T PDWORD BaseAddr
    )

{

    INTERNAL_STRUCTURE_TYPE StrucType = StructureTypeUnknown;
    INTERNAL_STRUCTURE_TYPE NewStrucType;

    *BaseAddr = Pointer;

    if (IsStreamPointer (Pointer)) StrucType = StructureType_KSSTREAM_POINTER;

    if (IsStreamPointer ((DWORD)
        (Pointer + FIELDOFFSET (KSPSTREAM_POINTER, Public)))) {
        NewStrucType = StructureType_KSSTREAM_POINTER;
        *BaseAddr = Pointer + FIELDOFFSET (KSPSTREAM_POINTER, Public);
        
        //
        // As with future additions, ensure this isn't a multiple match!
        //
        if (StrucType != StructureTypeUnknown)
            return StructureTypeUnknown;

        StrucType = NewStrucType;
    }

    return StrucType;

}

/*************************************************

    Function:

        DumpObjectQueueList

    Description:

        Dump an object queue list.  Note that if the caller specifies an 
        adjustment callback that returns NULL(0), the NULL pointer isn't
        printed.  This allows this function to be used as an iterator
        as well.

    Arguments:

        PLIST_HEAD -
            Points to the list head (InterlockedListHead.ListEntry)
            on the host

        TargetListStart -
            When ListEntry->Flink == TargetListStart, we are done. (Points
            to the top of the list on the target).  If this is 0, we assume
            a NULL terminated singly linked list; this also means that
            ObjHeadToListEntry is really FIELDOFFSET(object, Next)

        ObjHeadToListEntry -
            The distance between the object head and the list entry links.
            FIELDOFFSET(object, ListEntry)

        ObjEOL -
            Indicates termination between objects (on display), EOL or space.
            TRUE indicates EOL

        ObjAdjustmentCallback -
            A function that will adjust the acquired object pointer when
            displayed.

        ObjAdjustmentCallbackContext -
            A context blob which is passed to the object adjustment callback

    Return Value:

        Number of objects in the list


    Notes:

        - This function can be used as an iterator via an object adjustment
          function that returns NULL(0)

*************************************************/

ULONG
DumpObjQueueList (
    IN PLIST_ENTRY ListHead,
    IN DWORD TargetListStart,
    IN DWORD ObjHeadToListEntry,
    IN BOOLEAN ObjEOL,
    IN OBJECT_ADJUSTMENT_FUNCTION ObjAdjustmentCallback OPTIONAL,
    IN PVOID ObjAdjustmentCallbackContext OPTIONAL 
) {
    LIST_ENTRY ListEntry;
    DWORD PreviousObj;
    DWORD Obj, AdjustedObj;
    ULONG Count;
    ULONG Result;

    Count = 0;
    ListEntry = *ListHead;

    PreviousObj = 0;

    while ((DWORD)ListEntry.Flink != NULL && 
           (DWORD)ListEntry.Flink != TargetListStart &&
           !CheckControlC ()) {

        //
        // Grab an Irp out of the queue and dump it
        //
        if (TargetListStart != 0)
            Obj = (DWORD)ListEntry.Flink - ObjHeadToListEntry;
        else 
            Obj = (DWORD)ListEntry.Flink;

        if (Obj == PreviousObj) {
            dprintf (" LIST DUMP BUG: notify wmessmer please!\n");
            break;
        }

        if (!ReadMemory (
            (TargetListStart != 0) ?
                (DWORD)(ListEntry.Flink) :
                (DWORD)(Obj + ObjHeadToListEntry),
            &ListEntry,
            (TargetListStart != 0) ? sizeof (LIST_ENTRY) : sizeof (PVOID),
            &Result
        )) {
            dprintf ("%lx: unable to read object chain entry!\n",
                Obj);
            return Count;
        }

        if (ObjAdjustmentCallback) 
            AdjustedObj = ObjAdjustmentCallback (
                ObjAdjustmentCallbackContext, 
                Obj
                );
        else
            AdjustedObj = Obj;

        if (AdjustedObj != 0) {
            if (!ObjEOL) 
                dprintf ("%08lx ", AdjustedObj);
            else
                dprintf ("%08lx\n", AdjustedObj);
        }

        Count++;

        if (Count > DUMPOBJQUEUELIST_BAILOUT_COUNT)
            break;

        PreviousObj = Obj;

    }

    return Count;

}

/*************************************************

    Function:

        DumpPropertyItem

    Description:

        Dump a KSPROPERTY_ITEM.  This is a helper for DECLARE_API(automation)

    Arguments:

        Property -
            The property item to dump

        TabDepth -
            The tab depth to print this at

*************************************************/

void
DumpPropertyItem (
    IN PKSPROPERTY_ITEM Property,
    IN ULONG TabDepth,
    IN GUID *Set OPTIONAL
) {

    CHAR Buffer [1024];
    ULONG Displ;

    dprintf ("%sItem ID = ", Tab (TabDepth));
    if (!Set || 
        !DisplayNamedAutomationId (Set, Property -> PropertyId, "%s\n", NULL))
        dprintf ("%ld\n", Property -> PropertyId);

    if (Property -> GetPropertyHandler) {
        GetSymbol ((LPVOID)(Property -> GetPropertyHandler), Buffer, &Displ);
        if (Buffer [0] && Displ == 0) 
            dprintf ("%sGet Handler = %s\n", 
                Tab (TabDepth + 1),
                Buffer);
        else
            dprintf ("%sGet Handler = %08lx\n", 
                Tab (TabDepth + 1),
                Property -> GetPropertyHandler);
    } else 
        dprintf ("%sGet Handler = NULL\n", Tab (TabDepth + 1));

    if (Property -> SetPropertyHandler) {
        GetSymbol ((LPVOID)(Property -> SetPropertyHandler), Buffer, &Displ);
        if (Buffer [0] && Displ == 0)
            dprintf ("%sSet Handler = %s\n", 
                Tab (TabDepth + 1), Buffer);
        else
            dprintf ("%sSet Handler = %08lx\n",
                Tab (TabDepth + 1),
                Property -> SetPropertyHandler);
    } else 
        dprintf ("%sSet Handler = NULL\n", Tab (TabDepth + 1));


    dprintf ("%sMinProperty = %08lx\n",
        Tab (TabDepth + 1),
        Property -> MinProperty);
    dprintf ("%sMinData = %08lx\n",
        Tab (TabDepth + 1),
        Property -> MinData);

}

/*************************************************

    Function:

        DumpMethodItem

    Description:

        Dump a KSMETHOD_ITEM.  This is a helper for DECLARE_API(automation)

    Arguments:

        Method -
            The method item to dump

        TabDepth -
            The tab depth to print this at

*************************************************/

void
DumpMethodItem (
    IN PKSMETHOD_ITEM Method,
    IN ULONG TabDepth,
    IN GUID *Set OPTIONAL
) {

    CHAR Buffer [1024];
    ULONG Displ;

    dprintf ("%sItem ID = ", Tab (TabDepth));
    if (!Set || 
        !DisplayNamedAutomationId (Set, Method -> MethodId, "%s\n", NULL))
        dprintf ("%ld\n", Method -> MethodId);

    if (Method -> MethodHandler) {
        GetSymbol ((LPVOID)(Method -> MethodHandler), Buffer, &Displ);
        if (Buffer [0] && Displ == 0) 
            dprintf ("%sMethod Handler = %s\n", 
                Tab (TabDepth + 1), Buffer);
        else
            dprintf ("%sMethod Handler = %08lx\n", 
                Tab (TabDepth + 1),
                Method -> MethodHandler);
    } else 
        dprintf ("%sMethod Handler = NULL\n", Tab (TabDepth + 1));

    dprintf ("%sMinMethod = %08lx\n",
        Tab (TabDepth + 1),
        Method -> MinMethod);
    dprintf ("%sMinData = %08lx\n",
        Tab (TabDepth + 1),
        Method -> MinData);

}

/*************************************************

    Function:

        DumpEventItem

    Description:

        Dump a KSEVENT_ITEM.  This is a helper for DECLARE_API(automation)

    Arguments:

        Event -
            The event item to dump

        TabDepth -
            The tab depth to print this at

*************************************************/

void
DumpEventItem (
    IN PKSEVENT_ITEM Event,
    IN ULONG TabDepth,
    IN GUID *Set OPTIONAL
) {

    CHAR Buffer [1024];
    ULONG Displ;

    dprintf ("%sItem ID = ", Tab (TabDepth));
    if (!Set || 
        !DisplayNamedAutomationId (Set, Event -> EventId, "%s\n", NULL))
        dprintf ("%ld\n", Event -> EventId);

    if (Event -> AddHandler) {
        GetSymbol ((LPVOID)(Event -> AddHandler), Buffer, &Displ);
        if (Buffer [0] && Displ == 0) 
            dprintf ("%sAdd Handler = %s\n", Tab (TabDepth + 1), Buffer);
        else
            dprintf ("%sAdd Handler = %08lx\n", 
                Tab (TabDepth + 1),
                Event -> AddHandler);
    } else 
        dprintf ("%sAdd Handler = NULL\n");

    if (Event -> RemoveHandler) {
        GetSymbol ((LPVOID)(Event -> RemoveHandler), Buffer, &Displ);
        if (Buffer [0] && Displ == 0) 
            dprintf ("%sRemove Handler = %s\n", Tab (TabDepth + 1), Buffer);
        else
            dprintf ("%sRemove Handler = %08lx\n", 
                Tab (TabDepth + 1),
                Event -> RemoveHandler);
    } else 
        dprintf ("%sRemove Handler = NULL\n",
            Tab (TabDepth + 1));

    if (Event -> SupportHandler) {
        GetSymbol ((LPVOID)(Event -> SupportHandler), Buffer, &Displ);
        if (Buffer [0] && Displ == 0) 
            dprintf ("%sSupport Handler = %s\n", Tab (TabDepth + 1), Buffer);
        else
            dprintf ("%sSupport Handler = %08lx\n", 
                Tab (TabDepth + 1),
                Event -> SupportHandler);
    } else 
        dprintf ("%sSupport Handler = NULL\n", Tab (TabDepth + 1));

    dprintf ("%sDataInput = %08lx\n",
        Tab (TabDepth + 1),
        Event -> DataInput);
    dprintf ("%sExtraEntryData = %08lx\n",
        Tab (TabDepth + 1),
        Event -> ExtraEntryData);

}


/*************************************************

    Function:

        DumpExtEventList

    Description:

        Given an object EXT, dump the event list associated
        with that Ext.

    Arguments:

        ExtAddr -
            The address of the object ext

        TabDepth -
            The tab depth to print this at

    Return Value:

        Number of event items in the event list

    Notes:

*************************************************/

ULONG
DumpExtEventList (
    IN DWORD ExtAddr,
    IN ULONG TabDepth
) {

    KSPX_EXT Ext;
    ULONG Result;
    KSEVENT_ENTRY EventEntry;
    DWORD InitialList;
    ULONG EventCount = 0;

    if (!ReadMemory (
        ExtAddr,
        &Ext,
        sizeof (KSPX_EXT),
        &Result)) {

        dprintf ("%08lx: cannot read object ext!\n",
            ExtAddr);
        return EventCount;
    }

    EventEntry.ListEntry = Ext.EventList.ListEntry;

    InitialList = ExtAddr + 
        FIELDOFFSET (KSPX_EXT, EventList) +
        FIELDOFFSET (INTERLOCKEDLIST_HEAD, ListEntry);

    #ifdef DEBUG_EXTENSION
        dprintf ("EventEntry.ListEntry.Flink = %08lx\n",
            EventEntry.ListEntry.Flink);
        dprintf ("InitialList = %08lx\n", InitialList);
    #endif // DEBUG_EXTENSION

    //
    // Walk the event list, printing each entry as we go...
    //
    while ((DWORD)EventEntry.ListEntry.Flink != InitialList &&
        !CheckControlC ()) {

        PKSEVENT_ENTRY EntryAddr =
            (PKSEVENT_ENTRY)(CONTAINING_RECORD (
                EventEntry.ListEntry.Flink, KSEVENT_ENTRY, ListEntry));

        KSEVENT_SET Set;
        KSEVENT_ITEM Item;
        GUID Guid;

        if (!ReadMemory (
            (DWORD)EntryAddr,
            &EventEntry,
            sizeof (KSEVENT_ENTRY),
            &Result)) {

            dprintf ("%08lx: cannot read event entry!\n",
                EventEntry.ListEntry.Flink);
            return EventCount;
        }

        EventCount++;

        dprintf ("%sEvent Entry %08lx:\n", Tab (TabDepth), EntryAddr);
        dprintf ("%sFile Object       %08lx\n",
            Tab (TabDepth + 1), EventEntry.FileObject);
        dprintf ("%sNotification Type %08lx\n",
            Tab (TabDepth + 1), EventEntry.NotificationType);
        dprintf ("%sSet               %08lx : ", 
            Tab (TabDepth + 1), EventEntry.EventSet);

        if (!ReadMemory (
            (DWORD)EventEntry.EventSet,
            &Set,
            sizeof (KSEVENT_SET),
            &Result)) {

            dprintf ("%08lx: cannot read event set!\n",
                EventEntry.EventSet);
            return EventCount;
        }

        if (!ReadMemory (
            (DWORD)Set.Set,
            &Guid,
            sizeof (GUID),
            &Result)) {

            dprintf ("%08lx: cannot read event set guid!\n",
                Set.Set);
            return EventCount;
        }

        XTN_DUMPGUID ("\0", 0, Guid);

        if (!ReadMemory (
            (DWORD)EventEntry.EventItem,
            &Item,
            sizeof (KSEVENT_ITEM),
            &Result)) {

            dprintf ("%08lx: cannot read event item!\n",
                EventEntry.EventItem);
            return EventCount;
        }

        DumpEventItem (&Item, TabDepth  + 1, &Guid);

    }

    return EventCount;
}

/*************************************************

    Function:

        FindMatchAndDumpAutomationItem

    Description:

        Given an automation item, match it to the public object for
        a handler and dump it.

    Arguments:

        Item -
            Automation item

        Public -
            The public to match it to (target addr)

        AutomationType -
            The automation type to match against (property, method, event)

        TabDepth -
            The depth to print at

    Return Value:

        Successful / non successful match

*************************************************/

//
// Internal structures from automat.cpp; these are private.  Maybe I should
// move these to avstream.h or do some #include <automat.cpp>
//

typedef struct KSPAUTOMATION_SET_ { 
    GUID* Set;
    ULONG ItemsCount;
    PVOID Items;
    ULONG FastIoCount;
    PVOID FastIoTable;
} KSPAUTOMATION_SET, *PKSPAUTOMATION_SET;

typedef struct {
    ULONG SetsCount;
    ULONG ItemSize;
    PKSPAUTOMATION_SET Sets;
} KSPAUTOMATION_TYPE, *PKSPAUTOMATION_TYPE;

BOOLEAN
FindMatchAndDumpAutomationItem (
    IN PKSIDENTIFIER Item,
    IN DWORD Public,
    IN AUTOMATION_TYPE AutomationType,
    IN ULONG TabDepth,
    IN ULONG NodeId OPTIONAL
    )

{

    //
    // First, I need to adjust public to the public ext object.  Then I
    // need to ensure that the ext is at least vaguely resembling an ext.
    // Find the automation table, and search it for Item...  then dump
    // the matching item
    //
    PKSPX_EXT ExtAddr;
    KSPX_EXT Ext;
    ULONG Result;

    ExtAddr = (PKSPX_EXT)CONTAINING_RECORD (Public, KSPX_EXT, Public);
    if (!ReadMemory (
        (DWORD)ExtAddr,
        &Ext,
        sizeof (KSPX_EXT),
        &Result)) {

        dprintf ("%08lx: unable to read ext!\n", ExtAddr);
        return FALSE;
    }

    //
    // Only find and match automation items on filter (&fac), pin objects.
    //
    if (Ext.ObjectType != KsObjectTypeFilterFactory &&
        Ext.ObjectType != KsObjectTypeFilter &&
        Ext.ObjectType != KsObjectTypePin)
        return FALSE;

    KSAUTOMATION_TABLE Table;
    PKSAUTOMATION_TABLE NodeAutomationTable = NULL;

    //
    // topology flag better match on all 3 types....
    //
    if (Item->Flags & KSPROPERTY_TYPE_TOPOLOGY) {
        NodeAutomationTable = GetNodeAutomationTablePointer (
            Public, NodeId
            );
    }

    if (!ReadMemory (
        NodeAutomationTable ? 
            (DWORD)NodeAutomationTable : (DWORD)Ext.AutomationTable,
        &Table,
        sizeof (KSAUTOMATION_TABLE),
        &Result)) {

        dprintf ("%08lx: cannot read ext automation table!\n",
            Ext.AutomationTable);
        return FALSE;
    }

    PKSPAUTOMATION_TYPE KsAutomationType = NULL;

    switch (AutomationType) {
        case AutomationProperty:
            KsAutomationType = 
                (PKSPAUTOMATION_TYPE)(&(Table.PropertySetsCount));
            break;
        case AutomationMethod:
            KsAutomationType = (PKSPAUTOMATION_TYPE)(&(Table.MethodSetsCount));
            break;
        case AutomationEvent:
            KsAutomationType = (PKSPAUTOMATION_TYPE)(&(Table.EventSetsCount));
            break;
    }

    if (!KsAutomationType)
        return FALSE;

    //
    // foreach set...
    //
    PKSPAUTOMATION_SET AutomationSet = KsAutomationType->Sets;
    for (ULONG cset = 0; cset < KsAutomationType -> SetsCount; cset++,
        AutomationSet++) {

        KSPAUTOMATION_SET CurrentSet;
        GUID set;

        if (!ReadMemory (
            (DWORD)AutomationSet,
            &CurrentSet,
            sizeof (KSPAUTOMATION_SET),
            &Result))
            return FALSE;

        if (!ReadMemory (
            (DWORD)CurrentSet.Set,
            &set,
            sizeof (GUID),
            &Result))
            return FALSE;

        //
        // If the set guids don't match....  don't bother...
        //
        if (RtlCompareMemory (&Item->Set, &set, sizeof (GUID)) != sizeof (GUID))
            continue;

        //
        // foreach item
        //
        PVOID CurItem = (PVOID)CurrentSet.Items;
        for (ULONG citem = 0; citem < CurrentSet.ItemsCount; citem++) {
            //
            // Check whether or not this is a match based on automation type
            //
            switch (AutomationType) {

                case AutomationProperty:
                {
                    KSPROPERTY_ITEM PropertyItem;

                    if (!ReadMemory (
                        (DWORD)CurItem,
                        &PropertyItem,
                        sizeof (KSPROPERTY_ITEM),
                        &Result))
                        return FALSE;

                    if (PropertyItem.PropertyId == Item->Id) {

                        //
                        // Horrah... we have a match
                        //

                        dprintf ("%sMatching Property Handler:\n",
                            Tab (TabDepth));
                        DumpPropertyItem (&PropertyItem, TabDepth + 1,
                            &Item -> Set
                            );

                        //
                        // There will not be a second match...  can the
                        // search.
                        //
                        return TRUE;

                    }

                    break;
                }

                case AutomationMethod:
                {
                    KSMETHOD_ITEM MethodItem;

                    if (!ReadMemory (
                        (DWORD)CurItem,
                        &MethodItem,
                        sizeof (KSMETHOD_ITEM),
                        &Result))
                        return FALSE;

                    if (MethodItem.MethodId == Item->Id) {

                        dprintf ("%sMatching Method Handler:\n",
                            Tab (TabDepth));
                        DumpMethodItem (&MethodItem, TabDepth + 1,
                            &Item -> Set);

                        return TRUE;
                    }

                    break;


                }

                case AutomationEvent:
                {
                    KSEVENT_ITEM EventItem;

                    if (!ReadMemory (
                        (DWORD)CurItem,
                        &EventItem,
                        sizeof (KSEVENT_ITEM),
                        &Result))
                        return FALSE;

                    if (EventItem.EventId == Item->Id) {

                        dprintf ("%sMatching Event Handler:\n",
                            Tab (TabDepth));
                        DumpEventItem (&EventItem, TabDepth + 1, &Item -> Set);

                        return TRUE;

                    }

                    break;

                }

                default:
                    return FALSE;

            }

            CurItem = (PVOID)((PUCHAR)CurItem + KsAutomationType -> ItemSize);

        }
    }

    return FALSE;
}

/*************************************************

    Function:

        DumpAutomationIrp

    Description:

        Given an Irp that is IOCTL_KS_* [automation], dump the relevant
        information.

    Arguments:

        Irp -
            Points to an Irp on the HOST system, not the TARGET system

        IoStack -
            Points to the current io stack for Irp on the HOST system.

        TabDepth -
            The tab depth to print info at

        Public -
            The public object the Irp refers to.  This should never be
            the parent object (only for creates)

*************************************************/

//
// Lay out string tables for the property flag names, etc...  Just
// for debug output in a more readable form.
//
char AutomationFlags[][29][48] = {
    {
        "KSPROPERTY_TYPE_GET",              // 00000001
        "KSPROPERTY_TYPE_SET",              // 00000002
        "*** INVALID ***",                  // 00000004
        "*** INVALID ***",                  // 00000008
        "*** INVALID ***",                  // 00000010
        "*** INVALID ***",                  // 00000020
        "*** INVALID ***",                  // 00000040
        "*** INVALID ***",                  // 00000080
        "KSPROPERTY_TYPE_SETSUPPORT",       // 00000100
        "KSPROPERTY_TYPE_BASICSUPPORT",     // 00000200
        "KSPROPERTY_TYPE_RELATIONS",        // 00000400
        "KSPROPERTY_TYPE_SERIALIZESET",     // 00000800
        "KSPROPERTY_TYPE_UNSERIALIZESET",   // 00001000
        "KSPROPERTY_TYPE_SERIALIZERAW",     // 00002000
        "KSPROPERTY_TYPE_UNSERIALIZERAW",   // 00004000
        "KSPROPERTY_TYPE_SERIALIZESIZE",    // 00008000
        "KSPROPERTY_TYPE_DEFAULTVALUES",    // 00010000
        "*** INVALID ***",                  // 00020000
        "*** INVALID ***",                  // 00040000
        "*** INVALID ***",                  // 00080000
        "*** INVALID ***",                  // 00100000
        "*** INVALID ***",                  // 00200000
        "*** INVALID ***",                  // 00400000
        "*** INVALID ***",                  // 00800000
        "*** INVALID ***",                  // 01000000
        "*** INVALID ***",                  // 02000000
        "*** INVALID ***",                  // 04000000
        "*** INVALID ***",                  // 08000000
        "KSPROPERTY_TYPE_TOPOLOGY"          // 10000000
    },
    {
        "KSMETHOD_TYPE_READ [SEND]",        // 00000001
        "KSMETHOD_TYPE_WRITE",              // 00000002
        "KSMETHOD_TYPE_SOURCE",             // 00000004
        "*** INVALID ***",                  // 00000008
        "*** INVALID ***",                  // 00000010
        "*** INVALID ***",                  // 00000020
        "*** INVALID ***",                  // 00000040
        "*** INVALID ***",                  // 00000080
        "KSMETHOD_TYPE_SETSUPPORT",         // 00000100
        "KSMETHOD_TYPE_BASICSUPPORT",       // 00000200
        "*** INVALID ***",                  // 00000400
        "*** INVALID ***",                  // 00000800
        "*** INVALID ***",                  // 00001000
        "*** INVALID ***",                  // 00002000
        "*** INVALID ***",                  // 00004000
        "*** INVALID ***",                  // 00008000
        "*** INVALID ***",                  // 00010000
        "*** INVALID ***",                  // 00020000
        "*** INVALID ***",                  // 00040000
        "*** INVALID ***",                  // 00080000
        "*** INVALID ***",                  // 00100000
        "*** INVALID ***",                  // 00200000
        "*** INVALID ***",                  // 00400000
        "*** INVALID ***",                  // 00800000
        "*** INVALID ***",                  // 01000000
        "*** INVALID ***",                  // 02000000
        "*** INVALID ***",                  // 04000000
        "*** INVALID ***",                  // 08000000
        "KSMETHOD_TYPE_TOPOLOGY"            // 10000000
    },
    {
        "KSEVENT_TYPE_ENABLE",              // 00000001
        "KSEVENT_TYPE_ONESHOT",             // 00000002
        "KSEVENT_TYPE_ENABLEBUFFERED",      // 00000004
        "*** INVALID ***",                  // 00000008
        "*** INVALID ***",                  // 00000010
        "*** INVALID ***",                  // 00000020
        "*** INVALID ***",                  // 00000040
        "*** INVALID ***",                  // 00000080
        "KSEVENT_TYPE_SETSUPPORT",          // 00000100
        "KSEVENT_TYPE_BASICSUPPORT",        // 00000200
        "KSEVENT_TYPE_QUERYBUFFER",         // 00000400
        "*** INVALID ***",                  // 00000800
        "*** INVALID ***",                  // 00001000
        "*** INVALID ***",                  // 00002000
        "*** INVALID ***",                  // 00004000
        "*** INVALID ***",                  // 00008000
        "*** INVALID ***",                  // 00010000
        "*** INVALID ***",                  // 00020000
        "*** INVALID ***",                  // 00040000
        "*** INVALID ***",                  // 00080000
        "*** INVALID ***",                  // 00100000
        "*** INVALID ***",                  // 00200000
        "*** INVALID ***",                  // 00400000
        "*** INVALID ***",                  // 00800000
        "*** INVALID ***",                  // 01000000
        "*** INVALID ***",                  // 02000000
        "*** INVALID ***",                  // 04000000
        "*** INVALID ***",                  // 08000000
        "KSEVENT_TYPE_TOPOLOGY"             // 10000000
    }
};

char AutomationTypeNames[][32] = {
    "unknown",
    "property",
    "method",
    "event"
};

void
DumpAutomationIrp (
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IoStack,
    IN AUTOMATION_TYPE AutomationType,
    IN ULONG TabDepth,
    IN DWORD Public OPTIONAL
    )

{

    PKSIDENTIFIER AutomationAddr = (PKSIDENTIFIER)
        IoStack->Parameters.DeviceIoControl.Type3InputBuffer;

    ULONG NodeId;

    //
    // Automation object information
    //
    KSIDENTIFIER AutomationObject;

    UCHAR Buffer [1024];
    ULONG Displ;
    ULONG Result;

    AUTOMATION_DUMP_HANDLER DumpHandler;

    if (!ReadMemory (
        (DWORD)AutomationAddr,
        &AutomationObject,
        sizeof (KSIDENTIFIER),
        &Result)) {

        dprintf ("%08lx: cannot read automation object!\n",
            AutomationAddr);
        return;
    }

    dprintf ("%sIRP has associated %s structure %ld:\n",
        Tab (TabDepth), AutomationTypeNames [AutomationType], AutomationType);

    dprintf ("%sSet", Tab (TabDepth + 1));
    if (!DisplayNamedAutomationSet (&AutomationObject.Set, " %s\n")) {
        XTN_DUMPGUID(" ", 0, (AutomationObject.Set));
    }

    dprintf ("%sItem ", Tab (TabDepth + 1));
    if (!DisplayNamedAutomationId (&AutomationObject.Set, AutomationObject.Id,
        "%s\n", &DumpHandler))
        dprintf ("%ld\n", AutomationObject.Id);

    //
    // Future expansion: should anyone want to add handlers for specific
    // properties...  This will cause them to be invoked.  The handlers are
    // all specified in the tables in strlib.c
    //
    if (DumpHandler)
        DumpHandler (AutomationAddr, TabDepth);

    //
    // Make sure I'm not being an idiot.
    //
    if (KSPROPERTY_TYPE_TOPOLOGY != KSMETHOD_TYPE_TOPOLOGY ||
        KSMETHOD_TYPE_TOPOLOGY != KSEVENT_TYPE_TOPOLOGY) {
        dprintf ("ERROR: someone needs to update the extension!  Topology\n"
                 "       flags no longer match property/method/event!\n");
        return;
    }

    //
    // If this really isn't automation on the object but on a topology node
    // instead, detect and dump relevant information regarding topology.
    //
    if (AutomationObject.Flags & KSPROPERTY_TYPE_TOPOLOGY) {

        //
        // Note that KSM_NODE, KSE_NODE, and KSP_NODE should have NodeId
        // at the same offset since KSPROPERTY, KSMETHOD, and KSEVENT are all
        // KSIDENTIFIERs.  The types should be identical which is why the
        // offset into KSP_NODE is used here.
        //
        if (!ReadMemory (
            (DWORD)AutomationAddr + FIELDOFFSET(KSP_NODE, NodeId),
            &NodeId,
            sizeof (ULONG),
            &Result)) {

            dprintf ("%08lx: unable to read node id!\n", AutomationAddr);
            return;

        }

        //
        // Dump information if the topology node is involved.
        // 
        // BUGBUG: detail this.
        //
        dprintf ("%sQuery for topology node id = %ld\n", Tab (TabDepth + 1), 
            NodeId);
    }

    dprintf ("%sFlags\n", Tab (TabDepth + 1));
    dprintf ("%s", Tab (TabDepth + 2));

    //
    // Dump out all flags...  Note that KS*_TYPE_TOPOLOGY are the same.
    //
    ULONG i = KSPROPERTY_TYPE_TOPOLOGY;
    ULONG aid = 28;
    ULONG flagcount = 0;

    do {
        if (AutomationObject.Flags & i) {
            dprintf ("%s ", AutomationFlags [AutomationType - 1][aid]);
            flagcount++;
        }

        if (i == 0)
            break;

        i >>= 1;
        aid--;

    } while (1);

    // 
    // This should never happen...  it's a bogus automation if it does.
    //
    if (!flagcount)
        dprintf ("%sNone (bogus %s!)", Tab (TabDepth + 2),
            AutomationTypeNames [AutomationType]);

    dprintf ("\n");

    if (Public) {
	dprintf ("\n");
        if (!FindMatchAndDumpAutomationItem (&AutomationObject, 
            Public, AutomationType, TabDepth, NodeId)) {
            dprintf ("%sThere is no handler for this %s!\n",
                Tab (TabDepth), AutomationTypeNames [AutomationType]);
        }
    }


    dprintf ("\n");

}

/*************************************************

    Function:

        DumpAssociatedIrpInfo

    Description:

        Given that a client has !ks.dump irp 7 (or something such as this),
        take the given Irp passed in and dump any associated information
        with the Irp.

    Arguments:

        IrpAddr -
            Points to the irp on the target system

        TabDepth -
            The tabbing depth to print this at

        Public -
            The public adjusted object for this Irp.  For a child
            object in the process of creation, this should be the parent
            object.

*************************************************/

void 
DumpAssociatedIrpInfo (
    IN PIRP IrpAddr,
    IN ULONG TabDepth,
    IN DWORD Public OPTIONAL
    )

{

    IRP Irp;
    IO_STACK_LOCATION IoStack;

    ULONG Result;

    #ifdef DEBUG_EXTENSION
        if (!signature_check ((DWORD)IrpAddr, SignatureIrp))
            return;
    #endif // DEBUG_EXTENSION

    //
    // Read the irp
    //
    if (!ReadMemory (
        (DWORD)IrpAddr,
        &Irp,
        sizeof (IRP),
        &Result)) {

        dprintf ("%08lx: cannot read Irp!\n", IrpAddr);
        return;
    }

    if (!ReadMemory (
        (DWORD)Irp.Tail.Overlay.CurrentStackLocation,
        &IoStack,
        sizeof (IO_STACK_LOCATION),
        &Result)) {

        dprintf ("%08lx: cannot read stack location of irp!\n",
            Irp.Tail.Overlay.CurrentStackLocation);
        return;
    }

    #ifdef DEBUG_EXTENSION
        dprintf ("associated irp io stack major func = %ld\n",
            (ULONG)IoStack.MajorFunction);
    #endif // DEBUG_EXTENSION

    //
    // Now, begin checking major/minor for things that we know information
    // about and can justify an extra dump for.
    //
    if (IoStack.MajorFunction == IRP_MJ_DEVICE_CONTROL) {
        
        //
        // It's a control IOCTL.  See if this is a method, property, or
        // event request.
        //
        switch (IoStack.Parameters.DeviceIoControl.IoControlCode) {

            case IOCTL_KS_PROPERTY:
                DumpAutomationIrp (&Irp, &IoStack, AutomationProperty, 
                    INITIAL_TAB, Public);
                break;
        
            case IOCTL_KS_METHOD:
                DumpAutomationIrp (&Irp, &IoStack, AutomationMethod,
                    INITIAL_TAB, Public);
                break;

            default:
                break;

        }
    }
}


/**************************************************************************

    Routines to dump private AVStream objects

**************************************************************************/

/*************************************************

    Function:

        DumpPrivateBranch

    Description:

        Given the address of a CKsSplitterBranch object on the target,
        duimp information about that branch object.

    Arguments:

        Private -
            The address of the CKsSplitterBranch

        Level -
            The 0-7 level of output

        TabDepth -
            The tab depth to print this at

    Return Value:

        None

*************************************************/

void
DumpPrivateBranch (
    IN DWORD Private,
    IN ULONG Level,
    IN ULONG TabDepth
    )

{

    CMemoryBlock <CKsSplitterBranch> BranchObject;
    ULONG Result;
    ULONG Count;

    if (!ReadMemory (
        Private,
        BranchObject.Get (),
        sizeof (CKsSplitterBranch),
        &Result)) {

        dprintf ("%08lx: cannot read branch object!\n", Private);
        return;
    }

    dprintf ("%sCKsSplitterBranch object %08lX\n", Tab (TabDepth), Private);
    TabDepth++;
    dprintf ("%sReference Count          %ld\n",
        Tab (TabDepth),
        GetObjectReferenceCount ((CBaseUnknown *)
            ((CKsSplitterBranch *)Private)));

    dprintf ("%sManaging Splitter        %08lx\n",
        Tab (TabDepth), BranchObject -> m_Splitter);

    dprintf ("%sBranch Pin               %08lx\n",
        Tab (TabDepth), BranchObject -> m_Pin);

    dprintf ("%sCompression/Expansion    %ld:%ld [constant margin = %ld]\n",
        Tab (TabDepth), BranchObject -> m_Compression.RatioNumerator,
        BranchObject -> m_Compression.RatioDenominator,
        BranchObject -> m_Compression.RatioConstantMargin
        );

    dprintf ("%sData Used                %ld bytes (0x%08lx)\n",
        Tab (TabDepth), BranchObject -> m_DataUsed,
        BranchObject -> m_DataUsed);

    dprintf ("%sFrame Extent             %ld bytes (0x%08lx)\n",
        Tab (TabDepth), BranchObject -> m_FrameExtent,
        BranchObject -> m_FrameExtent);

    if (Level >= DUMPLVL_HIGHDETAIL) {
    
        dprintf ("%sIrps Available:\n", Tab (TabDepth));
        dprintf ("%s", Tab (TabDepth + 1));
        Count = DumpObjQueueList (
            &(BranchObject -> m_IrpsAvailable.ListEntry),
            FIELDOFFSET (CKsSplitterBranch, m_IrpsAvailable) + Private +
                FIELDOFFSET (INTERLOCKEDLIST_HEAD, ListEntry),
            FIELDOFFSET (IRP, Tail.Overlay.ListEntry),
            FALSE,
            NULL,
            NULL
            );
    
        if (Count == 0)
            dprintf ("There are no Irps available!\n");
        else
            dprintf ("\n");
    }
    
}

/*************************************************

    Function:
        
        DumpPrivateSplitter

    Description:

        Given the address of a CKsSplitter object on the target,
        dump information about that splitter object.

    Arguments:

        Private -
            The address of the CKsSplitter

        Level -
            The 0-7 level of output

        TabDepth -
            The tab depth to print this at

    Return Value:

        None

    Notes:

*************************************************/

typedef struct _BRANCH_ITERATOR_CONTEXT {
    
    ULONG Level;
    ULONG TabDepth;

} BRANCH_ITERATOR_CONTEXT, *PBRANCH_ITERATOR_CONTEXT;

DWORD
BranchIteratorCallback (
    IN PVOID Context,
    IN DWORD Object
    )

{

    PBRANCH_ITERATOR_CONTEXT BranchContext = (PBRANCH_ITERATOR_CONTEXT)Context;

    DumpPrivateBranch (
        Object,
        BranchContext -> Level,
        BranchContext -> TabDepth
        );

    //
    // This return code instructs the iterator not to actually "dump" the
    // information.
    //
    return 0;

}

void
DumpPrivateSplitter (
    IN DWORD Private,
    IN ULONG Level,
    IN ULONG TabDepth
    )

{

    CMemoryBlock <CKsSplitter> SplitterObject;
    ULONG Result;
    ULONG Count, BranchCount;

    if (!ReadMemory (
        Private,
        SplitterObject.Get (),
        sizeof (CKsSplitter),
        &Result)) {

        dprintf ("%08lx: cannot read splitter object!\n", Private);
        return;
    }

    dprintf ("%sCKsSplitter object %08lX\n", Tab (TabDepth), Private);
    TabDepth++;
    dprintf ("%sReference Count          %ld\n",
        Tab (TabDepth),
        GetObjectReferenceCount ((CBaseUnknown *)((CKsSplitter *)Private)));

    dprintf ("%sBranches Managed By This Splitter:\n", Tab (TabDepth));
    dprintf ("%s", Tab (TabDepth + 1));
    BranchCount = DumpObjQueueList (
        &(SplitterObject -> m_BranchList),
        FIELDOFFSET (CKsSplitter, m_BranchList) + Private,
        FIELDOFFSET (CKsSplitterBranch, m_ListEntry),
        FALSE,
        NULL,
        NULL
        );
    if (BranchCount == 0) 
        dprintf ("There are no branches managed by this splitter yet!\n");
    else 
        dprintf ("\n");

    if (Level >= DUMPLVL_INTERNAL) {
        dprintf ("%sParent Frame Headers Available:\n", Tab (TabDepth));
        dprintf ("%s", Tab (TabDepth + 1));
        Count = DumpObjQueueList (
            &(SplitterObject -> m_FrameHeadersAvailable.ListEntry),
            FIELDOFFSET (CKsSplitter, m_FrameHeadersAvailable) + Private +
                FIELDOFFSET (INTERLOCKEDLIST_HEAD, ListEntry),
            FIELDOFFSET (KSPPARENTFRAME_HEADER, ListEntry),
            FALSE,
            NULL,
            NULL
            );

        if (Count == 0)
            dprintf ("There are no parent frame headers available!\n");
        else
            dprintf ("\n");
    }

    if (Level >= DUMPLVL_HIGHDETAIL) {
    
        dprintf ("%sIrps Outstanding:\n", Tab (TabDepth));
        dprintf ("%s", Tab (TabDepth + 1));
        Count = DumpObjQueueList (
            &(SplitterObject -> m_IrpsOutstanding.ListEntry),
            FIELDOFFSET (CKsSplitter, m_IrpsOutstanding) + Private +
                FIELDOFFSET (INTERLOCKEDLIST_HEAD, ListEntry),
            FIELDOFFSET (IRP, Tail.Overlay.ListEntry),
            FALSE,
            NULL,
            NULL
            );
    
    
        if (Count == 0)
            dprintf ("There are no Irps outstanding!\n");
        else
            dprintf ("\n");
    }

    if (Level >= DUMPLVL_EVERYTHING && BranchCount > 0) {

        dprintf ("\n%sManaged Branches :\n", Tab (TabDepth));

        BRANCH_ITERATOR_CONTEXT BranchContext;

        BranchContext.TabDepth = TabDepth + 1;
        BranchContext.Level = Level;

        Count = DumpObjQueueList (
            &(SplitterObject -> m_BranchList),
            FIELDOFFSET (CKsSplitter, m_BranchList) + Private,
            FIELDOFFSET (CKsSplitterBranch, m_ListEntry),
            FALSE,
            BranchIteratorCallback,
            (PVOID)&BranchContext
            );

    }

}

/*************************************************

    Function:

        DumpPrivateRequestor

    Description:

        Given the address of a CKsRequestor object on the target,
        dump information about that requestor object.

    Arguments:

        Private -
            The address of the CKsRequestor

        Level -
            The 0-7 level of output

        TabDepth -
            The tab depth to print this at

    Return Value:

        None

    Notes:

*************************************************/

void
DumpPrivateRequestor (
    IN DWORD Private,
    IN ULONG Level,
    IN ULONG TabDepth
) {

    CMemoryBlock <CKsRequestor> RequestorObject;
    ULONG Result;

    if (!ReadMemory (
        Private,
        RequestorObject.Get (),
        sizeof (CKsRequestor),
        &Result
    )) {
        dprintf ("%08lx: unable to read requestor object!\n",
            Private);
        return;
    }

    dprintf ("%sCKsRequestor object %08lX\n", Tab (TabDepth), Private);
    TabDepth++;
    dprintf ("%sReference Count          %ld\n",
        Tab (TabDepth),
        GetObjectReferenceCount ((CBaseUnknown *)((CKsRequestor *)Private)));
    dprintf ("%sOwning PIKSPIPESECTION   %08lx\n", 
        Tab (TabDepth),
        RequestorObject -> m_PipeSection);
    dprintf ("%sAssociated PIKSPIN       %08lx\n",
        Tab (TabDepth),
        RequestorObject -> m_Pin);
    dprintf ("%sAssociated Allocator     %08lx\n",
        Tab (TabDepth),
        RequestorObject -> m_AllocatorFileObject);

    dprintf ("%sState                    %ld\n", 
        Tab (TabDepth),
        RequestorObject -> m_State);
    dprintf ("%sFrame Size               %08lx\n", 
        Tab (TabDepth),
        RequestorObject -> m_FrameSize);
    dprintf ("%sFrame Count              %ld\n",
        Tab (TabDepth),
        RequestorObject -> m_FrameCount);
    dprintf ("%sActive Frame Count       %ld\n",
        Tab (TabDepth),
        RequestorObject -> m_ActiveFrameCountPlusOne - 1);
    
    if (Level >= DUMPLVL_HIGHDETAIL) {
        ULONG Count;

        dprintf ("%sIrps Available:\n", Tab (TabDepth));
        dprintf ("%s", Tab (TabDepth + 1));
        Count = DumpObjQueueList (
            &(RequestorObject -> m_IrpsAvailable.ListEntry),
            FIELDOFFSET(CKsRequestor, m_IrpsAvailable) + Private +
                FIELDOFFSET(INTERLOCKEDLIST_HEAD, ListEntry),
            FIELDOFFSET(IRP, Tail.Overlay.ListEntry),
            FALSE,
            NULL,
            NULL
        );
        if (Count == 0)
            dprintf ("There are no available Irps!\n");
        else
            dprintf ("\n");

    }

    if (Level >= DUMPLVL_INTERNALDETAIL) {
        ULONG Count;

        dprintf ("%sFrame Headers Available:\n", Tab (TabDepth));
        dprintf ("%s", Tab (TabDepth + 1));
        Count = DumpObjQueueList (
            &(RequestorObject -> m_FrameHeadersAvailable.ListEntry),
            FIELDOFFSET(CKsRequestor, m_FrameHeadersAvailable) + Private +
                FIELDOFFSET(INTERLOCKEDLIST_HEAD, ListEntry),
            FIELDOFFSET(KSPFRAME_HEADER, ListEntry),
            FALSE,
            NULL,
            NULL
        );
        if (Count == 0)
            dprintf ("There are no available frame headers!\n");
        else
            dprintf ("\n");

        dprintf ("%sFrame Headers Waiting To Be Retired:\n", Tab (TabDepth));
        dprintf ("%s", Tab (TabDepth + 1));
        Count = DumpObjQueueList (
            &(RequestorObject -> m_FrameHeadersToRetire.ListEntry),
            FIELDOFFSET(CKsRequestor, m_FrameHeadersToRetire) + Private +
                FIELDOFFSET(INTERLOCKEDLIST_HEAD, ListEntry),
            FIELDOFFSET(KSPFRAME_HEADER, ListEntry),
            FALSE,
            NULL,
            NULL
        );
        if (Count == 0)
            dprintf ("There are no frame headers waiting for retirement!\n");
        else
            dprintf ("\n");

    }

}

/*************************************************

    Function:

        DumpPrivatePin

    Description:

        Given the address of a CKsPin object on the target,
        dump information about that pin object.

    Arguments:

        Private -
            The address of the CKsPin

        Level -
            The 0-7 level of output

    Return Value:

        None

    Notes:

*************************************************/

DWORD AdjustIrpListEntryToIrp (
    IN PVOID Context,
    IN DWORD IrpListEntry
) {
    DWORD IrpAddress =
        IrpListEntry + FIELDOFFSET(IRPLIST_ENTRY, Irp);
    PIRP Irp;
    ULONG Result;

    if (!ReadMemory (
        IrpAddress,
        &Irp,
        sizeof (PIRP),
        &Result
    )) 
        return IrpListEntry;

    return (DWORD)Irp;

}

void
DumpPrivatePin (
    IN DWORD Private,
    IN ULONG Level,
    IN ULONG TabDepth
) {

    ULONG Result;

    CMemoryBlock <CKsPin> PinObject;

    if (!ReadMemory (
        Private,
        PinObject.Get (),
        sizeof (CKsPin),
        &Result
    )) {
        dprintf ("%lx: unable to read private pin object!\n",
            Private);
        return;
    }

    dprintf ("%sCKsPin object %08lX [corresponding EXT = %08lx, KSPIN = %08lx]"
        "\n", Tab (TabDepth),
        Private, FIELDOFFSET(CKsPin, m_Ext) + Private, 
        FIELDOFFSET(CKsPin, m_Ext) + FIELDOFFSET(KSPIN_EXT, Public) + Private
    );
    TabDepth++;
    dprintf ("%sReference Count          %ld\n",
        Tab (TabDepth),
        GetObjectReferenceCount ((CBaseUnknown *)((CKsPin *)Private)));

    //
    // Dump INTRA / EXTRA status.  If the pin is a source pin or an intra-
    // pin, dump the connected pin.
    //
    if (Level >= DUMPLVL_INTERNAL) {
        if (PinObject -> m_ConnectedPinInterface) {
            dprintf ("%sConnection Type          INTRA\n", Tab (TabDepth));
            dprintf ("%sConnected Intra-Pin      %08lx\n", 
                Tab (TabDepth), 
                (CKsPin *)(PinObject -> m_ConnectedPinInterface)
                );
        } else {
            dprintf ("%sConnection Type          EXTRA\n", Tab (TabDepth));
        }

        PFILE_OBJECT ConnectedFileObject = NULL;
        CKsPin *ConnectedPin = NULL;
        CMemoryBlock <CKsPin> ConnectedPinObject;

        //
        // Source pins have the sink file object.  Intra sinks have the
        // interface exchanged from which we can retrieve the pin object
        // and hence the connected pin object's internal file object.
        //
        if (PinObject -> m_ConnectionFileObject) 
            ConnectedFileObject = PinObject -> m_ConnectionFileObject;
        else {

            if (PinObject -> m_ConnectedPinInterface) {

                ConnectedPin = static_cast <CKsPin *> 
                    (PinObject -> m_ConnectedPinInterface);

                if (!ReadMemory (
                    (DWORD)ConnectedPin,
                    ConnectedPinObject.Get (),
                    sizeof (CKsPin),
                    &Result
                    )) {
                    dprintf ("%lx: unable to read connected pin object!\n",
                        ConnectedPin);
                    return;
                }

                ConnectedFileObject = ConnectedPinObject -> m_FileObject;

            }
        
        }

        //
        // If we have an extra-source or an intra-* pin, dump information about
        // the connected pin.
        //
        if (ConnectedFileObject) {

            FILE_OBJECT FileObject;

            if (!ReadMemory (
                (DWORD)ConnectedFileObject,
                &FileObject,
                sizeof (FILE_OBJECT),
                &Result
                )) {
                dprintf ("%lx: unable to read file object!\n",
                    ConnectedFileObject);
                return;
            }

            //
            // We don't really want to print the driver owning the PDO...
            // Walk to the top of the device stack and print the top
            // of the stack.  
            //
            PDEVICE_OBJECT DeviceObject = FileObject.DeviceObject;
            PDEVICE_OBJECT AttachedDevice = FileObject.DeviceObject;

            while (AttachedDevice) {
                if (!ReadMemory (
                    ((DWORD)DeviceObject) + 
                        FIELDOFFSET (DEVICE_OBJECT, AttachedDevice),
                    &AttachedDevice,
                    sizeof (PDEVICE_OBJECT),
                    &Result
                    )) {
                    dprintf ("%lx: cannot walk device stack!\n",
                        AttachedDevice);
                    return;
                }

                if (AttachedDevice)
                    DeviceObject = AttachedDevice;
            }

            //
            // Find out the owning driver.
            //
            DWORD DriverObjAddr, NameAddr;
            PDRIVER_OBJECT DriverObject;
            UNICODE_STRING Name;
    
            DriverObjAddr = (DWORD)DeviceObject +
                FIELDOFFSET(DEVICE_OBJECT, DriverObject);
    
            if (ReadMemory (
                DriverObjAddr,
                &DriverObject,
                sizeof (PDRIVER_OBJECT),
                &Result
            )) {
    
                NameAddr = (DWORD)DriverObject +
                    FIELDOFFSET(DRIVER_OBJECT, DriverName);
        
                if (ReadMemory (
                    NameAddr,
                    &Name,
                    sizeof (UNICODE_STRING),
                    &Result
                )) {
        
                    PWSTR Buffer = (PWSTR)malloc (
                        Name.MaximumLength * sizeof (WCHAR));
        
                    UNICODE_STRING HostString;
        
                    //
                    // We have the unicode string name...  Allocate 
                    // enough memory to read the thing.
                    //
        
                    if (!ReadMemory (
                        (DWORD)Name.Buffer,
                        Buffer,
                        sizeof (WCHAR) * Name.MaximumLength,
                        &Result
                    )) {
                        dprintf ("%08lx: unable to read unicode string"
                            "buffer!\n", Name.Buffer);
                        return;
                    }
        
                    HostString.MaximumLength = Name.MaximumLength;
                    HostString.Length = Name.Length;
                    HostString.Buffer = Buffer;
    
                    dprintf ("%sConnected Pin File       %08lx"
                        " [StackTop = %wZ]\n",
                        Tab (TabDepth), ConnectedFileObject, &HostString
                        );
        
                    free (Buffer);

                }
            }
        }
    }

    dprintf ("%sState                    %ld\n", 
        Tab (TabDepth),
        PinObject -> m_State);
    dprintf ("%sMaster Clock Object      %08lx\n", 
        Tab (TabDepth),
        PinObject -> m_MasterClockFileObject);
    if (Level >= DUMPLVL_INTERNAL) {
        dprintf ("%sOut of order completions %ld\n",
            Tab (TabDepth),
            PinObject -> m_IrpsCompletedOutOfOrder);
        dprintf ("%sSourced Irps             %ld\n",
            Tab (TabDepth),
            PinObject -> m_StreamingIrpsSourced);
        dprintf ("%sDispatched Irps          %ld\n",
            Tab (TabDepth),
            PinObject -> m_StreamingIrpsDispatched);
        dprintf ("%sSync. Routed Irps        %ld\n",
            Tab (TabDepth),
            PinObject -> m_StreamingIrpsRoutedSynchronously);
    }

    dprintf ("%sProcessing Mutex         %08lx [SignalState = %ld]\n",
        Tab (TabDepth),
        FIELDOFFSET(CKsPin, m_Mutex) + Private,
        PinObject -> m_Mutex.Header.SignalState
    );

    dprintf ("%sAnd Gate &               %08lx\n",
        Tab (TabDepth),
        FIELDOFFSET(CKsPin, m_AndGate) + Private);
    dprintf ("%sAnd Gate Count           %ld\n",
        Tab (TabDepth),
        PinObject -> m_AndGate.Count);

    //
    // Dump out the Irp lists.  If they want it all
    //
    if (Level >= DUMPLVL_HIGHDETAIL) {
        ULONG Count;

        dprintf ("%sIrps to send:\n", Tab (TabDepth));
        dprintf ("%s", Tab (TabDepth + 1));
        Count = DumpObjQueueList (
            &(PinObject -> m_IrpsToSend.ListEntry),
            FIELDOFFSET(CKsPin, m_IrpsToSend) + Private +
                FIELDOFFSET(INTERLOCKEDLIST_HEAD, ListEntry),
            FIELDOFFSET(IRP, Tail.Overlay.ListEntry),
            FALSE,
            NULL,
            NULL
        );
        if (Count == 0)
            dprintf ("There are no Irps waiting to be sent!\n");
        else
            dprintf ("\n");

        dprintf ("%sIrps outstanding (sent out but not completed):\n",
            Tab (TabDepth));
        dprintf ("%s", Tab (TabDepth + 1));
        Count  = DumpObjQueueList (
            &(PinObject -> m_IrpsOutstanding.ListEntry),
            FIELDOFFSET(CKsPin, m_IrpsOutstanding) + Private +
                FIELDOFFSET(INTERLOCKEDLIST_HEAD, ListEntry),
            FIELDOFFSET(IRPLIST_ENTRY, ListEntry),
            FALSE,
            AdjustIrpListEntryToIrp,
            NULL
        );
        if (Count == 0)
            dprintf ("There are no outstanding Irps!\n");
        else
            dprintf ("\n");
    }

}

/*************************************************

    Function:

        DumpPrivatePipeSection

    Description:

        Given the address of a CKsPipeSection object on the target,
        dump information about that pipe section object.

    Arguments:

        Private -
            The address of the CKsPipeSection object

        Level -
            The 0-7 dump level

        TabDepth -
            The tab depth to print this at

    Return Value:

    Notes:

*************************************************/

DWORD
AdjustProcessPinToKSPIN (
    IN PVOID Context,
    IN DWORD ProcessPinAddr
) {

    PKSPIN Pin;
    ULONG Result;

    if (!ReadMemory (
        ProcessPinAddr + FIELDOFFSET(KSPPROCESSPIN, Pin),
        &Pin,
        sizeof (PKSPIN),
        &Result
    )) {
        dprintf ("%08lx: unable to adjust process pin to KSPIN!\n",
            ProcessPinAddr);
        return ProcessPinAddr;
    }

    return (DWORD)Pin;

}

DWORD
AdjustProcessPipeToPipe (
    IN PVOID Context,
    IN DWORD ProcessPipeAddr
) {
    
    return (DWORD)(CONTAINING_RECORD ((PKSPPROCESSPIPESECTION)ProcessPipeAddr,
        CKsPipeSection, m_ProcessPipeSection));

}

void
DumpPrivatePipeSection (
    IN DWORD Private,
    IN ULONG Level,
    IN ULONG TabDepth
) {

    CMemoryBlock <CKsPipeSection> PipeObject;
    ULONG Result;

    if (!ReadMemory (
        Private,
        PipeObject.Get (),
        sizeof (CKsPipeSection),
        &Result
    )) {
        dprintf ("%08lx: cannot read pipe section object!\n",
            Private);
        return;
    }

    dprintf ("%sCKsPipeSection object %08lX:\n", Tab (TabDepth), Private);
    TabDepth++;
    dprintf ("%sReference Count          %ld\n",
        Tab (TabDepth),
        GetObjectReferenceCount ((CBaseUnknown *)((CKsPipeSection *)Private)));
    dprintf ("%sPipe Id                  %08lx\n",
        Tab (TabDepth),
        PipeObject -> m_Id);
    dprintf ("%sState                    %ld\n", 
        Tab (TabDepth),
        PipeObject -> m_DeviceState);
    dprintf ("%sOwning PIKSFILTER        %08lx\n",
        Tab (TabDepth),
        PipeObject -> m_Filter);
    dprintf ("%sOwning PIKSDEVICE        %08lx\n",
        Tab (TabDepth),
        PipeObject -> m_Device);
    dprintf ("%sMaster PIKSPIN           %08lx\n",
        Tab (TabDepth),
        PipeObject -> m_MasterPin);

    if (Level >= DUMPLVL_GENERAL) {
        ULONG Count;


        dprintf ("%sProcess Pipe Data [%08lx]:\n",
            Tab (TabDepth),
            FIELDOFFSET(CKsPipeSection, m_ProcessPipeSection) + Private);

        dprintf ("%sAssociated PIKSREQUESTOR %08lx\n",
            Tab (TabDepth + 1),
            PipeObject -> m_ProcessPipeSection.Requestor);
        dprintf ("%sAssociated PIKSQUEUE     %08lx\n",
            Tab (TabDepth + 1),
            PipeObject -> m_ProcessPipeSection.Queue);
        dprintf ("%sRequired for processing  %ld\n",
            Tab (TabDepth + 1),
            PipeObject -> m_ProcessPipeSection.RequiredForProcessing);

        dprintf ("%sInput Pins:\n", Tab (TabDepth + 1));
        dprintf ("%s", Tab (TabDepth + 2));
        
        //                
        // Here's a bit of fun trickery.  It's not really a list entry,
        // but what the heck.
        //
        Count = DumpObjQueueList (
            (PLIST_ENTRY)(&(PipeObject -> m_ProcessPipeSection.Inputs)),
            0,
            FIELDOFFSET(KSPPROCESSPIN, Next),
            FALSE,
            AdjustProcessPinToKSPIN,
            NULL
        );
        if (Count == 0)
            dprintf ("No input pins exist in this pipe section!\n");
        else
            dprintf ("\n");

        dprintf ("%sOutput Pins:\n", Tab (TabDepth + 1));
        dprintf ("%s", Tab (TabDepth + 2));
        
        Count = DumpObjQueueList (
            (PLIST_ENTRY)(&(PipeObject -> m_ProcessPipeSection.Outputs)),
            0,
            FIELDOFFSET(KSPPROCESSPIN, Next),
            FALSE,
            AdjustProcessPinToKSPIN,
            NULL
        );
        if (Count == 0)
            dprintf ("No output pins exist in this pipe section!\n");
        else
            dprintf ("\n");

        dprintf ("%sCopy Destinations:\n", Tab (TabDepth + 1));
        dprintf ("%s", Tab (TabDepth + 2));

        Count = DumpObjQueueList (
            (PLIST_ENTRY)(&(PipeObject -> 
                m_ProcessPipeSection.CopyDestinations)),
            FIELDOFFSET (KSPPROCESSPIPESECTION, CopyDestinations) + Private +
                FIELDOFFSET (CKsPipeSection, m_ProcessPipeSection),
            FIELDOFFSET (KSPPROCESSPIPESECTION, ListEntry),
            FALSE,
            AdjustProcessPipeToPipe,
            NULL
            );
        if  (Count == 0)
            dprintf ("No copy destinations exist for this pipe section!\n");
        else
            dprintf ("\n");

    }

}

/*************************************************

    Function:
        
        DumpPrivateFilter

    Description:

        Dump a CKsFilter object by address on the target

    Arguments:

        Private -
            Points to the CKsFilter object on the target

        Level -
            The 0-7 dump level

        TabDepth -
            The tab depth to print this at

    Return Value:

        None

    Notes:

*************************************************/

DWORD
AdjustPinExtToKSPIN (
    IN PVOID Context,
    IN DWORD PinExt
) {

    return (PinExt + FIELDOFFSET(KSPIN_EXT, Public));

}

void
DumpPrivateFilter (
    IN DWORD Private,
    IN ULONG Level,
    IN ULONG TabDepth
) {

    CMemoryBlock <CKsFilter> FilterObject;
    ULONG Result;

    if (!ReadMemory (
        Private,
        FilterObject.Get (),
        sizeof (CKsFilter),
        &Result
    )) {
        dprintf ("%08lx: unable to read CKsFilter object!\n",
            Private);
        return;
    }

    dprintf ("%sCKsFilter object %08lX [corresponding EXT = %08lx, "
        "KSFILTER = %08lx]\n",
        Tab (TabDepth),
        Private, FIELDOFFSET(CKsFilter, m_Ext) + Private, 
        FIELDOFFSET(CKsFilter, m_Ext) + FIELDOFFSET(KSFILTER_EXT, Public) + 
            Private
    );
    TabDepth++;
    dprintf ("%sReference Count          %ld\n",
        Tab (TabDepth),
        GetObjectReferenceCount ((CBaseUnknown *)((CKsFilter *)Private)));

    dprintf ("%sProcessing Mutex         %08lx [SignalState = %ld]\n",
        Tab (TabDepth),
        FIELDOFFSET(CKsFilter, m_Mutex) + Private,
        FilterObject -> m_Mutex.Header.SignalState
    );

    dprintf ("%sGate &                   %08lx\n",
        Tab (TabDepth),
        Private + FIELDOFFSET(CKsFilter,m_AndGate));
    dprintf ("%sGate.Count               %ld\n",
        Tab (TabDepth),
        FilterObject -> m_AndGate.Count);

    if (Level >= DUMPLVL_SPECIFIC) {

        CMemoryBlock <CKsPinFactory> PinFactories(
            FilterObject -> m_PinFactoriesCount);

        ULONG i;
        CKsPinFactory *Factory;

        if (!ReadMemory (
            (DWORD)FilterObject -> m_PinFactories,
            PinFactories.Get (),
            sizeof (CKsPinFactory) * FilterObject -> m_PinFactoriesCount,
            &Result
        )) {
            dprintf ("%08lx: unable to read pin factories!\n",
                Private);
            return;
        }

        dprintf ("%sPin Factories:\n", Tab (TabDepth));
    
        for (Factory = PinFactories.Get (), i = 0; 
             i < FilterObject -> m_PinFactoriesCount; 
             i++, Factory++) {

            ULONG Count;

            dprintf ("%sPin ID %ld:\n", Tab (TabDepth + 1), i);
            dprintf ("%sChild Count        %ld\n",
                Tab (TabDepth + 2),
                Factory -> m_PinCount);
            dprintf ("%sBound Child Count  %ld\n",
                Tab (TabDepth + 2),
                Factory -> m_BoundPinCount);
            dprintf ("%sNecessary Count    %ld\n",
                Tab (TabDepth + 2),
                Factory -> m_InstancesNecessaryForProcessing);
            dprintf ("%sSpecific Instances:\n", Tab (TabDepth + 2));
            dprintf ("%s", Tab (TabDepth + 3));

            Count = DumpObjQueueList (
                &(Factory -> m_ChildPinList),
                FIELDOFFSET(CKsPinFactory, m_ChildPinList) +
                    (DWORD)(FilterObject -> m_PinFactories + i),
                FIELDOFFSET(KSPIN_EXT, SiblingListEntry),
                FALSE,
                AdjustPinExtToKSPIN,
                NULL
            );

            if (Count == 0)
                dprintf ("No specific instances of this pin exist!\n");
            else
                dprintf ("\n");

        }
    }
}

/*************************************************

    Function:

        DumpPrivateFilterFactory

    Description:

        Given the address of a CKsFilterFactory on the target,
        dump information about that filter factory.

    Arguments:

        Private -
            The address of the CKsFilterFactory on the target

        Level -
            The 0-7 dump level

        TabDepth -
            The tab depth to print this at

    Return Value:

    Notes:


*************************************************/

void
DumpPrivateFilterFactory (
    IN DWORD Private,
    IN ULONG Level,
    IN ULONG TabDepth
) {

    CMemoryBlock <CKsFilterFactory> FactoryObject;
    ULONG Result;
    LIST_ENTRY ListEntry;
    DWORD InitialList;
    KSPDEVICECLASS DeviceClass;
    UNICODE_STRING SymbolicLink;

    if (!ReadMemory (
        Private,
        FactoryObject.Get (),
        sizeof (CKsFilterFactory),
        &Result
    )) {
        dprintf ("%08lx: unable to read CKsFilterFactory object!\n",
            Private);
        return;
    }

    dprintf ("%sCKsFilterFactory object %08lX [corresponding EXT = %08lx, "
        "KSFILTERFACTORY = %08lx]\n",
        Tab (TabDepth),
        Private, FIELDOFFSET(CKsFilterFactory, m_Ext) + Private, 
        FIELDOFFSET(CKsFilterFactory, m_Ext) + 
            FIELDOFFSET(KSFILTERFACTORY_EXT, Public) + 
            Private
    );
    TabDepth++;
    dprintf ("%sReference Count          %ld\n",
        Tab (TabDepth),
        GetObjectReferenceCount ((CBaseUnknown *)((CKsFilterFactory *)
            Private)));
    dprintf ("%sFilter Automation Table  %08lx\n",
        Tab (TabDepth),
        FactoryObject -> m_FilterAutomationTable);
    dprintf ("%sPin Automation Tables    %08lx\n",
        Tab (TabDepth),
        FactoryObject -> m_PinAutomationTables);
    dprintf ("%sNode Automation Tables   %08lx\n",
        Tab (TabDepth),
        FactoryObject -> m_NodeAutomationTables);
    dprintf ("%sNode Count               %ld\n",
        Tab (TabDepth),
        FactoryObject -> m_NodesCount);

    dprintf ("%sDevice Classes:\n", Tab (TabDepth));

    //
    // Walk the device classes list and print out all symbolic links that
    // are associated with this factory.
    //
    InitialList = FIELDOFFSET(CKsFilterFactory, m_DeviceClasses) + Private;
    DeviceClass.ListEntry = FactoryObject -> m_DeviceClasses;

    #ifdef DEBUG_EXTENSION
        dprintf ("Begin dump of device class list: list.fl=%08lx, init=%08lx"
            "\n", DeviceClass.ListEntry.Flink, InitialList);
    #endif // DEBUG_EXTENSION

    while ((DWORD)DeviceClass.ListEntry.Flink != InitialList &&
        !CheckControlC ()) {

        PWSTR Buffer;
        
        if (!ReadMemory (
            (DWORD)DeviceClass.ListEntry.Flink,
            &DeviceClass,
            sizeof (KSPDEVICECLASS),
            &Result
        )) {
            dprintf ("%08lx: unable to read device class!\n",
                DeviceClass.ListEntry.Flink);
            return;
        }

        Buffer = (PWSTR)malloc (
            sizeof (WCHAR) * DeviceClass.SymbolicLinkName.MaximumLength);

        if (!ReadMemory (
            (DWORD)DeviceClass.SymbolicLinkName.Buffer,
            Buffer,
            sizeof (WCHAR) * 
                DeviceClass.SymbolicLinkName.MaximumLength,
            &Result
        )) {
            dprintf ("%08lx: unable to read symbolic link name!\n",
                DeviceClass.SymbolicLinkName.Buffer);
            return;
        }

        DeviceClass.SymbolicLinkName.Buffer = Buffer;

        dprintf ("%s%wZ\n", Tab (TabDepth + 1), &DeviceClass.SymbolicLinkName);

        free (Buffer);

    }

    dprintf ("%sDevice Classes State     %s\n",
        Tab (TabDepth),
        FactoryObject -> m_DeviceClassesState ? "active" : "inactive");

}

/*************************************************

    Function:

        DumpPrivateDevice

    Description:

        Given the address of a CKsDevice on the target,
        dump information about that device.

    Arguments:

        Private -
            The address of the CKsDevice on the target

        Level -
            The 0-7 dump level

        TabDepth -
            The tab depth to print this at

    Return Value:

    Notes:

*************************************************/

void
DumpPrivateDevice (
    IN DWORD Private,
    IN ULONG Level,
    IN ULONG TabDepth
) {

    CMemoryBlock <CKsDevice> DeviceObject;
    ULONG Result;

    if (!ReadMemory (
        Private,
        DeviceObject.Get (),
        sizeof (CKsDevice),
        &Result
    )) {
        dprintf ("%08lx: unable to read CKsDevice object!\n",
            Private);
        return;
    }

    dprintf ("%sCKsDevice object %08lX [corresponding EXT = %08lx, "
        "KSDEVICE = %08lx]\n",
        Tab (TabDepth),
        Private, FIELDOFFSET(CKsDevice, m_Ext) + Private, 
        FIELDOFFSET(CKsDevice, m_Ext) + FIELDOFFSET(KSDEVICE_EXT, Public) + 
            Private
    );
    dprintf ("%sReference Count          %ld\n",
        Tab (TabDepth),
        GetObjectReferenceCount ((CBaseUnknown *)((CKsDevice *)Private)));

    dprintf ("%sDevice Mutex             %08lx is %s\n",
        Tab (TabDepth),
        FIELDOFFSET(CKsDevice, m_Mutex) + Private,
        DeviceObject -> m_Mutex.Header.SignalState != 1 ? "held" : "not held");
    dprintf ("%sCreatesMayProceed        %ld\n",
        Tab (TabDepth),
        DeviceObject -> m_CreatesMayProceed);
    dprintf ("%sRunsMayProceed           %ld\n",
        Tab (TabDepth),
        DeviceObject -> m_RunsMayProceed);
    dprintf ("%sAdapter Object           %08lx\n",
        Tab (TabDepth),
        DeviceObject -> m_AdapterObject);

    if (Level >= DUMPLVL_HIGHDETAIL) {
        ULONG Count;

        dprintf ("%sClose Irp List:\n", Tab (TabDepth));
        dprintf ("%s", Tab (TabDepth + 1));
        Count = DumpObjQueueList (
            &(DeviceObject -> m_CloseIrpList.ListEntry),
            FIELDOFFSET(CKsDevice, m_CloseIrpList) + Private +
                FIELDOFFSET(INTERLOCKEDLIST_HEAD, ListEntry),
            FIELDOFFSET(IRP, Tail.Overlay.ListEntry),
            FALSE,
            NULL,
            NULL
        );
        if (Count == 0) 
            dprintf ("No close irps pending!\n");
        else
            dprintf ("\n");

        dprintf ("%sPending Create Irps:\n", Tab (TabDepth));
        dprintf ("%s", Tab (TabDepth + 1));
        Count = DumpObjQueueList (
            &(DeviceObject -> m_PendingCreateIrpList.ListEntry),
            FIELDOFFSET(CKsDevice, m_PendingCreateIrpList) + Private +
                FIELDOFFSET(INTERLOCKEDLIST_HEAD, ListEntry),
            FIELDOFFSET(IRP, Tail.Overlay.ListEntry),
            FALSE,
            NULL,
            NULL
        );
        if (Count == 0)
            dprintf ("No create irps pending!\n");
        else
            dprintf ("\n");

        dprintf ("%sPending Run Irps:\n", Tab (TabDepth));
        dprintf ("%s", Tab (TabDepth + 1));
        Count = DumpObjQueueList (
            &(DeviceObject -> m_PendingRunIrpList.ListEntry),
            FIELDOFFSET(CKsDevice, m_PendingRunIrpList) + Private +
                FIELDOFFSET(INTERLOCKEDLIST_HEAD, ListEntry),
            FIELDOFFSET(IRP, Tail.Overlay.ListEntry),
            FALSE,
            NULL,
            NULL
        );
        if (Count == 0)
            dprintf ("No run irps pending!\n");
        else
            dprintf ("\n");
    }
}

/*************************************************

    Function:

        DumpPrivateBag

    Description:

        Given the address of a KSIOBJECTBAG on the target,
        dump the bag's contents.

    Arguments:

        Private -
            The address of the bag
        
        Level -
            The 0-7 dump level to dump at

        TabDepth -
            The tab depth to print this at

*************************************************/

void
DumpPrivateBag (
    IN DWORD Private,
    IN ULONG Level,
    IN ULONG TabDepth
) {

    KSIOBJECTBAG Bag;
    ULONG Result;

    CHAR Buffer [1024];
    ULONG Displ;

    if (!ReadMemory (
        Private,
        &Bag,
        sizeof (KSIOBJECTBAG),
        &Result)) {

        dprintf ("%08lx: unable to read bag!\n", Private);
        return;
    }

    dprintf ("%sObject Bag %08lx:\n", Tab (TabDepth), Private);
    TabDepth++;

    //
    // Scope out the hash table allocation.  The bag structure will end
    // up looking like
    // 
    // HASH TABLE:
    //      HASH ENTRY * -> HASH ENTRY * -> HASH ENTRY * -> /
    //      /
    //      HASH ENTRY * -> HASH ENTRY * -> /
    //      etc...
    //
    // Each HASH ENTRY contains a reference back to an entry in the device
    // bag where reference count, context info, etc... are held.  This allows
    // items to be in multiple bags and be reference counted through the
    // device bag.
    //
    // We have to walk the hash table, each hash chain...  get the device
    // bag entry, and then print.
    //
    {
        CMemory HashTableMem (
            sizeof (PLIST_ENTRY) *
            Bag.HashTableEntryCount
        );
        PLIST_ENTRY HashTable = 
            (PLIST_ENTRY)HashTableMem.Get ();

        KSIOBJECTBAG_ENTRY HashEntry;
        KSIDEVICEBAG_ENTRY DeviceBagEntry;
        PLIST_ENTRY HashChainPointer;

        ULONG HashChain;

        if (!ReadMemory (
            (DWORD)Bag.HashTable,
            HashTable,
            sizeof (LIST_ENTRY) *
                Bag.HashTableEntryCount,
            &Result)) {

            dprintf ("%08lx: unable to read hash table!\n", Bag.HashTable);
            return;

        }

        //
        // Iterate through hash chains in the bag.
        //
        for (HashChain = 0; HashChain < Bag.HashTableEntryCount &&
            !CheckControlC (); 
            HashChain++, HashTable++) {

            //
            // Iterate through the given hash chain.
            //
            HashChainPointer = HashTable -> Flink;
            while (HashChainPointer != 
                (PLIST_ENTRY)
                    (Private + FIELDOFFSET (KSIOBJECTBAG, HashTable) +
                        sizeof (LIST_ENTRY) * HashChain +
                        FIELDOFFSET (LIST_ENTRY, Flink)
                    ) && 
                !CheckControlC ()) {

                #ifdef DEBUG_EXTENSION
                    dprintf ("Reading object bag entry at %08lx [ch=%ld]\n",
                        HashChainPointer, HashChain);
                #endif // DEBUG_EXTENSION

                PKSIOBJECTBAG_ENTRY BagEntry = (PKSIOBJECTBAG_ENTRY)
                    CONTAINING_RECORD (
                        HashChainPointer,
                        KSIOBJECTBAG_ENTRY,
                        ListEntry
                        );

                //
                // Read the hash entry for this object bag item; then
                // fetch the device bag entry.
                //
                if (!ReadMemory (
                    (DWORD)BagEntry,
                    &HashEntry,
                    sizeof (KSIOBJECTBAG_ENTRY),
                    &Result)) {

                    dprintf ("%08lx: unable to read hash entry!\n", 
                        HashChainPointer);
                    return;
                }

                #ifdef DEBUG_EXTENSION
                    dprintf ("Reading device bag entry at %08lx\n",
                        HashEntry.DeviceBagEntry);
                #endif // DEBUG_EXTENSION

                if (!ReadMemory (
                    (DWORD)HashEntry.DeviceBagEntry,
                    &DeviceBagEntry,
                    sizeof (KSIDEVICEBAG_ENTRY),
                    &Result)) {

                    dprintf ("%08x: unable to read device bag entry!\n",
                        HashEntry.DeviceBagEntry);
                    return;
                }

                //
                // Aah...  we finally have enough information to print
                // a single bag item.
                //
                dprintf ("%sObject Bag Item %08lx:\n",
                    Tab (TabDepth),
                    DeviceBagEntry.Item);
                dprintf ("%sReference Count        : %ld\n",
                    Tab (TabDepth + 1),
                    DeviceBagEntry.ReferenceCount);

                Buffer [0] = 0;
                if (DeviceBagEntry.Free) {
                    GetSymbol ((LPVOID)(DeviceBagEntry.Free), Buffer, &Displ);
                    if (Buffer [0] && Displ == 0) {
                        dprintf ("%sItem Cleanup Handler   : %s\n",
                            Tab (TabDepth + 1),
                            Buffer);
                    } else {
                        dprintf ("%sItem Cleanup Handler   : %08lx\n",
                            Tab (TabDepth + 1),
                            DeviceBagEntry.Free);
                    }
                } else {
                    dprintf ("%sItem Cleanup Handler   : ExFreePool "
                        "[default]\n",
                        Tab (TabDepth + 1));
                }

                //
                // Dump out internally useful information.
                //
                if (Level >= DUMPLVL_INTERNAL) {
                    dprintf ("%sObject Bag Entry &     : %08lx\n",
                        Tab (TabDepth + 1),
                        HashChainPointer);
                    dprintf ("%sDevice Bag Entry &     : %08lx\n",
                        Tab (TabDepth + 1),
                        HashEntry.DeviceBagEntry);
                }

                HashChainPointer = HashEntry.ListEntry.Flink;

                #ifdef DEBUG_EXTENSION
                    dprintf ("Next item in hash chain = %08lx\n",
                        HashChainPointer);
                #endif // DEBUG_EXTENSION

            }
        }
    }
}

/**************************************************************************

    Routines to dump public AVStream objects

**************************************************************************/

/*************************************************

    Function:

        DumpPublicPin

    Description:

        Given the address of a KSPIN object on the target,
        dump information about that pin object.

    Arguments:

        Public -
            The address of the public pin (KSPIN) object

        Level -
            The 0-7 dump level to dump at

        TabDepth -
            The tab depth to print this at

    Return Value:

        None

*************************************************/

char *CommunicationNames [] = {
    "None",
    "Sink",
    "Source",
    "Both",
    "Bridge"
};

char *DataflowNames [] = {
    "Unknown",
    "In",
    "Out"
};

#define DumpRelatedPinInfo(Name, InternalPin, TabDepth) \
    { \
        KSPPROCESSPIN InternalPinData;\
\
        if (InternalPin) {\
            if (!ReadMemory (\
                (DWORD)InternalPin,\
                &InternalPinData,\
                sizeof (KSPPROCESSPIN),\
                &Result\
                )) {\
                dprintf ("%lx: unable to read related pin!\n", InternalPin);\
                return;\
            }\
\
            dprintf ("%s%s%08lx [PKSPIN = %08lx]\n",\
                Tab (TabDepth), Name, InternalPin, InternalPinData.Pin);\
        }\
        else \
            dprintf ("%s%s00000000 [PKSPIN = 00000000]\n",\
                Tab (TabDepth), Name);\
    }


void
DumpPublicPin (
    IN DWORD Public,
    IN ULONG Level,
    IN ULONG TabDepth
) {

    IN DWORD ExtAddr;
    KSPIN_EXT PinExt;
    DWORD ClassAddr;
    ULONG Result;

    ExtAddr = (DWORD)(CONTAINING_RECORD(Public, KSPIN_EXT, Public));
    ClassAddr = (DWORD)(CONTAINING_RECORD(ExtAddr, CKsPin, m_Ext));

    if (!ReadMemory (
        ExtAddr,
        &PinExt,
        sizeof (KSPIN_EXT),
        &Result
    )) {
        dprintf ("%lx: unable to read object!\n", Public);
        return;
    }

    dprintf ("%sPin object %08lX [corresponding EXT = %08lx, CKsPin = %08lx]\n",
        Tab (TabDepth),
        Public, ExtAddr, ClassAddr);
    TabDepth++;
    dprintf ("%sDescriptor     %08lx\n", 
        Tab (TabDepth), PinExt.Public.Descriptor);
    dprintf ("%sContext        %08lx\n", 
        Tab (TabDepth), PinExt.Public.Context);
    dprintf ("%sId             %d\n", 
        Tab (TabDepth), PinExt.Public.Id);

    if (Level >= DUMPLVL_GENERAL) {
        dprintf ("%sCommunication  %s\n", 
            Tab (TabDepth), 
            CommunicationNames [PinExt.Public.Communication]);
        dprintf ("%sDataFlow       %s\n", 
            Tab (TabDepth),
            DataflowNames [PinExt.Public.DataFlow]);

        XTN_DUMPGUID("Interface     ", TabDepth, 
            (PinExt.Public.ConnectionInterface));
        XTN_DUMPGUID("Medium        ", TabDepth, 
            (PinExt.Public.ConnectionMedium));

        dprintf ("%sStreamHdr Size %08lx\n", 
            Tab (TabDepth),
            PinExt.Public.StreamHeaderSize);
        dprintf ("%sDeviceState    %ld\n",
            Tab (TabDepth),
            PinExt.Public.DeviceState);
        dprintf ("%sResetState     %ld\n",
            Tab (TabDepth),
            PinExt.Public.ResetState);

    }

    if (Level >= DUMPLVL_INTERNAL) {
        DWORD FilterAddr;
        KMUTEX Mutex;

        FilterAddr = ((DWORD)FIELDOFFSET(KSFILTER_EXT, Public)) + 
            (DWORD)PinExt.Parent;

        dprintf ("%sINTERNAL INFORMATION:\n", Tab (TabDepth));
        dprintf ("%sPublic Parent Filter    %08lx\n", 
            Tab (TabDepth + 1), FilterAddr);
        dprintf ("%sAggregated Unknown      %08lx\n", 
            Tab (TabDepth + 1),
            PinExt.AggregatedClientUnknown);
        dprintf ("%sDevice Interface        %08lx\n",
            Tab (TabDepth + 1),
            PinExt.Device);

        if (ReadMemory (
            (DWORD)PinExt.FilterControlMutex,
            &Mutex,
            sizeof (KMUTEX),
            &Result
        )) {
            dprintf ("%sControl Mutex           %08lx is %s\n",
                Tab (TabDepth + 1),
                PinExt.FilterControlMutex,
                Mutex.Header.SignalState != 1 ? "held" : "not held");
        }
        
        if (Level >= DUMPLVL_HIGHDETAIL) {
            KSPPROCESSPIN ProcessPin;
            KSPPROCESSPIPESECTION ProcessPipe;

            dprintf ("%sProcess Pin             %08lx:\n",
                Tab (TabDepth + 1),
                PinExt.ProcessPin);

            if (!ReadMemory (
                (DWORD)PinExt.ProcessPin,
                &ProcessPin,
                sizeof (KSPPROCESSPIN),
                &Result
            )) {
                dprintf ("%lx: unable to read process pin!\n",
                    PinExt.ProcessPin);
                return;
            }

            if (!ReadMemory (
                (DWORD)ProcessPin.PipeSection,
                &ProcessPipe,
                sizeof (KSPPROCESSPIPESECTION),
                &Result
            )) {
                dprintf ("%lx: unable to read process pipe!\n",
                    (DWORD)ProcessPin.PipeSection);
                return;
            }

            dprintf ("%sPipe Section (if)   %08lx\n",
                Tab (TabDepth + 2),
                ProcessPipe.PipeSection);
            
            DumpRelatedPinInfo ("Inplace Counterpart ",
                ProcessPin.InPlaceCounterpart, TabDepth + 2);
            DumpRelatedPinInfo ("Copy Source         ",
                ProcessPin.CopySource, TabDepth + 2);
            DumpRelatedPinInfo ("Delegate Branch     ",
                ProcessPin.DelegateBranch, TabDepth + 2);

            dprintf ("%sNext Process Pin    %08lx\n",
                Tab (TabDepth + 2),
                ProcessPin.Next);
            dprintf ("%sPipe Id             %08lx\n",
                Tab (TabDepth + 2),
                ProcessPin.PipeId);
            dprintf ("%sAllocator           %08lx\n",
                Tab (TabDepth + 2),
                ProcessPin.AllocatorFileObject);
            dprintf ("%sFrameGate           %08lx\n",
                Tab (TabDepth + 2),
                ProcessPin.FrameGate);
            dprintf ("%sFrameGateIsOr       %ld\n",
                Tab (TabDepth + 2),
                ProcessPin.FrameGateIsOr);

        } else {

            dprintf ("%sProcess Pin             %08lx\n",
                Tab (TabDepth + 1),
                PinExt.ProcessPin);

        }

    }

    if (Level >= DUMPLVL_HIGHDETAIL) {
        dprintf ("%sObject Event List:\n", Tab (TabDepth));
        if (DumpExtEventList (ExtAddr, TabDepth + 1) == 0)
            dprintf ("%sNone\n", Tab (TabDepth + 1));
        DumpPrivatePin (ClassAddr, Level, TabDepth);
    }

}

/*************************************************

    Function:

        DumpPublicFilter

    Description:

        Dump a KSFILTER structure

    Arguments:

        Public -
            Points to the KSFILTER structure on the target

        Level -
            The 0-7 dump level

        TabDepth -
            The tab depth to print this at

    Return Value:

        None

    Notes:

*************************************************/

void
DumpPublicFilter (
    IN DWORD Public,
    IN ULONG Level,
    IN ULONG TabDepth
) {

    IN DWORD ExtAddr;
    KSFILTER_EXT FilterExt;
    DWORD ClassAddr;
    ULONG Result;

    ExtAddr = (DWORD)(CONTAINING_RECORD(Public, KSFILTER_EXT, Public));
    ClassAddr = (DWORD)(CONTAINING_RECORD(ExtAddr, CKsFilter, m_Ext));

    if (!ReadMemory (
        ExtAddr,
        &FilterExt,
        sizeof (KSFILTER_EXT),
        &Result
    )) {
        dprintf ("%lx: unable to read object!\n", Public);
        return;
    }

    dprintf ("%sFilter object %08lX [corresponding EXT = %08lx, "
        "CKsFilter = %08lx]\n", Tab (TabDepth), Public, ExtAddr, ClassAddr);
    TabDepth++;
    dprintf ("%sDescriptor     %08lx:\n", 
        Tab (TabDepth), FilterExt.Public.Descriptor);

    if (Level >= DUMPLVL_BEYONDGENERAL) {
        KSFILTER_DESCRIPTOR Descriptor;
        GUID *Categories, *CatTrav;
        ULONG i;

        if (!ReadMemory (
            (DWORD)FilterExt.Public.Descriptor,
            &Descriptor,
            sizeof (KSFILTER_DESCRIPTOR),
            &Result
        )) {
            dprintf ("%08lx: unable to read descriptor!\n",
                FilterExt.Public.Descriptor);
            return;
        }

        Categories = (GUID *)malloc (
            sizeof (GUID) * Descriptor.CategoriesCount);

        if (!ReadMemory (
            (DWORD)Descriptor.Categories,
            Categories,
            sizeof (GUID) * Descriptor.CategoriesCount,
            &Result
        )) {
            dprintf ("%08lx: unable to read category guids!\n",
                Descriptor.Categories);
            return;
        }

        dprintf ("%sFilter Category GUIDs:\n", Tab (TabDepth));
        CatTrav = Categories;
        i = Descriptor.CategoriesCount;
        while (i && !CheckControlC ()) {
            XTN_DUMPGUID ("\0", TabDepth + 1, *CatTrav);
            CatTrav++;
            i--;
        }

        free (Categories);

    }

    dprintf ("%sContext        %08lx\n", 
        Tab (TabDepth), FilterExt.Public.Context);

    if (Level >= DUMPLVL_INTERNAL) {
        
        DWORD FactoryAddr;
        KMUTEX Mutex;

        dprintf ("%sINTERNAL INFORMATION:\n", Tab (TabDepth));

        FactoryAddr = (DWORD)FilterExt.Parent + 
            FIELDOFFSET(KSFILTERFACTORY_EXT, Public);
        dprintf ("%sPublic Parent Factory   %08lx\n", 
            Tab (TabDepth + 1), FactoryAddr);
        dprintf ("%sAggregated Unknown      %08lx\n", 
            Tab (TabDepth + 1),
            FilterExt.AggregatedClientUnknown);
        dprintf ("%sDevice Interface        %08lx\n",
            Tab (TabDepth + 1),
            FilterExt.Device);

        if (ReadMemory (
            (DWORD)FilterExt.FilterControlMutex,
            &Mutex,
            sizeof (KMUTEX),
            &Result
        )) {
            dprintf ("%sControl Mutex           %08lx is %s\n",
                Tab (TabDepth + 1),
                FilterExt.FilterControlMutex,
                Mutex.Header.SignalState != 1 ? "held" : "not held");
        }
    }

    if (Level >= DUMPLVL_HIGHDETAIL) {
        dprintf ("%sObject Event List:\n", Tab (TabDepth));
        if (DumpExtEventList (ExtAddr, TabDepth + 1) == 0)
            dprintf ("%sNone\n", Tab (TabDepth + 1));
        DumpPrivateFilter (ClassAddr, Level, TabDepth);
    }

}

/*************************************************

    Function:

        DumpPublicFilterFactory

    Description:

        Given an address of a KSFILTERFACTORY on the target, dump it

    Arguments:

        Public -
            The address of the KSFILTERFACTORY on the target

        Level -
            The 0-7 dump level

        TabDepth -
            The tab depth to print this at

    Return Value:

    Notes:

*************************************************/

void 
DumpPublicFilterFactory (
    IN DWORD Public,
    IN ULONG Level,
    IN ULONG TabDepth
) {

    DWORD ExtAddr;
    DWORD ClassAddr;
    ULONG Result;
    KSFILTERFACTORY_EXT FactoryExt;

    ExtAddr = (DWORD)(CONTAINING_RECORD(Public, KSFILTERFACTORY_EXT, Public));
    ClassAddr = (DWORD)(CONTAINING_RECORD(ExtAddr, CKsFilterFactory, m_Ext));

    if (!ReadMemory (
        ExtAddr,
        &FactoryExt,
        sizeof (KSFILTERFACTORY_EXT),
        &Result
    )) {
        dprintf ("%lx: unable to read object!\n", Public);
        return;
    }

    dprintf ("%sFilter Factory object %08lX [corresponding EXT = %08lx, "
        "CKsDevice = %08lx]\n", Tab (TabDepth), Public, ExtAddr, ClassAddr);
    TabDepth++;
    dprintf ("%sDescriptor     %08lx\n", 
        Tab (TabDepth), FactoryExt.Public.FilterDescriptor);

    dprintf ("%sContext        %08lx\n", 
        Tab (TabDepth), FactoryExt.Public.Context);

    if (Level >= DUMPLVL_INTERNAL) {
        
        DWORD DeviceAddr;

        dprintf ("%sINTERNAL INFORMATION:\n", Tab (TabDepth));

        DeviceAddr = (DWORD)FactoryExt.Parent + 
            FIELDOFFSET(KSDEVICE_EXT, Public);
        dprintf ("%sPublic Parent Device    %08lx\n", 
            Tab (TabDepth + 1), DeviceAddr);
        dprintf ("%sAggregated Unknown      %08lx\n", 
            Tab (TabDepth + 1),
            FactoryExt.AggregatedClientUnknown);
        dprintf ("%sDevice Interface        %08lx\n",
            Tab (TabDepth + 1),
            FactoryExt.Device);

    }

    if (Level >= DUMPLVL_HIGHDETAIL) 
        DumpPrivateFilterFactory (ClassAddr, Level, TabDepth);

}

/*************************************************

    Function:

        DumpPublicDevice

    Description:

        Given an address of a KSDEVICE on the target, dump it

    Arguments:

        Public -
            The address of the KSDEVICE on the target

        Level -
            The 0-7 dump level

        TabDepth -
            The tab depth to print this at

    Return Value:

    Notes:

*************************************************/

void
DumpPublicDevice (
    IN DWORD Public,
    IN ULONG Level,
    IN ULONG TabDepth
) {

    IN DWORD ExtAddr;
    KSDEVICE_EXT DeviceExt;
    DWORD ClassAddr;
    ULONG Result;

    BOOLEAN Named = FALSE;

    ExtAddr = (DWORD)(CONTAINING_RECORD(Public, KSDEVICE_EXT, Public));
    ClassAddr = (DWORD)(CONTAINING_RECORD(ExtAddr, CKsDevice, m_Ext));

    if (!ReadMemory (
        ExtAddr,
        &DeviceExt,
        sizeof (KSDEVICE_EXT),
        &Result
    )) {
        dprintf ("%lx: unable to read object!\n", Public);
        return;
    }

    dprintf ("%sDevice object %08lX [corresponding EXT = %08lx, "
        "CKsDevice = %08lx]\n", Tab (TabDepth), Public, ExtAddr, ClassAddr);
    TabDepth++;
    dprintf ("%sDescriptor     %08lx\n", 
        Tab (TabDepth), DeviceExt.Public.Descriptor);

    Named = FALSE;

    // 
    // PDO
    //
    if (DeviceExt.Public.PhysicalDeviceObject) {
        //
        // Find out the owning driver.
        //
        DWORD DriverObjAddr, NameAddr;
        PDRIVER_OBJECT DriverObject;
        UNICODE_STRING Name;

        DriverObjAddr = (DWORD)DeviceExt.Public.PhysicalDeviceObject +
            FIELDOFFSET(DEVICE_OBJECT, DriverObject);

        if (ReadMemory (
            DriverObjAddr,
            &DriverObject,
            sizeof (PDRIVER_OBJECT),
            &Result
        )) {

            NameAddr = (DWORD)DriverObject +
                FIELDOFFSET(DRIVER_OBJECT, DriverName);
    
            if (ReadMemory (
                NameAddr,
                &Name,
                sizeof (UNICODE_STRING),
                &Result
            )) {
    
                PWSTR Buffer = (PWSTR)malloc (
                    Name.MaximumLength * sizeof (WCHAR));
    
                UNICODE_STRING HostString;
    
                //
                // We have the unicode string name...  Allocate enough memory to
                // read the thing.
                //
    
                if (!ReadMemory (
                    (DWORD)Name.Buffer,
                    Buffer,
                    sizeof (WCHAR) * Name.MaximumLength,
                    &Result
                )) {
                    dprintf ("%08lx: unable to read unicode string buffer!\n",
                        Name.Buffer);
                    return;
                }
    
                HostString.MaximumLength = Name.MaximumLength;
                HostString.Length = Name.Length;
                HostString.Buffer = Buffer;

                Named = TRUE;
    
                dprintf ("%sPDO            %08lx [%wZ]\n", 
                    Tab (TabDepth),
                    DeviceExt.Public.PhysicalDeviceObject,
                    &HostString);
    
                free (Buffer);
            }
        }
    }
    if (!Named) {
        dprintf ("%sPDO            %08lx\n", 
            Tab (TabDepth),
            DeviceExt.Public.PhysicalDeviceObject);
    }

    Named = FALSE;
    //
    // FDO
    //
    if (DeviceExt.Public.FunctionalDeviceObject) {
        //
        // Find out the owning driver.
        //
        DWORD DriverObjAddr, NameAddr;
        PDRIVER_OBJECT DriverObject;
        UNICODE_STRING Name;

        DriverObjAddr = (DWORD)DeviceExt.Public.FunctionalDeviceObject +
            FIELDOFFSET(DEVICE_OBJECT, DriverObject);

        if (ReadMemory (
            DriverObjAddr,
            &DriverObject,
            sizeof (PDRIVER_OBJECT),
            &Result
        )) {

            NameAddr = (DWORD)DriverObject +
                FIELDOFFSET(DRIVER_OBJECT, DriverName);
    
            if (ReadMemory (
                NameAddr,
                &Name,
                sizeof (UNICODE_STRING),
                &Result
            )) {
    
                PWSTR Buffer = (PWSTR)malloc (
                    Name.MaximumLength * sizeof (WCHAR));
    
                UNICODE_STRING HostString;
    
                //
                // We have the unicode string name...  Allocate enough memory to
                // read the thing.
                //
    
                if (!ReadMemory (
                    (DWORD)Name.Buffer,
                    Buffer,
                    sizeof (WCHAR) * Name.MaximumLength,
                    &Result
                )) {
                    dprintf ("%08lx: unable to read unicode string buffer!\n",
                        Name.Buffer);
                    return;
                }
    
                HostString.MaximumLength = Name.MaximumLength;
                HostString.Length = Name.Length;
                HostString.Buffer = Buffer;

                Named = TRUE;
    
                dprintf ("%sFDO            %08lx [%wZ]\n", 
                    Tab (TabDepth),
                    DeviceExt.Public.FunctionalDeviceObject,
                    &HostString);
    
                free (Buffer);
            }
        }
    }
    if (!Named) {
        dprintf ("%sFDO            %08lx\n",
            Tab (TabDepth),
            DeviceExt.Public.FunctionalDeviceObject);
    }

    Named = FALSE;
    //
    // NDO
    //
    if (DeviceExt.Public.NextDeviceObject) {
        //
        // Find out the owning driver.
        //
        DWORD DriverObjAddr, NameAddr;
        PDRIVER_OBJECT DriverObject;
        UNICODE_STRING Name;

        DriverObjAddr = (DWORD)DeviceExt.Public.NextDeviceObject +
            FIELDOFFSET(DEVICE_OBJECT, DriverObject);

        if (ReadMemory (
            DriverObjAddr,
            &DriverObject,
            sizeof (PDRIVER_OBJECT),
            &Result
        )) {

            NameAddr = (DWORD)DriverObject +
                FIELDOFFSET(DRIVER_OBJECT, DriverName);
    
            if (ReadMemory (
                NameAddr,
                &Name,
                sizeof (UNICODE_STRING),
                &Result
            )) {
    
                PWSTR Buffer = (PWSTR)malloc (
                    Name.MaximumLength * sizeof (WCHAR));
    
                UNICODE_STRING HostString;
    
                //
                // We have the unicode string name...  Allocate enough memory to
                // read the thing.
                //
    
                if (!ReadMemory (
                    (DWORD)Name.Buffer,
                    Buffer,
                    sizeof (WCHAR) * Name.MaximumLength,
                    &Result
                )) {
                    dprintf ("%08lx: unable to read unicode string buffer!\n",
                        Name.Buffer);
                    return;
                }
    
                HostString.MaximumLength = Name.MaximumLength;
                HostString.Length = Name.Length;
                HostString.Buffer = Buffer;

                Named = TRUE;
    
                dprintf ("%sNext DevObj    %08lx [%wZ]\n", 
                    Tab (TabDepth),
                    DeviceExt.Public.NextDeviceObject,
                    &HostString);
    
                free (Buffer);
            }
        }
    }
    if (!Named) {
        dprintf ("%sNext DevObj    %08lx\n",
            Tab (TabDepth),
            DeviceExt.Public.NextDeviceObject);
    }
    dprintf ("%sStarted        %ld\n",
        Tab (TabDepth),
        DeviceExt.Public.Started);
    dprintf ("%sSystemPower    %ld\n",
        Tab (TabDepth),
        DeviceExt.Public.SystemPowerState);
    dprintf ("%sDevicePower    %ld\n",
        Tab (TabDepth),
        DeviceExt.Public.DevicePowerState);

    if (Level >= DUMPLVL_HIGHDETAIL) 
        DumpPrivateDevice (ClassAddr, Level, TabDepth);

}

/*************************************************

    Function:

        DumpCircuitPipeRelevencies

    Description:

        Dump any information pertaining to a pipe section which is relevant
        to knowing in tracing a circuit.

    Arguments:

        TabDepth -
            The tab depth to print information at

        PipeSection -
            The target pointer for the pipe section which to dump

*************************************************/

void
DumpCircuitPipeRelevencies (
    IN ULONG TabDepth,
    IN CKsPipeSection *PipeSection
    )

{

    CMemoryBlock <CKsPipeSection> PipeObject;
    ULONG Result;

    if (!PipeSection) {
        dprintf ("%sCannot read associated pipe section!\n",
            Tab (TabDepth));
        return;
    }

    if (!ReadMemory (
        (DWORD)PipeSection,
        PipeObject.Get (),
        sizeof (CKsPipeSection),
        &Result)) {
        
        dprintf ("%08lx: cannot read pipe section!\n", PipeSection);
        return;
    }

    //
    // BUGBUG:
    //
    // Determine whether or not the pipe section is the owner of the pipe
    // and display this information.  Most people should be able to figure
    // this out easily, but it'd be nice to display
    //
    dprintf ("%sPipe%lx (PipeId = %lx, State = %ld, Reset State = %ld)\n",
        Tab (TabDepth),
        PipeSection,
        PipeObject -> m_Id,
        PipeObject -> m_DeviceState,
        PipeObject -> m_ResetState
        );

}

typedef struct _DUMP_CIRCUIT_CONTEXT {

    ULONG TabDepth;
    ULONG DumpLevel;

} DUMP_CIRCUIT_CONTEXT, *PDUMP_CIRCUIT_CONTEXT;

/*************************************************

    Function:

        DumpCircuitCallback

    Description:

        This is the WalkCircuit callback for !ks.dumpcircuit.  Display
        information about the circuit element.

    Arguments:

        Context -
            The context structure (DUMP_CIRCUIT_CONTEXT)

        Type -
            The type of object

        Base -
            The object (base address)

        Object -
            The object itself

    Return Value:

        FALSE : do not stop walking

*************************************************/

BOOLEAN
DumpCircuitCallback (
    IN PVOID Context,
    IN INTERNAL_OBJECT_TYPE Type,
    IN DWORD Base,
    IN PVOID Object
    )

{

#define FRIENDLY_BU(obj) \
    ((CFriendlyBaseUnknown *)((CBaseUnknown *)obj))

    PDUMP_CIRCUIT_CONTEXT DumpContext = (PDUMP_CIRCUIT_CONTEXT)Context;
    ULONG TabDepth = DumpContext -> TabDepth;
    ULONG DumpLevel = DumpContext -> DumpLevel;
    ULONG Result;
    ULONG RefCount;

    switch (Type) {

        case ObjectTypeCKsPin:
        {
            CKsPin *PinObject = (CKsPin *)Object;

            RefCount = CFriendlyBaseUnknown::GetRefCount (
                FRIENDLY_BU (PinObject)
                );

            if (PinObject -> m_TransportSink == NULL || 
                PinObject -> m_TransportSource == NULL) {

                //
                // We have a CKsPin which appears to have been bypassed
                // during circuit construction.  We will suggest that
                // they try the queue instead.
                //

                KSPPROCESSPIPESECTION PipeSection;

                if (ReadMemory (
                    (DWORD)PinObject -> m_Process.PipeSection,
                    &PipeSection,
                    sizeof (KSPPROCESSPIPESECTION),
                    &Result
                )) {
                    dprintf ("%sPin%lX appears bypassed, try Queue%lX\n",
                        Tab (TabDepth),
                        Base, PipeSection.Queue);
                } else {
                    dprintf ("%sPin%lX appears bypassed!\n",
                        Tab (TabDepth),
                        Base
                    );
                }
            } else {                        
                dprintf ("%sPin%lX %d (%s, %s) refs=%d\n", 
                    Tab (TabDepth),
                    Base,
                    PinObject -> m_Ext.Public.Id,
                    PinObject -> m_ConnectionFileObject ? "src" : "snk",
                    PinObject -> m_Ext.Public.DataFlow == 
                        KSPIN_DATAFLOW_OUT ? "out" : "in",
                    RefCount
                );
            };

            break;

        }

        case ObjectTypeCKsQueue:
        {
            CKsQueue *QueueObject = (CKsQueue *)Object;

            RefCount = CFriendlyBaseUnknown::GetRefCount (
                FRIENDLY_BU (QueueObject)
                );

            dprintf ("%sQueue%lX r/w/c=%d/%d/%d refs=%ld\n",
                Tab (TabDepth),
                Base,
                QueueObject -> m_FramesReceived,
                QueueObject -> m_FramesWaiting,
                QueueObject -> m_FramesCancelled,
                RefCount
            );

            //
            // If the dump level specifies more information, dump 
            // details about the pipe section.
            //
            if (DumpLevel >= DUMPLVL_SPECIFIC) 
                DumpCircuitPipeRelevencies (
                    TabDepth + 1,
                    (CKsPipeSection *)(QueueObject -> m_PipeSection)
                    );

            break;

        }

        case ObjectTypeCKsRequestor:
        {
            CKsRequestor *RequestorObject = (CKsRequestor *)Object;

            RefCount = CFriendlyBaseUnknown::GetRefCount (
                FRIENDLY_BU (RequestorObject)
                );

            dprintf ("%sReq%lX refs=%ld alloc=%lx size=%d count=%d\n",
                Tab (TabDepth),
                Base,
                RefCount,
                RequestorObject -> m_AllocatorFileObject,
                RequestorObject -> m_FrameSize,
                RequestorObject -> m_FrameCount
            );

            //
            // If the dump level specifies more information, dump
            // details about the pipe section.
            //
            if (DumpLevel >= DUMPLVL_SPECIFIC)
                DumpCircuitPipeRelevencies (
                    TabDepth + 1,
                    (CKsPipeSection *)(RequestorObject -> m_PipeSection)
                    );

            break;

        }

        case ObjectTypeCKsSplitter:
        {
            CKsSplitter *SplitterObject = (CKsSplitter *)Object;

            RefCount = CFriendlyBaseUnknown::GetRefCount (
                FRIENDLY_BU (SplitterObject)
                );

            dprintf ("%sSplit%lX refs=%ld\n",
                Tab (TabDepth),
                Base,
                RefCount
                );

            break;

        }

        case ObjectTypeCKsSplitterBranch:
        {
            CKsSplitterBranch *BranchObject = (CKsSplitterBranch *)Object;

            RefCount = CFriendlyBaseUnknown::GetRefCount (
                FRIENDLY_BU (BranchObject)
                );

            dprintf ("%sBranch%lX refs=%ld\n",
                Tab (TabDepth),
                Base,
                RefCount
                );

            break;
        }

        default:

            dprintf ("%lx: Detected a bad object [%s] in the circuit!\n",
                Base,
                ObjectNames [Type]);
            return TRUE;

    }

    return FALSE;

}

/*************************************************

    Function:

        WalkCircuit

    Description:

        Walk around a circuit, making a callback for each item in the
        circuit (base address and type)

    Arguments:

        Object -
            Starting object address of the walk

        Callback -
            The callback

        CallbackContext -
            The callback context

    Return Value:

        Number of items in the circuit

*************************************************/

ULONG
WalkCircuit (
    IN PVOID Object,
    IN PFNCIRCUIT_WALK_CALLBACK Callback,
    IN PVOID CallbackContext
    )

{

    DWORD Address, Base, TopBase;
    ULONG Result;
    PIKSTRANSPORT NextObj;
    INTERNAL_OBJECT_TYPE CurrentObjectType;
    INTERNAL_OBJECT_TYPE NextObjectType;

    ULONG WalkCount = 0;

    Address = (DWORD)Object;

    //
    // Identify what the heck the user is pointing us at.
    //
    CurrentObjectType = DemangleAndAttemptIdentification (
        Address, &Base, NULL);

    if (CurrentObjectType == ObjectTypeUnknown) {
        dprintf ("%lx: This object cannot be identified!\n", Address);
        return 0;
    }

    TopBase = Base;

    //
    // Walk around the circuit until we get back where we started.  Where
    // we started is TopBase.  Base will be the current base address of the
    // object in the circuit.
    //
    do {

        #ifdef DEBUG_EXTENSION
            dprintf ("Object in circuit: type = %ld, base = %lx\n",
                CurrentObjectType, Base);
        #endif // DEBUG_EXTENSION

        switch (CurrentObjectType) {

            case ObjectTypeCKsPin:
            {
                CMemoryBlock <CKsPin> PinObject;

                if (!ReadMemory (
                    Base,
                    PinObject.Get (),
                    sizeof (CKsPin),
                    &Result
                )) {
                    dprintf ("%lx: cannot read pin object!\n",
                        Base);
                    return WalkCount;
                }

                WalkCount++;

                if (Callback (CallbackContext, CurrentObjectType, 
                    Base, PinObject.Get ())) {
                    NextObj = NULL;
                    break;
                }

                NextObj = PinObject -> m_TransportSink;

                break;

            }

            case ObjectTypeCKsQueue:
            {
                CMemoryBlock <CKsQueue> QueueObject;

                if (!ReadMemory (
                    Base,
                    QueueObject.Get (),
                    sizeof (CKsQueue),
                    &Result
                )) {
                    dprintf ("%lx: cannot read queue object!\n",
                        Base);
                    return WalkCount;
                }

                WalkCount++;

                if (Callback (CallbackContext, CurrentObjectType, 
                    Base, QueueObject.Get ())) {
                    NextObj = NULL;
                    break;
                }

                NextObj = QueueObject -> m_TransportSink;

                break;

            }

            case ObjectTypeCKsRequestor:
            {
                CMemoryBlock <CKsRequestor> RequestorObject;

                if (!ReadMemory (
                    Base,
                    RequestorObject.Get (),
                    sizeof (CKsRequestor),
                    &Result
                )) {
                    dprintf ("%lx: cannot read requestor object!\n",
                        Base);
                    return WalkCount;
                }

                WalkCount++;

                if (Callback (CallbackContext, CurrentObjectType, 
                    Base, RequestorObject.Get ())) {
                    NextObj = NULL;
                    break;
                }

                NextObj = RequestorObject -> m_TransportSink;

                break;

            }

            case ObjectTypeCKsSplitter:
            {
                CMemoryBlock <CKsSplitter> SplitterObject;

                if (!ReadMemory (
                    Base,
                    SplitterObject.Get (),
                    sizeof (CKsSplitter),
                    &Result
                )) {
                    dprintf ("%lx: cannot read splitter object!\n",
                        Base);
                    return WalkCount;
                }

                WalkCount++;

                if (Callback (CallbackContext, CurrentObjectType,
                    Base, SplitterObject.Get ())) {
                    NextObj = NULL;
                    break;
                }

                NextObj = SplitterObject -> m_TransportSink;

                break;

            }

            case ObjectTypeCKsSplitterBranch:
            {
                CMemoryBlock <CKsSplitterBranch> BranchObject;

                if (!ReadMemory (
                    Base,
                    BranchObject.Get(),
                    sizeof (CKsSplitterBranch),
                    &Result)) {
                    dprintf ("%lx: cannot read branch object!\n",
                        Base);
                    return WalkCount;
                }

                WalkCount++;

                if (Callback (CallbackContext, CurrentObjectType,
                    Base, BranchObject.Get ())) {
                    NextObj = NULL;
                    break;
                }

                NextObj = BranchObject -> m_TransportSink;

                break;

            }

            default:

                dprintf ("%lx: Detected a bad object [%s] in the circuit!\n",
                    ObjectNames [CurrentObjectType]);
                return WalkCount;

        }

        #ifdef DEBUG_EXTENSION
            dprintf ("%lx: Next transport in circuit = %lx\n",
                Base, NextObj);
        #endif // DEBUG_EXTENSION

        //
        // NextObj now holds the transport sink of whatever object we're
        // done printing.  Now, we must determine what the heck kind of
        // object this IKsTransport* really is and we must get the base
        // address of it.  Again, DemangleAndAttemptIdentification comes
        // to the rescue.  (So would a PDB <cough cough>, unfortunately,
        // 9x dists don't use them)
        //

        if (NextObj != NULL) {	
    
            CurrentObjectType = DemangleAndAttemptIdentification (
                (DWORD)NextObj,
                &Base,
                NULL
            );
    
            if (CurrentObjectType == ObjectTypeUnknown) {
                dprintf ("%lx: cannot identify next object in circuit!\n",
                    NextObj);
                return WalkCount;
            }

        } else {
            
            Base = 0;

        }

    } while (Base != TopBase && Base != 0 && !CheckControlC ());

    return WalkCount;

}

/**************************************************************************

    AVStream API

**************************************************************************/

/*************************************************

    Function:

        AdjustFileToPublicObject

    Description:

        This is a helper function for the APIs to adjust a file object to
        a public AVStream object.

    Arguments:

        Address -
            The address of the file object

    Return Value:

        The address of the public object associated.  Note, we do not attempt
        to type identify the object

*************************************************/

DWORD 
AdjustFileToPublicObject (
    IN DWORD Address
    )

{
    PKSIOBJECT_HEADER *FSContext, ObjectHeader;
    PVOID Object;
    ULONG Result;

    #ifdef DEBUG_EXTENSION
        if (!signature_check (Address, SignatureFile))
            return Address;
    #endif // DEBUG_EXTENSION

    if (!ReadMemory (
        (DWORD)Address + FIELDOFFSET (FILE_OBJECT, FsContext),
        &FSContext,
        sizeof (PKSIOBJECT_HEADER *),
        &Result)) {

        dprintf ("%08lx: cannot read fscontext of file object!\n", Address);
        return Address;
    }

    if (!ReadMemory (
        (DWORD)FSContext,
        &ObjectHeader,
        sizeof (PKSIOBJECT_HEADER),
        &Result)) {

        dprintf ("%08lx: cannot read object header!\n", FSContext);
        return Address;
    }

    if (!ObjectHeader) {
        dprintf ("%08lx: this does not refer to an AVStream object!\n",
            ObjectHeader);
        return Address;
    }

    if (!ReadMemory (
        (DWORD)ObjectHeader + FIELDOFFSET (KSIOBJECT_HEADER, Object),
        &Object,
        sizeof (PVOID),
        &Result)) {

        dprintf ("%08x: cannot read object from header!\n", ObjectHeader);
        return Address;
    }

    if (!Object) {
        dprintf ("%08lx: this does not refer to an AVStream object!\n",
            Object);
        return Address;
    }

    return (DWORD)Object + FIELDOFFSET (KSPX_EXT, Public);

}

/*************************************************

    Function:

        AdjustIrpToPublicObject

    Description:

        This is a helper function for the APIs to adjust an Irp to a public
        AVStream object. 

    Arguments:

        Address -
            The address of the irp

    Return Value:

        The address of the public object associated.  Note, we do not attempt
        to type identify the object.

*************************************************/

DWORD
AdjustIrpToPublicObject (
    IN DWORD Address
    )

{

    PIO_STACK_LOCATION CurrentIrpStack;
    PFILE_OBJECT FileObject;
    ULONG Result;
    DWORD Public;

    #ifdef DEBUG_EXTENSION
        if (!signature_check (Address, SignatureIrp))
            return Address;
    #endif // DEBUG_EXTENSION

    //
    // Get the current Irp stack location...
    //
    if (!ReadMemory (
        Address + FIELDOFFSET (IRP, Tail.Overlay.CurrentStackLocation),
        &CurrentIrpStack,
        sizeof (PIO_STACK_LOCATION),
        &Result)) {

        dprintf ("%08lx: cannot read current irp stack!\n", Address);
        return Address;
    }

    //
    // Now get file object, and then use the adjuster for that to get
    // the address of the public.
    //
    if (!ReadMemory (
        (DWORD)CurrentIrpStack + FIELDOFFSET (IO_STACK_LOCATION, FileObject),
        &FileObject,
        sizeof (PFILE_OBJECT),
        &Result)) {

        dprintf ("%08lx: cannot read file object of irp stack!\n", 
            CurrentIrpStack);
        return Address;
    }

    //
    // Here's a tricky part.  If this happens to be a create Irp...  the 
    // file object will be the file object of the pin, not of the parent
    // performing the create.  That won't tell us lots on an uninitialized
    // child.  In this case, we adjust such that we dump the parent and inform
    // the user that we're doing this.
    //
    if (irp_stack_match (Address, IRP_MJ_CREATE, (UCHAR)-1)) {

        PFILE_OBJECT ChildFile = FileObject;
        PVOID ChildContext;

        if (!ReadMemory (
            (DWORD)ChildFile + FIELDOFFSET (FILE_OBJECT, RelatedFileObject),
            &FileObject,
            sizeof (PFILE_OBJECT),
            &Result)) {

            dprintf ("%08lx: cannot read parent file object from file object!"
                "\n", ChildFile);
            return Address;
        }

        //
        // Perhaps not the best place to do this informing as this function
        // is intended to adjust.  But it works and it's debug extension
        // code...
        //
        dprintf ("%sIRP %08lx is a create Irp.  Child file object = %08lx\n",
            Tab (INITIAL_TAB), Address, ChildFile);

        if (!ReadMemory (
            (DWORD)ChildFile + FIELDOFFSET (FILE_OBJECT, FsContext),
            &ChildContext,
            sizeof (PVOID),
            &Result)) {

            dprintf ("%08lx: cannot read child FsContext!\n",
                ChildFile);
            return Address;
        }

        //
        // Check to see if the child is before or after header creation.
        //
        if (ChildContext != NULL) {
            dprintf ("%sChild is at least partially created (!ks.dump %08lx "
                "for more).\n",
                Tab (INITIAL_TAB), ChildFile);
        } else {
            dprintf ("%sChild object header is not yet built (create not yet"
                " near complete).\n",
                Tab (INITIAL_TAB), ChildFile);
        }

        dprintf ("%sParent file object %08lx is being displayed!\n\n",
            Tab (INITIAL_TAB), FileObject);
    }

    Public = AdjustFileToPublicObject ((DWORD)FileObject);
    if (Public != (DWORD)FileObject)
        return Public;
    else
        return Address;

}

/*************************************************

    Function:

        dump

    Usage:

        !avstream.dump <Any valid AVStream object> <dump level>

    Description:

        Dump the object presented

*************************************************/

DECLARE_API(dump) {

    DWORD Public, ExtAddr;
    KSPX_EXT ObjExt;
    ULONG Result;
    char objStr[256], lvlStr[256], *pLvl;
    ULONG DumpLevel;

    PIRP IrpInfo = NULL;

    GlobInit ();

    #ifdef DEBUG_EXTENSION
        dprintf ("Attempting to dump structure args=[%s]!\n", args);
    #endif // DEBUG_EXTENSION

    if (!args || args [0] == 0) {
        dprintf ("Usage: !avstream.dump <object>\n");
        return;
    }

    objStr [0] = lvlStr [0] = 0;

    //
    // Get the object address and convert it to the private _EXT address.
    // Read in the KSPX_EXT structure to find out what the heck we're
    // referring to.
    //
    sscanf (args, "%s %s", objStr, lvlStr);

    if (!(Public = Evaluator (objStr)))
        return;

    if (lvlStr && lvlStr [0]) {
        pLvl = lvlStr; while (*pLvl && !isdigit (*pLvl)) pLvl++;

        #ifdef DEBUG_EXTENSION
            dprintf ("pLvl = [%s]\n", pLvl);
        #endif // DEBUG_EXTENSION

        if (*pLvl) {
            sscanf (pLvl, "%lx", &DumpLevel);
        } else {
            DumpLevel = 1;
        }
    } else {
        DumpLevel = 1;
    }

    #ifdef DEBUG_EXTENSION
        dprintf ("Dumping at level %ld\n", DumpLevel);
    #endif // DEBUG_EXTENSION

    //
    // Check first to see if the signature matches that of an irp.  If someone
    // does a !ks.dump irp #, we will end up adjusting the irp to the AVStream
    // object associated with that Irp.  This still requires identification, so
    // we perform the check first and then attempt the ID after that.
    //

    if (signature_check (Public, SignatureIrp)) {
        DWORD OldPublic = Public;

        Public = AdjustIrpToPublicObject (Public);
        if (Public != OldPublic) {
            dprintf ("%sIRP %08lx was adjusted to an object %08lx\n\n",
                Tab (INITIAL_TAB), OldPublic, Public);

            //
            // If the client wants to know everything, let them know
            // everything. 
            //
            if (DumpLevel >= DUMPLVL_EVERYTHING)
                DumpAssociatedIrpInfo ((PIRP)OldPublic, INITIAL_TAB, Public);

        } else {
            dprintf ("%sIRP %08lx could not be adjusted to an AVStream"
                "object!\n", Tab (INITIAL_TAB), OldPublic);
            return;
        }
    } else if (signature_check (Public, SignatureFile)) {
        DWORD OldPublic = Public;

        Public = AdjustFileToPublicObject (Public);
        if (Public != OldPublic) {
            dprintf ("%sFILE OBJECT %08lx was adjusted to an object %08lx\n\n",
                Tab (INITIAL_TAB), OldPublic, Public);
        } else {
            dprintf ("%sFILE OBJECT %08lx could not be adjusted to an AVStream"
                "object!\n", Tab (INITIAL_TAB), OldPublic);
            return;
        }
    }

    //
    // Check first to see if this is a C++ class object within AVStream.
    //
    {
        INTERNAL_OBJECT_TYPE ObjType;
        DWORD BaseAddr;

        ObjType = DemangleAndAttemptIdentification (
            Public,
            &BaseAddr,
            NULL
        );

        if (ObjType != ObjectTypeUnknown) {

            #ifdef DEBUG_EXTENSION
                dprintf ("%08lx: object is a [%s], base address = %08lx\n",
                    Public, ObjectNames [ObjType], BaseAddr);
            #endif // DEBUG_EXTENSION

            switch (ObjType) {

                case ObjectTypeCKsPin:

                    DumpPrivatePin (BaseAddr, DumpLevel, INITIAL_TAB);
                    break;

                case ObjectTypeCKsRequestor:
                    
                    DumpPrivateRequestor (BaseAddr, DumpLevel, INITIAL_TAB);
                    break;

                case ObjectTypeCKsPipeSection:

                    DumpPrivatePipeSection (BaseAddr, DumpLevel, INITIAL_TAB);
                    break;

                case ObjectTypeCKsFilter:
                    
                    DumpPrivateFilter (BaseAddr, DumpLevel, INITIAL_TAB);
                    break;

                case ObjectTypeCKsFilterFactory:

                    DumpPrivateFilterFactory (BaseAddr, DumpLevel, INITIAL_TAB);
                    break;

                case ObjectTypeCKsDevice:

                    DumpPrivateDevice (BaseAddr, DumpLevel, INITIAL_TAB);
                    break;

                case ObjectTypeCKsQueue:

                    DumpQueueContents ((CKsQueue *)BaseAddr, DumpLevel,
                        INITIAL_TAB);
                    break;

                case ObjectTypeCKsSplitter:

                    DumpPrivateSplitter (BaseAddr, DumpLevel, INITIAL_TAB);
                    break;

                case ObjectTypeCKsSplitterBranch:

                    DumpPrivateBranch (BaseAddr, DumpLevel, INITIAL_TAB);
                    break;

                default:

                    dprintf ("Sorry....  I haven't finished this yet!\n");
                    break;

            }

            //
            // We've completed the dump.  Get out.
            //
            return;
        }
    }

    //
    // Check to see whether or not this is another confidentally identifiable
    // object within AVStream.  EXTs are the riskiest to identify, so they're
    // identified last.
    //
    {
        INTERNAL_STRUCTURE_TYPE StrucType;
        DWORD BaseAddr;

        if ((StrucType = IdentifyStructure (Public, &BaseAddr)) != 
            StructureTypeUnknown) {
    
            switch (StrucType) {
    
                case StructureType_KSSTREAM_POINTER:
                {
                    //
                    // The routine expects to have the stream pointer brought
                    // over already.  This is for optimization on queue dumping.
                    // I'm reusing the same routine.
                    //
                    CMemoryBlock <KSPSTREAM_POINTER> StreamPointer;

                    DWORD PrivAddr = (DWORD)
                        CONTAINING_RECORD (BaseAddr,
                            KSPSTREAM_POINTER, Public);
    
                    if (!ReadMemory (
                        PrivAddr,
                        StreamPointer.Get (),
                        sizeof (KSPSTREAM_POINTER),
                        &Result)) {
                        dprintf ("%08lx: cannot read stream pointer!\n",  
                            BaseAddr);
                        return;
                    }
    
                    DumpStreamPointer (StreamPointer.Get (), 
                        PrivAddr, DumpLevel, INITIAL_TAB);

                    return;
    
    
                }
    
                default:
    
                    dprintf ("Sorry....  I haven't finished this yet!\n");
                    return;
    
            }
        }
    }

    //
    // This wasn't recognized as a C++ class object, assume it's a public
    // structure such as a KSPIN, KSFILTER, etc...  Scan for what the
    // heck it is.
    //
    #ifdef DEBUG_EXTENSION
        dprintf ("Attempting to identify %08lx at level %08lx\n", Public,
            DumpLevel);
    #endif // DEBUG_EXTENSION

    ExtAddr = (DWORD)(CONTAINING_RECORD(Public, KSPX_EXT, Public));

    if (!ReadMemory (
        ExtAddr,
        &ObjExt,
        sizeof (KSPX_EXT),
        &Result
    )) {
        dprintf ("%08lx: could not read object!\n", Public);
        return;
    }

    switch (ObjExt.ObjectType) {

        case KsObjectTypeDevice:
            dprintf ("%s%08lx: object is a KSDEVICE:\n", 
                Tab (INITIAL_TAB), Public);
            DumpPublicDevice (Public, DumpLevel, INITIAL_TAB);
            break;
        
        case KsObjectTypeFilterFactory:
            dprintf ("%s%08lx: object is a KSFILTERFACTORY\n", 
                Tab (INITIAL_TAB), Public);
            DumpPublicFilterFactory (Public, DumpLevel, INITIAL_TAB);
            break;

        case KsObjectTypeFilter:
            dprintf ("%s%08lx: object is a KSFILTER\n", 
                Tab (INITIAL_TAB), Public);
            DumpPublicFilter (Public, DumpLevel, INITIAL_TAB);
            break;

        case KsObjectTypePin:
            dprintf ("%s%08lx: object is a KSPIN\n", 
                Tab (INITIAL_TAB), Public);
            DumpPublicPin (Public, DumpLevel, INITIAL_TAB);
            break;

        default: {

            dprintf ("%s%08lx: object is not identifiable\n", 
                Tab (INITIAL_TAB), Public);
            break;

        }

    }

}

/*************************************************

    Function:

        dumpbag

    Usage:

        !avstream.dumpbag <device -> pin> [<dump level>]

    Description:

        Dump the object presented

*************************************************/

DECLARE_API(dumpbag) {

    DWORD Public, ExtAddr, PublicBagAddr;
    KSPX_EXT ObjExt;
    ULONG Result;
    char objStr[256], lvlStr[256], *pLvl;
    ULONG DumpLevel;
    PKSIOBJECTBAG BagAddr;

    GlobInit ();

    #ifdef DEBUG_EXTENSION
        dprintf ("Attempting to dump bag args=[%s]!\n", args);
    #endif // DEBUG_EXTENSION

    if (!args || args [0] == 0) {
        dprintf ("Usage: !avstream.dumpbag <object> [<level>]\n");
        return;
    }

    objStr [0] = lvlStr [0] = 0;

    //
    // Get the object address and convert it to the private _EXT address.
    // Read in the KSPX_EXT structure to find out what the heck we're
    // referring to.
    //
    sscanf (args, "%s %s", objStr, lvlStr);

    if (!(Public = Evaluator (objStr)))
        return;

    if (lvlStr && lvlStr [0]) {
        pLvl = lvlStr; while (*pLvl && !isdigit (*pLvl)) pLvl++;

        #ifdef DEBUG_EXTENSION
            dprintf ("pLvl = [%s]\n", pLvl);
        #endif // DEBUG_EXTENSION

        if (*pLvl) {
            sscanf (pLvl, "%lx", &DumpLevel);
        } else {
            DumpLevel = 1;
        }
    } else {
        DumpLevel = 1;
    }

    #ifdef DEBUG_EXTENSION
        dprintf ("Dumping at level %ld\n", DumpLevel);
    #endif // DEBUG_EXTENSION

    //
    // Check first to see if this is a C++ class object within AVStream.
    //
    {
        INTERNAL_OBJECT_TYPE ObjType;
        DWORD BaseAddr;

        ObjType = DemangleAndAttemptIdentification (
            Public,
            &BaseAddr,
            NULL
        );

        if (ObjType != ObjectTypeUnknown) {

            #ifdef DEBUG_EXTENSION
                dprintf ("%08lx: object is a [%s], base address = %08lx\n",
                    Public, ObjectNames [ObjType], BaseAddr);
            #endif // DEBUG_EXTENSION

            switch (ObjType) {

                case ObjectTypeCKsPin:

                    ExtAddr = FIELDOFFSET (CKsPin, m_Ext) + BaseAddr;
                    break;

                case ObjectTypeCKsFilter:

                    ExtAddr = FIELDOFFSET (CKsFilter, m_Ext) + BaseAddr;
                    break;

                case ObjectTypeCKsFilterFactory:

                    ExtAddr = FIELDOFFSET (CKsFilterFactory, m_Ext) +
                        BaseAddr;
                    break;

                case ObjectTypeCKsDevice:

                    ExtAddr = FIELDOFFSET (CKsDevice, m_Ext) + BaseAddr;
                    break;

                default:

                    dprintf ("%08lx: object has no bag!\n");
                    return;
                
            }

        } else {
            //
            // Try to identify the object as a public structure, not a private
            // AVStream class obj.
            //
            #ifdef DEBUG_EXTENSION
                dprintf ("Attempting to identify %08lx at level %08lx\n", Public,
                    DumpLevel);
            #endif // DEBUG_EXTENSION
        
            ExtAddr = (DWORD)(CONTAINING_RECORD(Public, KSPX_EXT, Public));

        }

    }

    #ifdef DEBUG_EXTENSION
        dprintf ("Bag: ExtAddr = %08lx\n", ExtAddr);
    #endif // DEBUG_EXTENSION

    if (!ReadMemory (
        ExtAddr,
        &ObjExt,
        sizeof (KSPX_EXT),
        &Result
    )) {
        dprintf ("%08lx: could not read object!\n", Public);
        return;
    }

    //
    // All Ext'ables have bags.  Find the bag
    //
    switch (ObjExt.ObjectType) {
        
        case KsObjectTypeDevice:

            PublicBagAddr = ExtAddr + FIELDOFFSET (KSDEVICE_EXT, Public) +
                FIELDOFFSET (KSDEVICE, Bag);

            dprintf ("%sDevice %08lx [Ext = %08lx, CKsDevice = %08lx]:\n",
                Tab (INITIAL_TAB),
                FIELDOFFSET (KSDEVICE_EXT, Public) + ExtAddr,
                ExtAddr,
                CONTAINING_RECORD (ExtAddr, CKsDevice, m_Ext)
            );

            break;
        
        case KsObjectTypeFilterFactory:

            PublicBagAddr = ExtAddr + FIELDOFFSET (KSFILTERFACTORY_EXT, 
                Public) + FIELDOFFSET (KSFILTERFACTORY, Bag);

            dprintf ("%sFilter Factory %08lx [Ext = %08lx, "
                "CKsFilterFactory = %08lx]:\n",
                Tab (INITIAL_TAB),
                FIELDOFFSET (KSFILTERFACTORY_EXT, Public) + ExtAddr,
                ExtAddr,
                CONTAINING_RECORD (ExtAddr, CKsFilterFactory, m_Ext)
            );
            break;

        case KsObjectTypeFilter:

            PublicBagAddr = ExtAddr + FIELDOFFSET (KSFILTER_EXT, Public) +
                FIELDOFFSET (KSFILTER, Bag);

            dprintf ("%sFilter %08lx [Ext = %08lx, CKsFilter = %08lx]:\n",
                Tab (INITIAL_TAB),
                FIELDOFFSET (KSFILTER_EXT, Public) + ExtAddr,
                ExtAddr,
                CONTAINING_RECORD (ExtAddr, CKsFilter, m_Ext)
            );
            break;

        case KsObjectTypePin:

            PublicBagAddr = ExtAddr + FIELDOFFSET(KSPIN_EXT, Public) +
                FIELDOFFSET (KSPIN, Bag);
            
            dprintf ("%sPin %08lx [Ext = %08lx, CKsPin = %08lx]:\n",
                Tab (INITIAL_TAB),
                FIELDOFFSET (KSFILTER_EXT, Public) + ExtAddr,
                ExtAddr,
                CONTAINING_RECORD (ExtAddr, CKsPin, m_Ext)
            );
            break;

        default:

            dprintf ("%08lx: unrecognized object!\n",
                Public);
            break;

    }

    if (!ReadMemory (
        PublicBagAddr,
        &BagAddr,
        sizeof (PKSIOBJECTBAG),
        &Result)) {

        dprintf ("%08lx: unable to read object bag pointer!\n", 
            PublicBagAddr);
        return;
    }

    #ifdef DEBUG_EXTENSION
        dprintf ("About to dump bag at %08lx\n", BagAddr);
    #endif // DEBUG_EXTENSION

    //
    // Dump the bag contents.
    //
    DumpPrivateBag ((DWORD)BagAddr, DumpLevel, INITIAL_TAB + 1);

}

/*************************************************

    Function:

        dumpcircuit

    Usage:

        !avstream.dumpcircuit <AVStream class>

    Description:

        Dump the circuit associated with a given AVStream object.
        We begin with the object specified and walk around the
        transport circuit.  This requires a special kind of magic
        since everything is done through abstract base classes and
        IKsTransport.  However, DemangleAndAttemptIdentification is the
        key to all of this magic.

*************************************************/

DECLARE_API (dumpcircuit) {

    DWORD Address, Base, TopBase;
    char objStr[256], lvlStr[256], *pLvl;
    ULONG DumpLevel;
    DUMP_CIRCUIT_CONTEXT DumpContext;

    ULONG TabDepth = INITIAL_TAB;

    GlobInit ();

    if (!args || args [0] == 0) {
        dprintf ("Usage: !avstream.dumpcircuit <AVStream class object>\n");
        return;
    }

    sscanf (args, "%s %s", objStr, lvlStr);

    if (!(Address = Evaluator (objStr)))
        return;

    if (lvlStr && lvlStr [0]) {
        pLvl = lvlStr; while (*pLvl && !isdigit (*pLvl)) pLvl++;

        #ifdef DEBUG_EXTENSION
            dprintf ("pLvl = [%s]\n", pLvl);
        #endif // DEBUG_EXTENSION

        if (*pLvl) {
            sscanf (pLvl, "%lx", &DumpLevel);
        } else {
            DumpLevel = 1;
        }
    } else {
        DumpLevel = 1;
    }

    #ifdef DEBUG_EXTENSION
        dprintf ("Dumping at level %ld\n", DumpLevel);
    #endif // DEBUG_EXTENSION

    DumpContext.TabDepth = INITIAL_TAB;
    DumpContext.DumpLevel = DumpLevel;

    WalkCircuit (
        (PVOID)Address, 
        DumpCircuitCallback,
        &DumpContext
        );

}

/*************************************************

    Function:

        EnumerateDeviceObject

    Description:

        Find the AVStream device object associated with the given
        WDM device object; enumerate all filter types and filters
        associated with it.

    Arguments:

        Address -
            The device object address on the target

        TabDepth -
            The tab depth to print this at

    Return Value:

        The next device object in the driver's chain.

*************************************************/

DWORD AdjustFilterExtToKSFILTER (
    IN PVOID Context,
    IN DWORD FilterExt
) {

    return (FilterExt + FIELDOFFSET (KSFILTER_EXT, Public));
}

PDEVICE_OBJECT
EnumerateDeviceObject (
    IN DWORD Address,
    IN ULONG TabDepth
) {

    DWORD ObjAddress;
    PKSIDEVICE_HEADER HeaderAddr;
    DEVICE_OBJECT DevObj;
    ULONG Result;
    PKSDEVICE DevAddr;
    KSDEVICE_EXT DeviceExt;
    DWORD ListBeginAddr, SubListBeginAddr;
    LIST_ENTRY ListEntry, SubListEntry;

    if (!ReadMemory (
        Address,
        &DevObj,
        sizeof (DEVICE_OBJECT),
        &Result
    )) {
        dprintf ("%08lx: unable to read WDM device object!\n",
            Address);
        return NULL;
    }

    if (DevObj.Type != IO_TYPE_DEVICE) {
        dprintf ("%08lx: this is **NOT** a WDM device object!\n",
            Address);
        return NULL;
    }

    if (!ReadMemory (
        (DWORD)DevObj.DeviceExtension,
        &HeaderAddr,
        sizeof (PKSIDEVICE_HEADER),
        &Result
    )) {
        dprintf ("%08lx: cannot read device header!\n",
            DevObj.DeviceExtension);
        return DevObj.NextDevice;
    }

    ObjAddress = (DWORD)HeaderAddr + FIELDOFFSET(KSIDEVICE_HEADER, Object);

    if (!ReadMemory (
        ObjAddress,
        &DevAddr,
        sizeof (PKSDEVICE),
        &Result
    )) {
        dprintf ("%08lx: cannot read object pointer!\n",
            ObjAddress);
        return DevObj.NextDevice;
    }

    if (!ReadMemory (
        (DWORD)DevAddr - FIELDOFFSET(KSDEVICE_EXT, Public), 
        &DeviceExt,
        sizeof (KSDEVICE_EXT),
        &Result
    )) {
        dprintf ("%08lx: cannot read KSDEVICE object!\n",
            DevAddr);
        return DevObj.NextDevice;
    }

    dprintf ("%sWDM device object %08lx:\n", 
        Tab (TabDepth), Address);
    TabDepth++;
    dprintf ("%sCorresponding KSDEVICE        %08lx\n", 
        Tab (TabDepth), DevAddr);

    //
    // Enumerate all filter factory types
    //
    ListBeginAddr = (DWORD)DevAddr - FIELDOFFSET(KSDEVICE_EXT, Public) +
        FIELDOFFSET(KSDEVICE_EXT, ChildList);
    ListEntry = DeviceExt.ChildList;
    while ((DWORD)ListEntry.Flink != ListBeginAddr && !CheckControlC ()) {
        
        DWORD ChildObjectAddr;
        KSFILTERFACTORY_EXT FactoryExt;
        ULONG Count;

        //
        // Get the address of the child's _EXT.
        //
        ChildObjectAddr = (DWORD)CONTAINING_RECORD (
            ListEntry.Flink,
            KSPX_EXT,
            SiblingListEntry
        );

        //
        // Read the factory.
        //
        if (!ReadMemory (
            ChildObjectAddr,
            &FactoryExt,
            sizeof (KSFILTERFACTORY_EXT),
            &Result
        )) {
            dprintf ("%08lx: unable to read factory!\n", ChildObjectAddr);
            return DevObj.NextDevice;
        }

        dprintf ("%sFactory %08lx [Descriptor %08lx] instances:\n",
            Tab (TabDepth),
            ChildObjectAddr,
            FactoryExt.Public.FilterDescriptor
        );
        dprintf ("%s", Tab (TabDepth + 1));

        //
        // Use the ever handy DumpObjQueueList to dump all filter instances
        // on this factory.
        //
        Count = DumpObjQueueList (
            &(FactoryExt.ChildList),
            FIELDOFFSET(KSFILTERFACTORY_EXT, ChildList) + 
                ChildObjectAddr,
            FIELDOFFSET(KSFILTER_EXT, SiblingListEntry),
            FALSE,
            AdjustFilterExtToKSFILTER,
            NULL
        );
        if (Count == 0) 
            dprintf ("No instantiated filters!\n");
        else
            dprintf ("\n");

        if (!ReadMemory (
            (DWORD)(ListEntry.Flink),
            &ListEntry,
            sizeof (LIST_ENTRY),
            &Result
        )) {
            dprintf ("%08lx: unable to follow object chain!\n",
                ChildObjectAddr);
            return DevObj.NextDevice;
        }

    }

    return DevObj.NextDevice;
}

/*************************************************

    Function:

        enumdevobj

    Usage:

        !avstream.enumdevobj <WDM device object>

    Description:

        Find the AVStream device object associated with the given WDM
        device object and enumerate all filter types and instantiated
        filters on the device.

*************************************************/

DECLARE_API(enumdevobj) {

    DWORD Address;

    GlobInit ();

    if (!args || args [0] == 0) {
        dprintf ("Usage: !avstream.enumdevobj <WDM device object>\n");
        return;
    }

    sscanf (args, "%lx", &Address);

    EnumerateDeviceObject (Address, INITIAL_TAB);

}

/*************************************************

    Function:

        enumdrvobj

    Usage:

        !avstream.enumdrvobj <WDM driver object>

    Description:

        Find the AVStream device object associated with the given WDM
        driver object and enumerate all filter types and instantiated
        filters on the device.

*************************************************/

DECLARE_API(enumdrvobj) {

    DWORD Address;
    DRIVER_OBJECT Driver;
    PDEVICE_OBJECT DeviceObject, NextDeviceObject;
    ULONG Result;

    ULONG TabDepth = INITIAL_TAB;

    GlobInit ();

    if (!args || args [0] == 0) {
        dprintf ("Usage: !avstream.enumdevobj <WDM device object>\n");
        return;
    }

    sscanf (args, "%lx", &Address);

    if (!ReadMemory (
        Address,
        &Driver,
        sizeof (DRIVER_OBJECT),
        &Result
    )) {
        dprintf ("%08lx: cannot read driver object!\n", Address);
        return;
    }

    if (Driver.Type != IO_TYPE_DRIVER) {
        dprintf ("%08lx: this is **NOT** a WDM driver object!\n",
            Address);
        return;
    }

    dprintf ("%sWDM driver object %08lx:\n", Tab (TabDepth), Address);
    TabDepth++;
    DeviceObject = Driver.DeviceObject;

    //
    // Walk the driver object's device list and enumerate each
    // device object for AVStream objects.
    //
    while (DeviceObject && !CheckControlC ()) {
        NextDeviceObject = EnumerateDeviceObject (
            (DWORD)DeviceObject,
            TabDepth
        );
        dprintf ("\n");

        DeviceObject = NextDeviceObject;
    }

}

/*************************************************

    Function:

        automation

    Usage:

        !avstream.automation <Filter | Pin>

    Description:

        Dump all automation objects associated with the specified filter
        or pin.  Clients can provide either a PKSFILTER, a PKSPIN,
        a CKsFilter*, or a CKsPin*

*************************************************/

DECLARE_API(automation) {

    DWORD Public, ExtAddr, BaseAddr;
    KSPX_EXT Ext;
    KSAUTOMATION_TABLE Automation;
    PKSPAUTOMATION_TYPE AutomationType;
    LONG TypeCount;
    ULONG Result, SetSize;
    CHAR Buffer [1024];
    ULONG Displ;

    ULONG TabDepth = INITIAL_TAB;

    GlobInit ();

    if (!args || args [0] == 0) {
        dprintf ("Usage: !avstream.automation <filter or pin or Irp>\n");
        return;
    }

    if (!(Public = Evaluator (args)))
        return;

    //
    // First, check to see whether this is an Irp for automation.  If it 
    // is, dump the automation information
    //
    if (signature_check (Public, SignatureIrp)) {

        //
        // If this is an Irp, verify it's an automation Irp.
        //
        PIO_STACK_LOCATION IoStackLocation;
        IO_STACK_LOCATION IoStack;

        if (!ReadMemory (
            (DWORD)Public + 
                FIELDOFFSET (IRP, Tail.Overlay.CurrentStackLocation),
            &IoStackLocation,
            sizeof (PIO_STACK_LOCATION),
            &Result)) {

            dprintf ("%08lx: cannot read current stack location!\n", Public);
            return;
        }

        if (!ReadMemory (
            (DWORD)IoStackLocation,
            &IoStack,
            sizeof (IO_STACK_LOCATION),
            &Result)) {

            dprintf ("%08lx: cannot read io stack location!\n", 
                IoStackLocation);
            return;

        }

        if (IoStack.MajorFunction != IRP_MJ_DEVICE_CONTROL ||
            (IoStack.Parameters.DeviceIoControl.IoControlCode !=
                IOCTL_KS_PROPERTY &&
            IoStack.Parameters.DeviceIoControl.IoControlCode !=
                IOCTL_KS_METHOD &&
            IoStack.Parameters.DeviceIoControl.IoControlCode !=
                IOCTL_KS_ENABLE_EVENT &&
            IoStack.Parameters.DeviceIoControl.IoControlCode !=
                IOCTL_KS_DISABLE_EVENT)) {

            dprintf ("%08lx: Irp is not an automation Irp!\n", Public);
            return;
        }

        //
        // At this point, we know we have an automation Irp; deal with
        // the information.
        //
        DWORD OldPublic = Public;

        Public = AdjustIrpToPublicObject (Public);
        if (Public != OldPublic) {
            //
            // If the client wants to know everything, let them know
            // everything. 
            //
            DumpAssociatedIrpInfo ((PIRP)OldPublic, INITIAL_TAB, Public);
        } else {
            dprintf ("%08lx: cannot figure out what public this is"
                "associated with!\n", OldPublic);
            return;
        }

        //
        // We only wanted to dump the associated automation information,
        // not the complete automation information associated with 
        // the object.
        //
        // BUGBUG: There should be a method of specifying dump level and
        // allowing a 7 to dump the entire automation lot.
        //
        return;

    }

    //
    // Check first to see if this is a C++ class object within AVStream.
    //
    {
        INTERNAL_OBJECT_TYPE ObjType;
        DWORD BaseAddr;

        ObjType = DemangleAndAttemptIdentification (
            Public,
            &BaseAddr,
            NULL
        );

        if (ObjType != ObjectTypeUnknown) {

            switch (ObjType) {

                case ObjectTypeCKsPin:

                    ExtAddr = BaseAddr + FIELDOFFSET(CKsPin, m_Ext);

                    break;

                case ObjectTypeCKsFilter:

                    ExtAddr = BaseAddr + FIELDOFFSET(CKsFilter, m_Ext);
                    
                    break;
                
                default:

                    dprintf ("%08lx: object is not a pin or filter!\n",
                        Public);
                    break;

            }
        } else 
            ExtAddr = (DWORD)(CONTAINING_RECORD(Public, KSPX_EXT, Public));
    }

    if (!ReadMemory (
        ExtAddr,
        &Ext,
        sizeof (KSPX_EXT),
        &Result)) {

        dprintf ("%08lx: unable to read Ext structure!\n", Public);
        return;
    }

    if (Ext.ObjectType != KsObjectTypePin && 
        Ext.ObjectType != KsObjectTypeFilter) {
        dprintf ("%08lx: object is not a pin or filter!\n",
            Public);
        return;
    }

    if (Ext.ObjectType == KsObjectTypePin) 
        dprintf ("%sPin %08lx has the following automation items:\n",
            Tab (TabDepth),
            ExtAddr + FIELDOFFSET(KSPIN_EXT, Public));
    else
        dprintf ("%sFilter %08lx has the following automation items:\n",
            Tab (TabDepth),
            ExtAddr + FIELDOFFSET(KSFILTER_EXT, Public));

    #ifdef DEBUG_EXTENSION
        dprintf ("%08lx: automation table at %08lx",
            ExtAddr, Ext.AutomationTable);
    #endif // DEBUG_EXTENSION

    TabDepth++;

    //
    // The EXT contains the automation table pointer.  Now, we have to read
    // in the automation table and then walk through each automation item.
    //
    if (!ReadMemory (
        (DWORD)Ext.AutomationTable,
        &Automation,
        sizeof(KSAUTOMATION_TABLE),
        &Result)) {

        dprintf ("%08lx: unable to read automation table!\n", 
            Ext.AutomationTable);
        return;
    }

    AutomationType = reinterpret_cast<PKSPAUTOMATION_TYPE>(&Automation);
    TypeCount = 3;
    while (TypeCount-- && !CheckControlC ()) {

        switch (TypeCount) {

            case 2:
                dprintf ("%sProperty Items:\n", Tab (TabDepth));
                SetSize = sizeof(KSPROPERTY_SET);
                break;
            case 1:
                dprintf ("%sMethod Items:\n", Tab (TabDepth));
                SetSize = sizeof(KSMETHOD_SET);
                break;
            case 0:
                dprintf ("%sEvent Items:\n", Tab (TabDepth));
                SetSize = sizeof(KSEVENT_SET);
                break;

        };

        //
        // Scope out the memory allocation and deallocation
        //
        if (AutomationType -> SetsCount != 0) 
        {
            CMemory AutomationSets (SetSize * AutomationType -> SetsCount);
            ULONG SetsCount = AutomationType -> SetsCount;
            PKSPAUTOMATION_SET AutomationSet = 
                (PKSPAUTOMATION_SET)AutomationSets.Get ();

            #ifdef DEBUG_EXTENSION
                dprintf ("%08lx: reading type set list [size=%ld]\n",
                    AutomationType -> Sets,
                    AutomationType -> SetsCount);
            #endif // DEBUG_EXTENSION

            if (!ReadMemory (
                (DWORD)AutomationType -> Sets,
                AutomationSet,
                SetSize * AutomationType -> SetsCount,
                &Result)) {

                dprintf ("%08lx: could not read automation sets!\n",
                    AutomationType -> Sets);
                return;
            }

            while (SetsCount-- && !CheckControlC ()) {

                ULONG ItemsCount;
                PVOID Items;
                GUID guid;

                if (!ReadMemory (
                    (DWORD)AutomationSet -> Set,
                    &guid,
                    sizeof (GUID),
                    &Result)) {

                    dprintf ("%08lx: cannot read set guid!\n",
                        AutomationSet -> Set);
                    return;
                }

                //
                // First display the information about this set.
                //
                dprintf ("%sSet", Tab (TabDepth + 1));
                if (!DisplayNamedAutomationSet (&guid, " %s\n")) {
                    GetSymbol ((LPVOID)(AutomationSet -> Set), Buffer, &Displ);
                    if (Buffer [0] && Displ == 0) 
                        dprintf (" [%s]", Buffer);
                    XTN_DUMPGUID(" ", 0, (guid));
                }

                if (AutomationSet -> ItemsCount)
                {

                    CMemory AutomationItems (AutomationSet -> ItemsCount *
                        AutomationType -> ItemSize);
                    ULONG ItemsCount = AutomationSet -> ItemsCount;
                    PVOID Item = AutomationItems.Get ();

                    #ifdef DEBUG_EXTENSION
                        dprintf ("%08lx: reading automation set item list "
                            "[size = %ld]\n",
                            AutomationSet -> Items, 
                            AutomationSet -> ItemsCount);
                    #endif // DEBUG_EXTENSION

                    if (!ReadMemory (
                        (DWORD)AutomationSet -> Items,
                        Item,
                        AutomationSet -> ItemsCount * 
                            AutomationType -> ItemSize,
                        &Result)) {

                        dprintf ("%08lx: could not read automation items!\n",
                            AutomationSet -> Items);
                        return;
                    }

                    while (ItemsCount-- && !CheckControlC ()) {

                        switch (TypeCount) {
                            
                            case 2:

                                DumpPropertyItem (
                                    reinterpret_cast<PKSPROPERTY_ITEM>(
                                        Item),
                                    TabDepth + 2,
                                    &guid
                                    );

                                break;

                            case 1:

                                DumpMethodItem (
                                    reinterpret_cast<PKSMETHOD_ITEM>(
                                        Item),
                                    TabDepth + 2,
                                    &guid
                                    );

                                break;

                            case 0:

                                DumpEventItem (
                                    reinterpret_cast<PKSEVENT_ITEM>(
                                        Item),
                                    TabDepth + 2,
                                    &guid
                                    );
                                
                                break;

                        }

                        Item = (PVOID)(((DWORD)Item) + AutomationType -> 
                            ItemSize);

                    }

                    AutomationSet = (PKSPAUTOMATION_SET)
                        (((DWORD)AutomationSet) + SetSize);
                }


            }
        } else 
            dprintf ("%sNO SETS FOUND!\n", Tab (TabDepth + 1));

        AutomationType++;
    
    }
}

/*************************************************

    Function:

        dumpqueue

    Usage:

        !avstream.dumpqueue <Filter | Pin | Queue>

    Description:

        Dump the queue(s) associated with a given AVStream object.  The
        object must be either a filter or a pin.  For a pin, a single
        queue will be dumped.  For a filter, multiple queues will be
        dumped.

*************************************************/

DECLARE_API(dumpqueue) {

    DWORD Public, ExtAddr;
    KSPX_EXT ObjExt;
    char objStr[256], lvlStr[256], *pLvl;
    ULONG Result;
    ULONG DumpLevel;

    ULONG TabDepth = INITIAL_TAB;

    GlobInit ();

    if (!args || args [0] == 0) {
        dprintf ("Usage: !avstream.dumpqueue <pin or filter>\n");
        return;
    }

    objStr [0] = lvlStr [0] = 0;

    //
    // Get the object address and convert it to the private _EXT address.
    // Read in the KSPX_EXT structure to find out what the heck we're
    // referring to.
    //
    sscanf (args, "%s %s", objStr, lvlStr);

    if (!(Public = Evaluator (objStr)))
        return;

    if (lvlStr && lvlStr [0]) {
        pLvl = lvlStr; while (*pLvl && !isdigit (*pLvl)) pLvl++;
        if (*pLvl) {
            sscanf (pLvl, "%lx", &DumpLevel);
        } else {
            DumpLevel = 1;
        }
    } else {
        DumpLevel = 1;
    }
    ExtAddr = (DWORD)(CONTAINING_RECORD (Public, KSPX_EXT, Public));

    //
    // First, we assume they handed us a CKsQueue to dump....  We must check
    // that.  If they didn't hand us a queue, check for a pin or a filter.
    //
    {
        INTERNAL_OBJECT_TYPE ObjType;
        DWORD BaseAddr;

        ObjType = DemangleAndAttemptIdentification (
            Public,
            &BaseAddr,
            NULL
        );

        if (ObjType == ObjectTypeCKsQueue) {

            DumpQueueContents ((CKsQueue *)BaseAddr, DumpLevel, TabDepth);
            return;

        }

        //
        // Check if they're passing us the privates before trying to guess
        // publics.
        //
        if (ObjType == ObjectTypeCKsPin) 
            ExtAddr = BaseAddr + FIELDOFFSET(CKsPin, m_Ext);

        if (ObjType == ObjectTypeCKsFilter)
            ExtAddr = BaseAddr + FIELDOFFSET(CKsFilter, m_Ext);


        //
        // Otherwise, fall through and continue trying to figure out
        // what the heck the user handed us.
        //

        #ifdef DEBUG_EXTENSION
            dprintf ("ObjType = %ld, BaseAddr = %08lX, ExtAddr = %08lX\n", 
                ObjType, BaseAddr, ExtAddr);
        #endif // DEBUG_EXTENSION

    }

    #ifdef DEBUG_EXTENSION
        dprintf ("Attempting to access EXT at %lx\n", ExtAddr);
    #endif // DEBUG_EXTENSION

    if (!ReadMemory (
        ExtAddr,
        &ObjExt,
        sizeof (KSPX_EXT),
        &Result
    )) {
        dprintf ("%08lx: Could not read object!\n", Public);
        return;
    }

      #ifdef DEBUG_EXTENSION
        dprintf ("Object %lx read, result = %ld\n", ExtAddr, Result); 
        HexDump ((PVOID)&ObjExt, ExtAddr, Result);
      #endif // DEBUG_EXTENSION

    if (ObjExt.ObjectType != KsObjectTypeFilter &&
        ObjExt.ObjectType != KsObjectTypePin) {

        dprintf ("%08lx: This object is not an AVStream filter or pin!\n",
            Public);
    
        #ifdef DEBUG_EXTENSION
            dprintf ("Object type %08lx = %ld\n", Public, ObjExt.ObjectType);
        #endif // DEBUG_EXTENSION

        return;
    }

    //
    // If we've been asked to dump the queue of a given pin, then
    // we only need to dump a single queue.  On the other hand, if we're
    // asked for the filter, then we iterate through all pipe sections on
    // the filter and dump all queues.
    //
    if (ObjExt.ObjectType == KsObjectTypePin) {

        DWORD Address;
        PKSPPROCESSPIN ProcessPin;
        PKSPPROCESSPIPESECTION ProcessPipe;
        PIKSQUEUE Queue;
        CKsQueue *QueueObject;

        Address = FIELDOFFSET (KSPIN_EXT, ProcessPin) + ExtAddr;

        #ifdef DEBUG_EXTENSION
            dprintf ("Process Pin Address = %08lx\n", Address);
        #endif // DEBUG_EXTENSION

        if (!ReadMemory (
            Address,
            &ProcessPin,
            sizeof (PKSPPROCESSPIN),
            &Result
        )) {
            dprintf ("FATAL: Cannot read process pin!\n");
            return;
        }

        //
        // We have the process pin address, now we need to grovel down into
        // the pipe section
        //
        Address = FIELDOFFSET (KSPPROCESSPIN, PipeSection) + (DWORD)ProcessPin;

        #ifdef DEBUG_EXTENSION
            dprintf ("Process Pipe Section Address = %08lx\n", Address);
        #endif // DEBUG_EXTENSION

        if (!ReadMemory (
            Address,
            &ProcessPipe,
            sizeof (PKSPPROCESSPIPESECTION),
            &Result
        )) {
            dprintf ("FATAL: Cannot read process pipe section!\n");
            return;
        }

        //
        // We have the process pipe, now we need to grovel down into the
        // queue.
        //
        Address = FIELDOFFSET (KSPPROCESSPIPESECTION, Queue) + 
            (DWORD)ProcessPipe;

        #ifdef DEBUG_EXTENSION
            dprintf ("IKsQueue address = %08lx\n", Address);
        #endif // DEBUG_EXTENSION

        if (!ReadMemory (
            Address,
            &Queue,
            sizeof (PIKSQUEUE),
            &Result
        )) {
            dprintf ("FATAL: Cannot read queue!\n");
            return;
        }

        //
        // Upcast the interface and dump the queue.
        //
        QueueObject = (CKsQueue *)(Queue);

        #ifdef DEBUG_EXTENSION
            dprintf ("QueueObject Address = %08lx\n", QueueObject);
        #endif // DEBUG_EXTENSION

        DumpQueueContents (QueueObject, DumpLevel, TabDepth);

    }

    //
    // We're not just dumping a single pin....  We're dumping every queue
    // on the filter.  We must get to the filter object and iterate through
    // the list of input and output pipes, dumping the queue for each.
    //
    else {

        DWORD FilterAddress, ListAddress, Address;
        LIST_ENTRY IterateEntry;
        PIKSQUEUE Queue;
        CKsQueue *QueueObject;

        FilterAddress = (DWORD)(CONTAINING_RECORD (ExtAddr, CKsFilter, m_Ext));

        //
        // First iterate through all the input pipes.
        //
        ListAddress = FIELDOFFSET (CKsFilter, m_InputPipes) + FilterAddress;

        #ifdef DEBUG_EXTENSION
            dprintf ("Filter Address=%08lx, ListAddress=%08lx\n",
                FilterAddress, ListAddress);
        #endif // DEBUG_EXTENSION

        if (!ReadMemory (
            ListAddress,
            &IterateEntry,
            sizeof (LIST_ENTRY),
            &Result
        )) {
            dprintf ("FATAL: Cannot read input pipes\n");
            return;
        }
        
        while ((DWORD)(IterateEntry.Flink) != ListAddress && 
            !CheckControlC ()) {

            #ifdef DEBUG_EXTENSION
                dprintf ("Current input queue %08lx, end = %08lx\n",
                    IterateEntry.Flink, ListAddress);
            #endif // DEBUG_EXTENSION

            Address = FIELDOFFSET (KSPPROCESSPIPESECTION, Queue) +
                (DWORD)IterateEntry.Flink;

            if (!ReadMemory (
                Address,
                &Queue,
                sizeof (PIKSQUEUE),
                &Result
            )) {
                dprintf ("FATAL: Cannot read queue!\n");
                return;
            }

            //
            // Upcast, print header, and dump the queue object.
            //
            QueueObject = (CKsQueue *)(Queue);

            dprintf ("%sFilter %08lx: Input Queue %08lx:\n",
                Tab (TabDepth),
                Public, QueueObject);

            DumpQueueContents (QueueObject, DumpLevel, TabDepth + 1);

            //
            // Get the next item in the list....
            //
            if (!ReadMemory (
                (DWORD)(IterateEntry.Flink),
                &IterateEntry,
                sizeof (LIST_ENTRY),
                &Result
            )) {
                dprintf ("FATAL: Cannot traverse input pipe chain\n");
                return;
            }
        }

        //
        // Next iterate through all output pipes.
        //
        ListAddress = FIELDOFFSET(CKsFilter, m_OutputPipes) + FilterAddress;

        if (!ReadMemory (
            ListAddress,
            &IterateEntry,
            sizeof (LIST_ENTRY),
            &Result
        )) {
            dprintf ("FATAL: Cannot read output pipe list!\n");
            return;
        }
        while ((DWORD)(IterateEntry.Flink) != ListAddress &&
            !CheckControlC ()) {

            #ifdef DEBUG_EXTENSION
                dprintf ("Current output queue %08lx, end = %08lx\n",
                    IterateEntry.Flink, ListAddress);
            #endif // DEBUG_EXTENSION

            Address = FIELDOFFSET (KSPPROCESSPIPESECTION, Queue) +
                (DWORD)IterateEntry.Flink;

            if (!ReadMemory (
                Address,
                &Queue,
                sizeof (PIKSQUEUE),
                &Result
            )) {
                dprintf ("FATAL: Cannot read queue!\n");
                return;
            }

            //
            // Upcast, print header, and dump the queue object.
            //
            QueueObject = (CKsQueue *)(Queue);

            dprintf ("%sFilter %08lx: Output Queue %08lx:\n",
                Tab (TabDepth),
                Public, QueueObject);

            DumpQueueContents (QueueObject, DumpLevel, TabDepth + 1);

            //
            // Get the next item in the list....
            //
            if (!ReadMemory (
                (DWORD)(IterateEntry.Flink),
                &IterateEntry,
                sizeof (LIST_ENTRY),
                &Result
            )) {
                dprintf ("FATAL: Cannot traverse output pipe chain\n");
                return;
            }
        }
    }
}

/*************************************************

    Function:

        forcedump

    Usage:

        !ks.forcedump <object> <type> [<level>]

    Description:

        This is used when the extension cannot recognize a given object
        type.  Because of certain flaws in the KD-style extension support
        within RTERM, this can be necessary.  Some versions of the debugger
        (the first 4.3) have a bug in that they cannot resolve symbols.  This
        renders !ks.dump unusable for class objects.  Further, no version
        of RTERM can resolve symbols that are loaded on the target side.  Since
        this isn't likely to be fixed soon and there's always the possibility
        of having to debug a machine fitting into the class above, this
        command is being added.

    Notes:

        Type must be the object type: ie: CKsQueue, CKsFilter, etc...
        It must be the **BASE** of the object, not a pointer to a base class
        which does not align with the pointer to the derived class.  You
        must trace back to the base yourself.

        You can very easily do something stupid with this command like
        !ks.forcedump <some CKsFilter> CKsPin 7.  This will force a dump of
        the memory as if the CKsFilter were a CKsPin; it may look very ugly!

*************************************************/

DECLARE_API(forcedump) {

    DWORD ForceAddr;
    ULONG Result, TabDepth;
    char objStr[256], typeStr[256], lvlStr[256], *pLvl;
    ULONG DumpLevel;
    INTERNAL_OBJECT_TYPE ObjType;
    ULONG i;

    GlobInit ();

    #ifdef DEBUG_EXTENSION
        dprintf ("Attempting to force dump structure args=[%s]!\n", args);
    #endif // DEBUG_EXTENSION

    if (!args || args [0] == 0) {
        dprintf ("Usage: !ks.forcedump <object> <type> [<level>]\n");
        return;
    }

    objStr [0] = lvlStr [0] = typeStr [0] = 0;

    //
    // Get all parameters converted as appropriate.
    //
    sscanf (args, "%s %s %s", objStr, typeStr, lvlStr);

    if (!(ForceAddr = Evaluator (objStr)))
        return;

    if (!typeStr [0]) {
        dprintf ("Usage: !ks.forcedump <object> <type> [<level>]\n");
        return;
    }

    if (lvlStr && lvlStr [0]) {
        pLvl = lvlStr; while (*pLvl && !isdigit (*pLvl)) pLvl++;

        #ifdef DEBUG_EXTENSION
            dprintf ("pLvl = [%s]\n", pLvl);
        #endif // DEBUG_EXTENSION

        if (*pLvl) {
            sscanf (pLvl, "%lx", &DumpLevel);
        } else {
            DumpLevel = 1;
        }
    } else {
        DumpLevel = 1;
    }

    #ifdef DEBUG_EXTENSION
        dprintf ("Dumping at level %ld\n", DumpLevel);
    #endif // DEBUG_EXTENSION

    //
    // The key is to determine what class the client gave us and use
    // the information.  Use the demangler array of type names and just
    // iterate through and straight strcmp for the type.
    //
    ObjType = ObjectTypeUnknown;
    for (i = 0; i < SIZEOF_ARRAY (TypeNamesToIdTypes); i++) 
        if (!strcmp (typeStr, TypeNamesToIdTypes [i].Name)) {
            ObjType = TypeNamesToIdTypes [i].ObjectType;
            break;
        }

    if (ObjType == ObjectTypeUnknown) {
        dprintf ("%s: unknown or currently unhandled type!\n", typeStr);
        return;
    }

    TabDepth = INITIAL_TAB;

    //
    // Warn the client that this is a forced dump and that no type checking
    // has been performed.
    //
    dprintf ("%sWARNING: I am dumping %08lx as a %s.\n"
        "%s         No checking has been performed to ensure that"
        " it is this type!!!\n\n",
        Tab (TabDepth), ForceAddr, typeStr, Tab(TabDepth));

    TabDepth++;

    //
    // Dump the private version of the object.  This is a forced dump.
    // Absolutely no checking is performed to ensure that ForceAddr is
    // really of type ObjType.
    //
    switch (ObjType) {

        case ObjectTypeCKsQueue:

            DumpQueueContents ((CKsQueue *)ForceAddr, DumpLevel, TabDepth);
            break;

        case ObjectTypeCKsDevice:

            DumpPrivateDevice (ForceAddr, DumpLevel, TabDepth);
            break;

        case ObjectTypeCKsFilterFactory:
            
            DumpPrivateFilterFactory (ForceAddr, DumpLevel, TabDepth);
            break;

        case ObjectTypeCKsFilter:

            DumpPrivateFilter (ForceAddr, DumpLevel, TabDepth);
            break;

        case ObjectTypeCKsPin:

            DumpPrivatePin (ForceAddr, DumpLevel, TabDepth);
            break;

        case ObjectTypeCKsPipeSection:

            DumpPrivatePipeSection (ForceAddr, DumpLevel, TabDepth);
            break;

        case ObjectTypeCKsRequestor:

            DumpPrivateRequestor (ForceAddr, DumpLevel, TabDepth);
            break;

        default:

            dprintf ("%s: I have not written support for this type yet!\n",
                typeStr);
            break;
    }

}

/*************************************************

    Function:

        enumerate

    Usage:

        !ks.enumerate <object>

    Description:

        Given any AVStream object, go to the parent device, find
        the FDO.  Walk up from the FDO to the driver.  Enumerate the
        driver as if you had done !ks.enumdrvobj

    Notes:

        - Some day I may add level to this as an indication of how
          far to trace down in the chain.

*************************************************/

DECLARE_API(enumerate) {

    DWORD Public, ExtAddr, ObjAddr;
    KSPX_EXT ObjExt;
    ULONG Result;
    char objStr[256], lvlStr[256], *pLvl;
    ULONG DumpLevel;

    GlobInit ();

    #ifdef DEBUG_EXTENSION
        dprintf ("Attempting to enumerate structure args=[%s]!\n", args);
    #endif // DEBUG_EXTENSION

    if (!args || args [0] == 0) {
        dprintf ("Usage: !ks.enumerate <object>\n");
        return;
    }

    objStr [0] = lvlStr [0] = 0;

    //
    // Get the object address and convert it to the private _EXT address.
    // Read in the KSPX_EXT structure to find out what the heck we're
    // referring to.
    //
    sscanf (args, "%s %s", objStr, lvlStr);

    if (!(Public = Evaluator (objStr)))
        return;

    if (lvlStr && lvlStr [0]) {
        pLvl = lvlStr; while (*pLvl && !isdigit (*pLvl)) pLvl++;

        #ifdef DEBUG_EXTENSION
            dprintf ("pLvl = [%s]\n", pLvl);
        #endif // DEBUG_EXTENSION

        if (*pLvl) {
            sscanf (pLvl, "%lx", &DumpLevel);
        } else {
            DumpLevel = 1;
        }
    } else {
        DumpLevel = 1;
    }

    #ifdef DEBUG_EXTENSION
        dprintf ("Enumerating at level %ld\n", DumpLevel);
    #endif // DEBUG_EXTENSION

    //
    // Check first to see if this is a C++ class object within AVStream.
    //
    {
        INTERNAL_OBJECT_TYPE ObjType;
        DWORD BaseAddr;

        ObjType = DemangleAndAttemptIdentification (
            Public,
            &BaseAddr,
            NULL
        );

        if (ObjType != ObjectTypeUnknown) {

            #ifdef DEBUG_EXTENSION
                dprintf ("%08lx: object is a [%s], base address = %08lx\n",
                    Public, ObjectNames [ObjType], BaseAddr);
            #endif // DEBUG_EXTENSION

            switch (ObjType) {

                case ObjectTypeCKsPin:

                    ExtAddr = BaseAddr + FIELDOFFSET (CKsPin, m_Ext);
                    break;

                case ObjectTypeCKsFilter:

                    ExtAddr = BaseAddr + FIELDOFFSET (CKsFilter, m_Ext);
                    break;

                case ObjectTypeCKsFilterFactory:

                    ExtAddr = BaseAddr + FIELDOFFSET (CKsFilterFactory, m_Ext);
                    break;

                case ObjectTypeCKsDevice:
                    
                    ExtAddr = BaseAddr + FIELDOFFSET (CKsDevice, m_Ext);
                    break;

                case ObjectTypeCKsQueue:
                {

                    PKSPIN MasterPin;

                    ObjAddr = BaseAddr + FIELDOFFSET (CKsQueue, m_MasterPin);
                    if (!ReadMemory (
                        ObjAddr,
                        &MasterPin,
                        sizeof (PKSPIN),
                        &Result)) {

                        dprintf ("%08lx: cannot read queue's master pin!\n",
                            ObjAddr);
                        return;
                    }
                    ExtAddr = (DWORD)CONTAINING_RECORD(
                        MasterPin, KSPIN_EXT, Public);
                    break;
                }

                case ObjectTypeCKsRequestor:
                {
                    PIKSPIN PinInterface;

                    ObjAddr = BaseAddr + FIELDOFFSET (CKsRequestor, m_Pin);
                    if (!ReadMemory (
                        ObjAddr,
                        &PinInterface,
                        sizeof (PIKSPIN),
                        &Result)) {

                        dprintf ("%08lx: cannot read requestor's pin!\n",
                            ObjAddr);
                        return;
                    }
                    ObjAddr = (DWORD)((CKsPin *)(PinInterface));
                    ExtAddr = ObjAddr + FIELDOFFSET (CKsPin, m_Ext);
                    break;
                }
                    
                case ObjectTypeCKsPipeSection:
                {
                    PIKSDEVICE DeviceInterface;

                    ObjAddr = BaseAddr + FIELDOFFSET (CKsPipeSection, 
                        m_Device);
                    if (!ReadMemory (
                        ObjAddr,
                        &DeviceInterface,
                        sizeof (PIKSDEVICE),
                        &Result)) {

                        dprintf ("%08lx: cannot read pipe's device!\n",
                            ObjAddr);
                        return;
                    }
                    ObjAddr = (DWORD)((CKsDevice *)(DeviceInterface));
                    ExtAddr = ObjAddr + FIELDOFFSET (CKsDevice, m_Ext);
                    break;

                }
                
                default:

                    dprintf ("Sorry....  I haven't finished this yet!\n");
                    break;

            }

        } else {

            ExtAddr = (DWORD)(CONTAINING_RECORD(Public, KSPX_EXT, Public));

        }

    }

    //
    // The above switch should give us an Ext somewhere in the hierarchy...
    // We really have no clue where.  Walk up the hierarchy until we hit
    // the device.
    //
    do {
    
        //
        // Read the Ext structure
        //
        if (!ReadMemory (
            ExtAddr,
            &ObjExt,
            sizeof (KSPX_EXT),
            &Result
        )) {
            dprintf ("%08lx: could not read object!\n", Public);
            return;
        }

        //
        // Ensure it's really Ok....
        //
        if (ObjExt.ObjectType != KsObjectTypeDevice &&
            ObjExt.ObjectType != KsObjectTypeFilterFactory &&
            ObjExt.ObjectType != KsObjectTypeFilter &&
            ObjExt.ObjectType != KsObjectTypePin) {

            dprintf ("%08lx: unknown object!\n", ExtAddr);
            return;
        }

    
        if (ObjExt.ObjectType != KsObjectTypeDevice)
            ExtAddr = (DWORD)ObjExt.Parent;

    } while (ObjExt.ObjectType != KsObjectTypeDevice && !CheckControlC ());

    //
    // Get the driver object and  enumerate it.
    //
    {
        KSDEVICE Device;
        PDRIVER_OBJECT DriverObjectAddr;
        DRIVER_OBJECT DriverObject;
        PDEVICE_OBJECT DeviceObject;
        PDEVICE_OBJECT NextDeviceObject;
        ULONG TabDepth = INITIAL_TAB;

        ObjAddr = ExtAddr + FIELDOFFSET (KSDEVICE_EXT, Public);

        if (!ReadMemory (
            ObjAddr,
            &Device,
            sizeof (KSDEVICE),
            &Result)) {

            dprintf ("%08lx: unable to read device!\n",
                ObjAddr);
            return;
        }

        ObjAddr = (DWORD)Device.FunctionalDeviceObject +
            FIELDOFFSET (DEVICE_OBJECT, DriverObject);
        
        if (!ReadMemory (
            ObjAddr,
            &DriverObjectAddr,
            sizeof (PDRIVER_OBJECT),
            &Result)) {

            dprintf ("%08lx: unable to read driver address!\n",
                ObjAddr);
            return;
        }

        if (!ReadMemory (
            (DWORD)DriverObjectAddr,
            &DriverObject,
            sizeof (DRIVER_OBJECT),
            &Result)) {

            dprintf ("%08lx: unable to read driver object!\n",
                DriverObjectAddr);
            return;
        }

        dprintf ("%sWDM driver object %08lx:\n", Tab (TabDepth), 
            DriverObjectAddr);
        TabDepth++;

        DeviceObject = DriverObject.DeviceObject;
        while (DeviceObject && !CheckControlC ()) {
            NextDeviceObject = EnumerateDeviceObject (
                (DWORD)DeviceObject,
                TabDepth
            );
            dprintf ("\n");
    
            DeviceObject = NextDeviceObject;
        }
    }
}

/**************************************************************************

    DEBUGGING API: 

        This is for debugging the extension and the kdext support in
        RTERM.

**************************************************************************/

/*************************************************

    Leave this in for debugging purposes.  IF 0 it, but
    DO **NOT** remove it.

*************************************************/

#if 0

DECLARE_API(resolve) {

    DWORD syma;
    CHAR buffer [1024];
    ULONG displ;

    GlobInit ();

    if (!args || args [0] == 0)
        return;

    sscanf(args, "%lx", &syma);

    dprintf ("Attempting to resolve %08lX\n", syma);

    GetSymbol ((LPVOID)syma, buffer, &displ);

    dprintf ("Called GetSymbol with the following parameters:\n"
        "1 [syma]: %08lx\n"
        "2 [buffer&]: %08lx\n"
        "3 [displ&]: %08lx\n",
        (LPVOID)syma,
        buffer,
        &displ
    );

    dprintf ("String buffer contents:\n");

    HexDump ((PVOID)buffer, (ULONG)buffer, 1024);

    dprintf ("buffer [%s], displ=%ld\n", buffer, displ);

}

#endif // 0

/*************************************************

    END DEBUG ONLY CODE

*************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\ksfilter\ks\kdexts\ksapi.c ===
/**************************************************************************

    Ks / AVStream debugging extensions	

    Copyright (C) Microsoft Corporation, 1997 - 2000


**************************************************************************/

#include "kskdx.h"

/**************************************************************************

    KS API

**************************************************************************/

#define MAX_CREATE_ITEMS    16

typedef struct {
    ULONG  Option;
    PSTR   Name;
} HEADER_OPTIONS_STRING;

HEADER_OPTIONS_STRING HeaderOptionStrings[] = {
    { 
        KSSTREAM_HEADER_OPTIONSF_SPLICEPOINT,
        "KSSTREAM_HEADER_OPTIONSF_SPLICEPOINT"
    },
    {
        KSSTREAM_HEADER_OPTIONSF_PREROLL,
        "KSSTREAM_HEADER_OPTIONSF_PREROLL"
    },
    {
        KSSTREAM_HEADER_OPTIONSF_DATADISCONTINUITY,
        "KSSTREAM_HEADER_OPTIONSF_DATADISCONTINUITY"
    },
    {
        KSSTREAM_HEADER_OPTIONSF_TYPECHANGED,
        "KSSTREAM_HEADER_OPTIONSF_TYPECHANGED"
    },
    {
        KSSTREAM_HEADER_OPTIONSF_TIMEVALID,
        "KSSTREAM_HEADER_OPTIONSF_TIMEVALID"
    },
    {
        KSSTREAM_HEADER_OPTIONSF_TIMEDISCONTINUITY,
        "KSSTREAM_HEADER_OPTIONSF_TIMEDISCONTINUITY"
    },
    {
        KSSTREAM_HEADER_OPTIONSF_FLUSHONPAUSE,
        "KSSTREAM_HEADER_OPTIONSF_FLUSHONPAUSE"
    },
    {
        KSSTREAM_HEADER_OPTIONSF_DURATIONVALID,
        "KSSTREAM_HEADER_OPTIONSF_DURATIONVALID"
    },
    {
        KSSTREAM_HEADER_OPTIONSF_ENDOFSTREAM,
        "KSSTREAM_HEADER_OPTIONSF_ENDOFSTREAM"
    },
    {
        KSSTREAM_HEADER_OPTIONSF_LOOPEDDATA,
        "KSSTREAM_HEADER_OPTIONSF_LOOPEDDATA" 
    }
};

static
VOID
DisplayKsTime(
    PSTR MemberName,
    PKSTIME Time
    )
{
    dprintf( 
        "%s.Time = %lu\n", MemberName, Time->Time );
    dprintf( 
        "%s.Numerator = %lu\n", MemberName, Time->Numerator );
    dprintf( 
        "%s.Denominator = %lu\n", MemberName, Time->Denominator );
}

static
void 
DisplayFunction(PVOID Address)
{
    UCHAR                CreateFunction[1024];
    ULONG                offset;
    
    if (Address == NULL) {
       dprintf("NULL\n");
    } else {
       GetSymbol(Address, CreateFunction, &offset);
       dprintf("%s+0x%02lx \n", CreateFunction, offset);
    }
}

static
void 
DisplayDispatchTable(ULONG Address)
{
    KSDISPATCH_TABLE  KsDispatchTable;
    DWORD             BytesRead;

    if (!ReadMemory( 
            (ULONG) Address, 
            &KsDispatchTable, 
            sizeof( KSDISPATCH_TABLE ), 
            &BytesRead)) {
        dprintf("????\n");
        return;
    }
 
    if (BytesRead < sizeof( KSDISPATCH_TABLE ) ) {
        dprintf( 
            "Only read %d bytes of DispatchTable, expected %d bytes\n", 
             BytesRead, 
             sizeof( KSDISPATCH_TABLE ) );
        return;
    }

    dprintf("    { DeviceIoControl = ");
    DisplayFunction(KsDispatchTable.DeviceIoControl);    

    dprintf("      Read = ");
    DisplayFunction(KsDispatchTable.Read);               

    dprintf("      Write = ");
    DisplayFunction(KsDispatchTable.Write);              

    dprintf("      Flush = ");
    DisplayFunction(KsDispatchTable.Flush);              

    dprintf("      Close = ");
    DisplayFunction(KsDispatchTable.Close);              

    dprintf("      QuerySecurity = ");
    DisplayFunction(KsDispatchTable.QuerySecurity);      

    dprintf("      SetSecurity = ");
    DisplayFunction(KsDispatchTable.SetSecurity);        

    dprintf("      FastDeviceIoControl = ");
    DisplayFunction(KsDispatchTable.FastDeviceIoControl);

    dprintf("      FastRead = ");
    DisplayFunction(KsDispatchTable.FastRead);           

    dprintf("      FastWrite = ");
    DisplayFunction(KsDispatchTable.FastWrite);          

    dprintf("     }\n");
}

static
void 
DisplayCreateItems(
                   ULONG Address, 
                   ULONG ItemsCount
                   )
{

                                                                                                                                                                                                                   
    KSOBJECT_CREATE_ITEM CreateItems[MAX_CREATE_ITEMS],
                         *pCreateItem;
    DWORD                BytesRead;
    WCHAR                Buffer[128];
    DWORD                BufferLength = sizeof( Buffer );
    ULONG                itemIdx;

    if ( ItemsCount == 0 ) {
        return;
    }
    
    if(ItemsCount > MAX_CREATE_ITEMS)
        ItemsCount = MAX_CREATE_ITEMS;
    
    if (!ReadMemory( 
            (ULONG) Address, 
            CreateItems, 
            sizeof( KSOBJECT_CREATE_ITEM ) * ItemsCount, 
            &BytesRead)) {
        dprintf("{ ???? }\n");
        return;
    }
 
    if (BytesRead < ItemsCount * sizeof( KSOBJECT_CREATE_ITEM ) ) {
        dprintf( 
            "Only read %d bytes of CreateItemList, expected %d bytes\n", 
             BytesRead, 
             ItemsCount * sizeof( KSOBJECT_CREATE_ITEM ) );
        ItemsCount = BytesRead / sizeof(KSOBJECT_CREATE_ITEM);
    }
    
    for( itemIdx = 0; itemIdx < ItemsCount; itemIdx++)
    {
        
        pCreateItem = &CreateItems[itemIdx];
        
        dprintf("    {\n        CreateFunction = ");
        DisplayFunction(pCreateItem->Create);

        dprintf("        ObjectClass = ");
        if (pCreateItem->ObjectClass.Length == 0) {
           dprintf("NULL\n");
        } else {
           if (BufferLength > pCreateItem->ObjectClass.MaximumLength ) {
              BufferLength = pCreateItem->ObjectClass.MaximumLength;
           }
           if (!ReadMemory( 
                   (ULONG) pCreateItem->ObjectClass.Buffer, 
                   Buffer, 
                   BufferLength, 
                   &BytesRead)) {
               dprintf("????\n");
           }
           if ( BufferLength <= pCreateItem->ObjectClass.Length ) {
               Buffer[sizeof(Buffer) / sizeof(WCHAR) - 1] = UNICODE_NULL;
           } else {
               Buffer[pCreateItem->ObjectClass.Length / sizeof(WCHAR)] = UNICODE_NULL;
           }
           
           dprintf("%S\n", Buffer);
        }
        
        dprintf("        Flags = %lx\n"
                "    }\n", 
                pCreateItem->Flags);
    }

}

static
void 
DisplayCreateList(
    PLIST_ENTRY ChildCreateHandlerList,
    DWORD OriginalAddress
    )
{
    KSICREATE_ENTRY CreateEntry;
    DWORD Address;
    ULONG Result;

    CreateEntry.ListEntry = *ChildCreateHandlerList;
    while ((DWORD)CreateEntry.ListEntry.Flink != OriginalAddress &&
        !CheckControlC() ) {

        Address = (DWORD) 
            CONTAINING_RECORD(CreateEntry.ListEntry.Flink, 
                KSICREATE_ENTRY, ListEntry);

        if (!ReadMemory (
            Address,
            &CreateEntry,
            sizeof (KSICREATE_ENTRY),
            &Result)) {

            dprintf ("%08lx: unable to read create entry!\n",
                Address);
            return;
        }

        DisplayCreateItems((ULONG)CreateEntry.CreateItem, 1);
    }

}

DECLARE_API(shdr)
{
    int                 i;
    DWORD               Address, BytesRead;
    KSSTREAM_HEADER     StreamHeader;
    
    if (0 == args[0])
    {
        dprintf("shdr <PKSSTREAM_HEADER>\n");
        return;
    }

    sscanf( args, "%lx", &Address );

    if (!ReadMemory( 
            Address, 
            &StreamHeader, 
            sizeof( KSSTREAM_HEADER ), 
            &BytesRead)) {
        return;     
    }
 
    if (BytesRead < sizeof( KSSTREAM_HEADER )) {
        dprintf( 
            "Only read %d bytes, expected %d bytes\n", 
             BytesRead, 
             sizeof( KSSTREAM_HEADER ) );
        return;     
    }
    
    dprintf(
        "Stream Header: 0x%08x\n\n", Address );
        
    DisplayKsTime( "PresentationTime", &StreamHeader.PresentationTime );
    dprintf( 
        "Duration = %lu\n", StreamHeader.Duration );
    dprintf( 
        "FrameExtent = %u\n", StreamHeader.FrameExtent );
    dprintf( 
        "DataUsed = %u\n", StreamHeader.DataUsed );
    dprintf( 
        "Data = 0x%08x\n", StreamHeader.Data );

    for (i = 0; i < SIZEOF_ARRAY( HeaderOptionStrings ); i++) {
        if (HeaderOptionStrings[ i ].Option & StreamHeader.OptionsFlags) {
            dprintf( "%s\n", HeaderOptionStrings[ i ].Name );
        }
    }
    
    return;
}

DECLARE_API(dhdr)
{
    DWORD                Address, BytesRead;    
    KSIDEVICE_HEADER     KsDeviceHeader;
    
    if (0 == args[0])
    {
        dprintf("dhdr <KSDEVICE_HEADER>\n");
        return;
    }

    sscanf( args, "%lx", &Address );

    if (!ReadMemory( 
            Address, 
            &KsDeviceHeader, 
            sizeof( KSIDEVICE_HEADER ), 
            &BytesRead)) {
        dprintf("Can not read KsDeviceHeader\n");
        return;     
    }
 
    if (BytesRead < sizeof( KSIDEVICE_HEADER )) {
        dprintf( 
            "Only read %d bytes of KsDeviceHeader, expected %d bytes\n", 
             BytesRead, 
             sizeof( KSIDEVICE_HEADER ) );
        return;     
    }
    
    
    dprintf(" KsDeviceHeader 0x%x {\n", Address);
    dprintf("     ChildCreateHandlerList\n");
    DisplayCreateList(&KsDeviceHeader.ChildCreateHandlerList,
        (DWORD)Address + FIELDOFFSET(KSIDEVICE_HEADER, ChildCreateHandlerList));
    dprintf(" }\n");
    return;
}

DECLARE_API(ohdr)
{
    DWORD                Address, BytesRead;    
    KSIOBJECT_HEADER     KsObjectHeader;
    
    if (0 == args[0])
    {
        dprintf("objhdr <PFILE_OBJECT>\n");
        return;
    }

    sscanf( args, "%lx", &Address );
    
    if (!ReadMemory( 
            Address, 
            &KsObjectHeader, 
            sizeof( KSIOBJECT_HEADER ), 
            &BytesRead)) {
        dprintf("Can not read KsObjectHeader\n");
        return;     
    }
 
    if (BytesRead < sizeof( KSIOBJECT_HEADER )) {
        dprintf( 
            "Only read %d bytes of KsObjectHeader, expected %d bytes\n", 
             BytesRead, 
             sizeof( KSIOBJECT_HEADER ) );
        return;     
    }
    
    
    dprintf(" KsObjectHeader 0x%x {\n", Address);
    
    dprintf("   Object's CreateItem:\n");
    DisplayCreateItems( (ULONG) KsObjectHeader.CreateItem,
                        1L);

    dprintf("   ChildCreateHandlerList:");
    DisplayCreateList( &KsObjectHeader.ChildCreateHandlerList,
        (DWORD)Address + 
        FIELDOFFSET (KSIOBJECT_HEADER, ChildCreateHandlerList));
    
    dprintf("   DispatchTable:\n");
    DisplayDispatchTable( (ULONG) KsObjectHeader.DispatchTable);

    if (KsObjectHeader.TargetState == KSTARGET_STATE_ENABLED) {
        dprintf("   TargetState: KSTARGET_STATE_ENABLED");
    } else {
        dprintf("   TargetState: KSTARGET_STATE_DISABLED");
    }

    dprintf("   TargetDevice: 0x%08lx", (ULONG) KsObjectHeader.TargetDevice);
    dprintf("   BaseDevice  : 0x%08lx", (ULONG) KsObjectHeader.BaseDevice);
    
    dprintf(" }\n");
    return;
}

DECLARE_API(devhdr)
{
    ULONG                i;
    DWORD                Address, BytesRead;    
    DEVICE_OBJECT        DeviceObject;
    PVOID                pHeader;
    KSIDEVICE_HEADER     KsDeviceHeader;
    KSOBJECT_CREATE_ITEM CreateItems[MAX_CREATE_ITEMS];
    ULONG                CreateItemsCnt;
    
    if (0 == args[0])
    {
        dprintf("devhdr <PDEVICE_OBJECT>\n");
        return;
    }

    sscanf( args, "%lx", &Address );

    if (!ReadMemory( 
            Address, 
            &DeviceObject, 
            sizeof( DEVICE_OBJECT ), 
            &BytesRead)) {
        dprintf("Can not read Device Object\n");
        return;     
    }
 
    if (BytesRead < sizeof( DEVICE_OBJECT )) {
        dprintf( 
            "Only read %d bytes of DeviceObject, expected %d bytes\n", 
             BytesRead, 
             sizeof( DEVICE_OBJECT ) );
        return;     
    }
    
    dprintf(" DeviceExtension 0x%x\n", (ULONG) DeviceObject.DeviceExtension);
    
    if (!ReadMemory( 
            (ULONG) DeviceObject.DeviceExtension, 
            &pHeader, 
            sizeof( PVOID ), 
            &BytesRead)) {
        dprintf("Can not read KsDeviceHeader address from Extension\n");
        return;     
    }
 
    if (BytesRead < sizeof( PVOID )) {
        dprintf( 
            "Only read %d bytes of DeviceExtension, expected %d bytes\n", 
             BytesRead, 
             sizeof( PVOID ) );
        return;     
    }
    
    if (!ReadMemory( 
            (ULONG) pHeader, 
            &KsDeviceHeader, 
            sizeof( KSIDEVICE_HEADER ), 
            &BytesRead)) {
        dprintf("Can not read KsDeviceHeader\n");
        return;     
    }
 
    if (BytesRead < sizeof( KSIDEVICE_HEADER )) {
        dprintf( 
            "Only read %d bytes of KsDeviceHeader, expected %d bytes\n", 
             BytesRead, 
             sizeof( KSIDEVICE_HEADER ) );
        return;     
    }
    
    
    dprintf(" KsDeviceHeader 0x%x {\n", (ULONG)pHeader);
    dprintf("     ChildCreateHandlerList");
    DisplayCreateList( &KsDeviceHeader.ChildCreateHandlerList,
        (DWORD)pHeader + FIELDOFFSET (KSIDEVICE_HEADER, 
        ChildCreateHandlerList));
    dprintf(" }\n");
    return;
}

DECLARE_API(objhdr)
{
    ULONG                i;
    DWORD                Address, BytesRead;    
    FILE_OBJECT          FileObject;
    PVOID                pHeader;
    KSIOBJECT_HEADER     KsObjectHeader;
    KSDISPATCH_TABLE     KsDiaptachTable;
    
    if (0 == args[0])
    {
        dprintf("objhdr <PFILE_OBJECT>\n");
        return;
    }

    sscanf( args, "%lx", &Address );

    if (!ReadMemory( 
            Address, 
            &FileObject, 
            sizeof( FILE_OBJECT ), 
            &BytesRead)) {
        dprintf("Can not read File Object\n");
        return;     
    }
 
    if (BytesRead < sizeof( FILE_OBJECT )) {
        dprintf( 
            "Only read %d bytes of File Object, expected %d bytes\n", 
             BytesRead, 
             sizeof( FILE_OBJECT ) );
        return;     
    }
    
    dprintf(" FsContext 0x%x\n", (ULONG) FileObject.FsContext);
    
    if (!ReadMemory( 
            (ULONG) FileObject.FsContext, 
            &pHeader, 
            sizeof( PVOID ), 
            &BytesRead)) {
        dprintf("Can not read KsObjectHeader address from FsContext\n");
        return;     
    }
 
    if (BytesRead < sizeof( PVOID )) {
        dprintf( 
            "Only read %d bytes of FsContext, expected %d bytes\n", 
             BytesRead, 
             sizeof( PVOID ) );
        return;     
    }
    
    if (!ReadMemory( 
            (ULONG) pHeader, 
            &KsObjectHeader, 
            sizeof( KSIOBJECT_HEADER ), 
            &BytesRead)) {
        dprintf("Can not read KsObjectHeader\n");
        return;     
    }
 
    if (BytesRead < sizeof( KSIOBJECT_HEADER )) {
        dprintf( 
            "Only read %d bytes of KsObjectHeader, expected %d bytes\n", 
             BytesRead, 
             sizeof( KSIOBJECT_HEADER ) );
        return;     
    }
    
    
    dprintf(" KsObjectHeader 0x%x {\n", (ULONG)pHeader);
    
    dprintf("   Object's CreateItem:\n");
    DisplayCreateItems( (ULONG) KsObjectHeader.CreateItem,
                        1L);

    dprintf("   ChildCreateHandlerList");
    DisplayCreateList( &KsObjectHeader.ChildCreateHandlerList,
        (DWORD)pHeader + FIELDOFFSET(KSIOBJECT_HEADER, ChildCreateHandlerList));
    
    dprintf("   DispatchTable:\n");
    DisplayDispatchTable( (ULONG) KsObjectHeader.DispatchTable);

    if (KsObjectHeader.TargetState == KSTARGET_STATE_ENABLED) {
        dprintf("   TargetState: KSTARGET_STATE_ENABLED");
    } else {
        dprintf("   TargetState: KSTARGET_STATE_DISABLED");
    }

    dprintf("   TargetDevice: 0x%08lx", (ULONG) KsObjectHeader.TargetDevice);
    dprintf("   BaseDevice  : 0x%08lx", (ULONG) KsObjectHeader.BaseDevice);
    
    dprintf(" }\n");
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\ksfilter\ks\kdexts\kskdx.c ===
/*++

Copyright (C) Microsoft Corporation, 1993 - 1997

Module Name:

    kskdx.c	


Abstract:

    This file contains the generic routines and initialization code
    for the kernel debugger extension dll for ks / AVStream

Author:


Environment:

    User Mode

--*/

#ifndef __KDEXT_ONLY__
#define __KDEXT_ONLY__
#endif // __KDEXT_ONLY__

#include "kskdx.h"

/**************************************************************************

    GLOBALS

**************************************************************************/

EXT_API_VERSION         ApiVersion = { 3, 5, EXT_API_VERSION_NUMBER, 0 };
WINDBG_EXTENSION_APIS   ExtensionApis;
USHORT                  SavedMajorVersion;
USHORT                  SavedMinorVersion;

PSTR    ApiDescriptions[] =
{
    "\nKS / AVStream Debugging Extension [AVStream extensions]\n\n",

    "help:\n",
    "     Displays this help screen\n\n",

    "kshelp:\n",
    "     Displays the commands available from the original Ks debug extension.\n\n",

    "automation <object>:\n",
    "     Dump any automation items associated with the given object.  The object\n",
    "     can be any one of the following: PKSPIN, PISFILTER, CKsPin*, CKsFilter*.\n",
    "     Automation item consist of properties, methods, and events.\n",
    "     Note that you can also use this on an Irp to find out property\n",
    "     information and handlers for automation Irps.\n\n",

    "dump <object> [<level>]:\n",
    "     Dump the given AVStream object.  This can be any valid client viewable\n",
    "     structure or any valid AVStream class object.  This can also be an Irp\n",
    "     or file object (in which case the associated AVStream object is dumped).\n\n",

    "dumpbag <object> [<level>]:\n",
    "     Dump the contents of the specified object's bag.  Object can be any valid\n",
    "     client viewable object structure or the private class object.\n\n",

    "dumpcircuit <object> [<level>]:\n",
    "     Dump the transport circuit associated with the given object.  Object can\n",
    "     be any one of the following: CKsPin*, CKsQueue*, CKsRequestor*,\n",
    "     CKsSplitter*, CKsSplitterBranch*.  Note that this starts walking the\n",
    "     circuit at the specified object; this is not necessarily the data source.\n\n",

    "dumplog [<# of entries>]:\n",
    "     Dump Ks's internal debug log.  Display up to # of entries.  If this\n",
    "     number is 0 or unspecified, the entire log is dumped.  This requires\n",
    "     debug ks.sys!\n\n"

    "dumpqueue <object> [<level>]:\n",
    "     Dump AVStream queue(s) associated with a given object.  Object can\n",

    "     be any of the following: PKSPIN, PKSFILTER, CKsPin*, CKsFilter*, CKsQueue*\n\n",

    "enumdevobj <WDM device object>:\n",
    "     Locate the AVStream device object associated with this WDM device object\n",
    "     and enumerate filter types and currently instantiated filters associated\n",
    "     with it  You must pass a device object which is for an AVStrema device!.\n\n",

    "enumdrvobj <WDM driver object>:\n",
    "     Locate the AVStream device object associated with this WDM driver object\n",
    "     and enumerate filter types and currently instantiated filters associated\n",
    "     with it.  You must pass a driver object which is an AVStream driver!\n\n"

    "forcedump <object> <type> [<level]:\n",
    "     Force a dump of the given AVStream object as a class object of the type\n",
    "     specified by type (CKsPin, CKsFilter, etc...)  No checking is performed\n",
    "     This is literally a totally dumb forced dump.\n\n",

    "findlive <type> [<# of entries>] [<level>]:\n",
    "     Search # of entries through the log attempting to find any live objects\n",
    "     of the specified type.  Type can be one of Queue, Requestor, Pin,\n",
    "     Filter, or Irp.  If # of entries is 0 or unspecified, the entire log is\n",
    "     searched.  Note that this does not guarantee to find all possible\n",
    "     specified live objects!\n\n"


};

PSTR KsHelpDescriptions[] = 
{
    "\nKS / AVStream Debugging Extension [KS 1.0 extensions]\n\n",
    "kshelp:\n",
    "     Displays this help screen\n\n",
    "help:\n",
    "     Displays the extension commands available for AVStream.\n\n",
    "shdr <PKSSTREAM_HEADER>:\n",
    "     Dump the contents of a stream header.  The object passed must currently\n",
    "     be a PKSSTREAM_HEADER.\n\n",
    "dhdr <KSDEVICE_HEADER>:\n",
    "     Dump the contents of a device header.  The object passed must currently\n",
    "     be a KSDEVICE_HEADER.\n\n",
    "ohdr <KSOBJECT_HEADER>:\n",
    "     Dump the contents of an object header.  The object passed must currently\n",
    "     be a KSOBJECT_HEADER.\n\n",
    "devhdr <PDEVICE_OBJECT>:\n",
    "     Dump the contents of the device header associated with the specified WDM\n",
    "     device object.\n\n",
    "objhdr <PFILE_OBJECT>:\n",
    "     Dump the contents of the object header associated with the specified file\n",
    "     object.\n\n"
};

#define MAX_APIS (SIZEOF_ARRAY( ApiDescriptions ) - 1)
#define KSMAX_APIS (SIZEOF_ARRAY( KsHelpDescriptions) - 1)

/**************************************************************************

    Extension Common Routines

**************************************************************************/

//
// THESE ARE NEEDED FOR THE KDEXT DLLs
//
BOOLEAN
DllInit(
    HANDLE hModule,
    DWORD  dwReason,
    DWORD  dwReserved
    )
{
    switch (dwReason) {
        case DLL_THREAD_ATTACH:
            DbgBreakPoint();
            break;

        case DLL_THREAD_DETACH:
            break;

        case DLL_PROCESS_DETACH:
            break;

        case DLL_PROCESS_ATTACH:
            break;
    }

    return TRUE;
}


//
// THESE ARE NEEDED FOR THE KDEXT DLLs
//
VOID
WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    USHORT MajorVersion,
    USHORT MinorVersion
    )
{
    ExtensionApis = *lpExtensionApis;

    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;

    return;
}

//
// THESE ARE NEEDED FOR THE KDEXT DLLs
//
DECLARE_API( version )
{
#if DBG
    PCHAR DebuggerType = "Checked";
#else
    PCHAR DebuggerType = "Free";
#endif

    dprintf( "%s Extension dll for Build %d debugging %s kernel for Build %d\n",
             DebuggerType,
             VER_PRODUCTBUILD,
             SavedMajorVersion == 0x0c ? "Checked" : "Free",
             SavedMinorVersion
           );
}

//
// THESE ARE NEEDED FOR THE KDEXT DLLs
//
VOID
CheckVersion(
    VOID
    )
{
#if DBG
    if ((SavedMajorVersion != 0x0c) || (SavedMinorVersion != VER_PRODUCTBUILD)) {
        dprintf("\r\n*** Extension DLL(%d Checked) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#else
    if ((SavedMajorVersion != 0x0f) || (SavedMinorVersion != VER_PRODUCTBUILD)) {
        dprintf("\r\n*** Extension DLL(%d Free) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#endif
}

LPEXT_API_VERSION
ExtensionApiVersion(
    VOID
    )
{
    return &ApiVersion;
}

/*************************************************

    Function:

        ustrcmp

    Description:

        Case insensitive strcmp

*************************************************/

int
ustrcmp (
    char *a,
    char *b
    )

{

    int dif;

    while (!(dif = (toupper (*a) - toupper (*b++))) && *a++);
    return dif;

}

/*************************************************

    Function:

        Evaluator

    Description:

        Given a string, return the address evaluation

    Arguments:

        StringEval -
            The string to evaluate

*************************************************/

DWORD 
Evaluator (
    IN const char *StringEval
    )

{

    DWORD Addr = 0;

    Addr = GetExpression (StringEval);

    return Addr;

}

char g_TabString [513];
ULONG g_TabSize;

/*************************************************

    Function:

        GlobInit

    Description:

        Initialize global utilities

*************************************************/

void
GlobInit (
) {

    static BOOLEAN Init = FALSE;

    ULONG i;

    //
    // KD loads the extension DLL and keeps it loaded.  Each command
    // comes is just a GetProcAddress and call into the DLL.  We only need
    // to initialize once.
    //
    // RTERM on the other hand loads the extension DLL for each extension
    // DLL command used.  Therefore, each extension command needs to
    // initialize.
    //
    // This is the reason for the static Init.
    //
    if (!Init) {
        for (i = 0; i < 512; i++)
            g_TabString [i] = ' ';
        g_TabString [512] = 0;
    
        g_TabSize = TAB_SPACING;

        Init = TRUE;
    } 

}

/*************************************************

    Function:

        Tab

    Description:

        Return a pointer to a string tabbing the requesting
        number of tab markers.

    Arguments:

        Depth -
            The tab depth.

    Return Value:

        Pointer to a string of Depth * g_TabSize spaces

    Notes:
        
        This is a single threaded function only!

        This can only be used once in a given dprintf.  ie: You CANNOT do:
            dprintf ("%sfoo:\n%s", Tab (TabDepth), Tab (TabDepth + 1));

*************************************************/

char *
Tab (
    IN ULONG Depth
) {

    static ULONG OldPos = 0;

    if (Depth * g_TabSize > 512) 
        Depth = 512 / g_TabSize;

    g_TabString [OldPos] = ' ';
    g_TabString [Depth * g_TabSize] = 0;

    OldPos = Depth * g_TabSize;

    return g_TabString;

}


/**************************************************************************

    Help API

**************************************************************************/

DECLARE_API(help)
{
   UINT  c;

    if (0 == args[0]) {
        for (c = 0; c < MAX_APIS + 1; c++)
            dprintf( ApiDescriptions[ c ] );
        return;
    }
}

DECLARE_API(kshelp)
{
   UINT  c;

    if (0 == args[0]) {
        for (c = 0; c < KSMAX_APIS + 1; c++)
            dprintf( KsHelpDescriptions [ c ] );
        return;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\ksfilter\ks\millen\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1997 - 1998

Module Name:

    makefile.inc.

!ENDIF

!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\ksfilter\ks\memphis\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1997 - 1998

Module Name:

    makefile.inc.

!ENDIF

!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\ksfilter\ks\win98se\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1997 - 1998

Module Name:

    makefile.inc.

!ENDIF

!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\ksfilter\ks\test\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1998 - 1998

Module Name:

    makefile.inc.

!ENDIF

!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\ksfilter\ks\test\ksmemtst.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       ksmemtst.h
//
//--------------------------------------------------------------------------

PVOID 
KsiAllocatePool(
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes);
        
PVOID 
KsiAllocatePoolWithTag(
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes,
    IN ULONG Tag);
        
PVOID 
KsiAllocatePoolWithQuota(
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes);
        
PVOID 
KsiAllocatePoolWithQuotaTag(
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes,
    IN ULONG Tag);

#define KS_ALLOCATION_PASS_THROUGH          0
#define KS_ALLOCATION_FAIL_ALWAYS           1
#define KS_ALLOCATION_FAIL_PERIODICALLY     2
#define KS_ALLOCATION_FAIL_ON_TAG           3

KSDDKAPI
VOID
NTAPI
KsSetAllocationParameters(
    IN ULONG FailureType,
    IN ULONG TagValue,
    IN ULONG FailureCountRate);


#undef  ExAllocatePool
#define ExAllocatePool(a,b)                 KsiAllocatePool(a,b)

#undef  ExAllocatePoolWithTag
#define ExAllocatePoolWithTag(a,b,c)        KsiAllocatePoolWithTag(a,b,c)

#undef  ExAllocatePoolWithQuota
#define ExAllocatePoolWithQuota(a,b)        KsiAllocatePoolWithQuota(a,b)

#undef  ExAllocatePoolWithQuotaTag
#define ExAllocatePoolWithQuotaTag(a,b,c)   KsiAllocatePoolWithQuotaTag(a,b,c)
//#define ExAllocateFromNPagedLookasideList
//#define ExAllocateFromPagedLookasideList
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\ksfilter\ks\kdexts\kskdx.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  File:       kskdx.h
//
//--------------------------------------------------------------------------

#ifndef __KDEXT_ONLY__
#define __KDEXT_ONLY__
#endif // __KDEXT_ONLY__

#ifndef __KSKDX_H
#define __KSKDX_H

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

#include <nt.h>
#include <ntos.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <imagehlp.h>
#include <wdbgexts.h>
#include <stdio.h>
#include <stdlib.h>
#include <ntverp.h>

//
// Get rid of any cute definitions of ExAllocatePool and ExFreePool.  The
// linkages should never get called.  They're only here to appease the
// inclusion of .cpp files without a million more #ifndef KDEXT_ONLY 
// exclusions.
//
#ifdef ExAllocatePool
#undef ExAllocatePool
#endif // ExAllocatePool

#ifdef ExFreePool
#undef ExFreePool
#endif // ExFreePool

#include <ksp.h>
#ifdef __cplusplus
}
#endif // __cplusplus
#ifdef __cplusplus
#include <kcom.h>
extern "C" {
#endif // __cplusplus
#include <ks.h>
#include <ksmedia.h>
#ifdef __cplusplus
}
#endif // __cplusplus

#define HOSTPOINTER 
#define TARGETPOINTER

//
// Internal definitions
//

typedef DWORD (*OBJECT_ADJUSTMENT_FUNCTION)(PVOID, DWORD);

#define NOT_IMPLEMENTED     0xFACEFEED

#define DUMPOBJQUEUELIST_BAILOUT_COUNT 120

typedef enum _INTERNAL_OBJECT_TYPE {

    ObjectTypeUnknown = 0,

    //
    // Client viewable structures.
    //
    ObjectTypeKSPin,
    ObjectTypeKSFilter,
    ObjectTypeKSDevice,
    ObjectTypeKSFilterFactory,

    //
    // Non-client viewable structures.
    //
    ObjectTypeCKsQueue,
    ObjectTypeCKsDevice,
    ObjectTypeCKsFilterFactory,
    ObjectTypeCKsFilter,
    ObjectTypeCKsPin,
    ObjectTypeCKsRequestor,
    ObjectTypeCKsSplitter,
    ObjectTypeCKsSplitterBranch,

    ObjectTypeCKsPipeSection,

    ObjectType_MAX

} INTERNAL_OBJECT_TYPE, *PINTERNAL_OBJECT_TYPE;

typedef enum _INTERNAL_STRUCTURE_TYPE {
    
    StructureTypeUnknown = 0,
    StructureType_KSSTREAM_POINTER 

} INTERNAL_STRUCTURE_TYPE, *PINTERNAL_STRUCTURE_TYPE;

typedef enum _INTERNAL_INTERFACE_TYPE {

    InterfaceTypeUnknown = 0,

    //
    // These are mostly internal to AVStream.  Only the base unknowns are
    // not.
    //

    InterfaceTypeIKsTransport,              // 1
    InterfaceTypeIKsRetireFrame,            // 2
    InterfaceTypeIKsPowerNotify,            // 3
    InterfaceTypeIKsProcessingObject,       // 4
    InterfaceTypeIKsConnection,             // 5
    InterfaceTypeIKsDevice,                 // 6
    InterfaceTypeIKsFilterFactory,          // 7
    InterfaceTypeIKsFilter,                 // 8
    InterfaceTypeIKsPin,                    // 9
    InterfaceTypeIKsPipeSection,            // 10
    InterfaceTypeIKsRequestor,              // 11
    InterfaceTypeIKsQueue,                  // 12
    InterfaceTypeIKsSplitter,               // 13

    InterfaceTypeIKsControl,                // 14
    InterfaceTypeIKsWorkSink,               // 15
    InterfaceTypeIKsReferenceClock,         // 16

    InterfaceTypeINonDelegatedUnknown,      // 17
    InterfaceTypeIIndirectedUnknown,        // 18

    InterfaceType_MAX

} INTERNAL_INTERFACE_TYPE, *PINTERNAL_INTERFACE_TYPE;

typedef enum _SIGNATURE_TYPE {

    SignatureUnknown = 0,
    SignatureIrp,
    SignatureFile

} SIGNATURE_TYPE, *PSIGNATURE_TYPE;

typedef enum _AUTOMATION_ITEM {

    AutomationUnknown = 0,
    AutomationProperty,
    AutomationMethod,
    AutomationEvent

} AUTOMATION_TYPE, *PAUTOMATION_TYPE;

typedef void (*AUTOMATION_DUMP_HANDLER)(IN PKSIDENTIFIER Property,
                                      IN ULONG TabDepth);

typedef BOOLEAN (*PFNLOG_ITERATOR_CALLBACK)(IN PVOID Context, 
    IN PKSLOG_ENTRY Entry);

typedef BOOLEAN (*PFNCIRCUIT_WALK_CALLBACK)(IN PVOID Context,
    IN INTERNAL_OBJECT_TYPE Type, IN DWORD Base, IN PVOID Object);

//
// function prototypes
//

VOID
DisplayStreamingHeader(
    ULONG Address,
    PKSSTREAM_HEADER StreamHeader
    );

ULONG
WalkCircuit (
    IN PVOID Object,
    IN PFNCIRCUIT_WALK_CALLBACK Callback,
    IN PVOID CallbackContext
    );

void
HexDump (
    IN PVOID HostAddress,
    IN ULONG TargetAddress,
    IN ULONG BufferSize
    );

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

BOOLEAN
DisplayNamedAutomationSet (
    IN GUID *Set,
    IN char *String
    );

BOOLEAN
DisplayNamedAutomationId (
    IN GUID *Set,
    IN ULONG Id,
    IN char *String,
    IN OUT AUTOMATION_DUMP_HANDLER *DumpHandler
    );

int
ustrcmp (
    char *a,
    char *b
    );

DWORD 
Evaluator (
    IN const char *StringEval
    );

void
GlobInit (
    );

char *
Tab (
    IN ULONG Depth
    );

#ifdef __cplusplus
}
#endif // __cplusplus


#define FIELDOFFSET(struc,field) \
    (ULONG)(&(((struc *)0) -> field))

//
// Dump Levels
//
#define DUMPLVL_TERSE 0
#define DUMPLVL_GENERAL 1
#define DUMPLVL_BEYONDGENERAL 2
#define DUMPLVL_SPECIFIC 3
#define DUMPLVL_INTERNAL 4
#define DUMPLVL_INTERNALDETAIL 5
#define DUMPLVL_HIGHDETAIL 6
#define DUMPLVL_EVERYTHING 7

//
// Tabbing
//
#define INITIAL_TAB 0
#define TAB_SPACING 4

#define DBG_DUMPGUID(text,guid) \
   dprintf ("%s%08lx-%04x-%04x-%02x%02x-%02x%02x%08lx\n", \
   text, \
   *(((ULONG *)&(guid)) + 0), \
   *(((USHORT *)&(guid)) + 2), \
   *(((USHORT *)&(guid)) + 3), \
   *(((USHORT *)&(guid)) + 4) & 0xFF, \
   *(((USHORT *)&(guid)) + 4) >> 8, \
   *(((USHORT *)&(guid)) + 5) & 0xFF, \
   *(((USHORT *)&(guid)) + 5) >> 8, \
   ((*(((ULONG *)&(guid)) + 3)) & 0xFF) << 24 | \
   ((*(((ULONG *)&(guid)) + 3)) & 0xFF00) << 8 | \
   ((*(((ULONG *)&(guid)) + 3)) & 0xFF0000) >> 8 | \
   ((*(((ULONG *)&(guid)) + 3)) & 0xFF000000) >> 24); \

#define XTN_DUMPGUID(text,tab,guid) \
   if (!text [0])\
       dprintf ("%s%08lx-%04x-%04x-%02x%02x-%02x%02x%08lx\n", \
       Tab (tab), \
       *(((ULONG *)&(guid)) + 0), \
       *(((USHORT *)&(guid)) + 2), \
       *(((USHORT *)&(guid)) + 3), \
       *(((USHORT *)&(guid)) + 4) & 0xFF, \
       *(((USHORT *)&(guid)) + 4) >> 8, \
       *(((USHORT *)&(guid)) + 5) & 0xFF, \
       *(((USHORT *)&(guid)) + 5) >> 8, \
       ((*(((ULONG *)&(guid)) + 3)) & 0xFF) << 24 | \
       ((*(((ULONG *)&(guid)) + 3)) & 0xFF00) << 8 | \
       ((*(((ULONG *)&(guid)) + 3)) & 0xFF0000) >> 8 | \
       ((*(((ULONG *)&(guid)) + 3)) & 0xFF000000) >> 24); \
   else \
       dprintf ("%s%s %08lx-%04x-%04x-%02x%02x-%02x%02x%08lx\n", \
       Tab (tab), \
       text, \
       *(((ULONG *)&(guid)) + 0), \
       *(((USHORT *)&(guid)) + 2), \
       *(((USHORT *)&(guid)) + 3), \
       *(((USHORT *)&(guid)) + 4) & 0xFF, \
       *(((USHORT *)&(guid)) + 4) >> 8, \
       *(((USHORT *)&(guid)) + 5) & 0xFF, \
       *(((USHORT *)&(guid)) + 5) >> 8, \
       ((*(((ULONG *)&(guid)) + 3)) & 0xFF) << 24 | \
       ((*(((ULONG *)&(guid)) + 3)) & 0xFF00) << 8 | \
       ((*(((ULONG *)&(guid)) + 3)) & 0xFF0000) >> 8 | \
       ((*(((ULONG *)&(guid)) + 3)) & 0xFF000000) >> 24)

#endif // __AVSTREAM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\ksfilter\ks\kdexts\logapi.cpp ===
/**************************************************************************

    logapi.cpp
   
    --------------------------------------------------

    Ks Logging access extension API

    --------------------------------------------------

    Toss questions at wmessmer
 
    ==================================================

    In debug mode, Ks keeps a log of events that happen (irp arrivals,
    transports, etc...).  Reading this without the aid of some type of
    extension is useless.  That's precisely what this section of the debug
    extension is designed to do.

    ==================================================

    Notes to future maintainers:

    1) 

        Unfortunately, as of the writing of this code, ks.sys does not
        track Irp movement in and out of certain types of objects 
        (requestors) and also does not track creation and destruction of
        certain types of objects.  This makes findlive a difficult command
        to accurately implement.

        I intend to eventually implement the logging of requestor motions
        and the creations/destructions which are not logged now, but this
        will not be in some releases (most notably DX8, but also WinME).  
        Once this is in, some of the code in FindLiveObject will become
        unnecessary...  PLEASE, maintain the support in case anything ever
        needs debugged with respect to DX8.  

**************************************************************************/

#include "kskdx.h"
#include "avsutil.h"

//
// Include class definitions for key parts.
//
#include "..\shpin.cpp"
#include "..\shfilt.cpp"
#include "..\shqueue.cpp"
#include "..\shreq.cpp"
#include "..\shdevice.cpp"

char *NounNames [] = {
    "Irp", // This isn't really a noun!
    "Graph",
    "Filter",
    "Pin",
    "Queue",
    "Requestor",
    "Splitter",
    "Branch"
    "Pipe Section"
};

#define NOUN_IDX_IRP 0
#define NOUN_IDX_FILTER 2
#define NOUN_IDX_PIN 3
#define NOUN_IDX_QUEUE 4
#define NOUN_IDX_REQUESTOR 5

char *VerbNames [] = {
    "Create",
    "Destroy",
    "Send",
    "Receive"
};

typedef enum _NODE_TYPE {

    NodeCreation,
    NodeDestruction

} NODE_TYPE, *PNODE_TYPE;

typedef struct _OBJECT_NODE {

    LIST_ENTRY ListEntry;
    
    //
    // What object are we looking at.  There can only be one node per object
    // in the list.
    //
    PVOID Object;

    //
    // Associated information out of the log information.  What is the filter
    // and what is the pin associated with this.  This may be the same as
    // object if the object is a filter or pin.
    //
    PVOID Filter;
    PVOID Pin;
    
    //
    // In all cases EXCEPT searching for Irps, this should match the context's
    // noun.  In IRP's we have to track all pins, queues, requestors 
    // (BUGBUG: splitters)
    //
    ULONG ObjectNoun;

    //
    // Is this a creation or destruction node?
    //
    NODE_TYPE NodeType;

    //
    // Indicates whether this entry is locked.  A locked entry is a guaranteed
    // match for a live object supposing the node is not a destruct node.
    //
    BOOLEAN Locked;

    //
    // Indicates whether or not the object is a sink.  All requestors are
    // sinks, some pins are sinks.
    //
    BOOLEAN Sink;

    //
    // Indicates whether or not the creation of the Irp was a receive.
    //
    BOOLEAN Received;

    //
    // Indicates whether we've passed the creation entry for this node (if
    // the node is a create node)
    //
    BOOLEAN PassedCreate;

    //
    // Indicates whether a creation for an Irp node referenced a component
    // which had already been destroyed in the log (temporally backwards,
    // I know...  obviously, the destruction would come in the future...
    // just remember that we're scanning the log backwards).
    //
    BOOLEAN CreationReferencedDestruction;

    //
    // What node is the parent node if we know
    //
    struct _OBJECT_NODE *ParentNode;
    
    //
    // What node created this node?  This is not the parent.  Only receivers
    // can be parents.
    //
    struct _OBJECT_NODE *CreatorNode;

} OBJECT_NODE, *POBJECT_NODE;

typedef struct _LIVE_OBJECT_CONTEXT {

    ULONG TabDepth;
    ULONG DumpLevel;
    ULONG ObjectNoun;

    PVOID PreviousObject;
    ULONG PreviousVerb;

    LIST_ENTRY ObjectNodes;

} LIVE_OBJECT_CONTEXT, *PLIVE_OBJECT_CONTEXT;

/*************************************************

    Function:

        IsSinkPin

    Description:

        Determine if a target side pin is a sink pin or a source
        pin.  Sinks return TRUE, sources FALSE.

    Arguments:

        Pin -
            The pin to question.

    Return Value:

        TRUE -
            The pin is a sink

        FALSE -
            The pin is a source / an error occurred

*************************************************/

BOOLEAN
IsSinkPin (
    IN CKsPin *Pin
    )

{

    PFILE_OBJECT *ConnectionAddress;
    PFILE_OBJECT ConnectionFile;
    ULONG Result;

    ConnectionAddress = (PFILE_OBJECT *)((PUCHAR)Pin + 
        FIELDOFFSET (CKsPin, m_ConnectionFileObject));

    if (!ReadMemory (
        (DWORD)ConnectionAddress,
        &ConnectionFile,
        sizeof (PFILE_OBJECT),
        &Result))
        return FALSE;

    return (ConnectionFile == NULL);

}

/*************************************************

    Function:

        DisplayOwningDriver

    Description:

        Find the owning driver for an object and display it.

    Arguments:

        Object -
            The object

        NounType -
            The object type (as a noun index)

    Return Value:

        Successful or not

*************************************************/

BOOLEAN
DisplayOwningDriver (
    IN PVOID Object,
    IN ULONG NounType
    )

{
    
    PKSPX_EXT ExtAddr;
    ULONG Result;

    switch (NounType) {

        case NOUN_IDX_PIN:
            ExtAddr = (PKSPX_EXT)((PUCHAR)Object + FIELDOFFSET (CKsPin, m_Ext));
            break;

        case NOUN_IDX_FILTER:
            ExtAddr = (PKSPX_EXT)((PUCHAR)Object + 
                FIELDOFFSET (CKsFilter, m_Ext));
            break;

        case NOUN_IDX_QUEUE:
        {
            PKSPIN *PinAddr = (PKSPIN *)((PUCHAR)Object +
                FIELDOFFSET (CKsQueue, m_MasterPin));

            if (!ReadMemory (
                (DWORD)PinAddr,
                (PVOID)&ExtAddr,
                sizeof (PVOID),
                &Result))
                return FALSE;

            ExtAddr = (PKSPX_EXT)CONTAINING_RECORD (
                ExtAddr, KSPIN_EXT, Public
                );

            break;
                
        }

        case NOUN_IDX_REQUESTOR:
        {
            PIKSPIN *PinIfAddr = (PIKSPIN *)((PUCHAR)Object +
                FIELDOFFSET (CKsRequestor, m_Pin));

            if (!ReadMemory (
                (DWORD)PinIfAddr,
                (PVOID)&ExtAddr,
                sizeof (PVOID),
                &Result))
                return FALSE;

            ExtAddr = (PKSPX_EXT)((PUCHAR)((CKsPin *)((PIKSPIN)ExtAddr)) + 
                FIELDOFFSET (CKsPin, m_Ext));

            break;

        }

    }

    //
    // We have some ext structure.  Now we need the device interface.
    //
    PIKSDEVICE DeviceIf;

    if (!ReadMemory (
        (DWORD)ExtAddr + FIELDOFFSET(KSPX_EXT, Device),
        &DeviceIf,
        sizeof (PIKSDEVICE),
        &Result)) {
        #ifdef DEBUG_EXTENSION
            dprintf ("%08lx: cannot read Ext's Device!\n", ExtAddr);
        #endif // DEBUG_EXTENSION
        return FALSE;
    }

    #ifdef DEBUG_EXTENSION
        dprintf ("DeviceIf = %08lx\n", DeviceIf);
    #endif // DEBUG_EXTENSION

    //
    // We have a device interface.  Now we need the address of the FDO.
    //
    PDEVICE_OBJECT *FDOAddr;
    PDEVICE_OBJECT FDO;

    FDOAddr = (PDEVICE_OBJECT *)((PUCHAR)((CKsDevice *)DeviceIf) + 
        FIELDOFFSET (CKsDevice, m_Ext) +
        FIELDOFFSET (KSDEVICE_EXT, Public) +
        FIELDOFFSET (KSDEVICE, FunctionalDeviceObject));

    if (!ReadMemory (
        (DWORD)FDOAddr,
        &FDO,
        sizeof (PDEVICE_OBJECT),
        &Result)) {
        #ifdef DEBUG_EXTENSION
            dprintf ("%08lx: cannot read FDO!\n", FDOAddr);
        #endif // DEBUG_EXTENSION
        return FALSE;
    }

    #ifdef DEBUG_EXTENSION
        dprintf ("FDO = %08lx\n", FDO);
    #endif // DEBUG_EXTENSION
        
    //
    // We have to read in the driver object from the FDO
    //
    PDRIVER_OBJECT DriverObject;

    if (!ReadMemory (
        (DWORD)FDO + FIELDOFFSET (DEVICE_OBJECT, DriverObject),
        &DriverObject,
        sizeof (PDRIVER_OBJECT),
        &Result)) {
        #ifdef DEBUG_EXTENSION
            dprintf ("%08lx: Cannot read FDO's driver object!\n", FDO);
        #endif // DEBUG_EXTENSION
        return FALSE;
    }

    #ifdef DEBUG_EXTENSION
        dprintf ("DriverObject = %08lx\n", DriverObject);
    #endif // DEBUG_EXTENSION

    //
    // Read in the string
    //
    UNICODE_STRING Name;

    if (!ReadMemory (
        (DWORD)DriverObject + FIELDOFFSET (DRIVER_OBJECT, DriverName),
        &Name,
        sizeof (UNICODE_STRING),
        &Result)) {
        #ifdef DEBUG_EXTENSION
            dprintf ("%08lx: Cannot read driver object's name!\n", 
                DriverObject);
        #endif // DEBUG_EXTENSION
        return FALSE;
    }

    #ifdef DEBUG_EXTENSION
        dprintf ("Read String!\n");
    #endif // DEBUG_EXTENSION

    PWSTR Buffer = (PWSTR)malloc (Name.MaximumLength * sizeof (WCHAR));

    #ifdef DEBUG_EXTENSION
        dprintf ("Allocated %ld bytes for buffer @ %08lx\n",
            Name.MaximumLength * sizeof (WCHAR), Buffer
            );
    #endif // DEBUG_EXTENSION

    if (Buffer) {

        #ifdef DEBUG_EXTENSION
            dprintf ("About to read memory %08lx, %08lx, %08lx, %08lx\n",
                Name.Buffer, Buffer, sizeof (WCHAR) * Name.MaximumLength,
                Result);
        #endif // DEBUG_EXTENSION

        if (!ReadMemory (
            (DWORD)Name.Buffer,
            Buffer,
            sizeof (WCHAR) * Name.MaximumLength,
            &Result
            )) {
            #ifdef DEBUG_EXTENSION
                dprintf ("%08lx: Cannot read name!\n", Name.Buffer);
            #endif // DEBUG_EXTENSION
            free (Buffer);
            return FALSE;
        }

        #ifdef DEBUG_EXTENSION
            dprintf ("Name.Length = %ld, Name.MaximumLength = %ld\n",
                Name.Length, Name.MaximumLength
                );

            HexDump (Buffer, (ULONG)Name.Buffer, 
                Name.MaximumLength * sizeof (WCHAR));

        #endif // DEBUG_EXTENSION

        Name.Buffer = Buffer;

        dprintf ("[%wZ]", &Name);

        free (Buffer);

    }

    #ifdef DEBUG_EXTENSION
        dprintf ("END OWNING DRIVER!\n");
    #endif // DEBUG_EXTENSION

    return TRUE;

}

char *States [] = {
    "STOP",
    "ACQUIRE",
    "PAUSE",
    "RUN"
};

/*************************************************

    Function:

        DisplayNodeAssociatedInfo

    Description:

        Display associated information with the node at a particular level.

    Arguments:

        TabDepth -
            The tab depth to display information at

        DumpLevel -
            The dump level to dump at

        Node -
            The node in question

*************************************************/

void
DisplayNodeAssociatedInfo (
    IN ULONG TabDepth,
    IN ULONG DumpLevel,
    IN POBJECT_NODE Node
    )

{

    ULONG Result;

    if (DumpLevel >= DUMPLVL_SPECIFIC && 
        Node -> ObjectNoun != NOUN_IDX_FILTER)
        dprintf ("%sParent Filter: %08lx\n", Tab (TabDepth), Node -> Filter);

    switch (Node -> ObjectNoun) {
        //
        // For a queue, we will display in/out state r/w/c
        //
        case NOUN_IDX_QUEUE:
        {
            CMemoryBlock <CKsQueue> QueueObject;

            if (!ReadMemory (
                (DWORD)Node -> Object,
                QueueObject.Get (),
                sizeof (CKsQueue),
                &Result)) {

                dprintf ("%08lx: unable to read queue!\n", Node -> Object);
                return;
            }

            if (DumpLevel >= DUMPLVL_SPECIFIC) {

                dprintf ("%s", Tab (TabDepth));

                if (QueueObject -> m_InputData) {
                    if (QueueObject -> m_OutputData)
                        dprintf ("in/out ");
                    else
                        dprintf ("in ");
                } else if (QueueObject -> m_OutputData) 
                    dprintf ("out ");

                dprintf ("%s ", States [QueueObject -> m_State]);

                dprintf ("r/w/c=%ld/%ld/%ld\n",
                    QueueObject -> m_FramesReceived,
                    QueueObject -> m_FramesWaiting,
                    QueueObject -> m_FramesCancelled
                    );

            }

            break;

        }
                
        //
        // For a pin, we will display state s/d/sy
        //
        case NOUN_IDX_PIN:
        {
            CMemoryBlock <CKsPin> PinObject;

            if (!ReadMemory (
                (DWORD)Node -> Object,
                PinObject.Get (),
                sizeof (CKsPin),
                &Result)) {

                dprintf ("%08lx: unable to read pin!\n", Node -> Object);
                return;
            }

            if (DumpLevel >= DUMPLVL_SPECIFIC) {
            
                dprintf ("%s%s s/d/sy=%ld/%ld/%ld\n", Tab (TabDepth),
                    States [PinObject -> m_Ext.Public.DeviceState],
                    PinObject -> m_StreamingIrpsSourced,
                    PinObject -> m_StreamingIrpsDispatched,
                    PinObject -> m_StreamingIrpsRoutedSynchronously
                    );

            }

            break;

        }

        //
        // For a requestor, we will display state size, count, active
        //
        case NOUN_IDX_REQUESTOR:
        {
            CMemoryBlock <CKsRequestor> RequestorObject;

            if (!ReadMemory (
                (DWORD)Node -> Object,
                RequestorObject.Get (),
                sizeof (CKsPin),
                &Result)) {

                dprintf ("%08lx: unable to read requestor!\n", Node -> Object);
                return;
            }

            if (DumpLevel >= DUMPLVL_SPECIFIC) {

                dprintf ("%s%s size=%ld count=%ld active=%ld\n",
                    Tab (TabDepth),
                    States [RequestorObject -> m_State],
                    RequestorObject -> m_FrameSize,
                    RequestorObject -> m_FrameCount,
                    RequestorObject -> m_ActiveFrameCountPlusOne - 1
                    );

            }

        }

        default:
            break;
    }

}

/*************************************************

    Function:

        DisplayAndCleanLiveObjects

    Description:

        Display any live objects as determined by the node list.  Clean
        up the memory used by the node list

    Arguments:

        LiveContext -
            The context information (containing the node list)

    Return Value:

        Number of live objects.

*************************************************/

ULONG
DisplayAndCleanLiveObjects (
    IN PLIVE_OBJECT_CONTEXT LiveContext
    )

{

    ULONG LivingCount = 0;
    PLIST_ENTRY Link, NextLink;

    for (Link = LiveContext -> ObjectNodes.Flink;
         Link != &(LiveContext -> ObjectNodes);
         Link = NextLink) {

        POBJECT_NODE Node = (POBJECT_NODE)CONTAINING_RECORD (
           Link, OBJECT_NODE, ListEntry
           );

        NextLink = Link -> Flink;

        if (Node -> NodeType == NodeCreation &&
            Node -> ObjectNoun == LiveContext -> ObjectNoun) {

            //
            // OPTIMIZATION RULE:
            //
            // Because of certain logging inadequacies, this rule helps to
            // eliminate bogus hits.  If we haven't found the parent and
            // the creation of the Irp node referenced a destruct node for
            // another component, ignore this object.
            //
            // NOTE: This only happens for Irp searches.  The frees will happen
            // in a second pass across the lists, so don't worry about the
            // continue.
            //
            if (LiveContext -> ObjectNoun == NOUN_IDX_IRP &&
                Node -> CreationReferencedDestruction)
                continue;

            LivingCount++;

            dprintf ("%s", Tab (LiveContext -> TabDepth));
            
            //
            // This shouldn't happen, but if the create isn't locked, it's
            // only a possible live.
            //
            // NOTE: due to a logging error in pre-Whistler ks.sys, this
            // can happen.  Filter destructions aren't logged which means
            // filters can come back bogus.  if WHISTLER is not defined,
            // filter nodes aren't locked ever.
            //
            if (!Node -> Locked)
                dprintf ("Possible ");

            dprintf ("Live %s %08lx ",
                NounNames [Node -> ObjectNoun],
                Node -> Object
                );
            
            //
            // Find the owning driver and display it.  Note that this may
            // fail for non-locked nodes....  but the extension SHOULD handle
            // that case.
            //
            if (Node -> ObjectNoun != NOUN_IDX_IRP)  {
                if (!DisplayOwningDriver (Node -> Object, Node -> ObjectNoun)) {
                    dprintf ("[unknown - POSSIBLY BOGUS!]");
                }
            }
            //
            // For Irps, we want to display the parent object and
            // the driver of the parent object.
            //
            else {
                if (Node -> ParentNode) {
                    dprintf ("in %s %08lx at ",
                        NounNames [Node -> ParentNode -> ObjectNoun],
                        Node -> ParentNode -> Object
                        );

                    if (!DisplayOwningDriver (Node -> ParentNode -> Object,
                        Node -> ParentNode -> ObjectNoun)) {
                        dprintf ("[unknown - POSSIBLY BOGUS!]");
                    }

                } else 
                    dprintf ("unknown parent!");
            }

            dprintf ("\n");

            //
            // If internal information is warranted, dump it.
            //
            if (LiveContext -> DumpLevel >= DUMPLVL_SPECIFIC) {
                if (Node -> ObjectNoun != NOUN_IDX_IRP)
                    DisplayNodeAssociatedInfo (LiveContext -> TabDepth + 1, 
                        LiveContext -> DumpLevel, Node);
                else {
                    if (Node -> ParentNode) {
                        dprintf ("%sParent %s information:\n",
                            Tab (LiveContext -> TabDepth + 1), 
                            NounNames [Node -> ParentNode -> ObjectNoun]
                            );
                        DisplayNodeAssociatedInfo (LiveContext -> TabDepth + 2,
                            LiveContext -> DumpLevel, Node -> ParentNode
                            );
                    }
                }
            }
        }

        //
        // We can't free nodes yet for Irps.  We must preserve parental
        // chains.  We'll make a second pass for Irp finding.
        //
        if (LiveContext -> ObjectNoun != NOUN_IDX_IRP)
            free (Node);

    }

    //
    // If we were searching for Irps, we had to preserve all nodes during
    // the first pass...  reason being that we have to know the parent node;
    // therefore, it cannot have been freed.
    //
    // In this case, we make a second pass across the node list and free 
    // everything.
    // 
    if (LiveContext -> ObjectNoun == NOUN_IDX_IRP) 
        for (Link = LiveContext -> ObjectNodes.Flink;
             Link != &(LiveContext -> ObjectNodes);
             Link = NextLink) {
    
            POBJECT_NODE Node = (POBJECT_NODE)CONTAINING_RECORD (
               Link, OBJECT_NODE, ListEntry
               );
    
            NextLink = Link -> Flink;

            free (Node);
        }

    return LivingCount;

}

/*************************************************

    Function:

        InsertNodeList

    Description:

        Insert a node into the node list in sorted order.  TODO: Make this
        hash!

    Arguments:

        List -
            The node list

        Node -
            The node to insert

    Return Value:

        None

*************************************************/

void
InsertNodeList (
    IN PLIST_ENTRY List,
    IN POBJECT_NODE Node
    )

{

    PLIST_ENTRY Searcher;
    PLIST_ENTRY NextSearcher;

    for (Searcher = List -> Flink;
         Searcher != List;
         Searcher = NextSearcher) {

        POBJECT_NODE NodeSought;

        NextSearcher = Searcher -> Flink;

        NodeSought = (POBJECT_NODE)CONTAINING_RECORD (
           Searcher, OBJECT_NODE, ListEntry
           );

        //
        // The list is kept in sorted order.  TODO: Hash this!
        //
        if (NodeSought -> Object > Node -> Object) {
            //
            // If there's an entry that's greater...  It means that we
            // can insert immediately before this entry and return.
            //
            InsertTailList (&(NodeSought -> ListEntry),
                &(Node -> ListEntry)
                );

            return;
        }

        if (NodeSought -> Object == Node -> Object) {
            dprintf ("ERROR: Duplicate node found in extension!  "
                "Inform component owner!\n");
            return;
        }
    }

    //
    // There is no greater.  Insert it at the tail of the list.
    //
    InsertTailList (List, &(Node -> ListEntry));

}

/*************************************************

    Function:

        FindNodeList

    Description:

        Find an object in the node list.  TODO: Make this hash!

    Arguments:

        List - 
            The node list

        Object -
            The object to find

    Return Value:

        The appropriate node or NULL if not found.

*************************************************/

POBJECT_NODE 
FindNodeList (
    IN PLIST_ENTRY List,
    IN PVOID Object
    )

{

    PLIST_ENTRY Searcher;
    PLIST_ENTRY NextSearcher;
    POBJECT_NODE Node;

    for (Searcher = List -> Flink;
         Searcher != List;
         Searcher = NextSearcher) {

        POBJECT_NODE Node;

        NextSearcher = Searcher -> Flink;

        Node = (POBJECT_NODE)CONTAINING_RECORD (
           Searcher, OBJECT_NODE, ListEntry
           );

        //
        // The list is kept in sorted order.  TODO: Hash this!
        //
        if (Node -> Object > Object)
            break;

        if (Node -> Object == Object)
            return Node;
    }

    return NULL;

}

/*************************************************

    Function:

        SearchForRequestor

    Description:

        Callback from the circuit walker to find a requestor.
        Since requestors aren't anywhere in the log, this is one
        way to find them.  I suppose the other would be digging
        through pipe sections.

    Arguments:

        Context -
            The live object context

        Type -
            The object type

        Base -
            The requestor's base address

        Object -
            The requestor data

    Return Value:

        FALSE (keep searching)

*************************************************/

BOOLEAN
SearchForRequestor (
    IN PVOID Context,
    IN INTERNAL_OBJECT_TYPE Type,
    IN DWORD Base,
    IN PVOID Object
    )

{

    POBJECT_NODE Node;
    PLIVE_OBJECT_CONTEXT LiveContext = (PLIVE_OBJECT_CONTEXT)Context;
    ULONG Result;

    if (Type != ObjectTypeCKsRequestor)
        return FALSE;

    //
    // Aha, we've found a requestor.  If such node doesn't already exist,
    // create one and lock it down.
    //
    Node = FindNodeList (&LiveContext -> ObjectNodes, (PVOID)Base);
    if (!Node) {

        CKsRequestor *RequestorObject = (CKsRequestor *)Object;

        //
        // We need the parent filter.  This means that we need to dig it up.
        //
        CKsPin *Pin = (CKsPin *)RequestorObject -> m_Pin;
        PKSFILTER_EXT FilterExt;

        if (!ReadMemory (
            (DWORD)Pin + FIELDOFFSET (CKsPin, m_Ext) +
                FIELDOFFSET (KSPIN_EXT, Parent),
            &FilterExt,
            sizeof (PKSFILTER_EXT),
            &Result)) {

            dprintf ("%08lx: Cannot read pin's parent filter!\n", Pin);
            return FALSE;
        }

        CKsFilter *Filter = (CKsFilter *)CONTAINING_RECORD (
            FilterExt, CKsFilter, m_Ext
            );

        Node = (POBJECT_NODE)malloc (sizeof (OBJECT_NODE));
        Node -> Object = (PVOID)Base;
        Node -> Filter = Node -> Pin = NULL;
        Node -> ObjectNoun = NOUN_IDX_REQUESTOR;
        Node -> NodeType = NodeCreation;
        Node -> Locked = TRUE;
        Node -> Sink = TRUE;
        Node -> Received = FALSE;
        Node -> PassedCreate = FALSE;
        Node -> CreationReferencedDestruction = FALSE;
        Node -> ParentNode = FALSE;
        Node -> CreatorNode = FALSE;
        Node -> Pin = (PVOID)Pin;
        Node -> Filter = (PVOID)Filter;

        InsertNodeList (&LiveContext -> ObjectNodes, Node);

    }

    return FALSE;

}
    
/*************************************************

    Function:

        FindLiveObject

    Description:

        Callback from the log iterator.  This is used to find live objects
        of a particular type.

    Arguments:

        Context -
            The live object context

        Entry -
            The entry we're iterating

    Notes:

        This routine is large and complex.  It probably could and should
        be simplified.  One of the major difficulties is that ks does not
        log movement of Irps through requestors and does not log certain
        object creations/destructions.  This means that I have to make 
        educated guesses about the Irp.  Hopefully, these are adequate.

*************************************************/

BOOLEAN
FindLiveObject (
    IN PVOID Context,
    IN PKSLOG_ENTRY Entry
    )

{

    PLIVE_OBJECT_CONTEXT LiveContext = (PLIVE_OBJECT_CONTEXT)Context;

    ULONG Noun = (Entry -> Code & KSLOGCODE_NOUN_MASK);
    ULONG Verb = (Entry -> Code & KSLOGCODE_VERB_MASK);
    ULONG PreviousVerb;

    PVOID Object, Irp;
    PVOID PreviousObject;
    NODE_TYPE ObjectNodeType;

    PLIST_ENTRY Searcher, NextSearcher;
    POBJECT_NODE Node;
    ULONG ObjectNoun;

    #ifdef DEBUG_EXTENSION
        dprintf ("[%s]Considering %s %08lx search is %s\n",
            VerbNames [Verb >> 16],
            NounNames [Noun >> 24], Entry -> Context.Component, 
            NounNames [LiveContext -> ObjectNoun]);
    #endif // DEBUG_EXTENSION

    //
    // Set previous information.
    //
    PreviousObject = LiveContext -> PreviousObject;
    PreviousVerb = LiveContext -> PreviousVerb;
    LiveContext -> PreviousObject = (PVOID)Entry -> Context.Component;
    LiveContext -> PreviousVerb = Verb;

    //
    // If the noun directly references the object we're talking about, the
    // component field should be what we want and the verbiage should
    // specify the type.
    //
    // If we're being asked to find live Irps, we must keep nodes for all
    // queues, pins, requestors (BUGBUG: splitters).  Note that we find only
    // streaming live Irps!
    //
    Irp = NULL;

    if (Noun >> 24 == LiveContext -> ObjectNoun ||
        (LiveContext -> ObjectNoun == NOUN_IDX_IRP &&
            (Noun == KSLOGCODE_NOUN_QUEUE ||
            Noun == KSLOGCODE_NOUN_REQUESTOR ||
            Noun == KSLOGCODE_NOUN_PIN)
            ) ||
        (LiveContext -> ObjectNoun == NOUN_IDX_REQUESTOR &&
            (Noun == KSLOGCODE_NOUN_QUEUE ||
            Noun == KSLOGCODE_NOUN_PIN)
            ) 
        ) {

        Object = (PVOID)Entry -> Context.Component;
        ObjectNoun = Noun >> 24;

        if (LiveContext -> ObjectNoun == NOUN_IDX_IRP && 
            (Verb == KSLOGCODE_VERB_RECV || Verb == KSLOGCODE_VERB_SEND)) {
            Irp = (PIRP)Entry -> Irp;
            
            #ifdef DEBUG_EXTENSION
                dprintf ("Considering potential Irp %08lx\n", Irp);
            #endif // DEBUG_EXTENSION

        }

        switch (Verb) {
            
            case KSLOGCODE_VERB_CREATE:
            case KSLOGCODE_VERB_RECV:
            case KSLOGCODE_VERB_SEND:
                ObjectNodeType = NodeCreation;
                break;

            case KSLOGCODE_VERB_DESTROY:
                ObjectNodeType = NodeDestruction;
                break;
    
            default:
                return FALSE;
        }
    } else {
        //
        // If we're not referring to the object in question, we may be
        // referring to it indirectly.
        //
        // This can only happen for pins and filters.  If it's not a pin
        // or filter, ignore it.
        //
        switch (LiveContext -> ObjectNoun) {
            case NOUN_IDX_FILTER:

                if (Entry -> Context.Filter) {
                    Object = (PVOID)Entry -> Context.Filter;

                    #ifdef DEBUG_EXTENSION
                        dprintf ("Considering indirect filter %08lx\n",
                            Object);
                    #endif // DEBUG_EXTENSION

                    //
                    // This is always creation.  The only way it'd be a
                    // destruction is if it were a filter.  In that case,
                    // the noun would match the search creterion and we'd
                    // not be in the else clause.
                    //
                    ObjectNodeType = NodeCreation;
                    ObjectNoun = NOUN_IDX_FILTER;
                }
                else
                    return FALSE;

                break;

            case NOUN_IDX_PIN:

                if (Entry -> Context.Pin) {
                    Object = (PVOID)Entry -> Context.Pin;

                    #ifdef DEBUG_EXTENSION
                        dprintf ("Considering indirect pin %08lx\n",
                            Object);
                    #endif // DEBUG_EXTENSION

                    //
                    // This is always creation.  The only way it'd be a
                    // destruction is if it were a pin.  In that case,
                    // the noun would match the search criterion and we'd
                    // not be in the else clause.
                    //
                    ObjectNodeType = NodeCreation;
                    ObjectNoun = NOUN_IDX_PIN;
                }
                else
                    return FALSE;

            default:

                return FALSE;
        }
    }

    //
    // Find out if this is a code we're interested in
    //
    switch (ObjectNodeType) {

        case NodeCreation:
            //
            // As far as we're concerned, creation, receiving, sending
            // all mean the same thing...  they all mean that the object
            // exists as of this timeslice.
            //

            //
            // If there's a destruction in the node list above this, the
            // object is gone...  Wipe the destruction node and continue
            //
            Node = FindNodeList (&LiveContext -> ObjectNodes, Object);

            if (Node) {
    
                //
                // Only a create can pop a destruct!  Multiple sends and
                // receives will just bail out.
                //
                if (Node -> NodeType == NodeDestruction &&
                    !Node -> Locked &&
                    Verb == KSLOGCODE_VERB_CREATE) {
    
                    #ifdef DEBUG_EXTENSION
                        dprintf ("[%08lx %08lx]Popping node for %08lx, "
                            "destruction above!\n", 
                            Noun, Verb,
                            Node -> Object
                        );
                    #endif // DEBUG_EXTENSION
    
                    RemoveEntryList (&(Node -> ListEntry));
    
                    free (Node);
    
                }
                else {
                    if (Verb == KSLOGCODE_VERB_CREATE &&
                        (PVOID)Entry -> Context.Component == Object)  {

                        #ifdef DEBUG_EXTENSION
                            dprintf ("Node for %s %08lx passed create!\n",
                                NounNames [Node -> ObjectNoun],
                                Node -> Object
                                );
                        #endif // DEBUG_EXTENSION

                        Node -> PassedCreate = TRUE;
                    }
                }

                //
                // We ignore multiple recv/send/create.  There's already
                // a node in the list corresponding to this object.
                //
                break;
            }

            //
            // If we found a matching node, we won't be here : we'll either
            // have popped the node and returned or done nothing and returned.
            // If we hit this, there is no creation node...  meaning that
            // there was no destruct above us.  Make a create node and 
            // lock it down.  This is a guaranteed live object.
            //
            #ifdef DEBUG_EXTENSION
                dprintf ("[%08lx %08lx]Pushing node for %s %08lx, locked "
                    "create!\n",
                    Noun, Verb,
                    NounNames [ObjectNoun],
                    Object
                    );
            #endif // DEBUG_EXTENSION

            Node = (POBJECT_NODE)malloc (sizeof (OBJECT_NODE));
            Node -> Object = (PVOID)Object;
            Node -> ObjectNoun = ObjectNoun;
            Node -> ParentNode = NULL;
            Node -> Received = FALSE;
            Node -> Filter = (PVOID)Entry -> Context.Filter;
            Node -> Pin = (PVOID)Entry -> Context.Pin;

            if (Verb == KSLOGCODE_VERB_CREATE &&
                (PVOID)Entry -> Context.Component == Object) {

                #ifdef DEBUG_EXTENSION
                    dprintf ("Node for %s %08lx passed create on node create!"
                        "\n",
                        NounNames [Node -> ObjectNoun],
                        Node -> Object
                        );
                #endif // DEBUG_EXTENSION 

                Node -> PassedCreate = TRUE;
            } else
                Node -> PassedCreate = FALSE;

            //
            // ks.sys prior to Whistler does not log filter creation and
            // destruction (it does every other object).  Any filters reported
            // are only possible on that.  Do NOT lock the entry.
            //
            #ifndef WHISTLER
                if (ObjectNoun == NOUN_IDX_FILTER)
                    Node -> Locked = FALSE;
                else
            #endif // WHISTLER
                    Node -> Locked = TRUE;

            Node -> NodeType = NodeCreation;
            
            if (Node -> ObjectNoun == NOUN_IDX_REQUESTOR)
                Node -> Sink = TRUE;
            else if (Node -> ObjectNoun == NOUN_IDX_PIN) {
                if (Node -> Locked) 
                    Node -> Sink = IsSinkPin ((CKsPin *)Object);
                else 
                    Node -> Sink = FALSE;
            } else
                Node -> Sink = FALSE;

            InsertNodeList (&LiveContext -> ObjectNodes, Node);

            //
            // Since ks doesn't log requestor creation, if we're looking
            // for live requestors, we're going to start walking circuits
            // if we just locked a pin or a queue.
            //
            if (LiveContext -> ObjectNoun == NOUN_IDX_REQUESTOR &&
                (Node -> ObjectNoun == NOUN_IDX_PIN ||
                Node -> ObjectNoun == NOUN_IDX_QUEUE) &&
                Node -> Locked) {

                WalkCircuit (
                    Node -> Object,
                    SearchForRequestor,
                    LiveContext
                    );
            }

            break;
            
        case NodeDestruction:

            //
            // We push a destroy if there's not already a node representing
            // this object.  The node musn't be locked; if a create node
            // is below a destruct node, the destruct node gets popped.
            //
            Node = FindNodeList (&LiveContext -> ObjectNodes, Object);

            if (!Node) {

                #ifdef DEBUG_EXTENSION
                    dprintf ("[%08lx %08lx]Pushing node for %s %08lx, unlocked"
                        " destruct!\n",
                        Noun, Verb,
                        NounNames [ObjectNoun],
                        Object
                        );
                #endif // DEBUG_EXTENSION

                Node = (POBJECT_NODE)malloc (sizeof (OBJECT_NODE));
                Node -> Object = Object;
                Node -> ObjectNoun = ObjectNoun;
                Node -> Sink = FALSE;
                Node -> ParentNode = NULL;
                Node -> PassedCreate = FALSE;
                Node -> Locked = FALSE;
                Node -> NodeType = NodeDestruction;
                Node -> Received = FALSE;
                Node -> Filter = (PVOID)Entry -> Context.Filter;
                Node -> Pin = (PVOID)Entry -> Context.Pin;
                
                InsertNodeList (&LiveContext -> ObjectNodes, Node);
            } 
            else {
                #ifdef DEBUG
                    dprintf ("On destruct push, found existing node for %s "
                        "%08lx (type = %ld)\n",
                        NounNames [Node -> ObjectNoun], Node -> Object,
                        Node -> NodeType
                        );
                #endif // DEBUG

            }

            break;

        default:

            break;
    }

    //
    // If we're hunting Irps, this is where we have to deal with them.  Irps
    // require special care.
    //
    if (LiveContext -> ObjectNoun == NOUN_IDX_IRP &&
        Irp != NULL) {

        //
        // MUSTCHECK: Not sure on the necessity of this!
        //
        POBJECT_NODE CurrentNode = FindNodeList (&LiveContext -> ObjectNodes,
            (PVOID)Entry -> Context.Component);

        if (!CurrentNode) {
            dprintf ("SERIOUS ERROR: Can't find component node!\n");
            return FALSE;
        }

        #ifdef DEBUG_EXTENSION
            if (CurrentNode != Node) dprintf ("DEV NOTE: nodes !=\n");

            dprintf ("For Irp %08lx, CompNode.Object = %08lx, Type = %ld\n", 
                Irp, CurrentNode -> Object, CurrentNode -> NodeType);
        #endif // DEBUG_EXTENSION

        //
        // If we're sinking the Irp, mark a destruct node
        //
        if (CurrentNode -> Sink &&
            Verb == KSLOGCODE_VERB_RECV) {

            POBJECT_NODE IrpNode;

            #ifdef DEBUG_EXTENSION
                dprintf ("Sinking Irp %08lx to parent %s %08lx\n",
                    Irp, NounNames [CurrentNode -> ObjectNoun],
                    CurrentNode -> Object);
            #endif // DEBUG_EXTENSION

            IrpNode = FindNodeList (&LiveContext -> ObjectNodes, (PVOID)Irp);
            if (!IrpNode) {
                //
                // If there's no node, and we're sinking the Irp, we need
                // a destruct node on the list.
                //
                IrpNode = (POBJECT_NODE)malloc (sizeof (OBJECT_NODE));
                IrpNode -> Object = (PVOID)Irp;
                IrpNode -> Locked = FALSE;
                IrpNode -> NodeType = NodeDestruction;
                IrpNode -> Sink = FALSE;
                IrpNode -> ObjectNoun = NOUN_IDX_IRP;
                IrpNode -> Received = TRUE;
                IrpNode -> CreatorNode = CurrentNode;

                //
                // We don't care about this information for destruct nodes.
                //
                IrpNode -> ParentNode = NULL;
                IrpNode -> CreationReferencedDestruction = FALSE;
                IrpNode -> PassedCreate = FALSE;

                //
                // Irp nodes...  we don't really care about this information.
                // The parent we might...  the Irp, we don't.
                //
                IrpNode -> Filter = NULL;
                IrpNode -> Pin = NULL;

                InsertNodeList (&LiveContext -> ObjectNodes, IrpNode);

            }
            else {
                //
                // If we're sinking to an object which has just "sent" the
                // Irp, this usually indicates Irp completion.  Mark the
                // Irp as a destruct node, not a create node.
                //
                if (IrpNode -> CreatorNode -> Received == FALSE &&
                    (PreviousObject == IrpNode -> CreatorNode -> Object &&
                     PreviousVerb == KSLOGCODE_VERB_SEND)
                   ) 
                   IrpNode -> NodeType = NodeDestruction;
            }

        } else {
            //
            // This may as well be a create.  The Irp is live as far as
            // we know as long as there's no destruct stacked above us.
            //
            // BUGBUG: The Irp destruct must get popped at the source...
            // This is not likely to cause problems except on reuse of memory
            // in some possible circumstances?
            //
            POBJECT_NODE IrpNode;

            IrpNode = FindNodeList (&LiveContext -> ObjectNodes, (PVOID)Irp);
            if (!IrpNode) {
                //
                // If there's no node, we can lock down the Irp as live.
                //
                IrpNode = (POBJECT_NODE)malloc (sizeof (OBJECT_NODE));
                IrpNode -> Object = (PVOID)Irp;

                //
                // Requestors don't log Irp receipt and transmission.
                //
                #ifdef WHISTLER
                    IrpNode -> Locked = TRUE;
                #else  // WHISTLER
                    IrpNode -> Locked = FALSE;
                #endif // WHISTLER

                IrpNode -> NodeType = NodeCreation;
                IrpNode -> Sink = FALSE;
                IrpNode -> ObjectNoun = NOUN_IDX_IRP;

                //
                // Irp nodes...  we don't really care about this information.
                // The parent we might...  the Irp, we don't.
                //
                IrpNode -> Filter = NULL;
                IrpNode -> Pin = NULL;
                IrpNode -> PassedCreate = NULL;

                if (CurrentNode -> NodeType == NodeDestruction ||
                    (CurrentNode -> NodeType == NodeCreation &&
                     CurrentNode -> PassedCreate))
                    IrpNode -> CreationReferencedDestruction = TRUE;
                else
                    IrpNode -> CreationReferencedDestruction = FALSE;

                IrpNode -> CreatorNode = CurrentNode;

                if (Verb == KSLOGCODE_VERB_RECV) {
                    IrpNode -> ParentNode = CurrentNode;
                    IrpNode -> Received = TRUE;
                }
                else {
                    IrpNode -> ParentNode = NULL;
                    IrpNode -> Received = FALSE;
                }

                #ifdef DEBUG_EXTENSION
                    dprintf ("Locking in Irp %08lx to parent %s %08lx\n",
                        Irp, IrpNode -> ParentNode ? 
                            NounNames [IrpNode -> ParentNode -> ObjectNoun] :
                            "NONE",
                        IrpNode -> ParentNode ?
                            IrpNode -> ParentNode -> Object :
                            NULL
                        );

                    dprintf ("    current node %s %08lx pc=%ld\n",
                        NounNames [CurrentNode -> ObjectNoun],
                        CurrentNode -> Object,
                        CurrentNode -> PassedCreate);

                #endif // DEBUG_EXTENSION

                InsertNodeList (&LiveContext -> ObjectNodes, IrpNode);

            } else {

                //
                // Multiple creates are ignored.  Only worry if there's a
                // destruct node around.  If this is the source and a destruct
                // node exists, pop it.
                //
                if (IrpNode -> NodeType == NodeDestruction) {

                    #ifdef DEBUG_EXTENSION
                        dprintf ("Irp %08lx hit with destruct stacked!\n",
                            Irp);
                    #endif // DEBUG_EXTENSION

                    //
                    // BUGBUG: If this is the source of the Irp, we must
                    // pop the destruct node here.
                    //
                } else {

                    #ifdef DEBUG_EXTENSION
                        dprintf ("Irp %08lx receives multiple create!\n",
                            Irp);
                    #endif // DEBUG_EXTENSION 

                    //
                    // If we haven't found the parent node yet, mark it now.
                    // The parent node will be the location that the Irp
                    // is currently at as far as this circuit is concerned.
                    //
                    if (IrpNode -> ParentNode == NULL &&
                        Verb == KSLOGCODE_VERB_RECV) {

                        IrpNode -> ParentNode = CurrentNode;

                        //
                        // Because ks.sys didn't originally log Irp movement
                        // through requestors, we can never determine when
                        // a sourced Irp is sinked back to the requestor.
                        // Istead, we make a very simple rule to deal with
                        // such cases.  If, when we find the parent node,
                        // the Irp node was created on a send, and the parent
                        // node is dead, mark the Irp dead.  This may leave
                        // out some weird shutdown case, but it will catch
                        // the majority of bogus Irps reported live.  Note
                        // that if we don't dump enough to find the parent
                        // node, the Irp gets reported anyway.
                        //
                        if (IrpNode -> Received == FALSE &&
                            CurrentNode -> NodeType == NodeDestruction ||
                            (CurrentNode -> NodeType == NodeCreation &&
                             CurrentNode -> PassedCreate)) 
                            //
                            // The sink was missing from the log.  Sink the
                            // Irp.
                            //
                            IrpNode -> NodeType = NodeDestruction;
                    }
                }
            }
        }
    }

    return FALSE;

}

/*************************************************

    Function:

        DumpLogEntry

    Description:

        Dump a particular log entry

    Arguments:

        Context -
            Context information for the dump (tab depth)

        Entry -
            The log entry to dump

    Return Value:

        Continuation indication (TRUE == stop)

*************************************************/

BOOLEAN
DumpLogEntry (
    IN PVOID Context,
    IN PKSLOG_ENTRY Entry
    )

{

    ULONG TabDepth = (ULONG)Context;

    dprintf ("%s", Tab (TabDepth));

    //
    // Check for special codes first.
    //
    if (Entry -> Code == 0 ||
        Entry -> Code == 1) {

        switch (Entry -> Code) {
            case 0:
                dprintf ("Text ");
                break;

            case 1:
                dprintf ("Start ");
                break;

        }
		
    } else {
        
        ULONG Verb;
        ULONG Noun;

        //
        // Each default entry has a noun and a verb associated with it
        // Display it gramatically as NOUN VERB.
        //
        Verb = (Entry -> Code & 0x00ff0000) >> 16;
        Noun = (Entry -> Code & 0xff000000) >> 24;

        if (Noun >= SIZEOF_ARRAY (NounNames))
            dprintf ("User Defined ");
        else
            dprintf ("%s ", NounNames [Noun]);

        if (Verb >= SIZEOF_ARRAY (VerbNames))
            dprintf ("User Defined ");
        else
            dprintf ("%s ", VerbNames [Verb]);

    }

    dprintf ("[Irp %08lx / Frame %08lx] @ %lx%08lx\n", 
        Entry -> Irp, Entry -> Frame,
        (ULONG)(Entry -> Time >> 32), (ULONG)(Entry -> Time & 0xFFFFFFFF));

    dprintf ("%s[Graph = %08lx, Filter = %08lx, Pin = %08lx, Component = "
        "%08lx\n\n", 
        Tab (TabDepth + 1),
        Entry -> Context.Graph,
        Entry -> Context.Filter,
        Entry -> Context.Pin,
        Entry -> Context.Component
        );

    //
    // Do not stop displaying!
    //
    return FALSE;

}

/*************************************************

    Function:

        IterateLogEntries

    Description:
        
        Iterate a specified number of log entries backwards in the log.  Note
        that this is rather complex for speed reasons.  It also makes the
        assumption that not many log entries have extended information.  If
        this assumption becomes bad at some later point in time, this needs
        to change.

        Further, if 1394 or faster interfaces begin to be used, this can
        go away and the entire log can be pulled across the link and parsed
        debugger side.

    Arguments:

        LogAddress -
            The target address of the logo
    
        LogSize -
            The size of the log in bytes

        Position -
            The position within the log that the next entry will be written
            to.  This may be an empty entry or the oldest entry about to
            be overwritten (or it may be in the middle of an entry depending
            on extended information tacked to entries).

        NumEntries -
            The number of entries to iterate through.  Zero indicates that
            we iterate the entire log.

        Callback -
            The iterator callback

        Context -
            The iterator callback context

    Return Value:

        The number of entries actually iterated.

*************************************************/

ULONG
IterateLogEntries (
    IN DWORD LogAddress,
    IN ULONG LogSize,
    IN ULONG Position,
    IN ULONG NumEntries,
    IN PFNLOG_ITERATOR_CALLBACK Callback,
    IN PVOID Context
    )

{

    ULONG IteratorCount = 0;
    BOOLEAN Complete = FALSE;
    BOOLEAN Wrap = FALSE;

    ULONG StartPosition = Position;

    //
    // BUGBUG:
    //
    // Yes, I don't support more than 1k entries...  No one in the universe
    // should be slapping entries larger than this anywhere.
    //
    UCHAR Buffer [1024];
    ULONG Result;
    PKSLOG_ENTRY LogEntry;

    //
    // Iterate while we're not up to the specified number of entries or
    // we've hit the start of the log.
    //
    while (
        ((!NumEntries) ||
        (NumEntries && (IteratorCount < NumEntries))) &&
        !Complete &&
        !CheckControlC()
        ) {

        ULONG Size;
        ULONG EntryPos;

        //
        // Guess the size of the previous log entry.  This makes the
        // implicit assumption that no information is tacked on the entry.
        // It will correct for the entry if there is such information, but
        // note that this SLLLOOOOWWWW in that case.
        //
        Size = (sizeof (KSLOG_ENTRY) + sizeof (ULONG) + FILE_QUAD_ALIGNMENT) 
            & ~FILE_QUAD_ALIGNMENT;

        if (Size > Position) {
            //
            // We've hit a wrap around.  Attempt to pull the entry from 
            // the other end of the log.
            //
            EntryPos = LogSize - Size;
            Wrap = TRUE;

        } else
            //
            // In the non wrap around case, just subtract off the size.
            //
            EntryPos = Position - Size;

        //
        // If there's a memory read error, bail out of the entire iterator.
        //
        if (!ReadMemory (
            (DWORD)(LogAddress + EntryPos),
            Buffer,
            Size,
            &Result)) 
            return NumEntries;

        LogEntry = (PKSLOG_ENTRY)Buffer;

        //
        // Check for additional information. 
        //
        // BUGBUG: Right now, this does **NOT** handle extended entries!
        //
        if (LogEntry -> Size < sizeof (KSLOG_ENTRY) ||
            LogEntry -> Size != *(PULONG)(Buffer + Size - sizeof (ULONG))) {

            //
            // BUGBUG: EXTENDED INFORMATION ENTRIES....
            //
            // We've either wrapped around to the end of the log or hit
            // an extended information entry.  Right now, I don't deal with
            // extended information entries because no one uses them.  Thus,
            // I assume it's the end of the log.
            //
            return IteratorCount;
        }

        //
        // Otherwise, we can feel safe displaying the information.
        //
        IteratorCount++;
        if (Callback (Context, LogEntry))
            Complete = TRUE;

        Position = EntryPos;

        //
        // If we've gotten back to where we started, we're done.  Also, we
        // need to check for wrapping and below where we started in case
        // the last entries are extended.
        //
        if (Position == StartPosition ||
            (Wrap && Position < StartPosition))
            Complete = TRUE;

    }

    return IteratorCount;

}

/*************************************************

    Function:

        InitLog

    Description:

        Initialize logging information.  Pass back key log pointers. 
        Return FALSE if not debug ks.sys or the log is invalid.

    Arguments:

        LogAddress -
            Log address will be deposited here on return TRUE

        LogSize -
            Log size will be deposited here on return TRUE

        LogPosition -
            Log position pointer will be deposited here on return TRUE

    Return Value:

        TRUE - 
            successful initialization

        FALSE -
            unsuccessful initialization (non debug ks.sys)

*************************************************/

BOOLEAN
InitLog (
    IN PVOID *LogAddress,
    IN PULONG LogSize,
    IN PULONG LogPosition
    )

{

    PVOID TargetLogAddress, TargetPositionAddress, TargetSizeAddress;
    ULONG Result;

    TargetLogAddress = (PVOID)GetExpression("ks!KsLog");
    TargetPositionAddress = (PVOID)GetExpression("ks!KsLogPosition");
    TargetSizeAddress = (PVOID)GetExpression("ks!KsLogSize");

    if (TargetLogAddress == 0 || TargetPositionAddress == 0 ||
        TargetSizeAddress == 0) {

        dprintf ("Cannot access the log; ensure you are running debug"
            " ks.sys!\n");
        return FALSE;
    }

    if (!ReadMemory (
        (DWORD)TargetLogAddress,
        (PVOID)LogAddress,
        sizeof (PVOID),
        &Result)) {

        dprintf ("%08lx: cannot read log!\n", TargetLogAddress);
        return FALSE;
    }

    if (!ReadMemory (
        (DWORD)TargetPositionAddress,
        (PVOID)LogPosition,
        sizeof (ULONG),
        &Result)) {

        dprintf ("%08lx: cannot read target position!\n", 
            TargetPositionAddress);
        return FALSE;
    }

    if (!ReadMemory (
        (DWORD)TargetSizeAddress,
        (PVOID)LogSize,
        sizeof (ULONG),
        &Result)) {

        dprintf ("%08lx: cannot read log size!\n",
            TargetSizeAddress);
        return FALSE;
    }

    return TRUE;

}

/**************************************************************************

    LOG API

**************************************************************************/

/*************************************************

    Function:

        findlive

    Usage:

        !ks.findlive Queue/Requestor/Pin/Filter/Irp [<# of objects>] [<level>]

    Description:

        Find all live objects of the specified type and print information
        about them.

*************************************************/

DECLARE_API(findlive) {

    char objName[256], lvlStr[256], numStr[256], *pLvl, *pNum;
    ULONG NumEntries, DumpLevel;
    ULONG i;
    PVOID LogAddress;
    ULONG TargetPosition, LogSize;
    LIVE_OBJECT_CONTEXT LiveContext;
    
    GlobInit();

    sscanf (args, "%s %s %s", objName, numStr, lvlStr);

    if (numStr && numStr [0]) {
        pNum = numStr; while (*pNum && !isdigit (*pNum)) pNum++;

        #ifdef DEBUG_EXTENSION
            dprintf ("pNum = [%s]\n", pNum);
        #endif // DEBUG_EXTENSION

        if (*pNum) {
            sscanf (pNum, "%lx", &NumEntries);
        } else {
            NumEntries = 0;
        }
    } else {
        NumEntries = 0;
    }

    if (lvlStr && lvlStr [0]) {
        pLvl = lvlStr; while (*pLvl && !isdigit (*pLvl)) pLvl++;

        #ifdef DEBUG_EXTENSION
            dprintf ("pLvl = [%s]\n", pLvl);
        #endif // DEBUG_EXTENSION

        if (*pLvl) {
            sscanf (pLvl, "%lx", &DumpLevel);
        } else {
            DumpLevel = 1;
        }
    } else {
        DumpLevel = 1;
    }

    for (i = 0; i < SIZEOF_ARRAY (NounNames); i++) 
        if (!ustrcmp (NounNames [i], objName))
            break;

    if (i >= SIZEOF_ARRAY (NounNames)) {
        dprintf ("Usage: !ks.findlive Queue|Requestor|Pin|Filter [<# entries>]"
            "\n\n");
        return;
    }

    LiveContext.ObjectNoun = i;
    LiveContext.DumpLevel = DumpLevel;
    LiveContext.PreviousObject = NULL;
    LiveContext.PreviousVerb = 0;
    InitializeListHead (&LiveContext.ObjectNodes);

    #ifndef WHISTLER
        if (LiveContext.ObjectNoun == NOUN_IDX_FILTER) {
            dprintf ("******************** READ THIS NOW ********************\n");
            dprintf ("ks.sys prior to Whistler will not log filter creation and\n");
            dprintf ("destruction.  This means that any filters reported are potentially\n");
            dprintf ("bogus.  !pool the filter to check.\n");
            dprintf ("******************** READ THIS NOW ********************\n\n");
        }
        if (LiveContext.ObjectNoun == NOUN_IDX_IRP) {
            dprintf ("******************** READ THIS NOW ********************\n");
            dprintf ("ks.sys prior to Whistler will not log Irp movement in and out\n");
            dprintf ("of requestors.  This leads the Irp dump to believe such Irps\n");
            dprintf ("are still live (meaning some Irps may be bogus!).  Check the\n");
            dprintf ("irps with !irp and/or !pool.\n");
            dprintf ("******************** READ THIS NOW ********************\n\n");
        }
    #endif // WHISTLER

    if (InitLog (&LogAddress, &LogSize, &TargetPosition)) {
        IterateLogEntries (
            (DWORD)LogAddress,
            LogSize,
            TargetPosition,
            NumEntries,
            FindLiveObject,
            &LiveContext
            );

        dprintf ("%sLive %s Objects:\n", Tab (INITIAL_TAB), NounNames [i]);
        LiveContext.TabDepth = INITIAL_TAB + 1;

        //
        // The above has only built the node list.  We now need to display
        // information that's on the node list and clean up memory used by
        // it.
        //
        if (i = DisplayAndCleanLiveObjects (&LiveContext)) 
            dprintf ("\n%s%ld total objects found.\n", 
                Tab (LiveContext.TabDepth),
                i);
        else
            dprintf ("\n%sNo such objects found.\n", 
                Tab (LiveContext.TabDepth));
    }

}

/*************************************************

    Function:

        dumplog

    Usage:

        !ks.dumplog [<# of entries>]

*************************************************/

DECLARE_API(dumplog) {

    ULONG NumEntries;
    PVOID LogAddress;
    ULONG TargetPosition, LogSize;
    ULONG Result;

    GlobInit();

    NumEntries = GetExpression (args);

    if (InitLog (&LogAddress, &LogSize, &TargetPosition)) 
        IterateLogEntries (
            (DWORD)LogAddress,
            LogSize,
            TargetPosition,
            NumEntries,
            DumpLogEntry,
            (PVOID)INITIAL_TAB
            );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\ksfilter\ks\test\memtest.c ===
/*++

    Copyright (C) Microsoft Corporation, 1998 - 1998

Module Name:

    memtest.c

Abstract:

    This module contains the helper functions for memory testing.

--*/

#include <ksp.h>

#define KSI_ALLOC
#define ALLOCATION_FAILURE_RATE   6

#undef ExAllocatePool
#undef ExAllocatePoolWithTag
#undef ExAllocatePoolWithQuota
#undef ExAllocatePoolWithQuotaTag

ULONG KsiFailureType = KS_ALLOCATION_PASS_THROUGH;
ULONG KsiTagValue;
ULONG KsiFailureCountRate = ALLOCATION_FAILURE_RATE;
ULONG KsiFailureCountDown = ALLOCATION_FAILURE_RATE;


KSDDKAPI
VOID
NTAPI
KsSetAllocationParameters(
    IN ULONG FailureType,
    IN ULONG TagValue,
    IN ULONG FailureCountRate
    )
{
    KsiFailureType = FailureType;
    KsiTagValue = TagValue;
    KsiFailureCountRate = FailureCountRate;
    KsiFailureCountDown = FailureCountRate;
}


PVOID
KsiAllocatePool(
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes) 
{
    switch (KsiFailureType) {
    
    case KS_ALLOCATION_PASS_THROUGH:
    case KS_ALLOCATION_FAIL_ON_TAG:
        break;
    case KS_ALLOCATION_FAIL_ALWAYS:
        DbgPrint("KS: Forced ExAllocatePool failure\n");
        return NULL;
    case KS_ALLOCATION_FAIL_PERIODICALLY:
        
        if ( KsiFailureCountDown-- == 0 ) {
    
            DbgPrint("KS: Forced ExAllocatePool failure on counter 0\n");
            KsiFailureCountDown = KsiFailureCountRate;
            return NULL;
        }
        break;
    default:
        DbgPrint("KS: Invalid Allocation failure type: %lx", KsiFailureType);
        DbgBreakPoint();
    }       

    return ExAllocatePool(PoolType, NumberOfBytes);
}


PVOID
KsiAllocatePoolWithTag(
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes,
    IN ULONG Tag)
{
    switch (KsiFailureType) {
    
    case KS_ALLOCATION_PASS_THROUGH:
        break;
    case KS_ALLOCATION_FAIL_ALWAYS:
        DbgPrint("KS: Forced ExAllocatePoolTag failure\n");
        return NULL;
    case KS_ALLOCATION_FAIL_ON_TAG:
        if (Tag == KsiTagValue) {
            DbgPrint("KS: Forced ExAllocatePoolWithTag failure on tag %c%c%c%c\n",
                     (CHAR)(Tag & 0xFF),
                     (CHAR)((Tag >> 8) & 0xFF), 
                     (CHAR)((Tag >> 16) & 0xFF), 
                     (CHAR)((Tag >> 24) & 0xFF));
            return NULL;
        }
        break;
    case KS_ALLOCATION_FAIL_PERIODICALLY:
        
        if ( KsiFailureCountDown-- == 0 ) {
    
            DbgPrint("KS: Forced ExAllocatePoolWithTag failure on counter 0\n");
            KsiFailureCountDown = KsiFailureCountRate;
            return NULL;
        }
        break;
    default:
        DbgPrint("KS: Invalid Allocation failure type: %lx", KsiFailureType);
        DbgBreakPoint();
    }

    return ExAllocatePoolWithTag(PoolType, NumberOfBytes, Tag);
}


PVOID
KsiAllocatePoolWithQuota(
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes)
{
    switch (KsiFailureType) {
    
    case KS_ALLOCATION_PASS_THROUGH:
    case KS_ALLOCATION_FAIL_ON_TAG:
        break;
    case KS_ALLOCATION_FAIL_ALWAYS:
        DbgPrint("KS: Forced ExAllocatePoolWithQuota failure\n");
        ExRaiseStatus(STATUS_INSUFFICIENT_RESOURCES);
        break;
    case KS_ALLOCATION_FAIL_PERIODICALLY:
        
        if ( KsiFailureCountDown-- == 0 ) {
    
            DbgPrint("KS: Forced ExAllocatePoolWithQuota failure on counter 0\n");
            KsiFailureCountDown = KsiFailureCountRate;
            ExRaiseStatus(STATUS_INSUFFICIENT_RESOURCES);
        }
        break;
    default:
        DbgPrint("KS: Invalid Allocation failure type: %lx", KsiFailureType);
        DbgBreakPoint();
    }

    return ExAllocatePoolWithQuota(PoolType, NumberOfBytes);
}


PVOID
KsiAllocatePoolWithQuotaTag(
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes,
    IN ULONG Tag) 
{
    switch (KsiFailureType) {
    
    case KS_ALLOCATION_PASS_THROUGH:
        break;
    case KS_ALLOCATION_FAIL_ALWAYS:
        DbgPrint("KS: Forced ExAllocatePoolWithQuotaTag failure\n");
        ExRaiseStatus(STATUS_INSUFFICIENT_RESOURCES);
        break;
    case KS_ALLOCATION_FAIL_ON_TAG:
        if (Tag == KsiTagValue) {
            DbgPrint("KS: Forced ExAllocatePoolWithQuotaTag failure on tag %c%c%c%c\n",
                     (CHAR)(Tag & 0xFF),
                     (CHAR)((Tag >> 8) & 0xFF), 
                     (CHAR)((Tag >> 16) & 0xFF), 
                     (CHAR)((Tag >> 24) & 0xFF));
            ExRaiseStatus(STATUS_INSUFFICIENT_RESOURCES);
        }
        break;
    case KS_ALLOCATION_FAIL_PERIODICALLY:
        
        if ( KsiFailureCountDown-- == 0 ) {
    
            DbgPrint("KS: Forced ExAllocatePoolWithQuotaTag failure on counter 0\n");
            KsiFailureCountDown = KsiFailureCountRate;
            ExRaiseStatus(STATUS_INSUFFICIENT_RESOURCES);
        }
        break;
    default:
        DbgPrint("KS: Invalid Allocation failure type: %lx", KsiFailureType);
        DbgBreakPoint();
    }

    return ExAllocatePoolWithQuotaTag(PoolType, NumberOfBytes, Tag);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\ksfilter\ks\kdexts\strlib.c ===
/**************************************************************************

    This is the string library and guid library for the AVStream debug
    extension.

    NOTES:

        - This is hardly encompassing...  The few items I have placed here
          are common properties directly out of ks.h (via some vi macros).
         
        - If this turns out to be useful more than I think, a perl script
          can parse ksmedia.h for properties, methods, events, etc...

        - Dump handlers : don't have them...  don't use them...  consider
          this for future expansion if some items get hard to read...  You
          can add a handler which will dump the associated information
          as appropriate.

**************************************************************************/

#include "kskdx.h"
#include "ksmedia.h"

typedef struct _AUTOMATION_MAPPING {

    GUID Guid;
    char *Name;

    ULONG ItemMappingsCount;
    char **ItemMappingNames;

    AUTOMATION_DUMP_HANDLER *ItemDumpers;

} AUTOMATION_MAPPING, *PAUTOMATION_MAPPING;

char *PropertySetGeneralMappings[] = {
    "KSPROPERTY_GENERAL_COMPONENTID"
};

char *PropertySetMediaSeekingMappings[] = {
    "KSPROPERTY_MEDIASEEKING_CAPABILITIES",
    "KSPROPERTY_MEDIASEEKING_FORMATS",
    "KSPROPERTY_MEDIASEEKING_TIMEFORMAT",
    "KSPROPERTY_MEDIASEEKING_POSITION",
    "KSPROPERTY_MEDIASEEKING_STOPPOSITION",
    "KSPROPERTY_MEDIASEEKING_POSITIONS",
    "KSPROPERTY_MEDIASEEKING_DURATION",
    "KSPROPERTY_MEDIASEEKING_AVAILABLE",
    "KSPROPERTY_MEDIASEEKING_PREROLL",
    "KSPROPERTY_MEDIASEEKING_CONVERTTIMEFORMAT"
};

char *PropertySetTopologyMappings[] = {
    "KSPROPERTY_TOPOLOGY_CATEGORIES",
    "KSPROPERTY_TOPOLOGY_NODES",
    "KSPROPERTY_TOPOLOGY_CONNECTIONS",
    "KSPROPERTY_TOPOLOGY_NAME"
};

char *PropertySetGraphManagerMappings[] = {
    "KSPROPERTY_GM_GRAPHMANAGER", 
    "KSPROPERTY_GM_TIMESTAMP_CLOCK", 
    "KSPROPERTY_GM_RATEMATCH", 
    "KSPROPERTY_GM_RENDER_CLOCK"
};

char *PropertySetPinMappings[] = {
    "KSPROPERTY_PIN_CINSTANCES",
    "KSPROPERTY_PIN_CTYPES",
    "KSPROPERTY_PIN_DATAFLOW",
    "KSPROPERTY_PIN_DATARANGES",
    "KSPROPERTY_PIN_DATAINTERSECTION",
    "KSPROPERTY_PIN_INTERFACES",
    "KSPROPERTY_PIN_MEDIUMS",
    "KSPROPERTY_PIN_COMMUNICATION",
    "KSPROPERTY_PIN_GLOBALCINSTANCES",
    "KSPROPERTY_PIN_NECESSARYINSTANCES",
    "KSPROPERTY_PIN_PHYSICALCONNECTION",
    "KSPROPERTY_PIN_CATEGORY",
    "KSPROPERTY_PIN_NAME",
    "KSPROPERTY_PIN_CONSTRAINEDDATARANGES",
    "KSPROPERTY_PIN_PROPOSEDATAFORMAT"
};

char *PropertySetQualityMappings[] = {
    "KSPROPERTY_QUALITY_REPORT",
    "KSPROPERTY_QUALITY_ERROR"
};

char *PropertySetConnectionMappings[] = {
    "KSPROPERTY_CONNECTION_STATE",
    "KSPROPERTY_CONNECTION_PRIORITY",
    "KSPROPERTY_CONNECTION_DATAFORMAT",
    "KSPROPERTY_CONNECTION_ALLOCATORFRAMING",
    "KSPROPERTY_CONNECTION_PROPOSEDATAFORMAT",
    "KSPROPERTY_CONNECTION_ACQUIREORDERING",
    "KSPROPERTY_CONNECTION_ALLOCATORFRAMING_EX",
    "KSPROPERTY_CONNECTION_STARTAT"
};

char *PropertySetStreamAllocatorMappings[] = {
    "KSPROPERTY_STREAMALLOCATOR_FUNCTIONTABLE",
    "KSPROPERTY_STREAMALLOCATOR_STATUS"
};

char *PropertySetStreamInterfaceMappings[] = {
    "KSPROPERTY_STREAMINTERFACE_HEADERSIZE"
};

char *PropertySetStreamMappings[] = {
    "KSPROPERTY_STREAM_ALLOCATOR",
    "KSPROPERTY_STREAM_QUALITY",
    "KSPROPERTY_STREAM_DEGRADATION",
    "KSPROPERTY_STREAM_MASTERCLOCK",
    "KSPROPERTY_STREAM_TIMEFORMAT",
    "KSPROPERTY_STREAM_PRESENTATIONTIME",
    "KSPROPERTY_STREAM_PRESENTATIONEXTENT",
    "KSPROPERTY_STREAM_FRAMETIME",
    "KSPROPERTY_STREAM_RATECAPABILITY",
    "KSPROPERTY_STREAM_RATE",
    "KSPROPERTY_STREAM_PIPE_ID"
};

char *PropertySetClockMappings[] = {
    "KSPROPERTY_CLOCK_TIME",
    "KSPROPERTY_CLOCK_PHYSICALTIME",
    "KSPROPERTY_CLOCK_CORRELATEDTIME",
    "KSPROPERTY_CLOCK_CORRELATEDPHYSICALTIME",
    "KSPROPERTY_CLOCK_RESOLUTION",
    "KSPROPERTY_CLOCK_STATE",
    "KSPROPERTY_CLOCK_FUNCTIONTABLE"
};

AUTOMATION_MAPPING PropertyMappings[] = {

    // KSPROPSETID_General
    {
        STATIC_KSPROPSETID_General,
        "KSPROPSETID_General",
        SIZEOF_ARRAY (PropertySetGeneralMappings),
        PropertySetGeneralMappings,
        NULL
    },

    // KSPROPSETID_MediaSeeking
    {
        STATIC_KSPROPSETID_MediaSeeking,
        "KSPROPSETID_MediaSeeking",
        SIZEOF_ARRAY (PropertySetMediaSeekingMappings),
        PropertySetMediaSeekingMappings,
        NULL
    },

    // KSPROPSETID_Topology
    {
        STATIC_KSPROPSETID_Topology,
        "KSPROPSETID_Topology",
        SIZEOF_ARRAY (PropertySetTopologyMappings),
        PropertySetTopologyMappings,
        NULL
    },

    // KSPROPSETID_GM
    {
        STATIC_KSPROPSETID_GM,
        "KSPROPSETID_GM (graph management)",
        SIZEOF_ARRAY (PropertySetGraphManagerMappings),
        PropertySetGraphManagerMappings,
        NULL
    },

    // KSPROPSETID_Pin
    {
        STATIC_KSPROPSETID_Pin,
        "KSPROPSETID_Pin",
        SIZEOF_ARRAY (PropertySetPinMappings),
        PropertySetPinMappings,
        NULL
    },

    // KSPROPSETID_Quality
    {
        STATIC_KSPROPSETID_Quality,
        "KSPROPSETID_Quality",
        SIZEOF_ARRAY (PropertySetQualityMappings),
        PropertySetQualityMappings,
        NULL
    },

    // KSPROPSETID_Connection
    {
        STATIC_KSPROPSETID_Connection,
        "KSPROPSETID_Connection",
        SIZEOF_ARRAY (PropertySetConnectionMappings),
        PropertySetConnectionMappings,
        NULL
    },

    // KSPROPSETID_StreamAllocator
    {
        STATIC_KSPROPSETID_StreamAllocator,
        "KSPROPSETID_StreamAllocator",
        SIZEOF_ARRAY (PropertySetStreamAllocatorMappings),
        PropertySetStreamAllocatorMappings,
        NULL
    },

    // KSPROPSETID_StreamInterface
    {
        STATIC_KSPROPSETID_StreamInterface,
        "KSPROPSETID_StreamInterface",
        SIZEOF_ARRAY (PropertySetStreamInterfaceMappings),
        PropertySetStreamInterfaceMappings,
        NULL
    },

    // KSPROPSETID_Stream
    {
        STATIC_KSPROPSETID_Stream,
        "KSPROPSETID_Stream",
        SIZEOF_ARRAY (PropertySetStreamMappings),
        PropertySetStreamMappings,
        NULL
    },

    // KSPROPSETID_Clock
    {
        STATIC_KSPROPSETID_Clock,
        "KSPROPSETID_Clock",
        SIZEOF_ARRAY (PropertySetClockMappings),
        PropertySetClockMappings,
        NULL
    }
};

typedef struct _AUTOMATION_IDENT_TABLE {

    ULONG ItemsCount;
    PAUTOMATION_MAPPING Mapping;

    // ...

} AUTOMATION_IDENT_TABLE, *PAUTOMATION_IDENT_TABLE;

AUTOMATION_IDENT_TABLE AutomationIdentTables[] = {
    
    {
        SIZEOF_ARRAY (PropertyMappings),
        PropertyMappings
    }

};

/**************************************************************************

    Functions which use string information

**************************************************************************/

/*************************************************

    Function:

        DisplayNamedAutomationSet

    Description:

        Display an automation set guid by name.  The string inpassed will
        be used as format string.  It must contain one %s for string
        substitution (and no other %'s)

    Arguments:

        Set -
            The set guid to display a name for

        String -
            Format string

*************************************************/

BOOLEAN
DisplayNamedAutomationSet (
    IN GUID *Set,
    IN char *String
    )

{

    ULONG curTable, curItem;

    for (curTable = 0; curTable < SIZEOF_ARRAY (AutomationIdentTables);
        curTable++) {

        for (curItem = 0; curItem < AutomationIdentTables [curTable].
            ItemsCount; curItem++) {

            //
            // See if we have a set GUID match...
            //
            if (RtlCompareMemory (Set, &(AutomationIdentTables [curTable].
                Mapping[curItem].Guid), sizeof (GUID)) == sizeof (GUID)) {

                dprintf (String, AutomationIdentTables [curTable].
                    Mapping[curItem].Name);

                return TRUE;

            }
        }
    }

    return FALSE;
}

/*************************************************

    Function:

        DisplayNamedAutomationId

    Description:

        Display an automation id by name. 

    Arguments:

        Set -
            The set guid

        Item -
            The item in the set

        String - 
            The format string as in DisplayNamedAutomationSet

        DumpHandler -
            Optional pointer into which will be deposited any dump handler
            for the item in question.

*************************************************/

BOOLEAN
DisplayNamedAutomationId (
    IN GUID *Set,
    IN ULONG Id,
    IN char *String,
    IN OUT AUTOMATION_DUMP_HANDLER *DumpHandler OPTIONAL
    )

{

    ULONG curTable, curItem;

    if (DumpHandler)
        *DumpHandler = NULL;

    for (curTable = 0; curTable < SIZEOF_ARRAY (AutomationIdentTables);
        curTable++) {

        for (curItem = 0; curItem < AutomationIdentTables [curTable].
            ItemsCount; curItem++) {

            //
            // See if we have a set GUID match...
            //
            if (RtlCompareMemory (Set, &(AutomationIdentTables [curTable].
                Mapping[curItem].Guid), sizeof (GUID)) == sizeof (GUID)) {

                if (AutomationIdentTables [curTable].
                    Mapping[curItem].ItemMappingsCount > Id) {

                    dprintf (String, AutomationIdentTables [curTable].
                        Mapping[curItem].ItemMappingNames [Id]);

                    //
                    // Return the dumper information.
                    //
                    if (AutomationIdentTables [curTable].Mapping[curItem].
                        ItemDumpers && DumpHandler) {

                        *DumpHandler =
                            AutomationIdentTables [curTable].Mapping[curItem].
                                ItemDumpers[Id];

                    }

                }
                        

                return TRUE;

            }
        }
    }

    return FALSE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\ksfilter\ksdrmhlp\ksdrmhlp.c ===
#include <KsDrmHlp.h>

NTSTATUS 
KsPropertyHandleDrmSetContentId(
    IN PIRP Irp, 
    IN PFNKSHANDLERDRMSETCONTENTID pDrmSetContentId);

#pragma alloc_text(PAGE, KsPropertyHandleDrmSetContentId)

NTSTATUS 
KsPropertyHandleDrmSetContentId(
    IN PIRP Irp, 
    IN PFNKSHANDLERDRMSETCONTENTID pDrmSetContentId)
/*++

Routine Description:

    Handles KS property requests.  Responds only to 
    KSPROPERTY_DRMAUDIOSTREAM_ContentId with KSPROPERTY_TYPE_SET flag by
    calling the supplied PFNKSHANDLERDRMSETCONTENTID handler.  This function
    may only be called at PASSIVE_LEVEL.
    
    This is a stripped down version of KS's generic KsPropertyHandler.  When
    invoked on properties other than KSPROPERTY_DRMAUDIOSTREAM_ContentId
    or with invalid buffer sizes it attempts to preserve the same error results
    as KsPropertyHandler.

Arguments:

    Irp -
        Contains the IRP with the property request being handled.
        
    pDrmSetContentId -
        The handler for KSPROPERTY_DRMAUDIOSTREAM_ContentId
        
Return Value:

    Returns STATUS_SUCCESS, else an error specific to the property being
    handled. Always sets the IO_STATUS_BLOCK.Information field of the
    PIRP.IoStatus element within the IRP, either through setting it to zero
    because of an internal error, or through a property handler setting it.
    It does not set the IO_STATUS_BLOCK.Status field, nor complete the IRP,
    but the called handler should.

--*/
{
    PIO_STACK_LOCATION IrpStack;
    ULONG InputBufferLength;
    ULONG OutputBufferLength;
    ULONG AlignedBufferLength;
    PVOID UserBuffer;
    PKSPROPERTY Property;
    ULONG Flags;

    PAGED_CODE();
    //
    // Determine the offsets to both the Property and UserBuffer parameters based
    // on the lengths of the DeviceIoControl parameters. A single allocation is
    // used to buffer both parameters. The UserBuffer (or results on a support
    // query) is stored first, and the Property is stored second, on
    // FILE_QUAD_ALIGNMENT.
    //
    IrpStack = IoGetCurrentIrpStackLocation(Irp);
    InputBufferLength = IrpStack->Parameters.DeviceIoControl.InputBufferLength;
    OutputBufferLength = IrpStack->Parameters.DeviceIoControl.OutputBufferLength;
    AlignedBufferLength = (OutputBufferLength + FILE_QUAD_ALIGNMENT) & ~FILE_QUAD_ALIGNMENT;
    //
    // Determine if the parameters have already been buffered by a previous
    // call to this function.
    //
    if (!Irp->AssociatedIrp.SystemBuffer) {
        //
        // Initially just check for the minimal property parameter length. The
        // actual minimal length will be validated when the property item is found.
        // Also ensure that the output and input buffer lengths are not set so
        // large as to overflow when aligned or added.
        //
        if ((InputBufferLength < sizeof(*Property)) || (AlignedBufferLength < OutputBufferLength) || (AlignedBufferLength + InputBufferLength < AlignedBufferLength)) {
            return STATUS_INVALID_BUFFER_SIZE;
        }
        try {
            //
            // Validate the pointers if the client is not trusted.
            //
            if (Irp->RequestorMode != KernelMode) {
                ProbeForRead(IrpStack->Parameters.DeviceIoControl.Type3InputBuffer, InputBufferLength, sizeof(BYTE));
            }
            //
            // Capture flags first so that they can be used to determine allocation.
            //
            Flags = ((PKSPROPERTY)IrpStack->Parameters.DeviceIoControl.Type3InputBuffer)->Flags;
            
            //
            // Use pool memory for system buffer
            //
            Irp->AssociatedIrp.SystemBuffer = ExAllocatePoolWithQuotaTag(NonPagedPool, AlignedBufferLength + InputBufferLength, 'ppSK');
            if ( Irp->AssociatedIrp.SystemBuffer ) {
                Irp->Flags |= (IRP_BUFFERED_IO | IRP_DEALLOCATE_BUFFER);
            
                //
                // Copy the Property parameter.
                //
                RtlCopyMemory((PUCHAR)Irp->AssociatedIrp.SystemBuffer + AlignedBufferLength, IrpStack->Parameters.DeviceIoControl.Type3InputBuffer, InputBufferLength);
            
                //
                // Rewrite the previously captured flags.
                //
                ((PKSPROPERTY)((PUCHAR)Irp->AssociatedIrp.SystemBuffer + AlignedBufferLength))->Flags = Flags;
            
                //
                // Validate the request flags. At the same time set up the IRP flags
                // for an input operation if there is an input buffer available so
                // that Irp completion will copy the data to the client's original
                // buffer.
                //
                if (KSPROPERTY_TYPE_SET == Flags) {
                    //
                    // Thse are all output operations, and must be probed
                    // when the client is not trusted. All data passed is
                    // copied to the system buffer.
                    //
                    if (OutputBufferLength) {
                        if (Irp->RequestorMode != KernelMode) {
                            ProbeForRead(Irp->UserBuffer, OutputBufferLength, sizeof(BYTE));
                        }
                        RtlCopyMemory(Irp->AssociatedIrp.SystemBuffer, Irp->UserBuffer, OutputBufferLength);
                    }
                } else {
                    // We don't handle this.  Ensure this is caught belowl!!!
                }
            }

        } except (EXCEPTION_EXECUTE_HANDLER) {
            if ( Irp->AssociatedIrp.SystemBuffer ) {
                ExFreePool(Irp->AssociatedIrp.SystemBuffer);
            }
            return GetExceptionCode();
        }
        if ( !Irp->AssociatedIrp.SystemBuffer ) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }
    }
    
    //
    // If there are property parameters, retrieve a pointer to the buffered copy
    // of it. This is the first portion of the SystemBuffer.
    //
    if (OutputBufferLength) {
        UserBuffer = Irp->AssociatedIrp.SystemBuffer;
    } else {
        UserBuffer = NULL;
    }

    Property = (PKSPROPERTY)((PUCHAR)Irp->AssociatedIrp.SystemBuffer + AlignedBufferLength);
    Flags = Property->Flags;
    
    if (!IsEqualGUIDAligned(&Property->Set,&KSPROPSETID_DrmAudioStream)) {
        return STATUS_PROPSET_NOT_FOUND;
    }
    
    if (Property->Id != KSPROPERTY_DRMAUDIOSTREAM_CONTENTID) {
        return STATUS_NOT_FOUND;
    }

    if (Irp->RequestorMode != KernelMode) {
        return STATUS_INVALID_DEVICE_REQUEST;
    }
    
    if (KSPROPERTY_TYPE_SET != Flags) {
        return STATUS_NOT_IMPLEMENTED;
    }

    if ((InputBufferLength < sizeof(KSP_DRMAUDIOSTREAM_CONTENTID)) ||
        (OutputBufferLength < sizeof(KSDRMAUDIOSTREAM_CONTENTID)))
    {
        return STATUS_BUFFER_TOO_SMALL;
    }
    
    return pDrmSetContentId(Irp, (PKSP_DRMAUDIOSTREAM_CONTENTID)Property, (PKSDRMAUDIOSTREAM_CONTENTID)UserBuffer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\ksfilter\mskssrv\mskssrv.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1997

Module Name:

    mskssrv.h

Abstract:

    Internal header file for filter.

--*/

#include <wdm.h>
#include <windef.h>

#include <memory.h>
#include <stddef.h>
#include <stdio.h>
#include <limits.h>
#include <stdlib.h>
#include <tchar.h>
#include <conio.h>

#include <ks.h>
#include <swenum.h>
#include <ksi.h>
#include <ksdebug.h>

#if (DBG)
#define STR_MODULENAME  "mskssrv: "
#endif // DBG

NTSTATUS
PnpAddDevice(
    IN PDRIVER_OBJECT   DriverObject,
    IN PDEVICE_OBJECT   PhysicalDeviceObject
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\ksfilter\mskssrv\mskssrv.c ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    mskssrv.c

Abstract:

    Kernel Server Driver

--*/

#include "mskssrv.h"

typedef struct {
    KSDEVICE_HEADER     Header;
} DEVICE_INSTANCE, *PDEVICE_INSTANCE;

typedef struct {
    KSOBJECT_HEADER     Header;
    ULONG               Reserved;
} INSTANCE, *PINSTANCE;

#define FCC(ch4) ((((DWORD)(ch4) & 0xFF) << 24) |     \
                  (((DWORD)(ch4) & 0xFF00) << 8) |    \
                  (((DWORD)(ch4) & 0xFF0000) >> 8) |  \
                  (((DWORD)(ch4) & 0xFF000000) >> 24))

// OK to have zero instances of pin In this case you will have to
// Create a pin to have even one instance
#define REG_PIN_B_ZERO 0x1

// The filter renders this input
#define REG_PIN_B_RENDERER 0x2

// OK to create many instance of  pin
#define REG_PIN_B_MANY 0x4

// This is an Output pin
#define REG_PIN_B_OUTPUT 0x8

typedef struct {
    ULONG   Version;
    ULONG   Merit;
    ULONG   Pins;
    ULONG   Reserved;
} REGFILTER_REG;

typedef struct {
    ULONG   Signature;
    ULONG   Flags;
    ULONG   PossibleInstances;
    ULONG   MediaTypes;
    ULONG   MediumTypes;
    ULONG   Category;
} REGFILTERPINS_REG2;

typedef struct {
    ULONG   Signature;
    ULONG   Reserved;
    ULONG   MajorType;
    ULONG   MinorType;
} REGPINTYPES_REG2;

NTSTATUS
PropertySrv(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    IN PBYTE Data
    );
NTSTATUS
SrvDispatchCreate(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );
NTSTATUS
SrvDispatchIoControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );
NTSTATUS
SrvDispatchClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

#ifdef ALLOC_PRAGMA
NTSTATUS
GetFilterPinCount(
    IN PFILE_OBJECT FilterObject,
    OUT PULONG PinCount
    );
NTSTATUS
GetPinTypes(
    IN PFILE_OBJECT FilterObject,
    IN ULONG Pin,
    IN ULONG Id,
    OUT PULONG Types
    );
NTSTATUS
GetPinFlags(
    IN PFILE_OBJECT FilterObject,
    IN ULONG Pin,
    OUT PULONG Flags
    );
NTSTATUS
GetPinInstances(
    IN PFILE_OBJECT FilterObject,
    IN ULONG Pin,
    OUT PULONG PossibleInstances
    );
NTSTATUS
GetPinTypeList(
    IN PFILE_OBJECT FilterObject,
    IN ULONG Pin,
    IN ULONG Id,
    OUT PKSMULTIPLE_ITEM* MultipleItem
    );
NTSTATUS
GetPinCategory(
    IN PFILE_OBJECT FilterObject,
    IN ULONG Pin,
    OUT GUID* Category
    );
VOID
InsertCacheItem(
    IN PVOID Item,
    IN ULONG ItemSize,
    IN PVOID OffsetBase,
    IN PVOID CacheBase,
    IN OUT PULONG ItemsCached,
    OUT PULONG ItemOffset
    );
VOID
ExtractMediaTypes(
    IN PKSMULTIPLE_ITEM MediaTypeList,
    IN ULONG MediaType,
    OUT GUID* MajorType,
    OUT GUID* MinorType
    );
NTSTATUS
BuildFilterData(
    IN PFILE_OBJECT FilterObject,
    IN ULONG Merit,
    OUT PUCHAR* FilterData,
    OUT ULONG* FilterDataLength
    );
#pragma alloc_text(PAGE, PnpAddDevice)
#pragma alloc_text(PAGE, GetFilterPinCount)
#pragma alloc_text(PAGE, GetPinTypes)
#pragma alloc_text(PAGE, GetPinFlags)
#pragma alloc_text(PAGE, GetPinInstances)
#pragma alloc_text(PAGE, GetPinTypeList)
#pragma alloc_text(PAGE, GetPinCategory)
#pragma alloc_text(PAGE, InsertCacheItem)
#pragma alloc_text(PAGE, ExtractMediaTypes)
#pragma alloc_text(PAGE, BuildFilterData)
#pragma alloc_text(PAGE, PropertySrv)
#pragma alloc_text(PAGE, SrvDispatchCreate)
#pragma alloc_text(PAGE, SrvDispatchIoControl)
#pragma alloc_text(PAGE, SrvDispatchClose)
#endif // ALLOC_PRAGMA

static const WCHAR DosPrefix[] = L"\\DosDevices";
static const WCHAR DeviceTypeName[] = KSSTRING_Server;

static const DEFINE_KSCREATE_DISPATCH_TABLE(CreateItems) {
    DEFINE_KSCREATE_ITEM(SrvDispatchCreate, DeviceTypeName, 0)
};

static DEFINE_KSDISPATCH_TABLE(
    SrvDispatchTable,
    SrvDispatchIoControl,
    NULL,
    NULL,
    NULL,
    SrvDispatchClose,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL);

static DEFINE_KSPROPERTY_TABLE(SrvPropertyItems) {
    DEFINE_KSPROPERTY_ITEM_SERVICE_BUILDCACHE(PropertySrv),
    DEFINE_KSPROPERTY_ITEM_SERVICE_MERIT(PropertySrv)
};

static DEFINE_KSPROPERTY_SET_TABLE(SrvPropertySets) {
    DEFINE_KSPROPERTY_SET(
        &KSPROPSETID_Service,
        SIZEOF_ARRAY(SrvPropertyItems),
        SrvPropertyItems,
        0, NULL
    )
};


NTSTATUS
PnpAddDevice(
    IN PDRIVER_OBJECT   DriverObject,
    IN PDEVICE_OBJECT   PhysicalDeviceObject
    )
/*++

Routine Description:

    When a new device is detected, PnP calls this entry point with the
    new PhysicalDeviceObject (PDO). The driver creates an associated 
    FunctionalDeviceObject (FDO).

Arguments:

    DriverObject -
        Pointer to the driver object.

    PhysicalDeviceObject -
        Pointer to the new physical device object.

Return Values:

    STATUS_SUCCESS or an appropriate error condition.

--*/
{
    PDEVICE_OBJECT      FunctionalDeviceObject;
    PDEVICE_INSTANCE    DeviceInstance;
    NTSTATUS            Status;

    Status = IoCreateDevice(
        DriverObject,
        sizeof(DEVICE_INSTANCE),
        NULL,                           // FDOs are unnamed
        FILE_DEVICE_KS,
        0,
        FALSE,
        &FunctionalDeviceObject);
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    DeviceInstance = (PDEVICE_INSTANCE)FunctionalDeviceObject->DeviceExtension;
    //
    // This object uses KS to perform access through the DeviceCreateItems.
    //
    Status = KsAllocateDeviceHeader(
        &DeviceInstance->Header,
        SIZEOF_ARRAY(CreateItems),
        (PKSOBJECT_CREATE_ITEM)CreateItems);
    if (NT_SUCCESS(Status)) {
        KsSetDevicePnpAndBaseObject(
            DeviceInstance->Header,
            IoAttachDeviceToDeviceStack(
                FunctionalDeviceObject, 
                PhysicalDeviceObject),
            FunctionalDeviceObject );
        FunctionalDeviceObject->Flags |= KsQueryDevicePnpObject(DeviceInstance->Header)->Flags & DO_POWER_PAGABLE;
        FunctionalDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;
        return STATUS_SUCCESS;
    }
    IoDeleteDevice(FunctionalDeviceObject);
    return Status;
}


NTSTATUS
GetFilterPinCount(
    IN PFILE_OBJECT FilterObject,
    OUT PULONG PinCount
    )
/*++

Routine Description:

    Queries the count of pin factories provided by the specified filter.

Arguments:

    FilterObject -
        The filter to query.

    PinCount -
        The place in which to return the pin factory count.

Return Values:

    Returns STATUS_SUCCESS, else some critical error.

--*/
{
    KSPROPERTY  Property;
    ULONG       BytesReturned;

    Property.Set = KSPROPSETID_Pin;
    Property.Id = KSPROPERTY_PIN_CTYPES;
    Property.Flags = KSPROPERTY_TYPE_GET;
    return KsSynchronousIoControlDevice(
        FilterObject,
        KernelMode,
        IOCTL_KS_PROPERTY,
        &Property,
        sizeof(Property),
        PinCount,
        sizeof(*PinCount),
        &BytesReturned);
}


NTSTATUS
GetPinTypes(
    IN PFILE_OBJECT FilterObject,
    IN ULONG Pin,
    IN ULONG Id,
    OUT PULONG Types
    )
/*++

Routine Description:

    Queries the count of "types" from the Pin property set. This is used
    to query the count of either Mediums or DataRanges, which use the same
    format for returning current count.

Arguments:

    FilterObject -
        The filter to query.

    Pin -
        The pin factory to query either Mediums or DataRanges of.

    Id -
        The property to query. This is either Mediums or DataRanges.

    Types -
        The place in which to return the number of types.

Return Values:

    Returns STATUS_SUCCESS, else some critical error.

--*/
{
    KSP_PIN         PinProp;
    KSMULTIPLE_ITEM MultipleItem;
    ULONG           BytesReturned;
    NTSTATUS        Status;

    PinProp.Property.Set = KSPROPSETID_Pin;
    PinProp.Property.Id = Id;
    PinProp.Property.Flags = KSPROPERTY_TYPE_GET;
    PinProp.PinId = Pin;
    PinProp.Reserved = 0;
    Status = KsSynchronousIoControlDevice(
        FilterObject,
        KernelMode,
        IOCTL_KS_PROPERTY,
        &PinProp,
        sizeof(PinProp),
        &MultipleItem,
        sizeof(MultipleItem),
        &BytesReturned);
    if (NT_SUCCESS(Status)) {
        *Types = MultipleItem.Count;
    }
    return Status;
}


NTSTATUS
GetPinFlags(
    IN PFILE_OBJECT FilterObject,
    IN ULONG Pin,
    OUT PULONG Flags
    )
/*++

Routine Description:

    Determines which flags to set based on the number of necessary instances
    a pin factory must create, and the data flow of the pin factory. It does
    not attempt to determine if the pin factory topologically connected to a
    Bridge.

Arguments:

    FilterObject -
        The filter to query.

    Pin -
        The pin factory to query.

    Flags -
        The place in which to return the flags.

Return Values:

    Returns STATUS_SUCCESS, else some critical error.

--*/
{
    KSP_PIN         PinProp;
    ULONG           Instances;
    KSPIN_DATAFLOW  DataFlow;
    ULONG           BytesReturned;
    NTSTATUS        Status;

    *Flags = 0;
    PinProp.Property.Set = KSPROPSETID_Pin;
    PinProp.Property.Id = KSPROPERTY_PIN_NECESSARYINSTANCES;
    PinProp.Property.Flags = KSPROPERTY_TYPE_GET;
    PinProp.PinId = Pin;
    PinProp.Reserved = 0;
    Status = KsSynchronousIoControlDevice(
        FilterObject,
        KernelMode,
        IOCTL_KS_PROPERTY,
        &PinProp,
        sizeof(PinProp),
        &Instances,
        sizeof(Instances),
        &BytesReturned);
    //
    // The property need not be supported.
    //
    if (NT_SUCCESS(Status) && !Instances) {
        *Flags |= REG_PIN_B_ZERO;
    }
    PinProp.Property.Id = KSPROPERTY_PIN_DATAFLOW;
    Status = KsSynchronousIoControlDevice(
        FilterObject,
        KernelMode,
        IOCTL_KS_PROPERTY,
        &PinProp,
        sizeof(PinProp),
        &DataFlow,
        sizeof(DataFlow),
        &BytesReturned);
    if (NT_SUCCESS(Status) && (DataFlow == KSPIN_DATAFLOW_OUT)) {
        *Flags |= REG_PIN_B_OUTPUT;
    }
    //
    // REG_PIN_B_RENDERER is not filled in at this time.
    //
    return Status;
}


NTSTATUS
GetPinInstances(
    IN PFILE_OBJECT FilterObject,
    IN ULONG Pin,
    OUT PULONG PossibleInstances
    )
/*++

Routine Description:

    Queries the number of possible instances a pin factory may create.
    This is used to set one of the flags.

Arguments:

    FilterObject -
        The filter to query.

    Pin -
        The pin factory to query.

    PossibleInstances -
        The place in which to return the possible instances.

Return Values:

    Returns STATUS_SUCCESS, else some critical error.

--*/
{
    KSP_PIN             PinProp;
    KSPIN_CINSTANCES    Instances;
    ULONG               BytesReturned;
    NTSTATUS            Status;

    PinProp.Property.Set = KSPROPSETID_Pin;
    PinProp.Property.Id = KSPROPERTY_PIN_CINSTANCES;
    PinProp.Property.Flags = KSPROPERTY_TYPE_GET;
    PinProp.PinId = Pin;
    PinProp.Reserved = 0;
    Status = KsSynchronousIoControlDevice(
        FilterObject,
        KernelMode,
        IOCTL_KS_PROPERTY,
        &PinProp,
        sizeof(PinProp),
        &Instances,
        sizeof(Instances),
        &BytesReturned);
    if (NT_SUCCESS(Status)) {
        *PossibleInstances = Instances.PossibleCount;
    }
    return Status;
}


NTSTATUS
GetPinTypeList(
    IN PFILE_OBJECT FilterObject,
    IN ULONG Pin,
    IN ULONG Id,
    OUT PKSMULTIPLE_ITEM* MultipleItem
    )
/*++

Routine Description:

    Queries multiple item properties from the Pin property set. This is
    used to query either the Mediums or DataRanges, which use the same
    format for returning data.

Arguments:

    FilterObject -
        The filter to query.

    Pin -
        The pin factory to query either Mediums or DataRanges of.

    Id -
        The property to query. This is either Mediums or DataRanges.

    MultipleItems -
        The place in which to return the pointer to the buffer allocated
        to contain the items.

Return Values:

    Returns STATUS_SUCCESS, else some critical error.

--*/
{
    KSP_PIN     PinProp;
    ULONG       BytesReturned;
    NTSTATUS    Status;

    //
    // First query for the size needed.
    //
    PinProp.Property.Set = KSPROPSETID_Pin;
    PinProp.Property.Id = Id;
    PinProp.Property.Flags = KSPROPERTY_TYPE_GET;
    PinProp.PinId = Pin;
    PinProp.Reserved = 0;
    Status = KsSynchronousIoControlDevice(
        FilterObject,
        KernelMode,
        IOCTL_KS_PROPERTY,
        &PinProp,
        sizeof(PinProp),
        NULL,
        0,
        &BytesReturned);
    //
    // This query must not success, else the filter is broken.
    //
    ASSERT(!NT_SUCCESS(Status));
    //
    // An overflow is expected, so that the size needed can be returned.
    //
    if (Status != STATUS_BUFFER_OVERFLOW) {
        return Status;
    }
    *MultipleItem = ExAllocatePoolWithTag(PagedPool, BytesReturned, 'tpSK');
    if (!*MultipleItem) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    Status = KsSynchronousIoControlDevice(
        FilterObject,
        KernelMode,
        IOCTL_KS_PROPERTY,
        &PinProp,
        sizeof(PinProp),
        *MultipleItem,
        BytesReturned,
        &BytesReturned);
    if (!NT_SUCCESS(Status)) {
        ExFreePool(*MultipleItem);
    }
    return Status;
}


NTSTATUS
GetPinCategory(
    IN PFILE_OBJECT FilterObject,
    IN ULONG Pin,
    OUT GUID* Category
    )
/*++

Routine Description:

    Queries the category of a pin. This may not be supported, which can
    be expected.

Arguments:

    FilterObject -
        The filter to query.

    Pin -
        The pin factory to query.

    Category -
        The place in which to return the category

Return Values:

    Returns STATUS_SUCCESS, STATUS_NOT_FOUND, else some critical error.

--*/
{
    KSP_PIN     PinProp;
    ULONG       BytesReturned;

    PinProp.Property.Set = KSPROPSETID_Pin;
    PinProp.Property.Id = KSPROPERTY_PIN_CATEGORY;
    PinProp.Property.Flags = KSPROPERTY_TYPE_GET;
    PinProp.PinId = Pin;
    PinProp.Reserved = 0;
    return KsSynchronousIoControlDevice(
        FilterObject,
        KernelMode,
        IOCTL_KS_PROPERTY,
        &PinProp,
        sizeof(PinProp),
        Category,
        sizeof(*Category),
        &BytesReturned);
}


VOID
InsertCacheItem(
    IN PVOID Item,
    IN ULONG ItemSize,
    IN PVOID OffsetBase,
    IN PVOID CacheBase,
    IN OUT PULONG ItemsCached,
    OUT PULONG ItemOffset
    )
/*++

Routine Description:

    Return an OffsetBase'd offset into the specified cache for the item
    passed in. If the item is already in the cache, return an offset to
    that item, else add the item to the cache by copying its contents,
    and return an offset to the new item.

Arguments:

    Item -
        Points to the item to insert into the specified cache.

    ItemSize -
        Contains the size of both the item passed, and the items in the
        specified cache.

    OffsetBase -
        Contains the pointer on which to base the offset returned.

    CacheBase -
        Contains a pointer to the beginning of the cache, which is greater
        than the OffsetBase.

    ItemsCached -
        Points to a counter of the total items currently in the cache. This
        is updated if a new item is added.

    ItemOffset -
        The place in which to put the offset to the item added to the cache.

Return Values:

    Nothing.

--*/
{
    ULONG   CurrentItem;

    //
    // Search the list of cache items for one which is equivalent.
    //
    for (CurrentItem = 0; CurrentItem < *ItemsCached; CurrentItem++) {
        if (RtlCompareMemory(
            Item,
            (PUCHAR)CacheBase + (CurrentItem * ItemSize),
            ItemSize) == ItemSize) {
            //
            // This item is equal to a cached item.
            //
            break;
        }
    }
    //
    // If an equal cached item was not found, make a new entry.
    //
    if (CurrentItem == *ItemsCached) {
        //
        // Increment the number of items currently cached.
        //
        (*ItemsCached)++;
        RtlMoveMemory(
            (PUCHAR)CacheBase + (CurrentItem * ItemSize),
            Item,
            ItemSize);
    }
    //
    // Return an offset to this cached item. This is the difference
    // of the current item to the OffsetBase.
    //
    *ItemOffset = 
        PtrToUlong( 
            (PVOID)((PUCHAR)CacheBase + 
                (CurrentItem * ItemSize) - 
                (PUCHAR)OffsetBase) );
}


VOID
ExtractMediaTypes(
    IN PKSMULTIPLE_ITEM MediaTypeList,
    IN ULONG MediaType,
    OUT GUID* MajorType,
    OUT GUID* MinorType
    )
/*++

Routine Description:

    Extract the major and minor Guids from a particular item in the list
    of media types.

Arguments:

    MediaTypeList -
        Points to the list of media types.

    MediaType -
        Specifies which item in the list to extract the Guids from.

    MajorType -
        The place in which to put the major Guid.

    MinorType -
        The place in which to put the minor Guid.

Return Values:

    Nothing.

--*/
{
    PVOID   DataRange;
    ULONG   DataRanges;

    DataRange = MediaTypeList + 1;
    //
    // Advance to the right data range.
    //
    for (DataRanges = 0; DataRanges < MediaType; DataRanges++) {
        (PUCHAR)DataRange += ((((PKSDATARANGE)DataRange)->FormatSize + FILE_QUAD_ALIGNMENT) & ~FILE_QUAD_ALIGNMENT);
    }
    *MajorType = ((PKSDATARANGE)DataRange)->MajorFormat;
    *MinorType = ((PKSDATARANGE)DataRange)->SubFormat;
}


NTSTATUS
BuildFilterData(
    IN PFILE_OBJECT FilterObject,
    IN ULONG Merit,
    OUT PUCHAR* FilterData,
    OUT ULONG* FilterDataLength
    )
/*++

Routine Description:

    Allocate memory and build the filter cache information to be stored in
    the registry for the particular interface.

Arguments:

    FilterObject -
        The file object of the filter to query.

    Merit -
        The merit to use in the cache.

    FilterData -
        The place in which to put the pointer to the cache data.

    FilterDataLength -
        The place in which to put the size of the cache data.

Return Values:

    STATUS_SUCCESS or an appropriate error condition.

--*/
{
    NTSTATUS            Status;
    ULONG               PinCount;
    ULONG               CurrentPin;
    ULONG               TotalMediaTypes;
    ULONG               TotalMediumTypes;
    REGFILTER_REG*      RegFilter;
    REGFILTERPINS_REG2* RegPin;
    GUID*               GuidCache;
    ULONG               GuidsCached;
    PKSPIN_MEDIUM       MediumCache;
    ULONG               MediumsCached;
    ULONG               TotalPossibleGuids;

    //
    // Calculate the maximum amount of space which could be taken up by
    // this cache data. This is before any collapsing which might occur.
    //
    if (!NT_SUCCESS(Status = GetFilterPinCount(FilterObject, &PinCount))) {
        return Status;
    }
    TotalMediaTypes = 0;
    TotalMediumTypes = 0;
    for (CurrentPin = PinCount; CurrentPin;) {
        ULONG   Types;

        CurrentPin--;
        if (!NT_SUCCESS(Status = GetPinTypes(FilterObject, CurrentPin, KSPROPERTY_PIN_DATARANGES, &Types))) {
            return Status;
        }
        TotalMediaTypes += Types;
        if (!NT_SUCCESS(Status = GetPinTypes(FilterObject, CurrentPin, KSPROPERTY_PIN_MEDIUMS, &Types))) {
            return Status;
        }
        TotalMediumTypes += Types;
    }
    //
    // The total is the size of all the structures, plus the maximum
    // number of Guids and Mediums which might be present before
    // collapsing.
    //
    TotalPossibleGuids = PinCount * 3 + TotalMediaTypes * 2;
    *FilterDataLength = sizeof(REGFILTER_REG) +
        PinCount * sizeof(REGFILTERPINS_REG2) +
        TotalMediaTypes * sizeof(REGPINTYPES_REG2) +
        TotalMediumTypes * sizeof(PKSPIN_MEDIUM) +
        TotalPossibleGuids * sizeof(GUID) +
        TotalMediumTypes * sizeof(KSPIN_MEDIUM);
    *FilterData = ExAllocatePoolWithTag(PagedPool, *FilterDataLength, 'dfSK');
    if (!*FilterData) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    //
    // Place the header in the data.
    //
    RegFilter = (REGFILTER_REG*)*FilterData;
    RegFilter->Version = 2;
    RegFilter->Merit = Merit;
    RegFilter->Pins = PinCount;
    RegFilter->Reserved = 0;
    //
    // Calculate the offset to the list of pins, and to each of the
    // cache positions at the end of the buffer. These follow the
    // structures containing the filter header, and the pin headers,
    // along with each pins media types and medium types. Initialize
    // the count of used guids and mediums in each cache. This is used
    // to compare when adding a new item to each cache, and in
    // compressing at the end.
    //
    RegPin = (REGFILTERPINS_REG2*)(RegFilter + 1);
    GuidCache = (GUID*)((PUCHAR)(RegPin + PinCount) +
        TotalMediaTypes * sizeof(REGPINTYPES_REG2) +
        TotalMediumTypes * sizeof(PKSPIN_MEDIUM));
    GuidsCached = 0;
    MediumCache = (PKSPIN_MEDIUM)(GuidCache + TotalPossibleGuids);
    MediumsCached = 0;
    //
    // Create each pin header, followed by the list of media types,
    // followed by the list of mediums.
    //
    for (CurrentPin = 0; CurrentPin < PinCount; CurrentPin++) {
        PKSMULTIPLE_ITEM    MediaTypeList;
        PKSMULTIPLE_ITEM    MediumTypeList;
        GUID                Guid;
        ULONG               CurrentType;
        REGPINTYPES_REG2*   PinType;
        PULONG              PinMedium;

        //
        // Initialize the pin header.
        //
        RegPin->Signature = FCC('0pi3');
        (*(PUCHAR)&RegPin->Signature) += (BYTE)CurrentPin;
        if (!NT_SUCCESS(Status = GetPinFlags(FilterObject, CurrentPin, &RegPin->Flags))) {
            break;
        }
        if (!NT_SUCCESS(Status = GetPinInstances(FilterObject, CurrentPin, &RegPin->PossibleInstances))) {
            break;
        }
        //
        // This flag must also be set, so just use the previously acquired value.
        //
        if (RegPin->PossibleInstances > 1) {
            RegPin->Flags |= REG_PIN_B_MANY;
        }
        if (!NT_SUCCESS(Status = GetPinTypeList(FilterObject, CurrentPin, KSPROPERTY_PIN_DATARANGES, &MediaTypeList))) {
            break;
        }
        RegPin->MediaTypes = MediaTypeList->Count;
        if (!NT_SUCCESS(Status = GetPinTypeList(FilterObject, CurrentPin, KSPROPERTY_PIN_MEDIUMS, &MediumTypeList))) {
            ExFreePool(MediaTypeList);
            break;
        }
        RegPin->MediumTypes = MediumTypeList->Count;
        if (NT_SUCCESS(Status = GetPinCategory(FilterObject, CurrentPin, &Guid))) {
            InsertCacheItem(&Guid, sizeof(*GuidCache), RegFilter, GuidCache, &GuidsCached, &RegPin->Category);
        } else if (Status == STATUS_NOT_FOUND) {
            //
            // Category may not be supported by a particular pin.
            //
            RegPin->Category = 0;
            Status = STATUS_SUCCESS;
        } else {
            ASSERT(FALSE && "The driver is broken and returned a completely unexpected failure status. Check owner of FilterObject above.");
            ExFreePool(MediaTypeList);
            ExFreePool(MediumTypeList);
            break;
        }
        //
        // Append the media types.
        //
        PinType = (REGPINTYPES_REG2*)(RegPin + 1);
        for (CurrentType = 0; CurrentType < MediaTypeList->Count; CurrentType++) {
            GUID    MajorType;
            GUID    MinorType;

            PinType->Signature = FCC('0ty3');
            (*(PUCHAR)&PinType->Signature) += (BYTE)CurrentType;
            PinType->Reserved = 0;
            ExtractMediaTypes(MediaTypeList, CurrentType, &MajorType, &MinorType);
            InsertCacheItem(&MajorType, sizeof(*GuidCache), RegFilter, GuidCache, &GuidsCached, &PinType->MajorType);
            InsertCacheItem(&MinorType, sizeof(*GuidCache), RegFilter, GuidCache, &GuidsCached, &PinType->MinorType);
            PinType++;
        }
        ExFreePool(MediaTypeList);
        //
        // Append the mediums.
        //
        PinMedium = (PULONG)PinType;
        for (CurrentType = 0; CurrentType < MediumTypeList->Count; CurrentType++) {
            PKSPIN_MEDIUM   Medium;

            Medium = (PKSPIN_MEDIUM)(MediumTypeList + 1) + CurrentType;
            InsertCacheItem(Medium, sizeof(*MediumCache), RegFilter, MediumCache, &MediumsCached, PinMedium);
            PinMedium++;
        }
        ExFreePool(MediumTypeList);
        //
        // Increment to the next pin header position.
        //
        RegPin = (REGFILTERPINS_REG2*)PinMedium;
    }
    if (NT_SUCCESS(Status)) {
        ULONG   OffsetAdjustment;

        //
        // If any duplicate guids were removed, the list of Mediums needs
        // to be shifted, and each pointer to a Medium needs to be adjusted.
        //
        OffsetAdjustment = (TotalPossibleGuids - GuidsCached) * sizeof(GUID);
        if (OffsetAdjustment) {
            RegPin = (REGFILTERPINS_REG2*)(RegFilter + 1);
            for (CurrentPin = PinCount; CurrentPin ; CurrentPin--) {
                ULONG               CurrentType;
                PULONG              PinMedium;

                //
                // Skip past the media types on to the mediums.
                //
                PinMedium = (PULONG)((REGPINTYPES_REG2*)(RegPin + 1) + RegPin->MediaTypes);
                //
                // Adjust each medium offset.
                //
                for (CurrentType = RegPin->MediumTypes; CurrentType; CurrentType--) {
                    *PinMedium -= OffsetAdjustment;
                    PinMedium++;
                }
                //
                // Increment to the next pin header position.
                //
                RegPin = (REGFILTERPINS_REG2*)PinMedium;
            }
            //
            // Move the medium entries down, and adjust the overall size.
            //
            RtlMoveMemory(
                (PUCHAR)MediumCache - OffsetAdjustment,
                MediumCache,
                MediumsCached * sizeof(KSPIN_MEDIUM));
            *FilterDataLength -= OffsetAdjustment;
        }
        //
        // Adjust the size by the number of duplicates removed.
        //
        *FilterDataLength -= ((TotalMediumTypes - MediumsCached) * sizeof(KSPIN_MEDIUM));
    } else {
        ExFreePool(RegFilter);
    }
    return Status;
}


NTSTATUS
UpdateMediumCache (
    IN HANDLE FilterObject,
    IN PUNICODE_STRING FilterSymbolicLink
    )

/*++

Routine Description:

    Go through and update the mediums cache for all non-public mediums
    that exist on pins on the given filter.

Arguments:

    FilterObject -
        The handle to the filter

    FilterSymbolicLink -
        The symlink to the filter (placed in the mediums cache)

Return Value:

    Success / Failure

--*/

{
    ULONG PinCount, CurPin;
    NTSTATUS Status = STATUS_SUCCESS;

    if (!NT_SUCCESS(Status = GetFilterPinCount(FilterObject, &PinCount))) {
        return Status;
    }

    for (CurPin = 0; CurPin < PinCount && NT_SUCCESS (Status); CurPin++) {
        PKSMULTIPLE_ITEM MediumTypeList;
        PKSPIN_MEDIUM Medium;
        ULONG CurMedium;
        KSPIN_DATAFLOW DataFlow;
        KSP_PIN PinProp;
        ULONG BytesReturned;

        PinProp.Property.Set = KSPROPSETID_Pin;
        PinProp.Property.Id = KSPROPERTY_PIN_DATAFLOW;
        PinProp.Property.Flags = KSPROPERTY_TYPE_GET;
        PinProp.PinId = CurPin;
        PinProp.Reserved = 0;

        Status = KsSynchronousIoControlDevice(
            FilterObject,
            KernelMode,
            IOCTL_KS_PROPERTY,
            &PinProp,
            sizeof(PinProp),
            &DataFlow,
            sizeof(DataFlow),
            &BytesReturned);

        if (!NT_SUCCESS (Status)) {
            break;
        }

        if (!NT_SUCCESS(Status = GetPinTypeList(
            FilterObject, CurPin, KSPROPERTY_PIN_MEDIUMS, &MediumTypeList))) {

            break;
        }

        //
        // Go through and only cache the private mediums on each pin. 
        //
        Medium = (PKSPIN_MEDIUM)(MediumTypeList + 1);
        for (CurMedium = 0; CurMedium < MediumTypeList -> Count; CurMedium++) {
            if (!IsEqualGUIDAligned (&Medium -> Set, &KSMEDIUMSETID_Standard)) {
                Status = KsCacheMedium (
                    FilterSymbolicLink,
                    Medium,
                    DataFlow == KSPIN_DATAFLOW_OUT ? 1 : 0
                    );

                if (!NT_SUCCESS (Status)) break;
            }

            Medium++;
        }

        ExFreePool (MediumTypeList);
    
    }

    return Status;

}


NTSTATUS
PropertySrv(
    IN PIRP         Irp,
    IN PKSPROPERTY  Property,
    IN PBYTE        Data
    )
/*++

Routine Description:

    Handles the Build Cache and Merit properties. Opens the interface registry
    key location, and queries the properties from the object to build the
    cache information structure. Or sets the specified Merit value, optionally
    propagating this to the Cache. This gives WRITE access to the interface
    registry location, while not allowing unauthorized access to the
    filter.

Arguments:

    Irp -
        Contains the Build Cache or Merit property IRP.

    Property -
        Contains the property identifier parameter.

    Data -
        Contains the data for the particular property.

Return Value:

    Return STATUS_SUCCESS if the cache was built or merit set, else some
    access or IO error.

--*/
{
    PIO_STACK_LOCATION  IrpStack;
    ULONG               OutputBufferLength;
    ULONG               Merit;
    PWCHAR              SymbolicLink;
    PWCHAR              LocalSymbolicLink;
    UNICODE_STRING      SymbolicString;
    NTSTATUS            Status;
    HANDLE              InterfaceKey;

    IrpStack = IoGetCurrentIrpStackLocation(Irp);
    OutputBufferLength = IrpStack->Parameters.DeviceIoControl.OutputBufferLength;
    SymbolicLink = (PWCHAR)Data;
    //
    // Ensure the string is terminated.
    //
    if (SymbolicLink[OutputBufferLength / sizeof(*SymbolicLink) - 1]) {
        _DbgPrintF(DEBUGLVL_ERROR, ("Invalid Symbolic Link [len=%u]", OutputBufferLength));
        return STATUS_INVALID_PARAMETER;
    }
    //
    // Since this handler deals with both properties, extract the specified
    // Merit value if necessary, and fix the pointer to the symbolic link.
    //
    if (Property->Id == KSPROPERTY_SERVICE_BUILDCACHE) {
        //
        // The default value for Merit is "unused". This can be modified
        // by the presence of a "Merit" value.
        //
        Merit = 0x200000;
    } else {
        ASSERT(Property->Id == KSPROPERTY_SERVICE_MERIT);
        Merit = *(PULONG)Data;
        SymbolicLink += (sizeof(Merit) / sizeof(*SymbolicLink));
        OutputBufferLength -= sizeof(Merit);
    }
    //
    // Make a copy of the incoming string in all cases, in case it needs to be modified.
    // Add on the length of the long prefix, in case it is needed.
    //
    LocalSymbolicLink = 
        ExAllocatePoolWithTag(
            PagedPool, OutputBufferLength + sizeof(DosPrefix), 'lsSK');
    if (!LocalSymbolicLink) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    RtlCopyMemory(LocalSymbolicLink, SymbolicLink, OutputBufferLength);
    //
    // Change a usermode string to kernelmode format. The string will be
    // at least 5 characters in length. This translates '\\?\' --> '\??\',
    // and '\\.\' --> '\DosDevices\'.
    //
    if ((LocalSymbolicLink[0] == '\\') && (LocalSymbolicLink[1] == '\\') && (LocalSymbolicLink[3] == '\\')) {
        if (LocalSymbolicLink[2] == '?') {
            LocalSymbolicLink[1] = '?';
        } else if (LocalSymbolicLink[2] == '.') {
            RtlCopyMemory(LocalSymbolicLink, DosPrefix, sizeof(DosPrefix));
            RtlCopyMemory(
                LocalSymbolicLink + (sizeof(DosPrefix) - sizeof(DosPrefix[0])) / sizeof(*LocalSymbolicLink),
                SymbolicLink + 3,
                OutputBufferLength - 3 * sizeof(*SymbolicLink));
        }
    }
    RtlInitUnicodeString(&SymbolicString, LocalSymbolicLink);
    //
    // Open the interface key which is where the cache data and merit is placed.
    //
    Status = IoOpenDeviceInterfaceRegistryKey(
        &SymbolicString,
        KEY_WRITE,
        &InterfaceKey);
    if (NT_SUCCESS(Status)) {
        UNICODE_STRING  KeyString;

        RtlInitUnicodeString(&KeyString, L"Merit");
        //
        // Building the cache is being requested. First read the current
        // Merit value, and use it when assigning the Merit in the
        // cache data.
        //
        if (Property->Id == KSPROPERTY_SERVICE_BUILDCACHE) {
            PKEY_VALUE_PARTIAL_INFORMATION PartialInfo;
            BYTE                PartialInfoBuffer[sizeof(*PartialInfo) + sizeof(Merit) - 1];
            ULONG               BytesReturned;
            HANDLE              FilterHandle;
            OBJECT_ATTRIBUTES   ObjectAttributes;
            IO_STATUS_BLOCK     IoStatusBlock;

            PartialInfo = (PKEY_VALUE_PARTIAL_INFORMATION)PartialInfoBuffer;
            //
            // Since old setupapi.dll could not handle REG_DWORD values,
            // allow REG_BINARY also.
            //
            if (NT_SUCCESS(ZwQueryValueKey(
                InterfaceKey,
                &KeyString,
                KeyValuePartialInformation,
                PartialInfoBuffer,
                sizeof(PartialInfoBuffer),
                &BytesReturned)) &&
                (PartialInfo->DataLength == sizeof(Merit)) &&
                ((PartialInfo->Type == REG_BINARY) ||
                (PartialInfo->Type == REG_DWORD))) {
                Merit = *(PULONG)PartialInfo->Data;
            }
            InitializeObjectAttributes(
                &ObjectAttributes,
                &SymbolicString,
                OBJ_CASE_INSENSITIVE,
                NULL,
                NULL);
            Status = IoCreateFile(
                &FilterHandle,
                GENERIC_READ | SYNCHRONIZE,
                &ObjectAttributes,
                &IoStatusBlock,
                NULL,
                0,
                0,
                FILE_OPEN,
                0,
                NULL,
                0,
                CreateFileTypeNone,
                NULL,
                IO_FORCE_ACCESS_CHECK | IO_NO_PARAMETER_CHECKING);
            if (NT_SUCCESS(Status)) {
                PFILE_OBJECT    FilterObject;
        
                Status = ObReferenceObjectByHandle(
                    FilterHandle,
                    FILE_GENERIC_READ,
                    *IoFileObjectType,
                    Irp->RequestorMode,
                    &FilterObject,
                    NULL);
                ZwClose(FilterHandle);
                if (NT_SUCCESS(Status)) {
                    ULONG   FilterDataLength;
                    PUCHAR  FilterData;

                    //
                    // Allocate room for the data, and build it.
                    //
                    Status = BuildFilterData(FilterObject, Merit, &FilterData, &FilterDataLength);
                    if (NT_SUCCESS(Status)) {
                        RtlInitUnicodeString(&KeyString, L"FilterData");
                        Status = ZwSetValueKey(
                            InterfaceKey,
                            &KeyString,
                            0,
                            REG_BINARY,
                            FilterData,
                            FilterDataLength);
                        ExFreePool(FilterData);
                    }

                    //
                    // Cache all non-public mediums.
                    //
                    if (NT_SUCCESS (Status)) {
                        Status = UpdateMediumCache(FilterObject, &SymbolicString);
                    }
                }
                ObDereferenceObject(FilterObject);
            }
        } else {
            //
            // The Merit value is being set. Try to set with the value
            // which was passed in, then determine if the cache needs
            // to be modified with the new value.
            //
            Status = ZwSetValueKey(
                InterfaceKey,
                &KeyString,
                0,
                REG_DWORD,
                &Merit,
                sizeof(Merit));
            if (NT_SUCCESS(Status)) {
                ULONG       FilterDataLength;
                KEY_VALUE_PARTIAL_INFORMATION   PartialInfoHeader;

                RtlInitUnicodeString(&KeyString, L"FilterData");
                //
                // Determine if the cache needs to be modified to fix the
                // Merit value. Only if it is present should it be rebuilt.
                //
                Status = ZwQueryValueKey(
                    InterfaceKey,
                    &KeyString,
                    KeyValuePartialInformation,
                    &PartialInfoHeader,
                    sizeof(PartialInfoHeader),
                    &FilterDataLength);
                if ((Status == STATUS_BUFFER_OVERFLOW) || NT_SUCCESS(Status)) {
                    PKEY_VALUE_PARTIAL_INFORMATION  PartialInfo;

                    //
                    // Allocate a buffer for the actual size of data needed.
                    //
                    PartialInfo = 
                        ExAllocatePoolWithTag( PagedPool, FilterDataLength, 'dfSK');
                    if (PartialInfo) {
                        //
                        // Retrieve the cache.
                        //
                        Status = ZwQueryValueKey(
                            InterfaceKey,
                            &KeyString,
                            KeyValuePartialInformation,
                            PartialInfo,
                            FilterDataLength,
                            &FilterDataLength);
                        if (NT_SUCCESS(Status)) {
                            if ((PartialInfo->DataLength >= sizeof(REGFILTER_REG)) &&
                                (PartialInfo->Type == REG_BINARY)) {
                                //
                                // Modify the Merit value and write it back.
                                //
                                ((REGFILTER_REG*)PartialInfo->Data)->Merit = Merit;
                                Status = ZwSetValueKey(
                                    InterfaceKey,
                                    &KeyString,
                                    0,
                                    REG_BINARY,
                                    PartialInfo->Data,
                                    PartialInfo->DataLength);
                            }
                        } else {
                            //
                            // Maybe it was just deleted. No need to modify it.
                            //
                            Status = STATUS_SUCCESS;
                        }
                        ExFreePool(PartialInfo);
                    }
                } else {
                    //
                    // The cache does not exist, so no need to modify it.
                    //
                    Status = STATUS_SUCCESS;
                }
            }
        }
        ZwClose(InterfaceKey);
    }
    ExFreePool(LocalSymbolicLink);
    return Status;
}


NTSTATUS
SrvDispatchCreate(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
/*++

Routine Description:

    The IRP handler for IRP_MJ_CREATE for the Server. Just validates that no
    random parameters are being passed.

Arguments:

    DeviceObject -
        The device object to which the Server is attached. This is not used.

    Irp -
        The specific close IRP to be processed.

Return Value:

    Returns STATUS_SUCCESS, else a memory allocation error.

--*/
{
    NTSTATUS                Status;

    //
    // Notify the software bus that this device is in use.
    //
    Status = KsReferenceSoftwareBusObject(((PDEVICE_INSTANCE)DeviceObject->DeviceExtension)->Header);
    if (NT_SUCCESS(Status)) {
        PIO_STACK_LOCATION      IrpStack;
        PKSOBJECT_CREATE_ITEM   CreateItem;
        PINSTANCE               SrvInst;

        IrpStack = IoGetCurrentIrpStackLocation(Irp);
        CreateItem = KSCREATE_ITEM_IRP_STORAGE(Irp);
        if (IrpStack->FileObject->FileName.Length != sizeof(OBJ_NAME_PATH_SEPARATOR) + CreateItem->ObjectClass.Length) {
            Status = STATUS_INVALID_PARAMETER;
        } else if (SrvInst = (PINSTANCE)ExAllocatePoolWithTag(NonPagedPool, sizeof(*SrvInst), 'IFsK')) {
            Status = KsAllocateObjectHeader(
                &SrvInst->Header,
                0,
                NULL,
                Irp,
                (PKSDISPATCH_TABLE)&SrvDispatchTable);
            if (NT_SUCCESS(Status)) {
                IrpStack->FileObject->FsContext = SrvInst;
            } else {
                ExFreePool(SrvInst);
            }
        } else {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
        if (!NT_SUCCESS(Status)) {
            KsDereferenceSoftwareBusObject(((PDEVICE_INSTANCE)DeviceObject->DeviceExtension)->Header);
        }
    }
    Irp->IoStatus.Status = Status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return Status;
}


NTSTATUS
SrvDispatchClose(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
/*++

Routine Description:

    The IRP handler for IRP_MJ_CLOSE for the Server. Cleans up object.

Arguments:

    DeviceObject -
        The device object to which the Server is attached. This is not used.

    Irp -
        The specific close IRP to be processed.

Return Value:

    Returns STATUS_SUCCESS.

--*/
{
    PIO_STACK_LOCATION  IrpStack;
    PINSTANCE           SrvInst;

    IrpStack = IoGetCurrentIrpStackLocation(Irp);
    SrvInst = (PINSTANCE)IrpStack->FileObject->FsContext;
    KsFreeObjectHeader(SrvInst->Header);
    ExFreePool(SrvInst);
    //
    // Notify the software bus that the device has been closed.
    //
    KsDereferenceSoftwareBusObject(((PDEVICE_INSTANCE)DeviceObject->DeviceExtension)->Header);
    Irp->IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return STATUS_SUCCESS;
}


NTSTATUS
SrvDispatchIoControl(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
/*++

Routine Description:

    The IRP handler for IRP_MJ_DEVICE_CONTROL for the Server. Handles
    the properties supported by this implementation using the
    default handlers provided by KS.

Arguments:

    DeviceObject -
        The device object to which the Server is attached. This is not used.

    Irp -
        The specific device control IRP to be processed.

Return Value:

    Returns the status of the processing.

--*/
{
    PIO_STACK_LOCATION  IrpStack;
    NTSTATUS            Status;

    IrpStack = IoGetCurrentIrpStackLocation(Irp);
    switch (IrpStack->Parameters.DeviceIoControl.IoControlCode) {
    case IOCTL_KS_PROPERTY:
        Status = KsPropertyHandler(
            Irp,
            SIZEOF_ARRAY(SrvPropertySets),
            (PKSPROPERTY_SET)SrvPropertySets);
        break;
    default:
        Status = STATUS_INVALID_DEVICE_REQUEST;
        break;
    }
    Irp->IoStatus.Status = Status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\ksfilter\mspclock\sources.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    sources.

!ENDIF

MAJORCOMP=ntos
MINORCOMP=dd

TARGETNAME=mspclock
TARGETPATH=obj
TARGETTYPE=DRIVER
TARGETLIBS=$(DDK_LIB_PATH)\ks.lib\
    $(DDK_LIB_PATH)\ksguid.lib

DRIVERTYPE=WDM

MSC_WARNING_LEVEL=/W3 /WX
C_DEFINES=$(C_DEFINES) -D_WIN32 -DUNICODE -D_UNICODE -DDEBUG_LEVEL=DEBUGLVL_BLAB

VC40_HACK=1
LINKER_FLAGS =$(LINKER_FLAGS) -map -merge:.rdata=PAGE -merge:PAGECONST=PAGE

SOURCES=\
        $(TARGETNAME).rc \
        $(TARGETNAME).c \
        device.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\ksfilter\mspclock\device.c ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1998

Module Name:

    device.c

Abstract:

    Device entry point and hardware validation.

--*/

#include "mspclock.h"

#ifdef ALLOC_PRAGMA
NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT   DriverObject,
    IN PUNICODE_STRING  RegistryPathName
    );

#pragma alloc_text(INIT, DriverEntry)
#endif // ALLOC_PRAGMA


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT   DriverObject,
    IN PUNICODE_STRING  RegistryPathName
    )
/*++

Routine Description:

    Sets up the driver object to handle the KS interface and PnP Add Device
    request. Does not set up a handler for PnP Irp's, as they are all dealt
    with directly by the PDO.

Arguments:

    DriverObject -
        Driver object for this instance.

    RegistryPathName -
        Contains the registry path which was used to load this instance.

Return Values:

    Returns STATUS_SUCCESS.

--*/
{
    DriverObject->MajorFunction[IRP_MJ_PNP] = KsDefaultDispatchPnp;
    DriverObject->MajorFunction[IRP_MJ_POWER] = KsDefaultDispatchPower;
    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = KsDefaultForwardIrp;
    DriverObject->DriverExtension->AddDevice = PnpAddDevice;
    DriverObject->DriverUnload = KsNullDriverUnload;
    KsSetMajorFunctionHandler(DriverObject, IRP_MJ_CREATE);
    KsSetMajorFunctionHandler(DriverObject, IRP_MJ_CLOSE);
    KsSetMajorFunctionHandler(DriverObject, IRP_MJ_DEVICE_CONTROL);
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\ksfilter\mspclock\mspclock.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1997

Module Name:

	mspclock.h

Abstract:

	Internal header file for filter.

--*/

#include <wdm.h>
#include <windef.h>

#include <memory.h>
#include <stddef.h>
#include <stdio.h>
#include <limits.h>
#include <stdlib.h>
#include <tchar.h>
#include <conio.h>

#include <ks.h>
#include <swenum.h>
#include <ksi.h>

#if (DBG)
#define STR_MODULENAME  "mspclock: "
#endif // DBG

NTSTATUS
PnpAddDevice(
    IN PDRIVER_OBJECT   DriverObject,
    IN PDEVICE_OBJECT   PhysicalDeviceObject
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\ksfilter\mskssrv\device.c ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1998

Module Name:

    device.c

Abstract:

    Device entry point and hardware validation.

--*/

#include "mskssrv.h"

#ifdef ALLOC_PRAGMA
NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT   DriverObject,
    IN PUNICODE_STRING  RegistryPathName
    );

#pragma alloc_text(INIT, DriverEntry)
#endif // ALLOC_PRAGMA


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT   DriverObject,
    IN PUNICODE_STRING  RegistryPathName
    )
/*++

Routine Description:

    Sets up the driver object to handle the KS interface and PnP Add Device
    request. Does not set up a handler for PnP Irp's, as they are all dealt
    with directly by the PDO.

Arguments:

    DriverObject -
        Driver object for this instance.

    RegistryPathName -
        Contains the registry path which was used to load this instance.

Return Values:

    Returns STATUS_SUCCESS.

--*/
{
    DriverObject->MajorFunction[IRP_MJ_PNP] = KsDefaultDispatchPnp;
    DriverObject->MajorFunction[IRP_MJ_POWER] = KsDefaultDispatchPower;
    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = KsDefaultForwardIrp;
    DriverObject->DriverExtension->AddDevice = PnpAddDevice;
    DriverObject->DriverUnload = KsNullDriverUnload;
    KsSetMajorFunctionHandler(DriverObject, IRP_MJ_CREATE);
    KsSetMajorFunctionHandler(DriverObject, IRP_MJ_CLOSE);
    KsSetMajorFunctionHandler(DriverObject, IRP_MJ_DEVICE_CONTROL);
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\ksfilter\mspqm\mspqm.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1997

Module Name:

	mspqm.h

Abstract:

	Internal header file for device.

--*/

#include <wdm.h>
#include <windef.h>

#include <memory.h>
#include <stddef.h>
#include <stdio.h>
#include <limits.h>
#include <stdlib.h>
#include <tchar.h>
#include <conio.h>

#include <ks.h>
#include <swenum.h>

#if (DBG)
#define STR_MODULENAME  "mspqm: "
#endif // DBG

NTSTATUS
PnpAddDevice(
    IN PDRIVER_OBJECT   DriverObject,
    IN PDEVICE_OBJECT   PhysicalDeviceObject
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\ksfilter\mspclock\mspclock.c ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    mspclock.c

Abstract:

    Kernel proxy for external clock.

--*/

#include "mspclock.h"

#ifdef WIN98GOLD
#define KeEnterCriticalRegion()
#define KeLeaveCriticalRegion()
#endif

typedef struct {
    KSDEVICE_HEADER     Header;
} DEVICE_INSTANCE, *PDEVICE_INSTANCE;

typedef struct {
    KSCLOCKINSTANCE     Base;
    FAST_MUTEX          StateMutex;
} INSTANCE, *PINSTANCE;

NTSTATUS
PropertyClockSetTime(
    IN PIRP         Irp,
    IN PKSPROPERTY  Property,
    IN PLONGLONG    Time
    );
NTSTATUS
PropertyClockSetState(
    IN PIRP         Irp,
    IN PKSPROPERTY  Property,
    IN PKSSTATE     State
    );
NTSTATUS
ClockDispatchCreate(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );
NTSTATUS
ClockDispatchIoControl(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );
NTSTATUS
ClockDispatchClose(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, PnpAddDevice)
#pragma alloc_text(PAGE, PropertyClockSetTime)
#pragma alloc_text(PAGE, PropertyClockSetState)
#pragma alloc_text(PAGE, ClockDispatchCreate)
#pragma alloc_text(PAGE, ClockDispatchClose)
#pragma alloc_text(PAGE, ClockDispatchIoControl)
#endif // ALLOC_PRAGMA

static const WCHAR DeviceTypeName[] = KSSTRING_Clock;

static const DEFINE_KSCREATE_DISPATCH_TABLE(CreateItems) {
    DEFINE_KSCREATE_ITEM(ClockDispatchCreate, DeviceTypeName, 0)
};

static DEFINE_KSDISPATCH_TABLE(
    ClockDispatchTable,
    ClockDispatchIoControl,
    NULL,
    NULL,
    NULL,
    ClockDispatchClose,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL);

//
// The standard clock property set is modified to add writable properties
// which are used as the method to set the time and state of the clock.
// Any querying of properties is handled by the internal default clock
// functions. Routing them through this module allows the addition of
// extra functionality to the clock
//
static DEFINE_KSPROPERTY_TABLE(ClockPropertyItems) {
    DEFINE_KSPROPERTY_ITEM(
        KSPROPERTY_CLOCK_TIME,
        KsiPropertyDefaultClockGetTime,
        sizeof(KSPROPERTY),
        sizeof(LONGLONG),
        PropertyClockSetTime,
        NULL, 0, NULL, NULL, 0
    ),
    DEFINE_KSPROPERTY_ITEM_CLOCK_PHYSICALTIME(KsiPropertyDefaultClockGetPhysicalTime),
    DEFINE_KSPROPERTY_ITEM_CLOCK_CORRELATEDTIME(KsiPropertyDefaultClockGetCorrelatedTime),
    DEFINE_KSPROPERTY_ITEM_CLOCK_CORRELATEDPHYSICALTIME(KsiPropertyDefaultClockGetCorrelatedPhysicalTime),
    DEFINE_KSPROPERTY_ITEM_CLOCK_RESOLUTION(KsiPropertyDefaultClockGetResolution),
    DEFINE_KSPROPERTY_ITEM(
        KSPROPERTY_CLOCK_STATE,
        KsiPropertyDefaultClockGetState,
        sizeof(KSPROPERTY),
        sizeof(KSSTATE),
        PropertyClockSetState,
        NULL, 0, NULL, NULL, 0
    ),
    DEFINE_KSPROPERTY_ITEM_CLOCK_FUNCTIONTABLE(KsiPropertyDefaultClockGetFunctionTable)
};

static DEFINE_KSPROPERTY_SET_TABLE(ClockPropertySets) {
    DEFINE_KSPROPERTY_SET(
        &KSPROPSETID_Clock,
        SIZEOF_ARRAY(ClockPropertyItems),
        ClockPropertyItems,
        0, NULL
    )
};

static DEFINE_KSEVENT_TABLE(ClockEventItems) {
    DEFINE_KSEVENT_ITEM(
        KSEVENT_CLOCK_INTERVAL_MARK,
        sizeof(KSEVENT_TIME_INTERVAL),
        sizeof(KSINTERVAL),
        (PFNKSADDEVENT)KsiDefaultClockAddMarkEvent,
        NULL,
        NULL),
    DEFINE_KSEVENT_ITEM(
        KSEVENT_CLOCK_POSITION_MARK,
        sizeof(KSEVENT_TIME_MARK),
        sizeof(LONGLONG),
        (PFNKSADDEVENT)KsiDefaultClockAddMarkEvent,
        NULL,
        NULL)
};

static DEFINE_KSEVENT_SET_TABLE(ClockEventSets) {
    DEFINE_KSEVENT_SET(
        &KSEVENTSETID_Clock,
        SIZEOF_ARRAY(ClockEventItems),
        ClockEventItems
    )
};


NTSTATUS
PnpAddDevice(
    IN PDRIVER_OBJECT   DriverObject,
    IN PDEVICE_OBJECT   PhysicalDeviceObject
    )
/*++

Routine Description:

    When a new device is detected, PnP calls this entry point with the
    new PhysicalDeviceObject (PDO). The driver creates an associated 
    FunctionalDeviceObject (FDO).

Arguments:

    DriverObject -
        Pointer to the driver object.

    PhysicalDeviceObject -
        Pointer to the new physical device object.

Return Values:

    STATUS_SUCCESS or an appropriate error condition.

--*/
{
    PDEVICE_OBJECT      FunctionalDeviceObject;
    PDEVICE_INSTANCE    DeviceInstance;
    NTSTATUS            Status;

    Status = IoCreateDevice(
        DriverObject,
        sizeof(DEVICE_INSTANCE),
        NULL,                           // FDOs are unnamed
        FILE_DEVICE_KS,
        0,
        FALSE,
        &FunctionalDeviceObject);
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    DeviceInstance = (PDEVICE_INSTANCE)FunctionalDeviceObject->DeviceExtension;
    //
    // This object uses KS to perform access through the DeviceCreateItems.
    //
    Status = KsAllocateDeviceHeader(
        &DeviceInstance->Header,
        SIZEOF_ARRAY(CreateItems),
        (PKSOBJECT_CREATE_ITEM)CreateItems);
    if (NT_SUCCESS(Status)) {
        KsSetDevicePnpAndBaseObject(
            DeviceInstance->Header,
            IoAttachDeviceToDeviceStack(
                FunctionalDeviceObject, 
                PhysicalDeviceObject),
            FunctionalDeviceObject );
        FunctionalDeviceObject->Flags |= DO_POWER_PAGABLE;
        FunctionalDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;
        return STATUS_SUCCESS;
    }
    IoDeleteDevice(FunctionalDeviceObject);
    return Status;
}


NTSTATUS
PropertyClockSetTime(
    IN PIRP         Irp,
    IN PKSPROPERTY  Property,
    IN PLONGLONG    Time
    )
/*++

Routine Description:

    Handles the Set Time property.

Arguments:

    Irp -
        Contains the Set Time property IRP.

    Property -
        Contains the property identifier parameter.

    Time -
        Contains a pointer to the new time value.

Return Value:

    Return STATUS_SUCCESS.

--*/
{
    PINSTANCE   ClockInst;

    ClockInst = (PINSTANCE)IoGetCurrentIrpStackLocation(Irp)->FileObject->FsContext;
    //
    // Serialize setting of time and state so that the client does not have to.
    //
    KeEnterCriticalRegion();
    ExAcquireFastMutexUnsafe(&ClockInst->StateMutex);
    KsSetDefaultClockTime(ClockInst->Base.DefaultClock, *Time);
    ExReleaseFastMutexUnsafe(&ClockInst->StateMutex);
    KeLeaveCriticalRegion();
    return STATUS_SUCCESS;
}


NTSTATUS
PropertyClockSetState(
    IN PIRP         Irp,
    IN PKSPROPERTY  Property,
    IN PKSSTATE     State
    )
/*++

Routine Description:

    Handles the Set State property.

Arguments:

    Irp -
        Contains the Set State property IRP.

    Property -
        Contains the property identifier parameter.

    State -
        Contains a pointer to the new state.

Return Value:

    Return STATUS_SUCCESS.

--*/
{
    PINSTANCE   ClockInst;

    ClockInst = (PINSTANCE)IoGetCurrentIrpStackLocation(Irp)->FileObject->FsContext;
    //
    // Serialize setting of time and state so that the client does not have to.
    //
    KeEnterCriticalRegion();
    ExAcquireFastMutexUnsafe(&ClockInst->StateMutex);
    KsSetDefaultClockState(ClockInst->Base.DefaultClock, *State);
    ExReleaseFastMutexUnsafe(&ClockInst->StateMutex);
    KeLeaveCriticalRegion();
    return STATUS_SUCCESS;
}


NTSTATUS
ClockDispatchCreate(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
/*++

Routine Description:

    The IRP handler for IRP_MJ_CREATE for the Clock. Initializes data structures
    and associates the IoGetCurrentIrpStackLocation(Irp)->FileObject with this
    clock using a dispatch table (KSDISPATCH_TABLE).

Arguments:

    DeviceObject -
        The device object to which the Clock is attached. This is not used.

    Irp -
        The specific close IRP to be processed.

Return Value:

    Returns STATUS_SUCCESS, else a memory allocation error.

--*/
{
    NTSTATUS            Status;

    //
    // Notify the software bus that this device is in use.
    //
    Status = KsReferenceSoftwareBusObject(((PDEVICE_INSTANCE)DeviceObject->DeviceExtension)->Header);
    if (NT_SUCCESS(Status)) {
        PINSTANCE           ClockInst;

        //
        // The proxy clock just uses a default clock to interpolate between
        // time updates from the client, and to provide notification services.
        //
        if (ClockInst = (PINSTANCE)ExAllocatePoolWithTag(NonPagedPool, sizeof(INSTANCE), 'IFsK')) {
            //
            // Allocate the internal structure and reference count it. This just
            // uses the Default Clock structures, which use the system time to
            // keep time. This proxy then interpolates between settings using the
            // system time.
            //
            if (NT_SUCCESS(Status = KsAllocateDefaultClock(&ClockInst->Base.DefaultClock))) {
                KsAllocateObjectHeader(&ClockInst->Base.Header,
                0,
                NULL,
                Irp,
                (PKSDISPATCH_TABLE)&ClockDispatchTable);
                //
                // This is the lock used to serialize setting state calls and setting
                // time calls, so that a client of this proxy need not worry about
                // serializing calls to this module.
                //
                ExInitializeFastMutex(&ClockInst->StateMutex);
                IoGetCurrentIrpStackLocation(Irp)->FileObject->FsContext = ClockInst;
                Status = STATUS_SUCCESS;
            } else {
                ExFreePool(ClockInst);
            }
        } else {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
        if (!NT_SUCCESS(Status)) {
            KsDereferenceSoftwareBusObject(((PDEVICE_INSTANCE)DeviceObject->DeviceExtension)->Header);
        }
    }
    Irp->IoStatus.Status = Status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return Status;
}


NTSTATUS
ClockDispatchClose(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
/*++

Routine Description:

    The IRP handler for IRP_MJ_CLOSE for the Clock. Cleans up the
    event list, and instance data, and cancels notification timer if no longer
    needed.

Arguments:

    DeviceObject -
        The device object to which the Clock is attached. This is not used.

    Irp -
        The specific close IRP to be processed.

Return Value:

    Returns STATUS_SUCCESS.

--*/
{
    PIO_STACK_LOCATION  IrpStack;
    PINSTANCE           ClockInst;

    IrpStack = IoGetCurrentIrpStackLocation(Irp);
    ClockInst = (PINSTANCE)IrpStack->FileObject->FsContext;
    //
    // There are only events based on this FileObject, so free any left enabled,
    // and kill the default clock object.
    //
    KsFreeEventList(
        IrpStack->FileObject,
        &ClockInst->Base.DefaultClock->EventQueue,
        KSEVENTS_SPINLOCK,
        &ClockInst->Base.DefaultClock->EventQueueLock);
    //
    // Dereference the internal structure, which also includes cancelling any
    // outstanding Dpc, and possibly freeing the data.
    //
    KsFreeDefaultClock(ClockInst->Base.DefaultClock);
    KsFreeObjectHeader(ClockInst->Base.Header);
    ExFreePool(ClockInst);
    //
    // Notify the software bus that the device has been closed.
    //
    KsDereferenceSoftwareBusObject(((PDEVICE_INSTANCE)DeviceObject->DeviceExtension)->Header);
    Irp->IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return STATUS_SUCCESS;
}


NTSTATUS
ClockDispatchIoControl(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
/*++

Routine Description:

    The IRP handler for IRP_MJ_DEVICE_CONTROL for the Clock. Handles
    the properties and events supported by this implementation using the
    default handlers provided by KS.

Arguments:

    DeviceObject -
        The device object to which the Clock is attached. This is not used.

    Irp -
        The specific device control IRP to be processed.

Return Value:

    Returns the status of the processing.

--*/
{
    PIO_STACK_LOCATION  IrpStack;
    NTSTATUS            Status;

    IrpStack = IoGetCurrentIrpStackLocation(Irp);
    switch (IrpStack->Parameters.DeviceIoControl.IoControlCode) {
    case IOCTL_KS_PROPERTY:
        Status = KsPropertyHandler(
            Irp,
            SIZEOF_ARRAY(ClockPropertySets),
            (PKSPROPERTY_SET)ClockPropertySets);
        break;
    case IOCTL_KS_ENABLE_EVENT:
        Status = KsEnableEvent(
            Irp,
            SIZEOF_ARRAY(ClockEventSets),
            (PKSEVENT_SET)ClockEventSets,
            NULL,
            0,
            NULL);
        break;
    case IOCTL_KS_DISABLE_EVENT:
    {
        PINSTANCE       ClockInst;

        ClockInst = (PINSTANCE)IrpStack->FileObject->FsContext;
        Status = KsDisableEvent(
            Irp,
            &ClockInst->Base.DefaultClock->EventQueue,
            KSEVENTS_SPINLOCK,
            &ClockInst->Base.DefaultClock->EventQueueLock);
        break;
    }
    default:
        Status = STATUS_INVALID_DEVICE_REQUEST;
        break;
    }
    Irp->IoStatus.Status = Status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\ksfilter\mspqm\device.c ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1998

Module Name:

    device.c

Abstract:

    Device entry point and hardware validation.

--*/

#include "mspqm.h"

#ifdef ALLOC_PRAGMA
NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT   DriverObject,
    IN PUNICODE_STRING  RegistryPathName
    );

#pragma alloc_text(INIT, DriverEntry)
#endif // ALLOC_PRAGMA


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT   DriverObject,
    IN PUNICODE_STRING  RegistryPathName
    )
/*++

Routine Description:

    Sets up the driver object to handle the KS interface and PnP Add Device
    request. Does not set up a handler for PnP Irp's, as they are all dealt
    with directly by the PDO.

Arguments:

    DriverObject -
        Driver object for this instance.

    RegistryPathName -
        Contains the registry path which was used to load this instance.

Return Values:

    Returns STATUS_SUCCESS.

--*/
{
    DriverObject->MajorFunction[IRP_MJ_PNP] = KsDefaultDispatchPnp;
    DriverObject->MajorFunction[IRP_MJ_POWER] = KsDefaultDispatchPower;
    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = KsDefaultForwardIrp;
    DriverObject->DriverExtension->AddDevice = PnpAddDevice;
    DriverObject->DriverUnload = KsNullDriverUnload;
    KsSetMajorFunctionHandler(DriverObject, IRP_MJ_CREATE);
    KsSetMajorFunctionHandler(DriverObject, IRP_MJ_CLOSE);
    KsSetMajorFunctionHandler(DriverObject, IRP_MJ_DEVICE_CONTROL);
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\ksfilter\mspqm\mspqm.c ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    mspqm.c

Abstract:

    Kernel proxy for Quality Manager.

--*/

#include "mspqm.h"

#ifdef WIN98GOLD
#define KeEnterCriticalRegion()
#define KeLeaveCriticalRegion()
#endif

typedef struct {
    KSDEVICE_HEADER     Header;
} DEVICE_INSTANCE, *PDEVICE_INSTANCE;

typedef struct {
    LIST_ENTRY  Queue;
    KSQUALITY   Quality;
} QUALITYITEM, *PQUALITYITEM;

typedef struct {
    LIST_ENTRY  Queue;
    KSERROR     Error;
} ERRORITEM, *PERRORITEM;

#define QUALITYREPORT 0
#define ERRORREPORT 1
#define REPORTTYPES 2

typedef struct {
    KSOBJECT_HEADER     Header;
    KSPIN_LOCK          ClientReportLock[REPORTTYPES];
    LIST_ENTRY          ClientReportQueue[REPORTTYPES];
    FAST_MUTEX          Mutex[REPORTTYPES];
    LIST_ENTRY          Queue[REPORTTYPES];
    ULONG               QueueLimit[REPORTTYPES];
} INSTANCE, *PINSTANCE;

//
// Limit the number of items which can stack up on the complaint/error
// queue in case the client stops processing complaints/errors.
//
#define QUEUE_LIMIT     256

//
// Represents the location at which a pointer to a quality complaint/error
// is temporarily stored when completing an old client Irp with a
// new complaint/error.
//
#define REPORT_IRP_STORAGE(Irp) (Irp)->Tail.Overlay.DriverContext[3]

NTSTATUS
PropertyGetReportComplete(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    OUT PVOID Report
    );
NTSTATUS
PropertySetReport(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    IN PVOID Report
    );
NTSTATUS
PropertyGetReport(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    OUT PVOID Report
    );
NTSTATUS
QualityDispatchCreate(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );
NTSTATUS
QualityDispatchIoControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );
NTSTATUS
QualityDispatchClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, PnpAddDevice)
#pragma alloc_text(PAGE, PropertyGetReportComplete)
#pragma alloc_text(PAGE, PropertySetReport)
#pragma alloc_text(PAGE, PropertyGetReport)
#pragma alloc_text(PAGE, QualityDispatchCreate)
#pragma alloc_text(PAGE, QualityDispatchClose)
#pragma alloc_text(PAGE, QualityDispatchIoControl)
#endif // ALLOC_PRAGMA

static const WCHAR DeviceTypeName[] = L"{97EBAACB-95BD-11D0-A3EA-00A0C9223196}";

static const DEFINE_KSCREATE_DISPATCH_TABLE(CreateItems) {
    DEFINE_KSCREATE_ITEM(QualityDispatchCreate, DeviceTypeName, 0)
};

static DEFINE_KSDISPATCH_TABLE(
    QualityDispatchTable,
    QualityDispatchIoControl,
    NULL,
    NULL,
    NULL,
    QualityDispatchClose,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL);

DEFINE_KSPROPERTY_TABLE(QualityPropertyItems) {
    DEFINE_KSPROPERTY_ITEM_QUALITY_REPORT(PropertyGetReport, PropertySetReport),
    DEFINE_KSPROPERTY_ITEM_QUALITY_ERROR(PropertyGetReport, PropertySetReport)
};

DEFINE_KSPROPERTY_SET_TABLE(QualityPropertySets) {
    DEFINE_KSPROPERTY_SET(
        &KSPROPSETID_Quality,
        SIZEOF_ARRAY(QualityPropertyItems),
        QualityPropertyItems,
        0, NULL
    )
};


NTSTATUS
PnpAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    )
/*++

Routine Description:

    When a new device is detected, PnP calls this entry point with the
    new PhysicalDeviceObject (PDO). The driver creates an associated 
    FunctionalDeviceObject (FDO).

Arguments:

    DriverObject -
        Pointer to the driver object.

    PhysicalDeviceObject -
        Pointer to the new physical device object.

Return Values:

    STATUS_SUCCESS or an appropriate error condition.

--*/
{
    PDEVICE_OBJECT      FunctionalDeviceObject;
    PDEVICE_INSTANCE    DeviceInstance;
    NTSTATUS            Status;

    Status = IoCreateDevice(
        DriverObject,
        sizeof(*DeviceInstance),
        NULL,
        FILE_DEVICE_KS,
        0,
        FALSE,
        &FunctionalDeviceObject);
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    DeviceInstance = (PDEVICE_INSTANCE)FunctionalDeviceObject->DeviceExtension;
    //
    // This object uses KS to perform access through the DeviceCreateItems.
    //
    Status = KsAllocateDeviceHeader(
        &DeviceInstance->Header,
        SIZEOF_ARRAY(CreateItems),
        (PKSOBJECT_CREATE_ITEM)CreateItems);
    if (NT_SUCCESS(Status)) {
        KsSetDevicePnpAndBaseObject(
            DeviceInstance->Header,
            IoAttachDeviceToDeviceStack(
                FunctionalDeviceObject, 
                PhysicalDeviceObject),
            FunctionalDeviceObject);
        FunctionalDeviceObject->Flags |= DO_POWER_PAGABLE;
        FunctionalDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;
        return STATUS_SUCCESS;
    }
    IoDeleteDevice(FunctionalDeviceObject);
    return Status;
}


NTSTATUS
PropertyGetReportComplete(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    OUT PVOID Report
    )
/*++

Routine Description:

    Completes the Get Report property after it has been previously
    queued. Assumes that REPORT_IRP_STORAGE(Irp) points to a new quality/error
    complaint report to copy to the client's buffer.

Arguments:

    Irp -
        Contains the Get Report property IRP.

    Property -
        Contains the property identifier parameter.

    Report -
        Contains a pointer in which to put the client report.

Return Value:

    Return STATUS_SUCCESS.

--*/
{
    switch (Property->Id) {
    case KSPROPERTY_QUALITY_REPORT:
        //
        // Assumes that the QUALITY_IRP_STORAGE(Irp) has been filled in with
        // a pointer to a quality complaint.
        //
        *(PKSQUALITY)Report = *(PKSQUALITY)REPORT_IRP_STORAGE(Irp);
        Irp->IoStatus.Information = sizeof(KSQUALITY);
        break;
    case KSPROPERTY_QUALITY_ERROR:
        //
        // Assumes that the ERROR_IRP_STORAGE(Irp) has been filled in with
        // a pointer to a quality complaint.
        //
        *(PKSERROR)Report = *(PKSERROR)REPORT_IRP_STORAGE(Irp);
        Irp->IoStatus.Information = sizeof(KSERROR);
        break;
    }
    Irp->IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return STATUS_SUCCESS;
}


NTSTATUS
PropertySetReport(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    IN PVOID Report
    )
/*++

Routine Description:

    Handles the Set Report property

Arguments:

    Irp -
        Contains the Set Quality/Error Report property IRP.

    Property -
        Contains the property identifier parameter.

    Report -
        Contains a pointer to the quality/error report.

Return Value:

    Return STATUS_SUCCESS if the report was made, else an error.

--*/
{
    PINSTANCE       QualityInst;
    ULONG           ReportType;

    //
    // There are only two types of reports at this time.
    //
    ASSERT((Property->Id == KSPROPERTY_QUALITY_REPORT) || (Property->Id == KSPROPERTY_QUALITY_ERROR));
    ReportType = (Property->Id == KSPROPERTY_QUALITY_REPORT) ? QUALITYREPORT : ERRORREPORT;
    QualityInst = (PINSTANCE)IoGetCurrentIrpStackLocation(Irp)->FileObject->FsContext;
    //
    // Acquire the list lock for the queue before checking the Irp queue.
    // This allows synchronization with placing Irp's on the queue so that
    // all complaints will be serviced if there is a client Irp on the
    // queue.
    //
    KeEnterCriticalRegion();
    ExAcquireFastMutexUnsafe(&QualityInst->Mutex[ReportType]);
    //
    // Check to see if there is a pending client Irp which can be completed
    // with this quality complaint. If so, remove it from the list.
    // 
    Irp = KsRemoveIrpFromCancelableQueue(
        &QualityInst->ClientReportQueue[ReportType],
        &QualityInst->ClientReportLock[ReportType],
        KsListEntryHead,
        KsAcquireAndRemove);
    ExReleaseFastMutexUnsafe(&QualityInst->Mutex[ReportType]);
    KeLeaveCriticalRegion();
    if (Irp) {
        //
        // Complete this old Irp with the new quality/error complaint information.
        //
        REPORT_IRP_STORAGE(Irp) = Report;
        return KsDispatchSpecificProperty(Irp, PropertyGetReportComplete);
    }
    //
    // Acquire the list lock before adding the item to the end of the
    // list.
    //
    KeEnterCriticalRegion();
    ExAcquireFastMutexUnsafe(&QualityInst->Mutex[ReportType]);
    //
    // If the client has just let things build up, then make sure the list
    // length is limited so as to not use up infinite resources.
    //
    if (QualityInst->QueueLimit[ReportType] == QUEUE_LIMIT) {
        ExReleaseFastMutexUnsafe(&QualityInst->Mutex[ReportType]);
        KeLeaveCriticalRegion();
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    //
    // The bad case is wherein the client is behind in queuing Irp's to
    // cover the number of quality complaints. In this case allocate a list
    // item and make a copy of the complaint. This will be retrieved on
    // receiving a new client Irp.
    //
    switch (ReportType) {
        PQUALITYITEM    QualityItem;
        PERRORITEM      ErrorItem;

    case QUALITYREPORT:
        if (!(QualityItem = 
                ExAllocatePoolWithTag( PagedPool, sizeof(*QualityItem), 'rqSK' ))) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        QualityItem->Quality = *(PKSQUALITY)Report;
        InsertTailList(&QualityInst->Queue[QUALITYREPORT], &QualityItem->Queue);
        break;
    case ERRORREPORT:
        if (!(ErrorItem = 
                ExAllocatePoolWithTag( PagedPool, sizeof(*ErrorItem), 'reSK' ))) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        ErrorItem->Error = *(PKSERROR)Report;
        InsertTailList(&QualityInst->Queue[ERRORREPORT], &ErrorItem->Queue);
        break;
    }
    QualityInst->QueueLimit[ReportType]++;
    ExReleaseFastMutexUnsafe(&QualityInst->Mutex[ReportType]);
    KeLeaveCriticalRegion();
    return STATUS_SUCCESS;
}


NTSTATUS
PropertyGetReport(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    OUT PVOID Report
    )
/*++

Routine Description:

    Handles the Get Report property. If there are no outstanding complaints,
    queues the request so that it may be used to fulfill a later quality
    management complaint.

Arguments:

    Irp -
        Contains the Get Quality Report property IRP to complete or queue.

    Property -
        Contains the property identifier parameter.

    Report -
        Contains a pointer to the quality/error report.

Return Value:

    Return STATUS_SUCCESS if a report was immediately returned, else
    STATUS_PENDING.

--*/
{
    PINSTANCE       QualityInst;
    ULONG           ReportType;

    //
    // There are only two types of reports at this time.
    //
    ASSERT((Property->Id == KSPROPERTY_QUALITY_REPORT) || (Property->Id == KSPROPERTY_QUALITY_ERROR));
    ReportType = (Property->Id == KSPROPERTY_QUALITY_REPORT) ? QUALITYREPORT : ERRORREPORT;
    QualityInst = (PINSTANCE)IoGetCurrentIrpStackLocation(Irp)->FileObject->FsContext;
    //
    // Acquire the list lock before checking to determine if there are any
    // outstanding items on the list which can be serviced with this Irp.
    //
    KeEnterCriticalRegion();
    ExAcquireFastMutexUnsafe(&QualityInst->Mutex[ReportType]);
    if (!IsListEmpty(&QualityInst->Queue[ReportType])) {
        PLIST_ENTRY     ListEntry;

        //
        // The client is behind, and needs to grab the top item from the
        // list of complaints. They are serviced in FIFO order, since a
        // new complaint may supercede an old one.
        //
        ListEntry = RemoveHeadList(&QualityInst->Queue[ReportType]);
        //
        // Adjust the number of items on the queue which is used to limit
        // outstanding items so they won't build up forever.
        //
        QualityInst->QueueLimit[ReportType]--;
        ExReleaseFastMutexUnsafe(&QualityInst->Mutex[ReportType]);
        KeLeaveCriticalRegion();
        switch (ReportType) {
            PQUALITYITEM    QualityItem;
            PERRORITEM      ErrorItem;

        case QUALITYREPORT:
            QualityItem = (PQUALITYITEM)CONTAINING_RECORD(ListEntry, QUALITYITEM, Queue);
            *(PKSQUALITY)Report = QualityItem->Quality;
            //
            // All quality complaints on the queue have been previously allocated
            // from a pool, and must be freed here.
            //
            ExFreePool(QualityItem);
            Irp->IoStatus.Information = sizeof(KSQUALITY);
            break;
        case ERRORREPORT:
            ErrorItem = (PERRORITEM)CONTAINING_RECORD(ListEntry, ERRORITEM, Queue);
            *(PKSERROR)Report = ErrorItem->Error;
            //
            // All error complaints on the queue have been previously allocated
            // from a pool, and must be freed here.
            //
            ExFreePool(ErrorItem);
            Irp->IoStatus.Information = sizeof(KSERROR);
            break;
        }
        return STATUS_SUCCESS;
    }
    //
    // Else just add the client Irp to the queue which can be used to
    // immediately service any new quality complaints.
    //
    KsAddIrpToCancelableQueue(&QualityInst->ClientReportQueue[ReportType],
        &QualityInst->ClientReportLock[ReportType],
        Irp,
        KsListEntryTail,
        NULL);
    //
    // The list lock must be released after adding the Irp to the list
    // so that complaints looking for an Irp can synchronize with any
    // new Irp being placed on the list.
    //
    ExReleaseFastMutexUnsafe(&QualityInst->Mutex[ReportType]);
    KeLeaveCriticalRegion();
    return STATUS_PENDING;
}


NTSTATUS
QualityDispatchCreate(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    The IRP handler for IRP_MJ_CREATE for the Quality Manager. Initializes data
    structures and associates the IoGetCurrentIrpStackLocation(Irp)->FileObject
    with this Quality Manager using a dispatch table (KSDISPATCH_TABLE).

Arguments:

    DeviceObject -
        The device object to which the Quality Manager is attached. This is not
        used.

    Irp -
        The specific close IRP to be processed.

Return Value:

    Returns STATUS_SUCCESS, else a memory allocation error.

--*/
{
    NTSTATUS            Status;

    //
    // Notify the software bus that this device is in use.
    //
    Status = KsReferenceSoftwareBusObject(((PDEVICE_INSTANCE)DeviceObject->DeviceExtension)->Header);
    if (NT_SUCCESS(Status)) {
        PINSTANCE           QualityInst;

        if (QualityInst = (PINSTANCE)ExAllocatePoolWithTag(NonPagedPool, sizeof(*QualityInst), 'IFsK')) {
            //
            // Allocate the header structure.
            //
            if (NT_SUCCESS(Status = KsAllocateObjectHeader(&QualityInst->Header,
                0,
                NULL,
                Irp,
                (PKSDISPATCH_TABLE)&QualityDispatchTable))) {
                ULONG   ReportType;

                for (ReportType = 0; ReportType < REPORTTYPES; ReportType++) {
                    KeInitializeSpinLock(&QualityInst->ClientReportLock[ReportType]);
                    InitializeListHead(&QualityInst->ClientReportQueue[ReportType]);
                    ExInitializeFastMutex(&QualityInst->Mutex[ReportType]);
                    InitializeListHead(&QualityInst->Queue[ReportType]);
                    QualityInst->QueueLimit[ReportType] = 0;
                }
                IoGetCurrentIrpStackLocation(Irp)->FileObject->FsContext = QualityInst;
                Status = STATUS_SUCCESS;
            } else {
                ExFreePool(QualityInst);
            }
        } else {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
        if (!NT_SUCCESS(Status)) {
            KsDereferenceSoftwareBusObject(((PDEVICE_INSTANCE)DeviceObject->DeviceExtension)->Header);
        }
    }
    Irp->IoStatus.Status = Status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return Status;
}


NTSTATUS
QualityDispatchClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    The IRP handler for IRP_MJ_CLOSE for the Quality Manager.

Arguments:

    DeviceObject -
        The device object to which the Quality Manager is attached. This is
        not used.

    Irp -
        The specific close IRP to be processed.

Return Value:

    Returns STATUS_SUCCESS.

--*/
{
    PIO_STACK_LOCATION  IrpStack;
    PINSTANCE           QualityInst;
    ULONG               ReportType;

    IrpStack = IoGetCurrentIrpStackLocation(Irp);
    QualityInst = (PINSTANCE)IrpStack->FileObject->FsContext;
    for (ReportType = 0; ReportType < REPORTTYPES; ReportType++) {
        //
        // There may be client Irp's on the queue still that need to be
        // cancelled.
        //
        KsCancelIo(&QualityInst->ClientReportQueue[ReportType], &QualityInst->ClientReportLock[ReportType]);
        //
        // Or there may be old quality complaints still outstanding.
        //
        while (!IsListEmpty(&QualityInst->Queue[ReportType])) {
            PLIST_ENTRY     ListEntry;

            ListEntry = RemoveHeadList(&QualityInst->Queue[ReportType]);
            switch (ReportType) {
                PQUALITYITEM    QualityItem;
                PERRORITEM      ErrorItem;

            case QUALITYREPORT:
                QualityItem = (PQUALITYITEM)CONTAINING_RECORD(ListEntry, QUALITYITEM, Queue);
                ExFreePool(QualityItem);
                break;
            case ERRORREPORT:
                ErrorItem = (PERRORITEM)CONTAINING_RECORD(ListEntry, ERRORITEM, Queue);
                ExFreePool(ErrorItem);
                break;
            }
        }
    }
    //
    // The header was allocated when the object was created.
    //
    KsFreeObjectHeader(QualityInst->Header);
    //
    // As was the FsContext.
    //
    ExFreePool(QualityInst);
    //
    // Notify the software bus that the device has been closed.
    //
    KsDereferenceSoftwareBusObject(((PDEVICE_INSTANCE)DeviceObject->DeviceExtension)->Header);
    Irp->IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return STATUS_SUCCESS;
}


NTSTATUS
QualityDispatchIoControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    The IRP handler for IRP_MJ_DEVICE_CONTROL for the Quality Manager. Handles
    the properties and events supported by this implementation.

Arguments:

    DeviceObject -
        The device object to which the Quality Manager is attached. This is not
        used.

    Irp -
        The specific device control IRP to be processed.

Return Value:

    Returns the status of the processing.

--*/
{
    PIO_STACK_LOCATION  IrpStack;
    NTSTATUS            Status;

    IrpStack = IoGetCurrentIrpStackLocation(Irp);
    switch (IrpStack->Parameters.DeviceIoControl.IoControlCode) {
    case IOCTL_KS_PROPERTY:
        Status = KsPropertyHandler(Irp,
            SIZEOF_ARRAY(QualityPropertySets),
            (PKSPROPERTY_SET)QualityPropertySets);
        break;
    default:
        Status = STATUS_INVALID_DEVICE_REQUEST;
        break;
    }
    //
    // A client Irp may be queued if there are no quality complaints in
    // the list to service.
    //
    if (Status != STATUS_PENDING) {
        Irp->IoStatus.Status = Status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\ksfilter\mstee\device.c ===
/*++

    Copyright (C) Microsoft Corporation, 1997 - 1998

Module Name:

    device.c

Abstract:
    
    This module implements the device object interface.

Author:

    Bryan A. Woodruff (bryanw) 13-Mar-1997

--*/

#define KSDEBUG_INIT

#include "private.h"

#ifdef ALLOC_PRAGMA
NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPathName
    );

#pragma alloc_text(INIT, DriverEntry)
#endif // ALLOC_PRAGMA

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

NTSTATUS 
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPathName
    )
{
    return 
        KsInitializeDriver(
            DriverObject,
            RegistryPathName,
            &DeviceDescriptor);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\ksfilter\mspqm\sources.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    sources.

!ENDIF

MAJORCOMP=ntos
MINORCOMP=dd

TARGETNAME=mspqm
TARGETPATH=obj
TARGETTYPE=DRIVER
TARGETLIBS=$(DDK_LIB_PATH)\ks.lib\
    $(DDK_LIB_PATH)\ksguid.lib

DRIVERTYPE=WDM

MSC_WARNING_LEVEL=/W3 /WX
C_DEFINES=$(C_DEFINES) -D_WIN32 -DUNICODE -D_UNICODE -DDEBUG_LEVEL=DEBUGLVL_BLAB

VC40_HACK=1
LINKER_FLAGS =$(LINKER_FLAGS) -map -merge:.rdata=PAGE -merge:PAGECONST=PAGE

SOURCES=\
        $(TARGETNAME).rc \
        $(TARGETNAME).c \
        device.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\ksfilter\mstee\filter.c ===
/*++

    Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    filter.c

Abstract:

    This module implements the filter object interface.

Author:

    Bryan A. Woodruff (bryanw) 13-Mar-1997

--*/


#include "private.h"

#ifdef ALLOC_PRAGMA
NTSTATUS
IntersectHandler(
    IN PVOID Filter,
    IN PIRP Irp,
    IN PKSP_PIN PinInstance,
    IN PKSDATARANGE CallerDataRange,
    IN PKSDATARANGE DescriptorDataRange,
    IN ULONG BufferSize,
    OUT PVOID Data OPTIONAL,
    OUT PULONG DataSize
    );

#pragma alloc_text(PAGE, FilterProcess)
#pragma alloc_text(PAGE, IntersectHandler)
#endif // ALLOC_PRAGMA

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("PAGECONST")
#endif // ALLOC_DATA_PRAGMA

//
// This type of definition is required because the compiler will not otherwise
// put these GUIDs in a paged segment.
//
const
GUID
NodeType0 = {STATICGUIDOF(KSCATEGORY_COMMUNICATIONSTRANSFORM)};
const
GUID
NodeType1 = {STATICGUIDOF(KSCATEGORY_SPLITTER)};

//
// Define the topologies for this filter
//
const
KSNODE_DESCRIPTOR
NodeDescriptors[] =
{
    DEFINE_NODE_DESCRIPTOR(NULL,&NodeType0,NULL),
    DEFINE_NODE_DESCRIPTOR(NULL,&NodeType1,NULL)
};

//
// Topology connections for the splitter includes the communications transform.
//
// Filter In (FN,0)
//      (0,0) Communication Transform (0,1)
//      (1,0) Splitter (1,1)
// Filter Out (FN,1)
//


const KSTOPOLOGY_CONNECTION ConnectionsSplitter[] = {
    { KSFILTER_NODE,    ID_DATA_SOURCE_PIN, 0,              0 },
    { 0,                1,                  1,              0 },
    { 1,                0,                  KSFILTER_NODE,  ID_DATA_DESTINATION_PIN  }
};

//
// Topology connections for the communication transform
//
// Filter In (FN,0)
//      (0,0) Communication Transform (0,1)
// Filter Out (FN,1)
//

const KSTOPOLOGY_CONNECTION ConnectionsCommTransform[] = {
    { KSFILTER_NODE,    ID_DATA_SOURCE_PIN, 0,              0 },
    { 0,                1,                  KSFILTER_NODE,  ID_DATA_DESTINATION_PIN  }
};    

//
// Define the wildcard data format.
//

const KSDATARANGE WildcardDataFormat =
{
    sizeof( WildcardDataFormat ),
    0, // ULONG Flags
    0, // ULONG SampleSize
    0, // ULONG Reserved
    STATICGUIDOF( KSDATAFORMAT_TYPE_WILDCARD ),
    STATICGUIDOF( KSDATAFORMAT_SUBTYPE_WILDCARD ),
    STATICGUIDOF( KSDATAFORMAT_SPECIFIER_WILDCARD )
};


const PKSDATARANGE PinFormatRanges[] =
{
    (PKSDATARANGE)&WildcardDataFormat
};


//
// Define pin allocator framing.
//

DECLARE_SIMPLE_FRAMING_EX(
    AllocatorFraming, 
    STATIC_KSMEMORY_TYPE_KERNEL_PAGED, 
    KSALLOCATOR_REQUIREMENTF_SYSTEM_MEMORY | 
    KSALLOCATOR_REQUIREMENTF_INPLACE_MODIFIER |
    KSALLOCATOR_FLAG_INSIST_ON_FRAMESIZE_RATIO |
    KSALLOCATOR_REQUIREMENTF_PREFERENCES_ONLY,
    3,
    0,
    2 * PAGE_SIZE,
    2 * PAGE_SIZE
);

//
// Define splitter pins.
//

const
KSPIN_DISPATCH
PinDispatch =
{
    PinCreate,
    PinClose,
    NULL,// Process
    NULL,// Reset
    NULL,// SetDataFormat
    NULL,// SetDeviceState
    NULL,// Connect
    NULL// Disconnect
};

const
KSPIN_DESCRIPTOR_EX
PinDescriptorsSplitter[] =
{
    {   
        &PinDispatch,
        NULL,
        {
            DEFINE_KSPIN_DEFAULT_INTERFACES,
            DEFINE_KSPIN_DEFAULT_MEDIUMS,
            SIZEOF_ARRAY(PinFormatRanges),
            PinFormatRanges,
            KSPIN_DATAFLOW_OUT,
            KSPIN_COMMUNICATION_BOTH,
            NULL,//Name
            NULL,//Category
            0
        },
        KSPIN_FLAG_SPLITTER,//Flags
        KSINSTANCE_INDETERMINATE,
        1,
        &AllocatorFraming,//AllocatorFraming,
        IntersectHandler
    },
    {   
        &PinDispatch,
        NULL,
        {
            DEFINE_KSPIN_DEFAULT_INTERFACES,
            DEFINE_KSPIN_DEFAULT_MEDIUMS,
            SIZEOF_ARRAY(PinFormatRanges),
            PinFormatRanges,
            KSPIN_DATAFLOW_IN,
            KSPIN_COMMUNICATION_BOTH,
            NULL,//Name
            NULL,//Category
            0
        },
        0,//Flags
        1,
        1,
        &AllocatorFraming,//AllocatorFraming,
        IntersectHandler
    }
};


//
// Define communication transform pins.
//

const
KSPIN_DESCRIPTOR_EX
PinDescriptorsCommTransform[] =
{
    {   
        &PinDispatch,
        NULL,
        {
            DEFINE_KSPIN_DEFAULT_INTERFACES,
            DEFINE_KSPIN_DEFAULT_MEDIUMS,
            SIZEOF_ARRAY(PinFormatRanges),
            PinFormatRanges,
            KSPIN_DATAFLOW_OUT,
            KSPIN_COMMUNICATION_BOTH,
            NULL,
            NULL,
            0
        },
        0,//Flags
        1,
        1,
        &AllocatorFraming,//AllocatorFraming,
        IntersectHandler
    },
    {   
        &PinDispatch,
        NULL,
        {
            DEFINE_KSPIN_DEFAULT_INTERFACES,
            DEFINE_KSPIN_DEFAULT_MEDIUMS,
            SIZEOF_ARRAY(PinFormatRanges),
            PinFormatRanges,
            KSPIN_DATAFLOW_IN,
            KSPIN_COMMUNICATION_BOTH,
            NULL,
            NULL,
            0
        },
        0,//Flags
        1,
        1,
        &AllocatorFraming,//AllocatorFraming,
        IntersectHandler
    }
};


//
// Define filter dispatch table.
//

const
KSFILTER_DISPATCH
FilterDispatch =
{
    NULL, // Create
    NULL, // Close
    FilterProcess,
    NULL // Reset
};


//
// Define filters.
//

DEFINE_KSFILTER_DESCRIPTOR(FilterDescriptorSplitter)
{   
    &FilterDispatch,
    NULL,//AutomationTable;
    KSFILTER_DESCRIPTOR_VERSION,
    0,//Flags
    &KSCATEGORY_SPLITTER,
    DEFINE_KSFILTER_PIN_DESCRIPTORS(PinDescriptorsSplitter),
    DEFINE_KSFILTER_CATEGORY(KSCATEGORY_SPLITTER),
    DEFINE_KSFILTER_NODE_DESCRIPTORS(NodeDescriptors),
    DEFINE_KSFILTER_CONNECTIONS(ConnectionsSplitter),
    NULL // ComponentId
};

DEFINE_KSFILTER_DESCRIPTOR(FilterDescriptorCommTransform)
{   
    &FilterDispatch,
    NULL,//AutomationTable;
    KSFILTER_DESCRIPTOR_VERSION,
    0,//Flags
    &KSCATEGORY_COMMUNICATIONSTRANSFORM,
    DEFINE_KSFILTER_PIN_DESCRIPTORS(PinDescriptorsCommTransform),
    DEFINE_KSFILTER_CATEGORY(KSCATEGORY_COMMUNICATIONSTRANSFORM),
    DEFINE_KSFILTER_NODE_DESCRIPTORS(NodeDescriptors),
    DEFINE_KSFILTER_CONNECTIONS(ConnectionsCommTransform),
    NULL // ComponentId
};

DEFINE_KSFILTER_DESCRIPTOR_TABLE(FilterDescriptors)
{
    &FilterDescriptorSplitter,
    &FilterDescriptorCommTransform
};

//
// Define device.
//

const
KSDEVICE_DESCRIPTOR 
DeviceDescriptor =
{   
    NULL,
    SIZEOF_ARRAY(FilterDescriptors),
    FilterDescriptors
};

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg()
#endif // ALLOC_DATA_PRAGMA


NTSTATUS
IntersectHandler(
    IN PVOID Filter,
    IN PIRP Irp,
    IN PKSP_PIN PinInstance,
    IN PKSDATARANGE CallerDataRange,
    IN PKSDATARANGE DescriptorDataRange,
    IN ULONG BufferSize,
    OUT PVOID Data OPTIONAL,
    OUT PULONG DataSize
    )

/*++

Routine Description:

    This routine handles pin intersection queries by determining the
    intersection between two data ranges.

Arguments:

    Filter -
        Contains a void pointer to the  filter structure.

    Irp -
        Contains a pointer to the data intersection property request.

    PinInstance -
        Contains a pointer to a structure indicating the pin in question.

    CallerDataRange -
        Contains a pointer to one of the data ranges supplied by the client
        in the data intersection request.  The format type, subtype and
        specifier are compatible with the DescriptorDataRange.

    DescriptorDataRange -
        Contains a pointer to one of the data ranges from the pin descriptor
        for the pin in question.  The format type, subtype and specifier are
        compatible with the CallerDataRange.

    BufferSize -
        Contains the size in bytes of the buffer pointed to by the Data
        argument.  For size queries, this value will be zero.

    Data -
        Optionally contains a pointer to the buffer to contain the data format
        structure representing the best format in the intersection of the
        two data ranges.  For size queries, this pointer will be NULL.

    DataSize -
        Contains a pointer to the location at which to deposit the size of the
        data format.  This information is supplied by the function when the
        format is actually delivered and in response to size queries.

Return Value:

    STATUS_SUCCESS if there is an intersection and it fits in the supplied
    buffer, STATUS_BUFFER_OVERFLOW for successful size queries, STATUS_NO_MATCH
    if the intersection is empty, or STATUS_BUFFER_TOO_SMALL if the supplied
    buffer is too small.

--*/

{
    PKSFILTER filter = (PKSFILTER) Filter;
    PKSPIN pin;
    NTSTATUS status;

    _DbgPrintF(DEBUGLVL_BLAB,("[IntersectHandler]"));

    PAGED_CODE();

    ASSERT(Filter);
    ASSERT(Irp);
    ASSERT(PinInstance);
    ASSERT(CallerDataRange);
    ASSERT(DescriptorDataRange);
    ASSERT(DataSize);

    //
    // Find a pin instance if there is one.  Try the supplied pin type first.
    // If there is no pin, we fail to force the graph builder to try the
    // other filter.  We need to acquire control because we will be looking
    // at other pins.
    //
    pin = KsFilterGetFirstChildPin(filter,PinInstance->PinId);
    if (! pin) {
        pin = KsFilterGetFirstChildPin(filter,PinInstance->PinId ^ 1);
    }

    if (! pin) {
        status = STATUS_NO_MATCH;
    } else {
        //
        // Verify that the correct subformat and specifier are (or wildcards)
        // in the intersection.
        //
        
        if ((!IsEqualGUIDAligned( 
                &CallerDataRange->SubFormat,
                &pin->ConnectionFormat->SubFormat ) &&
             !IsEqualGUIDAligned( 
                &CallerDataRange->SubFormat,
                &KSDATAFORMAT_SUBTYPE_WILDCARD )) || 
            (!IsEqualGUIDAligned(  
                &CallerDataRange->Specifier, 
                &pin->ConnectionFormat->Specifier ) &&
             !IsEqualGUIDAligned( 
                &CallerDataRange->Specifier,
                &KSDATAFORMAT_SPECIFIER_WILDCARD ))) {
            _DbgPrintF( 
                DEBUGLVL_VERBOSE, 
                ("range does not match current format") );
            status = STATUS_NO_MATCH;
        } else {
            //
            // Validate return buffer size, if the request is only for the
            // size of the resultant structure, return it now.
            //    
            if (!BufferSize) {
                *DataSize = pin->ConnectionFormat->FormatSize;
                status = STATUS_BUFFER_OVERFLOW;
            } else if (BufferSize < pin->ConnectionFormat->FormatSize) {
                status =  STATUS_BUFFER_TOO_SMALL;
            } else {
                *DataSize = pin->ConnectionFormat->FormatSize;
                RtlCopyMemory( Data, pin->ConnectionFormat, *DataSize );
                status = STATUS_SUCCESS;
            }
        }
    } 

    return status;
}


NTSTATUS
FilterProcess(
    IN PKSFILTER Filter,
    IN PKSPROCESSPIN_INDEXENTRY ProcessPinsIndex
    )

/*++

Routine Description:

    This routine is called when there is data to be processed.

Arguments:

    Filter -
        Contains a pointer to the  filter structure.

    ProcessPinsIndex -
        Contains a pointer to an array of process pin index entries.  This
        array is indexed by pin ID.  An index entry indicates the number 
        of pin instances for the corresponding pin type and points to the
        array of pointers to process pins.
        This allows process pin structures to be quickly accessed by pin ID
        when the number of instances per type is not known in advance.

Return Value:

    Indication of whether more processing should be done if frames are 
    available.  A value of STATUS_PENDING indicates that processing should not
    continue even if frames are available on all required queues.  
    STATUS_SUCCESS indicates processing should continue if frames are
    available on all required queues.

--*/

{
    PKSPROCESSPIN *processPin;
    ULONG byteCount;
    PVOID data;
    PKSSTREAM_HEADER header;

    PAGED_CODE();

    //
    // Determine how much data we can process this time.
    //
    ASSERT(ProcessPinsIndex[ID_DATA_SOURCE_PIN].Count == 1);
    processPin = &ProcessPinsIndex[ID_DATA_SOURCE_PIN].Pins[0];

    byteCount = (*processPin)->BytesAvailable;
    data = (*processPin)->Data;
    header = (*processPin)->StreamPointer->StreamHeader;
    (*processPin)->BytesUsed = byteCount;

    if ((*processPin)->InPlaceCounterpart) {
        //
        // A pipe goes through the filter.  All we need to do is indicated
        // number of bytes used on the output pin.
        //
        if ((*processPin)->InPlaceCounterpart->BytesAvailable < byteCount) {
            return STATUS_UNSUCCESSFUL;
        }
        (*processPin)->InPlaceCounterpart->BytesUsed = byteCount;
    } else {
        //
        // The pipe does not go through, so the first pin will be the delegate
        // or copy source for all the others.  A copy is required.
        //
        PKSSTREAM_HEADER destHeader;

        processPin = ProcessPinsIndex[ID_DATA_DESTINATION_PIN].Pins;
        while ((*processPin)->CopySource) {
            processPin++;
        }
        if ((*processPin)->BytesAvailable < byteCount) {
            return STATUS_UNSUCCESSFUL;
        }
        (*processPin)->BytesUsed = byteCount;
        (*processPin)->Terminate = TRUE;

        destHeader = (*processPin)->StreamPointer->StreamHeader;
        ASSERT(header->Size == destHeader->Size);
        destHeader->TypeSpecificFlags = header->TypeSpecificFlags;
        destHeader->PresentationTime = header->PresentationTime;
        destHeader->Duration = header->Duration;
        destHeader->OptionsFlags = header->OptionsFlags & ~KSSTREAM_HEADER_OPTIONSF_ENDOFSTREAM;
        if (destHeader->Size > sizeof(KSSTREAM_HEADER) &&
            destHeader->Size >= header->Size) {
            RtlCopyMemory(destHeader + 1,header + 1,header->Size - sizeof(KSSTREAM_HEADER));
        }
        RtlCopyMemory((*processPin)->Data,data,byteCount);
    }

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\ksfilter\mstee\pins.c ===
/*++

    Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    pins.c

Abstract:

    This module handles the communication transform filters
    (e.g. source to source connections).

Author:

    Bryan A. Woodruff (bryanw) 13-Mar-1997

--*/

#include "private.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, PinCreate)
#pragma alloc_text(PAGE, PinClose)
#pragma alloc_text(PAGE, PinAllocatorFraming)
#endif // ALLOC_PRAGMA

//===========================================================================
//===========================================================================


NTSTATUS
PinCreate(
    IN PKSPIN Pin,
    IN PIRP Irp
    )

/*++

Routine Description:

    Validates pin format on creation.

Arguments:

    Pin -
        Contains a pointer to the  pin structure.

    Irp -
        Contains a pointer to the create IRP.

Return:

    STATUS_SUCCESS or an appropriate error code

--*/

{
    PKSFILTER filter;
    PKSPIN otherPin;
    NTSTATUS status;
    BOOLEAN distribute = FALSE;
    PIKSCONTROL control;

    PAGED_CODE();

    ASSERT(Pin);
    ASSERT(Irp);

    //
    // Find another pin instance if there is one.
    //
    filter = KsPinGetParentFilter(Pin);
    otherPin = KsFilterGetFirstChildPin(filter,Pin->Id ^ 1);
    if (! otherPin) {
        otherPin = KsFilterGetFirstChildPin(filter,Pin->Id);
        if (otherPin == Pin) {
            otherPin = KsPinGetNextSiblingPin(otherPin);
        }
    }

    //
    // Verify the formats are the same if there is another pin.
    //
    if (otherPin) {
        if ((Pin->ConnectionFormat->FormatSize != 
             otherPin->ConnectionFormat->FormatSize) ||
            (Pin->ConnectionFormat->FormatSize != 
             RtlCompareMemory(
                Pin->ConnectionFormat,
                otherPin->ConnectionFormat,
                Pin->ConnectionFormat->FormatSize))) {
            _DbgPrintF(DEBUGLVL_TERSE,("format does not match existing pin's format") );
            return STATUS_INVALID_PARAMETER;
        }
    }

    //
    // Try to obtain the header size from the connected pin.
    //
    status = KsPinGetConnectedPinInterface(Pin,&IID_IKsControl,(PVOID *) &control);
    if (NT_SUCCESS(status)) {
        KSPROPERTY property;
        ULONG bytesReturned;
        
        property.Set = KSPROPSETID_StreamInterface;
        property.Id = KSPROPERTY_STREAMINTERFACE_HEADERSIZE;
        property.Flags = KSPROPERTY_TYPE_GET;
        
        status = 
            control->lpVtbl->KsProperty(
                control,
                &property,
                sizeof(property),
                &Pin->StreamHeaderSize,
                sizeof(Pin->StreamHeaderSize),
                &bytesReturned);
        if ((status == STATUS_NOT_FOUND) || 
            (status == STATUS_PROPSET_NOT_FOUND)) {
            //
            // If the connected pin did not supply a header size, use another
            // pin's value or the default.
            //
            Pin->StreamHeaderSize = otherPin ? otherPin->StreamHeaderSize : 0;
        } else if (NT_SUCCESS(status)) {
            //
            // The property worked.  The resulting value is just the additional
            // size, so add in the standard size.
            //
            Pin->StreamHeaderSize += sizeof(KSSTREAM_HEADER);

            //
            // If there are other pins, figure out if we need to update their
            // header sizes.  Other pins may have the default size (indicated
            // by a zero StreamHeaderSize), but disagreements otherwise are
            // not a good thing.
            //
            if (otherPin) {
                if (! otherPin->StreamHeaderSize) {
                    //
                    // The other 
                    //
                    distribute = TRUE;
                } else {
                    if (otherPin->StreamHeaderSize < Pin->StreamHeaderSize) {
                        distribute = TRUE;
                    } else {
                        Pin->StreamHeaderSize = otherPin->StreamHeaderSize;
                    }
                    if (otherPin->StreamHeaderSize != Pin->StreamHeaderSize) {
                        _DbgPrintF( 
                            DEBUGLVL_TERSE, 
                            ("stream header size disagreement (%d != %d)",
                            otherPin->StreamHeaderSize,
                            Pin->StreamHeaderSize) );
                    }
                }
            }
        }
    } else {
        //
        // This is a sink pin, so we inherit the header size or go with the 
        // default if there are no other pins.
        //
        control = NULL;
        Pin->StreamHeaderSize = otherPin ? otherPin->StreamHeaderSize : 0;
    }

    //
    // Copy allocator framing from the filter if it's there.  Otherwise, if
    // this is a source pin, try to get allocator framing from the connected 
    // pin.
    //
    if (Pin->Context) {
        status = KsEdit(Pin,&Pin->Descriptor,'ETSM');
        if (NT_SUCCESS(status)) {
            ((PKSPIN_DESCRIPTOR_EX)(Pin->Descriptor))->AllocatorFraming = 
                (PKSALLOCATOR_FRAMING_EX) Pin->Context;
        }
    } else if (control) {
        //
        // Sink pin.  Try the extended allocator framing property first.
        //
        KSPROPERTY property;
        ULONG bufferSize;
        
        property.Set = KSPROPSETID_Connection;
        property.Id = KSPROPERTY_CONNECTION_ALLOCATORFRAMING_EX;
        property.Flags = KSPROPERTY_TYPE_GET;
        
        status = 
            control->lpVtbl->KsProperty(
                control,
                &property,
                sizeof(property),
                NULL,
                0,
                &bufferSize);

        if (status == STATUS_BUFFER_OVERFLOW) {
            //
            // It worked!  Now we need to get the actual value into a buffer.
            //
            filter->Context = 
                ExAllocatePoolWithTag(PagedPool,bufferSize,POOLTAG_ALLOCATORFRAMING);

            if (filter->Context) {
                PKSALLOCATOR_FRAMING_EX framingEx = 
                    (PKSALLOCATOR_FRAMING_EX) filter->Context;

                status = 
                    control->lpVtbl->KsProperty(
                        control,
                        &property,
                        sizeof(property),
                        filter->Context,
                        bufferSize,
                        &bufferSize);

                //
                // Sanity check.
                //
                if (NT_SUCCESS(status) && 
                    (bufferSize != 
                        ((framingEx->CountItems) * sizeof(KS_FRAMING_ITEM)) + 
                        sizeof(KSALLOCATOR_FRAMING_EX) - 
                        sizeof(KS_FRAMING_ITEM))) {
                    _DbgPrintF( 
                        DEBUGLVL_TERSE, 
                        ("connected pin's allocator framing property size disagrees with item count"));
                    status = STATUS_UNSUCCESSFUL;
                }

                if (NT_SUCCESS(status)) {
                    //
                    // Mark all the items 'in-place'.
                    //
                    ULONG item;
                    for (item = 0; item < framingEx->CountItems; item++) {
                        framingEx->FramingItem[item].Flags |= 
                            KSALLOCATOR_REQUIREMENTF_INPLACE_MODIFIER |
                            KSALLOCATOR_FLAG_INSIST_ON_FRAMESIZE_RATIO |
                            KSALLOCATOR_REQUIREMENTF_PREFERENCES_ONLY;
                    }
                } else {
                    ExFreePool(filter->Context);
                    filter->Context = NULL;
                }
            } else {
                status = STATUS_INSUFFICIENT_RESOURCES;
            }
        } else {
            //
            // No extended framing.  Try regular framing next.
            //
            KSALLOCATOR_FRAMING framing;
            property.Id = KSPROPERTY_CONNECTION_ALLOCATORFRAMING;

            status = 
                control->lpVtbl->KsProperty(
                    control,
                    &property,
                    sizeof(property),
                    &framing,
                    sizeof(framing),
                    &bufferSize);

            if (NT_SUCCESS(status)) {
                //
                // It worked!  Now we make a copy of the default framing and
                // modify it.
                //
                filter->Context = 
                    ExAllocatePoolWithTag(
                        PagedPool,
                        sizeof(AllocatorFraming),
                        POOLTAG_ALLOCATORFRAMING);

                if (filter->Context) {
                    PKSALLOCATOR_FRAMING_EX framingEx = 
                        (PKSALLOCATOR_FRAMING_EX) filter->Context;

                    //
                    // Use the old-style framing acquired from the connected
                    // pin to modify the framing from the descriptor.
                    //
                    RtlCopyMemory(
                        framingEx,
                        &AllocatorFraming,
                        sizeof(AllocatorFraming));

                    framingEx->FramingItem[0].MemoryType = 
                        (framing.PoolType == NonPagedPool) ? 
                            KSMEMORY_TYPE_KERNEL_NONPAGED : 
                            KSMEMORY_TYPE_KERNEL_PAGED;
                    framingEx->FramingItem[0].Flags = 
                        framing.RequirementsFlags | 
                        KSALLOCATOR_REQUIREMENTF_INPLACE_MODIFIER |
                        KSALLOCATOR_FLAG_INSIST_ON_FRAMESIZE_RATIO |
                        KSALLOCATOR_REQUIREMENTF_PREFERENCES_ONLY;
                    framingEx->FramingItem[0].Frames = framing.Frames;
                    framingEx->FramingItem[0].FileAlignment = 
                        framing.FileAlignment;
                    framingEx->FramingItem[0].FramingRange.Range.MaxFrameSize = 
                    framingEx->FramingItem[0].FramingRange.Range.MinFrameSize = 
                        framing.FrameSize;
                    if (framing.RequirementsFlags & 
                        KSALLOCATOR_REQUIREMENTF_PREFERENCES_ONLY) {
                        framingEx->FramingItem[0].FramingRange.InPlaceWeight = 0;
                        framingEx->FramingItem[0].FramingRange.NotInPlaceWeight = 0;
                    } else {
                        framingEx->FramingItem[0].FramingRange.InPlaceWeight = (ULONG) -1;
                        framingEx->FramingItem[0].FramingRange.NotInPlaceWeight = (ULONG) -1;
                    }
                } else {
                    status = STATUS_INSUFFICIENT_RESOURCES;
                }
            } else {
                //
                // No framing at all.  Oh well.
                //
                status = STATUS_SUCCESS;
            }
        }

        //
        // If we got a good framing structure, tell all the existing pins.
        //
        if (filter->Context) {
            distribute = TRUE;
        }
    } else {
        //
        // This is a sink.
        //
        status = STATUS_SUCCESS;
    }

    //
    // Distribute allocator and header size information to all the pins.
    //
    if (NT_SUCCESS(status) && distribute) {
        ULONG pinId;
        for(pinId = 0; 
            NT_SUCCESS(status) && 
                (pinId < filter->Descriptor->PinDescriptorsCount); 
            pinId++) {
            otherPin = KsFilterGetFirstChildPin(filter,pinId);
            while (otherPin && NT_SUCCESS(status)) {
                status = KsEdit(otherPin,&otherPin->Descriptor,'ETSM');
                if (NT_SUCCESS(status)) {
                    ((PKSPIN_DESCRIPTOR_EX)(otherPin->Descriptor))->
                        AllocatorFraming = 
                            filter->Context;
                }
                otherPin->StreamHeaderSize = Pin->StreamHeaderSize;
                otherPin = KsPinGetNextSiblingPin(otherPin);
            }
        }
    }

    //
    // Release the control interface if there is one.
    //
    if (control) {
        control->lpVtbl->Release(control);
    }

    return status;
}


NTSTATUS
PinClose(
    IN PKSPIN Pin,
    IN PIRP Irp
    )

/*++

Routine Description:
    Called when a pin closes.

Arguments:
    Pin -
        Contains a pointer to the  pin structure.

    Irp -
        Contains a pointer to the create IRP.

Return:
    STATUS_SUCCESS or an appropriate error code

--*/

{
    PKSFILTER filter;

    PAGED_CODE();

    ASSERT(Pin);
    ASSERT(Irp);

    //
    // If the filter has the allocator framing and this is the last pin, free
    // the structure.
    //
    filter = KsPinGetParentFilter(Pin);
    if (filter->Context) {
        ULONG pinId;
        ULONG pinCount = 0;
        for(pinId = 0; 
            pinId < filter->Descriptor->PinDescriptorsCount; 
            pinId++) {
            pinCount += KsFilterGetChildPinCount(filter,pinId);
        }

        //
        // Free the allocator framing attached to the filter if this is the last
        // pin.
        //
        if (pinCount == 1) {
            ExFreePool(filter->Context);
            filter->Context = NULL;
        }
    }

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\ksfilter\swenum\private.h ===
/*++

    Copyright (C) Microsoft Corporation, 1997 - 1998

Module Name:

    private.h

Abstract:
    Private header file for SWENUM.

Author:

    Bryan A. Woodruff (bryanw) 20-Feb-1997

--*/

#if !defined( _PRIVATE_ )
#define _PRIVATE_

#include <wdm.h>
#include <windef.h>
#include <ks.h>
#include <swenum.h>
#if (DBG)
//
// debugging specific constants
//
#define STR_MODULENAME "swenum: "
#define DEBUG_VARIABLE SWENUMDebug
#endif
#include <ksdebug.h>

//
// Macros
//

NTSTATUS __inline
CompleteIrp(
    PIRP Irp,
    NTSTATUS Status,
    CCHAR PriorityBoost
    )
{
    Irp->IoStatus.Status = Status;
    IoCompleteRequest( Irp, PriorityBoost );
    return Status;
}


//
// Function prototypes
//

NTSTATUS
AddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    );

NTSTATUS
DispatchCreate(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );
    
NTSTATUS
DispatchClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );
    
NTSTATUS
DispatchIoControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );
    
NTSTATUS
DispatchPnP(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
DispatchPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );
    
NTSTATUS
DispatchSystemControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );
    
NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

VOID
DriverUnload(
    IN PDRIVER_OBJECT   DriverObject
    );
    
#endif // _PRIVATE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\ksfilter\swenum\swenum.c ===
/*++

    Copyright (C) Microsoft Corporation, 1997 - 2001

Module Name:

    swenum.c

Abstract:

    Demand load software device enumerator.

Author:

    Bryan A. Woodruff (bryanw) 20-Feb-1997

--*/

#define KSDEBUG_INIT

#include "private.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, AddDevice )
#pragma alloc_text( PAGE, DispatchCreate )
#pragma alloc_text( PAGE, DispatchClose )
#pragma alloc_text( PAGE, DispatchIoControl )
#pragma alloc_text( PAGE, DispatchPnP )
#pragma alloc_text( INIT, DriverEntry )
#endif


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:
    Main driver entry, sets up the bus device object and performs
    first enumeration.

Arguments:
    IN PDRIVER_OBJECT DriverObject -
        pointer to driver object

    IN PUNICODE_STRING RegistryPath -
        pointer to registry path

Return:
    STATUS_SUCCESS else an appropriate error code

--*/

{

    //
    // win98gold ntkern does not fill in the Service name in our
    // driver extension. but we depend on the name to have correct
    // KsCreateBusEnumObject. Try to add the Service name here.
    // Since we are statically loaded, freeing the memory is rarely
    // necessary.
    //
    #ifdef WIN98GOLD
    if ( NULL == DriverObject->DriverExtension->ServiceKeyName.Buffer ) {
        UNICODE_STRING ServiceNameU;
        ULONG          cb;

        cb = RegistryPath->Length;
        ServiceNameU.Buffer = ExAllocatePool( NonPagedPool, cb );
        if ( NULL == ServiceNameU.Buffer ) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        RtlCopyMemory( ServiceNameU.Buffer, RegistryPath->Buffer, cb );
        ServiceNameU.MaximumLength = ServiceNameU.Length = (USHORT)cb;
        DriverObject->DriverExtension->ServiceKeyName = ServiceNameU;
    }
    #endif
    
    _DbgPrintF(
        DEBUGLVL_VERBOSE,
        ("DriverEntry, registry path = %S", RegistryPath->Buffer) );

    //
    // Fill in the driver object
    //

    DriverObject->MajorFunction[ IRP_MJ_PNP ] = DispatchPnP;
    DriverObject->MajorFunction[ IRP_MJ_POWER ] = DispatchPower;
    DriverObject->MajorFunction[ IRP_MJ_CREATE ] = DispatchCreate;
    DriverObject->MajorFunction[ IRP_MJ_DEVICE_CONTROL ] = DispatchIoControl;
    DriverObject->MajorFunction[ IRP_MJ_SYSTEM_CONTROL ] = DispatchSystemControl;
    DriverObject->MajorFunction[ IRP_MJ_CLOSE ] = DispatchClose;
    DriverObject->DriverExtension->AddDevice = AddDevice;
    DriverObject->DriverUnload = DriverUnload;

    return STATUS_SUCCESS;
}


VOID
DriverUnload(
    IN PDRIVER_OBJECT   DriverObject
    )

/*++

Routine Description:
    This is the driver unload routine for SWENUM.  It does nothing.


Arguments:
    IN PDRIVER_OBJECT DriverObject -
        pointer to the driver object

Return:
    Nothing.

--*/

{
    return;
}


NTSTATUS
AddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    )

/*++

Routine Description:
    Called by the PnP manager when a new device is instantiated.

Arguments:
    IN PDRIVER_OBJECT DriverObject -
        pointer to the driver object

    IN PDEVICE_OBJECT PhysicalDeviceObject -
        pointer to the physical device object

Return:
    STATUS_SUCCESS else an appropriate error code

--*/

{
    PDEVICE_OBJECT      FunctionalDeviceObject;
    NTSTATUS            Status;

    PAGED_CODE();

    //
    // On AddDevice, we are given the physical device object (PDO)
    // for the bus.  Create the associcated functional device object (FDO).
    //

    _DbgPrintF( DEBUGLVL_VERBOSE, ("AddDevice") );

    //
    // Note, there is only one instance of this device allowed.  The
    // static device name will guarantee an object name collision if
    // another instance is already installed.
    //

    Status = IoCreateDevice(
                DriverObject,               // our driver object
                sizeof( PVOID ),            // size of our extension
                NULL,                       // our name for the FDO
                FILE_DEVICE_BUS_EXTENDER,   // device type
                0,                          // device characteristics
                FALSE,                      // not exclusive
                &FunctionalDeviceObject     // store new device object here
                );

    if(!NT_SUCCESS( Status )) {
        _DbgPrintF(
            DEBUGLVL_ERROR,
            ("failed to create FDO, status = %x.", Status) );

        return Status;
    }

    //
    // Clear the device extension
    //
    *(PVOID *)FunctionalDeviceObject->DeviceExtension = NULL;

    //
    // Create the bus enumerator object
    //

    Status =
        KsCreateBusEnumObject(
            L"SW",
            FunctionalDeviceObject,
            PhysicalDeviceObject,
            NULL, // PDEVICE_OBJECT PnpDeviceObject
            &BUSID_SoftwareDeviceEnumerator,
            L"Devices" );

    if (!NT_SUCCESS( Status )) {
        _DbgPrintF(
            DEBUGLVL_ERROR,
            ("failed KsCreateBusEnumObject: %08x", Status) );
        IoDeleteDevice( FunctionalDeviceObject );
        return Status;
    }

    FunctionalDeviceObject->Flags |= DO_POWER_PAGABLE;
    FunctionalDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

    return STATUS_SUCCESS;
}

NTSTATUS
DispatchPnP(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )

/*++

Routine Description:
    This is the main entry point for the IRP_MJ_PNP dispatch, the exported
    service is used for processing.

Arguments:
    IN PDEVICE_OBJECT DeviceObject -
        pointer to the device object

    IN OUT PIRP Irp -
        pointer to the associated Irp

Return:
    NTSTATUS code

--*/

{
    BOOLEAN                 ChildDevice;
    PIO_STACK_LOCATION      irpSp;
    NTSTATUS                Status;
    PDEVICE_OBJECT          PnpDeviceObject;

    irpSp = IoGetCurrentIrpStackLocation( Irp );

    //
    // Get the PnpDeviceObject and determine FDO/PDO.
    //

    Status = KsIsBusEnumChildDevice( DeviceObject, &ChildDevice );

    //
    // If we're unable to obtain any of this information, fail now.
    //

    if (!NT_SUCCESS( Status )) {
        return CompleteIrp( Irp, Status, IO_NO_INCREMENT );
    }

    Status = KsServiceBusEnumPnpRequest( DeviceObject, Irp );

    //
    // FDO processing may return STATUS_NOT_SUPPORTED or may require
    // overrides.
    //

    if (!ChildDevice) {
        NTSTATUS tempStatus;

        //
        // FDO case
        //
        // First retrieve the DO we will forward everything to...
        //
        tempStatus = KsGetBusEnumPnpDeviceObject( DeviceObject, &PnpDeviceObject );

        if (!NT_SUCCESS( tempStatus )) {
            //
            // No DO to forward to. Actually a fatal error, but just complete
            // with an error status.
            //
            return CompleteIrp( Irp, tempStatus, IO_NO_INCREMENT );
        }

        switch (irpSp->MinorFunction) {

        case IRP_MN_QUERY_RESOURCES:
        case IRP_MN_QUERY_RESOURCE_REQUIREMENTS:
            //
            // This is normally passed on to the PDO, but since this is a
            // software only device, resources are not required.
            //
            Irp->IoStatus.Information = (ULONG_PTR)NULL;
            Status = STATUS_SUCCESS;
            break;

        case IRP_MN_QUERY_PNP_DEVICE_STATE:
            {
                //
                // Mark the device as not disableable.
                //
                PPNP_DEVICE_STATE DeviceState;

                DeviceState = (PPNP_DEVICE_STATE) &Irp->IoStatus.Information;
                *DeviceState |= PNP_DEVICE_NOT_DISABLEABLE;
                Status = STATUS_SUCCESS;
            }
            break;

        case IRP_MN_QUERY_DEVICE_RELATIONS:

            //
            // Forward everything...
            //
            break;

        case IRP_MN_REMOVE_DEVICE:
            //
            // The KsBusEnum services cleaned up attachments, etc. However,
            // we must remove our own FDO.
            //
            Status = STATUS_SUCCESS;
            IoDeleteDevice( DeviceObject );
            break;
        }

        if (Status != STATUS_NOT_SUPPORTED) {

            //
            // Set the Irp status only if we have something to add.
            //
            Irp->IoStatus.Status = Status;
        }


        //
        // Forward this IRP down the stack only if we are successful or
        // we don't know how to handle this Irp.
        //
        if (NT_SUCCESS( Status ) || (Status == STATUS_NOT_SUPPORTED)) {

            IoSkipCurrentIrpStackLocation(Irp);
            return IoCallDriver( PnpDeviceObject, Irp );
        }

        //
        // On error, fall through and complete the IRP with the status.
        //
    }


    //
    // KsServiceBusEnumPnpRequest() handles all other child PDO requests.
    //

    if (Status != STATUS_NOT_SUPPORTED) {
        Irp->IoStatus.Status = Status;
    } else {
        Status = Irp->IoStatus.Status;
    }
    IoCompleteRequest( Irp, IO_NO_INCREMENT );
    return Status;
}


NTSTATUS
DispatchSystemControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:
    Handler for system control IRPs.

Arguments:
    IN PDEVICE_OBJECT DeviceObject -
        pointer to the device object

    IN PIRP Irp -
        pointer to the I/O request packet for IRP_MJ_SYSTEM_CONTROL

Return:
    NTSTATUS code

--*/

{
    BOOLEAN                 ChildDevice;
    PIO_STACK_LOCATION      irpSp;
    NTSTATUS                Status;
    PDEVICE_OBJECT          PnpDeviceObject;

    //
    // Get the PnpDeviceObject and determine FDO/PDO.
    //

    Status = KsIsBusEnumChildDevice( DeviceObject, &ChildDevice );

    //
    // If we're unable to obtain any of this information, fail now.
    //

    if (!NT_SUCCESS( Status )) {
        return CompleteIrp( Irp, Status, IO_NO_INCREMENT );
    }

    if (!ChildDevice) {

        //
        // FDO case
        //
        // We will need the DO we will forward everything to...
        //
        Status = KsGetBusEnumPnpDeviceObject( DeviceObject, &PnpDeviceObject );

        if (!NT_SUCCESS( Status )) {
            //
            // No DO to forward to. Actually a fatal error, but just complete
            // with an error status.
            //
            return CompleteIrp( Irp, Status, IO_NO_INCREMENT );
        }

        //
        // Forward this IRP down the stack.
        //
        IoSkipCurrentIrpStackLocation(Irp);
        return IoCallDriver( PnpDeviceObject, Irp );
    }

    Status = Irp->IoStatus.Status;
    return CompleteIrp( Irp, Status, IO_NO_INCREMENT );
}


NTSTATUS
DispatchPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:
    Dispatch handler for IRP_MJ_POWER

Arguments:
    IN PDEVICE_OBJECT DeviceObject -
        pointer to the device object

    IN PIRP Irp -
        pointer to the I/O request packet

Return:
    NTSTATUS code

--*/

{
    BOOLEAN                 ChildDevice;
    PIO_STACK_LOCATION      irpSp;
    NTSTATUS                Status;
    PDEVICE_OBJECT          PnpDeviceObject;

    irpSp = IoGetCurrentIrpStackLocation( Irp );

    //
    // Get the PnpDeviceObject and determine FDO/PDO.
    //

    Status = KsIsBusEnumChildDevice( DeviceObject, &ChildDevice );

    //
    // If we're unable to obtain any of this information, fail now.
    //

    if (!NT_SUCCESS( Status )) {
        PoStartNextPowerIrp(Irp);
        return CompleteIrp( Irp, Status, IO_NO_INCREMENT );
    }

    if (!ChildDevice) {

        NTSTATUS tempStatus;

        //
        // FDO case
        //
        // We will need the DO we will forward everything to...
        //
        tempStatus = KsGetBusEnumPnpDeviceObject( DeviceObject, &PnpDeviceObject );

        if (!NT_SUCCESS( tempStatus )) {
            //
            // No DO to forward to. Actually a fatal error, but just complete
            // with an error status.
            //
            PoStartNextPowerIrp(Irp);
            return CompleteIrp( Irp, tempStatus, IO_NO_INCREMENT );
        }
    }

    switch (irpSp->MinorFunction) {

    case IRP_MN_QUERY_POWER:
    case IRP_MN_SET_POWER:

        switch (irpSp->Parameters.Power.Type) {

        case DevicePowerState:
        case SystemPowerState:

            Status = STATUS_SUCCESS;
            break;

        default:
            Status = STATUS_NOT_SUPPORTED;
            break;

        }
        break;

    default:
        Status = STATUS_NOT_SUPPORTED;
        break;
    }

    if (Status != STATUS_NOT_SUPPORTED) {

        Irp->IoStatus.Status = Status;
    }

    if ((!ChildDevice) && (NT_SUCCESS(Status) || (Status == STATUS_NOT_SUPPORTED))) {

        PoStartNextPowerIrp(Irp);
        IoSkipCurrentIrpStackLocation(Irp);
        return PoCallDriver( PnpDeviceObject, Irp );

    } else {
        Status = Irp->IoStatus.Status;
        PoStartNextPowerIrp( Irp );
        return CompleteIrp( Irp, Status, IO_NO_INCREMENT );
    }
}

NTSTATUS
DispatchCreate(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )

/*++

Routine Description:
    Processes the create request for the SWENUM device.

Arguments:
    IN PDEVICE_OBJECT DeviceObject -
        pointer to the device object

    IN OUT PIRP Irp -
        pointer to the I/O request packet

Return:
    NTSTATUS code

--*/

{
    BOOLEAN             ChildDevice;
    NTSTATUS            Status;
    PIO_STACK_LOCATION  irpSp;

    PAGED_CODE();

    Status = KsIsBusEnumChildDevice( DeviceObject, &ChildDevice );
    if (NT_SUCCESS( Status )) {

        irpSp = IoGetCurrentIrpStackLocation( Irp );

        if (!ChildDevice) {
            if (!irpSp->FileObject->FileName.Length) {
                //
                // This is a request for the bus, if and only if there
                // is no filename specified.
                //
                Status = STATUS_SUCCESS;
            } else {
                //
                // Redirection to the child PDO.
                //
                Status = KsServiceBusEnumCreateRequest( DeviceObject, Irp );
            }
        } else {
            Status = STATUS_OBJECT_NAME_NOT_FOUND;
        }
    }

    if (Status != STATUS_PENDING) {
        Irp->IoStatus.Status = Status;
        IoCompleteRequest( Irp, IO_NO_INCREMENT );
    }
    return Status;
}


NTSTATUS
DispatchIoControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )

/*++

Routine Description:
    Process I/O control requests for the SWENUM device.

Arguments:
    IN PDEVICE_OBJECT DeviceObject -
        pointer to the device object

    IN OUT PIRP Irp -
        pointer to the I/O request packet

Return:
    STATUS_SUCCESS or STATUS_INVALID_DEVICE_REQUEST

--*/

{
    NTSTATUS            Status;
    PIO_STACK_LOCATION  irpSp;

    PAGED_CODE();

    irpSp = IoGetCurrentIrpStackLocation( Irp );

    _DbgPrintF( DEBUGLVL_BLAB, ("DispatchIoControl") );

    switch (irpSp->Parameters.DeviceIoControl.IoControlCode) {

    case IOCTL_SWENUM_INSTALL_INTERFACE:
        Status = KsInstallBusEnumInterface( Irp );
        break;

    case IOCTL_SWENUM_GET_BUS_ID:
        Status = KsGetBusEnumIdentifier( Irp );
        break;

    case IOCTL_SWENUM_REMOVE_INTERFACE:
        Status = KsRemoveBusEnumInterface( Irp );
        break;

    default:
        Status = STATUS_INVALID_DEVICE_REQUEST;
        break;

    }

    return CompleteIrp( Irp, Status, IO_NO_INCREMENT );
}


NTSTATUS
DispatchClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )

/*++

Routine Description:
    Processes the close request for the SWENUM device.

Arguments:
    IN PDEVICE_OBJECT DeviceObject -
        pointer to the device object

    IN OUT PIRP Irp -
        pointer to the I/O request packet

Return:
    STATUS_SUCCESS

--*/

{
    PAGED_CODE();

    _DbgPrintF( DEBUGLVL_BLAB, ("DispatchClose") );

    return CompleteIrp( Irp, STATUS_SUCCESS, IO_NO_INCREMENT );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\ksfilter\swenum\sources.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    sources.

!ENDIF

MAJORCOMP=ntos
MINORCOMP=dd

TARGETNAME=swenum
TARGETPATHLIB=$(DDK_LIB_DEST)
TARGETTYPE=DRIVER
TARGETPATH=obj
TARGETLIBS=$(DDK_LIB_PATH)\ks.lib\
    $(DDK_LIB_PATH)\ksguid.lib

DRIVERTYPE=WDM

MSC_WARNING_LEVEL=/W3 /WX

C_DEFINES=$(C_DEFINES) -DUNICODE -D_UNICODE
#C_DEFINES=$(C_DEFINES) -DUNICODE -D_UNICODE -DDEBUG_LEVEL=DEBUGLVL_BLAB

LINKER_FLAGS =$(LINKER_FLAGS) -map -merge:PAGECONST=PAGE

SOURCES=\
        $(TARGETNAME).rc    \
        $(TARGETNAME).c
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\ksfilter\tests\avshws\avshws.h ===
/**************************************************************************

    AVStream Simulated Hardware Sample

    Copyright (c) 2001, Microsoft Corporation.

    File:

        avshws.h

    Abstract:

        AVStream Simulated Hardware Sample header file.  This is the 
        main header.

    History:

        created 3/12/2001

**************************************************************************/

/*************************************************

    Standard Includes

*************************************************/

extern "C" {
#include <wdm.h>
}

#include <windef.h>
#include <stdio.h>
#include <stdlib.h>
#include <windef.h>
#define NOBITMAP
#include <mmreg.h>
#undef NOBITMAP
#include <unknown.h>
#include <ks.h>
#include <ksmedia.h>
#include <kcom.h>

/*************************************************

    Misc Definitions

*************************************************/

#define ABS(x) ((x) < 0 ? (-(x)) : (x))

#ifndef mmioFOURCC    
#define mmioFOURCC( ch0, ch1, ch2, ch3 )                \
        ( (DWORD)(BYTE)(ch0) | ( (DWORD)(BYTE)(ch1) << 8 ) |    \
        ( (DWORD)(BYTE)(ch2) << 16 ) | ( (DWORD)(BYTE)(ch3) << 24 ) )
#endif

#define FOURCC_YUV422       mmioFOURCC('U', 'Y', 'V', 'Y')

//
// CAPTURE_PIN_DATA_RANGE_COUNT:
//
// The number of ranges supported on the capture pin.
//
#define CAPTURE_PIN_DATA_RANGE_COUNT 2

//
// CAPTURE_FILTER_PIN_COUNT:
//
// The number of pins on the capture filter.
//
#define CAPTURE_FILTER_PIN_COUNT 1

//
// CAPTURE_FILTER_CATEGORIES_COUNT:
//
// The number of categories for the capture filter.
//
#define CAPTURE_FILTER_CATEGORIES_COUNT 2

/*************************************************

    Externed information

*************************************************/

//
// filter.cpp externs:
//
extern
const
KSFILTER_DISPATCH
CaptureFilterDispatch;

extern
const
KSFILTER_DESCRIPTOR
CaptureFilterDescriptor;

extern
const
KSPIN_DESCRIPTOR_EX
CaptureFilterPinDescriptors [CAPTURE_FILTER_PIN_COUNT];

extern
const
GUID
CaptureFilterCategories [CAPTURE_FILTER_CATEGORIES_COUNT];

//
// capture.cpp externs:
//
extern 
const
KSALLOCATOR_FRAMING_EX
CapturePinAllocatorFraming;

extern 
const
KSPIN_DISPATCH
CapturePinDispatch;

extern
const
PKSDATARANGE
CapturePinDataRanges [CAPTURE_PIN_DATA_RANGE_COUNT];

/*************************************************

    Enums / Typedefs

*************************************************/

typedef enum _HARDWARE_STATE {

    HardwareStopped = 0,
    HardwarePaused,
    HardwareRunning

} HARDWARE_STATE, *PHARDWARE_STATE;

/*************************************************

    Class Definitions

*************************************************/

//
// IHardwareSink:
//
// This interface is used by the hardware simulation to fake interrupt
// service routines.  The Interrupt method is called at DPC as a fake
// interrupt.
//
class IHardwareSink {

public:

    virtual
    void
    Interrupt (
        ) = 0;

};

//
// ICaptureSink:
//
// This is a capture sink interface.  The device level calls back the
// CompleteMappings method passing the number of completed mappings for
// the capture pin.  This method is called during the device DPC.
//
class ICaptureSink {

public:

    virtual
    void
    CompleteMappings (
        IN ULONG NumMappings
        ) = 0;

};

/*************************************************

    Internal Includes

*************************************************/

#include "image.h"
#include "hwsim.h"
#include "device.h"
#include "filter.h"
#include "capture.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\ksfilter\mstee\private.h ===
/*++

    Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    Private.h

Abstract:


Author:

    Bryan A. Woodruff (bryanw) 13-Mar-1997

--*/


#if !defined( _PRIVATE_ )
#define _PRIVATE_

#include <wdm.h>
#include <windef.h>

#include <memory.h>
#include <stddef.h>
#include <stdio.h>
#include <limits.h>
#include <stdlib.h>
#include <tchar.h>
#include <conio.h>

#define NOBITMAP
#include <mmsystem.h>
#include <mmreg.h>
#undef NOBITMAP
#include <unknown.h>
#include <ks.h>
#include <ksmedia.h>
#if (DBG)
//
// debugging specific constants
//
#define STR_MODULENAME "mstee: "
#define DEBUG_VARIABLE MSTEEDebug
#endif
#include <ksdebug.h>

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

//
// constant definitions
//

#define ID_DATA_DESTINATION_PIN     0
#define ID_DATA_SOURCE_PIN          1

#define POOLTAG_ALLOCATORFRAMING 'ETSM'

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

//
// global data
//
                    
// filter.c:

extern const KSDEVICE_DESCRIPTOR DeviceDescriptor;
extern const KSALLOCATOR_FRAMING_EX AllocatorFraming;

//
// local prototypes
//

//---------------------------------------------------------------------------
// filter.c:

NTSTATUS
FilterProcess(
    IN PKSFILTER Filter,
    IN PKSPROCESSPIN_INDEXENTRY ProcessPinsIndex
    );

//---------------------------------------------------------------------------
// pins.c:

NTSTATUS
PinCreate(
    IN PKSPIN Pin,
    IN PIRP Irp
    );
NTSTATUS
PinClose(
    IN PKSPIN Pin,
    IN PIRP Irp
    );
NTSTATUS PinAllocatorFraming(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    IN OUT PKSALLOCATOR_FRAMING Framing
);

#endif // _PRIVATE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\ksfilter\tests\avshws\capture.cpp ===
/**************************************************************************

    AVStream Simulated Hardware Sample

    Copyright (c) 2001, Microsoft Corporation.

    File:

        capture.cpp

    Abstract:

        This file contains source for the video capture pin on the capture
        filter.  The capture sample performs "fake" DMA directly into
        the capture buffers.  Common buffer DMA will work slightly differently.

        For common buffer DMA, the general technique would be DPC schedules
        processing with KsPinAttemptProcessing.  The processing routine grabs
        the leading edge, copies data out of the common buffer and advances.
        Cloning would not be necessary with this technique.  It would be 
        similiar to the way "AVSSamp" works, but it would be pin-centric.

    History:

        created 3/8/2001

**************************************************************************/

#include "avshws.h"

/**************************************************************************

    PAGEABLE CODE

**************************************************************************/

#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGE")
#endif // ALLOC_PRAGMA


CCapturePin::
CCapturePin (
    IN PKSPIN Pin
    ) :
    m_Pin (Pin)

/*++

Routine Description:

    Construct a new capture pin.

Arguments:

    Pin -
        The AVStream pin object corresponding to the capture pin

Return Value:

    None

--*/

{

    PAGED_CODE();

    PKSDEVICE Device = KsPinGetDevice (Pin);

    //
    // Set up our device pointer.  This gives us access to "hardware I/O"
    // during the capture routines.
    //
    m_Device = reinterpret_cast <CCaptureDevice *> (Device -> Context);

}

/*************************************************/


NTSTATUS
CCapturePin::
DispatchCreate (
    IN PKSPIN Pin,
    IN PIRP Irp
    )

/*++

Routine Description:

    Create a new capture pin.  This is the creation dispatch for
    the video capture pin.

Arguments:

    Pin -
        The pin being created

    Irp -
        The creation Irp

Return Value:

    Success / Failure

--*/

{

    PAGED_CODE();

    NTSTATUS Status = STATUS_SUCCESS;

    CCapturePin *CapPin = new (NonPagedPool) CCapturePin (Pin);

    if (!CapPin) {
        //
        // Return failure if we couldn't create the pin.
        //
        Status = STATUS_INSUFFICIENT_RESOURCES;

    } else {
        //
        // Add the item to the object bag if we we were successful. 
        // Whenever the pin closes, the bag is cleaned up and we will be
        // freed.
        //
        Status = KsAddItemToObjectBag (
            Pin -> Bag,
            reinterpret_cast <PVOID> (CapPin),
            reinterpret_cast <PFNKSFREE> (CCapturePin::Cleanup)
            );

        if (!NT_SUCCESS (Status)) {
            delete CapPin;
        } else {
            Pin -> Context = reinterpret_cast <PVOID> (CapPin);
        }

    }

    //
    // If we succeeded so far, stash the video info header away and change
    // our allocator framing to reflect the fact that only now do we know
    // the framing requirements based on the connection format.
    //
    PKS_VIDEOINFOHEADER VideoInfoHeader = NULL;

    if (NT_SUCCESS (Status)) {

        VideoInfoHeader = CapPin -> CaptureVideoInfoHeader ();
        if (!VideoInfoHeader) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    if (NT_SUCCESS (Status)) {
        
        //
        // We need to edit the descriptor to ensure we don't mess up any other
        // pins using the descriptor or touch read-only memory.
        //
        Status = KsEdit (Pin, &Pin -> Descriptor, 'aChS');

        if (NT_SUCCESS (Status)) {
            Status = KsEdit (
                Pin, 
                &(Pin -> Descriptor -> AllocatorFraming),
                'aChS'
                );
        }

        //
        // If the edits proceeded without running out of memory, adjust 
        // the framing based on the video info header.
        //
        if (NT_SUCCESS (Status)) {

            //
            // We've KsEdit'ed this...  I'm safe to cast away constness as
            // long as the edit succeeded.
            //
            PKSALLOCATOR_FRAMING_EX Framing =
                const_cast <PKSALLOCATOR_FRAMING_EX> (
                    Pin -> Descriptor -> AllocatorFraming
                    );

            Framing -> FramingItem [0].Frames = 2;

            //
            // The physical and optimal ranges must be biSizeImage.  We only
            // support one frame size, precisely the size of each capture
            // image.
            //
            Framing -> FramingItem [0].PhysicalRange.MinFrameSize =
                Framing -> FramingItem [0].PhysicalRange.MaxFrameSize =
                Framing -> FramingItem [0].FramingRange.Range.MinFrameSize =
                Framing -> FramingItem [0].FramingRange.Range.MaxFrameSize =
                VideoInfoHeader -> bmiHeader.biSizeImage;

            Framing -> FramingItem [0].PhysicalRange.Stepping = 
                Framing -> FramingItem [0].FramingRange.Range.Stepping =
                0;

        }

    }

    return Status;

}

/*************************************************/


PKS_VIDEOINFOHEADER 
CCapturePin::
CaptureVideoInfoHeader (
    )

/*++

Routine Description:

    Capture the video info header out of the connection format.  This
    is what we use to base synthesized images off.

Arguments:

    None

Return Value:

    The captured video info header or NULL if there is insufficient
    memory.

--*/

{

    PAGED_CODE();

    PKS_VIDEOINFOHEADER ConnectionHeader =
        &((reinterpret_cast <PKS_DATAFORMAT_VIDEOINFOHEADER> 
            (m_Pin -> ConnectionFormat)) -> 
            VideoInfoHeader);

    m_VideoInfoHeader = reinterpret_cast <PKS_VIDEOINFOHEADER> (
        ExAllocatePool (
            NonPagedPool,
            KS_SIZE_VIDEOHEADER (ConnectionHeader)
            )
        );

    if (!m_VideoInfoHeader)
        return NULL;

    //
    // Bag the newly allocated header space.  This will get cleaned up
    // automatically when the pin closes.
    //
    NTSTATUS Status =
        KsAddItemToObjectBag (
            m_Pin -> Bag,
            reinterpret_cast <PVOID> (m_VideoInfoHeader),
            NULL
            );

    if (!NT_SUCCESS (Status)) {

        ExFreePool (m_VideoInfoHeader);
        return NULL;

    } else {

        //
        // Copy the connection format video info header into the newly 
        // allocated "captured" video info header.
        //
        RtlCopyMemory (
            m_VideoInfoHeader,
            ConnectionHeader,
            KS_SIZE_VIDEOHEADER (ConnectionHeader)
            );

    }

    return m_VideoInfoHeader;

}

/*************************************************/


NTSTATUS
CCapturePin::
Process (
    )

/*++

Routine Description:

    The process dispatch for the pin bridges to this location.
    We handle setting up scatter gather mappings, etc...

Arguments:

    None

Return Value:

    Success / Failure

--*/

{

    PAGED_CODE();

    NTSTATUS Status = STATUS_SUCCESS;
    PKSSTREAM_POINTER Leading;

    Leading = KsPinGetLeadingEdgeStreamPointer (
        m_Pin,
        KSSTREAM_POINTER_STATE_LOCKED
        );

    while (NT_SUCCESS (Status) && Leading) {

        PKSSTREAM_POINTER ClonePointer;
        PSTREAM_POINTER_CONTEXT SPContext;

        //
        // For optimization sake in this particular sample, I will only keep
        // one clone stream pointer per frame.  This complicates the logic
        // here but simplifies the completions.
        //
        // I'm also choosing to do this since I need to keep track of the
        // virtual addresses corresponding to each mapping since I'm faking
        // DMA.  It simplifies that too.
        //
        if (!m_PreviousStreamPointer) {
            //
            // First thing we need to do is clone the leading edge.  This allows
            // us to keep reference on the frames while they're in DMA.
            //
            Status = KsStreamPointerClone (
                Leading,
                NULL,
                sizeof (STREAM_POINTER_CONTEXT),
                &ClonePointer
                );

            //
            // I use this for easy chunking of the buffer.  We're not really
            // dealing with physical addresses.  This keeps track of what 
            // virtual address in the buffer the current scatter / gather 
            // mapping corresponds to for the fake hardware.
            //
            if (NT_SUCCESS (Status)) {

                //
                // Set the stream header data used to 0.  We update this 
                // in the DMA completions.  For queues with DMA, we must
                // update this field ourselves.
                //
                ClonePointer -> StreamHeader -> DataUsed = 0;

                SPContext = reinterpret_cast <PSTREAM_POINTER_CONTEXT> 
                    (ClonePointer -> Context);

                SPContext -> BufferVirtual = 
                    reinterpret_cast <PUCHAR> (
                        ClonePointer -> StreamHeader -> Data
                        );
            }

        } else {

            ClonePointer = m_PreviousStreamPointer;
            SPContext = reinterpret_cast <PSTREAM_POINTER_CONTEXT> 
                (ClonePointer -> Context);
            Status = STATUS_SUCCESS;
        }

        //
        // If the clone failed, likely we're out of resources.  Break out
        // of the loop for now.  We may end up starving DMA.
        //
        if (!NT_SUCCESS (Status)) {
            KsStreamPointerUnlock (Leading, FALSE);
            break;
        }

        //
        // Program the fake hardware.  I would use Clone -> OffsetOut.*, but
        // because of the optimization of one stream pointer per frame, it
        // doesn't make complete sense.
        //
        ULONG MappingsUsed =
            m_Device -> ProgramScatterGatherMappings (
                &(SPContext -> BufferVirtual),
                Leading -> OffsetOut.Mappings,
                Leading -> OffsetOut.Remaining
                );

        //
        // In order to keep one clone per frame and simplify the fake DMA
        // logic, make a check to see if we completely used the mappings in
        // the leading edge.  Set a flag.
        //
        if (MappingsUsed == Leading -> OffsetOut.Remaining) {
            m_PreviousStreamPointer = NULL;
        } else {
            m_PreviousStreamPointer = ClonePointer;
        }

        if (MappingsUsed) {
            //
            // If any mappings were added to scatter / gather queues, 
            // advance the leading edge by that number of mappings.  If 
            // we run off the end of the queue, Status will be 
            // STATUS_DEVICE_NOT_READY.  Otherwise, the leading edge will
            // point to a new frame.  The previous one will not have been
            // dismissed (unless "DMA" completed) since there's a clone
            // pointer referencing the frames.
            //
            Status =
                KsStreamPointerAdvanceOffsets (
                    Leading,
                    0,
                    MappingsUsed,
                    FALSE
                    );
        } else {

            //
            // The hardware was incapable of adding more entries.  The S/G
            // table is full.
            //
            Status = STATUS_PENDING;
            break;

        }

    }

    //
    // If the leading edge failed to lock (this is always possible, remember
    // that locking CAN occassionally fail), don't blow up passing NULL
    // into KsStreamPointerUnlock.  Also, set m_PendIo to kick us later...
    //
    if (!Leading) {

        m_PendIo = TRUE;

        //
        // If the lock failed, there's no point in getting called back 
        // immediately.  The lock could fail due to insufficient memory,
        // etc...  In this case, we don't want to get called back immediately.
        // Return pending.  The m_PendIo flag will cause us to get kicked
        // later.
        //
        Status = STATUS_PENDING;
    }

    //
    // If we didn't run the leading edge off the end of the queue, unlock it.
    //
    if (NT_SUCCESS (Status) && Leading) {
        KsStreamPointerUnlock (Leading, FALSE);
    } else {
        //
        // DEVICE_NOT_READY indicates that the advancement ran off the end
        // of the queue.  We couldn't lock the leading edge.
        //
        if (Status == STATUS_DEVICE_NOT_READY) Status = STATUS_SUCCESS;
    }

    //
    // If we failed with something that requires pending, set the pending I/O
    // flag so we know we need to start it again in a completion DPC.
    //
    if (!NT_SUCCESS (Status) || Status == STATUS_PENDING) {
        m_PendIo = TRUE;
    }

    return Status;

}

/*************************************************/


NTSTATUS
CCapturePin::
CleanupReferences (
    )

/*++

Routine Description:

    Clean up any references we're holding on frames after we abruptly
    stop the hardware.

Arguments:

    None

Return Value:

    Success / Failure

--*/

{

    PAGED_CODE();

    PKSSTREAM_POINTER Clone = KsPinGetFirstCloneStreamPointer (m_Pin);
    PKSSTREAM_POINTER NextClone = NULL;

    //
    // Walk through the clones, deleting them, and setting DataUsed to
    // zero since we didn't use any data!
    //
    while (Clone) {

        NextClone = KsStreamPointerGetNextClone (Clone);

        Clone -> StreamHeader -> DataUsed = 0;
        KsStreamPointerDelete (Clone);

        Clone = NextClone;

    }

    return STATUS_SUCCESS;

}

/*************************************************/


NTSTATUS
CCapturePin::
SetState (
    IN KSSTATE ToState,
    IN KSSTATE FromState
    )

/*++

Routine Description:

    This is called when the caputre pin transitions state.  The routine
    attempts to acquire / release any hardware resources and start up
    or shut down capture based on the states we are transitioning to
    and away from.

Arguments:

    ToState -
        The state we're transitioning to

    FromState -
        The state we're transitioning away from

Return Value:

    Success / Failure

--*/

{

    PAGED_CODE();

    NTSTATUS Status = STATUS_SUCCESS;

    switch (ToState) {

        case KSSTATE_STOP:

            //
            // First, stop the hardware if we actually did anything to it.
            //
            if (m_HardwareState != HardwareStopped) {
                Status = m_Device -> Stop ();
                ASSERT (NT_SUCCESS (Status));

                m_HardwareState = HardwareStopped;
            }

            //
            // We've stopped the "fake hardware".  It has cleared out
            // it's scatter / gather tables and will no longer be 
            // completing clones.  We had locks on some frames that were,
            // however, in hardware.  This will clean them up.  An
            // alternative location would be in the reset dispatch.
            // Note, however, that the reset dispatch can occur in any
            // state and this should be understood.
            //
            // Some hardware may fill all S/G mappings before stopping...
            // in this case, you may not have to do this.  The 
            // "fake hardware" here simply stops filling mappings and 
            // cleans its scatter / gather tables out on the Stop call.
            //
            Status = CleanupReferences ();

            //
            // Release any hardware resources related to this pin.
            //
            if (m_AcquiredResources) {
                //
                // If we got an interface to the clock, we must release it.
                //
                if (m_Clock) {
                    m_Clock -> Release ();
                    m_Clock = NULL;
                }

                m_Device -> ReleaseHardwareResources (
                    );

                m_AcquiredResources = FALSE;
            }

            break;

        case KSSTATE_ACQUIRE:
            //
            // Acquire any hardware resources related to this pin.  We should
            // only acquire them here -- **NOT** at filter create time. 
            // This means we do not fail creation of a filter because of
            // limited hardware resources.
            //
            if (FromState == KSSTATE_STOP) {
                Status = m_Device -> AcquireHardwareResources (
                    this,
                    m_VideoInfoHeader
                    );

                if (NT_SUCCESS (Status)) {
                    m_AcquiredResources = TRUE;

                    //
                    // Attempt to get an interface to the master clock.
                    // This will fail if one has not been assigned.  Since
                    // one must be assigned while the pin is still in 
                    // KSSTATE_STOP, this is a guranteed method of getting
                    // the clock should one be assigned.
                    //
                    if (!NT_SUCCESS (
                        KsPinGetReferenceClockInterface (
                            m_Pin,
                            &m_Clock
                            )
                        )) {

                        //
                        // If we could not get an interface to the clock,
                        // don't use one.  
                        //
                        m_Clock = NULL;

                    }

                } else {
                    m_AcquiredResources = FALSE;
                }

            } else {
                //
                // Standard transport pins will always receive transitions in
                // +/- 1 manner.  This means we'll always see a PAUSE->ACQUIRE
                // transition before stopping the pin.  
                //
                // The below is done because on DirectX 8.0, when the pin gets
                // a message to stop, the queue is inaccessible.  The reset 
                // which comes on every stop happens after this (at which time
                // the queue is inaccessible also).  So, for compatibility with
                // DirectX 8.0, I am stopping the "fake" hardware at this
                // point and cleaning up all references we have on frames.  See
                // the comments above regarding the CleanupReferences call.
                //
                // If this sample were targeting XP only, the below code would
                // not be here.  Again, I only do this so the sample does not
                // hang when it is stopped running on a configuration such as
                // Win2K + DX8. 
                //
                if (m_HardwareState != HardwareStopped) {
                    Status = m_Device -> Stop ();
                    ASSERT (NT_SUCCESS (Status));

                    m_HardwareState = HardwareStopped;
                }

                Status = CleanupReferences ();
            }

            break;

        case KSSTATE_PAUSE:
            //
            // Stop the hardware simulation if we're coming down from run.
            //
            if (FromState == KSSTATE_RUN) {

                Status = m_Device -> Pause (TRUE);

                if (NT_SUCCESS (Status)) {
                    m_HardwareState = HardwarePaused;
                }

            }
            break;

        case KSSTATE_RUN:
            //
            // Start the hardware simulation or unpause it depending on
            // whether we're initially running or we've paused and restarted.
            //
            if (m_HardwareState == HardwarePaused) {
                Status = m_Device -> Pause (FALSE);
            } else {
                Status = m_Device -> Start ();
            }

            if (NT_SUCCESS (Status)) {
                m_HardwareState = HardwareRunning;
            }

            break;

    }

    return Status;

}

/*************************************************/


NTSTATUS
CCapturePin::
IntersectHandler (
    IN PKSFILTER Filter,
    IN PIRP Irp,
    IN PKSP_PIN PinInstance,
    IN PKSDATARANGE CallerDataRange,
    IN PKSDATARANGE DescriptorDataRange,
    IN ULONG BufferSize,
    OUT PVOID Data OPTIONAL,
    OUT PULONG DataSize
    )

/*++

Routine Description:

    This routine handles video pin intersection queries by determining the
    intersection between two data ranges.

Arguments:

    Filter -
        Contains a void pointer to the  filter structure.

    Irp -
        Contains a pointer to the data intersection property request.

    PinInstance -
        Contains a pointer to a structure indicating the pin in question.

    CallerDataRange -
        Contains a pointer to one of the data ranges supplied by the client
        in the data intersection request.  The format type, subtype and
        specifier are compatible with the DescriptorDataRange.

    DescriptorDataRange -
        Contains a pointer to one of the data ranges from the pin descriptor
        for the pin in question.  The format type, subtype and specifier are
        compatible with the CallerDataRange.

    BufferSize -
        Contains the size in bytes of the buffer pointed to by the Data
        argument.  For size queries, this value will be zero.

    Data -
        Optionally contains a pointer to the buffer to contain the data 
        format structure representing the best format in the intersection 
        of the two data ranges.  For size queries, this pointer will be 
        NULL.

    DataSize -
        Contains a pointer to the location at which to deposit the size 
        of the data format.  This information is supplied by the function 
        when the format is actually delivered and in response to size 
        queries.

Return Value:

    STATUS_SUCCESS if there is an intersection and it fits in the supplied
    buffer, STATUS_BUFFER_OVERFLOW for successful size queries, 
    STATUS_NO_MATCH if the intersection is empty, or 
    STATUS_BUFFER_TOO_SMALL if the supplied buffer is too small.

--*/

{
    PAGED_CODE();

    const GUID VideoInfoSpecifier = 
        {STATICGUIDOF(KSDATAFORMAT_SPECIFIER_VIDEOINFO)};
    
    ASSERT(Filter);
    ASSERT(Irp);
    ASSERT(PinInstance);
    ASSERT(CallerDataRange);
    ASSERT(DescriptorDataRange);
    ASSERT(DataSize);
    
    ULONG DataFormatSize;
    
    //
    // Specifier FORMAT_VideoInfo for VIDEOINFOHEADER
    //
    if (IsEqualGUID(CallerDataRange->Specifier, VideoInfoSpecifier) &&
        CallerDataRange -> FormatSize >= sizeof (KS_DATARANGE_VIDEO)) {
            
        PKS_DATARANGE_VIDEO callerDataRange = 
            reinterpret_cast <PKS_DATARANGE_VIDEO> (CallerDataRange);

        PKS_DATARANGE_VIDEO descriptorDataRange = 
            reinterpret_cast <PKS_DATARANGE_VIDEO> (DescriptorDataRange);

        PKS_DATAFORMAT_VIDEOINFOHEADER FormatVideoInfoHeader;

        //
        // Check that the other fields match
        //
        if ((callerDataRange->bFixedSizeSamples != 
                descriptorDataRange->bFixedSizeSamples) ||
            (callerDataRange->bTemporalCompression != 
                descriptorDataRange->bTemporalCompression) ||
            (callerDataRange->StreamDescriptionFlags != 
                descriptorDataRange->StreamDescriptionFlags) ||
            (callerDataRange->MemoryAllocationFlags != 
                descriptorDataRange->MemoryAllocationFlags) ||
            (RtlCompareMemory (&callerDataRange->ConfigCaps,
                    &descriptorDataRange->ConfigCaps,
                    sizeof (KS_VIDEO_STREAM_CONFIG_CAPS)) != 
                    sizeof (KS_VIDEO_STREAM_CONFIG_CAPS))) 
        {
            return STATUS_NO_MATCH;
        }

        //
        // KS_SIZE_VIDEOHEADER() below is relying on bmiHeader.biSize from
        // the caller's data range.  This **MUST** be validated; the
        // extended bmiHeader size (biSize) must not extend past the end
        // of the range buffer.  Possible arithmetic overflow is also
        // checked for.
        //
        {
            ULONG VideoHeaderSize = KS_SIZE_VIDEOHEADER (
                &callerDataRange->VideoInfoHeader
                );

            ULONG DataRangeSize = 
                FIELD_OFFSET (KS_DATARANGE_VIDEO, VideoInfoHeader) +
                VideoHeaderSize;

            //
            // Check that biSize does not extend past the buffer.  The 
            // first two checks are for arithmetic overflow on the 
            // operations to compute the alleged size.  (On unsigned
            // math, a+b < a iff an arithmetic overflow occurred).
            //
            if (
                VideoHeaderSize < callerDataRange->
                    VideoInfoHeader.bmiHeader.biSize ||
                DataRangeSize < VideoHeaderSize ||
                DataRangeSize > callerDataRange -> DataRange.FormatSize
                ) {

                return STATUS_INVALID_PARAMETER;

            }

        }

        DataFormatSize = 
            sizeof (KSDATAFORMAT) + 
            KS_SIZE_VIDEOHEADER (&callerDataRange->VideoInfoHeader);

            
        //
        // If the passed buffer size is 0, it indicates that this is a size
        // only query.  Return the size of the intersecting data format and
        // pass back STATUS_BUFFER_OVERFLOW.
        //
        if (BufferSize == 0) {

            *DataSize = DataFormatSize;
            return STATUS_BUFFER_OVERFLOW;

        }
        
        //
        // Verify that the provided structure is large enough to
        // accept the result.
        //
        if (BufferSize < DataFormatSize) 
        {
            return STATUS_BUFFER_TOO_SMALL;
        }

        //
        // Copy over the KSDATAFORMAT, followed by the actual VideoInfoHeader
        //
        *DataSize = DataFormatSize;
            
        FormatVideoInfoHeader = PKS_DATAFORMAT_VIDEOINFOHEADER( Data );

        //
        // Copy over the KSDATAFORMAT.  This is precisely the same as the
        // KSDATARANGE (it's just the GUIDs, etc...  not the format information
        // following any data format.
        // 
        RtlCopyMemory (
            &FormatVideoInfoHeader->DataFormat, 
            DescriptorDataRange, 
            sizeof (KSDATAFORMAT));

        FormatVideoInfoHeader->DataFormat.FormatSize = DataFormatSize;

        //
        // Copy over the callers requested VIDEOINFOHEADER
        //

        RtlCopyMemory (
            &FormatVideoInfoHeader->VideoInfoHeader, 
            &callerDataRange->VideoInfoHeader,
            KS_SIZE_VIDEOHEADER (&callerDataRange->VideoInfoHeader) 
            );

        //
        // Calculate biSizeImage for this request, and put the result in both
        // the biSizeImage field of the bmiHeader AND in the SampleSize field
        // of the DataFormat.
        //
        // Note that for compressed sizes, this calculation will probably not
        // be just width * height * bitdepth
        //
        FormatVideoInfoHeader->VideoInfoHeader.bmiHeader.biSizeImage =
            FormatVideoInfoHeader->DataFormat.SampleSize = 
            KS_DIBSIZE (FormatVideoInfoHeader->VideoInfoHeader.bmiHeader);

        //
        // REVIEW - Perform other validation such as cropping and scaling checks
        // 
        
        return STATUS_SUCCESS;
        
    } // End of VIDEOINFOHEADER specifier
    
    return STATUS_NO_MATCH;
}

/*************************************************/

BOOL
MultiplyCheckOverflow (
    ULONG a,
    ULONG b,
    ULONG *pab
    )

/*++

Routine Description:

    Perform a 32 bit unsigned multiplication and check for arithmetic overflow.

Arguments:

    a -
        First operand

    b -
        Second operand

    pab -
        Result

Return Value:

    TRUE -
        no overflow

    FALSE -
        overflow occurred

--*/

{

    *pab = a * b;
    if ((a == 0) || (((*pab) / a) == b)) {
        return TRUE;
    }
    return FALSE;
}

/*************************************************/


NTSTATUS
CCapturePin::
DispatchSetFormat (
    IN PKSPIN Pin,
    IN PKSDATAFORMAT OldFormat OPTIONAL,
    IN PKSMULTIPLE_ITEM OldAttributeList OPTIONAL,
    IN const KSDATARANGE *DataRange,
    IN const KSATTRIBUTE_LIST *AttributeRange OPTIONAL
    )

/*++

Routine Description:

    This is the set data format dispatch for the capture pin.  It is called
    in two circumstances.

        1: before Pin's creation dispatch has been made to verify that
           Pin -> ConnectionFormat is an acceptable format for the range
           DataRange.  In this case OldFormat is NULL.

        2: after Pin's creation dispatch has been made and an initial format
           selected in order to change the format for the pin.  In this case,
           OldFormat will not be NULL.

    Validate that the format is acceptible and perform the actions necessary
    to change format if appropriate.

Arguments:

    Pin -
        The pin this format is being set on.  The format itself will be in
        Pin -> ConnectionFormat.

    OldFormat -
        The previous format used on this pin.  If this is NULL, it is an
        indication that Pin's creation dispatch has not yet been made and
        that this is a request to validate the initial format and not to
        change formats.

    OldAttributeList -
        The old attribute list for the prior format

    DataRange -
        A range out of our list of data ranges which was determined to be
        at least a partial match for Pin -> ConnectionFormat.  If the format
        there is unacceptable for the range, STATUS_NO_MATCH should be
        returned.

    AttributeRange -
        The attribute range

Return Value:

    Success / Failure

        STATUS_SUCCESS -
            The format is acceptable / the format has been changed

        STATUS_NO_MATCH -
            The format is not-acceptable / the format has not been changed

--*/

{

    PAGED_CODE();

    NTSTATUS Status = STATUS_NO_MATCH;

    const GUID VideoInfoSpecifier = 
        {STATICGUIDOF(KSDATAFORMAT_SPECIFIER_VIDEOINFO)};

    CCapturePin *CapPin = NULL;

    //
    // Find the pin, if it exists yet.  OldFormat will be an indication of 
    // this.  If we're changing formats, OldFormat will be non-NULL.
    //
    // You cannot use Pin -> Context to make the determination.  AVStream
    // preinitializes this to the filter's context.
    //
    if (OldFormat) {
        CapPin = reinterpret_cast <CCapturePin *> (Pin -> Context);
    }

    if (IsEqualGUID (Pin -> ConnectionFormat -> Specifier,
            VideoInfoSpecifier) &&
        Pin -> ConnectionFormat -> FormatSize >=
            sizeof (KS_DATAFORMAT_VIDEOINFOHEADER)) {

        PKS_DATAFORMAT_VIDEOINFOHEADER ConnectionFormat =
            reinterpret_cast <PKS_DATAFORMAT_VIDEOINFOHEADER> 
                (Pin -> ConnectionFormat);

        //
        // DataRange comes out of OUR data range list.  I know the range
        // is valid as such.
        //
        const KS_DATARANGE_VIDEO *VIRange =
            reinterpret_cast <const KS_DATARANGE_VIDEO *>
                (DataRange);

        //
        // Check that bmiHeader.biSize is valid since we use it later.
        //
        ULONG VideoHeaderSize = KS_SIZE_VIDEOHEADER (
            &ConnectionFormat -> VideoInfoHeader
            );

        ULONG DataFormatSize = FIELD_OFFSET (
            KS_DATAFORMAT_VIDEOINFOHEADER, VideoInfoHeader
            ) + VideoHeaderSize;

        if (
            VideoHeaderSize < ConnectionFormat->
                VideoInfoHeader.bmiHeader.biSize ||
            DataFormatSize < VideoHeaderSize ||
            DataFormatSize > ConnectionFormat -> DataFormat.FormatSize
            ) {

            Status = STATUS_INVALID_PARAMETER;

        }

        //
        // Check that the format is a match for the selected range. 
        //
        else if (
            (ConnectionFormat -> VideoInfoHeader.bmiHeader.biWidth !=
                VIRange -> VideoInfoHeader.bmiHeader.biWidth) ||

            (ConnectionFormat -> VideoInfoHeader.bmiHeader.biHeight !=
                VIRange -> VideoInfoHeader.bmiHeader.biHeight) ||

            (ConnectionFormat -> VideoInfoHeader.bmiHeader.biCompression !=
                VIRange -> VideoInfoHeader.bmiHeader.biCompression) 

            ) {

            Status = STATUS_NO_MATCH;

        } else {

            //
            // Compute the minimum size of our buffers to validate against.
            // The image synthesis routines synthesize |biHeight| rows of
            // biWidth pixels in either RGB24 or UYVY.  In order to ensure
            // safe synthesis into the buffer, we need to know how large an
            // image this will produce.
            //
            // I do this explicitly because of the method that the data is
            // synthesized.  A variation of this may or may not be necessary
            // depending on the mechanism the driver in question fills the 
            // capture buffers.  The important thing is to ensure that they
            // aren't overrun during capture.
            //
            ULONG ImageSize;

            if (!MultiplyCheckOverflow (
                (ULONG)ConnectionFormat->VideoInfoHeader.bmiHeader.biWidth,
                (ULONG)abs (ConnectionFormat->
                    VideoInfoHeader.bmiHeader.biHeight),
                &ImageSize
                )) {

                Status = STATUS_INVALID_PARAMETER;
            }

            //
            // We only support KS_BI_RGB (24) and KS_BI_YUV422 (16), so
            // this is valid for those formats.
            //
            else if (!MultiplyCheckOverflow (
                ImageSize,
                (ULONG)(ConnectionFormat->
                    VideoInfoHeader.bmiHeader.biBitCount / 8),
                &ImageSize
                )) {

                Status = STATUS_INVALID_PARAMETER;

            }

            //
            // Valid for the formats we use.  Otherwise, this would be
            // checked later.
            //
            else if (ConnectionFormat->VideoInfoHeader.bmiHeader.biSizeImage <
                    ImageSize) {

                Status = STATUS_INVALID_PARAMETER;

            } else {

                //
                // We can accept the format. 
                //
                Status = STATUS_SUCCESS;

                //
                // OldFormat is an indication that this is a format change.  
                // Since I do not implement the 
                // KSPROPERTY_CONNECTION_PROPOSEDATAFORMAT, by default, I do 
                // not handle dynamic format changes.
                //
                // If something changes while we're in the stop state, we're 
                // fine to handle it since we haven't "configured the hardware"
                // yet.
                //
                if (OldFormat) {
                    //
                    // If we're in the stop state, we can handle just about any
                    // change.  We don't support dynamic format changes. 
                    //
                    if (Pin -> DeviceState == KSSTATE_STOP) {
                        if (!CapPin -> CaptureVideoInfoHeader ()) {
                            Status = STATUS_INSUFFICIENT_RESOURCES;
                        }
                    } else {
                        //
                        // Because we don't accept dynamic format changes, we
                        // should never get here.  Just being over-protective.
                        //
                        Status = STATUS_INVALID_DEVICE_STATE;
                    }

                }

            }

        }

    }

    return Status;

}

/**************************************************************************

    LOCKED CODE

**************************************************************************/

#ifdef ALLOC_PRAGMA
#pragma code_seg()
#endif // ALLOC_PRAGMA


void
CCapturePin::
CompleteMappings (
    IN ULONG NumMappings
    )

/*++

Routine Description:

    Called to notify the pin that a given number of scatter / gather
    mappings have completed.  Let the buffers go if possible.
    We're called at DPC.

Arguments:

    NumMappings -
        The number of mappings that have completed.

Return Value:

    None

--*/

{

    ULONG MappingsRemaining = NumMappings;

    //
    // Walk through the clones list and delete clones whose time has come.
    // The list is guaranteed to be kept in the order they were cloned.
    //
    PKSSTREAM_POINTER Clone = KsPinGetFirstCloneStreamPointer (m_Pin);

    while (MappingsRemaining && Clone) {

        PKSSTREAM_POINTER NextClone = KsStreamPointerGetNextClone (Clone);

        //
        // Count up the number of bytes we've completed and mark this
        // in the Stream Header.  In mapped queues 
        // (KSPIN_FLAG_GENERATE_MAPPINGS), this is the responsibility of
        // the minidriver.  In non-mapped queues, AVStream performs this.
        //
        ULONG MappingsToCount = 
            (MappingsRemaining > Clone -> OffsetOut.Remaining) ?
                 Clone -> OffsetOut.Remaining :
                 MappingsRemaining;

        //
        // Update DataUsed according to the mappings.
        //
        for (ULONG CurMapping = 0; CurMapping < MappingsToCount; CurMapping++) {
            Clone -> StreamHeader -> DataUsed +=
                Clone -> OffsetOut.Mappings [CurMapping].ByteCount;
        }

        // 
        // If we have completed all remaining mappings in this clone, it
        // is an indication that the clone is ready to be deleted and the
        // buffer released.  Set anything required in the stream header which
        // has not yet been set.  If we have a clock, we can timestamp the
        // sample.
        //
        if (MappingsRemaining >= Clone -> OffsetOut.Remaining) {

            Clone -> StreamHeader -> Duration =
                m_VideoInfoHeader -> AvgTimePerFrame;

            Clone -> StreamHeader -> PresentationTime.Numerator =
                Clone -> StreamHeader -> PresentationTime.Denominator = 1;

            //
            // If a clock has been assigned, timestamp the packets with the
            // time shown on the clock. 
            //
            if (m_Clock) {

                LONGLONG ClockTime = m_Clock -> GetTime ();

                Clone -> StreamHeader -> PresentationTime.Time = ClockTime;

                Clone -> StreamHeader -> OptionsFlags =
                    KSSTREAM_HEADER_OPTIONSF_TIMEVALID |
                    KSSTREAM_HEADER_OPTIONSF_DURATIONVALID;

            } else {
                //
                // If there is no clock, don't time stamp the packets.
                //
                Clone -> StreamHeader -> PresentationTime.Time = 0;

            }

            MappingsRemaining -= Clone -> OffsetOut.Remaining;

            //
            // If all of the mappings in this clone have been completed,
            // delete the clone.  We've already updated DataUsed above.
            //
            KsStreamPointerDelete (Clone);

        } else {
            //
            // If only part of the mappings in this clone have been completed,
            // update the pointers.  Since we're guaranteed this won't advance
            // to a new frame by the check above, it won't fail.
            //
            KsStreamPointerAdvanceOffsets (
                Clone,
                0,
                MappingsRemaining,
                FALSE
                );

            MappingsRemaining = 0;

        }

        //
        // Go to the next clone.
        //
        Clone = NextClone;

    }

    //
    // If we've used all the mappings in hardware and pended, we can kick
    // processing to happen again if we've completed mappings.
    //
    if (m_PendIo) {
        m_PendIo = TRUE;
        KsPinAttemptProcessing (m_Pin, TRUE);
    }

}

/**************************************************************************

    DISPATCH AND DESCRIPTOR LAYOUT

**************************************************************************/

#define D_X 320
#define D_Y 240

//
// FormatRGB24Bpp_Capture:
//
// This is the data range description of the RGB24 capture format we support.
//
const 
KS_DATARANGE_VIDEO 
FormatRGB24Bpp_Capture = {

    //
    // KSDATARANGE
    //
    {   
        sizeof (KS_DATARANGE_VIDEO),                // FormatSize
        0,                                          // Flags
        D_X * D_Y * 3,                              // SampleSize
        0,                                          // Reserved

        STATICGUIDOF (KSDATAFORMAT_TYPE_VIDEO),     // aka. MEDIATYPE_Video
        0xe436eb7d, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 
            0xaf, 0x0b, 0xa7, 0x70,                 // aka. MEDIASUBTYPE_RGB24,
        STATICGUIDOF (KSDATAFORMAT_SPECIFIER_VIDEOINFO) // aka. FORMAT_VideoInfo
    },

    TRUE,               // BOOL,  bFixedSizeSamples (all samples same size?)
    TRUE,               // BOOL,  bTemporalCompression (all I frames?)
    0,                  // Reserved (was StreamDescriptionFlags)
    0,                  // Reserved (was MemoryAllocationFlags   
                        //           (KS_VIDEO_ALLOC_*))

    //
    // _KS_VIDEO_STREAM_CONFIG_CAPS  
    //
    {
        STATICGUIDOF( KSDATAFORMAT_SPECIFIER_VIDEOINFO ), // GUID
        KS_AnalogVideo_NTSC_M |
        KS_AnalogVideo_PAL_B,                    // AnalogVideoStandard
        720,480,        // InputSize, (the inherent size of the incoming signal
                        //             with every digitized pixel unique)
        160,120,        // MinCroppingSize, smallest rcSrc cropping rect allowed
        720,480,        // MaxCroppingSize, largest  rcSrc cropping rect allowed
        8,              // CropGranularityX, granularity of cropping size
        1,              // CropGranularityY
        8,              // CropAlignX, alignment of cropping rect 
        1,              // CropAlignY;
        160, 120,       // MinOutputSize, smallest bitmap stream can produce
        720, 480,       // MaxOutputSize, largest  bitmap stream can produce
        8,              // OutputGranularityX, granularity of output bitmap size
        1,              // OutputGranularityY;
        0,              // StretchTapsX  (0 no stretch, 1 pix dup, 2 interp...)
        0,              // StretchTapsY
        0,              // ShrinkTapsX 
        0,              // ShrinkTapsY 
        333667,         // MinFrameInterval, 100 nS units
        640000000,      // MaxFrameInterval, 100 nS units
        8 * 3 * 30 * 160 * 120,  // MinBitsPerSecond;
        8 * 3 * 30 * 720 * 480   // MaxBitsPerSecond;
    }, 
        
    //
    // KS_VIDEOINFOHEADER (default format)
    //
    {
        0,0,0,0,                            // RECT  rcSource; 
        0,0,0,0,                            // RECT  rcTarget; 
        D_X * D_Y * 3 * 30,                 // DWORD dwBitRate;
        0L,                                 // DWORD dwBitErrorRate; 
        333667,                             // REFERENCE_TIME  AvgTimePerFrame;   
        sizeof (KS_BITMAPINFOHEADER),       // DWORD biSize;
        D_X,                                // LONG  biWidth;
        -D_Y,                               // LONG  biHeight;
        1,                                  // WORD  biPlanes;
        24,                                 // WORD  biBitCount;
        KS_BI_RGB,                          // DWORD biCompression;
        D_X * D_Y * 3,                      // DWORD biSizeImage;
        0,                                  // LONG  biXPelsPerMeter;
        0,                                  // LONG  biYPelsPerMeter;
        0,                                  // DWORD biClrUsed;
        0                                   // DWORD biClrImportant;
    }
}; 

#undef D_X
#undef D_Y

#define D_X 320
#define D_Y 240

//
// FormatUYU2_Capture:
//
// This is the data range description of the UYVY format we support.
//
const 
KS_DATARANGE_VIDEO 
FormatUYU2_Capture = {

    //
    // KSDATARANGE
    //
    {   
        sizeof (KS_DATARANGE_VIDEO),            // FormatSize
        0,                                      // Flags
        D_X * D_Y * 2,                          // SampleSize
        0,                                      // Reserved
        STATICGUIDOF (KSDATAFORMAT_TYPE_VIDEO), // aka. MEDIATYPE_Video
        0x59565955, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 
            0x00, 0x38, 0x9b, 0x71,             // aka. MEDIASUBTYPE_UYVY,
        STATICGUIDOF (KSDATAFORMAT_SPECIFIER_VIDEOINFO) // aka. FORMAT_VideoInfo
    },

    TRUE,               // BOOL,  bFixedSizeSamples (all samples same size?)
    TRUE,               // BOOL,  bTemporalCompression (all I frames?)
    0,                  // Reserved (was StreamDescriptionFlags)
    0,                  // Reserved (was MemoryAllocationFlags   
                        //           (KS_VIDEO_ALLOC_*))

    //
    // _KS_VIDEO_STREAM_CONFIG_CAPS  
    //
    {
        STATICGUIDOF( KSDATAFORMAT_SPECIFIER_VIDEOINFO ), // GUID
        KS_AnalogVideo_NTSC_M |
        KS_AnalogVideo_PAL_B,                    // AnalogVideoStandard
        720,480,        // InputSize, (the inherent size of the incoming signal
                    //             with every digitized pixel unique)
        160,120,        // MinCroppingSize, smallest rcSrc cropping rect allowed
        720,480,        // MaxCroppingSize, largest  rcSrc cropping rect allowed
        8,              // CropGranularityX, granularity of cropping size
        1,              // CropGranularityY
        8,              // CropAlignX, alignment of cropping rect 
        1,              // CropAlignY;
        160, 120,       // MinOutputSize, smallest bitmap stream can produce
        720, 480,       // MaxOutputSize, largest  bitmap stream can produce
        8,              // OutputGranularityX, granularity of output bitmap size
        1,              // OutputGranularityY;
        0,              // StretchTapsX  (0 no stretch, 1 pix dup, 2 interp...)
        0,              // StretchTapsY
        0,              // ShrinkTapsX 
        0,              // ShrinkTapsY 
        333667,         // MinFrameInterval, 100 nS units
        640000000,      // MaxFrameInterval, 100 nS units
        8 * 2 * 30 * 160 * 120,  // MinBitsPerSecond;
        8 * 2 * 30 * 720 * 480   // MaxBitsPerSecond;
    }, 
        
    //
    // KS_VIDEOINFOHEADER (default format)
    //
    {
        0,0,0,0,                            // RECT  rcSource; 
        0,0,0,0,                            // RECT  rcTarget; 
        D_X * D_Y * 2 * 30,                 // DWORD dwBitRate;
        0L,                                 // DWORD dwBitErrorRate; 
        333667,                             // REFERENCE_TIME  AvgTimePerFrame;   
        sizeof (KS_BITMAPINFOHEADER),       // DWORD biSize;
        D_X,                                // LONG  biWidth;
        D_Y,                                // LONG  biHeight;
        1,                                  // WORD  biPlanes;
        16,                                 // WORD  biBitCount;
        FOURCC_YUV422,                      // DWORD biCompression;
        D_X * D_Y * 2,                      // DWORD biSizeImage;
        0,                                  // LONG  biXPelsPerMeter;
        0,                                  // LONG  biYPelsPerMeter;
        0,                                  // DWORD biClrUsed;
        0                                   // DWORD biClrImportant;
    }
}; 

//
// CapturePinDispatch:
//
// This is the dispatch table for the capture pin.  It provides notifications
// about creation, closure, processing, data formats, etc...
//
const
KSPIN_DISPATCH
CapturePinDispatch = {
    CCapturePin::DispatchCreate,            // Pin Create
    NULL,                                   // Pin Close
    CCapturePin::DispatchProcess,           // Pin Process
    NULL,                                   // Pin Reset
    CCapturePin::DispatchSetFormat,         // Pin Set Data Format
    CCapturePin::DispatchSetState,          // Pin Set Device State
    NULL,                                   // Pin Connect
    NULL,                                   // Pin Disconnect
    NULL,                                   // Clock Dispatch
    NULL                                    // Allocator Dispatch
};

//
// CapturePinAllocatorFraming:
//
// This is the simple framing structure for the capture pin.  Note that this
// will be modified via KsEdit when the actual capture format is determined.
//
DECLARE_SIMPLE_FRAMING_EX (
    CapturePinAllocatorFraming,
    STATICGUIDOF (KSMEMORY_TYPE_KERNEL_NONPAGED),
    KSALLOCATOR_REQUIREMENTF_SYSTEM_MEMORY |
        KSALLOCATOR_REQUIREMENTF_PREFERENCES_ONLY,
    2,
    0,
    2 * PAGE_SIZE,
    2 * PAGE_SIZE
    );

//
// CapturePinDataRanges:
//
// This is the list of data ranges supported on the capture pin.  We support
// two: one RGB24, and one UYVY.
//
const 
PKSDATARANGE 
CapturePinDataRanges [CAPTURE_PIN_DATA_RANGE_COUNT] = {
    (PKSDATARANGE) &FormatRGB24Bpp_Capture,
    (PKSDATARANGE) &FormatUYU2_Capture
    };
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\ksfilter\tests\avshws\capture.h ===
/**************************************************************************

    AVStream Simulated Hardware Sample

    Copyright (c) 2001, Microsoft Corporation.

    File:

        capture.h

    Abstract:

        This file contains header for the video capture pin on the capture
        filter.  The capture sample performs "fake" DMA directly into
        the capture buffers.  Common buffer DMA will work slightly differently.

        For common buffer DMA, the general technique would be DPC schedules
        processing with KsPinAttemptProcessing.  The processing routine grabs
        the leading edge, copies data out of the common buffer and advances.
        Cloning would not be necessary with this technique.  It would be 
        similiar to the way "AVSSamp" works, but it would be pin-centric.

    History:

        created 3/8/2001

**************************************************************************/

//
// STREAM_POINTER_CONTEXT:
//
// This is the context structure we associate with all clone stream pointers.
// It allows the mapping code to rip apart the buffer into chunks the same
// size as the scatter/gather mappings in order to fake scatter / gather
// bus-master DMA.
//
typedef struct _STREAM_POINTER_CONTEXT {
    
    PUCHAR BufferVirtual;

} STREAM_POINTER_CONTEXT, *PSTREAM_POINTER_CONTEXT;

//
// CCapturePin:
//
// The video capture pin class.
//
class CCapturePin :
    public ICaptureSink {

private:

    //
    // The AVStream pin we're associated with.
    //
    PKSPIN m_Pin;

    //
    // Pointer to the internal device object for our capture device.
    // We access the "fake" hardware through this object.
    //
    CCaptureDevice *m_Device;

    //
    // The state we've put the hardware into.  This allows us to keep track
    // of whether to do things like unpausing or restarting.
    //
    HARDWARE_STATE m_HardwareState;

    //
    // The clock we've been assigned.  As with other capture filters, we do
    // not expose a clock.  If one has been assigned, we will use it to
    // time stamp packets (plus a reasonable delta to work the capture stream
    // in a preview graph).
    //
    PIKSREFERENCECLOCK m_Clock;

    //
    // The captured video info header.  The settings for "fake" hardware will be
    // programmed via this video info header.
    //
    PKS_VIDEOINFOHEADER m_VideoInfoHeader;

    //
    // If we are unable to insert all of the mappings in a stream pointer into
    // the "fake" hardware's scatter / gather table, we set this to the
    // stream pointer that's incomplete.  This is done both to make the 
    // relasing easier and to make it easier to fake the scatter / gather
    // hardware.
    //
    PKSSTREAM_POINTER m_PreviousStreamPointer;

    //
    // An indication of whether or not we pended I/O for some reason.  If this
    // is set, the DPC will resume I/O when any mappings are completed.
    //
    BOOLEAN m_PendIo;

    //
    // An indication of whether or not this pin has acquired the necessary
    // hardware resources to operate.  When the pin reaches KSSTATE_ACQUIRE,
    // we attempt to acquire the hardware.  This flag will be set based on
    // our success / failure.
    //
    BOOLEAN m_AcquiredResources;

    //
    // CleanupReferences():
    //
    // Clean up any references we hold on frames in the queue.  This is called
    // when we abruptly stop the fake hardware.
    //
    NTSTATUS
    CleanupReferences (
        );

    //
    // SetState():
    //
    // This is the state transition handler for the capture pin.  It attempts
    // to acquire resources for the capture pin (or releasing them if
    // necessary) and starts and stops the hardware as required.
    //
    NTSTATUS
    SetState (
        IN KSSTATE ToState,
        IN KSSTATE FromState
        );

    //
    // Process():
    //
    // This is the processing dispatch for the capture pin.  It handles
    // programming the scatter / gather tables for the hardware as buffers
    // become available.  This processing routine is designed for a direct
    // into the capture buffers kind of DMA as opposed to common-buffer
    // and copy strategies.
    //
    NTSTATUS
    Process (
        );

    //
    // CaptureVideoInfoHeader():
    //
    // This routine stashes the video info header set on the pin connection
    // in the CCapturePin object.  This is used to base hardware settings.
    //
    PKS_VIDEOINFOHEADER
    CaptureVideoInfoHeader (
        );

    //
    // Cleanup():
    //
    // This is the free callback from the bagged item (CCapturePin).  If we
    // do not provide a callback when we bag the CCapturePin, ExFreePool
    // would be called.  This is not desirable for C++ constructed objects.
    // We merely delete the object here.
    //
    static
    void
    Cleanup (
        IN CCapturePin *Pin
        )
    {
        delete Pin;
    }

public:

    //
    // CCapturePin():
    //
    // The capture pin's constructor.  Initialize any non-0, non-NULL fields
    // (since new will have zero'ed the memory anyway) and set up our
    // device level pointers for access during capture routines.
    //
    CCapturePin (
        IN PKSPIN Pin
        );

    //
    // ~CCapturePin():
    //
    // The capture pin's destructor.
    //
    ~CCapturePin (
        )
    {
    }

    //
    // ICaptureSink::CompleteMappings()
    //
    // This is the capture sink notification mechanism for mapping completion.
    // When the device DPC detects that a given number of mappings have been
    // completed by the fake hardware, it signals the capture sink of this
    // through this method.
    //
    virtual
    void
    CompleteMappings (
        IN ULONG NumMappings
        );

    /*************************************************

        Dispatch Routines

    *************************************************/

    //
    // DispatchCreate():
    //
    // This is the creation dispatch for the capture pin.  It creates
    // the CCapturePin object and associates it with the AVStream object
    // bagging it in the process.
    //
    static
    NTSTATUS
    DispatchCreate (
        IN PKSPIN Pin,
        IN PIRP Irp
        );

    //
    // DispatchSetState():
    //
    // This is the set device state dispatch for the pin.  The routine bridges
    // to SetState() in the context of the CCapturePin.
    //
    static
    NTSTATUS
    DispatchSetState (
        IN PKSPIN Pin,
        IN KSSTATE ToState,
        IN KSSTATE FromState
        )
    {
        return 
            (reinterpret_cast <CCapturePin *> (Pin -> Context)) ->
                SetState (ToState, FromState);
    }

    //
    // DispatchSetFormat():
    //
    // This is the set data format dispatch for the pin.  This will be called
    // BEFORE pin creation to validate that a data format selected is a match
    // for the range pulled out of our range list.  It will also be called
    // for format changes.
    //
    // If OldFormat is NULL, this is an indication that it's the initial
    // call and not a format change.  Even fixed format pins get this call
    // once.
    //
    static
    NTSTATUS
    DispatchSetFormat (
        IN PKSPIN Pin,
        IN PKSDATAFORMAT OldFormat OPTIONAL,
        IN PKSMULTIPLE_ITEM OldAttributeList OPTIONAL,
        IN const KSDATARANGE *DataRange,
        IN const KSATTRIBUTE_LIST *AttributeRange OPTIONAL
        );

    //
    // DispatchProcess():
    //
    // This is the processing dispatch for the capture pin.  The routine 
    // bridges to Process() in the context of the CCapturePin.
    //
    static 
    NTSTATUS
    DispatchProcess (
        IN PKSPIN Pin
        )
    {
        return 
            (reinterpret_cast <CCapturePin *> (Pin -> Context)) ->
                Process ();
    }

    //
    // IntersectHandler():
    //
    // This is the data intersection handler for the capture pin.  This 
    // determines an optimal format in the intersection of two ranges,
    // one local and one possibly foreign.  If there is no compatible format,
    // STATUS_NO_MATCH is returned.
    //
    static
    NTSTATUS
    IntersectHandler (
        IN PKSFILTER Filter,
        IN PIRP Irp,
        IN PKSP_PIN PinInstance,
        IN PKSDATARANGE CallerDataRange,
        IN PKSDATARANGE DescriptorDataRange,
        IN ULONG BufferSize,
        OUT PVOID Data OPTIONAL,
        OUT PULONG DataSize
        );

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\ksfilter\tests\avshws\device.cpp ===
/**************************************************************************

    AVStream Simulated Hardware Sample

    Copyright (c) 2001, Microsoft Corporation.

    File:

        device.cpp

    Abstract:

        This file contains the device level implementation of the AVStream
        hardware sample.  Note that this is not the "fake" hardware.  The
        "fake" hardware is in hwsim.cpp.

    History:

        created 3/9/2001

**************************************************************************/

#include "avshws.h"

/**************************************************************************

    PAGEABLE CODE

**************************************************************************/

#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGE")
#endif // ALLOC_PRAGMA


NTSTATUS
CCaptureDevice::
DispatchCreate (
    IN PKSDEVICE Device
    )

/*++

Routine Description:

    Create the capture device.  This is the creation dispatch for the
    capture device.

Arguments:

    Device -
        The AVStream device being created.

Return Value:

    Success / Failure

--*/

{

    PAGED_CODE();

    NTSTATUS Status;

    CCaptureDevice *CapDevice = new (NonPagedPool) CCaptureDevice (Device);

    if (!CapDevice) {
        //
        // Return failure if we couldn't create the pin.
        //
        Status = STATUS_INSUFFICIENT_RESOURCES;

    } else {

        //
        // Add the item to the object bag if we were successful.
        // Whenever the device goes away, the bag is cleaned up and
        // we will be freed.
        //
        // For backwards compatibility with DirectX 8.0, we must grab
        // the device mutex before doing this.  For Windows XP, this is
        // not required, but it is still safe.
        //
        KsAcquireDevice (Device);
        Status = KsAddItemToObjectBag (
            Device -> Bag,
            reinterpret_cast <PVOID> (CapDevice),
            reinterpret_cast <PFNKSFREE> (CCaptureDevice::Cleanup)
            );
        KsReleaseDevice (Device);

        if (!NT_SUCCESS (Status)) {
            delete CapDevice;
        } else {
            Device -> Context = reinterpret_cast <PVOID> (CapDevice);
        }

    }

    return Status;

}

/*************************************************/


NTSTATUS
CCaptureDevice::
PnpStart (
    IN PCM_RESOURCE_LIST TranslatedResourceList,
    IN PCM_RESOURCE_LIST UntranslatedResourceList
    )

/*++

Routine Description:

    Called at Pnp start.  We start up our virtual hardware simulation.

Arguments:

    TranslatedResourceList -
        The translated resource list from Pnp

    UntranslatedResourceList -
        The untranslated resource list from Pnp

Return Value:

    Success / Failure

--*/

{

    PAGED_CODE();

    //
    // Normally, we'd do things here like parsing the resource lists and
    // connecting our interrupt.  Since this is a simulation, there isn't
    // much to parse.  The parsing and connection should be the same as
    // any WDM driver.  The sections that will differ are illustrated below
    // in setting up a simulated DMA.
    //

    NTSTATUS Status = STATUS_SUCCESS;

    //
    // By PnP, it's possible to receive multiple starts without an intervening
    // stop (to reevaluate resources, for example).  Thus, we only perform
    // creations of the simulation on the initial start and ignore any 
    // subsequent start.  Hardware drivers with resources should evaluate
    // resources and make changes on 2nd start.
    //
    if (!m_Device -> Started) {

        m_HardwareSimulation = new (NonPagedPool) CHardwareSimulation (this);
        if (!m_HardwareSimulation) {
            //
            // If we couldn't create the hardware simulation, fail.
            //
            Status = STATUS_INSUFFICIENT_RESOURCES;
    
        } else {
            Status = KsAddItemToObjectBag (
                m_Device -> Bag,
                reinterpret_cast <PVOID> (m_HardwareSimulation),
                reinterpret_cast <PFNKSFREE> (CHardwareSimulation::Cleanup)
                );

            if (!NT_SUCCESS (Status)) {
                delete m_HardwareSimulation;
            }
        }
    
        INTERFACE_TYPE InterfaceBuffer;
        ULONG InterfaceLength;
        DEVICE_DESCRIPTION DeviceDescription;
        NTSTATUS IfStatus;
    
        if (NT_SUCCESS (Status)) {
            //
            // Set up DMA...
            //
            IfStatus = IoGetDeviceProperty (
                m_Device -> PhysicalDeviceObject,
                DevicePropertyLegacyBusType,
                sizeof (INTERFACE_TYPE),
                &InterfaceBuffer,
                &InterfaceLength
                );

            //
            // Initialize our fake device description.  We claim to be a 
            // bus-mastering 32-bit scatter/gather capable piece of hardware.
            //
            // Ordinarilly, we'd be using InterfaceBuffer or 
            // InterfaceTypeUndefined if !NT_SUCCESS (IfStatus) as the 
            // InterfaceType below; however, for the purposes of this sample, 
            // we lie and say we're on the PCI Bus.  Otherwise, we're using map
            // registers on x86 32 bit physical to 32 bit logical and this isn't
            // what I want to show in this sample.
            //
            DeviceDescription.Version = DEVICE_DESCRIPTION_VERSION;
            DeviceDescription.DmaChannel = ((ULONG) ~0);
            DeviceDescription.InterfaceType = PCIBus;
            DeviceDescription.DmaWidth = Width32Bits;
            DeviceDescription.DmaSpeed = Compatible;
            DeviceDescription.ScatterGather = TRUE;
            DeviceDescription.Master = TRUE;
            DeviceDescription.Dma32BitAddresses = TRUE;
            DeviceDescription.AutoInitialize = FALSE;
            DeviceDescription.MaximumLength = (ULONG) -1;
    
            //
            // Get a DMA adapter object from the system.
            //
            m_DmaAdapterObject = IoGetDmaAdapter (
                m_Device -> PhysicalDeviceObject,
                &DeviceDescription,
                &m_NumberOfMapRegisters
                );
    
            if (!m_DmaAdapterObject) {
                Status = STATUS_UNSUCCESSFUL;
            }
    
        }
    
        if (NT_SUCCESS (Status)) {
            //
            // Initialize our DMA adapter object with AVStream.  This is 
            // **ONLY** necessary **IF** you are doing DMA directly into
            // capture buffers as this sample does.  For this,
            // KSPIN_FLAG_GENERATE_MAPPINGS must be specified on a queue.
            //
    
            //
            // The (1 << 20) below is the maximum size of a single s/g mapping
            // that this hardware can handle.  Note that I have pulled this
            // number out of thin air for the "fake" hardware.
            //
            KsDeviceRegisterAdapterObject (
                m_Device,
                m_DmaAdapterObject,
                (1 << 20),
                sizeof (KSMAPPING)
                );
    
        }

    }
    
    return Status;

}

/*************************************************/


void
CCaptureDevice::
PnpStop (
    )

/*++

Routine Description:

    This is the pnp stop dispatch for the capture device.  It releases any
    adapter object previously allocated by IoGetDmaAdapter during Pnp Start.

Arguments:

    None

Return Value:

    None

--*/

{

    if (m_DmaAdapterObject) {
        //
        // Return the DMA adapter back to the system.
        //
        m_DmaAdapterObject -> DmaOperations -> 
            PutDmaAdapter (m_DmaAdapterObject);

        m_DmaAdapterObject = NULL;
    }

}

/*************************************************/


NTSTATUS
CCaptureDevice::
AcquireHardwareResources (
    IN ICaptureSink *CaptureSink,
    IN PKS_VIDEOINFOHEADER VideoInfoHeader
    )

/*++

Routine Description:

    Acquire hardware resources for the capture hardware.  If the 
    resources are already acquired, this will return an error.
    The hardware configuration must be passed as a VideoInfoHeader.

Arguments:

    CaptureSink -
        The capture sink attempting to acquire resources.  When scatter /
        gather mappings are completed, the capture sink specified here is
        what is notified of the completions.

    VideoInfoHeader -
        Information about the capture stream.  This **MUST** remain
        stable until the caller releases hardware resources.  Note
        that this could also be guaranteed by bagging it in the device
        object bag as well.

Return Value:

    Success / Failure

--*/

{

    PAGED_CODE();

    NTSTATUS Status = STATUS_SUCCESS;

    //
    // If we're the first pin to go into acquire (remember we can have
    // a filter in another graph going simultaneously), grab the resources.
    //
    if (InterlockedCompareExchange (
        &m_PinsWithResources,
        1,
        0) == 0) {

        m_VideoInfoHeader = VideoInfoHeader;

        //
        // If there's an old hardware simulation sitting around for some
        // reason, blow it away.
        //
        if (m_ImageSynth) {
            delete m_ImageSynth;
            m_ImageSynth = NULL;
        }
    
        //
        // Create the necessary type of image synthesizer.
        //
        if (m_VideoInfoHeader -> bmiHeader.biBitCount == 24 &&
            m_VideoInfoHeader -> bmiHeader.biCompression == KS_BI_RGB) {
    
            //
            // If we're RGB24, create a new RGB24 synth.  RGB24 surfaces
            // can be in either orientation.  The origin is lower left if
            // height < 0.  Otherwise, it's upper left.
            //
            m_ImageSynth = new (NonPagedPool, 'RysI') 
                CRGB24Synthesizer (
                    m_VideoInfoHeader -> bmiHeader.biHeight >= 0
                    );
    
        } else
        if (m_VideoInfoHeader -> bmiHeader.biBitCount == 16 &&
            m_VideoInfoHeader -> bmiHeader.biCompression == FOURCC_YUV422) {
    
            //
            // If we're UYVY, create the YUV synth.
            //
            m_ImageSynth = new(NonPagedPool, 'YysI') CYUVSynthesizer;
    
        }
        else
            //
            // We don't synthesize anything but RGB 24 and UYVY.
            //
            Status = STATUS_INVALID_PARAMETER;
    
        if (NT_SUCCESS (Status) && !m_ImageSynth) {
    
            Status = STATUS_INSUFFICIENT_RESOURCES;
    
        } 

        if (NT_SUCCESS (Status)) {
            //
            // If everything has succeeded thus far, set the capture sink.
            //
            m_CaptureSink = CaptureSink;

        } else {
            //
            // If anything failed in here, we release the resources we've
            // acquired.
            //
            ReleaseHardwareResources ();
        }
    
    } else {

        //
        // TODO: Better status code?
        //
        Status = STATUS_SHARING_VIOLATION;

    }

    return Status;

}

/*************************************************/


void
CCaptureDevice::
ReleaseHardwareResources (
    )

/*++

Routine Description:

    Release hardware resources.  This should only be called by
    an object which has acquired them.

Arguments:

    None

Return Value:

    None

--*/

{

    PAGED_CODE();

    //
    // Blow away the image synth.
    //
    if (m_ImageSynth) {
        delete m_ImageSynth;
        m_ImageSynth = NULL;

    }

    m_VideoInfoHeader = NULL;
    m_CaptureSink = NULL;

    //
    // Release our "lock" on hardware resources.  This will allow another
    // pin (perhaps in another graph) to acquire them.
    //
    InterlockedExchange (
        &m_PinsWithResources,
        0
        );

}

/*************************************************/


NTSTATUS
CCaptureDevice::
Start (
    )

/*++

Routine Description:

    Start the capture device based on the video info header we were told
    about when resources were acquired.

Arguments:

    None

Return Value:

    Success / Failure

--*/

{

    PAGED_CODE();

    m_LastMappingsCompleted = 0;
    m_InterruptTime = 0;

    return
        m_HardwareSimulation -> Start (
            m_ImageSynth,
            m_VideoInfoHeader -> AvgTimePerFrame,
            m_VideoInfoHeader -> bmiHeader.biWidth,
            ABS (m_VideoInfoHeader -> bmiHeader.biHeight),
            m_VideoInfoHeader -> bmiHeader.biSizeImage
            );


}

/*************************************************/


NTSTATUS
CCaptureDevice::
Pause (
    IN BOOLEAN Pausing
    )

/*++

Routine Description:

    Pause or unpause the hardware simulation.  This is an effective start
    or stop without resetting counters and formats.  Note that this can
    only be called to transition from started -> paused -> started.  Calling
    this without starting the hardware with Start() does nothing.

Arguments:

    Pausing -
        An indicatation of whether we are pausing or unpausing

        TRUE -
            Pause the hardware simulation

        FALSE -
            Unpause the hardware simulation

Return Value:

    Success / Failure

--*/

{

    PAGED_CODE();

    return
        m_HardwareSimulation -> Pause (
            Pausing
            );

}

/*************************************************/


NTSTATUS
CCaptureDevice::
Stop (
    )

/*++

Routine Description:

    Stop the capture device.

Arguments:

    None

Return Value:

    Success / Failure

--*/

{

    PAGED_CODE();

    return
        m_HardwareSimulation -> Stop ();

}

/*************************************************/


ULONG
CCaptureDevice::
ProgramScatterGatherMappings (
    IN PUCHAR *Buffer,
    IN PKSMAPPING Mappings,
    IN ULONG MappingsCount
    )

/*++

Routine Description:

    Program the scatter / gather mappings for the "fake" hardware.

Arguments:

    Buffer -
        Points to a pointer to the virtual address of the topmost
        scatter / gather chunk.  The pointer will be updated as the
        device "programs" mappings.  Reason for this is that we get
        the physical addresses and sizes, but must calculate the virtual
        addresses...  This is used as scratch space for that.

    Mappings -
        An array of mappings to program

    MappingsCount -
        The count of mappings in the array

Return Value:

    The number of mappings successfully programmed

--*/

{

    PAGED_CODE();

    return 
        m_HardwareSimulation -> ProgramScatterGatherMappings (
            Buffer,
            Mappings,
            MappingsCount,
            sizeof (KSMAPPING)
            );

}

/*************************************************************************

    LOCKED CODE

**************************************************************************/

#ifdef ALLOC_PRAGMA
#pragma code_seg()
#endif // ALLOC_PRAGMA


ULONG
CCaptureDevice::
QueryInterruptTime (
    )

/*++

Routine Description:

    Return the number of frame intervals that have elapsed since the
    start of the device.  This will be the frame number.

Arguments:

    None

Return Value:

    The interrupt time of the device (the number of frame intervals that
    have elapsed since the start of the device).

--*/

{

    return m_InterruptTime;

}

/*************************************************/


void
CCaptureDevice::
Interrupt (
    )

/*++

Routine Description:

    This is the "faked" interrupt service routine for this device.  It
    is called at dispatch level by the hardware simulation.

Arguments:

    None

Return Value:

    None

--*/

{

    m_InterruptTime++;

    //
    // Realistically, we'd do some hardware manipulation here and then queue
    // a DPC.  Since this is fake hardware, we do what's necessary here.  This
    // is pretty much what the DPC would look like short of the access
    // of hardware registers (ReadNumberOfMappingsCompleted) which would likely
    // be done in the ISR.
    //
    ULONG NumMappingsCompleted = 
        m_HardwareSimulation -> ReadNumberOfMappingsCompleted ();

    //
    // Inform the capture sink that a given number of scatter / gather
    // mappings have completed.
    //
    m_CaptureSink -> CompleteMappings (
        NumMappingsCompleted - m_LastMappingsCompleted
        );

    m_LastMappingsCompleted = NumMappingsCompleted;

}

/**************************************************************************

    DESCRIPTOR AND DISPATCH LAYOUT

**************************************************************************/

//
// CaptureFilterDescriptor:
//
// The filter descriptor for the capture device.
DEFINE_KSFILTER_DESCRIPTOR_TABLE (FilterDescriptors) { 
    &CaptureFilterDescriptor
};

//
// CaptureDeviceDispatch:
//
// This is the dispatch table for the capture device.  Plug and play
// notifications as well as power management notifications are dispatched
// through this table.
//
const
KSDEVICE_DISPATCH
CaptureDeviceDispatch = {
    CCaptureDevice::DispatchCreate,         // Pnp Add Device
    CCaptureDevice::DispatchPnpStart,       // Pnp Start
    NULL,                                   // Post-Start
    NULL,                                   // Pnp Query Stop
    NULL,                                   // Pnp Cancel Stop
    CCaptureDevice::DispatchPnpStop,        // Pnp Stop
    NULL,                                   // Pnp Query Remove
    NULL,                                   // Pnp Cancel Remove
    NULL,                                   // Pnp Remove
    NULL,                                   // Pnp Query Capabilities
    NULL,                                   // Pnp Surprise Removal
    NULL,                                   // Power Query Power
    NULL,                                   // Power Set Power
    NULL                                    // Pnp Query Interface
};

//
// CaptureDeviceDescriptor:
//
// This is the device descriptor for the capture device.  It points to the
// dispatch table and contains a list of filter descriptors that describe
// filter-types that this device supports.  Note that the filter-descriptors
// can be created dynamically and the factories created via 
// KsCreateFilterFactory as well.  
//
const
KSDEVICE_DESCRIPTOR
CaptureDeviceDescriptor = {
    &CaptureDeviceDispatch,
    SIZEOF_ARRAY (FilterDescriptors),
    FilterDescriptors,
    KSDEVICE_DESCRIPTOR_VERSION
};

/**************************************************************************

    INITIALIZATION CODE

**************************************************************************/


extern "C"
NTSTATUS
DriverEntry (
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    Driver entry point.  Pass off control to the AVStream initialization
    function (KsInitializeDriver) and return the status code from it.

Arguments:

    DriverObject -
        The WDM driver object for our driver

    RegistryPath -
        The registry path for our registry info

Return Value:

    As from KsInitializeDriver

--*/

{

    //
    // Simply pass the device descriptor and parameters off to AVStream
    // to initialize us.  This will cause filter factories to be set up
    // at add & start.  Everything is done based on the descriptors passed
    // here.
    //
    return 
        KsInitializeDriver (
            DriverObject,
            RegistryPath,
            &CaptureDeviceDescriptor
            );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\ksfilter\tests\avshws\hwsim.h ===
/**************************************************************************

    AVStream Simulated Hardware Sample

    Copyright (c) 2001, Microsoft Corporation.

    File:

        hwsim.cpp

    Abstract:
        
        This file is the hardware simulation header.  

        The simulation fakes "DMA" transfers, scatter gather mapping handling, 
        ISR's, etc...  The ISR routine in here will be called when an ISR 
        would be generated by the fake hardware and it will directly call into 
        the device level ISR for more accurate simulation.

    History:

        created 3/9/2001

**************************************************************************/

//
// SCATTER_GATHER_MAPPINGS_MAX:
//
// The maximum number of entries in the hardware's scatter/gather list.  I
// am making this so large for a few reasons:
//
//     1) we're faking this with uncompressed surfaces -- 
//            these are large buffers which will map to a lot of s/g entries
//     2) the fake hardware implementation requires at least one frame's
//            worth of s/g entries to generate a frame
//
#define SCATTER_GATHER_MAPPINGS_MAX 128

//
// SCATTER_GATHER_ENTRY:
//
// This structure is used to keep the scatter gather table for the fake
// hardware as a doubly linked list.
//
typedef struct _SCATTER_GATHER_ENTRY {

    LIST_ENTRY ListEntry;
    PUCHAR Virtual;
    ULONG ByteCount;

} SCATTER_GATHER_ENTRY, *PSCATTER_GATHER_ENTRY;

//
// CHardwareSimulation:
//
// The hardware simulation class.
//
class CHardwareSimulation {

private:

    //
    // The image synthesizer.  This is a piece of code which actually draws
    // the requested images.
    //
    CImageSynthesizer *m_ImageSynth;

    //
    // The synthesis buffer.  This is a private buffer we use to generate the
    // capture image in.  The fake "scatter / gather" mappings are filled
    // in from this buffer during each interrupt.
    //
    PUCHAR m_SynthesisBuffer;

    //
    // Key information regarding the frames we generate.
    //
    LONGLONG m_TimePerFrame;
    ULONG m_Width;
    ULONG m_Height;
    ULONG m_ImageSize;

    //
    // Scatter gather mappings for the simulated hardware.
    //
    KSPIN_LOCK m_ListLock;
    LIST_ENTRY m_ScatterGatherMappings;

    //
    // Lookaside for memory for the scatter / gather entries on the scatter /
    // gather list.
    //
    NPAGED_LOOKASIDE_LIST m_ScatterGatherLookaside;

    //
    // The current state of the fake hardware.
    //
    HARDWARE_STATE m_HardwareState;

    //
    // The pause / stop hardware flag and event.
    //
    BOOLEAN m_StopHardware;
    KEVENT m_HardwareEvent;

    //
    // Maximum number of scatter / gather mappins in the s/g table of the
    // fake hardware.
    //
    ULONG m_ScatterGatherMappingsMax;

    //
    // Number of scatter / gather mappings that have been completed (total)
    // since the start of the hardware or any reset.
    //
    ULONG m_NumMappingsCompleted;

    //
    // Number of scatter / gather mappings that are queued for this hardware.
    //
    ULONG m_ScatterGatherMappingsQueued;
    ULONG m_ScatterGatherBytesQueued;

    //
    // Number of frames skipped due to lack of scatter / gather mappings.
    //
    ULONG m_NumFramesSkipped;

    //
    // The "Interrupt Time".  Number of "fake" interrupts that have occurred
    // since the hardware was started.
    // 
    ULONG m_InterruptTime;

    //
    // The system time at start.
    //
    LARGE_INTEGER m_StartTime;
    
    //
    // The DPC used to "fake" ISR
    //
    KDPC m_IsrFakeDpc;
    KTIMER m_IsrTimer;

    //
    // The hardware sink that will be used for interrupt notifications.
    //
    IHardwareSink *m_HardwareSink;

    //
    // FakeHardware():
    //
    // Called from the simulated interrupt.  First we fake the hardware's
    // actions (at DPC) then we call the "Interrupt service routine" on
    // the hardware sink.
    //
    void 
    FakeHardware (
        );

    //
    // SimulatedInterrupt():
    //
    // This is the hardware's simulated interrupt.  Really, it's just a DPC.
    // We'll use a spinlock instead of any KeSynchronizeExecutions.
    //
    static
    void
    SimulatedInterrupt (
        IN PKDPC Dpc,
        IN CHardwareSimulation *HardwareSim,
        IN PVOID SystemArg1,
        IN PVOID SystemArg2
        )
    {
        HardwareSim -> FakeHardware ();
    }

    //
    // FillScatterGatherBuffers():
    //
    // This is called by the hardware simulation to fill a series of scatter /
    // gather buffers with synthesized data.
    //
    NTSTATUS
    FillScatterGatherBuffers (
        );

public:

    //
    // CHardwareSimulation():
    //
    // The hardware simulation constructor.  Since the new operator will
    // have zeroed the memory, only initialize non-NULL, non-0 fields. 
    //
    CHardwareSimulation (
        IN IHardwareSink *HardwareSink
        );

    //
    // ~CHardwareSimulation():
    //
    // The hardware simulation destructor.
    //
    ~CHardwareSimulation (
        )
    {
    }

    //
    // Cleanup():
    //
    // This is the free callback for the bagged hardware sim.  Not providing
    // one will call ExFreePool, which is not what we want for a constructed
    // C++ object.  This simply deletes the simulation.
    //
    static
    void
    Cleanup (
        IN CHardwareSimulation *HwSim
        )
    {
        delete HwSim;
    }

    //
    // Start():
    //
    // "Start" the fake hardware.  This will start issuing interrupts and 
    // DPC's. 
    //
    // The frame rate, image size, and a synthesizer must be provided.
    //
    NTSTATUS
    Start (
        CImageSynthesizer *ImageSynth,
        IN LONGLONG TimePerFrame,
        IN ULONG Width,
        IN ULONG Height,
        IN ULONG ImageSize
        );

    //
    // Pause():
    //
    // "Pause" or "unpause" the fake hardware.  This will stop issuing 
    // interrupts or DPC's on a pause and restart them on an unpause.  Note
    // that this will not reset counters as a Stop() would.
    //
    NTSTATUS
    Pause (
        IN BOOLEAN Pausing
        );

    //
    // Stop():
    //
    // "Stop" the fake hardware.  This will stop issuing interrupts and
    // DPC's.
    //
    NTSTATUS
    Stop (
        );

    //
    // ProgramScatterGatherMappings():
    //
    // Program a series of scatter gather mappings into the fake hardware.
    //
    ULONG
    ProgramScatterGatherMappings (
        IN PUCHAR *Buffer,
        IN PKSMAPPING Mappings,
        IN ULONG MappingsCount,
        IN ULONG MappingStride
        );

    //
    // Initialize():
    //
    // Initialize a piece of simulated hardware.
    //
    static 
    CHardwareSimulation *
    Initialize (
        IN KSOBJECT_BAG Bag,
        IN IHardwareSink *HardwareSink
        );

    //
    // ReadNumberOfMappingsCompleted():
    //
    // Read the number of mappings completed since the last hardware reset.
    //
    ULONG
    ReadNumberOfMappingsCompleted (
        );

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\ksfilter\tests\avshws\image.cpp ===
/**************************************************************************

    AVStream Simulated Hardware Sample

    Copyright (c) 2001, Microsoft Corporation.

    File:

        image.cpp

    Abstract:

        The image synthesis and overlay code.  These objects provide image
        synthesis (pixel, color-bar, etc...) onto RGB24 and UYVY buffers as
        well as software string overlay into these buffers.

	This entire file, data and all, must be in locked segments.

    History:

        created 1/16/2001

**************************************************************************/

#include "avshws.h"

/**************************************************************************

    Constants

**************************************************************************/

//
// g_FontData:
//
// The following is an 8x8 bitmapped font for use in the text overlay
// code.
//
UCHAR g_FontData [256][8] = {
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x7e, 0x81, 0xa5, 0x81, 0xbd, 0x99, 0x81, 0x7e},
    {0x7e, 0xff, 0xdb, 0xff, 0xc3, 0xe7, 0xff, 0x7e},
    {0x6c, 0xfe, 0xfe, 0xfe, 0x7c, 0x38, 0x10, 0x00},
    {0x10, 0x38, 0x7c, 0xfe, 0x7c, 0x38, 0x10, 0x00},
    {0x38, 0x7c, 0x38, 0xfe, 0xfe, 0x7c, 0x38, 0x7c},
    {0x10, 0x10, 0x38, 0x7c, 0xfe, 0x7c, 0x38, 0x7c},
    {0x00, 0x00, 0x18, 0x3c, 0x3c, 0x18, 0x00, 0x00},
    {0xff, 0xff, 0xe7, 0xc3, 0xc3, 0xe7, 0xff, 0xff},
    {0x00, 0x3c, 0x66, 0x42, 0x42, 0x66, 0x3c, 0x00},
    {0xff, 0xc3, 0x99, 0xbd, 0xbd, 0x99, 0xc3, 0xff},
    {0x0f, 0x07, 0x0f, 0x7d, 0xcc, 0xcc, 0xcc, 0x78},
    {0x3c, 0x66, 0x66, 0x66, 0x3c, 0x18, 0x7e, 0x18},
    {0x3f, 0x33, 0x3f, 0x30, 0x30, 0x70, 0xf0, 0xe0},
    {0x7f, 0x63, 0x7f, 0x63, 0x63, 0x67, 0xe6, 0xc0},
    {0x99, 0x5a, 0x3c, 0xe7, 0xe7, 0x3c, 0x5a, 0x99},
    {0x80, 0xe0, 0xf8, 0xfe, 0xf8, 0xe0, 0x80, 0x00},
    {0x02, 0x0e, 0x3e, 0xfe, 0x3e, 0x0e, 0x02, 0x00},
    {0x18, 0x3c, 0x7e, 0x18, 0x18, 0x7e, 0x3c, 0x18},
    {0x66, 0x66, 0x66, 0x66, 0x66, 0x00, 0x66, 0x00},
    {0x7f, 0xdb, 0xdb, 0x7b, 0x1b, 0x1b, 0x1b, 0x00},
    {0x3e, 0x63, 0x38, 0x6c, 0x6c, 0x38, 0xcc, 0x78},
    {0x00, 0x00, 0x00, 0x00, 0x7e, 0x7e, 0x7e, 0x00},
    {0x18, 0x3c, 0x7e, 0x18, 0x7e, 0x3c, 0x18, 0xff},
    {0x18, 0x3c, 0x7e, 0x18, 0x18, 0x18, 0x18, 0x00},
    {0x18, 0x18, 0x18, 0x18, 0x7e, 0x3c, 0x18, 0x00},
    {0x00, 0x18, 0x0c, 0xfe, 0x0c, 0x18, 0x00, 0x00},
    {0x00, 0x30, 0x60, 0xfe, 0x60, 0x30, 0x00, 0x00},
    {0x00, 0x00, 0xc0, 0xc0, 0xc0, 0xfe, 0x00, 0x00},
    {0x00, 0x24, 0x66, 0xff, 0x66, 0x24, 0x00, 0x00},
    {0x00, 0x18, 0x3c, 0x7e, 0xff, 0xff, 0x00, 0x00},
    {0x00, 0xff, 0xff, 0x7e, 0x3c, 0x18, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x30, 0x78, 0x78, 0x30, 0x30, 0x00, 0x30, 0x00},
    {0x6c, 0x6c, 0x6c, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x6c, 0x6c, 0xfe, 0x6c, 0xfe, 0x6c, 0x6c, 0x00},
    {0x30, 0x7c, 0xc0, 0x78, 0x0c, 0xf8, 0x30, 0x00},
    {0x00, 0xc6, 0xcc, 0x18, 0x30, 0x66, 0xc6, 0x00},
    {0x38, 0x6c, 0x38, 0x76, 0xdc, 0xcc, 0x76, 0x00},
    {0x60, 0x60, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x18, 0x30, 0x60, 0x60, 0x60, 0x30, 0x18, 0x00},
    {0x60, 0x30, 0x18, 0x18, 0x18, 0x30, 0x60, 0x00},
    {0x00, 0x66, 0x3c, 0xff, 0x3c, 0x66, 0x00, 0x00},
    {0x00, 0x30, 0x30, 0xfc, 0x30, 0x30, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x60},
    {0x00, 0x00, 0x00, 0xfc, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x00},
    {0x06, 0x0c, 0x18, 0x30, 0x60, 0xc0, 0x80, 0x00},
    {0x7c, 0xc6, 0xce, 0xde, 0xf6, 0xe6, 0x7c, 0x00},
    {0x30, 0x70, 0x30, 0x30, 0x30, 0x30, 0xfc, 0x00},
    {0x78, 0xcc, 0x0c, 0x38, 0x60, 0xcc, 0xfc, 0x00},
    {0x78, 0xcc, 0x0c, 0x38, 0x0c, 0xcc, 0x78, 0x00},
    {0x1c, 0x3c, 0x6c, 0xcc, 0xfe, 0x0c, 0x1e, 0x00},
    {0xfc, 0xc0, 0xf8, 0x0c, 0x0c, 0xcc, 0x78, 0x00},
    {0x38, 0x60, 0xc0, 0xf8, 0xcc, 0xcc, 0x78, 0x00},
    {0xfc, 0xcc, 0x0c, 0x18, 0x30, 0x30, 0x30, 0x00},
    {0x78, 0xcc, 0xcc, 0x78, 0xcc, 0xcc, 0x78, 0x00},
    {0x78, 0xcc, 0xcc, 0x7c, 0x0c, 0x18, 0x70, 0x00},
    {0x00, 0x30, 0x30, 0x00, 0x00, 0x30, 0x30, 0x00},
    {0x00, 0x30, 0x30, 0x00, 0x00, 0x30, 0x30, 0x60},
    {0x18, 0x30, 0x60, 0xc0, 0x60, 0x30, 0x18, 0x00},
    {0x00, 0x00, 0xfc, 0x00, 0x00, 0xfc, 0x00, 0x00},
    {0x60, 0x30, 0x18, 0x0c, 0x18, 0x30, 0x60, 0x00},
    {0x78, 0xcc, 0x0c, 0x18, 0x30, 0x00, 0x30, 0x00},
    {0x7c, 0xc6, 0xde, 0xde, 0xde, 0xc0, 0x78, 0x00},
    {0x30, 0x78, 0xcc, 0xcc, 0xfc, 0xcc, 0xcc, 0x00},
    {0xfc, 0x66, 0x66, 0x7c, 0x66, 0x66, 0xfc, 0x00},
    {0x3c, 0x66, 0xc0, 0xc0, 0xc0, 0x66, 0x3c, 0x00},
    {0xf8, 0x6c, 0x66, 0x66, 0x66, 0x6c, 0xf8, 0x00},
    {0xfe, 0x62, 0x68, 0x78, 0x68, 0x62, 0xfe, 0x00},
    {0xfe, 0x62, 0x68, 0x78, 0x68, 0x60, 0xf0, 0x00},
    {0x3c, 0x66, 0xc0, 0xc0, 0xce, 0x66, 0x3e, 0x00},
    {0xcc, 0xcc, 0xcc, 0xfc, 0xcc, 0xcc, 0xcc, 0x00},
    {0x78, 0x30, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00},
    {0x1e, 0x0c, 0x0c, 0x0c, 0xcc, 0xcc, 0x78, 0x00},
    {0xe6, 0x66, 0x6c, 0x78, 0x6c, 0x66, 0xe6, 0x00},
    {0xf0, 0x60, 0x60, 0x60, 0x62, 0x66, 0xfe, 0x00},
    {0xc6, 0xee, 0xfe, 0xfe, 0xd6, 0xc6, 0xc6, 0x00},
    {0xc6, 0xe6, 0xf6, 0xde, 0xce, 0xc6, 0xc6, 0x00},
    {0x38, 0x6c, 0xc6, 0xc6, 0xc6, 0x6c, 0x38, 0x00},
    {0xfc, 0x66, 0x66, 0x7c, 0x60, 0x60, 0xf0, 0x00},
    {0x78, 0xcc, 0xcc, 0xcc, 0xdc, 0x78, 0x1c, 0x00},
    {0xfc, 0x66, 0x66, 0x7c, 0x6c, 0x66, 0xe6, 0x00},
    {0x78, 0xcc, 0xe0, 0x70, 0x1c, 0xcc, 0x78, 0x00},
    {0xfc, 0xb4, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00},
    {0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xfc, 0x00},
    {0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0x78, 0x30, 0x00},
    {0xc6, 0xc6, 0xc6, 0xd6, 0xfe, 0xee, 0xc6, 0x00},
    {0xc6, 0xc6, 0x6c, 0x38, 0x38, 0x6c, 0xc6, 0x00},
    {0xcc, 0xcc, 0xcc, 0x78, 0x30, 0x30, 0x78, 0x00},
    {0xfe, 0xc6, 0x8c, 0x18, 0x32, 0x66, 0xfe, 0x00},
    {0x78, 0x60, 0x60, 0x60, 0x60, 0x60, 0x78, 0x00},
    {0xc0, 0x60, 0x30, 0x18, 0x0c, 0x06, 0x02, 0x00},
    {0x78, 0x18, 0x18, 0x18, 0x18, 0x18, 0x78, 0x00},
    {0x10, 0x38, 0x6c, 0xc6, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff},
    {0x30, 0x30, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x78, 0x0c, 0x7c, 0xcc, 0x76, 0x00},
    {0xe0, 0x60, 0x60, 0x7c, 0x66, 0x66, 0xdc, 0x00},
    {0x00, 0x00, 0x78, 0xcc, 0xc0, 0xcc, 0x78, 0x00},
    {0x1c, 0x0c, 0x0c, 0x7c, 0xcc, 0xcc, 0x76, 0x00},
    {0x00, 0x00, 0x78, 0xcc, 0xfc, 0xc0, 0x78, 0x00},
    {0x38, 0x6c, 0x60, 0xf0, 0x60, 0x60, 0xf0, 0x00},
    {0x00, 0x00, 0x76, 0xcc, 0xcc, 0x7c, 0x0c, 0xf8},
    {0xe0, 0x60, 0x6c, 0x76, 0x66, 0x66, 0xe6, 0x00},
    {0x30, 0x00, 0x70, 0x30, 0x30, 0x30, 0x78, 0x00},
    {0x0c, 0x00, 0x0c, 0x0c, 0x0c, 0xcc, 0xcc, 0x78},
    {0xe0, 0x60, 0x66, 0x6c, 0x78, 0x6c, 0xe6, 0x00},
    {0x70, 0x30, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00},
    {0x00, 0x00, 0xcc, 0xfe, 0xfe, 0xd6, 0xc6, 0x00},
    {0x00, 0x00, 0xf8, 0xcc, 0xcc, 0xcc, 0xcc, 0x00},
    {0x00, 0x00, 0x78, 0xcc, 0xcc, 0xcc, 0x78, 0x00},
    {0x00, 0x00, 0xdc, 0x66, 0x66, 0x7c, 0x60, 0xf0},
    {0x00, 0x00, 0x76, 0xcc, 0xcc, 0x7c, 0x0c, 0x1e},
    {0x00, 0x00, 0xdc, 0x76, 0x66, 0x60, 0xf0, 0x00},
    {0x00, 0x00, 0x7c, 0xc0, 0x78, 0x0c, 0xf8, 0x00},
    {0x10, 0x30, 0x7c, 0x30, 0x30, 0x34, 0x18, 0x00},
    {0x00, 0x00, 0xcc, 0xcc, 0xcc, 0xcc, 0x76, 0x00},
    {0x00, 0x00, 0xcc, 0xcc, 0xcc, 0x78, 0x30, 0x00},
    {0x00, 0x00, 0xc6, 0xd6, 0xfe, 0xfe, 0x6c, 0x00},
    {0x00, 0x00, 0xc6, 0x6c, 0x38, 0x6c, 0xc6, 0x00},
    {0x00, 0x00, 0xcc, 0xcc, 0xcc, 0x7c, 0x0c, 0xf8},
    {0x00, 0x00, 0xfc, 0x98, 0x30, 0x64, 0xfc, 0x00},
    {0x1c, 0x30, 0x30, 0xe0, 0x30, 0x30, 0x1c, 0x00},
    {0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x00},
    {0xe0, 0x30, 0x30, 0x1c, 0x30, 0x30, 0xe0, 0x00},
    {0x76, 0xdc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x10, 0x38, 0x6c, 0xc6, 0xc6, 0xfe, 0x00},
    {0x78, 0xcc, 0xc0, 0xcc, 0x78, 0x18, 0x0c, 0x78},
    {0x00, 0xcc, 0x00, 0xcc, 0xcc, 0xcc, 0x7e, 0x00},
    {0x1c, 0x00, 0x78, 0xcc, 0xfc, 0xc0, 0x78, 0x00},
    {0x7e, 0xc3, 0x3c, 0x06, 0x3e, 0x66, 0x3f, 0x00},
    {0xcc, 0x00, 0x78, 0x0c, 0x7c, 0xcc, 0x7e, 0x00},
    {0xe0, 0x00, 0x78, 0x0c, 0x7c, 0xcc, 0x7e, 0x00},
    {0x30, 0x30, 0x78, 0x0c, 0x7c, 0xcc, 0x7e, 0x00},
    {0x00, 0x00, 0x78, 0xc0, 0xc0, 0x78, 0x0c, 0x38},
    {0x7e, 0xc3, 0x3c, 0x66, 0x7e, 0x60, 0x3c, 0x00},
    {0xcc, 0x00, 0x78, 0xcc, 0xfc, 0xc0, 0x78, 0x00},
    {0xe0, 0x00, 0x78, 0xcc, 0xfc, 0xc0, 0x78, 0x00},
    {0xcc, 0x00, 0x70, 0x30, 0x30, 0x30, 0x78, 0x00},
    {0x7c, 0xc6, 0x38, 0x18, 0x18, 0x18, 0x3c, 0x00},
    {0xe0, 0x00, 0x70, 0x30, 0x30, 0x30, 0x78, 0x00},
    {0xc6, 0x38, 0x6c, 0xc6, 0xfe, 0xc6, 0xc6, 0x00},
    {0x30, 0x30, 0x00, 0x78, 0xcc, 0xfc, 0xcc, 0x00},
    {0x1c, 0x00, 0xfc, 0x60, 0x78, 0x60, 0xfc, 0x00},
    {0x00, 0x00, 0x7f, 0x0c, 0x7f, 0xcc, 0x7f, 0x00},
    {0x3e, 0x6c, 0xcc, 0xfe, 0xcc, 0xcc, 0xce, 0x00},
    {0x78, 0xcc, 0x00, 0x78, 0xcc, 0xcc, 0x78, 0x00},
    {0x00, 0xcc, 0x00, 0x78, 0xcc, 0xcc, 0x78, 0x00},
    {0x00, 0xe0, 0x00, 0x78, 0xcc, 0xcc, 0x78, 0x00},
    {0x78, 0xcc, 0x00, 0xcc, 0xcc, 0xcc, 0x7e, 0x00},
    {0x00, 0xe0, 0x00, 0xcc, 0xcc, 0xcc, 0x7e, 0x00},
    {0x00, 0xcc, 0x00, 0xcc, 0xcc, 0x7c, 0x0c, 0xf8},
    {0xc3, 0x18, 0x3c, 0x66, 0x66, 0x3c, 0x18, 0x00},
    {0xcc, 0x00, 0xcc, 0xcc, 0xcc, 0xcc, 0x78, 0x00},
    {0x18, 0x18, 0x7e, 0xc0, 0xc0, 0x7e, 0x18, 0x18},
    {0x38, 0x6c, 0x64, 0xf0, 0x60, 0xe6, 0xfc, 0x00},
    {0xcc, 0xcc, 0x78, 0xfc, 0x30, 0xfc, 0x30, 0x30},
    {0xf8, 0xcc, 0xcc, 0xfa, 0xc6, 0xcf, 0xc6, 0xc7},
    {0x0e, 0x1b, 0x18, 0x3c, 0x18, 0x18, 0xd8, 0x70},
    {0x1c, 0x00, 0x78, 0x0c, 0x7c, 0xcc, 0x7e, 0x00},
    {0x38, 0x00, 0x70, 0x30, 0x30, 0x30, 0x78, 0x00},
    {0x00, 0x1c, 0x00, 0x78, 0xcc, 0xcc, 0x78, 0x00},
    {0x00, 0x1c, 0x00, 0xcc, 0xcc, 0xcc, 0x7e, 0x00},
    {0x00, 0xf8, 0x00, 0xf8, 0xcc, 0xcc, 0xcc, 0x00},
    {0xfc, 0x00, 0xcc, 0xec, 0xfc, 0xdc, 0xcc, 0x00},
    {0x3c, 0x6c, 0x6c, 0x3e, 0x00, 0x7e, 0x00, 0x00},
    {0x38, 0x6c, 0x6c, 0x38, 0x00, 0x7c, 0x00, 0x00},
    {0x30, 0x00, 0x30, 0x60, 0xc0, 0xcc, 0x78, 0x00},
    {0x00, 0x00, 0x00, 0xfc, 0xc0, 0xc0, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0xfc, 0x0c, 0x0c, 0x00, 0x00},
    {0xc3, 0xc6, 0xcc, 0xde, 0x33, 0x66, 0xcc, 0x0f},
    {0xc3, 0xc6, 0xcc, 0xdb, 0x37, 0x6f, 0xcf, 0x03},
    {0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x18, 0x00},
    {0x00, 0x33, 0x66, 0xcc, 0x66, 0x33, 0x00, 0x00},
    {0x00, 0xcc, 0x66, 0x33, 0x66, 0xcc, 0x00, 0x00},
    {0x22, 0x88, 0x22, 0x88, 0x22, 0x88, 0x22, 0x88},
    {0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa},
    {0xdb, 0x77, 0xdb, 0xee, 0xdb, 0x77, 0xdb, 0xee},
    {0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18},
    {0x18, 0x18, 0x18, 0x18, 0xf8, 0x18, 0x18, 0x18},
    {0x18, 0x18, 0xf8, 0x18, 0xf8, 0x18, 0x18, 0x18},
    {0x36, 0x36, 0x36, 0x36, 0xf6, 0x36, 0x36, 0x36},
    {0x00, 0x00, 0x00, 0x00, 0xfe, 0x36, 0x36, 0x36},
    {0x00, 0x00, 0xf8, 0x18, 0xf8, 0x18, 0x18, 0x18},
    {0x36, 0x36, 0xf6, 0x06, 0xf6, 0x36, 0x36, 0x36},
    {0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36},
    {0x00, 0x00, 0xfe, 0x06, 0xf6, 0x36, 0x36, 0x36},
    {0x36, 0x36, 0xf6, 0x06, 0xfe, 0x00, 0x00, 0x00},
    {0x36, 0x36, 0x36, 0x36, 0xfe, 0x00, 0x00, 0x00},
    {0x18, 0x18, 0xf8, 0x18, 0xf8, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0xf8, 0x18, 0x18, 0x18},
    {0x18, 0x18, 0x18, 0x18, 0x1f, 0x00, 0x00, 0x00},
    {0x18, 0x18, 0x18, 0x18, 0xff, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0xff, 0x18, 0x18, 0x18},
    {0x18, 0x18, 0x18, 0x18, 0x1f, 0x18, 0x18, 0x18},
    {0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00},
    {0x18, 0x18, 0x18, 0x18, 0xff, 0x18, 0x18, 0x18},
    {0x18, 0x18, 0x1f, 0x18, 0x1f, 0x18, 0x18, 0x18},
    {0x36, 0x36, 0x36, 0x36, 0x37, 0x36, 0x36, 0x36},
    {0x36, 0x36, 0x37, 0x30, 0x3f, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x3f, 0x30, 0x37, 0x36, 0x36, 0x36},
    {0x36, 0x36, 0xf7, 0x00, 0xff, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0xff, 0x00, 0xf7, 0x36, 0x36, 0x36},
    {0x36, 0x36, 0x37, 0x30, 0x37, 0x36, 0x36, 0x36},
    {0x00, 0x00, 0xff, 0x00, 0xff, 0x00, 0x00, 0x00},
    {0x36, 0x36, 0xf7, 0x00, 0xf7, 0x36, 0x36, 0x36},
    {0x18, 0x18, 0xff, 0x00, 0xff, 0x00, 0x00, 0x00},
    {0x36, 0x36, 0x36, 0x36, 0xff, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0xff, 0x00, 0xff, 0x18, 0x18, 0x18},
    {0x00, 0x00, 0x00, 0x00, 0xff, 0x36, 0x36, 0x36},
    {0x36, 0x36, 0x36, 0x36, 0x3f, 0x00, 0x00, 0x00},
    {0x18, 0x18, 0x1f, 0x18, 0x1f, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x1f, 0x18, 0x1f, 0x18, 0x18, 0x18},
    {0x00, 0x00, 0x00, 0x00, 0x3f, 0x36, 0x36, 0x36},
    {0x36, 0x36, 0x36, 0x36, 0xff, 0x36, 0x36, 0x36},
    {0x18, 0x18, 0xff, 0x18, 0xff, 0x18, 0x18, 0x18},
    {0x18, 0x18, 0x18, 0x18, 0xf8, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x1f, 0x18, 0x18, 0x18},
    {0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff},
    {0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff},
    {0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0},
    {0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f},
    {0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x76, 0xdc, 0xc8, 0xdc, 0x76, 0x00},
    {0x00, 0x78, 0xcc, 0xf8, 0xcc, 0xf8, 0xc0, 0xc0},
    {0x00, 0xfc, 0xcc, 0xc0, 0xc0, 0xc0, 0xc0, 0x00},
    {0x00, 0xfe, 0x6c, 0x6c, 0x6c, 0x6c, 0x6c, 0x00},
    {0xfc, 0xcc, 0x60, 0x30, 0x60, 0xcc, 0xfc, 0x00},
    {0x00, 0x00, 0x7e, 0xd8, 0xd8, 0xd8, 0x70, 0x00},
    {0x00, 0x66, 0x66, 0x66, 0x66, 0x7c, 0x60, 0xc0},
    {0x00, 0x76, 0xdc, 0x18, 0x18, 0x18, 0x18, 0x00},
    {0xfc, 0x30, 0x78, 0xcc, 0xcc, 0x78, 0x30, 0xfc},
    {0x38, 0x6c, 0xc6, 0xfe, 0xc6, 0x6c, 0x38, 0x00},
    {0x38, 0x6c, 0xc6, 0xc6, 0x6c, 0x6c, 0xee, 0x00},
    {0x1c, 0x30, 0x18, 0x7c, 0xcc, 0xcc, 0x78, 0x00},
    {0x00, 0x00, 0x7e, 0xdb, 0xdb, 0x7e, 0x00, 0x00},
    {0x06, 0x0c, 0x7e, 0xdb, 0xdb, 0x7e, 0x60, 0xc0},
    {0x38, 0x60, 0xc0, 0xf8, 0xc0, 0x60, 0x38, 0x00},
    {0x78, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0x00},
    {0x00, 0xfc, 0x00, 0xfc, 0x00, 0xfc, 0x00, 0x00},
    {0x30, 0x30, 0xfc, 0x30, 0x30, 0x00, 0xfc, 0x00},
    {0x60, 0x30, 0x18, 0x30, 0x60, 0x00, 0xfc, 0x00},
    {0x18, 0x30, 0x60, 0x30, 0x18, 0x00, 0xfc, 0x00},
    {0x0e, 0x1b, 0x1b, 0x18, 0x18, 0x18, 0x18, 0x18},
    {0x18, 0x18, 0x18, 0x18, 0x18, 0xd8, 0xd8, 0x70},
    {0x30, 0x30, 0x00, 0xfc, 0x00, 0x30, 0x30, 0x00},
    {0x00, 0x76, 0xdc, 0x00, 0x76, 0xdc, 0x00, 0x00},
    {0x38, 0x6c, 0x6c, 0x38, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00},
    {0x0f, 0x0c, 0x0c, 0x0c, 0xec, 0x6c, 0x3c, 0x1c},
    {0x78, 0x6c, 0x6c, 0x6c, 0x6c, 0x00, 0x00, 0x00},
    {0x70, 0x18, 0x30, 0x60, 0x78, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x3c, 0x3c, 0x3c, 0x3c, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
};

//
// Standard definition of EIA-189-A color bars.  The actual color definitions
// are either in CRGB24Synthesizer or CYUVSynthesizer.
//
const COLOR g_ColorBars[] = 
    {WHITE, YELLOW, CYAN, GREEN, MAGENTA, RED, BLUE, BLACK};

const UCHAR CRGB24Synthesizer::Colors [MAX_COLOR][3] = {
    {0, 0, 0},          // BLACK
    {255, 255, 255},    // WHITE
    {0, 255, 255},      // YELLOW
    {255, 255, 0},      // CYAN
    {0, 255, 0},        // GREEN
    {255, 0, 255},      // MAGENTA
    {0, 0, 255},        // RED
    {255, 0, 0},        // BLUE
    {128, 128, 128}     // GREY
};

const UCHAR CYUVSynthesizer::Colors [MAX_COLOR][3] = {
    {128, 16, 128},     // BLACK
    {128, 235, 128},    // WHITE
    {16, 211, 146},     // YELLOW
    {166, 170, 16},     // CYAN
    {54, 145, 34},      // GREEN
    {202, 106, 222},    // MAGENTA
    {90, 81, 240},      // RED
    {240, 41, 109},     // BLUE
    {128, 125, 128},    // GREY
};

/**************************************************************************

    LOCKED CODE

**************************************************************************/

#ifdef ALLOC_PRAGMA
#pragma code_seg()
#endif // ALLOC_PRAGMA


void
CImageSynthesizer::
SynthesizeBars (
    )

/*++

Routine Description:

    Synthesize EIA-189-A standard color bars onto the Image.  The image
    in question is the current synthesis buffer.

Arguments:

    None

Return Value:

    None

--*/

{
    const COLOR *CurColor = g_ColorBars;
    ULONG ColorCount = SIZEOF_ARRAY (g_ColorBars);

    //
    // Set the default cursor...
    //
    GetImageLocation (0, 0);

    //
    // Synthesize a single line.
    //
    PUCHAR ImageStart = m_Cursor;
    for (ULONG x = 0; x < m_Width; x++) 
        PutPixel (g_ColorBars [((x * ColorCount) / m_Width)]);

    PUCHAR ImageEnd = m_Cursor;
    
    //
    // Copy the synthesized line to all subsequent lines.
    //
    for (ULONG line = 1; line < m_Height; line++) {

        GetImageLocation (0, line);

        RtlCopyMemory (
            m_Cursor,
            ImageStart,
            ImageEnd - ImageStart
            );
    }
}

/*************************************************/


void 
CImageSynthesizer::
OverlayText (
    ULONG LocX,
    ULONG LocY,
    ULONG Scaling,
    CHAR *Text,
    COLOR BgColor,
    COLOR FgColor
    )

/*++

Routine Description:

    Overlay text onto the synthesized image.  Clip to fit the image
    if the overlay does not fit.  The image buffer used is the set
    synthesis buffer.

Arguments:

    LocX -
        The X location on the image to begin the overlay.  This MUST
        be inside the image.  POSITION_CENTER may be used to indicate
        horizontal centering.

    LocY -
        The Y location on the image to begin the overlay.  This MUST
        be inside the image.  POSITION_CENTER may be used to indicate
        vertical centering.

    Scaling -
        Normally, the overlay is done in 8x8 font.  A scaling of
        2 indicates 16x16, 3 indicates 24x24 and so forth.

    Text -
        A character string containing the information to overlay

    BgColor -
        The background color of the overlay window.  For transparency,
        indicate TRANSPARENT here.

    FgColor -
        The foreground color for the text overlay.

Return Value:

    None

--*/

{

    ASSERT ((LocX <= m_Width || LocX == POSITION_CENTER) &&
            (LocY <= m_Height || LocY == POSITION_CENTER));

    ULONG StrLen = 0;

    //
    // Determine the character length of the string.
    //
    for (CHAR *CurChar = Text; CurChar && *CurChar; CurChar++)
        StrLen++;

    //
    // Determine the physical size of the string plus border.  There is
    // a definable NO_CHARACTER_SEPARATION.  If this is defined, there will
    // be no added space between font characters.  Otherwise, one empty pixel
    // column is added between characters.
    //
    #ifndef NO_CHARACTER_SEPARATION
        ULONG LenX = (StrLen * (Scaling << 3)) + 1 + StrLen;
    #else // NO_CHARACTER_SEPARATION
        ULONG LenX = (StrLen * (Scaling << 3)) + 2;
    #endif // NO_CHARACTER_SEPARATION

    ULONG LenY = 2 + (Scaling << 3);

    //
    // Adjust for center overlays.
    //
    // NOTE: If the overlay doesn't fit into the synthesis buffer, this
    // merely left aligns the overlay and clips off the right side.
    //
    if (LocX == POSITION_CENTER) {
        if (LenX >= m_Width) {
            LocX = 0;
        } else {
            LocX = (m_Width >> 1) - (LenX >> 1);
        }
    }

    if (LocY == POSITION_CENTER) {
        if (LenY >= m_Height) {
            LocY = 0;
        } else {
            LocY = (m_Height >> 1) - (LenY >> 1);
        }
    }

    //
    // Determine the amount of space available on the synthesis buffer.
    // We will clip anything that finds itself outside the synthesis buffer.
    //
    ULONG SpaceX = m_Width - LocX;
    ULONG SpaceY = m_Height - LocY;

    //
    // Set the default cursor position.
    //
    GetImageLocation (LocX, LocY);

    //
    // Overlay a background color row.
    //
    if (BgColor != TRANSPARENT && SpaceY) {
        for (ULONG x = 0; x < LenX && x < SpaceX; x++) {
            PutPixel (BgColor);
        }
    }
    LocY++;
    if (SpaceY) SpaceY--;

    //
    // Loop across each row of the image.
    //
    for (ULONG row = 0; row < 8 && SpaceY; row++) {
        //
        // Generate a line.
        //
        GetImageLocation (LocX, LocY++);

        PUCHAR ImageStart = m_Cursor;

        ULONG CurSpaceX = SpaceX;
        if (CurSpaceX) {
            PutPixel (BgColor);
            CurSpaceX--;
        }

        //
        // Generate the row'th row of the overlay.
        //
        CurChar = Text;
        while (CurChar && *CurChar) {
            
            UCHAR CharBase = g_FontData [*CurChar++][row];
            for (ULONG mask = 0x80; mask && CurSpaceX; mask >>= 1) {
                for (ULONG scale = 0; scale < Scaling && CurSpaceX; scale++) {
                    if (CharBase & mask) {
                        PutPixel (FgColor);
                    } else {
                        PutPixel (BgColor);
                    }
                    CurSpaceX--;
                }
            }

            // 
            // Separate each character by one space.  Account for the border
            // space at the end by placing the separator after the last 
            // character also.
            //
            #ifndef NO_CHARACTER_SEPARATION
                if (CurSpaceX) {
                    PutPixel (BgColor);
                    CurSpaceX--;
                }
            #endif // NO_CHARACTER_SEPARATION

        }

        //
        // If there is no separation character defined, account for the
        // border.
        // 
        #ifdef NO_CHARACTER_SEPARATION
            if (CurSpaceX) {
                PutPixel (BgColor);
                CurSpaceX--;
            }
        #endif // NO_CHARACTER_SEPARATION
            

        PUCHAR ImageEnd = m_Cursor;
        //
        // Copy the line downward scale times.
        //
        for (ULONG scale = 1; scale < Scaling && SpaceY; scale++) {
            GetImageLocation (LocX, LocY++);
            RtlCopyMemory (m_Cursor, ImageStart, ImageEnd - ImageStart);
            SpaceY--;
        }

    }

    //
    // Add the bottom section of the overlay.
    //
    GetImageLocation (LocX, LocY);
    if (BgColor != TRANSPARENT && SpaceY) {
        for (ULONG x = 0; x < LenX && x < SpaceX; x++) {
            PutPixel (BgColor);
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\ksfilter\tests\avshws\filter.cpp ===
/**************************************************************************

    AVStream Simulated Hardware Sample

    Copyright (c) 2001, Microsoft Corporation.

    File:

        filter.cpp

    Abstract:

        This file contains the filter level implementation for the 
        capture filter.

    History:

        created 3/12/2001

**************************************************************************/

#include "avshws.h"

/**************************************************************************

    PAGEABLE CODE

**************************************************************************/

#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGE")
#endif // ALLOC_PRAGMA


NTSTATUS
CCaptureFilter::
DispatchCreate (
    IN PKSFILTER Filter,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the creation dispatch for the capture filter.  It creates
    the CCaptureFilter object, associates it with the AVStream filter
    object, and bag the CCaptureFilter for later cleanup.

Arguments:

    Filter -
        The AVStream filter being created

    Irp -
        The creation Irp

Return Value:
    
    Success / failure

--*/

{

    PAGED_CODE();

    NTSTATUS Status = STATUS_SUCCESS;

    CCaptureFilter *CapFilter = new (NonPagedPool) CCaptureFilter (Filter);

    if (!CapFilter) {
        //
        // Return failure if we couldn't create the filter.
        //
        Status = STATUS_INSUFFICIENT_RESOURCES;

    } else {
        //
        // Add the item to the object bag if we we were successful. 
        // Whenever the filter closes, the bag is cleaned up and we will be
        // freed.
        //
        Status = KsAddItemToObjectBag (
            Filter -> Bag,
            reinterpret_cast <PVOID> (CapFilter),
            reinterpret_cast <PFNKSFREE> (CCaptureFilter::Cleanup)
            );

        if (!NT_SUCCESS (Status)) {
            delete CapFilter;
        } else {
            Filter -> Context = reinterpret_cast <PVOID> (CapFilter);
        }

    }

    return Status;

}

/**************************************************************************

    DESCRIPTOR AND DISPATCH LAYOUT

**************************************************************************/

GUID g_PINNAME_VIDEO_CAPTURE = {STATIC_PINNAME_VIDEO_CAPTURE};

//
// CaptureFilterCategories:
//
// The list of category GUIDs for the capture filter.
//
const
GUID
CaptureFilterCategories [CAPTURE_FILTER_CATEGORIES_COUNT] = {
    STATICGUIDOF (KSCATEGORY_VIDEO),
    STATICGUIDOF (KSCATEGORY_CAPTURE)
};

//
// CaptureFilterPinDescriptors:
//
// The list of pin descriptors on the capture filter.  
//
const 
KSPIN_DESCRIPTOR_EX
CaptureFilterPinDescriptors [CAPTURE_FILTER_PIN_COUNT] = {
    //
    // Capture Pin
    //
    {
        &CapturePinDispatch,
        NULL,             
        {
            NULL,                           // Interfaces (NULL, 0 == default)
            0,
            NULL,                           // Mediums (NULL, 0 == default)
            0,
            SIZEOF_ARRAY (CapturePinDataRanges), // Range Count
            CapturePinDataRanges,           // Ranges
            KSPIN_DATAFLOW_OUT,             // Dataflow
            KSPIN_COMMUNICATION_BOTH,       // Communication
            &KSCATEGORY_VIDEO,              // Category
            &g_PINNAME_VIDEO_CAPTURE,       // Name
            0                               // Reserved
        },
        
        KSPIN_FLAG_GENERATE_MAPPINGS |      // Pin Flags
            KSPIN_FLAG_PROCESS_IN_RUN_STATE_ONLY,
        1,                                  // Instances Possible
        1,                                  // Instances Necessary
        &CapturePinAllocatorFraming,        // Allocator Framing
        reinterpret_cast <PFNKSINTERSECTHANDLEREX> 
            (CCapturePin::IntersectHandler)
    }
    
};

//
// CaptureFilterDispatch:
//
// This is the dispatch table for the capture filter.  It provides notification
// of creation, closure, processing (for filter-centrics, not for the capture
// filter), and resets (for filter-centrics, not for the capture filter).
//
const 
KSFILTER_DISPATCH
CaptureFilterDispatch = {
    CCaptureFilter::DispatchCreate,         // Filter Create
    NULL,                                   // Filter Close
    NULL,                                   // Filter Process
    NULL                                    // Filter Reset
};

//
// CaptureFilterDescription:
//
// The descriptor for the capture filter.  We don't specify any topology
// since there's only one pin on the filter.  Realistically, there would
// be some topological relationships here because there would be input 
// pins from crossbars and the like.
//
const 
KSFILTER_DESCRIPTOR 
CaptureFilterDescriptor = {
    &CaptureFilterDispatch,                 // Dispatch Table
    NULL,                                   // Automation Table
    KSFILTER_DESCRIPTOR_VERSION,            // Version
    0,                                      // Flags
    &KSNAME_Filter,                         // Reference GUID
    DEFINE_KSFILTER_PIN_DESCRIPTORS (CaptureFilterPinDescriptors),
    DEFINE_KSFILTER_CATEGORIES (CaptureFilterCategories),

    0,
    sizeof (KSNODE_DESCRIPTOR),
    NULL,
    0,
    NULL,

    NULL                                    // Component ID
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\ksfilter\tests\avshws\device.h ===
/**************************************************************************

    AVStream Simulated Hardware Sample

    Copyright (c) 2001, Microsoft Corporation.

    File:

        device.h

    Abstract:

        The header for the device level of the simulated hardware.  This is
        not actually the hardware simulation itself.  The hardware simulation
        is contained in hwsim.*, image.*.
        
    History:

        created 3/9/2001

**************************************************************************/

class CCaptureDevice :
    public IHardwareSink {

private:

    //
    // The AVStream device we're associated with.
    //
    PKSDEVICE m_Device;

    //
    // Number of pins with resources acquired.  This is used as a locking
    // mechanism for resource acquisition on the device.
    //
    LONG m_PinsWithResources;

    //
    // Since we don't have physical hardware, this provides the hardware
    // simulation.  m_HardwareSimulation provides the fake ISR, fake DPC,
    // etc...  m_ImageSynth provides RGB24 and UYVY image synthesis and
    // overlay in software.
    //
    CHardwareSimulation *m_HardwareSimulation;
    CImageSynthesizer *m_ImageSynth;

    //
    // The number of ISR's that have occurred since capture started.
    //
    ULONG m_InterruptTime;

    //
    // The last reading of mappings completed.
    //
    ULONG m_LastMappingsCompleted;

    //
    // The Dma adapter object we acquired through IoGetDmaAdapter() during
    // Pnp start.  This must be initialized with AVStream in order to perform
    // Dma directly into the capture buffers.
    //
    PADAPTER_OBJECT m_DmaAdapterObject;

    //
    // The number of map registers returned from IoGetDmaAdapter().
    //
    ULONG m_NumberOfMapRegisters;

    //
    // The capture sink.  When we complete scatter / gather mappings, we
    // notify the capture sink.
    //
    ICaptureSink *m_CaptureSink;

    //
    // The video info header we're basing hardware settings on.  The pin
    // provides this to us when acquiring resources and must guarantee its
    // stability until resources are released.
    //
    PKS_VIDEOINFOHEADER m_VideoInfoHeader;

    //
    // Cleanup():
    //
    // This is the free callback for the bagged capture device.  Not providing
    // one will call ExFreePool, which is not what we want for a constructed
    // C++ object.  This simply deletes the capture device.
    //
    static
    void
    Cleanup (
        IN CCaptureDevice *CapDevice
        )
    {
        delete CapDevice;
    }

    //
    // PnpStart():
    //
    // This is the Pnp start routine for our simulated hardware.  Note that
    // DispatchStart bridges to here in the context of the CCaptureDevice.
    //
    NTSTATUS
    PnpStart (
        IN PCM_RESOURCE_LIST TranslatedResourceList,
        IN PCM_RESOURCE_LIST UntranslatedResourceList
        );

    //
    // PnpStop():
    //
    // This is the Pnp stop routine for our simulated hardware.  Note that
    // DispatchStop bridges to here in the context of the CCaptureDevice.
    //
    void
    PnpStop (
        );

public:

    //
    // CCaptureDevice():
    //
    // The capture device class constructor.  Since everything should have
    // been zero'ed by the new operator, don't bother setting anything to
    // zero or NULL.  Only initialize non-NULL, non-0 fields.
    //
    CCaptureDevice (
        IN PKSDEVICE Device
        ) :
        m_Device (Device)
    {
    }

    //
    // ~CCaptureDevice():
    //
    // The capture device destructor.
    //
    ~CCaptureDevice (
        )
    {
    }

    //
    // DispatchCreate():
    //
    // This is the Add Device dispatch for the capture device.  It creates
    // the CCaptureDevice and associates it with the device via the bag.
    //
    static
    NTSTATUS
    DispatchCreate (
        IN PKSDEVICE Device
        );
    //
    // DispatchPnpStart():
    //
    // This is the Pnp Start dispatch for the capture device.  It simply
    // bridges to PnpStart() in the context of the CCaptureDevice.
    //
    static
    NTSTATUS
    DispatchPnpStart (
        IN PKSDEVICE Device,
        IN PIRP Irp,
        IN PCM_RESOURCE_LIST TranslatedResourceList,
        IN PCM_RESOURCE_LIST UntranslatedResourceList
        )
    {
        return 
            (reinterpret_cast <CCaptureDevice *> (Device -> Context)) ->
            PnpStart (
                TranslatedResourceList,
                UntranslatedResourceList
                );
    }

    //
    // DispatchPnpStop():
    //
    // This is the Pnp stop dispatch for the capture device.  It simply
    // bridges to PnpStop() in the context of the CCaptureDevice.
    //
    static
    void
    DispatchPnpStop (
        IN PKSDEVICE Device,
        IN PIRP Irp
        )
    {
        return
            (reinterpret_cast <CCaptureDevice *> (Device -> Context)) ->
            PnpStop (
                );
    }

    //
    // AcquireHardwareResources():
    //
    // Called to acquire hardware resources for the device based on a given
    // video info header.  This will fail if another object has already
    // acquired hardware resources since we emulate a single capture
    // device.
    //
    NTSTATUS
    AcquireHardwareResources (
        IN ICaptureSink *CaptureSink,
        IN PKS_VIDEOINFOHEADER VideoInfoHeader
        );

    //
    // ReleaseHardwareResources():
    //
    // Called to release hardware resources for the device.
    //
    void
    ReleaseHardwareResources (
        );

    //
    // Start():
    //
    // Called to start the hardware simulation.  This causes us to simulate
    // interrupts, simulate filling buffers with synthesized data, etc...
    //
    NTSTATUS
    Start (
        );

    //
    // Pause():
    //
    // Called to pause or unpause the hardware simulation.  This will be
    // indentical to a start or stop but it will not reset formats and 
    // counters.
    //
    NTSTATUS
    Pause (
        IN BOOLEAN Pausing
        );

    //
    // Stop():
    //
    // Called to stop the hardware simulation.  This causes interrupts to
    // stop issuing.  When this call returns, the "fake" hardware has
    // stopped accessing all s/g buffers, etc...
    //
    NTSTATUS
    Stop (
        );

    //
    // ProgramScatterGatherMappings():
    //
    // Called to program the hardware simulation's scatter / gather table.
    // This synchronizes with the "fake" ISR and hardware simulation via
    // a spinlock.
    //
    ULONG
    ProgramScatterGatherMappings (
        IN PUCHAR *Buffer,
        IN PKSMAPPING Mappings,
        IN ULONG MappingsCount
        );

    //
    // QueryInterruptTime():
    //
    // Determine the frame number that this frame corresponds to.  
    //
    ULONG
    QueryInterruptTime (
        );

    //
    // IHardwareSink::Interrupt():
    //
    // The interrupt service routine as called through the hardware sink
    // interface.  The "fake" hardware uses this method to inform the device
    // of a "fake" ISR.  The routine is called at dispatch level and must
    // be in locked code.
    //
    virtual
    void
    Interrupt (
        );

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\ksfilter\tests\avshws\hwsim.cpp ===
/**************************************************************************

    AVStream Simulated Hardware Sample

    Copyright (c) 2001, Microsoft Corporation.

    File:

        hwsim.cpp

    Abstract:
        
        This file contains the hardware simulation.  It fakes "DMA" transfers,
        scatter gather mapping handling, ISR's, etc...  The ISR routine in
        here will be called when an ISR would be generated by the fake hardware
        and it will directly call into the device level ISR for more accurate
        simulation.

    History:

        created 3/9/2001

**************************************************************************/

#include "avshws.h"

/**************************************************************************

    PAGEABLE CODE

**************************************************************************/

#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGE")
#endif // ALLOC_PRAGMA


CHardwareSimulation::
CHardwareSimulation (
    IN IHardwareSink *HardwareSink
    ) :
    m_HardwareSink (HardwareSink),
    m_ScatterGatherMappingsMax (SCATTER_GATHER_MAPPINGS_MAX)

/*++

Routine Description:

    Construct a hardware simulation

Arguments:

    HardwareSink -
        The hardware sink interface.  This is used to trigger
        fake interrupt service routines from.

Return Value:

    Success / Failure

--*/

{

    PAGED_CODE();

    //
    // Initialize the DPC's, timer's, and locks necessary to simulate
    // this capture hardware.
    //
    KeInitializeDpc (
        &m_IsrFakeDpc, 
        reinterpret_cast <PKDEFERRED_ROUTINE> 
            (CHardwareSimulation::SimulatedInterrupt),
        this
        );

    KeInitializeEvent (
        &m_HardwareEvent,
        SynchronizationEvent,
        FALSE
        );

    KeInitializeTimer (&m_IsrTimer);

    KeInitializeSpinLock (&m_ListLock);

}

/*************************************************/


CHardwareSimulation *
CHardwareSimulation::
Initialize (
    IN KSOBJECT_BAG Bag,
    IN IHardwareSink *HardwareSink
    )

/*++

Routine Description:

    Initialize the hardware simulation

Arguments:

    HardwareSink -
        The hardware sink interface.  This is what ISR's will be
        triggered through.

Return Value:

    A fully initialized hardware simulation or NULL if the simulation
    could not be initialized.

--*/

{

    PAGED_CODE();

    CHardwareSimulation *HwSim = 
        new (NonPagedPool) CHardwareSimulation (HardwareSink);

    return HwSim;

}

/*************************************************/


NTSTATUS
CHardwareSimulation::
Start (
    IN CImageSynthesizer *ImageSynth,
    IN LONGLONG TimePerFrame,
    IN ULONG Width,
    IN ULONG Height,
    IN ULONG ImageSize
    )

/*++

Routine Description:

    Start the hardware simulation.  This will kick the interrupts on,
    begin issuing DPC's, filling in capture information, etc...
    We keep track of starvation starting at this point.

Arguments:

    ImageSynth -
        The image synthesizer to use to generate pictures to display
        on the capture buffer.

    TimePerFrame -
        The time per frame...  we issue interrupts this often.

    Width -
        The image width

    Height -
        The image height

    ImageSize - 
        The size of the image.  We allocate a temporary scratch buffer
        based on this size to fake hardware.

Return Value:

    Success / Failure (typical failure will be out of memory on the 
    scratch buffer, etc...)

--*/

{

    PAGED_CODE();

    NTSTATUS Status = STATUS_SUCCESS;

    m_ImageSynth = ImageSynth;
    m_TimePerFrame = TimePerFrame;
    m_ImageSize = ImageSize;
    m_Height = Height;
    m_Width = Width;

    InitializeListHead (&m_ScatterGatherMappings);
    m_NumMappingsCompleted = 0;
    m_ScatterGatherMappingsQueued = 0;
    m_NumFramesSkipped = 0;
    m_InterruptTime = 0;

    KeQuerySystemTime (&m_StartTime);

    //
    // Allocate a scratch buffer for the synthesizer.
    //
    m_SynthesisBuffer = reinterpret_cast <PUCHAR> (
        ExAllocatePool (
            NonPagedPool,
            m_ImageSize
            )
        );

    if (!m_SynthesisBuffer) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // If everything is ok, start issuing interrupts.
    //
    if (NT_SUCCESS (Status)) {

        //
        // Initialize the entry lookaside.
        //
        ExInitializeNPagedLookasideList (
            &m_ScatterGatherLookaside,
            NULL,
            NULL,
            0,
            sizeof (SCATTER_GATHER_ENTRY),
            'nEGS',
            0
            );

        //
        // Set up the synthesizer with the width, height, and scratch buffer.
        //
        m_ImageSynth -> SetImageSize (m_Width, m_Height);
        m_ImageSynth -> SetBuffer (m_SynthesisBuffer);

        LARGE_INTEGER NextTime;
        NextTime.QuadPart = m_StartTime.QuadPart + m_TimePerFrame;

        m_HardwareState = HardwareRunning;
        KeSetTimer (&m_IsrTimer, NextTime, &m_IsrFakeDpc);

    }

    return Status;
        
}

/*************************************************/


NTSTATUS
CHardwareSimulation::
Pause (
    BOOLEAN Pausing
    )

/*++

Routine Description:

    Pause the hardware simulation...  When the hardware simulation is told
    to pause, it stops issuing interrupts, etc...  but it does not reset
    the counters 

Arguments:

    Pausing -
        Indicates whether the hardware is pausing or not. 

        TRUE -
            Pause the hardware

        FALSE -
            Unpause the hardware from a previous pause


Return Value:

    Success / Failure

--*/

{

    PAGED_CODE();

    if (Pausing && m_HardwareState == HardwareRunning) {
        //
        // If we were running, stop completing mappings, etc...
        //
        m_StopHardware = TRUE;
    
        KeWaitForSingleObject (
            &m_HardwareEvent,
            Suspended,
            KernelMode,
            FALSE,
            NULL
            );

        ASSERT (m_StopHardware == FALSE);

        m_HardwareState = HardwarePaused; 

    } else if (!Pausing && m_HardwareState == HardwarePaused) {

        //
        // For unpausing the hardware, we need to compute the relative time
        // and restart interrupts.
        //
        LARGE_INTEGER UnpauseTime;

        KeQuerySystemTime (&UnpauseTime);
        m_InterruptTime = (ULONG) (
            (UnpauseTime.QuadPart - m_StartTime.QuadPart) /
            m_TimePerFrame
            );

        UnpauseTime.QuadPart = m_StartTime.QuadPart +
            (m_InterruptTime + 1) * m_TimePerFrame;

        m_HardwareState = HardwareRunning;
        KeSetTimer (&m_IsrTimer, UnpauseTime, &m_IsrFakeDpc);

    }

    return STATUS_SUCCESS;

}

/*************************************************/


NTSTATUS
CHardwareSimulation::
Stop (
    )

/*++

Routine Description:

    Stop the hardware simulation....  Wait until the hardware simulation
    has successfully stopped and then return.

Arguments:

    None

Return Value:

    Success / Failure

--*/

{

    PAGED_CODE();

    //
    // If the hardware is told to stop while it's running, we need to
    // halt the interrupts first.  If we're already paused, this has
    // already been done.
    //
    if (m_HardwareState == HardwareRunning) {
    
        m_StopHardware = TRUE;
    
        KeWaitForSingleObject (
            &m_HardwareEvent,
            Suspended,
            KernelMode,
            FALSE,
            NULL
            );
    
        ASSERT (m_StopHardware == FALSE);

    }

    m_HardwareState = HardwareStopped;

    //
    // The image synthesizer may still be around.  Just for safety's
    // sake, NULL out the image synthesis buffer and toast it.
    //
    m_ImageSynth -> SetBuffer (NULL);

    if (m_SynthesisBuffer) {
        ExFreePool (m_SynthesisBuffer);
        m_SynthesisBuffer = NULL;
    }

    //
    // Delete the scatter / gather lookaside for this run.
    //
    ExDeleteNPagedLookasideList (&m_ScatterGatherLookaside);

    return STATUS_SUCCESS;

}

/**************************************************************************

    LOCKED CODE

**************************************************************************/

#ifdef ALLOC_PRAGMA
#pragma code_seg()
#endif // ALLOC_PRAGMA


ULONG
CHardwareSimulation::
ReadNumberOfMappingsCompleted (
    )

/*++

Routine Description:

    Read the number of scatter / gather mappings which have been
    completed (TOTAL NUMBER) since the last reset of the simulated
    hardware

Arguments:

    None

Return Value:

    Total number of completed mappings.

--*/

{

    //
    // Don't care if this is being updated this moment in the DPC...  I only
    // need a number to return which isn't too great (too small is ok).
    // In real hardware, this wouldn't be done this way anyway.
    //
    return m_NumMappingsCompleted;

}

/*************************************************/


ULONG
CHardwareSimulation::
ProgramScatterGatherMappings (
    IN PUCHAR *Buffer,
    IN PKSMAPPING Mappings,
    IN ULONG MappingsCount,
    IN ULONG MappingStride
    )

/*++

Routine Description:

    Program the scatter gather mapping list.  This shoves a bunch of 
    entries on a list for access during the fake interrupt.  Note that
    we have physical addresses here only for simulation.  We really
    access via the virtual address....  although we chunk it into multiple
    buffers to more realistically simulate S/G

Arguments:

    Buffer -
        The virtual address of the buffer mapped by the mapping list 

    Mappings -
        The KSMAPPINGS array corresponding to the buffer

    MappingsCount -
        The number of mappings in the mappings array

    MappingStride -
        The mapping stride used in initialization of AVStream DMA

Return Value:

    Number of mappings actually inserted.

--*/

{

    KIRQL Irql;

    ULONG MappingsInserted = 0;

    //
    // Protect our S/G list with a spinlock.
    //
    KeAcquireSpinLock (&m_ListLock, &Irql);

    //
    // Loop through the scatter / gather list and break the buffer up into
    // chunks equal to the scatter / gather mappings.  Stuff the virtual
    // addresses of these chunks on a list somewhere.  We update the buffer
    // pointer the caller passes as a more convenient way of doing this.
    //
    // If I could just remap physical in the list to virtual easily here,
    // I wouldn't need to do it.
    //
    for (ULONG MappingNum = 0; 
        MappingNum < MappingsCount &&
            m_ScatterGatherMappingsQueued < m_ScatterGatherMappingsMax; 
        MappingNum++) {

        PSCATTER_GATHER_ENTRY Entry =
            reinterpret_cast <PSCATTER_GATHER_ENTRY> (
                ExAllocateFromNPagedLookasideList (
                    &m_ScatterGatherLookaside
                    )
                );

        if (!Entry) {
            break;
        }

        Entry -> Virtual = *Buffer;
        Entry -> ByteCount = Mappings -> ByteCount;

        //
        // Move forward a specific number of bytes in chunking this into
        // mapping sized va buffers.
        //
        *Buffer += Entry -> ByteCount;
        Mappings = reinterpret_cast <PKSMAPPING> (
            (reinterpret_cast <PUCHAR> (Mappings) + MappingStride)
            );

        InsertTailList (&m_ScatterGatherMappings, &(Entry -> ListEntry));
        MappingsInserted++;
        m_ScatterGatherMappingsQueued++;
        m_ScatterGatherBytesQueued += Entry -> ByteCount;

    }

    KeReleaseSpinLock (&m_ListLock, Irql);

    return MappingsInserted;

}

/*************************************************/


NTSTATUS
CHardwareSimulation::
FillScatterGatherBuffers (
    )

/*++

Routine Description:

    The hardware has synthesized a buffer in scratch space and we're to
    fill scatter / gather buffers.

Arguments:

    None

Return Value:

    Success / Failure

--*/

{

    //
    // We're using this list lock to protect our scatter / gather lists instead
    // of some hardware mechanism / KeSynchronizeExecution / whatever.
    //
    KeAcquireSpinLockAtDpcLevel (&m_ListLock);

    PUCHAR Buffer = reinterpret_cast <PUCHAR> (m_SynthesisBuffer);
    ULONG BufferRemaining = m_ImageSize;

    //
    // For simplification, if there aren't enough scatter / gather buffers
    // queued, we don't partially fill the ones that are available.  We just
    // skip the frame and consider it starvation.
    //
    // This could be enforced by only programming scatter / gather mappings
    // for a buffer if all of them fit in the table also...
    //
    while (BufferRemaining &&
        m_ScatterGatherMappingsQueued > 0 &&
        m_ScatterGatherBytesQueued >= BufferRemaining) {

        LIST_ENTRY *listEntry = RemoveHeadList (&m_ScatterGatherMappings);
        m_ScatterGatherMappingsQueued--;

        PSCATTER_GATHER_ENTRY SGEntry =  
            reinterpret_cast <PSCATTER_GATHER_ENTRY> (
                CONTAINING_RECORD (
                    listEntry,
                    SCATTER_GATHER_ENTRY,
                    ListEntry
                    )
                );

        //
        // Since we're software, we'll be accessing this by virtual address...
        //
        ULONG BytesToCopy = 
            (BufferRemaining < SGEntry -> ByteCount) ?
            BufferRemaining :
            SGEntry -> ByteCount;

        RtlCopyMemory (
            SGEntry -> Virtual,
            Buffer,
            BytesToCopy
            );

        BufferRemaining -= BytesToCopy;
        Buffer += BytesToCopy;
        m_NumMappingsCompleted++;
        m_ScatterGatherBytesQueued -= SGEntry -> ByteCount;

        //
        // Release the scatter / gather entry back to our lookaside.
        //
        ExFreeToNPagedLookasideList (
            &m_ScatterGatherLookaside,
            reinterpret_cast <PVOID> (SGEntry)
            );

    }
    
    KeReleaseSpinLockFromDpcLevel (&m_ListLock);

    if (BufferRemaining) return STATUS_INSUFFICIENT_RESOURCES;
    else return STATUS_SUCCESS;
    
}

/*************************************************/


void
CHardwareSimulation::
FakeHardware (
    )

/*++

Routine Description:

    Simulate an interrupt and what the hardware would have done in the
    time since the previous interrupt.

Arguments:

    None

Return Value:

    None

--*/

{

    m_InterruptTime++;

    //
    // The hardware can be in a pause state in which case, it issues interrupts
    // but does not complete mappings.  In this case, don't bother synthesizing
    // a frame and doing the work of looking through the mappings table.
    //
    if (m_HardwareState == HardwareRunning) {
    
        //
        // Generate a "time stamp" just to overlay it onto the capture image.
        // It makes it more exciting than bars that do nothing.
        //
        LONGLONG PtsRel = ((m_InterruptTime + 1) * m_TimePerFrame);
    
        ULONG Min = (ULONG)(PtsRel / 600000000);
        ULONG RemMin = (ULONG)(PtsRel % 600000000);
        ULONG Sec = (ULONG)(RemMin / 10000000);
        ULONG RemSec = (ULONG)(RemMin % 10000000);
        ULONG Hund = (ULONG)(RemSec / 100000);
    
        //
        // Synthesize a buffer in scratch space.
        //
        m_ImageSynth -> SynthesizeBars ();
    
        CHAR Text [256];
        sprintf (Text, "%ld:%02ld.%02ld", Min, Sec, Hund);
    
        //
        // Overlay a clock onto the scratch space image.
        //
        m_ImageSynth -> OverlayText (
            POSITION_CENTER,
            (m_Height - 28),
            1,
            Text,
            BLACK,	
            WHITE
            );
    
        //
        // Overlay a counter of skipped frames onto the scratch image.
        //
        sprintf (Text, "Skipped: %ld", m_NumFramesSkipped);
        m_ImageSynth -> OverlayText (
            10,
            10,
            1,
            Text,
            TRANSPARENT,
            BLUE
            );

        //
        // Fill scatter gather buffers
        //
        if (!NT_SUCCESS (FillScatterGatherBuffers ())) {
            InterlockedIncrement (PLONG (&m_NumFramesSkipped));
        }

    }
        
    //
    // Issue an interrupt to our hardware sink.  This is a "fake" interrupt.
    // It will occur at DISPATCH_LEVEL.
    //
    m_HardwareSink -> Interrupt ();

    //
    // Reschedule the timer if the hardware isn't being stopped.
    //
    if (!m_StopHardware) {

        //
        // Reschedule the timer for the next interrupt time.
        //
        LARGE_INTEGER NextTime;
        NextTime.QuadPart = m_StartTime.QuadPart + 
            (m_TimePerFrame * (m_InterruptTime + 1));

        KeSetTimer (&m_IsrTimer, NextTime, &m_IsrFakeDpc);
        
    } else {
        //
        // If someone is waiting on the hardware to stop, raise the stop
        // event and clear the flag.
        //
        m_StopHardware = FALSE;
        KeSetEvent (&m_HardwareEvent, IO_NO_INCREMENT, FALSE);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\ksfilter\tests\avshws\purecall.c ===
/**************************************************************************

    AVStream Simulated Hardware Sample

    Copyright (c) 2001, Microsoft Corporation.

    File:

        purecall.c

    Abstract:

        This file contains the _purecall stub necessary for virtual function
        usage in drivers on 98 gold.

    History:

        created 9/16/02

**************************************************************************/

/*************************************************

    Function:

        _purecall

    Description:

        _purecall stub for virtual function usage

    Arguments:

        None

    Return Value:

        0

*************************************************/

int __cdecl 
_purecall (
    VOID
    ) 

{
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\ksfilter\tests\avshws\image.h ===
/**************************************************************************

    AVStream Simulated Hardware Sample

    Copyright (c) 2001, Microsoft Corporation.

    File:

        image.h

    Abstract:

        The image synthesis and overlay header.  These objects provide image
        synthesis (pixel, color-bar, etc...) onto RGB24 and UYVY buffers as
        well as software string overlay into these buffers.

    History:

        created 1/16/2001

**************************************************************************/

/**************************************************************************

    Constants

**************************************************************************/

//
// COLOR:
//
// Pixel color for placement onto the synthesis buffer.
//
typedef enum {

    BLACK = 0,
    WHITE,
    YELLOW,
    CYAN,
    GREEN,
    MAGENTA,
    RED,
    BLUE,
    GREY,

    MAX_COLOR,
    TRANSPARENT,

} COLOR;

//
// POSITION_CENTER:
//
// Only useful for text overlay.  This can be substituted for LocX or LocY
// in order to center the text screen on the synthesis buffer.
//
#define POSITION_CENTER ((ULONG)-1)

/*************************************************

    CImageSynthesizer

    This class synthesizes images in various formats for output from the
    capture filter.  It is capable of performing various text overlays onto
    the image surface.

*************************************************/

class CImageSynthesizer {

protected:

    //
    // The width and height the synthesizer is set to. 
    //
    ULONG m_Width;
    ULONG m_Height;

    //
    // The synthesis buffer.  All scan conversion happens in the synthesis
    // buffer.  This must be set with SetBuffer() before any scan conversion
    // routines are called.
    //
    PUCHAR m_SynthesisBuffer;

    //
    // The default cursor.  This is a pointer into the synthesis buffer where
    // a non specific PutPixel will be placed. 
    //
    PUCHAR m_Cursor;

public:

    //
    // PutPixel():
    //
    // Place a pixel at the specified image cursor and move right
    // by one pixel.  No bounds checking...  wrap around occurs.
    //
    virtual void
    PutPixel (
        PUCHAR *ImageLocation,
        COLOR Color
        ) = 0;

    //
    // PutPixel():
    //
    // Place a pixel at the default image cursor and move right
    // by one pixel.  No bounds checking...  wrap around occurs.
    //
    // If the derived class doesn't provide an implementation, provide
    // one.
    //
    virtual void
    PutPixel (
        COLOR Color
        )
    {
        PutPixel (&m_Cursor, Color);
    }
        

    //
    // GetImageLocation():
    //
    // Get the location into the image buffer for a specific X/Y location.
    // This also sets the synthesizer's default cursor to the position
    // LocX, LocY.
    //
    virtual PUCHAR
    GetImageLocation (  
        ULONG LocX,
        ULONG LocY
        ) = 0;

    //
    // SetImageSize():
    //
    // Set the image size of the synthesis buffer.
    //
    void
    SetImageSize (
        ULONG Width,
        ULONG Height
        )
    {
        m_Width = Width;
        m_Height = Height;
    }

    //
    // SetBuffer():
    //
    // Set the buffer the synthesizer generates images to.
    //
    void
    SetBuffer (
        PUCHAR SynthesisBuffer
        )
    {
        m_SynthesisBuffer = SynthesisBuffer;
    }

    //
    // SynthesizeBars():
    //
    // Synthesize EIA-189-A standard color bars.
    //
    void
    SynthesizeBars (
        );

    //
    // OverlayText():
    //
    // Overlay a text string onto the image.
    //
    void
    OverlayText (
        ULONG LocX,
        ULONG LocY,
        ULONG Scaling,
        CHAR *Text,
        COLOR BgColor,
        COLOR FgColor
        );

    //
    // DEFAULT CONSTRUCTOR
    //
    CImageSynthesizer (
        ) :
        m_Width (0),
        m_Height (0),
        m_SynthesisBuffer (NULL)
    {
    }

    //
    // CONSTRUCTOR:
    //
    CImageSynthesizer (
        ULONG Width,
        ULONG Height
        ) :
        m_Width (Width),
        m_Height (Height),
        m_SynthesisBuffer (NULL)
    {
    }

    //
    // DESTRUCTOR:
    //
    virtual
    ~CImageSynthesizer (
        )
    {
    }

};

/*************************************************

    CRGB24Synthesizer

    Image synthesizer for RGB24 format.

*************************************************/

class CRGB24Synthesizer : public CImageSynthesizer {

private:

    const static UCHAR Colors [MAX_COLOR][3];

    BOOLEAN m_FlipVertical;

public:

    //
    // PutPixel():
    //
    // Place a pixel at a specific cursor location.  *ImageLocation must
    // reside within the synthesis buffer.
    //
    virtual void
    PutPixel (
        PUCHAR *ImageLocation,
        COLOR Color
        )
    {
        if (Color != TRANSPARENT) {
            *(*ImageLocation)++ = Colors [(ULONG)Color][0];
            *(*ImageLocation)++ = Colors [(ULONG)Color][1];
            *(*ImageLocation)++ = Colors [(ULONG)Color][2];
        } else {
            *ImageLocation += 3;
        }
    }

    //
    // PutPixel():
    //
    // Place a pixel at the default cursor location.  The cursor location
    // must be set via GetImageLocation(x, y).
    // 
    virtual void
    PutPixel (
        COLOR Color
        )
    {
        if (Color != TRANSPARENT) {
            *m_Cursor++ = Colors [(ULONG)Color][0];
            *m_Cursor++ = Colors [(ULONG)Color][1];
            *m_Cursor++ = Colors [(ULONG)Color][2];
        } else {
            m_Cursor += 3;
        }
    }

    virtual PUCHAR
    GetImageLocation (
        ULONG LocX,
        ULONG LocY
        )
    {
        if (m_FlipVertical) {
            return (m_Cursor = 
                (m_SynthesisBuffer + 3 * 
                    (LocX + (m_Height - 1 - LocY) * m_Width))
                );
        } else {
            return (m_Cursor =
                (m_SynthesisBuffer + 3 * (LocX + LocY * m_Width))
                );
        }
    }

    //
    // DEFAULT CONSTRUCTOR:
    //
    CRGB24Synthesizer (
        BOOLEAN FlipVertical
        ) :
        m_FlipVertical (FlipVertical)
    {
    }

    //
    // CONSTRUCTOR:
    //
    CRGB24Synthesizer (
        BOOLEAN FlipVertical,
        ULONG Width,
        ULONG Height
        ) :
        CImageSynthesizer (Width, Height),
        m_FlipVertical (FlipVertical)
    {
    }

    //
    // DESTRUCTOR:
    //
    virtual
    ~CRGB24Synthesizer (
        )
    {
    }

};

/*************************************************

    CYUVSynthesizer

    Image synthesizer for YUV format.

*************************************************/

class CYUVSynthesizer : public CImageSynthesizer {

private:

    const static UCHAR Colors [MAX_COLOR][3];

    BOOLEAN m_Parity;

public:

    //
    // PutPixel():
    //
    // Place a pixel at a specific cursor location.  *ImageLocation must
    // reside within the synthesis buffer.
    //
    virtual void
    PutPixel (
        PUCHAR *ImageLocation,
        COLOR Color
        )
    {

        BOOLEAN Parity = (((*ImageLocation - m_SynthesisBuffer) & 0x2) != 0);

#if DBG
        //
        // Check that the current pixel points to a valid start pixel
        // in the UYVY buffer.
        //
        BOOLEAN Odd = (((*ImageLocation - m_SynthesisBuffer) & 0x1) != 0);
        ASSERT ((m_Parity && Odd) || (!m_Parity && !Odd));
#endif // DBG

        if (Color != TRANSPARENT) {
            if (Parity) {
                *(*ImageLocation)++ = Colors [(ULONG)Color][1];
            } else {
                *(*ImageLocation)++ = Colors [(ULONG)Color][0];
                *(*ImageLocation)++ = Colors [(ULONG)Color][1];
                *(*ImageLocation)++ = Colors [(ULONG)Color][2];
            }
        } else {
            *ImageLocation += (Parity ? 1 : 3);
        }

    }

    //
    // PutPixel():
    //
    // Place a pixel at the default cursor location.  The cursor location
    // must be set via GetImageLocation(x, y).
    //
    virtual void
    PutPixel (
        COLOR Color
        )

    {

        if (Color != TRANSPARENT) {
            if (m_Parity) {
                *m_Cursor++ = Colors [(ULONG)Color][1];
            } else {
                *m_Cursor++ = Colors [(ULONG)Color][0];
                *m_Cursor++ = Colors [(ULONG)Color][1];
                *m_Cursor++ = Colors [(ULONG)Color][2];
            }
        } else {
            m_Cursor += (m_Parity ? 1 : 3);
        }

        m_Parity = !m_Parity;

    }

    virtual PUCHAR
    GetImageLocation (
        ULONG LocX,
        ULONG LocY
        )
    {
    
        m_Cursor = m_SynthesisBuffer + ((LocX + LocY * m_Width) << 1);
        if (m_Parity = ((LocX & 1) != 0)) 
            m_Cursor++;

        return m_Cursor;
    }

    //
    // DEFAULT CONSTRUCTOR:
    //
    CYUVSynthesizer (
        ) 
    {
    }

    //
    // CONSTRUCTOR:
    //
    CYUVSynthesizer (
        ULONG Width,
        ULONG Height
        ) :
        CImageSynthesizer (Width, Height)
    {
    }

    //
    // DESTRUCTOR:
    //
    virtual
    ~CYUVSynthesizer (
        )
    {
    }

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\ksfilter\tests\avshws\filter.h ===
/**************************************************************************

    AVStream Simulated Hardware Sample

    Copyright (c) 2001, Microsoft Corporation.

    File:

        filter.h

    Abstract:

        This file contains the filter level header for the capture filter.

    History:

        created 3/12/2001

**************************************************************************/

class CCaptureFilter {

private:

    //
    // The AVStream filter object associated with this CCaptureFilter.
    //
    PKSFILTER m_Filter;

    //
    // Cleanup():
    //
    // This is the bag cleanup callback for the CCaptureFilter.  Not providing
    // one would cause ExFreePool to be used.  This is not good for C++
    // constructed objects.  We simply delete the object here.
    //
    static
    void
    Cleanup (
        IN CCaptureFilter *CapFilter
        )
    {
        delete CapFilter;
    }

public:

    //
    // CCaptureFilter():
    //
    // The capture filter object constructor.  Since the new operator will
    // have zeroed the memory, do not bother initializing any NULL or 0
    // fields.  Only initialize non-NULL, non-0 fields.
    //
    CCaptureFilter (
        IN PKSFILTER Filter
        ) :
        m_Filter (Filter)
    {
    }

    //
    // ~CCaptureFilter():
    //
    // The capture filter destructor.
    //
    ~CCaptureFilter (
        )
    {
    }

    //
    // DispatchCreate():
    //
    // This is the filter creation dispatch for the capture filter.  It
    // creates the CCaptureFilter object, associates it with the AVStream
    // object, and bags it for easy cleanup later.
    //
    static
    NTSTATUS
    DispatchCreate (
        IN PKSFILTER Filter,
        IN PIRP Irp
        );

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\ksfilter\tests\avstest\audio.cpp ===
/**************************************************************************

    AVStream Filter-Centric Sample

    Copyright (c) 1999 - 2001, Microsoft Corporation

    File:

        audio.cpp

    Abstract:

        This file contains the audio capture pin implementation.

    History:

        created 6/28/01

**************************************************************************/

#include "avssamp.h"

/**************************************************************************

    PAGED CODE

**************************************************************************/

#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGE")
#endif // ALLOC_PRAGMA


NTSTATUS
CAudioCapturePin::
DispatchCreate (
    IN PKSPIN Pin,
    IN PIRP Irp
    )

/*++

Routine Description:

    Create a new audio capture pin.  This is the creation dispatch for
    the audio capture pin.

Arguments:

    Pin -
        The pin being created

    Irp -
        The creation Irp

Return Value:

    Success / Failure

--*/

{

    PAGED_CODE();

    NTSTATUS Status = STATUS_SUCCESS;

    CAudioCapturePin *CapPin = new (NonPagedPool) CAudioCapturePin (Pin);
    CCapturePin *BasePin = static_cast <CCapturePin *> (CapPin);

    if (!CapPin) {
        //
        // Return failure if we couldn't create the pin.
        //
        Status = STATUS_INSUFFICIENT_RESOURCES;

    } else {
        //
        // Add the item to the object bag if we we were successful. 
        // Whenever the pin closes, the bag is cleaned up and we will be
        // freed.
        //
        Status = KsAddItemToObjectBag (
            Pin -> Bag,
            reinterpret_cast <PVOID> (BasePin),
            reinterpret_cast <PFNKSFREE> (CCapturePin::BagCleanup)
            );

        if (!NT_SUCCESS (Status)) {
            delete CapPin;
        } else {
            Pin -> Context = reinterpret_cast <PVOID> (BasePin);
        }

    }

    return Status;

}

/*************************************************/


NTSTATUS
CAudioCapturePin::
Acquire (
    IN KSSTATE FromState
    )

/*++

Routine Description:

    Called when the pin transitions into acquire, this gets and releases
    our hold on the wave object we use to synthesize audio streams.

Arguments:

    FromState -
        The state the pin is transitioning away from

Return Value:

    Success / Failure

--*/

{

    PAGED_CODE();

    NTSTATUS Status = STATUS_SUCCESS;

    if (FromState == KSSTATE_STOP) {
        //
        // On the transition into acquire from stop, get ahold of the
        // wave object we're synthesizing from.
        //
        m_WaveObject = m_ParentFilter -> GetWaveObject ();
        ASSERT (m_WaveObject);

        //
        // There must be a wave object or something is really wrong.
        //
        if (!m_WaveObject) {
            Status = STATUS_INTERNAL_ERROR;
        } else {
            m_WaveObject -> Reset ();
        }

    } else {
        //
        // Ensure we hold no reference on the wave object.
        //
        m_WaveObject = NULL;

    }

    return Status;
            
}

/*************************************************/


NTSTATUS
CAudioCapturePin::
IntersectHandler (
    IN PKSFILTER Filter,
    IN PIRP Irp,
    IN PKSP_PIN PinInstance,
    IN PKSDATARANGE CallerDataRange,
    IN PKSDATARANGE DescriptorDataRange,
    IN ULONG BufferSize,
    OUT PVOID Data OPTIONAL,
    OUT PULONG DataSize
    )

/*++

Routine Description:

    The intersect handler for the audio capture pin.  This is really quite
    simple because the audio pin only exposes the number of channels,
    sampling frequency, etc...  that the wave file it is synthesizing from
    contains.

Arguments:

    Filter -
        Contains a void pointer to the  filter structure.

    Irp -
        Contains a pointer to the data intersection property request.

    PinInstance -
        Contains a pointer to a structure indicating the pin in question.

    CallerDataRange -
        Contains a pointer to one of the data ranges supplied by the client
        in the data intersection request.  The format type, subtype and
        specifier are compatible with the DescriptorDataRange.

    DescriptorDataRange -
        Contains a pointer to one of the data ranges from the pin descriptor
        for the pin in question.  The format type, subtype and specifier are
        compatible with the CallerDataRange.

    BufferSize -
        Contains the size in bytes of the buffer pointed to by the Data
        argument.  For size queries, this value will be zero.

    Data -
        Optionally contains a pointer to the buffer to contain the data 
        format structure representing the best format in the intersection 
        of the two data ranges.  For size queries, this pointer will be 
        NULL.

    DataSize -
        Contains a pointer to the location at which to deposit the size 
        of the data format.  This information is supplied by the function 
        when the format is actually delivered and in response to size 
        queries.

Return Value:

    STATUS_SUCCESS if there is an intersection and it fits in the supplied
    buffer, STATUS_BUFFER_OVERFLOW for successful size queries, 
    STATUS_NO_MATCH if the intersection is empty, or 
    STATUS_BUFFER_TOO_SMALL if the supplied buffer is too small.

--*/


{
    
    PAGED_CODE();

    //
    // Verify that the inpassed range is valid size. 
    //
    if (CallerDataRange -> FormatSize < sizeof (KSDATARANGE_AUDIO)) {
        return STATUS_NO_MATCH;
    }

    //
    // Because the only range we expose is such that it will match
    // KSDATARANGE_AUDIO, it is safe to interpret the data structures as
    // KSDATARANGE_AUDIO.  This is due to the fact that AVStream will have
    // prematched the GUIDs for us.
    //
    PKSDATARANGE_AUDIO CallerAudioRange =
        reinterpret_cast <PKSDATARANGE_AUDIO> (CallerDataRange);

    PKSDATARANGE_AUDIO DescriptorAudioRange =
        reinterpret_cast <PKSDATARANGE_AUDIO> (DescriptorDataRange);

    //
    // We are returning a KSDATAFORMAT_WAVEFORMATEX.  Specify such if a size
    // query happens.
    //
    if (BufferSize == 0) {
        *DataSize = sizeof (KSDATAFORMAT_WAVEFORMATEX);
        return STATUS_BUFFER_OVERFLOW;
    }

    if (BufferSize < sizeof (KSDATAFORMAT_WAVEFORMATEX)) {
        return STATUS_BUFFER_TOO_SMALL;
    }

    //
    // Match the blocks.  We only support one format (not really a range), so
    // this intersection aught to be really simple.  It's more of a check
    // if the format we are going to use intersects somewhere in 
    // CallerAudioRange.
    //
    if (DescriptorAudioRange -> MaximumChannels > 
            CallerAudioRange -> MaximumChannels ||
        DescriptorAudioRange -> MinimumBitsPerSample <
            CallerAudioRange -> MinimumBitsPerSample ||
        DescriptorAudioRange -> MinimumBitsPerSample >
            CallerAudioRange -> MaximumBitsPerSample ||
        DescriptorAudioRange -> MinimumSampleFrequency <
            CallerAudioRange -> MinimumSampleFrequency ||
        DescriptorAudioRange -> MinimumSampleFrequency >
            CallerAudioRange -> MaximumSampleFrequency) {

        //
        // If the descriptor's "range" (more of a single format specified
        // in a range) doesn't intersect the caller's, no match the call.
        //
        *DataSize = sizeof (KSDATAFORMAT_WAVEFORMATEX);
        return STATUS_NO_MATCH;

    }

    //
    // Build the format.
    //
    PKSDATAFORMAT_WAVEFORMATEX WaveFormat =
        reinterpret_cast <PKSDATAFORMAT_WAVEFORMATEX> (Data);

    RtlCopyMemory (
        &WaveFormat -> DataFormat,
        &DescriptorAudioRange -> DataRange,
        sizeof (KSDATAFORMAT)
        );

    WaveFormat -> WaveFormatEx.wFormatTag = WAVE_FORMAT_PCM;
    WaveFormat -> WaveFormatEx.nChannels = 
        (WORD)DescriptorAudioRange -> MaximumChannels;
    WaveFormat -> WaveFormatEx.nSamplesPerSec =
        DescriptorAudioRange -> MaximumSampleFrequency;
    WaveFormat -> WaveFormatEx.wBitsPerSample =
        (WORD)DescriptorAudioRange -> MaximumBitsPerSample;
    WaveFormat -> WaveFormatEx.nBlockAlign =
        (WaveFormat -> WaveFormatEx.wBitsPerSample / 8) *
        WaveFormat -> WaveFormatEx.nChannels;
    WaveFormat -> WaveFormatEx.nAvgBytesPerSec =
        WaveFormat -> WaveFormatEx.nBlockAlign *
        WaveFormat -> WaveFormatEx.nSamplesPerSec;
    WaveFormat -> WaveFormatEx.cbSize = 0;
    WaveFormat -> DataFormat.SampleSize = 
        WaveFormat -> WaveFormatEx.nBlockAlign;

    *DataSize = sizeof (KSDATAFORMAT_WAVEFORMATEX);

    return STATUS_SUCCESS;

}

/*************************************************/


NTSTATUS
CAudioCapturePin::
DispatchSetFormat (
    IN PKSPIN Pin,
    IN PKSDATAFORMAT OldFormat OPTIONAL,
    IN PKSMULTIPLE_ITEM OldAttributeList OPTIONAL,
    IN const KSDATARANGE *DataRange,
    IN const KSATTRIBUTE_LIST *AttributeRange OPTIONAL
    )

/*++

Routine Description:

    This is the set data format dispatch for the capture pin.  It is called
    in two circumstances.

        1: before Pin's creation dispatch has been made to verify that
           Pin -> ConnectionFormat is an acceptable format for the range
           DataRange.  In this case OldFormat is NULL.

        2: after Pin's creation dispatch has been made and an initial format
           selected in order to change the format for the pin.  In this case,
           OldFormat will not be NULL.

    Validate that the format is acceptible and perform the actions necessary
    to change format if appropriate.

Arguments:

    Pin -
        The pin this format is being set on.  The format itself will be in
        Pin -> ConnectionFormat.

    OldFormat -
        The previous format used on this pin.  If this is NULL, it is an
        indication that Pin's creation dispatch has not yet been made and
        that this is a request to validate the initial format and not to
        change formats.

    OldAttributeList -
        The old attribute list for the prior format

    DataRange -
        A range out of our list of data ranges which was determined to be
        at least a partial match for Pin -> ConnectionFormat.  If the format
        there is unacceptable for the range, STATUS_NO_MATCH should be
        returned.

    AttributeRange -
        The attribute range

Return Value:

    Success / Failure

        STATUS_SUCCESS -
            The format is acceptable / the format has been changed

        STATUS_NO_MATCH -
            The format is not-acceptable / the format has not been changed

--*/

{

    PAGED_CODE();

    //
    // This pin does not accept any format changes.  It is fixed format based
    // on what the wave file we're synthesizing from is.  Thus, we don't
    // need to worry about this being called in any context except pin
    // creation (KSPIN_FLAG_FIXED_FORMAT ensures this).  Knowing that the
    // format already is a GUID match for the range and we only have one
    // range, the interpretation without any guid checks is safe.
    //
    ASSERT (!OldFormat);

    const KSDATARANGE_AUDIO *DataRangeAudio =
        reinterpret_cast <const KSDATARANGE_AUDIO *> (DataRange);

    //
    // Verify the format is the right size.
    //
    if (Pin -> ConnectionFormat -> FormatSize <
        sizeof (KSDATAFORMAT_WAVEFORMATEX)) {

        return STATUS_NO_MATCH;
    }

    PKSDATAFORMAT_WAVEFORMATEX WaveFormat =
        reinterpret_cast <PKSDATAFORMAT_WAVEFORMATEX> (
            Pin -> ConnectionFormat
            );

    //
    // This is not an intersection, but rather a direct comparison due to
    // the fact that we're fixed to a single format and do not really have
    // a range.
    //
    if (WaveFormat -> WaveFormatEx.wFormatTag != WAVE_FORMAT_PCM ||
        WaveFormat -> WaveFormatEx.nChannels !=
            DataRangeAudio -> MaximumChannels ||
        WaveFormat -> WaveFormatEx.nSamplesPerSec !=
            DataRangeAudio -> MaximumSampleFrequency ||
        WaveFormat -> WaveFormatEx.wBitsPerSample !=
            DataRangeAudio -> MaximumBitsPerSample) {

        return STATUS_NO_MATCH;

    }

    //
    // The format passes consideration.  Allow the pin creation with this
    // particular format.
    //
    return STATUS_SUCCESS;
    
}

/**************************************************************************

    LOCKED CODE

**************************************************************************/

#ifdef ALLOC_PRAGMA
#pragma code_seg()
#endif // ALLOC_PRAGMA


NTSTATUS
CAudioCapturePin::
CaptureFrame (
    IN PKSPROCESSPIN ProcessPin,
    IN ULONG Tick
    )

/*++

Routine Description:

    Called to synthesize a frame of audio data from the wave object.

Arguments:

    ProcessPin -
        The process pin from the filter's process pins index

    Tick -
        The tick counter from the filter (the number of DPC's that have 
        happened since the DPC timer started).  Note that the DPC timer
        starts at pause and capture starts at run.

Return Value:

    Success / Failure

--*/

{

    ASSERT (ProcessPin -> Pin == m_Pin);

    //
    // Increment the frame number.  This is the total count of frames which
    // have attempted capture.
    //
    m_FrameNumber++;

    //
    // Find out how much time worth of audio data to synthesize into
    // the buffer a buffer (or how much time to skip if there are no available
    // capture buffers).
    //
    LONGLONG TimerInterval = m_ParentFilter -> GetTimerInterval ();

    //
    // Since this pin is KSPIN_FLAG_FRAMES_NOT_REQUIRED_FOR_PROCESSING, it
    // means that we do not require frames available in order to process.
    // This means that this routine can get called from our DPC with no
    // buffers available to capture into.  In this case, we increment our
    // dropped frame counter and skip forward into the audio stream.
    //
    if (ProcessPin -> BytesAvailable) {
        //
        // Synthesize a fixed amount of audio data based on the timer interval.
        //
        ULONG BytesUsed = m_WaveObject -> SynthesizeFixed (
            TimerInterval,
            ProcessPin -> Data,
            ProcessPin -> BytesAvailable
            );
    
        ProcessPin -> BytesUsed = BytesUsed;
        ProcessPin -> Terminate = TRUE;
    
        //
        // Time stamp the packet if there is a clock assigned.
        //
        if (m_Clock) {
            PKSSTREAM_HEADER StreamHeader = 
                ProcessPin -> StreamPointer -> StreamHeader;

            StreamHeader -> PresentationTime.Time = m_Clock -> GetTime ();
            StreamHeader -> PresentationTime.Numerator =
                StreamHeader -> PresentationTime.Denominator = 1;
            StreamHeader -> OptionsFlags |=
                KSSTREAM_HEADER_OPTIONSF_TIMEVALID;
        }

    } else {
        m_DroppedFrames++;

        //
        // Since we've skipped an audio frame, inform the wave object to
        // skip forward this much.
        //
        m_WaveObject -> SkipFixed (TimerInterval);
    }
    
    return STATUS_SUCCESS;

}

/**************************************************************************

    DESCRIPTOR / DISPATCH LAYOUT

**************************************************************************/

//
// AudioCapturePinDispatch:
//
// This is the dispatch table for the capture pin.  It provides notifications
// about creation, closure, processing, data formats, etc...
//
const
KSPIN_DISPATCH
AudioCapturePinDispatch = {
    CAudioCapturePin::DispatchCreate,       // Pin Create
    NULL,                                   // Pin Close
    NULL,                                   // Pin Process
    NULL,                                   // Pin Reset
    CAudioCapturePin::DispatchSetFormat,    // Pin Set Data Format
    CCapturePin::DispatchSetState,          // Pin Set Device State
    NULL,                                   // Pin Connect
    NULL,                                   // Pin Disconnect
    NULL,                                   // Clock Dispatch
    NULL                                    // Allocator Dispatch
};

//
// AudioDefaultAllocatorFraming:
//
// A default framing for the audio pin.  In order for this to work properly,
// the frame size must be at least 1/fps * bytes_per_sec large.  Otherwise,
// the audio stream will fall behind.  This is dynamically adjusted when
// the actual pin is created.
//
DECLARE_SIMPLE_FRAMING_EX (
    AudioDefaultAllocatorFraming,
    STATICGUIDOF (KSMEMORY_TYPE_KERNEL_NONPAGED),
    KSALLOCATOR_REQUIREMENTF_SYSTEM_MEMORY |
        KSALLOCATOR_REQUIREMENTF_PREFERENCES_ONLY,
    25,
    0,
    2 * PAGE_SIZE,
    2 * PAGE_SIZE
    );

//
// g_PINNAME_AUDIO_CAPTURE:
//
// A GUID identifying the name of the audio capture pin.  I use the standard
// STATIC_PINNAME_VIDEO_CAPTURE for the video capture pin, but a custom name
// as defined in avssamp.inf for the audio capture pin.
//
GUID g_PINNAME_AUDIO_CAPTURE = 
    {0xba1184b9, 0x1fe6, 0x488a, 0xae, 0x78, 0x6e, 0x99, 0x7b, 0x2, 0xca, 0xea};

//
// AudioPinDescriptorTemplate:
//
// The template for the audio pin descriptor.  The audio pin on this filter
// is created dynamically -- if and only if c:\avssamp.wav exists and is
// a valid and readable wave file.
//
const
KSPIN_DESCRIPTOR_EX
AudioPinDescriptorTemplate = {
    //
    // Audio Capture Pin
    //
    &AudioCapturePinDispatch,
    NULL,
    { 
        NULL,                               // Interfaces (NULL, 0 == default)
        0,                      
        NULL,                               // Mediums (NULL, 0 == default)
        0,
        0,                                  // Range count (filled in later)
        NULL,                               // Ranges (filled in later)
        KSPIN_DATAFLOW_OUT,                 // Dataflow
        KSPIN_COMMUNICATION_BOTH,           // Communication
        &KSCATEGORY_AUDIO,                  // Category
        &g_PINNAME_AUDIO_CAPTURE,           // Name
        0                                   // Reserved
    },
    KSPIN_FLAG_FRAMES_NOT_REQUIRED_FOR_PROCESSING | // Flags
        KSPIN_FLAG_DO_NOT_INITIATE_PROCESSING | 
        KSPIN_FLAG_PROCESS_IN_RUN_STATE_ONLY |
        KSPIN_FLAG_FIXED_FORMAT,
    1,                                      // Instances Possible
    0,                                      // Instances Necessary
    &AudioDefaultAllocatorFraming,          // Allocator Framing (filled later)
    reinterpret_cast <PFNKSINTERSECTHANDLEREX> // Intersect Handler
        (CAudioCapturePin::IntersectHandler)
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\ksfilter\tests\avstest\avssamp.cpp ===
/**************************************************************************

    AVStream Filter-Centric Sample

    Copyright (c) 1999 - 2001, Microsoft Corporation

    File:

        avssamp.cpp

    Abstract:

        This is the main file for the filter-centric sample.

    History:

        created 6/18/01

**************************************************************************/

#include "avssamp.h"

/**************************************************************************

    INITIALIZATION CODE

**************************************************************************/


extern "C"
NTSTATUS
DriverEntry (
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    Driver entry point.  Pass off control to the AVStream initialization
    function (KsInitializeDriver) and return the status code from it.

Arguments:

    DriverObject -
        The WDM driver object for our driver

    RegistryPath -
        The registry path for our registry info

Return Value:

    As from KsInitializeDriver

--*/

{

    //
    // Simply pass the device descriptor and parameters off to AVStream
    // to initialize us.  This will cause filter factories to be set up
    // at add & start.  Everything is done based on the descriptors passed
    // here.
    //
    return
        KsInitializeDriver (
            DriverObject,
            RegistryPath,
            &CaptureDeviceDescriptor
            );

}

/**************************************************************************

    DESCRIPTOR AND DISPATCH LAYOUT

**************************************************************************/

//
// FilterDescriptors:
//
// The table of filter descriptors that this device supports.  Each one of
// these will be used as a template to create a filter-factory on the device.
//
DEFINE_KSFILTER_DESCRIPTOR_TABLE (FilterDescriptors) {
    &CaptureFilterDescriptor
};

//
// CaptureDeviceDescriptor:
//
// This is the device descriptor for the capture device.  It points to the
// dispatch table and contains a list of filter descriptors that describe
// filter-types that this device supports.  Note that the filter-descriptors
// can be created dynamically and the factories created via
// KsCreateFilterFactory as well.
//
const
KSDEVICE_DESCRIPTOR
CaptureDeviceDescriptor = {
    //
    // Since this is a software sample (filter-centric filters usually are
    // software kinds of transforms), we really don't care about device level
    // notifications and work.  The default behavior done on behalf of us
    // by AVStream will be quite sufficient.
    //
    NULL,
    SIZEOF_ARRAY (FilterDescriptors),
    FilterDescriptors,
    KSDEVICE_DESCRIPTOR_VERSION
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\ksfilter\tests\avstest\avssamp.h ===
/**************************************************************************

    AVStream Filter-Centric Sample

    Copyright (c) 2001, Microsoft Corporation

    File:

        avssamp.h

    Abstract:

        AVStream Filter-Centric Sample header file.  This is the main
        header.

    History:

        created 6/18/01

**************************************************************************/

/*************************************************

    Standard Includes

*************************************************/

extern "C" {
#include <wdm.h>
}

#include <windef.h>
#include <stdio.h>
#include <stdlib.h>
#define NOBITMAP
#include <mmreg.h>
#undef NOBITMAP
#include <unknown.h>
#include <ks.h>
#include <ksmedia.h>
#include <kcom.h>

/*************************************************

    Misc Definitions

*************************************************/

#define ABS(x) ((x) < 0 ? (-(x)) : (x))

#ifndef mmioFOURCC    
#define mmioFOURCC( ch0, ch1, ch2, ch3 )                \
        ( (DWORD)(BYTE)(ch0) | ( (DWORD)(BYTE)(ch1) << 8 ) |    \
        ( (DWORD)(BYTE)(ch2) << 16 ) | ( (DWORD)(BYTE)(ch3) << 24 ) )
#endif

#define FOURCC_YUV422       mmioFOURCC('U', 'Y', 'V', 'Y')

//
// CAPTURE_PIN_DATA_RANGE_COUNT:
//
// The number of ranges supported on the capture pin.
//
#define CAPTURE_PIN_DATA_RANGE_COUNT 2

//
// CAPTURE_FILTER_PIN_COUNT:
//
// The number of pins on the capture filter.
//
#define CAPTURE_FILTER_PIN_COUNT 1

//
// CAPTURE_FILTER_CATEGORIES_COUNT:
//
// The number of categories for the capture filter.
//
#define CAPTURE_FILTER_CATEGORIES_COUNT 2

/*************************************************

    Externed information

*************************************************/

//
// filter.cpp externs:
//
extern
const
KSFILTER_DISPATCH
CaptureFilterDispatch;

extern
const
KSFILTER_DESCRIPTOR
CaptureFilterDescriptor;

extern
const
KSPIN_DESCRIPTOR_EX
CaptureFilterPinDescriptors [CAPTURE_FILTER_PIN_COUNT];

extern
const
GUID
CaptureFilterCategories [CAPTURE_FILTER_CATEGORIES_COUNT];

//
// video.cpp externs:
//
extern
const
KSALLOCATOR_FRAMING_EX
VideoCapturePinAllocatorFraming;

extern
const
KSPIN_DISPATCH
VideoCapturePinDispatch;

extern
const
PKSDATARANGE
VideoCapturePinDataRanges [CAPTURE_PIN_DATA_RANGE_COUNT];

//
// audio.cpp externs:
//
extern
const
KSPIN_DESCRIPTOR_EX
AudioPinDescriptorTemplate;

//
// avssamp.cpp externs:
//
extern
const
KSDEVICE_DESCRIPTOR
CaptureDeviceDescriptor;

/*************************************************

    Internal Includes

*************************************************/

#include "image.h"
#include "wave.h"
#include "filter.h"
#include "capture.h"
#include "video.h"
#include "audio.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\ksfilter\tests\avstest\capture.cpp ===
/**************************************************************************

    AVStream Filter-Centric Sample

    Copyright (c) 1999 - 2001, Microsoft Corporation

    File:

        capture.cpp

    Abstract:

        This file contains the capture pin implementation for all capture
        pins on the sample filter.

    History:

        created 5/31/01

**************************************************************************/

#include "avssamp.h"

/**************************************************************************

    PAGED CODE

**************************************************************************/

#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGE")
#endif // ALLOC_PRAGMA


CCapturePin::
CCapturePin (
    IN PKSPIN Pin
    ) :
    m_Pin (Pin),
    m_State (KSSTATE_STOP)

/*++

Routine Description:

    Construct a new capture pin.  Find out the filter associated with this
    pin and stash a pointer to our parent filter.

Arguments:

    Pin -
        The AVStream pin object being created.

Return Value:

    None

--*/

{

    PAGED_CODE();

    PKSFILTER ParentFilter = KsPinGetParentFilter (Pin);

    m_ParentFilter = reinterpret_cast <CCaptureFilter *> (
        ParentFilter -> Context
        );

}

/*************************************************/


NTSTATUS
CCapturePin::
SetState (
    IN KSSTATE ToState,
    IN KSSTATE FromState
    )

/*++

Routine Description:

    Called when the pin is transitioning state.  This is a bridge from
    DispatchSetState in the context of the capture pin.  The function itself
    performs basic clock handling (things that all the derived pins would use)
    and then calls the appropriate method in the derived class.

Arguments:

    FromState -
        The state the pin is transitioning away from

    ToState -
        The state the pin is transitioning towards

Return Value:

    Success / Failure of state transition.

--*/

{

    PAGED_CODE();

    NTSTATUS Status = STATUS_SUCCESS;

    switch (ToState) {
        
        case KSSTATE_STOP:

            //
            // Reset the dropped frame counter.
            //
            m_DroppedFrames = 0;
            m_FrameNumber = 0;

            //
            // On a transition to stop, the clock will be released.
            //
            if (m_Clock) {
                m_Clock -> Release ();
                m_Clock = NULL;
            }

            Status = Stop (FromState);
            break;

        case KSSTATE_ACQUIRE:

            //
            // On a transition to acqiure (from stop), the pin queries for
            // its assigned clock.  This can be done either here or at the
            // transition to pause.
            //
            if (FromState == KSSTATE_STOP) {

                Status = KsPinGetReferenceClockInterface (
                    m_Pin,
                    &m_Clock
                    );

                if (!NT_SUCCESS (Status)) {
                    m_Clock = NULL;
                }

            }

            Status = Acquire (FromState);
            break;

        case KSSTATE_PAUSE:

            Status = Pause (FromState);
            break;

        case KSSTATE_RUN:

            Status = Run (FromState);
            break;

    }

    if (NT_SUCCESS (Status)) {
        m_State = ToState;
    }

    return Status;

}

/**************************************************************************

    LOCKED CODE

**************************************************************************/

#ifdef ALLOC_PRAGMA
#pragma code_seg()
#endif // ALLOC_PRAGMA


ULONG
CCapturePin::
QueryFrameDrop (
    )

/*++

Routine Description:

    Return the number of frames which have been dropped on this pin.

Arguments:

    None

Return Value:

    The number of frames which have been dropped on this pin.

--*/

{

    return m_DroppedFrames;

}

/*************************************************/


void
CCapturePin::
NotifyDrops (
    IN ULONG VidDrop,
    IN ULONG AudDrop
    )

/*++

Routine Description:

    Stash the number of dropped frames on each pin in this pin to allow
    this data to be incorporated into any synthesis.

Arguments:

    VidDrop -
        Number of video frames that have been dropped

    AudDrop -
        Number of audio frames that have been dropped

Return Value:

    None

--*/

{

    m_NotifyVidDrop = VidDrop;
    m_NotifyAudDrop = AudDrop;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\ksfilter\tests\avstest\audio.h ===
/**************************************************************************

    AVStream Filter-Centric Sample

    Copyright (c) 1999 - 2001, Microsoft Corporation

    File:

        audio.h

    Abstract:

        This file contains the audio capture pin header.

    History:

        created 6/28/01

**************************************************************************/

class CAudioCapturePin :
    public CCapturePin

{

private:

    //
    // The wave object used to synthesize audio data.
    //
    CWaveObject *m_WaveObject;

public:

    //
    // CAudioCapturePin():
    //
    // Construct a new audio capture pin.
    //
    CAudioCapturePin (
        IN PKSPIN Pin
        ) : CCapturePin (Pin)
    {
    }

    //
    // ~CAudioCapturePin():
    //
    // Destruct an audio capture pin.
    //
    ~CAudioCapturePin (
        )
    {
    }

    //
    // Acquire():
    //
    // Called when the audio capture pin is transitioning into the acquire
    // state (from either stop or pause).  This routine will get ahold of
    // the wave object from the filter.
    //
    virtual
    NTSTATUS
    Acquire (
        IN KSSTATE FromState
        );

    //
    // CaptureFrame():
    //
    // This is called when the filter processes and wants to trigger processing
    // of an audio frame.  The routine will compute how far into the stream
    // we've progressed and ask the filter's wave object to copy enough
    // "synthesized" audio data from the wave object in order to reach
    // the position.
    //
    virtual
    NTSTATUS
    CaptureFrame (
        IN PKSPROCESSPIN ProcessPin,
        IN ULONG Tick
        );

    /*************************************************

        Dispatch Functions

    *************************************************/

    //
    // DispatchCreate():
    //
    // This is the creation dispatch for the audio capture pin on the filter.
    // It creates the CAudioCapturePin, associates it with the AVStream pin
    // object and bags the class object for automatic cleanup when the
    // pin is closed.
    //
    static
    NTSTATUS
    DispatchCreate (
        IN PKSPIN Pin,
        IN PIRP Irp
        );

    //
    // DispatchSetFormat():
    //
    // This is the set data format dispatch for the pin.  This will be called 
    // BEFORE pin creation to validate that a data format selected is a match
    // for the range pulled out of our range list.  It will also be called
    // for format changes.
    //
    // If OldFormat is NULL, this is an indication that it's the initial
    // call and not a format change.  Even fixed format pins get this call
    // once.
    //
    static
    NTSTATUS
    DispatchSetFormat (
        IN PKSPIN Pin,
        IN PKSDATAFORMAT OldFormat OPTIONAL,
        IN PKSMULTIPLE_ITEM OldAttributeList OPTIONAL,
        IN const KSDATARANGE *DataRange,
        IN const KSATTRIBUTE_LIST *AttributeRange OPTIONAL
        );

    //
    // IntersectHandler():
    //
    // This is the data intersection handler for the capture pin.  This 
    // determines an optimal format in the intersection of two ranges,
    // one local and one possibly foreign.  If there is no compatible format,
    // STATUS_NO_MATCH is returned.
    //
    static
    NTSTATUS
    IntersectHandler (
        IN PKSFILTER Filter,
        IN PIRP Irp,
        IN PKSP_PIN PinInstance,
        IN PKSDATARANGE CallerDataRange,
        IN PKSDATARANGE DescriptorDataRange,
        IN ULONG BufferSize,
        OUT PVOID Data OPTIONAL,
        OUT PULONG DataSize
        );
        

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\ksfilter\tests\avstest\filter.cpp ===
/**************************************************************************

    AVStream Filter-Centric Sample

    Copyright (c) 1999 - 2001, Microsoft Corporation

    File:

        filter.cpp

    Abstract:

        This file contails the capture filter implementation (including
        frame synthesis) for the fake capture filter.

    History:

        created 5/31/01

**************************************************************************/

#include "avssamp.h"

/**************************************************************************

    PAGEABLE CODE

**************************************************************************/

#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGE")
#endif // ALLOC_PRAGMA


CCaptureFilter::
CCaptureFilter (
    IN PKSFILTER Filter
    ) :
    m_Filter (Filter)

/*++

Routine Description:

    This is the constructor for the capture filter.  It initializes all the
    structures necessary to kick off timer DPC's for capture.

Arguments:

    Filter -
        The AVStream filter being created.

Return Value:

    None

--*/

{

    //
    // Initialize the DPC's, timers, and events necessary to cause a 
    // capture trigger to happen.
    //
    KeInitializeDpc (
        &m_TimerDpc,
        reinterpret_cast <PKDEFERRED_ROUTINE> (
            CCaptureFilter::TimerRoutine
            ),
        this
        );

    KeInitializeEvent (
        &m_StopDPCEvent,
        SynchronizationEvent,
        FALSE
        );

    KeInitializeTimer (&m_Timer);

}

/*************************************************/


NTSTATUS
CCaptureFilter::
DispatchCreate (
    IN PKSFILTER Filter,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the creation dispatch for the capture filter.  It creates
    the CCaptureFilter object, associates it with the AVStream filter
    object, and bag the CCaptureFilter for later cleanup.

Arguments:

    Filter -
        The AVStream filter being created

    Irp -
        The creation Irp

Return Value:
    
    Success / failure

--*/

{

    PAGED_CODE();

    NTSTATUS Status = STATUS_SUCCESS;

    CCaptureFilter *CapFilter = new (NonPagedPool) CCaptureFilter (Filter);

    if (!CapFilter) {
        //
        // Return failure if we couldn't create the filter.
        //
        Status = STATUS_INSUFFICIENT_RESOURCES;

    } else {
        //
        // Add the item to the object bag if we we were successful. 
        // Whenever the filter closes, the bag is cleaned up and we will be
        // freed.
        //
        Status = KsAddItemToObjectBag (
            Filter -> Bag,
            reinterpret_cast <PVOID> (CapFilter),
            reinterpret_cast <PFNKSFREE> (CCaptureFilter::Cleanup)
            );

        if (!NT_SUCCESS (Status)) {
            delete CapFilter;
        } else {
            Filter -> Context = reinterpret_cast <PVOID> (CapFilter);
        }

    }

    //
    // Create the wave reader.  We need it at this point because the data
    // ranges exposed on the audio pin need to change dynamically right
    // now.
    //
    if (NT_SUCCESS (Status)) {

        CapFilter -> m_WaveObject =  
            new (NonPagedPool, 'evaW') CWaveObject (
                L"\\DosDevices\\c:\\avssamp.wav"
                );

        if (!CapFilter -> m_WaveObject) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        } else {
            Status = CapFilter -> m_WaveObject -> ParseAndRead ();

            //
            // If the file cannot be found, don't fail to create the filter.
            // This simply means that audio cannot be synthesized.
            //
            if (Status == STATUS_OBJECT_NAME_NOT_FOUND ||
                Status == STATUS_ACCESS_DENIED) {
                delete CapFilter -> m_WaveObject;
                CapFilter -> m_WaveObject = NULL;
                Status = STATUS_SUCCESS;
            }
            
        }

    }

    if (NT_SUCCESS (Status) && CapFilter -> m_WaveObject) {
        //
        // Add the wave object to the filter's bag for auto-cleanup.
        //
        Status = KsAddItemToObjectBag (
            Filter -> Bag,
            reinterpret_cast <PVOID> (CapFilter -> m_WaveObject),
            reinterpret_cast <PFNKSFREE> (CWaveObject::Cleanup)
            );

        if (!NT_SUCCESS (Status)) {
            delete CapFilter -> m_WaveObject;
            CapFilter -> m_WaveObject = NULL;
        } else {
            Status = CapFilter -> BindAudioToWaveObject ();
        }
    }

    return Status;

}

/*************************************************/


NTSTATUS
CCaptureFilter::
BindAudioToWaveObject (
    )

/*++

Routine Description:

    Create an audio pin directly bound to m_WaveObject (aka: it only exposes
    the format (channels, frequency, etc...) that m_WaveObject represents.
    This will actually create a pin on the filter dynamically.

Arguments:

    None

Return Value:

    Success / Failure

--*/

{

    PAGED_CODE();

    ASSERT (m_WaveObject);

    NTSTATUS Status = STATUS_SUCCESS;

    //
    // Build a pin descriptor from the template.  This descriptor is
    // temporary scratch space because the call to AVStream to create the
    // pin will actually duplicate the descriptor.
    //
    KSPIN_DESCRIPTOR_EX PinDescriptor = AudioPinDescriptorTemplate;

    //
    // The data range must be dynamically created since we're basing it
    // on dynamic reading of a wave file!
    //
    PKSDATARANGE_AUDIO DataRangeAudio = 
        reinterpret_cast <PKSDATARANGE_AUDIO> (
            ExAllocatePool (PagedPool, sizeof (KSDATARANGE_AUDIO))
            );

    PKSDATARANGE_AUDIO *DataRanges =
        reinterpret_cast <PKSDATARANGE_AUDIO *> (
            ExAllocatePool (PagedPool, sizeof (PKSDATARANGE_AUDIO))
            );

    PKSALLOCATOR_FRAMING_EX Framing =
        reinterpret_cast <PKSALLOCATOR_FRAMING_EX> (
            ExAllocatePool (PagedPool, sizeof (KSALLOCATOR_FRAMING_EX))
            );

    if (DataRangeAudio && DataRanges && Framing) {
        DataRangeAudio -> DataRange.FormatSize = sizeof (KSDATARANGE_AUDIO);
        DataRangeAudio -> DataRange.Flags = 0;
        DataRangeAudio -> DataRange.SampleSize = 0;
        DataRangeAudio -> DataRange.Reserved = 0;
        DataRangeAudio -> DataRange.MajorFormat = KSDATAFORMAT_TYPE_AUDIO;
        DataRangeAudio -> DataRange.SubFormat = KSDATAFORMAT_SUBTYPE_PCM;
        DataRangeAudio -> DataRange.Specifier = 
            KSDATAFORMAT_SPECIFIER_WAVEFORMATEX;

        m_WaveObject -> WriteRange (DataRangeAudio);

        *DataRanges = DataRangeAudio;

    } else {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    if (NT_SUCCESS (Status)) {
        //
        // Bag the newly created range information in the filter's bag since
        // this will be alive for the lifetime of the filter.
        //
        Status = KsAddItemToObjectBag (
            m_Filter -> Bag,
            DataRangeAudio,
            NULL
            );

        if (!NT_SUCCESS (Status)) {
            ExFreePool (DataRangeAudio);
            ExFreePool (DataRanges);
            ExFreePool (Framing);
        }

    }

    if (NT_SUCCESS (Status)) {

        Status = KsAddItemToObjectBag (
            m_Filter -> Bag,
            DataRanges,
            NULL
            );

        if (!NT_SUCCESS (Status)) {
            ExFreePool (DataRanges);
            ExFreePool (Framing);
        }

    }

    if (NT_SUCCESS (Status)) {
        
        Status = KsAddItemToObjectBag (
            m_Filter -> Bag,
            Framing,
            NULL
            );

        if (!NT_SUCCESS (Status)) {
            ExFreePool (Framing);
        }

    }

    if (NT_SUCCESS (Status)) {
        //
        // The physical and optimal ranges must block aligned and 
        // the size of 1/(fps) * bytes_per_sec in size.  It's true
        // that we don't know the frame rate at this point due
        // to the fact that the video pin doesn't exist yet; however, that
        // would also be true if this were edited at audio pin creation.
        //
        // Thus, we instead adjust the allocator for the minimum frame rate
        // we support (which is 1/30 of a second).
        //
        *Framing = *PinDescriptor.AllocatorFraming;

        Framing -> FramingItem [0].PhysicalRange.MinFrameSize =
            Framing -> FramingItem [0].PhysicalRange.MaxFrameSize =
            Framing -> FramingItem [0].FramingRange.Range.MinFrameSize =
            Framing -> FramingItem [0].FramingRange.Range.MaxFrameSize =
                ((DataRangeAudio -> MaximumSampleFrequency *
                DataRangeAudio -> MaximumBitsPerSample *
                DataRangeAudio -> MaximumChannels) + 29) / 30;

        Framing -> FramingItem [0].PhysicalRange.Stepping = 
            Framing -> FramingItem [0].FramingRange.Range.Stepping =
            0;

        PinDescriptor.AllocatorFraming = Framing;

        PinDescriptor.PinDescriptor.DataRangesCount = 1;
        PinDescriptor.PinDescriptor.DataRanges = 
            reinterpret_cast <const PKSDATARANGE *> (DataRanges);

        //
        // Create the actual pin.  We need to save the pin id returned.  It
        // is how we refer to the audio pin in the future.
        //
        Status = KsFilterCreatePinFactory (
            m_Filter, 
            &PinDescriptor, 
            &m_AudioPinId
            );

    }

    return Status;

}


/*************************************************/


void
CCaptureFilter::
StartDPC (
    IN LONGLONG TimerInterval
    )

/*++

Routine Description:

    This routine starts the timer DPC running at a specified interval.  The 
    specified interval is the amount of time between triggering frame captures.
    Once this routine returns, the timer DPC should be running and attempting
    to trigger processing on the capture filter as a whole.

Arguments:

    TimerInterval -
        The amount of time between timer DPC's.  This is the amount of delay
        between one frame and the next.  Since the DPC is driven off the 
        video capture pin, this should be an amount of time specified by
        the video info header.

Return Value:

    None

--*/

{

    PAGED_CODE();

    //
    // Initialize any variables used by the timer DPC.
    //
    m_Tick = 0;
    m_TimerInterval = TimerInterval;
    KeQuerySystemTime (&m_StartTime);

    //
    // Schedule the DPC to happen one frame time from now.
    //
    LARGE_INTEGER NextTime;
    NextTime.QuadPart = m_StartTime.QuadPart + m_TimerInterval;

    KeSetTimer (&m_Timer, NextTime, &m_TimerDpc);

}

/*************************************************/


void
CCaptureFilter::
StopDPC (
    )

/*++

Routine Description:

    Stop the timer DPC from firing.  After this routine returns, there is
    a guarantee that no more timer DPC's will fire and no more processing
    attempts will occur.  Note that this routine does block.

Arguments:

    None

Return Value:

    None

--*/

{

    PAGED_CODE();

    m_StoppingDPC = TRUE;

    KeWaitForSingleObject (
        &m_StopDPCEvent,
        Suspended,
        KernelMode,
        FALSE,
        NULL
        );

    ASSERT (m_StoppingDPC == FALSE);

}

/**************************************************************************

    LOCKED CODE

**************************************************************************/

#ifdef ALLOC_PRAGMA
#pragma code_seg()
#endif // ALLOC_PRAGMA


LONGLONG
CCaptureFilter::
GetTimerInterval (
    )

/*++

Routine Description:

    Return the timer interval being used to fire DPC's.

Arguments:

    None

Return Value:

    The timer interval being used to fire DPC's.

--*/

{

    return m_TimerInterval;

}

/*************************************************/


NTSTATUS
CCaptureFilter::
Process (
    IN PKSPROCESSPIN_INDEXENTRY ProcessPinsIndex
    )

/*++

Routine Description:

    This is the processing function for the capture filter.  It is responsible
    for copying synthesized image data into the image buffers.  The timer DPC
    will attempt to trigger processing (and hence indirectly call this routine)
    to trigger a capture.

Arguments:

    ProcessPinsIndex -
        Contains a pointer to an array of process pin index entries.  This
        array is indexed by pin ID.  An index entry indicates the number
        of pin instances for the corresponding filter type and points to the
        first corresponding process pin structure in the ProcessPins array.
        This allows the process pin structure to be quickly accessed by pin ID
        when the number of instances per type is not known in advance.

Return Value:

    Indication of whether more processing should be done if frames are
    available.  A value of STATUS_PENDING indicates that processing should not
    continue even if frames are available on all required queues. 
    STATUS_SUCCESS indicates processing should continue if frames are available
    on all required queues.

--*/

{

    //
    // The audio and video pins do not necessarily need to exist (one could
    // be capturing video w/o audio or vice-versa).  Do not assume the
    // existence by checking Index[ID].Pins[0].  Always check the Count
    // field first.
    //
    PKSPROCESSPIN VideoPin = NULL;
    CCapturePin *VidCapPin = NULL;
    PKSPROCESSPIN AudioPin = NULL;
    CCapturePin *AudCapPin = NULL;
    ULONG VidCapDrop = 0;
    ULONG AudCapDrop = (ULONG)-1;

    if (ProcessPinsIndex [VIDEO_PIN_ID].Count != 0) {
        //
        // There can be at most one instance via the possible instances field,
        // so the below is safe.
        //
        VideoPin = ProcessPinsIndex [VIDEO_PIN_ID].Pins [0];
        VidCapPin = 
            reinterpret_cast <CCapturePin *> (VideoPin -> Pin -> Context);
    }

    //
    // The audio pin only exists on the filter if the wave object does.
    // They're tied together at filter create time.
    //
    if (m_WaveObject && ProcessPinsIndex [m_AudioPinId].Count != 0) {
        //
        // There can be at most one instance via the possible instances field,
        // so the below is safe.
        //
        AudioPin = ProcessPinsIndex [m_AudioPinId].Pins [0];
        AudCapPin =
            reinterpret_cast <CCapturePin *> (AudioPin -> Pin -> Context);
    }

    if (VidCapPin) {
        VidCapDrop = VidCapPin -> QueryFrameDrop ();
    } 
    
    if (AudCapPin) {
        AudCapDrop = AudCapPin -> QueryFrameDrop ();
    }

    //
    // If there's a video pin around, trigger capture on it.  We call the
    // pin object to actually synthesize the frame; however, we could just
    // as easily have done that here.
    //
    if (VidCapPin) {
        //
        // This is used to notify the pin how many frames have been dropped
        // on each pin to allow that to be rendered.
        //
        VidCapPin -> NotifyDrops (VidCapDrop, AudCapDrop);
        VidCapPin -> CaptureFrame (VideoPin, m_Tick);
    }

    //
    // If there's an audio pin around, trigger capture on it.  Since the
    // audio capture pin isn't necessary for capture, there might be an
    // instance which is connected and is in the stop state when we get 
    // called [there will never be one in acquire or pause since we specify
    // KSPIN_FLAG_PROCESS_IN_RUN_STATE_ONLY].  Don't bother triggering capture
    // on the pin unless it's actually running.
    //
    // On DX8.x platforms, the Pin -> ClientState field does not exist.
    // Hence, we check the state we maintain ourselves.  DeviceState is not
    // the right thing to check here.
    //
    if (AudioPin && AudCapPin -> GetState () == KSSTATE_RUN) {
        AudCapPin -> CaptureFrame (AudioPin, m_Tick);
    }

    //
    // STATUS_PENDING indicates that we do not want to be called back if
    // there is more data available.  We only want to trigger processing
    // (and hence capture) on the timer ticks.
    //
    return STATUS_PENDING;

}

/*************************************************/


void
CCaptureFilter::
TimerDpc (
    )

/*++

Routine Description:

    This is the timer function for our timer (bridged to from TimerRoutine
    in the context of the appropriate CCaptureFilter).  It is called every
    1/Nth of a second as specified in StartDpc() to trigger capture of a video
    frame.

Arguments:

    None

Return Value:

    None

--*/

{

    //
    // Increment the tick counter.  This keeps track of the number of ticks
    // that have happened since the timer DPC started running.  Note that the
    // timer DPC starts running before the pins go into run state and this
    // variable gets incremented from the original start point.
    //
    m_Tick++;

    //
    // Trigger processing on the filter.  Since the filter is prepared to
    // run at DPC, we do not request asynchronous processing.  Thus, if 
    // possible, processing will occur in the context of this DPC.
    //
    KsFilterAttemptProcessing (m_Filter, FALSE);

    //
    // Reschedule the timer if the hardware isn't being stopped.
    //
    if (!m_StoppingDPC) {
        
        LARGE_INTEGER NextTime;

        NextTime.QuadPart = m_StartTime.QuadPart +
            (m_TimerInterval * (m_Tick + 1));

        KeSetTimer (&m_Timer, NextTime, &m_TimerDpc);

    } else {

        //
        // If another thread is waiting on the DPC to stop running, raise
        // the stop event and clear the flag.
        //
        m_StoppingDPC = FALSE;
        KeSetEvent (&m_StopDPCEvent, IO_NO_INCREMENT, FALSE);

    }

}

/**************************************************************************

    DESCRIPTOR AND DISPATCH LAYOUT

**************************************************************************/

GUID g_PINNAME_VIDEO_CAPTURE = {STATIC_PINNAME_VIDEO_CAPTURE};

//
// CaptureFilterCategories:
//
// The list of category GUIDs for the capture filter.
//
const
GUID
CaptureFilterCategories [CAPTURE_FILTER_CATEGORIES_COUNT] = {
    STATICGUIDOF (KSCATEGORY_VIDEO),
    STATICGUIDOF (KSCATEGORY_CAPTURE)
};

//
// CaptureFilterPinDescriptors:
//
// The list of pin descriptors on the capture filter.  
//
const 
KSPIN_DESCRIPTOR_EX
CaptureFilterPinDescriptors [CAPTURE_FILTER_PIN_COUNT] = {
    //
    // Video Capture Pin
    //
    {
        &VideoCapturePinDispatch,
        NULL,             
        {
            NULL,                           // Interfaces (NULL, 0 == default)
            0,
            NULL,                           // Mediums (NULL, 0 == default)
            0,
            SIZEOF_ARRAY (VideoCapturePinDataRanges), // Range Count
            VideoCapturePinDataRanges,      // Ranges
            KSPIN_DATAFLOW_OUT,             // Dataflow
            KSPIN_COMMUNICATION_BOTH,       // Communication
            &KSCATEGORY_VIDEO,              // Category
            &g_PINNAME_VIDEO_CAPTURE,       // Name
            0                               // Reserved
        },
        KSPIN_FLAG_FRAMES_NOT_REQUIRED_FOR_PROCESSING | // Flags
            KSPIN_FLAG_DO_NOT_INITIATE_PROCESSING |
            KSPIN_FLAG_PROCESS_IN_RUN_STATE_ONLY,
        1,                                  // Instances Possible
        1,                                  // Instances Necessary
        &VideoCapturePinAllocatorFraming,   // Allocator Framing
        reinterpret_cast <PFNKSINTERSECTHANDLEREX> 
            (CVideoCapturePin::IntersectHandler)
    }
};

//
// CaptureFilterDispatch:
//
// This is the dispatch table for the capture filter.  It provides notification
// of creation, closure, processing, and resets.
//
const 
KSFILTER_DISPATCH
CaptureFilterDispatch = {
    CCaptureFilter::DispatchCreate,         // Filter Create
    NULL,                                   // Filter Close
    CCaptureFilter::DispatchProcess,        // Filter Process
    NULL                                    // Filter Reset
};

//
// CaptureFilterDescription:
//
// The descriptor for the capture filter.  We don't specify any topology
// since there's only one pin on the filter.  Realistically, there would
// be some topological relationships here because there would be input 
// pins from crossbars and the like.
//
const 
KSFILTER_DESCRIPTOR 
CaptureFilterDescriptor = {
    &CaptureFilterDispatch,                 // Dispatch Table
    NULL,                                   // Automation Table
    KSFILTER_DESCRIPTOR_VERSION,            // Version
    KSFILTER_FLAG_DISPATCH_LEVEL_PROCESSING,// Flags
    &KSNAME_Filter,                         // Reference GUID
    DEFINE_KSFILTER_PIN_DESCRIPTORS (CaptureFilterPinDescriptors),
    DEFINE_KSFILTER_CATEGORIES (CaptureFilterCategories),

    DEFINE_KSFILTER_NODE_DESCRIPTORS_NULL,
    DEFINE_KSFILTER_DEFAULT_CONNECTIONS,

    NULL                                    // Component ID
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\ksfilter\tests\avstest\purecall.c ===
/**************************************************************************

    AVStream Filter-Centric Sample

    Copyright (c) 1999 - 2001, Microsoft Corporation

    File:

        purecall.c

    Abstract:

        This file contains the _purecall stub necessary for virtual function
        usage in drivers on 98 gold.

    History:

        created 9/16/02

**************************************************************************/

/*************************************************

    Function:

        _purecall

    Description:

        _purecall stub for virtual function usage

    Arguments:

        None

    Return Value:

        0

*************************************************/

int __cdecl 
_purecall (
    VOID
    ) 

{
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\ksfilter\tests\avstest\filter.h ===
/**************************************************************************

    AVStream Filter-Centric Sample

    Copyright (c) 1999 - 2001, Microsoft Corporation

    File:

        filter.h

    Abstract:

        This file contails the filter level header for the filter-centric
        capture filter.

    History:

        created 5/31/01

**************************************************************************/

/**************************************************************************

    DEFINES

**************************************************************************/

//
// VIDEO_PIN_ID:
//
// The pin factory id of the video pin (the order in the descriptor table).
//
#define VIDEO_PIN_ID 0

/**************************************************************************

    CLASSES

**************************************************************************/

class CCaptureFilter {

private:

    //
    // The AVStream filter object associated with this CCaptureFilter.
    //
    PKSFILTER m_Filter;

    //
    // The DPC used for the timer.
    //
    KDPC m_TimerDpc;
    
    //
    // The timer used for simulation of capture timings.
    //
    KTIMER m_Timer;

    //
    // Boolean used to detect whether the DPC routine is to shutdown or not
    //
    BOOLEAN m_StoppingDPC;

    //
    // The event used to signal successful shutdown of the timer DPC
    //
    KEVENT m_StopDPCEvent;

    //
    // The number of timer ticks that have occurred since the timer DPC 
    // started firing.
    //
    volatile ULONG m_Tick;

    //
    // The system time at the point that the timer DPC starts.
    //
    LARGE_INTEGER m_StartTime;

    //
    // The amount of time between timer DPC's (and hence frame capture
    // triggers).
    //
    LONGLONG m_TimerInterval;

    //
    // The wave object.  This is passed to the audio pin later, but it's
    // used at filter create time to determine what ranges to expose on
    // the audio pin.
    //
    CWaveObject *m_WaveObject;

    //
    // The audio pin factory id.  This is dynamic since the pin is created
    // dynamically at filter create time.
    //
    ULONG m_AudioPinId;

    //
    // Process():
    //
    // The process routine for the capture filter.  This is responsible for
    // copying synthesized data into image buffers.  The DispatchProcess()
    // function bridges to this routine in the context of the CCaptureFilter.
    //
    NTSTATUS
    Process (
        IN PKSPROCESSPIN_INDEXENTRY ProcessPinsIndex
        );

    //
    // TimerDpc():
    //
    // The timer dpc routine.  This is bridged to from TimerRoutine in the
    // context of the appropriate CCaptureFilter.
    //
    void
    TimerDpc (
        );

    //
    // BindAudioToWaveObject():
    //
    // This function call binds the audio stream exposed by the filter to
    // the wave object m_WaveObject. 
    //
    NTSTATUS
    BindAudioToWaveObject (
        );

    //
    // Cleanup():
    //
    // This is the bag cleanup callback for the CCaptureFilter.  Not providing
    // one would cause ExFreePool to be used.  This is not good for C++
    // constructed objects.  We simply delete the object here.
    //
    static
    void
    Cleanup (
        IN CCaptureFilter *CapFilter
        )
    {
        delete CapFilter;
    }

public:

    //
    // CCaptureFilter():
    //
    // The capture filter object constructor.  Since the new operator will
    // have zeroed the memory, do not bother initializing any NULL or 0
    // fields.  Only initialize non-NULL, non-0 fields.
    //
    CCaptureFilter (
        IN PKSFILTER Filter
        );

    //
    // ~CCaptureFilter():
    //
    // The capture filter destructor.
    //
    ~CCaptureFilter (
        )
    {
    }

    //
    // StartDPC():
    //
    // This is called in order to start the timer DPC running. 
    //
    void
    StartDPC (
        IN LONGLONG TimerInterval
        );

    //
    // StopDPC():
    //
    // This is called in order to stop the timer DPC running.  The function
    // will not return until it guarantees that no more timer DPC's fire.
    //
    void
    StopDPC (
        );

    //
    // GetWaveObject():
    //
    // Returns the wave object that has been opened for the filter.
    //
    CWaveObject *
    GetWaveObject (
        )
    {
        return m_WaveObject;
    }

    //
    // GetTimerInterval():
    //
    // Returns the timer interval we're using to generate DPC's.
    //
    LONGLONG
    GetTimerInterval (
        );

    /*************************************************

        Dispatch Routines

    *************************************************/

    //
    // DispatchCreate():
    //
    // This is the filter creation dispatch for the capture filter.  It 
    // creates the CCaptureFilter object, associates it with the AVStream
    // object, and bags it for easy cleanup later.
    //
    static
    NTSTATUS
    DispatchCreate (
        IN PKSFILTER Filter,
        IN PIRP Irp
        );

    //
    // DispatchProcess():
    //
    // This is the filter process dispatch for the capture filter.  It merely
    // bridges to Process() in the context of the CCaptureFilter.
    //
    static
    NTSTATUS
    DispatchProcess (
        IN PKSFILTER Filter,
        IN PKSPROCESSPIN_INDEXENTRY ProcessPinsIndex
        )
    {
        return
            (reinterpret_cast <CCaptureFilter *> (Filter -> Context)) ->
                Process (ProcessPinsIndex);
    }

    //
    // TimerRoutine():
    //
    // This is the timer routine called every 1/Nth of a second to trigger
    // capture by the filter.
    //
    static
    void
    TimerRoutine (
        IN PKDPC Dpc,
        IN CCaptureFilter *This,
        IN PVOID SystemArg1,
        IN PVOID SystemArg2
        )
    {
        This -> TimerDpc ();
    }
            
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\ksfilter\tests\avstest\capture.h ===
/**************************************************************************

    AVStream Filter-Centric Sample

    Copyright (c) 1999 - 2001, Microsoft Corporation

    File:

        capture.h

    Abstract:

        This file contains the capture pin level header for all capture pins
        on the sample filter.

    History:

        created 5/31/01

**************************************************************************/

class CCapturePin 
{

protected:

    //
    // The clock object associated with this pin.
    //
    PIKSREFERENCECLOCK m_Clock;

    //
    // The AVStream pin object associated with this pin.
    //
    PKSPIN m_Pin;

    //
    // The CCaptureFilter owning this pin.
    //
    CCaptureFilter *m_ParentFilter;

    //
    // The count of dropped frames.  The base class will reset this upon
    // stopping the pin.
    //
    ULONG m_DroppedFrames;

    //
    // The frame number.
    //
    ULONGLONG m_FrameNumber;

    //
    // Notifications as to frame drop.  This is used to incorporate frame
    // drop data into the synthesis.
    //
    ULONG m_NotifyVidDrop;
    ULONG m_NotifyAudDrop;

    //
    // Current state.
    //
    KSSTATE m_State;

public:

    //
    // CCapturePin():
    //
    // Construct a new capture pin.
    //
    CCapturePin (
        IN PKSPIN Pin
        );

    //
    // ~CCapturePin():
    //
    // Destruct a capture pin.  The destructor is virtual because the cleanup
    // code will delete the derived class as a CCapturePin.
    //
    virtual
    ~CCapturePin (
        )
    {
    }

    //
    // ClockAssigned():
    //
    // Determine whether or not there is a clock assigned to the pin.
    //
    BOOLEAN
    ClockAssigned (
        )
    {
        return (m_Clock != NULL);
    }

    //
    // GetTime():
    //
    // Get the time on the clock.  There must be a clock assigned to the pin
    // for this call to work.  Verification should be made through
    // the ClockAssigned() call.
    //
    LONGLONG
    GetTime (
        )
    {
        return m_Clock -> GetTime ();
    }

    //
    // SetState():
    //
    // Called to set the state of the pin.  The base class performs clock
    // handling and calls the appropriate derived method (Run/Pause/Acquire/
    // Stop).
    //
    NTSTATUS
    SetState (
        IN KSSTATE ToState,
        IN KSSTATE FromState
        );

    //
    // Run():
    //
    // Called when a pin transitions to KSSTATE_ACQUIRE by SetState().
    // The derived class can override this to provide any implementation it
    // needs.
    //
    virtual
    NTSTATUS 
    Run (
        IN KSSTATE FromState
        )
    {
        return STATUS_SUCCESS;
    }

    //
    // Pause():
    //
    // Called when a pin transitions to KSSTATE_PAUSE by SetState().
    // The derived class can override this to provide any implementation it
    // needs.
    //
    virtual
    NTSTATUS
    Pause (
        IN KSSTATE FromState
        )
    {
        return STATUS_SUCCESS;
    }

    //
    // Acquire():
    //
    // Called when a pin transitions to KSSTATE_ACQUIRE by SetState().
    // The derived class can override this to provide any implementation it
    // needs.
    //
    virtual
    NTSTATUS
    Acquire (
        IN KSSTATE FromState
        )
    {
        return STATUS_SUCCESS;
    }

    //
    // Stop():
    //
    // Called when a pin transitions to KSSTATE_STOP by SetState().
    // The derived class can override this to provide any implementation it
    // needs.
    //
    virtual
    NTSTATUS
    Stop (
        IN KSSTATE FromState
        )
    {
        return STATUS_SUCCESS;
    }

    //
    // GetState():
    //
    // Return the current state of the pin.
    //
    KSSTATE
    GetState (
        )
    {
        return m_State;
    }

    //
    // CaptureFrame():
    //
    // Called in order to trigger capture of a frame on the given pin.  The
    // filter's "tick" count is passed as a reference to synthesize an
    // appropriate frame.
    //
    virtual
    NTSTATUS
    CaptureFrame (
        IN PKSPROCESSPIN ProcessPin,
        IN ULONG Tick
        ) = 0;

    //
    // QueryFrameDrop():
    //
    // Query the number of dropped frames.
    //
    ULONG
    QueryFrameDrop (
        );

    //
    // NotifyDrops():
    //
    // Notify the pin how many frames have been dropped on all pins.
    //
    void
    NotifyDrops (
        IN ULONG VidDrop,
        IN ULONG AudDrop
        );

    /*************************************************

        Dispatch Functions

    *************************************************/

    //
    // DispatchSetState():
    //
    // This is the set device state dispatch for the pin.  It merely acts
    // as a bridge to SetState() in the context of the CCapturePin associated
    // with Pin.
    //
    static
    NTSTATUS
    DispatchSetState (
        IN PKSPIN Pin,
        IN KSSTATE ToState,
        IN KSSTATE FromState
        )
    {
        return
            (reinterpret_cast <CCapturePin *> (Pin -> Context)) ->
                SetState (ToState, FromState);
    }

    //
    // BagCleanup():
    //
    // This is the free callback for the CCapturePin that we bag.  Normally,
    // ExFreePool would be used, but we must delete instead.  This function
    // will just delete the CCapturePin instead of freeing it.  Because our
    // destructor is virtual, the appropriate derived class destructor will
    // get called.
    //
    static
    void
    BagCleanup (
        IN CCapturePin *This
        )

    {

        delete This;

    }

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\ksfilter\tests\avstest\video.cpp ===
/**************************************************************************

    AVStream Filter-Centric Sample

    Copyright (c) 1999 - 2001, Microsoft Corporation

    File:

        video.cpp

    Abstract:

        This file contains the video capture pin implementation.

    History:

        created 6/11/01

**************************************************************************/

#include "avssamp.h"

/**************************************************************************

    PAGEABLE CODE

**************************************************************************/

#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGE")
#endif // ALLOC_PRAGMA

NTSTATUS
CVideoCapturePin::
DispatchCreate (
    IN PKSPIN Pin,
    IN PIRP Irp
    )

/*++

Routine Description:

    Create a new video capture pin.  This is the creation dispatch for
    the video capture pin.

Arguments:

    Pin -
        The pin being created

    Irp -
        The creation Irp

Return Value:

    Success / Failure

--*/

{

    PAGED_CODE();

    NTSTATUS Status = STATUS_SUCCESS;

    CVideoCapturePin *CapPin = new (NonPagedPool) CVideoCapturePin (Pin);
    CCapturePin *BasePin = static_cast <CCapturePin *> (CapPin);

    if (!CapPin) {
        //
        // Return failure if we couldn't create the pin.
        //
        Status = STATUS_INSUFFICIENT_RESOURCES;

    } else {
        //
        // Add the item to the object bag if we we were successful. 
        // Whenever the pin closes, the bag is cleaned up and we will be
        // freed.
        //
        Status = KsAddItemToObjectBag (
            Pin -> Bag,
            reinterpret_cast <PVOID> (BasePin),
            reinterpret_cast <PFNKSFREE> (CCapturePin::BagCleanup)
            );

        if (!NT_SUCCESS (Status)) {
            delete CapPin;
        } else {
            Pin -> Context = reinterpret_cast <PVOID> (BasePin);
        }

    }

    //
    // If we succeeded so far, stash the video info header away and change
    // our allocator framing to reflect the fact that only now do we know
    // the framing requirements based on the connection format.
    //
    PKS_VIDEOINFOHEADER VideoInfoHeader = NULL;

    if (NT_SUCCESS (Status)) {

        VideoInfoHeader = CapPin -> CaptureVideoInfoHeader ();
        if (!VideoInfoHeader) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    if (NT_SUCCESS (Status)) {
        
        //
        // We need to edit the descriptor to ensure we don't mess up any other
        // pins using the descriptor or touch read-only memory.
        //
        Status = KsEdit (Pin, &Pin -> Descriptor, 'aChS');

        if (NT_SUCCESS (Status)) {
            Status = KsEdit (
                Pin, 
                &(Pin -> Descriptor -> AllocatorFraming),
                'aChS'
                );
        }

        //
        // If the edits proceeded without running out of memory, adjust 
        // the framing based on the video info header.
        //
        if (NT_SUCCESS (Status)) {

            //
            // We've KsEdit'ed this...  I'm safe to cast away constness as
            // long as the edit succeeded.
            //
            PKSALLOCATOR_FRAMING_EX Framing =
                const_cast <PKSALLOCATOR_FRAMING_EX> (
                    Pin -> Descriptor -> AllocatorFraming
                    );

            Framing -> FramingItem [0].Frames = 2;

            //
            // The physical and optimal ranges must be biSizeImage.  We only
            // support one frame size, precisely the size of each capture
            // image.
            //
            Framing -> FramingItem [0].PhysicalRange.MinFrameSize =
                Framing -> FramingItem [0].PhysicalRange.MaxFrameSize =
                Framing -> FramingItem [0].FramingRange.Range.MinFrameSize =
                Framing -> FramingItem [0].FramingRange.Range.MaxFrameSize =
                VideoInfoHeader -> bmiHeader.biSizeImage;

            Framing -> FramingItem [0].PhysicalRange.Stepping = 
                Framing -> FramingItem [0].FramingRange.Range.Stepping =
                0;

        }

    }

    if (NT_SUCCESS (Status)) {
        //
        // Adjust the stream header size.  The video packets have extended
        // header info (KS_FRAME_INFO).
        //
        Pin -> StreamHeaderSize = sizeof (KSSTREAM_HEADER) +
            sizeof (KS_FRAME_INFO);

    }

    return Status;

}

/*************************************************/


PKS_VIDEOINFOHEADER 
CVideoCapturePin::
CaptureVideoInfoHeader (
    )

/*++

Routine Description:

    Capture the video info header out of the connection format.  This
    is what we use to base synthesized images off.

Arguments:

    None

Return Value:

    The captured video info header or NULL if there is insufficient
    memory.

--*/

{

    PAGED_CODE();

    PKS_VIDEOINFOHEADER ConnectionHeader =
        &((reinterpret_cast <PKS_DATAFORMAT_VIDEOINFOHEADER> 
            (m_Pin -> ConnectionFormat)) -> 
            VideoInfoHeader);

    m_VideoInfoHeader = reinterpret_cast <PKS_VIDEOINFOHEADER> (
        ExAllocatePool (
            NonPagedPool,
            KS_SIZE_VIDEOHEADER (ConnectionHeader)
            )
        );

    if (!m_VideoInfoHeader)
        return NULL;

    //
    // Bag the newly allocated header space.  This will get cleaned up
    // automatically when the pin closes.
    //
    NTSTATUS Status =
        KsAddItemToObjectBag (
            m_Pin -> Bag,
            reinterpret_cast <PVOID> (m_VideoInfoHeader),
            NULL
            );

    if (!NT_SUCCESS (Status)) {

        ExFreePool (m_VideoInfoHeader);
        return NULL;

    } else {

        //
        // Copy the connection format video info header into the newly 
        // allocated "captured" video info header.
        //
        RtlCopyMemory (
            m_VideoInfoHeader,
            ConnectionHeader,
            KS_SIZE_VIDEOHEADER (ConnectionHeader)
            );

    }

    return m_VideoInfoHeader;

}

/*************************************************/


NTSTATUS
CVideoCapturePin::
IntersectHandler (
    IN PKSFILTER Filter,
    IN PIRP Irp,
    IN PKSP_PIN PinInstance,
    IN PKSDATARANGE CallerDataRange,
    IN PKSDATARANGE DescriptorDataRange,
    IN ULONG BufferSize,
    OUT PVOID Data OPTIONAL,
    OUT PULONG DataSize
    )

/*++

Routine Description:

    This routine handles video pin intersection queries by determining the
    intersection between two data ranges.

Arguments:

    Filter -
        Contains a void pointer to the  filter structure.

    Irp -
        Contains a pointer to the data intersection property request.

    PinInstance -
        Contains a pointer to a structure indicating the pin in question.

    CallerDataRange -
        Contains a pointer to one of the data ranges supplied by the client
        in the data intersection request.  The format type, subtype and
        specifier are compatible with the DescriptorDataRange.

    DescriptorDataRange -
        Contains a pointer to one of the data ranges from the pin descriptor
        for the pin in question.  The format type, subtype and specifier are
        compatible with the CallerDataRange.

    BufferSize -
        Contains the size in bytes of the buffer pointed to by the Data
        argument.  For size queries, this value will be zero.

    Data -
        Optionally contains a pointer to the buffer to contain the data 
        format structure representing the best format in the intersection 
        of the two data ranges.  For size queries, this pointer will be 
        NULL.

    DataSize -
        Contains a pointer to the location at which to deposit the size 
        of the data format.  This information is supplied by the function 
        when the format is actually delivered and in response to size 
        queries.

Return Value:

    STATUS_SUCCESS if there is an intersection and it fits in the supplied
    buffer, STATUS_BUFFER_OVERFLOW for successful size queries, 
    STATUS_NO_MATCH if the intersection is empty, or 
    STATUS_BUFFER_TOO_SMALL if the supplied buffer is too small.

--*/

{
    PAGED_CODE();

    const GUID VideoInfoSpecifier = 
        {STATICGUIDOF(KSDATAFORMAT_SPECIFIER_VIDEOINFO)};
    
    ASSERT(Filter);
    ASSERT(Irp);
    ASSERT(PinInstance);
    ASSERT(CallerDataRange);
    ASSERT(DescriptorDataRange);
    ASSERT(DataSize);
    
    ULONG DataFormatSize;
    
    //
    // Specifier FORMAT_VideoInfo for VIDEOINFOHEADER
    //
    if (IsEqualGUID(CallerDataRange->Specifier, VideoInfoSpecifier) &&
        CallerDataRange->FormatSize >= sizeof (KS_DATARANGE_VIDEO)) {
            
        PKS_DATARANGE_VIDEO callerDataRange = 
            reinterpret_cast <PKS_DATARANGE_VIDEO> (CallerDataRange);

        PKS_DATARANGE_VIDEO descriptorDataRange = 
            reinterpret_cast <PKS_DATARANGE_VIDEO> (DescriptorDataRange);

        PKS_DATAFORMAT_VIDEOINFOHEADER FormatVideoInfoHeader;

        //
        // Check that the other fields match
        //
        if ((callerDataRange->bFixedSizeSamples != 
                descriptorDataRange->bFixedSizeSamples) ||
            (callerDataRange->bTemporalCompression != 
                descriptorDataRange->bTemporalCompression) ||
            (callerDataRange->StreamDescriptionFlags != 
                descriptorDataRange->StreamDescriptionFlags) ||
            (callerDataRange->MemoryAllocationFlags != 
                descriptorDataRange->MemoryAllocationFlags) ||
            (RtlCompareMemory (&callerDataRange->ConfigCaps,
                    &descriptorDataRange->ConfigCaps,
                    sizeof (KS_VIDEO_STREAM_CONFIG_CAPS)) != 
                    sizeof (KS_VIDEO_STREAM_CONFIG_CAPS))) 
        {
            return STATUS_NO_MATCH;
        }

        //
        // KS_SIZE_VIDEOHEADER() below is relying on bmiHeader.biSize from
        // the caller's data range.  This **MUST** be validated; the
        // extended bmiHeader size (biSize) must not extend past the end
        // of the range buffer.  Possible arithmetic overflow is also
        // checked for.
        //
        {
            ULONG VideoHeaderSize = KS_SIZE_VIDEOHEADER (
                &callerDataRange->VideoInfoHeader
                );

            ULONG DataRangeSize = 
                FIELD_OFFSET (KS_DATARANGE_VIDEO, VideoInfoHeader) +
                VideoHeaderSize;

            //
            // Check that biSize does not extend past the buffer.  The 
            // first two checks are for arithmetic overflow on the 
            // operations to compute the alleged size.  (On unsigned
            // math, a+b < a iff an arithmetic overflow occurred).
            //
            if (
                VideoHeaderSize < callerDataRange->
                    VideoInfoHeader.bmiHeader.biSize ||
                DataRangeSize < VideoHeaderSize ||
                DataRangeSize > callerDataRange -> DataRange.FormatSize
                ) {

                return STATUS_INVALID_PARAMETER;

            }

        }

        DataFormatSize = 
            sizeof (KSDATAFORMAT) + 
            KS_SIZE_VIDEOHEADER (&callerDataRange->VideoInfoHeader);
            
        //
        // If the passed buffer size is 0, it indicates that this is a size
        // only query.  Return the size of the intersecting data format and
        // pass back STATUS_BUFFER_OVERFLOW.
        //
        if (BufferSize == 0) {

            *DataSize = DataFormatSize;
            return STATUS_BUFFER_OVERFLOW;

        }
        
        //
        // Verify that the provided structure is large enough to
        // accept the result.
        //
        if (BufferSize < DataFormatSize) 
        {
            return STATUS_BUFFER_TOO_SMALL;
        }

        //
        // Copy over the KSDATAFORMAT, followed by the actual VideoInfoHeader
        //
        *DataSize = DataFormatSize;
            
        FormatVideoInfoHeader = PKS_DATAFORMAT_VIDEOINFOHEADER( Data );

        //
        // Copy over the KSDATAFORMAT.  This is precisely the same as the
        // KSDATARANGE (it's just the GUIDs, etc...  not the format information
        // following any data format.
        // 
        RtlCopyMemory (
            &FormatVideoInfoHeader->DataFormat, 
            DescriptorDataRange, 
            sizeof (KSDATAFORMAT));

        FormatVideoInfoHeader->DataFormat.FormatSize = DataFormatSize;

        //
        // Copy over the callers requested VIDEOINFOHEADER
        //

        RtlCopyMemory (
            &FormatVideoInfoHeader->VideoInfoHeader, 
            &callerDataRange->VideoInfoHeader,
            KS_SIZE_VIDEOHEADER (&callerDataRange->VideoInfoHeader) 
            );

        //
        // Calculate biSizeImage for this request, and put the result in both
        // the biSizeImage field of the bmiHeader AND in the SampleSize field
        // of the DataFormat.
        //
        // Note that for compressed sizes, this calculation will probably not
        // be just width * height * bitdepth
        //
        FormatVideoInfoHeader->VideoInfoHeader.bmiHeader.biSizeImage =
            FormatVideoInfoHeader->DataFormat.SampleSize = 
            KS_DIBSIZE (FormatVideoInfoHeader->VideoInfoHeader.bmiHeader);

        //
        // REVIEW - Perform other validation such as cropping and scaling checks
        // 
        
        return STATUS_SUCCESS;
        
    } // End of VIDEOINFOHEADER specifier
    
    return STATUS_NO_MATCH;
}

/*************************************************/

BOOL
MultiplyCheckOverflow (
    ULONG a,
    ULONG b,
    ULONG *pab
    )

/*++

Routine Description:

    Perform a 32 bit unsigned multiplication and check for arithmetic overflow.

Arguments:

    a -
        First operand

    b -
        Second operand

    pab -
        Result

Return Value:

    TRUE -
        no overflow

    FALSE -
        overflow occurred

--*/

{

    *pab = a * b;
    if ((a == 0) || (((*pab) / a) == b)) {
        return TRUE;
    }
    return FALSE;
}

/*************************************************/


NTSTATUS
CVideoCapturePin::
DispatchSetFormat (
    IN PKSPIN Pin,
    IN PKSDATAFORMAT OldFormat OPTIONAL,
    IN PKSMULTIPLE_ITEM OldAttributeList OPTIONAL,
    IN const KSDATARANGE *DataRange,
    IN const KSATTRIBUTE_LIST *AttributeRange OPTIONAL
    )

/*++

Routine Description:

    This is the set data format dispatch for the capture pin.  It is called
    in two circumstances.

        1: before Pin's creation dispatch has been made to verify that
           Pin -> ConnectionFormat is an acceptable format for the range
           DataRange.  In this case OldFormat is NULL.

        2: after Pin's creation dispatch has been made and an initial format
           selected in order to change the format for the pin.  In this case,
           OldFormat will not be NULL.

    Validate that the format is acceptible and perform the actions necessary
    to change format if appropriate.

Arguments:

    Pin -
        The pin this format is being set on.  The format itself will be in
        Pin -> ConnectionFormat.

    OldFormat -
        The previous format used on this pin.  If this is NULL, it is an
        indication that Pin's creation dispatch has not yet been made and
        that this is a request to validate the initial format and not to
        change formats.

    OldAttributeList -
        The old attribute list for the prior format

    DataRange -
        A range out of our list of data ranges which was determined to be
        at least a partial match for Pin -> ConnectionFormat.  If the format
        there is unacceptable for the range, STATUS_NO_MATCH should be
        returned.

    AttributeRange -
        The attribute range

Return Value:

    Success / Failure

        STATUS_SUCCESS -
            The format is acceptable / the format has been changed

        STATUS_NO_MATCH -
            The format is not-acceptable / the format has not been changed

--*/

{

    PAGED_CODE();

    NTSTATUS Status = STATUS_NO_MATCH;

    const GUID VideoInfoSpecifier = 
        {STATICGUIDOF(KSDATAFORMAT_SPECIFIER_VIDEOINFO)};

    CCapturePin *CapPin = NULL;
    CVideoCapturePin *VidCapPin = NULL;

    //
    // Find the pin, if it exists yet.  OldFormat will be an indication of 
    // this.  If we're changing formats, OldFormat will be non-NULL.
    //
    // You cannot use Pin -> Context to make the determination.  AVStream
    // preinitializes this to the filter's context.
    //
    if (OldFormat) {
        CapPin = reinterpret_cast <CCapturePin *> (Pin -> Context);

        //
        // We know this pin happens to be the video capture pin.  Downcast it.
        //
        VidCapPin = static_cast <CVideoCapturePin *> (CapPin);
    }

    if (IsEqualGUID (Pin -> ConnectionFormat -> Specifier,
            VideoInfoSpecifier) &&
        Pin -> ConnectionFormat -> FormatSize >= 
            sizeof (KS_DATAFORMAT_VIDEOINFOHEADER)
        ) {

        PKS_DATAFORMAT_VIDEOINFOHEADER ConnectionFormat =
            reinterpret_cast <PKS_DATAFORMAT_VIDEOINFOHEADER> 
                (Pin -> ConnectionFormat);

        //
        // DataRange comes out of OUR data range list.  I know the range
        // is valid as such.
        //
        const KS_DATARANGE_VIDEO *VIRange =
            reinterpret_cast <const KS_DATARANGE_VIDEO *>
                (DataRange);

        //
        // Check that bmiHeader.biSize is valid since we use it later.
        //
        ULONG VideoHeaderSize = KS_SIZE_VIDEOHEADER (
            &ConnectionFormat -> VideoInfoHeader
            );

        ULONG DataFormatSize = FIELD_OFFSET (
            KS_DATAFORMAT_VIDEOINFOHEADER, VideoInfoHeader
            ) + VideoHeaderSize;

        if (
            VideoHeaderSize < ConnectionFormat->
                VideoInfoHeader.bmiHeader.biSize ||
            DataFormatSize < VideoHeaderSize ||
            DataFormatSize > ConnectionFormat -> DataFormat.FormatSize
            ) {

            Status = STATUS_INVALID_PARAMETER;

        }

        //
        // Check that the format is a match for the selected range. 
        //
        else if (
            (ConnectionFormat -> VideoInfoHeader.bmiHeader.biWidth !=
                VIRange -> VideoInfoHeader.bmiHeader.biWidth) ||

            (ConnectionFormat -> VideoInfoHeader.bmiHeader.biHeight !=
                VIRange -> VideoInfoHeader.bmiHeader.biHeight) ||

            (ConnectionFormat -> VideoInfoHeader.bmiHeader.biCompression !=
                VIRange -> VideoInfoHeader.bmiHeader.biCompression)
           ) {

            Status = STATUS_NO_MATCH;

        } else {

            //
            // Compute the minimum size of our buffers to validate against.
            // The image synthesis routines synthesize |biHeight| rows of
            // biWidth pixels in either RGB24 or UYVY.  In order to ensure
            // safe synthesis into the buffer, we need to know how large an
            // image this will produce.
            //
            // I do this explicitly because of the method that the data is
            // synthesized.  A variation of this may or may not be necessary
            // depending on the mechanism the driver in question fills the 
            // capture buffers.  The important thing is to ensure that they
            // aren't overrun during capture.
            //
            ULONG ImageSize;

            if (!MultiplyCheckOverflow (
                (ULONG)ConnectionFormat->VideoInfoHeader.bmiHeader.biWidth,
                (ULONG)abs (ConnectionFormat->
                    VideoInfoHeader.bmiHeader.biHeight),
                &ImageSize
                )) {

                Status = STATUS_INVALID_PARAMETER;
            }

            //
            // We only support KS_BI_RGB (24) and KS_BI_YUV422 (16), so
            // this is valid for those formats.
            //
            else if (!MultiplyCheckOverflow (
                ImageSize,
                (ULONG)(ConnectionFormat->
                    VideoInfoHeader.bmiHeader.biBitCount / 8),
                &ImageSize
                )) {

                Status = STATUS_INVALID_PARAMETER;

            }

            //
            // Valid for the formats we use.  Otherwise, this would be
            // checked later.
            //
            else if (ConnectionFormat->VideoInfoHeader.bmiHeader.biSizeImage <
                    ImageSize) {

                Status = STATUS_INVALID_PARAMETER;

            } else {

                //
                // We can accept the format. 
                //
                Status = STATUS_SUCCESS;
    
                //
                // OldFormat is an indication that this is a format change.  
                // Since I do not implement the 
                // KSPROPERTY_CONNECTION_PROPOSEDATAFORMAT, by default, I do 
                // not handle dynamic format changes.
                //
                // If something changes while we're in the stop state, we're 
                // fine to handle it since we haven't "configured the hardware"
                // yet.
                //
                if (OldFormat) {
                    //
                    // If we're in the stop state, we can handle just about any
                    // change.  We don't support dynamic format changes. 
                    //
                    if (Pin -> DeviceState == KSSTATE_STOP) {
                        if (!VidCapPin -> CaptureVideoInfoHeader ()) {
                            Status = STATUS_INSUFFICIENT_RESOURCES;
                        }
                    } else {
                        //
                        // Because we don't accept dynamic format changes, we
                        // should never get here.  Just being over-protective.
                        //
                        Status = STATUS_INVALID_DEVICE_STATE;
                    }
    
                }
    
            }
    
        }

    }
    
    return Status;

}

/*************************************************/


NTSTATUS
CVideoCapturePin::
Pause (
    IN KSSTATE FromState
    )

/*++

Routine Description:

    Called when the pin transitions into the pause state.  If we're in an 
    upward transition, start the capture DPC.  Note that we do not actually
    trigger capture in the pause state, but we start up our DPC.

Arguments:

    FromState -
        The state that the pin is transitioning away from.  This is either
        KSSTATE_ACQUIRE, indicating an upward transition, or KSSTATE_RUN,
        indicating a downward transition.

Return Value:

    STATUS_SUCCESS

--*/

{

    PAGED_CODE();

    //
    // On the transition from acquire -> pause, start the timer DPC running.
    //
    if (FromState == KSSTATE_ACQUIRE) {
        m_ParentFilter -> StartDPC (m_VideoInfoHeader -> AvgTimePerFrame);
    }

    return STATUS_SUCCESS;

}

/*************************************************/


NTSTATUS
CVideoCapturePin::
Acquire (
    IN KSSTATE FromState
    )

/*++

Routine Description:

    This is called from the base class when the video capture pin transitions
    into the acquire state (from either Stop or Pause).  The state the pin
    transitioned from is passed in.

    During this phase, the video capture pin creates the image synthesizer
    and initializes it.

Arguments:

    FromState -
        The state transitioning from (KSSTATE_STOP or KSSTATE_PAUSE)

Return Value:

    Success / Failure

--*/

{

    PAGED_CODE();

    ASSERT (m_VideoInfoHeader);

    NTSTATUS Status = STATUS_SUCCESS;

    if (FromState == KSSTATE_STOP) {

        m_SynthesisBuffer = reinterpret_cast <PUCHAR> (
            ExAllocatePool (
                NonPagedPool, 
                m_VideoInfoHeader -> bmiHeader.biSizeImage
                )
            );

        if (!m_SynthesisBuffer) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        } else {
            //
            // Determine the necessary type of image synthesizer to create 
            // based on the format that has been set on this pin.
            //
            if (m_VideoInfoHeader -> bmiHeader.biBitCount == 24 &&
                m_VideoInfoHeader -> bmiHeader.biCompression == KS_BI_RGB) {
        
                //
                // If we're RGB24, create a new RGB24 synth.  RGB24 surfaces
                // can be in either orientation.  The origin is lower left if
                // height < 0.  Otherwise, it's upper left.
                //
                m_ImageSynth = new (NonPagedPool, 'RysI')
                    CRGB24Synthesizer (
                        m_VideoInfoHeader -> bmiHeader.biHeight >= 0,
                        m_VideoInfoHeader -> bmiHeader.biWidth,
                        ABS (m_VideoInfoHeader -> bmiHeader.biHeight)
                        );
        
            } else
            if (m_VideoInfoHeader -> bmiHeader.biBitCount == 16 &&
                m_VideoInfoHeader -> bmiHeader.biCompression == FOURCC_YUV422) {
        
                //
                // If we're UYVY, create the YUV synth.
                //
                m_ImageSynth = new (NonPagedPool, 'YysI') CYUVSynthesizer (
                    m_VideoInfoHeader -> bmiHeader.biWidth,
                    m_VideoInfoHeader -> bmiHeader.biHeight
                    );
        
            } else
                //
                // We don't synthesize anything but RGB 24 and UYVY.
                //
                Status = STATUS_INVALID_PARAMETER;
        
            if (NT_SUCCESS (Status) && !m_ImageSynth) {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }

        }
    
        //
        // Bag the image synthesizer.
        //
        if (NT_SUCCESS (Status)) {
            
            Status = KsAddItemToObjectBag (
                m_Pin -> Bag,
                m_ImageSynth,
                reinterpret_cast <PFNKSFREE> (CVideoCapturePin::CleanupSynth)
                );
    
        }

        //
        // If everything is okay at this point, inform the synthesizer of
        // the scratch buffer.
        //
        if (NT_SUCCESS (Status)) {
            m_ImageSynth -> SetBuffer (m_SynthesisBuffer);
        }

    } else {

        //
        // The only other state we can come from is pause.  If we're in a
        // downward state transition below pause, tell the filter to stop the
        // capture DPC.
        //
        m_ParentFilter -> StopDPC ();

    }

    return Status;

}

/*************************************************/


NTSTATUS
CVideoCapturePin::
Stop (
    IN KSSTATE FromState
    )

/*++

Routine Description:

    Called when the video capture pin transitions from acquire to stop.
    This function will clean up the image synth and any data structures
    that we need to clean up on stop.

Arguments:

    FromState -
        The state the pin is transitioning away from.  This should
        always be KSSTATE_ACQUIRE for this call.

Return Value:

    STATUS_SUCCESS

--*/

{
    PAGED_CODE();

    ASSERT (FromState == KSSTATE_ACQUIRE);

    //
    // Remove the image synthesizer from the object bag and free it.
    //
    KsRemoveItemFromObjectBag (
        m_Pin -> Bag,
        m_ImageSynth,
        TRUE
        );

    m_ImageSynth = NULL;

    if (m_SynthesisBuffer) {
        ExFreePool (m_SynthesisBuffer);
        m_SynthesisBuffer = NULL;
    }

    return STATUS_SUCCESS;

}

/**************************************************************************

    LOCKED CODE

**************************************************************************/

#ifdef ALLOC_PRAGMA
#pragma code_seg()
#endif // ALLOC_PRAGMA


NTSTATUS
CVideoCapturePin::
CaptureFrame (
    IN PKSPROCESSPIN ProcessPin,
    IN ULONG Tick
    )

/*++

Routine Description:

    This routine is called from the filter processing function to capture
    a frame for the video capture pin.  The process pin to capture to is
    passed.

Arguments:

    ProcessPin -
        The process pin associated with this pin.

    Tick -
        The tick count on the filter.  This is the number of timer DPC's that
        have fired since the timer DPC started.

Return Value:

    STATUS_SUCCESS

--*/

{

    ASSERT (ProcessPin -> Pin == m_Pin);

    //
    // Increment the frame number.  This is the total count of frames which
    // have attempted capture.
    //
    m_FrameNumber++;

    //
    // Since this pin is KSPIN_FLAG_FRAMES_NOT_REQUIRED_FOR_PROCESSING, it
    // means that we do not require frames available in order to process.
    // This means that this routine can get called from our DPC with no
    // buffers available to capture into.  In this case, we increment our
    // dropped frame counter and do nothing.
    //
    if (ProcessPin -> BytesAvailable) {

        //
        // Because we adjusted the allocator framing, each frame should be
        // sufficient to trigger capture of the appropriate buffer size.
        //
        ASSERT (ProcessPin -> BytesAvailable >= 
            m_VideoInfoHeader -> bmiHeader.biSizeImage);

        //
        // If we get an invalid buffer, kick it out.
        //
        if (ProcessPin -> BytesAvailable < 
            m_VideoInfoHeader -> bmiHeader.biSizeImage) {

            ProcessPin -> BytesUsed = 0;
            ProcessPin -> Terminate = TRUE;
            m_DroppedFrames++;
            return STATUS_SUCCESS;
        }

        //
        // Generate a synthesized image.
        //
        m_ImageSynth -> SynthesizeBars ();

        //
        // Overlay some activity onto the bars.
        //
        ULONG DropLength = (Tick * 2) % 
            (ABS (m_VideoInfoHeader -> bmiHeader.biHeight));
    
        //
        // Create a drop flowing down DropLength lines from the top of the 
        // image.
        //
        m_ImageSynth -> Fill (
            0, 0, 
            m_VideoInfoHeader -> bmiHeader.biWidth - 1, DropLength, 
            GREEN
            );

        //
        // Overlay the dropped frame count over the image.
        //
        char Text [256];
        sprintf (Text, "Video Skipped: %ld", m_DroppedFrames);

        m_ImageSynth -> OverlayText (
            10,
            10,
            1,
            Text,
            TRANSPARENT,
            BLUE
            );

        //
        // This is used to indicate that there is no audio pin.
        //
        if (m_NotifyAudDrop != (ULONG)-1) {
            sprintf (Text, "Audio Skipped: %ld", m_NotifyAudDrop);

            m_ImageSynth -> OverlayText (
                10,
                20,
                1,
                Text,
                TRANSPARENT,
                BLUE
                );
        }

        //
        // Copy the synthesized image into the buffer.
        //
        RtlCopyMemory (
            ProcessPin -> Data,
            m_SynthesisBuffer,
            m_VideoInfoHeader -> bmiHeader.biSizeImage
            );
        
        ProcessPin -> BytesUsed = m_VideoInfoHeader -> bmiHeader.biSizeImage;
        ProcessPin -> Terminate = TRUE;


        PKSSTREAM_HEADER StreamHeader = 
            ProcessPin -> StreamPointer -> StreamHeader;

        //
        // If there is a clock assigned to the pin, time stamp the sample.
        //
        if (m_Clock) {

            StreamHeader -> PresentationTime.Time = GetTime ();
            StreamHeader -> Duration = m_VideoInfoHeader -> AvgTimePerFrame;

            StreamHeader -> OptionsFlags =
                KSSTREAM_HEADER_OPTIONSF_TIMEVALID |
                KSSTREAM_HEADER_OPTIONSF_DURATIONVALID;

        }

        //
        // Update the extended header info.
        //
        ASSERT (StreamHeader -> Size >= sizeof (KSSTREAM_HEADER) +
            sizeof (KS_FRAME_INFO));

        //
        // Double check the Stream Header size.  AVStream makes no guarantee
        // that because StreamHeaderSize is set to a specific size that you
        // will get that size.  If the proper data type handlers are not 
        // installed, the stream header will be of default size.
        //
        if (StreamHeader -> Size >= sizeof (KSSTREAM_HEADER) +
            sizeof (KS_FRAME_INFO)) {

            PKS_FRAME_INFO FrameInfo = reinterpret_cast <PKS_FRAME_INFO> (
                StreamHeader + 1
                );
    
            FrameInfo -> ExtendedHeaderSize = sizeof (KS_FRAME_INFO);
            FrameInfo -> PictureNumber = (LONGLONG)m_FrameNumber;
            FrameInfo -> DropCount = (LONGLONG)m_DroppedFrames;

        }
    
    } else {
        m_DroppedFrames++;
    }

    return STATUS_SUCCESS;
        
}

/**************************************************************************

    DESCRIPTOR AND DISPATCH LAYOUT

**************************************************************************/

#define D_X 320
#define D_Y 240

//
// FormatRGB24Bpp_Capture:
//
// This is the data range description of the RGB24 capture format we support.
//
const 
KS_DATARANGE_VIDEO 
FormatRGB24Bpp_Capture = {

    //
    // KSDATARANGE
    //
    {   
        sizeof (KS_DATARANGE_VIDEO),                // FormatSize
        0,                                          // Flags
        D_X * D_Y * 3,                              // SampleSize
        0,                                          // Reserved

        STATICGUIDOF (KSDATAFORMAT_TYPE_VIDEO),     // aka. MEDIATYPE_Video
        0xe436eb7d, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 
            0xaf, 0x0b, 0xa7, 0x70,                 // aka. MEDIASUBTYPE_RGB24,
        STATICGUIDOF (KSDATAFORMAT_SPECIFIER_VIDEOINFO) // aka. FORMAT_VideoInfo
    },

    TRUE,               // BOOL,  bFixedSizeSamples (all samples same size?)
    TRUE,               // BOOL,  bTemporalCompression (all I frames?)
    0,                  // Reserved (was StreamDescriptionFlags)
    0,                  // Reserved (was MemoryAllocationFlags   
                        //           (KS_VIDEO_ALLOC_*))

    //
    // _KS_VIDEO_STREAM_CONFIG_CAPS  
    //
    {
        STATICGUIDOF( KSDATAFORMAT_SPECIFIER_VIDEOINFO ), // GUID
        KS_AnalogVideo_NTSC_M |
        KS_AnalogVideo_PAL_B,                    // AnalogVideoStandard
        720,480,        // InputSize, (the inherent size of the incoming signal
                        //             with every digitized pixel unique)
        160,120,        // MinCroppingSize, smallest rcSrc cropping rect allowed
        720,480,        // MaxCroppingSize, largest  rcSrc cropping rect allowed
        8,              // CropGranularityX, granularity of cropping size
        1,              // CropGranularityY
        8,              // CropAlignX, alignment of cropping rect 
        1,              // CropAlignY;
        160, 120,       // MinOutputSize, smallest bitmap stream can produce
        720, 480,       // MaxOutputSize, largest  bitmap stream can produce
        8,              // OutputGranularityX, granularity of output bitmap size
        1,              // OutputGranularityY;
        0,              // StretchTapsX  (0 no stretch, 1 pix dup, 2 interp...)
        0,              // StretchTapsY
        0,              // ShrinkTapsX 
        0,              // ShrinkTapsY 
        333667,         // MinFrameInterval, 100 nS units
        640000000,      // MaxFrameInterval, 100 nS units
        8 * 3 * 30 * 160 * 120,  // MinBitsPerSecond;
        8 * 3 * 30 * 720 * 480   // MaxBitsPerSecond;
    }, 
        
    //
    // KS_VIDEOINFOHEADER (default format)
    //
    {
        0,0,0,0,                            // RECT  rcSource; 
        0,0,0,0,                            // RECT  rcTarget; 
        D_X * D_Y * 3 * 30,                 // DWORD dwBitRate;
        0L,                                 // DWORD dwBitErrorRate; 
        333667,                             // REFERENCE_TIME  AvgTimePerFrame;   
        sizeof (KS_BITMAPINFOHEADER),       // DWORD biSize;
        D_X,                                // LONG  biWidth;
        -D_Y,                               // LONG  biHeight;
        1,                                  // WORD  biPlanes;
        24,                                 // WORD  biBitCount;
        KS_BI_RGB,                          // DWORD biCompression;
        D_X * D_Y * 3,                      // DWORD biSizeImage;
        0,                                  // LONG  biXPelsPerMeter;
        0,                                  // LONG  biYPelsPerMeter;
        0,                                  // DWORD biClrUsed;
        0                                   // DWORD biClrImportant;
    }
}; 

#undef D_X
#undef D_Y

#define D_X 320
#define D_Y 240

//
// FormatUYU2_Capture:
//
// This is the data range description of the UYVY format we support.
//
const 
KS_DATARANGE_VIDEO 
FormatUYU2_Capture = {

    //
    // KSDATARANGE
    //
    {   
        sizeof (KS_DATARANGE_VIDEO),            // FormatSize
        0,                                      // Flags
        D_X * D_Y * 2,                          // SampleSize
        0,                                      // Reserved
        STATICGUIDOF (KSDATAFORMAT_TYPE_VIDEO), // aka. MEDIATYPE_Video
        0x59565955, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 
            0x00, 0x38, 0x9b, 0x71,             // aka. MEDIASUBTYPE_UYVY,
        STATICGUIDOF (KSDATAFORMAT_SPECIFIER_VIDEOINFO) // aka. FORMAT_VideoInfo
    },

    TRUE,               // BOOL,  bFixedSizeSamples (all samples same size?)
    TRUE,               // BOOL,  bTemporalCompression (all I frames?)
    0,                  // Reserved (was StreamDescriptionFlags)
    0,                  // Reserved (was MemoryAllocationFlags   
                        //           (KS_VIDEO_ALLOC_*))

    //
    // _KS_VIDEO_STREAM_CONFIG_CAPS  
    //
    {
        STATICGUIDOF( KSDATAFORMAT_SPECIFIER_VIDEOINFO ), // GUID
        KS_AnalogVideo_NTSC_M |
        KS_AnalogVideo_PAL_B,                    // AnalogVideoStandard
        720,480,        // InputSize, (the inherent size of the incoming signal
                    //             with every digitized pixel unique)
        160,120,        // MinCroppingSize, smallest rcSrc cropping rect allowed
        720,480,        // MaxCroppingSize, largest  rcSrc cropping rect allowed
        8,              // CropGranularityX, granularity of cropping size
        1,              // CropGranularityY
        8,              // CropAlignX, alignment of cropping rect 
        1,              // CropAlignY;
        160, 120,       // MinOutputSize, smallest bitmap stream can produce
        720, 480,       // MaxOutputSize, largest  bitmap stream can produce
        8,              // OutputGranularityX, granularity of output bitmap size
        1,              // OutputGranularityY;
        0,              // StretchTapsX  (0 no stretch, 1 pix dup, 2 interp...)
        0,              // StretchTapsY
        0,              // ShrinkTapsX 
        0,              // ShrinkTapsY 
        333667,         // MinFrameInterval, 100 nS units
        640000000,      // MaxFrameInterval, 100 nS units
        8 * 2 * 30 * 160 * 120,  // MinBitsPerSecond;
        8 * 2 * 30 * 720 * 480   // MaxBitsPerSecond;
    }, 
        
    //
    // KS_VIDEOINFOHEADER (default format)
    //
    {
        0,0,0,0,                            // RECT  rcSource; 
        0,0,0,0,                            // RECT  rcTarget; 
        D_X * D_Y * 2 * 30,                 // DWORD dwBitRate;
        0L,                                 // DWORD dwBitErrorRate; 
        333667,                             // REFERENCE_TIME  AvgTimePerFrame;   
        sizeof (KS_BITMAPINFOHEADER),       // DWORD biSize;
        D_X,                                // LONG  biWidth;
        D_Y,                                // LONG  biHeight;
        1,                                  // WORD  biPlanes;
        16,                                 // WORD  biBitCount;
        FOURCC_YUV422,                      // DWORD biCompression;
        D_X * D_Y * 2,                      // DWORD biSizeImage;
        0,                                  // LONG  biXPelsPerMeter;
        0,                                  // LONG  biYPelsPerMeter;
        0,                                  // DWORD biClrUsed;
        0                                   // DWORD biClrImportant;
    }
}; 

//
// VideoCapturePinDispatch:
//
// This is the dispatch table for the capture pin.  It provides notifications
// about creation, closure, processing, data formats, etc...
//
const
KSPIN_DISPATCH
VideoCapturePinDispatch = {
    CVideoCapturePin::DispatchCreate,       // Pin Create
    NULL,                                   // Pin Close
    NULL,                                   // Pin Process
    NULL,                                   // Pin Reset
    CVideoCapturePin::DispatchSetFormat,    // Pin Set Data Format
    CCapturePin::DispatchSetState,          // Pin Set Device State
    NULL,                                   // Pin Connect
    NULL,                                   // Pin Disconnect
    NULL,                                   // Clock Dispatch
    NULL                                    // Allocator Dispatch
};

//
// VideoCapturePinAllocatorFraming:
//
// This is the simple framing structure for the capture pin.  Note that this
// will be modified via KsEdit when the actual capture format is determined.
//
DECLARE_SIMPLE_FRAMING_EX (
    VideoCapturePinAllocatorFraming,
    STATICGUIDOF (KSMEMORY_TYPE_KERNEL_NONPAGED),
    KSALLOCATOR_REQUIREMENTF_SYSTEM_MEMORY |
        KSALLOCATOR_REQUIREMENTF_PREFERENCES_ONLY,
    2,
    0,
    2 * PAGE_SIZE,
    2 * PAGE_SIZE
    );

//
// VideoCapturePinDataRanges:
//
// This is the list of data ranges supported on the capture pin.  We support
// two: one RGB24, and one UYVY.
//
const 
PKSDATARANGE 
VideoCapturePinDataRanges [CAPTURE_PIN_DATA_RANGE_COUNT] = {
    (PKSDATARANGE) &FormatRGB24Bpp_Capture,
    (PKSDATARANGE) &FormatUYU2_Capture
    };
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\ksfilter\tests\avstest\image.h ===
/**************************************************************************

    AVStream Simulated Hardware Sample

    Copyright (c) 2001, Microsoft Corporation.

    File:

        image.h

    Abstract:

        The image synthesis and overlay header.  These objects provide image
        synthesis (pixel, color-bar, etc...) onto RGB24 and UYVY buffers as
        well as software string overlay into these buffers.

    History:

        created 1/16/2001

**************************************************************************/

/**************************************************************************

    Constants

**************************************************************************/

//
// COLOR:
//
// Pixel color for placement onto the synthesis buffer.
//
typedef enum {

    BLACK = 0,
    WHITE,
    YELLOW,
    CYAN,
    GREEN,
    MAGENTA,
    RED,
    BLUE,
    GREY,

    MAX_COLOR,
    TRANSPARENT,

} COLOR;

//
// POSITION_CENTER:
//
// Only useful for text overlay.  This can be substituted for LocX or LocY
// in order to center the text screen on the synthesis buffer.
//
#define POSITION_CENTER ((ULONG)-1)

/*************************************************

    CImageSynthesizer

    This class synthesizes images in various formats for output from the
    capture filter.  It is capable of performing various text overlays onto
    the image surface.

*************************************************/

class CImageSynthesizer {

protected:

    //
    // The width and height the synthesizer is set to. 
    //
    ULONG m_Width;
    ULONG m_Height;

    //
    // The synthesis buffer.  All scan conversion happens in the synthesis
    // buffer.  This must be set with SetBuffer() before any scan conversion
    // routines are called.
    //
    PUCHAR m_SynthesisBuffer;

    //
    // The default cursor.  This is a pointer into the synthesis buffer where
    // a non specific PutPixel will be placed. 
    //
    PUCHAR m_Cursor;

public:

    //
    // PutPixel():
    //
    // Place a pixel at the specified image cursor and move right
    // by one pixel.  No bounds checking...  wrap around occurs.
    //
    virtual void
    PutPixel (
        PUCHAR *ImageLocation,
        COLOR Color
        ) = 0;

    //
    // PutPixel():
    //
    // Place a pixel at the default image cursor and move right
    // by one pixel.  No bounds checking...  wrap around occurs.
    //
    // If the derived class doesn't provide an implementation, provide
    // one.
    //
    virtual void
    PutPixel (
        COLOR Color
        )
    {
        PutPixel (&m_Cursor, Color);
    }

    //
    // Fill():
    //
    // Fill an area of the image with a specific color.
    //
    virtual void
    Fill (
        IN ULONG X_TopLeft,
        IN ULONG Y_TopLeft,
        IN ULONG X_BottomRight,
        IN ULONG Y_BottomRight,
        IN COLOR Color
        );

    //
    // GetImageLocation():
    //
    // Get the location into the image buffer for a specific X/Y location.
    // This also sets the synthesizer's default cursor to the position
    // LocX, LocY.
    //
    virtual PUCHAR
    GetImageLocation (  
        ULONG LocX,
        ULONG LocY
        ) = 0;

    //
    // SetImageSize():
    //
    // Set the image size of the synthesis buffer.
    //
    void
    SetImageSize (
        ULONG Width,
        ULONG Height
        )
    {
        m_Width = Width;
        m_Height = Height;
    }

    //
    // SetBuffer():
    //
    // Set the buffer the synthesizer generates images to.
    //
    void
    SetBuffer (
        PUCHAR SynthesisBuffer
        )
    {
        m_SynthesisBuffer = SynthesisBuffer;
    }

    //
    // SynthesizeBars():
    //
    // Synthesize EIA-189-A standard color bars.
    //
    void
    SynthesizeBars (
        );

    //
    // OverlayText():
    //
    // Overlay a text string onto the image.
    //
    void
    OverlayText (
        ULONG LocX,
        ULONG LocY,
        ULONG Scaling,
        CHAR *Text,
        COLOR BgColor,
        COLOR FgColor
        );

    //
    // DEFAULT CONSTRUCTOR
    //
    CImageSynthesizer (
        ) :
        m_Width (0),
        m_Height (0),
        m_SynthesisBuffer (NULL)
    {
    }

    //
    // CONSTRUCTOR:
    //
    CImageSynthesizer (
        ULONG Width,
        ULONG Height
        ) :
        m_Width (Width),
        m_Height (Height),
        m_SynthesisBuffer (NULL)
    {
    }

    //
    // DESTRUCTOR:
    //
    virtual
    ~CImageSynthesizer (
        )
    {
    }

};

/*************************************************

    CRGB24Synthesizer

    Image synthesizer for RGB24 format.

*************************************************/

class CRGB24Synthesizer : public CImageSynthesizer {

private:

    const static UCHAR Colors [MAX_COLOR][3];

    BOOLEAN m_FlipVertical;

public:

    //
    // PutPixel():
    //
    // Place a pixel at a specific cursor location.  *ImageLocation must
    // reside within the synthesis buffer.
    //
    virtual void
    PutPixel (
        PUCHAR *ImageLocation,
        COLOR Color
        )
    {
        if (Color != TRANSPARENT) {
            *(*ImageLocation)++ = Colors [(ULONG)Color][0];
            *(*ImageLocation)++ = Colors [(ULONG)Color][1];
            *(*ImageLocation)++ = Colors [(ULONG)Color][2];
        } else {
            *ImageLocation += 3;
        }
    }

    //
    // PutPixel():
    //
    // Place a pixel at the default cursor location.  The cursor location
    // must be set via GetImageLocation(x, y).
    // 
    virtual void
    PutPixel (
        COLOR Color
        )
    {
        if (Color != TRANSPARENT) {
            *m_Cursor++ = Colors [(ULONG)Color][0];
            *m_Cursor++ = Colors [(ULONG)Color][1];
            *m_Cursor++ = Colors [(ULONG)Color][2];
        } else {
            m_Cursor += 3;
        }
    }

    virtual PUCHAR
    GetImageLocation (
        ULONG LocX,
        ULONG LocY
        )
    {
        if (m_FlipVertical) {
            return (m_Cursor = 
                (m_SynthesisBuffer + 3 * 
                    (LocX + (m_Height - 1 - LocY) * m_Width))
                );
        } else {
            return (m_Cursor =
                (m_SynthesisBuffer + 3 * (LocX + LocY * m_Width))
                );
        }
    }

    //
    // DEFAULT CONSTRUCTOR:
    //
    CRGB24Synthesizer (
        BOOLEAN FlipVertical
        ) :
        m_FlipVertical (FlipVertical)
    {
    }

    //
    // CONSTRUCTOR:
    //
    CRGB24Synthesizer (
        BOOLEAN FlipVertical,
        ULONG Width,
        ULONG Height
        ) :
        CImageSynthesizer (Width, Height),
        m_FlipVertical (FlipVertical)
    {
    }

    //
    // DESTRUCTOR:
    //
    virtual
    ~CRGB24Synthesizer (
        )
    {
    }

};

/*************************************************

    CYUVSynthesizer

    Image synthesizer for YUV format.

*************************************************/

class CYUVSynthesizer : public CImageSynthesizer {

private:

    const static UCHAR Colors [MAX_COLOR][3];

    BOOLEAN m_Parity;

public:

    //
    // PutPixel():
    //
    // Place a pixel at a specific cursor location.  *ImageLocation must
    // reside within the synthesis buffer.
    //
    virtual void
    PutPixel (
        PUCHAR *ImageLocation,
        COLOR Color
        )
    {

        BOOLEAN Parity = (((*ImageLocation - m_SynthesisBuffer) & 0x2) != 0);

#if DBG
        //
        // Check that the current pixel points to a valid start pixel
        // in the UYVY buffer.
        //
        BOOLEAN Odd = (((*ImageLocation - m_SynthesisBuffer) & 0x1) != 0);
        ASSERT ((m_Parity && Odd) || (!m_Parity && !Odd));
#endif // DBG

        if (Color != TRANSPARENT) {
            if (Parity) {
                *(*ImageLocation)++ = Colors [(ULONG)Color][1];
            } else {
                *(*ImageLocation)++ = Colors [(ULONG)Color][0];
                *(*ImageLocation)++ = Colors [(ULONG)Color][1];
                *(*ImageLocation)++ = Colors [(ULONG)Color][2];
            }
        } else {
            *ImageLocation += (Parity ? 1 : 3);
        }

    }

    //
    // PutPixel():
    //
    // Place a pixel at the default cursor location.  The cursor location
    // must be set via GetImageLocation(x, y).
    //
    virtual void
    PutPixel (
        COLOR Color
        )

    {

        if (Color != TRANSPARENT) {
            if (m_Parity) {
                *m_Cursor++ = Colors [(ULONG)Color][1];
            } else {
                *m_Cursor++ = Colors [(ULONG)Color][0];
                *m_Cursor++ = Colors [(ULONG)Color][1];
                *m_Cursor++ = Colors [(ULONG)Color][2];
            }
        } else {
            m_Cursor += (m_Parity ? 1 : 3);
        }

        m_Parity = !m_Parity;

    }

    virtual PUCHAR
    GetImageLocation (
        ULONG LocX,
        ULONG LocY
        )
    {
    
        m_Cursor = m_SynthesisBuffer + ((LocX + LocY * m_Width) << 1);
        if (m_Parity = ((LocX & 1) != 0)) 
            m_Cursor++;

        return m_Cursor;
    }

    //
    // DEFAULT CONSTRUCTOR:
    //
    CYUVSynthesizer (
        ) 
    {
    }

    //
    // CONSTRUCTOR:
    //
    CYUVSynthesizer (
        ULONG Width,
        ULONG Height
        ) :
        CImageSynthesizer (Width, Height)
    {
    }

    //
    // DESTRUCTOR:
    //
    virtual
    ~CYUVSynthesizer (
        )
    {
    }

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\ksfilter\tests\avstest\image.cpp ===
/**************************************************************************

    AVStream Simulated Hardware Sample

    Copyright (c) 2001, Microsoft Corporation.

    File:

        image.cpp

    Abstract:

        The image synthesis and overlay code.  These objects provide image
        synthesis (pixel, color-bar, etc...) onto RGB24 and UYVY buffers as
        well as software string overlay into these buffers.

	This entire file, data and all, must be in locked segments.

    History:

        created 1/16/2001

**************************************************************************/

#include "avssamp.h"

/**************************************************************************

    Constants

**************************************************************************/

//
// g_FontData:
//
// The following is an 8x8 bitmapped font for use in the text overlay
// code.
//
UCHAR g_FontData [256][8] = {
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x7e, 0x81, 0xa5, 0x81, 0xbd, 0x99, 0x81, 0x7e},
    {0x7e, 0xff, 0xdb, 0xff, 0xc3, 0xe7, 0xff, 0x7e},
    {0x6c, 0xfe, 0xfe, 0xfe, 0x7c, 0x38, 0x10, 0x00},
    {0x10, 0x38, 0x7c, 0xfe, 0x7c, 0x38, 0x10, 0x00},
    {0x38, 0x7c, 0x38, 0xfe, 0xfe, 0x7c, 0x38, 0x7c},
    {0x10, 0x10, 0x38, 0x7c, 0xfe, 0x7c, 0x38, 0x7c},
    {0x00, 0x00, 0x18, 0x3c, 0x3c, 0x18, 0x00, 0x00},
    {0xff, 0xff, 0xe7, 0xc3, 0xc3, 0xe7, 0xff, 0xff},
    {0x00, 0x3c, 0x66, 0x42, 0x42, 0x66, 0x3c, 0x00},
    {0xff, 0xc3, 0x99, 0xbd, 0xbd, 0x99, 0xc3, 0xff},
    {0x0f, 0x07, 0x0f, 0x7d, 0xcc, 0xcc, 0xcc, 0x78},
    {0x3c, 0x66, 0x66, 0x66, 0x3c, 0x18, 0x7e, 0x18},
    {0x3f, 0x33, 0x3f, 0x30, 0x30, 0x70, 0xf0, 0xe0},
    {0x7f, 0x63, 0x7f, 0x63, 0x63, 0x67, 0xe6, 0xc0},
    {0x99, 0x5a, 0x3c, 0xe7, 0xe7, 0x3c, 0x5a, 0x99},
    {0x80, 0xe0, 0xf8, 0xfe, 0xf8, 0xe0, 0x80, 0x00},
    {0x02, 0x0e, 0x3e, 0xfe, 0x3e, 0x0e, 0x02, 0x00},
    {0x18, 0x3c, 0x7e, 0x18, 0x18, 0x7e, 0x3c, 0x18},
    {0x66, 0x66, 0x66, 0x66, 0x66, 0x00, 0x66, 0x00},
    {0x7f, 0xdb, 0xdb, 0x7b, 0x1b, 0x1b, 0x1b, 0x00},
    {0x3e, 0x63, 0x38, 0x6c, 0x6c, 0x38, 0xcc, 0x78},
    {0x00, 0x00, 0x00, 0x00, 0x7e, 0x7e, 0x7e, 0x00},
    {0x18, 0x3c, 0x7e, 0x18, 0x7e, 0x3c, 0x18, 0xff},
    {0x18, 0x3c, 0x7e, 0x18, 0x18, 0x18, 0x18, 0x00},
    {0x18, 0x18, 0x18, 0x18, 0x7e, 0x3c, 0x18, 0x00},
    {0x00, 0x18, 0x0c, 0xfe, 0x0c, 0x18, 0x00, 0x00},
    {0x00, 0x30, 0x60, 0xfe, 0x60, 0x30, 0x00, 0x00},
    {0x00, 0x00, 0xc0, 0xc0, 0xc0, 0xfe, 0x00, 0x00},
    {0x00, 0x24, 0x66, 0xff, 0x66, 0x24, 0x00, 0x00},
    {0x00, 0x18, 0x3c, 0x7e, 0xff, 0xff, 0x00, 0x00},
    {0x00, 0xff, 0xff, 0x7e, 0x3c, 0x18, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x30, 0x78, 0x78, 0x30, 0x30, 0x00, 0x30, 0x00},
    {0x6c, 0x6c, 0x6c, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x6c, 0x6c, 0xfe, 0x6c, 0xfe, 0x6c, 0x6c, 0x00},
    {0x30, 0x7c, 0xc0, 0x78, 0x0c, 0xf8, 0x30, 0x00},
    {0x00, 0xc6, 0xcc, 0x18, 0x30, 0x66, 0xc6, 0x00},
    {0x38, 0x6c, 0x38, 0x76, 0xdc, 0xcc, 0x76, 0x00},
    {0x60, 0x60, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x18, 0x30, 0x60, 0x60, 0x60, 0x30, 0x18, 0x00},
    {0x60, 0x30, 0x18, 0x18, 0x18, 0x30, 0x60, 0x00},
    {0x00, 0x66, 0x3c, 0xff, 0x3c, 0x66, 0x00, 0x00},
    {0x00, 0x30, 0x30, 0xfc, 0x30, 0x30, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x60},
    {0x00, 0x00, 0x00, 0xfc, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x00},
    {0x06, 0x0c, 0x18, 0x30, 0x60, 0xc0, 0x80, 0x00},
    {0x7c, 0xc6, 0xce, 0xde, 0xf6, 0xe6, 0x7c, 0x00},
    {0x30, 0x70, 0x30, 0x30, 0x30, 0x30, 0xfc, 0x00},
    {0x78, 0xcc, 0x0c, 0x38, 0x60, 0xcc, 0xfc, 0x00},
    {0x78, 0xcc, 0x0c, 0x38, 0x0c, 0xcc, 0x78, 0x00},
    {0x1c, 0x3c, 0x6c, 0xcc, 0xfe, 0x0c, 0x1e, 0x00},
    {0xfc, 0xc0, 0xf8, 0x0c, 0x0c, 0xcc, 0x78, 0x00},
    {0x38, 0x60, 0xc0, 0xf8, 0xcc, 0xcc, 0x78, 0x00},
    {0xfc, 0xcc, 0x0c, 0x18, 0x30, 0x30, 0x30, 0x00},
    {0x78, 0xcc, 0xcc, 0x78, 0xcc, 0xcc, 0x78, 0x00},
    {0x78, 0xcc, 0xcc, 0x7c, 0x0c, 0x18, 0x70, 0x00},
    {0x00, 0x30, 0x30, 0x00, 0x00, 0x30, 0x30, 0x00},
    {0x00, 0x30, 0x30, 0x00, 0x00, 0x30, 0x30, 0x60},
    {0x18, 0x30, 0x60, 0xc0, 0x60, 0x30, 0x18, 0x00},
    {0x00, 0x00, 0xfc, 0x00, 0x00, 0xfc, 0x00, 0x00},
    {0x60, 0x30, 0x18, 0x0c, 0x18, 0x30, 0x60, 0x00},
    {0x78, 0xcc, 0x0c, 0x18, 0x30, 0x00, 0x30, 0x00},
    {0x7c, 0xc6, 0xde, 0xde, 0xde, 0xc0, 0x78, 0x00},
    {0x30, 0x78, 0xcc, 0xcc, 0xfc, 0xcc, 0xcc, 0x00},
    {0xfc, 0x66, 0x66, 0x7c, 0x66, 0x66, 0xfc, 0x00},
    {0x3c, 0x66, 0xc0, 0xc0, 0xc0, 0x66, 0x3c, 0x00},
    {0xf8, 0x6c, 0x66, 0x66, 0x66, 0x6c, 0xf8, 0x00},
    {0xfe, 0x62, 0x68, 0x78, 0x68, 0x62, 0xfe, 0x00},
    {0xfe, 0x62, 0x68, 0x78, 0x68, 0x60, 0xf0, 0x00},
    {0x3c, 0x66, 0xc0, 0xc0, 0xce, 0x66, 0x3e, 0x00},
    {0xcc, 0xcc, 0xcc, 0xfc, 0xcc, 0xcc, 0xcc, 0x00},
    {0x78, 0x30, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00},
    {0x1e, 0x0c, 0x0c, 0x0c, 0xcc, 0xcc, 0x78, 0x00},
    {0xe6, 0x66, 0x6c, 0x78, 0x6c, 0x66, 0xe6, 0x00},
    {0xf0, 0x60, 0x60, 0x60, 0x62, 0x66, 0xfe, 0x00},
    {0xc6, 0xee, 0xfe, 0xfe, 0xd6, 0xc6, 0xc6, 0x00},
    {0xc6, 0xe6, 0xf6, 0xde, 0xce, 0xc6, 0xc6, 0x00},
    {0x38, 0x6c, 0xc6, 0xc6, 0xc6, 0x6c, 0x38, 0x00},
    {0xfc, 0x66, 0x66, 0x7c, 0x60, 0x60, 0xf0, 0x00},
    {0x78, 0xcc, 0xcc, 0xcc, 0xdc, 0x78, 0x1c, 0x00},
    {0xfc, 0x66, 0x66, 0x7c, 0x6c, 0x66, 0xe6, 0x00},
    {0x78, 0xcc, 0xe0, 0x70, 0x1c, 0xcc, 0x78, 0x00},
    {0xfc, 0xb4, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00},
    {0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xfc, 0x00},
    {0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0x78, 0x30, 0x00},
    {0xc6, 0xc6, 0xc6, 0xd6, 0xfe, 0xee, 0xc6, 0x00},
    {0xc6, 0xc6, 0x6c, 0x38, 0x38, 0x6c, 0xc6, 0x00},
    {0xcc, 0xcc, 0xcc, 0x78, 0x30, 0x30, 0x78, 0x00},
    {0xfe, 0xc6, 0x8c, 0x18, 0x32, 0x66, 0xfe, 0x00},
    {0x78, 0x60, 0x60, 0x60, 0x60, 0x60, 0x78, 0x00},
    {0xc0, 0x60, 0x30, 0x18, 0x0c, 0x06, 0x02, 0x00},
    {0x78, 0x18, 0x18, 0x18, 0x18, 0x18, 0x78, 0x00},
    {0x10, 0x38, 0x6c, 0xc6, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff},
    {0x30, 0x30, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x78, 0x0c, 0x7c, 0xcc, 0x76, 0x00},
    {0xe0, 0x60, 0x60, 0x7c, 0x66, 0x66, 0xdc, 0x00},
    {0x00, 0x00, 0x78, 0xcc, 0xc0, 0xcc, 0x78, 0x00},
    {0x1c, 0x0c, 0x0c, 0x7c, 0xcc, 0xcc, 0x76, 0x00},
    {0x00, 0x00, 0x78, 0xcc, 0xfc, 0xc0, 0x78, 0x00},
    {0x38, 0x6c, 0x60, 0xf0, 0x60, 0x60, 0xf0, 0x00},
    {0x00, 0x00, 0x76, 0xcc, 0xcc, 0x7c, 0x0c, 0xf8},
    {0xe0, 0x60, 0x6c, 0x76, 0x66, 0x66, 0xe6, 0x00},
    {0x30, 0x00, 0x70, 0x30, 0x30, 0x30, 0x78, 0x00},
    {0x0c, 0x00, 0x0c, 0x0c, 0x0c, 0xcc, 0xcc, 0x78},
    {0xe0, 0x60, 0x66, 0x6c, 0x78, 0x6c, 0xe6, 0x00},
    {0x70, 0x30, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00},
    {0x00, 0x00, 0xcc, 0xfe, 0xfe, 0xd6, 0xc6, 0x00},
    {0x00, 0x00, 0xf8, 0xcc, 0xcc, 0xcc, 0xcc, 0x00},
    {0x00, 0x00, 0x78, 0xcc, 0xcc, 0xcc, 0x78, 0x00},
    {0x00, 0x00, 0xdc, 0x66, 0x66, 0x7c, 0x60, 0xf0},
    {0x00, 0x00, 0x76, 0xcc, 0xcc, 0x7c, 0x0c, 0x1e},
    {0x00, 0x00, 0xdc, 0x76, 0x66, 0x60, 0xf0, 0x00},
    {0x00, 0x00, 0x7c, 0xc0, 0x78, 0x0c, 0xf8, 0x00},
    {0x10, 0x30, 0x7c, 0x30, 0x30, 0x34, 0x18, 0x00},
    {0x00, 0x00, 0xcc, 0xcc, 0xcc, 0xcc, 0x76, 0x00},
    {0x00, 0x00, 0xcc, 0xcc, 0xcc, 0x78, 0x30, 0x00},
    {0x00, 0x00, 0xc6, 0xd6, 0xfe, 0xfe, 0x6c, 0x00},
    {0x00, 0x00, 0xc6, 0x6c, 0x38, 0x6c, 0xc6, 0x00},
    {0x00, 0x00, 0xcc, 0xcc, 0xcc, 0x7c, 0x0c, 0xf8},
    {0x00, 0x00, 0xfc, 0x98, 0x30, 0x64, 0xfc, 0x00},
    {0x1c, 0x30, 0x30, 0xe0, 0x30, 0x30, 0x1c, 0x00},
    {0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x00},
    {0xe0, 0x30, 0x30, 0x1c, 0x30, 0x30, 0xe0, 0x00},
    {0x76, 0xdc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x10, 0x38, 0x6c, 0xc6, 0xc6, 0xfe, 0x00},
    {0x78, 0xcc, 0xc0, 0xcc, 0x78, 0x18, 0x0c, 0x78},
    {0x00, 0xcc, 0x00, 0xcc, 0xcc, 0xcc, 0x7e, 0x00},
    {0x1c, 0x00, 0x78, 0xcc, 0xfc, 0xc0, 0x78, 0x00},
    {0x7e, 0xc3, 0x3c, 0x06, 0x3e, 0x66, 0x3f, 0x00},
    {0xcc, 0x00, 0x78, 0x0c, 0x7c, 0xcc, 0x7e, 0x00},
    {0xe0, 0x00, 0x78, 0x0c, 0x7c, 0xcc, 0x7e, 0x00},
    {0x30, 0x30, 0x78, 0x0c, 0x7c, 0xcc, 0x7e, 0x00},
    {0x00, 0x00, 0x78, 0xc0, 0xc0, 0x78, 0x0c, 0x38},
    {0x7e, 0xc3, 0x3c, 0x66, 0x7e, 0x60, 0x3c, 0x00},
    {0xcc, 0x00, 0x78, 0xcc, 0xfc, 0xc0, 0x78, 0x00},
    {0xe0, 0x00, 0x78, 0xcc, 0xfc, 0xc0, 0x78, 0x00},
    {0xcc, 0x00, 0x70, 0x30, 0x30, 0x30, 0x78, 0x00},
    {0x7c, 0xc6, 0x38, 0x18, 0x18, 0x18, 0x3c, 0x00},
    {0xe0, 0x00, 0x70, 0x30, 0x30, 0x30, 0x78, 0x00},
    {0xc6, 0x38, 0x6c, 0xc6, 0xfe, 0xc6, 0xc6, 0x00},
    {0x30, 0x30, 0x00, 0x78, 0xcc, 0xfc, 0xcc, 0x00},
    {0x1c, 0x00, 0xfc, 0x60, 0x78, 0x60, 0xfc, 0x00},
    {0x00, 0x00, 0x7f, 0x0c, 0x7f, 0xcc, 0x7f, 0x00},
    {0x3e, 0x6c, 0xcc, 0xfe, 0xcc, 0xcc, 0xce, 0x00},
    {0x78, 0xcc, 0x00, 0x78, 0xcc, 0xcc, 0x78, 0x00},
    {0x00, 0xcc, 0x00, 0x78, 0xcc, 0xcc, 0x78, 0x00},
    {0x00, 0xe0, 0x00, 0x78, 0xcc, 0xcc, 0x78, 0x00},
    {0x78, 0xcc, 0x00, 0xcc, 0xcc, 0xcc, 0x7e, 0x00},
    {0x00, 0xe0, 0x00, 0xcc, 0xcc, 0xcc, 0x7e, 0x00},
    {0x00, 0xcc, 0x00, 0xcc, 0xcc, 0x7c, 0x0c, 0xf8},
    {0xc3, 0x18, 0x3c, 0x66, 0x66, 0x3c, 0x18, 0x00},
    {0xcc, 0x00, 0xcc, 0xcc, 0xcc, 0xcc, 0x78, 0x00},
    {0x18, 0x18, 0x7e, 0xc0, 0xc0, 0x7e, 0x18, 0x18},
    {0x38, 0x6c, 0x64, 0xf0, 0x60, 0xe6, 0xfc, 0x00},
    {0xcc, 0xcc, 0x78, 0xfc, 0x30, 0xfc, 0x30, 0x30},
    {0xf8, 0xcc, 0xcc, 0xfa, 0xc6, 0xcf, 0xc6, 0xc7},
    {0x0e, 0x1b, 0x18, 0x3c, 0x18, 0x18, 0xd8, 0x70},
    {0x1c, 0x00, 0x78, 0x0c, 0x7c, 0xcc, 0x7e, 0x00},
    {0x38, 0x00, 0x70, 0x30, 0x30, 0x30, 0x78, 0x00},
    {0x00, 0x1c, 0x00, 0x78, 0xcc, 0xcc, 0x78, 0x00},
    {0x00, 0x1c, 0x00, 0xcc, 0xcc, 0xcc, 0x7e, 0x00},
    {0x00, 0xf8, 0x00, 0xf8, 0xcc, 0xcc, 0xcc, 0x00},
    {0xfc, 0x00, 0xcc, 0xec, 0xfc, 0xdc, 0xcc, 0x00},
    {0x3c, 0x6c, 0x6c, 0x3e, 0x00, 0x7e, 0x00, 0x00},
    {0x38, 0x6c, 0x6c, 0x38, 0x00, 0x7c, 0x00, 0x00},
    {0x30, 0x00, 0x30, 0x60, 0xc0, 0xcc, 0x78, 0x00},
    {0x00, 0x00, 0x00, 0xfc, 0xc0, 0xc0, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0xfc, 0x0c, 0x0c, 0x00, 0x00},
    {0xc3, 0xc6, 0xcc, 0xde, 0x33, 0x66, 0xcc, 0x0f},
    {0xc3, 0xc6, 0xcc, 0xdb, 0x37, 0x6f, 0xcf, 0x03},
    {0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x18, 0x00},
    {0x00, 0x33, 0x66, 0xcc, 0x66, 0x33, 0x00, 0x00},
    {0x00, 0xcc, 0x66, 0x33, 0x66, 0xcc, 0x00, 0x00},
    {0x22, 0x88, 0x22, 0x88, 0x22, 0x88, 0x22, 0x88},
    {0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa},
    {0xdb, 0x77, 0xdb, 0xee, 0xdb, 0x77, 0xdb, 0xee},
    {0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18},
    {0x18, 0x18, 0x18, 0x18, 0xf8, 0x18, 0x18, 0x18},
    {0x18, 0x18, 0xf8, 0x18, 0xf8, 0x18, 0x18, 0x18},
    {0x36, 0x36, 0x36, 0x36, 0xf6, 0x36, 0x36, 0x36},
    {0x00, 0x00, 0x00, 0x00, 0xfe, 0x36, 0x36, 0x36},
    {0x00, 0x00, 0xf8, 0x18, 0xf8, 0x18, 0x18, 0x18},
    {0x36, 0x36, 0xf6, 0x06, 0xf6, 0x36, 0x36, 0x36},
    {0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36},
    {0x00, 0x00, 0xfe, 0x06, 0xf6, 0x36, 0x36, 0x36},
    {0x36, 0x36, 0xf6, 0x06, 0xfe, 0x00, 0x00, 0x00},
    {0x36, 0x36, 0x36, 0x36, 0xfe, 0x00, 0x00, 0x00},
    {0x18, 0x18, 0xf8, 0x18, 0xf8, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0xf8, 0x18, 0x18, 0x18},
    {0x18, 0x18, 0x18, 0x18, 0x1f, 0x00, 0x00, 0x00},
    {0x18, 0x18, 0x18, 0x18, 0xff, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0xff, 0x18, 0x18, 0x18},
    {0x18, 0x18, 0x18, 0x18, 0x1f, 0x18, 0x18, 0x18},
    {0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00},
    {0x18, 0x18, 0x18, 0x18, 0xff, 0x18, 0x18, 0x18},
    {0x18, 0x18, 0x1f, 0x18, 0x1f, 0x18, 0x18, 0x18},
    {0x36, 0x36, 0x36, 0x36, 0x37, 0x36, 0x36, 0x36},
    {0x36, 0x36, 0x37, 0x30, 0x3f, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x3f, 0x30, 0x37, 0x36, 0x36, 0x36},
    {0x36, 0x36, 0xf7, 0x00, 0xff, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0xff, 0x00, 0xf7, 0x36, 0x36, 0x36},
    {0x36, 0x36, 0x37, 0x30, 0x37, 0x36, 0x36, 0x36},
    {0x00, 0x00, 0xff, 0x00, 0xff, 0x00, 0x00, 0x00},
    {0x36, 0x36, 0xf7, 0x00, 0xf7, 0x36, 0x36, 0x36},
    {0x18, 0x18, 0xff, 0x00, 0xff, 0x00, 0x00, 0x00},
    {0x36, 0x36, 0x36, 0x36, 0xff, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0xff, 0x00, 0xff, 0x18, 0x18, 0x18},
    {0x00, 0x00, 0x00, 0x00, 0xff, 0x36, 0x36, 0x36},
    {0x36, 0x36, 0x36, 0x36, 0x3f, 0x00, 0x00, 0x00},
    {0x18, 0x18, 0x1f, 0x18, 0x1f, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x1f, 0x18, 0x1f, 0x18, 0x18, 0x18},
    {0x00, 0x00, 0x00, 0x00, 0x3f, 0x36, 0x36, 0x36},
    {0x36, 0x36, 0x36, 0x36, 0xff, 0x36, 0x36, 0x36},
    {0x18, 0x18, 0xff, 0x18, 0xff, 0x18, 0x18, 0x18},
    {0x18, 0x18, 0x18, 0x18, 0xf8, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x1f, 0x18, 0x18, 0x18},
    {0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff},
    {0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff},
    {0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0},
    {0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f},
    {0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x76, 0xdc, 0xc8, 0xdc, 0x76, 0x00},
    {0x00, 0x78, 0xcc, 0xf8, 0xcc, 0xf8, 0xc0, 0xc0},
    {0x00, 0xfc, 0xcc, 0xc0, 0xc0, 0xc0, 0xc0, 0x00},
    {0x00, 0xfe, 0x6c, 0x6c, 0x6c, 0x6c, 0x6c, 0x00},
    {0xfc, 0xcc, 0x60, 0x30, 0x60, 0xcc, 0xfc, 0x00},
    {0x00, 0x00, 0x7e, 0xd8, 0xd8, 0xd8, 0x70, 0x00},
    {0x00, 0x66, 0x66, 0x66, 0x66, 0x7c, 0x60, 0xc0},
    {0x00, 0x76, 0xdc, 0x18, 0x18, 0x18, 0x18, 0x00},
    {0xfc, 0x30, 0x78, 0xcc, 0xcc, 0x78, 0x30, 0xfc},
    {0x38, 0x6c, 0xc6, 0xfe, 0xc6, 0x6c, 0x38, 0x00},
    {0x38, 0x6c, 0xc6, 0xc6, 0x6c, 0x6c, 0xee, 0x00},
    {0x1c, 0x30, 0x18, 0x7c, 0xcc, 0xcc, 0x78, 0x00},
    {0x00, 0x00, 0x7e, 0xdb, 0xdb, 0x7e, 0x00, 0x00},
    {0x06, 0x0c, 0x7e, 0xdb, 0xdb, 0x7e, 0x60, 0xc0},
    {0x38, 0x60, 0xc0, 0xf8, 0xc0, 0x60, 0x38, 0x00},
    {0x78, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0x00},
    {0x00, 0xfc, 0x00, 0xfc, 0x00, 0xfc, 0x00, 0x00},
    {0x30, 0x30, 0xfc, 0x30, 0x30, 0x00, 0xfc, 0x00},
    {0x60, 0x30, 0x18, 0x30, 0x60, 0x00, 0xfc, 0x00},
    {0x18, 0x30, 0x60, 0x30, 0x18, 0x00, 0xfc, 0x00},
    {0x0e, 0x1b, 0x1b, 0x18, 0x18, 0x18, 0x18, 0x18},
    {0x18, 0x18, 0x18, 0x18, 0x18, 0xd8, 0xd8, 0x70},
    {0x30, 0x30, 0x00, 0xfc, 0x00, 0x30, 0x30, 0x00},
    {0x00, 0x76, 0xdc, 0x00, 0x76, 0xdc, 0x00, 0x00},
    {0x38, 0x6c, 0x6c, 0x38, 0x00, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00},
    {0x0f, 0x0c, 0x0c, 0x0c, 0xec, 0x6c, 0x3c, 0x1c},
    {0x78, 0x6c, 0x6c, 0x6c, 0x6c, 0x00, 0x00, 0x00},
    {0x70, 0x18, 0x30, 0x60, 0x78, 0x00, 0x00, 0x00},
    {0x00, 0x00, 0x3c, 0x3c, 0x3c, 0x3c, 0x00, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
};

//
// Standard definition of EIA-189-A color bars.  The actual color definitions
// are either in CRGB24Synthesizer or CYUVSynthesizer.
//
const COLOR g_ColorBars[] = 
    {WHITE, YELLOW, CYAN, GREEN, MAGENTA, RED, BLUE, BLACK};

const UCHAR CRGB24Synthesizer::Colors [MAX_COLOR][3] = {
    {0, 0, 0},          // BLACK
    {255, 255, 255},    // WHITE
    {0, 255, 255},      // YELLOW
    {255, 255, 0},      // CYAN
    {0, 255, 0},        // GREEN
    {255, 0, 255},      // MAGENTA
    {0, 0, 255},        // RED
    {255, 0, 0},        // BLUE
    {128, 128, 128}     // GREY
};

const UCHAR CYUVSynthesizer::Colors [MAX_COLOR][3] = {
    {128, 16, 128},     // BLACK
    {128, 235, 128},    // WHITE
    {16, 211, 146},     // YELLOW
    {166, 170, 16},     // CYAN
    {54, 145, 34},      // GREEN
    {202, 106, 222},    // MAGENTA
    {90, 81, 240},      // RED
    {240, 41, 109},     // BLUE
    {128, 125, 128},    // GREY
};

/**************************************************************************

    LOCKED CODE

**************************************************************************/

#ifdef ALLOC_PRAGMA
#pragma code_seg()
#endif // ALLOC_PRAGMA


void
CImageSynthesizer::
SynthesizeBars (
    )

/*++

Routine Description:

    Synthesize EIA-189-A standard color bars onto the Image.  The image
    in question is the current synthesis buffer.

Arguments:

    None

Return Value:

    None

--*/

{
    const COLOR *CurColor = g_ColorBars;
    ULONG ColorCount = SIZEOF_ARRAY (g_ColorBars);

    //
    // Set the default cursor...
    //
    GetImageLocation (0, 0);

    //
    // Synthesize a single line.
    //
    PUCHAR ImageStart = m_Cursor;
    for (ULONG x = 0; x < m_Width; x++) 
        PutPixel (g_ColorBars [((x * ColorCount) / m_Width)]);

    PUCHAR ImageEnd = m_Cursor;
    
    //
    // Copy the synthesized line to all subsequent lines.
    //
    for (ULONG line = 1; line < m_Height; line++) {

        GetImageLocation (0, line);

        RtlCopyMemory (
            m_Cursor,
            ImageStart,
            ImageEnd - ImageStart
            );
    }
}

/*************************************************/


void
CImageSynthesizer::
Fill (
    IN ULONG X_TopLeft,
    IN ULONG Y_TopLeft,
    IN ULONG X_BottomRight,
    IN ULONG Y_BottomRight,
    IN COLOR Color
    )

{

    //
    // Set the default cursor and capture the copy location.  Draw a line
    // of the specified color at the default location.
    //
    PUCHAR ImageStart = GetImageLocation (X_TopLeft, Y_TopLeft);
    for (ULONG x = X_TopLeft; x <= X_BottomRight; x++) 
        PutPixel (Color);

    PUCHAR ImageEnd = m_Cursor;

    //
    // Copy the fill line from the current location downward to the requested
    // end location.
    //
    for (ULONG y = Y_TopLeft + 1; y <= Y_BottomRight; y++) {

        GetImageLocation (X_TopLeft, y);

        RtlCopyMemory (
            m_Cursor,
            ImageStart,
            ImageEnd - ImageStart
            );

    }

}

/*************************************************/


void 
CImageSynthesizer::
OverlayText (
    ULONG LocX,
    ULONG LocY,
    ULONG Scaling,
    CHAR *Text,
    COLOR BgColor,
    COLOR FgColor
    )

/*++

Routine Description:

    Overlay text onto the synthesized image.  Clip to fit the image
    if the overlay does not fit.  The image buffer used is the set
    synthesis buffer.

Arguments:

    LocX -
        The X location on the image to begin the overlay.  This MUST
        be inside the image.  POSITION_CENTER may be used to indicate
        horizontal centering.

    LocY -
        The Y location on the image to begin the overlay.  This MUST
        be inside the image.  POSITION_CENTER may be used to indicate
        vertical centering.

    Scaling -
        Normally, the overlay is done in 8x8 font.  A scaling of
        2 indicates 16x16, 3 indicates 24x24 and so forth.

    Text -
        A character string containing the information to overlay

    BgColor -
        The background color of the overlay window.  For transparency,
        indicate TRANSPARENT here.

    FgColor -
        The foreground color for the text overlay.

Return Value:

    None

--*/

{

    ASSERT ((LocX <= m_Width || LocX == POSITION_CENTER) &&
            (LocY <= m_Height || LocY == POSITION_CENTER));

    ULONG StrLen = 0;

    //
    // Determine the character length of the string.
    //
    for (CHAR *CurChar = Text; CurChar && *CurChar; CurChar++)
        StrLen++;

    //
    // Determine the physical size of the string plus border.  There is
    // a definable NO_CHARACTER_SEPARATION.  If this is defined, there will
    // be no added space between font characters.  Otherwise, one empty pixel
    // column is added between characters.
    //
    #ifndef NO_CHARACTER_SEPARATION
        ULONG LenX = (StrLen * (Scaling << 3)) + 1 + StrLen;
    #else // NO_CHARACTER_SEPARATION
        ULONG LenX = (StrLen * (Scaling << 3)) + 2;
    #endif // NO_CHARACTER_SEPARATION

    ULONG LenY = 2 + (Scaling << 3);

    //
    // Adjust for center overlays.
    //
    // NOTE: If the overlay doesn't fit into the synthesis buffer, this
    // merely left aligns the overlay and clips off the right side.
    //
    if (LocX == POSITION_CENTER) {
        if (LenX >= m_Width) {
            LocX = 0;
        } else {
            LocX = (m_Width >> 1) - (LenX >> 1);
        }
    }

    if (LocY == POSITION_CENTER) {
        if (LenY >= m_Height) {
            LocY = 0;
        } else {
            LocY = (m_Height >> 1) - (LenY >> 1);
        }
    }

    //
    // Determine the amount of space available on the synthesis buffer.
    // We will clip anything that finds itself outside the synthesis buffer.
    //
    ULONG SpaceX = m_Width - LocX;
    ULONG SpaceY = m_Height - LocY;

    //
    // Set the default cursor position.
    //
    GetImageLocation (LocX, LocY);

    //
    // Overlay a background color row.
    //
    if (BgColor != TRANSPARENT && SpaceY) {
        for (ULONG x = 0; x < LenX && x < SpaceX; x++) {
            PutPixel (BgColor);
        }
    }
    LocY++;
    if (SpaceY) SpaceY--;

    //
    // Loop across each row of the image.
    //
    for (ULONG row = 0; row < 8 && SpaceY; row++) {
        //
        // Generate a line.
        //
        GetImageLocation (LocX, LocY++);

        PUCHAR ImageStart = m_Cursor;

        ULONG CurSpaceX = SpaceX;
        if (CurSpaceX) {
            PutPixel (BgColor);
            CurSpaceX--;
        }

        //
        // Generate the row'th row of the overlay.
        //
        CurChar = Text;
        while (CurChar && *CurChar) {
            
            UCHAR CharBase = g_FontData [*CurChar++][row];
            for (ULONG mask = 0x80; mask && CurSpaceX; mask >>= 1) {
                for (ULONG scale = 0; scale < Scaling && CurSpaceX; scale++) {
                    if (CharBase & mask) {
                        PutPixel (FgColor);
                    } else {
                        PutPixel (BgColor);
                    }
                    CurSpaceX--;
                }
            }

            // 
            // Separate each character by one space.  Account for the border
            // space at the end by placing the separator after the last 
            // character also.
            //
            #ifndef NO_CHARACTER_SEPARATION
                if (CurSpaceX) {
                    PutPixel (BgColor);
                    CurSpaceX--;
                }
            #endif // NO_CHARACTER_SEPARATION

        }

        //
        // If there is no separation character defined, account for the
        // border.
        // 
        #ifdef NO_CHARACTER_SEPARATION
            if (CurSpaceX) {
                PutPixel (BgColor);
                CurSpaceX--;
            }
        #endif // NO_CHARACTER_SEPARATION
            

        PUCHAR ImageEnd = m_Cursor;
        //
        // Copy the line downward scale times.
        //
        for (ULONG scale = 1; scale < Scaling && SpaceY; scale++) {
            GetImageLocation (LocX, LocY++);
            RtlCopyMemory (m_Cursor, ImageStart, ImageEnd - ImageStart);
            SpaceY--;
        }

    }

    //
    // Add the bottom section of the overlay.
    //
    GetImageLocation (LocX, LocY);
    if (BgColor != TRANSPARENT && SpaceY) {
        for (ULONG x = 0; x < LenX && x < SpaceX; x++) {
            PutPixel (BgColor);
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\ksfilter\tests\avstest\video.h ===
/**************************************************************************

    AVStream Filter-Centric Sample

    Copyright (c) 1999 - 2001, Microsoft Corporation

    File:

        video.h

    Abstract:

        This file contains the video capture pin header.

    History:

        created 6/11/01

**************************************************************************/

class CVideoCapturePin :
    public CCapturePin {

private:

    //
    // A scratch buffer to write into.  Due to the fact that we're likely
    // sitting upstream of the VMR and getting video memory, I don't want the
    // image synthesizer writing to video memory a single byte at a time.
    // This will be the buffer that the image synth uses.  After a synthesis,
    // the buffer will get copied into the data buffers for capture.
    //
    PUCHAR m_SynthesisBuffer;

    //
    // The captured video info header.  The settings for image synthesis will
    // be based off this header.
    //
    PKS_VIDEOINFOHEADER m_VideoInfoHeader;

    //
    // The image synthesizer.  This object is used to construct synthesized
    // image data in the video format specified by the connection format.
    //
    CImageSynthesizer *m_ImageSynth;

    //
    // CaptureVideoInfoHeader():
    //
    // This routine stashes the video info header set on the pin connection
    // in the CVideoCapturePin object.  This is used to determine necessary
    // variables for image synthesis, etc...
    //
    PKS_VIDEOINFOHEADER
    CaptureVideoInfoHeader (
        );

protected:

public:

    //
    // CVideoCapturePin():
    //
    // Construct a new video capture pin.
    //
    CVideoCapturePin (
        IN PKSPIN Pin
        ) :
        CCapturePin (Pin)
    {
    }

    //
    // ~CVideoCapturePin():
    //
    // Destruct a video capture pin.
    //
    virtual
    ~CVideoCapturePin (
        )
    {
    }

    //
    // CaptureFrame():
    //
    // Called from the filter processing routine to indicate that the pin
    // should attempt to trigger capture of a video frame.  This routine
    // will copy synthesized image data into the frame buffer and complete
    // the frame buffer.
    //
    virtual
    NTSTATUS
    CaptureFrame (
        IN PKSPROCESSPIN ProcessPin,
        IN ULONG Tick
        );

    //
    // Pause():
    //
    // Called when the video capture pin is transitioning into the pause
    // state.  This will instruct the capture filter to start the timer DPC's
    // at the interval demanded by the video info header in the connection
    // format.
    //
    virtual
    NTSTATUS
    Pause (
        IN KSSTATE FromState
        );

    //
    // Acquire():
    //
    // Called when the video capture pin is transitioning into the acquire
    // state.  This will create the necessary image synthesizer to begin
    // synthesizing frame capture data when the pin transitions to the
    // appropriate state.
    //
    virtual
    NTSTATUS
    Acquire (
        IN KSSTATE FromState
        );

    //
    // Stop():
    //
    // Called when the video capture pin is transitioning into a stop state.
    // This simply destroys the image synthesizer in preparation for creating
    // a new one next acquire.
    //
    virtual
    NTSTATUS
    Stop (
        IN KSSTATE FromState
        );

    /*************************************************

        Dispatch Functions

    *************************************************/

    //
    // DispatchCreate():
    //
    // This is the creation dispatch for the video capture pin on the filter.
    // It creates the CVideoCapturePin, associates it with the AVStream pin
    // object and bags the class object for automatic cleanup when the
    // pin is closed.
    //
    static
    NTSTATUS
    DispatchCreate (
        IN PKSPIN Pin,
        IN PIRP Irp
        );

    //
    // DispatchSetFormat():
    //
    // This is the set data format dispatch for the pin.  This will be called 
    // BEFORE pin creation to validate that a data format selected is a match
    // for the range pulled out of our range list.  It will also be called
    // for format changes.
    //
    // If OldFormat is NULL, this is an indication that it's the initial
    // call and not a format change.  Even fixed format pins get this call
    // once.
    //
    static
    NTSTATUS
    DispatchSetFormat (
        IN PKSPIN Pin,
        IN PKSDATAFORMAT OldFormat OPTIONAL,
        IN PKSMULTIPLE_ITEM OldAttributeList OPTIONAL,
        IN const KSDATARANGE *DataRange,
        IN const KSATTRIBUTE_LIST *AttributeRange OPTIONAL
        );

    //
    // IntersectHandler():
    //
    // This is the data intersection handler for the capture pin.  This 
    // determines an optimal format in the intersection of two ranges,
    // one local and one possibly foreign.  If there is no compatible format,
    // STATUS_NO_MATCH is returned.
    //
    static
    NTSTATUS
    IntersectHandler (
        IN PKSFILTER Filter,
        IN PIRP Irp,
        IN PKSP_PIN PinInstance,
        IN PKSDATARANGE CallerDataRange,
        IN PKSDATARANGE DescriptorDataRange,
        IN ULONG BufferSize,
        OUT PVOID Data OPTIONAL,
        OUT PULONG DataSize
        );

    //
    // CleanupSynth():
    //
    // Called when the Image Synthesizer is removed from the object bag
    // to be cleaned up.  We simply delete the image synth.
    //
    static
    void
    CleanupSynth (
        IN CImageSynthesizer *ImageSynth
        )
    {
        delete ImageSynth;
    }

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\net\irda\irsir\sources.inc ===
MAJORCOMP=setup
MINORCOMP=infs

TARGETNAME=inf
TARGETPATH=obj
TARGETTYPE=notarget
SOURCES=
NTTARGETFILES=

MISCFILES = \
    $(O)\netirsir.inf
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\net\irda\irsir\daytona\chsinf\makefile.inc ===
LANGUAGE=CHS

!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\net\irda\irsir\daytona\brinf\makefile.inc ===
LANGUAGE=br

!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\ksfilter\tests\avstest\wave.cpp ===
/**************************************************************************

    AVStream Filter-Centric Sample

    Copyright (c) 1999 - 2001, Microsoft Corporation

    File:

        wave.cpp

    Abstract:

        Wave object implementation.

    History:

        Created 6/28/01

**************************************************************************/

#include "avssamp.h"

/**************************************************************************

    PAGED CODE

**************************************************************************/

#ifdef ALLOC_PRAGMA
#pragma code_seg("PAGE")
#endif // ALLOC_PRAGMA


CWaveObject::
~CWaveObject (
    )

/*++

Routine Description:

    Destroy a wave object.

Arguments:

    None

Return Value:

    None

--*/

{

    if (m_WaveData) {
        ExFreePool (m_WaveData);
    }

}

/*************************************************/


NTSTATUS
CWaveObject::
ParseForBlock (
    IN HANDLE FileHandle,
    IN ULONG BlockHeader,
    IN OUT PLARGE_INTEGER BlockPosition,
    OUT PULONG BlockSize
    )

/*++

Routine Description:

    Given that BlockPosition points to the offset of the start of a RIFF block,
    continue parsing the specified file until a block with the header of
    BlockHeader is found.  Return the position of the block data and the size
    of the block.

Arguments:

    FileHandle -
        Handle to the file to parse

    BlockHeader -
        The block header to scan for

    BlockPosition -
        INPUT : Points to the block header to start at
        OUTPUT: If successful, points to the block data for the sought block
                If unsuccessful, unchanged

    BlockSize -
        On output, if successful -- the size of the sought block will be 
        placed here

Return Value:

    Success / Failure of the search

--*/

{

    PAGED_CODE();

    NTSTATUS Status;
    ULONG FmtBlockSize = 0;
    LARGE_INTEGER ReadPos = *BlockPosition;
    IO_STATUS_BLOCK iosb;

    while (1) {
        ULONG BlockHeaderData [2];

        Status = ZwReadFile (
            FileHandle,
            NULL,
            NULL,
            NULL,
            &iosb,
            BlockHeaderData,
            sizeof (BlockHeaderData),
            &ReadPos,
            NULL
            );

        if (NT_SUCCESS (Status)) {
            if (BlockHeaderData [0] == BlockHeader) {
                FmtBlockSize = BlockHeaderData [1];
                ReadPos.QuadPart += 0x8;
                break;
            } else {
                //
                // This isn't a format block.  Just ignore it.  All we
                // care about is the format block and the PCM data.
                //
                ReadPos.QuadPart += BlockHeaderData [1] + 0x8;
            }
        } else {
            break;
        }

    }

    if (FmtBlockSize == 0) {
        Status = STATUS_NOT_FOUND;
    } else {
        *BlockPosition = ReadPos;
        *BlockSize = FmtBlockSize;
    }

    return Status;

}

/*************************************************/


NTSTATUS
CWaveObject::
ParseAndRead (
    )

/*++

Routine Description:

    Parse the wave file and read the data into an internally allocated
    buffer.  This prepares to synthesize audio data from the wave
    object.

Arguments:

    None

Return Value:

    Success / Failure

        If the wave is unrecognized, unparsable, or insufficient memory
        exists to allocate the internal buffer, an error code will
        be returned and the object will be incapable of synthesizing
        audio data based on the wave.

--*/

{

    PAGED_CODE();

    IO_STATUS_BLOCK iosb;
    UNICODE_STRING FileName;
    OBJECT_ATTRIBUTES ObjectAttributes;
    NTSTATUS Status;
    HANDLE FileHandle = NULL;
    FILE_OBJECT *FileObj;
    ULONG PostRiffSize;

    RtlInitUnicodeString (&FileName, m_FileName);

    InitializeObjectAttributes (
        &ObjectAttributes,
        &FileName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    Status = ZwCreateFile (
        &FileHandle,
        GENERIC_READ | SYNCHRONIZE,
        &ObjectAttributes,
        &iosb,
        0,
        FILE_ATTRIBUTE_NORMAL,
        FILE_SHARE_READ,
        FILE_OPEN,
        FILE_SYNCHRONOUS_IO_NONALERT,
        NULL,
        0
        );

    if (NT_SUCCESS (Status)) {
        ULONG RiffWaveHeader [3];

        //
        // Read the header: RIFF size WAVE
        //
        Status = ZwReadFile (
            FileHandle,
            NULL,
            NULL,
            NULL,
            &iosb,
            RiffWaveHeader,
            sizeof (RiffWaveHeader),
            NULL,
            NULL
            );

        //
        // Ensure that this is a RIFF file and it's a WAVE.
        //
        if (NT_SUCCESS (Status)) {

            if (RiffWaveHeader [0] != 'FFIR' ||
                RiffWaveHeader [2] != 'EVAW') {
                Status = STATUS_INVALID_PARAMETER;
            } else {
                PostRiffSize = RiffWaveHeader [1] - 4;
            }
        }
    }

    //
    // Find the wave format block and ensure it's WAVEFORMATEX and PCM
    // data.  Otherwise, this can't parse the wave.
    //
    LARGE_INTEGER ReadPos;
    ReadPos.QuadPart = 0xc;
    ULONG FmtBlockSize = 0;

    if (NT_SUCCESS (Status)) {
        Status = ParseForBlock (FileHandle, ' tmf', &ReadPos, &FmtBlockSize);
    }

    //
    // If the format block was not found, the file cannot be parsed.  If the
    // format block is unrecognized, the file cannot be parsed.
    //
    if (FmtBlockSize >= sizeof (m_WaveFormat)) {
        Status = STATUS_INVALID_PARAMETER;
    }

    if (NT_SUCCESS (Status)) {
        Status = ZwReadFile (
            FileHandle,
            NULL,
            NULL,
            NULL,
            &iosb,
            &m_WaveFormat,
            FmtBlockSize,
            &ReadPos,
            NULL
            );
    }

    if (NT_SUCCESS (Status)) {
        if (m_WaveFormat.wFormatTag != WAVE_FORMAT_PCM) {
            Status = STATUS_INVALID_PARAMETER;
        }
    }

    ReadPos.QuadPart += FmtBlockSize;

    //
    // Find the data block and read it in.
    //
    ULONG DataBlockSize;
    if (NT_SUCCESS (Status)) {
        Status = ParseForBlock (FileHandle, 'atad', &ReadPos, &DataBlockSize);
    }

    //
    // Perform a slight validation.
    //
    if (NT_SUCCESS (Status) && 
        (DataBlockSize == 0 || 
        (DataBlockSize & (m_WaveFormat.nBlockAlign - 1)))) {

        Status = STATUS_INVALID_PARAMETER;
    }

    //
    // If we're okay so far, allocate memory for the wave data.
    //
    if (NT_SUCCESS (Status)) {
        m_WaveData = reinterpret_cast <PUCHAR> (
            ExAllocatePool (NonPagedPool, DataBlockSize)
            );

        if (!m_WaveData) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    //
    // Read the wave data in.
    //
    if (NT_SUCCESS (Status)) {
        Status = ZwReadFile (
            FileHandle,
            NULL,
            NULL,
            NULL,
            &iosb,
            m_WaveData,
            DataBlockSize,
            &ReadPos,
            NULL
            );

        m_WaveSize = DataBlockSize;
    }

    //
    // If we failed, clean up.
    //
    if (!NT_SUCCESS (Status)) {
        if (m_WaveData) {
            ExFreePool (m_WaveData);
            m_WaveData = NULL;
        }
    }

    if (FileHandle) {
        ZwClose (FileHandle);
    }

    return Status;
}

/*************************************************/


void
CWaveObject::
WriteRange (
    OUT PKSDATARANGE_AUDIO DataRange
    )

/*++

Routine Description:

    Fill out the extended portion of the audio data range at DataRange.  This
    includes the channel, bps, and frequency fields.

Arguments:

    DataRange -
        The data range to fill out

Return Value:

    None

--*/

{

    PAGED_CODE();

    DataRange -> MaximumChannels = m_WaveFormat.nChannels;
    DataRange -> MinimumBitsPerSample =
        DataRange -> MaximumBitsPerSample = 
        m_WaveFormat.wBitsPerSample;
    DataRange -> MinimumSampleFrequency =
        DataRange -> MaximumSampleFrequency =
        m_WaveFormat.nSamplesPerSec;


}

/**************************************************************************

    LOCKED CODE

**************************************************************************/

#ifdef ALLOC_PRAGMA
#pragma code_seg()
#endif // ALLOC_PRAGMA


void
CWaveObject::
SkipFixed (
    IN LONGLONG TimeDelta
    )

/*++

Routine Description:

    Skip ahead a specific time delta within the wave.

Arguments:
    
    TimeDelta -
        The amount of time to skip ahead.

--*/

{
    if (TimeDelta > 0)  {

        //
        // Compute the number of bytes of audio data necessary to move the 
        // stream forward TimeDelta time.  Remember that TimeDelta is in 
        // units of 100nS.
        //
        ULONG Samples = (ULONG)(
            (m_WaveFormat.nSamplesPerSec * TimeDelta) / 10000000
            );
    
        ULONG Bytes = Samples * (m_WaveFormat.wBitsPerSample / 8) *
            m_WaveFormat.nChannels;
    
        m_WavePointer = (m_WavePointer + Bytes) % m_WaveSize;
    
        m_SynthesisTime += TimeDelta;

    }

}


ULONG
CWaveObject::
SynthesizeFixed (
    IN LONGLONG TimeDelta,
    IN PVOID Buffer,
    IN ULONG BufferSize
    )

/*++

Routine Description:

    Copy wave data from our wave block in order to synthesize forward in time
    TimeDelta (in 100nS units).

Arguments:

    TimeDelta -
        The amount of time to move the stream (in 100nS increments)

    Buffer -
        The buffer to synthesize into

    BufferSize -
        The size of the buffer

Return Value:

    Number of bytes synthesized.

--*/

{

    //
    // If there is no time delta, return 0.
    //
    if (TimeDelta < 0) 
        return 0;

    //
    // Compute the number of bytes of audio data necessary to move the stream
    // forward TimeDelta time.  Remember that TimeDelta is in units of 100nS.
    //
    ULONG Samples = (ULONG)(
        (m_WaveFormat.nSamplesPerSec * TimeDelta) / 10000000
        );

    ULONG Bytes = Samples * (m_WaveFormat.wBitsPerSample / 8) *
        m_WaveFormat.nChannels;

    //
    // Now that we have a specified number of bytes, we determine how many
    // to really copy based on the Size of the buffer.
    //
    if (Bytes > BufferSize) Bytes = BufferSize;

    //
    // Because the buffer is looping, this may multiple distinct copies.  For
    // large wave files, this may be two chunks.  For small wave files, this
    // may be MANY distinct chunks.
    //
    ULONG BytesRemaining = Bytes;
    PUCHAR DataCopy = reinterpret_cast <PUCHAR> (Buffer);

    while (BytesRemaining) {
        ULONG ChunkCount = m_WaveSize - m_WavePointer;
        if (ChunkCount > BytesRemaining) ChunkCount = BytesRemaining;

        RtlCopyMemory (
            DataCopy,
            m_WaveData + m_WavePointer,
            ChunkCount
            );

        m_WavePointer += ChunkCount;
        if (m_WavePointer >= m_WaveSize) m_WavePointer -= m_WaveSize;

        BytesRemaining -= ChunkCount;
        DataCopy += ChunkCount;

    }

    //
    // Consider that we have synthesized up to the specified time.  If the
    // buffer was not large enough to do this, we'll end up falling behind
    // the synthesis time.  This does not skip samples.
    //
    m_SynthesisTime += TimeDelta;

    return Bytes;

}


ULONG
CWaveObject::
SynthesizeTo (
    IN LONGLONG StreamTime,
    IN PVOID Buffer,
    IN ULONG BufferSize
    )

/*++

Routine Description:

    Copy wave data from our wave block in order to synthesize the stream
    up to the specified stream time.  If the buffers are not large enough,
    this will fall behind on synthesis.

Arguments:

    StreamTime -
        The time to synthesize up to

    Buffer -
        The buffer to copy synthesized wave data into

    BufferSize -
        The size of the buffer

Return Value:

    The number of bytes used.

--*/

{

    LONGLONG TimeDelta = StreamTime - m_SynthesisTime;

    return SynthesizeFixed (TimeDelta, Buffer, BufferSize);


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\net\irda\irsir\makefile.inc ===
PLATFORM_SWITCH=$(TARGET_DIRECTORY)
!IF "$(ALT_PROJECT)" == "NEC_98"
PLATFORM_SWITCH =nec98
!ENDIF

_LNG=..\..\$(LANGUAGE)
_INX=..\..
STAMP=stampinf -f

$(O)\netirsir.inf: $(_INX)\netirsir.inx $(_LNG)\netirsir.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $(@B).tmp
    $(STAMP) $(@B).tmp
    prodfilt $(@B).tmp $@ +$(PLATFORM_SWITCH)
    @del $(@B).tmp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\net\irda\irsir\daytona\chtinf\makefile.inc ===
LANGUAGE=CHT

!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\net\irda\irsir\daytona\csinf\makefile.inc ===
LANGUAGE=cs

!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\ksfilter\tests\avstest\wave.h ===
/**************************************************************************

    AVStream Filter-Centric Sample

    Copyright (c) 1999 - 2001, Microsoft Corporation

    File:

        wave.h

    Abstract:

        Wave object header.

    History:

        Created 6/28/01

**************************************************************************/

//
// The CWaveObject is a class which will parse PCM wave files, read the
// data, and expose the data in a loop.  This allows the sample to "synthesize"
// audio data by using any PCM wave file the user wishes.
//
class CWaveObject {

private:

    //
    // The wave format.
    //
    WAVEFORMATEX m_WaveFormat;

    //
    // The wave data.
    //
    PUCHAR m_WaveData;

    //
    // The size of the wave data.
    //
    ULONG m_WaveSize;

    //
    // The filename for the wave file.  This string must be constant and 
    // static over the lifetime of the wave object.
    //
    PWCHAR m_FileName;

    //
    // The time we have synthesized to.
    //
    LONGLONG m_SynthesisTime;

    //
    // The pointer into the wave data that we have synthesized to.
    //
    ULONG m_WavePointer;

    //
    // ParseBlock():
    //
    // Parse the wave file, starting at the specified location, until the
    // specified block has been found.  The pointer will be updated to
    // point to the block data and the amount of data in the block will
    // be returned in a variable. 
    //
    NTSTATUS
    ParseForBlock (
        IN HANDLE FileHandle,
        IN ULONG BlockHeader,
        IN OUT PLARGE_INTEGER BlockPointer,
        OUT PULONG BlockSize
        );

public:

    //
    // CWaveObject():
    //
    // Construct a new wave object using the specified file name.
    //
    CWaveObject (
        IN PWCHAR FileName
        ) :
        m_FileName (FileName)
    {
    }

    //
    // ~CWaveObject():
    //
    // Destroy a wave object.
    //
    ~CWaveObject (
        );

    //
    // ParseAndRead():
    //
    // Parse the wave file and read it into an internally allocated buffer
    // inside the wave object.  This is preparation to synthesize looped
    // audio based on the wave.
    //
    NTSTATUS
    ParseAndRead (
        );

    //
    // WriteRange():
    //
    // Given the address of a KSDATARANGE_AUDIO, write out a range which
    // matches exactly the specifications of the wave we're using to
    // synthesize audio data.
    //
    // The GUIDs must be filled out already.  This only fills out the 
    // channel, bps, and freq fields.
    //
    void
    WriteRange (
        PKSDATARANGE_AUDIO AudioRange
        );

    //
    // SynthesizeTo():
    //
    // Given a specific stream time, synthesize from the current stream time
    // (assume 0) to the supplied stream time.
    //
    ULONG
    SynthesizeTo (
        IN LONGLONG StreamTime,
        IN PVOID Data,
        IN ULONG BufferSize
        );

    //
    // SynthesizeFixed():
    //
    // Given a specific amount of time, synthesize forward in time that
    // particular amount.  Units expressed in 100nS increments.
    //
    ULONG
    SynthesizeFixed (
        IN LONGLONG TimeDelta,
        IN PVOID Data,
        IN ULONG BufferSize
        );

    //
    // SkipFixed():
    //
    // Given a specific amount of time, skip forward in time that
    // particular amount.  Units expressed in 100nS increments.
    //
    void
    SkipFixed (
        IN LONGLONG TimeDelta
        );

    //
    // Reset():
    //
    // Reset the synthesis time and block pointers.  This will cause the
    // clock with respect to this wave object to go to zero.
    //
    void
    Reset (
        )
    {
        m_WavePointer = 0;
        m_SynthesisTime = 0;
    }

    //
    // Cleanup():
    //
    // This is a bag cleanup callback.  It merely deletes the wave object
    // instead of letting the default of ExFreePool free it.
    //
    static
    void
    Cleanup (
        IN CWaveObject *This
        )
    {
        delete This;
    }

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\net\irda\irsir\daytona\esinf\makefile.inc ===
LANGUAGE=es

!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\net\irda\irsir\daytona\gerinf\makefile.inc ===
LANGUAGE=GER

!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\net\irda\irsir\daytona\frinf\makefile.inc ===
LANGUAGE=fr

!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\net\irda\irsir\daytona\dainf\makefile.inc ===
LANGUAGE=da

!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\net\irda\irsir\daytona\fiinf\makefile.inc ===
LANGUAGE=fi

!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\net\irda\irsir\daytona\huinf\makefile.inc ===
LANGUAGE=hu

!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\net\irda\irsir\daytona\elinf\makefile.inc ===
LANGUAGE=el

!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\net\irda\irsir\daytona\itinf\makefile.inc ===
LANGUAGE=it

!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\net\irda\irsir\daytona\plinf\makefile.inc ===
LANGUAGE=pl

!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\net\irda\irsir\daytona\ruinf\makefile.inc ===
LANGUAGE=ru

!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\net\irda\irsir\daytona\jpninf\makefile.inc ===
LANGUAGE=JPN

!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\net\irda\irsir\daytona\necinf\makefile.inc ===
LANGUAGE=JPN

!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\net\irda\irsir\daytona\noinf\makefile.inc ===
LANGUAGE=no

!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\net\irda\irsir\daytona\nlinf\makefile.inc ===
LANGUAGE=nl

!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\net\irda\irsir\daytona\psuinf\makefile.inc ===
LANGUAGE=psu

!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\net\irda\irsir\daytona\ptinf\makefile.inc ===
LANGUAGE=pt

!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\net\irda\irsir\daytona\usainf\makefile.inc ===
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\net\irda\irsir\daytona\trinf\makefile.inc ===
LANGUAGE=tr

!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\net\irda\irsir\daytona\tstinf\makefile.inc ===
LANGUAGE=TST

!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\net\irda\irsir\daytona\svinf\makefile.inc ===
LANGUAGE=sv

!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\net\irda\mknet\inf\makefile.inc ===
!IFNDEF LANGUAGE
LANGUAGE=usa
!ENDIF

_LNG=$(LANGUAGE)
_INX=.
STAMP=stampinf -f $@

$(O)\IRMK7W2K.INF: $(_INX)\IRMK7W2K.inx $(_LNG)\IRMK7W2K.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $@
    $(STAMP)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\net\irda\mknet\sys\dbg.c ===
/*****************************************************************************
 **																			**
 **	COPYRIGHT (C) 2000, 2001 MKNET CORPORATION								**
 **	DEVELOPED FOR THE MK7100-BASED VFIR PCI CONTROLLER.						**
 **																			**
 *****************************************************************************/

/**********************************************************************

Module Name:
	DBG.C

Routines:
	MyLogEvent
	MyLogPhysEvent
	DbgInterPktTimeGap
	DbgTestInit
	MK7DbgTestIntTmo

**********************************************************************/

#include	"precomp.h"
#pragma		hdrstop
#include	"protot.h"


#define LOG_LENGTH 1000


#if DBG


UINT	DbgLogIndex = 0;
char	*DbgLogMsg[LOG_LENGTH] = {0};
ULONG	DbgLogVal[LOG_LENGTH] = {0};

// This to keep track of the phy buffs
ULONG	DbgLogTxPhysBuffs[DEF_TCB_CNT];
ULONG	DbgLogRxPhysBuffs[CalRpdSize(DEF_RCB_CNT)];
UINT	DbgLogTxPhysBuffsIndex = 0;
UINT	DbgLogRxPhysBuffsIndex = 0;


// Globals to ease debugging
UINT		GDbgDataSize=0;
MK7DBG_STAT	GDbgStat;
ULONG		GDbgSleep=0;

LONGLONG	GDbgTACmdTime[1000];
LONGLONG	GDbgTARspTime[1000];
LONGLONG	GDbgTATime[1000];
UINT		GDbgTATimeIdx;



//----------------------------------------------------------------------
// Procedure:		[MyLogEvent]
//
// Description:	Log to our arrary.
//
//----------------------------------------------------------------------
VOID MyLogEvent(char *msg, ULONG val)
{

//	NdisGetCurrentSystemTime((PLARGE_INTEGER)&DbgLog[DbgLogIndex].usec);

	DbgLogMsg[DbgLogIndex] = msg;
	DbgLogVal[DbgLogIndex] = val;
	DbgLogIndex++;
	DbgLogIndex %= LOG_LENGTH;
}



//----------------------------------------------------------------------
// Procedure:		[MyLogPhysEvent]
//
// Description:	Log to our arrary.

//----------------------------------------------------------------------
VOID MyLogPhysEvent(ULONG *logarray, UINT *index, ULONG val)
{
	logarray[*index] = val;
	(*index)++;
}


//----------------------------------------------------------------------
//	Procedure:		Time gap between successive sends.
//----------------------------------------------------------------------
VOID	DbgInterPktTimeGap()
{
	NdisMSleep(GDbgSleep);
}



//----------------------------------------------------------------------
// Procedure:	[DbgTestInit]
//
// Description:	Initialized the test context.
//
//-----------------------------------------------------------------------
VOID DbgTestInit(PMK7_ADAPTER Adapter)
{
	UINT	i;

	//************************************************************
	// The start of this routine is to facilitate debugging. We create
	// canned debug/test settings so we don't have to manually change
	// variables in debugger. However, tests not covered by the hardcoded
	// settings still need to be manually set.
	//
	// 2 main functions happen here to help w/ test/debug:
	//	1. Desired fields in the Adapter struct are extracted here and
	//		displayed so we don't have to manually look at these fields.
	//  2. Setup debug/test fields in Adapter.
	//************************************************************


	//************************************************************
	//
	// Set DbgTest here to run canned tests.
	//
	//************************************************************

	//++++++++++++++++++++++++++++++
	// Hardcode something to ease debug.
	Adapter->DbgTest = 0;
	//++++++++++++++++++++++++++++++


	if (Adapter->DbgTest == 0)
		return;

	switch(Adapter->DbgTest) {
	//
	// Tests 1-5 all need Loopback turned on at startup.
	//

	case 1:
		Adapter->LBPktLevel = 1;
		Adapter->DbgTestDataCnt = GDbgDataSize;
		break;

	case 2:
		Adapter->LBPktLevel = 4;
		break;

	case 3:
		Adapter->LBPktLevel = 15;
		break;

	case 4:
		Adapter->LBPktLevel = 32;
		break;

	case 5:
		Adapter->LBPktLevel = 4;
		break;

	case 6:
		Adapter->LBPktLevel = 1;
		Adapter->DbgTestDataCnt = GDbgDataSize;
		break;

	case 7:
		Adapter->LBPktLevel = 0;
		Adapter->DbgTestDataCnt = GDbgDataSize;
		break;

	default:
		// anything else we're not running any tests
		break;
	}

	NdisZeroMemory(&GDbgStat, sizeof(MK7DBG_STAT));


	// Use our timer to simulate TX/RX (this to basically tests
	// my interrupt handling logic while hw interrupt is not yet
	// working. (May be used for other tests.)
	// Always set it up but we may not use it.
//	NdisMInitializeTimer(&Adapter->MK7DbgTestIntTimer,
//						Adapter->MK7AdapterHandle,
//						(PNDIS_TIMER_FUNCTION) MK7DbgTestIntTmo,
//						(PVOID) Adapter);


	for (i=0; i<1000; i++) {
		GDbgTACmdTime[i] = 0;
		GDbgTARspTime[i] = 0;
		GDbgTATime[i] = 0;
	}

	GDbgTATimeIdx = 0;

}


//----------------------------------------------------------------------
// Procedure:	[MK7DbgTestIntTmo]
//
// Description:	Process a test interrupt time out.
//
// (NOTE: This was used to test the TEST_Int bit when hw interrupt was
// not fully working. This function is no longer needed. It's here as
// as example on how to process an NDIS timer.)
//-----------------------------------------------------------------------
VOID MK7DbgTestIntTmo(PVOID sysspiff1,
				NDIS_HANDLE MiniportAdapterContext,
				PVOID sysspiff2,
				PVOID sysspiff3)
{
	PMK7_ADAPTER	Adapter;
	UINT	tcbidx;
	PTCB	tcb;
	PRCB	rcb;
	UINT	testsize;
	PUCHAR	dst, src;

	Adapter = PMK7_ADAPTER_FROM_CONTEXT_HANDLE(MiniportAdapterContext);

	MK7DisableInterrupt(Adapter);

    NdisAcquireSpinLock(&Adapter->Lock);

	// Find the tcb-trd being sent. We just go back one becuase after
	// the send this gets incremented.
	if (Adapter->nextAvailTcbIdx == 0) {
		tcbidx = Adapter->NumTcb - 1;
	}
	else {
		tcbidx = Adapter->nextAvailTcbIdx - 1;
	}

	tcb = Adapter->pTcbArray[tcbidx];
	rcb = Adapter->pRcbArray[Adapter->nextRxRcbIdx];


	// Copy from TX buff to RX buff
	src = tcb->buff;
	dst = rcb->rpd->databuff;
	testsize = tcb->PacketLength;
	NdisMoveMemory(dst, src, testsize);
	
	// now the RX ring buffer fields -- count
	rcb->rrd->count = tcb->trd->count;
	// now make sure the ownerships go to the drv
	GrantTrdToDrv(tcb->trd);
	GrantRrdToDrv(rcb->rrd);

    NdisReleaseSpinLock(&Adapter->Lock);

	MK7Reg_Write(Adapter, R_INTS, 0x0004);
}

#endif // DBG end bracket
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\net\irda\mknet\sys\mk7comm.c ===
/*****************************************************************************
 **																			**
 **	COPYRIGHT (C) 2000, 2001 MKNET CORPORATION								**
 **	DEVELOPED FOR THE MK7100-BASED VFIR PCI CONTROLLER.						**
 **																			**
 *****************************************************************************/

/**********************************************************************

Module Name:
	MK7COMM.C

Routines:
	MK7Reg_Write
	MK7Reg_Read
	MK7DisableInterrupt
	MK7EnableInterrupt
	MK7SwitchToRXMode
	MK7SwitchToTXMode
	SetSpeed
	MK7ChangeSpeedNow

Comments:


**********************************************************************/

#include	"precomp.h"
#include	"protot.h"
#pragma		hdrstop


baudRateInfo supportedBaudRateTable[NUM_BAUDRATES] = {
	{
		BAUDRATE_2400,					// Table index
		2400,							// bps
		NDIS_IRDA_SPEED_2400,			// NDIS bit mask code (NOTE: We don't support 
										// 2400. We set this bit to 0.)
	},
	{
		BAUDRATE_9600,
		9600,
		NDIS_IRDA_SPEED_9600,
	},
	{
		BAUDRATE_19200,
		19200,
		NDIS_IRDA_SPEED_19200,
	},
	{
		BAUDRATE_38400,
		38400,
		NDIS_IRDA_SPEED_38400,
	},
	{
		BAUDRATE_57600,
		57600,
		NDIS_IRDA_SPEED_57600,
	},
	{
		BAUDRATE_115200,
		115200,
		NDIS_IRDA_SPEED_115200,
	},
	{
		BAUDRATE_576000,
		576000,
		NDIS_IRDA_SPEED_576K,
	},
	{
		BAUDRATE_1152000,
		1152000,
		NDIS_IRDA_SPEED_1152K,
	},
	{
		BAUDRATE_4M,
		4000000,
		NDIS_IRDA_SPEED_4M,
	},
	{
		BAUDRATE_16M,
		16000000,
		NDIS_IRDA_SPEED_16M,
	}
};



// Write to IRCONFIG2 w/ these to set SIR/MIR speeds
MK7REG	HwSirMirSpeedTable[] = {
	HW_SIR_SPEED_2400,
	HW_SIR_SPEED_9600,
	HW_SIR_SPEED_19200,
	HW_SIR_SPEED_38400,
	HW_SIR_SPEED_57600,
	HW_SIR_SPEED_115200,
	HW_MIR_SPEED_576000,
	HW_MIR_SPEED_1152000
};



#if	DBG

//----------------------------------------------------------------------
//
//	NOTE: The following Write and Read routines are bracketed w/ DBG
//		switch. In the non-debug version, these 2 calls are inline
//		macros for faster execution.
//
//----------------------------------------------------------------------


//----------------------------------------------------------------------
// Procedure:	[MK7Reg_Write]
//
// Description:	Write to the MK7100 register.
//				(Note: In the free build, this is an inline macro. It's
//				here in the checked build for debugging.)
//----------------------------------------------------------------------
VOID MK7Reg_Write(PMK7_ADAPTER Adapter, ULONG port, USHORT val)
{
	PUCHAR	ioport;

	// Break this out for debugging
	ioport = Adapter->MappedIoBase + port;
	NdisRawWritePortUshort(ioport, val);
}



//----------------------------------------------------------------------
// Procedure:	[MK7Reg_Read]
//
// Description:	Read from MK7100 register.
//				(Note: In the free build, this is an inline macro. It's
//				here in the checked build for debugging.)
//----------------------------------------------------------------------
VOID MK7Reg_Read(PMK7_ADAPTER Adapter, ULONG port, USHORT *pval)
{
	PUCHAR 	ioport;

	// Break this out for debugging
	ioport = Adapter->MappedIoBase + port;
	NdisRawReadPortUshort(ioport, pval);
}

#endif


//----------------------------------------------------------------------
// Procedure:	[MK7DisableInterrupt]
//
// Description:	Disable all interrupts on the MK7
//
// Arguments:
//		Adapter - ptr to Adapter object instance
//
// Returns:
//	  	NDIS_STATUS_SUCCESS - If an adapter is successfully found and claimed
//	  	NDIS_STATUS_FAILURE - If an adapter is not found/claimed
//
//----------------------------------------------------------------------
NDIS_STATUS MK7DisableInterrupt(PMK7_ADAPTER Adapter)
{
	MK7REG	mk7reg;
	UINT	i;


	// NOTE: Workaround for potential hw problem where 0xFFFF is returned
	for (i=0; i<50; i++) {
		MK7Reg_Read(Adapter, R_CFG3, &mk7reg);
		if (mk7reg != 0xFFFF) {
			break;
		}
	}
	ASSERT(i < 50);

	mk7reg &= (~B_ENAB_INT);

	MK7Reg_Write(Adapter, R_CFG3, mk7reg);
	return(NDIS_STATUS_SUCCESS);
}



//----------------------------------------------------------------------
// Procedure:	[MK7EnableInterrupt]
//
// Description:	Enable all interrupts on the MK7
//
// Arguments:
//		Adapter - ptr to Adapter object instance
//
// Returns:
//	  	NDIS_STATUS_SUCCESS - If an adapter is successfully found and claimed
//	  	NDIS_STATUS_FAILURE - If an adapter is not found/claimed
//
//----------------------------------------------------------------------
NDIS_STATUS MK7EnableInterrupt(PMK7_ADAPTER Adapter)
{
	MK7REG	mk7reg;
	UINT	i;


	// NOTE: Workaround for potential hw problem where 0xFFFF is returned
	for (i=0; i<50; i++) {
		MK7Reg_Read(Adapter, R_CFG3, &mk7reg);
		if (mk7reg != 0xFFFF) {
			break;
		}
	}
	ASSERT(i < 50);

	mk7reg |= B_ENAB_INT;


	MK7Reg_Write(Adapter, R_CFG3, mk7reg);

	// PROMPT - Always after an Enable
	MK7Reg_Write(Adapter, R_PRMT, 0);

	return(NDIS_STATUS_SUCCESS);
}



//----------------------------------------------------------------------
// Procedure:	[MK7SwitchToRXMode]
//
// Description:	Put hw in receive mode.
//
// Actions:
//	- Hw registers are programmed accordingly.
//	- IOMode set to RX_MODE.
//	- SlaveTXStuckCnt reset.
//----------------------------------------------------------------------
VOID	MK7SwitchToRXMode(PMK7_ADAPTER Adapter)
{
	MK7REG mk7reg;

	MK7Reg_Read(Adapter, R_CFG0, &mk7reg);
	mk7reg &= (~B_CFG0_ENTX);
	MK7Reg_Write(Adapter, R_CFG0, mk7reg);		
	Adapter->IOMode = RX_MODE;

	DBGLOG("-  Switch to RX mode", 0);
}



//----------------------------------------------------------------------
// Procedure:	[MK7SwitchToTXMode]
//
// Description:	Put hw in receive mode.
//
// Actions:
//	- Hw registers are programmed accordingly.
//	- IOMode set to TX_MODE.
//----------------------------------------------------------------------
VOID	MK7SwitchToTXMode(PMK7_ADAPTER Adapter)
{
	MK7REG mk7reg;

	MK7Reg_Read(Adapter, R_CFG0, &mk7reg);
	mk7reg |= B_CFG0_ENTX;
	MK7Reg_Write(Adapter, R_CFG0, mk7reg);
	Adapter->IOMode = TX_MODE;

	DBGLOG("-  Switch to TX mode", 0);
}



//----------------------------------------------------------------------
// Procedure:	[SetSpeed]
//
// Description:
//		Set the hw to a new speed.
//		[IMPORTANT: This should be called only from xxxSetInformation().]
//
// Actions:
//----------------------------------------------------------------------
BOOLEAN	SetSpeed(PMK7_ADAPTER Adapter)
{
	UINT	i, bps;
	MK7REG	mk7reg;
    PTCB	tcb;

	//******************************
	// The idea is any sends that came before the change-speed command are
	// sent at the old speed. There are 3 scenarios here:
	//	1.	There's no TXs outstanding -- We can change speed right away.
	//	2.	There's TXs oustanding in the TX ring but none in the TX q -- We
	//		do not change speed right away.
	//	3.	There's TXs oustanding in the TX q (may be also in the TX ring) --
	//		We do not change speed right away.
	//******************************


	DBGLOG("=> SetSpeed", 0);

	// If we're already waiting to change speed, fail all such requests
	// until the original is done. (Is this good?)
	//if (Adapter->changeSpeedPending) {
	//	LOG("SetSpeed: already pending", 0);
	//	return (FALSE);
	//}

	// This means 1 TX is already active. Change speed on completion.
	if (Adapter->NumPacketsQueued == 1) {
		Adapter->changeSpeedPending = CHANGESPEED_ON_DONE; // After the latest tx
		DBGLOG("<= SetSpeed: Q", 0);
		return (TRUE);
	}
	else
	if (Adapter->NumPacketsQueued > 1) {
		Adapter->changeSpeedAfterThisPkt = Adapter->LastTxQueue;
		Adapter->changeSpeedPending = CHANGESPEED_ON_Q;
		DBGLOG("<= SetSpeed: Qs", 0);
		return (TRUE);
	}


	// There's nothing pending TX or TX completion we must be
	// changing speed in RX mode.
	MK7ChangeSpeedNow(Adapter);

	return(TRUE);
}



//----------------------------------------------------------------------
// Procedure:	[MK7ChangeSpeedNow]
//
// Description:
//		Set the hw to a new speed.
//
// Actions:
//----------------------------------------------------------------------
VOID	MK7ChangeSpeedNow(PMK7_ADAPTER Adapter)
{
	UINT	i, bps;
	MK7REG	mk7reg,	mk7reg_cfg3, mk7reg_w;


	DBGLOG("=> MK7ChangeSpeedNow", 0);

	bps = Adapter->linkSpeedInfo->bitsPerSec;


	//****************************************
	// Clear IRENABLE Bit
	// This is the only writeable bit in this reg so just write it.
	//****************************************
	MK7Reg_Write(Adapter, R_ENAB, ~B_ENAB_IRENABLE);


	// NOTE: Workaround for potential hw problem where 0xFFFF is returned.
	// (See aLSO MK7EnableInterrupt & MK7DisableInterrupt)
	for (i=0; i<50; i++) {
		MK7Reg_Read(Adapter, R_CFG3, &mk7reg_cfg3);
		if (mk7reg_cfg3 != 0xFFFF) {
			break;
		}
	}
	ASSERT(i < 50);


	// Need distinguish between changing speed in RX or TX mode.
	// Prep the bit that says TX or RX
	if (Adapter->IOMode == TX_MODE) {
		mk7reg_w = 0x1000;
	}
	else {
		mk7reg_w = 0;
	}


	if (bps <= MAX_SIR_SPEED) {	// SIR
		if (Adapter->Wireless) {
	 		// WIRELESS: ... no INVERTTX
			mk7reg_w |= 0x0E18;
		}
		else {
			// WIRED: ENRX, DMA, small pkts, SIR, SIR RX filter, INVERTTX
			mk7reg_w |= 0x0E1A;
		}
		MK7Reg_Write(Adapter, R_CFG0, mk7reg_w);

		// Baud rate & pulse width
		i = Adapter->linkSpeedInfo->tableIndex;
		mk7reg = HwSirMirSpeedTable[i];
		MK7Reg_Write(Adapter, R_CFG2, mk7reg);

		mk7reg_cfg3 &= ~B_FAST_TX;
		MK7Reg_Write(Adapter, R_CFG3, mk7reg_cfg3);

		DBGLOG("   SIR", 0);
	}
	else
	if (bps < MIN_FIR_SPEED) {	// MIR
		if (Adapter->Wireless) {
	 		// WIRELESS: ... no INVERTTX
			mk7reg_w |= 0x0CA0;
		}
		else {
			// WIRED: ENRX, DMA, 16-bit CRC, MIR, INVERTTX
			mk7reg_w |= 0x0CA2;
		}
		MK7Reg_Write(Adapter, R_CFG0, mk7reg_w);
	
		// Baud rate & pulse width, & preamble
		i = Adapter->linkSpeedInfo->tableIndex;
		mk7reg = HwSirMirSpeedTable[i];
		mk7reg |= 0x0001;		// Preamble
		MK7Reg_Write(Adapter, R_CFG2, mk7reg);

		mk7reg_cfg3 |= B_FAST_TX;
		MK7Reg_Write(Adapter, R_CFG3, mk7reg_cfg3);

		DBGLOG("   MIR", 0);
	}
	else
	if (bps < VFIR_SPEED) {		// FIR
		if (Adapter->Wireless) {
	 		// WIRELESS: ... no INVERTTX
			mk7reg_w |= 0x0C40;
		}
		else {
			// WIRED: ENRX, DMA, 32-bit CRC, FIR, INVERTTX
			mk7reg_w |= 0x0C42;
		}
		MK7Reg_Write(Adapter, R_CFG0, mk7reg_w);

		MK7Reg_Write(Adapter, R_CFG2, 0x000A);		// 10 Preambles

		mk7reg_cfg3 |= B_FAST_TX;
		MK7Reg_Write(Adapter, R_CFG3, mk7reg_cfg3);

		DBGLOG("   FIR", 0);
	}
	else {						// VFIR
		// For testing 4Mbps in VFIR mode.
		//if (Adapter->Wireless) {
	 		// WIRELESS: ... no INVERTTX
		//	mk7reg_w |= 0x0C40;
		//}
		//else {
			// WIRED: ENRX, DMA, 32-bit CRC, FIR, INVERTTX
		//	mk7reg_w |= 0x0C42;
		//}
		//MK7Reg_Write(Adapter, R_CFG0, mk7reg_w);

		if (Adapter->Wireless) {
	 		// WIRELESS: ... no INVERTTX
			mk7reg_w |= 0x2C00;
		}
		else {
			// WIRED: VFIR, ENRX, DMA, 32-bit CRC, FIR, INVERTTX
			mk7reg_w |= 0x2C02;
		}
		MK7Reg_Write(Adapter, R_CFG0, mk7reg_w);


		MK7Reg_Write(Adapter, R_CFG2, 0x000A);	// 10 Preambles

		mk7reg_cfg3 |= B_FAST_TX;
		MK7Reg_Write(Adapter, R_CFG3, mk7reg_cfg3);

		DBGLOG("   VFIR", 0);
	}


	Adapter->CurrentSpeed = bps;


	//****************************************
	// Set IRENABLE Bit
	//****************************************
	MK7Reg_Write(Adapter, R_ENAB, B_ENAB_IRENABLE);


	//****************************************
	// PROMPT
	//****************************************
	MK7Reg_Write(Adapter, R_PRMT, 0);

	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\net\irda\mknet\sys\mk7.h ===
/*****************************************************************************
 **																			**
 **	COPYRIGHT (C) 2000, 2001 MKNET CORPORATION								**
 **	DEVELOPED FOR THE MK7100-BASED VFIR PCI CONTROLLER.						**
 **																			**
 *****************************************************************************/

/**********************************************************************

Module Name:
	MK7.H

Comments:
	Include file for the MK7100 controller. Also includes Phoenix stuff.
	

**********************************************************************/

#ifndef	_MK7_H
#define	_MK7_H

#include	<ndis.h>


#define	MK7REG	USHORT


#define	PHOENIX_REG_CNT		0x34	// 52
#define	PHOENIX_REG_SIZE	2		// 2 bytes
#define	MK7_IO_SIZE			(PHOENIX_REG_CNT * PHOENIX_REG_SIZE)
//#define MISC_REG_CNT		4
//#define MISC_REG_SIZE		2
//#define MK7_IO_SIZE		( (PHOENIX_REG_CNT * PHOENIX_REG_SIZE) + \
//							  (MISC_REG_CNT * MISC_REG_SIZE) )




//******************************
// Phoenix Definitions
//******************************

//
// Registers
//

#define	REG_BASE				0x00000000

#define	REG_RPRB_OFFSET			0x00	// Ring Pointer Readback
#define	REG_RBAU_OFFSET			0x02	// Ring Base Addr - Upper
#define	REG_RBAL_OFFSET			0x04	// Ring Base Addr - Lower
#define	REG_RSIZ_OFFSET			0x06	// Ring Size
#define	REG_PRMT_OFFSET			0x08	// PROMPT
#define	REG_ACMP_OFFSET			0x0A	// Addr Compare
#define	REG_TXCL_OFFSET			0x0C	// Clear TX Interrupt
#define	REG_RXCL_OFFSET			0x0D	// Clear RX Interrupt
#define	REG_CFG0_OFFSET			0x10	// Config Reg 0 (IR Config Reg 0)
#define	REG_SFLG_OFFSET			0x12	// SIR Flag
#define	REG_ENAB_OFFSET			0x14	// Enable
#define	REG_CPHY_OFFSET			0x16	// Config to Physical
#define	REG_CFG2_OFFSET			0x18	// Phy Config Reg 2 (IRCONFIG2)
#define	REG_MPLN_OFFSET			0x1A	// Max Packet Length
#define	REG_RCNT_OFFSET			0x1C	// Recv Byte Count
#define	REG_CFG3_OFFSET			0x1E	// Phy Config Reg 3 (IRCONFIG3)
#define REG_INTS_OFFSET			0x30	// Interrupt Status
#define	REG_GANA_OFFSET			0x31	// General & Analog Transceiver Control // B3.1.0-pre


#define	R_RPRB			(REG_BASE + REG_RPRB_OFFSET)
#define	R_RBAU			(REG_BASE + REG_RBAU_OFFSET)
#define	R_RBAL			(REG_BASE + REG_RBAL_OFFSET)
#define	R_RSIZ			(REG_BASE + REG_RSIZ_OFFSET)
#define	R_PRMT			(REG_BASE + REG_PRMT_OFFSET)
#define	R_ACMP			(REG_BASE + REG_ACMP_OFFSET)
#define R_TXCL			(REG_BASE + REG_TXCL_OFFSET)
#define R_RXCL			(REG_BASE + REG_RXCL_OFFSET)
#define	R_CFG0			(REG_BASE + REG_CFG0_OFFSET)
#define	R_SFLG			(REG_BASE + REG_SFLG_OFFSET)
#define	R_ENAB			(REG_BASE + REG_ENAB_OFFSET)
#define	R_CPHY			(REG_BASE + REG_CPHY_OFFSET)
#define	R_CFG2			(REG_BASE + REG_CFG2_OFFSET)
#define	R_MPLN			(REG_BASE + REG_MPLN_OFFSET)
#define	R_RCNT			(REG_BASE + REG_RCNT_OFFSET)
#define	R_CFG3			(REG_BASE + REG_CFG3_OFFSET)
#define	R_INTS			(REG_BASE + REG_INTS_OFFSET)
#define R_GANA			(REG_BASE + REG_GANA_OFFSET)


// Use the above definitions for register access or the
// following structure.
//
// (NOTE: This is useful if we used memory mapped access to the registers.)
//
//typedef struct _MK7REG {
//	USHORT	MK7REG_RPRB;
//	USHORT	MK7REG_RBAU;
//	USHORT	MK7REG_RBAL;
//	USHORT	MK7REG_RSIZ;
//	USHORT	MK7REG_RPMP;
//	USHORT	MK7REG_ACMP;
//	USHORT	MK7REG_CFG0;
//	USHORT	MK7REG_SFLG;
//	USHORT	MK7REG_ENAB;
//	USHORT	MK7REG_CPHY;
//	USHORT	MK7REG_CFG2;
//	USHORT	MK7REG_MPLN;
//	USHORT	MK7REG_RCNT;
//	USHORT	MK7REG_CFG3;
//	USHORT	MK7REG_INTM;
//	USHORT	MK7REG_INTE;
//} MK7REG, PMK7REG;



//
// Ring Entry Formats
//
// (A Ring entry is referred to as TRD (Transmit Ring Descriptor) &
// RRD (Receive Ring Descriptor)).
//

typedef	struct TRD {
	unsigned	count:16;
	unsigned	unused:8;
	unsigned	status:8;
	unsigned	addr:32;
} TRD, *PTRD;


typedef struct RRD {
	unsigned	count:16;
	unsigned	unused:8;
	unsigned	status:8;
	unsigned	addr:32;
} RRD, *PRRD;


// Bit mask definitions for the TX and RX Ring Buffer Descriptor Status field.
#define B_TRDSTAT_UNDER			0x01	// underrun
#define B_TRDSTAT_CLRENTX		0x04	// R/W REQ_TO_CLEAR_ENTX
#define B_TRDSTAT_FORCEUNDER	0x08	// R/W FORCE_UNDERRUN
#define B_TRDSTAT_NEEDPULSE		0x10	// R/W NEED_PULSE
#define B_TRDSTAT_BADCRC		0x20	// R/W BAD_CRC
#define B_TRDSTAT_DISTXCRC		0x40	// R/W DISTX-CRC
#define B_TRDSTAT_HWOWNS		0x80	// R/W HW OWNS

#define B_RRDSTAT_SIRBAD		0x04	// R SIR BAD (if SIR Filter is on)
#define B_RRDSTAT_OVERRUN		0x08	// R RCV FIFO overflow
#define B_RRDSTAT_LEN			0x10	// R Max length packet encountered
#define B_RRDSTAT_CRCERR		0x20	// R CRC_ERROR (16- or 32-bit)
#define B_RRDSTAT_PHYERR		0x40	// R PHY_ERROR (encoding error)
#define B_RRDSTAT_HWOWNS		0x80	// R/W HW OWNS

#define	B_CFG0_ENRX				0x0800	// ENTX - enable TX	[R_CFG0]
#define	B_CFG0_ENTX				0x1000	// ENRX - enable RX [R_CFG0]
#define	B_CFG0_INVTTX			0x0002	// INVERTTX


// Bits for TX & RX interrupt enable mask and Interrupt Status registers
// [R_INTS] (@ 0x30)
#define	B_TX_INTS				0x0001	// TX_int (bit 0) [R_INTS]
#define B_RX_INTS				0x0002	// RX_int (bit 1) [R_INTS]
#define B_TEST_INTS				0x0004	// TEST_int for testing (R/W)

// Enable RX & TX interrupts
#define	B_ENAB_INT				0x0100	// Enable/Dislabe both RX/TX interrupt (bit 8)
										// [R_CFG3]


// Bits in IR Enable Reg [R_ENAB] (@ 0x14)
#define	B_ENAB_IRENABLE		0x8000		// IR_ENABLE (bit 15) [R_ENAB]


// B3.1.0-pre This bit mask (0x0020) was set wrong.
// Bit for >SIR TX  (fast = >SIR)
#define	B_FAST_TX			0x0200		// IRCONFIG (bit 9) -- bit set to 0 - SIR
										//                  --     set to 1 - >SIR

// B3.1.0-pre New SEL0/1 power level control
#define B_GANA_SEL01		0x0003		// Bits 0 (SEL0) & 1 (SEL1)


// Ring Size settings
#define	RINGSIZE_4				0x00
#define	RINGSIZE_8				0x01
#define	RINGSIZE_16				0x03
#define	RINGSIZE_32				0x07
#define	RINGSIZE_64				0x0F

#define	RINGSIZE_RX4			(RINGSIZE_4  << 8)
#define	RINGSIZE_RX8			(RINGSIZE_8  << 8)
#define	RINGSIZE_RX16			(RINGSIZE_16 << 8)
#define	RINGSIZE_RX32			(RINGSIZE_32 << 8)
#define	RINGSIZE_RX64			(RINGSIZE_64 << 8)
#define	RINGSIZE_TX4			(RINGSIZE_4  << 12)
#define	RINGSIZE_TX8			(RINGSIZE_8  << 12)
#define	RINGSIZE_TX16			(RINGSIZE_16 << 12)
#define	RINGSIZE_TX32			(RINGSIZE_32 << 12)
#define	RINGSIZE_TX64			(RINGSIZE_64 << 12)


// Set IrDA speeds to IRCONFIG2
#define HW_SIR_SPEED_2400		((47<<10) |  (12<<5))
#define HW_SIR_SPEED_9600		((11<<10) |  (12<<5))
#define HW_SIR_SPEED_19200		((5<<10)  |  (12<<5))
#define HW_SIR_SPEED_38400		((2<<10)  |  (12<<5))
#define HW_SIR_SPEED_57600		((1<<10)  |  (12<<5))
#define HW_SIR_SPEED_115200		((12<<5))
// Additional defs
#define	HW_MIR_SPEED_576000		((1<<10)  |  (16<<5))
#define	HW_MIR_SPEED_1152000	((8<<5))


// RRD Macros
#define GrantRrdToHw(x)		(x->status = B_RRDSTAT_HWOWNS)
#define GrantTrdToHw(x)		(x->status = B_TRDSTAT_HWOWNS)
#define GrantRrdToDrv(x)	(x->status &= ~B_RRDSTAT_HWOWNS)
#define GrantTrdToDrv(x)	(x->status &= ~B_TRDSTAT_HWOWNS)
#define	HwOwnsRrd(x)		((x->status & B_RRDSTAT_HWOWNS))
#define HwOwnsTrd(x)		((x->status & B_TRDSTAT_HWOWNS))

#define	RrdError(x)			(x->status & 0x6C)		// PHY_ERROR, CRC_ERROR, Rx Overrun, Rx SIRBAD

#define	RrdAnyError(x)		(x->status & 0x7C)		// Any error at all (for debug)
#define	TrdError(x)			(x->status & 0x01)		// Underrun
#define	TrdAnyError(x)		(x->status & 0x01)		// Underrun

// Macros to access MK7 hw registers
// 16-bit registers
#if	!DBG
#define	MK7Reg_Write(adapter, _port, _val) \
	NdisRawWritePortUshort( (PUCHAR)(adapter->MappedIoBase+_port), (USHORT)(_val) )
#define	MK7Reg_Read(adapter, _port, _pval) \
	NdisRawReadPortUshort( (PUCHAR)(adapter->MappedIoBase+_port), (PUSHORT)(_pval) )
//#define	MK7Reg_Write(_port, _val) DEBUGSTR(("MK7Write\n"))
//#define	MK7Reg_Read(_port, _pval) DEBUGSTR(("MK7Read\n"))
#endif


#define MK7DisableIr(adapter)	(MK7Reg_Write(adapter, R_ENAB, ~B_ENAB_IRENABLE))
#define MK7EnableIr(adapter)	(MK7Reg_Write(adapter, R_ENAB, B_ENAB_IRENABLE))



#define	MK7OurInterrupt(x)	(x != 0)
#if DBG
#define	MK7RXInterrupt(x)	( (x & B_RX_INTS) || (x & B_TEST_INTS) )
#define	MK7TXInterrupt(x)	( (x & B_TX_INTS) || (x & B_TEST_INTS) )
#else
#define	MK7RXInterrupt(x)	(x & B_RX_INTS)
#define	MK7TXInterrupt(x)	(x & B_TX_INTS)
#endif

//******************************
// Phoenix End
//******************************



#include	"winpci.h"
#include	"mk7comm.h"
#include	"wincomm.h"
#include	"dbg.h"
#include	"queue.h"


#endif // _MK7_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\net\irda\mknet\sys\mk7comm.h ===
/*****************************************************************************
 **																			**
 **	COPYRIGHT (C) 2000, 2001 MKNET CORPORATION								**
 **	DEVELOPED FOR THE MK7100-BASED VFIR PCI CONTROLLER.						**
 **																			**
 *****************************************************************************/

/**********************************************************************

Module Name:
	MK7COMM.H

Comments:
	Include file for the MK7 driver.

**********************************************************************/

#ifndef	_MK7COMM_H
#define	_MK7COMM_H


//
// IrDA definitions
//

#define MAX_EXTRA_SIR_BOFS				48
#define	SIR_BOF_SIZE					1
#define	SIR_EOF_SIZE					1
#define ADDR_SIZE						1
#define CONTROL_SIZE					1
#define	MAX_I_DATA_SIZE					2048
#define	MAX_I_DATA_SIZE_ESC				(MAX_I_DATA_SIZE + 40)
#define SIR_FCS_SIZE					2
#define FASTIR_FCS_SIZE					4		// FIR/VFIR

// History:
//	B2.1.0 - Was 2; set to 10 to align to 4DW.
//  B3.1.0-pre - back to 2
//#define ALIGN_PAD						10		// buffer alignment
#define ALIGN_PAD						2		// buffer alignment


#define DEFAULT_TURNAROUND_usec 1000			// 1000 usec (1 msec)

typedef struct {
	enum baudRates tableIndex;
	UINT bitsPerSec;					// actual bits/sec
	UINT ndisCode;						// bitmask
} baudRateInfo;

enum baudRates {

	// SIR
	BAUDRATE_2400 = 0,
	BAUDRATE_9600,
	BAUDRATE_19200,
	BAUDRATE_38400,
	BAUDRATE_57600,
	BAUDRATE_115200,

	// MIR
	BAUDRATE_576000,
	BAUDRATE_1152000,

	// FIR
	BAUDRATE_4M,

	// VFIR
	BAUDRATE_16M,

	NUM_BAUDRATES	/* must be last */
};

#define DEFAULT_BAUD_RATE 9600

#define MAX_SIR_SPEED				115200
#define MIN_FIR_SPEED				4000000
#define	VFIR_SPEED					16000000

//
// End IrDA definitions
//



// TX/RX Ring settings
#define DEF_RING_SIZE		64
#define	MIN_RING_SIZE		4
#define	MAX_RING_SIZE		64
#define DEF_TXRING_SIZE		4
#define DEF_RXRING_SIZE		(DEF_TXRING_SIZE * 2)
#define	DEF_EBOFS			24
#define MIN_EBOFS			0
#define MAX_EBOFS			48
#define	HW_VER_1_EBOFS		5	// 4.1.0

#define	DEF_RCB_CNT			DEF_RING_SIZE	// !!RCB and TCB cnt must be the same!!
#define	DEF_TCB_CNT			DEF_RING_SIZE	// ALSO SEE MAX_ARRAY_xxx_PACKETS


// Alloc twice as many receive buffers as receive ring size because these buffs
// are pended to upper layer. Don't know when they may be returned.
#define	CalRpdSize(x)		(x * 2)			// Get RPD size given ring size
#define	NO_RCB_PENDING		0xFF

#define	RX_MODE				0
#define TX_MODE				1


// Set to hw for RX
#define	MK7_MAXIMUM_PACKET_SIZE			(MAX_EXTRA_SIR_BOFS + \
										 SIR_BOF_SIZE + \
										 ADDR_SIZE + \
										 CONTROL_SIZE + \
										 MAX_I_DATA_SIZE + \
										 SIR_FCS_SIZE + \
										 SIR_EOF_SIZE)

#define	MK7_MAXIMUM_PACKET_SIZE_ESC		(MAX_EXTRA_SIR_BOFS + \
										 SIR_BOF_SIZE + \
										 ADDR_SIZE + \
										 CONTROL_SIZE + \
										 MAX_I_DATA_SIZE_ESC + \
										 SIR_FCS_SIZE + \
										 SIR_EOF_SIZE)

// For RX memory allocation
//#define	RPD_BUFFER_SIZE					(MK7_MAXIMUM_PACKET_SIZE + ALIGN_PAD)
#define	RPD_BUFFER_SIZE					(MK7_MAXIMUM_PACKET_SIZE_ESC + ALIGN_PAD)

// For TX memory allocation
#define COALESCE_BUFFER_SIZE			(MK7_MAXIMUM_PACKET_SIZE_ESC + ALIGN_PAD)


// Not used?
#define MAX_TX_PACKETS 4
#define MAX_RX_PACKETS 4

#define SIR_BOF_TYPE		UCHAR
#define SIR_EXTRA_BOF_TYPE	UCHAR
#define SIR_EXTRA_BOF_SIZE	sizeof(SIR_EXTRA_BOF_TYPE)
#define SIR_EOF_TYPE		UCHAR
#define SIR_FCS_TYPE		USHORT
#define	SIR_BOF				0xC0
#define SIR_EXTRA_BOF		0xC0
#define SIR_EOF				0xC1
#define SIR_ESC				0x7D
#define SIR_ESC_COMP		0x20

// When FCS is computed on an IR packet with FCS appended, the result
// should be this constant.
#define GOOD_FCS ((USHORT) ~0xf0b8)


//
// Link list
//
typedef struct _MK7_LIST_ENTRY {
	LIST_ENTRY	Link;
} MK7_LIST_ENTRY, *PMK7_LIST_ENTRY;



//
// COALESCE -- Consolidate data for TX
//
typedef struct _COALESCE {
	MK7_LIST_ENTRY		Link;
	PVOID				OwningTcb;
	PUCHAR				CoalesceBufferPtr;
	ULONG				CoalesceBufferPhys;
} COALESCE, *PCOALESCE;




//
// Receive Packet Descriptor (RPD)
//
//   Each receive buffer has this control struct.
//
//   (We use this mainly because there doesn't seem to be a simple way
//    to obtain a buff's phy addr from its virtual addr.)
//
typedef struct _RPD {
	MK7_LIST_ENTRY	link;
	PNDIS_BUFFER	ReceiveBuffer;	// mapped buffer
	PNDIS_PACKET	ReceivePacket;	// mapped packet
	PUCHAR			databuff;		// virtual data buffer
	ULONG			databuffphys;	// physical data buffer
	USHORT			status;
	UINT			FrameLength;
} RPD, *PRPD;




//
// Receive Control Block (RCB)
//
//   Points to the corresponding RX Ring entry (RRD).
//
typedef struct _RCB {
	MK7_LIST_ENTRY	link;
	PRRD			rrd;		// RX ring descriptor - RBD
	ULONG			rrdphys;	// Phy addr of RX ring descriptor
	PRPD			rpd;		// Receive Packet Descriptor
} RCB, *PRCB;


//
// Transmit Control Block (TCB)
//
//   Points to the corresponding TX Ring entry (TRD).
//
//   NOTE: We have a link field. Chances are we don't need it
//   because the TCB (which is the software context for a TRD)
//   is indexed. For now we'll have a link field in case it's
//   needed.
//
typedef struct _TCB {
	MK7_LIST_ENTRY	link;
	PTRD			trd;		// TX Ring entry - Transmit Ring Descriptor
	ULONG			trdPhy;
	PUCHAR			buff;		// virtual data buffer
	ULONG			buffphy;	// physical data buffer
	// Stuff you get back from NdisQueryPacket()
	PNDIS_PACKET	Packet;
	UINT			PacketLength;
	UINT			NumPhysDesc;
	UINT			BufferCount;
	PNDIS_BUFFER	FirstBuffer;
	BOOLEAN			changeSpeedAfterThisTcb;
} TCB, *PTCB;




//
// MK7_ADAPTER
//
typedef struct _MK7_ADAPTER
{
#if DBG
	UINT					Debug;
	UINT					DbgTest;			// different debug/tests to run; 0=none
	UINT					DbgTestDataCnt;
#define DBG_QUEUE_LEN	4095   //0xfff
	UINT					DbgIndex;
	UCHAR					DbgQueue[DBG_QUEUE_LEN];

	UINT					DbgSendCallCnt;
	UINT					DbgSentCnt;
	UINT					DbgSentPktsCnt;

	UINT					LB;					// Loopback debug/test
	UINT					LBPktLevel;			// pass thru 1 out of this many
	UINT					LBPktCnt;

	NDIS_MINIPORT_TIMER		MK7DbgTestIntTimer;	// for interrupt testing
#endif

	// Handle given by NDIS when the Adapter registered itself.
	NDIS_HANDLE				MK7AdapterHandle;

	// 1st pkt queued for TX in deserialized miniport
	PNDIS_PACKET			FirstTxQueue;
	PNDIS_PACKET			LastTxQueue;
	UINT					NumPacketsQueued;

	// Save the most recent interrupt events because the reg
	// is cleared once it's read.
	MK7REG					recentInt;
	UINT					CurrentSpeed;		// bits/sec
	UINT					MaxConnSpeed;		// in 100bps increments
	UINT					AllowedSpeedMask;
	baudRateInfo			*linkSpeedInfo;
//	BOOLEAN					haveIndicatedMediaBusy;	// 1.0.0


	// Keep track of when to change speed.
	PNDIS_PACKET			changeSpeedAfterThisPkt;
	UINT					changeSpeedPending;
//#define	CHANGESPEED_ON_T	1		// change speed marked on TCB
#define	CHANGESPEED_ON_DONE	1		// change speed marked on Q
#define	CHANGESPEED_ON_Q	2		// change speed marked on Q


	// This info may come from the Registry
	UINT					RegNumRcb;			// # of RCB from the Registry
	UINT					RegNumTcb;			// # of TCB from the Registry
	UINT					RegNumRpd;			// RPD (RX Packet Descriptor) from Registry
	UINT					RegSpeed;			// IrDA speeds
	UINT					RegExtraBOFs;		// Extra BOFs based on 115.2kbps

	//******************************
	// RXs & TXs
	//******************************
//	UINT					RrdTrdSize;			// total RRD & TRD memory size
	PUCHAR					pRrdTrd;			// virtual address - aligned
	ULONG					pRrdTrdPhysAligned;	// physical address - aligned

	PUCHAR					RxTxUnCached;
	NDIS_PHYSICAL_ADDRESS	RxTxUnCachedPhys;
	UINT					RxTxUnCachedSize;

	UINT					RingSize;			// same for both RRD & TRD

	//******************************
	// RXs
	//******************************
	UINT					NumRcb;				// what we actually use
	PRCB					pRcb;				// start of RCB
	PUCHAR					pRrd;				// start of RRD ( = pRrdTrd)
	ULONG					pRrdPhys;			// start of phy RRD ( = pRrdTrdPhysAligned)
	PRCB					pRcbArray[MAX_RING_SIZE];
	UINT					nextRxRcbIdx;		// index of next RCB to process
	UINT					rcbPendRpdIdx;		// 1st RCB waiting for RPD
	UINT					rcbPendRpdCnt;		// keep cnt to help simplify code logic
	UINT					rcbUsed;			// RYM10-5 needed??

	UINT					NumRpd;				// actually allocated/used
	MK7_LIST_ENTRY			FreeRpdList;		// start of free list
// 4.0.1 BOC
	UINT					UsedRpdCount;		// num of Rpds that not yet return to driver
// 4.0.1 EOC.
	NDIS_HANDLE				ReceivePacketPool;
	NDIS_HANDLE				ReceiveBufferPool;

	PUCHAR					RecvCached;			// control structs
	UINT					RecvCachedSize;
	PUCHAR					RecvUnCached;		// data buffs
	UINT					RecvUnCachedSize;
	NDIS_PHYSICAL_ADDRESS	RecvUnCachedPhys;

	// 4.1.0 HwVersion
#define	HW_VER_1	1
#define HW_VER_2	2
	BOOLEAN					HwVersion;

	//******************************
	// TXs
	//******************************
	UINT					NumTcb;				// what we actually use
	PTCB					pTcb;				// start of TCB
	PUCHAR					pTrd;				// start of TRD (512 bytes from pRrd)
	ULONG					pTrdPhys;
	PTCB					pTcbArray[MAX_RING_SIZE];
	UINT					nextAvailTcbIdx;	// index of next avail in the ring to use for TX
	UINT					nextReturnTcbIdx;	// index of next that'll be returned on completion
	UINT					tcbUsed;
	BOOLEAN					writePending;		// RYM-2K-1TX

	PUCHAR					XmitCached;			// control structs
	UINT					XmitCachedSize;
	PUCHAR					XmitUnCached;		// data buffs - coalesce buffs
	UINT					XmitUnCachedSize;
	NDIS_PHYSICAL_ADDRESS	XmitUnCachedPhys;


	ULONG					MaxPhysicalMappings;

	// I/O port space (NOT memory mapped I/O)
	PUCHAR					MappedIoBase;
	UINT					MappedIoRange;


	// Adapter Information Variable (set via Registry entries)
	UINT					BusNumber;			//' BusNumber'
	USHORT					BusDevice;			// PCI Bus/Device #

	// timer structure for Async Resets
	NDIS_MINIPORT_TIMER		MK7AsyncResetTimer;	// 1.0.0

	NDIS_MINIPORT_TIMER		MinTurnaroundTxTimer;

	NDIS_MINIPORT_INTERRUPT	Interrupt;			// interrupt object

	NDIS_INTERRUPT_MODE 	InterruptMode;

	NDIS_SPIN_LOCK			Lock;

	UINT				 	NumMapRegisters;

	UINT					IOMode;

	UINT					Wireless;

	UINT					HangCheck;			// 1.0.0


	//******************************
	// Hardware capabilities
	//******************************
	// This is a mask of NDIS_IRDA_SPEED_xxx bit values.
	UINT supportedSpeedsMask;
	// Time (in microseconds) that must transpire between a transmit
	//and the next receive.
	UINT turnAroundTime_usec;
	// Extra BOF (Beginning Of Frame) characters required at the
	// start of each received frame.
	UINT extraBOFsRequired;


	//******************************
	// OIDs
	//******************************
	UINT	hardwareStatus;		// OID_GEN_HARDWARE_STATUS
	BOOLEAN	nowReceiving;		// OID_IRDA_RECEIVING
	BOOLEAN	mediaBusy;			// OID_IRDA_MEDIA_BUSY


	UINT					MKBaseSize;		// Total port size in bytes
	UINT    				MKBaseIo;		// Base I/O address
	UINT					MKBusType;		// 'BusType' (EISA or PCI)
	UINT					MKInterrupt;	// 'InterruptNumber'
	USHORT					MKSlot;			// 'Slot', PCI Slot Number
	

	// This variable should be initialized to false, and set to true
	// to prevent re-entrancy in our driver during reset spinlock and unlock
	// stuff related to checking our link status
	BOOLEAN					ResetInProgress;	

	NDIS_MEDIA_STATE		LinkIsActive;	// not used right now

	// save the status of the Memory Write Invalidate bit in the PCI command word
	BOOLEAN				MWIEnable;


	//
	// Put statistics here
	//


} MK7_ADAPTER, *PMK7_ADAPTER;


//Given a MiniportContextHandle return the PMK7_ADAPTER it represents.
#define PMK7_ADAPTER_FROM_CONTEXT_HANDLE(Handle) ((PMK7_ADAPTER)(Handle))


//================================================
// Global Variables shared by all driver instances
//================================================


// This constant is used for places where NdisAllocateMemory needs to be
// called and the HighestAcceptableAddress does not matter.
static const NDIS_PHYSICAL_ADDRESS HighestAcceptableMax =
	NDIS_PHYSICAL_ADDRESS_CONST(-1,-1);


#endif		// _MK7COMM.H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\net\irda\mknet\sys\precomp.h ===
/*****************************************************************************
 **																			**
 **	COPYRIGHT (C) 2000, 2001 MKNET CORPORATION								**
 **	DEVELOPED FOR THE MK7100-BASED VFIR PCI CONTROLLER.						**
 **																			**
 *****************************************************************************/

#include	"mk7.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\net\irda\mknet\sys\interrup.c ===
/*****************************************************************************
 **																			**
 **	COPYRIGHT (C) 2000, 2001 MKNET CORPORATION								**
 **	DEVELOPED FOR THE MK7100-BASED VFIR PCI CONTROLLER.						**
 **																			**
 *****************************************************************************/

/**********************************************************************

Module Name:
	INTERRUP.C

Procedures:
	MKMiniportIsr
	MKMiniportHandleInterrupt
	ProcessRXComp
	ProcessTXComp
	ProcessRXCompIsr
	ProcessTXCompIsr

Comments:



**********************************************************************/

#include	"precomp.h"
#pragma		hdrstop
#include	"protot.h"



//-----------------------------------------------------------------------------
// Procedure:	[MKMiniportIsr] (miniport)
//
// Description: This is the interrupt service routine running at interrupt level.
//				It checks to see if there is an interrupt pending. If yes, it
//				disables board interrupts and schedules HandleInterrupt callback.
//
// Arguments:
//		MiniportAdapterContext - The context value returned by the Miniport
//				when the adapter was initialized (see the call
//				NdisMSetAttributes). In reality, it is a pointer to MK7_ADAPTER.
//
// Returns:
//		InterruptRecognized - Returns True if the interrupt belonges to this
//				adapter, and false otherwise.
//		QueueMiniportHandleInterrupt - Returns True if we want a callback to
//				HandleInterrupt.
//
//-----------------------------------------------------------------------------
VOID
MKMiniportIsr(	OUT PBOOLEAN InterruptRecognized,
				OUT PBOOLEAN QueueMiniportHandleInterrupt,
				IN NDIS_HANDLE MiniportAdapterContext )
{	
	MK7REG	mk7reg, ReadInt;


	PMK7_ADAPTER Adapter = PMK7_ADAPTER_FROM_CONTEXT_HANDLE(MiniportAdapterContext);


	DBGLOG("=> INT", 0);

	//****************************************
	// Read the Interrupt Event Reg and save to context area for
	// DPC processing.
	//
	// IMPORTANT NOTE: The ISR runs at DIRQL level and is, thus, higher
	// proiority than other miniport routines. We need to be careful
	// about shared resources. Example: If our multi-pkt send is running
	// when an int occurs, the send routine can be preempted. If the ISR
	// and the send routine access shared resource then we have problems.
	//
	// We save the interrupt in recentInt because the interrupt event
	// register may be cleared upon a Read. (This has been verified.)
	//****************************************
	//MK7Reg_Read(Adapter, R_INTS, &Adapter->recentInt);
	MK7Reg_Read(Adapter, R_INTS, &ReadInt);
	if (MK7OurInterrupt(ReadInt)) {

		// Int enable should happen only after DPC is done.
		// Also disabling interrupt clears Interrupt Status.
		MK7DisableInterrupt(Adapter);

		Adapter->recentInt = ReadInt;

		MK7Reg_Read(Adapter, R_CFG3, &mk7reg);
			if ((mk7reg & 0x1000) != 0){
				mk7reg &= 0xEFFF;
				MK7Reg_Write(Adapter, R_CFG3, mk7reg);
				mk7reg |= 0x1000;
				MK7Reg_Write(Adapter, R_CFG3, mk7reg);
//				mk7reg = mk7reg; //For Debugging
			}

#if	DBG
		GDbgStat.isrCnt++;
		DBGLOG("   INT status", Adapter->recentInt);
#endif

		// Don't do TX processing in ISR. I saw a condition where SetSpeed()
		// was called while tcbused = 1. I set the change-speed flags correctly.
		// But the TX processing in ISR cleared tcbused resulting in the code
		// not chaning speed in DPC.
		// ProcessTXCompIsr(Adapter);

		ProcessRXCompIsr(Adapter);

		*InterruptRecognized = TRUE;
		*QueueMiniportHandleInterrupt = TRUE;
	}
	else {
		*InterruptRecognized = FALSE;
		*QueueMiniportHandleInterrupt = FALSE;
	}
}



//-----------------------------------------------------------------------------
// Procedure:	[MKMiniportHandleInterrupt]
//
// Description: This is the DPC for the ISR. It goes on to do RX & TX
//				completion processing.
//
// Arguments:
//		MiniportAdapterContext (miniport) - The context value returned by the
//				 Miniport when the adapter was initialized (see the call
//				NdisMSetAttributes). In reality, it is a pointer to MK7_ADAPTER.
//
// Returns: (none)
//-----------------------------------------------------------------------------
VOID
MKMiniportHandleInterrupt(NDIS_HANDLE MiniportAdapterContext)
{
	MK7REG	mk7reg;
	PMK7_ADAPTER Adapter = PMK7_ADAPTER_FROM_CONTEXT_HANDLE(MiniportAdapterContext);


	NdisAcquireSpinLock(&Adapter->Lock);

	DBGLOG("=> MKMiniportHandleInterrupt", Adapter->recentInt);

	//****************************************
	// DPC runs at Dispatch Level IRQL (just below ISR's DIRQL in proiority).
	// Note that recentInt can be modified in the ISR routine, which is
	// higher IRQL. But since this is DPC w/ int disabled, recentInt can
	// be safely queried.
	//****************************************
	ProcessTXComp(Adapter);
	ProcessRXComp(Adapter);

	Adapter->recentInt = 0;		// clear the saved int

	NdisReleaseSpinLock(&Adapter->Lock);
	MK7EnableInterrupt(Adapter);
}



//-----------------------------------------------------------------------------
// Procedure:	[ProcessRXComp]
//
// Description: This is the DPC for RX completions.
//
// Arguments:
//		Adapter - ptr to Adapter object instance
//
// Returns: (none)
//-----------------------------------------------------------------------------

VOID	ProcessRXComp(PMK7_ADAPTER Adapter)
{
	UINT			PacketArrayCount, i;
// 4.0.1 BOC
	UINT			PacketFreeCount;
// 4.0.1 EOC
	PNDIS_PACKET	PacketArray[MAX_ARRAY_RECEIVE_PACKETS];
	PRCB			rcb;
	PRRD			rrd;
	PRPD			rpd;
	UINT			rrdstatus;
	BOOLEAN			done=FALSE;
	BOOLEAN			gotdata=FALSE;
	MK7REG			intereg;
	UINT			rcvcnt;
// 4.0.1 BOC
	BOOLEAN			LowResource;
// 4.0.1 EOC


	// Process only if we get the corresponding int.
	if (!(Adapter->recentInt & B_RX_INTS)) {
		return;
	}

	DBGLOG("=> RX comp", 0);

#if DBG
	GDbgStat.rxIsrCnt++;
#endif


	// 1.0.0
	// If we have just started receiving a packet, indicate media-busy
	// to the protocol.
//    if (Adapter->mediaBusy && !Adapter->haveIndicatedMediaBusy) {
//   	    if (Adapter->CurrentSpeed > MAX_SIR_SPEED) {
//#if DBG
//			DBGLOG("Error: MKMiniportHandleInterrupt is in wrong state",
//	           	    Adapter->CurrentSpeed);
//#endif
//       	    ASSERT(0);
//        }
//   	    NdisMIndicateStatus(Adapter->MK7AdapterHandle,
//       	                    NDIS_STATUS_MEDIA_BUSY, NULL, 0);
//       NdisMIndicateStatusComplete(Adapter->MK7AdapterHandle);
		// RYM-5+
		// May need to protect this because ISR also writes to this?
//		Adapter->haveIndicatedMediaBusy = TRUE;
//    }



	rcb 		= Adapter->pRcbArray[Adapter->nextRxRcbIdx];
	rrd			= rcb->rrd;
	rrdstatus	= rrd->status;	// for debug

	do {
		PacketArrayCount = 0;
// 4.0.1 BOC
		LowResource = FALSE;
// 4.0.1 EOC.


// 4.0.1 BOC
		PacketFreeCount = 0;
// 4.0.1 EOC.
		// inner loop
		while ( !HwOwnsRrd(rrd) && 
				(PacketArrayCount < MAX_ARRAY_RECEIVE_PACKETS) ) {
// 4.0.1 BOC
			if (QueueEmpty(&Adapter->FreeRpdList))
				{
					break;
		        }
// 4.0.1 EOC.

#if	DBG
			// DBG_STAT
			if (RrdAnyError(rrd)) {
				GDbgStat.rxErrCnt++;
				GDbgStat.rxErr |= rrd->status;
				DBGSTATUS1("   RX err: %x \n\r", rrd->status);
			}
			if (Adapter->recentInt & B_RX_INTS)
				GDbgStat.rxComp++;
			else
				GDbgStat.rxCompNoInt++;
#endif

			if (RrdError(rrd)) {
				// If error just give RRD back to hw and continue.
				// (NOTE: This may indicate errors for MIR & FIR only.
				//		The sw does the FCS for SIR.)
				// (Note that hw may not detect all SIR errors.)
				rrd->count = 0;
				GrantRrdToHw(rrd);
				// Next receive to read from
				Adapter->nextRxRcbIdx++;
				Adapter->nextRxRcbIdx %= Adapter->NumRcb;
				rcb = Adapter->pRcbArray[Adapter->nextRxRcbIdx];
				rrd = rcb->rrd;
				rrdstatus = rrd->status;	// for debug
//				break;		// this to do 1 rx per int

				DBGLOG("   RX err", 0);

				continue;	// this to do > 1 rx per int
			}
				

			// Additional software processing for SIR frames
			if (Adapter->CurrentSpeed <= MAX_SIR_SPEED) {
				if (!ProcRXSir(rcb->rpd->databuff, (UINT)rrd->count)) {
					// If error just give RRD back to hw and continue.
					rrd->count = 0;
					GrantRrdToHw(rrd);
					// Next receive to read from
					Adapter->nextRxRcbIdx++;
					Adapter->nextRxRcbIdx %= Adapter->NumRcb;
					rcb = Adapter->pRcbArray[Adapter->nextRxRcbIdx];
					rrd = rcb->rrd;
					rrdstatus = rrd->status;	// for debug
#if	DBG
					GDbgStat.rxErrCnt++;
					GDbgStat.rxErrSirCrc++;
#endif
					//	break;		// this to do 1 rx per int

					DBGLOG("   RX err", 0);

					continue;	// this to do > 1 rx per int
				}
			}


			// Remove count of FCS bytes:
			//	SIR/MIR = 2 (16 bits)
			//	FIR/VFIR = 4 (32 bits)
			if (Adapter->CurrentSpeed < MIN_FIR_SPEED) {
				rcvcnt = (UINT) rrd->count - SIR_FCS_SIZE;
				DBGLOG("   RX comp (slow)", 0);
			}
			else {
				rcvcnt = (UINT) rrd->count - FASTIR_FCS_SIZE;
				DBGLOG("   RX comp (fast)", 0);
			}


			NdisAdjustBufferLength(rcb->rpd->ReceiveBuffer, rcvcnt);



#if	DBG
			if (rcvcnt > GDbgStat.rxLargestPkt) {
				GDbgStat.rxLargestPkt = rcvcnt;
			}

//			NdisGetCurrentSystemTime((PLARGE_INTEGER)&GDbgTARspTime[GDbgTATimeIdx]);
//			GDbgTATime[GDbgTATimeIdx] = GDbgTARspTime[GDbgTATimeIdx] -
//				GDbgTACmdTime[GDbgTATimeIdx];
//			GDbgTATimeIdx++;
//			GDbgTATimeIdx %= 1000;	// wrap around
#endif


			PacketArray[PacketArrayCount] = rcb->rpd->ReceivePacket;
// 4.0.1 BOC
			if (((Adapter->NumRpd - Adapter->UsedRpdCount-Adapter->NumRcb) <= 4)|| LowResource==TRUE) {
				NDIS_SET_PACKET_STATUS(PacketArray[PacketArrayCount], NDIS_STATUS_RESOURCES);
				LowResource = TRUE;
				PacketFreeCount++;
			}
			else {
				// NDIS_SET_PACKET_STATUS(PacketArray[PacketArrayCount], NDIS_STATUS_SUCCESS);
				NDIS_SET_PACKET_STATUS(PacketArray[PacketArrayCount], NDIS_STATUS_SUCCESS);
			}
// 4.0.1 EOC

			PacketArrayCount++;

// 4.0.1 BOC
			Adapter->UsedRpdCount++;
// 4.0.1 EOC

			// unbind the one we just indicated to upper layer
			rcb->rpd = (PRPD)NULL;
			rcb->rrd->addr = 0;


			// get a new one for the next rx
			rpd = (PRPD) QueuePopHead(&Adapter->FreeRpdList);

// 4.0.1 BOC
			ASSERT(!(rpd == (PRPD)NULL));
//			if (rpd == (PRPD)NULL) {

				//****************************************
				// If there's no existing RCB that's waiting for a
				// RPD, set the start of waiting RCBs to this one.
				//****************************************
//				if (Adapter->rcbPendRpdCnt == 0) {
//					Adapter->rcbPendRpdIdx = Adapter->nextRxRcbIdx;
//				}
//				Adapter->rcbPendRpdCnt++;
//
//#if DBG
//				GDbgStat.rxNoRpd++;
//#endif
//			}
//			else {
// 4.0.1 EOC
				// bind new RDP-Packet to RCB-RRD
				rcb->rpd = rpd;
				rcb->rrd->addr = rpd->databuffphys;
				rcb->rrd->count = 0;
				GrantRrdToHw(rcb->rrd);
// 4.0.1 BOC
//				}
// 4.0.1 EOC.

			// Next receive to read from
			Adapter->nextRxRcbIdx++;
			Adapter->nextRxRcbIdx %= Adapter->NumRcb;


			rcb = Adapter->pRcbArray[Adapter->nextRxRcbIdx];
			rrd = rcb->rrd;
			rrdstatus = rrd->status;	// for debug

		}	// while


		if (PacketArrayCount >= MAX_ARRAY_RECEIVE_PACKETS) {
			DBGLOG("   RX max indicate", 0);
		}


		//****************************************
		// RYM-5+
		// NOTE: This controls whether we poll the next ring buffers
		//		 for data after serviceing the current ring buffer that
		//		 caused the original RX int. The current int scheme
		//		 is to get 1 rx buffer per int. So the following lines
		// 		 are replaced with a 1 rx per int logic.
		// **We're done when we run into the 1st Ring entry that
		// **we have no ownership.
		//****************************************
		if (HwOwnsRrd(rrd))
			done = TRUE;
//		done = TRUE;

		// Indicate away
		if(PacketArrayCount) {
			NdisReleaseSpinLock(&Adapter->Lock);
			NdisMIndicateReceivePacket(Adapter->MK7AdapterHandle,
							PacketArray,
							PacketArrayCount);
#if	DBG
			GDbgStat.rxPktsInd += PacketArrayCount;
#endif
			gotdata = TRUE;

			NdisAcquireSpinLock(&Adapter->Lock);
			//DBGLOG("   ProcessRXInterrupt: indicated Packet(s)", PacketArrayCount);
		}


		//****************************************
		// Check Packet status on return from Indicate. Pending means
		// NDIS-upper layer still holds it, else it's ours.
		//****************************************
		// Don't do this for deserialized driver.
//		for (i=0; i<PacketArrayCount; i++ ) {
//			NDIS_STATUS ReturnStatus;
//
//			ReturnStatus = NDIS_GET_PACKET_STATUS(PacketArray[i]);
//			
			// recover the RPD
//			rpd = *(PRPD *)(PacketArray[i]->MiniportReserved);
//			
//			if (ReturnStatus != NDIS_STATUS_PENDING) {
//				ProcReturnedRpd(Adapter, rpd);
//			}
//		}
// 4.0.1 BOC
		for (i=PacketArrayCount-PacketFreeCount; i<PacketArrayCount; i++){
			rpd = *(PRPD *)(PacketArray[i]->MiniportReserved);
			ProcReturnedRpd(Adapter, rpd);
			Adapter->UsedRpdCount--;
		}
// 4.0.1 EOC.

	} while (!done);

	Adapter->nowReceiving = FALSE;

}


//-----------------------------------------------------------------------------
// Procedure:   [ProcessTXComp]
//
// Description: TX complete processing in DPC. This is very similar to
//		ProcessTXCompIsr(), the main difference being we also process the TX
//		queue here and perform TXs as necessary.
//
// Arguements:	Adapter.
//
// Result:		(none)
//-----------------------------------------------------------------------------
VOID	ProcessTXComp(PMK7_ADAPTER Adapter)
{
    PTCB			tcb;
	MK7REG			mk7reg;
	NDIS_STATUS		SendStatus;
	PNDIS_PACKET	QueuePacket;


	// Process only if we get the corresponding int.
	if (!(Adapter->recentInt & B_TX_INTS)) {
		return;
	}


	DBGLOG("=> TX comp", 0);


#if DBG
		GDbgStat.txIsrCnt++;
#endif

	// Debug
	if (Adapter->CurrentSpeed > MAX_SIR_SPEED) {
		DBGLOG("   TX comp (fast)", 0);
	}
	else {
		DBGLOG("   TX comp (slow)", 0);
	}


	// Simplified change speed
	if (Adapter->changeSpeedPending == CHANGESPEED_ON_DONE) {
		// Note: We're changing speed in TX mode.
		MK7ChangeSpeedNow(Adapter);
		Adapter->changeSpeedPending = 0;
	}


	while (Adapter->tcbUsed > 0) {
		tcb = Adapter->pTcbArray[Adapter->nextReturnTcbIdx];

		if ( !HwOwnsTrd(tcb->trd) ) {
#if	DBG
			if (TrdAnyError(tcb->trd)) {
				GDbgStat.txErrCnt++;
				GDbgStat.txErr |= tcb->trd->status;
				DBGSTATUS1("   TX err: %x \n\r", tcb->trd->status);
			}
			if (Adapter->recentInt & B_TX_INTS)
				GDbgStat.txComp++;
			else
				GDbgStat.txCompNoInt++;
#endif
			tcb->trd->count = 0; 


			// For each completing TX there's a corresponding q'd pkt.
			// We release it here.
			QueuePacket = Adapter->FirstTxQueue;
			DequeuePacket(Adapter->FirstTxQueue, Adapter->LastTxQueue);
			Adapter->NumPacketsQueued--;
			NDIS_SET_PACKET_STATUS(QueuePacket, NDIS_STATUS_SUCCESS);
			NdisMSendComplete(	Adapter->MK7AdapterHandle,
								QueuePacket,
								NDIS_STATUS_SUCCESS);
			Adapter->HangCheck = 0;			// 1.0.0
			Adapter->nextReturnTcbIdx++;
			Adapter->nextReturnTcbIdx %= Adapter->NumTcb;
			Adapter->tcbUsed--;
		}
		else {
			DBGLOG("   Not our TCB; but tcbUsed>0", 0);
			break;
		}
	}


	// No resource even if we have more to send. Return now & let subsequent
	// TX completes keep the ball rolling.
	if (Adapter->tcbUsed >= Adapter->NumTcb) {
		// NdisReleaseSpinLock(&Adapter->Lock);
		return;
	}


	// If no TXs queued and all TXs are done, then switch to RX mode.
    if ( (!Adapter->FirstTxQueue) && (Adapter->tcbUsed == 0) ) {
		MK7SwitchToRXMode(Adapter);
		return;
    }


	// Send the q'd pkts until all done or until all TX ring buffers are used up.
	//while(Adapter->FirstTxQueue) {
	if (Adapter->FirstTxQueue) {

#if	DBG
		GDbgStat.txProcQ++;
#endif

		DBGLOG("   Proc Q", 0);

		QueuePacket = Adapter->FirstTxQueue;
		SendStatus = SendPkt(Adapter, QueuePacket);
	}
}


//-----------------------------------------------------------------------------
// Procedure:   [ProcessRXCompIsr]
//
// Description: Some RX complete processing in ISR.
//
// Arguements:	Adapter.
//
// Result:		(none)
//-----------------------------------------------------------------------------
VOID	ProcessRXCompIsr(PMK7_ADAPTER Adapter)
{

	// 4.1.0 Back for HW_VER_1 support
	if (Adapter->recentInt & B_RX_INTS) {
		Adapter->nowReceiving=TRUE;
//		if (!Adapter->mediaBusy) {
			// mediaBusy: IrLAP clears mediaBusy (via OID) to indicate
			// it wants to be notified when media becomes busy. Here
			// we detect it is cleared. We then set it and clear
			// haveIndicatedMediaBusy so we do notify later in DPC.
//			Adapter->mediaBusy = TRUE;
//			Adapter->haveIndicatedMediaBusy = FALSE;
//			Adapter->nowReceiving = TRUE;
//		}
	}
}



//-----------------------------------------------------------------------------
// Procedure:   [ProcessTXCompIsr]
//
// Description: TX complete processing in ISR. This is very similar to
//		ProcessTXComp() except we don't start any TX's here.
//
// Arguements:	Adapter.
//
// Result:		(none)
//-----------------------------------------------------------------------------
VOID	ProcessTXCompIsr(PMK7_ADAPTER Adapter)
{
    PTCB	tcb;
	MK7REG	mk7reg;

	//******************************
	// Whether or not there was a TX-completion interrupt, we do some
	// processing here in case ever the driver or hw missed an
	// interrupt previously.
	//
	// We loop until all tcb's are returned (tcbUsed == 0) or we run into
	// a TX ring buff that the hw still owns (HwOwnsTrd()). When we leave
	// here, we should have processed all current TX completions based on
	// the TX ownership bit. We switch to RX mode ONLY after all TX are
	// completed (either here in the ISR or in DPC).
	//******************************


	while (Adapter->tcbUsed > 0) {
		tcb = Adapter->pTcbArray[Adapter->nextReturnTcbIdx];

		if ( !HwOwnsTrd(tcb->trd) ) {
#if	DBG
			if (TrdAnyError(tcb->trd)) {
				GDbgStat.txErrCnt++;
				GDbgStat.txErr |= tcb->trd->status;
				DBGSTATUS1("   TX err: %x \n\r", tcb->trd->status);
			}
			if (Adapter->recentInt & B_TX_INTS)
				GDbgStat.txComp++;
			else
				GDbgStat.txCompNoInt++;
#endif
			tcb->trd->count = 0; 
			Adapter->nextReturnTcbIdx++;
			Adapter->nextReturnTcbIdx %= Adapter->NumTcb;
			Adapter->tcbUsed--;
		}
		else {
			return;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\net\irda\mknet\sys\mkmini.c ===
/*****************************************************************************
 **																			**
 **	COPYRIGHT (C) 2000, 2001 MKNET CORPORATION								**
 **	DEVELOPED FOR THE MK7100-BASED VFIR PCI CONTROLLER.						**
 **																			**
 *****************************************************************************/

/*****************************************************************************

Module Name:
	MKMINI.C

Routines:
	MKMiniportReturnPackets
	MKMiniportCheckForHang
	MKMiniportHalt
	MKMiniportShutdownHandler
	MKMiniportInitialize
	MKMiniportReset
	(MK7EnableInterrupt & Disable in MK7COMM.C.)
	DriverEntry

Comments:
	Contains most NDIS API routines supplied to Windows by the miniport.

*****************************************************************************/

#include	"precomp.h"
#pragma		hdrstop
#include	"protot.h"


// Globals to help debug/test
PMK7_ADAPTER	GAdapter;




//-----------------------------------------------------------------------------
// Procedure:	[MKMiniportReturnPackets]
//
// Description: NDIS returns a previously indicated pkt by calling this routine.
//
// Arguments:
//		IN NDIS_HANDLE MiniportAdapterContext
//			- a context version of our Adapter pointer
//		IN NDIS_PACKET Packet
//			- the packet that is being freed
//
// Returns:		(none)
//
//-----------------------------------------------------------------------------
VOID MKMiniportReturnPackets(	NDIS_HANDLE  MiniportAdapterContext,
								PNDIS_PACKET Packet)
{
	PMK7_ADAPTER	Adapter;
	PRPD			rpd;
	PRCB			rcb;

	//****************************************
	// - SpinLock brackets the FreeList resource.
	// - Recover the RPD from the returned pkt, then return
	//   the RPD to the FreeList.
	//****************************************

	Adapter = PMK7_ADAPTER_FROM_CONTEXT_HANDLE(MiniportAdapterContext);

	NdisAcquireSpinLock(&Adapter->Lock);

	ASSERT(Packet);

#if	DBG
	GDbgStat.rxPktsRtn++;
#endif

	rpd = *(PRPD *)(Packet->MiniportReserved);

	ASSERT(rpd);

	ProcReturnedRpd(Adapter, rpd);

// 4.0.1 BOC
	Adapter->UsedRpdCount--;
// 4.0.1 EOC

	NdisReleaseSpinLock(&Adapter->Lock);
}


//-----------------------------------------------------------------------------
// Procedure:	[MKMiniportCheckForHang]
//
// Description: This procedure does not do much for now.
//
// Arguments:
//		MiniportAdapterContext (both) - pointer to the adapter object data area
//
// Returns:
//		FALSE or TRUE
//-----------------------------------------------------------------------------
BOOLEAN MKMiniportCheckForHang(NDIS_HANDLE MiniportAdapterContext)
{
	PMK7_ADAPTER Adapter;

	Adapter = PMK7_ADAPTER_FROM_CONTEXT_HANDLE(MiniportAdapterContext);

	NdisAcquireSpinLock(&Adapter->Lock);
	// DbgPrint(" ==> Hang Check\n\r");
	if (Adapter->IOMode == TX_MODE) {
		Adapter->HangCheck++;
		if (Adapter->HangCheck >= 3) {
			NdisReleaseSpinLock(&Adapter->Lock);
			return(TRUE);
		}
	}
	NdisReleaseSpinLock(&Adapter->Lock);

	return(FALSE);
}


//-----------------------------------------------------------------------------
// Procedure:	[MKMiniportHalt]
//
// Description: Halts our hardware. We disable interrupts as well as the hw
//				itself. We release other Windows resources such as allocated
//				memory and timers.
//
// Arguments:
//		MiniportAdapterContext - pointer to the adapter object data area.
//
// Returns:		(none)
//-----------------------------------------------------------------------------
VOID MKMiniportHalt(NDIS_HANDLE MiniportAdapterContext)
{
	PMK7_ADAPTER Adapter;
	BOOLEAN		Cancelled;


	DBGFUNC("  MKMiniportHalt");

	Adapter = PMK7_ADAPTER_FROM_CONTEXT_HANDLE(MiniportAdapterContext);

	MK7DisableInterrupt(Adapter);
	MK7DisableIr(Adapter);

    Adapter->hardwareStatus = NdisHardwareStatusClosing;


	// check to make sure there are no outstanding transmits
	while(Adapter->FirstTxQueue) {
		PNDIS_PACKET QueuePacket = Adapter->FirstTxQueue;

		Adapter->NumPacketsQueued--;
		DequeuePacket(Adapter->FirstTxQueue, Adapter->LastTxQueue);

		NDIS_SET_PACKET_STATUS(QueuePacket, NDIS_STATUS_FAILURE);
		NdisMSendComplete(
			Adapter->MK7AdapterHandle,
			QueuePacket,
			NDIS_STATUS_FAILURE);
	}


	// deregister shutdown handler
	NdisMDeregisterAdapterShutdownHandler(Adapter->MK7AdapterHandle);

	// Free the interrupt object
	NdisMDeregisterInterrupt(&Adapter->Interrupt);

	NdisMCancelTimer(&Adapter->MinTurnaroundTxTimer, &Cancelled);

	NdisFreeSpinLock(&Adapter->Lock);

	// Free the entire adapter object, including the shared memory structures.
	FreeAdapterObject(Adapter);
}

//-----------------------------------------------------------------------------
// Procedure:	[MKMiniportShutdownHandler]
//
// Description: Removes an adapter instance that was previously initialized.
//		To Shutdown simply Disable interrupts.	Since the system is shutting
//		down there is no need to release resources (memory, i/o space, etc.)
//		that the adapter instance was using.
//
// Arguments:
//		MiniportAdapterContext - pointer to the adapter object data area.
//
// Returns:		(none)
//-----------------------------------------------------------------------------
VOID MKMiniportShutdownHandler(NDIS_HANDLE MiniportAdapterContext)

{
	PMK7_ADAPTER Adapter;

	Adapter = PMK7_ADAPTER_FROM_CONTEXT_HANDLE(MiniportAdapterContext);

	MK7DisableInterrupt(Adapter);
}

//-----------------------------------------------------------------------------
// Procedure:	[MKMiniportInitialize] (only single adapter support for now)
//
// Description: This routine is called once per supported adapter card in the
//		system. This routine is responsible for initializing each adapter.
//		This includes parsing all of the necessary parameters from the registry,
//		allocating and initializing shared memory structures, configuring the
//		MK7100 chip, registering the interrupt, etc.
//
// Arguments:
//		OpenErrorStatus (mini) - Returns more info about any failure
//		SelectedMediumIndex (mini) - Returns the index in MediumArray of the
//									 medium that the miniport is using
//		MediumArraySize (mini) - An array of medium types that the driver
//								 supports
//		MiniportAdapterHandle (mini) - pointer to the adapter object data area.
//
//		WrapperConfigurationContext (both) - A value that we will pass to
//											 NdisOpenConfiguration.
//
//
// Returns:
//		NDIS_STATUS_SUCCESS - If the adapter was initialized successfully.
//		<not NDIS_STATUS_SUCCESS> - If for some reason the adapter didn't
//									initialize
//-----------------------------------------------------------------------------
NDIS_STATUS
MKMiniportInitialize(PNDIS_STATUS OpenErrorStatus,
			   PUINT SelectedMediumIndex,
			   PNDIS_MEDIUM MediumArray,
			   UINT MediumArraySize,
			   NDIS_HANDLE MiniportAdapterHandle,
			   NDIS_HANDLE WrapperConfigurationContext)
{
	ULONG				i;
	NDIS_STATUS			Status;
	PMK7_ADAPTER		Adapter;
	NDIS_HANDLE			ConfigHandle;
	NDIS_INTERFACE_TYPE IfType;
	PVOID				OverrideNetAddress;
	MK7REG				mk7reg;


	DBGFUNC("  MKMiniportInitialize");

	//****************************************
	// We're an IrDA device. Exit w/ error if type not passed in.
	//****************************************
	for (i = 0; i < MediumArraySize; i++) {
		if (MediumArray[i] == NdisMediumIrda)
			break;
	}

	if (i == MediumArraySize) {
		DBGSTR(("ERROR: IrDA Media type not found.\n"));
		DBGLOG("=> MKMiniportInitialize (ERR): IrDA not found", 0);
		return (NDIS_STATUS_UNSUPPORTED_MEDIA);
	}

	*SelectedMediumIndex = i;

	//****************************************
	// Allocate the Adapter Object, exit if error.
	// (Cacheable, non-paged system memory)
	//****************************************
	Status = ALLOC_SYS_MEM(&Adapter, sizeof(MK7_ADAPTER));
	if (Status != NDIS_STATUS_SUCCESS) {
		DBGSTR(("ERROR: ADAPTER Allocate Memory failed (Status = 0x%x)\n", Status));
		DBGLOG("<= MKMiniportInitialize: (ERR - 1)", 0);
		return (Status);
	}
	NdisZeroMemory(Adapter, sizeof(MK7_ADAPTER));
	Adapter->MK7AdapterHandle = MiniportAdapterHandle;

	GAdapter = Adapter;

    Adapter->hardwareStatus = NdisHardwareStatusInitializing;

	//****************************************
	// Process the Registry -- Get config settings, etc.
	//****************************************
	Status = ProcessRegistry(Adapter, WrapperConfigurationContext);	
	if (Status != NDIS_STATUS_SUCCESS) {
		FreeAdapterObject(Adapter);
		DBGSTR(("ERROR: ProcessRegistry() \n"));
		DBGLOG("<= MKMiniportInitialize: (ERR - 2)", 0);
		return (NDIS_STATUS_FAILURE);
	}


	//****************************************
	// Let NDIS know kind of driver and features we support
	//****************************************
	IfType = NdisInterfacePci;

	NdisMSetAttributesEx(
		Adapter->MK7AdapterHandle,
		(NDIS_HANDLE) Adapter,
		0,
		(ULONG) NDIS_ATTRIBUTE_DESERIALIZE | NDIS_ATTRIBUTE_BUS_MASTER,
		IfType );


	//****************************************
	// Claim the physical Adapter for this Adapter object. We call on
	// NdisMPciAssignResources to find our assigned resources.
	//****************************************
	if (ClaimAdapter(Adapter, WrapperConfigurationContext) != NDIS_STATUS_SUCCESS) {
		FreeAdapterObject(Adapter);
		DBGSTR(("ERROR: No adapter detected\n"));
		DBGLOG("<= MKMiniportInitialize: (ERR - 3)", 0);
		return (NDIS_STATUS_FAILURE);
	}


	//****************************************
	// Set up the MK7 register I/O mapping w/ NDIS, interrupt mode, etc.
	//****************************************
	Status = SetupAdapterInfo(Adapter);
	if (Status != NDIS_STATUS_SUCCESS) {
		FreeAdapterObject(Adapter);
		DBGSTR(("ERROR: I/O Space allocation failed (Status = 0x%X)\n",Status));
		DBGLOG("<= MKMiniportInitialize: (ERR - 4)", 0);
		return(NDIS_STATUS_FAILURE);
	}


	//****************************************
	// Allocate & initialize memory/buffer needs.
	//****************************************
	Status = AllocAdapterMemory(Adapter);
	if (Status != NDIS_STATUS_SUCCESS) {

        MKLogError(Adapter, EVENT_10, NDIS_ERROR_CODE_OUT_OF_RESOURCES, 0);
		DBGSTR(("ERROR: Shared Memory Allocation failed (Status = 0x%x)\n", Status));
		DBGLOG("<= MKMiniportInitialize: (ERR - 5)", 0);

		FreeAdapterObject(Adapter);

		return (NDIS_STATUS_FAILURE);
	}

	
	// 4.1.0 Check hw version.
	MK7Reg_Read(Adapter, R_CFG3, &mk7reg);
	if ((mk7reg & 0x1000) != 0){
		mk7reg &= 0xEFFF;
		MK7Reg_Write(Adapter, R_CFG3, mk7reg);
		mk7reg |= 0x1000;
		MK7Reg_Write(Adapter, R_CFG3, mk7reg);
		MK7Reg_Read(Adapter, R_CFG3, &mk7reg);
		if ((mk7reg & 0x1000) != 0)
			Adapter->HwVersion = HW_VER_1;
		else
			Adapter->HwVersion = HW_VER_2;
	}
	else{
		Adapter->HwVersion = HW_VER_2;
	}


	//****************************************
	// Disable interrupts while we finish with the initialization
	// Must AllocAdapterMemory() before you can do this.
	//****************************************
	MK7DisableInterrupt(Adapter);


	//****************************************
	// Register our interrupt with the NDIS wrapper, hook our interrupt
	// vector, & use shared interrupts for our PCI adapters
	//****************************************
	Status = NdisMRegisterInterrupt(&Adapter->Interrupt,
		Adapter->MK7AdapterHandle,
		Adapter->MKInterrupt,
		Adapter->MKInterrupt,
		TRUE,						// call ISR each time NIC interrupts
		TRUE, 						// shared irq 
		Adapter->InterruptMode);	// NdisInterruptLatched, NdisInterruptLevelSensitive

	if (Status != NDIS_STATUS_SUCCESS) {
		FreeAdapterObject(Adapter);
        MKLogError(Adapter,
            EVENT_0,
            NDIS_ERROR_CODE_INTERRUPT_CONNECT,
            (ULONG) Adapter->MKInterrupt);
		DBGLOG("<= MKMiniportInitialize: (ERR - 6)", 0);
		return (NDIS_STATUS_FAILURE);
	}



#if	DBG
	DbgTestInit(Adapter);
#endif


	//****************************************
	// allocate a spin lock
	//****************************************
	NdisAllocateSpinLock(&Adapter->Lock);


	Adapter->HangCheck = 0;
	Adapter->nowReceiving=FALSE;	// 4.1.0


	//****************************************
	// Setup and initialize the transmit and receive structures then
	// init the adapter
	//****************************************
	SetupTransmitQueues(Adapter, TRUE);

	SetupReceiveQueues(Adapter);

	if (!InitializeAdapter(Adapter)) {
		FreeAdapterObject(Adapter);
		NdisMDeregisterInterrupt(&Adapter->Interrupt);

		DBGSTR(("ERROR: InitializeAdapter Failed.\n"));
		DBGLOG("<= MKMiniportInitialize: (ERR - 7)", 0);
		return (NDIS_STATUS_FAILURE);
	}


	//****************************************
	// Register a shutdown handler
	//****************************************
	NdisMRegisterAdapterShutdownHandler(Adapter->MK7AdapterHandle,
		(PVOID) Adapter,
		(ADAPTER_SHUTDOWN_HANDLER) MKMiniportShutdownHandler);

	StartAdapter(Adapter);
	MK7EnableInterrupt(Adapter);

	Adapter->hardwareStatus = NdisHardwareStatusReady;

	DBGSTR(("MKMiniportInitialize: Completed Init Successfully\n"));
	DBGLOG("<= MKMiniportInitialize", 0);
	return (NDIS_STATUS_SUCCESS);
}


//-----------------------------------------------------------------------------
// RYM-5++
// Procedure:	[MKMiniportReset]
//
// Description: Instructs the Miniport to issue a hardware reset to the
//		network adapter.  The driver also resets its software state. this
//		function also resets the transmit queues.
//
// Arguments:
//		AddressingReset - TRUE if the wrapper needs to call
//						  MiniportSetInformation to restore the addressing
//						  information to the current values
//		MiniportAdapterContext - pointer to the adapter object data area.
//
// Returns:
//		NDIS_STATUS_PENDING - This function sets a timer to complete, so
//							  pending is always returned
//
// (NOTE: The timer-based completion scheme has been disable by now starting
// the timer. We may now want to return Success instead of Pending.)
//-----------------------------------------------------------------------------
NDIS_STATUS
MKMiniportReset(PBOOLEAN AddressingReset,
		  NDIS_HANDLE MiniportAdapterContext)
{
	PMK7_ADAPTER Adapter;
	MK7REG	mk7reg;


	DBGFUNC("MKMiniportReset");

	Adapter = PMK7_ADAPTER_FROM_CONTEXT_HANDLE(MiniportAdapterContext);

	NdisAcquireSpinLock(&Adapter->Lock);

    Adapter->hardwareStatus = NdisHardwareStatusReset;

	*AddressingReset = TRUE;

	// *** possible temporary code
	// *** NDIS may actually handle this
	Adapter->ResetInProgress = TRUE;

	// Disable interrupts while we re-init the transmit structures
	MK7DisableInterrupt(Adapter);
	MK7DisableIr(Adapter);


	// The NDIS 5 support for deserialized miniports requires that
	// when reset is called, the driver de-queue and fail all uncompleted
	// sends, and complete any uncompleted sends. Essentially we must have
	// no pending send requests left when we leave this routine.


	// we will fail all sends that we have left right now.
	while(Adapter->FirstTxQueue) {
		PNDIS_PACKET QueuePacket = Adapter->FirstTxQueue;

		Adapter->NumPacketsQueued--;
		DequeuePacket(Adapter->FirstTxQueue, Adapter->LastTxQueue);

		// we must release the lock here before returning control to ndis
		// (even temporarily like this)
		NdisReleaseSpinLock(&Adapter->Lock);

		NDIS_SET_PACKET_STATUS(QueuePacket, NDIS_STATUS_FAILURE);
		NdisMSendComplete(
			Adapter->MK7AdapterHandle,
			QueuePacket,
			NDIS_STATUS_FAILURE);

		NdisAcquireSpinLock(&Adapter->Lock);
	}

	// clean up all the packets we have successfully TX'd
//	ProcessTXInterrupt(Adapter);


	// Clear out our software transmit structures
	NdisZeroMemory((PVOID) Adapter->XmitCached, Adapter->XmitCachedSize);

	// Re-initialize the transmit structures
	ResetTransmitQueues(Adapter, FALSE);
	ResetReceiveQueues(Adapter);
	Adapter->tcbUsed = 0;
	NdisMSetTimer(&Adapter->MK7AsyncResetTimer, 500);

//	Adapter->hardwareStatus = NdisHardwareStatusReady;
//	Adapter->ResetInProgress = FALSE;
//	MK7EnableInterrupt(Adapter);
//	MK7EnableIr(Adapter);

	NdisReleaseSpinLock(&Adapter->Lock);
	return(NDIS_STATUS_PENDING);
}



//-----------------------------------------------------------------------------
// Procedure:	[DriverEntry]
//
// Description: This is the primary initialization routine for the MK7 driver.
//		It is simply responsible for the intializing the wrapper and registering
//		the adapter driver. The routine gets called once per driver, but
//		MKMiniportInitialize(miniport)  will get called multiple times if there are
//		multiple adapters.
//
// Arguments:
//		DriverObject - Pointer to driver object created by the system.
//		RegistryPath - The registry path of this driver
//
// Returns:
//	The status of the operation, normally this will be NDIS_STATUS_SUCCESS
//-----------------------------------------------------------------------------
NTSTATUS
DriverEntry(PDRIVER_OBJECT DriverObject,
			PUNICODE_STRING RegistryPath)
{
	NDIS_STATUS		Status;
	NDIS_HANDLE		NdisWrapperHandle;


	NDIS_MINIPORT_CHARACTERISTICS MKMiniportChar;

	DBGFUNC("MK7-DriverEntry");
	DBGLOG("=> DriverEntry", 0);

	//****************************************
	// Now we must initialize the wrapper, and then register the Miniport
	//****************************************
	NdisMInitializeWrapper( &NdisWrapperHandle,
		DriverObject,
		RegistryPath,
		NULL );

	NdisZeroMemory(&MKMiniportChar, sizeof(MKMiniportChar));

	// Initialize the Miniport characteristics for the call to
	// NdisMRegisterMiniport.
	MKMiniportChar.MajorNdisVersion			= MK7_NDIS_MAJOR_VERSION;
	MKMiniportChar.MinorNdisVersion			= MK7_NDIS_MINOR_VERSION;
	MKMiniportChar.CheckForHangHandler		= MKMiniportCheckForHang;
	MKMiniportChar.DisableInterruptHandler	= MK7DisableInterrupt;
	MKMiniportChar.EnableInterruptHandler	= MK7EnableInterrupt;
	MKMiniportChar.HaltHandler				= MKMiniportHalt;
	MKMiniportChar.HandleInterruptHandler	= MKMiniportHandleInterrupt;
	MKMiniportChar.InitializeHandler		= MKMiniportInitialize;
	MKMiniportChar.ISRHandler				= MKMiniportIsr;
	MKMiniportChar.QueryInformationHandler	= MKMiniportQueryInformation;
	MKMiniportChar.ReconfigureHandler		= NULL;
	MKMiniportChar.ResetHandler				= MKMiniportReset;
	MKMiniportChar.SetInformationHandler	= MKMiniportSetInformation;
	MKMiniportChar.SendHandler				= NULL;
	MKMiniportChar.SendPacketsHandler		= MKMiniportMultiSend;
	MKMiniportChar.ReturnPacketHandler		= MKMiniportReturnPackets;
	MKMiniportChar.TransferDataHandler		= NULL;
//	MKMiniportChar.AllocateCompleteHandler	= D100AllocateComplete;


	//****************************************
	// Register this driver with the NDIS wrapper
	// This will cause MKMiniportInitialize to be called before returning
	// (is this really true? -- SoftIce shows this returning before
	// MKMiniportInitialize() is called(?))
	//****************************************
	Status = NdisMRegisterMiniport(	NdisWrapperHandle,
									&MKMiniportChar,
									sizeof(NDIS_MINIPORT_CHARACTERISTICS));

	if (Status == NDIS_STATUS_SUCCESS) {
		DBGLOG("<= DriverEntry", 0);
		return (STATUS_SUCCESS);
	}

	DBGLOG("<= DriverEntry: Failed!", 0);
	return (Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\net\irda\mknet\sys\dbg.h ===
/*****************************************************************************
 **																			**
 **	COPYRIGHT (C) 2000, 2001 MKNET CORPORATION								**
 **	DEVELOPED FOR THE MK7100-BASED VFIR PCI CONTROLLER.						**
 **																			**
 *****************************************************************************/

/**********************************************************************

Module Name:
	DBG.H

**********************************************************************/

#ifndef _DBG_H
#define _DBG_H


// Statistics should eventually go in the adapter struct.
typedef struct MK7DBG_STAT {
	UINT	isrCnt;
	// TX
	UINT	txIsrCnt;
	UINT	txSndCnt;		// call to our send
	UINT	txComp;			// TX processed w/ int bit set
	UINT	txCompNoInt;	// TX processed w/o int bit set
	UINT	txNoTcb;
	UINT	txProcQ;		// processed Q'd entry
	UINT	txSkipPoll;		// master side skipped a poll because no tcb's
	UINT	txLargestPkt;
	UINT	txSlaveStuck;
	UINT	txErrCnt;
	UINT	txErr;
	// RX
	UINT	rxIsrCnt;
	UINT	rxComp;
	UINT	rxCompNoInt;
	UINT	rxNoRpd;
	UINT	rxPktsInd;
	UINT	rxPktsRtn;
	UINT	rxLargestPkt;
	UINT	rxErrCnt;
	UINT	rxErr;
	UINT	rxErrSirCrc;
} MK7DBG_STAT;



#if DBG

extern	MK7DBG_STAT		GDbgStat;
extern	VOID			MyLogEvent(char *, ULONG);
extern	LONGLONG		GDbgTACmdTime[];	// command sent
extern	LONGLONG		GDbgTARspTime[];	// response received
extern	LONGLONG		GDbgTATime[];		// turnaround time
extern	UINT			GDbgTATimeIdx;
extern	VOID			MyLogPhysEvent(ULONG *, UINT *, ULONG);
extern	ULONG			DbgLogTxPhysBuffs[];
extern	ULONG			DbgLogRxPhysBuffs[];
extern	UINT			DbgLogTxPhysBuffsIndex;
extern	UINT			DbgLogRxPhysBuffsIndex;
#define	LOGTXPHY(V)		{MyLogPhysEvent(DbgLogTxPhysBuffs, &DbgLogTxPhysBuffsIndex, V);}
#define	LOGRXPHY(V)		{MyLogPhysEvent(DbgLogRxPhysBuffs, &DbgLogRxPhysBuffsIndex, V);}


//
// __FUNC__[] is the the built-in variable to hold a string, usually
// the name of the function we're currently in. Here the macro sets
// the variable so calls to DbgPrint later will print out the function
// name.
//
// The variables __FILE__ and __LINE__ are used similarly. But these
// 2 are set automatically.

#define DBGFUNC(__F)         static const char __FUNC__[] = __F;; \
						{DbgPrint("%s: \n", __FUNC__);}
#define DBGLINE(S)		{DbgPrint("%s:%d - ", __FILE__, __LINE__);DbgPrint S;}
#define	DBGSTR(S)		DbgPrint S;
#define	DBGSTATUS1(S,I)	DbgPrint (S, I)		// B3.1.0-pre
#define DBGLOG(S, V)	{MyLogEvent(S, V);}

#endif	// DBG



#if !DBG
#define	DBGLOG(S,V)
#define DBGFUNC(__F);
#define DBGLINE(S);
#define	DBGSTR(S);
#define	DBGSTR1(S, I);
#define	LOGTXPHY(V)
#define	LOGRXPHY(V)

#undef	ASSERT
#define	ASSERT(x)
#endif	// !DBG


#define	LOOPBACK_NONE	0
#define	LOOPBACK_SW		1
#define	LOOPBACK_HW		2


#endif      // DBG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\net\irda\mknet\sys\mkinit.c ===
/*****************************************************************************
 **																			**
 **	COPYRIGHT (C) 2000, 2001 MKNET CORPORATION								**
 **	DEVELOPED FOR THE MK7100-BASED VFIR PCI CONTROLLER.						**
 **																			**
 *****************************************************************************/

/**********************************************************************

Module Name:
	MKINIT.C

Routines:
	ClaimAdapter
	SetupIrIoMapping
	SetupAdapterInfo
	AllocAdapterMemory
	ReleaseAdapterMemory
	FreeAdapterObject
	SetupTransmitQueues
	SetupReceiveQueues
	InitializeMK7
	InitializeAdapter
	StartAdapter
	MK7ResetComplete
	ResetTransmitQueues
	ResetReceiveQueues

Comments:
	Various one-time inits. This involves a combo of inits to the
	NDIS env and the MK7100 hw.

**********************************************************************/

#include	"precomp.h"
#include	"protot.h"
#pragma		hdrstop




//-----------------------------------------------------------------------------
// Procedure:	[ClaimAdapter]
//
// Description: Locate a MK7-based adapter and assign (claim) the adapter
//		hardware. This routine also stores the slot, base IO Address, and IRQ.
//
// Arguments:
//	  Adapter - ptr to Adapter object instance.
//
// Returns:
//	  NDIS_STATUS_SUCCESS - If an adapter is successfully found and claimed
//	  NDIS_STATUS_FAILURE- If an adapter is not found/claimed
//
//-----------------------------------------------------------------------------
NDIS_STATUS
ClaimAdapter(PMK7_ADAPTER Adapter, NDIS_HANDLE WrapperConfigurationContext)
{
	USHORT				NumPciBoardsFound;
	ULONG				Bus;
	UINT				i,j;
	NDIS_STATUS			Status = NDIS_STATUS_SUCCESS;
	USHORT				VendorID = MKNET_PCI_VENDOR_ID;
	USHORT				DeviceID = MK7_PCI_DEVICE_ID;
	PCI_CARDS_FOUND_STRUC PciCardsFound;
	PNDIS_RESOURCE_LIST AssignedResources;


	DBGLOG("=> ClaimAdapter", 0);

	// "Bus" is not used??
	Bus = (ULONG) Adapter->BusNumber;

	if (Adapter->MKBusType != PCIBUS) {
		//Not supported -  ISA, EISA or MicroChannel
		DBGLOG("<= ClaimAdapter (ERR - 1", 0);
		return (NDIS_STATUS_FAILURE);
	}


	NumPciBoardsFound = FindAndSetupPciDevice(Adapter,
								WrapperConfigurationContext,
								VendorID,
								DeviceID,
								&PciCardsFound);

	if(NumPciBoardsFound) {

#if DBG
		DBGSTR(("\n\n					  Found the following adapters\n"));

		for(i=0; i < NumPciBoardsFound; i++) {
			DBGSTR(("slot=%x, io=%x, irq=%x \n",
			PciCardsFound.PciSlotInfo[i].SlotNumber,
			PciCardsFound.PciSlotInfo[i].BaseIo,
			PciCardsFound.PciSlotInfo[i].Irq));
		}
#endif

	}
	else {
		DBGSTR(("our PCI board was not found!!!!!!\n"));
		MKLogError(Adapter,
					EVENT_16,
					NDIS_ERROR_CODE_ADAPTER_NOT_FOUND,
					0);

		DBGLOG("<= ClaimAdapter (ERR - 2", 0);
		return (NDIS_STATUS_FAILURE);
	}

	i = 0;	 // only one adapter in the system
	//		NOTE: i == the index into PciCardsFound that we want to use.


	//****************************************
	// Store our allocated resources in Adapter struct
	//****************************************
	Adapter->MKSlot = PciCardsFound.PciSlotInfo[i].SlotNumber;
	Adapter->MKInterrupt = PciCardsFound.PciSlotInfo[i].Irq;
	Adapter->MKBaseIo = PciCardsFound.PciSlotInfo[i].BaseIo;

	DBGLOG("<= ClaimAdapter", 0);

	return (NDIS_STATUS_SUCCESS);
}



//-----------------------------------------------------------------------------
// Procedure:	[SetupIrIoMapping]
//
// Description: This sets up our assigned PCI I/O space w/ NDIS.
//
// Arguments:
//	  Adapter - ptr to Adapter object instance
//
// Returns:
//	  NDIS_STATUS_SUCCESS
//	  not NDIS_STATUS_SUCCESS
//-----------------------------------------------------------------------------
NDIS_STATUS
SetupIrIoMapping(PMK7_ADAPTER Adapter)
{
	NDIS_STATUS Status = NDIS_STATUS_SUCCESS;


	DBGFUNC("SetupIrIoMapping");
	DBGLOG("=> SetupIrIoMapping", 0);

	Adapter->MappedIoRange = Adapter->MKBaseSize;

	Status = NdisMRegisterIoPortRange(
					(PVOID *) &Adapter->MappedIoBase,
					Adapter->MK7AdapterHandle,
					(UINT) Adapter->MKBaseIo,
					Adapter->MappedIoRange);

	DBGSTR(("SetupPciRegs: io=%x, size=%x, stat=%x\n",
		Adapter->MKBaseIo, Adapter->MappedIoRange, Status));

	if (Status != NDIS_STATUS_SUCCESS) {
		DBGSTR(("ERROR: NdisMRegisterIoPortRange failed (Status = 0x%x)\n", Status));
		DBGLOG("<= SetupIrIoMapping (ERR)", 0);
		return (Status);
	}
	DBGLOG("<= SetupIrIoMapping", 0);
	return (Status);
}

//-----------------------------------------------------------------------------
// Procedure:	[SetupAdapterInfo]
//
// Description: Sets up the various adapter fields in the specified Adapter
//				object.
// Arguments:
//	  Adapter - ptr to Adapter object instance
//
// Returns:
//	  NDIS_STATUS_SUCCESS - If an adapter's IO mapping was setup correctly
//	  not NDIS_STATUS_SUCCESS- If an adapter's IO space could not be registered
//-----------------------------------------------------------------------------
NDIS_STATUS
SetupAdapterInfo(PMK7_ADAPTER Adapter)
{
	NDIS_STATUS Status;


	DBGFUNC("SetupAdapterInfo");
	DBGLOG("=> SetupAdapterInfo", 0);

	// Setup the IR Registers I/O mapping
	Status = SetupIrIoMapping(Adapter);

	Adapter->InterruptMode = NdisInterruptLevelSensitive;
//	Adapter->InterruptMode = NdisInterruptLatched;

	DBGLOG("<= SetupAdapterInfo", 0);
	return (Status);
}



//-----------------------------------------------------------------------------
// Procedure:	[AllocAdapterMemory]
//
// Description:	Allocte and setup memory (control structures, shared memory
//		data buffers, ring buffers, etc.) for the MK7. Additional setups
//		may also be done later on, e.g., TX/RX CB lists, buffer lists, etc. 
//
// Arguments:
//	  Adapter - the adapter structure to allocate for.
//
// Returns:
//	  NDIS_STATUS_SUCCESS - If the shared memory structures were setup
//	  not NDIS_STATUS_SUCCESS- If not enough memory or map registers could be
//							   allocated
//-----------------------------------------------------------------------------
NDIS_STATUS
AllocAdapterMemory(PMK7_ADAPTER Adapter)
{
	NDIS_STATUS				Status;
	ULONG					alignedphys;


	DBGFUNC("AllocAdapterMemory");
	DBGLOG("=> SetupAdapterMemory", 0);

	Adapter->MaxPhysicalMappings = MK7_MAXIMUM_PACKET_SIZE_ESC;


	//****************************************
	// We allocate several chunks of memory. They fall into 2 categories:
	// cached and non-cached. Memory that is shared w/ the hw is non-cached
	// for reason of simplicity. Cached memory is used for our internal
	// sw runtime operations.
	//
	// The following is done:
	// 1. Allocate RRDs and TRDs from non-cached memory. This is the
	//	  Ring descriptors for the hw. (The base address of this is
	//	  set in the Phoenix's Base Address Reg.)
	// 2. RX memory --
	//		I.	Alloc cached memory for RCBs and RPDs.
	//		II. Alloc non-cached for RX DMA data buffers (these are
	//			mapped to RX packet->buffers).
	// 3. TX memory --
	//		I.	Alloc cached for TCBs.
	//		II. Alloc non-cached for TX DMA data buffers.
	//****************************************


	//****************************************
	// Since we use shared memory (NdisMAllocateSharedMemory), we have to
	// call NdisMAllocateMapRegisters even though we don't use such
	// mapping. So just ask for 1 map reg.
	//****************************************
	Adapter->NumMapRegisters = 1;
	Status = NdisMAllocateMapRegisters(
				Adapter->MK7AdapterHandle,
				0,
				FALSE,
				Adapter->NumMapRegisters,
				Adapter->MaxPhysicalMappings );

	if (Status != NDIS_STATUS_SUCCESS) {
		Adapter->NumMapRegisters = 0;

		MKLogError(Adapter, EVENT_11, NDIS_ERROR_CODE_OUT_OF_RESOURCES, 0);
		DBGSTR(("NdisMAllocateMapRegister Failed - %x\n", Status));
		DBGLOG("<= SetupAdapterMemory: (ERR - NdisMAllocateMapRegister)", 0);
		return(Status);
	}


	//****************************************
	// RRDs & TRDs (RX/TX Ring Descriptors)
	//
	// Allocate shared memory for the Phoenix Ring buffers.  Each TRD and
	// RRD has a max count (we may not use all). This contiguous space
	// holds both the RRDs and TRDs. The 1st 64 entries are RRDs followed
	// immediately by 64 TRDs. Hence, the 1st TRD is always a max ring count
	// (64x8=512 bytes) from the 1st RRD. We always allocate the max for
	// simplicity. Allocate enough extras to align on 1k boundary.
	//****************************************
	Adapter->RxTxUnCachedSize = 1024 + ( (sizeof(RRD) + sizeof(TRD)) * MAX_RING_SIZE );
	NdisMAllocateSharedMemory(Adapter->MK7AdapterHandle,
							Adapter->RxTxUnCachedSize,
							FALSE,		// non-cached
							(PVOID) &Adapter->RxTxUnCached,
							&Adapter->RxTxUnCachedPhys);
	if (Adapter->RxTxUnCached == NULL) {
		Adapter->pRrd = Adapter->pTrd = NULL;

		MKLogError(Adapter, EVENT_12, NDIS_ERROR_CODE_OUT_OF_RESOURCES, 0);
		DBGSTR(("ERROR: Failed alloc for RRDs & TRDs\n"));
		DBGLOG("<= SetupAdapterMemory: (ERR - RRD/TRD mem)", Adapter->RxTxUnCachedSize);
		return (NDIS_STATUS_FAILURE);
	}
	// Align to 1K boundary.
	// NOTE: We don't modify RxTxUnCached. We need it for release later.
	alignedphys = NdisGetPhysicalAddressLow(Adapter->RxTxUnCachedPhys);
	alignedphys += 0x000003FF;
	alignedphys &= (~0x000003FF);
	Adapter->pRrdTrdPhysAligned = alignedphys;
	Adapter->pRrdTrd = Adapter->RxTxUnCached +
		(alignedphys - NdisGetPhysicalAddressLow(Adapter->RxTxUnCachedPhys));


	Adapter->pRrd		= Adapter->pRrdTrd;
	Adapter->pRrdPhys	= Adapter->pRrdTrdPhysAligned;
	// TRDs are right after RRDs (see Phoenix doc)
	Adapter->pTrd = Adapter->pRrd + (sizeof(RRD) * MAX_RING_SIZE);
	Adapter->pTrdPhys = Adapter->pRrdPhys + (sizeof(RRD) * MAX_RING_SIZE);



	//****************************************
	// Allocate RX memory
	//
	// 1. Cacheable control structures (RCBs, RPDs),
	// 2. Non-cacheable DMA buffers.
	//****************************************

	// RCBs and RPDs (cached)
	Adapter->RecvCachedSize = (	Adapter->NumRcb * sizeof(RCB) +
								Adapter->NumRpd * sizeof(RPD) );
	Status = ALLOC_SYS_MEM(&Adapter->RecvCached, Adapter->RecvCachedSize);
	if (Status != NDIS_STATUS_SUCCESS) {
		Adapter->RecvCached = (PUCHAR) 0;

		MKLogError(Adapter, EVENT_13, NDIS_ERROR_CODE_OUT_OF_RESOURCES, 0);
		DBGSTR(("ERROR: Failed allocate %d bytes for RecvCached mem\n",
				Adapter->RecvCachedSize));
		DBGLOG("<= SetupAdapterMemory: (ERR - RCB/RPD mem)", Adapter->RecvCachedSize);
		return (Status);
	}
	DBGSTR(("Allocated %08x %8d bytes for RecvCached mem\n", 
			Adapter->RecvCached, Adapter->RecvCachedSize));
	NdisZeroMemory((PVOID) Adapter->RecvCached, Adapter->RecvCachedSize);


	// RX data buffers (non-cached)
	// Alignment!?
	Adapter->RecvUnCachedSize = (Adapter->NumRpd * RPD_BUFFER_SIZE);
	NdisMAllocateSharedMemory(
			Adapter->MK7AdapterHandle,
			Adapter->RecvUnCachedSize,
			FALSE,		// non-cached
			(PVOID) &Adapter->RecvUnCached,
			&Adapter->RecvUnCachedPhys );
	if (Adapter->RecvUnCached == NULL) {
		MKLogError(Adapter, EVENT_14, NDIS_ERROR_CODE_OUT_OF_RESOURCES, 0);
		DBGSTR(("ERROR: Failed allocate %d bytes for RecvUnCached mem\n",
				Adapter->RecvUnCachedSize));
		DBGLOG("<= SetupAdapterMemory: (ERR - RPD buff mem)", Adapter->RecvUnCachedSize);
		return (NDIS_STATUS_FAILURE);
	}
	DBGSTR(("Allocated %08x %8d bytes for RecvUnCached mem\n",
			Adapter->RecvUnCached, Adapter->RecvUnCachedSize));
	NdisZeroMemory((PVOID) Adapter->RecvUnCached, Adapter->RecvUnCachedSize);



	//****************************************
	// Allocate TX memory
	//
	// 1. Cacheable control structure (TCBs),
	// 2. Non-cacheable DMA buffers (coalesce).
	//****************************************

	// TCBs (cached)
	Adapter->XmitCachedSize = (Adapter->NumTcb * sizeof(TCB));
	Status = ALLOC_SYS_MEM(&Adapter->XmitCached, Adapter->XmitCachedSize);
	if (Status != NDIS_STATUS_SUCCESS) {
		Adapter->XmitCached = (PUCHAR) 0;

		MKLogError(Adapter, EVENT_13, NDIS_ERROR_CODE_OUT_OF_RESOURCES, 0);
		DBGSTR(("ERROR: Failed allocate %d bytes for XmitCached mem\n",
				Adapter->XmitCachedSize));
		DBGLOG("<= SetupAdapterMemory: (ERR - TCB mem)", Adapter->XmitCachedSize);
		return (Status);
	}
	DBGSTR(("Allocated %08x %8d bytes for XmitCached mem\n",
			Adapter->XmitCached, Adapter->XmitCachedSize));
	NdisZeroMemory((PVOID) Adapter->XmitCached, Adapter->XmitCachedSize);


	// TX coalesce data buffers (non-cached)
	Adapter->XmitUnCachedSize =
		((Adapter->NumTcb + 1) * COALESCE_BUFFER_SIZE);

	//****************************************
	// Do we need to paragraph align this memory?
	//****************************************
	NdisMAllocateSharedMemory(
			Adapter->MK7AdapterHandle,
			Adapter->XmitUnCachedSize,
			FALSE,
			(PVOID) &Adapter->XmitUnCached,
			&Adapter->XmitUnCachedPhys);

	if (Adapter->XmitUnCached == NULL) {
		MKLogError(Adapter, EVENT_15, NDIS_ERROR_CODE_OUT_OF_RESOURCES, 0);
		DBGSTR(("ERROR: Failed allocate %d bytes for XmitUnCached mem\n", 
				Adapter->XmitUnCachedSize));
		DBGLOG("<= SetupAdapterMemory: (ERR - TX buff mem)", (ULONG)0);
		return (NDIS_STATUS_FAILURE);
	}
	DBGSTR(("Allocated %08x %8d bytes for XmitUnCached mem\n", 
				Adapter->XmitUnCached, Adapter->XmitUnCachedSize));
	// initialize this recently allocated area to zeros
	NdisZeroMemory((PVOID) Adapter->XmitUnCached, Adapter->XmitUnCachedSize);


	DBGLOG("<= SetupAdapterMemory", 0);
	return (NDIS_STATUS_SUCCESS);
}



//-----------------------------------------------------------------------------
// Procedure:	[ReleaseAdapterMemory]
//
// Description: This is the reverse of AllocAdapterMemory().  We deallocate the
//		shared memory data structures for the Adapter structure.  This includes
//		the both the cached and uncached memory allocations. We also free any
//		allocated map registers in this routine.
//
// Arguments:
//		Adapter - Ptr to the Adapter structure
//
// Returns:		(none)
//-----------------------------------------------------------------------------
VOID
ReleaseAdapterMemory(PMK7_ADAPTER Adapter)
{
	UINT	i;
	PRCB	rcb;
	PRPD	rpd;


	DBGFUNC("ReleaseAdapterMemory");
	DBGLOG("=> ReleaseAdapterMemory", 0);

	//********************
	// Release RX memory
	//********************

	// Packet and buffer descriptors and pools	
	if (Adapter->ReceivePacketPool) {
		DBGLOG("Freeing Packet Pool resources\n", 0);

		rcb = Adapter->pRcb;
		for (i=0; i<Adapter->NumRcb; i++) {
			NdisFreeBuffer(rcb->rpd->ReceiveBuffer);
			NdisFreePacket(rcb->rpd->ReceivePacket);
			rcb++;
		}

		rpd = (PRPD) QueuePopHead(&Adapter->FreeRpdList);
		while (rpd != (PRPD)NULL) {
			NdisFreeBuffer(rpd->ReceiveBuffer);
			NdisFreePacket(rpd->ReceivePacket);
			rpd = (PRPD) QueuePopHead(&Adapter->FreeRpdList);
		}

		NdisFreeBufferPool(Adapter->ReceiveBufferPool);
		NdisFreePacketPool(Adapter->ReceivePacketPool);
	}



	// RCBs (cacheable)
	if (Adapter->RecvCached) {
		DBGLOG("Freeing %d bytes RecvCached\n", Adapter->RecvCachedSize);
		NdisFreeMemory((PVOID) Adapter->RecvCached, Adapter->RecvCachedSize, 0);
		Adapter->RecvCached = (PUCHAR) 0;
	}

	// RX shared data buffer memory (non-cacheable)
	if (Adapter->RecvUnCached) {
		DBGLOG("Freeing %d bytes RecvUnCached\n", Adapter->RecvUnCachedSize);

		NdisMFreeSharedMemory(
			Adapter->MK7AdapterHandle,
			Adapter->RecvUnCachedSize,
			FALSE,
			(PVOID) Adapter->RecvUnCached,
			Adapter->RecvUnCachedPhys);
		Adapter->RecvUnCached = (PUCHAR) 0;
	}



	//********************
	// Release TX memory
	//********************

	// TCBs (cacheable)
	if (Adapter->XmitCached) {
		DBGLOG("Freeing %d bytes XmitCached\n", Adapter->XmitCachedSize);
		NdisFreeMemory((PVOID) Adapter->XmitCached, Adapter->XmitCachedSize, 0);
		Adapter->XmitCached = (PUCHAR) 0;
	}

	// TX shared data buffer memory (non-cacheable)
	if (Adapter->XmitUnCached) {
		DBGLOG("Freeing %d bytes XmitUnCached\n", Adapter->XmitUnCachedSize);

		// Now free the shared memory that was used for the command blocks and
		// transmit buffers.

		NdisMFreeSharedMemory(
			Adapter->MK7AdapterHandle,
			Adapter->XmitUnCachedSize,
			FALSE,
			(PVOID) Adapter->XmitUnCached,
			Adapter->XmitUnCachedPhys
			);
		Adapter->XmitUnCached = (PUCHAR) 0;
	}


	//********************
	// RRDs/TRDs (Ring) & Reg Map (non-cacheable)
	//********************

	// If this is a miniport driver we must free our allocated map registers
	if (Adapter->NumMapRegisters) {
		NdisMFreeMapRegisters(Adapter->MK7AdapterHandle);
	}

	// Now the TRDs & RRDs
	if (Adapter->RxTxUnCached) {
		NdisMFreeSharedMemory(
			Adapter->MK7AdapterHandle,
			Adapter->RxTxUnCachedSize,
			FALSE,
			(PVOID) Adapter->RxTxUnCached,
			Adapter->RxTxUnCachedPhys );
	}

	DBGLOG("<= ReleaseAdapterMemory", 0);
}



//-----------------------------------------------------------------------------
// Procedure:	[FreeAdapterObject]
//
// Description: Free all allocated resources for the adapter.
//
// Arguments:
//		Adapter - ptr to Adapter object instance
//
// Returns:		(none)
//-----------------------------------------------------------------------------
VOID
FreeAdapterObject(PMK7_ADAPTER Adapter)
{
	DBGFUNC("FreeAdapterObject");

	// The reverse of AllocAdapterMemory().
	ReleaseAdapterMemory(Adapter);

	// Delete any IO mappings that we have registered
	if (Adapter->MappedIoBase) {
		NdisMDeregisterIoPortRange(
					Adapter->MK7AdapterHandle,
					(UINT) Adapter->MKBaseIo,
					Adapter->MappedIoRange,
					(PVOID) Adapter->MappedIoBase);
	}

	// free the adapter object itself
	FREE_SYS_MEM(Adapter, sizeof(MK7_ADAPTER));
}



//-----------------------------------------------------------------------------
// Procedure:	[SetupTransmitQueues]
//
// Description: Setup TRBs, TRDs and TX data buffs at INIT time. This routine
//		may also be called at RESET time.
//
// Arguments:
//	  Adapter - ptr to Adapter object instance
//	  DebugPrint - A boolean value that will be TRUE if this routine is to
//				   write all of transmit queue debug info to the debug terminal.
//
// Returns:	   (none)
//-----------------------------------------------------------------------------
VOID
SetupTransmitQueues(PMK7_ADAPTER Adapter,
					BOOLEAN DebugPrint)
{
	UINT	i;
	PTCB	tcb;
	PTRD	trd;
	PUCHAR	databuff;
	ULONG	databuffphys;


	DBGLOG("=> SetupTransmitQueues", 0);

	Adapter->nextAvailTcbIdx = 0;
	Adapter->nextReturnTcbIdx = 0;

	Adapter->pTcb	= (PTCB)Adapter->XmitCached;

	tcb				= Adapter->pTcb;			// TCB
	trd				= (PTRD)Adapter->pTrd;		// TRD
	databuff		= Adapter->XmitUnCached;
	databuffphys	= NdisGetPhysicalAddressLow(Adapter->XmitUnCachedPhys);// shared data buffer

	//****************************************
	// Pair up a TCB w/ a TRD, and init ownership of TRDs to the driver.
	// Setup the physical buffer to the Ring descriptor (TRD).
	//****************************************
	for (i=0; i<Adapter->NumTcb; i++) {	
		tcb->trd		= trd;
		tcb->buff		= databuff;
		tcb->buffphy	= databuffphys;

		LOGTXPHY(databuffphys);	// for debug

		trd->count		= 0;
		trd->status		= 0;
		trd->addr		= (UINT)databuffphys;
		GrantTrdToDrv(trd);

		Adapter->pTcbArray[i] = tcb;

		tcb++;
		trd++;
		databuff		+= COALESCE_BUFFER_SIZE;
		databuffphys	+= COALESCE_BUFFER_SIZE;
	}


	// Initialize the Transmit queueing pointers to NULL
	Adapter->FirstTxQueue = (PNDIS_PACKET) NULL;
	Adapter->LastTxQueue = (PNDIS_PACKET) NULL;
	Adapter->NumPacketsQueued = 0;

	DBGLOG("<= SetupTransmitQueues", 0);
}


//-----------------------------------------------------------------------------
// Procedure:	[SetupReceiveQueues]
//
// Description:	Setup all rx-related descriptors, buffers, etc. using memory
//		allocated during init. Also setup our buffers for NDIS 5 and multiple
//		receive indications	through a packet array.
//
// Arguments:
//	  Adapter - ptr to Adapter object instance
//
// Returns:	   (none)
//-----------------------------------------------------------------------------
VOID
SetupReceiveQueues(PMK7_ADAPTER Adapter)
{
	UINT		i;
	PRCB		rcb;
	PRRD		rrd;
	PRPD		rpd;
	PUCHAR		databuff;
	ULONG		databuffphys;
	PRPD		*TempPtr;
	NDIS_STATUS	status;


	DBGLOG("=> SetupReceiveQueues", 0);

	QueueInitList(&Adapter->FreeRpdList);

	Adapter->nextRxRcbIdx = 0;

// 4.0.1 BOC
	Adapter->UsedRpdCount = 0;
	Adapter->rcbPendRpdCnt = 0;	// April 8, 2001.
// 4.0.1 EOC

	Adapter->pRcb	= (PRCB)Adapter->RecvCached;


	//****************************************
	// Our driver does not currently use async allocs. However, it's
	// still true that we have only one buffer per rx packet.
	//****************************************
	NdisAllocatePacketPool(&status,
						&Adapter->ReceivePacketPool,
						Adapter->NumRpd,
						NUM_BYTES_PROTOCOL_RESERVED_SECTION);
	ASSERT(status == NDIS_STATUS_SUCCESS);

	NdisAllocateBufferPool(&status,
						&Adapter->ReceiveBufferPool,
						Adapter->NumRpd);
	ASSERT(status == NDIS_STATUS_SUCCESS);


	//****************************************
	// Pair up a RCB w/ a RRD
	//****************************************
	rcb	= Adapter->pRcb;
	rrd	= (PRRD)Adapter->pRrd;
	for (i=0; i<Adapter->NumRcb; i++) {
		rcb->rrd	= rrd;

		rrd->count	= 0;
		GrantRrdToHw(rrd);

		Adapter->pRcbArray[i] = rcb;

		rcb++;
		rrd++;
	}


	//****************************************
	// Now set up the RPDs and the data buffers. The RPDs come right
	// after the RCBs in RecvCached memory. Put the RPDs on FreeRpdList.
	// Map the databuff to NDIS Packet/Buffer.
	// "Adapter->pRcb + Adapter->NumRcb" will skip over (NumRcb * sizeof(RCB))
	// bytes to get to RPDs because pRcb is ptr to RCB. 
	//****************************************
	rpd				= (PRPD) (Adapter->pRcb + Adapter->NumRcb);
	databuff		= Adapter->RecvUnCached;
	databuffphys	= NdisGetPhysicalAddressLow(Adapter->RecvUnCachedPhys);
	for (i=0; i<Adapter->NumRpd; i++) {

		rpd->databuff		= databuff;
		rpd->databuffphys	= databuffphys;

		LOGRXPHY(databuffphys);

		NdisAllocatePacket(&status,
						&rpd->ReceivePacket,
						Adapter->ReceivePacketPool);
		ASSERT(status== NDIS_STATUS_SUCCESS);

		//****************************************
		// Set the medium-specific header size in OOB data block.
		//****************************************
		NDIS_SET_PACKET_HEADER_SIZE(rpd->ReceivePacket,	ADDR_SIZE+CONTROL_SIZE);

		NdisAllocateBuffer(&status,
						&rpd->ReceiveBuffer,
						Adapter->ReceiveBufferPool,
						(PVOID)databuff,
						MK7_MAXIMUM_PACKET_SIZE);
		ASSERT(status == NDIS_STATUS_SUCCESS);

		NdisChainBufferAtFront(rpd->ReceivePacket,	rpd->ReceiveBuffer);

		QueuePutTail(&Adapter->FreeRpdList, &rpd->link);

		TempPtr = (PRPD *)&rpd->ReceivePacket->MiniportReserved;
		*TempPtr = rpd;

		rpd++;
		databuff		+= RPD_BUFFER_SIZE;
		databuffphys	+= RPD_BUFFER_SIZE;
	}



	//****************************************
	// Assign a RPB to each RCB, and setup the related RRD's data ptr.
	//****************************************
	rcb	= Adapter->pRcb;
	rrd	= rcb->rrd;
	for (i=0; i<Adapter->NumRcb; i++) {
		rpd = (PRPD) QueuePopHead(&Adapter->FreeRpdList);
		rcb->rpd	= rpd;
		rrd->addr	= rpd->databuffphys;
		rcb++;
		rrd = rcb->rrd;
	}
}



//-----------------------------------------------------------------------------
// Procedure:	[InitializeMK7] (RYM-IRDA)
//
// Description:	Init the Phoenix core to SIR mode.
//
// Arguments:
//	  Adapter - ptr to Adapter object instance
//
// Returns:
//		TRUE
//		FALSE
//-----------------------------------------------------------------------------
BOOLEAN
InitializeMK7(PMK7_ADAPTER Adapter)
{
	ULONG	phyaddr;
	MK7REG	mk7reg;


	DBGFUNC("InitializeMK7");

	//****************************************
	// Setup Ring Base Address & Ring Size. Need to shift down/right
	// 10 bits first.
	//****************************************
	phyaddr = (Adapter->pRrdTrdPhysAligned >> 10);
	MK7Reg_Write(Adapter, R_RBAL, (USHORT)phyaddr);
	MK7Reg_Write(Adapter, R_RBAU, (USHORT)(phyaddr >> 16));


	//****************************************
	// RX & TX ring sizes
	//
	// Now need to do this for RX & TX separately.
	//****************************************
	mk7reg = 0;

	switch(Adapter->NumRcb) {
	case 4:		mk7reg = RINGSIZE_RX4;		break;
	case 8:		mk7reg = RINGSIZE_RX8;		break;
	case 16:	mk7reg = RINGSIZE_RX16;		break;
	case 32:	mk7reg = RINGSIZE_RX32;		break;
	case 64:	mk7reg = RINGSIZE_RX64;		break;
	}

	switch(Adapter->NumTcb) {
	case 4:		mk7reg |= RINGSIZE_TX4;		break;
	case 8:		mk7reg |= RINGSIZE_TX8;		break;
	case 16:	mk7reg |= RINGSIZE_TX16;	break;
	case 32:	mk7reg |= RINGSIZE_TX32;	break;
	case 64:	mk7reg |= RINGSIZE_TX64;	break;
	}

	MK7Reg_Write(Adapter, R_RSIZ, mk7reg);


	//****************************************
	// The following is based on Phoenix's Programming Model
	// for SIR mode.
	//****************************************

	//****************************************
	// Step 1:	clear IRENALBE
	// This is the only writeable bit in this reg so just write it.
	//****************************************
	MK7Reg_Write(Adapter, R_ENAB, ~B_ENAB_IRENABLE);

	//****************************************
	// Step 2:	MAXRXALLOW
	//****************************************
	MK7Reg_Write(Adapter, R_MPLN, MK7_MAXIMUM_PACKET_SIZE_ESC);

	//****************************************
	// Step 3:
	// IRCONFIG0 - We init in SIR w/ filter, RX, etc.
	//****************************************
#if DBG
	if (Adapter->LB == LOOPBACK_HW) {
		DBGLOG("   Loopback HW", 0);

//		MK7Reg_Write(Adapter, R_CFG0, 0x5C40);		// HW loopback: ENTX, ENRX, + below
		MK7Reg_Write(Adapter, R_CFG0, 0xDC40);		// HW loopback: ENTX, ENRX, + below
	}
	else {
#endif

		// We need to clear EN_MEMSCHD in IRCONFIG0 to reset the TX/RX
		// indexes to 0. Eveytime we init we need to do this. Actually we
		// just set eveything to zero since we're in ~B_ENAB_IRENABLE mode
		// anyway & we do the real setup right away below.
		MK7Reg_Write(Adapter, R_CFG0, 0x0000);
				
		if (Adapter->Wireless) {
			// WIRELESS: ..., no invert TX
			MK7Reg_Write(Adapter, R_CFG0, 0x0E18);
		}
		else {
			// WIRED: ENRX, DMA, small pkts, SIR, SIR RX filter, invert TX
			MK7Reg_Write(Adapter, R_CFG0, 0x0E1A);
		}
#if DBG
	}
#endif

	
	//****************************************
	// Step 4:
	// Infrared Phy Reg - Baude Rate & Pulse width
	//****************************************
	mk7reg = HW_SIR_SPEED_9600;
	MK7Reg_Write(Adapter, R_CFG2, mk7reg);


	//****************************************
	// Setup CFG3 - 48Mhz, etc.
	//****************************************
	//MK7Reg_Write(Adapter, R_CFG3, 0xF606);
	// We want to set the following:
	//		Bit 1	- 1 for 1 RCV pin (for all speeds)
	//		    2/3	- 48MHz
	//			8	- 0 to disable interrupt
	//			9	- 0 for SIR
	//			11	- 0 for burst mode
	MK7Reg_Write(Adapter, R_CFG3, 0xF406);


	// Set SEL0/1 for power level control for the 8102. This
	// should not affect the 8100.
	// IMPORTANT: The FIRSL bit in this register is the same
	//				as the FIRSL bit in CFG3!
	MK7Reg_Write(Adapter, R_GANA, 0x0000);


	//
	// More one-time inits are done later when we startup the controller
	// (see StartMK7()).
	//

	return (TRUE);
}



//-----------------------------------------------------------------------------
// Procedure:	[InitializeAdapter]
//
// Description:
//
// Arguments:
//		Adapter - ptr to Adapter object instance
//
// Returns:
//		TRUE - If the adapter was initialized
//		FALSE - If the adapter failed initialization
//-----------------------------------------------------------------------------
BOOLEAN
InitializeAdapter(PMK7_ADAPTER Adapter)
{
	UINT	i;


	DBGFUNC("InitializeAdapter");


   	for (i=0; i<NUM_BAUDRATES; i++) {
		if (supportedBaudRateTable[i].bitsPerSec <= Adapter->MaxConnSpeed) {
			Adapter->AllowedSpeedMask |= supportedBaudRateTable[i].ndisCode;
		}
	}

	Adapter->supportedSpeedsMask	= ALL_IRDA_SPEEDS;
	Adapter->linkSpeedInfo 			= &supportedBaudRateTable[BAUDRATE_9600];
	Adapter->CurrentSpeed			= DEFAULT_BAUD_RATE;	// 9600
	//Adapter->extraBOFsRequired	= MAX_EXTRA_SIR_BOFS; Now configurable
	Adapter->writePending			= FALSE;

	// Set both TRUE to allow Windows to let us know when it wants an update.
	Adapter->mediaBusy				= TRUE;
//	Adapter->haveIndicatedMediaBusy = TRUE;		// 1.0.0

	NdisMInitializeTimer(&Adapter->MinTurnaroundTxTimer,
						Adapter->MK7AdapterHandle,
						(PNDIS_TIMER_FUNCTION)MinTurnaroundTxTimeout,
						(PVOID)Adapter);

	// 1.0.0
	NdisMInitializeTimer(&Adapter->MK7AsyncResetTimer,
		Adapter->MK7AdapterHandle,
		(PNDIS_TIMER_FUNCTION) MK7ResetComplete,
		(PVOID) Adapter);

	return (InitializeMK7(Adapter));
}



//----------------------------------------------------------------------
// Procedure:	[StartMK7]
//
// Description: All inits are done. Now we can enable the MK7 to
//				be able to do RXs and TXs.
//
//----------------------------------------------------------------------
VOID	StartMK7(PMK7_ADAPTER Adapter)
{
	MK7REG	mk7reg;


	//****************************************
	// The following is based on Phoenix's Programming Model
	// for SIR mode.
	//****************************************

	//****************************************
	// Step 5:	IR_ENABLE
	// Now finish where InitializeMK7() left off. This completes
	// the one-time init of the MK7 core.
	//****************************************
	MK7Reg_Write(Adapter, R_ENAB, B_ENAB_IRENABLE);

	MK7Reg_Read(Adapter, R_ENAB, &mk7reg);

//	ASSERT(mk7reg == 0x8FFF);

	// Still need to do the 1st Prompt. This will be done later
	// when we call MK7EnableInterrupt().
}



//----------------------------------------------------------------------
// Procedure:	[StartAdapter]
//
// Description: All inits are done. Now we can enable the adapter to
//				be able to do RXs and TXs.
//
//----------------------------------------------------------------------
VOID	StartAdapter(PMK7_ADAPTER Adapter)
{
	StartMK7(Adapter);
}

//-----------------------------------------------------------------------------
// Procedure;	[MKResetComplete]
//
// Description: This function is called by a timer indicating our
//              reset is done (by way of .5 seconds expiring)
//
// Arguements:  NDIS_HANDLE MiniportAdapterContext
//
// Return:		nothing, but sets NdisMResetComplete and enables ints.
//-----------------------------------------------------------------------------

VOID
MK7ResetComplete(PVOID sysspiff1,
                  NDIS_HANDLE MiniportAdapterContext,
                  PVOID sysspiff2, PVOID sysspiff3)
{
    PMK7_ADAPTER Adapter;
	MK7REG mk7reg;

//    DEBUGFUNC("MKResetComplete");

//    INITSTR(("\n"));
    Adapter = PMK7_ADAPTER_FROM_CONTEXT_HANDLE(MiniportAdapterContext);

	// NdisAcquireSpinLock(&Adapter->Lock); 4.0.1
	MK7Reg_Read(Adapter, R_INTS, &Adapter->recentInt);
	Adapter->recentInt = 0;
	MK7SwitchToRXMode(Adapter);

    NdisMResetComplete(Adapter->MK7AdapterHandle,
        (NDIS_STATUS) NDIS_STATUS_SUCCESS,
        TRUE);

	Adapter->hardwareStatus = NdisHardwareStatusReady;

	Adapter->ResetInProgress = FALSE;

	StartMK7(Adapter);

	MK7EnableInterrupt(Adapter);

//	PSTR("=> NDIS RESET COMPLETE\n\r");

	// NdisReleaseSpinLock(&Adapter->Lock);	// 4.0.1
}


//-----------------------------------------------------------------------------
// Procedure:	[ResetTransmitQueues]
//
// Description: Setup TRBs, TRDs and TX data buffs at INIT time. And Reset
//				TCB/RCB	Index to zero in both hardware and software
//
// Arguments:
//	  Adapter - ptr to Adapter object instance
//	  DebugPrint - A boolean value that will be TRUE if this routine is to
//				   write all of transmit queue debug info to the debug terminal.
//
// Returns:	   (none)
//-----------------------------------------------------------------------------
VOID
ResetTransmitQueues(PMK7_ADAPTER Adapter,
					BOOLEAN DebugPrint)
{
	UINT	i;
	PTCB	tcb;
	PTRD	trd;
	PUCHAR	databuff;
	ULONG	databuffphys;
	MK7REG	mk7reg;


	DBGLOG("=> SetupTransmitQueues", 0);

	Adapter->nextAvailTcbIdx = 0;
	Adapter->nextReturnTcbIdx = 0;

	MK7Reg_Read(Adapter, R_CFG0, &mk7reg);
	mk7reg &= 0xfbff;
	MK7Reg_Write(Adapter, R_CFG0, mk7reg);
	mk7reg |= 0x0400;
	MK7Reg_Write(Adapter, R_CFG0, mk7reg);

	Adapter->pTcb	= (PTCB)Adapter->XmitCached;

	tcb				= Adapter->pTcb;			// TCB
	trd				= (PTRD)Adapter->pTrd;		// TRD
	databuff		= Adapter->XmitUnCached;
	databuffphys	= NdisGetPhysicalAddressLow(Adapter->XmitUnCachedPhys);// shared data buffer

	//****************************************
	// Pair up a TCB w/ a TRD, and init ownership of TRDs to the driver.
	// Setup the physical buffer to the Ring descriptor (TRD).
	//****************************************
	for (i=0; i<Adapter->NumTcb; i++) {
		tcb->trd		= trd;
		tcb->buff		= databuff;
		tcb->buffphy	= databuffphys;

		trd->count		= 0;
		trd->status		= 0;
		trd->addr		= (UINT)databuffphys;
		GrantTrdToDrv(trd);

		Adapter->pTcbArray[i] = tcb;

		tcb++;
		trd++;
		databuff		+= COALESCE_BUFFER_SIZE;
		databuffphys	+= COALESCE_BUFFER_SIZE;
	}


	// Initialize the Transmit queueing pointers to NULL
	Adapter->FirstTxQueue = (PNDIS_PACKET) NULL;
	Adapter->LastTxQueue = (PNDIS_PACKET) NULL;
	Adapter->NumPacketsQueued = 0;

	DBGLOG("<= SetupTransmitQueues", 0);
}
//-----------------------------------------------------------------------------
// Procedure:	[ResetReceiveQueues]
//
// Description:	Reset all the rrd's Ownership to HW
//				and byte_counts to zero. All other
//				setting (such as rpd) will remain				
//				same.  We do not reset all, because
//				some data buffers may still hold by
//				by the upper protocol layers.
//
// Arguments:
//	  Adapter - ptr to Adapter object instance
//
// Returns:	   (none)
//-----------------------------------------------------------------------------
VOID
ResetReceiveQueues(PMK7_ADAPTER Adapter)
{
	UINT		i;
	PRCB		rcb;
	PRRD		rrd;

	DBGLOG("=> SetupReceiveQueues", 0);

	Adapter->nextRxRcbIdx = 0;

	Adapter->pRcb	= (PRCB)Adapter->RecvCached;

	//****************************************
	// Pair up a RCB w/ a RRD
	//****************************************
	rcb	= Adapter->pRcb;
	rrd	= (PRRD)Adapter->pRrd;
	for (i=0; i<Adapter->NumRcb; i++) {
		rcb->rrd	= rrd;

		rrd->count	= 0;
		GrantRrdToHw(rrd);

		Adapter->pRcbArray[i] = rcb;

		rcb++;
		rrd++;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\net\irda\mknet\sys\queue.h ===
/*****************************************************************************
 **																			**
 **	COPYRIGHT (C) 2000, 2001 MKNET CORPORATION								**
 **	DEVELOPED FOR THE MK7100-BASED VFIR PCI CONTROLLER.						**
 **																			**
 *****************************************************************************/

/**********************************************************************

Module Name:
	QUEUE.H
		

**********************************************************************/


//-------------------------------------------------------------------------
// QueueInitList -- Macro which will initialize a queue to NULL.
//-------------------------------------------------------------------------
#define QueueInitList(_L) (_L)->Link.Flink = (_L)->Link.Blink = (PLIST_ENTRY)0;


//-------------------------------------------------------------------------
// QueueEmpty -- Macro which checks to see if a queue is empty.
//-------------------------------------------------------------------------
#define QueueEmpty(_L) (QueueGetHead((_L)) == (PMK7_LIST_ENTRY)0)


//-------------------------------------------------------------------------
// QueueGetHead -- Macro which returns the head of the queue, but does not
// remove the head from the queue.
//-------------------------------------------------------------------------
#define QueueGetHead(_L) ((PMK7_LIST_ENTRY)((_L)->Link.Flink))


//-------------------------------------------------------------------------
// QueuePushHead -- Macro which puts an element at the head of the queue.
//-------------------------------------------------------------------------
#define QueuePushHead(_L,_E) \
    ASSERT(_L); \
    ASSERT(_E); \
    if (!((_E)->Link.Flink = (_L)->Link.Flink)) \
    { \
        (_L)->Link.Blink = (PLIST_ENTRY)(_E); \
    } \
(_L)->Link.Flink = (PLIST_ENTRY)(_E);


//-------------------------------------------------------------------------
// QueueRemoveHead -- Macro which removes the head of the head of queue.
//-------------------------------------------------------------------------
#define QueueRemoveHead(_L) \
    {                                                     \
    PMK7_LIST_ENTRY ListElem;                        \
    ASSERT((_L));                                     \
    if (ListElem = (PMK7_LIST_ENTRY)(_L)->Link.Flink) /* then fix up our our list to point to next elem */ \
        {   \
            if(!((_L)->Link.Flink = ListElem->Link.Flink)) /* rechain list pointer to next link */ \
                /* if the list pointer is null, null out the reverse link */ \
                (_L)->Link.Blink = (PLIST_ENTRY) 0; \
        } }

//-------------------------------------------------------------------------
// QueuePutTail -- Macro which puts an element at the tail (end) of the queue.
//-------------------------------------------------------------------------
#define QueuePutTail(_L,_E) \
    ASSERT(_L); \
    ASSERT(_E); \
    if ((_L)->Link.Blink) \
    { \
        ((PMK7_LIST_ENTRY)(_L)->Link.Blink)->Link.Flink = (PLIST_ENTRY)(_E); \
        (_L)->Link.Blink = (PLIST_ENTRY)(_E); \
    } \
    else \
    { \
        (_L)->Link.Flink = \
        (_L)->Link.Blink = (PLIST_ENTRY)(_E); \
    } \
(_E)->Link.Flink = (PLIST_ENTRY)0;

//-------------------------------------------------------------------------
// QueueGetTail -- Macro which returns the tail of the queue, but does not
// remove the tail from the queue.
//-------------------------------------------------------------------------
#define QueueGetTail(_L) ((PMK7_LIST_ENTRY)((_L)->Link.Blink))

//-------------------------------------------------------------------------
// QueuePopHead -- Macro which  will pop the head off of a queue (list), and
//                 return it (this differs only from queueremovehead only in the 1st line)
//-------------------------------------------------------------------------
#define QueuePopHead(_L) \
(PMK7_LIST_ENTRY) (_L)->Link.Flink; QueueRemoveHead(_L);


typedef struct _MK7_RESERVED {

	// next packet in the chain of queued packets being allocated,
	// or waiting for the finish of transmission.
	//
	// We always keep the packet on a list so that in case the
	// the adapter is closing down or resetting, all the packets
	// can easily be located and "canceled".
	//
	PNDIS_PACKET Next;
} MK7_RESERVED,*PMK7_RESERVED;

#define PMK7_RESERVED_FROM_PACKET(_Packet) \
	((PMK7_RESERVED)((_Packet)->MiniportReserved))

#define EnqueuePacket(_Head, _Tail, _Packet)		   		\
{													   		\
	if (!_Head) {									   		\
		_Head = _Packet;							   		\
	} else {										   		\
		PMK7_RESERVED_FROM_PACKET(_Tail)->Next = _Packet;	\
	}												   		\
	PMK7_RESERVED_FROM_PACKET(_Packet)->Next = NULL;   		\
	_Tail = _Packet;								   		\
}

#define DequeuePacket(Head, Tail)						\
{													 	\
	PMK7_RESERVED Reserved =						  	\
		PMK7_RESERVED_FROM_PACKET(Head);				\
	if (!Reserved->Next) {							   	\
		Tail = NULL;									\
	}												   	\
	Head = Reserved->Next;							   	\
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\net\irda\mknet\sys\sir.c ===
/*****************************************************************************
 **																			**
 **	COPYRIGHT (C) 2000, 2001 MKNET CORPORATION								**
 **	DEVELOPED FOR THE MK7100-BASED VFIR PCI CONTROLLER.						**
 **																			**
 *****************************************************************************/

 /**********************************************************************

Module Name:
	SIR.C

Routines:
	NdisToSirPacket
	ComputeSirFCS
	ProcRXSir

Comments:

**********************************************************************/


#include	"precomp.h"
#include	"protot.h"
#pragma		hdrstop



// SIR only
const USHORT fcsTable[256] =
{
        0x0000, 0x1189, 0x2312, 0x329b, 0x4624, 0x57ad, 0x6536, 0x74bf,
        0x8c48, 0x9dc1, 0xaf5a, 0xbed3, 0xca6c, 0xdbe5, 0xe97e, 0xf8f7,
        0x1081, 0x0108, 0x3393, 0x221a, 0x56a5, 0x472c, 0x75b7, 0x643e,
        0x9cc9, 0x8d40, 0xbfdb, 0xae52, 0xdaed, 0xcb64, 0xf9ff, 0xe876,
        0x2102, 0x308b, 0x0210, 0x1399, 0x6726, 0x76af, 0x4434, 0x55bd,
        0xad4a, 0xbcc3, 0x8e58, 0x9fd1, 0xeb6e, 0xfae7, 0xc87c, 0xd9f5,
        0x3183, 0x200a, 0x1291, 0x0318, 0x77a7, 0x662e, 0x54b5, 0x453c,
        0xbdcb, 0xac42, 0x9ed9, 0x8f50, 0xfbef, 0xea66, 0xd8fd, 0xc974,
        0x4204, 0x538d, 0x6116, 0x709f, 0x0420, 0x15a9, 0x2732, 0x36bb,
        0xce4c, 0xdfc5, 0xed5e, 0xfcd7, 0x8868, 0x99e1, 0xab7a, 0xbaf3,
        0x5285, 0x430c, 0x7197, 0x601e, 0x14a1, 0x0528, 0x37b3, 0x263a,
        0xdecd, 0xcf44, 0xfddf, 0xec56, 0x98e9, 0x8960, 0xbbfb, 0xaa72,
        0x6306, 0x728f, 0x4014, 0x519d, 0x2522, 0x34ab, 0x0630, 0x17b9,
        0xef4e, 0xfec7, 0xcc5c, 0xddd5, 0xa96a, 0xb8e3, 0x8a78, 0x9bf1,
        0x7387, 0x620e, 0x5095, 0x411c, 0x35a3, 0x242a, 0x16b1, 0x0738,
        0xffcf, 0xee46, 0xdcdd, 0xcd54, 0xb9eb, 0xa862, 0x9af9, 0x8b70,
        0x8408, 0x9581, 0xa71a, 0xb693, 0xc22c, 0xd3a5, 0xe13e, 0xf0b7,
        0x0840, 0x19c9, 0x2b52, 0x3adb, 0x4e64, 0x5fed, 0x6d76, 0x7cff,
        0x9489, 0x8500, 0xb79b, 0xa612, 0xd2ad, 0xc324, 0xf1bf, 0xe036,
        0x18c1, 0x0948, 0x3bd3, 0x2a5a, 0x5ee5, 0x4f6c, 0x7df7, 0x6c7e,
        0xa50a, 0xb483, 0x8618, 0x9791, 0xe32e, 0xf2a7, 0xc03c, 0xd1b5,
        0x2942, 0x38cb, 0x0a50, 0x1bd9, 0x6f66, 0x7eef, 0x4c74, 0x5dfd,
        0xb58b, 0xa402, 0x9699, 0x8710, 0xf3af, 0xe226, 0xd0bd, 0xc134,
        0x39c3, 0x284a, 0x1ad1, 0x0b58, 0x7fe7, 0x6e6e, 0x5cf5, 0x4d7c,
        0xc60c, 0xd785, 0xe51e, 0xf497, 0x8028, 0x91a1, 0xa33a, 0xb2b3,
        0x4a44, 0x5bcd, 0x6956, 0x78df, 0x0c60, 0x1de9, 0x2f72, 0x3efb,
        0xd68d, 0xc704, 0xf59f, 0xe416, 0x90a9, 0x8120, 0xb3bb, 0xa232,
        0x5ac5, 0x4b4c, 0x79d7, 0x685e, 0x1ce1, 0x0d68, 0x3ff3, 0x2e7a,
        0xe70e, 0xf687, 0xc41c, 0xd595, 0xa12a, 0xb0a3, 0x8238, 0x93b1,
        0x6b46, 0x7acf, 0x4854, 0x59dd, 0x2d62, 0x3ceb, 0x0e70, 0x1ff9,
        0xf78f, 0xe606, 0xd49d, 0xc514, 0xb1ab, 0xa022, 0x92b9, 0x8330,
        0x7bc7, 0x6a4e, 0x58d5, 0x495c, 0x3de3, 0x2c6a, 0x1ef1, 0x0f78
};





ULONG __inline EscapeSlowIrData(PUCHAR Dest, UCHAR SourceByte)
{
    switch (SourceByte){
        case SIR_BOF:
        case SIR_EOF:
        case SIR_ESC:
            Dest[0] = SIR_ESC;
            Dest[1] = SourceByte ^ SIR_ESC_COMP;
            return 2;

        default:
            Dest[0] = SourceByte;
            return 1;
    }
}




//-----------------------------------------------------------------------------
// Procedure:	[NdisToSirPacket]
//-----------------------------------------------------------------------------
BOOLEAN NdisToSirPacket	(PMK7_ADAPTER Adapter,
						PNDIS_PACKET Packet,
						UCHAR *irPacketBuf,
						UINT irPacketBufLen,
						UINT *irPacketLen
					)
{
	PNDIS_BUFFER    CurrentBuffer, NextBuffer;
	UINT			CurrentLength;
	PVOID           VirtualAddress;
	PNDIS_BUFFER ndisBuf;
	UINT i, ndisPacketBytes = 0, I_fieldBytes, totalBytes = 0;
	UINT ndisPacketLen, numExtraBOFs;
	SIR_FCS_TYPE fcs;
	UCHAR nextChar;
    UCHAR *bufData;
    UINT bufLen;
	PNDIS_IRDA_PACKET_INFO packetInfo = GetPacketInfo(Packet);


	// Get the packet's entire length and its first NDIS buffer
	NdisQueryPacket(Packet, NULL, NULL, &ndisBuf, &ndisPacketLen);

	// Make sure that the packet is big enough to be legal.
	// It consists of an A, C, and variable-length I field.
	if (ndisPacketLen < ADDR_SIZE + CONTROL_SIZE){
//		DBGERR(("packet too short in NdisToIrPacket (%d bytes)", ndisPacketLen));
		return (FALSE);
	}
	else {
		I_fieldBytes = ndisPacketLen - ADDR_SIZE - CONTROL_SIZE;
	}


	// Make sure that we won't overwrite our contiguous buffer.
	// Make sure that the passed-in buffer can accomodate this packet's
	// data no matter how much it grows through adding ESC-sequences, etc.
	if (ndisPacketLen > MK7_MAXIMUM_PACKET_SIZE) {
		// The packet is too large
		// Tell the caller to retry with a packet size large
		// enough to get past this stage next time.
		//DBGERR(("Packet too large in NdisToIrPacket (%d=%xh bytes), MAX_IRDA_DATA_SIZE=%d, irPacketBufLen=%d.",  ndisPacketLen, ndisPacketLen, MAX_IRDA_DATA_SIZE, irPacketBufLen));
		*irPacketLen = ndisPacketLen;
		return (FALSE);
	}
	
    if (!ndisBuf) {
        // DBGERR(("No NDIS_BUFFER in NdisToIrPacket"));
        return (FALSE);
    }
	
	
	CurrentBuffer = ndisBuf;
	while (CurrentBuffer != NULL) {
			NdisQueryBufferSafe(CurrentBuffer, &VirtualAddress, &CurrentLength, 16);
			if (!VirtualAddress) {
#if DBG
				DbgPrint("==> Throw Away Failed Packet\n\r");
#endif
				return (FALSE);
			}
			NdisGetNextBuffer(CurrentBuffer, &NextBuffer);
			CurrentBuffer = NextBuffer;
	}

	// NDIS requirement
//  NdisQueryBuffer(ndisBuf, (PVOID *)&bufData, &bufLen);
    NdisQueryBufferSafe(ndisBuf, (PVOID *)&bufData, &bufLen,16);

	/*
	 *  Now begin building the IR frame.
	 *
	 *  This is the final format:
	 *
	 *      extra BOFs ...
	 *		BOF	(1)
	 *		NdisMediumIrda packet (what we get from NDIS):
	 *			Address (1)
	 *			Control (1)
	 *		FCS	(2)
	 *      EOF (1)
	 */

    // Prepend BOFs (extra BOFs + 1 actual BOF)
	// 4.1.0
	if ((Adapter->HwVersion==HW_VER_1) && (Adapter->CurrentSpeed <= MAX_SIR_SPEED))
		numExtraBOFs = HW_VER_1_EBOFS;	
	else
		numExtraBOFs = packetInfo->ExtraBOFs;

	
	if (numExtraBOFs > MAX_EXTRA_SIR_BOFS) {
		numExtraBOFs = MAX_EXTRA_SIR_BOFS;
	}
	for (i = totalBytes = 0; i < numExtraBOFs; i++) {
		*(SIR_BOF_TYPE *)(irPacketBuf+totalBytes) = SIR_EXTRA_BOF;
		totalBytes += SIR_EXTRA_BOF_SIZE;
	}
	*(SIR_BOF_TYPE *)(irPacketBuf+totalBytes) = SIR_BOF;
	totalBytes += SIR_BOF_SIZE;

    fcs = 0xffff;

	// Fill TX buff w/ I data & calculate FCS as we go
    for (i=0; i<ndisPacketLen; i++) {

        ASSERT(bufData);
        nextChar = *bufData++;
        fcs = (fcs >> 8) ^ fcsTable[(fcs ^ nextChar) & 0xff];

		totalBytes += EscapeSlowIrData(&irPacketBuf[totalBytes], nextChar);
		
        if (--bufLen==0) {
            NdisGetNextBuffer(ndisBuf, &ndisBuf);
            if (ndisBuf) {
				// NDIS requriement
//				NdisQueryBuffer(ndisBuf, (PVOID *)&bufData, &bufLen);
				NdisQueryBufferSafe(ndisBuf, (PVOID *)&bufData, &bufLen,16);
            }
            else {
                bufData = NULL;
            }
        }
    }


    if (bufData != NULL) {
		// Packet was corrupt -- it misreported its size.
		// DBGERR(("Packet corrupt in NdisToIrPacket (buffer lengths don't add up to packet length)."));
		*irPacketLen = 0;
		return (FALSE);
    }

    fcs = ~fcs;

	// Put in the 16-bit FCS
    totalBytes += EscapeSlowIrData(&irPacketBuf[totalBytes], (UCHAR)(fcs&0xff));
    totalBytes += EscapeSlowIrData(&irPacketBuf[totalBytes], (UCHAR)(fcs>>8));

    // EOF
	*(SIR_EOF_TYPE *)&irPacketBuf[totalBytes] = SIR_EOF;
	totalBytes += SIR_EOF_SIZE;

	*irPacketLen = totalBytes;

//	DBGOUT(("... NdisToIrPacket converted %d-byte ndis pkt to %d-byte irda pkt:", ndisPacketLen, *irPacketLen));

	return (TRUE);
}



//----------------------------------------------------------------------
// Procedure:	[ComputeSirFCS]
//
//----------------------------------------------------------------------
USHORT ComputeSirFCS(UCHAR *data, UINT dataLen)
{
  USHORT fcs = 0xffff;
  UINT i;
 	
//  DBGOUT(("ComputeSirFCS() on %d-byte buffer.", dataLen));

  for (i = 0; i < dataLen; i++){
    fcs = (fcs >> 8) ^ fcsTable[(fcs ^ *data++) & 0xff];
  }

  fcs = ~fcs;

//  DBGOUT(("ComputeFCS returning %d=0x%x.", (UINT)fcs, (UINT)fcs));

  return (fcs);
}


//-----------------------------------------------------------------------------
// Procedure:   [ProcRXSir]
//
//-----------------------------------------------------------------------------
BOOLEAN	ProcRXSir(UCHAR *dBuff, UINT dCnt)
{
	USHORT fcs;


	// FCS is not computed over the FCS field. Need to look into this.
	// (It seems when the original FCS is included in the calculation,
	// we should get GOOD_FCS for result.)

	fcs = ComputeSirFCS(dBuff, dCnt);

	if (fcs != GOOD_FCS)
		return (FALSE);

	return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\net\irda\mknet\sys\send.c ===
/*****************************************************************************
 **																			**
 **	COPYRIGHT (C) 2000, 2001 MKNET CORPORATION								**
 **	DEVELOPED FOR THE MK7100-BASED VFIR PCI CONTROLLER.						**
 **																			**
 *****************************************************************************/

/**********************************************************************

Module Name:
	SEND.C

Routines:
	MKMiniportMultiSend
	SendPkt
	PrepareForTransmit
	CopyFromPacketToBuffer
	MinTurnaroundTxTimeout
	[TestDataToTXBuff]

Comments:
	Transmits in the NDIS env.

**********************************************************************/

#include	"precomp.h"
#include	"protot.h"
#pragma		hdrstop



#if	DBG
// for debug/test
extern VOID TestDataToTXBuff(PCHAR, UINT, PUINT);
#define	TEST_PATTERN_SIZE 16
CHAR	TestPattern[] = {0,1,2,3,4,5,6,7,8,9,0x0A,0x0B,0x0C,0x0D,0x0E,0x0F};
#endif


//-----------------------------------------------------------------------------
// Procedure:	[MKMiniportMultiSend]
//
// Description:	This routine simply takes the pkt(s) passed down and queues
//		it to the trasmit queue (FirstTxQueue) for later processing. Each
//		pkt is marked NDIS_STATUS_PENDING) before returning.
//
// Arguments:
//		MiniportAdapterContext (Adapter Structure pointer)
//      PacketArray - an array of pointers to NDIS_PACKET structs
//      PacketCount - number of packets in PacketArray
//
// Returns:		(none)	
//
//-----------------------------------------------------------------------------
VOID
MKMiniportMultiSend(NDIS_HANDLE MiniportAdapterContext,
					PPNDIS_PACKET PacketArray,
					UINT NumberOfPackets)
{
    PMK7_ADAPTER	Adapter;
    NDIS_STATUS		Status;
    UINT			PacketCount;
	UINT			i;
	PNDIS_PACKET	QueuePacket;


    DBGFUNC("=> MKMiniportMultiSend");
	DBGLOG("=> MKMiniportMultiSend", 0);

    Adapter = PMK7_ADAPTER_FROM_CONTEXT_HANDLE(MiniportAdapterContext);

    NdisAcquireSpinLock(&Adapter->Lock);

#if	DBG
	Adapter->DbgSendCallCnt++;
	GDbgStat.txSndCnt++;
	Adapter->DbgSentCnt++;
	Adapter->DbgSentPktsCnt += NumberOfPackets; 
#endif


	// Q 'em up 1st
    for(PacketCount=0; PacketCount < NumberOfPackets; PacketCount++) {
    	Adapter->NumPacketsQueued++;
		EnqueuePacket(	Adapter->FirstTxQueue,
						Adapter->LastTxQueue,
						PacketArray[PacketCount] );
		NDIS_SET_PACKET_STATUS(PacketArray[PacketCount], NDIS_STATUS_PENDING);
	}

	if (Adapter->writePending || (Adapter->IOMode == TX_MODE)) {
		// In TX mode: Meaning TX outstanding. We wait for the TX comp to kick
		// off the next TX.
		// Or we have writePending, which means a pkt is on q waiting for
		// MinTurnaroundTimeout.
		DBGLOG("<= MKMiniportMultiSend: TX_MODE", 0);
	    NdisReleaseSpinLock(&Adapter->Lock);
		return;
	}

	ASSERT(Adapter->tcbUsed == 0);

	QueuePacket = Adapter->FirstTxQueue;

	Status = SendPkt(Adapter, QueuePacket);

	DBGLOG("<= MKMiniportMultiSend", 0);

    NdisReleaseSpinLock(&Adapter->Lock);

	MK7EnableInterrupt(Adapter);
}



//-----------------------------------------------------------------------------
// Procedure:   [SendPkt]
//
// Description:	This sets up (copies) the pkt to the TX ring data buffer in
//		preparation for TX. The caller then needs to Enable Int & Prompt to
//		initiate the actual tx at hw level.
//
// Arguments:
//      Adapter - ptr to Adapter object instance
//      Packet - A pointer to a descriptor for the packet that is to be
//               transmitted.
// Returns:
//      NDIS_STATUS_SUCCESS - We copied the entire packet into a TRD data buff,
//                            so we can immediately return the packet/buffer
//							  back to the upper layers.
//		NDIS_STATUS_RESOURCE - No resource. NDIS should re-send this to us
//							  at a later time. (Caller should re-Q the pkt.)
//----------------------------------------------------------------------
NDIS_STATUS
SendPkt(	PMK7_ADAPTER Adapter,
			PNDIS_PACKET Packet)
{
	PTCB	tcb;
	UINT	bytestosend, sndcnt, nextavail;
	MK7REG	mk7reg;
	BOOLEAN	timeout;
    PNDIS_IRDA_PACKET_INFO packetInfo;
	PNDIS_PACKET	QueuePacket;


	//****************************************
	// To send a pkt we do the following:
	// 1.	Check Min Turnaround Time.
	// 2.	Check if there's avail TX resource. It not we return "resource".
	//		(We assume that there's outstanding TXs to trigger subseuqent TX
	//		completion interrupts, which will keep the ball rolling.)
	//		(RYM-IRDA-5+ Need to talk to Wayne about missed interrupts.)
	// 3.	Copy the NDIS pkt into the contiguous TX buffer.
	// 4.	The copied pkt could have been marked as the last pkt to go out
	//		at the old speed after which we change speed. We check for this.
	//****************************************
    DBGFUNC("=> SendPkt");	
	DBGLOG("=> SendPkt", 0);


    packetInfo = GetPacketInfo(Packet);
    if (packetInfo->MinTurnAroundTime) {

	    UINT usecToWait = packetInfo->MinTurnAroundTime;
		UINT msecToWait;
        packetInfo->MinTurnAroundTime = 0;

		DBGLOG("<= SendPkt: Delay TX", 0);


		// Need to set IOMode = TX  so if a multisend comes down before
		// the delayed TX timer goes off we just q.
		
		
		// Ndis timer has a 1ms granularity (in theory).  Let's round off.
        msecToWait = (usecToWait<1000) ? 1 : (usecToWait+500)/1000;
        NdisMSetTimer(&Adapter->MinTurnaroundTxTimer, msecToWait);
// 4.0.1 BOC
		MK7SwitchToTXMode(Adapter);
// 4.0.1 EOC
		Adapter->writePending = TRUE;

        return (NDIS_STATUS_PENDING); // Say we're successful.  We'll come back here.
	}


	// Avail TX resource
	if (Adapter->tcbUsed >= Adapter->NumTcb) {
#if	DBG
		GDbgStat.txNoTcb++;
#endif
		DBGSTR(("STATUS (SendPkt): No avail TCB\n"));
		return (NDIS_STATUS_RESOURCES);
	}

	tcb = Adapter->pTcbArray[Adapter->nextAvailTcbIdx];

	bytestosend = PrepareForTransmit(Adapter, Packet, tcb);

	if (Adapter->changeSpeedAfterThisPkt == Packet) {
		Adapter->changeSpeedAfterThisPkt = NULL;
		Adapter->changeSpeedPending = CHANGESPEED_ON_DONE;
	}

#if	DBG
	if (bytestosend > GDbgStat.txLargestPkt) {
		GDbgStat.txLargestPkt = bytestosend;
	}
#endif

	// 1.0.0
	if (bytestosend == 0) {
#if DBG
		DbgPrint ("==> OB \n\r");
#endif
			// Simplified change speed
		if (Adapter->changeSpeedPending == CHANGESPEED_ON_DONE) {
			// Note: We're changing speed in TX mode.
			MK7ChangeSpeedNow(Adapter);
			Adapter->changeSpeedPending = 0;
		}
			// For each completing TX there's a corresponding q'd pkt.
			// We release it here.
			QueuePacket = Adapter->FirstTxQueue;
			DequeuePacket(Adapter->FirstTxQueue, Adapter->LastTxQueue);
			Adapter->NumPacketsQueued--;
			NDIS_SET_PACKET_STATUS(QueuePacket, NDIS_STATUS_RESOURCES);
			NdisMSendComplete(	Adapter->MK7AdapterHandle,
								QueuePacket,
								NDIS_STATUS_RESOURCES);
			return(NDIS_STATUS_RESOURCES);
	}

	// Take care of ring wrap when incrementing.
	Adapter->nextAvailTcbIdx++;
	Adapter->nextAvailTcbIdx %= Adapter->NumTcb;
	Adapter->tcbUsed++;


	tcb->trd->count = bytestosend;

	GrantTrdToHw(tcb->trd);
	MK7SwitchToTXMode(Adapter);


#if	DBG
	NdisGetCurrentSystemTime((PLARGE_INTEGER)&GDbgTACmdTime[GDbgTATimeIdx]);
#endif

	DBGLOG("<= SendPkt", 0);

	return (NDIS_STATUS_SUCCESS);
}



//-----------------------------------------------------------------------------
// Procedure:   [PrepareForTransmit]
//
// Description:	When we come here we know there's an available TCB for the next
//		TX. We move the Packet data into the tx buff associated w/ the TCB.
//
// Arguments:
//      Adapter - ptr to Adapter object instance
//      Packet - A pointer to a descriptor for the packet that is to be
//               transmitted.
//      SwTcb - Pointer to a software structure that represents a hardware TCB.
//
// Returns:
//      TRUE If we were able to acquire the necessary TRD's or Coalesce buffer
//           for the packet in we are attempting to prepare for transmission.
//      FALSE If we needed a coalesce buffer, and we didn't have any available.
//-----------------------------------------------------------------------------
UINT PrepareForTransmit(PMK7_ADAPTER Adapter,
                   PNDIS_PACKET Packet,
                   PTCB tcb)
{
	UINT	BytesCopied;


	if (Adapter->CurrentSpeed <= MAX_SIR_SPEED) {
		// SIR needs additional software process
		if ( NdisToSirPacket(Adapter,
							Packet,
							(UCHAR *)tcb->buff,
							MK7_MAXIMUM_PACKET_SIZE,
							&BytesCopied) ) {

			return(BytesCopied);
		}
		return(0);
	}


#if	DBG
	if (Adapter->DbgTestDataCnt > 0) {
		TestDataToTXBuff(tcb->buff, Adapter->DbgTestDataCnt, &BytesCopied);
		return(BytesCopied);
	}
#endif


	tcb->Packet = Packet;
    NdisQueryPacket(tcb->Packet,
			        &tcb->NumPhysDesc,
	    	    	&tcb->BufferCount,
		    	    &tcb->FirstBuffer,
        			&tcb->PacketLength);

	// Alignment??
	//
	// Copy from packet to TCB data buffer
	CopyFromPacketToBuffer(	Adapter,
								tcb->Packet,
								tcb->PacketLength,
								tcb->buff,
								tcb->FirstBuffer,
								&BytesCopied );

//	ASSERT(BytesCopied == tcb->PacketLength);
	if (BytesCopied != tcb->PacketLength) {
#if DBG
		DbgPrint (" ==> BytesCopied Unmatched\n\r");
#endif
		return(0);
	}
	else 
		return(BytesCopied);
}



//-----------------------------------------------------------------------------
// Procedure:   [CopyFromPacketToBuffer]
//
// Description: This routine will copy a packet to a the passed buffer (which
//		in this case will be a coalesce buffer).
//
// Arguments:
//      Adapter - ptr to Adapter object instance
//      Packet - The packet to copy from.
//      BytesToCopy - The number of bytes to copy from the packet.
//      DestBuffer - The destination of the copy.
//      FirstBuffer - The first buffer of the packet that we are copying from.
//
// Result:
//      BytesCopied - The number of bytes actually copied
//
// Returns:		(none)
//-----------------------------------------------------------------------------
VOID
CopyFromPacketToBuffer( PMK7_ADAPTER Adapter,
                           PNDIS_PACKET Packet,
                           UINT BytesToCopy,
                           PCHAR DestBuffer,
                           PNDIS_BUFFER FirstBuffer,
                           PUINT BytesCopied)
{
	PNDIS_BUFFER    CurrentBuffer, NextBuffer;
    PVOID           VirtualAddress;
    UINT            CurrentLength;
    UINT            AmountToMove;

    *BytesCopied = 0;
    if (!BytesToCopy)
        return;

	if (FirstBuffer == NULL)
		return;
    
	CurrentBuffer = FirstBuffer;

	while (CurrentBuffer != NULL) {
			NdisQueryBufferSafe(CurrentBuffer, &VirtualAddress, &CurrentLength, 16);
			if (!VirtualAddress) {
#if DBG
				DbgPrint("==> Throw Away Failed Packet\n\r");
#endif
				return;
			}
			NdisGetNextBuffer(CurrentBuffer, &NextBuffer);
			CurrentBuffer = NextBuffer;
	}
    CurrentBuffer = FirstBuffer;
	// NDIS requirement
//  NdisQueryBuffer(CurrentBuffer,&VirtualAddress,&CurrentLength);
	NdisQueryBufferSafe(CurrentBuffer, &VirtualAddress, &CurrentLength, 16);

    while (BytesToCopy) {
        while (!CurrentLength) {
            NdisGetNextBuffer(CurrentBuffer, &CurrentBuffer);

            // If we've reached the end of the packet.  We return with what
            // we've done so far (which must be shorter than requested).
            if (!CurrentBuffer)
                return;

			// NDIS requirement
//			 NdisQueryBuffer(CurrentBuffer,&VirtualAddress,&CurrentLength);
			 NdisQueryBufferSafe(CurrentBuffer, &VirtualAddress, &CurrentLength, 16);


        }

        // Compute how much data to move from this fragment
        if (CurrentLength > BytesToCopy)
            AmountToMove = BytesToCopy;
        else
            AmountToMove = CurrentLength;

        // Copy the data.
        NdisMoveMemory(DestBuffer, VirtualAddress, AmountToMove);

        // Update destination pointer
        DestBuffer = (PCHAR) DestBuffer + AmountToMove;

        // Update counters
        *BytesCopied +=AmountToMove;
        BytesToCopy -=AmountToMove;
        CurrentLength = 0;
    }

	DBGLOG("  CopyFromPacketToBuffer: Bytes to Copy = ", BytesToCopy);
	DBGLOG("  CopyFromPacketToBuffer: Bytes Copied  = ", *BytesCopied);
}


//-----------------------------------------------------------------------------
// Procedure:	[MinTurnaroundTxTimeout] RYM-2K-1TX
//
// Description:	Delayed write because of Min Turnaround requirement. Just
//				do send.
//-----------------------------------------------------------------------------
VOID MinTurnaroundTxTimeout(PVOID sysspiff1,
							NDIS_HANDLE MiniportAdapterContext,
 							PVOID sysspiff2,
 							PVOID sysspiff3)
{
	PMK7_ADAPTER	Adapter;
	PNDIS_PACKET	QueuePacket;
    NDIS_STATUS		Status;


	Adapter = PMK7_ADAPTER_FROM_CONTEXT_HANDLE(MiniportAdapterContext);

	DBGLOG("=> MinTurnaroundTxTimeout", 0);

    NdisAcquireSpinLock(&Adapter->Lock);

	QueuePacket = Adapter->FirstTxQueue;

	if (!QueuePacket) {
	    NdisReleaseSpinLock(&Adapter->Lock);
		return;
	}

	Status = SendPkt(Adapter, QueuePacket);

	// Note: We set false here because we just processed a q'd TX pkt
	// that was waiting for MinTurnaround. However, we may still stay
	// in TX mode based on other pkts on the q. This is determined in
	// TX comp. Either writePending or IOMode will prevent new pkts
	// from above to get thru out of sequence.
	Adapter->writePending = FALSE;

    NdisReleaseSpinLock(&Adapter->Lock);

	MK7EnableInterrupt(Adapter);
}



#if	DBG
//--------------------------------------------------------------------------------
// Procedure:	[TestDataToTXBuff]
//
// Description:	Put test data in tx buff instead of data that came down.
//--------------------------------------------------------------------------------
VOID TestDataToTXBuff(	PCHAR	DestBuffer,
						UINT	BytesToCopy,
						PUINT	BytesCopied)
{
	UINT	i, j;

	for(i=0,j=0; j<BytesToCopy; j++) {
		DestBuffer[j] = TestPattern[i];
		i++;
		i %= TEST_PATTERN_SIZE;
	}
	*BytesCopied = BytesToCopy;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\net\irda\mknet\sys\protot.h ===
/*****************************************************************************
 **																			**
 **	COPYRIGHT (C) 2000, 2001 MKNET CORPORATION								**
 **	DEVELOPED FOR THE MK7100-BASED VFIR PCI CONTROLLER.						**
 **																			**
 *****************************************************************************/

/**********************************************************************

Module Name:
	PROTOT.H

Comments:	
	Prototype all extern function references and globle variables.

**********************************************************************/

// DBG.C
#if	DBG
// MyLogEvent
// MyLogPhysEvent
extern	VOID 		DbgTestInit(PMK7_ADAPTER);
extern	VOID 		MK7DbgTestIntTmo(PVOID, NDIS_HANDLE, PVOID, PVOID);
extern	VOID		DbgInterPktTimeGap();

extern	MK7DBG_STAT	GDbgStat;
#endif


// INTERRUPT.C
extern	VOID		MKMiniportIsr(PBOOLEAN, PBOOLEAN, NDIS_HANDLE);
extern	VOID		MKMiniportHandleInterrupt(IN NDIS_HANDLE);
extern	VOID		ProcessTXCompIsr(PMK7_ADAPTER);
extern	VOID		ProcessRXCompIsr(PMK7_ADAPTER);
extern	VOID		ProcessTXComp(PMK7_ADAPTER);
extern	VOID		ProcessRXComp(PMK7_ADAPTER);


// MK7COMM.C
#if DBG
extern	VOID		MK7Reg_Read(PVOID, ULONG, USHORT *);
extern	VOID		MK7Reg_Write(PVOID, ULONG, USHORT);
#endif
extern	NDIS_STATUS	MK7DisableInterrupt(PMK7_ADAPTER);
extern	NDIS_STATUS	MK7EnableInterrupt(PMK7_ADAPTER);
extern	VOID		MK7SwitchToRXMode(PMK7_ADAPTER);
extern	VOID		MK7SwitchToTXMode(PMK7_ADAPTER);
extern	BOOLEAN		SetSpeed(PMK7_ADAPTER);
extern	VOID		MK7ChangeSpeedNow(PMK7_ADAPTER);

extern	baudRateInfo	supportedBaudRateTable[];



// MKINIT.C
extern	NDIS_STATUS ClaimAdapter(PMK7_ADAPTER, NDIS_HANDLE);
extern	NDIS_STATUS SetupIrIoMapping(PMK7_ADAPTER);
extern	NDIS_STATUS SetupAdapterInfo(PMK7_ADAPTER);
extern	NDIS_STATUS AllocAdapterMemory(PMK7_ADAPTER);
//(ReleaseAdapterMemory)
extern	VOID 		FreeAdapterObject(PMK7_ADAPTER);
extern	VOID		SetupTransmitQueues(PMK7_ADAPTER, BOOLEAN);
extern	VOID		SetupReceiveQueues(PMK7_ADAPTER);

// (InitializeMK7)
// 1.0.0
extern	VOID		ResetTransmitQueues(PMK7_ADAPTER, BOOLEAN);
extern  VOID		ResetReceiveQueues(PMK7_ADAPTER);
extern  VOID		MK7ResetComplete(PVOID,NDIS_HANDLE,PVOID,PVOID);

extern	BOOLEAN		InitializeAdapter(PMK7_ADAPTER);
extern	VOID 		StartAdapter(PMK7_ADAPTER);	




// MKMINI.C
//	MKMiniportReturnPackets
//	MKMiniportReturnPackets
//	MKMiniportCheckForHang
//	MKMiniportHalt
//	MKMiniportShutdownHandler
//	MKMiniportInitialize
//	MKMiniportReset
//	(MK7EnableInterrupt & Disable in MK7COMM.C.)
//	DriverEntry


// SEND.C
extern	VOID		MKMiniportMultiSend(NDIS_HANDLE, PPNDIS_PACKET, UINT);
extern	NDIS_STATUS SendPkt(PMK7_ADAPTER, PNDIS_PACKET);
extern	UINT		PrepareForTransmit(PMK7_ADAPTER, PNDIS_PACKET, PTCB);
extern	VOID		CopyFromPacketToBuffer(	PMK7_ADAPTER,
						PNDIS_PACKET,
   		            	UINT,
       		   			PCHAR,
       					PNDIS_BUFFER,
       					PUINT);
extern	VOID		MinTurnaroundTxTimeout(PVOID, NDIS_HANDLE, PVOID, PVOID);


// SIR.C
extern	BOOLEAN		NdisToSirPacket(PMK7_ADAPTER, PNDIS_PACKET, UCHAR *, UINT, UINT *);
extern	USHORT		ComputeSirFCS(PUCHAR, UINT);
extern	BOOLEAN		ProcRXSir(PUCHAR, UINT);


// UTIL.C
extern	PNDIS_IRDA_PACKET_INFO GetPacketInfo(PNDIS_PACKET);
extern	VOID		ProcReturnedRpd(PMK7_ADAPTER, PRPD);



// WINOIDS.C
extern	NDIS_STATUS MKMiniportQueryInformation(NDIS_HANDLE,
						NDIS_OID,
						PVOID,
						ULONG,
						PULONG,
						PULONG);
extern	NDIS_STATUS MKMiniportSetInformation(NDIS_HANDLE,
						NDIS_OID,
						PVOID,
						ULONG,
						PULONG,
						PULONG);

// WINPCI.C
extern	USHORT		FindAndSetupPciDevice(PMK7_ADAPTER,
						NDIS_HANDLE,
						USHORT,
						USHORT,
						PPCI_CARDS_FOUND_STRUC);

// WINREG.C
extern	NDIS_STATUS ParseRegistryParameters(PMK7_ADAPTER, NDIS_HANDLE);
extern	NDIS_STATUS ProcessRegistry(PMK7_ADAPTER, NDIS_HANDLE);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\net\irda\mknet\sys\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by IRMK7.RC
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\net\irda\mknet\sys\util.c ===
/*****************************************************************************
 **																			**
 **	COPYRIGHT (C) 2000, 2001 MKNET CORPORATION								**
 **	DEVELOPED FOR THE MK7100-BASED VFIR PCI CONTROLLER.						**
 **																			**
 *****************************************************************************/

/**********************************************************************

Module Name:
	UTIL.C

Routines:
	GetPacketInfo
 	ProcReturnedRpd

Comments:
	Various utilities to assist in operating in the NDIS env.

**********************************************************************/


#include	"precomp.h"
//#include	"protot.h"
#pragma		hdrstop




//-----------------------------------------------------------------------------
// Procedure:	[GetPacketInfo]
//
//-----------------------------------------------------------------------------
PNDIS_IRDA_PACKET_INFO GetPacketInfo(PNDIS_PACKET packet)
{
    MEDIA_SPECIFIC_INFORMATION *mediaInfo;
    UINT size;
    NDIS_GET_PACKET_MEDIA_SPECIFIC_INFO(packet, &mediaInfo, &size);
    return (PNDIS_IRDA_PACKET_INFO)mediaInfo->ClassInformation;
}



//----------------------------------------------------------------------
// Procedure:	[ProcReturnedRpd]
//
// Description:	Process a RPD (previously indicated pkt) being returned
//		to us from NDIS.
//
//----------------------------------------------------------------------
VOID ProcReturnedRpd(PMK7_ADAPTER Adapter, PRPD rpd)
{
	NdisAdjustBufferLength(rpd->ReceiveBuffer, MK7_MAXIMUM_PACKET_SIZE);

	//******************************
	// If a RCB is waiting for a RPD, bind the RPD to the RCB-RRD
	// and give the RCB-RRD to hw.	Else, put the RPD on FreeRpdList.
	//******************************

	if (Adapter->rcbPendRpdCnt > 0) {
		PRCB	rcb;

		rcb = Adapter->pRcbArray[Adapter->rcbPendRpdIdx];
		rcb->rpd = rpd;
		rcb->rrd->addr = rpd->databuffphys;
		rcb->rrd->count = 0;
		GrantRrdToHw(rcb->rrd);

		Adapter->rcbPendRpdCnt--;

		//****************************************
		// If more RCBs waiting for RPDs then need to
		// bump the index up, taking care of wrapping.
		//****************************************
		if (Adapter->rcbPendRpdCnt > 0) {
			Adapter->rcbPendRpdIdx++;
			Adapter->rcbPendRpdIdx %= Adapter->NumRcb;
		}
	}
	else {
		QueuePutTail(&Adapter->FreeRpdList, &rpd->link);
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\net\irda\mknet\sys\wincomm.h ===
/*****************************************************************************
 **																			**
 **	COPYRIGHT (C) 2000, 2001 MKNET CORPORATION								**
 **	DEVELOPED FOR THE MK7100-BASED VFIR PCI CONTROLLER.						**
 **																			**
 *****************************************************************************/

/**********************************************************************

Module Name:
	WINCOMM.H

Comments:

**********************************************************************/

#ifndef	_WINCOMM_H
#define	_WINCOMM_H


#define MK7_NDIS_MAJOR_VERSION		5
#define MK7_NDIS_MINOR_VERSION		0
#define MK7_DRIVER_VERSION ((MK7_NDIS_MAJOR_VERSION*0x100) + MK7_NDIS_MINOR_VERSION)
#define MK7_MAJOR_VERSION			0
#define MK7_MINOR_VERSION			1
#define MK7_LETTER_VERSION			'a'

// SIR
#define NDIS_IRDA_SPEED_2400       (UINT)(0 << 0)	// Not supported
#define NDIS_IRDA_SPEED_9600       (UINT)(1 << 1)
#define NDIS_IRDA_SPEED_19200      (UINT)(1 << 2)
#define NDIS_IRDA_SPEED_38400      (UINT)(1 << 3)
#define NDIS_IRDA_SPEED_57600      (UINT)(1 << 4)
#define NDIS_IRDA_SPEED_115200     (UINT)(1 << 5)
// MIR
#define NDIS_IRDA_SPEED_576K       (UINT)(1 << 6)
#define NDIS_IRDA_SPEED_1152K      (UINT)(1 << 7)
// FIR
#define NDIS_IRDA_SPEED_4M         (UINT)(1 << 8)
// VFIR
#define	NDIS_IRDA_SPEED_16M			(UINT)(1 << 9)


//
// Speed bit masks
//
#define ALL_SLOW_IRDA_SPEEDS (							\
	NDIS_IRDA_SPEED_9600  |								\
	NDIS_IRDA_SPEED_19200 | NDIS_IRDA_SPEED_38400 |		\
	NDIS_IRDA_SPEED_57600 | NDIS_IRDA_SPEED_115200)

#define ALL_IRDA_SPEEDS (													\
	ALL_SLOW_IRDA_SPEEDS | NDIS_IRDA_SPEED_576K | NDIS_IRDA_SPEED_1152K |		\
	NDIS_IRDA_SPEED_4M   | NDIS_IRDA_SPEED_16M)


// For processing Registry entries
#define MK7_OFFSET(field)		( (UINT) FIELD_OFFSET(MK7_ADAPTER,field) )
#define MK7_SIZE(field)	  		sizeof( ((MK7_ADAPTER *)0)->field )


// NDIS multisend capability may send >1 pkt for TX at a time.
// This comes down in an array. Since we queue them up and process
// TX at a time, this number does not necessarily have to match
// the count of TX ring size.
#define	 MAX_ARRAY_SEND_PACKETS		8
// limit our receive routine to indicating this many at a time
// IMPORTANT: Keep this less than TCB or ringsize count for now or
// the algorithm may break
#define	 MAX_ARRAY_RECEIVE_PACKETS	16
//#define	 MAX_ARRAY_RECEIVE_PACKETS	1


#define NUM_BYTES_PROTOCOL_RESERVED_SECTION	   16


// NDIS BusType values
#define		ISABUS			 1
#define		EISABUS			 2
#define		PCIBUS			 5


// IRDA-5 ?
//- Driver defaults
#define		LOOKAHEAD_SIZE		222


//- Macros peculiar to NT
//- The highest physical address that can be allocated to buffers.
//  Non-page system mem.

// 1.0.0 NDIS requirements
#define		MEMORY_TAG			'tNKM'
//#define ALLOC_SYS_MEM(_pbuffer, _length) NdisAllocateMemory( \
//	(PVOID*)(_pbuffer), \
//	(_length), \
//	0, \
//	HighestAcceptableMax)
#define ALLOC_SYS_MEM(_pbuffer, _length) NdisAllocateMemoryWithTag( \
	(PVOID*)(_pbuffer), \
	(_length), \
	(ULONG)MEMORY_TAG)
#define FREE_SYS_MEM(_buffer,_length) NdisFreeMemory((_buffer), (_length), 0)



#define MAX_PCI_CARDS 12



//-------------------------------------------------------------------------
// PCI Cards found - returns hardware info after scanning for devices
//-------------------------------------------------------------------------
typedef struct _PCI_CARDS_FOUND_STRUC
{
	USHORT NumFound;
	struct
	{
		ULONG			BaseIo;
		UCHAR			ChipRevision;
//		ULONG			SubVendor_DeviceID;
		USHORT			SlotNumber;		// Ndis Slot number
//		ULONG			MemPhysAddress; // CSR Physical address
		UCHAR			Irq;
	} PciSlotInfo[MAX_PCI_CARDS];

} PCI_CARDS_FOUND_STRUC, *PPCI_CARDS_FOUND_STRUC;




// Uniquely defines the location of the error
#define MKLogError(_Adapt, _EvId, _ErrCode, _Spec1) \
	NdisWriteErrorLogEntry((NDIS_HANDLE)(_Adapt)->MK7AdapterHandle, \
		(NDIS_ERROR_CODE)(_ErrCode), (ULONG) 3, (ULONG)(_EvId), \
		(ULONG)(_Spec1), (ULONG_PTR)(_Adapt))


// Each entry in the error log will be tagged with a unique event code so that
// we'll be able to grep the driver source code for that specific event, and
// get an idea of why that particular event was logged.	 Each time a new
// "MKLogError" statement is added to the code, a new Event tag should be
// added below.
//
// RYM10-2
// "-" indicates being used in new code,
// "x" not used in new code.
// "X" not even used in the original code.
typedef enum _MK_EVENT_VIEWER_CODES
{
		EVENT_0,					// - couldn't register the specified interrupt
		EVENT_1,					// - One of our PCI cards didn't get required resources
		EVENT_2,					// x bad node address (it was a multicast address)
		EVENT_3,					// x failed self-test
		EVENT_4,					// X Wait for SCB failed
		EVENT_5,					// X NdisRegisterAdapter failed for the MAC driver
		EVENT_6,					// x WaitSCB failed
		EVENT_7,					// X Command complete status was never posted to the SCB
		EVENT_8,					// X Couldn't find a phy at over-ride address 0
		EVENT_9,					// x Invalid duplex or speed setting with the detected phy
		EVENT_10,					// - Couldn't setup adapter memory
		EVENT_11,					// - couldn't allocate enough map registers
		EVENT_12,					// - couldn't allocate enough RRD/TRD non-cached memory
		EVENT_13,					// - couldn't allocate enough RCB/RPD or TCB cached memory
		EVENT_14,					// - couldn't allocate enough RX non-cached shared memory
		EVENT_15,					// - couldn't allocate enough TX non-cached shared memory
		EVENT_16,					// - Didn't find any PCI boards
		EVENT_17,		   // 11	// X Multiple PCI were found, but none matched our id.
		EVENT_18,		   // 12	// - NdisMPciAssignResources Error
		EVENT_19,		   // 13	// X Didn't Find Any PCI Boards that matched our subven/subdev
		EVENT_20,		   // 14	// x ran out of cached memory to allocate in async allocation
		EVENT_30		   // 1e	// X WAIT_TRUE timed out
} MK_EVENT_VIEWER_CODES;




#endif		// _WINCOMM.H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\net\irda\mknet\sys\winoids.c ===
/*****************************************************************************
 **																			**
 **	COPYRIGHT (C) 2000, 2001 MKNET CORPORATION								**
 **	DEVELOPED FOR THE MK7100-BASED VFIR PCI CONTROLLER.						**
 **																			**
 *****************************************************************************/

 /**********************************************************************

Module Name:
	WINOIDS.C

Routines:
	MKMiniportQueryInformation 
	MKMiniportSetInformation 

Comments:
	Windows-NDIS Sets & Gets of OIDs.

**********************************************************************/


#include	"precomp.h"
#include	"protot.h"
#pragma		hdrstop



//----------------------------------------------------------------------
//  Function:	    MKMiniportQueryInformation
//
//  Description:
//  Query the capabilities and status of the miniport driver.
//
//----------------------------------------------------------------------
NDIS_STATUS MKMiniportQueryInformation (
    IN NDIS_HANDLE MiniportAdapterContext,
    IN NDIS_OID Oid,
    IN PVOID InformationBuffer,
    IN ULONG InformationBufferLength,
    OUT PULONG BytesWritten,
    OUT PULONG BytesNeeded)
{
    NDIS_STATUS result = NDIS_STATUS_SUCCESS;
    PMK7_ADAPTER Adapter = PMK7_ADAPTER_FROM_CONTEXT_HANDLE(MiniportAdapterContext);
    INT i, speeds, speedSupported;
    UINT *infoPtr;
    CHAR *pnpid;
	MK7REG	mk7reg;
//    CMCONFIG_A *hwInfo = (CMCONFIG_A *)InformationBuffer;

    static  NDIS_OID MK7GlobalSupportedOids[] = {
		OID_GEN_SUPPORTED_LIST,
	    OID_GEN_HARDWARE_STATUS,
		OID_GEN_MEDIA_SUPPORTED,
		OID_GEN_MEDIA_IN_USE,
		OID_GEN_MEDIA_CONNECT_STATUS,	// 1.0.0
		OID_GEN_MAXIMUM_LOOKAHEAD,
		OID_GEN_MAXIMUM_FRAME_SIZE,
	 	OID_GEN_MAXIMUM_SEND_PACKETS,
		OID_GEN_MAXIMUM_TOTAL_SIZE,
		OID_GEN_MAC_OPTIONS,
		OID_GEN_PROTOCOL_OPTIONS,
		OID_GEN_LINK_SPEED,
		OID_GEN_TRANSMIT_BUFFER_SPACE,
		OID_GEN_RECEIVE_BUFFER_SPACE,
		OID_GEN_TRANSMIT_BLOCK_SIZE,
		OID_GEN_RECEIVE_BLOCK_SIZE,
		OID_GEN_VENDOR_DESCRIPTION,
   	 	OID_GEN_VENDOR_DRIVER_VERSION,
		OID_GEN_DRIVER_VERSION,
		OID_GEN_CURRENT_PACKET_FILTER,
		OID_GEN_CURRENT_LOOKAHEAD,
		OID_IRDA_RECEIVING,
		OID_IRDA_SUPPORTED_SPEEDS,
		OID_IRDA_LINK_SPEED,
		OID_IRDA_MEDIA_BUSY,
		OID_IRDA_TURNAROUND_TIME,
		OID_IRDA_MAX_RECEIVE_WINDOW_SIZE,
		OID_IRDA_EXTRA_RCV_BOFS };

    static ULONG BaudRateTable[NUM_BAUDRATES] = {
		// Add 16Mbps support; 2400 not supported
		0, 9600, 19200,38400, 57600, 115200, 576000, 1152000, 4000000, 16000000};
    NDIS_MEDIUM Medium = NdisMediumIrda;
    ULONG GenericUlong;
    PVOID SourceBuffer = (PVOID) (&GenericUlong);
    ULONG SourceLength = sizeof(ULONG);


    switch (Oid){

	case OID_GEN_SUPPORTED_LIST:
	    SourceBuffer = (PVOID) (MK7GlobalSupportedOids);
	    SourceLength = sizeof(MK7GlobalSupportedOids);
	    break;

    case OID_GEN_HARDWARE_STATUS:
        GenericUlong = Adapter->hardwareStatus;
        break;

	case OID_GEN_MEDIA_SUPPORTED:
	case OID_GEN_MEDIA_IN_USE:
	    SourceBuffer = (PVOID) (&Medium);
	    SourceLength = sizeof(NDIS_MEDIUM);
	    break;
	case OID_GEN_MEDIA_CONNECT_STATUS:
		GenericUlong = (ULONG) NdisMediaStateConnected;
		break;
	case OID_IRDA_RECEIVING:
	    GenericUlong = (ULONG)Adapter->nowReceiving;
	    break;
			
	case OID_IRDA_SUPPORTED_SPEEDS:
	    speeds = Adapter->supportedSpeedsMask &
					Adapter->AllowedSpeedMask &
					ALL_IRDA_SPEEDS;

        for (i = 0, infoPtr = (PUINT)BaudRateTable, SourceLength=0;
             (i < NUM_BAUDRATES) && speeds;
             i++){

            if (supportedBaudRateTable[i].ndisCode & speeds){
                *infoPtr++ = supportedBaudRateTable[i].bitsPerSec;
                SourceLength += sizeof(UINT);
                speeds &= ~supportedBaudRateTable[i].ndisCode;
            }
        }

	    SourceBuffer = (PVOID) BaudRateTable;
	    break;

	case OID_GEN_LINK_SPEED:
	    GenericUlong = Adapter->MaxConnSpeed;  // 100bps increments
	    break;

	case OID_IRDA_LINK_SPEED:
	    if (Adapter->linkSpeedInfo){
    		GenericUlong = (ULONG)Adapter->linkSpeedInfo->bitsPerSec;
	    }
	    else {
	    	GenericUlong = DEFAULT_BAUD_RATE;
	    }
	    break;


	case OID_IRDA_MEDIA_BUSY:	// 4.1.0
		if (Adapter->HwVersion == HW_VER_1){
			if (Adapter->nowReceiving==TRUE){
				NdisAcquireSpinLock(&Adapter->Lock);
				Adapter->mediaBusy=TRUE;
				NdisReleaseSpinLock(&Adapter->Lock);
			}
			else {
				NdisAcquireSpinLock(&Adapter->Lock);
				Adapter->mediaBusy=FALSE;
				NdisReleaseSpinLock(&Adapter->Lock);
			}
		}
		else{
				MK7Reg_Read(Adapter, R_CFG3, &mk7reg);
				if(((mk7reg & 0x1000) != 0)|| (Adapter->nowReceiving==TRUE)) {
					NdisAcquireSpinLock(&Adapter->Lock);
					Adapter->mediaBusy = TRUE;
					NdisReleaseSpinLock(&Adapter->Lock);
				}
				else {
					NdisAcquireSpinLock(&Adapter->Lock);
					Adapter->mediaBusy=FALSE;
					NdisReleaseSpinLock(&Adapter->Lock);
				}
		}
		GenericUlong = (UINT)Adapter->mediaBusy;
	    break;


	case OID_GEN_CURRENT_LOOKAHEAD:
	case OID_GEN_MAXIMUM_LOOKAHEAD:
	    GenericUlong = MAX_I_DATA_SIZE;
	    break;

    case OID_GEN_MAXIMUM_TOTAL_SIZE:		// Largest pkt protocol sends to miniport
    case OID_GEN_TRANSMIT_BLOCK_SIZE:
    case OID_GEN_RECEIVE_BLOCK_SIZE:
	case OID_GEN_MAXIMUM_FRAME_SIZE:
        // Normally there's some difference in these values, based on the
        // MAC header, but IrDA doesn't have one.
	    GenericUlong = MAX_I_DATA_SIZE;
	    break;

	case OID_GEN_RECEIVE_BUFFER_SPACE:
	case OID_GEN_TRANSMIT_BUFFER_SPACE:
	    GenericUlong = (ULONG) (MK7_MAXIMUM_PACKET_SIZE * MAX_TX_PACKETS);
	    break;

	case OID_GEN_MAC_OPTIONS:
	    GenericUlong = NDIS_MAC_OPTION_COPY_LOOKAHEAD_DATA |
			   NDIS_MAC_OPTION_TRANSFERS_NOT_PEND;
	    break;

	case OID_GEN_MAXIMUM_SEND_PACKETS:
	    GenericUlong = MAX_ARRAY_SEND_PACKETS;
	    break;

	case OID_IRDA_TURNAROUND_TIME:
	    // Indicate the amount of time that the transceiver needs
	    // to recuperate after a send.
	    GenericUlong =
		      (ULONG)Adapter->turnAroundTime_usec;
	    break;

	case OID_IRDA_EXTRA_RCV_BOFS:
	    // Pass back the number of _extra_ BOFs to be prepended
	    // to packets sent to this unit at 115.2 baud, the
	    // maximum Slow IR speed.  This will be scaled for other
	    // speed according to the table in the
	    // Infrared Extensions to NDIS' spec.
	    GenericUlong = (ULONG)Adapter->extraBOFsRequired;
	    break;

	case OID_GEN_CURRENT_PACKET_FILTER:
	    GenericUlong = NDIS_PACKET_TYPE_PROMISCUOUS;
	    break;

	case OID_IRDA_MAX_RECEIVE_WINDOW_SIZE:
	    GenericUlong = MAX_RX_PACKETS;
	    //GenericUlong = 1;
	    break;

	case OID_GEN_VENDOR_DESCRIPTION:
	    SourceBuffer = (PVOID)"MKNet Very Highspeed IR";
	    SourceLength = 24;
	    break;

    case OID_GEN_VENDOR_DRIVER_VERSION:
        // This value is used to know whether to update driver.
        GenericUlong = (MK7_MAJOR_VERSION << 16) +
                       (MK7_MINOR_VERSION << 8) +
                       MK7_LETTER_VERSION;
        break;

	case OID_GEN_DRIVER_VERSION:
        GenericUlong = (MK7_NDIS_MAJOR_VERSION << 8) + MK7_NDIS_MINOR_VERSION;
        SourceLength = 2;
	    break;

    case OID_IRDA_MAX_SEND_WINDOW_SIZE:	// 4.0.1
        GenericUlong = MAX_ARRAY_SEND_PACKETS;
        break;

	default:
	    result = NDIS_STATUS_NOT_SUPPORTED;
	    break;
    }

    if (result == NDIS_STATUS_SUCCESS) {
	if (SourceLength > InformationBufferLength) {
	    *BytesNeeded = SourceLength;
	    result = NDIS_STATUS_INVALID_LENGTH;
	}
	else {
	    *BytesNeeded = 0;
	    *BytesWritten = SourceLength;
	    NdisMoveMemory(InformationBuffer, SourceBuffer, SourceLength);
	}
    }

    return result;

}



//----------------------------------------------------------------------
//  Function:	    MKMiniportSetInformation
//
//  Description:
//  Allow other layers of the network software (e.g., a transport
//  driver) to control the miniport driver by changing information that
//  the miniport driver maintains in its OIDs, such as the packet
//  or multicast addresses.
//----------------------------------------------------------------------
NDIS_STATUS MKMiniportSetInformation (
    IN NDIS_HANDLE MiniportAdapterContext,
    IN NDIS_OID Oid,
    IN PVOID InformationBuffer,
    IN ULONG InformationBufferLength,
    OUT PULONG BytesRead,
    OUT PULONG BytesNeeded)
{
    NDIS_STATUS result = NDIS_STATUS_SUCCESS;
    PMK7_ADAPTER Adapter = PMK7_ADAPTER_FROM_CONTEXT_HANDLE(MiniportAdapterContext);
    UINT i,speedSupported;
    NDIS_DMA_DESCRIPTION DMAChannelDcr;
    CHAR *pnpid;
    UCHAR IOResult;
//     CMCONFIG_A *hwInfo = (CMCONFIG_A *)InformationBuffer;

    if (InformationBufferLength >= sizeof(UINT)){

	UINT info = *(UINT *)InformationBuffer;
	*BytesRead = sizeof(UINT);
	*BytesNeeded = 0;

	switch (Oid) {
	    case OID_IRDA_LINK_SPEED:
		result = NDIS_STATUS_INVALID_DATA;

		// Find the appropriate speed and set it
		speedSupported = NUM_BAUDRATES;
		for (i = 0; i < speedSupported; i++) {
		    if (supportedBaudRateTable[i].bitsPerSec == info) {
				Adapter->linkSpeedInfo = &supportedBaudRateTable[i];
				result = NDIS_STATUS_SUCCESS;
				break;
		    }
		}
		if (result == NDIS_STATUS_SUCCESS) {
		    if (!SetSpeed(Adapter)){
				result = NDIS_STATUS_FAILURE;
		    }
		}
		else {
		    *BytesRead = 0;
		    *BytesNeeded = 0;
		}
		break;


	    case OID_IRDA_MEDIA_BUSY:

		//  The protocol can use this OID to reset the busy field
		//  in order to check it later for intervening activity.
		//
		Adapter->mediaBusy = (BOOLEAN)info;
		result = NDIS_STATUS_SUCCESS;
		break;

	    case OID_GEN_CURRENT_PACKET_FILTER:
		result = NDIS_STATUS_SUCCESS;
		break;


        case OID_GEN_CURRENT_LOOKAHEAD:
        result = (info<=MAX_I_DATA_SIZE) ? NDIS_STATUS_SUCCESS : NDIS_STATUS_INVALID_LENGTH;
        break;

	    //	 We don't support these
	    //
	    case OID_IRDA_RATE_SNIFF:
	    case OID_IRDA_UNICAST_LIST:

	     // These are query-only parameters.
	     //
	    case OID_IRDA_SUPPORTED_SPEEDS:
	    case OID_IRDA_MAX_UNICAST_LIST_SIZE:
	    case OID_IRDA_TURNAROUND_TIME:

	    default:
		*BytesRead = 0;
		*BytesNeeded = 0;
		result = NDIS_STATUS_NOT_SUPPORTED;
		break;
	}
    }
    else {
	*BytesRead = 0;
	*BytesNeeded = sizeof(UINT);
	result = NDIS_STATUS_INVALID_LENGTH;
    }

    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\net\irda\sigmatel\inf\makefile.inc ===
!IFNDEF LANGUAGE
LANGUAGE=usa
!ENDIF

_LNG=$(LANGUAGE)
_INX=.
STAMP=stampinf -f $@ -d 01/23/2001 -v 1.14.0.0

$(O)\irstusb.INF: $(_INX)\irstusb.inx $(_LNG)\irstusb.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $@
    $(STAMP)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\net\irda\nscirda\makefile.inc ===
_LNG=$(LANGUAGE)
_INX=.

$(O)\irnsc.inf: $(_INX)\irnsc.inx $(_LNG)\irnsc.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\net\irda\mknet\sys\winpci.c ===
/*****************************************************************************
 **																			**
 **	COPYRIGHT (C) 2000, 2001 MKNET CORPORATION								**
 **	DEVELOPED FOR THE MK7100-BASED VFIR PCI CONTROLLER.						**
 **																			**
 *****************************************************************************/

/**********************************************************************

Module Name:
	WINPCI.C

Routines:
	FindAndSetupPciDevice

Comments:
	Windows-NDIS PCI.

**********************************************************************/

#include	"precomp.h"
#pragma		hdrstop



//-----------------------------------------------------------------------------
// Procedure:   [FindAndSetupPciDevice]
//
// Description: This routine finds an adapter for the driver to load on
//              The critical piece to understanding this routine is that
//              the System will not let us read any information from PCI
//              space from any slot but the one that the System thinks
//              we should be using. The configuration manager rules this
//              land... The Slot number used by this routine is just a
//              placeholder, it could be zero even.
//
//				This code has enough flexibility to support multiple
//				PCI adapters. For now we only do one.
//
// Arguments:
//      Adapter - ptr to Adapter object instance
//      VendorID - Vendor ID of the adapter.
//      DeviceID - Device ID of the adapter.
//      PciCardsFound - A structure that contains an array of the IO addresses,
//                   IRQ, and node addresses of each PCI card that we find.
//
//    NOTE: due to NT 5's Plug and Play configuration manager
//          this routine will never return more than one device.
//
// Returns:
//      USHORT - Number of MK7 based PCI adapters found in the scanned bus
//-----------------------------------------------------------------------------
USHORT FindAndSetupPciDevice(IN PMK7_ADAPTER	Adapter, 
						NDIS_HANDLE WrapperConfigurationContext,
						IN USHORT		VendorID,
                    	IN USHORT		DeviceID,
                    	OUT PPCI_CARDS_FOUND_STRUC pPciCardsFound )
{
	NDIS_STATUS stat;
    ULONG		Device_Vendor_Id = 0;
    USHORT      Slot			= 0;

    /*
     *  We should only need 2 adapter resources (2 IO and 1 interrupt),
     *  but I've seen devices get extra resources.
     *  So give the NdisMQueryAdapterResources call room for 10 resources.
     */
    #define RESOURCE_LIST_BUF_SIZE (sizeof(NDIS_RESOURCE_LIST) + (10*sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR)))
    UCHAR buf[RESOURCE_LIST_BUF_SIZE];
    PNDIS_RESOURCE_LIST resList = (PNDIS_RESOURCE_LIST)buf;
    UINT bufSize = RESOURCE_LIST_BUF_SIZE;


	//****************************************
    // Verify the device is ours.
	//****************************************
    NdisReadPciSlotInformation(
        Adapter->MK7AdapterHandle,
        Slot,
        PCI_VENDOR_ID_REGISTER,
        (PVOID) &Device_Vendor_Id,
        sizeof (ULONG));

    if ( (((USHORT) Device_Vendor_Id) != VendorID) ||
         (((USHORT) (Device_Vendor_Id >> 16)) != DeviceID) ) {
	    pPciCardsFound->NumFound = 0;
		return (0);
	}


	//****************************************
    // Controller revision id
	//****************************************
	NdisReadPciSlotInformation(
		Adapter->MK7AdapterHandle,
		Slot,
		PCI_REV_ID_REGISTER,
		&pPciCardsFound->PciSlotInfo[0].ChipRevision,
		sizeof(pPciCardsFound->PciSlotInfo[0].ChipRevision));

	
	//****************************************
    // SubDevice and SubVendor ID
	// (We may want this in the future.)
	//****************************************
//        NdisReadPciSlotInformation(
//            Adapter->MK7AdapterHandle,
//            Slot,
//            PCI_SUBVENDOR_ID_REGISTER,
//            &pPciCardsFound->PciSlotInfo[found].SubVendor_DeviceID,
//            0x4);
//

    pPciCardsFound->PciSlotInfo[0].SlotNumber = (USHORT) 0;
	

	NdisMQueryAdapterResources(&stat, WrapperConfigurationContext, resList, &bufSize);
    if (stat == NDIS_STATUS_SUCCESS) {
        PCM_PARTIAL_RESOURCE_DESCRIPTOR resDesc;
        BOOLEAN     haveIRQ = FALSE,
                    haveIOAddr = FALSE;
        UINT i;

        for (resDesc = resList->PartialDescriptors, i = 0;
             i < resList->Count;
             resDesc++, i++) {

            switch (resDesc->Type) {
                case CmResourceTypePort:
					if (!haveIOAddr) {
		                if (resDesc->Flags & CM_RESOURCE_PORT_IO) {
			                pPciCardsFound->PciSlotInfo[0].BaseIo =
				                resDesc->u.Port.Start.LowPart;
							haveIOAddr = TRUE;
						}
					}
					break;

                case CmResourceTypeInterrupt:
					if (!haveIRQ) {
		                pPciCardsFound->PciSlotInfo[0].Irq =
			                (UCHAR) (resDesc->u.Port.Start.LowPart);
						haveIRQ = TRUE;
					}
					break;

	            case CmResourceTypeMemory:
					break;
            }
        }
    }

    return(1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\net\irda\mknet\sys\winreg.c ===
/*****************************************************************************
 **																			**
 **	COPYRIGHT (C) 2000, 2001 MKNET CORPORATION								**
 **	DEVELOPED FOR THE MK7100-BASED VFIR PCI CONTROLLER.						**
 **																			**
 *****************************************************************************/

/**********************************************************************

Module Name:
	WINREG.C

Routines:
	ParseRegistryParameters
	ProcessRegistry

Comments:
	Parse Windows Registry.

*****************************************************************************/

#include	"precomp.h"
#pragma		hdrstop



//************************************************************
// MK7RegTabType
//
//      One instance of this structure will be used for every configuration
//      parameter that this driver supports.  The table contains all of the
//      relavent information about each parameter:  Name, whether or not it is
//      required, where it is located in the "Adapter" structure, the size of
//      the parameter in bytes, the default value for the parameter, and what
//      the minimum and maximum values are for the parameter.  In the debug
//      version of the driver, this table also contains a field for the ascii
//      name of the parameter.
//************************************************************
typedef struct _MK7RegTabType {
    NDIS_STRING RegVarName;             // variable name text
    char       *RegAscName;             // variable name text
    UINT        Mandantory;             // 1 -> manditory, 0 -> optional
#define			MK7OPTIONAL		0
#define			MK7MANDATORY	1
    UINT        FieldOffset;            // offset to MK7_ADAPTER field loaded
    UINT        FieldSize;              // size (in bytes) of the field
    UINT        Default;                // default value to use
    UINT        Min;                    // minimum value allowed
    UINT        Max;                    // maximum value allowed
} MK7RegTabType;



//************************************************************
// Registry Parameters Table
//
//      This table contains a list of all of the configuration parameters
//      that the driver supports.  The driver will attempt to find these
//      parameters in the registry and use the registry value for these
//      parameters.  If the parameter is not found in the registry, then the
//      default value is used. This is a way for us to set defaults for
//		certain parameters.
//
//************************************************************


MK7RegTabType MK7RegTab[ ] = {
//
//	REGISTRY NAME						TEXT NAME		MAN/OPT			OFFSET
//	SIZE								DEF VAL			MIN				MAX
//

//#if DBG
//	{NDIS_STRING_CONST("Debug"),		"Debug",		MK7OPTIONAL,	MK7_OFFSET(Debug),
//	 MK7_SIZE(Debug),					DBG_NORMAL,		0,          	0xffffffff},
//#endif

	{NDIS_STRING_CONST("MaxConnectRate"),	"MaxConnectRate",	MK7OPTIONAL,	MK7_OFFSET(MaxConnSpeed),
	 MK7_SIZE(MaxConnSpeed),			16000000,			9600,			16000000},

	{NDIS_STRING_CONST("MinTurnAroundTime"), "MinTurnAroundTime",	MK7OPTIONAL, MK7_OFFSET(turnAroundTime_usec),
	 MK7_SIZE(turnAroundTime_usec),		DEFAULT_TURNAROUND_usec,	0,		 DEFAULT_TURNAROUND_usec},

	//
	// All the ones from here down are not really necessary except for testing.
	//

	{NDIS_STRING_CONST("BusNumber"),	"BusNumber",	MK7OPTIONAL,	MK7_OFFSET(BusNumber),
	 MK7_SIZE(BusNumber),				0,				0,				16},

    {NDIS_STRING_CONST("SlotNumber"),	"SlotNumber",	MK7OPTIONAL,	MK7_OFFSET(MKSlot),
	 MK7_SIZE(MKSlot),					0,				0,				32},

#if DBG
	{NDIS_STRING_CONST("Loopback"),		"Loopback",		MK7OPTIONAL,	MK7_OFFSET(LB),
	 MK7_SIZE(LB),						0,				0,				2},
#endif

	{NDIS_STRING_CONST("RingSize"),		"RingSize",		MK7OPTIONAL,	MK7_OFFSET(RingSize),
	 MK7_SIZE(RingSize),				DEF_RING_SIZE,	MIN_RING_SIZE,	MAX_RING_SIZE},

	{NDIS_STRING_CONST("RXRingSize"),	"RXRingSize",	MK7OPTIONAL,	MK7_OFFSET(RegNumRcb),
	 MK7_SIZE(RegNumRcb),				DEF_RXRING_SIZE,MIN_RING_SIZE,	DEF_RXRING_SIZE},

	{NDIS_STRING_CONST("TXRingSize"),	"TXRingSize",	MK7OPTIONAL,	MK7_OFFSET(RegNumTcb),
	 MK7_SIZE(RegNumTcb),				DEF_TXRING_SIZE,MIN_RING_SIZE,	DEF_TXRING_SIZE},

	{NDIS_STRING_CONST("ExtraBOFs"),	"ExtraBOFs",	MK7OPTIONAL,	MK7_OFFSET(RegExtraBOFs),
	 MK7_SIZE(RegExtraBOFs),			DEF_EBOFS,		MIN_EBOFS,		MAX_EBOFS},

	{NDIS_STRING_CONST("Speed"),		"Speed",		MK7OPTIONAL,	MK7_OFFSET(RegSpeed),
	 MK7_SIZE(RegSpeed),				16000000,		4000000,		16000000},

    {NDIS_STRING_CONST("BusType"),		"BusType",		MK7OPTIONAL,	MK7_OFFSET(MKBusType),
	MK7_SIZE(MKBusType),				PCIBUS,			PCIBUS,			PCIBUS},

    {NDIS_STRING_CONST("IoSize"),		"IoSize",		MK7OPTIONAL,	MK7_OFFSET(MKBaseSize),
	MK7_SIZE(MKBaseSize),				MK7_IO_SIZE,	MK7_IO_SIZE,	MK7_IO_SIZE},

	{NDIS_STRING_CONST("Wireless"),		"Wireless",		MK7OPTIONAL,	MK7_OFFSET(Wireless),
	 MK7_SIZE(Wireless),				1,				0,				1},
};



#define NUM_REG_PARAM ( sizeof (MK7RegTab) / sizeof (MK7RegTabType) )


//-----------------------------------------------------------------------------
// Procedure:   ParseRegistryParameters
//
// Description: This routine will parse all of the parameters out of the
//		registry/PROTOCOL.INI, and store the values in the "Adapter"
//		Structure.  If the parameter is not present in the registry, then the
//		default value for the parameter will be placed into the "Adapter"
//		structure.  This routine also checks the validity of the parameter
//		value, and if the value is out of range, the driver will the min/max
//		value allowed.
//
// Arguments:
//      Adapter - ptr to Adapter object instance
//      ConfigHandle - NDIS Configuration Registery handle
//
// Returns:
//      NDIS_STATUS_SUCCESS - All mandatory parameters were parsed
//      NDIS_STATUS_FAILED - A mandatory parameter was not present
//-----------------------------------------------------------------------------

NDIS_STATUS
ParseRegistryParameters(IN PMK7_ADAPTER Adapter,
                        IN NDIS_HANDLE ConfigHandle)
{
    UINT                i;
    NDIS_STATUS         Status;
    MK7RegTabType      *RegTab;
    UINT                value;
    PUCHAR              fieldPtr;
    PNDIS_CONFIGURATION_PARAMETER ReturnedValue;
#if DBG
    char                ansiRegName[32];
	ULONG				paramval;
#endif


	//****************************************
    // Grovel through the registry parameters and aquire all of the values
    // stored therein.
	//****************************************
    for (i=0, RegTab=MK7RegTab;	i<NUM_REG_PARAM; i++, RegTab++) {

        fieldPtr = ((PUCHAR) Adapter) + RegTab->FieldOffset;

#if DBG
        strcpy(ansiRegName, RegTab->RegAscName);
#endif

		//****************************************
        // Get the configuration value for a specific parameter.  Under NT the
        // parameters are all read in as DWORDs.
		//****************************************
        NdisReadConfiguration(&Status,
            &ReturnedValue,
            ConfigHandle,
            &RegTab->RegVarName,
            NdisParameterInteger);


		//****************************************
		// Param in Reg:
        // Check that it's w/i the min-max range. If not set it to
		// default, else just set to that in the Reg.
		//
		// Param not in Reg:
		// If it's a mandatory param, error out.
		// If it's optional (non-mandatory), again use default.
		//****************************************
        if (Status == NDIS_STATUS_SUCCESS) {

#if DBG
			paramval = ReturnedValue->ParameterData.IntegerData;
#endif

            if (ReturnedValue->ParameterData.IntegerData < RegTab->Min ||
                ReturnedValue->ParameterData.IntegerData > RegTab->Max) {
                value = RegTab->Default;
            }
            else {
                value = ReturnedValue->ParameterData.IntegerData;
            }
        }
        else if (RegTab->Mandantory) {
            DBGSTR(("Could not find mandantory in registry\n"));
			DBGLOG("<= ParseRegistryParameters (ERROR out)", 0);
			return (NDIS_STATUS_FAILURE);
        }
        else {	// non-mandatory
            value = RegTab->Default;
        }

		//****************************************
        // Store the value in the adapter structure.
		//****************************************
        switch (RegTab->FieldSize) {
        case 1:
                *((PUCHAR) fieldPtr) = (UCHAR) value;
                break;

        case 2:
                *((PUSHORT) fieldPtr) = (USHORT) value;
                break;

        case 4:
                *((PULONG) fieldPtr) = (ULONG) value;
                break;

        default:
            DBGSTR(("Bogus field size %d\n", RegTab->FieldSize));
            break;
        }
    }

    return (NDIS_STATUS_SUCCESS);
}



//----------------------------------------------------------------------
// Procedure:	[ProcessRegistry]
//
// Description:	Do all the one time Registry stuff.
//
// Return:		NDIS_STATUS_SUCCESS
//				(!NDIS_STATUS_SUCCESS)

//----------------------------------------------------------------------
NDIS_STATUS	ProcessRegistry(PMK7_ADAPTER Adapter,
							NDIS_HANDLE WrapperConfigurationContext)
{
	NDIS_STATUS		Status;
	NDIS_HANDLE		ConfigHandle;
    PVOID			OverrideNetAddress;
    ULONG			i;


	NdisOpenConfiguration(&Status,
						&ConfigHandle,
						WrapperConfigurationContext);

	if (Status != NDIS_STATUS_SUCCESS) {
		return (NDIS_STATUS_FAILURE);
	}

	//****************************************
	// Parse all our configuration parameters. Error out if bad
	// status returned -- Required param not in Registry.
	//****************************************
	Status = ParseRegistryParameters(Adapter, ConfigHandle);
	if (Status != NDIS_STATUS_SUCCESS) {
		NdisCloseConfiguration(ConfigHandle);
		return (Status);
	  }

	NdisCloseConfiguration(ConfigHandle);

//	Adapter->NumRcb = Adapter->RegNumRcb;
//	Adapter->NumTcb = Adapter->RegNumTcb;
	Adapter->NumRcb = DEF_RXRING_SIZE;
	Adapter->NumTcb = DEF_TXRING_SIZE;
	Adapter->NumRpd = CalRpdSize(Adapter->NumRcb);
	Adapter->extraBOFsRequired = Adapter->RegExtraBOFs;

	return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\net\irda\mknet\sys\winpci.h ===
/*****************************************************************************
 **																			**
 **	COPYRIGHT (C) 2000, 2001 MKNET CORPORATION								**
 **	DEVELOPED FOR THE MK7100-BASED VFIR PCI CONTROLLER.						**
 **																			**
 *****************************************************************************/

/**********************************************************************

Module Name:
	WINPCI.H

Comments:
	PCI & Windows PCI defs.

**********************************************************************/

#ifndef _WINPCI_H
#define _WINPCI_H


//-------------------------------------------------------------------------
// PCI configuration hardware ports
//-------------------------------------------------------------------------
#define CF1_CONFIG_ADDR_REGISTER    0x0CF8
#define CF1_CONFIG_DATA_REGISTER    0x0CFC
#define CF2_SPACE_ENABLE_REGISTER   0x0CF8
#define CF2_FORWARD_REGISTER        0x0CFA
#define CF2_BASE_ADDRESS            0xC000



//-------------------------------------------------------------------------
// Configuration Space Header
//-------------------------------------------------------------------------
typedef struct _PCI_CONFIG_STRUC {
    USHORT  PciVendorId;        // PCI Vendor ID
    USHORT  PciDeviceId;        // PCI Device ID
    USHORT  PciCommand;
    USHORT  PciStatus;
    UCHAR   PciRevisionId;
    UCHAR   PciClassCode[3];
    UCHAR   PciCacheLineSize;
    UCHAR   PciLatencyTimer;
    UCHAR   PciHeaderType;
    UCHAR   PciBIST;
    ULONG   PciBaseReg0;
    ULONG   PciBaseReg1;
    ULONG   PciBaseReg2;
    ULONG   PciBaseReg3;
    ULONG   PciBaseReg4;
    ULONG   PciBaseReg5;
    ULONG   PciReserved0;
    ULONG   PciReserved1;
    ULONG   PciExpROMAddress;
    ULONG   PciReserved2;
    ULONG   PciReserved3;
    UCHAR   PciInterruptLine;
    UCHAR   PciInterruptPin;
    UCHAR   PciMinGnt;
    UCHAR   PciMaxLat;
} PCI_CONFIG_STRUC, *PPCI_CONFIG_STRUC;


//----------------------------------------------------------------------
// PCI Config Space
//----------------------------------------------------------------------
#define PCI_VENDOR_ID_REGISTER      0x00    // PCI Vendor ID Register
#define PCI_DEVICE_ID_REGISTER      0x02    // PCI Device ID Register
#define PCI_CONFIG_ID_REGISTER      0x00    // PCI Configuration ID Register
#define PCI_COMMAND_REGISTER        0x04    // PCI Command Register
#define PCI_STATUS_REGISTER         0x06    // PCI Status Register
#define PCI_REV_ID_REGISTER         0x08    // PCI Revision ID Register
#define PCI_CLASS_CODE_REGISTER     0x09    // PCI Class Code Register
#define PCI_CACHE_LINE_REGISTER     0x0C    // PCI Cache Line Register
#define PCI_LATENCY_TIMER           0x0D    // PCI Latency Timer Register
#define PCI_HEADER_TYPE             0x0E    // PCI Header Type Register
#define PCI_BIST_REGISTER           0x0F    // PCI Built-In SelfTest Register
#define PCI_BAR_0_REGISTER          0x10    // PCI Base Address Register 0
#define PCI_BAR_1_REGISTER          0x14    // PCI Base Address Register 1
#define PCI_BAR_2_REGISTER          0x18    // PCI Base Address Register 2
#define PCI_BAR_3_REGISTER          0x1C    // PCI Base Address Register 3
#define PCI_BAR_4_REGISTER          0x20    // PCI Base Address Register 4
#define PCI_BAR_5_REGISTER          0x24    // PCI Base Address Register 5
#define PCI_SUBVENDOR_ID_REGISTER   0x2C    // PCI SubVendor ID Register
#define PCI_SUBDEVICE_ID_REGISTER   0x2E    // PCI SubDevice ID Register
#define PCI_EXPANSION_ROM           0x30    // PCI Expansion ROM Base Register
#define PCI_INTERRUPT_LINE          0x3C    // PCI Interrupt Line Register
#define PCI_INTERRUPT_PIN           0x3D    // PCI Interrupt Pin Register
#define PCI_MIN_GNT_REGISTER        0x3E    // PCI Min-Gnt Register
#define PCI_MAX_LAT_REGISTER        0x3F    // PCI Max_Lat Register
#define PCI_NODE_ADDR_REGISTER      0x40    // PCI Node Address Register



//-------------------------------------------------------------------------
// PCI Class Code Definitions
// Configuration Space Header
//-------------------------------------------------------------------------
#define PCI_BASE_CLASS      0x02    // Base Class - Network Controller
#define PCI_SUB_CLASS       0x00    // Sub Class - Ethernet Controller
#define PCI_PROG_INTERFACE  0x00    // Prog I/F - Ethernet COntroller

//-------------------------------------------------------------------------
// The following is copied from EQUATES.H
// Bit Mask definitions
//-------------------------------------------------------------------------
#define BIT_0		0x0001
#define BIT_1		0x0002
#define BIT_2		0x0004
#define BIT_3		0x0008
#define BIT_4		0x0010
#define BIT_5		0x0020
#define BIT_6		0x0040
#define BIT_7		0x0080
#define BIT_8		0x0100
#define BIT_9		0x0200
#define BIT_10		0x0400
#define BIT_11		0x0800
#define BIT_12		0x1000
#define BIT_13		0x2000
#define BIT_14		0x4000
#define BIT_15		0x8000
#define BIT_24		0x01000000
#define BIT_28		0x10000000

//-------------------------------------------------------------------------
// PCI Command Register Bit Definitions
// Configuration Space Header
//-------------------------------------------------------------------------
#define CMD_IO_SPACE            BIT_0
#define CMD_MEMORY_SPACE        BIT_1
#define CMD_BUS_MASTER          BIT_2
#define CMD_SPECIAL_CYCLES      BIT_3
#define CMD_MEM_WRT_INVALIDATE  BIT_4
#define CMD_VGA_PALLETTE_SNOOP  BIT_5
#define CMD_PARITY_RESPONSE     BIT_6
#define CMD_WAIT_CYCLE_CONTROL  BIT_7
#define CMD_SERR_ENABLE         BIT_8
#define CMD_BACK_TO_BACK        BIT_9

//-------------------------------------------------------------------------
// PCI Status Register Bit Definitions
// Configuration Space Header
//-------------------------------------------------------------------------
#define STAT_BACK_TO_BACK           BIT_7
#define STAT_DATA_PARITY            BIT_8
#define STAT_DEVSEL_TIMING          BIT_9 OR BIT_10
#define STAT_SIGNAL_TARGET_ABORT    BIT_11
#define STAT_RCV_TARGET_ABORT       BIT_12
#define STAT_RCV_MASTER_ABORT       BIT_13
#define STAT_SIGNAL_MASTER_ABORT    BIT_14
#define STAT_DETECT_PARITY_ERROR    BIT_15

//-------------------------------------------------------------------------
// PCI Base Address Register For Memory (BARM) Bit Definitions
// Configuration Space Header
//-------------------------------------------------------------------------
#define BARM_LOCATE_BELOW_1_MEG     BIT_1
#define BARM_LOCATE_IN_64_SPACE     BIT_2
#define BARM_PREFETCHABLE           BIT_3

//-------------------------------------------------------------------------
// PCI Base Address Register For I/O (BARIO) Bit Definitions
// Configuration Space Header
//-------------------------------------------------------------------------
#define BARIO_SPACE_INDICATOR       BIT_0

//-------------------------------------------------------------------------
// PCI BIOS Definitions
// Refer To The PCI BIOS Specification
//-------------------------------------------------------------------------
//- Function Code List
#define PCI_FUNCTION_ID         0xB1    // AH Register
#define PCI_BIOS_PRESENT        0x01    // AL Register
#define FIND_PCI_DEVICE         0x02    // AL Register
#define FIND_PCI_CLASS_CODE     0x03    // AL Register
#define GENERATE_SPECIAL_CYCLE  0x06    // AL Register
#define READ_CONFIG_BYTE        0x08    // AL Register
#define READ_CONFIG_WORD        0x09    // AL Register
#define READ_CONFIG_DWORD       0x0A    // AL Register
#define WRITE_CONFIG_BYTE       0x0B    // AL Register
#define WRITE_CONFIG_WORD       0x0C    // AL Register
#define WRITE_CONFIG_DWORD      0x0D    // AL Register

//- Function Return Code List
#define SUCCESSFUL              0x00
#define FUNC_NOT_SUPPORTED      0x81
#define BAD_VENDOR_ID           0x83
#define DEVICE_NOT_FOUND        0x86
#define BAD_REGISTER_NUMBER     0x87

//- PCI BIOS Calls
#define PCI_BIOS_INTERRUPT      0x1A        // PCI BIOS Int 1Ah Function Call
#define PCI_PRESENT_CODE        0x20494350  // Hex Equivalent Of 'PCI '

#define PCI_SERVICE_IDENTIFIER  0x49435024  // ASCII Codes for 'ICP$'

//- Device and Vendor IDs
#define MK7_PCI_DEVICE_ID       0x7100
#define MKNET_PCI_VENDOR_ID     0x1641
// For debugging
#define DBG_DEVICE_ID           0x7100
#define DBG_VENDOR_ID           0x2828

#endif      // _WINPCI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\net\irda\sigmatel\sys\convert.c ===
/**************************************************************************************************************************
 *  CONVERT.C SigmaTel STIR4200 format conversion (NDIS->IR, IR->NDIS) module
 **************************************************************************************************************************
 *  (C) Unpublished Copyright of Sigmatel, Inc. All Rights Reserved.
 *
 *
 *		Created: 04/06/2000 
 *			Version 0.9
 *		Edited: 05/12/2000 
 *			Version 0.94
 *	
 *
 **************************************************************************************************************************/

#define DOBREAKS    // enable debug breaks

#include <ndis.h>
#include <ntddndis.h>  // defines OID's

#include <usbdi.h>
#include <usbdlib.h>

#include "debug.h"
#include "ircommon.h"
#include "irndis.h"
#include "stir4200.h"

//
// Tables for CRC calculations
//
static const USHORT fcsTable16[256] =
{
    0x0000, 0x1189, 0x2312, 0x329b, 0x4624, 0x57ad, 0x6536, 0x74bf,
    0x8c48, 0x9dc1, 0xaf5a, 0xbed3, 0xca6c, 0xdbe5, 0xe97e, 0xf8f7,
    0x1081, 0x0108, 0x3393, 0x221a, 0x56a5, 0x472c, 0x75b7, 0x643e,
    0x9cc9, 0x8d40, 0xbfdb, 0xae52, 0xdaed, 0xcb64, 0xf9ff, 0xe876,
    0x2102, 0x308b, 0x0210, 0x1399, 0x6726, 0x76af, 0x4434, 0x55bd,
    0xad4a, 0xbcc3, 0x8e58, 0x9fd1, 0xeb6e, 0xfae7, 0xc87c, 0xd9f5,
    0x3183, 0x200a, 0x1291, 0x0318, 0x77a7, 0x662e, 0x54b5, 0x453c,
    0xbdcb, 0xac42, 0x9ed9, 0x8f50, 0xfbef, 0xea66, 0xd8fd, 0xc974,
    0x4204, 0x538d, 0x6116, 0x709f, 0x0420, 0x15a9, 0x2732, 0x36bb,
    0xce4c, 0xdfc5, 0xed5e, 0xfcd7, 0x8868, 0x99e1, 0xab7a, 0xbaf3,
    0x5285, 0x430c, 0x7197, 0x601e, 0x14a1, 0x0528, 0x37b3, 0x263a,
    0xdecd, 0xcf44, 0xfddf, 0xec56, 0x98e9, 0x8960, 0xbbfb, 0xaa72,
    0x6306, 0x728f, 0x4014, 0x519d, 0x2522, 0x34ab, 0x0630, 0x17b9,
    0xef4e, 0xfec7, 0xcc5c, 0xddd5, 0xa96a, 0xb8e3, 0x8a78, 0x9bf1,
    0x7387, 0x620e, 0x5095, 0x411c, 0x35a3, 0x242a, 0x16b1, 0x0738,
    0xffcf, 0xee46, 0xdcdd, 0xcd54, 0xb9eb, 0xa862, 0x9af9, 0x8b70,
    0x8408, 0x9581, 0xa71a, 0xb693, 0xc22c, 0xd3a5, 0xe13e, 0xf0b7,
    0x0840, 0x19c9, 0x2b52, 0x3adb, 0x4e64, 0x5fed, 0x6d76, 0x7cff,
    0x9489, 0x8500, 0xb79b, 0xa612, 0xd2ad, 0xc324, 0xf1bf, 0xe036,
    0x18c1, 0x0948, 0x3bd3, 0x2a5a, 0x5ee5, 0x4f6c, 0x7df7, 0x6c7e,
    0xa50a, 0xb483, 0x8618, 0x9791, 0xe32e, 0xf2a7, 0xc03c, 0xd1b5,
    0x2942, 0x38cb, 0x0a50, 0x1bd9, 0x6f66, 0x7eef, 0x4c74, 0x5dfd,
    0xb58b, 0xa402, 0x9699, 0x8710, 0xf3af, 0xe226, 0xd0bd, 0xc134,
    0x39c3, 0x284a, 0x1ad1, 0x0b58, 0x7fe7, 0x6e6e, 0x5cf5, 0x4d7c,
    0xc60c, 0xd785, 0xe51e, 0xf497, 0x8028, 0x91a1, 0xa33a, 0xb2b3,
    0x4a44, 0x5bcd, 0x6956, 0x78df, 0x0c60, 0x1de9, 0x2f72, 0x3efb,
    0xd68d, 0xc704, 0xf59f, 0xe416, 0x90a9, 0x8120, 0xb3bb, 0xa232,
    0x5ac5, 0x4b4c, 0x79d7, 0x685e, 0x1ce1, 0x0d68, 0x3ff3, 0x2e7a,
    0xe70e, 0xf687, 0xc41c, 0xd595, 0xa12a, 0xb0a3, 0x8238, 0x93b1,
    0x6b46, 0x7acf, 0x4854, 0x59dd, 0x2d62, 0x3ceb, 0x0e70, 0x1ff9,
    0xf78f, 0xe606, 0xd49d, 0xc514, 0xb1ab, 0xa022, 0x92b9, 0x8330,
    0x7bc7, 0x6a4e, 0x58d5, 0x495c, 0x3de3, 0x2c6a, 0x1ef1, 0x0f78
};

static const ULONG fcsTable32[256] =
{
    0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA, 0x076DC419, 0x706AF48F, 0xE963A535, 0x9E6495A3,
    0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988, 0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91,
    0x1DB71064, 0x6AB020F2, 0xF3B97148, 0x84BE41DE, 0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7,
    0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC, 0x14015C4F, 0x63066CD9, 0xFA0F3D63, 0x8D080DF5,
    0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172, 0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B,
    0x35B5A8FA, 0x42B2986C, 0xDBBBC9D6, 0xACBCF940, 0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59,
    0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116, 0x21B4F4B5, 0x56B3C423, 0xCFBA9599, 0xB8BDA50F,
    0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924, 0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D,
    0x76DC4190, 0x01DB7106, 0x98D220BC, 0xEFD5102A, 0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433,
    0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818, 0x7F6A0DBB, 0x086D3D2D, 0x91646C97, 0xE6635C01,
    0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E, 0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457,
    0x65B0D9C6, 0x12B7E950, 0x8BBEB8EA, 0xFCB9887C, 0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65,
    0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2, 0x4ADFA541, 0x3DD895D7, 0xA4D1C46D, 0xD3D6F4FB,
    0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0, 0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9,
    0x5005713C, 0x270241AA, 0xBE0B1010, 0xC90C2086, 0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F,
    0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4, 0x59B33D17, 0x2EB40D81, 0xB7BD5C3B, 0xC0BA6CAD,
    0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A, 0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683,
    0xE3630B12, 0x94643B84, 0x0D6D6A3E, 0x7A6A5AA8, 0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1,
    0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE, 0xF762575D, 0x806567CB, 0x196C3671, 0x6E6B06E7,
    0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC, 0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5,
    0xD6D6A3E8, 0xA1D1937E, 0x38D8C2C4, 0x4FDFF252, 0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B,
    0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60, 0xDF60EFC3, 0xA867DF55, 0x316E8EEF, 0x4669BE79,
    0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236, 0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F,
    0xC5BA3BBE, 0xB2BD0B28, 0x2BB45A92, 0x5CB36A04, 0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D,
    0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A, 0x9C0906A9, 0xEB0E363F, 0x72076785, 0x05005713,
    0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38, 0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21,
    0x86D3D2D4, 0xF1D4E242, 0x68DDB3F8, 0x1FDA836E, 0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777,
    0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C, 0x8F659EFF, 0xF862AE69, 0x616BFFD3, 0x166CCF45,
    0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2, 0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB,
    0xAED16A4A, 0xD9D65ADC, 0x40DF0B66, 0x37D83BF0, 0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9,
    0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6, 0xBAD03605, 0xCDD70693, 0x54DE5729, 0x23D967BF,
    0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94, 0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D
};


/*****************************************************************************
*
*  Function:	NdisToFirPacket
*
*  Synopsis:	convert an NDIS packet to a Fir IR packet
*
*				Write the IR packet into the provided buffer and report
*				its actual size.
*
*  Arguments:	pIrDev - pointer to device instance
*				pPacket - NDIS packet to convert
*				pIrPacketBuf - output buffer
*				IrPacketBufLen - output buffer size
*				pContigPacketBuf - temporary staging buffer
*				pIrPacketLen - lenght of the converted data
*
*				MS Security bug #533243
*				Note: size of pContigPacketBuf staging buffer is:
*				MAX_TOTAL_SIZE_WITH_ALL_HEADERS + FAST_IR_FCS_SIZE
*
*  Returns:		TRUE  - on success
*				FALSE - on failure
*
*
*****************************************************************************/
BOOLEAN         
NdisToFirPacket(
		IN PIR_DEVICE pIrDev,
		IN PNDIS_PACKET pPacket,
		OUT PUCHAR pIrPacketBuf,
		ULONG IrPacketBufLen,
		IN PUCHAR pContigPacketBuf,
		OUT PULONG pIrPacketLen
	)
{
    PNDIS_BUFFER        pNdisBuf;
    ULONG               ndisPacketBytes = 0;
    ULONG               I_fieldBytes, ndisPacketLen;
    FAST_IR_FCS_TYPE    fcs;
    FAST_IR_FCS_TYPE    UNALIGNED *pfcs;
    ULONG               i, TotalBytes, EscSize;
	PSTIR4200_FRAME_HEADER  pFrameHeader = (PSTIR4200_FRAME_HEADER)pIrPacketBuf;
	PUCHAR					pIrPacketBufFrame = pIrPacketBuf + sizeof(STIR4200_FRAME_HEADER);

    /***********************************************/
    /*   Get  the  packet's entire length and its  */
    /*   first NDIS buffer                         */
    /***********************************************/
    NdisQueryPacket( pPacket, NULL, NULL, &pNdisBuf, (UINT*)&ndisPacketLen );

    /***********************************************/
    /*   Make  sure that the packet is big enough  */
    /*   to be legal. It consists of an A, C, and  */
    /*   variable-length I field.                  */
    /***********************************************/
    if( ndisPacketLen < IRDA_A_C_TOTAL_SIZE )
    {
		DEBUGMSG(DBG_ERR, (" NdisToFirPacket(): Packet is too small\n"));
        return FALSE;
    }
    else
    {
        I_fieldBytes = ndisPacketLen - IRDA_A_C_TOTAL_SIZE;
    }

    /***********************************************/
    /*   Make  sure  that  we won't overwrite our  */
    /*   contiguous buffer                         */
    /***********************************************/
    if( (ndisPacketLen > MAX_TOTAL_SIZE_WITH_ALL_HEADERS) ||
        (MAX_POSSIBLE_IR_PACKET_SIZE_FOR_DATA(I_fieldBytes) > IrPacketBufLen) )
    {
        /***********************************************/
        /*   The packet is too large. Tell the caller  */
        /*   to retry with a packet size large enough  */
        /*   to get past this stage next time.         */
        /***********************************************/
		DEBUGMSG(DBG_ERR, (" NdisToFirPacket(): Packet is too big\n"));
        return FALSE;
    }

    /***********************************************/
    /*   Read  the  NDIS packet into a contiguous  */
    /*   buffer.  We have to do this in two steps  */
    /*   so  that  we  can compute the FCS BEFORE  */
    /*   applying escape-byte transparency.        */
    /***********************************************/
    while( pNdisBuf )
    {
        UCHAR *bufData;
        ULONG bufLen;

#if defined(LEGACY_NDIS5)
        NdisQueryBuffer( pNdisBuf, (PVOID*)&bufData, (UINT*)&bufLen );
#else
        NdisQueryBufferSafe( pNdisBuf, (PVOID*)&bufData, (UINT*)&bufLen, NormalPagePriority );
        if (bufData == NULL) 
		{
            DEBUGMSG(DBG_ERR, (" NdisToFirPacket(): Could not query buffer\n"));
            return FALSE;
        }
#endif
        if( (ndisPacketBytes + bufLen) > ndisPacketLen )
        {
			//
            // Packet was corrupt -- it misreported its size.
            //
			DEBUGMSG(DBG_ERR, (" NdisToFirPacket(): Packet is corrupt\n"));
            return FALSE;
        }
        NdisMoveMemory( (PVOID)(pContigPacketBuf + ndisPacketBytes), (PVOID)bufData, bufLen );
        ndisPacketBytes += bufLen;
        NdisGetNextBuffer( pNdisBuf, &pNdisBuf );
    }

    /***********************************************/
    /*   Do sanity check on length of packet...    */
    /***********************************************/
    if( ndisPacketBytes != ndisPacketLen )
    {
		//
		// Packet was corrupt -- it misreported its size.
        //
		DEBUGMSG(DBG_ERR, (" NdisToFirPacket(): Packet is corrupt\n"));
		return FALSE;
    }

    /***********************************************/
    /*   Compute  the  FCS  on  the packet BEFORE  */
    /*   applying  transparency  fixups.  The FCS  */
    /*   also   must   be   sent  using  ESC-char  */
    /*   transparency.                             */
    /***********************************************/
    fcs = ComputeFCS32( pContigPacketBuf, ndisPacketBytes );

    /***********************************************/
    /*   Add FCS to packet...                      */
    /***********************************************/
    pfcs = (FAST_IR_FCS_TYPE *)&pContigPacketBuf[ndisPacketBytes];
    *pfcs = fcs;

    /***********************************************/
    /*   Build the STIr4200 FIR frame.             */
    /***********************************************/

    /***********************************************/
    /*   Add preamble...                           */
    /***********************************************/
    memset( pIrPacketBufFrame, STIR4200_FIR_PREAMBLE, STIR4200_FIR_PREAMBLE_SIZ );

    /***********************************************/
    /*   Add BOF's...                              */
    /***********************************************/
    memset( &pIrPacketBufFrame[STIR4200_FIR_PREAMBLE_SIZ], STIR4200_FIR_BOF, STIR4200_FIR_BOF_SIZ );
    
    /***********************************************/
    /*   Escape A, C, I & CRC fields of packet...  */
    /***********************************************/
    EscSize = ndisPacketBytes + FAST_IR_FCS_SIZE;
    for( i = 0, TotalBytes = STIR4200_FIR_PREAMBLE_SIZ + STIR4200_FIR_BOF_SIZ; i < EscSize; i++ )
    {
        UCHAR   c;

        switch( c = pContigPacketBuf[i] )
        {
			case STIR4200_FIR_ESC_CHAR:
				pIrPacketBufFrame[TotalBytes++] = STIR4200_FIR_ESC_CHAR;
				pIrPacketBufFrame[TotalBytes++] = STIR4200_FIR_ESC_DATA_7D;
				break;
			case STIR4200_FIR_BOF:                  // BOF = EOF too
				pIrPacketBufFrame[TotalBytes++] = STIR4200_FIR_ESC_CHAR;
				pIrPacketBufFrame[TotalBytes++] = STIR4200_FIR_ESC_DATA_7E;
				break;
			case STIR4200_FIR_PREAMBLE:
				pIrPacketBufFrame[TotalBytes++] = STIR4200_FIR_ESC_CHAR;
				pIrPacketBufFrame[TotalBytes++] = STIR4200_FIR_ESC_DATA_7F;
				break;
			default: 
				pIrPacketBufFrame[TotalBytes++] = c;
        }
    }

    /***********************************************/
    /*   Add EOF's...                              */
    /***********************************************/
    memset( &pIrPacketBufFrame[TotalBytes], STIR4200_FIR_EOF, STIR4200_FIR_EOF_SIZ );

  	/***********************************************/
    /*   Add in STIr4200 header...                 */
    /***********************************************/
    TotalBytes += STIR4200_FIR_EOF_SIZ;
    pFrameHeader->id1     = STIR4200_HEADERID_BYTE1;
    pFrameHeader->id2     = STIR4200_HEADERID_BYTE2;
    pFrameHeader->sizlsb  = LOBYTE(TotalBytes);
    pFrameHeader->sizmsb  = HIBYTE(TotalBytes);

	/***********************************************/
    /*   Calc size packet w/escaped data...        */
    /***********************************************/
    *pIrPacketLen = TotalBytes + sizeof(STIR4200_FRAME_HEADER);

    return TRUE;
}


/*****************************************************************************
*
*  Function:	NdisToMirPacket
*
*  Synopsis:	convert an NDIS packet to a Mir IR packet
*
*				Write the IR packet into the provided buffer and report
*				its actual size.
*
*  Arguments:	pIrDev - pointer to device instance
*				pPacket - NDIS packet to convert
*				pIrPacketBuf - output buffer
*				IrPacketBufLen - output buffer size
*				pContigPacketBuf - temporary staging buffer
*				pIrPacketLen - lenght of the converted data
*
*				MS Security bug #533243
*				Note: size of pContigPacketBuf staging buffer is:
*				MAX_TOTAL_SIZE_WITH_ALL_HEADERS + FAST_IR_FCS_SIZE
*
*  Returns:		TRUE  - on success
*				FALSE - on failure
*
*
*****************************************************************************/
BOOLEAN         
NdisToMirPacket(
		IN PIR_DEVICE pIrDev,
		IN PNDIS_PACKET pPacket,
		OUT PUCHAR pIrPacketBuf,
		ULONG IrPacketBufLen,
		IN PUCHAR pContigPacketBuf,
		OUT PULONG pIrPacketLen
	)
{
    PNDIS_BUFFER        pNdisBuf;
    ULONG               ndisPacketBytes = 0;
    ULONG               I_fieldBytes, ndisPacketLen;
    MEDIUM_IR_FCS_TYPE  fcs;
    MEDIUM_IR_FCS_TYPE  UNALIGNED *pfcs;
    ULONG               i, TotalBytes, EscSize;
	PSTIR4200_FRAME_HEADER  pFrameHeader = (PSTIR4200_FRAME_HEADER)pIrPacketBuf;
	PUCHAR					pIrPacketBufFrame = pIrPacketBuf + sizeof(STIR4200_FRAME_HEADER);

    /***********************************************/
    /*   Get  the  packet's entire length and its  */
    /*   first NDIS buffer                         */
    /***********************************************/
    NdisQueryPacket( pPacket, NULL, NULL, &pNdisBuf, (UINT*)&ndisPacketLen );

    /***********************************************/
    /*   Make  sure that the packet is big enough  */
    /*   to be legal. It consists of an A, C, and  */
    /*   variable-length I field.                  */
    /***********************************************/
    if( ndisPacketLen < IRDA_A_C_TOTAL_SIZE )
    {
		DEBUGMSG(DBG_ERR, (" NdisToMirPacket(): Packet too small\n"));
        return FALSE;
    }
    else
    {
        I_fieldBytes = ndisPacketLen - IRDA_A_C_TOTAL_SIZE;
    }

    /***********************************************/
    /*   Make  sure  that  we won't overwrite our  */
    /*   contiguous buffer                         */
    /***********************************************/
    if( (ndisPacketLen > MAX_TOTAL_SIZE_WITH_ALL_HEADERS) ||
        (MAX_POSSIBLE_IR_PACKET_SIZE_FOR_DATA(I_fieldBytes) > IrPacketBufLen) )
    {
        /***********************************************/
        /*   The packet is too large. Tell the caller  */
        /*   to retry with a packet size large enough  */
        /*   to get past this stage next time.         */
        /***********************************************/
		DEBUGMSG(DBG_ERR, (" NdisToMirPacket(): Packet too big\n"));
        return FALSE;
    }

    /***********************************************/
    /*   Read  the  NDIS packet into a contiguous  */
    /*   buffer.  We have to do this in two steps  */
    /*   so  that  we  can compute the FCS BEFORE  */
    /*   applying escape-byte transparency.        */
    /***********************************************/
    while( pNdisBuf )
    {
        UCHAR *bufData;
        ULONG bufLen;

#if defined(LEGACY_NDIS5)
        NdisQueryBuffer( pNdisBuf, (PVOID*)&bufData, (UINT*)&bufLen );
#else
        NdisQueryBufferSafe( pNdisBuf, (PVOID*)&bufData, (UINT*)&bufLen, NormalPagePriority );
        if (bufData == NULL) 
		{
            DEBUGMSG(DBG_ERR, (" NdisToMirPacket(): Could not query buffer\n"));
            return FALSE;
        }
#endif
        if( ndisPacketBytes + bufLen > ndisPacketLen )
        {
			//
            // Packet was corrupt -- it misreported its size.
            //
			DEBUGMSG(DBG_ERR, (" NdisToMirPacket(): Packet is corrupt\n"));
			*pIrPacketLen = 0;
            return FALSE;
        }
        NdisMoveMemory( (PVOID)(pContigPacketBuf + ndisPacketBytes), (PVOID)bufData, bufLen );
        ndisPacketBytes += bufLen;
        NdisGetNextBuffer( pNdisBuf, &pNdisBuf );
    }

    /***********************************************/
    /*   Do sanity check on length of packet...    */
    /***********************************************/
    if( ndisPacketBytes != ndisPacketLen )
    {
		//
		// Packet was corrupt -- it misreported its size.
        //
		DEBUGMSG(DBG_ERR, (" NdisToMirPacket(): Packet is corrupt\n"));
		return FALSE;
    }

    /***********************************************/
    /*   Compute  the  FCS  on  the packet BEFORE  */
    /*   applying  transparency  fixups.  The FCS  */
    /*   also   must   be   sent  using  ESC-char  */
    /*   transparency.                             */
    /***********************************************/
    fcs = ComputeFCS16( pContigPacketBuf, ndisPacketBytes );

    /***********************************************/
    /*   Add FCS to packet...                      */
    /***********************************************/
    pfcs    = (MEDIUM_IR_FCS_TYPE *)&pContigPacketBuf[ndisPacketBytes];
    *pfcs   = fcs;

    /***********************************************/
    /*   Build the STIr4200 MIR frame.             */
    /***********************************************/

    /***********************************************/
    /*   Add BOF's...                              */
    /***********************************************/
    memset( pIrPacketBufFrame, STIR4200_MIR_BOF, STIR4200_MIR_BOF_SIZ );
    
    /***********************************************/
    /*   Escape A, C, I & CRC fields of packet...  */
    /***********************************************/
    EscSize = ndisPacketBytes + MEDIUM_IR_FCS_SIZE;
    for( i = 0, TotalBytes = STIR4200_MIR_BOF_SIZ; i < EscSize; i++ )
    {
        UCHAR   c;

        switch( c = pContigPacketBuf[i] )
        {
			case STIR4200_MIR_ESC_CHAR:
				pIrPacketBufFrame[TotalBytes++] = STIR4200_MIR_ESC_CHAR;
				pIrPacketBufFrame[TotalBytes++] = STIR4200_MIR_ESC_DATA_7D;
				break;
			case STIR4200_MIR_BOF:                  // BOF = EOF too
				pIrPacketBufFrame[TotalBytes++] = STIR4200_MIR_ESC_CHAR;
				pIrPacketBufFrame[TotalBytes++] = STIR4200_MIR_ESC_DATA_7E;
				break;
			default: 
				pIrPacketBufFrame[TotalBytes++] = c;
        }
    }

    /***********************************************/
    /*   Add EOF's...                              */
    /***********************************************/
    memset( &pIrPacketBufFrame[TotalBytes], STIR4200_MIR_EOF, STIR4200_MIR_EOF_SIZ );

  	/***********************************************/
    /*   Add in STIr4200 header...                 */
    /***********************************************/
    TotalBytes += STIR4200_MIR_EOF_SIZ;
    pFrameHeader->id1     = STIR4200_HEADERID_BYTE1;
    pFrameHeader->id2     = STIR4200_HEADERID_BYTE2;
    pFrameHeader->sizlsb  = LOBYTE(TotalBytes);
    pFrameHeader->sizmsb  = HIBYTE(TotalBytes);

	/***********************************************/
    /*   Calc size packet w/escaped data...        */
    /***********************************************/
    *pIrPacketLen = TotalBytes + sizeof(STIR4200_FRAME_HEADER);

    return TRUE;
}


/*****************************************************************************
*
*  Function:    NdisToSirPacket
*
*  Synopsis:    convert an NDIS packet to a Sir IR packet
*
*               Write the IR packet into the provided buffer and report
*               its actual size.
*
*  Arguments:	pIrDev - pointer to device instance
*				pPacket - NDIS packet to convert
*				pIrPacketBuf - output buffer
*				IrPacketBufLen - output buffer size
*				pContigPacketBuf - temporary staging buffer
*				pIrPacketLen - lenght of the converted data
*
*				MS Security bug #533243
*				Note: size of pContigPacketBuf staging buffer is:
*				MAX_TOTAL_SIZE_WITH_ALL_HEADERS + FAST_IR_FCS_SIZE
*
*  Returns:     TRUE  - on success
*               FALSE - on failure
*
*
*****************************************************************************/
BOOLEAN
NdisToSirPacket( 
		IN PIR_DEVICE pIrDev,
		IN PNDIS_PACKET pPacket,
		OUT PUCHAR pIrPacketBuf,
		ULONG IrPacketBufLen,
		IN PUCHAR pContigPacketBuf,
		OUT PULONG pIrPacketLen
	)
{
    PNDIS_BUFFER            pNdisBuf;
    ULONG                   i, ndisPacketBytes = 0;
    ULONG                   I_fieldBytes, totalBytes = 0;
    ULONG                   ndisPacketLen, numExtraBOFs;
    SLOW_IR_FCS_TYPE        fcs, tmpfcs;
    UCHAR                   fcsBuf[SLOW_IR_FCS_SIZE * 2];
    ULONG                   fcsLen = 0;
    PNDIS_IRDA_PACKET_INFO  pPacketInfo = GetPacketInfo(pPacket);
    UCHAR                   nextChar;
	PSTIR4200_FRAME_HEADER  pFrameHeader = (PSTIR4200_FRAME_HEADER)pIrPacketBuf;
	PUCHAR					pIrPacketBufFrame = pIrPacketBuf + sizeof(STIR4200_FRAME_HEADER);

    /***********************************************/
    /*   Get  the  packet's entire length and its  */
    /*   first NDIS buffer                         */
    /***********************************************/
    NdisQueryPacket( pPacket, NULL, NULL, &pNdisBuf, (UINT*)&ndisPacketLen );

    /***********************************************/
    /*   Make  sure that the packet is big enough  */
    /*   to be legal. It consists of an A, C, and  */
    /*   variable-length I field.                  */
    /***********************************************/
    if( ndisPacketLen < IRDA_A_C_TOTAL_SIZE )
    {
		DEBUGMSG(DBG_ERR, (" NdisToSirPacket(): Packet is too small\n"));
        return FALSE;
    }
    else
    {
        I_fieldBytes = ndisPacketLen - IRDA_A_C_TOTAL_SIZE;
    }

    /***********************************************/
    /*   Make  sure  that  we won't overwrite our  */
    /*   contiguous  buffer.  Make  sure that the  */
    /*   passed-in  buffer  can  accomodate  this  */
    /*   packet's  data  no  matter  how  much it  */
    /*   grows through adding ESC-sequences, etc.  */
    /***********************************************/
    if( (ndisPacketLen > MAX_TOTAL_SIZE_WITH_ALL_HEADERS) ||
        (MAX_POSSIBLE_IR_PACKET_SIZE_FOR_DATA(I_fieldBytes) > IrPacketBufLen) )
    {
		//
        // Packet is too big
		//
		DEBUGMSG(DBG_ERR, (" NdisToSirPacket(): Packet is too big\n"));
		return FALSE;
    }

    /***********************************************/
    /*   First,  read  the  NDIS  packet  into  a  */
    /*   contiguous buffer. We have to do this in  */
    /*   two steps so that we can compute the FCS  */
    /*   BEFORE        applying       escape-byte  */
    /*   transparency.                             */
    /***********************************************/
    while( pNdisBuf )
    {
        UCHAR *bufData;
        ULONG bufLen;

#if defined(LEGACY_NDIS5)
        NdisQueryBuffer( pNdisBuf, (PVOID*)&bufData, (UINT*)&bufLen );
#else
        NdisQueryBufferSafe( pNdisBuf, (PVOID*)&bufData, (UINT*)&bufLen, NormalPagePriority );
        if (bufData == NULL) 
		{
            DEBUGMSG(DBG_ERR, (" NdisToSirPacket(): Could not query buffer\n"));
            return FALSE;
        }
#endif
        if( (ndisPacketBytes + bufLen) > ndisPacketLen )
        {
            //
			// Packet was corrupt -- it misreported its size.
            //
			DEBUGMSG(DBG_ERR, (" NdisToSirPacket(): Packet is corrupt\n"));
			return FALSE;
        }
        NdisMoveMemory( (PVOID)(pContigPacketBuf + ndisPacketBytes), (PVOID)bufData, bufLen );
        ndisPacketBytes += bufLen;
        NdisGetNextBuffer( pNdisBuf, &pNdisBuf );
    }

    /***********************************************/
    /*   Do sanity check on length of packet...    */
    /***********************************************/
    if( ndisPacketBytes != ndisPacketLen )
    {
		//
        // Packet was corrupt -- it misreported its size.
        //
		DEBUGMSG(DBG_ERR, (" NdisToSirPacket(): Packet is corrupt\n"));
		return FALSE;
    }

    /***********************************************/
    /*   Compute  the  FCS  on  the packet BEFORE  */
    /*   applying  transparency  fixups.  The FCS  */
    /*   also   must   be   sent  using  ESC-char  */
    /*   transparency,  so  figure  out how large  */
    /*   the fcs will really be.                   */
    /***********************************************/
    fcs = ComputeFCS16( pContigPacketBuf, ndisPacketBytes );

    for( i = 0, tmpfcs = fcs, fcsLen = 0; i < SLOW_IR_FCS_SIZE; tmpfcs >>= 8, i++ )
    {
        UCHAR fcsbyte = tmpfcs & 0x00ff;

        switch( fcsbyte )
        {
			case SLOW_IR_BOF:
			case SLOW_IR_EOF:
			case SLOW_IR_ESC:
				fcsBuf[fcsLen++] = SLOW_IR_ESC;
				fcsBuf[fcsLen++] = fcsbyte ^ SLOW_IR_ESC_COMP;
				break;
			default:
				fcsBuf[fcsLen++] = fcsbyte;
				break;
        }
    }

    /***********************************************/
    /*   Now begin building the IR frame.          */
    /*                                             */
    /*   This is the final format:                 */
    /*                                             */
    /*  BOF  (1)                                   */
    /*  extra BOFs ...                             */
    /*          NdisMediumIrda packet (from NDIS): */
    /*                  Address (1)                */
    /*                  Control (1)                */
    /*          FCS     (2)                        */
    /*  EOF  (1)                                   */
    /*                                             */
    /*  Prepend BOFs (extra BOFs + 1 actual BOF)   */
    /***********************************************/
	numExtraBOFs = pPacketInfo->ExtraBOFs;
    if( numExtraBOFs > MAX_NUM_EXTRA_BOFS )
    {
        numExtraBOFs = MAX_NUM_EXTRA_BOFS;
    }

    for( i = totalBytes = 0; i < numExtraBOFs; i++ )
    {
        *(SLOW_IR_BOF_TYPE*)(pIrPacketBufFrame + totalBytes) = SLOW_IR_EXTRA_BOF;
        totalBytes += SLOW_IR_EXTRA_BOF_SIZE;
    }

    *(SLOW_IR_BOF_TYPE*)(pIrPacketBufFrame + totalBytes) = SLOW_IR_BOF;
    totalBytes += SLOW_IR_BOF_SIZE;

    /***********************************************/
    /*   Copy the NDIS packet from our contiguous  */
    /*   buffer,       applying       escape-char  */
    /*   transparency.                             */
    /***********************************************/
    for( i = 0; i < ndisPacketBytes; i++ )
    {
        nextChar = pContigPacketBuf[i];
        switch( nextChar )
        {
			case SLOW_IR_BOF:
			case SLOW_IR_EOF:
			case SLOW_IR_ESC:
				pIrPacketBufFrame[totalBytes++] = SLOW_IR_ESC;
				pIrPacketBufFrame[totalBytes++] = nextChar ^ SLOW_IR_ESC_COMP;
				break;
			default:
				pIrPacketBufFrame[totalBytes++] = nextChar;
				break;
        }
    }

    /***********************************************/
    /*   Add FCS, EOF.                             */
    /***********************************************/
    NdisMoveMemory( (PVOID)(pIrPacketBufFrame + totalBytes), (PVOID)fcsBuf, fcsLen );
    totalBytes += fcsLen;
    *(SLOW_IR_EOF_TYPE*)(pIrPacketBufFrame + totalBytes) = (UCHAR)SLOW_IR_EOF;
    totalBytes += SLOW_IR_EOF_SIZE;

 	/***********************************************/
    /*   Add in STIr4200 header...                 */
    /***********************************************/
    pFrameHeader->id1     = STIR4200_HEADERID_BYTE1;
    pFrameHeader->id2     = STIR4200_HEADERID_BYTE2;
    pFrameHeader->sizlsb  = LOBYTE(totalBytes);
    pFrameHeader->sizmsb  = HIBYTE(totalBytes);

   *pIrPacketLen = totalBytes + sizeof(STIR4200_FRAME_HEADER);
   return TRUE;
}


/*****************************************************************************
*
*  Function:	ComputeFCS16
*
*  Synopsis:	Calculates the 16 bit CRC.
*
*  Arguments:	pData - pointer to data buffer
*				DataLen - length of data buffer
*	
*  Returns:		Calculated CRC 
*
*  Notes:
*
*****************************************************************************/
USHORT
ComputeFCS16(
		IN PUCHAR pData, 
		UINT DataLen
	)
{
    USHORT	fcs = 0xffff;
    UINT    i;

    for( i = 0; i < DataLen; i++ )
    {
        fcs = (fcs >> 8) ^ fcsTable16[(fcs ^ *pData++)& 0xff];
    }
    fcs = ~fcs;
    return fcs;
}


/*****************************************************************************
*
*  Function:	ComputeFCS32
*
*  Synopsis:	Calculates the 32 bit CRC.
*
*  Arguments:	pData - pointer to data buffer
*				DataLen - length of data buffer
*	
*  Returns:		Calculated CRC 
*
*  Notes:
*
*****************************************************************************/
#define USE_FASTER_CRC32 1
ULONG 
ComputeFCS32(
		IN PUCHAR pData, 
		ULONG DataLen
	)
{
#ifdef USE_FASTER_CRC32

#define UPDC32(octet, crc) (crc_32_tab[((crc) ^ ((UCHAR)octet)) & 0xff] ^ ((crc) >> 8))

    ULONG   crc;

    crc = 0xFFFFFFFF;
    for( ; DataLen; --DataLen, ++pData )
    {
        crc = (fcsTable32[((crc) ^ (*pData)) & 0xff] ^ ((crc) >> 8));
    }
    return ~crc;
#else
    ULONG	crc, temp1, temp2;

    crc = 0xFFFFFFFF;
    while( DataLen-- != 0 )
    {
        temp1 = (crc >> 8) & 0x00FFFFFFL;
        temp2 = fcsTable32[((int)crc ^ *pData++) & 0xff];
        crc = temp1 ^ temp2;
    }
    return crc;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\net\irda\sigmatel\sys\diagsioctl.h ===
/**************************************************************************************************************************
 *  DIAGSIOCTL.H SigmaTel STIR4200 diagnostic IOCTL definitions
 **************************************************************************************************************************
 *  (C) Unpublished Copyright of Sigmatel, Inc. All Rights Reserved.
 *
 *
 *		Created: 05/12/2000 
 *			Version 0.94
 *		Edited: 05/24/2000 
 *			Version 0.96
 *	
 *
 **************************************************************************************************************************/

#ifndef DIAGSIOCTL_H
#define DIAGSIOCTL_H

//
// Diagnostic operation codes
//
#define DIAGS_ENABLE			0
#define DIAGS_DISABLE			1
#define DIAGS_READ_REGISTERS	2
#define DIAGS_WRITE_REGISTER	3
#define DIAGS_BULK_OUT			4
#define DIAGS_BULK_IN			5
#define DIAGS_SEND				6
#define DIAGS_RECEIVE			7
#define DIAGS_GET_SPEED			8
#define DIAGS_SET_SPEED			9

//
// Read Register structure
//
typedef struct _DIAGS_READ_REGISTERS_IOCTL
{
	USHORT DiagsCode;
	UCHAR FirstRegister;
	UCHAR NumberRegisters;
	UCHAR pRegisterBuffer[1];
} DIAGS_READ_REGISTERS_IOCTL, *PDIAGS_READ_REGISTERS_IOCTL;

typedef struct _IR_REG
{
	UCHAR RegNum;
	UCHAR RegVal;
} IR_REG, *PIR_REG;

//
// Bulk structure 
//
typedef struct _DIAGS_BULK_IOCTL
{
	USHORT DiagsCode;
	USHORT DataSize;
	UCHAR pData[1];
} DIAGS_BULK_IOCTL, *PDIAGS_BULK_IOCTL;

//
// Send structure
//
typedef struct _DIAGS_SEND_IOCTL
{
	USHORT DiagsCode;
	USHORT ExtraBOFs;
	USHORT DataSize;
	UCHAR pData[1];
} DIAGS_SEND_IOCTL, *PDIAGS_SEND_IOCTL;

//
// Receive structure
//
typedef struct _DIAGS_RECEIVE_IOCTL
{
	USHORT DiagsCode;
	USHORT DataSize;
	UCHAR pData[1];
} DIAGS_RECEIVE_IOCTL, *PDIAGS_RECEIVE_IOCTL;

//
// Speed get/set structure
//
typedef struct _DIAGS_SPEED_IOCTL
{
	USHORT DiagsCode;
	ULONG Speed;
} DIAGS_SPEED_IOCTL, *PDIAGS_SPEED_IOCTL;

#define FILE_DEVICE_STIRUSB			0x8000

#define IOCTL_PROTOCOL_DIAGS		CTL_CODE(FILE_DEVICE_STIRUSB, 0 , METHOD_BUFFERED, FILE_ANY_ACCESS)

#endif DIAGSIOCTL_H

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\net\irda\sigmatel\sys\diags.h ===
/**************************************************************************************************************************
 *  DIAGS.H SigmaTel STIR4200 diagnostic definitions
 **************************************************************************************************************************
 *  (C) Unpublished Copyright of Sigmatel, Inc. All Rights Reserved.
 *
 *
 *		Created: 04/27/2000 
 *			Version 0.92
 *		Edited: 05/12/2000 
 *			Version 0.94
 *	
 *
 **************************************************************************************************************************/

#ifndef DIAGS_H
#define DIAGS_H

#include "diagsioctl.h"

//
// Prototypes
//
BOOLEAN         
Diags_BufferToFirPacket(
		IN PIR_DEVICE pIrDev,
		OUT PUCHAR pIrPacketBuf,
		ULONG IrPacketBufLen,
		IN PUCHAR pContigPacketBuf,
		ULONG ContigPacketLen,
		OUT PULONG pIrPacketLen
	);

BOOLEAN
Diags_BufferToSirPacket(
		IN PIR_DEVICE pIrDev,
		OUT PUCHAR pIrPacketBuf,
		ULONG IrPacketBufLen,
		IN PUCHAR pContigPacketBuf,
		ULONG ContigPacketLen,
		USHORT ExtraBOFs,
		OUT PULONG pIrPacketLen
	);

NTSTATUS
Diags_Enable(
		IN OUT PIR_DEVICE pThisDev
	);

NTSTATUS
Diags_Disable(
		IN OUT PIR_DEVICE pThisDev
	);

NTSTATUS
Diags_ReadRegisters(
		IN PIR_DEVICE pThisDev,
		OUT PDIAGS_READ_REGISTERS_IOCTL pIOCTL,
		ULONG IOCTLSize
	);

NTSTATUS
Diags_WriteRegister(
		IN OUT PIR_DEVICE pThisDev,
		OUT PDIAGS_READ_REGISTERS_IOCTL pIOCTL,
		ULONG IOCTLSize
	);

NTSTATUS
Diags_PrepareBulk(
		IN OUT PIR_DEVICE pThisDev,
		OUT PDIAGS_BULK_IOCTL pIOCTL,
		ULONG IOCTLSize,
		BOOLEAN DirectionOut
	);

NTSTATUS
Diags_PrepareSend(
		IN OUT PIR_DEVICE pThisDev,
		OUT PDIAGS_SEND_IOCTL pIOCTL,
		ULONG IOCTLSize
	);

NTSTATUS
Diags_Receive(
		IN OUT PIR_DEVICE pThisDev,
		OUT PDIAGS_RECEIVE_IOCTL pIOCTL,
		ULONG IOCTLSize
	);

NTSTATUS
Diags_GetSpeed(
		IN OUT PIR_DEVICE pThisDev,
		OUT PDIAGS_SPEED_IOCTL pIOCTL,
		ULONG IOCTLSize
	);

NTSTATUS
Diags_SetSpeed(
		IN OUT PIR_DEVICE pThisDev,
		OUT PDIAGS_SPEED_IOCTL pIOCTL,
		ULONG IOCTLSize
	);

VOID
Diags_CompleteEnable(
		IN OUT PIR_DEVICE pThisDev,
		IN PVOID pContext
	);

NTSTATUS
Diags_CompleteReadRegisters(
		IN OUT PIR_DEVICE pThisDev,
		IN PVOID pContext
	);

NTSTATUS
Diags_CompleteWriteRegister(
		IN OUT PIR_DEVICE pThisDev,
		IN PVOID pContext
	);

NTSTATUS
Diags_Bulk(
		IN OUT PIR_DEVICE pThisDev,
		IN PVOID pContext,
		BOOLEAN DirectionOut
	);

NTSTATUS
Diags_Send(
		IN OUT PIR_DEVICE pThisDev,
		IN PVOID pContext
	);

NTSTATUS
Diags_CompleteIrp(
		IN PDEVICE_OBJECT pUsbDevObj,
		IN PIRP           pIrp,
		IN PVOID          Context
	);

#endif DIAGS_H

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\net\irda\sigmatel\sys\debug.c ===
/**************************************************************************************************************************
 *  DEBUG.C SigmaTel STIR4200 debug module
 **************************************************************************************************************************
 *  (C) Unpublished Copyright of Sigmatel, Inc. All Rights Reserved.
 *
 *
 *		Created: 04/06/2000 
 *			Version 0.9
 *	
 *
 **************************************************************************************************************************/

#if DBG

#include "ndis.h"
#include "stdarg.h"
#include "stdio.h"

#include "usbdi.h"
#include "usbdlib.h"
#include "debug.h"


//
// begin, data/code  used only in DBG build
//
IRUSB_DBGDATA gDbgBuf = { 0, 0, 0 }; 

//
// ptr to global debug data struct; txt buffer is only allocated in DBG builds
//
PIRUSB_DBGDATA gpDbg = &gDbgBuf; 

#ifdef DEBUG
int DbgSettings =
                  //DBG_PNP |
                  //DBG_TIME     |
                  //DBG_DBG      |
                  //DBG_STAT     |
                  //DBG_FUNCTION |
                  DBG_ERROR    |
                  //DBG_WARN |
                  //DBG_BUFS |
                  //DBG_OUT |
                  0;
#endif


/*****************************************************************************
*
*  Function:	DBG_PrintBuf
*
*  Synopsis:	Prints a message to the debugger.
*
*  Arguments:	bufptr - pointer to the data to print
*				buflen - length of data 
*	
*  Returns:		None 
*
*  Notes:
*
*****************************************************************************/
VOID 
DBG_PrintBuf( 
		IN PUCHAR bufptr, 
		int buflen 
	)
{
	int i, linei;

	#define ISPRINT(ch) (((ch) >= ' ') && ((ch) <= '~'))
	#define PRINTCHAR(ch) (UCHAR)(ISPRINT(ch) ? (ch) : '.')

	DbgPrint("\r\n         %d bytes @%x:", buflen, bufptr);

	//
	//  Print whole lines of 8 characters with HEX and ASCII
	//
	for (i = 0; i+8 <= buflen; i += 8) 
	{
		UCHAR ch0 = bufptr[i+0],
			ch1 = bufptr[i+1], ch2 = bufptr[i+2],
			ch3 = bufptr[i+3], ch4 = bufptr[i+4],
			ch5 = bufptr[i+5], ch6 = bufptr[i+6],
			ch7 = bufptr[i+7];

		DbgPrint("\r\n         %02x %02x %02x %02x %02x %02x %02x %02x"
			"   %c %c %c %c %c %c %c %c",
			ch0, ch1, ch2, ch3, ch4, ch5, ch6, ch7,
			PRINTCHAR(ch0), PRINTCHAR(ch1),
			PRINTCHAR(ch2), PRINTCHAR(ch3),
			PRINTCHAR(ch4), PRINTCHAR(ch5),
			PRINTCHAR(ch6), PRINTCHAR(ch7));
	}

	//
	//  Print final incomplete line
	//
	DbgPrint("\r\n        ");
	for (linei = 0; (linei < 8) && (i < buflen); i++, linei++)
	{
		DbgPrint(" %02x", (int)(bufptr[i]));
	}

	DbgPrint("  ");
	i -= linei;
	while (linei++ < 8) DbgPrint("   ");

	for (linei = 0; (linei < 8) && (i < buflen); i++, linei++){
		UCHAR ch = bufptr[i];
		DbgPrint(" %c", PRINTCHAR(ch));
	}

	DbgPrint("\t\t<>\r\n");
}



#endif // end , if DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\net\irda\sigmatel\sys\debug.h ===
/**************************************************************************************************************************
 *  DEBUG.H SigmaTel STIR4200 debug header file
 **************************************************************************************************************************
 *  (C) Unpublished Copyright of Sigmatel, Inc. All Rights Reserved.
 *
 *
 *		Created: 04/06/2000 
 *			Version 0.9
 *		Edited: 04/27/2000 
 *			Version 0.92
 *	
 *
 **************************************************************************************************************************/

#ifndef _DEBUG_H_
#define _DEBUG_H_

#if DBG

#define DEBUG
#define DEBUG_IRUSB

//Begin, Debug code from BulkUsb

#ifndef DBGSTR_PREFIX
#define DBGSTR_PREFIX "StIrUsb: " 
#endif

#define DPRINT DbgPrint

#define TRAP() DbgBreakPoint();

#define IRUSB_DBGOUTSIZE 512

typedef struct _IRUSB_DBGDATA 
{
	// mirrors device extension pending io count
	ULONG PendingIoCount;

	// count of pipe errors detected during the life of this device instance
	ULONG PipeErrorCount;

	// count of pipe resets performed during the life of this device instance
	ULONG ResetPipeCount;

} IRUSB_DBGDATA, *PIRUSB_DBGDATA;

//these declared in debug 'c' file
extern PIRUSB_DBGDATA gpDbg; 

static const PCHAR szIrpMajFuncDesc[] =
{  // note this depends on corresponding values to the indexes in wdm.h
   "IRP_MJ_CREATE",
   "IRP_MJ_CREATE_NAMED_PIPE",
   "IRP_MJ_CLOSE",
   "IRP_MJ_READ",
   "IRP_MJ_WRITE",
   "IRP_MJ_QUERY_INFORMATION",
   "IRP_MJ_SET_INFORMATION",
   "IRP_MJ_QUERY_EA",
   "IRP_MJ_SET_EA",
   "IRP_MJ_FLUSH_BUFFERS",
   "IRP_MJ_QUERY_VOLUME_INFORMATION",
   "IRP_MJ_SET_VOLUME_INFORMATION",
   "IRP_MJ_DIRECTORY_CONTROL",
   "IRP_MJ_FILE_SYSTEM_CONTROL",
   "IRP_MJ_DEVICE_CONTROL",
   "IRP_MJ_INTERNAL_DEVICE_CONTROL",
   "IRP_MJ_SHUTDOWN",
   "IRP_MJ_LOCK_CONTROL",
   "IRP_MJ_CLEANUP",
   "IRP_MJ_CREATE_MAILSLOT",
   "IRP_MJ_QUERY_SECURITY",
   "IRP_MJ_SET_SECURITY",
   "IRP_MJ_POWER",          
   "IRP_MJ_SYSTEM_CONTROL", 
   "IRP_MJ_DEVICE_CHANGE",  
   "IRP_MJ_QUERY_QUOTA",    
   "IRP_MJ_SET_QUOTA",      
   "IRP_MJ_PNP"            
};
//IRP_MJ_MAXIMUM_FUNCTION defined in wdm.h

static const PCHAR szPnpMnFuncDesc[] =
{	// note this depends on corresponding values to the indexes in wdm.h 

    "IRP_MN_START_DEVICE",
    "IRP_MN_QUERY_REMOVE_DEVICE",
    "IRP_MN_REMOVE_DEVICE",
    "IRP_MN_CANCEL_REMOVE_DEVICE",
    "IRP_MN_STOP_DEVICE",
    "IRP_MN_QUERY_STOP_DEVICE",
    "IRP_MN_CANCEL_STOP_DEVICE",
    "IRP_MN_QUERY_DEVICE_RELATIONS",
    "IRP_MN_QUERY_INTERFACE",
    "IRP_MN_QUERY_CAPABILITIES",
    "IRP_MN_QUERY_RESOURCES",
    "IRP_MN_QUERY_RESOURCE_REQUIREMENTS",
    "IRP_MN_QUERY_DEVICE_TEXT",
    "IRP_MN_FILTER_RESOURCE_REQUIREMENTS",
    "IRP_MN_READ_CONFIG",
    "IRP_MN_WRITE_CONFIG",
    "IRP_MN_EJECT",
    "IRP_MN_SET_LOCK",
    "IRP_MN_QUERY_ID",
    "IRP_MN_QUERY_PNP_DEVICE_STATE",
    "IRP_MN_QUERY_BUS_INFORMATION",
    "IRP_MN_DEVICE_USAGE_NOTIFICATION",
	"IRP_MN_SURPRISE_REMOVAL"
};

#define IRP_PNP_MN_FUNCMAX	IRP_MN_SURPRISE_REMOVAL

static const PCHAR szSystemPowerState[] = 
{
    "PowerSystemUnspecified",
    "PowerSystemWorking",
    "PowerSystemSleeping1",
    "PowerSystemSleeping2",
    "PowerSystemSleeping3",
    "PowerSystemHibernate",
    "PowerSystemShutdown",
    "PowerSystemMaximum"
};

static const PCHAR szDevicePowerState[] = 
{
    "PowerDeviceUnspecified",
    "PowerDeviceD0",
    "PowerDeviceD1",
    "PowerDeviceD2",
    "PowerDeviceD3",
    "PowerDeviceMaximum"
};

VOID 
DBG_PrintBuf(
		IN PUCHAR bufptr, 
		int buflen
	);

#define IRUSB_ASSERT( cond ) ASSERT( cond )

#define IRUSB_StringForDevState( devState )	szDevicePowerState[ devState ] 

#define IRUSB_StringForSysState( sysState )	szSystemPowerState[ sysState ] 

#define IRUSB_StringForPnpMnFunc( mnfunc ) szPnpMnFuncDesc[ mnfunc ]

#define IRUSB_StringForIrpMjFunc( mjfunc ) szIrpMajFuncDesc[ mjfunc ]


#else // if not DBG

//
// dummy definitions that go away in the retail build
//
#define IRUSB_ASSERT( cond )
#define IRUSB_StringForDevState( devState )
#define IRUSB_StringForSysState( sysState ) 
#define IRUSB_StringForPnpMnFunc( mnfunc )
#define IRUSB_StringForIrpMjFunc( mjfunc ) 

#endif
// End, debug code from Bul kUsb

#ifdef DEBUG

#define DEBUGCOND( ilev, cond, _x_) \
	if( (ilev & DbgSettings) && ( cond )) { \
			DbgPrint( DBGSTR_PREFIX ); \
			DbgPrint _x_ ; \
	}

#define DEBUGONCE( ilev, _x_ ) \
{ \
	static BOOLEAN didOnce = FALSE; \
	if ( !didOnce ) { \
		didOnce = TRUE; \
	    DEBUGMSG( ilev, _x_ ); \
	} \
}

#define DEBUGONCECOND( ilev, cond, _x_ ) \
{ \
	static BOOLEAN didOnce = FALSE; \
	if (( !didOnce ) && (cond)) { \
		didOnce = TRUE; \
	    DEBUGMSG( ilev, _x_ ); \
	} \
}

extern int DbgSettings;

#define DEBUGMSG( dbgs, format )		( ((dbgs) & DbgSettings)? DbgPrint format:0 )

#define IRUSB_DUMP( flag, parms )		( (( flag) & DbgSettings )? DBG_PrintBuf parms: 0 )

    #define DBG_STAT     (1 << 23)
    #define DBG_PNP      (1 << 24)
    #define DBG_TIME     (1 << 25)
    #define DBG_DBG      (1 << 26)
    #define DBG_OUT      (1 << 27)
    #define DBG_BUF      (1 << 28)
    #define DBG_BUFS     (1 << 28)
    #define DBG_FUNCTION (1 << 29)
    #define DBG_FUNC     (1 << 29)
    #define DBG_WARN     (1 << 30)
    #define DBG_WARNING  (1 << 30)
    #define DBG_ERROR    (1 << 31)
    #define DBG_ERR      (1 << 31)
#if defined(ERROR_MESSAGES)
    #define DBG_INT_ERR  (1 << 31)
#else
    #define DBG_INT_ERR  (1 << 29)
#endif

    #define DBGDBG(_dbgPrint)                       \
            DbgPrint(_dbgPrint)

    #ifdef DEBUG_IRUSB

        #define DBG_D(dbgs, i) (((dbgs) & DbgSettings)? DbgPrint("irusb:"#i"==%d\n", (i)):0)
        #define DBG_X(dbgs, x) (((dbgs) & DbgSettings)? DbgPrint("irusb:"#x"==0x%0*X\n", sizeof(x)*2, ((ULONG_PTR)(x))&((1<<(sizeof(x)*8))-1) ):0)
        #define DBG_UNISTR(dbgs, s) (((dbgs) & DbgSettings)? DbgPrint("irusb:"#s"==%wZ\n", (s) ):0))

        #define DBGTIME(_str)                               \
            {                                               \
                LARGE_INTEGER Time;                         \
                                                            \
                KeQuerySystemTime(&Time);                   \
                DEBUGMSG(DBG_TIME, (_str " %d:%d\n",        \
                                    Time.HighPart,          \
                                    Time.LowPart/10000));   \
            }
    #else // DEBUG_IRUSB

        #define DBGTIME(_str)
        #define DBGFUNC(_dbgPrint)
        #define DBGOUT(_dbgPrint)
        #define DBGERR(_dbgPrint)
        #define DBGWARN(_dbgPrint)
        #define DBGSTAT(_dbgPrint)
        #define DBGTIME(_dbgPrint)
        #define DEBUGMSG(dbgs,format)
		#define DEBUGONCE( ilev, _x_ )
		#define DEBUGCOND( a, b, c )
		#define DEBUGONCECOND( a, b, c )
        #define IRUSB_DUMP(dbgs,format)

    #endif // DEBUG_IRUSB

#else // DEBUG

    #define DBGTIME(_str)
    #define DBGFUNC(_dbgPrint)
    #define DBGDBG(_dbgPrint)
    #define DBGOUT(_dbgPrint)
    #define DBGERR(_dbgPrint)
    #define DBGWARN(_dbgPrint)
    #define DBGSTAT(_dbgPrint)
    #define DEBUGMSG(dbgs,format)
    #define DBG_D(dbgs, ivar)
    #define DBG_X(dbgs, xvar)
    #define DBG_UNISTR(dbgs, svar)
	#define DEBUGONCE( ilev, _x_ )
	#define DEBUGONCECOND( a, b, c )
    #define DEBUGCOND( a, b, c )
    #define IRUSB_DUMP(dbgs,format)

#endif // DEBUG

#endif // _DEBUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\net\irda\sigmatel\sys\diags.c ===
/**************************************************************************************************************************
 *  DIAGS.C SigmaTel STIR4200 diagnostic module
 **************************************************************************************************************************
 *  (C) Unpublished Copyright of Sigmatel, Inc. All Rights Reserved.
 *
 *
 *		Created: 04/27/2000 
 *			Version 0.92
 *		Edited: 05/12/2000 
 *			Version 0.94
 *		Edited: 05/19/2000 
 *			Version 0.95
 *		Edited: 05/24/2000 
 *			Version 0.96
 *		Edited: 10/09/2000 
 *			Version 1.10
 *	
 *
 **************************************************************************************************************************/

#if defined(DIAGS)

#define DOBREAKS    // enable debug breaks

#include <ndis.h>
#include <ntddndis.h>  // defines OID's

#include <usbdi.h>
#include <usbdlib.h>

#include "debug.h"
#include "ircommon.h"
#include "irndis.h"
#include "irusb.h"
#include "stir4200.h"
#include "diags.h"


/*****************************************************************************
*
*  Function:	Diags_BufferToFirPacket
*
*  Synopsis:	convert a buffer to a Fir IR packet
*
*				Write the IR packet into the provided buffer and report
*				its actual size.
*
*  Arguments:	pIrDev - pointer to device instance
*				pIrPacketBuf - output buffer
*				IrPacketBufLen - output buffer size
*				pContigPacketBuf - temporary staging buffer (input buffer)
*				ContigPacketLen - input buffer size
*				pIrPacketLen - lenght of the converted data
*
*				MS Security bug #533243
*				Note: size of pContigPacketBuf staging buffer is:
*				MAX_TOTAL_SIZE_WITH_ALL_HEADERS + FAST_IR_FCS_SIZE
*
*  Returns:		TRUE  - on success
*				FALSE - on failure
*
*
*****************************************************************************/
BOOLEAN         
Diags_BufferToFirPacket(
		IN PIR_DEVICE pIrDev,
		OUT PUCHAR pIrPacketBuf,
		ULONG IrPacketBufLen,
		IN PUCHAR pContigPacketBuf,
		ULONG ContigPacketLen,
		OUT PULONG pIrPacketLen
	)
{
    ULONG               I_fieldBytes;
    FAST_IR_FCS_TYPE    fcs, *pfcs;
    ULONG               i, TotalBytes, EscSize;
	PSTIR4200_FRAME_HEADER  pFrameHeader = (PSTIR4200_FRAME_HEADER)pIrPacketBuf;
	PUCHAR					pIrPacketBufFrame = pIrPacketBuf + sizeof(STIR4200_FRAME_HEADER);

    /***********************************************/
    /*   Make  sure that the packet is big enough  */
    /*   to be legal. It consists of an A, C, and  */
    /*   variable-length I field.                  */
    /***********************************************/
    if( ContigPacketLen < IRDA_A_C_TOTAL_SIZE )
    {
		DEBUGMSG(DBG_ERR, (" Diags_BufferToFirPacket(): Packet is too small\n"));
        return FALSE;
    }
    else
    {
        I_fieldBytes = ContigPacketLen - IRDA_A_C_TOTAL_SIZE;
    }

    /***********************************************/
    /*   Make  sure  that  we won't overwrite our  */
    /*   contiguous buffer                         */
    /***********************************************/
    if( (ContigPacketLen > MAX_TOTAL_SIZE_WITH_ALL_HEADERS) ||
        (MAX_POSSIBLE_IR_PACKET_SIZE_FOR_DATA(I_fieldBytes) > IrPacketBufLen) )
    {
        /***********************************************/
        /*   The packet is too large. Tell the caller  */
        /*   to retry with a packet size large enough  */
        /*   to get past this stage next time.         */
        /***********************************************/
		DEBUGMSG(DBG_ERR, (" Diags_BufferToFirPacket(): Packet is too big\n"));
        return FALSE;
    }

    /***********************************************/
    /*   Compute  the  FCS  on  the packet BEFORE  */
    /*   applying  transparency  fixups.  The FCS  */
    /*   also   must   be   sent  using  ESC-char  */
    /*   transparency.                             */
    /***********************************************/
    fcs = ComputeFCS32( pContigPacketBuf, ContigPacketLen );

    /***********************************************/
    /*   Add FCS to packet...                      */
    /***********************************************/
    pfcs = (FAST_IR_FCS_TYPE *)&pContigPacketBuf[ContigPacketLen];
    *pfcs = fcs;

    /***********************************************/
    /*   Build the STIr4200 FIR frame.             */
    /***********************************************/

    /***********************************************/
    /*   Add preamble...                           */
    /***********************************************/
    memset( pIrPacketBufFrame, STIR4200_FIR_PREAMBLE, STIR4200_FIR_PREAMBLE_SIZ );

    /***********************************************/
    /*   Add BOF's...                              */
    /***********************************************/
    memset( &pIrPacketBufFrame[STIR4200_FIR_PREAMBLE_SIZ], STIR4200_FIR_BOF, STIR4200_FIR_BOF_SIZ );
    
    /***********************************************/
    /*   Escape A, C, I & CRC fields of packet...  */
    /***********************************************/
    EscSize = ContigPacketLen + FAST_IR_FCS_SIZE;
    for( i = 0, TotalBytes = STIR4200_FIR_PREAMBLE_SIZ + STIR4200_FIR_BOF_SIZ; i < EscSize; i++ )
    {
        UCHAR   c;

        switch( c = pContigPacketBuf[i] )
        {
			case STIR4200_FIR_ESC_CHAR:
				pIrPacketBufFrame[TotalBytes++] = STIR4200_FIR_ESC_CHAR;
				pIrPacketBufFrame[TotalBytes++] = STIR4200_FIR_ESC_DATA_7D;
				break;
			case STIR4200_FIR_BOF:                  // BOF = EOF too
				pIrPacketBufFrame[TotalBytes++] = STIR4200_FIR_ESC_CHAR;
				pIrPacketBufFrame[TotalBytes++] = STIR4200_FIR_ESC_DATA_7E;
				break;
			case STIR4200_FIR_PREAMBLE:
				pIrPacketBufFrame[TotalBytes++] = STIR4200_FIR_ESC_CHAR;
				pIrPacketBufFrame[TotalBytes++] = STIR4200_FIR_ESC_DATA_7F;
				break;
			default: 
				pIrPacketBufFrame[TotalBytes++] = c;
        }
    }

    /***********************************************/
    /*   Add EOF's...                              */
    /***********************************************/
    memset( &pIrPacketBufFrame[TotalBytes], STIR4200_FIR_EOF, STIR4200_FIR_EOF_SIZ );

  	/***********************************************/
    /*   Add in STIr4200 header...                 */
    /***********************************************/
    TotalBytes += STIR4200_FIR_EOF_SIZ;
    pFrameHeader->id1     = STIR4200_HEADERID_BYTE1;
    pFrameHeader->id2     = STIR4200_HEADERID_BYTE2;
    pFrameHeader->sizlsb  = LOBYTE(TotalBytes);
    pFrameHeader->sizmsb  = HIBYTE(TotalBytes);

	/***********************************************/
    /*   Calc size packet w/escaped data...        */
    /***********************************************/
    *pIrPacketLen = TotalBytes + sizeof(STIR4200_FRAME_HEADER);

    return TRUE;
}


/*****************************************************************************
*
*  Function:	Diags_BufferToSirPacket
*
*  Synopsis:	convert a buffer to a Sir IR packet
*
*               Write the IR packet into the provided buffer and report
*               its actual size.
*
*  Arguments:	pIrDev - pointer to device instance
*				pPacket - NDIS packet to convert
*				pIrPacketBuf - output buffer
*				IrPacketBufLen - output buffer size
*				pContigPacketBuf - temporary staging buffer (input buffer)
*				ContigPacketLen - input buffer size
*				pIrPacketLen - lenght of the converted data
*
*				MS Security bug #533243
*				Note: size of pContigPacketBuf staging buffer is:
*				MAX_TOTAL_SIZE_WITH_ALL_HEADERS + FAST_IR_FCS_SIZE
*
*  Returns:     TRUE  - on success
*               FALSE - on failure
*
*
*****************************************************************************/
BOOLEAN
Diags_BufferToSirPacket(
		IN PIR_DEVICE pIrDev,
		OUT PUCHAR pIrPacketBuf,
		ULONG IrPacketBufLen,
		IN PUCHAR pContigPacketBuf,
		ULONG ContigPacketLen,
		USHORT ExtraBOFs,
		OUT PULONG pIrPacketLen
	)
{
    ULONG                   i;
    ULONG                   I_fieldBytes, totalBytes = 0;
    ULONG                   numExtraBOFs;
    SLOW_IR_FCS_TYPE        fcs, tmpfcs;
    UCHAR                   fcsBuf[SLOW_IR_FCS_SIZE * 2];
    ULONG                   fcsLen = 0;
    UCHAR                   nextChar;
	PSTIR4200_FRAME_HEADER  pFrameHeader = (PSTIR4200_FRAME_HEADER)pIrPacketBuf;
	PUCHAR					pIrPacketBufFrame = pIrPacketBuf + sizeof(STIR4200_FRAME_HEADER);

    /***********************************************/
    /*   Make  sure that the packet is big enough  */
    /*   to be legal. It consists of an A, C, and  */
    /*   variable-length I field.                  */
    /***********************************************/
    if( ContigPacketLen < IRDA_A_C_TOTAL_SIZE )
    {
		DEBUGMSG(DBG_ERR, (" NdisToSirPacket(): Packet is too small\n"));
        return FALSE;
    }
    else
    {
        I_fieldBytes = ContigPacketLen - IRDA_A_C_TOTAL_SIZE;
    }

    /***********************************************/
    /*   Make  sure  that  we won't overwrite our  */
    /*   contiguous  buffer.  Make  sure that the  */
    /*   passed-in  buffer  can  accomodate  this  */
    /*   packet's  data  no  matter  how  much it  */
    /*   grows through adding ESC-sequences, etc.  */
    /***********************************************/
    if( (ContigPacketLen > MAX_TOTAL_SIZE_WITH_ALL_HEADERS) ||
        (MAX_POSSIBLE_IR_PACKET_SIZE_FOR_DATA(I_fieldBytes) > IrPacketBufLen) )
    {
		//
        // Packet is too big
		//
		DEBUGMSG(DBG_ERR, (" NdisToSirPacket(): Packet is too big\n"));
		return FALSE;
    }

    /***********************************************/
    /*   Compute  the  FCS  on  the packet BEFORE  */
    /*   applying  transparency  fixups.  The FCS  */
    /*   also   must   be   sent  using  ESC-char  */
    /*   transparency,  so  figure  out how large  */
    /*   the fcs will really be.                   */
    /***********************************************/
    fcs = ComputeFCS16( pContigPacketBuf, ContigPacketLen );

    for( i = 0, tmpfcs = fcs, fcsLen = 0; i < SLOW_IR_FCS_SIZE; tmpfcs >>= 8, i++ )
    {
        UCHAR fcsbyte = tmpfcs & 0x00ff;

        switch( fcsbyte )
        {
			case SLOW_IR_BOF:
			case SLOW_IR_EOF:
			case SLOW_IR_ESC:
				fcsBuf[fcsLen++] = SLOW_IR_ESC;
				fcsBuf[fcsLen++] = fcsbyte ^ SLOW_IR_ESC_COMP;
				break;
			default:
				fcsBuf[fcsLen++] = fcsbyte;
				break;
        }
    }

    /***********************************************/
    /*   Now begin building the IR frame.          */
    /*                                             */
    /*   This is the final format:                 */
    /*                                             */
    /*  BOF  (1)                                   */
    /*  extra BOFs ...                             */
    /*          NdisMediumIrda packet (from NDIS): */
    /*                  Address (1)                */
    /*                  Control (1)                */
    /*          FCS     (2)                        */
    /*  EOF  (1)                                   */
    /*                                             */
    /*  Prepend BOFs (extra BOFs + 1 actual BOF)   */
    /***********************************************/
	numExtraBOFs = ExtraBOFs;
    if( numExtraBOFs > MAX_NUM_EXTRA_BOFS )
    {
        numExtraBOFs = MAX_NUM_EXTRA_BOFS;
    }

    for( i = totalBytes = 0; i < numExtraBOFs; i++ )
    {
        *(SLOW_IR_BOF_TYPE*)(pIrPacketBufFrame + totalBytes) = SLOW_IR_EXTRA_BOF;
        totalBytes += SLOW_IR_EXTRA_BOF_SIZE;
    }

    *(SLOW_IR_BOF_TYPE*)(pIrPacketBufFrame + totalBytes) = SLOW_IR_BOF;
    totalBytes += SLOW_IR_BOF_SIZE;

    /***********************************************/
    /*   Copy the NDIS packet from our contiguous  */
    /*   buffer,       applying       escape-char  */
    /*   transparency.                             */
    /***********************************************/
    for( i = 0; i < ContigPacketLen; i++ )
    {
        nextChar = pContigPacketBuf[i];
        switch( nextChar )
        {
			case SLOW_IR_BOF:
			case SLOW_IR_EOF:
			case SLOW_IR_ESC:
				pIrPacketBufFrame[totalBytes++] = SLOW_IR_ESC;
				pIrPacketBufFrame[totalBytes++] = nextChar ^ SLOW_IR_ESC_COMP;
				break;
			default:
				pIrPacketBufFrame[totalBytes++] = nextChar;
				break;
        }
    }

    /***********************************************/
    /*   Add FCS, EOF.                             */
    /***********************************************/
    NdisMoveMemory( (PVOID)(pIrPacketBufFrame + totalBytes), (PVOID)fcsBuf, fcsLen );
    totalBytes += fcsLen;
    *(SLOW_IR_EOF_TYPE*)(pIrPacketBufFrame + totalBytes) = (UCHAR)SLOW_IR_EOF;
    totalBytes += SLOW_IR_EOF_SIZE;

 	/***********************************************/
    /*   Add in STIr4200 header...                 */
    /***********************************************/
    pFrameHeader->id1     = STIR4200_HEADERID_BYTE1;
    pFrameHeader->id2     = STIR4200_HEADERID_BYTE2;
    pFrameHeader->sizlsb  = LOBYTE(totalBytes);
    pFrameHeader->sizmsb  = HIBYTE(totalBytes);

   *pIrPacketLen = totalBytes + sizeof(STIR4200_FRAME_HEADER);
   return TRUE;
}


/*****************************************************************************
*
*  Function:	Diags_Enable
*
*  Synopsis:	Switches the STIr4200 to diagnostic mode
*
*  Arguments:	pThisDev - pointer to IR device
*	
*  Returns:     NT status code
*
*  Notes:
*
*****************************************************************************/
NTSTATUS
Diags_Enable(
		IN OUT PIR_DEVICE pThisDev
	)
{
	PIRUSB_CONTEXT		pThisContext;
	PLIST_ENTRY			pListEntry;

	//
	// Make sure diags aren't already active
	//
	if( pThisDev->DiagsActive )
	{
        DEBUGMSG(DBG_ERR, (" Diags_Enable diags already active\n"));
		return STATUS_UNSUCCESSFUL;
	}

	//
	// Get a context to switch to the new mode
	//
	pListEntry = ExInterlockedRemoveHeadList( &pThisDev->SendAvailableQueue, &pThisDev->SendLock );

	if( NULL == pListEntry )
    {
        //
		// This must not happen
		//
        DEBUGMSG(DBG_ERR, (" Diags_Enable failed to find a free context struct\n"));
		IRUSB_ASSERT( 0 );
        
		return STATUS_UNSUCCESSFUL;
    }
	
	InterlockedDecrement( &pThisDev->SendAvailableCount );

	pThisContext = CONTAINING_RECORD( pListEntry, IRUSB_CONTEXT, ListEntry );
	pThisContext->ContextType = CONTEXT_DIAGS_ENABLE;
	
	//
	// Disable further interaction with the stack
	//
	InterlockedExchange( &pThisDev->DiagsPendingActivation, TRUE );

	//
	// Queue the context and then wait 
	//
	KeClearEvent( &pThisDev->EventDiags );
	ExInterlockedInsertTailList(
			&pThisDev->SendBuiltQueue,
			&pThisContext->ListEntry,
			&pThisDev->SendLock
		);
	InterlockedIncrement( &pThisDev->SendBuiltCount );

	MyKeWaitForSingleObject( pThisDev, &pThisDev->EventDiags, 0 );

	return pThisDev->IOCTLStatus;
}


/*****************************************************************************
*
*  Function:	Diags_Disable
*
*  Synopsis:	Switches the STIr4200 back to normal mode
*
*  Arguments:	pThisDev - pointer to IR device
*	
*  Returns:     NT status code
*
*  Notes:
*
*****************************************************************************/
NTSTATUS
Diags_Disable(
		IN OUT PIR_DEVICE pThisDev
	)
{
	PRCV_BUFFER pRecBuf;
	PLIST_ENTRY pEntry;
    
	//
	// Make sure diags are active
	//
	if( !pThisDev->DiagsActive )
	{
        DEBUGMSG(DBG_ERR, (" Diags_Disable diags not active\n"));
		return STATUS_UNSUCCESSFUL;
	}

	//
	// Enable interaction with the stack and no queuing of contexts is required
	//
	InterlockedExchange( &pThisDev->DiagsActive, FALSE );
	InterlockedExchange( &pThisDev->DiagsPendingActivation, FALSE );

	//
	// Get rid of all the diagnostic buffers
	//
	while( pEntry=ExInterlockedRemoveHeadList(
			&pThisDev->DiagsReceiveQueue,
			&pThisDev->DiagsReceiveLock )
		)
    {
		pRecBuf = CONTAINING_RECORD( pEntry, RCV_BUFFER, ListEntry );

		InterlockedExchange( &pRecBuf->DataLen, 0 );
		InterlockedExchange( (PULONG)&pRecBuf->BufferState, RCV_STATE_FREE );
    }

	return STATUS_SUCCESS;
}


/*****************************************************************************
*
*  Function:	Diags_ReadRegisters
*
*  Synopsis:	Prepares a context to read the registers
*
*  Arguments:	pThisDev - pointer to IR device
*				pIOCTL - pointer to IOCTL descriptor
*				IOCTLSize - size of the IOCTL buffer
*	
*  Returns:     NT status code
*
*  Notes:
*
*****************************************************************************/
NTSTATUS
Diags_ReadRegisters(
		IN OUT PIR_DEVICE pThisDev,
		OUT PDIAGS_READ_REGISTERS_IOCTL pIOCTL,
		ULONG IOCTLSize
	)
{
	PIRUSB_CONTEXT		pThisContext;
	PLIST_ENTRY			pListEntry;

	//
	// First basic validation
	//
	if( IOCTLSize < sizeof(DIAGS_READ_REGISTERS_IOCTL) )
	{
        DEBUGMSG(DBG_ERR, (" Diags_ReadRegisters invalid output buffer\n"));
		return STATUS_UNSUCCESSFUL;
	}
	
	//
	// Now we get a little more sofisticated
	//
	if( ((pIOCTL->FirstRegister+pIOCTL->NumberRegisters)>(STIR4200_MAX_REG+1)) || 
		((IOCTLSize+1)<(sizeof(DIAGS_READ_REGISTERS_IOCTL)+pIOCTL->NumberRegisters)) )
	{
        DEBUGMSG(DBG_ERR, (" Diags_ReadRegisters invalid output buffer\n"));
		return STATUS_UNSUCCESSFUL;
	}

	pThisDev->pIOCTL = pIOCTL;
	pThisDev->IOCTLStatus = STATUS_UNSUCCESSFUL;
	
	//
	// Get a context to queue
	//
	pListEntry = ExInterlockedRemoveHeadList( &pThisDev->SendAvailableQueue, &pThisDev->SendLock );

	if( NULL == pListEntry )
    {
        //
		// This must not happen
		//
        DEBUGMSG(DBG_ERR, (" Diags_ReadRegisters failed to find a free context struct\n"));
		IRUSB_ASSERT( 0 );
        
		return STATUS_UNSUCCESSFUL;
    }
	
	InterlockedDecrement( &pThisDev->SendAvailableCount );

	pThisContext = CONTAINING_RECORD( pListEntry, IRUSB_CONTEXT, ListEntry );
	pThisContext->ContextType = CONTEXT_DIAGS_READ_REGISTERS;
	
	//
	// Queue the context and then wait 
	//
	KeClearEvent( &pThisDev->EventDiags );
	ExInterlockedInsertTailList(
			&pThisDev->SendBuiltQueue,
			&pThisContext->ListEntry,
			&pThisDev->SendLock
		);
	InterlockedIncrement( &pThisDev->SendBuiltCount );

	MyKeWaitForSingleObject( pThisDev, &pThisDev->EventDiags, 0 );

	return pThisDev->IOCTLStatus;
}


/*****************************************************************************
*
*  Function:	Diags_WriteRegister
*
*  Synopsis:	Prepares a context to write the registers
*
*  Arguments:	pThisDev - pointer to IR device
*				pIOCTL - pointer to IOCTL descriptor
*				IOCTLSize - size of the IOCTL buffer
*	
*  Returns:     NT status code
*
*  Notes:
*
*****************************************************************************/
NTSTATUS
Diags_WriteRegister(
		IN OUT PIR_DEVICE pThisDev,
		OUT PDIAGS_READ_REGISTERS_IOCTL pIOCTL,
		ULONG IOCTLSize
	)
{
	PIRUSB_CONTEXT		pThisContext;
	PLIST_ENTRY			pListEntry;

	//
	// Validation
	//
	if( (IOCTLSize < sizeof(DIAGS_READ_REGISTERS_IOCTL)) ||
		(pIOCTL->FirstRegister>STIR4200_MAX_REG) )
	{
        DEBUGMSG(DBG_ERR, (" Diags_WriteRegister invalid output buffer\n"));
		return STATUS_UNSUCCESSFUL;
	}
	
	pThisDev->pIOCTL = pIOCTL;
	pThisDev->IOCTLStatus = STATUS_UNSUCCESSFUL;
	
	//
	// Get a context to queue
	//
	pListEntry = ExInterlockedRemoveHeadList( &pThisDev->SendAvailableQueue, &pThisDev->SendLock );

	if( NULL == pListEntry )
    {
        //
		// This must not happen
		//
        DEBUGMSG(DBG_ERR, (" Diags_ReadRegisters failed to find a free context struct\n"));
		IRUSB_ASSERT( 0 );
        
		return STATUS_UNSUCCESSFUL;
    }
	
	InterlockedDecrement( &pThisDev->SendAvailableCount );

	pThisContext = CONTAINING_RECORD( pListEntry, IRUSB_CONTEXT, ListEntry );
	pThisContext->ContextType = CONTEXT_DIAGS_WRITE_REGISTER;
	
	//
	// Queue the context and the wait 
	//
	KeClearEvent( &pThisDev->EventDiags );
	ExInterlockedInsertTailList(
			&pThisDev->SendBuiltQueue,
			&pThisContext->ListEntry,
			&pThisDev->SendLock
		);
	InterlockedIncrement( &pThisDev->SendBuiltCount );

	MyKeWaitForSingleObject( pThisDev, &pThisDev->EventDiags, 0 );

	return pThisDev->IOCTLStatus;
}


/*****************************************************************************
*
*  Function:	Diags_PrepareBulk
*
*  Synopsis:	Prepares a context to do a bulk transfer
*
*  Arguments:	pThisDev - pointer to IR device
*				pIOCTL - pointer to IOCTL descriptor
*				IOCTLSize - size of the IOCTL buffer
*				DirectionOut - TRUE if bulk-out, FALSE if bulk-in
*	
*  Returns:     NT status code
*
*  Notes:
*
*****************************************************************************/
NTSTATUS
Diags_PrepareBulk(
		IN OUT PIR_DEVICE pThisDev,
		OUT PDIAGS_BULK_IOCTL pIOCTL,
		ULONG IOCTLSize,
		BOOLEAN DirectionOut
	)
{
	PIRUSB_CONTEXT		pThisContext;
	PLIST_ENTRY			pListEntry;

	//
	// First basic validation
	//
	if( IOCTLSize < sizeof(DIAGS_BULK_IOCTL) )
	{
        DEBUGMSG(DBG_ERR, (" Diags_PrepareBulk invalid input buffer\n"));
		return STATUS_UNSUCCESSFUL;
	}
	
	//
	// Now we get a little more sofisticated
	//
	if( IOCTLSize < (sizeof(DIAGS_BULK_IOCTL)+pIOCTL->DataSize-1) )
	{
        DEBUGMSG(DBG_ERR, (" Diags_PrepareBulk invalid output buffer\n"));
		return STATUS_UNSUCCESSFUL;
	}

	pThisDev->pIOCTL = pIOCTL;
	pThisDev->IOCTLStatus = STATUS_UNSUCCESSFUL;
	
	//
	// Get a context to queue
	//
	pListEntry = ExInterlockedRemoveHeadList( &pThisDev->SendAvailableQueue, &pThisDev->SendLock );

	if( NULL == pListEntry )
    {
        //
		// This must not happen
		//
        DEBUGMSG(DBG_ERR, (" Diags_PrepareBulk failed to find a free context struct\n"));
		IRUSB_ASSERT( 0 );
        
		return STATUS_UNSUCCESSFUL;
    }
	
	InterlockedDecrement( &pThisDev->SendAvailableCount );

	pThisContext = CONTAINING_RECORD( pListEntry, IRUSB_CONTEXT, ListEntry );
	if( DirectionOut )
		pThisContext->ContextType = CONTEXT_DIAGS_BULK_OUT;
	else
		pThisContext->ContextType = CONTEXT_DIAGS_BULK_IN;

	//
	// Queue the context and then wait 
	//
	KeClearEvent( &pThisDev->EventDiags );
	ExInterlockedInsertTailList(
			&pThisDev->SendBuiltQueue,
			&pThisContext->ListEntry,
			&pThisDev->SendLock
		);
	InterlockedIncrement( &pThisDev->SendBuiltCount );

	MyKeWaitForSingleObject( pThisDev, &pThisDev->EventDiags, 0 );

	return pThisDev->IOCTLStatus;
}


/*****************************************************************************
*
*  Function:	Diags_PrepareSend
*
*  Synopsis:	Prepares a diagnostic send
*
*  Arguments:	pThisDev - pointer to IR device
*				pIOCTL - pointer to IOCTL descriptor
*				IOCTLSize - size of the IOCTL buffer
*	
*  Returns:		None
*
*  Notes:
*
*****************************************************************************/
NTSTATUS
Diags_PrepareSend(
		IN OUT PIR_DEVICE pThisDev,
		OUT PDIAGS_SEND_IOCTL pIOCTL,
		ULONG IOCTLSize
	)
{
	PIRUSB_CONTEXT		pThisContext;
	PLIST_ENTRY			pListEntry;
	ULONG				Size = sizeof(DIAGS_SEND_IOCTL)+pIOCTL->DataSize-1;

	//
	// First basic validation
	//
	if( IOCTLSize < sizeof(DIAGS_SEND_IOCTL) )
	{
        DEBUGMSG(DBG_ERR, (" Diags_PrepareBulk invalid input buffer\n"));
		return STATUS_UNSUCCESSFUL;
	}
	
	//
	// Now we get a little more sofisticated
	//
	if( IOCTLSize < (sizeof(DIAGS_SEND_IOCTL)+pIOCTL->DataSize-1) )
	{
        DEBUGMSG(DBG_ERR, (" Diags_PrepareSend invalid output buffer\n"));
		return STATUS_UNSUCCESSFUL;
	}

	pThisDev->pIOCTL = pIOCTL;
	pThisDev->IOCTLStatus = STATUS_UNSUCCESSFUL;
	
	//
	// Get a context to queue
	//
	pListEntry = ExInterlockedRemoveHeadList( &pThisDev->SendAvailableQueue, &pThisDev->SendLock );

	if( NULL == pListEntry )
    {
        //
		// This must not happen
		//
        DEBUGMSG(DBG_ERR, (" Diags_PrepareSend failed to find a free context struct\n"));
		IRUSB_ASSERT( 0 );
        
		return STATUS_UNSUCCESSFUL;
    }
	
	InterlockedDecrement( &pThisDev->SendAvailableCount );

	pThisContext = CONTAINING_RECORD( pListEntry, IRUSB_CONTEXT, ListEntry );
	pThisContext->ContextType = CONTEXT_DIAGS_SEND;

	//
	// Queue the context and then wait 
	//
	KeClearEvent( &pThisDev->EventDiags );
	ExInterlockedInsertTailList(
			&pThisDev->SendBuiltQueue,
			&pThisContext->ListEntry,
			&pThisDev->SendLock
		);
	InterlockedIncrement( &pThisDev->SendBuiltCount );

	MyKeWaitForSingleObject( pThisDev, &pThisDev->EventDiags, 0 );

	return pThisDev->IOCTLStatus;
}


/*****************************************************************************
*
*  Function:	Diags_Receive
*
*  Synopsis:	Diagnostic receive
*
*  Arguments:	pThisDev - pointer to IR device
*				pIOCTL - pointer to IOCTL descriptor
*				IOCTLSize - size of the IOCTL buffer
*	
*  Returns:		None
*
*  Notes:
*
*****************************************************************************/
NTSTATUS
Diags_Receive(
		IN OUT PIR_DEVICE pThisDev,
		OUT PDIAGS_RECEIVE_IOCTL pIOCTL,
		ULONG IOCTLSize
	)
{
	PLIST_ENTRY			pListEntry;
	PRCV_BUFFER			pRecBuf;

	//
	// First basic validation
	//
	if( IOCTLSize < sizeof(DIAGS_RECEIVE_IOCTL) )
	{
        DEBUGMSG(DBG_ERR, (" Diags_Receive invalid input buffer\n"));
		return STATUS_UNSUCCESSFUL;
	}
	
	//
	// Get a received packet
	//
	pListEntry = ExInterlockedRemoveHeadList( &pThisDev->DiagsReceiveQueue, &pThisDev->DiagsReceiveLock );

	if( NULL == pListEntry )
    {
        //
		// No packet available
		//
		return STATUS_UNSUCCESSFUL;
    }
	
	pRecBuf = CONTAINING_RECORD( pListEntry, RCV_BUFFER, ListEntry );

	//
	// Now we get a little more sofisticated
	//
	if( IOCTLSize < (sizeof(DIAGS_RECEIVE_IOCTL)+pIOCTL->DataSize-1) )
	{
        DEBUGMSG(DBG_ERR, (" Diags_Receive invalid output buffer\n"));
		return STATUS_UNSUCCESSFUL;
	}

	//
	// Fix MS Security bug #534771
	//
	if (pIOCTL->DataSize < pRecBuf->DataLen)
	{
        DEBUGMSG(DBG_ERR, (" Diags_Receive output buffer too small\n"));
		return STATUS_UNSUCCESSFUL;
	}

	//
	// Copy the data
	//
	NdisMoveMemory( pIOCTL->pData, pRecBuf->pDataBuf, pRecBuf->DataLen );
	pIOCTL->DataSize = (USHORT)pRecBuf->DataLen;
	pThisDev->pIOCTL = pIOCTL;
	InterlockedExchange( &pRecBuf->DataLen, 0 );
	InterlockedExchange( (PULONG)&pRecBuf->BufferState, RCV_STATE_FREE );

	return STATUS_SUCCESS;
}


/*****************************************************************************
*
*  Function:	Diags_GetSpeed
*
*  Synopsis:	Retrieves the current speed
*
*  Arguments:	pThisDev - pointer to IR device
*				pIOCTL - pointer to IOCTL descriptor
*				IOCTLSize - size of the IOCTL buffer
*	
*  Returns:		None
*
*  Notes:
*
*****************************************************************************/
NTSTATUS
Diags_GetSpeed(
		IN OUT PIR_DEVICE pThisDev,
		OUT PDIAGS_SPEED_IOCTL pIOCTL,
		ULONG IOCTLSize
	)
{
	//
	// First basic validation
	//
	if( IOCTLSize < sizeof(DIAGS_SPEED_IOCTL) )
	{
        DEBUGMSG(DBG_ERR, (" Diags_GetSpeed invalid input buffer\n"));
		return STATUS_UNSUCCESSFUL;
	}

	pIOCTL->Speed = pThisDev->currentSpeed;

	return STATUS_SUCCESS;
}


/*****************************************************************************
*
*  Function:	Diags_SetSpeed
*
*  Synopsis:	Sets a new speed in diagnostic mode
*
*  Arguments:	pThisDev - pointer to IR device
*				pIOCTL - pointer to IOCTL descriptor
*				IOCTLSize - size of the IOCTL buffer
*	
*  Returns:		None
*
*  Notes:
*
*****************************************************************************/
NTSTATUS
Diags_SetSpeed(
		IN OUT PIR_DEVICE pThisDev,
		OUT PDIAGS_SPEED_IOCTL pIOCTL,
		ULONG IOCTLSize
	)
{
	// MS Security fix bug #535716
	NDIS_STATUS status = STATUS_UNSUCCESSFUL;
	USHORT i;
	
	//
	// First basic validation
	//
	if( IOCTLSize < sizeof(DIAGS_SPEED_IOCTL) )
	{
        DEBUGMSG(DBG_ERR, (" Diags_SetSpeed invalid input buffer\n"));
		return STATUS_UNSUCCESSFUL;
	}

    if( pThisDev->currentSpeed == pIOCTL->Speed )
    {
        //
        // We are already set to the requested speed.
        //
		return STATUS_SUCCESS;
    }

    DEBUGMSG(DBG_ERR, (" Diags_SetSpeed(OID_IRDA_LINK_SPEED, 0x%x, decimal %d)\n",pIOCTL->Speed, pIOCTL->Speed));

    for( i = 0; i < NUM_BAUDRATES; i++ )
    {
        if( supportedBaudRateTable[i].BitsPerSec == pIOCTL->Speed )
        {
            //
            // Keep a pointer to the link speed which has
            // been requested. 
            //
            pThisDev->linkSpeedInfo = &supportedBaudRateTable[i]; 

            status = NDIS_STATUS_PENDING; 
            break; //for
        }
    }

    //
	// Don't set if there is an error
	//
	if( NDIS_STATUS_PENDING != status  )
    {
        DEBUGMSG(DBG_ERR, (" Invalid link speed\n"));
 		return STATUS_UNSUCCESSFUL;
	} 

	//
	// Set the new speed
	//
	IrUsb_PrepareSetSpeed( pThisDev );
	
	while( pThisDev->linkSpeedInfo->BitsPerSec != pThisDev->currentSpeed )
	{
		NdisMSleep( 50000 );
	}

	return STATUS_SUCCESS;
}


/*****************************************************************************
*
*  Function:	Diags_CompleteEnable
*
*  Synopsis:	Completes the enabling of the diagnostic state
*
*  Arguments:	pThisDev - pointer to IR device
*				pContext - pinter to the operation context
*	
*  Returns:		None
*
*  Notes:
*
*****************************************************************************/
VOID
Diags_CompleteEnable(
		IN OUT PIR_DEVICE pThisDev,
		IN PVOID pContext
	)
{
	PIRUSB_CONTEXT pThisContext = pContext;

	//
	// Really enable diags
	//
	InterlockedExchange( &pThisDev->DiagsActive, TRUE );

	//
	// Return the context
	//
	ExInterlockedInsertTailList(
		&pThisDev->SendAvailableQueue,
		&pThisContext->ListEntry,
		&pThisDev->SendLock
	);
	InterlockedIncrement( &pThisDev->SendAvailableCount );

	//
	// Signal
	//
	KeSetEvent( &pThisDev->EventDiags, 0, FALSE );  //signal we're done
}


/*****************************************************************************
*
*  Function:	Diags_CompleteReadRegisters
*
*  Synopsis:	Reads the registers and returns the value
*
*  Arguments:	pThisDev - pointer to IR device
*				pContext - pinter to the operation context
*	
*  Returns:		NTSTATUS
*
*  Notes:
*
*****************************************************************************/
NTSTATUS
Diags_CompleteReadRegisters(
		IN OUT PIR_DEVICE pThisDev,
		IN PVOID pContext
	)
{
	PDIAGS_READ_REGISTERS_IOCTL pIOCTL = pThisDev->pIOCTL;
	PIRUSB_CONTEXT pThisContext = pContext;

	//
	// Read the data
	//
	pThisDev->IOCTLStatus = St4200ReadRegisters( pThisDev, pIOCTL->FirstRegister, pIOCTL->NumberRegisters );
	if( pThisDev->IOCTLStatus == STATUS_SUCCESS )
	{
		NdisMoveMemory( 
				&pIOCTL->pRegisterBuffer, 
				&pThisDev->StIrTranceiver.FifoDataReg+pIOCTL->FirstRegister,
				pIOCTL->NumberRegisters
			);
	}

	//
	// Return the context
	//
	ExInterlockedInsertTailList(
		&pThisDev->SendAvailableQueue,
		&pThisContext->ListEntry,
		&pThisDev->SendLock
	);
	InterlockedIncrement( &pThisDev->SendAvailableCount );

	//
	// Signal
	//
	KeSetEvent( &pThisDev->EventDiags, 0, FALSE );  //signal we're done

	return pThisDev->IOCTLStatus;
}


/*****************************************************************************
*
*  Function:	Diags_CompleteWriteRegister
*
*  Synopsis:	Reads the registers and returns the value
*
*  Arguments:	pThisDev - pointer to IR device
*				pContext - pinter to the operation context
*	
*  Returns:		NTSTATUS
*
*  Notes:
*
*****************************************************************************/
NTSTATUS
Diags_CompleteWriteRegister(
		IN OUT PIR_DEVICE pThisDev,
		IN PVOID pContext
	)
{
	PDIAGS_READ_REGISTERS_IOCTL pIOCTL = pThisDev->pIOCTL;
	PIRUSB_CONTEXT pThisContext = pContext;

	//
	// Copy the new register value
	//
	NdisMoveMemory( 
			&pThisDev->StIrTranceiver.FifoDataReg+pIOCTL->FirstRegister,
			&pIOCTL->pRegisterBuffer, 
			1
		);

	//
	// Write to the device
	//
	pThisDev->IOCTLStatus = St4200WriteRegister( pThisDev, pIOCTL->FirstRegister );

	//
	// Return the context
	//
	ExInterlockedInsertTailList(
		&pThisDev->SendAvailableQueue,
		&pThisContext->ListEntry,
		&pThisDev->SendLock
	);
	InterlockedIncrement( &pThisDev->SendAvailableCount );

	//
	// Signal
	//
	KeSetEvent( &pThisDev->EventDiags, 0, FALSE );  //signal we're done

	return pThisDev->IOCTLStatus;
}

/*****************************************************************************
*
*  Function:	Diags_Bulk
*
*  Synopsis:	Executes a diagnostic bulk transfer
*
*  Arguments:	pThisDev - pointer to IR device
*				pContext - pinter to the operation context
*				DirectionOut - TRUE if bulk-out, FALSE if bulk-in
*	
*  Returns:		NTSTATUS
*
*  Notes:
*
*****************************************************************************/
NTSTATUS
Diags_Bulk(
		IN OUT PIR_DEVICE pThisDev,
		IN PVOID pContext,
		BOOLEAN DirectionOut
	)
{
	PDIAGS_BULK_IOCTL	pIOCTL = pThisDev->pIOCTL;
	PIRUSB_CONTEXT		pThisContext = pContext;
	NTSTATUS			status = STATUS_SUCCESS;
    PIRP                pIrp;
	PURB				pUrb = NULL;
    PDEVICE_OBJECT		pUrbTargetDev;
    PIO_STACK_LOCATION	pNextStack;
	KIRQL				OldIrql;

    IRUSB_ASSERT( KeGetCurrentIrql() == PASSIVE_LEVEL );

	IRUSB_ASSERT( NULL != pThisContext );

	//
	// Stop if a halt/reset is going on
	//
	if( pThisDev->fPendingWriteClearStall || pThisDev->fPendingHalt || 
		pThisDev->fPendingReset || pThisDev->fPendingClearTotalStall ) 
	{
        DEBUGMSG(DBG_ERR, (" Diags_Bulk abort due to pending reset or halt\n"));
		goto done;
	}
		
	//
	// MS Security recommendation - allocate a new urb.
	//
	pThisContext->UrbLen = sizeof( struct _URB_BULK_OR_INTERRUPT_TRANSFER );
	pThisContext->pUrb = MyUrbAlloc(pThisContext->UrbLen);
	if (pThisContext->pUrb == NULL)
	{
        DEBUGMSG(DBG_ERR, (" Diags_Bulk abort due to urb alloc failure\n"));
		goto done;
	}
	pUrb = pThisContext->pUrb;

	//
	// Save the effective length
	//
	pThisDev->BufLen = pIOCTL->DataSize;

	//
    // Now that we have created the urb, we will send a
    // request to the USB device object.
    //
    pUrbTargetDev = pThisDev->pUsbDevObj;

	//
	// make an irp sending to usbhub
	//
	pIrp = IoAllocateIrp( (CCHAR)(pThisDev->pUsbDevObj->StackSize + 1), FALSE );

    if( NULL == pIrp )
    {
        DEBUGMSG(DBG_ERR, (" Diags_Bulk failed to alloc IRP\n"));
		MyUrbFree(pThisContext->pUrb, pThisContext->UrbLen);
        goto done;
    }

    pIrp->IoStatus.Status = STATUS_PENDING;
    pIrp->IoStatus.Information = 0;

	pThisContext->pIrp = pIrp;

	//
	// Build our URB for USBD
	//
    pUrb->UrbBulkOrInterruptTransfer.Hdr.Length = (USHORT)sizeof( struct _URB_BULK_OR_INTERRUPT_TRANSFER );
    pUrb->UrbBulkOrInterruptTransfer.Hdr.Function = URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER;
	if( DirectionOut )
	{
		pUrb->UrbBulkOrInterruptTransfer.TransferFlags = USBD_TRANSFER_DIRECTION_OUT ;
		pUrb->UrbBulkOrInterruptTransfer.PipeHandle = pThisDev->BulkOutPipeHandle;
	}
	else
	{
		pUrb->UrbBulkOrInterruptTransfer.TransferFlags = USBD_TRANSFER_DIRECTION_IN ;
 		pUrb->UrbBulkOrInterruptTransfer.PipeHandle = pThisDev->BulkInPipeHandle;
   }
	// short packet is not treated as an error.
    pUrb->UrbBulkOrInterruptTransfer.TransferFlags |= USBD_SHORT_TRANSFER_OK;
    pUrb->UrbBulkOrInterruptTransfer.UrbLink = NULL;
    pUrb->UrbBulkOrInterruptTransfer.TransferBufferMDL = NULL;
    pUrb->UrbBulkOrInterruptTransfer.TransferBuffer = pIOCTL->pData;
    pUrb->UrbBulkOrInterruptTransfer.TransferBufferLength = (int)pIOCTL->DataSize;

    //
    // Call the class driver to perform the operation.
	//
    pNextStack = IoGetNextIrpStackLocation( pIrp );

    IRUSB_ASSERT( pNextStack != NULL );

    //
    // pass the URB to the USB driver stack
    //
	pNextStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
	pNextStack->Parameters.Others.Argument1 = pUrb;
	pNextStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_INTERNAL_USB_SUBMIT_URB;
	
    IoSetCompletionRoutine(
			pIrp,							// irp to use
			Diags_CompleteIrp,				// routine to call when irp is done
			DEV_TO_CONTEXT(pThisContext),	// context to pass routine
			TRUE,							// call on success
			TRUE,							// call on error
			TRUE							// call on cancel
		);

#ifdef SERIALIZE
	KeClearEvent( &pThisDev->EventSyncUrb );
#endif
	
	//
    // Call IoCallDriver to send the irp to the usb port.
    //
	ExInterlockedInsertTailList(
			&pThisDev->SendPendingQueue,
			&pThisContext->ListEntry,
			&pThisDev->SendLock
		);
	InterlockedIncrement( &pThisDev->SendPendingCount );
	status = MyIoCallDriver( pThisDev, pUrbTargetDev, pIrp );

    //
    // The USB driver should always return STATUS_PENDING when
    // it receives a write irp
    //
    IRUSB_ASSERT( status == STATUS_PENDING );

	status = MyKeWaitForSingleObject( pThisDev, &pThisDev->EventSyncUrb, 0 );

	if( status == STATUS_TIMEOUT ) 
	{
		DEBUGMSG( DBG_ERR,(" Diags_Bulk() TIMED OUT! return from IoCallDriver USBD %x\n", status));
		// MS Security recommendation - cannot cancel IRP.
		IRUSB_ASSERT(0);
	}


done:

	//
	// Return the context
	//
	KeAcquireSpinLock( &pThisDev->SendLock, &OldIrql );
	RemoveEntryList( &pThisContext->ListEntry );
	KeReleaseSpinLock( &pThisDev->SendLock, OldIrql );
	InterlockedDecrement( &pThisDev->SendPendingCount );
	ExInterlockedInsertTailList(
			&pThisDev->SendAvailableQueue,
			&pThisContext->ListEntry,
			&pThisDev->SendLock
		);
	InterlockedIncrement( &pThisDev->SendAvailableCount );

	//
	// Signal
	//
	KeSetEvent( &pThisDev->EventDiags, 0, FALSE );  //signal we're done

	return status;
}


/*****************************************************************************
*
*  Function:	Diags_Send
*
*  Synopsis:	Sends a packet through the diagnostic path
*
*  Arguments:	pThisDev - pointer to IR device
*				pContext - pinter to the operation context
*	
*  Returns:		NTSTATUS
*
*  Notes:
*
*****************************************************************************/
NTSTATUS
Diags_Send(
		IN OUT PIR_DEVICE pThisDev,
		IN PVOID pContext
	)
{
	PDIAGS_SEND_IOCTL	pIOCTL = pThisDev->pIOCTL;
	PIRUSB_CONTEXT		pThisContext = pContext;
	NTSTATUS			status = STATUS_SUCCESS;
    PIRP                pIrp;
	PURB				pUrb = NULL;
    PDEVICE_OBJECT		pUrbTargetDev;
    PIO_STACK_LOCATION	pNextStack;
	BOOLEAN				fConvertedPacket;
	KIRQL				OldIrql;
	ULONG				BytesToWrite;

    IRUSB_ASSERT( KeGetCurrentIrql() == PASSIVE_LEVEL );

	IRUSB_ASSERT( NULL != pThisContext );

	//
	// Stop if a halt/reset is going on
	//
	if( pThisDev->fPendingWriteClearStall || pThisDev->fPendingHalt || 
		pThisDev->fPendingReset || pThisDev->fPendingClearTotalStall ) 
	{
        DEBUGMSG(DBG_ERR, (" Diags_Send abort due to pending reset or halt\n"));
		goto done;
	}
		
	DEBUGMSG(DBG_ERR, (" Diags_Send() packet size: %d\n", pIOCTL->DataSize));

	//
	// Convert the packet to an ir frame and copy into our buffer
	// and send the irp.
	//
	if( pThisDev->currentSpeed<=MAX_SIR_SPEED )
	{
		fConvertedPacket = Diags_BufferToSirPacket(
				pThisDev,
				(PUCHAR)pThisDev->pBuffer,
				MAX_IRDA_DATA_SIZE,
				pIOCTL->pData,
				pIOCTL->DataSize,
				pIOCTL->ExtraBOFs,
				&BytesToWrite
			);
	}
	else if( pThisDev->currentSpeed<=MAX_MIR_SPEED )
	{
		fConvertedPacket = Diags_BufferToFirPacket(
				pThisDev,
				(PUCHAR)pThisDev->pBuffer,
				MAX_IRDA_DATA_SIZE,
				pIOCTL->pData,
				pIOCTL->DataSize,
				&BytesToWrite
			);
	}
	else
	{
		fConvertedPacket = Diags_BufferToFirPacket(
				pThisDev,
				(PUCHAR)pThisDev->pBuffer,
				MAX_IRDA_DATA_SIZE,
				pIOCTL->pData,
				pIOCTL->DataSize,
				&BytesToWrite
			);
	}
	
	if( fConvertedPacket == FALSE )
	{
		DEBUGMSG(DBG_ERR, (" Diags_Send() NdisToIrPacket failed. Couldn't convert packet!\n"));
		goto done;
	}

	//
	// Always force turnaround
	//
	NdisMSleep( pThisDev->dongleCaps.turnAroundTime_usec );
	
	//
	// MS Security recommendation - allocate a new urb.
	//
	pThisContext->UrbLen = sizeof( struct _URB_BULK_OR_INTERRUPT_TRANSFER );
	pThisContext->pUrb = MyUrbAlloc(pThisContext->UrbLen);
	if (pThisContext->pUrb == NULL)
	{
        DEBUGMSG(DBG_ERR, (" Diags_Send abort due to urb alloc failure\n"));
		goto done;
	}
	pUrb = pThisContext->pUrb;

	//
    // Now that we have created the urb, we will send a
    // request to the USB device object.
    //
    pUrbTargetDev = pThisDev->pUsbDevObj;

	//
	// make an irp sending to usbhub
	//
	pIrp = IoAllocateIrp( (CCHAR)(pThisDev->pUsbDevObj->StackSize + 1), FALSE );

    if( NULL == pIrp )
    {
        DEBUGMSG(DBG_ERR, (" Diags_Send failed to alloc IRP\n"));
		MyUrbFree(pThisContext->pUrb, pThisContext->UrbLen);
        goto done;
    }

    pIrp->IoStatus.Status = STATUS_PENDING;
    pIrp->IoStatus.Information = 0;

	pThisContext->pIrp = pIrp;

	//
	// Build our URB for USBD
	//
    pUrb->UrbBulkOrInterruptTransfer.Hdr.Length = (USHORT)sizeof( struct _URB_BULK_OR_INTERRUPT_TRANSFER );
    pUrb->UrbBulkOrInterruptTransfer.Hdr.Function = URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER;
    pUrb->UrbBulkOrInterruptTransfer.PipeHandle = pThisDev->BulkOutPipeHandle;
    pUrb->UrbBulkOrInterruptTransfer.TransferFlags = USBD_TRANSFER_DIRECTION_OUT ;
    // short packet is not treated as an error.
    pUrb->UrbBulkOrInterruptTransfer.TransferFlags |= USBD_SHORT_TRANSFER_OK;
    pUrb->UrbBulkOrInterruptTransfer.UrbLink = NULL;
    pUrb->UrbBulkOrInterruptTransfer.TransferBufferMDL = NULL;
    pUrb->UrbBulkOrInterruptTransfer.TransferBuffer = pThisDev->pBuffer;
    pUrb->UrbBulkOrInterruptTransfer.TransferBufferLength = (int)BytesToWrite;

    //
    // Call the class driver to perform the operation.
	//
    pNextStack = IoGetNextIrpStackLocation( pIrp );

    IRUSB_ASSERT( pNextStack != NULL );

    //
    // pass the URB to the USB driver stack
    //
	pNextStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
	pNextStack->Parameters.Others.Argument1 = pUrb;
	pNextStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_INTERNAL_USB_SUBMIT_URB;
	
    IoSetCompletionRoutine(
			pIrp,							// irp to use
			Diags_CompleteIrp,				// routine to call when irp is done
			DEV_TO_CONTEXT(pThisContext),	// context to pass routine
			TRUE,							// call on success
			TRUE,							// call on error
			TRUE							// call on cancel
		);

#ifdef SERIALIZE
	KeClearEvent( &pThisDev->EventSyncUrb );
#endif
	
	//
    // Call IoCallDriver to send the irp to the usb port.
    //
	ExInterlockedInsertTailList(
			&pThisDev->SendPendingQueue,
			&pThisContext->ListEntry,
			&pThisDev->SendLock
		);
	InterlockedIncrement( &pThisDev->SendPendingCount );
	status = MyIoCallDriver( pThisDev, pUrbTargetDev, pIrp );

    //
    // The USB driver should always return STATUS_PENDING when
    // it receives a write irp
    //
    IRUSB_ASSERT( status == STATUS_PENDING );

	status = MyKeWaitForSingleObject( pThisDev, &pThisDev->EventSyncUrb, 0 );

	if( status == STATUS_TIMEOUT ) 
	{
		DEBUGMSG( DBG_ERR,(" Diags_Send() TIMED OUT! return from IoCallDriver USBD %x\n", status));
		// MS Security recommendation - cannot cancel IRP.
		IRUSB_ASSERT(0);
	}

done:
	//
	// Return the context
	//
	KeAcquireSpinLock( &pThisDev->SendLock, &OldIrql );
	RemoveEntryList( &pThisContext->ListEntry );
	KeReleaseSpinLock( &pThisDev->SendLock, OldIrql );
	InterlockedDecrement( &pThisDev->SendPendingCount );
	ExInterlockedInsertTailList(
			&pThisDev->SendAvailableQueue,
			&pThisContext->ListEntry,
			&pThisDev->SendLock
		);
	InterlockedIncrement( &pThisDev->SendAvailableCount );

	//
	// Signal
	//
	KeSetEvent( &pThisDev->EventDiags, 0, FALSE );  //signal we're done

	return status;
}

/*****************************************************************************
*
*  Function:   Diags_CompleteIrp
*
*  Synopsis:   Completes a USB operation
*
*  Arguments:  pUsbDevObj - pointer to the USB device object which
*                           completed the irp
*              pIrp       - the irp which was completed by the
*                           device object
*              Context    - the context given to IoSetCompletionRoutine
*                           before calling IoCallDriver on the irp
*                           The Context is a pointer to the ir device object.
*
*  Returns:    STATUS_MORE_PROCESSING_REQUIRED - allows the completion routine
*              (IofCompleteRequest) to stop working on the irp.
*
*****************************************************************************/
NTSTATUS
Diags_CompleteIrp(
		IN PDEVICE_OBJECT pUsbDevObj,
		IN PIRP           pIrp,
		IN PVOID          Context
	)
{
    PIR_DEVICE          pThisDev;
    NTSTATUS            status;
	PIRUSB_CONTEXT		pThisContext = (PIRUSB_CONTEXT)Context;
	PIRP				pContextIrp;
	PURB                pContextUrb;
	PDIAGS_BULK_IOCTL	pIOCTL;

    //
    // The context given to IoSetCompletionRoutine is an IRUSB_CONTEXT struct
    //
	IRUSB_ASSERT( NULL != pThisContext );				// we better have a non NULL buffer

    pThisDev = pThisContext->pThisDev;

	IRUSB_ASSERT( NULL != pThisDev );	

	pContextIrp = pThisContext->pIrp;
	pContextUrb = pThisContext->pUrb;
	pIOCTL = pThisDev->pIOCTL;

	//
	// Perform various IRP, URB, and buffer 'sanity checks'
	//
    IRUSB_ASSERT( pContextIrp == pIrp );				// check we're not a bogus IRP
	IRUSB_ASSERT( pContextUrb != NULL );

    status = pIrp->IoStatus.Status;
	pThisDev->IOCTLStatus = status;

	//
	// we should have failed, succeeded, or cancelled, but NOT be pending
	//
	IRUSB_ASSERT( STATUS_PENDING != status );

    //
    // IoCallDriver has been called on this Irp;
    // Set the length based on the TransferBufferLength
    // value in the URB
    //
    pIrp->IoStatus.Information = pContextUrb->UrbBulkOrInterruptTransfer.TransferBufferLength;
	pIOCTL->DataSize = (USHORT)pIrp->IoStatus.Information;

    //
    // Free the IRP.
    //
    IoFreeIrp( pIrp );
	InterlockedIncrement( (PLONG)&pThisDev->NumWrites );

	IrUsb_DecIoCount( pThisDev ); // we will track count of pending irps

	// Free the URB.
	MyUrbFree(pThisContext->pUrb, pThisContext->UrbLen);
	pThisContext->pUrb = NULL;

#ifdef SERIALIZE
	KeSetEvent( &pThisDev->EventSyncUrb, 0, FALSE );  //signal we're done
#endif
    return STATUS_MORE_PROCESSING_REQUIRED;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\net\irda\sigmatel\sys\ircommon.h ===
/**************************************************************************************************************************
 *  IRCOMMON.H SigmaTel STIR4200 common USB/IR definitions
 **************************************************************************************************************************
 *  (C) Unpublished Copyright of Sigmatel, Inc. All Rights Reserved.
 *
 *
 *		Created: 04/06/2000 
 *			Version 0.9
 *		Edited: 04/24/2000 
 *			Version 0.91
 *		Edited: 04/27/2000 
 *			Version 0.92
 *		Edited: 05/03/2000 
 *			Version 0.93
 *		Edited: 05/12/2000 
 *			Version 0.94
 *		Edited: 05/19/2000 
 *			Version 0.95
 *		Edited: 07/27/2000 
 *			Version 1.01
 *		Edited: 09/16/2000 
 *			Version 1.03
 *		Edited: 09/25/2000 
 *			Version 1.10
 *		Edited: 11/09/2000 
 *			Version 1.12
 *		Edited: 02/20/2001
 *			Version 1.15
 *
 **************************************************************************************************************************/

#ifndef _IRCOM_H
#define _IRCOM_H
 
#include "stir4200.h"

// 
// This is for use by check-for-hang handler and is just a reasonable guess;
// Total # of USBD control errors, read aerrors and write errors;
// Used by check-for-hang handler to decide if we need a reset
//
#define IRUSB_100ns_PER_ms                    10000
#define IRUSB_100ns_PER_us                    10
#define IRUSB_ms_PER_SEC                      1000
#define IRUSB_100ns_PER_SEC                   ( IRUSB_100ns_PER_ms * IRUSB_ms_PER_SEC )

#define MAX_QUERY_TIME_100ns             ( 8 * IRUSB_100ns_PER_SEC )        //8 sec
#define MAX_SET_TIME_100ns               MAX_QUERY_TIME_100ns
#define MAX_SEND_TIME_100ns             ( 20 * IRUSB_100ns_PER_SEC )        //20 sec

#define MAX_TURNAROUND_usec     10000

#define DEFAULT_TURNAROUND_usec 1000

//
// Customer data area size.
// Big enough for 2 byte header (7e7e) + one byte count + 255 bytes data.
// Header bytes are not sent back to app.
//
#define STIR4200_CUST_DATA_SIZE	(2+256)

#define MIN(a,b) (((a) <= (b)) ? (a) : (b))
#define MAX(a,b) (((a) >= (b)) ? (a) : (b))

//
//  A receive buffer is either FREE (not holding anything) FULL
// (holding undelivered data) or PENDING (holding data delivered
// asynchronously)
//
typedef enum  
{
    RCV_STATE_FREE,
    RCV_STATE_FULL,
    RCV_STATE_PENDING
} RCV_BUFFER_STATE, FIFO_BUFFER_STATE;

//
// Structure to keep track of receive packets and buffers to indicate
// receive data to the protocol.
//
typedef struct
{
    PVOID				pPacket;
    UINT				DataLen;
    PUCHAR				pDataBuf;
	PVOID    			pThisDev;
    ULONG				fInRcvDpc;
    RCV_BUFFER_STATE	BufferState;
#if defined(DIAGS)
	LIST_ENTRY			ListEntry;			// This will be used to do the diags queueing
#endif
#if defined(WORKAROUND_MISSING_C1)
	BOOLEAN				MissingC1Detected;
	BOOLEAN				MissingC1Possible;
#endif
} RCV_BUFFER, *PRCV_BUFFER;

//
// Structure to read data from the FIFO
//
typedef struct
{
    UINT				DataLen;
    PUCHAR				pDataBuf;
	PVOID    			pThisDev;
	PVOID				pIrp;
	PURB				pUrb;				// urb allocated by irp send routine, deallocated
	UINT				UrbLen;				//   by irp completion handler
    FIFO_BUFFER_STATE	BufferState;
} FIFO_BUFFER, *PFIFO_BUFFER;

//
// All different sizes for data
//
#define IRDA_ADDRESS_FIELD_SIZE				1
#define IRDA_CONTROL_FIELD_SIZE				1
#define IRDA_A_C_TOTAL_SIZE					( IRDA_ADDRESS_FIELD_SIZE + IRDA_CONTROL_FIELD_SIZE )

#define USB_IRDA_TOTAL_NON_DATA_SIZE		( IRDA_ADDRESS_FIELD_SIZE +  IRDA_CONTROL_FIELD_SIZE )
#define IRDA_MAX_DATAONLY_SIZE				2048
#define MAX_TOTAL_SIZE_WITH_ALL_HEADERS		( IRDA_MAX_DATAONLY_SIZE + USB_IRDA_TOTAL_NON_DATA_SIZE )

#define MAX_NUM_EXTRA_BOFS					48

// Fix for MS Security Bug #533267
#define MAX_POSSIBLE_IR_PACKET_SIZE_FOR_DATA(dataLen) (							\
        (dataLen) * 2 + (MAX_NUM_EXTRA_BOFS + 1) *								\
        SLOW_IR_BOF_SIZE + IRDA_ADDRESS_FIELD_SIZE + IRDA_CONTROL_FIELD_SIZE +	\
        (2 * FAST_IR_FCS_SIZE) + (2 * SLOW_IR_FCS_SIZE) + SLOW_IR_EOF_SIZE) +	\
		sizeof(STIR4200_FRAME_HEADER)

//
// Note that the receive size needs to be incremented to account for
// the way the decoding can use one more byte
//
#define MAX_RCV_DATA_SIZE					(MAX_TOTAL_SIZE_WITH_ALL_HEADERS + FAST_IR_FCS_SIZE + 1)

#define MAX_IRDA_DATA_SIZE					MAX_POSSIBLE_IR_PACKET_SIZE_FOR_DATA(IRDA_MAX_DATAONLY_SIZE)

//
// Possible speeds
//
typedef enum _BAUD_RATE 
{
        //
        // Slow IR
        //
        BAUDRATE_2400 = 0,
        BAUDRATE_9600,
        BAUDRATE_19200,
        BAUDRATE_38400,
        BAUDRATE_57600,
        BAUDRATE_115200,

        //
        // Medium IR
        //
#if !defined(DWORKAROUND_BROKEN_MIR)
        BAUDRATE_576000,
        BAUDRATE_1152000,
#endif
        //
        // Fast IR
        //
        BAUDRATE_4000000,

        //
        // must be last
        //
        NUM_BAUDRATES

} BAUD_RATE;

typedef enum _IR_MODE 
{
	IR_MODE_SIR = 0,
	IR_MODE_MIR,
	IR_MODE_FIR,
	NUM_IR_MODES
} IR_MODE;

//
// Speeds
//
#define SPEED_2400				2400
#define SPEED_9600				9600
#define SPEED_19200				19200
#define SPEED_38400				38400
#define SPEED_57600				57600
#define SPEED_115200			115200
#define SPEED_576000			576000
#define SPEED_1152000			1152000
#define SPEED_4000000			4000000

#define DEFAULT_BAUD_RATE		SPEED_9600

#define MAX_SIR_SPEED           SPEED_115200
#define MAX_MIR_SPEED           SPEED_1152000


//
// Sizes of IrLAP frame fields:
//       Beginning Of Frame (BOF)
//       End Of Frame (EOF)
//       Address
//       Control
//
#define SLOW_IR_BOF_TYPE			UCHAR
#define SLOW_IR_BOF_SIZE			sizeof(SLOW_IR_BOF_TYPE)
#define SLOW_IR_EOF_TYPE			UCHAR
#define SLOW_IR_EOF_SIZE			sizeof(SLOW_IR_EOF_TYPE)
#define SLOW_IR_FCS_TYPE			USHORT
#define SLOW_IR_FCS_SIZE			sizeof(SLOW_IR_FCS_TYPE)
#define SLOW_IR_BOF					0xC0
#define SLOW_IR_EOF					0xC1
#define SLOW_IR_ESC					0x7D
#define SLOW_IR_ESC_COMP			0x20
#define SLOW_IR_EXTRA_BOF_TYPE      UCHAR
#define SLOW_IR_EXTRA_BOF_SIZE      sizeof(SLOW_IR_EXTRA_BOF_TYPE)
#define SLOW_IR_EXTRA_BOF           0xC0

#define MEDIUM_IR_BOF				0x7E
#define MEDIUM_IR_EOF				0x7E
#define MEDIUM_IR_FCS_TYPE			USHORT
#define MEDIUM_IR_FCS_SIZE			sizeof(MEDIUM_IR_FCS_TYPE)

#define FAST_IR_FCS_TYPE            ULONG
#define FAST_IR_FCS_SIZE            sizeof(FAST_IR_FCS_TYPE)
#define FAST_IR_EOF_TYPE			ULONG
#define FAST_IR_EOF_SIZE			sizeof(FAST_IR_EOF_TYPE)

//
// Definition for speed masks
//
#define NDIS_IRDA_SPEED_MASK_2400		0x001    // SLOW IR ...
#define NDIS_IRDA_SPEED_MASK_9600		0x003
#define NDIS_IRDA_SPEED_MASK_19200		0x007
#define NDIS_IRDA_SPEED_MASK_38400		0x00f
#define NDIS_IRDA_SPEED_MASK_57600		0x01f
#define NDIS_IRDA_SPEED_MASK_115200		0x03f
#define NDIS_IRDA_SPEED_MASK_576K		0x07f   // MEDIUM IR ...
#define NDIS_IRDA_SPEED_MASK_1152K		0x0ff
#define NDIS_IRDA_SPEED_MASK_4M			0x1ff   // FAST IR

#define GOOD_FCS                        ((USHORT) ~0xf0b8)
#define FIR_GOOD_FCS                    ((ULONG) ~0xdebb20e3)

typedef struct
{
    BAUD_RATE	TableIndex;
    UINT		BitsPerSec;
	IR_MODE		IrMode;
    UINT		NdisCode;			// bitmask element as used by ndis and in class-specific descriptor
	UCHAR		Stir4200Divisor;
} BAUDRATE_INFO;


//
// Struct to hold the IR USB dongle's USB Class-Specific Descriptor as per
// "Universal Serial Bus IrDA Bridge Device Definition" doc, section 7.2
// This is the struct returned by USBD as the result of a request with an urb 
// of type _URB_CONTROL_VENDOR_OR_CLASS_REQUEST, function URB_FUNCTION_CLASS_DEVICE
// 

// Enable 1-byte alignment in the below struct
#pragma pack (push,1)

typedef struct _IRUSB_CLASS_SPECIFIC_DESCRIPTOR
{
    BOOLEAN  ClassConfigured;            

    UCHAR  bmDataSize;         // max bytes allowed in any frame as per IrLAP spec, where:
                            
#define BM_DATA_SIZE_2048   (1 << 5)
#define BM_DATA_SIZE_1024   (1 << 4)
#define BM_DATA_SIZE_512    (1 << 3)
#define BM_DATA_SIZE_256    (1 << 2)
#define BM_DATA_SIZE_128    (1 << 1)
#define BM_DATA_SIZE_64     (1 << 0)

    UCHAR bmWindowSize;         // max un-acked frames that can be received
                                // before an ack is sent, where:
#define BM_WINDOW_SIZE_7     (1 << 6)
#define BM_WINDOW_SIZE_6     (1 << 5)
#define BM_WINDOW_SIZE_5     (1 << 4)
#define BM_WINDOW_SIZE_4     (1 << 3)
#define BM_WINDOW_SIZE_3     (1 << 2)
#define BM_WINDOW_SIZE_2     (1 << 1)
#define BM_WINDOW_SIZE_1     (1 << 0)

    UCHAR bmMinTurnaroundTime;         // min millisecs required for recovery between
                                       // end of last xmission and can receive again, where:
#define BM_TURNAROUND_TIME_0ms      (1 << 7)  // 0 ms
#define BM_TURNAROUND_TIME_0p01ms   (1 << 6)  // 0.01 ms
#define BM_TURNAROUND_TIME_0p05ms   (1 << 5)  // 0.05 ms
#define BM_TURNAROUND_TIME_0p1ms    (1 << 4)  // 0.1 ms
#define BM_TURNAROUND_TIME_0p5ms    (1 << 3)  // 0.5 ms
#define BM_TURNAROUND_TIME_1ms      (1 << 2)  // 1 ms
#define BM_TURNAROUND_TIME_5ms      (1 << 1)  // 5 ms
#define BM_TURNAROUND_TIME_10ms     (1 << 0)  // 10 ms

    USHORT wBaudRate;

//
// ir speed masks as used both by NDIS and as formatted in USB class-specfic descriptor
//
#define NDIS_IRDA_SPEED_2400		(1 << 0)    // SLOW IR ...
#define NDIS_IRDA_SPEED_9600		(1 << 1)
#define NDIS_IRDA_SPEED_19200		(1 << 2)
#define NDIS_IRDA_SPEED_38400		(1 << 3)
#define NDIS_IRDA_SPEED_57600		(1 << 4)
#define NDIS_IRDA_SPEED_115200		(1 << 5)
#define NDIS_IRDA_SPEED_576K		(1 << 6)   // MEDIUM IR ...
#define NDIS_IRDA_SPEED_1152K		(1 << 7)
#define NDIS_IRDA_SPEED_4M			(1 << 8)   // FAST IR

    
    UCHAR  bmExtraBofs; // #BOFS required at 115200; 0 if slow speeds <=115200 not supported

#define BM_EXTRA_BOFS_0        (1 << 7)  
#define BM_EXTRA_BOFS_1        (1 << 6)  
#define BM_EXTRA_BOFS_2        (1 << 5)  
#define BM_EXTRA_BOFS_3        (1 << 4)  
#define BM_EXTRA_BOFS_6        (1 << 3)  
#define BM_EXTRA_BOFS_12       (1 << 2)  
#define BM_EXTRA_BOFS_24       (1 << 1)  
#define BM_EXTRA_BOFS_48       (1 << 0)  
    
} IRUSB_CLASS_SPECIFIC_DESCRIPTOR, *PIRUSB_CLASS_SPECIFIC_DESCRIPTOR;

#pragma pack (pop) //disable 1-byte alignment


typedef struct _DONGLE_CAPABILITIES
{
    //
    // Time (in microseconds) that must transpire between
    // a transmit and the next receive.
    //
    LONG turnAroundTime_usec;   // gotten from class-specific descriptor

    //
    // Max un-acked frames that can be received
    // before an ack is sent
    //
    UINT windowSize;            // gotten from class-specific descriptor

    //
    // #BOFS required at 115200; 0 if slow speeds <=115200 are not supported
    //
    UINT extraBOFS;             // gotten from class-specific descriptor

    //
    // max bytes allowed in any frame as per IrLAP spec
    //
    UINT dataSize;              // gotten from class-specific descriptor

} DONGLE_CAPABILITIES, *PDONGLE_CAPABILITIES;


//
// Enum of context types for SendPacket
//
typedef enum _CONTEXT_TYPE 
{
    CONTEXT_NDIS_PACKET,
    CONTEXT_SET_SPEED,
	CONTEXT_READ_WRITE_REGISTER,
	CONTEXT_DIAGS_ENABLE,
	CONTEXT_DIAGS_DISABLE,
	CONTEXT_DIAGS_READ_REGISTERS,
	CONTEXT_DIAGS_WRITE_REGISTER,
	CONTEXT_DIAGS_BULK_OUT,
	CONTEXT_DIAGS_BULK_IN,
	CONTEXT_DIAGS_SEND
} CONTEXT_TYPE;

typedef	NTSTATUS (*WORK_PROC)(struct _IR_WORK_ITEM *);

typedef struct _IR_WORK_ITEM
{
    PVOID               pIrDevice;
    WORK_PROC           Callback;
    PUCHAR              pInfoBuf;
    ULONG               InfoBufLen;
	ULONG				fInUse;  // declared as ulong for use with interlockedexchange
} IR_WORK_ITEM, *PIR_WORK_ITEM;

//
// Transceiver type definition
//
typedef enum _TRANSCEIVER_TYPE 
{
	TRANSCEIVER_4012 = 0,
	TRANSCEIVER_4000,
	TRANSCEIVER_VISHAY,
	TRANSCEIVER_VISHAY_6102F,
	TRANSCEIVER_INFINEON,
	TRANSCEIVER_HP,
	TRANSCEIVER_CUSTOM
} TRANSCEIVER_TYPE;

//
// Receive mode definition
//
typedef enum _RXMODE 
{
	RXMODE_SLOW = 0,
	RXMODE_SLOWFAST,
	RXMODE_FAST
} RXMODE;

//
// Chip revision definition
//
typedef enum _CHIP_REVISION 
{
	CHIP_REVISION_6 = 5,
	CHIP_REVISION_7,
	CHIP_REVISION_8
} CHIP_REVISION;

typedef struct _IR_DEVICE
{
    //
    // Keep track of various device objects.
    //
    PDEVICE_OBJECT  pUsbDevObj;     //'Next Device Object'
    PDEVICE_OBJECT  pPhysDevObj;    // Physical Device Object 

    //
    // This is the handle that the NDIS wrapper associates with a connection.
    // (The handle that the miniport driver associates with the connection
    // is just an index into the devStates array).
    //
    HANDLE hNdisAdapter;

    //
    // The dongle interface allows us to check the tranceiver type once
    // and then set up the interface to allow us to init, set speed,
    // and deinit the dongle.
    //
    // We also want the dongle capabilities.
    //
    DONGLE_CAPABILITIES dongleCaps;

	//
	// Type of transceiver installed
	//
	TRANSCEIVER_TYPE TransceiverType;

	//
	// Receive mode
	//
	RXMODE ReceiveMode;

	//
	// Revision of the installed 4200
	//
	CHIP_REVISION ChipRevision;

    //
    // Current speed setting, in bits/sec.
    // Note: This is updated when we ACTUALLY change the speed,
    //       not when we get the request to change speed via
    //       irusbSetInformation.
    //
    //
    //  When speed is changed, we have to clear the send queue before
    //  setting the new speed on the hardware.
    //  These vars let us remember to do it.
    //
    UINT			currentSpeed;

    //
    // Current link speed information. This also will maintain the
    // chosen speed if the protocol requests a speed change.
    //
    BAUDRATE_INFO	*linkSpeedInfo;

    //
    // Maintain statistical debug info.
    //
    ULONG packetsReceived;
    ULONG packetsReceivedDropped;
    ULONG packetsReceivedOverflow;
    ULONG packetsReceivedChecksum;
    ULONG packetsReceivedRunt;
	ULONG packetsReceivedNoBuffer;
    ULONG packetsSent;
	ULONG packetsSentDropped;
 	ULONG packetsSentRejected;
 	ULONG packetsSentInvalid;

#if DBG
    ULONG packetsHeldByProtocol;
    ULONG MaxPacketsHeldByProtocol;
	ULONG TotalBytesReceived;
	ULONG TotalBytesSent;
	ULONG NumYesQueryMediaBusyOids;
	ULONG NumNoQueryMediaBusyOids;
	ULONG NumSetMediaBusyOids;
	ULONG NumMediaBusyIndications;
	ULONG NumPacketsSentRequiringTurnaroundTime;
	ULONG NumPacketsSentNotRequiringTurnaroundTime;
#endif

	//
    // used by check hang handler to track Query, Set, and Send times
    //
	LARGE_INTEGER	LastQueryTime;
    LARGE_INTEGER	LastSetTime;
	BOOLEAN			fSetpending;
	BOOLEAN			fQuerypending;

    //
    // Set when device has been started; use for safe cleanup after failed initialization
    //
    BOOLEAN			fDeviceStarted;

    //
    // Indicates that we have received an OID_GEN_CURRENT_PACKET_FILTER
    // indication from the protocol. We can deliver received packets to the
    // protocol.
    //
    BOOLEAN			fGotFilterIndication;

    //
    // NDIS calls most of the MiniportXxx function with IRQL DISPATCH_LEVEL.
    // There are a number of instances where the ir device must send
    // requests to the device which may be synchronous and
    // we can't block in DISPATCH_LEVEL. Therefore, we set up a thread to deal
    // with request which require PASSIVE_LEVEL. An event is used to signal
    // the thread that work is required.
    //
    HANDLE          hPassiveThread;
    BOOLEAN         fKillPassiveLevelThread;

    KEVENT			EventPassiveThread;

/*  
    According to  W2000 ddk doc:
    The IrDA protocol driver sets this OID to zero to request the miniport to
    start monitoring for a media busy condition. The IrDA protocol 
    can then query this OID to determine whether the media is busy.
    If the media is not busy, the miniport returns a zero for this
    OID when queried. If the media is busy,that is, if the miniport
    has detected some traffic since the IrDA protocol driver last
    set OID_IRDA_MEDIA_BUSY to zero the miniport returns a non-zero
    value for this OID when queried. On detecting the media busy
    condition. the miniport must also call NdisMIndicateStatus to
    indicate NDIS_STATUS_MEDIA_BUSY. When the media is busy, 
    the IrDA protocol driver will not send packets to the miniport
    for transmission. After the miniport has detected a busy state, 
    it does not have to monitor for a media busy condition until
    the IrDA protocol driver again sets OID_IRDA_MEDIA_BUSY to zero.

    According to USB IrDA Bridge Device Definition Doc sec 5.4.1.2:

    The bmStatus field indicators shall be set by the Device as follows:
    Media_Busy
     Media_Busy shall indicate zero (0) if the Device:
    . has not received a Check Media Busy class-specific request
    . has detected no traffic on the infrared media since receiving a Check Media Busy
    . class-specific request
   . Has returned a header with Media_Busy set to one (1) since receiving a Check
      Media Busy class-specific request.
     
    Media_Busy shall indicate one (1) if the Device has detected traffic on the infrared
     media since receiving a Check Media Busy class-specific request. Note that
     Media_Busy shall indicate one (1) in exactly one header following receipt of each
     Check Media Busy class-specific request.

    According to USB IrDA Bridge Device Definition Doc sec 6.2.2:

      Check Media Busy
    This class-specific request instructs the Device to look for a media busy condition. If infrared
    traffic of any kind is detected by this Device, the Device shall set the Media_Busy field in the
    bmStatus field in the next Data-In packet header sent to the host. In the case where a Check
    Media Busy command has been received, a media busy condition detected, and no IrLAP frame
    traffic is ready to transmit to the host, the Device shall set the Media_Busy field and send it in a
    Data-In packet with no IrLAP frame following the header.

    bmRequestType   bRequest   wValue   wIndex   wLength   Data
    00100001B          3        Zero   Interface   Zero   [None]
     
*/
    ULONG         fMediaBusy;  // declare as ULONGS for use with InterlockedExchange
    ULONG         fIndicatedMediaBusy;

    //
    // The variable fProcessing is used to indicate that the ir device
    // object has an active polling thread,
    //
    // Under normal circumstances fReceiving should always be TRUE.
    // However sometimes the processing has to be stopped
    // and this variable is used to synchronize
    //
    ULONG fProcessing;

	//
	// To be set to true when really receiving packets
	//
    ULONG fCurrentlyReceiving;

    //
    // The variables fPendingHalt and fPendingReset allow the send and receive
    // completion routines to complete the current pending irp and
    // then cleanup and stop sending irps to the USB driver.
    //
    BOOLEAN fPendingHalt;
    BOOLEAN fPendingReset;


    ULONG fPendingReadClearStall;
    ULONG fPendingWriteClearStall;

	// 
	// This is required when the part gets into a complete USB hang and a reset is required
	//
    ULONG fPendingClearTotalStall;

    //
    // We keep an array of receive buffers so that we don't continually
    // need to allocate buffers to indicate packets to the protocol.
    // Since the protocol can retain ownership of up to eight packets
    // and we can be receiving up to WindowSize  ( 7 ) packets while the protocol has
    // ownership of eight packets, we will allocate 16 packets for
    // receiving.
    //
    #define NUM_RCV_BUFS 16

    RCV_BUFFER		rcvBufs[NUM_RCV_BUFS];
	PRCV_BUFFER		pCurrentRecBuf;

	FIFO_BUFFER		PreReadBuffer;

	//
	// Can have max of NUM_RCV_BUFS packets pending + one set and one query
	//
	#define  NUM_WORK_ITEMS	 (NUM_RCV_BUFS+3)

	IR_WORK_ITEM	WorkItems[NUM_WORK_ITEMS];

	//
    // Since we can have multiple write irps pending with the USB driver,
    // we track the irp contexts for each one so we have all the info we need at each
	// invokation of the USB write completion routine. See the IRUSB_CONTEXT definition below
    // There are 128 contexts for sending, one for read/write operations, one for setting the speed
	// and one for diagnostic operations
	//
	#define	NUM_SEND_CONTEXTS 131

	PVOID			pSendContexts;

    //
    // Handles to the NDIS packet pool and NDIS buffer pool
    // for allocating the receive buffers.
    //
    HANDLE			hPacketPool;
    HANDLE			hBufferPool;
	BOOLEAN			BufferPoolAllocated;

	KEVENT			EventSyncUrb;
	KEVENT			EventAsyncUrb;

	NTSTATUS        StatusControl;  
	NTSTATUS        StatusReadWrite;  
	NTSTATUS        StatusSendReceive;  
	
	//
	// track pending IRPS; this should be zero at halt time
	//
	UINT			PendingIrpCount;
    ULONG			NumReads;
    ULONG			NumWrites;
    ULONG			NumReadWrites;

	//
    // various USB errors
    //
    ULONG			NumDataErrors;
    ULONG			NumReadWriteErrors;

    HANDLE			BulkInPipeHandle;
    HANDLE			BulkOutPipeHandle;

    HANDLE          hPollingThread;
    BOOLEAN         fKillPollingThread;

//
// The IR USB dongle's USB Class-Specific Descriptor as per
// "Universal Serial Bus IrDA Bridge Device Definition" doc, section 7.2
// This is the struct returned by USBD as the result of a request with an urb 
// of type _URB_CONTROL_VENDOR_OR_CLASS_REQUEST, function URB_FUNCTION_CLASS_DEVICE.
// Note this  struct is  in-line, not a pointer
// 
    IRUSB_CLASS_SPECIFIC_DESCRIPTOR  ClassDesc;

	UINT			IdVendor;			// USB vendor Id read from dongle
	
	//
	// We don't define it here because we need to isolate USB stuff so we
	// can build  things referencing NDIS with the BINARY_COMPATIBLE flag for win9x
	//
	PUCHAR			pUsbInfo;

	//
	// Optional registry entry for debugging; limit baud rate. 
	// The mask is set up as per the USB Class-Specific descriptor 'wBaudRate'
	// This is 'and'ed with value from Class descriptor to possibly limit baud rate;
	// It defaults to 0xffff
	//
	UINT			BaudRateMask;

	//
	// Necessary to read the registry fields
	//
	NDIS_HANDLE		WrapperConfigurationContext;

	//
	// IR Tranceiver Model
	//
	STIR4200_TRANCEIVER StIrTranceiver;

	//
	// Send buffers (works only if sending is serialied)
	//
	PUCHAR			pBuffer;
	UINT			BufLen;
	PUCHAR			pStagingBuffer;
    
	//
	// Send FIFO count
	//
	ULONG			SendFifoCount;

	//
	// Receive adaptive delay
	//
	ULONG			ReceiveAdaptiveDelay;
	ULONG			ReceiveAdaptiveDelayBoost;

	// MS Security issue - removed pUrb

	//
	// Receive buffer and positions
	//
	UCHAR			pRawBuf[STIR4200_FIFO_SIZE];
	ULONG			rawCleanupBytesRead;
	PORT_RCV_STATE  rcvState;
    ULONG           readBufPos;
	BOOLEAN			fReadHoldingReg;
	ULONG			PreFifoCount;

	//
	// Send lists and lock
    //
	LIST_ENTRY		SendAvailableQueue;
    LIST_ENTRY		SendBuiltQueue;
	LIST_ENTRY		SendPendingQueue;
	ULONG			SendAvailableCount;
	ULONG			SendBuiltCount;
	ULONG			SendPendingCount;
	KSPIN_LOCK		SendLock;

	//
	// Read and write register list, shares the other send queues
    //
	LIST_ENTRY		ReadWritePendingQueue;
	ULONG			ReadWritePendingCount;

	//
	// Diagnostics
	//
#if defined(DIAGS)
	ULONG			DiagsActive;
	ULONG			DiagsPendingActivation;
	PVOID			pIOCTL;
	NTSTATUS		IOCTLStatus;
	KEVENT			EventDiags;
	LIST_ENTRY		DiagsReceiveQueue;
	KSPIN_LOCK		DiagsReceiveLock;
#endif
	NDIS_HANDLE		NdisDeviceHandle;

	//
	// Logging
	//
#if defined(RECEIVE_LOGGING)
	HANDLE ReceiveFileHandle;
	__int64 ReceiveFilePosition;
#endif

#if defined(RECEIVE_ERROR_LOGGING)
	HANDLE ReceiveErrorFileHandle;
	__int64 ReceiveErrorFilePosition;
#endif

#if defined(SEND_LOGGING)
	HANDLE SendFileHandle;
	__int64 SendFilePosition;
#endif
	
#if !defined(WORKAROUND_BROKEN_MIR)
	//
	// Mir in software
	//
	UCHAR pRawUnstuffedBuf[STIR4200_FIFO_SIZE];
	UCHAR MirIncompleteByte;
	ULONG MirIncompleteBitCount;
	ULONG MirOneBitCount;
	ULONG MirFlagCount;
#endif

	//
	// Dummy send fix
	//
	BOOLEAN GearedDown;

	//
	// Fix for FIR permanent invalid state
	//
	BOOLEAN StuckFir;

	//
	// Customer data area.
	//
	UCHAR	pCustomerData[STIR4200_CUST_DATA_SIZE];
	BOOLEAN CustomerDataRead;

	//
	// Used in Diagnostic version.
	//
#if defined(VARIABLE_SETTINGS)
	ULONG SirDpll;
	ULONG FirDpll;
	ULONG SirSensitivity;
	ULONG FirSensitivity;
#endif
} IR_DEVICE, *PIR_DEVICE;


//
// We use a pointer to the IR_DEVICE structure as the miniport's device context.
//

#define CONTEXT_TO_DEV(__deviceContext) ((PIR_DEVICE)(__deviceContext))
#define DEV_TO_CONTEXT(__irdev) ((HANDLE)(__irdev))

#define IRUSB_TAG 'RITS'


VOID   
MyNdisMSetInformationComplete( 
        IN PIR_DEVICE pThisDev,
        IN NDIS_STATUS Status
	);

VOID  
MyNdisMQueryInformationComplete( 
        IN PIR_DEVICE pThisDev,
        IN NDIS_STATUS Status
	);

USHORT
ComputeFCS16(
		IN PUCHAR pData, 
		UINT DataLen
	);

ULONG 
ComputeFCS32(
		IN PUCHAR pData, 
		ULONG DataLen
	);

BOOLEAN         
NdisToFirPacket(
		IN PIR_DEVICE pIrDev,
		IN PNDIS_PACKET pPacket,
		OUT PUCHAR pIrPacketBuf,
		ULONG IrPacketBufLen,
		IN PUCHAR pContigPacketBuf,
		OUT PULONG pIrPacketLen
	);

BOOLEAN
NdisToMirPacket( 
		IN PIR_DEVICE pIrDev,
		IN PNDIS_PACKET pPacket,
		OUT PUCHAR pIrPacketBuf,
		ULONG IrPacketBufLen,
		IN PUCHAR pContigPacketBuf,
		OUT PULONG pIrPacketLen
	);

BOOLEAN
NdisToSirPacket( 
		IN PIR_DEVICE pIrDev,
		IN PNDIS_PACKET pPacket,
		OUT PUCHAR pIrPacketBuf,
		ULONG IrPacketBufLen,
		IN PUCHAR pContigPacketBuf,
		OUT PULONG pIrPacketLen
	);

BOOLEAN     
ReceiveFirStepFSM(
		IN OUT PIR_DEVICE pIrDev, 
		OUT PULONG pBytesProcessed
	);

BOOLEAN     
ReceiveMirStepFSM(
		IN OUT PIR_DEVICE pIrDev, 
		OUT PULONG pBytesProcessed
	);

#if !defined(WORKAROUND_BROKEN_MIR)
BOOLEAN
ReceiveMirUnstuff(
		IN OUT PIR_DEVICE pIrDev,
		IN PUCHAR pInputBuffer,
		ULONG InputBufferSize,
		OUT PUCHAR pOutputBuffer,
		OUT PULONG pOutputBufferSize
	);
#endif

BOOLEAN     
ReceiveSirStepFSM(
		IN OUT PIR_DEVICE pIrDev, 
		OUT PULONG pBytesProcessed
	);

VOID
ReceiveProcessFifoData(
		IN OUT PIR_DEVICE pThisDev
	);

VOID
ReceiveResetPointers(
		IN OUT PIR_DEVICE pThisDev
	);

NTSTATUS
ReceivePreprocessFifo(
		IN OUT PIR_DEVICE pThisDev,
		OUT PULONG pFifoCount
	);

NTSTATUS
ReceiveGetFifoData(
		IN OUT PIR_DEVICE pThisDev,
		OUT PUCHAR pData,
		OUT PULONG pBytesRead,
		ULONG BytesToRead
	);

VOID 
ReceiveProcessReturnPacket(
		OUT PIR_DEVICE pThisDev,
		OUT PRCV_BUFFER pReceiveBuffer
	);

NTSTATUS 
ReceivePacketRead( 
		IN PIR_DEVICE pThisDev,
		OUT PFIFO_BUFFER pRecBuf
	);

NTSTATUS
ReceiveCompletePacketRead(
		IN PDEVICE_OBJECT pUsbDevObj,
		IN PIRP           pIrp,
		IN PVOID          Context
	);

VOID  
IndicateMediaBusy(
       IN PIR_DEVICE pThisDev
   );

VOID  
IrUsb_IncIoCount( 
		IN OUT PIR_DEVICE pThisDev 
	); 

VOID  
IrUsb_DecIoCount( 
		IN OUT PIR_DEVICE pThisDev 
	);

NTSTATUS
IrUsb_GetDongleCaps( 
		IN OUT PIR_DEVICE pThisDev 
	);

VOID 
IrUsb_SetDongleCaps( 
        IN OUT PIR_DEVICE pThisDev 
	);

VOID 
MyMemFree(
		IN PVOID pMem,
		IN UINT size
	);

PVOID 
MyMemAlloc(
		UINT size
	);

VOID 
MyUrbFree(
		IN PURB pUrb,
		IN UINT size
	);

PURB
MyUrbAlloc(
		UINT size
	);

BOOLEAN 
AllocUsbInfo(
		IN OUT PIR_DEVICE pThisDev 
	);

VOID 
FreeUsbInfo(
		IN OUT PIR_DEVICE pThisDev 
	);

VOID 
PollingThread(
		IN OUT PVOID Context
	);

extern BAUDRATE_INFO supportedBaudRateTable[NUM_BAUDRATES];

VOID 
ReceiveDeliverBuffer(
		IN OUT PIR_DEVICE pThisDev,
		IN PRCV_BUFFER pRecBuf
	);

NTSTATUS 
InitializeProcessing(
        IN OUT PIR_DEVICE pThisDev,
		IN BOOLEAN InitPassiveThread
    );

NTSTATUS
IrUsb_ResetPipe (
		IN PIR_DEVICE pThisDev,
		IN HANDLE Pipe
    );

BOOLEAN
IrUsb_InitSendStructures( 
        IN OUT PIR_DEVICE pThisDev
	);

VOID
IrUsb_FreeSendStructures( 
        IN OUT PIR_DEVICE pThisDev
	);

NDIS_STATUS
SendPacketPreprocess(
		IN OUT PIR_DEVICE pThisDev,
		IN PVOID pPacketToSend
	);

NDIS_STATUS
SendPreprocessedPacketSend(
		IN OUT PIR_DEVICE pThisDev,
		IN PVOID pContext
	);

NTSTATUS
SendWaitCompletion(
		IN OUT PIR_DEVICE pThisDev
	);

NTSTATUS
SendCheckForOverflow(
		IN OUT PIR_DEVICE pThisDev
	);

NTSTATUS 
SendCompletePacketSend(
		IN PDEVICE_OBJECT pUsbDevObj,
		IN PIRP           pIrp,
		IN PVOID          Context
	);

PRCV_BUFFER
ReceiveGetBuf( 
		PIR_DEVICE pThisDev,
		OUT PUINT pIndex,
		IN RCV_BUFFER_STATE BufferState
	);

VOID 
PassiveLevelThread(
        IN PVOID Context
    );

BOOLEAN
ScheduleWorkItem(
		IN OUT PIR_DEVICE pThisDev,
		WORK_PROC Callback,
		IN PVOID pInfoBuf,
		ULONG InfoBufLen
	);

VOID 
FreeWorkItem(
		IN OUT PIR_WORK_ITEM pItem
	);

VOID 
IrUsb_PrepareSetSpeed(
		IN OUT PIR_DEVICE pThisDev
	);

NTSTATUS
ResetPipeCallback (
		IN PIR_WORK_ITEM pWorkItem
    );

PVOID 
AllocXferUrb ( 
		VOID 
	);

VOID
FreeXferUrb( 
		IN OUT PVOID pUrb 
	);

#endif // _IRCOM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\net\irda\sigmatel\sys\hwio.c ===
/**************************************************************************************************************************
 *  HWIO.C SigmaTel STIR4200 hardware specific module (to access the registers)
 **************************************************************************************************************************
 *  (C) Unpublished Copyright of Sigmatel, Inc. All Rights Reserved.
 *
 *
 *		Created: 04/06/2000 
 *			Version 0.9
 *		Edited: 04/27/2000 
 *			Version 0.92
 *		Edited: 05/12/2000 
 *			Version 0.94
 *		Edited: 07/27/2000 
 *			Version 1.01
 *		Edited: 08/22/2000 
 *			Version 1.02
 *		Edited: 09/16/2000 
 *			Version 1.03
 *		Edited: 09/25/2000 
 *			Version 1.10
 *		Edited: 11/10/2000 
 *			Version 1.12
 *		Edited: 01/16/2001
 *			Version 1.14
 *		Edited: 02/20/2001
 *			Version 1.15
 *
 **************************************************************************************************************************/

#define DOBREAKS    // enable debug breaks

#include <ndis.h>
#include <ntdef.h>
#include <windef.h>

#include "stdarg.h"
#include "stdio.h"

#include "debug.h"
#include "usbdi.h"
#include "usbdlib.h"

#include "ircommon.h"
#include "irusb.h"
#include "irndis.h"
#include "stir4200.h"


/*****************************************************************************
*
*  Function:   St4200ResetFifo
*
*  Synopsis:   Reset the STIr4200 FIFO to clear several hangs
*
*  Arguments:  pDevice - pointer to current ir device object
*
*  Returns:    NT_STATUS
*
*
*****************************************************************************/
NTSTATUS        
St4200ResetFifo( 
		IN PVOID pDevice
	)
{
	NTSTATUS		Status;
	PIR_DEVICE		pThisDev = (PIR_DEVICE)pDevice;
	
	DEBUGMSG(DBG_INT_ERR, (" St4200ResetFifo: Issuing a FIFO reset()\n"));

	// MS Security bug #538703
	IRUSB_ASSERT(pDevice != NULL);
	
#if !defined(FAST_WRITE_REGISTERS)
	if( (Status = St4200ReadRegisters(pThisDev, STIR4200_MODE_REG, 1)) != STATUS_SUCCESS )
	{
		DEBUGMSG(DBG_ERR, (" St4200ResetFifo(): USB failure\n"));
		goto done;
	}
#endif

	//
	// Force a FIFO reset by clearing and setting again the RESET_OFF bit
	//
	pThisDev->StIrTranceiver.ModeReg &= (~STIR4200_MODE_RESET_OFF);
	if( (Status = St4200WriteRegister(pThisDev, STIR4200_MODE_REG)) != STATUS_SUCCESS )
	{
		DEBUGMSG(DBG_ERR, (" St4200ResetFifo(): USB failure\n"));
		goto done;
	}

	pThisDev->StIrTranceiver.ModeReg |= STIR4200_MODE_RESET_OFF;
	if( (Status = St4200WriteRegister(pThisDev, STIR4200_MODE_REG)) != STATUS_SUCCESS )
	{
		DEBUGMSG(DBG_ERR, (" St4200ResetFifo(): USB failure\n"));
		goto done;
	}

done:
	return Status;
}


/*****************************************************************************
*
*  Function:   St4200DoubleResetFifo
*
*  Synopsis:   Reset the STIr4200 FIFO to clear several 4012 related hangs
*
*  Arguments:  pDevice - pointer to current ir device object
*
*  Returns:    NT_STATUS
*
*
*****************************************************************************/
NTSTATUS        
St4200DoubleResetFifo( 
		IN PVOID pDevice
	)
{
	NTSTATUS		Status;
	PIR_DEVICE		pThisDev = (PIR_DEVICE)pDevice;
	
	DEBUGMSG(DBG_INT_ERR, (" St4200DoubleResetFifo: Issuing a FIFO reset()\n"));

	// MS Security bug #538703
	IRUSB_ASSERT(pDevice != NULL);
	
	//
	// Turn off the receiver to clear the pointers
	//
	if( (Status = St4200TurnOffReceiver( pThisDev ) ) != STATUS_SUCCESS )
	{
		DEBUGMSG(DBG_ERR, (" St4200DoubleResetFifo(): USB failure\n"));
		goto done;
	}

	//
	// Now clear the fifo logic
	//
#if !defined(FAST_WRITE_REGISTERS)
	if( (Status = St4200ReadRegisters(pThisDev, STIR4200_STATUS_REG, 1)) != STATUS_SUCCESS )
	{
		DEBUGMSG(DBG_ERR, (" St4200DoubleResetFifo(): USB failure\n"));
		goto done;
	}

	if( (Status = St4200ReadRegisters(pThisDev, STIR4200_STATUS_REG, 1)) != STATUS_SUCCESS )
	{
		DEBUGMSG(DBG_ERR, (" St4200DoubleResetFifo(): USB failure\n"));
		goto done;
	}
#endif

	pThisDev->StIrTranceiver.StatusReg |= STIR4200_STAT_FFCLR;
	if( (Status = St4200WriteRegister(pThisDev, STIR4200_STATUS_REG)) != STATUS_SUCCESS )
	{
		DEBUGMSG(DBG_ERR, (" St4200DoubleResetFifo(): USB failure\n"));
		goto done;
	}

	//
	// All back on
	//
	pThisDev->StIrTranceiver.StatusReg &= (~STIR4200_STAT_FFCLR);
	if( (Status = St4200WriteRegister(pThisDev, STIR4200_STATUS_REG)) != STATUS_SUCCESS )
	{
		DEBUGMSG(DBG_ERR, (" St4200DoubleResetFifo(): USB failure\n"));
		goto done;
	}

	if( (Status = St4200TurnOnReceiver( pThisDev ) ) != STATUS_SUCCESS )
	{
		DEBUGMSG(DBG_ERR, (" St4200DoubleResetFifo(): USB failure\n"));
		goto done;
	}


done:
	return Status;
}


/*****************************************************************************
*
*  Function:   St4200SoftReset
*
*  Synopsis:   Soft reset of the STIr4200 modulator
*
*  Arguments:  pDevice - pointer to current ir device object
*
*  Returns:    NT_STATUS
*
*
*****************************************************************************/
NTSTATUS        
St4200SoftReset( 
		IN PVOID pDevice
	)
{
	NTSTATUS		Status;
	PIR_DEVICE		pThisDev = (PIR_DEVICE)pDevice;
	
	DEBUGMSG(DBG_INT_ERR, (" St4200SoftReset: Issuing a soft reset()\n"));
	
	// MS Security bug #538703
	IRUSB_ASSERT(pDevice != NULL);
	
#if !defined(FAST_WRITE_REGISTERS)
	if( (Status = St4200ReadRegisters(pThisDev, STIR4200_CONTROL_REG, 1)) != STATUS_SUCCESS )
	{
		DEBUGMSG(DBG_ERR, (" St4200SoftReset(): USB failure\n"));
		goto done;
	}
#endif

	//
	// Force a FIFO reset by clearing and setting again the RESET_OFF bit
	//
	pThisDev->StIrTranceiver.ControlReg |= STIR4200_CTRL_SRESET;
	if( (Status = St4200WriteRegister(pThisDev, STIR4200_CONTROL_REG)) != STATUS_SUCCESS )
	{
		DEBUGMSG(DBG_ERR, (" St4200SoftReset(): USB failure\n"));
		goto done;
	}

	pThisDev->StIrTranceiver.ControlReg &= (~STIR4200_CTRL_SRESET);
	if( (Status = St4200WriteRegister(pThisDev, STIR4200_CONTROL_REG)) != STATUS_SUCCESS )
	{
		DEBUGMSG(DBG_ERR, (" St4200SoftReset(): USB failure\n"));
		goto done;
	}

done:
	return Status;
}


/*****************************************************************************
*
*  Function:   St4200SetIrMode
*
*  Synopsis:   Sets the STIr4200 to the proper operational mode
*
*  Arguments:  pDevice - pointer to current ir device object
*			   mode - mode to set the tranceiver to
*
*  Returns:    NT_STATUS
*
*
*****************************************************************************/
NTSTATUS        
St4200SetIrMode( 
		IN OUT PVOID pDevice,
		ULONG mode 
	)
{
    NTSTATUS		Status;
	PIR_DEVICE		pThisDev = (PIR_DEVICE)pDevice;

	// MS Security bug #538703
	IRUSB_ASSERT(pDevice != NULL);
	
#if !defined(FAST_WRITE_REGISTERS)
    if( (Status = St4200ReadRegisters(pThisDev, STIR4200_MODE_REG, 1)) != STATUS_SUCCESS )
    {
		DEBUGMSG(DBG_ERR, (" St4200SetIrMode(): USB failure\n"));
		goto done;
    }
#endif

	//
	// Remove all mode bits and set the proper mode
	//
	pThisDev->StIrTranceiver.ModeReg &= ~STIR4200_MODE_MASK;
	pThisDev->StIrTranceiver.ModeReg |= STIR4200_MODE_RESET_OFF;

	//
	// Enable the bug fixing feature for LA8
	//
#if defined(SUPPORT_LA8)
	if( pThisDev->ChipRevision >= CHIP_REVISION_8 )
	{
		pThisDev->StIrTranceiver.ModeReg &= ~STIR4200_MODE_AUTO_RESET;
		pThisDev->StIrTranceiver.ModeReg &= ~STIR4200_MODE_BULKIN_FIX;
	}
#endif

    switch( (IR_MODE)mode )
    {
		case IR_MODE_SIR:
#if defined(WORKAROUND_CASIO)
			if( pThisDev->linkSpeedInfo->BitsPerSec != SPEED_9600 )
#endif
				pThisDev->StIrTranceiver.ModeReg |= STIR4200_MODE_BULKIN_FIX;

			pThisDev->StIrTranceiver.ModeReg |= STIR4200_MODE_SIR;
			//pThisDev->StIrTranceiver.ModeReg |= STIR4200_MODE_ASK;
			break;
#if !defined(WORKAROUND_BROKEN_MIR)
		case IR_MODE_MIR:
			pThisDev->MirIncompleteBitCount = 0;
			pThisDev->MirOneBitCount = 0;
			pThisDev->MirIncompleteByte = 0;
			pThisDev->MirFlagCount = 0;
			pThisDev->StIrTranceiver.ModeReg |= STIR4200_MODE_MIR;
			break;
#endif
		case IR_MODE_FIR:
			pThisDev->StIrTranceiver.ModeReg |= STIR4200_MODE_FIR;
#if defined(SUPPORT_LA8)
			if( pThisDev->ChipRevision >= CHIP_REVISION_8 )
			{
				pThisDev->StIrTranceiver.ModeReg |= STIR4200_MODE_BULKIN_FIX;
				pThisDev->StIrTranceiver.ModeReg |= STIR4200_MODE_AUTO_RESET;
			}
#endif
			break;
		default:
			IRUSB_ASSERT( 0 );
    }

#ifdef NO_BULKIN_FIX
	// force clear of mode reg bit 3
	pThisDev->StIrTranceiver.ModeReg &= ~STIR4200_MODE_BULKIN_FIX;
#endif

    if( (Status = St4200WriteRegister(pThisDev, STIR4200_MODE_REG) ) != STATUS_SUCCESS )
    {
		DEBUGMSG(DBG_ERR, (" St4200SetIrMode(): USB failure\n"));
		goto done;
    }

    /***********************************************/
    /*   Set TEMIC transceiver...                  */
    /***********************************************/
#if !defined(FAST_WRITE_REGISTERS)
    if( (Status = St4200ReadRegisters(pThisDev, STIR4200_CONTROL_REG, 1)) != STATUS_SUCCESS )
    {
		DEBUGMSG(DBG_ERR, (" St4200SetIrMode(): USB failure\n"));
		goto done;
    }
#endif

	pThisDev->StIrTranceiver.ControlReg |= STIR4200_CTRL_SDMODE;
    
	if( (Status = St4200WriteRegister(pThisDev, STIR4200_CONTROL_REG)) != STATUS_SUCCESS )
    {
		DEBUGMSG(DBG_ERR, (" St4200SetIrMode(): USB failure\n"));
		goto done;
    }
 
#if !defined(FAST_WRITE_REGISTERS)
    if( (Status = St4200ReadRegisters(pThisDev, STIR4200_CONTROL_REG, 1)) != STATUS_SUCCESS )
    {
		DEBUGMSG(DBG_ERR, (" St4200SetIrMode(): USB failure\n"));
		goto done;
    }
#endif
	
	pThisDev->StIrTranceiver.ControlReg &= (~STIR4200_CTRL_SDMODE);

	if( (Status = St4200WriteRegister(pThisDev, STIR4200_CONTROL_REG)) != STATUS_SUCCESS )
    {
		DEBUGMSG(DBG_ERR, (" St4200SetIrMode(): USB failure\n"));
		goto done;
    }

done:
    return Status;
}

/*****************************************************************************
*
*  Function:   St4200SetSpeed
*
*  Synopsis:   Sets the STIr4200 speed
*
*  Arguments:  pDevice - pointer to current ir device object
*
*  Returns:    NT_STATUS
*
*
*****************************************************************************/
NTSTATUS        
St4200SetSpeed( 
		IN OUT PVOID pDevice
	)
{
    NTSTATUS        Status = STATUS_SUCCESS;
	PIR_DEVICE		pThisDev = (PIR_DEVICE)pDevice;

	// MS Security bug #538703
	IRUSB_ASSERT(pDevice != NULL);	
	
	//
	// MS Security bug #539173
	// These log files need either ACLs restricted to Admin, or need
	// to be put in a admin directory. For now we are punting on this because
	// logging is NEVER turned on in a driver that is released to customers.
	//
#define RECEIVE_LOG_FILE_NAME		L"\\DosDevices\\c:\\receive.log"
#define RECEIVE_ERR_LOG_FILE_NAME	L"\\DosDevices\\c:\\receive_error.log"
#define SEND_LOG_FILE_NAME			L"\\DosDevices\\c:\\send.log"

#if defined(RECEIVE_LOGGING)
	if( pThisDev->linkSpeedInfo->BitsPerSec==SPEED_4000000 )
	{
		IO_STATUS_BLOCK IoStatusBlock;
		OBJECT_ATTRIBUTES ObjectAttributes;
		UNICODE_STRING FileName;
		NTSTATUS Status;

		RtlInitUnicodeString(&FileName, RECEIVE_LOG_FILE_NAME);
		
		InitializeObjectAttributes(
			&ObjectAttributes,
			&FileName,
			// MS Security bug #539151
			OBJ_CASE_INSENSITIVE || OBJ_KERNEL_HANDLE,
			NULL,
			NULL
			);

		// MS Security bug #539093
		if( pThisDev->ReceiveFileHandle )
		{
			ZwClose( pThisDev->ReceiveFileHandle );
		}

		Status=ZwCreateFile(
			   &pThisDev->ReceiveFileHandle,
			   GENERIC_WRITE | SYNCHRONIZE,
			   &ObjectAttributes,
			   &IoStatusBlock,
			   0,
			   FILE_ATTRIBUTE_NORMAL,
			   FILE_SHARE_READ,
			   FILE_OVERWRITE_IF,
			   FILE_SYNCHRONOUS_IO_NONALERT,
			   NULL,
			   0
			   );
		
		pThisDev->ReceiveFilePosition = 0;
	}
	else
	{
		if( pThisDev->ReceiveFileHandle )
		{
			ZwClose( pThisDev->ReceiveFileHandle );
			pThisDev->ReceiveFileHandle = 0;
			pThisDev->ReceiveFilePosition = 0;
		}
	}
#endif
#if defined(RECEIVE_ERROR_LOGGING)
	if( pThisDev->linkSpeedInfo->BitsPerSec==SPEED_4000000 )
	{
		IO_STATUS_BLOCK IoStatusBlock;
		OBJECT_ATTRIBUTES ObjectAttributes;
		UNICODE_STRING FileName;
		NTSTATUS Status;

		RtlInitUnicodeString(&FileName, RECEIVE_ERR_LOG_FILE_NAME);
		
		InitializeObjectAttributes(
			&ObjectAttributes,
			&FileName,
			// MS Security bug #539151
			OBJ_CASE_INSENSITIVE || OBJ_KERNEL_HANDLE,
			NULL,
			NULL
			);

		// MS Security bug #539093
		if( pThisDev->ReceiveErrorFileHandle )
		{
			ZwClose( pThisDev->ReceiveErrorFileHandle );
		}

		Status=ZwCreateFile(
			   &pThisDev->ReceiveErrorFileHandle,
			   GENERIC_WRITE | SYNCHRONIZE,
			   &ObjectAttributes,
			   &IoStatusBlock,
			   0,
			   FILE_ATTRIBUTE_NORMAL,
			   FILE_SHARE_READ,
			   FILE_OVERWRITE_IF,
			   FILE_SYNCHRONOUS_IO_NONALERT,
			   NULL,
			   0
			   );
		
		pThisDev->ReceiveErrorFilePosition = 0;
	}
	else
	{
		if( pThisDev->ReceiveErrorFileHandle )
		{
			ZwClose( pThisDev->ReceiveErrorFileHandle );
			pThisDev->ReceiveErrorFileHandle = 0;
			pThisDev->ReceiveErrorFilePosition = 0;
		}
	}
#endif
#if defined(SEND_LOGGING)
	if( pThisDev->linkSpeedInfo->BitsPerSec==SPEED_4000000 )
	{
		IO_STATUS_BLOCK IoStatusBlock;
		OBJECT_ATTRIBUTES ObjectAttributes;
		UNICODE_STRING FileName;
		NTSTATUS Status;

		RtlInitUnicodeString(&FileName, SEND_LOG_FILE_NAME);
		
		InitializeObjectAttributes(
			&ObjectAttributes,
			&FileName,
			// MS Security bug #539151
			OBJ_CASE_INSENSITIVE || OBJ_KERNEL_HANDLE,
			NULL,
			NULL
			);

		// MS Security bug #539093
		if( pThisDev->SendFileHandle )
		{
			ZwClose( pThisDev->SendFileHandle );
		}

		Status=ZwCreateFile(
			   &pThisDev->SendFileHandle,
			   GENERIC_WRITE | SYNCHRONIZE,
			   &ObjectAttributes,
			   &IoStatusBlock,
			   0,
			   FILE_ATTRIBUTE_NORMAL,
			   FILE_SHARE_READ,
			   FILE_OVERWRITE_IF,
			   FILE_SYNCHRONOUS_IO_NONALERT,
			   NULL,
			   0
			   );
		
		pThisDev->SendFilePosition = 0;
	}
	else
	{
		if( pThisDev->SendFileHandle )
		{
			ZwClose( pThisDev->SendFileHandle );
			pThisDev->SendFileHandle = 0;
			pThisDev->SendFilePosition = 0;
		}
	}
#endif

	//
	// Always force a new tuning
	//
	if( (Status = St4200TuneDpllAndSensitivity(pThisDev, pThisDev->linkSpeedInfo->BitsPerSec)) != STATUS_SUCCESS )
	{
		DEBUGMSG(DBG_ERR, (" St4200TuneDpllAndSensitivity(): USB failure\n"));
		goto done;
	}

	//
	// First power down the modulator
    //
	/*
#if !defined(FAST_WRITE_REGISTERS)
    if( (Status = St4200ReadRegisters(pThisDev, STIR4200_CONTROL_REG, 1)) != STATUS_SUCCESS )
    {
		DEBUGMSG(DBG_ERR, (" St4200SetSpeed(): USB failure\n"));
		goto done;
    }
#endif
    pThisDev->StIrTranceiver.ControlReg |= (STIR4200_CTRL_TXPWD | STIR4200_CTRL_RXPWD);
    if( (Status = St4200WriteRegister(pThisDev, STIR4200_CONTROL_REG)) != STATUS_SUCCESS )
    {
		DEBUGMSG(DBG_ERR, (" St4200SetSpeed(): USB failure\n"));
		goto done;
    }*/

    //
	// Then set baudrate
	//
	pThisDev->StIrTranceiver.BaudrateReg = pThisDev->linkSpeedInfo->Stir4200Divisor;

    if( (Status = St4200WriteRegister(pThisDev, STIR4200_BAUDRATE_REG)) != STATUS_SUCCESS )
    {
		DEBUGMSG(DBG_ERR, (" St4200SetSpeed(): USB failure\n"));
		goto done;
    }

	//
	// We'll have to write the MSB of baud-rate too (only for 2400)
	//
	if( pThisDev->linkSpeedInfo->BitsPerSec == SPEED_2400 )
	{
		pThisDev->StIrTranceiver.ModeReg |= STIR4200_MODE_PDLCK8;
		
		if( (Status = St4200WriteRegister(pThisDev, STIR4200_MODE_REG)) != STATUS_SUCCESS )
		{
			DEBUGMSG(DBG_ERR, (" St4200SetSpeed(): USB failure\n"));
			goto done;
		}
	}
	else
	{
		if( pThisDev->StIrTranceiver.ModeReg & STIR4200_MODE_PDLCK8 )
		{
			pThisDev->StIrTranceiver.ModeReg &= ~STIR4200_MODE_PDLCK8;
			
			if( (Status = St4200WriteRegister(pThisDev, STIR4200_MODE_REG)) != STATUS_SUCCESS )
			{
				DEBUGMSG(DBG_ERR, (" St4200SetSpeed(): USB failure\n"));
				goto done;
			}
		}
	}

	//
	// Modulator back up
    //
	/*pThisDev->StIrTranceiver.ControlReg &= (~(STIR4200_CTRL_TXPWD | STIR4200_CTRL_RXPWD));

	if( (Status = St4200WriteRegister(pThisDev, STIR4200_CONTROL_REG)) != STATUS_SUCCESS )
	{
		DEBUGMSG(DBG_ERR, (" St4200SetSpeed(): USB failure\n"));
		goto done;
	}*/

	//
	// then IR mode
	//
	Status = St4200SetIrMode( pThisDev, pThisDev->linkSpeedInfo->IrMode );

	if( Status != STATUS_SUCCESS )
    {
		DEBUGMSG(DBG_ERR, (" St4200SetSpeed(): USB failure\n"));
		goto done;
    }

	//
	// optionally set the rx line
	//
	if( pThisDev->ReceiveMode == RXMODE_SLOWFAST )
	{
		if( pThisDev->linkSpeedInfo->BitsPerSec == SPEED_4000000 )
		{
			pThisDev->StIrTranceiver.ControlReg &= ~STIR4200_CTRL_RXSLOW;
		}
		else
		{
			pThisDev->StIrTranceiver.ControlReg |= STIR4200_CTRL_RXSLOW;
		}

		if( (Status = St4200WriteRegister(pThisDev, STIR4200_CONTROL_REG)) != STATUS_SUCCESS )
		{
			DEBUGMSG(DBG_ERR, (" St4200SetSpeed(): USB failure\n"));
			goto done;
		}
	}
	else if (pThisDev->ReceiveMode == RXMODE_SLOW )
	{
		pThisDev->StIrTranceiver.ControlReg |= STIR4200_CTRL_RXSLOW;

		if( (Status = St4200WriteRegister(pThisDev, STIR4200_CONTROL_REG)) != STATUS_SUCCESS )
		{
			DEBUGMSG(DBG_ERR, (" St4200SetSpeed(): USB failure\n"));
			goto done;
		}
	}

	//
	// Program the receive delay for FIR
	//
	if( pThisDev->linkSpeedInfo->BitsPerSec == SPEED_4000000 )
	{
		if( pThisDev->dongleCaps.windowSize == 2 )
			pThisDev->ReceiveAdaptiveDelay = STIR4200_MULTIPLE_READ_DELAY;
		else
			pThisDev->ReceiveAdaptiveDelay = 0;
		pThisDev->ReceiveAdaptiveDelayBoost = 0;
	}

#if defined(WORKAROUND_GEAR_DOWN)
	//
	// Force a reset if going to 9600 from 4M
	//
	pThisDev->GearedDown = FALSE;
	if( pThisDev->linkSpeedInfo->BitsPerSec==SPEED_9600 && pThisDev->currentSpeed==SPEED_4000000 )
	{		
		St4200ResetFifo( pThisDev );
		pThisDev->GearedDown = TRUE;		
	}
#endif

done:
    return Status;
}


/*****************************************************************************
*
*  Function:   St4200GetFifoCount
*
*  Synopsis:   Verifies if there is data to be received
*
*  Arguments:  pDevice - pointer to current ir device object
*			   pCountFifo - pointer to variable to return FIFO count
*
*  Returns:    NT_STATUS
*
*
*****************************************************************************/
NTSTATUS        
St4200GetFifoCount( 
		IN PVOID pDevice,
		OUT PULONG pCountFifo
	)
{
    NTSTATUS		Status = STATUS_SUCCESS;
	PIR_DEVICE		pThisDev = (PIR_DEVICE)pDevice;

 	// MS Security bug #538703
	IRUSB_ASSERT(pDevice != NULL);
	IRUSB_ASSERT(pCountFifo != NULL);
	
   *pCountFifo = 0;
	if( pThisDev->PreFifoCount )
	{
		*pCountFifo = pThisDev->PreFifoCount;
	}
	else
	{
		Status = St4200ReadRegisters( pThisDev, STIR4200_FIFOCNT_LSB_REG, 2 );

		if( Status == STATUS_SUCCESS )
		{
			*pCountFifo = 
				((ULONG)MAKEUSHORT(pThisDev->StIrTranceiver.FifoCntLsbReg, pThisDev->StIrTranceiver.FifoCntMsbReg));
		}
	}

	pThisDev->PreFifoCount = 0;
    return Status;
}


/*****************************************************************************
*
*  Function:   St4200TuneDpllAndSensitivity
*
*  Synopsis:   tunes the DPLL and sensitivity registers
*
*  Arguments:  pDevice - pointer to current ir device object
*			   Speed - speed to tune for
*
*  Returns:    NT_STATUS
*
*
*****************************************************************************/
NTSTATUS        
St4200TuneDpllAndSensitivity(
		IN OUT PVOID pDevice,
		ULONG Speed
	)
{
    NTSTATUS		Status;
	PIR_DEVICE		pThisDev = (PIR_DEVICE)pDevice;

	// MS Security bug #538703
	IRUSB_ASSERT(pDevice != NULL);
	
#if !defined(FAST_WRITE_REGISTERS)
    //
	// Read the current value of the DPLL
	//
	if( (Status = St4200ReadRegisters(pThisDev, STIR4200_DPLLTUNE_REG, 1)) != STATUS_SUCCESS )
    {
		DEBUGMSG(DBG_ERR, (" St4200TuneDpllAndSensitivity(): USB failure\n"));
		goto done;
    }
#endif

	//
	// Tune the DPLL according to the installed transceiver
	//
    switch( pThisDev->TransceiverType )
	{
		case TRANSCEIVER_HP:
			pThisDev->StIrTranceiver.DpllTuneReg = STIR4200_DPLL_DESIRED_HP;
			break;
		case TRANSCEIVER_INFINEON:
			pThisDev->StIrTranceiver.DpllTuneReg = STIR4200_DPLL_DESIRED_INFI;
			break;
		case TRANSCEIVER_VISHAY:
			pThisDev->StIrTranceiver.DpllTuneReg = STIR4200_DPLL_DESIRED_VISHAY;
			break;
		case TRANSCEIVER_VISHAY_6102F:
			pThisDev->StIrTranceiver.DpllTuneReg = STIR4200_DPLL_DESIRED_VISHAY_6102F;
			break;
		case TRANSCEIVER_4000:
			pThisDev->StIrTranceiver.DpllTuneReg = STIR4200_DPLL_DESIRED_4000;
			break;
		case TRANSCEIVER_4012:
			switch( Speed )
			{
				case SPEED_9600:
				case SPEED_19200:
				case SPEED_38400:
				case SPEED_57600:
				case SPEED_115200:
					pThisDev->StIrTranceiver.DpllTuneReg = STIR4200_DPLL_DESIRED_4012_SIR; 
					break;
				case SPEED_4000000:
					pThisDev->StIrTranceiver.DpllTuneReg = STIR4200_DPLL_DESIRED_4012_FIR; 
					break;
				default:
					pThisDev->StIrTranceiver.DpllTuneReg = STIR4200_DPLL_DESIRED_4012;
					break;
			}
			break;
		case TRANSCEIVER_CUSTOM:
		default:
			switch( Speed )
			{
				case SPEED_9600:
				case SPEED_19200:
				case SPEED_38400:
				case SPEED_57600:
				case SPEED_115200:
#if defined(VARIABLE_SETTINGS)
					pThisDev->StIrTranceiver.DpllTuneReg = (UCHAR)pThisDev->SirDpll;
#else					
					pThisDev->StIrTranceiver.DpllTuneReg = STIR4200_DPLL_DESIRED_CUSTOM_SIR; 
#endif
					break;
				case SPEED_4000000:
#if defined(VARIABLE_SETTINGS)
					pThisDev->StIrTranceiver.DpllTuneReg = (UCHAR)pThisDev->FirDpll;
#else
					pThisDev->StIrTranceiver.DpllTuneReg = STIR4200_DPLL_DESIRED_CUSTOM_FIR; 
#endif
					break;
				default:
					pThisDev->StIrTranceiver.DpllTuneReg = STIR4200_DPLL_DESIRED_CUSTOM;
					break;
			}
			break;
	}

    if( (Status = St4200WriteRegister(pThisDev, STIR4200_DPLLTUNE_REG)) != STATUS_SUCCESS )
    {
		DEBUGMSG(DBG_ERR, (" St4200TuneDpllAndSensitivity(): USB failure\n"));
		goto done;
    }

#if !defined(FAST_WRITE_REGISTERS)
    //
	// Read the current value of the sensitivity
	//
	if( (Status = St4200ReadRegisters(pThisDev, STIR4200_SENSITIVITY_REG, 1)) != STATUS_SUCCESS )
    {
		DEBUGMSG(DBG_ERR, (" St4200TuneDpllAndSensitivity(): USB failure\n"));
		goto done;
    }
#endif

	//
	// Tune the sensitivity
	//
    switch( pThisDev->TransceiverType )
	{
		case TRANSCEIVER_HP:
			switch( Speed )
			{
				default:
				case SPEED_9600:
				case SPEED_19200:
				case SPEED_38400:
				case SPEED_57600:
				case SPEED_115200:
					pThisDev->StIrTranceiver.SensitivityReg = STIR4200_SENS_RXDSNS_HP_SIR;
					break;
				case SPEED_4000000:
					pThisDev->StIrTranceiver.SensitivityReg = STIR4200_SENS_RXDSNS_HP_FIR;
					break;
			}
			break;
		case TRANSCEIVER_INFINEON:
			switch( Speed )
			{
				default:
				case SPEED_9600:
				case SPEED_19200:
				case SPEED_38400:
				case SPEED_57600:
				case SPEED_115200:
					pThisDev->StIrTranceiver.SensitivityReg = STIR4200_SENS_RXDSNS_INFI_SIR;
					break;
				case SPEED_4000000:
					pThisDev->StIrTranceiver.SensitivityReg = STIR4200_SENS_RXDSNS_INFI_FIR;
					break;
			}
			break;
			case TRANSCEIVER_VISHAY_6102F:
			switch( Speed )
			{
				default:
				case SPEED_9600:
				case SPEED_19200:
				case SPEED_38400:
				case SPEED_57600:
				case SPEED_115200:
					pThisDev->StIrTranceiver.SensitivityReg = STIR4200_SENS_RXDSNS_VISHAY_6102F_SIR;
					break;
				case SPEED_4000000:
					pThisDev->StIrTranceiver.SensitivityReg = STIR4200_SENS_RXDSNS_VISHAY_6102F_FIR;
					break;
			}
			break;
		case TRANSCEIVER_VISHAY:
			pThisDev->StIrTranceiver.SensitivityReg = STIR4200_SENS_RXDSNS_DEFAULT;
			break;
		case TRANSCEIVER_4000:
			pThisDev->StIrTranceiver.SensitivityReg = STIR4200_SENS_RXDSNS_DEFAULT;
			break;
		case TRANSCEIVER_4012:
			switch( Speed )
			{
				default:
				case SPEED_9600:
					pThisDev->StIrTranceiver.SensitivityReg = STIR4200_SENS_RXDSNS_4012_SIR_9600;
					break;
				case SPEED_19200:
				case SPEED_38400:
				case SPEED_57600:
				case SPEED_115200:
					pThisDev->StIrTranceiver.SensitivityReg = STIR4200_SENS_RXDSNS_4012_SIR;
					break;
				case SPEED_4000000:
					pThisDev->StIrTranceiver.SensitivityReg = STIR4200_SENS_RXDSNS_4012_FIR;
					break;
			}
			break;
		case TRANSCEIVER_CUSTOM:
		default:
			switch( Speed )
			{
				default:
				case SPEED_9600:
#if defined(VARIABLE_SETTINGS)
					pThisDev->StIrTranceiver.SensitivityReg = (UCHAR)pThisDev->SirSensitivity;
#else
					pThisDev->StIrTranceiver.SensitivityReg = STIR4200_SENS_RXDSNS_CUSTOM_SIR_9600;
#endif
					break;
				case SPEED_19200:
				case SPEED_38400:
				case SPEED_57600:
				case SPEED_115200:
#if defined(VARIABLE_SETTINGS)
					pThisDev->StIrTranceiver.SensitivityReg = (UCHAR)pThisDev->SirSensitivity;
#else
					pThisDev->StIrTranceiver.SensitivityReg = STIR4200_SENS_RXDSNS_CUSTOM_SIR;
#endif
					break;
				case SPEED_4000000:
#if defined(VARIABLE_SETTINGS)
					pThisDev->StIrTranceiver.SensitivityReg = (UCHAR)pThisDev->FirSensitivity;
#else
					pThisDev->StIrTranceiver.SensitivityReg = STIR4200_SENS_RXDSNS_CUSTOM_FIR;
#endif
					break;
			}
			break;
	}
    if( (Status = St4200WriteRegister(pThisDev, STIR4200_SENSITIVITY_REG)) != STATUS_SUCCESS )
    {
		DEBUGMSG(DBG_ERR, (" St4200TuneDpllAndSensitivity(): USB failure\n"));
		goto done;
    }


done:
    return Status;
}


/*****************************************************************************
*
*  Function:   St4200EnableOscillatorPowerDown
*
*  Synopsis:   enable the oscillator to power down when we go into suspend mode
*
*  Arguments:  pDevice - pointer to current ir device object
*
*  Returns:    NT_STATUS
*
*
*****************************************************************************/
NTSTATUS        
St4200EnableOscillatorPowerDown(
		IN OUT PVOID pDevice
	)
{
    NTSTATUS		Status;
	PIR_DEVICE		pThisDev = (PIR_DEVICE)pDevice;

	// MS Security bug #538703
	IRUSB_ASSERT(pDevice != NULL);
	
#if !defined(FAST_WRITE_REGISTERS)
    //
	// Read the current value
	//
	if( (Status = St4200ReadRegisters(pThisDev, pThisDev, 1)) != STATUS_SUCCESS )
    {
		DEBUGMSG(DBG_ERR, (" St4200EnableOscillatorPowerDown(): USB failure\n"));
		goto done;
    }
#endif

	//
	// Enable
	//
    pThisDev->StIrTranceiver.TestReg |= STIR4200_TEST_EN_OSC_SUSPEND;
    if( (Status = St4200WriteRegister(pThisDev, STIR4200_TEST_REG)) != STATUS_SUCCESS )
    {
		DEBUGMSG(DBG_ERR, (" St4200EnableOscillatorPowerDown(): USB failure\n"));
		goto done;
    }

done:
    return Status;
}


/*****************************************************************************
*
*  Function:   St4200TurnOnSuspend
*
*  Synopsis:   prepares the part to go into suspend mode
*
*  Arguments:  pDevice - pointer to current ir device object
*
*  Returns:    NT_STATUS
*
*
*****************************************************************************/
NTSTATUS        
St4200TurnOnSuspend(
		IN OUT PVOID pDevice
	)
{
    NTSTATUS		Status;
	PIR_DEVICE		pThisDev = (PIR_DEVICE)pDevice;

	// MS Security bug #538703
	IRUSB_ASSERT(pDevice != NULL);
	
#if !defined(FAST_WRITE_REGISTERS)
    //
	// Read the current value
	//
	if( (Status = St4200ReadRegisters(pThisDev, STIR4200_CONTROL_REG, 1)) != STATUS_SUCCESS )
    {
		DEBUGMSG(DBG_ERR, (" St4200TurnOnSuspend(): USB failure\n"));
		goto done;
    }
#endif

	//
	// Control UOUT
	//
    pThisDev->StIrTranceiver.ControlReg |= STIR4200_CTRL_SDMODE;
    if( (Status = St4200WriteRegister(pThisDev, STIR4200_CONTROL_REG)) != STATUS_SUCCESS )
    {
		DEBUGMSG(DBG_ERR, (" St4200TurnOnSuspend(): USB failure\n"));
		goto done;
    }

done:
    return Status;
}


/*****************************************************************************
*
*  Function:   St4200TurnOffSuspend
*
*  Synopsis:   prepares the part to go back into operational mode
*
*  Arguments:  pDevice - pointer to current ir device object
*
*  Returns:    NT_STATUS
*
*
*****************************************************************************/
NTSTATUS        
St4200TurnOffSuspend(
		IN OUT PVOID pDevice
	)
{
    NTSTATUS		Status;
	PIR_DEVICE		pThisDev = (PIR_DEVICE)pDevice;

	// MS Security bug #538703
	IRUSB_ASSERT(pDevice != NULL);
	
#if !defined(FAST_WRITE_REGISTERS)
    //
	// Read the current value
	//
	if( (Status = St4200ReadRegisters(pThisDev, STIR4200_CONTROL_REG, 1)) != STATUS_SUCCESS )
    {
		DEBUGMSG(DBG_ERR, (" St4200TurnOffSuspend(): USB failure\n"));
		goto done;
    }
#endif

	//
	// Control UOUT
	//
    pThisDev->StIrTranceiver.ControlReg &= ~STIR4200_CTRL_SDMODE;
    if( (Status = St4200WriteRegister(pThisDev, STIR4200_CONTROL_REG)) != STATUS_SUCCESS )
    {
		DEBUGMSG(DBG_ERR, (" St4200TurnOffSuspend(): USB failure\n"));
		goto done;
    }

done:
    return Status;
}


/*****************************************************************************
*
*  Function:   St4200TurnOffReceiver
*
*  Synopsis:   turns of the STIr4200 receiver
*
*  Arguments:  pDevice - pointer to current ir device object
*
*  Returns:    NT_STATUS
*
*
*****************************************************************************/
NTSTATUS        
St4200TurnOffReceiver(
		IN OUT PVOID pDevice
	)
{
    NTSTATUS		Status;
	PIR_DEVICE		pThisDev = (PIR_DEVICE)pDevice;

	// MS Security bug #538703
	IRUSB_ASSERT(pDevice != NULL);
	
#if !defined(FAST_WRITE_REGISTERS)
    //
	// Read the current value
	//
	if( (Status = St4200ReadRegisters(pThisDev, STIR4200_CONTROL_REG, 1)) != STATUS_SUCCESS )
    {
		DEBUGMSG(DBG_ERR, (" St4200TurnOffReceiver(): USB failure\n"));
		goto done;
    }
#endif

	//
	// Turn off receiver
	//
    pThisDev->StIrTranceiver.ControlReg |= STIR4200_CTRL_RXPWD;
    if( (Status = St4200WriteRegister(pThisDev, STIR4200_CONTROL_REG)) != STATUS_SUCCESS )
    {
		DEBUGMSG(DBG_ERR, (" St4200TurnOffReceiver(): USB failure\n"));
		goto done;
    }

done:
    return Status;
}


/*****************************************************************************
*
*  Function:   St4200TurnOnReceiver
*
*  Synopsis:   turns on the STIr4200 receiver
*
*  Arguments:  pDevice - pointer to current ir device object
*
*  Returns:    NT_STATUS
*
*
*****************************************************************************/
NTSTATUS        
St4200TurnOnReceiver(
		IN OUT PVOID pDevice
	)
{
    NTSTATUS		Status;
	PIR_DEVICE		pThisDev = (PIR_DEVICE)pDevice;

	// MS Security bug #538703
	IRUSB_ASSERT(pDevice != NULL);
	
#if !defined(FAST_WRITE_REGISTERS)
    //
	// Read the current value
	//
	if( (Status = St4200ReadRegisters(pThisDev, STIR4200_CONTROL_REG, 1)) != STATUS_SUCCESS )
    {
		DEBUGMSG(DBG_ERR, (" St4200TurnOnReceiver(): USB failure\n"));
		goto done;
    }
#endif

	//
	// Turn on receiver
	//
    pThisDev->StIrTranceiver.ControlReg &= ~STIR4200_CTRL_RXPWD;
    if( (Status = St4200WriteRegister(pThisDev, STIR4200_CONTROL_REG)) != STATUS_SUCCESS )
    {
		DEBUGMSG(DBG_ERR, (" St4200TurnOnReceiver(): USB failure\n"));
		goto done;
    }

done:
    return Status;
}


/*****************************************************************************
*
*  Function:	St4200WriteMultipleRegisters
*
*  Synopsis:	reads multiple registers from the tranceiver
*
*  Arguments:	pDevice - pointer to current ir device object
*				FirstRegister - first register to write
*				RegistersToWrite - number of registers
*				
*  Returns:		NT_STATUS
*
*
*****************************************************************************/
NTSTATUS        
St4200WriteMultipleRegisters(
		IN PVOID pDevice,
		UCHAR FirstRegister, 
		UCHAR RegistersToWrite
	)
{
    NTSTATUS            status = STATUS_SUCCESS;
	PIRUSB_CONTEXT		pThisContext;
    PURB				pUrb = NULL;
    PDEVICE_OBJECT		pUrbTargetDev;
    PIO_STACK_LOCATION	pNextStack;
    PIRP                pIrp;
	PIR_DEVICE			pThisDev = (PIR_DEVICE)pDevice;
	PLIST_ENTRY			pListEntry;

	DEBUGMSG(DBG_FUNC, ("+St4200WriteMultipleRegisters\n"));

	// MS Security bug #538703
	IRUSB_ASSERT(pDevice != NULL);
	
    IRUSB_ASSERT( KeGetCurrentIrql() == PASSIVE_LEVEL );

	//
	// Make sure there isn't a halt/reset going on
	//
	if( pThisDev->fPendingHalt || pThisDev->fPendingReset || pThisDev->fPendingClearTotalStall ) 
	{
        DEBUGMSG(DBG_ERR, (" St4200WriteMultipleRegisters abort due to pending reset\n"));

		status = STATUS_UNSUCCESSFUL;
		goto done;
	}
		
	//
	// Validate the parameters
	//
	if( (FirstRegister+RegistersToWrite)>(STIR4200_MAX_REG+1) )
	{
        DEBUGMSG(DBG_ERR, (" St4200WriteMultipleRegisters invalid input parameters\n"));

        status = STATUS_UNSUCCESSFUL;
        goto done;
	}

	pListEntry = ExInterlockedRemoveHeadList( &pThisDev->SendAvailableQueue, &pThisDev->SendLock );

	if( NULL == pListEntry )
    {
        //
		// This must not happen
		//
        DEBUGMSG(DBG_ERR, (" St4200WriteMultipleRegisters failed to find a free context struct\n"));
		IRUSB_ASSERT( 0 );

        status = STATUS_UNSUCCESSFUL;
        goto done;
    }
	
	InterlockedDecrement( &pThisDev->SendAvailableCount );

	pThisContext = CONTAINING_RECORD( pListEntry, IRUSB_CONTEXT, ListEntry );
	pThisContext->ContextType = CONTEXT_READ_WRITE_REGISTER;

	//
	// MS Security recommendation - allocate a new urb.
	//
	pThisContext->UrbLen = sizeof( struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST );
	pThisContext->pUrb = MyUrbAlloc(pThisContext->UrbLen);
	if (pThisContext->pUrb == NULL)
	{
        DEBUGMSG(DBG_ERR, (" St4200WriteMultipleRegisters abort due to urb alloc failure\n"));
		goto done;
	}
	pUrb = pThisContext->pUrb;

	//
    // Now that we have created the urb, we will send a
    // request to the USB device object.
    //
    pUrbTargetDev = pThisDev->pUsbDevObj;

	//
	// make an irp sending to usbhub
	//
	pIrp = IoAllocateIrp( (CCHAR)(pThisDev->pUsbDevObj->StackSize + 1), FALSE );

    if( NULL == pIrp )
    {
        DEBUGMSG(DBG_ERR, (" St4200WriteMultipleRegisters failed to alloc IRP\n"));

		ExInterlockedInsertTailList(
				&pThisDev->SendAvailableQueue,
				&pThisContext->ListEntry,
				&pThisDev->SendLock
			);
		InterlockedIncrement( &pThisDev->SendAvailableCount );
		MyUrbFree(pThisContext->pUrb, pThisContext->UrbLen);
		pThisContext->pUrb = NULL;
        status = STATUS_UNSUCCESSFUL;
        goto done;
    }

    pIrp->IoStatus.Status = STATUS_PENDING;
    pIrp->IoStatus.Information = 0;

	pThisContext->pIrp = pIrp;

	//
	// Build our URB for USBD
	//
    pUrb->UrbControlVendorClassRequest.Hdr.Length = (USHORT)sizeof( struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST );
    pUrb->UrbControlVendorClassRequest.Hdr.Function = URB_FUNCTION_VENDOR_DEVICE;
    pUrb->UrbControlVendorClassRequest.TransferFlags = USBD_TRANSFER_DIRECTION_OUT;
    // short packet is not treated as an error.
    pUrb->UrbControlVendorClassRequest.TransferFlags |= USBD_SHORT_TRANSFER_OK;
    pUrb->UrbControlVendorClassRequest.UrbLink = NULL;
    pUrb->UrbControlVendorClassRequest.TransferBufferMDL = NULL;
    pUrb->UrbControlVendorClassRequest.TransferBuffer = &(pThisDev->StIrTranceiver.FifoDataReg)+FirstRegister;
    pUrb->UrbControlVendorClassRequest.TransferBufferLength = RegistersToWrite;
	pUrb->UrbControlVendorClassRequest.Request = STIR4200_WRITE_REGS_REQ;
	pUrb->UrbControlVendorClassRequest.RequestTypeReservedBits = 0;
	pUrb->UrbControlVendorClassRequest.Index = FirstRegister;

	//
	// Call the class driver to perform the operation.
	//
    pNextStack = IoGetNextIrpStackLocation( pIrp );

    IRUSB_ASSERT( pNextStack != NULL );

    //
    // pass the URB to the USB driver stack
    //
	pNextStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
	pNextStack->Parameters.Others.Argument1 = pUrb;
	pNextStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_INTERNAL_USB_SUBMIT_URB;

	IoSetCompletionRoutine(
			pIrp,							// irp to use
			St4200CompleteReadWriteRequest,	// routine to call when irp is done
			DEV_TO_CONTEXT(pThisContext),	// context to pass routine
			TRUE,							// call on success
			TRUE,							// call on error
			TRUE							// call on cancel
		);

	KeClearEvent( &pThisDev->EventSyncUrb );

	//
    // Call IoCallDriver to send the irp to the usb port.
    //
	ExInterlockedInsertTailList(
			&pThisDev->ReadWritePendingQueue,
			&pThisContext->ListEntry,
			&pThisDev->SendLock
		);
	InterlockedIncrement( &pThisDev->ReadWritePendingCount );
    status = MyIoCallDriver( pThisDev, pUrbTargetDev, pIrp );

    //
    // The USB driver should always return STATUS_PENDING when
    // it receives a write irp
    //
    if( (status == STATUS_PENDING) || (status == STATUS_SUCCESS) )
	{
        // wait, but dump out on timeout
        if( status == STATUS_PENDING )
		{
            status = MyKeWaitForSingleObject( pThisDev, &pThisDev->EventSyncUrb, 0 );

            if( status == STATUS_TIMEOUT ) 
			{
				KIRQL OldIrql;

				DEBUGMSG( DBG_ERR,(" St4200WriteMultipleRegisters() TIMED OUT! return from IoCallDriver USBD %x\n", status));
				KeAcquireSpinLock( &pThisDev->SendLock, &OldIrql );
				RemoveEntryList( &pThisContext->ListEntry );
				KeReleaseSpinLock( &pThisDev->SendLock, OldIrql );
				InterlockedDecrement( &pThisDev->ReadWritePendingCount );
				// MS Security recommendation - cannot cancel IRP.
            }
        }
    } 
	else 
	{
        DEBUGMSG( DBG_ERR, (" St4200WriteMultipleRegisters IoCallDriver FAILED(%x)\n",status));
		IRUSB_ASSERT( status == STATUS_PENDING );
	}

done:
    DEBUGMSG(DBG_FUNC, ("-St4200WriteMultipleRegisters\n"));
    return status;
}


/*****************************************************************************
*
*  Function:	St4200WriteRegister
*
*  Synopsis:	writes a STIr4200 register
*
*  Arguments:	pDevice - pointer to current ir device object
*				FirstRegister - first register to write
*
*  Returns:		NT_STATUS
*
*
*****************************************************************************/
NTSTATUS        
St4200WriteRegister(
		IN PVOID pDevice,
		UCHAR RegisterToWrite
	)
{
    NTSTATUS            status = STATUS_SUCCESS;
	PIRUSB_CONTEXT		pThisContext;
    PURB				pUrb = NULL;
    PDEVICE_OBJECT		pUrbTargetDev;
    PIO_STACK_LOCATION	pNextStack;
    PIRP                pIrp;
	PIR_DEVICE			pThisDev = (PIR_DEVICE)pDevice;
	PLIST_ENTRY			pListEntry;

	DEBUGMSG(DBG_FUNC, ("+St4200WriteRegister\n"));

 	// MS Security bug #538703
	IRUSB_ASSERT(pDevice != NULL);
	
    IRUSB_ASSERT( KeGetCurrentIrql() == PASSIVE_LEVEL );

	//
	// Make sure there isn't a halt/reset going on
	//
	if( pThisDev->fPendingHalt || pThisDev->fPendingReset || pThisDev->fPendingClearTotalStall ) 
	{
        DEBUGMSG(DBG_ERR, (" St4200WriteRegister abort due to pending reset\n"));

		status = STATUS_UNSUCCESSFUL;
		goto done;
	}
		
	//
	// Validate the parameters
	//
	if( RegisterToWrite>STIR4200_MAX_REG )
	{
        DEBUGMSG(DBG_ERR, (" St4200WriteRegister invalid input parameters\n"));

        status = STATUS_UNSUCCESSFUL;
        goto done;
	}

	pListEntry = ExInterlockedRemoveHeadList( &pThisDev->SendAvailableQueue, &pThisDev->SendLock );

	if( NULL == pListEntry )
    {
        //
		// This must not happen
		//
        DEBUGMSG(DBG_ERR, (" St4200WriteRegister failed to find a free context struct\n"));
		IRUSB_ASSERT( 0 );

        status = STATUS_UNSUCCESSFUL;
        goto done;
    }
	
	InterlockedDecrement( &pThisDev->SendAvailableCount );

	pThisContext = CONTAINING_RECORD( pListEntry, IRUSB_CONTEXT, ListEntry );
	pThisContext->ContextType = CONTEXT_READ_WRITE_REGISTER;

	//
	// MS Security recommendation - allocate a new urb.
	//
	pThisContext->UrbLen = sizeof( struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST );
	pThisContext->pUrb = MyUrbAlloc(pThisContext->UrbLen);
	if (pThisContext->pUrb == NULL)
	{
        DEBUGMSG(DBG_ERR, (" St4200WriteMultipleRegisters abort due to urb alloc failure\n"));
		goto done;
	}
	pUrb = pThisContext->pUrb;

	//
    // Now that we have created the urb, we will send a
    // request to the USB device object.
    //
    pUrbTargetDev = pThisDev->pUsbDevObj;

	//
	// make an irp sending to usbhub
	//
	pIrp = IoAllocateIrp( (CCHAR)(pThisDev->pUsbDevObj->StackSize + 1), FALSE );

    if( NULL == pIrp )
    {
        DEBUGMSG(DBG_ERR, (" St4200WriteRegister failed to alloc IRP\n"));

 		MyUrbFree(pThisContext->pUrb, pThisContext->UrbLen);
		pThisContext->pUrb = NULL;
		ExInterlockedInsertTailList(
				&pThisDev->SendAvailableQueue,
				&pThisContext->ListEntry,
				&pThisDev->SendLock
			);
		InterlockedIncrement( &pThisDev->SendAvailableCount );
        status = STATUS_UNSUCCESSFUL;
       goto done;
    }

    pIrp->IoStatus.Status = STATUS_PENDING;
    pIrp->IoStatus.Information = 0;

	pThisContext->pIrp = pIrp;

	//
	// Build our URB for USBD
	//
    pUrb->UrbControlVendorClassRequest.Hdr.Length = (USHORT) sizeof( struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST );
    pUrb->UrbControlVendorClassRequest.Hdr.Function = URB_FUNCTION_VENDOR_DEVICE;
    pUrb->UrbControlVendorClassRequest.TransferFlags = USBD_TRANSFER_DIRECTION_OUT;
    // short packet is not treated as an error.
    pUrb->UrbControlVendorClassRequest.TransferFlags |= USBD_SHORT_TRANSFER_OK;
    pUrb->UrbControlVendorClassRequest.UrbLink = NULL;
    pUrb->UrbControlVendorClassRequest.TransferBufferMDL = NULL;
    pUrb->UrbControlVendorClassRequest.Value = *(&pThisDev->StIrTranceiver.FifoDataReg+RegisterToWrite);
	pUrb->UrbControlVendorClassRequest.Request = STIR4200_WRITE_REG_REQ;
	pUrb->UrbControlVendorClassRequest.RequestTypeReservedBits = 0;
	pUrb->UrbControlVendorClassRequest.Index = RegisterToWrite;

	//
	// Call the class driver to perform the operation.
	//
    pNextStack = IoGetNextIrpStackLocation( pIrp );

    IRUSB_ASSERT( pNextStack != NULL );

    //
    // pass the URB to the USB driver stack
    //
	pNextStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
	pNextStack->Parameters.Others.Argument1 = pUrb;
	pNextStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_INTERNAL_USB_SUBMIT_URB;

	IoSetCompletionRoutine(
			pIrp,							// irp to use
			St4200CompleteReadWriteRequest,	// routine to call when irp is done
			DEV_TO_CONTEXT(pThisContext),	// context to pass routine
			TRUE,							// call on success
			TRUE,							// call on error
			TRUE							// call on cancel
		);

	KeClearEvent( &pThisDev->EventSyncUrb );

	//
    // Call IoCallDriver to send the irp to the usb port.
    //
	ExInterlockedInsertTailList(
			&pThisDev->ReadWritePendingQueue,
			&pThisContext->ListEntry,
			&pThisDev->SendLock
		);
	InterlockedIncrement( &pThisDev->ReadWritePendingCount );
    status = MyIoCallDriver( pThisDev, pUrbTargetDev, pIrp );

    //
    // The USB driver should always return STATUS_PENDING when
    // it receives a write irp
    //
    if( (status == STATUS_PENDING) || (status == STATUS_SUCCESS) )
	{
        // wait, but dump out on timeout
        if( status == STATUS_PENDING )
		{
            status = MyKeWaitForSingleObject( pThisDev, &pThisDev->EventSyncUrb, 0 );

            if( status == STATUS_TIMEOUT ) 
			{
				KIRQL OldIrql;

				DEBUGMSG( DBG_ERR,(" St4200WriteRegister() TIMED OUT! return from IoCallDriver USBD %x\n", status));
				KeAcquireSpinLock( &pThisDev->SendLock, &OldIrql );
				RemoveEntryList( &pThisContext->ListEntry );
				KeReleaseSpinLock( &pThisDev->SendLock, OldIrql );
				InterlockedDecrement( &pThisDev->ReadWritePendingCount );
				// MS Security recommendation - cannot cancel IRP.
            }
        }
    } 
	else 
	{
        DEBUGMSG( DBG_ERR, (" St4200WriteRegister IoCallDriver FAILED(%x)\n",status));
		IRUSB_ASSERT( status == STATUS_PENDING );
	}

done:
    DEBUGMSG(DBG_FUNC, ("-St4200WriteRegister\n"));
    return status;
}


/*****************************************************************************
*
*  Function:	St4200ReadRegisters
*
*  Synopsis:	reads multiple STIr4200 register
*
*  Arguments:	pDevice - pointer to current ir device object
*				FirstRegister - first register to read
*				RegistersToWrite - number of registers to read
*
*  Returns:		NT_STATUS
*
*
*****************************************************************************/
NTSTATUS
St4200ReadRegisters(
		IN OUT PVOID pDevice,
		UCHAR FirstRegister, 
		UCHAR RegistersToRead
	)
{
    NTSTATUS            status = STATUS_SUCCESS;
	PIRUSB_CONTEXT		pThisContext;
    PURB				pUrb = NULL;
    PDEVICE_OBJECT		pUrbTargetDev;
    PIO_STACK_LOCATION	pNextStack;
    PIRP                pIrp;
	PIR_DEVICE			pThisDev = (PIR_DEVICE)pDevice;
	PLIST_ENTRY			pListEntry;

	DEBUGMSG(DBG_FUNC, ("+St4200ReadRegisters\n"));

 	// MS Security bug #538703
	IRUSB_ASSERT(pDevice != NULL);
	
    IRUSB_ASSERT( KeGetCurrentIrql() == PASSIVE_LEVEL );

	//
	// Make sure there isn't a halt/reset going on
	//
	if( pThisDev->fPendingHalt || pThisDev->fPendingReset || pThisDev->fPendingClearTotalStall ) 
	{
        DEBUGMSG(DBG_ERR, (" St4200ReadRegisters abort due to pending reset\n"));

		status = STATUS_UNSUCCESSFUL;
		goto done;
	}

	//
	// Validate the parameters
	//
	if( (FirstRegister+RegistersToRead)>(STIR4200_MAX_REG+1) )
	{
        DEBUGMSG(DBG_ERR, (" St4200ReadRegisters invalid input parameters\n"));

        status = STATUS_UNSUCCESSFUL;
        goto done;
	}

	pListEntry = ExInterlockedRemoveHeadList( &pThisDev->SendAvailableQueue, &pThisDev->SendLock );

	if( NULL == pListEntry )
    {
        //
		// This must not happen
		//
		DEBUGMSG(DBG_ERR, (" St4200ReadRegisters failed to find a free context struct\n"));
		IRUSB_ASSERT( 0 );

        status = STATUS_UNSUCCESSFUL;
        goto done;
    }

	InterlockedDecrement( &pThisDev->SendAvailableCount );
	
	pThisContext = CONTAINING_RECORD( pListEntry, IRUSB_CONTEXT, ListEntry );
	pThisContext->ContextType = CONTEXT_READ_WRITE_REGISTER;

	//
	// MS Security recommendation - allocate a new urb.
	//
	pThisContext->UrbLen = sizeof( struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST );
	pThisContext->pUrb = MyUrbAlloc(pThisContext->UrbLen);
	if (pThisContext->pUrb == NULL)
	{
        DEBUGMSG(DBG_ERR, (" St4200ReadRegisters abort due to urb alloc failure\n"));
		goto done;
	}
	pUrb = pThisContext->pUrb;

	//
    // Now that we have created the urb, we will send a
    // request to the USB device object.
    //
    pUrbTargetDev = pThisDev->pUsbDevObj;

	//
	// make an irp sending to usbhub
	//
	pIrp = IoAllocateIrp( (CCHAR)(pThisDev->pUsbDevObj->StackSize + 1), FALSE );

    if( NULL == pIrp )
    {
        DEBUGMSG(DBG_ERR, (" St4200ReadRegisters failed to alloc IRP\n"));

 		MyUrbFree(pThisContext->pUrb, pThisContext->UrbLen);
		pThisContext->pUrb = NULL;
		ExInterlockedInsertTailList(
				&pThisDev->SendAvailableQueue,
				&pThisContext->ListEntry,
				&pThisDev->SendLock
			);
		InterlockedIncrement( &pThisDev->SendAvailableCount );
        status = STATUS_UNSUCCESSFUL;
        goto done;
    }

    pIrp->IoStatus.Status = STATUS_PENDING;
    pIrp->IoStatus.Information = 0;

	pThisContext->pIrp = pIrp;

	//
	// Build our URB for USBD
	//
    pUrb->UrbControlVendorClassRequest.Hdr.Length = (USHORT) sizeof( struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST );
    pUrb->UrbControlVendorClassRequest.Hdr.Function = URB_FUNCTION_VENDOR_DEVICE ;
    pUrb->UrbControlVendorClassRequest.TransferFlags = USBD_TRANSFER_DIRECTION_IN ;
    // short packet is not treated as an error.
    pUrb->UrbControlVendorClassRequest.TransferFlags |= USBD_SHORT_TRANSFER_OK;
    pUrb->UrbControlVendorClassRequest.UrbLink = NULL;
    pUrb->UrbControlVendorClassRequest.TransferBufferMDL = NULL;
    pUrb->UrbControlVendorClassRequest.TransferBuffer = &(pThisDev->StIrTranceiver.FifoDataReg)+FirstRegister;
    pUrb->UrbControlVendorClassRequest.TransferBufferLength = RegistersToRead;
	pUrb->UrbControlVendorClassRequest.Request = STIR4200_READ_REGS_REQ;
	pUrb->UrbControlVendorClassRequest.RequestTypeReservedBits = 0;
	pUrb->UrbControlVendorClassRequest.Index = FirstRegister;
    
	//
    // Call the class driver to perform the operation.
	//
    pNextStack = IoGetNextIrpStackLocation( pIrp );

    IRUSB_ASSERT( pNextStack != NULL );

    //
    // pass the URB to the USB driver stack
    //
	pNextStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
	pNextStack->Parameters.Others.Argument1 = pUrb;
	pNextStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_INTERNAL_USB_SUBMIT_URB;

	IoSetCompletionRoutine(
			pIrp,							// irp to use
			St4200CompleteReadWriteRequest,	// routine to call when irp is done
			DEV_TO_CONTEXT(pThisContext),	// context to pass routine
			TRUE,							// call on success
			TRUE,							// call on error
			TRUE							// call on cancel
		);

	KeClearEvent( &pThisDev->EventSyncUrb );

	//
    // Call IoCallDriver to send the irp to the usb port.
    //
	ExInterlockedInsertTailList(
			&pThisDev->ReadWritePendingQueue,
			&pThisContext->ListEntry,
			&pThisDev->SendLock
		);
	InterlockedIncrement( &pThisDev->ReadWritePendingCount );
	status = MyIoCallDriver( pThisDev, pUrbTargetDev, pIrp );

    //
    // The USB driver should always return STATUS_PENDING when
    // it receives a write irp
    //
	if( (status == STATUS_PENDING) || (status == STATUS_SUCCESS) )
	{
		// wait, but dump out on timeout
		if( status == STATUS_PENDING )
		{
			status = MyKeWaitForSingleObject( pThisDev, &pThisDev->EventSyncUrb, 0 );

			if( status == STATUS_TIMEOUT ) 
			{
				KIRQL OldIrql;

				DEBUGMSG( DBG_ERR,(" St4200ReadRegisters() TIMED OUT! return from IoCallDriver USBD %x\n", status));
				KeAcquireSpinLock( &pThisDev->SendLock, &OldIrql );
				RemoveEntryList( &pThisContext->ListEntry );
				KeReleaseSpinLock( &pThisDev->SendLock, OldIrql );
				InterlockedDecrement( &pThisDev->ReadWritePendingCount );
				// MS Security recommendation - cannot cancel IRP.
			}
			else
			{
				//
				// Update the status to reflect the real return code
				//
				status = pThisDev->StatusReadWrite;
			}
		}
	} 
	else 
	{
		DEBUGMSG( DBG_ERR, (" St4200ReadRegisters IoCallDriver FAILED(%x)\n",status));
		
		//
		// Don't assert, as such a failure can happen at shutdown
		//
		//IRUSB_ASSERT( status == STATUS_PENDING );
	}

done:
    DEBUGMSG(DBG_FUNC, ("-St4200ReadRegisters\n"));
    return status;
}


/*****************************************************************************
*
*  Function:   St4200CompleteReadWriteRequest
*
*  Synopsis:   completes a read/write ST4200 register request
*
*  Arguments:  pUsbDevObj - pointer to the  device object which
*                           completed the irp
*              pIrp       - the irp which was completed by the device
*                           object
*              Context    - send context
*
*  Returns:    NT_STATUS
*
*
*****************************************************************************/
NTSTATUS
St4200CompleteReadWriteRequest(
		IN PDEVICE_OBJECT pUsbDevObj,
		IN PIRP           pIrp,
		IN PVOID          Context
	)
{
    PIR_DEVICE          pThisDev;
    NTSTATUS            status;
	PIRUSB_CONTEXT		pThisContext = (PIRUSB_CONTEXT)Context;
	PIRP				pContextIrp;
	PURB                pContextUrb;
	PLIST_ENTRY			pListEntry;

    DEBUGMSG(DBG_FUNC, ("+St4200CompleteReadWriteRequest\n"));
	
    //
    // The context given to IoSetCompletionRoutine is an IRUSB_CONTEXT struct
    //
	IRUSB_ASSERT( NULL != pThisContext );				// we better have a non NULL buffer

    pThisDev = pThisContext->pThisDev;

	IRUSB_ASSERT( NULL != pThisDev );	

	pContextIrp = pThisContext->pIrp;
	pContextUrb = pThisContext->pUrb;
	
	//
	// Perform various IRP, URB, and buffer 'sanity checks'
	//
    IRUSB_ASSERT( pContextIrp == pIrp );				// check we're not a bogus IRP
	IRUSB_ASSERT( pContextUrb != NULL );

    status = pIrp->IoStatus.Status;

	//
	// we should have failed, succeeded, or cancelled, but NOT be pending
	//
	IRUSB_ASSERT( STATUS_PENDING != status );

	//
	// Remove from the pending queue (only if NOT cancelled)
	//
	if( status != STATUS_CANCELLED )
	{
		KIRQL OldIrql;
		
		KeAcquireSpinLock( &pThisDev->SendLock, &OldIrql );
		RemoveEntryList( &pThisContext->ListEntry );
		KeReleaseSpinLock( &pThisDev->SendLock, OldIrql );
		InterlockedDecrement( &pThisDev->ReadWritePendingCount );
	}

    //pIrp->IoStatus.Information = pContextUrb->UrbControlVendorClassRequest.TransferBufferLength;

    DEBUGMSG(DBG_OUT, 
		(" St4200CompleteReadWriteRequest  pIrp->IoStatus.Status = 0x%x\n", status));
    //DEBUGMSG(DBG_OUT, 
	//	(" St4200CompleteReadWriteRequest  pIrp->IoStatus.Information = 0x%x, dec %d\n", pIrp->IoStatus.Information,pIrp->IoStatus.Information));

    //
    // Free the IRP.
    //
    IoFreeIrp( pIrp );
	InterlockedIncrement( &pThisDev->NumReadWrites );

	IrUsb_DecIoCount( pThisDev ); // we will track count of pending irps

	// Free the URB.
	MyUrbFree(pThisContext->pUrb, pThisContext->UrbLen);
	pThisContext->pUrb = NULL;

	//
	// Put back on the available queue
	//
	ExInterlockedInsertTailList(
			&pThisDev->SendAvailableQueue,
			&pThisContext->ListEntry,
			&pThisDev->SendLock
		);
	InterlockedIncrement( &pThisDev->SendAvailableCount );

	if( ( STATUS_SUCCESS != status )  && ( STATUS_CANCELLED != status ) ) 
	{
		InterlockedIncrement( (PLONG)&pThisDev->NumReadWriteErrors );
		
		//
		// We have a serious USB failure, we'll have to issue a total reset
		//
		if( !pThisDev->fPendingClearTotalStall && !pThisDev->fPendingHalt 
			&& !pThisDev->fPendingReset && pThisDev->fProcessing )
		{
			DEBUGMSG(DBG_ERR, (" St4200CompleteReadWriteRequest error, will schedule an entire reset\n"));
    
			InterlockedExchange( (PLONG)&pThisDev->fPendingClearTotalStall, TRUE );
			ScheduleWorkItem( pThisDev,	RestoreIrDevice, NULL, 0 );
		}
	}

	//
	// This will only work as long as we serialize the access to the hardware
	//
	pThisDev->StatusReadWrite = status;
	
	//
	// Signal we're done
	//
	KeSetEvent( &pThisDev->EventSyncUrb, 0, FALSE );  
    DEBUGMSG(DBG_FUNC, ("-St4200CompleteReadWriteRequest\n"));
    return STATUS_MORE_PROCESSING_REQUIRED;
}


#if defined( WORKAROUND_STUCK_AFTER_GEAR_DOWN )
/*****************************************************************************
*
*  Function:	St4200FakeSend
*
*  Synopsis:	forces a bulk out transfer
*
*  Arguments:	pDevice - pointer to current ir device object
*				pData - pointer to bulk data
*				DataSize - size of bulk data
*
*  Returns:		NT_STATUS
*
*
*****************************************************************************/
NTSTATUS        
St4200FakeSend(
		IN PVOID pDevice,
		PUCHAR pData,
		ULONG DataSize
	)
{
    NTSTATUS            status = STATUS_SUCCESS;
	PIRUSB_CONTEXT		pThisContext;
    PURB				pUrb = NULL;
    PDEVICE_OBJECT		pUrbTargetDev;
    PIO_STACK_LOCATION	pNextStack;
    PIRP                pIrp;
	PIR_DEVICE			pThisDev = (PIR_DEVICE)pDevice;
	PLIST_ENTRY			pListEntry;

	DEBUGMSG(DBG_FUNC, ("+St4200FakeSend\n"));

 	// MS Security bug #538703
	IRUSB_ASSERT(pDevice != NULL);
	
    IRUSB_ASSERT( KeGetCurrentIrql() == PASSIVE_LEVEL );

	pListEntry = ExInterlockedRemoveHeadList( &pThisDev->SendAvailableQueue, &pThisDev->SendLock );

	if( NULL == pListEntry )
    {
        //
		// This must not happen
		//
        DEBUGMSG(DBG_ERR, (" St4200FakeSend failed to find a free context struct\n"));
		IRUSB_ASSERT( 0 );

        status = STATUS_UNSUCCESSFUL;
        goto done;
    }
	
	InterlockedDecrement( &pThisDev->SendAvailableCount );

	pThisContext = CONTAINING_RECORD( pListEntry, IRUSB_CONTEXT, ListEntry );
	pThisContext->ContextType = CONTEXT_READ_WRITE_REGISTER;

	//
	// MS Security recommendation - allocate a new urb.
	//
	pThisContext->UrbLen = sizeof( struct _URB_BULK_OR_INTERRUPT_TRANSFER );
	pThisContext->pUrb = MyUrbAlloc(pThisContext->UrbLen);
	if (pThisContext->pUrb == NULL)
	{
        DEBUGMSG(DBG_ERR, (" St4200FakeSend abort due to urb alloc failure\n"));
		goto done;
	}
	pUrb = pThisContext->pUrb;

	//
    // Now that we have created the urb, we will send a
    // request to the USB device object.
    //
    pUrbTargetDev = pThisDev->pUsbDevObj;

	//
	// make an irp sending to usbhub
	//
	pIrp = IoAllocateIrp( (CCHAR)(pThisDev->pUsbDevObj->StackSize + 1), FALSE );

    if( NULL == pIrp )
    {
        DEBUGMSG(DBG_ERR, (" St4200FakeSend failed to alloc IRP\n"));

 		MyUrbFree(pThisContext->pUrb, pThisContext->UrbLen);
		pThisContext->pUrb = NULL;
		ExInterlockedInsertTailList(
				&pThisDev->SendAvailableQueue,
				&pThisContext->ListEntry,
				&pThisDev->SendLock
			);
		InterlockedIncrement( &pThisDev->SendAvailableCount );
        status = STATUS_UNSUCCESSFUL;
        goto done;
    }

    pIrp->IoStatus.Status = STATUS_PENDING;
    pIrp->IoStatus.Information = 0;

	pThisContext->pIrp = pIrp;

	//
	// Build our URB for USBD
	//
    pUrb->UrbBulkOrInterruptTransfer.Hdr.Length = (USHORT)sizeof( struct _URB_BULK_OR_INTERRUPT_TRANSFER );
    pUrb->UrbBulkOrInterruptTransfer.Hdr.Function = URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER;
    pUrb->UrbBulkOrInterruptTransfer.PipeHandle = pThisDev->BulkOutPipeHandle;
    pUrb->UrbBulkOrInterruptTransfer.TransferFlags = USBD_TRANSFER_DIRECTION_OUT ;
    // short packet is not treated as an error.
    pUrb->UrbBulkOrInterruptTransfer.TransferFlags |= USBD_SHORT_TRANSFER_OK;
    pUrb->UrbBulkOrInterruptTransfer.UrbLink = NULL;
    pUrb->UrbBulkOrInterruptTransfer.TransferBufferMDL = NULL;
    pUrb->UrbBulkOrInterruptTransfer.TransferBuffer = pData;
    pUrb->UrbBulkOrInterruptTransfer.TransferBufferLength = (int)DataSize;

	//
	// Call the class driver to perform the operation.
	//
    pNextStack = IoGetNextIrpStackLocation( pIrp );

    IRUSB_ASSERT( pNextStack != NULL );

    //
    // pass the URB to the USB driver stack
    //
	pNextStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
	pNextStack->Parameters.Others.Argument1 = pUrb;
	pNextStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_INTERNAL_USB_SUBMIT_URB;

	IoSetCompletionRoutine(
			pIrp,							// irp to use
			St4200CompleteReadWriteRequest,	// routine to call when irp is done
			DEV_TO_CONTEXT(pThisContext),	// context to pass routine
			TRUE,							// call on success
			TRUE,							// call on error
			TRUE							// call on cancel
		);

	KeClearEvent( &pThisDev->EventSyncUrb );

	//
    // Call IoCallDriver to send the irp to the usb port.
    //
	ExInterlockedInsertTailList(
			&pThisDev->ReadWritePendingQueue,
			&pThisContext->ListEntry,
			&pThisDev->SendLock
		);
	InterlockedIncrement( &pThisDev->ReadWritePendingCount );
    status = MyIoCallDriver( pThisDev, pUrbTargetDev, pIrp );
	DEBUGMSG( DBG_ERR,(" St4200FakeSend() Did it\n"));

    //
    // The USB driver should always return STATUS_PENDING when
    // it receives a write irp
    //
    if( (status == STATUS_PENDING) || (status == STATUS_SUCCESS) )
	{
        // wait, but dump out on timeout
        if( status == STATUS_PENDING )
		{
            status = MyKeWaitForSingleObject( pThisDev, &pThisDev->EventSyncUrb, 0 );

            if( status == STATUS_TIMEOUT ) 
			{
				KIRQL OldIrql;

				DEBUGMSG( DBG_ERR,(" St4200FakeSend() TIMED OUT! return from IoCallDriver USBD %x\n", status));
				KeAcquireSpinLock( &pThisDev->SendLock, &OldIrql );
				RemoveEntryList( &pThisContext->ListEntry );
				KeReleaseSpinLock( &pThisDev->SendLock, OldIrql );
				InterlockedDecrement( &pThisDev->ReadWritePendingCount );
				// MS Security recommendation - cannot cancel IRP.
            }
        }
    } 
	else 
	{
        DEBUGMSG( DBG_ERR, (" St4200FakeSend IoCallDriver FAILED(%x)\n",status));
		IRUSB_ASSERT( status == STATUS_PENDING );
	}

done:
    DEBUGMSG(DBG_FUNC, ("-St4200FakeSend\n"));
    return status;
}

/*****************************************************************************
*
*  Function:	St4200FakeReceive
*
*  Synopsis:	forces a bulk in transfer
*
*  Arguments:	pDevice - pointer to current ir device object
*				pData - pointer to bulk data
*				DataSize - size of bulk data
*
*  Returns:		NT_STATUS
*
*
*****************************************************************************/
NTSTATUS        
St4200FakeReceive(
		IN PVOID pDevice,
		PUCHAR pData,
		ULONG DataSize
	)
{
    NTSTATUS            status = STATUS_SUCCESS;
	PIRUSB_CONTEXT		pThisContext;
    PURB				pUrb = NULL;
    PDEVICE_OBJECT		pUrbTargetDev;
    PIO_STACK_LOCATION	pNextStack;
    PIRP                pIrp;
	PIR_DEVICE			pThisDev = (PIR_DEVICE)pDevice;
	PLIST_ENTRY			pListEntry;

	DEBUGMSG(DBG_FUNC, ("+St4200FakeReceive\n"));

 	// MS Security bug #538703
	IRUSB_ASSERT(pDevice != NULL);
	
    IRUSB_ASSERT( KeGetCurrentIrql() == PASSIVE_LEVEL );
		
	pListEntry = ExInterlockedRemoveHeadList( &pThisDev->SendAvailableQueue, &pThisDev->SendLock );

	if( NULL == pListEntry )
    {
        //
		// This must not happen
		//
        DEBUGMSG(DBG_ERR, (" St4200FakeReceive failed to find a free context struct\n"));
		IRUSB_ASSERT( 0 );

        status = STATUS_UNSUCCESSFUL;
        goto done;
    }
	
	InterlockedDecrement( &pThisDev->SendAvailableCount );

	pThisContext = CONTAINING_RECORD( pListEntry, IRUSB_CONTEXT, ListEntry );
	pThisContext->ContextType = CONTEXT_READ_WRITE_REGISTER;

	//
	// MS Security recommendation - allocate a new urb.
	//
	pThisContext->UrbLen = sizeof( struct _URB_BULK_OR_INTERRUPT_TRANSFER );
	pThisContext->pUrb = MyUrbAlloc(pThisContext->UrbLen);
	if (pThisContext->pUrb == NULL)
	{
        DEBUGMSG(DBG_ERR, (" St4200FakeReceive abort due to urb alloc failure\n"));
		goto done;
	}
	pUrb = pThisContext->pUrb;

	//
    // Now that we have created the urb, we will send a
    // request to the USB device object.
    //
    pUrbTargetDev = pThisDev->pUsbDevObj;

	//
	// make an irp sending to usbhub
	//
	pIrp = IoAllocateIrp( (CCHAR)(pThisDev->pUsbDevObj->StackSize + 1), FALSE );

    if( NULL == pIrp )
    {
        DEBUGMSG(DBG_ERR, (" St4200FakeReceive failed to alloc IRP\n"));

 		MyUrbFree(pThisContext->pUrb, pThisContext->UrbLen);
		pThisContext->pUrb = NULL;
		ExInterlockedInsertTailList(
				&pThisDev->SendAvailableQueue,
				&pThisContext->ListEntry,
				&pThisDev->SendLock
			);
		InterlockedIncrement( &pThisDev->SendAvailableCount );
        status = STATUS_UNSUCCESSFUL;
        goto done;
    }

    pIrp->IoStatus.Status = STATUS_PENDING;
    pIrp->IoStatus.Information = 0;

	pThisContext->pIrp = pIrp;

	//
	// Build our URB for USBD
	//
    pUrb->UrbBulkOrInterruptTransfer.Hdr.Length = (USHORT)sizeof( struct _URB_BULK_OR_INTERRUPT_TRANSFER );
    pUrb->UrbBulkOrInterruptTransfer.Hdr.Function = URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER;
    pUrb->UrbBulkOrInterruptTransfer.PipeHandle = pThisDev->BulkInPipeHandle;
    pUrb->UrbBulkOrInterruptTransfer.TransferFlags = USBD_TRANSFER_DIRECTION_IN ;
    // short packet is not treated as an error.
    pUrb->UrbBulkOrInterruptTransfer.TransferFlags |= USBD_SHORT_TRANSFER_OK;
    pUrb->UrbBulkOrInterruptTransfer.UrbLink = NULL;
    pUrb->UrbBulkOrInterruptTransfer.TransferBufferMDL = NULL;
    pUrb->UrbBulkOrInterruptTransfer.TransferBuffer = pData;
    pUrb->UrbBulkOrInterruptTransfer.TransferBufferLength = (int)DataSize;

	//
	// Call the class driver to perform the operation.
	//
    pNextStack = IoGetNextIrpStackLocation( pIrp );

    IRUSB_ASSERT( pNextStack != NULL );

    //
    // pass the URB to the USB driver stack
    //
	pNextStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
	pNextStack->Parameters.Others.Argument1 = pUrb;
	pNextStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_INTERNAL_USB_SUBMIT_URB;

	IoSetCompletionRoutine(
			pIrp,							// irp to use
			St4200CompleteReadWriteRequest,	// routine to call when irp is done
			DEV_TO_CONTEXT(pThisContext),	// context to pass routine
			TRUE,							// call on success
			TRUE,							// call on error
			TRUE							// call on cancel
		);

	KeClearEvent( &pThisDev->EventSyncUrb );

	//
    // Call IoCallDriver to send the irp to the usb port.
    //
	ExInterlockedInsertTailList(
			&pThisDev->ReadWritePendingQueue,
			&pThisContext->ListEntry,
			&pThisDev->SendLock
		);
	InterlockedIncrement( &pThisDev->ReadWritePendingCount );
    status = MyIoCallDriver( pThisDev, pUrbTargetDev, pIrp );
	DEBUGMSG( DBG_ERR,(" St4200FakeReceive() Did it\n"));

    //
    // The USB driver should always return STATUS_PENDING when
    // it receives a write irp
    //
    if( (status == STATUS_PENDING) || (status == STATUS_SUCCESS) )
	{
        // wait, but dump out on timeout
        if( status == STATUS_PENDING )
		{
            status = MyKeWaitForSingleObject( pThisDev, &pThisDev->EventSyncUrb, 0 );

            if( status == STATUS_TIMEOUT ) 
			{
				KIRQL OldIrql;

				DEBUGMSG( DBG_ERR,(" St4200FakeReceive() TIMED OUT! return from IoCallDriver USBD %x\n", status));
				KeAcquireSpinLock( &pThisDev->SendLock, &OldIrql );
				RemoveEntryList( &pThisContext->ListEntry );
				KeReleaseSpinLock( &pThisDev->SendLock, OldIrql );
				InterlockedDecrement( &pThisDev->ReadWritePendingCount );
				// MS Security recommendation - cannot cancel IRP.
            }
        }
    } 
	else 
	{
        DEBUGMSG( DBG_ERR, (" St4200FakeReceive IoCallDriver FAILED(%x)\n",status));
		IRUSB_ASSERT( status == STATUS_PENDING );
	}

done:
    DEBUGMSG(DBG_FUNC, ("-St4200FakeReceive\n"));
    return status;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\net\irda\sigmatel\sys\irmisc.c ===
/**************************************************************************************************************************
 *  IRMISC.C SigmaTel STIR4200 misc module
 **************************************************************************************************************************
 *  (C) Unpublished Copyright of Sigmatel, Inc. All Rights Reserved.
 *
 *
 *		Created: 04/06/2000 
 *			Version 0.9
 *		Edited: 09/16/2000 
 *			Version 1.03
 *		Edited: 09/25/2000 
 *			Version 1.10
 *		Edited: 12/07/2000 
 *			Version 1.12
 *		Edited: 01/09/2001 
 *			Version 1.13
 *		Edited: 01/16/2001
 *			Version 1.14
 *	
 *
 **************************************************************************************************************************/

#define DOBREAKS    // enable debug breaks

#include <ndis.h>
#include <ntddndis.h>  // defines OID's

#include <usbdi.h>
#include <usbdlib.h>

#include "debug.h"
#include "ircommon.h"
#include "irndis.h"


/*****************************************************************************
*
*  Function:	IrUsb_CreateDeviceExt
*
*  Synopsis:	Creates a IR device extension
*
*  Arguments:	DeviceExt - pointer to DeviceExt pointer to return created device extension.
*	
*  Returns:		STATUS_SUCCESS if successful
*			    STATUS_UNSUCCESSFUL otherwise
*
*  Notes:
*
*****************************************************************************/
NTSTATUS
IrUsb_CreateDeviceExt(
		IN OUT PIR_DEVICE *DeviceExt
	)
{
    NTSTATUS	ntStatus = STATUS_SUCCESS;
    PIR_DEVICE	pThisDev = NULL;

    DEBUGMSG(DBG_FUNC,("+IrUsb_CreateDeviceExt() \n"));

    pThisDev = NewDevice();

    if( !pThisDev )  
	{
         ntStatus = STATUS_INSUFFICIENT_RESOURCES;
         goto done;
    }

    *DeviceExt = pThisDev;

done:
    DEBUGMSG(DBG_FUNC,("-IrUsb_CreateDeviceExt() \n"));
    return ntStatus;
}


/*****************************************************************************
*
*  Function:	IrUsb_AddDevice
*
*  Synopsis:    This routine is called to create and initialize our Functional Device Object (FDO).
*				For monolithic drivers, this is done in DriverEntry(), but Plug and Play devices
*				wait for a PnP event
*
*  Arguments:	DeviceExt - receives ptr to new dev obj
*	
*  Returns:		STATUS_SUCCESS if successful,
*				STATUS_UNSUCCESSFUL otherwise
*
*  Notes:
*
*****************************************************************************/
NTSTATUS
IrUsb_AddDevice(
		IN OUT PIR_DEVICE *DeviceExt
	)
{
    NTSTATUS ntStatus;
    
    DEBUGMSG( DBG_FUNC,("+IrUsb_AddDevice()\n"));

    *DeviceExt = NULL;
	ntStatus = IrUsb_CreateDeviceExt( DeviceExt );

    DEBUGMSG( DBG_FUNC,("-IrUsb_AddDevice() (%x)\n", ntStatus));
    return ntStatus;
}


/*****************************************************************************
*
*  Function:	IrUsb_GetDongleCaps
*
*  Synopsis:	We need to manually set the data in the class specific descriptor, since
*				our device does not support the automatic-read feature
*
*  Arguments:	pThisDev - pointer to IR device
*	
*  Returns:		STATUS_SUCCESS if successful
*				STATUS_UNSUCCESSFUL otherwise
*
*  Notes:
*
*****************************************************************************/
NTSTATUS
IrUsb_GetDongleCaps( 
		IN OUT PIR_DEVICE pThisDev 
	)
{
    IRUSB_CLASS_SPECIFIC_DESCRIPTOR *pDesc = &(pThisDev->ClassDesc);
    NTSTATUS						ntStatus = STATUS_SUCCESS;
	NDIS_HANDLE						ConfigurationHandle;

	// MS Security bug #539291
	IRUSB_ASSERT(pThisDev != NULL);
	IRUSB_ASSERT(pDesc != NULL);

	//
	// MS Security bug #539314
	// Note: this code is called at init time when it will set ClassConfigured=TRUE.
	// It may later be called by the polling thread, but at no time could multiple
	// threads be in here. Therefore, access to ClassConfigured does not need to be locked.
	//

	//
	// Make sure the code is only executed at init time
	//
	if( pDesc->ClassConfigured )
	{
		return STATUS_SUCCESS;
	}
	
	pDesc->ClassConfigured = TRUE;

	//
	// Some is hardwired, some are read from the registry
	//
	NdisOpenConfiguration(
			&ntStatus,
			&ConfigurationHandle,
			pThisDev->WrapperConfigurationContext
		);

	//
	// Turnaroud time (read from the registry)
	//
	if( NT_SUCCESS(ntStatus) ) 
	{
		NDIS_STRING MinTurnAroundKeyWord = NDIS_STRING_CONST("MinTurnTime");
		PNDIS_CONFIGURATION_PARAMETER pParameterValue;
		
		NdisReadConfiguration(
				&ntStatus,
				&pParameterValue,
				ConfigurationHandle,
				&MinTurnAroundKeyWord,
				NdisParameterInteger 
			);

		if( NT_SUCCESS(ntStatus) ) 
		{
			switch( pParameterValue->ParameterData.IntegerData )
			{
				case 500:
					pDesc->bmMinTurnaroundTime = BM_TURNAROUND_TIME_0p5ms;
					break;
				case 1000:
					pDesc->bmMinTurnaroundTime = BM_TURNAROUND_TIME_1ms;
					break;
				case 5000:
					pDesc->bmMinTurnaroundTime = BM_TURNAROUND_TIME_5ms;
					break;
				case 10000:
					pDesc->bmMinTurnaroundTime = BM_TURNAROUND_TIME_10ms;
					break;
				default:
					pDesc->bmMinTurnaroundTime = BM_TURNAROUND_TIME_0ms;
					break;
			}
		}

		//
		// Speed mask (read from the registry)
		//
		if( NT_SUCCESS(ntStatus) ) 
		{
			NDIS_STRING SpeedEnable = NDIS_STRING_CONST("SpeedEnable");
		
			NdisReadConfiguration(
					&ntStatus,
					&pParameterValue,
					ConfigurationHandle,
					&SpeedEnable,
					NdisParameterInteger 
				);

			if( NT_SUCCESS(ntStatus) ) 
			{
				switch( pParameterValue->ParameterData.IntegerData )
				{
					case SPEED_2400:
						pThisDev->BaudRateMask = NDIS_IRDA_SPEED_MASK_2400;
						break;
					case SPEED_9600:
						pThisDev->BaudRateMask = NDIS_IRDA_SPEED_MASK_9600;
						break;
					case SPEED_19200:
						pThisDev->BaudRateMask = NDIS_IRDA_SPEED_MASK_19200;
						break;
					case SPEED_38400:
						pThisDev->BaudRateMask = NDIS_IRDA_SPEED_MASK_38400;
						break;
					case SPEED_57600:
						pThisDev->BaudRateMask = NDIS_IRDA_SPEED_MASK_57600;
						break;
					case SPEED_115200:
						pThisDev->BaudRateMask = NDIS_IRDA_SPEED_MASK_115200;
						break;
					case SPEED_576000:
						pThisDev->BaudRateMask = NDIS_IRDA_SPEED_MASK_576K;
						break;
					case SPEED_1152000:
						pThisDev->BaudRateMask = NDIS_IRDA_SPEED_MASK_1152K;
						break;
					case SPEED_4000000:
						pThisDev->BaudRateMask = NDIS_IRDA_SPEED_MASK_4M;
						break;
					default:
						pThisDev->BaudRateMask = NDIS_IRDA_SPEED_MASK_4M;
						break;
				}
			}
		}

		//
		// Read the receive mode
		//
		if( NT_SUCCESS(ntStatus) ) 
		{
			NDIS_STRING Keyword = NDIS_STRING_CONST("ReceiveMode");
		
			NdisReadConfiguration(
					&ntStatus,
					&pParameterValue,
					ConfigurationHandle,
					&Keyword,
					NdisParameterInteger 
				);

			if( NT_SUCCESS(ntStatus) ) 
			{
				switch( pParameterValue->ParameterData.IntegerData )
				{
					case RXMODE_SLOW:
						pThisDev->ReceiveMode = RXMODE_SLOW;
						break;
					case RXMODE_SLOWFAST:
						pThisDev->ReceiveMode = RXMODE_SLOWFAST;
						break;
					case RXMODE_FAST:
					default:
						pThisDev->ReceiveMode = RXMODE_FAST;
						break;
				}
			}
			else
			{
				//
				// Force a default anyway
				//
				pThisDev->ReceiveMode = RXMODE_FAST;
				ntStatus = STATUS_SUCCESS;
			}
		}

		//
		// Read the tranceiver type
		//
		if( NT_SUCCESS(ntStatus) ) 
		{
			NDIS_STRING Keyword = NDIS_STRING_CONST("TransceiverType");
		
			NdisReadConfiguration(
					&ntStatus,
					&pParameterValue,
					ConfigurationHandle,
					&Keyword,
					NdisParameterInteger 
				);

			if( NT_SUCCESS(ntStatus) ) 
			{
				switch( pParameterValue->ParameterData.IntegerData )
				{
					case TRANSCEIVER_HP:
						pThisDev->TransceiverType = TRANSCEIVER_HP;
						break;
					case TRANSCEIVER_INFINEON:
						pThisDev->TransceiverType = TRANSCEIVER_INFINEON;
						break;
					case TRANSCEIVER_VISHAY:
						pThisDev->TransceiverType = TRANSCEIVER_VISHAY;
						break;
					case TRANSCEIVER_VISHAY_6102F:
						pThisDev->TransceiverType = TRANSCEIVER_VISHAY_6102F;
						break;
					case TRANSCEIVER_4000:
						pThisDev->TransceiverType = TRANSCEIVER_4000;
						break;
					case TRANSCEIVER_4012:
						pThisDev->TransceiverType = TRANSCEIVER_4012;
						break;
					case TRANSCEIVER_CUSTOM:
					default:
						pThisDev->TransceiverType = TRANSCEIVER_CUSTOM;
						break;
				}
			}
			else
			{
				//
				// Force a default anyway
				//
				pThisDev->TransceiverType = TRANSCEIVER_4012;
				ntStatus = STATUS_SUCCESS;

			}
		}

		//
		// And the receive window
		//
		if( NT_SUCCESS(ntStatus) )
		{
			if( pThisDev->ChipRevision == CHIP_REVISION_7 ) 
			{
				NDIS_STRING Keyword = NDIS_STRING_CONST("ReceiveWindow");
			
				NdisReadConfiguration(
						&ntStatus,
						&pParameterValue,
						ConfigurationHandle,
						&Keyword,
						NdisParameterInteger 
					);

				if( NT_SUCCESS(ntStatus) ) 
				{
					switch( pParameterValue->ParameterData.IntegerData )
					{
						case 2:
							pDesc->bmWindowSize = BM_WINDOW_SIZE_2;
							break;
						case 1:
						default:
							pDesc->bmWindowSize = BM_WINDOW_SIZE_1;
							break;
					}
				}
				else
				{
					//
					// Force a default anyway
					//
					pDesc->bmWindowSize = BM_WINDOW_SIZE_1;
					ntStatus = STATUS_SUCCESS;

				}
			}
#if defined(SUPPORT_LA8) && !defined(LEGACY_NDIS5)
			else if( pThisDev->ChipRevision == CHIP_REVISION_8 ) 
			{
#ifdef LOW_PRIORITY_POLL
				pDesc->bmWindowSize = BM_WINDOW_SIZE_2;
#else
				pDesc->bmWindowSize = BM_WINDOW_SIZE_4;
#endif
			}
#endif
			else
			{
				pDesc->bmWindowSize = BM_WINDOW_SIZE_1;
			}
		}

	//
	// MS Security bug #539329 (added comment).
	// Used in Diagnostic version.
	//
#if defined(VARIABLE_SETTINGS)
		if( NT_SUCCESS(ntStatus) )
		{
			NDIS_STRING Keyword = NDIS_STRING_CONST("Dpll");
			NTSTATUS DumStatus;
		
			NdisReadConfiguration(
					&DumStatus,
					&pParameterValue,
					ConfigurationHandle,
					&Keyword,
					NdisParameterHexInteger 
				);
			//
			// Since the Sir and Fir Dpll must be identical, they have
			// been combined into a single registry value.
			//
			if( NT_SUCCESS(DumStatus) )
			{
				pThisDev->SirDpll = pParameterValue->ParameterData.IntegerData;
				pThisDev->FirDpll = pParameterValue->ParameterData.IntegerData;
			}
		}

		if( NT_SUCCESS(ntStatus) )
		{
			NDIS_STRING Keyword = NDIS_STRING_CONST("SirSensitivity");
			NTSTATUS DumStatus;
		
			NdisReadConfiguration(
					&DumStatus,
					&pParameterValue,
					ConfigurationHandle,
					&Keyword,
					NdisParameterHexInteger 
				);
			if( NT_SUCCESS(DumStatus) )
			{
				pThisDev->SirSensitivity = pParameterValue->ParameterData.IntegerData;
			}
		}

		if( NT_SUCCESS(ntStatus) )
		{
			NDIS_STRING Keyword = NDIS_STRING_CONST("FirSensitivity");
			NTSTATUS DumStatus;
		
			NdisReadConfiguration(
					&DumStatus,
					&pParameterValue,
					ConfigurationHandle,
					&Keyword,
					NdisParameterHexInteger 
				);
			if( NT_SUCCESS(DumStatus) )
			{
				pThisDev->FirSensitivity = pParameterValue->ParameterData.IntegerData;
			}
		}
#endif

		NdisCloseConfiguration( ConfigurationHandle );

	}

	if( NT_SUCCESS(ntStatus) ) 
	{
		// fixup settings

		if ( pThisDev->TransceiverType == TRANSCEIVER_HP )
			pThisDev->ReceiveMode = RXMODE_SLOWFAST;

		if ( pThisDev->ReceiveMode == RXMODE_SLOW &&
			 pThisDev->BaudRateMask == NDIS_IRDA_SPEED_MASK_4M)
			pThisDev->BaudRateMask = NDIS_IRDA_SPEED_MASK_115200;
	}

	if( NT_SUCCESS(ntStatus) ) 
	{
		// Maximum data size
		pDesc->bmDataSize = BM_DATA_SIZE_2048;
#ifdef LOW_PRIORITY_POLL
		pDesc->bmDataSize = BM_DATA_SIZE_1024;
#endif

		// Speed
		pDesc->wBaudRate = NDIS_IRDA_SPEED_MASK_4M;
#if defined(WORKAROUND_BROKEN_MIR)
		pDesc->wBaudRate &= (~NDIS_IRDA_SPEED_1152K & ~NDIS_IRDA_SPEED_576K);
#endif
#if defined(WORKAROUND_CASIO)
		pDesc->wBaudRate &= (~NDIS_IRDA_SPEED_57600 & ~NDIS_IRDA_SPEED_19200);
#endif

		// Extra BOFs
#if defined(WORKAROUND_CASIO)
		pDesc->bmExtraBofs = BM_EXTRA_BOFS_0;
#else
		pDesc->bmExtraBofs = BM_EXTRA_BOFS_24;
#endif
	}

	return ntStatus;
}


/*****************************************************************************
*
*  Function:	IrUsb_SetDongleCaps
*
*  Synopsis:    Set the DONGLE_CAPABILITIES struct in our device from the information
*				we have already gotten from the USB Class-Specific descriptor.
*				Some data items are usable directly as formatted in the Class-Specific descriptor,
*				but some need to be translated  to a different format for OID_xxx use;
*				The donglecaps struct is thus used to hold the info in a form
*				usable directly by OID_xxx 's.
*
*  Arguments:	pThisDev - pointer to IR device
*	
*  Returns:		None
*
*  Notes:		
*
*****************************************************************************/
VOID 
IrUsb_SetDongleCaps( 
		IN OUT PIR_DEVICE pThisDev 
	)
{
    DONGLE_CAPABILITIES					*pCaps = &(pThisDev->dongleCaps);
    IRUSB_CLASS_SPECIFIC_DESCRIPTOR		*pDesc = &(pThisDev->ClassDesc);

    DEBUGMSG( DBG_FUNC,("+IrUsb_SetDongleCaps\n"));  

	// MS Security bug #539291
	IRUSB_ASSERT(pThisDev != NULL);
	IRUSB_ASSERT(pDesc != NULL);
	IRUSB_ASSERT(pCaps != NULL);

    DEBUGMSG( DBG_FUNC, (" IrUsb_SetDongleCaps() RAW ClassDesc BUFFER:\n"));
    IRUSB_DUMP( DBG_FUNC,( (PUCHAR) pDesc, 12 ) );

    //
	// Deal with the turnaround time
	//
	switch( pDesc->bmMinTurnaroundTime ) 
    {

        case BM_TURNAROUND_TIME_0ms:
            pCaps->turnAroundTime_usec = 0;
            break;

        case BM_TURNAROUND_TIME_0p01ms:  
            pCaps->turnAroundTime_usec = 10; //device tells us millisec; we store as microsec
            break;

        case BM_TURNAROUND_TIME_0p05ms:
            pCaps->turnAroundTime_usec = 50; 
            break;

        case BM_TURNAROUND_TIME_0p1ms:
            pCaps->turnAroundTime_usec = 100; 
            break;

        case BM_TURNAROUND_TIME_0p5ms:
            pCaps->turnAroundTime_usec = 500; 
            break;

        case BM_TURNAROUND_TIME_1ms:
            pCaps->turnAroundTime_usec = 1000; 
            break;

        case BM_TURNAROUND_TIME_5ms:
            pCaps->turnAroundTime_usec = 5000;
            break;

        case BM_TURNAROUND_TIME_10ms:
            pCaps->turnAroundTime_usec = 10000;
            break;

        default:
            IRUSB_ASSERT( 0 ); // we should have covered all the cases here
            pCaps->turnAroundTime_usec = 1000;
    }

	//
    // We probably support many window sizes and will have multiple of these bits set;
    // Just save the biggest we support for now to tell ndis
	//
    if( pDesc->bmWindowSize & BM_WINDOW_SIZE_7 )  
            pCaps->windowSize = 7;
    else if(  pDesc->bmWindowSize & BM_WINDOW_SIZE_6 )
            pCaps->windowSize = 6;
    else if(  pDesc->bmWindowSize & BM_WINDOW_SIZE_5 )
            pCaps->windowSize = 5;
    else if(  pDesc->bmWindowSize & BM_WINDOW_SIZE_4 )
            pCaps->windowSize = 4;
    else if(  pDesc->bmWindowSize & BM_WINDOW_SIZE_3 )
            pCaps->windowSize = 3;
    else if(  pDesc->bmWindowSize & BM_WINDOW_SIZE_2 )
            pCaps->windowSize = 2;
    else if(  pDesc->bmWindowSize & BM_WINDOW_SIZE_1 )
            pCaps->windowSize = 1;
    else 
	{
		IRUSB_ASSERT( 0 ); // we should have covered all the cases here
		pCaps->windowSize = 1;
    }

    //
	// Extra BOFS
	//
	switch( (USHORT)pDesc->bmExtraBofs )
    {

        case BM_EXTRA_BOFS_0:
            pCaps->extraBOFS = 0;
            break;

        case BM_EXTRA_BOFS_1:          
            pCaps->extraBOFS = 1;
            break;

        case BM_EXTRA_BOFS_2:          
            pCaps->extraBOFS = 2;
            break;

        case BM_EXTRA_BOFS_3:          
            pCaps->extraBOFS = 3;
            break;

        case BM_EXTRA_BOFS_6:          
            pCaps->extraBOFS = 6;
            break;

        case BM_EXTRA_BOFS_12:         
            pCaps->extraBOFS = 12;
            break;

        case BM_EXTRA_BOFS_24:         
            pCaps->extraBOFS = 24;
            break;

        case BM_EXTRA_BOFS_48:         
            pCaps->extraBOFS = 48;
            break;

        default:
            IRUSB_ASSERT( 0 ); // we should have covered all the cases here
            pCaps->extraBOFS = 0;
    }

	//
    // We probably support many data sizes and will have multiple of these bits set;
    // Just save biggest we support for now to tell ndis
	//
    if( pDesc->bmDataSize & BM_DATA_SIZE_2048 )  
            pCaps->dataSize = 2048;
    else if(  pDesc->bmDataSize & BM_DATA_SIZE_1024 )
            pCaps->dataSize = 1024;
    else if(  pDesc->bmDataSize & BM_DATA_SIZE_512 )
            pCaps->dataSize = 512;
    else if(  pDesc->bmDataSize & BM_DATA_SIZE_256 )
            pCaps->dataSize = 256;
    else if(  pDesc->bmDataSize & BM_DATA_SIZE_128 )
            pCaps->dataSize = 128;
    else if(  pDesc->bmDataSize & BM_DATA_SIZE_64 )
            pCaps->dataSize = 64;
    else
	{
		IRUSB_ASSERT( 0 ); // we should have covered all the cases here
		pCaps->dataSize = 2048;
    }

	pDesc->wBaudRate &= pThisDev->BaudRateMask;  // mask defaults to 0xffff; may be set in registry

	//
    // max frame size is 2051; max irda dataSize should be 2048
	//
    IRUSB_ASSERT( MAX_TOTAL_SIZE_WITH_ALL_HEADERS > pCaps->dataSize);

    DEBUGMSG( DBG_FUNC,(" IrUsb_SetDongleCaps pCaps->turnAroundTime_usec = dec %d\n",pCaps->turnAroundTime_usec));
    DEBUGMSG( DBG_FUNC,("   extraBOFS = dec %d\n",pCaps->extraBOFS));
    DEBUGMSG( DBG_FUNC,("   dataSize = dec %d\n",pCaps->dataSize));
    DEBUGMSG( DBG_FUNC,("   windowSize = dec %d\n",pCaps->windowSize)); 
    DEBUGMSG( DBG_FUNC,("   MAX_TOTAL_SIZE_WITH_ALL_HEADERS == dec %d\n",MAX_TOTAL_SIZE_WITH_ALL_HEADERS)); 

    DEBUGMSG( DBG_FUNC,("   pDesc->bmDataSize = 0x%02x\n",pDesc->bmDataSize));
    DEBUGMSG( DBG_FUNC,("   pDesc->bmWindowSize = 0x%02x\n",pDesc->bmWindowSize));
    DEBUGMSG( DBG_FUNC,("   pDesc->bmMinTurnaroundTime = 0x%02x\n",pDesc->bmMinTurnaroundTime));
    DEBUGMSG( DBG_FUNC,("   pDesc->wBaudRate = 0x%04x\n",pDesc->wBaudRate));
    DEBUGMSG( DBG_FUNC,("   pDesc->bmExtraBofs = 0x%02x\n",pDesc->bmExtraBofs));

    DEBUGMSG( DBG_FUNC,("-IrUsb_SetDongleCaps\n")); 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\net\irda\sigmatel\sys\irndis.h ===
/**************************************************************************************************************************
 *  IRNDIS.H SigmaTel STIR4200 ndis standard entry point definitions
 **************************************************************************************************************************
 *  (C) Unpublished Copyright of Sigmatel, Inc. All Rights Reserved.
 *
 *
 *		Created: 04/06/2000 
 *			Version 0.9
 *		Edited: 04/27/2000 
 *			Version 0.92
 *		Edited: 05/03/2000 
 *			Version 0.93
 *		Edited: 05/24/2000 
 *			Version 0.96
 *		Edited: 08/09/2000 
 *			Version 1.02
 *		Edited: 09/16/2000 
 *			Version 1.03
 *		Edited: 09/25/2000 
 *			Version 1.10
 *		Edited: 11/09/2000 
 *			Version 1.12
 *	
 *
 **************************************************************************************************************************/

#ifndef IRNDIS_H
#define IRNDIS_H


//
// NDIS version compatibility.
//
#define NDIS_MAJOR_VERSION 5  
#define NDIS_MINOR_VERSION 0

#define DRIVER_MAJOR_VERSION 1  
#define DRIVER_MINOR_VERSION 23


//
// Externs for required NDIS-dependent miniport export functions
//
VOID 
StIrUsbHalt(
		IN NDIS_HANDLE MiniportAdapterContext
	);

NDIS_STATUS 
StIrUsbInitialize(
		OUT PNDIS_STATUS    OpenErrorStatus,
		OUT PUINT           SelectedMediumIndex,
		IN  PNDIS_MEDIUM    MediumArray,
		IN  UINT            MediumArraySize,
		IN  NDIS_HANDLE     MiniportAdapterHandle,
		IN  NDIS_HANDLE     WrapperConfigurationContext
	);

NDIS_STATUS 
StIrUsbQueryInformation(
		IN  NDIS_HANDLE MiniportAdapterContext,
		IN  NDIS_OID    Oid,
		IN  PVOID       InformationBuffer,
		IN  ULONG       InformationBufferLength,
		OUT PULONG      BytesWritten,
		OUT PULONG      BytesNeeded
    );

VOID
StIrUsbSendPackets(
		IN NDIS_HANDLE  MiniportAdapterContext,
		IN PPNDIS_PACKET  PacketArray,
		IN UINT  NumberOfPackets
	);

NDIS_STATUS 
StIrUsbSend(
		IN NDIS_HANDLE  MiniportAdapterContext,
		IN PNDIS_PACKET Packet,
		IN UINT         Flags
	);

NDIS_STATUS 
StIrUsbSetInformation(
		IN  NDIS_HANDLE MiniportAdapterContext,
		IN  NDIS_OID    Oid,
		IN  PVOID       InformationBuffer,
		IN  ULONG       InformationBufferLength,
		OUT PULONG      BytesRead,
		OUT PULONG      BytesNeeded
	);

VOID StIrUsbReturnPacket(
		IN OUT NDIS_HANDLE MiniportAdapterContext,
		IN OUT PNDIS_PACKET Packet
	);

VOID
IrUsb_CommonShutdown(
		IN OUT PIR_DEVICE pThisDev,
		BOOLEAN KillPassiveThread
	);

NDIS_STATUS 
StIrUsbReset(
		OUT PBOOLEAN    AddressingReset,
		IN  NDIS_HANDLE MiniportAdapterContext
	);

NTSTATUS
StIrUsbDispatch(
		IN PDEVICE_OBJECT DeviceObject,
		IN PIRP Irp
	);

NTSTATUS
StIrUsbCreate(
		IN PDEVICE_OBJECT DeviceObject,
		IN PIRP Irp
	);

NTSTATUS
StIrUsbClose(
		IN PDEVICE_OBJECT DeviceObject,
		IN PIRP Irp
	);

NTSTATUS
ResetIrDevice(
		IN PIR_WORK_ITEM pWorkItem
	);

NTSTATUS
RestoreIrDevice(
		IN PIR_WORK_ITEM pWorkItem
	);

NTSTATUS
SuspendIrDevice(
		IN PIR_WORK_ITEM pWorkItem
	);

NTSTATUS
ResumeIrDevice(
		IN PIR_WORK_ITEM pWorkItem
	);

PIR_DEVICE
NewDevice();

NTSTATUS
IrUsb_StartDevice(
		IN PIR_DEVICE pThisDev
    );

NTSTATUS
IrUsb_StopDevice(
		IN PIR_DEVICE pThisDev
    );

NTSTATUS
IrUsb_AddDevice(
		IN OUT PIR_DEVICE *DeviceExt
    );

NTSTATUS
IrUsb_CreateDeviceExt(
		IN OUT PIR_DEVICE *DeviceExt
    );

NTSTATUS
IrUsb_ConfigureDevice(
		IN OUT PIR_DEVICE pThisDev
    );

NDIS_STATUS 
InitializeDevice(
		IN OUT PIR_DEVICE pThisDev
	);

VOID 
DeinitializeDevice(
		IN OUT PIR_DEVICE pThisDev
	);

NDIS_STATUS 
UsbOpen(
		IN PIR_DEVICE pThisDev
	);

NDIS_STATUS 
UsbClose(
		IN PIR_DEVICE pThisDev
	);

VOID 
FreeDevice(
		IN OUT PIR_DEVICE pThisDev
	);

PNDIS_IRDA_PACKET_INFO  
GetPacketInfo(
		IN PNDIS_PACKET pPacket
	);

#endif IRNDIS_H

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\net\irda\sigmatel\sys\receive.c ===
/**************************************************************************************************************************
 *  RECEIVE.C SigmaTel STIR4200 packet reception and decoding module
 **************************************************************************************************************************
 *  (C) Unpublished Copyright of Sigmatel, Inc. All Rights Reserved.
 *
 *
 *		Created: 04/06/2000 
 *			Version 0.9
 *		Edited: 04/24/2000 
 *			Version 0.91
 *		Edited: 04/27/2000 
 *			Version 0.92
 *		Edited: 05/03/2000 
 *			Version 0.93
 *		Edited: 05/12/2000 
 *			Version 0.94
 *		Edited: 05/19/2000 
 *			Version 0.95
 *		Edited: 07/13/2000 
 *			Version 1.00
 *		Edited: 08/22/2000 
 *			Version 1.02
 *		Edited: 09/25/2000 
 *			Version 1.10
 *		Edited: 10/13/2000 
 *			Version 1.11
 *		Edited: 11/09/2000 
 *			Version 1.12
 *		Edited: 12/29/2000 
 *			Version 1.13
 *		Edited: 01/16/2001 
 *			Version 1.14
 *		Edited: 02/20/2001
 *			Version 1.15
 *
 **************************************************************************************************************************/

#define DOBREAKS    // enable debug breaks

#include <ndis.h>
#include <ntdef.h>
#include <windef.h>

#include "stdarg.h"
#include "stdio.h"

#include "debug.h"
#include "usbdi.h"
#include "usbdlib.h"

#include "ircommon.h"
#include "irusb.h"
#include "irndis.h"


/*****************************************************************************
*
*  Function:   ReceiveProcessFifoData
*
*  Synopsis:   Processes the received data and indicates packets to the protocol
*
*  Arguments:  pThisDev - pointer to current ir device object
*
*  Returns:    None
*
*
*****************************************************************************/
VOID
ReceiveProcessFifoData(
		IN OUT PIR_DEVICE pThisDev
	)
{
    ULONG		BytesProcessed;
	BOOLEAN		ReturnValue = TRUE;

	while( ReturnValue )
	{
		if( pThisDev->currentSpeed<=MAX_SIR_SPEED )
		{
			ReturnValue = ReceiveSirStepFSM( pThisDev, &BytesProcessed );
		}
		else if( pThisDev->currentSpeed<=MAX_MIR_SPEED )
		{
			ReturnValue = ReceiveMirStepFSM( pThisDev, &BytesProcessed );
		}
		else
		{
			ReturnValue = ReceiveFirStepFSM( pThisDev, &BytesProcessed );
		}
	}

	//
	// Indicate that we are no more receiving
	//
	InterlockedExchange( (PLONG)&pThisDev->fCurrentlyReceiving, FALSE );

}


/*****************************************************************************
*
*  Function:   ReceiveResetPointers
*
*  Synopsis:   Reset the receive pointers as the data is gone when we are sending
*
*  Arguments:  pThisDev - pointer to current ir device object
*
*  Returns:    None
*
*
*****************************************************************************/
VOID
ReceiveResetPointers(
		IN OUT PIR_DEVICE pThisDev
	)
{
	pThisDev->rcvState = STATE_INIT;
	pThisDev->readBufPos = 0;
}


/*****************************************************************************
*
*  Function:   ReceivePreprocessFifo
*
*  Synopsis:   Verifies if there is data to be received
*
*  Arguments:  MiniportAdapterContext - pointer to current ir device object
*			   pFifoCount - pinter to count to return
*
*  Returns:    NT status code
*
*
*****************************************************************************/
NTSTATUS
ReceivePreprocessFifo(
		IN OUT PIR_DEVICE pThisDev,
		OUT PULONG pFifoCount
	)
{
	NTSTATUS Status;

#ifdef WORKAROUND_POLLING_FIFO_COUNT
 	LARGE_INTEGER CurrentTime;
	BOOLEAN SlowReceive;
	ULONG OldFifoCount = 0;
	LONG Delay;
	
	//
    // Set the receive algorithm
	//
#if defined(SUPPORT_LA8)
	if( pThisDev->ChipRevision >= CHIP_REVISION_8 )
		SlowReceive = FALSE;
	else
#endif
		SlowReceive = TRUE;

	if( SlowReceive )
	{
		Status = St4200GetFifoCount( pThisDev, pFifoCount );
		if( Status != STATUS_SUCCESS )
		{
			DEBUGMSG(DBG_ERR, (" ReceivePreprocessFifo(): USB failure\n"));
			return Status;
		}
	}
	else
	{
		*pFifoCount = 1;
	}

	//
	// Receive the data
	//
    if( *pFifoCount || pThisDev->fReadHoldingReg )
    {
		//
		// See if we need to take care of the fake empty FIFO
		//
#if defined( WORKAROUND_FAKE_EMPTY_FIFO )		
		if( *pFifoCount )
		{
#endif
			//
			// If we are in SIR read again until we see a stable value
			//
			if( (pThisDev->currentSpeed <= MAX_SIR_SPEED) && (pThisDev->currentSpeed != SPEED_9600) && SlowReceive )
			{
				//
				// Make also sure we don't ever wrap
				//
				while( (OldFifoCount != *pFifoCount) && (*pFifoCount < 9*STIR4200_FIFO_SIZE/10) )
				{
					OldFifoCount = *pFifoCount;
					St4200GetFifoCount( pThisDev, pFifoCount );
				}
			}

			//
			// If we are in FIR we need to delay
			//
			if( (pThisDev->currentSpeed > MAX_MIR_SPEED) && SlowReceive )
			{
				if( pThisDev->ChipRevision < CHIP_REVISION_7 )
				{
#if !defined(ONLY_ERROR_MESSAGES)
					DEBUGMSG(DBG_ERR, (" ReceivePreprocessFifo(): Delaying\n"));
#endif
					Delay = STIR4200_READ_DELAY - (STIR4200_READ_DELAY*(*pFifoCount))/STIR4200_ESC_PACKET_SIZE;
					if( Delay > 0 )
					{
						// MS Security bug #540780 - use NdisMSleep instead of NdisStallExecution
						NdisMSleep( (ULONG)Delay );
					}
				}
				else //if( pThisDev->dongleCaps.windowSize == 2 )
				{
					/*if( !(*pFifoCount%10) )
					{
						DEBUGMSG(DBG_ERR, (" ReceivePreprocessFifo(): Forcing wrap\n"));
						NdisMSleep( 1000 );
					}*/
					Delay = pThisDev->ReceiveAdaptiveDelay - 
						(pThisDev->ReceiveAdaptiveDelay*(*pFifoCount))/STIR4200_MULTIPLE_READ_THREHOLD;
					if( Delay > 0 )
					{
						// MS Security bug #540780 - use NdisMSleep instead of NdisStallExecution
						NdisMSleep( (ULONG)Delay );
					}
				}
			}
#if defined( WORKAROUND_FAKE_EMPTY_FIFO )		
		}
		//
		// Read after a successful bulk-in with count of zero
		//
		else
		{
			pThisDev->fReadHoldingReg = FALSE;
		}
#endif

		//
		// Perform the read
		//
		pThisDev->PreReadBuffer.DataLen = 0;
		Status = ReceivePacketRead( 
				pThisDev,
				&pThisDev->PreReadBuffer
			);

		if( Status == STATUS_SUCCESS )
		{
			*pFifoCount = pThisDev->PreReadBuffer.DataLen;

#if defined( WORKAROUND_FAKE_EMPTY_FIFO )		
			//
			// If we got data restore the flag
			//
			if( *pFifoCount )
			{
				pThisDev->fReadHoldingReg = TRUE;
			}
#endif

#if !defined(ONLY_ERROR_MESSAGES) && defined( WORKAROUND_FAKE_EMPTY_FIFO )
			if( *pFifoCount && !pThisDev->fReadHoldingReg )
				DEBUGMSG(DBG_ERR, (" ReceivePreprocessFifo(): Final byte(s) workaround\n"));
#endif

#if defined(RECEIVE_LOGGING)
			if( pThisDev->ReceiveFileHandle && *pFifoCount )
			{
				IO_STATUS_BLOCK IoStatusBlock;

				ZwWriteFile(
						pThisDev->ReceiveFileHandle,
						NULL,
						NULL,
						NULL,
						&IoStatusBlock,
						pThisDev->PreReadBuffer.pDataBuf,
						pThisDev->PreReadBuffer.DataLen,
						(PLARGE_INTEGER)&pThisDev->ReceiveFilePosition,
						NULL
				   );

				pThisDev->ReceiveFilePosition += pThisDev->PreReadBuffer.DataLen;
			}
#endif
		}
		else
		{
			DEBUGMSG(DBG_ERR, (" ReceivePreprocessFifo(): USB failure\n"));
			pThisDev->PreReadBuffer.DataLen = 0;
			*pFifoCount = 0;
		}
    }
#else
	Status = ReceivePacketRead( 
			pThisDev,
			&pThisDev->PreReadBuffer
		);

	if( Status == STATUS_SUCCESS )
		*pFifoCount = pThisDev->PreReadBuffer.DataLen;
#endif

	return Status;
}


/*****************************************************************************
*
*  Function:	ReceiveGetFifoData
*
*  Synopsis:	Load the preprocessed data if any is vailable, otherwise tries to read and load new data
*
*  Arguments:	pThisDev - pointer to current ir device object
*			  	pData - buffer to copy to
*				pBytesRead - pointer to return bytes read
*				BytesToRead - requested number of bytes
*
*  Returns:		Number of bytes in the FIFO
*
*
*****************************************************************************/
NTSTATUS
ReceiveGetFifoData(
		IN OUT PIR_DEVICE pThisDev,
		OUT PUCHAR pData,
		OUT PULONG pBytesRead,
		ULONG BytesToRead
	)
{
	NTSTATUS Status;

#ifdef WORKAROUND_POLLING_FIFO_COUNT
	LARGE_INTEGER CurrentTime;
	BOOLEAN SlowReceive;
    ULONG FifoCount = 0, OldFifoCount = 0;
	LONG Delay;

    //
	// Make sure if there is data in the preread buffer
	//
	if( pThisDev->PreReadBuffer.DataLen )
    {
		ULONG OutputBufferSize;
		
		IRUSB_ASSERT( pThisDev->PreReadBuffer.DataLen <= BytesToRead );

		//
		// Copy the data
		//
        RtlCopyMemory( pData, pThisDev->PreReadBuffer.pDataBuf, pThisDev->PreReadBuffer.DataLen );
		
#if !defined(WORKAROUND_BROKEN_MIR)
		//
		// Consider MIR
		//
		if( pThisDev->currentSpeed == SPEED_1152000 )
			ReceiveMirUnstuff(
					pThisDev,
					pData,
					pThisDev->PreReadBuffer.DataLen,
					pThisDev->pRawUnstuffedBuf,
					&OutputBufferSize
				);
#endif

		*pBytesRead = pThisDev->PreReadBuffer.DataLen;
		pThisDev->PreReadBuffer.DataLen = 0;
        return STATUS_SUCCESS;
    }
	//
	// Try to read if no data is already available
	//
    else
    {
		//
		// Set the receive algorithm
		//
#if defined(SUPPORT_LA8)
		if( pThisDev->ChipRevision >= CHIP_REVISION_8 ) 
			SlowReceive = FALSE;
		else
#endif
			SlowReceive = TRUE;

		if( SlowReceive )
		{
			Status = St4200GetFifoCount( pThisDev, &FifoCount );
			if( Status != STATUS_SUCCESS )
			{
				DEBUGMSG(DBG_ERR, (" ReceiveGetFifoData(): USB failure\n"));
				return Status;
			}
		}
		else
		{
			FifoCount = 1; 
		}

		//
		// Receive the data
		//
		if( FifoCount || pThisDev->fReadHoldingReg )
		{
			//
			// See if we need to take care of the fake empty FIFO
			//
#if defined( WORKAROUND_FAKE_EMPTY_FIFO )		
			if( FifoCount )
			{
#endif
				//
				// If we are in SIR read again until we see a stable value
				//
#if defined( WORKAROUND_9600_ANTIBOUNCING )
				if( (pThisDev->currentSpeed <= MAX_SIR_SPEED) && SlowReceive )
				{
					if( pThisDev->currentSpeed != SPEED_9600 )
					{
						//
						// Make also sure we don't ever wrap
						//
						while( (OldFifoCount != FifoCount) && (FifoCount < 9*STIR4200_FIFO_SIZE/10) )
						{
							OldFifoCount = FifoCount;
							St4200GetFifoCount( pThisDev, &FifoCount );
						}
					}
					else
					{
						if( pThisDev->rcvState != STATE_INIT )
						{
							while( OldFifoCount != FifoCount )
							{
								OldFifoCount = FifoCount;
								St4200GetFifoCount( pThisDev, &FifoCount );
							}
						}
					}
				}
#else
				if( (pThisDev->currentSpeed <= MAX_SIR_SPEED) && ( pThisDev->currentSpeed != SPEED_9600) && SlowReceive )
				{
					while( OldFifoCount != FifoCount )
					{
						OldFifoCount = FifoCount;
						St4200GetFifoCount( pThisDev, &FifoCount );
					}
				}
#endif

				//
				// If we are in FIR we need to delay
				//
				if( (pThisDev->currentSpeed > MAX_MIR_SPEED) && SlowReceive )
				{
					if( pThisDev->ChipRevision <= CHIP_REVISION_6 ) 
					{
#if !defined(ONLY_ERROR_MESSAGES)
						DEBUGMSG(DBG_ERR, (" ReceiveGetFifoData(): Delaying\n"));
#endif
						Delay = STIR4200_READ_DELAY - (STIR4200_READ_DELAY*FifoCount)/STIR4200_ESC_PACKET_SIZE;
						if( Delay > 0 )
						{
							// MS Security bug #540780 - use NdisMSleep instead of NdisStallExecution
							NdisMSleep( (ULONG)Delay );
						}
					}
					else //if( pThisDev->dongleCaps.windowSize == 2 )
					{
						/*if( !(FifoCount%10) )
						{
							DEBUGMSG(DBG_ERR, (" ReceiveGetFifoData(): Forcing wrap\n"));
							NdisMSleep( 1000 );
						}*/
						Delay = pThisDev->ReceiveAdaptiveDelay - 
							(pThisDev->ReceiveAdaptiveDelay*FifoCount)/STIR4200_MULTIPLE_READ_THREHOLD;
						if( Delay > 0 )
						{
							// MS Security bug #540780 - use NdisMSleep instead of NdisStallExecution
							NdisMSleep( (ULONG)Delay );
						}
					}
				}
#if defined( WORKAROUND_FAKE_EMPTY_FIFO )		
			}
			else
			{
				// Force antibouncing to take care of OHCI
				if( pThisDev->currentSpeed <= MAX_SIR_SPEED )
				{
					if( pThisDev->rcvState != STATE_INIT )
					{
						OldFifoCount = 1;
						while( OldFifoCount != FifoCount )
						{
							OldFifoCount = FifoCount;
							St4200GetFifoCount( pThisDev, &FifoCount );
						}
					}
				}
				pThisDev->fReadHoldingReg = FALSE;
			}
#endif

			//
			// Perform the read
			//
			pThisDev->PreReadBuffer.DataLen = 0;
			Status = ReceivePacketRead( 
					pThisDev,
					&pThisDev->PreReadBuffer
				);

			if( Status == STATUS_SUCCESS )
			{
				IRUSB_ASSERT( pThisDev->PreReadBuffer.DataLen <= BytesToRead );
				
				//
				// Copy the data
				//
				RtlCopyMemory( pData, pThisDev->PreReadBuffer.pDataBuf, pThisDev->PreReadBuffer.DataLen );
				FifoCount = pThisDev->PreReadBuffer.DataLen;

#if defined( WORKAROUND_FAKE_EMPTY_FIFO )		
				//
				// If we got data restore the flag
				//
				if( FifoCount )
				{
					pThisDev->fReadHoldingReg = TRUE;
				}
#endif

#if !defined(ONLY_ERROR_MESSAGES) && defined( WORKAROUND_FAKE_EMPTY_FIFO )
				if( FifoCount && !pThisDev->fReadHoldingReg )
					DEBUGMSG(DBG_ERR, (" ReceiveGetFifoData(): Final byte(s) workaround\n"));
#endif

#if defined(RECEIVE_LOGGING)
				if( pThisDev->ReceiveFileHandle && FifoCount )
				{
					IO_STATUS_BLOCK IoStatusBlock;

					ZwWriteFile(
							pThisDev->ReceiveFileHandle,
							NULL,
							NULL,
							NULL,
							&IoStatusBlock,
							pThisDev->PreReadBuffer.pDataBuf,
							pThisDev->PreReadBuffer.DataLen,
							(PLARGE_INTEGER)&pThisDev->ReceiveFilePosition,
							NULL
					   );

					pThisDev->ReceiveFilePosition += pThisDev->PreReadBuffer.DataLen;
				}
#endif
				pThisDev->PreReadBuffer.DataLen = 0;
			}
			else
			{
				DEBUGMSG(DBG_ERR, (" ReceiveGetFifoData(): USB failure\n"));
				pThisDev->PreReadBuffer.DataLen = 0;
				FifoCount = 0;
			}
		}
	}

	*pBytesRead = FifoCount;
    return Status;
#else
    if( pThisDev->PreReadBuffer.DataLen )
    {
		IRUSB_ASSERT( pThisDev->PreReadBuffer.DataLen <= BytesToRead );

		//
		// Copy the data
		//
        RtlCopyMemory( pData, pThisDev->PreReadBuffer.pDataBuf, pThisDev->PreReadBuffer.DataLen );
		*pBytesRead = pThisDev->PreReadBuffer.DataLen;
		pThisDev->PreReadBuffer.DataLen = 0;
        return STATUS_SUCCESS;
    }
    else
    {
		Status = ReceivePacketRead( 
				pThisDev,
				&pThisDev->PreReadBuffer
			);

		if( Status == STATUS_SUCCESS )
		{
			RtlCopyMemory( pData, pThisDev->PreReadBuffer.pDataBuf, pThisDev->PreReadBuffer.DataLen );
			*pBytesRead = pThisDev->PreReadBuffer.DataLen;
			pThisDev->PreReadBuffer.DataLen = 0;
		}

		return Status;
    }
#endif
}


/*****************************************************************************
*
*  Function:    ReceiveFirStepFSM
*
*  Synopsis:	Step the receive FSM to read in a piece of an IrDA frame. 
*				Strip the BOFs and EOF, and eliminate escape sequences.
*
*  Arguments:	pIrDev - pointer to the current IR device object
*				pBytesProcessed - pointer to bytes processed
*
*  Returns:		TRUE after an entire frame has been read in
*				FALSE otherwise
*
*****************************************************************************/
BOOLEAN
ReceiveFirStepFSM(
		IN OUT PIR_DEVICE pIrDev, 
		OUT PULONG pBytesProcessed
	)
{
    ULONG           rawBufPos=0, rawBytesRead=0;
    BOOLEAN         FrameProcessed = FALSE, ForceExit = FALSE;
    UCHAR           ThisChar;
    PUCHAR          pRawBuf, pReadBuf;
	PRCV_BUFFER		pRecBuf;
    
	*pBytesProcessed = 0;

	if( !pIrDev->pCurrentRecBuf )
	{
		UINT Index;
		
		pRecBuf = ReceiveGetBuf( pIrDev, &Index, RCV_STATE_FULL );
		if( !pRecBuf )
		{
			//
			// no buffers available; stop
			//
			DEBUGMSG(DBG_ERR, (" ReceiveSirStepFSM out of buffers\n"));
			pIrDev->packetsReceivedNoBuffer ++;
			return FALSE;
		}

		pIrDev->pCurrentRecBuf = pRecBuf;
	}
	else
		pRecBuf = pIrDev->pCurrentRecBuf;

	pReadBuf = pRecBuf->pDataBuf;
    pRawBuf = pIrDev->pRawBuf;

    /***********************************************/
    /*   Read  in  and process groups of incoming  */
    /*   bytes from the FIFO.                      */
    /***********************************************/
    while( (pIrDev->rcvState != STATE_SAW_EOF) && 
		(pIrDev->readBufPos <= (MAX_TOTAL_SIZE_WITH_ALL_HEADERS + FAST_IR_FCS_SIZE)) &&
		!ForceExit )
    {
        if( pIrDev->rcvState == STATE_CLEANUP )
        {
            /***********************************************/
            /*   We returned a complete packet last time,  */
            /*   but  we had read some extra bytes, which  */
            /*   we   stored   into   the   rawBuf  after  */
            /*   returning  the  previous complete buffer  */
            /*   to  the  user.  So  instead  of  calling  */
            /*   DoRcvDirect() in this first execution of  */
            /*   this  loop, we just use these previously  */
            /*   read bytes. (This is typically only 1 or  */
            /*   2 bytes).                                 */
            /***********************************************/
            rawBytesRead = pIrDev->rawCleanupBytesRead;
            pIrDev->rcvState = STATE_INIT;
        }
        else
        {
            if( ReceiveGetFifoData( pIrDev, pRawBuf, &rawBytesRead, STIR4200_FIFO_SIZE ) == STATUS_SUCCESS )
			{
				if( rawBytesRead == (ULONG)-1 )
				{
					/***********************************************/
					/*   Receive error...back to INIT state...     */
					/***********************************************/
					pIrDev->rcvState	= STATE_INIT;
					pIrDev->readBufPos	= 0;
					continue;
				}
				else if( rawBytesRead == 0 )
				{
					/***********************************************/
					/*   No more receive bytes...break out...      */
					/***********************************************/
					break;
				}
			}
			else
				break;
        }

        /***********************************************/
        /*   Let  the  receive  state machine process  */
        /*   this group of bytes.                      */
        /*                                             */
        /*   NOTE:  We  have  to loop once more after  */
        /*   getting  MAX_RCV_DATA_SIZE bytes so that  */
        /*   we  can  see the 'EOF'; hence <= and not  */
        /*   <.                                        */
        /***********************************************/
        for( rawBufPos = 0;
             ((pIrDev->rcvState != STATE_SAW_EOF) && (rawBufPos < rawBytesRead) && 
			 (pIrDev->readBufPos <= (MAX_TOTAL_SIZE_WITH_ALL_HEADERS + FAST_IR_FCS_SIZE)));
             rawBufPos++ )
        {
            *pBytesProcessed += 1;
            ThisChar = pRawBuf[rawBufPos];
            switch( pIrDev->rcvState )
            {
				case STATE_INIT:
					switch( ThisChar )
					{
						case STIR4200_FIR_BOF:
							pIrDev->rcvState = STATE_GOT_FIR_BOF;
							break;
#if defined(WORKAROUND_XX_HANG)
						case 0x3F:
							if( (rawBufPos+1) < rawBytesRead )
							{
								if( pRawBuf[rawBufPos+1] == 0x3F )
								{
									DEBUGMSG(DBG_INT_ERR, 
										(" ReceiveFirStepFSM(): hang sequence in INIT state\n"));
									St4200ResetFifo( pIrDev );
								}
							}
							break;
#endif
#if defined(WORKAROUND_FF_HANG)
						case 0xFF:
							if( (rawBufPos+2) < rawBytesRead )
							{
								if( (pRawBuf[rawBufPos+2] == 0xFF) && (pRawBuf[rawBufPos+1] == 0xFF) &&
									(rawBytesRead>STIR4200_FIFO_OVERRUN_THRESHOLD) )
								{
									DEBUGMSG(DBG_INT_ERR, 
										(" ReceiveFirStepFSM(): overflow sequence in INIT state\n"));
									
									//
									// First time aroud try resetting the FIFO
									//
									if( !pIrDev->StuckFir )
									{
										St4200ResetFifo( pIrDev );
										pIrDev->StuckFir = TRUE;
									}
									//
									// Otherwise reset the part
									//
									else
									{
										InterlockedExchange( (PLONG)&pIrDev->fPendingClearTotalStall, TRUE );
										ScheduleWorkItem( pIrDev, RestoreIrDevice, NULL, 0 );
										pIrDev->StuckFir = FALSE;
									}
									rawBufPos = rawBytesRead;
									ForceExit = TRUE;
								}
							}
							break;
#endif
						default:
							DEBUGMSG(DBG_INT_ERR, 
								(" ReceiveFirStepFSM(): invalid char in INIT state\n"));
							break;
					}
					break;

				case STATE_GOT_FIR_BOF:
					switch( ThisChar )
					{
						case STIR4200_FIR_BOF:
							pIrDev->rcvState = STATE_GOT_BOF;
							break;
#if defined(WORKAROUND_BAD_ESC)
						case STIR4200_FIR_ESC_CHAR:
							DEBUGMSG(DBG_INT_ERR, 
								(" ReceiveFirStepFSM(): invalid char in BOF state, bufpos=%d, char=%X\n", pIrDev->readBufPos, (ULONG)ThisChar));
							if( rawBufPos < (rawBytesRead-1) )
							{
								pIrDev->rcvState = STATE_GOT_BOF;
								rawBufPos ++;
							}
							else
							{
								pIrDev->rcvState = STATE_INIT;
								pIrDev->readBufPos = 0;
							}
							break;
#endif
						default:
							DEBUGMSG(DBG_INT_ERR, 
								(" ReceiveFirStepFSM(): invalid char in BOF state, bufpos=%d, char=%X\n", pIrDev->readBufPos, (ULONG)ThisChar));
#if defined(WORKAROUND_BAD_SOF)
							pIrDev->rcvState = STATE_GOT_BOF;
							rawBufPos --;
#else
							pIrDev->rcvState = STATE_INIT;
							pIrDev->readBufPos = 0;
#endif
							break;
					}
					break;

				case STATE_GOT_BOF:
					switch( ThisChar )
					{
						case STIR4200_FIR_BOF:
							/***********************************************/
							/*   It's a mistake, but could still be valid data
							/***********************************************/
							DEBUGMSG(DBG_INT_ERR, 
								(" ReceiveFirStepFSM(): More than legal BOFs, bufpos=%d\n", pIrDev->readBufPos));
							pIrDev->rcvState = STATE_GOT_BOF;
							pIrDev->readBufPos = 0;                    
							break;
						case STIR4200_FIR_PREAMBLE:
							/***********************************************/
							/*   Garbage                                   */
							/***********************************************/
							DEBUGMSG(DBG_INT_ERR, 
								(" ReceiveFirStepFSM(): invalid char in BOF state, bufpos=%d, char=%X\n", pIrDev->readBufPos, (ULONG)ThisChar));
							pIrDev->packetsReceivedDropped ++;
							pIrDev->rcvState = STATE_INIT;
							pIrDev->readBufPos = 0;                     
							break;
						case STIR4200_FIR_ESC_CHAR:
							/***********************************************/
							/*   Start  of  data.  Our  first  data  byte  */
							/*   happens to be an ESC sequence.            */
							/***********************************************/
							pIrDev->rcvState = STATE_ESC_SEQUENCE;
							pIrDev->readBufPos = 0;
							break;
						default:
							pReadBuf[0] = ThisChar;
							pIrDev->rcvState = STATE_ACCEPTING;
							pIrDev->readBufPos = 1;
							break;
					}
					break;

				case STATE_ACCEPTING:
					switch( ThisChar )
					{
						case STIR4200_FIR_EOF:
#if defined( WORKAROUND_33_HANG )
							if( pIrDev->readBufPos < (IRDA_A_C_TOTAL_SIZE + FAST_IR_FCS_SIZE - 1) )
#else
							if( pIrDev->readBufPos < (IRDA_A_C_TOTAL_SIZE + FAST_IR_FCS_SIZE) )
#endif
							{
								DEBUGMSG(DBG_INT_ERR, 
									("ReceiveFirStepFSM(): WARNING: EOF encountered in short packet, bufpos=%d\n", pIrDev->readBufPos));
								pIrDev->packetsReceivedRunt ++;
								pIrDev->rcvState = STATE_INIT;
								pIrDev->readBufPos = 0;
							}
							else
							{
#if defined( WORKAROUND_MISSING_7E )
								// Force to get out if there is one EOF and we have no more data
								if( rawBufPos == (rawBytesRead-1) )
								{
#if !defined(ONLY_ERROR_MESSAGES)
									DEBUGMSG(DBG_INT_ERR, ("ReceiveFirStepFSM(): Using a single 7E EOF\n"));
#endif
									pIrDev->rcvState = STATE_SAW_EOF;
								}
								else
									pIrDev->rcvState = STATE_SAW_FIR_BOF;
#else
								pIrDev->rcvState = STATE_SAW_FIR_BOF;
#endif
							}
							break;
						case STIR4200_FIR_ESC_CHAR:
							pIrDev->rcvState = STATE_ESC_SEQUENCE;
							break;
						case STIR4200_FIR_PREAMBLE:
							DEBUGMSG(DBG_INT_ERR, 
								(" ReceiveFirStepFSM(): invalid preamble char in ACCEPTING state, bufpos=%d\n", pIrDev->readBufPos));
							pIrDev->packetsReceivedDropped ++;
							pIrDev->rcvState = STATE_INIT;
							pIrDev->readBufPos = 0;                    
							break;
						default:
							pReadBuf[pIrDev->readBufPos++] = ThisChar;
							break;
					}
					break;

				case STATE_ESC_SEQUENCE:
					switch( ThisChar )
					{
						case STIR4200_FIR_ESC_DATA_7D:
							pReadBuf[pIrDev->readBufPos++] = 0x7d;
							pIrDev->rcvState = STATE_ACCEPTING;
							break;
						case STIR4200_FIR_ESC_DATA_7E:
							pReadBuf[pIrDev->readBufPos++] = 0x7e;
							pIrDev->rcvState = STATE_ACCEPTING;
							break;
						case STIR4200_FIR_ESC_DATA_7F:
							pReadBuf[pIrDev->readBufPos++] = 0x7f;
							pIrDev->rcvState = STATE_ACCEPTING;
							break;
						default:
							DEBUGMSG(DBG_INT_ERR, 
								(" ReceiveFirStepFSM(): invalid escaped char=%X\n", (ULONG)ThisChar));
							pIrDev->packetsReceivedDropped ++;
							pIrDev->rcvState = STATE_INIT;
							pIrDev->readBufPos = 0;
							break;
					}
					break;

				case STATE_SAW_FIR_BOF:
					switch( ThisChar )
					{
						case STIR4200_FIR_EOF:
							pIrDev->rcvState = STATE_SAW_EOF;
							break;
						default:
							DEBUGMSG(DBG_INT_ERR, 
								(" ReceiveFirStepFSM(): invalid char=%X, expected EOF\n", (ULONG)ThisChar));
							pIrDev->rcvState = STATE_SAW_EOF;
#if !defined(WORKAROUND_MISSING_7E)
							pIrDev->packetsReceivedDropped ++;
							pIrDev->rcvState = STATE_INIT;
							pIrDev->readBufPos = 0;
#endif
							break;
					}
					break;

				case STATE_SAW_EOF:
					default:
						DEBUGMSG(DBG_ERR, (" ReceiveFirStepFSM(): Illegal state, bufpos=%d\n", pIrDev->readBufPos));
						IRUSB_ASSERT( 0 );
						pIrDev->readBufPos = 0;
						pIrDev->rcvState = STATE_INIT;
						return FALSE;
            }
        }
    }

    // *  Set result and do any post-cleanup.
    switch( pIrDev->rcvState )
    {
		case STATE_SAW_EOF:
			/***********************************************/
			/*   We've  read  in the entire packet. Queue  */
			/*   it and return TRUE.                       */
			/***********************************************/
			pIrDev->StuckFir = FALSE;
 			pRecBuf->DataLen = pIrDev->readBufPos;
			pIrDev->pCurrentRecBuf = NULL;
			ReceiveDeliverBuffer(
					pIrDev,
					pRecBuf
				);
			FrameProcessed = TRUE;
			if( rawBufPos < rawBytesRead )
			{
				/***********************************************/
				/*   This   is   ugly.   We  have  some  more  */
				/*   unprocessed  bytes  in  the  raw buffer.  */
				/*   Move  these  to the beginning of the raw  */
				/*   buffer  go  to  the CLEANUP state, which  */
				/*   indicates  that  these  bytes be used up  */
				/*   during the next call. (This is typically  */
				/*   only 1 or 2 bytes).                       */
				/*                                             */
				/*   Note:  We  can't just leave these in the  */
				/*   raw   buffer   because   we   might   be  */
				/*   supporting  connections  to multiple COM  */
				/*   ports.                                    */
				/*                                             */
				/***********************************************/
				RtlMoveMemory( pRawBuf, &pRawBuf[rawBufPos], rawBytesRead - rawBufPos );
				pIrDev->rawCleanupBytesRead = rawBytesRead - rawBufPos;
				pIrDev->rcvState   = STATE_CLEANUP;
			}
			else
			{
				pIrDev->rcvState = STATE_INIT;
			}
			pIrDev->readBufPos = 0;                                 
			break;
		default:
			if( pIrDev->readBufPos > (MAX_TOTAL_SIZE_WITH_ALL_HEADERS + FAST_IR_FCS_SIZE) )
			{
				DEBUGMSG( DBG_INT_ERR,(" ReceiveFirStepFSM() Overflow\n"));
				St4200ResetFifo( pIrDev );

				pIrDev->packetsReceivedOverflow ++;
				pIrDev->rcvState    = STATE_INIT;
				pIrDev->readBufPos  = 0;
				pIrDev->pCurrentRecBuf = NULL;
				InterlockedExchange( &pRecBuf->DataLen, 0 );
				InterlockedExchange( (PULONG)&pRecBuf->BufferState, RCV_STATE_FREE );
			}
			else
			{
#if !defined(ONLY_ERROR_MESSAGES)
				DEBUGMSG(DBG_INT_ERR, 
					(" ReceiveFirStepFSM(): returning with partial packet, read %d bytes\n", pIrDev->readBufPos));
#endif
			}
			FrameProcessed = FALSE;
			break;
    }
    return FrameProcessed;
}


#if !defined(WORKAROUND_BROKEN_MIR)
/*****************************************************************************
*
*  Function:    ReceiveMirUnstuff
*
*  Synopsis:	Software unstuffing for a MIR frmae
*
*  Arguments:	pIrDev - pointer to the current IR device object
*				pBytesProcessed - pointer to bytes processed
*
*  Returns:		TRUE after an entire frame has been read in
*
*****************************************************************************/
BOOLEAN
ReceiveMirUnstuff(
		IN OUT PIR_DEVICE pIrDev,
		IN PUCHAR pInputBuffer,
		ULONG InputBufferSize,
		OUT PUCHAR pOutputBuffer,
		OUT PULONG pOutputBufferSize
	)
{
	ULONG MirIncompleteBitCount = pIrDev->MirIncompleteBitCount;
	ULONG MirOneBitCount = pIrDev->MirOneBitCount;
	UCHAR MirIncompleteByte = pIrDev->MirIncompleteByte;
	ULONG ByteCounter, BitCounter;
	BOOL MirUnstuffNext = FALSE;

	*pOutputBufferSize = 0;

	if( MirOneBitCount == 5 )
	{
		MirUnstuffNext = TRUE;
	}

	//
	// Loop on the input buffer
	//
	for( ByteCounter=0; ByteCounter<InputBufferSize; ByteCounter++ )
	{
		//
		// Loop on the byte
		//
		for( BitCounter=0; BitCounter<8; BitCounter++ )
		{
			//
			// test for one
			//
			if( pInputBuffer[ByteCounter] & (0x01<<BitCounter) )
			{
				//
				// Sixth one, reset
				//
				if( MirUnstuffNext )
				{
					MirOneBitCount = 0;
					MirUnstuffNext = FALSE;

					pIrDev->MirFlagCount ++;
				}
				//
				// Increase the one count
				//
				else
				{
					MirOneBitCount ++;
					if( MirOneBitCount == 5 )
					{
						MirUnstuffNext = TRUE;
					}
				}

				//
				// Copy to the temp byte
				//
				MirIncompleteByte += 0x01<<MirIncompleteBitCount;
				
				//
				// Increase the output bit count
				// 
				MirIncompleteBitCount ++;
			}
			else
			{
				//
				// Increase the output bit count if we are not stuffing
				// 
				if( !MirUnstuffNext )
				{
					MirIncompleteBitCount ++;
				}

				//
				// Reset
				//
				MirOneBitCount = 0;
				MirUnstuffNext = FALSE;

				//
				// No copy needs to be done
				//
			}

			//
			// Flush to output buffer
			//
			if( MirIncompleteBitCount == 8 )
			{
				pOutputBuffer[*pOutputBufferSize] = MirIncompleteByte;
				(*pOutputBufferSize) ++;

				MirIncompleteBitCount = 0;
				MirIncompleteByte = 0;
			}

			//
			// Check for complete packet
			//
			if( pIrDev->MirFlagCount == 2 )
			{
				pIrDev->MirFlagCount = 0;

				pIrDev->MirIncompleteBitCount = 0;
				pIrDev->MirOneBitCount = 0;
				pIrDev->MirIncompleteByte = 0;

				return TRUE;
			}
		}
	}
	
	//
	// roll over
	//
	pIrDev->MirIncompleteBitCount = MirIncompleteBitCount;
	pIrDev->MirOneBitCount = MirOneBitCount;
	pIrDev->MirIncompleteByte = MirIncompleteByte;
	
	return FALSE;
}
#endif


/*****************************************************************************
*
*  Function:    ReceiveMirStepFSM
*
*  Synopsis:	Step the receive FSM to read in a piece of an IrDA frame. 
*				Strip the BOFs and EOF, and eliminate escape sequences.
*
*  Arguments:	pIrDev - pointer to the current IR device object
*				pBytesProcessed - pointer to bytes processed
*
*  Returns:		TRUE after an entire frame has been read in
*				FALSE otherwise
*
*****************************************************************************/
BOOLEAN
ReceiveMirStepFSM(
		IN OUT PIR_DEVICE pIrDev, 
		OUT PULONG pBytesProcessed
	)
{
    ULONG           rawBufPos=0, rawBytesRead=0;
    BOOLEAN         FrameProcessed = FALSE, ForceExit = FALSE;
    UCHAR           ThisChar;
    PUCHAR          pRawBuf, pReadBuf;
	PRCV_BUFFER		pRecBuf;
    
	*pBytesProcessed = 0;

	if( !pIrDev->pCurrentRecBuf )
	{
		UINT Index;

		pRecBuf = ReceiveGetBuf( pIrDev, &Index, RCV_STATE_FULL );
		if ( !pRecBuf)
		{
			//
			// no buffers available; stop
			//
			DEBUGMSG(DBG_ERR, (" ReceiveMirStepFSM out of buffers\n"));
			pIrDev->packetsReceivedNoBuffer ++;
			return FALSE;
		}

		pIrDev->pCurrentRecBuf = pRecBuf;
	}
	else
		pRecBuf = pIrDev->pCurrentRecBuf;

	pReadBuf = pRecBuf->pDataBuf;
    pRawBuf = pIrDev->pRawBuf;

    /***********************************************/
    /*   Read  in  and process groups of incoming  */
    /*   bytes from the FIFO.                      */
    /***********************************************/
    while( (pIrDev->rcvState != STATE_SAW_EOF) && 
		(pIrDev->readBufPos <= (MAX_TOTAL_SIZE_WITH_ALL_HEADERS + MEDIUM_IR_FCS_SIZE)) &&
		!ForceExit )
    {
        if( pIrDev->rcvState == STATE_CLEANUP )
        {
            /***********************************************/
            /*   We returned a complete packet last time,  */
            /*   but  we had read some extra bytes, which  */
            /*   we   stored   into   the   rawBuf  after  */
            /*   returning  the  previous complete buffer  */
            /*   to  the  user.  So  instead  of  calling  */
            /*   DoRcvDirect() in this first execution of  */
            /*   this  loop, we just use these previously  */
            /*   read bytes. (This is typically only 1 or  */
            /*   2 bytes).                                 */
            /***********************************************/
            rawBytesRead = pIrDev->rawCleanupBytesRead;
            pIrDev->rcvState = STATE_INIT;
        }
        else
        {
            if( ReceiveGetFifoData( pIrDev, pRawBuf, &rawBytesRead, STIR4200_FIFO_SIZE ) == STATUS_SUCCESS )
			{
				if( rawBytesRead == (ULONG)-1 )
				{
					/***********************************************/
					/*   Receive error...back to INIT state...     */
					/***********************************************/
					pIrDev->rcvState	= STATE_INIT;
					pIrDev->readBufPos	= 0;
					continue;
				}
				else if( rawBytesRead == 0 )
				{
					/***********************************************/
					/*   No more receive bytes...break out...      */
					/***********************************************/
					break;
				}
			}
			else
				break;
        }

        /***********************************************/
        /*   Let  the  receive  state machine process  */
        /*   this group of bytes.                      */
        /*                                             */
        /*   NOTE:  We  have  to loop once more after  */
        /*   getting  MAX_RCV_DATA_SIZE bytes so that  */
        /*   we  can  see the 'EOF'; hence <= and not  */
        /*   <.                                        */
        /***********************************************/
        for( rawBufPos = 0;
             ((pIrDev->rcvState != STATE_SAW_EOF) && (rawBufPos < rawBytesRead) && 
			 (pIrDev->readBufPos <= (MAX_TOTAL_SIZE_WITH_ALL_HEADERS + MEDIUM_IR_FCS_SIZE)));
             rawBufPos++ )
        {
            *pBytesProcessed += 1;
            ThisChar = pRawBuf[rawBufPos];
            switch( pIrDev->rcvState )
            {
				case STATE_INIT:
					switch( ThisChar )
					{
						case STIR4200_MIR_BOF:
							pIrDev->rcvState = STATE_GOT_MIR_BOF;
							break;
						case 0xFF:
							if( ((rawBufPos+2) < rawBytesRead) && (rawBufPos==0) )
							{
								if( (pRawBuf[rawBufPos+2] == 0xFF) && (pRawBuf[rawBufPos+1] == 0xFF) )
								{
									DEBUGMSG(DBG_INT_ERR, 
										(" ReceiveMirStepFSM(): overflow sequence in INIT state\n"));
									St4200ResetFifo( pIrDev );
									St4200SoftReset( pIrDev );
									//rawBufPos = rawBytesRead;
									//ForceExit = TRUE;
								}
							}
							break;
						default:
							break;
					}
					break;

				case STATE_GOT_MIR_BOF:
					switch( ThisChar )
					{
						case STIR4200_MIR_BOF:
							pIrDev->rcvState = STATE_GOT_BOF;
							break;
						default:
							DEBUGMSG(DBG_INT_ERR, 
								(" ReceiveMirStepFSM(): invalid char in BOF state, bufpos=%d\n", pIrDev->readBufPos));
							pIrDev->rcvState = STATE_INIT;
							pIrDev->readBufPos = 0;
							break;
					}
					break;

				case STATE_GOT_BOF:
					switch( ThisChar )
					{
						case STIR4200_MIR_BOF:
							/***********************************************/
							/*   It's a mistake, but could still be valid data
							/***********************************************/
							DEBUGMSG(DBG_INT_ERR, 
								(" ReceiveMirStepFSM(): More than legal BOFs, bufpos=%d\n", pIrDev->readBufPos));
							pIrDev->readBufPos = 0;                    
							pIrDev->rcvState = STATE_GOT_BOF;
							break;
						case STIR4200_MIR_ESC_CHAR:
							/***********************************************/
							/*   Start  of  data.  Our  first  data  byte  */
							/*   happens to be an ESC sequence.            */
							/***********************************************/
							pIrDev->readBufPos = 0;
							pIrDev->rcvState = STATE_ESC_SEQUENCE;
							break;
						default:
							pReadBuf[0] = ThisChar;
							pIrDev->readBufPos = 1;
							pIrDev->rcvState = STATE_ACCEPTING;
							break;
					}
					break;

				case STATE_ACCEPTING:
					switch( ThisChar )
					{
						case STIR4200_MIR_EOF:
							if( pIrDev->readBufPos < (IRDA_A_C_TOTAL_SIZE + MEDIUM_IR_FCS_SIZE) )
							{
								DEBUGMSG(DBG_INT_ERR, 
									(" ReceiveMirStepFSM(): WARNING: EOF encountered in short packet, bufpos=%d\n", pIrDev->readBufPos));
								pIrDev->packetsReceivedRunt ++;
								pIrDev->rcvState = STATE_INIT;
								pIrDev->readBufPos = 0;
							}
							else
							{
								pIrDev->rcvState = STATE_SAW_FIR_BOF;
							}
							break;
						case STIR4200_MIR_ESC_CHAR:
							pIrDev->rcvState = STATE_ESC_SEQUENCE;
							break;
						default:
							pReadBuf[pIrDev->readBufPos++] = ThisChar;
							break;
					}
					break;

				case STATE_ESC_SEQUENCE:
					switch( ThisChar )
					{
						case STIR4200_MIR_ESC_DATA_7D:
							pReadBuf[pIrDev->readBufPos++] = 0x7d;
							pIrDev->rcvState = STATE_ACCEPTING;
							break;
						case STIR4200_MIR_ESC_DATA_7E:
							pReadBuf[pIrDev->readBufPos++] = 0x7e;
							pIrDev->rcvState = STATE_ACCEPTING;
							break;
						default:
							DEBUGMSG(DBG_INT_ERR, 
								(" ReceiveFirStepFSM(): invalid escaped char=%X\n", (ULONG)ThisChar));
							pIrDev->packetsReceivedDropped ++;
							pIrDev->rcvState = STATE_INIT;
							pIrDev->readBufPos = 0;
							break;
					}
					break;

				case STATE_SAW_MIR_BOF:
					switch( ThisChar )
					{
						case STIR4200_MIR_EOF:
							pIrDev->rcvState = STATE_SAW_EOF;
							break;
						default:
							DEBUGMSG(DBG_INT_ERR, 
								(" ReceiveMirStepFSM(): invalid char=%X, expected EOF\n", (ULONG)ThisChar));
							pIrDev->packetsReceivedDropped ++;
							pIrDev->rcvState = STATE_INIT;
							pIrDev->readBufPos = 0;
							break;
					}
					break;

				case STATE_SAW_EOF:
					default:
						DEBUGMSG(DBG_INT_ERR, 
							(" ReceiveMirStepFSM(): Illegal state, bufpos=%d\n", pIrDev->readBufPos));
						IRUSB_ASSERT( 0 );
						pIrDev->readBufPos = 0;
						pIrDev->rcvState = STATE_INIT;
						return FALSE;
            }
        }
    }

    // *  Set result and do any post-cleanup.
    switch( pIrDev->rcvState )
    {
		case STATE_SAW_EOF:
			/***********************************************/
			/*   We've  read  in the entire packet. Queue  */
			/*   it and return TRUE.                       */
			/***********************************************/
 			pRecBuf->DataLen = pIrDev->readBufPos;
			pIrDev->pCurrentRecBuf = NULL;
			ReceiveDeliverBuffer(
					pIrDev,
					pRecBuf
				);
			FrameProcessed = TRUE;
			if( rawBufPos < rawBytesRead )
			{
				/***********************************************/
				/*   This   is   ugly.   We  have  some  more  */
				/*   unprocessed  bytes  in  the  raw buffer.  */
				/*   Move  these  to the beginning of the raw  */
				/*   buffer  go  to  the CLEANUP state, which  */
				/*   indicates  that  these  bytes be used up  */
				/*   during the next call. (This is typically  */
				/*   only 1 or 2 bytes).                       */
				/*                                             */
				/*   Note:  We  can't just leave these in the  */
				/*   raw   buffer   because   we   might   be  */
				/*   supporting  connections  to multiple COM  */
				/*   ports.                                    */
				/*                                             */
				/***********************************************/
				RtlMoveMemory( pRawBuf, &pRawBuf[rawBufPos], rawBytesRead - rawBufPos );
				pIrDev->rawCleanupBytesRead = rawBytesRead - rawBufPos;
				pIrDev->rcvState   = STATE_CLEANUP;
			}
			else
			{
				pIrDev->rcvState = STATE_INIT;
			}
			pIrDev->readBufPos = 0;                                 
			break;
		default:
			if( pIrDev->readBufPos > (MAX_TOTAL_SIZE_WITH_ALL_HEADERS + MEDIUM_IR_FCS_SIZE) )
			{
				DEBUGMSG( DBG_INT_ERR,(" ReceiveMirStepFSM() Overflow\n"));

				pIrDev->packetsReceivedOverflow ++;
				pIrDev->readBufPos  = 0;
				pIrDev->rcvState    = STATE_INIT;
				pIrDev->pCurrentRecBuf = NULL;
				InterlockedExchange( &pRecBuf->DataLen, 0 );
				InterlockedExchange( (PULONG)&pRecBuf->BufferState, RCV_STATE_FREE );
			}
			else
			{
#if !defined(ONLY_ERROR_MESSAGES)
				DEBUGMSG(DBG_INT_ERR, 
					(" ReceiveMirStepFSM(): returning with partial packet, read %d bytes\n", pIrDev->readBufPos));
#endif
			}
			FrameProcessed = FALSE;
			break;
    }
    return FrameProcessed;
}


/*****************************************************************************
*
*  Function:    ReceiveSirStepFSM
*
*  Synopsis:	Step the receive FSM to read in a piece of an IrDA frame. 
*				Strip the BOFs and EOF, and eliminate escape sequences.
*
*  Arguments:	pIrDev - pointer to the current IR device object
*				pBytesProcessed - pointer to bytes processed
*
*  Returns:		TRUE after an entire frame has been read in
*				FALSE otherwise
*
*****************************************************************************/
BOOLEAN     
ReceiveSirStepFSM(
		IN OUT PIR_DEVICE pIrDev, 
		OUT PULONG pBytesProcessed
	)
{
    ULONG           rawBufPos=0, rawBytesRead=0;
    BOOLEAN         FrameProcessed = FALSE, ForceExit = FALSE;
    UCHAR           ThisChar;
    PUCHAR          pRawBuf, pReadBuf;
	PRCV_BUFFER		pRecBuf;

    *pBytesProcessed = 0;

	if( !pIrDev->pCurrentRecBuf )
	{
		UINT Index;
		
		pRecBuf = ReceiveGetBuf( pIrDev, &Index, RCV_STATE_FULL );
		if ( !pRecBuf)
		{
			//
			// no buffers available; stop
			//
			DEBUGMSG(DBG_ERR, (" ReceiveSirStepFSM out of buffers\n"));
			pIrDev->packetsReceivedNoBuffer ++;
			return FALSE;
		}

		pIrDev->pCurrentRecBuf = pRecBuf;
	}
	else
		pRecBuf = pIrDev->pCurrentRecBuf;

	pReadBuf = pRecBuf->pDataBuf;
    pRawBuf = pIrDev->pRawBuf;

    // Read in and process groups of incoming bytes from the FIFO.
    // NOTE:  We have to loop once more after getting MAX_RCV_DATA_SIZE
    //        bytes so that we can see the 'EOF'; hence <= and not <.
    while( (pIrDev->rcvState != STATE_SAW_EOF) &&
           (pIrDev->readBufPos <= (MAX_TOTAL_SIZE_WITH_ALL_HEADERS + SLOW_IR_FCS_SIZE)) &&
		   !ForceExit )
    {
        if( pIrDev->rcvState == STATE_CLEANUP )
        {
            /***********************************************/
            /*   We returned a complete packet last time,  */
            /*   but  we had read some extra bytes, which  */
            /*   we   stored   into   the   rawBuf  after  */
            /*   returning  the  previous complete buffer  */
            /*   to  the  user.  So  instead  of  calling  */
            /*   DoRcvDirect() in this first execution of  */
            /*   this  loop, we just use these previously  */
            /*   read bytes. (This is typically only 1 or  */
            /*   2 bytes).                                 */
            /***********************************************/
            rawBytesRead		= pIrDev->rawCleanupBytesRead;
            pIrDev->rcvState    = STATE_INIT;
        }
        else
        {
            if( ReceiveGetFifoData( pIrDev, pRawBuf, &rawBytesRead, STIR4200_FIFO_SIZE ) == STATUS_SUCCESS )
			{
				if( rawBytesRead == (ULONG)-1 )
				{
					/***********************************************/
					/*   Receive error...back to INIT state...     */
					/***********************************************/
					DEBUGMSG( DBG_ERR,(" ReceiveSirStepFSM() Error in receiving packet\n"));
					pIrDev->rcvState	= STATE_INIT;
					pIrDev->readBufPos	= 0;
					continue;
				}
				else if( rawBytesRead == 0 )
				{
					/***********************************************/
					/*   No more receive bytes...break out...      */
					/***********************************************/
#if defined(WORKAROUND_MISSING_C1)
					if( (pIrDev->rcvState == STATE_ACCEPTING) && (pIrDev->ChipRevision <= CHIP_REVISION_7) )
					{
						pIrDev->rcvState = STATE_SAW_EOF;
						DEBUGMSG(DBG_INT_ERR, (" ReceiveSirStepFSM(): Missing C1 workaround\n"));
						pRecBuf->MissingC1Detected = TRUE;
					}
#endif
#if defined(WORKAROUND_CASIO)
					if( (pRecBuf->MissingC1Possible) && 
						(pIrDev->rcvState == STATE_ACCEPTING) && (pIrDev->currentSpeed != SPEED_9600) ) 
					{
						pIrDev->rcvState = STATE_SAW_EOF;
						//DEBUGMSG(DBG_INT_ERR, (" ReceiveSirStepFSM(): Missing C1 workaround\n"));
						pRecBuf->MissingC1Detected = TRUE;
						pRecBuf->MissingC1Possible = FALSE;
					}
					if( (pIrDev->rcvState == STATE_ACCEPTING) && (pIrDev->currentSpeed != SPEED_9600) ) 
					{
						pRecBuf->MissingC1Possible = TRUE;
						goto no_break;
					}
#endif
					break;
#if defined(WORKAROUND_CASIO)
no_break:			;
#endif
				}
#if defined(WORKAROUND_CASIO)
				else
				{
					pRecBuf->MissingC1Possible = FALSE;
				}
#endif
			}
			else
				break;
        }

        /***********************************************/
        /*   Let  the  receive  state machine process  */
        /*   this group of bytes.                      */
        /*                                             */
        /*   NOTE:  We  have  to loop once more after  */
        /*   getting  MAX_RCV_DATA_SIZE bytes so that  */
        /*   we  can  see the 'EOF'; hence <= and not  */
        /*   <.                                        */
        /***********************************************/
        for( rawBufPos = 0; 
			((pIrDev->rcvState != STATE_SAW_EOF) && (rawBufPos < rawBytesRead) && 
			(pIrDev->readBufPos <= (MAX_TOTAL_SIZE_WITH_ALL_HEADERS + SLOW_IR_FCS_SIZE)));
			rawBufPos ++ )
        {
            *pBytesProcessed += 1;
            ThisChar = pRawBuf[rawBufPos];
            switch( pIrDev->rcvState )
            {
				case STATE_INIT:
					switch( ThisChar )
					{
#if defined(WORKAROUND_FF_HANG)
						case 0xFF:
							if( (rawBufPos+2) < rawBytesRead )
							{
								if( (pRawBuf[rawBufPos+2] == 0xFF) && (pRawBuf[rawBufPos+1] == 0xFF) &&
									(rawBytesRead>STIR4200_FIFO_OVERRUN_THRESHOLD) )
								{
									DEBUGMSG(DBG_INT_ERR, 
										(" ReceiveFirStepFSM(): overflow sequence in INIT state\n"));
									St4200DoubleResetFifo( pIrDev );
									rawBufPos = rawBytesRead;
									ForceExit = TRUE;
								}
							}
							break;
#endif
#if defined( WORKAROUND_E0_81_FLAG )
						// This will take care of wrong start flags at low rates
						case 0x81:
						case 0xe0:
#if !defined(ONLY_ERROR_MESSAGES)
							DEBUGMSG(DBG_INT_ERR, 
								(" ReceiveSirStepFSM(): WORKAROUND_E0_81_FLAG\n"));
#endif
#endif
						case SLOW_IR_BOF:
							pIrDev->rcvState = STATE_GOT_BOF;
							break;
						case SLOW_IR_EOF:
						case SLOW_IR_ESC:
						default:
							/***********************************************/
							/*   Byte is garbage...scan past it....        */
							/***********************************************/
							DEBUGMSG(DBG_INT_ERR, 
								(" ReceiveSirStepFSM(): invalid char in INIT state\n"));
							break;
					}
					break;

				case STATE_GOT_BOF:
					switch( ThisChar )
					{
						case SLOW_IR_BOF:
							break;
						case SLOW_IR_EOF:
							/***********************************************/
							/*   Garbage                                   */
							/***********************************************/
							DEBUGMSG( DBG_INT_ERR,(" ReceiveSirStepFSM() Invalid char in BOF state\n"));
							pIrDev->packetsReceivedDropped ++;
							pIrDev->rcvState = STATE_INIT;
							pIrDev->readBufPos = 0;                     
							break;
						case SLOW_IR_ESC:
							/***********************************************/
							/*   Start  of  data.  Our  first  data  byte  */
							/*   happens to be an ESC sequence.            */
							/***********************************************/
							pIrDev->rcvState    = STATE_ESC_SEQUENCE;
							pIrDev->readBufPos  = 0;
							break;
						default:
							pReadBuf[0] = ThisChar;
							pIrDev->rcvState   = STATE_ACCEPTING;
							pIrDev->readBufPos = 1;
							break;
					}
					break;

				case STATE_ACCEPTING:
					switch( ThisChar )
					{
						case SLOW_IR_BOF:
							//
							// Either a new packet is starting here and we're missing parts of the old one
							// or it's garbage
							//
#if !defined(WORKAROUND_MISSING_C1)
							DEBUGMSG( DBG_INT_ERR,(" ReceiveSirStepFSM() Invalid char in ACCEPTING state\n"));
							pIrDev->packetsReceivedDropped ++;
							pIrDev->rcvState    = STATE_INIT;
							pIrDev->readBufPos	= 0;
							break;
#elif defined(WORKAROUND_CASIO)
							pIrDev->rcvState    = STATE_GOT_BOF;
							pIrDev->readBufPos  = 0;
							break;
#else
							//
							// Take the packet and decrement the pointer in the FIFO decoding so that
							// the new packet can be processed
							//
							DEBUGMSG( DBG_INT_ERR,(" ReceiveSirStepFSM() C0 in ACCEPTING state, trying workaround\n"));
							rawBufPos --;
							pRecBuf->MissingC1Detected = TRUE;
#endif
						case SLOW_IR_EOF:
							if( pIrDev->readBufPos < (IRDA_A_C_TOTAL_SIZE + SLOW_IR_FCS_SIZE) )
							{
								pIrDev->packetsReceivedRunt ++;
								pIrDev->rcvState    = STATE_INIT;
								pIrDev->readBufPos  = 0;
#if defined(WORKAROUND_MISSING_C1)
								if( pRecBuf->MissingC1Detected )
									pRecBuf->MissingC1Detected = FALSE;
								else
									DEBUGMSG( DBG_INT_ERR,(" ReceiveSirStepFSM() Error packet too small\n"));
#else
								DEBUGMSG( DBG_INT_ERR,(" ReceiveSirStepFSM() Error packet too small\n"));
#endif
							}
							else
							{
								pIrDev->rcvState = STATE_SAW_EOF;
							}
							break;
						case SLOW_IR_ESC:
							pIrDev->rcvState = STATE_ESC_SEQUENCE;
							break;
						default:
							pReadBuf[pIrDev->readBufPos++] = ThisChar;
							break;
					}
					break;

				case STATE_ESC_SEQUENCE:
					switch( ThisChar )
					{
						case SLOW_IR_EOF:
						case SLOW_IR_BOF:
						case SLOW_IR_ESC:
							/***********************************************/
							/*   ESC + {EOF|BOF|ESC} is an abort sequence  */
							/***********************************************/
							pIrDev->rcvState    = STATE_INIT;
							pIrDev->readBufPos  = 0;
							break;
						case SLOW_IR_EOF ^ SLOW_IR_ESC_COMP:
						case SLOW_IR_BOF ^ SLOW_IR_ESC_COMP:
						case SLOW_IR_ESC ^ SLOW_IR_ESC_COMP:
							pReadBuf[pIrDev->readBufPos++]   = ThisChar ^ SLOW_IR_ESC_COMP;
							pIrDev->rcvState				= STATE_ACCEPTING;
							break;
#if defined(WORKAROUND_CASIO)
						case 0xf8:
							pReadBuf[pIrDev->readBufPos++]   = 0xc1;
							pIrDev->rcvState				= STATE_ACCEPTING;
							break;
						case 0xf0:
							pReadBuf[pIrDev->readBufPos++]   = 0xc0;
							pIrDev->rcvState				= STATE_ACCEPTING;
							break;
						/*case 0xf4:
							pReadBuf[pIrDev->readBufPos++]   = 0x7d;
							pIrDev->rcvState				= STATE_ACCEPTING;
							break;*/
#endif
						default:
							// junk
							DEBUGMSG(DBG_INT_ERR, 
								(" ReceiveSirStepFSM(): invalid escaped char=%X\n", (ULONG)ThisChar));
							pIrDev->packetsReceivedDropped ++;
							pIrDev->rcvState    = STATE_INIT;
							pIrDev->readBufPos	= 0;
							break;
					}
					break;

				case STATE_SAW_EOF:
					default:
						DEBUGMSG(DBG_INT_ERR, 
							(" ReceiveSirStepFSM(): Illegal state, bufpos=%d\n", pIrDev->readBufPos));
						IRUSB_ASSERT( 0 );
						pIrDev->rcvState    = STATE_INIT;
						pIrDev->readBufPos  = 0;
						return FALSE;
            }
        }
    }

    // *  Set result and do any post-cleanup.
    switch( pIrDev->rcvState )
    {
		case STATE_SAW_EOF:
			// We've read in the entire packet.
			// Queue it and return TRUE.
			pRecBuf->DataLen = pIrDev->readBufPos;
			pIrDev->pCurrentRecBuf = NULL;
			ReceiveDeliverBuffer(
					pIrDev,
					pRecBuf
				);
			FrameProcessed = TRUE;
			if( rawBufPos < rawBytesRead )
			{
				/***********************************************/
				/*   This   is   ugly.   We  have  some  more  */
				/*   unprocessed  bytes  in  the  raw buffer.  */
				/*   Move  these  to the beginning of the raw  */
				/*   buffer  go  to  the CLEANUP state, which  */
				/*   indicates  that  these  bytes be used up  */
				/*   during the next call. (This is typically  */
				/*   only 1 or 2 bytes).                       */
				/*                                             */
				/*   Note:  We  can't just leave these in the  */
				/*   raw   buffer   because   we   might   be  */
				/*   supporting  connections  to multiple COM  */
				/*   ports.                                    */
				/*                                             */
				/***********************************************/
				RtlMoveMemory( pRawBuf, &pRawBuf[rawBufPos], rawBytesRead - rawBufPos );
				pIrDev->rawCleanupBytesRead = rawBytesRead - rawBufPos;
				pIrDev->rcvState   = STATE_CLEANUP;
#if defined( WORKAROUND_9600_ANTIBOUNCING )
				if( (pIrDev->currentSpeed == SPEED_9600) && (pIrDev->ChipRevision <= CHIP_REVISION_7) )
				{
#if !defined(ONLY_ERROR_MESSAGES)
					DEBUGMSG(DBG_INT_ERR, (" ReceiveSirStepFSM(): Delaying\n"));
#endif
					NdisMSleep( 10*1000 );
				}
#endif
			}
			else
			{
				pIrDev->rcvState = STATE_INIT;
			}
			pIrDev->readBufPos = 0;                                 
			break;
		default:
			if( pIrDev->readBufPos > (MAX_TOTAL_SIZE_WITH_ALL_HEADERS + SLOW_IR_FCS_SIZE + 1) )
			{
				DEBUGMSG( DBG_INT_ERR,(" ReceiveSirStepFSM() Overflow\n"));

				pIrDev->packetsReceivedOverflow ++;
				pIrDev->rcvState    = STATE_INIT;
				pIrDev->readBufPos  = 0;
				pIrDev->pCurrentRecBuf = NULL;
				InterlockedExchange( &pRecBuf->DataLen, 0 );
				InterlockedExchange( (PULONG)&pRecBuf->BufferState, RCV_STATE_FREE );
			}
			else if( pIrDev->readBufPos == (MAX_TOTAL_SIZE_WITH_ALL_HEADERS + SLOW_IR_FCS_SIZE + 1) )
			{
				//DEBUGMSG( DBG_INT_ERR,(" ReceiveSirStepFSM() Overflow Workaround\n"));
				
				//
				// Try patching up
				//
				pRecBuf->DataLen = pIrDev->readBufPos-1;
				pIrDev->pCurrentRecBuf = NULL;
				ReceiveDeliverBuffer(
						pIrDev,
						pRecBuf
					);
				FrameProcessed = TRUE;
			}
			else
			{
#if !defined(ONLY_ERROR_MESSAGES)
				DEBUGMSG(DBG_INT_ERR, (" ReceiveSirStepFSM(): returning with partial packet, read %d bytes\n", pIrDev->readBufPos));
#endif
			}
			FrameProcessed = FALSE;
			break;
    }
    return FrameProcessed;
}


/*****************************************************************************
*
*  Function:   ReceiveProcessReturnPacket
*
*  Synopsis:   Returns the packet to the free pool after preparing for reuse
*
*  Arguments:  pThisDev - pointer to the current ir device object
*              pReceiveBuffer - pointer to a RCV_BUFFER struct
*
*  Returns:    None
*
*
*****************************************************************************/
VOID 
ReceiveProcessReturnPacket(
		OUT PIR_DEVICE pThisDev,
		OUT PRCV_BUFFER pReceiveBuffer
	)
{
	PNDIS_BUFFER	pBuffer;

	DEBUGONCE(DBG_FUNC, ("+ReceiveProcessReturnPacket\n"));
	
	//
	// Deallocate the buffer
	//
	NdisUnchainBufferAtFront( (PNDIS_PACKET)pReceiveBuffer->pPacket, &pBuffer );
	IRUSB_ASSERT( pBuffer );
	if( pBuffer ) 
	{
		NdisFreeBuffer( pBuffer );
	}

	//
	// Get ready to reuse
	//
	InterlockedExchange( &pReceiveBuffer->DataLen, 0 );
	InterlockedExchange( &pReceiveBuffer->fInRcvDpc, FALSE );
	InterlockedExchange( (PULONG)&pReceiveBuffer->BufferState, RCV_STATE_FREE );

#if DBG
	if( InterlockedDecrement(&pThisDev->packetsHeldByProtocol)<0 )
	{
		IRUSB_ASSERT(0);
	}
#endif

	DEBUGMSG(DBG_FUNC, ("-ReceiveProcessReturnPacket\n"));
}


/*****************************************************************************
*
*  Function:    ReceiveDeliverBuffer
*
*  Synopsis:	Delivers the buffer to the protocol via
*				NdisMIndicateReceivePacket.
*
*  Arguments:	pThisDev - pointer to the current ir device object
*				pRecBuf - poiter to descriptor to deliver
*
*  Returns:		None
*
*
*****************************************************************************/
VOID
ReceiveDeliverBuffer(
		IN OUT PIR_DEVICE pThisDev,
		IN PRCV_BUFFER pRecBuf
	)
{
	PNDIS_BUFFER	pBuffer;
	NDIS_STATUS		Status;

    DEBUGMSG(DBG_FUNC, ("+ReceiveDeliverBuffer\n"));

    if( pThisDev->currentSpeed <= MAX_MIR_SPEED )
    {
        USHORT sirfcs;
		
		/***********************************************/
        /*   The packet we have already has had BOFs,  */
        /*   EOF,  and * escape-sequences removed. It  */
        /*   contains  an  FCS code at the end, which  */
        /*   we need to verify and then remove before  */
        /*   delivering the frame. We compute the FCS  */
        /*   on   the  packet  with  the  packet  FCS  */
        /*   attached;   this   should   produce  the  */
        /*   constant value GOOD_FCS.                  */
        /***********************************************/
        if( (sirfcs = ComputeFCS16(pRecBuf->pDataBuf, pRecBuf->DataLen)) != GOOD_FCS )
        {
#if !defined(WORKAROUND_EXTRA_BYTE) && !defined(WORKAROUND_MISSING_C1)
            //
            // FCS error...drop frame...               
            //
			DEBUGMSG( DBG_INT_ERR,(" ReceiveDeliverBuffer(): Bad FCS, size: %d\n",pRecBuf->DataLen));
			pThisDev->packetsReceivedChecksum ++;
			InterlockedExchange( &pRecBuf->DataLen, 0 );
			InterlockedExchange( (PULONG)&pRecBuf->BufferState, RCV_STATE_FREE );
			goto done;
#else
			//
			// Calculate again stripping off the last byte
			//
			if( pRecBuf->MissingC1Detected )
			{
				if( (sirfcs = ComputeFCS16(pRecBuf->pDataBuf, pRecBuf->DataLen-1)) != GOOD_FCS )
				{
#if defined(RECEIVE_ERROR_LOGGING)
					if( pThisDev->ReceiveErrorFileHandle )
					{
						IO_STATUS_BLOCK IoStatusBlock;

						ZwWriteFile(
								pThisDev->ReceiveErrorFileHandle,
								NULL,
								NULL,
								NULL,
								&IoStatusBlock,
								pRecBuf->pDataBuf,
								pRecBuf->DataLen,
								(PLARGE_INTEGER)&pThisDev->ReceiveErrorFilePosition,
								NULL
						   );

						pThisDev->ReceiveErrorFilePosition += pRecBuf->DataLen;
					}
#endif
					//
					// It is really junk
					//
					DEBUGMSG( DBG_INT_ERR,(" ReceiveDeliverBuffer(): Bad FCS, size: %d\n",pRecBuf->DataLen));
					pThisDev->packetsReceivedChecksum ++;
					InterlockedExchange( &pRecBuf->DataLen, 0 );
					InterlockedExchange( (PULONG)&pRecBuf->BufferState, RCV_STATE_FREE );
					pRecBuf->MissingC1Detected = FALSE;
					goto done;
				}
				else
				{
					//
					// Readjust to get rid of the extra byte
					//
					pRecBuf->DataLen --;
					pRecBuf->MissingC1Detected = FALSE;
				}
			}
			else
			{
				//
				// Or maybe the first one
				//
				if( (sirfcs = ComputeFCS16(pRecBuf->pDataBuf+1, pRecBuf->DataLen-1)) != GOOD_FCS )
				{
#if defined(RECEIVE_ERROR_LOGGING)
					if( pThisDev->ReceiveErrorFileHandle )
					{
						IO_STATUS_BLOCK IoStatusBlock;

						ZwWriteFile(
								pThisDev->ReceiveErrorFileHandle,
								NULL,
								NULL,
								NULL,
								&IoStatusBlock,
								pRecBuf->pDataBuf,
								pRecBuf->DataLen,
								(PLARGE_INTEGER)&pThisDev->ReceiveErrorFilePosition,
								NULL
						   );

						pThisDev->ReceiveErrorFilePosition += pRecBuf->DataLen;
					}
#endif
					//
					// It is really junk
					//
					DEBUGMSG( DBG_INT_ERR,(" ReceiveDeliverBuffer(): Bad FCS, size: %d\n",pRecBuf->DataLen));
					pThisDev->packetsReceivedChecksum ++;
					InterlockedExchange( &pRecBuf->DataLen, 0 );
					InterlockedExchange( (PULONG)&pRecBuf->BufferState, RCV_STATE_FREE );
					goto done;
				}
				//
				else
				{
					//
					// Readjust to get rid of the extra byte
					//
					pRecBuf->DataLen --;
					RtlMoveMemory( pRecBuf->pDataBuf, &pRecBuf->pDataBuf[1], pRecBuf->DataLen );
				}
			}
#endif
        }

        /***********************************************/
        /*   Remove FCS from end of packet...          */
        /***********************************************/
        pRecBuf->DataLen -= SLOW_IR_FCS_SIZE;
    }
    else
    {
        LONG firfcs;

#if !defined(WORKAROUND_33_HANG)
        if( (firfcs = ComputeFCS32(pRecBuf->dataBuf, pRecBuf->dataLen)) != FIR_GOOD_FCS )
        {
			/***********************************************/
            /*   FCS error...drop frame...                 */
            /***********************************************/
			DEBUGMSG( DBG_INT_ERR,(" ReceiveDeliverBuffer(): Bad FCS, size: %d\n",pRecBuf->dataLen));
			pThisDev->packetsReceivedChecksum ++;
			InterlockedExchange( &pRecBuf->dataLen, 0 );
			InterlockedExchange( (PULONG)&pRecBuf->state, RCV_STATE_FREE );
			goto done;
        }
#else
        if( (firfcs = ComputeFCS32(pRecBuf->pDataBuf, pRecBuf->DataLen)) != FIR_GOOD_FCS )
        {
			NTSTATUS rc;
			
			//
			// Try again with the data stuffed with 0x33
			//
			if( pRecBuf->DataLen < (MAX_TOTAL_SIZE_WITH_ALL_HEADERS + FAST_IR_FCS_SIZE) )
			{
				pRecBuf->pDataBuf[pRecBuf->DataLen] = 0x33;
				pRecBuf->DataLen ++;

				if( (firfcs = ComputeFCS32(pRecBuf->pDataBuf, pRecBuf->DataLen)) != FIR_GOOD_FCS )
				{
#if defined(RECEIVE_ERROR_LOGGING)
					if( pThisDev->ReceiveErrorFileHandle )
					{
						IO_STATUS_BLOCK IoStatusBlock;

						ZwWriteFile(
								pThisDev->ReceiveErrorFileHandle,
								NULL,
								NULL,
								NULL,
								&IoStatusBlock,
								pRecBuf->pDataBuf,
								pRecBuf->DataLen,
								(PLARGE_INTEGER)&pThisDev->ReceiveErrorFilePosition,
								NULL
						   );

						pThisDev->ReceiveErrorFilePosition += pRecBuf->DataLen;
					}
#endif
					/***********************************************/
					/*   FCS error...drop frame...                 */
					/***********************************************/
					DEBUGMSG( DBG_INT_ERR,(" ReceiveDeliverBuffer(): Bad FCS, size: %d\n",pRecBuf->DataLen));
					pThisDev->ReceiveAdaptiveDelayBoost += STIR4200_DELTA_DELAY;
					if( pThisDev->ReceiveAdaptiveDelayBoost <= STIR4200_MAX_BOOST_DELAY )
						pThisDev->ReceiveAdaptiveDelay += STIR4200_DELTA_DELAY;
					DEBUGMSG( DBG_INT_ERR,(" ReceiveDeliverBuffer(): Delay: %d\n",pThisDev->ReceiveAdaptiveDelay));
					pThisDev->packetsReceivedChecksum ++;
					InterlockedExchange( &pRecBuf->DataLen, 0 );
					InterlockedExchange( (PULONG)&pRecBuf->BufferState, RCV_STATE_FREE );
					goto done;
				}
			}
			else
			{
#if defined(RECEIVE_ERROR_LOGGING)
				if( pThisDev->ReceiveErrorFileHandle )
				{
					IO_STATUS_BLOCK IoStatusBlock;

					ZwWriteFile(
							pThisDev->ReceiveErrorFileHandle,
							NULL,
							NULL,
							NULL,
							&IoStatusBlock,
							pRecBuf->pDataBuf,
							pRecBuf->DataLen,
							(PLARGE_INTEGER)&pThisDev->ReceiveErrorFilePosition,
							NULL
					   );

					pThisDev->ReceiveErrorFilePosition += pRecBuf->DataLen;
				}
#endif
				/***********************************************/
				/*   FCS error...drop frame...                 */
				/***********************************************/
				DEBUGMSG( DBG_INT_ERR,(" ReceiveDeliverBuffer(): Bad FCS, size: %d\n",pRecBuf->DataLen));
				pThisDev->ReceiveAdaptiveDelayBoost += STIR4200_DELTA_DELAY;
				if( pThisDev->ReceiveAdaptiveDelayBoost <= STIR4200_MAX_BOOST_DELAY )
					pThisDev->ReceiveAdaptiveDelay += STIR4200_DELTA_DELAY;
				DEBUGMSG( DBG_INT_ERR,(" ReceiveDeliverBuffer(): Delay: %d\n",pThisDev->ReceiveAdaptiveDelay));
				pThisDev->packetsReceivedChecksum ++;
				InterlockedExchange( &pRecBuf->DataLen, 0 );
				InterlockedExchange( (PULONG)&pRecBuf->BufferState, RCV_STATE_FREE );
				goto done;
			}

			//
			// Reset the USB of the part
			//
			if( pThisDev->ChipRevision <= CHIP_REVISION_7 )
			{
				St4200ResetFifo( pThisDev );
			}
        }
#endif

        /***********************************************/
        /*   Remove FCS from end of packet...          */
        /***********************************************/
        pRecBuf->DataLen -= FAST_IR_FCS_SIZE;
    }

	//
	// If in normal mode, give the packet to the protocol
	//
#if defined(DIAGS)
	if( !pThisDev->DiagsActive )
	{	
#endif
		NdisAllocateBuffer(
				&Status,
				&pBuffer,
				pThisDev->hBufferPool,
				(PVOID)pRecBuf->pDataBuf,		
				pRecBuf->DataLen		
			);
  
		if( Status != NDIS_STATUS_SUCCESS )
		{
			DEBUGMSG( DBG_ERR,(" ReceiveDeliverBuffer(): No packets available...\n"));
			InterlockedExchange( &pRecBuf->DataLen, 0);
			InterlockedExchange( (PULONG)&pRecBuf->BufferState, RCV_STATE_FREE );
			goto done;
		}
		
		NdisChainBufferAtFront( (PNDIS_PACKET)pRecBuf->pPacket, pBuffer );

		//
		// Fix up some other packet fields.
		// Remember, we only account for A and C fields
		//  
		NDIS_SET_PACKET_HEADER_SIZE(
				(PNDIS_PACKET)pRecBuf->pPacket,
				IRDA_CONTROL_FIELD_SIZE + IRDA_ADDRESS_FIELD_SIZE
			);

	#if DBG
		InterlockedIncrement( &pThisDev->packetsHeldByProtocol );
		if( pThisDev->packetsHeldByProtocol > pThisDev->MaxPacketsHeldByProtocol ) 
		{
			pThisDev->MaxPacketsHeldByProtocol = pThisDev->packetsHeldByProtocol;  //keep record of our longest attained len
		}
	#endif
#if !defined(ONLY_ERROR_MESSAGES)
		DEBUGMSG( DBG_INT_ERR,
			(" ReceiveDeliverBuffer() Handed packet to protocol, size: %d\n", pRecBuf->DataLen ));
#endif

		//
		// Indicate the packet to NDIS
		//
		NDIS_SET_PACKET_STATUS( (PNDIS_PACKET)pRecBuf->pPacket, NDIS_STATUS_PENDING );
		InterlockedExchange( &pRecBuf->fInRcvDpc, TRUE );
		NdisMIndicateReceivePacket(
				pThisDev->hNdisAdapter,
				&((PNDIS_PACKET)pRecBuf->pPacket),
				1
			);

		//
		// Check to see if the packet is not pending (patch for 98)
		//
#if defined(LEGACY_NDIS5)
		Status = NDIS_GET_PACKET_STATUS( (PNDIS_PACKET)pRecBuf->pPacket );
		if( (Status == NDIS_STATUS_SUCCESS) || (Status == NDIS_STATUS_RESOURCES) )
		{
			ReceiveProcessReturnPacket( pThisDev, pRecBuf ) ;
		}
#endif
#if defined(DIAGS)
	}
	//
	// Do a diagnostic receive
	//
	else
	{
#if !defined(ONLY_ERROR_MESSAGES)
		DEBUGMSG( DBG_INT_ERR,
			(" ReceiveDeliverBuffer() Queued packet, size: %d\n", pRecBuf->DataLen ));
#endif
		//
		// Put the buffer in the diagnostic queue
		//
		ExInterlockedInsertTailList(
				&pThisDev->DiagsReceiveQueue,
				&pRecBuf->ListEntry,
				&pThisDev->DiagsReceiveLock
			);
	}
#endif

done:
    DEBUGMSG(DBG_FUNC, ("-ReceiveDeliverBuffer\n"));
}

/*****************************************************************************
*
*  Function:   StIrUsbReturnPacket
*
*  Synopsis:   The protocol returns ownership of a receive packet to
*              the ir device object.
*
*  Arguments:  Context         - a pointer to the current ir device obect.
*              pReturnedPacket - a pointer the packet which the protocol
*                                is returning ownership.
*
*  Returns:    None.
*
*
*
*****************************************************************************/
VOID
StIrUsbReturnPacket(
		IN OUT NDIS_HANDLE Context,
		IN OUT PNDIS_PACKET pReturnedPacket
	)
{
	PIR_DEVICE		pThisDev;
	PNDIS_BUFFER	pBuffer;
	PRCV_BUFFER		pRecBuffer;
	UINT			Index;
	BOOLEAN			found = FALSE;

	DEBUGONCE(DBG_FUNC, ("+StIrUsbReturnPacket\n"));

    //
    // The context is just the pointer to the current ir device object.
    //
    pThisDev = CONTEXT_TO_DEV( Context );

    NdisInterlockedIncrement( (PLONG)&pThisDev->packetsReceived );

	//
	// Search the queue to find the right packet.
	//
	for( Index=0; Index < NUM_RCV_BUFS; Index ++ )
	{
		pRecBuffer = &(pThisDev->rcvBufs[Index]);

		if( ((PNDIS_PACKET) pRecBuffer->pPacket) == pReturnedPacket )
		{
			if( pRecBuffer->fInRcvDpc )
			{
				ReceiveProcessReturnPacket( pThisDev, pRecBuffer );
				found = TRUE;
			}
			else
			{
				DEBUGMSG(DBG_ERR, (" StIrUsbReturnPacket, queues are corrupt\n"));
				IRUSB_ASSERT( 0 );
			}
			break;
		}
	}

    //
    // Ensure that the packet was found.
    //
	IRUSB_ASSERT( found );

	DEBUGMSG(DBG_FUNC, ("-StIrUsbReturnPacket\n"));
}


/*****************************************************************************
*
*  Function:    ReceiveGetBuf
*
*  Synopsis:    Gets a receive buffer
*
*  Arguments:   pThisDev - a pointer to the current ir device obect
*				pIndex - pointer to return the buffer index
*				state - state to set the buffer to
*
*  Returns:		buffer
*
*
*****************************************************************************/
PRCV_BUFFER
ReceiveGetBuf(
		IN PIR_DEVICE pThisDev,
		OUT PUINT pIndex,
		IN RCV_BUFFER_STATE BufferState  
	)
{
	UINT			Index;
	PRCV_BUFFER		pBuf = NULL;

	DEBUGMSG(DBG_FUNC, ("+ReceiveGetBuf()\n"));

	//
	// Look for a free buffer to return
	//
	for( Index=0; Index<NUM_RCV_BUFS; Index++ )
	{
		if( pThisDev->rcvBufs[Index].BufferState == RCV_STATE_FREE )
		{
			//
			// set to input state
			//
			InterlockedExchange( (PULONG)&pThisDev->rcvBufs[Index].BufferState, (ULONG)BufferState ); 
			*pIndex = Index;
			pBuf = &(pThisDev->rcvBufs[*pIndex]);
			break;
		}
	}

	DEBUGMSG(DBG_FUNC, ("-ReceiveGetBuf()\n"));
	return pBuf;
}


/*****************************************************************************
*
*  Function:   ReceivePacketRead
*
*  Synopsis:   Reads a packet from the US device
*              the inbound USB header,  check for overrun,
*              deliver to the protocol
*
*  Arguments:  pThisDev - pointer to the current ir device object
*              pRecBuf - pointer to a RCV_BUFFER struct
*
*  Returns:    NT status code
*
*
*****************************************************************************/
NTSTATUS 
ReceivePacketRead( 
		IN PIR_DEVICE pThisDev,
		OUT PFIFO_BUFFER pRecBuf
	)
{
    ULONG				UrbSize;
    ULONG				TransferLength;
    PURB				pUrb = NULL;
    PDEVICE_OBJECT		pUrbTargetDev;
    PIO_STACK_LOCATION	pNextStack;
    NTSTATUS			Status = STATUS_UNSUCCESSFUL;

    DEBUGMSG(DBG_FUNC, ("+ReceivePacketRead()\n"));

	IRUSB_ASSERT( KeGetCurrentIrql() == PASSIVE_LEVEL );

    UrbSize = sizeof(struct _URB_BULK_OR_INTERRUPT_TRANSFER);
    TransferLength = STIR4200_FIFO_SIZE;

	//
	// Stop if a halt/reset/suspend is going on
	//
	if( pThisDev->fPendingReadClearStall || pThisDev->fPendingHalt || 
		pThisDev->fPendingReset || pThisDev->fPendingClearTotalStall || !pThisDev->fProcessing ) 
	{
		//
		// USB reset going on?
		//
		DEBUGMSG( DBG_ERR,(" ReceivePacketRead() rejecting a packet due to pendig halt/reset\n"));
		
		Status = STATUS_UNSUCCESSFUL;
		goto done;
	}

	//
	// MS Security recommendation - allocate a new urb.
	//
	pRecBuf->UrbLen = UrbSize;
	pRecBuf->pUrb = MyUrbAlloc(pRecBuf->UrbLen);
	if (pRecBuf->pUrb == NULL)
	{
        DEBUGMSG(DBG_ERR, (" ReceivePacketRead abort due to urb alloc failure\n"));
		goto done;
	}
	pUrb = pRecBuf->pUrb;

    IRUSB_ASSERT( pThisDev->BulkInPipeHandle );

    //
    // Now that we have created the urb, we will send a
    // request to the USB device object.
    //
    KeClearEvent( &pThisDev->EventSyncUrb );

    pUrbTargetDev = pThisDev->pUsbDevObj;

    IRUSB_ASSERT( pUrbTargetDev );

	//
	// make an irp sending to usbhub
	//
	pRecBuf->pIrp = IoAllocateIrp( (CCHAR)(pThisDev->pUsbDevObj->StackSize + 1), FALSE );

    if( NULL == pRecBuf->pIrp )
    {
        DEBUGMSG(DBG_ERR, ("  read failed to alloc IRP\n"));
 		MyUrbFree(pRecBuf->pUrb, pRecBuf->UrbLen);
		pRecBuf->pUrb = NULL;
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto done;
    }

    ((PIRP)pRecBuf->pIrp)->IoStatus.Status = STATUS_PENDING;
    ((PIRP)pRecBuf->pIrp)->IoStatus.Information = 0;

	//
	// Build our URB for USBD
	//
    pUrb->UrbBulkOrInterruptTransfer.Hdr.Length = (USHORT)UrbSize;
    pUrb->UrbBulkOrInterruptTransfer.Hdr.Function = URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER;
    pUrb->UrbBulkOrInterruptTransfer.PipeHandle = pThisDev->BulkInPipeHandle;
    pUrb->UrbBulkOrInterruptTransfer.TransferFlags = USBD_TRANSFER_DIRECTION_IN ;
	
	//
    // short packet is not treated as an error.
    //
	pUrb->UrbBulkOrInterruptTransfer.TransferFlags |= USBD_SHORT_TRANSFER_OK;

    //
    // not using linked urb's
    //
    pUrb->UrbBulkOrInterruptTransfer.UrbLink = NULL;
    pUrb->UrbBulkOrInterruptTransfer.TransferBufferMDL = NULL;
    pUrb->UrbBulkOrInterruptTransfer.TransferBuffer = pRecBuf->pDataBuf;
    pUrb->UrbBulkOrInterruptTransfer.TransferBufferLength = TransferLength;

    //
    // Call the class driver to perform the operation.
	//
    pNextStack = IoGetNextIrpStackLocation( (PIRP)pRecBuf->pIrp );

    IRUSB_ASSERT( pNextStack != NULL );

    //
    // pass the URB to the USB driver stack
    //
	pNextStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
	pNextStack->Parameters.Others.Argument1 = pUrb;
	pNextStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_INTERNAL_USB_SUBMIT_URB;

    IoSetCompletionRoutine(
			((PIRP)pRecBuf->pIrp),		// irp to use
			ReceiveCompletePacketRead,  // routine to call when irp is done
			pRecBuf,					// context to pass routine is the RCV_BUFFER
			TRUE,						// call on success
			TRUE,						// call on error
			TRUE						// call on cancel
		);

	//
    // Call IoCallDriver to send the irp to the usb port.
    //
	InterlockedExchange( (PLONG)&pRecBuf->BufferState, RCV_STATE_PENDING );
	Status = MyIoCallDriver( pThisDev, pUrbTargetDev, (PIRP)pRecBuf->pIrp ); // Start UsbRead()

    DEBUGMSG(DBG_FUNC, (" ReceivePacketRead() after IoCallDriver () status = 0x%x\n", Status));

	IRUSB_ASSERT( STATUS_SUCCESS != Status );

	//
	// Wait for completion
	//
	Status = MyKeWaitForSingleObject(
			pThisDev,
			&pThisDev->EventSyncUrb,	// event to wait on
			0 
		);

	if( Status == STATUS_TIMEOUT ) 
	{
		// MS Security recommendation - cannot cancel IRP.
	}
	else
	{
		//
		// Update the status to reflect the real return code
		//
		Status = pThisDev->StatusSendReceive;
	}

	IRUSB_ASSERT( NULL == pRecBuf->pIrp ); // Will be nulled by completion routine
    DEBUGMSG(DBG_FUNC, (" ReceivePacketRead() after KeWaitForSingleObject() Status = 0x%x\n", Status));

done:
    DEBUGMSG(DBG_FUNC, ("-ReceivePacketRead()\n"));
    return Status;
}


/*****************************************************************************
*
*  Function:   ReceiveCompletePacketRead
*
*  Synopsis:   Completes USB read operation
*
*  Arguments:  pUsbDevObj - pointer to the USB device object which
*                              completed the irp
*              pIrp - the irp which was completed by the
*                              device object
*              Context - the context given to IoSetCompletionRoutine
*                              before calling IoCallDriver on the irp
*                              The Context is a pointer to the ir device object.
*
*  Returns:    STATUS_MORE_PROCESSING_REQUIRED - allows the completion routine
*              (IofCompleteRequest) to stop working on the irp.
*
*
*****************************************************************************/
NTSTATUS
ReceiveCompletePacketRead(
		IN PDEVICE_OBJECT pUsbDevObj,
		IN PIRP           pIrp,
		IN PVOID          Context
	)
{
    PIR_DEVICE		pThisDev;
    NTSTATUS		status;
    ULONG_PTR		BytesRead;
	PFIFO_BUFFER	pFifoBuf;
	PURB			pUrb;

    DEBUGMSG(DBG_FUNC, ("+ReceiveCompletePacketRead\n"));

    //
    // The context given to ReceiveCompletePacketRead is the receive buffer object
    //
	pFifoBuf = (PFIFO_BUFFER)Context;

    pThisDev = (PIR_DEVICE)pFifoBuf->pThisDev;

    IRUSB_ASSERT( pFifoBuf->pIrp == pIrp );

    IRUSB_ASSERT( NULL != pThisDev );

	pUrb = pFifoBuf->pUrb;
	IRUSB_ASSERT( pUrb != NULL );

    //
    // We have a number of cases:
    //      1) The USB read timed out and we received no data.
    //      2) The USB read timed out and we received some data.
    //      3) The USB read was successful and fully filled our irp buffer.
    //      4) The irp was cancelled.
    //      5) Some other failure from the USB device object.
    //
    status = pIrp->IoStatus.Status;

    //
    // IoCallDriver has been called on this Irp;
    // Set the length based on the TransferBufferLength
    // value in the URB
    //
    pIrp->IoStatus.Information = pUrb->UrbBulkOrInterruptTransfer.TransferBufferLength;

    BytesRead = pIrp->IoStatus.Information;

    DEBUGMSG(DBG_FUNC, (" ReceiveCompletePacketRead Bytes Read = 0x%x, dec %d\n", BytesRead,BytesRead ));

    switch( status )
    {
        case STATUS_SUCCESS:
            DEBUGMSG(DBG_FUNC, (" ReceiveCompletePacketRead STATUS_SUCCESS\n"));

            if( BytesRead > 0 )
            {
				pFifoBuf->DataLen = (UINT)pIrp->IoStatus.Information;
            }
            break; // STATUS_SUCCESS

        case STATUS_TIMEOUT:
			InterlockedIncrement( (PLONG)&pThisDev->NumDataErrors );
            DEBUGMSG(DBG_FUNC, (" ReceiveCompletePacketRead STATUS_TIMEOUT\n"));
            break;

        case STATUS_PENDING:
            DEBUGMSG(DBG_FUNC, (" ReceiveCompletePacketRead STATUS_PENDING\n"));
            break;

        case STATUS_DEVICE_DATA_ERROR:
			// can get during shutdown
			InterlockedIncrement( (PLONG)&pThisDev->NumDataErrors );
            DEBUGMSG(DBG_FUNC, (" ReceiveCompletePacketRead STATUS_DEVICE_DATA_ERROR\n"));
            break;

        case STATUS_UNSUCCESSFUL:
			InterlockedIncrement( (PLONG)&pThisDev->NumDataErrors );
            DEBUGMSG(DBG_ERR, (" ReceiveCompletePacketRead STATUS_UNSUCCESSFUL\n"));
            break;

        case STATUS_INSUFFICIENT_RESOURCES:
			InterlockedIncrement( (PLONG)&pThisDev->NumDataErrors );
            DEBUGMSG(DBG_ERR, (" ReceiveCompletePacketRead STATUS_INSUFFICIENT_RESOURCES\n"));
            break;
        case STATUS_INVALID_PARAMETER:
			InterlockedIncrement( (PLONG)&pThisDev->NumDataErrors );
            DEBUGMSG(DBG_ERR, (" ReceiveCompletePacketRead STATUS_INVALID_PARAMETER\n"));
            break;

        case STATUS_CANCELLED:
            DEBUGMSG(DBG_FUNC, (" ReceiveCompletePacketRead STATUS_CANCELLED\n"));
            break;

        case STATUS_DEVICE_NOT_CONNECTED:
			// can get during shutdown
			InterlockedIncrement( (PLONG)&pThisDev->NumDataErrors );
            DEBUGMSG(DBG_ERR, (" ReceiveCompletePacketRead STATUS_DEVICE_NOT_CONNECTED\n"));
            break;

        case STATUS_DEVICE_POWER_FAILURE:
			// can get during shutdown
			InterlockedIncrement( (PLONG)&pThisDev->NumDataErrors );
            DEBUGMSG(DBG_ERR, (" ReceiveCompletePacketRead STATUS_DEVICE_POWER_FAILURE\n"));
            break;

        default:
			InterlockedIncrement( (PLONG)&pThisDev->NumDataErrors );
            DEBUGMSG(DBG_ERR, (" ReceiveCompletePacketRead UNKNOWN WEIRD STATUS = 0x%x, dec %d\n",status,status ));
            break;
    }

	//
	// change the status
	//
	if( STATUS_SUCCESS != status ) 
	{
		InterlockedExchange( (PLONG)&pFifoBuf->BufferState, RCV_STATE_FREE );
	}
	else
	{
		InterlockedExchange( (PLONG)&pFifoBuf->BufferState, RCV_STATE_FULL );
	}

    //
    // Free the IRP  and its mdl because they were  allocated by us
    //
	IoFreeIrp( pIrp );
    pFifoBuf->pIrp = NULL;
	InterlockedIncrement( (PLONG)&pThisDev->NumReads );

	//
	// we will track count of pending irps
	//
	IrUsb_DecIoCount( pThisDev ); 

	if( ( STATUS_SUCCESS != status )  && ( STATUS_CANCELLED != status ) && 
		( STATUS_DEVICE_NOT_CONNECTED != status ) )
	{
		PURB urb = pFifoBuf->pUrb;

		DEBUGMSG(DBG_ERR, (" USBD status = 0x%x\n", urb->UrbHeader.Status));
		DEBUGMSG(DBG_ERR, (" NT status = 0x%x\n",  status));

		if( !pThisDev->fPendingReadClearStall && !pThisDev->fPendingClearTotalStall && 
			!pThisDev->fPendingHalt && !pThisDev->fPendingReset && pThisDev->fProcessing )
		{
			DEBUGMSG(DBG_ERR, 
				(" ReceiveCompletePacketRead error, will schedule a clear stall via URB_FUNCTION_RESET_PIPE (IN)\n"));
			InterlockedExchange( &pThisDev->fPendingReadClearStall, TRUE );
			ScheduleWorkItem( pThisDev, ResetPipeCallback, pThisDev->BulkInPipeHandle, 0 );
		}
	}

	// Free the URB.
	MyUrbFree(pFifoBuf->pUrb, pFifoBuf->UrbLen);
	pFifoBuf->pUrb = NULL;

	//
	// This will only work as long as we serialize the access to the hardware
	//
	pThisDev->StatusSendReceive = status;

	//
	// Signal completion
	//
	KeSetEvent( &pThisDev->EventSyncUrb, 0, FALSE );  

    //
    // We return STATUS_MORE_PROCESSING_REQUIRED so that the completion
    // routine (IoCompleteRequest) will stop working on the irp.
    //
    DEBUGMSG(DBG_FUNC, ("-ReceiveCompletePacketRead\n"));
    return STATUS_MORE_PROCESSING_REQUIRED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\net\irda\sigmatel\sys\openclos.c ===
/**************************************************************************************************************************
 *  OPENCLOS.C SigmaTel STIR4200 init/shutdown module
 **************************************************************************************************************************
 *  (C) Unpublished Copyright of Sigmatel, Inc. All Rights Reserved.
 *
 *
 *		Created: 04/06/2000 
 *			Version 0.9
 *		Edited: 04/24/2000 
 *			Version 0.91
 *		Edited: 04/27/2000 
 *			Version 0.92
 *		Edited: 05/12/2000 
 *			Version 0.94
 *		Edited: 05/19/2000 
 *			Version 0.95
 *	
 *
 **************************************************************************************************************************/

#define DOBREAKS    // enable debug breaks

#include <ndis.h>
#include <ntddndis.h>  // defines OID's

#include <usbdi.h>
#include <usbdlib.h>

#include "debug.h"
#include "ircommon.h"
#include "irndis.h"

/*****************************************************************************
*
*  Function:	InitializeDevice
*
*  Synopsis:	initialize resources for a single IR device object
*
*  Arguments:	pThisDev - IR device object to initialize
*
*  Returns:		NDIS_STATUS_SUCCESS      - if device is successfully opened
*				NDIS_STATUS_RESOURCES    - could not claim sufficient
*                                         resources
*
*
*  Notes:
*              we do a lot of stuff in this open device function
*              - allocate packet pool
*              - allocate buffer pool
*              - allocate packets/buffers/memory and chain together
*                (only one buffer per packet)
*              - initialize send queue
*
*  This function should be called with device lock held.
*
*  We don't initialize the following ir device object entries, since
*  these values will outlast an reset.
*       pUsbDevObj
*       hNdisAdapter
*       dongleCaps
*       fGotFilterIndication
*
*****************************************************************************/
NDIS_STATUS
InitializeDevice(
		IN OUT PIR_DEVICE pThisDev
	)
{
    int				i;
    NDIS_STATUS		status = NDIS_STATUS_SUCCESS;

    DEBUGMSG(DBG_FUNC|DBG_PNP, ("+InitializeDevice\n"));

    IRUSB_ASSERT( pThisDev != NULL );

    //
    // Current speed is the default (9600).
    //
    pThisDev->linkSpeedInfo = &supportedBaudRateTable[BAUDRATE_9600];
    pThisDev->currentSpeed  = DEFAULT_BAUD_RATE;

    //
    // Init statistical info. 
    // We need to do this cause reset won't free and realloc pThisDev!
    //
    pThisDev->packetsReceived         = 0;
    pThisDev->packetsReceivedDropped  = 0;
    pThisDev->packetsReceivedOverflow = 0;
	pThisDev->packetsReceivedChecksum = 0;
	pThisDev->packetsReceivedRunt	  = 0;
	pThisDev->packetsReceivedNoBuffer = 0;
    
	pThisDev->packetsSent             = 0;
    pThisDev->packetsSentDropped      = 0;
	pThisDev->packetsSentRejected	  = 0;
	pThisDev->packetsSentInvalid	  = 0;

	pThisDev->NumDataErrors			  = 0;
	pThisDev->NumReadWriteErrors	  = 0;

	pThisDev->NumReads				  = 0;
	pThisDev->NumWrites				  = 0;
	pThisDev->NumReadWrites			  = 0;

#if DBG
	pThisDev->TotalBytesReceived      = 0;
	pThisDev->TotalBytesSent          = 0;
	pThisDev->NumYesQueryMediaBusyOids		= 0;
	pThisDev->NumNoQueryMediaBusyOids		= 0;
	pThisDev->NumSetMediaBusyOids			= 0;
	pThisDev->NumMediaBusyIndications		= 0;
	pThisDev->packetsHeldByProtocol			= 0;
	pThisDev->MaxPacketsHeldByProtocol		= 0;
	pThisDev->NumPacketsSentRequiringTurnaroundTime		= 0;
	pThisDev->NumPacketsSentNotRequiringTurnaroundTime	= 0;
#endif

    //
	// Variables about the state of the device
	//
	pThisDev->fDeviceStarted          = FALSE;
    pThisDev->fGotFilterIndication    = FALSE;
    pThisDev->fPendingHalt            = FALSE;
    pThisDev->fPendingReadClearStall  = FALSE;
    pThisDev->fPendingWriteClearStall = FALSE;
	pThisDev->fPendingReset			  = FALSE;

	pThisDev->fPendingClearTotalStall = FALSE;

    pThisDev->fKillPollingThread      = FALSE;

    pThisDev->fKillPassiveLevelThread  = FALSE;

    pThisDev->LastQueryTime.QuadPart   = 0;
    pThisDev->LastSetTime.QuadPart     = 0;
	pThisDev->PendingIrpCount          = 0;

	//
	// OID Set/Query pending
	// 
	pThisDev->fQuerypending            = FALSE;
	pThisDev->fSetpending              = FALSE;

	//
	// Diags are off
	//
#if defined(DIAGS)
	pThisDev->DiagsActive			   = FALSE;
	pThisDev->DiagsPendingActivation   = FALSE;
#endif

    //
	// Some more state variables
	// 
	InterlockedExchange( &pThisDev->fMediaBusy, FALSE ); 
    InterlockedExchange( &pThisDev->fIndicatedMediaBusy, FALSE ); 

	pThisDev->pCurrentRecBuf			= NULL;

    pThisDev->fProcessing				= FALSE;
    pThisDev->fCurrentlyReceiving		= FALSE;

    pThisDev->fReadHoldingReg			= FALSE;

	pThisDev->BaudRateMask				= 0xffff;  // as per Class Descriptor; may be reset in registry

	//
	// Initialize the queues.
	//
	if( TRUE != IrUsb_InitSendStructures( pThisDev ) )
	{
		DEBUGMSG(DBG_ERR, (" Failed to init WDM objects\n"));
		goto done;
	}

    //
    // Allocate the NDIS packet and NDIS buffer pools
    // for this device's RECEIVE buffer queue.
    // Our receive packets must only contain one buffer a piece,
    // so #buffers == #packets.
    //

	//
	// MS security bug #540550
	//
    pThisDev->hPacketPool = NULL;

    NdisAllocatePacketPool(
			&status,                    // return status
			&pThisDev->hPacketPool,     // handle to the packet pool
			NUM_RCV_BUFS,               // number of packet descriptors
			16                          // number of bytes reserved for ProtocolReserved field
		);

    if( status != NDIS_STATUS_SUCCESS )
    {
        DEBUGMSG(DBG_ERR, (" NdisAllocatePacketPool failed. Returned 0x%.8x\n", status));
        goto done;
    }

    NdisAllocateBufferPool(
			&status,               // return status
			&pThisDev->hBufferPool,// handle to the buffer pool
			NUM_RCV_BUFS           // number of buffer descriptors
		);

    if( status != NDIS_STATUS_SUCCESS )
    {
        DEBUGMSG(DBG_ERR, (" NdisAllocateBufferPool failed. Returned 0x%.8x\n", status));
        pThisDev->BufferPoolAllocated = FALSE;
		goto done;
    }
        
	pThisDev->BufferPoolAllocated = TRUE;

    //
	// Prepare the work items
	// 
	for( i = 0; i < NUM_WORK_ITEMS; i++ )
    {
		PIR_WORK_ITEM pWorkItem;

		pWorkItem = &(pThisDev->WorkItems[i]);

		pWorkItem->pIrDevice    = pThisDev;
		pWorkItem->pInfoBuf     = NULL;
		pWorkItem->InfoBufLen   = 0;
		pWorkItem->fInUse       = FALSE;
		pWorkItem->Callback     = NULL;
	}

    //
    //  Initialize each of the RECEIVE objects for this device.
    //
    for( i = 0; i < NUM_RCV_BUFS; i++ )
    {
        PNDIS_BUFFER pBuffer = NULL;
        PRCV_BUFFER pReceivBuffer = &pThisDev->rcvBufs[i];

        //
        // Allocate a data buffer
        //
        pReceivBuffer->pDataBuf = MyMemAlloc( MAX_RCV_DATA_SIZE ); 

        if( pReceivBuffer->pDataBuf == NULL )
        {
            status = NDIS_STATUS_RESOURCES;
            goto done;
        }

        NdisZeroMemory( 
				pReceivBuffer->pDataBuf,
				MAX_RCV_DATA_SIZE
			);

		pReceivBuffer->pThisDev = pThisDev;
        pReceivBuffer->DataLen = 0;
        pReceivBuffer->BufferState = RCV_STATE_FREE;

#if defined(WORKAROUND_MISSING_C1)
		pReceivBuffer->MissingC1Detected = FALSE;
		pReceivBuffer->MissingC1Possible = FALSE;
#endif

        //
        //  Allocate the NDIS_PACKET.
        //
        NdisAllocatePacket(
				&status,									// return status
				&((PNDIS_PACKET)pReceivBuffer->pPacket),	// return pointer to allocated descriptor
				pThisDev->hPacketPool						// handle to packet pool
			);

        if( status != NDIS_STATUS_SUCCESS )
        {
            DEBUGMSG(DBG_ERR, (" NdisAllocatePacket failed. Returned 0x%.8x\n", status));
            goto done;
        }
    }

	//
	// These are the receive objects for the USB
	//
    pThisDev->PreReadBuffer.pDataBuf = MyMemAlloc( STIR4200_FIFO_SIZE ); 

    if( pThisDev->PreReadBuffer.pDataBuf == NULL )
    {
        status = NDIS_STATUS_RESOURCES;
        goto done;
    }

    NdisZeroMemory( 
			pThisDev->PreReadBuffer.pDataBuf,
			STIR4200_FIFO_SIZE
		);

	pThisDev->PreReadBuffer.pThisDev = pThisDev;
    pThisDev->PreReadBuffer.DataLen = 0;
    pThisDev->PreReadBuffer.BufferState = RCV_STATE_FREE;

	//
	// Synchronization events
	//
	KeInitializeEvent(
        &pThisDev->EventSyncUrb,
        NotificationEvent,    // non-auto-clearing event
        FALSE                 // event initially non-signalled
    );

    KeInitializeEvent(
            &pThisDev->EventAsyncUrb,
            NotificationEvent,    // non-auto-clearing event
            FALSE                 // event initially non-signalled
        );

done:
    //
    // If we didn't complete the init successfully, then we should clean
    // up what we did allocate.
    //
    if( status != NDIS_STATUS_SUCCESS )
    {
        DEBUGMSG(DBG_ERR, (" InitializeDevice() FAILED\n"));
        DeinitializeDevice(pThisDev);
    }
    else
    {
        DEBUGMSG(DBG_OUT, (" InitializeDevice() SUCCEEDED\n"));
    }

    DEBUGMSG(DBG_FUNC|DBG_PNP, ("-InitializeDevice()\n"));
    return status;
}


/*****************************************************************************
*
*  Function:   DeinitializeDevice
*
*  Synopsis:   deallocate the resources of the IR device object
*
*  Arguments:  pThisDev - the IR device object to close
*
*  Returns:    none
*
*
*  Notes:
*
*  Called for shutdown and reset.
*  Don't clear hNdisAdapter, since we might just be resetting.
*  This function should be called with device lock held.
*
*****************************************************************************/
VOID
DeinitializeDevice(
		IN OUT PIR_DEVICE pThisDev
	)
{
    UINT			i;

    DEBUGMSG( DBG_FUNC|DBG_PNP, ("+DeinitializeDevice\n"));

    pThisDev->linkSpeedInfo = NULL;

    //
    // Free all resources for the RECEIVE buffer queue.
    //
    for( i = 0; i < NUM_RCV_BUFS; i++ )
    {
        PNDIS_BUFFER pBuffer = NULL;
        PRCV_BUFFER  pRcvBuf = &pThisDev->rcvBufs[i];

        if( pRcvBuf->pPacket != NULL )
        {
            NdisFreePacket( (PNDIS_PACKET)pRcvBuf->pPacket );
            pRcvBuf->pPacket = NULL;
        }

        if( pRcvBuf->pDataBuf != NULL )
        {
            MyMemFree( pRcvBuf->pDataBuf, MAX_RCV_DATA_SIZE ); 
            pRcvBuf->pDataBuf = NULL;
        }

        pRcvBuf->DataLen = 0;
    }

	//
	// Deallocate the USB receive buffers
	//
    if( pThisDev->PreReadBuffer.pDataBuf != NULL )
        MyMemFree( pThisDev->PreReadBuffer.pDataBuf, STIR4200_FIFO_SIZE ); 

    //
    // Free the packet and buffer pool handles for this device.
    //
    if( pThisDev->hPacketPool )
    {
        NdisFreePacketPool( pThisDev->hPacketPool );
        pThisDev->hPacketPool = NULL;
    }

    if( pThisDev->BufferPoolAllocated )
    {
        NdisFreeBufferPool( pThisDev->hBufferPool );
        pThisDev->BufferPoolAllocated = FALSE;
    }

    if( pThisDev->fDeviceStarted )
    {
		NTSTATUS ntstatus;

		ntstatus = IrUsb_StopDevice( pThisDev ); 
        DEBUGMSG(DBG_FUNC, (" DeinitializeDevice IrUsb_StopDevice() status = 0x%x\n",ntstatus));
    }

    InterlockedExchange( &pThisDev->fMediaBusy, FALSE ); 
    InterlockedExchange( &pThisDev->fIndicatedMediaBusy, FALSE ); 

	IrUsb_FreeSendStructures( pThisDev );

	DEBUGMSG(DBG_FUNC|DBG_PNP, ("-DeinitializeDevice\n"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\net\irda\sigmatel\sys\irusb.h ===
/**************************************************************************************************************************
 *  IRUSB.H SigmaTel STIR4200 USB specific definitions
 **************************************************************************************************************************
 *  (C) Unpublished Copyright of Sigmatel, Inc. All Rights Reserved.
 *
 *
 *		Created: 04/06/2000 
 *			Version 0.9
 *		Edited: 04/27/2000 
 *			Version 0.92
 *		Edited: 08/09/2000 
 *			Version 1.02
 *	
 *
 **************************************************************************************************************************/


#ifndef USB_H
#define USB_H

//
// Send and Read/Write register structure 
// Most of the buffers have been moved to IRCOMMON.H and made global to save memory
// This will only work if the main thread is serialized 
//
typedef struct _IRUSB_CONTEXT {
    PIR_DEVICE		pThisDev;
	PVOID			pPacket;
    PIRP			pIrp;
	PURB			pUrb;				// urb allocated by irp send routine, deallocated
	UINT			UrbLen;				//   by irp completion handler
	LIST_ENTRY		ListEntry;			// This will be used to do the queueing
	LARGE_INTEGER	TimeReceived;		// For enforcing turnaround time
	CONTEXT_TYPE	ContextType;		// To gear up/down
} IRUSB_CONTEXT, *PIRUSB_CONTEXT, **PPIRUSB_CONTEXT;


typedef struct _IRUSB_USB_INFO
{
    // USB configuration handle and ptr for the configuration the
    // device is currently in
    USBD_CONFIGURATION_HANDLE UsbConfigurationHandle;
	PUSB_CONFIGURATION_DESCRIPTOR UsbConfigurationDescriptor;

	PIRP IrpSubmitUrb;
	PIRP IrpSubmitIoCtl;

    // ptr to the USB device descriptor
    // for this device
    PUSB_DEVICE_DESCRIPTOR UsbDeviceDescriptor;

    // we support one interface
    // this is a copy of the info structure
    // returned from select_configuration or
    // select_interface
    PUSBD_INTERFACE_INFORMATION UsbInterface;

	// urb for control descriptor request
	struct _URB_CONTROL_DESCRIPTOR_REQUEST DescriptorUrb;

	// urb to use for control/status requests to USBD
	struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST ClassUrb;
} IRUSB_USB_INFO, *PIRUSB_USB_INFO;


//
// Prototypes
//
NTSTATUS
UsbIoCompleteControl(
		IN PDEVICE_OBJECT pUsbDevObj,
		IN PIRP           pIrp,
		IN PVOID          Context
    );

NTSTATUS 
MyIoCallDriver(
		IN PIR_DEVICE pThisDev,
		IN PDEVICE_OBJECT pDeviceObject,
		IN OUT PIRP pIrp
	);

NTSTATUS
IrUsb_CallUSBD(
		IN PIR_DEVICE pThisDev,
		IN PURB pUrb
	);

NTSTATUS
IrUsb_ResetUSBD(
		IN PIR_DEVICE pThisDev,
		BOOLEAN ForceUnload
    );

NTSTATUS
IrUsb_SelectInterface(
		IN OUT PIR_DEVICE pThisDev,
		IN PUSB_CONFIGURATION_DESCRIPTOR pConfigurationDescriptor
    );

NTSTATUS 
MyKeWaitForSingleObject( 
		IN PIR_DEVICE pThisDev,
		IN PVOID pEventWaitingFor,
		LONGLONG timeout100ns
	);


#endif // USB_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\net\irda\sigmatel\sys\request.c ===
/**************************************************************************************************************************
 *  REQUEST.C SigmaTel STIR4200 OID query/set module
 **************************************************************************************************************************
 *  (C) Unpublished Copyright of Sigmatel, Inc. All Rights Reserved.
 *
 *
 *		Created: 04/06/2000 
 *			Version 0.9
 *		Edited: 04/24/2000 
 *			Version 0.91
 *		Edited: 04/27/2000 
 *			Version 0.92
 *		Edited: 05/03/2000 
 *			Version 0.93
 *		Edited: 05/12/2000 
 *			Version 0.94
 *		Edited: 05/19/2000 
 *			Version 0.95
 *		Edited: 06/13/2000 
 *			Version 0.96
 *		Edited: 08/22/2000 
 *			Version 1.02
 *		Edited: 09/25/2000 
 *			Version 1.10
 *		Edited: 12/29/2000 
 *			Version 1.13
 *	
 *
 **************************************************************************************************************************/

#define DOBREAKS    // enable debug breaks

#include <ndis.h>
#include <ntddndis.h>  // defines OID's

#include <usbdi.h>
#include <usbdlib.h>

#include "debug.h"
#include "ircommon.h"
#include "irndis.h"
#include "diags.h"

//
//  These are the OIDs we support 
//
UINT supportedOIDs[] =
{
    //
    // General required OIDs.
    //
    OID_GEN_SUPPORTED_LIST,
    OID_GEN_HARDWARE_STATUS,
    OID_GEN_MEDIA_SUPPORTED,
    OID_GEN_MEDIA_IN_USE,
    OID_GEN_MAXIMUM_LOOKAHEAD,
    OID_GEN_MAXIMUM_FRAME_SIZE,
    OID_GEN_LINK_SPEED,
    OID_GEN_TRANSMIT_BUFFER_SPACE,
    OID_GEN_RECEIVE_BUFFER_SPACE,
    OID_GEN_TRANSMIT_BLOCK_SIZE,
    OID_GEN_RECEIVE_BLOCK_SIZE,
    OID_GEN_VENDOR_ID,
    OID_GEN_VENDOR_DESCRIPTION,
    OID_GEN_CURRENT_PACKET_FILTER,
    OID_GEN_CURRENT_LOOKAHEAD,
    OID_GEN_DRIVER_VERSION,
    OID_GEN_MAXIMUM_TOTAL_SIZE,
    OID_GEN_PROTOCOL_OPTIONS,
    OID_GEN_MAC_OPTIONS,
    OID_GEN_MEDIA_CONNECT_STATUS,
    OID_GEN_MAXIMUM_SEND_PACKETS,
    OID_GEN_VENDOR_DRIVER_VERSION,

    //
    // Required statistical OIDs.
    //
    OID_GEN_XMIT_OK,
    OID_GEN_RCV_OK,
    OID_GEN_XMIT_ERROR,
    OID_GEN_RCV_ERROR,
    OID_GEN_RCV_NO_BUFFER,

    //
    // Infrared-specific OIDs.
    //
    OID_IRDA_RECEIVING,
    OID_IRDA_TURNAROUND_TIME,
    OID_IRDA_SUPPORTED_SPEEDS,
    OID_IRDA_LINK_SPEED,
    OID_IRDA_MEDIA_BUSY,
    OID_IRDA_EXTRA_RCV_BOFS,
	OID_IRDA_MAX_RECEIVE_WINDOW_SIZE,		
	OID_IRDA_MAX_SEND_WINDOW_SIZE,		

    OID_PNP_CAPABILITIES,

    OID_PNP_SET_POWER,  
    OID_PNP_QUERY_POWER
    //OID_PNP_ENABLE_WAKE_UP
    //OID_PNP_ADD_WAKE_UP_PATTERN		
    //OID_PNP_REMOVE_WAKE_UP_PATTERN	
    //OID_PNP_WAKE_UP_PATTERN_LIST	
    //OID_PNP_WAKE_UP_OK		
    //OID_PNP_WAKE_UP_ERROR	
}; 


/*****************************************************************************
*
*  Function:   StIrUsbQueryInformation
*
*  Synopsis:   Queries the capabilities and status of the miniport driver.
*
*  Arguments:  MiniportAdapterContext  - miniport context area (PIR_DEVICE)
*              Oid                     - system defined OID_Xxx
*              InformationBuffer       - where to return Oid specific info
*              InformationBufferLength - specifies size of InformationBuffer
*              BytesWritten            - bytes written to InformationBuffer
*              BytesNeeded             - addition bytes required if
*                                        InformationBufferLength is less than
*                                        what the Oid requires to write
*
*  Returns:    NDIS_STATUS_SUCCESS       - success
*              NDIS_STATUS_PENDING       - will complete asynchronously and
*                                          call NdisMQueryInformationComplete
*              NDIS_STATUS_INVALID_OID   - don't recognize the Oid
*              NDIS_STATUS_INVALID_LENGTH- InformationBufferLength does not
*                                          match length for the Oid
*              NDIS_STATUS_NOT_ACCEPTED  - failure
*              NDIS_STATUS_NOT_SUPPORTED - do not support an optional Oid
*              NDIS_STATUS_RESOURCES     - failed allocation of resources
*
*  Notes:
*       See list of Supported OIDs at the top of this module in the supportedOIDs[] array
*
*
*****************************************************************************/
NDIS_STATUS
StIrUsbQueryInformation(
		IN  NDIS_HANDLE MiniportAdapterContext,
		IN  NDIS_OID    Oid,
		IN  PVOID       InformationBuffer,
		IN  ULONG       InformationBufferLength,
		OUT PULONG      BytesWritten,
		OUT PULONG      BytesNeeded
	)
{
    PIR_DEVICE      pThisDev;
    NDIS_STATUS     status;
    UINT            speeds;
    UINT            i;
    UINT            infoSizeNeeded;
    PUINT           pInfoPtr;
	PNDIS_PNP_CAPABILITIES pNdisPnpCapabilities;

    static char vendorDesc[] = "SigmaTel Usb-IrDA Dongle";

    DEBUGMSG(DBG_FUNC, ("+StIrUsbQueryInformation\n"));

    pThisDev = CONTEXT_TO_DEV( MiniportAdapterContext );

	IRUSB_ASSERT( NULL != pThisDev ); 
	IRUSB_ASSERT( NULL != BytesWritten );
	IRUSB_ASSERT( NULL != BytesNeeded );

    status = NDIS_STATUS_SUCCESS;

    KeQuerySystemTime( &pThisDev->LastQueryTime ); //used by check for hang handler
	pThisDev->fQuerypending = TRUE;

	if( (NULL == InformationBuffer) && InformationBufferLength )
	{ 
		//
		// Should be impossible but it happened on an MP system!
		//
		DEBUGMSG(DBG_ERR, (" StIrUsbQueryInformation() NULL info buffer passed!, InformationBufferLength = dec %d\n",InformationBufferLength));
		status = NDIS_STATUS_NOT_ACCEPTED;
		*BytesNeeded =0;
		*BytesWritten = 0;
		goto done;
	}

	//
    // Figure out buffer size needed.
    // Most OIDs just return a single UINT, but there are exceptions.
    //
    switch( Oid )
    {
        case OID_GEN_SUPPORTED_LIST:
            infoSizeNeeded = sizeof(supportedOIDs);
            break;

        case OID_PNP_CAPABILITIES:
            infoSizeNeeded = sizeof(NDIS_PNP_CAPABILITIES);
            break;

        case OID_GEN_DRIVER_VERSION:
            infoSizeNeeded = sizeof(USHORT);
            break;

        case OID_GEN_VENDOR_DESCRIPTION:
            infoSizeNeeded = sizeof(vendorDesc);
            break;

        case OID_IRDA_SUPPORTED_SPEEDS:
            speeds = pThisDev->ClassDesc.wBaudRate;
            for (infoSizeNeeded = 0; speeds; infoSizeNeeded += sizeof(UINT))
            {
                //
                // This instruction clears the lowest set bit in speeds.
                // Trust me.
                //
                speeds &= (speeds - 1);
            }
            break;

        default:
            infoSizeNeeded = sizeof(UINT);
            break;
    }

    //
    // If the protocol provided a large enough buffer, we can go ahead
    // and complete the query.
    //
    if( InformationBufferLength >= infoSizeNeeded )
    {
        //
        // Set default results.
        //
        *BytesWritten = infoSizeNeeded;
        *BytesNeeded = 0;

        switch( Oid )
        {
            //
            // Generic OIDs.
            //

            case OID_GEN_SUPPORTED_LIST:
                DEBUGMSG(DBG_ERR, (" StIrUsbQueryInformation(OID_GEN_SUPPORTED_LIST)\n"));
/*
                Specifies an array of OIDs for objects that the underlying
                driver or its device supports. Objects include general, media-specific,
                and implementation-specific objects.

                The underlying driver should order the OID list it returns 
                in increasing numeric order. NDIS forwards a subset of the returned 
                list to protocols that make this query. That is, NDIS filters
                any supported statistics OIDs out of the list since protocols
                never make statistics queries subsequentlly. 
*/
                NdisMoveMemory(
						InformationBuffer,
						(PVOID)supportedOIDs,
						sizeof(supportedOIDs)
					);
                break;

            case OID_GEN_HARDWARE_STATUS:
                DEBUGMSG(DBG_ERR, (" StIrUsbQueryInformation(OID_GEN_HARDWARE_STATUS)\n"));
                //
                // If we can be called with a context, then we are
                // initialized and ready.
                //
                *(UINT *)InformationBuffer = NdisHardwareStatusReady;
                break;

            case OID_GEN_MEDIA_SUPPORTED:
                DEBUGMSG(DBG_ERR, (" StIrUsbQueryInformation(OID_GEN_MEDIA_SUPPORTED)\n"));
                *(UINT *)InformationBuffer = NdisMediumIrda;
                break;

            case OID_GEN_MEDIA_IN_USE:
                DEBUGMSG(DBG_ERR, (" StIrUsbQueryInformation(OID_GEN_MEDIA_IN_USE)\n"));
                *(UINT *)InformationBuffer = NdisMediumIrda;
                break;

            case OID_GEN_TRANSMIT_BUFFER_SPACE: 
                DEBUGMSG(DBG_ERR, (" StIrUsbQueryInformation(OID_GEN_TRANSMIT_BUFFER_SPACE)\n"));
/*
                The amount of memory, in bytes, on the device available 
                for buffering transmit data.  
*/
                *(UINT *)InformationBuffer = MAX_TOTAL_SIZE_WITH_ALL_HEADERS;
                break;

            case OID_GEN_RECEIVE_BUFFER_SPACE: 
                DEBUGMSG(DBG_ERR, (" StIrUsbQueryInformation(OID_GEN_RECEIVE_BUFFER_SPACE)\n"));
/*
                The amount of memory on the device available 
                for buffering receive data.
*/
                *(UINT *)InformationBuffer = MAX_TOTAL_SIZE_WITH_ALL_HEADERS;
                break;

            case OID_GEN_TRANSMIT_BLOCK_SIZE: 
                DEBUGMSG(DBG_ERR, (" StIrUsbQueryInformation(OID_GEN_TRANSMIT_BLOCK_SIZE)\n"));
/*
                The minimum number of bytes that a single net packet 
                occupies in the transmit buffer space of the device.
                For example, on some devices the transmit space is 
                divided into 256-byte pieces so such a device's 
                transmit block size would be 256. To calculate 
                the total transmit buffer space on such a device, 
                its driver multiplies the number of transmit 
                buffers on the device by its transmit block size.

                For other devices, the transmit block size is
                identical to its maximum packet size. 
*/
                *(UINT *)InformationBuffer = pThisDev->dongleCaps.dataSize + USB_IRDA_TOTAL_NON_DATA_SIZE;
                break;

            case OID_GEN_RECEIVE_BLOCK_SIZE: 
                DEBUGMSG(DBG_ERR, (" StIrUsbQueryInformation(OID_GEN_RECEIVE_BLOCK_SIZE)\n"));
/*
                The amount of storage, in bytes, that a single packet
                occupies in the receive buffer space of the device
*/
                *(UINT *)InformationBuffer = pThisDev->dongleCaps.dataSize + USB_IRDA_TOTAL_NON_DATA_SIZE;
                break;

            case OID_GEN_MAXIMUM_LOOKAHEAD: 
                DEBUGMSG(DBG_ERR, (" StIrUsbQueryInformation(OID_GEN_MAXIMUM_LOOKAHEAD)\n"));
/*
                The maximum number of bytes the device can always provide as lookahead data.
                If the underlying driver supports multipacket receive indications,
                bound protocols are given full net packets on every indication. 
                Consequently, this value is identical to that 
                returned for OID_GEN_RECEIVE_BLOCK_SIZE. 
*/
                *(UINT *)InformationBuffer =  pThisDev->dongleCaps.dataSize + USB_IRDA_TOTAL_NON_DATA_SIZE;
                break;

            case OID_GEN_CURRENT_LOOKAHEAD: 
                DEBUGMSG(DBG_ERR, (" StIrUsbQueryInformation(OID_GEN_CURRENT_LOOKAHEAD)\n"));
/*
                The number of bytes of received packet data, 
                excluding the header, that will be indicated 
                to the protocol driver. For a query, 
                NDIS returns the largest lookahead size from 
                among all the bindings. A protocol driver can 
                set a suggested value for the number of bytes 
                to be used in its binding; however, 
                the underlying device driver is never required 
                to limit its indications to the value set. 

                If the underlying driver supports multipacket
                receive indications, bound protocols are given
                full net packets on every indication. Consequently,
                this value is identical to that returned for OID_GEN_RECEIVE_BLOCK_SIZE. 
*/
                *(UINT *)InformationBuffer = pThisDev->dongleCaps.dataSize + USB_IRDA_TOTAL_NON_DATA_SIZE;
                break;

            case OID_GEN_MAXIMUM_FRAME_SIZE:
                DEBUGMSG(DBG_ERR, (" StIrUsbQueryInformation(OID_GEN_MAXIMUM_FRAME_SIZE)\n"));
/*
                The maximum network packet size in bytes 
                the device supports, not including a header. 
                For a binding emulating another medium type, 
                the device driver must define the maximum frame 
                size in such a way that it will not transform 
                a protocol-supplied net packet of this size 
                to a net packet too large for the true network medium.
*/
                *(UINT *)InformationBuffer = pThisDev->dongleCaps.dataSize;
                break;

            case OID_GEN_MAXIMUM_TOTAL_SIZE:
                DEBUGMSG(DBG_ERR, (" StIrUsbQueryInformation(OID_GEN_MAXIMUM_TOTAL_SIZE)\n"));
/*
                The maximum total packet length, in bytes, 
                the device supports, including the header. 
                This value is medium-dependent. The returned 
                length specifies the largest packet a protocol 
                driver can pass to NdisSend or NdisSendPackets.

                For a binding emulating another media type,
                the device driver must define the maximum total 
                packet length in such a way that it will not 
                transform a protocol-supplied net packet of 
                this size to a net packet too large for the true network medium.
*/
                *(UINT *)InformationBuffer = pThisDev->dongleCaps.dataSize;  //+ USB_IRDA_TOTAL_NON_DATA_SIZE;
                break;

            case OID_IRDA_MAX_RECEIVE_WINDOW_SIZE:
                DEBUGMSG(DBG_ERR, (" StIrUsbQueryInformation(OID_IRDA_MAX_RECEIVE_WINDOW_SIZE) \n"));
                // Gotten from the device's USB Class-Specific Descriptor
                *(PUINT)InformationBuffer = pThisDev->dongleCaps.windowSize;
                break;

            case OID_IRDA_MAX_SEND_WINDOW_SIZE:
                DEBUGMSG(DBG_ERR, (" StIrUsbQueryInformation(OID_IRDA_MAX_SEND_WINDOW_SIZE) \n"));
                // Gotten from the device's USB Class-Specific Descriptor
                *(PUINT)InformationBuffer = pThisDev->dongleCaps.windowSize;
                break;

            case OID_GEN_VENDOR_ID:
                DEBUGMSG(DBG_ERR, (" StIrUsbQueryInformation(OID_GEN_VENDOR_ID)\n"));
                // we get this from our config descriptor
                *(UINT *)InformationBuffer = pThisDev->IdVendor;
                break;

            case OID_GEN_VENDOR_DESCRIPTION:
                DEBUGMSG(DBG_ERR, (" StIrUsbQueryInformation(OID_GEN_VENDOR_DESCRIPTION)\n"));
                NdisMoveMemory(
						InformationBuffer,
						(PVOID)vendorDesc,
						sizeof(vendorDesc)
					);
                break;

            case OID_GEN_LINK_SPEED:
                DEBUGMSG(DBG_ERR, (" StIrUsbQueryInformation(OID_GEN_LINK_SPEED)\n"));
                //
                // Return MAXIMUM POSSIBLE speed for this device in units
                // of 100 bits/sec.
                //
                *(UINT *)InformationBuffer = 0;
                speeds = pThisDev->ClassDesc.wBaudRate;
                *BytesWritten = 0;

                for ( i = 0; i<NUM_BAUDRATES; i++ )
                {
                    if ((supportedBaudRateTable[i].NdisCode & speeds) &&
                        ((supportedBaudRateTable[i].BitsPerSec)/100 > *(UINT *)InformationBuffer))
                    {
                        *(UINT *)InformationBuffer = supportedBaudRateTable[i].BitsPerSec/100;
                        *BytesWritten = sizeof(UINT);
                    }
                }

                DEBUGMSG(DBG_ERR, (" StIrUsbQueryInformation(OID_GEN_LINK_SPEED)  %d\n",*(UINT *)InformationBuffer));
                break;

            case OID_GEN_CURRENT_PACKET_FILTER:
                DEBUGMSG(DBG_ERR, (" StIrUsbQueryInformation(OID_GEN_CURRENT_PACKET_FILTER)\n"));
                *(UINT *)InformationBuffer = NDIS_PACKET_TYPE_PROMISCUOUS;
                break;

            case OID_GEN_DRIVER_VERSION:
                DEBUGMSG(DBG_ERR, (" StIrUsbQueryInformation(OID_GEN_DRIVER_VERSION)\n"));
                *(USHORT *)InformationBuffer = ((NDIS_MAJOR_VERSION << 8) | NDIS_MINOR_VERSION);
                break;

            case OID_GEN_PROTOCOL_OPTIONS:
                DEBUGMSG(DBG_ERR, (" StIrUsbQueryInformation(OID_GEN_PROTOCOL_OPTIONS)\n"));
                DEBUGMSG(DBG_ERR, ("This is a set-only OID\n"));
                *BytesWritten = 0;
                status = NDIS_STATUS_NOT_SUPPORTED;
                break;

            case OID_GEN_MAC_OPTIONS:
                DEBUGMSG(DBG_ERR, (" StIrUsbQueryInformation(OID_GEN_MAC_OPTIONS)\n"));
                *(UINT *)InformationBuffer = NDIS_MAC_OPTION_COPY_LOOKAHEAD_DATA | NDIS_MAC_OPTION_TRANSFERS_NOT_PEND;  
                break;

            case OID_GEN_MEDIA_CONNECT_STATUS:
                DEBUGMSG(DBG_ERR, (" StIrUsbQueryInformation(OID_GEN_MEDIA_CONNECT_STATUS)\n"));
                //
                // Since we are not physically connected to a LAN, we
                // cannot determine whether or not we are connected;
                // so always indicate that we are.
                //
                *(UINT *)InformationBuffer = NdisMediaStateConnected;
                break;

            case OID_GEN_MAXIMUM_SEND_PACKETS:
                DEBUGMSG(DBG_ERR, (" StIrUsbQueryInformation(OID_GEN_MAXIMUM_SEND_PACKETS)\n"));
								//
                //
				// The maximum number of send packets the
                // MiniportSendPackets function can accept. 
				//
                *(UINT *)InformationBuffer = NUM_SEND_CONTEXTS-3;
                break;

            case OID_GEN_VENDOR_DRIVER_VERSION:
                DEBUGMSG(DBG_ERR, (" StIrUsbQueryInformation(OID_GEN_VENDOR_DRIVER_VERSION)\n"));
                *(UINT *)InformationBuffer = ((DRIVER_MAJOR_VERSION << 16) | DRIVER_MINOR_VERSION);
                break;

            //
            // Required statistical OIDs.
            //
            case OID_GEN_XMIT_OK:
                DEBUGMSG(DBG_ERR, (" StIrUsbQueryInformation(OID_GEN_XMIT_OK)\n"));
                *(UINT *)InformationBuffer = (UINT)pThisDev->packetsSent;
                break;

            case OID_GEN_RCV_OK:
                DEBUGMSG(DBG_ERR, (" StIrUsbQueryInformation(OID_GEN_RCV_OK)\n"));
                *(UINT *)InformationBuffer = (UINT)pThisDev->packetsReceived;
                break;

            case OID_GEN_XMIT_ERROR:
                DEBUGMSG(DBG_ERR, (" StIrUsbQueryInformation(OID_GEN_XMIT_ERROR)\n"));
                *(UINT *)InformationBuffer = (UINT)(pThisDev->packetsSentDropped +
					pThisDev->packetsSentRejected + pThisDev->packetsSentInvalid );
                break;

            case OID_GEN_RCV_ERROR:
                DEBUGMSG(DBG_ERR, (" StIrUsbQueryInformation(OID_GEN_RCV_ERROR)\n"));
                *(UINT *)InformationBuffer = (UINT)(pThisDev->packetsReceivedDropped +
					pThisDev->packetsReceivedChecksum + pThisDev->packetsReceivedRunt +
					pThisDev->packetsReceivedOverflow);
                break;

            case OID_GEN_RCV_NO_BUFFER:
                DEBUGMSG(DBG_ERR, (" StIrUsbQueryInformation(OID_GEN_RCV_NO_BUFFER)\n"));
                *(UINT *)InformationBuffer = (UINT)pThisDev->packetsReceivedNoBuffer;
                break;

            //
            // Infrared OIDs.
            //
            case OID_IRDA_LINK_SPEED: 
                DEBUGMSG(DBG_ERR, (" StIrUsbQueryInformation(OID_IRDA_LINK_SPEED)\n"));
                *(UINT *)InformationBuffer = (UINT)pThisDev->currentSpeed;
				break;

            case OID_IRDA_RECEIVING:
#if !defined(ONLY_ERROR_MESSAGES)
                DEBUGMSG(DBG_ERR, (" StIrUsbQueryInformation(OID_IRDA_RECEIVING, %xh)\n",pThisDev->fCurrentlyReceiving));
#endif
                *(UINT *)InformationBuffer = (UINT)pThisDev->fCurrentlyReceiving; 
                break;

            case OID_IRDA_TURNAROUND_TIME:
                DEBUGMSG(DBG_ERR, (" StIrUsbQueryInformation(OID_IRDA_TURNAROUND_TIME)\n"));
                //
                // Time remote station must wait after receiving data from us
                // before we can receive
				//
                *(UINT *)InformationBuffer = pThisDev->dongleCaps.turnAroundTime_usec;
                break;

            case OID_IRDA_SUPPORTED_SPEEDS:
                DEBUGMSG(DBG_ERR, (" StIrUsbQueryInformation(OID_IRDA_SUPPORTED_SPEEDS)\n"));
                speeds = pThisDev->ClassDesc.wBaudRate;
                *BytesWritten = 0;

                for( i = 0, pInfoPtr = (PUINT)InformationBuffer;
                     (i < NUM_BAUDRATES) && speeds && (InformationBufferLength >= sizeof(UINT));
                     i++ )
                {
                    if( supportedBaudRateTable[i].NdisCode & speeds )
                    {
                        *pInfoPtr++ = supportedBaudRateTable[i].BitsPerSec;
                        InformationBufferLength -= sizeof(UINT);
                        *BytesWritten += sizeof(UINT);
                        speeds &= ~supportedBaudRateTable[i].NdisCode;
                        DEBUGMSG(DBG_FUNC, (" - supporting speed %d bps\n", supportedBaudRateTable[i].BitsPerSec));
                    }
                }

                if( speeds )
                {
                    //
                    // This shouldn't happen, since we checked the
                    // InformationBuffer size earlier.
                    //
                    DEBUGMSG(DBG_ERR, (" Something's wrong; previous check for buf size failed somehow\n"));

                    for( *BytesNeeded = 0; speeds; *BytesNeeded += sizeof(UINT) )
                    {
                        //
                        // This instruction clears the lowest set bit in speeds.
                        // Trust me.
                        //
                        speeds &= (speeds - 1);
                    }

                    status = NDIS_STATUS_INVALID_LENGTH;
                }
                else
                {
                    status = NDIS_STATUS_SUCCESS;
                }
                break;


            case OID_IRDA_MEDIA_BUSY:
#if !defined(ONLY_ERROR_MESSAGES)
                DEBUGMSG(DBG_ERR, (" StIrUsbQueryInformation(OID_IRDA_MEDIA_BUSY, %xh)\n", pThisDev->fMediaBusy));
#endif
/*  
    According to  W2000 ddk doc:
    The IrDA protocol driver sets this OID to zero to request the miniport to
    start monitoring for a media busy condition. The IrDA protocol 
    can then query this OID to determine whether the media is busy.
    If the media is not busy, the miniport returns a zero for this
    OID when queried. If the media is busy,that is, if the miniport
    has detected some traffic since the IrDA protocol driver last
    set OID_IRDA_MEDIA_BUSY to zero the miniport returns a non-zero
    value for this OID when queried. On detecting the media busy
    condition. the miniport must also call NdisMIndicateStatus to
    indicate NDIS_STATUS_MEDIA_BUSY. When the media is busy, 
    the IrDA protocol driver will not send packets to the miniport
    for transmission. After the miniport has detected a busy state, 
    it does not have to monitor for a media busy condition until
    the IrDA protocol driver again sets OID_IRDA_MEDIA_BUSY to zero.

    According to USB IrDA Bridge Device Definition Doc sec 5.4.1.2:

    The bmStatus field indicators shall be set by the Device as follows:
    Media_Busy
     Media_Busy shall indicate zero (0) if the Device:
    . has not received a Check Media Busy class-specific request
    . has detected no traffic on the infrared media since receiving a Check Media Busy
    . class-specific request
   . Has returned a header with Media_Busy set to one (1) since receiving a Check
      Media Busy class-specific request.
     
    Media_Busy shall indicate one (1) if the Device has detected traffic on the infrared
     media since receiving a Check Media Busy class-specific request. Note that
     Media_Busy shall indicate one (1) in exactly one header following receipt of each
     Check Media Busy class-specific request.

    According to USB IrDA Bridge Device Definition Doc sec 6.2.2:

      Check Media Busy
    This class-specific request instructs the Device to look for a media busy condition. If infrared
    traffic of any kind is detected by this Device, the Device shall set the Media_Busy field in the
    bmStatus field in the next Data-In packet header sent to the host. In the case where a Check
    Media Busy command has been received, a media busy condition detected, and no IrLAP frame
    traffic is ready to transmit to the host, the Device shall set the Media_Busy field and send it in a
    Data-In packet with no IrLAP frame following the header.

    bmRequestType   bRequest   wValue   wIndex   wLength   Data
    00100001B          3        Zero   Interface   Zero   [None]
     
*/
#if DBG
				if ( pThisDev->fMediaBusy ) 
					pThisDev->NumYesQueryMediaBusyOids++;
				else
					pThisDev->NumNoQueryMediaBusyOids++;
#endif
                *(UINT *)InformationBuffer = pThisDev->fMediaBusy; 
                status = NDIS_STATUS_SUCCESS;
                break;

            case OID_IRDA_EXTRA_RCV_BOFS:
                DEBUGMSG(DBG_ERR, (" StIrUsbQueryInformation(OID_IRDA_EXTRA_RCV_BOFS)\n"));
                //
                // Pass back the number of _extra_ BOFs to be prepended
                // to packets sent to this unit at 115.2 baud, the
                // maximum Slow IR speed. 
                // Gotten from the device's USB Class-Specific Descriptor
				//			
                *(UINT *)InformationBuffer = pThisDev->dongleCaps.extraBOFS;
                break;

            // PNP OIDs
            case OID_PNP_CAPABILITIES:
                DEBUGMSG(DBG_ERR, (" StIrUsbQueryInformation(OID_PNP_CAPABILITIES) OID %x BufLen:%d\n", Oid, InformationBufferLength));
                NdisZeroMemory( 
						InformationBuffer,
						sizeof(NDIS_PNP_CAPABILITIES)
					);
				//
				// Prepare formatting with the info
				//
				pNdisPnpCapabilities = (PNDIS_PNP_CAPABILITIES)InformationBuffer;
				pNdisPnpCapabilities->WakeUpCapabilities.MinMagicPacketWakeUp = NdisDeviceStateUnspecified;
				pNdisPnpCapabilities->WakeUpCapabilities.MinPatternWakeUp = NdisDeviceStateUnspecified;
				pNdisPnpCapabilities->WakeUpCapabilities.MinLinkChangeWakeUp = NdisDeviceStateUnspecified;
                break;

			case OID_PNP_QUERY_POWER:
				//
				// If we are asked to power down prepare to do it
				//
				switch( (NDIS_DEVICE_POWER_STATE)*(UINT *)InformationBuffer )
				{
					case NdisDeviceStateD0:
						DEBUGMSG(DBG_ERR, (" StIrUsbQueryInformation(OID_PNP_QUERY_POWER) NdisDeviceStateD0\n"));
						break;
					case NdisDeviceStateD1:
		                DEBUGMSG(DBG_ERR, (" StIrUsbQueryInformation(OID_PNP_QUERY_POWER) NdisDeviceStateD1\n"));
						//break;
					case NdisDeviceStateD2:
		                DEBUGMSG(DBG_ERR, (" StIrUsbQueryInformation(OID_PNP_QUERY_POWER) NdisDeviceStateD2\n"));
						//break;
					case NdisDeviceStateD3:
						DEBUGMSG(DBG_ERR, (" StIrUsbQueryInformation(OID_PNP_QUERY_POWER) NdisDeviceStateD3\n"));
						//
						// The processing must be essentially shut down
						//
						InterlockedExchange( (PLONG)&pThisDev->fProcessing, FALSE );
						ScheduleWorkItem( pThisDev,	SuspendIrDevice, NULL, 0 );
						//
						// This will be the new value of the DPLL register (when we come back up)
						//
						pThisDev->StIrTranceiver.DpllTuneReg = STIR4200_DPLL_DEFAULT;
						status = NDIS_STATUS_PENDING;
						break;
				}
				break;
			
            default:
                DEBUGMSG(DBG_ERR, (" StIrUsbQueryInformation(%d=0x%x), invalid OID\n", Oid, Oid));
                status = NDIS_STATUS_NOT_SUPPORTED; 
                break;
        }
    }
    else
    {
        *BytesNeeded = infoSizeNeeded - InformationBufferLength;
        *BytesWritten = 0;
        status = NDIS_STATUS_INVALID_LENGTH;
    }

done:
    if( NDIS_STATUS_PENDING != status ) 
	{
        // zero-out the time so check for hang handler knows nothing pending
        pThisDev->LastQueryTime.QuadPart = 0;
		pThisDev->fQuerypending          = FALSE;
    }

    DEBUGMSG(DBG_FUNC, ("-StIrUsbQueryInformation\n"));
    return status;
}

/*****************************************************************************
*
*  Function:   StIrUsbSetInformation
*
*  Synopsis:   StIrUsbSetInformation allows other layers of the network software
*              (e.g., a transport driver) to control the miniport driver
*              by changing information that the miniport driver maintains
*              in its OIDs, such as the packet filters or multicast addresses.
*
*  Arguments:  MiniportAdapterContext  - miniport context area (PIR_DEVICE)
*              Oid                     - system defined OID_Xxx
*              InformationBuffer       - buffer containing data for the set Oid
*              InformationBufferLength - specifies size of InformationBuffer
*              BytesRead               - bytes read from InformationBuffer
*              BytesNeeded             - addition bytes required if
*                                        InformationBufferLength is less than
*                                        what the Oid requires to read
*
*  Returns:    NDIS_STATUS_SUCCESS       - success
*              NDIS_STATUS_PENDING       - will complete asynchronously and
*                                          call NdisMSetInformationComplete
*              NDIS_STATUS_INVALID_OID   - don't recognize the Oid
*              NDIS_STATUS_INVALID_LENGTH- InformationBufferLength does not
*                                          match length for the Oid
*              NDIS_STATUS_INVALID_DATA  - supplied data was invalid for the
*                                          given Oid
*              NDIS_STATUS_NOT_ACCEPTED  - failure
*              NDIS_STATUS_NOT_SUPPORTED - do not support an optional Oid
*              NDIS_STATUS_RESOURCES     - failed allocation of resources
*
*  Notes:
*
*
*****************************************************************************/
NDIS_STATUS
StIrUsbSetInformation(
		IN  NDIS_HANDLE MiniportAdapterContext,
		IN  NDIS_OID    Oid,
		IN  PVOID       InformationBuffer,
		IN  ULONG       InformationBufferLength,
		OUT PULONG      BytesRead,
		OUT PULONG      BytesNeeded
	)
{
    NDIS_STATUS status;
    PIR_DEVICE pThisDev;
    int i;

    DEBUGMSG(DBG_FUNC, ("+StIrUsbSetInformation\n"));

    status   = NDIS_STATUS_SUCCESS;
    pThisDev = CONTEXT_TO_DEV( MiniportAdapterContext );

	IRUSB_ASSERT( NULL != pThisDev ); 
	IRUSB_ASSERT( NULL != BytesRead );
	IRUSB_ASSERT( NULL != BytesNeeded );

    KeQuerySystemTime( &pThisDev->LastSetTime ); //used by check for hang handler
	pThisDev->fSetpending = TRUE;

	if( (NULL == InformationBuffer) && InformationBufferLength ) 
	{ 
        DEBUGMSG(DBG_ERR, ("    StIrUsbSetInformation() NULL info buffer passed!,InformationBufferLength = dec %d\n",InformationBufferLength));
		status = NDIS_STATUS_NOT_ACCEPTED;
        *BytesNeeded =0;
        *BytesRead = 0;
        goto done;
 
	}

    if( InformationBufferLength >= sizeof(UINT) )
    {
        //
        //  Set default results.
        //
        UINT info = 0;
		
		if( NULL != InformationBuffer ) 
		{
			info = *(UINT *)InformationBuffer;
		}

        *BytesRead = sizeof(UINT);
        *BytesNeeded = 0;

        switch( Oid )
        {
            //
            //  Generic OIDs.
            //

            case OID_GEN_CURRENT_PACKET_FILTER:
                DEBUGMSG(DBG_ERR, (" StIrUsbSetInformation(OID_GEN_CURRENT_PACKET_FILTER, %xh)\n", info));
                //
                // We ignore the packet filter itself.
                //
                // Note:  The protocol may use a NULL filter, in which case
                //        we will not get this OID; so don't wait on
                //        OID_GEN_CURRENT_PACKET_FILTER to start receiving
                //        frames.
                //
                pThisDev->fGotFilterIndication = TRUE;
                break;

            case OID_GEN_CURRENT_LOOKAHEAD:
                DEBUGMSG(DBG_ERR, (" StIrUsbSetInformation(OID_GEN_CURRENT_LOOKAHEAD, %xh)\n", info));
                //
                // We always indicate entire receive frames all at once,
                // so just ignore this.
                //
                break;

            case OID_GEN_PROTOCOL_OPTIONS:
                DEBUGMSG(DBG_ERR, (" StIrUsbSetInformation(OID_GEN_PROTOCOL_OPTIONS, %xh)\n", info));
                //
                // Ignore.
                //
                break;

            //
            // Infrared OIDs.
            //
            case OID_IRDA_LINK_SPEED:
				//
				// Don't do it if we are in diagnostic mode
				//
#if defined(DIAGS)
				if( pThisDev->DiagsActive )
				{
                    DEBUGMSG(DBG_ERR, (" Rejecting due to diagnostic mode\n"));
					status = NDIS_STATUS_SUCCESS;
					break;
				}
#endif

                if( pThisDev->currentSpeed == info )
                {
                    //
                    // We are already set to the requested speed.
                    //
                    DEBUGONCE(DBG_FUNC, (" Link speed already set.\n"));
                    status = NDIS_STATUS_SUCCESS;

                    break;
                }

                DEBUGMSG(DBG_ERR, (" StIrUsbSetInformation(OID_IRDA_LINK_SPEED, 0x%x, decimal %d)\n",info, info));
                status = NDIS_STATUS_INVALID_DATA;

                for( i = 0; i < NUM_BAUDRATES; i++ )
                {
                    if( supportedBaudRateTable[i].BitsPerSec == info )
                    {
                        //
                        // Keep a pointer to the link speed which has
                        // been requested. 
                        //
                        pThisDev->linkSpeedInfo = &supportedBaudRateTable[i]; 

                        status = NDIS_STATUS_PENDING; 
                        break; //for
                    }
                }

                //
				// Don't set if there is an error
				//
				if( NDIS_STATUS_PENDING != status  )
                {
                    status = NDIS_STATUS_INVALID_DATA;
                    DEBUGMSG(DBG_ERR, (" Invalid link speed\n"));

                    *BytesRead = 0;
                    *BytesNeeded = 0;
					break;
                } 

				//
				// Set the new speed
				//
				IrUsb_PrepareSetSpeed( pThisDev ); 
				break;

            case OID_IRDA_MEDIA_BUSY:
#if !defined(ONLY_ERROR_MESSAGES)
                DEBUGMSG(DBG_ERR, (" StIrUsbSetInformation(OID_IRDA_MEDIA_BUSY, %xh)\n", info));
#endif
				//
				// See comments in the 'query' code above;
				//
#if DBG
				pThisDev->NumSetMediaBusyOids++;
#endif
				// should always be setting 0
				DEBUGCOND( DBG_ERR, TRUE == info, (" StIrUsbSetInformation(OID_IRDA_MEDIA_BUSY, %xh)\n", info));

				InterlockedExchange( &pThisDev->fMediaBusy, FALSE ); 
				InterlockedExchange( &pThisDev->fIndicatedMediaBusy, FALSE ); 

 				status = NDIS_STATUS_SUCCESS; 
                break;

			case OID_PNP_SET_POWER:
				//
				// Perform the operations required to stop/resume
				//
				switch( (NDIS_DEVICE_POWER_STATE)info )
				{
					case NdisDeviceStateD0:
		                DEBUGMSG(DBG_ERR, (" StIrUsbSetInformation(OID_PNP_SET_POWER) NdisDeviceStateD0\n"));
						//
						// Processing back up (and a new speed setting)
						//
						ScheduleWorkItem( pThisDev,	ResumeIrDevice, NULL, 0 );
						break;
					case NdisDeviceStateD1:
		                DEBUGMSG(DBG_ERR, (" StIrUsbSetInformation(OID_PNP_SET_POWER) NdisDeviceStateD1\n"));
						//break;
					case NdisDeviceStateD2:
		                DEBUGMSG(DBG_ERR, (" StIrUsbSetInformation(OID_PNP_SET_POWER) NdisDeviceStateD2\n"));
						//break;
					case NdisDeviceStateD3:
		                DEBUGMSG(DBG_ERR, (" StIrUsbSetInformation(OID_PNP_SET_POWER) NdisDeviceStateD3\n"));					
						//
						// Handle the case where query wasn't sent
						//
						if( pThisDev->fProcessing )
						{
							InterlockedExchange( (PLONG)&pThisDev->fProcessing, FALSE );
							ScheduleWorkItem( pThisDev,	SuspendIrDevice, NULL, 0 );
							//
							// This will be the new value of the DPLL register (when we come back up)
							//
							pThisDev->StIrTranceiver.DpllTuneReg = STIR4200_DPLL_DEFAULT;
						}
						break;
				}
				break;

            default:
                DEBUGMSG(DBG_ERR, (" StIrUsbSetInformation(OID=%d=0x%x, value=%xh) - invalid OID\n", Oid, Oid, info));

                *BytesRead = 0;
                *BytesNeeded = 0;
                status = NDIS_STATUS_INVALID_OID;

                break;
        }
    }
    else
    {
        //
        // The given data buffer is not large enough for the information
        // to set.
        //
        *BytesRead = 0;
        *BytesNeeded = sizeof(UINT);
        status = NDIS_STATUS_INVALID_LENGTH;
    }

done:

    if( NDIS_STATUS_PENDING != status ) 
	{
		//
        // zero-out the time so check for hang handler knows nothing pending
		//
        pThisDev->LastSetTime.QuadPart = 0;
		pThisDev->fSetpending = FALSE;
    }

    DEBUGMSG(DBG_FUNC, ("-StIrUsbSetInformation\n"));

    return status;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\net\irda\sigmatel\sys\irusb.c ===
/**************************************************************************************************************************
 *  IRUSB.C SigmaTel STIR4200 main module (contains main NDIS entry points)
 **************************************************************************************************************************
 *  (C) Unpublished Copyright of Sigmatel, Inc. All Rights Reserved.
 *
 *
 *		Created: 04/06/2000 
 *			Version 0.9
 *		Edited: 04/24/2000 
 *			Version 0.91
 *		Edited: 04/27/2000 
 *			Version 0.92
 *		Edited: 05/03/2000 
 *			Version 0.93
 *		Edited: 05/12/2000 
 *			Version 0.94
 *		Edited: 05/19/2000 
 *			Version 0.95
 *		Edited: 05/24/2000 
 *			Version 0.96
 *		Edited: 08/22/2000 
 *			Version 1.02
 *		Edited: 09/25/2000 
 *			Version 1.10
 *		Edited: 10/13/2000 
 *			Version 1.11
 *		Edited: 11/13/2000 
 *			Version 1.12
 *		Edited: 12/29/2000 
 *			Version 1.13
 *	
 *
 **************************************************************************************************************************/

#define DOBREAKS    // enable debug breaks

#include <ndis.h>
#include <ntddndis.h>  // defines OID's

#include <usbdi.h>
#include <usbdlib.h>

#include "debug.h"
#include "ircommon.h"
#include "irusb.h"
#include "irndis.h"
#include "diags.h"
#include "stirioctl.h"

//
// Diagnostic global variables
//
#ifndef WIN9X
//#if defined(DIAGS)
NDIS_HANDLE hSavedWrapper;
PIR_DEVICE pGlobalDev;
//#endif
#endif
//
// Mark the DriverEntry function to run once during initialization.
//
NDIS_STATUS DriverEntry( PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath );
#pragma NDIS_INIT_FUNCTION( DriverEntry )

/*****************************************************************************
*
*  Function:   DriverEntry
*
*  Synopsis:   register driver entry functions with NDIS
*
*  Arguments:  DriverObject - the driver object being initialized
*              RegistryPath - registry path of the driver
*
*  Returns:    value returned by NdisMRegisterMiniport
*
*  Algorithm:
*
*
*  Notes:
*
*  This routine runs at IRQL PASSIVE_LEVEL.
*
*****************************************************************************/
NDIS_STATUS
DriverEntry(
		IN PDRIVER_OBJECT pDriverObject,
		IN PUNICODE_STRING pRegistryPath
	)
{
    NDIS_STATUS status = NDIS_STATUS_SUCCESS;
    NDIS50_MINIPORT_CHARACTERISTICS characteristics;
    NDIS_HANDLE hWrapper;

    DEBUGMSG(DBG_FUNC, ("+DriverEntry(IrUsb)\n"));
    DEBUGMSG( DBG_FUNC ,(" Entering IRUSB DriverEntry(), pRegistryPath=\n    %ws\n", pRegistryPath->Buffer ));

    NdisMInitializeWrapper(
			&hWrapper,
			pDriverObject,
			pRegistryPath,
			NULL
		);

#ifndef WIN9X
//#if defined(DIAGS)
	hSavedWrapper = hWrapper;
//#endif
#endif
    DEBUGMSG(DBG_FUNC, (" DriverEntry(IrUsb) called NdisMInitializeWrapper()\n"));

    NdisZeroMemory(
			&characteristics,
			sizeof(NDIS50_MINIPORT_CHARACTERISTICS)
		);

    characteristics.MajorNdisVersion        =    (UCHAR)NDIS_MAJOR_VERSION;
    characteristics.MinorNdisVersion        =    (UCHAR)NDIS_MINOR_VERSION;
    characteristics.Reserved                =    0;

    characteristics.HaltHandler             =    StIrUsbHalt;
    characteristics.InitializeHandler       =    StIrUsbInitialize;
    characteristics.QueryInformationHandler =    StIrUsbQueryInformation;
    characteristics.SetInformationHandler   =    StIrUsbSetInformation;
    characteristics.ResetHandler            =    StIrUsbReset;

    //
    // For now we will allow NDIS to send only one packet at a time.
    //
	characteristics.SendHandler				=    StIrUsbSend;
    characteristics.SendPacketsHandler      =    StIrUsbSendPackets;

    //
    // We don't use NdisMIndicateXxxReceive function, so we will
    // need a ReturnPacketHandler to retrieve our packet resources.
    //
    characteristics.ReturnPacketHandler     =    StIrUsbReturnPacket;
    characteristics.TransferDataHandler     =    NULL;

    //
    // NDIS never calls the ReconfigureHandler.
    //
    characteristics.ReconfigureHandler      =    NULL;
	// MS Security bug #540168 - remove unused CheckForHangHandler
    characteristics.CheckForHangHandler     =	 NULL;

    //
    // This miniport driver does not handle interrupts.
    //
    characteristics.HandleInterruptHandler  =    NULL;
    characteristics.ISRHandler              =    NULL;
    characteristics.DisableInterruptHandler =    NULL;
    characteristics.EnableInterruptHandler  =    NULL;

    //
    // This miniport does not control a busmaster DMA with
    // NdisMAllocateShareMemoryAsysnc, AllocateCompleteHandler won't be
    // called from NDIS.
    //
    characteristics.AllocateCompleteHandler =    NULL;

    DEBUGMSG(DBG_FUNC, (" DriverEntry(IrUsb) initted locks and events\n"));
    DEBUGMSG(DBG_FUNC, (" DriverEntry(IrUsb) about to NdisMRegisterMiniport()\n"));

    status = NdisMRegisterMiniport(
			hWrapper,
			&characteristics,
			sizeof(NDIS50_MINIPORT_CHARACTERISTICS)
        );

    DEBUGMSG(DBG_FUNC, (" DriverEntry(IrUsb) after NdisMRegisterMiniport() status 0x%x\n", status));
    DEBUGMSG(DBG_WARN, ("-DriverEntry(IrUsb) status = 0x%x\n", status));

    return status;
}


/*****************************************************************************
*
*  Function:   StIrUsbInitialize
*
*  Synopsis:   Initializes the device (usbd.sys) and allocates all resources
*              required to carry out 'network' io operations.
*
*  Arguments:  OpenErrorStatus - allows StIrUsbInitialize to return additional
*                                status code NDIS_STATUS_xxx if returning
*                                NDIS_STATUS_OPEN_FAILED
*              SelectedMediumIndex - specifies to NDIS the medium type the
*                                    driver uses
*              MediumArray - array of NdisMediumXXX the driver can choose
*              MediumArraySize
*              MiniportAdapterHandle - handle identifying miniport's NIC
*              WrapperConfigurationContext - used with Ndis config and init
*                                            routines
*
*  Returns:    NDIS_STATUS_SUCCESS if properly configure and resources allocated
*              NDIS_STATUS_FAILURE, otherwise
*							 
*							 more specific failures:
*              NDIS_STATUS_UNSUPPORTED_MEDIA - driver can't support any medium
*              NDIS_STATUS_ADAPTER_NOT_FOUND - NdisOpenConfiguration or
*                                              NdisReadConfiguration failed
*              NDIS_STATUS_OPEN_FAILED       - failed to open serial.sys
*              NDIS_STATUS_NOT_ACCEPTED      - serial.sys does not accept the
*                                              configuration
*              NDIS_STATUS_RESOURCES         - could not claim sufficient
*                                              resources
*
*
*  Notes:      NDIS will not submit requests until this is complete.
*
*  This routine runs at IRQL PASSIVE_LEVEL.
*
*****************************************************************************/
NDIS_STATUS
StIrUsbInitialize(
		OUT PNDIS_STATUS OpenErrorStatus,
		OUT PUINT        SelectedMediumIndex,
		IN  PNDIS_MEDIUM MediumArray,
		IN  UINT         MediumArraySize,
		IN  NDIS_HANDLE  NdisAdapterHandle,
		IN  NDIS_HANDLE  WrapperConfigurationContext
	)
{
    UINT i;
    PIR_DEVICE pThisDev = NULL;
    NDIS_STATUS status = NDIS_STATUS_SUCCESS;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PDEVICE_OBJECT pPhysicalDeviceObject = NULL;
    PDEVICE_OBJECT pNextDeviceObject = NULL;
#ifndef WIN9X
//#if defined(DIAGS)
	UNICODE_STRING SymbolicLinkName;
	UNICODE_STRING DeviceName;
    PDEVICE_OBJECT pDeviceObject;
    PDRIVER_DISPATCH MajorFunction[IRP_MJ_MAXIMUM_FUNCTION+1];
//#endif
#endif
    DEBUGMSG(DBG_WARN, ("+StIrUsbInitialize\n"));

    //
    // Search for the irda medium in the medium array.
    //
    for( i = 0; i < MediumArraySize; i++ )
    {
        if( MediumArray[i] == NdisMediumIrda )
        {
            break;
        }
    }
    if( i < MediumArraySize )
    {
        *SelectedMediumIndex = i;
    }
    else
    {
        //
        // Irda medium not found.
        //
        DEBUGMSG(DBG_ERROR, (" Failure: NdisMediumIrda not found!\n"));
        status = NDIS_STATUS_UNSUPPORTED_MEDIA;

		//
		// Log the error
		//
        NdisWriteErrorLogEntry(
				NdisAdapterHandle,
				NDIS_STATUS_UNSUPPORTED_MEDIA,
				1,
				status
			);

        goto done;
    }

	//
	// This will connect to a specific bus
	//
	NdisMGetDeviceProperty(
			NdisAdapterHandle,
			&pPhysicalDeviceObject,
			NULL,
			&pNextDeviceObject,
			NULL,
			NULL
		);

	IRUSB_ASSERT( pPhysicalDeviceObject );
	IRUSB_ASSERT( pNextDeviceObject );

    DEBUGMSG( 
			DBG_OUT,
			("NdisMGetDeviceProperty PDO 0x%x,Next DO 0x%x\n",
			pPhysicalDeviceObject, pNextDeviceObject)
		);

    //
    // Allocate a functional device object.
    //
    ntStatus = IrUsb_AddDevice( &pThisDev );

    IRUSB_ASSERT( pThisDev );

    if( (ntStatus != STATUS_SUCCESS) || (pThisDev == NULL) )
    {
		//
		// Log the error
		//
        NdisWriteErrorLogEntry(
				NdisAdapterHandle,
				NDIS_STATUS_RESOURCES,
				1,
				ntStatus
			);

        DEBUGMSG(DBG_ERROR, (" IrUsb_AddDevice() FAILED.\n"));
        status = NDIS_STATUS_RESOURCES;
        goto done;
    }

    pThisDev->pUsbDevObj = pNextDeviceObject;
    pThisDev->pPhysDevObj = pPhysicalDeviceObject;

    //
    // Initialize device object and resources.
    // All the queues and buffer/packets etc. are allocated here.
    //
    status = InitializeDevice( pThisDev );
    if( status != NDIS_STATUS_SUCCESS )
    {
		//
		// Log the error
		//
        NdisWriteErrorLogEntry(
				NdisAdapterHandle,
				NDIS_STATUS_RESOURCES,
				1,
				status
			);

        DEBUGMSG(DBG_ERROR, (" InitializeDevice failed. Returned 0x%.8x\n", status));
        status = NDIS_STATUS_RESOURCES;
        goto done;
    }

    //
    // Record the NdisAdapterHandle.
    //
    pThisDev->hNdisAdapter = NdisAdapterHandle;
	
    //
    // NdisMSetAttributes will associate our adapter handle with the wrapper's
    // adapter handle.  The wrapper will then always use our handle
    // when calling us.  We use a pointer to the device object as the context.
    //
    NdisMSetAttributesEx(
			NdisAdapterHandle,
			(NDIS_HANDLE)pThisDev,
			0,
			NDIS_ATTRIBUTE_DESERIALIZE,
			NdisInterfaceInternal
		);

	//
    // Now we're ready to do our own startup processing.
    // USB client drivers such as us set up URBs (USB Request Packets) to send requests
    // to the host controller driver (HCD). The URB structure defines a format for all
    // possible commands that can be sent to a USB device.
    // Here, we request the device descriptor and store it,
    // and configure the device.
    // In USB, no special  HW processing is required to 'open'  or 'close' the pipes
	//
	pThisDev->WrapperConfigurationContext = WrapperConfigurationContext;
	ntStatus = IrUsb_StartDevice( pThisDev );

    if( ntStatus != STATUS_SUCCESS )
    {
		//
		// Log the error
		//
        NdisWriteErrorLogEntry(
				pThisDev->hNdisAdapter,
				NDIS_STATUS_ADAPTER_NOT_FOUND,
				1,
				ntStatus
			);

        DEBUGMSG(DBG_ERROR, (" IrUsb_StartDevice FAILED. Returned 0x%.8x\n", ntStatus));
        status = NDIS_STATUS_ADAPTER_NOT_FOUND;
        goto done;
    }

    //
    // Create an irp and begin our receives.
    // NOTE: All other receive processing will be done in the read completion
    //       routine  and PollingThread  started therein.
    //
    status = InitializeProcessing( pThisDev, TRUE );

    if( status != NDIS_STATUS_SUCCESS )
    {
		//
		// Log the error
		//
        NdisWriteErrorLogEntry(
				pThisDev->hNdisAdapter,
				NDIS_STATUS_RESOURCES,
				1,
				status
			);

        DEBUGMSG(DBG_ERROR, (" InitializeProcessing failed. Returned 0x%.8x\n", status));
        status = NDIS_STATUS_RESOURCES;
        goto done;
    }

	//
	// Initialize the diagnostic portion.
	// Also supports the CustomerData ioctl.
	//
#ifndef WIN9X
//#if defined(DIAGS)
	NdisZeroMemory( MajorFunction, sizeof(PDRIVER_DISPATCH)*(IRP_MJ_MAXIMUM_FUNCTION+1) );
	
	RtlInitUnicodeString( &SymbolicLinkName, L"\\DosDevices\\Stirusb" );
    RtlInitUnicodeString( &DeviceName, L"\\Device\\Stirusb" );

	MajorFunction[IRP_MJ_CREATE] = StIrUsbCreate;
    MajorFunction[IRP_MJ_CLOSE] = StIrUsbClose;
	MajorFunction[IRP_MJ_DEVICE_CONTROL] = StIrUsbDispatch;

	NdisMRegisterDevice(
			hSavedWrapper,
			&DeviceName,
			&SymbolicLinkName,
			MajorFunction,
			&pDeviceObject,
			&pThisDev->NdisDeviceHandle
		);
	pGlobalDev = pThisDev;
//#endif
#endif
done:
    if( status != NDIS_STATUS_SUCCESS )
    {
        if( pThisDev != NULL )
        {
            DeinitializeDevice( pThisDev );
            FreeDevice( pThisDev );
        }
    }

    if( status!=NDIS_STATUS_SUCCESS )
    {
        DEBUGMSG(DBG_ERR, (" IrUsb: StIrUsbInitialize failed %x\n", status));
    }
    else
    {
        DEBUGMSG(DBG_ERR, (" IrUsb: StIrUsbInitialize SUCCESS %x\n", status));

    }

    DEBUGMSG(DBG_FUNC, ("-StIrUsbInitialize\n"));
    return status;
}

/*****************************************************************************
*
*  Function:   StIrUsbHalt
*
*  Synopsis:   Deallocates resources when the NIC is removed and halts the
*              device.
*
*  Arguments:  Context - pointer to the ir device object
*
*  Returns:	   None
*
*  Algorithm:  Mirror image of StIrUsbInitialize...undoes everything initialize
*              did.
*  Notes:
*
*  This routine runs at IRQL PASSIVE_LEVEL.
*
*  BUGBUG: Could StIrUsbReset fail and then StIrUsbHalt be called. If so, we need
*          to chech validity of all the pointers, etc. before trying to
*          deallocate.
*
*****************************************************************************/
VOID
StIrUsbHalt(
		IN NDIS_HANDLE Context
	)
{
    PIR_DEVICE pThisDev;
    NTSTATUS ntstatus;

    DEBUGMSG(DBG_WARN, ("+StIrUsbHalt\n")); // change to FUNC later?

    pThisDev = CONTEXT_TO_DEV( Context );

	//
	// MS Security bug #540137
	// Note: fPendingHalt is checked by the polling thread to see if we are shutting down,
	// so there is a need for this variable. The following check to see if halt is
	// is called more than once has been changed to DBG only.
	//
#if DBG
	if( TRUE == pThisDev->fPendingHalt ) 
	{
		DEBUGMSG(DBG_ERR, (" StIrUsbHalt called with halt already pending\n"));
		IRUSB_ASSERT( 0 );
		goto done;
	}
#endif

    //
    // Let the send completion and receive completion routine know that there
    // is a pending reset.
    //
    pThisDev->fPendingHalt = TRUE;

    IrUsb_CommonShutdown( pThisDev, TRUE );  //shutdown logic common to halt and reset; see below

	//
	// We had better not have left any pending read, write, or control IRPS hanging out there!
	//
	IRUSB_ASSERT( 0 == pThisDev->PendingIrpCount );

	if ( 0 != pThisDev->PendingIrpCount ) 
	{
		DEBUGMSG(DBG_ERR, (" StIrUsbHalt WE LEFT %d PENDING IRPS!!!!!\n", pThisDev->PendingIrpCount));
	}

	IRUSB_ASSERT( FALSE == pThisDev->fSetpending );
	IRUSB_ASSERT( FALSE == pThisDev->fQuerypending );

	//
	// Destroy diags
	//
#ifndef WIN9X
//#if defined(DIAGS)
	NdisMDeregisterDevice( pThisDev->NdisDeviceHandle );
//#endif
#endif
    //
    // Free our own IR device object.
    //
    FreeDevice( pThisDev );

#if DBG
done:
#endif
	DEBUGMSG(DBG_ERR, (" StIrUsbHalt HALT complete\n"));
    DEBUGMSG(DBG_WARN, ("-StIrUsbHalt\n")); // change to FUNC later?
}


/*****************************************************************************
*
*  Function:	IrUsb_CommonShutdown
*	
*  Synopsis:	Deallocates resources when the NIC is removed and halts the
*				device. This is stuff common to IrUsbHalt and IrUsbReset and is called by both
*
*  Arguments:	pThisDev - pointer to IR device
*				KillPassiveThread - determines whether we need to kill the passive thread
*
*  Returns:		None
*
*  Algorithm:	Mirror image of IrUsbInitialize...undoes everything initialize
*				did.
*
*  Notes:
*
*  This routine runs at IRQL PASSIVE_LEVEL.
*
*
*****************************************************************************/
VOID
IrUsb_CommonShutdown(
		IN OUT PIR_DEVICE pThisDev,
		BOOLEAN KillPassiveThread
	)
{
	DEBUGMSG(DBG_WARN, ("+IrUsb_CommonShutdown\n")); //chg to FUNC later?

	//
	// Stop processing and sleep 50 milliseconds.
	//
	InterlockedExchange( (PLONG)&pThisDev->fProcessing, FALSE );
	NdisMSleep( 50000 );

	//
	// Kill the passive thread
	//
	if( KillPassiveThread )
	{
		DEBUGMSG(DBG_WARN, (" IrUsb_CommonShutdown About to Kill PassiveLevelThread\n"));
		pThisDev->fKillPassiveLevelThread = TRUE;
		KeSetEvent(&pThisDev->EventPassiveThread, 0, FALSE);

		while( pThisDev->hPassiveThread != NULL )
		{
			//
			// Sleep 50 milliseconds.
			//
			NdisMSleep( 50000 );
		}

		DEBUGMSG(DBG_WARN, (" passive thread killed\n"));
	}

	//
	// Kill the polling thread
	//
	DEBUGMSG(DBG_WARN, (" IrUsb_CommonShutdown About to kill Polling thread\n"));
	pThisDev->fKillPollingThread = TRUE;

	while( pThisDev->hPollingThread != NULL )
	{
		//
		// Sleep 50 milliseconds.
		//
		NdisMSleep( 50000 );
	}

	IRUSB_ASSERT( pThisDev->packetsHeldByProtocol == 0 );
	DEBUGMSG( DBG_WARN, (" Polling thread killed\n") );

	//
	// Sleep 50 milliseconds so pending io might finish normally
	//
	NdisMSleep( 50000 );    

	//
	// MS Security recommendation - not safe to cancel pending IRPs
	//

	//
	// Deinitialize our own ir device object.
	//
	DeinitializeDevice( pThisDev );

	pThisDev->fDeviceStarted = FALSE;

	DEBUGMSG(DBG_WARN, ("-IrUsb_CommonShutdown\n")); //chg to FUNC later?
}


/*****************************************************************************
*
*  Function:   StIrUsbReset
*
*  Synopsis:   Resets the drivers software state.
*
*  Arguments:  AddressingReset - return arg. If set to TRUE, NDIS will call
*                                MiniportSetInformation to restore addressing
*                                information to the current values.
*              Context         - pointer to ir device object
*
*  Returns:    NDIS_STATUS_PENDING
*
*
*  Notes:
*
*
*****************************************************************************/
NDIS_STATUS
StIrUsbReset(
		OUT PBOOLEAN AddressingReset,
		IN NDIS_HANDLE MiniportAdapterContext
	)
{
    PIR_DEVICE pThisDev;
    NDIS_STATUS status = NDIS_STATUS_PENDING;

    DEBUGMSG(DBG_WARN, ("+StIrUsbReset\n"));  // CHANGE TO FUNC?

    pThisDev = CONTEXT_TO_DEV( MiniportAdapterContext );

	if( TRUE == pThisDev->fPendingReset ) 
	{
		DEBUGMSG(DBG_ERROR, (" StIrUsbReset called with reset already pending\n"));

		status = NDIS_STATUS_RESET_IN_PROGRESS ;
		goto done;
	}

    //
    // Let the send completion and receive completion routine know that there
    // is a pending reset.
    //
    pThisDev->fPendingReset = TRUE;
	InterlockedExchange( (PLONG)&pThisDev->fProcessing, FALSE );
    *AddressingReset = TRUE;

	if( FALSE == ScheduleWorkItem( pThisDev, ResetIrDevice, NULL, 0) )
	{
		status = NDIS_STATUS_FAILURE;
	}

 done:
    DEBUGMSG(DBG_WARN, ("-StIrUsbReset\n"));  // change to FUNC later?
    return status;
}

/*****************************************************************************
*
*  Function:	SuspendIrDevice
*
*  Synopsis:	Callback for a going into suspend mode
*
*  Arguments:	pWorkItem - pointer to the reset work item
*
*  Returns:		NTSTATUS
*
*  Notes:
*
*****************************************************************************/
NTSTATUS
SuspendIrDevice(
		IN PIR_WORK_ITEM pWorkItem
	)
{
	PIR_DEVICE		pThisDev = (PIR_DEVICE)pWorkItem->pIrDevice;
	NTSTATUS		Status = STATUS_SUCCESS;

	//
	// We no longer need the work item
	//
	FreeWorkItem( pWorkItem );

	//
	// A little time to complete pending IRPs
	//
	NdisMSleep( 100*1000 );
	
	// MS Security recommendation - not safe to cancel pending IRPs

	//
	// Prepare the part
	//
#if defined(SUPPORT_LA8)
	if( pThisDev->ChipRevision >= CHIP_REVISION_8 )
	{
		Status = St4200EnableOscillatorPowerDown( pThisDev );
		if( Status == STATUS_SUCCESS )
		{
			Status = St4200TurnOnSuspend( pThisDev );
		}
	}
#endif

	//
	// Tell the OS
	//
	if( pThisDev->fQuerypending )
		MyNdisMQueryInformationComplete( pThisDev, Status );

	return Status;
}


/*****************************************************************************
*
*  Function:	ResumeIrDevice
*
*  Synopsis:	Callback for a going out of suspend mode
*
*  Arguments:	pWorkItem - pointer to the reset work item
*
*  Returns:		None
*
*  Notes:
*
*****************************************************************************/
NTSTATUS
ResumeIrDevice(
		IN PIR_WORK_ITEM pWorkItem
	)
{
	PIR_DEVICE		pThisDev = (PIR_DEVICE)pWorkItem->pIrDevice;
	NTSTATUS		Status = STATUS_SUCCESS;

	//
	// We no longer need the work item
	//
	FreeWorkItem( pWorkItem );
	
	//
	// Get the device back up and running
	//
#if defined(SUPPORT_LA8)
	if( pThisDev->ChipRevision >= CHIP_REVISION_8 )
	{
		Status = St4200TurnOffSuspend( pThisDev );
	}
#endif
	if (Status == STATUS_SUCCESS)
		St4200SetSpeed( pThisDev );
	InterlockedExchange( (PLONG)&pThisDev->currentSpeed, pThisDev->linkSpeedInfo->BitsPerSec );
	InterlockedExchange( (PLONG)&pThisDev->fProcessing, TRUE );

	return Status;
}


/*****************************************************************************
*
*  Function:	RestoreIrDevice
*
*  Synopsis:	Callback for a on-the-fly reset
*
*  Arguments:	pWorkItem - pointer to the reset work item
*
*  Returns:		NTSTATUS
*
*  Notes:
*
*****************************************************************************/
NTSTATUS
RestoreIrDevice(
		IN PIR_WORK_ITEM pWorkItem
	)
{
	NTSTATUS		Status = STATUS_SUCCESS;
	PIR_DEVICE		pThisDev = (PIR_DEVICE)pWorkItem->pIrDevice;
	UINT			CurrentSpeed, i;

    DEBUGMSG(DBG_WARN, ("+RestoreIrDevice\n")); 

	DEBUGMSG(DBG_ERROR, (" RestoreIrDevice USB hang, resetting\n"));

	//
	// We no longer need the work item
	//
	FreeWorkItem( pWorkItem );

	//
	// Give a little time to complete
	//
	NdisMSleep( 100*1000 );

	//
	// Force a reset on the USB bus
	//
	Status = IrUsb_ResetUSBD( pThisDev, FALSE );
    if( Status != STATUS_SUCCESS )
    {
        //IrUsb_ResetUSBD( pThisDev, TRUE );
		pThisDev->fDeviceStarted =  FALSE;
		InterlockedExchange( (PLONG)&pThisDev->fProcessing, FALSE );
		DEBUGMSG(DBG_ERROR, (" RestoreIrDevice() IrUsb_ResetUSBD failed. Returned 0x%.8x\n", Status));
        goto done;
    }

	//
	// Save the current speed
	//
	CurrentSpeed = pThisDev->currentSpeed;

	//
	// Shutdown the device
	//
    DEBUGMSG(DBG_WARN, (" RestoreIrDevice() about to call IrUsb_CommonShutdown()\n")); // change to FUNC later?
	IrUsb_CommonShutdown( pThisDev, FALSE );  //shutdown logic common to halt and reset; see above
    DEBUGMSG(DBG_WARN, (" RestoreIrDevice() after IrUsb_CommonShutdown()\n")); // change to FUNC later?
	
	//
	// Destroy and create again the USB portion of the device
	//
    DEBUGMSG(DBG_WARN, (" RestoreIrDevice() about to refresh USB info\n")); // change to FUNC later?
	FreeUsbInfo( pThisDev );

	if( !AllocUsbInfo( pThisDev ) )
	{
        DEBUGMSG(DBG_ERROR, (" RestoreIrDevice() AllocUsbInfo failed\n"));
        goto done;
	}

    DEBUGMSG(DBG_WARN, (" RestoreIrDevice() after refreshing USB info\n")); // change to FUNC later?

	//
	// Reinitialize the device
	//
    DEBUGMSG(DBG_WARN, (" RestoreIrDevice() about to call InitializeDevice()\n")); // change to FUNC later?
	Status = InitializeDevice( pThisDev );  

    if( Status != STATUS_SUCCESS )
    {
        DEBUGMSG(DBG_ERROR, (" RestoreIrDevice() InitializeDevice failed. Returned 0x%.8x\n", Status));
        goto done;
    }

    DEBUGMSG(DBG_WARN, (" RestoreIrDevice() InitializeProcessing() SUCCESS, about to call InitializeReceive()\n")); // change to FUNC later?

	//
	// Restart it
	//
	Status = IrUsb_StartDevice( pThisDev );

    if( Status != STATUS_SUCCESS )
    {
        DEBUGMSG(DBG_ERROR, (" RestoreIrDevice() IrUsb_StartDevice failed. Returned 0x%.8x\n", Status));
        goto done;
    }

    //
    // Keep a pointer to the link speed which was previously set
    //
    for( i = 0; i < NUM_BAUDRATES; i++ )
    {
        if( supportedBaudRateTable[i].BitsPerSec == CurrentSpeed )
        {
            pThisDev->linkSpeedInfo = &supportedBaudRateTable[i]; 

            break; //for
        }
    }

	//
	// restore the old speed
	//
	DEBUGMSG( DBG_ERR, (" Restoring speed to: %d\n", pThisDev->linkSpeedInfo->BitsPerSec));
	Status = St4200SetSpeed( pThisDev );
    if( Status != STATUS_SUCCESS )
    {
        DEBUGMSG(DBG_ERROR, (" RestoreIrDevice() St4200SetSpeed failed. Returned 0x%.8x\n", Status));
        goto done;
    }
	InterlockedExchange( (PLONG)&pThisDev->currentSpeed, CurrentSpeed );

    //
    // Initialize receive loop.
    //
    Status = InitializeProcessing( pThisDev, FALSE );

    if( Status != STATUS_SUCCESS )
    {
        DEBUGMSG(DBG_ERROR, (" RestoreIrDevice() InitializeProcessing failed. Returned 0x%.8x\n", Status));
        goto done;
    }

done:
    DEBUGCOND(DBG_ERROR, (Status != NDIS_STATUS_SUCCESS), (" RestoreIrDevice failed = 0x%.8x\n", Status));

	return Status;
}


/*****************************************************************************
*
*  Function:	ResetIrDevice
*
*  Synopsis:	Callback for StIrUsbReset
*
*  Arguments:	pWorkItem - pointer to the reset work item
*
*  Returns:		NTSTATUS
*
*  Notes:
*
*  The following elements of the ir device object outlast the reset:
*
*      pUsbDevObj
*      hNdisAdapter
*
*****************************************************************************/
NTSTATUS
ResetIrDevice(
		IN PIR_WORK_ITEM pWorkItem
	)
{
	NTSTATUS		Status = STATUS_SUCCESS;
	NDIS_STATUS		NdisStatus = NDIS_STATUS_SUCCESS;
	PIR_DEVICE		pThisDev = (PIR_DEVICE)pWorkItem->pIrDevice;

    DEBUGMSG(DBG_WARN, ("+ResetIrDevice\n")); // change to FUNC later?

	//
	// We no longer need the work item
	//
	FreeWorkItem( pWorkItem );

	//
	// A little time to complete pending IRPs
	//
	NdisMSleep( 100*1000 );

	// MS Security recommendation - not safe to cancel pending IRPs
	
	//
	// reset the part
	//
	Status = IrUsb_ResetUSBD( pThisDev, FALSE );
    if( Status != STATUS_SUCCESS )
    {
		pThisDev->fDeviceStarted =  FALSE;
		//
		// Log the error
		//
        NdisWriteErrorLogEntry(
				pThisDev->hNdisAdapter,
				NDIS_STATUS_ADAPTER_NOT_FOUND,
				1,
				Status
			);

        DEBUGMSG(DBG_ERROR, (" ResetIrDevice() IrUsb_ResetUSBD failed. Returned 0x%.8x\n", Status));
        NdisStatus = NDIS_STATUS_ADAPTER_NOT_FOUND;
        goto done;
    }
 
	//
	// Shutdown the device
	//
    DEBUGMSG(DBG_WARN, (" ResetIrDevice() about to call IrUsb_CommonShutdown()\n")); // change to FUNC later?
	IrUsb_CommonShutdown( pThisDev, FALSE );  //shutdown logic common to halt and reset; see above
    DEBUGMSG(DBG_WARN, (" ResetIrDevice() after IrUsb_CommonShutdown()\n")); // change to FUNC later?
	
	//
	// Destroy and create again the USB portion of the device
	//
    DEBUGMSG(DBG_WARN, (" ResetIrDevice() about to refresh USB info\n")); // change to FUNC later?
	FreeUsbInfo( pThisDev );

	if( !AllocUsbInfo( pThisDev ) )
	{
		//
		// Log the error
		//
        NdisWriteErrorLogEntry(
				pThisDev->hNdisAdapter,
				NDIS_STATUS_RESOURCES,
				1,
				Status
			);

        DEBUGMSG(DBG_ERROR, (" ResetIrDevice() AllocUsbInfo failed\n"));
        NdisStatus = NDIS_STATUS_FAILURE;
        goto done;
	}

    DEBUGMSG(DBG_WARN, (" ResetIrDevice() after refreshing USB info\n")); // change to FUNC later?

	//
	// Reinitialize the device
	//
    DEBUGMSG(DBG_WARN, (" ResetIrDevice() about to call InitializeDevice()\n")); // change to FUNC later?
	Status = InitializeDevice( pThisDev );  

    if( Status != NDIS_STATUS_SUCCESS )
    {
		//
		// Log the error
		//
        NdisWriteErrorLogEntry(
				pThisDev->hNdisAdapter,
				NDIS_STATUS_RESOURCES,
				1,
				Status
			);

        DEBUGMSG(DBG_ERROR, (" ResetIrDevice() InitializeDevice failed. Returned 0x%.8x\n", Status));
        NdisStatus = NDIS_STATUS_FAILURE;
        goto done;
    }

    DEBUGMSG(DBG_WARN, (" ResetIrDevice() InitializeProcessing() SUCCESS, about to call InitializeReceive()\n")); // change to FUNC later?

	//
	// Restart it
	//
	Status = IrUsb_StartDevice( pThisDev );

    if( Status != STATUS_SUCCESS )
    {
		//
		// Log the error
		//
        NdisWriteErrorLogEntry(
				pThisDev->hNdisAdapter,
				NDIS_STATUS_ADAPTER_NOT_FOUND,
				1,
				Status
			);

        DEBUGMSG(DBG_ERROR, (" ResetIrDevice() IrUsb_StartDevice failed. Returned 0x%.8x\n", Status));
        NdisStatus = NDIS_STATUS_ADAPTER_NOT_FOUND;
        goto done;
    }

    //
    // Initialize receive loop.
    //
    Status = InitializeProcessing( pThisDev, FALSE );

    if( Status != STATUS_SUCCESS )
    {
		//
		// Log the error
		//
        NdisWriteErrorLogEntry(
				pThisDev->hNdisAdapter,
				NDIS_STATUS_RESOURCES,
				1,
				Status
			);

        DEBUGMSG(DBG_ERROR, (" ResetIrDevice() InitializeProcessing failed. Returned 0x%.8x\n", Status));
        NdisStatus = NDIS_STATUS_FAILURE;
        goto done;
    }

done:
    DEBUGCOND(DBG_ERROR, (Status != NDIS_STATUS_SUCCESS), (" ResetIrDevice failed = 0x%.8x\n", Status));

	//
	// Deal with possible errors
	//
    if( NdisStatus != NDIS_STATUS_SUCCESS )
    {
        NdisStatus = NDIS_STATUS_HARD_ERRORS;
    }

	NdisMResetComplete(
			pThisDev->hNdisAdapter,
			NdisStatus,
			TRUE
		);

    DEBUGMSG(DBG_WARN, ("-ResetIrDevice\n")); // change to FUNC later?

	return Status;
}


/*****************************************************************************
*
*  Function:	GetPacketInfo
*
*  Synopsis:	Gets the IR specific information for an input packet
*
*  Arguments:	pPacket - pointer to packet
*	
*  Returns:		PNDIS_IRDA_PACKET_INFO structure for the packet
*
*  Notes:
*
*****************************************************************************/
PNDIS_IRDA_PACKET_INFO 
GetPacketInfo( 
		IN PNDIS_PACKET pPacket
	)
{
    PMEDIA_SPECIFIC_INFORMATION pMediaInfo;
    UINT                        Size;

    NDIS_GET_PACKET_MEDIA_SPECIFIC_INFO( pPacket, &pMediaInfo, &Size );

	if( Size )
		return (PNDIS_IRDA_PACKET_INFO)pMediaInfo->ClassInformation;
	else
		return NULL;
}


/*****************************************************************************
*
*  Function:	MyNdisMSetInformationComplete
*
*  Synopsis:	Call NdisMSetInformationComplete()
*
*  Arguments:	pThisDev - pointer to IR device
*				Status - status to signal
*	
*  Returns:		None
*
*  Notes:		
*
*****************************************************************************/
VOID 
MyNdisMSetInformationComplete(
		IN PIR_DEVICE pThisDev,
		IN NDIS_STATUS Status
	)
{
    DEBUGMSG( DBG_FUNC,("+MyNdisMSetInformationComplete\n"));

    NdisMSetInformationComplete( (NDIS_HANDLE)pThisDev->hNdisAdapter, Status );
    pThisDev->LastSetTime.QuadPart = 0;
	pThisDev->fSetpending = FALSE;

    DEBUGMSG( DBG_FUNC,("-MyNdisMSetInformationComplete\n"));
}


/*****************************************************************************
*
*  Function:	MyNdisMQueryInformationComplete
*
*  Synopsis:	Call NdisMQueryInformationComplete()
*
*  Arguments:	pThisDev - pointer to IR device
*				Status - status to signal
*	
*  Returns:		None
*
*  Notes:		
*
*****************************************************************************/
VOID 
MyNdisMQueryInformationComplete(
		IN PIR_DEVICE pThisDev,
		IN NDIS_STATUS Status
	)
{
    DEBUGMSG( DBG_FUNC,("+MyNdisMQueryInformationComplete\n"));

    NdisMQueryInformationComplete( (NDIS_HANDLE)pThisDev->hNdisAdapter, Status );
    pThisDev->LastQueryTime.QuadPart = 0;
	pThisDev->fQuerypending = FALSE;

    DEBUGMSG( DBG_FUNC,("-MyNdisMQueryInformationComplete\n"));
}


/*****************************************************************************
*
*  Function:	IndicateMediaBusy
*
*  Synopsis:	Call NdisMIndicateStatus()
*
*  Arguments:	pThisDev - pointer to IR device
*	
*  Returns:		None
*
*  Notes:
*
*****************************************************************************/
VOID 
IndicateMediaBusy(
		IN PIR_DEVICE pThisDev
	)

{
    DEBUGMSG( DBG_FUNC,("+IndicateMediaBusy\n"));

    NdisMIndicateStatus(
		   pThisDev->hNdisAdapter,
		   NDIS_STATUS_MEDIA_BUSY,
		   NULL,
		   0
       );

    NdisMIndicateStatusComplete(
		   pThisDev->hNdisAdapter
       );

#if DBG
	pThisDev->NumMediaBusyIndications ++;
#endif
#if !defined(ONLY_ERROR_MESSAGES)
    DEBUGMSG(DBG_ERR, (" IndicateMediaBusy()\n"));
#endif

    DEBUGMSG( DBG_FUNC,("-IndicateMediaBusy\n"));
}


/*****************************************************************************
*
*  Function:   StIrUsbSendPackets
*
*  Synopsis:   Send a packet to the USB driver and add the sent irp and io context to
*              To the pending send queue; this que is really just needed for possible later error cancellation
*
*
*  Arguments:  MiniportAdapterContext	- pointer to current ir device object
*              PacketArray				- pointer to array of packets to send
*              NumberOfPackets          - number of packets in the array
*
*  Returns:    VOID
*
*	Notes: This routine does nothing but calling StIrUsbSend
*
*
*****************************************************************************/
VOID
StIrUsbSendPackets(
		IN NDIS_HANDLE  MiniportAdapterContext,
		IN PPNDIS_PACKET  PacketArray,
		IN UINT  NumberOfPackets
	)
{
	ULONG i;

	//
    // This is a great opportunity to be lazy.  
    // Just call StIrUsbSend with each packet  
    // in sequence and set the result in the 
    // packet array object.                      
	//
    for( i=0; i<NumberOfPackets; i++ )
    {
        StIrUsbSend( MiniportAdapterContext, PacketArray[i], 0 );
    }
}


/*****************************************************************************
*
*  Function:   StIrUsbSend
*
*  Synopsis:   Send a packet to the USB driver and add the sent irp and io context to
*              To the pending send queue; this que is really just needed for possible later error cancellation
*
*
*  Arguments:  MiniportAdapterContext - pointer to current ir device object
*              pPacketToSend          - pointer to packet to send
*              Flags                  - any flags set by protocol
*
*  Returns:    NDIS_STATUS_PENDING - This is generally what we should
*                                    return. We will call NdisMSendComplete
*                                    when the USB driver completes the
*                                    send.
*
*  Unsupported returns:
*              NDIS_STATUS_SUCCESS  - We should never return this since
*                                     results will always be pending from
*                                     the USB driver.
*              NDIS_STATUS_RESOURCES - This indicates to the protocol that the
*                                      device currently has no resources to complete
*                                      the request. The protocol will resend
*                                      the request when it receives either
*                                      NdisMSendResourcesAvailable or
*                                      NdisMSendComplete from the device.
*
*	Notes: This routine delegates all the real work to SendPacketPreprocess in send.c
*
*
*****************************************************************************/
NDIS_STATUS
StIrUsbSend(
		IN NDIS_HANDLE  MiniportAdapterContext,
		IN PNDIS_PACKET pPacketToSend,
		IN UINT         Flags
	)
{
	PIR_DEVICE		pThisDev = (PIR_DEVICE)MiniportAdapterContext;
	NDIS_STATUS		Status;

	DEBUGMSG( DBG_FUNC,("+StIrUsbSend()\n"));

    //
	// Make sure we are in the proper status, i.e. we are processing
	// and no diagnostics are active
	//
#if defined(DIAGS)
	if( !pThisDev->fProcessing || pThisDev->DiagsPendingActivation )
#else
	if( !pThisDev->fProcessing )
#endif
	{
		Status = NDIS_STATUS_FAILURE;
		goto done;
	}

	//
	// Send the packet to the hardware
	//
    NDIS_SET_PACKET_STATUS( pPacketToSend, NDIS_STATUS_PENDING );
	Status = SendPacketPreprocess( 
			pThisDev,
			pPacketToSend
		);

done:
	//
	// If the operation didn't pend we have to complete
	// We are really bouncing the packets...
	//
	if( Status != NDIS_STATUS_PENDING )
	{
		NdisMSendComplete(
				pThisDev->hNdisAdapter,
				pPacketToSend,
				NDIS_STATUS_SUCCESS 
			);
	}

	DEBUGMSG( DBG_FUNC,("-StIrUsbSend()\n"));
	return Status;
}


// Diagnostic entry points

#ifndef WIN9X
//#if defined(DIAGS)

/*****************************************************************************
*
*  Function:	StIrUsbDispatch
*
*  Synopsis:	Processes the diagnostic Irps
*	
*  Arguments:	DeviceObject - pointer to the device object
*				Irp - pointer to the Irp
*	
*  Returns:		NT status code
*
*  Notes:
*
*****************************************************************************/
NTSTATUS
StIrUsbDispatch(
		IN PDEVICE_OBJECT DeviceObject,
		IN PIRP Irp
	)
{
	PIR_DEVICE			pThisDev = pGlobalDev;
    PIO_STACK_LOCATION  irpSp;
    ULONG               FunctionCode;
    NTSTATUS			status;
	PVOID				pBuffer;
	ULONG				BufferLength;
	USHORT				DiagsCode;

	DEBUGMSG( DBG_FUNC,("+StIrUsbDispatch()\n"));
    
    //
	// Get the Irp
	//
	irpSp = IoGetCurrentIrpStackLocation( Irp );

	//
	// Get the data
	//
    FunctionCode = irpSp->Parameters.DeviceIoControl.IoControlCode;
	pBuffer = Irp->AssociatedIrp.SystemBuffer;

	//
	// Process the diagnostic operation
	//
	switch( FunctionCode )
	{
#ifdef DIAGS
		case IOCTL_PROTOCOL_DIAGS:

			DiagsCode = *(PUSHORT)pBuffer;
			BufferLength = irpSp->Parameters.DeviceIoControl.InputBufferLength;

			switch( DiagsCode )
			{
				case DIAGS_ENABLE:
					status = Diags_Enable( pThisDev );
					break;
				case DIAGS_DISABLE:
					status = Diags_Disable( pThisDev );
					break;
				case DIAGS_READ_REGISTERS:
					status = Diags_ReadRegisters( pThisDev, pBuffer, BufferLength );
					if( status == STATUS_SUCCESS )
					{
						Irp->IoStatus.Information = sizeof(DIAGS_READ_REGISTERS_IOCTL);
					}
					break;
				case DIAGS_WRITE_REGISTER:
					status = Diags_WriteRegister( pThisDev, pBuffer, BufferLength );
					break;
				case DIAGS_BULK_OUT:
					status = Diags_PrepareBulk( pThisDev, pBuffer, BufferLength, TRUE );
					break;
				case DIAGS_BULK_IN:
					status = Diags_PrepareBulk( pThisDev, pBuffer, BufferLength, FALSE );
					if( status == STATUS_SUCCESS )
					{
						PDIAGS_BULK_IOCTL pIOCTL = pThisDev->pIOCTL;
						
						Irp->IoStatus.Information = sizeof(DIAGS_BULK_IOCTL)+pIOCTL->DataSize-1;
					}
					break;
				case DIAGS_SEND:
					status = Diags_PrepareSend( pThisDev, pBuffer, BufferLength );
					break;
				case DIAGS_RECEIVE:
					status = Diags_Receive( pThisDev, pBuffer, BufferLength );
					if( status == STATUS_SUCCESS )
					{
						PDIAGS_RECEIVE_IOCTL pIOCTL = pThisDev->pIOCTL;
						
						Irp->IoStatus.Information = sizeof(DIAGS_RECEIVE_IOCTL)+pIOCTL->DataSize-1;
					}
					break;
				case DIAGS_GET_SPEED:
					status = Diags_GetSpeed( pThisDev, pBuffer, BufferLength );
					if( status == STATUS_SUCCESS )
					{
						Irp->IoStatus.Information = sizeof(DIAGS_SPEED_IOCTL);
					}
					break;
				case DIAGS_SET_SPEED:
					status = Diags_SetSpeed( pThisDev, pBuffer, BufferLength );
					break;
				default:
					status = STATUS_NOT_SUPPORTED;
					break;
			}
			break;
#endif //DIAGS

		case IOCTL_STIR_CUSTOMER_DATA:
			//
			// Return customer data returned from the chip on power-up.
			//
			BufferLength = irpSp->Parameters.DeviceIoControl.OutputBufferLength;

			if (BufferLength < sizeof(STIR_CUSTOMER_DATA))
			{
				status = STATUS_INVALID_PARAMETER;
				break;
			}

			RtlCopyMemory(pBuffer, &(pThisDev->pCustomerData[2]), sizeof(STIR_CUSTOMER_DATA));
			status = STATUS_SUCCESS;
			Irp->IoStatus.Information = sizeof(STIR_CUSTOMER_DATA);
			break;

		default:
			status = STATUS_NOT_SUPPORTED;
			break;
	}

    //
	// Complete and return
	//
	Irp->IoStatus.Status = status;
	IoCompleteRequest( Irp, IO_NO_INCREMENT );
	DEBUGMSG( DBG_FUNC,("-StIrUsbDispatch()\n"));
    return status;
}


/*****************************************************************************
*
*  Function:	StIrUsbCreate
*
*  Synopsis:	Creates a new diagnostic object (it does nothing)
*	
*  Arguments:	DeviceObject - pointer to the device object
*				Irp - pointer to the Irp
*	
*  Returns:		NT status code
*
*  Notes:
*
*****************************************************************************/
NTSTATUS
StIrUsbCreate(
		IN PDEVICE_OBJECT DeviceObject,
		IN PIRP Irp
	)
{
 	PIR_DEVICE pThisDev = pGlobalDev;

	//
    //  Initialize list for holding pending read requests
    //
#ifdef DIAGS
    KeInitializeSpinLock( &pThisDev->DiagsReceiveLock );
    InitializeListHead( &pThisDev->DiagsReceiveQueue );
#endif // DIAGS

    Irp->IoStatus.Status = STATUS_SUCCESS;
	IoCompleteRequest( Irp, IO_NO_INCREMENT );
	return STATUS_SUCCESS;
}


/*****************************************************************************
*
*  Function:	StIrUsbClose
*
*  Synopsis:	Destroys a new diagnostic object (it does nothing)
*	
*  Arguments:	DeviceObject - pointer to the device object
*				Irp - pointer to the Irp
*	
*  Returns:		NT status code
*
*  Notes:
*
*****************************************************************************/
NTSTATUS
StIrUsbClose(
		IN PDEVICE_OBJECT DeviceObject,
		IN PIRP Irp
	)
{
    Irp->IoStatus.Status = STATUS_SUCCESS;
	IoCompleteRequest( Irp, IO_NO_INCREMENT );
	return STATUS_SUCCESS;
}

//#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\net\irda\sigmatel\sys\resource.c ===
/**************************************************************************************************************************
 *  RESOURCE.C SigmaTel STIR4200 memory allocation module
 **************************************************************************************************************************
 *  (C) Unpublished Copyright of Sigmatel, Inc. All Rights Reserved.
 *
 *
 *		Created: 04/06/2000 
 *			Version 0.9
 *	
 *
 **************************************************************************************************************************/

#define DOBREAKS    // enable debug breaks

#include <ndis.h>
#include <ntddndis.h>  // defines OID's

#include <usbdi.h>
#include <usbdlib.h>

#include "debug.h"
#include "ircommon.h"
#include "irndis.h"


/*****************************************************************************
*
*  Function:   MyMemAlloc
*
*  Synopsis:   allocates a block of memory using NdisAllocateMemory
*
*  Arguments:  size - size of the block to allocate
*
*  Returns:    a pointer to the allocated block of memory
*
*
*****************************************************************************/
PVOID
MyMemAlloc( 
		UINT size 
	)
{
    PVOID			pMem;
    NDIS_STATUS     status;

    status = NdisAllocateMemoryWithTag( &pMem, size, IRUSB_TAG );

    if( status != NDIS_STATUS_SUCCESS )
    {
        DEBUGMSG(DBG_ERR, (" Memory allocation failed\n"));
        pMem = NULL;
    }

    return pMem;
}


/*****************************************************************************
*
*  Function:   MyMemFree
*
*  Synopsis:   frees a block of memory allocated by MyMemAlloc
*
*  Arguments:  memptr - memory to free
*              size   - size of the block to free
*
*
*****************************************************************************/
VOID
MyMemFree(
		PVOID pMem,
		UINT size
	)
{
    NdisFreeMemory( pMem, size, 0 );
}

/*****************************************************************************
*
*  Function:   MyUrbAlloc
*
*  Synopsis:   allocates an URB using NdisAllocateMemory
*
*  Arguments:  size - size of urb to allocate
*
*  Returns:    a pointer to the urb
*
*****************************************************************************/
PURB
MyUrbAlloc( 
		UINT size 
	)
{
	PURB pUrb = NULL;

	pUrb = MyMemAlloc( size );

	if( NULL == pUrb )
	{
		DEBUGMSG(DBG_ERR, (" IrUsb failed to alloc urb\n"));
	}
	else
	{
		NdisZeroMemory( pUrb, size );
	}

	return pUrb;
}

/*****************************************************************************
*
*  Function:   MyUrbFree
*
*  Synopsis:   frees an Urb allocated by MyUrbAlloc
*
*  Arguments:  pUrb - urb to free
*              size   - size of the urb to free
*
*
*****************************************************************************/
VOID
MyUrbFree(
		PURB pUrb,
		UINT size
	)
{
	MyMemFree(pUrb, size);
}

/*****************************************************************************
*
*  Function:   NewDevice
*
*  Synopsis:   allocates an IR device and zeros the memory
*
*  Arguments:  none
*
*  Returns:    initialized IR device or NULL (if alloc failed)
*
*
*****************************************************************************/
PIR_DEVICE
NewDevice()
{
    PIR_DEVICE	pNewDev;

    pNewDev = MyMemAlloc( sizeof(IR_DEVICE) );

    if( pNewDev != NULL )
    {
		NdisZeroMemory( (PVOID)pNewDev, sizeof(IR_DEVICE) );

		if( !AllocUsbInfo( pNewDev ) ) 
		{
			MyMemFree( pNewDev, sizeof(IR_DEVICE) );
			pNewDev = NULL;
		} 
	}

    return pNewDev;
}

/*****************************************************************************
*
*  Function:   FreeDevice
*
*  Synopsis:   frees an IR device structure
*
*  Arguments:  pThisDev - pointer to device to free
*
*  Returns:    none
*
*
*****************************************************************************/
VOID
FreeDevice(
		IN OUT PIR_DEVICE pThisDev
	)
{
	FreeUsbInfo( pThisDev );
    MyMemFree( (PVOID)pThisDev, sizeof(IR_DEVICE) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\net\irda\sigmatel\sys\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by IrUsb.rc
//
#define IDC_CURSOR1                     104

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        105
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\net\irda\sigmatel\sys\settings.c ===
/**************************************************************************************************************************
 *  SETTINGS.C SigmaTel STIR4200 baud rate information table
 **************************************************************************************************************************
 *  (C) Unpublished Copyright of Sigmatel, Inc. All Rights Reserved.
 *
 *
 *		Created: 04/06/2000 
 *			Version 0.9
 *		Edited: 04/27/2000 
 *			Version 0.92
 *		Edited: 11/15/2000 
 *			Version 1.12
 *	
 *
 **************************************************************************************************************************/

#define DOBREAKS    // enable debug breaks

#include <ndis.h>
#include <ntddndis.h>  // defines OID's

#include <usbdi.h>
#include <usbdlib.h>

#include "debug.h"
#include "ircommon.h"
#include "irndis.h"

BAUDRATE_INFO supportedBaudRateTable[NUM_BAUDRATES] = {
    {
        BAUDRATE_2400,
        SPEED_2400,
		IR_MODE_SIR,
        NDIS_IRDA_SPEED_2400, 
		0xDF

    },
    {
        BAUDRATE_9600,
        SPEED_9600,
		IR_MODE_SIR,
        NDIS_IRDA_SPEED_9600,
		0x77
    },
    {
        BAUDRATE_19200,
        SPEED_19200,
		IR_MODE_SIR,
        NDIS_IRDA_SPEED_19200,
		0x3B
    },
    {
        BAUDRATE_38400,
        SPEED_38400,
		IR_MODE_SIR,
        NDIS_IRDA_SPEED_38400,
		0x1D
    },
    {
        BAUDRATE_57600,
        SPEED_57600,
		IR_MODE_SIR,
        NDIS_IRDA_SPEED_57600,
		0x13
    },
    {
        BAUDRATE_115200,
        SPEED_115200,
		IR_MODE_SIR,
        NDIS_IRDA_SPEED_115200,
		0x09
    },
#if !defined(WORKAROUND_BROKEN_MIR)
    {
        BAUDRATE_576000,
        SPEED_576000,
		IR_MODE_MIR,
        NDIS_IRDA_SPEED_576K,
		0x15
    },
    {
        BAUDRATE_1152000,
        SPEED_1152000,
		IR_MODE_MIR,
        NDIS_IRDA_SPEED_1152K,
		0x01
    },
#endif
    {
        BAUDRATE_4000000,
        SPEED_4000000,
		IR_MODE_FIR,
        NDIS_IRDA_SPEED_4M,
		0x02
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\net\irda\sigmatel\sys\stirioctl.h ===
//
// stirioctl.h
//

#ifndef _STIRIOCTL_H_
#define _STIRIOCTL_H_

#define STIR_CUSTOMER_INFO_SIZE	255

// Structure of returned customer data buffer
typedef struct _STIR_CUSTOMER_DATA
{
	UCHAR	ByteCount;
	UCHAR	Info[STIR_CUSTOMER_INFO_SIZE];

} STIR_CUSTOMER_DATA, *PSTIR_CUSTOMER_DATA;

#ifndef FILE_DEVICE_STIRUSB
#define FILE_DEVICE_STIRUSB			0x8000
#endif

#define IOCTL_STIR_CUSTOMER_DATA	CTL_CODE(FILE_DEVICE_STIRUSB, 0x900, METHOD_BUFFERED, FILE_ANY_ACCESS)

#endif // _STIRIOCTL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\net\irda\sigmatel\sys\send.c ===
/**************************************************************************************************************************
 *  SEND.C SigmaTel STIR4200 packet send module
 **************************************************************************************************************************
 *  (C) Unpublished Copyright of Sigmatel, Inc. All Rights Reserved.
 *
 *
 *		Created: 04/06/2000 
 *			Version 0.9
 *		Edited: 04/27/2000 
 *			Version 0.92
 *		Edited: 05/03/2000 
 *			Version 0.93
 *		Edited: 05/12/2000 
 *			Version 0.94
 *		Edited: 08/22/2000 
 *			Version 1.02
 *		Edited: 09/25/2000 
 *			Version 1.10
 *		Edited: 10/13/2000 
 *			Version 1.11
 *		Edited: 11/09/2000 
 *			Version 1.12
 *		Edited: 12/29/2000 
 *			Version 1.13
 *		Edited: 01/16/2001 
 *			Version 1.14
 *	
 *
 **************************************************************************************************************************/

#include <ndis.h>
#include <ntdef.h>
#include <windef.h>

#include "stdarg.h"
#include "stdio.h"

#include "debug.h"
#include "usbdi.h"
#include "usbdlib.h"

#include "ircommon.h"
#include "irusb.h"
#include "irndis.h"
#include "stir4200.h"


/*****************************************************************************
*
*  Function:   SendPacketPreprocess
*
*  Synopsis:   Prepares a packet in such a way that the polling thread can later send it
*              The only operations are initializing and queuing the context
*
*
*  Arguments:  pThisDev - pointer to current ir device object
*              pPacketToSend - pointer to packet to send
*
*  Returns:    NDIS_STATUS_PENDING - This is generally what we should
*                                    return. We will call NdisMSendComplete
*                                    when the USB driver completes the
*                                    send.
*              NDIS_STATUS_RESOURCES - No descriptor was available.
*
*  Unsupported returns:
*              NDIS_STATUS_SUCCESS - We should never return this since
*                                    packet has to be sent from the polling thread
*
*
*
*****************************************************************************/
NDIS_STATUS
SendPacketPreprocess(
		IN OUT PIR_DEVICE pThisDev,
		IN PVOID pPacketToSend
	)
{
    NDIS_STATUS			status = NDIS_STATUS_PENDING ;
	PIRUSB_CONTEXT		pThisContext;
	PLIST_ENTRY			pListEntry;

    DEBUGMSG(DBG_FUNC, ("+SendPacketPreprocess\n"));

	//
	// See if there are available send contexts
	//
	if( pThisDev->SendAvailableCount<=2 )
    {
        DEBUGMSG(DBG_ERR, (" SendPacketPreprocess not enough contexts\n"));

 		InterlockedIncrement( &pThisDev->packetsSentRejected );
		status = NDIS_STATUS_RESOURCES;
        goto done;
    }

	//
	// Dequeue a context
	//
	pListEntry = ExInterlockedRemoveHeadList( &pThisDev->SendAvailableQueue, &pThisDev->SendLock );

	if( NULL == pListEntry )
    {
		//
		// This cannot happen
		//
		IRUSB_ASSERT( 0 );
		DEBUGMSG(DBG_ERR, (" SendPacketPreprocess failed to find a free context struct\n"));

 		InterlockedIncrement( &pThisDev->packetsSentRejected );
		status = NDIS_STATUS_RESOURCES;
        goto done;
    }

	InterlockedDecrement( &pThisDev->SendAvailableCount );
	
	pThisContext = CONTAINING_RECORD( pListEntry, IRUSB_CONTEXT, ListEntry );
	pThisContext->pPacket = pPacketToSend;
	pThisContext->ContextType = CONTEXT_NDIS_PACKET;

	//
	// Store the time the packet was handed by the protocol
	//
	KeQuerySystemTime( &pThisContext->TimeReceived );

	//
	// Queue so that the polling thread can later handle it
	//
	ExInterlockedInsertTailList(
			&pThisDev->SendBuiltQueue,
			&pThisContext->ListEntry,
			&pThisDev->SendLock
		);
	InterlockedIncrement( &pThisDev->SendBuiltCount );

done:
    DEBUGMSG(DBG_FUNC, ("-SendPacketPreprocess\n"));
    return status;
}


/*****************************************************************************
*
*  Function:   SendPreprocessedPacketSend
*
*  Synopsis:   Send a packet to the USB driver and add the sent irp and io context to
*              To the pending send queue; this queue is really just needed for possible later error cancellation
*
*
*  Arguments:  pThisDev - pointer to current ir device object
*              pContext	- pointer to the context with the packet to send
*
*  Returns:    NDIS_STATUS_PENDING - This is generally what we should
*                                    return. We will call NdisMSendComplete
*                                    when the USB driver completes the
*                                    send.
*              STATUS_UNSUCCESSFUL - The packet was invalid.
*
*              NDIS_STATUS_SUCCESS - When blocking send are employed
*
*
*****************************************************************************/
NDIS_STATUS
SendPreprocessedPacketSend(
		IN OUT PIR_DEVICE pThisDev,
		IN PVOID pContext
	)
{
    PIRP                pIrp;
    UINT                BytesToWrite;
	NDIS_STATUS			status;
    BOOLEAN             fConvertedPacket;
    ULONG				Counter;
    PURB				pUrb = NULL;
    PDEVICE_OBJECT		pUrbTargetDev;
    PIO_STACK_LOCATION	pNextStack;
	PVOID				pPacketToSend;
	PIRUSB_CONTEXT		pThisContext = pContext;
	LARGE_INTEGER		CurrentTime, TimeDifference;
	PNDIS_IRDA_PACKET_INFO	pPacketInfo;

    DEBUGMSG(DBG_FUNC, ("+SendPreprocessedPacketSend\n"));

    IRUSB_ASSERT( KeGetCurrentIrql() == PASSIVE_LEVEL );

	IRUSB_ASSERT( NULL != pThisContext );

	//
	// Stop if a halt/reset/suspend is going on
	//
	if( pThisDev->fPendingWriteClearStall || pThisDev->fPendingHalt || 
		pThisDev->fPendingReset || pThisDev->fPendingClearTotalStall || !pThisDev->fProcessing ) 
	{
        DEBUGMSG(DBG_ERR, (" SendPreprocessedPacketSend abort due to pending reset or halt\n"));
		status = NDIS_STATUS_RESET_IN_PROGRESS;

		//
		// Give the packet back to the protocol
		//
		NdisMSendComplete(
				pThisDev->hNdisAdapter,
				pThisContext->pPacket,
				status 
			);
 		InterlockedIncrement( &pThisDev->packetsSentRejected );

		//
		// Back to the available queue
		//
		ExInterlockedInsertTailList(
				&pThisDev->SendAvailableQueue,
				&pThisContext->ListEntry,
				&pThisDev->SendLock
			);
		InterlockedIncrement( &pThisDev->SendAvailableCount );
		goto done;
	}
		
	pPacketToSend = pThisContext->pPacket;
	IRUSB_ASSERT( NULL != pPacketToSend );

	//
	// Indicate that we are not receiving
	//
	InterlockedExchange( (PLONG)&pThisDev->fCurrentlyReceiving, FALSE );

	//
	// Convert the packet to an ir frame and copy into our buffer
	// and send the irp.
	//
	if( pThisDev->currentSpeed<=MAX_SIR_SPEED )
	{
		fConvertedPacket = NdisToSirPacket(
				pThisDev,
				pPacketToSend,
				(PUCHAR)pThisDev->pBuffer,
				MAX_IRDA_DATA_SIZE,
				pThisDev->pStagingBuffer,
				&BytesToWrite
			);
	}
	else if( pThisDev->currentSpeed<=MAX_MIR_SPEED )
	{
		fConvertedPacket = NdisToMirPacket(
				pThisDev,
				pPacketToSend,
				(PUCHAR)pThisDev->pBuffer,
				MAX_IRDA_DATA_SIZE,
				pThisDev->pStagingBuffer,
				&BytesToWrite
			);
	}
	else
	{
		fConvertedPacket = NdisToFirPacket(
				pThisDev,
				pPacketToSend,
				(PUCHAR)pThisDev->pBuffer,
				MAX_IRDA_DATA_SIZE,
				pThisDev->pStagingBuffer,
				&BytesToWrite
			);
	}
	
#if defined(SEND_LOGGING)
	if( pThisDev->SendFileHandle )
	{
		IO_STATUS_BLOCK IoStatusBlock;

		ZwWriteFile(
				pThisDev->SendFileHandle,
				NULL,
				NULL,
				NULL,
				&IoStatusBlock,
				pThisDev->pBuffer,
				BytesToWrite,
				(PLARGE_INTEGER)&pThisDev->SendFilePosition,
				NULL
		   );

		pThisDev->SendFilePosition += BytesToWrite;
	}
#endif

	if( (fConvertedPacket == FALSE) || (BytesToWrite > NDIS_STATUS_INVALID_PACKET) )
	{
		DEBUGMSG(DBG_ERR, (" SendPreprocessedPacketSend() NdisToIrPacket failed. Couldn't convert packet!\n"));
		status = NDIS_STATUS_INVALID_LENGTH;

		//
		// Give the packet back to the protocol
		//
		NdisMSendComplete(
				pThisDev->hNdisAdapter,
				pThisContext->pPacket,
				status 
			);
 		InterlockedIncrement( &pThisDev->packetsSentInvalid );

		//
		// Back to the available queue
		//
		ExInterlockedInsertTailList(
				&pThisDev->SendAvailableQueue,
				&pThisContext->ListEntry,
				&pThisDev->SendLock
			);
		InterlockedIncrement( &pThisDev->SendAvailableCount );
		goto done;
	}

	//
	// Save the effective length
	//
	pThisDev->BufLen = BytesToWrite;
#if !defined(ONLY_ERROR_MESSAGES)
	DEBUGMSG(DBG_ERR, (" SendPreprocessedPacketSend() NdisToIrPacket success BytesToWrite = dec %d, \n", BytesToWrite));
#endif
	
	//
	// Verify the FIFO condition and possibly make sure we don't overflow
	//
	pThisDev->SendFifoCount += BytesToWrite;
	if( pThisDev->SendFifoCount >= (3*STIR4200_FIFO_SIZE/2) )
	{
		DEBUGMSG(DBG_ERR, (" SendPreprocessedPacketSend() Completing, size: %d\n", pThisDev->SendFifoCount));
		SendWaitCompletion( pThisDev );
		pThisDev->SendFifoCount = BytesToWrite;
	}

	//
	// Enforce turnaround time
	//
	pPacketInfo = GetPacketInfo( pPacketToSend );
    if (pPacketInfo != NULL) 
	{
#if DBG
		//
		// See if we get a packet with 0 turnaround time specified
		// when we think we need need a turnaround time 
		//
		if( pPacketInfo->MinTurnAroundTime > 0 ) 
		{
			pThisDev->NumPacketsSentRequiringTurnaroundTime++;
		} 
		else 
		{
			pThisDev->NumPacketsSentNotRequiringTurnaroundTime++;
		}
#endif

		//
		// Deal with turnaroud time
		//
		KeQuerySystemTime( &CurrentTime );
		TimeDifference = RtlLargeIntegerSubtract( CurrentTime, pThisContext->TimeReceived );
		if( (ULONG)(TimeDifference.QuadPart/10) < pPacketInfo->MinTurnAroundTime )
		{
			ULONG TimeToWait = pPacketInfo->MinTurnAroundTime - (ULONG)(TimeDifference.QuadPart/10);

			//
			// Potential hack...
			//
#if !defined(WORKAROUND_CASIO)
			if( TimeToWait > 1000 )
#endif
			{
#if !defined(ONLY_ERROR_MESSAGES)
				DEBUGMSG(DBG_ERR, (" SendPreprocessedPacketSend() Enforcing turnaround time %d\n", TimeToWait));
#endif
				NdisMSleep( TimeToWait );
			}
		}
	}
	else 
	{
        //
        //  irda protocol is broken
        //
   		DEBUGMSG(DBG_ERR, (" SendPreprocessedPacketSend() pPacketInfo == NULL\n"));
    }

	//
	// MS Security recommendation - allocate a new urb.
	//
	pThisContext->UrbLen = sizeof( struct _URB_BULK_OR_INTERRUPT_TRANSFER );
	pThisContext->pUrb = MyUrbAlloc(pThisContext->UrbLen);
	if (pThisContext->pUrb == NULL)
	{
        DEBUGMSG(DBG_ERR, (" SendPreprocessedPacketSend abort due to urb alloc failure\n"));
		goto done;
	}
	pUrb = pThisContext->pUrb;

	//
    // Now that we have created the urb, we will send a
    // request to the USB device object.
    //
    pUrbTargetDev = pThisDev->pUsbDevObj;

	//
	// make an irp sending to usbhub
	//
	pIrp = IoAllocateIrp( (CCHAR)(pThisDev->pUsbDevObj->StackSize + 1), FALSE );

    if( NULL == pIrp )
    {
        DEBUGMSG(DBG_ERR, (" SendPreprocessedPacketSend failed to alloc IRP\n"));
        status = NDIS_STATUS_FAILURE;

		//
		// Give the packet back to the protocol
		//
		NdisMSendComplete(
				pThisDev->hNdisAdapter,
				pThisContext->pPacket,
				status 
			);
        InterlockedIncrement( (PLONG)&pThisDev->packetsSentDropped );

		//
		// Back to the available queue
		//
 		MyUrbFree(pThisContext->pUrb, pThisContext->UrbLen);
		pThisContext->pUrb = NULL;
		ExInterlockedInsertTailList(
				&pThisDev->SendAvailableQueue,
				&pThisContext->ListEntry,
				&pThisDev->SendLock
			);
		InterlockedIncrement( &pThisDev->SendAvailableCount );
        goto done;
    }

    pIrp->IoStatus.Status = STATUS_PENDING;
    pIrp->IoStatus.Information = 0;

	pThisContext->pIrp = pIrp;

	//
	// Build our URB for USBD
	//
    pUrb->UrbBulkOrInterruptTransfer.Hdr.Length = (USHORT)sizeof( struct _URB_BULK_OR_INTERRUPT_TRANSFER );
    pUrb->UrbBulkOrInterruptTransfer.Hdr.Function = URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER;
    pUrb->UrbBulkOrInterruptTransfer.PipeHandle = pThisDev->BulkOutPipeHandle;
    pUrb->UrbBulkOrInterruptTransfer.TransferFlags = USBD_TRANSFER_DIRECTION_OUT ;
    // short packet is not treated as an error.
    pUrb->UrbBulkOrInterruptTransfer.TransferFlags |= USBD_SHORT_TRANSFER_OK;
    pUrb->UrbBulkOrInterruptTransfer.UrbLink = NULL;
    pUrb->UrbBulkOrInterruptTransfer.TransferBufferMDL = NULL;
    pUrb->UrbBulkOrInterruptTransfer.TransferBuffer = pThisDev->pBuffer;
    pUrb->UrbBulkOrInterruptTransfer.TransferBufferLength = (int)BytesToWrite;

    //
    // Call the class driver to perform the operation.
	//
    pNextStack = IoGetNextIrpStackLocation( pIrp );

    IRUSB_ASSERT( pNextStack != NULL );

    //
    // pass the URB to the USB driver stack
    //
	pNextStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
	pNextStack->Parameters.Others.Argument1 = pUrb;
	pNextStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_INTERNAL_USB_SUBMIT_URB;
	
    IoSetCompletionRoutine(
			pIrp,							// irp to use
			SendCompletePacketSend,			// routine to call when irp is done
			DEV_TO_CONTEXT(pThisContext),	// context to pass routine
			TRUE,							// call on success
			TRUE,							// call on error
			TRUE							// call on cancel
		);

#ifdef SERIALIZE
	KeClearEvent( &pThisDev->EventSyncUrb );
#endif
	
	//
    // Call IoCallDriver to send the irp to the usb port.
    //
	ExInterlockedInsertTailList(
			&pThisDev->SendPendingQueue,
			&pThisContext->ListEntry,
			&pThisDev->SendLock
		);
	InterlockedIncrement( &pThisDev->SendPendingCount );
	status = MyIoCallDriver( pThisDev, pUrbTargetDev, pIrp );

    //
    // The USB driver should always return STATUS_PENDING when
    // it receives a write irp
    //
    IRUSB_ASSERT( status == STATUS_PENDING );

	status = MyKeWaitForSingleObject( pThisDev, &pThisDev->EventSyncUrb, 0 );

	if( status == STATUS_TIMEOUT ) 
	{
		KIRQL OldIrql;

		DEBUGMSG( DBG_ERR,(" SendPreprocessedPacketSend() TIMED OUT! return from IoCallDriver USBD %x\n", status));
		KeAcquireSpinLock( &pThisDev->SendLock, &OldIrql );
		RemoveEntryList( &pThisContext->ListEntry );
		KeReleaseSpinLock( &pThisDev->SendLock, OldIrql );
		InterlockedDecrement( &pThisDev->SendPendingCount );
		// MS Security recommendation - cannot cancel IRP.
	}

done:
    DEBUGMSG(DBG_FUNC, ("-SendPreprocessedPacketSend\n"));
    return status;
}


/*****************************************************************************
*
*  Function:	SendWaitCompletion
*
*  Synopsis:	Waits for a send operation to be completed. A send is completed when the
*				entire frame has been transmitted ove the IR medium
*
*  Arguments:	pThisDev - pointer to current ir device object
*
*  Returns:		NT status code
*
*****************************************************************************/
NTSTATUS
SendWaitCompletion(
		IN OUT PIR_DEVICE pThisDev
	)
{
	NTSTATUS Status;
	LARGE_INTEGER CurrentTime, InitialTime;
	ULONG FifoCount, OldFifoCount = STIR4200_FIFO_SIZE;

	DEBUGMSG(DBG_ERR, (" SendWaitCompletion\n"));

	//
	// At low speed we simply force to wait
	//
	if( (pThisDev->currentSpeed <= MAX_MIR_SPEED) || (pThisDev->ChipRevision >= CHIP_REVISION_7) )
	{
		//
		// We force to wait until the end of transmit
		//
		KeQuerySystemTime( &InitialTime );
		while( TRUE )
		{
			//
			// Read the status register and check
			//
			if( (Status = St4200ReadRegisters( pThisDev, STIR4200_STATUS_REG, 3 )) == STATUS_SUCCESS )
			{
				//
				// bit set means still in transmit mode...
				//
				if( pThisDev->StIrTranceiver.StatusReg & STIR4200_STAT_FFDIR )     
				{
					KeQuerySystemTime( &CurrentTime );
					FifoCount = 
						((ULONG)MAKEUSHORT(pThisDev->StIrTranceiver.FifoCntLsbReg, pThisDev->StIrTranceiver.FifoCntMsbReg));
					if( ((CurrentTime.QuadPart-InitialTime.QuadPart) > (IRUSB_100ns_PER_ms*STIR4200_SEND_TIMEOUT) ) ||
						(FifoCount > OldFifoCount) )
					{
						//
						// The part received something while in transmit mode, so it hosed
						//
						pThisDev->PreFifoCount = 0;
						St4200DoubleResetFifo( pThisDev );
						break;
					}
					OldFifoCount = FifoCount;
				}
				else
				{
					pThisDev->PreFifoCount = 
						((ULONG)MAKEUSHORT(pThisDev->StIrTranceiver.FifoCntLsbReg, pThisDev->StIrTranceiver.FifoCntMsbReg));
					break;
				}
			}
			else break;
		}
	}
	//
	// In high speed we try to be smarter
	//
	else
	{
		if( (Status = St4200ReadRegisters( pThisDev, STIR4200_STATUS_REG, 3 )) == STATUS_SUCCESS )
		{
			//
			// bit set means still in transmit mode...
			//
			if( pThisDev->StIrTranceiver.StatusReg & STIR4200_STAT_FFDIR )     
			{
				ULONG Count;

				Count = ((ULONG)MAKEUSHORT(pThisDev->StIrTranceiver.FifoCntLsbReg, pThisDev->StIrTranceiver.FifoCntMsbReg));
				// MS Security bug #540780 - use NdisMSleep instead of NdisStallExecution
				NdisMSleep( (STIR4200_WRITE_DELAY*Count)/MAX_TOTAL_SIZE_WITH_ALL_HEADERS );
				pThisDev->PreFifoCount = 0;
			}
			else
			{
				pThisDev->PreFifoCount = 
					((ULONG)MAKEUSHORT(pThisDev->StIrTranceiver.FifoCntLsbReg, pThisDev->StIrTranceiver.FifoCntMsbReg));
			}
		}
	}

	pThisDev->SendFifoCount = 0;
	return Status;
}


/*****************************************************************************
*
*  Function:	SendCheckForOverflow
*
*  Synopsis:	Makes sure we are not going to overflow the TX FIFO
*
*  Arguments:	pThisDev - pointer to current ir device object
*
*  Returns:		NT status code
*
*****************************************************************************/
NTSTATUS
SendCheckForOverflow(
		IN OUT PIR_DEVICE pThisDev
	)
{
	NTSTATUS	Status = STATUS_SUCCESS;

	//
	// Check what we think we have in the FIFO
	//
	if( pThisDev->SendFifoCount > STIR4200_FIFO_SIZE )
	{
		//
		// Always one initial read
		//
		if( (Status = St4200ReadRegisters( pThisDev, STIR4200_FIFOCNT_LSB_REG, 2 )) == STATUS_SUCCESS )
		{
			pThisDev->SendFifoCount =
				(ULONG)MAKEUSHORT(pThisDev->StIrTranceiver.FifoCntLsbReg, pThisDev->StIrTranceiver.FifoCntMsbReg);
#if !defined(ONLY_ERROR_MESSAGES)
			DEBUGMSG( DBG_ERR,(" SendCheckForOverflow() Count: %d\n", pThisDev->SendFifoCount));
#endif
		}
		else goto done;

		//
		// Force reads to get the real count, until condition is satisfied
		//
		while( pThisDev->SendFifoCount > (3*STIR4200_FIFO_SIZE/4) )
		{
			if( (Status = St4200ReadRegisters( pThisDev, STIR4200_FIFOCNT_LSB_REG, 2 )) == STATUS_SUCCESS )
			{
				pThisDev->SendFifoCount =
					(ULONG)MAKEUSHORT(pThisDev->StIrTranceiver.FifoCntLsbReg, pThisDev->StIrTranceiver.FifoCntMsbReg);
#if !defined(ONLY_ERROR_MESSAGES)
				DEBUGMSG( DBG_ERR,(" SendCheckForOverflow() Count: %d\n", pThisDev->SendFifoCount));
#endif
			}
			else goto done;
		}
	}

done:
	return Status;
}


/*****************************************************************************
*
*  Function:   SendCompletePacketSend
*
*  Synopsis:   Completes USB write operation
*
*  Arguments:  pUsbDevObj - pointer to the USB device object which
*                           completed the irp
*              pIrp       - the irp which was completed by the
*                           device object
*              Context    - the context given to IoSetCompletionRoutine
*                           before calling IoCallDriver on the irp
*                           The Context is a pointer to the ir device object.
*
*  Returns:    STATUS_MORE_PROCESSING_REQUIRED - allows the completion routine
*              (IofCompleteRequest) to stop working on the irp.
*
*****************************************************************************/
NTSTATUS
SendCompletePacketSend(
		IN PDEVICE_OBJECT pUsbDevObj,
		IN PIRP           pIrp,
		IN PVOID          Context
	)
{
    PIR_DEVICE          pThisDev;
    PVOID               pThisContextPacket;
    NTSTATUS            status;
	PIRUSB_CONTEXT		pThisContext = (PIRUSB_CONTEXT)Context;
	PIRP				pContextIrp;
	PURB                pContextUrb;
	ULONG				BufLen;
	ULONG				BytesTransfered;
	PLIST_ENTRY			pListEntry;

    DEBUGMSG(DBG_FUNC, ("+SendCompletePacketSend\n"));

    //
    // The context given to IoSetCompletionRoutine is an IRUSB_CONTEXT struct
    //
	IRUSB_ASSERT( NULL != pThisContext );				// we better have a non NULL buffer

    pThisDev = pThisContext->pThisDev;

	IRUSB_ASSERT( NULL != pThisDev );	

	pContextIrp = pThisContext->pIrp;
	pContextUrb = pThisContext->pUrb;
	BufLen = pThisDev->BufLen;

	pThisContextPacket = pThisContext->pPacket; //save ptr to packet to access after context freed

	//
	// Perform various IRP, URB, and buffer 'sanity checks'
	//
    IRUSB_ASSERT( pContextIrp == pIrp );				// check we're not a bogus IRP
	IRUSB_ASSERT( pContextUrb != NULL );

    status = pIrp->IoStatus.Status;

	//
	// we should have failed, succeeded, or cancelled, but NOT be pending
	//
	IRUSB_ASSERT( STATUS_PENDING != status );

	//
	// Remove from the pending queue (only if NOT cancelled)
	//
	if( status != STATUS_CANCELLED )
	{
		KIRQL OldIrql;

		KeAcquireSpinLock( &pThisDev->SendLock, &OldIrql );
		RemoveEntryList( &pThisContext->ListEntry );
		KeReleaseSpinLock( &pThisDev->SendLock, OldIrql );
		InterlockedDecrement( &pThisDev->SendPendingCount );
	}

    //
    // IoCallDriver has been called on this Irp;
    // Set the length based on the TransferBufferLength
    // value in the URB
    //
    pIrp->IoStatus.Information = pContextUrb->UrbBulkOrInterruptTransfer.TransferBufferLength;

	BytesTransfered = (ULONG)pIrp->IoStatus.Information; // save for below need-termination test

#if DBG
	if( STATUS_SUCCESS == status ) 
	{
		IRUSB_ASSERT( pIrp->IoStatus.Information == BufLen );
	}
#endif

    DEBUGMSG(DBG_OUT, (" SendCompletePacketSend  pIrp->IoStatus.Status = 0x%x\n", status));
    DEBUGMSG(DBG_OUT, (" SendCompletePacketSend  pIrp->IoStatus.Information = 0x%x, dec %d\n", pIrp->IoStatus.Information,pIrp->IoStatus.Information));

    //
    // Keep statistics.
    //
    if( status == STATUS_SUCCESS )
    {
#if DBG
		ULONG total = pThisDev->TotalBytesSent + BytesTransfered;
		InterlockedExchange( (PLONG)&pThisDev->TotalBytesSent, (LONG)total );
#endif
	    InterlockedIncrement( (PLONG)&pThisDev->packetsSent );
        DEBUGMSG(DBG_OUT, (" SendCompletePacketSend Sent a packet, packets sent = dec %d\n",pThisDev->packetsSent));
    }
    else
    {
        InterlockedIncrement( (PLONG)&pThisDev->NumDataErrors );
        InterlockedIncrement( (PLONG)&pThisDev->packetsSentDropped );
        DEBUGMSG(DBG_ERR, (" SendCompletePacketSend DROPPED a packet, packets dropped = dec %d\n",pThisDev->packetsSentDropped));
    }

    //
    // Free the IRP.
    //
    IoFreeIrp( pIrp );
	InterlockedIncrement( (PLONG)&pThisDev->NumWrites );

	// Free the URB.
	MyUrbFree(pThisContext->pUrb, pThisContext->UrbLen);
	pThisContext->pUrb = NULL;

	//
	// Indicate to the protocol the status of the sent packet and return
	// ownership of the packet.
	//
	NdisMSendComplete(
			pThisDev->hNdisAdapter,
			pThisContextPacket,
			status 
		);

	//
	// Enqueue the completed packet
	//
	ExInterlockedInsertTailList(
			&pThisDev->SendAvailableQueue,
			&pThisContext->ListEntry,
			&pThisDev->SendLock
		);
	InterlockedIncrement( &pThisDev->SendAvailableCount );

	IrUsb_DecIoCount( pThisDev ); // we will track count of pending irps

	if( ( STATUS_SUCCESS != status )  && ( STATUS_CANCELLED != status ) ) 
	{
		if( !pThisDev->fPendingWriteClearStall && !pThisDev->fPendingClearTotalStall && 
			!pThisDev->fPendingHalt && !pThisDev->fPendingReset && pThisDev->fProcessing )
		{
			DEBUGMSG(DBG_ERR, (" SendCompletePacketSend error, will schedule a clear stall via URB_FUNCTION_RESET_PIPE (OUT)\n"));
			InterlockedExchange( (PLONG)&pThisDev->fPendingWriteClearStall, TRUE );
			ScheduleWorkItem( pThisDev,	ResetPipeCallback, pThisDev->BulkOutPipeHandle, 0 );
		}
	}

#ifdef SERIALIZE
	KeSetEvent( &pThisDev->EventSyncUrb, 0, FALSE );  //signal we're done
#endif
    DEBUGMSG(DBG_FUNC, ("-SendCompletePacketSend\n"));
    return STATUS_MORE_PROCESSING_REQUIRED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\net\irda\sigmatel\sys\version.h ===
// version.h

#define	CHIP_VER	9		// 1=4200, 2=4115, 8=4200diag, 9=4115diag
#define BUILD_VER	27
#define CUST_VER1	0		// 1=casio
#define CUST_VER2	0

#define REL_VER		"9, 27, 0, 0\0"

// must end in blank line
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\net\irda\via\inf\makefile.inc ===
!IFNDEF LANGUAGE
LANGUAGE=usa
!ENDIF

_LNG=$(LANGUAGE)
_INX=.
STAMP=stampinf -f  $@ -d 04/30/2001 -v 5.1.2480.0

$(O)\viafir2k.inf: $(_INX)\viafir2k.inx
    copy $(_INX)\$(@B).inx $@
    $(STAMP)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\net\irda\sigmatel\sys\stir4200.h ===
/**************************************************************************************************************************
 *  STIR4200.H - SigmaTel STIr4200 hardware (register) specific definitions
 **************************************************************************************************************************
 *  (C) Unpublished Copyright of Sigmatel, Inc. All Rights Reserved.
 *
 *
 *		Created: 04/06/2000 
 *			Version 0.9
 *		Edited: 04/27/2000 
 *			Version 0.92
 *		Edited: 05/03/2000 
 *			Version 0.93
 *		Edited: 05/12/2000 
 *			Version 0.94
 *		Edited: 05/19/2000 
 *			Version 0.95
 *		Edited: 06/29/2000 
 *			Version 0.97
 *		Edited: 08/22/2000 
 *			Version 1.02
 *		Edited: 09/16/2000 
 *			Version 1.03
 *		Edited: 09/25/2000 
 *			Version 1.10
 *		Edited: 11/10/2000 
 *			Version 1.12
 *		Edited: 12/29/2000 
 *			Version 1.13
 *		Edited: 01/16/2001 
 *			Version 1.14
 *	
 *
 **************************************************************************************************************************/

#ifndef __STIR4200_H__
#define __STIR4200_H__


#define STIR4200_FIFO_SIZE          4096

//
// Some useful macros
//
#define MAKEUSHORT(lo, hi)  ((unsigned short)(((unsigned char)(lo)) | ((unsigned short)((unsigned char)(hi))) << 8))
#define MAKEULONG(lo, hi)   ((unsigned long)(((unsigned short)(lo)) | ((unsigned long)((unsigned short)(hi))) << 16))
#ifndef LOWORD
	#define LOWORD(l)           ((unsigned short)(l))
#endif
#ifndef HIWORD
	#define HIWORD(l)           ((unsigned short)(((unsigned long)(l) >> 16) & 0xFFFF))
#endif
#ifndef LOBYTE
	#define LOBYTE(w)           ((unsigned char)(w))
#endif
#ifndef HIBYTE
	#define HIBYTE(w)           ((unsigned char)(((unsigned short)(w) >> 8) & 0xFF))
#endif


/**************************************************************************************************************************/
/*   STIr4200 Tranceiver Hardware Model Definitions                                                                                 */
/**************************************************************************************************************************/
typedef struct _STIR4200_TRANCEIVER
{
    UCHAR       FifoDataReg;
	UCHAR		ModeReg;
	UCHAR		BaudrateReg;
	UCHAR		ControlReg;
	UCHAR		SensitivityReg;
    UCHAR       StatusReg;
	UCHAR		FifoCntLsbReg;
	UCHAR		FifoCntMsbReg;
	UCHAR		DpllTuneReg;
	UCHAR		IrdigSetupReg;
	UCHAR		Reserved1Reg;
	UCHAR		Reserved2Reg;
	UCHAR		Reserved3Reg;
	UCHAR		Reserved4Reg;
	UCHAR		Reserved5Reg;
	UCHAR		TestReg;
} STIR4200_TRANCEIVER, *PSTIR4200_TRANCEIVER;

/**************************************************************************************************************************/
/*   STIr4200 Receiver State                                                                                 */
/**************************************************************************************************************************/
typedef enum
{
    STATE_INIT = 0,
    STATE_GOT_FIR_BOF,
    STATE_GOT_BOF,
    STATE_ACCEPTING,
    STATE_ESC_SEQUENCE,
    STATE_SAW_FIR_BOF,
    STATE_SAW_EOF,
    STATE_CLEANUP
} PORT_RCV_STATE;

#define STATE_GOT_MIR_BOF STATE_GOT_FIR_BOF
#define STATE_SAW_MIR_BOF STATE_SAW_FIR_BOF

/**************************************************************************************************************************/
/*   Register Offsets                                                                                                     */
/**************************************************************************************************************************/
#define STIR4200_FIFO_DATA_REG              0
#define STIR4200_MODE_REG                   1
#define STIR4200_BAUDRATE_REG               2
#define STIR4200_CONTROL_REG                3
#define STIR4200_SENSITIVITY_REG            4
#define STIR4200_STATUS_REG                 5
#define STIR4200_FIFOCNT_LSB_REG            6
#define STIR4200_FIFOCNT_MSB_REG            7
#define STIR4200_DPLLTUNE_REG               8
#define STIR4200_IRDIG_SETUP_REG            9
#define STIR4200_RESERVE1_REG               10
#define STIR4200_RESERVE2_REG               11
#define STIR4200_RESERVE3_REG               12
#define STIR4200_RESERVE4_REG               13
#define STIR4200_RESERVE5_REG               14
#define STIR4200_TEST_REG                   15
#define STIR4200_MAX_REG                    STIR4200_TEST_REG


/**************************************************************************************************************************/
/*   Register Bit Definitions                                                                                             */
/**************************************************************************************************************************/
#define STIR4200_MODE_PDLCK8	            0x01
#define STIR4200_MODE_RESET_OFF             0x02
#define STIR4200_MODE_AUTO_RESET            0x04
#define STIR4200_MODE_BULKIN_FIX            0x08
#define STIR4200_MODE_FIR                   0x80
#define STIR4200_MODE_MIR                   0x40
#define STIR4200_MODE_SIR                   0x20
#define STIR4200_MODE_ASK                   0x10
#define STIR4200_MODE_MASK                  (STIR4200_MODE_FIR | STIR4200_MODE_MIR | STIR4200_MODE_SIR | STIR4200_MODE_ASK)

#define STIR4200_CTRL_SDMODE                0x80
#define STIR4200_CTRL_RXSLOW                0x40
#define STIR4200_CTRL_DLOOP1                0x20
#define STIR4200_CTRL_TXPWD                 0x10
#define STIR4200_CTRL_RXPWD                 0x08
#define STIR4200_CTRL_SRESET                0x01

#define STIR4200_SENS_IDMASK                0x07
#define STIR4200_SENS_SPWIDTH               0x08
#define STIR4200_SENS_BSTUFF                0x10
#define STIR4200_SENS_RXDSNS_DEFAULT        0x20
#define STIR4200_SENS_RXDSNS_4012_SIR_9600	0x20
#define STIR4200_SENS_RXDSNS_4012_SIR		0x00
#define STIR4200_SENS_RXDSNS_4012_FIR		0x20
#define STIR4200_SENS_RXDSNS_INFI_SIR		0x07
#define STIR4200_SENS_RXDSNS_INFI_FIR		0x07
#define STIR4200_SENS_RXDSNS_HP_SIR			0x07
#define STIR4200_SENS_RXDSNS_HP_FIR			0x07
#define STIR4200_SENS_RXDSNS_VISHAY_6102F_FIR	0x07
#define STIR4200_SENS_RXDSNS_VISHAY_6102F_SIR	0x07
#define STIR4200_SENS_RXDSNS_CUSTOM_SIR_9600	0x20
#define STIR4200_SENS_RXDSNS_CUSTOM_SIR		0x00
#define STIR4200_SENS_RXDSNS_CUSTOM_FIR		0x20

#define STIR4200_STAT_EOFRAME               0x80
#define STIR4200_STAT_FFUNDER               0x40
#define STIR4200_STAT_FFOVER                0x20
#define STIR4200_STAT_FFDIR                 0x10
#define STIR4200_STAT_FFCLR                 0x08
#define STIR4200_STAT_FFEMPTY               0x04
#define STIR4200_STAT_FFRXERR               0x02
#define STIR4200_STAT_FFTXERR               0x01

#define STIR4200_DPLL_DESIRED_4012			0x05
#define STIR4200_DPLL_DESIRED_4012_SIR		0x06
#define STIR4200_DPLL_DESIRED_4012_FIR		0x05
#define STIR4200_DPLL_DESIRED_4000			0x15
#define STIR4200_DPLL_DESIRED_VISHAY		0x15
#define STIR4200_DPLL_DESIRED_INFI			0x06
#define STIR4200_DPLL_DESIRED_HP			0x06
#define STIR4200_DPLL_DESIRED_VISHAY_6102F	0x04
#define STIR4200_DPLL_DEFAULT				0x52
#define STIR4200_DPLL_DESIRED_CUSTOM		0x05
#define STIR4200_DPLL_DESIRED_CUSTOM_SIR	0x06
#define STIR4200_DPLL_DESIRED_CUSTOM_FIR	0x05

#define STIR4200_TEST_EN_OSC_SUSPEND		0x10

/**************************************************************************************************************************/
/*   Vendor Specific Device Requests                                                                                      */
/**************************************************************************************************************************/
#define STIR4200_WRITE_REGS_REQ             0
#define STIR4200_READ_REGS_REQ              1
#define STIR4200_READ_ROM_REQ               2
#define STIR4200_WRITE_REG_REQ              3
#define STIR4200_CLEAR_STALL_REQ            1


/**************************************************************************************************************************/
/*   STIr4200 Frame Header ID Definitions                                                                                 */
/**************************************************************************************************************************/
#define STIR4200_HEADERID_BYTE1             0x55
#define STIR4200_HEADERID_BYTE2             0xAA

typedef struct _STIR4200_FRAME_HEADER
{
    UCHAR       id1;                // header id byte 1
    UCHAR       id2;                // header id byte 2
    UCHAR       sizlsb;             // frame size LSB
    UCHAR       sizmsb;             // frame size MSB
} STIR4200_FRAME_HEADER, *PSTIR4200_FRAME_HEADER;

/**************************************************************************************************************************/
/*   STIr4200 Frame Definitions                                                                                           */
/**************************************************************************************************************************/
#define STIR4200_FIR_PREAMBLE               0x7f
#define STIR4200_FIR_PREAMBLE_SIZ           16
#define STIR4200_FIR_BOF                    0x7E
#define STIR4200_FIR_EOF                    0x7E
#define STIR4200_FIR_BOF_SIZ                2
#define STIR4200_FIR_EOF_SIZ                2
#define STIR4200_FIR_ESC_CHAR               0x7d
#define STIR4200_FIR_ESC_DATA_7D            0x5d
#define STIR4200_FIR_ESC_DATA_7E            0x5e
#define STIR4200_FIR_ESC_DATA_7F            0x5f

#define STIR4200_MIR_BOF                    0x7E
#define STIR4200_MIR_EOF                    0x7E
#define STIR4200_MIR_BOF_SIZ                2
#define STIR4200_MIR_EOF_SIZ                2
#define STIR4200_MIR_ESC_CHAR               0x7d
#define STIR4200_MIR_ESC_DATA_7D            0x5d
#define STIR4200_MIR_ESC_DATA_7E            0x5e

//
// A few workaroud definitions
//
#define STIR4200_READ_DELAY					3000
#define STIR4200_MULTIPLE_READ_DELAY		2500
#define STIR4200_DELTA_DELAY				250
#define STIR4200_MAX_BOOST_DELAY			1000
#define STIR4200_MULTIPLE_READ_THREHOLD		2048
#define STIR4200_WRITE_DELAY				2000
#define STIR4200_ESC_PACKET_SIZE			3072
#define STIR4200_SMALL_PACKET_MAX_SIZE		32
#define STIR4200_LARGE_PACKET_MIN_SIZE		1024
#define STIR4200_ACK_WINDOW					20
#define	STIR4200_FIFO_OVERRUN_THRESHOLD		100
#define	STIR4200_SEND_TIMEOUT				2000

/**************************************************************************************************************************/
/*   Prototypes of functions that access the hardware                                                                                           */
/**************************************************************************************************************************/

NTSTATUS        
St4200ResetFifo( 
		IN PVOID pDevice
	);

NTSTATUS        
St4200DoubleResetFifo( 
		IN PVOID pDevice
	);

NTSTATUS        
St4200SoftReset( 
		IN PVOID pDevice
	);

NTSTATUS        
St4200SetSpeed( 
		IN OUT PVOID pDevice
	);

NTSTATUS        
St4200SetIrMode( 
		IN OUT PVOID pDevice,
		ULONG mode 
	);

NTSTATUS        
St4200GetFifoCount( 
		IN PVOID pDevice,
		OUT PULONG pCountFifo
	);

NTSTATUS        
St4200TuneDpllAndSensitivity(
		IN OUT PVOID pDevice,
		ULONG Speed
	);

NTSTATUS        
St4200TurnOffReceiver(
		IN OUT PVOID pDevice
	);

NTSTATUS        
St4200TurnOnReceiver(
		IN OUT PVOID pDevice
	);

NTSTATUS        
St4200EnableOscillatorPowerDown(
		IN OUT PVOID pDevice
	);

NTSTATUS        
St4200TurnOnSuspend(
		IN OUT PVOID pDevice
	);

NTSTATUS        
St4200TurnOffSuspend(
		IN OUT PVOID pDevice
	);

NTSTATUS        
St4200WriteMultipleRegisters(
		IN PVOID pDevice,
		UCHAR FirstRegister, 
		UCHAR RegistersToWrite
	);

NTSTATUS        
St4200WriteRegister(
		IN PVOID pDevice,
		UCHAR RegisterToWrite
	);

NTSTATUS
St4200ReadRegisters(
		IN OUT PVOID pDevice,
		UCHAR FirstRegister, 
		UCHAR RegistersToRead
	);

NTSTATUS        
St4200FakeSend(
		IN PVOID pDevice,
		PUCHAR pData,
		ULONG DataSize
	);

NTSTATUS        
St4200FakeReceive(
		IN PVOID pDevice,
		PUCHAR pData,
		ULONG DataSize
	);

NTSTATUS
St4200CompleteReadWriteRequest(
		IN PDEVICE_OBJECT pUsbDevObj,
		IN PIRP           pIrp,
		IN PVOID          Context
	);

/**************************************************************************************************************************/

#endif      // __STIR4200_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\net\irda\sigmatel\sys\rwir.c ===
/**************************************************************************************************************************
 *  RWIR.C SigmaTel STIR4200 USB, but not NDIS, module
 **************************************************************************************************************************
 *  (C) Unpublished Copyright of Sigmatel, Inc. All Rights Reserved.
 *
 *
 *		Created: 04/06/2000 
 *			Version 0.9
 *		Edited: 04/24/2000 
 *			Version 0.91
 *		Edited: 04/27/2000 
 *			Version 0.92
 *		Edited: 05/01/2000 
 *			Version 0.93
 *		Edited: 05/12/2000 
 *			Version 0.94
 *		Edited: 05/19/2000 
 *			Version 0.95
 *		Edited: 05/24/2000 
 *			Version 0.96
 *		Edited: 08/22/2000 
 *			Version 1.02
 *		Edited: 09/25/2000 
 *			Version 1.10
 *		Edited: 11/09/2000 
 *			Version 1.12
 *	
 *
 **************************************************************************************************************************/

#include <ndis.h>
#include <ntdef.h>
#include <windef.h>
#include <conio.h>
#include <stdio.h>

#include "usbdi.h"
#include "usbdlib.h"

#include "debug.h"

#include "ircommon.h"
#include "irusb.h"
#include "diags.h"

//
// Local function prototypes.
//
NTSTATUS
ReadCustomerData(
		IN OUT PIR_DEVICE pThisDev
	);

/*****************************************************************************
*
*  Function:	InitializeProcessing
*
*  Synopsis:	Initialize the driver processing (sending and receiving packets) functionality.
*
*  Arguments:	pThisDevice - pointer to current ir device object
*				InitPassiveThread - whether we must initialize the passive thread
*	
*  Returns:		NDIS_STATUS_SUCCESS   - if irp is successfully sent to USB
*                                       device object
*				NDIS_STATUS_RESOURCES - if mem can't be alloc'd
*				NDIS_STATUS_FAILURE   - otherwise
*
*  Notes:
*
*  This routine must be called in IRQL PASSIVE_LEVEL.
*
*****************************************************************************/
NTSTATUS
InitializeProcessing(
        IN OUT PIR_DEVICE pThisDev,
		IN BOOLEAN InitPassiveThread
	)
{
    NTSTATUS status = STATUS_SUCCESS;

    DEBUGMSG(DBG_FUNC, ("+InitializeProcessing\n"));

	if( InitPassiveThread )
	{
		//
		// Create a thread to run at IRQL PASSIVE_LEVEL.
		//
		status = PsCreateSystemThread(
				&pThisDev->hPassiveThread,
				(ACCESS_MASK)0L,
				NULL,
				NULL,
				NULL,
				PassiveLevelThread,
				pThisDev
			);

		if( status != STATUS_SUCCESS )
		{
			DEBUGMSG(DBG_ERROR, (" PsCreateSystemThread PassiveLevelThread failed. Returned 0x%.8x\n", status));
			status = STATUS_INSUFFICIENT_RESOURCES;
			goto done;
		}
	}

    //
    // Create a thread to run at IRQL PASSIVE_LEVEL to be always receiving.
    //
    status = PsCreateSystemThread(
			&pThisDev->hPollingThread,
			(ACCESS_MASK)0L,
			NULL,
			NULL,
			NULL,
			PollingThread,
			pThisDev
		);

	if( status != STATUS_SUCCESS )
    {
        DEBUGMSG(DBG_ERROR, (" PsCreateSystemThread PollingThread failed. Returned 0x%.8x\n", status));
		status = STATUS_INSUFFICIENT_RESOURCES;
		goto done;
    }

    pThisDev->fProcessing = TRUE;

done:
    DEBUGMSG(DBG_FUNC, ("-InitializeProcessing\n"));
    return status;
}


/*****************************************************************************
*
*  Function:	ScheduleWorkItem
*
*  Synopsis:	Preapares a work item in such a way that the passive thread can process it
*
*  Arguments:	pThisDev - pointer to IR device
*				Callback - function to call
*				pInfoBuf - context for the call
*				InfoBufLen - length of the context
*
*  Returns:		TRUE if successful
*				FALSE otherwise
*
*  Notes:
*
*****************************************************************************/
BOOLEAN
ScheduleWorkItem(
		IN OUT PIR_DEVICE pThisDev,
		WORK_PROC Callback,
		IN PVOID pInfoBuf,
		ULONG InfoBufLen
	)
{
	int				i;
	PIR_WORK_ITEM	pWorkItem = NULL;
	BOOLEAN			ItemScheduled = FALSE;

    DEBUGMSG(DBG_FUNC, ("+ScheduleWorkItem\n"));

    //
	// Find an item that is available
	//
	for( i = 0; i < NUM_WORK_ITEMS; i++ )
	{
		pWorkItem = &(pThisDev->WorkItems[i]);

		//
		// MS Security bug #554702
		//
		if( InterlockedCompareExchange( (PLONG)&pWorkItem->fInUse, TRUE, FALSE ) == FALSE ) 
		{
			ItemScheduled = TRUE;
			break;
		}
	}

	//
	// Can't fail because can only have one set and one query pending,
	// and no more than 8 packets to process
	//
	IRUSB_ASSERT( NULL != pWorkItem );
	IRUSB_ASSERT( i < NUM_WORK_ITEMS );

    InterlockedExchangePointer( &pWorkItem->pInfoBuf, pInfoBuf );
    InterlockedExchange( (PLONG)&pWorkItem->InfoBufLen, InfoBufLen );

    /*
    ** This interface was designed to use NdisScheduleWorkItem(), which
    ** would be good except that we're really only supposed to use that
    ** interface during startup and shutdown, due to the limited pool of
    ** threads available to service NdisScheduleWorkItem().  Therefore,
    ** instead of scheduling real work items, we simulate them, and use
    ** our own thread to process the calls.  This also makes it easy to
    ** expand the size of our own thread pool, if we wish.
    **
    ** Our version is slightly different from actual NDIS_WORK_ITEMs,
    ** because that is an NDIS 5.0 structure, and we want people to
    ** (at least temporarily) build this with NDIS 4.0 headers.
    */
    InterlockedExchangePointer( (PVOID *)&pWorkItem->Callback, (PVOID)Callback );

    /*
    ** Our worker thread checks this list for new jobs, whenever its event
    ** is signalled.
    */

    // wake up worker thread
    KeSetEvent( &pThisDev->EventPassiveThread, 0, FALSE );

    DEBUGMSG(DBG_FUNC, ("-ScheduleWorkItem\n"));
	return ItemScheduled;
}


/*****************************************************************************
*
*  Function:	FreeWorkItem
*
*  Synopsis:	Sets the work item to the reusable state.
*
*  Arguments:	pItem - pointer to work item
*	
*  Returns:		None
*
*  Notes:
*
*****************************************************************************/
VOID
FreeWorkItem(
        IN OUT PIR_WORK_ITEM pItem
    )
{
    InterlockedExchange( (PLONG)&pItem->fInUse, FALSE );
}


/*****************************************************************************
*
*  Function:	MyIoCallDriver
*
*  Synopsis:	Calls a device driver and keeps track of the count
*
*  Arguments:	pThisDev - pointer to IR device
*				pDeviceObject - pointer to device driver to call
*				pIrp - pointer to Irp to submit
*	
*  Returns:		NT status code
*
*  Notes:		
*
*****************************************************************************/
NTSTATUS
MyIoCallDriver(
	   IN PIR_DEVICE pThisDev,
       IN PDEVICE_OBJECT pDeviceObject,
       IN OUT PIRP pIrp
   )
{
    NTSTATUS	ntStatus;

	DEBUGMSG( DBG_FUNC,("+MyIoCallDriver\n "));

	//
	// We will track count of pending irps;
	// We May later add logic to actually save array of pending irps
	//
	IrUsb_IncIoCount( pThisDev );
	ntStatus = IoCallDriver( pDeviceObject, pIrp );

	DEBUGMSG( DBG_FUNC,("+MyIoCallDriver\n "));
	return ntStatus;
}


/*****************************************************************************
*
*  Function:	IrUsb_CallUSBD
*
*  Synopsis:	Passes a URB to the USBD class driver
*				The client device driver passes USB request block (URB) structures
*				to the class driver as a parameter in an IRP with Irp->MajorFunction
*				set to IRP_MJ_INTERNAL_DEVICE_CONTROL and the next IRP stack location
*				Parameters.DeviceIoControl.IoControlCode field set to
*				IOCTL_INTERNAL_USB_SUBMIT_URB.
*
*  Arguments:	pThisDev - pointer to the IR device
*				pUrb - pointer to an already-formatted Urb request block
*	
*  Returns:		STATUS_SUCCESS if successful,
*				STATUS_UNSUCCESSFUL otherwise
*
*  Notes:
*
*****************************************************************************/
NTSTATUS
IrUsb_CallUSBD(
		IN PIR_DEVICE pThisDev,
		IN PURB pUrb
    )
{
    NTSTATUS			ntStatus = STATUS_SUCCESS;
    PDEVICE_OBJECT		pUrbTargetDev;
    PIO_STACK_LOCATION	pNextStack;

    DEBUGMSG( DBG_FUNC,("+IrUsb_CallUSBD\n"));

    IRUSB_ASSERT( KeGetCurrentIrql() == PASSIVE_LEVEL );
    IRUSB_ASSERT( pThisDev );
    IRUSB_ASSERT( NULL == ((PIRUSB_USB_INFO)pThisDev->pUsbInfo)->IrpSubmitUrb );  //shouldn't be multiple control calls pending

    //
    // issue a synchronous request (we'll wait )
    //
    pUrbTargetDev = pThisDev->pUsbDevObj;

    IRUSB_ASSERT( pUrbTargetDev );

	// make an irp sending to usbhub
	((PIRUSB_USB_INFO)pThisDev->pUsbInfo)->IrpSubmitUrb = 
		IoAllocateIrp( (CCHAR)(pThisDev->pUsbDevObj->StackSize + 1), FALSE );

    if( NULL == ((PIRUSB_USB_INFO)pThisDev->pUsbInfo)->IrpSubmitUrb )
    {
        DEBUGMSG(DBG_ERR, (" IrUsb_CallUsbd failed to alloc IRP\n"));
		ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto done;
    }

    ((PIRUSB_USB_INFO)pThisDev->pUsbInfo)->IrpSubmitUrb->IoStatus.Status = STATUS_PENDING;
    ((PIRUSB_USB_INFO)pThisDev->pUsbInfo)->IrpSubmitUrb->IoStatus.Information = 0;

    //
    // Call the class driver to perform the operation.  If the returned status
    // is PENDING, wait for the request to complete.
    //
    pNextStack = IoGetNextIrpStackLocation( ((PIRUSB_USB_INFO) pThisDev->pUsbInfo)->IrpSubmitUrb );
    IRUSB_ASSERT( pNextStack != NULL );

    //
    // pass the URB to the USB driver stack
    //
	pNextStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
	pNextStack->Parameters.Others.Argument1 = pUrb;
	pNextStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_INTERNAL_USB_SUBMIT_URB;

    IoSetCompletionRoutine(
			((PIRUSB_USB_INFO) pThisDev->pUsbInfo)->IrpSubmitUrb,      // irp to use
			UsbIoCompleteControl,			// routine to call when irp is done
			DEV_TO_CONTEXT(pThisDev),		// context to pass routine
			TRUE,							// call on success
			TRUE,							// call on error
			TRUE							// call on cancel
		);

	KeClearEvent( &pThisDev->EventAsyncUrb );

    ntStatus = MyIoCallDriver(
			pThisDev,
			pUrbTargetDev,
			((PIRUSB_USB_INFO)pThisDev->pUsbInfo)->IrpSubmitUrb
		);

    DEBUGMSG( DBG_OUT,(" IrUsb_CallUSBD () return from IoCallDriver USBD %x\n", ntStatus));

    if( (ntStatus == STATUS_PENDING) || (ntStatus == STATUS_SUCCESS) )
	{
        //
		// wait, but dump out on timeout
        //
		if( ntStatus == STATUS_PENDING )
		{
            ntStatus = MyKeWaitForSingleObject( pThisDev, &pThisDev->EventAsyncUrb, 0 );

            if( ntStatus == STATUS_TIMEOUT ) 
			{
                DEBUGMSG( DBG_ERR,(" IrUsb_CallUSBD () TIMED OUT! return from IoCallDriver USBD %x\n", ntStatus));
				// MS Security recommendation - cannot cancel IRP.
            }
			else
			{
				//
				// Update the status to reflect the real return code
				//
				ntStatus = pThisDev->StatusControl;
			}
        }
    } 
	else 
	{
        DEBUGMSG( DBG_ERR, ("IrUsb_CallUSBD IoCallDriver FAILED(%x)\n",ntStatus));
    }

    DEBUGMSG( DBG_OUT,("IrUsb_CallUSBD () URB status = %x  IRP status = %x\n", pUrb->UrbHeader.Status, ntStatus ));

done:
	((PIRUSB_USB_INFO) pThisDev->pUsbInfo)->IrpSubmitUrb = NULL;

    DEBUGCOND( DBG_ERR, !NT_SUCCESS( ntStatus ), (" exit IrUsb_CallUSBD FAILED (%x)\n", ntStatus));
    DEBUGMSG( DBG_FUNC,("-IrUsb_CallUSBD\n"));

    return ntStatus;
}



/*****************************************************************************
*
*  Function:	IrUsb_ResetUSBD
*
*  Synopsis:	Passes a URB to the USBD class driver, forcing the latter to reset or part
*
*  Arguments:	pThisDev - pointer to the IR device
*				ForceUnload - flag to perform a reset or an unload
*	
*  Returns:		STATUS_SUCCESS if successful,
*				STATUS_UNSUCCESSFUL otherwise
*
*  Notes:
*
*****************************************************************************/
NTSTATUS
IrUsb_ResetUSBD(
		IN PIR_DEVICE pThisDev,
		BOOLEAN ForceUnload
    )
{
    NTSTATUS			ntStatus;
    PDEVICE_OBJECT		pUrbTargetDev;
    PIO_STACK_LOCATION	pNextStack;

    DEBUGMSG( DBG_FUNC,("+IrUsb_ResetUSBD\n"));

    IRUSB_ASSERT( KeGetCurrentIrql() == PASSIVE_LEVEL );
    IRUSB_ASSERT( pThisDev );
    IRUSB_ASSERT( NULL == ((PIRUSB_USB_INFO)pThisDev->pUsbInfo)->IrpSubmitUrb );  //shouldn't be multiple control calls pending

    //
    // issue a synchronous request (we'll wait )
    //
    pUrbTargetDev = pThisDev->pUsbDevObj;

    IRUSB_ASSERT( pUrbTargetDev );

	// make an irp sending to usbhub
	((PIRUSB_USB_INFO)pThisDev->pUsbInfo)->IrpSubmitUrb = 
		IoAllocateIrp( (CCHAR)(pThisDev->pUsbDevObj->StackSize + 1), FALSE );

    if( NULL == ((PIRUSB_USB_INFO)pThisDev->pUsbInfo)->IrpSubmitUrb )
    {
        DEBUGMSG(DBG_ERR, (" IrUsb_ResetUSBD failed to alloc IRP\n"));
		ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto done;
    }

    ((PIRUSB_USB_INFO)pThisDev->pUsbInfo)->IrpSubmitUrb->IoStatus.Status = STATUS_PENDING;
    ((PIRUSB_USB_INFO)pThisDev->pUsbInfo)->IrpSubmitUrb->IoStatus.Information = 0;

    //
    // Call the class driver to perform the operation.  If the returned status
    // is PENDING, wait for the request to complete.
    //
    pNextStack = IoGetNextIrpStackLocation( ((PIRUSB_USB_INFO) pThisDev->pUsbInfo)->IrpSubmitUrb );
    IRUSB_ASSERT( pNextStack != NULL );

    //
    // pass the URB to the USB driver stack
    //
	pNextStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
	if( ForceUnload )
		pNextStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_INTERNAL_USB_CYCLE_PORT;
	else
		pNextStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_INTERNAL_USB_RESET_PORT;

    IoSetCompletionRoutine(
			((PIRUSB_USB_INFO)pThisDev->pUsbInfo)->IrpSubmitUrb,      // irp to use
			UsbIoCompleteControl,			// routine to call when irp is done
			DEV_TO_CONTEXT(pThisDev),		// context to pass routine
			TRUE,							// call on success
			TRUE,							// call on error
			TRUE							// call on cancel
		);

	KeClearEvent( &pThisDev->EventAsyncUrb );

    ntStatus = MyIoCallDriver(
			pThisDev,
			pUrbTargetDev,
			((PIRUSB_USB_INFO)pThisDev->pUsbInfo)->IrpSubmitUrb
		);

    DEBUGMSG( DBG_OUT,(" IrUsb_ResetUSBD () return from IoCallDriver USBD %x\n", ntStatus));

    if( (ntStatus == STATUS_PENDING) || (ntStatus == STATUS_SUCCESS) )
	{
        //
		// wait, but dump out on timeout
        //
		if( ntStatus == STATUS_PENDING )
		{
            ntStatus = MyKeWaitForSingleObject( pThisDev, &pThisDev->EventAsyncUrb, 0 );

            if( ntStatus == STATUS_TIMEOUT ) 
			{
                DEBUGMSG( DBG_ERR,(" IrUsb_ResetUSBD () TIMED OUT! return from IoCallDriver USBD %x\n", ntStatus));
				// MS Security recommendation - cannot cancel IRP.
            }
			else
			{
				//
				// Update the status to reflect the real return code
				//
				ntStatus = pThisDev->StatusControl;
			}
        }
    } 
	else 
	{
        DEBUGMSG( DBG_ERR, ("IrUsb_ResetUSBD IoCallDriver FAILED(%x)\n",ntStatus));
    }

done:
	((PIRUSB_USB_INFO) pThisDev->pUsbInfo)->IrpSubmitUrb = NULL;

    DEBUGCOND( DBG_ERR, !NT_SUCCESS( ntStatus ), (" exit IrUsb_ResetUSBD FAILED (%x)\n", ntStatus));
    DEBUGMSG( DBG_FUNC,("-IrUsb_ResetUSBD\n"));

    return ntStatus;
}


/*****************************************************************************
*
*  Function:   UsbIoCompleteControl
*
*  Synopsis:   General completetion routine just to insure cancel-ability of control calls
*              and keep track of pending irp count
*
*  Arguments:  pUsbDevObj - pointer to the  device object which
*                              completed the irp
*              pIrp          - the irp which was completed by the  device
*                              object
*              Context       - dev ext
*
*  Returns:    STATUS_MORE_PROCESSING_REQUIRED - allows the completion routine
*              (IofCompleteRequest) to stop working on the irp.
*
*
*****************************************************************************/
NTSTATUS
UsbIoCompleteControl(
		IN PDEVICE_OBJECT pUsbDevObj,
		IN PIRP           pIrp,
		IN PVOID          Context
	)
{
    PIR_DEVICE  pThisDev;
    NTSTATUS    status;

    DEBUGMSG(DBG_FUNC, ("+UsbIoCompleteControl\n"));

    //
    // The context given to IoSetCompletionRoutine is simply the the ir
    // device object pointer.
    //
    pThisDev = CONTEXT_TO_DEV( Context );

    status = pIrp->IoStatus.Status;

    switch( status )
    {
        case STATUS_SUCCESS:
            DEBUGMSG(DBG_OUT, (" UsbIoCompleteControl STATUS_SUCCESS\n"));
            break; // STATUS_SUCCESS

        case STATUS_TIMEOUT:
            DEBUGMSG(DBG_ERR, (" UsbIoCompleteControl STATUS_TIMEOUT\n"));
            break;

        case STATUS_PENDING:
            DEBUGMSG(DBG_ERR, (" UsbIoCompleteControl STATUS_PENDING\n"));
            break;

        case STATUS_DEVICE_DATA_ERROR:
			// can get during shutdown
            DEBUGMSG(DBG_ERR, (" UsbIoCompleteControl STATUS_DEVICE_DATA_ERROR\n"));
            break;

        case STATUS_UNSUCCESSFUL:
            DEBUGMSG(DBG_ERR, (" UsbIoCompleteControl STATUS_UNSUCCESSFUL\n"));
            break;

        case STATUS_INSUFFICIENT_RESOURCES:
            DEBUGMSG(DBG_ERR, (" UsbIoCompleteControl STATUS_INSUFFICIENT_RESOURCES\n"));
            break;

        case STATUS_INVALID_PARAMETER:
            DEBUGMSG(DBG_ERR, (" UsbIoCompleteControl STATUS_INVALID_PARAMETER\n"));
            break;

        case STATUS_CANCELLED:
            DEBUGMSG(DBG_ERR, (" UsbIoCompleteControl STATUS_CANCELLED\n"));
            break;

        case STATUS_DEVICE_NOT_CONNECTED:
			// can get during shutdown
            DEBUGMSG(DBG_ERR, (" UsbIoCompleteControl STATUS_DEVICE_NOT_CONNECTED\n"));
            break;

        case STATUS_DEVICE_POWER_FAILURE:
			// can get during shutdown
            DEBUGMSG(DBG_ERR, (" UsbIoCompleteControl STATUS_DEVICE_POWER_FAILURE\n"));
            break;

        default:
            DEBUGMSG(DBG_ERR, (" UsbIoCompleteControl UNKNOWN WEIRD STATUS = 0x%x, dec %d\n",status,status ));
            break;
    }

	IrUsb_DecIoCount( pThisDev );  //we track pending irp count

	if( pIrp == ((PIRUSB_USB_INFO)pThisDev->pUsbInfo)->IrpSubmitUrb ) 
	{
		IRUSB_ASSERT( NULL != ((PIRUSB_USB_INFO)pThisDev->pUsbInfo)->IrpSubmitUrb );

		IoFreeIrp( ((PIRUSB_USB_INFO)pThisDev->pUsbInfo)->IrpSubmitUrb );

		pThisDev->StatusControl = status; // save status because can't use irp after completion routine is hit!
		KeSetEvent( &pThisDev->EventAsyncUrb, 0, FALSE );  //signal we're done
	} 
	else 
	{
		DEBUGMSG( DBG_ERR, (" UsbIoCompleteControl UNKNOWN IRP\n"));
		IRUSB_ASSERT( 0 );
	}

    DEBUGCOND(DBG_ERR, !( NT_SUCCESS( status ) ), ("UsbIoCompleteControl BAD status = 0x%x\n", status));

    DEBUGMSG(DBG_FUNC, ("-UsbIoCompleteControl\n"));

	//
    // We return STATUS_MORE_PROCESSING_REQUIRED so that the completion
    // routine (IofCompleteRequest) will stop working on the irp.
    //
    return STATUS_MORE_PROCESSING_REQUIRED;
}


/*****************************************************************************
*
*  Function:	IrUsb_ConfigureDevice
*
*  Synopsis:	Initializes a given instance of the device on the USB and
*				selects and saves the configuration.
*
*  Arguments:	pThisDev - pointer to the IR device
*	
*  Returns:		NT status code
*
*  Notes:
*
*****************************************************************************/
NTSTATUS
IrUsb_ConfigureDevice(
		IN OUT PIR_DEVICE pThisDev
    )
{
    NTSTATUS	ntStatus;
    PURB		pUrb;
    ULONG		UrbSize;

    DEBUGMSG(DBG_FUNC,("+IrUsb_ConfigureDevice()\n"));

	IRUSB_ASSERT( ((PIRUSB_USB_INFO)pThisDev->pUsbInfo)->UsbConfigurationDescriptor == NULL );

    pUrb = (PURB)&((PIRUSB_USB_INFO)pThisDev->pUsbInfo)->DescriptorUrb;
	
	//
	// When USB_CONFIGURATION_DESCRIPTOR_TYPE is specified for DescriptorType
	// in a call to UsbBuildGetDescriptorRequest(),
	// all interface, endpoint, class-specific, and vendor-specific descriptors
	// for the configuration also are retrieved.
	// The caller must allocate a buffer large enough to hold all of this
	// information or the data is truncated without error.
	// Therefore the 'siz' set below is just a 'good guess', and we may have to retry
	//
    UrbSize = sizeof(USB_CONFIGURATION_DESCRIPTOR) + 512;  // Store size, may need to free

	//
	// We will break out of this 'retry loop' when UsbBuildGetDescriptorRequest()
	// has a big enough pThisDev->UsbConfigurationDescriptor buffer not to truncate
	//
	while( TRUE ) 
	{
		((PIRUSB_USB_INFO)pThisDev->pUsbInfo)->UsbConfigurationDescriptor = MyMemAlloc( UrbSize );

		if( !((PIRUSB_USB_INFO) pThisDev->pUsbInfo)->UsbConfigurationDescriptor ) 
		{
		    MyMemFree( pUrb, sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST) );
			return STATUS_INSUFFICIENT_RESOURCES;
		}

		UsbBuildGetDescriptorRequest(
				pUrb,
				(USHORT) sizeof( struct _URB_CONTROL_DESCRIPTOR_REQUEST ),
				USB_CONFIGURATION_DESCRIPTOR_TYPE,
				0,
				0,
				((PIRUSB_USB_INFO)pThisDev->pUsbInfo)->UsbConfigurationDescriptor,
				NULL,
				UrbSize,
				NULL
			);

		ntStatus = IrUsb_CallUSBD( pThisDev, pUrb ); //Get Usb Config Descriptor; done in main thread

		DEBUGMSG(DBG_OUT,(" IrUsb_ConfigureDevice() Configuration Descriptor = %x, len %x\n",
						((PIRUSB_USB_INFO) pThisDev->pUsbInfo)->UsbConfigurationDescriptor,
						pUrb->UrbControlDescriptorRequest.TransferBufferLength));
		//
		// if we got some data see if it was enough.
		// NOTE: we may get an error in URB because of buffer overrun
		if( (pUrb->UrbControlDescriptorRequest.TransferBufferLength > 0) &&
				(((PIRUSB_USB_INFO)pThisDev->pUsbInfo)->UsbConfigurationDescriptor->wTotalLength > UrbSize) &&
				NT_SUCCESS(ntStatus) ) 
		{ 
			MyMemFree( ((PIRUSB_USB_INFO)pThisDev->pUsbInfo)->UsbConfigurationDescriptor, UrbSize );
			UrbSize = ((PIRUSB_USB_INFO)pThisDev->pUsbInfo)->UsbConfigurationDescriptor->wTotalLength;
			((PIRUSB_USB_INFO)pThisDev->pUsbInfo)->UsbConfigurationDescriptor = NULL;
		} 
		else 
		{
			break;  // we got it on the first try
		}

	} // end, while (retry loop )

	IRUSB_ASSERT( ((PIRUSB_USB_INFO) pThisDev->pUsbInfo)->UsbConfigurationDescriptor );

    if( !NT_SUCCESS(ntStatus) ) 
	{
        DEBUGMSG( DBG_ERR,(" IrUsb_ConfigureDevice() Get Config Descriptor FAILURE (%x)\n", ntStatus));
        goto done;
    }

    //
    // We have the configuration descriptor for the configuration we want.
    // Now we issue the select configuration command to get
    // the  pipes associated with this configuration.
    //
    ntStatus = IrUsb_SelectInterface(
			pThisDev,
			((PIRUSB_USB_INFO)pThisDev->pUsbInfo)->UsbConfigurationDescriptor
		);

    if( !NT_SUCCESS(ntStatus) ) 
	{
        DEBUGMSG( DBG_ERR,(" IrUsb_ConfigureDevice() IrUsb_SelectInterface() FAILURE (%x)\n", ntStatus));
    } 
	
done:
    DEBUGMSG(DBG_FUNC,("-IrUsb_ConfigureDevice (%x)\n", ntStatus));
    return ntStatus;
}


/*****************************************************************************
*
*  Function:	IrUsb_SelectInterface
*
*  Synopsis:    Initializes the ST4200 interfaces;
*				This minidriver only supports one interface (with multiple endpoints).
*
*  Arguments:	pThisDev - pointer to IR device
*				pConfigurationDescriptor - pointer to USB configuration descriptor
*	
*  Returns:		NT status code
*
*  Notes:		
*
*****************************************************************************/
NTSTATUS
IrUsb_SelectInterface(
		IN OUT PIR_DEVICE pThisDev,
		IN PUSB_CONFIGURATION_DESCRIPTOR pConfigurationDescriptor
    )
{
    NTSTATUS	ntStatus;
    PURB		pUrb = NULL;
    ULONG		i;
    USHORT		DescriptorSize;
    PUSB_INTERFACE_DESCRIPTOR		pInterfaceDescriptor = NULL;
	PUSBD_INTERFACE_INFORMATION		pInterface = NULL;

    DEBUGMSG(DBG_FUNC,("+IrUsb_SelectInterface\n"));

    IRUSB_ASSERT( pConfigurationDescriptor != NULL );
    IRUSB_ASSERT( pThisDev != NULL );
	
	//
    // IrUsb driver only supports one interface, we must parse
    // the configuration descriptor for the interface
    // and remember the pipes. Needs to be aupdated
    //
    pUrb = USBD_CreateConfigurationRequest( pConfigurationDescriptor, &DescriptorSize );

    if( pUrb ) 
	{
        DEBUGMSG(DBG_OUT,(" USBD_CreateConfigurationRequest created the urb\n"));

		//
		// USBD_ParseConfigurationDescriptorEx searches a given configuration
		// descriptor and returns a pointer to an interface that matches the
		// given search criteria. We only support one interface on this device
		//
        pInterfaceDescriptor = USBD_ParseConfigurationDescriptorEx(
				pConfigurationDescriptor,
				pConfigurationDescriptor,	// search from start of config descriptor
				-1,							// interface number not a criteria; we only support one interface
				-1,							// not interested in alternate setting here either
				-1,							// interface class not a criteria
				-1,							// interface subclass not a criteria
				-1							// interface protocol not a criteria
			);

		if( !pInterfaceDescriptor ) 
		{
			DEBUGMSG(DBG_ERR,("IrUsb_SelectInterface() ParseConfigurationDescriptorEx() failed\n  returning STATUS_INSUFFICIENT_RESOURCES\n"));
		    
			//
			// don't call the MyMemFree since the buffer was
		    //  alloced by USBD_CreateConfigurationRequest, not MyMemAlloc()
            //
			ExFreePool( pUrb );
			return STATUS_INSUFFICIENT_RESOURCES;
		}

        pInterface = &pUrb->UrbSelectConfiguration.Interface;

        DEBUGMSG(DBG_OUT,(" After USBD_CreateConfigurationRequest, before UsbBuildSelectConfigurationRequest\n" ));
        
		//
		// Now prepare the pipes
		//
		for( i=0; i<pInterface->NumberOfPipes; i++ ) 
		{
            //
            // perform any pipe initialization here; mainly set max xfer size
            // But Watch out! USB may change these when you select the interface;
            // In general USB doesn;t seem to like differing max transfer sizes on the pipes
            //
            pInterface->Pipes[i].MaximumTransferSize = STIR4200_FIFO_SIZE;
        }

        //
		// Initialize the device with the pipe structure found
		//
		UsbBuildSelectConfigurationRequest( pUrb, DescriptorSize, pConfigurationDescriptor );
        ntStatus = IrUsb_CallUSBD( pThisDev, pUrb ); //select config; done in main thread
        ((PIRUSB_USB_INFO)pThisDev->pUsbInfo)->UsbConfigurationHandle =
            pUrb->UrbSelectConfiguration.ConfigurationHandle;
    } 
	else 
	{
        DEBUGMSG(DBG_ERR,(" IrUsb_SelectInterface() USBD_CreateConfigurationRequest() failed\n  returning STATUS_INSUFFICIENT_RESOURCES\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    if( NT_SUCCESS(ntStatus) ) 
	{
        //
        // Save the configuration handle for this device
        //
        ((PIRUSB_USB_INFO) pThisDev->pUsbInfo)->UsbConfigurationHandle =
            pUrb->UrbSelectConfiguration.ConfigurationHandle;

		if( NULL == ((PIRUSB_USB_INFO)pThisDev->pUsbInfo)->UsbInterface ) 
		{
			((PIRUSB_USB_INFO)pThisDev->pUsbInfo)->UsbInterface = MyMemAlloc( pInterface->Length );
		}

        if( NULL != ((PIRUSB_USB_INFO)pThisDev->pUsbInfo)->UsbInterface ) 
		{
            ULONG j;

            //
            // save a copy of the interface information returned
            //
            RtlCopyMemory( ((PIRUSB_USB_INFO) pThisDev->pUsbInfo)->UsbInterface, pInterface, pInterface->Length );

            //
            // Dump the interface to the debugger
            //
            DEBUGMSG(DBG_FUNC,("---------After Select Config \n"));
            DEBUGMSG(DBG_FUNC,("NumberOfPipes 0x%x\n", ((PIRUSB_USB_INFO) pThisDev->pUsbInfo)->UsbInterface->NumberOfPipes));
            DEBUGMSG(DBG_FUNC,("Length 0x%x\n", ((PIRUSB_USB_INFO) pThisDev->pUsbInfo)->UsbInterface->Length));
            DEBUGMSG(DBG_FUNC,("Alt Setting 0x%x\n", ((PIRUSB_USB_INFO) pThisDev->pUsbInfo)->UsbInterface->AlternateSetting));
            DEBUGMSG(DBG_FUNC,("Interface Number 0x%x\n", ((PIRUSB_USB_INFO) pThisDev->pUsbInfo)->UsbInterface->InterfaceNumber));
            DEBUGMSG(DBG_FUNC,("Class, subclass, protocol 0x%x 0x%x 0x%x\n",
                ((PIRUSB_USB_INFO) pThisDev->pUsbInfo)->UsbInterface->Class,
                ((PIRUSB_USB_INFO) pThisDev->pUsbInfo)->UsbInterface->SubClass,
                ((PIRUSB_USB_INFO) pThisDev->pUsbInfo)->UsbInterface->Protocol));

            //
			// Find our Bulk in and out pipes, save their handles, Dump the pipe info
            //
			for( j=0; j<pInterface->NumberOfPipes; j++ ) 
			{
                PUSBD_PIPE_INFORMATION pipeInformation;

                pipeInformation = &((PIRUSB_USB_INFO) pThisDev->pUsbInfo)->UsbInterface->Pipes[j];

                //
				// Find the Bulk In and Out pipes ( these are probably the only two pipes )
                //
				if( UsbdPipeTypeBulk == pipeInformation->PipeType )
                {
                    // endpoint address with bit 0x80 set are input pipes, else output
                    if( USB_ENDPOINT_DIRECTION_IN( pipeInformation->EndpointAddress ) ) 
					{
                        pThisDev->BulkInPipeHandle = pipeInformation->PipeHandle;
                    }

                    if( USB_ENDPOINT_DIRECTION_OUT( pipeInformation->EndpointAddress ) ) 
					{
                        pThisDev->BulkOutPipeHandle = pipeInformation->PipeHandle;
                    }

                }

                DEBUGMSG(DBG_FUNC,("---------\n"));
                DEBUGMSG(DBG_FUNC,("PipeType 0x%x\n", pipeInformation->PipeType));
                DEBUGMSG(DBG_FUNC,("EndpointAddress 0x%x\n", pipeInformation->EndpointAddress));
                DEBUGMSG(DBG_FUNC,("MaxPacketSize 0x%x\n", pipeInformation->MaximumPacketSize));
                DEBUGMSG(DBG_FUNC,("Interval 0x%x\n", pipeInformation->Interval));
                DEBUGMSG(DBG_FUNC,("Handle 0x%x\n", pipeInformation->PipeHandle));
                DEBUGMSG(DBG_FUNC,("MaximumTransferSize 0x%x\n", pipeInformation->MaximumTransferSize));
            }

            DEBUGMSG(DBG_FUNC,("---------\n"));
        }
    }

    //
	// we better have found input and output bulk pipes!
    //
	IRUSB_ASSERT( pThisDev->BulkInPipeHandle && pThisDev->BulkOutPipeHandle );
	if( !pThisDev->BulkInPipeHandle || !pThisDev->BulkOutPipeHandle )
	{
		DEBUGMSG(DBG_ERR,("IrUsb_SelectInterface() failed to get pipes\n"));
		ntStatus = STATUS_UNSUCCESSFUL;
	}

    if( pUrb ) 
	{
		//
		// don't call the MyMemFree since the buffer was
		//  alloced by USBD_CreateConfigurationRequest, not MyMemAlloc()
        //
		ExFreePool( pUrb );
    }

    DEBUGMSG(DBG_FUNC,("-IrUsb_SelectInterface (%x)\n", ntStatus));

    return ntStatus;
}


/*****************************************************************************
*
*  Function:	IrUsb_StartDevice
*
*  Synopsis:	Initializes a given instance of the device on the USB.
*				USB client drivers such as us set up URBs (USB Request Packets) to send requests
*				to the host controller driver (HCD). The URB structure defines a format for all
*				possible commands that can be sent to a USB device.
*				Here, we request the device descriptor and store it, and configure the device.
*
*  Arguments:	pThisDev - pointer to IR device
*	
*  Returns:		NT status code
*
*  Notes:		
*
*****************************************************************************/
NTSTATUS
IrUsb_StartDevice(
		IN PIR_DEVICE pThisDev
	)
{
    NTSTATUS				ntStatus;
    PUSB_DEVICE_DESCRIPTOR	pDeviceDescriptor = NULL;
    PURB					pUrb;
    ULONG					DescriptorSize;

    DEBUGMSG( DBG_FUNC, ("+IrUsb_StartDevice()\n"));

    pUrb = MyMemAlloc( sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST));

    DEBUGCOND( DBG_ERR,!pUrb, (" IrUsb_StartDevice() FAILED MyMemAlloc() for URB\n"));

    if( pUrb ) 
	{
        DescriptorSize = sizeof( USB_DEVICE_DESCRIPTOR );

        pDeviceDescriptor = MyMemAlloc( DescriptorSize );

        DEBUGCOND( DBG_ERR, !pDeviceDescriptor, (" IrUsb_StartDevice() FAILED MyMemAlloc() for deviceDescriptor\n"));

        if( pDeviceDescriptor ) 
		{
            //
			// Get all the USB descriptor data
			//
			UsbBuildGetDescriptorRequest(
					pUrb,
					(USHORT) sizeof (struct _URB_CONTROL_DESCRIPTOR_REQUEST),
					USB_DEVICE_DESCRIPTOR_TYPE,
					0,
					0,
					pDeviceDescriptor,
					NULL,
					DescriptorSize,
					NULL
				);

            ntStatus = IrUsb_CallUSBD( pThisDev, pUrb ); // build get descripttor req; main thread

            DEBUGCOND( DBG_ERR, !NT_SUCCESS(ntStatus), (" IrUsb_StartDevice() FAILED IrUsb_CallUSBD (pThisDev, pUrb)\n"));

            if( NT_SUCCESS(ntStatus) ) 
			{
                DEBUGMSG( DBG_FUNC,("Device Descriptor = %x, len %x\n",
                                pDeviceDescriptor,
                                pUrb->UrbControlDescriptorRequest.TransferBufferLength));

                DEBUGMSG( DBG_FUNC,("IR Dongle Device Descriptor:\n"));
                DEBUGMSG( DBG_FUNC,("-------------------------\n"));
                DEBUGMSG( DBG_FUNC,("bLength %d\n", pDeviceDescriptor->bLength));
                DEBUGMSG( DBG_FUNC,("bDescriptorType 0x%x\n", pDeviceDescriptor->bDescriptorType));
                DEBUGMSG( DBG_FUNC,("bcdUSB 0x%x\n", pDeviceDescriptor->bcdUSB));
                DEBUGMSG( DBG_FUNC,("bDeviceClass 0x%x\n", pDeviceDescriptor->bDeviceClass));
                DEBUGMSG( DBG_FUNC,("bDeviceSubClass 0x%x\n", pDeviceDescriptor->bDeviceSubClass));
                DEBUGMSG( DBG_FUNC,("bDeviceProtocol 0x%x\n", pDeviceDescriptor->bDeviceProtocol));
                DEBUGMSG( DBG_FUNC,("bMaxPacketSize0 0x%x\n", pDeviceDescriptor->bMaxPacketSize0));
                DEBUGMSG( DBG_FUNC,("idVendor 0x%x\n", pDeviceDescriptor->idVendor));
                DEBUGMSG( DBG_FUNC,("idProduct 0x%x\n", pDeviceDescriptor->idProduct));
                DEBUGMSG( DBG_FUNC,("bcdDevice 0x%x\n", pDeviceDescriptor->bcdDevice));
                DEBUGMSG( DBG_FUNC,("iManufacturer 0x%x\n", pDeviceDescriptor->iManufacturer));
                DEBUGMSG( DBG_FUNC,("iProduct 0x%x\n", pDeviceDescriptor->iProduct));
                DEBUGMSG( DBG_FUNC,("iSerialNumber 0x%x\n", pDeviceDescriptor->iSerialNumber));
                DEBUGMSG( DBG_FUNC,("bNumConfigurations 0x%x\n", pDeviceDescriptor->bNumConfigurations));
            }
        } 
		else 
		{
			// if we got here we failed to allocate deviceDescriptor
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }

        if( NT_SUCCESS(ntStatus) ) 
		{
            ((PIRUSB_USB_INFO) pThisDev->pUsbInfo)->UsbDeviceDescriptor = pDeviceDescriptor;
			pThisDev->IdVendor = ((PIRUSB_USB_INFO) pThisDev->pUsbInfo)->UsbDeviceDescriptor->idVendor;
        }

        MyMemFree( pUrb, sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST) );

    } 
	else 
	{
		//
		// if we got here we failed to allocate the urb
        //
		ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

	//
	// Now that we have the descriptors, we can configure the device
	//
	if( NT_SUCCESS(ntStatus) ) 
	{
        ntStatus = IrUsb_ConfigureDevice( pThisDev );

        DEBUGCOND( DBG_ERR,!NT_SUCCESS(ntStatus),(" IrUsb_StartDevice IrUsb_ConfigureDevice() FAILURE (%x)\n", ntStatus));
    }

	//
	// Read all the initial registers
	//
	if( NT_SUCCESS(ntStatus) ) 
	{
        ntStatus = St4200ReadRegisters( pThisDev, 0, STIR4200_MAX_REG );
        DEBUGCOND( DBG_ERR,!NT_SUCCESS(ntStatus),(" IrUsb_StartDevice St4200ReadRegisters() FAILURE (%x)\n", ntStatus));
	}

	//
	// Get the current chip revision
	//
	if( NT_SUCCESS(ntStatus) ) 
	{
		pThisDev->ChipRevision = pThisDev->StIrTranceiver.SensitivityReg & STIR4200_SENS_IDMASK;
	}
	
    //
    // Next we must get the Class-Specific Descriptor
    // Get the IR USB dongle's Class-Specific descriptor; this has many
    // characterisitics we must tell Ndis about, such as supported speeds,
    // BOFS required, rate sniff-supported flag, turnaround time, window size,
    // data size.
    //
	if( NT_SUCCESS(ntStatus) ) 
	{
		ntStatus = IrUsb_GetDongleCaps( pThisDev );
		if( !NT_SUCCESS( ntStatus ) ) 
		{
			DEBUGMSG( DBG_ERR,(" IrUsb_ConfigureDevice() IrUsb_GetClassDescriptor() FAILURE (%x)\n", ntStatus));
		} 
		else 
		{
			// fill out dongleCaps struct from class-specific descriptor info
			IrUsb_SetDongleCaps( pThisDev );
		}
	}

	//
	// Read customer data block.
	//
	if( NT_SUCCESS(ntStatus) && !pThisDev->CustomerDataRead) 
	{
		ntStatus = ReadCustomerData(pThisDev);
        DEBUGCOND( DBG_ERR,!NT_SUCCESS(ntStatus),(" IrUsb_StartDevice ReadCustomerData() FAILURE (%x)\n", ntStatus));
		pThisDev->CustomerDataRead = TRUE;	// one chance only
	}

	//
	// Set the initial speed
	//
	if( NT_SUCCESS(ntStatus) ) 
	{
		ntStatus = St4200SetSpeed( pThisDev );
        DEBUGCOND( DBG_ERR,!NT_SUCCESS(ntStatus),(" IrUsb_StartDevice St4200SetSpeed() FAILURE (%x)\n", ntStatus));
	}

	//
	// All set and ready to roll
	//
    if( NT_SUCCESS(ntStatus) ) 
	{
		pThisDev->fDeviceStarted = TRUE;
    }

    DEBUGMSG( DBG_FUNC, ("-IrUsb_StartDevice (%x)\n", ntStatus));
    return ntStatus;
}



/*****************************************************************************
*
*  Function:	IrUsb_StopDevice
*
*  Synopsis:	Stops a given instance of a ST4200 device on the USB.
*				We basically just tell USB this device is now 'unconfigured'
*
*  Arguments:	pThisDev - pointer to IR device
*	
*  Returns:		NT status code
*
*  Notes:		
*
*****************************************************************************/
NTSTATUS
IrUsb_StopDevice(
		IN PIR_DEVICE pThisDev
    )
{
    NTSTATUS	ntStatus = STATUS_SUCCESS;
    PURB		pUrb;
    ULONG		DescriptorSize;

    DEBUGMSG( DBG_FUNC,("+IrUsb_StopDevice\n"));

    //
    // Send the select configuration urb with a NULL pointer for the configuration
    // handle. This closes the configuration and puts the device in the 'unconfigured'
    // state.
    //
    DescriptorSize = sizeof( struct _URB_SELECT_CONFIGURATION );
    pUrb = MyMemAlloc( DescriptorSize );

    if( pUrb ) 
	{
        UsbBuildSelectConfigurationRequest(
				pUrb,
				(USHORT)DescriptorSize,
				NULL
			);

        ntStatus = IrUsb_CallUSBD( pThisDev, pUrb ); // build select config req; main thread

        DEBUGCOND( DBG_ERR,
			!NT_SUCCESS(ntStatus),(" IrUsb_StopDevice() FAILURE Configuration Closed status = %x usb status = %x.\n", ntStatus, pUrb->UrbHeader.Status));
        DEBUGCOND( DBG_WARN,
			NT_SUCCESS(ntStatus),(" IrUsb_StopDevice() SUCCESS Configuration Closed status = %x usb status = %x.\n", ntStatus, pUrb->UrbHeader.Status));

        MyMemFree( pUrb, sizeof(struct _URB_SELECT_CONFIGURATION) );
    } 
	else 
	{
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    DEBUGMSG( DBG_FUNC,("-IrUsb_StopDevice  (%x) \n ", ntStatus));
    return ntStatus;
}


/*****************************************************************************
*
*  Function:	ResetPipeCallback
*
*  Synopsis:	Callback for resetting a pipe
*
*  Arguments:	pWorkItem - pointer to the reset work item
*
*  Returns:		NTSTATUS
*
*  Notes:
*
*****************************************************************************/
NTSTATUS
ResetPipeCallback (
		IN PIR_WORK_ITEM pWorkItem
    )
{
	PIR_DEVICE	pThisDev;
	HANDLE		Pipe;
	NTSTATUS	Status = STATUS_SUCCESS;

	pThisDev = (PIR_DEVICE)pWorkItem->pIrDevice;
	Pipe = (HANDLE)pWorkItem->pInfoBuf;

	if( Pipe == pThisDev->BulkInPipeHandle ) 
	{
		IRUSB_ASSERT( TRUE == pThisDev->fPendingReadClearStall );
		
		// MS Security recommendation - not safe to cancel pending IRPs

		Status = IrUsb_ResetPipe( pThisDev, Pipe );

		InterlockedExchange( &pThisDev->fPendingReadClearStall, FALSE );
	} 
	else if( Pipe == pThisDev->BulkOutPipeHandle ) 
	{
		IRUSB_ASSERT( TRUE == pThisDev->fPendingWriteClearStall );

		// MS Security recommendation - not safe to cancel pending IRPs

		Status = IrUsb_ResetPipe( pThisDev, Pipe );

		InterlockedExchange( &pThisDev->fPendingWriteClearStall, FALSE );
	}
#if DBG
	else 
	{
		IRUSB_ASSERT( 0 );
	}
#endif

	FreeWorkItem( pWorkItem );

	return Status;
}


/*****************************************************************************
*
*  Function:	IrUsb_ResetPipe
*
*  Synopsis:	This will reset the host pipe to Data0 and should also reset the device
*				endpoint to Data0 for Bulk and Interrupt pipes by issuing a Clear_Feature
*				Endpoint_Stall to the device endpoint.
*
*  Arguments:	pThisDev - pointer to IR device
*				Pipe - handle to the pipe to reset
*	
*  Returns:		NTSTATUS
*
*  Notes:		Must be called at IRQL PASSIVE_LEVEL
*
*****************************************************************************/
NTSTATUS
IrUsb_ResetPipe (
		IN PIR_DEVICE pThisDev,
		IN HANDLE Pipe
    )
{
    PURB        pUrb;
    NTSTATUS    ntStatus;

    DEBUGMSG(DBG_ERR, ("+IrUsb_ResetPipe()\n"));
	
	//
    // Allocate URB for RESET_PIPE request
    //
    pUrb = MyMemAlloc( sizeof(struct _URB_PIPE_REQUEST) );

    if( pUrb != NULL )
    {
		NdisZeroMemory( pUrb, sizeof (struct _URB_PIPE_REQUEST) );
		
		//
		// Initialize RESET_PIPE request URB
        //
        pUrb->UrbHeader.Length   = sizeof (struct _URB_PIPE_REQUEST);
        pUrb->UrbHeader.Function = URB_FUNCTION_RESET_PIPE;
        pUrb->UrbPipeRequest.PipeHandle = (USBD_PIPE_HANDLE)Pipe;
		
		//
        // Submit RESET_PIPE request URB
        //
        ntStatus = IrUsb_CallUSBD( pThisDev, pUrb );

		DEBUGCOND(DBG_ERR, !NT_SUCCESS(ntStatus),  (" IrUsb_ResetPipe RESET PIPE FAILED \n"));
		DEBUGCOND(DBG_ERR, NT_SUCCESS(ntStatus),  (" IrUsb_ResetPipe RESET PIPE SUCCEEDED \n"));
		
		//
        // Done with URB for RESET_PIPE request, free urb
        //
        MyMemFree( pUrb, sizeof(struct _URB_PIPE_REQUEST) );
    }
    else
    {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    DEBUGMSG(DBG_ERR, ("-IrUsb_ResetPipe %08X\n", ntStatus));
    return ntStatus;
}


/*****************************************************************************
*
*  Function:	MyKeWaitForSingleObject
*
*  Synopsis:	Wait with a timeout in a loop
*				so we will never hang if we are asked to halt/reset the driver while
*				pollingthread is waiting for something.
*
*  Arguments:	pThisDev - pointer to IR device
*				pEventWaitingFor - pointer to event to wait for
*				timeout100ns - timeout
*	
*  Returns:		NT status code
*
*  Notes:		THIS FUNCTION MUST BE RE-ENTERABLE!
*
*****************************************************************************/
NTSTATUS 
MyKeWaitForSingleObject(
		IN PIR_DEVICE pThisDev,
		IN PVOID pEventWaitingFor,
		LONGLONG timeout100ns
	)
{
    NTSTATUS		status = STATUS_SUCCESS;
    LARGE_INTEGER	Timeout;

	DEBUGMSG( DBG_FUNC,("+MyKeWaitForSingleObject\n "));
	
	if( timeout100ns ) 
	{   
		//
		//if a non-zero timeout was passed in, use it
		//
		Timeout.QuadPart = - ( timeout100ns );

	} 
	else 
	{
		// MS Security recommendation - changed back to 3 seconds because
		// timeout now for sure disables all processing.
		Timeout.QuadPart = -10000 * 1000 * 3; // default to 3 second relative delay
		//Timeout.QuadPart = -10000 * 1000; // default to 1 second relative delay
	}

	status = KeWaitForSingleObject( //keep this as standard wait
			pEventWaitingFor,
			Suspended,
			KernelMode,
			FALSE,
			&Timeout
		);


	DEBUGCOND( DBG_OUT,( STATUS_TIMEOUT == status ),(" MyKeWaitForSingleObject TIMED OUT\n"));
    DEBUGCOND( DBG_OUT,( STATUS_ALERTED == status ),(" MyKeWaitForSingleObject ALERTED\n"));
    DEBUGCOND( DBG_OUT,( STATUS_USER_APC == status ),(" MyKeWaitForSingleObject USER APC\n"));

    DEBUGMSG( DBG_FUNC,("-MyKeWaitForSingleObject  (%x)\n", status));
    return status;
}


/*****************************************************************************
*
*  Function:	PassiveLevelThread
*
*  Synopsis:	Thread running at IRQL PASSIVE_LEVEL.
*
*  Arguments:	Context - pointer to IR device
*
*  Returns:		None
*
*  Notes:
*
*  Any work item that can be called must be serialized.
*  i.e. when IrUsbReset is called, NDIS will not make any other
*       requests of the miniport until NdisMResetComplete is called.
*
*****************************************************************************/
VOID
PassiveLevelThread(
		IN OUT PVOID Context
	)
{
    LARGE_INTEGER	Timeout;
	int				i;
	PIR_WORK_ITEM	pWorkItem;
    PIR_DEVICE		pThisDev = (PIR_DEVICE)Context;
	NTSTATUS		Status=STATUS_SUCCESS;

    DEBUGMSG(DBG_WARN, ("+PassiveLevelThread\n"));  // change to FUNC later?
    DEBUGMSG(DBG_ERR, (" PassiveLevelThread: Starting\n"));

    KeSetPriorityThread( KeGetCurrentThread(), LOW_REALTIME_PRIORITY+1 );
    Timeout.QuadPart = -10000 * 1000 * 3; // 3 second relative delay
    while ( !pThisDev->fKillPassiveLevelThread )
    {
        Status=STATUS_SUCCESS;

        //
        // The eventPassiveThread is an auto-clearing event, so
        // we don't need to reset the event.
        //
        KeWaitForSingleObject( //keep this as standard wait
                   &pThisDev->EventPassiveThread,
                   Suspended,
                   KernelMode,
                   FALSE,
                   &Timeout
			);

        for( i = 0; i < NUM_WORK_ITEMS; i++ )
        {
			if( pThisDev->WorkItems[i].fInUse ) 
			{
				Status = pThisDev->WorkItems[i].Callback( &(pThisDev->WorkItems[i]) );

				if (Status == STATUS_TIMEOUT)
					break;
			}
        }
	} // while !fKill

	// MS Security recommendation - cannot cancel IRP on timeout, so we must exit
	if (Status == STATUS_TIMEOUT)
	{
		DEBUGMSG(DBG_ERR, (" PassiveLevelThread exits on TIMEOUT error\n"));
		IRUSB_ASSERT(0);
	}

    DEBUGMSG(DBG_ERR, (" PassiveLevelThread: HALT\n"));

    ZwClose(pThisDev->hPassiveThread);
    pThisDev->hPassiveThread = NULL;

    DEBUGMSG(DBG_WARN, ("-PassiveLevelThread\n")); // change to FUNC later?
    PsTerminateSystemThread( STATUS_SUCCESS );
}


/*****************************************************************************
*
*  Function:	PollingThread
*
*  Synopsis:	Thread running at IRQL PASSIVE_LEVEL.
*
*  Arguments:	Context - Pointer to IR device
*
*  Returns:		None
*
*  Algorithm:	
*				1) Call USBD for input data;
*				2) Call USBD for output data or sets a new speed;
*				
*  Notes:
*
*****************************************************************************/
VOID
PollingThread(
		IN OUT PVOID Context
    )
{
    PIR_DEVICE		pThisDev = (PIR_DEVICE)Context;
    NTSTATUS		Status = STATUS_SUCCESS;
 	PLIST_ENTRY		pListEntry;

	DEBUGMSG(DBG_WARN, ("+PollingThread\n"));  // change to FUNC later?
    DEBUGMSG(DBG_ERR, (" PollingThread: Starting\n"));

#ifdef LOW_PRIORITY_POLL
    //KeSetPriorityThread( KeGetCurrentThread(), LOW_REALTIME_PRIORITY );
#else
    KeSetPriorityThread( KeGetCurrentThread(), HIGH_PRIORITY );
#endif

    DEBUGMSG(DBG_ERR, (" PollingThread priority=%d\n",
		KeQueryPriorityThread(KeGetCurrentThread())));

	//
	// MS Security bug #539259
	// Note: all requests that end up sending URBs either called at init time only
	// or serialized through this thread. Therefore, it is safe to reuse the
	// EventSyncUrb event.
	//

    while( !pThisDev->fKillPollingThread )
	{
        if( pThisDev->fProcessing )
        {
			ULONG FifoCount;
			PIRUSB_CONTEXT pThisContext;
			BOOLEAN SentPackets;

			//
			// First process the receive
			//
			Status = ReceivePreprocessFifo( pThisDev, &FifoCount );
			if( Status != STATUS_SUCCESS )
			{
				//
				// There is a USB error, stop banging on the chip for a while
				//
				NdisMSleep( 1000 );    
			}
			else if( FifoCount )
			{
				//
				// Indicate that we are now receiving
				//
				InterlockedExchange( (PLONG)&pThisDev->fCurrentlyReceiving, TRUE );

				//
				// Tell the protocol that the media is now busy
				//
				if( pThisDev->fIndicatedMediaBusy == FALSE ) 
				{
					InterlockedExchange( &pThisDev->fMediaBusy, TRUE );
					InterlockedExchange( &pThisDev->fIndicatedMediaBusy, TRUE );
					IndicateMediaBusy( pThisDev ); 
				}

				ReceiveProcessFifoData( pThisDev );
			}
			else if( pThisDev->currentSpeed == SPEED_9600 )
			{
				NdisMSleep( 10*1000 );    
			}

			if (Status == STATUS_TIMEOUT)
				break;

			//
			// Then process the contexts that are ready
			//
			SentPackets = FALSE;
			do 
			{
				Status = STATUS_SUCCESS;
				pListEntry = ExInterlockedRemoveHeadList(  &pThisDev->SendBuiltQueue, &pThisDev->SendLock );
				if( pListEntry )
				{
					InterlockedDecrement( &pThisDev->SendBuiltCount );
					
					pThisContext = CONTAINING_RECORD( pListEntry, IRUSB_CONTEXT, ListEntry );
					
					switch( pThisContext->ContextType )
					{
						//
						// Packet to send
						//
						case CONTEXT_NDIS_PACKET:
							//
							// make sure the receive is cleaned
							//
							ReceiveResetPointers( pThisDev );

							//
							// Send
							//
							Status = SendPreprocessedPacketSend( pThisDev, pThisContext );
							if (Status != STATUS_TIMEOUT)
							{
								if( (pThisDev->ChipRevision >= CHIP_REVISION_7) &&
									(pThisDev->currentSpeed > MAX_MIR_SPEED) )
								{
									SentPackets = TRUE;
									Status = SendCheckForOverflow( pThisDev );
								}
								else
								{
									Status = SendWaitCompletion( pThisDev );
								}
							}
							break;
						//
						// Set the new speed
						//
						case CONTEXT_SET_SPEED:
							//
							// make sure the receive is cleaned
							//
							ReceiveResetPointers( pThisDev );

							//
							// Force completion and set
							//
							if( SentPackets )
							{
								SentPackets = TRUE;
								Status = SendWaitCompletion( pThisDev );
							}

							if (Status == STATUS_TIMEOUT)
								break;

							if( !pThisDev->fPendingHalt && !pThisDev->fPendingReset )
							{
								DEBUGMSG( DBG_ERR, (" Changing speed to: %d\n", pThisDev->linkSpeedInfo->BitsPerSec));
								Status = St4200SetSpeed( pThisDev );
								InterlockedExchange( (PLONG)&pThisDev->currentSpeed, pThisDev->linkSpeedInfo->BitsPerSec );
#if defined(DIAGS)
								if( !pThisDev->DiagsActive )
#endif
									MyNdisMSetInformationComplete( pThisDev, STATUS_SUCCESS );
							} 
							else 
							{
								DEBUGMSG( DBG_ERR , (" St4200SetSpeed DUMPING OUT on TIMEOUT,HALT OR RESET\n"));
#if defined(DIAGS)
								if( !pThisDev->DiagsActive )
#endif
									MyNdisMSetInformationComplete( pThisDev, STATUS_UNSUCCESSFUL );
							}
							ExInterlockedInsertTailList(
									&pThisDev->SendAvailableQueue,
									&pThisContext->ListEntry,
									&pThisDev->SendLock
								);
							InterlockedIncrement( &pThisDev->SendAvailableCount );
							break;
#if defined(DIAGS)
						//
						// Diagnostic state is enabled
						//
						case CONTEXT_DIAGS_ENABLE:
							Diags_CompleteEnable( pThisDev, pThisContext );
							break;
						//
						// Diagnostic read of the registers
						//
						case CONTEXT_DIAGS_READ_REGISTERS:
							Status = Diags_CompleteReadRegisters( pThisDev, pThisContext );
							break;
						//
						// Diagnostic write of the registers
						//
						case CONTEXT_DIAGS_WRITE_REGISTER:
							Status = Diags_CompleteWriteRegister( pThisDev, pThisContext );
							break;
						//
						// Diagnostic bulk out
						//
						case CONTEXT_DIAGS_BULK_OUT:
							Status = Diags_Bulk( pThisDev, pThisContext, TRUE );
							break;
						//
						// Diagnostic bulk in
						//
						case CONTEXT_DIAGS_BULK_IN:
							Status = Diags_Bulk( pThisDev, pThisContext, FALSE );
							break;
						//
						// Diagnostic bulk out
						//
						case CONTEXT_DIAGS_SEND:
							Status = Diags_Send( pThisDev, pThisContext );
							break;
#endif
					}
				}
				
				if (Status == STATUS_TIMEOUT)
					break;

			} while( pListEntry );
			
			if (Status == STATUS_TIMEOUT)
				break;

			//
			// Force to wait
			//
			if( SentPackets )
			{
				Status = SendWaitCompletion( pThisDev );
				if (Status == STATUS_TIMEOUT)
					break;
			}

		} // end if
		else
		{
			NdisMSleep( 10*1000 );
		}
    } // end while

	// MS Security recommendation - cannot cancel IRP on timeout, so we must exit
	if (Status == STATUS_TIMEOUT)
	{
		DEBUGMSG(DBG_ERR, (" PollingThread exits on TIMEOUT error\n"));
		IRUSB_ASSERT(0);
	}

    DEBUGMSG(DBG_ERR, (" PollingThread: HALT\n"));

    ZwClose(pThisDev->hPollingThread);
    pThisDev->hPollingThread = NULL;
	pThisDev->fProcessing = FALSE;

	//
    // this thread will finish here
    // if the terminate flag is TRUE
    //
    DEBUGMSG(DBG_WARN, ("-PollingThread\n"));  // change to FUNC later?
	PsTerminateSystemThread( STATUS_SUCCESS );
}


/*****************************************************************************
*
*  Function:	AllocUsbInfo
*
*  Synopsis:	Allocates the USB portion of the device context.
*
*  Arguments:	pThisDev - pointer to current ir device object
*	
*  Returns:		TRUE - Success
*				FALSE - Failure
*
*  Notes:
*
*****************************************************************************/
BOOLEAN 
AllocUsbInfo(
		IN OUT PIR_DEVICE pThisDev 
	)
{
	UINT Size = sizeof( IRUSB_USB_INFO );

	pThisDev->pUsbInfo = MyMemAlloc( Size );

	if( NULL == pThisDev->pUsbInfo ) 
	{
		return FALSE;
	}

    NdisZeroMemory( (PVOID)pThisDev->pUsbInfo, Size );
	return TRUE;
}


/*****************************************************************************
*
*  Function:	AllocUsbInfo
*
*  Synopsis:	Deallocates the USB portion of the device context.
*
*  Arguments:	pThisDev - pointer to current ir device object
*	
*  Returns:		None
*
*  Notes:
*
*****************************************************************************/
VOID 
FreeUsbInfo(
		IN OUT PIR_DEVICE pThisDev 
	)
{
	if( NULL != pThisDev->pUsbInfo ) 
	{
		//
		// Free device descriptor structure
		//
		if ( ((PIRUSB_USB_INFO)pThisDev->pUsbInfo)->UsbDeviceDescriptor ) 
		{
			MyMemFree( 
					((PIRUSB_USB_INFO)pThisDev->pUsbInfo)->UsbDeviceDescriptor,  
					sizeof(USB_DEVICE_DESCRIPTOR) 
				);
		}

		//
		// Free up the Usb Interface structure
		//
		if( ((PIRUSB_USB_INFO)pThisDev->pUsbInfo)->UsbInterface ) 
		{
			MyMemFree( 
					((PIRUSB_USB_INFO)pThisDev->pUsbInfo)->UsbInterface,
					((PIRUSB_USB_INFO)pThisDev->pUsbInfo)->UsbInterface->Length
				);
		}

		//
		// free up the USB config discriptor
		//
		if( ((PIRUSB_USB_INFO) pThisDev->pUsbInfo)->UsbConfigurationDescriptor )
		{
			MyMemFree( 
					((PIRUSB_USB_INFO)pThisDev->pUsbInfo)->UsbConfigurationDescriptor, 
					sizeof(USB_CONFIGURATION_DESCRIPTOR) + 512
				);
		}

		MyMemFree( (PVOID)pThisDev->pUsbInfo, sizeof(IRUSB_USB_INFO) );
	}
}


/*****************************************************************************
*
*  Function:	IrUsb_InitSendStructures
*
*  Synopsis:	Allocates the send stuff
*
*  Arguments:	pThisDev - pointer to IR device
*	
*  Returns:		TRUE if successful
*				FALSE otherwise
*
*  Notes:
*
*****************************************************************************/
BOOLEAN
IrUsb_InitSendStructures(
		IN OUT PIR_DEVICE pThisDev
	)
{

	BOOLEAN			InitResult = TRUE;
	PUCHAR			pThisContext;  
	PIRUSB_CONTEXT	pCont;
	int				i;

    DEBUGMSG(DBG_FUNC, ("+IrUsb_InitSendStructures\n"));
    
	//
    // Initialize a notification event for signalling PassiveLevelThread.
    //
    KeInitializeEvent(
			&pThisDev->EventPassiveThread,
			SynchronizationEvent, // auto-clearing event
			FALSE                 // event initially non-signalled
		);

#if defined(DIAGS)
    KeInitializeEvent(
            &pThisDev->EventDiags,
            NotificationEvent,    // non-auto-clearing event
            FALSE                 // event initially non-signalled
        );
#endif
	
	((PIRUSB_USB_INFO)pThisDev->pUsbInfo)->IrpSubmitUrb = NULL;

	//
	// allocate our send context structs
	//
	pThisDev->pSendContexts = MyMemAlloc( NUM_SEND_CONTEXTS * sizeof(IRUSB_CONTEXT) );

	if( NULL == pThisDev->pSendContexts ) 
	{
		InitResult = FALSE;
		goto done;
	}

	NdisZeroMemory( pThisDev->pSendContexts, NUM_SEND_CONTEXTS * sizeof(IRUSB_CONTEXT) );

	//
	//  Initialize list for holding pending read requests
    //
	InitializeListHead( &pThisDev->SendAvailableQueue );
    InitializeListHead( &pThisDev->SendBuiltQueue );
	InitializeListHead( &pThisDev->SendPendingQueue );
	KeInitializeSpinLock( &pThisDev->SendLock );

	//
	// Prepare the read/write specific queue
	//
	InitializeListHead( &pThisDev->ReadWritePendingQueue );

	pThisContext = pThisDev->pSendContexts;
	for ( i= 0; i < NUM_SEND_CONTEXTS; i++ ) 
	{
		pCont = (PIRUSB_CONTEXT)pThisContext;

		pCont->pThisDev = pThisDev;

		// Also put in the available queue
		ExInterlockedInsertTailList(
				&pThisDev->SendAvailableQueue,
				&pCont->ListEntry,
				&pThisDev->SendLock
			);

		pThisContext += sizeof( IRUSB_CONTEXT );

	} // for

	// MS Security issue - don't reuse urb
	// Single URB allocate removed.

	//
	// Send buffers
	//
	pThisDev->pBuffer = MyMemAlloc( MAX_IRDA_DATA_SIZE );
	if( NULL == pThisDev->pBuffer )
	{
		DEBUGMSG(DBG_ERR, (" IrUsb_InitSendStructures failed to alloc info buf\n"));

		InitResult = FALSE;
		goto done;
	}

	pThisDev->pStagingBuffer = MyMemAlloc( MAX_TOTAL_SIZE_WITH_ALL_HEADERS + FAST_IR_FCS_SIZE );
	if( NULL == pThisDev->pStagingBuffer )
	{
		DEBUGMSG(DBG_ERR, (" IrUsb_InitSendStructures failed to alloc staging buf\n"));

		InitResult = FALSE;
		goto done;
	}

	//
	// and send counts
	//
	pThisDev->SendAvailableCount = NUM_SEND_CONTEXTS;
	pThisDev->SendBuiltCount = 0;
	pThisDev->SendPendingCount = 0;
	pThisDev->ReadWritePendingCount = 0;
	pThisDev->SendFifoCount =  0;

done:
    DEBUGMSG(DBG_FUNC, ("-IrUsb_InitSendStructures\n"));
	return InitResult;
}


/*****************************************************************************
*
*  Function:	IrUsb_FreeSendStructures
*
*  Synopsis:	Deallocates the send stuff
*
*  Arguments:	pThisDev - pointer to IR device
*	
*  Returns:		None
*
*  Notes:
*
*****************************************************************************/
VOID
IrUsb_FreeSendStructures(
		IN OUT PIR_DEVICE pThisDev
	)
{
    DEBUGMSG(DBG_FUNC, ("+IrUsb_FreeSendStructures\n"));

	if( NULL != pThisDev->pSendContexts ) 
	{
		MyMemFree( pThisDev->pSendContexts, NUM_SEND_CONTEXTS * sizeof(IRUSB_CONTEXT) );
		pThisDev->pSendContexts = NULL;

	} 

	if( NULL != pThisDev->pBuffer )
	{
		MyMemFree( pThisDev->pBuffer, MAX_IRDA_DATA_SIZE );
		pThisDev->pBuffer = NULL;
	}

	if( NULL != pThisDev->pStagingBuffer )
	{
		MyMemFree( pThisDev->pStagingBuffer, MAX_TOTAL_SIZE_WITH_ALL_HEADERS + FAST_IR_FCS_SIZE );
		pThisDev->pStagingBuffer = NULL;
	}

    DEBUGMSG(DBG_FUNC, ("-IrUsb_FreeSendStructures\n"));
}


/*****************************************************************************
*
*  Function:	IrUsb_PrepareSetSpeed
*
*  Synopsis:	Prepares a context to set the new speed
*
*  Arguments:	pThisDev - pointer to IR device
*	
*  Returns:		None
*
*  Notes:
*
*****************************************************************************/
VOID
IrUsb_PrepareSetSpeed(
		IN OUT PIR_DEVICE pThisDev
	)
{
	PIRUSB_CONTEXT		pThisContext;
	PLIST_ENTRY			pListEntry;

    DEBUGMSG( DBG_FUNC, ("+IrUsb_PrepareSetSpeed()\n"));

	//
	// Get a context to queue
	//
	pListEntry = ExInterlockedRemoveHeadList( &pThisDev->SendAvailableQueue, &pThisDev->SendLock );

	if( NULL == pListEntry )
    {
        //
		// This must not happen
		//
        DEBUGMSG(DBG_ERR, (" IrUsb_PrepareSetSpeed failed to find a free context struct\n"));
		IRUSB_ASSERT( 0 );
        
		goto done;
    }
	
	InterlockedDecrement( &pThisDev->SendAvailableCount );

	pThisContext = CONTAINING_RECORD( pListEntry, IRUSB_CONTEXT, ListEntry );
	pThisContext->ContextType = CONTEXT_SET_SPEED;
	
	//
	// Queue the context and nothing else has to be done 
	//
	ExInterlockedInsertTailList(
			&pThisDev->SendBuiltQueue,
			&pThisContext->ListEntry,
			&pThisDev->SendLock
		);
	InterlockedIncrement( &pThisDev->SendBuiltCount );

done:
    DEBUGMSG( DBG_FUNC, ("-IrUsb_PrepareSetSpeed()\n"));
}


/*****************************************************************************
*
*  Function:	IrUsb_IncIoCount
*
*  Synopsis:	Tracks count of pending irps
*
*  Arguments:	pThisDev - pointer to IR device
*	
*  Returns:		None
*
*  Notes:
*
*****************************************************************************/
VOID
IrUsb_IncIoCount(
		IN OUT PIR_DEVICE  pThisDev
	)
{
	InterlockedIncrement( &pThisDev->PendingIrpCount );
}


/*****************************************************************************
*
*  Function:	IrUsb_DecIoCount
*
*  Synopsis:	Tracks count of pending irps
*
*  Arguments:	pThisDev - pointer to IR device
*	
*  Returns:		None
*
*  Notes:
*
*****************************************************************************/
VOID
IrUsb_DecIoCount(
		IN OUT PIR_DEVICE  pThisDev
	)
{
	InterlockedDecrement( &pThisDev->PendingIrpCount );
}


/*****************************************************************************
*
*  Function:	AllocXferUrb
*
*  Synopsis:	Allocates the transfer Urb for a USB transaction
*
*  Arguments:	None
*	
*  Returns:		Pointer to Urb
*
*  Notes:
*
*****************************************************************************/
PVOID
AllocXferUrb( 
		VOID 
	)
{
	return MyMemAlloc( sizeof(struct _URB_BULK_OR_INTERRUPT_TRANSFER) );
}


/*****************************************************************************
*
*  Function:	FreeXferUrb
*
*  Synopsis:	Deallocates the transfer Urb for a USB transaction
*
*  Arguments:	pUrb - pointer to Urb
*	
*  Returns:		Pointer to Urb
*
*  Notes:
*
*****************************************************************************/
VOID
FreeXferUrb( 
		IN OUT PVOID pUrb 
	)
{
	MyMemFree( pUrb, sizeof(struct _URB_BULK_OR_INTERRUPT_TRANSFER) );
}

/*****************************************************************************
*
*  Function:	ReadCustomerData
*
*  Synopsis:	Read customer data block from chip.
*
*  Arguments:	Pointer to device.
*	
*  Returns:		STATUS_SUCCESS if any data is read.
*
*  Notes:
*
*****************************************************************************/
NTSTATUS
ReadCustomerData(
		IN OUT PIR_DEVICE pThisDev
	)
{
#define SIZE_FAKE_SEND 6
	
	UCHAR pDataSend[SIZE_FAKE_SEND]={0x55,0xaa,SIZE_FAKE_SEND-4,0x00,0xff,0xff};
	BAUDRATE_INFO *SavedLinkSpeedInfo;
	UCHAR SavedSensitivity;
	UCHAR SavedControlReg;
	NTSTATUS ntStatus;

	//
	// Set the speed to 9600.
	//
	SavedLinkSpeedInfo = pThisDev->linkSpeedInfo;
	pThisDev->linkSpeedInfo = &supportedBaudRateTable[BAUDRATE_9600];
	ntStatus = St4200SetSpeed( pThisDev );
	DEBUGCOND( DBG_ERR,!NT_SUCCESS(ntStatus),(" ReadCustomerData set speed FAILURE (%x)\n", ntStatus));
	pThisDev->linkSpeedInfo = SavedLinkSpeedInfo;
	
	//
	// Set the sensitivity.
	//
	SavedSensitivity = pThisDev->StIrTranceiver.SensitivityReg;
	pThisDev->StIrTranceiver.SensitivityReg = 0x0f;
    ntStatus = St4200WriteRegister(pThisDev, STIR4200_SENSITIVITY_REG);
	DEBUGCOND( DBG_ERR,!NT_SUCCESS(ntStatus),(" ReadCustomerData set sensitivity FAILURE (%x)\n", ntStatus));
	pThisDev->StIrTranceiver.SensitivityReg = SavedSensitivity;

	//
	// Select RXSLOW.
	//
	SavedControlReg = pThisDev->StIrTranceiver.ControlReg;
    pThisDev->StIrTranceiver.ControlReg |= STIR4200_CTRL_RXSLOW;
    ntStatus = St4200WriteRegister(pThisDev, STIR4200_CONTROL_REG);
	DEBUGCOND( DBG_ERR,!NT_SUCCESS(ntStatus),(" ReadCustomerData set rxslow FAILURE (%x)\n", ntStatus));
    pThisDev->StIrTranceiver.ControlReg = SavedControlReg;

	//
	// Send a bulk-out transfer to trigger the device to make the customer data available.
	//
	ntStatus = St4200FakeSend(
		pThisDev,
		pDataSend,
		SIZE_FAKE_SEND
		);
	if (!NT_SUCCESS(ntStatus))
		return ntStatus;
	
	//
	// Wait until uP fills up usb pipe with customer data, about 1 millisecond per byte.
	//
	NdisMSleep( 1000*STIR4200_CUST_DATA_SIZE );

	//
	// Issue bulk read to get all the customer data.
	//
	ntStatus = St4200FakeReceive(
		pThisDev,
		pThisDev->pCustomerData,
		STIR4200_CUST_DATA_SIZE
		);
	if (!NT_SUCCESS(ntStatus))
		return ntStatus;

#if 0
#if DBG
	{
		int i;
		for (i = 0; i < STIR4200_CUST_DATA_SIZE; i++)
		{
			DbgPrint("%02x ", pThisDev->pCustomerData[i]);
			if (((i+1) % 16) == 0)
				DbgPrint("\n");
		}
		DbgPrint("\n\n");
	}
#endif
#endif

	//
	// If data starts with 7e7e then it is valid customer data and we will
	// send it to the app when requested. Otherwise clear the customer data
	// buffer.
	//
	if (!(pThisDev->pCustomerData[0] == 0x7e && pThisDev->pCustomerData[1] == 0x7e))
		NdisZeroMemory(pThisDev->pCustomerData, STIR4200_CUST_DATA_SIZE);

	return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\net\ms\e100bex\e100_def.h ===
#ifndef _E100_DEF_H_
#define _E100_DEF_H_

//-------------------------------------------------------------------------
// NON_TRANSMIT_CB -- Generic Non-Transmit Command Block
//-------------------------------------------------------------------------
typedef struct _NON_TRANSMIT_CB
{
    union
    {
        MULTICAST_CB_STRUC  Multicast;
        CONFIG_CB_STRUC     Config;
        IA_CB_STRUC         Setup;
        DUMP_CB_STRUC       Dump;
        FILTER_CB_STRUC     Filter;
    }   NonTxCb;

} NON_TRANSMIT_CB, *PNON_TRANSMIT_CB;

//-------------------------------------------------------------------------
// WMI header file e100_wmi.h, generated by wmimofck utility from e100.bmf
//-------------------------------------------------------------------------

//#include "e100_wmi.h"

#endif //_E100_DEF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\net\ms\e100bex\e100_557.h ===
/****************************************************************************
** COPYRIGHT (C) 1994-1997 INTEL CORPORATION                               **
** DEVELOPED FOR MICROSOFT BY INTEL CORP., HILLSBORO, OREGON               **
** HTTP://WWW.INTEL.COM/                                                   **
** THIS FILE IS PART OF THE INTEL ETHEREXPRESS PRO/100B(TM) AND            **
** ETHEREXPRESS PRO/100+(TM) NDIS 5.0 MINIPORT SAMPLE DRIVER               **
****************************************************************************/

/****************************************************************************
Module Name:
    e100_557.h  (82557.h)

This driver runs on the following hardware:
    - 82558 based PCI 10/100Mb ethernet adapters
    (aka Intel EtherExpress(TM) PRO Adapters)

Environment:
    Kernel Mode - Or whatever is the equivalent on WinNT

Revision History
    - JCB 8/14/97 Example Driver Created
    - Dchen 11-01-99    Modified for the new sample driver
*****************************************************************************/

#ifndef _E100_557_H
#define _E100_557_H

//-------------------------------------------------------------------------
// D100 Stepping Defines
//-------------------------------------------------------------------------
#define D100_A_STEP                 0   // NEVER SHIPPED
#define D100_B_STEP                 1   // d100 first shipped silicon
#define D100_C_STEP                 2   // d100' (c-step) with vendor/id and hw fix
#define D101_A_STEP                 4   // first silicon of d101

//-------------------------------------------------------------------------
// E100 Stepping Defines - used in PoMgmt Decisions
//-------------------------------------------------------------------------
#define E100_82557_A_STEP   1
#define E100_82557_B_STEP   2
#define E100_82557_C_STEP   3
#define E100_82558_A_STEP   4
#define E100_82558_B_STEP   5
#define E100_82559_A_STEP   6
#define E100_82559_B_STEP   7
#define E100_82559_C_STEP   8
#define E100_82559ER_A_STEP 9

//-------------------------------------------------------------------------
// D100 PORT functions -- lower 4 bits
//-------------------------------------------------------------------------
#define PORT_SOFTWARE_RESET         0
#define PORT_SELFTEST               1
#define PORT_SELECTIVE_RESET        2
#define PORT_DUMP                   3


//-------------------------------------------------------------------------
// CSR field definitions -- Offsets from CSR base
//-------------------------------------------------------------------------
#define SCB_STATUS_LOW_BYTE         0x0
#define SCB_STATUS_HIGH_BYTE        0x1
#define SCB_COMMAND_LOW_BYTE        0x2
#define SCB_COMMAND_HIGH_BYTE       0x3
#define SCB_GENERAL_POINTER         0x4
#define CSR_PORT_LOW_WORD           0x8
#define CSR_PORT_HIGH_WORD          0x0a
#define CSR_FLASH_CONTROL_REG       0x0c
#define CSR_EEPROM_CONTROL_REG      0x0e
#define CSR_MDI_CONTROL_LOW_WORD    0x10
#define CSR_MDI_CONTROL_HIGH_WORD   0x12


//-------------------------------------------------------------------------
// SCB Status Word bit definitions
//-------------------------------------------------------------------------
//- Interrupt status fields
#define SCB_STATUS_MASK         BIT_12_15       // ACK Mask
#define SCB_STATUS_CX           BIT_15          // CU Completed Action Cmd
#define SCB_STATUS_FR           BIT_14          // RU Received A Frame
#define SCB_STATUS_CNA          BIT_13          // CU Became Inactive (IDLE)
#define SCB_STATUS_RNR          BIT_12          // RU Became Not Ready
#define SCB_STATUS_MDI          BIT_11          // MDI read or write done
#define SCB_STATUS_SWI          BIT_10          // Software generated interrupt

//- Interrupt ACK fields
#define SCB_ACK_MASK            (BIT_9 | BIT_12_15 | BIT_8)   // ACK Mask
#define SCB_ALL_INTERRUPT_BITS  BIT_8_15                      // if all the bits are set, no interrupt to be served
#define SCB_ACK_CX              BIT_15          // CU Completed Action Cmd
#define SCB_ACK_FR              BIT_14          // RU Received A Frame
#define SCB_ACK_CNA             BIT_13          // CU Became Inactive (IDLE)
#define SCB_ACK_RNR             BIT_12          // RU Became Not Ready
#define SCB_ACK_MDI             BIT_11          // MDI read or write done
#define SCB_ACK_SWI             BIT_10          // Software generated interrupt
#define SCB_ACK_ER              BIT_9           // Early Receive interrupt
#define SCB_ACK_FCP             BIT_8           // Flow Control Pause interrupt

//- CUS Fields
#define SCB_CUS_MASK            (BIT_6 | BIT_7) // CUS 2-bit Mask
#define SCB_CUS_IDLE            0               // CU Idle
#define SCB_CUS_SUSPEND         BIT_6           // CU Suspended
#define SCB_CUS_ACTIVE          BIT_7           // CU Active

//- RUS Fields
#define SCB_RUS_IDLE            0               // RU Idle
#define SCB_RUS_MASK            BIT_2_5         // RUS 3-bit Mask
#define SCB_RUS_SUSPEND         BIT_2           // RU Suspended
#define SCB_RUS_NO_RESOURCES    BIT_3           // RU Out Of Resources
#define SCB_RUS_READY           BIT_4           // RU Ready
#define SCB_RUS_SUSP_NO_RBDS    (BIT_2 | BIT_5) // RU No More RBDs
#define SCB_RUS_NO_RBDS         (BIT_3 | BIT_5) // RU No More RBDs
#define SCB_RUS_READY_NO_RBDS   (BIT_4 | BIT_5) // RU Ready, No RBDs


//-------------------------------------------------------------------------
// SCB Command Word bit definitions
//-------------------------------------------------------------------------
//- CUC fields
#define SCB_CUC_MASK            BIT_4_6         // CUC 3-bit Mask
#define SCB_CUC_START           BIT_4           // CU Start
#define SCB_CUC_RESUME          BIT_5           // CU Resume
#define SCB_CUC_DUMP_ADDR       BIT_6           // CU Dump Counters Address
#define SCB_CUC_DUMP_STAT       (BIT_4 | BIT_6) // CU Dump statistics counters
#define SCB_CUC_LOAD_BASE       (BIT_5 | BIT_6) // Load the CU base
#define SCB_CUC_DUMP_RST_STAT   BIT_4_6         // CU Dump and reset statistics counters
#define SCB_CUC_STATIC_RESUME   (BIT_5 | BIT_7) // CU Static Resume

//- RUC fields
#define SCB_RUC_MASK            BIT_0_2         // RUC 3-bit Mask
#define SCB_RUC_START           BIT_0           // RU Start
#define SCB_RUC_RESUME          BIT_1           // RU Resume
#define SCB_RUC_ABORT           BIT_2           // RU Abort
#define SCB_RUC_LOAD_HDS        (BIT_0 | BIT_2) // Load RFD Header Data Size
#define SCB_RUC_LOAD_BASE       (BIT_1 | BIT_2) // Load the RU base
#define SCB_RUC_RBD_RESUME      BIT_0_2         // RBD resume

// Interrupt fields (assuming byte addressing)
#define SCB_INT_MASK            BIT_0           // Mask interrupts
#define SCB_SOFT_INT            BIT_1           // Generate a software interrupt


//-------------------------------------------------------------------------
// EEPROM bit definitions
//-------------------------------------------------------------------------
//- EEPROM control register bits
#define EN_TRNF                     0x10    // Enable turnoff
#define EEDO                        0x08    // EEPROM data out
#define EEDI                        0x04    // EEPROM data in (set for writing data)
#define EECS                        0x02    // EEPROM chip select (1=high, 0=low)
#define EESK                        0x01    // EEPROM shift clock (1=high, 0=low)

//- EEPROM opcodes
#define EEPROM_READ_OPCODE          06
#define EEPROM_WRITE_OPCODE         05
#define EEPROM_ERASE_OPCODE         07
#define EEPROM_EWEN_OPCODE          19      // Erase/write enable
#define EEPROM_EWDS_OPCODE          16      // Erase/write disable

//- EEPROM data locations
#define EEPROM_NODE_ADDRESS_BYTE_0  0
#define EEPROM_FLAGS_WORD_3         3
#define EEPROM_FLAG_10MC            BIT_0
#define EEPROM_FLAG_100MC           BIT_1

//-------------------------------------------------------------------------
// MDI Control register bit definitions
//-------------------------------------------------------------------------
#define MDI_DATA_MASK           BIT_0_15        // MDI Data port
#define MDI_REG_ADDR            BIT_16_20       // which MDI register to read/write
#define MDI_PHY_ADDR            BIT_21_25       // which PHY to read/write
#define MDI_PHY_OPCODE          BIT_26_27       // which PHY to read/write
#define MDI_PHY_READY           BIT_28          // PHY is ready for another MDI cycle
#define MDI_PHY_INT_ENABLE      BIT_29          // Assert INT at MDI cycle completion


//-------------------------------------------------------------------------
// MDI Control register opcode definitions
//-------------------------------------------------------------------------
#define MDI_WRITE               1               // Phy Write
#define MDI_READ                2               // Phy read


//-------------------------------------------------------------------------
// D100 Action Commands
//-------------------------------------------------------------------------
#define CB_NOP                  0
#define CB_IA_ADDRESS           1
#define CB_CONFIGURE            2
#define CB_MULTICAST            3
#define CB_TRANSMIT             4
#define CB_LOAD_MICROCODE       5
#define CB_DUMP                 6
#define CB_DIAGNOSE             7


//-------------------------------------------------------------------------
// Command Block (CB) Field Definitions
//-------------------------------------------------------------------------
//- CB Command Word
#define CB_EL_BIT               BIT_15          // CB EL Bit
#define CB_S_BIT                BIT_14          // CB Suspend Bit
#define CB_I_BIT                BIT_13          // CB Interrupt Bit
#define CB_TX_SF_BIT            BIT_3           // TX CB Flexible Mode
#define CB_CMD_MASK             BIT_0_2         // CB 3-bit CMD Mask

//- CB Status Word
#define CB_STATUS_MASK          BIT_12_15       // CB Status Mask (4-bits)
#define CB_STATUS_COMPLETE      BIT_15          // CB Complete Bit
#define CB_STATUS_OK            BIT_13          // CB OK Bit
#define CB_STATUS_UNDERRUN      BIT_12          // CB A Bit
#define CB_STATUS_FAIL          BIT_11          // CB Fail (F) Bit

//misc command bits
#define CB_TX_EOF_BIT           BIT_15          // TX CB/TBD EOF Bit

//-------------------------------------------------------------------------
// Config CB Parameter Fields
//-------------------------------------------------------------------------
#define CB_CFIG_BYTE_COUNT          22          // 22 config bytes
#define CB_SHORT_CFIG_BYTE_COUNT    8           // 8 config bytes

// byte 0 bit definitions
#define CB_CFIG_BYTE_COUNT_MASK     BIT_0_5     // Byte count occupies bit 5-0

// byte 1 bit definitions
#define CB_CFIG_RXFIFO_LIMIT_MASK   BIT_0_4     // RxFifo limit mask
#define CB_CFIG_TXFIFO_LIMIT_MASK   BIT_4_7     // TxFifo limit mask

// byte 3 bit definitions --
#define CB_CFIG_B3_MWI_ENABLE       BIT_0       // Memory Write Invalidate Enable Bit

// byte 4 bit definitions
#define CB_CFIG_RX_MIN_DMA_MASK     BIT_0_6     // Rx minimum DMA count mask

// byte 5 bit definitions
#define CB_CFIG_TX_MIN_DMA_MASK     BIT_0_6     // Tx minimum DMA count mask
#define CB_CFIG_DMBC_EN             BIT_7       // Enable Tx/Rx minimum DMA counts

// byte 6 bit definitions
#define CB_CFIG_LATE_SCB            BIT_0       // Update SCB After New Tx Start
#define CB_CFIG_TNO_INT             BIT_2       // Tx Not OK Interrupt
#define CB_CFIG_CI_INT              BIT_3       // Command Complete Interrupt
#define CB_CFIG_SAVE_BAD_FRAMES     BIT_7       // Save Bad Frames Enabled

// byte 7 bit definitions
#define CB_CFIG_DISC_SHORT_FRAMES   BIT_0       // Discard Short Frames
#define CB_CFIG_URUN_RETRY          BIT_1_2     // Underrun Retry Count

// byte 8 bit definitions
#define CB_CFIG_503_MII             BIT_0       // 503 vs. MII mode

// byte 9 bit definitions -- pre-defined all zeros

// byte 10 bit definitions
#define CB_CFIG_NO_SRCADR           BIT_3       // No Source Address Insertion
#define CB_CFIG_PREAMBLE_LEN        BIT_4_5     // Preamble Length
#define CB_CFIG_LOOPBACK_MODE       BIT_6_7     // Loopback Mode

// byte 11 bit definitions
#define CB_CFIG_LINEAR_PRIORITY     BIT_0_2     // Linear Priority

// byte 12 bit definitions
#define CB_CFIG_LINEAR_PRI_MODE     BIT_0       // Linear Priority mode
#define CB_CFIG_IFS_MASK            BIT_4_7     // CSMA level Interframe Spacing mask

// byte 13 bit definitions -- pre-defined all zeros

// byte 14 bit definitions -- pre-defined 0xf2

// byte 15 bit definitions
#define CB_CFIG_PROMISCUOUS         BIT_0       // Promiscuous Mode Enable
#define CB_CFIG_BROADCAST_DIS       BIT_1       // Broadcast Mode Disable
#define CB_CFIG_CRS_OR_CDT          BIT_7       // CRS Or CDT

// byte 16 bit definitions -- pre-defined all zeros

// byte 17 bit definitions -- pre-defined 0x40

// byte 18 bit definitions
#define CB_CFIG_STRIPPING           BIT_0       // Stripping Disabled
#define CB_CFIG_PADDING             BIT_1       // Padding Disabled
#define CB_CFIG_CRC_IN_MEM          BIT_2       // Transfer CRC To Memory

// byte 19 bit definitions
#define CB_CFIG_FORCE_FDX           BIT_6       // Force Full Duplex
#define CB_CFIG_FDX_ENABLE          BIT_7       // Full Duplex Enabled

// byte 20 bit definitions
#define CB_CFIG_MULTI_IA            BIT_6       // Multiple IA Addr

// byte 21 bit definitions
#define CB_CFIG_MULTICAST_ALL       BIT_3       // Multicast All


//-------------------------------------------------------------------------
// Receive Frame Descriptor Fields
//-------------------------------------------------------------------------

//- RFD Status Bits
#define RFD_RECEIVE_COLLISION   BIT_0           // Collision detected on Receive
#define RFD_IA_MATCH            BIT_1           // Indv Address Match Bit
#define RFD_RX_ERR              BIT_4           // RX_ERR pin on Phy was set
#define RFD_FRAME_TOO_SHORT     BIT_7           // Receive Frame Short
#define RFD_DMA_OVERRUN         BIT_8           // Receive DMA Overrun
#define RFD_NO_RESOURCES        BIT_9           // No Buffer Space
#define RFD_ALIGNMENT_ERROR     BIT_10          // Alignment Error
#define RFD_CRC_ERROR           BIT_11          // CRC Error
#define RFD_STATUS_OK           BIT_13          // RFD OK Bit
#define RFD_STATUS_COMPLETE     BIT_15          // RFD Complete Bit

//- RFD Command Bits
#define RFD_EL_BIT              BIT_15          // RFD EL Bit
#define RFD_S_BIT               BIT_14          // RFD Suspend Bit
#define RFD_H_BIT               BIT_4           // Header RFD Bit
#define RFD_SF_BIT              BIT_3           // RFD Flexible Mode

//- RFD misc bits
#define RFD_EOF_BIT             BIT_15          // RFD End-Of-Frame Bit
#define RFD_F_BIT               BIT_14          // RFD Buffer Fetch Bit
#define RFD_ACT_COUNT_MASK      BIT_0_13        // RFD Actual Count Mask
#define RFD_HEADER_SIZE         0x10            // Size of RFD Header (16 bytes)

//-------------------------------------------------------------------------
// Receive Buffer Descriptor Fields
//-------------------------------------------------------------------------
#define RBD_EOF_BIT             BIT_15          // RBD End-Of-Frame Bit
#define RBD_F_BIT               BIT_14          // RBD Buffer Fetch Bit
#define RBD_ACT_COUNT_MASK      BIT_0_13        // RBD Actual Count Mask

#define SIZE_FIELD_MASK         BIT_0_13        // Size of the associated buffer
#define RBD_EL_BIT              BIT_15          // RBD EL Bit


//-------------------------------------------------------------------------
// Size Of Dump Buffer
//-------------------------------------------------------------------------
#define DUMP_BUFFER_SIZE            600         // size of the dump buffer


//-------------------------------------------------------------------------
// Self Test Results
//-------------------------------------------------------------------------
#define CB_SELFTEST_FAIL_BIT        BIT_12
#define CB_SELFTEST_DIAG_BIT        BIT_5
#define CB_SELFTEST_REGISTER_BIT    BIT_3
#define CB_SELFTEST_ROM_BIT         BIT_2

#define CB_SELFTEST_ERROR_MASK ( \
                CB_SELFTEST_FAIL_BIT | CB_SELFTEST_DIAG_BIT | \
                CB_SELFTEST_REGISTER_BIT | CB_SELFTEST_ROM_BIT)


//-------------------------------------------------------------------------
// Driver Configuration Default Parameters for the 557
//  Note: If the driver uses any defaults that are different from the chip's
//        defaults, it will be noted below
//-------------------------------------------------------------------------
// Byte 0 (byte count) default
#define CB_557_CFIG_DEFAULT_PARM0   CB_CFIG_BYTE_COUNT

// Byte 1 (fifo limits) default
#define DEFAULT_TX_FIFO_LIMIT       0x08
#define DEFAULT_RX_FIFO_LIMIT       0x08
#define CB_557_CFIG_DEFAULT_PARM1   0x88

// Byte 2 (IFS) default
#define CB_557_CFIG_DEFAULT_PARM2   0x00

// Byte 3 (reserved) default
#define CB_557_CFIG_DEFAULT_PARM3   0x00

// Byte 4 (Rx DMA min count) default
#define CB_557_CFIG_DEFAULT_PARM4   0x00

// Byte 5 (Tx DMA min count, DMA min count enable) default
#define CB_557_CFIG_DEFAULT_PARM5   0x00

// Byte 6 (Late SCB, TNO int, CI int, Save bad frames) default
#define CB_557_CFIG_DEFAULT_PARM6   0x32

// Byte 7 (Discard short frames, underrun retry) default
//          note: disc short frames will be enabled
#define DEFAULT_UNDERRUN_RETRY      0x01
#define CB_557_CFIG_DEFAULT_PARM7   0x01

// Byte 8 (MII or 503) default
//          note: MII will be the default
#define CB_557_CFIG_DEFAULT_PARM8   0x01

// Byte 9 - Power management for 82558B, 82559
#define CB_WAKE_ON_LINK_BYTE9 0x20
#define CB_WAKE_ON_ARP_PKT_BYTE9 0x40

#define CB_557_CFIG_DEFAULT_PARM9   0 

// Byte 10 (scr addr insertion, preamble, loopback) default
#define CB_557_CFIG_DEFAULT_PARM10  0x2e

// Byte 11 (linear priority) default
#define CB_557_CFIG_DEFAULT_PARM11  0x00

// Byte 12 (IFS,linear priority mode) default
#define CB_557_CFIG_DEFAULT_PARM12  0x60

// Byte 13 (reserved) default
#define CB_557_CFIG_DEFAULT_PARM13  0x00

// Byte 14 (reserved) default
#define CB_557_CFIG_DEFAULT_PARM14  0xf2

// Byte 15 (promiscuous, broadcast, CRS/CDT) default
#define CB_557_CFIG_DEFAULT_PARM15  0xea

// Byte 16 (reserved) default
#define CB_557_CFIG_DEFAULT_PARM16  0x00

// Byte 17 (reserved) default
#define CB_557_CFIG_DEFAULT_PARM17  0x40

// Byte 18 (Stripping, padding, Rcv CRC in mem) default
//          note: padding will be enabled
#define CB_557_CFIG_DEFAULT_PARM18  0xf2

// Byte 19 (reserved) default
//          note: full duplex is enabled if FDX# pin is 0
#define CB_557_CFIG_DEFAULT_PARM19  0x80

// Byte 20 (multi-IA) default
#define CB_557_CFIG_DEFAULT_PARM20  0x3f

// Byte 21 (multicast all) default
#define CB_557_CFIG_DEFAULT_PARM21  0x05


#pragma pack(1)

//-------------------------------------------------------------------------
// Ethernet Frame Structure
//-------------------------------------------------------------------------
//- Ethernet 6-byte Address
typedef struct _ETH_ADDRESS_STRUC {
    UCHAR       EthNodeAddress[ETHERNET_ADDRESS_LENGTH];
} ETH_ADDRESS_STRUC, *PETH_ADDRESS_STRUC;


//- Ethernet 14-byte Header
typedef struct _ETH_HEADER_STRUC {
    UCHAR       Destination[ETHERNET_ADDRESS_LENGTH];
    UCHAR       Source[ETHERNET_ADDRESS_LENGTH];
    USHORT      TypeLength;
} ETH_HEADER_STRUC, *PETH_HEADER_STRUC;


//- Ethernet Buffer (Including Ethernet Header) for Transmits
typedef struct _ETH_TX_BUFFER_STRUC {
    ETH_HEADER_STRUC    TxMacHeader;
    UCHAR               TxBufferData[(TCB_BUFFER_SIZE - sizeof(ETH_HEADER_STRUC))];
} ETH_TX_BUFFER_STRUC, *PETH_TX_BUFFER_STRUC;

typedef struct _ETH_RX_BUFFER_STRUC {
    ETH_HEADER_STRUC    RxMacHeader;
    UCHAR               RxBufferData[(RCB_BUFFER_SIZE - sizeof(ETH_HEADER_STRUC))];
} ETH_RX_BUFFER_STRUC, *PETH_RX_BUFFER_STRUC;



//-------------------------------------------------------------------------
// 82557 Data Structures
//-------------------------------------------------------------------------

//-------------------------------------------------------------------------
// Self test
//-------------------------------------------------------------------------
typedef struct _SELF_TEST_STRUC {
    ULONG       StSignature;            // Self Test Signature
    ULONG       StResults;              // Self Test Results
} SELF_TEST_STRUC, *PSELF_TEST_STRUC;


//-------------------------------------------------------------------------
// Control/Status Registers (CSR)
//-------------------------------------------------------------------------
typedef struct _CSR_STRUC {
    USHORT      ScbStatus;              // SCB Status register
    UCHAR       ScbCommandLow;          // SCB Command register (low byte)
    UCHAR       ScbCommandHigh;         // SCB Command register (high byte)
    ULONG       ScbGeneralPointer;      // SCB General pointer
    ULONG       Port;                   // PORT register
    USHORT      FlashControl;           // Flash Control register
    USHORT      EepromControl;          // EEPROM control register
    ULONG       MDIControl;             // MDI Control Register
    ULONG       RxDMAByteCount;         // Receive DMA Byte count register
} CSR_STRUC, *PCSR_STRUC;

//-------------------------------------------------------------------------
// Error Counters
//-------------------------------------------------------------------------
typedef struct _ERR_COUNT_STRUC {
    ULONG       XmtGoodFrames;          // Good frames transmitted
    ULONG       XmtMaxCollisions;       // Fatal frames -- had max collisions
    ULONG       XmtLateCollisions;      // Fatal frames -- had a late coll.
    ULONG       XmtUnderruns;           // Transmit underruns (fatal or re-transmit)
    ULONG       XmtLostCRS;             // Frames transmitted without CRS
    ULONG       XmtDeferred;            // Deferred transmits
    ULONG       XmtSingleCollision;     // Transmits that had 1 and only 1 coll.
    ULONG       XmtMultCollisions;      // Transmits that had multiple coll.
    ULONG       XmtTotalCollisions;     // Transmits that had 1+ collisions.
    ULONG       RcvGoodFrames;          // Good frames received
    ULONG       RcvCrcErrors;           // Aligned frames that had a CRC error
    ULONG       RcvAlignmentErrors;     // Receives that had alignment errors
    ULONG       RcvResourceErrors;      // Good frame dropped due to lack of resources
    ULONG       RcvOverrunErrors;       // Overrun errors - bus was busy
    ULONG       RcvCdtErrors;           // Received frames that encountered coll.
    ULONG       RcvShortFrames;         // Received frames that were to short
    ULONG       CommandComplete;        // A005h indicates cmd completion
} ERR_COUNT_STRUC, *PERR_COUNT_STRUC;


//-------------------------------------------------------------------------
// Command Block (CB) Generic Header Structure
//-------------------------------------------------------------------------
typedef struct _CB_HEADER_STRUC {
    USHORT      CbStatus;               // Command Block Status
    USHORT      CbCommand;              // Command Block Command
    ULONG       CbLinkPointer;          // Link To Next CB
} CB_HEADER_STRUC, *PCB_HEADER_STRUC;


//-------------------------------------------------------------------------
// NOP Command Block (NOP_CB)
//-------------------------------------------------------------------------
typedef struct _NOP_CB_STRUC {
    CB_HEADER_STRUC     NopCBHeader;
} NOP_CB_STRUC, *PNOP_CB_STRUC;


//-------------------------------------------------------------------------
// Individual Address Command Block (IA_CB)
//-------------------------------------------------------------------------
typedef struct _IA_CB_STRUC {
    CB_HEADER_STRUC     IaCBHeader;
    UCHAR               IaAddress[ETHERNET_ADDRESS_LENGTH];
} IA_CB_STRUC, *PIA_CB_STRUC;


//-------------------------------------------------------------------------
// Configure Command Block (CONFIG_CB)
//-------------------------------------------------------------------------
typedef struct _CONFIG_CB_STRUC {
    CB_HEADER_STRUC     ConfigCBHeader;
    UCHAR               ConfigBytes[CB_CFIG_BYTE_COUNT];
} CONFIG_CB_STRUC, *PCONFIG_CB_STRUC;


//-------------------------------------------------------------------------
// MultiCast Command Block (MULTICAST_CB)
//-------------------------------------------------------------------------
typedef struct _MULTICAST_CB_STRUC {
    CB_HEADER_STRUC     McCBHeader;
    USHORT              McCount;        // Number of multicast addresses
    UCHAR               McAddress[(ETHERNET_ADDRESS_LENGTH * MAX_MULTICAST_ADDRESSES)];
} MULTICAST_CB_STRUC, *PMULTICAST_CB_STRUC;

//-------------------------------------------------------------------------
// WakeUp Filter Command Block (FILTER_CB)
//-------------------------------------------------------------------------
typedef struct _FILTER_CB_STRUC {
    CB_HEADER_STRUC     FilterCBHeader;
    ULONG               Pattern[16];        
}FILTER_CB_STRUC , *PFILTER_CB_STRUC ;

//-------------------------------------------------------------------------
// Dump Command Block (DUMP_CB)
//-------------------------------------------------------------------------
typedef struct _DUMP_CB_STRUC {
    CB_HEADER_STRUC     DumpCBHeader;
    ULONG               DumpAreaAddress;        // Dump Buffer Area Address
} DUMP_CB_STRUC, *PDUMP_CB_STRUC;


//-------------------------------------------------------------------------
// Dump Area structure definition
//-------------------------------------------------------------------------
typedef struct _DUMP_AREA_STRUC {
    UCHAR       DumpBuffer[DUMP_BUFFER_SIZE];
} DUMP_AREA_STRUC, *PDUMP_AREA_STRUC;


//-------------------------------------------------------------------------
// Diagnose Command Block (DIAGNOSE_CB)
//-------------------------------------------------------------------------
typedef struct _DIAGNOSE_CB_STRUC {
    CB_HEADER_STRUC     DiagCBHeader;
} DIAGNOSE_CB_STRUC, *PDIAGNOSE_CB_STRUC;

//-------------------------------------------------------------------------
// Transmit Command Block (TxCB)
//-------------------------------------------------------------------------
typedef struct _GENERIC_TxCB {
    CB_HEADER_STRUC     TxCbHeader;
    ULONG               TxCbTbdPointer;         // TBD address
    USHORT              TxCbCount;              // Data Bytes In TCB past header
    UCHAR               TxCbThreshold;          // TX Threshold for FIFO Extender
    UCHAR               TxCbTbdNumber;
    ETH_TX_BUFFER_STRUC TxCbData;
    ULONG               pad0;
    ULONG               pad1;
    ULONG               pad2;
    ULONG               pad3;
} TXCB_STRUC, *PTXCB_STRUC;

//-------------------------------------------------------------------------
// Transmit Buffer Descriptor (TBD)
//-------------------------------------------------------------------------
typedef struct _TBD_STRUC {
    ULONG       TbdBufferAddress;       // Physical Transmit Buffer Address
    unsigned    TbdCount :14;
    unsigned             :1 ;           // always 0
    unsigned    EndOfList:1 ;           // EL bit in Tbd
    unsigned             :16;           // field that is always 0's in a TBD
} TBD_STRUC, *PTBD_STRUC;


//-------------------------------------------------------------------------
// Receive Frame Descriptor (RFD)
//-------------------------------------------------------------------------
typedef struct _RFD_STRUC {
    CB_HEADER_STRUC     RfdCbHeader;
    ULONG               RfdRbdPointer;  // Receive Buffer Descriptor Addr
    USHORT              RfdActualCount; // Number Of Bytes Received
    USHORT              RfdSize;        // Number Of Bytes In RFD
    ETH_RX_BUFFER_STRUC RfdBuffer;      // Data buffer in RFD
} RFD_STRUC, *PRFD_STRUC;


//-------------------------------------------------------------------------
// Receive Buffer Descriptor (RBD)
//-------------------------------------------------------------------------
typedef struct _RBD_STRUC {
    USHORT      RbdActualCount;         // Number Of Bytes Received
    USHORT      RbdFiller;
    ULONG       RbdLinkAddress;         // Link To Next RBD
    ULONG       RbdRcbAddress;          // Receive Buffer Address
    USHORT      RbdSize;                // Receive Buffer Size
    USHORT      RbdFiller1;
} RBD_STRUC, *PRBD_STRUC;

#pragma pack()

//-------------------------------------------------------------------------
// 82557 PCI Register Definitions
// Refer To The PCI Specification For Detailed Explanations
//-------------------------------------------------------------------------
//- Register Offsets
#define PCI_VENDOR_ID_REGISTER      0x00    // PCI Vendor ID Register
#define PCI_DEVICE_ID_REGISTER      0x02    // PCI Device ID Register
#define PCI_CONFIG_ID_REGISTER      0x00    // PCI Configuration ID Register
#define PCI_COMMAND_REGISTER        0x04    // PCI Command Register
#define PCI_STATUS_REGISTER         0x06    // PCI Status Register
#define PCI_REV_ID_REGISTER         0x08    // PCI Revision ID Register
#define PCI_CLASS_CODE_REGISTER     0x09    // PCI Class Code Register
#define PCI_CACHE_LINE_REGISTER     0x0C    // PCI Cache Line Register
#define PCI_LATENCY_TIMER           0x0D    // PCI Latency Timer Register
#define PCI_HEADER_TYPE             0x0E    // PCI Header Type Register
#define PCI_BIST_REGISTER           0x0F    // PCI Built-In SelfTest Register
#define PCI_BAR_0_REGISTER          0x10    // PCI Base Address Register 0
#define PCI_BAR_1_REGISTER          0x14    // PCI Base Address Register 1
#define PCI_BAR_2_REGISTER          0x18    // PCI Base Address Register 2
#define PCI_BAR_3_REGISTER          0x1C    // PCI Base Address Register 3
#define PCI_BAR_4_REGISTER          0x20    // PCI Base Address Register 4
#define PCI_BAR_5_REGISTER          0x24    // PCI Base Address Register 5
#define PCI_SUBVENDOR_ID_REGISTER   0x2C    // PCI SubVendor ID Register
#define PCI_SUBDEVICE_ID_REGISTER   0x2E    // PCI SubDevice ID Register
#define PCI_EXPANSION_ROM           0x30    // PCI Expansion ROM Base Register
#define PCI_INTERRUPT_LINE          0x3C    // PCI Interrupt Line Register
#define PCI_INTERRUPT_PIN           0x3D    // PCI Interrupt Pin Register
#define PCI_MIN_GNT_REGISTER        0x3E    // PCI Min-Gnt Register
#define PCI_MAX_LAT_REGISTER        0x3F    // PCI Max_Lat Register
#define PCI_NODE_ADDR_REGISTER      0x40    // PCI Node Address Register


//-------------------------------------------------------------------------
// PHY 100 MDI Register/Bit Definitions
//-------------------------------------------------------------------------
// MDI register set
#define MDI_CONTROL_REG             0x00        // MDI control register
#define MDI_STATUS_REG              0x01        // MDI Status regiser
#define PHY_ID_REG_1                0x02        // Phy indentification reg (word 1)
#define PHY_ID_REG_2                0x03        // Phy indentification reg (word 2)
#define AUTO_NEG_ADVERTISE_REG      0x04        // Auto-negotiation advertisement
#define AUTO_NEG_LINK_PARTNER_REG   0x05        // Auto-negotiation link partner ability
#define AUTO_NEG_EXPANSION_REG      0x06        // Auto-negotiation expansion
#define AUTO_NEG_NEXT_PAGE_REG      0x07        // Auto-negotiation next page transmit
#define EXTENDED_REG_0              0x10        // Extended reg 0 (Phy 100 modes)
#define EXTENDED_REG_1              0x14        // Extended reg 1 (Phy 100 error indications)
#define NSC_CONG_CONTROL_REG        0x17        // National (TX) congestion control
#define NSC_SPEED_IND_REG           0x19        // National (TX) speed indication
#define PHY_EQUALIZER_REG           0x1A        // Register for the Phy Equalizer values

// MDI Control register bit definitions
#define MDI_CR_COLL_TEST_ENABLE     BIT_7       // Collision test enable
#define MDI_CR_FULL_HALF            BIT_8       // FDX =1, half duplex =0
#define MDI_CR_RESTART_AUTO_NEG     BIT_9       // Restart auto negotiation
#define MDI_CR_ISOLATE              BIT_10      // Isolate PHY from MII
#define MDI_CR_POWER_DOWN           BIT_11      // Power down
#define MDI_CR_AUTO_SELECT          BIT_12      // Auto speed select enable
#define MDI_CR_10_100               BIT_13      // 0 = 10Mbs, 1 = 100Mbs
#define MDI_CR_LOOPBACK             BIT_14      // 0 = normal, 1 = loopback
#define MDI_CR_RESET                BIT_15      // 0 = normal, 1 = PHY reset

// MDI Status register bit definitions
#define MDI_SR_EXT_REG_CAPABLE      BIT_0       // Extended register capabilities
#define MDI_SR_JABBER_DETECT        BIT_1       // Jabber detected
#define MDI_SR_LINK_STATUS          BIT_2       // Link Status -- 1 = link
#define MDI_SR_AUTO_SELECT_CAPABLE  BIT_3       // Auto speed select capable
#define MDI_SR_REMOTE_FAULT_DETECT  BIT_4       // Remote fault detect
#define MDI_SR_AUTO_NEG_COMPLETE    BIT_5       // Auto negotiation complete
#define MDI_SR_10T_HALF_DPX         BIT_11      // 10BaseT Half Duplex capable
#define MDI_SR_10T_FULL_DPX         BIT_12      // 10BaseT full duplex capable
#define MDI_SR_TX_HALF_DPX          BIT_13      // TX Half Duplex capable
#define MDI_SR_TX_FULL_DPX          BIT_14      // TX full duplex capable
#define MDI_SR_T4_CAPABLE           BIT_15      // T4 capable

// Auto-Negotiation advertisement register bit definitions
#define NWAY_AD_SELCTOR_FIELD       BIT_0_4     // identifies supported protocol
#define NWAY_AD_ABILITY             BIT_5_12    // technologies that are supported
#define NWAY_AD_10T_HALF_DPX        BIT_5       // 10BaseT Half Duplex capable
#define NWAY_AD_10T_FULL_DPX        BIT_6       // 10BaseT full duplex capable
#define NWAY_AD_TX_HALF_DPX         BIT_7       // TX Half Duplex capable
#define NWAY_AD_TX_FULL_DPX         BIT_8       // TX full duplex capable
#define NWAY_AD_T4_CAPABLE          BIT_9       // T4 capable
#define NWAY_AD_REMOTE_FAULT        BIT_13      // indicates local remote fault
#define NWAY_AD_RESERVED            BIT_14      // reserved
#define NWAY_AD_NEXT_PAGE           BIT_15      // Next page (not supported)

// Auto-Negotiation link partner ability register bit definitions
#define NWAY_LP_SELCTOR_FIELD       BIT_0_4     // identifies supported protocol
#define NWAY_LP_ABILITY             BIT_5_9     // technologies that are supported
#define NWAY_LP_REMOTE_FAULT        BIT_13      // indicates partner remote fault
#define NWAY_LP_ACKNOWLEDGE         BIT_14      // acknowledge
#define NWAY_LP_NEXT_PAGE           BIT_15      // Next page (not supported)

// Auto-Negotiation expansion register bit definitions
#define NWAY_EX_LP_NWAY             BIT_0       // link partner is NWAY
#define NWAY_EX_PAGE_RECEIVED       BIT_1       // link code word received
#define NWAY_EX_NEXT_PAGE_ABLE      BIT_2       // local is next page able
#define NWAY_EX_LP_NEXT_PAGE_ABLE   BIT_3       // partner is next page able
#define NWAY_EX_PARALLEL_DET_FLT    BIT_4       // parallel detection fault
#define NWAY_EX_RESERVED            BIT_5_15    // reserved


// PHY 100 Extended Register 0 bit definitions
#define PHY_100_ER0_FDX_INDIC       BIT_0       // 1 = FDX, 0 = half duplex
#define PHY_100_ER0_SPEED_INDIC     BIT_1       // 1 = 100mbs, 0= 10mbs
#define PHY_100_ER0_WAKE_UP         BIT_2       // Wake up DAC
#define PHY_100_ER0_RESERVED        BIT_3_4     // Reserved
#define PHY_100_ER0_REV_CNTRL       BIT_5_7     // Revsion control (A step = 000)
#define PHY_100_ER0_FORCE_FAIL      BIT_8       // Force Fail is enabled
#define PHY_100_ER0_TEST            BIT_9_13    // Revsion control (A step = 000)
#define PHY_100_ER0_LINKDIS         BIT_14      // Link integrity test is disabled
#define PHY_100_ER0_JABDIS          BIT_15      // Jabber function is disabled


// PHY 100 Extended Register 1 bit definitions
#define PHY_100_ER1_RESERVED        BIT_0_8     // Reserved
#define PHY_100_ER1_CH2_DET_ERR     BIT_9       // Channel 2 EOF detection error
#define PHY_100_ER1_MANCH_CODE_ERR  BIT_10      // Manchester code error
#define PHY_100_ER1_EOP_ERR         BIT_11      // EOP error
#define PHY_100_ER1_BAD_CODE_ERR    BIT_12      // bad code error
#define PHY_100_ER1_INV_CODE_ERR    BIT_13      // invalid code error
#define PHY_100_ER1_DC_BAL_ERR      BIT_14      // DC balance error
#define PHY_100_ER1_PAIR_SKEW_ERR   BIT_15      // Pair skew error

// PHY TX Register/Bit definitions
#define PHY_TX_STATUS_CTRL_REG      0x10
#define PHY_TX_POLARITY_MASK        BIT_8       // register 10h bit 8 (the polarity bit)
#define PHY_TX_NORMAL_POLARITY      0           // register 10h bit 8 =0 (normal polarity)

#define PHY_TX_SPECIAL_CTRL_REG     0x11
#define AUTO_POLARITY_DISABLE       BIT_4       // register 11h bit 4 (0=enable, 1=disable)

#define PHY_TX_REG_18               0x18        // Error counter register
// National Semiconductor TX phy congestion control register bit definitions
#define NSC_TX_CONG_TXREADY         BIT_10      // Makes TxReady an input
#define NSC_TX_CONG_ENABLE          BIT_8       // Enables congestion control
#define NSC_TX_CONG_F_CONNECT       BIT_5       // Enables congestion control

// National Semiconductor TX phy speed indication register bit definitions
#define NSC_TX_SPD_INDC_SPEED       BIT_6       // 0 = 100mb, 1=10mb

#endif  // _E100_557_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\net\ms\e100bex\mp_cmn.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:
    mp_cmn.h

Abstract:
    Common definitions for the miniport and kd extension dll

Revision History:
    Who         When        What
    --------    --------    ----------------------------------------------
    DChen       11-01-99    created

Notes:

--*/

#ifndef _MP_CMN_H
#define _MP_CMN_H

// MP_TCB flags
#define fMP_TCB_IN_USE                         0x00000001
#define fMP_TCB_USE_LOCAL_BUF                  0x00000002
#define fMP_TCB_MULTICAST                      0x00000004  // a hardware workaround using multicast
               
// MP_RFD flags                           
#define fMP_RFD_RECV_PEND                      0x00000001
#define fMP_RFD_ALLOC_PEND                     0x00000002
#define fMP_RFD_RECV_READY                     0x00000004
#define fMP_RFD_RESOURCES                      0x00000008

// MP_ADAPTER flags               
#define fMP_ADAPTER_SCATTER_GATHER             0x00000001
#define fMP_ADAPTER_MAP_REGISTER               0x00000002
#define fMP_ADAPTER_RECV_LOOKASIDE             0x00000004
#define fMP_ADAPTER_INTERRUPT_IN_USE           0x00000008
#define fMP_ADAPTER_SECONDARY                  0x00000010

#if OFFLOAD
// MP_ SHARED flags
#define fMP_SHARED_MEM_IN_USE                  0x00000100
#endif

#define fMP_ADAPTER_NON_RECOVER_ERROR          0x00800000

#define fMP_ADAPTER_RESET_IN_PROGRESS          0x01000000
#define fMP_ADAPTER_NO_CABLE                   0x02000000 
#define fMP_ADAPTER_HARDWARE_ERROR             0x04000000
#define fMP_ADAPTER_REMOVE_IN_PROGRESS         0x08000000
#define fMP_ADAPTER_HALT_IN_PROGRESS           0x10000000

#define fMP_ADAPTER_LINK_DETECTION             0x20000000
                                 
#define fMP_ADAPTER_FAIL_SEND_MASK             0x1ff00000                
#define fMP_ADAPTER_NOT_READY_MASK             0x3ff00000    


#endif  // _MP_CMN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\net\ms\e100bex\eeprom.c ===
/****************************************************************************
** COPYRIGHT (C) 1994-1997 INTEL CORPORATION                               **
** DEVELOPED FOR MICROSOFT BY INTEL CORP., HILLSBORO, OREGON               **
** HTTP://WWW.INTEL.COM/                                                   **
** THIS FILE IS PART OF THE INTEL ETHEREXPRESS PRO/100B(TM) AND            **
** ETHEREXPRESS PRO/100+(TM) NDIS 5.0 MINIPORT SAMPLE DRIVER               **
****************************************************************************/

/****************************************************************************
Module Name:
    eeprom.c

This driver runs on the following hardware:
    - 82558 based PCI 10/100Mb ethernet adapters
    (aka Intel EtherExpress(TM) PRO Adapters)

Environment:
    Kernel Mode - Or whatever is the equivalent on WinNT

Revision History
    - JCB 8/14/97 Example Driver Created
    - Dchen 11-01-99    Modified for the new sample driver
*****************************************************************************/

#include "precomp.h"
#pragma hdrstop
#pragma warning (disable: 4244 4514)

#define EEPROM_MAX_SIZE        256

//*****************************************************************************
//
//            I/O based Read EEPROM Routines
//
//*****************************************************************************

//-----------------------------------------------------------------------------
// Procedure:   EEpromAddressSize
//
// Description: determines the number of bits in an address for the eeprom
//              acceptable values are 64, 128, and 256
//
// Arguments:
//      Size -- size of the eeprom
//
// Returns:
//      bits in an address for that size eeprom
//-----------------------------------------------------------------------------

USHORT GetEEpromAddressSize(
    IN USHORT  Size)
{
    switch (Size)
    {
        case 64:    return 6;
        case 128:   return 7;
        case 256:   return 8;
    }

    return 0;
}

//-----------------------------------------------------------------------------
// Procedure:   GetEEpromSize
//
// Description: This routine determines the size of the EEPROM.
//
// Arguments:
//      Reg - EEPROM word to read.
//
// Returns:
//      Size of the EEPROM, or zero if error.
//-----------------------------------------------------------------------------

USHORT GetEEpromSize(
    IN PUCHAR CSRBaseIoAddress)
{
    USHORT x, data;
    USHORT size = 1;

    // select EEPROM, reset bits, set EECS
    x = READ_PORT_USHORT((PUSHORT)(CSRBaseIoAddress + CSR_EEPROM_CONTROL_REG));

    x &= ~(EEDI | EEDO | EESK);
    x |= EECS;
    WRITE_PORT_USHORT((PUSHORT)(CSRBaseIoAddress + CSR_EEPROM_CONTROL_REG), x);

    // write the read opcode
    ShiftOutBits(EEPROM_READ_OPCODE, 3, CSRBaseIoAddress);

    // experiment to discover the size of the eeprom.  request register zero
    // and wait for the eeprom to tell us it has accepted the entire address.
    x = READ_PORT_USHORT((PUSHORT)(CSRBaseIoAddress + CSR_EEPROM_CONTROL_REG));
    do
    {
        size *= 2;          // each bit of address doubles eeprom size
        x |= EEDO;          // set bit to detect "dummy zero"
        x &= ~EEDI;         // address consists of all zeros

        WRITE_PORT_USHORT((PUSHORT)(CSRBaseIoAddress + CSR_EEPROM_CONTROL_REG), x);
        NdisStallExecution(100);
        RaiseClock(&x, CSRBaseIoAddress);
        LowerClock(&x, CSRBaseIoAddress);

        // check for "dummy zero"
        x = READ_PORT_USHORT((PUSHORT)(CSRBaseIoAddress + CSR_EEPROM_CONTROL_REG));
        if (size > EEPROM_MAX_SIZE)
        {
            size = 0;
            break;
        }
    }
    while (x & EEDO);

    // Now read the data (16 bits) in from the selected EEPROM word
    data = ShiftInBits(CSRBaseIoAddress);

    EEpromCleanup(CSRBaseIoAddress);
    
    return size;
}

//-----------------------------------------------------------------------------
// Procedure:   ReadEEprom
//
// Description: This routine serially reads one word out of the EEPROM.
//
// Arguments:
//      Reg - EEPROM word to read.
//
// Returns:
//      Contents of EEPROM word (Reg).
//-----------------------------------------------------------------------------

USHORT ReadEEprom(
    IN PUCHAR CSRBaseIoAddress,
    IN USHORT Reg,
    IN USHORT AddressSize)
{
    USHORT x;
    USHORT data;

    // select EEPROM, reset bits, set EECS
    x = READ_PORT_USHORT((PUSHORT)(CSRBaseIoAddress + CSR_EEPROM_CONTROL_REG));

    x &= ~(EEDI | EEDO | EESK);
    x |= EECS;
    WRITE_PORT_USHORT((PUSHORT)(CSRBaseIoAddress + CSR_EEPROM_CONTROL_REG), x);

    // write the read opcode and register number in that order
    // The opcode is 3bits in length, reg is 6 bits long
    ShiftOutBits(EEPROM_READ_OPCODE, 3, CSRBaseIoAddress);
    ShiftOutBits(Reg, AddressSize, CSRBaseIoAddress);

    // Now read the data (16 bits) in from the selected EEPROM word
    data = ShiftInBits(CSRBaseIoAddress);

    EEpromCleanup(CSRBaseIoAddress);
    return data;
}

//-----------------------------------------------------------------------------
// Procedure:   ShiftOutBits
//
// Description: This routine shifts data bits out to the EEPROM.
//
// Arguments:
//      data - data to send to the EEPROM.
//      count - number of data bits to shift out.
//
// Returns: (none)
//-----------------------------------------------------------------------------

VOID ShiftOutBits(
    IN USHORT data,
    IN USHORT count,
    IN PUCHAR CSRBaseIoAddress)
{
    USHORT x,mask;

    mask = 0x01 << (count - 1);
    x = READ_PORT_USHORT((PUSHORT)(CSRBaseIoAddress + CSR_EEPROM_CONTROL_REG));

    x &= ~(EEDO | EEDI);

    do
    {
        x &= ~EEDI;
        if(data & mask)
            x |= EEDI;

        WRITE_PORT_USHORT((PUSHORT)(CSRBaseIoAddress + CSR_EEPROM_CONTROL_REG), x);
        NdisStallExecution(100);
        RaiseClock(&x, CSRBaseIoAddress);
        LowerClock(&x, CSRBaseIoAddress);
        mask = mask >> 1;
    } while(mask);

    x &= ~EEDI;
    WRITE_PORT_USHORT((PUSHORT)(CSRBaseIoAddress + CSR_EEPROM_CONTROL_REG), x);
}

//-----------------------------------------------------------------------------
// Procedure:   ShiftInBits
//
// Description: This routine shifts data bits in from the EEPROM.
//
// Arguments:
//
// Returns:
//      The contents of that particular EEPROM word
//-----------------------------------------------------------------------------

USHORT ShiftInBits(
    IN PUCHAR CSRBaseIoAddress)
{
    USHORT x,d,i;
    x = READ_PORT_USHORT((PUSHORT)(CSRBaseIoAddress + CSR_EEPROM_CONTROL_REG));

    x &= ~( EEDO | EEDI);
    d = 0;

    for(i=0; i<16; i++)
    {
        d = d << 1;
        RaiseClock(&x, CSRBaseIoAddress);

        x = READ_PORT_USHORT((PUSHORT)(CSRBaseIoAddress + CSR_EEPROM_CONTROL_REG));

        x &= ~(EEDI);
        if(x & EEDO)
            d |= 1;

        LowerClock(&x, CSRBaseIoAddress);
    }

    return d;
}

//-----------------------------------------------------------------------------
// Procedure:   RaiseClock
//
// Description: This routine raises the EEPOM's clock input (EESK)
//
// Arguments:
//      x - Ptr to the EEPROM control register's current value
//
// Returns: (none)
//-----------------------------------------------------------------------------

VOID RaiseClock(
    IN OUT USHORT *x,
    IN PUCHAR CSRBaseIoAddress)
{
    *x = *x | EESK;
    WRITE_PORT_USHORT((PUSHORT)(CSRBaseIoAddress + CSR_EEPROM_CONTROL_REG), *x);
    NdisStallExecution(100);
}


//-----------------------------------------------------------------------------
// Procedure:   LowerClock
//
// Description: This routine lower's the EEPOM's clock input (EESK)
//
// Arguments:
//      x - Ptr to the EEPROM control register's current value
//
// Returns: (none)
//-----------------------------------------------------------------------------

VOID LowerClock(
    IN OUT USHORT *x,
    IN PUCHAR CSRBaseIoAddress)
{
    *x = *x & ~EESK;
    WRITE_PORT_USHORT((PUSHORT)(CSRBaseIoAddress + CSR_EEPROM_CONTROL_REG), *x);
    NdisStallExecution(100);
}

//-----------------------------------------------------------------------------
// Procedure:   EEpromCleanup
//
// Description: This routine returns the EEPROM to an idle state
//
// Arguments:
//
// Returns: (none)
//-----------------------------------------------------------------------------

VOID EEpromCleanup(
    IN PUCHAR CSRBaseIoAddress)
{
    USHORT x;
    x = READ_PORT_USHORT((PUSHORT)(CSRBaseIoAddress + CSR_EEPROM_CONTROL_REG));

    x &= ~(EECS | EEDI);
    WRITE_PORT_USHORT((PUSHORT)(CSRBaseIoAddress + CSR_EEPROM_CONTROL_REG), x);

    RaiseClock(&x, CSRBaseIoAddress);
    LowerClock(&x, CSRBaseIoAddress);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\net\ms\e100bex\mp_dbg.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:
    mp_dbg.c

Abstract:
    This module contains all debug-related code.

Revision History:
    Who         When        What
    --------    --------    ----------------------------------------------
    DChen       11-01-99    created

Notes:

--*/

#include "precomp.h"

#if DBG

/**
Constants
**/

#define _FILENUMBER     'GBED'

// Bytes to appear on each line of dump output.
//
#define DUMP_BytesPerLine 16

ULONG               MPDebugLevel = MP_WARN;
ULONG               MPAllocCount = 0;       // the number of outstanding allocs
NDIS_SPIN_LOCK      MPMemoryLock;           // spinlock for the debug mem list
LIST_ENTRY          MPMemoryList;
BOOLEAN             MPInitDone = FALSE;     // debug mem list init flag 

NDIS_STATUS MPAuditAllocMem(
    PVOID           *pPointer,
    UINT            Size,
    UINT            Flags,
    NDIS_PHYSICAL_ADDRESS HighestAddr,
    ULONG           FileNumber,
    ULONG           LineNumber
    )
{
    NDIS_STATUS     Status;
    PMP_ALLOCATION  pAllocInfo;

    if (!MPInitDone)
    {
        NdisAllocateSpinLock(&MPMemoryLock);
        InitializeListHead(&MPMemoryList);
        MPInitDone = TRUE;
    }

    //
    // Ensure Flags is non-zero, 
    // otherwise NdisAllocateMemoryWithTag should be used
    //
    ASSERT(Flags);                  

    Status = NdisAllocateMemory(
                 (PVOID *)(&pAllocInfo), 
                 (UINT)(Size + sizeof(MP_ALLOCATION)), 
                 Flags,
                 HighestAddr);

    if (pAllocInfo == (PMP_ALLOCATION)NULL)
    {
        DBGPRINT(MP_LOUD,
            ("MPAuditAllocMemCore: file %d, line %d, Size %d failed!\n",
            FileNumber, LineNumber, Size));
        *pPointer = NULL;
    }
    else
    {
        *pPointer = (PVOID)&(pAllocInfo->UserData);
        MP_MEMSET(*pPointer, Size, 0xc);

        pAllocInfo->Signature = 'DOOG';
        pAllocInfo->FileNumber = FileNumber;
        pAllocInfo->LineNumber = LineNumber;
        pAllocInfo->Size = Size;
        pAllocInfo->Location = pPointer;
        pAllocInfo->Flags = Flags;

        NdisAcquireSpinLock(&MPMemoryLock);
        InsertTailList(&MPMemoryList, &pAllocInfo->List);
        MPAllocCount++;
        NdisReleaseSpinLock(&MPMemoryLock);
    }

    DBGPRINT(MP_LOUD,
        ("MPAuditAllocMem: file %c%c%c%c, line %d, %d bytes, [0x"PTR_FORMAT"] <- 0x"PTR_FORMAT"\n",
        (CHAR)(FileNumber & 0xff),
        (CHAR)((FileNumber >> 8) & 0xff),
        (CHAR)((FileNumber >> 16) & 0xff),
        (CHAR)((FileNumber >> 24) & 0xff),
        LineNumber, Size, pPointer, *pPointer));

    return(Status);
}

NDIS_STATUS MPAuditAllocMemTag(
    PVOID *  pPointer,
    UINT     Size,
    ULONG    FileNumber,
    ULONG    LineNumber
    )
{
    NDIS_STATUS     Status;
    PMP_ALLOCATION  pAllocInfo;

    if (!MPInitDone)
    {
        NdisAllocateSpinLock(&MPMemoryLock);
        InitializeListHead(&MPMemoryList);
        MPInitDone = TRUE;
    }

    Status = NdisAllocateMemoryWithTag(
                 (PVOID *)(&pAllocInfo), 
                 (UINT)(Size + sizeof(MP_ALLOCATION)), 
                 NIC_TAG);

    if (pAllocInfo == (PMP_ALLOCATION)NULL)
    {
        *pPointer = NULL;

        DBGPRINT(MP_LOUD,
            ("MPAuditAllocMemCore: file %d, line %d, Size %d failed!\n",
            FileNumber, LineNumber, Size));
    }
    else
    {
        *pPointer = (PVOID)&(pAllocInfo->UserData);
        MP_MEMSET(*pPointer, Size, 0xc);

        pAllocInfo->Signature = 'DOOG';
        pAllocInfo->FileNumber = FileNumber;
        pAllocInfo->LineNumber = LineNumber;
        pAllocInfo->Size = Size;
        pAllocInfo->Location = pPointer;
        pAllocInfo->Flags = 0;

        NdisAcquireSpinLock(&MPMemoryLock);
        InsertTailList(&MPMemoryList, &pAllocInfo->List);
        MPAllocCount++;
        NdisReleaseSpinLock(&MPMemoryLock);
    }

    DBGPRINT(MP_LOUD,
        ("MPAuditAllocMemTag: file %c%c%c%c, line %d, %d bytes, [0x"PTR_FORMAT"] <- 0x"PTR_FORMAT"\n",
        (CHAR)(FileNumber & 0xff),
        (CHAR)((FileNumber >> 8) & 0xff),
        (CHAR)((FileNumber >> 16) & 0xff),
        (CHAR)((FileNumber >> 24) & 0xff),
        LineNumber, Size, pPointer, *pPointer));

    return(Status);
}

VOID MPAuditFreeMem(
    IN PVOID  Pointer, 
    IN UINT   Size,
    IN UINT   Flags
    )
{
    PMP_ALLOCATION  pAllocInfo;

    pAllocInfo = CONTAINING_RECORD(Pointer, MP_ALLOCATION, UserData);

    ASSERT(pAllocInfo->Signature == (ULONG)'DOOG');
    ASSERT(pAllocInfo->Size == Size);
    ASSERT(pAllocInfo->Flags == Flags);

    NdisAcquireSpinLock(&MPMemoryLock);
    pAllocInfo->Signature = (ULONG)'DEAD';
    RemoveEntryList(&pAllocInfo->List);
    MPAllocCount--;
    NdisReleaseSpinLock(&MPMemoryLock);

    NdisFreeMemory(pAllocInfo, Size + sizeof(MP_ALLOCATION), Flags);
}

VOID mpDbgPrintUnicodeString(
    IN  PUNICODE_STRING UnicodeString
    )
{
    UCHAR Buffer[256];

    USHORT i;

    for (i = 0; (i < UnicodeString->Length / 2) && (i < 255); i++) 
    {
        Buffer[i] = (UCHAR)UnicodeString->Buffer[i];
    }

    Buffer[i] = '\0';

    DbgPrint("%s", Buffer);
}



// Hex dump 'cb' bytes starting at 'p' grouping 'ulGroup' bytes together.
// For example, with 'ulGroup' of 1, 2, and 4:
//
// 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................|
// 0000 0000 0000 0000 0000 0000 0000 0000 |................|
// 00000000 00000000 00000000 00000000 |................|
//
// If 'fAddress' is true, the memory address dumped is prepended to each
// line.
//
VOID
Dump(
    IN CHAR*   p,
    IN ULONG   cb,
    IN BOOLEAN fAddress,
    IN ULONG   ulGroup 
    )
{
    INT cbLine;

    while (cb)
    {

        cbLine = (cb < DUMP_BytesPerLine) ? cb : DUMP_BytesPerLine;
        DumpLine( p, cbLine, fAddress, ulGroup );
        cb -= cbLine;
        p += cbLine;
    }
}


VOID
DumpLine(
    IN CHAR*   p,
    IN ULONG   cb,
    IN BOOLEAN fAddress,
    IN ULONG   ulGroup 
    )
{

    CHAR* pszDigits = "0123456789ABCDEF";
    CHAR szHex[ ((2 + 1) * DUMP_BytesPerLine) + 1 ];
    CHAR* pszHex = szHex;
    CHAR szAscii[ DUMP_BytesPerLine + 1 ];
    CHAR* pszAscii = szAscii;
    ULONG ulGrouped = 0;

    if (fAddress) 
    {
        DbgPrint( "E100: %p: ", p );
    }
    else 
    {
        DbgPrint( "E100: " );
    }

    while (cb)
    {
        *pszHex++ = pszDigits[ ((UCHAR )*p) / 16 ];
        *pszHex++ = pszDigits[ ((UCHAR )*p) % 16 ];

        if (++ulGrouped >= ulGroup)
        {
            *pszHex++ = ' ';
            ulGrouped = 0;
        }

        *pszAscii++ = (*p >= 32 && *p < 128) ? *p : '.';

        ++p;
        --cb;
    }

    *pszHex = '\0';
    *pszAscii = '\0';

    DbgPrint(
        "%-*s|%-*s|\n",
        (2 * DUMP_BytesPerLine) + (DUMP_BytesPerLine / ulGroup), szHex,
        DUMP_BytesPerLine, szAscii );
}



#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\net\ms\e100bex\e100_equ.h ===
/****************************************************************************
** COPYRIGHT (C) 1994-1997 INTEL CORPORATION                               **
** DEVELOPED FOR MICROSOFT BY INTEL CORP., HILLSBORO, OREGON               **
** HTTP://WWW.INTEL.COM/                                                   **
** THIS FILE IS PART OF THE INTEL ETHEREXPRESS PRO/100B(TM) AND            **
** ETHEREXPRESS PRO/100+(TM) NDIS 5.0 MINIPORT SAMPLE DRIVER               **
****************************************************************************/

/****************************************************************************
Module Name:
    e100_equ.h  (equates.h)

This driver runs on the following hardware:
    - 82558 based PCI 10/100Mb ethernet adapters
    (aka Intel EtherExpress(TM) PRO Adapters)

Environment:
    Kernel Mode - Or whatever is the equivalent on WinNT

Revision History
    - JCB 8/14/97 Example Driver Created
    - Dchen 11-01-99    Modified for the new sample driver
*****************************************************************************/

#ifndef _E100_EQU_H
#define _E100_EQU_H

//-------------------------------------------------------------------------
// OEM Message Tags
//-------------------------------------------------------------------------
#define stringTag       0xFEFA      // Length Byte After String
#define lStringTag      0xFEFB      // Length Byte Before String
#define zStringTag      0xFEFC      // Zero-Terminated String Tag
#define nStringTag      0xFEFD      // No Length Byte Or 0-Term

//-------------------------------------------------------------------------
// Adapter Types Supported
//-------------------------------------------------------------------------
#define FLASH32_EISA    (0 * 4)
#define FLASH32_PCI     (1 * 4)
#define D29C_EISA       (2 * 4)
#define D29C_PCI        (3 * 4)
#define D100_PCI        (4 * 4)

//-------------------------------------------------------------------------
// Phy related constants
//-------------------------------------------------------------------------
#define PHY_503                 0
#define PHY_100_A               0x000003E0
#define PHY_100_C               0x035002A8
#define PHY_TX_ID               0x015002A8
#define PHY_NSC_TX              0x5c002000
#define PHY_OTHER               0xFFFF

#define PHY_MODEL_REV_ID_MASK   0xFFF0FFFF
#define PARALLEL_DETECT         0
#define N_WAY                   1

#define RENEGOTIATE_TIME        35 // (3.5 Seconds)

#define CONNECTOR_AUTO          0
#define CONNECTOR_TPE           1
#define CONNECTOR_MII           2

//-------------------------------------------------------------------------
// Ethernet Frame Sizes
//-------------------------------------------------------------------------
#define ETHERNET_ADDRESS_LENGTH         6
#define ETHERNET_HEADER_SIZE            14
#define MINIMUM_ETHERNET_PACKET_SIZE    60
#define MAXIMUM_ETHERNET_PACKET_SIZE    1514

#define MAX_MULTICAST_ADDRESSES         32
#define TCB_BUFFER_SIZE                 0XE0 // 224
#define COALESCE_BUFFER_SIZE            2048
#define ETH_MAX_COPY_LENGTH             0x80 // 128

// Make receive area 1536 for 16 bit alignment.
//#define RCB_BUFFER_SIZE       MAXIMUM_ETHERNET_PACKET_SIZE
#define RCB_BUFFER_SIZE                 1520 // 0x5F0

//- Area reserved for all Non Transmit command blocks
#define MAX_NON_TX_CB_AREA              512

//-------------------------------------------------------------------------
// Ndis/Adapter driver constants
//-------------------------------------------------------------------------
#define MAX_PHYS_DESC                   16
#define MAX_RECEIVE_DESCRIPTORS         1024 // 0x400
#define NUM_RMD                         10

//--------------------------------------------------------------------------
// System wide Equates
//--------------------------------------------------------------------------
#define MAX_NUMBER_OF_EISA_SLOTS        15
#define MAX_NUMBER_OF_PCI_SLOTS         15

//--------------------------------------------------------------------------
//    Equates Added for NDIS 4
//--------------------------------------------------------------------------
#define  NUM_BYTES_PROTOCOL_RESERVED_SECTION    16
#define  MAX_NUM_ALLOCATED_RFDS                 64
#define  MIN_NUM_RFD                            4
#define  MAX_ARRAY_SEND_PACKETS                 8
// limit our receive routine to indicating this many at a time
#define  MAX_ARRAY_RECEIVE_PACKETS              16
#define  MAC_RESERVED_SWRFDPTR                  0
#define  MAX_PACKETS_TO_ADD                     32

//-------------------------------------------------------------------------
//- Miscellaneous Equates
//-------------------------------------------------------------------------
#define CR      0x0D        // Carriage Return
#define LF      0x0A        // Line Feed

#ifndef FALSE
#define FALSE       0
#define TRUE        1
#endif

#define DRIVER_NULL ((ULONG)0xffffffff)
#define DRIVER_ZERO 0

//-------------------------------------------------------------------------
// Bit Mask definitions
//-------------------------------------------------------------------------
#define BIT_0       0x0001
#define BIT_1       0x0002
#define BIT_2       0x0004
#define BIT_3       0x0008
#define BIT_4       0x0010
#define BIT_5       0x0020
#define BIT_6       0x0040
#define BIT_7       0x0080
#define BIT_8       0x0100
#define BIT_9       0x0200
#define BIT_10      0x0400
#define BIT_11      0x0800
#define BIT_12      0x1000
#define BIT_13      0x2000
#define BIT_14      0x4000
#define BIT_15      0x8000
#define BIT_24      0x01000000
#define BIT_28      0x10000000

#define BIT_0_2     0x0007
#define BIT_0_3     0x000F
#define BIT_0_4     0x001F
#define BIT_0_5     0x003F
#define BIT_0_6     0x007F
#define BIT_0_7     0x00FF
#define BIT_0_8     0x01FF
#define BIT_0_13    0x3FFF
#define BIT_0_15    0xFFFF
#define BIT_1_2     0x0006
#define BIT_1_3     0x000E
#define BIT_2_5     0x003C
#define BIT_3_4     0x0018
#define BIT_4_5     0x0030
#define BIT_4_6     0x0070
#define BIT_4_7     0x00F0
#define BIT_5_7     0x00E0
#define BIT_5_9     0x03E0
#define BIT_5_12    0x1FE0
#define BIT_5_15    0xFFE0
#define BIT_6_7     0x00c0
#define BIT_7_11    0x0F80
#define BIT_8_10    0x0700
#define BIT_9_13    0x3E00
#define BIT_12_15   0xF000
#define BIT_8_15    0xFF00 

#define BIT_16_20   0x001F0000
#define BIT_21_25   0x03E00000
#define BIT_26_27   0x0C000000

// in order to make our custom oids hopefully somewhat unique
// we will use 0xFF (indicating implementation specific OID)
//               A0 (first byte of non zero intel unique identifier)
//               C9 (second byte of non zero intel unique identifier)
//               XX (the custom OID number - providing 255 possible custom oids)
#define OID_CUSTOM_DRIVER_SET       0xFFA0C901
#define OID_CUSTOM_DRIVER_QUERY     0xFFA0C902
#define OID_CUSTOM_ARRAY            0xFFA0C903
#define OID_CUSTOM_STRING           0xFFA0C904

#define CMD_BUS_MASTER              BIT_2

#endif  // _E100_EQU_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\net\ms\e100bex\mp_dbg.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:
    mp_dbg.h

Abstract:
    Debug definitions and macros

Revision History:
    Who         When        What
    --------    --------    ----------------------------------------------
    DChen       11-01-99    created

Notes:

--*/

#ifndef _MP_DBG_H
#define _MP_DBG_H

//
// Message verbosity: lower values indicate higher urgency
//
#define MP_OFF          0
#define MP_ERROR        1
#define MP_WARN         2
#define MP_TRACE        3
#define MP_INFO         4
#define MP_LOUD         5

// Define a macro so DbgPrint can work on win9x, 32-bit/64-bit NT's
#ifdef _WIN64
#define PTR_FORMAT      "%p"
#else
#define PTR_FORMAT      "%x"
#endif
                            
#if DBG

extern ULONG            MPDebugLevel;
extern BOOLEAN          MPInitDone;
extern NDIS_SPIN_LOCK   MPMemoryLock;

#define DBGPRINT(Level, Fmt) \
{ \
    if (Level <= MPDebugLevel) \
    { \
        DbgPrint(NIC_DBG_STRING); \
        DbgPrint Fmt; \
    } \
}

#define DBGPRINT_RAW(Level, Fmt) \
{ \
    if (Level <= MPDebugLevel) \
    { \
      DbgPrint Fmt; \
    } \
}

#define DBGPRINT_S(Status, Fmt) \
{ \
    ULONG dbglevel; \
    if(Status == NDIS_STATUS_SUCCESS || Status == NDIS_STATUS_PENDING) dbglevel = MP_TRACE; \
    else dbglevel = MP_ERROR; \
    DBGPRINT(dbglevel, Fmt); \
}

#define DBGPRINT_UNICODE(Level, UString) \
{ \
    if (Level <= MPDebugLevel) \
    { \
        DbgPrint(NIC_DBG_STRING); \
      mpDbgPrintUnicodeString(UString); \
   } \
}

#undef ASSERT
#define ASSERT(x) if(!(x)) { \
    DBGPRINT(MP_ERROR, ("Assertion failed: %s:%d %s\n", __FILE__, __LINE__, #x)); \
    DbgBreakPoint(); }

//
// The MP_ALLOCATION structure stores all info about MPAuditAllocMem
//
typedef struct _MP_ALLOCATION
{
    LIST_ENTRY              List;
    ULONG                   Signature;
    ULONG                   FileNumber;
    ULONG                   LineNumber;
    ULONG                   Size;
    PVOID                   *Location;   // where the returned pointer was put
    UINT                    Flags;
    union {
        ULONGLONG           Alignment;        
        UCHAR               UserData;
    };
} MP_ALLOCATION, *PMP_ALLOCATION;


NDIS_STATUS MPAuditAllocMem(
    PVOID                   *pPointer,
    UINT                    Size,
    UINT                    Flags,
    NDIS_PHYSICAL_ADDRESS   HighestAddr,    
    ULONG                   FileNumber,
    ULONG                   LineNumber);

NDIS_STATUS MPAuditAllocMemTag(
    PVOID       *pPointer,
    UINT        Size,
    ULONG       FileNumber,
    ULONG       LineNumber);

VOID MPAuditFreeMem(
    PVOID       Pointer,
    UINT        Size,
    UINT        Flags);

VOID mpDbgPrintUnicodeString(
    IN  PUNICODE_STRING UnicodeString);


VOID
Dump(
    CHAR* p,
    ULONG cb,
    BOOLEAN fAddress,
    ULONG ulGroup );




#else   // !DBG

#define DBGPRINT(Level, Fmt)
#define DBGPRINT_RAW(Level, Fmt)
#define DBGPRINT_S(Status, Fmt)
#define DBGPRINT_UNICODE(Level, UString)
#define Dump(p,cb,fAddress,ulGroup)

#undef ASSERT
#define ASSERT(x)

#endif  // DBG

VOID
DumpLine(
    CHAR* p,
    ULONG cb,
    BOOLEAN  fAddress,
    ULONG ulGroup );


#endif  // _MP_DBG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\net\ms\e100bex\mp.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:
    mp.h

Abstract:
    Miniport generic portion header file

Revision History:
    Who         When        What
    --------    --------    ----------------------------------------------
    DChen       03-04-99    created

Notes:

--*/

#ifndef _MP_H
#define _MP_H

#ifdef NDIS50_MINIPORT
#define MP_NDIS_MAJOR_VERSION       5
#define MP_NDIS_MINOR_VERSION       0
#endif

#ifdef NDIS51_MINIPORT
#define MP_NDIS_MAJOR_VERSION       5
#define MP_NDIS_MINOR_VERSION       1
#endif

#define ALIGN_16                   16

#ifndef MIN
#define MIN(a, b)   ((a) > (b) ? b: a)
#endif

//
// The driver should put the data(after Ethernet header) at 8-bytes boundary
//
#define ETH_DATA_ALIGN                      8   // the data(after Ethernet header) should be 8-byte aligned
// 
// Shift HW_RFD 0xA bytes to make Tcp data 8-byte aligned
// Since the ethernet header is 14 bytes long. If a packet is at 0xA bytes 
// offset, its data(ethernet user data) will be at 8 byte boundary
// 
#define HWRFD_SHIFT_OFFSET                0xA   // Shift HW_RFD 0xA bytes to make Tcp data 8-byte aligned

//
// The driver has to allocate more data then HW_RFD needs to allow shifting data
// 
#define MORE_DATA_FOR_ALIGN         (ETH_DATA_ALIGN + HWRFD_SHIFT_OFFSET)
//
// Get a 8-bytes aligned memory address from a given the memory address.
// If the given address is not 8-bytes aligned, return  the closest bigger memory address
// which is 8-bytes aligned. 
// 
#define DATA_ALIGN(_Va)             ((PVOID)(((ULONG_PTR)(_Va) + (ETH_DATA_ALIGN - 1)) & ~(ETH_DATA_ALIGN - 1)))
//
// Get the number of bytes the final address shift from the original address
// 
#define BYTES_SHIFT(_NewVa, _OrigVa) ((PUCHAR)(_NewVa) - (PUCHAR)(_OrigVa))

//--------------------------------------
// Queue structure and macros
//--------------------------------------
typedef struct _QUEUE_ENTRY
{
    struct _QUEUE_ENTRY *Next;
} QUEUE_ENTRY, *PQUEUE_ENTRY;

typedef struct _QUEUE_HEADER
{
    PQUEUE_ENTRY Head;
    PQUEUE_ENTRY Tail;
} QUEUE_HEADER, *PQUEUE_HEADER;

#define ETH_IS_LOCALLY_ADMINISTERED(Address) \
    (BOOLEAN)(((PUCHAR)(Address))[0] & ((UCHAR)0x02))
    

#define InitializeQueueHeader(QueueHeader)                 \
    {                                                      \
        (QueueHeader)->Head = (QueueHeader)->Tail = NULL;  \
    }

#define IsQueueEmpty(QueueHeader) ((QueueHeader)->Head == NULL)

#define RemoveHeadQueue(QueueHeader)                  \
    (QueueHeader)->Head;                              \
    {                                                 \
        PQUEUE_ENTRY pNext;                           \
        ASSERT((QueueHeader)->Head);                  \
        pNext = (QueueHeader)->Head->Next;            \
        (QueueHeader)->Head = pNext;                  \
        if (pNext == NULL)                            \
            (QueueHeader)->Tail = NULL;               \
    }

#define InsertHeadQueue(QueueHeader, QueueEntry)                \
    {                                                           \
        ((PQUEUE_ENTRY)QueueEntry)->Next = (QueueHeader)->Head; \
        (QueueHeader)->Head = (PQUEUE_ENTRY)(QueueEntry);       \
        if ((QueueHeader)->Tail == NULL)                        \
            (QueueHeader)->Tail = (PQUEUE_ENTRY)(QueueEntry);   \
    }

#define InsertTailQueue(QueueHeader, QueueEntry)                     \
    {                                                                \
        ((PQUEUE_ENTRY)QueueEntry)->Next = NULL;                     \
        if ((QueueHeader)->Tail)                                     \
            (QueueHeader)->Tail->Next = (PQUEUE_ENTRY)(QueueEntry);  \
        else                                                         \
            (QueueHeader)->Head = (PQUEUE_ENTRY)(QueueEntry);        \
        (QueueHeader)->Tail = (PQUEUE_ENTRY)(QueueEntry);            \
    }

//--------------------------------------
// Common fragment list structure
// Identical to the scatter gather frag list structure
// This is created to simplify the NIC-specific portion code
//--------------------------------------
#define MP_FRAG_ELEMENT SCATTER_GATHER_ELEMENT 
#define PMP_FRAG_ELEMENT PSCATTER_GATHER_ELEMENT 

typedef struct _MP_FRAG_LIST {
    ULONG NumberOfElements;
    ULONG_PTR Reserved;
    MP_FRAG_ELEMENT Elements[NIC_MAX_PHYS_BUF_COUNT];
} MP_FRAG_LIST, *PMP_FRAG_LIST;
                     

//--------------------------------------
// Some utility macros        
//--------------------------------------
#ifndef min
#define min(_a, _b)     (((_a) < (_b)) ? (_a) : (_b))
#endif

#ifndef max
#define max(_a, _b)     (((_a) > (_b)) ? (_a) : (_b))
#endif

#define MP_ALIGNMEM(_p, _align) (((_align) == 0) ? (_p) : (PUCHAR)(((ULONG_PTR)(_p) + ((_align)-1)) & (~((ULONG_PTR)(_align)-1))))
#define MP_ALIGNMEM_PHYS(_p, _align) (((_align) == 0) ?  (_p) : (((ULONG)(_p) + ((_align)-1)) & (~((ULONG)(_align)-1))))
#define MP_ALIGNMEM_PA(_p, _align) (((_align) == 0) ?  (_p).QuadPart : (((_p).QuadPart + ((_align)-1)) & (~((ULONGLONG)(_align)-1))))

#define GetListHeadEntry(ListHead)  ((ListHead)->Flink)
#define GetListTailEntry(ListHead)  ((ListHead)->Blink)
#define GetListFLink(ListEntry)     ((ListEntry)->Flink)

#define IsSListEmpty(ListHead)  (((PSINGLE_LIST_ENTRY)ListHead)->Next == NULL)

#define MP_EXIT goto exit

//--------------------------------------
// Memory manipulation macros        
//--------------------------------------

/*++
VOID
MP_MEMSET(
    IN  PVOID       Pointer,
    IN  ULONG       Length,
    IN  UCHAR       Value
    )
--*/
#define MP_MEMSET(Pointer, Length, Value)   NdisFillMemory(Pointer, Length, Value)

/*++
VOID
MP_MEMCOPY(
    IN  POPAQUE     Destn,
    IN  POPAQUE     Source,
    IN  ULONG       Length
    )
--*/
#define MP_MEMCOPY(Destn, Source, Length) NdisMoveMemory((Destn), (Source), (Length))


/*++
ULONG
MP_MEMCOPY(
    IN  PVOID       Destn,
    IN  PVOID       Source,
    IN  ULONG       Length
    )
--*/
#define MPMemCmp(Destn, Source, Length)   \
    RtlCompareMemory((PUCHAR)(Destn), (PUCHAR)(Source), (ULONG)(Length))

#if DBG

/*++
PVOID
MP_ALLOCMEM(
    IN  ULONG   Size
    )
--*/
#define MP_ALLOCMEM(pptr, size, flags, highest) \
    MPAuditAllocMem(pptr, size, flags, highest, _FILENUMBER, __LINE__);

#define MP_ALLOCMEMTAG(pptr, size) \
    MPAuditAllocMemTag(pptr, size, _FILENUMBER, __LINE__);

/*++
VOID
MP_FREEMEM(
    IN  PVOID   Pointer
    )
--*/
#define MP_FREEMEM(ptr, size, flags) MPAuditFreeMem(ptr, size, flags)

#else // DBG

#define MP_ALLOCMEM(pptr, size, flags, highest) \
    NdisAllocateMemory(pptr, size, flags, highest)

#define MP_ALLOCMEMTAG(pptr, size) \
    NdisAllocateMemoryWithTag(pptr, size, NIC_TAG)

#define MP_FREEMEM(ptr, size, flags) NdisFreeMemory(ptr, size, flags)

#endif 

#define MP_FREE_NDIS_STRING(str)                        \
    MP_FREEMEM((str)->Buffer, (str)->MaximumLength, 0); \
    (str)->Length = 0;                                  \
    (str)->MaximumLength = 0;                           \
    (str)->Buffer = NULL;

//--------------------------------------
// Macros for flag and ref count operations       
//--------------------------------------
#define MP_SET_FLAG(_M, _F)         ((_M)->Flags |= (_F))   
#define MP_CLEAR_FLAG(_M, _F)       ((_M)->Flags &= ~(_F))
#define MP_CLEAR_FLAGS(_M)          ((_M)->Flags = 0)
#define MP_TEST_FLAG(_M, _F)        (((_M)->Flags & (_F)) != 0)
#define MP_TEST_FLAGS(_M, _F)       (((_M)->Flags & (_F)) == (_F))

#define MP_INC_REF(_A)              NdisInterlockedIncrement(&(_A)->RefCount)
#define MP_DEC_REF(_A)              NdisInterlockedDecrement(&(_A)->RefCount); ASSERT(_A->RefCount >= 0)
#define MP_GET_REF(_A)              ((_A)->RefCount)

#define MP_INC_RCV_REF(_A)          ((_A)->RcvRefCount++)
#define MP_DEC_RCV_REF(_A)          ((_A)->RcvRefCount--)
#define MP_GET_RCV_REF(_A)          ((_A)->RcvRefCount)
   

#define MP_LBFO_INC_REF(_A)         NdisInterlockedIncrement(&(_A)->RefCountLBFO)
#define MP_LBFO_DEC_REF(_A)         NdisInterlockedDecrement(&(_A)->RefCountLBFO); ASSERT(_A->RefCountLBFO >= 0)
#define MP_LBFO_GET_REF(_A)         ((_A)->RefCountLBFO)


//--------------------------------------
// Coalesce Tx buffer for local data copying                     
//--------------------------------------
typedef struct _MP_TXBUF
{
    SINGLE_LIST_ENTRY       SList;
    PNDIS_BUFFER            NdisBuffer;

    ULONG                   AllocSize;
    PVOID                   AllocVa;
    NDIS_PHYSICAL_ADDRESS   AllocPa; 

    PUCHAR                  pBuffer;
    NDIS_PHYSICAL_ADDRESS   BufferPa;
    ULONG                   BufferSize;

} MP_TXBUF, *PMP_TXBUF;

//--------------------------------------
// TCB (Transmit Control Block)
//--------------------------------------
typedef struct _MP_TCB
{
    struct _MP_TCB    *Next;
    ULONG             Flags;
    ULONG             Count;
    PNDIS_PACKET      Packet;

    PMP_TXBUF         MpTxBuf;
    PHW_TCB           HwTcb;            // ptr to HW TCB VA
    ULONG             HwTcbPhys;        // ptr to HW TCB PA
    PHW_TCB           PrevHwTcb;        // ptr to previous HW TCB VA

    PTBD_STRUC        HwTbd;            // ptr to first TBD 
    ULONG             HwTbdPhys;        // ptr to first TBD PA

    ULONG             PhysBufCount;                                 
    ULONG             BufferCount;   
    PNDIS_BUFFER      FirstBuffer;                              
    ULONG             PacketLength;


} MP_TCB, *PMP_TCB;

//--------------------------------------
// RFD (Receive Frame Descriptor)
//--------------------------------------
typedef struct _MP_RFD
{
    LIST_ENTRY              List;
    PNDIS_PACKET            NdisPacket;
    PNDIS_BUFFER            NdisBuffer;          // Pointer to Buffer

    PHW_RFD                 HwRfd;               // ptr to hardware RFD
    PHW_RFD                 OriginalHwRfd;       // ptr to memory allocated by NDIS
    NDIS_PHYSICAL_ADDRESS   HwRfdPa;             // physical address of RFD   
    NDIS_PHYSICAL_ADDRESS   OriginalHwRfdPa;     // Original physical address allocated by NDIS
    ULONG                   HwRfdPhys;          // lower part of HwRfdPa 
    
    ULONG                   Flags;
    UINT                    PacketSize;         // total size of receive frame
} MP_RFD, *PMP_RFD;

//--------------------------------------
// Structure for pended OIS query request
//--------------------------------------
typedef struct _MP_QUERY_REQUEST
{
    IN NDIS_OID Oid;
    IN PVOID InformationBuffer;
    IN ULONG InformationBufferLength;
    OUT PULONG BytesWritten;
    OUT PULONG BytesNeeded;
} MP_QUERY_REQUEST, *PMP_QUERY_REQUEST;

//--------------------------------------
// Structure for pended OIS set request
//--------------------------------------
typedef struct _MP_SET_REQUEST
{
    IN NDIS_OID Oid;
    IN PVOID InformationBuffer;
    IN ULONG InformationBufferLength;
    OUT PULONG BytesRead;
    OUT PULONG BytesNeeded;
} MP_SET_REQUEST, *PMP_SET_REQUEST;

//--------------------------------------
// Structure for Power Management Info
//--------------------------------------
typedef struct _MP_POWER_MGMT
{


    // List of Wake Up Patterns
    LIST_ENTRY              PatternList;

    // Number of outstanding Rcv Packet.
    UINT                    OutstandingRecv;
    // Current Power state of the adapter
    UINT                    PowerState;

    // Is PME_En on this adapter
    BOOLEAN                 PME_En;

    // Wake-up capabailities of the adapter
    BOOLEAN                 bWakeFromD0;
    BOOLEAN                 bWakeFromD1;
    BOOLEAN                 bWakeFromD2;
    BOOLEAN                 bWakeFromD3Hot;
    BOOLEAN                 bWakeFromD3Aux;
    // Pad
    BOOLEAN                 Pad[2];

} MP_POWER_MGMT, *PMP_POWER_MGMT;

typedef struct _MP_WAKE_PATTERN 
{
    // Link to the next Pattern
    LIST_ENTRY      linkListEntry;

    // E100 specific signature of the pattern
    ULONG           Signature;

    // Size of this allocation
    ULONG           AllocationSize;

    // Pattern - This contains the NDIS_PM_PACKET_PATTERN
    UCHAR           Pattern[1];
    
} MP_WAKE_PATTERN , *PMP_WAKE_PATTERN ;

//--------------------------------------
// Macros specific to miniport adapter structure 
//--------------------------------------
#define MP_TCB_RESOURCES_AVAIABLE(_M) ((_M)->nBusySend < (_M)->NumTcb)

#define MP_SHOULD_FAIL_SEND(_M)   ((_M)->Flags & fMP_ADAPTER_FAIL_SEND_MASK) 
#define MP_IS_NOT_READY(_M)       ((_M)->Flags & fMP_ADAPTER_NOT_READY_MASK)
#define MP_IS_READY(_M)           !((_M)->Flags & fMP_ADAPTER_NOT_READY_MASK)

#define MP_SET_PACKET_RFD(_p, _rfd)  *((PMP_RFD *)&(_p)->MiniportReserved[0]) = _rfd
#define MP_GET_PACKET_RFD(_p)        *((PMP_RFD *)&(_p)->MiniportReserved[0])
#define MP_GET_PACKET_MR(_p)         (&(_p)->MiniportReserved[0]) 

#define MP_SET_HARDWARE_ERROR(adapter)    MP_SET_FLAG(adapter, fMP_ADAPTER_HARDWARE_ERROR) 
#define MP_SET_NON_RECOVER_ERROR(adapter) MP_SET_FLAG(adapter, fMP_ADAPTER_NON_RECOVER_ERROR)

#define MP_OFFSET(field)   ((UINT)FIELD_OFFSET(MP_ADAPTER,field))
#define MP_SIZE(field)     sizeof(((PMP_ADAPTER)0)->field)

#if OFFLOAD


// The offload capabilities of the miniport
typedef struct _NIC_TASK_OFFLOAD
{
    ULONG   ChecksumOffload:1;
    ULONG   LargeSendOffload:1;
    ULONG   IpSecOffload:1;

}NIC_TASK_OFFLOAD;

// Checksum offload capabilities
typedef struct _NIC_CHECKSUM_OFFLOAD
{
    ULONG   DoXmitTcpChecksum:1;
    ULONG   DoRcvTcpChecksum:1;
    ULONG   DoXmitUdpChecksum:1;
    ULONG   DoRcvUdpChecksum:1;
    ULONG   DoXmitIpChecksum:1;
    ULONG   DoRcvIpChecksum:1;
    
}NIC_CHECKSUM_OFFLOAD;

// LargeSend offload information
typedef struct _NIC_LARGE_SEND_OFFLOAD
{
    NDIS_TASK_TCP_LARGE_SEND LargeSendInfo;
}NIC_LARGE_SEND_OFFLOAD;

// IpSec offload information

//
// shared memory for offloading
typedef struct _OFFLOAD_SHARED_MEM
{
    PVOID  StartVa;
    NDIS_PHYSICAL_ADDRESS  PhyAddr;
}OFFLOAD_SHARED_MEM;

#endif


//--------------------------------------
// The miniport adapter structure
//--------------------------------------
typedef struct _MP_ADAPTER MP_ADAPTER, *PMP_ADAPTER;
typedef struct _MP_ADAPTER
{
    LIST_ENTRY              List;
    
    // Handle given by NDIS when the Adapter registered itself.
    NDIS_HANDLE             AdapterHandle;

    //flags 
    ULONG                   Flags;

    // configuration 
    UCHAR                   PermanentAddress[ETH_LENGTH_OF_ADDRESS];
    UCHAR                   CurrentAddress[ETH_LENGTH_OF_ADDRESS];
    BOOLEAN                 bOverrideAddress;

    NDIS_EVENT              ExitEvent;

    // SEND                       
    PMP_TCB                 CurrSendHead;
    PMP_TCB                 CurrSendTail;
    LONG                    nBusySend;
    LONG                    nWaitSend;
    LONG                    nCancelSend;
    QUEUE_HEADER            SendWaitQueue;
    QUEUE_HEADER            SendCancelQueue;
    SINGLE_LIST_ENTRY       SendBufList;

    LONG                    NumTcb;             // Total number of TCBs
    LONG                    RegNumTcb;          // 'NumTcb'
    LONG                    NumTbd;
    LONG                    NumBuffers;

    NDIS_HANDLE             SendBufferPool;

    PUCHAR                  MpTcbMem;
    ULONG                   MpTcbMemSize;

    PUCHAR                  MpTxBufMem;
    ULONG                   MpTxBufMemSize;

    PUCHAR                  HwSendMemAllocVa;
    ULONG                   HwSendMemAllocSize;
    NDIS_PHYSICAL_ADDRESS   HwSendMemAllocPa;

    // Map register variables (for win9x)
    UINT                    CurrMapRegHead;
    UINT                    CurrMapRegTail;

    // command unit status flags
    BOOLEAN                 TransmitIdle;
    BOOLEAN                 ResumeWait;

    // RECV
    LIST_ENTRY              RecvList;
    LIST_ENTRY              RecvPendList;
    LONG                    nReadyRecv;
    LONG                    RefCount;

    LONG                    NumRfd;
    LONG                    CurrNumRfd;
    LONG                    MaxNumRfd;
    ULONG                   HwRfdSize;
    BOOLEAN                 bAllocNewRfd;
    LONG                    RfdShrinkCount;

    NDIS_HANDLE             RecvPacketPool;
    NDIS_HANDLE             RecvBufferPool;

    // spin locks
    NDIS_SPIN_LOCK          Lock;

    // lookaside lists                               
    NPAGED_LOOKASIDE_LIST   RecvLookaside;

    // Packet Filter and look ahead size.
    ULONG                   PacketFilter;
    ULONG                   OldPacketFilter;
    ULONG                   ulLookAhead;
    USHORT                  usLinkSpeed;
    USHORT                  usDuplexMode;

    // multicast list
    UINT                    MCAddressCount;
    UCHAR                   MCList[NIC_MAX_MCAST_LIST][ETH_LENGTH_OF_ADDRESS];

    // Packet counts
    ULONG64                 GoodTransmits;
    ULONG64                 GoodReceives;
    ULONG                   NumTxSinceLastAdjust;

    // Count of transmit errors
    ULONG                   TxAbortExcessCollisions;
    ULONG                   TxLateCollisions;
    ULONG                   TxDmaUnderrun;
    ULONG                   TxLostCRS;
    ULONG                   TxOKButDeferred;
    ULONG                   OneRetry;
    ULONG                   MoreThanOneRetry;
    ULONG                   TotalRetries;

    // Count of receive errors
    ULONG                   RcvCrcErrors;
    ULONG                   RcvAlignmentErrors;
    ULONG                   RcvResourceErrors;
    ULONG                   RcvDmaOverrunErrors;
    ULONG                   RcvCdtFrames;
    ULONG                   RcvRuntErrors;

    ULONG                   IoBaseAddress;    
    ULONG                   IoRange;           
    ULONG                   InterruptLevel;
    NDIS_PHYSICAL_ADDRESS   MemPhysAddress;

    PVOID                   PortOffset;
    PHW_CSR                 CSRAddress;
    NDIS_MINIPORT_INTERRUPT Interrupt;

    // Revision ID
    UCHAR                   RevsionID;

    USHORT                  SubVendorID;
    USHORT                  SubSystemID;

    ULONG                   CacheFillSize;
    ULONG                   Debug;

    PUCHAR                  HwMiscMemAllocVa;
    ULONG                   HwMiscMemAllocSize;
    NDIS_PHYSICAL_ADDRESS   HwMiscMemAllocPa;

    PSELF_TEST_STRUC        SelfTest;           // 82558 SelfTest
    ULONG                   SelfTestPhys;

    PNON_TRANSMIT_CB        NonTxCmdBlock;      // 82558 (non transmit) Command Block
    ULONG                   NonTxCmdBlockPhys;

    PDUMP_AREA_STRUC        DumpSpace;          // 82558 dump buffer area
    ULONG                   DumpSpacePhys;

    PERR_COUNT_STRUC        StatsCounters;
    ULONG                   StatsCounterPhys;

    UINT                    PhyAddress;         // Address of the phy component 
    UCHAR                   Connector;          // 0=Auto, 1=TPE, 2=MII

    USHORT                  AiTxFifo;           // TX FIFO Threshold
    USHORT                  AiRxFifo;           // RX FIFO Threshold
    UCHAR                   AiTxDmaCount;       // Tx dma count
    UCHAR                   AiRxDmaCount;       // Rx dma count
    UCHAR                   AiUnderrunRetry;    // The underrun retry mechanism
    UCHAR                   AiForceDpx;         // duplex setting
    USHORT                  AiTempSpeed;        // 'Speed', user over-ride of line speed
    USHORT                  AiThreshold;        // 'Threshold', Transmit Threshold
    BOOLEAN                 MWIEnable;          // Memory Write Invalidate bit in the PCI command word
    UCHAR                   Congest;            // Enables congestion control
    UCHAR                   SpeedDuplex;        // New reg value for speed/duplex

    NDIS_MEDIA_STATE        MediaState;

    NDIS_DEVICE_POWER_STATE CurrentPowerState;
    NDIS_DEVICE_POWER_STATE NextPowerState;

    UCHAR                   OldParameterField;

    // WMI support
    ULONG                   CustomDriverSet;
    ULONG                   HwErrCount;

    // Minimize init-time 
    BOOLEAN                 bQueryPending;
    BOOLEAN                 bSetPending;
    BOOLEAN                 bResetPending;
    NDIS_MINIPORT_TIMER     LinkDetectionTimer;
    MP_QUERY_REQUEST        QueryRequest;
    MP_SET_REQUEST          SetRequest;
    
    BOOLEAN                 bLinkDetectionWait;
    BOOLEAN                 bLookForLink;
    UCHAR                   CurrentScanPhyIndex;
    UCHAR                   LinkDetectionWaitCount;
    UCHAR                   FoundPhyAt;
    USHORT                  EepromAddressSize;

    MP_POWER_MGMT           PoMgmt;

#if LBFO
    PMP_ADAPTER             PrimaryAdapter;
    LONG                    NumSecondary;
    PMP_ADAPTER             NextSecondary;
    NDIS_SPIN_LOCK          LockLBFO;
    LONG                    RefCountLBFO;
    NDIS_STRING             BundleId;           // BundleId
#endif 
   
    NDIS_SPIN_LOCK          SendLock;
    NDIS_SPIN_LOCK          RcvLock;
    ULONG                   RcvRefCount;  // number of packets that have not been returned back
    NDIS_EVENT              AllPacketsReturnedEvent;
    ULONG                   WakeUpEnable;

#if OFFLOAD    
    // Add for checksum offloading
    LONG                    SharedMemRefCount;  
    ULONG                   OffloadSharedMemSize;
    OFFLOAD_SHARED_MEM      OffloadSharedMem;
    NIC_TASK_OFFLOAD        NicTaskOffload;
    NIC_CHECKSUM_OFFLOAD    NicChecksumOffload;
    NDIS_TASK_TCP_LARGE_SEND LargeSendInfo;
    BOOLEAN                 OffloadEnable;
    
    NDIS_ENCAPSULATION_FORMAT   EncapsulationFormat;
#endif

} MP_ADAPTER, *PMP_ADAPTER;

//--------------------------------------
// Stall execution and wait with timeout
//--------------------------------------
/*++
    _condition  - condition to wait for 
    _timeout_ms - timeout value in milliseconds
    _result     - TRUE if condition becomes true before it times out
--*/
#define MP_STALL_AND_WAIT(_condition, _timeout_ms, _result)     \
{                                                               \
    int counter;                                                \
    _result = FALSE;                                            \
    for(counter = _timeout_ms * 50; counter != 0; counter--)    \
    {                                                           \
        if(_condition)                                          \
        {                                                       \
            _result = TRUE;                                     \
            break;                                              \
        }                                                       \
        NdisStallExecution(20);                                 \
    }                                                           \
}

__inline VOID MP_STALL_EXECUTION(
   IN UINT MsecDelay)
{
    // Delay in 100 usec increments
    MsecDelay *= 10;
    while (MsecDelay)
    {
        NdisStallExecution(100);
        MsecDelay--;
    }
}



#if LBFO
#define MP_GET_ADAPTER_HANDLE(_A) (_A)->PrimaryAdapter->AdapterHandle

typedef struct _MP_GLOBAL_DATA
{
    LIST_ENTRY AdapterList;
    NDIS_SPIN_LOCK Lock;
    ULONG ulIndex;
} MP_GLOBAL_DATA, *PMP_GLOBAL_DATA;
#else
#define MP_GET_ADAPTER_HANDLE(_A) (_A)->AdapterHandle
#endif

__inline NDIS_STATUS MP_GET_STATUS_FROM_FLAGS(PMP_ADAPTER Adapter)
{
    NDIS_STATUS Status = NDIS_STATUS_FAILURE;

    if(MP_TEST_FLAG(Adapter, fMP_ADAPTER_RESET_IN_PROGRESS))
    {
        Status = NDIS_STATUS_RESET_IN_PROGRESS;      
    }
    else if(MP_TEST_FLAG(Adapter, fMP_ADAPTER_HARDWARE_ERROR))
    {
        Status = NDIS_STATUS_DEVICE_FAILED;
    }
    else if(MP_TEST_FLAG(Adapter, fMP_ADAPTER_NO_CABLE))
    {
        Status = NDIS_STATUS_NO_CABLE;
    }

    return Status;
}   

//--------------------------------------
// Miniport routines in MP_MAIN.C
//--------------------------------------

NDIS_STATUS DriverEntry(
    IN  PDRIVER_OBJECT      DriverObject,
    IN  PUNICODE_STRING     RegistryPath);

VOID MPAllocateComplete(
    NDIS_HANDLE MiniportAdapterContext,
    IN PVOID VirtualAddress,
    IN PNDIS_PHYSICAL_ADDRESS PhysicalAddress,
    IN ULONG Length,
    IN PVOID Context);

BOOLEAN MPCheckForHang(
    IN NDIS_HANDLE MiniportAdapterContext);

VOID MPHalt(
    IN  NDIS_HANDLE MiniportAdapterContext);

NDIS_STATUS MPInitialize(
    OUT PNDIS_STATUS OpenErrorStatus,
    OUT PUINT SelectedMediumIndex,
    IN PNDIS_MEDIUM MediumArray,
    IN UINT MediumArraySize,
    IN NDIS_HANDLE MiniportAdapterHandle,
    IN NDIS_HANDLE WrapperConfigurationContext);

VOID MPHandleInterrupt(
    IN NDIS_HANDLE MiniportAdapterContext);

VOID MPIsr(
    OUT PBOOLEAN InterruptRecognized,
    OUT PBOOLEAN QueueMiniportHandleInterrupt,
    IN NDIS_HANDLE MiniportAdapterContext);

NDIS_STATUS MPQueryInformation(
    IN NDIS_HANDLE MiniportAdapterContext,
    IN NDIS_OID Oid,
    IN PVOID InformationBuffer,
    IN ULONG InformationBufferLength,
    OUT PULONG BytesWritten,
    OUT PULONG BytesNeeded);

NDIS_STATUS MPReset(
    OUT PBOOLEAN AddressingReset,
    IN  NDIS_HANDLE MiniportAdapterContext);

VOID MPReturnPacket(
    IN NDIS_HANDLE  MiniportAdapterContext,
    IN PNDIS_PACKET Packet);

VOID MPSendPackets(
    IN  NDIS_HANDLE             MiniportAdapterContext,
    IN  PPNDIS_PACKET           PacketArray,
    IN  UINT                    NumberOfPackets);

NDIS_STATUS MPSetInformation(
    IN NDIS_HANDLE MiniportAdapterContext,
    IN NDIS_OID Oid,
    IN PVOID InformationBuffer,
    IN ULONG InformationBufferLength,
    OUT PULONG BytesRead,
    OUT PULONG BytesNeeded);

VOID MPShutdown(
    IN  NDIS_HANDLE MiniportAdapterContext);

#ifdef NDIS51_MINIPORT
VOID MPCancelSendPackets(
    IN  NDIS_HANDLE    MiniportAdapterContext,
    IN  PVOID             CancelId);

VOID MPPnPEventNotify(
    IN  NDIS_HANDLE                MiniportAdapterContext,
    IN  NDIS_DEVICE_PNP_EVENT   PnPEvent,
    IN  PVOID                         InformationBuffer,
    IN  ULONG                         InformationBufferLength);
#endif   

NDIS_STATUS
MPSetPowerD0Private (
    IN MP_ADAPTER* pAdapter
    );

VOID
MPSetPowerLowPrivate(
    PMP_ADAPTER Adapter 
    );

VOID 
MpExtractPMInfoFromPciSpace(
    PMP_ADAPTER pAdapter,
    PUCHAR pPciConfig
    );

VOID
HwSetWakeUpConfigure(
    IN PMP_ADAPTER pAdapter, 
    PUCHAR pPoMgmtConfigType, 
    UINT WakeUpParameter
    );

BOOLEAN  
MPIsPoMgmtSupported(
   IN PMP_ADAPTER pAdapter
   );

VOID 
NICIssueSelectiveReset(
    PMP_ADAPTER Adapter);

NDIS_STATUS
MPCalculateE100PatternForFilter (
    IN PUCHAR pFrame,
    IN ULONG FrameLength,
    IN PUCHAR pMask,
    IN ULONG MaskLength,
    OUT PULONG pSignature
    );

VOID
MPRemoveAllWakeUpPatterns(
    PMP_ADAPTER pAdapter
    );

VOID
MpSetPowerLowComplete(
    IN PMP_ADAPTER Adapter
    );


#if LBFO
VOID MPUnload(IN PDRIVER_OBJECT DriverObject);

VOID MpAddAdapterToList(PMP_ADAPTER Adapter);
VOID MpRemoveAdapterFromList(PMP_ADAPTER Adapter);
VOID MpPromoteSecondary(PMP_ADAPTER Adapter);
#endif


//
// Define different functions depending on OFFLOAD is on or not
// 
#if OFFLOAD
#define MpSendPacketsHandler  MPOffloadSendPackets

#define  MP_FREE_SEND_PACKET_FUN(Adapter, pMpTcb)  MP_OFFLOAD_FREE_SEND_PACKET(Adapter, pMpTcb)

#define  MpSendPacketFun(Adapter, Packet, bFromQueue) MpOffloadSendPacket(Adapter, Packet, bFromQueue)

#else    

#define MpSendPacketsHandler  MPSendPackets

#define  MP_FREE_SEND_PACKET_FUN(Adapter, pMpTcb)  MP_FREE_SEND_PACKET(Adapter, pMpTcb)

#define  MpSendPacketFun(Adapter, Packet, bFromQueue) MpSendPacket(Adapter, Packet,bFromQueue)

#endif // end OFFLOAD    


#endif  // _MP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\net\ms\e100bex\mp_def.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:
    mp_def.h

Abstract:
    NIC specific definitions

Revision History:
    Who         When        What
    --------    --------    ----------------------------------------------
    DChen       11-01-99    created

Notes:

--*/

#ifndef _MP_DEF_H
#define _MP_DEF_H

// memory tag for this driver   
#define NIC_TAG                         ((ULONG)'001E')
#define NIC_DBG_STRING                  ("**E100**") 

// packet and header sizes
#define NIC_MAX_PACKET_SIZE             1514
#define NIC_MIN_PACKET_SIZE             60
#define NIC_HEADER_SIZE                 14

// multicast list size                          
#define NIC_MAX_MCAST_LIST              32

// update the driver version number every time you release a new driver
// The high word is the major version. The low word is the minor version. 
#define NIC_VENDOR_DRIVER_VERSION       0x00010006

// NDIS version in use by the NIC driver. 
// The high byte is the major version. The low byte is the minor version. 
#ifdef NDIS51_MINIPORT
#define NIC_DRIVER_VERSION              0x0501
#else
#define NIC_DRIVER_VERSION              0x0500
#endif

// media type, we use ethernet, change if necessary
#define NIC_MEDIA_TYPE                  NdisMedium802_3

// interface type, we use PCI
#define NIC_INTERFACE_TYPE              NdisInterfacePci
#define NIC_INTERRUPT_MODE              NdisInterruptLevelSensitive 

// NIC PCI Device and vendor IDs 
#define NIC_PCI_DEVICE_ID               0x1229
#define NIC_PCI_VENDOR_ID               0x8086

// buffer size passed in NdisMQueryAdapterResources                            
// We should only need three adapter resources (IO, interrupt and memory),
// Some devices get extra resources, so have room for 10 resources 
#define NIC_RESOURCE_BUF_SIZE           (sizeof(NDIS_RESOURCE_LIST) + \
                                        (10*sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR)))

// IO space length
#define NIC_MAP_IOSPACE_LENGTH          sizeof(CSR_STRUC)

// PCS config space including the Device Specific part of it/
#define NIC_PCI_E100_HDR_LENGTH         0xe2

// define some types for convenience
// TXCB_STRUC, RFD_STRUC and CSR_STRUC are hardware specific structures

// hardware TCB (Transmit Control Block) structure
typedef TXCB_STRUC                      HW_TCB; 
typedef PTXCB_STRUC                     PHW_TCB;

// hardware RFD (Receive Frame Descriptor) structure                         
typedef RFD_STRUC                       HW_RFD;  
typedef PRFD_STRUC                      PHW_RFD;               

// hardware CSR (Control Status Register) structure                         
typedef CSR_STRUC                       HW_CSR;                                       
typedef PCSR_STRUC                      PHW_CSR;                                      

// change to your company name instead of using Microsoft
#define NIC_VENDOR_DESC                 "Microsoft"

// number of TCBs per processor - min, default and max
#define NIC_MIN_TCBS                    1
#define NIC_DEF_TCBS                    32
#define NIC_MAX_TCBS                    64

// max number of physical fragments supported per TCB
#define NIC_MAX_PHYS_BUF_COUNT          8     

// number of RFDs - min, default and max
#define NIC_MIN_RFDS                    4
#define NIC_DEF_RFDS                    20
#define NIC_MAX_RFDS                    1024

// only grow the RFDs up to this number
#define NIC_MAX_GROW_RFDS               128 

// How many intervals before the RFD list is shrinked?
#define NIC_RFD_SHRINK_THRESHOLD        10

// local data buffer size (to copy send packet data into a local buffer)
#define NIC_BUFFER_SIZE                 1520

// max lookahead size
#define NIC_MAX_LOOKAHEAD               (NIC_MAX_PACKET_SIZE - NIC_HEADER_SIZE)

// max number of send packets the MiniportSendPackets function can accept                            
#define NIC_MAX_SEND_PACKETS            10

// supported filters
#define NIC_SUPPORTED_FILTERS (     \
    NDIS_PACKET_TYPE_DIRECTED       | \
    NDIS_PACKET_TYPE_MULTICAST      | \
    NDIS_PACKET_TYPE_BROADCAST      | \
    NDIS_PACKET_TYPE_PROMISCUOUS    | \
    NDIS_PACKET_TYPE_ALL_MULTICAST)

// Threshold for a remove 
#define NIC_HARDWARE_ERROR_THRESHOLD    5

// The CheckForHang intervals before we decide the send is stuck
#define NIC_SEND_HANG_THRESHOLD         5        

// NDIS_ERROR_CODE_ADAPTER_NOT_FOUND                                                     
#define ERRLOG_READ_PCI_SLOT_FAILED     0x00000101L
#define ERRLOG_WRITE_PCI_SLOT_FAILED    0x00000102L
#define ERRLOG_VENDOR_DEVICE_NOMATCH    0x00000103L

// NDIS_ERROR_CODE_ADAPTER_DISABLED
#define ERRLOG_BUS_MASTER_DISABLED      0x00000201L

// NDIS_ERROR_CODE_UNSUPPORTED_CONFIGURATION
#define ERRLOG_INVALID_SPEED_DUPLEX     0x00000301L
#define ERRLOG_SET_SECONDARY_FAILED     0x00000302L

// NDIS_ERROR_CODE_OUT_OF_RESOURCES
#define ERRLOG_OUT_OF_MEMORY            0x00000401L
#define ERRLOG_OUT_OF_SHARED_MEMORY     0x00000402L
#define ERRLOG_OUT_OF_MAP_REGISTERS     0x00000403L
#define ERRLOG_OUT_OF_BUFFER_POOL       0x00000404L
#define ERRLOG_OUT_OF_NDIS_BUFFER       0x00000405L
#define ERRLOG_OUT_OF_PACKET_POOL       0x00000406L
#define ERRLOG_OUT_OF_NDIS_PACKET       0x00000407L
#define ERRLOG_OUT_OF_LOOKASIDE_MEMORY  0x00000408L
#define ERRLOG_OUT_OF_SG_RESOURCES      0x00000409L

// NDIS_ERROR_CODE_HARDWARE_FAILURE
#define ERRLOG_SELFTEST_FAILED          0x00000501L
#define ERRLOG_INITIALIZE_ADAPTER       0x00000502L
#define ERRLOG_REMOVE_MINIPORT          0x00000503L

// NDIS_ERROR_CODE_RESOURCE_CONFLICT
#define ERRLOG_MAP_IO_SPACE             0x00000601L
#define ERRLOG_QUERY_ADAPTER_RESOURCES  0x00000602L
#define ERRLOG_NO_IO_RESOURCE           0x00000603L
#define ERRLOG_NO_INTERRUPT_RESOURCE    0x00000604L
#define ERRLOG_NO_MEMORY_RESOURCE       0x00000605L

// NIC specific macros                                        
#define NIC_RFD_GET_STATUS(_HwRfd) ((_HwRfd)->RfdCbHeader.CbStatus)
#define NIC_RFD_STATUS_COMPLETED(_Status) ((_Status) & RFD_STATUS_COMPLETE)
#define NIC_RFD_STATUS_SUCCESS(_Status) ((_Status) & RFD_STATUS_OK)
#define NIC_RFD_GET_PACKET_SIZE(_HwRfd) (((_HwRfd)->RfdActualCount) & RFD_ACT_COUNT_MASK)
#define NIC_RFD_VALID_ACTUALCOUNT(_HwRfd) ((((_HwRfd)->RfdActualCount) & (RFD_EOF_BIT | RFD_F_BIT)) == (RFD_EOF_BIT | RFD_F_BIT))

// Constants for various purposes of NdisStallExecution

#define NIC_DELAY_POST_RESET            20
// Wait 5 milliseconds for the self-test to complete
#define NIC_DELAY_POST_SELF_TEST_MS     5

                                      
// delay used for link detection to minimize the init time
// change this value to match your hardware 
#define NIC_LINK_DETECTION_DELAY        100




#endif  // _MP_DEF_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\net\ms\e100bex\e100_sup.h ===
/****************************************************************************
** COPYRIGHT (C) 1994-1997 INTEL CORPORATION                               **
** DEVELOPED FOR MICROSOFT BY INTEL CORP., HILLSBORO, OREGON               **
** HTTP://WWW.INTEL.COM/                                                   **
** THIS FILE IS PART OF THE INTEL ETHEREXPRESS PRO/100B(TM) AND            **
** ETHEREXPRESS PRO/100+(TM) NDIS 5.0 MINIPORT SAMPLE DRIVER               **
****************************************************************************/

/****************************************************************************
Module Name:
     e100_sup.h     (inlinef.h)

This driver runs on the following hardware:
     - 82558 based PCI 10/100Mb ethernet adapters
     (aka Intel EtherExpress(TM) PRO Adapters)

Environment:
     Kernel Mode - Or whatever is the equivalent on WinNT

Revision History
     - JCB 8/14/97 Example Driver Created
    - Dchen 11-01-99    Modified for the new sample driver
*****************************************************************************/

//-----------------------------------------------------------------------------
// Procedure:   WaitScb
//
// Description: This routine checks to see if the D100 has accepted a command.
//              It does so by checking the command field in the SCB, which will
//              be zeroed by the D100 upon accepting a command.  The loop waits
//              for up to 600 milliseconds for command acceptance.
//
// Arguments:
//      Adapter - ptr to Adapter object instance
//
// Returns:
//      TRUE if the SCB cleared within 600 milliseconds.
//      FALSE if it didn't clear within 600 milliseconds
//-----------------------------------------------------------------------------
__inline BOOLEAN WaitScb(
    IN PMP_ADAPTER Adapter)
{
    BOOLEAN     bResult;
    
    HW_CSR volatile *pCSRAddress = Adapter->CSRAddress;

    MP_STALL_AND_WAIT(pCSRAddress->ScbCommandLow == 0, 600, bResult);
    if(!bResult)
    {
        DBGPRINT(MP_ERROR, ("WaitScb failed, ScbCommandLow=%x\n", pCSRAddress->ScbCommandLow));
        if(pCSRAddress->ScbCommandLow != 0x80)
        {
            ASSERT(FALSE); 
        }
        MP_SET_HARDWARE_ERROR(Adapter);
    }

    return bResult;
}

//-----------------------------------------------------------------------------
// Procedure:   D100IssueScbCommand
//
// Description: This general routine will issue a command to the D100.
//
// Arguments:
//      Adapter - ptr to Adapter object instance.
//      ScbCommand - The command that is to be issued
//      WaitForSCB - A boolean value indicating whether or not a wait for SCB
//                   must be done before the command is issued to the chip
//
// Returns:
//      TRUE if the command was issued to the chip successfully
//      FALSE if the command was not issued to the chip
//-----------------------------------------------------------------------------
__inline NDIS_STATUS D100IssueScbCommand(
    IN PMP_ADAPTER Adapter,
    IN UCHAR ScbCommandLow,
    IN BOOLEAN WaitForScb)
{
    if(WaitForScb == TRUE)
    {
        if(!WaitScb(Adapter))
        {
            return(NDIS_STATUS_HARD_ERRORS);
        }
    }

    Adapter->CSRAddress->ScbCommandLow = ScbCommandLow;

    return(NDIS_STATUS_SUCCESS);
}

// routines.c           
BOOLEAN MdiRead(
    IN PMP_ADAPTER Adapter,
    IN ULONG       RegAddress,
    IN ULONG       PhyAddress,
    IN BOOLEAN     Recoverable,
    IN OUT PUSHORT DataValue);

VOID MdiWrite(
    IN PMP_ADAPTER Adapter,
    IN ULONG       RegAddress,
    IN ULONG       PhyAddress,
    IN USHORT      DataValue);

NDIS_STATUS D100SubmitCommandBlockAndWait(IN PMP_ADAPTER Adapter);
VOID DumpStatsCounters(IN PMP_ADAPTER Adapter);
NDIS_MEDIA_STATE NICGetMediaState(IN PMP_ADAPTER Adapter);
VOID NICIssueSelectiveReset(PMP_ADAPTER Adapter);
VOID NICIssueFullReset(PMP_ADAPTER Adapter);

// physet.c

VOID ResetPhy(IN PMP_ADAPTER Adapter);
NDIS_STATUS PhyDetect(IN PMP_ADAPTER Adapter);
NDIS_STATUS ScanAndSetupPhy(IN PMP_ADAPTER Adapter);
VOID SelectPhy(
    IN PMP_ADAPTER Adapter,
    IN UINT SelectPhyAddress,
    IN BOOLEAN WaitAutoNeg);
NDIS_STATUS SetupPhy(
    IN PMP_ADAPTER Adapter);

VOID FindPhySpeedAndDpx(
    IN PMP_ADAPTER Adapter,
    IN UINT PhyId);


// eeprom.c
USHORT GetEEpromAddressSize(
    IN USHORT Size);

USHORT GetEEpromSize(
    IN PUCHAR CSRBaseIoAddress);

USHORT ReadEEprom(
    IN PUCHAR CSRBaseIoAddress,
    IN USHORT Reg,
    IN USHORT AddressSize);

VOID ShiftOutBits(
    IN USHORT data,
    IN USHORT count,
    IN PUCHAR CSRBaseIoAddress);

USHORT ShiftInBits(
    IN PUCHAR CSRBaseIoAddress);

VOID RaiseClock(
    IN OUT USHORT *x,
    IN PUCHAR CSRBaseIoAddress);

VOID LowerClock(
    IN OUT USHORT *x,
    IN PUCHAR CSRBaseIoAddress);

VOID EEpromCleanup(
    IN PUCHAR CSRBaseIoAddress);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\net\ms\e100bex\mp_nic.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:
    mp_nic.c

Abstract:
    This module contains miniport send/receive routines

Revision History:
    Who         When        What
    --------    --------    ----------------------------------------------
    DChen       11-01-99    created

Notes:

--*/

#include "precomp.h"

#if DBG
#define _FILENUMBER     'CINM'
#endif

__inline VOID MP_FREE_SEND_PACKET(
    IN  PMP_ADAPTER Adapter,
    IN  PMP_TCB     pMpTcb
    )
/*++
Routine Description:

    Recycle a MP_TCB and complete the packet if necessary
    Assumption: Send spinlock has been acquired 

Arguments:

    Adapter     Pointer to our adapter
    pMpTcb      Pointer to MP_TCB        

Return Value:

    None

--*/
{
    
    PNDIS_PACKET  Packet;
    PNDIS_BUFFER  CurrBuffer;

    ASSERT(MP_TEST_FLAG(pMpTcb, fMP_TCB_IN_USE));

    Packet = pMpTcb->Packet;
    pMpTcb->Packet = NULL;
    pMpTcb->Count = 0;

    if (pMpTcb->MpTxBuf)
    {
        ASSERT(MP_TEST_FLAG(pMpTcb, fMP_TCB_USE_LOCAL_BUF));

        PushEntryList(&Adapter->SendBufList, &pMpTcb->MpTxBuf->SList);
        pMpTcb->MpTxBuf = NULL;
    }
#ifndef NDIS51_MINIPORT    
    else if (MP_TEST_FLAG(Adapter, fMP_ADAPTER_MAP_REGISTER))
    {
        //
        // Complete physical mapping for each buffer in this packet
        //
        ASSERT(Packet);

        CurrBuffer = pMpTcb->FirstBuffer;
        while (CurrBuffer)
        {
            NdisMCompleteBufferPhysicalMapping(
                Adapter->AdapterHandle,
                CurrBuffer,
                Adapter->CurrMapRegHead);

            Adapter->CurrMapRegHead++;
            if (Adapter->CurrMapRegHead == (ULONG)Adapter->NumTbd)
                Adapter->CurrMapRegHead = 0;

            //
            // Get the next buffer
            //
            NdisGetNextBuffer(CurrBuffer, &CurrBuffer);
        }
    }
#endif    

    MP_CLEAR_FLAGS(pMpTcb);

    Adapter->CurrSendHead = Adapter->CurrSendHead->Next;
    Adapter->nBusySend--;
    ASSERT(Adapter->nBusySend >= 0);

    if (Packet)
    {
        NdisReleaseSpinLock(&Adapter->SendLock);
        DBGPRINT(MP_TRACE, ("Calling NdisMSendComplete, Pkt= "PTR_FORMAT"\n", Packet));
        NdisMSendComplete(
            MP_GET_ADAPTER_HANDLE(Adapter),
            Packet,
            NDIS_STATUS_SUCCESS);

        NdisAcquireSpinLock(&Adapter->SendLock);
    }
}

NDIS_STATUS MpSendPacket(
    IN  PMP_ADAPTER   Adapter,
    IN  PNDIS_PACKET  Packet,
    IN  BOOLEAN       bFromQueue
    )
/*++
Routine Description:

    Do the work to send a packet
    Assumption: Send spinlock has been acquired 

Arguments:

    Adapter     Pointer to our adapter
    Packet      The packet
    bFromQueue  TRUE if it's taken from the send wait queue

Return Value:

    NDIS_STATUS_SUCCESS
    NDIS_STATUS_PENDING         Put into the send wait queue
    NDIS_STATUS_HARD_ERRORS

--*/
{
    NDIS_STATUS     Status = NDIS_STATUS_PENDING;
    PMP_TCB         pMpTcb = NULL;
    PMP_TXBUF       pMpTxBuf = NULL;
    ULONG           BytesCopied;
    
    // Mimiced frag list if map registers are used, on the local stack as it's not so big                                         
    MP_FRAG_LIST    FragList;
    
    // Pointer to either the scatter gather or the local mimiced frag list
    PMP_FRAG_LIST   pFragList;

    DBGPRINT(MP_TRACE, ("--> MpSendPacket, Pkt= "PTR_FORMAT"\n", Packet));

    pMpTcb = Adapter->CurrSendTail;
    ASSERT(!MP_TEST_FLAG(pMpTcb, fMP_TCB_IN_USE));

    NdisQueryPacket(
        Packet,
        (PUINT)&pMpTcb->PhysBufCount,
        (PUINT)&pMpTcb->BufferCount,
        &pMpTcb->FirstBuffer,
        (PUINT)&pMpTcb->PacketLength);

    ASSERT(pMpTcb->PhysBufCount);
    ASSERT(pMpTcb->FirstBuffer);
    ASSERT(pMpTcb->PacketLength);

    //
    // Check to see if we need to coalesce
    //
    if (pMpTcb->PacketLength < NIC_MIN_PACKET_SIZE ||
        pMpTcb->PhysBufCount > NIC_MAX_PHYS_BUF_COUNT)
    {
        //
        // A local MP_TXBUF available (for local data copying)?
        //
        if (IsSListEmpty(&Adapter->SendBufList))
        {
            Adapter->nWaitSend++;
            if (bFromQueue)
            {
                InsertHeadQueue(&Adapter->SendWaitQueue, MP_GET_PACKET_MR(Packet));
            }
            else
            {
                InsertTailQueue(&Adapter->SendWaitQueue, MP_GET_PACKET_MR(Packet));
            }

            DBGPRINT(MP_TRACE, ("<-- MpSendPacket - queued, no buf\n"));
            return Status;
        }

        pMpTxBuf = (PMP_TXBUF) PopEntryList(&Adapter->SendBufList);   
        ASSERT(pMpTxBuf);

        //
        // Copy the buffers in this packet, enough to give the first buffer as they are linked
        //
        BytesCopied = MpCopyPacket(pMpTcb->FirstBuffer, pMpTxBuf);
        
        //
        // MpCopyPacket may return 0 if system resources are low or exhausted
        //
        if (BytesCopied == 0)
        {
            PushEntryList(&Adapter->SendBufList, &pMpTxBuf->SList);
        
            DBGPRINT(MP_ERROR, ("Calling NdisMSendComplete with NDIS_STATUS_RESOURCES, Pkt= "PTR_FORMAT"\n", Packet));
    
            NdisReleaseSpinLock(&Adapter->SendLock); 
            NdisMSendComplete(
                MP_GET_ADAPTER_HANDLE(Adapter),
                Packet,
                NDIS_STATUS_RESOURCES);
    
            NdisAcquireSpinLock(&Adapter->SendLock);  
            return NDIS_STATUS_RESOURCES;            
        }

        pMpTcb->MpTxBuf = pMpTxBuf; 

        //
        // Set up the frag list, only one fragment after it's coalesced
        //
        pFragList = &FragList;
        pFragList->NumberOfElements = 1;
        pFragList->Elements[0].Address = pMpTxBuf->BufferPa;
        pFragList->Elements[0].Length = (BytesCopied >= NIC_MIN_PACKET_SIZE) ? 
                                        BytesCopied : NIC_MIN_PACKET_SIZE;
        
        MP_SET_FLAG(pMpTcb, fMP_TCB_USE_LOCAL_BUF);
        //
        // Even the driver uses its local buffer, it has to wait the send complete interrupt to
        // complete the packet. Otherwise, the driver may run into the following situation:
        // before send complete interrupt happens, its halt handler is called and the halt handler 
        // deregisters the interrupt, so no send complete interrupt can happen, and the send 
        // complete interrupt handle routine will never be called to free some resources used 
        // by this send. 
        
    }
    else
    {
#ifdef NDIS51_MINIPORT
        ASSERT(MP_TEST_FLAG(Adapter, fMP_ADAPTER_SCATTER_GATHER));
        //
        // In scatter/gather case, use the frag list pointer saved 
        // in the packet info field
        //
        pFragList = (PMP_FRAG_LIST) NDIS_PER_PACKET_INFO_FROM_PACKET(Packet, 
                                                           ScatterGatherListPacketInfo);
#else        
        if (MP_TEST_FLAG(Adapter, fMP_ADAPTER_SCATTER_GATHER))
        {
            //
            // In scatter/gather case, use the frag list pointer saved 
            // in the packet info field
            //
            pFragList = (PMP_FRAG_LIST) NDIS_PER_PACKET_INFO_FROM_PACKET(Packet, 
                                                           ScatterGatherListPacketInfo);
        }
        else
        {
            //
            // In the map register case, use the local frag list structure
            //
            pFragList = &FragList;

            //
            // Do the physical mapping to get all the fragment physical addresses
            //
            MpStartPacketPhysicalMapping(
                Adapter, 
                pMpTcb->FirstBuffer,
                pFragList);
        }
#endif        

    }

    pMpTcb->Packet = Packet;
    MP_SET_FLAG(pMpTcb, fMP_TCB_IN_USE);

    //
    // Call the NIC specific send handler, it only needs to deal with the frag list
    //
    Status = NICSendPacket(Adapter, pMpTcb, pFragList);

    Adapter->nBusySend++;
    ASSERT(Adapter->nBusySend <= Adapter->NumTcb);
    Adapter->CurrSendTail = Adapter->CurrSendTail->Next;

    DBGPRINT(MP_TRACE, ("<-- MpSendPacket\n"));
    return Status;

}  

ULONG MpCopyPacket(
    IN  PNDIS_BUFFER  CurrBuffer,
    IN  PMP_TXBUF     pMpTxBuf
    ) 
/*++
Routine Description:

    Copy the packet data to a local buffer
    Either the packet is too small or it has too many fragments
    Assumption: Send spinlock has been acquired 

Arguments:

    CurrBuffer  Pointer to the first NDIS_BUFFER    
    pMpTxBuf    Pointer to the local buffer (MP_TXBUF)

Return Value:

    Bytes copied

--*/
{
    UINT    CurrLength;
    PUCHAR  pSrc;
    PUCHAR  pDest;
    UINT    BytesCopied = 0;

    DBGPRINT(MP_TRACE, ("--> MpCopyPacket\n"));

    pDest = pMpTxBuf->pBuffer;

    while ((CurrBuffer) && (BytesCopied < pMpTxBuf->BufferSize))
    {

        //
        // Support for the following API with NormalPagePrioirty was added for 
        // NDIS 5.0 and 5.1 miniports in Windows XP
        //
#if !BUILD_W2K
	NdisQueryBufferSafe( CurrBuffer, &pSrc, &CurrLength, NormalPagePriority );
#else
	NdisQueryBuffer( CurrBuffer, &pSrc, &CurrLength);	
#endif

        if (pSrc == NULL)
        {
            return 0;
        }

        
        if (pMpTxBuf->BufferSize - BytesCopied < CurrLength)
        {
            CurrLength = pMpTxBuf->BufferSize - BytesCopied;
        }
                    
        if (CurrLength)
        {
            //
            // Copy the data.
            //
            NdisMoveMemory(pDest, pSrc, CurrLength);
            BytesCopied += CurrLength;
            pDest += CurrLength;
        }

        NdisGetNextBuffer( CurrBuffer, &CurrBuffer);
    }
    //
    // Zero out the padding bytes
    // 
    if (BytesCopied < NIC_MIN_PACKET_SIZE)
    {
        NdisZeroMemory(pDest, NIC_MIN_PACKET_SIZE - BytesCopied);
    }

    NdisAdjustBufferLength(pMpTxBuf->NdisBuffer, BytesCopied);

    NdisFlushBuffer(pMpTxBuf->NdisBuffer, TRUE);

    ASSERT(BytesCopied <= pMpTxBuf->BufferSize);

    DBGPRINT(MP_TRACE, ("<-- MpCopyPacket\n"));

    return BytesCopied;
}

#ifndef NDIS51_MINIPORT    
VOID MpStartPacketPhysicalMapping(
    IN  PMP_ADAPTER     Adapter, 
    IN  PNDIS_BUFFER    CurrBuffer,
    OUT PMP_FRAG_LIST   pFragList
    )
/*++
Routine Description:

    Call NdisMStartBufferPhysicalMapping on each NDIS buffer
    Get the physical address for each fragment and save them in the fragment list
    We use the same fragment list as the scatter gather so the driver writers only need
    to deal one type. 
    Assumption: spinlock has been acquired 

Arguments:

    Adapter     Pointer to our adapter
    CurrBuffer  Pointer to the first NDIS_BUFFER    
    pFragList   The pointer to the frag list to be filled

Return Value:

    None

--*/
{
    NDIS_PHYSICAL_ADDRESS_UNIT PhysAddrUnits[NIC_MAX_PHYS_BUF_COUNT];   
    UINT            ArraySize, i;
    ULONG           ElementIndex = 0;

    DBGPRINT(MP_TRACE, ("--> MpStartPacketPhysicalMapping\n"));

    while (CurrBuffer)
    {
        NdisMStartBufferPhysicalMapping(
            Adapter->AdapterHandle,
            CurrBuffer,
            Adapter->CurrMapRegTail,
            TRUE,
            PhysAddrUnits,
            &ArraySize);

        Adapter->CurrMapRegTail++;
        if (Adapter->CurrMapRegTail == (ULONG)Adapter->NumTbd)
        {
            Adapter->CurrMapRegTail = 0;
        }

        for (i = 0; i < ArraySize; i++)
        {
            pFragList->Elements[ElementIndex].Address = PhysAddrUnits[i].PhysicalAddress;
            pFragList->Elements[ElementIndex].Length = PhysAddrUnits[i].Length;
            ElementIndex++; 
        }

        //
        // Flush the current buffer because it could be cached
        //
        NdisFlushBuffer(CurrBuffer, TRUE);

        //
        // point to the next buffer
        //
        NdisGetNextBuffer(CurrBuffer, &CurrBuffer);
    }

    pFragList->NumberOfElements = ElementIndex;
    ASSERT(pFragList->NumberOfElements);   

    DBGPRINT(MP_TRACE, ("<-- MpStartPacketPhysicalMapping\n"));

}
#endif

NDIS_STATUS NICSendPacket(
    IN  PMP_ADAPTER     Adapter,
    IN  PMP_TCB         pMpTcb,
    IN  PMP_FRAG_LIST   pFragList
    )
/*++
Routine Description:

    NIC specific send handler
    Assumption: Send spinlock has been acquired 

Arguments:

    Adapter     Pointer to our adapter
    pMpTcb      Pointer to MP_TCB
    pFragList   The pointer to the frag list to be filled

Return Value:

    NDIS_STATUS_SUCCESS
    NDIS_STATUS_HARD_ERRORS

--*/
{
    NDIS_STATUS  Status;
    ULONG        index;
    UCHAR        TbdCount = 0;

    PHW_TCB      pHwTcb = pMpTcb->HwTcb;
    PTBD_STRUC   pHwTbd = pMpTcb->HwTbd;

    DBGPRINT(MP_TRACE, ("--> NICSendPacket\n"));

    for (index = 0; index < pFragList->NumberOfElements; index++)
    {
        if (pFragList->Elements[index].Length)
        {
            pHwTbd->TbdBufferAddress = NdisGetPhysicalAddressLow(pFragList->Elements[index].Address);
            pHwTbd->TbdCount = pFragList->Elements[index].Length;

            pHwTbd++;                    
            TbdCount++;   
        }
    }

    pHwTcb->TxCbHeader.CbStatus = 0;
    pHwTcb->TxCbHeader.CbCommand = CB_S_BIT | CB_TRANSMIT | CB_TX_SF_BIT;

    pHwTcb->TxCbTbdPointer = pMpTcb->HwTbdPhys;
    pHwTcb->TxCbTbdNumber = TbdCount;
    pHwTcb->TxCbCount = 0;
    pHwTcb->TxCbThreshold = (UCHAR) Adapter->AiThreshold;

    Status = NICStartSend(Adapter, pMpTcb);

    DBGPRINT(MP_TRACE, ("<-- NICSendPacket\n"));

    return Status;
}

NDIS_STATUS NICStartSend(
    IN  PMP_ADAPTER  Adapter,
    IN  PMP_TCB      pMpTcb
    )
/*++
Routine Description:

    Issue a send command to the NIC
    Assumption: Send spinlock has been acquired 

Arguments:

    Adapter     Pointer to our adapter
    pMpTcb      Pointer to MP_TCB

Return Value:

    NDIS_STATUS_SUCCESS
    NDIS_STATUS_HARD_ERRORS

--*/
{
    NDIS_STATUS     Status;

    DBGPRINT(MP_TRACE, ("--> NICStartSend\n"));

    //
    // If the transmit unit is idle (very first transmit) then we must
    // setup the general pointer and issue a full CU-start
    //
    if (Adapter->TransmitIdle)
    {
        
        DBGPRINT(MP_INFO,  ("CU is idle -- First TCB added to Active List\n"));

        //
        // Wait for the SCB to clear before we set the general pointer
        //
        if (!WaitScb(Adapter))
        {
            Status = NDIS_STATUS_HARD_ERRORS;
            MP_EXIT;
        }

        //
        // Don't try to start the transmitter if the command unit is not
        // idle ((not idle) == (Cu-Suspended or Cu-Active)).
        //
        if ((Adapter->CSRAddress->ScbStatus & SCB_CUS_MASK) != SCB_CUS_IDLE)
        {
            DBGPRINT(MP_ERROR, ("Adapter = "PTR_FORMAT", CU Not IDLE\n", Adapter));
            MP_SET_HARDWARE_ERROR(Adapter);
            NdisStallExecution(25);
        }

        Adapter->CSRAddress->ScbGeneralPointer = pMpTcb->HwTcbPhys;

        Status = D100IssueScbCommand(Adapter, SCB_CUC_START, FALSE);

        Adapter->TransmitIdle = FALSE;
        Adapter->ResumeWait = TRUE;
    }
    else
    {
        //
        // If the command unit has already been started, then append this
        // TCB onto the end of the transmit chain, and issue a CU-Resume.
        //
        DBGPRINT(MP_LOUD, ("adding TCB to Active chain\n"));

        //
        // Clear the suspend bit on the previous packet.
        //
        pMpTcb->PrevHwTcb->TxCbHeader.CbCommand &= ~CB_S_BIT;

        //
        // Issue a CU-Resume command to the device.  We only need to do a
        // WaitScb if the last command was NOT a RESUME.
        //
        Status = D100IssueScbCommand(Adapter, SCB_CUC_RESUME, Adapter->ResumeWait);
    }

    exit:
                      
    DBGPRINT(MP_TRACE, ("<-- NICStartSend\n"));

    return Status;
}

NDIS_STATUS MpHandleSendInterrupt(
    IN  PMP_ADAPTER  Adapter
    )
/*++
Routine Description:

    Interrupt handler for sending processing
    Re-claim the send resources, complete sends and get more to send from the send wait queue
    Assumption: Send spinlock has been acquired 

Arguments:

    Adapter     Pointer to our adapter

Return Value:

    NDIS_STATUS_SUCCESS
    NDIS_STATUS_HARD_ERRORS
    NDIS_STATUS_PENDING

--*/
{
    NDIS_STATUS     Status = NDIS_STATUS_SUCCESS;
    PMP_TCB         pMpTcb;

#if DBG
    LONG            i;
#endif

    DBGPRINT(MP_TRACE, ("---> MpHandleSendInterrupt\n"));

    //
    // Any packets being sent? Any packet waiting in the send queue?
    //
    if (Adapter->nBusySend == 0 &&
        IsQueueEmpty(&Adapter->SendWaitQueue))
    {
        ASSERT(Adapter->CurrSendHead == Adapter->CurrSendTail);
        DBGPRINT(MP_TRACE, ("<--- MpHandleSendInterrupt\n"));
        return Status;
    }

    //
    // Check the first TCB on the send list
    //
    while (Adapter->nBusySend > 0)
    {

#if DBG
        pMpTcb = Adapter->CurrSendHead;
        for (i = 0; i < Adapter->nBusySend; i++)
        {
            pMpTcb = pMpTcb->Next;   
        }

        if (pMpTcb != Adapter->CurrSendTail)
        {
            DBGPRINT(MP_ERROR, ("nBusySend= %d\n", Adapter->nBusySend));
            DBGPRINT(MP_ERROR, ("CurrSendhead= "PTR_FORMAT"\n", Adapter->CurrSendHead));
            DBGPRINT(MP_ERROR, ("CurrSendTail= "PTR_FORMAT"\n", Adapter->CurrSendTail));
            ASSERT(FALSE);
        }
#endif      

        pMpTcb = Adapter->CurrSendHead;

        //
        // Is this TCB completed?
        //
        if (pMpTcb->HwTcb->TxCbHeader.CbStatus & CB_STATUS_COMPLETE)
        {
            //
            // Check if this is a multicast hw workaround packet
            //
            if ((pMpTcb->HwTcb->TxCbHeader.CbCommand & CB_CMD_MASK) != CB_MULTICAST)
            {
                MP_FREE_SEND_PACKET_FUN(Adapter, pMpTcb);
                
            }
            else
            {
                               
            
            }
        }
        else
        {
            break;
        }
    }

    //
    // If we queued any transmits because we didn't have any TCBs earlier,
    // dequeue and send those packets now, as long as we have free TCBs.
    //
    if (MP_IS_READY(Adapter))
    {
        while (!IsQueueEmpty(&Adapter->SendWaitQueue) &&
            MP_TCB_RESOURCES_AVAIABLE(Adapter))
        {
            PNDIS_PACKET Packet;
            PQUEUE_ENTRY pEntry; 
            
#if OFFLOAD
            if (MP_TEST_FLAG(Adapter, fMP_SHARED_MEM_IN_USE))
            {
                break;
            }
#endif
            
            pEntry = RemoveHeadQueue(&Adapter->SendWaitQueue); 
            
            ASSERT(pEntry);
            
            Adapter->nWaitSend--;

            Packet = CONTAINING_RECORD(pEntry, NDIS_PACKET, MiniportReserved);

            DBGPRINT(MP_INFO, ("MpHandleSendInterrupt - send a queued packet\n"));
            
            Status = MpSendPacketFun(Adapter, Packet, TRUE);
            if (Status != NDIS_STATUS_SUCCESS)
            {
                break;
            }
        }
    }

    DBGPRINT(MP_TRACE, ("<--- MpHandleSendInterrupt\n"));
    return Status;
}

VOID MpHandleRecvInterrupt(
    IN  PMP_ADAPTER  Adapter
    )
/*++
Routine Description:

    Interrupt handler for receive processing
    Put the received packets into an array and call NdisMIndicateReceivePacket
    If we run low on RFDs, allocate another one
    Assumption: Rcv spinlock has been acquired 

Arguments:

    Adapter     Pointer to our adapter

Return Value:

    None
    
--*/
{
    PMP_RFD         pMpRfd;
    PHW_RFD         pHwRfd;

    PNDIS_PACKET    PacketArray[NIC_DEF_RFDS];              
    PNDIS_PACKET    PacketFreeArray[NIC_DEF_RFDS];
    UINT            PacketArrayCount;
    UINT            PacketFreeCount;
    UINT            Index;
    UINT            LoopIndex = 0;
    UINT            LoopCount = NIC_MAX_RFDS / NIC_DEF_RFDS + 1;    // avoid staying here too long

    BOOLEAN         bContinue = TRUE;
    BOOLEAN         bAllocNewRfd = FALSE;
    USHORT          PacketStatus;

    
    DBGPRINT(MP_TRACE, ("---> MpHandleRecvInterrupt\n"));

    ASSERT(Adapter->nReadyRecv >= NIC_MIN_RFDS);
    
    while (LoopIndex++ < LoopCount && bContinue)
    {
        PacketArrayCount = 0;
        PacketFreeCount = 0;

        //
        // Process up to the array size RFD's
        //
        while (PacketArrayCount < NIC_DEF_RFDS)
        {
            if (IsListEmpty(&Adapter->RecvList))
            {
                ASSERT(Adapter->nReadyRecv == 0);
                bContinue = FALSE;  
                break;
            }

            //
            // Get the next MP_RFD to process
            //
            pMpRfd = (PMP_RFD)GetListHeadEntry(&Adapter->RecvList);

            //
            // Get the associated HW_RFD
            //
            pHwRfd = pMpRfd->HwRfd;
            
            //
            // Is this packet completed?
            //
            PacketStatus = NIC_RFD_GET_STATUS(pHwRfd);
            if (!NIC_RFD_STATUS_COMPLETED(PacketStatus))
            {
                bContinue = FALSE;
                break;
            }

            //
            // HW specific - check if actual count field has been updated
            //
            if (!NIC_RFD_VALID_ACTUALCOUNT(pHwRfd))
            {
                bContinue = FALSE;
                break;
            }


            //
            // Remove the RFD from the head of the List
            //
            RemoveEntryList((PLIST_ENTRY)pMpRfd);
            Adapter->nReadyRecv--;
            ASSERT(Adapter->nReadyRecv >= 0);
            
            ASSERT(MP_TEST_FLAG(pMpRfd, fMP_RFD_RECV_READY));
            MP_CLEAR_FLAG(pMpRfd, fMP_RFD_RECV_READY);

            //
            // A good packet? drop it if not.
            //
            if (!NIC_RFD_STATUS_SUCCESS(PacketStatus))
            {
                DBGPRINT(MP_WARN, ("Receive failure = %x\n", PacketStatus));
                NICReturnRFD(Adapter, pMpRfd);
                continue;
            }

            //
            // Do not receive any packets until a filter has been set
            //
            if (!Adapter->PacketFilter)
            {
                NICReturnRFD(Adapter, pMpRfd);
                continue;
            }

            //
            // Do not receive any packets until we are at D0
            //
            if (Adapter->CurrentPowerState != NdisDeviceStateD0)
            {
                NICReturnRFD(Adapter, pMpRfd);
                continue;
            }

            pMpRfd->PacketSize = NIC_RFD_GET_PACKET_SIZE(pHwRfd);
            
            NdisAdjustBufferLength(pMpRfd->NdisBuffer, pMpRfd->PacketSize);
            NdisFlushBuffer(pMpRfd->NdisBuffer, FALSE);

            // we don't mess up the buffer chain, no need to make this call in this case                                  
            // NdisRecalculatePacketCounts(pMpRfd->ReceivePacket);

            //
            // set the status on the packet, either resources or success
            //
            if (Adapter->nReadyRecv >= MIN_NUM_RFD)
            {
                // NDIS_STATUS_SUCCESS
                NDIS_SET_PACKET_STATUS(pMpRfd->NdisPacket, NDIS_STATUS_SUCCESS);
                MP_SET_FLAG(pMpRfd, fMP_RFD_RECV_PEND);
                
                InsertTailList(&Adapter->RecvPendList, (PLIST_ENTRY)pMpRfd);
                MP_INC_RCV_REF(Adapter);

            }
            else
            {
                //
                // NDIS_STATUS_RESOURCES
                //
                NDIS_SET_PACKET_STATUS(pMpRfd->NdisPacket, NDIS_STATUS_RESOURCES);
                MP_SET_FLAG(pMpRfd, fMP_RFD_RESOURCES);
                
                PacketFreeArray[PacketFreeCount] = pMpRfd->NdisPacket;
                PacketFreeCount++;

                //
                // Reset the RFD shrink count - don't attempt to shrink RFD
                //
                Adapter->RfdShrinkCount = 0;
                
                //
                // Remember to allocate a new RFD later
                //
                bAllocNewRfd = TRUE;
            }

            PacketArray[PacketArrayCount] = pMpRfd->NdisPacket;
            PacketArrayCount++;
        }

        //
        // if we didn't process any receives, just return from here
        //
        if (PacketArrayCount == 0) 
        {
            break;
        }
        //
        // Update the number of outstanding Recvs
        //
        Adapter->PoMgmt.OutstandingRecv += PacketArrayCount;

        NdisDprReleaseSpinLock(&Adapter->RcvLock);
        NdisDprAcquireSpinLock(&Adapter->Lock);
        //
        // if we have a Recv interrupt and have reported a media disconnect status
        // time to indicate the new status
        //

        if (NdisMediaStateDisconnected == Adapter->MediaState)
        {
            DBGPRINT(MP_WARN, ("Media state changed to Connected\n"));

            MP_CLEAR_FLAG(Adapter, fMP_ADAPTER_NO_CABLE);

            Adapter->MediaState = NdisMediaStateConnected;

            
            NdisDprReleaseSpinLock(&Adapter->Lock);
            //
            // Indicate the media event
            //
            NdisMIndicateStatus(Adapter->AdapterHandle, NDIS_STATUS_MEDIA_CONNECT, (PVOID)0, 0);

            NdisMIndicateStatusComplete(Adapter->AdapterHandle);

        }
    
        else
        {
            NdisDprReleaseSpinLock(&Adapter->Lock);
        }


        NdisMIndicateReceivePacket(
            Adapter->AdapterHandle,
            PacketArray,
            PacketArrayCount);

        NdisDprAcquireSpinLock(&Adapter->RcvLock);

        //
        // NDIS won't take ownership for the packets with NDIS_STATUS_RESOURCES.
        // For other packets, NDIS always takes the ownership and gives them back 
        // by calling MPReturnPackets
        //
        for (Index = 0; Index < PacketFreeCount; Index++)
        {

            //
            // Get the MP_RFD saved in this packet, in NICAllocRfd
            //
            pMpRfd = MP_GET_PACKET_RFD(PacketFreeArray[Index]);
            
            ASSERT(MP_TEST_FLAG(pMpRfd, fMP_RFD_RESOURCES));
            MP_CLEAR_FLAG(pMpRfd, fMP_RFD_RESOURCES);

            //
            // Decrement the number of outstanding Recvs
            //
            Adapter->PoMgmt.OutstandingRecv --;
    
            NICReturnRFD(Adapter, pMpRfd);
        }
        //
        //If we have set power pending, then complete it
        //
        if (((Adapter->bSetPending == TRUE)
                && (Adapter->SetRequest.Oid == OID_PNP_SET_POWER))
                && (Adapter->PoMgmt.OutstandingRecv == 0))
        {
            MpSetPowerLowComplete(Adapter);
        }
    }
    
    //
    // If we ran low on RFD's, we need to allocate a new RFD
    //
    if (bAllocNewRfd)
    {
        //
        // Allocate one more RFD only if no pending new RFD allocation AND
        // it doesn't exceed the max RFD limit
        //
        if (!Adapter->bAllocNewRfd && Adapter->CurrNumRfd < Adapter->MaxNumRfd)
        {
            PMP_RFD TempMpRfd;
            NDIS_STATUS TempStatus;

            TempMpRfd = NdisAllocateFromNPagedLookasideList(&Adapter->RecvLookaside);
            if (TempMpRfd)
            {
                MP_INC_REF(Adapter);
                Adapter->bAllocNewRfd = TRUE;

                MP_SET_FLAG(TempMpRfd, fMP_RFD_ALLOC_PEND); 

                //
                // Allocate the shared memory for this RFD.
                //
                TempStatus = NdisMAllocateSharedMemoryAsync(
                                 Adapter->AdapterHandle,
                                 Adapter->HwRfdSize,
                                 FALSE,
                                 TempMpRfd);

                //
                // The return value will be either NDIS_STATUS_PENDING or NDIS_STATUS_FAILURE
                //
                if (TempStatus == NDIS_STATUS_FAILURE)
                {
                    MP_CLEAR_FLAGS(TempMpRfd);
                    NdisFreeToNPagedLookasideList(&Adapter->RecvLookaside, TempMpRfd);

                    Adapter->bAllocNewRfd = FALSE;
                    MP_DEC_REF(Adapter);
                }
            }
        }
    }

    ASSERT(Adapter->nReadyRecv >= NIC_MIN_RFDS);

    DBGPRINT(MP_TRACE, ("<--- MpHandleRecvInterrupt\n"));
}

VOID NICReturnRFD(
    IN  PMP_ADAPTER  Adapter,
    IN  PMP_RFD		pMpRfd
    )
/*++
Routine Description:

    Recycle a RFD and put it back onto the receive list 
    Assumption: Rcv spinlock has been acquired 

Arguments:

    Adapter     Pointer to our adapter
    pMpRfd      Pointer to the RFD 

Return Value:

    None
    
--*/
{
    PMP_RFD   pLastMpRfd;
    PHW_RFD   pHwRfd = pMpRfd->HwRfd;

    ASSERT(pMpRfd->Flags == 0);
    MP_SET_FLAG(pMpRfd, fMP_RFD_RECV_READY);
    
    //
    // HW_SPECIFIC_START
    //
    pHwRfd->RfdCbHeader.CbStatus = 0;
    pHwRfd->RfdActualCount = 0;
    pHwRfd->RfdCbHeader.CbCommand = (RFD_EL_BIT);
    pHwRfd->RfdCbHeader.CbLinkPointer = DRIVER_NULL;

    //
    // We don't use any of the OOB data besides status
    // Otherwise, we need to clean up OOB data
    // NdisZeroMemory(NDIS_OOB_DATA_FROM_PACKET(pMpRfd->NdisPacket),14);
    //
    // Append this RFD to the RFD chain
    if (!IsListEmpty(&Adapter->RecvList))
    {
        pLastMpRfd = (PMP_RFD)GetListTailEntry(&Adapter->RecvList);

        // Link it onto the end of the chain dynamically
        pHwRfd = pLastMpRfd->HwRfd;
        pHwRfd->RfdCbHeader.CbLinkPointer = pMpRfd->HwRfdPhys;
        pHwRfd->RfdCbHeader.CbCommand = 0;
    }

    //
    // HW_SPECIFIC_END
    //

    //
    // The processing on this RFD is done, so put it back on the tail of
    // our list
    //
    InsertTailList(&Adapter->RecvList, (PLIST_ENTRY)pMpRfd);
    Adapter->nReadyRecv++;
    ASSERT(Adapter->nReadyRecv <= Adapter->CurrNumRfd);
}

NDIS_STATUS NICStartRecv(
    IN  PMP_ADAPTER  Adapter
    )
/*++
Routine Description:

    Start the receive unit if it's not in a ready state                    
    Assumption: Rcv spinlock has been acquired 

Arguments:

    Adapter     Pointer to our adapter

Return Value:

    NDIS_STATUS_SUCCESS
    NDIS_STATUS_HARD_ERRROS
    
--*/
{
    PMP_RFD         pMpRfd;
    NDIS_STATUS     Status;

    DBGPRINT(MP_TRACE, ("---> NICStartRecv\n"));

    //
    // If the receiver is ready, then don't try to restart.
    //
    if (NIC_IS_RECV_READY(Adapter))
    {
        DBGPRINT(MP_LOUD, ("Receive unit already active\n"));
        return NDIS_STATUS_SUCCESS;
    }

    DBGPRINT(MP_LOUD, ("Re-start receive unit...\n"));
    ASSERT(!IsListEmpty(&Adapter->RecvList));
    
    //
    // Get the MP_RFD head
    //
    pMpRfd = (PMP_RFD)GetListHeadEntry(&Adapter->RecvList);

    //
    // If more packets are received, clean up RFD chain again
    //
    if (NIC_RFD_GET_STATUS(pMpRfd->HwRfd))
    {
        MpHandleRecvInterrupt(Adapter);
        ASSERT(!IsListEmpty(&Adapter->RecvList));

        //
        // Get the new MP_RFD head
        //
        pMpRfd = (PMP_RFD)GetListHeadEntry(&Adapter->RecvList);
    }

    //
    // Wait for the SCB to clear before we set the general pointer
    //
    if (!WaitScb(Adapter))
    {
        Status = NDIS_STATUS_HARD_ERRORS;
        MP_EXIT;
    }

    if (Adapter->CurrentPowerState > NdisDeviceStateD0)
    {
        Status = NDIS_STATUS_HARD_ERRORS;
        MP_EXIT;
    }
    //
    // Set the SCB General Pointer to point the current Rfd
    //
    Adapter->CSRAddress->ScbGeneralPointer = pMpRfd->HwRfdPhys;

    //
    // Issue the SCB RU start command
    //
    Status = D100IssueScbCommand(Adapter, SCB_RUC_START, FALSE);
    if (Status == NDIS_STATUS_SUCCESS)
    {
        // wait for the command to be accepted
        if (!WaitScb(Adapter))
        {
            Status = NDIS_STATUS_HARD_ERRORS;
        }
    }        
    
    exit:

    DBGPRINT_S(Status, ("<--- NICStartRecv, Status=%x\n", Status));
    return Status;
}

VOID MpFreeQueuedSendPackets(
    IN  PMP_ADAPTER  Adapter
    )
/*++
Routine Description:

    Free and complete the pended sends on SendWaitQueue
    Assumption: spinlock has been acquired 
    
Arguments:

    Adapter     Pointer to our adapter

Return Value:

     None

--*/
{
    PQUEUE_ENTRY    pEntry;
    PNDIS_PACKET    Packet;
    NDIS_STATUS     Status = MP_GET_STATUS_FROM_FLAGS(Adapter);

    DBGPRINT(MP_TRACE, ("--> MpFreeQueuedSendPackets\n"));

    while (!IsQueueEmpty(&Adapter->SendWaitQueue))
    {
        pEntry = RemoveHeadQueue(&Adapter->SendWaitQueue); 
        Adapter->nWaitSend--;
        NdisReleaseSpinLock(&Adapter->SendLock);

        ASSERT(pEntry);
        Packet = CONTAINING_RECORD(pEntry, NDIS_PACKET, MiniportReserved);

        NdisMSendComplete(
            MP_GET_ADAPTER_HANDLE(Adapter),
            Packet,
            Status);

        NdisAcquireSpinLock(&Adapter->SendLock);
    }

    DBGPRINT(MP_TRACE, ("<-- MpFreeQueuedSendPackets\n"));

}

void MpFreeBusySendPackets(
    IN  PMP_ADAPTER  Adapter
    )
/*++
Routine Description:

    Free and complete the stopped active sends
    Assumption: Send spinlock has been acquired 
    
Arguments:

    Adapter     Pointer to our adapter

Return Value:

     None

--*/
{
    PMP_TCB  pMpTcb;

    DBGPRINT(MP_TRACE, ("--> MpFreeBusySendPackets\n"));

    //
    // Any packets being sent? Check the first TCB on the send list
    //
    while (Adapter->nBusySend > 0)
    {
        pMpTcb = Adapter->CurrSendHead;

        //
        // Is this TCB completed?
        //
        if ((pMpTcb->HwTcb->TxCbHeader.CbCommand & CB_CMD_MASK) != CB_MULTICAST)
        {
            MP_FREE_SEND_PACKET_FUN(Adapter, pMpTcb);
        }
        else
        {
            break;
        }
    }

    DBGPRINT(MP_TRACE, ("<-- MpFreeBusySendPackets\n"));
}

VOID NICResetRecv(
    IN  PMP_ADAPTER   Adapter
    )
/*++
Routine Description:

    Reset the receive list                    
    Assumption: Rcv spinlock has been acquired 
    
Arguments:

    Adapter     Pointer to our adapter

Return Value:

     None

--*/
{
    PMP_RFD   pMpRfd;      
    PHW_RFD   pHwRfd;    
    LONG      RfdCount;

    DBGPRINT(MP_TRACE, ("--> NICResetRecv\n"));

    ASSERT(!IsListEmpty(&Adapter->RecvList));
    
    //
    // Get the MP_RFD head
    //
    pMpRfd = (PMP_RFD)GetListHeadEntry(&Adapter->RecvList);
    for (RfdCount = 0; RfdCount < Adapter->nReadyRecv; RfdCount++)
    {
        pHwRfd = pMpRfd->HwRfd;
        pHwRfd->RfdCbHeader.CbStatus = 0;

        pMpRfd = (PMP_RFD)GetListFLink(&pMpRfd->List);
    }

    DBGPRINT(MP_TRACE, ("<-- NICResetRecv\n"));
}

VOID MpLinkDetectionDpc(
    IN  PVOID	    SystemSpecific1,
    IN  PVOID	    FunctionContext,
    IN  PVOID	    SystemSpecific2, 
    IN  PVOID	    SystemSpecific3
    )
/*++

Routine Description:
    
    Timer function for postponed link negotiation
    
Arguments:

    SystemSpecific1     Not used
    FunctionContext     Pointer to our adapter
    SystemSpecific2     Not used
    SystemSpecific3     Not used

Return Value:

    None
    
--*/
{
    PMP_ADAPTER         Adapter = (PMP_ADAPTER)FunctionContext;
    NDIS_STATUS         Status;
    NDIS_MEDIA_STATE    CurrMediaState;
    NDIS_STATUS         IndicateStatus;

	UNREFERENCED_PARAMETER(SystemSpecific1);
	UNREFERENCED_PARAMETER(SystemSpecific2);
	UNREFERENCED_PARAMETER(SystemSpecific3);
    //
    // Handle the link negotiation.
    //
    if (Adapter->bLinkDetectionWait)
    {
        Status = ScanAndSetupPhy(Adapter);
    }
    else
    {
        Status = PhyDetect(Adapter);
    }
    
    if (Status == NDIS_STATUS_PENDING)
    {
        // Wait for 100 ms   
        Adapter->bLinkDetectionWait = TRUE;
        NdisMSetTimer(&Adapter->LinkDetectionTimer, NIC_LINK_DETECTION_DELAY);
        return;
    }

    //
    // Reset some variables for link detection
    //
    Adapter->bLinkDetectionWait = FALSE;
    
    DBGPRINT(MP_WARN, ("MpLinkDetectionDpc - negotiation done\n"));

    NdisDprAcquireSpinLock(&Adapter->Lock);
    MP_CLEAR_FLAG(Adapter, fMP_ADAPTER_LINK_DETECTION);
    NdisDprReleaseSpinLock(&Adapter->Lock);

    //
    // Any OID query request?                                                        
    //
    if (Adapter->bQueryPending)
    {
        
        switch(Adapter->QueryRequest.Oid)
        {
            case OID_GEN_LINK_SPEED:
                *((PULONG) Adapter->QueryRequest.InformationBuffer) = Adapter->usLinkSpeed * 10000;
                *((PULONG) Adapter->QueryRequest.BytesWritten) = sizeof(ULONG);

                break;

            case OID_GEN_MEDIA_CONNECT_STATUS:
            default:
                ASSERT(Adapter->QueryRequest.Oid == OID_GEN_MEDIA_CONNECT_STATUS);
                CurrMediaState = NICGetMediaState(Adapter);
                NdisMoveMemory(Adapter->QueryRequest.InformationBuffer,
                               &CurrMediaState,
                               sizeof(NDIS_MEDIA_STATE));
                NdisDprAcquireSpinLock(&Adapter->Lock);
                if (Adapter->MediaState != CurrMediaState)
                {
                    Adapter->MediaState = CurrMediaState;
                    DBGPRINT(MP_WARN, ("Media state changed to %s\n",
                              ((CurrMediaState == NdisMediaStateConnected)? 
                              "Connected": "Disconnected")));

                    IndicateStatus = (CurrMediaState == NdisMediaStateConnected) ? 
                              NDIS_STATUS_MEDIA_CONNECT : NDIS_STATUS_MEDIA_DISCONNECT;          
                    if (IndicateStatus == NDIS_STATUS_MEDIA_CONNECT)
                    {
                        MP_CLEAR_FLAG(Adapter, fMP_ADAPTER_NO_CABLE);
                    }
                    else
                    {
                        MP_SET_FLAG(Adapter, fMP_ADAPTER_NO_CABLE);
                    }
                        
                    NdisDprReleaseSpinLock(&Adapter->Lock);
                      
                    // Indicate the media event
                    NdisMIndicateStatus(Adapter->AdapterHandle, IndicateStatus, (PVOID)0, 0);
                    NdisMIndicateStatusComplete(Adapter->AdapterHandle);
      
                }
                else
                {
                    NdisDprReleaseSpinLock(&Adapter->Lock);
                }

                *((PULONG) Adapter->QueryRequest.BytesWritten) = sizeof(NDIS_MEDIA_STATE);
        }

        Adapter->bQueryPending = FALSE;
        NdisMQueryInformationComplete(Adapter->AdapterHandle, NDIS_STATUS_SUCCESS);
    }

    //
    // Any OID set request?                             
    //
    if (Adapter->bSetPending)
    {
        ULONG    PacketFilter; 

        if (Adapter->SetRequest.Oid == OID_GEN_CURRENT_PACKET_FILTER)
        {

            NdisMoveMemory(&PacketFilter, Adapter->SetRequest.InformationBuffer, sizeof(ULONG));

            NdisDprAcquireSpinLock(&Adapter->Lock);

            Status = NICSetPacketFilter(
                         Adapter,
                         PacketFilter);

            NdisDprReleaseSpinLock(&Adapter->Lock);
 
            if (Status == NDIS_STATUS_SUCCESS)
            {
                Adapter->PacketFilter = PacketFilter;
            }
 
            Adapter->bSetPending = FALSE;
            NdisMSetInformationComplete(Adapter->AdapterHandle, Status);
        }
    }

    NdisDprAcquireSpinLock(&Adapter->Lock);
    //
    // Any pendingf reset?
    //
    if (Adapter->bResetPending)
    {
        // The link detection may have held some requests and caused reset. 
        // Complete the reset with NOT_READY status
        Adapter->bResetPending = FALSE;
        MP_CLEAR_FLAG(Adapter, fMP_ADAPTER_RESET_IN_PROGRESS);
        
        NdisDprReleaseSpinLock(&Adapter->Lock);

        NdisMResetComplete(
            Adapter->AdapterHandle, 
            NDIS_STATUS_ADAPTER_NOT_READY,
            FALSE);
    }
    else
    {
        NdisDprReleaseSpinLock(&Adapter->Lock);
    }

    NdisDprAcquireSpinLock(&Adapter->RcvLock);

    //
    // Start the NIC receive unit                                                     
    //
    Status = NICStartRecv(Adapter);
    if (Status != NDIS_STATUS_SUCCESS)
    {
        MP_SET_HARDWARE_ERROR(Adapter);
    }
    
    NdisDprReleaseSpinLock(&Adapter->RcvLock);
    NdisDprAcquireSpinLock(&Adapter->SendLock);

    //
    // Send packets which have been queued while link detection was going on. 
    //
    if (MP_IS_READY(Adapter))
    {
        while (!IsQueueEmpty(&Adapter->SendWaitQueue) &&
            MP_TCB_RESOURCES_AVAIABLE(Adapter))
        {
            PNDIS_PACKET Packet;
            PQUEUE_ENTRY pEntry;
#if OFFLOAD
            if (MP_TEST_FLAG(Adapter, fMP_SHARED_MEM_IN_USE))
            {
                break;
            }
#endif
            
            pEntry = RemoveHeadQueue(&Adapter->SendWaitQueue); 
            
            ASSERT(pEntry);
            
            Adapter->nWaitSend--;

            Packet = CONTAINING_RECORD(pEntry, NDIS_PACKET, MiniportReserved);

            DBGPRINT(MP_INFO, ("MpLinkDetectionDpc - send a queued packet\n"));

            Status = MpSendPacketFun(Adapter, Packet, TRUE);
            if (Status != NDIS_STATUS_SUCCESS)
            {
                break;
            }
        }
    }

    MP_DEC_REF(Adapter);

    if (MP_GET_REF(Adapter) == 0)
    {
        NdisSetEvent(&Adapter->ExitEvent);
    }

    NdisDprReleaseSpinLock(&Adapter->SendLock);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\net\ms\e100bex\offload.c ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

   Offload.c

Abstract:
   This file contains all the functions needed by TCP/IP checksum and segmentation
   of Large TCP packets task offloading. Actually thses functions should be 
   implemented by hardware, and the purpose of this file is just to demonstrate 
   how to use OID_TCP_TASK_OFFLOAD to enable/disable task offload capabilities.

Revision History
   Who           When                What
   ------        ---------           ----------
                 02-19-2001          Create
                 
Notes:

--*/

#include "precomp.h"

#ifdef OFFLOAD

#define PROTOCOL_TCP         6

//
// This miniport uses shared memory to handle offload tasks, so it tries to allocate
// shared memory of 64K, 32K, 16K. First it tries to allocate 64K, if fails, then
// it tries 32K and so on. If successed, than keeps the size in adapter, which is used
// to decide the maximum offload size in large send. If all the tries fail, then this
// miniport cann't support any offload task.
// 
ULONG LargeSendSharedMemArray[LARGE_SEND_MEM_SIZE_OPTION] = {64*1024, 32*1024, 16*1024};

//
// if x is aabb(where aa, bb are hex bytes), we want net_short (x) to be bbaa.
// 
USHORT net_short(
    ULONG NaturalData
    )
{
    USHORT ShortData = (USHORT)NaturalData;

    return (ShortData << 8) | (ShortData >> 8);
}

//
// if x is aabbccdd (where aa, bb, cc, dd are hex bytes)
// we want net_long(x) to be ddccbbaa.  A small and fast way to do this is
// to first byteswap it to get bbaaddcc and then swap high and low words.
//
ULONG net_long(
    ULONG NaturalData
    )
{
    ULONG ByteSwapped;

    ByteSwapped = ((NaturalData & 0x00ff00ff) << 8) |
                  ((NaturalData & 0xff00ff00) >> 8);

    return (ByteSwapped << 16) | (ByteSwapped >> 16);
}


//
// calculate the checksum for pseudo-header
//
#define PHXSUM(s,d,p,l) (UINT)( (UINT)*(USHORT *)&(s) + \
                        (UINT)*(USHORT *)((char *)&(s) + sizeof(USHORT)) + \
                        (UINT)*(USHORT *)&(d) + \
                        (UINT)*(USHORT *)((char *)&(d) + sizeof(USHORT)) + \
                        (UINT)((USHORT)net_short((p))) + \
                        (UINT)((USHORT)net_short((USHORT)(l))) )


#define IP_HEADER_LENGTH(pIpHdr)   \
        ( (ULONG)((pIpHdr->iph_verlen & 0x0F) << 2) )

#define TCP_HEADER_LENGTH(pTcpHdr) \
        ( (USHORT)(((*((PUCHAR)(&(pTcpHdr->tcp_flags))) & 0xF0) >> 4) << 2) )


/*++
Routine Description:
    
   Copy data in a packet to the specified location 
    
Arguments:
    
    BytesToCopy          The number of bytes need to copy
    CurreentBuffer       The buffer to start to copy
    StartVa              The start address to copy the data to
    Offset               The start offset in the buffer to copy the data
    HeandersLength       The length of the headers which have aleady been copied.

Return Value:
 
    The number of bytes actually copied
  

--*/  

ULONG MpCopyData(
    IN  ULONG           BytesToCopy, 
    IN  PNDIS_BUFFER*   CurrentBuffer, 
    IN  PVOID           StartVa, 
    IN  PULONG          Offset,
    IN  ULONG           HeadersLength
    )
{
    ULONG    CurrLength;
    PUCHAR   pSrc;
    PUCHAR   pDest;
    ULONG    BytesCopied = 0;
    ULONG    CopyLength;
    
    DBGPRINT(MP_TRACE, ("--> MpCopyData\n"));
    pDest = StartVa;
    while (*CurrentBuffer && BytesToCopy != 0)
    {
        //
        // Even the driver is 5.0, it should use safe APIs
        //
        NdisQueryBufferSafe(
            *CurrentBuffer, 
            &pSrc,
            (PUINT)&CurrLength,
            NormalPagePriority);
        if (pSrc == NULL)
        {
            BytesCopied = 0;
            break;
        }
        // 
        //  Current buffer length is greater than the offset to the buffer
        //  
        if (CurrLength > *Offset)
        { 
            pSrc += *Offset;
            CurrLength -= *Offset;
            CopyLength = CurrLength > BytesToCopy ? BytesToCopy : CurrLength;
            
            NdisMoveMemory(pDest, pSrc, CopyLength);
            BytesCopied += CopyLength;

            if (CurrLength > BytesToCopy)
            {
                *Offset += BytesToCopy;
                break;
            }

            BytesToCopy -= CopyLength;
            pDest += CopyLength;
            *Offset = 0;
        }
        else
        {
            *Offset -= CurrLength;
        }
        NdisGetNextBuffer( *CurrentBuffer, CurrentBuffer);
    
    }
    ASSERT(BytesCopied <= NIC_MAX_PACKET_SIZE);
    if (BytesCopied + HeadersLength < NIC_MIN_PACKET_SIZE)
    {
        NdisZeroMemory(pDest, NIC_MIN_PACKET_SIZE - (BytesCopied + HeadersLength));
    }
    
    DBGPRINT(MP_TRACE, ("<-- MpCopyData\n"));
    return BytesCopied;
}



/*++
Routine Description:
    
    Dump packet information for debug purpose
    
Arguments:
    
    pPkt      Pointer to the packet

Return Value:
 
    None
  

--*/  
VOID e100DumpPkt (
    IN PNDIS_PACKET Packet
    )
{
    PNDIS_BUFFER pPrevBuffer;
    PNDIS_BUFFER pBuffer;

    do
    {
        //
        // Get first buffer of the packet
        //
        pBuffer = Packet->Private.Head;
        pPrevBuffer = NULL;

        //
        // Scan the buffer chain
        //
        while (pBuffer != NULL) 
        {
            PVOID pVa = NULL;
            ULONG BufLen = 0;

            BufLen = NdisBufferLength (pBuffer);

            pVa = NdisBufferVirtualAddress(pBuffer);

            pPrevBuffer = pBuffer;
            pBuffer = pBuffer->Next;
            
            if (pVa == NULL)
            {
                continue;
            }

            DBGPRINT(MP_WARN, ("Mdl %p, Va %p. Len %x\n", pPrevBuffer, pVa, BufLen));
            Dump( (CHAR* )pVa, BufLen, 0, 1 );                           
        }

    } while (FALSE);
}


/*++
Routine Description:
    
    Calculate the IP checksum
    
Arguments:
    
    Packet       Pointer to the packet
    IpHdrOffset  Offset of IP header from the beginning of the packet

Return Value:
 
    None
  

--*/  
VOID CalculateIpChecksum(
    IN  PUCHAR       StartVa,
    IN  ULONG        IpHdrOffset
    )
{
    
    IPHeader      *pIpHdr;
    ULONG          IpHdrLen;
    ULONG          TempXsum = 0;
    
   
    pIpHdr = (IPHeader *)(StartVa + IpHdrOffset);
    IpHdrLen = IP_HEADER_LENGTH(pIpHdr);

    XSUM(TempXsum, StartVa, IpHdrLen, IpHdrOffset);
    pIpHdr->iph_xsum = ~(USHORT)TempXsum;
}



/*++
Routine Description:
    
    Calculate the UDP checksum 
    
Arguments:
    
    Packet       Pointer to the packet
    IpHdrOffset  Offset of IP header from the beginning of the packet

Return Value:
 
    None
  

--*/  
VOID CalculateUdpChecksum(
    IN  PNDIS_PACKET    pPacket, 
    IN  ULONG           IpHdrOffset
    )
{
    UNREFERENCED_PARAMETER(pPacket);
    UNREFERENCED_PARAMETER(IpHdrOffset);
    
    DBGPRINT(MP_WARN, ("UdpChecksum is not handled\n"));
}




/*++
Routine Description:
    
    Calculate the TCP checksum 
    
Arguments:
    
    Packet       Pointer to the packet
    IpHdrOffset  Offset of IP header from the beginning of the packet

Return Value:
 
    None
  

--*/  
VOID CalculateTcpChecksum(
    IN  PVOID  StartVa,
    IN  ULONG  PacketLength,
    IN  ULONG  IpHdrOffset
    )
{
    ULONG        Offset;
    IPHeader     *pIpHdr;
    ULONG        IpHdrLength;
    TCPHeader    *pTcpHdr;
    USHORT       PseudoXsum;
    ULONG        TmpXsum;
 
    
    DBGPRINT(MP_TRACE, ("===> CalculateTcpChecksum\n"));
    
    //
    // Find IP header and get IP header length in byte
    // MDL won't split headers
    //
    Offset = IpHdrOffset;
    pIpHdr = (IPHeader *) ((PUCHAR)StartVa + Offset);
    IpHdrLength = IP_HEADER_LENGTH(pIpHdr);
  
    //
    // If that is not tcp protocol, we can not do anything.
    // So just return to the caller
    //
    if (((pIpHdr->iph_verlen & 0xF0) >> 4) != 4 && pIpHdr->iph_protocol != PROTOCOL_TCP)
    {
        return;
    }
   
    //
    // Locate the TCP header
    //
    Offset += IpHdrLength;
    pTcpHdr = (TCPHeader *) ((PUCHAR)StartVa + Offset);

    //
    // Calculate the checksum for the tcp header and payload
    //
    PseudoXsum = pTcpHdr->tcp_xsum;
 
    pTcpHdr->tcp_xsum = 0;
    TmpXsum = PseudoXsum;
    XSUM(TmpXsum, StartVa, PacketLength - Offset, Offset);
    
    //
    // Now we got the checksum, need to put the checksum back to MDL
    //
    pTcpHdr->tcp_xsum = (USHORT)(~TmpXsum);
    
    DBGPRINT(MP_TRACE, ("<=== CalculateTcpChecksum\n"));
}


/*++
Routine Description:
    
    Do the checksum offloading 
    
Arguments:
    
    Packet       Pointer to the packet
    IpHdrOffset  Offset of IP header from the beginning of the packet

Return Value:
 
    None
  

--*/  
VOID CalculateChecksum(
    IN  PVOID        StartVa,
    IN  ULONG        PacketLength,
    IN  PNDIS_PACKET Packet,
    IN  ULONG        IpHdrOffset
    )
{ 
    ULONG                             ChecksumPktInfo;
    PNDIS_TCP_IP_CHECKSUM_PACKET_INFO pChecksumPktInfo;
    
    //
    // Check for protocol
    //
    if (NDIS_PROTOCOL_ID_TCP_IP != NDIS_GET_PACKET_PROTOCOL_TYPE(Packet))
    {
        DBGPRINT(MP_TRACE, ("Packet's protocol is wrong.\n"));
        return;
    }

    //
    // Query per packet information 
    //
    ChecksumPktInfo = PtrToUlong(
                         NDIS_PER_PACKET_INFO_FROM_PACKET( Packet,
                                                           TcpIpChecksumPacketInfo));

  
    // DBGPRINT(MP_WARN, ("Checksum info: %lu\n", ChecksumPktInfo));
    
    pChecksumPktInfo = (PNDIS_TCP_IP_CHECKSUM_PACKET_INFO) & ChecksumPktInfo;
    
    //
    // Check per packet information
    //
    if (pChecksumPktInfo->Transmit.NdisPacketChecksumV4 == 0)
    {
        
        DBGPRINT(MP_TRACE, ("NdisPacketChecksumV4 is not set.\n"));
        return;
    }
    
    //
    // do tcp checksum
    //
    if (pChecksumPktInfo->Transmit.NdisPacketTcpChecksum)
    {
        CalculateTcpChecksum(StartVa, PacketLength, IpHdrOffset);
    }

    //
    // do udp checksum
    //
    if (pChecksumPktInfo->Transmit.NdisPacketUdpChecksum)
    {
        CalculateUdpChecksum(Packet, IpHdrOffset);
    }

    //
    // do ip checksum
    //
    if (pChecksumPktInfo->Transmit.NdisPacketIpChecksum)
    {
        CalculateIpChecksum(StartVa, IpHdrOffset);
    }
    
}

/*++

Routine Description:
    
    MiniportSendPackets handler
    
Arguments:

    MiniportAdapterContext  Pointer to our adapter
    PacketArray             Set of packets to send
    NumOfPackets         Self-explanatory

Return Value:

    None

--*/
VOID MPOffloadSendPackets(
    IN  NDIS_HANDLE    MiniportAdapterContext,
    IN  PPNDIS_PACKET  PacketArray,
    IN  UINT           NumOfPackets
    )
{
    PMP_ADAPTER  Adapter;
    NDIS_STATUS  Status;
    UINT         PacketCount;
    

    DBGPRINT(MP_TRACE, ("====> MPOffloadSendPackets\n"));

    Adapter = (PMP_ADAPTER)MiniportAdapterContext;


    NdisAcquireSpinLock(&Adapter->SendLock);

    //
    // Is this adapter ready for sending?
    //
    if (MP_IS_NOT_READY(Adapter))
    {
        //
        // There is link
        //
        if (MP_TEST_FLAG(Adapter, fMP_ADAPTER_LINK_DETECTION))
        {
            for (PacketCount = 0; PacketCount < NumOfPackets; PacketCount++)
            {
                InsertTailQueue(&Adapter->SendWaitQueue, 
                                MP_GET_PACKET_MR( PacketArray[PacketCount] )
                               );
                
                Adapter->nWaitSend++;
                DBGPRINT(MP_WARN, ("MpOffloadSendPackets: link detection - queue packet "PTR_FORMAT"\n", PacketArray[PacketCount]));
            }
            NdisReleaseSpinLock(&Adapter->SendLock);
            return;
        }
        
        //
        // Adapter is not ready and there is not link
        //
        Status = MP_GET_STATUS_FROM_FLAGS(Adapter);

        NdisReleaseSpinLock(&Adapter->SendLock);

        for (PacketCount = 0; PacketCount < NumOfPackets; PacketCount++)
        {
            NdisMSendComplete(
                MP_GET_ADAPTER_HANDLE(Adapter),
                PacketArray[PacketCount],
                Status);
        }

        return;
    }

    //
    // Adapter is ready, send these packets      
    //
    for (PacketCount = 0; PacketCount < NumOfPackets; PacketCount++)
    {
        //
        // queue is not empty or tcb is not available 
        //
        if (!IsQueueEmpty(&Adapter->SendWaitQueue) || 
            !MP_TCB_RESOURCES_AVAIABLE(Adapter) ||
            MP_TEST_FLAG(Adapter, fMP_SHARED_MEM_IN_USE))
        {
            InsertTailQueue(&Adapter->SendWaitQueue, 
                            MP_GET_PACKET_MR( PacketArray[PacketCount] )
                           );
            Adapter->nWaitSend++;
        }
        else
        {
            MpOffloadSendPacket(Adapter, PacketArray[PacketCount], FALSE);
        }
    }

    NdisReleaseSpinLock(&Adapter->SendLock);

    DBGPRINT(MP_TRACE, ("<==== MPOffloadSendPackets\n"));

    return;
}

/*++
Routine Description:

    Do the work to send a packet
    Assumption: Send spinlock has been acquired and shared mem is available 

Arguments:

    Adapter     Pointer to our adapter
    Packet      The packet
    bFromQueue  TRUE if it's taken from the send wait queue

Return Value:

    NDIS_STATUS_SUCCESS
    NDIS_STATUS_PENDING         Put into the send wait queue
    NDIS_STATUS_HARD_ERRORS

--*/
NDIS_STATUS MpOffloadSendPacket(
    IN  PMP_ADAPTER   Adapter,
    IN  PNDIS_PACKET  Packet,
    IN  BOOLEAN       bFromQueue
    )
{
    NDIS_STATUS             Status = NDIS_STATUS_PENDING;
    PMP_TCB                 pMpTcb = NULL;
    ULONG                   BytesCopied;
    ULONG                   NumOfPackets;

    // Mimiced frag list if map registers are used, on the local stack as it's not so big                                         
    MP_FRAG_LIST            FragList;
    
    // Pointer to either the scatter gather or the local mimiced frag list
    PMP_FRAG_LIST           pFragList;
    NDIS_PHYSICAL_ADDRESS   SendPa;
    ULONG                   BytesToCopy;
    ULONG                   Offset;
    PNDIS_PACKET_EXTENSION  PktExt;
    ULONG                   mss;
    PNDIS_BUFFER            NdisBuffer;
    ULONG                   PacketLength;
    PVOID                   CopyStartVa;
    ULONG                   IpHdrOffset;
    PUCHAR                  StartVa;
    PNDIS_BUFFER            FirstBuffer;
    
    DBGPRINT(MP_TRACE, ("--> MpOffloadSendPacket, Pkt= "PTR_FORMAT"\n", Packet));

    //
    //Check is shared memory available,  just double check
    //
    if (MP_TEST_FLAG(Adapter, fMP_SHARED_MEM_IN_USE))
    {
        DBGPRINT(MP_WARN, ("Shared mem is in use.\n"));
        if (bFromQueue)
        {
            InsertHeadQueue(&Adapter->SendWaitQueue, MP_GET_PACKET_MR(Packet));
        }
        else
        {
            InsertTailQueue(&Adapter->SendWaitQueue, MP_GET_PACKET_MR(Packet));
        }
        DBGPRINT(MP_TRACE, ("<-- MpOffloadSendPacket\n"));
        return Status;
    }

    MP_SET_FLAG(Adapter, fMP_SHARED_MEM_IN_USE);
    ASSERT(Adapter->SharedMemRefCount == 0);
    //
    // Get maximum segment size
    // 
    PktExt = NDIS_PACKET_EXTENSION_FROM_PACKET(Packet);       
    mss = PtrToUlong(PktExt->NdisPacketInfo[TcpLargeSendPacketInfo]);
    
    //
    // Copy NIC_MAX_PACKET_SIZE bytes of data from NDIS buffer 
    // to the shared memory
    //
    NdisQueryPacket( Packet, NULL, NULL, &FirstBuffer, (PUINT)&PacketLength );
    Offset = 0;
    NdisBuffer = FirstBuffer;
    BytesToCopy = NIC_MAX_PACKET_SIZE;
    CopyStartVa = Adapter->OffloadSharedMem.StartVa;
    BytesCopied = MpCopyData(BytesToCopy, &NdisBuffer, CopyStartVa, &Offset, 0); 

    //
    // MpCopyPacket may return 0 if system resources are low or exhausted
    //
    if (BytesCopied == 0)
    {
        
        DBGPRINT(MP_ERROR, ("Calling NdisMSendComplete with NDIS_STATUS_RESOURCES, Pkt= "PTR_FORMAT"\n", Packet));
    
        NdisReleaseSpinLock(&Adapter->SendLock); 
        NdisMSendComplete(
                MP_GET_ADAPTER_HANDLE(Adapter),
                Packet,
                NDIS_STATUS_RESOURCES);
    
        NdisAcquireSpinLock(&Adapter->SendLock);    
        MP_CLEAR_FLAG(Adapter, fMP_SHARED_MEM_IN_USE);
            
        return NDIS_STATUS_RESOURCES;            
    }

    StartVa = CopyStartVa;
    SendPa = Adapter->OffloadSharedMem.PhyAddr;
    IpHdrOffset = Adapter->EncapsulationFormat.EncapsulationHeaderSize;
    
    // 
    // Check if large send capability is on and this is a large packet
    // 
    if (Adapter->NicTaskOffload.LargeSendOffload && mss > 0)
    {
        ULONG                IpHeaderLen;
        ULONG                TcpHdrOffset;
        ULONG                HeadersLen;
        IPHeader UNALIGNED  *IpHdr;
        TCPHeader UNALIGNED *TcpHdr;
        ULONG                TcpDataLen;
        ULONG                LastPacketDataLen;
        int                  SeqNum;
        ULONG                TmpXsum;
        ULONG                BytesSent = 0;
        ULONG                TmpPxsum = 0;
        USHORT               TcpHeaderLen;
        USHORT               IpSegmentLen;
        BOOLEAN              IsFinSet = FALSE;
        BOOLEAN              IsPushSet = FALSE;
        BOOLEAN              IsFirstSlot = TRUE;
        
        

        IpHdr = (IPHeader UNALIGNED*)((PUCHAR)CopyStartVa + IpHdrOffset);
        IpHeaderLen = IP_HEADER_LENGTH(IpHdr);
        
        // 
        // The packet must be a TCP packet
        //
        ASSERT(IpHdr->iph_protocol == PROTOCOL_TCP);
        
        TcpHdrOffset = IpHdrOffset + IpHeaderLen;
        
        TcpHdr = (TCPHeader UNALIGNED *)((PUCHAR)CopyStartVa + TcpHdrOffset);
        
        TcpHeaderLen = TCP_HEADER_LENGTH(TcpHdr);
        HeadersLen = TcpHdrOffset + TcpHeaderLen;
       
        //
        // This length include IP, TCP headers and TCP data.
        //
        IpSegmentLen = net_short(IpHdr->iph_length);

        //
        // get the pseudo-header 1's complement sum
        //
        TmpPxsum = TcpHdr->tcp_xsum;
        
        ASSERT(IpSegmentLen == PacketLength - IpHdrOffset);
        
        IsFinSet = (BOOLEAN)(TcpHdr->tcp_flags & TCP_FLAG_FIN);
        IsPushSet = (BOOLEAN)(TcpHdr->tcp_flags & TCP_FLAG_PUSH);
        
        SeqNum = net_long(TcpHdr->tcp_seq);
        TcpDataLen = IpSegmentLen - TcpHeaderLen - IpHeaderLen;

        ASSERT(TcpDataLen <= Adapter->LargeSendInfo.MaxOffLoadSize)
        
        NumOfPackets = TcpDataLen / mss + 1;
        
        ASSERT (NumOfPackets >= Adapter->LargeSendInfo.MinSegmentCount);
        
        LastPacketDataLen = TcpDataLen % mss;
        NdisBuffer = FirstBuffer;
        BytesSent = 0;

        //
        // The next copy start with offset of (mss+HeadersLen) corresponding to first buf
        // 
        BytesCopied = (BytesCopied >= mss + HeadersLen)? (mss + HeadersLen):BytesCopied;
        Offset = BytesCopied;

        //
        // Send out all the packets from the large TCP packet
        // 
        while (NumOfPackets--)
        {
            TmpXsum = 0;
           
            //
            // Is the first packet?
            // 
            if (IsFirstSlot) 
            {
                if (NumOfPackets == 0)
                {
                    PktExt->NdisPacketInfo[TcpLargeSendPacketInfo] = UlongToPtr(BytesCopied);
                }
                else 
                {
                    if (IsFinSet)
                    {
                        TcpHdr->tcp_flags &= ~TCP_FLAG_FIN;
                        
                    }
                    if (IsPushSet)
                    {                        
                        TcpHdr->tcp_flags &= ~TCP_FLAG_PUSH;
                        
                    }
                        
                }
                BytesCopied -= HeadersLen;
                IsFirstSlot = FALSE;
            }
            //
            // Not the first packet
            // 
            else
            {
                //
                // copy headers
                //
                NdisMoveMemory (StartVa, CopyStartVa, HeadersLen);
                
                IpHdr = (IPHeader UNALIGNED *)((PUCHAR)StartVa + IpHdrOffset);
                TcpHdr = (TCPHeader UNALIGNED *) ((PUCHAR)StartVa + TcpHdrOffset);
                
                //
                // Last packet
                //
                if (NumOfPackets == 0)
                {
                    BytesToCopy = LastPacketDataLen;
                    PktExt->NdisPacketInfo[TcpLargeSendPacketInfo] = 
                                                   UlongToPtr(BytesSent + LastPacketDataLen);
                }
                else 
                {
                    BytesToCopy = mss;
                    // clear flag
                    if (IsFinSet)
                    {
                        TcpHdr->tcp_flags &= ~TCP_FLAG_FIN;
                    }
                    if (IsPushSet)
                    {
                        TcpHdr->tcp_flags &= ~TCP_FLAG_PUSH;
                    }
                    
                }
                BytesCopied = MpCopyData(
                                    BytesToCopy,        
                                    &NdisBuffer, 
                                    StartVa + HeadersLen, 
                                    &Offset,
                                    HeadersLen);
                
                //
                // MpCopyData may return 0 if system resources are low or exhausted
                //
                if (BytesCopied == 0)
                {
        
                    PktExt->NdisPacketInfo[TcpLargeSendPacketInfo] = UlongToPtr(BytesSent);
                    return NDIS_STATUS_RESOURCES;            
                }
            } 
            
            IpHdr->iph_length = net_short(TcpHeaderLen + IpHeaderLen + BytesCopied);
            TcpHdr->tcp_seq = net_long(SeqNum);
            SeqNum += BytesCopied;

            //
            // calculate ip checksum and tcp checksum
            //
            IpHdr->iph_xsum = 0;
            XSUM(TmpXsum, StartVa, IpHeaderLen, IpHdrOffset);
            IpHdr->iph_xsum = ~(USHORT)(TmpXsum);

            TmpXsum = TmpPxsum + net_short((USHORT)(BytesCopied + TcpHeaderLen));
            TcpHdr->tcp_xsum = 0;
            XSUM(TmpXsum, StartVa, BytesCopied + TcpHeaderLen, TcpHdrOffset);
            TcpHdr->tcp_xsum = ~(USHORT)(TmpXsum);

            BytesSent += BytesCopied;
            BytesCopied += HeadersLen;
            
            //
            // get TCB for the slot
            //
            pMpTcb = Adapter->CurrSendTail;
            ASSERT(!MP_TEST_FLAG(pMpTcb, fMP_TCB_IN_USE));
            
            //
            // Set up the frag list, only one fragment after it's coalesced
            //
            pFragList = &FragList;
            pFragList->NumberOfElements = 1;
            pFragList->Elements[0].Address = SendPa;
            pFragList->Elements[0].Length = (BytesCopied >= NIC_MIN_PACKET_SIZE) ?
                                             BytesCopied : NIC_MIN_PACKET_SIZE;
            pMpTcb->Packet = Packet;
                
            MP_SET_FLAG(pMpTcb, fMP_TCB_IN_USE);
            
            //
            // Call the NIC specific send handler, it only needs to deal with the frag list
            //
            Status = NICSendPacket(Adapter, pMpTcb, pFragList);
                
            Adapter->nBusySend++;
            Adapter->SharedMemRefCount++;
       
            //
            // Update the CopyVa and SendPa
            //
            SendPa.QuadPart += BytesCopied;
            StartVa += BytesCopied;
            
            Adapter->CurrSendTail = Adapter->CurrSendTail->Next;
            
            //
            // out of resouces, which will send complete part of the packet
            //
            if (Adapter->nBusySend >= Adapter->NumTcb)
            {
                PktExt->NdisPacketInfo[TcpLargeSendPacketInfo] = UlongToPtr(BytesSent);
                break;
            }
        } // while
    }
    // 
    // This is not a large packet or large send capability is not on
    //
    else
    {
        //
        // get TCB for the slot
        //
        pMpTcb = Adapter->CurrSendTail;
        ASSERT(!MP_TEST_FLAG(pMpTcb, fMP_TCB_IN_USE));
        //
        // Set up the frag list, only one fragment after it's coalesced
        //
        pFragList = &FragList;
        pFragList->NumberOfElements = 1;
        pFragList->Elements[0].Address = SendPa;
        pFragList->Elements[0].Length = (BytesCopied >= NIC_MIN_PACKET_SIZE) ?
                                         BytesCopied : NIC_MIN_PACKET_SIZE;
        pMpTcb->Packet = Packet;

        if (Adapter->NicChecksumOffload.DoXmitTcpChecksum
            && Adapter->NicTaskOffload.ChecksumOffload)
        {
            CalculateChecksum(CopyStartVa, 
                                  BytesCopied,
                                  Packet, 
                                  Adapter->EncapsulationFormat.EncapsulationHeaderSize);
        }
        MP_SET_FLAG(pMpTcb, fMP_TCB_IN_USE);
        //
        // Call the NIC specific send handler, it only needs to deal with the frag list
        //
        Status = NICSendPacket(Adapter, pMpTcb, pFragList);

        Adapter->nBusySend++;
        Adapter->SharedMemRefCount++;
        
        ASSERT(Adapter->nBusySend <= Adapter->NumTcb);
        Adapter->CurrSendTail = Adapter->CurrSendTail->Next;
        
    }
    
    DBGPRINT(MP_TRACE, ("<-- MpOffloadSendPacket\n"));
    return Status;
}  



/*++
Routine Description:

    Recycle a MP_TCB and complete the packet if necessary
    Assumption: Send spinlock has been acquired 

Arguments:

    Adapter     Pointer to our adapter
    pMpTcb      Pointer to MP_TCB        

Return Value:

    None

--*/
VOID MP_OFFLOAD_FREE_SEND_PACKET(
    IN  PMP_ADAPTER  Adapter,
    IN  PMP_TCB      pMpTcb
    )
{
    
    PNDIS_PACKET      Packet;
    
    ASSERT(MP_TEST_FLAG(pMpTcb, fMP_TCB_IN_USE));

    Packet = pMpTcb->Packet;
    pMpTcb->Packet = NULL;
    pMpTcb->Count = 0;

    MP_CLEAR_FLAGS(pMpTcb);

    Adapter->CurrSendHead = Adapter->CurrSendHead->Next;
    Adapter->nBusySend--;
    
    Adapter->SharedMemRefCount--;

    if (Adapter->SharedMemRefCount == 0)
    {
        MP_CLEAR_FLAG(Adapter, fMP_SHARED_MEM_IN_USE);
        //
        // Send complete the packet too
        //
        NdisMSendComplete(
                        MP_GET_ADAPTER_HANDLE(Adapter),
                        Packet,
                        NDIS_STATUS_SUCCESS);
        
        ASSERT(Adapter->nBusySend == 0);
    }
    ASSERT(Adapter->nBusySend >= 0);

}

    

/*++
Routine Description:

    Disable the existing capabilities before protocol is setting the
    new capabilities

Arguments:

    Adapter     Pointer to our adapter

Return Value:

    None

--*/
VOID DisableOffload(
    IN PMP_ADAPTER Adapter
    )
{
    //
    // Disable the capabilities of the miniports
    // 
    NdisZeroMemory(&(Adapter->NicTaskOffload), sizeof(NIC_TASK_OFFLOAD));
    NdisZeroMemory(&(Adapter->NicChecksumOffload), sizeof(NIC_CHECKSUM_OFFLOAD));
}

#endif // OFFLOAD
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\net\ms\e100bex\mp_init.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:
    mp_init.c

Abstract:
    This module contains miniport initialization related routines

Revision History:
    Who         When        What
    --------    --------    ----------------------------------------------
    DChen       11-01-99    created

Notes:

--*/

#include "precomp.h"

#if DBG
#define _FILENUMBER     'TINI'
#endif

typedef struct _MP_REG_ENTRY
{
    NDIS_STRING RegName;                // variable name text
    BOOLEAN     bRequired;              // 1 -> required, 0 -> optional
    UINT        FieldOffset;            // offset to MP_ADAPTER field
    UINT        FieldSize;              // size (in bytes) of the field
    UINT        Default;                // default value to use
    UINT        Min;                    // minimum value allowed
    UINT        Max;                    // maximum value allowed
} MP_REG_ENTRY, *PMP_REG_ENTRY;

MP_REG_ENTRY NICRegTable[] = {
// reg value name                           Offset in MP_ADAPTER            Field size                  Default Value           Min             Max
#if DBG                                                                                                                          
    {NDIS_STRING_CONST("Debug"),            0, MP_OFFSET(Debug),            MP_SIZE(Debug),             MP_WARN,                0,              0xffffffff},
#endif
    {NDIS_STRING_CONST("NumRfd"),           0, MP_OFFSET(NumRfd),           MP_SIZE(NumRfd),            32,                     NIC_MIN_RFDS,   NIC_MAX_RFDS},
    {NDIS_STRING_CONST("NumTcb"),           0, MP_OFFSET(NumTcb),           MP_SIZE(NumTcb),            NIC_DEF_TCBS,           1,              NIC_MAX_TCBS},
    {NDIS_STRING_CONST("NumCoalesce"),      0, MP_OFFSET(NumBuffers),       MP_SIZE(NumBuffers),        8,                      1,              32},
    {NDIS_STRING_CONST("PhyAddress"),       0, MP_OFFSET(PhyAddress),       MP_SIZE(PhyAddress),        0xFF,                   0,              0xFF},
    {NDIS_STRING_CONST("Connector"),        0, MP_OFFSET(Connector),        MP_SIZE(Connector),         0,                      0,              0x2},
    {NDIS_STRING_CONST("TxFifo"),           0, MP_OFFSET(AiTxFifo),         MP_SIZE(AiTxFifo),          DEFAULT_TX_FIFO_LIMIT,  0,              15},
    {NDIS_STRING_CONST("RxFifo"),           0, MP_OFFSET(AiRxFifo),         MP_SIZE(AiRxFifo),          DEFAULT_RX_FIFO_LIMIT,  0,              15},
    {NDIS_STRING_CONST("TxDmaCount"),       0, MP_OFFSET(AiTxDmaCount),     MP_SIZE(AiTxDmaCount),      0,                      0,              63},
    {NDIS_STRING_CONST("RxDmaCount"),       0, MP_OFFSET(AiRxDmaCount),     MP_SIZE(AiRxDmaCount),      0,                      0,              63},
    {NDIS_STRING_CONST("UnderrunRetry"),    0, MP_OFFSET(AiUnderrunRetry),  MP_SIZE(AiUnderrunRetry),   DEFAULT_UNDERRUN_RETRY, 0,              3},
    {NDIS_STRING_CONST("Threshold"),        0, MP_OFFSET(AiThreshold),      MP_SIZE(AiThreshold),       200,                    0,              200},
    {NDIS_STRING_CONST("MWIEnable"),        0, MP_OFFSET(MWIEnable),        MP_SIZE(MWIEnable),         1,                      0,              1},
    {NDIS_STRING_CONST("Congest"),          0, MP_OFFSET(Congest),          MP_SIZE(Congest),           0,                      0,              0x1},
    {NDIS_STRING_CONST("SpeedDuplex"),      0, MP_OFFSET(SpeedDuplex),      MP_SIZE(SpeedDuplex),       0,                      0,              4}
};

#define NIC_NUM_REG_PARAMS (sizeof (NICRegTable) / sizeof(MP_REG_ENTRY))

#if LBFO
NDIS_STRING strBundleId = NDIS_STRING_CONST("BundleId");        
#endif


NDIS_STATUS MpFindAdapter(
    IN  PMP_ADAPTER  Adapter,
    IN  NDIS_HANDLE  WrapperConfigurationContext
    )
/*++
Routine Description:

    Find the adapter and get all the assigned resources

Arguments:

    Adapter     Pointer to our adapter

Return Value:

    NDIS_STATUS_SUCCESS
    NDIS_STATUS_ADAPTER_NOT_FOUND (event is logged as well)    

--*/    
{

    
    NDIS_STATUS         Status = NDIS_STATUS_ADAPTER_NOT_FOUND;
    ULONG               ErrorCode = 0;
    ULONG               ErrorValue = 0;

    ULONG               ulResult;
    UCHAR               buffer[NIC_PCI_E100_HDR_LENGTH ];
    PPCI_COMMON_CONFIG  pPciConfig = (PPCI_COMMON_CONFIG) buffer;
    USHORT              usPciCommand;
       
    UCHAR               resBuf[NIC_RESOURCE_BUF_SIZE];
    PNDIS_RESOURCE_LIST resList = (PNDIS_RESOURCE_LIST)resBuf;
    UINT                bufSize = NIC_RESOURCE_BUF_SIZE;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR pResDesc;
    ULONG               index;
    BOOLEAN             bResPort = FALSE, bResInterrupt = FALSE, bResMemory = FALSE;

    DBGPRINT(MP_TRACE, ("---> MpFindAdapter\n"));

    do
    {
        //
        // Make sure the adpater is present
        //
        ulResult = NdisReadPciSlotInformation(
                       Adapter->AdapterHandle,
                       0,          // not used
                       FIELD_OFFSET(PCI_COMMON_CONFIG, VendorID),
                       buffer,
                       NIC_PCI_E100_HDR_LENGTH );

        if (ulResult != NIC_PCI_E100_HDR_LENGTH )
        {
            DBGPRINT(MP_ERROR, 
                ("NdisReadPciSlotInformation (PCI_COMMON_CONFIG) ulResult=%d\n", ulResult));

            ErrorCode = NDIS_ERROR_CODE_ADAPTER_NOT_FOUND;
            ErrorValue = ERRLOG_READ_PCI_SLOT_FAILED;
                   
            break;
        }

        //     
        // Right type of adapter?
        //
        if (pPciConfig->VendorID != NIC_PCI_VENDOR_ID || 
            pPciConfig->DeviceID != NIC_PCI_DEVICE_ID)
        {
            DBGPRINT(MP_ERROR, ("VendorID/DeviceID don't match - %x/%x\n", 
                pPciConfig->VendorID, pPciConfig->DeviceID));

            ErrorCode = NDIS_ERROR_CODE_ADAPTER_NOT_FOUND;
            ErrorValue = ERRLOG_VENDOR_DEVICE_NOMATCH;

            break;
        }

        DBGPRINT(MP_INFO, ("Adapter is found - VendorID/DeviceID=%x/%x\n", 
            pPciConfig->VendorID, pPciConfig->DeviceID));

        // save info from config space
        Adapter->RevsionID = pPciConfig->RevisionID;
        Adapter->SubVendorID = pPciConfig->u.type0.SubVendorID;
        Adapter->SubSystemID = pPciConfig->u.type0.SubSystemID;

        MpExtractPMInfoFromPciSpace (Adapter, (PUCHAR)pPciConfig);
        
        // --- HW_START   

        usPciCommand = pPciConfig->Command;
        if ((usPciCommand & PCI_ENABLE_WRITE_AND_INVALIDATE) && (Adapter->MWIEnable))
            Adapter->MWIEnable = TRUE;
        else
            Adapter->MWIEnable = FALSE;

        // Enable bus matering if it isn't enabled by the BIOS
        if (!(usPciCommand & PCI_ENABLE_BUS_MASTER))
        {
            DBGPRINT(MP_WARN, ("Bus master is not enabled by BIOS! usPciCommand=%x\n", 
                usPciCommand));

            usPciCommand |= CMD_BUS_MASTER;

            ulResult = NdisWritePciSlotInformation(
                           Adapter->AdapterHandle,
                           0,
                           FIELD_OFFSET(PCI_COMMON_CONFIG, Command),
                           &usPciCommand,
                           sizeof(USHORT));
            if (ulResult != sizeof(USHORT))
            {
                DBGPRINT(MP_ERROR, 
                    ("NdisWritePciSlotInformation (Command) ulResult=%d\n", ulResult));

                ErrorCode = NDIS_ERROR_CODE_ADAPTER_NOT_FOUND;
                ErrorValue = ERRLOG_WRITE_PCI_SLOT_FAILED;

                break;
            }

            ulResult = NdisReadPciSlotInformation(
                           Adapter->AdapterHandle,
                           0,
                           FIELD_OFFSET(PCI_COMMON_CONFIG, Command),
                           &usPciCommand,
                           sizeof(USHORT));
            if (ulResult != sizeof(USHORT))
            {
                DBGPRINT(MP_ERROR, 
                    ("NdisReadPciSlotInformation (Command) ulResult=%d\n", ulResult));

                ErrorCode = NDIS_ERROR_CODE_ADAPTER_NOT_FOUND;
                ErrorValue = ERRLOG_READ_PCI_SLOT_FAILED;

                break;
            }

            if (!(usPciCommand & PCI_ENABLE_BUS_MASTER))
            {
                DBGPRINT(MP_ERROR, ("Failed to enable bus master! usPciCommand=%x\n", 
                    usPciCommand));

                ErrorCode = NDIS_ERROR_CODE_ADAPTER_DISABLED;
                ErrorValue = ERRLOG_BUS_MASTER_DISABLED;

                break;
            }
        }

        DBGPRINT(MP_INFO, ("Bus master is enabled. usPciCommand=%x\n", usPciCommand));

        // --- HW_END

        //     
        // Adapter is found. Now get the assigned resources
        //
        NdisMQueryAdapterResources(
            &Status, 
            WrapperConfigurationContext, 
            resList, 
            &bufSize);
    
        if (Status != NDIS_STATUS_SUCCESS)
        {
            ErrorCode = NDIS_ERROR_CODE_RESOURCE_CONFLICT;
            ErrorValue = ERRLOG_QUERY_ADAPTER_RESOURCES;
            break;
        }

        for (index=0; index < resList->Count; index++)
        {
            pResDesc = &resList->PartialDescriptors[index];

            switch(pResDesc->Type)
            {
                case CmResourceTypePort:
                    Adapter->IoBaseAddress = NdisGetPhysicalAddressLow(pResDesc->u.Port.Start); 
                    Adapter->IoRange = pResDesc->u.Port.Length;
                    bResPort = TRUE;

                    DBGPRINT(MP_INFO, ("IoBaseAddress = 0x%x\n", Adapter->IoBaseAddress));
                    DBGPRINT(MP_INFO, ("IoRange = x%x\n", Adapter->IoRange));
                    break;

                case CmResourceTypeInterrupt:
                    Adapter->InterruptLevel = pResDesc->u.Interrupt.Level;
                    bResInterrupt = TRUE;
                    
                    DBGPRINT(MP_INFO, ("InterruptLevel = x%x\n", Adapter->InterruptLevel));
                    break;

                case CmResourceTypeMemory:
                    // Our CSR memory space should be 0x1000, other memory is for 
                    // flash address, a boot ROM address, etc.
                    if (pResDesc->u.Memory.Length == 0x1000)
                    {
                        Adapter->MemPhysAddress = pResDesc->u.Memory.Start;
                        bResMemory = TRUE;
                        
                        DBGPRINT(MP_INFO, 
                            ("MemPhysAddress(Low) = 0x%0x\n", NdisGetPhysicalAddressLow(Adapter->MemPhysAddress)));
                        DBGPRINT(MP_INFO, 
                            ("MemPhysAddress(High) = 0x%0x\n", NdisGetPhysicalAddressHigh(Adapter->MemPhysAddress)));
                    }
                    break;
            }
        } 
        
        if (!bResPort || !bResInterrupt || !bResMemory)
        {
            Status = NDIS_STATUS_RESOURCE_CONFLICT;
            ErrorCode = NDIS_ERROR_CODE_RESOURCE_CONFLICT;
            
            if (!bResPort)
            {
                ErrorValue = ERRLOG_NO_IO_RESOURCE;
            }
            else if (!bResInterrupt)
            {
                ErrorValue = ERRLOG_NO_INTERRUPT_RESOURCE;
            }
            else 
            {
                ErrorValue = ERRLOG_NO_MEMORY_RESOURCE;
            }
            
            break;
        }
        
        Status = NDIS_STATUS_SUCCESS;

    } while (FALSE);
    
    if (Status != NDIS_STATUS_SUCCESS)
    {
        NdisWriteErrorLogEntry(
            Adapter->AdapterHandle,
            ErrorCode,
            1,
            ErrorValue);
    }

    DBGPRINT_S(Status, ("<--- MpFindAdapter, Status=%x\n", Status));

    return Status;

}

NDIS_STATUS NICReadAdapterInfo(
    IN  PMP_ADAPTER     Adapter)
/*++
Routine Description:

    Read the mac addresss from the adapter

Arguments:

    Adapter     Pointer to our adapter

Return Value:

    NDIS_STATUS_SUCCESS
    NDIS_STATUS_INVALID_ADDRESS

--*/    
{
    NDIS_STATUS     Status = NDIS_STATUS_SUCCESS;
    USHORT          usValue; 
    int             i;

    DBGPRINT(MP_TRACE, ("--> NICReadAdapterInfo\n"));

    Adapter->EepromAddressSize = 
        GetEEpromAddressSize(GetEEpromSize(Adapter->PortOffset));
    DBGPRINT(MP_WARN, ("EepromAddressSize = %d\n", Adapter->EepromAddressSize));
        
    
    //
    // Read node address from the EEPROM
    //
    for (i=0; i< ETH_LENGTH_OF_ADDRESS; i += 2)
    {
        usValue = ReadEEprom(Adapter->PortOffset,
                      (USHORT)(EEPROM_NODE_ADDRESS_BYTE_0 + (i/2)),
                      Adapter->EepromAddressSize);

        *((PUSHORT)(&Adapter->PermanentAddress[i])) = usValue;
    }

    DBGPRINT(MP_INFO, ("Permanent Address = %02x-%02x-%02x-%02x-%02x-%02x\n", 
        Adapter->PermanentAddress[0], Adapter->PermanentAddress[1], 
        Adapter->PermanentAddress[2], Adapter->PermanentAddress[3], 
        Adapter->PermanentAddress[4], Adapter->PermanentAddress[5]));

    if (ETH_IS_MULTICAST(Adapter->PermanentAddress) || 
        ETH_IS_BROADCAST(Adapter->PermanentAddress))
    {
        DBGPRINT(MP_ERROR, ("Permanent address is invalid\n")); 

        NdisWriteErrorLogEntry(
            Adapter->AdapterHandle,
            NDIS_ERROR_CODE_NETWORK_ADDRESS,
            0);
        Status = NDIS_STATUS_INVALID_ADDRESS;         
    }
    else
    {
        if (!Adapter->bOverrideAddress)
        {
            ETH_COPY_NETWORK_ADDRESS(Adapter->CurrentAddress, Adapter->PermanentAddress);
        }

        DBGPRINT(MP_INFO, ("Current Address = %02x-%02x-%02x-%02x-%02x-%02x\n", 
            Adapter->CurrentAddress[0], Adapter->CurrentAddress[1],
            Adapter->CurrentAddress[2], Adapter->CurrentAddress[3],
            Adapter->CurrentAddress[4], Adapter->CurrentAddress[5]));
    }

    DBGPRINT_S(Status, ("<-- NICReadAdapterInfo, Status=%x\n", Status));

    return Status;
}

NDIS_STATUS MpAllocAdapterBlock(
    OUT PMP_ADAPTER     *pAdapter)
/*++
Routine Description:

    Allocate MP_ADAPTER data block and do some initialization

Arguments:

    Adapter     Pointer to receive pointer to our adapter

Return Value:

    NDIS_STATUS_SUCCESS
    NDIS_STATUS_FAILURE

--*/    
{
    PMP_ADAPTER     Adapter;
    NDIS_STATUS     Status;

    DBGPRINT(MP_TRACE, ("--> NICAllocAdapter\n"));

    *pAdapter = NULL;

    do
    {
        // Allocate MP_ADAPTER block
        Status = MP_ALLOCMEMTAG(&Adapter, sizeof(MP_ADAPTER));
        if (Status != NDIS_STATUS_SUCCESS)
        {
            DBGPRINT(MP_ERROR, ("Failed to allocate memory - ADAPTER\n"));
            break;
        }

        // Clean up the memory block
        NdisZeroMemory(Adapter, sizeof(MP_ADAPTER));

        MP_INC_REF(Adapter);

        // Init lists, spinlocks, etc.
        InitializeQueueHeader(&Adapter->SendWaitQueue);
        InitializeQueueHeader(&Adapter->SendCancelQueue);

        InitializeListHead(&Adapter->RecvList);
        InitializeListHead(&Adapter->RecvPendList);
        InitializeListHead(&Adapter->PoMgmt.PatternList);

        NdisInitializeEvent(&Adapter->ExitEvent);
        NdisInitializeEvent(&Adapter->AllPacketsReturnedEvent);
        MP_INC_RCV_REF(Adapter);

        NdisAllocateSpinLock(&Adapter->Lock);
        NdisAllocateSpinLock(&Adapter->SendLock);
        NdisAllocateSpinLock(&Adapter->RcvLock);

    } while (FALSE);

    *pAdapter = Adapter;

    DBGPRINT_S(Status, ("<-- NICAllocAdapter, Status=%x\n", Status));

    return Status;

}

VOID MpFreeAdapter(
    IN  PMP_ADAPTER     Adapter)
/*++
Routine Description:

    Free all the resources and MP_ADAPTER data block

Arguments:

    Adapter     Pointer to our adapter

Return Value:

    None                                                    

--*/    
{
    PMP_TXBUF       pMpTxBuf;
    PMP_RFD         pMpRfd;

    DBGPRINT(MP_TRACE, ("--> NICFreeAdapter\n"));

    // No active and waiting sends
    ASSERT(Adapter->nBusySend == 0);
    ASSERT(Adapter->nWaitSend == 0);
    ASSERT(IsQueueEmpty(&Adapter->SendWaitQueue));
    ASSERT(IsQueueEmpty(&Adapter->SendCancelQueue));

    // No other pending operations
    ASSERT(IsListEmpty(&Adapter->RecvPendList));
    ASSERT(Adapter->bAllocNewRfd == FALSE);
    ASSERT(!MP_TEST_FLAG(Adapter, fMP_ADAPTER_LINK_DETECTION));
    ASSERT(MP_GET_REF(Adapter) == 0);

    //
    // Free hardware resources
    //      
    if (MP_TEST_FLAG(Adapter, fMP_ADAPTER_INTERRUPT_IN_USE))
    {
        NdisMDeregisterInterrupt(&Adapter->Interrupt);
        MP_CLEAR_FLAG(Adapter, fMP_ADAPTER_INTERRUPT_IN_USE);
    }

    if (Adapter->CSRAddress)
    {
        NdisMUnmapIoSpace(
            Adapter->AdapterHandle,
            Adapter->CSRAddress,
            NIC_MAP_IOSPACE_LENGTH);
        Adapter->CSRAddress = NULL;
    }

    if (Adapter->PortOffset)
    {
        NdisMDeregisterIoPortRange(
            Adapter->AdapterHandle,
            Adapter->IoBaseAddress,
            Adapter->IoRange,
            Adapter->PortOffset);
        Adapter->PortOffset = NULL;
    }

    //               
    // Free RECV memory/NDIS buffer/NDIS packets/shared memory
    //
    ASSERT(Adapter->nReadyRecv == Adapter->CurrNumRfd);

    while (!IsListEmpty(&Adapter->RecvList))
    {
        pMpRfd = (PMP_RFD)RemoveHeadList(&Adapter->RecvList);
        NICFreeRfd(Adapter, pMpRfd);
    }

    // Free receive buffer pool
    if (Adapter->RecvBufferPool)
    {
        NdisFreeBufferPool(Adapter->RecvBufferPool);
        Adapter->RecvBufferPool = NULL;
    }

    // Free receive packet pool
    if (Adapter->RecvPacketPool)
    {
        NdisFreePacketPool(Adapter->RecvPacketPool);
        Adapter->RecvPacketPool = NULL;
    }
    
    if (MP_TEST_FLAG(Adapter, fMP_ADAPTER_RECV_LOOKASIDE))
    {
        NdisDeleteNPagedLookasideList(&Adapter->RecvLookaside);
        MP_CLEAR_FLAG(Adapter, fMP_ADAPTER_RECV_LOOKASIDE);
    }
            
    //               
    // Free SEND memory/NDIS buffer/NDIS packets/shared memory
    //
    while (!IsSListEmpty(&Adapter->SendBufList))
    {
        pMpTxBuf = (PMP_TXBUF)PopEntryList(&Adapter->SendBufList);
        ASSERT(pMpTxBuf);

        // Free the shared memory associated with each MP_TXBUF
        if (pMpTxBuf->AllocVa)
        {
            NdisMFreeSharedMemory(
                Adapter->AdapterHandle,
                pMpTxBuf->AllocSize,
                TRUE,
                pMpTxBuf->AllocVa,
                pMpTxBuf->AllocPa);
            pMpTxBuf->AllocVa = NULL;      
        }

        // Free the NDIS buffer
        if (pMpTxBuf->NdisBuffer)
        {
            NdisAdjustBufferLength(pMpTxBuf->NdisBuffer, pMpTxBuf->BufferSize);
            NdisFreeBuffer(pMpTxBuf->NdisBuffer);
            pMpTxBuf->NdisBuffer = NULL;
        }
    }

    // Free the send buffer pool
    if (Adapter->SendBufferPool)
    {
        NdisFreeBufferPool(Adapter->SendBufferPool);
        Adapter->SendBufferPool = NULL;
    }
    
    // Free the memory for MP_TXBUF structures
    if (Adapter->MpTxBufMem)
    {
        MP_FREEMEM(Adapter->MpTxBufMem, Adapter->MpTxBufMemSize, 0);
        Adapter->MpTxBufMem = NULL;
    }

    // Free the shared memory for HW_TCB structures
    if (Adapter->HwSendMemAllocVa)
    {
        NdisMFreeSharedMemory(
            Adapter->AdapterHandle,
            Adapter->HwSendMemAllocSize,
            FALSE,
            Adapter->HwSendMemAllocVa,
            Adapter->HwSendMemAllocPa);
        Adapter->HwSendMemAllocVa = NULL;
    }

    // Free the shared memory for other command data structures                       
    if (Adapter->HwMiscMemAllocVa)
    {
        NdisMFreeSharedMemory(
            Adapter->AdapterHandle,
            Adapter->HwMiscMemAllocSize,
            FALSE,
            Adapter->HwMiscMemAllocVa,
            Adapter->HwMiscMemAllocPa);
        Adapter->HwMiscMemAllocVa = NULL;
    }


    // Free the memory for MP_TCB structures
    if (Adapter->MpTcbMem)
    {
        MP_FREEMEM(Adapter->MpTcbMem, Adapter->MpTcbMemSize, 0);
        Adapter->MpTcbMem = NULL;
    }

    // Free map registers. This must be after all the shared memory is freed
    if (MP_TEST_FLAG(Adapter, fMP_ADAPTER_MAP_REGISTER))
    {
        NdisMFreeMapRegisters(Adapter->AdapterHandle);
        MP_CLEAR_FLAG(Adapter, fMP_ADAPTER_MAP_REGISTER);
    }

    //Free all the wake up patterns on this adapter
    MPRemoveAllWakeUpPatterns(Adapter);
    
    NdisFreeSpinLock(&Adapter->Lock);
    NdisFreeSpinLock(&Adapter->SendLock);
    NdisFreeSpinLock(&Adapter->RcvLock);


#if LBFO
    if (Adapter->BundleId.MaximumLength)
    {
        MP_FREE_NDIS_STRING(&Adapter->BundleId);
    }
#endif

#if OFFLOAD    
    // Free the shared memory for offload tasks
    if (Adapter->OffloadSharedMem.StartVa)
    {
        NdisMFreeSharedMemory(
                Adapter->AdapterHandle,
                Adapter->OffloadSharedMemSize,
                FALSE,
                Adapter->OffloadSharedMem.StartVa,
                Adapter->OffloadSharedMem.PhyAddr);
        Adapter->OffloadSharedMem.StartVa = NULL;
    }

#endif

    MP_FREEMEM(Adapter, sizeof(MP_ADAPTER), 0);  

#if DBG
    if (MPInitDone)
    {
        NdisFreeSpinLock(&MPMemoryLock);
    }
#endif

    DBGPRINT(MP_TRACE, ("<-- NICFreeAdapter\n"));
}

NDIS_STATUS NICReadRegParameters(
    IN  PMP_ADAPTER     Adapter,
    IN  NDIS_HANDLE     WrapperConfigurationContext)
/*++
Routine Description:

    Read the following from the registry
    1. All the parameters
    2. NetworkAddres
    3. LBFO - BundleId

Arguments:

    Adapter                         Pointer to our adapter
    WrapperConfigurationContext     For use by NdisOpenConfiguration

Return Value:

    NDIS_STATUS_SUCCESS
    NDIS_STATUS_FAILURE
    NDIS_STATUS_RESOURCES                                       

--*/    
{
    NDIS_STATUS     Status = NDIS_STATUS_SUCCESS;
    NDIS_HANDLE     ConfigurationHandle;
    PMP_REG_ENTRY   pRegEntry;
    UINT            i;
    UINT            value;
    PUCHAR          pointer;
    PNDIS_CONFIGURATION_PARAMETER ReturnedValue;
    PUCHAR          NetworkAddress;
    UINT            Length;

    DBGPRINT(MP_TRACE, ("--> NICReadRegParameters\n"));

    // Open the registry for this adapter
    NdisOpenConfiguration(
        &Status,
        &ConfigurationHandle,
        WrapperConfigurationContext);
    if (Status != NDIS_STATUS_SUCCESS)
    {
        DBGPRINT(MP_ERROR, ("NdisOpenConfiguration failed\n"));
        DBGPRINT_S(Status, ("<-- NICReadRegParameters, Status=%x\n", Status));
        return Status;
    }

    // read all the registry values 
    for (i = 0, pRegEntry = NICRegTable; i < NIC_NUM_REG_PARAMS; i++, pRegEntry++)
    {
        //
        // Driver should NOT fail the initialization only because it can not
        // read the registry
        //
        ASSERT(pRegEntry->bRequired == FALSE);
        pointer = (PUCHAR) Adapter + pRegEntry->FieldOffset;

        DBGPRINT_UNICODE(MP_INFO, &pRegEntry->RegName);

        // Get the configuration value for a specific parameter.  Under NT the
        // parameters are all read in as DWORDs.
        NdisReadConfiguration(
            &Status,
            &ReturnedValue,
            ConfigurationHandle,
            &pRegEntry->RegName,
            NdisParameterInteger);

        // If the parameter was present, then check its value for validity.
        if (Status == NDIS_STATUS_SUCCESS)
        {
            // Check that param value is not too small or too large
            if (ReturnedValue->ParameterData.IntegerData < pRegEntry->Min ||
                ReturnedValue->ParameterData.IntegerData > pRegEntry->Max)
            {
                value = pRegEntry->Default;
            }
            else
            {
                value = ReturnedValue->ParameterData.IntegerData;
            }

            DBGPRINT_RAW(MP_INFO, ("= 0x%x\n", value));
        }
        else if (pRegEntry->bRequired)
        {
            DBGPRINT_RAW(MP_ERROR, (" -- failed\n"));

            ASSERT(FALSE);

            Status = NDIS_STATUS_FAILURE;
            break;
        }
        else
        {
            value = pRegEntry->Default;
            DBGPRINT_RAW(MP_INFO, ("= 0x%x (default)\n", value));
            Status = NDIS_STATUS_SUCCESS;
        }
        //
        // Store the value in the adapter structure.
        //
        switch(pRegEntry->FieldSize)
        {
            case 1:
                *((PUCHAR) pointer) = (UCHAR) value;
                break;

            case 2:
                *((PUSHORT) pointer) = (USHORT) value;
                break;

            case 4:
                *((PULONG) pointer) = (ULONG) value;
                break;

            default:
                DBGPRINT(MP_ERROR, ("Bogus field size %d\n", pRegEntry->FieldSize));
                break;
        }
    }

    // Read NetworkAddress registry value 
    // Use it as the current address if any
    if (Status == NDIS_STATUS_SUCCESS)
    {
        NdisReadNetworkAddress(
            &Status,
            &NetworkAddress,
            &Length,
            ConfigurationHandle);

        // If there is a NetworkAddress override in registry, use it 
        if ((Status == NDIS_STATUS_SUCCESS) && (Length == ETH_LENGTH_OF_ADDRESS))
        {
            if ((ETH_IS_MULTICAST(NetworkAddress) 
                    || ETH_IS_BROADCAST(NetworkAddress))
                    || !ETH_IS_LOCALLY_ADMINISTERED (NetworkAddress))
            {
                DBGPRINT(MP_ERROR, 
                    ("Overriding NetworkAddress is invalid - %02x-%02x-%02x-%02x-%02x-%02x\n", 
                    NetworkAddress[0], NetworkAddress[1], NetworkAddress[2],
                    NetworkAddress[3], NetworkAddress[4], NetworkAddress[5]));
            }
            else
            {
                ETH_COPY_NETWORK_ADDRESS(Adapter->CurrentAddress, NetworkAddress);
                Adapter->bOverrideAddress = TRUE;
            }
        }

        Status = NDIS_STATUS_SUCCESS;
    }

#if LBFO
    if (Status == NDIS_STATUS_SUCCESS)
    {
        // Read BundleIdentifier string
        NdisReadConfiguration(
            &Status,
            &ReturnedValue,
            ConfigurationHandle,
            &strBundleId,
            NdisParameterString);

        if (Status == NDIS_STATUS_SUCCESS)
        {
            ASSERT(ReturnedValue->ParameterType == NdisParameterString);

            if (ReturnedValue->ParameterData.StringData.Length !=0)
            {
                Status = MP_ALLOCMEMTAG(&Adapter->BundleId.Buffer, 
                             ReturnedValue->ParameterData.StringData.Length + sizeof(WCHAR));
                if (Status == NDIS_STATUS_SUCCESS)
                {
                    Adapter->BundleId.MaximumLength = 
                        ReturnedValue->ParameterData.StringData.Length + sizeof(WCHAR);
                    NdisUpcaseUnicodeString(
                        &Adapter->BundleId, 
                        &ReturnedValue->ParameterData.StringData);
                }
                else
                {
                    DBGPRINT(MP_ERROR, ("Failed to allocate memory - BundleIdentifier\n"));
                }
            }
        }
        else
        {
            // This parameter is optional, set status to SUCCESS
            Status = NDIS_STATUS_SUCCESS;
        }
    }
#endif   

    // Close the registry
    NdisCloseConfiguration(ConfigurationHandle);
    
    // Decode SpeedDuplex
    if (Status == NDIS_STATUS_SUCCESS && Adapter->SpeedDuplex)
    {
        switch(Adapter->SpeedDuplex)
        {
            case 1:
            Adapter->AiTempSpeed = 10; Adapter->AiForceDpx = 1;
            break;
            
            case 2:
            Adapter->AiTempSpeed = 10; Adapter->AiForceDpx = 2;
            break;
            
            case 3:
            Adapter->AiTempSpeed = 100; Adapter->AiForceDpx = 1;
            break;
            
            case 4:
            Adapter->AiTempSpeed = 100; Adapter->AiForceDpx = 2;
            break;
        }
    
    }

    DBGPRINT_S(Status, ("<-- NICReadRegParameters, Status=%x\n", Status));

    return Status;
}

NDIS_STATUS NICAllocAdapterMemory(
    IN  PMP_ADAPTER     Adapter)
/*++
Routine Description:

    Allocate all the memory blocks for send, receive and others

Arguments:

    Adapter     Pointer to our adapter

Return Value:

    NDIS_STATUS_SUCCESS
    NDIS_STATUS_FAILURE
    NDIS_STATUS_RESOURCES

--*/    
{
    NDIS_STATUS     Status;
    PMP_TXBUF       pMpTxbuf;
    PUCHAR          pMem;
    ULONG           MemPhys;
    LONG            index;
    ULONG           ErrorValue = 0;
    UINT            MaxNumBuffers;

#if OFFLOAD
    BOOLEAN         OffloadSharedMemSuccess = FALSE;
    UINT            i;
#endif
    
    DBGPRINT(MP_TRACE, ("--> NICAllocMemory\n"));

    DBGPRINT(MP_INFO, ("NumTcb=%d\n", Adapter->NumTcb));
    Adapter->NumTbd = Adapter->NumTcb * NIC_MAX_PHYS_BUF_COUNT;

    do
    {
        //
        // Try to use the ScatterGather method first, this is the preferred way
        // Only use map registers if we can't do scatter gather (e.g. on win9x)
#if OFFLOAD          
        Status = NdisMInitializeScatterGatherDma(
                     Adapter->AdapterHandle,
                     FALSE,
                     LARGE_SEND_OFFLOAD_SIZE);
#else
        Status = NdisMInitializeScatterGatherDma(
                     Adapter->AdapterHandle,
                     FALSE,
                     NIC_MAX_PACKET_SIZE);
#endif        


        
        if (Status == NDIS_STATUS_SUCCESS)
        {
            MP_SET_FLAG(Adapter, fMP_ADAPTER_SCATTER_GATHER);
        }
        else
        {

            DBGPRINT(MP_WARN, ("Failed to init ScatterGather DMA\n"));

#ifdef NDIS51_MINIPORT
            //
            // NDIS 5.1 miniport should NOT use map register
            //
            ErrorValue = ERRLOG_OUT_OF_SG_RESOURCES;
            DBGPRINT(MP_ERROR, ("Failed to allocate map registers\n"));
            
            break;  
#else
            DBGPRINT(MP_WARN, ("Try to allocate map registers\n"));

            // We should limit the totoal map registers needed to 32            
            Adapter->NumTcb = 32 / NIC_MAX_PHYS_BUF_COUNT;  
            Adapter->NumTbd = Adapter->NumTcb * NIC_MAX_PHYS_BUF_COUNT;
            DBGPRINT(MP_WARN, ("NumTcb is reduced to %d", Adapter->NumTcb));

            while (Adapter->NumTcb > 0)
            {
                Status = NdisMAllocateMapRegisters(
                             Adapter->AdapterHandle,
                             0,
                             NDIS_DMA_32BITS,
                             Adapter->NumTbd,
                             NIC_MAX_PACKET_SIZE);

                if (Status == NDIS_STATUS_SUCCESS)
                {
                    break;   
                }

                // Reduce NumTcb and try again          
                Adapter->NumTcb--;
                DBGPRINT(MP_WARN, ("NumTcb is reduced to %d", Adapter->NumTcb));
                Adapter->NumTbd = Adapter->NumTcb * NIC_MAX_PHYS_BUF_COUNT;
            }

            if (Status == NDIS_STATUS_SUCCESS)
            {
                MP_SET_FLAG(Adapter, fMP_ADAPTER_MAP_REGISTER);
            }
            else
            {
                ErrorValue = ERRLOG_OUT_OF_MAP_REGISTERS;
                DBGPRINT(MP_ERROR, ("Failed to allocate map registers\n"));
                break;   
            }
    #endif            
        }

        //
        // Send + Misc
        //
        //
        // Allocate MP_TCB's
        // 
        Adapter->MpTcbMemSize = Adapter->NumTcb * sizeof(MP_TCB);
        Status = MP_ALLOCMEMTAG(&pMem, Adapter->MpTcbMemSize);
        if (Status != NDIS_STATUS_SUCCESS)
        {
            ErrorValue = ERRLOG_OUT_OF_MEMORY;
            DBGPRINT(MP_ERROR, ("Failed to allocate MP_TCB's\n"));
            break;
        }
        NdisZeroMemory(pMem, Adapter->MpTcbMemSize);
        Adapter->MpTcbMem = pMem;
        //
        // Now the driver needs to allocate send buffer pool, the number 
        // of send buffers the driver needs is the larger one of Adapter->NumBuffer  
        // and Adapter->NumTcb.
        //
        MaxNumBuffers = Adapter->NumBuffers > Adapter->NumTcb ? Adapter->NumBuffers: Adapter->NumTcb;
        NdisAllocateBufferPool(
            &Status,
            &Adapter->SendBufferPool,
            MaxNumBuffers);
        if (Status != NDIS_STATUS_SUCCESS)
        {
            ErrorValue = ERRLOG_OUT_OF_BUFFER_POOL;
            DBGPRINT(MP_ERROR, ("Failed to allocate send buffer pool\n"));
            break;
        }

        // Allocate send buffers
        Adapter->MpTxBufMemSize = Adapter->NumBuffers * sizeof(MP_TXBUF);
        Status = MP_ALLOCMEMTAG(&pMem, Adapter->MpTxBufMemSize);
        if (Status != NDIS_STATUS_SUCCESS)
        {
            ErrorValue = ERRLOG_OUT_OF_MEMORY;
            DBGPRINT(MP_ERROR, ("Failed to allocate MP_TXBUF's\n"));
            break;
        }
        NdisZeroMemory(pMem, Adapter->MpTxBufMemSize);
        Adapter->MpTxBufMem = pMem;

        pMpTxbuf = (PMP_TXBUF) pMem;         

    //
    // NdisMGetDmaAlignment is provided in XP (WINVER=0x0501) and higher
    // if you need to write a driver that runs on older versions of Windows
    // you need to compile with older versions of DDK which have WINVER < 0x0501
    // such as W2K DDK.
    //
#if (WINVER < 0x0501)
        Adapter->CacheFillSize = NdisGetCacheFillSize();
#else
        Adapter->CacheFillSize = NdisMGetDmaAlignment(Adapter->AdapterHandle);
#endif
        DBGPRINT(MP_INFO, ("CacheFillSize=%d\n", Adapter->CacheFillSize));

        for (index = 0; index < Adapter->NumBuffers; index++)
        {
            pMpTxbuf->AllocSize = NIC_MAX_PACKET_SIZE + Adapter->CacheFillSize;
            pMpTxbuf->BufferSize = NIC_MAX_PACKET_SIZE;

            NdisMAllocateSharedMemory(
                Adapter->AdapterHandle,
                pMpTxbuf->AllocSize,
                TRUE,                           // CACHED
                &pMpTxbuf->AllocVa,  
                &pMpTxbuf->AllocPa);

            if (!pMpTxbuf->AllocVa)
            {
                ErrorValue = ERRLOG_OUT_OF_SHARED_MEMORY;
                DBGPRINT(MP_ERROR, ("Failed to allocate a big buffer\n"));
                Status = NDIS_STATUS_RESOURCES;
                break;
            }
            //
            // Align the buffer on the cache line boundary
            //
            pMpTxbuf->pBuffer = MP_ALIGNMEM(pMpTxbuf->AllocVa, Adapter->CacheFillSize);
            pMpTxbuf->BufferPa.QuadPart = MP_ALIGNMEM_PA(pMpTxbuf->AllocPa, Adapter->CacheFillSize);

            NdisAllocateBuffer(
                &Status,
                &pMpTxbuf->NdisBuffer,
                Adapter->SendBufferPool,
                pMpTxbuf->pBuffer,
                pMpTxbuf->BufferSize);

            if (Status != NDIS_STATUS_SUCCESS)
            {
                ErrorValue = ERRLOG_OUT_OF_NDIS_BUFFER;
                DBGPRINT(MP_ERROR, ("Failed to allocate NDIS buffer for a big buffer\n"));

                NdisMFreeSharedMemory(
                    Adapter->AdapterHandle,
                    pMpTxbuf->AllocSize,
                    TRUE,                           // CACHED
                    pMpTxbuf->AllocVa,   
                    pMpTxbuf->AllocPa);

                break;
            }

            PushEntryList(&Adapter->SendBufList, &pMpTxbuf->SList);

            pMpTxbuf++;
        }

        if (Status != NDIS_STATUS_SUCCESS) break;

        // HW_START

        //
        // Allocate shared memory for send
        // 
        Adapter->HwSendMemAllocSize = Adapter->NumTcb * (sizeof(TXCB_STRUC) + 
                                          NIC_MAX_PHYS_BUF_COUNT * sizeof(TBD_STRUC));

        NdisMAllocateSharedMemory(
            Adapter->AdapterHandle,
            Adapter->HwSendMemAllocSize,
            FALSE,
            (PVOID) &Adapter->HwSendMemAllocVa,
            &Adapter->HwSendMemAllocPa);

        if (!Adapter->HwSendMemAllocVa)
        {
            ErrorValue = ERRLOG_OUT_OF_SHARED_MEMORY;
            DBGPRINT(MP_ERROR, ("Failed to allocate send memory\n"));
            Status = NDIS_STATUS_RESOURCES;
            break;
        }

        NdisZeroMemory(Adapter->HwSendMemAllocVa, Adapter->HwSendMemAllocSize);

        //
        // Allocate shared memory for other uses
        // 
        Adapter->HwMiscMemAllocSize =
            sizeof(SELF_TEST_STRUC) + ALIGN_16 +
            sizeof(DUMP_AREA_STRUC) + ALIGN_16 +
            sizeof(NON_TRANSMIT_CB) + ALIGN_16 +
            sizeof(ERR_COUNT_STRUC) + ALIGN_16;
       
        //
        // Allocate the shared memory for the command block data structures.
        //
        NdisMAllocateSharedMemory(
            Adapter->AdapterHandle,
            Adapter->HwMiscMemAllocSize,
            FALSE,
            (PVOID *) &Adapter->HwMiscMemAllocVa,
            &Adapter->HwMiscMemAllocPa);
        if (!Adapter->HwMiscMemAllocVa)
        {
            ErrorValue = ERRLOG_OUT_OF_SHARED_MEMORY;
            DBGPRINT(MP_ERROR, ("Failed to allocate misc memory\n"));
            Status = NDIS_STATUS_RESOURCES;
            break;
        }

        NdisZeroMemory(Adapter->HwMiscMemAllocVa, Adapter->HwMiscMemAllocSize);

        pMem = Adapter->HwMiscMemAllocVa; 
        MemPhys = NdisGetPhysicalAddressLow(Adapter->HwMiscMemAllocPa);

        Adapter->SelfTest = (PSELF_TEST_STRUC)MP_ALIGNMEM(pMem, ALIGN_16);
        Adapter->SelfTestPhys = MP_ALIGNMEM_PHYS(MemPhys, ALIGN_16);
        pMem = (PUCHAR)Adapter->SelfTest + sizeof(SELF_TEST_STRUC);
        MemPhys = Adapter->SelfTestPhys + sizeof(SELF_TEST_STRUC);

        Adapter->NonTxCmdBlock = (PNON_TRANSMIT_CB)MP_ALIGNMEM(pMem, ALIGN_16);
        Adapter->NonTxCmdBlockPhys = MP_ALIGNMEM_PHYS(MemPhys, ALIGN_16);
        pMem = (PUCHAR)Adapter->NonTxCmdBlock + sizeof(NON_TRANSMIT_CB);
        MemPhys = Adapter->NonTxCmdBlockPhys + sizeof(NON_TRANSMIT_CB);

        Adapter->DumpSpace = (PDUMP_AREA_STRUC)MP_ALIGNMEM(pMem, ALIGN_16);
        Adapter->DumpSpacePhys = MP_ALIGNMEM_PHYS(MemPhys, ALIGN_16);
        pMem = (PUCHAR)Adapter->DumpSpace + sizeof(DUMP_AREA_STRUC);
        MemPhys = Adapter->DumpSpacePhys + sizeof(DUMP_AREA_STRUC);

        Adapter->StatsCounters = (PERR_COUNT_STRUC)MP_ALIGNMEM(pMem, ALIGN_16);
        Adapter->StatsCounterPhys = MP_ALIGNMEM_PHYS(MemPhys, ALIGN_16);

        // HW_END

        //
        // Recv
        //

        NdisInitializeNPagedLookasideList(
            &Adapter->RecvLookaside,
            NULL,
            NULL,
            0,
            sizeof(MP_RFD),
            NIC_TAG, 
            0);

        MP_SET_FLAG(Adapter, fMP_ADAPTER_RECV_LOOKASIDE);

        // set the max number of RFDs
        // disable the RFD grow/shrink scheme if user specifies a NumRfd value 
        // larger than NIC_MAX_GROW_RFDS
        Adapter->MaxNumRfd = max(Adapter->NumRfd, NIC_MAX_GROW_RFDS);
        DBGPRINT(MP_INFO, ("NumRfd = %d\n", Adapter->NumRfd));
        DBGPRINT(MP_INFO, ("MaxNumRfd = %d\n", Adapter->MaxNumRfd));

        //
        // The driver should allocate more data than sizeof(RFD_STRUC) to allow the
        // driver to align the data(after ethernet header) at 8 byte boundary
        //
        Adapter->HwRfdSize = sizeof(RFD_STRUC) + MORE_DATA_FOR_ALIGN;      

        // alloc the recv packet pool

        NdisAllocatePacketPoolEx(
            &Status,
            &Adapter->RecvPacketPool,
            Adapter->NumRfd,
            Adapter->MaxNumRfd,
            sizeof(PVOID) * 4);
        if (Status != NDIS_STATUS_SUCCESS)
        {
            ErrorValue = ERRLOG_OUT_OF_PACKET_POOL;
            break;
        }

        // alloc the buffer pool
        NdisAllocateBufferPool(
            &Status,
            &Adapter->RecvBufferPool,
            Adapter->MaxNumRfd);
        if (Status != NDIS_STATUS_SUCCESS)
        {
            ErrorValue = ERRLOG_OUT_OF_BUFFER_POOL;
            break;
        }
#if OFFLOAD
        //
        // Allocate the shared memory for the offloading packet
        // this miniport use this shared memory when OFFLAOD is on
        // 
        for (i = 0; i < LARGE_SEND_MEM_SIZE_OPTION; i++)
        {
            NdisMAllocateSharedMemory(
                Adapter->AdapterHandle,
                LargeSendSharedMemArray[i],
                FALSE,
                (PVOID *)&(Adapter->OffloadSharedMem.StartVa),
                &(Adapter->OffloadSharedMem.PhyAddr));
            if (Adapter->OffloadSharedMem.StartVa)
            {
                Adapter->OffloadSharedMemSize = LargeSendSharedMemArray[i];
                OffloadSharedMemSuccess = TRUE;
                Adapter->OffloadEnable = TRUE;

                break;
            }
        }
        //
        // The driver cannot allocate the shared memory used by offload, but it should 
        // NOT fail the initialization
        //
        if (OffloadSharedMemSuccess == FALSE)
        {

            DBGPRINT(MP_ERROR, ("Failed to allocate offload used memory\n"));
            Adapter->OffloadEnable = FALSE;
            
        }
#endif

        Status = NDIS_STATUS_SUCCESS;

    } while (FALSE);

    if (Status != NDIS_STATUS_SUCCESS)
    {
        NdisWriteErrorLogEntry(
            Adapter->AdapterHandle,
            NDIS_ERROR_CODE_OUT_OF_RESOURCES,
            1,
            ErrorValue);
    }

    DBGPRINT_S(Status, ("<-- NICAllocMemory, Status=%x\n", Status));

    return Status;

}

VOID NICInitSend(
    IN  PMP_ADAPTER     Adapter)
/*++
Routine Description:

    Initialize send data structures

Arguments:

    Adapter     Pointer to our adapter

Return Value:

    None                                                    

--*/    
{
    PMP_TCB         pMpTcb;
    PHW_TCB         pHwTcb;
    ULONG           HwTcbPhys;
    LONG            TcbCount;

    PTBD_STRUC      pHwTbd;  
    ULONG           HwTbdPhys;     

    DBGPRINT(MP_TRACE, ("--> NICInitSend\n"));

    Adapter->TransmitIdle = TRUE;
    Adapter->ResumeWait = TRUE;

    // Setup the initial pointers to the SW and HW TCB data space
    pMpTcb = (PMP_TCB) Adapter->MpTcbMem;
    pHwTcb = (PHW_TCB) Adapter->HwSendMemAllocVa;
    HwTcbPhys = NdisGetPhysicalAddressLow(Adapter->HwSendMemAllocPa);

    // Setup the initial pointers to the TBD data space.
    // TBDs are located immediately following the TCBs
    pHwTbd = (PTBD_STRUC) (Adapter->HwSendMemAllocVa +
                 (sizeof(TXCB_STRUC) * Adapter->NumTcb));
    HwTbdPhys = HwTcbPhys + (sizeof(TXCB_STRUC) * Adapter->NumTcb);

    // Go through and set up each TCB
    for (TcbCount = 0; TcbCount < Adapter->NumTcb; TcbCount++)
    {
        pMpTcb->HwTcb = pHwTcb;                 // save ptr to HW TCB
        pMpTcb->HwTcbPhys = HwTcbPhys;      // save HW TCB physical address

        pMpTcb->HwTbd = pHwTbd;                 // save ptr to TBD array
        pMpTcb->HwTbdPhys = HwTbdPhys;      // save TBD array physical address

        if (TcbCount)
            pMpTcb->PrevHwTcb = pHwTcb - 1;
        else
            pMpTcb->PrevHwTcb   = (PHW_TCB)((PUCHAR)Adapter->HwSendMemAllocVa +
                                      ((Adapter->NumTcb - 1) * sizeof(HW_TCB)));

        pHwTcb->TxCbHeader.CbStatus = 0;        // clear the status 
        pHwTcb->TxCbHeader.CbCommand = CB_EL_BIT | CB_TX_SF_BIT | CB_TRANSMIT;


        // Set the link pointer in HW TCB to the next TCB in the chain.  
        // If this is the last TCB in the chain, then set it to the first TCB.
        if (TcbCount < Adapter->NumTcb - 1)
        {
            pMpTcb->Next = pMpTcb + 1;
            pHwTcb->TxCbHeader.CbLinkPointer = HwTcbPhys + sizeof(HW_TCB);
        }
        else
        {
            pMpTcb->Next = (PMP_TCB) Adapter->MpTcbMem;
            pHwTcb->TxCbHeader.CbLinkPointer = 
                NdisGetPhysicalAddressLow(Adapter->HwSendMemAllocPa);
        }

        pHwTcb->TxCbThreshold = (UCHAR) Adapter->AiThreshold;
        pHwTcb->TxCbTbdPointer = HwTbdPhys;

        pMpTcb++; 
        pHwTcb++;
        HwTcbPhys += sizeof(TXCB_STRUC);
        pHwTbd = (PTBD_STRUC)((PUCHAR)pHwTbd + sizeof(TBD_STRUC) * NIC_MAX_PHYS_BUF_COUNT);
        HwTbdPhys += sizeof(TBD_STRUC) * NIC_MAX_PHYS_BUF_COUNT;
    }

    // set the TCB head/tail indexes
    // head is the olded one to free, tail is the next one to use
    Adapter->CurrSendHead = (PMP_TCB) Adapter->MpTcbMem;
    Adapter->CurrSendTail = (PMP_TCB) Adapter->MpTcbMem;

    // set the map register head/tail indexes if used
    if (MP_TEST_FLAG(Adapter, fMP_ADAPTER_MAP_REGISTER))
    {
        Adapter->CurrMapRegHead = 0;
        Adapter->CurrMapRegTail = 0;
    }

    DBGPRINT(MP_TRACE, ("<-- NICInitSend, Status=%x\n"));
}

NDIS_STATUS NICInitRecv(
    IN  PMP_ADAPTER     Adapter)
/*++
Routine Description:

    Initialize receive data structures

Arguments:

    Adapter     Pointer to our adapter

Return Value:

    NDIS_STATUS_SUCCESS
    NDIS_STATUS_RESOURCES

--*/    
{
    NDIS_STATUS     Status = NDIS_STATUS_RESOURCES;

    PMP_RFD         pMpRfd;      
    LONG            RfdCount;
    ULONG           ErrorValue = 0;

    DBGPRINT(MP_TRACE, ("--> NICInitRecv\n"));

    // Setup each RFD
    for (RfdCount = 0; RfdCount < Adapter->NumRfd; RfdCount++)
    {
        pMpRfd = NdisAllocateFromNPagedLookasideList(&Adapter->RecvLookaside);
        if (!pMpRfd)
        {
            ErrorValue = ERRLOG_OUT_OF_LOOKASIDE_MEMORY;
            continue;
        }
        //
        // Allocate the shared memory for this RFD.
        //
        NdisMAllocateSharedMemory(
            Adapter->AdapterHandle,
            Adapter->HwRfdSize,
            FALSE,
            &pMpRfd->OriginalHwRfd,
            &pMpRfd->OriginalHwRfdPa);

        if (!pMpRfd->OriginalHwRfd)
        {
            ErrorValue = ERRLOG_OUT_OF_SHARED_MEMORY;
            NdisFreeToNPagedLookasideList(&Adapter->RecvLookaside, pMpRfd);
            continue;
        }
        //
        // Get a 8-byts aligned memory from the original HwRfd
        //
        pMpRfd->HwRfd = (PHW_RFD)DATA_ALIGN(pMpRfd->OriginalHwRfd);
        
        //
        // Now HwRfd is already 8-bytes aligned, and the size of HwPfd header(not data part) is a multiple of 8,
        // If we shift HwRfd 0xA bytes up, the Ethernet header size is 14 bytes long, then the data will be at
        // 8 byte boundary. 
        // 
        pMpRfd->HwRfd = (PHW_RFD)((PUCHAR)(pMpRfd->HwRfd) + HWRFD_SHIFT_OFFSET);
        //
        // Update physical address accordingly
        // 
        pMpRfd->HwRfdPa.QuadPart = pMpRfd->OriginalHwRfdPa.QuadPart + BYTES_SHIFT(pMpRfd->HwRfd, pMpRfd->OriginalHwRfd);


        ErrorValue = NICAllocRfd(Adapter, pMpRfd);
        if (ErrorValue)
        {
            NdisFreeToNPagedLookasideList(&Adapter->RecvLookaside, pMpRfd);
            continue;
        }
        //
        // Add this RFD to the RecvList
        // 
        Adapter->CurrNumRfd++;                      
        NICReturnRFD(Adapter, pMpRfd);
    }

    if (Adapter->CurrNumRfd > NIC_MIN_RFDS)
    {
        Status = NDIS_STATUS_SUCCESS;
    }
    //
    // Adapter->CurrNumRfd < NIC_MIN_RFDs
    //
    if (Status != NDIS_STATUS_SUCCESS)
    {
        NdisWriteErrorLogEntry(
            Adapter->AdapterHandle,
            NDIS_ERROR_CODE_OUT_OF_RESOURCES,
            1,
            ErrorValue);

    }

    DBGPRINT_S(Status, ("<-- NICInitRecv, Status=%x\n", Status));

    return Status;
}

ULONG NICAllocRfd(
    IN  PMP_ADAPTER     Adapter,
    IN  PMP_RFD         pMpRfd)
/*++
Routine Description:

    Allocate NDIS_PACKET and NDIS_BUFFER associated with a RFD

Arguments:

    Adapter     Pointer to our adapter
    pMpRfd      pointer to a RFD

Return Value:

    ERRLOG_OUT_OF_NDIS_PACKET
    ERRLOG_OUT_OF_NDIS_BUFFER

--*/    
{
    NDIS_STATUS         Status;
    PHW_RFD             pHwRfd;    
    ULONG               ErrorValue = 0;

    do
    {
        pHwRfd = pMpRfd->HwRfd;
        pMpRfd->HwRfdPhys = NdisGetPhysicalAddressLow(pMpRfd->HwRfdPa);

        pMpRfd->Flags = 0;
        pMpRfd->NdisPacket = NULL;
        pMpRfd->NdisBuffer = NULL;

        NdisAllocatePacket(
            &Status,
            &pMpRfd->NdisPacket,
            Adapter->RecvPacketPool);
        if (Status != NDIS_STATUS_SUCCESS)
        {
            ASSERT(pMpRfd->NdisPacket == NULL);
            ErrorValue = ERRLOG_OUT_OF_NDIS_PACKET;
            break;
        }

        //
        // point our buffer for receives at this Rfd
        // 
        NdisAllocateBuffer(
            &Status,
            &pMpRfd->NdisBuffer,
            Adapter->RecvBufferPool,
            (PVOID)&pHwRfd->RfdBuffer.RxMacHeader,
            NIC_MAX_PACKET_SIZE);
        if (Status != NDIS_STATUS_SUCCESS)
        {
            ASSERT(pMpRfd->NdisBuffer == NULL);
            ErrorValue = ERRLOG_OUT_OF_NDIS_BUFFER;
            break;
        }

        // Init each RFD header
        pHwRfd->RfdRbdPointer = DRIVER_NULL;
        pHwRfd->RfdSize = NIC_MAX_PACKET_SIZE;

        NDIS_SET_PACKET_HEADER_SIZE(pMpRfd->NdisPacket, NIC_HEADER_SIZE);

        NdisChainBufferAtFront(pMpRfd->NdisPacket, pMpRfd->NdisBuffer);
        //
        // Save ptr to MP_RFD in the packet, used in MPReturnPackets 
        // 
        MP_SET_PACKET_RFD(pMpRfd->NdisPacket, pMpRfd);      


    } while (FALSE);

    if (ErrorValue)
    {
        if (pMpRfd->NdisPacket)
        {
            NdisFreePacket(pMpRfd->NdisPacket);
        }

        if (pMpRfd->HwRfd)
        {
            //
            // Free HwRfd, we need to free the original memory pointed by OriginalHwRfd.
            // 
            NdisMFreeSharedMemory(
                Adapter->AdapterHandle,
                Adapter->HwRfdSize,
                FALSE,
                pMpRfd->OriginalHwRfd,
                pMpRfd->OriginalHwRfdPa);

            pMpRfd->HwRfd = NULL;
            pMpRfd->OriginalHwRfd = NULL;
        }
    }

    return ErrorValue;

}

VOID NICFreeRfd(
    IN  PMP_ADAPTER     Adapter,
    IN  PMP_RFD         pMpRfd)
/*++
Routine Description:

    Free a RFD and assocaited NDIS_PACKET and NDIS_BUFFER

Arguments:

    Adapter     Pointer to our adapter
    pMpRfd      Pointer to a RFD

Return Value:

    None                                                    

--*/    
{
    ASSERT(pMpRfd->NdisBuffer);      
    ASSERT(pMpRfd->NdisPacket);  
    ASSERT(pMpRfd->HwRfd);    

    NdisAdjustBufferLength(pMpRfd->NdisBuffer, NIC_MAX_PACKET_SIZE);
    NdisFreeBuffer(pMpRfd->NdisBuffer);
    NdisFreePacket(pMpRfd->NdisPacket);
    pMpRfd->NdisBuffer = NULL;
    pMpRfd->NdisPacket = NULL;

    //
    // Free HwRfd, we need to free the original memory pointed by OriginalHwRfd.
    // 
    NdisMFreeSharedMemory(
        Adapter->AdapterHandle,
        Adapter->HwRfdSize,
        FALSE,
        pMpRfd->OriginalHwRfd,
        pMpRfd->OriginalHwRfdPa);
    
    pMpRfd->HwRfd = NULL;
    pMpRfd->OriginalHwRfd = NULL;
    
    NdisFreeToNPagedLookasideList(&Adapter->RecvLookaside, pMpRfd);
}


NDIS_STATUS NICSelfTest(
    IN  PMP_ADAPTER     Adapter)
/*++
Routine Description:

    Perform a NIC self-test

Arguments:

    Adapter     Pointer to our adapter

Return Value:

    NDIS_STATUS_SUCCESS
    NDIS_STATUS_DEVICE_FAILED

--*/    
{
    NDIS_STATUS     Status = NDIS_STATUS_SUCCESS;
    ULONG           SelfTestCommandCode;

    DBGPRINT(MP_TRACE, ("--> NICSelfTest\n"));

    DBGPRINT(MP_INFO, ("SelfTest=%x, SelfTestPhys=%x\n", 
        Adapter->SelfTest, Adapter->SelfTestPhys));

    //
    // Issue a software reset to the adapter
    // 
    HwSoftwareReset(Adapter);

    //
    // Execute The PORT Self Test Command On The 82558.
    // 
    ASSERT(Adapter->SelfTestPhys != 0);
    SelfTestCommandCode = Adapter->SelfTestPhys;

    //
    // Setup SELF TEST Command Code in D3 - D0
    // 
    SelfTestCommandCode |= PORT_SELFTEST;

    //
    // Initialize the self-test signature and results DWORDS
    // 
    Adapter->SelfTest->StSignature = 0;
    Adapter->SelfTest->StResults = 0xffffffff;

    //
    // Do the port command
    // 
    Adapter->CSRAddress->Port = SelfTestCommandCode;

    MP_STALL_EXECUTION(NIC_DELAY_POST_SELF_TEST_MS);

    //
    // if The First Self Test DWORD Still Zero, We've timed out.  If the second
    // DWORD is not zero then we have an error.
    // 
    if ((Adapter->SelfTest->StSignature == 0) || (Adapter->SelfTest->StResults != 0))
    {
        DBGPRINT(MP_ERROR, ("StSignature=%x, StResults=%x\n", 
            Adapter->SelfTest->StSignature, Adapter->SelfTest->StResults));

        NdisWriteErrorLogEntry(
            Adapter->AdapterHandle,
            NDIS_ERROR_CODE_HARDWARE_FAILURE,
            1,
            ERRLOG_SELFTEST_FAILED);

        Status = NDIS_STATUS_DEVICE_FAILED;
    }

    DBGPRINT_S(Status, ("<-- NICSelfTest, Status=%x\n", Status));

    return Status;
}

NDIS_STATUS NICInitializeAdapter(
    IN  PMP_ADAPTER     Adapter)
/*++
Routine Description:

    Initialize the adapter and set up everything

Arguments:

    Adapter     Pointer to our adapter

Return Value:

    NDIS_STATUS_SUCCESS
    NDIS_STATUS_HARD_ERRORS

--*/    
{
    NDIS_STATUS     Status;

    DBGPRINT(MP_TRACE, ("--> NICInitializeAdapter\n"));

    do
    {

        // set up our link indication variable
        // it doesn't matter what this is right now because it will be
        // set correctly if link fails
        Adapter->MediaState = NdisMediaStateConnected;

        Adapter->CurrentPowerState = NdisDeviceStateD0;
        Adapter->NextPowerState    = NdisDeviceStateD0;

        // Issue a software reset to the D100
        HwSoftwareReset(Adapter);

        // Load the CU BASE (set to 0, because we use linear mode)
        Adapter->CSRAddress->ScbGeneralPointer = 0;
        Status = D100IssueScbCommand(Adapter, SCB_CUC_LOAD_BASE, FALSE);
        if (Status != NDIS_STATUS_SUCCESS)
        {
            break;
        }

        // Wait for the SCB command word to clear before we set the general pointer
        if (!WaitScb(Adapter))
        {
            Status = NDIS_STATUS_HARD_ERRORS;
            break;
        }

        // Load the RU BASE (set to 0, because we use linear mode)
        Adapter->CSRAddress->ScbGeneralPointer = 0;
        Status = D100IssueScbCommand(Adapter, SCB_RUC_LOAD_BASE, FALSE);
        if (Status != NDIS_STATUS_SUCCESS)
        {
            break;
        }

        // Configure the adapter
        Status = HwConfigure(Adapter);
        if (Status != NDIS_STATUS_SUCCESS)
        {
            break;
        }

        Status = HwSetupIAAddress(Adapter);
        if (Status != NDIS_STATUS_SUCCESS) 
        {
            break;
        }

        // Clear the internal counters
        HwClearAllCounters(Adapter);


    } while (FALSE);
    
    if (Status != NDIS_STATUS_SUCCESS)
    {
        NdisWriteErrorLogEntry(
            Adapter->AdapterHandle,
            NDIS_ERROR_CODE_HARDWARE_FAILURE,
            1,
            ERRLOG_INITIALIZE_ADAPTER);
    }

    DBGPRINT_S(Status, ("<-- NICInitializeAdapter, Status=%x\n", Status));

    return Status;
}    


VOID HwSoftwareReset(
    IN  PMP_ADAPTER     Adapter)
/*++
Routine Description:

    Issue a software reset to the hardware    

Arguments:

    Adapter     Pointer to our adapter

Return Value:

    None                                                    

--*/    
{
    DBGPRINT(MP_TRACE, ("--> HwSoftwareReset\n"));

    // Issue a PORT command with a data word of 0
    Adapter->CSRAddress->Port = PORT_SOFTWARE_RESET;

    // wait after the port reset command
    NdisStallExecution(NIC_DELAY_POST_RESET);

    // Mask off our interrupt line -- its unmasked after reset
    NICDisableInterrupt(Adapter);

    DBGPRINT(MP_TRACE, ("<-- HwSoftwareReset\n"));
}


NDIS_STATUS HwConfigure(
    IN  PMP_ADAPTER     Adapter)
/*++
Routine Description:

    Configure the hardware    

Arguments:

    Adapter     Pointer to our adapter

Return Value:

    NDIS_STATUS_SUCCESS
    NDIS_STATUS_HARD_ERRORS

--*/    
{
    NDIS_STATUS         Status;
    PCB_HEADER_STRUC    NonTxCmdBlockHdr = (PCB_HEADER_STRUC)Adapter->NonTxCmdBlock;
    UINT                i;

    DBGPRINT(MP_TRACE, ("--> HwConfigure\n"));

    //
    // Init the packet filter to nothing.
    //
    Adapter->OldPacketFilter = Adapter->PacketFilter;
    Adapter->PacketFilter = 0;
    
    //
    // Store the current setting for BROADCAST/PROMISCUOS modes
    Adapter->OldParameterField = CB_557_CFIG_DEFAULT_PARM15;
    
    // Setup the non-transmit command block header for the configure command.
    NonTxCmdBlockHdr->CbStatus = 0;
    NonTxCmdBlockHdr->CbCommand = CB_CONFIGURE;
    NonTxCmdBlockHdr->CbLinkPointer = DRIVER_NULL;

    // Fill in the configure command data.

    // First fill in the static (end user can't change) config bytes
    Adapter->NonTxCmdBlock->NonTxCb.Config.ConfigBytes[0] = CB_557_CFIG_DEFAULT_PARM0;
    Adapter->NonTxCmdBlock->NonTxCb.Config.ConfigBytes[2] = CB_557_CFIG_DEFAULT_PARM2;
    Adapter->NonTxCmdBlock->NonTxCb.Config.ConfigBytes[3] = CB_557_CFIG_DEFAULT_PARM3;
    Adapter->NonTxCmdBlock->NonTxCb.Config.ConfigBytes[6] = CB_557_CFIG_DEFAULT_PARM6;
    Adapter->NonTxCmdBlock->NonTxCb.Config.ConfigBytes[9] = CB_557_CFIG_DEFAULT_PARM9;
    Adapter->NonTxCmdBlock->NonTxCb.Config.ConfigBytes[10] = CB_557_CFIG_DEFAULT_PARM10;
    Adapter->NonTxCmdBlock->NonTxCb.Config.ConfigBytes[11] = CB_557_CFIG_DEFAULT_PARM11;
    Adapter->NonTxCmdBlock->NonTxCb.Config.ConfigBytes[12] = CB_557_CFIG_DEFAULT_PARM12;
    Adapter->NonTxCmdBlock->NonTxCb.Config.ConfigBytes[13] = CB_557_CFIG_DEFAULT_PARM13;
    Adapter->NonTxCmdBlock->NonTxCb.Config.ConfigBytes[14] = CB_557_CFIG_DEFAULT_PARM14;
    Adapter->NonTxCmdBlock->NonTxCb.Config.ConfigBytes[16] = CB_557_CFIG_DEFAULT_PARM16;
    Adapter->NonTxCmdBlock->NonTxCb.Config.ConfigBytes[17] = CB_557_CFIG_DEFAULT_PARM17;
    Adapter->NonTxCmdBlock->NonTxCb.Config.ConfigBytes[18] = CB_557_CFIG_DEFAULT_PARM18;
    Adapter->NonTxCmdBlock->NonTxCb.Config.ConfigBytes[20] = CB_557_CFIG_DEFAULT_PARM20;
    Adapter->NonTxCmdBlock->NonTxCb.Config.ConfigBytes[21] = CB_557_CFIG_DEFAULT_PARM21;

    // Now fill in the rest of the configuration bytes (the bytes that contain
    // user configurable parameters).

    // Set the Tx and Rx Fifo limits
    Adapter->NonTxCmdBlock->NonTxCb.Config.ConfigBytes[1] =
        (UCHAR) ((Adapter->AiTxFifo << 4) | Adapter->AiRxFifo);

    if (Adapter->MWIEnable)
    {
        Adapter->NonTxCmdBlock->NonTxCb.Config.ConfigBytes[3] |= CB_CFIG_B3_MWI_ENABLE;
    }

    // Set the Tx and Rx DMA maximum byte count fields.
    if ((Adapter->AiRxDmaCount) || (Adapter->AiTxDmaCount))
    {
        Adapter->NonTxCmdBlock->NonTxCb.Config.ConfigBytes[4] =
            Adapter->AiRxDmaCount;
        Adapter->NonTxCmdBlock->NonTxCb.Config.ConfigBytes[5] =
            (UCHAR) (Adapter->AiTxDmaCount | CB_CFIG_DMBC_EN);
    }
    else
    {
        Adapter->NonTxCmdBlock->NonTxCb.Config.ConfigBytes[4] =
            CB_557_CFIG_DEFAULT_PARM4;
        Adapter->NonTxCmdBlock->NonTxCb.Config.ConfigBytes[5] =
            CB_557_CFIG_DEFAULT_PARM5;
    }


    Adapter->NonTxCmdBlock->NonTxCb.Config.ConfigBytes[7] =
        (UCHAR) ((CB_557_CFIG_DEFAULT_PARM7 & (~CB_CFIG_URUN_RETRY)) |
        (Adapter->AiUnderrunRetry << 1)
        );

    // Setup for MII or 503 operation.  The CRS+CDT bit should only be set
    // when operating in 503 mode.
    if (Adapter->PhyAddress == 32)
    {
        Adapter->NonTxCmdBlock->NonTxCb.Config.ConfigBytes[8] =
            (CB_557_CFIG_DEFAULT_PARM8 & (~CB_CFIG_503_MII));
        Adapter->NonTxCmdBlock->NonTxCb.Config.ConfigBytes[15] =
            (CB_557_CFIG_DEFAULT_PARM15 | CB_CFIG_CRS_OR_CDT);
    }
    else
    {
        Adapter->NonTxCmdBlock->NonTxCb.Config.ConfigBytes[8] =
            (CB_557_CFIG_DEFAULT_PARM8 | CB_CFIG_503_MII);
        Adapter->NonTxCmdBlock->NonTxCb.Config.ConfigBytes[15] =
            ((CB_557_CFIG_DEFAULT_PARM15 & (~CB_CFIG_CRS_OR_CDT)) | CB_CFIG_BROADCAST_DIS);
    }


    // Setup Full duplex stuff

    // If forced to half duplex
    if (Adapter->AiForceDpx == 1)
        Adapter->NonTxCmdBlock->NonTxCb.Config.ConfigBytes[19] =
            (CB_557_CFIG_DEFAULT_PARM19 &
            (~(CB_CFIG_FORCE_FDX| CB_CFIG_FDX_ENABLE)));

    // If forced to full duplex
    else if (Adapter->AiForceDpx == 2)
        Adapter->NonTxCmdBlock->NonTxCb.Config.ConfigBytes[19] =
            (CB_557_CFIG_DEFAULT_PARM19 | CB_CFIG_FORCE_FDX);

    // If auto-duplex
    else
    {
        // We must force full duplex on if we are using PHY 0, and we are
        // supposed to run in FDX mode.  We do this because the D100 has only
        // one FDX# input pin, and that pin will be connected to PHY 1.
        if ((Adapter->PhyAddress == 0) && (Adapter->usDuplexMode == 2))
            Adapter->NonTxCmdBlock->NonTxCb.Config.ConfigBytes[19] =
                (CB_557_CFIG_DEFAULT_PARM19 | CB_CFIG_FORCE_FDX);
        else
            Adapter->NonTxCmdBlock->NonTxCb.Config.ConfigBytes[19] =
            CB_557_CFIG_DEFAULT_PARM19;
    }


    // display the config info to the debugger
    DBGPRINT(MP_INFO, ("   Issuing Configure command\n"));
    DBGPRINT(MP_INFO, ("   Config Block at virt addr "PTR_FORMAT", phys address %x\n",
        &NonTxCmdBlockHdr->CbStatus, Adapter->NonTxCmdBlockPhys));

    for (i=0; i < CB_CFIG_BYTE_COUNT; i++)
        DBGPRINT(MP_INFO, ("   Config byte %x = %.2x\n", 
            i, Adapter->NonTxCmdBlock->NonTxCb.Config.ConfigBytes[i]));

    // Wait for the SCB command word to clear before we set the general pointer
    if (!WaitScb(Adapter))
    {
        Status = NDIS_STATUS_HARD_ERRORS;
    }
    else
    {
        ASSERT(Adapter->CSRAddress->ScbCommandLow == 0)
        Adapter->CSRAddress->ScbGeneralPointer = Adapter->NonTxCmdBlockPhys;
    
        // Submit the configure command to the chip, and wait for it to complete.
        Status = D100SubmitCommandBlockAndWait(Adapter);
    }

    DBGPRINT_S(Status, ("<-- HwConfigure, Status=%x\n", Status));

    return Status;
}


NDIS_STATUS HwSetupIAAddress(
    IN  PMP_ADAPTER     Adapter)
/*++
Routine Description:

    Set up the individual MAC address                             

Arguments:

    Adapter     Pointer to our adapter

Return Value:

    NDIS_STATUS_SUCCESS
    NDIS_SUCCESS_HARD_ERRORS

--*/    
{
    NDIS_STATUS         Status;
    UINT                i;
    PCB_HEADER_STRUC    NonTxCmdBlockHdr = (PCB_HEADER_STRUC)Adapter->NonTxCmdBlock;

    DBGPRINT(MP_TRACE, ("--> HwSetupIAAddress\n"));

    // Individual Address Setup
    NonTxCmdBlockHdr->CbStatus = 0;
    NonTxCmdBlockHdr->CbCommand = CB_IA_ADDRESS;
    NonTxCmdBlockHdr->CbLinkPointer = DRIVER_NULL;

    // Copy in the station's individual address
    for (i = 0; i < ETH_LENGTH_OF_ADDRESS; i++)
        Adapter->NonTxCmdBlock->NonTxCb.Setup.IaAddress[i] = Adapter->CurrentAddress[i];

    // Update the command list pointer.  We don't need to do a WaitSCB here
    // because this command is either issued immediately after a reset, or
    // after another command that runs in polled mode.  This guarantees that
    // the low byte of the SCB command word will be clear.  The only commands
    // that don't run in polled mode are transmit and RU-start commands.
    ASSERT(Adapter->CSRAddress->ScbCommandLow == 0)
    Adapter->CSRAddress->ScbGeneralPointer = Adapter->NonTxCmdBlockPhys;

    // Submit the IA configure command to the chip, and wait for it to complete.
    Status = D100SubmitCommandBlockAndWait(Adapter);

    DBGPRINT_S(Status, ("<-- HwSetupIAAddress, Status=%x\n", Status));

    return Status;
}

NDIS_STATUS HwClearAllCounters(
    IN  PMP_ADAPTER     Adapter)
/*++
Routine Description:

    This routine will clear the hardware error statistic counters
    
Arguments:

    Adapter     Pointer to our adapter

Return Value:

    NDIS_STATUS_SUCCESS
    NDIS_STATUS_HARD_ERRORS

--*/    
{
    NDIS_STATUS     Status;
    BOOLEAN         bResult;

    DBGPRINT(MP_TRACE, ("--> HwClearAllCounters\n"));

    do
    {
        // Load the dump counters pointer.  Since this command is generated only
        // after the IA setup has complete, we don't need to wait for the SCB
        // command word to clear
        ASSERT(Adapter->CSRAddress->ScbCommandLow == 0)
        Adapter->CSRAddress->ScbGeneralPointer = Adapter->StatsCounterPhys;

        // Issue the load dump counters address command
        Status = D100IssueScbCommand(Adapter, SCB_CUC_DUMP_ADDR, FALSE);
        if (Status != NDIS_STATUS_SUCCESS) 
            break;

        // Now dump and reset all of the statistics
        Status = D100IssueScbCommand(Adapter, SCB_CUC_DUMP_RST_STAT, TRUE);
        if (Status != NDIS_STATUS_SUCCESS) 
            break;

        // Now wait for the dump/reset to complete, timeout value 2 secs
        MP_STALL_AND_WAIT(Adapter->StatsCounters->CommandComplete == 0xA007, 2000, bResult);
        if (!bResult)
        {
            MP_SET_HARDWARE_ERROR(Adapter);
            Status = NDIS_STATUS_HARD_ERRORS;
            break;
        }

        // init packet counts
        Adapter->GoodTransmits = 0;
        Adapter->GoodReceives = 0;

        // init transmit error counts
        Adapter->TxAbortExcessCollisions = 0;
        Adapter->TxLateCollisions = 0;
        Adapter->TxDmaUnderrun = 0;
        Adapter->TxLostCRS = 0;
        Adapter->TxOKButDeferred = 0;
        Adapter->OneRetry = 0;
        Adapter->MoreThanOneRetry = 0;
        Adapter->TotalRetries = 0;

        // init receive error counts
        Adapter->RcvCrcErrors = 0;
        Adapter->RcvAlignmentErrors = 0;
        Adapter->RcvResourceErrors = 0;
        Adapter->RcvDmaOverrunErrors = 0;
        Adapter->RcvCdtFrames = 0;
        Adapter->RcvRuntErrors = 0;

    } while (FALSE);

    DBGPRINT_S(Status, ("<-- HwClearAllCounters, Status=%x\n", Status));

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\net\ms\e100bex\offload.h ===
/*++
 
Copyright (c) 2001  Microsoft Corporation

Module Name:
    offload.h

Abstract:
    Task offloading header file

Revision History:
    Who         When        What
    --------    --------    ----------------------------------------------
                            created

Notes:

--*/

#if OFFLOAD
//
//  Define the maximum size of large TCP packets the driver can offload.
//  This sample driver uses shared memory to map the large packets, 
//  LARGE_SEND_OFFLOAD_SIZE is useless in this case, so we just define 
//  it as NIC_MAX_PACKET_SIZE. But shipping drivers should define
//  LARGE_SEND_OFFLOAD_SIZE if they support LSO, and use it as 
//  MaximumPhysicalMapping  when they call NdisMInitializeScatterGatherDma 
//  if they use ScatterGather method. If the drivers don't support
//  LSO, then MaximumPhysicalMapping is NIC_MAX_PACKET_SIZE.
//
#define LARGE_SEND_OFFLOAD_SIZE     NIC_MAX_PACKET_SIZE
//
// Definitions for header flags.
//
#define TCP_FLAG_FIN    0x00000100
#define TCP_FLAG_SYN    0x00000200
#define TCP_FLAG_RST    0x00000400
#define TCP_FLAG_PUSH   0x00000800
#define TCP_FLAG_ACK    0x00001000
#define TCP_FLAG_URG    0x00002000

//
// These are the maximum size of TCP and IP options
// 
#define TCP_MAX_OPTION_SIZE     40
#define IP_MAX_OPTION_SIZE      40

//
// Structure of a TCP packet header.
//
struct TCPHeader {
    USHORT    tcp_src;                // Source port.
    USHORT    tcp_dest;               // Destination port.
    int       tcp_seq;                // Sequence number.
    int       tcp_ack;                // Ack number.
    USHORT    tcp_flags;              // Flags and data offset.
    USHORT    tcp_window;             // Window offered.
    USHORT    tcp_xsum;               // Checksum.
    USHORT    tcp_urgent;             // Urgent pointer.
};

typedef struct TCPHeader TCPHeader;


//
// IP Header format.
//
typedef struct IPHeader {
    UCHAR     iph_verlen;             // Version and length.
    UCHAR     iph_tos;                // Type of service.
    USHORT    iph_length;             // Total length of datagram.
    USHORT    iph_id;                 // Identification.
    USHORT    iph_offset;             // Flags and fragment offset.
    UCHAR     iph_ttl;                // Time to live.
    UCHAR     iph_protocol;           // Protocol.
    USHORT    iph_xsum;               // Header checksum.
    UINT      iph_src;                // Source address.
    UINT      iph_dest;               // Destination address.
} IPHeader;

#define TCP_IP_MAX_HEADER_SIZE  TCP_MAX_OPTION_SIZE+IP_MAX_OPTION_SIZE \
                                +sizeof(TCPHeader)+sizeof(IPHeader)


#define LARGE_SEND_MEM_SIZE_OPTION       3
//
// Try different size of shared memory to use
// 
extern ULONG LargeSendSharedMemArray[];

//
// Compute the checksum
// 
#define XSUM(_TmpXsum, _StartVa, _PacketLength, _Offset)                             \
{                                                                                    \
    PUSHORT  WordPtr = (PUSHORT)((PUCHAR)_StartVa + _Offset);                        \
    ULONG    WordCount = (_PacketLength) >> 1;                                       \
    BOOLEAN  fOddLen = (BOOLEAN)((_PacketLength) & 1);                               \
    while (WordCount--)                                                              \
    {                                                                                \
        _TmpXsum += *WordPtr;                                                        \
        WordPtr++;                                                                   \
    }                                                                                \
    if (fOddLen)                                                                     \
    {                                                                                \
        _TmpXsum += (USHORT)*((PUCHAR)WordPtr);                                      \
    }                                                                                \
    _TmpXsum = (((_TmpXsum >> 16) | (_TmpXsum << 16)) + _TmpXsum) >> 16;             \
}                                                                                        
        

//
// Function prototypes
// 
VOID
e100DumpPkt(
    IN  PNDIS_PACKET Packet
    );

VOID
CalculateChecksum(
    IN  PVOID        StartVa,
    IN  ULONG        PacketLength,
    IN  PNDIS_PACKET pPacket,
    IN  ULONG        IpHdrOffset
    );

VOID
CalculateTcpChecksum(
    IN  PVOID   StartVa,
    IN  ULONG   PacketLength,
    IN  ULONG  IpHdrOffset
    );

VOID
CalculateIpChecksum(
    IN  PUCHAR StartVa,
    IN  ULONG  IpHdrOffset
    );

VOID 
CalculateUdpChecksum(
    IN  PNDIS_PACKET Packet,
    IN  ULONG  IpHdrOffset
    );


VOID
MPOffloadSendPackets(
    IN  NDIS_HANDLE     MiniportAdapterContext,
    IN  PPNDIS_PACKET   PacketArray,
    IN  UINT            NumberOfPackets
    );

NDIS_STATUS 
MpOffloadSendPacket(
    IN  PMP_ADAPTER     Adapter,
    IN  PNDIS_PACKET    Packet,
    IN  BOOLEAN         bFromQueue
    );


VOID 
MP_OFFLOAD_FREE_SEND_PACKET(
    IN  PMP_ADAPTER     Adapter,
    IN  PMP_TCB         pMpTcb
    );

VOID 
DisableOffload(
    IN  PMP_ADAPTER Adapter
    );

#endif // OFFLOAD
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\net\ms\e100bex\mp_main.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:
    mp_main.c

Abstract:
    This module contains NDIS miniport handlers

Revision History:
    Who         When        What
    --------    --------    ----------------------------------------------
    DChen       11-01-99    created

Notes:

--*/

#include "precomp.h"

#if DBG
#define _FILENUMBER     "NIAM"
#endif

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)
#endif


//                 
// Global data for LBFO
//
#if LBFO
LIST_ENTRY g_AdapterList;
NDIS_SPIN_LOCK g_Lock;
#endif

NDIS_STATUS DriverEntry(
    IN  PDRIVER_OBJECT   DriverObject,
    IN  PUNICODE_STRING  RegistryPath
    )
/*++
Routine Description:

Arguments:

    DriverObject    -   pointer to the driver object
    RegistryPath    -   pointer to the driver registry path
     
Return Value:
    
    NDIS_STATUS - the value returned by NdisMRegisterMiniport 
    
--*/
{
    NDIS_STATUS                   Status;
    NDIS_HANDLE                   NdisWrapperHandle;
    NDIS_MINIPORT_CHARACTERISTICS MPChar;

    DBGPRINT(MP_TRACE, ("====> DriverEntry\n"));

    //
    // Notify the NDIS wrapper about this driver, get a NDIS wrapper handle back
    //
    NdisMInitializeWrapper(
        &NdisWrapperHandle,
        DriverObject,
        RegistryPath,
        NULL);

    if (NdisWrapperHandle == NULL)
    {
        Status = NDIS_STATUS_FAILURE;

        DBGPRINT_S(Status, ("<==== DriverEntry failed to InitWrapper, Status=%x\n", Status));
        return Status;
    }

#if LBFO
    //
    // Init the global data
    //
    InitializeListHead(&g_AdapterList);
    NdisAllocateSpinLock(&g_Lock);

    //
    // For regular miniports, there is NO need to have an Unload handler
    // For a LBFO miniport, register an Unload handler for global data cleanup
    // The unload handler has a more global scope, whereas the scope of the 
    // MiniportHalt function is restricted to a particular miniport instance.
    //
    NdisMRegisterUnloadHandler(NdisWrapperHandle, MPUnload);
#endif      

    //
    // Fill in the Miniport characteristics structure with the version numbers 
    // and the entry points for driver-supplied MiniportXxx 
    //
    NdisZeroMemory(&MPChar, sizeof(MPChar));

    MPChar.MajorNdisVersion         = MP_NDIS_MAJOR_VERSION;
    MPChar.MinorNdisVersion         = MP_NDIS_MINOR_VERSION;

    MPChar.CheckForHangHandler      = MPCheckForHang;
    MPChar.DisableInterruptHandler  = NULL;
    MPChar.EnableInterruptHandler   = NULL;
    MPChar.HaltHandler              = MPHalt;
    MPChar.InitializeHandler        = MPInitialize;
    MPChar.QueryInformationHandler  = MPQueryInformation;
    //MPChar.ReconfigureHandler         = NULL;
    MPChar.ResetHandler             = MPReset;
    MPChar.ReturnPacketHandler      = MPReturnPacket;
    
    MPChar.SendPacketsHandler       = MpSendPacketsHandler;
    
    MPChar.SetInformationHandler    = MPSetInformation;
    MPChar.AllocateCompleteHandler  = MPAllocateComplete;
    MPChar.HandleInterruptHandler   = MPHandleInterrupt;
    MPChar.ISRHandler               = MPIsr;

#ifdef NDIS51_MINIPORT
    MPChar.CancelSendPacketsHandler = MPCancelSendPackets;
    MPChar.PnPEventNotifyHandler    = MPPnPEventNotify;
    MPChar.AdapterShutdownHandler   = MPShutdown;
#endif

    DBGPRINT(MP_LOUD, ("Calling NdisMRegisterMiniport...\n"));

    Status = NdisMRegisterMiniport(
                 NdisWrapperHandle,
                 &MPChar,
                 sizeof(NDIS_MINIPORT_CHARACTERISTICS));

    if (Status != NDIS_STATUS_SUCCESS)
    {
        NdisTerminateWrapper(NdisWrapperHandle, NULL);
    }
    DBGPRINT_S(Status, ("<==== DriverEntry, Status=%x\n", Status));

    return Status;
}


NDIS_STATUS MPInitialize(
    OUT PNDIS_STATUS    OpenErrorStatus,
    OUT PUINT           SelectedMediumIndex,
    IN  PNDIS_MEDIUM    MediumArray,
    IN  UINT            MediumArraySize,
    IN  NDIS_HANDLE     MiniportAdapterHandle,
    IN  NDIS_HANDLE     WrapperConfigurationContext
    )
/*++
Routine Description:

    MiniportInitialize handler

Arguments:

    OpenErrorStatus         Not used
    SelectedMediumIndex     Place-holder for what media we are using
    MediumArray             Array of ndis media passed down to us to pick from
    MediumArraySize         Size of the array
    MiniportAdapterHandle   The handle NDIS uses to refer to us
    WrapperConfigurationContext For use by NdisOpenConfiguration

Return Value:

    NDIS_STATUS_SUCCESS unless something goes wrong

--*/
{
    NDIS_STATUS     Status;
    PMP_ADAPTER     Adapter = NULL;
    UINT            index;
    
#if DBG
    LARGE_INTEGER   TS, TD, TE;
#endif

    DBGPRINT(MP_TRACE, ("====> MPInitialize\n"));

#if DBG
    NdisGetCurrentSystemTime(&TS);
#endif    

    do
    {
        //
        // Find the media type we support
        //
        for (index = 0; index < MediumArraySize; ++index)
        {
            if (MediumArray[index] == NIC_MEDIA_TYPE) 
	    {
                break;
            }
        }

        if (index == MediumArraySize)
        {
            DBGPRINT(MP_ERROR, ("Expected media (%x) is not in MediumArray.\n", NIC_MEDIA_TYPE));
            Status = NDIS_STATUS_UNSUPPORTED_MEDIA;
            break;
        }

        *SelectedMediumIndex = index;

        //
        // Allocate MP_ADAPTER structure
        //
        Status = MpAllocAdapterBlock(&Adapter);
        if (Status != NDIS_STATUS_SUCCESS) 
        {
            break;
        }

        Adapter->AdapterHandle = MiniportAdapterHandle;

        //
        // Read the registry parameters
        //
        Status = NICReadRegParameters(
                     Adapter,
                     WrapperConfigurationContext);
        if (Status != NDIS_STATUS_SUCCESS) 
        {
            break;
        }

        //
        // Inform NDIS of the attributes of our adapter.
        // This has to be done before calling NdisMRegisterXxx or NdisXxxx function
        // that depends on the information supplied to NdisMSetAttributesEx
        // e.g. NdisMAllocateMapRegisters 
        // If this is NDIS51 miniport, it should use safe APIs. But if this is NDIS 
        // 5.0, the driver claim to use safe APIs by setting NDIS_ATTRIBUTE_USES_SAFE_BUFFER_APIS
        //
        NdisMSetAttributesEx(
            MiniportAdapterHandle,
            (NDIS_HANDLE) Adapter,
            0,
#ifdef NDIS51_MINIPORT            
            NDIS_ATTRIBUTE_DESERIALIZE | 
            NDIS_ATTRIBUTE_BUS_MASTER,
#else 
            NDIS_ATTRIBUTE_DESERIALIZE | 
            NDIS_ATTRIBUTE_BUS_MASTER | 
            NDIS_ATTRIBUTE_USES_SAFE_BUFFER_APIS, 
#endif               
            NIC_INTERFACE_TYPE);

        //
        // Find the physical adapter
        //
        Status = MpFindAdapter(Adapter, WrapperConfigurationContext);
        if (Status != NDIS_STATUS_SUCCESS)
        {
            break;
        }

        //
        // Map bus-relative IO range to system IO space
        //
        Status = NdisMRegisterIoPortRange(
                     (PVOID *)&Adapter->PortOffset,
                     Adapter->AdapterHandle,
                     Adapter->IoBaseAddress,
                     Adapter->IoRange);
        if (Status != NDIS_STATUS_SUCCESS)
        {
            DBGPRINT(MP_ERROR, ("NdisMRegisterioPortRange failed\n"));
    
            NdisWriteErrorLogEntry(
                Adapter->AdapterHandle,
                NDIS_ERROR_CODE_BAD_IO_BASE_ADDRESS,
                0);
        
            break;
        }
        
        //
        // Read additional info from NIC such as MAC address
        //
        Status = NICReadAdapterInfo(Adapter);
        if (Status != NDIS_STATUS_SUCCESS)
        {
            break;
        }
        
        //
        // Allocate all other memory blocks including shared memory
        //
        Status = NICAllocAdapterMemory(Adapter);
        if (Status != NDIS_STATUS_SUCCESS)
        {
            break;
        }

        //
        // Init send data structures
        //
        NICInitSend(Adapter);

        //
        // Init receive data structures
        //
        Status = NICInitRecv(Adapter);
        if (Status != NDIS_STATUS_SUCCESS)
        {
            break;
        }
        
        // Map bus-relative registers to virtual system-space
        Status = NdisMMapIoSpace(
                     (PVOID *) &(Adapter->CSRAddress),
                     Adapter->AdapterHandle,
                     Adapter->MemPhysAddress,
                     NIC_MAP_IOSPACE_LENGTH);
        if (Status != NDIS_STATUS_SUCCESS)
        {
            DBGPRINT(MP_ERROR, ("NdisMMapIoSpace failed\n"));
    
            NdisWriteErrorLogEntry(
                Adapter->AdapterHandle,
                NDIS_ERROR_CODE_RESOURCE_CONFLICT,
                1,
                ERRLOG_MAP_IO_SPACE);
        
            break;
        }

        DBGPRINT(MP_INFO, ("CSRAddress="PTR_FORMAT"\n", Adapter->CSRAddress));

        //
        // Disable interrupts here which is as soon as possible
        //
        NICDisableInterrupt(Adapter);
                     
        //
        // Register the interrupt
        //
        Status = NdisMRegisterInterrupt(
                     &Adapter->Interrupt,
                     Adapter->AdapterHandle,
                     Adapter->InterruptLevel,
                     Adapter->InterruptLevel,
                     TRUE,       // RequestISR
                     TRUE,       // SharedInterrupt
                     NIC_INTERRUPT_MODE);
        if (Status != NDIS_STATUS_SUCCESS)
        {
            DBGPRINT(MP_ERROR, ("NdisMRegisterInterrupt failed\n"));
    
            NdisWriteErrorLogEntry(
                Adapter->AdapterHandle,
                NDIS_ERROR_CODE_INTERRUPT_CONNECT,
                0);
        
            break;
        }
        
        MP_SET_FLAG(Adapter, fMP_ADAPTER_INTERRUPT_IN_USE);

        //
        // Test our adapter hardware
        //
        Status = NICSelfTest(Adapter);
        if (Status != NDIS_STATUS_SUCCESS)
        {
            break;
        }
        
        //
        // Init the hardware and set up everything
        //
        Status = NICInitializeAdapter(Adapter);
        if (Status != NDIS_STATUS_SUCCESS)
        {
            break;
        }
        
#ifdef NDIS50_MINIPORT
        //
        // Register a shutdown handler for NDIS50 or earlier miniports
        // For NDIS51 miniports, set AdapterShutdownHandler as shown above
        //
        NdisMRegisterAdapterShutdownHandler(
            Adapter->AdapterHandle,
            (PVOID) Adapter,
            (ADAPTER_SHUTDOWN_HANDLER) MPShutdown);
#endif         

        //
        // Enable the interrupt
        //
        NICEnableInterrupt(Adapter);

        //
        // Minimize init-time
        //
        NdisMInitializeTimer(
            &Adapter->LinkDetectionTimer, 
            Adapter->AdapterHandle,
            MpLinkDetectionDpc, 
            Adapter);

        //
        // Set the link detection flag
        //
        MP_SET_FLAG(Adapter, fMP_ADAPTER_LINK_DETECTION);

        //
        // Increment the reference count so halt handler will wait 
        //
        MP_INC_REF(Adapter);
        NdisMSetTimer(&Adapter->LinkDetectionTimer, NIC_LINK_DETECTION_DELAY);
        
#if LBFO
        //
        // Add this adapter to the global miniport list
        //
        MpAddAdapterToList(Adapter);
#endif

    } while (FALSE);

    if (Adapter && Status != NDIS_STATUS_SUCCESS)
    {
        //
        // Undo everything if it failed
        //
        MP_DEC_REF(Adapter);
        MpFreeAdapter(Adapter);
    }

    
#if DBG
    NdisGetCurrentSystemTime(&TE);
    TD.QuadPart = TE.QuadPart - TS.QuadPart;
    TD.QuadPart /= 10000;       // Convert to ms
    DBGPRINT(MP_WARN, ("Init time = %d ms\n", TD.LowPart));
#endif    
    
    DBGPRINT_S(Status, ("<==== MPInitialize, Status=%x\n", Status));
    //
    // Ndis doesn't check OpenErrorStatus.
    //
    *OpenErrorStatus = Status;
    
    return Status;
}


BOOLEAN MPCheckForHang(
    IN  NDIS_HANDLE     MiniportAdapterContext
    )
/*++

Routine Description:
    
    MiniportCheckForHang handler
    
Arguments:

    MiniportAdapterContext  Pointer to our adapter

Return Value:

    TRUE    This NIC needs a reset
    FALSE   Everything is fine

Note: 
    CheckForHang handler is called in the context of a timer DPC. 
    take advantage of this fact when acquiring/releasing spinlocks

--*/
{
    PMP_ADAPTER         Adapter = (PMP_ADAPTER) MiniportAdapterContext;
    NDIS_MEDIA_STATE    CurrMediaState;
    NDIS_STATUS         Status;
    PMP_TCB             pMpTcb;
    
    //
    // Just skip this part if the adapter is doing link detection
    //
    if (MP_TEST_FLAG(Adapter, fMP_ADAPTER_LINK_DETECTION))
    {
        return(FALSE);   
    }

    //
    // any nonrecoverable hardware error?
    //
    if (MP_TEST_FLAG(Adapter, fMP_ADAPTER_NON_RECOVER_ERROR))
    {
        DBGPRINT(MP_WARN, ("Non recoverable error - remove\n"));
        return (TRUE);
    }
            
    //
    // hardware failure?
    //
    if (MP_TEST_FLAG(Adapter, fMP_ADAPTER_HARDWARE_ERROR))
    {
        DBGPRINT(MP_WARN, ("hardware error - reset\n"));
        return(TRUE);
    }
          
    //
    // Is send stuck?                  
    //
    
    NdisDprAcquireSpinLock(&Adapter->SendLock);

    if (Adapter->nBusySend > 0)
    {
        pMpTcb = Adapter->CurrSendHead;
        pMpTcb->Count++;
        if (pMpTcb->Count > NIC_SEND_HANG_THRESHOLD)
        {
            NdisDprReleaseSpinLock(&Adapter->SendLock);
            DBGPRINT(MP_WARN, ("Send stuck - reset\n"));
            return(TRUE);
        }
    }
    
    NdisDprReleaseSpinLock(&Adapter->SendLock);
    NdisDprAcquireSpinLock(&Adapter->RcvLock);

    //
    // Update the RFD shrink count                                          
    //
    if (Adapter->CurrNumRfd > Adapter->NumRfd)
    {
        Adapter->RfdShrinkCount++;          
    }



    NdisDprReleaseSpinLock(&Adapter->RcvLock);
    NdisDprAcquireSpinLock(&Adapter->Lock);
    CurrMediaState = NICGetMediaState(Adapter);

    if (CurrMediaState != Adapter->MediaState)
    {
        DBGPRINT(MP_WARN, ("Media state changed to %s\n",
            ((CurrMediaState == NdisMediaStateConnected)? 
            "Connected": "Disconnected")));

        Adapter->MediaState = CurrMediaState;
        Status = (CurrMediaState == NdisMediaStateConnected) ? 
                 NDIS_STATUS_MEDIA_CONNECT : NDIS_STATUS_MEDIA_DISCONNECT;          
        if (Status == NDIS_STATUS_MEDIA_CONNECT)
        {
            MP_CLEAR_FLAG(Adapter, fMP_ADAPTER_NO_CABLE);
        }
        else
        {
            MP_SET_FLAG(Adapter, fMP_ADAPTER_NO_CABLE);
        }
        
        NdisDprReleaseSpinLock(&Adapter->Lock);
        
        // Indicate the media event
        NdisMIndicateStatus(Adapter->AdapterHandle, Status, (PVOID)0, 0);

        NdisMIndicateStatusComplete(Adapter->AdapterHandle);
    }
    else
    {
        NdisDprReleaseSpinLock(&Adapter->Lock);
    }
    return(FALSE);
}


VOID MPHalt(
    IN  NDIS_HANDLE     MiniportAdapterContext)
/*++

Routine Description:
    
    MiniportHalt handler
    
Arguments:

    MiniportAdapterContext  Pointer to our adapter

Return Value:

    None
    
--*/
{
    LONG            Count;

    PMP_ADAPTER     Adapter = (PMP_ADAPTER) MiniportAdapterContext;
    
    MP_SET_FLAG(Adapter, fMP_ADAPTER_HALT_IN_PROGRESS);
                                           
    DBGPRINT(MP_TRACE, ("====> MPHalt\n"));

    //
    // Call Shutdown handler to disable interrupt and turn the hardware off 
    // by issuing a full reset
    //
    MPShutdown(MiniportAdapterContext);
    
    //
    // Deregister interrupt as early as possible
    //
    if (MP_TEST_FLAG(Adapter, fMP_ADAPTER_INTERRUPT_IN_USE))
    {
        NdisMDeregisterInterrupt(&Adapter->Interrupt);                           
        MP_CLEAR_FLAG(Adapter, fMP_ADAPTER_INTERRUPT_IN_USE);
    }

#if LBFO
    MpRemoveAdapterFromList(Adapter);

    //
    // For a regualr miniport, no send packets and OID requests should be outstanding 
    // when Halt handler is called. But for a LBFO miniport in secondary mode, 
    // some packets from primary miniport may be still around
    //

    NdisAcquireSpinLock(&Adapter->SendLock);
              
    //
    // Free the packets on SendWaitList                                                           
    //
    MpFreeQueuedSendPackets(Adapter);

    //
    // Free the packets being actively sent & stopped
    //
    MpFreeBusySendPackets(Adapter);
    
    NdisReleaseSpinLock(&Adapter->SendLock);

#endif

    //
    // Decrement the ref count which was incremented in MPInitialize
    //
    Count = MP_DEC_REF(Adapter);

    //
    // Possible non-zero ref counts mean one or more of the following conditions: 
    // 1) Pending async shared memory allocation;
    // 2) DPC's are not finished (e.g. link detection)
    //
    if (Count)
    {
        DBGPRINT(MP_WARN, ("RefCount=%d --- waiting!\n", MP_GET_REF(Adapter)));

        while (TRUE)
        {
            if (NdisWaitEvent(&Adapter->ExitEvent, 2000))
            {
                break;
            }

            DBGPRINT(MP_WARN, ("RefCount=%d --- rewaiting!\n", MP_GET_REF(Adapter)));
        }
    }
    
    NdisAcquireSpinLock(&Adapter->RcvLock);
    //
    // wait for all the received packets to return
    //
    MP_DEC_RCV_REF(Adapter);
    Count = MP_GET_RCV_REF(Adapter);
    
    NdisReleaseSpinLock(&Adapter->RcvLock);

    if (Count)
    {
        DBGPRINT(MP_WARN, ("RcvRefCount=%d --- waiting!\n", Count));

        while (TRUE)
        {
            if (NdisWaitEvent(&Adapter->AllPacketsReturnedEvent, 2000))
            {
                break;
            }

            DBGPRINT(MP_WARN, ("RcvRefCount=%d --- rewaiting!\n", MP_GET_RCV_REF(Adapter)));
        }
    }
        

#ifdef NDIS50_MINIPORT
    //
    // Deregister shutdown handler as it's being halted
    //
    NdisMDeregisterAdapterShutdownHandler(Adapter->AdapterHandle);
#endif   

    //
    // Reset the PHY chip.  We do this so that after a warm boot, the PHY will
    // be in a known state, with auto-negotiation enabled.
    //
    ResetPhy(Adapter);

    //
    // Free the entire adapter object, including the shared memory structures.
    //
    MpFreeAdapter(Adapter);

    DBGPRINT(MP_TRACE, ("<==== MPHalt\n"));
}

NDIS_STATUS MPReset(
    OUT PBOOLEAN        AddressingReset,
    IN  NDIS_HANDLE     MiniportAdapterContext)
/*++

Routine Description:
    
    MiniportReset handler
    
Arguments:

    AddressingReset         To let NDIS know whether we need help from it with our reset
    MiniportAdapterContext  Pointer to our adapter

Return Value:

    NDIS_STATUS_SUCCESS
    NDIS_STATUS_PENDING
    NDIS_STATUS_RESET_IN_PROGRESS
    NDIS_STATUS_HARD_ERRORS

Note:
    ResetHandler is called at DPC. take advantage of this fact when acquiring or releasing
    spinlocks
    
--*/
{
    NDIS_STATUS     Status;
    
    PMP_ADAPTER     Adapter = (PMP_ADAPTER) MiniportAdapterContext;

    DBGPRINT(MP_TRACE, ("====> MPReset\n"));

    *AddressingReset = TRUE;

    NdisDprAcquireSpinLock(&Adapter->Lock);
    NdisDprAcquireSpinLock(&Adapter->SendLock);
    NdisDprAcquireSpinLock(&Adapter->RcvLock);

    do
    {
        ASSERT(!MP_TEST_FLAG(Adapter, fMP_ADAPTER_HALT_IN_PROGRESS));
  
        //
        // Is this adapter already doing a reset?
        //
        if (MP_TEST_FLAG(Adapter, fMP_ADAPTER_RESET_IN_PROGRESS))
        {
            Status = NDIS_STATUS_RESET_IN_PROGRESS;
            MP_EXIT;
        }

        MP_SET_FLAG(Adapter, fMP_ADAPTER_RESET_IN_PROGRESS);

        //
        // Is this adapter doing link detection?                                      
        //
        if (MP_TEST_FLAG(Adapter, fMP_ADAPTER_LINK_DETECTION))
        {
            DBGPRINT(MP_WARN, ("Reset is pended...\n"));
        
            Adapter->bResetPending = TRUE;
            Status = NDIS_STATUS_PENDING;
            MP_EXIT;
        }
        //
        // Is this adapter going to be removed
        //
        if (MP_TEST_FLAG(Adapter, fMP_ADAPTER_NON_RECOVER_ERROR))
        {
           Status = NDIS_STATUS_HARD_ERRORS;
           if (MP_TEST_FLAG(Adapter, fMP_ADAPTER_REMOVE_IN_PROGRESS))
           {
               MP_EXIT;
           }
                      
           // This is an unrecoverable hardware failure. 
           // We need to tell NDIS to remove this miniport
           MP_SET_FLAG(Adapter, fMP_ADAPTER_REMOVE_IN_PROGRESS);
           MP_CLEAR_FLAG(Adapter, fMP_ADAPTER_RESET_IN_PROGRESS);
           
           NdisDprReleaseSpinLock(&Adapter->RcvLock);
           NdisDprReleaseSpinLock(&Adapter->SendLock);
           NdisDprReleaseSpinLock(&Adapter->Lock);
           
           NdisWriteErrorLogEntry(
               Adapter->AdapterHandle,
               NDIS_ERROR_CODE_HARDWARE_FAILURE,
               1,
               ERRLOG_REMOVE_MINIPORT);
           
           NdisMRemoveMiniport(Adapter->AdapterHandle);
           
           DBGPRINT_S(Status, ("<==== MPReset, Status=%x\n", Status));
            
           return Status;
        }   
                

        //
        // Disable the interrupt and issue a reset to the NIC
        //
        NICDisableInterrupt(Adapter);
        NICIssueSelectiveReset(Adapter);


        //
        // release all the locks and then acquire back the send lock
        // we are going to clean up the send queues
        // which may involve calling Ndis APIs
        // release all the locks before grabbing the send lock to
        // avoid deadlocks
        //
        NdisDprReleaseSpinLock(&Adapter->RcvLock);
        NdisDprReleaseSpinLock(&Adapter->SendLock);
        NdisDprReleaseSpinLock(&Adapter->Lock);
        
        NdisDprAcquireSpinLock(&Adapter->SendLock);


        //
        // This is a deserialized miniport, we need to free all the send packets
        // Free the packets on SendWaitList                                                           
        //
        MpFreeQueuedSendPackets(Adapter);

        //
        // Free the packets being actively sent & stopped
        //
        MpFreeBusySendPackets(Adapter);

#if DBG
        if (MP_GET_REF(Adapter) > 1)
        {
            DBGPRINT(MP_WARN, ("RefCount=%d\n", MP_GET_REF(Adapter)));
        }
#endif

        NdisZeroMemory(Adapter->MpTcbMem, Adapter->MpTcbMemSize);

        //
        // Re-initialize the send structures
        //
        NICInitSend(Adapter);
        
        NdisDprReleaseSpinLock(&Adapter->SendLock);

        //
        // get all the locks again in the right order
        //
        NdisDprAcquireSpinLock(&Adapter->Lock);
        NdisDprAcquireSpinLock(&Adapter->SendLock);
        NdisDprAcquireSpinLock(&Adapter->RcvLock);

        //
        // Reset the RFD list and re-start RU         
        //
        NICResetRecv(Adapter);
        Status = NICStartRecv(Adapter);
        if (Status != NDIS_STATUS_SUCCESS) 
        {
            // Are we having failures in a few consecutive resets?                  
            if (Adapter->HwErrCount < NIC_HARDWARE_ERROR_THRESHOLD)
            {
                // It's not over the threshold yet, let it to continue
                Adapter->HwErrCount++;
            }
            else
            {
                // This is an unrecoverable hardware failure. 
                // We need to tell NDIS to remove this miniport
                MP_SET_FLAG(Adapter, fMP_ADAPTER_REMOVE_IN_PROGRESS);
                MP_CLEAR_FLAG(Adapter, fMP_ADAPTER_RESET_IN_PROGRESS);
                
                NdisDprReleaseSpinLock(&Adapter->RcvLock);
                NdisDprReleaseSpinLock(&Adapter->SendLock);
                NdisDprReleaseSpinLock(&Adapter->Lock);
                
                NdisWriteErrorLogEntry(
                    Adapter->AdapterHandle,
                    NDIS_ERROR_CODE_HARDWARE_FAILURE,
                    1,
                    ERRLOG_REMOVE_MINIPORT);
                     
                NdisMRemoveMiniport(Adapter->AdapterHandle);
                
                DBGPRINT_S(Status, ("<==== MPReset, Status=%x\n", Status));
                return(Status);
            }
            
            break;
        }
        
        Adapter->HwErrCount = 0;
        MP_CLEAR_FLAG(Adapter, fMP_ADAPTER_HARDWARE_ERROR);

        NICEnableInterrupt(Adapter);

    } while (FALSE);

    MP_CLEAR_FLAG(Adapter, fMP_ADAPTER_RESET_IN_PROGRESS);

    exit:

    NdisDprReleaseSpinLock(&Adapter->RcvLock);
    NdisDprReleaseSpinLock(&Adapter->SendLock);
    NdisDprReleaseSpinLock(&Adapter->Lock);



    DBGPRINT_S(Status, ("<==== MPReset, Status=%x\n", Status));
    return(Status);
}

VOID MPReturnPacket(
    IN  NDIS_HANDLE     MiniportAdapterContext,
    IN  PNDIS_PACKET    Packet
    )
/*++

Routine Description:
    
    MiniportReturnPacket handler
    
Arguments:

    MiniportAdapterContext  Pointer to our adapter
    Packet                  Pointer to a packet being returned to the miniport

Return Value:

    None

Note:
    ReturnPacketHandler is called at DPC. take advantage of this fact when acquiring or releasing
    spinlocks
    
--*/
{
    PMP_ADAPTER     Adapter = (PMP_ADAPTER)MiniportAdapterContext;
    PMP_RFD         pMpRfd = MP_GET_PACKET_RFD(Packet);
    ULONG           Count;

    DBGPRINT(MP_TRACE, ("====> MPReturnPacket\n"));

    ASSERT(pMpRfd);

    ASSERT(MP_TEST_FLAG(pMpRfd, fMP_RFD_RECV_PEND));
    MP_CLEAR_FLAG(pMpRfd, fMP_RFD_RECV_PEND);

    NdisDprAcquireSpinLock(&Adapter->RcvLock);

    RemoveEntryList((PLIST_ENTRY)pMpRfd);


    // Decrement the Power Mgmt Ref.
    Adapter->PoMgmt.OutstandingRecv --;
    //
    // If we have set power pending, then complete it
    // 
    if (((Adapter->bSetPending == TRUE) 
            && (Adapter->SetRequest.Oid == OID_PNP_SET_POWER))
            && (Adapter->PoMgmt.OutstandingRecv == 0))
    {
        MpSetPowerLowComplete(Adapter);
    }

    if (Adapter->RfdShrinkCount < NIC_RFD_SHRINK_THRESHOLD)
    {
        NICReturnRFD(Adapter, pMpRfd);
    }
    else
    {
        ASSERT(Adapter->CurrNumRfd > Adapter->NumRfd);

        Adapter->RfdShrinkCount = 0;
        NICFreeRfd(Adapter, pMpRfd);
        Adapter->CurrNumRfd--;

        DBGPRINT(MP_TRACE, ("Shrink... CurrNumRfd = %d\n", Adapter->CurrNumRfd));
    }


    //
    // note that we get the ref count here, but check
    // to see if it is zero and signal the event -after-
    // releasign the SpinLock. otherwise, we may let the Halthandler
    // continue while we are holding a lock.
    //
    MP_DEC_RCV_REF(Adapter);
    Count =  MP_GET_RCV_REF(Adapter);

    NdisDprReleaseSpinLock(&Adapter->RcvLock);

    if (Count == 0)
        NdisSetEvent(&Adapter->AllPacketsReturnedEvent);

    DBGPRINT(MP_TRACE, ("<==== MPReturnPacket\n"));
}


VOID MPSendPackets(
    IN  NDIS_HANDLE     MiniportAdapterContext,
    IN  PPNDIS_PACKET   PacketArray,
    IN  UINT            NumberOfPackets)
/*++

Routine Description:
    
    MiniportSendPackets handler
    
Arguments:

    MiniportAdapterContext  Pointer to our adapter
    PacketArray             Set of packets to send
    NumberOfPackets         Self-explanatory

Return Value:

    None

--*/
{
    PMP_ADAPTER     Adapter;
    NDIS_STATUS     Status;
    UINT            PacketCount;

    
#if LBFO
    PMP_ADAPTER     ThisAdapter;
#endif

    DBGPRINT(MP_TRACE, ("====> MPSendPackets\n"));

    Adapter = (PMP_ADAPTER)MiniportAdapterContext;

#if LBFO
    NdisAcquireSpinLock(&Adapter->LockLBFO);
    
    // Any secondary adapters?
    if (Adapter->NumSecondary)
    {
        // In this sample driver, we do very simple load balancing ...
        // Walk through the secondary miniport list, send the packets on a secondary 
        // miniport if it's ready
        // If none of the secondary miniports is ready, we'll use the primary miniport
        ThisAdapter = Adapter->NextSecondary; 
        while (ThisAdapter)
        {
            if (MP_IS_NOT_READY(ThisAdapter))
            {
                ThisAdapter = ThisAdapter->NextSecondary;
                continue;
            }
            
            //
            // Found a good secondary miniport to send packets on
            // Need to put a ref on this adapter so it won't go away
            //
            MP_LBFO_INC_REF(ThisAdapter);        
            NdisReleaseSpinLock(&Adapter->LockLBFO);
            
            NdisAcquireSpinLock(&ThisAdapter->SendLock);
        
            //
            // Send these packets      
            //
            for (PacketCount=0;PacketCount < NumberOfPackets; PacketCount++)
            {
                MpSendPacket(ThisAdapter, PacketArray[PacketCount], FALSE);
            }
            
            NdisReleaseSpinLock(&ThisAdapter->SendLock);

            //
            // Done with this adapter for now, deref it            
            //
            MP_LBFO_DEC_REF(ThisAdapter);        
            
            //
            // Sent all the packets on a secondary miniport, return
            //
            return;
        }
    }

    NdisReleaseSpinLock(&Adapter->LockLBFO);
    
#endif

    NdisAcquireSpinLock(&Adapter->SendLock);

    // Is this adapter ready for sending?
    if (MP_IS_NOT_READY(Adapter))
    {
        //
        // there  is link
        //
        if (MP_TEST_FLAG(Adapter, fMP_ADAPTER_LINK_DETECTION))
        {
            for (PacketCount = 0; PacketCount < NumberOfPackets; PacketCount++)
            {
                
                InsertTailQueue(&Adapter->SendWaitQueue, 
                    MP_GET_PACKET_MR(PacketArray[PacketCount]));
                Adapter->nWaitSend++;
                DBGPRINT(MP_WARN, ("MpSendPackets: link detection - queue packet "PTR_FORMAT"\n", 
                    PacketArray[PacketCount]));
            }
            NdisReleaseSpinLock(&Adapter->SendLock);
            return;
        }
        
        //
        // Adapter is not ready and there is not link
        //
        Status = MP_GET_STATUS_FROM_FLAGS(Adapter);

        NdisReleaseSpinLock(&Adapter->SendLock);

        for (PacketCount = 0; PacketCount < NumberOfPackets; PacketCount++)
        {
            NdisMSendComplete(
                MP_GET_ADAPTER_HANDLE(Adapter),
                PacketArray[PacketCount],
                Status);
        }

        return;
    }

    //
    // Adapter is ready, send these packets      
    //
    for (PacketCount = 0; PacketCount < NumberOfPackets; PacketCount++)
    {
        //
        // queue is not empty or tcb is not available 
        //
        if (!IsQueueEmpty(&Adapter->SendWaitQueue) || 
            !MP_TCB_RESOURCES_AVAIABLE(Adapter))
        {
            InsertTailQueue(&Adapter->SendWaitQueue, MP_GET_PACKET_MR(PacketArray[PacketCount]));
            Adapter->nWaitSend++;
        }
        else
        {
            MpSendPacket(Adapter, PacketArray[PacketCount], FALSE);
        }
    }

    NdisReleaseSpinLock(&Adapter->SendLock);

    DBGPRINT(MP_TRACE, ("<==== MPSendPackets\n"));

    return;
}

VOID MPShutdown(
    IN  NDIS_HANDLE     MiniportAdapterContext)
/*++

Routine Description:
    
    MiniportShutdown handler
    
Arguments:

    MiniportAdapterContext  Pointer to our adapter

Return Value:

    None
    
--*/
{
    PMP_ADAPTER     Adapter = (PMP_ADAPTER)MiniportAdapterContext;

    DBGPRINT(MP_TRACE, ("====> MPShutdown\n"));

    //
    // Disable interrupt and issue a full reset
    //
    NICDisableInterrupt(Adapter);
    NICIssueFullReset(Adapter);

    DBGPRINT(MP_TRACE, ("<==== MPShutdown\n"));
}

VOID MPAllocateComplete(
    IN  NDIS_HANDLE             MiniportAdapterContext,
    IN  PVOID                   VirtualAddress,
    IN  PNDIS_PHYSICAL_ADDRESS  PhysicalAddress,
    IN  ULONG                   Length,
    IN  PVOID                   Context)
/*++

Routine Description:
    
    MiniportAllocateComplete handler
    This handler is needed because we make calls to NdisMAllocateSharedMemoryAsync
    
Arguments:

    MiniportAdapterContext  Pointer to our adapter
    VirtualAddress          Pointer to the allocated memory block 
    PhysicalAddress         Physical address of the memory block       
    Length                  Length of the memory block                
    Context                 Context in NdisMAllocateSharedMemoryAsync              

Return Value:

    None
    
--*/
{
    ULONG           ErrorValue;
    PMP_ADAPTER     Adapter = (PMP_ADAPTER)MiniportAdapterContext;
    PMP_RFD         pMpRfd = (PMP_RFD)Context;


#if !DBG
    UNREFERENCED_PARAMETER(Length);
#endif

    DBGPRINT(MP_TRACE, ("==== MPAllocateComplete\n"));

    ASSERT(pMpRfd);
    ASSERT(MP_TEST_FLAG(pMpRfd, fMP_RFD_ALLOC_PEND));
    MP_CLEAR_FLAG(pMpRfd, fMP_RFD_ALLOC_PEND);

    NdisAcquireSpinLock(&Adapter->RcvLock);

    //
    // Is allocation successful?  
    //
    if (VirtualAddress)
    {
        ASSERT(Length == Adapter->HwRfdSize);
        
        pMpRfd->OriginalHwRfd = (PHW_RFD)VirtualAddress;
        pMpRfd->OriginalHwRfdPa = *PhysicalAddress;

        //
        // First get a HwRfd at 8 byte boundary from OriginalHwRfd
        // 
        pMpRfd->HwRfd = (PHW_RFD)DATA_ALIGN(pMpRfd->OriginalHwRfd);
        //
        // Then shift HwRfd so that the data(after ethernet header) is at 8 bytes boundary
        //
        pMpRfd->HwRfd = (PHW_RFD)((PUCHAR)pMpRfd->HwRfd + HWRFD_SHIFT_OFFSET);
        //
        // Update physical address as well
        // 
        pMpRfd->HwRfdPa.QuadPart = pMpRfd->OriginalHwRfdPa.QuadPart + BYTES_SHIFT(pMpRfd->HwRfd, pMpRfd->OriginalHwRfd);

        ErrorValue = NICAllocRfd(Adapter, pMpRfd);
        if (ErrorValue == 0)
        {
            // Add this RFD to the RecvList
            Adapter->CurrNumRfd++;                      
            NICReturnRFD(Adapter, pMpRfd);

            ASSERT(Adapter->CurrNumRfd <= Adapter->MaxNumRfd);
            DBGPRINT(MP_TRACE, ("CurrNumRfd=%d\n", Adapter->CurrNumRfd));
        }
        else
        {
            NdisFreeToNPagedLookasideList(&Adapter->RecvLookaside, pMpRfd);
        }
    }
    else
    {
        NdisFreeToNPagedLookasideList(&Adapter->RecvLookaside, pMpRfd);
    }

    Adapter->bAllocNewRfd = FALSE;
    MP_DEC_REF(Adapter);

    if (MP_GET_REF(Adapter) == 0)
    {
        NdisSetEvent(&Adapter->ExitEvent);
    }

    NdisReleaseSpinLock(&Adapter->RcvLock);
}

VOID MPIsr(
    OUT PBOOLEAN        InterruptRecognized,
    OUT PBOOLEAN        QueueMiniportHandleInterrupt,
    IN  NDIS_HANDLE     MiniportAdapterContext)
/*++

Routine Description:
    
    MiniportIsr handler
    
Arguments:

    InterruptRecognized             TRUE on return if the interrupt comes from this NIC    
    QueueMiniportHandleInterrupt    TRUE on return if MiniportHandleInterrupt should be called
    MiniportAdapterContext          Pointer to our adapter

Return Value:

    None
    
--*/
{
    PMP_ADAPTER  Adapter = (PMP_ADAPTER)MiniportAdapterContext;
    USHORT       IntStatus;

    DBGPRINT(MP_LOUD, ("====> MPIsr\n"));
    
    do 
    {
        //
        // If the adapter is in low power state, then it should not 
        // recognize any interrupt
        // 
        if (Adapter->CurrentPowerState > NdisDeviceStateD0)
        {
            *InterruptRecognized = FALSE;
            *QueueMiniportHandleInterrupt = FALSE;
            break;
        }
        //
        // We process the interrupt if it's not disabled and it's active                  
        //
        if (!NIC_INTERRUPT_DISABLED(Adapter) && NIC_INTERRUPT_ACTIVE(Adapter))
        {
            *InterruptRecognized = TRUE;
            *QueueMiniportHandleInterrupt = TRUE;
        
            //
            // Disable the interrupt (will be re-enabled in MPHandleInterrupt
            //
            NICDisableInterrupt(Adapter);
                
            //
            // Acknowledge the interrupt(s) and get the interrupt status
            //

            NIC_ACK_INTERRUPT(Adapter, IntStatus);
        }
        else
        {
            *InterruptRecognized = FALSE;
            *QueueMiniportHandleInterrupt = FALSE;
        }
    }
    while (FALSE);    

    DBGPRINT(MP_LOUD, ("<==== MPIsr\n"));
}


VOID MPHandleInterrupt(
    IN  NDIS_HANDLE  MiniportAdapterContext
    )
/*++

Routine Description:
    
    MiniportHandleInterrupt handler
    
Arguments:

    MiniportAdapterContext  Pointer to our adapter

Return Value:

    None
    
--*/
{
    PMP_ADAPTER  Adapter = (PMP_ADAPTER)MiniportAdapterContext;
    
    
    NdisDprAcquireSpinLock(&Adapter->RcvLock);

    MpHandleRecvInterrupt(Adapter);

    NdisDprReleaseSpinLock(&Adapter->RcvLock);
    
    //
    // Handle send interrupt    
    //
    NdisDprAcquireSpinLock(&Adapter->SendLock);

    MpHandleSendInterrupt(Adapter);

    NdisDprReleaseSpinLock(&Adapter->SendLock);

    //
    // Start the receive unit if it had stopped
    //
    NdisDprAcquireSpinLock(&Adapter->RcvLock);

    NICStartRecv(Adapter);

    NdisDprReleaseSpinLock(&Adapter->RcvLock);

    
    //
    // Re-enable the interrupt (disabled in MPIsr)
    //
    NdisMSynchronizeWithInterrupt(
        &Adapter->Interrupt,
        (PVOID)NICEnableInterrupt,
        Adapter);
}

#ifdef NDIS51_MINIPORT
VOID MPCancelSendPackets(
    IN  NDIS_HANDLE     MiniportAdapterContext,
    IN  PVOID           CancelId)
/*++

Routine Description:
    
    MiniportCancelSendpackets handler - NDIS51 and later
    
Arguments:

    MiniportAdapterContext      Pointer to our adapter
    CancelId                    All the packets with this Id should be cancelled

Return Value:

    None
    
--*/
{
    PQUEUE_ENTRY    pEntry, pPrevEntry, pNextEntry;
    PNDIS_PACKET    Packet;
    PVOID           PacketId;

    PMP_ADAPTER     Adapter = (PMP_ADAPTER)MiniportAdapterContext;

    DBGPRINT(MP_TRACE, ("====> MPCancelSendPackets\n"));

    pPrevEntry = NULL;

    NdisAcquireSpinLock(&Adapter->SendLock);

    //
    // Walk through the send wait queue and complete the sends with matching Id
    //
    pEntry = Adapter->SendWaitQueue.Head;                        

    while (pEntry)
    {
        Packet = CONTAINING_RECORD(pEntry, NDIS_PACKET, MiniportReserved);

        PacketId = NdisGetPacketCancelId(Packet);
        if (PacketId == CancelId)
        {
            Adapter->nWaitSend--;
        
            //
            // This packet has the right CancelId
            //
            pNextEntry = pEntry->Next;

            if (pPrevEntry == NULL)
            {
                Adapter->SendWaitQueue.Head = pNextEntry;
                if (pNextEntry == NULL)
                {
                    Adapter->SendWaitQueue.Tail = NULL;
                }
            }
            else
            {
                pPrevEntry->Next = pNextEntry;
                if (pNextEntry == NULL)
                {
                    Adapter->SendWaitQueue.Tail = pPrevEntry;
                }
            }

            pEntry = pEntry->Next;
            
            // Put this packet on SendCancelQueue
            InsertTailQueue(&Adapter->SendCancelQueue, MP_GET_PACKET_MR(Packet));
            Adapter->nCancelSend++;
        }
        else
        {
            // This packet doesn't have the right CancelId
            pPrevEntry = pEntry;
            pEntry = pEntry->Next;
        }
    }

    //
    // Get the packets from SendCancelQueue and complete them if any
    //
    while (!IsQueueEmpty(&Adapter->SendCancelQueue))
    {
        pEntry = RemoveHeadQueue(&Adapter->SendCancelQueue); 

        NdisReleaseSpinLock(&Adapter->SendLock);

        ASSERT(pEntry);
        Packet = CONTAINING_RECORD(pEntry, NDIS_PACKET, MiniportReserved);

        NdisMSendComplete(
            MP_GET_ADAPTER_HANDLE(Adapter),
            Packet,
            NDIS_STATUS_REQUEST_ABORTED);
        
        NdisAcquireSpinLock(&Adapter->SendLock);
    } 

    NdisReleaseSpinLock(&Adapter->SendLock);

    DBGPRINT(MP_TRACE, ("<==== MPCancelSendPackets\n"));

}

VOID MPPnPEventNotify(
    IN  NDIS_HANDLE             MiniportAdapterContext,
    IN  NDIS_DEVICE_PNP_EVENT   PnPEvent,
    IN  PVOID                   InformationBuffer,
    IN  ULONG                   InformationBufferLength
    )
/*++

Routine Description:
    
    MiniportPnPEventNotify handler - NDIS51 and later
    
Arguments:

    MiniportAdapterContext      Pointer to our adapter
    PnPEvent                    Self-explanatory 
    InformationBuffer           Self-explanatory 
    InformationBufferLength     Self-explanatory 

Return Value:

    None
    
--*/
{
    PMP_ADAPTER     Adapter = (PMP_ADAPTER)MiniportAdapterContext;

    //
    // Turn off the warings.
    //
    UNREFERENCED_PARAMETER(InformationBuffer);
    UNREFERENCED_PARAMETER(InformationBufferLength);
    UNREFERENCED_PARAMETER(Adapter);

    DBGPRINT(MP_TRACE, ("====> MPPnPEventNotify\n"));

    switch (PnPEvent)
    {
        case NdisDevicePnPEventQueryRemoved:
            DBGPRINT(MP_WARN, ("MPPnPEventNotify: NdisDevicePnPEventQueryRemoved\n"));
            break;

        case NdisDevicePnPEventRemoved:
            DBGPRINT(MP_WARN, ("MPPnPEventNotify: NdisDevicePnPEventRemoved\n"));
            break;       

        case NdisDevicePnPEventSurpriseRemoved:

            DBGPRINT(MP_WARN, ("MPPnPEventNotify: NdisDevicePnPEventSurpriseRemoved\n"));
            break;

        case NdisDevicePnPEventQueryStopped:
            DBGPRINT(MP_WARN, ("MPPnPEventNotify: NdisDevicePnPEventQueryStopped\n"));
            break;

        case NdisDevicePnPEventStopped:
            DBGPRINT(MP_WARN, ("MPPnPEventNotify: NdisDevicePnPEventStopped\n"));
            break;      
            
        case NdisDevicePnPEventPowerProfileChanged:
            DBGPRINT(MP_WARN, ("MPPnPEventNotify: NdisDevicePnPEventPowerProfileChanged\n"));
            break;      
            
        default:
            DBGPRINT(MP_ERROR, ("MPPnPEventNotify: unknown PnP event %x \n", PnPEvent));
            break;         
    }

    DBGPRINT(MP_TRACE, ("<==== MPPnPEventNotify\n"));

}

#endif

#if LBFO
VOID MPUnload(
    IN  PDRIVER_OBJECT  DriverObject
    )
/*++

Routine Description:
    
    The Unload handler
    This handler is registered through NdisMRegisterUnloadHandler
    
Arguments:

    DriverObject        Not used

Return Value:

    None
    
--*/
{
    ASSERT(IsListEmpty(&g_AdapterList));

    NdisFreeSpinLock(&g_Lock);      
}

VOID MpAddAdapterToList(
    IN  PMP_ADAPTER  Adapter
    )
/*++

Routine Description:
    
    This function adds a new adapter to the global adapter list
    1. Not part of bundle (primary) if BundleId string is empty
    2. Primary if no adapter with the same BundleId
    3. Secondary if there is already one adapter with the same BundleId  
    
Arguments:

    MiniportAdapterContext      Pointer to our adapter

Return Value:

    None
    
--*/
{
    NDIS_STATUS     Status = NDIS_STATUS_SUCCESS;
    PMP_ADAPTER     ThisAdapter;
    PMP_ADAPTER     PrimaryAdapter = NULL;

    DBGPRINT(MP_WARN, ("Add adapter "PTR_FORMAT" ...", Adapter));

    //
    // Set the primary adapter to itself by default
    //
    Adapter->PrimaryAdapter = Adapter;

    //
    // Is this adapter part of a bundle? Just insert it in the list if not
    //
    if (Adapter->BundleId.Length == 0)
    {
        DBGPRINT_RAW(MP_WARN, ("not in a bundle\n"));
        NdisInterlockedInsertTailList(&g_AdapterList, &Adapter->List, &g_Lock);
        return;   
    }

    NdisAllocateSpinLock(&Adapter->LockLBFO);

    do
    {
        NdisAcquireSpinLock(&g_Lock);

        //
        // Search for the primary adapter if it exists. 
        // Skip searching if the list is empty 
        //
        if (IsListEmpty(&g_AdapterList))
        {
            DBGPRINT_RAW(MP_WARN, ("Primary\n"));
            break;
        }

        ThisAdapter = (PMP_ADAPTER)GetListHeadEntry(&g_AdapterList);

        while ((PLIST_ENTRY)ThisAdapter != &g_AdapterList)
        {
            if (!MP_TEST_FLAG(ThisAdapter, fMP_ADAPTER_SECONDARY) && 
                ThisAdapter->BundleId.Length == Adapter->BundleId.Length)
            {
                if (NdisEqualMemory(ThisAdapter->BundleId.Buffer, 
                    Adapter->BundleId.Buffer, Adapter->BundleId.Length))
                {
                    PrimaryAdapter = ThisAdapter;
                    break;
                }
            }

            ThisAdapter = (PMP_ADAPTER)GetListFLink((PLIST_ENTRY)ThisAdapter);   
        }

        //
        // Does a primary adapter exist? If not, this adapter will be primary.
        //
        if (PrimaryAdapter == NULL)
        {
            DBGPRINT_RAW(MP_WARN, ("Primary\n"));
            break;
        }

        //
        // Found the primary adapter, so set this adapter as secondary
        // Put a ref on the primary adapter so it won't go away while 
        // we are calling NdisMSetMiniportSecondary.
        //
        MP_LBFO_INC_REF(PrimaryAdapter);        

        NdisReleaseSpinLock(&g_Lock);

        //
        // We found the primary adapter with the same BundleIdentifier string
        // Set this adapter as scondary
        //
        Status = NdisMSetMiniportSecondary(
                     Adapter->AdapterHandle,
                     PrimaryAdapter->AdapterHandle);

        ASSERT(Status == NDIS_STATUS_SUCCESS);

        NdisAcquireSpinLock(&g_Lock);

        if (Status == NDIS_STATUS_SUCCESS)
        {
            MP_SET_FLAG(Adapter, fMP_ADAPTER_SECONDARY);
            Adapter->PrimaryAdapter = PrimaryAdapter; 

            DBGPRINT_RAW(MP_WARN, ("Secondary, use primary adapter "PTR_FORMAT"\n", 
                PrimaryAdapter));

            //
            // Add this to the end of primary's secondary miniport list
            //
            NdisAcquireSpinLock(&PrimaryAdapter->LockLBFO);

            PrimaryAdapter->NumSecondary++;   
            ThisAdapter = PrimaryAdapter; 
            while (ThisAdapter->NextSecondary)
            {
                ThisAdapter = ThisAdapter->NextSecondary;
            }
            ThisAdapter->NextSecondary = Adapter;

            NdisReleaseSpinLock(&PrimaryAdapter->LockLBFO);
        }

        MP_LBFO_DEC_REF(PrimaryAdapter);        

    } while (FALSE);

    InsertTailList(&g_AdapterList, &Adapter->List);

    NdisReleaseSpinLock(&g_Lock);

    return;      
}

VOID MpRemoveAdapterFromList(
    IN  PMP_ADAPTER  Adapter
    )
/*++

Routine Description:
    
    This function removes the adapter from the global adapter list
    1. Not part of bundle (primary) if BundleId string is empty
    2. Secondary - Remove it from primary's secondary adapter list
    3. Primary - If a secondary adapter exists, promote the secondary
    
Arguments:

    MiniportAdapterContext      Pointer to our adapter

Return Value:

    None
    
--*/
{
    PMP_ADAPTER     PrimaryAdapter;
    PMP_ADAPTER     ThisAdapter;

    DBGPRINT(MP_WARN, ("Remove adapter "PTR_FORMAT" ...", Adapter));

    ASSERT(!IsListEmpty(&g_AdapterList));

    //
    // Is this adapter part of a bundle? Just remove it if not
    //
    if (Adapter->BundleId.Length == 0)
    {
        DBGPRINT_RAW(MP_WARN, ("not in a bundle\n"));

        NdisAcquireSpinLock(&g_Lock);
        RemoveEntryList(&Adapter->List);
        NdisReleaseSpinLock(&g_Lock);
        return;
    }

    NdisAcquireSpinLock(&g_Lock);

    //
    // Check to see if it's secondary adapter, need to remove it from primary 
    // adapter's secondary list so the primary adapter won't pass more packets 
    // to this adapter
    //
    if (MP_TEST_FLAG(Adapter, fMP_ADAPTER_SECONDARY))
    {
        //
        // This is a secondary adapter
        //
        PrimaryAdapter = Adapter->PrimaryAdapter;

        DBGPRINT_RAW(MP_WARN, ("Secondary, primary adapter = "PTR_FORMAT"\n", 
            PrimaryAdapter));

        NdisAcquireSpinLock(&PrimaryAdapter->LockLBFO);

        //
        // Remove it from the primary's secondary miniport list
        //
        ThisAdapter = PrimaryAdapter; 
        while (ThisAdapter)
        {
            if (ThisAdapter->NextSecondary == Adapter)
            {
                ThisAdapter->NextSecondary = Adapter->NextSecondary;
                PrimaryAdapter->NumSecondary--;   
                break;
            }

            ThisAdapter = ThisAdapter->NextSecondary;
        }
        
        NdisReleaseSpinLock(&PrimaryAdapter->LockLBFO);

        //
        // Remove this adapter from the list
        //
        RemoveEntryList(&Adapter->List);
    }

    //
    // Need to wait for the ref count to be zero ...
    // For a primary adapter, non-zero ref count means one or more adapters are 
    // trying to become this adapter's secondary adapters    
    // For a secondary adapter, non-zero ref count means the primary is actively 
    // sending some packets on this adapter
    //
    while (TRUE)
    {
        if (MP_LBFO_GET_REF(Adapter) == 0)
        {
            break;
        }
        
        NdisReleaseSpinLock(&g_Lock);
        NdisMSleep(100);
        NdisAcquireSpinLock(&g_Lock);
    }  
    
    if (!MP_TEST_FLAG(Adapter, fMP_ADAPTER_SECONDARY))
    {
        //
        // Remove this adapter from the list
        //
        RemoveEntryList(&Adapter->List);
    
        DBGPRINT_RAW(MP_WARN, ("Primary\n"));
        if (Adapter->NumSecondary > 0)
        {
            //
            // Promote a secondary adapter
            //
            MpPromoteSecondary(Adapter);
        }
    }

    NdisReleaseSpinLock(&g_Lock);

    NdisFreeSpinLock(&Adapter->LockLBFO);
}

VOID MpPromoteSecondary(
    IN  PMP_ADAPTER     Adapter)
/*++

Routine Description:
    
    This function promotes a secondary miniport and sets up this new primary's
    secondary adapter list
    
Arguments:

    MiniportAdapterContext      Pointer to our adapter

Return Value:

    None
    
--*/
{
    NDIS_STATUS     Status;
    PMP_ADAPTER     ThisAdapter;
    PMP_ADAPTER     PromoteAdapter = NULL;

    //
    // Promote a secondary adapter
    //
    ThisAdapter = Adapter->NextSecondary; 
    while (ThisAdapter)
    {
        DBGPRINT(MP_WARN, ("Promote adapter "PTR_FORMAT"\n", ThisAdapter));

        Status = NdisMPromoteMiniport(ThisAdapter->AdapterHandle);
        ASSERT(Status == NDIS_STATUS_SUCCESS);
        if (Status == NDIS_STATUS_SUCCESS)
        {
            PromoteAdapter = ThisAdapter;
            MP_CLEAR_FLAG(PromoteAdapter, fMP_ADAPTER_SECONDARY);
            break;
        }

        ThisAdapter = ThisAdapter->NextSecondary;
    }

    if (PromoteAdapter)
    {
        //
        // Remove the new primary from old primary's secondary miniport list
        //
        NdisAcquireSpinLock(&Adapter->LockLBFO);
        ThisAdapter = Adapter; 
        while (ThisAdapter)
        {
            if (ThisAdapter->NextSecondary == PromoteAdapter)
            {
                ThisAdapter->NextSecondary = PromoteAdapter->NextSecondary;
                Adapter->NumSecondary--;   
                break;
            }

            ThisAdapter = ThisAdapter->NextSecondary;
        }
        NdisReleaseSpinLock(&Adapter->LockLBFO);

        //
        // Set all adapters in the bundle to use the new primary
        //
        PromoteAdapter->PrimaryAdapter = PromoteAdapter;
        while (ThisAdapter)
        {
            ThisAdapter->PrimaryAdapter = PromoteAdapter;
            ThisAdapter = ThisAdapter->NextSecondary;
        }

        //
        // Set the new primary's secondary miniport list
        //
        NdisAcquireSpinLock(&PromoteAdapter->LockLBFO);
        PromoteAdapter->NextSecondary = Adapter->NextSecondary;
        PromoteAdapter->NumSecondary = Adapter->NumSecondary;
        NdisReleaseSpinLock(&PromoteAdapter->LockLBFO);
    }
    else
    {
        //
        // This shouldn't happen! 
        // Set each secondary's primary to point to itself
        //
        DBGPRINT(MP_ERROR, ("Failed to promote any seconday adapter\n"));
        ASSERT(FALSE);

        ThisAdapter = Adapter->NextSecondary; 
        while (ThisAdapter)
        {
            ThisAdapter->PrimaryAdapter = ThisAdapter;
            ThisAdapter = ThisAdapter->NextSecondary;
        }
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\net\ms\e100bex\mp_nic.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:
    mp_nic.h

Abstract:
    Function prototypes for mp_nic.c, mp_init.c and mp_req.c

Revision History:
    Who         When        What
    --------    --------    ----------------------------------------------
    DChen       11-01-99    created

Notes:

--*/

#ifndef _MP_NIC_H
#define _MP_NIC_H

#define NIC_INTERRUPT_DISABLED(_adapter) \
   (_adapter->CSRAddress->ScbCommandHigh & SCB_INT_MASK)
   
#define NIC_INTERRUPT_ACTIVE(_adapter) \
      (((_adapter->CSRAddress->ScbStatus & SCB_ALL_INTERRUPT_BITS) != SCB_ALL_INTERRUPT_BITS) \
       && (_adapter->CSRAddress->ScbStatus & SCB_ACK_MASK))


#define NIC_ACK_INTERRUPT(_adapter, _value) { \
   _value = _adapter->CSRAddress->ScbStatus & SCB_ACK_MASK; \
   _adapter->CSRAddress->ScbStatus = _value; }        

#define NIC_IS_RECV_READY(_adapter) \
    ((_adapter->CSRAddress->ScbStatus & SCB_RUS_MASK) == SCB_RUS_READY)
    
__inline VOID NICDisableInterrupt(
    IN PMP_ADAPTER Adapter)
{
   Adapter->CSRAddress->ScbCommandHigh = SCB_INT_MASK;
}

__inline VOID NICEnableInterrupt(
    IN PMP_ADAPTER Adapter)
{
    Adapter->CSRAddress->ScbCommandHigh = 0;
}
    

//
//  MP_NIC.C
//                    
NDIS_STATUS MpSendPacket(
    IN  PMP_ADAPTER     Adapter,
    IN  PNDIS_PACKET    Packet,
    IN  BOOLEAN         bFromQueue);
   
NDIS_STATUS NICSendPacket(
    IN  PMP_ADAPTER     Adapter,
    IN  PMP_TCB         pMpTcb,
    IN  PMP_FRAG_LIST   pFragList);
                                
ULONG MpCopyPacket(
    IN  PNDIS_BUFFER    CurrBuffer,
    IN  PMP_TXBUF       pMpTxbuf); 

#ifndef NDIS51_MINIPORT
VOID MpStartPacketPhysicalMapping(
    IN  PMP_ADAPTER     Adapter, 
    IN  PNDIS_BUFFER    CurrBuffer,
    OUT PMP_FRAG_LIST   pFragList);
#endif
       
NDIS_STATUS NICStartSend(
    IN  PMP_ADAPTER     Adapter,
    IN  PMP_TCB         pMpTcb);
   
NDIS_STATUS MpHandleSendInterrupt(
    IN  PMP_ADAPTER     Adapter);
                   
VOID MpHandleRecvInterrupt(
    IN  PMP_ADAPTER     Adapter);
   
VOID NICReturnRFD(
    IN  PMP_ADAPTER     Adapter,
    IN  PMP_RFD         pMpRfd);
   
NDIS_STATUS NICStartRecv(
    IN  PMP_ADAPTER     Adapter);

VOID MpFreeQueuedSendPackets(
    IN  PMP_ADAPTER     Adapter);

void MpFreeBusySendPackets(
    IN  PMP_ADAPTER     Adapter);
                            
void NICResetRecv(
    IN  PMP_ADAPTER     Adapter);

VOID MpLinkDetectionDpc(
    IN  PVOID       SystemSpecific1,
    IN  PVOID       FunctionContext,
    IN  PVOID       SystemSpecific2, 
    IN  PVOID       SystemSpecific3);

//
// MP_INIT.C
//                  
      
NDIS_STATUS MpFindAdapter(
    IN  PMP_ADAPTER     Adapter,
    IN  NDIS_HANDLE     WrapperConfigurationContext);

NDIS_STATUS NICReadAdapterInfo(
    IN  PMP_ADAPTER     Adapter);
              
NDIS_STATUS MpAllocAdapterBlock(
    OUT  PMP_ADAPTER    *pAdapter);
    
void MpFreeAdapter(
    IN  PMP_ADAPTER     Adapter);
                                         
NDIS_STATUS NICReadRegParameters(
    IN  PMP_ADAPTER     Adapter,
    IN  NDIS_HANDLE     WrapperConfigurationContext);
                                              
NDIS_STATUS NICAllocAdapterMemory(
    IN  PMP_ADAPTER     Adapter);
   
VOID NICInitSend(
    IN  PMP_ADAPTER     Adapter);

NDIS_STATUS NICInitRecv(
    IN  PMP_ADAPTER     Adapter);

ULONG NICAllocRfd(
    IN  PMP_ADAPTER     Adapter, 
    IN  PMP_RFD         pMpRfd);
    
VOID NICFreeRfd(
    IN  PMP_ADAPTER     Adapter, 
    IN  PMP_RFD         pMpRfd);
   
NDIS_STATUS NICSelfTest(
    IN  PMP_ADAPTER     Adapter);

NDIS_STATUS NICInitializeAdapter(
    IN  PMP_ADAPTER     Adapter);

VOID HwSoftwareReset(
    IN  PMP_ADAPTER     Adapter);

NDIS_STATUS HwConfigure(
    IN  PMP_ADAPTER     Adapter);

NDIS_STATUS HwSetupIAAddress(
    IN  PMP_ADAPTER     Adapter);

NDIS_STATUS HwClearAllCounters(
    IN  PMP_ADAPTER     Adapter);

//
// MP_REQ.C
//                  
    
NDIS_STATUS NICGetStatsCounters(
    IN  PMP_ADAPTER     Adapter, 
    IN  NDIS_OID        Oid,
    OUT PULONG64        pCounter);
    
NDIS_STATUS NICSetPacketFilter(
    IN  PMP_ADAPTER     Adapter,
    IN  ULONG           PacketFilter);

NDIS_STATUS NICSetMulticastList(
    IN  PMP_ADAPTER     Adapter);
    
ULONG NICGetMediaConnectStatus(
    IN  PMP_ADAPTER     Adapter);
    


                    
#endif  // MP_NIC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\net\ms\e100bex\mp_req.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:
    mp_req.c

Abstract:
    This module contains miniport OID related handlers

Revision History:
    Who         When        What
    --------    --------    ----------------------------------------------
    DChen       11-01-99    created

Notes:

--*/

#include "precomp.h"
#include "e100_wmi.h"

#if DBG
#define _FILENUMBER     'QERM'
#endif

#if OFFLOAD

//
// This miniport only supports one Encapsultion type: IEEE_802_3_Encapsulation
// one task version: NDIS_TASK_OFFLOAD_VERSION. Modify the code below OID_TCP_
// TASK_OFFLOAD in query and setting information functions to make it support
// more than one encapsulation type and task version
//
// Define the task offload the miniport currently supports.
// This miniport only supports two kinds of offload tasks:
// TCP/IP checksum offload and Segmentation large TCP packet offload
// Later if it can supports more tasks, just redefine this task array
// 
NDIS_TASK_OFFLOAD OffloadTasks[] = {
    {   
        NDIS_TASK_OFFLOAD_VERSION,
        sizeof(NDIS_TASK_OFFLOAD),
        TcpIpChecksumNdisTask,
        0,
        sizeof(NDIS_TASK_TCP_IP_CHECKSUM)
    },

    {   
        NDIS_TASK_OFFLOAD_VERSION,
        sizeof(NDIS_TASK_OFFLOAD),
        TcpLargeSendNdisTask,
        0,
        sizeof(NDIS_TASK_TCP_LARGE_SEND)
    }
};

//
// Get the number of offload tasks this miniport supports
// 
ULONG OffloadTasksCount = sizeof(OffloadTasks) / sizeof(OffloadTasks[0]);

//
// Specify TCP/IP checksum offload task, the miniport can only supports, for now,
// TCP checksum and IP checksum on the sending side, also it supports TCP and IP 
// options
// 
NDIS_TASK_TCP_IP_CHECKSUM TcpIpChecksumTask = {
    {1, 1, 1, 0, 1},
    {0, 0, 0, 0, 0},
    {0, 0, 0, 0},
    {0, 0, 0, 0}
};
//
// Specify Large Send offload task, the miniport supports TCP options and IP options,
// and the minimum segment count the protocol can offload is 1. At this point, we
// cannot specify the maximum offload size(here is 0), because it depends on the size
// of shared memory and the number of TCB used by the driver.
// 
NDIS_TASK_TCP_LARGE_SEND TcpLargeSendTask = {
    0,      //Currently the version is set to 0, later it may change
    0,
    1,
    TRUE,
    TRUE
};

#endif // OFFLOAD


ULONG VendorDriverVersion = NIC_VENDOR_DRIVER_VERSION;

NDIS_OID NICSupportedOids[] =
{
    OID_GEN_SUPPORTED_LIST,
    OID_GEN_HARDWARE_STATUS,
    OID_GEN_MEDIA_SUPPORTED,
    OID_GEN_MEDIA_IN_USE,
    OID_GEN_MAXIMUM_LOOKAHEAD,
    OID_GEN_MAXIMUM_FRAME_SIZE,
    OID_GEN_LINK_SPEED,
    OID_GEN_TRANSMIT_BUFFER_SPACE,
    OID_GEN_RECEIVE_BUFFER_SPACE,
    OID_GEN_TRANSMIT_BLOCK_SIZE,
    OID_GEN_RECEIVE_BLOCK_SIZE,
    OID_GEN_VENDOR_ID,
    OID_GEN_VENDOR_DESCRIPTION,
    OID_GEN_VENDOR_DRIVER_VERSION,
    OID_GEN_CURRENT_PACKET_FILTER,
    OID_GEN_CURRENT_LOOKAHEAD,
    OID_GEN_DRIVER_VERSION,
    OID_GEN_MAXIMUM_TOTAL_SIZE,
    OID_GEN_MAC_OPTIONS,
    OID_GEN_MEDIA_CONNECT_STATUS,
    OID_GEN_MAXIMUM_SEND_PACKETS,
    OID_GEN_SUPPORTED_GUIDS,
    OID_GEN_XMIT_OK,
    OID_GEN_RCV_OK,
    OID_GEN_XMIT_ERROR,
    OID_GEN_RCV_ERROR,
    OID_GEN_RCV_NO_BUFFER,
    OID_GEN_RCV_CRC_ERROR,
    OID_GEN_TRANSMIT_QUEUE_LENGTH,
    OID_802_3_PERMANENT_ADDRESS,
    OID_802_3_CURRENT_ADDRESS,
    OID_802_3_MULTICAST_LIST,
    OID_802_3_MAXIMUM_LIST_SIZE,
    OID_802_3_RCV_ERROR_ALIGNMENT,
    OID_802_3_XMIT_ONE_COLLISION,
    OID_802_3_XMIT_MORE_COLLISIONS,
    OID_802_3_XMIT_DEFERRED,
    OID_802_3_XMIT_MAX_COLLISIONS,
    OID_802_3_RCV_OVERRUN,
    OID_802_3_XMIT_UNDERRUN,
    OID_802_3_XMIT_HEARTBEAT_FAILURE,
    OID_802_3_XMIT_TIMES_CRS_LOST,
    OID_802_3_XMIT_LATE_COLLISIONS,

#if !BUILD_W2K
    OID_GEN_PHYSICAL_MEDIUM,
#endif

#if OFFLOAD
    OID_TCP_TASK_OFFLOAD,
#endif 
    
/* powermanagement */

    OID_PNP_CAPABILITIES,
    OID_PNP_SET_POWER,
    OID_PNP_QUERY_POWER,
    OID_PNP_ADD_WAKE_UP_PATTERN,
    OID_PNP_REMOVE_WAKE_UP_PATTERN,
    OID_PNP_ENABLE_WAKE_UP,


/* custom oid WMI support */
    OID_CUSTOM_DRIVER_SET,
    OID_CUSTOM_DRIVER_QUERY,
    OID_CUSTOM_ARRAY,
    OID_CUSTOM_STRING
};

//
// WMI support
// check out the e100.mof file for examples of how the below
// maps into a .mof file for external advertisement of GUIDs
//
#define NIC_NUM_CUSTOM_GUIDS    4       
//
// Define the following values to demonstrate that the driver should
// always validat the content in the information buffer whether the OID
// is for set or query
//
#define CUSTOM_DRIVER_SET_MIN   0x1       
#define CUSTOM_DRIVER_SET_MAX   0xFFFFFF       

#if BUILD_W2K

static const NDIS_GUID NICGuidList[NIC_NUM_CUSTOM_GUIDS] = {
    { // {F4A80276-23B7-11d1-9ED9-00A0C9010057} example of a uint set
        E100BExampleSetUINT_OIDGuid,
        OID_CUSTOM_DRIVER_SET,
        sizeof(ULONG),
        (fNDIS_GUID_TO_OID )
    },
    { // {F4A80277-23B7-11d1-9ED9-00A0C9010057} example of a uint query
        E100BExampleQueryUINT_OIDGuid,
            OID_CUSTOM_DRIVER_QUERY,
            sizeof(ULONG),
            (fNDIS_GUID_TO_OID)
    },
    { // {F4A80278-23B7-11d1-9ED9-00A0C9010057} example of an array query
        E100BExampleQueryArrayOIDGuid,
            OID_CUSTOM_ARRAY,
            sizeof(UCHAR),  // size is size of each element in the array
            (fNDIS_GUID_TO_OID|fNDIS_GUID_ARRAY )
    },
    { // {F4A80279-23B7-11d1-9ED9-00A0C9010057} example of a string query
        E100BExampleQueryStringOIDGuid,
            OID_CUSTOM_STRING,
            (ULONG) -1, // size is -1 for ANSI or NDIS_STRING string types
            (fNDIS_GUID_TO_OID|fNDIS_GUID_ANSI_STRING)
    }
};

#else
//
// Support for the fNDIS_GUID_ALLOW_READ flag has been added in WinXP for
// both 5.0 and 5.1 miniports
//
static const NDIS_GUID NICGuidList[NIC_NUM_CUSTOM_GUIDS] = {
    { // {F4A80276-23B7-11d1-9ED9-00A0C9010057} example of a uint set
        E100BExampleSetUINT_OIDGuid,
        OID_CUSTOM_DRIVER_SET,
        sizeof(ULONG),
        // Not setting fNDIS_GUID_ALLOW_WRITE flag means that we don't allow
        // users without administrator privilege to set this value, but we do 
        // allow any user to query this value
        (fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ)
    },
    { // {F4A80277-23B7-11d1-9ED9-00A0C9010057} example of a uint query
        E100BExampleQueryUINT_OIDGuid,
            OID_CUSTOM_DRIVER_QUERY,
            sizeof(ULONG),
            // setting fNDIS_GUID_ALLOW_READ flag means that we allow any
            // user to query this value.
            (fNDIS_GUID_TO_OID | fNDIS_GUID_ALLOW_READ)
    },
    { // {F4A80278-23B7-11d1-9ED9-00A0C9010057} example of an array query
        E100BExampleQueryArrayOIDGuid,
            OID_CUSTOM_ARRAY,
            sizeof(UCHAR),  // size is size of each element in the array
            // setting fNDIS_GUID_ALLOW_READ flag means that we allow any
            // user to query this value.
            (fNDIS_GUID_TO_OID|fNDIS_GUID_ARRAY | fNDIS_GUID_ALLOW_READ)
    },
    { // {F4A80279-23B7-11d1-9ED9-00A0C9010057} example of a string query
        E100BExampleQueryStringOIDGuid,
            OID_CUSTOM_STRING,
            (ULONG) -1, // size is -1 for ANSI or NDIS_STRING string types
            // setting fNDIS_GUID_ALLOW_READ flag means that we allow any
            // user to query this value.
            (fNDIS_GUID_TO_OID|fNDIS_GUID_ANSI_STRING | fNDIS_GUID_ALLOW_READ)
    }
};
#endif
/**
Local Prototypes
**/
NDIS_STATUS
MPSetPower(
    PMP_ADAPTER               Adapter,
    NDIS_DEVICE_POWER_STATE   PowerState 
    );

VOID
MPFillPoMgmtCaps (
    IN PMP_ADAPTER                  Adapter, 
    IN OUT PNDIS_PNP_CAPABILITIES   pPower_Management_Capabilities, 
    IN OUT PNDIS_STATUS             pStatus,
    IN OUT PULONG                   pulInfoLen
    );

NDIS_STATUS
MPAddWakeUpPattern(
    IN PMP_ADAPTER   pAdapter,
    IN PVOID         InformationBuffer, 
    IN UINT          InformationBufferLength,
    IN OUT PULONG    BytesRead,
    IN OUT PULONG    BytesNeeded    
    );

NDIS_STATUS
MPRemoveWakeUpPattern(
    IN PMP_ADAPTER  pAdapter,
    IN PVOID        InformationBuffer, 
    IN UINT         InformationBufferLength,
    OUT PULONG      BytesRead,
    OUT PULONG      BytesNeeded
    );

BOOLEAN 
MPAreTwoPatternsEqual(
    IN PNDIS_PM_PACKET_PATTERN pNdisPattern1,
    IN PNDIS_PM_PACKET_PATTERN pNdisPattern2
    );


//
// Macros used to walk a doubly linked list. Only macros that are not defined in ndis.h
// The List Next macro will work on Single and Doubly linked list as Flink is a common
// field name in both
//

/*
PLIST_ENTRY
ListNext (
    IN PLIST_ENTRY
    );

PSINGLE_LIST_ENTRY
ListNext (
    IN PSINGLE_LIST_ENTRY
    );
*/
#define ListNext(_pL)                       (_pL)->Flink

/*
PLIST_ENTRY
ListPrev (
    IN LIST_ENTRY *
    );
*/
#define ListPrev(_pL)                       (_pL)->Blink


__inline 
BOOLEAN  
MPIsPoMgmtSupported(
   IN PMP_ADAPTER pAdapter
   )
{

    if (pAdapter->RevsionID  >= E100_82559_A_STEP   && 
         pAdapter->RevsionID <= E100_82559_C_STEP )
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
    
}


NDIS_STATUS MPQueryInformation(
    IN  NDIS_HANDLE  MiniportAdapterContext,
    IN  NDIS_OID     Oid,
    IN  PVOID        InformationBuffer,
    IN  ULONG        InformationBufferLength,
    OUT PULONG       BytesWritten,
    OUT PULONG       BytesNeeded
    )
/*++
Routine Description:

    MiniportQueryInformation handler            

Arguments:

    MiniportAdapterContext  Pointer to the adapter structure
    Oid                     Oid for this query
    InformationBuffer       Buffer for information
    InformationBufferLength Size of this buffer
    BytesWritten            Specifies how much info is written
    BytesNeeded             In case the buffer is smaller than what we need, tell them how much is needed
    
Return Value:
    
    NDIS_STATUS_SUCCESS
    NDIS_STATUS_NOT_SUPPORTED
    NDIS_STATUS_BUFFER_TOO_SHORT
    
--*/
{
    NDIS_STATUS                 Status = NDIS_STATUS_SUCCESS;
    PMP_ADAPTER                 Adapter;

    NDIS_HARDWARE_STATUS        HardwareStatus = NdisHardwareStatusReady;
    NDIS_MEDIUM                 Medium = NIC_MEDIA_TYPE;
    UCHAR                       VendorDesc[] = NIC_VENDOR_DESC;
    NDIS_PNP_CAPABILITIES       Power_Management_Capabilities;

    ULONG                       ulInfo = 0;
    ULONG64                     ul64Info = 0;
    
    USHORT                      usInfo = 0;                                              
    PVOID                       pInfo = (PVOID) &ulInfo;
    ULONG                       ulInfoLen = sizeof(ulInfo);
    ULONG                       ulBytesAvailable = ulInfoLen;
    PNDIS_TASK_OFFLOAD_HEADER   pNdisTaskOffloadHdr;
    NDIS_MEDIA_STATE            CurrMediaState;
    NDIS_STATUS                 IndicateStatus;
    
#if OFFLOAD   
    PNDIS_TASK_OFFLOAD          pTaskOffload;
    PNDIS_TASK_TCP_IP_CHECKSUM  pTcpIpChecksumTask;
    PNDIS_TASK_TCP_LARGE_SEND   pTcpLargeSendTask;
    ULONG                       ulHeadersLen;
    ULONG                       ulMaxOffloadSize;
    UINT                        i;
#endif

#if !BUILD_W2K
    NDIS_PHYSICAL_MEDIUM        PhysMedium = NdisPhysicalMediumUnspecified;
#endif    
    
    DBGPRINT(MP_TRACE, ("====> MPQueryInformation\n"));

    Adapter = (PMP_ADAPTER) MiniportAdapterContext;

    //
    // Initialize the result
    //
    *BytesWritten = 0;
    *BytesNeeded = 0;

    //
    // Process different type of requests
    //
    switch(Oid)
    {
        case OID_GEN_SUPPORTED_LIST:
            pInfo = (PVOID) NICSupportedOids;
            ulBytesAvailable = ulInfoLen = sizeof(NICSupportedOids);
            break;

        case OID_GEN_HARDWARE_STATUS:
            pInfo = (PVOID) &HardwareStatus;
            ulBytesAvailable = ulInfoLen = sizeof(NDIS_HARDWARE_STATUS);
            break;

        case OID_GEN_MEDIA_SUPPORTED:
        case OID_GEN_MEDIA_IN_USE:
            pInfo = (PVOID) &Medium;
            ulBytesAvailable = ulInfoLen = sizeof(NDIS_MEDIUM);
            break;

#if !BUILD_W2K
        case OID_GEN_PHYSICAL_MEDIUM:
            pInfo = (PVOID) &PhysMedium;
            ulBytesAvailable = ulInfoLen = sizeof(NDIS_PHYSICAL_MEDIUM);
            break;
#endif

        case OID_GEN_CURRENT_LOOKAHEAD:
        case OID_GEN_MAXIMUM_LOOKAHEAD:
            if (Adapter->ulLookAhead == 0)
            {
                Adapter->ulLookAhead = NIC_MAX_PACKET_SIZE - NIC_HEADER_SIZE;
            }
            ulInfo = Adapter->ulLookAhead;
            break;         

        case OID_GEN_MAXIMUM_FRAME_SIZE:
            ulInfo = NIC_MAX_PACKET_SIZE - NIC_HEADER_SIZE;
            break;

        case OID_GEN_MAXIMUM_TOTAL_SIZE:
        case OID_GEN_TRANSMIT_BLOCK_SIZE:
        case OID_GEN_RECEIVE_BLOCK_SIZE:
            ulInfo = (ULONG) NIC_MAX_PACKET_SIZE;
            break;

        case OID_GEN_MAC_OPTIONS:
            // Notes: 
            // The protocol driver is free to access indicated data by any means. 
            // Some fast-copy functions have trouble accessing on-board device 
            // memory. NIC drivers that indicate data out of mapped device memory 
            // should never set this flag. If a NIC driver does set this flag, it 
            // relaxes the restriction on fast-copy functions. 

            // This miniport indicates receive with NdisMIndicateReceivePacket 
            // function. It has no MiniportTransferData function. Such a driver 
            // should set this flag. 

            ulInfo = NDIS_MAC_OPTION_COPY_LOOKAHEAD_DATA | 
                     NDIS_MAC_OPTION_TRANSFERS_NOT_PEND |
                     NDIS_MAC_OPTION_NO_LOOPBACK;
            
            break;

        case OID_GEN_LINK_SPEED:
        case OID_GEN_MEDIA_CONNECT_STATUS:
            if (InformationBufferLength < ulInfoLen)
            {
                break;
            }

            NdisAcquireSpinLock(&Adapter->Lock);
            if (MP_TEST_FLAG(Adapter, fMP_ADAPTER_LINK_DETECTION))
            {
                ASSERT(!Adapter->bQueryPending);
                Adapter->bQueryPending = TRUE;
                Adapter->QueryRequest.Oid = Oid;                       
                Adapter->QueryRequest.InformationBuffer = InformationBuffer;                       
                Adapter->QueryRequest.InformationBufferLength = InformationBufferLength;
                Adapter->QueryRequest.BytesWritten = BytesWritten;                       
                Adapter->QueryRequest.BytesNeeded = BytesNeeded;                       

                NdisReleaseSpinLock(&Adapter->Lock);

                DBGPRINT(MP_WARN, ("MPQueryInformation: OID 0x%08x is pended\n", Oid));

                Status = NDIS_STATUS_PENDING;   
                break;
            }
            else
            {
                
                NdisReleaseSpinLock(&Adapter->Lock);
                if (Oid == OID_GEN_LINK_SPEED)
                {
                    ulInfo = Adapter->usLinkSpeed * 10000;
                }
                else  // OID_GEN_MEDIA_CONNECT_STATUS
                {
                    CurrMediaState = NICGetMediaState(Adapter);
                    NdisAcquireSpinLock(&Adapter->Lock);
                    if (Adapter->MediaState != CurrMediaState)
                    {
                        Adapter->MediaState = CurrMediaState;

                        DBGPRINT(MP_WARN, ("Media state changed to %s\n",
                                  ((CurrMediaState == NdisMediaStateConnected)? 
                                  "Connected": "Disconnected")));

                        IndicateStatus = (CurrMediaState == NdisMediaStateConnected) ? 
                                  NDIS_STATUS_MEDIA_CONNECT : NDIS_STATUS_MEDIA_DISCONNECT;          

                        if (IndicateStatus == NDIS_STATUS_MEDIA_CONNECT)
                        {
                            MP_CLEAR_FLAG(Adapter, fMP_ADAPTER_NO_CABLE);
                        }
                        else
                        {
                            MP_SET_FLAG(Adapter, fMP_ADAPTER_NO_CABLE);
                        }

                        NdisReleaseSpinLock(&Adapter->Lock);
                        
                        // Indicate the media event
                        NdisMIndicateStatus(Adapter->AdapterHandle, IndicateStatus, (PVOID)0, 0);
                
                        NdisMIndicateStatusComplete(Adapter->AdapterHandle);
      
                    }
                    else
                    {
                        NdisReleaseSpinLock(&Adapter->Lock);
                    }    
                    ulInfo = CurrMediaState;
                }
            }
            
            break;

        case OID_GEN_TRANSMIT_BUFFER_SPACE:
            ulInfo = NIC_MAX_PACKET_SIZE * Adapter->NumTcb;
            break;

        case OID_GEN_RECEIVE_BUFFER_SPACE:
            ulInfo = NIC_MAX_PACKET_SIZE * Adapter->CurrNumRfd;
            break;

        case OID_GEN_VENDOR_ID:
            NdisMoveMemory(&ulInfo, Adapter->PermanentAddress, 3);
            break;

        case OID_GEN_VENDOR_DESCRIPTION:
            pInfo = VendorDesc;
            ulBytesAvailable = ulInfoLen = sizeof(VendorDesc);
            break;

        case OID_GEN_VENDOR_DRIVER_VERSION:
            ulInfo = VendorDriverVersion;
            break;

        case OID_GEN_DRIVER_VERSION:
            usInfo = (USHORT) NIC_DRIVER_VERSION;
            pInfo = (PVOID) &usInfo;
            ulBytesAvailable = ulInfoLen = sizeof(USHORT);
            break;

            // WMI support
        case OID_GEN_SUPPORTED_GUIDS:
            pInfo = (PUCHAR) &NICGuidList;
            ulBytesAvailable = ulInfoLen =  sizeof(NICGuidList);
            break;

#if OFFLOAD
            // Task Offload
        case OID_TCP_TASK_OFFLOAD:
            
            DBGPRINT(MP_WARN, ("Query Offloading.\n"));
            
            //
            // If the miniport supports LBFO, it can't support task offload
            // 
#if LBFO
            return NDIS_STATUS_NOT_SUPPORTED;
#endif
           
            //
            // Because this miniport uses shared memory to do the offload tasks, if
            // allocation of memory is failed, then the miniport can't do the offloading
            // 
            if (Adapter->OffloadEnable == FALSE)
            {
                Status = NDIS_STATUS_NOT_SUPPORTED;
                break;
            }

            //
            // Calculate the information buffer length we need to write the offload
            // capabilities
            //
            ulInfoLen = sizeof(NDIS_TASK_OFFLOAD_HEADER) +
                        FIELD_OFFSET(NDIS_TASK_OFFLOAD, TaskBuffer) +
                        sizeof(NDIS_TASK_TCP_IP_CHECKSUM) +
                        FIELD_OFFSET(NDIS_TASK_OFFLOAD, TaskBuffer) +
                        sizeof(NDIS_TASK_TCP_LARGE_SEND);
            
            if (ulInfoLen > InformationBufferLength)
            {
                *BytesNeeded = ulInfoLen;
                Status = NDIS_STATUS_BUFFER_TOO_SHORT;
                break;
            }

            //
            // check version and Encapsulation Type
            //
            pNdisTaskOffloadHdr = (PNDIS_TASK_OFFLOAD_HEADER)InformationBuffer;
            
            //
            // Assume the miniport only supports IEEE_802_3_Encapsulation type
            //
            if (pNdisTaskOffloadHdr->EncapsulationFormat.Encapsulation != IEEE_802_3_Encapsulation)
            {
                DBGPRINT(MP_WARN, ("Encapsulation  type is not supported.\n"));

                pNdisTaskOffloadHdr->OffsetFirstTask = 0;
                Status = NDIS_STATUS_NOT_SUPPORTED;
                break;
            }

            //
            // Assume the miniport only supports task version of NDIS_TASK_OFFLOAD_VERSION
            // 
            if (pNdisTaskOffloadHdr->Size != sizeof(NDIS_TASK_OFFLOAD_HEADER)
                    || pNdisTaskOffloadHdr->Version != NDIS_TASK_OFFLOAD_VERSION)
            {
                DBGPRINT(MP_WARN, ("Size or Version is not correct.\n"));

                pNdisTaskOffloadHdr->OffsetFirstTask = 0;
                Status = NDIS_STATUS_NOT_SUPPORTED;
                break;
            }

            //            
            // If no capabilities supported, OffsetFirstTask should be set to 0
            // Currently we support TCP/IP checksum and TCP large send, so set 
            // OffsetFirstTask to indicate the offset of the first offload task
            //
            pNdisTaskOffloadHdr->OffsetFirstTask = pNdisTaskOffloadHdr->Size; 

            //
            // Fill TCP/IP checksum and TCP large send task offload structures
            //
            pTaskOffload = (PNDIS_TASK_OFFLOAD)((PUCHAR)(InformationBuffer) + 
                                                         pNdisTaskOffloadHdr->Size);
            //
            // Fill all the offload capabilities the miniport supports.
            // 
            for (i = 0; i < OffloadTasksCount; i++)
            {
                pTaskOffload->Size = OffloadTasks[i].Size;
                pTaskOffload->Version = OffloadTasks[i].Version;
                pTaskOffload->Task = OffloadTasks[i].Task;
                pTaskOffload->TaskBufferLength = OffloadTasks[i].TaskBufferLength;

                //
                // Not the last task
                // 
                if (i != OffloadTasksCount - 1) 
                {
                    pTaskOffload->OffsetNextTask = FIELD_OFFSET(NDIS_TASK_OFFLOAD, TaskBuffer) +
                                                pTaskOffload->TaskBufferLength;
                }
                else 
                {
                    pTaskOffload->OffsetNextTask = 0;
                }

                switch (OffloadTasks[i].Task) 
                {
                //
                // TCP/IP checksum task offload
                //
                case TcpIpChecksumNdisTask:
                    pTcpIpChecksumTask = (PNDIS_TASK_TCP_IP_CHECKSUM) pTaskOffload->TaskBuffer;
           
                    NdisMoveMemory(pTcpIpChecksumTask, 
                                   &TcpIpChecksumTask, 
                                   sizeof(TcpIpChecksumTask));
                    break;

                //
                // TCP large send task offload
                //
                case TcpLargeSendNdisTask:
                    pTcpLargeSendTask = (PNDIS_TASK_TCP_LARGE_SEND) pTaskOffload->TaskBuffer;
                    NdisMoveMemory(pTcpLargeSendTask, 
                                   &TcpLargeSendTask,
                                   sizeof(TcpLargeSendTask));

                    ulHeadersLen = TCP_IP_MAX_HEADER_SIZE + 
                            pNdisTaskOffloadHdr->EncapsulationFormat.EncapsulationHeaderSize;

                    ulMaxOffloadSize = (NIC_MAX_PACKET_SIZE - ulHeadersLen) * (ULONG)(Adapter->NumTcb);
                    //
                    // The maximum offload size depends on the size of allocated shared memory
                    // and the number of TCB available, because this driver doesn't use a queue
                    // to store the small packets splited from the large packet, so the number
                    // of small packets must be less than or equal to the number of TCB the 
                    // miniport has, so all the small packets can be sent out at one time.
                    // 
                    pTcpLargeSendTask->MaxOffLoadSize = (ulMaxOffloadSize > Adapter->OffloadSharedMemSize) ? 
                                                        Adapter->OffloadSharedMemSize: ulMaxOffloadSize;

                    //
                    // Store the maximum offload size 
                    // 
                    TcpLargeSendTask.MaxOffLoadSize = pTcpLargeSendTask->MaxOffLoadSize;
                    break;
                }

                //
                // Points to the next task offload
                //
                if (i != OffloadTasksCount) 
                {
                    pTaskOffload = (PNDIS_TASK_OFFLOAD)
                                   ((PUCHAR)pTaskOffload + pTaskOffload->OffsetNextTask);
                }
            }
            
            //
            // So far, everything is setup, so return to the caller
            //
            *BytesWritten = ulInfoLen;
            *BytesNeeded = 0;
            
            DBGPRINT (MP_WARN, ("Offloading is set.\n"));

            return NDIS_STATUS_SUCCESS;

#endif //OFFLOAD

            
        case OID_802_3_PERMANENT_ADDRESS:
            pInfo = Adapter->PermanentAddress;
            ulBytesAvailable = ulInfoLen = ETH_LENGTH_OF_ADDRESS;
            break;

        case OID_802_3_CURRENT_ADDRESS:
            pInfo = Adapter->CurrentAddress;
            ulBytesAvailable = ulInfoLen = ETH_LENGTH_OF_ADDRESS;
            break;

        case OID_802_3_MAXIMUM_LIST_SIZE:
            ulInfo = NIC_MAX_MCAST_LIST;
            break;

        case OID_GEN_MAXIMUM_SEND_PACKETS:
            ulInfo = NIC_MAX_SEND_PACKETS;
            break;

        case OID_PNP_CAPABILITIES:

            MPFillPoMgmtCaps (Adapter, 
                                &Power_Management_Capabilities, 
                                &Status,
                                &ulInfoLen);
            if (Status == NDIS_STATUS_SUCCESS)
            {
                pInfo = (PVOID) &Power_Management_Capabilities;
            }
            else
            {
                pInfo = NULL;
            }

            break;

        case OID_PNP_QUERY_POWER:
            // Status is pre-set in this routine to Success

            Status = NDIS_STATUS_SUCCESS; 

            break;

            // WMI support
        case OID_CUSTOM_DRIVER_QUERY:
            // this is the uint case
            DBGPRINT(MP_INFO,("CUSTOM_DRIVER_QUERY got a QUERY\n"));
            ulInfo = ++Adapter->CustomDriverSet;
            break;

        case OID_CUSTOM_DRIVER_SET:
            DBGPRINT(MP_INFO,("CUSTOM_DRIVER_SET got a QUERY\n"));
            ulInfo = Adapter->CustomDriverSet;
            break;

            // this is the array case
        case OID_CUSTOM_ARRAY:
            DBGPRINT(MP_INFO,("CUSTOM_ARRAY got a QUERY\n"));
            NdisMoveMemory(&ulInfo, Adapter->PermanentAddress, 4);
            break;

            // this is the string case
        case OID_CUSTOM_STRING:
            DBGPRINT(MP_INFO, ("CUSTOM_STRING got a QUERY\n"));
            pInfo = (PVOID) VendorDesc;
            ulBytesAvailable = ulInfoLen = sizeof(VendorDesc);
            break;

        case OID_GEN_XMIT_OK:
        case OID_GEN_RCV_OK:
        case OID_GEN_XMIT_ERROR:
        case OID_GEN_RCV_ERROR:
        case OID_GEN_RCV_NO_BUFFER:
        case OID_GEN_RCV_CRC_ERROR:
        case OID_GEN_TRANSMIT_QUEUE_LENGTH:
        case OID_802_3_RCV_ERROR_ALIGNMENT:
        case OID_802_3_XMIT_ONE_COLLISION:
        case OID_802_3_XMIT_MORE_COLLISIONS:
        case OID_802_3_XMIT_DEFERRED:
        case OID_802_3_XMIT_MAX_COLLISIONS:
        case OID_802_3_RCV_OVERRUN:
        case OID_802_3_XMIT_UNDERRUN:
        case OID_802_3_XMIT_HEARTBEAT_FAILURE:
        case OID_802_3_XMIT_TIMES_CRS_LOST:
        case OID_802_3_XMIT_LATE_COLLISIONS:
            Status = NICGetStatsCounters(Adapter, Oid, &ul64Info);
            ulBytesAvailable = ulInfoLen = sizeof(ul64Info);
            if (Status == NDIS_STATUS_SUCCESS)
            {
                if (InformationBufferLength < sizeof(ULONG))
                {
                    Status = NDIS_STATUS_BUFFER_TOO_SHORT;
                    *BytesNeeded = ulBytesAvailable;
                    break;
                }

                ulInfoLen = MIN(InformationBufferLength, ulBytesAvailable);
                pInfo = &ul64Info;
            }
                    
            break;         
            
        default:
            Status = NDIS_STATUS_NOT_SUPPORTED;
            break;
    }

    if (Status == NDIS_STATUS_SUCCESS)
    {
        *BytesNeeded = ulBytesAvailable;
        if (ulInfoLen <= InformationBufferLength)
        {
            //
            // Copy result into InformationBuffer
            //
            *BytesWritten = ulInfoLen;
            if (ulInfoLen)
            {
                NdisMoveMemory(InformationBuffer, pInfo, ulInfoLen);
            }
        }
        else
        {
            //
            // too short
            //
            *BytesNeeded = ulInfoLen;
            Status = NDIS_STATUS_BUFFER_TOO_SHORT;
        }
    }

    DBGPRINT(MP_TRACE, ("<==== MPQueryInformation, OID=0x%08x, Status=%x\n", Oid, Status));

    return(Status);
}   

NDIS_STATUS NICGetStatsCounters(
    IN  PMP_ADAPTER  Adapter, 
    IN  NDIS_OID     Oid,
    OUT PULONG64     pCounter
    )
/*++
Routine Description:

    Get the value for a statistics OID

Arguments:

    Adapter     Pointer to our adapter 
    Oid         Self-explanatory   
    pCounter    Pointer to receive the value
    
Return Value:

    NDIS_STATUS_SUCCESS
    NDIS_STATUS_NOT_SUPPORTED
    
--*/
{
    NDIS_STATUS     Status = NDIS_STATUS_SUCCESS;

    DBGPRINT(MP_TRACE, ("--> NICGetStatsCounters\n"));

    *pCounter = 0; 

    DumpStatsCounters(Adapter);
            
    switch(Oid)
    {
        case OID_GEN_XMIT_OK:
            *pCounter = Adapter->GoodTransmits;
            break;

        case OID_GEN_RCV_OK:
            *pCounter = Adapter->GoodReceives;
            break;

        case OID_GEN_XMIT_ERROR:
            *pCounter = Adapter->TxAbortExcessCollisions +
                        Adapter->TxDmaUnderrun +
                        Adapter->TxLostCRS +
                        Adapter->TxLateCollisions;
            break;

        case OID_GEN_RCV_ERROR:
            *pCounter = Adapter->RcvCrcErrors +
                        Adapter->RcvAlignmentErrors +
                        Adapter->RcvResourceErrors +
                        Adapter->RcvDmaOverrunErrors +
                        Adapter->RcvRuntErrors;
            break;

        case OID_GEN_RCV_NO_BUFFER:
            *pCounter = Adapter->RcvResourceErrors;
            break;

        case OID_GEN_RCV_CRC_ERROR:
            *pCounter = Adapter->RcvCrcErrors;
            break;

        case OID_GEN_TRANSMIT_QUEUE_LENGTH:
            *pCounter = Adapter->nWaitSend;
            break;

        case OID_802_3_RCV_ERROR_ALIGNMENT:
            *pCounter = Adapter->RcvAlignmentErrors;
            break;

        case OID_802_3_XMIT_ONE_COLLISION:
            *pCounter = Adapter->OneRetry;
            break;

        case OID_802_3_XMIT_MORE_COLLISIONS:
            *pCounter = Adapter->MoreThanOneRetry;
            break;

        case OID_802_3_XMIT_DEFERRED:
            *pCounter = Adapter->TxOKButDeferred;
            break;

        case OID_802_3_XMIT_MAX_COLLISIONS:
            *pCounter = Adapter->TxAbortExcessCollisions;
            break;

        case OID_802_3_RCV_OVERRUN:
            *pCounter = Adapter->RcvDmaOverrunErrors;
            break;

        case OID_802_3_XMIT_UNDERRUN:
            *pCounter = Adapter->TxDmaUnderrun;
            break;

        case OID_802_3_XMIT_HEARTBEAT_FAILURE:
            *pCounter = Adapter->TxLostCRS;
            break;

        case OID_802_3_XMIT_TIMES_CRS_LOST:
            *pCounter = Adapter->TxLostCRS;
            break;

        case OID_802_3_XMIT_LATE_COLLISIONS:
            *pCounter = Adapter->TxLateCollisions;
            break;

        default:
            Status = NDIS_STATUS_NOT_SUPPORTED;
            break;
    }

    DBGPRINT(MP_TRACE, ("<-- NICGetStatsCounters\n"));

    return(Status);
}

NDIS_STATUS NICSetPacketFilter(
    IN PMP_ADAPTER Adapter,
    IN ULONG PacketFilter
    )
/*++
Routine Description:

    This routine will set up the adapter so that it accepts packets 
    that match the specified packet filter.  The only filter bits   
    that can truly be toggled are for broadcast and promiscuous     

Arguments:
    
    Adapter         Pointer to our adapter
    PacketFilter    The new packet filter 
    
Return Value:

    NDIS_STATUS_SUCCESS
    NDIS_STATUS_NOT_SUPPORTED
    
--*/
{
    NDIS_STATUS     Status = NDIS_STATUS_SUCCESS;
    UCHAR           NewParameterField;
    UINT            i;
    BOOLEAN         bResult;

    DBGPRINT(MP_TRACE, ("--> NICSetPacketFilter, PacketFilter=%08x\n", PacketFilter));

    //
    // Need to enable or disable broadcast and promiscuous support depending
    // on the new filter
    //
    NewParameterField = CB_557_CFIG_DEFAULT_PARM15;

    if (PacketFilter & NDIS_PACKET_TYPE_BROADCAST) 
    {
        NewParameterField &= ~CB_CFIG_BROADCAST_DIS;
    }
    else 
    {
        NewParameterField |= CB_CFIG_BROADCAST_DIS;
    }

    if (PacketFilter & NDIS_PACKET_TYPE_PROMISCUOUS) 
    {
        NewParameterField |= CB_CFIG_PROMISCUOUS;
    }
    else 
    {
        NewParameterField &= ~CB_CFIG_PROMISCUOUS;
    }

    do
    {
        if ((Adapter->OldParameterField == NewParameterField ) &&
            !(PacketFilter & NDIS_PACKET_TYPE_ALL_MULTICAST))
        {
            break;
        }

        //
        // Only need to do something to the HW if the filter bits have changed.
        //
        Adapter->OldParameterField = NewParameterField;
        ((PCB_HEADER_STRUC)Adapter->NonTxCmdBlock)->CbCommand = CB_CONFIGURE;
        ((PCB_HEADER_STRUC)Adapter->NonTxCmdBlock)->CbStatus = 0;
        ((PCB_HEADER_STRUC)Adapter->NonTxCmdBlock)->CbLinkPointer = DRIVER_NULL;

        //
        // First fill in the static (end user can't change) config bytes
        //
        Adapter->NonTxCmdBlock->NonTxCb.Config.ConfigBytes[0] = CB_557_CFIG_DEFAULT_PARM0;
        Adapter->NonTxCmdBlock->NonTxCb.Config.ConfigBytes[2] = CB_557_CFIG_DEFAULT_PARM2;
        Adapter->NonTxCmdBlock->NonTxCb.Config.ConfigBytes[3] = CB_557_CFIG_DEFAULT_PARM3;
        Adapter->NonTxCmdBlock->NonTxCb.Config.ConfigBytes[6] = CB_557_CFIG_DEFAULT_PARM6;
        Adapter->NonTxCmdBlock->NonTxCb.Config.ConfigBytes[9] = CB_557_CFIG_DEFAULT_PARM9;
        Adapter->NonTxCmdBlock->NonTxCb.Config.ConfigBytes[10] = CB_557_CFIG_DEFAULT_PARM10;
        Adapter->NonTxCmdBlock->NonTxCb.Config.ConfigBytes[11] = CB_557_CFIG_DEFAULT_PARM11;
        Adapter->NonTxCmdBlock->NonTxCb.Config.ConfigBytes[12] = CB_557_CFIG_DEFAULT_PARM12;
        Adapter->NonTxCmdBlock->NonTxCb.Config.ConfigBytes[13] = CB_557_CFIG_DEFAULT_PARM13;
        Adapter->NonTxCmdBlock->NonTxCb.Config.ConfigBytes[14] = CB_557_CFIG_DEFAULT_PARM14;
        Adapter->NonTxCmdBlock->NonTxCb.Config.ConfigBytes[16] = CB_557_CFIG_DEFAULT_PARM16;
        Adapter->NonTxCmdBlock->NonTxCb.Config.ConfigBytes[17] = CB_557_CFIG_DEFAULT_PARM17;
        Adapter->NonTxCmdBlock->NonTxCb.Config.ConfigBytes[18] = CB_557_CFIG_DEFAULT_PARM18;
        Adapter->NonTxCmdBlock->NonTxCb.Config.ConfigBytes[20] = CB_557_CFIG_DEFAULT_PARM20;

        //
        // Set the Tx underrun retries
        //
        Adapter->NonTxCmdBlock->NonTxCb.Config.ConfigBytes[7] =
            (UCHAR) (CB_557_CFIG_DEFAULT_PARM7 | (Adapter->AiUnderrunRetry << 1));

        //
        // Set the Tx and Rx Fifo limits
        //
        Adapter->NonTxCmdBlock->NonTxCb.Config.ConfigBytes[1] =
            (UCHAR) ((Adapter->AiTxFifo << 4) | Adapter->AiRxFifo);

        //
        // set the MWI enable bit if needed
        //
        if (Adapter->MWIEnable)
            Adapter->NonTxCmdBlock->NonTxCb.Config.ConfigBytes[3] |= CB_CFIG_B3_MWI_ENABLE;

        //
        // Set the Tx and Rx DMA maximum byte count fields.
        //
        if ((Adapter->AiRxDmaCount) || (Adapter->AiTxDmaCount))
        {
            Adapter->NonTxCmdBlock->NonTxCb.Config.ConfigBytes[4] =
                Adapter->AiRxDmaCount;
            Adapter->NonTxCmdBlock->NonTxCb.Config.ConfigBytes[5] =
                (UCHAR) (Adapter->AiTxDmaCount | CB_CFIG_DMBC_EN);
        }
        else
        {
            Adapter->NonTxCmdBlock->NonTxCb.Config.ConfigBytes[4] =
                CB_557_CFIG_DEFAULT_PARM4;
            Adapter->NonTxCmdBlock->NonTxCb.Config.ConfigBytes[5] =
                CB_557_CFIG_DEFAULT_PARM5;
        }

        //
        // Setup for MII or 503 operation.  The CRS+CDT bit should only be
        // set when operating in 503 mode.
        //
        if (Adapter->PhyAddress == 32)
        {
            Adapter->NonTxCmdBlock->NonTxCb.Config.ConfigBytes[8] =
                (CB_557_CFIG_DEFAULT_PARM8 & (~CB_CFIG_503_MII));
            Adapter->NonTxCmdBlock->NonTxCb.Config.ConfigBytes[15] =
                (UCHAR) (NewParameterField | CB_CFIG_CRS_OR_CDT);
        }
        else
        {
            Adapter->NonTxCmdBlock->NonTxCb.Config.ConfigBytes[8] =
                (CB_557_CFIG_DEFAULT_PARM8 | CB_CFIG_503_MII);
            Adapter->NonTxCmdBlock->NonTxCb.Config.ConfigBytes[15] =
                (UCHAR) (NewParameterField & (~CB_CFIG_CRS_OR_CDT));
        }

        //
        // Setup Full duplex stuff
        //

        //
        // If forced to half duplex
        //
        if (Adapter->AiForceDpx == 1) 
	    {
            Adapter->NonTxCmdBlock->NonTxCb.Config.ConfigBytes[19] =
                (CB_557_CFIG_DEFAULT_PARM19 &
                (~(CB_CFIG_FORCE_FDX| CB_CFIG_FDX_ENABLE)));
        }
        //
        // If forced to full duplex
        //
        else if (Adapter->AiForceDpx == 2)
	    {
            Adapter->NonTxCmdBlock->NonTxCb.Config.ConfigBytes[19] =
                (CB_557_CFIG_DEFAULT_PARM19 | CB_CFIG_FORCE_FDX);
        }
        //
        // If auto-duplex
        //
        else 
	    {
            Adapter->NonTxCmdBlock->NonTxCb.Config.ConfigBytes[19] =
                                                CB_557_CFIG_DEFAULT_PARM19;
        }

        //
        // if multicast all is being turned on, set the bit
        //
        if (PacketFilter & NDIS_PACKET_TYPE_ALL_MULTICAST) 
	    {
            Adapter->NonTxCmdBlock->NonTxCb.Config.ConfigBytes[21] =
                                 (CB_557_CFIG_DEFAULT_PARM21 | CB_CFIG_MULTICAST_ALL);
        }
        else 
	    {
            Adapter->NonTxCmdBlock->NonTxCb.Config.ConfigBytes[21] =
                                                CB_557_CFIG_DEFAULT_PARM21;
        }


        //
        // Wait for the SCB to clear before we check the CU status.
        //
        if (!WaitScb(Adapter))
        {
            Status = NDIS_STATUS_HARD_ERRORS;
            break;
        }

        //
        // If we have issued any transmits, then the CU will either be active,
        // or in the suspended state.  If the CU is active, then we wait for
        // it to be suspended.
        //
        if (Adapter->TransmitIdle == FALSE)
        {
            //
            // Wait for suspended state
            //
            MP_STALL_AND_WAIT((Adapter->CSRAddress->ScbStatus & SCB_CUS_MASK) != SCB_CUS_ACTIVE, 5000, bResult);
            if (!bResult)
            {
                MP_SET_HARDWARE_ERROR(Adapter);
                Status = NDIS_STATUS_HARD_ERRORS;
                break;
            }

            //
            // Check the current status of the receive unit
            //
            if ((Adapter->CSRAddress->ScbStatus & SCB_RUS_MASK) != SCB_RUS_IDLE)
            {
                // Issue an RU abort.  Since an interrupt will be issued, the
                // RU will be started by the DPC.
                Status = D100IssueScbCommand(Adapter, SCB_RUC_ABORT, TRUE);
                if (Status != NDIS_STATUS_SUCCESS)
                {
                    break;
                }
            }
            
            if (!WaitScb(Adapter))
            {
                Status = NDIS_STATUS_HARD_ERRORS;
                break;
            }
           
            //
            // Restore the transmit software flags.  After the multicast
            // command is issued, the command unit will be idle, because the
            // EL bit will be set in the multicast commmand block.
            //
            Adapter->TransmitIdle = TRUE;
            Adapter->ResumeWait = TRUE;
        }
        
        //
        // Display config info
        //
        DBGPRINT(MP_INFO, ("Re-Issuing Configure command for filter change\n"));
        DBGPRINT(MP_INFO, ("Config Block at virt addr "PTR_FORMAT", phys address %x\n",
            &((PCB_HEADER_STRUC)Adapter->NonTxCmdBlock)->CbStatus, Adapter->NonTxCmdBlockPhys));

        for (i = 0; i < CB_CFIG_BYTE_COUNT; i++)
            DBGPRINT(MP_INFO, ("  Config byte %x = %.2x\n", i, Adapter->NonTxCmdBlock->NonTxCb.Config.ConfigBytes[i]));

        //
        // Submit the configure command to the chip, and wait for it to complete.
        //
        Adapter->CSRAddress->ScbGeneralPointer = Adapter->NonTxCmdBlockPhys;
        Status = D100SubmitCommandBlockAndWait(Adapter);
        if (Status != NDIS_STATUS_SUCCESS)
        {
            Status = NDIS_STATUS_NOT_ACCEPTED;
        }

    } while (FALSE);

    DBGPRINT_S(Status, ("<-- NICSetPacketFilter, Status=%x\n", Status));

    return(Status);
}

NDIS_STATUS NICSetMulticastList(
    IN  PMP_ADAPTER  Adapter
    )
/*++
Routine Description:

    This routine will set up the adapter for a specified multicast address list
    
Arguments:
    
    Adapter     Pointer to our adapter
    
Return Value:

    NDIS_STATUS_SUCCESS
    NDIS_STATUS_NOT_ACCEPTED
    
--*/
{
    NDIS_STATUS     Status;
    PUCHAR          McAddress;
    UINT            i, j;
    BOOLEAN         bResult;

    DBGPRINT(MP_TRACE, ("--> NICSetMulticastList\n"));

    //
    // Setup the command block for the multicast command.
    //
    for (i = 0; i < Adapter->MCAddressCount; i++)
    {
        DBGPRINT(MP_INFO, ("MC(%d) = %02x-%02x-%02x-%02x-%02x-%02x\n", 
            i,
            Adapter->MCList[i][0],
            Adapter->MCList[i][1],
            Adapter->MCList[i][2],
            Adapter->MCList[i][3],
            Adapter->MCList[i][4],
            Adapter->MCList[i][5]));

        McAddress = &Adapter->NonTxCmdBlock->NonTxCb.Multicast.McAddress[i*ETHERNET_ADDRESS_LENGTH];

        for (j = 0; j < ETH_LENGTH_OF_ADDRESS; j++)
            *(McAddress++) = Adapter->MCList[i][j];
    }

    Adapter->NonTxCmdBlock->NonTxCb.Multicast.McCount =
        (USHORT)(Adapter->MCAddressCount * ETH_LENGTH_OF_ADDRESS);
    ((PCB_HEADER_STRUC)Adapter->NonTxCmdBlock)->CbStatus = 0;
    ((PCB_HEADER_STRUC)Adapter->NonTxCmdBlock)->CbCommand = CB_MULTICAST;

    //
    // Wait for the SCB to clear before we check the CU status.
    //
    if (!WaitScb(Adapter))
    {
        Status = NDIS_STATUS_HARD_ERRORS;
        MP_EXIT;
    }

    //
    // If we have issued any transmits, then the CU will either be active, or
    // in the suspended state.  If the CU is active, then we wait for it to be
    // suspended.
    //
    if (Adapter->TransmitIdle == FALSE)
    {
        //
        // Wait for suspended state
        //
        MP_STALL_AND_WAIT((Adapter->CSRAddress->ScbStatus & SCB_CUS_MASK) != SCB_CUS_ACTIVE, 5000, bResult);
        if (!bResult)
        {
            MP_SET_HARDWARE_ERROR(Adapter);
            Status = NDIS_STATUS_HARD_ERRORS;
        }

        //
        // Restore the transmit software flags.  After the multicast command is
        // issued, the command unit will be idle, because the EL bit will be
        // set in the multicast commmand block.
        //
        Adapter->TransmitIdle = TRUE;
        Adapter->ResumeWait = TRUE;
    }

    //
    // Update the command list pointer.
    //
    Adapter->CSRAddress->ScbGeneralPointer = Adapter->NonTxCmdBlockPhys;

    //
    // Submit the multicast command to the adapter and wait for it to complete.
    //
    Status = D100SubmitCommandBlockAndWait(Adapter);
    if (Status != NDIS_STATUS_SUCCESS)
    {
        Status = NDIS_STATUS_NOT_ACCEPTED;
    }
    
    exit:

    DBGPRINT_S(Status, ("<-- NICSetMulticastList, Status=%x\n", Status));

    return(Status);

}

NDIS_STATUS MPSetInformation(
    IN NDIS_HANDLE MiniportAdapterContext,
    IN NDIS_OID Oid,
    IN PVOID InformationBuffer,
    IN ULONG InformationBufferLength,
    OUT PULONG BytesRead,
    OUT PULONG BytesNeeded
    )
/*++
Routine Description:

    This is the handler for an OID set operation.
    The only operations that really change the configuration of the adapter are
    set PACKET_FILTER, and SET_MULTICAST.       
    
Arguments:
    
    MiniportAdapterContext  Pointer to the adapter structure
    Oid                     Oid for this query
    InformationBuffer       Buffer for information
    InformationBufferLength Size of this buffer
    BytesRead               Specifies how much info is read
    BytesNeeded             In case the buffer is smaller than what we need, tell them how much is needed
    
Return Value:

    NDIS_STATUS_SUCCESS        
    NDIS_STATUS_INVALID_LENGTH 
    NDIS_STATUS_INVALID_OID    
    NDIS_STATUS_NOT_SUPPORTED  
    NDIS_STATUS_NOT_ACCEPTED   
    
--*/
{
    NDIS_STATUS                 Status = NDIS_STATUS_SUCCESS;
    PMP_ADAPTER                 Adapter = (PMP_ADAPTER) MiniportAdapterContext;
    ULONG                       PacketFilter;
    NDIS_DEVICE_POWER_STATE     NewPowerState;
    ULONG                       CustomDriverSet;

#if OFFLOAD
    PNDIS_TASK_OFFLOAD_HEADER   pNdisTaskOffloadHdr;
    PNDIS_TASK_OFFLOAD          TaskOffload;
    PNDIS_TASK_OFFLOAD          TmpOffload;
    PNDIS_TASK_TCP_IP_CHECKSUM  pTcpIpChecksumTask;
    PNDIS_TASK_TCP_LARGE_SEND   pNdisTaskTcpLargeSend;
    UINT                        i;
#endif    

    
    DBGPRINT(MP_TRACE, ("====> MPSetInformation\n"));

    *BytesRead = 0;
    *BytesNeeded = 0;

    switch(Oid)
    {
        case OID_802_3_MULTICAST_LIST:
            //
            // Verify the length
            //
            if (InformationBufferLength % ETH_LENGTH_OF_ADDRESS != 0)
            {
                return(NDIS_STATUS_INVALID_LENGTH);
            }

            //
            // Save the number of MC list size
            //
            Adapter->MCAddressCount = InformationBufferLength / ETH_LENGTH_OF_ADDRESS;
            ASSERT(Adapter->MCAddressCount <= NIC_MAX_MCAST_LIST);

            //
            // Save the MC list
            //
            NdisMoveMemory(
                Adapter->MCList, 
                InformationBuffer, 
                InformationBufferLength);

            *BytesRead = InformationBufferLength;
            NdisDprAcquireSpinLock(&Adapter->Lock);
            NdisDprAcquireSpinLock(&Adapter->RcvLock);
            
            Status = NICSetMulticastList(Adapter);

            NdisDprReleaseSpinLock(&Adapter->RcvLock);
            NdisDprReleaseSpinLock(&Adapter->Lock);
            break;

        case OID_GEN_CURRENT_PACKET_FILTER:
            //
            // Verify the Length
            //
            if (InformationBufferLength != sizeof(ULONG))
            {
                return(NDIS_STATUS_INVALID_LENGTH);
            }

            *BytesRead = InformationBufferLength;
            
            NdisMoveMemory(&PacketFilter, InformationBuffer, sizeof(ULONG));

            //
            // any bits not supported?
            //
            if (PacketFilter & ~NIC_SUPPORTED_FILTERS)
            {
                return(NDIS_STATUS_NOT_SUPPORTED);
            }

            //
            // any filtering changes?
            //
            if (PacketFilter == Adapter->PacketFilter)
            {
                return(NDIS_STATUS_SUCCESS);
            }

            NdisDprAcquireSpinLock(&Adapter->Lock);
            NdisDprAcquireSpinLock(&Adapter->RcvLock);
            
            if (MP_TEST_FLAG(Adapter, fMP_ADAPTER_LINK_DETECTION))
            {
                ASSERT(!Adapter->bSetPending);
                Adapter->bSetPending = TRUE;
                Adapter->SetRequest.Oid = Oid;                       
                Adapter->SetRequest.InformationBuffer = InformationBuffer;                       
                Adapter->SetRequest.InformationBufferLength = InformationBufferLength;
                Adapter->SetRequest.BytesRead = BytesRead;                       
                Adapter->SetRequest.BytesNeeded = BytesNeeded;                       

                NdisDprReleaseSpinLock(&Adapter->RcvLock);
                NdisDprReleaseSpinLock(&Adapter->Lock);
                Status = NDIS_STATUS_PENDING;   
                break;
            }

            Status = NICSetPacketFilter(
                         Adapter,
                         PacketFilter);

            NdisDprReleaseSpinLock(&Adapter->RcvLock);
            NdisDprReleaseSpinLock(&Adapter->Lock);
            if (Status == NDIS_STATUS_SUCCESS)
            {
                Adapter->PacketFilter = PacketFilter;
            }

            break;

        case OID_GEN_CURRENT_LOOKAHEAD:
            //
            // Verify the Length
            //
            if (InformationBufferLength < sizeof(ULONG))
            {
                *BytesNeeded = sizeof(ULONG);
                return(NDIS_STATUS_INVALID_LENGTH);
            }

            NdisMoveMemory(&Adapter->ulLookAhead, InformationBuffer, sizeof(ULONG));
            
            *BytesRead = sizeof(ULONG);
            Status = NDIS_STATUS_SUCCESS;
            break;


        case OID_PNP_SET_POWER:

            DBGPRINT(MP_LOUD, ("SET: Power State change, "PTR_FORMAT"!!!\n", InformationBuffer));

            if (InformationBufferLength != sizeof(NDIS_DEVICE_POWER_STATE ))
            {
                return(NDIS_STATUS_INVALID_LENGTH);
            }

            NewPowerState = *(PNDIS_DEVICE_POWER_STATE UNALIGNED)InformationBuffer;

            //
            // Set the power state - Cannot fail this request
            //
            Status = MPSetPower(Adapter ,NewPowerState );

            if (Status == NDIS_STATUS_PENDING)
            {
                Adapter->bSetPending = TRUE;
                Adapter->SetRequest.Oid = OID_PNP_SET_POWER;
                Adapter->SetRequest.BytesRead = BytesRead;
                break;
            }
            if (Status != NDIS_STATUS_SUCCESS)
            {
                DBGPRINT(MP_ERROR, ("SET Power: Hardware error !!!\n"));
                break;
            }
        
            *BytesRead = sizeof(NDIS_DEVICE_POWER_STATE);
            Status = NDIS_STATUS_SUCCESS; 
            break;

        case OID_PNP_ADD_WAKE_UP_PATTERN:
            //
            // call a function that would program the adapter's wake
            // up pattern, return success
            //
            DBGPRINT(MP_LOUD, ("SET: Add Wake Up Pattern, !!!\n"));

            if (MPIsPoMgmtSupported(Adapter) )
            {
                Status = MPAddWakeUpPattern(Adapter,
                                            InformationBuffer, 
                                            InformationBufferLength, 
                                            BytesRead, 
                                            BytesNeeded); 
            }
            else
            {
                Status = NDIS_STATUS_NOT_SUPPORTED;
            }
            break;

    
        case OID_PNP_REMOVE_WAKE_UP_PATTERN:
            DBGPRINT(MP_LOUD, ("SET: Got a WakeUpPattern REMOVE Call\n"));
            //
            // call a function that would remove the adapter's wake
            // up pattern, return success
            //
            if (MPIsPoMgmtSupported(Adapter) )
            {
                Status = MPRemoveWakeUpPattern(Adapter, 
                                               InformationBuffer, 
                                               InformationBufferLength,
                                               BytesRead,
                                               BytesNeeded);

            }
            else
            {
                Status = NDIS_STATUS_NOT_SUPPORTED;
            }
            break;

        case OID_PNP_ENABLE_WAKE_UP:
            DBGPRINT(MP_LOUD, ("SET: Got a EnableWakeUp Call, "PTR_FORMAT"\n",InformationBuffer));
            //
            // call a function that would enable wake up on the adapter
            // return success
            //
            if (MPIsPoMgmtSupported(Adapter) )
            {
                ULONG       WakeUpEnable;
                NdisMoveMemory(&WakeUpEnable, InformationBuffer,sizeof(ULONG));
                //
                // The WakeUpEable can only be 0, or NDIS_PNP_WAKE_UP_PATTERN_MATCH since the driver only
                // supports wake up pattern match
                //
                if ((WakeUpEnable != 0)
                       && ((WakeUpEnable & NDIS_PNP_WAKE_UP_PATTERN_MATCH) != NDIS_PNP_WAKE_UP_PATTERN_MATCH ))
                {
                    Status = NDIS_STATUS_NOT_SUPPORTED;
                    Adapter->WakeUpEnable = 0;    
                    break;
                }
                //
                // When the driver goes to low power state, it would check WakeUpEnable to decide
                // which wake up methed it should use to wake up the machine. If WakeUpEnable is 0,
                // no wake up method is enabled.
                //
                Adapter->WakeUpEnable = WakeUpEnable;
                
                *BytesRead = sizeof(ULONG);                         
                Status = NDIS_STATUS_SUCCESS; 
            }
            else
            {
                Status = NDIS_STATUS_NOT_SUPPORTED;
            }

            break;

            //
            // this OID is for showing how to work with driver specific (custom)
            // OIDs and the NDIS 5 WMI interface using GUIDs
            //
        case OID_CUSTOM_DRIVER_SET:
            DBGPRINT(MP_INFO, ("OID_CUSTOM_DRIVER_SET got a set\n"));
            if (InformationBufferLength < sizeof(ULONG))
            {
                *BytesNeeded = sizeof(ULONG);
                Status = NDIS_STATUS_INVALID_LENGTH;
                break;
            }
            //
            // The driver need to validate the set data in the buffer
            //
            NdisMoveMemory(&CustomDriverSet, InformationBuffer, sizeof(ULONG));
            if ((CustomDriverSet < CUSTOM_DRIVER_SET_MIN) 
                || (CustomDriverSet > CUSTOM_DRIVER_SET_MAX))
            {
               Status = NDIS_STATUS_INVALID_DATA;
               break;
            }
            *BytesRead = sizeof(ULONG);
            
            Adapter->CustomDriverSet = CustomDriverSet;
            //
            // Validate the content of the data
            //
            // Adapter->CustomDriverSet = (ULONG) *(PULONG)(InformationBuffer);
            break;

#if OFFLOAD     
        
        case OID_TCP_TASK_OFFLOAD:
            //
            // Disable all the existing capabilities whenever task offload is updated
            //
            DisableOffload(Adapter);

            if (InformationBufferLength < sizeof(NDIS_TASK_OFFLOAD_HEADER))
            {   
                return NDIS_STATUS_INVALID_LENGTH;
            }

            *BytesRead = sizeof(NDIS_TASK_OFFLOAD_HEADER);
            //
            // Assume miniport only supports IEEE_802_3_Encapsulation 
            // Check to make sure that TCP/IP passed down the correct encapsulation type
            //
            pNdisTaskOffloadHdr = (PNDIS_TASK_OFFLOAD_HEADER)InformationBuffer;
            if (pNdisTaskOffloadHdr->EncapsulationFormat.Encapsulation != IEEE_802_3_Encapsulation)
            {
                pNdisTaskOffloadHdr->OffsetFirstTask = 0;    
                return NDIS_STATUS_INVALID_DATA;
            }
            //
            // No offload task to be set
            //
            if (pNdisTaskOffloadHdr->OffsetFirstTask == 0)
            {
                DBGPRINT(MP_WARN, ("No offload task is set!!\n"));
                return NDIS_STATUS_SUCCESS;
            }
            //
            // OffsetFirstTask is not valid
            //
            if (pNdisTaskOffloadHdr->OffsetFirstTask < pNdisTaskOffloadHdr->Size)
            {
                pNdisTaskOffloadHdr->OffsetFirstTask = 0;
                return NDIS_STATUS_FAILURE;

            }
            //
            // The length can't hold one task
            // 
            if (InformationBufferLength < 
                    (pNdisTaskOffloadHdr->OffsetFirstTask + sizeof(NDIS_TASK_OFFLOAD))) 
            {
                DBGPRINT(MP_WARN, ("response of task offload does not have sufficient space even for 1 offload task!!\n"));
                Status = NDIS_STATUS_INVALID_LENGTH;
                break;
            }

            //
            // Copy Encapsulation format into adapter, later the miniport may use it
            // to get Encapsulation header size
            //
            NdisMoveMemory(&(Adapter->EncapsulationFormat), 
                            &(pNdisTaskOffloadHdr->EncapsulationFormat),
                            sizeof(NDIS_ENCAPSULATION_FORMAT));
            
            ASSERT(pNdisTaskOffloadHdr->EncapsulationFormat.Flags.FixedHeaderSize == 1);
            
            //
            // Check to make sure we support the task offload requested
            //
            TaskOffload = (NDIS_TASK_OFFLOAD *) 
                          ( (PUCHAR)pNdisTaskOffloadHdr + pNdisTaskOffloadHdr->OffsetFirstTask);

            TmpOffload = TaskOffload;

            //
            // Check the task in the buffer and enable the offload capabilities
            // 
            while (TmpOffload) 
            {
                *BytesRead += FIELD_OFFSET(NDIS_TASK_OFFLOAD, TaskBuffer);
                
                switch (TmpOffload->Task)
                {
                
                case TcpIpChecksumNdisTask:
                    //
                    // Invalid information buffer length
                    // 
                    if (InformationBufferLength < *BytesRead + sizeof(NDIS_TASK_TCP_IP_CHECKSUM))
                    {
                        *BytesNeeded = *BytesRead + sizeof(NDIS_TASK_TCP_IP_CHECKSUM);
                        return NDIS_STATUS_INVALID_LENGTH;
                    }
                    //
                    //Check version 
                    //
                    for (i = 0; i < OffloadTasksCount; i++) 
                    {
                        if (OffloadTasks[i].Task == TmpOffload->Task &&
                            OffloadTasks[i].Version == TmpOffload->Version )
                        {
                            break;
                        }
                    }
                    // 
                    // Version is mismatched
                    // 
                    if (i == OffloadTasksCount) 
                    {
                         return NDIS_STATUS_NOT_SUPPORTED;
                    }
                        
                    //
                    // This miniport support TCP/IP checksum offload only with sending TCP
                    // and IP checksum with TCP/IP options. 
                    // check if the fields in NDIS_TASK_TCP_IP_CHECKSUM is set correctly
                    //
                    Adapter->NicTaskOffload.ChecksumOffload = 1;
                    
                    pTcpIpChecksumTask = (PNDIS_TASK_TCP_IP_CHECKSUM) TmpOffload->TaskBuffer;

                    if (pTcpIpChecksumTask->V4Transmit.TcpChecksum) 
                    {   
                        //
                        // If miniport doesn't support sending TCP checksum, we can't enable
                        // this capability
                        // 
                        if (TcpIpChecksumTask.V4Transmit.TcpChecksum == 0 )
                        {
                            return NDIS_STATUS_NOT_SUPPORTED;
                        }
                        
                        DBGPRINT (MP_WARN, ("Set Sending TCP offloading.\n"));    
                        //
                        // Enable sending TCP checksum
                        //
                        Adapter->NicChecksumOffload.DoXmitTcpChecksum = 1;
                    }

                    //
                    // left for recieve and other IP and UDP checksum offload
                    //
                    if (pTcpIpChecksumTask->V4Transmit.IpChecksum) 
                    {
                        //
                        // If the miniport doesn't support sending IP checksum, we can't enable
                        // this capabilities
                        // 
                        if (TcpIpChecksumTask.V4Transmit.IpChecksum == 0)
                        {
                            return NDIS_STATUS_NOT_SUPPORTED;
                        }
                        
                        DBGPRINT (MP_WARN, ("Set Sending IP offloading.\n"));    
                        //
                        // Enable sending IP checksum
                        //
                        Adapter->NicChecksumOffload.DoXmitIpChecksum = 1;
                    }
                    if (pTcpIpChecksumTask->V4Receive.TcpChecksum)
                    {
                        //
                        // If the miniport doesn't support receiving TCP checksum, we can't
                        // enable this capability
                        // 
                        if (TcpIpChecksumTask.V4Receive.TcpChecksum == 0)
                        {
                            return NDIS_STATUS_NOT_SUPPORTED;
                        }
                        DBGPRINT (MP_WARN, ("Set recieve TCP offloading.\n"));    
                        //
                        // Enable recieving TCP checksum
                        //
                        Adapter->NicChecksumOffload.DoRcvTcpChecksum = 1;
                    }
                    if (pTcpIpChecksumTask->V4Receive.IpChecksum)
                    {
                        //
                        // If the miniport doesn't support receiving IP checksum, we can't
                        // enable this capability
                        //
                        if (TcpIpChecksumTask.V4Receive.IpChecksum == 0)
                        {
                            return NDIS_STATUS_NOT_SUPPORTED;
                        }
                        DBGPRINT (MP_WARN, ("Set Recieve IP offloading.\n"));    
                        //
                        // Enable recieving IP checksum
                        //
                        Adapter->NicChecksumOffload.DoRcvIpChecksum = 1;
                    }

                    if (pTcpIpChecksumTask->V4Transmit.UdpChecksum) 
                    {
                        //
                        // If the miniport doesn't support sending UDP checksum, we can't
                        // enable this capability
                        // 
                        if (TcpIpChecksumTask.V4Transmit.UdpChecksum == 0)
                        {
                            return NDIS_STATUS_NOT_SUPPORTED;
                        }
                        
                        DBGPRINT (MP_WARN, ("Set Sending UDP offloading.\n"));    
                        //
                        // Enable sending UDP checksum
                        //
                        Adapter->NicChecksumOffload.DoXmitUdpChecksum = 1;
                    }
                    if (pTcpIpChecksumTask->V4Receive.UdpChecksum)
                    {
                        //
                        // IF the miniport doesn't support receiving UDP checksum, we can't
                        // enable this capability
                        // 
                        if (TcpIpChecksumTask.V4Receive.UdpChecksum == 0)
                        {
                            return NDIS_STATUS_NOT_SUPPORTED;
                        }
                        DBGPRINT (MP_WARN, ("Set recieve UDP offloading.\n"));    
                        //
                        // Enable receiving UDP checksum
                        //
                        Adapter->NicChecksumOffload.DoRcvUdpChecksum = 1;
                    }
                    // 
                    // check for V6 setting, because this miniport doesn't support any of
                    // checksum offload for V6, so we just return NDIS_STATUS_NOT_SUPPORTED
                    // if the protocol tries to set these capabilities
                    //
                    if (pTcpIpChecksumTask->V6Transmit.TcpChecksum
                            || pTcpIpChecksumTask->V6Transmit.UdpChecksum
                            || pTcpIpChecksumTask->V6Receive.TcpChecksum
                            || pTcpIpChecksumTask->V6Receive.UdpChecksum)
                    {
                        return NDIS_STATUS_NOT_SUPPORTED;
                    }
                    
                    *BytesRead += sizeof(NDIS_TASK_TCP_IP_CHECKSUM);
                    break;

                case TcpLargeSendNdisTask: 
                    //
                    // Invalid information buffer length
                    // 
                    if (InformationBufferLength < *BytesRead + sizeof(NDIS_TASK_TCP_LARGE_SEND))
                    {
                        *BytesNeeded = *BytesRead + sizeof(NDIS_TASK_TCP_LARGE_SEND);
                        return NDIS_STATUS_INVALID_LENGTH;
                    }
                    //
                    // Check version
                    // 
                    for (i = 0; i < OffloadTasksCount; i++) 
                    {
                        if (OffloadTasks[i].Task == TmpOffload->Task &&
                            OffloadTasks[i].Version == TmpOffload->Version )
                        {
                            break;
                        }
                    }
                    if (i == OffloadTasksCount) 
                    {
                         return NDIS_STATUS_NOT_SUPPORTED;
                    }

                        
                    pNdisTaskTcpLargeSend = (PNDIS_TASK_TCP_LARGE_SEND) TmpOffload->TaskBuffer;

                    //
                    // Check maximum offload size, if the size is greater than the maximum
                    // size of the miniport can handle, return NDIS_STATUS_NOT_SUPPORTED.
                    //
                    if (pNdisTaskTcpLargeSend->MaxOffLoadSize > TcpLargeSendTask.MaxOffLoadSize
                        || pNdisTaskTcpLargeSend->MinSegmentCount < TcpLargeSendTask.MinSegmentCount)
                    {
                        return NDIS_STATUS_NOT_SUPPORTED;
                    }
                    
                    //
                    // If the miniport doesn't support TCP or IP options, but the protocol
                    // is setting such information, return NDIS_STATUS_NOT_SUPPORTED.
                    // 
                    if ((pNdisTaskTcpLargeSend->TcpOptions && !TcpLargeSendTask.TcpOptions)
                            || (pNdisTaskTcpLargeSend->IpOptions && !TcpLargeSendTask.IpOptions))
                    {
                        return NDIS_STATUS_NOT_SUPPORTED;
                    }
                    //
                    // Store the valid setting information into adapter
                    // 
                    Adapter->LargeSendInfo.MaxOffLoadSize = pNdisTaskTcpLargeSend->MaxOffLoadSize;
                    Adapter->LargeSendInfo.MinSegmentCount = pNdisTaskTcpLargeSend->MinSegmentCount;

                    Adapter->LargeSendInfo.TcpOptions = pNdisTaskTcpLargeSend->TcpOptions;
                    Adapter->LargeSendInfo.IpOptions = pNdisTaskTcpLargeSend->IpOptions;

                    //
                    // Everythins is OK, enable large send offload capabilities
                    // 
                    Adapter->NicTaskOffload.LargeSendOffload = 1;
                    
                    *BytesRead += sizeof(NDIS_TASK_TCP_LARGE_SEND);
                    break;

                default:
                    //
                    // Because this miniport doesn't implement IPSec offload, so it doesn't
                    // support IPSec offload. Tasks other then these 3 task are not supported
                    // 
                    return NDIS_STATUS_NOT_SUPPORTED;
                }

                //
                // Go on to the next offload structure
                //
                if (TmpOffload->OffsetNextTask) 
                {
                    TmpOffload = (PNDIS_TASK_OFFLOAD)
                                 ((PUCHAR) TmpOffload + TmpOffload->OffsetNextTask);
                }
                else 
                {
                    TmpOffload = NULL;
                }

            } // while

            break;
#endif

        default:
            Status = NDIS_STATUS_NOT_SUPPORTED;
            break;

    }

  
    DBGPRINT(MP_TRACE, ("<==== MPSetInformationSet, OID=0x%08x, Status=%x\n", Oid, Status));

    return(Status);
}


VOID
MPSetPowerD0(
    PMP_ADAPTER  Adapter
    )
/*++
Routine Description:

    This routine is called when the adapter receives a SetPower 
    to D0.
    
Arguments:
    
    Adapter                 Pointer to the adapter structure
    PowerState              NewPowerState
    
Return Value:

    
--*/
{
    NDIS_STATUS    Status;
    //
    // MPSetPowerD0Private Initializes the adapte, issues a selective reset.
    // 
    MPSetPowerD0Private (Adapter);       
    Adapter->CurrentPowerState = NdisDeviceStateD0;
    //
    // Set up the packet filter
    //
    NdisDprAcquireSpinLock(&Adapter->Lock);
    Status = NICSetPacketFilter(
                 Adapter,
                 Adapter->OldPacketFilter);
    //
    // If Set Packet Filter succeeds, restore the old packet filter
    // 
    if (Status == NDIS_STATUS_SUCCESS)
    {
        Adapter->PacketFilter = Adapter->OldPacketFilter;
    }
    //
    // Set up the multicast list address
    //
    NdisDprAcquireSpinLock(&Adapter->RcvLock);

    Status = NICSetMulticastList(Adapter);

    NICStartRecv(Adapter);

    NdisDprReleaseSpinLock(&Adapter->RcvLock);
    
    NdisDprReleaseSpinLock(&Adapter->Lock);

    //
    // Enable the interrup, so the driver can send/receive packets
    //
    NICEnableInterrupt(Adapter);
}

NDIS_STATUS
MPSetPowerLow(
    PMP_ADAPTER              Adapter ,
    NDIS_DEVICE_POWER_STATE  PowerState 
    )
/*++
Routine Description:

    This routine is called when the adapter receives a SetPower 
    to a PowerState > D0
    
Arguments:
    
    Adapter                 Pointer to the adapter structure
    PowerState              NewPowerState
    
Return Value:
    NDIS_STATUS_SUCCESS
    NDIS_STATUS_PENDING
    NDIS_STATUS_HARD_ERRORS
    
--*/
{

    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;

    do
    {
        Adapter->NextPowerState = PowerState;

        //        
        // Stop sending packets. Create a new flag and make it part 
        // of the Send Fail Mask
        //

        //
        // Stop hardware from receiving packets - Set the RU to idle 
        //
        
        //
        // Check the current status of the receive unit
        //
        if ((Adapter->CSRAddress->ScbStatus & SCB_RUS_MASK) != SCB_RUS_IDLE)
        {
            //
            // Issue an RU abort.  Since an interrupt will be issued, the
            // RU will be started by the DPC.
            //
            Status = D100IssueScbCommand(Adapter, SCB_RUC_ABORT, TRUE);
        }

        if (Status != NDIS_STATUS_SUCCESS)
        {
            break;
        }

        //
        // If there are any outstanding Receive packets, return NDIS_STATUS_PENDING,
        // When all the packets are returned later, the driver will complete the request
        //
        if (Adapter->PoMgmt.OutstandingRecv != 0)
        {
            Status = NDIS_STATUS_PENDING;
            break;
        }

        //
        // Wait for all incoming sends to complete
        //
       
        //
        // MPSetPowerLowPrivate first disables the interrupt, acknowledges all the pending 
        // interrupts and sets pAdapter->CurrentPowerState to the given low power state
        // then starts Hardware specific part of the transition to low power state
        // Setting up wake-up patterns, filters, wake-up events etc
        //
        NdisMSynchronizeWithInterrupt(
                &Adapter->Interrupt,
                (PVOID)MPSetPowerLowPrivate,
                Adapter);

        Status = NDIS_STATUS_SUCCESS;

    } while (FALSE);

    return Status;
}

VOID
MpSetPowerLowComplete(
    IN PMP_ADAPTER Adapter
    )
/*++
Routine Description:

    This routine when all the packets are returned to the driver and the driver has a pending OID to
    set it to lower power state 
    
Arguments:
    
    Adapter                 Pointer to the adapter structure
    
Return Value:

NOTE: this function is called with RcvLock held

--*/
{
    NDIS_STATUS        Status = NDIS_STATUS_SUCCESS;

    NdisDprReleaseSpinLock(&Adapter->RcvLock);
    //
    // MPSetPowerLowPrivate first disables the interrupt, acknowledges all the pending 
    // interrupts and sets pAdapter->CurrentPowerState to the given low power state
    // then starts Hardware specific part of the transition to low power state
    // Setting up wake-up patterns, filters, wake-up events etc
    //
    NdisMSynchronizeWithInterrupt(
            &Adapter->Interrupt,
            (PVOID)MPSetPowerLowPrivate,
            Adapter);

    Adapter->bSetPending = FALSE;
    *Adapter->SetRequest.BytesRead = sizeof(NDIS_DEVICE_POWER_STATE); 
    NdisMSetInformationComplete(Adapter->AdapterHandle, Status);
    
    NdisDprAcquireSpinLock(&Adapter->RcvLock);
}



NDIS_STATUS
MPSetPower(
    PMP_ADAPTER     Adapter ,
    NDIS_DEVICE_POWER_STATE   PowerState 
    )
/*++
Routine Description:

    This routine is called when the adapter receives a SetPower 
    request. It redirects the call to an appropriate routine to
    Set the New PowerState
    
Arguments:
    
    Adapter                 Pointer to the adapter structure
    PowerState              NewPowerState
    
Return Value:
   
    NDIS_STATUS_SUCCESS
    NDIS_STATUS_PENDING
    NDIS_STATUS_HARDWARE_ERROR

    
--*/
{
    NDIS_STATUS      Status = NDIS_STATUS_SUCCESS;
    
    if (PowerState == NdisDeviceStateD0)
    {
        MPSetPowerD0 (Adapter);
    }
    else
    {
        Status = MPSetPowerLow (Adapter, PowerState);
    }
    
    return Status;
}




VOID
MPFillPoMgmtCaps (
    IN PMP_ADAPTER                 pAdapter, 
    IN OUT PNDIS_PNP_CAPABILITIES  pPower_Management_Capabilities, 
    IN OUT PNDIS_STATUS            pStatus,
    IN OUT PULONG                  pulInfoLen
    )
/*++
Routine Description:

    Fills in the Power  Managment structure depending the capabilities of 
    the software driver and the card.

    Currently this is only supported on 82559 Version of the driver

Arguments:
    
    Adapter                 Pointer to the adapter structure
    pPower_Management_Capabilities - Power management struct as defined in the DDK, 
    pStatus                 Status to be returned by the request,
    pulInfoLen              Length of the pPowerManagmentCapabilites
    
Return Value:

    Success or failure depending on the type of card
--*/

{

    BOOLEAN bIsPoMgmtSupported; 
    
    bIsPoMgmtSupported = MPIsPoMgmtSupported(pAdapter);

    if (bIsPoMgmtSupported == TRUE)
    {
        pPower_Management_Capabilities->Flags = NDIS_DEVICE_WAKE_UP_ENABLE ;
        pPower_Management_Capabilities->WakeUpCapabilities.MinMagicPacketWakeUp = NdisDeviceStateUnspecified;
        pPower_Management_Capabilities->WakeUpCapabilities.MinPatternWakeUp = NdisDeviceStateD3;
        pPower_Management_Capabilities->WakeUpCapabilities.MinLinkChangeWakeUp  = NdisDeviceStateUnspecified;
        *pulInfoLen = sizeof (*pPower_Management_Capabilities);
        *pStatus = NDIS_STATUS_SUCCESS;
    }
    else
    {
        NdisZeroMemory (pPower_Management_Capabilities, sizeof(*pPower_Management_Capabilities));
        *pStatus = NDIS_STATUS_NOT_SUPPORTED;
        *pulInfoLen = 0;
            
    }
}

NDIS_STATUS
MPAddWakeUpPattern(
    IN PMP_ADAPTER  pAdapter,
    IN PVOID        InformationBuffer, 
    IN UINT         InformationBufferLength,
    OUT PULONG      BytesRead,
    OUT PULONG      BytesNeeded   
    )
/*++
Routine Description:

    This routine will allocate a local memory structure, copy the pattern, 
    insert the pattern into a linked list and return success

    We are gauranteed that we wll get only one request at a time, so this is implemented
    without locks.
    
Arguments:
    
    Adapter                 Adapter structure
    InformationBuffer       Wake up Pattern
    InformationBufferLength Wake Up Pattern Length
    
Return Value:

    Success - if successful.
    NDIS_STATUS_FAILURE - if memory allocation fails. 
    
--*/
{

    NDIS_STATUS             Status = NDIS_STATUS_FAILURE;
    PMP_WAKE_PATTERN        pWakeUpPattern = NULL;
    UINT                    AllocationLength = 0;
    PNDIS_PM_PACKET_PATTERN pPmPattern = NULL;
    ULONG                   Signature = 0;
    ULONG                   CopyLength = 0;
    
    do
    {
        pPmPattern = (PNDIS_PM_PACKET_PATTERN) InformationBuffer;

        if (InformationBufferLength < sizeof(NDIS_PM_PACKET_PATTERN))
        {
            Status = NDIS_STATUS_BUFFER_TOO_SHORT;
            
            *BytesNeeded = sizeof(NDIS_PM_PACKET_PATTERN);
            break;
        }
        if (InformationBufferLength < pPmPattern->PatternOffset + pPmPattern->PatternSize)
        {
            Status = NDIS_STATUS_BUFFER_TOO_SHORT;
            
            *BytesNeeded = pPmPattern->PatternOffset + pPmPattern->PatternSize;
            break;
        }
        
        *BytesRead = pPmPattern->PatternOffset + pPmPattern->PatternSize;
        
        //
        // Calculate the e100 signature
        //
        Status = MPCalculateE100PatternForFilter (
            (PUCHAR)pPmPattern+ pPmPattern->PatternOffset,
            pPmPattern->PatternSize,
            (PUCHAR)pPmPattern +sizeof(NDIS_PM_PACKET_PATTERN),
            pPmPattern->MaskSize,
            &Signature );
        
        if ( Status != NDIS_STATUS_SUCCESS)
        {
            break;
        }

        CopyLength = pPmPattern->PatternOffset + pPmPattern->PatternSize;
        
        //
        // Allocate the memory to hold the WakeUp Pattern
        //
        AllocationLength = sizeof (MP_WAKE_PATTERN) + CopyLength;
        
        Status = MP_ALLOCMEMTAG (&pWakeUpPattern, AllocationLength);

        if (Status != NDIS_STATUS_SUCCESS)
        {
            pWakeUpPattern = NULL;
            break;
        }

        //
        // Initialize pWakeUpPattern
        //
        NdisZeroMemory (pWakeUpPattern, AllocationLength);

        pWakeUpPattern->AllocationSize = AllocationLength;
        
        pWakeUpPattern->Signature = Signature;

        //
        // Copy the pattern into local memory
        //
        NdisMoveMemory (&pWakeUpPattern->Pattern[0], InformationBuffer, CopyLength);
            
        //
        // Insert the pattern into the list 
        //
        NdisInterlockedInsertHeadList (&pAdapter->PoMgmt.PatternList, 
                                        &pWakeUpPattern->linkListEntry, 
                                        &pAdapter->Lock);

        Status = NDIS_STATUS_SUCCESS;

    } while (FALSE);

    return Status;
}

NDIS_STATUS
MPRemoveWakeUpPattern(
    IN PMP_ADAPTER  pAdapter,
    IN PVOID        InformationBuffer, 
    IN UINT         InformationBufferLength,
    OUT PULONG      BytesRead,
    OUT PULONG      BytesNeeded
    )
/*++
Routine Description:

    This routine will walk the list of wake up pattern and attempt to match the wake up pattern. 
    If it finds a copy , it will remove that WakeUpPattern     

Arguments:
    
    Adapter                 Adapter structure
    InformationBuffer       Wake up Pattern
    InformationBufferLength Wake Up Pattern Length
    
Return Value:

    Success - if successful.
    NDIS_STATUS_FAILURE - if memory allocation fails. 
    
--*/
{

    NDIS_STATUS              Status = NDIS_STATUS_FAILURE;
    PNDIS_PM_PACKET_PATTERN  pReqPattern = (PNDIS_PM_PACKET_PATTERN)InformationBuffer;
    PLIST_ENTRY              pPatternEntry = ListNext(&pAdapter->PoMgmt.PatternList) ;

    do
    {
        
        if (InformationBufferLength < sizeof(NDIS_PM_PACKET_PATTERN))
        {
            Status = NDIS_STATUS_BUFFER_TOO_SHORT;
            
            *BytesNeeded = sizeof(NDIS_PM_PACKET_PATTERN);
            break;
        }
        if (InformationBufferLength < pReqPattern->PatternOffset + pReqPattern->PatternSize)
        {
            Status = NDIS_STATUS_BUFFER_TOO_SHORT;
            
            *BytesNeeded = pReqPattern->PatternOffset + pReqPattern->PatternSize;
            break;
        }
        
        *BytesRead = pReqPattern->PatternOffset + pReqPattern->PatternSize;
    	
    
        while (pPatternEntry != (&pAdapter->PoMgmt.PatternList))
        {
            BOOLEAN                  bIsThisThePattern = FALSE;
            PMP_WAKE_PATTERN         pWakeUpPattern = NULL;
            PNDIS_PM_PACKET_PATTERN  pCurrPattern = NULL;;

            //
            // initialize local variables
            //
            pWakeUpPattern = CONTAINING_RECORD(pPatternEntry, MP_WAKE_PATTERN, linkListEntry);

            pCurrPattern = (PNDIS_PM_PACKET_PATTERN)&pWakeUpPattern->Pattern[0];

            //
            // increment the iterator
            //
            pPatternEntry = ListNext (pPatternEntry);

            //
            // Begin Check : Is (pCurrPattern  == pReqPattern) 
            //
            bIsThisThePattern = MPAreTwoPatternsEqual(pReqPattern, pCurrPattern);
                                                      

            if (bIsThisThePattern == TRUE)
            {
                //
                // we have a match - remove the entry
                //
                RemoveEntryList (&pWakeUpPattern->linkListEntry);

                //
                // Free the entry
                //
                MP_FREEMEM (pWakeUpPattern, pWakeUpPattern->AllocationSize, 0);
                
                Status = NDIS_STATUS_SUCCESS;
                break;
            }

        } 
    }
    while (FALSE);
    
    return Status;
}



VOID
MPRemoveAllWakeUpPatterns(
    PMP_ADAPTER pAdapter
    )
/*++
Routine Description:

    This routine will walk the list of wake up pattern and free it 

Arguments:
    
    Adapter                 Adapter structure
    
Return Value:

    Success - if successful.
    
--*/
{

    PLIST_ENTRY  pPatternEntry = ListNext(&pAdapter->PoMgmt.PatternList) ;
    
    while (pPatternEntry != (&pAdapter->PoMgmt.PatternList))
    {
        PMP_WAKE_PATTERN  pWakeUpPattern = NULL;

        //
        // initialize local variables
        //
        pWakeUpPattern = CONTAINING_RECORD(pPatternEntry, MP_WAKE_PATTERN,linkListEntry);

        //
        // increment the iterator
        //
        pPatternEntry = ListNext (pPatternEntry);
       
        //
        // Remove the entry from the list
        //
        RemoveEntryList (&pWakeUpPattern->linkListEntry);

        //
        // Free the memory
        //
        MP_FREEMEM(pWakeUpPattern, pWakeUpPattern->AllocationSize, 0);
    } 
}

BOOLEAN 
MPAreTwoPatternsEqual(
    IN PNDIS_PM_PACKET_PATTERN pNdisPattern1,
    IN PNDIS_PM_PACKET_PATTERN pNdisPattern2
    )
/*++
Routine Description:

    This routine will compare two wake up patterns to see if they are equal

Arguments:
    
    pNdisPattern1 - Pattern1 
    pNdisPattern2 - Pattern 2
    
    
Return Value:

    True - if patterns are equal
    False - Otherwise
--*/
{
    BOOLEAN bEqual = FALSE;

    // Local variables used later in the compare section of this function
    PUCHAR  pMask1, pMask2;
    PUCHAR  pPattern1, pPattern2;
    UINT    MaskSize, PatternSize;

    do
    {
    	
        bEqual = (BOOLEAN)(pNdisPattern1->Priority == pNdisPattern2->Priority);

        if (bEqual == FALSE)
        {
            break;
        }

        bEqual = (BOOLEAN)(pNdisPattern1->MaskSize == pNdisPattern2->MaskSize);
        if (bEqual == FALSE)
        {
            break;
        }

        //
        // Verify the Mask 
        //
        MaskSize = pNdisPattern1->MaskSize ; 
        pMask1 = (PUCHAR) pNdisPattern1 + sizeof (NDIS_PM_PACKET_PATTERN);
        pMask2 = (PUCHAR) pNdisPattern2 + sizeof (NDIS_PM_PACKET_PATTERN);
        
        bEqual = (BOOLEAN)NdisEqualMemory (pMask1, pMask2, MaskSize);

        if (bEqual == FALSE)
        {
            break;
        }

        //
        // Verify the Pattern
        //
        bEqual = (BOOLEAN)(pNdisPattern1->PatternSize == pNdisPattern2->PatternSize);
        
        if (bEqual == FALSE)
        {
            break;
        }

        PatternSize = pNdisPattern2->PatternSize;
        pPattern1 = (PUCHAR) pNdisPattern1 + pNdisPattern1->PatternOffset;
        pPattern2 = (PUCHAR) pNdisPattern2 + pNdisPattern2->PatternOffset;
        
        bEqual  = (BOOLEAN)NdisEqualMemory (pPattern1, pPattern2, PatternSize );

        if (bEqual == FALSE)
        {
            break;
        }

    } while (FALSE);

    return bEqual;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\net\ms\e100bex\physet.c ===
/****************************************************************************
** COPYRIGHT (C) 1994-1997 INTEL CORPORATION                               **
** DEVELOPED FOR MICROSOFT BY INTEL CORP., HILLSBORO, OREGON               **
** HTTP://WWW.INTEL.COM/                                                   **
** THIS FILE IS PART OF THE INTEL ETHEREXPRESS PRO/100B(TM) AND            **
** ETHEREXPRESS PRO/100+(TM) NDIS 5.0 MINIPORT SAMPLE DRIVER               **
****************************************************************************/

/****************************************************************************
Module Name:
    physet.c

This driver runs on the following hardware:
    - 82558 based PCI 10/100Mb ethernet adapters
    (aka Intel EtherExpress(TM) PRO Adapters)

Environment:
    Kernel Mode - Or whatever is the equivalent on WinNT

Revision History
    - JCB 8/14/97 Example Driver Created
    - Dchen 11-01-99    Modified for the new sample driver
*****************************************************************************/

#include "precomp.h"
#pragma hdrstop
#pragma warning (disable: 4514)

//-----------------------------------------------------------------------------
// Procedure:   PhyDetect
//
// Description: This routine will detect what phy we are using, set the line
//              speed, FDX or HDX, and configure the phy if necessary.
//
//              The following combinations are supported:
//              - TX or T4 PHY alone at PHY address 1
//              - T4 or TX PHY at address 1 and MII PHY at address 0
//              - 82503 alone (10Base-T mode, no full duplex support)
//              - 82503 and MII PHY (TX or T4) at address 0
//
//              The sequence / priority of detection is as follows:
//                  If there is a PHY Address override use that address.
//                  else scan based on the 'Connector' setting.
//                      Switch Connector
//                          0 = AutoScan
//                          1 = Onboard TPE only
//                          2 = MII connector only
//
//              Each of the above cases is explained below.
//
//              AutoScan means:
//                Look for link on addresses 1, 0, 2..31 (in that order).  Use the first
//                address found that has link.
//                If link is not found then use the first valid PHY found in the same scan
//                order 1,0,2..31.  NOTE: this means that NO LINK or Multi-link cases will
//                default to the onboard PHY (address 1).
//
//              Onboard TPE only:
//                Phy address is set to 1 (No Scanning).
//
//              MII connector only means:
//                Look for link on addresses 0, 2..31 (again in that order, Note address 1 is
//                NOT scanned).   Use the first address found that has link.
//                If link is not found then use the first valid Phy found in the same scan
//                order 0, 2..31.
//                In the AutoScan case above we should always find a valid PHY at address 1,
//                there is no such guarantee here, so, If NO Phy is found then the driver
//                should default to address 0 and continue to load.  Note: External
//                transceivers should be at address 0 but our early Nitro3 testing found
//                transceivers at several non-zero addresses (6,10,14).
//
//
//   NWAY
//              Additionally auto-negotiation capable (NWAY) and parallel
//              detection PHYs are supported. The flow-chart is described in
//              the 82557 software writer's manual.
//
//   NOTE:  1.  All PHY MDI registers are read in polled mode.
//          2.  The routines assume that the 82557 has been RESET and we have
//              obtained the virtual memory address of the CSR.
//          3.  PhyDetect will not RESET the PHY.
//          4.  If FORCEFDX is set, SPEED should also be set. The driver will
//              check the values for inconsistency with the detected PHY
//              technology.
//          5.  PHY 1 (the PHY on the adapter) MUST be at address 1.
//          6.  Driver ignores FORCEFDX and SPEED overrides if a 503 interface
//              is detected.
//
//
// Arguments:
//      Adapter - ptr to Adapter object instance
//
// Result:
// Returns:
//  NDIS_STATUS_SUCCESS
//  NDIS_STATUS_FAILURE
//-----------------------------------------------------------------------------

NDIS_STATUS PhyDetect(
    IN PMP_ADAPTER Adapter
    )
{
#if DBG    
    USHORT  MdiControlReg; 
    USHORT  MdiStatusReg;
#endif

    //
    // Check for a phy address over-ride of 32 which indicates a 503
    //
    if (Adapter->PhyAddress == 32)
    {
        //
        // 503 interface over-ride
        //
        DBGPRINT(MP_INFO, ("   503 serial component over-ride\n"));

        Adapter->PhyAddress = 32;

        //
        // Record the current speed and duplex.  We will be in half duplex
        // mode unless the user used the force full duplex over-ride.
        //
        Adapter->usLinkSpeed = 10;
        Adapter->usDuplexMode = (USHORT) Adapter->AiForceDpx;
        if (!Adapter->usDuplexMode)
        {
            Adapter->usDuplexMode = 1;
        }

        return(NDIS_STATUS_SUCCESS);
    }

    //
    // Check for other phy address over-rides.
    //   If the Phy Address is between 0-31 then there is an over-ride.
    //   Or the connector was set to 1
    //
    if ((Adapter->PhyAddress < 32) || (Adapter->Connector == CONNECTOR_TPE))
    {
            
        //
        // User Override nothing to do but setup Phy and leave
        //
        if ((Adapter->PhyAddress > 32) && (Adapter->Connector == CONNECTOR_TPE))
        {
            Adapter->PhyAddress = 1;  // Connector was forced

            // Isolate all other PHYs and unisolate this one
            SelectPhy(Adapter, Adapter->PhyAddress, FALSE);

        }

        DBGPRINT(MP_INFO, 
            ("   Phy address Override to address %d\n", Adapter->PhyAddress));

#if DBG
        //
        // Read the MDI control register at override address.
        //
        MdiRead(Adapter, MDI_CONTROL_REG, Adapter->PhyAddress, FALSE, &MdiControlReg);

        //
        // Read the status register at override address.
        //
        MdiRead(Adapter, MDI_STATUS_REG, Adapter->PhyAddress, FALSE, &MdiStatusReg);
        //
        // Read the status register again because of sticky bits
        //
        MdiRead(Adapter, MDI_STATUS_REG, Adapter->PhyAddress, FALSE, &MdiStatusReg);

        //
        // check if we found a valid phy
        //
        if (!((MdiControlReg == 0xffff) || ((MdiStatusReg == 0) && (MdiControlReg == 0))))
        {
            //
            // we have a valid phy1
            //
            DBGPRINT(MP_INFO, ("   Over-ride address %d has a valid Phy.\n", Adapter->PhyAddress));

            //
            // Read the status register again
            //
            MdiRead(Adapter, MDI_STATUS_REG, Adapter->PhyAddress, FALSE, &MdiStatusReg);

            //
            // If there is a valid link then use this Phy.
            //
            if (MdiStatusReg & MDI_SR_LINK_STATUS)
            {
                DBGPRINT(MP_INFO, ("   Phy at address %d has link\n", Adapter->PhyAddress));
            }

        }
        else
        {
            //
            // no PHY at over-ride address
            //
            DBGPRINT(MP_INFO, ("   Over-ride address %d has no Phy!!!!\n", Adapter->PhyAddress));
        }
#endif
        return(SetupPhy(Adapter));
    }
    else // Need to scan - No address over-ride and Connector is AUTO or MII
    {
        Adapter->CurrentScanPhyIndex = 0;
        Adapter->LinkDetectionWaitCount = 0;
        Adapter->FoundPhyAt = 0xff;
        Adapter->bLookForLink = TRUE;
        
        return(ScanAndSetupPhy(Adapter));
    
    } // End else scan


}

NDIS_STATUS ScanAndSetupPhy(
    IN PMP_ADAPTER Adapter
    )
{
    USHORT MdiControlReg = 0; 
    USHORT MdiStatusReg = 0;

    if (Adapter->bLinkDetectionWait)
    {
        goto NEGOTIATION_WAIT;
    }
           
    SCAN_PHY_START:
    
    //
    // For each PhyAddress 0 - 31
    //
    DBGPRINT(MP_INFO, ("   Index=%d, bLookForLink=%d\n", 
        Adapter->CurrentScanPhyIndex, Adapter->bLookForLink));

    if (Adapter->bLookForLink)
    {
        //
        // Phy Addresses must be tested in the order 1,0,2..31.
        //
        switch(Adapter->CurrentScanPhyIndex)
        {
            case 0:
                Adapter->PhyAddress = 1;
                break;

            case 1:
                Adapter->PhyAddress = 0;
                break;
            
            default:
                Adapter->PhyAddress = Adapter->CurrentScanPhyIndex;
                break;
        }

        //
        // Skip OnBoard for MII only case
        //
        if ((Adapter->PhyAddress == 1)&&(Adapter->Connector == CONNECTOR_MII))
        {
            goto SCAN_PHY_NEXT;    
        }

        DBGPRINT(MP_INFO, ("   Scanning Phy address %d for link\n", Adapter->PhyAddress));

        //
        // Read the MDI control register
        //
        MdiRead(Adapter, MDI_CONTROL_REG, Adapter->PhyAddress, FALSE, &MdiControlReg);

        //
        // Read the status register
        //
        MdiRead(Adapter, MDI_STATUS_REG, Adapter->PhyAddress, FALSE, &MdiStatusReg);
        MdiRead(Adapter, MDI_STATUS_REG, Adapter->PhyAddress, FALSE, &MdiStatusReg);
        // Sticky Bits
    }
    else
    {   
        //
        // Not looking for link
        //
        if (Adapter->FoundPhyAt < 32)
        {
            Adapter->PhyAddress = Adapter->FoundPhyAt;
        }
        else if (Adapter->Connector == CONNECTOR_MII) 
	{
            //
            // No valid PHYs were found last time so just default
            //
            Adapter->PhyAddress = 0;  // Default for MII
        }
        else 
        { 
            //
            // assume a 503 interface
            //
            Adapter->PhyAddress = 32;

            //
            // Record the current speed and duplex.  We will be in half duplex
            // mode unless the user used the force full duplex over-ride.
            //
            Adapter->usLinkSpeed = 10;
            Adapter->usDuplexMode = (USHORT) Adapter->AiForceDpx;
            if (!Adapter->usDuplexMode)
            {
                Adapter->usDuplexMode = 1;
            }

            return(NDIS_STATUS_SUCCESS);
        }

        DBGPRINT(MP_INFO, ("   No Links Found!!\n"));
    }

    //
    // check if we found a valid phy or on !LookForLink pass
    //
    if (!( (MdiControlReg == 0xffff) || ((MdiStatusReg == 0) && (MdiControlReg == 0))) 
        || (!Adapter->bLookForLink))
    {   
        
        //
        // Valid phy or Not looking for Link
        //

#if DBG
        if (!( (MdiControlReg == 0xffff) || ((MdiStatusReg == 0) && (MdiControlReg == 0))))
        {
            DBGPRINT(MP_INFO, ("   Found a Phy at address %d\n", Adapter->PhyAddress));
        }
#endif
        //
        // Store highest priority phy found for NO link case
        //
        if (Adapter->CurrentScanPhyIndex < Adapter->FoundPhyAt && Adapter->FoundPhyAt != 1)
        {
            // this phy is higher priority
            Adapter->FoundPhyAt = (UCHAR) Adapter->PhyAddress;
        }

        //
        // Select Phy before checking link status
        // NOTE: may take up to 3.5 Sec if LookForLink == TRUE
        //SelectPhy(Adapter, Adapter->PhyAddress, (BOOLEAN)LookForLink);
        //
        SelectPhy(Adapter, Adapter->PhyAddress, FALSE);
        
        NEGOTIATION_WAIT:
        
        //
        // wait for auto-negotiation to complete (up to 3.5 seconds)
        //
        if (Adapter->LinkDetectionWaitCount++ < RENEGOTIATE_TIME)
        {
            // Read the status register twice because of sticky bits
            MdiRead(Adapter, MDI_STATUS_REG, Adapter->PhyAddress, FALSE, &MdiStatusReg);
            MdiRead(Adapter, MDI_STATUS_REG, Adapter->PhyAddress, FALSE, &MdiStatusReg);

            if (!(MdiStatusReg & MDI_SR_AUTO_NEG_COMPLETE))
            {
                return NDIS_STATUS_PENDING;
            }
        }
        else
        {
            Adapter->LinkDetectionWaitCount = 0;
        }

        //
        // Read the MDI control register
        //
        MdiRead(Adapter, MDI_CONTROL_REG, Adapter->PhyAddress, FALSE, &MdiControlReg);

        //
        // Read the status register
        //
        MdiRead(Adapter, MDI_STATUS_REG, Adapter->PhyAddress, FALSE, &MdiStatusReg);
        MdiRead(Adapter, MDI_STATUS_REG, Adapter->PhyAddress, FALSE, &MdiStatusReg);

        //
        // If there is a valid link or we alreadry tried once then use this Phy.
        //
        if ((MdiStatusReg & MDI_SR_LINK_STATUS) || (!Adapter->bLookForLink))
        {
#if DBG
            if (MdiStatusReg & MDI_SR_LINK_STATUS)
            {
                DBGPRINT(MP_INFO, ("   Using Phy at address %d with link\n", Adapter->PhyAddress));
            }
            else
            {
                DBGPRINT(MP_INFO, ("   Using Phy at address %d WITHOUT link!!!\n", Adapter->PhyAddress));
            }
#endif

            return(SetupPhy(Adapter));      // Exit with Link Path
        }
    } // End if valid PHY
    
    SCAN_PHY_NEXT:
                                   
    Adapter->CurrentScanPhyIndex++;
    if (Adapter->CurrentScanPhyIndex >= 32)
    {
        Adapter->bLookForLink = FALSE;
    }

    goto SCAN_PHY_START;
}


//***************************************************************************
//
// Name:            SelectPhy
//
// Description:     This routine will Isolate all Phy addresses on the MII
//                  Bus except for the one address to be 'selected'.  This
//                  Phy address will be un-isolated and auto-negotiation will
//                  be enabled, started, and completed.  The Phy will NOT be
//                  reset and the speed will NOT be set to any value (that is
//                  done in SetupPhy).
//
// Arguments:       SelectPhyAddress - PhyAddress to select
//                  WaitAutoNeg      - Flag TRUE = Wait for Auto Negociation to complete.
//                                          FALSE = don't wait. Good for 'No Link' case.
//
// Returns:         Nothing
//
// Modification log:
// Date      Who  Description
// --------  ---  --------------------------------------------------------
//***************************************************************************
VOID SelectPhy(
    IN PMP_ADAPTER  Adapter,
    IN UINT         SelectPhyAddress,
    IN BOOLEAN      WaitAutoNeg
    )
{
    UCHAR   i;
    USHORT  MdiControlReg = 0; 
    USHORT  MdiStatusReg = 0;
    
    //
    // Isolate all other phys and unisolate the one to query
    //
    for (i = 0; i < 32; i++)
    {
        if (i != SelectPhyAddress)
        {
            // isolate this phy
            MdiWrite(Adapter, MDI_CONTROL_REG, i, MDI_CR_ISOLATE);
            // wait 100 microseconds for the phy to isolate.
            NdisStallExecution(100);
        }
    }

    // unisolate the phy to query

    //
    // Read the MDI control register
    //
    MdiRead(Adapter, MDI_CONTROL_REG, SelectPhyAddress, FALSE, &MdiControlReg);

    //
    // Set/Clear bit unisolate this phy
    //
    MdiControlReg &= ~MDI_CR_ISOLATE;                // Clear the Isolate Bit

    //
    // issue the command to unisolate this Phy
    //
    MdiWrite(Adapter, MDI_CONTROL_REG, SelectPhyAddress, MdiControlReg);

    //
    // sticky bits on link
    //
    MdiRead(Adapter, MDI_STATUS_REG, SelectPhyAddress, FALSE, &MdiStatusReg);
    MdiRead(Adapter, MDI_STATUS_REG, SelectPhyAddress, FALSE, &MdiStatusReg);

    //
    // if we have link, don't mess with the phy
    //
    if (MdiStatusReg & MDI_SR_LINK_STATUS)
        return;

    //
    // Read the MDI control register
    //
    MdiRead(Adapter, MDI_CONTROL_REG, SelectPhyAddress, FALSE, &MdiControlReg);

    //
    // set Restart auto-negotiation
    //
    MdiControlReg |= MDI_CR_AUTO_SELECT;             // Set Auto Neg Enable
    MdiControlReg |= MDI_CR_RESTART_AUTO_NEG;        // Restart Auto Neg

    //
    // restart the auto-negotion process
    //
    MdiWrite(Adapter, MDI_CONTROL_REG, SelectPhyAddress, MdiControlReg);

    //
    // wait 200 microseconds for the phy to unisolate.
    //
    NdisStallExecution(200);

    if (WaitAutoNeg)
    {
        //
        // wait for auto-negotiation to complete (up to 3.5 seconds)
        //
        for (i = RENEGOTIATE_TIME; i != 0; i--)
        {
            // Read the status register twice because of sticky bits
            MdiRead(Adapter, MDI_STATUS_REG, SelectPhyAddress, FALSE, &MdiStatusReg);
            MdiRead(Adapter, MDI_STATUS_REG, SelectPhyAddress, FALSE, &MdiStatusReg);

            if (MdiStatusReg & MDI_SR_AUTO_NEG_COMPLETE)
                break;

            MP_STALL_EXECUTION(100);
        }
    }
}

//-----------------------------------------------------------------------------
// Procedure:   SetupPhy
//
// Description: This routine will setup phy 1 or phy 0 so that it is configured
//              to match a speed and duplex over-ride option.  If speed or
//              duplex mode is not explicitly specified in the registry, the
//              driver will skip the speed and duplex over-ride code, and
//              assume the adapter is automatically setting the line speed, and
//              the duplex mode.  At the end of this routine, any truly Phy
//              specific code will be executed (each Phy has its own quirks,
//              and some require that certain special bits are set).
//
//   NOTE:  The driver assumes that SPEED and FORCEFDX are specified at the
//          same time. If FORCEDPX is set without speed being set, the driver
//          will encouter a fatal error and log a message into the event viewer.
//
// Arguments:
//      Adapter - ptr to Adapter object instance
//
// Result:
// Returns:
//  NDIS_STATUS_SUCCESS
//  NDIS_STATUS_FAILURE
//-----------------------------------------------------------------------------

NDIS_STATUS SetupPhy(
    IN PMP_ADAPTER Adapter)
{
    USHORT   MdiControlReg = 0;
    USHORT   MdiStatusReg = 0; 
    USHORT   MdiIdLowReg = 0; 
    USHORT   MdiIdHighReg = 0;
    USHORT   MdiMiscReg = 0;
    UINT     PhyId;
    BOOLEAN  ForcePhySetting = FALSE;

    //
    // If we are NOT forcing a setting for line speed or full duplex, then
    // we won't force a link setting, and we'll jump down to the phy
    // specific code.
    //
    if (((Adapter->AiTempSpeed) || (Adapter->AiForceDpx)))
    {
        
        //
        // Find out what kind of technology this Phy is capable of.
        //
        MdiRead(Adapter, MDI_STATUS_REG, Adapter->PhyAddress, FALSE, &MdiStatusReg);

        //
        // Read the MDI control register at our phy
        //
        MdiRead(Adapter, MDI_CONTROL_REG, Adapter->PhyAddress, FALSE, &MdiControlReg);

        //
        // Now check the validity of our forced option.  If the force option is
        // valid, then force the setting.  If the force option is not valid,
        // we'll set a flag indicating that we should error out.
        //

        //
        // If speed is forced to 10mb
        //
        if (Adapter->AiTempSpeed == 10)
        {
            // If half duplex is forced
            if (Adapter->AiForceDpx == 1)
            {
                if (MdiStatusReg & MDI_SR_10T_HALF_DPX)
                {
                    DBGPRINT(MP_INFO, ("   Forcing 10mb 1/2 duplex\n"));
                    MdiControlReg &= ~(MDI_CR_10_100 | MDI_CR_AUTO_SELECT | MDI_CR_FULL_HALF);
                    ForcePhySetting = TRUE;
                }
            }

            // If full duplex is forced
            else if (Adapter->AiForceDpx == 2)
            {
                if (MdiStatusReg & MDI_SR_10T_FULL_DPX)
                {
                    DBGPRINT(MP_INFO, ("   Forcing 10mb full duplex\n"));
                    MdiControlReg &= ~(MDI_CR_10_100 | MDI_CR_AUTO_SELECT);
                    MdiControlReg |= MDI_CR_FULL_HALF;
                    ForcePhySetting = TRUE;
                }
            }

            // If auto duplex (we actually set phy to 1/2)
            else
            {
                if (MdiStatusReg & (MDI_SR_10T_FULL_DPX | MDI_SR_10T_HALF_DPX))
                {
                    DBGPRINT(MP_INFO, ("   Forcing 10mb auto duplex\n"));
                    MdiControlReg &= ~(MDI_CR_10_100 | MDI_CR_AUTO_SELECT | MDI_CR_FULL_HALF);
                    ForcePhySetting = TRUE;
                    Adapter->AiForceDpx = 1;
                }
            }
        }

        //
        // If speed is forced to 100mb
        //
        else if (Adapter->AiTempSpeed == 100)
        {
            // If half duplex is forced
            if (Adapter->AiForceDpx == 1)
            {
                if (MdiStatusReg & (MDI_SR_TX_HALF_DPX | MDI_SR_T4_CAPABLE))
                {
                    DBGPRINT(MP_INFO, ("   Forcing 100mb half duplex\n"));
                    MdiControlReg &= ~(MDI_CR_AUTO_SELECT | MDI_CR_FULL_HALF);
                    MdiControlReg |= MDI_CR_10_100;
                    ForcePhySetting = TRUE;
                }
            }

            // If full duplex is forced
            else if (Adapter->AiForceDpx == 2)
            {
                if (MdiStatusReg & MDI_SR_TX_FULL_DPX)
                {
                    DBGPRINT(MP_INFO, ("   Forcing 100mb full duplex\n"));
                    MdiControlReg &= ~MDI_CR_AUTO_SELECT;
                    MdiControlReg |= (MDI_CR_10_100 | MDI_CR_FULL_HALF);
                    ForcePhySetting = TRUE;
                }
            }

            // If auto duplex (we set phy to 1/2)
            else
            {
                if (MdiStatusReg & (MDI_SR_TX_HALF_DPX | MDI_SR_T4_CAPABLE))
                {
                    DBGPRINT(MP_INFO, ("   Forcing 100mb auto duplex\n"));
                    MdiControlReg &= ~(MDI_CR_AUTO_SELECT | MDI_CR_FULL_HALF);
                    MdiControlReg |= MDI_CR_10_100;
                    ForcePhySetting = TRUE;
                    Adapter->AiForceDpx = 1;
                }
            }
        }

        if (ForcePhySetting == FALSE)
        {
            DBGPRINT(MP_INFO, ("   Can't force speed=%d, duplex=%d\n",Adapter->AiTempSpeed, Adapter->AiForceDpx));

            return(NDIS_STATUS_FAILURE);
        }

        //
        // Write the MDI control register with our new Phy configuration
        //
        MdiWrite(Adapter, MDI_CONTROL_REG, Adapter->PhyAddress, MdiControlReg);

        //
        // wait 100 milliseconds for auto-negotiation to complete
        //
        MP_STALL_EXECUTION(100);

    }

    //
    // Find out specifically what Phy this is.  We do this because for certain
    // phys there are specific bits that must be set so that the phy and the
    // 82557 work together properly.
    //
    MdiRead(Adapter, PHY_ID_REG_1, Adapter->PhyAddress, FALSE, &MdiIdLowReg);
    MdiRead(Adapter, PHY_ID_REG_2, Adapter->PhyAddress, FALSE, &MdiIdHighReg);

    PhyId =  ((UINT) MdiIdLowReg | ((UINT) MdiIdHighReg << 16));

    DBGPRINT(MP_INFO, ("   Phy ID is %x\n", PhyId));

    //
    // And out the revsion field of the Phy ID so that we'll be able to detect
    // future revs of the same Phy.
    //
    PhyId &= PHY_MODEL_REV_ID_MASK;

    //
    // Handle the National TX
    //
    if (PhyId == PHY_NSC_TX)
    {
        DBGPRINT(MP_INFO, ("   Found a NSC TX Phy\n"));

        MdiRead(Adapter, NSC_CONG_CONTROL_REG, Adapter->PhyAddress, FALSE, &MdiMiscReg);

        MdiMiscReg |= (NSC_TX_CONG_TXREADY | NSC_TX_CONG_F_CONNECT);

        //
        // If we are configured to do congestion control, then enable the
        // congestion control bit in the National Phy
        //
        if (Adapter->Congest)
            MdiMiscReg |= NSC_TX_CONG_ENABLE;
        else
            MdiMiscReg &= ~NSC_TX_CONG_ENABLE;

        MdiWrite(Adapter, NSC_CONG_CONTROL_REG, Adapter->PhyAddress, MdiMiscReg);
    }

    FindPhySpeedAndDpx(Adapter, PhyId);

    DBGPRINT(MP_WARN, ("   Current Speed=%d, Current Duplex=%d\n",Adapter->usLinkSpeed, Adapter->usDuplexMode));

    return(NDIS_STATUS_SUCCESS);
}


//-----------------------------------------------------------------------------
// Procedure:   FindPhySpeedAndDpx
//
// Description: This routine will figure out what line speed and duplex mode
//              the PHY is currently using.
//
// Arguments:
//      Adapter - ptr to Adapter object instance
//      PhyId - The ID of the PHY in question.
//
// Returns:
//      NOTHING
//-----------------------------------------------------------------------------

VOID FindPhySpeedAndDpx(
    IN PMP_ADAPTER  Adapter,
    IN UINT         PhyId
    )
{
    USHORT  MdiStatusReg = 0;
    USHORT  MdiMiscReg = 0;
    USHORT  MdiOwnAdReg = 0;
    USHORT  MdiLinkPartnerAdReg = 0;
    
    //
    // If there was a speed and/or duplex override, then set our current
    // value accordingly
    //
    Adapter->usLinkSpeed = Adapter->AiTempSpeed;
    Adapter->usDuplexMode = (USHORT) Adapter->AiForceDpx;

    //
    // If speed and duplex were forced, then we know our current settings, so
    // we'll just return.  Otherwise, we'll need to figure out what NWAY set
    // us to.
    //
    if (Adapter->usLinkSpeed && Adapter->usDuplexMode)
    {
        return;
    }

    //
    // If we didn't have a valid link, then we'll assume that our current
    // speed is 10mb half-duplex.
    //

    //
    // Read the status register twice because of sticky bits
    //
    MdiRead(Adapter, MDI_STATUS_REG, Adapter->PhyAddress, FALSE, &MdiStatusReg);
    MdiRead(Adapter, MDI_STATUS_REG, Adapter->PhyAddress, FALSE, &MdiStatusReg);

    //
    // If there wasn't a valid link then use default speed & duplex
    //
    if (!(MdiStatusReg & MDI_SR_LINK_STATUS))
    {
        DBGPRINT(MP_INFO, ("   Link Not found for speed detection!!!  Using defaults.\n"));

        Adapter->usLinkSpeed = 10;
        Adapter->usDuplexMode = 1;

        return;
    }

    //
    // If this is an Intel PHY (a T4 PHY_100 or a TX PHY_TX), then read bits
    // 1 and 0 of extended register 0, to get the current speed and duplex
    // settings.
    //
    if ((PhyId == PHY_100_A) || (PhyId == PHY_100_C) || (PhyId == PHY_TX_ID))
    {
        DBGPRINT(MP_INFO, ("   Detecting Speed/Dpx for an Intel PHY\n"));

        //
        // Read extended register 0
        //
        MdiRead(Adapter, EXTENDED_REG_0, Adapter->PhyAddress, FALSE, &MdiMiscReg);

        //
        // Get current speed setting
        //
        if (MdiMiscReg & PHY_100_ER0_SPEED_INDIC)
        {
            Adapter->usLinkSpeed = 100;
        }
        else 
        {
            Adapter->usLinkSpeed    = 10;
        }

        //
        //
        // Get current duplex setting -- if bit is set then FDX is enabled
        //
        if (MdiMiscReg & PHY_100_ER0_FDX_INDIC)
        {
            Adapter->usDuplexMode = 2;
        }
        else
        {
            Adapter->usDuplexMode   = 1;
        }

        return;
    }

    //
    // Read our link partner's advertisement register
    //
    MdiRead(Adapter, 
            AUTO_NEG_LINK_PARTNER_REG, 
            Adapter->PhyAddress, 
            FALSE,
            &MdiLinkPartnerAdReg);
    //
    // See if Auto-Negotiation was complete (bit 5, reg 1)
    //
    MdiRead(Adapter, MDI_STATUS_REG, Adapter->PhyAddress, FALSE, &MdiStatusReg);

    //
    // If a True NWAY connection was made, then we can detect speed/duplex by
    // ANDing our adapter's advertised abilities with our link partner's
    // advertised ablilities, and then assuming that the highest common
    // denominator was chosed by NWAY.
    //
    if ((MdiLinkPartnerAdReg & NWAY_LP_ABILITY) &&
        (MdiStatusReg & MDI_SR_AUTO_NEG_COMPLETE))
    {
        DBGPRINT(MP_INFO, ("   Detecting Speed/Dpx from NWAY connection\n"));

        //
        // Read our advertisement register
        //
        MdiRead(Adapter, AUTO_NEG_ADVERTISE_REG, Adapter->PhyAddress, FALSE, &MdiOwnAdReg);

        //
        // AND the two advertisement registers together, and get rid of any
        // extraneous bits.
        //
        MdiOwnAdReg &= (MdiLinkPartnerAdReg & NWAY_LP_ABILITY);

        //
        // Get speed setting
        //
        if (MdiOwnAdReg & (NWAY_AD_TX_HALF_DPX | NWAY_AD_TX_FULL_DPX | NWAY_AD_T4_CAPABLE))
        {
            Adapter->usLinkSpeed = 100;
        }
        else
        {
            Adapter->usLinkSpeed    = 10;
        }

        //
        // Get duplex setting -- use priority resolution algorithm
        //
        if (MdiOwnAdReg & (NWAY_AD_T4_CAPABLE))
        {
            Adapter->usDuplexMode = 1;
            return;
        }
        else if (MdiOwnAdReg & (NWAY_AD_TX_FULL_DPX))
        {
            Adapter->usDuplexMode = 2;
            return;
        }
        else if (MdiOwnAdReg & (NWAY_AD_TX_HALF_DPX))
        {
            Adapter->usDuplexMode = 1;
            return;
        }
        else if (MdiOwnAdReg & (NWAY_AD_10T_FULL_DPX))
        {
            Adapter->usDuplexMode = 2;
            return;
        }
        else
        {
            Adapter->usDuplexMode = 1;
            return;
        }
    }

    //
    // If we are connected to a non-NWAY repeater or hub, and the line
    // speed was determined automatically by parallel detection, then we have
    // no way of knowing exactly what speed the PHY is set to unless that PHY
    // has a propietary register which indicates speed in this situation.  The
    // NSC TX PHY does have such a register.  Also, since NWAY didn't establish
    // the connection, the duplex setting should HALF duplex.
    //
    Adapter->usDuplexMode = 1;

    if (PhyId == PHY_NSC_TX)
    {
        DBGPRINT(MP_INFO, ("   Detecting Speed/Dpx from non-NWAY NSC connection\n"));

        //
        // Read register 25 to get the SPEED_10 bit
        //
        MdiRead(Adapter, NSC_SPEED_IND_REG, Adapter->PhyAddress, FALSE, &MdiMiscReg);

        //
        // If bit 6 was set then we're at 10mb
        //
        if (MdiMiscReg & NSC_TX_SPD_INDC_SPEED)
        {
            Adapter->usLinkSpeed = 10;
        }
        else 
	{
            Adapter->usLinkSpeed    = 100;
        }
    }
    //
    // If we don't know what line speed we are set at, then we'll default to
    // 10mbs
    //
    else 
    {
        Adapter->usLinkSpeed  = 10;
    }
}


//-----------------------------------------------------------------------------
// Procedure:   ResetPhy
//
// Description: This routine will reset the PHY that the adapter is currently
//              configured to use.
//
// Arguments:
//      Adapter - ptr to Adapter object instance
//
// Returns:
//      NOTHING
//-----------------------------------------------------------------------------

VOID ResetPhy(
    IN PMP_ADAPTER Adapter
    )
{
    USHORT  MdiControlReg;

    //
    // Reset the Phy, enable auto-negotiation, and restart auto-negotiation.
    //
    MdiControlReg = (MDI_CR_AUTO_SELECT | MDI_CR_RESTART_AUTO_NEG | MDI_CR_RESET);

    //
    // Write the MDI control register with our new Phy configuration
    //
    MdiWrite(Adapter, MDI_CONTROL_REG, Adapter->PhyAddress, MdiControlReg);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\net\ms\e100bex\precomp.h ===
#pragma warning(disable:4214)   // bit field types other than int

#pragma warning(disable:4201)   // nameless struct/union
#pragma warning(disable:4115)   // named type definition in parentheses
#pragma warning(disable:4127)   // conditional expression is constant
#pragma warning(disable:4054)   // cast of function pointer to PVOID
#pragma warning(disable:4206)   // translation unit is empty

#include <ndis.h>

#include "e100_equ.h"
#include "e100_557.h"
#include "e100_def.h"

#include "mp_dbg.h"
#include "mp_cmn.h"
#include "mp_def.h"
#include "mp.h"
#include "mp_nic.h"

#include "e100_sup.h"
  
#if OFFLOAD
#include "offload.h"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\net\ms\e100bex\kd\e100kd.c ===
/*

NOTE: Debugger extensions should be compiled with the headers that match the debugger 
      you will use. 
      You can install the latest debugger package from http://www.microsoft.com/ddk/debugging
      and the debugger has more up to date samples of various debugger extensions to which you
      can refer when you write debugger extensions.
      
*/

// This is a 64 bit aware debugger extension
#define KDEXT_64BIT

#include <windows.h>
#include <wdbgexts.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "e100_equ.h"
#include "e100_557.h"

#include "mp_cmn.h"

#include "e100kd.h"

WINDBG_EXTENSION_APIS ExtensionApis;
EXT_API_VERSION ApiVersion = { 5, 0, EXT_API_VERSION_NUMBER64, 0};


USHORT SavedMajorVersion;
USHORT SavedMinorVersion;
BOOL   ChkTarget;                 // is debuggee a CHK build?

typedef struct
{
    char           Name[16];
    unsigned int   Val;
} DBG_LEVEL;

DBG_LEVEL DbgLevel[] = {
    {"ERROR", MP_ERROR},
    {"WARN",  MP_WARN},
    {"TRACE", MP_TRACE},
    {"INFO",  MP_INFO},
    {"LOUD",  MP_LOUD}
};

typedef struct
{
    char  Name[32];
    unsigned int   Val;

} DBG_ADAPTER_FLAGS, DBG_FILTER;

DBG_ADAPTER_FLAGS DbgAdapterFlags[] = {
    {"SCATTER_GATHER",      fMP_ADAPTER_SCATTER_GATHER},       
    {"MAP_REGISTER",        fMP_ADAPTER_MAP_REGISTER},     
    {"RECV_LOOKASIDE",      fMP_ADAPTER_RECV_LOOKASIDE},   
    {"INTERRUPT_IN_USE",    fMP_ADAPTER_INTERRUPT_IN_USE}, 
    {"RESET_IN_PROGRESS",   fMP_ADAPTER_RESET_IN_PROGRESS},                                 
    {"NO_CABLE",            fMP_ADAPTER_NO_CABLE},         
    {"HARDWARE_ERROR",      fMP_ADAPTER_HARDWARE_ERROR}   
};

//
// Ndis Packet Filter Bits (OID_GEN_CURRENT_PACKET_FILTER).
//
#define NDIS_PACKET_TYPE_DIRECTED               0x00000001
#define NDIS_PACKET_TYPE_MULTICAST              0x00000002
#define NDIS_PACKET_TYPE_ALL_MULTICAST          0x00000004
#define NDIS_PACKET_TYPE_BROADCAST              0x00000008
#define NDIS_PACKET_TYPE_SOURCE_ROUTING    0x00000010
#define NDIS_PACKET_TYPE_PROMISCUOUS            0x00000020
#define NDIS_PACKET_TYPE_SMT                       0x00000040
#define NDIS_PACKET_TYPE_ALL_LOCAL              0x00000080
#define NDIS_PACKET_TYPE_GROUP                  0x00001000
#define NDIS_PACKET_TYPE_ALL_FUNCTIONAL    0x00002000
#define NDIS_PACKET_TYPE_FUNCTIONAL             0x00004000
#define NDIS_PACKET_TYPE_MAC_FRAME              0x00008000


DBG_FILTER DbgFilterTable[] = {
    {"DIRECTED",            NDIS_PACKET_TYPE_DIRECTED},       
    {"MULTICAST",           NDIS_PACKET_TYPE_MULTICAST},      
    {"ALL_MULTICAST",       NDIS_PACKET_TYPE_ALL_MULTICAST},  
    {"BROADCAST",           NDIS_PACKET_TYPE_BROADCAST},      
    {"SOURCE_ROUTING",      NDIS_PACKET_TYPE_SOURCE_ROUTING}, 
    {"PROMISCUOUS",         NDIS_PACKET_TYPE_PROMISCUOUS},    
    {"SMT",                 NDIS_PACKET_TYPE_SMT},            
    {"ALL_LOCAL",           NDIS_PACKET_TYPE_ALL_LOCAL},      
    {"GROUP",               NDIS_PACKET_TYPE_GROUP},          
    {"ALL_FUNCTIONAL",      NDIS_PACKET_TYPE_ALL_FUNCTIONAL}, 
    {"FUNCTIONAL",          NDIS_PACKET_TYPE_FUNCTIONAL},     
    {"MAC_FRAME",           NDIS_PACKET_TYPE_MAC_FRAME}      
};

typedef struct
{
    char  Name[32];
    USHORT Val;
} DBG_RFD_STATUS, DBG_RFD_COMMAND, DBG_USHORT_BITS, DBG_USHORT_VALUE;

typedef struct
{
    char  Name[32];
    UCHAR Val;
} DBG_UCHAR_BITS, DBG_UCHAR_VALUE;


DBG_RFD_STATUS DbgRfdStatus[] = {
    {"COMPLETE",            RFD_STATUS_COMPLETE},  
    {"OK",                  RFD_STATUS_OK},        
    {"CRC_ERROR",           RFD_CRC_ERROR},        
    {"ALIGNMENT_ERROR",     RFD_ALIGNMENT_ERROR},  
    {"NO_RESOURCES",        RFD_NO_RESOURCES},     
    {"DMA_OVERRUN",         RFD_DMA_OVERRUN},      
    {"FRAME_TOO_SHORT",     RFD_FRAME_TOO_SHORT},  
    {"RX_ERR",              RFD_RX_ERR},           
    {"IA_MATCH",            RFD_IA_MATCH},
    {"RECEIVE_COLLISION",   RFD_RECEIVE_COLLISION},
};

DBG_RFD_COMMAND DbgRfdCommand[] = {
    {"EL",  RFD_EL_BIT},   
    {"S",   RFD_S_BIT},  
    {"H",   RFD_H_BIT},  
    {"SF",  RFD_SF_BIT} 
};

DBG_USHORT_BITS DbgCbCommandBits[] = {
    {"EL",      CB_EL_BIT},    
    {"S",       CB_S_BIT},     
    {"I",       CB_I_BIT},     
    {"TX_SF",   CB_TX_SF_BIT} 
};

DBG_USHORT_VALUE DbgCbCommands[] = { 
    {"CB_NOP",                 CB_NOP},           
    {"CB_IA_ADDRESS",          CB_IA_ADDRESS},    
    {"CB_CONFIGURE",           CB_CONFIGURE},     
    {"CB_MULTICAST",           CB_MULTICAST},     
    {"CB_TRANSMIT",            CB_TRANSMIT},      
    {"CB_LOAD_MICROCODE",      CB_LOAD_MICROCODE},
    {"CB_DUMP",                CB_DUMP},          
    {"CB_DIAGNOSE",            CB_DIAGNOSE}      
};

DBG_USHORT_VALUE DbgScbStatusRus[] = {
    {"IDLE",           SCB_RUS_IDLE},
    {"SUSPEND",        SCB_RUS_SUSPEND},
    {"NO_RESOURCES",   SCB_RUS_NO_RESOURCES},
    {"READY",          SCB_RUS_READY},
    {"SUSP_NO_RBDS",   SCB_RUS_SUSP_NO_RBDS},
    {"NO_RBDS",        SCB_RUS_NO_RBDS},
    {"READY_NO_RBDS",  SCB_RUS_READY_NO_RBDS},
};

DBG_USHORT_BITS DbgScbStatusBits[] = {
    {"CX",      SCB_STATUS_CX}, 
    {"FR",      SCB_STATUS_FR}, 
    {"CNA",     SCB_STATUS_CNA},
    {"RNR",     SCB_STATUS_RNR},
    {"MDI",     SCB_STATUS_MDI},
    {"SWI",     SCB_STATUS_SWI}
};

DBG_UCHAR_VALUE DbgScbCommandCuc[] = {
    {"START",         SCB_CUC_START},
    {"RESUME",        SCB_CUC_RESUME},       
    {"DUMP_ADDR",     SCB_CUC_DUMP_ADDR},    
    {"DUMP_STAT",     SCB_CUC_DUMP_STAT},    
    {"LOAD_BASE",     SCB_CUC_LOAD_BASE},    
    {"DUMP_RST_STAT", SCB_CUC_DUMP_RST_STAT},
    {"STATIC_RESUME", SCB_CUC_STATIC_RESUME}
};


DBG_UCHAR_VALUE DbgScbCommandRuc[] = {
    {"START",         SCB_RUC_START},
    {"RESUME",        SCB_RUC_RESUME},    
    {"ABORT",         SCB_RUC_ABORT},
    {"LOAD_HDS",      SCB_RUC_LOAD_HDS},  
    {"LOAD_BASE",     SCB_RUC_LOAD_BASE}, 
    {"RBD_RESUME",    SCB_RUC_RBD_RESUME}
};

VOID WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS64 lpExtensionApis,
    USHORT MajorVersion,
    USHORT MinorVersion
    )
{
    ExtensionApis = *lpExtensionApis;

    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;
    ChkTarget = SavedMajorVersion == 0x0c ? TRUE : FALSE;
}

LPEXT_API_VERSION ExtensionApiVersion(VOID)
{
    return &ApiVersion;
}

VOID CheckVersion(VOID)
{

    //
    // for now don't bother to version check
    //
    return;
}

DECLARE_API( help )
{
    int i;

    dprintf("E100 extensions:\n");

    dprintf("   dbglevel                                  dump debug level\n");
    dprintf("   mpadapter <MP_ADAPTER> <verbosity>>       dump MP_ADAPTER block\n");
    dprintf("   csr <CSRAddress>                          dump CSR block\n");
    dprintf("   sendlist <CurrSendHead> <verbosity>       dump send list\n");
    dprintf("   mptcb <MP_TCB>                            dump MP_TCB block\n");   
    dprintf("   hwtcb <HW_TCB>                            dump HW_TCB block\n");   
    dprintf("   sendqueue <SendWaitQueue>                 dump queued send packets\n");
    dprintf("   recvlist <RecvList> <verbosity>           dump receive list\n");
    dprintf("   mprfd <MP_RFD>                            dump MP_RFD block\n");   
    dprintf("   hwrfd <HW_RFD>                            dump HW_RFD block\n");   
    dprintf("   recvpendlist <RecvPendList>               dump pending indicated rx packets\n");
}


DECLARE_API(dbglevel)    
{
    ULONG64  debugLevelPtr;
    ULONG    debugLevel, NewLevel;
    ULONG64  Val;

    int      i;
    ULONG    Bytes;

    debugLevelPtr = GetExpression("e100bnt5!MPDebugLevel");

    if(debugLevelPtr == 0)
    {
        dprintf("Error retrieving address of MPDebugLevel\n");
        dprintf("Target is %s\n", ChkTarget ? "Checked" : "Free");
    }

    dprintf("MPDebugLevel @ %p\n", debugLevelPtr);                    

    debugLevel = GetUlongFromAddress(debugLevelPtr);

    dprintf("Current MPDebugLevel = %d", debugLevel);

    for(i = 0; i < sizeof(DbgLevel)/sizeof(DBG_LEVEL); i++)
    {
        if(debugLevel == DbgLevel[i].Val)
        {
            dprintf(" - %s", DbgLevel[i].Name);
            break;
        }
    }

    dprintf("\n");

    dprintf("Available settings: ");
    for(i = 0; i < sizeof(DbgLevel)/sizeof(DBG_LEVEL); i++)
    {
        if(debugLevel != DbgLevel[i].Val)
        {
            dprintf("%d-%s ", DbgLevel[i].Val, DbgLevel[i].Name);
        }
    }

    dprintf("\n");

    if(!*args)
    {
        return;
    }

    i = sscanf(args, "%lx", &NewLevel);

    if(i == 1)
    {
        for(i = 0; i < sizeof(DbgLevel)/sizeof(DBG_LEVEL); i++)
        {
            if(NewLevel == DbgLevel[i].Val)
            {
                if(NewLevel != debugLevel)
                {
                    dprintf("New MPDebugLevel = %d\n", NewLevel);
                    WriteMemory(debugLevelPtr, &NewLevel, sizeof(ULONG), &Bytes);
                }

                break;
            }
        }
    }
}

DECLARE_API(version)    
{
#if    DBG
    PCSTR kind = "Checked";
#else
    PCSTR kind = "Free";
#endif

    dprintf("%s E100 Extension dll on a %s system\n", 
        kind,  ChkTarget? "Checked" : "Free");

}

#define MAX_FLAGS_PER_LINE  4
#define MAC_ADDRESS_LENGTH 6

DECLARE_API(mpadapter)    
{
    ULONG64  pAdapter;

    int      ArgCount = 0;

    ULONG    i, j;
    ULONG    Flags;
    ULONG    PacketFilter;
    ULONG    Off;

    UCHAR    MacAddress[MAC_ADDRESS_LENGTH];
    UINT     MCAddressCount;
    PUCHAR   pBuffer;

    if(*args)
    {
        ArgCount = sscanf(args,"%I64lx",&pAdapter);
    }

    //check for arguments
    if(ArgCount < 1)
    {
        dprintf("Usage: mpadapter <pointer to MP_ADAPTER>\n");
        return ;
    }

    dprintf(" pAdapter %p : \n", pAdapter);

    InitTypeRead(pAdapter, MP_ADAPTER);

    dprintf("   AdapterHandle  : %p\n", ReadField(AdapterHandle));

    Flags = (ULONG) ReadField(Flags);
    dprintf("   Flags          : 0x%08x\n", Flags);

    j = 0;
    for(i = 0; i < sizeof(DbgAdapterFlags)/sizeof(DBG_ADAPTER_FLAGS); i++)
    {
        if(Flags & DbgAdapterFlags[i].Val)
        {
            if(j == 0)
            {
                dprintf("                     ");
            }

            dprintf("%s", DbgAdapterFlags[i].Name);

            j++;

            if(j != MAX_FLAGS_PER_LINE)
            {
                dprintf(", ");
            }
            else
            {
                dprintf("\n");
                j = 0;
            }
        }
    }

    if(j != 0)
    {
        dprintf("\n");
    }

    if(!GetFieldOffset("MP_ADAPTER", "PermanentAddress", &Off))
    {
        if(GetData(MacAddress, pAdapter+Off, MAC_ADDRESS_LENGTH, "PermanentAddress[]"))
        {
            dprintf("   Permanent address : %02x-%02x-%02x-%02x-%02x-%02x\n", 
                MacAddress[0], MacAddress[1],
                MacAddress[2], MacAddress[3],
                MacAddress[4], MacAddress[5]);
        }
    }

    if((BOOLEAN) ReadField(OverrideAddress))
    {
        if(!GetFieldOffset("MP_ADAPTER", "CurrentAddress", &Off))
        {
            if(GetData(MacAddress, pAdapter+Off, MAC_ADDRESS_LENGTH, "CurrentAddress[]"))
            {
                dprintf("   Current address : %02x-%02x-%02x-%02x-%02x-%02x\n", 
                    MacAddress[0], MacAddress[1],
                    MacAddress[2], MacAddress[3],
                    MacAddress[4], MacAddress[5]);
            }
        }
    }
    else
    {
        dprintf("   Current address : same as above\n"); 
    }

    dprintf("\n"); 

    dprintf("   --- SEND ---\n");
    dprintf("   CurrSendHead = %p , CurrSendTail = %p , nBusySend = %d\n", 
        ReadField(CurrSendHead), ReadField(CurrSendTail), (LONG)ReadField(nBusySend)); 

    dprintf("   SendWaitQueue Head = %p, Tail = %p\n",
        ReadField(SendWaitQueue.Head), ReadField(SendWaitQueue.Tail)); 
    dprintf("   NumTcb = %d, RegNumTcb = %d, NumBuffers = %d\n", 
        (LONG)ReadField(NumTcb), (LONG)ReadField(RegNumTcb), (LONG)ReadField(NumBuffers));
    dprintf("   MpTcbMem = %p\n", ReadField(MpTcbMem)); 

    if(DBG_TEST_FLAG(Flags, fMP_ADAPTER_MAP_REGISTER))
    {
        dprintf("   CurrMapRegHead = %d, CurrMapRegTail = %d\n",
            (UINT)ReadField(CurrMapRegHead), (UINT)ReadField(CurrMapRegTail));       
    }

    dprintf("   TransmitIdle = %s, ResumeWait = %s\n", 
        (BOOLEAN)ReadField(TransmitIdle) ? "TRUE" : "FALSE", 
        (BOOLEAN)ReadField(ResumeWait) ? "TRUE" : "FALSE");

    dprintf("   SendBufferPool = %p\n", ReadField(SendBufferPool));

    dprintf("\n"); 

    dprintf("   --- RECV ---\n");

    if(!GetFieldOffset("MP_ADAPTER", "RecvList", &Off))
    {
        dprintf("   RecvList @ %p , nReadyRecv = %d\n",
            pAdapter+Off, (LONG)ReadField(nReadyRecv));
    }

    if(!GetFieldOffset("MP_ADAPTER", "RecvPendList", &Off))
    {
        dprintf("   RecvPendList @ %p , RefCount = %d\n",
            pAdapter+Off, (LONG)ReadField(RefCount));
    }

    dprintf("   NumRfd = %d, CurrNumRfd = %d , HwRfdSize = %d\n", 
        (LONG)ReadField(NumRfd), (LONG)ReadField(CurrNumRfd), (LONG)ReadField(HwRfdSize));

    dprintf("   bAllocNewRfd = %s, RfdShrinkCount = %d\n", 
        (BOOLEAN)ReadField(bAllocNewRfd) ? "TRUE" : "FALSE",
        (LONG)ReadField(RfdShrinkCount));       

    dprintf("   RecvPacketPool = %p , RecvBufferPool = %p\n", 
        ReadField(RecvPacketPool), ReadField(RecvBufferPool));  

    dprintf("\n"); 

    PacketFilter = (ULONG)ReadField(PacketFilter);
    dprintf("   PacketFilter   : 0x%08x\n", PacketFilter);

    j = 0;
    for(i = 0; i < sizeof(DbgFilterTable)/sizeof(DBG_FILTER); i++)
    {
        if(PacketFilter & DbgFilterTable[i].Val)
        {
            if(j == 0)
            {
                dprintf("                     ");
            }

            dprintf("%s", DbgFilterTable[i].Name);

            j++;

            if(j != MAX_FLAGS_PER_LINE)
            {
                dprintf(", ");
            }
            else
            {
                dprintf("\n");
                j = 0;
            }
        }
    }

    if(j != 0)
    {
        dprintf("\n");
    }

    dprintf("   ulLookAhead=%d, usLinkSpeed=%d, usDuplexMode=%d\n",
        (ULONG)ReadField(ulLookAhead), (USHORT)ReadField(usLinkSpeed), 
        (USHORT)ReadField(usDuplexMode));

    dprintf("\n");

    MCAddressCount = (UINT)ReadField(MCAddressCount);
    dprintf("   MCAddressCount = %d\n", MCAddressCount);

    pBuffer = malloc(MCAddressCount * MAC_ADDRESS_LENGTH);
    if(pBuffer)
    {
        if(!GetFieldOffset("MP_ADAPTER", "MCList", &Off))
        {
            if(GetData(pBuffer, pAdapter+Off, MCAddressCount * MAC_ADDRESS_LENGTH, "MCList[]"))
            {
                for(i=0; i<MCAddressCount; i++)
                {
                    j = i * MAC_ADDRESS_LENGTH;
                    dprintf("   (%d) = %02x-%02x-%02x-%02x-%02x-%02x\n",
                        i, pBuffer[j], pBuffer[j+1], pBuffer[j+2], 
                        pBuffer[j+3], pBuffer[j+4], pBuffer[j+5]);
                }
            }
        }

        free(pBuffer);
    }
    else
    {

    }


    dprintf("\n");


    dprintf("   IoBaseAddress = 0x%x, IoRange = 0x%x, InterrupLevel = 0x%x, MemPhysAddress = 0x%x\n",   
        (ULONG)ReadField(IoBaseAddress), (ULONG)ReadField(IoRange), 
        (ULONG)ReadField(InterruptLevel), (ULONG)ReadField(MemPhysAddress.LowPart)); 
    dprintf("   PortOffset = %p , CSRAddress = %p\n", 
        ReadField(PortOffset), ReadField(CSRAddress));

    dprintf("   RevsionID = %d, SubVendorID = 0x%02x, SubSystemID = 0x%02x\n",
        (UCHAR)ReadField(RevsionID), (USHORT)ReadField(SubVendorID), 
        (USHORT)ReadField(SubSystemID));

}

DECLARE_API(csr)    
{
    ULONG64  pHwCsr;
    int      ArgCount = 0;

    UCHAR    ucVal;
    USHORT   usVal;

    ULONG    i;

    if(*args)
    {
        ArgCount = sscanf(args,"%I64lx", &pHwCsr);
    }

    //check for arguments
    if(ArgCount < 1)
    {
        dprintf("Usage: csr <CSRAddress>\n");
        return ;
    }

    dprintf(" pHwCsr %x : \n", pHwCsr);

    InitTypeRead(pHwCsr, HW_CSR);

    // ScbStatus 
    usVal = (USHORT)ReadField(ScbStatus);
    dprintf("   ScbStatus - 0x%04x ", usVal);

    dprintf("CUS-");              
    switch(usVal & SCB_CUS_MASK)
    {
        case SCB_CUS_IDLE:
            dprintf("IDLE "); 
            break;

        case SCB_CUS_SUSPEND:
            dprintf("SUSPEND "); 
            break;

        case SCB_CUS_ACTIVE:
            dprintf("ACTIVE "); 
            break;

        default:
            dprintf("Reserved "); 
    }

    for(i = 0; i < sizeof(DbgScbStatusRus)/sizeof(DBG_USHORT_VALUE); i++)
    {
        if((usVal & SCB_RUS_MASK) == DbgScbStatusRus[i].Val)
        {
            dprintf("RUS-%s ", DbgScbStatusRus[i].Name);
            break;
        }
    }

    dprintf("STAT-");

    for(i = 0; i < sizeof(DbgScbStatusBits)/sizeof(DBG_USHORT_BITS); i++)
    {
        if(usVal & DbgScbStatusBits[i].Val)
        {
            dprintf("%s ", DbgScbStatusBits[i].Name);
        }
    }

    dprintf("\n");

    //ScbCommandLow
    ucVal = (UCHAR)ReadField(ScbCommandLow);
    dprintf("   ScbCommandLow - 0x%02x ", ucVal);

    for(i = 0; i < sizeof(DbgScbCommandCuc)/sizeof(DBG_UCHAR_VALUE); i++)
    {
        if((ucVal & SCB_CUC_MASK) == DbgScbCommandCuc[i].Val)
        {
            dprintf("CUC-%s ", DbgScbCommandCuc[i].Name);
            break;
        }
    }

    for(i = 0; i < sizeof(DbgScbCommandRuc)/sizeof(DBG_UCHAR_VALUE); i++)
    {
        if((ucVal & SCB_RUC_MASK) == DbgScbCommandRuc[i].Val)
        {
            dprintf("RUC-%s ", DbgScbCommandRuc[i].Name);
            break;
        }
    }

    //ScbCommandHigh
    ucVal = (UCHAR)ReadField(ScbCommandHigh);
    dprintf(" ScbCommandHigh - 0x%02x ", ucVal);              
    if(ucVal & SCB_INT_MASK)
    {
        dprintf("INT_MASK ");
    }
    if(ucVal & SCB_SOFT_INT)
    {
        dprintf("SOFT_INT ");
    }

    dprintf("\n");
}

DECLARE_API(sendlist)    
{
    ULONG64  pMpTcb;
    ULONG64  pFirstMpTcb;

    int      ArgCount = 0;
    int      Verbosity = 0;
    int      index = 0;

    if(*args)
    {
        ArgCount = sscanf(args,"%I64lx %lx", &pMpTcb, &Verbosity);
    }

    //check for arguments
    if(ArgCount < 1 || Verbosity > 1)
    {
        dprintf("Usage: sendlist <CurrSendHead> <verbosity>\n");
        dprintf("1-Show HW_TCB info\n");
        return ;
    }

    SIGN_EXTEND(pMpTcb);                      

    pFirstMpTcb = pMpTcb;

    do                                                
    {
        dprintf(" (%d) pMpTcb %p : \n", index, pMpTcb);

        PrintMpTcbDetails(pMpTcb, Verbosity);

        if(GetFieldValue(pMpTcb, "MP_TCB", "Next", pMpTcb))
        {
            break;
        }

        index++;

        if(CheckControlC())
        {
            dprintf("***Control-C***\n");
            break;
        }

    } while(pMpTcb != pFirstMpTcb);

}


DECLARE_API(mptcb)    
{
    ULONG64  pMpTcb;

    int      ArgCount = 0;

    if(*args)
    {
        ArgCount = sscanf(args,"%I64lx", &pMpTcb);
    }

    //check for arguments
    if(ArgCount < 1)
    {
        dprintf("Usage: mptcb <MP_TCB>\n");
        return ;
    }

    dprintf(" pMpTcb %p : \n", pMpTcb);

    PrintMpTcbDetails(pMpTcb, 1);

}

DECLARE_API(hwtcb)    
{
    ULONG64  pHwTcb;

    int      ArgCount = 0;

    if(*args)
    {
        ArgCount = sscanf(args,"%I64lx", &pHwTcb);
    }

    //check for arguments
    if(ArgCount < 1)
    {
        dprintf("Usage: hwtcb <HW_TCB>\n");
        return ;
    }

    dprintf(" pHwTcb %p : \n", pHwTcb);

    PrintHwTcbDetails(pHwTcb);
}

void PrintMpTcbDetails(ULONG64 pMpTcb, int Verbosity)
{
    ULONG    Flags;
    ULONG64  pMpTxBuf;
    ULONG64  pHwTcb;

    ULONG64  pVal;                 
    ULONG    ulVal;
    USHORT   usVal;

    InitTypeRead(pMpTcb, MP_TCB);

    dprintf("   Next %p", ReadField(Next));

    Flags = (ULONG) ReadField(Flags);
    dprintf(" , Flags - 0x%x", Flags);
    if(Flags & fMP_TCB_IN_USE)
    {
        dprintf(" IN_USE");
    }
    if(Flags & fMP_TCB_USE_LOCAL_BUF)
    {
        dprintf(" USE_LOCAL_BUF");
    }
    if(Flags & fMP_TCB_MULTICAST)
    {
        dprintf(" MULTICAST");
    }

    dprintf("\n");

    if(Flags & fMP_TCB_USE_LOCAL_BUF)
    {

        pMpTxBuf = ReadField(MpTxBuf);
        dprintf("   MpTxBuf = %p", pMpTxBuf);

        GetFieldValue(pMpTxBuf, "MP_TXBUF", "NdisBuffer", pVal);
        dprintf(" - NdisBuffer = %p", pVal);

        GetFieldValue(pMpTxBuf, "MP_TXBUF", "AllocSize", ulVal);
        dprintf(" , AllocSize = %d", ulVal);

        GetFieldValue(pMpTxBuf, "MP_TXBUF", "AllocVa", pVal);
        dprintf(" , AllocVa = %p", pVal);

        GetFieldValue(pMpTxBuf, "MP_TXBUF", "pBuffer", pVal);
        dprintf(" , pBuffer = %p\n", pVal);

        dprintf("\n");
    }

    if(Flags & fMP_TCB_IN_USE)
    {
        dprintf("   Packet = %p\n", ReadField(Packet));

        pHwTcb = ReadField(HwTcb);
        dprintf("   HwTcb = %p , HwTcbPhys = 0x%lx , PrevHwTcb = 0x%x\n", 
            pHwTcb, (ULONG)ReadField(HwTcbPhys), ReadField(PrevHwTcb));

        dprintf("   HwTbd (First) = %p , HwTbdPhys = 0x%x\n", 
            ReadField(HwTbd), (ULONG)ReadField(HwTbdPhys));

        dprintf("   PhysBufCount = %d, BufferCount = %d, FirstBuffer = %p , PacketLength = %d\n", 
            (ULONG)ReadField(PhysBufCount), (ULONG)ReadField(BufferCount), 
            ReadField(FirstBuffer), (ULONG)ReadField(PacketLength));
    }

    dprintf("\n");

    if((Flags & fMP_TCB_IN_USE) && Verbosity == 1)
    {
        PrintHwTcbDetails(pHwTcb);
    }
}

void PrintHwTcbDetails(ULONG64 pHwTcb)
{
    USHORT   HwCbStatus;
    USHORT   HwCbCommand; 

    ULONG    i;

    InitTypeRead(pHwTcb, HW_TCB);

    HwCbStatus = (USHORT) ReadField(TxCbHeader.CbStatus);
    HwCbCommand = (USHORT) ReadField(TxCbHeader.CbCommand);

    dprintf("      TxCbHeader.CbStatus = 0x%04x ,", HwCbStatus);
    if(HwCbStatus & CB_STATUS_COMPLETE)
    {
        dprintf(" COMPLETE");
    }
    if(HwCbStatus & CB_STATUS_OK)
    {
        dprintf(" OK");
    }
    if(HwCbStatus & CB_STATUS_UNDERRUN)
    {
        dprintf(" UNDERRUN");
    }

    dprintf("\n");

    dprintf("      TxCbHeader.CbCommand = 0x%04x ", HwCbCommand);
    for(i = 0; i < sizeof(DbgCbCommandBits)/sizeof(DBG_USHORT_BITS); i++)
    {
        if(HwCbCommand & DbgCbCommandBits[i].Val)
        {
            dprintf(", %s", DbgCbCommandBits[i].Name);
        }
    }

    for(i = 0; i < sizeof(DbgCbCommands)/sizeof(DBG_USHORT_VALUE); i++)
    {
        if((HwCbCommand & CB_CMD_MASK) == DbgCbCommands[i].Val)
        {
            dprintf(", %s", DbgCbCommands[i].Name);
            break;
        }
    }

    if(i == sizeof(DbgCbCommands)/sizeof(DBG_USHORT_VALUE))
    {
        dprintf(", UNKNOWN COMMAND");
    }

    dprintf("\n");

    dprintf("      TxCbHeader.CbLinkPointer = 0x%x\n", (ULONG)ReadField(TxCbHeader.CbLinkPointer));

    if((HwCbCommand & CB_CMD_MASK) == CB_TRANSMIT)
    {
        dprintf("      TxCbTbdPointer = 0x%08x\n", (ULONG)ReadField(TxCbTbdPointer));
        dprintf("      TxCbCount = %d, ", (USHORT)ReadField(TxCbCount));
        dprintf("TxCbThreshold = %d, ", (UCHAR)ReadField(TxCbThreshold));
        dprintf("TxCbTbdNumber = %d\n", (UCHAR)ReadField(TxCbTbdNumber));
    }
}

DECLARE_API(sendqueue)    
{
    ULONG64  pEntry; 
    ULONG64  pPacket;

    ULONG    ulSize;

    int      ArgCount = 0;
    int      index = 0;

    if(*args)
    {
        ArgCount = sscanf(args,"%I64lx", &pEntry);
    }

    //check for arguments
    if(ArgCount < 1)
    {
        dprintf("Usage: sendqueue <SendWaitQueue address>\n");
        return ;
    }

    SIGN_EXTEND(pEntry);

    if(!(ulSize = GetTypeSize("NDIS_PACKET_PRIVATE")))
    {
        dprintf("Failed to get the type size of NDIS_PACKET_PRIVATE\n");
        return;
    }

    dprintf("NDIS_PACKET_PRIVATE size is 0x%x\n", ulSize);

    while(pEntry)
    {
        pPacket = pEntry - ulSize;
        if(pPacket > pEntry)
        {
            dprintf("Invalid pEntry %p\n", pEntry);
            break;
        }

        dprintf("   (%d) pEntry = %p, Pkt = %p\n", index, pEntry, pPacket);

        if(ReadPtr(pEntry, &pEntry))
        {
            break;
        }

        index++;

        if(CheckControlC())
        {
            dprintf("***Control-C***\n");
            break;
        }
    }
}

DECLARE_API(recvlist)    
{
    ULONG64  pListHead;
    ULONG64  pMpRfd;
    ULONG64  pHwRfd;

    int      ArgCount = 0;
    int      Verbosity = 0;
    int      index = 0;

    if(*args)
    {
        ArgCount = sscanf(args,"%I64lx %lx", &pListHead, &Verbosity);
    }

    //check for arguments
    if(ArgCount < 1 || Verbosity > 1)
    {
        dprintf("Usage: recvlist <RecvList address> <verbosity>\n");
        dprintf("1-Show HW_RFD info\n");
        return ;
    }

    SIGN_EXTEND(pListHead);

    if(GetFieldValue(pListHead, "LIST_ENTRY", "Flink", pMpRfd))
    {
        dprintf("Failed to get LIST_ENTRY Flink at %p\n", pListHead);
        return;      
    }

    while((pMpRfd != pListHead))
    {
        dprintf("   (%d) pMpRfd %p :\n", index, pMpRfd);

        PrintMpRfdDetails(pMpRfd, Verbosity);

        if(GetFieldValue(pMpRfd, "LIST_ENTRY", "Flink", pMpRfd))
        {
            dprintf("Failed to get LIST_ENTRY Flink at %p\n", pMpRfd);
            break;
        }

        index++;

        if(CheckControlC())
        {
            dprintf("***Control-C***\n");
            break;
        }
    }

    dprintf("RecvList has %d RFDs\n", index);

}

DECLARE_API(mprfd)    
{
    ULONG64  pMpRfd;

    int      ArgCount = 0;

    if(*args)
    {
        ArgCount = sscanf(args,"%I64lx", &pMpRfd);
    }

    //check for arguments
    if(ArgCount < 1)
    {
        dprintf("Usage: mprfd <MP_RFD>\n");
        return ;
    }

    dprintf(" pMpRfd %p : \n", pMpRfd);

    PrintMpRfdDetails(pMpRfd, 1);
}

DECLARE_API(hwrfd)    
{
    ULONG64  pHwRfd;

    int      ArgCount = 0;

    if(*args)
    {
        ArgCount = sscanf(args,"%I64lx", &pHwRfd);
    }

    //check for arguments
    if(ArgCount < 1)
    {
        dprintf("Usage: hwrfd <HW_RFD>\n");
        return ;
    }

    dprintf(" pHwRfd = %p : \n", pHwRfd); 

    PrintHwRfdDetails(pHwRfd);
}

void PrintMpRfdDetails(ULONG64 pMpRfd, int Verbosity)
{
    ULONG64  pHwRfd;

    ULONG    Flags;

    InitTypeRead(pMpRfd, MP_RFD);

    dprintf("   Flink %p", ReadField(List.Flink));
    dprintf(" , Blink %p\n", ReadField(List.Blink));

    pHwRfd = ReadField(HwRfd);                           
    dprintf("   NdisPacket = %p , NdisBuffer = %p , HwRfd = %p\n", 
        ReadField(NdisPacket), ReadField(NdisBuffer), pHwRfd);

    dprintf("   PacketSize = %d, ", (ULONG) ReadField(PacketSize));

    Flags = (ULONG) ReadField(Flags);                                   
    dprintf("Flags 0x%x", Flags);
    if(Flags & fMP_RFD_RECV_PEND)
    {
        dprintf(" RECV_PEND ");
    }
    if(Flags & fMP_RFD_ALLOC_PEND)
    {
        dprintf(" ALLOC_PEND ");
    }
    if(Flags & fMP_RFD_RECV_READY)
    {
        dprintf(" RECV_READY ");
    }
    if(Flags & fMP_RFD_RESOURCES)
    {
        dprintf(" RESOURCES ");
    }
    

    dprintf("\n");

    if(Verbosity == 1)
    {
        PrintHwRfdDetails(pHwRfd);
    }
}

void PrintHwRfdDetails(ULONG64 pHwRfd)
{
    USHORT   RfdStatus;
    USHORT   RfdCommand; 

    ULONG    i;

    InitTypeRead(pHwRfd, HW_RFD);

    RfdStatus = (USHORT) ReadField(RfdCbHeader.CbStatus);
    RfdCommand = (USHORT) ReadField(RfdCbHeader.CbCommand);

    dprintf("      RfdCbHeader.CbStatus = 0x%04x", RfdStatus);

    for(i = 0; i < sizeof(DbgRfdStatus)/sizeof(DBG_RFD_STATUS); i++)
    {
        if(RfdStatus & DbgRfdStatus[i].Val)
        {
            dprintf(", %s", DbgRfdStatus[i].Name);
        }
    }

    dprintf("\n");

    dprintf("      RfdCbHeader.CbCommand = %04x", RfdCommand);
    for(i = 0; i < sizeof(DbgRfdCommand)/sizeof(DBG_RFD_COMMAND); i++)
    {
        if(RfdCommand & DbgRfdCommand[i].Val)
        {
            dprintf(", %s", DbgRfdCommand[i].Name);
        }
    }

    dprintf("\n");

    dprintf("      RfdCbHeader.CbLinkPointer = 0x%x\n", (ULONG)ReadField(RfdCbHeader.CbLinkPointer));
    //dprintf("      RfdRbdPointer = 0x%x\n", (ULONG)ReadField(RfdRbdPointer));
    dprintf("      RfdActualCount = %x , %d", (USHORT)ReadField(RfdActualCount), (USHORT)ReadField(RfdActualCount) & 0x3fff);
    dprintf(", RfdSize = %d\n", (USHORT)ReadField(RfdSize));
}

DECLARE_API(recvpendlist)    
{
    ULONG64  pListHead;
    ULONG64  pMpRfd;
    ULONG64  pPacket;

    int      ArgCount = 0;
    int      index = 0;

    if(*args)
    {
        ArgCount = sscanf(args,"%I64lx", &pListHead);
    }

    //check for arguments
    if(ArgCount < 1)
    {
        dprintf("Usage: recvpendlist <RecvPendList address>\n");
        return ;
    }

    SIGN_EXTEND(pListHead);

    if(GetFieldValue(pListHead, "LIST_ENTRY", "Flink", pMpRfd))
    {
        dprintf("Failed to get LIST_ENTRY Flink at %p\n", pListHead);
        return;      
    }

    while(pMpRfd != pListHead)
    {
        dprintf("   (%d) pMpRfd %x :\n", index, pMpRfd);

        PrintMpRfdDetails(pMpRfd, 0);

        if(GetFieldValue(pMpRfd, "LIST_ENTRY", "Flink", pMpRfd))
        {
            dprintf("Failed to get LIST_ENTRY Flink at %p\n", pMpRfd);
            break;
        }

        index++;

        if(CheckControlC())
        {
            dprintf("***Control-C***\n");
            break;
        }
    }

    dprintf("RecvPendList has %d RFDs\n", index);

}


/**
   Get 'size' bytes from the debuggee program at 'dwAddress' and place it
   in our address space at 'ptr'.  Use 'type' in an error printout if necessary
 **/
BOOL GetData( IN LPVOID ptr, IN ULONG64 AddressPtr, IN ULONG size, IN PCSTR type )
{
    BOOL b;
    ULONG BytesRead;
    ULONG count = size;

    while(size > 0)
    {

        if(count >= 3000)
            count = 3000;

        b = ReadMemory(AddressPtr, ptr, count, &BytesRead );

        if(!b || BytesRead != count)
        {
            dprintf( "Unable to read %u bytes at %X, for %s\n", size, AddressPtr, type );
            return FALSE;
        }

        AddressPtr += count;
        size -= count;
        ptr = (LPVOID)((ULONG_PTR)ptr + count);
    }

    return TRUE;
}

/**
   
   Routine to get offset and size of a "Field" of "Type" on a debugee machine. This uses
   Ioctl call for type info.
   Returns 0 on success, Ioctl error value otherwise.
   
 **/
ULONG GetFieldOffsetAndSize(
    IN LPSTR     Type, 
    IN LPSTR     Field, 
    OUT PULONG   pOffset,
    OUT PULONG   pSize) 
{
    FIELD_INFO flds = {
        Field, "", 0, 
        DBG_DUMP_FIELD_FULL_NAME | DBG_DUMP_FIELD_RETURN_ADDRESS | DBG_DUMP_FIELD_SIZE_IN_BITS, 
        0, NULL};
    SYM_DUMP_PARAM Sym = {
        sizeof (SYM_DUMP_PARAM), Type, DBG_DUMP_NO_PRINT, 0,
        NULL, NULL, NULL, 1, &flds
    };
    ULONG Err, i=0;
    LPSTR dot, last=Field;

    Sym.nFields = 1;
    Err = Ioctl( IG_DUMP_SYMBOL_INFO, &Sym, Sym.size );
    *pOffset = (ULONG) (flds.address - Sym.addr);
    *pSize   = flds.size;
    return Err;
}

ULONG GetUlongFromAddress (
    ULONG64 Location)
{
    ULONG Value;
    ULONG result;

    if((!ReadMemory(Location,&Value,sizeof(ULONG),&result)) ||
        (result < sizeof(ULONG)))
    {
        dprintf("unable to read from %08x\n",Location);
        return 0;
    }

    return Value;
}

ULONG64 GetPointerFromAddress(
    ULONG64 Location)
{
    ULONG64 Value;
    ULONG result;

    if(ReadPtr(Location,&Value))
    {
        dprintf("unable to read from %p\n",Location);
        return 0;
    }

    return Value;
}

ULONG GetUlongValue (
    PCHAR String)
{
    ULONG64 Location;
    ULONG Value;
    ULONG result;

    Location = GetExpression(String);
    if(!Location)
    {
        dprintf("unable to get %s\n",String);
        return 0;
    }

    return GetUlongFromAddress(Location);
}

ULONG64 GetPointerValue (
    PCHAR String)
{
    ULONG64 Location, Val=0;

    Location = GetExpression(String);
    if(!Location)
    {
        dprintf("unable to get %s\n",String);
        return 0;
    }

    ReadPtr(Location, &Val);

    return Val;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\net\ms\e100bex\sys\makefile.inc ===
$(O)\e100.mof: ..\e100.mof

$(O)\e100_wmi.h: $(O)\e100.bmf 
    wmimofck -h$(O)\e100_wmi.h $(O)\e100.bmf
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\net\ms\e100bex\routines.c ===
/****************************************************************************
** COPYRIGHT (C) 1994-1997 INTEL CORPORATION                               **
** DEVELOPED FOR MICROSOFT BY INTEL CORP., HILLSBORO, OREGON               **
** HTTP://WWW.INTEL.COM/                                                   **
** THIS FILE IS PART OF THE INTEL ETHEREXPRESS PRO/100B(TM) AND            **
** ETHEREXPRESS PRO/100+(TM) NDIS 5.0 MINIPORT SAMPLE DRIVER               **
****************************************************************************/

/****************************************************************************
Module Name:
    routines.c

This driver runs on the following hardware:
    - 82558 based PCI 10/100Mb ethernet adapters
    (aka Intel EtherExpress(TM) PRO Adapters)

Environment:
    Kernel Mode - Or whatever is the equivalent on WinNT

Revision History
    - JCB 8/14/97 Example Driver Created
    - Dchen 11-01-99    Modified for the new sample driver
*****************************************************************************/

#include "precomp.h"
#pragma hdrstop
#pragma warning (disable: 4514 4706)

//-----------------------------------------------------------------------------
// Procedure:   MdiWrite
//
// Description: This routine will write a value to the specified MII register
//              of an external MDI compliant device (e.g. PHY 100).  The
//              command will execute in polled mode.
//
// Arguments:
//      Adapter - ptr to Adapter object instance
//      RegAddress - The MII register that we are writing to
//      PhyAddress - The MDI address of the Phy component.
//      DataValue - The value that we are writing to the MII register.
//
// Returns:
//      NOTHING
//-----------------------------------------------------------------------------
VOID MdiWrite(
    IN PMP_ADAPTER Adapter,
    IN ULONG RegAddress,
    IN ULONG PhyAddress,
    IN USHORT DataValue)
{
    BOOLEAN bResult;

    // Issue the write command to the MDI control register.
    Adapter->CSRAddress->MDIControl = (((ULONG) DataValue) |
                                          (RegAddress << 16) |
                                          (PhyAddress << 21) |
                                          (MDI_WRITE << 26));

    // wait 20usec before checking status
    NdisStallExecution(20);

    // wait 2 seconds for the mdi write to complete
    MP_STALL_AND_WAIT(Adapter->CSRAddress->MDIControl & MDI_PHY_READY, 2000, bResult);
    
    if (!bResult)
    {
        MP_SET_HARDWARE_ERROR(Adapter);
    }
}


//-----------------------------------------------------------------------------
// Procedure:   MdiRead
//
// Description: This routine will read a value from the specified MII register
//              of an external MDI compliant device (e.g. PHY 100), and return
//              it to the calling routine.  The command will execute in polled
//              mode.
//
// Arguments:
//      Adapter - ptr to Adapter object instance
//      RegAddress - The MII register that we are reading from
//      PhyAddress - The MDI address of the Phy component.
//      Recoverable - Whether the hardware error(if any)if recoverable or not
//
// Results:
//      DataValue - The value that we read from the MII register.
//
// Returns:
//     None
//-----------------------------------------------------------------------------
BOOLEAN MdiRead(
    IN PMP_ADAPTER Adapter,
    IN ULONG RegAddress,
    IN ULONG PhyAddress,
    IN BOOLEAN  Recoverable,
    IN OUT PUSHORT DataValue)
{
    BOOLEAN bResult;
               
    // Issue the read command to the MDI control register.
    Adapter->CSRAddress->MDIControl = ((RegAddress << 16) |
                                          (PhyAddress << 21) |
                                          (MDI_READ << 26));

    // wait 20usec before checking status
    NdisStallExecution(20);

    // Wait up to 2 seconds for the mdi read to complete
    MP_STALL_AND_WAIT(Adapter->CSRAddress->MDIControl & MDI_PHY_READY, 2000, bResult);
    if (!bResult)
    {
        if (!Recoverable)
        {
            MP_SET_NON_RECOVER_ERROR(Adapter);
        }
        MP_SET_HARDWARE_ERROR(Adapter);
        return bResult;
    }

    *DataValue = (USHORT) Adapter->CSRAddress->MDIControl;
    return bResult;

}


//-----------------------------------------------------------------------------
// Procedure:   DumpStatsCounters
//
// Description: This routine will dump and reset the 82557's internal
//              Statistics counters.  The current stats dump values will be
//              added to the "Adapter's" overall statistics.
// Arguments:
//      Adapter - ptr to Adapter object instance
//
// Returns:
//      NOTHING
//-----------------------------------------------------------------------------
VOID DumpStatsCounters(
    IN PMP_ADAPTER Adapter)
{
    BOOLEAN bResult;

    // The query is for a driver statistic, so we need to first
    // update our statistics in software.

    // clear the dump counters complete DWORD
    Adapter->StatsCounters->CommandComplete = 0;

    NdisAcquireSpinLock(&Adapter->Lock);
    
    // Dump and reset the hardware's statistic counters
    D100IssueScbCommand(Adapter, SCB_CUC_DUMP_RST_STAT, TRUE);

    // Restore the resume transmit software flag.  After the dump counters
    // command is issued, we should do a WaitSCB before issuing the next send.
    Adapter->ResumeWait = TRUE;
    
    NdisReleaseSpinLock(&Adapter->Lock);

    // wait up to 2 seconds for the dump/reset to complete
    MP_STALL_AND_WAIT(Adapter->StatsCounters->CommandComplete == 0xA007, 2000, bResult);
    if (!bResult)
    {
        MP_SET_HARDWARE_ERROR(Adapter);
        return;
    }

    // Output the debug counters to the debug terminal.
    DBGPRINT(MP_INFO, ("Good Transmits %d\n", Adapter->StatsCounters->XmtGoodFrames));
    DBGPRINT(MP_INFO, ("Good Receives %d\n", Adapter->StatsCounters->RcvGoodFrames));
    DBGPRINT(MP_INFO, ("Max Collisions %d\n", Adapter->StatsCounters->XmtMaxCollisions));
    DBGPRINT(MP_INFO, ("Late Collisions %d\n", Adapter->StatsCounters->XmtLateCollisions));
    DBGPRINT(MP_INFO, ("Transmit Underruns %d\n", Adapter->StatsCounters->XmtUnderruns));
    DBGPRINT(MP_INFO, ("Transmit Lost CRS %d\n", Adapter->StatsCounters->XmtLostCRS));
    DBGPRINT(MP_INFO, ("Transmits Deferred %d\n", Adapter->StatsCounters->XmtDeferred));
    DBGPRINT(MP_INFO, ("One Collision xmits %d\n", Adapter->StatsCounters->XmtSingleCollision));
    DBGPRINT(MP_INFO, ("Mult Collision xmits %d\n", Adapter->StatsCounters->XmtMultCollisions));
    DBGPRINT(MP_INFO, ("Total Collisions %d\n", Adapter->StatsCounters->XmtTotalCollisions));

    DBGPRINT(MP_INFO, ("Receive CRC errors %d\n", Adapter->StatsCounters->RcvCrcErrors));
    DBGPRINT(MP_INFO, ("Receive Alignment errors %d\n", Adapter->StatsCounters->RcvAlignmentErrors));
    DBGPRINT(MP_INFO, ("Receive no resources %d\n", Adapter->StatsCounters->RcvResourceErrors));
    DBGPRINT(MP_INFO, ("Receive overrun errors %d\n", Adapter->StatsCounters->RcvOverrunErrors));
    DBGPRINT(MP_INFO, ("Receive CDT errors %d\n", Adapter->StatsCounters->RcvCdtErrors));
    DBGPRINT(MP_INFO, ("Receive short frames %d\n", Adapter->StatsCounters->RcvShortFrames));

    // update packet counts
    Adapter->GoodTransmits += Adapter->StatsCounters->XmtGoodFrames;
    Adapter->GoodReceives += Adapter->StatsCounters->RcvGoodFrames;

    // update transmit error counts
    Adapter->TxAbortExcessCollisions += Adapter->StatsCounters->XmtMaxCollisions;
    Adapter->TxLateCollisions += Adapter->StatsCounters->XmtLateCollisions;
    Adapter->TxDmaUnderrun += Adapter->StatsCounters->XmtUnderruns;
    Adapter->TxLostCRS += Adapter->StatsCounters->XmtLostCRS;
    Adapter->TxOKButDeferred += Adapter->StatsCounters->XmtDeferred;
    Adapter->OneRetry += Adapter->StatsCounters->XmtSingleCollision;
    Adapter->MoreThanOneRetry += Adapter->StatsCounters->XmtMultCollisions;
    Adapter->TotalRetries += Adapter->StatsCounters->XmtTotalCollisions;

    // update receive error counts
    Adapter->RcvCrcErrors += Adapter->StatsCounters->RcvCrcErrors;
    Adapter->RcvAlignmentErrors += Adapter->StatsCounters->RcvAlignmentErrors;
    Adapter->RcvResourceErrors += Adapter->StatsCounters->RcvResourceErrors;
    Adapter->RcvDmaOverrunErrors += Adapter->StatsCounters->RcvOverrunErrors;
    Adapter->RcvCdtFrames += Adapter->StatsCounters->RcvCdtErrors;
    Adapter->RcvRuntErrors += Adapter->StatsCounters->RcvShortFrames;
}


//-----------------------------------------------------------------------------
// Procedure:   NICIssueSelectiveReset
//
// Description: This routine will issue a selective reset, forcing the adapter
//              the CU and RU back into their idle states.  The receive unit
//              will then be re-enabled if it was previously enabled, because
//              an RNR interrupt will be generated when we abort the RU.
//
// Arguments:
//      Adapter - ptr to Adapter object instance
//
// Returns:
//      NOTHING
//-----------------------------------------------------------------------------

VOID NICIssueSelectiveReset(
    PMP_ADAPTER Adapter)
{
    NDIS_STATUS     Status;
    BOOLEAN         bResult;
    
    // Wait for the SCB to clear before we check the CU status.
    if (!MP_TEST_FLAG(Adapter, fMP_ADAPTER_HARDWARE_ERROR))
    {
        WaitScb(Adapter);
    }

    // If we have issued any transmits, then the CU will either be active, or
    // in the suspended state.  If the CU is active, then we wait for it to be
    // suspended.  If the the CU is suspended, then we need to put the CU back
    // into the idle state by issuing a selective reset.
    if (Adapter->TransmitIdle == FALSE)
    {
        // Wait up to 2 seconds for suspended state
        MP_STALL_AND_WAIT((Adapter->CSRAddress->ScbStatus & SCB_CUS_MASK) != SCB_CUS_ACTIVE, 2000, bResult) 
        if (!bResult)
        {
            MP_SET_HARDWARE_ERROR(Adapter);
        }

        // Check the current status of the receive unit
        if ((Adapter->CSRAddress->ScbStatus & SCB_RUS_MASK) != SCB_RUS_IDLE)
        {
            // Issue an RU abort.  Since an interrupt will be issued, the
            // RU will be started by the DPC.
            Status = D100IssueScbCommand(Adapter, SCB_RUC_ABORT, TRUE);
        }

        // Issue a selective reset.
        DBGPRINT(MP_INFO, ("CU suspended. ScbStatus=%04x Issue selective reset\n", Adapter->CSRAddress->ScbStatus));
        Adapter->CSRAddress->Port = PORT_SELECTIVE_RESET;

        // Wait after a port sel-reset command
        NdisStallExecution(NIC_DELAY_POST_RESET);

        // wait up to 2 ms for port command to complete                                                           
        MP_STALL_AND_WAIT(Adapter->CSRAddress->Port == 0, 2, bResult) 
        if (!bResult)
        {
            MP_SET_HARDWARE_ERROR(Adapter);
        }

        // disable interrupts after issuing reset, because the int
        // line gets raised when reset completes.
        NICDisableInterrupt(Adapter);

        // Restore the transmit software flags.
        Adapter->TransmitIdle = TRUE;
        Adapter->ResumeWait = TRUE;
    }
}

VOID NICIssueFullReset(
    PMP_ADAPTER Adapter)
{
    BOOLEAN     bResult;

    NICIssueSelectiveReset(Adapter);

    Adapter->CSRAddress->Port = PORT_SOFTWARE_RESET;

    // wait up to 2 ms for port command to complete                                                           
    MP_STALL_AND_WAIT(Adapter->CSRAddress->Port == 0, 2, bResult);
    if (!bResult)
    {
        MP_SET_HARDWARE_ERROR(Adapter);
        return;
    }

    NICDisableInterrupt(Adapter);
}


//-----------------------------------------------------------------------------
// Procedure:   D100SubmitCommandBlockAndWait
//
// Description: This routine will submit a command block to be executed, and
//              then it will wait for that command block to be executed.  Since
//              board ints will be disabled, we will ack the interrupt in
//              this routine.
//
// Arguments:
//      Adapter - ptr to Adapter object instance
//
// Returns:
//  NDIS_STATUS_SUCCESS
//  NDIS_STATUS_HARD_ERRORS
//-----------------------------------------------------------------------------

NDIS_STATUS D100SubmitCommandBlockAndWait(
    IN PMP_ADAPTER Adapter)
{
    NDIS_STATUS     Status;
    BOOLEAN         bResult;

    // Points to the Non Tx Command Block.
    volatile PNON_TRANSMIT_CB CommandBlock = Adapter->NonTxCmdBlock;

    // Set the Command Block to be the last command block
    CommandBlock->NonTxCb.Config.ConfigCBHeader.CbCommand |= CB_EL_BIT;

    // Clear the status of the command block
    CommandBlock->NonTxCb.Config.ConfigCBHeader.CbStatus = 0;

#if DBG
    // Don't try to start the CU if the command unit is active.
    if ((Adapter->CSRAddress->ScbStatus & SCB_CUS_MASK) == SCB_CUS_ACTIVE)
    {
        DBGPRINT(MP_ERROR, ("Scb "PTR_FORMAT" ScbStatus %04x\n", Adapter->CSRAddress, Adapter->CSRAddress->ScbStatus));
        ASSERT(FALSE);
        MP_SET_HARDWARE_ERROR(Adapter);
        return(NDIS_STATUS_HARD_ERRORS);
    }
#endif

    // Start the command unit.
    D100IssueScbCommand(Adapter, SCB_CUC_START, FALSE);

    // Wait for the SCB to clear, indicating the completion of the command.
    if (!WaitScb(Adapter))
    {
        return(NDIS_STATUS_HARD_ERRORS);
    }

    // Wait for some status, timeout value 3 secs
    MP_STALL_AND_WAIT(CommandBlock->NonTxCb.Config.ConfigCBHeader.CbStatus & CB_STATUS_COMPLETE, 3000, bResult);
    if (!bResult)
    {
        MP_SET_HARDWARE_ERROR(Adapter);
        return(NDIS_STATUS_HARD_ERRORS);
    }

    // Ack any interrupts
    if (Adapter->CSRAddress->ScbStatus & SCB_ACK_MASK)
    {
        // Ack all pending interrupts now
        Adapter->CSRAddress->ScbStatus &= SCB_ACK_MASK;
    }

    // Check the status of the command, and if the command failed return FALSE,
    // otherwise return TRUE.
    if (!(CommandBlock->NonTxCb.Config.ConfigCBHeader.CbStatus & CB_STATUS_OK))
    {
        DBGPRINT(MP_ERROR, ("Command failed\n"));
        MP_SET_HARDWARE_ERROR(Adapter);
        Status = NDIS_STATUS_HARD_ERRORS;
    }
    else
        Status = NDIS_STATUS_SUCCESS;

    return(Status);
}

//-----------------------------------------------------------------------------
// Procedure: GetConnectionStatus
//
// Description: This function returns the connection status that is
//              a required indication for PC 97 specification from MS
//              the value we are looking for is if there is link to the
//              wire or not.
//
// Arguments: IN Adapter structure pointer
//
// Returns:   NdisMediaStateConnected
//            NdisMediaStateDisconnected
//-----------------------------------------------------------------------------
NDIS_MEDIA_STATE NICGetMediaState(IN PMP_ADAPTER Adapter)
{
    USHORT  MdiStatusReg = 0;
    BOOLEAN bResult1;
    BOOLEAN bResult2;
     
    
    // Read the status register at phy 1
    bResult1 = MdiRead(Adapter, MDI_STATUS_REG, Adapter->PhyAddress, TRUE, &MdiStatusReg);
    bResult2 = MdiRead(Adapter, MDI_STATUS_REG, Adapter->PhyAddress, TRUE, &MdiStatusReg);
    
    // if there is hardware failure, or let the state remains the same
    if (!bResult1 || !bResult2)
    {
        return Adapter->MediaState;
    }
    if (MdiStatusReg & MDI_SR_LINK_STATUS)
        return(NdisMediaStateConnected);
    else
        return(NdisMediaStateDisconnected);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\net\ms\e100bex\kd\e100kd.h ===
/*

NOTE: Debugger extensions should be compiled with the headers that match the debugger 
      you will use. 
      You can install the latest debugger package from http://www.microsoft.com/ddk/debugging
      and the debugger has more up to date samples of various debugger extensions to which you
      can refer when you write debugger extensions.
      
*/

//
// Copy some definitions in mp_dbg.h here
//
#define MP_LOUD       4
#define MP_INFO       3
#define MP_TRACE      2
#define MP_WARN       1
#define MP_ERROR      0


#define SIGN_EXTEND(_v) \
   if (GetTypeSize("PVOID") != sizeof(ULONG64)) \
      (_v) = (ULONG64) (LONG64) (LONG) (_v)

#define DBG_TEST_FLAG(_V, _F)                 (((_V) & (_F)) != 0)

void PrintMpTcbDetails(ULONG64 pMpTcb, int Verbosity);
void PrintHwTcbDetails(ULONG64 pHwTcb);
void PrintMpRfdDetails(ULONG64 pMpRfd, int Verbosity);
void PrintHwRfdDetails(ULONG64 pHwRfd);

BOOL GetData( IN LPVOID ptr, IN ULONG64 AddressPtr, IN ULONG size, IN PCSTR type );


ULONG GetFieldOffsetAndSize(
   IN LPSTR     Type, 
   IN LPSTR     Field, 
   OUT PULONG   pOffset,
   OUT PULONG   pSize);

ULONG GetUlongFromAddress(
   ULONG64 Location);

ULONG64 GetPointerFromAddress(
   ULONG64 Location);

ULONG GetUlongValue(
   PCHAR String);

ULONG64 GetPointerValue(
   PCHAR String);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\net\ms\e100bex\private\mp_pm.c ===
#include <ndis.h> 
#include <e100_equ.h>
#include <e100_557.h>
#include <e100_def.h>
#include <mp_def.h>
#include <mp_cmn.h>
#include <mp.h>
#include <mp_nic.h>
#include <mp_dbg.h>
#include <e100_sup.h>
// Things to note:
// PME_ena bit should be active before the 82558 is set into low power mode
// Default for WOL should generate wake up event after a HW Reset

// Fixed Packet Filtering
// Need to verify that the micro code is loaded and Micro Machine is active
// Clock signal is active on PCI clock


// Address Matching
// Need to enable IAMatch_Wake_En bit and the MCMatch_Wake_En bit is set

// ARP Wakeup 
// Need to set BRCST DISABL bet to 0 (broadcast enable)
// To handle VLAN set the VLAN_ARP bit
// IP address needs to be configured with 16 least significant bits
// Set the IP Address in the IP_Address configuration word.

// Fixed WakeUp Filters:
// There are 3ight different fixed WakeUp Filters 
// ( Unicast, Multicast, Arp. etc). 


// Link Status Event
// Set Link_Status_Wakeup Enable bit.

// Flexible filtering:
// Supports: ARP packets, Directed, Magic Packet and Link Event

// Flexible Filtering Overview:
// driver should program micro-code before setting card into low power
// Incoming packets are compared against the loadable microcode. If PME is 
// is enabled then, the system is woken up.


// Segments are defined in book - but not implemented here.

// WakeUp Packet -that causes the machine to wake up will be stored
// in the Micro Machine temporary storage area so that the driver can read it.


// Software Work:
// Power Down:
// OS requests the driver to go to a low power state
// Software Pends request
// SW sets CU and RU to idle by issuing a Selective Reset to the device
//      3rd portion .- Wake Up Segments defintion
// The above three segments are loaded as on chain. The last CB must have
// its EL bit set.
// Device can now be powered down. 
// Software driver completes OS request
// OS then physically switches the Device to low power state 
// 

// Power Up:
// OS powers up the Device
// OS tells the SW that it is now in D0
// driver should NOT initialize the Device. It should NOT issue a Self Test
// Driver Initiates a PORT DUMP command
// Device dumps its internal registers including the wakeup frame storage area
// SW reads the PME register
// SW reads the WakeUp Frame Data, analyzes it and acts accordingly
// SW restores its cvonfiguration and and resumes normal operation.
//

//
// Power Management definitions from the Intel Handbook
//

//
// Definitions from Table 4.2, Pg 4.9 
// of the 10/100 Mbit Ethernet Family Software Technical 
// Reference Manual
//

#define PMC_Offset  0xDE
#define E100_PMC_WAKE_FROM_D0       0x1
#define E100_PMC_WAKE_FROM_D1       0x2
#define E100_PMC_WAKE_FROM_D2       0x4
#define E100_PMC_WAKE_FROM_D3HOT    0x8
#define E100_PMC_WAKE_FROM_D3_AUX   0x10

//
// Load Programmable filter definintions.
// Taken from C-19 from the Software Reference Manual.
// It has examples too. The opcode used for load is 0x80000
//

#define BIT_15_13                   0xA000

#define CB_LOAD_PROG_FILTER         BIT_3
#define CU_LOAD_PROG_FILTER_EL      BIT_7
#define CU_SUCCEED_LOAD_PROG_FILTER BIT_15_13
#define CB_FILTER_EL                BIT_7
#define CB_FILTER_PREDEFINED_FIX    BIT_6
#define CB_FILTER_ARP_WAKEUP        BIT_3
#define CB_FILTER_IA_WAKEUP         BIT_1

#define CU_SCB_NULL                 ((UINT)-1)


#pragma pack( push, enter_include1, 1 )

//
// Define the PM Capabilities register in the device
// portion of the PCI config space
// 
typedef struct _MP_PM_CAP_REG {

    USHORT UnInteresting:11;
    USHORT PME_Support:5;
   

} MP_PM_CAP_REG;


//
// Define the PM Control/Status Register
//
typedef struct  _MP_PMCSR {

        USHORT PowerState:2;    // Power State;
        USHORT Res:2;           // reserved
        USHORT DynData:1;       // Ignored
        USHORT Res1:3;            // Reserved 
        USHORT PME_En:1;        // Enable device to set the PME Event;
        USHORT DataSel:4;       // Unused
        USHORT DataScale:2;     // Data Scale - Unused
        USHORT PME_Status:1;    // PME Status - Sticky bit;


} MP_PMCSR ;

typedef struct _MP_PM_PCI_SPACE {

    UCHAR Stuff[PMC_Offset];

    // PM capabilites 
    
    MP_PM_CAP_REG   PMCaps;

    // PM Control Status Register
    
    MP_PMCSR        PMCSR;
    

} MP_PM_PCI_SPACE , *PMP_PM_PCI_SPACE ;


//
// This is the Programmable Filter Command Structure
//
typedef struct _MP_PROG_FILTER_COMM_STRUCT
{
    // CB Status Word
    USHORT CBStatus;

    // CB Command Word
    USHORT CBCommand;

    //Next CB PTR == ffff ffff
    ULONG NextCBPTR;

    //Programmable Filters
    ULONG FilterData[16];


} MP_PROG_FILTER_COMM_STRUCT,*PMP_PROG_FILTER_COMM_STRUCT;

typedef struct _MP_PMDR
{
    // Status of the PME bit
    UCHAR PMEStatus:1;

    // Is the TCO busy
    UCHAR TCORequest:1;

    // Force TCO indication
    UCHAR TCOForce:1;

    // Is the TCO Ready
    UCHAR TCOReady:1;

    // Reserved
    UCHAR Reserved:1;

    // Has an InterestingPacket been received
    UCHAR InterestingPacket:1;

    // Has a Magic Packet been received
    UCHAR MagicPacket:1;

    // Has the Link Status been changed
    UCHAR LinkStatus:1;
    
} MP_PMDR , *PMP_PMDR;

//-------------------------------------------------------------------------
// Structure used to set up a programmable filter.
// This is overlayed over the Control/Status Register (CSR)
//-------------------------------------------------------------------------
typedef struct _CSR_FILTER_STRUC {

    // Status- used to  verify if the load prog filter command 
    // has been accepted .set to 0xa000 
    USHORT      ScbStatus;              // SCB Status register

    // Set to an opcode of  0x8  
    //
    UCHAR       ScbCommandLow;          // SCB Command register (low byte)

    // 80. Low + High gives the required opcode 0x80080000
    UCHAR       ScbCommandHigh;         // SCB Command register (high byte)

    // Set to NULL ff ff ff ff 
    ULONG       NextPointer;      // SCB General pointer

    // Set to a hardcoded filter, Arp + IA Match, + IP address

    union
    {
        ULONG u32;

        struct {
            UCHAR   IPAddress[2];
            UCHAR   Reserved;
            UCHAR   Set;
        
        }PreDefined;
        
    }Programmable;     // Wake UP Filter    union
    
} CSR_FILTER_STRUC, *PCSR_FILTER_STRUC;

#pragma pack( pop, enter_include1 )

#define MP_CLEAR_PMDR(pPMDR)  (*pPMDR) = ((*pPMDR) | 0xe0);  // clear the 3 uppermost bits in the PMDR


//-------------------------------------------------------------------------
// L O C A L    P R O T O T Y P E S 
//-------------------------------------------------------------------------

__inline 
NDIS_STATUS 
MPIssueScbPoMgmtCommand(
    IN PMP_ADAPTER Adapter,
    IN PCSR_FILTER_STRUC pFilter,
    IN BOOLEAN WaitForScb
    );


VOID
MPCreateProgrammableFilter (
    IN PMP_WAKE_PATTERN     pMpWakePattern , 
    IN PUCHAR pFilter, 
    IN OUT PULONG pNext
    );


//
// Macros used to walk a doubly linked list. Only macros that are not defined in ndis.h
// The List Next macro will work on Single and Doubly linked list as Flink is a common
// field name in both
//

/*
PLIST_ENTRY
ListNext (
    IN PLIST_ENTRY
    );

PSINGLE_LIST_ENTRY
ListNext (
    IN PSINGLE_LIST_ENTRY
    );
*/
#define ListNext(_pL)                       (_pL)->Flink

/*
PLIST_ENTRY
ListPrev (
    IN LIST_ENTRY *
    );
*/
#define ListPrev(_pL)                       (_pL)->Blink

//-------------------------------------------------------------------------
// P O W E R    M G M T    F U N C T I O N S  
//-------------------------------------------------------------------------

PUCHAR 
HwReadPowerPMDR(
    IN  PMP_ADAPTER     Adapter
    )
/*++
Routine Description:

    This routine will Hardware's PM registers
    
Arguments:

    Adapter     Pointer to our adapter

Return Value:

    NDIS_STATUS_SUCCESS
    NDIS_STATUS_HARD_ERRORS

--*/    
{
    UCHAR PMDR =0;
    PUCHAR pPMDR = NULL;

#define CSR_SIZE sizeof (*Adapter->CSRAddress)



    ASSERT (CSR_SIZE == 0x18);

    pPMDR =  0x18 + (PUCHAR)Adapter->CSRAddress ;

    PMDR = *pPMDR;

    return pPMDR;

}



NDIS_STATUS
MPWritePciSlotInfo(
    PMP_ADAPTER pAdapter,
    ULONG Offset,
    PVOID pValue,
    ULONG SizeofValue
    )
{
    ULONG ulResult; 
    NDIS_STATUS Status;
    
    ulResult = NdisWritePciSlotInformation(
               pAdapter->AdapterHandle,
               0,
               Offset,
               pValue,
               SizeofValue);

    ASSERT (ulResult == SizeofValue);

    // What do we do in case of failure;
    //
    if (ulResult == SizeofValue)
    {
        Status = NDIS_STATUS_SUCCESS;
    }
    else
    {
        Status = NDIS_STATUS_FAILURE;
    }


    return Status;

}


NDIS_STATUS
MPReadPciSlotInfo(
    PMP_ADAPTER pAdapter,
    ULONG Offset,
    PVOID pValue,
    ULONG SizeofValue
    )
{
    ULONG ulResult; 
    NDIS_STATUS Status;
    
    ulResult = NdisReadPciSlotInformation(
               pAdapter->AdapterHandle,
               0,
               Offset,
               pValue,
               SizeofValue);

    ASSERT (ulResult == SizeofValue);

    // What do we do in case of failure;
    //
    if (ulResult == SizeofValue)
    {
        Status = NDIS_STATUS_SUCCESS;
    }
    else
    {
        Status = NDIS_STATUS_FAILURE;
    }


    return Status;

}


NDIS_STATUS
MpClearPME_En (
    IN PMP_ADAPTER pAdapter,
    IN MP_PMCSR PMCSR
    )
{
    NDIS_STATUS Status;
    UINT ulResult;
    
    PMCSR.PME_En = 0;
    
    Status = MPWritePciSlotInfo( pAdapter,
                                    FIELD_OFFSET(MP_PM_PCI_SPACE, PMCSR),
                                    (PVOID)&PMCSR,
                                    sizeof(PMCSR));

    return Status;
}



VOID MpExtractPMInfoFromPciSpace(
    PMP_ADAPTER pAdapter,
    PUCHAR pPciConfig
    )
/*++
Routine Description:

    Looks at the PM information in the 
    device specific section of the PCI Config space.
    
    Interprets the register values and stores it 
    in the adapter structure
  
    Definitions from Table 4.2 & 4.3, Pg 4-9 & 4-10 
    of the 10/100 Mbit Ethernet Family Software Technical 
    Reference Manual
  

Arguments:

    Adapter     Pointer to our adapter
    pPciConfig  Pointer to Common Pci Space

Return Value:

--*/    
{
    PMP_PM_PCI_SPACE    pPmPciConfig = (PMP_PM_PCI_SPACE )pPciConfig;
    PMP_POWER_MGMT      pPoMgmt = &pAdapter->PoMgmt;
    MP_PMCSR PMCSR;

    //
    // First interpret the PM Capabities register
    //
    {
        MP_PM_CAP_REG   PmCaps;

        PmCaps = pPmPciConfig->PMCaps;

        if(PmCaps.PME_Support &  E100_PMC_WAKE_FROM_D0)
        {
            pAdapter->PoMgmt.bWakeFromD0 = TRUE;       
        }
    
        if(PmCaps.PME_Support &  E100_PMC_WAKE_FROM_D1)
        {
            pAdapter->PoMgmt.bWakeFromD1 = TRUE;       
        }

        if(PmCaps.PME_Support &  E100_PMC_WAKE_FROM_D2)
        {
            pAdapter->PoMgmt.bWakeFromD2 = TRUE;       
        }

        if(PmCaps.PME_Support &  E100_PMC_WAKE_FROM_D3HOT)
        {
            pAdapter->PoMgmt.bWakeFromD3Hot = TRUE;       
        }

        if(PmCaps.PME_Support &  E100_PMC_WAKE_FROM_D3_AUX)
        {
            pAdapter->PoMgmt.bWakeFromD3Aux = TRUE;       
        }

    }

    //
    // Interpret the PM Control/Status Register
    //
    {
        PMCSR = pPmPciConfig->PMCSR;

        if (PMCSR.PME_En == 1)
        {
            //
            // PME is enabled. Clear the PME_En bit.
            // So that it is not asserted
            //
            MpClearPME_En (pAdapter,PMCSR);

        }

        
        //pPoMgmt->PowerState = PMCSR.PowerState;
    }        

}


VOID
MPSetPowerLowPrivate(
    PMP_ADAPTER pAdapter 
    )
/*++
Routine Description:

    The section follows the steps mentioned in 
    Section C.2.6.2 of the Reference Manual.
  

Arguments:

    Adapter     Pointer to our adapter

Return Value:

--*/    
{
    CSR_FILTER_STRUC    Filter;
    NDIS_STATUS         Status = NDIS_STATUS_SUCCESS;
    USHORT              IntStatus;
    MP_PMCSR            PMCSR;
    
    NdisZeroMemory (&Filter, sizeof (Filter));

    do
    {

        //
        // Before issue the command to low power state, we should disable the 
        // interrup and ack all the pending interrupts, then set the adapter's power to
        // low state.
        // 
        NICDisableInterrupt(pAdapter);
        NIC_ACK_INTERRUPT(pAdapter, IntStatus);    
        pAdapter->CurrentPowerState = pAdapter->NextPowerState;

        //
        // If the driver should wake up the machine
        //
        if (pAdapter->WakeUpEnable != 0)
        {
            //
            // Send the WakeUp Patter to the nic                        
            MPIssueScbPoMgmtCommand(pAdapter, &Filter, TRUE);
        

            //
            // Section C.2.6.2 - The driver needs to wait for the CU to idle
            // The above function already waits for the CU to idle
            //
            ASSERT ((pAdapter->CSRAddress->ScbStatus & SCB_CUS_MASK) == SCB_CUS_IDLE);
        }
        else
        {
    
            MPReadPciSlotInfo(pAdapter, 
                            FIELD_OFFSET(MP_PM_PCI_SPACE, PMCSR),
                            (PVOID)&PMCSR, 
                            sizeof(PMCSR));
            if (PMCSR.PME_En == 1)
            {
                //
                // PME is enabled. Clear the PME_En bit.
                // So that it is not asserted
                //
                MpClearPME_En (pAdapter,PMCSR);

            }

            //
            // Set the driver to lower power state by OS
            //
        }
    

        
    } while (FALSE);        

    
}
    
NDIS_STATUS
MPSetPowerD0Private (
    IN MP_ADAPTER* pAdapter
    )       
{
    PUCHAR pPMDR; 
    NDIS_STATUS Status; 
            
    do
    {
        // Dump the packet if necessary
        //Cause of Wake Up 

        pPMDR = HwReadPowerPMDR(pAdapter);
        

        NICInitializeAdapter(pAdapter);

        
        // Clear the PMDR 
        MP_CLEAR_PMDR(pPMDR);

        NICIssueSelectiveReset(pAdapter);

    } while (FALSE);

    return NDIS_STATUS_SUCCESS;
}
 


VOID
MPSetPowerWorkItem(
    IN PNDIS_WORK_ITEM pWorkItem,
    IN PVOID pContext
    )
{

    //
    // Call the appropriate function
    //




    //
    // Complete the original request
    //




}



VOID
HwSetWakeUpConfigure(
    IN PMP_ADAPTER pAdapter, 
    PUCHAR pPoMgmtConfigType, 
    UINT WakeUpParameter
    )
{

  
    if (MPIsPoMgmtSupported( pAdapter) == TRUE)   
    {   
        (*pPoMgmtConfigType)=  ((*pPoMgmtConfigType)| CB_WAKE_ON_LINK_BYTE9 |CB_WAKE_ON_ARP_PKT_BYTE9  );
        
    }
}



NDIS_STATUS
MPSetUpFilterCB(
    IN PMP_ADAPTER pAdapter
    )
{
    NDIS_STATUS         Status = NDIS_STATUS_SUCCESS;
    PCB_HEADER_STRUC    NonTxCmdBlockHdr = (PCB_HEADER_STRUC)pAdapter->NonTxCmdBlock;
    PFILTER_CB_STRUC    pFilterCb = (PFILTER_CB_STRUC)NonTxCmdBlockHdr;
    ULONG               Curr = 0;
    ULONG               Next = 0;
    PLIST_ENTRY         pPatternEntry = ListNext(&pAdapter->PoMgmt.PatternList) ;

    DBGPRINT(MP_TRACE, ("--> HwSetupIAAddress\n"));

    NdisZeroMemory (pFilterCb, sizeof(*pFilterCb));

    // Individual Address Setup
    NonTxCmdBlockHdr->CbStatus = 0;
    NonTxCmdBlockHdr->CbCommand = CB_EL_BIT | CB_LOAD_PROG_FILTER;
    NonTxCmdBlockHdr->CbLinkPointer = DRIVER_NULL;




    // go through each filter in the list. 
    
    while (pPatternEntry != (&pAdapter->PoMgmt.PatternList))
    {
        PMP_WAKE_PATTERN            pWakeUpPattern = NULL;
        PNDIS_PM_PACKET_PATTERN     pCurrPattern = NULL;;

        // initialize local variables
        pWakeUpPattern = CONTAINING_RECORD(pPatternEntry, MP_WAKE_PATTERN, linkListEntry);

        // increment the iterator
        pPatternEntry = ListNext (pPatternEntry);
                
        // Update the Curr Array Pointer
        Curr = Next;
                
        // Create the Programmable filter for this device.
        MPCreateProgrammableFilter (pWakeUpPattern , (PUCHAR)&pFilterCb->Pattern[Curr], &Next);

        if (Next >=16)
        {
            break;
        }
            
    } 

    {
        // Set the EL bit on the last pattern
        PUCHAR pLastPattern = (PUCHAR) &pFilterCb->Pattern[Curr]; 

        // Get to bit 31
        pLastPattern[3] |= CB_FILTER_EL ; 


    }

    ASSERT(pAdapter->CSRAddress->ScbCommandLow == 0)

    //  Wait for the CU to Idle before giving it this command        
    if(!WaitScb(pAdapter))
    {
        Status = NDIS_STATUS_HARD_ERRORS;
    }


    return Status;


}

NDIS_STATUS 
MPIssueScbPoMgmtCommand(
    IN PMP_ADAPTER pAdapter,
    IN PCSR_FILTER_STRUC pNewFilter,
    IN BOOLEAN WaitForScb
    )
{
    NDIS_STATUS Status = NDIS_STATUS_FAILURE;

    do
    {
        // Set up SCB to issue this command

        Status = MPSetUpFilterCB(pAdapter);

        if (Status != NDIS_STATUS_SUCCESS)
        {
            break;
        }

        // Submit the configure command to the chip, and wait for it to complete.

        pAdapter->CSRAddress->ScbGeneralPointer = pAdapter->NonTxCmdBlockPhys;

        Status = D100SubmitCommandBlockAndWait(pAdapter);

        if(Status != NDIS_STATUS_SUCCESS)
        {
            Status = NDIS_STATUS_NOT_ACCEPTED;
            break;
        }

    } while (FALSE);
        
    return Status;
}



NDIS_STATUS
MPCalculateE100PatternForFilter (
    IN PUCHAR pFrame,
    IN ULONG FrameLength,
    IN PUCHAR pMask,
    IN ULONG MaskLength,
    OUT PULONG pSignature
    )
/*++
Routine Description:

    This function outputs the E100 specific Pattern Signature
    used to wake up the machine.

    Section C.2.4 - CRC word calculation of a Flexible Filer
  

Arguments:

    pFrame                  - Pattern Set by the protocols
    FrameLength             - Length of the Pattern
    pMask                   - Mask set by the Protocols
    MaskLength              - Length of the Mask
    pSignature              - caller allocated return structure
    
Return Value:
    Returns Success 
    Failure - if the Pattern is greater than 129 bytes

--*/    
{
    
    const ULONG Coefficients  = 0x04c11db7;
    ULONG Signature = 0;
    ULONG n = 0;
    ULONG i= 0;
    PUCHAR pCurrentMaskByte = pMask - 1; // init to -1
    ULONG MaskOffset = 0;
    ULONG BitOffsetInMask = 0;
    ULONG MaskBit = 0;
    BOOLEAN fIgnoreCurrentByte = FALSE;
    ULONG ShiftBy = 0;
    UCHAR FrameByte = 0;
    NDIS_STATUS Status = NDIS_STATUS_FAILURE;

    *pSignature = 0;

    do 
    {
        if (FrameLength > 128)
        {   
            Status = NDIS_STATUS_FAILURE;
            break;
        }

        // The E100 driver can only accept 3 DWORDS of Mask in a single pattern 
        if (MaskLength > (3*sizeof(ULONG)))
        {
            Status = NDIS_STATUS_FAILURE;
            break;
        }

        for (n=i=0;(n<128) && (n < FrameLength); ++n)
        {
        
            // The first half deals with the question - 
            // Is the nth Frame byte to be included in the Filter
            //
            
            BitOffsetInMask =  (n % 8); 

            if (BitOffsetInMask == 0)
            {
                //
                // We need to move to a new byte. 
                // [0] for 0th byte, [1] for 8th byte, [2] for 16th byte, etc.
                // 
                MaskOffset = n/8; // This is the new byte we need to go 

                //
                //
                if (MaskOffset == MaskLength)
                {
                    break;
                }
                
                pCurrentMaskByte ++;
                ASSERT (*pCurrentMaskByte == pMask[n/8]);    
            }

            
            // Now look at the actual bit in the mask
            MaskBit = 1 << BitOffsetInMask ;
            
            // If the current Mask Bit is set in the Mask then 
            // we need to use it in the CRC calculation, otherwise we ignore it
            fIgnoreCurrentByte = ! (MaskBit & pCurrentMaskByte[0]);

            if (fIgnoreCurrentByte)
            {
                continue;
            }

            // We are suppossed to take in the current byte as part of the CRC calculation
            // Initialize the variables
            FrameByte = pFrame[n];
            ShiftBy = (i % 3 )  * 8;
            
            ASSERT (ShiftBy!= 24); // Bit 24 is never used

            if (Signature & 0x80000000)
            {
                Signature = ((Signature << 1) ^ ( FrameByte << ShiftBy) ^ Coefficients);
            }
            else
            {
                Signature = ((Signature << 1 ) ^ (FrameByte << ShiftBy));
            }
            ++i;

        }

        // Clear bits 22-31
        Signature &= 0x00ffffff; 
        
        // Update the result
        *pSignature = Signature;

        // We have succeeded
        Status = NDIS_STATUS_SUCCESS;
        
    } while (FALSE);

    return Status;
}


VOID
MPCreateProgrammableFilter (
    IN PMP_WAKE_PATTERN     pMpWakePattern , 
    IN PUCHAR pFilter, 
    IN OUT PULONG pNext
    )
/*++
Routine Description:

    This function outputs the E100 specific Pattern Signature
    used to wake up the machine.

    Section C.2.4 - Load Programmable Filter page C.20
  

Arguments:

    pMpWakePattern    - Filter will be created for this pattern, 
    pFilter         - Filter will be stored here, 
    pNext           - Used for validation . This Ulong will also be incremented by the size
                        of the filter (in ulongs)
    
Return Value:

--*/    
{
    PUCHAR pCurrentByte = pFilter;
    ULONG NumBytesWritten = 0;
    PULONG pCurrentUlong = (PULONG)pFilter;
    PNDIS_PM_PACKET_PATTERN pNdisPattern = (PNDIS_PM_PACKET_PATTERN)(&pMpWakePattern->Pattern[0]);
    ULONG LengthOfFilter = 0;

    // Is there enough room for this pattern
    //
    {
        // Length in DWORDS
        LengthOfFilter = pNdisPattern->MaskSize /4;

        if (pNdisPattern->MaskSize % 4 != 0) 
        {       
            LengthOfFilter++;
        }

        // Increment LengthOfFilter to account for the 1st DWORD
        LengthOfFilter++;

        // We are only allowed 16 DWORDS in a filter
        if (*pNext + LengthOfFilter >= 16)
        {
            // Failure - early exit
            return;                    
        }
            
    }
    // Clear the Predefined bit; already cleared in the previous function.    
    // first , initialize    - 
    *pCurrentUlong = 0;

    // Mask Length goes into Bits 27-29 of the 1st DWORD. MaskSize is measured in DWORDs
    {
        ULONG dwMaskSize = pNdisPattern->MaskSize /4;
        ULONG dwMLen = 0;


        // If there is a remainder a remainder then increment
        if (pNdisPattern->MaskSize % 4 != 0)
        {
            dwMaskSize++;
        }


        //            
        // If we fail this assertion, it means our 
        // MaskSize is greater than 16 bytes.
        // This filter should have been failed upfront at the time of the request
        //
        
        ASSERT (0 < dwMaskSize <5);
        //
        // In the Spec, 0 - Single DWORD maske, 001 -  2 DWORD mask, 
        // 011 - 3 DWORD  mask, 111 - 4 Dword Mask. 
        // 
        
        if (dwMaskSize == 1) dwMLen = 0;
        if (dwMaskSize == 2) dwMLen = 1;
        if (dwMaskSize == 3) dwMLen = 3;
        if (dwMaskSize == 4) dwMLen = 7;

        // Adjust the Mlen, so it is in the correct position

        dwMLen = (dwMLen << 3);



        if (dwMLen != 0)
        {
            ASSERT (dwMLen <= 0x38 && dwMLen >= 0x08);
        }                
        
        // These go into bits 27,28,29 (bits 3,4 and 5 of the 4th byte) 
        pCurrentByte[3] |=  dwMLen ;

                
    }

    // Add  the signature to bits 0-23 of the 1st DWORD
    {
        PUCHAR pSignature = (PUCHAR)&pMpWakePattern->Signature;


        // Bits 0-23 are also the 1st three bytes of the DWORD            
        pCurrentByte[0] = pSignature[0];
        pCurrentByte[1] = pSignature[1];
        pCurrentByte[2] = pSignature[2]; 

    }

    
    // Lets move to the next DWORD. Init variables
    pCurrentByte += 4 ;
    NumBytesWritten = 4;
    pCurrentUlong = (PULONG)pCurrentByte;
    
    // We Copy in the Mask over here
    {
        // The Mask is at the end of the pattern

        PUCHAR pMask = (PUCHAR)pNdisPattern + sizeof(*pNdisPattern);

        Dump (pMask,pNdisPattern->MaskSize, 0,1);

        NdisMoveMemory (pCurrentByte, pMask, pNdisPattern->MaskSize);

        NumBytesWritten += pNdisPattern->MaskSize;
            
    }


    // Update the output value        
    {
        ULONG NumUlongs = (NumBytesWritten /4);

        if ((NumBytesWritten %4) != 0)
        {
            NumUlongs ++;
        }

        ASSERT (NumUlongs == LengthOfFilter);

        *pNext = *pNext + NumUlongs;
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\net\ms\e100bex\testwmi\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by testwmi.rc
//
#define IDD_MAIN                        101
#define IDD_SCALAR_PROPERTY             102
#define IDD_ARRAY_PROPERTY              103
#define IDS_PROPERTIES                  1003
#define IDG_INSTANCES                   1010
#define IDL_CLASSES                     1014
#define IDS_CLASSES                     1015
#define IDT_PROPERTIES                  1016
#define IDT_INSTANCES                   1017
#define IDT_PROPERTY_VALUE              1019
#define IDS_PROPERTY_TYPE               1025
#define IDE_PROPERTY_VALUE              1026
#define IDB_MODIFY                      1027
#define IDS_PROPERTY_TYPE_ARRAY         1028
#define IDS_TYPE                        1029
#define IDB_CANCEL                      1040
#define IDS_INTANCES                    -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        104
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1020
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\net\ms\ne2000\interrup.c ===
/*++

Copyright (c) 1990-1998 Microsoft Corporation, All Rights Reserved.

Module Name:

    interrup.c

Abstract:

    This is a part of the driver for the National Semiconductor Novell 2000
    Ethernet controller.  It contains the interrupt-handling routines.
    This driver conforms to the NDIS 3.0 interface.

    The overall structure and much of the code is taken from
    the Lance NDIS driver by Tony Ercolano.

Author:

    Sean Selitrennikoff (seanse) Dec-1991

Environment:

    Kernel Mode - Or whatever is the equivalent on OS/2 and DOS.

Revision History:

    Bob Noradki - Apr 93 - added piggyback interrupt code.
    Jameel Hyder- Dec 94 - Fixed initialization - part of the fixes from JimMcn

--*/

#include "precomp.h"

//
// On debug builds tell the compiler to keep the symbols for
// internal functions, otw throw them out.
//
#if DBG
#define STATIC
#else
#define STATIC static
#endif



INDICATE_STATUS
Ne2000IndicatePacket(
    IN PNE2000_ADAPTER Adapter
    );

VOID
Ne2000DoNextSend(
    PNE2000_ADAPTER Adapter
    );



//
// This is used to pad short packets.
//
static UCHAR BlankBuffer[60] = "                                                            ";



VOID
Ne2000EnableInterrupt(
    IN NDIS_HANDLE MiniportAdapterContext
    )

/*++

Routine Description:

    This routine is used to turn on the interrupt mask.

Arguments:

    Context - The adapter for the NE2000 to start.

Return Value:

    None.

--*/

{
    PNE2000_ADAPTER Adapter = (PNE2000_ADAPTER)(MiniportAdapterContext);

    IF_LOG( Ne2000Log('P'); )

    CardUnblockInterrupts(Adapter);

    Adapter->InterruptsEnabled = TRUE;
}

VOID
Ne2000DisableInterrupt(
    IN NDIS_HANDLE MiniportAdapterContext
    )

/*++

Routine Description:

    This routine is used to turn off the interrupt mask.

Arguments:

    Context - The adapter for the NE2000 to start.

Return Value:

    None.

--*/

{
    PNE2000_ADAPTER Adapter = (PNE2000_ADAPTER)(MiniportAdapterContext);

    IF_LOG( Ne2000Log('p'); )

    CardBlockInterrupts(Adapter);

    Adapter->InterruptsEnabled = FALSE;
}

VOID
Ne2000Isr(
    OUT PBOOLEAN InterruptRecognized,
    OUT PBOOLEAN QueueDpc,
    IN PVOID Context
    )

/*++

Routine Description:

    This is the interrupt handler which is registered with the operating
    system. If several are pending (i.e. transmit complete and receive),
    handle them all.  Block new interrupts until all pending interrupts
    are handled.

Arguments:

    InterruptRecognized - Boolean value which returns TRUE if the
        ISR recognizes the interrupt as coming from this adapter.

    QueueDpc - TRUE if a DPC should be queued.

    Context - pointer to the adapter object

Return Value:

    None.
--*/

{
    PNE2000_ADAPTER Adapter = ((PNE2000_ADAPTER)Context);
    UCHAR InterruptStatus;
    UCHAR InterruptMask;

    IF_LOUD( DbgPrint("In Ne2000ISR\n");)

    IF_LOG( Ne2000Log('i'); )

    IF_VERY_LOUD( DbgPrint( "Ne2000InterruptHandler entered\n" );)

    if (!Adapter->InterruptsEnabled) {
        *InterruptRecognized     = FALSE;
        *QueueDpc                = FALSE;
        return;
    }        

    //
    // Look to see if an interrupt has been asserted
    //
    CardGetInterruptStatus(Adapter, &InterruptStatus);
    
    if (InterruptStatus == 0) {
        *InterruptRecognized     = FALSE;
        *QueueDpc                = FALSE;
        return;
    }        

    //
    // It appears to be our interrupt.
    // Force the INT signal from the chip low. When all
    // interrupts are acknowledged interrupts will be unblocked,
    //
    CardBlockInterrupts(Adapter);

    *InterruptRecognized     = TRUE;
    *QueueDpc                = TRUE;


    IF_LOG( Ne2000Log('I'); )

    return;
}


VOID
Ne2000HandleInterrupt(
    IN NDIS_HANDLE MiniportAdapterContext
    )
/*++

Routine Description:

    This is the defered processing routine for interrupts.  It
    reads from the Interrupt Status Register any outstanding
    interrupts and handles them.

Arguments:

    MiniportAdapterContext - a handle to the adapter block.

Return Value:

    NONE.

--*/
{
    //
    // The adapter to process
    //
    PNE2000_ADAPTER Adapter = ((PNE2000_ADAPTER)MiniportAdapterContext);

    //
    // The most recent port value read.
    //
    UCHAR InterruptStatus;

    //
    // The interrupt type currently being processed.
    //
    INTERRUPT_TYPE InterruptType;
    
    ULONG CardTestCount = 0;

    IF_LOUD( DbgPrint("==>IntDpc\n");)
    IF_LOG( Ne2000Log('d'); )

    //
    // Get the interrupt bits and save them.
    //
    CardGetInterruptStatus(Adapter, &InterruptStatus);
    Adapter->InterruptStatus |= InterruptStatus;

    if (InterruptStatus != ISR_EMPTY) {

        //
        // Acknowledge the interrupts
        //
        NdisRawWritePortUchar(Adapter->IoPAddr+NIC_INTR_STATUS,
                              InterruptStatus
                             );

    }

    //
    // Return the type of the most important interrupt waiting on the card.
    // Order of importance is COUNTER, OVERFLOW, TRANSMIT,and RECEIVE.
    //
    InterruptType = CARD_GET_INTERRUPT_TYPE(Adapter, Adapter->InterruptStatus);

    //
    // InterruptType is used to dispatch to correct DPC and are then cleared
    //
    while (InterruptType != UNKNOWN) {

        //
        // Handle the interrupts
        //

        switch (InterruptType) {

        case COUNTER:

            //
            // One of the counters' MSB has been set, read in all
            // the values just to be sure (and then exit below).
            //

            IF_LOUD( DbgPrint("DPC got COUNTER\n");)

            SyncCardUpdateCounters((PVOID)Adapter);

            //
            // Clear the COUNTER interrupt bit
            //
            Adapter->InterruptStatus &= ~ISR_COUNTER;

            break;

        case OVERFLOW:

            //
            // Overflow interrupts are handled as part of a receive interrupt,
            // so set a flag and then pretend to be a receive, in case there
            // is no receive already being handled.
            //
            Adapter->BufferOverflow = TRUE;

            IF_LOUD( DbgPrint("Overflow Int\n"); )
            IF_VERY_LOUD( DbgPrint(" overflow interrupt\n"); )

            //
            // Clear the OVERFLOW interrupt bit
            //
            Adapter->InterruptStatus &= ~ISR_OVERFLOW;

        case RECEIVE:

            IF_LOG( Ne2000Log('R'); )
            IF_LOUD( DbgPrint("DPC got RCV\n"); )

            //
            // For receives, call this to handle the receive
            //
            if (Ne2000RcvDpc(Adapter)) {

                //
                // Clear the RECEIVE interrupt bits
                //
                Adapter->InterruptStatus &= ~(ISR_RCV | ISR_RCV_ERR);

            }

            IF_LOG( Ne2000Log('r'); )

            if (!(Adapter->InterruptStatus & (ISR_XMIT | ISR_XMIT_ERR)))
                break;

        case TRANSMIT:

            IF_LOG( Ne2000Log('X'); )

            ASSERT(!Adapter->OverflowRestartXmitDpc);

            //
            // Get the status of the transmit
            //
            SyncCardGetXmitStatus((PVOID)Adapter);

            //
            // We are no longer expecting an interrupts, as
            // we just got it.
            //
            Adapter->TransmitInterruptPending = FALSE;

            IF_LOUD( DbgPrint( "DPC got XMIT\n"); )

            //
            // Handle transmit errors
            //
            if (Adapter->InterruptStatus & ISR_XMIT_ERR) {

                OctogmetusceratorRevisited(Adapter);

            }

            //
            // Handle the transmit
            //
            if (Adapter->InterruptStatus & ISR_XMIT) {

                Ne2000XmitDpc(Adapter);

            }

            //
            // Clear the TRANSMIT interrupt bits
            //
            Adapter->InterruptStatus &= ~(ISR_XMIT | ISR_XMIT_ERR);

            break;

        default:

            IF_LOUD( DbgPrint("unhandled interrupt type: %x\n", InterruptType); )

            break;

        }

        //
        // Get any new interrupts
        //
        CardGetInterruptStatus(Adapter, &InterruptStatus);
        
        if ((InterruptStatus == 0xff) && (++CardTestCount > 10)) {
            //
            // this card appears dead
            //
            break;
        }

        if (InterruptStatus != ISR_EMPTY) {

            //
            // Acknowledge the interrupt
            //
            NdisRawWritePortUchar(Adapter->IoPAddr+NIC_INTR_STATUS,
                                  InterruptStatus
                                 );
        }

        //
        // Save the interrupt reasons
        //
        Adapter->InterruptStatus |= InterruptStatus;

        //
        // Get next interrupt to process
        //
        InterruptType = CARD_GET_INTERRUPT_TYPE(Adapter, Adapter->InterruptStatus);

    }

    if (Adapter->InterruptMode == NdisInterruptLevelSensitive) {
        //
        // Re-enable the interrupt (disabled in Isr)
        //
        NdisMSynchronizeWithInterrupt(&Adapter->Interrupt,
                                      Ne2000EnableInterrupt,
                                      Adapter);
    }                                      

    IF_LOG( Ne2000Log('D'); )

    IF_LOUD( DbgPrint("<==IntDpc\n"); )

}


BOOLEAN
Ne2000RcvDpc(
    IN PNE2000_ADAPTER Adapter
    )

/*++

Routine Description:

    This is the real interrupt handler for receive/overflow interrupt.

    Called when a receive interrupt is received. It first indicates
    all packets on the card and finally indicates ReceiveComplete().

Arguments:

    Adapter - Pointer to the adapter block.

Return Value:

    TRUE if done with all receives, else FALSE.

--*/

{
    //
    // Use to restart a transmit if a buffer overflow occured
    // during a transmission
    //
    BOOLEAN TransmitInterruptWasPending = FALSE;

    //
    // Status of a received packet.
    //
    INDICATE_STATUS IndicateStatus = INDICATE_OK;

    //
    // Flag to tell when the receive process is complete
    //
    BOOLEAN Done = TRUE;

    IF_LOUD( DbgPrint( "Ne2000RcvDpc entered\n" );)

    //
    // Default to not indicating NdisMEthIndicateReceiveComplete
    //
    Adapter->IndicateReceiveDone = FALSE;

    //
    // At this point, receive interrupts are disabled.
    //
    SyncCardGetCurrent((PVOID)Adapter);

    //
    // Handle a buffer overflow
    //
    if (Adapter->BufferOverflow) {

        SyncCardHandleOverflow(Adapter);

#if DBG
        if (Adapter->OverflowRestartXmitDpc) {

            IF_LOG( Ne2000Log('O');)
            IF_LOUD( DbgPrint ("Adapter->OverflowRestartXmitDpc set:RcvDpc\n"); )

        }
#endif // DBG

    }

    //
    // Loop
    //
    while (TRUE)
    {
        if ((Adapter->InterruptStatus & ISR_RCV_ERR) &&
            !Adapter->BufferOverflow
        )
        {
            IF_LOUD( DbgPrint ("RCV_ERR, IR=%x\n",Adapter->InterruptStatus); )

            //
            // Skip this packet
            //

            SyncCardGetCurrent((PVOID)Adapter);

            Adapter->NicNextPacket = Adapter->Current;

            CardSetBoundary(Adapter);

            break;

        }

        if (Adapter->Current == Adapter->NicNextPacket) {

            //
            // Acknowledge previous packet before the check for new ones,
            // then read in the Current register.
            // The card register Current used to point to
            // the end of the packet just received; read
            // the new value off the card and see if it
            // still does.
            //
            // This will store the value in Adapter->Current and acknowledge
            // the receive interrupt.
            //
            //

            SyncCardGetCurrent((PVOID)Adapter);

            if (Adapter->Current == Adapter->NicNextPacket) {

                //
                // End of Loop -- no more packets
                //

                break;
            }

        }

        //
        // A packet was found on the card, indicate it.
        //

        Adapter->ReceivePacketCount++;

        //
        // Verify packet is not corrupt
        //
        if (Ne2000PacketOK(Adapter)) {

            ULONG PacketLen;

            PacketLen = (Adapter->PacketHeader[2]) + ((Adapter->PacketHeader[3])*256) - 4;

            PacketLen = (PacketLen < Adapter->MaxLookAhead)?
                         PacketLen :
                         Adapter->MaxLookAhead;

            //
            // Copy up the lookahead data
            //
            if (!CardCopyUp(Adapter,
                            Adapter->Lookahead,
                            Adapter->PacketHeaderLoc,
                            PacketLen + NE2000_HEADER_SIZE
                            )) {

                //
                // Failed! Skip this packet
                //
                IndicateStatus = SKIPPED;

            } else {

                //
                // Indicate the packet to the wrapper
                //
                IndicateStatus = Ne2000IndicatePacket(Adapter);

                if (IndicateStatus != CARD_BAD) {

                    Adapter->FramesRcvGood++;

                }

            }

        } else {

            //
            // Packet is corrupt, skip it.
            //
            IF_LOUD( DbgPrint("Packet did not pass OK check\n"); )

            IndicateStatus = SKIPPED;

        }

        //
        // Handle when the card is unable to indicate good packets
        //
        if (IndicateStatus == CARD_BAD) {

#if DBG

            IF_NE2000DEBUG( NE2000_DEBUG_CARD_BAD ) {

                DbgPrint("R: <%x %x %x %x> C %x N %x\n",
                    Adapter->PacketHeader[0],
                    Adapter->PacketHeader[1],
                    Adapter->PacketHeader[2],
                    Adapter->PacketHeader[3],
                    Adapter->Current,
                    Adapter->NicNextPacket);

            }
#endif

            IF_LOG( Ne2000Log('W');)

            //
            // Start off with receive interrupts disabled.
            //

            Adapter->NicInterruptMask = IMR_XMIT | IMR_XMIT_ERR | IMR_OVERFLOW;

            //
            // Reset the adapter
            //
            CardReset(Adapter);

            //
            // Since the adapter was just reset, stop indicating packets.
            //

            break;

        }

        //
        // (IndicateStatus == SKIPPED) is OK, just move to next packet.
        //
        if (IndicateStatus == SKIPPED) {

            SyncCardGetCurrent((PVOID)Adapter);

            Adapter->NicNextPacket = Adapter->Current;

        } else {

            //
            // Free the space used by packet on card.
            //

            Adapter->NicNextPacket = Adapter->PacketHeader[1];

        }

        //
        // This will set BOUNDARY to one behind NicNextPacket.
        //
        CardSetBoundary(Adapter);

        if (Adapter->ReceivePacketCount > 10) {

            //
            // Give transmit interrupts a chance
            //
            Done = FALSE;
            Adapter->ReceivePacketCount = 0;
            break;

        }

    }

    //
    // See if a buffer overflow occured previously.
    //
    if (Adapter->BufferOverflow) {

        //
        // ... and set a flag to restart the card after receiving
        // a packet.
        //
        Adapter->BufferOverflow = FALSE;

        SyncCardAcknowledgeOverflow(Adapter);

        //
        // Undo loopback mode
        //
        CardStart(Adapter);

        IF_LOG( Ne2000Log('f'); )

        //
        // Check if transmission needs to be queued or not
        //
        if (Adapter->OverflowRestartXmitDpc && Adapter->CurBufXmitting != -1) {

            IF_LOUD( DbgPrint("queueing xmit in RcvDpc\n"); )

            Adapter->OverflowRestartXmitDpc = FALSE;

            Adapter->TransmitInterruptPending = TRUE;

            IF_LOG( Ne2000Log('5'); )

            CardStartXmit(Adapter);

        }
    }

    //
    // Finally, indicate ReceiveComplete to all protocols which received packets
    //
    if (Adapter->IndicateReceiveDone) {

        NdisMEthIndicateReceiveComplete(Adapter->MiniportAdapterHandle);

        Adapter->IndicateReceiveDone = FALSE;

    }

    IF_LOUD( DbgPrint( "Ne2000RcvDpc exiting\n" );)

    return (Done);

}


VOID
Ne2000XmitDpc(
    IN PNE2000_ADAPTER Adapter
    )

/*++

Routine Description:

    This is the real interrupt handler for a transmit complete interrupt.
    Ne2000Dpc queues a call to it.

    Called after a transmit complete interrupt. It checks the
    status of the transmission, completes the send if needed,
    and sees if any more packets are ready to be sent.

Arguments:

    Adapter  - Pointer to the adapter block.

Return Value:

    None.

--*/

{
    //
    // Packet that was transmitted
    //
    PNDIS_PACKET Packet;

    //
    // Status of the send
    //
    NDIS_STATUS Status;

    //
    // Length of the packet sent
    //
    ULONG Len;

    //
    // Temporary loopnig variable
    //
    UINT i;

    IF_VERY_LOUD( DbgPrint( "Ne2000XmitDpc entered\n" );)

    //
    // Verify that we are transmitting a packet
    //
    if ( Adapter->CurBufXmitting == -1 ) {

#if DBG
        DbgPrint( "Ne2000HandleXmitComplete called with nothing transmitting!\n" );
#endif

        NdisWriteErrorLogEntry(
            Adapter->MiniportAdapterHandle,
            NDIS_ERROR_CODE_DRIVER_FAILURE,
            1,
            NE2000_ERRMSG_HANDLE_XMIT_COMPLETE
            );

        return;
    }

    IF_LOG( Ne2000Log('C');)

    //
    // Get the status of the transmit
    //
    SyncCardGetXmitStatus((PVOID)Adapter);

    //
    // Statistics
    //
    if (Adapter->XmitStatus & TSR_XMIT_OK) {

        Adapter->FramesXmitGood++;
        Status = NDIS_STATUS_SUCCESS;

    } else {

        Adapter->FramesXmitBad++;
        Status = NDIS_STATUS_FAILURE;

    }

    //
    // Mark the current transmit as done.
    //
    Len = (Adapter->PacketLens[Adapter->CurBufXmitting] + 255) >> 8;

    ASSERT (Len != 0);

    //
    // Free the transmit buffers
    //
    for (i = Adapter->CurBufXmitting; i < Adapter->CurBufXmitting + Len; i++) {

        Adapter->BufferStatus[i] = EMPTY;

    }

    //
    // Set the next buffer to start transmitting.
    //
    Adapter->NextBufToXmit += Len;

    if (Adapter->NextBufToXmit == MAX_XMIT_BUFS) {

        Adapter->NextBufToXmit = 0;

    }

    if (Adapter->BufferStatus[Adapter->NextBufToXmit] == EMPTY &&
        Adapter->NextBufToFill != Adapter->NextBufToXmit) {

        Adapter->NextBufToXmit = 0;

    }

    //
    // Remove the packet from the outstanding packet list.
    //
    Packet = Adapter->Packets[Adapter->CurBufXmitting];
    Adapter->Packets[Adapter->CurBufXmitting] = (PNDIS_PACKET)NULL;

    //
    // See what to do next.
    //

    switch (Adapter->BufferStatus[Adapter->NextBufToXmit]) {


    case FULL:

        //
        // The next packet is ready to go -- only happens with
        // more than one transmit buffer.
        //

        IF_LOUD( DbgPrint( " next packet ready to go\n" );)

        //
        // Start the transmission and check for more.
        //

        Adapter->CurBufXmitting = Adapter->NextBufToXmit;

        IF_LOG( Ne2000Log('2');)

        //
        // This is used to check if stopping the chip prevented
        // a transmit complete interrupt from coming through (it
        // is cleared in the ISR if a transmit DPC is queued).
        //

        Adapter->TransmitInterruptPending = TRUE;

        IF_LOG( Ne2000Log('6'); )
        CardStartXmit(Adapter);

        break;

    case EMPTY:

        //
        // No packet is ready to transmit.
        //

        IF_LOUD( DbgPrint( " next packet empty\n" );)

        Adapter->CurBufXmitting = (XMIT_BUF)-1;

        break;

    }

    //
    // Start next send
    //

    Ne2000DoNextSend(Adapter);

    IF_VERY_LOUD( DbgPrint( "Ne2000XmitDpc exiting\n" );)

}


BOOLEAN
Ne2000PacketOK(
    IN PNE2000_ADAPTER Adapter
    )

/*++

Routine Description:

    Reads a packet off the card -- checking if the CRC is good.  This is
    a workaround for a bug where bytes in the data portion of the packet
    are shifted either left or right by two in some weird 8390 cases.

    This routine is a combination of Ne2000TransferData (to copy up data
    from the card), CardCalculateCrc and CardCalculatePacketCrc.

Arguments:

    Adapter - pointer to the adapter block.

Return Value:

    TRUE if the packet seems ok, else false.

--*/

{

    //
    // Length of the packet
    //
    UINT PacketLen;

    //
    // Guess at where the packet is located
    //
    PUCHAR PacketLoc;

    //
    // Header Validation Variables
    //
    BOOLEAN FrameAlign;
    PUCHAR PacketRcvStatus;
    PUCHAR NextPacket;
    PUCHAR PacketLenLo;
    PUCHAR PacketLenHi;
    PUCHAR ReceiveDestAddrLo;
    UINT FrameAlignCount;
    UCHAR OldPacketLenHi;
    UCHAR TempPacketHeader[6];
    PUCHAR BeginPacketHeader;

    //
    // First copy up the four-byte header the card attaches
    // plus first two bytes of the data packet (which contain
    // the destination address of the packet).  We use the extra
    // two bytes in case the packet was shifted right 1 or 2 bytes
    //
    PacketLoc = Adapter->PageStart +
        256*(Adapter->NicNextPacket-Adapter->NicPageStart);

    if (!CardCopyUp(Adapter, TempPacketHeader, PacketLoc, 6)) {

        return FALSE;

    }
    PacketLoc += 4;

    //
    // Validate the header
    //
    FrameAlignCount = 0;
    BeginPacketHeader = TempPacketHeader;

    //
    // Sometimes the Ne2000 will misplace a packet and shift the
    // entire packet and header by a byte, either up by 1 or 2 bytes.
    // This loop will look for the packet in the expected place,
    // and then shift up in an effort to find the packet.
    //
    do {

        //
        // Set where we think the packet is
        //
        PacketRcvStatus = BeginPacketHeader;
        NextPacket = BeginPacketHeader + 1;
        PacketLenLo = BeginPacketHeader + 2;
        PacketLenHi = BeginPacketHeader + 3;
        OldPacketLenHi = *PacketLenHi;
        ReceiveDestAddrLo = BeginPacketHeader + 4;
        FrameAlign = FALSE;

        //
        // Check if the status makes sense as is.
        //
        if (*PacketRcvStatus & 0x05E){

            FrameAlign = TRUE;

        } else if ((*PacketRcvStatus & RSR_MULTICAST)   // If a multicast packet
                     && (!FrameAlignCount)              // and hasn't been aligned
                     && !(*ReceiveDestAddrLo & 1)       // and lsb is set on dest addr
                  ){

            FrameAlign = TRUE;

        } else {

            //
            // Compare high and low address bytes.  If the same, the low
            // byte may have been copied into the high byte.
            //

            if (*PacketLenLo == *PacketLenHi){

                //
                // Save the old packetlenhi
                //
                OldPacketLenHi = *PacketLenHi;

                //
                // Compute new packet length
                //
                *PacketLenHi = *NextPacket - Adapter->NicNextPacket - 1;

                if (*PacketLenHi < 0) {

                    *PacketLenHi = (Adapter->NicPageStop - Adapter->NicNextPacket) +
                        (*NextPacket - Adapter->NicPageStart) - 1;

                }

                if (*PacketLenLo > 0xFC) {

                    (*PacketLenHi)++;
                }

            }

            PacketLen = (*PacketLenLo) + ((*PacketLenHi)*256) - 4;

            //
            // Does it make sense?
            //
            if ((PacketLen > 1514) || (PacketLen < 60)){

                //
                // Bad length.  Restore the old packetlenhi
                //
                *PacketLenHi = OldPacketLenHi;

                FrameAlign = TRUE;

            }

            //
            // Did we recover the frame?
            //
            if (!FrameAlign && ((*NextPacket < Adapter->NicPageStart) ||
                (*NextPacket > Adapter->NicPageStop))) {

                IF_LOUD( DbgPrint ("Packet address invalid in HeaderValidation\n"); )

                FrameAlign = TRUE;

            }

        }

        //
        // FrameAlignment - if first time through, shift packetheader right 1 or 2 bytes.
        // If second time through, shift it back to where it was and let it through.
        // This compensates for a known bug in the 8390D chip.
        //
        if (FrameAlign){

            switch (FrameAlignCount){

            case 0:

                BeginPacketHeader++;
                PacketLoc++;
                if (!Adapter->EightBitSlot){

                    BeginPacketHeader++;
                    PacketLoc++;

                }
                break;

            case 1:

                BeginPacketHeader--;
                PacketLoc--;
                if (!Adapter->EightBitSlot){
                    BeginPacketHeader--;
                    PacketLoc--;
                }
                break;

            }

            FrameAlignCount++;

        }

    } while ( (FrameAlignCount < 2) && FrameAlign );

    //
    // Now grab the packet header information
    //
    Adapter->PacketHeader[0] = *BeginPacketHeader;
    BeginPacketHeader++;
    Adapter->PacketHeader[1] = *BeginPacketHeader;
    BeginPacketHeader++;
    Adapter->PacketHeader[2] = *BeginPacketHeader;
    BeginPacketHeader++;
    Adapter->PacketHeader[3] = *BeginPacketHeader;

    //
    // Packet length is in bytes 3 and 4 of the header.
    //
    Adapter->PacketHeaderLoc = PacketLoc;
    PacketLen = (Adapter->PacketHeader[2]) + ((Adapter->PacketHeader[3])*256) - 4;

    //
    // Sanity check the packet
    //
    if ((PacketLen > 1514) || (PacketLen < 60)){

        if ((Adapter->PacketHeader[1] < Adapter->NicPageStart) ||
            (Adapter->PacketHeader[1] > Adapter->NicPageStop)) {

            //
            // Return TRUE here since IndicatePacket will notice the error
            // and handle it correctly.
            //
            return(TRUE);

        }

        return(FALSE);

    }

    return(TRUE);
}


INDICATE_STATUS
Ne2000IndicatePacket(
    IN PNE2000_ADAPTER Adapter
    )

/*++

Routine Description:

    Indicates the first packet on the card to the protocols.

    NOTE: For MP, non-x86 architectures, this assumes that the packet has been
    read from the card and into Adapter->PacketHeader and Adapter->Lookahead.

    NOTE: For UP x86 systems this assumes that the packet header has been
    read into Adapter->PacketHeader and the minimal lookahead stored in
    Adapter->Lookahead

Arguments:

    Adapter - pointer to the adapter block.

Return Value:

    CARD_BAD if the card should be reset;
    INDICATE_OK otherwise.

--*/

{
    //
    // Length of the packet
    //
    UINT PacketLen;

    //
    // Length of the lookahead buffer
    //
    UINT IndicateLen;

    //
    // Variables for checking if the packet header looks valid
    //
    UCHAR PossibleNextPacket1, PossibleNextPacket2;

    //
    // Check if the next packet byte agress with the length, as
    // described on p. A-3 of the Etherlink II Technical Reference.
    // The start of the packet plus the MSB of the length must
    // be equal to the start of the next packet minus one or two.
    // Otherwise the header is considered corrupted, and the
    // card must be reset.
    //

    PossibleNextPacket1 =
                Adapter->NicNextPacket + Adapter->PacketHeader[3] + (UCHAR)1;

    if (PossibleNextPacket1 >= Adapter->NicPageStop) {

        PossibleNextPacket1 -= (Adapter->NicPageStop - Adapter->NicPageStart);

    }

    if (PossibleNextPacket1 != Adapter->PacketHeader[1]) {

        PossibleNextPacket2 = PossibleNextPacket1+(UCHAR)1;

        if (PossibleNextPacket2 == Adapter->NicPageStop) {

            PossibleNextPacket2 = Adapter->NicPageStart;

        }

        if (PossibleNextPacket2 != Adapter->PacketHeader[1]) {

            IF_LOUD( DbgPrint("First CARD_BAD check failed\n"); )
            return SKIPPED;
        }

    }

    //
    // Check that the Next is valid
    //
    if ((Adapter->PacketHeader[1] < Adapter->NicPageStart) ||
        (Adapter->PacketHeader[1] > Adapter->NicPageStop)) {

        IF_LOUD( DbgPrint("Second CARD_BAD check failed\n"); )
        return(SKIPPED);

    }

    //
    // Sanity check the length
    //
    PacketLen = Adapter->PacketHeader[2] + Adapter->PacketHeader[3]*256 - 4;

    if (PacketLen > 1514) {
        IF_LOUD( DbgPrint("Third CARD_BAD check failed\n"); )
        return(SKIPPED);

    }

#if DBG

    IF_NE2000DEBUG( NE2000_DEBUG_WORKAROUND1 ) {
        //
        // Now check for the high order 2 bits being set, as described
        // on page A-2 of the Etherlink II Technical Reference. If either
        // of the two high order bits is set in the receive status byte
        // in the packet header, the packet should be skipped (but
        // the adapter does not need to be reset).
        //

        if (Adapter->PacketHeader[0] & (RSR_DISABLED|RSR_DEFERRING)) {

            IF_LOUD (DbgPrint("H");)

            return SKIPPED;

        }

    }

#endif

    //
    // Lookahead amount to indicate
    //
    IndicateLen = (PacketLen > (Adapter->MaxLookAhead + NE2000_HEADER_SIZE)) ?
                           (Adapter->MaxLookAhead + NE2000_HEADER_SIZE) :
                           PacketLen;

    //
    // Indicate packet
    //

    Adapter->PacketLen = PacketLen;

    if (IndicateLen < NE2000_HEADER_SIZE) {

        //
        // Runt Packet
        //

        NdisMEthIndicateReceive(
                Adapter->MiniportAdapterHandle,
                (NDIS_HANDLE)Adapter,
                (PCHAR)(Adapter->Lookahead),
                IndicateLen,
                NULL,
                0,
                0
                );

    } else {

        NdisMEthIndicateReceive(
                Adapter->MiniportAdapterHandle,
                (NDIS_HANDLE)Adapter,
                (PCHAR)(Adapter->Lookahead),
                NE2000_HEADER_SIZE,
                (PCHAR)(Adapter->Lookahead) + NE2000_HEADER_SIZE,
                IndicateLen - NE2000_HEADER_SIZE,
                PacketLen - NE2000_HEADER_SIZE
                );

    }

    Adapter->IndicateReceiveDone = TRUE;

    return INDICATE_OK;
}


NDIS_STATUS
Ne2000TransferData(
    OUT PNDIS_PACKET Packet,
    OUT PUINT BytesTransferred,
    IN NDIS_HANDLE MiniportAdapterContext,
    IN NDIS_HANDLE MiniportReceiveContext,
    IN UINT ByteOffset,
    IN UINT BytesToTransfer
    )

/*++

Routine Description:

    A protocol calls the Ne2000TransferData request (indirectly via
    NdisTransferData) from within its Receive event handler
    to instruct the driver to copy the contents of the received packet
    a specified packet buffer.

Arguments:

    MiniportAdapterContext - Context registered with the wrapper, really
        a pointer to the adapter.

    MiniportReceiveContext - The context value passed by the driver on its call
    to NdisMEthIndicateReceive.  The driver can use this value to determine
    which packet, on which adapter, is being received.

    ByteOffset - An unsigned integer specifying the offset within the
    received packet at which the copy is to begin.  If the entire packet
    is to be copied, ByteOffset must be zero.

    BytesToTransfer - An unsigned integer specifying the number of bytes
    to copy.  It is legal to transfer zero bytes; this has no effect.  If
    the sum of ByteOffset and BytesToTransfer is greater than the size
    of the received packet, then the remainder of the packet (starting from
    ByteOffset) is transferred, and the trailing portion of the receive
    buffer is not modified.

    Packet - A pointer to a descriptor for the packet storage into which
    the MAC is to copy the received packet.

    BytesTransfered - A pointer to an unsigned integer.  The MAC writes
    the actual number of bytes transferred into this location.  This value
    is not valid if the return status is STATUS_PENDING.

Notes:

  - The MacReceiveContext will be a pointer to the open block for
    the packet.

--*/

{
    //
    // Variables for the number of bytes to copy, how much can be
    // copied at this moment, and the total number of bytes to copy.
    //
    UINT BytesLeft, BytesNow, BytesWanted;

    //
    // Current NDIS_BUFFER to copy into
    //
    PNDIS_BUFFER CurBuffer;

    //
    // Virtual address of the buffer.
    //
    XMIT_BUF NextBufToXmit;
    PUCHAR BufStart;

    //
    // Length and offset into the buffer.
    //
    UINT BufLen, BufOff;

    //
    // The adapter to transfer from.
    //
    PNE2000_ADAPTER Adapter = ((PNE2000_ADAPTER)MiniportReceiveContext);

    IF_LOG( Ne2000Log('t');)

    //
    // Add the packet header onto the offset.
    //
    ByteOffset += NE2000_HEADER_SIZE;

    //
    // See how much data there is to transfer.
    //
    if (ByteOffset+BytesToTransfer > Adapter->PacketLen) {

        if (Adapter->PacketLen < ByteOffset) {

            *BytesTransferred = 0;
            IF_LOG( Ne2000Log('T');)
            return(NDIS_STATUS_FAILURE);
        }

        BytesWanted = Adapter->PacketLen - ByteOffset;

    } else {

        BytesWanted = BytesToTransfer;

    }

    //
    // Set the number of bytes left to transfer
    //
    BytesLeft = BytesWanted;

    {

        //
        // Address on the adapter to copy from
        //
        PUCHAR CurCardLoc;

        //
        // Copy data from the card -- it is not completely stored in the
        // adapter structure.
        //
        // Determine where the copying should start.
        //
        CurCardLoc = Adapter->PacketHeaderLoc + ByteOffset;

        if (CurCardLoc > Adapter->PageStop) {

            CurCardLoc = CurCardLoc - (Adapter->PageStop - Adapter->PageStart);

        }

        //
        // Get location to copy into
        //
        NdisQueryPacket(Packet, NULL, NULL, &CurBuffer, NULL);

        NdisQueryBuffer(CurBuffer, (PVOID *)&BufStart, &BufLen);

        BufOff = 0;

        //
        // Loop, filling each buffer in the packet until there
        // are no more buffers or the data has all been copied.
        //
        while (BytesLeft > 0) {

            //
            // See how much data to read into this buffer.
            //

            if ((BufLen-BufOff) > BytesLeft) {

                BytesNow = BytesLeft;

            } else {

                BytesNow = (BufLen - BufOff);

            }

            //
            // See if the data for this buffer wraps around the end
            // of the receive buffers (if so filling this buffer
            // will use two iterations of the loop).
            //

            if (CurCardLoc + BytesNow > Adapter->PageStop) {

                BytesNow = (UINT)(Adapter->PageStop - CurCardLoc);

            }

            //
            // Copy up the data.
            //

            if (!CardCopyUp(Adapter, BufStart+BufOff, CurCardLoc, BytesNow)) {

                *BytesTransferred = BytesWanted - BytesLeft;

                NdisWriteErrorLogEntry(
                    Adapter->MiniportAdapterHandle,
                    NDIS_ERROR_CODE_HARDWARE_FAILURE,
                    1,
                    0x2
                    );

                return(NDIS_STATUS_FAILURE);

            }

            //
            // Update offsets and counts
            //
            CurCardLoc += BytesNow;
            BytesLeft -= BytesNow;

            //
            // Is the transfer done now?
            //
            if (BytesLeft == 0) {

                break;

            }

            //
            // Wrap around the end of the receive buffers?
            //
            if (CurCardLoc == Adapter->PageStop) {

                CurCardLoc = Adapter->PageStart;

            }

            //
            // Was the end of this packet buffer reached?
            //
            BufOff += BytesNow;

            if (BufOff == BufLen) {

                NdisGetNextBuffer(CurBuffer, &CurBuffer);

                if (CurBuffer == (PNDIS_BUFFER)NULL) {

                    break;

                }

                NdisQueryBuffer(CurBuffer, (PVOID *)&BufStart, &BufLen);

                BufOff = 0;

            }

        }

        *BytesTransferred = BytesWanted - BytesLeft;

        //
        // Did a transmit complete while we were doing what we were doing?
        //
        if (!Adapter->BufferOverflow && Adapter->CurBufXmitting != -1) {

            ULONG Len;
            UINT i;
            UCHAR Status;
            PNDIS_PACKET tmpPacket;
            NDIS_STATUS NdisStatus;

            //
            // Check if it completed
            //
            CardGetInterruptStatus(Adapter, &Status);

            if (Status & ISR_XMIT_ERR) {
                OctogmetusceratorRevisited(Adapter);
                Adapter->InterruptStatus &= ~ISR_XMIT_ERR;
                NdisRawWritePortUchar(Adapter->IoPAddr+NIC_INTR_STATUS, (ISR_XMIT_ERR));
                Status &= ~ISR_XMIT_ERR;

            }

            if (Status & (ISR_XMIT)) {


                IF_LOG( Ne2000Log('*'); )


                //
                // Update NextBufToXmit
                //
                Len = (Adapter->PacketLens[Adapter->CurBufXmitting] + 255) >> 8;
                NextBufToXmit = Adapter->NextBufToXmit + Len;

//                Adapter->NextBufToXmit += Len;

                if (NextBufToXmit == MAX_XMIT_BUFS) {
                    NextBufToXmit = 0;
                }

                if (Adapter->BufferStatus[NextBufToXmit] == EMPTY &&
                    Adapter->NextBufToFill != NextBufToXmit) {
                    NextBufToXmit = 0;
                }


                //
                // If the next packet is ready to go, start it.
                //
                if (Adapter->BufferStatus[NextBufToXmit] == FULL) {

                    //
                    // Ack the transmit
                    //

                    //
                    // Remove the packet from the packet list.
                    //
                    Adapter->NextBufToXmit = NextBufToXmit;
                    tmpPacket = Adapter->Packets[Adapter->CurBufXmitting];
                    Adapter->Packets[Adapter->CurBufXmitting] = (PNDIS_PACKET)NULL;
                    SyncCardGetXmitStatus((PVOID)Adapter);


                    //
                    // Statistics
                    //
                    if (Adapter->XmitStatus & TSR_XMIT_OK) {

                        Adapter->FramesXmitGood++;
                        NdisStatus = NDIS_STATUS_SUCCESS;

                    } else {

                        Adapter->FramesXmitBad++;
                        NdisStatus = NDIS_STATUS_FAILURE;

                    }

                    for (i = Adapter->CurBufXmitting; i < Adapter->CurBufXmitting + Len; i++) {
                        Adapter->BufferStatus[i] = EMPTY;
                    }
                    Adapter->TransmitInterruptPending = FALSE;
                    NdisRawWritePortUchar(Adapter->IoPAddr+NIC_INTR_STATUS, (ISR_XMIT));
                    Adapter->CurBufXmitting = Adapter->NextBufToXmit;
                    Adapter->TransmitInterruptPending = TRUE;

                    IF_LOG( Ne2000Log('8'); )
                    Adapter->InterruptStatus &= ~(ISR_XMIT);
                    CardStartXmit(Adapter);

                } else {
                    NdisRawWritePortUchar(Adapter->IoPAddr+NIC_INTR_STATUS, (ISR_XMIT));
                    Adapter->InterruptStatus |= (Status);

                }

            }

        }

        return(NDIS_STATUS_SUCCESS);

    }

}


NDIS_STATUS
Ne2000Send(
    IN NDIS_HANDLE MiniportAdapterContext,
    IN PNDIS_PACKET Packet,
    IN UINT Flags
    )

/*++

Routine Description:


    The Ne2000Send request instructs a driver to transmit a packet through
    the adapter onto the medium.

Arguments:

    MiniportAdapterContext - Context registered with the wrapper, really
        a pointer to the adapter.

    Packet - A pointer to a descriptor for the packet that is to be
    transmitted.

    SendFlags - Optional send flags

Notes:

    This miniport driver will always accept a send.  This is because
    the Ne2000 has limited send resources and the driver needs packets
    to copy to the adapter immediately after a transmit completes in
    order to keep the adapter as busy as possible.

    This is not required for other adapters, as they have enough
    resources to keep the transmitter busy until the wrapper submits
    the next packet.

--*/

{
    PNE2000_ADAPTER Adapter = (PNE2000_ADAPTER)(MiniportAdapterContext);

    //
    // Put the packet on the send queue.
    //
    if (Adapter->FirstPacket == NULL) {
        Adapter->FirstPacket = Packet;
    } else {
        RESERVED(Adapter->LastPacket)->Next = Packet;
    }

    RESERVED(Packet)->Next = NULL;

    Adapter->LastPacket = Packet;

    //
    // Process the next send
    //
    Ne2000DoNextSend(Adapter);
    return(NDIS_STATUS_PENDING);

}

VOID
Ne2000DoNextSend(
    PNE2000_ADAPTER Adapter
    )

/*++

Routine Description:

    This routine examines if the packet at the head of the packet
    list can be copied to the adapter, and does so.

Arguments:

    Adapter - Pointer to the adapter block.

Return Value:

    None

--*/

{
    //
    // The packet to process.
    //
    PNDIS_PACKET Packet;

    //
    // The current destination transmit buffer.
    //
    XMIT_BUF TmpBuf1;

    //
    // Length of the packet
    //
    ULONG Len;

    //
    // Temporary looping variable
    //
    ULONG i;

    IF_LOG( Ne2000Log('s'); )

    //
    // Check if we have enough resources and a packet to process
    //
    while((Adapter->FirstPacket != NULL) &&
          (Adapter->BufferStatus[Adapter->NextBufToFill] == EMPTY)) {

        //
        // Get the length of the packet.
        //
        NdisQueryPacket(
            Adapter->FirstPacket,
            NULL,
            NULL,
            NULL,
            &Len
            );

        //
        // Convert length to the number of transmit buffers needed.
        //
        Len = (Len + 255) >> 8;

        //
        // If not transmitting
        //
        if (Adapter->CurBufXmitting == -1) {

            //
            // Then check from the next free buffer if the packet will
            // fit.
            //
            if (Adapter->BufferStatus[Adapter->NextBufToXmit] == EMPTY) {

                //
                // It won't fit at the end, so put it at the first buffer
                //
                if (Adapter->NextBufToFill + Len > MAX_XMIT_BUFS) {

                    Adapter->NextBufToFill = 0;

                }

            } else {

                //
                // Check if this packet will fit before the packet on the
                // adapter.
                //
                if (Adapter->NextBufToXmit > Adapter->NextBufToFill) {

                    if (Adapter->NextBufToFill + Len > Adapter->NextBufToXmit) {

                        IF_LOG( Ne2000Log('^'); )
                        IF_LOG( Ne2000Log('S'); )

                        break;

                    }

                } else {

                    //
                    // Check if it will fit after the packet already on the
                    // adapter.
                    //
                    if (Adapter->NextBufToFill + Len > MAX_XMIT_BUFS) {

                        Adapter->NextBufToFill = 0;

                        if (Adapter->NextBufToFill + Len > Adapter->NextBufToXmit){

                            IF_LOG( Ne2000Log('%'); )
                            IF_LOG( Ne2000Log('S'); )

                            break;

                        }

                    }

                }

            }

        } else {

            //
            // Check if the packet will fit before the packet currently
            // transmitting
            //

            if (Adapter->CurBufXmitting > Adapter->NextBufToFill) {

                if (Adapter->NextBufToFill + Len > Adapter->CurBufXmitting) {

                    IF_LOG( Ne2000Log('$'); )
                    IF_LOG( Ne2000Log('S'); )

                    break;
                }

            } else {

                //
                // Check if it will fit after the packet currently transmitting
                //
                if (Adapter->NextBufToFill + Len > MAX_XMIT_BUFS) {

                    Adapter->NextBufToFill = 0;

                    if (Adapter->NextBufToFill + Len > Adapter->CurBufXmitting){

                        IF_LOG( Ne2000Log('!'); )
                        IF_LOG( Ne2000Log('S'); )
                        break;

                    }

                }

            }

        }

        //
        // Set starting location
        //
        TmpBuf1 = Adapter->NextBufToFill;

        //
        // Remove the packet from the queue.
        //
        Packet = Adapter->FirstPacket;
        Adapter->FirstPacket = RESERVED(Packet)->Next;

        if (Packet == Adapter->LastPacket) {
            Adapter->LastPacket = NULL;
        }

        //
        // Store the packet in the list
        //
        Adapter->Packets[TmpBuf1] = Packet;

        //
        // Copy down the packet.
        //
        if (CardCopyDownPacket(Adapter, Packet,
                        &Adapter->PacketLens[TmpBuf1]) == FALSE) {

            for (i = TmpBuf1; i < TmpBuf1 + Len; i++) {
                Adapter->BufferStatus[i] = EMPTY;
            }
            Adapter->Packets[TmpBuf1] = NULL;
            IF_LOG( Ne2000Log('F'); )
            IF_LOG( Ne2000Log('S'); )

            NdisMSendComplete(
                Adapter->MiniportAdapterHandle,
                Packet,
                NDIS_STATUS_FAILURE
                );

            continue;

        }

        //
        // Pad short packets with blanks.
        //
        if (Adapter->PacketLens[TmpBuf1] < 60) {

            (VOID)CardCopyDown(
                    Adapter,
                    ((PUCHAR)Adapter->XmitStart +
                    TmpBuf1*TX_BUF_SIZE +
                    Adapter->PacketLens[TmpBuf1]),
                    BlankBuffer,
                    60-Adapter->PacketLens[TmpBuf1]
                    );

        }

        //
        // Set the buffer status
        //
        for (i = TmpBuf1; i < (TmpBuf1 + Len); i++) {
                Adapter->BufferStatus[i] = FULL;
        }

        //
        // Update next free buffer
        //
        Adapter->NextBufToFill += Len;

        if (Adapter->NextBufToFill == MAX_XMIT_BUFS) {
            Adapter->NextBufToFill = 0;
        }

        //
        // See whether to start the transmission.
        //
        if (Adapter->CurBufXmitting == -1) {

            //
            // OK to start transmission.
            //
            if (Adapter->BufferStatus[Adapter->NextBufToXmit] == EMPTY &&
                Adapter->NextBufToFill != Adapter->NextBufToXmit) {

                Adapter->NextBufToXmit = 0;

            }

            Adapter->CurBufXmitting = Adapter->NextBufToXmit;


            IF_LOG( Ne2000Log('4');)

            //
            // If we are currently handling an overflow, then we need to let
            // the overflow handler send this packet...
            //

            if (Adapter->BufferOverflow) {

                Adapter->OverflowRestartXmitDpc = TRUE;

                IF_LOG( Ne2000Log('O');)
                IF_LOUD( DbgPrint ("Adapter->OverflowRestartXmitDpc set:copy and send");)

            } else {

                //
                // This is used to check if stopping the chip prevented
                // a transmit complete interrupt from coming through (it
                // is cleared in the ISR if a transmit DPC is queued).
                //

                Adapter->TransmitInterruptPending = TRUE;

                IF_LOG( Ne2000Log('9'); )
                CardStartXmit(Adapter);

            }

        }

        //
        // Ack the send immediately.  If for some reason it
        // should fail, the protocol should be able to handle
        // the retransmit.
        //

        IF_LOG( Ne2000Log('S'); )

        NdisMSendComplete(
                Adapter->MiniportAdapterHandle,
                Packet,
                NDIS_STATUS_SUCCESS
                );
    }

}

VOID
OctogmetusceratorRevisited(
    IN PNE2000_ADAPTER Adapter
    )

/*++

Routine Description:

    Recovers the card from a transmit error.

Arguments:

    Adapter - pointer to the adapter block

Return Value:

    None.

--*/

{

    IF_LOUD( DbgPrint("Octogmetuscerator called!"); )

    IF_LOG( Ne2000Log('y'); )

    //
    // Ack the interrupt, if needed
    //
    NdisRawWritePortUchar(Adapter->IoPAddr+NIC_INTR_STATUS, ISR_XMIT_ERR);

    //
    // Stop the card
    //
    SyncCardStop(Adapter);

    //
    // Wait up to 1.6 milliseconds for any receives to finish
    //
    NdisStallExecution(2000);

    //
    // Place the card in Loopback
    //
    NdisRawWritePortUchar(Adapter->IoPAddr+NIC_XMIT_CONFIG, TCR_LOOPBACK);

    //
    // Start the card in Loopback
    //
    NdisRawWritePortUchar(Adapter->IoPAddr+NIC_COMMAND, CR_START | CR_NO_DMA);

    //
    // Get out of loopback and start the card
    //
    CardStart(Adapter);

    //
    // If there was a packet waiting to get sent, send it.
    //
    if (Adapter->CurBufXmitting != -1) {

        Adapter->TransmitInterruptPending = TRUE;
        CardStartXmit(Adapter);

    }
    IF_LOG( Ne2000Log('Y'); )
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\net\ms\e100bex\testwmi\wmicode.cpp ===
#include "testwmi.h"

//
// The function connects to the namespace.
//

IWbemServices *ConnectToNamespace (VOID)
{
  IWbemServices *pIWbemServices = NULL;
  IWbemLocator *pIWbemLocator = NULL;
  HRESULT      hr;


  //
  // Create an instance of WbemLocator interface.
  //

  hr = CoCreateInstance( CLSID_WbemLocator,
                         NULL,
                         CLSCTX_INPROC_SERVER,
                         IID_IWbemLocator,
                         (LPVOID *)&pIWbemLocator );
  if ( hr == S_OK ) {

     //
     // Using the locator, connect to COM in the given namespace.
     //

     hr = pIWbemLocator->ConnectServer( (BSTR)((PVOID)DEFAULT_NAMESPACE),
                                        NULL,   // current account.
                                        NULL,   // current password.
                                        0L,     // locale
                                        0L,     // securityFlags
                                        NULL,   // domain for NTLM
                                        NULL,   // context
                                        &pIWbemServices );

     if ( hr == WBEM_S_NO_ERROR) {
         
        //
        // Switch the security level to IMPERSONATE so that provider(s)
        // will grant access to system-level objects, and so that
        // CALL authorization will be used.
        //

        hr = CoSetProxyBlanket( (IUnknown *)pIWbemServices, // proxy
                                RPC_C_AUTHN_WINNT,  // authentication service
                                RPC_C_AUTHZ_NONE,   // authorization service
                                NULL,               // server principle name
                                RPC_C_AUTHN_LEVEL_CALL, // authentication level
                                RPC_C_IMP_LEVEL_IMPERSONATE, // impersonation
                                NULL,            // identity of the client
                                EOAC_NONE );  // capability flags

        if ( hr != S_OK ) {

           pIWbemServices->Release();
           pIWbemServices  = NULL;

           PrintError( hr,
                     __LINE__,
                     TEXT(__FILE__),
                     TEXT("Couldn't impersonate, program exiting...") );
        }
     }
     else {
        PrintError( hr,
                  __LINE__,
                  TEXT(__FILE__),
                  TEXT("Couldn't connect to root\\wmi, program exiting...") );
     }

     //
     // Done with IWbemLocator.
     //

     pIWbemLocator->Release();
  }
  else {
     PrintError( hr,
               __LINE__,
               TEXT(__FILE__),
               TEXT("Couldn't create an instance of ")
               TEXT("IWbemLocator interface, programm exiting...") );
  }

  return pIWbemServices;
}

//
// Given a class name, the function populates the combo box with all
// the instances of the class.
//

VOID EnumInstances (IWbemServices *pIWbemServices,
                    LPTSTR        lpszClass,
                    HWND          hwndInstTree)
{
  IEnumWbemClassObject *pEnumInst;
  IWbemClassObject     *pInst;
  VARIANT              varInstanceName;
  BSTR                 bstrClass;
  LPTSTR               lpszInstance;
  ULONG                ulFound;
  HRESULT              hr;


  bstrClass = StringToBstr( lpszClass,
                            -1 );
  if ( !bstrClass ) {

     PrintError( HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY),
               __LINE__,
               TEXT(__FILE__),
               TEXT("Not enough memory to enumerate instances of %s"),
                    lpszClass );

     return;
  }

  hr = pIWbemServices->CreateInstanceEnum(
                  bstrClass,              // Name of the root class.
                  WBEM_FLAG_SHALLOW |     // Enumerate at current root only.
                  WBEM_FLAG_FORWARD_ONLY, // Forward-only enumeration.
                  NULL,                   // Context.
                  &pEnumInst );          // pointer to class enumerator

  if ( hr == WBEM_S_NO_ERROR ) {

     //
     // Begin enumerating instances.
     //

     ulFound = 0;

     hr = pEnumInst->Next( 2000,      // two seconds timeout
                           1,         // return just one instance.
                           &pInst,    // pointer to instance.
                           &ulFound); // Number of instances returned.
     
     while ( (hr == WBEM_S_NO_ERROR) && (ulFound == 1) ) {

        VariantInit( &varInstanceName );

        //
        // Get the instance name stored in __RELPATH property.
        //

        hr = pInst->Get( L"__RELPATH", // property name 
                         0L,                // Reserved, must be zero.
                         &varInstanceName,  // property value returned.
                         NULL,              // CIM type not needed.
                         NULL );            // Flavor not needed.

        if ( hr == WBEM_S_NO_ERROR ) {

           lpszInstance = BstrToString( V_BSTR(&varInstanceName),
                                        -1 );
           if ( lpszInstance ) {

              InsertItem( hwndInstTree,
                          lpszInstance );

               SysFreeString( (BSTR)((PVOID)lpszInstance) );
           }
           else {
              hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);

              PrintError( hr,
                          __LINE__,
                          TEXT(__FILE__),
                          TEXT("Out of memory while enumerating instaces of")
                          TEXT(" %s, no more instances will")
                          TEXT(" be listed."),
                          lpszClass );
           }

           VariantClear( &varInstanceName );
        }
        else {
           PrintError( hr,
                     __LINE__,
                     TEXT(__FILE__),
                     TEXT("Couldn't retrieve __RELPATH of an instance")
                     TEXT(" of %s, no more instances will be listed."),
                     lpszClass );
        }

        //
        // Done with this instance.
        //

        pInst->Release();

        if ( hr == WBEM_S_NO_ERROR ) {

           hr = pEnumInst->Next( 2000,       // two seconds timeout.
                                 1,          // return just one class.
                                 &pInst,     // pointer to returned class.
                                 &ulFound);  // Number of classes returned.
        }
     }
 
     pEnumInst->Release();

  }
  else {
     PrintError( hr,
               __LINE__,
               TEXT(__FILE__),
               TEXT("Couldn't create an instance of ")
               TEXT("IEnumWbemClassObject interface, instances of %s ")
               TEXT("will not be listed."),
               lpszClass );
  }

  SysFreeString( bstrClass );

  return;
}

//
// Given a class name and __RELPATH of an instance, the function lists all the
// local non-system properties in a tree list.
//

VOID EnumProperties (IWbemServices *pIWbemServices,
                     LPTSTR        lpszClass,
                     LPTSTR        lpszInstance,
                     HWND          hwndPropTree)
{
  IWbemClassObject  *pInst;
  SAFEARRAY         *psaPropNames;
  BSTR              bstrProperty;
  long              lLower;
  long              lUpper;
  long              i;
  HRESULT           hr;
  LPTSTR            lpszProperty;

  //
  // Get a pointer to the instance.
  //

  pInst = GetInstanceReference( pIWbemServices,
                                lpszClass,
                                lpszInstance );

  if ( pInst ) {

     //
     // psaPropNames must be null prior to making the call.
     //

     psaPropNames = NULL;

     //
     // Get all the properties.
     //

     hr = pInst->GetNames( NULL,              // No qualifier names.
                           WBEM_FLAG_ALWAYS | // All non-system properties
                           WBEM_FLAG_LOCAL_ONLY, 
                           NULL,             // No qualifier values.
                           &psaPropNames);   // Returned property names

     if ( hr == WBEM_S_NO_ERROR ) {

        //
        // Get the number of properties returned.
        //

        SafeArrayGetLBound( psaPropNames, 1, &lLower );
        SafeArrayGetUBound( psaPropNames, 1, &lUpper );

        //
        // List all properties or stop when encountered an error.
        //

        for (i=lLower; (hr == WBEM_S_NO_ERROR) && (i <= lUpper); i++) {

           //
           // Add the property name into the list box.
           //

           bstrProperty = NULL;

           hr = SafeArrayGetElement( psaPropNames,
                                     &i,
                                     &bstrProperty);

           if ( SUCCEEDED(hr) ) {

               lpszProperty = BstrToString( bstrProperty,
                                          -1 );

               if ( lpszProperty ) {

                  InsertItem( hwndPropTree,
                              lpszProperty );

                  SysFreeString( (BSTR)((PVOID)lpszProperty) );
               }
               else {
                  PrintError( HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY),
                            __LINE__,
                            TEXT(__FILE__),
                            TEXT("Out of memory while enumerating")
                            TEXT(" properties of %s, no more properties")
                            TEXT(" will be listed"),
                            lpszInstance );
               }

              //
              // Done with the property name.
              //

              SysFreeString( bstrProperty );
           }
           else {
              PrintError( hr,
                          __LINE__,
                          TEXT(__FILE__),
                          TEXT("Couldn't get the name of a property(%d). ")
                          TEXT("No more properties will be listed."),
                          i );
           }
        }

        //
        // Done with the array of properties.
        //

        SafeArrayDestroy( psaPropNames );
     }
     else {
        PrintError( hr,
                    __LINE__,
                    TEXT(__FILE__),
                    TEXT("Couldn't retrieve the properties of %s, ")
                    TEXT("an instance of class %s. Properties will not be ")
                    TEXT("listed."),
                    lpszInstance, lpszClass );
     }

  }
  else {
     PrintError( HRESULT_FROM_WIN32(ERROR_WMI_INSTANCE_NOT_FOUND),
                 __LINE__,
                 TEXT(__FILE__),
                 TEXT("Couldn't retrieve a pointer to instance %s of class %s.")
                 TEXT("Its properties will not be listed."),
                 lpszInstance, lpszClass );
  }

  return;
}

//
// Given a class name and __RELPATH of an instance, the function returns a
// pointer to the instance.
//

IWbemClassObject *GetInstanceReference (IWbemServices *pIWbemServices,
                                        LPTSTR        lpszClass,
                                        LPTSTR        lpszInstance)
{
  IWbemClassObject     *pInst;
  IEnumWbemClassObject *pEnumInst;
  ULONG                ulCount;
  BSTR                 bstrClass;
  BOOL                 bFound;
  HRESULT              hr;
  

  hr = 0;

  bstrClass = StringToBstr( lpszClass,
                            -1 );
  if ( !bstrClass ) {

     PrintError( HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY),
               __LINE__,
               TEXT(__FILE__),
               TEXT("Not enough memory to get a pointer to %s."),
               lpszInstance );

     return NULL;
  }

  //
  // pInst pointer must be NULL initially,
  //

  pInst = NULL;

  // 
  // Get Instance Enumerator Interface.
  //

  pEnumInst = NULL;

  hr = pIWbemServices->CreateInstanceEnum(bstrClass,
                                          WBEM_FLAG_SHALLOW | 
                                          WBEM_FLAG_FORWARD_ONLY,
                                          NULL,         
                                          &pEnumInst );

  if ( hr == WBEM_S_NO_ERROR ) {

     //
     // Get a pointer to the instance.
     //
     // We enumerate all the instances and compare their __RELPATH with
     // the specified __RELPATH. If we find a match then, that is the one
     // we are looking for.
     //
     // The other more efficient way is to create a WQL query and execute
     // it.
     //

     hr = WBEM_S_NO_ERROR;
     bFound = FALSE;

     while ( (hr == WBEM_S_NO_ERROR) && (bFound == FALSE) ) {

        hr = pEnumInst->Next( 2000,      // two seconds timeout
                              1,         // return just one instance.
                              &pInst,    // pointer to instance.
                              &ulCount); // Number of instances returned.

        if ( ulCount > 0 ) {

           bFound = IsInstance( pInst,
                                lpszInstance );

           if ( bFound == FALSE ) {
              pInst->Release();
           }
        }
     }

     if ( bFound == FALSE )
        pInst = NULL;

     //
     // Done with the instance enumerator.
     //

     pEnumInst->Release();
  }

  SysFreeString( bstrClass );
  return pInst;
}

//
// Given a pointer, the function returns TRUE if the pointer points to
// the instance specified by lpszInstance.
//

BOOL IsInstance (IWbemClassObject *pInst,
                 LPTSTR           lpszInstance)
{
  VARIANT              varPropVal;
  LPTSTR               lpInstance;
  BOOL                 bRet;

  bRet = GetPropertyValue( pInst,
                           TEXT("__RELPATH"),
                           &varPropVal,
                           NULL );

  if ( bRet == TRUE ) {

     lpInstance = BstrToString( V_BSTR(&varPropVal),
                                       -1 );
     if ( !lpInstance ) {

        PrintError( HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY),
                  __LINE__,
                  TEXT(__FILE__),
                  TEXT("Not enough memory to search for an instance.") );

        bRet = FALSE;
     }
     else {
        bRet = _tcsicmp( lpszInstance, lpInstance ) == 0;

        SysFreeString( (BSTR)((PVOID)lpInstance) );
     }

     VariantClear( &varPropVal );
  }

  return bRet;
}


//
// The function returns property value and its type of a given class/instance.
//

BOOL GetPropertyValue (IWbemClassObject *pRef,
                       LPTSTR           lpszProperty, 
                       VARIANT          *pvaPropertyValue,
                       LPTSTR           *lppszPropertyType)
{
  IWbemQualifierSet *pQual;
  VARIANT           vaQual;
  BSTR              bstrProperty;
  HRESULT           hr;
  BOOL              bRet;


  //
  // Get the property value.
  //

  bstrProperty = StringToBstr( lpszProperty,
                               -1 );

  if ( !bstrProperty ) {

     return FALSE;

  }

  bRet = FALSE;

  if ( lppszPropertyType ) {

     //
     // Get the textual name of the property type.
     //

     hr = pRef->GetPropertyQualifierSet( bstrProperty,
                                         &pQual );

     if ( hr == WBEM_S_NO_ERROR ) {

        //
        // Get the textual name of the property type.
        //

        hr = pQual->Get( L"CIMTYPE",
                         0,
                         &vaQual,
                         NULL );

        if ( hr == WBEM_S_NO_ERROR ) {
           *lppszPropertyType = BstrToString( V_BSTR(&vaQual),
                                              -1 );

           VariantClear( &vaQual );
        }

        pQual->Release();
     }
  }

  VariantInit( pvaPropertyValue );

  hr = pRef->Get( bstrProperty,
                  0,
                  pvaPropertyValue,
                  NULL,
                  NULL );

  if ( hr == WBEM_S_NO_ERROR ) {
     bRet = TRUE;
  }
  else {
     if ( lppszPropertyType && *lppszPropertyType ) {
        SysFreeString( (BSTR)((PVOID)*lppszPropertyType) );
     }
  }

  SysFreeString( bstrProperty );
  return bRet;
}

//
// Given a pointer to an instance, its property and and variant specifying
// the value for the property, the function updates the property and the
// instance.
//

HRESULT UpdatePropertyValue (IWbemServices *pIWbemServices,
                             IWbemClassObject *pInstance,
                             LPTSTR lpszProperty,
                             LPVARIANT pvaNewValue)
{
  BSTR           bstrProperty;
  HRESULT hr;


  bstrProperty = StringToBstr( lpszProperty,
                               -1 );

  if ( !bstrProperty ) {

     PrintError( HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY),
                 __LINE__,
                 TEXT(__FILE__),
                 TEXT("Not enough memory to update %s."),
                 lpszProperty );

     return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
  }
  
  hr = pInstance->Put( bstrProperty,
                       0,
                       pvaNewValue,
                       0 );

  if ( hr == WBEM_S_NO_ERROR ) {
     hr = pIWbemServices->PutInstance( pInstance,
                                       WBEM_FLAG_UPDATE_ONLY,
                                       NULL,
                                       NULL );

     if ( hr != WBEM_S_NO_ERROR ) {
        PrintError(  hr,
                     __LINE__,
                     TEXT(__FILE__),
                     TEXT("Failed to save the instance,")
                     TEXT(" %s will not be updated."),
                     lpszProperty );
     }
  }
  else {
     PrintError(  hr,
                  __LINE__,
                  TEXT(__FILE__),
                  TEXT("Couldn't update %s."),
                  lpszProperty );
  }

  SysFreeString( bstrProperty );

  return hr;
}

BSTR StringToBstr (LPTSTR lpSrc,
                  int nLenSrc)
{
  BSTR lpDest;

  //
  // In case of ANSI version, we need to change the ANSI string to UNICODE since
  // BSTRs are essentially UNICODE strings.
  //

  #if !defined(UNICODE) || !defined(_UNICODE)

     int  nLenDest;

     nLenDest = MultiByteToWideChar( CP_ACP, 0, lpSrc, nLenSrc, NULL, 0);

     lpDest = SysAllocStringLen( NULL, nLenDest );

     if ( lpDest ) {
        MultiByteToWideChar( CP_ACP, 0, lpSrc, nLenSrc, lpDest, nLenDest );
     }

  //
  // In case of UNICODE version, we simply allocate memory and copy the string.
  //

  #else
     if ( lpSrc == NULL ) {
        nLenSrc = 0;
     }
     else {
        if ( nLenSrc == -1 ) {
           nLenSrc = _tcslen( lpSrc ) + 1;
        }
     }

     lpDest = SysAllocStringLen( lpSrc, nLenSrc );
  #endif

  return lpDest;
}

//
// The function converts a BSTR string into ANSI and returns it in an allocated
// memory. The memory must be freed by the caller using SysFreeString()
// function. If nLenSrc is -1, the string is null terminated.
//

LPTSTR BstrToString (BSTR lpSrc,
                    int nLenSrc)
{
  LPTSTR lpDest;

  //
  // In case of ANSI version, we need to change BSTRs which are UNICODE strings
  // into ANSI version.
  //

  #if !defined(UNICODE) || !defined(_UNICODE)

     int   nLenDest;

     nLenDest = WideCharToMultiByte( CP_ACP, 0, lpSrc, nLenSrc, NULL,
                                     0, NULL, NULL );
     lpDest = (LPTSTR)SysAllocStringLen( NULL, (size_t)nLenDest );

     if ( lpDest ) {
        WideCharToMultiByte( CP_ACP, 0, lpSrc, nLenSrc, lpDest,
                             nLenDest, NULL, NULL );
     }
  //
  // In case of UNICODE version, we simply allocate memory and copy the BSTR
  // into allocate memory and return its address.
  //

  #else
     if ( lpSrc ) {
        if ( nLenSrc == -1 ) {
           nLenSrc = _tcslen( lpSrc ) + 1;
        }
     }
     else {
        nLenSrc = 0;
     }

     lpDest = (LPTSTR)SysAllocStringLen( lpSrc, nLenSrc );
  #endif

  return lpDest;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\net\ms\e100bex\testwmi\testwmi.h ===
#ifndef _TESTWMI_H_INCLUDED

#define _TESTWMI_H_INCLUDED

#define _WIN32_DCOM

#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <tchar.h>
#include <wchar.h>
#include <commctrl.h>        // For common controls, e.g. Tree
#include <objidl.h>
#include <objbase.h>
#include <ole2.h>
#include <wbemcli.h>

//
// Resource editor generated header file.
//

#include "resource.h"

//
// Default namespace.
//

#define DEFAULT_NAMESPACE      L"root\\wmi"

#define ROOT_CLASS             NULL


typedef struct _PROPERTY_INFO {
   IWbemServices    *pIWbemServices;
   IWbemClassObject *pInstance;
   LPTSTR           lpszProperty;
   LPTSTR           lpszType;
   LPVARIANT        pvaValue;
}  PROPERTY_INFO, *LPPROPERTY_INFO;
  
//
// Function defined in testwmi.cpp
//

int APIENTRY WinMain (HINSTANCE hInst,
                      HINSTANCE hPrevInstance, 
                      LPSTR lpCmdLine,         
                      int nCmdShow);

INT_PTR CALLBACK MainDlgProc (HWND hwndDlg,
                              UINT uMsg,
                              WPARAM wParam,
                              LPARAM lParam);

INT_PTR CALLBACK DlgProcScalar (HWND hwndDlg,
                                UINT uMsg,
                                WPARAM wParam,
                                LPARAM lParam);

VOID ListDefaults (HWND hwndDlg);

VOID ShowProperties (HWND hwndDlg,
                     HWND hwndInstTree);

VOID EditProperty (HWND hwndDlg,
                   HWND hwndPropTree);

BOOL ModifyProperty (HWND hwndDlg);

BOOL DisplayArrayProperty (LPTSTR lpszProperty,
                           VARIANT *pvaValue,
                           HWND hwndDlg);

HRESULT AddToList (HWND hwndDlg,
                  VARIANT *pvaValue);

VOID ModifyArrayProperty(HWND hwndDlg,
                         LPPROPERTY_INFO pPropInfo);

VOID RefreshOnClassSelection (HWND hwndDlg);

LPTSTR GetSelectedClass (HWND hwndClassList);

LPTSTR GetSelectedItem (HWND hwndTree);

VOID InsertItem (HWND hwndTree,
                 LPTSTR lpszItem);

VOID PrintError (HRESULT hr,
                 UINT    uiLine,
                 LPTSTR  lpszFile,
                 LPCTSTR  lpFmt,
                 ...);

//
// Functions defined in wmicode.c
//

IWbemServices *ConnectToNamespace (VOID);

VOID EnumInstances (IWbemServices *pIWbemServices,
                    LPTSTR        lpszClass,
                    HWND          hwndInstTree);

VOID EnumProperties (IWbemServices *pIWbemServices,
                     LPTSTR        lpszClass,
                     LPTSTR        lpszInstance,
                     HWND          hwndPropTree);

IWbemClassObject *GetInstanceReference (IWbemServices *pIWbemServices,
                                        LPTSTR        lpszClass,
                                        LPTSTR        lpszInstance);

BOOL IsInstance (IWbemClassObject *pInst,
                 LPTSTR lpszInstance);

BOOL GetPropertyValue (IWbemClassObject *pRef,
                       LPTSTR lpszProperty, 
                       VARIANT *pvaPropertyValue,
                       LPTSTR *lppszPropertyType);

HRESULT UpdatePropertyValue (IWbemServices *pIWbemServices,
                             IWbemClassObject *pInstance,
                             LPTSTR lpszProperty,
                             LPVARIANT pvaNewValue);

BSTR StringToBstr (LPTSTR lpSrc,
                  int nLenSrc);

LPTSTR BstrToString (BSTR lpSrc,
                    int nLenSrc);


#endif // _TESTWMI_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\net\ms\e100bex\testwmi\testwmi.cpp ===
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//
// Copyright 2000 Microsoft Corporation.  All Rights Reserved.
//
// PROGRAM: testwmi.cpp
//
// AUTHOR:  Alok Sinha August 15, 2000
//
// PURPOSE: To test getting/setting custom classs of E100BEX driver.
//
// ENVIRONMENT: Windows 2000 user mode application.
//

#include "testwmi.h"

//
// List of custom classes as defined in E100BEX sample.
//
// If you want to use this application to excersize querying/setting guids
// exported by your driver then, simply add the class name of the guid
// to the following array and recompile the program.
//

LPTSTR lpszClasses[] = {
                         TEXT("E100BExampleSetUINT_OID"),
                         TEXT("E100BExampleQueryUINT_OID"),
                         TEXT("E100BExampleQueryArrayOID"),
                         TEXT("E100BExampleQueryStringOID")
                       };
                         
//
// Handle to this instance of the application.
//

HINSTANCE     hInstance;

//
// Program entry point.
//

int APIENTRY WinMain (HINSTANCE hInst,
                      HINSTANCE hPrevInstance, 
                      LPSTR lpCmdLine,         
                      int nCmdShow)
{
  HRESULT   hr;

  hInstance = hInst;

  //
  // Make sure common control DLL is loaded.
  //

  InitCommonControls();

  //
  // Initialize COM library. Must be done before invoking any
  // other COM function.
  //

  hr = CoInitializeEx( NULL,
                       COINIT_MULTITHREADED );

  if ( hr != S_OK ) {
     PrintError( hr,
               __LINE__,
               TEXT(__FILE__),
               TEXT("Failed to initialize COM library, program exiting...") );
  }
  else {

	    hr =  CoInitializeSecurity( NULL,
                                 -1,
                                 NULL,
                                 NULL,
								                         RPC_C_AUTHN_LEVEL_CONNECT, 
								                         RPC_C_IMP_LEVEL_IDENTIFY, 
								                         NULL,
                          