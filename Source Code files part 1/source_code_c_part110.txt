;
static double const q2 =  0.59578436142597344465e+2;
static double const q3 =  0.15024001160028576121e+2;
static double const q4 =  0.10000000000000000000e+1;


#define Q(g)  (((((g) + q3) * (g) + q2) * (g) + q1) * (g) + q0)
#define R(g)  ((((p3 * (g) + p2) * (g) + p1) * (g) + p0) * (g)) / Q(g)

/***
*double atan(double x) - arctangent
*
*Purpose:
*
*Entry:
*
*Exit:
*
*Exceptions:
*   P, I
\*******************************************************************************/
double atan(double x)
{
    uintptr_t savedcw;
    double result;

    /* save user fp control word */
    savedcw = _maskfp();

    /* check for infinity or NAN */
    if (IS_D_SPECIAL(x)){
        switch(_sptype(x)) {
        case T_PINF:
            result = PI_OVER_TWO;
            break;
        case T_NINF:
            result = -PI_OVER_TWO;
            break;
        case T_QNAN:
            return _handle_qnan1(OP_ATAN,x,savedcw);
        default: //T_SNAN
            return _except1(FP_I,OP_ATAN,x,_s2qnan(x),savedcw);
        }
    }

    if (x == 0.0)
        RETURN(savedcw,x);

    result = _atanhlp(x);
    RETURN_INEXACT1(OP_ATAN,x,result,savedcw);
}

/***
*double atan2(double x, double y) - arctangent (x/y)
*
*Purpose:
*
*Entry:
*
*Exit:
*
*Exceptions:
*    NAN or both args 0: DOMAIN error
*******************************************************************************/
double atan2(double v, double u)
{
    uintptr_t savedcw;
    double result;

    /* save user fp control word */
    savedcw = _maskfp();

    /* check for infinity or NAN */
    if (IS_D_SPECIAL(v) || IS_D_SPECIAL(u)){
        if (IS_D_SNAN(v) || IS_D_SNAN(u)){
            return _except2(FP_I,OP_ATAN2,v,u,_d_snan2(v,u),savedcw);
        }
        if (IS_D_QNAN(v) || IS_D_QNAN(u)){
            return _handle_qnan2(OP_ATAN2,v,u,savedcw);
        }
        if ((IS_D_INF(v) || IS_D_MINF(v)) &&
            (IS_D_INF(u) || IS_D_MINF(u))){
            return _except2(FP_I,OP_ATAN2,v,u,QNAN_ATAN2,savedcw);
        }
        /* the other combinations of infinities will be handled
         * later by the division v/u
         */
    }


    if (u == 0) {
        if (v == 0) {
            return _except2(FP_I,OP_ATAN2,v,u,QNAN_ATAN2,savedcw);
        }
        else {
            result = PI_OVER_TWO;
        }
    }
    else if (INTEXP(v) - INTEXP(u) > MAXEXP - 3) {
        /* v/u overflow */
        result = PI_OVER_TWO;
    }
    else {
        double arg = v/u;


        if (ABS(arg) < D_MIN) {

            if (v == 0.0 || IS_D_INF(u) || IS_D_MINF(u)) {
                result = (u < 0) ? PI : 0;
                if (v < 0) {
                    result = -result;
                }
                if (result == 0) {
                     RETURN(savedcw,  result);
                }
                else {
                     RETURN_INEXACT2(OP_ATAN2,v,u,result,savedcw);
                }
            }
            else {

                double v1, u1;
                int vexp, uexp;
                int exc_flags;

                //
                // in this case an underflow has occurred
                // re-compute the result in order to raise
                // an IEEE underflow exception
                //

                if (u < 0) {
                    result = v < 0 ? -PI: PI;
                    RETURN_INEXACT2(OP_ATAN2,v,u,result,savedcw);
                }

                v1 = _decomp(v, &vexp);
                u1 = _decomp(u, &uexp);
                result = _add_exp(v1/u1, vexp-uexp+IEEE_ADJUST);
                result = ABS(result);

                if (v < 0) {
                    result = -result;
                }

                // this is not a perfect solution. In the future
                // we may want to have a way to let the division
                // generate an exception and propagate the IEEE result
                // to the user's handler

                exc_flags = FP_U;
                if (_statfp() & ISW_INEXACT) {
                    exc_flags  |= FP_P;
                }
                return _except2(exc_flags,OP_ATAN2,v,u,result,savedcw);

            }
        }

        else {
           result = _atanhlp( ABS(arg) );
        }

    }

    /* set sign of the result */
    if (u < 0) {
        result = PI - result;
    }
    if (v < 0) {
        result = -result;
    }


    RETURN_INEXACT2(OP_ATAN2,v,u,result,savedcw);
}





/***
*double _atanhlp(double x) - arctangent helper
*
*Purpose:
*   Compute arctangent of x, assuming x is a valid, non infinite
*   number.
*   The algorithm (reduction / rational approximation) is
*   taken from Cody & Waite.
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/
static double _atanhlp(double x)
{
    double f,g,result;
    int n;


    f = ABS(x);
    if (f > MAX_ARG) {
        // if this step is ommited, 1.0/f might underflow in the
        // following block
        return x > 0.0 ? PI_OVER_TWO : -PI_OVER_TWO;
    }
    if (f > 1.0) {
        f = 1.0/f;
        n = 2;
    }
    else {
        n = 0;
    }

    if (f > TWO_M_SQRT3) {
        f = (((SQRT3_M_ONE * f - .5) - .5) + f) / (SQRT3 + f);
        n++;
    }

    if (ABS(f) < EPS) {
        result = f;
    }
    else {
        g = f*f;
        result = f + f * R(g);
    }

    if (n > 1)
        result = -result;

    result += a[n];

    if (x < 0.0)
        result = -result;


    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\bessel.c ===
/***
*bessel.c - defines the bessel functions for C.
*
*       Copyright (c) 1983-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*
*  This is a collection of routines for computing the bessel functions j0, j1,
*  y0, y1, jn and yn.  The approximations used for j0, j1, y0, and y1 are
*  from the approximations listed in Hart, Computer Approximations, 1978.
*  For these functions, a rational approximation with 18 places of accuracy
*  after the decimal point has been selected.  jn and yn are computed using
*  the recursive formula that the bessel functions satisfy.  Using these
*  formulas their values can be computed from the values of the bessel
*  functions of order 0 and 1.  In the case of jn, the recursive formula
*
*                 jn(n-1,x) = (2.0*n/x)*jn(n,x) - jn(n+1,x)
*
*  is used to stabily compute in the downward direction, normalizing in the
*  the end by j0(x) in the usual manner.  In the case of yn, the recursive
*  formula
*
*                 yn(n+1,x) = (2.0*n/x)*yn(n,x) - yn(n-1,x)
*
*  is used to stably compute the functions in the forward direction.
*
*
*  Note: upon testing and experimentation the low range approximations were
*        found to have an error on the order of 1.0e-14 in the neighborhood of
*        8.0.  Moving the boundary point between the low range and high
*        range approximations down to 7.5 reduced this error to less than
*        1.0e-14.  This is not suprising.  The high range asymptotoic is
*        likely to have greater precision in the neighborhood of 8.0.
*
*Revision History:
*
*       06/05/89  WAJ   Added this header. Made changes for C6 and -W3
*       06/06/89  WAJ   Moved some of the routines into _RTEXT if MTHREAD.
*       08/17/90  WAJ   Now uses _stdcall.
*       01/13/92  GDP   changed domain_err. No full IEEE support yet
*       04-06-93  SKS   Replace _CALLTYPE* with __cdecl
*       08-28-96  JWM   Disabled warning 4056.
*
*******************************************************************************/


/*
 *  The functions sqrt, sin, cos, and log from the math library are used in
 *  the computations of the bessel functions.
 */

#include <math.h>
#include <trans.h>

#ifdef _M_IX86
#pragma warning(disable:4056)
#endif

#ifdef _X86SEG_
#include <os2supp.h>
#define _CALLTYPE1 _PASCAL
#else
#include <cruntime.h>
#endif

#ifdef LD_VER
#define D_TYPE  long double

#else
#define D_TYPE  double
#endif



static D_TYPE  domain_err( int who, D_TYPE arg1, D_TYPE arg2 ); /* error routine for y0, y1, yn */
static D_TYPE  evaluate( D_TYPE x, D_TYPE p[], int n1, D_TYPE q[], int n2 );


#ifdef FAR_CODE
    #ifdef LD_VER
        #pragma alloc_text( _RTEXT, _y0l, _y1l, _ynl, _j0l, _j1l, _jnl )
    #else
        #pragma alloc_text( _RTEXT, _y0, _y1, _yn, _j0, _j1, _jn )
    #endif
#endif



/*
 *  Following are the constants needed for the computations of the bessel
 *  functions as in Hart.
 */

#define PI 3.14159265358979323846264338327950288


/* coefficients for Hart JZERO 5848, the low range approximation for _j0 */

static D_TYPE J0p[12] = {
                         0.1208181340866561224763662419e+12 ,
                        -0.2956513002312076810191727211e+11 ,
                         0.1729413174598080383355729444e+10 ,
                        -0.4281611621547871420502838045e+08 ,
                         0.5645169313685735094277826749e+06 ,
                        -0.4471963251278787165486324342e+04 ,
                         0.2281027164345610253338043760e+02 ,
                        -0.7777570245675629906097285039e-01 ,
                         0.1792464784997734953753734861e-03 ,
                        -0.2735011670747987792661294323e-06 ,
                         0.2553996162031530552738418047e-09 ,
                        -0.1135416951138795305302383379e-12
                        };

static D_TYPE J0q[5] =  {
                        0.1208181340866561225104607422e+12 ,
                        0.6394034985432622416780183619e+09 ,
                        0.1480704129894421521840387092e+07 ,
                        0.1806405145147135549477896097e+04 ,
                        0.1e+01
                        };


/* coefficients for Hart 6548, P0 of the high range approximation for j0
   and _y0 */

static D_TYPE P0p[6] =  {
                        0.2277909019730468430227002627e+05 ,
                        0.4134538663958076579678016384e+05 ,
                        0.2117052338086494432193395727e+05 ,
                        0.3480648644324927034744531110e+04 ,
                        0.1537620190900835429577172500e+03 ,
                        0.8896154842421045523607480000e+00
                        };

static D_TYPE P0q[6] =  {
                        0.2277909019730468431768423768e+05 ,
                        0.4137041249551041663989198384e+05 ,
                        0.2121535056188011573042256764e+05 ,
                        0.3502873513823560820735614230e+04 ,
                        0.1571115985808089364906848200e+03 ,
                        0.1e+01
                        };


/* coefficients for Hart 6948, Q0 of the high range approximation for _j0
   and _y0 */

static D_TYPE Q0p[6] =  {
                        -0.8922660020080009409846916000e+02 ,
                        -0.1859195364434299380025216900e+03 ,
                        -0.1118342992048273761126212300e+03 ,
                        -0.2230026166621419847169915000e+02 ,
                        -0.1244102674583563845913790000e+01 ,
                        -0.8803330304868075181663000000e-02
                        };

static D_TYPE Q0q[6] =  {
                        0.5710502412851206190524764590e+04 ,
                        0.1195113154343461364695265329e+05 ,
                        0.7264278016921101883691345060e+04 ,
                        0.1488723123228375658161346980e+04 ,
                        0.9059376959499312585881878000e+02 ,
                        0.1e+01
                        };



/* coefficients for Hart JONE 6047, the low range approximation for _j1 */

static D_TYPE J1p[11] = {
                         0.4276440148317146125749678272e+11 ,
                        -0.5101551390663600782363700742e+10 ,
                         0.1928444249391651825203957853e+09 ,
                        -0.3445216851469225845312168656e+07 ,
                         0.3461845033978656620861683039e+05 ,
                        -0.2147334276854853222870548439e+03 ,
                         0.8645934990693258061130801001e+00 ,
                        -0.2302415336775925186376173217e-02 ,
                         0.3991878933072250766608485041e-05 ,
                        -0.4179409142757237977587032616e-08 ,
                         0.2060434024597835939153003596e-11
                        };


 static D_TYPE J1q[5] = {
                        0.8552880296634292263013618479e+11 ,
                        0.4879975894656629161544052051e+09 ,
                        0.1226033111836540909388789681e+07 ,
                        0.1635396109098603257687643236e+04 ,
                        0.1e+01
                        };


/* coefficients for Hart PONE 6749, P1 of the high range approximation for
   _j1 and y1 */

static D_TYPE P1p[6] =  {
                        0.3522466491336797983417243730e+05 ,
                        0.6275884524716128126900567500e+05 ,
                        0.3135396311091595742386698880e+05 ,
                        0.4985483206059433843450045500e+04 ,
                        0.2111529182853962382105718000e+03 ,
                        0.1257171692914534155849500000e+01
                        };

static D_TYPE P1q[6] =  {
                        0.3522466491336797980683904310e+05 ,
                        0.6269434695935605118888337310e+05 ,
                        0.3124040638190410399230157030e+05 ,
                        0.4930396490181088978386097000e+04 ,
                        0.2030775189134759322293574000e+03 ,
                        0.1e+01
                        };


/* coefficients for Hart QONE 7149, Q1 of the high range approximation for _j1
   and y1 */

static D_TYPE Q1p[6] =  {
                        0.3511751914303552822533318000e+03 ,
                        0.7210391804904475039280863000e+03 ,
                        0.4259873011654442389886993000e+03 ,
                        0.8318989576738508273252260000e+02 ,
                        0.4568171629551226706440500000e+01 ,
                        0.3532840052740123642735000000e-01
                        };

static D_TYPE Q1q[6] =  {
                        0.7491737417180912771451950500e+04 ,
                        0.1541417733926509704998480510e+05 ,
                        0.9152231701516992270590472700e+04 ,
                        0.1811186700552351350672415800e+04 ,
                        0.1038187587462133728776636000e+03 ,
                        0.1e+01
                        };


/* coeffiecients for Hart YZERO 6245, the low range approximation for y0 */

static D_TYPE Y0p[9] =  {
                        -0.2750286678629109583701933175e+20 ,
                         0.6587473275719554925999402049e+20 ,
                        -0.5247065581112764941297350814e+19 ,
                         0.1375624316399344078571335453e+18 ,
                        -0.1648605817185729473122082537e+16 ,
                         0.1025520859686394284509167421e+14 ,
                        -0.3436371222979040378171030138e+11 ,
                         0.5915213465686889654273830069e+08 ,
                        -0.4137035497933148554125235152e+05
                        };

static D_TYPE Y0q[9] =  {
                        0.3726458838986165881989980739e+21 ,
                        0.4192417043410839973904769661e+19 ,
                        0.2392883043499781857439356652e+17 ,
                        0.9162038034075185262489147968e+14 ,
                        0.2613065755041081249568482092e+12 ,
                        0.5795122640700729537480087915e+09 ,
                        0.1001702641288906265666651753e+07 ,
                        0.1282452772478993804176329391e+04 ,
                        0.1e+01
                        };


/* coefficients for Hart YONE 6444, the low range approximation for y1 */

static D_TYPE Y1p[8] =  {
                        -0.2923821961532962543101048748e+20 ,
                         0.7748520682186839645088094202e+19 ,
                        -0.3441048063084114446185461344e+18 ,
                         0.5915160760490070618496315281e+16 ,
                        -0.4863316942567175074828129117e+14 ,
                         0.2049696673745662182619800495e+12 ,
                        -0.4289471968855248801821819588e+09 ,
                         0.3556924009830526056691325215e+06
                        };


static D_TYPE Y1q[9] =  {
                        0.1491311511302920350174081355e+21 ,
                        0.1818662841706134986885065935e+19 ,
                        0.1131639382698884526905082830e+17 ,
                        0.4755173588888137713092774006e+14 ,
                        0.1500221699156708987166369115e+12 ,
                        0.3716660798621930285596927703e+09 ,
                        0.7269147307198884569801913150e+06 ,
                        0.1072696143778925523322126700e+04 ,
                        0.1e+01
                        };



/*
 *  Function name:  evaluate
 *
 *  Arguments:      x  -  double
 *                  p, q  -  double arrays of coefficients
 *                  n1, n2  -  the order of the numerator and denominator
 *                             polynomials
 *
 *  Description:    evaluate is meant strictly as a helper routine for the
 *                  bessel function routines to evaluate the rational polynomial
 *                  aproximations appearing in _j0, _j1, y0, and y1.  Given the
 *                  coefficient arrays in p and q, it evaluates the numerator
 *                  and denominator polynomials through orders n1 and n2
 *                  respectively, returning p(x)/q(x).  This routine is not
 *                  available to the user of the bessel function routines.
 *
 *  Side Effects:   evaluate uses the global data stored in the coefficients
 *                  above.  No other global data is used or affected.
 *
 *  Author:         written  R.K. Wyss, Microsoft,  Sept. 9, 1983
 *
 *  History:
 */

static D_TYPE  evaluate( D_TYPE x, D_TYPE p[], int n1, D_TYPE q[], int n2 )
{
D_TYPE  numerator, denominator;
int     i;

    numerator = x*p[n1];
    for ( i = n1-1 ; i > 0 ; i-- )
        numerator = x*(p[i] + numerator);
    numerator += p[0];

    denominator = x*q[n2];
    for ( i = n2-1 ; i > 0 ; i-- )
        denominator = x*(q[i] + denominator);
    denominator += q[0];

    return( numerator/denominator );
}


/*
 *  Function name:  _j0
 *
 *  Arguments:      x  -  double
 *
 *  Description:    _j0 computes the bessel function of the first kind of zero
 *                  order for real values of its argument x, where x can range
 *                  from - infinity to + infinity.  The algorithm is taken
 *                  from Hart, Computer Approximations, 1978, and yields full
 *                  double precision accuracy.
 *
 *  Side Effects:   no global data other than the static coefficients above
 *                  is used or affected.
 *
 *  Author:         written  R.K. Wyss,  Microsoft,  Sept. 9, 1983
 *
 *  History:
 */

#ifdef  LD_VER
    D_TYPE _
cdecl _j0l( D_TYPE x )
#else
    D_TYPE __cdecl _j0( D_TYPE x )
#endif
{
D_TYPE  z, P0, Q0;

    /* if the argument is negative, take the absolute value */

    if ( x < 0.0 )
        x = - x;

    /* if x <= 7.5  use Hart JZERO 5847 */

    if ( x <= 7.5 )
        return( evaluate( x*x, J0p, 11, J0q, 4) );

    /* else if x >= 7.5  use Hart PZERO 6548 and QZERO 6948, the high range
       approximation */

    else {
        z = 8.0/x;
        P0 = evaluate( z*z, P0p, 5, P0q, 5);
        Q0 = z*evaluate( z*z, Q0p, 5, Q0q, 5);
        return( sqrt(2.0/(PI*x))*(P0*cos(x-PI/4) - Q0*sin(x-PI/4)) );
        }
}


/*
 *  Function name:  _j1
 *
 *  Arguments:      x  -  double
 *
 *  Description:    _j1 computes the bessel function of the first kind of the
 *                  first order for real values of its argument x, where x can
 *                  range from - infinity to + infinity.  The algorithm is taken
 *                  from Hart, Computer Approximations, 1978, and yields full
 *                  D_TYPE precision accuracy.
 *
 *  Side Effects:   no global data other than the static coefficients above
 *                  is used or affected.
 *
 *  Author:         written  R.K. Wyss,  Microsoft,  Sept. 9, 1983
 *
 *  History:
 */

#ifdef  LD_VER
    D_TYPE _cdecl _j1l( D_TYPE x )
#else
    D_TYPE __cdecl _j1( D_TYPE x )
#endif
{
D_TYPE  z, P1, Q1;
int     sign;

     /* if the argument is negative, take the absolute value and set sign */

     sign = 1;
     if( x < 0.0 ){
        x = -x;
        sign = -1;
        }

     /* if x <= 7.5  use Hart JONE 6047 */

     if ( x <= 7.5 )
        return( sign*x*evaluate( x*x, J1p, 10, J1q, 4) );


    /* else if x > 7.5  use Hart PONE 6749 and QONE 7149, the high range
       approximation */

    else {
        z = 8.0/x;
        P1 = evaluate( z*z, P1p, 5, P1q, 5);
        Q1 = z*evaluate( z*z, Q1p, 5, Q1q, 5);
        return( sign*sqrt(2.0/(PI*x))*
                           ( P1*cos(x-3.0*PI/4.0) - Q1*sin(x-3.0*PI/4.0) )  );
        }
}



/*
 *  Function name:  _y0
 *
 *  Arguments:      x  -  double
 *
 *  Description:    y0 computes the bessel function of the second kind of zero
 *                  order for real values of its argument x, where x can range
 *                  from 0 to + infinity.  The algorithm is taken from Hart,
 *                  Computer Approximations, 1978, and yields full double
 *                  precision accuracy.
 *
 *  Side Effects:   no global data other than the static coefficients above
 *                  is used or affected.
 *
 *  Author:         written  R.K. Wyss, Microsoft,  Sept. 9, 1983
 *
 *  History:
 */

#ifdef  LD_VER
    D_TYPE _cdecl _y0l( D_TYPE x )
#else
    D_TYPE __cdecl _y0( D_TYPE x )
#endif
{
D_TYPE  z, P0, Q0;


    /* if the argument is negative, set EDOM error, print an error message,
     * and return -HUGE
     */

    if (x < 0.0)
        return( domain_err(OP_Y0 , x, D_IND) );


    /* if x <= 7.5 use Hart YZERO 6245, the low range approximation */

    if ( x <= 7.5 )
        return( evaluate( x*x, Y0p, 8, Y0q, 8) + (2.0/PI)*_j0(x)*log(x) );


    /* else if x > 7.5 use Hart PZERO 6548 and QZERO 6948, the high range
       approximation */

    else {
        z = 8.0/x;
        P0 = evaluate( z*z, P0p, 5, P0q, 5);
        Q0 = z*evaluate( z*z, Q0p, 5, Q0q, 5);
        return( sqrt(2.0/(PI*x))*(P0*sin(x-PI/4) + Q0*cos(x-PI/4)) );
        }
}


/*
 *  Function name:  _y1
 *
 *  Arguments:      x  -  double
 *
 *  Description:    y1 computes the bessel function of the second kind of first
 *                  order for real values of its argument x, where x can range
 *                  from 0 to + infinity.  The algorithm is taken from Hart,
 *                  Computer Approximations, 1978, and yields full double
 *                  precision accuracy.
 *
 *  Side Effects:   no global data other than the static coefficients above
 *                  is used or affected.
 *
 *  Author:         written  R.K. Wyss,  Microsoft,  Sept. 9, 1983
 *
 *  History:
 */

#ifdef  LD_VER
    D_TYPE _cdecl _y1l( D_TYPE x )
#else
    D_TYPE __cdecl _y1( D_TYPE x )
#endif
{
D_TYPE  z, P1, Q1;


    /* if the argument is negative, set EDOM error, print an error message,
     * and return -HUGE
     */

    if (x < 0.0)
        return( domain_err(OP_Y1, x, D_IND) );

    /* if x <= 7.5  use Hart YONE 6444, the low range approximation */

    if ( x <= 7.5 )
        return( x*evaluate( x*x, Y1p, 7, Y1q, 8)
                               + (2.0/PI)*(_j1(x)*log(x) - 1.0/x) );


    /* else if x > 7.5  use Hart PONE 6749 and QONE 7149, the high range
       approximation */

    else {
        z = 8.0/x;
        P1 = evaluate( z*z, P1p, 5, P1q, 5);
        Q1 = z*evaluate( z*z, Q1p, 5, Q1q, 5);
        return(  sqrt(2.0/(PI*x))*
                         ( P1*sin(x-3.0*PI/4.0) + Q1*cos(x-3.0*PI/4.0) )   );
        }
}


/*
 *  Function name:  _jn
 *
 *  Arguments:      n  -  integer
 *                  x  -  double
 *
 *  Description:    _jn computes the bessel function of the first kind of order
 *                  n for real values of its argument, where x can range from
 *                  - infinity to + infinity, and n can range over the integers
 *                  from - infinity to + infinity.  The function is computed
 *                  by recursion, using the formula
 *
 *                               _jn(n-1,x) = (2.0*n/x)*_jn(n,x) - _jn(n+1,x)
 *
 *                  stabilly in the downward direction, normalizing by _j0(x)
 *                  in the end in the usual manner.
 *
 *  Side Effects:   the routines _j0, y0, and yn are called during the
 *                  execution of this routine.
 *
 *  Author:         written  R.K. Wyss,  Microsoft,  Sept. 9, 1983
 *
 *  History:
 *              07/29/85        Greg Whitten
 *                              rewrote _jn to use Hart suggested algorithm
 */

#ifdef  LD_VER
    D_TYPE _cdecl _jnl( int n, D_TYPE x )
#else
    D_TYPE __cdecl _jn( int n, D_TYPE x )
#endif
{
int     i;
D_TYPE  x2, jm1, j, jnratio, hold;

    /*  use symmetry relationships:  _j(-n,x) = _j(n,-x) */

    if( n < 0 ){
        n = -n;
        x = -x;
        }

    /*  if n = 0 use _j0(x) and if n = 1 use _j1(x) functions */

    if (n == 0)
        return (_j0(x));

    if (n == 1)
        return (_j1(x));

    /*  if x = 0.0 then _j(n,0.0) = 0.0 for n > 0   (_j(0,x) = 1.0) */

    if (x == 0.0)
        return (0.0);

    /*  otherwise - must use the recurrence relation
     *
     *      _jn(n+1,x) = (2.0*n/x)*_jn(n,x) - _jn(n-1,x)  forward
     *      _jn(n-1,x) = (2.0*n/x)*_jn(n,x) - _jn(n+1,x)  backward
     */

    if( (double)n < fabs(x) ) {

        /*  stably compute _jn using forward recurrence above */

        n <<= 1;  /* n *= 2  (n is positive) */
        jm1 = _j0(x);
        j = _j1(x);
        i = 2;
        for(;;) {
            hold = j;
            j = ((double)(i))*j/x - jm1;
            i += 2;
            if (i == n)
                return (j);
            jm1 = hold;
            }
        }
    else {
        /*  stably compute _jn using backward recurrence above */

        /*  use Hart continued fraction formula for j(n,x)/j(n-1,x)
         *  so that we can compute a normalization factor
         */

        n <<= 1;                /* n *= 2  (n is positive) */
        x2 = x*x;
        hold = 0.0;             /* initial continued fraction tail value */
        for (i=n+36; i>n; i-=2)
            hold = x2/((double)(i) - hold);
        jnratio = j = x/((double)(n) - hold);
        jm1 = 1.0;

        /*  have jn/jn-1 ratio - now use backward recurrence */

        i = n-2;
        for (;;) {
            hold = jm1;
            jm1 = ((double)(i))*jm1/x - j;
            i -= 2;
            if (i == 0)
                    break;
            j = hold;
            }

        /*  jm1 is relative j0(x) so normalize it for final result
         *
         *  jnratio = K*j(n,x) and jm1 = K*_j0(x)
         */

        return(_j0(x)*jnratio/jm1);
        }
}


/*
 *  Function name:  _yn
 *
 *  Arguments:      n  -  integer
 *                  x  -  double
 *
 *  Description:    yn computes the bessel function of the second kind of order
 *                  n for real values of its argument x, where x can range from
 *                  0 to + infinity, and n can range over the integers from
 *                  - infinity to + infinity. The function is computed by
 *                  recursion from y0 and y1, using the recursive formula
 *
 *                          yn(n+1,x) = (2.0*n/x)*yn(n,x) - yn(n-1,x)
 *
 *                  in the forward direction.
 *
 *  Side Effects:   the routines y0 and y1 are called during the execution
 *                  of this routine.
 *
 *  Author:         written  R.K. Wyss,  Microsoft,  Sept. 9, 1983
 *
 *  History:
 *              08/09/85        Greg Whitten
 *                              added check for n==0 and n==1
 *              04/20/87        Barry McCord
 *                              eliminated use of "const" as an identifier for ANSI conformance
 */

#ifdef  LD_VER
    D_TYPE _cdecl _ynl( int n, D_TYPE x )
#else
    D_TYPE __cdecl _yn( int n, D_TYPE x )
#endif
{
int     i;
int     sign;
D_TYPE  constant, yn2, yn1, yn0;


    /* if the argument is negative, set EDOM error, print an error message,
         * and return -HUGE
         */

    if (x < 0.0)
        return(domain_err(OP_YN, x, D_IND));


     /* take the absolute value of n, and set sign accordingly */

     sign = 1;
     if( n < 0 ){
        n = -n;
        if( n&1 )
            sign = -1;
        }

     if( n == 0 )
        return( sign*_y0(x) );

     if (n == 1)
        return( sign*_y1(x) );

     /* otherwise go ahead and compute the function by iteration */

     yn0 = _y0(x);
     yn1 = _y1(x);

     constant = 2.0/x;
     for( i = 1 ; i < n ; i++ ){
        yn2 = constant*i*yn1 - yn0;
        yn0 = yn1;
        yn1 = yn2;
        }
     return( sign*yn2 );
}


static D_TYPE  domain_err( int who, D_TYPE arg1, D_TYPE arg2 )
{
#ifdef  LD_VER
#error long double version not supported
#endif

    uintptr_t savedcw;
    savedcw = _maskfp();
    return _except1(FP_I, who, arg1, arg2, savedcw);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\include\cv.h ===
/***
*cv.h - definitions for floating point conversion
*
*       Copyright (c) 1991-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*   define types, macros, and constants used in floating point
*   conversion routines
*
*Revision History:
*       07-17-91  GDP   initial version
*       09-21-91  GDP   restructured 'ifdef' directives
*       10-29-91  GDP   MIPS port: new defs for ALIGN and DOUBLE
*       03-03-92  GDP   removed os2 16-bit stuff
*       04-30-92  GDP   support intrncvt.c --cleanup and reorganize
*       05-13-92  XY    fixed B_END macros
*       06-16-92  GDP   merged changes from \\orville and \\vangogh trees
*       09-05-92  GDP   included fltintrn.h, new calling convention macros
*       04-06-93  SKS   Replace _CALLTYPE* with __cdecl
*       07-16-93  SRW   ALPHA Merge
*       11-17-93  GJF   Merged in NT version. Replaced _ALPHA_ with _M_ALPHA,
*                       MIPS with _M_MRX000, MTHREAD with _MT, and deleted
*                       M68K stuff.
*       10-02-94  BWT   PPC merge
*       02-06-95  JWM   Mac merge
*       10-07-97  RDL   Added IA64.
*       05-05-99  RDL   Added _M_IA64 to #if def's for alignment.
*       05-13-99  PML   Remove _CRTAPI1
*       05-17-99  PML   Remove all Macintosh support.
*       07-15-01  PML   Remove all ALPHA, MIPS, and PPC code
*
*******************************************************************************/

#ifndef _INC_CV

#ifdef __cplusplus
extern "C" {
#endif

#include <cruntime.h>

/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


#include <fltintrn.h>


/* define little endian or big endian memory */

#if     defined(_M_IX86) || defined(_M_IA64) || defined(_M_AMD64)
#define L_END
#endif

typedef unsigned char   u_char;   /* should have 1 byte */
typedef char            s_char;   /* should have 1 byte */
typedef unsigned short  u_short;  /* should have 2 bytes */
typedef signed short    s_short;  /* should have 2 bytes */
typedef unsigned int    u_long;   /* sholuld have 4 bytes */
typedef int             s_long;   /* sholuld have 4 bytes */

/* calling conventions */
#define _CALLTYPE5


/*
 * defining _LDSUPPORT enables using long double computations
 * for string conversion. We do not do this even for i386,
 * since we want to avoid using floating point code that
 * may generate IEEE exceptions.
 *
 * Currently our string conversion routines do not conform
 * to the special requirements of the IEEE standard for
 * floating point conversions
 */


#ifndef _LDSUPPORT

#pragma pack(4)
typedef struct {
    u_char ld[10];
} _LDOUBLE;
#pragma pack()

#define PTR_LD(x) ((u_char  *)(&(x)->ld))

#else

typedef long double _LDOUBLE;

#define PTR_LD(x) ((u_char  *)(x))

#endif


#pragma pack(4)
typedef struct {
    u_char ld12[12];
} _LDBL12;
#pragma pack()

typedef struct {
    float f;
} FLOAT;



/*
 * return values for internal conversion routines
 * (12-byte to long double, double, or float)
 */

typedef enum {
    INTRNCVT_OK,
    INTRNCVT_OVERFLOW,
    INTRNCVT_UNDERFLOW
} INTRNCVT_STATUS;


/*
 * return values for strgtold12 routine
 */

#define SLD_UNDERFLOW 1
#define SLD_OVERFLOW 2
#define SLD_NODIGITS 4

#define MAX_MAN_DIGITS 21


/* specifies '%f' format */

#define SO_FFORMAT 1

typedef  struct _FloatOutStruct {
                    short   exp;
                    char    sign;
                    char    ManLen;
                    char    man[MAX_MAN_DIGITS+1];
                    } FOS;



#define PTR_12(x) ((u_char  *)(&(x)->ld12))

#define MAX_USHORT  ((u_short)0xffff)
#define MSB_USHORT  ((u_short)0x8000)
#define MAX_ULONG   ((u_long)0xffffffff)
#define MSB_ULONG   ((u_long)0x80000000)

#define TMAX10 5200       /* maximum temporary decimal exponent */
#define TMIN10 -5200      /* minimum temporary decimal exponent */
#define LD_MAX_EXP_LEN 4  /* maximum number of decimal exponent digits */
#define LD_MAX_MAN_LEN 24  /* maximum length of mantissa (decimal)*/
#define LD_MAX_MAN_LEN1 25 /* MAX_MAN_LEN+1 */

#define LD_BIAS 0x3fff    /* exponent bias for long double */
#define LD_BIASM1 0x3ffe  /* LD_BIAS - 1 */
#define LD_MAXEXP 0x7fff  /* maximum biased exponent */

#define D_BIAS  0x3ff    /* exponent bias for double */
#define D_BIASM1 0x3fe  /* D_BIAS - 1 */
#define D_MAXEXP 0x7ff  /* maximum biased exponent */


/*
 * end of definitions from crt32\h\fltintrn.h
 */

/* Recognizing special patterns in the mantissa field */
#define _EXP_SP  0x7fff
#define NAN_BIT (1<<30)

#define _IS_MAN_INF(signbit, manhi, manlo) \
        ( (manhi)==MSB_ULONG && (manlo)==0x0 )


/* i386, IA64, and AMD64 use same NaN format */
#if     defined(_M_IX86) || defined(_M_IA64) || defined(_M_AMD64)
#define _IS_MAN_IND(signbit, manhi, manlo) \
        ((signbit) && (manhi)==0xc0000000 && (manlo)==0)

#define _IS_MAN_QNAN(signbit, manhi, manlo) \
        ( (manhi)&NAN_BIT )

#define _IS_MAN_SNAN(signbit, manhi, manlo) \
        (!( _IS_MAN_INF(signbit, manhi, manlo) || \
           _IS_MAN_QNAN(signbit, manhi, manlo) ))


#endif



#if     defined (L_END) && !( defined(_M_IA64) || defined(_M_AMD64))
/* "little endian" memory */
/*
 * Manipulation of a 12-byte long double number (an ordinary
 * 10-byte long double plus two extra bytes of mantissa).
 */
/*
 * byte layout:
 *
 *              +-----+--------+--------+-------+
 *              |XT(2)|MANLO(4)|MANHI(4)|EXP(2) |
 *              +-----+--------+--------+-------+
 *              |<-UL_LO->|<-UL_MED->|<-UL_HI ->|
 *                  (4)       (4)        (4)
 */

/* a pointer to the exponent/sign portion */
#define U_EXP_12(p) ((u_short  *)(PTR_12(p)+10))

/* a pointer to the 4 hi-order bytes of the mantissa */
#define UL_MANHI_12(p) ((u_long  *)(PTR_12(p)+6))

/* a pointer to the 4 lo-order bytes of the ordinary (8-byte) mantissa */
#define UL_MANLO_12(p) ((u_long  *)(PTR_12(p)+2))

/* a pointer to the 2 extra bytes of the mantissa */
#define U_XT_12(p) ((u_short  *)PTR_12(p))

/* a pointer to the 4 lo-order bytes of the extended (10-byte) mantissa */
#define UL_LO_12(p) ((u_long  *)PTR_12(p))

/* a pointer to the 4 mid-order bytes of the extended (10-byte) mantissa */
#define UL_MED_12(p) ((u_long  *)(PTR_12(p)+4))

/* a pointer to the 4 hi-order bytes of the extended long double */
#define UL_HI_12(p) ((u_long  *)(PTR_12(p)+8))

/* a pointer to the byte of order i (LSB=0, MSB=9)*/
#define UCHAR_12(p,i) ((u_char  *)PTR_12(p)+(i))

/* a pointer to a u_short with offset i */
#define USHORT_12(p,i) ((u_short  *)((u_char  *)PTR_12(p)+(i)))

/* a pointer to a u_long with offset i */
#define ULONG_12(p,i) ((u_long  *)((u_char  *)PTR_12(p)+(i)))

/* a pointer to the 10 MSBytes of a 12-byte long double */
#define TEN_BYTE_PART(p) ((u_char  *)PTR_12(p)+2)

/*
 * Manipulation of a 10-byte long double number
 */
#define U_EXP_LD(p) ((u_short  *)(PTR_LD(p)+8))
#define UL_MANHI_LD(p) ((u_long  *)(PTR_LD(p)+4))
#define UL_MANLO_LD(p) ((u_long  *)PTR_LD(p))

/*
 * Manipulation of a 64bit IEEE double
 */
#define U_SHORT4_D(p) ((u_short  *)(p) + 3)
#define UL_HI_D(p) ((u_long  *)(p) + 1)
#define UL_LO_D(p) ((u_long  *)(p))

#endif

/* big endian */
#if defined (B_END)

/*
 * byte layout:
 *
 *              +------+-------+---------+------+
 *              |EXP(2)|MANHI(4)|MANLO(4)|XT(2) |
 *              +------+-------+---------+------+
 *              |<-UL_HI->|<-UL_MED->|<-UL_LO ->|
 *                  (4)       (4)        (4)
 */


#define U_EXP_12(p) ((u_short  *)PTR_12(p))
#define UL_MANHI_12(p) ((u_long  *)(PTR_12(p)+2))
#define UL_MANLO_12(p) ((u_long  *)(PTR_12(p)+6))
#define U_XT_12(p) ((u_short  *)(PTR_12(p)+10))

#define UL_LO_12(p) ((u_long  *)(PTR_12(p)+8))
#define UL_MED_12(p) ((u_long  *)(PTR_12(p)+4))
#define UL_HI_12(p) ((u_long  *)PTR_12(p))

#define UCHAR_12(p,i) ((u_char  *)PTR_12(p)+(11-(i)))
#define USHORT_12(p,i)  ((u_short  *)((u_char  *)PTR_12(p)+10-(i)))
#define ULONG_12(p,i) ((u_long  *)((u_char  *)PTR_12(p)+8-(i)))
#define TEN_BYTE_PART(p) (u_char  *)PTR_12(p)

#define U_EXP_LD(p) ((u_short  *)PTR_LD(p))
#define UL_MANHI_LD(p) ((u_long  *)(PTR_LD(p)+2))
#define UL_MANLO_LD(p) ((u_long  *)(PTR_LD(p)+6))

/*
 * Manipulation of a 64bit IEEE double
 */
#define U_SHORT4_D(p) ((u_short  *)(p))
#define UL_HI_D(p) ((u_long  *)(p))
#define UL_LO_D(p) ((u_long  *)(p) + 1)

#endif

#if     defined(_M_IA64) || defined(_M_AMD64)

#define ALIGN(x)  ( (unsigned long  __unaligned *) (x))

#define U_EXP_12(p) ((u_short  *)(PTR_12(p)+10))

#define UL_MANHI_12(p) ((u_long  __unaligned *) (PTR_12(p)+6) )
#define UL_MANLO_12(p) ((u_long  __unaligned *) (PTR_12(p)+2) )


#define U_XT_12(p) ((u_short  *)PTR_12(p))
#define UL_LO_12(p) ((u_long  *)PTR_12(p))
#define UL_MED_12(p) ((u_long  *)(PTR_12(p)+4))
#define UL_HI_12(p) ((u_long  *)(PTR_12(p)+8))

/* the following 3 macros do not take care of proper alignment */
#define UCHAR_12(p,i) ((u_char  *)PTR_12(p)+(i))
#define USHORT_12(p,i) ((u_short  *)((u_char  *)PTR_12(p)+(i)))
#define ULONG_12(p,i) ((u_long  *) ((u_char  *)PTR_12(p)+(i) ))

#define TEN_BYTE_PART(p) ((u_char  *)PTR_12(p)+2)

/*
 * Manipulation of a 10-byte long double number
 */
#define U_EXP_LD(p) ((u_short  *)(PTR_LD(p)+8))

#define UL_MANHI_LD(p) ((u_long  *) (PTR_LD(p)+4) )
#define UL_MANLO_LD(p) ((u_long  *) PTR_LD(p) )

/*
 * Manipulation of a 64bit IEEE double
 */
#define U_SHORT4_D(p) ((u_short  *)(p) + 3)
#define UL_HI_D(p) ((u_long  *)(p) + 1)
#define UL_LO_D(p) ((u_long  *)(p))

#endif


#define PUT_INF_12(p,sign) \
                  *UL_HI_12(p) = (sign)?0xffff8000:0x7fff8000; \
                  *UL_MED_12(p) = 0; \
                  *UL_LO_12(p) = 0;

#define PUT_ZERO_12(p) *UL_HI_12(p) = 0; \
                  *UL_MED_12(p) = 0; \
                  *UL_LO_12(p) = 0;

#define ISZERO_12(p) ((*UL_HI_12(p)&0x7fffffff) == 0 && \
                      *UL_MED_12(p) == 0 && \
                      *UL_LO_12(p) == 0 )

#define PUT_INF_LD(p,sign) \
                  *U_EXP_LD(p) = (sign)?0xffff:0x7fff; \
                  *UL_MANHI_LD(p) = 0x8000; \
                  *UL_MANLO_LD(p) = 0;

#define PUT_ZERO_LD(p) *U_EXP_LD(p) = 0; \
                  *UL_MANHI_LD(p) = 0; \
                  *UL_MANLO_LD(p) = 0;

#define ISZERO_LD(p) ((*U_EXP_LD(p)&0x7fff) == 0 && \
                      *UL_MANHI_LD(p) == 0 && \
                      *UL_MANLO_LD(p) == 0 )


/*********************************************************
 *
 *   Function Prototypes
 *
 *********************************************************/

/* from mantold.c */
void _CALLTYPE5 __mtold12(char  *manptr, unsigned manlen,_LDBL12 *ld12);
int  _CALLTYPE5 __addl(u_long x, u_long y, u_long  *sum);
void _CALLTYPE5 __shl_12(_LDBL12  *ld12);
void _CALLTYPE5 __shr_12(_LDBL12  *ld12);
void _CALLTYPE5 __add_12(_LDBL12  *x, _LDBL12  *y);

/* from tenpow.c */
void _CALLTYPE5 __multtenpow12(_LDBL12  *pld12,int pow, unsigned mult12);
void _CALLTYPE5 __ld12mul(_LDBL12  *px, _LDBL12  *py);

/* from strgtold.c */
unsigned int __strgtold12(_LDBL12 *pld12,
            const char * *p_end_ptr,
            const char * str,
            int mult12,
            int scale,
            int decpt,
            int implicit_E);

unsigned _CALLTYPE5 __STRINGTOLD(_LDOUBLE *pld,
            const char  * *p_end_ptr,
            const char  *str,
            int mult12);


/* from x10fout.c */
/* this is defined as void in convert.h
 * After porting the asm files to c, we need a return value for
 * i10_output, that used to reside in reg. ax
 */
int _CALLTYPE5  $I10_OUTPUT(_LDOUBLE ld, int ndigits,
                    unsigned output_flags, FOS  *fos);


/* for cvt.c and fltused.c */
/* The following functions are #defined as macros in fltintrn.h */
#undef _cfltcvt
#undef _cropzeros
#undef _fassign
#undef _forcdecpt
#undef _positive

void __cdecl _cfltcvt(double *arg, char *buffer,
                         int format, int precision,
                         int caps);
void __cdecl _cropzeros(char *buf);
void __cdecl _fassign(int flag, char  *argument, char *number);
void __cdecl _forcdecpt(char *buf);
int __cdecl _positive(double *arg);

/* from intrncvt.c */
void _atodbl(DOUBLE *d, char *str);
void _atoldbl(_LDOUBLE *ld, char *str);
void _atoflt(FLOAT *f, char *str);
INTRNCVT_STATUS _ld12tod(_LDBL12 *ifp, DOUBLE *d);
INTRNCVT_STATUS _ld12tof(_LDBL12 *ifp, FLOAT *f);
INTRNCVT_STATUS _ld12told(_LDBL12 *ifp, _LDOUBLE *ld);

#ifdef __cplusplus
}
#endif

#define _INC_CV
#endif  /* _INC_CV */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\exp.c ===
/***
*exp.c - exponential
*
*       Copyright (c) 1991-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*   Compute exp(x)
*
*Revision History:
*        8-15-91  GDP   written
*       12-21-91  GDP   support IEEE exceptions
*       02-03-92  GDP   added _exphlp for use by exp, sinh, and cosh
*       02-06-95  JWM   Mac merge
*       10-07-97  RDL   Added IA64.
*
*******************************************************************************/

#include <math.h>
#include <trans.h>

#if defined(_M_IA64)
#pragma function(exp)
#endif

double _exphlp(double, int *);

/*
 * Thresholds for over/underflow that results in an adjusted value
 * too big/small to be represented as a double.
 * OVFX: ln(XMAX * 2^IEEE_ADJ)
 * UFLX: ln(XIN * 2^(-IEEE_ADJ)
 */

static _dbl const ovfx = {SET_DBL(0x40862e42, 0xfefa39f8)}; /*  709.782712893385 */
static _dbl const uflx = {SET_DBL(0xc086232b, 0xdd7abcda)};     /* -708.396418532265 */

#define OVFX    ovfx.dbl
#define UFLX    uflx.dbl


static double const  EPS    =  5.16987882845642297e-26;   /* 2^(-53) / 2 */
static double const  LN2INV =  1.442695040889634074;      /* 1/ln(2) */
static double const  C1     =  0.693359375000000000;
static double const  C2     = -2.1219444005469058277e-4;

/* constants for the rational approximation */
static double const p0 = 0.249999999999999993e+0;
static double const p1 = 0.694360001511792852e-2;
static double const p2 = 0.165203300268279130e-4;
static double const q0 = 0.500000000000000000e+0;
static double const q1 = 0.555538666969001188e-1;
static double const q2 = 0.495862884905441294e-3;

#define P(z)  ( (p2 * (z) + p1) * (z) + p0 )
#define Q(z)  ( (q2 * (z) + q1) * (z) + q0 )

/***
*double exp(double x) - exponential
*
*Purpose:
*   Compute the exponential of a number.
*   The algorithm (reduction / rational approximation) is
*   taken from Cody & Waite.
*
*Entry:
*
*Exit:
*
*Exceptions: O, U, P, I
*
*******************************************************************************/

double exp (double x)
{
    uintptr_t savedcw;
    int newexp;
    double result;

    /* save user fp control word */
    savedcw = _maskfp();

    if (IS_D_SPECIAL(x)){
        switch (_sptype(x)) {
        case T_PINF:
            RETURN(savedcw,x);
        case T_NINF:
            RETURN(savedcw,0.0);
        case T_QNAN:
            return _handle_qnan1(OP_EXP, x, savedcw);
        default: //T_SNAN
            return _except1(FP_I, OP_EXP, x, _s2qnan(x), savedcw);
        }
    }

    if (x == 0.0) {
        RETURN(savedcw, 1.0);
    }

    if (x > OVFX) {

        // even after scaling the exponent of the result,
        // it is still too large.
        // Deliver infinity to the trap handler

        return _except1(FP_O | FP_P, OP_EXP, x, D_INF, savedcw);
    }

    if (x < UFLX) {

        // even after scaling the exponent of the result,
        // it is still too small.
        // Deliver 0 to the trap handler

        return _except1(FP_U | FP_P, OP_EXP, x, 0.0, savedcw);
    }

    if (ABS(x) < EPS) {
        result = 1.0;
    }

    else {
        result = _exphlp(x, &newexp);
        if (newexp > MAXEXP) {
            result = _set_exp(result, newexp-IEEE_ADJUST);
            return _except1(FP_O | FP_P, OP_EXP, x, result, savedcw);
        }
        else if (newexp < MINEXP) {
            result = _set_exp(result, newexp+IEEE_ADJUST);
            return _except1(FP_U | FP_P, OP_EXP, x, result, savedcw);
        }
        else
            result = _set_exp(result, newexp);
    }

    RETURN_INEXACT1(OP_EXP, x, result, savedcw);
}




/***
*double _exphlp(double x, int * pnewexp) - exp helper routine
*
*Purpose:
*   Provide the mantissa and  the exponent of e^x
*
*Entry:
*   x : a (non special) double precision number
*
*Exit:
*   *newexp: the exponent of e^x
*   return value: the mantissa m of e^x scaled by a factor
*                 (the value of this factor has no significance.
*                  The mantissa can be obtained with _set_exp(m, 0).
*
*   _set_exp(m, *pnewexp) may be used for constructing the final
*   result, if it is within the representable range.
*
*Exceptions:
*   No exceptions are raised by this function
*
*******************************************************************************/



double _exphlp(double x, int * pnewexp)
{

    double xn;
    double g,z,gpz,qz,rg;
    int n;

    xn = _frnd(x * LN2INV);
    n = (int) xn;

    /* assume guard digit is present */
    g = (x - xn * C1) - xn * C2;
    z = g*g;
    gpz = g * P(z);
    qz = Q(z);
    rg = 0.5 + gpz/(qz-gpz);

    n++;

    *pnewexp = _get_exp(rg) + n;
    return rg;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\ceil.c ===
/***
*ceil.c - ceiling
*
*       Copyright (c) 1991-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*
*Revision History:
*        8-24-91  GDP   written
*        1-09-92  GDP   support IEEE exceptions
*        6-23-92  GDP   ceil(INF) now returns INF (NCEG spec)
*       02-06-95  JWM   Mac merge
*       01-26-01  PML   Pentium4 merge
*
*******************************************************************************/
#include <math.h>
#include <trans.h>

extern double _frnd(double);


/***
*double ceil(double x) - ceiling
*
*Purpose:
*   Return a double representing the smallest integer that is
*   greater than or equal to x
*
*Entry:
*
*Exit:
*
*Exceptions:
*    P, I
*******************************************************************************/
static uintptr_t newcw = (ICW & ~IMCW_RC) | (IRC_UP & IMCW_RC);



#if !defined(_M_IX86)
double ceil(double x)
#else
double _ceil_default(double x)
#endif
{
    uintptr_t savedcw;
    double result;

    /* save user fp control word */
    savedcw = _ctrlfp(newcw,IMCW);      /* round up */

    /* check for infinity or NAN */
    if (IS_D_SPECIAL(x)){
        switch (_sptype(x)) {
        case T_PINF:
        case T_NINF:
            RETURN(savedcw,x);
        case T_QNAN:
            return _handle_qnan1(OP_CEIL, x, savedcw);
        default: //T_SNAN
            return _except1(FP_I, OP_CEIL, x, _s2qnan(x), savedcw);
        }
    }

    result = _frnd(x); /* round according to the current rounding mode */

    // In general, the Precision Exception should be raised if
    // _frnd reports a precision loss. In order to detect this with
    // masked exceptions, the status word needs to be cleared.
    // However, we want to avoid this, since the 387 instruction
    // set does not provide an fast way to restore the status word

    if (result == x) {
        RETURN(savedcw,result);
    }
    else {
        RETURN_INEXACT1(OP_CEIL, x, result, savedcw);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\fmod.c ===
/***
*fmod.c - floating point remainder
*
*       Copyright (c) 1991-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*
*Revision History:
*        8-24-91  GDP   written
*        1-13-92  GDP   support IEEE exceptions
*        3-04-92  GDP   complete rewrite for improved accuracy
*        3-16-92  GDP   restore cw properly, do not raise Inexact exception
*       06-23-92  GDP   support NCEG special return values (signed 0's etc)
*       02-06-95  JWM   Mac merge
*       10-07-97  RDL   Added IA64.
*
*******************************************************************************/

#include <math.h>
#include <trans.h>

#if defined(_M_IA64)
#pragma function(fmod)
#endif

/***
*double fmod(double x, double y)
*
*Purpose:
*   Return f, s.t. x = i*y + f, where i is an integer, f has the same
*   sign as x, and |f| < |y|
*
*Entry:
*
*Exit:
*
*Exceptions:
*   I,P
*******************************************************************************/
#define SCALE  53

double fmod(double x, double y)
{
    uintptr_t savedcw;
    int neg=0;
    int denorm=0;
    double d,tx,ty,fx,fy;
    int nx, ny, nexp;



    /* save user fp control word */
    savedcw = _maskfp();

    /* check for infinity or NAN */
    if (IS_D_SPECIAL(y) || IS_D_SPECIAL(x)){
        if (IS_D_SNAN(y) || IS_D_SNAN(x)){
            return _except2(FP_I,OP_FMOD,x,y,_d_snan2(x,y),savedcw);
        }
        if (IS_D_QNAN(y) || IS_D_QNAN(x)){
            return _handle_qnan2(OP_FMOD,x,y,savedcw);
        }

        if (IS_D_INF(x) || IS_D_MINF(x)) {
            return _except2(FP_I,OP_FMOD,x,y,QNAN_FMOD,savedcw);
        }

        RETURN(savedcw, x);
    }


    if (y == 0) {
        return _except2(FP_I,OP_FMOD,x,y,QNAN_FMOD,savedcw);
    }

    if (x == 0) {
        RETURN(savedcw, x);      // NCEG spec
    }


    if (x < 0) {
        tx = -x;
        neg = 1;
    }
    else {
        tx = x;
    }

    ty = ABS(y);


    while (tx >= ty) {
        fx = _decomp(tx, &nx);
        fy = _decomp(ty, &ny);

        if (nx < MINEXP) {
            // tx is a denormalized number
            denorm = 1;
            nx += SCALE;
            ny += SCALE;
            tx = _set_exp(fx, nx);
            ty = _set_exp(fy, ny);
        }


        if (fx >= fy) {
            nexp = nx ;
        }
        else {
            nexp = nx - 1;
        }
        d = _set_exp(fy, nexp);
        tx -= d;
    }

    if (denorm) {

        //
        // raise only FP_U exception
        //

        return _except2(FP_U,
                        OP_FMOD,
                        x,
                        y,
                        _add_exp(tx, IEEE_ADJUST-SCALE),
                        savedcw);
    }

    if (neg) {
        tx = -tx;
    }

    RETURN(savedcw,tx);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\frexp.c ===
/***
*frexp.c - get mantissa and exponent of a floating point number
*
*       Copyright (c) 1991-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*
*Revision History:
*        8-24-91  GDP   written
*        1-13-92  GDP   support IEEE exceptions
*       02-06-95  JWM   Mac merge
*
*******************************************************************************/
#include <math.h>
#include <trans.h>

/***
*double frexp(double x, double *expptr)
*
*Purpose:
*   The nomalized fraction f is returned: .5<=f<1
*   The exponent is stored in the object pointed by expptr
*
*Entry:
*
*Exit:
*
*Exceptions:
*    NAN: domain error
*
*******************************************************************************/
double frexp(double x, int *expptr)
{
    uintptr_t savedcw;
    double man;

    /* save user fp control word */
    savedcw = _maskfp();

    /* check for infinity or NAN */
    if (IS_D_SPECIAL(x)){
        *expptr = INT_NAN;
        switch (_sptype(x)) {
        case T_PINF:
        case T_NINF:
            return _except1(FP_I, OP_FREXP, x, QNAN_FREXP, savedcw);
        case T_QNAN:
            return _handle_qnan1(OP_FREXP, x, savedcw);
        default: //T_SNAN
            return _except1(FP_I, OP_FREXP, x, _s2qnan(x), savedcw);
        }
    }

    man = _decomp(x, expptr);
    RETURN(savedcw,man);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\floor.c ===
/***
*floor.c - floor
*
*       Copyright (c) 1991-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*
*Revision History:
*        8-24-91  GDP   written
*        1-09-92  GDP   support IEEE exceptions
*        6-23-92  GDP   floor(INF) now returns INF (NCEG spec)
*       02-06-95  JWM   Mac merge
*       01-26-01  PML   Pentium4 merge
*
*******************************************************************************/
#include <math.h>
#include <trans.h>

extern double _frnd(double);

/***
*double floor(double x) - floor
*
*Purpose:
*   Return a double representing the largest integer that is
*   less than or equal to x
*
*Entry:
*
*Exit:
*
*Exceptions:
*    I, P
*******************************************************************************/
static unsigned int newcw = (ICW & ~IMCW_RC) | (IRC_DOWN & IMCW_RC);


#if !defined(_M_IX86)
double floor(double x)
#else
double _floor_default(double x)
#endif
{
    uintptr_t savedcw;
    double result;

    /* save user fp control word */
    savedcw = _ctrlfp(newcw,IMCW);      /* round down */

    /* check for infinity or NAN */
    if (IS_D_SPECIAL(x)){
        switch (_sptype(x)) {
        case T_PINF:
        case T_NINF:
            RETURN(savedcw,x);
        case T_QNAN:
            return _handle_qnan1(OP_FLOOR, x, savedcw);
        default: //T_SNAN
            return _except1(FP_I, OP_FLOOR, x, _s2qnan(x), savedcw);
        }
    }


    result = _frnd(x); /* round according to the current rounding mode */

    // In general, the Precision Exception should be raised if
    // _frnd reports a precision loss. In order to detect this with
    // masked exceptions, the status word needs to be cleared.
    // However, we want to avoid this, since the 387 instruction
    // set does not provide an fast way to restore the status word

    if (result == x) {
        RETURN(savedcw,result);
    }
    else {
        RETURN_INEXACT1(OP_FLOOR, x, result, savedcw);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\fpexcept.c ===
/***
*fpexcept.c - floating point exception handling
*
*       Copyright (c) 1991-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*
*Revision History:
*       08-24-91  GDP   written
*       09-26-91  GDP   changed DOMAIN error handling
*       10-10-91  GDP   use fp addition for propagating NaNs
*       01-14-92  GDP   IEEE exception support
*       03-20-92  GDP   major changes, reorganized code
*       03-31-92  GDP   new interface, use internal fp control functions
*       07-16-93  SRW   ALPHA Merge
*       11-18-93  GJF   Merged in NT SDK version. Cleaned up preprocessing
*                       conditional: replaced #if _NTSUBSET_ with #ifdef
*                       _NTSUBSET_, i386 with _M_IX86, MIPS with _M_MRX000,
*                       _ALPHA_ with _M_ALPHA.
*       09-01-94  SKS   Change include file from <nt.h> to <windows.h>
*       09-05-94  SKS   Change another #ifdef i386 to #ifdef _M_IX86
*       10-02-94  BWT   PPC merge and change NTSUBSET includes to use nt.h
*       02-19-95  BWT   Define _KERNEL32_ before including windows.h for _NTSUBSET_
*                       build (otherwise declspec(dllimport) will be on for
*                       RaiseException)
*       03-29-95  BWT   Add casts to fix warnings.
*       05-10-96  BWT   POSIX fix
*       06-21-00  GB    Add OP_LOGB in _get_fname.
*       07-15-01  PML   Remove all ALPHA, MIPS, and PPC code
*
*******************************************************************************/

#if defined(_NTSUBSET_) || defined (_POSIX_)
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#define _KERNEL32_          // Don't Export RaiseException
#endif  // _NTSUBSET_


#include <trans.h>
#include <errno.h>
#include <math.h>
#include <windows.h>

#ifdef  _NTSUBSET_
VOID
WINAPI
RaiseException(
    DWORD dwExceptionCode,
    DWORD dwExceptionFlags,
    DWORD nNumberOfArguments,
    CONST DWORD_PTR *lpArguments
    )
{
    EXCEPTION_RECORD ExceptionRecord;
    ULONG n;
    PULONG_PTR s,d;
    ExceptionRecord.ExceptionCode = (DWORD)dwExceptionCode;
    ExceptionRecord.ExceptionFlags = dwExceptionFlags & EXCEPTION_NONCONTINUABLE;
    ExceptionRecord.ExceptionRecord = NULL;
    ExceptionRecord.ExceptionAddress = (PVOID)RaiseException;
    if ( ARGUMENT_PRESENT(lpArguments) ) {
        n =  nNumberOfArguments;
        if ( n > EXCEPTION_MAXIMUM_PARAMETERS ) {
            n = EXCEPTION_MAXIMUM_PARAMETERS;
            }
        ExceptionRecord.NumberParameters = n;
        s = (PULONG_PTR)lpArguments;
        d = ExceptionRecord.ExceptionInformation;
        while(n--){
            *d++ = *s++;
            }
        }
    else {
        ExceptionRecord.NumberParameters = 0;
        }
    RtlRaiseException(&ExceptionRecord);

}
#endif  // _NTSUBSET_


//
// copy a double without generating floating point instructions
// (avoid invalid operation on x87)
//

#define COPY_DOUBLE(pdest, psrc) \
      ( *(unsigned int *)pdest = *(unsigned int *)psrc,   \
        *((unsigned int *)pdest+1) = *((unsigned int *)psrc+1) )



//
// _matherr_flag is a communal variable. It is equal to zero
// if the user has redefined matherr(). Otherwise it has a
// non zero value. The default matherr routine does nothing
// and returns 0.
//

int _matherr_flag;

//
// a routine for artificially setting the fp status bits in order
// to signal a software generated masked fp exception.
//

extern void _set_statfp(uintptr_t);


void _raise_exc(_FPIEEE_RECORD *prec,uintptr_t *pcw,
    int flags, int opcode, double *parg1, double *presult);

double _umatherr(int type, unsigned int opcode,
                 double arg1, double arg2, double presult,
                 uintptr_t cw);

static char *_get_fname(unsigned int opcode);

/***
* _handle_qnan1, _handle_qnan2 - handle quiet NaNs as function arguments
*
*Purpose:
*   Do all necessary work for handling the case where the argument
*   or one of the arguments of a floating point function is a quiet NaN
*
*Entry:
*   unsigned int opcode: The operation code of the fp function
*   double x: the fp function argument
*   double y: the fp function second argument (_handle_qnan2 only)
*   uintptr_t savedcw: the user's control word
*
*Exit:
*   restore the user's control word,  and
*   return the suggested return value for the fp function
*
*Exceptions:
*
*******************************************************************************/

double _handle_qnan1(unsigned int opcode,
                     double x,
                     uintptr_t savedcw)
{
    if (! _matherr_flag) {

        //
        // QNaN arguments are treated as domain errors
        // invoke the user's matherr routine
        // _umatherr will take care of restoring the
        // user's control word
        //

        return _umatherr(_DOMAIN,opcode,x,0.0,x,savedcw);
    }
    else {
        errno = EDOM;
        _rstorfp(savedcw);
        return x;
    }
}


double _handle_qnan2(unsigned int opcode,
                     double x,
                     double y,
                     uintptr_t savedcw)
{
    double result;

    //
    // NaN propagation should be handled by the underlying fp h/w
    //

    result = x+y;

    if (! _matherr_flag) {
        return _umatherr(_DOMAIN,opcode,x,y,result,savedcw);
    }
    else {
        errno = EDOM;
        _rstorfp(savedcw);
        return result;
    }
}



/***
* _except1 - exception handling shell for fp functions with one argument
*
*Purpose:
*
*Entry:
*   int flags:  the exception flags
*   int opcode: the operation code of the fp function that faulted
*   double arg: the argument of the fp function
*   double result: default result
*   uintptr_t cw: user's fp control word
*
*Exit:
*   restore user's fp control word
*   and return the (possibly modified) result of the fp function
*
*Exceptions:
*
*******************************************************************************/

double _except1(int flags,
                int opcode,
                double arg,
                double result,
                uintptr_t cw)
{
    int type;

    if (_handle_exc(flags, &result, cw) == 0) {

        //
        // At this point _handle_exception has failed to deal
        // with the error
        // An IEEE exception should be raised
        //

        _FPIEEE_RECORD rec;

        // The rec structure will be filled in by _raise_exc,
        // except for the Operand2 information

        rec.Operand2.OperandValid = 0;
        _raise_exc(&rec, &cw, flags, opcode, &arg, &result);
    }


    //
    // At this point we have either the masked response of the
    // exception, or a value supplied by the user's IEEE exception
    // handler. The _matherr mechanism is supported for backward
    // compatibility.
    //

    type = _errcode(flags);

    // Inexact result fp exception does not have a matherr counterpart;
    // in that case type is 0.

    if (! _matherr_flag && type) {
        return _umatherr(type, opcode, arg, 0.0, result, cw);
    }
    else {
        _set_errno(type);
    }

    RETURN(cw,result);
}



/***
* _except2 - exception handling shell for fp functions with two arguments
*
*Purpose:
*
*Entry:
*   int flags:  the exception flags
*   int opcode: the operation code of the fp function that faulted
*   double arg1: the first argument of the fp function
*   double arg2: the second argument of the fp function
*   double result: default result
*   unsigned int cw: user's fp control word
*
*Exit:
*   restore user's fp control word
*   and return the (possibly modified) result of the fp function
*
*Exceptions:
*
*******************************************************************************/

double _except2(int flags,
                int opcode,
                double arg1,
                double arg2,
                double result,
                uintptr_t cw)
{
    int type;

    if (_handle_exc(flags, &result, cw) == 0) {

        //
        // trap should be taken
        //

        _FPIEEE_RECORD rec;

        //
        // fill in operand2 info. The rest of rec will be
        // filled in by _raise_exc
        //

        rec.Operand2.OperandValid = 1;
        rec.Operand2.Format = _FpFormatFp64;
        rec.Operand2.Value.Fp64Value = arg2;

        _raise_exc(&rec, &cw, flags, opcode, &arg1, &result);

    }

    type = _errcode(flags);

    if (! _matherr_flag && type) {
        return _umatherr(type, opcode, arg1, arg2, result, cw);
    }
    else {
        _set_errno(type);
    }

    RETURN(cw,result);
}



/***
* _raise_exc - raise fp IEEE exception
*
*Purpose:
*   fill in an fp IEEE record struct and raise a fp exception
*
*
*Entry / Exit:
*   IN _FPIEEE_RECORD prec   pointer to an IEEE record
*   IN OUT unsigned int *pcw     pointer to user's fp control word
*   IN int flags,       exception flags
*   IN int opcode,      fp operation code
*   IN double *parg1,        pointer to first argument
*   IN double *presult)      pointer to result
*
*Exceptions:
*
*******************************************************************************/

void _raise_exc( _FPIEEE_RECORD *prec,
                 uintptr_t *pcw,
                 int flags,
                 int opcode,
                 double *parg1,
                 double *presult)
{
    DWORD exc_code;
    uintptr_t sw;

    //
    // reset all control bits
    //

    *(int *)&(prec->Cause) = 0;
    *(int *)&(prec->Enable) = 0;
    *(int *)&(prec->Status) = 0;

    //
    // Precision exception may only coincide with overflow
    // or underflow. If this is the case, overflow (or
    // underflow) take priority over precision exception.
    // The order of checks is from the least important
    // to the most important exception
    //

    if (flags & FP_P) {
        exc_code = (DWORD) STATUS_FLOAT_INEXACT_RESULT;
        prec->Cause.Inexact = 1;
    }
    if (flags & FP_U) {
        exc_code = (DWORD) STATUS_FLOAT_UNDERFLOW;
        prec->Cause.Underflow = 1;
    }
    if (flags & FP_O) {
        exc_code = (DWORD) STATUS_FLOAT_OVERFLOW;
        prec->Cause.Overflow = 1;
    }
    if (flags & FP_Z) {
        exc_code = (DWORD) STATUS_FLOAT_DIVIDE_BY_ZERO;
        prec->Cause.ZeroDivide = 1;
    }
    if (flags & FP_I) {
        exc_code = (DWORD) STATUS_FLOAT_INVALID_OPERATION;
        prec->Cause.InvalidOperation = 1;
    }


    //
    // Set exception enable bits
    //

    prec->Enable.InvalidOperation = (*pcw & IEM_INVALID) ? 0 : 1;
    prec->Enable.ZeroDivide = (*pcw & IEM_ZERODIVIDE) ? 0 : 1;
    prec->Enable.Overflow = (*pcw & IEM_OVERFLOW) ? 0 : 1;
    prec->Enable.Underflow = (*pcw & IEM_UNDERFLOW) ? 0 : 1;
    prec->Enable.Inexact = (*pcw & IEM_INEXACT) ? 0 : 1;


    //
    // Set status bits
    //

    sw = _statfp();


    if (sw & ISW_INVALID) {
        prec->Status.InvalidOperation = 1;
    }
    if (sw & ISW_ZERODIVIDE) {
        prec->Status.ZeroDivide = 1;
    }
    if (sw & ISW_OVERFLOW) {
        prec->Status.Overflow = 1;
    }
    if (sw & ISW_UNDERFLOW) {
        prec->Status.Underflow = 1;
    }
    if (sw & ISW_INEXACT) {
        prec->Status.Inexact = 1;
    }


    switch (*pcw & IMCW_RC) {
    case IRC_CHOP:
        prec->RoundingMode = _FpRoundChopped;
        break;
    case IRC_UP:
        prec->RoundingMode = _FpRoundPlusInfinity;
        break;
    case IRC_DOWN:
        prec->RoundingMode = _FpRoundMinusInfinity;
        break;
    case IRC_NEAR:
        prec->RoundingMode = _FpRoundNearest;
        break;
    }

#ifdef _M_IX86

    switch (*pcw & IMCW_PC) {
    case IPC_64:
        prec->Precision = _FpPrecisionFull;
        break;
    case IPC_53:
        prec->Precision = _FpPrecision53;
        break;
    case IPC_24:
        prec->Precision = _FpPrecision24;
        break;
    }

#endif

    prec->Operation = opcode;

    prec->Operand1.OperandValid = 1;
    prec->Operand1.Format = _FpFormatFp64;
    prec->Operand1.Value.Fp64Value = *parg1;

    prec->Result.OperandValid = 1;
    prec->Result.Format = _FpFormatFp64;
    prec->Result.Value.Fp64Value = *presult;

    //
    // By convention software exceptions use the first exception
    // parameter in order to pass a pointer to the _FPIEEE_RECORD
    // structure.
    //

    _clrfp();

    RaiseException(exc_code,0,1,(uintptr_t *)&prec);


    //
    // user's trap handler may have changed either the fp environment
    // or the result
    //

    //
    // Update exception mask
    //

    if (prec->Enable.InvalidOperation)
        (*pcw) &= ~IEM_INVALID;
    if (prec->Enable.ZeroDivide)
        (*pcw) &= ~IEM_ZERODIVIDE;
    if (prec->Enable.Overflow)
        (*pcw) &= ~IEM_OVERFLOW;
    if (prec->Enable.Underflow)
        (*pcw) &= ~IEM_UNDERFLOW;
    if (prec->Enable.Inexact)
        (*pcw) &= ~IEM_INEXACT;

    //
    // Update Rounding mode
    //

    switch (prec->RoundingMode) {
    case _FpRoundChopped:
         *pcw = *pcw & ~IMCW_RC | IRC_CHOP;
         break;
    case _FpRoundPlusInfinity:
         *pcw = *pcw & ~IMCW_RC | IRC_UP;
         break;
    case _FpRoundMinusInfinity:
         *pcw = *pcw & ~IMCW_RC | IRC_DOWN;
         break;
    case _FpRoundNearest:
         *pcw = *pcw & ~IMCW_RC | IRC_NEAR;
         break;
    }


#ifdef _M_IX86

    //
    // Update Precision Control
    //

    switch (prec->Precision) {
    case _FpPrecisionFull:
         *pcw = *pcw & ~IMCW_RC | IPC_64;
         break;
    case _FpPrecision53:
         *pcw = *pcw & ~IMCW_RC | IPC_53;
         break;
    case _FpPrecision24:
         *pcw = *pcw & ~IMCW_RC | IPC_24;
         break;
    }

#endif

    //
    // Update result
    //

    *presult = prec->Result.Value.Fp64Value;
}



/***
* _handle_exc - produce masked response for IEEE fp exception
*
*Purpose:
*
*Entry:
*   unsigned int flags      the exception flags
*   double *presult         the default result
*   unsigned int cw         user's fp control word
*
*Exit:
*   returns 1 on successful handling, 0 on failure
*   On success, *presult becomes the masked response
*
*Exceptions:
*
*******************************************************************************/

int _handle_exc(unsigned int flags, double * presult, uintptr_t cw)
{
    //
    // flags_p is useful for deciding whether there are still unhandled
    // exceptions in case multiple exceptions have occurred
    //

    int flags_p = flags & (FP_I | FP_Z | FP_O | FP_U | FP_P);

    if (flags & FP_I && cw & IEM_INVALID) {

        //
        // Masked response for invalid operation
        //

        _set_statfp(ISW_INVALID);
        flags_p &= ~FP_I;
    }

    else if (flags & FP_Z && cw & IEM_ZERODIVIDE) {

        //
        // Masked response for Division by zero
        // result should already have the proper value
        //

        _set_statfp( ISW_ZERODIVIDE);
        flags_p &= ~FP_Z;
    }

    else if (flags & FP_O && cw & IEM_OVERFLOW) {

        //
        // Masked response for Overflow
        //

        _set_statfp(ISW_OVERFLOW);
        switch (cw & IMCW_RC) {
        case IRC_NEAR:
            *presult = *presult > 0.0 ? D_INF : -D_INF;
            break;
        case IRC_UP:
            *presult = *presult > 0.0 ? D_INF : -D_MAX;
            break;
        case IRC_DOWN:
            *presult = *presult > 0.0 ? D_MAX : -D_INF;
            break;
        case IRC_CHOP:
            *presult = *presult > 0.0 ? D_MAX : -D_MAX;
            break;
        }

        flags_p &= ~FP_O;
    }

    else if (flags & FP_U && cw & IEM_UNDERFLOW) {

        //
        // Masked response for Underflow:
        // According to the IEEE standard, when the underflow trap is not
        // enabled, underflow shall be signaled only when both tininess
        // and loss of accuracy have been detected
        //

        int aloss=0;    // loss of accuracy flag

        if (flags & FP_P) {
            aloss = 1;
        }

        //
        // a zero value in the result denotes
        // that even after ieee scaling, the exponent
        // was too small.
        // in this case the masked response is also
        // zero (sign is preserved)
        //

        if (*presult != 0.0) {
            double result;
            int expn, newexp;

            result = _decomp(*presult, &expn);
            newexp = expn - IEEE_ADJUST;

            if (newexp < MINEXP - 53) {
                result *= 0.0;          // produce a signed zero
                aloss = 1;
            }
            else {
                int neg = result < 0;       // save sign

                //
                // denormalize result
                //

                (*D_EXP(result)) &= 0x000f; /* clear exponent field */
                (*D_EXP(result)) |= 0x0010; /* set hidden bit */

                for (;newexp<MINEXP;newexp++) {
                    if (*D_LO(result) & 0x1 && !aloss) {
                        aloss = 1;
                    }

                    /* shift mantissa to the right */
                    (*D_LO(result)) >>= 1;
                    if (*D_HI(result) & 0x1) {
                        (*D_LO(result)) |= 0x80000000;
                    }
                    (*D_HI(result)) >>= 1;
                }
                if (neg) {
                    result = -result;       // restore sign
                }
            }

            *presult = result;
        }
        else {
            aloss = 1;
        }

        if (aloss) {
            _set_statfp(ISW_UNDERFLOW);
        }

        flags_p &= ~FP_U;
    }


    //
    // Separate check for precision exception
    // (may coexist with overflow or underflow)
    //

    if (flags & FP_P && cw & IEM_INEXACT) {

        //
        // Masked response for inexact result
        //

        _set_statfp(ISW_INEXACT);
        flags_p &= ~FP_P;
    }

    return flags_p ? 0: 1;
}



/***
* _umatherr - call user's matherr routine
*
*Purpose:
*   call user's matherr routine and set errno if appropriate
*
*
*Entry:
*     int type              type of excpetion
*     unsigned int opcode   fp function that caused the exception
*     double arg1           first argument of the fp function
*     double arg2           second argument of the fp function
*     double retval         return value of the fp function
*     unsigned int cw       user's fp control word
*
*Exit:
*     fp control word       becomes the user's fp cw
*     errno                 modified if user's matherr returns 0
*     return value          the retval entered by the user in
*                           the _exception matherr struct
*
*Exceptions:
*
*******************************************************************************/

double _umatherr(
              int type,
              unsigned int opcode,
              double arg1,
              double arg2,
              double retval,
              uintptr_t cw
              )
{
    struct _exception exc;

    //
    // call matherr only if the name of the function
    // is registered in the table, i.e., only if exc.name is valid
    //

    if (exc.name = _get_fname(opcode)) {
        exc.type = type;

        COPY_DOUBLE(&exc.arg1,&arg1);
        COPY_DOUBLE(&exc.arg2,&arg2);
        COPY_DOUBLE(&exc.retval,&retval);

        _rstorfp(cw);

        if (_matherr(&exc) == 0) {
            _set_errno(type);
        }
        return  exc.retval;
    }
    else {

        //
        // treat this case as if matherr returned 0
        //

        _rstorfp(cw);
        _set_errno(type);
        return retval;
    }

}



/***
* _set_errno - set errno
*
*Purpose:
*   set correct error value for errno
*
*Entry:
*   int matherrtype:    the type of math error
*
*Exit:
*   modifies errno
*
*Exceptions:
*
*******************************************************************************/

void _set_errno(int matherrtype)
{
    switch(matherrtype) {
    case _DOMAIN:
        errno = EDOM;
        break;
    case _OVERFLOW:
    case _SING:
        errno = ERANGE;
        break;
    }
}



/***
* _get_fname -  get function name
*
*Purpose:
*  returns the _matherr function name that corresponds to a
*  floating point opcode
*
*Entry:
*  _FP_OPERATION_CODE opcode
*
*Exit:
*   returns a pointer to a string
*
*Exceptions:
*
*******************************************************************************/
#define OP_NUM  29   /* number of fp operations */

static char *_get_fname(unsigned int opcode)
{

    static struct {
        unsigned int opcode;
        char *name;
    } _names[OP_NUM] = {
        { OP_EXP,   "exp" },
        { OP_POW,   "pow" },
        { OP_LOG,   "log" },
        { OP_LOG10, "log10"},
        { OP_SINH,  "sinh"},
        { OP_COSH,  "cosh"},
        { OP_TANH,  "tanh"},
        { OP_ASIN,  "asin"},
        { OP_ACOS,  "acos"},
        { OP_ATAN,  "atan"},
        { OP_ATAN2, "atan2"},
        { OP_SQRT,  "sqrt"},
        { OP_SIN,   "sin"},
        { OP_COS,   "cos"},
        { OP_TAN,   "tan"},
        { OP_CEIL,  "ceil"},
        { OP_FLOOR, "floor"},
        { OP_ABS,   "fabs"},
        { OP_MODF,  "modf"},
        { OP_LDEXP, "ldexp"},
        { OP_CABS,  "_cabs"},
        { OP_HYPOT, "_hypot"},
        { OP_FMOD,  "fmod"},
        { OP_FREXP, "frexp"},
        { OP_Y0,    "_y0"},
        { OP_Y1,    "_y1"},
        { OP_YN,    "_yn"},
        { OP_LOGB,  "_logb"},
        { OP_NEXTAFTER, "_nextafter"}
    };

    int i;
    for (i=0;i<OP_NUM;i++) {
        if (_names[i].opcode == opcode)
            return _names[i].name;
    }
    return (char *)0;
}



/***
* _errcode - get _matherr error code
*
*Purpose:
*   returns matherr type that corresponds to exception flags
*
*Entry:
*   flags: exception flags
*
*Exit:
*   returns matherr type
*
*Exceptions:
*
*******************************************************************************/

int _errcode(unsigned int flags)
{
    unsigned int errcode;

    if (flags & FP_TLOSS) {
        errcode = _TLOSS;
    }
    else if (flags & FP_I) {
        errcode = _DOMAIN;
    }
    else if (flags & FP_Z) {
        errcode = _SING;
    }
    else if (flags & FP_O) {
        errcode = _OVERFLOW;
    }
    else if (flags & FP_U) {
        errcode = _UNDERFLOW;
    }
    else {

        // FP_P

        errcode = 0;
    }
    return errcode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\fabs.c ===
/***
*fabs.c - absolute value of a floating point number
*
*       Copyright (c) 1991-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*
*Revision History:
*        8-24-91  GDP   written
*       12-10-91  GDP   Domain error for NAN, use fp negation
*        1-13-91  GDP   support IEEE exceptions
*        6-23-92  GDP   fabs(-0) is now +0 (NCEG spec)
*       02-06-95  JWM   Mac merge
*       10-07-97  RDL   Added IA64.
*       05-17-99  PML   Remove all Macintosh support.
*       07-15-01  PML   Remove all ALPHA, MIPS, and PPC code
*
*******************************************************************************/

#include <math.h>
#include <trans.h>

#if     defined(_M_IX86) || defined(_M_IA64)
#pragma function(fabs)
#endif


/***
*double fabs(double x)
*
*Purpose:
*   Compute |x|
*
*Entry:
*
*Exit:
*
*Exceptions:
*   I
*
*******************************************************************************/
double fabs(double x)
{
    uintptr_t savedcw;
    double result;

    /* save user fp control word */
    savedcw = _maskfp();

    if (IS_D_SPECIAL(x)){
        switch (_sptype(x)) {
        case T_PINF:
            RETURN(savedcw,x);
        case T_NINF:
            RETURN(savedcw,-x);
        case T_QNAN:
            return _handle_qnan1(OP_ABS, x, savedcw);
        default: //T_SNAN
            return _except1(FP_I, OP_ABS, x, _s2qnan(x), savedcw);
        }
    }


    *D_HI(result) = *D_HI(x) & ~(1<<31);
    *D_LO(result) = *D_LO(x);
    RETURN(savedcw,result);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\ieeemisc.c ===
/***
* ieeemisc.c - IEEE miscellaneous recommended functions
*
*       Copyright (c) 1992-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*
*Revision History:
*        5-04-92  GDP   written
*        8-13-96  JWM   Order of tests in _fpclass() rearranged, since
*                       "if (x==0.0)" now uses FP hardware.
*       11-25-00  PML   IA64 _logb and _isnan supplied by libm .s code.
*
*******************************************************************************/

#include <trans.h>
#include <math.h>
#include <float.h>


/***
* _copysign - copy sign
*
*Purpose:
*   copysign(x,y) returns x with the sign of y. Hence, abs(x) := copysign
*   even if x is NaN [IEEE std 854-1987 Appendix]
*
*
*Entry:
*
*Exit:
*
*Exceptions:
*   No exceptions, even if one of the arguments is NaN.
*
*   (Currently the i386 compiler returns doubles on the fp stack
*   so the fld instruction at the end will cause an invalid operation
*   if x is NaN. However this compiler calling convention will change
*   soon)
*
*******************************************************************************/

double _copysign (double x, double y)
{
    double retval;
    *D_LO(retval) = *D_LO(x);
    *D_HI(retval) = *D_HI(x) & ~(1<<31) |
                    *D_HI(y) &  (1<<31) ;

    return retval;
}



/***
* _chgsign - change sign
*
*Purpose:
*  x is copied with its sign reversed, not 0-x; the distinction is germane
*  when x is +0, -0, or NaN
*
*Entry:
*
*Exit:
*
*Exceptions:
*   No exceptions, even if x is NaN.
*
*   (Currently the i386 compiler returns doubles on the fp stack
*   so the fld instruction at the end will cause an invalid operation
*   if x is NaN. However this compiler calling convention will change
*   soon)
*
*******************************************************************************/

double _chgsign (double x)
{
    double retval;

    *D_LO(retval) = *D_LO(x);
    *D_HI(retval) = *D_HI(x) & ~(1 << 31)  |
                    ~*D_HI(x) & (1<<31);

    return retval;
}


/***
* _scalb - scale by power of 2
*
*Purpose:
*   _scalb(x,n) returns x * 2^n for integral values of n without
*   computing 2^n
*   Special case:
*      If x is infinity or zero, _scaleb returns x
*
*
*Entry:
*   double x
*   int   n
*
*Exit:
*
*Exceptions:
*   Invalid operation, Overflow, Underflow
*
*******************************************************************************/

double _scalb(double x, long n)
{
    //
    // It turns out that our implementation of ldexp matces the IEEE
    // description of _scalb. The only problem with calling ldexp
    // is that if an exception occurs, the operation code reported
    // to the handler will be the one that corresponds to ldexp
    // (i.e., we do not define a new operation code for _scalb
    //

    return ldexp(x,n);
}


#if !defined(_M_IA64)

/***
* _logb - extract exponent
*
*Purpose:
*   _logb(x) returns the unbiased exponent of x, a signed integer in the
*   format of x, except that logb(NaN) is a NaN, logb(+INF) is +INF,and
*   logb(0) is is -INF and signals the division by zero exception.
*   For x positive and finite, 1<= abs(scalb(x, -logb(x))) < 2
*
*
*Entry:
*   double x
*   int   n
*
*Exit:
*
*Exceptions:
*   Invalid operation, Division by zero
*
*******************************************************************************/
double _logb(double x)
{
    uintptr_t savedcw;
    int exp;
    double retval;

    /* save user fp control word */
    savedcw = _maskfp();

    /* check for infinity or NAN */
    if (IS_D_SPECIAL(x)){
        switch (_sptype(x)) {
        case T_PINF:
        case T_NINF:
            RETURN(savedcw, x);
        case T_QNAN:
            return _handle_qnan1(OP_LOGB, x, savedcw);
        default: //T_SNAN
            return _except1(FP_I, OP_LOGB, x, _s2qnan(x), savedcw);
        }
    }

    if (x == 0) {
         return _except1(FP_Z, OP_LOGB, x, -D_INF, savedcw);
    }

    (void) _decomp(x, &exp);

    //
    // x == man * 2^exp, where .5 <= man < 1. According to the spec
    // of this function, we should compute the exponent so that
    // 1<=man<2, i.e., we should decrement the computed exp by one
    //

    retval = (double) (exp - 1);

    RETURN(savedcw, retval);

}

#endif  // !defined(_M_IA64)



/***
* _nextafter - next representable neighbor
*
*Purpose:
*  _nextafter(x,y) returns the next representable neighbor of x in
*  the direction toward y. The following special cases arise: if
*  x=y, then the result is x without any exception being signaled;
*  otherwise, if either x or y is a quiet NaN, then the result is
*  one or the other of the input NaNs. Overflow is sibnaled when x
*  is finite but nextafter(x,y) is infinite; underflow is signaled
*  when nextafter(x,y) lies strictly between -2^Emin, 2^Emin; in
*  both cases, inexact is signaled.
*
*
*Entry:
*
*Exit:
*
*Exceptions:
*   O, U, I, P
*
*******************************************************************************/

double _nextafter(double x, double y)
{
    uintptr_t savedcw;
    double result;

    /* save user fp control word */
    savedcw = _maskfp();

    /* check for infinity or NAN */
    if (IS_D_SPECIAL(x) || IS_D_SPECIAL(y)){
        if (IS_D_SNAN(x) || IS_D_SNAN(y)){
            return _except2(FP_I,OP_NEXTAFTER,x,y,_d_snan2(x,y),savedcw);
        }
        if (IS_D_QNAN(x) || IS_D_QNAN(y)){
            return _handle_qnan2(OP_NEXTAFTER,x,y,savedcw);
        }

        //
        // infinite arguments are not treated as special cases
        //
    }

    if (y == x) {

        //
        // no exceptions are raised in this case
        //

        RETURN(savedcw, x);
    }

    if (x == 0) {

        *D_LO(result) = 1;

        if (y > x) {
            *D_HI(result) = 0;
        }

        else {

            //
            // result should be negative
            //

            *D_HI(result) = (unsigned long)(1<<31);
        }

    }


    //
    // At this point x!=y, and x!=0. x can be treated as a 64bit
    // integer in sign/magnitude representation. To get the next
    // representable neighbor we add or subtract one from this
    // integer. (Note that for boundary cases like x==INF, need to
    // add one will never occur --this would mean that y should
    // be greater than INF, which is impossible)
    //

    if (x > 0 && y < x ||
        x < 0 && y > x) {

        //
        // decrease value by one
        //

        *D_LO(result) = *D_LO(x) - 1;
        *D_HI(result) = *D_HI(x);

        if (*D_LO(x) == 0) {

            //
            // a borrow should propagate to the high order dword
            //

            (*D_HI(result)) --;
        }
    }

    else if (x > 0 && y > x ||
             x < 0 && y < x) {

        //
        // increase value by one
        //

        *D_LO(result) = *D_LO(x) + 1;
        *D_HI(result) = *D_HI(x);

        if (*D_LO(result) == 0) {

            //
            // a carry should propagate to the high order dword
            //

            (*D_HI(result)) ++;
        }
    }


    //
    // check if an exception should be raised
    //


    if ( IS_D_DENORM(result) ) {

        //
        // should signal underflow and inexact
        // and provide a properly scaled value
        //

        double mant;
        int exp;

        mant = _decomp(result, &exp);
        result = _set_exp(mant, exp+IEEE_ADJUST);

        return _except2(FP_U|FP_P,OP_NEXTAFTER,x,y,result,savedcw);
    }



    if ( IS_D_INF(result) || IS_D_MINF(result) ) {

        //
        // should signal overflow and inexact
        // and provide a properly scaled value
        //

        double mant;
        int exp;

        mant = _decomp(result, &exp);
        result = _set_exp(mant, exp-IEEE_ADJUST);

        return _except2(FP_O|FP_P,OP_NEXTAFTER,x,y,result,savedcw);
    }


    RETURN(savedcw, result);
}




/***
* _finite -
*
*Purpose:
*   finite(x) returns the value TRUE if -INF < x < +INF and returns
*   false otherwise [IEEE std]
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*   This routine is treated as a nonarithmetic operation, therefore
*   it does not signal any floating point exceptions
*
*******************************************************************************/

int _finite(double x)
{
    if (IS_D_SPECIAL(x)) {

        //
        // x is INF or NaN
        //

        return 0;
    }
    return 1;
}



#if !defined(_M_IA64)

/***
* _isnan -
*
*Purpose:
*   isnan(x) returns the value TRUE if x is a NaN, and returns FALSE
*   otherwise.
*
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*   This routine is treated as a nonarithmetic operation, therefore
*   it does not signal any floating point exceptions
*
*******************************************************************************/

int _isnan(double x)
{
    if (IS_D_SNAN(x) || IS_D_QNAN(x)) {
        return 1;
    }
    return 0;
}

#endif  // !defined(_M_IA64)


/***
*double _fpclass(double x) - floating point class
*
*Purpose:
*   Compute the floating point class of a number, according
*   to the recommendations of the IEEE std. 754
*
*Entry:
*
*Exit:
*
*Exceptions:
*   This function is never exceptional, even when the argument is SNAN
*
*******************************************************************************/

int _fpclass(double x)
{
    int sign;

    if (IS_D_SPECIAL(x)){
        switch (_sptype(x)) {
        case T_PINF:
            return _FPCLASS_PINF;
        case T_NINF:
            return _FPCLASS_NINF;
        case T_QNAN:
            return _FPCLASS_QNAN;
        default: //T_SNAN
            return _FPCLASS_SNAN;
        }
    }
    sign = (*D_EXP(x)) & 0x8000;

    if (IS_D_DENORM(x))
        return sign? _FPCLASS_ND : _FPCLASS_PD;

    if (x == 0.0)
        return sign? _FPCLASS_NZ : _FPCLASS_PZ;

    return sign? _FPCLASS_NN : _FPCLASS_PN;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\ldexp.c ===
/***
*ldexp.c - multiply by a power of two
*
*       Copyright (c) 1991-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*
*Revision History:
*        8-24-91  GDP   written
*        1-13-92  GDP   rewritten to support IEEE exceptions
*        5-05-92  GDP   bug fix for x denormal
*       07-16-93  SRW   ALPHA Merge
*       11-18-93  GJF   Merged in NT SDK verion.
*
*******************************************************************************/
#include <math.h>
#include <float.h>
#include <trans.h>
#include <limits.h>

/***
*double ldexp(double x, int exp)
*
*Purpose:
*   Compute x * 2^exp
*
*Entry:
*
*Exit:
*
*Exceptions:
*    I  U  O  P
*
*******************************************************************************/
double ldexp(double x, int exp)
{
    uintptr_t savedcw;
    int oldexp;
    long newexp; /* for checking out of bounds exponents */
    double result, mant;

    /* save user fp control word */
    savedcw = _maskfp();

    /* check for infinity or NAN */
    if (IS_D_SPECIAL(x)){
        switch (_sptype(x)) {
        case T_PINF:
        case T_NINF:
            RETURN(savedcw,x);
        case T_QNAN:
            return _handle_qnan2(OP_LDEXP, x, (double)exp, savedcw);
        default: //T_SNAN
            return _except2(FP_I,OP_LDEXP,x,(double)exp,_s2qnan(x),savedcw);
        }
    }


    if (x == 0.0) {
        RETURN(savedcw,x);
    }

    mant = _decomp(x, &oldexp);

    if (ABS(exp) > INT_MAX)
        newexp = exp; // avoid possible integer overflow
    else
        newexp = oldexp + exp;


    /* out of bounds cases */
    if (newexp > MAXEXP + IEEE_ADJUST) {
        return _except2(FP_O|FP_P,OP_LDEXP,x,(double)exp,_copysign(D_INF,mant),savedcw);
    }
    if (newexp > MAXEXP) {
        result = _set_exp(mant, newexp-IEEE_ADJUST);
        return _except2(FP_O|FP_P,OP_LDEXP,x,(double)exp,result,savedcw);
    }
    if (newexp < MINEXP - IEEE_ADJUST) {
        return _except2(FP_U|FP_P,OP_LDEXP,x,(double)exp,mant*0.0,savedcw);
    }
    if (newexp < MINEXP) {
        result = _set_exp(mant, newexp+IEEE_ADJUST);
        return _except2(FP_U|FP_P,OP_LDEXP,x,(double)exp,result,savedcw);
    }

    result = _set_exp(mant, (int)newexp);

    RETURN(savedcw,result);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\hypot.c ===
/***
*hypot.c - hypotenuse and complex absolute value
*
*       Copyright (c) 1991-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*
*Revision History:
*       08-15-91  GDP   written
*       10-20-91  GDP   removed inline assembly for calling sqrt
*
*******************************************************************************/
#include <math.h>
#include <trans.h>

static double _hypothlp(double x, double y, int who);

/*
 *  Function name:  hypot
 *
 *  Arguments:      x, y  -  double
 *
 *  Description:    hypot returns sqrt(x*x + y*y), taking precautions against
 *                  unwarrented over and underflows.
 *
 *  Side Effects:   no global data is used or affected.
 *
 *  Author:         written  R.K. Wyss, Microsoft,  Sept. 9, 1983
 *
 *  History:
 *      03/13/89  WAJ   Minor changes to source.
 *      04/13/89  WAJ   Now uses _cdecl for _CDECL
 *      06/07/91  JCR   ANSI naming (_hypot)
 *      08/26/91  GDP   NaN support, error handling
 *      01/13/91  GDP   IEEE exceptions support
 */

double _hypot(double x, double y)
{
    return _hypothlp(x,y,OP_HYPOT);
}

/***
*double _cabs(struct _complex z) - absolute value of a complex number
*
*Purpose:
*
*Entry:
*
*Exit:
*
*Exceptions:
*******************************************************************************/
double _cabs(struct _complex z)
{
    return( _hypothlp(z.x, z.y, OP_CABS ) );
}



static double _hypothlp(double x, double y, int who)
{
    double max;
    double result, sum;
    uintptr_t savedcw;
    int exp1, exp2, newexp;

    /* save user fp control word */
    savedcw = _maskfp();

    /* check for infinity or NAN */
    if (IS_D_SPECIAL(x) || IS_D_SPECIAL(y)){
        if (IS_D_SNAN(x) || IS_D_SNAN(y)){
            return _except2(FP_I,who,x,y,_d_snan2(x,y),savedcw);
        }
        if (IS_D_QNAN(x) || IS_D_QNAN(y)){
            return _handle_qnan2(who,x,y,savedcw);
        }
        /* there is at least one infinite argument ... */
        RETURN(savedcw,D_INF);
    }


    /* take the absolute values of x and y, compute the max, and then scale by
       max to prevent over or underflowing */

    if ( x < 0.0 )
        x = - x;

    if ( y < 0.0 )
        y = - y;

    max = ( ( y > x ) ?  y : x );

    if ( max == 0.0 )
        RETURN(savedcw, 0.0 );

    x /= max;   //this may pollute the fp status word (underflow flag)
    y /= max;

    sum = x*x + y*y;

    result = _decomp(sqrt(sum),&exp1) * _decomp(max,&exp2);
    newexp = exp1 + exp2 + _get_exp(result);

    // in case of overflow or underflow
    // adjusting exp by IEEE_ADJUST will certainly
    // bring the result in the representable range

    if (newexp > MAXEXP) {
        result = _set_exp(result, newexp - IEEE_ADJUST);
        return _except2(FP_O | FP_P, who, x, y, result, savedcw);
    }
    if (newexp < MINEXP) {
        result = _set_exp(result, newexp + IEEE_ADJUST);
        return _except2(FP_U | FP_P, who, x, y, result, savedcw);
    }

    result = _set_exp(result, newexp);
    // fix needed: P exception is raised even if the result is exact

    RETURN_INEXACT2(who, x, y, result, savedcw);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\modf.c ===
/***
*modf.c - modf()
*
*       Copyright (c) 1991-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*
*Revision History:
*        8-24-91  GDP   written
*        1-13-92  GDP   support IEEE exceptions
*        6-23-92  GDP   modified special return values for NCEG conformance
*       02-06-95  JWM   Mac merge
*       01-26-01  PML   Pentium4 merge
*       02-28-01  PML   Make sure 0.0 fraction return has correct sign
*
*******************************************************************************/

#include <math.h>
#include <trans.h>
#include <float.h>

extern double _frnd(double);
extern double _copysign (double x, double y);

/***
*double modf(double x, double *intptr)
*
*Purpose:
*   Split x into fractional and integer part
*   The signed fractional portion is returned
*   The integer portion is stored as a floating point value at intptr
*
*Entry:
*
*Exit:
*
*Exceptions:
*    I
*******************************************************************************/
static  uintptr_t newcw = (ICW & ~IMCW_RC) | (IRC_CHOP & IMCW_RC);

#if !defined(_M_IX86)
double modf(double x, double *intptr)
#else
double _modf_default(double x, double *intptr)
#endif
{
    uintptr_t savedcw;
    double result,intpart;

    /* save user fp control word */
    savedcw = _ctrlfp(0, 0);     /* get old control word */
    _ctrlfp(newcw,IMCW);        /* round towards 0 */

    /* check for infinity or NAN */
    if (IS_D_SPECIAL(x)){
        *intptr = QNAN_MODF;
        switch (_sptype(x)) {
        case T_PINF:
        case T_NINF:
            *intptr = x;
            result = _copysign(0, x);
            RETURN(savedcw,result);
        case T_QNAN:
            *intptr = x;
            return _handle_qnan1(OP_MODF, x, savedcw);
        default: //T_SNAN
            result = _s2qnan(x);
            *intptr = result;
            return _except1(FP_I, OP_MODF, x, result, savedcw);
        }
    }

    intpart = _frnd(x); //fix needed: this may set the P exception flag
                        //and pollute the fp status word

    *intptr = intpart;
    result = x - intpart;

    if (result == 0.0) {
	/* Make sure fractional part of 0.0 has the correct sign */
	*D_EXP(result) |= (*D_EXP(x) & 0x8000);
    }

    RETURN(savedcw,result);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\matherr.c ===
/***
*matherr.c - floating point exception handling
*
*       Copyright (c) 1991-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*
*Revision History:
*        8-24-91  GDP   written
*       08-03-94  GJF   Revised to support user-supplied version of _matherr
*                       in clients of msvcrt*.dll.
*       05-13-99  PML   Remove Win32s
*
*******************************************************************************/

#include <math.h>
#include <stddef.h>

int _matherr_flag = 9876;

#if     defined(CRTDLL) && !defined(_NTSDK)

/*
 * Pointer to user-supplied _matherr routine if one has been supplied.
 */
int (__cdecl * pusermatherr)(struct _exception *) = NULL;

/***
*void __setusermatherr ( int (__cdecl *pf)(struct exception *) )
*
*Purpose:
*       Copy pointer to user-supplied matherr routine into pusermatherr
*
*Entry:
*       pf  - pointer to an implementation of _matherr supplied by the user
*Exit:
*
*Exceptions:
*******************************************************************************/

_CRTIMP void __setusermatherr( int (__cdecl *pf)(struct _exception *) )
{
        pusermatherr = pf;
        _matherr_flag = 0;
}

#endif

/***
*int _matherr(struct _exception *except) - handle math errors
*
*Purpose:
*   Permits the user customize fp error handling by redefining this function.
*
*   The default matherr does nothing and returns 0
*
*Entry:
*
*Exit:
*
*Exceptions:
*******************************************************************************/
int _matherr(struct _exception *pexcept)
{
#if     defined(CRTDLL) && !defined(_NTSDK)

        /*
         * If user has supplied a _matherr implementation, pass control to
         * it and let it handle the error.
         */
        if ( pusermatherr != NULL )
                return pusermatherr(pexcept);
#endif
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\pow.c ===
/***
*pow.c - raise to a power
*
*       Copyright (c) 1991-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*
*Revision History:
*        8-15-91  GDP   written
*       12-20-91  GDP   support IEEE exceptions & denormals
*        1-11-92  GDP   special handling of small powers
*                       special handling of u1, u2 when cancellation occurs
*        3-22-92  GDP   changed handling of int exponents, pow(0, neg)
*                       added check to avoid internal overflow due to large y
*        6-23-92  GDP   adjusted special return values according to NCEG spec
*       02-06-95  JWM   Mac merge
*       02-07-95  JWM   powhlp() usage restored to Intel version.
*       10-07-97  RDL   Added IA64.
*
*******************************************************************************/

#include <math.h>
#include <trans.h>
#include <float.h>

#if defined(_M_IA64)
#pragma function(pow)
#endif

static double _reduce(double);

static double const a1[18] = {
    0.00000000000000000000e+000,   /* dummy element */
    1.00000000000000000000e+000,
    9.57603280698573646910e-001,
    9.17004043204671231754e-001,
    8.78126080186649741555e-001,
    8.40896415253714543073e-001,
    8.05245165974627154042e-001,
    7.71105412703970411793e-001,
    7.38413072969749655712e-001,
    7.07106781186547524436e-001,
    6.77127773468446364133e-001,
    6.48419777325504832961e-001,
    6.20928906036742024317e-001,
    5.94603557501360533344e-001,
    5.69394317378345826849e-001,
    5.45253866332628829604e-001,
    5.22136891213706920173e-001,
    5.00000000000000000000e-001
};

static double const a2[9] = {
    0.00000000000000000000e+000,   /* dummy element */
   -5.31259064517897172664e-017,
    1.47993596544271355242e-017,
    1.23056946577104753260e-017,
   -1.74014448683923461658e-017,
    3.84891771232354074073e-017,
    2.33103467084383453312e-017,
    4.45607092891542322377e-017,
    4.27717757045531499216e-017
};

static double const log2inv = 1.44269504088896340739e+0; //  1/log(2)
static double const K = 0.44269504088896340736e+0;

static double const p1 = 0.83333333333333211405e-1;
static double const p2 = 0.12500000000503799174e-1;
static double const p3 = 0.22321421285924258967e-2;
static double const p4 = 0.43445775672163119635e-3;

#define P(v) (((p4 * v + p3) * v + p2) * v + p1)

static double const q1 = 0.69314718055994529629e+0;
static double const q2 = 0.24022650695909537056e+0;
static double const q3 = 0.55504108664085595326e-1;
static double const q4 = 0.96181290595172416964e-2;
static double const q5 = 0.13333541313585784703e-2;
static double const q6 = 0.15400290440989764601e-3;
static double const q7 = 0.14928852680595608186e-4;

#define Q(w)   ((((((q7 * w + q6) * w + q5) * w + q4) * w + \
                              q3) * w + q2) * w + q1)


/*
 * Thresholds for over/underflow that results in an adjusted value
 * too big/small to be represented as a double. An infinity or 0
 * is delivered to the trap handler instead
 */

static _dbl const _ovfx ={SET_DBL(0x40e40000,0)}; // 16*log2(XMAX*2^IEEE_ADJ)
static _dbl const _uflx ={SET_DBL(0xc0e3fc00,0)}; // 16*log2(XMIN*2^(-IEEE_ADJ))

#define OVFX _ovfx.dbl
#define UFLX _uflx.dbl

#define INT_POW_LIMIT   128.0

static double ymax = 1e20;

static double _reduce(double x)
{
    return 0.0625 * _frnd( 16.0 * x);
}

/***
*double pow(double x, double y) - x raised to the power of y
*
*Purpose:
*   Calculate x^y
*   Algorithm from Cody & Waite
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*   All 5 IEEE exceptions may occur
*
*******************************************************************************/
double pow(double x, double y)
{
    uintptr_t savedcw;
    int m,mprim;
    int p,pprim;
    int i,iw1;
    int iy;
    int newexp;
    double diw1;
    double sign;
    double g,z,bigz,v,rz,result;
    double u1,u2,y1,y2,w,w1,w2;
    double savedx;

    /* save user fp control word */
    savedcw = _maskfp();
    savedx = x;         // save original value of first argument

    if (_fpclass(y) & (_FPCLASS_NZ | _FPCLASS_PZ)) {
        RETURN(savedcw, 1.0);
    }

    /* Check for zero^y */
    if (_fpclass(x) & (_FPCLASS_NZ | _FPCLASS_PZ)) { /* x==0? */
        int type;

        type = _d_inttype(y);

        if (y < 0.0) {
            result = (type == _D_ODD ? _copysign(D_INF,x) : D_INF);
            return _except2(FP_Z,OP_POW,savedx,y,result,savedcw|ISW_ZERODIVIDE);
        }
        else if (y > 0.0) {
            result = (type == _D_ODD ? x : 0.0);
                RETURN(savedcw, result);
        }
    }

    /* check for infinity or NAN */
    if (IS_D_SPECIAL(x) || IS_D_SPECIAL(y)) {
      double absx = fabs(x);

      if (IS_D_SNAN(x) || IS_D_SNAN(y)) {
        return _except2(FP_I,OP_POW,savedx,y,_d_snan2(x,y),savedcw | (ISW_INVALID>>5) );
      }
      if (IS_D_QNAN(x) || IS_D_QNAN(y)){
        return _handle_qnan2(OP_POW,x,y,savedcw | (ISW_INVALID>>5) );
      }
      
      /* there is at least one infinite argument ... */
      if (_powhlp(x, y, &result)) { /* removed "<" 0. */
        return _except2(FP_I,OP_POW,savedx,y,result,savedcw | (ISW_INVALID>>5) );
      }
      RETURN(savedcw, result);
    }

    sign = 1.0;
    if (x < 0) {
        switch (_d_inttype(y)) {
        case _D_ODD: /* y is an odd integral value */
            sign = -1.0;
            /* NO BREAK */
        case _D_EVEN:
            x = -x;
            break;
        default: /* y is not an integral value */
            return _except2(FP_I,OP_POW,savedx,y,D_IND,savedcw|(ISW_INVALID>>5));
        }
    }

    //
    // This is here in order to prevent internal overflows
    // due to a large value of y
    // The following relation holds on overflow with a scaled
    // result out of range
    // (lg stands for log base 2)
    //      |y| * |lg(x)| > MAXEXP + IEEE_ADJUST        <=>
    //      |y| >  2560 / |lg(x)|
    // The values of lg(x) closer to 0 are:
    //      x                                    lg(x)
    //  3fefffffffffffff    (0,99...9)        -1.601e-16
    //  3ff0000000000000    (1.0)              0.0
    //  3ff0000000000001    (1.00...1)         3.203e-16
    //
    // So if |y| > 2560/1.6e-16 = 1.6e19 overflow occurs
    // We set ymax to 1e20 in order to have a safety margin
    //

    if (ABS(y) > ymax) {
        if (y < 0) {
            y = -y;
            //
            // this may cause an underflow
            // there is no problem with fp sw pollution because
            // a FP_U exception is going to be raised anyway.
            //
            x = 1.0 / x;
        }
        if (x > 1.0) {
            return _except2(FP_O | FP_P,OP_POW,savedx,y,sign*D_INF,savedcw|ISW_OVERFLOW);
        }
        else if (x < 1.0){
            return _except2(FP_U | FP_P,OP_POW,savedx,y,sign*0.0,savedcw|ISW_UNDERFLOW);
        }
        else {
            RETURN(savedcw, sign*1.0);
        }
    }


    /* determine m, g */
    g = _decomp(x, &m);


    /* handle small integer powers
     * for small integer powers this is faster that Cody&Waite's
     * algorithm, and yields better precision
     * Without this piece of code there was not enough precision
     * to satisfy all requirements of the 'paranoia' test.
     * We choose INT_POW_LIMIT such that (1) no overflow or underflow
     * occurs while computing bigz (g is in the range
     * [0.5, 1.0) or (1.0, 2.0] so INT_POW_LIMIT should be less than
     * approximately 10^3) and (2) no extraordinary loss of precision
     * occurs because of repeated multiplications (this practically
     * restricts the maximum INT_POW_LIMIT to 128).
     */

    if (y <= INT_POW_LIMIT &&
        _d_inttype(x) != _D_NOINT &&
        _d_inttype(y) != _D_NOINT &&
        y > 0.0 ) {

        iy = (int)y;
        mprim = m * iy;

        for (bigz=1 ; iy ; iy >>= 1, g *= g) {
            if (iy & 0x1)
                bigz *= g;
        }

        newexp = _get_exp(bigz) + mprim;
        if (newexp > MAXEXP + IEEE_ADJUST) {
            return _except2(FP_O | FP_P, OP_POW, savedx, y, sign*bigz*D_INF, savedcw);
        }
        if (newexp < MINEXP - IEEE_ADJUST) {
            return _except2(FP_U | FP_P, OP_POW, savedx, y, sign*bigz*0.0, savedcw);
        }

    }


    else {

        /* determine p using binary search */
        p = 1;
        if (g <= a1[9])
            p = 9;
        if (g <= a1[p+4])
            p += 4;
        if (g <= a1[p+2])
            p += 2;


        /* C&W's algorithm is not very accurate when m*16-p == 1,
         * because there is cancellation between u1 and u2.
         * Handle this separately.
         */
        if (ABS(m*16-p) == 1) {
            u1 = log(x) * log2inv;
            u2 = 0.0;
        }
        else {
            /* determine z */
            z = ( (g - a1[p+1]) - a2[(p+1)/2] ) / ( g + a1[p+1] );
            z += z;


            /* determine u2 */
            v = z * z;
            rz = P(v) * v * z;
            rz += K * rz;
            u2 = (rz + z * K) + z;

            u1 = (m * 16 - p) * 0.0625;
        }

        /* determine w1, w2 */
        y1 = _reduce(y);
        y2 = y - y1;
        w = u2 * y + u1 * y2;
        w1 = _reduce(w);
        w2 = w - w1;
        w = w1 + u1 * y1;
        w1 = _reduce(w);
        w2 += w - w1;
        w = _reduce(w2);
        diw1 = 16 * (w1 + w); /* iw1 might overflow here, so use diw1 */
        w2 -= w;

        if (diw1 > OVFX) {
            return _except2(FP_O | FP_P,OP_POW,savedx,y,sign*D_INF,savedcw | ISW_OVERFLOW);
        }
        if (diw1 < UFLX) {
            return _except2(FP_U | FP_P,OP_POW,savedx,y,sign*0.0,savedcw | ISW_UNDERFLOW);
        }

        iw1 = (int) diw1;        /* now it is safe to cast to int */


        /* make sure w2 <= 0 */
        if (w2 > 0) {
            iw1 += 1;
            w2 -= 0.0625;
        }

        /* determine mprim, pprim */
        i = iw1 < 0 ? 0 : 1;
        mprim = iw1 / 16 + i;
        pprim = 16 * mprim - iw1;

        /* determine 2^w2 */
        bigz = Q(w2) * w2;

        /* determine  final result */
        bigz = a1[pprim + 1] + a1[pprim + 1] * bigz;
        newexp = _get_exp(bigz) + mprim;
    }


    if (newexp > MAXEXP) {
        result = sign * _set_exp(bigz, newexp - IEEE_ADJUST);
        return _except2(FP_O | FP_P, OP_POW, savedx, y, sign*D_INF, savedcw|ISW_OVERFLOW);
    }
    if (newexp < MINEXP) {
        result = sign * _set_exp(bigz, newexp + IEEE_ADJUST);
        return _except2(FP_U | FP_P, OP_POW, savedx, y, sign*0.0, savedcw|ISW_UNDERFLOW);
    }

    result = sign * _set_exp(bigz, newexp);
    RETURN_INEXACT2(OP_POW, savedx, y, result, savedcw|ISW_INEXACT);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\powhlp.c ===
/***
*powhlp.c - pow() helper routines for handling special cases
*
*	Copyright (c) 1991-2001, Microsoft Corporation.	All rights reserved.
*
*Purpose:
*	pow(x,y) helper routine. Handles +inf, -inf
*
*Revision History:
*   11-09-91	GDP
*   06-23-92	GDP	adjusted return values according to the NCEG spec
*   02-06-95	JWM	Mac merge
*	02-07-95	JWM	powhlp() restored to Intel version.
*
*******************************************************************************/
#include <trans.h>
#include <float.h>

/***
*int _powhlp(double x, double y, double * result) - pow() helper
*
*Purpose:
*   Calculate x^(sign)inf
*
*Entry:
*   double x: the base
*   int sign: the sign of the infinite exponent (0: pos, non-0: neg)
*   double *result: pointer to the result
*
*Exit:
*   0: normal exit
*   -1: indicates domain error for pow(x,inf)
*
*Exceptions:
*
***************************************************************************/

int _powhlp(double x, double y, double * result)
{
    double absx;
    int err = 0;


    absx = ABS(x);

    if (IS_D_INF(y)) {
	if (absx > 1.0) {
	    *result = D_INF;
	}
	else if (absx < 1.0) {
	    *result = 0.0;
	}
	else {
	    *result = D_IND;
	    err = 1;
	}
    }

    else if (IS_D_MINF(y)) {
	if (absx > 1.0) {
	    *result = 0.0;
	}
	else if (absx < 1.0) {
	    *result = D_INF;
	}
	else {
	    *result = D_IND;
	    err = 1;
	}
    }

    else if (IS_D_INF(x)) {
	if (y > 0)
	    *result = D_INF;
	else if (y < 0.0)
	    *result = 0.0;
	else {
	    *result = 1.0;
	}
    }

    else if (IS_D_MINF(x)) {
	int type;

	type = _d_inttype(y);

	if (y > 0.0) {
	    *result = (type == _D_ODD ? -D_INF : D_INF);
	}
	else if (y < 0.0) {
	    *result = (type == _D_ODD ? D_MZERO : 0.0);
	}
	else {
	    *result = 1;
	}

    }

    return err;
}




int _d_inttype(double y)
{
    double rounded;
    /* check if y is an integral value */
    if (_fpclass(y) & (_FPCLASS_PD | _FPCLASS_ND))
      return _D_NOINT;
    rounded = _frnd(y);
    if (rounded == y) {
	if (_frnd(y/2.0) == y/2.0)
	    return _D_EVEN;
	else
	    return _D_ODD;
    }
    return _D_NOINT;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\log.c ===
/***
*log.c - logarithmic functions
*
*       Copyright (c) 1991-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*   Compute log(x) and log10(x)
*
*Revision History:
*        8-15-91  GDP   written
*       12-20-91  GDP   support IEEE exceptions
*       10-07-97  RDL   Added IA64.
*
*******************************************************************************/

#include <math.h>
#include <trans.h>

#if defined(_M_IA64)
#pragma function(log, log10)
#endif

static double _log_hlp( double x, int flag);

/* constants */
static double const c0 =  0.70710678118654752440;       /* sqrt(0.5) */
static double const c1 =  0.69335937500000000000;
static double const c2 = -2.121944400546905827679e-4;
static double const c3 =  0.43429448190325182765;

/* coefficients for rational approximation */
static double const a0 = -0.64124943423745581147e2 ;
static double const a1 =  0.16383943563021534222e2 ;
static double const a2 = -0.78956112887491257267e0 ;
static double const b0 = -0.76949932108494879777e3 ;
static double const b1 =  0.31203222091924532844e3 ;
static double const b2 = -0.35667977739034646171e2 ;
/* b3=1.0  is not used -avoid multiplication by 1.0 */

#define A(w) (((w) * a2 + a1) * (w) + a0)
#define B(w) ((((w) + b2) * (w) + b1) * (w) + b0)

/***
*double log(double x) -  natural logarithm
*double log10(double x) - base-10 logarithm
*
*Purpose:
*   Compute the natural and base-10 logarithm of a number.
*   The algorithm (reduction / rational approximation) is
*   taken from Cody & Waite.
*
*Entry:
*
*Exit:
*
*Exceptions:
*   I P Z
*******************************************************************************/

double log10(double x)
{
    return(_log_hlp(x,OP_LOG10));
}

double log(double x)
{
    return(_log_hlp(x,OP_LOG));
}

static double _log_hlp(double x, int opcode)
{
    uintptr_t savedcw;
    int n;
    double f,result;
    double z,w,znum,zden;
    double rz,rzsq;

    /* save user fp control word */
    savedcw = _maskfp();

    /* check for infinity or NAN */
    if (IS_D_SPECIAL(x)){
        switch (_sptype(x)) {
        case T_PINF:
            RETURN(savedcw, x);
        case T_QNAN:
            return _handle_qnan1(opcode, x, savedcw);
        case T_SNAN:
            return _except1(FP_I, opcode, x, _s2qnan(x), savedcw);
        }
        /* NINF will be handled in the x<0 case */
    }

    if (x <= 0.0) {
        double qnan;
        if (x == 0.0) {
            return _except1(FP_Z,opcode,x,-D_INF,savedcw);
        }
        qnan = (opcode == OP_LOG ? QNAN_LOG : QNAN_LOG10);
        return _except1(FP_I,opcode,x,qnan,savedcw);
    }

    if (x == 1.0) {
        // no precision ecxeption
        RETURN(savedcw, 0.0);
    }

    f = _decomp(x, &n);

    if (f > c0) {
        znum = (f - 0.5) - 0.5;
        zden = f * 0.5 + 0.5;
    }
    else {
        n--;
        znum = f - 0.5;
        zden = znum * 0.5 + 0.5;
    }
    z = znum / zden;
    w = z * z;

    rzsq = w * A(w)/B(w) ;
    rz = z + z*rzsq;

    result = (n * c2 + rz) + n * c1;
    if (opcode == OP_LOG10) {
        result *= c3;
    }

    RETURN_INEXACT1(opcode,x,result,savedcw);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\sincosh.c ===
/***
*sincosh.c - hyperbolic sine and cosine
*
*       Copyright (c) 1991-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*
*Revision History:
*        8-15-91  GDP   written
*       12-20-91  GDP   support IEEE exceptions
*       02-03-92  GDP   use _exphlp for computing e^x
*       06-23-92  GDP   sinh(denormal) now raises underflow exception (NCEG)
*       07-16-93  SRW   ALPHA Merge
*       11-18-93  GJF   Merged in NT SDK version.
*       02-06-95  JWM   Mac merge
*       05-17-99  PML   Remove all Macintosh support.
*       07-15-01  PML   Remove all ALPHA, MIPS, and PPC code
*
*******************************************************************************/

#include <math.h>
#include <trans.h>

extern double _exphlp(double, int *);

static double const EPS  = 5.16987882845642297e-26;    /* 2^(-53) / 2 */
/* exp(YBAR) should be close to but less than XMAX
 * and 1/exp(YBAR) should not underflow
 */
static double const YBAR = 7.00e2;

/* WMAX=ln(OVFX)+0.69 (Cody & Waite),ommited LNV, used OVFX instead of BIGX */

static double const WMAX = 1.77514678223345998953e+003;

/* constants for the rational approximation */
static double const p0 = -0.35181283430177117881e+6;
static double const p1 = -0.11563521196851768270e+5;
static double const p2 = -0.16375798202630751372e+3;
static double const p3 = -0.78966127417357099479e+0;
static double const q0 = -0.21108770058106271242e+7;
static double const q1 =  0.36162723109421836460e+5;
static double const q2 = -0.27773523119650701667e+3;
/* q3 = 1 is not used (avoid myltiplication by 1) */

#define P(f)   (((p3 * (f) + p2) * (f) + p1) * (f) + p0)
#define Q(f)   ((((f) + q2) * (f) + q1) * (f) + q0)

#if !defined(_M_AMD64)
#pragma function(sinh, cosh)
#endif

/***
*double sinh(double x) - hyperbolic sine
*
*Purpose:
*   Compute the hyperbolic sine of a number.
*   The algorithm (reduction / rational approximation) is
*   taken from Cody & Waite.
*
*Entry:
*
*Exit:
*
*Exceptions:
*       I P
*       no exception if x is denormal: return x
*******************************************************************************/

double sinh(double x)
{
    uintptr_t savedcw;
    double result;
    double y,f,z,r;
    int newexp;
    int sgn;

    /* save user fp control word */
    savedcw = _maskfp();

    if (IS_D_SPECIAL(x)){
        switch(_sptype(x)) {
        case T_PINF:
        case T_NINF:
            RETURN(savedcw,x);
        case T_QNAN:
            return _handle_qnan1(OP_SINH, x, savedcw);
        default: //T_SNAN
            return _except1(FP_I,OP_SINH,x,_s2qnan(x),savedcw);
        }
    }

    if (x == 0.0) {
        RETURN(savedcw,x); // no precision ecxeption
    }

    y = ABS(x);
    sgn = x<0 ? -1 : +1;

    if (y > 1.0) {
        if (y > YBAR) {
            if (y > WMAX) {
                // result too large, even after scaling
                return _except1(FP_O | FP_P,OP_SINH,x,x*D_INF,savedcw);
            }

            //
            // result = exp(y)/2
            //

            result = _exphlp(y, &newexp);
            newexp --;      //divide by 2
            if (newexp > MAXEXP) {
                result = _set_exp(result, newexp-IEEE_ADJUST);
                return _except1(FP_O|FP_P,OP_SINH,x,result,savedcw);
            }
            else {
                result = _set_exp(result, newexp);
            }

        }
        else {
            z = _exphlp(y, &newexp);
            z = _set_exp(z, newexp);
            result = (z - 1/z) / 2;
        }

        if (sgn < 0) {
            result = -result;
        }
    }
    else {
        if (y < EPS) {
            result = x;
            if (IS_D_DENORM(result)) {
                return _except1(FP_U | FP_P,OP_SINH,x,_add_exp(result, IEEE_ADJUST),savedcw);
            }
        }
        else {
            f = x * x;
            r = f * (P(f) / Q(f));
            result = x + x * r;
        }
    }

    RETURN_INEXACT1(OP_SINH,x,result,savedcw);
}



/***
*double cosh(double x) - hyperbolic cosine
*
*Purpose:
*   Compute the hyperbolic cosine of a number.
*   The algorithm (reduction / rational approximation) is
*   taken from Cody & Waite.
*
*Entry:
*
*Exit:
*
*Exceptions:
*   I P
*   no exception if x is denormal: return 1
*******************************************************************************/
double cosh(double x)
{
    uintptr_t savedcw;
    double y,z,result;
    int newexp;

    /* save user fp control word */
    savedcw = _maskfp();

    if (IS_D_SPECIAL(x)){
        switch(_sptype(x)) {
        case T_PINF:
        case T_NINF:
            RETURN(savedcw,D_INF);
        case T_QNAN:
            return _handle_qnan1(OP_COSH, x, savedcw);
        default: //T_SNAN
            return _except1(FP_I,OP_COSH,x,_s2qnan(x),savedcw);
        }
    }

    if (x == 0.0) {
        RETURN(savedcw,1.0);
    }

    y = ABS(x);
    if (y > YBAR) {
        if (y > WMAX) {
            return _except1(FP_O | FP_P,OP_COSH,x,D_INF,savedcw);
        }

        //
        // result =     exp(y)/2
        //

        result = _exphlp(y, &newexp);
        newexp --;          //divide by 2
        if (newexp > MAXEXP) {
            result = _set_exp(result, newexp-IEEE_ADJUST);
            return _except1(FP_O|FP_P,OP_COSH,x,result,savedcw);
        }
        else {
            result = _set_exp(result, newexp);
        }
    }
    else {
        z = _exphlp(y, &newexp);
        z = _set_exp(z, newexp);
        result = (z + 1/z) / 2;
    }

    RETURN_INEXACT1(OP_COSH,x,result,savedcw);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\sqrt.c ===
/***
*sqrt.c - square root
*
*       Copyright (c) 1991-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*
*Revision History:
*        8-15-91  GDP   written
*        1-29-91  GDP   Kahan's algorithm for final rounding
*        3-11-92  GDP   new interval and initial approximation
*       10-07-97  RDL   Added IA64.
*
*******************************************************************************/

#ifndef R4000

#include <math.h>
#include <trans.h>

#if defined(_M_IA64)
#pragma function(sqrt)
#endif

//
// Coefficients for initial approximation (Hart & al)
//

static double p00 =  .2592768763e+0;
static double p01 =  .1052021187e+1;
static double p02 = -.3163221431e+0;


/***
*double sqrt(double x) - square root
*
*Purpose:
*   Compute the square root of a number.
*   This function should be provided by the underlying
*   hardware (IEEE spec).
*Entry:
*
*Exit:
*
*Exceptions:
*  I P
*******************************************************************************/
double sqrt(double x)
{
    uintptr_t savedcw, sw;
    double result,t;
    uintptr_t stat,rc;

    savedcw = _ctrlfp(ICW, IMCW);

    if (IS_D_SPECIAL(x)){
        switch (_sptype(x)) {
        case T_PINF:
            RETURN(savedcw, x);
        case T_QNAN:
            return _handle_qnan1(OP_SQRT, x, savedcw);
        case T_SNAN:
            return _except1(FP_I,OP_SQRT,x,QNAN_SQRT,savedcw);
        }
        /* -INF will be handled in the x<0 case */
    }
    if (x < 0.0) {
        return _except1(FP_I, OP_SQRT, x, QNAN_SQRT,savedcw);
    }

    if (x == 0.0) {
        RETURN (savedcw, x);
    }


    result = _fsqrt(x);

    _ctrlfp(IRC_DOWN, IMCW_RC);


    //
    // Kahan's algorithm
    //

    sw = _clrfp();
    t = x / result;
    stat = _statfp();
    if (! (stat & ISW_INEXACT)) {
        // exact
        if (t == result) {
            _set_statfp(sw);            // restore status word
            RETURN(savedcw, result);
        }
        else {
            // t = t-1
            if (*D_LO(t) == 0) {
                (*D_HI(t)) --;
            }
            (*D_LO(t)) --;
        }

    }

    rc = savedcw & IMCW_RC;
    if (rc == IRC_UP  || rc == IRC_NEAR) {
        // t = t+1
        (*D_LO(t)) ++;
        if (*D_LO(t) == 0) {
            (*D_HI(t)) ++;
        }
        if (rc == IRC_UP) {
            // y = y+1
            (*D_LO(t)) ++;
            if (*D_LO(t) == 0) {
                (*D_HI(t)) ++;
            }
        }
    }

    result = 0.5 * (t + result);

    _set_statfp(sw | ISW_INEXACT);      // update status word
    RETURN_INEXACT1(OP_SQRT, x, result, savedcw);
}



/***
* _fsqrt - non IEEE conforming square root
*
*Purpose:
*   compute a square root of a normal number without performing
*   IEEE rounding. The argument is a finite number (no NaN or INF)
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

double _fsqrt(double x)
{
    double f,y,result;
    int n;

    f = _decomp(x,&n);

    if (n & 0x1) {
        // n is odd
        n++;
        f = _add_exp(f, -1);
    }

    //
    // approximation for sqrt in the interval [.25, 1]
    // (Computer Approximationsn, Hart & al.)
    // gives more than 7 bits of accuracy
    //

    y =  p00 + f * (p01 + f *  p02);

    y += f / y;
    y = _add_exp(y, -1);

    y += f / y;
    y = _add_exp(y, -1);

    y += f / y;
    y = _add_exp(y, -1);

    n >>= 1;
    result = _add_exp(y,n);

    return result;
}



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\sincos.c ===
/***
*sincos.c - sine and cosine
*
*       Copyright (c) 1991-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*
*Revision History:
*        8-15-91  GDP   written
*        9-29-91  GDP   added missing ABS() for cosine
*       12-26-91  GDP   IEEE exceptions support
*       03-11-91  GDP   use 66 significant bits for representing pi
*                       support FP_TLOSS, use _frnd for rounding
*       06-23-92  GDP   sin(denormal) now raises underflow exception
*       02-06-95  JWM   Mac merge
*       10-07-97  RDL   Added IA64.
*
*******************************************************************************/

#include <math.h>
#include <trans.h>

#if defined(_M_IA64)
#pragma function(sin, cos)
#endif

static double _sincos(double x, double y, double sin);

/* constants */
static double const EPS = 1.05367121277235079465e-8; /* 2^(-53/2) */
static double const PI     = 3.14159265358979323846;
static double const PI2    = 1.57079632679489661923; /* pi/2 */
static double const PI_INV = 0.31830988618379067154; /* 1/pi */
static double const YMAX   = 2.2e8; /* approx. pi * 2 ^(t/2), where t=53 */

//
// The sum of C1 and C2 is a representation of PI with 66 bits in the
// significand (same as x87). (PI = 4 * 0.c90fdaa2 2168c234 c h)
//

static _dbl _C1  = {SET_DBL (0x400921fb, 0x54400000)};
static _dbl _C2  = {SET_DBL (0x3de0b461, 0x1a600000)};
#define C1  (_C1.dbl)
#define C2  (_C2.dbl)

/* constants for the polynomial approximation of sin, cos */
static double const r1 = -0.16666666666666665052e+0;
static double const r2 =  0.83333333333331650314e-2;
static double const r3 = -0.19841269841201840457e-3;
static double const r4 =  0.27557319210152756119e-5;
static double const r5 = -0.25052106798274584544e-7;
static double const r6 =  0.16058936490371589114e-9;
static double const r7 = -0.76429178068910467734e-12;
static double const r8 =  0.27204790957888846175e-14;

#define R(g)  ((((((((r8 * (g) + r7) * (g) + r6) * (g) + r5) * (g) + r4) \
                         * (g) + r3) * (g) + r2) * (g) + r1) * (g))


/***
*double sin(double x) - sine
*
*Purpose:
*   Compute the sine of a number.
*   The algorithm (reduction / polynomial approximation) is
*   taken from Cody & Waite.
*
*Entry:
*
*Exit:
*
*Exceptions:
*   I, P, U
*   if x is denormal: raise Underflow
*******************************************************************************/
double sin (double x)
{
    uintptr_t savedcw;
    double result;
    double sign,y;

    /* save user fp control word */
    savedcw = _maskfp();

    if (IS_D_SPECIAL(x)){
        switch(_sptype(x)) {
        case T_PINF:
        case T_NINF:
            return _except1(FP_I,OP_SIN,x,QNAN_SIN1,savedcw);
        case T_QNAN:
            return _handle_qnan1(OP_SIN, x, savedcw);
        default: //T_SNAN
            return _except1(FP_I,OP_SIN,x,_s2qnan(x),savedcw);
        }
    }

    if (x == 0.0) {
        // no P exception
        RETURN(savedcw,x);
    }

    if (x < 0) {
        sign = -1;
        y = -x;
    }
    else {
        sign = 1;
        y = x;
    }
    if (y >= YMAX) {

        // The argument is too large to produce a meaningful result,
        // so this is treated as an invalid operation.
        // We also set the (extra) FP_TLOSS flag for matherr
        // support

        return _except1(FP_TLOSS | FP_I,OP_SIN,x,QNAN_SIN2,savedcw);
    }

    result = _sincos(x,y,sign);

    if (IS_D_DENORM(result)) {
        return _except1(FP_U | FP_P,OP_SIN,x,_add_exp(result, IEEE_ADJUST),savedcw);
    }

    RETURN_INEXACT1(OP_SIN,x,result,savedcw);
}


/***
*double cos(double x) - cosine
*
*Purpose:
*   Compute the cosine of a number.
*   The algorithm (reduction / polynomial approximation) is
*   taken from Cody & Waite.
*
*Entry:
*
*Exit:
*
*Exceptions:
*   P, I
*   if x is denormal: return 1
*******************************************************************************/

double cos (double x)
{
    uintptr_t savedcw;
    double result,y;

    /* save user fp control word */
    savedcw = _maskfp();

    if (IS_D_SPECIAL(x)){
        switch(_sptype(x)) {
        case T_PINF:
        case T_NINF:
            return _except1(FP_I,OP_COS,x,QNAN_COS1,savedcw);
        case T_QNAN:
            return _handle_qnan1(OP_COS,x, savedcw);
        default: //T_SNAN
            return _except1(FP_I,OP_COS,x,_s2qnan(x),savedcw);
        }
    }

    /* this will handle small arguments */
    if (ABS(x) < EPS) {
        if (x == 0.0) {
            RETURN(savedcw,1.0);
        }
        result = 1.0;
    }

    else {
        y = ABS(x) + PI2;
        if (y >= YMAX) {

            // The argument is too large to produce a meaningful result,
            // so this is treated as an invalid operation.
            // We also set the (extra) FP_TLOSS flag for matherr
            // support

            return _except1(FP_TLOSS | FP_I,OP_COS,x,QNAN_COS2,savedcw);
        }

        result = _sincos(x,y,1.0);
    }

    RETURN_INEXACT1(OP_COS,x,result,savedcw);
}



/***
*double _sincos(double x, double y,double sign) - cos sin helper
*
*Purpose:
*   Help computing sin or cos of a valid, within correct range
*   number.
*   The algorithm (reduction / polynomial approximation) is
*   taken from Cody & Waite.
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

static double _sincos(double x, double y, double sign)
{
    unsigned long n;
    double xn,f,g,r,result;

    xn = _frnd(y * PI_INV);
    n = (int) xn;

    if (n & 0x1) {
        /* n is odd */
        sign = -sign;
    }
    if (ABS(x) != y) {
        /* cosine wanted */
        xn -= .5;
    }

    /* assume there is a guard digit for addition */
    f = (ABS(x) - xn * C1) - xn * C2;
    if (ABS(f) < EPS)
        result = f;
    else {
        g = f*f;
        r = R(g);
        result = f + f*r;
    }
    result *= sign;

    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\tanh.c ===
/***
*tanh.c - hyperbolic tangent
*
*       Copyright (c) 1991-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*
*Revision History:
*        8-15-91  GDP   written
*       12-22-91  GDP   support IEEE exceptions
*       06-23-92  GDP   tanh(denormal) now raises underflow exception (NCEG)
*       02-06-95  JWM   Mac merge
*       05-17-99  PML   Remove all Macintosh support.
*       07-15-01  PML   Remove all ALPHA, MIPS, and PPC code
*
*******************************************************************************/

#include <math.h>
#include <trans.h>

/* constants */
static double const EPS  = 5.16987882845642297e-26;     /* 2^(-53) / 2 */
static double const XBIG = 1.90615474653984960096e+001; /* ln(2)(53+2)/2 */
static double const C0   = 0.54930614433405484570;      /* ln(3)/2 */

/* constants for rational approximation */
static double const p0 = -0.16134119023996228053e+4;
static double const p1 = -0.99225929672236083313e+2;
static double const p2 = -0.96437492777225469787e+0;
static double const q0 =  0.48402357071988688686e+4;
static double const q1 =  0.22337720718962312926e+4;
static double const q2 =  0.11274474380534949335e+3;
static double const q3 =  0.10000000000000000000e+1;


#define Q(g)    ((((g) + q2) * (g) + q1) * (g) + q0)
#define R(g)    ((((p2 * (g) + p1) * (g) + p0) * (g)) / Q(g))

#if !defined(_M_AMD64)
#pragma function(tanh)
#endif

/***
*double tanh(double x) - hyperbolic tangent
*
*Purpose:
*   Compute the hyperbolic tangent of a number.
*   The algorithm (reduction / rational approximation) is
*   taken from Cody & Waite.
*
*Entry:
*
*Exit:
*
*Exceptions:
*   I P
*******************************************************************************/
double tanh(double x)
{
    uintptr_t savedcw;
    double f,g;
    double result;

    /* save user fp control word */
    savedcw = _maskfp();

    if (IS_D_SPECIAL(x)){
        switch(_sptype(x)) {
        case T_PINF:
            RETURN(savedcw,1.0);
        case T_NINF:
            RETURN(savedcw,-1.0);
        case T_QNAN:
            return _handle_qnan1(OP_TANH, x, savedcw);
        default: //T_SNAN
            return _except1(FP_I,OP_TANH,x,_s2qnan(x),savedcw);
        }
    }

    if (x == 0.0) {
        // no precision exception
        RETURN(savedcw,x);
    }

    f = ABS(x);
    if (f > XBIG) {
        result = 1;
    }
    else if (f > C0) {
        result = 0.5 - 1.0 / (exp(f+f) + 1.0);
        result = result + result;
    }
    else if (f < EPS) {
        result = f;
        if (IS_D_DENORM(result)) {
            return _except1(FP_U | FP_P,OP_TANH,x,_add_exp(x, IEEE_ADJUST),savedcw);
        }
    }
    else {
        g = f * f;
        result = f + f * R(g);
    }

    if (x < 0)
        result = -result;

    RETURN_INEXACT1(OP_TANH,x,result,savedcw);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\util.c ===
/***
*util.c - utilities for fp transcendentals
*
*	Copyright (c) 1991-2001, Microsoft Corporation.	All rights reserved.
*
*Purpose:
*   _set_exp and _add_exp are as those defined in Cody & Waite
*
*Revision History:
*   08-15-91	GDP	written
*   10-20-91	GDP	removed _rint, unsafe_intrnd
*   02-05-92	GDP	added _fpclass
*   03-27-92	GDP	added _d_min
*   06-23-92	GDP	added _d_mzero
*
*******************************************************************************/
#include "trans.h"

/* define special values */

_dbl _d_inf = {SET_DBL (0x7ff00000, 0x0) };	  //positive infinity
_dbl _d_ind = {SET_DBL (D_IND_HI, D_IND_LO)};	  //real indefinite
_dbl _d_max = {SET_DBL (0x7fefffff, 0xffffffff)}; //max double
_dbl _d_min = {SET_DBL (0x00100000, 0x00000000)}; //min normalized double
_dbl _d_mzero = {SET_DBL (0x80000000, 0x00000000)}; //negative zero



double _set_exp(double x, int exp)
/* does not check validity of exp */
{
    double retval;
    int biased_exp;
    retval = x;
    biased_exp = exp + D_BIASM1;
    *D_EXP(retval) = (unsigned short) (*D_EXP(x) & 0x800f | (biased_exp << 4));
    return retval;
}


int _get_exp(double x)
{
    signed short exp;
    exp = (signed short)((*D_EXP(x) & 0x7ff0) >> 4);
    exp -= D_BIASM1; //unbias
    return (int) exp;
}


double _add_exp(double x, int exp)
{
    return _set_exp(x, INTEXP(x)+exp);
}


double _set_bexp(double x, int bexp)
/* does not check validity of bexp */
{
    double retval;
    retval = x;
    *D_EXP(retval) = (unsigned short) (*D_EXP(x) & 0x800f | (bexp << 4));
    return retval;
}


int _sptype(double x)
{
    if (IS_D_INF(x))
	return T_PINF;
    if (IS_D_MINF(x))
	return T_NINF;
    if (IS_D_QNAN(x))
	return T_QNAN;
    if (IS_D_SNAN(x))
	return T_SNAN;
    return 0;
}



/***
*double _decomp(double x, double *expptr)
*
*Purpose:
*   decompose a number to a normalized mantisa and exponent
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

double _decomp(double x, int *pexp)
{
    int exp;
    double man;

    if (x == 0) {
	man = 0;
	exp = 0;
    }
    else if (IS_D_DENORM(x)) {
	int neg;

	exp = 1-D_BIASM1;
	neg = x < 0.0;
	while((*D_EXP(x) & 0x0010) == 0) {
	    /* shift mantissa to the left until bit 52 is 1 */
	    (*D_HI(x)) <<= 1;
	    if (*D_LO(x) & 0x80000000)
		(*D_HI(x)) |= 0x1;
	    (*D_LO(x)) <<= 1;
	    exp--;
	}
	(*D_EXP(x)) &= 0xffef; /* clear bit 52 */
	if (neg) {
	    (*D_EXP(x)) |= 0x8000; /* set sign bit */
	}
	man = _set_exp(x,0);
    }
    else {
	man = _set_exp(x,0);
	exp = INTEXP(x);
    }

    *pexp = exp;
    return man;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\amd64\fpsr.asm ===
include ksamd64.inc

public _get_fpsr
_status$ = 0
        NESTED_ENTRY _get_fpsr, _TEXT$00
        sub     rsp, 8
        .allocstack 8
        .endprolog
        stmxcsr DWORD PTR _status$[rsp]
        mov     eax, DWORD PTR _status$[rsp]
        add     rsp, 8
        ret
        NESTED_END _get_fpsr, _TEXT$00

PUBLIC  _set_fpsr
_TEXT   SEGMENT
_status$ = 8
_set_fpsr PROC NEAR
        mov     DWORD PTR _status$[rsp], ecx
        ldmxcsr DWORD PTR _status$[rsp]
        ret
_set_fpsr       ENDP
_TEXT   ENDS

PUBLIC  _fclrf
_TEXT   SEGMENT
_fclrf PROC    NEAR
        stmxcsr DWORD PTR _status$[rsp]
        mov     ecx, 0ffffffc0h
        and     DWORD PTR _status$[rsp], ecx
        ldmxcsr DWORD PTR _status$[rsp]
	ret
_fclrf ENDP
_TEXT   ENDS

PUBLIC  _frnd
_TEXT   SEGMENT
_frnd PROC NEAR
        cvtpd2dq    xmm(1), xmm(0)
        cvtdq2pd    xmm(0), xmm(1)
        ret
_frnd ENDP
_TEXT   ENDS

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\amd64\ieee.c ===
/***
*ieee.c - ieee control and status routines
*
*   Copyright (c) 1985-2000, Microsoft Corporation
*
*Purpose:
*   IEEE control and status routines.
*
*Revision History:
*
*   04-01-02  GDP   Rewritten to use abstract control and status words
*
*/

#include <trans.h>
#include <float.h>
#include <signal.h>

extern unsigned int _get_fpsr(void);
extern void _set_fpsr(unsigned int);
extern void _fclrf(void);

static unsigned int _abstract_sw(unsigned int sw);
static unsigned int _abstract_cw(unsigned int cw);
static unsigned int _hw_cw(unsigned int abstr);

#define FS         (1<<6)

/***
* _statusfp() -
*
*Purpose:
*	return abstract fp status word
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

unsigned int _statusfp()
{
    unsigned int status;

    status = _get_fpsr();

    return _abstract_sw(status);
}


/***
*_clearfp() -
*
*Purpose:
*	return abstract	status word and clear status
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

unsigned int _clearfp()
{
    unsigned int status;

    status = _get_fpsr();
    _fclrf();

    return _abstract_sw(status);
}



/***	_control87
*() -
*
*Purpose:
*	return and set abstract user fp control word
*	can modify EM_DENORMAL mask
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

unsigned int _control87(unsigned int newctrl, unsigned int mask)
{
    unsigned int oldCw;
    unsigned int newCw;
    unsigned int oldabs;
    unsigned int newabs;

    oldCw = _get_fpsr();

    oldabs = _abstract_cw(oldCw);

    newabs = (newctrl & mask) | (oldabs & ~mask);

    newCw = _hw_cw(newabs);

    _set_fpsr(newCw);

    return newabs;
}					/* _control87() */


/***	_controlfp
*() -
*
*Purpose:
*	return and set abstract user fp control word
*	cannot change denormal mask (ignores _EM_DENORMAL)
*	This is done for portable IEEE behavior on all platforms
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

unsigned int _controlfp(unsigned int newctrl, unsigned int mask)
{
    return _control87(newctrl, mask & ~_EM_DENORMAL);
}


/***
* _abstract_cw() - abstract control word
*
*Purpose:
*   produce a fp control word in abstracted (machine independent) form
*
*Entry:
*   cw:     machine control word
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

unsigned int _abstract_cw(unsigned int cw)
{
    unsigned int abstr = 0;


    //
    // Set exception mask bits
    //

    if (cw & IEM_INVALID)
	abstr |= _EM_INVALID;
    if (cw & IEM_ZERODIVIDE)
	abstr |= _EM_ZERODIVIDE;
    if (cw & IEM_OVERFLOW)
	abstr |= _EM_OVERFLOW;
    if (cw & IEM_UNDERFLOW)
	abstr |= _EM_UNDERFLOW;
    if (cw & IEM_INEXACT)
	abstr |= _EM_INEXACT;
    if (cw & IEM_DENORMAL)
	abstr |= _EM_DENORMAL;

    //
    // Set rounding mode
    //

    switch (cw & IMCW_RC) {
    case IRC_NEAR:
	abstr |= _RC_NEAR;
	break;
    case IRC_UP:
	abstr |= _RC_UP;
	break;
    case IRC_DOWN:
	abstr |= _RC_DOWN;
	break;
    case IRC_CHOP:
	abstr |= _RC_CHOP;
	break;
    }
    return abstr;
}


/***
* _hw_cw() -  h/w control word
*
*Purpose:
*   produce a machine dependent fp control word
*
*
*Entry:
*   abstr:	abstract control word
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

unsigned int _hw_cw(unsigned int abstr)
{
    //
    // Set standard infinity and denormal control bits
    //

    unsigned int cw = 0;

    //
    // Set exception mask bits
    //

    if (abstr & _EM_INVALID)
	cw |= IEM_INVALID;
    if (abstr & _EM_ZERODIVIDE)
	cw |= IEM_ZERODIVIDE;
    if (abstr & _EM_OVERFLOW)
	cw |= IEM_OVERFLOW;
    if (abstr & _EM_UNDERFLOW)
	cw |= IEM_UNDERFLOW;
    if (abstr & _EM_INEXACT)
	cw |= IEM_INEXACT;
    if (abstr & _EM_DENORMAL)
	cw |= IEM_DENORMAL;

    //
    // Set rounding mode
    //

    switch (abstr & _MCW_RC) {
    case _RC_NEAR:
	cw |= IRC_NEAR;
	break;
    case _RC_UP:
	cw |= IRC_UP;
	break;
    case _RC_DOWN:
	cw |= IRC_DOWN;
	break;
    case _RC_CHOP:
	cw |= IRC_CHOP;
	break;
    }
    return cw;
}



/***
* _abstract_sw() - abstract fp status word
*
*Purpose:
*   produce an abstract (machine independent) fp status word
*
*
*Entry:
*   sw:     machine status word
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

unsigned int _abstract_sw(unsigned int sw)
{
    unsigned int abstr = 0;


    if (sw & ISW_INVALID)
	abstr |= _SW_INVALID;
    if (sw & ISW_ZERODIVIDE)
	abstr |= _SW_ZERODIVIDE;
    if (sw & ISW_OVERFLOW)
	abstr |= _SW_OVERFLOW;
    if (sw & ISW_UNDERFLOW)
	abstr |= _SW_UNDERFLOW;
    if (sw & ISW_INEXACT)
	abstr |= _SW_INEXACT;
    if (sw & ISW_DENORMAL)
	abstr |= _SW_DENORMAL;

    return abstr;
}

/***
* _fpreset() - reset fp system
*
*Purpose:
*	reset fp environment to the default state
*	Also reset saved fp environment if invoked from a user's
*	signal handler
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/
void _fpreset()
{
    unsigned int status = ICW;  
//    PEXCEPTION_POINTERS excptrs = (PEXCEPTION_POINTERS) _pxcptinfoptrs;

    //
    // reset fp state
    //

    _set_fpsr(status);

//    if (excptrs &&
//        excptrs->ContextRecord->ContextFlags & CONTEXT_FLOATING_POINT) {
        // _fpreset has been invoked by a signal handler which in turn
        // has been invoked by the CRT filter routine. In this case
        // the saved fp context should be cleared, so that the change take
        // effect on continuation.

//        excptrs->ContextRecord->StFPSR = ICW;
//    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\tan.c ===
/***
*tan.c - tangent
*
*       Copyright (c) 1991-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*
*Revision History:
*        8-15-91  GDP   written
*       12-30-91  GDP   support IEEE exceptions
*       03-11-91  GDP   use 66 significant bits for representing pi
*                       support FP_TLOSS
*       06-23-92  GDP   tan(denormal) now raises underflow exception
*       02-06-95  JWM   Mac merge
*       10-07-97  RDL   Added IA64.
*
*******************************************************************************/

#include <math.h>
#include <trans.h>

#if defined(_M_IA64)
#pragma function(tan)
#endif

/* constants */
static double const TWO_OVER_PI = 0.63661977236758134308;
static double const EPS  = 1.05367121277235079465e-8; /* 2^(-53/2) */
static double const YMAX = 2.98156826864790199324e8; /* 2^(53/2)*PI/2 */

//
// The sum of C1 and C2 is a representation of PI/2 with 66 bits in the
// significand (same as x87). (PI/2 = 2 * 0.c90fdaa2 2168c234 c h)
//

static _dbl _C1  = {SET_DBL (0x3ff921fb, 0x54400000)};
static _dbl _C2  = {SET_DBL (0x3dd0b461, 0x1a600000)};
#define C1  (_C1.dbl)
#define C2  (_C2.dbl)

/* constants for the rational approximation */
/* p0 = 1.0  is not used (avoid mult by 1) */
static double const p1 = -0.13338350006421960681e+0;
static double const p2 =  0.34248878235890589960e-2;
static double const p3 = -0.17861707342254426711e-4;
static double const q0 =  0.10000000000000000000e+1;
static double const q1 = -0.46671683339755294240e+0;
static double const q2 =  0.25663832289440112864e-1;
static double const q3 = -0.31181531907010027307e-3;
static double const q4 =  0.49819433993786512270e-6;


#define Q(g)   ((((q4 * (g) + q3) * (g) + q2) * (g) + q1) * (g) + q0)
#define P(g,f)  (((p3 * (g) + p2) * (g) + p1) * (g) * (f) + (f))

#define ISODD(i) ((i)&0x1)


/***
*double tan(double x) - tangent
*
*Purpose:
*   Compute the tangent of a number.
*   The algorithm (reduction / rational approximation) is
*   taken from Cody & Waite.
*
*Entry:
*
*Exit:
*
*Exceptions:
*   P, I, U
*   if x is denormal: raise underflow
*******************************************************************************/
double tan(double x)
{
    uintptr_t savedcw;
    unsigned long n;
    double xn,xnum,xden;
    double f,g,result;

    /* save user fp control word */
    savedcw = _maskfp();

    if (IS_D_SPECIAL(x)){
        switch(_sptype(x)) {
        case T_PINF:
        case T_NINF:
            return _except1(FP_I,OP_TAN,x,QNAN_TAN1,savedcw);
        case T_QNAN:
            return _handle_qnan1(OP_TAN, x, savedcw);
        default: //T_SNAN
            return _except1(FP_I,OP_TAN,x,_s2qnan(x),savedcw);
        }
    }

    if (x == 0.0)
        RETURN(savedcw, x);

    if (ABS(x) > YMAX) {

        // The argument is too large to produce a meaningful result,
        // so this is treated as an invalid operation.
        // We also set the (extra) FP_TLOSS flag for matherr
        // support

        return _except1(FP_TLOSS | FP_I,OP_TAN,x,QNAN_TAN2,savedcw);
    }

    xn = _frnd(x * TWO_OVER_PI);
    n = (unsigned long) fabs(xn);


    /* assume there is a guard digit for addition */
    f = (x - xn * C1) - xn * C2;
    if (ABS(f) < EPS) {
        xnum = f;
        xden = 1;
        if (IS_D_DENORM(f)) {
            return _except1(FP_U | FP_P,OP_TAN,x,_add_exp(f, IEEE_ADJUST),savedcw);
        }
    }
    else {
        g = f*f;
        xnum = P(g,f);
        xden = Q(g);
    }

    if (ISODD(n)) {
        xnum = -xnum;
        result = xden/xnum;
    }
    else
        result = xnum/xden;

    RETURN_INEXACT1(OP_TAN,x,result,savedcw);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\amd64\fpctrl.c ===
/***
*fpctrl.c - fp low level control and status routines
*
*   Copyright (c) 1985-2000, Microsoft Corporation
*
*Purpose:
*   IEEE control and status routines for internal use.
*   These routines use machine specific constants while _controlfp,
*   _statusfp, and _clearfp use an abstracted control/status word
*
*Revision History:
*
*   03-31-92  GDP   written
*   05-12-92  GJF   Rewrote fdivr as fdivrp st(1),st to work around C8-32
*		    assertions.
*
*/

#include <trans.h>

extern unsigned int _get_fpsr(void);
extern void _set_fpsr(unsigned int);
extern void _fclrf(void);

/***	_statfp
*() -
*
*Purpose:
*	return user status word
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

uintptr_t _statfp()
{
    unsigned int status;

    status = _get_fpsr() & ISW;
    return (uintptr_t)status;
}

/***	_clrfp
*() -
*
*Purpose:
*	return user status word and clear status
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

uintptr_t _clrfp()
{
    unsigned int status;

    status = _get_fpsr() & ISW;
    _fclrf();
    return (uintptr_t)status;
}

/***	_ctrlfp
*() -
*
*Purpose:
*	return and set user control word
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

uintptr_t _ctrlfp(uintptr_t newctrl, uintptr_t _mask)
{
    unsigned int oldCw;
    unsigned int newCw;
    unsigned int tmp;

    oldCw = _get_fpsr();
    newCw = ((unsigned int)(newctrl & _mask) | (oldCw & (unsigned int)~_mask));
    _set_fpsr(newCw);

    return (uintptr_t)oldCw;
}

/***	_set_statfp
*() -
*
*Purpose:
*	force selected exception flags to 1
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

void _set_statfp(uintptr_t sw)
{
    unsigned int status;

    status = _get_fpsr() | ((unsigned int)sw & ISW);
    _set_fpsr(status);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\amd64\huge.asm ===
page	,132
	title   HUGE    - HUGE value
;*** 
;huge.asm - defines HUGE
;
;	Copyright (c) 1984-2000, Microsoft Corporation.  All rights reserved.
;
;Purpose:
;	defines HUGE
;
;Revision History:
;
;   07/04/84	Greg Whitten
;		initial version
;
;   12/21/84	Greg Whitten
;		add assumes so that C can find variable
;
;   09/23/87	Barry C. McCord
;		add _matherr_flag for the sake of the
;		C floating-point intrinsic functions
;
;   08/29/88	Bill Johinston
;		386 version
;
;   08/27/91	JeffRob
;		ANSI naming
;
;   09/06/91	GeorgioP
;		define HUGE as positive infinity
;
;   09/06/91	GeorgioP
;		define _HUGE_dll
;
;   04/05/93	SteveSa
;		undefine _HUGE_dll
;   10/14/93	GregF
;		Restored _HUGE_DLL for _NTSDK
;
;*******************************************************************************

_DATA$00 SEGMENT PARA PUBLIC 'DATA'
        align   8

ifdef	_NTSDK
ifdef	CRTDLL
public	_HUGE_dll
_HUGE_dll dq	7ff0000000000000R
else
public	_HUGE
_HUGE	dq	7ff0000000000000R
endif
else
public	_HUGE
_HUGE	dq	7ff0000000000000R
endif

_DATA$00 ends

	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\i386\87ctrig.asm ===
page	,132
	title	87ctrig - C interfaces - sin, cos, tan
;***
;87ctrig.asm - trig functions (8087/emulator version)
;
;   Copyright (c) 1984-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;   C interfaces for the sin, cos, and tan functions (8087/emulator version)
;
;Revision History:
;   07-04-84  GFW   initial version
;   05-08-87  BCM   added C intrinsic interface (_CI...)
;   10-12-87  BCM   changes for OS/2 Support Library
;   11-24-87  BCM   added _loadds under ifdef DLL
;   01-18-88  BCM   eliminated IBMC20; ifos2,noos2 ==> ifmt,nomt
;   08-26-88  WAJ   386 version
;   11-20-89  WAJ   Don't need pascal for MTHREAD 386.
;
;*******************************************************************************

.xlist
	include cruntime.inc
.list

	.data
extrn _OP_SINjmptab:word
extrn _OP_COSjmptab:word
extrn _OP_TANjmptab:word

page

	CODESEG

extrn	_ctrandisp1:near
extrn	_ctrandisp2:near


	public	oldsin
oldsin	proc

	mov	edx, OFFSET _OP_SINjmptab
trigdisp::
	jmp	_ctrandisp1

oldsin	endp


	public	oldcos
oldcos	proc

	mov	edx, OFFSET _OP_COSjmptab
	jmp	trigdisp

oldcos	endp


	public	oldtan
oldtan	proc

	mov	edx, OFFSET _OP_TANjmptab
	jmp	trigdisp

oldtan	endp


extrn	_cintrindisp1:near
extrn	_cintrindisp2:near


	public	_old_CIsin
_old_CIsin	proc

	mov	edx, OFFSET _OP_SINjmptab
itrigdisp::
	jmp	_cintrindisp1

_old_CIsin	endp


	public	_old_CIcos
_old_CIcos	proc

	mov	edx, OFFSET _OP_COSjmptab
	jmp	itrigdisp

_old_CIcos	endp


	public	_old_CItan
_old_CItan	proc

	mov	edx, OFFSET _OP_TANjmptab
	jmp	itrigdisp

_old_CItan	endp


	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\i386\87csqrt.asm ===
page	,132
	title	87csqrt - C interfaces - sqrt
;***
;87csqrt.asm - sqrt functions (8087/emulator version)
;
;   Copyright (c) 1984-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;   C interfaces for the sqrt function (8087/emulator version)
;
;Revision History:
;   07-04-84  GFW   initial version
;   05-08-87  BCM   added C intrinsic interface (_CIsqrt)
;   10-12-87  BCM   changes for OS/2 Support Library
;   11-24-87  BCM   added _loadds under ifdef DLL
;   01-18-88  BCM   eliminated IBMC20; ifos2,noos2 ==> ifmt,nomt
;   08-26-88  WAJ   386 version.
;   11-20-89  WAJ   Don't need pascal for 386 MTHREAD.
;
;*******************************************************************************

.xlist
	include cruntime.inc
.list


	.data
extrn	_OP_SQRTjmptab:word

page

	CODESEG

extrn	_ctrandisp1:near


	public	oldsqr
oldsqr	proc

	mov	edx, OFFSET _OP_SQRTjmptab
	jmp	_ctrandisp1

oldsqr	endp


extrn	_cintrindisp1:near


	public	_old_CIsqrt
_old_CIsqrt	proc

	mov	edx, OFFSET _OP_SQRTjmptab
	jmp	_cintrindisp1

_old_CIsqrt	endp


	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\i386\87cdisp.asm ===
page	,132
	title	87cdisp  - C transcendental function dispatcher
;*** 
;87cdisp.asm - C transcendental function dispatcher (80x87/emulator version)
;
;   Copyright (c) 1987-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;   Common dispatch code and error handling for C transcendental functions
;
;Revision History:
;   07-04-84  GFW   initial version
;   12-21-84  GFW   correctly point to name in matherr struct
;   05-12-85  GFW   return HUGE correctly signed on ERANGE errors
;		    fill 2nd operand for matherr structure correctly
;   07-05-85  GFW   check for possible overflow on PLOSS errors
;		    in this case OVERFLOW overrides PLOSS
;   07-08-85  GFW   added FWAIT in useHUGE
;   11-20-85  GFW   faster RANGE checking
;   09-30-86  JMB   internationalized error message handling
;   03-09-87  BCM   changed writestr to _wrt2err (extern)
;   04-14-87  BCM   log(0.0) and log10(0.0) sets errno to ERANGE
;		    for MS C 5.0 (ANSI compatible); errno is still
;		    set to EDOM for IBM C 2.0 (System V compatible).
;   04-28-87  BCM   Added _cintrindisp1 and _cintrindisp2
;		    for C "intrinsic" versions of pow, log, log10, exp,
;		    cos, sin, tan, acos, asin, atan, atan2,
;		    cosh, sinh, tanh, sqrt, ... for MS C 5.0
;   08-04-87  BCM   Removed "externP write" declaration.
;   08-17-87  BCM   Changed _wrt2err from near to model-dependent
;		    except for IMBC20; this is because of QC core lib
;   10-12-87  BCM   OS/2 support C library changes
;   11-24-87  BCM   added _loadds under ifdef DLL
;   01-18-88  BCM   eliminated IBMC20; ifos2,noos2 ==> ifmt, nomt
;   02-10-88  WAJ   MTHREAD libraries now lock stderr  when printing errors
;   04-25-88  WAJ   _cpower is on the stack for MTHREAD so must be set to 1
;   07-11-88  WAJ   address of matherr structure was incorrect in MTHREAD case
;   08-24-88  WAJ   386 version.
;   11-20-89  WAJ   386 MTHREAD is no longer _pascal.
;   08-17-90  WAJ   Now uses _stdcall.
;   10-15-90  WAJ   Fixed intrinsic/2 argument problems.
;   05-17-91  WAJ   Added _STDCALL ifdefs.
;   08-27-91  JCR   ANSI naming
;   09-15-91  GDP   Added _cwrt2err. _NMSG_WRITE is no longer _pascal
;   11-15-91  GDP   Removed error message display stuff
;		    moved exception structure to stack frame, even for
;			single thread code (allow recursive calls of
;			transcendentals through matherr)
;		    call _87except after fsave
;		    put Localfac on the stack for multi thread
;   02-10-92  GDP   changed error handling avoid polluting the fp status word
;   03-15-92  GDP   extensive changes in error detection scheme
;   10-27-92  SKS   Re-arranged some code to make this work with MASM 6.10
;   11-06-92  GDP   merged changes from the fp tree on \\vangogh: removed
;		    saveflag, added __fastflag, new range error checking
;   09-06-94  CFW   Replace MTHREAD with _MT.
;   04-06-01  PML   CHECKOVER should check overflow, not underflow (vs7#132450)
;*******************************************************************************

.xlist
	include cruntime.inc
	include mrt386.inc
	include os2supp.inc
	include elem87.inc
.list


EDOM =		33		; math error numbers
ERANGE =	34

EDOMAIN =	120		; internal error number for DOMAIN
ESING = 	121		; internal error number for SING
ETLOSS =	122		; internal error number for TLOSS



	.data

comm	_matherr_flag:dword
extrn	__fastflag:dword

	.const

staticQ DblMax,	      07fefffffffffffffR
staticQ DblMin,       00010000000000000R
staticQ IeeeAdjO,     0c098000000000000R
staticQ IeeeAdjU,     04098000000000000R
staticQ _infinity,    07ff0000000000000R
staticQ _zero,	      00000000000000000R

ifndef	_MT

	.data?

staticQ LocalFac,     ?
intrinflag  db	    ?

else	;_MT


MTStackFrame	struc
    MTS_LocalFac   dq	?
    MTS_cdispflags db	?
MTStackFrame	ends

MTSFISize equ	((size MTStackFrame) + ISIZE - 1) and (not (ISIZE-1))


LocalFac    equ     <MTSF.MTS_LocalFac>
cdispflags  equ     <MTSF.MTS_cdispflags>

INTRINFLAG = 01h
TWOARGFLAG = 02h

endif	;_MT

;	error value action table

;labelW	retvaltab
;    DNCPTR  codeOFFSET useretval
page


	CODESEG

extrn	_trandisp1:near
extrn	_trandisp2:near
extrn	_87except:proc




;----------------------------------------------------------
;
;	intrinsic versions: TRANSCENDENTAL DISPATCH ROUTINES
;
;----------------------------------------------------------
;
;	_cintrindisp1 - Intrinsic Dispatch for 1 arg DP transcendental
;	_cintrindisp2 - Intrinsic Dispatch for 2 arg DP transcendental
;
;	rdx - function dispatch table address
;
;----------------------------------------------------------


_cintrindisp2	proc  uses RBXONLY
	local	DLSF[DSFISize]:IWORD
ifmt	<local	MTSF[MTSFISize]:IWORD>


	fstcw	[DSF.savCntrl]
	fwait

	; store the args in case they are needed by matherr.
	; Generally avoid storing since this may generate
	; various exceptions (overflow, underflow, inexact, invalid)
	; Args will not be available to an exception handler and
	; users should not use /Oi if interested in IEEE conformance

	cmp	[_matherr_flag], 0
	JSE	save2arg

lab resume2

;ifmt	<mov	 [_cpower], 1>	; set _cpower to C semantics
				; DISABLED this feature since pow(0,0)
				; will return 1 in C (NCEG spec) which
				; is the same as in FORTRAN  --GDP


	call	_trandisp2

ifmt	<or	 [cdispflags], (INTRINFLAG OR TWOARGFLAG)>
nomt	<mov	 [intrinflag], 1>

	call	cintrinexit
	ret


lab save2arg
	fxch 
	fst	[DSF.arg1]
	fxch
	fst	[DSF.arg2]
	jmp	resume2

_cintrindisp2	endp


_cintrindisp1	proc  uses RBXONLY
	local	DLSF[DSFISize]:IWORD
ifmt	<local	MTSF[MTSFISize]:IWORD>


	fstcw	[DSF.savCntrl]
	cmp	[_matherr_flag], 0
	JSE	save1arg

lab resume1

	call	_trandisp1

ifmt	<or	 [cdispflags],INTRINFLAG>
ifmt	<and	 [cdispflags],(NOT TWOARGFLAG)>
nomt	<mov	 [intrinflag], 1>

	call	cintrinexit
	ret


lab save1arg
	fst	[DSF.arg1]
	jmp	resume1


_cintrindisp1	endp




;*******************************************************************************
;*
;*	TRANSCENDENTAL DISPATCH ROUTINES
;*
;*******************************************************************************
;*
;*	_ctrandisp1 - Dispatch for 1 arg DP transcendental
;*	_ctrandisp2 - Dispatch for 2 arg DP transcendental
;*
;*	edx - function dispatch table address
;*
;*******************************************************************************

;*
;*  Two arg standard dispatch.
;*

_ctrandisp2  proc  uses ebx, parm1:qword, parm2:qword

	local	DLSF[DSFISize]:IWORD
ifmt   <local  MTSF[MTSFISize]:IWORD>


	push	dword ptr [parm1+4]	 ; load arg1
	push	dword ptr [parm1]
	call	_fload
ifndef _STDCALL
	add	esp, 8
endif
	push	dword ptr [parm2+4]	 ; load arg2
	push	dword ptr [parm2]
	call	_fload
ifndef _STDCALL
	add	esp, 8
endif

	fstcw	[DSF.savCntrl]

ifmt	<or	 [cdispflags], TWOARGFLAG>
ifmt	<mov	 [_cpower], 1>		    ; set _cpower to C semantics

	call	_trandisp2

	call	ctranexit

ifdef _STDCALL
	ret	16
else
	ret
endif

;*
;*  Check for overflow and errors.
;*



ctranexit::

ifmt	<and	 [cdispflags], (NOT INTRINFLAG)>
nomt	<mov	 [intrinflag], 0>

cintrinexit::
	cmp	__fastflag, 0
	JSNZ	restoreCW

	fst	qword ptr [LocalFac]	; cast result to double precision

	;
	; PROBLEM: Since the intrinsics may be given an argument anywhere
	; in the long double range, functions that are not normally
	; expected to overflow (like sqrt) may generate IEEE exceptions
	; at this point. We can cure this by making the checkrange test
	; standard.
	;


	mov	al, [DSF.ErrorType]	; check for errors
	or	al, al
	JE	checkinexact
	cmp	al, CHECKOVER
	JE	checkoverflow
	cmp	al, CHECKRANGE
	JSE	checkrng
	or	al, al
	JSE	restoreCW
	CBI
	mov	[DSF.typ], rax		; set exception type
	jmp	haveerror


lab checkinexact

	; This will be the most common path because of
	; the nature of transcendentals. If inexact is
	; unmasked in user's cw and active, raise it

	mov	ax, [DSF.savCntrl]
	and	ax, 20h
	JSNZ	restoreCW		; inexact exception masked
	fstsw	ax
	and	ax, 20h
	JSZ	restoreCW
	mov	[DSF.typ], INEXACT
	jmp	haveerror


lab restoreCW
lab restoreCW2
	fldcw	[DSF.savCntrl]		; load old control word
	fwait

	retn



lab checkrng
	mov	ax, word ptr [LocalFac+6]	; get exponent part
	and	ax, 07ff0h
	or	ax, ax
	JSE	haveunderflow
	cmp	ax, 07ff0h
	JSE	haveoverflow
	jmp	checkinexact		; assume possibly inexact result


lab checkoverflow
	mov	ax, word ptr [LocalFac+6]	; get exponent part
	and	ax, 07ff0h
	cmp	ax, 07ff0h
	JSE	haveoverflow
	jmp	checkinexact		; assume possibly inexact result


lab haveunderflow
	mov	[DSF.typ], UNDERFLOW
	fld	IeeeAdjU
	fxch
	fscale
	fstp	st(1)
	fld	st(0)
	fabs
	fcomp	[DblMin]
	fstsw	ax
	sahf
	JSAE	haveerror
	fmul	[_zero]
	jmp	short haveerror

lab haveoverflow
	mov	[DSF.typ], OVERFLOW
	fld	IeeeAdjO
	fxch
	fscale
	fstp	st(1)
	fld	st(0)
	fabs
	fcomp	[DblMax]
	fstsw	ax
	sahf
	JSBE	haveerror
	fmul	[_infinity]

lab haveerror
;	fill error structure and call matherr

	push	rsi			; save si
	push	rdi

	mov	rbx, [DSF.Function]	; get function jmp table address
	inc	rbx

	mov	[DSF.nam], rbx		; save name address


ifmt	<test	 cdispflags, INTRINFLAG>
nomt	<cmp	 [intrinflag], 0>

	JSNE	aftercopy
;
; copy function args (for matherr structure) 
;
	cld
	lea	esi, [parm1]
	lea	edi, [DSF.arg1]
	movsd
	movsd
	cmp	[rbx-1].fnumarg, 1	; check for 2nd parameter
	JSE	aftercopy
	lea	esi, [parm2]
	lea	edi, [DSF.arg2]
	movsd
	movsd

lab aftercopy
lab useretval
	fstp	[DSF.retval]		; store return value


	;
	; If intrinsic calling convention, an 'fsave' is required
	; before matherr starts doing any fp operations.
	; (This needs to be documented.)

	lea	rax, [DSF.typ]
	lea	rbx, [DSF.savCntrl]
	push	rbx
	push	rax
	mov	rbx, [DSF.function]
	mov	al, [rbx].fnumber
	CBI
	push	rax
	call	_87except		; _fpexcept(&exception, &savedcw)
ifndef _STDCALL
	add	esp, 12			; clear arguments if _cdecl.
endif

lab movretval
	pop	rdi			; restore di
	pop	rsi			; restore si
	fld	[DSF.retval]		; this assumes that the user
					; does not want to return a
					; signaling NaN

	jmp	restoreCW		;  restore CW and return

_ctrandisp2  endp




;*
;*  One arg standard dispatch.
;*

_ctrandisp1 proc  uses ebx, parm1:qword

	local	DLSF[DSFISize]:IWORD
ifmt   <local	MTSF[MTSFISize]:IWORD>

	push	dword ptr [parm1+4]	 ; load arg1
	push	dword ptr [parm1]
	call	_fload
ifndef _STDCALL
	add	esp, 8
endif

	fstcw	[DSF.savCntrl]

ifmt	<and	 [cdispflags],(NOT TWOARGFLAG)>

	call	_trandisp1

	call	ctranexit

ifdef _STDCALL
	ret	8
else
	ret
endif


_ctrandisp1  endp



;
; Load arg in the fp stack without raising an exception if the argument
; is a signaling NaN
;


_fload	proc	uses ebx, parm:qword
	local	tmp:tbyte

	mov	ax, word ptr [parm+6]  ; get exponent field
	mov	bx, ax		       ; save it
	and	ax, 07ff0h
	cmp	ax, 07ff0h	       ; check for special exponent
	JSNE	fpload
				       ; have special argument (NaN or INF)
	or	bx, 07fffh	       ; preserve sign, set max long double exp
	mov	word ptr [tmp+8], bx
				       ; convert to long double
	mov	eax, dword ptr [parm+4]
	mov	ebx, dword ptr [parm]
	shld	eax, ebx, 11
				       ; the MSB of the significand is
				       ; already 1 because of the exponent value
	mov	dword ptr [tmp+4], eax
	mov	dword ptr [tmp], ebx
	fld	tmp
	jmp	short return

lab fpload
	fld	parm
lab return
ifdef _STDCALL
	ret	8
else
	ret
endif

_fload endp





end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\i386\87ctran.asm ===
page	,132
	title	87ctran - C interfaces - exp, log, log10, pow
;***
;87ctran.asm - exp, log, log10, pow functions (8087/emulator version)
;
;   Copyright (c) 1984-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;   C interfaces for exp, log, log10, pow functions (8087/emulator version)
;
;Revision History:
;   07-04-84  GFW   initial version
;   05-08-87  BCM   added C intrinsic interface (_CI...)
;   10-12-87  BCM   changes for OS/2 Support Library
;   11-24-87  BCM   added _loadds under ifdef DLL
;   01-18-88  BCM   eliminated IBMC20; ifos2,noos2 ==> ifmt,nomt
;   08-26-88  WAJ   386 version
;   11-20-89  WAJ   Don't need pascal for MTHREAD 386.
;   01-26-01  PML   Pentium4 merge.
;
;*******************************************************************************

.xlist
	include cruntime.inc
.list

_FUNC_     equ	<exp>
_FUNC_DEF_ equ	<_exp_default>
_FUNC_P4_  equ	<_exp_pentium4>
_FUNC_P4_EXTERN_ equ 1
	include	disp_pentium4.inc

_FUNC_     equ	<_CIexp>
_FUNC_DEF_ equ	<_CIexp_default>
_FUNC_P4_  equ	<_CIexp_pentium4>
	include	disp_pentium4.inc

	.data

extrn _OP_EXPjmptab:word


page

	CODESEG

extrn	_ctrandisp1:near

	public	_exp_default
_exp_default proc

	mov	edx, OFFSET _OP_EXPjmptab
	jmp	_ctrandisp1

_exp_default endp


extrn	_cintrindisp1:near

	public	_CIexp_default
_CIexp_default proc

	mov	edx, OFFSET _OP_EXPjmptab
	jmp	_cintrindisp1

_CIexp_default endp



	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\i386\87except.c ===
/***
*87except.c - floating point exception handling
*
*	Copyright (c) 1991-2001, Microsoft Corporation.	All rights reserved.
*
*Purpose:
*
*Revision History:
*   8-24-91	GDP	written
*   9-26-91	GDP	changed DOMAIN error handling
*   1-29-91	GDP	renamed to 87exept.c
*   3-15-92	GDP	support raising exceptions
*
*******************************************************************************/
#include <errno.h>
#include <math.h>
#include <trans.h>


#define _DOMAIN_QNAN	7 /* should be in sync with elem87.inc */
#define _INEXACT	8 /* should be in sync with elem87.inc */

int _matherr_flag;
extern void _raise_exc(_FPIEEE_RECORD *prec,unsigned int *pcw,
    int flags, int opcode, double *parg1, double *presult);
extern void _set_errno(int matherrtype);
extern int _handle_exc(unsigned int flags, double * presult, unsigned int cw);




/***
*double _87except(struct _exception *except, unsigned int *cw)
*
*Purpose:
*   Handle floating point exceptions.
*
*Entry:
*
*Exit:
*
*Exceptions:
*******************************************************************************/

void _87except(int opcode, struct _exception *exc, unsigned short *pcw16)
{
    int fixed;
    unsigned int flags;
    unsigned int cw, *pcw;

    //
    // convert fp control word into an unsigned int
    //

    cw = *pcw16;
    pcw = &cw;

    switch (exc->type) {
    case _DOMAIN:
    case _TLOSS:
	flags = FP_I;
	break;
    case _OVERFLOW:
	flags = FP_O | FP_P;
	break;
    case _UNDERFLOW:
	flags = FP_U | FP_P;
	break;
    case _SING:
	flags = FP_Z;
	break;
    case _INEXACT:
	flags = FP_P;
	break;
    case _DOMAIN_QNAN:
	exc->type = _DOMAIN;
	// no break
    default:
	flags = 0;
    }



    if (flags && _handle_exc(flags, &exc->retval, *pcw) == 0) {

	//
	// trap should be taken
	//

	_FPIEEE_RECORD rec;

	//
	// fill in operand2 info. The rest of rec will be
	// filled in by _raise_exc
	//

	switch (opcode) {
	case OP_POW:
	case OP_FMOD:
	case OP_ATAN2:
	    rec.Operand2.OperandValid = 1;
	    rec.Operand2.Format = _FpFormatFp64;
	    rec.Operand2.Value.Fp64Value = exc->arg2;
	    break;
	default:
	    rec.Operand2.OperandValid = 0;
	}

	_raise_exc(&rec,
		   pcw,
		   flags,
		   opcode,
		   &exc->arg1,
		   &exc->retval);
    }


    /* restore cw  */
    _rstorfp(*pcw);

    fixed = 0;

    if (exc->type != _INEXACT &&
	! _matherr_flag) {
	fixed = _matherr(exc);
    }
    if (!fixed) {
	_set_errno(exc->type);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\i386\87ctriga.asm ===
page	,132
	title	87ctriga - C interfaces - asin, acos, atan, atan2
;***
;87ctriga.asm - inverse trig functions (8087/emulator version)
;
;   Copyright (c) 1984-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;   C interfaces for asin, acos, atan, atan2 (8087/emulator version)
;
;Revision History:
;   07-04-84  GFW   initial version
;   05-08-87  BCM   added C intrinsic interface (_CI...)
;   10-12-87  BCM   changes for OS/2 Support Library
;   11-24-87  BCM   added _loadds under ifdef DLL
;   01-18-88  BCM   eliminated IBMC20; ifos2,noos2 ==> ifmt,nomt
;   08-26-88  WAJ   386 version
;   11-20-89  WAJ   Don't need pascal for MTHREAD 386.
;
;*******************************************************************************

.xlist
	include cruntime.inc
.list

	.data

extrn _OP_ATAN2jmptab:word

page

	CODESEG

extrn _ctrandisp2:near

	public	atan2
atan2	proc

	mov	edx, OFFSET _OP_ATAN2jmptab
	jmp	_ctrandisp2

atan2	endp


extrn _cintrindisp2:near

	public	_CIatan2
_CIatan2	proc

	mov	edx, OFFSET _OP_ATAN2jmptab
	jmp	_cintrindisp2

_CIatan2	endp


	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\i386\87disp.asm ===
page	,132
	title	87disp - common transcendental dispatch routine
;*** 
;87disp.asm - common transcendental dispatch routine (80x87/emulator version)
;
;   Copyright (c) 1984-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;   Common transcendental dispatch routine (80x87/emulator version)
;
;Revision History:
;   07-07-84  GFW initial version
;   11-20-85  GFW mask overflow/underflow/precision exceptions;
;		  fixed affine/projective infinity confusion
;   09-12-86  BCM added _Flanguage to distinguish languages
;   10-21-86  BCM use _cpower rather than _Flanguage to
;		  distinguish C and FORTRAN exponentiation semantics
;   06-11-87  GFW faster dispatch code - all in-line
;   10-26-87  BCM minor changes for new cmacros.inc
;   04-25-88  WAJ _cpower is now on stack for MTHREAD
;   08-24-88  WAJ 386 version
;   02-01-92  GDP ported to NT
;   09-06-94  CFW Replace MTHREAD with _MT.
;
;*******************************************************************************

.xlist
	include cruntime.inc
	include mrt386.inc
	include elem87.inc
.list

	.data

globalT _indefinite,  0FFFFC000000000000000R
globalT _piby2,       03FFFC90FDAA22168C235R
staticQ One,	      03FF0000000000000R


ifndef	_MT 	        ; by default assume C pow() semantics
globalB _cpower, 1	; if zero, assume FORTRAN (or other) exponentiation
endif	;_MT	        ;    semantics



labelB	XAMtoTagTab
			    ; C2 C1 C0 C3   Meaning	   Meaning  Tag   0
	db	2 * ISIZE   ;  0  0  0	0  +Unnormal  =>   NAN	     10   0
	db	1 * ISIZE   ;  0  0  0	1  +Zero      =>   Zero      01   0
	db	2 * ISIZE   ;  0  0  1	0  +NAN       =>   NAN	     10   0
	db	2 * ISIZE   ;  0  0  1	1   Empty     =>   NAN	     10   0
	db	2 * ISIZE   ;  0  1  0	0  -Unnormal  =>   NAN	     10   0
	db	1 * ISIZE   ;  0  1  0	1  -Zero      =>   Zero      01   0
	db	2 * ISIZE   ;  0  1  1	0  -NAN       =>   NAN	     10   0
	db	2 * ISIZE   ;  0  1  1	1   Empty     =>   NAN	     10   0
	db	0 * ISIZE   ;  1  0  0	0  +Normal    =>   Valid     00   0
	db	1 * ISIZE   ;  1  0  0	1  +Denormal  =>   Zero      01   0
	db	3 * ISIZE   ;  1  0  1	0  +Infinity  =>   Infinity  11   0
	db	2 * ISIZE   ;  1  0  1	1   Empty     =>   NAN	     10   0
	db	0 * ISIZE   ;  1  1  0	0  -Normal    =>   Valid     00   0
	db	1 * ISIZE   ;  1  1  0	1  -Denormal  =>   Zero      01   0
	db	3 * ISIZE   ;  1  1  1	0  -Infinity  =>   Infinity  11   0
	db	2 * ISIZE   ;  1  1  1	1   Empty     =>   NAN	     10   0


	CODESEG

xamTOS	macro
	cmp	[rdx].fnumber, OP_SQRT	; check for sqrt
	JSNE	cwdefault
	mov	bx, word ptr (DSF.savCntrl)
	or	bh, 2			; set precision control to 53 bits
	and	bh, 0feh
	mov	bl, 03fh		; mask exceptions
	jmp	setcw
lab cwdefault
	mov	bx, 133fh		; default cw
lab setcw
	mov	DSF.setCntrl, bx	; set new control word
	fldcw	DSF.setCntrl		; load new control word
	mov	rbx, dataoffset XAMtoTagTab	; Prepare for XLAT
	fxam
	mov	DSF.Function, rdx	; save function jmp table address
	fstsw	DSF.StatusWord
	mov	DSF.ErrorType, 0	; clear error code
	endm

comdisp macro
	CBI
	and	rcx, 0404h		; clear all but signs from CX
	mov	rbx, rdx
	add	rbx, rax
	add	rbx, size funtab	; skip over name, error vals, etc.
	jmp	[rbx]			; jmp to function
	endm

; Will dispatch  to  the  special  case routines for the single argument
; transcendental functions.  It assumes on  entry  that  the  8087 stack
; has the  argument  on  the  top  of its stack and that DX has been set
; to the address of the dispatch table (which should be in  Tag  order).
; This routine	will  FXAM  the top of the 8087 stack, generate Tag info
; from the condition code, and jump to the corresponding dispatch  table
; entry.  In the process of creating the offset for the XLAT instruction
; bit 2 of CL will be loaded with  the sign of the argument.  DI may not
; be used in any computations.

_trandisp1  proc    near

	xamTOS				; setup control word and check TOS

	fwait
	mov	cl, CondCode
	shl	cl, 1
	sar	cl, 1
	rol	cl, 1
	mov	al, cl
	and	al, 0fh
	xlat

	comdisp

_trandisp1  endp


; Will dispatch to the special case routines  for  the	double	argument
; transcendental functions.   It  assumes on entry that the 8087 has arg1
; next to the top and arg2 on top of the 8087  stack  and  that  DX  has
; been set  to	the  address  of  the dispatch table (which should be in
; Tag-arg1,Tag-arg2  order).   This  routine  will  FXAM  the  top   two
; registers of	the  8087  stack,generate  Tag info from the condition
; codes, and jump to the corresponding	dispatch  table entry.	 In  the
; process of  creating	the  offsets  for  the	XLAT statements bit 2 of
; CH and bit 2 of CL will be loaded with  the  signs  of  the  arguments
; next to the  top and on top, respectively, of  the 8087 stack.  DI may
; not be used in any computations.

_trandisp2  proc    near

	xamTOS				; setup control word and check TOS

	fxch
	mov	cl, CondCode
	fxam
	fstsw	DSF.StatusWord
	fxch
	mov	ch, CondCode
	shl	ch, 1
	sar	ch, 1
	rol	ch, 1
	mov	al, ch
	and	al, 0fh
	xlat
	mov	ah, al
	shl	cl, 1
	sar	cl, 1
	rol	cl, 1
	mov	al, cl
	and	al, 0fh
	xlat
	shl	ah, 1
	shl	ah, 1
	or	al, ah

	comdisp

_trandisp2  endp



page
;----------------------------------------------------------
;
;	SPECIAL CASE RETURN FUNCTIONS
;
;----------------------------------------------------------
;
;	INPUTS - The signs of the last, second to last
;		 arguments are in CH, CL respectively.
;
;	OUTPUT - The result is the stack top.
;
;----------------------------------------------------------

labelNP _rttospopde, PUBLIC
	call	setDOMAIN

labelNP _rttospop, PUBLIC
	fxch				; remove ST(1)

labelNP _rtnospop, PUBLIC
	fstp	st(0)			; remove ST(0)

labelNP _rttosnpop, PUBLIC
	ret				; return TOS

labelNP _rtnospopde, PUBLIC
	call	setDOMAIN
	jmp	_rtnospop


;----------------------------------------------------------

labelNP _rtzeropop, PUBLIC
	fstp	st(0)			; remove ST(0)

labelNP _rtzeronpop, PUBLIC
	fstp	st(0)			; remove ST(0)
	fldz				; push 0.0 onto stack
	ret

;----------------------------------------------------------

labelNP _rtonepop, PUBLIC
	fstp	st(0)			; remove ST(0)

labelNP _rtonenpop, PUBLIC
	fstp	st(0)			; remove ST(0)
	fld1				; push 1.0 onto stack
	ret

;----------------------------------------------------------

isQNAN macro
	fstp	DSF.Fac 		; use ten byte storage
	fld	DSF.Fac
	test	byte ptr [DSF.Fac+7], 40h ; Test for QNaN or SNaN
	endm


labelNP _tosnan1, PUBLIC		; ST(0) is a NaN
	isQNAN
	JSZ	_tossnan1
	mov	DSF.Errortype, DOMAIN_QNAN
	ret
lab _tossnan1
	mov	DSF.Errortype, DOMAIN
	fadd	[One]			; Convert SNaN to QNaN
	ret

labelNP _nosnan2, PUBLIC		; ST(1) is a NaN
	fxch
labelNP _tosnan2, PUBLIC		; ST(0) is a NaN
	isQNAN
	JSZ	_tossnan2
	mov	DSF.Errortype, DOMAIN_QNAN
	jmp	_tosnan2ret
lab _tossnan2
	mov	DSF.Errortype, DOMAIN
lab _tosnan2ret
	fadd				; Propagate NaN and pop
	ret

labelNP _nan2, PUBLIC
	isQNAN
	JSZ	_snan2
	fxch
	isQNAN
	JSZ	_snan2
	mov	DSF.Errortype, DOMAIN_QNAN
	jmp	_nan2ret
lab _snan2
	mov	DSF.Errortype, DOMAIN
lab _nan2ret
	fadd				; Propagate NaN and pop
	ret




;----------------------------------------------------------

labelNP _rtindfpop, PUBLIC
	fstp	st(0)			; remove ST(0)

labelNP _rtindfnpop, PUBLIC
	fstp	st(0)			; remove ST(0)
	fld	[_indefinite]		; push real indefinite onto stack
	cmp	DSF.ErrorType, 0	; if error set
	JSG	retj			;   must be SING, don't set DOMAIN

labelNP _rttosnpopde, PUBLIC
lab setDOMAIN
	mov	DSF.ErrorType, DOMAIN
lab retj
	or	cl, cl			; test sign in cl
	ret


;----------------------------------------------------------

labelNP _rtchsifneg, PUBLIC
	or	cl, cl			; if arg is negative
	JSZ	chsifnegret		;    negate top of stack
	fchs
lab chsifnegret
	ret

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\i386\87ctrigh.asm ===
page	,132
	title	87ctrigh - C interfaces - sinh, cosh, tanh
;***
;87ctrigh.asm - hyperbolic trig functions (8087/emulator version)
;
;   Copyright (c) 1984-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;   C interfaces for sinh, cosh, tanh functions (8087/emulator version)
;
;Revision History:
;   07-04-84  GFW   initial version
;   05-08-87  BCM   added C intrinsic interface (_CI...)
;   10-12-87  BCM   changes for OS/2 Support Library
;   11-24-87  BCM   added _loadds under ifdef DLL
;   01-18-88  BCM   eliminated IBMC20; ifos2,noos2 ==> ifmt,nomt
;   08-26-88  WAJ   386 version
;   11-20-89  WAJ   Don't need pascal for MTHREAD 386.
;
;*******************************************************************************

.xlist
	include cruntime.inc
.list

	.data

extrn _OP_SINHjmptab:word
extrn _OP_COSHjmptab:word
extrn _OP_TANHjmptab:word

page

	CODESEG

extrn _ctrandisp1:near
extrn _ctrandisp2:near


	public	sinh
sinh	proc

	mov	rdx, OFFSET _OP_SINHjmptab
disp1::
	jmp	_ctrandisp1

sinh	endp


	public	cosh
cosh	proc

	mov	rdx, OFFSET _OP_COSHjmptab
	jmp	disp1

cosh	endp


	public	tanh
tanh	proc

	mov	rdx, OFFSET _OP_TANHjmptab
	jmp	disp1

tanh	endp


extrn _cintrindisp1:near
extrn _cintrindisp2:near


	public	_CIsinh
_CIsinh	proc

	mov	rdx, OFFSET _OP_SINHjmptab
idisp1::
	jmp	_cintrindisp1

_CIsinh	endp


	public	_CIcosh
_CIcosh	proc

	mov	rdx, OFFSET _OP_COSHjmptab
	jmp	idisp1

_CIcosh	endp


	public	_CItanh
_CItanh	proc

	mov	rdx, OFFSET _OP_TANHjmptab
	jmp	idisp1

_CItanh	endp


	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\i386\87fmod.asm ===
page	,132
	title	87fmod	 - fmod function
;***
;87fmod.asm - fmod function (8087/emulator version)
;
;   Copyright (c) 1984-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;   Implements fmod() library function for computing floating-point
;   remainder.	Uses FPREM 8087 instruction or its emulated equivalent.
;
;Revision History:
;	12-09-84  GFW	Added copyright message
;	05-12-85  GFW	Changed fmod(x,0) = 0 for System V.2 compatibility
;	10-15-86  GFW	In-line instructions rather than call _fpmath
;	05-08-87  BCM	Added intrinsic version (_CIfmod)
;	10-12-87  BCM	OS/2 support C library changes
;			Including pascal naming and calling conv. & no _fac
;	01-18-88  BCM	Eliminated IBMC20 switches; ifos2,noos2 ==> ifmt,nomt
;			OS2_SUPPORT ==> MTHREAD
;	08-26-88  WAJ	386 version.
;	08-17-90  WAJ	Now uses _stdcall.
;	05-17-91  WAJ	Added _STDCALL ifdefs.
;	03-04-92  GDP	Changed behavior for INF args
;	03-22-92  GDP	Fixed bug: removed fxch out of the remloop
;	09-22-93  SKS	Removed obsolete _FIamod (no longer needed by FORTRAN)
;	12-09-94  JWM	Modified fFMOD to test for bogus Pentiums and call an FPREM workaround
;	12-13-94  SKS	Correct spelling of _adjust_fdiv
;	10-15-95  BWT	Don't do _adjust_fdiv test for NT.
;
;*******************************************************************************


.xlist
	include cruntime.inc
	include mrt386.inc
	include elem87.inc
.list

    .data

ifndef NT_BUILD
extrn	_adjust_fdiv:dword
endif

jmptab	OP_FMOD,4,<'fmod',0,0>,<0,0,0,0,0,0>,2
    DNCPTR	codeoffset fFMOD	; 0000 NOS Valid non-0, TOS Valid non-0
    DNCPTR	codeoffset _rtindfpop	; 0001 NOS Valid non-0, TOS 0
    DNCPTR	codeoffset _tosnan2	; 0010 NOS Valid non-0, TOS NAN
    DNCPTR	codeoffset _rtindfpop	; 0011 NOS Valid non-0, TOS Inf
    DNCPTR	codeoffset _rtzeropop	; 0100 NOS 0, TOS Valid non-0
    DNCPTR	codeoffset _rtindfpop	; 0101 NOS 0, TOS 0
    DNCPTR	codeoffset _tosnan2	; 0110 NOS 0, TOS NAN
    DNCPTR	codeoffset _rtindfpop	; 0111 NOS 0, TOS Inf
    DNCPTR	codeoffset _nosnan2	; 1000 NOS NAN, TOS Valid non-0
    DNCPTR	codeoffset _nosnan2	; 1001 NOS NAN, TOS 0
    DNCPTR	codeoffset _nan2	; 1010 NOS NAN, TOS NAN
    DNCPTR	codeoffset _nosnan2	; 1011 NOS NAN, TOS Inf
    DNCPTR	codeoffset _rtindfpop	; 1100 NOS Inf, TOS Valid non-0
    DNCPTR	codeoffset _rtindfpop	; 1101 NOS Inf, TOS 0
    DNCPTR	codeoffset _tosnan2	; 1110 NOS Inf, TOS NAN
    DNCPTR	codeoffset _rtindfpop	; 1111 NOS Inf, TOS Inf


page

	CODESEG

extrn	_ctrandisp2:near
extrn	_cintrindisp2:near


extrn	_rtindfpop:near
extrn	_rtnospop:near
extrn	_rtzeropop:near
extrn	_tosnan2:near
extrn	_nosnan2:near
extrn	_nan2:near

ifndef NT_BUILD
extrn	_adj_fprem:near
endif

.386

;***
;fFMOD - floating-point remainder (8087/emulator intrinsic version)
;Purpose:
;	fmod(x,y) computes floating-point remainder of x/y, i.e. the
;	floating-point number f such that x = iy + f where f and x have
;	the same sign, and |f| < |y|, and i is an integer.
;
;	Uses the FPREM instruction to compute the remainder.
;	(Formerly used FDIV.)
;
;Entry:
;	floating-point numerator in ST(1)
;	floating-point denominator in ST(0)
;
;Exit:
;	floating-point result in ST(0);
;	(pops one of the arguments, replaces the other with the result)	
;
;Uses:
;	AX, Flags.
;
;Exceptions:
;	fmod(x, 0.0) currently returns 0.0 -- see System V specification
;*******************************************************************************


	public	fmod
fmod	proc

	mov	edx, OFFSET _OP_FMODjmptab
	jmp     _ctrandisp2

fmod	endp


	public	_CIfmod
_CIfmod	proc

	mov	edx, OFFSET _OP_FMODjmptab
	jmp	_cintrindisp2

_CIfmod	endp


lab fFMOD
	fxch

lab remloop

ifdef NT_BUILD				; NT handles the P5 bug in the OS
	fprem				; do fprem's until reduction is done
else
	cmp		_adjust_fdiv, 1
	jz		badP5_fprem
	fprem				; do fprem's until reduction is done
	jmp		fprem_done
lab badP5_fprem
	call	_adj_fprem
lab fprem_done
endif
	fstsw	ax
	fwait
	sahf				; load fprem flags into flags
	JSPE	remloop 		;   not done with range reduction

	fstp	st(1)			; get rid of divisor
	ret


end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\i386\87trig.asm ===
page	,132
	title	87trig	 - trigonometric functions - SIN, COS, TAN
;*** 
;87trig.asm - trigonometric functions - SIN, COS, TAN
;
;	Copyright (c) 1984-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;	Support for SIN, COS, TAN
;
;Revision History:
;
;    11-06-91	 GDP	rewritten for 386
;
;*******************************************************************************

.xlist
	include cruntime.inc
	include mrt386.inc
	include elem87.inc
.list


	.data

extrn	_piby2:tbyte

staticT _piby4,     03FFEC90FDAA22168C235R  ; pi/4
staticD _plossval,  04D000000R		    ; 2^27
staticD _tlossval,  04F000000R		    ; 2^31


	CODESEG

extrn	_rtindfnpop:near
extrn	_rtonenpop:near
extrn	_rttosnpop:near
extrn	_rtinfnpopse:near
extrn	_rttosnpop:near
extrn	_rttosnpopde:near
extrn	_tosnan1:near

;----------------------------------------------------------
;
;	FORWARD TRIGONOMETRIC FUNCTIONS
;
;----------------------------------------------------------
;
;	INPUTS - The argument is the stack top.
;		 The sign of argument is the 04h bit of CL.
;
;	OUTPUT - The result is the stack top.
;
;----------------------------------------------------------

jmponC2 macro	tag
	fstsw	ax
	fwait
	sahf
	JSP	tag
	endm



labelNP _fFCOS, PUBLIC
lab fFCOS
	fcos
	jmponC2	ArgTooLarge
	ret


labelNP _fFSIN, PUBLIC
lab fFSIN
	fsin
	jmponC2	ArgTooLarge
	ret


lab fFTAN
	fptan
	fstsw	ax
	fstp	st(0)		    ; pop TOS (fptan pushed an extra value)
	sahf
	JSP	ArgTooLarge
	ret


lab ArgTooLarge
	mov	DSF.ErrorType, TLOSS	; set TLOSS error
	jmp	_rtindfnpop



end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\i386\acos.asm ===
;***
;
;   Copyright (c) 1984-2001, Microsoft Corporation. All rights reserved.
;
;Revision History:
;
;*******************************************************************************

_ACOS_ equ 1
include triga.asm
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\i386\87sqrt.asm ===
page	,132
	title	87sqrt	 - square root - SQRT
;*** 
;87sqrt.asm - common square root support (80x87/emulator version)
;
;	Copyright (c) 1984-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;	Common support for the sqrt function (80x87/emulator version)
;
;Revision History:
;	07-04-84  GFW initial version
;	10-26-87  BCM minor changes for new cmacros.inc
;	08-24-88  WAJ 386 version
;
;*******************************************************************************

.xlist
	include cruntime.inc
	include mrt386.inc
	include elem87.inc
.list


	CODESEG

extrn	_rtindfnpop:near
extrn	_rttosnpopde:near
extrn	_rtzeronpop:near
extrn	_tosnan1:near

;----------------------------------------------------------
;
;	SQUARE ROOT FUNCTIONS
;
;----------------------------------------------------------

lab fFSQRT
	or	cl,cl			; test sign
	JSNZ	sqrtindfnpop		;    return indefinite if negative
	fsqrt				; calculate the square root of TOS
	ret

lab _rtforsqrtinf
	or	cl,cl			; test sign
	JSNZ	sqrtindfnpop
	ret				; return infinity

lab _rtforsqrtzero			; zero or denormal
	ftst
	fstsw	ax
	fwait
	sahf
	JSNZ	fFSQRT			; denormal operand
	ret				; return +0 or -0 (IEEE std)

lab sqrtindfnpop
	jmp	_rtindfnpop		; return indefinite

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\i386\87tran.asm ===
page	,132
	title	87tran	 - elementary functions - EXP, LOG, LN, X^Y
;***
;87tran.asm - elementary functions - EXP, LOG, LN, X^Y
;
;	Copyright (c) 1984-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;	Support for  EXP, LOG, LN, X^Y (80x87/emulator version)
;
;Revision History:
;
;   07/04/84	Greg Whitten
;		initial version
;
;   07/05/85	Greg Whitten
;		support x ^ y where x < 0 and y is an integer
;
;   07/08/85	Greg Whitten
;		corrected value of infinity (was a NaN)
;
;   07/26/85	Greg Whitten
;		make XENIX version truely System V compatible
;
;   10/31/85	Jamie Bariteau
;		made _fFEXP and _fFLN public labels
;
;   05/29/86	Jamie Bariteau
;		make pow return values conform to System V and
;		ANSI C standards
;
;   09/12/86	Barry McCord
;		added FORTRAN specific code to deal
;		with zero**nonpositive;
;		it requires run-time switching on language
;		for mixed-language support
;
;   10/09/86	Barry McCord
;		cotan(0.0) ==> SING error (jmp _rtinfnpopse),
;		return infinity
;
;   06/11/87	Greg Whitten
;		faster transcendental functions
;
;   06/24/87	Barry McCord
;		fixed FORTRAN 4.01 bug (bcp #1801) in which
;		an expression of the form
;		   (small positive less than one) ** (large positive)
;		was overflowing instead of underflowing to zero
;
;   10/30/87	Bill Johnston
;		made changes for os/2 support.
;
;   04/25/88	Bill Johnston
;		_cpower is now on stack for MTHREAD
;
;   05/01/88	Bill Johnston
;		si was being trashed in MTHREAD
;
;   06/03/88	Bill Johnston
;		fixed neg ^ int int MTHREAD case
;
;   08/24/88	Bill Johnston
;		386 version
;
;   11/15/91	Georgios Papagiannakopoulos
;		NT port. call _powhlp to handle special cases for pow()
;
;   04/01/91	Georgios Papagiannakopoulos
;		fixed special values: log(-INF), log(0), pow(0, neg)
;
;   10/27/92    Steve Salisbury
;		Move declaration of _powhlp out of .data declarations
;		This fix is required for use with MASM 6.10.
;
;   11/06/92	Georgios Papagiannakopoulos
;		changed special return values for NCEG conformance
;
;   09/06/94    Chris Weight
;               Change MTHREAD to _MT.
;
;   12/09/94	Jamie MacCalman
;		Modified fFEXP to test for bogus Pentiums and call an FDIV workaround
;
;   12/13/94	SKS	Correct spelling of _adjust_fdiv
;
;	10-15-95  BWT	Don't do _adjust_fdiv test for NT.
;
;*******************************************************************************

.xlist
	include cruntime.inc
	include mrt386.inc
	include elem87.inc
	include os2supp.inc
.list

	.data

globalT _infinity,	07FFF8000000000000000R
globalT _minfinity,	0FFFF8000000000000000R
globalT _logemax,	0400DB1716685B9D7A7DCR

staticT _log2max,	0400DFFFF000000000000R
staticT _smallarg,	03FFD95F619980C4336F7R
staticQ _half,		03fe0000000000000R

SBUFSIZE EQU	108

ifndef _MT
staticT _temp, 0
extrn	_cpower:byte
endif

ifndef NT_BUILD
extrn	_adjust_fdiv:dword
endif


jmptab	OP_EXP,3,<'exp',0,0,0>,<0,0,0,0,0,0>,1
    DNCPTR	codeoffset fFEXP       ; 0000 TOS Valid non-0
    DNCPTR	codeoffset _rtonenpop	; 0001 TOS 0
    DNCPTR	codeoffset _tosnan1	; 0010 TOS NAN
    DNCPTR	codeoffset _rtforexpinf ; 0011 TOS Inf

page

	CODESEG


extrn	_rtindfpop:near
extrn	_rtindfnpop:near
extrn	_rtnospop:near
extrn	_rtonepop:near
extrn	_rtonenpop:near
extrn	_rttospop:near
extrn	_rttosnpop:near
extrn	_rttosnpopde:near
extrn	_rtzeronpop:near
extrn	_tosnan1:near
extrn	_tosnan2:near
extrn	_nosnan2:near
extrn	_nan2:near
extrn	_powhlp:proc

ifndef NT_BUILD
extrn	_safe_fdivr:near
endif

;----------------------------------------------------------
;
;	LOG AND EXPONENTIAL FUNCTIONS
;
;----------------------------------------------------------
;
;	INPUTS - For single argument functions the argument
;		 is the stack top.  For fFYTOX the base
;		 is next to stack top, the exponent is
;		 the stack top.
;		 For single argument functions the sign is
;		 in bit 2 of CL.  For fFYTOX the base
;		 sign is bit 2 of CH, the exponent
;		 sign is bit 2 of CL.
;
;	OUTPUT - The result is the stack top
;
;----------------------------------------------------------

lab fFYTOX
	mov	DSF.ErrorType, CHECKRANGE ; indicate possible over/under flow on exit
	or	ch,ch		    ; base < 0
	JSNZ	negYTOX 	    ;	 check for integer power
	fxch			    ; TOS = base , NOS = exponent


lab fFXTOY
	fyl2x			    ; compute y*log2(x)
	jmp	short fF2X	    ; compute 2^(y*log2(x))



;-----------------------------------------------
;
;   Entry for exponential function (exp)
;
;-----------------------------------------------

labelNP _fFEXP, PUBLIC
lab fFEXP
	mov	DSF.ErrorType, CHECKRANGE ; indicate possible over/under flow on exit
	xor	ch,ch		    ; result is always positive
	fldl2e
	fmul			    ; convert log base e to log base 2

lab fF2X
	call	_ffexpm1	    ; get exponent and (2^fraction)-1
	fld1
	fadd
	test	CondCode,1	    ; if fraction > 0 (TOS > 0)
	JSZ	ExpNoInvert	    ;	 bypass 2^x invert
	fld1
ifdef NT_BUILD			    ; NT always handles the P5 bug in the OS
	fdivrp	st(1),st(0)
else
	cmp		_adjust_fdiv, 1
	jz		badP5_fdivr
	fdivrp	st(1),st(0)
	jmp		fdivr_done
lab badP5_fdivr
	call	_safe_fdivr
lab fdivr_done

endif

lab ExpNoInvert
	test	dl,040h 	    ; if integer part was zero
	JSNZ	ExpScaled	    ;	 bypass scaling to avoid bug
	fscale			    ; now TOS = 2^x

lab ExpScaled
	or	ch,ch		    ; check for negate flag
	JSZ	expret
	fchs			    ; negate result (negreal ^ odd integer)
lab expret
	jmp	_rttospop



lab negYTOX			    ; check for negreal ^ integer
	call	_isintTOS
	or	eax, eax
	JSE	negYTOXerror
	xor	ch,ch
	cmp	eax, 2
	JSE	evenexp
	not	ch		    ; ch <> 0 means negative result
lab evenexp
	fxch
	fabs			    ; x is positive
	jmp	fFXTOY		    ; continue with ch <> 0 for neg result


lab _rtfor0to0
	;cmp	[_cpower], 1	    ; DISABLED (conform to NCEG spec)
	;JSE	c_0to0		    ; C requires a DOMAIN error for System V compat.
	jmp	_rtonepop	    ; MS FORTRAN has 0.0**0.0 == 1.0


c_0to0::			; System V needs DOMAIN error with 0.0 return

lab negYTOXerror
lab Yl2XArgNegative
	jmp 	_rtindfpop	; DOMAIN error or SING error
				; top of stack now has a NAN
				; 	code in 87cdisp replaces this with
				;		proper System V return value
				;		(for C only)
				;	FORTRAN keeps indefinite value but
				;		currently aborts on DOMAIN
				;		and SING errors


; FORTRAN SING error (return infinity)
;	e.g. 0.0**negative
;	and  cotan(0.0)
;

labelNP _rtinfpopse, PUBLIC
	fstp	st(0)		

labelNP _rtinfnpopse, PUBLIC
	fstp	st(0)
	fld	tbyte ptr [_infinity]
	mov	DSF.ErrorType, SING
	ret

labelNP _fFLN, PUBLIC
lab fFLN
	fldln2
	fxch
	ftst
	fstsw	DSF.StatusWord
	fwait
	test	CondCode, 041H		; if arg is negative or zero
	JSNZ	Yl2XArgNegative 	;    return a NAN

	fyl2x				; compute y*log2(x)
	ret


;-------------------------------------------------------
;
; Logarithmic functions (log and log 10) entry points
;
;-------------------------------------------------------

lab _rtforln0				; (we don't distinguish +0, -0)
	mov	DSF. ErrorType, SING	; set SING error
	fstp	st(0)
	fld	tbyte ptr [_minfinity]
	ret

lab _rtforloginf
	or	cl, cl			; check sign
	JSNZ	tranindfnpop		; if negetive return indefinite
	ret				; else return +INF
					; no overflow in this case (IEEE)





lab fFLOGm
	fldlg2				; main LOG10 entry point
	jmp	short fFYL2Xm

lab fFLNm				; main LN entry point
	fldln2

lab fFYL2Xm
	fxch
	or	cl, cl			; if arg is negative
	JSNZ	Yl2XArgNegative 	;    return a NAN
	fyl2x				; compute y*log2(x)
	ret

page

lab _rtforyto0
	jmp	_rtonepop		; return 1.0


lab _rtfor0tox
	call	_isintTOS
	fstp	st(0)
	fstp	st(0)
	or	cl, cl			; if 0^(-valid)
	JSNZ	_rtfor0toneg		;    do more checking
	fldz
	cmp	eax, 1		; eax has the return value of _isintTOS
	JSNE	zerotoxdone
	or	ch, ch
	JSE	zerotoxdone
	fchs
lab zerotoxdone
	ret


lab _rtfor0toneg
	mov	DSF.ErrorType, SING
	fld	tbyte ptr [_infinity]
	cmp	eax, 1		; eax has the return value of _isintTOS
	JSNE	zerotoxdone
	or	ch, ch
	JSE	zerotoxdone
	fchs
	jmp	zerotoxdone


lab tranzeropop
	fstp	st(0)			; toss 1 stack entry

lab tranzeronpop
	jmp	_rtzeronpop


lab tranindfpop
	fstp	st(0)			; toss 1 stack entry

lab tranindfnpop
	jmp	_rtindfnpop


lab ExpArgOutOfRange
	pop	rax			; remove return address from stack
					; We need to check the sign of the
					; exponent to distinguish underflow
					; from overflow.  We cannot just check
					; CL directly since for the XtoY case,
					; the exponent is a product of Y*log2(x)
					; and not an original argument that
					; has already been thru FXAM.  So,
					; the following instructions were
					; substituted to fix FORTRAN 4.01
					; bcp #1801)

	ftst				; check if exponent was negative large
	fstsw	DSF.StatusWord
	fwait
	test	CondCode, 01h		; if valid^(-large)
	JSNZ	zeronpopue		; underflow error/return zero
	fstp	st(0)			; else return infinity/overflow
	fld	[_infinity]
	or	ch, ch
	JSZ	_expbigret
	fchs
lab _expbigret
	ret

lab zeronpopue
	mov	DSF.ErrorType, UNDERFLOW
	jmp	_rtzeronpop


labelNP _rtinfpop, PUBLIC
	fstp	st(0)			; remove ST(0)

labelNP _rtinfnpop, PUBLIC
	fstp	st(0)			; remove ST(0)
	fld	[_infinity]		; push infinity onto stack
lab setOVERFLOW
	mov	DSF.ErrorType, OVERFLOW ;  set OVERFLOW error
	ret


lab _rtforexpinf
	or	cl, cl
	JSNZ	tranzeronpop		; if exp(-infinity) return +zero
	fstp	st(0)
	fld	[_infinity]		; return infinity, no overflow
	ret

labelNP _ffexpm1, PUBLIC
	fld	st(0)			; copy TOS
	fabs				; make TOS +ve
	fld	[_log2max]		; get log2 of largest number
	fcompp
	fstsw	DSF.StatusWord
	fwait
	test	CondCode, 041H		; if abs(arg) >= 2^15-.5
	JSNZ	ExpArgOutOfRange	;    perform arg out of range routine
	fld	st(0)			; copy TOS
	frndint 			; near round to integer
	ftst
	fstsw	DSF.StatusWord
	fwait
	mov	dl, CondCode		; save sign of integer part
	fxch				; NOS gets integer part
	fsub	st,st(1)		; TOS gets fraction
	ftst
	fstsw	DSF.StatusWord		; store sign of fraction
	fabs
	f2xm1
	ret

;
; returns 0, 1, 2 if TOS is non-int, odd int or even int respectively
;

lab _isintTOS
	fld	st(0)
	frndint
	fcomp
	fstsw	ax
	sahf
	JSNE	notanint
	fld	st(0)		    ; it is an integer
	fmul	[_half]
	fld	st(0)
	frndint
	fcompp
	fstsw	ax
	sahf
	JSE	evenint
	mov	eax, 1
lab _isintTOSret
	ret
lab notanint
	mov	eax, 0
	jmp	_isintTOSret
lab evenint
	mov	eax, 2
	jmp	_isintTOSret






lab _usepowhlp

	push	rsi			; save rsi
	sub	rsp, SBUFSIZE+8 	; get storage for _retval and savebuf
	mov	rsi, rsp
	push	rsi			; push address for result

	sub	rsp, 8
	fstp	qword ptr [rsp]
	sub	rsp, 8
	fstp	qword ptr [rsp]

	fsave	[rsi+8]
	call	_powhlp
ifndef _STDCALL
	add	esp, 16+ISIZE		; clear arguments if _cdecl.
endif
	frstor	[rsi+8]
	fld	qword ptr [rsi] 	; load result on the NDP stack
	add	rsp, SBUFSIZE+8		; get rid of storage
	pop	rsi			; restore rsi

	test	rax, rax		; check return value for domain error
	JSZ	noerror
	jmp	_rttosnpopde

lab	noerror
	ret



end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\i386\87trigh.asm ===
page	,132
	title   87trigh   - hyperbolic trigonometric functions - SINH, COSH, TANH
;*** 
;87trigh.asm - hyperbolic trigonometric functions - SINH, COSH, TANH
;
;   Copyright (c) 1984-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;   Routines for SINH, COSH, TANH
;
;Revision History:
;
;   07/04/84	Greg Whitten
;		initial version
;
;   10/31/85	Jamie Bariteau
;		made _fFSINH and _fFCOSH public labels
;
;   10/30/87	Bill Johnston
;		Minor changes for new cmacros.
;
;   08/25/88	Bill Johnston
;		386 version.
;
;   02/10/92	Georgios Papagiannakopoulos
;		NT port --used CHECKOVER for detection of overflow
;
;*******************************************************************************

.xlist
	include cruntime.inc
	include mrt386.inc
	include elem87.inc
.list

	.data

extrn	_logemax:tbyte
extrn	_infinity:tbyte
staticT _tanhmaxarg,	04003987E0C9996699000R

jmptab	OP_SINH,4,<'sinh',0,0>,<0,0,0,0,0,0>,1
    DNCPTR	codeoffset fFSINH	; 0000 TOS Valid non-0
    DNCPTR	codeoffset _rttosnpop	; 0001 TOS 0
    DNCPTR	codeoffset _tosnan1	; 0010 TOS NAN
    DNCPTR	codeoffset _rtforsnhinf ; 0011 TOS Inf

jmptab	OP_COSH,4,<'cosh',0,0>,<0,0,0,0,0,0>,1
    DNCPTR	codeoffset fFCOSH      ; 0000 TOS Valid non-0
    DNCPTR	codeoffset _rtonenpop	; 0001 TOS 0
    DNCPTR	codeoffset _tosnan1	; 0010 TOS NAN
    DNCPTR	codeoffset _rtforcshinf	; 0011 TOS Inf

jmptab	OP_TANH,4,<'tanh',0,0>,<0,0,0,0,0,0>,1
    DNCPTR	codeoffset fFTANH      ; 0000 TOS Valid non-0
    DNCPTR	codeoffset _rttosnpop	; 0001 TOS 0
    DNCPTR	codeoffset _tosnan1	; 0010 TOS NAN
    DNCPTR	codeoffset _rtfortnhinf ; 0011 TOS Inf

page

	CODESEG

extrn	_ffexpm1:near
extrn	_rtchsifneg:near
extrn	_rtindfnpop:near
extrn	_rtinfnpop:near
extrn	_rtonenpop:near
extrn	_rttospop:near
extrn	_rttosnpop:near
extrn	_rttosnpopde:near
extrn	_tosnan1:near

;----------------------------------------------------------
;
;       HYPERBOLIC FUNCTIONS
;
;----------------------------------------------------------
;
;       INPUTS - The argument is the stack top.
;                The sign of the argument is bit 2 of CL.
;
;       OUTPUT - The result is the stack top
;
;----------------------------------------------------------


labelNP _fFSINH, PUBLIC
lab fFSINH
	mov	DSF.ErrorType, CHECKOVER ; indicate possible overflow on exit
	call	fFEXPH			; compute e^x for hyperbolics
	or	bl, bl			; if e^x is infinite
	JSZ	_rtforsnhlarge		;    return as if x = affine infinity
	call	ExpHypCopyInv		; TOS = e^(-x), NOS = e^x
	fsubp	st(1), st(0)		; compute e^x - e^(-x) for hyperbolics
	jmp	short SinhCoshReturn


lab fFTANH
	fld	st(0)			; copy TOS
	fabs				; make TOS +ve
	fld	[_tanhmaxarg]		; get largest arg, roughly ln(2)(55)/2
	fcompp
	fstsw	DSF.StatusWord
	fwait
	test	CondCode, 041h		; if abs(arg) > XBIG (see tanh.h)
	JSNZ	_rtfortnhlarge		;    return as if x = affine infinity
	call	fFEXPH			; compute e^x for hyperbolics
	or	bl, bl			; if e^x is infinite
	JSZ	_rtfortnhlarge		;    return as if x = affine infinity
	fld	st(0)			; copy TOS
	call	ExpHypSum		; compute e^x + e^(-x) for hyperbolics
	fxch				; get copy of e^x
	call	ExpHypCopyInv		; TOS = e^(-x), NOS = e^x
	fsubp	st(1), st(0)		; compute e^x - e^(-x) for hyperbolics
	fdivrp	st(1), st(0)		; now TOS = tanh(x)
	ret


labelNP _fFCOSH, PUBLIC
lab fFCOSH
	mov	DSF.ErrorType, CHECKOVER ; indicate possible overflow on exit
	call	fFEXPH			; compute e^x for hyperbolics
	or	bl, bl			; if e^x is infinite
	JSZ	_rtforcnhlarge		;    return as if x = affine infinity
	call	ExpHypSum		; compute e^x + e^(-x) for hyperbolics

lab SinhCoshReturn
	fld1
	fchs
	fxch
	fscale				; divide result by 2
	jmp	_rttospop

page

lab _rtforsnhinf
	fstp	st(0)
	fld	[_infinity]
	jmp	_rtchsifneg		; change sign if argument -ve

lab _rtforcshinf
	fstp	st(0)
	fld	[_infinity]
	ret

lab infpositive
	ret

lab _rtforsnhlarge
	call	_rtinfnpop		; TOS = infinity

lab chsifneg
	jmp	_rtchsifneg		; change sign if argument -ve


lab _rtforcnhlarge
	jmp	_rtinfnpop		; TOS = infinity


lab _rtfortnhlarge
	mov	DSF.ErrorType, INEXACT
lab _rtfortnhinf
	call	_rtonenpop		; TOS = one
	jmp	chsifneg		; change sign if argument -ve

page

lab fFEXPH
	fldl2e
	fmul				; convert log base e to log base 2
	xor	rbx, rbx		; clear e^x, finite result flags
	call	_ffexpm1		; TOS = e^|x|-1 unscaled, NOS = scale
	not	bl			; set finite result flag
	test	CondCode, 1		; if fraction > 0 (TOS > 0)
	JSZ	ExpHypNoInvert		;    bypass e^x-1 invert
	call	ExpHypCopyInv		; TOS = e^(-x)-1, NOS = e^x-1
	fxch
	fstp	st(0)			; remove NOS

lab ExpHypNoInvert
	test	dl, 040h		; if integer part was zero
	JSNZ	ExpHypScaled		;    bypass scaling to avoid bug
	not	bh			; set e^x flag
	fld1
	fadd				; TOS = e^x unscaled
	fscale				; now TOS = e^x

lab ExpHypScaled
	jmp	_rttospop		; TOS = e^x-1 or e^x scaled

lab ExpHypSum
	call	ExpHypCopyInv		; TOS = e^(-x), NOS = e^x
	fadd				; TOS = e^x + e^(-x)
	or	bh, bh			; if e^x flag set
	JSNZ	ExpHypSumReturn 	;    bypass e^x-1 adjust
	fld1
	fadd	st(1),st
	fadd				; add 2 to result

lab ExpHypSumReturn
	ret

lab ExpHypCopyInv
	fld	st(0)			; TOS = e^x (or e^x-1)
	fld1				; TOS = 1, NOS = e^x (or e^x-1)
	or	bh, bh			; if e^x flag set
	JSNZ	ExpHypCopyInvReturn	;    bypass e^x-1 adjust
	fadd	st, st(1)		; TOS = e^x, NOS = e^x-1
	fchs				; TOS = -e^x, NOS = e^x-1
	fxch				; TOS = e^x-1, NOS = -e^x

lab ExpHypCopyInvReturn
	fdivrp	st(1), st(0)		; TOS = e^(-x) (or e^(-x)-1)
	ret

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\i386\87triga.asm ===
page	,132
        title   87triga   - inverse trigonometric functions - ASIN, ACOS, ATAN
;*** 
;87triga.asm - inverse trigonometric functions - ASIN, ACOS, ATAN
;
;   Copyright (c) 1984-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;   Routines for ASIN, ACOS, ATAN
;
;Revision History:
;
;   07/04/84	Greg Whitten
;		initial version
;
;   10/01/84	Brad Verheiden
;		Fixed bug in _rtforatnby0 which did not remove an
;		element from the floating stack
;
;   10/28/85	Jamie Bariteau
;		Added comment about inputs to fFATN2, made fFATN2
;		public
;		made _fFATN2 and _rtpiby2 public labels
;
;   10/30/87	Bill Johnston
;		Minor changes for new cmacros.
;
;   08/25/88	Bill Johnston
;		386 version.
;
;   02/10/92	Georgios Papagiannakopoulos
;		NT port -- Bug fix for atan(-INF)
;
;   03/27/92	GDP  support underflow
;
;   01/03/96	JWM  Modify return value of atan2(0,0)
;
;   05/10/00    GB   Modify return value for atan2(-0.0, 1.0)
;
;*******************************************************************************

.xlist
	include cruntime.inc
	include mrt386.inc
	include elem87.inc
.list



	.data

extrn	_indefinite:tbyte
extrn	_piby2:tbyte

jmptab	OP_ATAN2,5,<'atan2',0>,<0,0,0,0,0,0>,2
    DNCPTR	codeoffset fFATN2	; 0000 NOS Valid non-0, TOS Valid non-0
    DNCPTR	codeoffset _rtforatnby0 ; 0001 NOS Valid non-0, TOS 0
    DNCPTR	codeoffset _tosnan2	; 0010 NOS Valid non-0, TOS NAN
    DNCPTR	codeoffset _rtforatn20	; 0011 NOS Valid non-0, TOS Inf
    DNCPTR	codeoffset _rtforatn20	; 0100 NOS 0, TOS Valid non-0
    DNCPTR	codeoffset _rtforatn20  ; 0101 NOS 0, TOS 0
    DNCPTR	codeoffset _tosnan2	; 0110 NOS 0, TOS NAN
    DNCPTR	codeoffset _rtforatn20	; 0111 NOS 0, TOS Inf
    DNCPTR	codeoffset _nosnan2	; 1000 NOS NAN, TOS Valid non-0
    DNCPTR	codeoffset _nosnan2	; 1001 NOS NAN, TOS 0
    DNCPTR	codeoffset _nan2	; 1010 NOS NAN, TOS NAN
    DNCPTR	codeoffset _nosnan2	; 1011 NOS NAN, TOS Inf
    DNCPTR	codeoffset _rtforatnby0	; 1100 NOS Inf, TOS Valid non-0
    DNCPTR	codeoffset _rtforatnby0	; 1101 NOS Inf, TOS 0
    DNCPTR	codeoffset _tosnan2	; 1110 NOS Inf, TOS NAN
    DNCPTR	codeoffset _rtindfpop	; 1111 NOS Inf, TOS Inf

page


	CODESEG

extrn	_rtchsifneg:near
extrn	_rtindfpop:near
extrn	_rtindfnpop:near
extrn	_rtnospop:near
extrn	_rtonenpop:near
extrn	_rttospop:near
extrn	_rttosnpop:near
extrn	_rttosnpopde:near
extrn	_rtzeronpop:near
extrn	_tosnan1:near
extrn	_tosnan2:near
extrn	_nosnan2:near
extrn	_nan2:near

;----------------------------------------------------------
;
;       INVERSE TRIGONOMETRIC FUNCTIONS
;
;----------------------------------------------------------
;
;       INPUTS - For single argument functions the argument
;                is the stack top.  For fFATN2 the numerator
;                is next to stack top, the denominator is
;                the stack top.
;                For single argument functions the sign is
;                in bit 2 of CL.  For fFATN2 the numerator
;                sign is bit 2 of CH, the denominator
;                sign is bit 2 of CL.
;
;		 Note:
;		 _clog calls fFATN2 with the signs of the arguments
;		 in bit 0 of CL and CH respectively.  This should
;		 work since fFATN2 tests for sign of numerator and
;		 denominator by using "or CL,CL" and "or CH,CH"
;
;       OUTPUT - The result is the stack top
;
;----------------------------------------------------------

lab fFASN
	call	AugmentSinCos		; num.=arg, den.=sqrt(1-arg^2)
	xchg	ch, cl			; sign(num.)=sign(arg)
	jmp	short fFPATAN


lab fFACS
	call	AugmentSinCos		; num.=arg, den.=sqrt(1-arg^2)
	fxch				; num.=sqrt(1-arg^2), den.=arg
	jmp	short fFPATAN


lab fFATN
	fabs
	fld1				; denominator is 1
	mov	ch, cl
	xor	cl, cl			; sign of denominator is +ve
	jmp	short fFPATAN


labelNP _fFATN2, PUBLIC
lab fFATN2
	mov	DSF.ErrorType, CHECKRANGE ; indicate possible over/under flow on exit
	fabs
	fxch
	fabs
	fxch

lab fFPATAN
	fpatan				; compute partial arctangent
	or	cl, cl			; if denominator was +ve
	JSZ	PatanNumeratorTest	;    bypass -ve denominator adjust
	fldpi
	fsubrp	st(1), st(0)		; change Patan to pi - Patan

lab PatanNumeratorTest
	or	ch, ch			; if numerator was +ve
	JSZ	PatanDone		;    bypass -ve numerator adjust
	fchs				; change Patan to -Patan

lab PatanDone
	ret

page

lab AugmentSinCos
	fabs				; NOS=x = |input|
	fld	st(0)			; NOS=x, TOS=x
	fld	st(0)			; NNOS=x, NOS=x, TOS=x
	fld1				; NNNOS=x, NNOS=x, NOS=x, TOS=1
	fsubrp	st(1),st(0)		; NNOS=x, NOS=x, TOS=1-x
	fxch				; NNOS=x, NOS=1-x, TOS=x
	fld1				; NNNOS=x, NNOS=1-x, NOS=x, TOS=1
	fadd				; NNOS=x, NOS=1-x, TOS=1+x
	fmul				; NOS=x, TOS=1-x^2
	ftst
	fstsw	DSF.StatusWord
	fwait
	test	CondCode, 1		; if 1-x^2 < 0
	JSNZ	DescriminantNeg 	;    return a NAN
	xor	ch, ch			; sign of TOS is +ve
	fsqrt				; NOS=x, TOS=sqrt(1-x^2)
	ret

lab DescriminantNeg
	pop	rax			; remove return address from stack
	jmp	_rtindfpop		; replace top of stack with a NAN

page
;----------------------------------------------------------
;
;       SPECIAL CASE RETURN FUNCTIONS
;
;----------------------------------------------------------
;
;       INPUTS - The signs of the last, second to last
;                arguments are in CH, CL respectively.
;
;       OUTPUT - The result is the stack top.
;
;----------------------------------------------------------

labelNP _rtpiby2, PUBLIC
	fstp	st(0)			; remove ST(0)
	fld	[_piby2]		; push pi/2 onto stack
	ret


lab _rtforatn20
	fstp	st(0)			; remove ST(0)
	or	cl ,cl			; if denominator is +ve
	JSZ	zeronpop		;    return zero
	fstp	st(0)
	fldpi				; push pi onto stack
	or	ch, ch			; if numerator was +ve
	JSZ	postv
	fchs
lab postv
	ret

lab zeronpop
    fstp    st(0)
    fldz                ; push 0.0 onto stack
    or  ch, ch          ; if numerator was +ve
    JSZ postv
    fchs
    ret


lab _rtforatn200
lab indfpop
	fstp	st(0)			; remove ST(0)
lab indfnpop
	jmp	_rtindfnpop		; return real indefinite


lab _rtforatnby0
	fstp	st(0)			; remove an argument before returning
	mov	cl, ch			; cl is sign(TOS)
	jmp	short _rtsignpiby2


lab _rtforatninf
lab _rtsignpiby2
	call	_rtpiby2		; push pi/2 onto stack
	jmp	_rtchsifneg		; return with sign change if negative

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\i386\adj_fdiv.asm ===
title   adj_fdiv   - routines to compensate for incorrect Pentium FDIV
;*** 
;adj_fdiv - routines to compensate for incorrect Pentium FDIV
;
;   Copyright (c) 1994-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;   Workarounds to correct for broken FDIV
;
;Revision History:
;
;   12/06/94	Jamie MacCalman
;		initial version, based on Intel fix
;   12/09/94	Jamie MacCalman
;		added _adj_fpremX & _safe_fdivX entry points
;   12/13/94	Jamie MacCalman
;		upgraded to V.3 of Intel's workarounds
;   12/19/94	Jamie MacCalman
;		upgraded to V.4 of Intel's workarounds
;   12/27/94	Jamie MacCalman
;		upgraded to V.5 (aka "V1.0") of Intel's workarounds
;    1/13/95	Jamie MacCalman
;		added underscores to fdivp_sti_st & fdivrp_sti_st for ANSI conformance
;
;  The following code is a PRELIMINARY IMPLEMENTATION of a
;  software patch for the floating point divide instructions.
;
;


	include cruntime.inc
	include mrt386.inc
	include elem87.inc

;
;  Stack variables for divide routines.
;

DENOM		EQU	0
NUMER		EQU	12
PREV_CW		EQU	28
PATCH_CW 	EQU	32

DENOM_SAVE	EQU	32

MAIN_DENOM	EQU	4
MAIN_NUMER	EQU	16

SPILL_SIZE	EQU	12
MEM_OPERAND	EQU	8
STACK_SIZE	EQU	44
SPILL_MEM_OPERAND	EQU	20

ONESMASK	EQU	0e000000h

SINGLE_NAN	EQU	07f800000h
DOUBLE_NAN	EQU	07ff00000h

ILLEGAL_OPC	EQU	6

;
; FPREM constants
;

FPREM_FLT_SIZE		EQU	12
FPREM_DENOM			EQU 0
FPREM_DENOM_SAVE	EQU	FPREM_DENOM + FPREM_FLT_SIZE
FPREM_NUMER			EQU FPREM_DENOM_SAVE + FPREM_FLT_SIZE
FPREM_PREV_CW		EQU FPREM_NUMER + FPREM_FLT_SIZE
FPREM_PATCH_CW		EQU FPREM_PREV_CW + 4
FPREM_SW			EQU	FPREM_PATCH_CW + 4
FPREM_STACK_SIZE	EQU FPREM_SW + 4
FPREM_RET_SIZE		EQU	4
FPREM_PUSH_SIZE		EQU	4

FPREM_MAIN_FUDGE	EQU	FPREM_RET_SIZE + FPREM_PUSH_SIZE + FPREM_PUSH_SIZE + FPREM_PUSH_SIZE

FPREM_MAIN_DENOM		EQU FPREM_DENOM + FPREM_MAIN_FUDGE
FPREM_MAIN_DENOM_SAVE	EQU	FPREM_DENOM_SAVE + FPREM_MAIN_FUDGE
FPREM_MAIN_NUMER		EQU FPREM_NUMER + FPREM_MAIN_FUDGE
FPREM_MAIN_PREV_CW		EQU	FPREM_PREV_CW + FPREM_MAIN_FUDGE
FPREM_MAIN_PATCH_CW		EQU	FPREM_PATCH_CW + FPREM_MAIN_FUDGE
FPREM_MAIN_FPREM_SW		EQU	FPREM_SW + FPREM_MAIN_FUDGE

FPREM_ONESMASK	EQU     700h


.data

fdiv_risc_table	DB	0, 1, 0, 0, 4, 0, 0, 7, 0, 0, 10, 0, 0, 13, 0, 0
fdiv_scale_1  	DD	03f700000h		;0.9375
fdiv_scale_2	DD	03f880000h		;1.0625
one_shl_63  	DD	05f000000h

fprem_risc_table 	DB 	0, 1, 0, 0, 4, 0, 0, 7, 0, 0, 10, 0, 0, 13, 0, 0
fprem_scale 		DB 	0, 0, 0, 0, 0, 0, 0eeh, 03fh
one_shl_64 		DB 	0, 0, 0, 0, 0, 0, 0f0h, 043h
one_shr_64 		DB 	0, 0, 0, 0, 0, 0, 0f0h, 03bh
one 			DB 	0, 0, 0, 0, 0, 0, 0f0h, 03fh
half 			DB 	0, 0, 0, 0, 0, 0, 0e0h, 03fh
big_number		DB	0, 0, 0, 0, 0, 0, 0ffh, 0ffh, 0feh, 07fh

ifdef	DEBUG
	public	fpcw
	public	fpsw
fpcw	dw	0
fpsw	dw	0
endif

FPU_STATE	STRUC
	CONTROL_WORD	DW	?
	reserved_1	DW	?
	STATUS_WORD	DD	?
	TAG_WORD	DW	?
	reserved_3	DW	?
	IP_OFFSET	DD	?
	CS_SLCT		DW	?
	OPCODE		DW	?
	DATA_OFFSET	DD	?
	OPERAND_SLCT	DW	?
	reserved_4	DW	?
FPU_STATE	ENDS

ENV_SIZE	EQU	28



dispatch_table DD	offset FLAT:label0
	DD	offset FLAT:label1
	DD	offset FLAT:label2
	DD	offset FLAT:label3
	DD	offset FLAT:label4
	DD	offset FLAT:label5
	DD	offset FLAT:label6
	DD	offset FLAT:label7
	DD	offset FLAT:label8
	DD	offset FLAT:label9
	DD	offset FLAT:label10
	DD	offset FLAT:label11
	DD	offset FLAT:label12
	DD	offset FLAT:label13
	DD	offset FLAT:label14
	DD	offset FLAT:label15
	DD	offset FLAT:label16
	DD	offset FLAT:label17
	DD	offset FLAT:label18
	DD	offset FLAT:label19
	DD	offset FLAT:label20
	DD	offset FLAT:label21
	DD	offset FLAT:label22
	DD	offset FLAT:label23
	DD	offset FLAT:label24
	DD	offset FLAT:label25
	DD	offset FLAT:label26
	DD	offset FLAT:label27
	DD	offset FLAT:label28
	DD	offset FLAT:label29
	DD	offset FLAT:label30
	DD	offset FLAT:label31
	DD	offset FLAT:label32
	DD	offset FLAT:label33
	DD	offset FLAT:label34
	DD	offset FLAT:label35
	DD	offset FLAT:label36
	DD	offset FLAT:label37
	DD	offset FLAT:label38
	DD	offset FLAT:label39
	DD	offset FLAT:label40
	DD	offset FLAT:label41
	DD	offset FLAT:label42
	DD	offset FLAT:label43
	DD	offset FLAT:label44
	DD	offset FLAT:label45
	DD	offset FLAT:label46
	DD	offset FLAT:label47
	DD	offset FLAT:label48
	DD	offset FLAT:label49
	DD	offset FLAT:label50
	DD	offset FLAT:label51
	DD	offset FLAT:label52
	DD	offset FLAT:label53
	DD	offset FLAT:label54
	DD	offset FLAT:label55
	DD	offset FLAT:label56
	DD	offset FLAT:label57
	DD	offset FLAT:label58
	DD	offset FLAT:label59
	DD	offset FLAT:label60
	DD	offset FLAT:label61
	DD	offset FLAT:label62
	DD	offset FLAT:label63


fpcw	dw	0



CODESEG


;
;  PRELIMINARY VERSION for register-register divides.
;


					; In this implementation the
					; fdiv_main_routine is called,
					; therefore all the stack frame
					; locations are adjusted for the
					; return pointer.

fdiv_main_routine PROC	NEAR

	fld     tbyte ptr [esp+MAIN_NUMER]	; load the numerator
	fld     tbyte ptr [esp+MAIN_DENOM]	; load the denominator
retry:

;  The following three lines test for denormals and zeros.
;  A denormal or zero has a 0 in the explicit digit to the left of the
;  binary point.  Since that bit is the high bit of the word, adding
;  it to itself will produce a carry if and only if the number is not
;  denormal or zero.
;
	mov 	eax, [esp+MAIN_DENOM+4]	; get mantissa bits 32-64
	add 	eax,eax			; shift the one's bit onto carry
	jnc 	denormal		; if no carry, we're denormal

;  The following three lines test the three bits after the four bit 
;  pattern (1,4,7,a,d).  If these three bits are not all one, then
;  the denominator cannot expose the flaw.  This condition is tested by
;  inverting the bits and testing that all are equal to zero afterward.

	xor 	eax, ONESMASK		; invert the bits that must be ones
	test	eax, ONESMASK		; and make sure they are all ones
	jz  	scale_if_needed		; if all are one scale numbers
	fdivp	st(1), st		; use of hardware is OK.
	ret

;
;  Now we test the four bits for one of the five patterns.
;
scale_if_needed:
	shr	eax, 28			; keep first 4 bits after point
	cmp	byte ptr fdiv_risc_table[eax], 0	; check for (1,4,7,a,d)
	jnz	divide_scaled		; are in potential problem area
	fdivp	st(1), st		; use of hardware is OK.
	ret

divide_scaled:
	mov	eax, [esp + MAIN_DENOM+8]	; test denominator exponent
	and	eax, 07fffh             ; if pseudodenormal ensure that only
	jz	invalid_denom		; invalid exception flag is set
	cmp	eax, 07fffh             ; if NaN or infinity  ensure that only
	je	invalid_denom		; invalid exception flag is set
;
;  The following six lines turn off exceptions and set the
;  precision control to 80 bits.  The former is necessary to
;  force any traps to be taken at the divide instead of the scaling
;  code.  The latter is necessary in order to get full precision for
;  codes with incoming 32 and 64 bit precision settings.  If
;  it can be guaranteed that before reaching this point, the underflow
;  exception is masked and the precision control is at 80 bits, these
;  six lines can be omitted.
;
	fnstcw	[esp+PREV_CW]		; save caller's control word
	mov	eax, [esp+PREV_CW] 
	or	eax, 033fh		; mask exceptions, pc=80
	and	eax, 0f3ffh		; set rounding mode to nearest
	mov	[esp+PATCH_CW], eax
	fldcw	[esp+PATCH_CW]		; mask exceptions & pc=80

;  The following lines check the numerator exponent before scaling.
;  This in order to prevent undeflow when scaling the numerator,
;  which will cause a denormal exception flag to be set when the
;  actual divide is preformed. This flag would not have been set
;  normally. If there is a risk of underflow, the scale factor is
;  17/16 instead of 15/16.
;
 	mov	eax, [esp+MAIN_NUMER+8]	; test numerator exponent
 	and	eax, 07fffh
 	cmp	eax, 00001h
 	je	small_numer

	fmul	fdiv_scale_1		; scale denominator by 15/16
	fxch
	fmul	fdiv_scale_1		; scale numerator by 15/16
	fxch

;
;  The next line restores the users control word.  If the incoming
;  control word had the underflow exception masked and precision
;  control set to 80 bits, this line can be omitted.
;

	fldcw	[esp+PREV_CW]		; restore caller's control word
	fdivp	st(1), st		; use of hardware is OK.
	ret

small_numer:
	fmul	fdiv_scale_2		; scale denominator by 17/16
	fxch
	fmul	fdiv_scale_2		; scale numerator by 17/16
	fxch

;
;  The next line restores the users control word.  If the incoming
;  control word had the underflow exception masked and precision
;  control set to 80 bits, this line can be omitted.
;

	fldcw	[esp+PREV_CW]		; restore caller's control word
	fdivp	st(1), st		; use of hardware is OK.
	ret

denormal:
	mov	eax, [esp+MAIN_DENOM]	; test for whole mantissa == 0
	or	eax, [esp+MAIN_DENOM+4]	; test for whole mantissa == 0
	jnz	denormal_divide_scaled	; denominator is not zero
invalid_denom:				; zero or invalid denominator
	fdivp	st(1), st		; use of hardware is OK.
	ret

denormal_divide_scaled:
	mov	eax, [esp + MAIN_DENOM + 8]	; get exponent 
	and	eax, 07fffh		; check for zero exponent
	jnz	invalid_denom		; 
;
;  The following six lines turn off exceptions and set the
;  precision control to 80 bits.  The former is necessary to
;  force any traps to be taken at the divide instead of the scaling
;  code.  The latter is necessary in order to get full precision for
;  codes with incoming 32 and 64 bit precision settings.  If
;  it can be guaranteed that before reaching this point, the underflow
;  exception is masked and the precision control is at 80 bits, these
;  six lines can be omitted.
;

	fnstcw	[esp+PREV_CW]		; save caller's control word
	mov	eax, [esp+PREV_CW] 
	or	eax, 033fh		; mask exceptions, pc=80
	and	eax, 0f3ffh		; set rounding mode to nearest
	mov	[esp+PATCH_CW], eax
	fldcw	[esp+PATCH_CW]		; mask exceptions & pc=80

	mov	eax, [esp + MAIN_NUMER +8]	; test numerator exponent
	and	eax, 07fffh		; check for denormal numerator
	je	denormal_numer	
	cmp	eax, 07fffh		; NaN or infinity
	je	invalid_numer
	mov	eax, [esp + MAIN_NUMER + 4]	; get bits 32..63 of mantissa
	add	eax, eax		; shift the first bit into carry
	jnc	invalid_numer		; if there is no carry, we have an
					; invalid numer
	jmp	numer_ok

denormal_numer:
	mov	eax, [esp + MAIN_NUMER + 4]	; get bits 32..63 of mantissa
	add	eax, eax		; shift the first bit into carry
	jc	invalid_numer		; if there is a carry, we have an
					; invalid numer
	
numer_ok:
	fxch
	fstp	st			; pop numerator
	fld 	st			; make copy of denominator
	fmul	dword ptr[one_shl_63]	; make denominator not denormal
	fstp	tbyte ptr [esp+MAIN_DENOM]	; save modified denominator
	fld 	tbyte ptr [esp+MAIN_NUMER]	; load numerator
	fxch				; restore proper order
	fwait

;  The next line restores the users control word.  If the incoming
;  control word had the underflow exception masked and precision
;  control set to 80 bits, this line can be omitted.
;

	fldcw	[esp+PREV_CW]		; restore caller's control word
	jmp	retry			; start the whole thing over

invalid_numer:
;
;  The next line restores the users control word.  If the incoming
;  control word had the underflow exception masked and precision
;  control set to 80 bits, this line can be omitted.
;
	fldcw	[esp + PREV_CW]
	fdivp	st(1), st		; use of hardware is OK.
	ret

fdiv_main_routine	ENDP

fdivr_st	MACRO	reg_index, reg_index_minus1
	fstp	tbyte ptr [esp+DENOM]
IF	reg_index_minus1 GE 1
	fxch	st(reg_index_minus1)
ENDIF
	fstp	tbyte ptr [esp+NUMER]
	call	fdiv_main_routine
IF	reg_index_minus1 GE 1
	fxch	st(reg_index_minus1)
ENDIF
	fld	tbyte ptr [esp+NUMER]
	fxch	st(reg_index)
	add	esp, STACK_SIZE
ENDM

fdivr_sti	MACRO	reg_index, reg_index_minus1
	fstp	tbyte ptr [esp+NUMER]
IF	reg_index_minus1 GE 1
	fxch	st(reg_index_minus1)
ENDIF
	fstp	tbyte ptr [esp+DENOM]
	call	fdiv_main_routine
IF	reg_index_minus1 GE 1
	fxch	st(reg_index_minus1)
ENDIF
	fld	tbyte ptr [esp+NUMER]
	add	esp, STACK_SIZE
ENDM

fdivrp_sti	MACRO	reg_index, reg_index_minus1
	fstp	tbyte ptr [esp+NUMER]
IF	reg_index_minus1 GE 1
	fxch	st(reg_index_minus1)
ENDIF
	fstp	tbyte ptr [esp+DENOM]
	call	fdiv_main_routine
IF	reg_index_minus1 GE 1
	fxch	st(reg_index_minus1)
ENDIF
	add	esp, STACK_SIZE
ENDM

fdiv_st		MACRO	reg_index, reg_index_minus1
	fstp	tbyte ptr [esp+NUMER]
IF	reg_index_minus1 GE 1
	fxch	st(reg_index_minus1)
ENDIF
	fld	st
	fstp	tbyte ptr [esp+DENOM]
	fstp	tbyte ptr [esp+DENOM_SAVE]	; save original denom, 
	call	fdiv_main_routine
IF	reg_index_minus1 GE 1
	fxch	st(reg_index_minus1)
ENDIF
	fld	tbyte ptr [esp+DENOM_SAVE]
	fxch	st(reg_index)
	add	esp, STACK_SIZE
ENDM

fdiv_sti	MACRO	reg_index, reg_index_minus1
	fxch	st(reg_index)
	fstp	tbyte ptr [esp+NUMER]
IF	reg_index_minus1 GE 1
	fxch	st(reg_index_minus1)
ENDIF
	fld	st
	fstp	tbyte ptr [esp+DENOM]
	fstp	tbyte ptr [esp+DENOM_SAVE]	; save original denom, 
	call	fdiv_main_routine
IF	reg_index_minus1 GE 1
	fxch	st(reg_index_minus1)
ENDIF
	fld	tbyte ptr [esp+DENOM_SAVE]
	add	esp, STACK_SIZE
ENDM

fdivp_sti	MACRO	reg_index, reg_index_minus1
	fstp	tbyte ptr [esp+DENOM]
IF	reg_index_minus1 GE 1
	fxch	st(reg_index_minus1)
ENDIF
	fstp	tbyte ptr [esp+NUMER]
	call	fdiv_main_routine
IF	reg_index_minus1 GE 1
	fxch	st(reg_index_minus1)
ENDIF
	add	esp, STACK_SIZE
ENDM 


	public  _adj_fdiv_r
_adj_fdiv_r      PROC    NEAR

	sub	esp, STACK_SIZE			; added back at end of fdiv_x macros
	and eax, 0000003FH			; upper 26 bits could be anything
	jmp	dword ptr dispatch_table[eax*4]



label0::
	fdiv	st,st(0)		; D8 F0 	FDIV	ST,ST(0)
	add	esp, STACK_SIZE
	ret
label1::
	add	esp, STACK_SIZE
	int	ILLEGAL_OPC
label2::
	fdivr	st,st(0)		; D8 F8		FDIVR	ST,ST(0)
	add	esp, STACK_SIZE
	ret
label3::
	add	esp, STACK_SIZE
	int	ILLEGAL_OPC
label4::
	fdiv 	st(0),st		; DC F8/D8 F0	FDIV	ST(0),ST
	add	esp, STACK_SIZE
	ret
label5::
	fdivp 	st(0),st		; DE F8		FDIVP	ST(0),ST
	add	esp, STACK_SIZE
	ret
label6::
	fdivr 	st(0),st		; DC F0/DE F0	FDIVR	ST(0),ST
	add	esp, STACK_SIZE
	ret
label7::
	fdivrp 	st(0),st		; DE F0		FDIVRP	ST(0),ST
	add	esp, STACK_SIZE
	ret
label8::
	fdiv_st 1,0
	ret
label9::
	add	esp, STACK_SIZE
	int	ILLEGAL_OPC
label10::
	fdivr_st 1,0
	ret
label11::
	add	esp, STACK_SIZE
	int	ILLEGAL_OPC
label12::
	fdiv_sti 1,0
	ret
label13::
	fdivp_sti 1,0
	ret
label14::
	fdivr_sti 1,0
	ret
label15::
	fdivrp_sti 1,0
	ret
label16::
	fdiv_st 2,1
	ret
label17::
	add	esp, STACK_SIZE
	int	ILLEGAL_OPC
label18::
	fdivr_st 2,1
	ret
label19::
	add	esp, STACK_SIZE
	int	ILLEGAL_OPC
label20::
	fdiv_sti 2,1
	ret
label21::
	fdivp_sti 2,1
	ret
label22::
	fdivr_sti 2,1
	ret
label23::
	fdivrp_sti 2,1
	ret
label24::
	fdiv_st 3,2
	ret
label25::
	add	esp, STACK_SIZE
	int	ILLEGAL_OPC
label26::
	fdivr_st 3,2
	ret
label27::
	add	esp, STACK_SIZE
	int	ILLEGAL_OPC
label28::
	fdiv_sti 3,2
	ret
label29::
	fdivp_sti 3,2
	ret
label30::
	fdivr_sti 3,2
	ret
label31::
	fdivrp_sti 3,2
	ret
label32::
	fdiv_st 4,3
	ret
label33::
	add	esp, STACK_SIZE
	int	ILLEGAL_OPC
label34::
	fdivr_st 4,3
	ret
label35::
	add	esp, STACK_SIZE
	int	ILLEGAL_OPC
label36::
	fdiv_sti 4,3
	ret
label37::
	fdivp_sti 4,3
	ret
label38::
	fdivr_sti 4,3
	ret
label39::
	fdivrp_sti 4,3
	ret
label40::
	fdiv_st 5,4
	ret
label41::
	add	esp, STACK_SIZE
	int	ILLEGAL_OPC
label42::
	fdivr_st 5,4
	ret
label43::
	add	esp, STACK_SIZE
	int	ILLEGAL_OPC
label44::
	fdiv_sti 5,4
	ret
label45::
	fdivp_sti 5,4
	ret
label46::
	fdivr_sti 5,4
	ret
label47::
	fdivrp_sti 5,4
	ret
label48::
	fdiv_st 6,5
	ret
label49::
	add	esp, STACK_SIZE
	int	ILLEGAL_OPC
label50::
	fdivr_st 6,5
	ret
label51::
	add	esp, STACK_SIZE
	int	ILLEGAL_OPC
label52::
	fdiv_sti 6,5
	ret
label53::
	fdivp_sti 6,5
	ret
label54::
	fdivr_sti 6,5
	ret
label55::
	fdivrp_sti 6,5
	ret
label56::
	fdiv_st 7,6
	ret
label57::
	add	esp, STACK_SIZE
	int	ILLEGAL_OPC
label58::
	fdivr_st 7,6
	ret
label59::
	add	esp, STACK_SIZE
	int	ILLEGAL_OPC
label60::
	fdiv_sti 7,6
	ret
label61::
	fdivp_sti 7,6
	ret
label62::
	fdivr_sti 7,6
	ret
label63::
	fdivrp_sti 7,6
	ret
_adj_fdiv_r      ENDP



_fdivp_sti_st	PROC	NEAR
				; for calling from mem routines
	sub	esp, STACK_SIZE			; added back at end of fdivp_sti macro
	fdivp_sti 1, 0
	ret
_fdivp_sti_st	ENDP

_fdivrp_sti_st	PROC	NEAR
				; for calling from mem routines
	sub	esp, STACK_SIZE			; added back at end of fdivrp_sti macro
	fdivrp_sti 1, 0
	ret
_fdivrp_sti_st	ENDP


;;; _adj_fdiv_m32 - FDIV m32real FIX
;;
;; 	Input : Value of the m32real in the top of STACK
;;
;;	Output: Result of FDIV in ST

	PUBLIC	_adj_fdiv_m32
_adj_fdiv_m32	PROC	NEAR

	push	eax				; save eax
	mov	eax, [esp + MEM_OPERAND]	; check for
	and	eax, SINGLE_NAN			; NaN
	cmp	eax, SINGLE_NAN			;
	je	memory_divide_m32		;

	fnstsw	ax				; get status word
	and	eax, 3800h			; get top of stack
	je	spill_fpstack			; is FP stack full?
	fld	dword ptr[esp + MEM_OPERAND]	; load m32real in ST
	call	_fdivp_sti_st			; do actual divide
	pop	eax
	ret 4
spill_fpstack:
	fxch
	sub	esp, SPILL_SIZE 		; make temp space
	fstp	tbyte ptr[esp ]			; save user's ST(1)
	fld	dword ptr[esp + SPILL_MEM_OPERAND] ; load m32 real 
	call	_fdivp_sti_st			; do actual divide
	fld	tbyte ptr[esp]			; restore user's ST(1)
						;esp is adjusted by fdivrp fn
	fxch
	add	esp, SPILL_SIZE
	pop	eax
	ret 4
memory_divide_m32:
	fdiv	dword ptr[esp + MEM_OPERAND]	; do actual divide
	pop	eax
	ret 4

_adj_fdiv_m32	ENDP
	

;;; _adj_fdiv_m64 - FDIV m64real FIX
;;
;; 	Input : Value of the m64real in the top of STACK
;;
;;	Output: Result of FDIV in ST

	PUBLIC	_adj_fdiv_m64
_adj_fdiv_m64	PROC	NEAR

	push	eax				; save eax
	mov	eax, [esp + MEM_OPERAND + 4]	; check for
	and	eax, DOUBLE_NAN			; NaN
	cmp	eax, DOUBLE_NAN			;
	je	memory_divide_m64		;

	fnstsw	ax				; get status word
	and	eax, 3800h			; get top of stack
	je	spill_fpstack_m64		; is FP stack full?
	fld	qword ptr[esp + MEM_OPERAND]	; load m64real in ST
	call	_fdivp_sti_st			; do actual divide
	pop	eax
	ret 8
spill_fpstack_m64:
	fxch
	sub	esp, SPILL_SIZE 		; make temp space
	fstp	tbyte ptr[esp]			; save user's ST(1)
	fld	qword ptr[esp + SPILL_MEM_OPERAND] ; load m64real 
	call	_fdivp_sti_st			; do actual divide
	fld	tbyte ptr[esp]			; restore user's ST(1)
						;esp is adjusted by fdivrp fn
	fxch
	add	esp, SPILL_SIZE
	pop	eax
	ret 8
memory_divide_m64:
	fdiv	qword ptr[esp + MEM_OPERAND]	; do actual divide
	pop	eax
	ret 8

_adj_fdiv_m64	ENDP

;;; _adj_fdiv_m16i - FDIV m16int FIX
;;
;; 	Input : Value of the m16int in the top of STACK
;;
;;	Output: Result of FDIV in ST

	PUBLIC	_adj_fdiv_m16i
_adj_fdiv_m16i	PROC	NEAR
	push	eax				; save eax
	fnstsw	ax				; get status word
	and	eax, 3800h			; get top of stack
	je	spill_fpstack_m16i		; is FP stack full?
	fild	word ptr[esp + MEM_OPERAND]	; load m16int in ST
	call	_fdivp_sti_st			; do actual divide
	pop	eax
	ret 4
spill_fpstack_m16i:
	fxch
	sub	esp, SPILL_SIZE 		; make temp space
	fstp	tbyte ptr[esp ]			; save user's ST(1)
	fild	word ptr[esp + SPILL_MEM_OPERAND] ; load m16int
	call	_fdivp_sti_st			; do actual divide
	fld	tbyte ptr[esp]			; restore user's ST(1)
						;esp is adjusted by fdivrp fn
	fxch
	add	esp, SPILL_SIZE
	pop	eax
	ret 4

_adj_fdiv_m16i	ENDP

;;; _adj_fdiv_m32i - FDIV m32int FIX
;;
;; 	Input : Value of the m32int in the top of STACK
;;
;;	Output: Result of FDIV in ST

	PUBLIC	_adj_fdiv_m32i
_adj_fdiv_m32i	PROC	NEAR
	push	eax				; save eax
	fnstsw	ax				; get status word
	and	eax, 3800h			; get top of stack
	je	spill_fpstack_m32i		; is FP stack full?
	fild	dword ptr[esp + MEM_OPERAND]	; load m32int in ST
	call	_fdivp_sti_st			; do actual divide
	pop	eax
	ret 4
spill_fpstack_m32i:
	fxch
	sub	esp, SPILL_SIZE 		; make temp space
	fstp	tbyte ptr[esp ]			; save user's ST(1)
	fild	dword ptr[esp + SPILL_MEM_OPERAND] ; load m32int
	call	_fdivp_sti_st			; do actual divide
	fld	tbyte ptr[esp]			; restore user's ST(1)
						;esp is adjusted by fdivrp fn
	fxch
	add	esp, SPILL_SIZE
	pop	eax
	ret 4

_adj_fdiv_m32i	ENDP



;;; _adj_fdivr_m32 - FDIVR m32real FIX
;;
;; 	Input : Value of the m32real in the top of STACK
;;
;;	Output: Result of FDIVR in ST

	PUBLIC	_adj_fdivr_m32
_adj_fdivr_m32	PROC	NEAR
	push	eax				; save eax
	mov	eax, [esp + MEM_OPERAND]	; check for
	and	eax, SINGLE_NAN			; NaN
	cmp	eax, SINGLE_NAN			;
	je	memory_divide_m32r		;

	fnstsw	ax				; get status word
	and	eax, 3800h			; get top of stack
	je	spill_fpstack_m32r		; is FP stack full?
	fld	dword ptr[esp + MEM_OPERAND]	; load m32real in ST
	call	_fdivrp_sti_st			; do actual divide
	pop	eax
	ret 4
spill_fpstack_m32r:
	fxch
	sub	esp, SPILL_SIZE 		; make temp space
	fstp	tbyte ptr[esp ]			; save user's ST(1)
	fld	dword ptr[esp + SPILL_MEM_OPERAND] ; load m32 real 
	call	_fdivrp_sti_st			; do actual divide
	fld	tbyte ptr[esp]			; restore user's ST(1)
						;esp is adjusted by fdivp fn
	fxch
	add	esp, SPILL_SIZE
	pop	eax
	ret 4
memory_divide_m32r:
	fdivr	dword ptr[esp + MEM_OPERAND]	; do actual divide
	pop	eax
	ret 4

_adj_fdivr_m32	ENDP


;;; _adj_fdivr_m64 - FDIVR m64real FIX
;;
;; 	Input : Value of the m64real in the top of STACK
;;
;;	Output: Result of FDIVR in ST

	PUBLIC	_adj_fdivr_m64
_adj_fdivr_m64	PROC	NEAR
	push	eax				; save eax
	mov	eax, [esp + MEM_OPERAND + 4]	; check for
	and	eax, DOUBLE_NAN			; NaN
	cmp	eax, DOUBLE_NAN			;
	je	memory_divide_m64r		;

	fnstsw	ax				; get status word
	and	eax, 3800h			; get top of stack
	je	spill_fpstack_m64r		; is FP stack full?
	fld	qword ptr[esp + MEM_OPERAND]	; load m64real in ST
	call	_fdivrp_sti_st			; do actual divide
	pop	eax
	ret 8
spill_fpstack_m64r:
	fxch
	sub	esp, SPILL_SIZE 		; make temp space
	fstp	tbyte ptr[esp ]			; save user's ST(1)
	fld	qword ptr[esp + SPILL_MEM_OPERAND] ; load m64real 
	call	_fdivrp_sti_st			; do actual divide
	fld	tbyte ptr[esp]			; restore user's ST(1)
						;esp is adjusted by fdivp fn
	fxch
	add	esp, SPILL_SIZE
	pop	eax
	ret 8
memory_divide_m64r:
	fdivr	qword ptr[esp + MEM_OPERAND]	; do actual divide
	pop	eax
	ret 8

_adj_fdivr_m64	ENDP


;;; _adj_fdivr_m16i - FDIVR m16int FIX
;;
;; 	Input : Value of the m16int in the top of STACK
;;
;;	Output: Result of FDIVR in ST

	PUBLIC	_adj_fdivr_m16i
_adj_fdivr_m16i	PROC	NEAR
	push	eax				; save eax
	fnstsw	ax				; get status word
	and	eax, 3800h			; get top of stack
	je	spill_fpstack_m16ir		; is FP stack full?
	fild	word ptr[esp + MEM_OPERAND]	; load m16int in ST
	call	_fdivrp_sti_st			; do actual divide
	pop	eax
	ret 4
spill_fpstack_m16ir:
	fxch
	sub	esp, SPILL_SIZE 		; make temp space
	fstp	tbyte ptr[esp ]			; save user's ST(1)
	fild	word ptr[esp + SPILL_MEM_OPERAND] ; load m16int
	call	_fdivrp_sti_st			; do actual divide
	fld	tbyte ptr[esp]			; restore user's ST(1)
						;esp is adjusted by fdivp fn
	fxch
	add	esp, SPILL_SIZE
	pop	eax
	ret 4

_adj_fdivr_m16i	ENDP


;;; _adj_fdivr_m32i - FDIVR m32int FIX
;;
;; 	Input : Value of the m32int in the top of STACK
;;
;;	Output: Result of FDIVR in ST

	PUBLIC	_adj_fdivr_m32i
_adj_fdivr_m32i	PROC	NEAR
	push	eax				; save eax
	fnstsw	ax				; get status word
	and	eax, 3800h			; get top of stack
	je	spill_fpstack_m32ir		; is FP stack full?
	fild	dword ptr[esp + MEM_OPERAND]	; load m32int in ST
	call	_fdivrp_sti_st			; do actual divide
	pop	eax
	ret 4
spill_fpstack_m32ir:
	fxch
	sub	esp, SPILL_SIZE 		; make temp space
	fstp	tbyte ptr[esp ]			; save user's ST(1)
	fild	dword ptr[esp + SPILL_MEM_OPERAND] ; load m32int
	call	_fdivrp_sti_st			; do actual divide
	fld	tbyte ptr[esp]			; restore user's ST(1)
						;esp is adjusted by fdivp fn
	fxch
	add	esp, SPILL_SIZE
	pop	eax
	ret 4

_adj_fdivr_m32i	ENDP


;;; _safe_fdiv - FDIV fix
;;
;;	Pentium-safe version of FDIV, aka FDIVP ST(1),ST(0)
;;
;; 	Input : Numerator in ST(1), Denominator in ST(0)
;;
;;	Output: Result of FDIV in ST(0)


	PUBLIC  _safe_fdiv
_safe_fdiv      PROC    NEAR

	push eax
	sub	esp, STACK_SIZE
	fstp	tbyte ptr [esp+DENOM]
	fstp	tbyte ptr [esp+NUMER]
	call	fdiv_main_routine
	add	esp, STACK_SIZE
	pop eax
	ret

_safe_fdiv	ENDP


;;; _safe_fdivr - FDIVR fix
;;
;;	Pentium-safe version of FDIVR, aka FDIVRP ST(1),ST(0)
;;
;; 	Input : Numerator in ST(0), Denominator in ST(1)
;;
;;	Output: Result of FDIVR in ST(0)

	public  _safe_fdivr
_safe_fdivr      PROC    NEAR

	push eax
	sub	esp, STACK_SIZE
	fstp	tbyte ptr [esp+NUMER]
	fstp	tbyte ptr [esp+DENOM]
	call	fdiv_main_routine
	add	esp, STACK_SIZE
	pop eax
	ret

_safe_fdivr	ENDP



;;; _adj_fprem - FPREM FIX
;;
;;	Based on PRELIMINARY Intel code.


_fprem_common	PROC	NEAR

	push	eax
	push	ebx
	push	ecx
    mov     eax, [FPREM_MAIN_DENOM+6+esp] ; exponent and high 16 bits of mantissa
    xor     eax, FPREM_ONESMASK           ; invert bits that have to be one
    test    eax, FPREM_ONESMASK           ; check bits that have to be one
	jnz     remainder_hardware_ok
    shr     eax, 11
    and     eax, 0fh
    cmp     byte ptr fprem_risc_table[eax], 0     ; check for (1,4,7,a,d)
    jz      remainder_hardware_ok

; The denominator has the bit pattern. Weed out the funny cases like NaNs
; before applying the software version. Our caller guarantees that the
; denominator is not a denormal. Here we check for:
;	denominator	inf, NaN, unnormal
;	numerator	inf, NaN, unnormal, denormal

	mov     eax, [FPREM_MAIN_DENOM+6+esp] ; exponent and high 16 bits of mantissa
    and     eax, 07fff0000h	        ; mask the exponent only
    cmp     eax, 07fff0000h         ; check for INF or NaN 
	je  	remainder_hardware_ok
	mov     eax, [FPREM_MAIN_NUMER+6+esp] ; exponent and high 16 bits of mantissa
    and     eax, 07fff0000h		; mask the exponent only
	jz  	remainder_hardware_ok	; jif numerator denormal
    cmp     eax, 07fff0000h         ; check for INF or NaN 
	je  	remainder_hardware_ok
	mov 	eax, [esp + FPREM_MAIN_NUMER + 4]	; high mantissa bits - numerator
	add 	eax, eax		; set carry if explicit bit set
	jnz 	remainder_hardware_ok	; jmp if numerator is unnormal
	mov 	eax, [esp + FPREM_MAIN_DENOM + 4] ; high mantissa bits - denominator
	add 	eax, eax		; set carry if explicit bit set
	jnz 	remainder_hardware_ok	; jmp if denominator is unnormal

rem_patch:
    mov     eax, [FPREM_MAIN_DENOM+8+esp] ; sign and exponent of y (denominator)
    and     eax, 07fffh              ; clear sy
    add     eax, 63                  ; evaluate ey + 63 
    mov     ebx, [FPREM_MAIN_NUMER+8+esp]  ; sign and exponent of x (numerator)
    and     ebx, 07fffh              ; clear sx
    sub     ebx, eax                 ; evaluate the exponent difference (ex - ey)
    ja      rem_large	 	; if ex > ey + 63, case of large arguments 
rem_patch_loop:
	mov     eax, [FPREM_MAIN_DENOM+8+esp]  ; sign and exponent of y (denominator)
	and     eax, 07fffh		; clear sy
	add 	eax, 10			; evaluate ey + 10
	mov     ebx, [FPREM_MAIN_NUMER+8+esp]	; sign and exponent of x (numerator)
	and     ebx, 07fffh		; clear sx 	
	sub 	ebx, eax		; evaluate the exponent difference (ex - ey)
	js  	remainder_hardware_ok	; safe if ey + 10 > ex
	fld     tbyte ptr [FPREM_MAIN_NUMER+esp]   ; load the numerator
	mov     eax, [FPREM_MAIN_DENOM+8+esp] ; sign and exponent of y (denominator)
    mov     ebx, [FPREM_MAIN_NUMER+8+esp] ; sign and exponent of x (numerator)
	and     ebx, 07fffh             ; clear sx
	mov		ecx, ebx
	sub		ebx, eax
	and		ebx, 07h
	or		ebx, 04h
	sub		ecx, ebx
	mov		ebx, eax
	and     ebx, 08000h		; keep sy
	or		ecx, ebx		; merge the sign of y
	mov		dword ptr [FPREM_MAIN_DENOM+8+esp], ecx
	fld     tbyte ptr [FPREM_MAIN_DENOM+esp]   ; load the shifted denominator
	mov     dword ptr [FPREM_MAIN_DENOM+8+esp], eax	; restore the initial denominator
	fxch
	fprem				; this rem is safe
	fstp	tbyte ptr [FPREM_MAIN_NUMER+esp]	; update the numerator
	fstp    st(0)                   ; pop the stack
	jmp     rem_patch_loop 
rem_large:
	test	edx, 02h		; is denominator already saved
	jnz 	already_saved
	fld 	tbyte ptr[esp + FPREM_MAIN_DENOM]
	fstp	tbyte ptr[esp + FPREM_MAIN_DENOM_SAVE]	; save denominator
already_saved:
	; Save user's precision control and institute 80.  The fp ops in
	; rem_large_loop must not round to user's precision (if it is less
	; than 80) because the hardware would not have done so.  We are
	; aping the hardware here, which is all extended.

	fnstcw	[esp+FPREM_MAIN_PREV_CW]	; save caller's control word
	mov 	eax, dword ptr[esp + FPREM_MAIN_PREV_CW]
	or  	eax, 033fh		; mask exceptions, pc=80
	mov 	[esp + FPREM_MAIN_PATCH_CW], eax
	fldcw	[esp + FPREM_MAIN_PATCH_CW]	

    mov     eax, [FPREM_MAIN_DENOM+8+esp] ; sign and exponent of y (denominator)
    and     eax, 07fffh             ; clear sy
    mov     ebx, [FPREM_MAIN_NUMER+8+esp] ; sign and exponent of x (numerator)
    and     ebx, 07fffh             ; clear sx
	sub 	ebx, eax		; evaluate the exponent difference
	and 	ebx, 03fh
	or  	ebx, 020h
	add 	ebx, 1
	mov 	ecx, ebx
	mov     eax, [FPREM_MAIN_DENOM+8+esp] ; sign and exponent of y (denominator)
	mov     ebx, [FPREM_MAIN_NUMER+8+esp] ; sign and exponent of x (numerator)
    and     ebx, 07fffh             ; clear sx
    and     eax, 08000h             ; keep sy
    or      ebx, eax                ; merge the sign of y
    mov     dword ptr[FPREM_MAIN_DENOM+8+esp], ebx	; make ey equal to ex (scaled denominator)
    fld     tbyte ptr [FPREM_MAIN_DENOM+esp]   ; load the scaled denominator
	fabs
    fld     tbyte ptr [FPREM_MAIN_NUMER+esp]   ; load the numerator
	fabs
rem_large_loop:
	fcom
	fnstsw  ax	
	and     eax, 00100h		
	jnz 	rem_no_sub
	fsub	st, st(1)
rem_no_sub:
	fxch
	fmul	qword ptr half
	fxch
	sub	ecx, 1			; decrement the loop counter
	jnz 	rem_large_loop
	mov     ebx, [FPREM_MAIN_NUMER+8+esp] ; sign and exponent of x (numerator)
	fstp	tbyte ptr[esp + FPREM_MAIN_NUMER]	; save result
	fstp	st			; toss modified denom
	fld 	tbyte ptr[esp + FPREM_MAIN_DENOM_SAVE]
	fld 	tbyte ptr[big_number]	; force C2 to be set
	fprem
	fstp	st
	fld 	tbyte ptr[esp + FPREM_MAIN_NUMER]	; restore saved result
	
	fldcw	[esp + FPREM_MAIN_PREV_CW]	; restore caller's control word
	and     ebx, 08000h             ; keep sx
	jz  	rem_done
	fchs
	jmp  	rem_done
remainder_hardware_ok:
    fld     tbyte ptr [FPREM_MAIN_DENOM+esp]   ; load the denominator
    fld     tbyte ptr [FPREM_MAIN_NUMER+esp]   ; load the numerator
	fprem                           ; and finally do a remainder
; prem_main_routine end
rem_done:
	test	edx, 03h
	jz  	rem_exit
	fnstsw	[esp + FPREM_MAIN_FPREM_SW]	; save Q0 Q1 and Q2
	test	edx, 01h
	jz  	do_not_de_scale
; De-scale the result. Go to pc=80 to prevent from fmul
; from user precision (fprem does not round the result).
	fnstcw	[esp + FPREM_MAIN_PREV_CW]	; save callers control word
	mov 	eax, [esp + FPREM_MAIN_PREV_CW]
	or  	eax, 0300h		; pc = 80
	mov 	[esp + FPREM_MAIN_PATCH_CW], eax
	fldcw	[esp + FPREM_MAIN_PATCH_CW]
	fmul	qword ptr one_shr_64
	fldcw	[esp + FPREM_MAIN_PREV_CW]	; restore callers CW
do_not_de_scale:
	mov	eax, [esp + FPREM_MAIN_FPREM_SW]
	fxch
	fstp	st
	fld 	tbyte ptr[esp + FPREM_MAIN_DENOM_SAVE]
	fxch
	and 	eax, 04300h		; restore saved Q0, Q1, Q2
	sub 	esp, ENV_SIZE
	fnstenv	[esp]
	and 	[esp].STATUS_WORD, 0bcffh
	or  	[esp].STATUS_WORD, eax
	fldenv	[esp]
	add 	esp, ENV_SIZE
rem_exit:
	pop 	ecx
	pop 	ebx
	pop 	eax
	ret
_fprem_common	ENDP




    PUBLIC  _adj_fprem
_adj_fprem	PROC	NEAR
	push	edx
    sub     esp, FPREM_STACK_SIZE
    fstp    tbyte ptr [FPREM_NUMER+esp]
    fstp    tbyte ptr [FPREM_DENOM+esp]
	xor 	edx, edx
; prem_main_routine begin
    mov     eax,[FPREM_DENOM+6+esp]       ; exponent and high 16 bits of mantissa
    test    eax,07fff0000h          ; check for denormal
    jz      fprem_denormal
	call	_fprem_common
	add 	esp, FPREM_STACK_SIZE
	pop 	edx
	ret

fprem_denormal:
    fld     tbyte ptr [FPREM_DENOM+esp]   ; load the denominator
    fld     tbyte ptr [FPREM_NUMER+esp]   ; load the numerator
    mov     eax, [FPREM_DENOM+esp]        ; test for whole mantissa == 0
    or      eax, [FPREM_DENOM+4+esp]      ; test for whole mantissa == 0
    jz      remainder_hardware_ok_l ; denominator is zero
	fxch
	fstp	tbyte ptr[esp + FPREM_DENOM_SAVE]	; save org denominator
	fld 	tbyte ptr[esp + FPREM_DENOM]
	fxch
	or  	edx, 02h
;
; For this we need pc=80.  Also, mask exceptions so we don't take any
; denormal operand exceptions.  It is guaranteed that the descaling
; later on will take underflow, which is what the hardware would have done
; on a normal fprem.
;
    fnstcw  [FPREM_PREV_CW+esp]         ; save caller's control word
    mov     eax, [FPREM_PREV_CW+esp] 
    or      eax, 0033fh             	; mask exceptions, pc=80
    mov     [FPREM_PATCH_CW+esp], eax
    fldcw   [FPREM_PATCH_CW+esp]        ; mask exceptions & pc=80

; The denominator is a denormal.  For most numerators, scale both numerator
; and denominator to get rid of denormals.  Then execute the common code
; with the flag set to indicate that the result must be de-scaled.
; For large numerators this won't work because the scaling would cause
; overflow.  In this case we know the numerator is large, the denominator
; is small (denormal), so the exponent difference is also large.  This means
; the rem_large code will be used and this code depends on the difference
; in exponents modulo 64.  Adding 64 to the denominators exponent
; doesn't change the modulo 64 difference.  So we can scale the denominator
; by 64, making it not denormal, and this won't effect the result.
;
; To start with, figure out if numerator is large

	mov 	eax, [esp + FPREM_NUMER + 8]	; load numerator exponent
	and 	eax, 7fffh		; isolate numerator exponent
	cmp 	eax, 7fbeh		; compare Nexp to Maxexp-64
	ja  	big_numer_rem_de	; jif big numerator

; So the numerator is not large scale both numerator and denominator

	or  	edx, 1			; edx = 1, if denormal extended divisor
	fmul	qword ptr one_shl_64	; make numerator not denormal
	fstp	tbyte ptr[esp + FPREM_NUMER]
	fmul	qword ptr one_shl_64	; make denominator not denormal
	fstp	tbyte ptr[esp + FPREM_DENOM]
	jmp 	scaling_done

; The numerator is large.  Scale only the denominator, which will not
; change the result which we know will be partial.  Set the scale flag
; to false.
big_numer_rem_de:
; We must do this with pc=80 to avoid rounding to single/double.
; In this case we do not mask exceptions so that we will take
; denormal operand, as would the hardware.
	fnstcw  [FPREM_PREV_CW+esp]				; save caller's control word
	mov     eax, [FPREM_PREV_CW+esp] 
	or      eax, 00300h             		; pc=80
	mov     [FPREM_PATCH_CW+esp], eax
	fldcw   [FPREM_PATCH_CW+esp]			; pc=80

	fstp	st			; Toss numerator
	fmul	qword ptr one_shl_64	; make denominator not denormal
	fstp	tbyte ptr[esp + FPREM_DENOM]
	
; Restore the control word which was fiddled to scale at 80-bit precision.
; Then call the common code.
scaling_done:
	fldcw	[esp + FPREM_PREV_CW] 	; restore callers control word
	call	_fprem_common
	add 	esp, FPREM_STACK_SIZE
	pop 	edx
	ret
	
remainder_hardware_ok_l:
    fprem              		; and finally do a remainder 

    add     esp, FPREM_STACK_SIZE
	pop 	edx
    ret

_adj_fprem	ENDP



;
; FPREM1 code begins here
;


_fprem1_common	PROC	NEAR

	push	eax
	push	ebx
	push	ecx
    mov     eax, [FPREM_MAIN_DENOM+6+esp] ; exponent and high 16 bits of mantissa
    xor     eax, FPREM_ONESMASK           ; invert bits that have to be one
    test    eax, FPREM_ONESMASK           ; check bits that have to be one
	jnz     remainder1_hardware_ok
    shr     eax, 11
    and     eax, 0fh
    cmp     byte ptr fprem_risc_table[eax], 0     ; check for (1,4,7,a,d)
    jz      remainder1_hardware_ok

; The denominator has the bit pattern. Weed out the funny cases like NaNs
; before applying the software version. Our caller guarantees that the
; denominator is not a denormal. Here we check for:
;	denominator	inf, NaN, unnormal
;	numerator	inf, NaN, unnormal, denormal

	mov     eax, [FPREM_MAIN_DENOM+6+esp] ; exponent and high 16 bits of mantissa
    and     eax, 07fff0000h	        ; mask the exponent only
    cmp     eax, 07fff0000h         ; check for INF or NaN 
	je  	remainder1_hardware_ok
	mov     eax, [FPREM_MAIN_NUMER+6+esp] ; exponent and high 16 bits of mantissa
    and     eax, 07fff0000h		; mask the exponent only
	jz  	remainder1_hardware_ok	; jif numerator denormal
    cmp     eax, 07fff0000h         ; check for INF or NaN 
	je  	remainder1_hardware_ok
	mov 	eax, [esp + FPREM_MAIN_NUMER + 4]	; high mantissa bits - numerator
	add 	eax, eax		; set carry if explicit bit set
	jnz 	remainder1_hardware_ok	; jmp if numerator is unnormal
	mov 	eax, [esp + FPREM_MAIN_DENOM + 4] ; high mantissa bits - denominator
	add 	eax, eax		; set carry if explicit bit set
	jnz 	remainder1_hardware_ok	; jmp if denominator is unnormal

rem1_patch:
    mov     eax, [FPREM_MAIN_DENOM+8+esp] ; sign and exponent of y (denominator)
    and     eax, 07fffh              ; clear sy
    add     eax, 63                  ; evaluate ey + 63 
    mov     ebx, [FPREM_MAIN_NUMER+8+esp]  ; sign and exponent of x (numerator)
    and     ebx, 07fffh              ; clear sx
    sub     ebx, eax                 ; evaluate the exponent difference (ex - ey)
    ja      rem1_large	 	; if ex > ey + 63, case of large arguments 
rem1_patch_loop:
	mov     eax, [FPREM_MAIN_DENOM+8+esp]  ; sign and exponent of y (denominator)
	and     eax, 07fffh		; clear sy
	add 	eax, 10			; evaluate ey + 10
	mov     ebx, [FPREM_MAIN_NUMER+8+esp]	; sign and exponent of x (numerator)
	and     ebx, 07fffh		; clear sx 	
	sub 	ebx, eax		; evaluate the exponent difference (ex - ey)
	js  	remainder1_hardware_ok	; safe if ey + 10 > ex
	fld     tbyte ptr [FPREM_MAIN_NUMER+esp]   ; load the numerator
	mov     eax, [FPREM_MAIN_DENOM+8+esp] ; sign and exponent of y (denominator)
    mov     ebx, [FPREM_MAIN_NUMER+8+esp] ; sign and exponent of x (numerator)
	and     ebx, 07fffh             ; clear sx
	mov		ecx, ebx
	sub		ebx, eax
	and		ebx, 07h
	or		ebx, 04h
	sub		ecx, ebx
	mov		ebx, eax
	and     ebx, 08000h				; keep sy
	or		ecx, ebx				; merge the sign of y
	mov		dword ptr [FPREM_MAIN_DENOM+8+esp], ecx
	fld     tbyte ptr [FPREM_MAIN_DENOM+esp]   ; load the shifted denominator
	mov     dword ptr [FPREM_MAIN_DENOM+8+esp], eax	; restore the initial denominator
	fxch
	fprem				; this rem is safe
	fstp	tbyte ptr [FPREM_MAIN_NUMER+esp]	; update the numerator
	fstp    st(0)                   ; pop the stack
	jmp     rem1_patch_loop 
rem1_large:
	test	ebx, 02h		; is denominator already saved
	jnz 	already_saved1
	fld 	tbyte ptr[esp + FPREM_MAIN_DENOM]
	fstp	tbyte ptr[esp + FPREM_MAIN_DENOM_SAVE]	; save denominator
already_saved1:
	; Save user's precision control and institute 80.  The fp ops in
	; rem1_large_loop must not round to user's precision (if it is less
	; than 80) because the hardware would not have done so.  We are
	; aping the hardware here, which is all extended.

	fnstcw	[esp+FPREM_MAIN_PREV_CW]	; save caller's control word
	mov 	eax, dword ptr[esp + FPREM_MAIN_PREV_CW]
	or  	eax, 033fh		; mask exceptions, pc=80
	mov 	[esp + FPREM_MAIN_PATCH_CW], eax
	fldcw	[esp + FPREM_MAIN_PATCH_CW]	

    mov     eax, [FPREM_MAIN_DENOM+8+esp] ; sign and exponent of y (denominator)
    and     eax, 07fffh             ; clear sy
    mov     ebx, [FPREM_MAIN_NUMER+8+esp] ; sign and exponent of x (numerator)
    and     ebx, 07fffh             ; clear sx
	sub 	ebx, eax		; evaluate the exponent difference
	and 	ebx, 03fh
	or  	ebx, 020h
	add 	ebx, 1
	mov 	ecx, ebx
	mov     eax, [FPREM_MAIN_DENOM+8+esp] ; sign and exponent of y (denominator)
	mov     ebx, [FPREM_MAIN_NUMER+8+esp] ; sign and exponent of x (numerator)
    and     ebx, 07fffh             ; clear sx
    and     eax, 08000h             ; keep sy
    or      ebx, eax                ; merge the sign of y
    mov     dword ptr[FPREM_MAIN_DENOM+8+esp], ebx	; make ey equal to ex (scaled denominator)
    fld     tbyte ptr [FPREM_MAIN_DENOM+esp]   ; load the scaled denominator
	fabs
    fld     tbyte ptr [FPREM_MAIN_NUMER+esp]   ; load the numerator
	fabs
rem1_large_loop:
	fcom
	fnstsw  ax	
	and     eax, 00100h		
	jnz	rem1_no_sub
	fsub	st, st(1)
rem1_no_sub:
	fxch
	fmul	qword ptr half
	fxch
	sub 	ecx, 1			; decrement the loop counter
	jnz 	rem1_large_loop
	mov     ebx, [FPREM_MAIN_NUMER+8+esp] ; sign and exponent of x (numerator)
	fstp	tbyte ptr[esp + FPREM_MAIN_NUMER]	; save result
	fstp	st			; toss modified denom
	fld 	tbyte ptr[esp + FPREM_MAIN_DENOM_SAVE]
	fld 	tbyte ptr[big_number]	; force C2 to be set
	fprem1
	fstp	st
	fld 	tbyte ptr[esp + FPREM_MAIN_NUMER]	; restore saved result
	
	fldcw	[esp + FPREM_MAIN_PREV_CW]	; restore caller's control word
	and     ebx, 08000h             ; keep sx
	jz  	rem1_done
	fchs
	jmp 	rem1_done
remainder1_hardware_ok:
    fld     tbyte ptr [FPREM_MAIN_DENOM+esp]   ; load the denominator
    fld     tbyte ptr [FPREM_MAIN_NUMER+esp]   ; load the numerator
	fprem1                           ; and finally do a remainder
; prem1_main_routine end
rem1_done:
	test	edx, 03h
	jz  	rem1_exit
	fnstsw	[esp + FPREM_MAIN_FPREM_SW]	; save Q0 Q1 and Q2
	test	edx, 01h
	jz  	do_not_de_scale1
; De-scale the result. Go to pc=80 to prevent from fmul
; from user precision (fprem does not round the result).
	fnstcw	[esp + FPREM_MAIN_PREV_CW]	; save callers control word
	mov 	eax, [esp + FPREM_MAIN_PREV_CW]
	or  	eax, 0300h		; pc = 80
	mov 	[esp + FPREM_MAIN_PATCH_CW], eax
	fldcw	[esp + FPREM_MAIN_PATCH_CW]
	fmul	qword ptr one_shr_64
	fldcw	[esp + FPREM_MAIN_PREV_CW]	; restore callers CW
do_not_de_scale1:
	mov	eax, [esp + FPREM_MAIN_FPREM_SW]
	fxch
	fstp	st
	fld 	tbyte ptr[esp + FPREM_MAIN_DENOM_SAVE]
	fxch
	and 	eax, 04300h		; restore saved Q0, Q1, Q2
	sub 	esp, ENV_SIZE
	fnstenv	[esp]
	and 	[esp].STATUS_WORD, 0bcffh
	or  	[esp].STATUS_WORD, eax
	fldenv	[esp]
	add 	esp, ENV_SIZE
rem1_exit:
	pop	ecx
	pop	ebx
	pop	eax
	ret
_fprem1_common	ENDP

	PUBLIC	_adj_fprem1
_adj_fprem1	PROC	NEAR

	push	edx
    sub     esp, FPREM_STACK_SIZE
    fstp    tbyte ptr [FPREM_NUMER+esp]
    fstp    tbyte ptr [FPREM_DENOM+esp]
	mov 	edx, 0
; prem1_main_routine begin
    mov     eax,[FPREM_DENOM+6+esp]       ; exponent and high 16 bits of mantissa
    test    eax,07fff0000h          ; check for denormal
    jz      denormal1
	call	_fprem1_common
	add 	esp, FPREM_STACK_SIZE
	pop 	edx
	ret

denormal1:
    fld     tbyte ptr [FPREM_DENOM+esp]   ; load the denominator
    fld     tbyte ptr [FPREM_NUMER+esp]   ; load the numerator
    mov     eax, [FPREM_DENOM+esp]        ; test for whole mantissa == 0
    or      eax, [FPREM_DENOM+4+esp]      ; test for whole mantissa == 0
    jz      remainder1_hardware_ok_l ; denominator is zero
	fxch
	fstp	tbyte ptr[esp + FPREM_DENOM_SAVE]	; save org denominator
	fld 	tbyte ptr[esp + FPREM_DENOM]
	fxch
	or  	edx, 02h
;
; For this we need pc=80.  Also, mask exceptions so we don't take any
; denormal operand exceptions.  It is guaranteed that the descaling
; later on will take underflow, which is what the hardware would have done
; on a normal fprem.
;
    fnstcw  [FPREM_PREV_CW+esp]         ; save caller's control word
    mov     eax, [FPREM_PREV_CW+esp] 
    or      eax, 0033fh             	; mask exceptions, pc=80
    mov     [FPREM_PATCH_CW+esp], eax
    fldcw   [FPREM_PATCH_CW+esp]        ; mask exceptions & pc=80

; The denominator is a denormal.  For most numerators, scale both numerator
; and denominator to get rid of denormals.  Then execute the common code
; with the flag set to indicate that the result must be de-scaled.
; For large numerators this won't work because the scaling would cause
; overflow.  In this case we know the numerator is large, the denominator
; is small (denormal), so the exponent difference is also large.  This means
; the rem1_large code will be used and this code depends on the difference
; in exponents modulo 64.  Adding 64 to the denominators exponent
; doesn't change the modulo 64 difference.  So we can scale the denominator
; by 64, making it not denormal, and this won't effect the result.
;
; To start with, figure out if numerator is large

	mov 	eax, [esp + FPREM_NUMER + 8]	; load numerator exponent
	and 	eax, 7fffh		; isolate numerator exponent
	cmp 	eax, 7fbeh		; compare Nexp to Maxexp-64
	ja  	big_numer_rem1_de	; jif big numerator

; So the numerator is not large scale both numerator and denominator

	or  	edx, 1			; edx = 1, if denormal extended divisor
	fmul	qword ptr one_shl_64	; make numerator not denormal
	fstp	tbyte ptr[esp + FPREM_NUMER]
	fmul	qword ptr one_shl_64	; make denominator not denormal
	fstp	tbyte ptr[esp + FPREM_DENOM]
	jmp 	scaling_done1

; The numerator is large.  Scale only the denominator, which will not
; change the result which we know will be partial.  Set the scale flag
; to false.
big_numer_rem1_de:
; We must do this with pc=80 to avoid rounding to single/double.
; In this case we do not mask exceptions so that we will take
; denormal operand, as would the hardware.
	fnstcw  [FPREM_PREV_CW+esp]			; save caller's control word
	mov     eax, [FPREM_PREV_CW+esp] 
	or      eax, 00300h             	; pc=80
	mov     [FPREM_PATCH_CW+esp], eax
	fldcw   [FPREM_PATCH_CW+esp]		;  pc=80
	fstp	st							; Toss numerator
	fmul	qword ptr one_shl_64		; make denominator not denormal
	fstp	tbyte ptr[esp + FPREM_DENOM]
	
; Restore the control word which was fiddled to scale at 80-bit precision.
; Then call the common code.
scaling_done1:
	fldcw	[esp + FPREM_PREV_CW] 	; restore callers control word
	call	_fprem1_common
	add 	esp, FPREM_STACK_SIZE
	pop 	edx
	ret
	
remainder1_hardware_ok_l:
    fprem              		; and finally do a remainder 
    add     esp, FPREM_STACK_SIZE
	pop	edx
    ret
_adj_fprem1	ENDP

	PUBLIC	_safe_fprem
_safe_fprem	PROC	NEAR

    call _adj_fprem
    ret

_safe_fprem	ENDP

	PUBLIC	_safe_fprem1
_safe_fprem1	PROC	NEAR

    call _adj_fprem1
    ret

_safe_fprem1	ENDP



;;; _adj_fpatan - FPATAN FIX
;;
;;	Dummy entry point


	PUBLIC	_adj_fpatan
_adj_fpatan	PROC	NEAR

	fpatan
	ret

_adj_fpatan	ENDP


;;; _adj_fptan - FPTAN FIX
;;
;;	Dummy entry point


	PUBLIC	_adj_fptan
_adj_fptan	PROC	NEAR

	fptan
	ret

_adj_fptan	ENDP


	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\i386\asin.asm ===
;***
;
;   Copyright (c) 1984-2001, Microsoft Corporation. All rights reserved.
;
;Revision History:
;
;*******************************************************************************

_ASIN_ equ 1
include triga.asm
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\i386\atan.asm ===
;***
;
;   Copyright (c) 1984-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;        support for atan() function
;
;Revision History:
;   01-26-01  PML   Pentium4 merge.
;
;*******************************************************************************

.xlist
        include cruntime.inc
        include elem87.inc
.list

_FUNC_     equ	<atan>
_FUNC_DEF_ equ	<_atan_default>
_FUNC_P4_  equ	<_atan_pentium4>
_FUNC_P4_EXTERN_ equ 1
	include	disp_pentium4.inc

_FUNC_     equ	<_CIatan>
_FUNC_DEF_ equ	<_CIatan_default>
_FUNC_P4_  equ	<_CIatan_pentium4>
	include	disp_pentium4.inc

        .data

_NAME_ db 'atan',0,0,0,0

extrn   _indefinite:tbyte
extrn   __fastflag:dword
extrn   _piby2:tbyte
extrn   _DEFAULT_CW_in_mem:word

        CODESEG

extrn   _startOneArgErrorHandling:near
extrn   _fload_withFB:near
extrn   _convertTOStoQNaN:near
extrn   _checkTOS_withFB:near
extrn   _math_exit:near
extrn   _fast_exit:near


; arg                ErrorType        result
;-------------------------------------------
;+infinity            -                 pi/2
;-infinity            -                -pi/2
;QNaN                DOMAIN_QNAN        QNaN            | ? to distinguish them???
;SNaN                DOMAIN             indefinite      | ? it costs 14 bytes per function
;indefinite is like QNaN
;denormal        fld converts it to normal (80 bits)

        public _atan_default,_CIatan_default
_CIatan_default proc
        sub     esp,DBLSIZE+4                 ; for argument
        fst     qword ptr [esp]
        call    _checkTOS_withFB
        call    start
        add     esp, DBLSIZE+4
        ret

_atan_default label   proc
        lea     edx, [esp+4]
        call    _fload_withFB
start:
        push    edx                           ; allocate space for Control Word
        fstcw   [esp]                         ; store Control Word

; at this point we have on stack: cw(4), ret_addr(4), arg1(8bytes)

        jz      inf_or_nan
        cmp     word ptr[esp], default_CW
        je      CW_is_set_to_default
; fpatan is not affected by precision bits. So we may ignore user's CW
        fldcw   _DEFAULT_CW_in_mem
CW_is_set_to_default:

        fld1                                  ; load 1.0
        fpatan                                ; fpatan(x,1.0)

exit:
        cmp     __fastflag, 0
        jnz     _fast_exit

; prepare in registers arguments for math_exit
        mov     edx,OP_ATAN
        lea     ecx,[_NAME_]
        jmp     _math_exit


not_infinity:
        call    _convertTOStoQNaN             ; eax MUST contain high dword
        jmp     _Error_handling               ; eax=error number
inf_or_nan:
        test    eax, 000fffffh
        jnz     not_infinity
        cmp     dword ptr[esp+8], 0
        jne     not_infinity
        fstp    st(0)
        fld     [_piby2]
        test    eax,80000000H
        jz      exit                          ; return pi/2
        fchs
        jmp     exit                          ; return  -pi/2

        mov     eax,DOMAIN
_Error_handling:
        cmp     __fastflag, 0
        jnz     _fast_exit

        mov     edx,OP_ATAN
        lea     ecx,[_NAME_]
        call    _startOneArgErrorHandling
        pop     edx                           ; remove saved CW from stack
        ret

_CIatan_default endp
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\i386\ceil_pentium4.asm ===
; file: ceil_wmt.asm

; Copyright  (C) 1985-2000 Intel Corporation.
;
; The information and source code contained herein is the exclusive property
; of Intel Corporation and may not be disclosed, examined, or reproduced in
; whole or in part without explicit written authorization from the Company.
;
; Implemented in VNIIEF-STL, july 2000

; double ceil (double x)
;
; Willamette specific version (MASM 6.15 required)
;
; Description:
;  The ceil function returns the smallest integer value not less than x,
;  expressed as a (double-precision) floating-point number.
;
; Special cases:
;  ceil(NaN) = that NaN
;  ceil(INF) = that INF
;  ceil(0) = that 0
;
; Accuracy:
;  The result is always exact.

.xlist
	include cruntime.inc
.list

EXTRN C __libm_error_support : NEAR  

_FUNC_     equ	<ceil>
_FUNC_DEF_ equ	<_ceil_default>
_FUNC_P4_  equ	<_ceil_pentium4>
_FUNC_DEF_EXTERN_ equ 1
	include	disp_pentium4.inc

      .const
      ALIGN 16

;-- 16x-aligned data --------------------------------------------------------

_One  DQ 03ff0000000000000H,03ff0000000000000H
_Bns  DQ 00000000000000433H,00000000000000433H
_Zero DQ 00000000000000000H,00000000000000000H
_S    DQ 000000000000007ffH,00000000000000000H

;-- 8x-aligned data ---------------------------------------------------------

_NegZero DQ 08000000000000000H

      codeseg
      ALIGN 16

; double ceil (double x);

; Stack frame locations

ceil_x TEXTEQU <esp+4>
XMMWORD TEXTEQU <OWORD>

PUBLIC _ceil_pentium4
_ceil_pentium4 PROC NEAR
    movq      xmm0, QWORD PTR [ceil_x]           ;
    movapd    xmm2, XMMWORD PTR _Bns             ;
    movapd    xmm1, xmm0                         ;
    movapd    xmm7, xmm0                         ;
    psrlq     xmm0, 52                           ; exp(x)
    movd      eax, xmm0                          ;
    andpd     xmm0, XMMWORD PTR _S               ;
    psubd     xmm2, xmm0                         ;
    psrlq     xmm1, xmm2                         ;

    test      eax, 0800H                         ;
    je        SHORT positive                     ;
    cmp       eax, 0bffH                         ;
    jl        SHORT ret_zero                     ;
    psllq     xmm1, xmm2                         ;
    cmp       eax, 0c32H                         ;
    jg        SHORT return_x                     ;
    movq      QWORD PTR [ceil_x], xmm1           ;
    fld       QWORD PTR [ceil_x]                 ;
    ret                                          ;

return_x:

    ucomisd   xmm7, xmm7
    jnp       not_nan

    mov       edx, 1004
    ;call libm_error_support(void *arg1,void *arg2,void *retval,error_types input_tag)
    sub       esp, 16
    mov       DWORD PTR [esp+12],edx
    mov       edx, esp
    add       edx, 16+4
    mov       DWORD PTR [esp+8],edx
    mov       DWORD PTR [esp+4],edx
    mov       DWORD PTR [esp],edx
    call      NEAR PTR __libm_error_support
    add       esp, 16

not_nan:
    fld       QWORD PTR [ceil_x]                 ;
    ret                                          ;

positive:

    movq      xmm0, QWORD PTR [ceil_x]           ;
    psllq     xmm1, xmm2                         ;
    movapd    xmm3, xmm0                         ;
    cmppd     xmm0, xmm1, 6                      ; !<=

    cmp       eax, 03ffH                         ;
    jl        SHORT ret_one                      ;
    cmp       eax, 0432H                         ;
    jg        SHORT return_x                     ;

    andpd     xmm0, XMMWORD PTR _One             ;
    addsd     xmm1, xmm0                         ;
    movq      QWORD PTR [ceil_x], xmm1           ;
    fld       QWORD PTR [ceil_x]                 ;
    ret                                          ;

ret_zero:

    fld       QWORD PTR _NegZero                 ;
    ret                                          ;

ret_one:

    cmppd     xmm3, XMMWORD PTR _Zero, 6         ; !<=
    andpd     xmm3, XMMWORD PTR _One             ;
    movq      QWORD PTR [ceil_x], xmm3           ;
    fld       QWORD PTR [ceil_x]                 ;
    ret                                          ;

_ceil_pentium4 ENDP

    END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\i386\debug.c ===
/*****************************************************************/
/*            Copyright (c) 1998 Intel Corporation               */        
/*                                                               */
/* All rights reserved.  No part of this program or publication  */
/* may be reproduced, transmitted, transcribed, stored in a      */
/* retrieval system, or translated into any language or computer */
/* language, in any form or by any means, electronic, mechanical */
/* magnetic, optical, chemical, manual, or otherwise, without    */
/* the prior written permission of Intel Corporation.            */
/*                                                               */
/*****************************************************************/
/*          INTEL CORPORATION PROPRIETARY INFORMATION            */
/*                                                               */
/*                                                               */
/*****************************************************************/

/*++

  Module Name:

    debug.c

Abstract:

    This module provides handy routines for debugging

Author:

Revision History:

--*/


#include <wtypes.h>
#include <stdio.h>
#include <conio.h>
#include "fpieee.h"
#include "xmmi_types.h"
#include "temp_context.h"
#include "filter.h"
#include "debug.h"


ULONG   DebugFlag = 0;
ULONG   Console = 0;
ULONG   DebugImm8 = 0;
ULONG   NotOk = 0;

#define DUMP_HEXL(pxmmi, num)    { \
    PRINTF(("in Hex:  ")); \
    for (i = 0; i < num; i++) { \
        PRINTF(("[%d] %x ", i, pxmmi->u.ul[i])); \
    } \
    PRINTF(("\n")); }

#define DUMP_FS(pxmmi, num)    { \
    PRINTF(("in Fflt: ")); \
    for (i = 0; i < num; i++) { \
        PRINTF(("[%d] %f ", i, pxmmi->u.fs[i])); \
    } \
    PRINTF(("\n")); }

#define DUMP_HEXLL(pxmmi, num)    { \
    PRINTF(("in Hex:  ")); \
    for (i = 0; i < num; i++) { \
        PRINTF(("[%d] %I64x ", i, pxmmi->u.ull[i])); \
    } \
    PRINTF(("\n")); }

#define DUMP_DS(pxmmi, num)    { \
    PRINTF(("in Dflt: ")); \
    for (i = 0; i < num; i++) { \
        PRINTF(("[%d] %e ", i, pxmmi->u.fd[i])); \
    } \
    PRINTF(("\n")); }


void
print_Rounding(PXMMI_ENV XmmiEnv) {

  if (XmmiEnv->Ieee->RoundingMode == _FpRoundNearest) {
      PRINTF(("XmmiEnv->Ieee->RoundingMode = _FpRoundNearest\n"));
  } else {
      if (XmmiEnv->Ieee->RoundingMode == _FpRoundMinusInfinity) { 
          PRINTF(("XmmiEnv->Ieee->RoundingMode = _FpRoundMinusInfinity\n"));
      } else {
          if (XmmiEnv->Ieee->RoundingMode == _FpRoundPlusInfinity) {
              PRINTF(("XmmiEnv->Ieee->RoundingMode = _FpRoundPlusInfinity\n"));
          } else {
              if (XmmiEnv->Ieee->RoundingMode == _FpRoundChopped) {
                  PRINTF(("XmmiEnv->Ieee->RoundingMode = _FpRoundChopped\n"));
              } else {
                  PRINTF(("XmmiEnv->Ieee->RoundingMode = UNKNOWN\n"));
              }
          }
      }
  }

}

void
print_Precision(PXMMI_ENV XmmiEnv) {

  if (XmmiEnv->Ieee->Precision == _FpPrecision24) {
      PRINTF(("XmmiEnv->Ieee->Precision = _FpPrecision24\n"));
  } else {
      if (XmmiEnv->Ieee->Precision == _FpPrecision53) {
          PRINTF(("XmmiEnv->Ieee->Precision = _FpPrecision53\n"));
      } else {
          if (XmmiEnv->Ieee->Precision == _FpPrecisionFull) {
              PRINTF(("XmmiEnv->Ieee->Precision = _FpPrecisionFull\n"));
          } else {
              PRINTF(("XmmiEnv->Ieee->Precision = INCORRECT\n"));
          }
      }
  }

}

void
print_CauseEnable(PXMMI_ENV XmmiEnv) {

  PRINTF(("XmmiEmv->Ieee->Cause:     P=%x U=%x O=%x Z=%x I=%x\n",
      XmmiEnv->Ieee->Cause.Inexact, XmmiEnv->Ieee->Cause.Underflow,
      XmmiEnv->Ieee->Cause.Overflow, XmmiEnv->Ieee->Cause.ZeroDivide,
      XmmiEnv->Ieee->Cause.InvalidOperation));
  PRINTF(("XmmiEnv->Ieee->Enable: P=%x U=%x O=%x Z=%x I=%x\n",
      XmmiEnv->Ieee->Enable.Inexact, XmmiEnv->Ieee->Enable.Underflow,
      XmmiEnv->Ieee->Enable.Overflow, XmmiEnv->Ieee->Enable.ZeroDivide,
      XmmiEnv->Ieee->Enable.InvalidOperation));

}

void
print_Status(PXMMI_ENV XmmiEnv) {

  PRINTF(("XmmiEnv->Ieee->Status: P=%x U=%x O=%x Z=%x I=%x\n",
      XmmiEnv->Ieee->Status.Inexact, XmmiEnv->Ieee->Status.Underflow,
      XmmiEnv->Ieee->Status.Overflow, XmmiEnv->Ieee->Status.ZeroDivide,
      XmmiEnv->Ieee->Status.InvalidOperation));

}

void
print_Operations(PXMMI_ENV XmmiEnv) {

    switch (XmmiEnv->Ieee->Operation) {
    case OP_ADDPS:
      PRINTF(("XmmiEnv->Ieee->Operation = OP_ADDPS\n"));
      break;
    case OP_ADDSS:
      PRINTF(("XmmiEnv->Ieee->Operation = OP_ADDSS\n"));
      break;
    case OP_SUBPS:
      PRINTF(("XmmiEnv->Ieee->Operation = OP_SUBPS\n"));
      break;
    case OP_SUBSS:
      PRINTF(("XmmiEnv->Ieee->Operation = OP_SUBSS\n"));
      break;
    case OP_MULPS:
      PRINTF(("XmmiEnv->Ieee->Operation = OP_MULPS\n"));
      break;
    case OP_MULSS:
      PRINTF(("XmmiEnv->Ieee->Operation = OP_MULSS\n"));
      break;
    case OP_DIVPS:
      PRINTF(("XmmiEnv->Ieee->Operation = OP_DIVPS\n"));
      break;
    case OP_DIVSS:
      PRINTF(("XmmiEnv->Ieee->Operation = OP_DIVSS\n"));
      break;
    case OP_MAXPS:
      PRINTF(("XmmiEnv->Ieee->Operation = OP_MAXPS\n"));
      break;
    case OP_MAXSS:
      PRINTF(("XmmiEnv->Ieee->Operation = OP_MAXSS\n"));
      break;
    case OP_MINPS:
      PRINTF(("XmmiEnv->Ieee->Operation = OP_MINPS\n"));
      break;
    case OP_MINSS:
      PRINTF(("XmmiEnv->Ieee->Operation = OP_MINSS\n"));
      break;
    case OP_CVTPI2PS:
      PRINTF(("XmmiEnv->Ieee->Operation = OP_CVTPI2PS\n"));
      break;
    case OP_CVTSI2SS:
      PRINTF(("XmmiEnv->Ieee->Operation = OP_CVTSI2SS\n"));
      break;
    case OP_CVTPS2PI:
      PRINTF(("XmmiEnv->Ieee->Operation = OP_CVTPS2PI\n"));
      break;
    case OP_CVTSS2SI:
      PRINTF(("XmmiEnv->Ieee->Operation = OP_CVTSS2SI\n"));
      break;
    case OP_CVTTPS2PI:
      PRINTF(("XmmiEnv->Ieee->Operation = OP_CVTTPS2PI\n"));
      break;
    case OP_CVTTSS2SI:
      PRINTF(("XmmiEnv->Ieee->Operation = OP_CVTTSS2SI\n"));
      break;
    case OP_COMISS:
      PRINTF(("XmmiEnv->Ieee->Operation = OP_COMISS\n"));
      break;
    case OP_UCOMISS:
      PRINTF(("XmmiEnv->Ieee->Operation = OP_UCOMISS\n"));
      break;
    case OP_CMPPS:
    case OP_CMPSS: 
    case OP_CMPPD:  
    case OP_CMPSD:    
      PRINTF(("XmmiEnv->Ieee->Operation = OP_CMPPS/CMPSS/CMPPD/CMPSD "));

      switch (XmmiEnv->Imm8 & 0x07) {

        case IMM8_EQ:
          PRINTF(("EQ\n"));
          break;
        case IMM8_UNORD:
          PRINTF(("UNORD\n"));
          break;
        case IMM8_NEQ:
          PRINTF(("NEQ\n"));
          break;
        case IMM8_ORD:
          PRINTF(("ORD\n"));
          break;
        case IMM8_LT:
          PRINTF(("LT\n"));
          break;
        case IMM8_LE:
          PRINTF(("LE\n"));
          break;
        case IMM8_NLT:
          PRINTF(("NLT\n"));
          break;
        case IMM8_NLE:
          PRINTF(("NLE\n"));
          break;
        default:
          ; // will never occur

      }
      break;
    case OP_SQRTPS:
      PRINTF(("XmmiEnv->Ieee->Operation = OP_SQRTPS\n"));
      break;
    case OP_SQRTSS:
      PRINTF(("XmmiEnv->Ieee->Operation = OP_SQRTSS\n"));
      break;
    case OP_ADDPD:
      PRINTF(("XmmiEnv->Ieee->Operation = OP_ADDPD\n"));
      break;
    case OP_ADDSD:   
      PRINTF(("XmmiEnv->Ieee->Operation = OP_ADDSD\n"));
      break;        
    case OP_SUBPD:    
      PRINTF(("XmmiEnv->Ieee->Operation = OP_SUBPD\n"));
      break;        
    case OP_SUBSD:   
      PRINTF(("XmmiEnv->Ieee->Operation = OP_SUBSD\n"));
      break;        
    case OP_MULPD: 
      PRINTF(("XmmiEnv->Ieee->Operation = OP_MULPD\n"));
      break;
    case OP_MULSD:  
      PRINTF(("XmmiEnv->Ieee->Operation = OP_MULSD\n"));
      break;        
    case OP_DIVPD:    
      PRINTF(("XmmiEnv->Ieee->Operation = OP_DIVPD\n"));
      break;
    case OP_DIVSD:   
      PRINTF(("XmmiEnv->Ieee->Operation = OP_DIVSD\n"));
      break;        
    case OP_SQRTPD:  
      PRINTF(("XmmiEnv->Ieee->Operation = OP_SQRTPD\n"));
      break;       
    case OP_SQRTSD: 
      PRINTF(("XmmiEnv->Ieee->Operation = OP_SQRTSD\n"));
      break;        
    case OP_MAXPD:  
      PRINTF(("XmmiEnv->Ieee->Operation = OP_MAXPD\n"));
      break;        
    case OP_MAXSD:  
      PRINTF(("XmmiEnv->Ieee->Operation = OP_MAXSD\n"));
      break;        
    case OP_MINPD: 
      PRINTF(("XmmiEnv->Ieee->Operation = OP_MINPD\n"));
      break;        
    case OP_MINSD:
      PRINTF(("XmmiEnv->Ieee->Operation = OP_MINSD\n"));
      break;                
    case OP_COMISD:   
      PRINTF(("XmmiEnv->Ieee->Operation = OP_COMISD\n"));
      break;        
    case OP_UCOMISD:   
      PRINTF(("XmmiEnv->Ieee->Operation = OP_UCOMISD\n"));
      break;
    case OP_CVTPD2PI:  
      PRINTF(("XmmiEnv->Ieee->Operation = OP_CVTPD2PI\n"));
      break;
    case OP_CVTSD2SI:  
      PRINTF(("XmmiEnv->Ieee->Operation = OP_CVTSD2SI\n"));
      break;
    case OP_CVTTPD2PI: 
      PRINTF(("XmmiEnv->Ieee->Operation = OP_CVTTPD2PI\n"));
      break;
    case OP_CVTTSD2SI: 
      PRINTF(("XmmiEnv->Ieee->Operation = OP_CVTTSD2SI\n"));
      break;
    case OP_CVTPS2PD:
      PRINTF(("XmmiEnv->Ieee->Operation = OP_CVTPS2PD\n"));
      break;        
    case OP_CVTSS2SD: 
      PRINTF(("XmmiEnv->Ieee->Operation = OP_CVTSS2SD\n"));
      break;        
    case OP_CVTPD2PS:
      PRINTF(("XmmiEnv->Ieee->Operation = OP_CVTPD2PS\n"));
      break;        
    case OP_CVTSD2SS:  
      PRINTF(("XmmiEnv->Ieee->Operation = OP_CVTSD2SS\n"));
      break;        
    case OP_CVTDQ2PS:  
      PRINTF(("XmmiEnv->Ieee->Operation = OP_CVTDQ2PS\n"));
      break;
    case OP_CVTTPS2DQ: 
      PRINTF(("XmmiEnv->Ieee->Operation = OP_CVTTPS2DQ\n"));
      break;
    case OP_CVTPS2DQ:  
      PRINTF(("XmmiEnv->Ieee->Operation = OP_CVTPS2DQ\n"));
      break;
    case OP_CVTPD2DQ:
      PRINTF(("XmmiEnv->Ieee->Operation = OP_CVTPD2DQ\n"));
      break;        
    case OP_CVTTPD2DQ:
      PRINTF(("XmmiEnv->Ieee->Operation = OP_CVTTPD2DQ\n"));
      break;
        
    default:
      PRINTF(("XmmiEnv->Ieee->Operation %d = UNKNOWN\n",
          XmmiEnv->Ieee->Operation));
    }
}

void
print_Operand1(PXMMI_ENV XmmiEnv) {

    PRINTF(("XmmiEnv->Ieee->Operand1.OperandValid = %x\n",
        XmmiEnv->Ieee->Operand1.OperandValid));

    if (!XmmiEnv->Ieee->Operand1.OperandValid) return;

    if (XmmiEnv->Ieee->Operand1.Format == _FpFormatFp32) {
        PRINTF(("XmmiEnv->Ieee->Operand1.Format = _FpFormatFp32\n"));
        PRINTF(("XmmiEnv->Ieee->Operand1.Value.Fp32Value = %f = %x\n",
            (float)XmmiEnv->Ieee->Operand1.Value.Fp32Value,
            XmmiEnv->Ieee->Operand1.Value.U32Value));
    } else if (XmmiEnv->Ieee->Operand1.Format == _FpFormatU32) {
        PRINTF(("XmmiEnv->Ieee->Operand1.Format = _FpFormatU32\n"));
        PRINTF(("XmmiEnv->Ieee->Operand1.Value.U32Value = %d = %x\n",
            XmmiEnv->Ieee->Operand1.Value.U32Value,
            XmmiEnv->Ieee->Operand1.Value.U32Value));
    } else if (XmmiEnv->Ieee->Operand1.Format == _FpFormatI32) {
        PRINTF(("XmmiEnv->Ieee->Operand1.Format = _FpFormatI32\n"));
        PRINTF(("XmmiEnv->Ieee->Operand1.Value.I32Value = %d = %x\n",
            XmmiEnv->Ieee->Operand1.Value.I32Value,
            XmmiEnv->Ieee->Operand1.Value.U32Value));
    } else if (XmmiEnv->Ieee->Operand1.Format == _FpFormatFp64) {
        PRINTF(("XmmiEnv->Ieee->Operand1.Format = _FpFormatFp64\n"));
        PRINTF(("XmmiEnv->Ieee->Operand1.Value.Fp64Value = %e = %I64x\n",
            (double)XmmiEnv->Ieee->Operand1.Value.Fp64Value,
            XmmiEnv->Ieee->Operand1.Value.U64Value));
    } else {
        PRINTF(("XmmiEnv->Ieee->Operand1.Format = INCORRECT\n"));
    }

}

void
print_Operand2(PXMMI_ENV XmmiEnv) {

    PRINTF(("XmmiEnv->Ieee->Operand2.OperandValid = %x\n",
        XmmiEnv->Ieee->Operand2.OperandValid));

    if (!XmmiEnv->Ieee->Operand2.OperandValid) return;

    if (XmmiEnv->Ieee->Operand2.Format == _FpFormatFp32) {
        PRINTF(("XmmiEnv->Ieee->Operand2.Format = _FpFormatFp32\n"));
        PRINTF(("XmmiEnv->Ieee->Operand2.Value.Fp32Value = %f = %x\n",
            (float)XmmiEnv->Ieee->Operand2.Value.Fp32Value,
            XmmiEnv->Ieee->Operand2.Value.U32Value));
    } else if (XmmiEnv->Ieee->Operand2.Format == _FpFormatU32) {
        PRINTF(("XmmiEnv->Ieee->Operand2.Format = _FpFormatU32\n"));
        PRINTF(("XmmiEnv->Ieee->Operand2.Value.U32Value = %d = %x\n",
            XmmiEnv->Ieee->Operand2.Value.U32Value,
            XmmiEnv->Ieee->Operand2.Value.U32Value));
    } else if (XmmiEnv->Ieee->Operand2.Format == _FpFormatI32) {
        PRINTF(("XmmiEnv->Ieee->Operand2.Format = _FpFormatI32\n"));
        PRINTF(("XmmiEnv->Ieee->Operand2.Value.I32Value = %d = %x\n",
            XmmiEnv->Ieee->Operand2.Value.I32Value,
            XmmiEnv->Ieee->Operand2.Value.U32Value));
    } else if (XmmiEnv->Ieee->Operand2.Format == _FpFormatFp64) {
        PRINTF(("XmmiEnv->Ieee->Operand2.Format = _FpFormatFp64\n"));
        PRINTF(("XmmiEnv->Ieee->Operand2.Value.Fp64Value = %e = %I64x\n",
            (double)XmmiEnv->Ieee->Operand2.Value.Fp64Value,
            XmmiEnv->Ieee->Operand2.Value.U64Value));
    } else {
        PRINTF(("XmmiEnv->Ieee->Operand2.Format = INCORRECT\n"));
    }
 
}

void
print_Result(PXMMI_ENV XmmiEnv, BOOL Exception) {

    PRINTF(("XmmiEnv->Ieee->Result.OperandValid = %x\n",
        XmmiEnv->Ieee->Result.OperandValid));

    if (XmmiEnv->Ieee->Result.OperandValid) {
        if (XmmiEnv->Ieee->Result.Format == _FpFormatFp32) {
            PRINTF(("XmmiEnv->Ieee->Result.Format = _FpFormatFp32\n")); 
            PRINTF(("XmmiEnv->Ieee->Result.Value.Fp32Value = %f = %x\n",
                (float)XmmiEnv->Ieee->Result.Value.Fp32Value,
                XmmiEnv->Ieee->Result.Value.U32Value));
        } else if (XmmiEnv->Ieee->Result.Format == _FpFormatU32) {
            PRINTF(("XmmiEnv->Ieee->Result.Format = _FpFormatU32\n")); 
            PRINTF(("XmmiEnv->Ieee->Result.Value.U32Value = %d = %x\n",
                XmmiEnv->Ieee->Result.Value.U32Value,
                XmmiEnv->Ieee->Result.Value.U32Value));
        } else if (XmmiEnv->Ieee->Result.Format == _FpFormatI32) {
            PRINTF(("XmmiEnv->Ieee->Result.Format = _FpFormatI32\n")); 
            PRINTF(("XmmiEnv->Ieee->Result.Value.I32Value = %d = %x\n",
                XmmiEnv->Ieee->Result.Value.I32Value,
                XmmiEnv->Ieee->Result.Value.U32Value));
        } else if (XmmiEnv->Ieee->Result.Format == _FpFormatFp64) {
            PRINTF(("XmmiEnv->Ieee->Result.Format = _FpFormatFp64\n"));
            PRINTF(("XmmiEnv->Ieee->Result.Value.Fp64Value = %e = %I64x\n",
                (double)XmmiEnv->Ieee->Result.Value.Fp64Value,
                XmmiEnv->Ieee->Result.Value.U64Value));
        } else {
            PRINTF(("XmmiEnv->Ieee->Result.Format = INCORRECT\n"));
        }
    }

    if (!Exception) {
        if (XmmiEnv->Ieee->Operation == _FpCodeCompare) {
            PRINTF(("XmmiEnv->EFlags = %x\n", XmmiEnv->EFlags)); 
        }
    }

}


void print_FPIEEE_RECORD_EXCEPTION (PXMMI_ENV XmmiEnv) {

  // print the FP IEEE record info
  PRINTF(("\nPRINTING FPIEEE_RECORD INFO (EXCEPTION):\n"));

  PRINTF(("XmmiEnv->Masks = %x\n", XmmiEnv->Masks));
  PRINTF(("XmmiEnv->Flags = %x\n", XmmiEnv->Flags));
  PRINTF(("XmmiEnv->Fz = %x\n", XmmiEnv->Fz));
  PRINTF(("XmmiEnv->Daz = %x\n", XmmiEnv->Daz));

  print_Rounding(XmmiEnv);
  print_Precision(XmmiEnv);
  print_CauseEnable(XmmiEnv);
  print_Status(XmmiEnv);
  print_Result(XmmiEnv, TRUE);

  PRINTF(("\n"));

}


void print_FPIEEE_RECORD_NO_EXCEPTION (PXMMI_ENV XmmiEnv) {

  // print the FP IEEE record result info
  PRINTF(("\nPRINTING FPIEEE_RECORD INFO (NO EXCEPTION):\n"));

  PRINTF(("XmmiEnv->Masks = %x\n", XmmiEnv->Masks));
  PRINTF(("XmmiEnv->Flags = %x\n", XmmiEnv->Flags));
  PRINTF(("XmmiEnv->Fz = %x\n", XmmiEnv->Fz));
  PRINTF(("XmmiEnv->Daz = %x\n", XmmiEnv->Daz));

  print_Rounding(XmmiEnv);
  print_Precision(XmmiEnv);
  print_Status(XmmiEnv);
  print_Result(XmmiEnv, FALSE);

  PRINTF(("\n"));

}

void print_FPIEEE_RECORD (PXMMI_ENV XmmiEnv) {
    

  // print input values
  PRINTF(("XmmiEnv->Masks = %x\n", XmmiEnv->Masks));
  PRINTF(("XmmiEnv->Flags = %x\n", XmmiEnv->Flags));
  PRINTF(("XmmiEnv->Fz = %x\n", XmmiEnv->Fz));
  PRINTF(("XmmiEnv->Daz = %x\n", XmmiEnv->Daz));

  if (XmmiEnv->Rc == _FpRoundNearest) {
      PRINTF(("XmmiEnv->Rc = _FpRoundNearest\n"));
  } else {
      if (XmmiEnv->Rc == _FpRoundMinusInfinity) { 
          PRINTF(("XmmiEnv->Rc = _FpRoundMinusInfinity\n"));
      } else {
          if (XmmiEnv->Rc == _FpRoundPlusInfinity) {
              PRINTF(("XmmiEnv->Rc = _FpRoundPlusInfinity\n"));
          } else {
              if (XmmiEnv->Rc == _FpRoundChopped) {
                  PRINTF(("XmmiEnv->Rc = _FpRoundChopped\n"));
              } else {
                  PRINTF(("XmmiEnv->Rc = UNKNOWN\n"));
              }
          }
      }
  }

  if (XmmiEnv->Precision == _FpPrecision24) {
      PRINTF(("XmmiEnv->Precision = _FpPrecision24\n"));
  } else {
      if (XmmiEnv->Precision == _FpPrecision53) {
          PRINTF(("XmmiEnv->Precision = _FpPrecision53\n"));
      } else {
          if (XmmiEnv->Precision == _FpPrecisionFull) {
              PRINTF(("XmmiEnv->Precision = _FpPrecisionFull\n"));
          } else {
              PRINTF(("XmmiEnv->Precision = INCORRECT\n"));
          }
      }
  }

  print_Operations(XmmiEnv);
  print_Operand1(XmmiEnv);
  print_Operand2(XmmiEnv);

}


void
dump_DataXMMI2(PTEMP_EXCEPTION_POINTERS p)
{

    PEXCEPTION_RECORD exc;
    PTEMP_CONTEXT pctxt;
    PFLOATING_EXTENDED_SAVE_AREA pExtendedArea;
    PXMMI_AREA XmmiArea;
    PX87_AREA X87Area;
    PXMMI128 xmmi128;
    PXMMI128 reg0, reg1, reg2, reg3, reg4, reg5, reg6, reg7;
    PMMX64 mmx0, mmx1, mmx2, mmx3, mmx4, mmx5, mmx6, mmx7;
    ULONG i;

    exc = p->ExceptionRecord;
    pctxt = p->ContextRecord;
    pExtendedArea = (PFLOATING_EXTENDED_SAVE_AREA) &pctxt->ExtendedRegisters[0];
    XmmiArea = (PXMMI_AREA) &pExtendedArea->XMMIRegisterArea[0];
    X87Area = (PX87_AREA) &pExtendedArea->X87RegisterArea[0];
    
    reg0 = (PXMMI128) &XmmiArea->Xmmi[0];
    reg1 = (PXMMI128) &XmmiArea->Xmmi[1]; 
    reg2 = (PXMMI128) &XmmiArea->Xmmi[2];
    reg3 = (PXMMI128) &XmmiArea->Xmmi[3]; 
    reg4 = (PXMMI128) &XmmiArea->Xmmi[4];
    reg5 = (PXMMI128) &XmmiArea->Xmmi[5]; 
    reg6 = (PXMMI128) &XmmiArea->Xmmi[6];
    reg7 = (PXMMI128) &XmmiArea->Xmmi[7]; 

    mmx0 = (PMMX64) &X87Area->Mm[0].Mmx;
    mmx1 = (PMMX64) &X87Area->Mm[1].Mmx;
    mmx2 = (PMMX64) &X87Area->Mm[2].Mmx;
    mmx3 = (PMMX64) &X87Area->Mm[3].Mmx;
    mmx4 = (PMMX64) &X87Area->Mm[4].Mmx;
    mmx5 = (PMMX64) &X87Area->Mm[5].Mmx;
    mmx6 = (PMMX64) &X87Area->Mm[6].Mmx;
    mmx7 = (PMMX64) &X87Area->Mm[7].Mmx;

    xmmi128 = (PXMMI128) pExtendedArea->DataOffset;

    PRINTF(("Dump Saved Area:\n"));
    PRINTF(("Registers: Edi 0x%x Esi 0x%x Ebx 0x%x, Edx 0x%x, Ecx 0x%x, Eax 0x%x, Ebp 0x%x\n",
            pctxt->Edi, pctxt->Esi, pctxt->Ebx, pctxt->Edx,
            pctxt->Ecx, pctxt->Eax, pctxt->Ebp));
        
    PRINTF(("pExtendedArea->DataOffset\n"));
    DUMP_HEXLL(xmmi128, 2);
    DUMP_DS(xmmi128, 2);

    PRINTF(("mmx reg0:\n"));
    DUMP_HEXL(mmx0, 2);

    PRINTF(("mmx reg1:\n"));
    DUMP_HEXL(mmx1, 2);

    PRINTF(("mmx reg2:\n"));
    DUMP_HEXL(mmx2, 2);

    PRINTF(("mmx reg3:\n"));
    DUMP_HEXL(mmx3, 2);

    PRINTF(("mmx reg4:\n"));
    DUMP_HEXL(mmx4, 2);

    PRINTF(("mmx reg5:\n"));
    DUMP_HEXL(mmx5, 2);

    PRINTF(("mmx reg6:\n"));
    DUMP_HEXL(mmx6, 2);

    PRINTF(("mmx reg7:\n"));
    DUMP_HEXL(mmx7, 2);

    PRINTF(("xmmi reg0: (+0, -0)\n"));
    DUMP_HEXLL(reg0, 2);
    DUMP_DS(reg0, 2);

    PRINTF(("xmmi reg1: (+1.5*2^1022, +denormalized finite)\n"));
    DUMP_HEXLL(reg1, 2);
    DUMP_DS(reg1, 2);

    PRINTF(("xmmi reg2: (-denormalized finite, +normalized finite)\n"));
    DUMP_HEXLL(reg2, 2);
    DUMP_DS(reg2, 2);

    PRINTF(("xmmi reg3: (-normalized finite, +infinites)\n"));
    DUMP_HEXLL(reg3, 2);
    DUMP_DS(reg3, 2);

    PRINTF(("xmmi reg4: (-infinity, +1.1111110...011*2^-1022)\n"));
    DUMP_HEXLL(reg4, 2);
    DUMP_DS(reg4, 2);

    PRINTF(("xmmi reg5: (SNan, SNan)\n"));
    DUMP_HEXLL(reg5, 2);
    DUMP_DS(reg5, 2);

    PRINTF(("xmmi reg6: (QNan, QNan)\n"));
    DUMP_HEXLL(reg6, 2);
    DUMP_DS(reg6, 2);

    PRINTF(("xmmi reg7: (+1.375*2^1022, +1.11111110...01 * 2^-1022)\n"));
    DUMP_HEXLL(reg7, 2);
    DUMP_DS(reg7, 2);

}

void
dump_Data(PTEMP_EXCEPTION_POINTERS p)
{

    PEXCEPTION_RECORD exc;
    PTEMP_CONTEXT pctxt;
    PFLOATING_EXTENDED_SAVE_AREA pExtendedArea;
    PXMMI_AREA XmmiArea;
    PX87_AREA X87Area;
    PXMMI128 xmmi128;
    PXMMI128 reg0, reg1, reg2, reg3, reg4, reg5, reg6, reg7;
    PMMX64 mmx0, mmx1, mmx2, mmx3, mmx4, mmx5, mmx6, mmx7;
    ULONG i;

    exc = p->ExceptionRecord;
    pctxt = p->ContextRecord;
    pExtendedArea = (PFLOATING_EXTENDED_SAVE_AREA) &pctxt->ExtendedRegisters[0];
    XmmiArea = (PXMMI_AREA) &pExtendedArea->XMMIRegisterArea[0];
    X87Area = (PX87_AREA) &pExtendedArea->X87RegisterArea[0];
    
    reg0 = (PXMMI128) &XmmiArea->Xmmi[0];
    reg1 = (PXMMI128) &XmmiArea->Xmmi[1]; 
    reg2 = (PXMMI128) &XmmiArea->Xmmi[2];
    reg3 = (PXMMI128) &XmmiArea->Xmmi[3]; 
    reg4 = (PXMMI128) &XmmiArea->Xmmi[4];
    reg5 = (PXMMI128) &XmmiArea->Xmmi[5]; 
    reg6 = (PXMMI128) &XmmiArea->Xmmi[6];
    reg7 = (PXMMI128) &XmmiArea->Xmmi[7]; 

    mmx0 = (PMMX64) &X87Area->Mm[0].Mmx;
    mmx1 = (PMMX64) &X87Area->Mm[1].Mmx;
    mmx2 = (PMMX64) &X87Area->Mm[2].Mmx;
    mmx3 = (PMMX64) &X87Area->Mm[3].Mmx;
    mmx4 = (PMMX64) &X87Area->Mm[4].Mmx;
    mmx5 = (PMMX64) &X87Area->Mm[5].Mmx;
    mmx6 = (PMMX64) &X87Area->Mm[6].Mmx;
    mmx7 = (PMMX64) &X87Area->Mm[7].Mmx;

    xmmi128 = (PXMMI128) pExtendedArea->DataOffset;

    PRINTF(("Dump Saved Area:\n"));
    PRINTF(("Registers: Edi 0x%x Esi 0x%x Ebx 0x%x, Edx 0x%x, Ecx 0x%x, Eax 0x%x, Ebp 0x%x\n",
            pctxt->Edi, pctxt->Esi, pctxt->Ebx, pctxt->Edx,
            pctxt->Ecx, pctxt->Eax, pctxt->Ebp));
        
    PRINTF(("pExtendedArea->DataOffset\n"));
    DUMP_HEXL(xmmi128, 4);
    DUMP_FS(xmmi128, 4);

    PRINTF(("mmx reg0:\n"));
    DUMP_HEXL(mmx0, 2);

    PRINTF(("mmx reg1:\n"));
    DUMP_HEXL(mmx1, 2);

    PRINTF(("mmx reg2:\n"));
    DUMP_HEXL(mmx2, 2);

    PRINTF(("mmx reg3:\n"));
    DUMP_HEXL(mmx3, 2);

    PRINTF(("mmx reg4:\n"));
    DUMP_HEXL(mmx4, 2);

    PRINTF(("mmx reg5:\n"));
    DUMP_HEXL(mmx5, 2);

    PRINTF(("mmx reg6:\n"));
    DUMP_HEXL(mmx6, 2);

    PRINTF(("mmx reg7:\n"));
    DUMP_HEXL(mmx7, 2);

    PRINTF(("xmmi reg0: (n, n, n, n)\n"));
    DUMP_HEXL(reg0, 4);
    DUMP_FS(reg0, 4);

    PRINTF(("xmmi reg1: (+0, -0, +denormalized finite, n)\n"));
    DUMP_HEXL(reg1, 4);
    DUMP_FS(reg1, 4);

    PRINTF(("xmmi reg2: (-denormalized finite, +normalized finite, -normalized finite, n)\n"));
    DUMP_HEXL(reg2, 4);
    DUMP_FS(reg2, 4);

    PRINTF(("xmmi reg3: (+infinites, -infinites, n, 1000003)\n"));
    DUMP_HEXL(reg3, 4);
    DUMP_FS(reg3, 4);

    PRINTF(("xmmi reg4: (n, n, n, n)\n"));
    DUMP_HEXL(reg4, 4);
    DUMP_FS(reg4, 4);

    PRINTF(("xmmi reg5: (SNan, SNan, n, n)\n"));
    DUMP_HEXL(reg5, 4);
    DUMP_FS(reg5, 4);

    PRINTF(("xmmi reg6: (QNan, QNan, 7ec00000, n)\n"));
    DUMP_HEXL(reg6, 4);
    DUMP_FS(reg6, 4);

    PRINTF(("xmmi reg7: (n, n, 7eb00000, 100004)\n"));
    DUMP_HEXL(reg7, 4);
    DUMP_FS(reg7, 4);

}

void
dump_OpLocation(POPERAND Operand) {

    if (!Operand->Op.OperandValid) {
        PRINTF(("Operand Invalid\n")) 
        return;
    }

    switch (Operand->OpLocation) {
    case ST0:
        PRINTF(("OpLocation = ST0 "));
        break;
    case ST1:
        PRINTF(("OpLocation = ST1 "));
        break;
    case ST2:
        PRINTF(("OpLocation = ST2 "));
        break;
    case ST3:
        PRINTF(("OpLocation = ST3 "));
        break;
    case ST4:
        PRINTF(("OpLocation = ST4 "));
        break;
    case ST5:
        PRINTF(("OpLocation = ST5 "));
        break;
    case ST6:
        PRINTF(("OpLocation = ST6 "));
        break;
    case ST7:
        PRINTF(("OpLocation = ST7 "));
        break;
    case REG:
        PRINTF(("OpLocation = REG "));
        PRINTF(("OpReg %x", Operand->OpReg));
        break;
    case RS:
        PRINTF(("OpLocation = RS "));
        break;
    case M16I:
        PRINTF(("OpLocation = M16I "));
        break;
    case M32I:
        PRINTF(("OpLocation = M32I "));
        break;
    case M64I:
        PRINTF(("OpLocation = M64I "));
        break;
    case M32R:
        PRINTF(("OpLocation = M32R "));
        break;
    case M64R:
        PRINTF(("OpLocation = M64R "));
        break;
    case M80R:
        PRINTF(("OpLocation = M80R "));
        break;
    case M80D:
        PRINTF(("OpLocation = M80D "));
        break;
    case Z80R:
        PRINTF(("OpLocation = Z80R "));
        break;
    case M128_M32R:
        PRINTF(("OpLocation = M128_M32R "));
        break;
    case M128_M64R:
        PRINTF(("OpLocation = M128_M64R "));
        break;
    case MMX:
        PRINTF(("OpLocation = MMX "));
        PRINTF(("OpReg %x", Operand->OpReg));
        break;
    case XMMI:
        PRINTF(("OpLocation = XMMI "));
        PRINTF(("OpReg %x", Operand->OpReg));
        break;
    case XMMI2:
        PRINTF(("OpLocation = XMMI2 "));
        PRINTF(("OpReg %x", Operand->OpReg));
        break;
    case IMM8:
        PRINTF(("OpLocation = IMM8 "));
        break;
    case M64R_64:
        PRINTF(("OpLocation = M64R_64 "));
        break;
    case M128_M32I:
        PRINTF(("OpLocation = M128_M32I "));
        break;
    case XMMI_M32I:
        PRINTF(("OpLocation = XMMI_M32I "));
        PRINTF(("OpReg %x", Operand->OpReg));
        break;
    case LOOKUP:
        PRINTF(("OpLocation = LOOKUP "));
        break;
    case INV:
        PRINTF(("OpLocation = INV "));
        break;
    default:
        PRINTF(("?"));
    }

    PRINTF(("\n"));

}

void
dump_XmmiFpEnv(
    PXMMI_FP_ENV XmmiFpEnv) {
    
    POPERAND Operand;
    XMMI_ENV XmmiEnv;
    _FPIEEE_RECORD ieee;

    XmmiEnv.Ieee = &ieee;
    XmmiEnv.Ieee->Operation = XmmiFpEnv->OriginalOperation;
    XmmiEnv.Imm8 = XmmiFpEnv->Imm8;
    print_Operations(&XmmiEnv);
        
    Operand = &XmmiFpEnv->Operand1;
    PRINTF(("Operand1: "));
    dump_OpLocation(Operand);

    Operand = &XmmiFpEnv->Operand2;
    PRINTF(("Operand2: "));
    dump_OpLocation(Operand);

}

void
dump_Control(PTEMP_EXCEPTION_POINTERS p) {

    PEXCEPTION_RECORD exc;
    PTEMP_CONTEXT pctxt;
    PFLOATING_EXTENDED_SAVE_AREA pExtendedArea;
    PULONG istream;

    exc = p->ExceptionRecord;
    pctxt = p->ContextRecord;
    pExtendedArea = (PFLOATING_EXTENDED_SAVE_AREA) &pctxt->ExtendedRegisters[0];
    istream = (PULONG) pctxt->Eip;

    PRINTF(("EIP %x ExceptionRecord %x ContextRecord %x ExtendedArea %x\n",
             istream, exc, pctxt, pExtendedArea));
    PRINTF(("MXCsr: %x, CW: %x\n", pExtendedArea->MXCsr, pExtendedArea->ControlWord));

}

void
dump_Format(_FPIEEE_VALUE *Operand) {

    _U64 u64;
    _I64 i64;
    _FP80 fp80;
    _FP128 fp128;
    ULONG i;

    if (!Operand->OperandValid) {
        PRINTF(("Operand Invalid\n")); 
    }

    PRINTF(("Format/Value: "));
    switch (Operand->Format) {
    case _FpFormatFp32:
         PRINTF(("_FpFormatFp32 %f", Operand->Value.Fp32Value));
         PRINTF((" = (hex) %x\n", Operand->Value.U32Value));
         break;
    case _FpFormatFp64:
         PRINTF(("_FpFormatFp64 %e\n", Operand->Value.Fp64Value));
         for (i=0; i < 3; i++) {
             PRINTF((" = (hex) %x\n", Operand->Value.U64Value.W[i]));
         }
         break;
    case _FpFormatFp80:
         fp80 = Operand->Value.Fp80Value;
         PRINTF(("_FpFormatFp80 (hex)"));        
         for (i=0; i < 5; i++) {
             PRINTF((" %x", fp80.W[i]));
         }
         break;
    case _FpFormatFp128:
         fp128 = Operand->Value.Fp128Value;
         PRINTF(("_FpFormatFp128 (hex)"));        
         for (i=0; i < 4; i++) {
             PRINTF((" %x", fp128.W[i]));
         }
         break;
    case _FpFormatI16:
         PRINTF(("_FpFormatI16 %d\n", Operand->Value.I16Value));
         break;
    case _FpFormatI32:
         PRINTF(("_FpFormatI32 %d", Operand->Value.I32Value));
         PRINTF((" = (hex) %x\n", Operand->Value.U32Value));
         break;
    case _FpFormatI64:
         i64 = Operand->Value.I64Value;
         PRINTF(("_FpFormatI64 (hex)"));  
         for (i=0; i < 2; i++) {
             PRINTF((" %x", i64.W[i]));
         }
         break;
    case _FpFormatU16:
         PRINTF(("_FpFormatU16 h%u\n", Operand->Value.U16Value));
         break;
    case _FpFormatU32:
         PRINTF(("_FpFormatU32 l%u\n", Operand->Value.U32Value));
         PRINTF((" = (hex) %x\n", Operand->Value.U32Value));
         break;
    case _FpFormatU64:
         u64 = Operand->Value.U64Value;
         PRINTF(("_FpFormatU64 (hex)"));  
         for (i=0; i < 2; i++) {
             PRINTF((" %x", u64.W[i]));
         }
         break;
    case _FpFormatCompare:
         PRINTF(("_FpFormatCompare %x\n", Operand->Value.CompareValue));
         break;
    case _FpFormatString:
         PRINTF(("_FpFormatString %s\n", Operand->Value.StringValue));
         break;

    default:
         PRINTF(("?"));
         break;

    }

    PRINTF(("\n"));

    return;

}

void
dump_fpieee_record(_FPIEEE_RECORD *pieee) {

    XMMI_ENV XmmiEnv;

    XmmiEnv.Ieee = pieee;
    PRINTF(("OPERATION: 0x%x\n", pieee->Operation));

    print_Rounding(&XmmiEnv);
    print_Precision(&XmmiEnv);
    print_CauseEnable(&XmmiEnv);
    print_Status(&XmmiEnv);
        
    PRINTF(("Operand 1:\n"));
    dump_Format(&pieee->Operand1);
    PRINTF(("Operand 2: \n"));
    dump_Format(&pieee->Operand2);

    PRINTF(("Result:"));
    dump_Format(&pieee->Result);

}

void 
print_FPIEEE_RECORD_EXCEPTION1 (PXMMI_ENV XmmiEnv, ULONG res1, ULONG res0, ULONG flags) {

  // print the FP IEEE record info
  PRINTF(("\nPRINTING FPIEEE_RECORD INFO (EXCEPTION):\n"));

  if (res1 != XmmiEnv->Ieee->Result.Value.U64Value.W[1] ||
      res0 != XmmiEnv->Ieee->Result.Value.U64Value.W[0])
      PRINTF (("ERROR: expected res = %8.8x %8.8x got res = %8.8x %8.8x\n",
      res1, res0, XmmiEnv->Ieee->Result.Value.U64Value.W[1],
      XmmiEnv->Ieee->Result.Value.U64Value.W[0]));

  if (flags != XmmiEnv->Flags)
      PRINTF (("ERROR: expected flags = %x got flags = %x\n",
      flags, XmmiEnv->Flags));

  PRINTF(("XmmiEnv->Masks = %x\n", XmmiEnv->Masks));
  PRINTF(("XmmiEnv->Flags = %x\n", XmmiEnv->Flags));
  PRINTF(("XmmiEnv->Fz = %x\n", XmmiEnv->Fz));
  PRINTF(("XmmiEnv->Daz = %x\n", XmmiEnv->Daz));

  print_Rounding(XmmiEnv);
  print_Precision(XmmiEnv);
  print_CauseEnable(XmmiEnv);
  print_Status(XmmiEnv);
  print_Result(XmmiEnv, TRUE);

  PRINTF(("\n"));

}

void
print_FPIEEE_RECORD_EXCEPTION2 (PXMMI_ENV XmmiEnv, ULONG res, ULONG flags) {

  // print the FP IEEE record info
  PRINTF(("\nPRINTING FPIEEE_RECORD INFO (EXCEPTION):\n"));

  if (res != XmmiEnv->Ieee->Result.Value.U32Value)
      printf ("ERROR: expected res = %x got res = %f = %8.8x\n",
      res, XmmiEnv->Ieee->Result.Value.Fp32Value,
      XmmiEnv->Ieee->Result.Value.U32Value);

  if (flags != XmmiEnv->Flags)
      printf ("ERROR: expected flags = %x got flags = %x\n",
      flags, XmmiEnv->Flags);

  PRINTF(("XmmiEnv->Masks = %x\n", XmmiEnv->Masks));
  PRINTF(("XmmiEnv->Flags = %x\n", XmmiEnv->Flags));
  PRINTF(("XmmiEnv->Fz = %x\n", XmmiEnv->Fz));
  PRINTF(("XmmiEnv->Daz = %x\n", XmmiEnv->Daz));

  print_Rounding(XmmiEnv);
  print_Precision(XmmiEnv);
  print_CauseEnable(XmmiEnv);
  print_Status(XmmiEnv);
  print_Result(XmmiEnv, TRUE);

  PRINTF(("\n"));

}

void
print_FPIEEE_RECORD_EXCEPTION3 (PXMMI_ENV XmmiEnv, ULONG eflags, ULONG flags) {

  // print the FP IEEE record info
  PRINTF(("\nPRINTING FPIEEE_RECORD INFO (EXCEPTION):\n"));

  if (eflags != XmmiEnv->EFlags)
      printf ("ERROR: expected eflags = %x got eflags = %x\n",
      eflags, XmmiEnv->EFlags);

  if (flags != XmmiEnv->Flags)
      printf ("ERROR: expected flags = %x got flags = %x\n",
      flags, XmmiEnv->Flags);

  PRINTF(("XmmiEnv->Masks = %x\n", XmmiEnv->Masks));
  PRINTF(("XmmiEnv->Flags = %x\n", XmmiEnv->Flags));
  PRINTF(("XmmiEnv->Fz = %x\n", XmmiEnv->Fz));
  PRINTF(("XmmiEnv->Daz = %x\n", XmmiEnv->Daz));

  print_Rounding(XmmiEnv);
  print_Precision(XmmiEnv);
  print_CauseEnable(XmmiEnv);
  print_Status(XmmiEnv);

  PRINTF(("\n"));

}

void 
print_FPIEEE_RECORD_NO_EXCEPTION1 (PXMMI_ENV XmmiEnv, ULONG res1, ULONG res0, ULONG flags) {

  // print the FP IEEE record result info
  PRINTF(("\nPRINTING FPIEEE_RECORD INFO (NO EXCEPTION):\n"));

  if (res1 != XmmiEnv->Ieee->Result.Value.U64Value.W[1] ||
      res0 != XmmiEnv->Ieee->Result.Value.U64Value.W[0])
      PRINTF (("ERROR: expected res = %8.8x %8.8x got res = %8.8x %8.8x\n",
      res1, res0, XmmiEnv->Ieee->Result.Value.U64Value.W[1],
      XmmiEnv->Ieee->Result.Value.U64Value.W[0]));

  if (flags != XmmiEnv->Flags)
      PRINTF (("ERROR: expected flags = %x got flags = %x\n",
      flags, XmmiEnv->Flags));

  PRINTF(("XmmiEnv->Masks = %x\n", XmmiEnv->Masks));
  PRINTF(("XmmiEnv->Flags = %x\n", XmmiEnv->Flags));
  PRINTF(("XmmiEnv->Fz = %x\n", XmmiEnv->Fz));
  PRINTF(("XmmiEnv->Daz = %x\n", XmmiEnv->Daz));

  print_Rounding(XmmiEnv);
  print_Precision(XmmiEnv);
  print_Status(XmmiEnv);
  print_Result(XmmiEnv, FALSE);

  PRINTF(("\n"));

}

void
print_FPIEEE_RECORD_NO_EXCEPTION2 (PXMMI_ENV XmmiEnv, ULONG res, ULONG flags) {

  // print the FP IEEE record result info
  PRINTF(("\nPRINTING FPIEEE_RECORD INFO (NO EXCEPTION):\n"));

  if (res != XmmiEnv->Ieee->Result.Value.U32Value)
      printf ("ERROR: expected res = %x got res = %f = %8.8x\n",
      res, XmmiEnv->Ieee->Result.Value.Fp32Value,
      XmmiEnv->Ieee->Result.Value.U32Value);

  if (flags != XmmiEnv->Flags)
      printf ("ERROR: expected flags = %x got flags = %x\n",
      flags, XmmiEnv->Flags);

  PRINTF(("XmmiEnv->Masks = %x\n", XmmiEnv->Masks));
  PRINTF(("XmmiEnv->Flags = %x\n", XmmiEnv->Flags));
  PRINTF(("XmmiEnv->Fz = %x\n", XmmiEnv->Fz));
  PRINTF(("XmmiEnv->Daz = %x\n", XmmiEnv->Daz));

  print_Rounding(XmmiEnv);
  print_Precision(XmmiEnv);
  print_Status(XmmiEnv);
  print_Result(XmmiEnv, FALSE);

  PRINTF(("\n"));

}


void
print_FPIEEE_RECORD_NO_EXCEPTION3 (PXMMI_ENV XmmiEnv, ULONG eflags, ULONG flags)
 {

  // print the FP IEEE record result info
  PRINTF(("\nPRINTING FPIEEE_RECORD INFO (NO EXCEPTION):\n"));

  if (eflags != XmmiEnv->EFlags)
      printf ("ERROR: expected eflags = %x got eflags = %x\n",
      eflags, XmmiEnv->EFlags);

  if (flags != XmmiEnv->Flags)
      printf ("ERROR: expected flags = %x got flags = %x\n",
      flags, XmmiEnv->Flags);

  PRINTF(("XmmiEnv->Masks = %x\n", XmmiEnv->Masks));
  PRINTF(("XmmiEnv->Flags = %x\n", XmmiEnv->Flags));
  PRINTF(("XmmiEnv->Fz = %x\n", XmmiEnv->Fz));
  PRINTF(("XmmiEnv->Daz = %x\n", XmmiEnv->Daz));

  print_Rounding(XmmiEnv);
  print_Precision(XmmiEnv);
  print_Status(XmmiEnv);
  print_Result(XmmiEnv, FALSE);

  PRINTF(("\n"));

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\i386\cos.asm ===
;***
;
;   Copyright (c) 1984-2001, Microsoft Corporation. All rights reserved.
;
;Revision History:
;
;*******************************************************************************

_COS_ equ 1
include trig.asm
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\i386\atan_pentium4.asm ===
;/* File: "atan_wmt.asm". */
;//
;//               INTEL CORPORATION PROPRIETARY INFORMATION
;//  This software is supplied under the terms of a license agreement or
;//  nondisclosure agreement with Intel Corporation and may not be copied
;//  or disclosed except in accordance with the terms of that agreement.
;//        Copyright (c) 2000 Intel Corporation. All Rights Reserved.
;//
;//
;//  Contents:      atan.
;//
;//  Purpose:       Libm 
;//

    .686P
    .387
    .XMM
    .MODEL FLAT,C

EXTRN C __libm_error_support : NEAR  

CONST	SEGMENT PARA PUBLIC USE32 'CONST'
        ALIGN 16

EXTRN C _atan_table:QWORD

_atn TEXTEQU <_atan_table>

;/*
;//   FUNCTION:     double atan(double x)
;//
;//   DESCRIPTION:
;//
;//      1. For |x| < 2^(-27), where atan(x) ~= x, return x.
;//      2. For |x| >= 0.1633123935319536975596774e+17, where atan(x) ~= +-Pi/2, return +-Pi/2.
;//      3. In interval [0.0,0.03125] polynomial approximation of atan(x)=x-x*P(x^2).
;//      4. In interval [0.03125,0.375] polynomial approximation of atan(x)=x-x*D(x^2).
;//      5. In interval [0.375,8.0] we compute ind and eps such, that x=0.03125*ind+eps and 0.0<eps<0.03125.
;//         Let s=0.03125*ind, then atan(x)=atan(s)+atan(t), where t=((x-s)/(1+x*s)). For lo and hi part of
;//         atan(s) we have table (see file atan_table.c): atn[ind]+atn[ind+1]=atan(s).
;//         atan(t) is approximated atan(t)=t-t*P(t^2).
;//      6. In interval [8.0,0.1633123935319536975596774e+17] atan(x)=Pi/2+atan(-1/x).
;//         atan(-1/x) is approximated atan(t)=t-t*P(t^2), where t=-1/x.
;//      7. For x < 0.0 atan(x) = -atan(|x|).
;//      8. Special cases:
;//         atan(+0)   = +0;
;//         atan(-0)   = -0;
;//         atan(+INF) = +Pi/2;
;//         atan(-INF) = -Pi/2;
;//         atan(NaN)  = NaN.
;//
;//   KEYS OF COMPILER: -c -w -Zl -Di386 /QIfdiv-
;*/

_mexp   DQ  07ff0000000000000H, 07ff0000000000000H
_mabs   DQ  07fffffffffffffffH, 07fffffffffffffffH
_pi_2d  DQ  03ff921fb54442d18H, 0bff921fb54442d18H
_cntshf DQ  00000000000040201H, 00000000000040201H
_d1400  DQ  03fd5555555555552H, 00000000000000000H
_d1213  DQ  03fc249249246aa76H, 0bfc99999999992acH
_d1011  DQ  03fb745d15933de8aH, 0bfbc71c71b835923H
_d89    DQ  03fb110f5eeb76ecaH, 0bfb3b1390a3b9899H
_d67    DQ  03faae4492fe3a600H, 0bfae1c1704144b68H
_d45    DQ  03fa51fa164891abeH, 0bfa8171d55d53138H
_d23    DQ  03f974721481ca2a2H, 0bfa124ce2388f2cbH
_d01    DQ  03f66107c30e0b8a5H, 0bf866e5652b14bbdH
_p60    DQ  03fd55555555554ebH, 00000000000000000H
_p45    DQ  03fc249249014497eH, 0bfc9999999976718H
_p23    DQ  03fb7453ba342480fH, 0bfbc71c4eebfb10eH
_p01    DQ  03fae9be97b0f8d08H, 0bfb39ad683f878c6H
_zero   DQ  00000000000000000H, 00000000000000000H
_onen   DQ  0bff0000000000000H, 0bff0000000000000H
_one    DQ  03ff0000000000000H, 03ff0000000000000H
_cnst8  DQ  04020000000000000H, 04020000000000000H
_in3    DQ  04020000000000000H, 04020000000000000H
_in2    DQ  03fd8000000000000H, 03fd8000000000000H
_in1    DQ  03fa0000000000000H, 03fa0000000000000H
_in0    DQ  03e40000000000000H, 03e40000000000000H
_in     DQ  0434d02967c31cdb5H, 0434d02967c31cdb5H
_minval DQ  00010000000000000H, 00010000000000000H
libm_small  DQ  00200000000000000H 
CONST	ENDS

_x      TEXTEQU     <esp+4>
XMMWORD TEXTEQU <OWORD>

_TEXT   SEGMENT PARA PUBLIC USE32 'CODE'
        ALIGN       4

PUBLIC C _atan_pentium4, _CIatan_pentium4
_CIatan_pentium4  PROC NEAR
	push	    ebp
	mov 	    ebp, esp 
	sub         esp, 8                          ; for argument DBLSIZE
	and         esp, 0fffffff0h
	fstp        qword ptr [esp]
	movq        xmm7, qword ptr [esp]
	call        start
	leave
	ret
_atan_pentium4   label proc
        movq        xmm7, QWORD PTR [_x]            ;  x
start:
        unpcklpd    xmm7, xmm7
        movapd      xmm2, xmm7
        andpd       xmm2, XMMWORD PTR _mabs         ; |x|
        comisd      xmm2, XMMWORD PTR _in           ; |x| < 0.1633123935319536975596774e+17 ?
        jp          x_nan
        jae         bigx
        comisd      xmm2, XMMWORD PTR _in1          ; |x| < 0.03125 ?
        jae         xge0_03125
        comisd      xmm2, XMMWORD PTR _in0          ; |x| < 2^(-27) ?
        jb          retx                            ; atan(x) ~= x

        ; 2^(-27) < |x| < 0.03125, atan(x)=x-x*P(x^2)

        movapd      xmm1, xmm2
        mulpd       xmm1, xmm2                      ; |x|^2
        movapd      xmm3, xmm1
        mulpd       xmm3, xmm1                      ; |x|^4
        movapd      xmm5, XMMWORD PTR _p01          ; calculate P(x^2)
        mulpd       xmm5, xmm3
        addpd       xmm5, XMMWORD PTR _p23
        mulpd       xmm5, xmm3
        addpd       xmm5, XMMWORD PTR _p45
        mulpd       xmm5, xmm3
        addpd       xmm5, XMMWORD PTR _p60
        mulsd       xmm5, xmm1
        movapd      xmm3, xmm5
        shufpd      xmm3, xmm3, 1
        addsd       xmm5, xmm3                      ; P(x^2)
        mulsd       xmm5, xmm7                      ; x * P(x^2)
        subsd       xmm7, xmm5                      ; x - x * P(x^2)
        movq        QWORD PTR [_x], xmm7
        fld         QWORD PTR [_x]
        ret

xge0_03125:                                         ; |x| >= 0.03125
        comisd    xmm2, XMMWORD PTR _in2            ; |x| < 0.375 ?
        jae       xge0_375

        ; 0.03125 < |x| < 0.375, atan(x)=x-x*D(x^2)

        movapd      xmm1, xmm2
        mulpd       xmm1, xmm2                      ; |x|^2
        movapd      xmm3, xmm1
        mulpd       xmm3, xmm1                      ; |x|^4
        movapd      xmm5, XMMWORD PTR _d01          ; calculate D(x^2)
        mulpd       xmm5, xmm3
        addpd       xmm5, XMMWORD PTR _d23
        mulpd       xmm5, xmm3
        addpd       xmm5, XMMWORD PTR _d45
        mulpd       xmm5, xmm3
        addpd       xmm5, XMMWORD PTR _d67
        mulpd       xmm5, xmm3
        addpd       xmm5, XMMWORD PTR _d89
        mulpd       xmm5, xmm3
        addpd       xmm5, XMMWORD PTR _d1011
        mulpd       xmm5, xmm3
        addpd       xmm5, XMMWORD PTR _d1213
        mulpd       xmm5, xmm3
        addpd       xmm5, XMMWORD PTR _d1400
        mulsd       xmm5, xmm1
        movapd      xmm3, xmm5
        shufpd      xmm3, xmm3, 1
        addsd       xmm5, xmm3                      ; D(x^2)
        mulsd       xmm5, xmm7                      ; x * D(x^2)
        subsd       xmm7, xmm5                      ; x - x * D(x^2)
        movq        QWORD PTR [_x], xmm7
        fld         QWORD PTR [_x]
        ret

xge0_375:                                           ; |x| >= 0.375
        movq        xmm6, xmm7                      ; x
        xorpd       xmm6, xmm2                      ; sign x
        comisd      xmm2, XMMWORD PTR _in3          ; |x| < 8.0 ?
        jae         xge8_0

;       0.375 < |x| < 8.0:
;       atan(|x|)=atan(s)+atan(t), s=ind*0.03125, t=(|x|-s)/(1+|x|*s)

        movq        xmm0, XMMWORD PTR _cnst8
        movq        xmm5, XMMWORD PTR _cntshf
        movq        xmm3, xmm2                      ; calculate ind
        addsd       xmm3, xmm0
        psrlq       xmm3, 44
        psubd       xmm3, xmm5
        movd        eax,  xmm3                      ; ind
        lea         eax,  DWORD PTR [eax+eax*2]     ; ind*3
        movq        xmm5, QWORD PTR _atn[eax*8+16]  ; s
        movq        xmm3, xmm2                      ; |x|
        subsd       xmm2, xmm5                      ; |x|-s
        mulsd       xmm3, xmm5                      ; |x|*s
        addsd       xmm3, XMMWORD PTR _one          ; 1+|x|*s
        divsd       xmm2, xmm3                      ; (|x|-s)/(1+|x|*s)
        unpcklpd    xmm2, xmm2
        jmp         clcpol

xge8_0:                                             ; |x| > 8.0

;       8.0 < |x| < 0.1633123935319536975596774e+17:
;       atan(|x|)=Pi/2+atan(-1/|x|)

        mov         eax, 768                        ; ind*3 - entry point in table, where lo and hi part of Pi/2
        movq        xmm0, xmm2                      ; |x|
        movq        xmm2, XMMWORD PTR _onen
        divsd       xmm2, xmm0                      ;-1/|x|
        unpcklpd    xmm2, xmm2

clcpol:
        movq        xmm0, QWORD PTR _atn[0+eax*8]   ; atn[ind+0] - hi part of atan(s) or Pi/2
        movq        xmm4, QWORD PTR _atn[8+eax*8]   ; atn[ind+1] - lo part of atan(s) or Pi/2
        movapd      xmm1, xmm2
        mulpd       xmm1, xmm2                      ; |x|^2
        movapd      xmm3, xmm1
        mulpd       xmm3, xmm1                      ; |x|^4
        movapd      xmm5, XMMWORD PTR _p01          ; calculate P(x^2)
        mulpd       xmm5, xmm3
        addpd       xmm5, XMMWORD PTR _p23
        mulpd       xmm5, xmm3
        addpd       xmm5, XMMWORD PTR _p45
        mulpd       xmm5, xmm3
        addpd       xmm5, XMMWORD PTR _p60
        mulsd       xmm5, xmm1
        movapd      xmm3, xmm5
        shufpd      xmm3, xmm3, 1
        addsd       xmm5, xmm3                      ; P(x^2)

;       atan(|x|) = atn[ind+0]-((|x|*P(x^2)-atn[ind+1])-|x|)

        mulsd       xmm5, xmm2                      ; |x|*P(x^2)
        subsd       xmm5, xmm4                      ; |x|*P(x^2)-atn[ind+1]
        subsd       xmm5, xmm2                      ; (|x|*P(x^2)-atn[ind+1])-|x|
        subsd       xmm0, xmm5                      ; atn[ind+0]-((|x|*P(x^2)-atn[ind+1])-|x|)
        orpd        xmm0, xmm6                      ; sign x
        movq        QWORD PTR [_x], xmm0
        fld         QWORD PTR [_x]
        ret

retx:                                               ; |x| < 2^(-27): atan(x) ~= x
        comisd      xmm2, XMMWORD PTR _zero         ; x == 0 ?
        jne         notzero
        fld         QWORD PTR [_x]                  ; x == +0.0 or -0.0
        ret

notzero:
        comisd      xmm2, XMMWORD PTR _minval       ; x < minval ?
        jae         ge_minval
        fld         QWORD PTR libm_small
        fmul        QWORD PTR libm_small
        sub         esp, 8
        fstp        QWORD PTR [esp]                 ; should be flag UNDERFLOW
        fld         QWORD PTR [esp]
        add         esp, 8
        fadd        QWORD PTR [_x]                  ; should be inexact result
        ret

ge_minval:                                          ; minval < x < 2^(-27)
        fld         QWORD PTR libm_small
        fmul        QWORD PTR libm_small
        fadd        QWORD PTR [_x]                  ; should be inexact result
        ret

bigx:                                               ; |x| > 0.1633123935319536975596774e+17
        movq        xmm0, xmm2                      ; |x|
        movq        xmm3, QWORD PTR _mexp
        andpd       xmm0, xmm3
        ucomisd     xmm0, xmm3
        jp          x_nan

        mov         eax, DWORD PTR [_x+4]           ; x
        shr         eax, 31                         ; sign x
        fld         QWORD PTR libm_small
        fadd        QWORD PTR _pi_2d[eax*8]         ; should be inexact result
        ret                                         ; return +-Pi/2

x_nan:
        mov         edx, 1003
        ;call libm_error_support(void *arg1,void *arg2,void *retval,error_types input_tag)
        sub         esp, 16
        mov         DWORD PTR [esp+12],edx
        mov         edx, esp
        add         edx, 16+4
        mov         DWORD PTR [esp+8],edx
        mov         DWORD PTR [esp+4],edx
        mov         DWORD PTR [esp],edx
        call        NEAR PTR __libm_error_support
        add         esp, 16

        fld         QWORD PTR [_x]
        ret                                         ; return same nan

        ALIGN       4

_CIatan_pentium4  ENDP

_TEXT   ENDS

        END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\i386\common.asm ===
;***
;
;   Copyright (c) 1984-2001, Microsoft Corporation. All rights reserved.
;
;Revision History:
;
;*******************************************************************************

.xlist
        include cruntime.inc
        include elem87.inc
.list
              .const
staticQ One,                    03FF0000000000000R
globalW _DEFAULT_CW_in_mem      027fh
globalT _pi_by_2_to_61          0403ec90fdaa22168c235R        ; (2**61) * pi
staticQ DblMax,                 07fefffffffffffffR
staticQ DblMin,                 00010000000000000R
staticQ IeeeAdjO,               0c098000000000000R
staticQ IeeeAdjU,               04098000000000000R
staticQ _infinity,              07ff0000000000000R
staticQ _zero,                  00000000000000000R

        CODESEG

extrn   _startOneArgErrorHandling:near
extrn   _startTwoArgErrorHandling:near

;***********************************************************
;
;                           _twoToTOS
;
;***********************************************************
; Recieves:
;        TOS is not NaN
; Retunns:
;        2^TOS
; Note:
;        uses 3 entries of FPU stack

_twoToTOS        proc
        fld     st(0)                         ; duplicate stack top
        frndint                               ; N = round(y)
        fsubr   st(1), st
        fxch
        fchs                                  ; g = y - N where abs(g) < 1
        f2xm1                                 ; 2**g - 1
        fld1
        fadd                                  ; 2**g
        fscale                                ; (2**g) * (2**N) - gives 2**y
        fstp    st(1)
        ret                                   ; pop extra stuff from fp stack
_twoToTOS        endp


;***********************************************************
;
;                           _load_CW
;
;***********************************************************
;        receives current control word on stack
;        and it's known that it differs from default
; Purpose:
;       load default CW, but take precision from current CW (bits 8 and 9)
; Note:
;       value of edx is destroyed
;
_load_CW        proc
        mov     edx,[esp+4]
        and     edx,0300H                     ; all bits except precision are zero
        or      edx,DEFAULT_CW_without_precision
        mov     [esp+6],dx                    ; use 2 free bytes in stack
        fldcw   [esp+6]
        ret
_load_CW        endp

;***********************************************************
;
;                           _convertTOStoQNaN
;
;***********************************************************
; Recieves:
;        TOS is QNaN or SNaN
;        eax is high dword of TOS
; Retunns:
;        if TOS=QNaN
;            eax=DOMAIN_QNAN
;        else (TOS=SNaN)
;            eax=DOMAIN
;        TOS=QNaN

_convertTOStoQNaN  proc
        test    eax, 00080000H                ; test weather arg is QNaN or SNaN
        jz      tosIsSNaN
        mov     eax,DOMAIN_QNAN               ; TOS is QNaN
        ret
tosIsSNaN:
        fadd    [One]                         ; convert SNaN to QNan
        mov     eax,DOMAIN                    ; TOS was SNaN
        ret                                   ; _cdecl return

_convertTOStoQNaN  endp



;***********************************************************
;
;                           _fload_withFB
;
;***********************************************************
; Load arg in the fp stack without raising an exception if the argument
; is a signaling NaN
; In other words, when arg is 53-bit SNaN convert it to 64-bit SNaN
;
; edx points to argument (in double precision)
; return value:
;   if we have normal number:
;        eax=exponent
;        Zero flag is 0
;   if we have special number:
;        eax=high dword
;        Zero flag is 1

_fload_withFB   proc                          ; load with feed back
        mov     eax, [edx+4]                  ; get exponent field
        and     eax, 07ff00000h
        cmp     eax, 07ff00000h               ; check for special exponent
        je      fpload_special
        fld     qword ptr[edx]                ; ZF=0
        ret                                   ; _cdecl return

; have special argument (NaN or INF)
fpload_special:                               ; convert to long double
        mov     eax,[edx+4]                   ; high dword of double
        sub     esp,LDBLSIZE
        or      eax, 7fff0000h                ; preserve sign, set max long double exp
        mov     [esp+6],eax                   ; store sign and power
        mov     eax,[edx+4]                   ; low dword of double
        mov     ecx,[edx]
        shld    eax,ecx,11
        shl     ecx,11

        mov     [esp+4],eax
        mov     [esp],ecx
        fld     tbyte ptr [esp]
        add     esp,LDBLSIZE
        test    eax,0                         ; ZF=1
        mov     eax,[edx+4]                   ; high dword of double

        ret                                   ; _cdecl return
_fload_withFB  endp

;***********************************************************
;
;                   _checkTOS_withFB
;
;***********************************************************
; Test first argument on INTEGER stack and set registers and flags exactly like _fload_withFB
;
; we have on stack : ret_value(4 bytes), arg1(8 bytes)
; return value:
;   if we have normal number:
;        eax=exponent
;        Zero flag is 0
;   if we have special number:
;        eax=high dword
;        Zero flag is 1

_checkTOS_withFB        proc
        mov     eax, [esp+8]                  ; get high dword
        and     eax,07ff00000h
        cmp     eax,07ff00000h                ; check for special exponent
                                              ; and set ZF
        je      special_exp
        ret                                   ; _cdecl return
special_exp:
        mov     eax, [esp+8]                  ; get exponent field
        ret                                   ; _cdecl return

_checkTOS_withFB  endp


;***********************************************************
;
;                        _fast_exit
;
;***********************************************************
;   called after execution of each math function (sin,cos, ....),
;         and if __fastflag!=0
;
_fast_exit      proc
        cmp     word ptr[esp],default_CW
        je      fast_exit_CW_is_restored
        fldcw   [esp]
fast_exit_CW_is_restored:
        pop     edx                           ; remove saved CW from stack
        ret                                   ; _cdecl return
_fast_exit      endp


;***********************************************************
;
;                        _math_exit
;
;***********************************************************
; called after execution of each math function (sin,cos, ....)
; and if __fastflag=0.
; The purpose is to check inexact exception.
; ecx        points to function name
; edx   function id (for example OP_LOG)

_math_exit      proc
        mov     ax,word ptr[esp]
        cmp     ax,default_CW
        je      CW_is_restored                ; we assume here that in default CW inexact
                                              ; exception is masked
        and     ax,20h                        ; test if inexact exception is masked
        jz      restore_CW
        fstsw   ax
        and     ax,20h
        jz      restore_CW
        mov     eax,INEXACT
        call    _startOneArgErrorHandling
        pop     edx                           ; remove saved CW from stack
        ret
restore_CW:
        fldcw   [esp]
CW_is_restored:
        pop     edx                           ; remove saved CW from stack
        ret                                   ; _cdecl return
_math_exit      endp


;***********************************************************
;
;                        _check_overflow_exit
;
;***********************************************************
;
_check_overflow_exit        proc
        sub     esp,DBLSIZE                   ; prepare place for argument
        fst     qword ptr[esp]
        mov     eax,[esp+4]                   ; eax=high dword
        add     esp,DBLSIZE
        and     eax,7ff00000H
        jmp     _check_overflow_start
_check_overflow_exit        endp


;***********************************************************
;
;                        _check_range_exit
;
;***********************************************************
; called after execution of math functions, which may generate
; overflow/underflow, and if __fastflag=0.
; used in exp() and pow() functions
; The purpose is to check inexact overflow/underflow and inexact exception
; ecx        points to function name
; edx   function id (for example OP_EXP)

_check_range_exit        proc
        sub     esp,DBLSIZE                   ; prepare place for argument
        fst     qword ptr[esp]
        mov     eax,[esp+4]                   ; eax=high dword
        add     esp,DBLSIZE
        and     eax,7ff00000H
        jz      haveunderflow
_check_overflow_start        label        proc
        cmp     eax,7ff00000H
        jz      haveoverflow

; check INEXACT(precision) exception
        mov     ax,word ptr[esp]             ; saved CW
        cmp     ax,default_CW
        je      CW_is_restored               ; we assume here that in default CW inexact
                                              ; exception is masked
        and     ax,20h                       ; test if inexact exception is masked
        jnz     restore_CW
        fstsw   ax
        and     ax,20h
        jz      restore_CW
        mov     eax,INEXACT
have_error:
        cmp     edx,OP_POW
        je      have_error_in_pow
        call    _startOneArgErrorHandling
        pop     edx                          ; remove saved CW from stack
        ret
have_error_in_pow:
        call    _startTwoArgErrorHandling
        pop     edx                          ; remove saved CW from stack
        ret

restore_CW:
        fldcw   [esp]
CW_is_restored:
        pop     edx                           ; remove saved CW from stack
        ret                                   ; _cdecl return

; this code is taken from previous version, to receive
; exactly the same result as before. But we may simplify it...
haveunderflow:                                ; underflow is detected
        fld     IeeeAdjU
        fxch
        fscale
        fstp    st(1)
        fld     st(0)
        fabs
        fcomp   [DblMin]
        fstsw   ax
        sahf
        mov     eax,UNDERFLOW
        JSAE    have_error
        fmul    [_zero]
        jmp     short have_error

haveoverflow:                                 ; overflow is detected
        fld     IeeeAdjO
        fxch
        fscale
        fstp    st(1)
        fld     st(0)
        fabs
        fcomp   [DblMax]
        fstsw   ax
        sahf
        mov     eax,OVERFLOW
        JSBE    have_error
        fmul    [_infinity]
        jmp     short have_error

_check_range_exit        endp
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\i386\cpu_disp.c ===
/**
*** Copyright  (C) 1985-1998 Intel Corporation.
***
*** The information and source code contained herein is the exclusive property
*** of Intel Corporation and may not be disclosed, examined, or
*** reproduced in whole or in part without explicit written authorization from
*** the Company.
***
*** static char sccs_id[] = "@(#)cpu_disp.c     1.9 06/06/00 14:08:14";
***
**/

#include <sect_attribs.h>
#include <cruntime.h>
#include <internal.h>
#undef leave

#define CPU_HAS_SSE2(x)   (((x) & (1 << 26)) != 0)

#ifdef _MSC_VER

int __sse2_available_init(void);

#pragma data_seg(".CRT$XIC")
_CRTALLOC(".CRT$XIC") static _PIFV pinit = __sse2_available_init;

#pragma data_seg()

#endif /* _MSC_VER */

int __sse2_available;
int __use_sse2_mathfcns;

static int
has_osfxsr_set()
{
    int ret = 0;

    __try {
        __asm movapd xmm0, xmm1;
        ret = 1;
    }
    __except(1) {
    }

    return ret;
}

__declspec(naked) int __sse2_available_init()
{
    int cpu_feature;

    __asm
    {
        push    ebp
        mov     ebp, esp
        sub     esp, __LOCAL_SIZE
        push    ebx
        push    edi
        push    esi

        pushfd                  /* if we can't write to bit 21  */
        pop     eax             /* of the eflags, then we don't */
        mov     ecx, eax        /* have a cpuid instruction.    */
        xor     eax, 0x200000
        push    eax
        popfd
        pushfd
        pop     edx
        sub     edx, ecx
        je      DONE            /* CPUID not available */

        push    ecx             /* restore eflags */
        popfd
        mov     eax, 1
        cpuid
DONE :
        mov     cpu_feature, edx
    }

    __use_sse2_mathfcns = __sse2_available = 0;

    if (CPU_HAS_SSE2(cpu_feature)) {
        if (has_osfxsr_set()) {
            __sse2_available = 1;
#if !defined(_SYSCRT)
            /*
             * The VC++ CRT will automatically enable the SSE2 implementations
             * when possible.  The system CRT will not, so existing apps don't
             * start seeing different results on a Pentium4.
             */
            __use_sse2_mathfcns = 1;
#endif
        }
    }

    __asm
    {
        xor     eax, eax
        pop     esi
        pop     edi
        pop     ebx
        leave
        ret
    }
}

_CRTIMP int __cdecl _set_SSE2_enable(int flag)
{
    return __use_sse2_mathfcns = flag ? __sse2_available : 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\i386\debug.h ===
/***
*       Copyright (c) 1992-2001, Microsoft Corporation. All rights reserved.
*
* Module Name:
*
*    debug.h
*
* Abstract:
*
*    This module contains XMMI debugging definitions.
*   
* Author:
*
*    Ping L. Sager
*
* Revision History:
*
--*/

#include <stdio.h>
#include <conio.h>

extern
ULONG DebugImm8;
extern 
ULONG DebugFlag;
extern 
ULONG Console;
extern
ULONG NotOk;

//Debugging
#define XMMI_INFO        0x00000001
#define XMMI_ERROR       0x00000002
#define XMMI_WARNING     0x00000004


void print_Rounding(PXMMI_ENV XmmiEnv);

void print_Precision(PXMMI_ENV XmmiEnv);

void print_CauseEnable(PXMMI_ENV XmmiEnv);

void print_Status(PXMMI_ENV XmmiEnv);

void print_Operations(PXMMI_ENV XmmiEnv);

void print_Operand1(PXMMI_ENV XmmiEnv);

void print_Operand2(PXMMI_ENV XmmiEnv);

void print_Result(PXMMI_ENV XmmiEnv, BOOL Exception);

void print_FPIEEE_RECORD_EXCEPTION (PXMMI_ENV XmmiEnv);

void print_FPIEEE_RECORD_NO_EXCEPTION (PXMMI_ENV XmmiEnv);

void print_FPIEEE_RECORD (PXMMI_ENV XmmiEnv);
    
void dump_Data(PTEMP_EXCEPTION_POINTERS p);

void dump_DataXMMI2(PTEMP_EXCEPTION_POINTERS p);

void dump_Control(PTEMP_EXCEPTION_POINTERS p);

void dump_XmmiFpEnv(PXMMI_FP_ENV XmmiFpEnv);

void dump_fpieee_record(_FPIEEE_RECORD *pieee);

void dump_OpLocation(POPERAND Operand);

void dump_Format(_FPIEEE_VALUE *Operand);

void print_FPIEEE_RECORD_EXCEPTION1 (PXMMI_ENV, ULONG, ULONG, ULONG);
void print_FPIEEE_RECORD_EXCEPTION2 (PXMMI_ENV, ULONG, ULONG);
void print_FPIEEE_RECORD_EXCEPTION3 (PXMMI_ENV, ULONG, ULONG);

void print_FPIEEE_RECORD_NO_EXCEPTION1 (PXMMI_ENV, ULONG, ULONG, ULONG);
void print_FPIEEE_RECORD_NO_EXCEPTION2 (PXMMI_ENV, ULONG, ULONG);
void print_FPIEEE_RECORD_NO_EXCEPTION3 (PXMMI_ENV, ULONG, ULONG);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\i386\atan_table.c ===
/* File: "atan_table.c". */

/*
//
//               INTEL CORPORATION PROPRIETARY INFORMATION
//  This software is supplied under the terms of a license agreement or
//  nondisclosure agreement with Intel Corporation and may not be copied
//  or disclosed except in accordance with the terms of that agreement.
//        Copyright (c) 2000 Intel Corporation. All Rights Reserved.
//
//  Contents:      Table for functhion atan (see file atan.c and atan_wmt.asm).
//
//  Purpose:       Libm.
//
//
*/

const double _atan_table[] = {
     3.12398332171142101287841796875e-02,    2.131540661249275652049909770325e-10,    3.12500e-02,
     6.24188096262514591217041015625e-02,    3.697058893522750114230051136063e-10,    6.25000e-02,
     9.34767806902527809143066406250e-02,    4.683366825902205526870604788232e-10,    9.37500e-02,
     1.24354993924498558044433593750e-01,    6.222628769869212554138710255732e-10,    1.25000e-01,
     1.54996741563081741333007812500e-01,    3.608592409707065624334921910556e-10,    1.56250e-01,
     1.85347948223352432250976562500e-01,    1.772342332635049398728544644515e-09,    1.87500e-01,
     2.15357698500156402587890625000e-01,    1.197581645436569002166489650499e-09,    2.18750e-01,
     2.44978662580251693725585937500e-01,    5.466124604464965437112758109141e-10,    2.50000e-01,
     2.74167448282241821289062500000e-01,    2.837416976310309398342175801554e-09,    2.81250e-01,
     3.02884865552186965942382812500e-01,    2.822784439618173282005558213292e-09,    3.12500e-01,
     3.31096075475215911865234375000e-01,    1.228916183079104412756944545469e-09,    3.43750e-01,
     3.58770668506622314453125000000e-01,    1.763949905942795063926460499777e-09,    3.75000e-01,
     3.85882668197154998779296875000e-01,    1.200918777118398609607231411754e-09,    4.06250e-01,
     4.12410438060760498046875000000e-01,    3.536626808852916289667126937047e-09,    4.37500e-01,
     4.38336558640003204345703125000e-01,    1.217954601099912924214771330029e-09,    4.68750e-01,
     4.63647607713937759399414062500e-01,    1.286868356814842168961214402029e-09,    5.00000e-01,
     4.88333947956562042236328125000e-01,    3.099843481630836835747064837358e-09,    5.31250e-01,
     5.12389458715915679931640625000e-01,    1.594822026734960395584259254421e-09,    5.62500e-01,
     5.35811230540275573730468750000e-01,    7.420188126538616318707691407099e-09,    5.93750e-01,
     5.58599308133125305175781250000e-01,    7.210437130795726966401661270346e-09,    6.25000e-01,
     5.80756351351737976074218750000e-01,    2.215932423129055725001500862099e-09,    6.56250e-01,
     6.02287344634532928466796875000e-01,    1.500431253215325819204232909999e-09,    6.87500e-01,
     6.23199328780174255371093750000e-01,    1.153891675621381599060374595087e-09,    7.18750e-01,
     6.43501102924346923828125000000e-01,    5.868937462974684228717322638042e-09,    7.50000e-01,
     6.63202986121177673339843750000e-01,    6.584915582023410560238275873263e-09,    7.81250e-01,
     6.82316549122333526611328125000e-01,    5.752414551645101856711152993143e-09,    8.12500e-01,
     7.00854405760765075683593750000e-01,    2.123685096774357531786751268090e-09,    8.43750e-01,
     7.18829996883869171142578125000e-01,    2.737755334274436026525904653951e-09,    8.75000e-01,
     7.36257426440715789794921875000e-01,    2.540712341947913396089146662832e-09,    9.06250e-01,
     7.53151275217533111572265625000e-01,    5.744661277952473745269028881600e-09,    9.37500e-01,
     7.69526474177837371826171875000e-01,    6.227820888580648160985654018868e-09,    9.68750e-01,
     7.85398162901401519775390625000e-01,    4.960467898402702208198757210493e-10,    1.00000e+00,
     8.00781562924385070800781250000e-01,    2.253658389748251166028452574564e-09,    1.03125e+00,
     8.15691918134689331054687500000e-01,    5.181534079966773338745645846567e-09,    1.06250e+00,
     8.30144390463829040527343750000e-01,    4.388234867630905473345013524770e-09,    1.09375e+00,
     8.44153985381126403808593750000e-01,    7.320445987092503982716475065259e-10,    1.12500e+00,
     8.57735492289066314697265625000e-01,    1.646976974689393634401636258728e-09,    1.15625e+00,
     8.70903454720973968505859375000e-01,    2.354678984634313737597814094030e-09,    1.18750e+00,
     8.83672110736370086669921875000e-01,    5.917087395273464170528949437663e-09,    1.21875e+00,
     8.96055378019809722900390625000e-01,    6.551534233274410093029937827025e-09,    1.25000e+00,
     9.08066816627979278564453125000e-01,    2.273925746984707125349512590406e-09,    1.28125e+00,
     9.19719599187374114990234375000e-01,    6.163042702238369079821089425988e-09,    1.31250e+00,
     9.31026540696620941162109375000e-01,    3.271650007157030305038895044289e-09,    1.34375e+00,
     9.42000038921833038330078125000e-01,    1.457630626407859045534593586072e-09,    1.37500e+00,
     9.52652096748352050781250000000e-01,    4.111357358345352207769909959585e-09,    1.40625e+00,
     9.62994329631328582763671875000e-01,    1.049607619051523960997099925814e-09,    1.43750e+00,
     9.73037928342819213867187500000e-01,    6.858995333578316940744079860537e-09,    1.46875e+00,
     9.82793718576431274414062500000e-01,    4.670897793571648111014666014497e-09,    1.50000e+00,
     9.92272108793258666992187500000e-01,    3.583932702000201676434503589257e-09,    1.53125e+00,
     1.00148312747478485107421875000e+00,    8.219449881844110845301437412509e-09,    1.56250e+00,
     1.01043644547462463378906250000e+00,    4.415428828550118277573210101588e-09,    1.59375e+00,
     1.01914133131504058837890625000e+00,    1.295130914625943666702306364877e-08,    1.62500e+00,
     1.02760674059391021728515625000e+00,    9.913158540718138781765724473397e-09,    1.65625e+00,
     1.03584124147891998291015625000e+00,    1.152988019367453822032544397905e-08,    1.68750e+00,
     1.04385308921337127685546875000e+00,    1.039209569213430778015756976209e-08,    1.71875e+00,
     1.05165021121501922607421875000e+00,    1.333354441385648562086299829630e-09,    1.75000e+00,
     1.05924019217491149902343750000e+00,    7.449679592682189804327891757113e-09,    1.78125e+00,
     1.06663036346435546875000000000e+00,    1.851388094329176347420279866865e-09,    1.81250e+00,
     1.07382771372795104980468750000e+00,    8.187892256056230171157143093471e-09,    1.84375e+00,
     1.08083899319171905517578125000e+00,    7.349449255711375479217199820270e-09,    1.87500e+00,
     1.08767065405845642089843750000e+00,    7.919106542905609278549419916748e-09,    1.90625e+00,
     1.09432889521121978759765625000e+00,    1.210997013229513206461023521251e-08,    1.93750e+00,
     1.10081967711448669433593750000e+00,    1.126340195293153417684743910042e-08,    1.96875e+00,
     1.10714870691299438476562500000e+00,    1.088109611825144046017853704007e-08,    2.00000e+00,
     1.11332146823406219482421875000e+00,    1.066480928312016123954471335648e-08,    2.03125e+00,
     1.11934322118759155273437500000e+00,    1.405475076614440095064569287758e-08,    2.06250e+00,
     1.12521903216838836669921875000e+00,    7.651926474267472354793458802278e-09,    2.09375e+00,
     1.13095372915267944335937500000e+00,    1.482648100311155851553632780475e-08,    2.12500e+00,
     1.13655199110507965087890625000e+00,    1.489301596741226207440196119733e-08,    2.15625e+00,
     1.14201828837394714355468750000e+00,    1.097493308804676433616846293427e-08,    2.18750e+00,
     1.14735691249370574951171875000e+00,    8.141471637937760575662511675050e-09,    2.21875e+00,
     1.15257199108600616455078125000e+00,    6.129661353489368612612751379749e-09,    2.25000e+00,
     1.15766748785972595214843750000e+00,    6.656769276927379159572038936973e-09,    2.28125e+00,
     1.16264721751213073730468750000e+00,    5.527676601269576108270774250510e-09,    2.31250e+00,
     1.16751483082771301269531250000e+00,    1.424834750241433964256123253258e-08,    2.34375e+00,
     1.17227387428283691406250000000e+00,    6.845639472538094944133704614971e-09,    2.37500e+00,
     1.17692771553993225097656250000e+00,    5.186029634961463187726083501939e-10,    2.40625e+00,
     1.18147960305213928222656250000e+00,    1.909616480075475539707852321316e-09,    2.43750e+00,
     1.18593266606330871582031250000e+00,    1.271992558884159172963360952599e-08,    2.46875e+00,
     1.19028994441032409667968750000e+00,    5.272207636248046274829318337601e-09,    2.50000e+00,
     1.19455431401729583740234375000e+00,    2.140227396707584909847208775055e-09,    2.53125e+00,
     1.19872856140136718750000000000e+00,    6.535408980289369957115321521420e-09,    2.56250e+00,
     1.20281538367271423339843750000e+00,    6.977198096471879240373377633244e-09,    2.59375e+00,
     1.20681735873222351074218750000e+00,    1.155302901965332408005655763031e-08,    2.62500e+00,
     1.21073698997497558593750000000e+00,    7.468868748272727604040307287924e-09,    2.65625e+00,
     1.21457666158676147460937500000e+00,    9.811984937110373652926690293626e-09,    2.68750e+00,
     1.21833869814872741699218750000e+00,    5.819464992428498234448426570259e-09,    2.71875e+00,
     1.22202531993389129638671875000e+00,    3.277098340655022993922570490883e-09,    2.75000e+00,
     1.22563867270946502685546875000e+00,    4.242763244518118341144662912366e-09,    2.78125e+00,
     1.22918082773685455322265625000e+00,    8.410234901274410412884989594487e-09,    2.81250e+00,
     1.23265379667282104492187500000e+00,    1.417428114670811737511913702246e-09,    2.84375e+00,
     1.23605948686599731445312500000e+00,    2.612084627456326971109078698703e-09,    2.87500e+00,
     1.23939976096153259277343750000e+00,    8.369044500402396194457257207079e-09,    2.90625e+00,
     1.24267642199993133544921875000e+00,    9.779659899699352145777694333653e-09,    2.93750e+00,
     1.24589119851589202880859375000e+00,    1.021388557297760889923466396129e-08,    2.96875e+00,
     1.24904575943946838378906250000e+00,    1.295878604204085457728109012308e-08,    3.00000e+00,
     1.25214172899723052978515625000e+00,    8.741573416471721248374162284960e-09,    3.03125e+00,
     1.25518065690994262695312500000e+00,    7.846187711282708199415876872025e-09,    3.06250e+00,
     1.25816404819488525390625000000e+00,    1.252056463778502262154196628145e-08,    3.09375e+00,
     1.26109337806701660156250000000e+00,    4.185423817751440881247335772010e-09,    3.12500e+00,
     1.26397003233432769775390625000e+00,    5.054011716071304844264195262485e-09,    3.15625e+00,
     1.26679538190364837646484375000e+00,    5.551103661141789592586819428842e-09,    3.18750e+00,
     1.26957073807716369628906250000e+00,    1.085534696510658459004780444988e-08,    3.21875e+00,
     1.27229738235473632812500000000e+00,    1.285398101317119374982248049407e-08,    3.25000e+00,
     1.27497655153274536132812500000e+00,    6.723153879304604699213464023845e-09,    3.28125e+00,
     1.27760942280292510986328125000e+00,    7.434089310438806796214328210783e-09,    3.31250e+00,
     1.28019715845584869384765625000e+00,    6.584012759248711064053626364991e-09,    3.34375e+00,
     1.28274087607860565185546875000e+00,    3.665665095507416501136495530625e-09,    3.37500e+00,
     1.28524164855480194091796875000e+00,    7.470486111767017009769765205919e-09,    3.40625e+00,
     1.28770053386688232421875000000e+00,    7.628518782370858406087463234843e-09,    3.43750e+00,
     1.29011854529380798339843750000e+00,    5.694900512274118337353804509427e-09,    3.46875e+00,
     1.29249666631221771240234375000e+00,    1.477567555500747671407081684585e-09,    3.50000e+00,
     1.29483583569526672363281250000e+00,    9.114595638024382007616089537116e-09,    3.53125e+00,
     1.29713699221611022949218750000e+00,    1.349669599669199502665650520093e-08,    3.56250e+00,
     1.29940104484558105468750000000e+00,    1.147679758986937059227915110913e-09,    3.59375e+00,
     1.30162882804870605468750000000e+00,    5.960490089117285850366685592141e-09,    3.62500e+00,
     1.30382120609283447265625000000e+00,    5.878161128489539301878008334584e-09,    3.65625e+00,
     1.30597898364067077636718750000e+00,    1.324843697720655978211778739786e-08,    3.68750e+00,
     1.30810298025608062744140625000e+00,    1.226106884751302716449107062469e-09,    3.71875e+00,
     1.31019392609596252441406250000e+00,    8.951593109842375189171905312273e-09,    3.75000e+00,
     1.31225259602069854736328125000e+00,    8.275016105071470064554145959456e-09,    3.78125e+00,
     1.31427970528602600097656250000e+00,    8.864547056389410047056937889374e-09,    3.81250e+00,
     1.31627595424652099609375000000e+00,    1.427042673943814755137727468444e-08,    3.84375e+00,
     1.31824204325675964355468750000e+00,    7.760077406304642702327136253116e-09,    3.87500e+00,
     1.32017861306667327880859375000e+00,    1.262921005512445307883014395673e-08,    3.90625e+00,
     1.32208633422851562500000000000e+00,    3.472858124168611993312009390952e-09,    3.93750e+00,
     1.32396580278873443603515625000e+00,    1.114432779750422544163364758367e-08,    3.96875e+00,
     1.32581765949726104736328125000e+00,    4.170771417695957960428475631184e-09,    4.00000e+00,
     1.32764247059822082519531250000e+00,    8.562541371162473394290094300359e-09,    4.03125e+00,
     1.32944083213806152343750000000e+00,    4.081431296441402128141829549292e-09,    4.06250e+00,
     1.33121328055858612060546875000e+00,    1.420136831552919347675057084008e-08,    4.09375e+00,
     1.33296039700508117675781250000e+00,    2.332364690796037369733155809370e-09,    4.12500e+00,
     1.33468267321586608886718750000e+00,    6.442354753983593217476570076898e-09,    4.15625e+00,
     1.33638064563274383544921875000e+00,    5.438341998417537726877161967895e-09,    4.18750e+00,
     1.33805480599403381347656250000e+00,    9.046037814385648659622761501864e-09,    4.21875e+00,
     1.33970564603805541992187500000e+00,    1.356094411940642875258955574110e-08,    4.25000e+00,
     1.34133365750312805175781250000e+00,    2.285596037267486062179053583112e-09,    4.28125e+00,
     1.34293927252292633056640625000e+00,    5.554870562188788912498970827328e-09,    4.31250e+00,
     1.34452295303344726562500000000e+00,    1.173381403717569307500270273711e-08,    4.34375e+00,
     1.34608514606952667236328125000e+00,    1.231072725868565967825177962565e-08,    4.37500e+00,
     1.34762628376483917236328125000e+00,    2.272218287547117422631062509978e-09,    4.40625e+00,
     1.34914675354957580566406250000e+00,    1.026664321996712870251856126637e-08,    4.43750e+00,
     1.35064698755741119384765625000e+00,    9.544908659820431810059953309619e-09,    4.46875e+00,
     1.35212737321853637695312500000e+00,    7.702418280236022941389812850984e-09,    4.50000e+00,
     1.35358829796314239501953125000e+00,    2.298311106522236589881694951011e-09,    4.53125e+00,
     1.35503011941909790039062500000e+00,    1.096875641746231101174713542048e-08,    4.56250e+00,
     1.35645322501659393310546875000e+00,    1.212201701673204195192859245690e-08,    4.59375e+00,
     1.35785797238349914550781250000e+00,    4.832000329604677385964058528746e-09,    4.62500e+00,
     1.35924468934535980224609375000e+00,    9.116804692809882842286486387302e-09,    4.65625e+00,
     1.36061373353004455566406250000e+00,    6.602682522350465783445563760715e-09,    4.68750e+00,
     1.36196543276309967041015625000e+00,    3.877573446682057410929518329238e-10,    4.71875e+00,
     1.36330009996891021728515625000e+00,    3.907837370041422778250991189943e-10,    4.75000e+00,
     1.36461804807186126708984375000e+00,    8.691123502302366102158347386489e-09,    4.78125e+00,
     1.36591960489749908447265625000e+00,    4.860289062625101607000745385741e-09,    4.81250e+00,
     1.36720505356788635253906250000e+00,    5.791195446259436674713169620190e-09,    4.84375e+00,
     1.36847469210624694824218750000e+00,    6.310345929394450693694852955619e-09,    4.87500e+00,
     1.36972880363464355468750000000e+00,    9.189514516165813329271081407916e-09,    4.90625e+00,
     1.37096767127513885498046875000e+00,    1.044676754867526478916455067153e-08,    4.93750e+00,
     1.37219156324863433837890625000e+00,    1.444291066122994092077186874377e-08,    4.96875e+00,
     1.37340076267719268798828125000e+00,    4.267823172872990676444961148651e-09,    5.00000e+00,
     1.37459550797939300537109375000e+00,    1.527387122824184692078603101451e-09,    5.03125e+00,
     1.37577605247497558593750000000e+00,    6.914999640531745497463320512676e-09,    5.06250e+00,
     1.37694266438484191894531250000e+00,    3.818378486586558829857026629662e-10,    5.09375e+00,
     1.37809556722640991210937500000e+00,    9.061011323442859641291551522494e-10,    5.12500e+00,
     1.37923499941825866699218750000e+00,    7.047511712721813814391809872058e-09,    5.15625e+00,
     1.38036119937896728515625000000e+00,    1.200237518564746200539758407614e-08,    5.18750e+00,
     1.38147440552711486816406250000e+00,    3.752431303860485847154508830984e-09,    5.21875e+00,
     1.38257481157779693603515625000e+00,    9.912328922024811167768568512557e-09,    5.25000e+00,
     1.38366265594959259033203125000e+00,    8.461972007611136551662947080744e-09,    5.28125e+00,
     1.38473814725875854492187500000e+00,    2.387134272079734864149462150428e-09,    5.31250e+00,
     1.38580147922039031982421875000e+00,    4.908768598138564463776776339150e-09,    5.34375e+00,
     1.38685286045074462890625000000e+00,    9.806976825422688109704248603488e-09,    5.37500e+00,
     1.38789249956607818603515625000e+00,    6.444437697102163472927543094628e-09,    5.40625e+00,
     1.38892057538032531738281250000e+00,    9.687117337622079724907822955494e-09,    5.43750e+00,
     1.38993729650974273681640625000e+00,    4.142746755845765070359169866481e-10,    5.46875e+00,
     1.39094282686710357666015625000e+00,    1.353147719826124443836432060856e-10,    5.50000e+00,
     1.39193734526634216308593750000e+00,    1.149271815404143250733190405928e-08,    5.53125e+00,
     1.39292106032371520996093750000e+00,    3.465104850475983881869885279409e-09,    5.56250e+00,
     1.39389412105083465576171875000e+00,    8.751972846933355826997338259422e-10,    5.59375e+00,
     1.39485669136047363281250000000e+00,    9.981895149582312209204422264489e-09,    5.62500e+00,
     1.39580896496772766113281250000e+00,    3.673990225978010422888335299850e-09,    5.65625e+00,
     1.39675107598304748535156250000e+00,    1.096911042189325662689037157861e-08,    5.68750e+00,
     1.39768320322036743164062500000e+00,    1.279477068249628351462798799313e-08,    5.71875e+00,
     1.39860551059246063232421875000e+00,    1.679496962688451331611428233573e-09,    5.75000e+00,
     1.39951811730861663818359375000e+00,    1.163902146698957855756715392016e-08,    5.78125e+00,
     1.40042120218276977539062500000e+00,    1.394951087425882225980348078085e-08,    5.81250e+00,
     1.40131491422653198242187500000e+00,    6.633460392900879147180110239037e-09,    5.84375e+00,
     1.40219937264919281005859375000e+00,    1.453627420047443672943364926769e-08,    5.87500e+00,
     1.40307474136352539062500000000e+00,    1.489477349711843444848571805625e-08,    5.90625e+00,
     1.40394115447998046875000000000e+00,    1.191512705053974257955257371087e-08,    5.93750e+00,
     1.40479874610900878906250000000e+00,    7.040537971277288777775128203578e-09,    5.96875e+00,
     1.40564763545989990234375000000e+00,    1.392036987860844340199580798810e-08,    6.00000e+00,
     1.40648797154426574707031250000e+00,    1.377265262781251842762842030113e-08,    6.03125e+00,
     1.40731988847255706787109375000e+00,    1.516454832781008004109129588904e-10,    6.06250e+00,
     1.40814347565174102783203125000e+00,    8.812392852367568475736726912337e-09,    6.09375e+00,
     1.40895888209342956542968750000e+00,    1.346304412954022002507925692872e-08,    6.12500e+00,
     1.40976624190807342529296875000e+00,    3.293815482142621061407439716301e-10,    6.15625e+00,
     1.41056562960147857666015625000e+00,    1.291535597312565950651550805849e-08,    6.18750e+00,
     1.41135720908641815185546875000e+00,    3.046912056781504556598516301656e-09,    6.21875e+00,
     1.41214105486869812011718750000e+00,    9.739797095250426171858489159963e-09,    6.25000e+00,
     1.41291730105876922607421875000e+00,    1.024031168077398483141533761956e-08,    6.28125e+00,
     1.41368605196475982666015625000e+00,    9.483176298330940700362142113524e-09,    6.31250e+00,
     1.41444741189479827880859375000e+00,    1.033869222335914782699115849033e-08,    6.34375e+00,
     1.41520148515701293945312500000e+00,    1.366085396849313009758338943949e-08,    6.37500e+00,
     1.41594839096069335937500000000e+00,    3.432973375068371408689440807613e-09,    6.40625e+00,
     1.41668820381164550781250000000e+00,    6.417824622786507475303697774616e-09,    6.43750e+00,
     1.41742104291915893554687500000e+00,    2.794932855413679169126588151130e-09,    6.46875e+00,
     1.41814699769020080566406250000e+00,    7.094306537397978039700989523716e-10,    6.50000e+00,
     1.41886615753173828125000000000e+00,    6.511618638791985801618497405100e-09,    6.53125e+00,
     1.41957862675189971923828125000e+00,    9.896556194686557004717711949810e-09,    6.56250e+00,
     1.42028449475765228271484375000e+00,    1.374603985595606071085278554348e-08,    6.59375e+00,
     1.42098386585712432861328125000e+00,    4.364874928050023392461446666118e-09,    6.62500e+00,
     1.42167679965496063232421875000e+00,    1.112308502143230238342818370506e-08,    6.65625e+00,
     1.42236341536045074462890625000e+00,    2.184350807916878859325266118764e-09,    6.68750e+00,
     1.42304377257823944091796875000e+00,    3.750899549292036644030269089181e-09,    6.71875e+00,
     1.42371796071529388427734375000e+00,    1.069120023462447529661072975031e-08,    6.75000e+00,
     1.42438608407974243164062500000e+00,    1.474877843219146090565202646625e-09,    6.78125e+00,
     1.42504818737506866455078125000e+00,    1.271139062462222761511135154115e-08,    6.81250e+00,
     1.42570438981056213378906250000e+00,    5.071595443040728669327516512176e-09,    6.84375e+00,
     1.42635473608970642089843750000e+00,    1.233054621889336855972812656957e-08,    6.87500e+00,
     1.42699933052062988281250000000e+00,    7.287424870077642925112396819355e-09,    6.90625e+00,
     1.42763823270797729492187500000e+00,    6.103270472013076602528007488299e-09,    6.93750e+00,
     1.42827151715755462646484375000e+00,    8.725177533766308578803575218566e-09,    6.96875e+00,
     1.42889925837516784667968750000e+00,    1.381556484973878257453719835909e-08,    7.00000e+00,
     1.42952154576778411865234375000e+00,    3.878408183331421157737222813987e-09,    7.03125e+00,
     1.43013842403888702392578125000e+00,    4.890586035833613242167706359834e-09,    7.06250e+00,
     1.43074996769428253173828125000e+00,    1.182210199236867169011076347577e-08,    7.09375e+00,
     1.43135626614093780517578125000e+00,    3.562621093048238216840177931212e-09,    7.12500e+00,
     1.43195736408233642578125000000e+00,    2.550855547300852132957145207900e-09,    7.15625e+00,
     1.43255333602428436279296875000e+00,    2.928837471379335503148003066060e-10,    7.18750e+00,
     1.43314424157142639160156250000e+00,    2.089160561552372671877910995624e-09,    7.21875e+00,
     1.43373014032840728759765625000e+00,    1.215630169904281565966988736486e-08,    7.25000e+00,
     1.43431112170219421386718750000e+00,    3.847142280027166839044400023082e-09,    7.28125e+00,
     1.43488721549510955810546875000e+00,    9.079536390908432116337422093224e-09,    7.31250e+00,
     1.43545849621295928955078125000e+00,    1.404952806211560556946013416408e-08,    7.34375e+00,
     1.43602503836154937744140625000e+00,    3.955616146055021283715500878067e-09,    7.37500e+00,
     1.43658687174320220947265625000e+00,    7.722515695860274460544521388517e-09,    7.40625e+00,
     1.43714407086372375488281250000e+00,    8.613979178524680791921236062657e-09,    7.43750e+00,
     1.43769669532775878906250000000e+00,    3.856753838848147089954125263076e-09,    7.46875e+00,
     1.43824478983879089355468750000e+00,    4.659431704406716747935481585539e-09,    7.50000e+00,
     1.43878841400146484375000000000e+00,    6.428527409096803478729704302162e-09,    7.53125e+00,
     1.43932762742042541503906250000e+00,    3.687602194584522205654788432971e-09,    7.56250e+00,
     1.43986247479915618896484375000e+00,    4.995962512345000737858412162894e-09,    7.59375e+00,
     1.44039301574230194091796875000e+00,    3.163461276481761353139212686569e-09,    7.62500e+00,
     1.44091929495334625244140625000e+00,    5.069541396358720258230994326320e-09,    7.65625e+00,
     1.44144137203693389892578125000e+00,    1.877242963101349535406770464928e-09,    7.68750e+00,
     1.44195927679538726806640625000e+00,    1.375263542407784571763662797591e-08,    7.71875e+00,
     1.44247309863567352294921875000e+00,    4.734282970760733099377292525125e-10,    7.75000e+00,
     1.44298283755779266357421875000e+00,    1.045580022307847213187143258234e-08,    7.78125e+00,
     1.44348858296871185302734375000e+00,    1.955330641876895861323269134488e-09,    7.81250e+00,
     1.44399034976959228515625000000e+00,    6.994297172085502553694421170635e-09,    7.84375e+00,
     1.44448819756507873535156250000e+00,    1.216657763016328285985080370259e-08,    7.87500e+00,
     1.44498218595981597900390625000e+00,    3.355001307363149651861224256277e-09,    7.90625e+00,
     1.44547232985496520996093750000e+00,    1.044838491216955419489400858952e-08,    7.93750e+00,
     1.44595870375633239746093750000e+00,    3.046649524822425965668741214886e-09,    7.96875e+00,
     1.44644132256507873535156250000e+00,    9.683056448848404342475880416525e-09,    8.00000e+00,
     1.5707963267948965579989817342720925807952880859375,       /* hi part of Pi/2 */
     0.6123233995736765886130329661375005291048747229615e-16,   /* lo part of Pi/2 */
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\i386\disp_pentium4.inc ===
.XMM

	CODESEG

	ALIGN	4
	
ifdef _NTSUBSET_	
	ifdef	_FUNC_DEF_EXTERN_
	extrn	_FUNC_DEF_:proc
	endif
	
	PUBLIC	_FUNC_

_FUNC_	PROC NEAR
	jmp	_FUNC_DEF_	; jmp to old code

_FUNC_	ENDP
else


	extrn	__use_sse2_mathfcns:dword

	ifdef	_FUNC_DEF_EXTERN_
	extrn	_FUNC_DEF_:proc
	endif

	ifdef	_FUNC_P4_EXTERN_
	extrn	_FUNC_P4_:proc
	endif

	PUBLIC	_FUNC_

_FUNC_	PROC NEAR

 	cmp	DWORD PTR __use_sse2_mathfcns, 0
 	je	_FUNC_DEF_	; not P4 go to MS code

	sub	esp, 8
	stmxcsr	dword ptr [esp+4]
	mov	eax, dword ptr [esp+4]
	and	eax, 01f80h	;mscxr mask
	cmp	eax, 01f80h
	jne	short jnedef	;if unmasked, we vector off to the MS code 

	;check if any x87 FP exceptions are unmasked
	fnstcw	word ptr [esp]
	mov	ax, word ptr [esp]
	and	ax, 07fh
	cmp	ax, 07fh
jnedef:	lea	esp, [esp+8]	;(release stack, preserve CC)
	jne	_FUNC_DEF_	;if unmasked, we vector off to the MS code 

	jmp	_FUNC_P4_	; ok to go to Intel code

_FUNC_	ENDP
endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\i386\exp_pentium4.asm ===
;//
;//               INTEL CORPORATION PROPRIETARY INFORMATION
;//  This software is supplied under the terms of a license agreement or
;//  nondisclosure agreement with Intel Corporation and may not be copied
;//  or disclosed except in accordance with the terms of that agreement.
;//  Copyright (c) 2000 Intel Corporation. All Rights Reserved.
;//
;//
;  exp_wmt.asm
;
;  double exp(double);
;
;  Initial version: 11/30/2000
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; This is a new version using just one table. Reduction by log2/64    ;;
;; A non-standard table is used. Normally, we store T,t where          ;;
;; T+t  =  exp(jlog2/64) to high precision. This implementation        ;;
;; stores  T,d where d = t/T. This shortens the latency by 1 FP op     ;;
;; This version uses two tricks from Andrey. First, we merge two       ;;
;; integer-based tests for exception filtering into 1. Second, instead ;;
;; of using sign(X)2^52 as a shifter, we use S = 2^52 * 1.10000..000   ;;
;; as the shifter. This will give bit pattern of the 2's complement of ;;
;; N in trailing bits of S + W, W = X * 64/log2.                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

.686P
.387
.XMM
.MODEL FLAT,C

EXTRN C __libm_error_support : NEAR  

CONST SEGMENT PARA PUBLIC USE32 'CONST'
ALIGN 16

smask   DQ 8000000000000000H, 8000000000000000H ; mask to get sign bit
emask   DQ 0FFF0000000000000H, 0FFF0000000000000H
mmask   DQ 00000000FFFFFFC0H, 00000000FFFFFFC0H ; mask off bottom 6 bits
bias    DQ 000000000000FFC0H, 000000000000FFC0H	; 1023 shifter left 6 bits
Shifter DQ 4338000000000000H, 4338000000000000H	; 2^52+2^51|2^52+2^51
twom60  DQ 3C30000000000000H, 3C30000000000000H ; 2^(-60)


cv      DQ 40571547652b82feH, 40571547652b82feH		; invL|invL
        DQ 3F862E42FEFA0000H, 3F862E42FEFA0000H         ; log2_hi|log2_hi
        DQ 3D1CF79ABC9E3B3AH, 3D1CF79ABC9E3B3AH         ; log2_lo|log2_lo

	DQ 3F811074B1D108E5H, 3FC555555566A45AH		; p2|p4
	DQ 3FA5555726ECED80H, 3FDFFFFFFFFFE17BH		; p1|p3

;-------Table d, T  so that movapd gives [ T | d ]
;-------Note that the exponent field of T is set to 000
Tbl_addr  DQ 0000000000000000H, 0000000000000000H
          DQ 3CAD7BBF0E03754DH, 00002C9A3E778060H
          DQ 3C8CD2523567F613H, 000059B0D3158574H
          DQ 3C60F74E61E6C861H, 0000874518759BC8H
          DQ 3C979AA65D837B6CH, 0000B5586CF9890FH
          DQ 3C3EBE3D702F9CD1H, 0000E3EC32D3D1A2H
          DQ 3CA3516E1E63BCD8H, 00011301D0125B50H
          DQ 3CA4C55426F0387BH, 0001429AAEA92DDFH
          DQ 3CA9515362523FB6H, 000172B83C7D517AH
          DQ 3C8B898C3F1353BFH, 0001A35BEB6FCB75H
          DQ 3C9AECF73E3A2F5FH, 0001D4873168B9AAH
          DQ 3C8A6F4144A6C38DH, 0002063B88628CD6H
          DQ 3C968EFDE3A8A894H, 0002387A6E756238H
          DQ 3C80472B981FE7F2H, 00026B4565E27CDDH
          DQ 3C82F7E16D09AB31H, 00029E9DF51FDEE1H
          DQ 3C8B3782720C0AB3H, 0002D285A6E4030BH
          DQ 3C834D754DB0ABB6H, 000306FE0A31B715H
          DQ 3C8FDD395DD3F84AH, 00033C08B26416FFH
          DQ 3CA12F8CCC187D29H, 000371A7373AA9CAH
          DQ 3CA7D229738B5E8BH, 0003A7DB34E59FF6H
          DQ 3C859F48A72A4C6DH, 0003DEA64C123422H
          DQ 3CA8B846259D9205H, 0004160A21F72E29H
          DQ 3C4363ED60C2AC12H, 00044E086061892DH
          DQ 3C6ECCE1DAA10379H, 000486A2B5C13CD0H
          DQ 3C7690CEBB7AAFB0H, 0004BFDAD5362A27H
          DQ 3CA083CC9B282A09H, 0004F9B2769D2CA6H
          DQ 3CA509B0C1AAE707H, 0005342B569D4F81H
          DQ 3C93350518FDD78EH, 00056F4736B527DAH
          DQ 3C9063E1E21C5409H, 0005AB07DD485429H
          DQ 3C9432E62B64C035H, 0005E76F15AD2148H
          DQ 3CA0128499F08C0AH, 0006247EB03A5584H
          DQ 3C99F0870073DC06H, 0006623882552224H
          DQ 3C998D4D0DA05571H, 0006A09E667F3BCCH
          DQ 3CA52BB986CE4786H, 0006DFB23C651A2EH
          DQ 3CA32092206F0DABH, 00071F75E8EC5F73H
          DQ 3CA061228E17A7A6H, 00075FEB564267C8H
          DQ 3CA244AC461E9F86H, 0007A11473EB0186H
          DQ 3C65EBE1ABD66C55H, 0007E2F336CF4E62H
          DQ 3C96FE9FBBFF67D0H, 00082589994CCE12H
          DQ 3C951F1414C801DFH, 000868D99B4492ECH
          DQ 3C8DB72FC1F0EAB4H, 0008ACE5422AA0DBH
          DQ 3C7BF68359F35F44H, 0008F1AE99157736H
          DQ 3CA360BA9C06283CH, 00093737B0CDC5E4H
          DQ 3C95E8D120F962AAH, 00097D829FDE4E4FH
          DQ 3C71AFFC2B91CE27H, 0009C49182A3F090H
          DQ 3C9B6D34589A2EBDH, 000A0C667B5DE564H
          DQ 3C95277C9AB89880H, 000A5503B23E255CH
          DQ 3C8469846E735AB3H, 000A9E6B5579FDBFH
          DQ 3C8C1A7792CB3387H, 000AE89F995AD3ADH
          DQ 3CA22466DC2D1D96H, 000B33A2B84F15FAH
          DQ 3CA1112EB19505AEH, 000B7F76F2FB5E46H
          DQ 3C74FFD70A5FDDCDH, 000BCC1E904BC1D2H
          DQ 3C736EAE30AF0CB3H, 000C199BDD85529CH
          DQ 3C84E08FD10959ACH, 000C67F12E57D14BH
          DQ 3C676B2C6C921968H, 000CB720DCEF9069H
          DQ 3C93700936DF99B3H, 000D072D4A07897BH
          DQ 3C74A385A63D07A7H, 000D5818DCFBA487H
          DQ 3C8E5A50D5C192ACH, 000DA9E603DB3285H
          DQ 3C98BB731C4A9792H, 000DFC97337B9B5EH
          DQ 3C74B604603A88D3H, 000E502EE78B3FF6H
          DQ 3C916F2792094926H, 000EA4AFA2A490D9H
          DQ 3C8EC3BC41AA2008H, 000EFA1BEE615A27H
          DQ 3C8A64A931D185EEH, 000F50765B6E4540H
          DQ 3C77893B4D91CD9DH, 000FA7C1819E90D8H


ONE_val  DQ 3ff0000000000000H ; 1.0

EMIN     DQ 0010000000000000H

MAX_ARG  DQ 40862e42fefa39efH

MIN_ARG  DQ 0c086232bdd70000H

INF      DQ 7ff0000000000000H

ZERO     DQ 0

XMAX	 DQ 7fefffffffffffffH

XMIN	 DQ 0010000000000000H

Sm_Thres    DQ 3C3000003C300000H  ; DP 2^(-60)
Del_Thres   DQ 045764CA045764CAH  ; DP 1080*log(2) - 2^(-60), hi part

ALIGN 16
CONST ENDS

_TEXT SEGMENT PARA PUBLIC USE32 'CODE'
ALIGN 16

PUBLIC _exp_pentium4, _CIexp_pentium4 
_CIexp_pentium4 PROC NEAR
	push	    ebp
	mov         ebp, esp
	sub         esp, 8                          ; for argument DBLSIZE
	and         esp, 0fffffff0h
	fstp        qword ptr [esp]
	movq        xmm0, qword ptr [esp]
	call        start
	leave
	ret
_exp_pentium4 label proc
	; load *|x in XMM0
    	movlpd xmm0, 4[esp]  
start:
	unpcklpd xmm0,xmm0

        ; load Inv_L pair
        movapd xmm1, QWORD PTR [cv]
        ; load Shifter
        movapd xmm6, QWORD PTR [Shifter]
        ; load L_hi pair
        movapd xmm2, QWORD PTR [cv+16]
        ; load L_lo pair
        movapd xmm3, QWORD PTR [cv+32]

	pextrw eax, xmm0,3
        and eax,7FFFH 
	; x>=2^{10} ? (i.e. 2^{10}-eps-x<0)
	mov edx, 408fH
	sub edx, eax
	; avoid underflow on intermediate calculations (|x|<2^{-54} ?)
	sub eax, 3c90H
	or edx, eax
	cmp edx, 80000000H
	; small input or UF/OF
	jae RETURN_ONE

	; xmm1=Inv_L*x|Inv_L*x
	mulpd  xmm1,xmm0
	; xmm1=Inv_L*x+Shifter| Inv_L*x+Shifter
	addpd  xmm1,xmm6
        ; xmm7 contains bit pattern of N
        movapd xmm7,xmm1
	; xmm1=N
	subpd xmm1,xmm6

	; xmm2=L_hi*round_to_int(Inv_L*x)|L_hi*round_to_int(Inv_L*x) ; N_L_hi
	mulpd xmm2,xmm1

        ; [p2|p4]
        MOVAPD xmm4,[cv+48]

	; xmm3=L_lo*round_to_int(Inv_L*x)|L_lo*round_to_int(Inv_L*x) ; N_L_lo
	mulpd xmm3,xmm1

        ; [p1|p3]
        MOVAPD xmm5,[cv+64]

	; xmm0=x-xmm2	   ; R := X |-| N_L_hi
	subpd xmm0,xmm2

        ; set eax <-- n, ecx <--j
        movd   eax,xmm7
        mov    ecx,eax
        and    ecx,0000003FH
      
        ; get offset for [T,d]
        shl ecx,4
        ; eax,edx <-- m
        sar eax,6
        mov edx,eax

	; xmm0-=xmm3       ; R := R |-| N_L_lo
	subpd xmm0,xmm3
        
        ; xmm2 <- [T,d]
        movapd xmm2,[ecx+Tbl_addr]
        
	; xmm4=p2*R|p4*R
	mulpd xmm4,xmm0

        MOVAPD xmm1,xmm0
        MULPD  xmm0,xmm0

	; xmm5=p1+p2*R|p3+p4*R
	addpd xmm5,xmm4
        MULSD xmm0,xmm0       
        
        ; get xmm1 <-- [R|R+d]
        addsd    xmm1,xmm2

        ; xmm2 <-- [T|T]
        unpckhpd xmm2,xmm2
        ; xmm7 <-- exponent of 2^m
        movdqa   xmm6,[mmask]
        pand     xmm7,xmm6
        movdqa   xmm6,[bias]
        paddq    xmm7,xmm6
        psllq    xmm7,46

	; xmm5=[P_hi | P_lo]
	mulpd xmm0,xmm5
        ; xmm1 <- [R |d+R+P_lo]
	addsd xmm1,xmm0
       
        ; xmm2 is 2^m T
        ORPD     xmm2,xmm7

        ; xmm5 <- [P_hi | P_hi]
        unpckhpd xmm0,xmm0

        ; xmm5 <-- [P_hi | d+R+P ]
        addsd    xmm0,xmm1

        ; make sure -894 <= m <= 1022 
        ; before we use the exponent in xmm7
        ; test by unsigned comp of  m+894 with 1022+894
        add edx,894
        cmp edx,1916

        ja  ADJUST

        mulsd    xmm0,xmm2
        sub esp, 16
        addsd    xmm0,xmm2

        movlpd    QWORD PTR [esp+4], xmm0       ; return result
        fld       QWORD PTR [esp+4]             ;
        add esp, 16
	ret

ADJUST:
;---xmm5 contains [*| d+R+P]
;---xmm2 contains [*| T ] where is exponent field is not correct
;---eax still contain the correct m
;---so we split m into m1 and m2, m1+m2 = m. Make T with exponent 2^m1 by
;---integer manipulation, and multiply final result by 2^m2

	; overflow or underflow
	sub esp,18

	fstcw WORD PTR [esp+16]
	mov dx,WORD PTR [esp+16]
	; set pc=64 bits
	or dx,300H 
	mov WORD PTR [esp],dx
	fldcw WORD PTR [esp]

        ; eax <-- m1 = m/2, edx <-- m2 = m - m1
        mov edx,eax
        sar eax,1
        sub edx,eax

        ; T with exponent field zerorized
        movdqa xmm6,[emask]
        pandn  xmm6,xmm2
        add    eax,1023
        movd   xmm3,eax
        psllq  xmm3,52
	; xmm6=T*2^m1
        ORPD   xmm6,xmm3

        add    edx,1023
        movd   xmm4,edx
        psllq  xmm4,52

	; load P on FP stack
	movlpd QWORD PTR [esp], xmm0
	fld QWORD PTR [esp]

	; load T'=T*2^m1 on FP stack
	movlpd QWORD PTR [esp+8], xmm6
	fld QWORD PTR [esp+8]

	; T'*P
	fmul st(1), st(0)
	; T'+T'*P
	faddp st(1), st(0)

	; load 2^m2 on FP stack
	movlpd QWORD PTR [esp], xmm4
	fld QWORD PTR [esp]

        ; final calculation: 2^m2*(T'+T'*P)
	fmulp st(1), st(0)

	; store result in memory, then xmm0
	fstp QWORD PTR [esp]
	movlpd xmm0, QWORD PTR [esp] 

	; restore FPCW
	fldcw WORD PTR [esp+16]
	add esp,18

;	mov ecx, DWORD PTR [esp+8]
;	; if 0<x<2^{10}*ln2, return
;	cmp ecx, 40862e42H
;	jb RETURN
;	ja CONT0
	pextrw ecx, xmm0, 3
	and ecx, 7ff0H
	cmp ecx, 7ff0H
	jae OVERFLOW
	cmp ecx, 0
	jz UNDERFLOW
	jmp RETURN

	; load lower 32 bits of x
;	mov edx, DWORD PTR [esp+4]
;	cmp edx, 0fefa39efH
;	jb RETURN
;	jmp OVERFLOW

CONT0:
	; OF/UF
	; OF ?
	cmp ecx,80000000H
	jb OVERFLOW

	; x<(2-2^{10})*ln2 ?
	cmp ecx, 0c086232bH
	jb RETURN
	ja UNDERFLOW
	mov edx, DWORD PTR [esp+4]
	cmp edx, 0fefa39efH
	jb RETURN
	jmp UNDERFLOW		

OVERFLOW:
	;OF
	mov edx,14
	jmp CALL_LIBM_ERROR

UNDERFLOW:
	mov edx, 15

CALL_LIBM_ERROR:
	;call libm_error_support(void *arg1,void *arg2,void *retval,error_types input_tag)
	sub esp, 28
	movlpd QWORD PTR [esp+16], xmm0
	mov DWORD PTR [esp+12],edx
	mov edx, esp
	add edx,16
	mov DWORD PTR [esp+8],edx
	add edx,16
	mov DWORD PTR [esp+4],edx
	mov DWORD PTR [esp],edx
	call NEAR PTR __libm_error_support
	movlpd xmm0, QWORD PTR [esp+16]
    	add esp, 28

RETURN:
        sub esp, 16
        movlpd    QWORD PTR [esp+4], xmm0       ; return result
        fld       QWORD PTR [esp+4]             ;
        add esp, 16
	ret


SPECIAL_CASES: 
;  code to be added, but OK for now
;  Need to resolve several cases
;
;  Case 1: Argument is close to zero ( |X| < 2^(-60) )
;  Compute 1 + X and return the result
;  This will allow the appropriate action to take place.
;  For example, in directed rounding, the correct number below/above 1 is returned.
;  If X is denormalized, and that DAE is set, then we will be consistant with DAE,
;  that is X is treated as zero and directed rounding will not affect the result.
;  This action also takes care of the case X = 0.
;
;  Case 2: |X| is large but finite
;  Generate overflow/underflow by a simple arithmetic operation. This is also a place
;  holder for various exception handling protocol.
;
;  Case 3: X is +-inf. Return +inf or +0 exactly without exception
;
;  Case 4: X is s/q NaN
;


OF_UF:
	; x=infinity/NaN ?
	cmp eax, 7ff00000H
	jae INF_NAN

        mov eax,[esp+8]
	cmp eax,80000000H
	jae UF

	movlpd xmm0, QWORD PTR [XMAX]
	mulsd xmm0, xmm0
	mov edx,14
	jmp CALL_LIBM_ERROR

UF:	movlpd xmm0, QWORD PTR [XMIN]
	mulsd xmm0, xmm0
	mov edx,15
	jmp CALL_LIBM_ERROR

INF_NAN:
	; load lower 32 bits of x
	mov edx, DWORD PTR [esp+4]
	cmp eax, 7ff00000H
	ja NaN_arg
	cmp edx,0
	jnz NaN_arg

	mov eax,DWORD PTR [esp+8]
	cmp eax,7ff00000H
	jne INF_NEG

	; +INF
	fld QWORD PTR [INF]
	ret

INF_NEG:
	; -INF
	fld QWORD PTR [ZERO]
	ret

NaN_arg:   
        ; movlpd xmm0, 4[esp]
        ; addsd xmm0,xmm0
	; sub esp, 16
	; movlpd 4[esp],xmm0
	   
    	; fld  QWORD PTR [esp+4]            ; return x
	; add esp, 16
    	; ret
	mov edx,1002
	jmp CALL_LIBM_ERROR
 
RETURN_ONE:
        ; load hi-part of x
        mov eax,[esp+8]
        and eax,7FFFFFFFH
	; large absolute value (>=2^{10}) ?
        cmp eax, 40900000H
	jae OF_UF

	; small inputs, return 1
	movlpd xmm0, 4[esp]
	; set D flag
	addsd xmm0, QWORD PTR [ONE_val]
	sub esp, 16
	movlpd 4[esp],xmm0
	   
    	fld  QWORD PTR [esp+4]            ; return x
	add esp, 16
	ret

_CIexp_pentium4 ENDP

ALIGN 16
_TEXT ENDS

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\i386\filter_simd.c ===
/***
* filter_simd.c - IEEE exception filter routine
*
*       Copyright (c) 1992-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Handles XMMI SIMD numeric exceptions
*
*Revision History:
*       03-01-98  PLS   written.  
*       01-11-99  PLS   added XMMI2 support.
*       01-12-99  PLS   included XMMI2 conversion support.
*       11-30-99  PML   Compile /Wp64 clean.
*       07-31-00  PLS   Placeholder for DAZ bit set
*       11-02-00  PLS   DAZ is supported by XMMI Emulation Code, 
*                       remove DAZ placeholder
*
*******************************************************************************/

#include <trans.h>
#include <windows.h>
#include <dbgint.h>
#include <fpieee.h>
#include "filter.h"
#include "xmmi_types.h"
#include "temp_context.h"
#ifdef _XMMI_DEBUG
#include "debug.h"
#endif

#pragma warning(disable:4311 4312)      // x86 specific, ignore /Wp64 warnings

#define InitExcptFlags(flags)       { \
        (flags).Inexact = 0; \
        (flags).Underflow = 0; \
        (flags).Overflow = 0; \
        (flags).ZeroDivide = 0; \
        (flags).InvalidOperation = 0; \
} 

__inline
void
FxSave(
    PFLOATING_EXTENDED_SAVE_AREA NpxFrame
    )
{
    _asm {
        mov eax, NpxFrame
        ;fxsave [eax]
        _emit  0fh
        _emit  0aeh
        _emit  0h
    }
}

__inline
void
FxRstor(
    PFLOATING_EXTENDED_SAVE_AREA NpxFrame
    )
{
    _asm {
        mov eax, NpxFrame
        ;fxrstor [eax]
        _emit  0fh
        _emit  0aeh
        _emit  8h
    }
}

extern 
ULONG 
XMMI_FP_Emulation(
    PXMMI_ENV XmmiEnv);

extern 
ULONG 
XMMI2_FP_Emulation(
    PXMMI_ENV XmmiEnv);

void
LoadOperand(
    BOOLEAN fScalar,
    ULONG OpLocation,
    ULONG OpReg,
    POPERAND pOperand,
    PTEMP_CONTEXT pctxt);

ULONG
LoadImm8(
    PXMMIINSTR Instr);

void
AdjustExceptionResult(
    ULONG OriginalOperation,
    PXMMI_ENV XmmiEnv);

void 
UpdateResult(
    POPERAND pOperand,
    PTEMP_CONTEXT pctxt,
    ULONG EFlags);

BOOLEAN
ValidateResult(
    PXMMI_FP_ENV XmmiFpEnv);

static ULONG  ax0  ( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip );
static ULONG  ax8  ( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip );
static ULONG  ax32 ( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip );
static ULONG  cx0  ( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip );
static ULONG  cx8  ( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip );
static ULONG  cx32 ( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip );
static ULONG  dx0  ( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip );
static ULONG  dx8  ( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip );
static ULONG  dx32 ( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip );
static ULONG  bx0  ( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip );
static ULONG  bx8  ( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip );
static ULONG  bx32 ( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip );
static ULONG  sib0 ( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip );
static ULONG  sib8 ( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip );
static ULONG  sib32( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip );
static ULONG  d32  ( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip );
static ULONG  bp8  ( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip );
static ULONG  bp32 ( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip );
static ULONG  si0  ( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip );
static ULONG  si8  ( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip );
static ULONG  si32 ( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip );
static ULONG  di0  ( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip );
static ULONG  di8  ( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip );
static ULONG  di32 ( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip );
static ULONG  reg  ( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip );

//
//The following 4 tables are used to parse the instructions - 0F/F3 0F/66 0F/F2 0F Opcodes.
//(XMMI/XMMI2 Opcodes are sparse.  Instead of having 1 big table, 4 tables are created,
// grouped by opcodes).
//Note: For the Scalar form of the instruction, it is always looked up in the table as 
//      XXXXPS for XMMI, XXXXPD for XMMI2. fScalar indicates if the instruction is a 
//      scalar or not. instrIndex indicates if the instruction is a XMMI or XMMI2.  
//      Scalar operation code == non-Scalar operation code + 1 (1st col in the table), 
//      Scalar operand location: scalar form of the non-Scalar operand.
//Note: The NumArgs is a 2 bit fields in the table, the actual value is NumArgs+1.
//
//
//InstInfoTableX is added to assist the parsing of the XMMI2 conversion instructions.
//Scalar rule does not apply to some of the XMMI2 conversion instructions.  Additional
//information is needed to parse the instruction.  In such case, one of the 4 tables
//(based on the Opcode) is looked up, if Op1Location has a value of LOOKUP, then,
//Op2Location is used as index to InstInfoTableX.  The entry in InstInfoTableX describes
//the real parsing rule for the instruction.  
//
//This table is indexed by 
//   (ULONG Op2Location:5) // Location of 2nd operand
//if (ULONG Op1Location:5) // Location of 1st operand has a value of LOOKUP
//from XMMI_INSTR_INFO. 
//
//Note: the size is 5, therefore, the max entries in this table can only be 32.
//

//
// Opcode 5x table
//
static XMMI_INSTR_INFO InstInfoTable5X[64] = {
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_SQRTPS,    INV,  XMMI,       0,     XMMI, 3},               // OP_SQRTSS    F3 51 (XMMI)
 {OP_SQRTPD,    INV,  XMMI2,      0,     XMMI2,1},               // OP_SQRTSD    F2 51 (XMMI2)
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_ADDPS,     XMMI, XMMI,       0,     XMMI, 3},               // OP_ADDSS     F3 58 (XMMI)
 {OP_ADDPD,     XMMI2,XMMI2,      0,     XMMI2,1},               // OP_ADDSD     F2 58 (XMMI2)
 {OP_MULPS,     XMMI, XMMI,       0,     XMMI, 3},               // OP_MULSS     F3 59 (XMMI)
 {OP_MULPD,     XMMI2,XMMI2,      0,     XMMI2,1},               // OP_MULSD     F2 59 (XMMI2)
 {OP_CVTPS2PD,  LOOKUP,0,         0,     0,    0},               // OP_CVTSS2SD  F3 5A (XMMI2)
 {OP_CVTPD2PS,  INV,  XMMI2,      0,     XMMI, 1},               // OP_CVTSD2SS  F2 5A (XMMI2)
 {OP_CVTDQ2PS,  LOOKUP,4,         0,     0,    0},               // OP_CVTTPS2DQ F3 5B (XMMI2)
 {OP_CVTPS2DQ,  LOOKUP,6,         0,     0,    0},               // NONE               (XMMI2)
 {OP_SUBPS,     XMMI, XMMI,       0,     XMMI, 3},               // OP_SUBSS     F3 5C (XMMI)
 {OP_SUBPD,     XMMI2,XMMI2,      0,     XMMI2,1},               // OP_SUBSD     F2 5C (XMMI2)
 {OP_MINPS,     XMMI, XMMI,       0,     XMMI, 3},               // OP_MINSS     F3 5D (XMMI)
 {OP_MINPD,     XMMI2,XMMI2,      0,     XMMI2,1},               // OP_MINSD     F2 5D (XMMI2)
 {OP_DIVPS,     XMMI, XMMI,       0,     XMMI, 3},               // OP_DIVSS     F3 5E (XMMI)
 {OP_DIVPD,     XMMI2,XMMI2,      0,     XMMI2,1},               // OP_DIVSD     F2 5E (XMMI2)
 {OP_MAXPS,     XMMI, XMMI,       0,     XMMI, 3},               // OP_MAXSS     F3 5F (XMMI)
 {OP_MAXPD,     XMMI2,XMMI2,      0,     XMMI2,1},               // OP_MAXSD     F2 5F (XMMI2)

 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_SQRTPS,    INV,  M128_M32R,  0,     XMMI, 3},               // OP_SQRTSS    M32R    F3 51 (XMMI)
 {OP_SQRTPD,    INV,  M128_M64R,  0,     XMMI2,1},               // OP_SQRTSD    M64R_64 F2 51 (XMMI2)
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_ADDPS,     XMMI, M128_M32R,  0,     XMMI, 3},               // OP_ADDSS     M32R    F3 58 (XMMI)
 {OP_ADDPD,     XMMI2,M128_M64R,  0,     XMMI2,1},               // OP_ADDSD     M64R_64 F2 58 (XMMI2)
 {OP_MULPS,     XMMI, M128_M32R,  0,     XMMI, 3},               // OP_MULSS     M32R    F3 59 (XMMI)
 {OP_MULPD,     XMMI2,M128_M64R,  0,     XMMI2,1},               // OP_MULSD     M64R_64 F2 59 (XMMI2)
 {OP_CVTPS2PD,  LOOKUP,2,         0,     0,    0},               // OP_CVTSS2SD  M32R    F3 5A (XMMI2)
 {OP_CVTPD2PS,  INV,  M128_M64R,  0,     XMMI, 1},               // OP_CVTSD2SS  M64R_64 F2 5A (XMMI2)
 {OP_CVTDQ2PS,  LOOKUP,8,         0,     0,    0},               // OP_CVTTPS2DQ         F3 5B (XMMI2)
 {OP_CVTPS2DQ,  LOOKUP,10,        0,     0,    0},               // NONE                       (XMMI2)
 {OP_SUBPS,     XMMI, M128_M32R,  0,     XMMI, 3},               // OP_SUBSS     M32R    F3 5C (XMMI)
 {OP_SUBPD,     XMMI2,M128_M64R,  0,     XMMI2,1},               // OP_SUBSD     M64R_64 F2 5C (XMMI2)
 {OP_MINPS,     XMMI, M128_M32R,  0,     XMMI, 3},               // OP_MINSS     M32R    F3 5D (XMMI)
 {OP_MINPD,     XMMI2,M128_M64R,  0,     XMMI2,1},               // OP_MINSD     M64R_64 F2 5D (XMMI2)
 {OP_DIVPS,     XMMI, M128_M32R,  0,     XMMI, 3},               // OP_DIVSS     M32R    F3 5E (XMMI)
 {OP_DIVPD,     XMMI2,M128_M64R,  0,     XMMI2,1},               // OP_DIVSD     M64R_64 F2 5E (XMMI2)
 {OP_MAXPS,     XMMI, M128_M32R,  0,     XMMI, 3},               // OP_MAXSS     M32R    F3 5F (XMMI)
 {OP_MAXPD,     XMMI2,M128_M64R,  0,     XMMI2,1},               // OP_MAXSD     M64R_64 F2 5F (XMMI2)
                                                                 // M128_M32R -> M32R
                                                                 // M128_M64R -> M64R_64
};

//
// Opcode Cx table
//
static XMMI_INSTR_INFO InstInfoTableCX[64] = {
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_CMPPS,     XMMI, XMMI,       HAS_IMM8, XMMI, 3},            // OP_CMPSS  F3 C2 (XMMI)
 {OP_CMPPD,     XMMI2,XMMI2,      HAS_IMM8, XMMI2,1},            // OP_CMPSD  F2 C2 (XMMI2)
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved

 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_CMPPS,     XMMI, M128_M32R,  HAS_IMM8,  XMMI, 3},           // OP_CMPSS  M32R    F3 C2 (XMMI)
 {OP_CMPPD,     XMMI2,M128_M64R,  HAS_IMM8,  XMMI2,1},           // OP_CMPSD  M64R_64 F2 C2 (XMMI2)
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
                                                                 // M128_M32R -> M32R
                                                                 // M128_M64R -> M64R_64
};

//
// Opcode 2x table
//
static XMMI_INSTR_INFO InstInfoTable2X[64] = {
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_CVTPI2PS,  INV,  MMX,        0,     XMMI, 1},               // OP_CVTSI2SS  REG F3 2A (XMMI)
 {OP_UNSPEC,    0,    0,          0,     0,    0},     
 {OP_UNSPEC,    0,    0,          0,     0,    0},     
 {OP_UNSPEC,    0,    0,          0,     0,    0},     
 {OP_CVTTPS2PI, INV,  XMMI,       0,     MMX,  1},               // OP_CVTTSS2SI REG F3 2C (XMMI)
 {OP_CVTTPD2PI, INV,  XMMI2,      0,     MMX,  1},               // OP_CVTTSD2SI REG F2 2C (XMMI2)
 {OP_CVTPS2PI,  INV,  XMMI,       0,     MMX,  1},               // OP_CVTSS2SI  REG F3 2D (XMMI) 
 {OP_CVTPD2PI,  INV,  XMMI2,      0,     MMX,  1},               // OP_CVTSD2SI  REG F2 2D (XMMI2) 
 {OP_UCOMISS,   XMMI, XMMI,       0,     RS,   0},               // NONE                   (XMMI)
 {OP_UCOMISD,   XMMI2,XMMI2,      0,     RS,   0},               // NONE                   (XMMI2)
 {OP_COMISS,    XMMI, XMMI,       0,     RS,   0},               // NONE                   (XMMI)
 {OP_COMISD,    XMMI2,XMMI2,      0,     RS,   0},               // NONE                   (XMMI2)

 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_CVTPI2PS,  INV,  M64I,       0,     XMMI, 1},               // OP_CVTSI2SS  M32I     F3 2A (XMMI)
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},     
 {OP_UNSPEC,    0,    0,          0,     0,    0},     
 {OP_CVTTPS2PI, INV,  M64R,       0,     MMX,  1},               // OP_CVTTSS2SI M32R REG F3 2C (XMMI)
 {OP_CVTTPD2PI, INV,  M128_M64R,  0,     MMX,  1},               // OP_CVTTSD2SI M64_64R REG F2 2C (XMMI2)
 {OP_CVTPS2PI,  INV,  M64R,       0,     MMX,  1},               // OP_CVTSS2SI  M32R REG F3 2D (XMMI) 
 {OP_CVTPD2PI,  INV,  M128_M64R,  0,     MMX,  1},               // OP_CVTSD2SI  M64_64R REG F2 2D (XMMI2) 
 {OP_UCOMISS,   XMMI, M32R,       0,     XMMI, 0},               // NONE                        (XMMI)
 {OP_UCOMISD,   XMMI2,M64R_64,    0,     XMMI2,0},               // NONE                        (XMMI2)
 {OP_COMISS,    XMMI, M32R,       0,     XMMI, 0},               // NONE                        (XMMI)
 {OP_COMISD,    XMMI2,M64R_64,    0,     XMMI2,0},               // NONE                        (XMMI2)
                                                                 // MMX -> REG
                                                                 // M64R      -> M32R
                                                                 // M128_M64R -> M64R_64
                                                                 // M64I      -> M32I
};

//
// Opcode Ex table
//
static XMMI_INSTR_INFO InstInfoTableEX[64] = {
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_CVTTPD2DQ, LOOKUP,12,        0,     0,    0},               // OP_CVTPD2DQ F2 E6 (XMMI2)    
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved

 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_CVTTPD2DQ, LOOKUP,14,        0,     0,    0},               // OP_CVTPD2DQ F2 E6 (XMMI2)    
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved
};

//
//This table is indexed by 
//   (ULONG Op2Location:5) // Location of 2nd operand
//if (ULONG Op1Location:5) // Location of 1st operand has a value of LOOKUP
//from XMMI_INSTR_INFO 
//
//
static XMMI_INSTR_INFO InstInfoTableX[16] = {
 {OP_CVTPS2PD,  INV,  XMMI,       0,     XMMI2,1},               //    0F 5A  (XMMI2)
 {OP_CVTSS2SD,  INV,  XMMI,       0,     XMMI2,0},               // F3 0F 5A  (XMMI2)

 {OP_CVTPS2PD,  INV,  M64R,       0,     XMMI2,1},               //    0F 5A  (XMMI2)
 {OP_CVTSS2SD,  INV,  M32R,       0,     XMMI2,0},               // F3 0F 5A  (XMMI2)

 {OP_CVTDQ2PS,  INV,  XMMI_M32I,  0,     XMMI, 3},               //    0F 5B  (XMMI2)
 {OP_CVTTPS2DQ, INV,  XMMI,       0,     XMMI_M32I, 3},          // F3 0F 5B  (XMMI2)
 {OP_CVTPS2DQ,  INV,  XMMI,       0,     XMMI_M32I, 3},          // 66 0F 5B  (XMMI2)
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved

 {OP_CVTDQ2PS,  INV,  M128_M32I,  0,     XMMI, 3},               //    0F 5B  (XMMI2)
 {OP_CVTTPS2DQ, INV,  M128_M32R,  0,     XMMI_M32I, 3},          // F3 0F 5B  (XMMI2)
 {OP_CVTPS2DQ,  INV,  M128_M32R,  0,     XMMI_M32I, 3},          // 66 0F 5B  (XMMI2)
 {OP_UNSPEC,    0,    0,          0,     0,    0},               // reserved

 {OP_CVTTPD2DQ, INV,  XMMI2,      0,     XMMI_M32I,1},           // 66 0F E6 (XMMI2)    
 {OP_CVTPD2DQ,  INV,  XMMI2,      0,     XMMI_M32I,1},           // F2 0F E6 (XMMI2)    

 {OP_CVTTPD2DQ, INV,  M128_M64R,  0,     XMMI_M32I,1},           // 66 0F E6 (XMMI2)     
 {OP_CVTPD2DQ,  INV,  M128_M64R,  0,     XMMI_M32I,1},           // F2 0F E6 (XMMI2)    
};

//The following table is used to parse Mod/RM byte to compute the data memory reference
/* Mod | Reg | R/M */
/* 7-6 | 5-3 | 2-0 */

/* Reg: EAX ECX EDX EBX ESP EBP ESI EDI */
/*      000 001 010 011 100 101 110 111 */
/* Mod: R/M:     Ea            Routine  */
/* 00   000      [EAX]         ax0      */
/*      001      [ECX]         cx0      */
/*      010      [EDX]         dx0      */
/*      011      [EBX]         bx0      */
/*      100      +SIB          sib0     */
/*      101      disp32        d32      */
/*      110      [ESI]         si0      */
/*      111      [EDI]         di0      */
/* 01   000      disp8[EAX]    ax8      */
/*      001      disp8[ECX]    cx8      */
/*      010      disp8[EDX]    dx8      */
/*      011      disp8[EBX]    bx8      */
/*      100      disp8+SIB     sib8     */
/*      101      disp8[EBP]    bp8      */
/*      110      disp8+[ESI]   si8      */
/*      111      disp8+[EDI]   di8      */
/* 10   000      disp32[EAX]   ax32     */
/*      001      disp32[ECX]   cx32     */
/*      010      disp32[EDX]   dx32     */
/*      011      disp32[EBX]   bx32     */
/*      100      disp32+SIB    sib32    */
/*      101      disp32[EBP]   bp32     */
/*      110      disp32+[ESI]  si32     */
/*      111      disp32+[EDI]  di32     */
/* 11   000-111  Regs          reg      */
typedef (*codeptr)();
static codeptr modrm32[256] = {
/*       0       1       2       3       4       5       6       7          */
/*       8       9       a       b       c       d       e       f          */
/*0*/    ax0,    cx0,    dx0,    bx0,    sib0,   d32,    si0,    di0,    /*0*/
/*0*/    ax0,    cx0,    dx0,    bx0,    sib0,   d32,    si0,    di0,    /*0*/
/*1*/    ax0,    cx0,    dx0,    bx0,    sib0,   d32,    si0,    di0,    /*1*/
/*1*/    ax0,    cx0,    dx0,    bx0,    sib0,   d32,    si0,    di0,    /*1*/
/*2*/    ax0,    cx0,    dx0,    bx0,    sib0,   d32,    si0,    di0,    /*2*/
/*2*/    ax0,    cx0,    dx0,    bx0,    sib0,   d32,    si0,    di0,    /*2*/
/*3*/    ax0,    cx0,    dx0,    bx0,    sib0,   d32,    si0,    di0,    /*3*/
/*3*/    ax0,    cx0,    dx0,    bx0,    sib0,   d32,    si0,    di0,    /*3*/
/*4*/    ax8,    cx8,    dx8,    bx8,    sib8,   bp8,    si8,    di8,    /*4*/
/*4*/    ax8,    cx8,    dx8,    bx8,    sib8,   bp8,    si8,    di8,    /*4*/
/*5*/    ax8,    cx8,    dx8,    bx8,    sib8,   bp8,    si8,    di8,    /*5*/
/*5*/    ax8,    cx8,    dx8,    bx8,    sib8,   bp8,    si8,    di8,    /*5*/
/*6*/    ax8,    cx8,    dx8,    bx8,    sib8,   bp8,    si8,    di8,    /*6*/
/*6*/    ax8,    cx8,    dx8,    bx8,    sib8,   bp8,    si8,    di8,    /*6*/
/*7*/    ax8,    cx8,    dx8,    bx8,    sib8,   bp8,    si8,    di8,    /*7*/
/*7*/    ax8,    cx8,    dx8,    bx8,    sib8,   bp8,    si8,    di8,    /*7*/
/*8*/    ax32,   cx32,   dx32,   bx32,   sib32,  bp32,   si32,   di32,   /*8*/
/*8*/    ax32,   cx32,   dx32,   bx32,   sib32,  bp32,   si32,   di32,   /*8*/
/*9*/    ax32,   cx32,   dx32,   bx32,   sib32,  bp32,   si32,   di32,   /*9*/
/*9*/    ax32,   cx32,   dx32,   bx32,   sib32,  bp32,   si32,   di32,   /*9*/
/*a*/    ax32,   cx32,   dx32,   bx32,   sib32,  bp32,   si32,   di32,   /*a*/
/*a*/    ax32,   cx32,   dx32,   bx32,   sib32,  bp32,   si32,   di32,   /*a*/
/*b*/    ax32,   cx32,   dx32,   bx32,   sib32,  bp32,   si32,   di32,   /*b*/
/*b*/    ax32,   cx32,   dx32,   bx32,   sib32,  bp32,   si32,   di32,   /*b*/
/*c*/    reg,    reg,    reg,    reg,    reg,    reg,    reg,    reg,    /*c*/
/*c*/    reg,    reg,    reg,    reg,    reg,    reg,    reg,    reg,    /*c*/
/*d*/    reg,    reg,    reg,    reg,    reg,    reg,    reg,    reg,    /*d*/
/*d*/    reg,    reg,    reg,    reg,    reg,    reg,    reg,    reg,    /*d*/
/*e*/    reg,    reg,    reg,    reg,    reg,    reg,    reg,    reg,    /*e*/
/*e*/    reg,    reg,    reg,    reg,    reg,    reg,    reg,    reg,    /*e*/
/*f*/    reg,    reg,    reg,    reg,    reg,    reg,    reg,    reg,    /*f*/
/*f*/    reg,    reg,    reg,    reg,    reg,    reg,    reg,    reg,    /*f*/
/*       0       1       2       3       4       5       6       7          */
/*       8       9       a       b       c       d       e       f          */
};


/***
* fpieee_flt_simd - IEEE fp filter routine
*
*Purpose:
*   Invokes the user's trap handler on IEEE fp exceptions and provides
*   it with all necessary information
*
*Entry:
*   unsigned long exc_code: the NT exception code
*   PEXCEPTION_POINTERS p: a pointer to the NT EXCEPTION_POINTERS struct
*   int handler (_FPIEEE_RECORD *): a user supplied ieee trap handler
*
*   Note: The IEEE filter routine does not handle some transcendental
*   instructions. This can be done at the cost of additional decoding.
*   Since the compiler does not generate these instructions, no portable
*   program should be affected by this fact.
*
*Exit:
*   returns the value returned by handler
*
*Exceptions:
*
*******************************************************************************/

int fpieee_flt_simd(unsigned long exc_code,
                    PTEMP_EXCEPTION_POINTERS p,
                    int (__cdecl *handler) (_FPIEEE_RECORD *))
{

    PEXCEPTION_RECORD pexc;
    PTEMP_CONTEXT pctxt;
    PFLOATING_EXTENDED_SAVE_AREA pExtendedArea;
    _FPIEEE_RECORD FpieeeRecord;
    ULONG Status = EXCEPTION_CONTINUE_EXECUTION;
    ULONG *pinfo;
    PUCHAR istream;
    UCHAR ibyte;
    BOOLEAN fPrefix,fScalar,fDecode, fMod;
    MXCSRReg MXCsr;
    XMMI_FP_ENV XmmiFpEnv;
    XMMI_ENV XmmiEnv;
    PXMMI_INSTR_INFO ptable;
    PXMMI_INSTR_INFO instr_info_table;
    PXMMIINSTR instr;
    ULONG instrIndex, index, pair, InstLen = 0, Offset = 0;
    PXMMI_EXCEPTION_FLAGS OFlags, Flags;
    ULONG DataOffset;

#ifdef _XMMI_DEBUG
    DebugFlag=7;
#endif

    pexc = p->ExceptionRecord;
    pinfo = pexc->ExceptionInformation;
    
    //Check for software generated exception
    
    //
    //By convention the first argument to the exception is 0 for h/w exception. 
    //For s/w exceptions it points to the _FPIEEE_RECORD
    //
    if (pinfo[0]) {

        //  
        //We have a software exception:
        //the first parameter points to the IEEE structure
        //
        return handler((_FPIEEE_RECORD *)(pinfo[0]));

    }

    //
    //If control reaches here, then we have to deal with a hardware exception
    //First check to see if the context record has XMMI saved area.
    //
    pctxt = (PTEMP_CONTEXT) p->ContextRecord;
    
    if ((pctxt->ContextFlags & CONTEXT_EXTENDED_REGISTERS) != CONTEXT_EXTENDED_REGISTERS) {
#ifdef _XMMI_DEBUG
        fprintf(stderr, "No Context_Extended_Registers area\n");
#else        
        _ASSERT(0);
#endif
        return EXCEPTION_CONTINUE_SEARCH;
        
    } else {
        //For NT
        pExtendedArea = (PFLOATING_EXTENDED_SAVE_AREA) &pctxt->ExtendedRegisters[0];
    }
 
#ifdef _XMMI_DEBUG
    dump_Control(p);
#endif //_XMMI_DEBUG

    //
    //Save the original DataOffset.
    //Unlike X87 (X87: The memory reference is provided via DataOffset), XMMI's 
    //memory reference is derived from parsing the instruction by this routine.
    //
    DataOffset = pExtendedArea->DataOffset;

    //
    //Check Instruction prefixes and/or 2 byte opcode starts with 0F
    //The only prefix we support is F3 (Scalar form of the XMMI instruction) for XMMI.
    //Additional prefix we support is 66 and F2 (Scalar form of the XMMI2 instruction) for XMMI2.
    //There may other instruction prefix, such as, segment override or address size. 
    //However, the filter routine does not handle this type (same as x87).
    //
    //Default to Katmai Instruction set
    instrIndex = XMMI_INSTR;
    fDecode = FALSE;      //Default to no error seen
    __try {

        //
        //Read instruction prefixes
        //
        fPrefix = TRUE;   //Default to prefix scan
        fScalar = FALSE;  //Default to non-scalar instruction

        //
        //Unlike X87 (X87: the EIP is from: istream = (PUCHAR) pExtendedArea->ErrorOffset),
        //EIP is from trap frame's EIP.
        //
        istream = (PUCHAR) pctxt->Eip;

        while (fPrefix) {
            ibyte = *istream;
            istream++;
            switch (ibyte) {
                case 0xF3:  // rep or XMMI scaler
                    fScalar = TRUE;
                    InstLen++;
                    break;

                case 0x66:  // operand size or XMMI2
                    instrIndex = XMMI2_INSTR;
                    InstLen++;
                    break;

                case 0xF2:  // rep or XMMI2 scaler
                    fScalar = TRUE;
                    instrIndex = XMMI2_INSTR;
                    InstLen++;
                    break;

                case 0x2e:  // cs override
                case 0x36:  // ss override
                case 0x3e:  // ds override
                case 0x26:  // es override
                case 0x64:  // fs override
                case 0x65:  // gs override

                    //
                    //We don't support this.  X87 does not support this either. 
                    //
                    fDecode = TRUE;
                    break;

                case 0x67:  // address size
                case 0xF0:  // lock
 
                    fDecode = TRUE;         
                    break;
                    
                default:    // stop the prefix scan
                    fPrefix = FALSE;
                    break;
            }
        }
    } __except (EXCEPTION_EXECUTE_HANDLER) {
#ifdef _XMMI_DEBUG
        DPrint(XMMI_WARNING, ("Encounter Invalid Istream during parsing 1 %x\n", istream));  
#else
         _ASSERT(0);
#endif
        return EXCEPTION_CONTINUE_SEARCH; 
    }

    if (fDecode) {
#ifdef _XMMI_DEBUG
        DPrint(XMMI_WARNING, ("Invalid Istream 1, %x EIP: %x \n", istream, pctxt->Eip));  
        istream = (PUCHAR) pctxt->Eip;
        DPrint(XMMI_WARNING, ("%x\n", *istream));  
#else
        _ASSERT(0);
#endif
        return EXCEPTION_CONTINUE_SEARCH;
    }

    //
    // Get the next opcode
    //
    __try {

        //
        // instr points to the real Opcode (istream points to the byte after 0F)
        //
        instr = (PXMMIINSTR) istream;

        //
        // If we get here, ibyte can only point to 0F, for,
        // there are only 4 valid cases: 
        // 66 0F, F2 0F, F3 0F or 0F
        //
        if (ibyte != 0x0F) {
            fDecode = TRUE;
            goto tryExit;
        }
        
        //5x
        if (instr->Opcode1b == 5) {
            instr_info_table = InstInfoTable5X;
        //Cx
        } else {
            if (instr->Opcode1b == 0x0C) {
                instr_info_table = InstInfoTableCX;
            //2x
            } else {
                if (instr->Opcode1b == 2) {
                    instr_info_table = InstInfoTable2X;
                } else {
                    if (instr->Opcode1b == 0x0E) {
                        instr_info_table = InstInfoTableEX;
                    } else {
                        fDecode = TRUE;
                        goto tryExit;
                    }
                }
            }    
        }

        //
        //Pick up the Mod field: Register Ref (0) or Memory Ref (1)
        //
        fMod = instr->Mod == 0x3 ? 0 : 1;

        //
        //fScalar indicates XMMI/XMMI2 instruction is a scalar form or not.
        //1st byte of the Opcode tells which table it is.
        //2nd byte of the Opcode tells which entry it is in the table.
        //Compute the index, if it is a memory ref, index will be at the second half of the table.
        //ie. ADDPS 58 - for reg, index = 8*2
        //    ADDPD 58 - for reg, index = 8*2+1
        //    ADDPS 58 - for mem, index = 18h*2
        //    ADDPD 58 - for mem, index = 18h*2+1

        index = instr->Opcode1a | fMod << 4;
        
        //
        //Check to see if the Opcode byte is valid.
        //
        if (index > INSTR_IN_OPTABLE) {
            fDecode = TRUE;
            goto tryExit;
        }

        ptable = &instr_info_table[index*INSTR_SET_SUPPORTED+instrIndex];
        if (ptable->Operation == OP_UNSPEC) {
            fDecode = TRUE;
            goto tryExit;
        } else {

            //
            // Odd ball instructions, perform further look up.
            //
            if (ptable->Op1Location == LOOKUP) {
                if (fScalar) {
                    ptable = &InstInfoTableX[ptable->Op2Location+1];
                } else {
                    ptable = &InstInfoTableX[ptable->Op2Location];
                }

                //
                //All bets are off.
                //
                fScalar = 0;
                instrIndex = XMMI2_OTHER;
            }

        }

        //
        // Adjust and Save the Operation, Take fScalar into account.
        //
        XmmiFpEnv.OriginalOperation = ptable->Operation + fScalar;

        //
        //At this point, we have a valid XMMI instruction that this routine supports.
        //
        //nF3 + 0F OpCode Mod/RM
        //nF2 + 0F OpCode 
        //n66 + 0F Opcode
        //      0F Opcode
        InstLen = InstLen + 3;

        //
        //We need to compute the memory reference if the data is a memory reference type.
        //
        if (fMod) {
            
            istream = (PUCHAR) instr;
            
            //
            //instr points to the opcode, we want the Mod/RM byte in ibyte.
            //
            istream++;
            ibyte = *istream;

            //
            //point to the byte after Mod/RM
            //
            istream++;

            //
            //Parse the instruction to calculate the memory reference, store the result
            //in DataOffset.
            //
            Offset = (*modrm32[ibyte])(&pExtendedArea->DataOffset, pctxt, istream);
            PRINTF(("pExtendedArea->DataOffset %x\n", pExtendedArea->DataOffset));  
        }

        //
        //Load Operand 1 for instruction with 2 operands, 
        //or none for instruction with 1 operand.
        //
        LoadOperand(fScalar, ptable->Op1Location, instr->Reg, &XmmiFpEnv.Operand1, pctxt); 

        //
        //Load Operand 2
        //
        if (ptable->Op1Location == INV) { //instruction with 1 operand
            LoadOperand(fScalar, ptable->Op2Location, instr->RM,  &XmmiFpEnv.Operand1, pctxt);
            XmmiFpEnv.Operand2.Op.OperandValid = 0;
        } else {                          //instruction with 2 operands
            LoadOperand(fScalar, ptable->Op2Location, instr->RM,  &XmmiFpEnv.Operand2, pctxt); 
        }

        //
        //Load Result, init to Operand1
        //
        LoadOperand(fScalar, ptable->ResultLocation, instr->Reg, &XmmiFpEnv.Result, pctxt); 
    
        InstLen = InstLen + Offset;

        //
        //Pick up imm8 if any.
        //
        if (ptable->Op3Location == HAS_IMM8) {
            istream = istream + Offset;
            XmmiFpEnv.Imm8 = *istream;
            InstLen++;
        }


tryExit: ;
    } __except (EXCEPTION_EXECUTE_HANDLER) {
#ifdef _XMMI_DEBUG
        DPrint(XMMI_WARNING, ("Encounter Invalid Istream during parsing 2, %x\n", istream)); 
#else
         _ASSERT(0);
#endif
        return EXCEPTION_CONTINUE_SEARCH; 
    }
   
    if (fDecode) {
#ifdef _XMMI_DEBUG
        DPrint(XMMI_WARNING, ("Invalid Istream 2, %x Inst: %x, %x\n", istream, instr, *instr)); 
#else
        _ASSERT(0);
#endif
        return EXCEPTION_CONTINUE_SEARCH;
    }

    //
    //Set up XmmiEnv environment from fp & mxcsr for Emulation.
    //

    //decode fp environment information
    switch (pExtendedArea->ControlWord & IMCW_PC) {
    case IPC_64:
        XmmiEnv.Precision = _FpPrecisionFull;
        break;
    case IPC_53:
        XmmiEnv.Precision = _FpPrecision53;
        break;
    case IPC_24:
        XmmiEnv.Precision = _FpPrecision24;
        break;
    }

    //decode mxcsr
    MXCsr.u.ul = pExtendedArea->MXCsr;
    switch (MXCsr.u.mxcsr.Rc & MaskCW_RC) {
    case rc_near:
        XmmiEnv.Rc = _FpRoundNearest;
        break;
    case rc_down:
        XmmiEnv.Rc = _FpRoundMinusInfinity;
        break;
    case rc_up:
        XmmiEnv.Rc = _FpRoundPlusInfinity;
        break;
    case rc_chop:
        XmmiEnv.Rc = _FpRoundChopped;
        break;
    }

    //and the rest.
    XmmiEnv.Masks = (MXCsr.u.ul & MXCSR_MASKS_MASK) >> 7;
    XmmiEnv.Fz    = MXCsr.u.mxcsr.Fz;
    XmmiEnv.Daz   = MXCsr.u.mxcsr.daz;
    XmmiEnv.EFlags = pctxt->EFlags;
    XmmiEnv.Imm8 = XmmiFpEnv.Imm8;
    Flags = (PXMMI_EXCEPTION_FLAGS) &XmmiEnv.Flags;

    //
    //Set up XmmiFpEnv environment for this routine.
    //

    //Save the original exception flags
    XmmiFpEnv.IFlags = MXCsr.u.ul & MXCSR_FLAGS_MASK;
    XmmiFpEnv.OFlags = 0;
    OFlags = (PXMMI_EXCEPTION_FLAGS) &XmmiFpEnv.OFlags;

#ifdef _XMMI_DEBUG
    dump_XmmiFpEnv(&XmmiFpEnv);
#endif //_XMMI_DEBUG

    pair = ptable->NumArgs + 1;
    if (fScalar) pair = 1;

    //
    // Loop through SIMD.  1 data item at a time.
    //
    for ( index=0; index < pair; index++ ) {    

        //
        // ieee field does not have denormal bit defined. Emulator returns
        // all Exception flags bits through this XmmiEnv.Flags field.
        //
        XmmiEnv.Flags = 0;

        //
        // Set up ieee Input Operands
        //
        InitExcptFlags(FpieeeRecord.Cause);
        InitExcptFlags(FpieeeRecord.Enable);
        InitExcptFlags(FpieeeRecord.Status);
        FpieeeRecord.RoundingMode = XmmiEnv.Rc; 
        FpieeeRecord.Precision = XmmiEnv.Precision;
        FpieeeRecord.Operation = XmmiFpEnv.OriginalOperation;

        FpieeeRecord.Operand1.OperandValid = XmmiFpEnv.Operand1.Op.OperandValid; 
        if (instrIndex == XMMI2_INSTR) {
            FpieeeRecord.Operand1.Value.Q64Value = XmmiFpEnv.Operand1.Op.Value.Fpq64Value.W[index];
        } else {
            if (instrIndex == XMMI_INSTR) {
                FpieeeRecord.Operand1.Value.U32Value = XmmiFpEnv.Operand1.Op.Value.Fp128Value.W[index];
            } else {
                switch (XmmiFpEnv.OriginalOperation) {
                    case OP_CVTPS2PD:
                    case OP_CVTSS2SD:
                         FpieeeRecord.Operand1.Value.Q64Value = XmmiFpEnv.Operand1.Op.Value.Fp128Value.W[index];
                         break;

                    case OP_CVTDQ2PS:
                    case OP_CVTTPS2DQ:
                    case OP_CVTPS2DQ:
                         FpieeeRecord.Operand1.Value.U32Value = XmmiFpEnv.Operand1.Op.Value.Fp128Value.W[index];
                         break;

                    case OP_CVTTPD2DQ:
                    case OP_CVTPD2DQ:
                         FpieeeRecord.Operand1.Value.Q64Value = XmmiFpEnv.Operand1.Op.Value.Fpq64Value.W[index];
                         break;
                }
            }
        }
        FpieeeRecord.Operand1.Format = XmmiFpEnv.Operand1.Op.Format;
       
        if (XmmiFpEnv.Operand2.Op.OperandValid) {
            FpieeeRecord.Operand2.OperandValid = XmmiFpEnv.Operand2.Op.OperandValid; 
            if (instrIndex == XMMI2_INSTR) {
                FpieeeRecord.Operand2.Value.Q64Value = XmmiFpEnv.Operand2.Op.Value.Fpq64Value.W[index];
            } else {
                if (instrIndex == XMMI_INSTR) {
                    FpieeeRecord.Operand2.Value.U32Value = XmmiFpEnv.Operand2.Op.Value.Fp128Value.W[index];
                } else {
                    switch (XmmiFpEnv.OriginalOperation) {
                        case OP_CVTPS2PD:
                        case OP_CVTSS2SD:
                             FpieeeRecord.Operand2.Value.Q64Value = XmmiFpEnv.Operand2.Op.Value.Fp128Value.W[index];
                             break;

                        case OP_CVTDQ2PS:
                        case OP_CVTTPS2DQ:
                        case OP_CVTPS2DQ:
                             FpieeeRecord.Operand2.Value.U32Value = XmmiFpEnv.Operand2.Op.Value.Fp128Value.W[index];
                             break;

                        case OP_CVTTPD2DQ:
                        case OP_CVTPD2DQ:
                             FpieeeRecord.Operand2.Value.Q64Value = XmmiFpEnv.Operand2.Op.Value.Fpq64Value.W[index];
                             break;
                    }
                }
            }
            FpieeeRecord.Operand2.Format = XmmiFpEnv.Operand2.Op.Format;
        } else {
            FpieeeRecord.Operand2.OperandValid = 0;
        }

        FpieeeRecord.Result.OperandValid = 0; 
        if (instrIndex == XMMI2_INSTR) {
            FpieeeRecord.Result.Value.Q64Value = XmmiFpEnv.Result.Op.Value.Fpq64Value.W[index];
        } else {
            if (instrIndex == XMMI_INSTR) {
                FpieeeRecord.Result.Value.U32Value = XmmiFpEnv.Result.Op.Value.Fp128Value.W[index];
            } else {
                switch (XmmiFpEnv.OriginalOperation) {
                    case OP_CVTPS2PD:
                    case OP_CVTSS2SD:
                         FpieeeRecord.Result.Value.Q64Value = XmmiFpEnv.Result.Op.Value.Fp128Value.W[index];
                         break;

                    case OP_CVTDQ2PS:
                    case OP_CVTTPS2DQ:
                    case OP_CVTPS2DQ:
                         FpieeeRecord.Result.Value.U32Value = XmmiFpEnv.Result.Op.Value.Fp128Value.W[index];
                         break;

                    case OP_CVTTPD2DQ:
                    case OP_CVTPD2DQ:
                         FpieeeRecord.Result.Value.Q64Value = XmmiFpEnv.Result.Op.Value.Fpq64Value.W[index];
                         break;
                }
            }
        }
        FpieeeRecord.Result.Format = XmmiFpEnv.Result.Op.Format;

        XmmiEnv.Ieee = (_PFPIEEE_RECORD) &FpieeeRecord;

#ifdef _XMMI_DEBUG
        PRINTF(("INPUT #%d:\n", index));
#endif _XMMI_DEBUG

        //
        // Perform Emulation
        //
        // Note: Cause will be all zeros for denormal.  
        //       Raised     - Denormal
        //       Not Raised - no exception
        //
        if ((instrIndex == XMMI2_INSTR) || (instrIndex == XMMI2_OTHER)) {
            XmmiFpEnv.Raised[index] = XMMI2_FP_Emulation(&XmmiEnv);
        } else {
            XmmiFpEnv.Raised[index] = XMMI_FP_Emulation(&XmmiEnv);
        }

        //
        // Remember the exceptions. 
        //
        XmmiFpEnv.Flags[index] = XmmiEnv.Flags;

        if (XmmiFpEnv.Raised[index] == ExceptionRaised) {

#ifdef _XMMI_DEBUG
            PRINTF(("OUTPUT #%d: ExceptionRaised\n", index));
            print_FPIEEE_RECORD_EXCEPTION(&XmmiEnv);
#endif //_XMMI_DEBUG
            
            //
            //ORed the flags.
            //
            if (Flags->pe) OFlags->pe = 1;
            if (Flags->ue) OFlags->ue = 1;
            if (Flags->oe) OFlags->oe = 1; 
            if (Flags->ze) OFlags->ze = 1;
            if (Flags->de) OFlags->de = 1;
            if (Flags->ie) OFlags->ie = 1;

            //
            // invoke the user-defined exception handler
            //
            Status = handler(&FpieeeRecord);        

            //
            // return if not EXCEPTION_CONTINUE_EXECUTION
            //
            if (Status != EXCEPTION_CONTINUE_EXECUTION) {
                return (Status);
            }

            //
            // Adjust the compare result.
            //
            AdjustExceptionResult(XmmiFpEnv.OriginalOperation, &XmmiEnv);

        } else {
#ifdef _XMMI_DEBUG
            PRINTF(("OUTPUT #%d:No ExceptionRaised\n", index));
            print_FPIEEE_RECORD_NO_EXCEPTION(&XmmiEnv);
#endif //_XMMI_DEBUG
        }

        //
        // Or the result piece together
        //
        XmmiFpEnv.Result.Op.OperandValid = FpieeeRecord.Result.OperandValid;
        XmmiFpEnv.EFlags = XmmiEnv.EFlags;
        if (XmmiFpEnv.Result.Op.OperandValid) {
            if (instrIndex == XMMI2_INSTR) {
                XmmiFpEnv.Result.Op.Value.Fpq64Value.W[index] = FpieeeRecord.Result.Value.Q64Value;
            } else {
                if (instrIndex == XMMI_INSTR) {
                    XmmiFpEnv.Result.Op.Value.Fp128Value.W[index] = FpieeeRecord.Result.Value.U32Value;
                } else {
                    switch (XmmiFpEnv.OriginalOperation) {
                        case OP_CVTPS2PD:
                        case OP_CVTSS2SD:
                             XmmiFpEnv.Result.Op.Value.Fpq64Value.W[index] = FpieeeRecord.Result.Value.U32Value;
                             break;

                        case OP_CVTDQ2PS:
                        case OP_CVTTPS2DQ:
                        case OP_CVTPS2DQ:
                             XmmiFpEnv.Result.Op.Value.Fp128Value.W[index] = FpieeeRecord.Result.Value.U32Value;
                             break;
                        case OP_CVTTPD2DQ:
                        case OP_CVTPD2DQ:
                             XmmiFpEnv.Result.Op.Value.Fpq64Value.W[index] = FpieeeRecord.Result.Value.Q64Value;
                             break;
                    }
                }
            }
        }
    } // End of Loop through SIMD.  1 data item at a time.

    //
    // Update the result from XmmiFpEnv to the context
    // 
    UpdateResult(&XmmiFpEnv.Result, pctxt, XmmiFpEnv.EFlags);

#ifdef _XMMI_DEBUG
    //
    // Valid the processor MXCSR and the emulator MXCSR 
    //
    NotOk = ValidateResult(&XmmiFpEnv);
#endif //_XMMI_DEBUG

    //
    //Update EIP
    //
    istream = (PUCHAR) pctxt->Eip;
    istream = istream + InstLen;
    (PUCHAR) pctxt->Eip = istream;

    //
    //Place the original one back.
    //
    pExtendedArea->DataOffset = DataOffset;


    return Status;

}

/***
* LoadOperand - Load in operand information
*
*Purpose:
*   Fill in data in the internal operand structure based on the information 
*   found in the floating point context and the location code
*
*Entry:
*    fScalar             Packed or Scalar
*    opLocation          type of the operand
*    opReg               reg number
*    pOperand            pointer to the operand to be filled in
*    pExtendedArea       pointer to the floating point context extended area
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

void
LoadOperand(
    BOOLEAN fScalar,
    ULONG OpLocation,
    ULONG OpReg,
    POPERAND pOperand,
    PTEMP_CONTEXT pctxt)

{

    PXMMI_AREA XmmiArea;
    PX87_AREA  X87Area;
    PMMX_AREA  MmxArea;
    PFLOATING_EXTENDED_SAVE_AREA pExtendedArea;
    ULONG index;
    PXMMI128 Fp128;
    
    //
    // If location is REG, the register number is
    // encoded in the instruction
    //
    pOperand->OpLocation = OpLocation;
    if (pOperand->OpLocation == INV) {
        pOperand->Op.OperandValid = 0;
        return;
    }

    //
    // Change to the sclar form if it is a scalr instruction.
    //
    if ((OpLocation == XMMI) || (OpLocation == MMX) || (OpLocation == XMMI2) || OpLocation == XMMI_M32I) {
 
        if (fScalar) {
            if (OpLocation == MMX) {
                pOperand->OpLocation = REG;
                }
            }
        pOperand->OpReg = OpReg;

    } else {
        if ((fScalar) && (OpLocation != INV)) {
            if (OpLocation == M128_M32R) {
                pOperand->OpLocation = M32R;
            }

            if (OpLocation == M128_M64R) {
                pOperand->OpLocation = M64R_64;
            }

            if (OpLocation == M64R) {
                pOperand->OpLocation = M32R;
            }

            if (OpLocation == M64I) {
                pOperand->OpLocation = M32I;
            }
        }
    }


    pExtendedArea = (PFLOATING_EXTENDED_SAVE_AREA) &pctxt->ExtendedRegisters[0];

    //
    // Init to 0
    //
    for ( index=0; index < 4; index++ ) {   
        pOperand->Op.Value.Fp128Value.W[index] = 0;
    }

    //
    // Assume valid operand (this is almost always the case)
    //
    pOperand->Op.OperandValid = 1;

    //
    // Load up value from the context area.  We need to be careful about accessing
    // the value, make sure there is no compiler intermediate data type conversion
    // via X87 floating point instruction.  If there is, X87 floating point inst
    // can screw us up when encountering a bad input value.  Bad input value may
    // be changed by the processor due to the processor is executing a masked 
    // X87 floating point inst.
    //
    switch (pOperand->OpLocation) {

        case M128_M32I:
             pOperand->Op.Format = _FpFormatI32;
             pOperand->Op.Value.Fp128Value = *(_FP128 *)(pExtendedArea->DataOffset);
             break;

        case M128_M32R:
             pOperand->Op.Format = _FpFormatFp32;
             pOperand->Op.Value.Fp128Value = *(_FP128 *)(pExtendedArea->DataOffset);
             break;

        case M128_M64R:
             pOperand->Op.Format = _FpFormatFp64;
             pOperand->Op.Value.Fp128Value = *(_FP128 *)(pExtendedArea->DataOffset);
             break;

        case M64R:
             pOperand->Op.Format = _FpFormatFp32;
             pOperand->Op.Value.U64Value = *(_U64 *)(pExtendedArea->DataOffset);
             break;

        case M64R_64:
             pOperand->Op.Format = _FpFormatFp64;
             pOperand->Op.Value.U64Value = *(_U64 *)(pExtendedArea->DataOffset);
             break;

        case M32R:
             pOperand->Op.Format = _FpFormatFp32;
             pOperand->Op.Value.U32Value = *(_U32 *)(pExtendedArea->DataOffset);
             break;

        case M64I:
             pOperand->Op.Format = _FpFormatI32;
             pOperand->Op.Value.U64Value = *(_U64 *)(pExtendedArea->DataOffset);
             break;

        case M32I:
             pOperand->Op.Format = _FpFormatI32;
             pOperand->Op.Value.U32Value = *(_U32 *)(pExtendedArea->DataOffset);
             break;

        case XMMI:
             XmmiArea = (PXMMI_AREA) &pExtendedArea->XMMIRegisterArea[0];
             pOperand->Op.Format = _FpFormatFp32;
             Fp128 = &XmmiArea->Xmmi[OpReg];
             pOperand->Op.Value.Fp128Value = Fp128->u.fp128;
             break;

        case XMMI2:
             XmmiArea = (PXMMI_AREA) &pExtendedArea->XMMIRegisterArea[0];
             pOperand->Op.Format = _FpFormatFp64;
             Fp128 = &XmmiArea->Xmmi[OpReg];
             pOperand->Op.Value.Fp128Value = Fp128->u.fp128;
             break;
         
        case XMMI_M32I:
             XmmiArea = (PXMMI_AREA) &pExtendedArea->XMMIRegisterArea[0];
             pOperand->Op.Format = _FpFormatI32;
             Fp128 = &XmmiArea->Xmmi[OpReg];
             pOperand->Op.Value.U32Value = Fp128->u.ul[0];
             break;

        case MMX:
             X87Area = (PX87_AREA) &pExtendedArea->X87RegisterArea[0];
             pOperand->Op.Format = _FpFormatI32;
             MmxArea = &X87Area->Mm[OpReg];
             pOperand->Op.Value.U64Value = MmxArea->Mmx.u.u64;
             break;

        case REG:
             pOperand->Op.Format = _FpFormatI32;
             switch (OpReg) {
             case 0x0:
                  pOperand->Op.Value.U32Value = pctxt->Eax;
                  break;
             case 0x1:
                  pOperand->Op.Value.U32Value = pctxt->Ecx;
                  break;
             case 0x2:
                  pOperand->Op.Value.U32Value = pctxt->Edx;
                  break;
             case 0x3:
                  pOperand->Op.Value.U32Value = pctxt->Ebx;
                  break;
             case 0x4:
                  //?
                  break;
             case 0x5:
                  pOperand->Op.Value.U32Value = pctxt->Ebp;
                  break;
             case 0x6:
                  pOperand->Op.Value.U32Value = pctxt->Esi;
                  break;
             case 0x7:
                  pOperand->Op.Value.U32Value = pctxt->Edi;
                  break;
             }
        break;
    }

    return;

}


/***
* LoadImm8 - Pick up imm8 from the instruction stream
*
*Purpose:
*    Return the offset of imm8 from the beginning of the Instruction stream 
*    pointer.  This routine is not used.
*
*Entry:
*    Instr - pointer to the Opcode (after f3/0f)
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

ULONG
LoadImm8(
    PXMMIINSTR Instr)

{

    PUCHAR pInstr;
    ULONG  Offset;

#ifdef _XMMI_DEBUG
    if (Console) return DebugImm8;
#endif //_XMMI_DEBUG

    //Assume 32-bit. pInstr points to the Opcode C2 after (f3/0f)
    pInstr = (PUCHAR) Instr;
    //Opcode, ModR/M
    Offset=2;
    //For Mod = 01, 10, 11
    if (Instr->Mod != 3) {
        //Notes #1 PPro 2-5
        if (Instr->RM == 4)  Offset=Offset+1; //SIB
        if (Instr->Mod == 0) Offset=Offset+0;
        if (Instr->Mod == 1) Offset=Offset+1;
        if (Instr->Mod == 2) Offset=Offset+4;
        //Notes #2 PPro 2-5
        if ((Instr->Mod == 0) && (Instr->RM == 5)) Offset=Offset+4; //SIB
        //Notes #3 PPro 2-5
        if ((Instr->Mod == 1) && (Instr->RM == 0)) Offset=Offset+1; //SIB
    }
    
    //imm8 
    return *(pInstr+Offset);

}

/***
* AdjustExceptionResult -  Adjust exception result returned from user's handler
*
*Purpose:
*    This routine is called after the exception is raised from the Emulation
*    the result is passed onto user's handler, and the user returns 
*    EXCEPTION_CONTINUE_EXECUTION.  Go ahead to adjust the result.
*
*Entry:
*   OriginalOperation - Original operation Opcode
*   XmmiEnv - Pointer to Emulation result
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/
void
AdjustExceptionResult(
    ULONG OriginalOperation,
    PXMMI_ENV XmmiEnv)


{

    // 
    //When the exception is raised, the user handler is invoked with the result.
    //If the user expects us to Adjust the result, user handler would have to
    //set the Result.OperandValid to 1.  From emulator's view point, the
    //Result.OperandValid is 0.
    //
    if (!XmmiEnv->Ieee->Result.OperandValid) return;
    if (XmmiEnv->Ieee->Result.Format != _FpCodeCompare) return;

    switch (OriginalOperation) {
        case OP_COMISS:
        case OP_UCOMISS:
        case OP_COMISD:
        case OP_UCOMISD:
             switch (XmmiEnv->Ieee->Result.Value.CompareValue) {
             case _FpCompareEqual:
                  // OF, SF, AF = 000, ZF, PF, CF = 100
                  XmmiEnv->EFlags = (XmmiEnv->EFlags & 0xfffff76a) | 0x00000040;
                  break;
             case _FpCompareGreater:
                  // OF, SF, AF = 000, ZF, PF, CF = 000
                  XmmiEnv->EFlags = XmmiEnv->EFlags & 0xfffff72a;
                  break;
             case _FpCompareLess:
                  // OF, SF, AF = 000, ZF, PF, CF = 001
                  XmmiEnv->EFlags = (XmmiEnv->EFlags & 0xfffff72b) | 0x00000001;
                  break;
             case _FpCompareUnordered:
                  // OF, SF, AF = 000, ZF, PF, CF = 111
                  XmmiEnv->EFlags = (XmmiEnv->EFlags & 0xfffff76f) | 0x00000045;
                  break;
             }
             break;

        case OP_CMPPS:
        case OP_CMPSS:
             switch (XmmiEnv->Ieee->Result.Value.CompareValue) {
             case _FpCompareEqual:
                  switch (XmmiEnv->Imm8) {
                  case IMM8_EQ:
                  case IMM8_LE:
                  case IMM8_NLT:
                  case IMM8_ORD:
                       XmmiEnv->Ieee->Result.Value.U32Value = 0xffffffff;
                       break;

                  case IMM8_LT:
                  case IMM8_UNORD:
                  case IMM8_NEQ:
                  case IMM8_NLE:
                       XmmiEnv->Ieee->Result.Value.U32Value = 0x0;
                       break;
                  }
                  break;
             case _FpCompareGreater:
                  switch (XmmiEnv->Imm8) {
                  case IMM8_NEQ:
                  case IMM8_NLT:
                  case IMM8_NLE:
                  case IMM8_ORD:
                       XmmiEnv->Ieee->Result.Value.U32Value = 0xffffffff;
                       break;

                  case IMM8_EQ:
                  case IMM8_LT:
                  case IMM8_LE:
                  case IMM8_UNORD:
                       XmmiEnv->Ieee->Result.Value.U32Value = 0x0;
                       break;
                  }
                  break;
             case _FpCompareLess:
                  switch (XmmiEnv->Imm8) {
                  case IMM8_LT:
                  case IMM8_LE:
                  case IMM8_NEQ:
                  case IMM8_ORD:
                       XmmiEnv->Ieee->Result.Value.U32Value = 0xffffffff;
                       break;
                  case IMM8_EQ:
                  case IMM8_UNORD:
                  case IMM8_NLT:
                  case IMM8_NLE:
                       XmmiEnv->Ieee->Result.Value.U32Value = 0x0;
                       break;
                  }
                  break;
             case _FpCompareUnordered:
                  switch (XmmiEnv->Imm8) {
                  case IMM8_EQ:
                  case IMM8_LT:
                  case IMM8_LE:
                  case IMM8_ORD:
                       XmmiEnv->Ieee->Result.Value.U32Value = 0x0;
                       break;
                  case IMM8_UNORD:
                  case IMM8_NEQ:
                  case IMM8_NLT:
                  case IMM8_NLE:
                       XmmiEnv->Ieee->Result.Value.U32Value = 0xffffffff;
                       break;
                  }
                  break;
             }

        case OP_CMPPD:
        case OP_CMPSD:
             switch (XmmiEnv->Ieee->Result.Value.CompareValue) {
             case _FpCompareEqual:
                  switch (XmmiEnv->Imm8) {
                  case IMM8_EQ:
                  case IMM8_LE:
                  case IMM8_NLT:
                  case IMM8_ORD:
                       XmmiEnv->Ieee->Result.Value.Q64Value = 0xffffffffffffffff;
                       break;

                  case IMM8_LT:
                  case IMM8_UNORD:
                  case IMM8_NEQ:
                  case IMM8_NLE:
                       XmmiEnv->Ieee->Result.Value.Q64Value = 0x0;
                       break;
                  }
                  break;
             case _FpCompareGreater:
                  switch (XmmiEnv->Imm8) {
                  case IMM8_NEQ:
                  case IMM8_NLT:
                  case IMM8_NLE:
                  case IMM8_ORD:
                       XmmiEnv->Ieee->Result.Value.Q64Value = 0xffffffffffffffff;
                       break;

                  case IMM8_EQ:
                  case IMM8_LT:
                  case IMM8_LE:
                  case IMM8_UNORD:
                       XmmiEnv->Ieee->Result.Value.Q64Value = 0x0;
                       break;
                  }
                  break;
             case _FpCompareLess:
                  switch (XmmiEnv->Imm8) {
                  case IMM8_LT:
                  case IMM8_LE:
                  case IMM8_NEQ:
                  case IMM8_ORD:
                       XmmiEnv->Ieee->Result.Value.Q64Value = 0xffffffffffffffff;
                       break;
                  case IMM8_EQ:
                  case IMM8_UNORD:
                  case IMM8_NLT:
                  case IMM8_NLE:
                       XmmiEnv->Ieee->Result.Value.Q64Value = 0x0;
                       break;
                  }
                  break;
             case _FpCompareUnordered:
                  switch (XmmiEnv->Imm8) {
                  case IMM8_EQ:
                  case IMM8_LT:
                  case IMM8_LE:
                  case IMM8_ORD:
                       XmmiEnv->Ieee->Result.Value.Q64Value = 0x0;
                       break;
                  case IMM8_UNORD:
                  case IMM8_NEQ:
                  case IMM8_NLT:
                  case IMM8_NLE:
                       XmmiEnv->Ieee->Result.Value.Q64Value = 0xffffffffffffffff;
                       break;
                  }
                  break;
             }

             break;
    }

    return;

}

/***
* UpdateResult -  Update result information in the extended floating point context
*
*Purpose:
*   Copy the operand information to  the snapshot of the floating point
*   context or memory, as to make it available on continuation
*
*Entry:
*   pOperand Pointer to the result
*   pctxt    Pointer to the context
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

void
UpdateResult(
    POPERAND pOperand,
    PTEMP_CONTEXT pctxt,
    ULONG EFlags)

{

    PXMMI_AREA XmmiArea;
    PX87_AREA  X87Area;
    PMMX_AREA  MmxArea;
    PFLOATING_EXTENDED_SAVE_AREA pExtendedArea;
    ULONG OpReg;

    OpReg = pOperand->OpReg;
    pExtendedArea = (PFLOATING_EXTENDED_SAVE_AREA) &pctxt->ExtendedRegisters[0];
    XmmiArea = (PXMMI_AREA) &pExtendedArea->XMMIRegisterArea[0];
    X87Area = (PX87_AREA) &pExtendedArea->X87RegisterArea[0];

    switch (pOperand->OpLocation) {

        case M128_M32R:
        case M128_M64R:
        case M128_M32I:
             *(_FP128 *)(pExtendedArea->DataOffset) = pOperand->Op.Value.Fp128Value;
             break;

        case M64R_64:
        case M64R:
             *(_U64 *)(pExtendedArea->DataOffset) = pOperand->Op.Value.U64Value;
             break;

        case M32R:
             *(_U32 *)(pExtendedArea->DataOffset) = pOperand->Op.Value.U32Value;
             break;

        case M64I:
             *(_U64 *)(pExtendedArea->DataOffset) = pOperand->Op.Value.U64Value;
             break;

        case M32I:
             *(_U32 *)(pExtendedArea->DataOffset) = pOperand->Op.Value.U32Value;
             break;

        case XMMI:
        case XMMI2:
        case XMMI_M32I:
             XmmiArea->Xmmi[OpReg].u.fp128 = pOperand->Op.Value.Fp128Value;
             break;

        case MMX:
             MmxArea = &X87Area->Mm[OpReg];
             MmxArea->Mmx.u.u64 = pOperand->Op.Value.U64Value;
             break;

        case REG:

             switch (OpReg) {
             case 0x0:
                  pctxt->Eax = pOperand->Op.Value.U32Value;
                  break;
             case 0x1:
                  pctxt->Ecx = pOperand->Op.Value.U32Value;
                  break;
             case 0x2:
                  pctxt->Edx = pOperand->Op.Value.U32Value;
                  break;
             case 0x3:
                  pctxt->Ebx = pOperand->Op.Value.U32Value;
                  break;
             case 0x4:
                  //?
                  break;
             case 0x5:
                  pctxt->Ebp = pOperand->Op.Value.U32Value;
                  break;
             case 0x6:
                  pctxt->Esi = pOperand->Op.Value.U32Value;
                  break;
             case 0x7:
                  pctxt->Edi = pOperand->Op.Value.U32Value;
                  break;
             }

        case RS:
             pctxt->EFlags = EFlags;
        break;
    }
    
}

/***
* ValidateResult -  Validate the emulation result with the MXCSR
*
*Purpose:
*   We are about to dismiss the exception, perform validation to
*   see if the processor agrees with our Emulation
*
*Entry:
*   XmmiFpEnv - pointer to the data about the exception.
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

BOOLEAN
ValidateResult(
    PXMMI_FP_ENV XmmiFpEnv)

{

    PXMMI_EXCEPTION_FLAGS IFlags;
    PXMMI_EXCEPTION_FLAGS OFlags;
    BOOLEAN Flag;

    Flag = FALSE;
    IFlags = (PXMMI_EXCEPTION_FLAGS) &XmmiFpEnv->IFlags;
    OFlags = (PXMMI_EXCEPTION_FLAGS) &XmmiFpEnv->OFlags;

/*    DPrint(XMMI_WARNING, ("Checking MXCSR Exception Flags\n"));  */
    if (IFlags->ie != OFlags->ie) {
/*        DPrint(XMMI_WARNING, ("ie: Processor %x, Emulator %x\n", IFlags->ie, OFlags->ie));  */
        Flag=TRUE;
    }

    if (IFlags->de != OFlags->de) {
/*        DPrint(XMMI_WARNING, ("de: Processor %x, Emulator %x\n", IFlags->de, OFlags->de)); */
        Flag=TRUE;
    }

    if (IFlags->ze != OFlags->ze) {
/*        DPrint(XMMI_WARNING, ("ze: Processor %x, Emulator %x\n", IFlags->ze, OFlags->ze));  */
        Flag=TRUE;
    }

    if (IFlags->oe != OFlags->oe) {
/*        DPrint(XMMI_WARNING, ("oe: Processor %x, Emulator %x\n", IFlags->oe, OFlags->oe));  */
        Flag=TRUE;
    }

    if (IFlags->ue != OFlags->ue) {
/*        DPrint(XMMI_WARNING, ("ue: Processor %x, Emulator %x\n", IFlags->ue, OFlags->ue));  */
        Flag=TRUE;
    }

    if (IFlags->pe != OFlags->pe) {
/*        DPrint(XMMI_WARNING, ("pe: Processor %x, Emulator %x\n", IFlags->pe, OFlags->pe));  */
        Flag=TRUE;
    }

    if (!Flag) {
/*        DPrint(XMMI_INFO, ("Validating MXCSR Exception Flags Ok, Prc:0x%x, Em:0x%x\n\n",  */
/*            XmmiFpEnv->IFlags, XmmiFpEnv->OFlags));  */
    }

    if (Flag) {
#ifdef _XMMI_DEBUG
        DPrint(XMMI_INFO, ("Validating MXCSR Exception Flags NotOk, Prc:0x%x, Em:0x%x\n\n", 
            XmmiFpEnv->IFlags, XmmiFpEnv->OFlags));  
        PRINTF(("WARNING: Validating MXCSR Exception Flags NotOk, Prc:0x%x, Em:0x%x\n",   
            XmmiFpEnv->IFlags, XmmiFpEnv->OFlags));  
#else
        _ASSERT(0);
#endif
    }

    return Flag;

}


/*
 *  mod r/m byte decoder support
 */

/*-----------------------------------------------------------------
 *  Routine:  ax0
 */
ULONG
ax0( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip )
{
    PRINTF(("ax0\n"));
    *DataOffset = GET_REG(Eax);
    return 0;

} /* End ax0(). */


/*-----------------------------------------------------------------
 *  Routine:  ax8
 */
ULONG
ax8( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip )
{
    PRINTF(("ax8\n"));
    *DataOffset = GET_REG(Eax) + GET_USER_UBYTE(eip);
    return 1;

} /* End ax8(). */


/*-----------------------------------------------------------------
 *  Routine:  ax32
 */
ULONG
ax32( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip )
{
    PRINTF(("ax32\n"));
    *DataOffset = GET_REG(Eax) + GET_USER_ULONG(eip);
    return 4;

} /* End ax32(). */


/*-----------------------------------------------------------------
 *  Routine:  cx0
 */
ULONG
cx0( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip )
{
    PRINTF(("cx0\n"));
    *DataOffset = GET_REG(Ecx);
    return 0;

} /* End cx0(). */


/*-----------------------------------------------------------------
 *  Routine:  cx8
 */
ULONG
cx8( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip )
{   
    PRINTF(("cx8\n"));
    *DataOffset = GET_REG(Ecx) + GET_USER_UBYTE(eip);
    return 1;

} /* End cx8(). */


/*-----------------------------------------------------------------
 *  Routine:  cx32
 */
ULONG
cx32( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip )
{
    
    PRINTF(("cx32\n"));
    *DataOffset = GET_REG(Ecx) + GET_USER_ULONG(eip);
    return 4;

} /* End cx32(). */


/*-----------------------------------------------------------------
 *  Routine:  dx0
 */
ULONG
dx0( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip )
{

    PRINTF(("dx0\n"));
    *DataOffset = GET_REG(Edx);
    return 0;

} /* End dx0(). */


/*-----------------------------------------------------------------
 *  Routine:  dx8
 */
ULONG
dx8( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip )
{

    PRINTF(("dx8\n"));
    *DataOffset = GET_REG(Edx) + GET_USER_UBYTE(eip);
    return 1;

} /* End dx8(). */


/*-----------------------------------------------------------------
 *  Routine:  dx32
 */
ULONG
dx32( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip )
{

    PRINTF(("dx32\n"));
    *DataOffset = GET_REG(Edx) + GET_USER_ULONG(eip);
    return 4;

} /* End dx32(). */

/*-----------------------------------------------------------------
 *  Routine:  bx0
 */
ULONG
bx0( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip )
{

    PRINTF(("bx0\n"));
    *DataOffset = GET_REG(Ebx);
    return 0;

} /* End bx0(). */


/*-----------------------------------------------------------------
 *  Routine:  bx8
 */
ULONG
bx8( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip )
{

    PRINTF(("bx8\n"));
    *DataOffset = GET_REG(Ebx) + GET_USER_UBYTE(eip);
    return 1;

} /* End bx8(). */


/*-----------------------------------------------------------------
 *  Routine:  bx32
 */
ULONG
bx32( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip )
{

    PRINTF(("bx32\n"));
    *DataOffset = GET_REG(Ebx) + GET_USER_ULONG(eip);
    return 4;

} /* End bx32(). */


/*
 *  A "mod r/m" byte indicates an s-i-b byte is present.  Assume the register
 *  from the mod r/m byte is not relevant (does not participate in a memory
 *  reference) and calculate the EA based on the s-i-b byte.
 */
/* SS  | Index | Base */
/* 7-6 |  5-3  |  2-0 */
/* Base: EAX ECX EDX EBX ESP EBP ESI EDI */
/*       000 001 010 011 100 101 110 111 */
/* SS: Index:    
/* 00   000      [EAX]         
/*      001      [ECX]         
/*      010      [EDX]         
/*      011      [EBX]         
/*      100      none         
/*      101      [EBP]        
/*      110      [ESI]         
/*      111      [EDI]         
/* 01   000      [EAX*2]    
/*      001      [ECX*2]    
/*      010      [EDX*2]    
/*      011      [EBX*2]    
/*      100      none     
/*      101      [EBP*2]    
/*      110      [ESI*2]   
/*      111      [EDI*2]   
/* 10   000      [EAX*4]    
/*      001      [ECX*4]    
/*      010      [EDX*4]    
/*      011      [EBX*4]    
/*      100      none     
/*      101      [EBP*4]    
/*      110      [ESI*4]   
/*      111      [EDI*4]   
/* 11   000      [EAX*8]    
/*      001      [ECX*8]    
/*      010      [EDX*8]    
/*      011      [EBX*8]    
/*      100      none     
/*      101      [EBP*8]    
/*      110      [ESI*8]   
/*      111      [EDI*8]   
/*Note: Mod=00, no base, Mod=01/10, base is EBP

/*-----------------------------------------------------------------
 *  Routine:  sib0
 */
ULONG
sib0( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip )
{

    ULONG sib = GET_USER_UBYTE(eip);
    ULONG scale;
    ULONG index;

    PRINTF(("sib0\n"));

    //(Base+Index*Scale)+disp0
    //Get ss: scaled as *1 (00), *2 (01), *4 (10), *8 (11)
    scale = 1 << (sib >> 6);
    //Get index: 000-111
    index = ((sib >> 3)&0x7);
    if (index == ESP_INDEX) {
        index = 0;
    } else {
        //index=GET_REG(index), upon return, index has the value of the register
        GET_REG_VIA_NDX(index, index);
    }
    //Get base: 000-111
    sib = (sib & 0x7);
    //mod=00, there is no base.
    if (sib == EBP_INDEX) {
        *DataOffset = GET_USER_ULONG(eip + 1) + index*scale;
        return 5;
    }

    if (sib == ESP_INDEX) {
        *DataOffset = GET_REG(Esp) + index*scale;
    } else {
        GET_REG_VIA_NDX(*DataOffset, sib);
        *DataOffset += index*scale;
    }
    return 1;

} /* End sib0(). */


/*-----------------------------------------------------------------
 *  Routine:  sib8
 */
ULONG
sib8( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip )
{

    ULONG sib = GET_USER_UBYTE(eip);
    ULONG scale;
    ULONG index;

    PRINTF(("sib8\n"));

    //(Base+Index*Scale)+disp8
    //Get ss: scaled as *1 (00), *2 (01), *4 (10), *8 (11)
    scale = 1 << (sib >> 6);
    //Get index: 000-111
    index = ((sib >> 3)&0x7);
    if (index == ESP_INDEX) {
        index = 0;
    } else {
        GET_REG_VIA_NDX(index, index);
    }
    //Get base: 000-111
    sib = (sib & 0x7);
    if (sib == ESP_INDEX) {
        *DataOffset = GET_USER_UBYTE(eip + 1) + GET_REG(Esp) + index*scale;
    } else {
        GET_REG_VIA_NDX(*DataOffset, sib);
        *DataOffset += GET_USER_UBYTE(eip + 1) + index*scale;
    }
    return 2;

} /* End sib8(). */


/*-----------------------------------------------------------------
 *  Routine:  sib32
 */
ULONG
sib32( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip )
{

    ULONG sib = GET_USER_UBYTE(eip);
    ULONG scale;
    ULONG index;

    PRINTF(("sib32\n"));

    //(Base+Index*Scale)+disp32
    //Get ss: scaled as *1 (00), *2 (01), *4 (10), *8 (11)
    scale = 1 << (sib >> 6);
    index =((sib >> 3)&0x7);
    //Get index: 000-111
    if (index == ESP_INDEX) {
        index = 0;
    } else {
        GET_REG_VIA_NDX(index, index);
    }
    //Get base: 000-111
    sib = (sib & 0x7);
    if (sib == ESP_INDEX) {
        *DataOffset = GET_USER_ULONG(eip + 1) + GET_REG(Esp) + index*scale;
    } else {
        GET_REG_VIA_NDX(*DataOffset, sib);
        *DataOffset += GET_USER_ULONG(eip + 1) + index*scale;
    }
    return 5;

} /* End sib32(). */

/*-----------------------------------------------------------------
 *  Routine:  d32
 */
ULONG
d32( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip )
{

    PRINTF(("d32\n"));

    *DataOffset = GET_USER_ULONG(eip);
    return 4;

} /* End d32(). */

/*-----------------------------------------------------------------
 *  Routine:  bp8
 */
ULONG
bp8( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip )
{

    PRINTF(("bp8%x\n"));

    *DataOffset = GET_REG(Ebp) + GET_USER_UBYTE(eip);
    return 1;

} /* End bp8(). */


/*-----------------------------------------------------------------
 *  Routine:  bp32
 */
ULONG
bp32( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip )
{

    PRINTF(("bp32\n"));

    *DataOffset = GET_REG(Ebp) + GET_USER_ULONG(eip);
    return 4;

} /* End bp32(). */

/*-----------------------------------------------------------------
 *  Routine:  si0
 */
ULONG
si0( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip )
{

    PRINTF(("si0\n"));

    *DataOffset = GET_REG(Esi);
    return 0;

} /* End si0(). */


/*-----------------------------------------------------------------
 *  Routine:  si8
 */
ULONG
si8( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip )
{

    PRINTF(("si8\n"));

    *DataOffset = GET_REG(Esi) + GET_USER_UBYTE(eip);
    return 1;

} /* End si8(). */


/*-----------------------------------------------------------------
 *  Routine:  si32
 */
ULONG
si32( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip )
{

    PRINTF(("si32\n"));

    *DataOffset = GET_REG(Esi) + GET_USER_ULONG(eip);
    return 4;

} /* End si32(). */

/*-----------------------------------------------------------------
 *  Routine:  di0
 */
ULONG
di0( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip )
{

    PRINTF(("di0\n"));

    *DataOffset = GET_REG(Edi);
    return 0;

} /* End di0(). */


/*-----------------------------------------------------------------
 *  Routine:  di8
 */
ULONG
di8( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip )
{

    PRINTF(("di8%x\n"));

    *DataOffset = GET_REG(Edi) + GET_USER_UBYTE(eip);
    return 1;

} /* End di8(). */

/*-----------------------------------------------------------------
 *  Routine:  di32
 */
ULONG
di32( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip )
{

    PRINTF(("di32%x\n"));

    *DataOffset = GET_REG(Edi) + GET_USER_ULONG(eip);
    return 4;

} /* End di32(). */


/*-----------------------------------------------------------------
 *  Routine:  reg
 */
ULONG
reg( PULONG DataOffset, PTEMP_CONTEXT pctxt, ULONG eip )
{

    PRINTF(("reg, should never be called\n"));

    return 0;

} /* End reg(). */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\i386\filter.h ===
/***
* filter.h - IEEE exception filter routine
*
*       Copyright (c) 1992-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*
*Revision History:
*       05-24-92  GDP   written
*       09-01-94  SKS   Change include file from <nt.h> to <windows.h>
*       01-11-95  GJF   Made instr_info_table[] static.
*       02-07-95  CFW   assert -> _ASSERTE.
*       04-07-95  SKS   Clean up prototype of param3 to _fpieee_flt()
*       03-01-98  PLS   move the definitions from filter.c to filter.h, so
*                       filter_simd.c can use it.
*******************************************************************************/


//
// Location codes
//
//
// By convention the first eight location codes contain the number of
// a floating point register, i.e., ST0 through ST7 have the values
// 0 to 7 respectively. The other codes have arbitrary values:
//
//  CODE    MEANING
//   STi    (0<=i<8) Floating point stack location ST(i)
//   REG    FP stack location is in the REG field of the instruction
//   RS     FP status register
//   M16I   Memory location (16bit int)
//   M32I   Memory location (32bit int)
//   M64I   Memory location (64bit int)
//   M32R   Memory location (32bit real)
//   M64R   Memory location (64bit real)
//   M80R   Memory location (80bit real)
//   M80D   Memory location (80bit packed decimal)
//   Z80R   Implied Zero Operand
//   M128R_M32R  Memory location (128bit memory location, 32bit real)
//   M128R_M64R  Memory location (128bit memory location, 64bit real) 
//   MMX    64-bit multimedia register
//   XMMI   128-bit multimedia register
//   IMM8   immedidate 8-bit operand
//   INV    Invalid, unavailable, or unused
//

#define ST0         0x00
#define ST1         0x01
#define ST2         0x02
#define ST3         0x03
#define ST4         0x04
#define ST5         0x05
#define ST6         0x06
#define ST7         0x07
#define REG         0x08
#define RS          0x09
#define M16I        0x0a
#define M32I        0x0b
#define M64I        0x0c
#define M32R        0x0d
#define M64R        0x0e
#define M80R        0x0f
#define M80D        0x10
#define Z80R        0x11
#define M128_M32R   0x12 //Xmmi
#define M128_M64R   0x13 //Xmmi
#define MMX         0x14 //Xmmi
#define XMMI        0x15 //Xmmi
#define IMM8        0x16 //Xmmi
#define XMMI2       0x17 //Xmmi2
#define M64R_64     0x19 //Xmmi2
#define M128_M32I   0x1a //Xmmi2
#define XMMI_M32I   0x1b //Xmmi2
#define LOOKUP      0x1e //Xmmi2
#define INV         0x1f
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\i386\filter.c ===
/***
* filter.c - IEEE exception filter routine
*
*       Copyright (c) 1992-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*
*Revision History:
*       05-24-92  GDP   written
*       09-01-94  SKS   Change include file from <nt.h> to <windows.h>
*       01-11-95  GJF   Made instr_info_table[] static.
*       02-07-95  CFW   assert -> _ASSERTE.
*       04-07-95  SKS   Clean up prototype of param3 to _fpieee_flt()
*       05-21-98  JWM   FP regs now saved/restored in logical, not physical,
*                       order
*       09-11-98  JWM   Katmai support added
*       10-11-99  PML   Protect against corrupting stack frames (vs7#6472)
*       10-15-99  PML   Pop register file, not just change Top ptr (vs7#5422)
*       11-30-99  PML   Compile /Wp64 clean.
*       04-24-00  PML   _fninit before handling SIMD exceptions (vs7#91746)
*
*******************************************************************************/

#include <trans.h>
#include <windows.h>
#include <dbgint.h>
#include "filter.h"

#pragma warning(disable:4311 4312)      // x86 specific, ignore /Wp64 warnings

void _FillOperand(
    _FPIEEE_VALUE *pOperand,
    PFLOATING_SAVE_AREA pFloatSave,
    int location);

void _UpdateFpCtxt(
    PFLOATING_SAVE_AREA pFloatSave,
    _FPIEEE_VALUE *pOperand,
    int resultLocation,
    int pop);

void _UpdateResult(
    PFLOATING_SAVE_AREA pFloatSave,
    _FPIEEE_VALUE *pOperand,
    int resultLocation);

void _AdjustStack(
    PFLOATING_SAVE_AREA pFloatSave,
    int pop);

int _AdjustLocation(
    int location,
    int pop);

int _PreventStackOverwrite(
    PCONTEXT pctxt,
    int location);

int _IsMemoryLocation(int location);

_FP80 _GetFpRegVal(
    PFLOATING_SAVE_AREA pFloatSave,
    int location);

void _SetFpRegVal(
    PFLOATING_SAVE_AREA pFloatSave,
    int location,
    _FP80 *pval);

void _SetTag(
    ULONG *pTagWord,
    int reg,
    int value);

static _FP80 _zero80 = { 0, 0, 0, 0, 0 };



//
// Define macros for IEEE scaling
// These should be called with all exceptions masked
//


#define SCALE(Operand, adj)          \
    _asm{fild   adj}                 \
    _asm{fld    tbyte ptr Operand}   \
    _asm{fscale}                     \
    _asm{fstp   st(1)}               \
    _asm{fstp   tbyte ptr Operand}



#define FP80_TO_FP64(p64, p80)  \
    _asm{fld    tbyte ptr p80}  \
    _asm{fstp   qword ptr p64}


#define FP80_TO_FP32(p32, p80)  \
    _asm {fld   tbyte ptr p80}  \
    _asm{fstp   dword ptr p32}


static int const _ieee_adj_single = 192;
static int const _ieee_adj_double = 1536;


//
// Define masks for instruction decoding
// x87 instruction form:
//    -------------------------------------------------
//    |      |          |   op  |            |        |
//    | MOD  | OPCODE2  | or REG| 1 1 0 1 1  | OPCODE1|
//    |or op |          | or R/M|  (ESC)     |        |
//    -------------------------------------------------
//    |<-2-->|<---3---->|<--3-->|<---5------>|<--3--->|

#define MASK_OPCODE2    0x3800
#define MASK_REG        0x0700
#define MASK_MOD        0xc000


#define ESC_PREFIX      0xd8
#define MASK_OPCODE1    0x07


typedef struct {
    ULONG   Opcode1:3;
    ULONG   Escape:5;
    ULONG   Reg:3;
    ULONG   Opcode2:3;
    ULONG   Mod:2;
    ULONG   Pad:16;
} X87INSTR, *PX87INSTR;


// define masks for C3,C2,C0 in fp status word

#define C3  (1 << 14)
#define C2  (1 << 10)
#define C0  (1 << 8)

typedef struct {
    ULONG Invalid:1;
    ULONG Denormal:1;
    ULONG ZeroDivide:1;
    ULONG Overflow:1;
    ULONG Underflow:1;
    ULONG Inexact:1;
    ULONG StackFault:1;
    ULONG ErrorSummary:1;
    ULONG CC0:1;
    ULONG CC1:1;
    ULONG CC2:1;
    ULONG Top:3;
    ULONG CC3:1;
    ULONG B:1;
    ULONG Pad:16;
} X87STATUS, *PX87STATUS;


//
// Define Tag word values
//

#define TAG_VALID       0x0
#define TAG_ZERO        0x1
#define TAG_SPECIAL     0x2
#define TAG_EMPTY       0x3



// Sanitize status word macro

#define SANITIZE_STATUS_WORD(pFSave) (pFSave->StatusWord &= ~0xff)




//
// Instruction Information structure
//

typedef struct {
    unsigned long Operation:12;       // Fp Operation code
    unsigned long Op1Location:5;      // Location of 1st operand
    unsigned long Op2Location:5;      // Location of 2nd operand
    unsigned long ResultLocation:5;   // Location of result
    int           PopStack:3;         // # of pops done by the instruction
                                      // (if <0 implies a push)
    unsigned long NumArgs:2;          // # of args to the instruction
} INSTR_INFO, *PINSTR_INFO;


//
// The following table contains instruction information for most
// of the x87 instructions. It is indexed with a 7-bit code (3 last
// bits of 1st byte of the instruction (OPCODE1), 1 bit that
// indicates the presence of a MOD field and 3 bits for OPCODE2.
// Reserved instructions, instructions that are not generated by the
// compiler, and some of the instructions that do not raise IEEE
// exceptions have OP_UNSPEC (unspecified) as Operation code
//

//  By convention FLD instructions and some others (FXTRACT, FSINCOS)
//  have a negative pop value (i.e., they push the stack instead of
//  popping it). In that case the location code specifies the register
//  number after pushing the stack


static INSTR_INFO instr_info_table[128] = {

 {OP_ADD,   ST0,  M32R, ST0,   0, 2 }, // FADD  single real
 {OP_MUL,   ST0,  M32R, ST0,   0, 2 }, // FMUL  single real
 {OP_COMP,  ST0,  M32R, RS,    0, 2 }, // FCOM  single real
 {OP_COMP,  ST0,  M32R, RS,    1, 2 }, // FCOMP single real
 {OP_SUB,   ST0,  M32R, ST0,   0, 2 }, // FSUB  single real
 {OP_SUB,   M32R, ST0,  ST0,   0, 2 }, // FSUBR single real
 {OP_DIV,   ST0,  M32R, ST0,   0, 2 }, // FDIV  single real
 {OP_DIV,   M32R, ST0,  ST0,   0, 2 }, // FDIVR single real

 {OP_ADD,   ST0,  REG,  ST0,   0, 2 }, // FADD  ST, ST(i)
 {OP_MUL,   ST0,  REG,  ST0,   0, 2 }, // FMUL  ST, ST(i)
 {OP_COMP,  ST0,  REG,  RS,    0, 2 }, // FCOM  ST, ST(i)
 {OP_COMP,  ST0,  REG,  RS,    1, 2 }, // FCOMP ST, ST(i)
 {OP_SUB,   ST0,  REG,  ST0,   0, 2 }, // FSUB  ST, ST(i)
 {OP_SUB,   ST0,  REG,  ST0,   0, 2 }, // FSUBR ST, ST(i)
 {OP_DIV,   ST0,  REG,  ST0,   0, 2 }, // FDIV  ST, ST(i)
 {OP_DIV,   ST0,  REG,  ST0,   0, 2 }, // FDIVR ST, ST(i)

 {OP_CVT,   M32R, INV,  ST0,  -1, 1 }, // FLD   single real
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // reserved
 {OP_CVT,   ST0,  INV,  M32R,  0, 1 }, // FST   single real
 {OP_CVT,   ST0,  INV,  M32R,  1, 1 }, // FSTP  single real
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // FLDENV
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // FLDCW
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // FSTENV
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // FSTCW

 {OP_CVT,   REG,  INV,  ST0,  -1, 1 }, // FLD   ST(i)
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // FXCH
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // FNOP or reserved
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // reserved
 {OP_COMP,  ST0,  Z80R, RS,    0, 2 }, // FTST (only this may raise IEEE exc)
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // FLDxx (no IEEE exceptions)
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // instructions not generated by cl386
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // instructions not generated by cl386

 {OP_ADD,   ST0,  M32I, ST0,   0, 2 }, // FIADD  short integer
 {OP_MUL,   ST0,  M32I, ST0,   0, 2 }, // FIMUL  short integer
 {OP_COMP,  ST0,  M32I, RS,    0, 2 }, // FICOM  short integer
 {OP_COMP,  ST0,  M32I, RS,    1, 2 }, // FICOMP short integer
 {OP_SUB,   ST0,  M32I, ST0,   0, 2 }, // FISUB  short integer
 {OP_SUB,   M32I, ST0,  ST0,   0, 2 }, // FISUBR short integer
 {OP_DIV,   ST0,  M32I, ST0,   0, 2 }, // FIDIV  short integer
 {OP_DIV,   M32I, ST0,  ST0,   0, 2 }, // FIDIVR short integer

 {OP_UNSPEC,0,    0,    0,     0, 0 }, // reserved
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // reserved
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // reserved
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // reserved
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // reserved
 {OP_COMP,  ST0,  ST1,  RS,    2, 2 }, // FUCOMPP
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // reserved
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // reserved

 {OP_CVT,   M32I, INV,  ST0,  -1, 1 }, // FILD  short integer
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // reserved
 {OP_CVT,   ST0,  INV,  M32I,  0, 1 }, // FIST  short integer
 {OP_CVT,   ST0,  INV,  M32I,  1, 1 }, // FISTP short integer
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // reserved
 {OP_CVT,   M80R, INV,  ST0,  -1, 1 }, // FLD   extended real
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // reserved
 {OP_CVT,   ST0,  INV,  M80R,  1, 1 }, // FSTP  extended real

 {OP_UNSPEC,0,    0,    0,     0, 0 }, // reserved
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // reserved
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // reserved
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // reserved
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // FCLEX, FINIT, or reserved
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // reserved
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // reserved
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // reserved

 {OP_ADD,   ST0,  M64R, ST0,   0, 2 }, // FADD  double real
 {OP_MUL,   ST0,  M64R, ST0,   0, 2 }, // FMUL  double real
 {OP_COMP,  ST0,  M64R, RS,    0, 2 }, // FCOM  double real
 {OP_COMP,  ST0,  M64R, RS,    1, 2 }, // FCOMP double real
 {OP_SUB,   ST0,  M64R, ST0,   0, 2 }, // FSUB  double real
 {OP_SUB,   M64R, ST0,  ST0,   0, 2 }, // FSUBR double real
 {OP_DIV,   ST0,  M64R, ST0,   0, 2 }, // FDIV  double real
 {OP_DIV,   M64R, ST0,  ST0,   0, 2 }, // FDIVR double real

 {OP_ADD,   REG,  ST0,  REG,   0, 2 }, // FADD  ST(i), ST
 {OP_MUL,   REG,  ST0,  REG,   0, 2 }, // FMUL  ST(i), ST
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // reserved
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // reserved
 {OP_SUB,   REG,  ST0,  REG,   0, 2 }, // FSUBR ST(i), ST
 {OP_SUB,   ST0,  REG,  REG,   0, 2 }, // FSUB  ST(i), ST
 {OP_DIV,   REG,  ST0,  REG,   0, 2 }, // FDIVR ST(i), ST
 {OP_DIV,   ST0,  REG,  REG,   0, 2 }, // FDIV  ST(i), ST

 {OP_CVT,   M64R, INV,  ST0,  -1, 1 }, // FLD   double real
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // reserved
 {OP_CVT,   ST0,  INV,  M64R,  0, 1 }, // FST   double real
 {OP_CVT,   ST0,  INV,  M64R,  1, 1 }, // FSTP  double real
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // FRSTOR
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // reserved
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // FSAVE
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // FSTSW

 {OP_UNSPEC,0,    0,    0,     0, 0 }, // FFREE ST(i)
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // reserved
 {OP_CVT,   ST0,  INV,  REG,   0, 1 }, // FST   ST(i)
 {OP_CVT,   ST0,  INV,  REG,   1, 1 }, // FSTP  ST(i)
 {OP_COMP,  ST0,  REG,  RS,    0, 2 }, // FUCOM ST(i)
 {OP_COMP,  ST0,  REG,  RS,    1, 2 }, // FUCOMP ST(i)
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // reserved
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // reserved

 {OP_ADD,   ST0,  M16I, ST0,   0, 2 }, // FIADD  word integer
 {OP_MUL,   ST0,  M16I, ST0,   0, 2 }, // FIMUL  word integer
 {OP_COMP,  ST0,  M16I, RS,    0, 2 }, // FICOM  word integer
 {OP_COMP,  ST0,  M16I, RS,    1, 2 }, // FICOMP word integer
 {OP_SUB,   ST0,  M16I, ST0,   0, 2 }, // FISUB  word integer
 {OP_SUB,   M16I, ST0,  ST0,   0, 2 }, // FISUBR word integer
 {OP_DIV,   ST0,  M16I, ST0,   0, 2 }, // FIDIV  word integer
 {OP_DIV,   M16I, ST0,  ST0,   0, 2 }, // FIDIVR word integer

 {OP_ADD,   REG,  ST0,  REG,   1, 2 }, // FADDP  ST(i), ST
 {OP_MUL,   REG,  ST0,  REG,   1, 2 }, // FMULP  ST(i), ST
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // reserved
 {OP_COMP,  ST0,  ST1,  RS,    2, 0 }, // FCOMPP (or reserved)
 {OP_SUB,   REG,  ST0,  REG,   1, 2 }, // FSUBRP ST(i), ST
 {OP_SUB,   ST0,  REG,  REG,   1, 2 }, // FSUBP  ST(i), ST
 {OP_DIV,   REG,  ST0,  REG,   1, 2 }, // FDIVRP ST(i), ST
 {OP_DIV,   ST0,  REG,  REG,   1, 2 }, // FDIVP  ST(i), ST

 {OP_CVT,   M16I, INV,  ST0,  -1, 1 }, // FILD  word integer
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // reserved
 {OP_CVT,   ST0,  INV,  M16I,  0, 1 }, // FIST  word integer
 {OP_CVT,   ST0,  INV,  M16I,  1, 1 }, // FISTP word integer
 {OP_CVT,   M80D, INV,  ST0,  -1, 0 }, // FBLD  packed decimal
 {OP_CVT,   M64I, INV,  ST0,  -1, 1 }, // FILD  long integer
 {OP_CVT,   ST0,  INV,  M80D,  1, 1 }, // FBSTP packed decimal
 {OP_CVT,   ST0,  INV,  M64I,  1, 1 }, // FISTP long integer

 {OP_UNSPEC,0,    0,    0,     0, 0 }, // reserved
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // reserved
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // reserved
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // reserved
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // FSTSW AX or reserved
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // reserved
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // reserved
 {OP_UNSPEC,0,    0,    0,     0, 0 }, // reserved
};



extern int fpieee_flt_simd(unsigned long exc_code, PEXCEPTION_POINTERS p,
           int (__cdecl *handler) (_FPIEEE_RECORD *));



/***
* _fpieee_flt - IEEE fp filter routine
*
*Purpose:
*   Invokes the user's trap handler on IEEE fp exceptions and provides
*   it with all necessary information
*
*Entry:
*   unsigned long exc_code: the NT exception code
*   PEXCEPTION_POINTERS p: a pointer to the NT EXCEPTION_POINTERS struct
*   int handler (_FPIEEE_RECORD *): a user supplied ieee trap handler
*
*   Note: The IEEE filter routine does not handle some transcendental
*   instructions. This can be done at the cost of additional decoding.
*   Since the compiler does not generate these instructions, no portable
*   program should be affected by this fact.
*
*Exit:
*   returns the value returned by handler
*
*Exceptions:
*
*******************************************************************************/
int _fpieee_flt(unsigned long exc_code,
                PEXCEPTION_POINTERS p,
                int (__cdecl *handler) (_FPIEEE_RECORD *))
{
    PEXCEPTION_RECORD pexc;
    PCONTEXT pctxt;
    PFLOATING_SAVE_AREA pFloatSave;
    _FPIEEE_RECORD ieee;
    ULONG *pinfo;
    X87INSTR instr;
    PINSTR_INFO ptable;
    int ret, index;
    int mod;
    ULONG cw, sw;

    ULONG op1Location, op2Location, resultLocation;
    ULONG newOp1Location, newOp2Location, newResultLocation;



    //
    // If the exception is not an IEEE exception, continue search
    // for another handler
    //


    if (exc_code != STATUS_FLOAT_DIVIDE_BY_ZERO &&
        exc_code != STATUS_FLOAT_INEXACT_RESULT &&
        exc_code != STATUS_FLOAT_INVALID_OPERATION &&
        exc_code != STATUS_FLOAT_OVERFLOW &&
        exc_code != STATUS_FLOAT_UNDERFLOW &&
        exc_code != STATUS_FLOAT_MULTIPLE_FAULTS &&
        exc_code != STATUS_FLOAT_MULTIPLE_TRAPS) {

        return EXCEPTION_CONTINUE_SEARCH;
    }

    _asm{fninit}

    /* Handle Katmai exceptions separately */
    if (exc_code == STATUS_FLOAT_MULTIPLE_FAULTS ||
        exc_code == STATUS_FLOAT_MULTIPLE_TRAPS) {
        return fpieee_flt_simd(exc_code, p, handler);
    }


    pexc = p->ExceptionRecord;
    pinfo = pexc->ExceptionInformation;
    pctxt = p->ContextRecord;
    pFloatSave = &pctxt->FloatSave;



    //
    // Check for software generated exception
    //
    // By convention the first argument to the exception is
    // 0 for h/w exception. For s/w exceptions it points
    // to the _FPIEEE_RECORD
    //

    if (pinfo[0]) {

        /*
         * we have a software exception:
         * the first parameter points to the IEEE structure
         */

        if ((ret = handler((_FPIEEE_RECORD *)(pinfo[0]))) ==
             EXCEPTION_CONTINUE_EXECUTION) {

            //
            // Sanitize status word only if there is continuation
            //

            SANITIZE_STATUS_WORD(pFloatSave);
        }

        return ret;
    }


    //
    // If control reaches here, then we have to deal with a
    // hardware exception
    //


    //
    // If the first byte of the instruction does not contain
    // the ESCAPE bit pattern (1101) there may be an instruction
    // prefix for segment override or address size. The filter
    // routine does not handle this.
    //

    if ((*(UCHAR *)(pFloatSave->ErrorOffset)&~MASK_OPCODE1) != ESC_PREFIX) {

        _ASSERT(0);
        return EXCEPTION_CONTINUE_SEARCH;
    }

    *(USHORT *)&instr = *(USHORT *)(pFloatSave->ErrorOffset);

    mod = instr.Mod == 0x3 ? 1 : 0;
    index = instr.Opcode1 << 4 | mod << 3 | instr.Opcode2;
    ptable = instr_info_table + index;

    ieee.Operation = ptable->Operation;


    cw = pFloatSave->ControlWord;
    sw = pFloatSave->StatusWord;



    //
    // decode fp environment information
    //


    switch (cw & IMCW_RC) {
    case IRC_NEAR:
        ieee.RoundingMode = _FpRoundNearest;
        break;

    case IRC_DOWN:
        ieee.RoundingMode = _FpRoundMinusInfinity;
        break;

    case IRC_UP:
        ieee.RoundingMode = _FpRoundPlusInfinity;
        break;

    case IRC_CHOP:
        ieee.RoundingMode = _FpRoundChopped;
        break;
    }

    switch (cw & IMCW_PC) {
    case IPC_64:
        ieee.Precision = _FpPrecisionFull;
        break;
    case IPC_53:
        ieee.Precision = _FpPrecision53;
        break;
    case IPC_24:
        ieee.Precision = _FpPrecision24;
        break;
    }

    ieee.Enable.Inexact = cw & IEM_INEXACT ? 0 : 1;
    ieee.Enable.Underflow = cw & IEM_UNDERFLOW ? 0 : 1;
    ieee.Enable.Overflow = cw & IEM_OVERFLOW ? 0 : 1;
    ieee.Enable.ZeroDivide = cw & IEM_ZERODIVIDE ? 0 : 1;
    ieee.Enable.InvalidOperation = cw & IEM_INVALID ? 0 : 1;

    ieee.Status.Inexact = sw & ISW_INEXACT ? 1 : 0;
    ieee.Status.Underflow = sw & ISW_UNDERFLOW ? 1 : 0;
    ieee.Status.Overflow = sw & ISW_OVERFLOW ? 1 : 0;
    ieee.Status.ZeroDivide = sw & ISW_ZERODIVIDE ? 1 : 0;
    ieee.Status.InvalidOperation = sw & ISW_INVALID ? 1 : 0;

    ieee.Cause.Inexact = ieee.Enable.Inexact && ieee.Status.Inexact;
    ieee.Cause.Underflow = ieee.Enable.Underflow && ieee.Status.Underflow;
    ieee.Cause.Overflow = ieee.Enable.Overflow && ieee.Status.Overflow;
    ieee.Cause.ZeroDivide = ieee.Enable.ZeroDivide && ieee.Status.ZeroDivide;
    ieee.Cause.InvalidOperation = ieee.Enable.InvalidOperation && ieee.Status.InvalidOperation;

    //
    // If location is REG, the register number is
    // encoded in the instruction
    //

    op1Location = ptable->Op1Location == REG ?
                  instr.Reg :
                  ptable->Op1Location;


    op2Location = ptable->Op2Location == REG ?
                  instr.Reg :
                  ptable->Op2Location;

    resultLocation = ptable->ResultLocation == REG ?
                  instr.Reg :
                  ptable->ResultLocation;


    switch (exc_code) {
    case STATUS_FLOAT_INVALID_OPERATION:
    case STATUS_FLOAT_DIVIDE_BY_ZERO:

        //
        // Invalid Operation and Divide by zero are detected
        // before the operation begins; therefore the NPX
        // register stack and memory have not been updated
        //

        _FillOperand(&ieee.Operand1, pFloatSave, op1Location);
        _FillOperand(&ieee.Operand2, pFloatSave, op2Location);

        _FillOperand(&ieee.Result, pFloatSave, resultLocation);

        //
        // The previous call was only good for setting the
        // result Format. Since the
        // operation has not begun yet, the result location
        // may contain an incorrect value.
        // For this reason, set OperandValid to 0
        //

        ieee.Result.OperandValid = 0;


        if ((ret = handler (&ieee)) == EXCEPTION_CONTINUE_EXECUTION) {

            resultLocation = _PreventStackOverwrite(pctxt,
                                                    resultLocation);

            _UpdateFpCtxt(pFloatSave,
                          &ieee.Result,
                          resultLocation,
                          ptable->PopStack);
        }

        break;


    case STATUS_FLOAT_OVERFLOW:
    case STATUS_FLOAT_UNDERFLOW:

        //
        // Overflow and Underflow exception
        // A result has already been computed and the stack has
        // been adjusted, unless the destination is memory (FST instruction)
        //

        if (_IsMemoryLocation(ptable->ResultLocation)) {
            _FP80 tmp;
            _FP32 ftmp;
            _FP64 dtmp;

            int adj;

            //
            // FST(P) instruction (takes only one argument)
            //

            _FillOperand(&ieee.Operand1, pFloatSave, op1Location);
            tmp = _GetFpRegVal(pFloatSave, 0);

            ieee.Result.OperandValid = 1;

            if (resultLocation == M32R) {
                ieee.Result.Format = _FpFormatFp32;
                adj = _ieee_adj_single;
            }
            else {
                ieee.Result.Format = _FpFormatFp64;
                adj = _ieee_adj_double;
            }

            if (exc_code == STATUS_FLOAT_OVERFLOW) {
                adj = -adj;
            }

            SCALE(tmp, adj)

            if (resultLocation == M32R){
                FP80_TO_FP32(ftmp,tmp)
                ieee.Result.Value.Fp32Value = ftmp;
            }
            else {
                FP80_TO_FP64(dtmp,tmp)
                ieee.Result.Value.Fp64Value = dtmp;
            }
            _asm{fnclex}


            if ((ret = handler (&ieee)) == EXCEPTION_CONTINUE_EXECUTION) {

                resultLocation = _PreventStackOverwrite(pctxt,
                                                        resultLocation);

                _UpdateFpCtxt(pFloatSave,
                              &ieee.Result,
                              resultLocation,
                              ptable->PopStack);
            }

            break;
        }


        // NO BREAK

    case STATUS_FLOAT_INEXACT_RESULT:

        //
        // Stack has already been adjusted, so we should compute
        // the new location of operands and result
        //


        newOp1Location = _AdjustLocation(op1Location, ptable->PopStack);
        newOp2Location = _AdjustLocation(op2Location, ptable->PopStack);
        newResultLocation = _AdjustLocation(resultLocation, ptable->PopStack);

        if (newOp1Location == newResultLocation)
            newOp1Location = INV;

        if (newOp2Location == newResultLocation)
            newOp2Location = INV;

        _FillOperand(&ieee.Result, pFloatSave, newResultLocation);
        _FillOperand(&ieee.Operand1, pFloatSave, newOp1Location);
        _FillOperand(&ieee.Operand2, pFloatSave, newOp2Location);


        if ((ret = handler (&ieee)) == EXCEPTION_CONTINUE_EXECUTION) {

            newResultLocation = _PreventStackOverwrite(pctxt,
                                                       newResultLocation);

            _UpdateFpCtxt(pFloatSave,
                          &ieee.Result,
                          newResultLocation,
                          0);

            //
            // no need to adjust the stack
            //
        }

        break;
    }

    if (ret == EXCEPTION_CONTINUE_EXECUTION) {


        SANITIZE_STATUS_WORD(pFloatSave);


        //
        // make fp control word changes take effect on continuation
        //

        cw = pFloatSave->ControlWord;

        switch (ieee.RoundingMode) {
        case _FpRoundNearest:
            cw = cw & ~ IMCW_RC | IRC_NEAR & IMCW_RC;
            break;
        case _FpRoundMinusInfinity:
            cw = cw & ~ IMCW_RC | IRC_DOWN & IMCW_RC;
            break;
        case _FpRoundPlusInfinity:
            cw = cw & ~ IMCW_RC | IRC_UP & IMCW_RC;
            break;
        case _FpRoundChopped:
            cw = cw & ~ IMCW_RC | IRC_CHOP & IMCW_RC;
            break;
        }
        switch (ieee.Precision) {
        case _FpPrecisionFull:
            cw = cw & ~ IMCW_PC | IPC_64 & IMCW_PC;
            break;
        case _FpPrecision53:
            cw = cw & ~ IMCW_PC | IPC_53 & IMCW_PC;
            break;
        case _FpPrecision24:
            cw = cw & ~ IMCW_PC | IPC_24 & IMCW_PC;
            break;
        }

        ieee.Enable.Inexact ? (cw &= ~IEM_INEXACT)
                    : (cw |= IEM_INEXACT);
        ieee.Enable.Underflow ? (cw &= ~IEM_UNDERFLOW)
                    : (cw |= IEM_UNDERFLOW);
        ieee.Enable.Overflow ? (cw &= ~IEM_OVERFLOW)
                   : (cw |= IEM_OVERFLOW);
        ieee.Enable.ZeroDivide ? (cw &= ~IEM_ZERODIVIDE)
                     : (cw |= IEM_ZERODIVIDE);
        ieee.Enable.InvalidOperation ? (cw &= ~IEM_INVALID)
                           : (cw |= IEM_INVALID);

        pFloatSave->ControlWord = cw;


    }


    return ret;
}





/***
* _FillOperand - Fill in operand information
*
*Purpose:
*   Fill in a _FPIEEE_VALUE record based on the information found in
*   the floating point context and the location code
*
*
*Entry:
*    _FPIEEE_VALUE *pOperand        pointer to the operand to be filled in
*    PFLOATING_SAVE_AREA pFloatSave pointer to the floating point context
*    int location                   location code of the operand
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/



void _FillOperand(
    _FPIEEE_VALUE *pOperand,
    PFLOATING_SAVE_AREA pFloatSave,
    int location)
{
    int c0,c2,c3;

    //
    // Assume valid operand (this is almost always the case)
    //

    pOperand->OperandValid = 1;


    switch (location) {
    case ST0:
    case ST1:
    case ST2:
    case ST3:
    case ST4:
    case ST5:
    case ST6:
    case ST7:

        //
        // By convention the location code contains the number of the
        // floating point register
        //

        pOperand->Format = _FpFormatFp80;
        pOperand->Value.Fp80Value = _GetFpRegVal(pFloatSave, location);
        break;

    case M80R:
        pOperand->Format = _FpFormatFp80;
        pOperand->Value.Fp80Value = *(_FP80 *)(pFloatSave->DataOffset);
        break;

    case M16I:
        pOperand->Format = _FpFormatI16;
        pOperand->Value.I16Value = *(_I16 *)(pFloatSave->DataOffset);
        break;

    case M32I:
        pOperand->Format = _FpFormatI32;
        pOperand->Value.I32Value = *(_I32 *)(pFloatSave->DataOffset);
        break;

    case M64I:
        pOperand->Format = _FpFormatI64;
        pOperand->Value.I64Value = *(_I64 *)(pFloatSave->DataOffset);
        break;

    case M64R:
        pOperand->Format = _FpFormatFp64;
        pOperand->Value.Fp64Value = *(_FP64 *)(pFloatSave->DataOffset);
        break;

    case M32R:
        pOperand->Format = _FpFormatFp32;
        pOperand->Value.Fp32Value = *(_FP32 *)(pFloatSave->DataOffset);
        break;

    case M80D:
        pOperand->Format = _FpFormatBcd80;
        pOperand->Value.Bcd80Value = *(_BCD80 *)(pFloatSave->DataOffset);
        break;

    //
    // Status register is used only for comparison instructions
    // therefore the format should be _FpFormatCompare
    //

    case RS:
        pOperand->Format = _FpFormatCompare;
        c0 = pFloatSave->StatusWord & C0 ? (1<<0) : 0;
        c2 = pFloatSave->StatusWord & C2 ? (1<<2) : 0;
        c3 = pFloatSave->StatusWord & C0 ? (1<<3) : 0;

        switch(c0 | c2 | c3) {
        case 0x000:

            // ST > SRC

            pOperand->Value.CompareValue = _FpCompareGreater;
            break;

        case 0x001:

            // ST < SRC

            pOperand->Value.CompareValue = _FpCompareLess;
            break;

        case 0x100:

            // ST = SRC

            pOperand->Value.CompareValue = _FpCompareEqual;
            break;

        default:

            pOperand->Value.CompareValue = _FpCompareUnordered;
            break;
        }

        break;


    case Z80R:
        pOperand->Format = _FpFormatFp80;
        pOperand->Value.Fp80Value = _zero80;
        break;

    case INV:

        pOperand->OperandValid = 0;
        break;


    case REG:

        //
        // Control should never reach here. REG should have already
        // been replaced with a code that corresponds to the register
        // encoded in the instruction

        _ASSERT(0);
        pOperand->OperandValid = 0;
        break;

    }
}




/***
* _UpdateFpCtxt - Update fp context
*
*Purpose:
*   Copy the operand information to  the snapshot of the floating point
*   context or memory, as to make it available on continuation and
*   adjust the fp stack accordingly
*
*
*Entry:
*
*   PFLOATING_SAVE_AREA pFloatSave    pointer to the floating point context
*   _FPIEEE_VALUE *pOperand           pointer to source operand
*   int location                      location code for destination in the
*                                     floating point context
*   int pop                           # of times the stack should be popped
*                                     (if negative, the stack is pushed)
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

void _UpdateFpCtxt(
    PFLOATING_SAVE_AREA pFloatSave,
    _FPIEEE_VALUE *pOperand,
    int location,
    int pop)
{
    if (pop < 0) {
        _AdjustStack(pFloatSave, pop);
    }

    _UpdateResult(pFloatSave, pOperand, location);

    if (pop > 0) {
        _AdjustStack(pFloatSave, pop);
    }
}




/***
* _UpdateResult -  Update result information in the fp context
*
*Purpose:
*   Copy the operand information to  the snapshot of the floating point
*   context or memory, as to make it available on continuation
*
*Entry:
*
*   PFLOATING_SAVE_AREA pFloatSave    pointer to the floating point context
*   _FPIEEE_VALUE *pOperand           pointer to source operand
*   int location)                     location code for destination in the
*                                     floating point context
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

void _UpdateResult(
    PFLOATING_SAVE_AREA pFloatSave,
    _FPIEEE_VALUE *pOperand,
    int location)
{

    switch (location) {
    case ST0:
    case ST1:
    case ST2:
    case ST3:
    case ST4:
    case ST5:
    case ST6:
    case ST7:

        //
        // By convention the location code contains the number of the
        // floating point register
        //

        _SetFpRegVal(pFloatSave,location,&pOperand->Value.Fp80Value);
        break;

    case M80R:
        *(_FP80 *)(pFloatSave->DataOffset) = pOperand->Value.Fp80Value;
        break;

    case M16I:
        *(_I16 *)(pFloatSave->DataOffset) = pOperand->Value.I16Value;
        break;

    case M32I:
        *(_I32 *)(pFloatSave->DataOffset) = pOperand->Value.I32Value;
        break;

    case M64I:
        *(_I64 *)(pFloatSave->DataOffset) = pOperand->Value.I64Value;
        break;

    case M64R:
        *(_FP64 *)(pFloatSave->DataOffset) = pOperand->Value.Fp64Value;
        break;

    case M32R:
        *(_FP32 *)(pFloatSave->DataOffset) = pOperand->Value.Fp32Value;
        break;

    case M80D:
        *(_BCD80 *)(pFloatSave->DataOffset) = pOperand->Value.Bcd80Value;
        break;

    //
    // Status register is used only for comparison instructions
    // therefore the format should be _FpFormatCompare
    //

    case RS:
        switch (pOperand->Value.CompareValue) {
        case _FpCompareEqual:
            // C3,C2,C0 <- 100
            pFloatSave->StatusWord |= C3;
            pFloatSave->StatusWord &= (~C2 & ~C0);
            break;
        case _FpCompareGreater:
            // C3,C2,C0 <- 000
            pFloatSave->StatusWord &= (~C3 & ~C2 & ~C0);
            break;
        case _FpCompareLess:
            // C3,C2,C0 <- 001
            pFloatSave->StatusWord |= C0;
            pFloatSave->StatusWord &= (~C3 & ~C2);
            break;
        case _FpCompareUnordered:
            // C3,C2,C0 <- 111
            pFloatSave->StatusWord |= (C3 | C2 | C0);
            break;
        }


    case INV:

        break;

    case REG:
    case Z80R:

        //
        // Control should never reach here. REG should have already
        // been replaced with a code that corresponds to the register
        // encoded in the instruction

        _ASSERT(0);
        break;

    }
}




/***
* _AdjustStack -
*
*Purpose:
*  Pop (or push) the image of the fp stack in the fp context
*
*Entry:
*  PFLOATING_SAVE_AREA pFloatSaveArea:  pointer to the fp context
*  int pop:     Number of times to pop the stack
*               (if pop<0 stack should be pushed once)
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/


void _AdjustStack(
    PFLOATING_SAVE_AREA pFloatSave,
    int pop)
{
    PX87STATUS pStatus;
    _FP80 tempRegFile[8];
    int i;

    pStatus = (PX87STATUS) &pFloatSave->StatusWord;

    if (pop > 0) {

        // stack should be popped

        for (i=0; i<pop; i++) {

            //
            // mark register as invalid
            //

            _SetTag(&pFloatSave->TagWord, pStatus->Top, TAG_EMPTY);

            pStatus->Top++;
        }

        // pop (rotate) register save area

        memcpy(tempRegFile, pFloatSave->RegisterArea, pop * sizeof(_FP80));
        memmove(pFloatSave->RegisterArea,
                ((_FP80 *)pFloatSave->RegisterArea) + pop,
                (8 - pop) * sizeof(_FP80));
        memcpy(((_FP80 *)pFloatSave->RegisterArea) + (8 - pop),
               tempRegFile,
               pop * sizeof(_FP80));

    }

    else if (pop < 0) {

        // stack should be pushed once (e.g., fsincos, fxtract)

        //
        // mark register as valid
        //

        pStatus->Top--;

        _SetTag(&pFloatSave->TagWord, pStatus->Top, TAG_VALID);

        // push (rotate) register save area just once

        memmove(((_FP80 *)pFloatSave->RegisterArea) + 1,
                pFloatSave->RegisterArea,
                7 * sizeof(_FP80));

    }
}



/***
* _AdjustLocation -
*
*Purpose:
*   Modify location code based on stack adjustment
*
*Entry:
*   int location:   old location code
*   int pop:        stack adjustment factor (>0 for pop, <0 for push)
*
*Exit:
*   returns new location code
*
*Exceptions:
*
*******************************************************************************/


int _AdjustLocation(int location, int pop)
{

    int newlocation;

    switch (location) {
    case ST0:
    case ST1:
    case ST2:
    case ST3:
    case ST4:
    case ST5:
    case ST6:
    case ST7:

        newlocation = location - pop;
        if (newlocation < 0 || newlocation > 7) {
            newlocation = INV;
        }
        break;

    default:
        newlocation = location;
    }

    return newlocation;

}


/***
* _PreventStackOverwrite -
*
*Purpose:
*  Checks if a memory result location is to a stale stack address, where
*  writing to that address would corrupt some newer stack frame.  This can
*  happen when a pending exception was for an FST to a stack local, but the
*  exception wasn't triggered until after the enclosing function exited and
*  the stack local no longer exists, so that it's memory is now being used
*  by an exception handling routine.
*
*Entry:
*  int location:    result location code
*
*Exit:
*  Returns a location code of INV if stack corruption would occur, otherwise
*  returns the entry location code unchanged.
*
*Exceptions:
*
*******************************************************************************/

int _PreventStackOverwrite(PCONTEXT pctxt, int location)
{
    if (_IsMemoryLocation(location)) {

        if (pctxt->Esp > pctxt->FloatSave.DataOffset) {

            //
            // Memory result location is below ESP of FP instr where pending
            // exception was raised
            //

            uintptr_t curESP;
            _asm {
                push    esp
                pop     eax
                mov     curESP, eax
            }

            if (curESP <= pctxt->FloatSave.DataOffset + sizeof(M80R)) {

                //
                // Memory result is in the stack frame of an exception
                // handling function - suppress the update.
                //

                location = INV;
            }
        }
    }

    return location;
}

/***
* _IsMemoryLocation -
*
*Purpose:
*  Returns true if the location code specifies a memory location,
*  otherwise it returns false.
*
*
*Entry:
*  int location:    location code
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

int _IsMemoryLocation(int location)
{
    switch (location) {
    case M80R:
    case M16I:
    case M32I:
    case M64I:
    case M64R:
    case M32R:
    case M80D:
        return 1;
    }

    return 0;

}







/***
* _GetFpRegVal - Get floating point register value
*
*Purpose:
* Return the value of the floating point register ST(stacklocation)
* found in the saved floating point context
*
*Entry:
* PFLOATING_SAVE_AREA pFloatSave  floating point context
* int stackLocation               location of register relative to stack top
*
*Exit:
* returns the register value in _FP80 format
*
*Exceptions:
*
*******************************************************************************/

_FP80 _GetFpRegVal(
    PFLOATING_SAVE_AREA pFloatSave,
    int stackLocation)
{
    if (stackLocation>=0 && stackLocation<8)
        return *((_FP80 *)(pFloatSave->RegisterArea)+stackLocation);
    else
        return _zero80;
}



/***
* _SetFpRegVal - Set floating point register value
*
*Purpose:
* Set the value of the floating point register ST(stacklocation)
* found in the saved floating point context
*
*Entry:
* PFLOATING_SAVE_AREA pFloatSave  floating point context
* int stackLocation               location of register relative to stack top
* _FP80 *pval                     pointer to the new value
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

void _SetFpRegVal(
    PFLOATING_SAVE_AREA pFloatSave,
    int stackLocation,
    _FP80 *pval)
{
    PX87STATUS pStatus;
    int n;
    int tag;

    pStatus = (PX87STATUS) &pFloatSave->StatusWord;

    if (stackLocation>=0 && stackLocation<8) {
        *((_FP80 *)(pFloatSave->RegisterArea)+stackLocation) = *pval;

        n = (pStatus->Top+stackLocation) % 8;

        //
        // Update tag word
        //

        switch (pval->W[4] & 0x7fff) { // check value of the exponent

        case 0:
            if (*(ULONG *)pval == 0 && *((ULONG *)pval+1) == 0) {
                // zero
                tag = TAG_ZERO;
            }
            else {
                // denormal or invalid
                tag = TAG_SPECIAL;
            }
            break;


        case 0x7fff:
            // infinity or NaN
            tag = TAG_SPECIAL;
            break;

        default:
            // valid
            tag = TAG_VALID;
        }

        _SetTag(&pFloatSave->TagWord, n, tag);
    }
}



/***
* _SetTag -
*
*Purpose:
* Set tag of register 'reg' in  tag word to 'value'
*
*
*Entry:
*   ULONG *pTagWord        pointer to the tagword to be modified
*   int reg                absolute register number (NOT relative to stack top)
*   int value              new tag value (empty, valid, zero, special)
*Exit:
*
*Exceptions:
*
*******************************************************************************/

void _SetTag(
    ULONG *pTagWord,
    int reg,
    int value)
{
    ULONG mask;
    int shift;

    shift = reg << 1;
    mask = 0x3 << shift;
    value <<= shift;

    *pTagWord = *pTagWord & ~mask | value & mask;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\i386\frnd.c ===
/***
*frnd.c -
*
*   Copyright (c) 1991-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*
*
*Revision History:
*
*   10-20-91  GDP   written
*   09-05-94  SKS   Change #ifdef i386 to #ifdef _M_IX86
*/

/***
*double _frnd(double x) - round to integer
*
*Purpose:
*   Round to integer according to the current rounding mode.
*   NaN's or infinities are NOT handled
*
*Entry:
*
*Exit:
*
*Exceptions:
*******************************************************************************/


double _frnd(double x)
{
    double result;

#if defined _M_IX86 || defined _X86SEG_
    _asm {
	fld x
	frndint
	fstp result
    }
#else
    #error Only 386 platform supported
#endif

    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\i386\fpctrl.c ===
/***
*fpctrl.c - fp low level control and status routines
*
*   Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*   IEEE control and status routines for internal use.
*   These routines use machine specific constants while _controlfp,
*   _statusfp, and _clearfp use an abstracted control/status word
*
*Revision History:
*
*   03-31-92  GDP   written
*   05-12-92  GJF   Rewrote fdivr as fdivrp st(1),st to work around C8-32
*		    assertions.
*
*/

#include <trans.h>

/***	_statfp
*() -
*
*Purpose:
*	return user status word
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

unsigned int _statfp()
{
    short	status;

    _asm {
	fstsw	status
    }
    return status;
}

/***	_clrfp
*() -
*
*Purpose:
*	return user status word and clear status
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

unsigned int _clrfp()
{
    short	status;
    
    _asm {
	fnstsw	status
	fnclex
    }
    return status;
}


/***	_ctrlfp
*() -
*
*Purpose:
*	return and set user control word
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

unsigned int _ctrlfp(unsigned int newctrl, unsigned int _mask)
{
    short	oldCw;
    short	newCw;

    _asm {
	fstcw	oldCw
    }
    newCw = (short) ((newctrl & _mask) | (oldCw & ~_mask));
    
    _asm {
	fldcw	newCw
    }
    return oldCw;
}



/***	_set_statfp
*() -
*
*Purpose:
*	force selected exception flags to 1
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

static unsigned long over[3] = { 0x0, 0x80000000, 0x4410 };
static unsigned long under[3] = { 0x1, 0x80000000, 0x3000 };


void _set_statfp(unsigned int sw)
{
    int itmp;
    double tmp;

    if (sw & ISW_INVALID) {
	_asm {
	    fld tbyte ptr over
	    fistp   itmp
	    fwait
	}
    }
    if (sw & ISW_OVERFLOW) {   // will also trigger precision
	_asm {
	    fstsw ax
	    fld tbyte ptr over
	    fstp    tmp
	    fwait
	    fstsw  ax
	}
    }
    if (sw & ISW_UNDERFLOW) {  // will also trigger precision
	_asm {
	    fld tbyte ptr under
	    fstp tmp
	    fwait
	}
    }
    if (sw & ISW_ZERODIVIDE) {
	_asm {
	    fldz
	    fld1
	    fdivrp  st(1), st
	    fstp st(0)
	    fwait
	}
    }
    if (sw & ISW_INEXACT) {
	_asm {
	    fldpi
	    fstp tmp
	    fwait
	}
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\i386\floor_pentium4.asm ===
; file: floor_wmt.asm

; Copyright  (C) 1985-2000 Intel Corporation.
;
; The information and source code contained herein is the exclusive property
; of Intel Corporation and may not be disclosed, examined, or reproduced in
; whole or in part without explicit written authorization from the Company.
;
; Implemented in VNIIEF-STL, july 2000

; double floor (double x)
;
; Willamette specific version (MASM 6.15 required)
;
; Description:
;  The floor functions return the largest integer value not greater than x,
;  expressed as a (double-precision) floating-point number.
;
; Special cases:
;  floor(NaN) = that NaN
;  floor(INF) = that INF
;  floor(0) = that 0
;
; Accuracy:
;  The result is always exact.

.xlist
	include cruntime.inc
.list

EXTRN C __libm_error_support : NEAR  

_FUNC_     equ	<floor>
_FUNC_DEF_ equ	<_floor_default>
_FUNC_P4_  equ	<_floor_pentium4>
_FUNC_DEF_EXTERN_ equ 1
	include	disp_pentium4.inc

      .const
      ALIGN 16

;-- 16x-aligned data --------------------------------------------------------

_One     DQ 03ff0000000000000H,03ff0000000000000H
_Bns     DQ 00000000000000433H,00000000000000433H
_NegOne  DQ 0bff0000000000000H,04330000000000000H
_NegZero DQ 08000000000000000H,08000000000000000H
_S       DQ 000000000000007ffH,00000000000000000H

      codeseg
      ALIGN 16

; double floor (double x);

; Stack frame locations

floor_x TEXTEQU <esp+4>
XMMWORD TEXTEQU <OWORD>  

PUBLIC _floor_pentium4
_floor_pentium4 PROC NEAR
    movq      xmm0, QWORD PTR [floor_x]          ; X
    movapd    xmm2, XMMWORD PTR _Bns             ;
    movapd    xmm1, xmm0                         ;
    movapd    xmm7, xmm0                         ;
    psrlq     xmm0, 52                           ; exp(x)    ; sign(X) | exp(X) in XMM reg
    movd      eax, xmm0                          ; sign(X) | exp(X) in eax reg
    andpd     xmm0, XMMWORD PTR _S               ; exp(X) (+3ff)
    psubd     xmm2, xmm0                         ; exp(X)
    psrlq     xmm1, xmm2                         ; truncate the fraction (shift right)

    test      eax, 0800h                         ;
    jne       SHORT negat                        ; if (X<0.0) goto negat
    cmp       eax, 03ffh                         ;**** POSITIVE X *****
    jl        SHORT ret_zero                     ; if (X<1.0) return zero
    psllq     xmm1, xmm2                         ; truncate the fraction (integer part)
    cmp       eax, 0432h                         ; if X is integer, return X
    jg        SHORT return_x
    movq      QWORD PTR [floor_x], xmm1          ; save integer part
    fld       QWORD PTR [floor_x]                ; return integer part
    ret                                          ;

return_x:

    ucomisd   xmm7, xmm7
    jnp       not_nan

    mov       edx, 1005
    ;call libm_error_support(void *arg1,void *arg2,void *retval,error_types input_tag)
    sub       esp, 16
    mov       DWORD PTR [esp+12],edx
    mov       edx, esp
    add       edx, 16+4
    mov       DWORD PTR [esp+8],edx
    mov       DWORD PTR [esp+4],edx
    mov       DWORD PTR [esp],edx
    call      NEAR PTR __libm_error_support
    add       esp, 16

not_nan:
    fld       QWORD PTR [floor_x]                ; return integer part
    ret                                          ;

negat:        ; **** NEGATIVE X ****

    movq      xmm0, QWORD PTR [floor_x]          ;
    psllq     xmm1, xmm2                         ;
    movapd    xmm3, xmm0                         ;
    cmppd     xmm0, xmm1, 1                      ; if X<integer part, form Mask

    cmp       eax, 0bffh                         ; if X > -1.0 return -1.0
    jl        SHORT ret_neg_one                  ;
    cmp       eax, 0c32h                         ; if X is integer, return X
    jg        SHORT return_x                     ;

    andpd     xmm0, XMMWORD PTR _One             ; Mask & One
    subsd     xmm1, xmm0                         ; if X<integer part,
    movq      QWORD PTR [floor_x], xmm1          ;        return (int.part-1.0)
    fld       QWORD PTR [floor_x]                ;
    ret                                          ;

ret_zero:

    fldz                                         ;
    ret                                          ;

ret_neg_one:

    cmppd     xmm3, XMMWORD PTR _NegZero, 1      ; case for X = Negative Zero
    orpd      xmm3, XMMWORD PTR _NegZero         ; return X, if X == Negative Zero
    andpd     xmm3, XMMWORD PTR _NegOne          ; if X==NegZero, xmm3=0.0
    movq      QWORD PTR [floor_x], xmm3          ;
    fld       QWORD PTR [floor_x]                ;
    ret                                          ;

_floor_pentium4 ENDP

    END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\i386\fsqrt.c ===
/***
*fsqrt.c - square root helper
*
*	Copyright (c) 1991-2001, Microsoft Corporation.	All rights reserved.
*
*Purpose:
*   Square root helper routine to be used with the i386
*
*Revision History:
*   10-20-91	GDP	written
*
*******************************************************************************/

double _fsqrt(double x)
{
    double result;
    _asm{
	fld	x
	fsqrt
	fstp	result
    }
    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\i386\ftol.asm ===
page	,132
	title	87ftol	 - truncate TOS to 32-bit integer
;*** 
;87ftol.asm - truncate TOS to 32-bit integer
;
;	Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;
;Revision History:
;
;   07/16/85	Greg Whitten
;		save BX and CX for sloppy code generator
;   10/15/86	Greg Whitten
;		in-line instructions rather than call _fpmath
;   08/24/87	Barry McCord
;		expand the functionality of _ftol to handle
;		unsigned long by using "fistp qword ptr"
;   11/24/87	Barry McCord
;		added _loadds under ifdef DLL
;
;   08/26/88	Bill Johnston
;		386 version
;
;*******************************************************************************


.xlist
	include cruntime.inc
.list

	CODESEG

	public	_ftol
_ftol	proc

	local	oldcw:word
	local	newcw:word
	local	intval:qword

	fstcw	[oldcw] 		; get control word
	fwait				; synchronize

	mov	ax, [oldcw]		; round mode saved
	or	ah, 0ch 		; set chop rounding mode
	mov	[newcw], ax		; back to memory

	fldcw	[newcw] 		; reset rounding
	fistp	qword ptr [intval]	; store chopped integer
	fldcw	[oldcw] 		; restore rounding

	mov	eax, dword ptr [intval]
	mov	edx, dword ptr [intval+4]

	ret
_ftol	endp

	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\i386\huge.asm ===
page	,132
	title   HUGE    - HUGE value
;*** 
;huge.asm - defines HUGE
;
;	Copyright (c) 1984-2001, Microsoft Corporation.  All rights reserved.
;
;Purpose:
;	defines HUGE
;
;Revision History:
;
;   07/04/84	Greg Whitten
;		initial version
;
;   12/21/84	Greg Whitten
;		add assumes so that C can find variable
;
;   09/23/87	Barry C. McCord
;		add _matherr_flag for the sake of the
;		C floating-point intrinsic functions
;
;   08/29/88	Bill Johinston
;		386 version
;
;   08/27/91	JeffRob
;		ANSI naming
;
;   09/06/91	GeorgioP
;		define HUGE as positive infinity
;
;   09/06/91	GeorgioP
;		define _HUGE_dll
;
;   04/05/93	SteveSa
;		undefine _HUGE_dll
;   10/14/93	GregF
;		Restored _HUGE_DLL for _NTSDK
;
;*******************************************************************************


.xlist
	include cruntime.inc
	include mrt386.inc
.list

	.data

ifdef	_NTSDK
ifdef	CRTDLL
globalQ _HUGE_dll, 7ff0000000000000R
else
globalQ _HUGE, 7ff0000000000000R
endif
else
globalQ _HUGE, 7ff0000000000000R
endif

	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\i386\ieee.c ===
/***
*ieee.c - ieee control and status routines
*
*   Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*   IEEE control and status routines.
*
*Revision History:
*
*   04-01-02  GDP   Rewritten to use abstract control and status words
*
*/

#include <trans.h>
#include <float.h>

static unsigned int _abstract_sw(unsigned short sw);
static unsigned int _abstract_cw(unsigned short cw);
static unsigned short _hw_cw(unsigned int abstr);



/***
* _statusfp() -
*
*Purpose:
*	return abstract fp status word
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

unsigned int _statusfp()
{
    short	status;

    _asm {
	fstsw	status
    }
    return _abstract_sw(status);
}


/***
*_clearfp() -
*
*Purpose:
*	return abstract	status word and clear status
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

unsigned int _clearfp()
{
    short	status;
    
    _asm {
	fnstsw	status
	fnclex
    }

    return _abstract_sw(status);
}



/***	_controlfp
*() -
*
*Purpose:
*	return and set abstract user fp control word
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

unsigned int _controlfp(unsigned int newctrl, unsigned int mask)
{
    short	oldCw;
    short	newCw;
    unsigned int oldabs;
    unsigned int newabs;

    _asm {
	fstcw	oldCw
    }

    oldabs = _abstract_cw(oldCw);

    newabs = (newctrl & mask) | (oldabs & ~mask);

    newCw = _hw_cw(newabs);
    
    _asm {
	fldcw	newCw
    }
    return newabs;
}					/* _controlfp() */


/***
* _abstract_cw() - abstract control word
*
*Purpose:
*   produce a fp control word in abstracted (machine independent) form
*
*Entry:
*   cw:     machine control word
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

unsigned int _abstract_cw(unsigned short cw)
{
    unsigned int abstr = 0;


    //
    // Set exception mask bits
    //

    if (cw & IEM_INVALID)
	abstr |= _EM_INVALID;
    if (cw & IEM_ZERODIVIDE)
	abstr |= _EM_ZERODIVIDE;
    if (cw & IEM_OVERFLOW)
	abstr |= _EM_OVERFLOW;
    if (cw & IEM_UNDERFLOW)
	abstr |= _EM_UNDERFLOW;
    if (cw & IEM_INEXACT)
	abstr |= _EM_INEXACT;

    //
    // Set rounding mode
    //

    switch (cw & IMCW_RC) {
    case IRC_NEAR:
	abstr |= _RC_NEAR;
	break;
    case IRC_UP:
	abstr |= _RC_UP;
	break;
    case IRC_DOWN:
	abstr |= _RC_DOWN;
	break;
    case IRC_CHOP:
	abstr |= _RC_CHOP;
	break;
    }

    //
    // Set Precision mode
    //

    switch (cw & IMCW_PC) {
    case IPC_64:
	abstr |= _PC_64;
	break;
    case IPC_53:
	abstr |= _PC_53;
	break;
    case IPC_24:
	abstr |= _PC_24;
	break;
    }

    return abstr;
}


/***
* _hw_cw() -  h/w control word
*
*Purpose:
*   produce a machine dependent fp control word
*
*
*Entry:
*   abstr:	abstract control word
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

unsigned short _hw_cw(unsigned int abstr)
{
    //
    // Set standard infinity and denormal control bits
    //

    unsigned short cw = 0x1002;

    //
    // Set exception mask bits
    //

    if (abstr & _EM_INVALID)
	cw |= IEM_INVALID;
    if (abstr & _EM_ZERODIVIDE)
	cw |= IEM_ZERODIVIDE;
    if (abstr & _EM_OVERFLOW)
	cw |= IEM_OVERFLOW;
    if (abstr & _EM_UNDERFLOW)
	cw |= IEM_UNDERFLOW;
    if (abstr & _EM_INEXACT)
	cw |= IEM_INEXACT;

    //
    // Set rounding mode
    //

    switch (abstr & _MCW_RC) {
    case _RC_NEAR:
	cw |= IRC_NEAR;
	break;
    case _RC_UP:
	cw |= IRC_UP;
	break;
    case _RC_DOWN:
	cw |= IRC_DOWN;
	break;
    case _RC_CHOP:
	cw |= IRC_CHOP;
	break;
    }

    //
    // Set Precision mode
    //

    switch (abstr & _MCW_PC) {
    case _PC_64:
	cw |= IPC_64;
	break;
    case _PC_53:
	cw |= IPC_53;
	break;
    case _PC_24:
	cw |= IPC_24;
	break;
    }


    return cw;
}



/***
* _abstract_sw() - abstract fp status word
*
*Purpose:
*   produce an abstract (machine independent) fp status word
*
*
*Entry:
*   sw:     machine status word
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

unsigned int _abstract_sw(unsigned short sw)
{
    unsigned int abstr = 0;


    if (sw & ISW_INVALID)
	abstr |= _EM_INVALID;
    if (sw & ISW_ZERODIVIDE)
	abstr |= _EM_ZERODIVIDE;
    if (sw & ISW_OVERFLOW)
	abstr |= _EM_OVERFLOW;
    if (sw & ISW_UNDERFLOW)
	abstr |= _EM_UNDERFLOW;
    if (sw & ISW_INEXACT)
	abstr |= _EM_INEXACT;

    return abstr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\i386\genexcep.asm ===
.xlist
        include cruntime.inc
        include elem87.inc
.list

        .data

_exception struc        ; struct _exception {
typ     dd      ?       ;   int type;           /* exception type - see below */
nam     dd      ?       ;   char *name;         /* name of function where error occured */
arg1    dq      ?       ;   double arg1;        /* first argument to function */
arg2    dq      ?       ;   double arg2;        /* second argument (if any) to function */
retval  dq      ?       ;   double retval;      /* value to be returned by function */
_exception ends         ; }

Except_struct_size      equ  ((size _exception) + ISIZE - 1) and (not (ISIZE-1))

Except_struct           equ  [ebp-Except_struct_size]

        CODESEG

extrn        _87except:proc

;***********************************************************
;
;                _startTwoArgErrorHandling
;
;***********************************************************
; Purpose: call to 87except() function, and restore CW
;
; at this point we have on stack: ret_addr(4), cw(4), ret_addr(4), arg1(8bytes)
; ecx   points to function name
; edx   function id (for example OP_LOG)
; eax   error type  (for example SING)
;
; Note:
;   we could use this procedure instead of _startOneArgErrorHandling,
;   but not always we can assume that there is something on stack below param1
;

_startTwoArgErrorHandling proc                \
        savCW:dword,                          \ ; don't change it !!!
        ret_addr:dword,                       \
        param1:qword,
        param2:qword

        local        arg_to_except87:_exception

; store second argument to _exception structure
        mov     [arg_to_except87.typ],eax     ; type of error
        mov     eax,dword ptr [param2]        ; load arg2
        mov     dword ptr [arg_to_except87.arg2],eax
        mov     eax,dword ptr [param2+4]
        mov     dword ptr [arg_to_except87.arg2+4],eax
        jmp     _ContinueErrorHandling
_startTwoArgErrorHandling endp


;***********************************************************
;
;                _startOneArgErrorHandling
;
;***********************************************************
; Purpose: call to 87except() function, and restore CW
;
; at this point we have on stack: ret_addr(4), cw(4), ret_addr(4), arg1(8bytes)
; ecx   points to function name
; edx   function id (for example OP_LOG)
; eax   error type  (for example SING)
;

_startOneArgErrorHandling proc                \
        savCW:dword,                          \ ; don't change it !!!
        ret_addr:dword,                       \
        param1:qword

        local        arg_to_except87:_exception

; prepare _exception structure
        mov     [arg_to_except87.typ],eax     ; type of error
_ContinueErrorHandling        label        proc
        fstp    [arg_to_except87.retval]      ; store return value
        mov     [arg_to_except87.nam],ecx     ; pointer to function name
        mov     eax,dword ptr [param1]        ; load arg1
        mov     ecx,dword ptr [param1+4]
        mov     dword ptr [arg_to_except87.arg1],eax
        mov     dword ptr [arg_to_except87.arg1+4],ecx

; push on stack args for _87except()
        lea     eax,[savCW]                   ; load control word
        lea     ecx,arg_to_except87
        push    eax                           ; &(CW)
        push    ecx                           ; &(_exception structure)
        push    edx                           ; function number
        call    _87except
        add     esp,12                        ; clear arguments if _cdecl
        fld     [arg_to_except87.retval]      ; this assumes that user
                                              ; does not want to return a
                                              ; signaling NaN
; Now it's time to restore saved CW
        cmp     word ptr[savCW],default_CW
        je      CW_is_restored                ; it's usualy taken
        fldcw   word ptr[savCW]
CW_is_restored:
        ret                                   ; _cdecl return

_startOneArgErrorHandling        endp
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\i386\ldsplit.asm ===
page	,132
	title	ldsplit	 - split long double
;*** 
;ldsplit.asm - split long double into two doubles
;
;	Copyright (c) 1992-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;   Helper for handling 10byte long double quantities if there is no
;   compiler support.
;
;Revision History:
;
;   04/21/92	GDP	written
;
;*******************************************************************************

.xlist
	include cruntime.inc
	include mrt386.inc
	include elem87.inc
	include os2supp.inc
.list

.data

labelB TagTable
			; C2 C1 C0 C3	 Meaning
	db	2 * 4	;  0  0  0  0  +Unnormal=>   NAN
	db	1 * 4	;  0  0  0  1  +Zero	=>   Zero
	db	2 * 4	;  0  0  1  0  +NAN	=>   NAN
	db	2 * 4	;  0  0  1  1	Empty	=>   NAN
	db	2 * 4	;  0  1  0  0  -Unnormal=>   NAN
	db	1 * 4	;  0  1  0  1  -Zero	=>   Zero
	db	2 * 4	;  0  1  1  0  -NAN	=>   NAN
	db	2 * 4	;  0  1  1  1	Empty	=>   NAN
	db	0 * 4	;  1  0  0  0  +Normal	=>   Valid
	db	4 * 4	;  1  0  0  1  +Denormal=>   Denormal
	db	3 * 4	;  1  0  1  0  +Infinity=>   Infinity
	db	2 * 4	;  1  0  1  1	Empty	=>   NAN
	db	0 * 4	;  1  1  0  0  -Normal	=>   Valid
	db	4 * 4	;  1  1  0  1  -Denormal=>   Zero
	db	3 * 4	;  1  1  1  0  -Infinity=>   Infinity
	db	2 * 4	;  1  1  1  1	Empty	=>   NAN

; factor = 2^64
staticQ factor,	      043F0000000000000R

LDBIAS		equ	3fffh
DBIAS		equ	3ffh
MAX_BIASED_DEXP equ	7feh

CODESEG



table:
	dd	valid
	dd	zero
	dd	nan
	dd	inf
	dd	denorm



;***
;int _ldsplit(pld, pd1, pd2) - split long double
;
;Purpose:
;   partition a long double quantity ld into two double quantities
;   d1, d2 and an integer scaling factror s. The mantissa of d1 has
;   the high order word of the mantissa of ld. Respectively, the
;   mantissa of d2 has the low order word of the mantissa of ld.
;   The following relation should be satisfied:
;
;	    ld == ((long double)d1 + (long double)d2) * 2^s
;
;   s is 0, unless d1 or d2 cannot be expressed as normalized
;   doubles; in that case s != 0, and .5 <= d1 < 1
;
;
;Entry:
;   pld     pointer to the long double argument
;   pd1     pointer to d1
;   pd2     pointer to d2
;
;Exit:
;   *pd1, *pd2 are updated
;   return value is equal to s
;
;
;Exceptions:
;   This function should raise no IEEE exceptions.
;   special cases:
;     ld is QNAN or SNAN: d1 = QNAN, d2 = 0, s = 0
;     ls is INF:	  d1 = INF, d2 = 0, s = 0
;
;
;******************************************************************************/


_ldsplit proc	uses ebx edx edi, pld:dword, pd1:dword, pd2:dword
	local	ld:tbyte
	local	exp_adj:dword
	local	retvalue:dword
	local	denorm_adj:dword

	mov	[retvalue], 0		; default return value
	mov	[denorm_adj], 0
	mov	ebx, [pld]
	fld	tbyte ptr [ebx]
	fxam
	fstsw	ax
	fstp	[ld]			; store to local area
	shl	ah, 1
	sar	ah, 1
	rol	ah, 1
	and	ah, 0fh
	mov	al, ah
	mov	ebx, dataoffset TagTable	; Prepare for XLAT
	xlat
	movzx	eax, al
	mov	ebx, OFFSET table
	add	ebx, eax

	mov	edx, pd1	    ; edx points to the high order double
	mov	edi, pd2	    ; edi points to the low order double

	jmp	[ebx]

lab valid
	; have a valid normalized non-special long double

	mov	eax, dword ptr [ld]
	or	eax, eax
	jz	d2zero

				    ; compute mantissa an exponent for d2
	mov	[exp_adj], 31	    ; adjustment to be subtracted from exp of *pd2

	;
	; compute mantissa of d2
	; shift left low order word of ld, until a '1' is hit
	;

	cmp	eax, 0ffffh
	ja	shl16done
	sal	eax, 16
	add	[exp_adj], 16

lab shl16done
	cmp	eax, 0ffffffh
	ja	shl8done
	sal	eax, 8
	add	[exp_adj], 8

lab shl8done
lab shiftloop
	inc	[exp_adj]
	sal	eax, 1
	jnc	shiftloop

	; now eax contains the mantissa for d2
	; exp_adj is the difference of the
	; exponents of d1 and d2
	; exp_adj should be in the range
	;	  32 <= exp_adj <= 63
	; By convention, if exp_adj is 0 then
	; d2 is zero

lab setd2man
	mov	dword ptr [edi+4], 0
	shld	dword ptr [edi+4], eax, 20
	shl	eax, 20
	mov	[edi], eax

	;
	; set mantissa of d1
	;

lab setd1man
	mov	eax, dword ptr [ld+4]
	sal	eax, 1			    ; get rid of explicit bit
	mov	dword ptr [edx+4], 0
	shld	dword ptr [edx+4], eax, 20
	shl	eax, 20
	mov	[edx], eax

				    ; check if exponent is in range
	mov	ax, word ptr [ld+8]

	and	ax, 07fffh		; clear sign bit
	movzx	eax, ax

	sub	eax, LDBIAS - DBIAS

	cmp	eax, MAX_BIASED_DEXP
	ja	expoutofrange


	cmp	eax, [exp_adj]
	jb	expoutofrange


	;
	; set exponent of d1
	;

lab setexp1
	mov	ebx, eax		; save exp value
	shl	eax, 20
	or	dword ptr [edx+4], eax


	cmp	[exp_adj], 0
	je	exp2zero
	sub	ebx, [exp_adj]
	je	exp2zero
lab setexp2
	shl	ebx, 20
	or	dword ptr [edi+4], ebx
	mov	[retvalue], 0


lab setsign				; set correct signs and return
					; at this point eax contains
					; the return value
	mov	bx, word ptr [ld+8]
	and	bx, 1 SHL 15		; get sign

	or	[edi+6], bx		; set sign bit
	or	[edx+6], bx		; set sign bit

	mov	eax, [retvalue]
	add	eax, [denorm_adj]
	ret


lab d2zero
	mov	[exp_adj], 0
	jmp	setd2man

lab exp2zero
	mov	ebx, 0
	jmp	setexp2



lab expoutofrange
	mov	ebx, DBIAS
	mov	ecx, ebx
	sub	ecx, [exp_adj]

	shl	ebx, 20
	or	dword ptr [edx+4], ebx

	shl	ecx, 20
	or	dword ptr [edi+4], ecx

	sub	eax, DBIAS		; unbias exp
	mov	[retvalue], eax		; this is the return value
	jmp	short setsign


lab zero
	mov	dword ptr [edx],   0
	mov	dword ptr [edx+4], 0
	mov	dword ptr [edi],   0
	mov	dword ptr [edi+4], 0
	jmp	setsign

lab nan
	mov	dword ptr [edx],   0
	mov	dword ptr [edx+4], 07ff80000h
	mov	dword ptr [edi],   0
	mov	dword ptr [edi+4], 0
	jmp	setsign

lab inf
	mov	dword ptr [edx],   0
	mov	dword ptr [edx+4], 07ff00000h
	mov	dword ptr [edi],   0
	mov	dword ptr [edi+4], 0
	jmp	setsign

lab denorm

	;
	; We have a long double denormal
	; so we know for sure that this is out of the double
	; precision range, and the return value of _ldsplit
	; should be non-zero.
	; Multiply the denormal by 2^64, then adjust the
	; return value by subtracting 64
	;


	; this assumes denormal exception masked
	fld	[ld]
	fmul	[factor]
	fstp	[ld]
	mov	[denorm_adj], 64
	jmp	valid



_ldsplit endp

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\i386\ftol2.asm ===
page    ,132
        title   ftol2    - truncate TOS to 32-bit integer
;*** 
;ftol2.asm - truncate TOS to 32-bit integer
;
;       Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;
;Revision History:
;
;   01/26/01    Phil Lucido
;               Optimized version from Intel to avoid Pentium FLDCW stalls.
;
;*******************************************************************************


.xlist
        include cruntime.inc
.list

        CODESEG

        public  _ftol2
_ftol2  proc

tmp1    equ     <[esp+24]>
tmp2    equ     <[esp+16]>
tmp3    equ     <[esp]>

        push    ebp
        mov     ebp,esp
        sub     esp,32
        and     esp,0fffffff0h

        fld     st(0)           ; duplicate FPU stack top
        fst     dword ptr tmp1  ; store single to get the sign
        fistp   qword ptr tmp2  ; sto as int
        fild    qword ptr tmp2  ; ld int, cvt to fp
        mov     edx,tmp1        ; get the sign (not fwd problem)
        mov     eax,tmp2        ; low dword of integer
        test    eax,eax
        je      integer_QnaN_or_zero

   arg_is_not_integer_QnaN:
        fsubp   st(1),st        ; TOS=d-round(d),
                                ; { st(1)=st(1)-st & pop ST}
        test    edx,edx         ; whats sign of integer
        jns     positive        ; number is negative
        fstp    dword ptr tmp3  ; result of subtraction
        mov     ecx,tmp3        ; dword of diff(single-precision)
        xor     ecx,80000000h
        add     ecx,7fffffffh   ; if diff<0 then decrement integer
        adc     eax,0           ; inc eax (add CARRY flag)
        mov     edx,tmp2+4      ; high dword of integer - deferred
        adc     edx,0
        jmp     localexit       

   positive:
        fstp    dword ptr tmp3  ; 17-18 result of subtraction
        mov     ecx,tmp3        ; dword of diff(single-precision)
        add     ecx,7fffffffh   ; if diff<0 then decrement integer
        sbb     eax,0           ; dec eax (subtract CARRY flag)
        mov     edx,tmp2+4      ; high dword of integer - deferred
        sbb     edx,0
        jmp     localexit      

   integer_QnaN_or_zero: ; load the upper 32 bits of the converted integer
        mov     edx,tmp2+4      ; high dword of integer (fwd problem)
        test    edx,7fffffffh
        jnz     arg_is_not_integer_QnaN
        fstp    dword ptr tmp1
        fstp    dword ptr tmp1

   localexit:
        leave
        ret

_ftol2  endp

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\i386\ieee87.c ===
/***
*ieee.c - ieee control and status routines
*
*   Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*   IEEE control and status routines.
*
*Revision History:
*
*       04-01-02  GDP   Rewritten to use abstract control and status words
*       10-30-92  GDP   _fpreset now resets saved fp context if called from a
*                       signal handler.
*       09-01-94  SKS   Change include file from <nt.h> to <windows.h>
*       04-11-95  JWM   _fpreset() now resets default precision.
*       05-10-96  BWT   Fix POSIX build.
*
*/

#include <trans.h>
#include <float.h>
#include <windows.h>
#include <signal.h>

extern void _setdefaultprecision();

static unsigned int _abstract_sw(unsigned short sw);
static unsigned int _abstract_cw(unsigned short cw);
static unsigned short _hw_cw(unsigned int abstr);


/***
* _statusfp() -
*
*Purpose:
*       return abstract fp status word
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

unsigned int _statusfp()
{
    short   status;

    _asm {
        fstsw   status
    }
    return _abstract_sw(status);
}


/***
*_clearfp() -
*
*Purpose:
*       return abstract status word and clear status
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

unsigned int _clearfp()
{
    short   status;

    _asm {
        fnstsw  status
        fnclex
    }

    return _abstract_sw(status);
}



/***    _control87
*() -
*
*Purpose:
*       return and set abstract user fp control word
*       can modify EM_DENORMAL mask
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

unsigned int _control87(unsigned int newctrl, unsigned int mask)
{
    short   oldCw;
    short   newCw;
    unsigned int oldabs;
    unsigned int newabs;

    _asm {
        fstcw   oldCw
    }

    oldabs = _abstract_cw(oldCw);

    newabs = (newctrl & mask) | (oldabs & ~mask);

    newCw = _hw_cw(newabs);

    _asm {
        fldcw   newCw
    }
    return newabs;
}                   /* _controlfp() */


/***    _controlfp
*() -
*
*Purpose:
*       return and set abstract user fp control word
*       cannot change denormal mask (ignores _EM_DENORMAL)
*       This is done for portable IEEE behavior on all platforms
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

unsigned int _controlfp(unsigned int newctrl, unsigned int mask)
{
    return _control87(newctrl, mask & ~_EM_DENORMAL);
}




/***
* _fpreset() - reset fp system
*
*Purpose:
*       reset fp environment to the default state
*       Also reset saved fp environment if invoked from a user's
*       signal handler
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/
#define TAG_ALL_EMPTY ((unsigned int) 0xffff);

void _fpreset()
{
#ifndef _POSIX_
    PEXCEPTION_POINTERS excptrs = (PEXCEPTION_POINTERS) _pxcptinfoptrs;
#endif

    _asm {
        fninit
    }
    _setdefaultprecision();     // reset precision, usually down to 53 bits
#ifndef _POSIX_
    if (excptrs &&
        excptrs->ContextRecord->ContextFlags & CONTEXT_FLOATING_POINT) {
        // _fpreset has been invoked by a signal handler which in turn
        // has been invoked by the CRT filter routine. In this case
        // the saved fp context should be cleared, so that the change take
        // effect on continuation.

        FLOATING_SAVE_AREA *pFloatSave = &excptrs->ContextRecord->FloatSave;
        pFloatSave->StatusWord = 0;
        pFloatSave->TagWord = TAG_ALL_EMPTY;
    }
#endif
}







/***
* _abstract_cw() - abstract control word
*
*Purpose:
*   produce a fp control word in abstracted (machine independent) form
*
*Entry:
*   cw:     machine control word
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

unsigned int _abstract_cw(unsigned short cw)
{
    unsigned int abstr = 0;


    //
    // Set exception mask bits
    //

    if (cw & IEM_INVALID)
        abstr |= _EM_INVALID;
    if (cw & IEM_ZERODIVIDE)
        abstr |= _EM_ZERODIVIDE;
    if (cw & IEM_OVERFLOW)
        abstr |= _EM_OVERFLOW;
    if (cw & IEM_UNDERFLOW)
        abstr |= _EM_UNDERFLOW;
    if (cw & IEM_INEXACT)
        abstr |= _EM_INEXACT;
    if (cw & IEM_DENORMAL)
        abstr |= _EM_DENORMAL;

    //
    // Set rounding mode
    //

    switch (cw & IMCW_RC) {
    case IRC_NEAR:
        abstr |= _RC_NEAR;
        break;
    case IRC_UP:
        abstr |= _RC_UP;
        break;
    case IRC_DOWN:
        abstr |= _RC_DOWN;
        break;
    case IRC_CHOP:
        abstr |= _RC_CHOP;
        break;
    }

    //
    // Set Precision mode
    //

    switch (cw & IMCW_PC) {
    case IPC_64:
        abstr |= _PC_64;
        break;
    case IPC_53:
        abstr |= _PC_53;
        break;
    case IPC_24:
        abstr |= _PC_24;
        break;
    }


    //
    // Infinity control (bit can be programmed but has no effect)
    //

    if (cw & IMCW_IC) {
        abstr |= _IC_AFFINE;
    }

    return abstr;
}


/***
* _hw_cw() -  h/w control word
*
*Purpose:
*   produce a machine dependent fp control word
*
*
*Entry:
*   abstr:  abstract control word
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

unsigned short _hw_cw(unsigned int abstr)
{
    //
    // Set standard infinity and denormal control bits
    //

    unsigned short cw = 0;

    //
    // Set exception mask bits
    //

    if (abstr & _EM_INVALID)
        cw |= IEM_INVALID;
    if (abstr & _EM_ZERODIVIDE)
        cw |= IEM_ZERODIVIDE;
    if (abstr & _EM_OVERFLOW)
        cw |= IEM_OVERFLOW;
    if (abstr & _EM_UNDERFLOW)
        cw |= IEM_UNDERFLOW;
    if (abstr & _EM_INEXACT)
        cw |= IEM_INEXACT;
    if (abstr & _EM_DENORMAL)
        cw |= IEM_DENORMAL;

    //
    // Set rounding mode
    //

    switch (abstr & _MCW_RC) {
    case _RC_NEAR:
        cw |= IRC_NEAR;
        break;
    case _RC_UP:
        cw |= IRC_UP;
        break;
    case _RC_DOWN:
        cw |= IRC_DOWN;
        break;
    case _RC_CHOP:
        cw |= IRC_CHOP;
        break;
    }

    //
    // Set Precision mode
    //

    switch (abstr & _MCW_PC) {
    case _PC_64:
        cw |= IPC_64;
        break;
    case _PC_53:
        cw |= IPC_53;
        break;
    case _PC_24:
        cw |= IPC_24;
        break;
    }


    //
    // Set Infinity mode
    //

    if (abstr & _MCW_IC) {
        cw |= IIC_AFFINE;
    }

    return cw;
}



/***
* _abstract_sw() - abstract fp status word
*
*Purpose:
*   produce an abstract (machine independent) fp status word
*
*
*Entry:
*   sw:     machine status word
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

unsigned int _abstract_sw(unsigned short sw)
{
    unsigned int abstr = 0;


    if (sw & ISW_INVALID)
        abstr |= _SW_INVALID;
    if (sw & ISW_ZERODIVIDE)
        abstr |= _SW_ZERODIVIDE;
    if (sw & ISW_OVERFLOW)
        abstr |= _SW_OVERFLOW;
    if (sw & ISW_UNDERFLOW)
        abstr |= _SW_UNDERFLOW;
    if (sw & ISW_INEXACT)
        abstr |= _SW_INEXACT;
    if (sw & ISW_DENORMAL)
        abstr |= _SW_DENORMAL;

    return abstr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\i386\libm_support.h ===
//  
// Copyright (c) 2000, Intel Corporation
// All rights reserved.
//
// Contributed 2/2/2000 by John Harrison, Ted Kubaska, Bob Norin, Shane Story, 
// and Ping Tak Peter Tang of the Computational Software Lab, Intel Corporation.
//
// WARRANTY DISCLAIMER
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS 
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// Intel Corporation is the author of this code, and requests that all
// problem reports or change requests be submitted to it directly at
// http://developer.intel.com/opensource.
//

typedef enum
{
  logl_zero=0,   logl_negative,                  /*  0,  1 */
  log_zero,      log_negative,                   /*  2,  3 */
  logf_zero,     logf_negative,                  /*  4,  5 */
  log10l_zero,   log10l_negative,                /*  6,  7 */
  log10_zero,    log10_negative,                 /*  8,  9 */
  log10f_zero,   log10f_negative,                /* 10, 11 */
  expl_overflow, expl_underflow,                 /* 12, 13 */
  exp_overflow,  exp_underflow,                  /* 14, 15 */
  expf_overflow, expf_underflow,                 /* 16, 17 */
  powl_overflow, powl_underflow,                 /* 18, 19 */
  powl_zero_to_zero,                             /* 20     */
  powl_zero_to_negative,                         /* 21     */
  powl_neg_to_non_integer,                       /* 22     */
  powl_nan_to_zero,                              /* 23     */
  pow_overflow,  pow_underflow,                  /* 24, 25 */
  pow_zero_to_zero,                              /* 26     */ 
  pow_zero_to_negative,                          /* 27     */
  pow_neg_to_non_integer,                        /* 28     */
  pow_nan_to_zero,                               /* 29     */
  powf_overflow, powf_underflow,                 /* 30, 31 */
  powf_zero_to_zero,                             /* 32     */
  powf_zero_to_negative,                         /* 33     */ 
  powf_neg_to_non_integer,                       /* 34     */ 
  powf_nan_to_zero,                              /* 35     */
  atan2l_zero,                                   /* 36     */
  atan2_zero,                                    /* 37     */
  atan2f_zero,                                   /* 38     */
  expm1l_overflow,                               /* 39     */
  expm1l_underflow,                              /* 40     */
  expm1_overflow,                                /* 41     */
  expm1_underflow,                               /* 42     */
  expm1f_overflow,                               /* 43     */
  expm1f_underflow,                              /* 44     */
  hypotl_overflow,                               /* 45     */
  hypot_overflow,                                /* 46     */
  hypotf_overflow,                               /* 47     */
  sqrtl_negative,                                /* 48     */
  sqrt_negative,                                 /* 49     */
  sqrtf_negative,                                /* 50     */
  scalbl_overflow, scalbl_underflow,             /* 51,52  */
  scalb_overflow,  scalb_underflow,              /* 53,54  */
  scalbf_overflow, scalbf_underflow,             /* 55,56  */
  acosl_gt_one, acos_gt_one, acosf_gt_one,       /* 57, 58, 59 */
  asinl_gt_one, asin_gt_one, asinf_gt_one,       /* 60, 61, 62 */
  coshl_overflow, cosh_overflow, coshf_overflow, /* 63, 64, 65 */
  y0l_zero, y0l_negative,y0l_gt_loss,            /* 66, 67, 68 */
  y0_zero, y0_negative,y0_gt_loss,               /* 69, 70, 71 */
  y0f_zero, y0f_negative,y0f_gt_loss,            /* 72, 73, 74 */
  y1l_zero, y1l_negative,y1l_gt_loss,            /* 75, 76, 77 */ 
  y1_zero, y1_negative,y1_gt_loss,               /* 78, 79, 80 */ 
  y1f_zero, y1f_negative,y1f_gt_loss,            /* 81, 82, 83 */ 
  ynl_zero, ynl_negative,ynl_gt_loss,            /* 84, 85, 86 */
  yn_zero, yn_negative,yn_gt_loss,               /* 87, 88, 89 */
  ynf_zero, ynf_negative,ynf_gt_loss,            /* 90, 91, 92 */
  j0l_gt_loss,                                   /* 93 */ 
  j0_gt_loss,                                    /* 94 */
  j0f_gt_loss,                                   /* 95 */
  j1l_gt_loss,                                   /* 96 */
  j1_gt_loss,                                    /* 97 */
  j1f_gt_loss,                                   /* 98 */
  jnl_gt_loss,                                   /* 99 */
  jn_gt_loss,                                    /* 100 */
  jnf_gt_loss,                                   /* 101 */
  lgammal_overflow, lgammal_negative,lgammal_reserve, /* 102, 103, 104 */
  lgamma_overflow, lgamma_negative,lgamma_reserve,    /* 105, 106, 107 */
  lgammaf_overflow, lgammaf_negative, lgammaf_reserve,/* 108, 109, 110 */
  gammal_overflow,gammal_negative, gammal_reserve,    /* 111, 112, 113 */
  gamma_overflow, gamma_negative, gamma_reserve,      /* 114, 115, 116 */
  gammaf_overflow,gammaf_negative,gammaf_reserve,     /* 117, 118, 119 */   
  fmodl_by_zero,                                 /* 120 */
  fmod_by_zero,                                  /* 121 */
  fmodf_by_zero,                                 /* 122 */
  remainderl_by_zero,                            /* 123 */
  remainder_by_zero,                             /* 124 */
  remainderf_by_zero,                            /* 125 */
  sinhl_overflow, sinh_overflow, sinhf_overflow, /* 126, 127, 128 */
  atanhl_gt_one, atanhl_eq_one,                  /* 129, 130 */
  atanh_gt_one, atanh_eq_one,                    /* 131, 132 */
  atanhf_gt_one, atanhf_eq_one,                  /* 133, 134 */
  acoshl_lt_one,                                 /* 135 */
  acosh_lt_one,                                  /* 136 */
  acoshf_lt_one,                                 /* 137 */
  log1pl_zero,   log1pl_negative,                /* 138, 139 */
  log1p_zero,    log1p_negative,                 /* 140, 141 */
  log1pf_zero,   log1pf_negative,                /* 142, 143 */
  ldexpl_overflow,   ldexpl_underflow,           /* 144, 145 */
  ldexp_overflow,    ldexp_underflow,            /* 146, 147 */
  ldexpf_overflow,   ldexpf_underflow,           /* 148, 149 */
  logbl_zero,   logb_zero, logbf_zero,           /* 150, 151,152 */
  nextafterl_overflow,   nextafter_overflow,  
  nextafterf_overflow,                           /* 153, 154,155 */
  ilogbl_zero,  ilogb_zero, ilogbf_zero,         /* 156, 157,158 */
  exp2l_overflow, exp2l_underflow,               /* 159, 160 */
  exp2_overflow,  exp2_underflow,                /* 161, 162 */
  exp2f_overflow, exp2f_underflow,               /* 163, 164 */
  exp10l_overflow, exp10_overflow,
  exp10f_overflow,                               /* 165, 166, 167 */
  log2l_zero,    log2l_negative,                 /* 168, 169 */
  log2_zero,     log2_negative,                  /* 170, 171 */
  log2f_zero,    log2f_negative,                 /* 172, 173 */

  log_nan = 1000,                                /* 1000 */
  log10_nan,                                     /* 1001 */
  exp_nan,                                       /* 1002 */
  atan_nan,                                      /* 1003 */
  ceil_nan,                                      /* 1004 */
  floor_nan,                                     /* 1005 */
  pow_nan,                                       /* 1006 */
  modf_nan                                       /* 1007 */
} error_types;

void __libm_error_support(void*,void*,void*,error_types);

#define BIAS_64  1023
#define EXPINF_64  2047

#define DOUBLE_HEX(HI, LO) 0x ## LO, 0x ## HI

static const unsigned INF[] = {
    DOUBLE_HEX(7ff00000, 00000000),
    DOUBLE_HEX(fff00000, 00000000)
};
static const unsigned BIG[] = {
    DOUBLE_HEX(7fe00000, 00000000),
    DOUBLE_HEX(00200000, 00000000)
};
static const unsigned ZERO[] = {
    DOUBLE_HEX(00000000, 00000000),
    DOUBLE_HEX(80000000, 00000000)
};

static const unsigned INF_32[] = {0x7f800000,0xff800000 };
static const unsigned NAN_32[] = {0x7fc00000,0xffc00000};
static const unsigned ZERO_32[] = { 0, 0x80000000 };

static const float libm_largef[] = { 1.0e+30f, -1.0e+30f };
static const float libm_smallf[] = { 1.0e-30f, -1.0e-30f };
static const double libm_small[] = { 1.0e-300, -1.0e-300 };

#define INVALID    (*((double*)&ZERO[0]) * *((double*)&INF[0]))
#define INVALID_32    *(float *)&ZERO_32[0] * *(float *)&INF_32[0]
#define LIBM_OVERFLOW (*((double*)&BIG[0]) * *((double*)&BIG[0]))
#define LIBM_UNDERFLOW (*((double*)&BIG[2]) * *((double*)&BIG[2]))
#define LIBM_OVERFLOWF (libm_largef[0] * libm_largef[0])
#define LIBM_UNDERFLOWF (libm_smallf[0] * libm_smallf[0])
#define PINF       *((double*)&INF[0]) 
#define NINF       -PINF 
#define PINF_DZ    (1.0/(*((double*)&ZERO[0])) 


struct _exception
{
  int type;
  char *name;
  double arg1, arg2, retval;
};

#define	MATHERR_D	_matherr

#define	EXC_DECL_D	_exception

extern int MATHERR_D(struct EXC_DECL_D*);

/* Set these appropriately to make thread Safe */
#define ERRNO_RANGE  errno = ERANGE
#define ERRNO_DOMAIN errno = EDOM

extern int (*_pmatherr)(struct EXC_DECL_D*);

// This is a run-time variable and may affect
// floating point behavior of the libm functions


#define BIAS_32  127
#define BIAS_64  1023
#define BIAS_80  16383
#define BIAS_128 16383

#define MAXEXP_32  254
#define MAXEXP_64  2046
#define MAXEXP_80  32766
#define MAXEXP_128 32766

#define EXPINF_32  255
#define EXPINF_64  2047
#define EXPINF_80  32767
#define EXPINF_128 32767

/*****************************/
/* memory format definitions */
/*****************************/

/*/// if you use /Zp2 option, or the following pragma... then the
//// 80 bit FP objects will occupy only 10 bytes in memory - otherwise
//// more generous alignments will "waste" memory.
//// Use of -DPACKFP80 is NOT recommended.
//// The same effect can be obtained using /Zp2 (again, NOT recommended).
//// Otherwise the alignment will be a word, forcing the size to be
//// 12 bytes (this means some memory will be wasted in exchange
//// for better performance).
//// Unfortunately, because -DPACKFP80 is implemented the same as /Zp2,
//// all structures will be packed tighter in the entire program. */
#ifdef PACKFP80
#pragma warning(disable:4103)
#pragma pack(2)
#endif

struct fp32 { /*// sign:1 exponent:8 significand:23 (implied leading 1)*/
  unsigned significand:23;
  unsigned exponent:8;
  unsigned sign:1;
};

struct fp64 { /*/ sign:1 exponent:11 significand:52 (implied leading 1)*/
  unsigned lo_significand:32;
  unsigned hi_significand:20;
  unsigned exponent:11;
  unsigned sign:1;
};

struct fp80 { /*/ sign:1 exponent:15 significand:64 (NO implied bits) */
  unsigned         lo_significand;
  unsigned         hi_significand;
  unsigned         exponent:15;
  unsigned         sign:1;
};

#ifdef __cplusplus
  extern "C" {
#endif

  #define NONZERO_SIGNIFICAND(X) ((X)->hi_significand != 0 || (X)->lo_significand != 0)
  #define ZERO_SIGNIFICAND(X)    ((X)->hi_significand == 0 && (X)->lo_significand == 0)
  #define SET_ZERO_SIGNIFICAND(X) (X)->hi_significand = 0; (X)->lo_significand = 0
  #define SET_LO_SIGNIFICAND(X, LO) (X)->lo_significand = (LO)
  #define SET_HI_SIGNIFICAND(X, HI) (X)->hi_significand = (HI)
  #define SET_SIGNIFICAND(X, HI, LO) (X)->hi_significand = (HI);(X)->lo_significand = (LO)
  #define SIGNIFICAND_EQUAL(X, HI, LO) (((X)->hi_significand == 0x ## HI) && ((X)->lo_significand == 0x ## LO))
  #define SIGNIFICAND_GREATER(X, HI, LO) ((X)->hi_significand > 0x ## HI) || \
    (((X)->hi_significand == 0x ## HI) && ((X)->lo_significand > 0x ## LO))
  #define SIGNIFICAND_GREATER_EQ(X, HI, LO) ((X)->hi_significand > 0x ## HI) || \
    (((X)->hi_significand == 0x ## HI) && ((X)->lo_significand >= 0x ## LO))
  #define SIGNIFICAND_LESS(X, HI, LO) ((X)->hi_significand < 0x ## HI) || \
    (((X)->hi_significand == 0x ## HI) && ((X)->lo_significand < 0x ## LO))
  #define SIGNIFICAND_LESS_EQ(X, HI, LO) ((X)->hi_significand < 0x ## HI) || \
    (((X)->hi_significand == 0x ## HI) && ((X)->lo_significand <= 0x ## LO))
  #define HI_SIGNIFICAND_LESS(X, HI) ((X)->hi_significand < 0x ## HI)
  #define ISSIGNIFICAND_EQUAL(X, Y) (((X)->hi_significand == (Y)->hi_significand) && ((X)->lo_significand == (Y)->lo_significand))
  #define ISSIGNIFICAND_GREATER(X, Y) ((X)->hi_significand > (Y)->hi_significand) || \
    (((X)->hi_significand == (Y)->hi_significand) && ((X)->lo_significand > (Y)->lo_significand))
  #define ADD_ULP(X) if(!++(X)->lo_significand) { \
                           if(!++(X)->hi_significand) { \
                                 (X)->exponent++; }}
  #define SUB_ULP(X) if(!(X)->lo_significand--) { \
                           if(!(X)->hi_significand--) { \
                                 (X)->exponent--; }}
  #define CLEAR_LOW_BITS(X,MASK) (X)->lo_significand &= 0x ## MASK
  #define FIX_N_HI_BITS(X, NBIT) (X)->lo_significand = 0; (X)->hi_significand &= (0xfffff << (20 - NBIT))
  #define HI_BITS_TO_INTEGER(X, NBIT) (1 << (NBIT)) | ((X)->hi_significand >> (20 - (NBIT)))
  #ifdef BIG_ENDIAN
    #define DOUBLE_HEX(HI, LO) 0x ## HI, 0x ## LO
    #define HI_WORD(NUM) (*((unsigned *)(NUM))) & 0x7fffffff
  #else
    #define DOUBLE_HEX(HI, LO) 0x ## LO, 0x ## HI
    #define HI_WORD(NUM) (*(((unsigned *)(NUM))+1)) & 0x7fffffff
  #endif

#define SIGN_EXPAND(val,num)  ((val) << (32-(num))) >> (32-(num)) /* sign expand of 'num' LSBs */

#define VALUE_EQUAL(X,EXP,HI,LO) (((X)->exponent == (EXP)) && SIGNIFICAND_EQUAL(X, HI, LO))

#define VALUE_GREATER(X,EXP,HI,LO) (((X)->exponent > (EXP)) || \
    (((X)->exponent == (EXP)) && (SIGNIFICAND_GREATER(X, HI, LO))))
#define VALUE_GREATER_EQ(X,EXP,HI,LO) (((X)->exponent > (EXP)) || \
    (((X)->exponent == (EXP)) && (SIGNIFICAND_GREATER_EQ(X, HI, LO))))
#define VALUE_LESS(X,EXP,HI,LO) (((X)->exponent < (EXP)) || \
    (((X)->exponent == (EXP)) && (SIGNIFICAND_LESS(X, HI, LO))))
#define VALUE_LESS_EQ(X,EXP,HI,LO) (((X)->exponent < (EXP)) || \
    (((X)->exponent == (EXP)) && (SIGNIFICAND_LESS_EQ(X, HI, LO))))

#define ISVALUE_EQUAL(X, Y) \
    (((X)->exponent == (Y)->exponent) && ISSIGNIFICAND_EQUAL(X, Y))
#define ISVALUE_GREATER(X, Y) \
    (((X)->exponent > (Y)->exponent) || (((X)->exponent == (Y)->exponent) && ISSIGNIFICAND_GREATER(X, Y)))

#define VALUE_GREATERF(X,EXP,SIG) (((X)->exponent > (EXP)) || \
    (((X)->exponent == (EXP)) && ((X)->significand > 0x##SIG)))
#define VALUE_GREATER_EQF(X,EXP,SIG) (((X)->exponent > (EXP)) || \
    (((X)->exponent == (EXP)) && ((X)->significand >= 0x##SIG)))
#define VALUE_LESSF(X,EXP,SIG) (((X)->exponent < (EXP)) || \
    (((X)->exponent == (EXP)) && ((X)->significand < 0x##SIG)))
#define VALUE_LESS_EQF(X,EXP,SIG) (((X)->exponent < (EXP)) || \
    (((X)->exponent == (EXP)) && ((X)->significand <= 0x##SIG)))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\i386\log_pentium4.asm ===
;//
;//               INTEL CORPORATION PROPRIETARY INFORMATION
;//  This software is supplied under the terms of a license agreement or
;//  nondisclosure agreement with Intel Corporation and may not be copied
;//  or disclosed except in accordance with the terms of that agreement.
;//  Copyright (c) 2000 Intel Corporation. All Rights Reserved.
;//
;//
;  log_wmt.asm
;
;  double log(double);
;
;  Initial version: 12/15/2000
;  Updated with bug fixes: 2/20/2001
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;                                                                       ;;
;; Another important feature is that we use the table of log(1/B)        ;;
;; throughout. To ensure numerical accuracy, we only need to ensure that ;;
;; T(0)_hi = B(last)_hi, T(0)_lo = B(last)_lo. This ensures W_hi = 0 and ;;
;; W_lo = 0 exactly in the case of |X-1| <= 2^(-7).                      ;;
;; Finally, we do away with the need for extra-precision addition by the ;;
;; following observation. The three pieces at the end are                ;;
;; A = W_hi + r_hi; B = r_lo; C = P + W_lo.                              ;;
;; When W_hi = W_lo = 0, the addition sequence (A+B) + C is accurate as  ;;
;; the sum A+B is exact.                                                 ;;
;; Otherwise, A + (B+C) is accurate as B is going to be largely shifted  ;;
;; off compared to the final result.                                     ;;
;; Hence if we use compare and mask operations to                        ;;
;; create alpha = (r_lo or 0), beta = (0 or r_lo), Res_hi <- W_hi+alpha, ;;
;; Res_lo <- C + beta, then result is accurately computed as             ;;
;; Res_hi+Res_lo.                                                        ;;
;;                                                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

.686P
.387
.XMM
.MODEL FLAT,C

EXTRN C __libm_error_support : NEAR  


CONST SEGMENT PARA PUBLIC USE32 'CONST'
ALIGN 16

emask   DQ  000FFFFFFFFFFFFFH, 000FFFFFFFFFFFFFH ; mask off sign/expo field
Magic   DQ  428FFFFFFFFFF80FH, 428FFFFFFFFFF80FH ; 2^(42)-1+2^(-7)
hi_mask DQ  7FFFFFFFFFE00000H, 7FFFFFFFFFE00000H ; mask of bottom 21 bits
LOG_2   DQ  3FE62E42FEFA3800H, 3D2EF35793C76730H ; L_hi,L_lo -> [L_lo|L_hi]
place_L DQ  0000000000000000H,0FFFFFFFFFFFFFFFFH ; 0,1 -> [FF..FF|00..00]
        DQ 0FFFFFFFFFFFFFFFFH, 0000000000000000H ; 1,0 -> [00..00|FF..FF]
One 	DQ  3ff0000000000000H, 3ff0000000000000H ; 1,1 
Zero    DQ  0000000000000000H, 0000000000000000H ; 0,0
Two52   DQ  4330000000000000H, 4330000000000000H ; 2^52 for normalization
Infs    DQ 0FFF0000000000000H, 7FF0000000000000H ; -inf,+inf --> [+inf|-inf]
NaN     DQ  7FF0000000000001H, 7FF0000000000001H ; NaN for log(-ve), log(Nan)

coeff   DQ  3FC24998090DC555H,  0BFCFFFFFFF201E13H      ; p6,p3 ->[p3|p6]
        DQ 0BFC555C54DD57D75H,   3FD55555555555A7H      ; p5,p2 ->[p2|p5]
        DQ  3FC9999998867A53H,  0BFE000000000001CH      ; p4,p1 ->[p1|p4]

;-------Table B-----------
B_Tbl     DQ 3FF0000000000000H, 3FF0000000000000H
          DQ 3FEF820000000000H, 3FEF820000000000H
          DQ 3FEF080000000000H, 3FEF080000000000H
          DQ 3FEE920000000000H, 3FEE920000000000H
          DQ 3FEE1E0000000000H, 3FEE1E0000000000H
          DQ 3FEDAE0000000000H, 3FEDAE0000000000H
          DQ 3FED420000000000H, 3FED420000000000H
          DQ 3FECD80000000000H, 3FECD80000000000H
          DQ 3FEC720000000000H, 3FEC720000000000H
          DQ 3FEC0E0000000000H, 3FEC0E0000000000H
          DQ 3FEBAC0000000000H, 3FEBAC0000000000H
          DQ 3FEB4E0000000000H, 3FEB4E0000000000H
          DQ 3FEAF20000000000H, 3FEAF20000000000H
          DQ 3FEA980000000000H, 3FEA980000000000H
          DQ 3FEA420000000000H, 3FEA420000000000H
          DQ 3FE9EC0000000000H, 3FE9EC0000000000H
          DQ 3FE99A0000000000H, 3FE99A0000000000H
          DQ 3FE9480000000000H, 3FE9480000000000H
          DQ 3FE8FA0000000000H, 3FE8FA0000000000H
          DQ 3FE8AC0000000000H, 3FE8AC0000000000H
          DQ 3FE8620000000000H, 3FE8620000000000H
          DQ 3FE8180000000000H, 3FE8180000000000H
          DQ 3FE7D00000000000H, 3FE7D00000000000H
          DQ 3FE78A0000000000H, 3FE78A0000000000H
          DQ 3FE7460000000000H, 3FE7460000000000H
          DQ 3FE7020000000000H, 3FE7020000000000H
          DQ 3FE6C20000000000H, 3FE6C20000000000H
          DQ 3FE6820000000000H, 3FE6820000000000H
          DQ 3FE6420000000000H, 3FE6420000000000H
          DQ 3FE6060000000000H, 3FE6060000000000H
          DQ 3FE5CA0000000000H, 3FE5CA0000000000H
          DQ 3FE58E0000000000H, 3FE58E0000000000H
          DQ 3FE5560000000000H, 3FE5560000000000H
          DQ 3FE51E0000000000H, 3FE51E0000000000H
          DQ 3FE4E60000000000H, 3FE4E60000000000H
          DQ 3FE4B00000000000H, 3FE4B00000000000H
          DQ 3FE47A0000000000H, 3FE47A0000000000H
          DQ 3FE4460000000000H, 3FE4460000000000H
          DQ 3FE4140000000000H, 3FE4140000000000H
          DQ 3FE3E20000000000H, 3FE3E20000000000H
          DQ 3FE3B20000000000H, 3FE3B20000000000H
          DQ 3FE3820000000000H, 3FE3820000000000H
          DQ 3FE3520000000000H, 3FE3520000000000H
          DQ 3FE3240000000000H, 3FE3240000000000H
          DQ 3FE2F60000000000H, 3FE2F60000000000H
          DQ 3FE2CA0000000000H, 3FE2CA0000000000H
          DQ 3FE29E0000000000H, 3FE29E0000000000H
          DQ 3FE2740000000000H, 3FE2740000000000H
          DQ 3FE24A0000000000H, 3FE24A0000000000H
          DQ 3FE2200000000000H, 3FE2200000000000H
          DQ 3FE1F80000000000H, 3FE1F80000000000H
          DQ 3FE1D00000000000H, 3FE1D00000000000H
          DQ 3FE1A80000000000H, 3FE1A80000000000H
          DQ 3FE1820000000000H, 3FE1820000000000H
          DQ 3FE15C0000000000H, 3FE15C0000000000H
          DQ 3FE1360000000000H, 3FE1360000000000H
          DQ 3FE1120000000000H, 3FE1120000000000H
          DQ 3FE0EC0000000000H, 3FE0EC0000000000H
          DQ 3FE0CA0000000000H, 3FE0CA0000000000H
          DQ 3FE0A60000000000H, 3FE0A60000000000H
          DQ 3FE0840000000000H, 3FE0840000000000H
          DQ 3FE0620000000000H, 3FE0620000000000H
          DQ 3FE0420000000000H, 3FE0420000000000H
          DQ 3FE0200000000000H, 3FE0200000000000H
          DQ 3FE0000000000000H, 3FE0000000000000H

;-------Table T_hi,T_lo  so that movapd gives [ T_lo | T_hi ]
T_Tbl     DQ 0000000000000000H, 0000000000000000H
          DQ 3F8FBEA8B13C0000H, 3CDEC927B17E4E13H
          DQ 3F9F7A9B16780000H, 3D242AD9271BE7D7H
          DQ 3FA766D923C20000H, 3D1FF0A82F1C24C1H
          DQ 3FAF0C30C1114000H, 3D31A88653BA4140H
          DQ 3FB345179B63C000H, 3D3D4203D36150D0H
          DQ 3FB6EF528C056000H, 3D24573A51306A44H
          DQ 3FBA956D3ECAC000H, 3D3E63794C02C4AFH
          DQ 3FBE2507702AE000H, 3D303B433FD6EEDCH
          DQ 3FC0D79E7CD48000H, 3D3CB422847849E4H
          DQ 3FC299D30C606000H, 3D3D4D0079DC08D9H
          DQ 3FC44F8B726F8000H, 3D3DF6A4432B9BB4H
          DQ 3FC601B076E7A000H, 3D3152D7D4DFC8E5H
          DQ 3FC7B00916515000H, 3D146280D3E606A3H
          DQ 3FC9509AA0044000H, 3D3F1E675B4D35C6H
          DQ 3FCAF6895610D000H, 3D375BEBBA042B64H
          DQ 3FCC8DF7CB9A8000H, 3D3EEE42F58E1E6EH
          DQ 3FCE2A877A6B2000H, 3D3823817787081AH
          DQ 3FCFB7D86EEE3000H, 3D371FCF1923FB43H
          DQ 3FD0A504E97BB000H, 3D303094E6690C44H
          DQ 3FD1661CAECB9800H, 3D2D1C000C076A8BH
          DQ 3FD22981FBEF7800H, 3D17AF7A7DA9FC99H
          DQ 3FD2E9E2BCE12000H, 3D24300C128D1DC2H
          DQ 3FD3A71C56BB4800H, 3D08C46FB5A88483H
          DQ 3FD4610BC29C5800H, 3D385F4D833BCDC7H
          DQ 3FD51D1D93104000H, 3D35B0FAA20D9C8EH
          DQ 3FD5D01DC49FF000H, 3D2740AB8CFA5ED3H
          DQ 3FD68518244CF800H, 3D28722FF88BF119H
          DQ 3FD73C1800DC0800H, 3D3320DBF75476C0H
          DQ 3FD7E9883FA49800H, 3D3FAFF96743F289H
          DQ 3FD898D38A893000H, 3D31F666071E2F57H
          DQ 3FD94A0428036000H, 3D30E7BCB08C6B44H
          DQ 3FD9F123F4BF6800H, 3D36892015F2401FH
          DQ 3FDA99FCABDB8000H, 3D11E89C5F87A311H
          DQ 3FDB44977C148800H, 3D3C6A343FB526DBH
          DQ 3FDBEACD9E271800H, 3D268A6EDB879B51H
          DQ 3FDC92B7D6BB0800H, 3D10FE9FFF876CC2H
          DQ 3FDD360E90C38000H, 3D342CDB58440FD6H
          DQ 3FDDD4AA04E1C000H, 3D32D8512DF01AFDH
          DQ 3FDE74D262788800H, 3CFEB945ED9457BCH
          DQ 3FDF100F6C2EB000H, 3D2CCE779D37F3D8H
          DQ 3FDFACC89C9A9800H, 3D163E0D100EC76CH
          DQ 3FE02582A5C9D000H, 3D222C6C4E98E18CH
          DQ 3FE0720E5C40DC00H, 3D38E27400B03FBEH
          DQ 3FE0BF52E7353800H, 3D19B5899CD387D3H
          DQ 3FE109EB9E2E4C00H, 3D12DA67293E0BE7H
          DQ 3FE15533D3B8D400H, 3D3D981CA8B0D3C3H
          DQ 3FE19DB6BA0BA400H, 3D2B675885A4A268H
          DQ 3FE1E6DF676FF800H, 3D1A58BA81B983AAH
          DQ 3FE230B0D8BEBC00H, 3D12FC066E48667BH
          DQ 3FE2779E1EC93C00H, 3D36523373359B79H
          DQ 3FE2BF29F9841C00H, 3CFD8A3861D3B7ECH
          DQ 3FE30757344F0C00H, 3D309BE85662F034H
          DQ 3FE34C80A8958000H, 3D1D4093FCAC34BDH
          DQ 3FE39240DDE5CC00H, 3D3493DBEAB758B3H
          DQ 3FE3D89A6B1A5400H, 3D28C7CD5FA81E3EH
          DQ 3FE41BCFF4860000H, 3D076FD6B90E2A84H
          DQ 3FE4635BCF40DC00H, 3D2CE8D5D412CAADH
          DQ 3FE4A3E862342400H, 3D224FA993F78464H
          DQ 3FE4E8D015786C00H, 3D38B1C0D0303623H
          DQ 3FE52A6D269BC400H, 3D30022268F689C9H
          DQ 3FE56C91D71CF800H, 3CE07BAFD1366E9EH
          DQ 3FE5AB505B390400H, 3CD5627AF66563FAH
          DQ 3FE5EE82AA241800H, 3D2202380CDA46BEH
          DQ 3FE62E42FEFA3800H, 3D2EF35793C76730H
  
ALIGN 16
CONST ENDS

$cmpsd MACRO op1, op2, op3
LOCAL begin_cmpsd, end_cmpsd
begin_cmpsd:
cmppd op1, op2, op3
end_cmpsd:
org begin_cmpsd
db 0F2h
org end_cmpsd
ENDM


_TEXT SEGMENT PARA PUBLIC USE32 'CODE'
ALIGN 16

PUBLIC _log_pentium4, _CIlog_pentium4
_CIlog_pentium4 PROC NEAR
push        ebp
mov         ebp, esp
sub         esp, 8                          ; for argument DBLSIZE
and         esp, 0fffffff0h
fstp        qword ptr [esp]
movq        xmm0, qword ptr [esp]
call        start
leave
ret

;----------------------;
;--Argument Reduction--;
;----------------------;
_log_pentium4 label proc
movlpd    xmm0, QWORD PTR [4+esp]         ;... load X to low part of xmm0
start:
mov       edx,0                ;... set edx to 0 

DENORMAL_RETRY:

movapd    xmm5,xmm0
unpcklpd  xmm0,xmm0            ;... [X|X]

psrlq     xmm5,52
pextrw    ecx,xmm5,0

movapd    xmm1, QWORD PTR [emask]         ;... pair of 000FF...FF
movapd    xmm3, QWORD PTR [One]           ;... pair of 3FF000...000
movapd    xmm4, QWORD PTR [Magic]         ;... pair of 2^(42)-1+2^(-7)
movapd    xmm6, QWORD PTR [hi_mask]       ;... pair of 7FFFFFFF..FE00000
andpd     xmm0,xmm1
orpd      xmm0,xmm3            ;... [Y|Y]
addpd     xmm4,xmm0            ;... 11 lsb contains the index to B
                               ;... the last 4 lsb are don't cares, the
                               ;... 7 bits following that is the index
                               ;... Hence by masking, we already have index*16

pextrw    eax,xmm4,0
and       eax,000007F0H                   ;... eax is offset
movapd    xmm4, QWORD PTR [eax+B_Tbl]     ;... [B|B]
movapd    xmm7, QWORD PTR [eax+T_Tbl]

andpd     xmm6,xmm0            ;... [Y_hi|Y_hi]
subpd     xmm0,xmm6            ;... [Y_lo|Y_lo]
mulpd     xmm6,xmm4            ;... [B*Y_hi|B*Y_hi]
subpd     xmm6,xmm3            ;... [R_hi|R_hi]
addsd     xmm7,xmm6            ;... [T_lo|T_hi+R_hi]
mulpd     xmm0,xmm4            ;... [R_lo|R_lo]
movapd    xmm4,xmm0            ;... [R_lo|R_lo]
addpd     xmm0,xmm6            ;... [R|R]

;-----------------------------------------;
;--Approx and Reconstruction in parallel--;
;-----------------------------------------;

;...m is in ecx, [T_lo,T_hi+R_hi] in xmm7
;...xmm4 through xmm6 will be used
and       ecx,00000FFFH        ;... note we need sign and biased exponent
sub       ecx,1
cmp       ecx,2045             ;... the largest biased exponent 2046-1
                               ;... if ecx is ABOVE (unsigned) this, either
                               ;... the sign is +ve and biased exponent is 7FF
                               ;... or the sign is +ve and exponent is 0, or
                               ;... the sign is -ve (i.e. sign bit 1)
ja        SPECIAL_CASES

sub       ecx,1022             ;... m in integer format
add       ecx,edx              ;... this is the denormal adjustment

cvtsi2sd  xmm6,ecx
unpcklpd  xmm6,xmm6            ;... [m | m] in FP format

shl       ecx,10
add       eax,ecx              ;16*(64*m + j) 0 <=> (m=-1 & j=64) or (m=0 & j=0)
mov       ecx,16
mov       edx,0
cmp       eax,0
cmove     edx,ecx              ;this is the index into the mask table (place_{L,R})
 
movapd    xmm1, QWORD PTR [coeff]         ;... loading [p3|p6]
movapd    xmm3,xmm0
movapd    xmm2, QWORD PTR [coeff+16]      ;... loading [p2|p5]
mulpd     xmm1,xmm0                       ;... [p3 R | p6 R]
mulpd     xmm3,xmm3                       ;... [R^2|R^2]
addpd     xmm1,xmm2                       ;... [p2+p3 R |p5+p6 R]
movapd    xmm2, QWORD PTR [coeff+32]      ;... [p1|p4]
mulsd     xmm3,xmm3                       ;... [R^2|R^4]

movapd    xmm5, QWORD PTR [LOG_2]         ;... loading [L_lo|L_hi]
                                          ;... [T_lo|T_hi+R_hi] already in xmm7
mulpd     xmm6,xmm5                       ;... [m L_lo | m L_hi]
movapd    xmm5, QWORD PTR [edx+place_L]   ;... [FF..FF|00.00] or [00..00|FF..FF]
andpd     xmm4,xmm5                       ;... [R_lo|0] or [0|R_lo]
addpd     xmm7,xmm6                       ;... [W_lo|W_hi]
addpd     xmm7,xmm4                       ;... [A_lo|A_hi]

mulpd     xmm1,xmm0                       ;... [p2 R+p3 R^2|p5 R+p6 R^2]
mulsd     xmm3,xmm0                       ;... [R^2|R^5]
addpd     xmm1,xmm2                       ;... [p1+.. | p4+...]


movapd    xmm6,xmm7            
unpckhpd  xmm6,xmm6            ;... [*|A_lo]

mulpd     xmm1,xmm3            ;... [P_hi|P_lo]
sub esp, 16
movapd    xmm0,xmm1            ;... copy of [P_hi|P_lo]
unpckhpd  xmm1,xmm1            ;... [P_hi|P_hi]

;...[P_hi|P_lo] in xmm1 at this point
addsd     xmm0,xmm1            ;... [*|P]
addsd     xmm0,xmm6
addsd     xmm0,xmm7

movlpd    QWORD PTR [esp+4], xmm0       ; return result
fld       QWORD PTR [esp+4]             ;
add esp, 16
	ret

SPECIAL_CASES:
movlpd    xmm0, QWORD PTR [4+esp]         ;... load X again
movapd    xmm1, QWORD PTR [Zero]
$cmpsd    xmm1,xmm0,0
pextrw    eax,xmm1,0           ;... ones if X = +-0.0
cmp       eax,0
ja        INPUT_ZERO

cmp       ecx,-1               ;... ecx = -1 iff X is positive denormal
je        INPUT_DENORM

cmp       ecx,000007FEH        
ja        INPUT_NEGATIVE

movlpd    xmm0, QWORD PTR [4+esp]
movapd    xmm1, QWORD PTR [emask]
movapd    xmm2, QWORD PTR [One]
andpd     xmm0,xmm1
orpd      xmm0,xmm2            ;... xmm0 is 1 iff the input argument was +inf
$cmpsd    xmm2,xmm0,0
pextrw    eax,xmm2,0           ;... 0 if X is NaN
cmp eax, 0
je        INPUT_NaN

INPUT_INF:

;....Input is +Inf
fld       QWORD PTR [Infs+8]             ;
ret

INPUT_NaN:

; movlpd xmm0, QWORD PTR [esp+4]
; addsd xmm0, xmm0
; sub esp, 16
; movlpd    QWORD PTR [esp+4], xmm0       ; return result
; fld       QWORD PTR [esp+4]             ;
; add esp, 16
; ret
mov edx, 1000
jmp CALL_LIBM_ERROR

INPUT_ZERO:

	; raise Divide by Zero
	movlpd xmm2, QWORD PTR [One]
	divsd  xmm2, xmm0
	movlpd xmm1, QWORD PTR [Infs]
mov edx, 2
jmp CALL_LIBM_ERROR

INPUT_DENORM:

;....check for zero or denormal
;....for now I assume this is simply denormal
;....in reality, we need to check for zero and handle appropriately

movlpd    xmm1,Two52
mulsd     xmm0,xmm1
mov       edx,-52              ;...set adjustment to exponent
jmp       DENORMAL_RETRY       ;...branch back

INPUT_NEGATIVE:

add ecx,1
and ecx, 7ffH
cmp ecx, 7ffH
jae NEG_INF_NAN 

NEG_NORMAL_INFINITY:

; xmm1=0
xorpd xmm1, xmm1
; raise Invalid
divsd xmm1, xmm1
mov edx, 3

CALL_LIBM_ERROR:

;call libm_error_support(void *arg1,void *arg2,void *retval,error_types input_tag)
sub esp, 28
movlpd QWORD PTR [esp+16], xmm1
mov DWORD PTR [esp+12],edx
mov edx, esp
add edx,16
mov DWORD PTR [esp+8],edx
add edx,16
mov DWORD PTR [esp+4],edx
mov DWORD PTR [esp],edx
call NEAR PTR __libm_error_support
;	movlpd xmm0, QWORD PTR [esp+16]
;	movlpd    QWORD PTR [esp+16], xmm0       ; return result
fld       QWORD PTR [esp+16]             ;
add esp,28
ret


NEG_INF_NAN:

  movlpd xmm2, QWORD PTR [esp+4]
  movlpd xmm0, QWORD PTR [esp+4]
  movd eax, xmm2
  psrlq xmm2, 32
  movd ecx, xmm2
  and ecx, 0fffffH ; eliminate sign/exponent
  or eax, ecx
  cmp eax,0
  jz NEG_NORMAL_INFINITY	; negative infinity

; addsd xmm0, xmm0
; sub esp,16
; movlpd QWORD PTR [esp+4], xmm0
; fld QWORD PTR [esp+4]
; add esp, 16
; ret
mov edx, 1000
jmp CALL_LIBM_ERROR


_CIlog_pentium4 ENDP

ALIGN 16
_TEXT ENDS

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\i386\libm_error.c ===
//     
// Copyright (c) 2000, Intel Corporation
// All rights reserved.
//
// Contributed 2/2/2000 by John Harrison, Ted Kubaska, Bob Norin, Shane Story, James
// Edwards, and Ping Tak Peter Tang of the Computational Software Lab, Intel Corporation.
//
// WARRANTY DISCLAIMER
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS 
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// Intel Corporation is the author of this code, and requests that all
// problem reports or change requests be submitted to it directly at
// http://developer.intel.com/opensource.
//
// History
//==============================================================
// 2/02/00: Initial version.
// 2/12/01: Updated to be NT double precision specific.

#include <errno.h>
#include <stdio.h>
#include "libm_support.h"

/************************************************************/
/* matherrX function pointers and setusermatherrX functions */
/************************************************************/
int (*_pmatherr)(struct EXC_DECL_D*) = MATHERR_D;

/***********************************************/
/* error-handling function, libm_error_support */
/***********************************************/
void __libm_error_support(void *arg1,void *arg2,void *retval,error_types input_tag)
{

struct _exception exc;

const char double_inf[8] = {0x00,0x00,0x00,0x00,0x00,0x00,0xF0,0x7F}; 
const char double_huge[8] = {0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xEF,0x7F};
const char double_zero[8] = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
const char double_neg_inf[8] = {0x00,0x00,0x00,0x00,0x00,0x00,0xF0,0xFF}; 
const char double_neg_huge[8] = {0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xEF,0xFF};
const char double_neg_zero[8] = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80};

#define RETVAL_HUGE_VALD *(double *)retval = *(double *) double_inf
#define RETVAL_NEG_HUGE_VALD *(double *)retval = *(double *) double_neg_inf
#define RETVAL_HUGED *(double *)retval = (double) *(float *)float_huge
#define RETVAL_NEG_HUGED *(double *)retval = (double) *(float *) float_neg_huge 
#define RETVAL_ZEROD *(double *)retval = *(double *)double_zero 
#define RETVAL_NEG_ZEROD *(double *)retval = *(double *)double_neg_zero 
#define RETVAL_ONED *(double *)retval = 1.0 

#define NOT_MATHERRD exc.arg1=*(double *)arg1;exc.arg2=*(double *)arg2;exc.retval=*(double *)retval;if(!_pmatherr(&exc))

#define NAMED exc.name  

//
// These should work OK for MS because they are ints -
// leading underbars are not necessary.
//

#define DOMAIN          1
#define SING            2
#define OVERFLOW        3
#define UNDERFLOW       4
#define TLOSS           5
#define PLOSS           6

#define SINGD exc.type = SING
#define DOMAIND exc.type = DOMAIN 
#define OVERFLOWD exc.type = OVERFLOW 
#define UNDERFLOWD exc.type = UNDERFLOW 
#define TLOSSD exc.type = TLOSS 

#define INPUT_XD (exc.arg1=*(double*)arg1)
#define INPUT_YD (exc.arg1=*(double*)arg2)
#define INPUT_RESD (*(double *)retval)

#define WRITED_LOG_ZERO fputs("log: SING error\n",stderr)
#define WRITED_LOG_NEGATIVE fputs("log: DOMAIN error\n",stderr)
#define WRITED_LOG10_ZERO fputs("log10: SING error\n",stderr) 
#define WRITED_LOG10_NEGATIVE fputs("log10: DOMAIN error\n",stderr)
#define WRITED_POW_ZERO_TO_ZERO fputs("pow(0,0): DOMAIN error\n",stderr)
#define WRITED_POW_ZERO_TO_NEGATIVE fputs("pow(0,negative): DOMAIN error\n",stderr)
#define WRITED_POW_NEG_TO_NON_INTEGER fputs("pow(negative,non-integer): DOMAIN error\n",stderr)

  switch(input_tag)
  {
  case log_zero:
    /* log(0) */
    {
       SINGD; NAMED="log"; 
       NOT_MATHERRD {ERRNO_RANGE;}
       *(double *)retval = exc.retval;	
       break;
    }
  case log_negative:
    /* log(x < 0) */
    {
       DOMAIND; NAMED="log";
       NOT_MATHERRD {ERRNO_DOMAIN;}
       *(double *)retval = exc.retval;	
       break;
    } 
  case log10_zero:
    /* log10(0) */
    {
       SINGD; NAMED="log10";
       NOT_MATHERRD {ERRNO_RANGE;}
       *(double *)retval = exc.retval;	
       break;
    }
  case log10_negative:
    /* log10(x < 0) */
    {
       DOMAIND; NAMED="log10";
       NOT_MATHERRD {ERRNO_DOMAIN;}
       *(double *)retval = exc.retval;
       break;
    }
  case exp_overflow:
    /* exp overflow */
    {
       OVERFLOWD; NAMED="exp";
       NOT_MATHERRD {ERRNO_RANGE;}
       *(double *)retval = exc.retval;	
       break;
    }
  case exp_underflow:
    /* exp underflow */
    {
       UNDERFLOWD; NAMED="exp"; 
       NOT_MATHERRD {}
       *(double *)retval = exc.retval;
       break;
    }
  case pow_zero_to_zero:
    /* pow 0**0 */
    {
       DOMAIND; NAMED="pow";
       RETVAL_ONED;
       break;
    }
  case pow_overflow:
    /* pow(x,y) overflow */
    {
       OVERFLOWD; NAMED = "pow";
       NOT_MATHERRD {ERRNO_RANGE;}
       *(double *)retval = exc.retval;
       break;
    }
  case pow_underflow:
    /* pow(x,y) underflow */
    {
       UNDERFLOWD; NAMED = "pow"; 
       NOT_MATHERRD {}
       *(double *)retval = exc.retval;
       break;
    }
  case pow_zero_to_negative:
    /* 0**neg */
    {
       SINGD; NAMED = "pow";
       NOT_MATHERRD {ERRNO_RANGE;}
       *(double *)retval = exc.retval;
       break;
    }
  case pow_neg_to_non_integer:
    /* neg**non_integral */
    {
       DOMAIND; NAMED = "pow";
       NOT_MATHERRD {ERRNO_DOMAIN;}
       *(double *)retval = exc.retval;	
       break;
    }
  case pow_nan_to_zero:
    /* pow(NaN,0.0) */
    /* Special Error */
    {
       DOMAIND; NAMED = "pow"; INPUT_XD; INPUT_YD;
       *(double *)retval = *(double *)arg1 * 1.0; 
       NOT_MATHERRD {ERRNO_DOMAIN;}
       *(double *)retval = exc.retval;	
       break;
    }
  case log2_zero:
    /* log2(0) */
    {
       SINGD; NAMED="log2";
       NOT_MATHERRD {ERRNO_RANGE;}
       *(double *)retval = exc.retval;
       break;
    }
  case log2_negative:
    /* log2(negative) */
    {
       DOMAIND; NAMED="log2";
       NOT_MATHERRD {ERRNO_DOMAIN;}
       *(double *)retval = exc.retval;
       break;
    }
  case exp2_underflow:
    /* exp2 underflow */
    {
       UNDERFLOWD; NAMED="exp2"; 
       NOT_MATHERRD {ERRNO_RANGE;}
       *(double *)retval = exc.retval;
       break;
    }
  case exp2_overflow:
    /* exp2 overflow */
    {
       OVERFLOWD; NAMED="exp2";
       NOT_MATHERRD {ERRNO_RANGE;}
       *(double *)retval = exc.retval;
       break;
    }
  case exp10_overflow:
    /* exp10 overflow */
    {
       OVERFLOWD; NAMED="exp10";
       NOT_MATHERRD {ERRNO_RANGE;}
       *(double *)retval = exc.retval;
       break;
    }
  case log_nan:
    /* log(NaN) */
    {
       DOMAIND; NAMED="log";
       *(double *)retval = *(double *)arg1 * 1.0; 
       NOT_MATHERRD {ERRNO_DOMAIN;}
       *(double *)retval = exc.retval;
       break;
    }
  case log10_nan:
    /* log10(NaN) */
    {
       DOMAIND; NAMED="log10";
       *(double *)retval = *(double *)arg1 * 1.0; 
       NOT_MATHERRD {ERRNO_DOMAIN;}
       *(double *)retval = exc.retval;
       break;
    }
  case exp_nan:
    /* exp(NaN) */
    {
       DOMAIND; NAMED="exp";
       *(double *)retval = *(double *)arg1 * 1.0; 
       NOT_MATHERRD {ERRNO_DOMAIN;}
       *(double *)retval = exc.retval;
       break;
    }
  case atan_nan:
    /* atan(NaN) */
    {
       DOMAIND; NAMED="atan";
       *(double *)retval = *(double *)arg1 * 1.0; 
       NOT_MATHERRD {ERRNO_DOMAIN;}
       *(double *)retval = exc.retval;
       break;
    }
  case ceil_nan:
    /* ceil(NaN) */
    {
       DOMAIND; NAMED="ceil";
       *(double *)retval = *(double *)arg1 * 1.0; 
       NOT_MATHERRD {ERRNO_DOMAIN;}
       *(double *)retval = exc.retval;
       break;
    }
  case floor_nan:
    /* floor(NaN) */
    {
       DOMAIND; NAMED="floor";
       *(double *)retval = *(double *)arg1 * 1.0; 
       NOT_MATHERRD {ERRNO_DOMAIN;}
       *(double *)retval = exc.retval;
       break;
    }
  case pow_nan:
    /* pow(NaN,*) or pow(*,NaN) */
    {
       DOMAIND; NAMED="pow";
       NOT_MATHERRD {ERRNO_DOMAIN;}
       *(double *)retval = exc.retval;
       break;
    }
  case modf_nan:
    /* modf(NaN) */
    {
       DOMAIND; NAMED="modf";
       *(double *)retval = *(double *)arg1 * 1.0; 
       NOT_MATHERRD {ERRNO_DOMAIN;}
       *(double *)retval = exc.retval;
       break;
    }
  }
  return;
  }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\i386\log10.asm ===
;***
;
;   Copyright (c) 1984-2001, Microsoft Corporation. All rights reserved.
;
;Revision History:
;
;*******************************************************************************

_LOG10_ equ 1
include log.asm
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\i386\log.asm ===
;***
;
;   Copyright (c) 1984-2001, Microsoft Corporation. All rights reserved.
;
;Revision History:
;   01-26-01  PML   Pentium4 merge.
;   02-28-01  PML   Check for negative denormal.
;
;*******************************************************************************

.xlist
        include cruntime.inc
        include elem87.inc
.list

ifdef   _LOG10_
    _FUNC_     equ      <log10>
    _FUNC_DEF_ equ      <_log10_default>
    _FUNC_P4_  equ      <_log10_pentium4>
else
    _FUNC_     equ      <log>
    _FUNC_DEF_ equ      <_log_default>
    _FUNC_P4_  equ      <_log_pentium4>
endif
    _FUNC_P4_EXTERN_ equ 1
        include disp_pentium4.inc

ifdef   _LOG10_
    _FUNC_     equ      <_CIlog10>
    _FUNC_DEF_ equ      <_CIlog10_default>
    _FUNC_P4_  equ      <_CIlog10_pentium4>
else
    _FUNC_     equ      <_CIlog>
    _FUNC_DEF_ equ      <_CIlog_default>
    _FUNC_P4_  equ      <_CIlog_pentium4>
endif
        include disp_pentium4.inc

        .data
extrn   _infinity:tbyte
extrn   _minfinity:tbyte
extrn   _indefinite:tbyte
extrn   __fastflag:dword
extrn   _DEFAULT_CW_in_mem:word

ifdef   _LOG10_
    LOG_name db 'log10',0,0,0
    _FUNC_      equ <_log10_default>
    _IFUNC_     equ <_CIlog10_default>
else
    LOG_name db 'log',0
    _FUNC_      equ <_log_default>
    _IFUNC_     equ <_CIlog_default>
endif
;page

        CODESEG

extrn   _startOneArgErrorHandling:near
extrn   _fload_withFB:near
extrn        _convertTOStoQNaN:near
extrn        _checkTOS_withFB:near
extrn        _math_exit:near
extrn        _fast_exit:near


; arg                ErrorType        result
;-------------------------------------------
;0.0 or -0.0         SING             minfinity
;negative            DOMAIN           indefinite
;-infinity           DOMAIN           indefinite
;+infinity           ??               +infinity
;QNaN                DOMAIN_QNAN      QNaN
;SNaN                DOMAIN           QNaN=indefinite
;indefinite is  like QNaN
;denormal(53)        fld converts it to normal (64 bits)
;denormal(64)        like normal number (64 bits)


        public        _IFUNC_,_FUNC_
_IFUNC_ proc
        sub     esp,DBLSIZE+4                   ; for argument
        fst     qword ptr [esp]
        call    _checkTOS_withFB
        call    start
        add     esp,DBLSIZE+4
        ret

_FUNC_        label        proc
        lea     edx,[esp+4]
        call    _fload_withFB
start:
        push    edx                           ; allocate space for Control Word
        fstcw   [esp]                         ; store Control Word

; at this point we have on stack: cw(4), ret_addr(4), arg1(8bytes)

        jz      inf_or_nan
        mov     eax,[esp+0ch]                 ; eax contains high dword
        cmp     word ptr[esp],default_CW
        je      CW_is_set_to_default
; fyl2x is not affected by precision bits. So we may ignore user's CW
        fldcw   _DEFAULT_CW_in_mem
CW_is_set_to_default:
        test    eax,7ff00000h
        jz      test_if_x_zero
        test    eax,80000000h                 ; obtain sign
        jnz     negative_x

normal:
ifdef _LOG10_
        fldlg2
else
        fldln2                                ; y=load loge(2)
endif
        fxch
        fyl2x                                 ; y*log2(x)

exit:
        cmp     __fastflag,0
        jnz     _fast_exit

; prepare in registers arguments for math_exit
        lea     ecx,[LOG_name]
ifdef _LOG10_
        mov     edx,OP_LOG10
else
        mov     edx,OP_LOG
endif
        jmp     _math_exit

x_is_denormal:                                ; denormal is like normal
        test    eax,80000000h                 ; obtain sign
        jnz     negative_x
        jmp     normal

inf_or_nan:                                   ; we differ inf and NaN
        test    eax,000fffffH                 ; eax=high
        jnz     not_infinity
        cmp     dword ptr[esp+8],0            ; test if low dword is zero
        jnz     not_infinity
        and     eax,80000000H                 ; test sign of infinity
        jz      exit                          ; infinity is already in ST(0)
negative_x:                                   ; -inf and neg is the same
        fstp    ST(0)
        fld     [_indefinite]                 ; log(infinity)=indefinite
        mov     eax,DOMAIN
        jmp     _ErrorHandling

not_infinity:                                 ; argument is QNaN or SNaN
        call    _convertTOStoQNaN             ; eax MUST contain high dword
        jmp     _ErrorHandling
test_if_x_zero:                               ; test if TOS is zero
        test    eax,000fffffH
        jnz     x_is_denormal                 ; denormal operand
        cmp     dword ptr[esp+8],0            ; test if low dword is zero
        jnz     x_is_denormal                 ; denormal operand

        fstp    ST(0)                         ; log(0)=-infinity
        fld     tbyte ptr[_minfinity]
        mov     eax,SING
;        jmp     _ErrorHandling

_ErrorHandling:
        cmp     __fastflag,0
        jnz     _fast_exit
        lea     ecx,[LOG_name]
ifdef _LOG10_
        mov     edx,OP_LOG10
else
        mov     edx,OP_LOG
endif
        call    _startOneArgErrorHandling
        pop     edx                           ; remove saved CW from stack
        ret

_IFUNC_        endp
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\i386\modf_pentium4.asm ===
; file: modf_wmt.asm

; Copyright  (C) 1985-2000 Intel Corporation.
;
; The information and source code contained herein is the exclusive property
; of Intel Corporation and may not be disclosed, examined, or reproduced in
; whole or in part without explicit written authorization from the Company.
;
; Implemented in VNIIEF-STL, july 2000

; double modf (double x, double *iptr)
; Returns the value of the signed fractional part of argument
;
; Willamette specific version (MASM 6.15 required)
;
; Description:
;  The modf functions break the argument value into integral and fractional parts,
;  each of which has the same type and sign as the argument. They store the integral
;  part (in floating-point format) in the object pointed to by iptr.
;
; Special cases:
;  modf(NaN,iptr) = that NaN and stores that NaN in the *iptr object
;  modf(INF,iptr) = 0 at the sign of x and stores that INF in the *iptr object
;
; Accuracy:
;  The result is always exact.

.xlist
        include cruntime.inc
.list

_FUNC_     equ  <modf>
_FUNC_DEF_ equ  <_modf_default>
_FUNC_P4_  equ  <_modf_pentium4>
_FUNC_DEF_EXTERN_ equ 1
        include disp_pentium4.inc

EXTRN C __libm_error_support : NEAR

      .const
      ALIGN 16

;-- 16x-aligned data --------------------------------------------------------

_Mantissa DQ 0000fffffffffffffH,0000fffffffffffffH
_Bns      DQ 00000000000000433H,00000000000000433H
_Sign     DQ 08000000000000000H,08000000000000000H
_Zero     DQ 00000000000000000H,00000000000000000H

      codeseg
      ALIGN 16

; double modf (double x, double *iptr);

; Stack frame locations

modf_x      TEXTEQU <esp+4>
modf_iptr   TEXTEQU <esp+12>
modf_result TEXTEQU <modf_x>
XMMWORD     TEXTEQU <OWORD>

PUBLIC _modf_pentium4
_modf_pentium4 PROC NEAR

    movq      xmm0, QWORD PTR [modf_x]           ; x
    movapd    xmm2, XMMWORD PTR _Bns             ;
    movapd    xmm3, xmm0                         ; x
    movapd    xmm1, xmm0                         ; x
    movapd    xmm4, xmm0                         ; x
    movapd    xmm6, xmm0
    psllq     xmm0, 1  ; exp(x)                  ; remove sign
    psrlq     xmm0, 53 ; exp(x)                  ; exp(x)
    psrlq     xmm3, 52 ; exp(x)                  ; sign(x) | exp(x)
    andpd     xmm4, XMMWORD PTR _Sign            ; sign(x)
    movd      eax, xmm0                          ; exp(x)
    psubd     xmm2, xmm0                         ;
    mov       ecx, DWORD PTR [modf_iptr]         ; iptr
    psrlq     xmm1, xmm2                         ; truncate
    psllq     xmm1, xmm2                         ; t = trunc(x)
    movd      edx, xmm3                          ; sign(x) | exp(x)

    cmp       eax, 03ffH                         ; if abs(x) < 1.0
    jl        SHORT ret_z                        ; case A
    cmp       eax, 0432H                         ; if abs(x) >=2**53
    jg        SHORT ret_xm                       ; case B

    movq      QWORD PTR [ecx], xmm1              ; *iptr = t
    subsd     xmm6, xmm1
    orpd      xmm6, xmm4                         ; set sign if frac = 0.0

    movq      QWORD PTR [modf_result], xmm6
    fld       QWORD PTR [modf_result]            ; return signed result
    ret                                          ;

ret_z: ; case A: |x|<1.0

    movq      QWORD PTR [ecx], xmm4              ; *iptr = properly-signed 0.0
    fld       QWORD PTR [modf_x]                 ;  return (X)
    ret                                          ;

ret_xm: ; case B: exp(x) >= 53

    cmp       eax, 07ffH                         ; check Inf (NaN)
    movq      xmm0, QWORD PTR [modf_x]           ; x
    je        SHORT ret_inf_nan                  ;

    movq      QWORD PTR [ecx], xmm0              ;

    cmp       edx, 800H                          ;
    fldz                                         ; if x is positive, return 0.0
    jl        SHORT return                       ;

    fchs                                         ; if x is negative, return -0.0

return:

    ret                                          ;

ret_inf_nan:

    movapd    xmm1, xmm0 
    addsd     xmm0, xmm0  
    movq      QWORD PTR [ecx], xmm0              ;
    andpd     xmm0, XMMWORD PTR _Mantissa        ;
    cmppd     xmm0, XMMWORD PTR _Zero, 4         ; Mask = (x == Inf) ? 0 : 1
    pextrw    eax,  xmm0, 0                      ; eax=(x==INF)? 0:1

    andpd     xmm0, xmm1                         ; t = Mask & x
    orpd      xmm0, xmm4                         ; t |= Sign(x)

    mov       edx, 1007
    cmp       eax, 0
    ; if NaN, call libm_error_support
    jnz       CALL_LIBM_ERROR

    movq      QWORD PTR [modf_result], xmm0      ;
    fld       QWORD PTR [modf_result]            ; return (t)
    ret                                          ;

CALL_LIBM_ERROR:
    ;call libm_error_support(void *arg1,void *arg2,void *retval,error_types input_tag)
    sub       esp, 28
    movlpd    QWORD PTR [esp+16], xmm0
    mov       DWORD PTR [esp+12],edx
    mov       edx, esp
    add       edx,16
    mov       DWORD PTR [esp+8],edx
    add       edx,16+8
    mov       DWORD PTR [esp+4],edx
    sub       edx, 8
    mov       DWORD PTR [esp],edx
    call      NEAR PTR __libm_error_support
;   movlpd    xmm0, QWORD PTR [esp+16]

;   movlpd    QWORD PTR [esp+16], xmm0           ; return result
    fld       QWORD PTR [esp+16]                 ;
    add       esp,28
    ret

_modf_pentium4 ENDP

    END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\i386\log10_pentium4.asm ===
;//
;//               INTEL CORPORATION PROPRIETARY INFORMATION
;//  This software is supplied under the terms of a license agreement or
;//  nondisclosure agreement with Intel Corporation and may not be copied
;//  or disclosed except in accordance with the terms of that agreement.
;//  Copyright (c) 2000 Intel Corporation. All Rights Reserved.
;//
;//
;    log10_wmt.asm
;
;    double log10(double);
;
;    Initial version: 11/30/2000
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; This is a second implementation of the branch-free log10 function     ;;
;; In this version, we use a trick to get the index j = 0,1,...,64 that  ;;
;; does not require integer testing. By adding 2^(42)-1 (FP) to Y, the   ;;
;; least 4 bits contains dob't cares and the 7 bits following that has   ;;
;; the range 0 to 64. Hence obtaining, say, the 16 lsb and masking off   ;;
;; everything except bit 4 through 10 gives the shifted index.           ;;
;; This saves an integer shift as well.                                  ;;
;;                                                                       ;;
;; Another important feature is that we use the table of log(1/B)        ;;
;; throughout. To ensure numerical accuracy, we only need to ensure that ;;
;; T(0)_hi = B(last)_hi, T(0)_lo = B(last)_lo. This ensures W_hi = 0 and ;;
;; W_lo = 0 exactly in the case of |X-1| <= 2^(-7).                      ;;
;; Finally, we do away with the need for extra-precision addition by the ;;
;; following observation. The three pieces at the end are                ;;
;; A = W_hi + r_hi; B = r_lo; C = P + W_lo.                              ;;
;; When W_hi = W_lo = 0, the addition sequence (A+B) + C is accurate as  ;;
;; the sum A+B is exact.                                                 ;;
;; Otherwise, A + (B+C) is accurate as B is going to be largely shifted  ;;
;; off compared to the final result.                                     ;;
;; Hence if we use compare and mask operations to                        ;;
;; create alpha = (r_lo or 0), beta = (0 or r_lo), Res_hi <- W_hi+alpha, ;;
;; Res_lo <- C + beta, then result is accurately computed as             ;;
;; Res_hi+Res_lo.                                                        ;;
;;                                                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

.686P
.387
.XMM
.MODEL FLAT,C

EXTRN C __libm_error_support : NEAR  

CONST SEGMENT PARA PUBLIC USE32 'CONST'
ALIGN 16

emask   DQ  000FFFFFFFFFFFFFH, 000FFFFFFFFFFFFFH ; mask off sign/expo field
CC      DQ  3FDBC00000000000H, 3FDBC00000000000H ; pair of C           
Magic   DQ  428FFFFFFFFFF810H, 428FFFFFFFFFF810H ; 2^(42)-1+2^(-7)
hi_mask DQ  7FFFFFFF80000000H, 7FFFFFFF80000000H ; maks of bottom 31 bits
LOG10_2 DQ  3FD34413509F7800H, 3D1FEF311F12B358H ; L_hi,L_lo -> [L_lo|L_hi]
place_L DQ  0000000000000000H,0FFFFFFFFFFFFFFFFH ; 0,1 -> [FF..FF|00..00]
        DQ 0FFFFFFFFFFFFFFFFH, 0000000000000000H ; 1,0 -> [00..00|FF..FF]
One 	DQ  3ff0000000000000H, 3ff0000000000000H ; 1,1 
Zero    DQ  0000000000000000H, 0000000000000000H ; 0,0
Two52   DQ  4330000000000000H, 4330000000000000H ; 2^52 for normalization
Infs    DQ 0FFF0000000000000H, 7FF0000000000000H ; -inf,+inf --> [+inf|-inf]
NaN     DQ  7FF0000000000001H, 7FF0000000000001H ; NaN for log(-ve), log(Nan)

coeff   DQ  40358914C697CEF9H, 0C00893096429813DH       ; p6,p3 ->[p3|p6]   
        DQ 0C025C9806A358455H,  3FFC6A02DC9635D2H       ; p5,p2 ->[p2|p5]   
        DQ  4016AB9F7E1899F7H, 0BFF27AF2DC77B135H       ; p4,p1 ->[p1|p4]  
        DQ  3F5A7A6CBF2E4108H,  0000000000000000H       ; p0,0  -> [0|p0]

;-------Table T_hi,T_lo  so that movapd gives [ T_lo | T_hi ]
T_Tbl     DQ 0000000000000000H, 0000000000000000H
          DQ 3F7C03A80AE40000H, 3D3E05382D51F71BH
          DQ 3F8B579DB6DE0000H, 3D386B09FEFB3005H
          DQ 3F9470AEDE968000H, 3D39FC780C91E11DH
          DQ 3F9ADA2E8E3E0000H, 3D351BD19E6E701AH
          DQ 3FA0ADD8F759C000H, 3D1B2A51090000A1H
          DQ 3FA3FAF7C6630000H, 3D083662F181F53FH
          DQ 3FA7171E59EFC000H, 3D16BD1A3FCF54DBH
          DQ 3FAA3E9002C70000H, 3D21D257C8D0D386H
          DQ 3FAD32332DC34000H, 3D1B7ADBF8D9441FH
          DQ 3FB0281170D6A000H, 3D1BF38B28AF5076H
          DQ 3FB19C1FECF16000H, 3D3EE03F1E5355D4H
          DQ 3FB3151BFD65C000H, 3D37E280048C6795H
          DQ 3FB4932780C56000H, 3D2FC4ACCD62A5F3H
          DQ 3FB605735EE98000H, 3D17C3CF23A17D9FH
          DQ 3FB76B778D4AA000H, 3D1C03E812A06E7AH
          DQ 3FB8D60B4EE4C000H, 3D3900E5CC4E4C82H
          DQ 3FBA33B422244000H, 3D36F17034675735H
          DQ 3FBB95B654A78000H, 3D290E5E24764EC7H
          DQ 3FBCEA2602E9E000H, 3CEBD129822ECBCBH
          DQ 3FBE42B4C16CA000H, 3D25E50FF38D4DE9H
          DQ 3FBF8D05B16A6000H, 3D2A8EA5A2B777A7H
          DQ 3FC06D9BC53C2000H, 3D32818DEEE1FA45H
          DQ 3FC10D3EACDE0000H, 3D1E8A45CB83F0AEH
          DQ 3FC1B83F1574D000H, 3D010B19F193FFD4H
          DQ 3FC251FE054FD000H, 3CFEAC09402877C0H
          DQ 3FC2F7301CF4E000H, 3D30F5C70D1A6341H
          DQ 3FC394700F795000H, 3D1FE93F791A7264H
          DQ 3FC4297453B4A000H, 3D3ECE09C5BC4B34H
          DQ 3FC4CA24FAFEC000H, 3D2E204342E66851H
          DQ 3FC5627512093000H, 3D30DFECB3AA172DH
          DQ 3FC5F21A1AF60000H, 3D3FEF1B2D3E6113H
          DQ 3FC68DA216900000H, 3CED942CFC9699D0H
          DQ 3FC720586C280000H, 3D3D20A8624054CDH
          DQ 3FC7B495FF1C5000H, 3D25012C689133C5H
          DQ 3FC83FA266CEA000H, 3D20C6C18687239FH
          DQ 3FC8CC0E0C56F000H, 3D36E3B4A1CFA0DFH
          DQ 3FC959DFEFE7D000H, 3D2420027AFFE0E5H
          DQ 3FC9E91F47D2C000H, 3D35330E6CF22420H
          DQ 3FCA6EA48B034000H, 3D33EBACB92B5B7FH
          DQ 3FCB00B7C552F000H, 3D3DF4694C64AA73H
          DQ 3FCB88E67CF97000H, 3D32FF232278A072H
          DQ 3FCC06E3BA2E4000H, 3D32CB15CD55BD7CH
          DQ 3FCC919DD46C0000H, 3D0EB64694E6AC72H
          DQ 3FCD11FB61139000H, 3D1A34DB91AE960BH
          DQ 3FCD9F59ABFD1000H, 3D207B23BCD76C73H
          DQ 3FCE163D527E6000H, 3D319D69F22E93E4H
          DQ 3FCE9A2CDC02A000H, 3D20EBF59081F187H
          DQ 3FCF1F5876949000H, 3D07AFEBEA179000H
          DQ 3FCF99801FDB7000H, 3D22737DF7F29668H
          DQ 3FD00A5B4509D000H, 3D1F6B5B2353257FH
          DQ 3FD0488037FBE800H, 3D1B6A93B9B912C6H
          DQ 3FD087315621A800H, 3D3261DA7DBFF3AEH
          DQ 3FD0C6711D6AB800H, 3D35E94A8D30C132H
          DQ 3FD0FFD9CDD2A800H, 3D16350EF6F19D80H
          DQ 3FD1402FBEC27800H, 3D313C204222BA8BH
          DQ 3FD17A9719699000H, 3D21F279212D5C99H
          DQ 3FD1B57A30AC5800H, 3D3DCF3E62FF847EH
          DQ 3FD1F0DB153AB800H, 3D27582E230C0EDFH
          DQ 3FD2260E4F424800H, 3D157E1028A41FF9H
          DQ 3FD26262A6117800H, 3D12B01A2E0C1912H
          DQ 3FD29871C043D800H, 3D2B3969AC9E3779H
          DQ 3FD2D5C1760B8000H, 3D3AEADEBE0F08BFH
          DQ 3FD30CB3A7BB3000H, 3D38929919B6D832H
          DQ 3FD34413509F7800H, 3D1FEF311F12B358H

;-----------------
CB_Tbl    DQ 3FDBC00000000000H, 3FDBC00000000000H  
          DQ 3FDB510000000000H, 3FDB510000000000H  
          DQ 3FDAE8F000000000H, 3FDAE8F000000000H  
          DQ 3FDA80E000000000H, 3FDA80E000000000H  
          DQ 3FDA1FC000000000H, 3FDA1FC000000000H  
          DQ 3FD9BEA000000000H, 3FD9BEA000000000H  
          DQ 3FD95D8000000000H, 3FD95D8000000000H  
          DQ 3FD9035000000000H, 3FD9035000000000H  
          DQ 3FD8A92000000000H, 3FD8A92000000000H  
          DQ 3FD855E000000000H, 3FD855E000000000H  
          DQ 3FD7FF2800000000H, 3FD7FF2800000000H  
          DQ 3FD7AF6000000000H, 3FD7AF6000000000H  
          DQ 3FD75F9800000000H, 3FD75F9800000000H  
          DQ 3FD70FD000000000H, 3FD70FD000000000H  
          DQ 3FD6C38000000000H, 3FD6C38000000000H  
          DQ 3FD67AA800000000H, 3FD67AA800000000H  
          DQ 3FD631D000000000H, 3FD631D000000000H  
          DQ 3FD5EC7000000000H, 3FD5EC7000000000H  
          DQ 3FD5A71000000000H, 3FD5A71000000000H  
          DQ 3FD5652800000000H, 3FD5652800000000H  
          DQ 3FD5234000000000H, 3FD5234000000000H  
          DQ 3FD4E4D000000000H, 3FD4E4D000000000H  
          DQ 3FD4A66000000000H, 3FD4A66000000000H  
          DQ 3FD46B6800000000H, 3FD46B6800000000H  
          DQ 3FD42CF800000000H, 3FD42CF800000000H  
          DQ 3FD3F57800000000H, 3FD3F57800000000H  
          DQ 3FD3BA8000000000H, 3FD3BA8000000000H  
          DQ 3FD3830000000000H, 3FD3830000000000H  
          DQ 3FD34EF800000000H, 3FD34EF800000000H  
          DQ 3FD3177800000000H, 3FD3177800000000H  
          DQ 3FD2E37000000000H, 3FD2E37000000000H  
          DQ 3FD2B2E000000000H, 3FD2B2E000000000H  
          DQ 3FD27ED800000000H, 3FD27ED800000000H  
          DQ 3FD24E4800000000H, 3FD24E4800000000H  
          DQ 3FD21DB800000000H, 3FD21DB800000000H  
          DQ 3FD1F0A000000000H, 3FD1F0A000000000H  
          DQ 3FD1C38800000000H, 3FD1C38800000000H  
          DQ 3FD1967000000000H, 3FD1967000000000H  
          DQ 3FD1695800000000H, 3FD1695800000000H  
          DQ 3FD13FB800000000H, 3FD13FB800000000H  
          DQ 3FD112A000000000H, 3FD112A000000000H  
          DQ 3FD0E90000000000H, 3FD0E90000000000H  
          DQ 3FD0C2D800000000H, 3FD0C2D800000000H  
          DQ 3FD0993800000000H, 3FD0993800000000H  
          DQ 3FD0731000000000H, 3FD0731000000000H  
          DQ 3FD0497000000000H, 3FD0497000000000H  
          DQ 3FD026C000000000H, 3FD026C000000000H  
          DQ 3FD0009800000000H, 3FD0009800000000H  
          DQ 3FCFB4E000000000H, 3FCFB4E000000000H  
          DQ 3FCF6F8000000000H, 3FCF6F8000000000H  
          DQ 3FCF2A2000000000H, 3FCF2A2000000000H  
          DQ 3FCEE4C000000000H, 3FCEE4C000000000H  
          DQ 3FCE9F6000000000H, 3FCE9F6000000000H  
          DQ 3FCE5A0000000000H, 3FCE5A0000000000H  
          DQ 3FCE1B9000000000H, 3FCE1B9000000000H  
          DQ 3FCDD63000000000H, 3FCDD63000000000H  
          DQ 3FCD97C000000000H, 3FCD97C000000000H  
          DQ 3FCD595000000000H, 3FCD595000000000H  
          DQ 3FCD1AE000000000H, 3FCD1AE000000000H  
          DQ 3FCCE36000000000H, 3FCCE36000000000H  
          DQ 3FCCA4F000000000H, 3FCCA4F000000000H  
          DQ 3FCC6D7000000000H, 3FCC6D7000000000H  
          DQ 3FCC2F0000000000H, 3FCC2F0000000000H  
          DQ 3FCBF78000000000H, 3FCBF78000000000H  
          DQ 3FCBC00000000000H, 3FCBC00000000000H  

ALIGN 16
CONST ENDS

$cmpsd MACRO op1, op2, op3
LOCAL begin_cmpsd, end_cmpsd
begin_cmpsd:
cmppd op1, op2, op3
end_cmpsd:
org begin_cmpsd
db 0F2h
org end_cmpsd
ENDM

_TEXT SEGMENT PARA PUBLIC USE32 'CODE'
    ALIGN 16

PUBLIC _log10_pentium4, _CIlog10_pentium4
_CIlog10_pentium4 PROC NEAR
push	    ebp
mov	    ebp, esp
sub         esp, 8                          ; for argument DBLSIZE
and         esp, 0fffffff0h
fstp        qword ptr [esp]
movq        xmm0, qword ptr [esp]
call        start
leave
ret


;----------------------;
;--Argument Reduction--;
;----------------------;

_log10_pentium4 label proc
movlpd    xmm0, QWORD PTR [4+esp]         ;... load X to low part of xmm0
start:
mov       edx,0                ;... set edx to 0 

DENORMAL_RETRY:

movapd    xmm5,xmm0
unpcklpd  xmm0,xmm0            ;... [X|X]

psrlq     xmm5,52
pextrw    ecx,xmm5,0

movapd    xmm1, QWORD PTR [emask]         ;... pair of 000FF...FF
movapd    xmm2, QWORD PTR [CC]            ;... pair of CC
movapd    xmm3, QWORD PTR [One]           ;... pair of 3FF000...000
movapd    xmm4, QWORD PTR [Magic]         ;... pair of 2^(42)-1+2^(-7)
movapd    xmm6, QWORD PTR [hi_mask]       ;... pair of 7FFFFFFF8000..00
andpd     xmm0,xmm1
orpd      xmm0,xmm3            ;... [Y|Y]
addpd     xmm4,xmm0            ;... 11 lsb contains the index to CB
                               ;... the last 4 lsb are don't cares, the
                               ;... 7 bits following that is the index
                               ;... Hence by masking, we already have index*16

pextrw    eax,xmm4,0
and       eax,000007F0H        ;... eax is offset
movapd    xmm4, QWORD PTR [eax+CB_Tbl]    ;... [CB|CB]
movapd    xmm7, QWORD PTR [eax+T_Tbl]

andpd     xmm6,xmm0            ;... [Y_hi|Y_hi]
subpd     xmm0,xmm6            ;... [Y_lo|Y_lo]
mulpd     xmm6,xmm4            ;... [CB*Y_hi|CB*Y_hi]
subpd     xmm6,xmm2            ;... [R_hi|R_hi]
addsd     xmm7,xmm6            ;... [T_lo|T_hi+R_hi]
mulpd     xmm0,xmm4            ;... [R_lo|R_lo]
movapd    xmm4,xmm0            ;... [R_lo|R_lo]
addpd     xmm0,xmm6            ;... [R|R]

;-----------------------------------------;
;--Approx and Reconstruction in parallel--;
;-----------------------------------------;

;...m is in ecx, [T_lo,T_hi+R_hi] in xmm7
;...xmm4 through xmm6 will be used
and       ecx,00000FFFH        ;... note we need sign and biased exponent
sub       ecx,1
cmp       ecx,2045             ;... the largest biased exponent 2046-1
                               ;... if ecx is ABOVE (unsigned) this, either
                               ;... the sign is +ve and biased exponent is 7FF
                               ;... or the sign is +ve and exponent is 0, or
                               ;... the sign is -ve (i.e. sign bit 1)
ja        SPECIAL_CASES

sub       ecx,1022             ;... m in integer format
add       ecx,edx              ;... this is the denormal adjustment

cvtsi2sd  xmm6,ecx
unpcklpd  xmm6,xmm6            ;... [m | m] in FP format

shl       ecx,10
add       eax,ecx              ;16*(64*m + j) 0 <=> (m=-1 & j=64) or (m=0 & j=0)
mov       ecx,16
mov       edx,0
cmp       eax,0
cmove     edx,ecx              ;this is the index into the mask table (place_{L,R})
 
movapd    xmm1, QWORD PTR [coeff]         ;... loading [p3|p6]
movapd    xmm3,xmm0
movapd    xmm2, QWORD PTR [coeff+16]      ;... loading [p2|p5]
mulpd     xmm1,xmm0            ;... [p3 R | p6 R]
mulpd     xmm3,xmm3            ;... [R^2|R^2]
addpd     xmm1,xmm2            ;... [p2+p3 R |p5+p6 R]
movapd    xmm2, QWORD PTR [coeff+32]      ;... [p1|p4]
mulsd     xmm3,xmm3            ;... [R^2|R^4]

movapd    xmm5, QWORD PTR [LOG10_2]       ;... loading [L_lo|L_hi]
                               ;... [T_lo|T_hi+R_hi] already in xmm7
mulpd     xmm6,xmm5            ;... [m L_lo | m L_hi]
movapd    xmm5, QWORD PTR [edx+place_L]   ;... [FF..FF|00.00] or [00..00|FF..FF]
andpd     xmm4,xmm5            ;... [R_lo|0] or [0|R_lo]
addpd     xmm7,xmm6            ;... [W_lo|W_hi]
addpd     xmm7,xmm4            ;... [A_lo|A_hi]

mulpd     xmm1,xmm0            ;... [p2 R+p3 R^2|p5 R+p6 R^2]
mulsd     xmm3,xmm0            ;... [R^2|R^5]
addpd     xmm1,xmm2            ;... [p1+.. | p4+...]
movapd    xmm2, QWORD PTR [coeff+48]      ;... [0|p0]
mulpd     xmm2,xmm0            ;... [0|p0 R]


movapd    xmm6,xmm7            
unpckhpd  xmm6,xmm6            ;... [*|A_lo]

mulpd     xmm1,xmm3            ;... [P_hi|P_lo]
sub esp, 16
movapd    xmm0,xmm1            ;... copy of [P_hi|P_lo]
addpd     xmm1,xmm2            ;... [P_hi|P_lo]
unpckhpd  xmm0,xmm0            ;... [P_hi|P_hi]

;...[P_hi|P_lo] in xmm1 at this point
addsd     xmm0,xmm1            ;... [*|P]
addsd     xmm0,xmm6
addsd     xmm0,xmm7

movlpd    QWORD PTR [esp+4], xmm0      ; return result
fld       QWORD PTR [esp+4]             ;
add esp, 16
	ret

SPECIAL_CASES:
movlpd    xmm0, QWORD PTR [4+esp]         ;... load X again
movapd    xmm1, QWORD PTR [Zero]
$cmpsd    xmm1,xmm0,0
pextrw    eax,xmm1,0           ;... ones if X = +-0.0
cmp       eax,0
ja        INPUT_ZERO

cmp       ecx,-1               ;... ecx = -1 iff X is positive denormal
je        INPUT_DENORM

cmp       ecx,000007FEH        
ja        INPUT_NEGATIVE

movlpd    xmm0, QWORD PTR [4+esp]
movapd    xmm1, QWORD PTR [emask]
movapd    xmm2, QWORD PTR [One]
andpd     xmm0,xmm1
orpd      xmm0,xmm2            ;... xmm0 is 1 iff the input argument was +inf
$cmpsd    xmm2,xmm0,0
pextrw    eax,xmm2,0           ;... 0 if X is NaN
cmp eax, 0
je        INPUT_NaN

INPUT_INF:
;....Input is +Inf
fld       QWORD PTR [Infs+8]             ;
	ret

INPUT_NaN:

; movlpd xmm0, [esp+4]
; addsd xmm0, xmm0
; sub esp, 16
; movlpd [esp+4], xmm0
; fld QWORD PTR [esp+4]
; add esp, 16
; ret
mov edx, 1001
jmp CALL_LIBM_ERROR

INPUT_ZERO:

	; raise Divide by Zero
	movlpd xmm2, QWORD PTR [One]
	divsd  xmm2, xmm0
	movlpd xmm1, QWORD PTR [Infs]
mov edx, 8
jmp CALL_LIBM_ERROR

INPUT_DENORM:

;....check for zero or denormal
;....for now I assume this is simply denormal
;....in reality, we need to check for zero and handle appropriately

movlpd    xmm1,Two52
mulsd     xmm0,xmm1
mov       edx,-52              ;...set adjustment to exponent
jmp       DENORMAL_RETRY         ;...branch back


INPUT_NEGATIVE:

add ecx,1
and ecx, 7ffH
cmp ecx, 7ffH
jae NEG_INF_NAN 

NEG_NORMAL_INFINITY:

; xmm1=0
xorpd xmm1, xmm1
; raise Invalid
divsd xmm1, xmm1
mov edx, 9

CALL_LIBM_ERROR:

;call libm_error_support(void *arg1,void *arg2,void *retval,error_types input_tag)
sub esp, 28
movlpd QWORD PTR [esp+16], xmm1
mov DWORD PTR [esp+12],edx
mov edx, esp
add edx,16
mov DWORD PTR [esp+8],edx
add edx,16
mov DWORD PTR [esp+4],edx
mov DWORD PTR [esp],edx
call NEAR PTR __libm_error_support
fld       QWORD PTR [esp+16]             ;
add esp,28
ret



NEG_INF_NAN:

  movlpd xmm2, QWORD PTR [esp+4]
  movlpd xmm0, QWORD PTR [esp+4]
  movd eax, xmm2
  psrlq xmm2, 32
  movd ecx, xmm2
  and ecx, 0fffffH ; eliminate sign/exponent
  or eax, ecx
  cmp eax,0
  jz NEG_NORMAL_INFINITY	; negative infinity

; addsd xmm0, xmm0
; sub esp,16
; movlpd QWORD PTR [esp+4], xmm0
; fld QWORD PTR [esp+4]
; add esp, 16
; ret
mov edx, 1001
jmp CALL_LIBM_ERROR
  

_CIlog10_pentium4 ENDP

ALIGN 16
_TEXT ENDS

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\i386\pow.asm ===
;***
;
;   Copyright (c) 1984-2001, Microsoft Corporation. All rights reserved.
;
;   Revision History:
;   01-26-01  PML   Pentium4 merge.
;   02-25-01  PML   Fix pow(+/-0,-denorm)
;
;*******************************************************************************

.xlist
        include cruntime.inc
        include elem87.inc
.list

_FUNC_     equ  <pow>
_FUNC_DEF_ equ  <_pow_default>
_FUNC_P4_  equ  <_pow_pentium4>
_FUNC_P4_EXTERN_ equ 1
        include disp_pentium4.inc

_FUNC_     equ  <_CIpow>
_FUNC_DEF_ equ  <_CIpow_default>
_FUNC_P4_  equ  <_CIpow_pentium4>
        include disp_pentium4.inc

        .data
globalQ _half,           03fe0000000000000R
POW_name db 'pow',0

extrn   _infinity:tbyte
extrn   _indefinite:tbyte
extrn   __fastflag:dword


        CODESEG

extrn   _startTwoArgErrorHandling:near
extrn   _fload_withFB:near
extrn   _convertTOStoQNaN:near
extrn   _checkTOS_withFB:near
extrn   _check_range_exit:near
extrn   _fast_exit:near
extrn   _load_CW:near
extrn   _powhlp:near
extrn   _twoToTOS:near

; arg1(base)   arg2(exponent)       ErrorType        result
;-----------------------------------------------------------
;infinity      not NaN                               called powhlp()
;not NaN       infinity                              called powhlp()
;QNaN          not SNaN             DOMAIN_QNAN      QNaN
;SNaN          any                  DOMAIN               
;
;*0           *0                    -                 1
;*0           positive,not odd      -                +0
;+0           positive, odd         -                +0
;-0           positive, odd         -                -0
;*0           negative,not odd      SING             infinity
;+0           negative, odd         SING             infinity
;-0           negative, odd         SING             -infinity
;negative     non-integer           DOMAIN           indefinite
;indefinite is                  like QNaN
;denormal(53)                   fld converts it to normal (64 bits)
;
; * in table above stands for both + and -
;
; if exponent field of result is 0, error type is set to UNDERFLOW
; if result is infinity, error type is set to OVERFLOW

        public        _CIpow_default,_pow_default
_CIpow_default proc
        sub     esp,2*DBLSIZE+4               ; prepare place for argument
        fxch    st(1)
        fstp    qword ptr [esp]               ; base
        fst     qword ptr [esp+8]             ; exponent
        mov     eax,[esp+12]                  ; high dword of exponent
        call    start
        add     esp,2*DBLSIZE+4               ; clean stack
        ret

_pow_default label        proc

        lea     edx,[esp+12]                  ; load exponent(arg2)
        call    _fload_withFB
start:
        mov     ecx,eax                       ; make copy of eax
        push    eax                           ; allocate space for Control Word
        fstcw   [esp]                         ; store Control Word
        cmp     word ptr[esp],default_CW
        je      CW_is_set_to_default
        call    _load_CW                      ; edx is destroyed
CW_is_set_to_default:
; at this point we have on stack: cw(4), ret_addr(4), arg1(8bytes), arg2(8bytes)
        and     ecx,7ff00000H
        lea     edx,[esp+8]                   ; edx points to arg1(base)

        cmp     ecx,7ff00000H
        je      special_exponent

        call    _fload_withFB                 ; edx already initialized
        jz      special_base
        test    eax,7ff00000H
        jz      test_if_we_have_zero_base
base_is_not_zero:
        mov     cl,[esp+15]                   ; cl will contain sign
        and     cl,80H                        ; test sign of base
        jnz     test_if_exp_is_int
normal:                                       ; denormal is like normal
        fyl2x                                 ; compute y*log2(x)
        call    _twoToTOS
        cmp     cl,1                          ; power was odd and base<0 ?
        jnz     exit
        fchs                                  ; if yes, we should change sign
exit:
        cmp     __fastflag,0
        jnz     _fast_exit

; prepare in registers arguments for math_exit
        lea     ecx,[POW_name]
        mov     edx,OP_POW
        jmp     _check_range_exit

_ErrorHandling:
        cmp     __fastflag,0
        jnz     _fast_exit

        lea     ecx,[POW_name]
        mov     edx,OP_POW
        call    _startTwoArgErrorHandling
        pop     edx                           ; remove saved CW from stack
        ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; some special cases
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 1.One of arguments is NaN
exponent_is_NAN:
        lea     edx,[esp+8]                   ; pointer to arg1(base)
        call    _fload_withFB                 ; load arg1 to FPU stack
        test    byte ptr[esp+22],08H          ; test if arg2(exponent) is SNaN
        jnz     SNaN_detected
        inc     ecx                           ; ecx!=0 when one of args is QNaN
        jmp     test_base

SNaN_detected:
        fadd
        mov     eax,DOMAIN
        jmp     _ErrorHandling

base_is_NAN:
        test    byte ptr[esp+14],08H          ; is it SNaN
        jnz     SNaN_detected
one_of_args_is_QNaN:
        fadd                                  ; one of args is QNaN, and second is not SNaN
        mov     eax,DOMAIN_QNAN
        jmp     _ErrorHandling

special_base:
; both arguments are loaded to FPU stack
        xor     ecx,ecx
        jmp     test_base

special_exponent:
; only one argument is loaded to FPU stack
        xor     ecx,ecx                       ; we use ecx to set flags
        and     eax,000fffffH                 ; eax=high
        or      eax,[esp+16]                  ; test whether mantissa is zero
        jne     exponent_is_NAN
        lea     edx,[esp+8]                   ; pointer to arg1(base)
        call    _fload_withFB                 ; load arg1(base) to FPU stack
test_base:                                    ; arg2 may be inf, QNaN or normal
; both arguments are loaded to FPU stack
        mov     eax,[esp+12]                  ; arg1 high
        mov     edx,eax
        and     eax,7ff00000H
        and     edx,000fffffH                 ; test mantissa of arg2
        cmp     eax,7ff00000H
        jne     end_of_tests
        or      edx,[esp+8]
        jnz     base_is_NAN                   ; arg1 is NaN,

end_of_tests:
        test    ecx,ecx
        jnz     one_of_args_is_QNaN           ; base is QNaN

; one of args is infinity and second is not NaN. In this case we use powhlp()
;_usepowhlp
        sub     esp, SBUFSIZE+8               ; get storage for _retval and savebuf
        mov     ecx, esp
        push    ecx                           ; push address for result

        sub     esp, 16
        fstp    qword ptr [esp]
        fstp    qword ptr [esp+8]

        fsave   [ecx+8]
        call    _powhlp
        add     esp, 16                       ; clear arguments if _cdecl.
        pop     ecx
        frstor  [ecx+8]
        fld     qword ptr [ecx]               ; load result on the NDP stack
        add     esp, SBUFSIZE+8               ; get rid of storage

        test    eax,eax
        jz      _fast_exit
        mov     eax,DOMAIN
        jmp     _ErrorHandling



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 2.  Base has zero exponent field
;
test_if_we_have_zero_base:
        mov     eax,[esp+12]
        and     eax,000fffffH
        or      eax,[esp+8]
        jnz     base_is_not_zero

; at this point we have two arguments on FPU stack.
; We know that TOS is zero, and arg2 is not special.
; We disinguish 3 cases:
;  (1) exponent is zero
;  (2) exponent is odd
;  (3) none of above

        fstp    st(0)                         ; remove zero from FPU stack
        mov     eax,[esp+20]                  ; test if arg2 is also zero
        and     eax,7fffffffh
        or      eax,[esp+16]
        jz      zero_to_zero
; check whether exponent is odd
        call    _test_whether_TOS_is_int
; cl=1 if exponent is odd,  2 - if even and 0 otherwise
        mov     ch,[esp+15]
        shr     ch,7                          ; ch==1 iff base is negative
        test    [esp+23],80H                  ; check sign of exponent
        jz      exp_is_positive
; exponent is negative
        fld     [_infinity]
        test    cl,ch
        jz      ret_inf
        fchs                                  ; base <0 and exponent is negative odd
ret_inf:
        mov     eax,SING
        jmp     _ErrorHandling

exp_is_positive:                              ; eax=error_code
        fldz
        test    cl,ch
        jz      _fast_exit
        fchs                                  ; base <0 and exponent positive is odd
        jmp     _fast_exit                    ; return -0.0

zero_to_zero:                                 ; arg1 and arg2 are zero
        fstp    st(0)                         ; remove useless argument from FPU stack
        fld1
        jmp     _fast_exit

;;;;;;;;;;;;;;;;;;;;;;;;;;;
;3. Base is negative.
;
;   If exponent is not integer it's a DOMAIN error
;

test_if_exp_is_int:
        fld     st(1)
        call    _test_whether_TOS_is_int
        fchs
        test    cl,cl
        jnz     normal
        fstp    st(0)
        fstp    st(0)
        fld     [_indefinite]
        mov     eax,DOMAIN
        jmp     _ErrorHandling

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;                _test_whether_TOS_is_int
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; returns in cl : 0,1,2 if TOS is non-int, odd int or even int respectively
;
_test_whether_TOS_is_int:
        fld     st(0)                         ; duplicate stack top
        frndint
        fcomp                                 ; is TOS integer???
        mov     cl,0                          ; prepare return value
        fstsw   ax
        sahf
        jne     _not_int                      ; TOS is not integer
        fmul    [_half]
        inc     cl                            ; cl>0, when exponent is integer
        fld     st(0)                         ; (exponent/2)
        frndint
        fcompp                                ; check if (exponent/2)==(int)(exponent/2)
        fstsw   ax
        sahf
        jne     _odd
        inc     cl                            ; sign that exponent is even
_odd:
        ret

_not_int:
        fstp    st(0)
        ret
_CIpow_default endp
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\i386\sin.asm ===
;***
;
;   Copyright (c) 1984-2001, Microsoft Corporation. All rights reserved.
;
;Revision History:
;
;*******************************************************************************

_SIN_ equ 1
include trig.asm
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\i386\pow_pentium4.asm ===
; Copyright  (C) 1985-2000 Intel Corporation.
;
; The information and source code contained herein is the exclusive property
; of Intel Corporation and may not be disclosed, examined, or reproduced in
; whole or in part without explicit written authorization from the Company.
;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;  pow_p4.asm
;
;  double pow(double,double);
;
;  Initial version: 01/10/2001
;  Update (bug fixes): 02/26/2001
;  Updated the underflow/overflow path 
;       to restore edi, esi in the correct order: 03/07/2001
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;  x=2^k*1.b1 b2...b6 b7 .. b52   x1=1.b1..b52
;;     f1=(b1 b2 ..b7 +1)/2
;;  x2=x1*rcp_t1[f1]=b'0.b'1 b'2 ... b'52 b'53  (b'53=0 if b'0=1)
;;     f2=(b'7 ..b'14 +1)/2
;;  x3=x2*rcp_t2[f2]=b"0.b"1 b"2 ... b"52 b"53   (b"53=0 if b"0=1)
;;     f3=(b"13 ..b"21+1)/2
;;  R=x3*rcp_t3[f3]
;;  rcp=rcp_t1[f1]*rcp_t2[f2]*rcp_t3[f3]  (exact multiplication)
;;  E=exact_mul(rcp*x1)-R
;;  R'=RN(R+E)
;;
;;  H=RN(RN(k+T1[f1]+T2[f2]+T3[f3]+R)+E)  (high part of log2(x) approximation)
;;  Rl+El=exact(k+T1[f1]+T2[f2]+T3[f3]+R+E)-H
;;
;;  Exponential evaluation started with approximate argument yH*HH (exact 
;;  product of the most significant 26 bits of y and H)
;;  Correction added to exponential reduced argument: 
;;    yH*HL+yL*HH+yL*HL+y*(D1+D2+D3+(Rl+El)+Pl14),
;;  where Pl14=cl1*R'+...+cl4*R'^4
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

    .686P
    .387
    .XMM
    .MODEL FLAT,C

EXTRN C __libm_error_support : NEAR

  

CONST SEGMENT PARA PUBLIC USE32 'CONST'
    ALIGN 16

rcp_t1	DQ 03ff0000000000000H, 03fefc08000000000H
	DQ 03fef820000000000H, 03fef448000000000H
	DQ 03fef07c000000000H, 03feecc0000000000H
	DQ 03fee914000000000H, 03fee574000000000H
	DQ 03fee1e0000000000H, 03fede5c000000000H
	DQ 03fedae8000000000H, 03fed77c000000000H
	DQ 03fed41c000000000H, 03fed0cc000000000H
	DQ 03fecd84000000000H, 03feca4c000000000H
	DQ 03fec71c000000000H, 03fec3f8000000000H
	DQ 03fec0e0000000000H, 03febdd4000000000H
	DQ 03febad0000000000H, 03feb7d8000000000H
	DQ 03feb4e8000000000H, 03feb204000000000H
	DQ 03feaf28000000000H, 03feac58000000000H
	DQ 03fea990000000000H, 03fea6d0000000000H
	DQ 03fea41c000000000H, 03fea16c000000000H
	DQ 03fe9ec8000000000H, 03fe9c2c000000000H
	DQ 03fe9998000000000H, 03fe9710000000000H
	DQ 03fe948c000000000H, 03fe9210000000000H
	DQ 03fe8f9c000000000H, 03fe8d30000000000H
	DQ 03fe8acc000000000H, 03fe8870000000000H
	DQ 03fe8618000000000H, 03fe83c8000000000H
	DQ 03fe8180000000000H, 03fe7f40000000000H
	DQ 03fe7d04000000000H, 03fe7ad4000000000H
	DQ 03fe78a4000000000H, 03fe767c000000000H
	DQ 03fe745c000000000H, 03fe7244000000000H
	DQ 03fe7030000000000H, 03fe6e20000000000H
	DQ 03fe6c18000000000H, 03fe6a14000000000H
	DQ 03fe6818000000000H, 03fe6620000000000H
	DQ 03fe642c000000000H, 03fe6240000000000H
	DQ 03fe6058000000000H, 03fe5e74000000000H
	DQ 03fe5c98000000000H, 03fe5ac0000000000H
	DQ 03fe58ec000000000H, 03fe5720000000000H
	DQ 03fe5554000000000H, 03fe5390000000000H
	DQ 03fe51d0000000000H, 03fe5014000000000H
	DQ 03fe4e60000000000H, 03fe4cac000000000H
	DQ 03fe4afc000000000H, 03fe4954000000000H
	DQ 03fe47b0000000000H, 03fe460c000000000H
	DQ 03fe4470000000000H, 03fe42d8000000000H
	DQ 03fe4140000000000H, 03fe3fb0000000000H
	DQ 03fe3e24000000000H, 03fe3c98000000000H
	DQ 03fe3b14000000000H, 03fe3990000000000H
	DQ 03fe3814000000000H, 03fe3698000000000H
	DQ 03fe3520000000000H, 03fe33b0000000000H
	DQ 03fe3240000000000H, 03fe30d0000000000H
	DQ 03fe2f68000000000H, 03fe2e04000000000H
	DQ 03fe2ca0000000000H, 03fe2b40000000000H
	DQ 03fe29e4000000000H, 03fe288c000000000H
	DQ 03fe2734000000000H, 03fe25e4000000000H
	DQ 03fe2494000000000H, 03fe2344000000000H
	DQ 03fe21fc000000000H, 03fe20b4000000000H
	DQ 03fe1f70000000000H, 03fe1e30000000000H
	DQ 03fe1cf0000000000H, 03fe1bb4000000000H
	DQ 03fe1a7c000000000H, 03fe1944000000000H
	DQ 03fe1810000000000H, 03fe16e0000000000H
	DQ 03fe15b0000000000H, 03fe1484000000000H
	DQ 03fe135c000000000H, 03fe1234000000000H
	DQ 03fe1110000000000H, 03fe0ff0000000000H
	DQ 03fe0ed0000000000H, 03fe0db4000000000H
	DQ 03fe0c98000000000H, 03fe0b80000000000H
	DQ 03fe0a68000000000H, 03fe0954000000000H
	DQ 03fe0844000000000H, 03fe0734000000000H
	DQ 03fe0624000000000H, 03fe0518000000000H
	DQ 03fe0410000000000H, 03fe0308000000000H
	DQ 03fe0204000000000H, 03fe0100000000000H
	DQ 03fe0000000000000H, 0

log2_t1 DQ 0, 0
	DQ 03f86fdf461d20000H, 03d3c9efc46d9f6f7H
	DQ 03f96e625317a0000H, 03d453f0e645614dbH
	DQ 03fa11a6297920000H, 03d4d925cd7d436d6H
	DQ 03fa6bb01a01f0000H, 03d3c995e7439db70H
	DQ 03fac4eb3635c8000H, 03d4a8192bdcad609H
	DQ 03fb0ea8b80338000H, 03d4e1797942f1be5H
	DQ 03fb3a9f062a90000H, 03d3011ef2e155a44H
	DQ 03fb665684ff80000H, 03d3084f28da93fafH
	DQ 03fb919bc335d0000H, 03d246082ed03fe7fH
	DQ 03fbbc6b9d7c04000H, 03d45b7e842652658H
	DQ 03fbe7272e1dc8000H, 03d4a2ea92333a25cH
	DQ 03fc08cd7820ec000H, 03d3543c511b40206H
	DQ 03fc1dc8f3a33c000H, 03d45598cab6d744cH
	DQ 03fc32b7a27af4000H, 03d07aba1fd6522b1H
	DQ 03fc476564c740000H, 03d4dc39f249b8f70H
	DQ 03fc5c04864906000H, 03d28c5d47e5f3668H
	DQ 03fc707a4ef786000H, 03d4f86ea591de6f8H
	DQ 03fc84c59fac38000H, 03d435cd351b14a77H
	DQ 03fc98e556aacc000H, 03d341c88d156ee10H
	DQ 03fcacf30032be000H, 03d2e3733debf9165H
	DQ 03fcc0d3213ae6000H, 03d4b15bcb18be2edH
	DQ 03fcd49f9d6d66000H, 03d30b557c2a12d29H
	DQ 03fce83c98a2d0000H, 03d442af5d10d18f2H
	DQ 03fcfbc44e396e000H, 03d47b3f928665437H
	DQ 03fd078d40936e000H, 03d38f1f608125902H
	DQ 03fd112ce25b29000H, 03d3c851c0f45bae5H
	DQ 03fd1ac0b77e3f000H, 03d3f97100b047ea3H
	DQ 03fd243a590d2b000H, 03d3c9b75e8e9d45dH
	DQ 03fd2db57ad935000H, 03cf934f5238ac23eH
	DQ 03fd37158be940000H, 03d4a16d142e3f4deH
	DQ 03fd40684445fb000H, 03d469ba14bfbfc6dH
	DQ 03fd49ad4a118d000H, 03d45cd377302cca5H
	DQ 03fd52d5be2114000H, 03d3a83640f883e4bH
	DQ 03fd5bfe367828000H, 03d49755c3dea7d5aH
	DQ 03fd6517e94738000H, 03d4e8a28223a67c4H
	DQ 03fd6e22792ef1000H, 03d314f240e7e9039H
	DQ 03fd771d87fd10000H, 03d258aaf31d36edbH
	DQ 03fd8008b6b297000H, 03d1605b88ccad976H
	DQ 03fd88e3a58a56000H, 03d2097ff572e71dfH
	DQ 03fd91bd19e695000H, 03d4dbb3ee4f6c667H
	DQ 03fd9a85babbe1000H, 03d4d889a0a61b2d6H
	DQ 03fda33d25fcb1000H, 03d4f5875d92c8dd6H
	DQ 03fdabe2f8ec96000H, 03d3c773190e2cc83H
	DQ 03fdb4865273ed000H, 03d4ab54a099e1f60H
	DQ 03fdbd07e0e781000H, 03d268ac21c0dcf20H
	DQ 03fdc5960ba6e1000H, 03d43b4bd96cb81feH
	DQ 03fdce1168b913000H, 03d2fada3055d19e2H
	DQ 03fdd679920231000H, 03d18ed5096e87504H
	DQ 03fddece20dffc000H, 03d43e26c2ced8aaaH
	DQ 03fde71ebad35f000H, 03d011609e08e95e1H
	DQ 03fdef6b3d3444000H, 03d40b35b2d1614faH
	DQ 03fdf7a349e747000H, 03d4a6e7081d99120H
	DQ 03fdffd6c9e8cc000H, 03cfa67452e86699dH
	DQ 03fe03fa97e79f000H, 03d275e12e74f8beeH
	DQ 03fe080748d542800H, 03d3b8c3b78ce0adbH
	DQ 03fe0c11650cf0000H, 03d461752eb1152a5H
	DQ 03fe1010826b18000H, 03d4ea3c98a07d258H
	DQ 03fe140ccdd4ae800H, 03d1fcada197ed2c1H
	DQ 03fe180633d744800H, 03d22551707e07a41H
	DQ 03fe1bf426e8e9800H, 03d376aff6c055f55H
	DQ 03fe1fdef5db3a000H, 03d4442de8501d871H
	DQ 03fe23c68c8201000H, 03d270c749129a57aH
	DQ 03fe27a23a05a8000H, 03d4cb0ea30b214a6H
	DQ 0bfda8f9d1c354000H, 0bd4604f54f4f9853H
	DQ 0bfda1506aee3b000H, 0bd44ff93dbb28c80H
	DQ 0bfd99ae48aa53000H, 0bd0e6ed7003dfdf5H
	DQ 0bfd9213957df2000H, 0bd3e186ac01b3f7fH
	DQ 0bfd8a9228a043000H, 0bd49bc20cf8dd883H
	DQ 0bfd8306ebf51c000H, 0bd45c8266e480596H
	DQ 0bfd7b83a057f9000H, 0bd35f4f79f443745H
	DQ 0bfd741a637fca000H, 0bd4025f49ff0180dH
	DQ 0bfd6cb99e7aa4000H, 0bd412b5ad5a7002aH
	DQ 0bfd654f5e853d000H, 0bd44c7008c4a72a7H
	DQ 0bfd5dfff91d34000H, 0bd3f544ed390ba95H
	DQ 0bfd56b9933779000H, 0bd391dc031bae772H
	DQ 0bfd4f69f5d830000H, 0bd38f36dd24bae46H
	DQ 0bfd483602143d000H, 0bce09c599a327931H
	DQ 0bfd410b98a0d4000H, 0bd156a3c28e8042aH
	DQ 0bfd39d83e4060000H, 0bd447f1643c10456H
	DQ 0bfd32c15f8b57000H, 0bd0d6ee2e01d9231H
	DQ 0bfd2ba1c0891f000H, 0bd3795076c3da632H
	DQ 0bfd249f2ada03000H, 0bd2a7809feb5964fH
	DQ 0bfd1d9406c900000H, 0bd4546d73ea7c032H
	DQ 0bfd16935d34fb000H, 0bd2151c6348d84a4H
	DQ 0bfd0fb093a3fd000H, 0bd2bacac000943a5H
	DQ 0bfd08c588cda7000H, 0bd43c72c4f78dfa1H
	DQ 0bfd01d228cf40000H, 0bd3c6972c813e541H
	DQ 0bfcf5faa7e71a000H, 0bd3d157620c552c1H
	DQ 0bfce867e093dc000H, 0bd366fa6f3fffcc0H
	DQ 0bfcdac50fe6d4000H, 0bd2b6484bb8f2009H
	DQ 0bfccd398e83e8000H, 0bd05f5cde492c839H
	DQ 0bfcbfc5c1d5be000H, 0bd2784900e42b538H
	DQ 0bfcb26a0fb83e000H, 0bd4a5b99e91f69b7H
	DQ 0bfca4fed5abba000H, 0bd45976e8062c61fH
	DQ 0bfc97d45e2448000H, 0bd401c636755cd02H
	DQ 0bfc8a9ad0948a000H, 0bd4c89ba64f25a55H
	DQ 0bfc7d520a4220000H, 0bd216a44d008a53dH
	DQ 0bfc704b6c17f0000H, 0bd413a806d56d6eeH
	DQ 0bfc633609cb64000H, 0bd33f125177ec11cH
	DQ 0bfc563adff6b0000H, 0bd4d0837079422c3H
	DQ 0bfc495a582ff2000H, 0bd3ebd9313709ef4H
	DQ 0bfc3c6b62529a000H, 0bd42d2b08296bf5cH
	DQ 0bfc2f9786ad2e000H, 0bd3b5188c2483623H
	DQ 0bfc22df302746000H, 0bd3048e3c2505d3dH
	DQ 0bfc1618c543b8000H, 0bd45b8d6a3b61bd1H
	DQ 0bfc096e5a2260000H, 0bd4bde98232d61f6H
	DQ 0bfbf9c0b5c568000H, 0bd4d3483b7a56256H
	DQ 0bfbe089492ee4000H, 0bd405589fcd57f86H
	DQ 0bfbc78bae5580000H, 0bd35351d0387c197H
	DQ 0bfbaec8bfaf64000H, 0bd3d13cbabea0e44H
	DQ 0bfb95eb24969c000H, 0bd3727fab299d747H
	DQ 0bfb7d49341a08000H, 0bd4eeef8bcf7aa55H
	DQ 0bfb64e3caa930000H, 0bd31aad2031e3ecaH
	DQ 0bfb4c647d2ea8000H, 0bceb43c4115c4fb7H
	DQ 0bfb3422b94a24000H, 0bd421b493a67e318H
	DQ 0bfb1bc75cf5a4000H, 0bd4d7db2139e8397H
	DQ 0bfb03aa8f8dc8000H, 0bd153121e9af5428H
	DQ 0bfad6e8ef48f8000H, 0bd38293c51765dbcH
	DQ 0bfaa6fbed7680000H, 0bd2b1c66db7cd724H
	DQ 0bfa778fdc1828000H, 0bd34378af2af5332H
	DQ 0bfa47f2e22550000H, 0bd2a424693c56dcdH
	DQ 0bfa18249a5368000H, 0bd441b0d5fdf534bH
	DQ 0bf9d1b35ee200000H, 0bd431fb72db4f24dH
	DQ 0bf97427d317a0000H, 0bd4700f14b03b093H
	DQ 0bf9163d20d100000H, 0bd46e8b9664fe33fH
	DQ 0bf872c1f4cf00000H, 0bd2b4934580fe573H
	DQ 0bf7709c46d780000H, 0bd4563ba56cde924H
	DQ 0H, 0H


rcp_t2	DQ 03ff0000000000000H, 03fefff4000000000H
	DQ 03feffe4000000000H, 03feffd4000000000H
	DQ 03feffc4000000000H, 03feffb4000000000H
	DQ 03feffa4000000000H, 03feff94000000000H
	DQ 03feff84000000000H, 03feff74000000000H
	DQ 03feff64000000000H, 03feff54000000000H
	DQ 03feff44000000000H, 03feff34000000000H
	DQ 03feff24000000000H, 03feff14000000000H
	DQ 03feff04000000000H, 03fefef4000000000H
	DQ 03fefee4000000000H, 03fefed4000000000H
	DQ 03fefec4000000000H, 03fefeb4000000000H
	DQ 03fefea4000000000H, 03fefe94000000000H
	DQ 03fefe84000000000H, 03fefe74000000000H
	DQ 03fefe64000000000H, 03fefe54000000000H
	DQ 03fefe44000000000H, 03fefe34000000000H
	DQ 03fefe24000000000H, 03fefe14000000000H
	DQ 03fefe04000000000H, 03fefdf4000000000H
	DQ 03fefde4000000000H, 03fefdd4000000000H
	DQ 03fefdc4000000000H, 03fefdb4000000000H
	DQ 03fefda4000000000H, 03fefd94000000000H
	DQ 03fefd84000000000H, 03fefd74000000000H
	DQ 03fefd64000000000H, 03fefd54000000000H
	DQ 03fefd44000000000H, 03fefd34000000000H
	DQ 03fefd28000000000H, 03fefd18000000000H
	DQ 03fefd08000000000H, 03fefcf8000000000H
	DQ 03fefce8000000000H, 03fefcd8000000000H
	DQ 03fefcc8000000000H, 03fefcb8000000000H
	DQ 03fefca8000000000H, 03fefc98000000000H
	DQ 03fefc88000000000H, 03fefc78000000000H
	DQ 03fefc68000000000H, 03fefc58000000000H
	DQ 03fefc48000000000H, 03fefc38000000000H
	DQ 03fefc28000000000H, 03fefc18000000000H
	DQ 03ff0100000000000H, 03ff00fc000000000H
	DQ 03ff00f8000000000H, 03ff00f4000000000H
	DQ 03ff00f0000000000H, 03ff00ec000000000H
	DQ 03ff00e8000000000H, 03ff00e4000000000H
	DQ 03ff00e0000000000H, 03ff00dc000000000H
	DQ 03ff00d8000000000H, 03ff00d4000000000H
	DQ 03ff00d0000000000H, 03ff00cc000000000H
	DQ 03ff00c8000000000H, 03ff00c4000000000H
	DQ 03ff00c0000000000H, 03ff00bc000000000H
	DQ 03ff00b8000000000H, 03ff00b4000000000H
	DQ 03ff00b0000000000H, 03ff00ac000000000H
	DQ 03ff00a8000000000H, 03ff00a4000000000H
	DQ 03ff00a0000000000H, 03ff009c000000000H
	DQ 03ff0098000000000H, 03ff0094000000000H
	DQ 03ff0090000000000H, 03ff008c000000000H
	DQ 03ff0088000000000H, 03ff0084000000000H
	DQ 03ff0080000000000H, 03ff007c000000000H
	DQ 03ff0078000000000H, 03ff0074000000000H
	DQ 03ff0070000000000H, 03ff006c000000000H
	DQ 03ff0068000000000H, 03ff0064000000000H
	DQ 03ff0060000000000H, 03ff005c000000000H
	DQ 03ff0058000000000H, 03ff0054000000000H
	DQ 03ff0050000000000H, 03ff004c000000000H
	DQ 03ff0048000000000H, 03ff0044000000000H
	DQ 03ff0040000000000H, 03ff003c000000000H
	DQ 03ff0038000000000H, 03ff0034000000000H
	DQ 03ff0030000000000H, 03ff002c000000000H
	DQ 03ff0028000000000H, 03ff0024000000000H
	DQ 03ff0020000000000H, 03ff001c000000000H
	DQ 03ff0018000000000H, 03ff0014000000000H
	DQ 03ff0010000000000H, 03ff000c000000000H
	DQ 03ff0008000000000H, 03ff0004000000000H
	DQ 03ff0000000000000H, 0


log2_t2 DQ 0, 0
	DQ 03f2150297c800000H, 03d210909f6306155H
	DQ 03f34332be0000000H, 03d09518ce032f41dH
	DQ 03f3fbe9f60c00000H, 03d4ac9bc570c3b37H
	DQ 03f45a537a3600000H, 03d4325006127af86H
	DQ 03f4b6b4dcbc00000H, 03d3c621fbc9e2ad6H
	DQ 03f5098c916300000H, 03d3f7aec2cad082aH
	DQ 03f537c0264100000H, 03d4bdf2754a94bbeH
	DQ 03f565f52d1000000H, 03d46f089976214ecH
	DQ 03f5942ba5e700000H, 03d2645f4fefad48aH
	DQ 03f5c26390dc00000H, 03d394ecb87dff47fH
	DQ 03f5f09cee0700000H, 03d415d326245addfH
	DQ 03f60f6bdebf80000H, 03d492366d5b7121cH
	DQ 03f62689ffae00000H, 03d3360481790324fH
	DQ 03f63da8d9da00000H, 03d31fe61b7973265H
	DQ 03f654c86d4f00000H, 03d4d5202bf82be32H
	DQ 03f66be8ba1980000H, 03d3a5f8d1a33f641H
	DQ 03f68309c04400000H, 03d4f65693283bc5bH
	DQ 03f69a2b7fdb00000H, 03d4b05a072311cdeH
	DQ 03f6b14df8ea00000H, 03d2da3ce84a38084H
	DQ 03f6c8712b7c00000H, 03d385b88ccf9e4bcH
	DQ 03f6df95179d00000H, 03d4138577c1eb13eH
	DQ 03f6f6b9bd5880000H, 03d4eb2dd71123ec2H
	DQ 03f706ef8e5d40000H, 03d4d0d7b6d01207aH
	DQ 03f712829ae740000H, 03d44fe53f52c6d10H
	DQ 03f71e16045000000H, 03d3f031f657d9491H
	DQ 03f729a9ca9d40000H, 03d45d9663a7e7da0H
	DQ 03f7353dedd500000H, 03d418e26d5dfd1bfH
	DQ 03f740d26dfd00000H, 03d38dc829af0262cH
	DQ 03f74c674b1b00000H, 03d408e4eb4d165e5H
	DQ 03f757fc853500000H, 03d3092346f3f705eH
	DQ 03f763921c5080000H, 03d4e3fa9e85711eeH
	DQ 03f76f281073c0000H, 03d4d59479023862bH
	DQ 03f77abe61a480000H, 03d40c38980430771H
	DQ 03f786550fe880000H, 03d1f92db260b1230H
	DQ 03f791ec1b4580000H, 03d150038c4b502c5H
	DQ 03f79d8383c140000H, 03d48cd3d7b281721H
	DQ 03f7a91b496200000H, 03d42c11f472c64baH
	DQ 03f7b4b36c2d40000H, 03d4d0945eaf29dd2H
	DQ 03f7c04bec2940000H, 03d21e7318833be77H
	DQ 03f7cbe4c95b40000H, 03d462d58105ef8bfH
	DQ 03f7d77e03c980000H, 03d4f85219e901c30H
	DQ 03f7e3179b7a00000H, 03d3c51fbafc4227cH
	DQ 03f7eeb1907240000H, 03d400766896bf3baH
	DQ 03f7fa4be2b840000H, 03d43558362ba179cH
	DQ 03f802f3492900000H, 03d2a3ccb5f4b8d2aH
	DQ 03f8074d69a3c0000H, 03d490b788dcc06d5H
	DQ 03f80d1b1320e0000H, 03d2b412556cf5977H
	DQ 03f812e8eb4fc0000H, 03d45c237732b1f78H
	DQ 03f818b6f23380000H, 03d45669defd365c1H
	DQ 03f81e8527cf00000H, 03d4589b8de73054bH
	DQ 03f824538c2540000H, 03d28fab914103d9cH
	DQ 03f82a221f3900000H, 03d47df970829f58aH
	DQ 03f82ff0e10d60000H, 03d4b0d87d80e4623H
	DQ 03f835bfd1a560000H, 03cf61343d497e17fH
	DQ 03f83b8ef103a0000H, 03d49f7f4ef56f96bH
	DQ 03f8415e3f2b60000H, 03d4859d5f817f2faH
	DQ 03f8472dbc1f80000H, 03d3b2734e7bf7114H
	DQ 03f84cfd67e2e0000H, 03d3753903d1eeba1H
	DQ 03f852cd427880000H, 03d23a058a8f8ba37H
	DQ 03f8589d4be340000H, 03d37c2ec6bdcca43H
	DQ 03f85e6d842620000H, 03d43701d45acf2c4H
	DQ 03f8643deb4420000H, 03d3d6b197832ab27H
	DQ 03f86a0e814020000H, 03d411a9b5557b8ccH
	DQ 0bf7709c46d780000H, 0bd4563ba56cde924H
	DQ 0bf76adca91cc0000H, 0bd37a1a05bc6b74bH
	DQ 0bf7651cf479c0000H, 0bd461bfa6c8b2465H
	DQ 0bf75f5d28ee00000H, 0bd48fc8fd49e79d0H
	DQ 0bf7599d4678c0000H, 0bd4925a3c7b88c7cH
	DQ 0bf753dd4d1940000H, 0bd4b4606033fb2beH
	DQ 0bf74e1d3ccf00000H, 0bd20210971a52753H
	DQ 0bf7485d1598c0000H, 0bd4812a07c384c12H
	DQ 0bf7429cd77640000H, 0bd4c07239b769baaH
	DQ 0bf73cdc8266c0000H, 0bd44838a3ea90181H
	DQ 0bf7371c166980000H, 0bd288537c7f77e67H
	DQ 0bf7315b937d80000H, 0bd4575a30536968cH
	DQ 0bf72b9af9a280000H, 0bd2c45e11e2e7675H
	DQ 0bf725da48d740000H, 0bd4f8176c38b4ce6H
	DQ 0bf72019811bc0000H, 0bd1a700bd79ac8a3H
	DQ 0bf71a58a26e80000H, 0bd46fb3522850043H
	DQ 0bf71497accf40000H, 0bd4f08e7ddd3e76fH
	DQ 0bf70ed6a03d40000H, 0bd4ff2a8fb0fa804H
	DQ 0bf709157cb7c0000H, 0bd4e2fc0aec80d04H
	DQ 0bf70354423e00000H, 0bd4e332fcfabff4fH
	DQ 0bf6fb25e19f00000H, 0bd21aebe490c8214H
	DQ 0bf6efa310d600000H, 0bd4543b144a21404H
	DQ 0bf6e420122080000H, 0bd45215e0a197589H
	DQ 0bf6d89ce57d00000H, 0bd30cd2d2dbef9ddH
	DQ 0bf6cd198ae980000H, 0bd4370f2ebb44e84H
	DQ 0bf6c196026500000H, 0bd4a99c21180f792H
	DQ 0bf6b6124bee80000H, 0bd11b04ea788b3a9H
	DQ 0bf6aa8e678380000H, 0bd3d2d0d040e5bb2H
	DQ 0bf69f0a552380000H, 0bd201eaa7eae8a79H
	DQ 0bf6938614cc80000H, 0bd2b467aacd98f5bH
	DQ 0bf68801a67d00000H, 0bd4b3840d3f33c6bH
	DQ 0bf67c7d0a3480000H, 0bd25ec92da83377dH
	DQ 0bf670f83ff080000H, 0bd33ab2631d4676dH
	DQ 0bf6657347b000000H, 0bd38fd1349b69dfeH
	DQ 0bf659ee217180000H, 0bd41a8baa44fb97dH
	DQ 0bf64e68cd3380000H, 0bd4d828cbc5c5ff3H
	DQ 0bf642e34af500000H, 0bd44361aa8b3c316H
	DQ 0bf6375d9ab400000H, 0bd49e932f704de99H
	DQ 0bf62bd7bc6f80000H, 0bd42bd57c254b5e3H
	DQ 0bf62051b02600000H, 0bd167df372942ee0H
	DQ 0bf614cb75d580000H, 0bd3c729ec54d36cdH
	DQ 0bf609450d7d00000H, 0bd490ea5c63bcdf1H
	DQ 0bf5fb7cee3700000H, 0bd2d803cea0e76a9H
	DQ 0bf5e46f655d00000H, 0bd4d398b96b4f4d5H
	DQ 0bf5cd61806b00000H, 0bd4ea2cca3058bbdH
	DQ 0bf5b6533f5e00000H, 0bd3f3e6ba7bbdd88H
	DQ 0bf59f44a23200000H, 0bd442ddc05082614H
	DQ 0bf58835a8e500000H, 0bd40498534d8fe6dH
	DQ 0bf57126537400000H, 0bd2fa2a0fd4fca1cH
	DQ 0bf55a16a1db00000H, 0bd4efd6c9949b49bH
	DQ 0bf54306941900000H, 0bd4975aa0b715781H
	DQ 0bf52bf62a2a00000H, 0bd4b3ae86d7c16e7H
	DQ 0bf514e5640c00000H, 0bd3064bec2477c3fH
	DQ 0bf4fba8837600000H, 0bd20f3d834ceb438H
	DQ 0bf4cd85866800000H, 0bd433742d88c7aa2H
	DQ 0bf49f61d0ea00000H, 0bd48f98b25223470H
	DQ 0bf4713d62f600000H, 0bd4957c30af53ad3H
	DQ 0bf443183c8600000H, 0bd48218d1305b92fH
	DQ 0bf414f25d9400000H, 0bd492239f241b9b9H
	DQ 0bf3cd978c3800000H, 0bcd0642236ea2a75H
	DQ 0bf37148ec2800000H, 0bd40dfe447087803H
	DQ 0bf314f8daf400000H, 0bd3e3bcf284f9cb2H
	DQ 0bf2714eb11800000H, 0bd4e94d8dd523885H
	DQ 0bf1715193b000000H, 0bd17d35d328b2afeH
	DQ 0, 0

rcp_t3	DQ 03ff7154740000000H, 03ff71545c0000000H
	DQ 03ff7154440000000H, 03ff7154300000000H
	DQ 03ff7154180000000H, 03ff7154000000000H
	DQ 03ff7153e80000000H, 03ff7153d40000000H
	DQ 03ff7153bc0000000H, 03ff7153a40000000H
	DQ 03ff71538c0000000H, 03ff7153780000000H
	DQ 03ff7153600000000H, 03ff7153480000000H
	DQ 03ff7153300000000H, 03ff7153180000000H
	DQ 03ff7153040000000H, 03ff7152ec0000000H
	DQ 03ff7152d40000000H, 03ff7152bc0000000H
	DQ 03ff7152a80000000H, 03ff7152900000000H
	DQ 03ff7152780000000H, 03ff7152600000000H
	DQ 03ff71524c0000000H, 03ff7152340000000H
	DQ 03ff71521c0000000H, 03ff7152040000000H
	DQ 03ff7151ec0000000H, 03ff7151d80000000H
	DQ 03ff7151c00000000H, 03ff7151a80000000H
	DQ 03ff7151900000000H, 03ff71517c0000000H
	DQ 03ff7151640000000H, 03ff71514c0000000H
	DQ 03ff7151340000000H, 03ff71511c0000000H
	DQ 03ff7151080000000H, 03ff7150f00000000H
	DQ 03ff7150d80000000H, 03ff7150c00000000H
	DQ 03ff7150ac0000000H, 03ff7150940000000H
	DQ 03ff71507c0000000H, 03ff7150640000000H
	DQ 03ff7150500000000H, 03ff7150380000000H
	DQ 03ff7150200000000H, 03ff7150080000000H
	DQ 03ff714ff00000000H, 03ff714fdc0000000H
	DQ 03ff714fc40000000H, 03ff714fac0000000H
	DQ 03ff714f940000000H, 03ff714f800000000H
	DQ 03ff714f680000000H, 03ff714f500000000H
	DQ 03ff714f380000000H, 03ff714f240000000H
	DQ 03ff714f0c0000000H, 03ff714ef40000000H
	DQ 03ff714edc0000000H, 03ff714ec40000000H
	DQ 03ff714eb00000000H, 03ff714e980000000H
	DQ 03ff714e800000000H, 03ff714e680000000H
	DQ 03ff714e540000000H, 03ff714e3c0000000H
	DQ 03ff714e240000000H, 03ff714e0c0000000H
	DQ 03ff714df80000000H, 03ff714de00000000H
	DQ 03ff714dc80000000H, 03ff714db00000000H
	DQ 03ff714d980000000H, 03ff714d840000000H
	DQ 03ff714d6c0000000H, 03ff714d540000000H
	DQ 03ff714d3c0000000H, 03ff714d280000000H
	DQ 03ff714d100000000H, 03ff714cf80000000H
	DQ 03ff714ce00000000H, 03ff714ccc0000000H
	DQ 03ff714cb40000000H, 03ff714c9c0000000H
	DQ 03ff714c840000000H, 03ff714c6c0000000H
	DQ 03ff714c580000000H, 03ff714c400000000H
	DQ 03ff714c280000000H, 03ff714c100000000H
	DQ 03ff714bfc0000000H, 03ff714be40000000H
	DQ 03ff714bcc0000000H, 03ff714bb40000000H
	DQ 03ff714ba00000000H, 03ff714b880000000H
	DQ 03ff714b700000000H, 03ff714b580000000H
	DQ 03ff714b400000000H, 03ff714b2c0000000H
	DQ 03ff714b140000000H, 03ff714afc0000000H
	DQ 03ff714ae40000000H, 03ff714ad00000000H
	DQ 03ff714ab80000000H, 03ff714aa00000000H
	DQ 03ff714a880000000H, 03ff714a740000000H
	DQ 03ff714a5c0000000H, 03ff714a440000000H
	DQ 03ff714a2c0000000H, 03ff714a140000000H
	DQ 03ff714a000000000H, 03ff7149e80000000H
	DQ 03ff7149d00000000H, 03ff7149b80000000H
	DQ 03ff7149a40000000H, 03ff71498c0000000H
	DQ 03ff7149740000000H, 03ff71495c0000000H
	DQ 03ff7149480000000H, 03ff7149300000000H
	DQ 03ff7149180000000H, 03ff7149000000000H
	DQ 03ff715a380000000H, 03ff715a2c0000000H
	DQ 03ff715a240000000H, 03ff715a180000000H
	DQ 03ff715a0c0000000H, 03ff715a000000000H
	DQ 03ff7159f40000000H, 03ff7159e80000000H
	DQ 03ff7159dc0000000H, 03ff7159d00000000H
	DQ 03ff7159c40000000H, 03ff7159bc0000000H
	DQ 03ff7159b00000000H, 03ff7159a40000000H
	DQ 03ff7159980000000H, 03ff71598c0000000H
	DQ 03ff7159800000000H, 03ff7159740000000H
	DQ 03ff7159680000000H, 03ff7159600000000H
	DQ 03ff7159540000000H, 03ff7159480000000H
	DQ 03ff71593c0000000H, 03ff7159300000000H
	DQ 03ff7159240000000H, 03ff7159180000000H
	DQ 03ff71590c0000000H, 03ff7159000000000H
	DQ 03ff7158f80000000H, 03ff7158ec0000000H
	DQ 03ff7158e00000000H, 03ff7158d40000000H
	DQ 03ff7158c80000000H, 03ff7158bc0000000H
	DQ 03ff7158b00000000H, 03ff7158a40000000H
	DQ 03ff7158980000000H, 03ff7158900000000H
	DQ 03ff7158840000000H, 03ff7158780000000H
	DQ 03ff71586c0000000H, 03ff7158600000000H
	DQ 03ff7158540000000H, 03ff7158480000000H
	DQ 03ff71583c0000000H, 03ff7158300000000H
	DQ 03ff7158280000000H, 03ff71581c0000000H
	DQ 03ff7158100000000H, 03ff7158040000000H
	DQ 03ff7157f80000000H, 03ff7157ec0000000H
	DQ 03ff7157e00000000H, 03ff7157d40000000H
	DQ 03ff7157cc0000000H, 03ff7157c00000000H
	DQ 03ff7157b40000000H, 03ff7157a80000000H
	DQ 03ff71579c0000000H, 03ff7157900000000H
	DQ 03ff7157840000000H, 03ff7157780000000H
	DQ 03ff71576c0000000H, 03ff7157640000000H
	DQ 03ff7157580000000H, 03ff71574c0000000H
	DQ 03ff7157400000000H, 03ff7157340000000H
	DQ 03ff7157280000000H, 03ff71571c0000000H
	DQ 03ff7157100000000H, 03ff7157040000000H
	DQ 03ff7156fc0000000H, 03ff7156f00000000H
	DQ 03ff7156e40000000H, 03ff7156d80000000H
	DQ 03ff7156cc0000000H, 03ff7156c00000000H
	DQ 03ff7156b40000000H, 03ff7156a80000000H
	DQ 03ff7156a00000000H, 03ff7156940000000H
	DQ 03ff7156880000000H, 03ff71567c0000000H
	DQ 03ff7156700000000H, 03ff7156640000000H
	DQ 03ff7156580000000H, 03ff71564c0000000H
	DQ 03ff7156400000000H, 03ff7156380000000H
	DQ 03ff71562c0000000H, 03ff7156200000000H
	DQ 03ff7156140000000H, 03ff7156080000000H
	DQ 03ff7155fc0000000H, 03ff7155f00000000H
	DQ 03ff7155e40000000H, 03ff7155d80000000H
	DQ 03ff7155d00000000H, 03ff7155c40000000H
	DQ 03ff7155b80000000H, 03ff7155ac0000000H
	DQ 03ff7155a00000000H, 03ff7155940000000H
	DQ 03ff7155880000000H, 03ff71557c0000000H
	DQ 03ff7155700000000H, 03ff7155680000000H
	DQ 03ff71555c0000000H, 03ff7155500000000H
	DQ 03ff7155440000000H, 03ff7155380000000H
	DQ 03ff71552c0000000H, 03ff7155200000000H
	DQ 03ff7155140000000H, 03ff71550c0000000H
	DQ 03ff7155000000000H, 03ff7154f40000000H
	DQ 03ff7154e80000000H, 03ff7154dc0000000H
	DQ 03ff7154d00000000H, 03ff7154c40000000H
	DQ 03ff7154b80000000H, 03ff7154ac0000000H
	DQ 03ff7154a40000000H, 03ff7154980000000H
	DQ 03ff71548c0000000H, 03ff7154800000000H
	DQ 03ff7154740000000H, 0

log2_t3	DQ 0, 0
	DQ 03eb80000c0000000H, 03d4722f0009be959H
	DQ 03ec80001a0000000H, 03d45e6576cb6dc2eH
	DQ 03ed10001a0000000H, 03d480762a98bdb6aH
	DQ 03ed7000300000000H, 03d231a4c495ec799H
	DQ 03edd0004b0000000H, 03d4926846928cda3H
	DQ 03ee1800368000000H, 03d4527509fdde667H
	DQ 03ee4000470000000H, 03d44fbd1292ae6daH
	DQ 03ee70005d8000000H, 03d4ef91cb226fd03H
	DQ 03eea000778000000H, 03d40978c9dc43b2eH
	DQ 03eed000948000000H, 03d33ae75bbe97951H
	DQ 03eef800af0000000H, 03d2d81b9a1639c05H
	DQ 03ef140068c000000H, 03d3d3aa4a1dd8452H
	DQ 03ef2c007b8000000H, 03d4d7bbe110bfb09H
	DQ 03ef4400900000000H, 03d43fbcb9ab61086H
	DQ 03ef5c00a60000000H, 03d421d94dff79062H
	DQ 03ef7000b98000000H, 03d43b8e9647408a2H
	DQ 03ef8800d24000000H, 03d4fd8ce39e1fdd4H
	DQ 03efa000ecc000000H, 03d439ab84e20bc42H
	DQ 03efb80108c000000H, 03d3dfd83269c6ac2H
	DQ 03efcc01214000000H, 03d3ca32ecd8004e0H
	DQ 03efe401400000000H, 03d47b472936c6005H
	DQ 03effc01608000000H, 03d31736ce8ef8e21H
	DQ 03f00a00c14000000H, 03d0617cfc138ccabH
	DQ 03f01400cfe000000H, 03d4e6d11d620108aH
	DQ 03f02000e26000000H, 03d2451827455b88dH
	DQ 03f02c00f58000000H, 03d435e7b8e426950H
	DQ 03f03801098000000H, 03d3296f937d77647H
	DQ 03f044011e4000000H, 03d2b6df6e16cae71H
	DQ 03f04e01302000000H, 03d2ff9376a2ea421H
	DQ 03f05a01464000000H, 03d438ebd204c10d2H
	DQ 03f066015d4000000H, 03d2b09d7e2fc6debH
	DQ 03f07201750000000H, 03d099925641f4f35H
	DQ 03f07c01896000000H, 03cedfbf4f07288e3H
	DQ 03f08801a28000000H, 03d32a0616748ca2aH
	DQ 03f09401bc6000000H, 03d49cc1e9cba43abH
	DQ 03f0a001d72000000H, 03d41ebd38173f5dbH
	DQ 03f0ac01f2a000000H, 03d41af6954471a92H
	DQ 03f0b6020a2000000H, 03d44a88bd59f4b89H
	DQ 03f0c202272000000H, 03d137160b27044e6H
	DQ 03f0ce0244c000000H, 03d47d7f6c97ef2fcH
	DQ 03f0da02634000000H, 03d44e605e1bb0db2H
	DQ 03f0e4027d4000000H, 03d459d8417d4ebcfH
	DQ 03f0f0029d4000000H, 03cf5ca7f05f05027H
	DQ 03f0fc02bde000000H, 03d4363b1c234f566H
	DQ 03f104016fb000000H, 03d3b7b6ed1035771H
	DQ 03f109017df000000H, 03d38699e204367efH
	DQ 03f10f018f6000000H, 03d44924bd9581118H
	DQ 03f11501a14000000H, 03d2252e80eb13b47H
	DQ 03f11b01b37000000H, 03d4c3c3381ce38a0H
	DQ 03f12101c61000000H, 03d4b88d24672a90dH
	DQ 03f12601d5e000000H, 03d4e1fc955055fefH
	DQ 03f12c01e94000000H, 03d36e18a547f3bc2H
	DQ 03f13201fd0000000H, 03ce9cbf2c6119ad4H
	DQ 03f13802111000000H, 03d4d03232a579871H
	DQ 03f13d02222000000H, 03d4d5c820ab96aa1H
	DQ 03f14302370000000H, 03d2ff6235a37497cH
	DQ 03f149024c3000000H, 03d4a4461e61bb95eH
	DQ 03f14f0261d000000H, 03d4431272c3ec2f0H
	DQ 03f15402742000000H, 03d424e2b9e3a8113H
	DQ 03f15a028a7000000H, 03d4a40baad7a3180H
	DQ 03f16002a13000000H, 03d33b2fef1b1988bH
	DQ 03f16602b85000000H, 03d01893f34559377H
	DQ 03f16c02cfc000000H, 03d4ffe120fb3ef44H
	DQ 03f17102e3b000000H, 03d120082c162d124H
	DQ 03f17702fbe000000H, 03d3e587c5b282967H
	DQ 03f17d03148000000H, 03d1df8f956673eacH
	DQ 03f183032d7000000H, 03d4ff8cd42de4f13H
	DQ 03f1880342a000000H, 03c83f84104915062H
	DQ 03f18e035c5000000H, 03d3484a765ad0e81H
	DQ 03f19403766000000H, 03d4c2a7e827b5b7cH
	DQ 03f19a0390e000000H, 03d45b9d9e619a5feH
	DQ 03f19f03a74000000H, 03d4389fde2d65d47H
	DQ 03f1a503c27000000H, 03d4b2175bb6d7bccH
	DQ 03f1ab03de1000000H, 03d34c0cf5c760a80H
	DQ 03f1b103fa1000000H, 03d046edae6d3e9a5H
	DQ 03f1b704166000000H, 03d4fd521af377bfcH
	DQ 03f1bc042e6000000H, 03d0cf59fe6ab1bfdH
	DQ 03f1c2044b7000000H, 03d3ccd20cc753db5H
	DQ 03f1c80468f000000H, 03d152df2a92669ccH
	DQ 03f1ce0486c000000H, 03d4e8cfdbe6ff5d7H
	DQ 03f1d3049ff000000H, 03d4e51b637245449H
	DQ 03f1d904be9000000H, 03d30855ccdda9dd0H
	DQ 03f1df04dd8000000H, 03d49dc0197d07430H
	DQ 03f1e504fce000000H, 03d431dc9bd27e20aH
	DQ 03f1ea05175000000H, 03d40ae402534fea4H
	DQ 03f1f005376000000H, 03d47fa77710aad2aH
	DQ 03f1f60557e000000H, 03d2bbdb4e113204bH
	DQ 03f1fc0578b000000H, 03d4d8d3b6e50d246H
	DQ 03f20102ccf800000H, 03d4bd3fc06a15de9H
	DQ 03f20382daf800000H, 03d4d93a1498ec6c9H
	DQ 03f20682ebf800000H, 03d33cb6df935a7f0H
	DQ 03f20982fd2000000H, 03d4de1089920cfdaH
	DQ 03f20c830e8000000H, 03d4985b012a6b1acH
	DQ 03f20f031d2000000H, 03d4913e1b9ba2290H
	DQ 03f212032ee000000H, 03d1624a57980edbcH
	DQ 03f2150340c800000H, 03d441ee709125ff3H
	DQ 03f2180352e800000H, 03d3a45e575f48b5dH
	DQ 03f21a83622800000H, 03d3501dd1e238a6cH
	DQ 03f21d8374a000000H, 03d4191bc1ea6aa2cH
	DQ 03f22083875000000H, 03ce323237921f7b0H
	DQ 03f223839a2800000H, 03d46b179d0781ff4H
	DQ 03f22683ad3800000H, 03d44c09dda134362H
	DQ 03f22903bd4000000H, 03d4652e31de50175H
	DQ 03f22c03d0b000000H, 03d137d77dcd68a32H
	DQ 03f22f03e44800000H, 03d4636fb2840cc02H
	DQ 03f23203f81800000H, 03d41a8e1979c27f4H
	DQ 03f2348408c000000H, 03d410dbf84163334H
	DQ 03f237841ce800000H, 03d4a8e042a7d4e75H
	DQ 03f23a84314800000H, 03d3772593772be29H
	DQ 03f23d8445d800000H, 03d223d4b2e8c031dH
	DQ 03f24004572000000H, 03d0c8072ca9dad06H
	DQ 03f243046c0800000H, 03d315a83ee313d33H
	DQ 03f24604812000000H, 03d473dc4088b7c68H
	DQ 03f24904967000000H, 03d3af34ea9dceae1H
	DQ 03f24c04abf000000H, 03d36c20ba0653485H
	DQ 03f24e84be0000000H, 03d39a63c847be3ffH
	DQ 03f25184d3d800000H, 03d48ca7750a55975H
	DQ 03f25484e9e800000H, 03d38db2a2d1381bbH
	DQ 03f25785002800000H, 03d2ef2461fbe7983H
	DQ 03f25a0512d800000H, 03d2c153bc40c395cH
	DQ 03f25d05297000000H, 03d4064fc5a39c232H
	DQ 03f26005404000000H, 03d070d1f7c4b597eH
	DQ 03f26305573800000H, 03d4a28e9bdbbc457H
	DQ 03f265856a8800000H, 03d474989ecc252f3H
	DQ 03f2688581e000000H, 03d4e13090fc01d57H
	DQ 03f26b85997000000H, 03d391227c8678403H
	DQ 03f26e85b13000000H, 03d155e22f244140dH
	DQ 0bf170fd210000000H, 0bd24caa429329aeeH
	DQ 0bf16dfd2ce000000H, 0bd4cb96d8562dc37H
	DQ 0bf16bfd34d000000H, 0bd2813e19b9dbfb8H
	DQ 0bf168fd409000000H, 0bd34c1a453011cc5H
	DQ 0bf165fd4c3000000H, 0bd4cd61ac43e09bcH
	DQ 0bf162fd57c000000H, 0bd4d64cef90ca8baH
	DQ 0bf15ffd634000000H, 0bd3819d713b1c267H
	DQ 0bf15cfd6ea000000H, 0bd319cda711db032H
	DQ 0bf159fd79e000000H, 0bd43a950c71a6171H
	DQ 0bf156fd851000000H, 0bd393b25eece00b9H
	DQ 0bf153fd902000000H, 0bd43ab308b5fe712H
	DQ 0bf151fd977000000H, 0bd4ca5e736256734H
	DQ 0bf14efda26000000H, 0bd40886b3b9c924dH
	DQ 0bf14bfdad3000000H, 0bd428441ff31aa38H
	DQ 0bf148fdb7f000000H, 0bd14cb421675c431H
	DQ 0bf145fdc29000000H, 0bcf8fb590baebb8dH
	DQ 0bf142fdcd1000000H, 0bd3a1f2ca38e93f3H
	DQ 0bf13ffdd78000000H, 0bd2dc25e83d52ed1H
	DQ 0bf13cfde1d000000H, 0bd3fd5b6efa081f3H
	DQ 0bf13afde8a000000H, 0bd49d89dd4f2bf07H
	DQ 0bf137fdf2d000000H, 0bd3e4f3d5d3a13b4H
	DQ 0bf134fdfce000000H, 0bd428fd96a5f7723H
	DQ 0bf131fe06e000000H, 0bd20452b288690a5H
	DQ 0bf12efe10c000000H, 0bd1d5f7c7e56ea2dH
	DQ 0bf12bfe1a8000000H, 0bd415fc47d421debH
	DQ 0bf128fe243000000H, 0bd3a598ca8dc214bH
	DQ 0bf125fe2dc000000H, 0bd4712f1d7350f14H
	DQ 0bf122fe374000000H, 0bd3e24878efa43e1H
	DQ 0bf120fe3d8000000H, 0bd48adffee23f9f0H
	DQ 0bf11dfe46d000000H, 0bd4d81e00aec2d96H
	DQ 0bf11afe501000000H, 0bd406eddef9956b1H
	DQ 0bf117fe593000000H, 0bd4174f65e105551H
	DQ 0bf114fe624000000H, 0bcf284c306b71311H
	DQ 0bf111fe6b2000000H, 0bd4dcc69dfedbec3H
	DQ 0bf10efe740000000H, 0bd323b7cee38aa4bH
	DQ 0bf10bfe7cc000000H, 0bd144104fd28c140H
	DQ 0bf108fe856000000H, 0bd34171a36d6a695H
	DQ 0bf106fe8b1000000H, 0bd4354a0acea06cdH
	DQ 0bf103fe939000000H, 0bd2eb1b1fae67526H
	DQ 0bf100fe9bf000000H, 0bd343a73fc467e03H
	DQ 0bf0fbfd486000000H, 0bd4aa705ed090ecaH
	DQ 0bf0f5fd58c000000H, 0bd4949cd0d4cde8eH
	DQ 0bf0effd690000000H, 0bd2816308340bd3dH
	DQ 0bf0e9fd790000000H, 0bcfb47fd2e8624a6H
	DQ 0bf0e3fd88c000000H, 0bd338fca5233867dH
	DQ 0bf0ddfd986000000H, 0bcf9cf14342e7c21H
	DQ 0bf0d9fda2a000000H, 0bd3388827d84b6e0H
	DQ 0bf0d3fdb1e000000H, 0bd3b3e0a6d6a2247H
	DQ 0bf0cdfdc0e000000H, 0bd4f92aec1df2a86H
	DQ 0bf0c7fdcfc000000H, 0bd4f9f3aa2200d30H
	DQ 0bf0c1fdde8000000H, 0bd3b894b32ad9b9fH
	DQ 0bf0bbfded0000000H, 0bd3405d8d2c46051H
	DQ 0bf0b5fdfb4000000H, 0bd445a0bd420a715H
	DQ 0bf0affe096000000H, 0bd39940136e0a90fH
	DQ 0bf0abfe12a000000H, 0bd46b0a6f2af86bbH
	DQ 0bf0a5fe206000000H, 0bd4bf4a2ca335408H
	DQ 0bf09ffe2e0000000H, 0bd3ea2d6b12e4d93H
	DQ 0bf099fe3b6000000H, 0bd40c6fd5fb7f840H
	DQ 0bf093fe48a000000H, 0bce555685c9c3116H
	DQ 0bf08dfe558000000H, 0bd4dfc70dfa2e7c3H
	DQ 0bf087fe626000000H, 0bd337897b84ac785H
	DQ 0bf081fe6f0000000H, 0bd1ca71ac6acd2d7H
	DQ 0bf07bfe7b6000000H, 0bd370c682f1de078H
	DQ 0bf077fe838000000H, 0bd45185d76c79d4cH
	DQ 0bf071fe8fa000000H, 0bd33bb0cdd985699H
	DQ 0bf06bfe9b8000000H, 0bd3976c00642b301H
	DQ 0bf065fea72000000H, 0bd4db1e6f5a163e7H
	DQ 0bf05ffeb2a000000H, 0bd4cc11808263596H
	DQ 0bf059febe0000000H, 0bd33d1dff912d171H
	DQ 0bf053fec92000000H, 0bd24a5ae52911a3aH
	DQ 0bf04dfed40000000H, 0bd3d050f249f8edcH
	DQ 0bf047fedec000000H, 0bd27d102dd924b0eH
	DQ 0bf043fee5c000000H, 0bd3e62957baad081H
	DQ 0bf03dfef02000000H, 0bd4376ad4524f2a0H
	DQ 0bf037fefa6000000H, 0bd2752913877e949H
	DQ 0bf031ff046000000H, 0bd292cb26a5ff847H
	DQ 0bf02bff0e2000000H, 0bd44da42ec6a2baeH
	DQ 0bf025ff17c000000H, 0bd4181e4056b600bH
	DQ 0bf01fff212000000H, 0bd4c420ca7722725H
	DQ 0bf019ff2a6000000H, 0bd451ab99454bc09H
	DQ 0bf015ff306000000H, 0bd4f4702fac61211H
	DQ 0bf00fff396000000H, 0bd23ccbf691e23e3H
	DQ 0bf009ff420000000H, 0bd48b7d85ede8a3bH
	DQ 0bf003ff4a8000000H, 0bd4a94f94a602836H
	DQ 0beffbfea5c000000H, 0bd35151ebd4248b6H
	DQ 0befeffeb60000000H, 0bd31312ebaebde60H
	DQ 0befe3fec5c000000H, 0bd44bf0e08b2a851H
	DQ 0befd7fed54000000H, 0bd3dfbe044563cddH
	DQ 0befcbfee44000000H, 0bd47553a6bb2cf4dH
	DQ 0befc3feee4000000H, 0bd02b3272c9e1514H
	DQ 0befb7fefc8000000H, 0bd4655cdd79568b8H
	DQ 0befabff0a8000000H, 0bd4998c8c6a29955H
	DQ 0bef9fff184000000H, 0bd35e84003879074H
	DQ 0bef93ff258000000H, 0bd34cfa09595f318H
	DQ 0bef87ff324000000H, 0bd47f3d66389e086H
	DQ 0bef7bff3ec000000H, 0bd43982f0dd1df79H
	DQ 0bef6fff4ac000000H, 0bd4d54d70b7407c7H
	DQ 0bef63ff568000000H, 0bd4529cb1e4119e9H
	DQ 0bef5bff5e0000000H, 0bd4ea8cf63b0e57aH
	DQ 0bef4fff694000000H, 0bd1a872dd1f9867bH
	DQ 0bef43ff73c000000H, 0bd46113f80238647H
	DQ 0bef37ff7e0000000H, 0bd46e9d9772d7da6H
	DQ 0bef2bff880000000H, 0bd276ac184b1770cH
	DQ 0bef1fff918000000H, 0bd171e07ff78e451H
	DQ 0bef13ff9a8000000H, 0bd3c0a102a88bdf6H
	DQ 0bef07ffa34000000H, 0bd2cfa098be9e4a8H
	DQ 0beef7ff570000000H, 0bd3d205955bedc7eH
	DQ 0beee7ff618000000H, 0bd47b79acbd1c3d4H
	DQ 0beecfff710000000H, 0bd37b870ff9b8582H
	DQ 0beeb7ff7f8000000H, 0bd3c31fb1038dd6dH
	DQ 0bee9fff8d0000000H, 0bd4e6de6a68aa227H
	DQ 0bee87ff9a0000000H, 0bd4cdaf09ce4e699H
	DQ 0bee6fffa68000000H, 0bd32c03059eee94bH
	DQ 0bee57ffb20000000H, 0bd1fead0c4719fccH
	DQ 0bee3fffbc8000000H, 0bd39656642e976adH
	DQ 0bee2fffc30000000H, 0bd46c7329db21925H
	DQ 0bee17ffcc8000000H, 0bd389eab4517a5ceH
	DQ 0bedffffaa0000000H, 0bd3fdf0e3da560d7H
	DQ 0bedcfffba0000000H, 0bd0a7c3d4511fbcbH
	DQ 0bed9fffc80000000H, 0bd0780884d13df75H
	DQ 0bed6fffd40000000H, 0bd3ec0a3e439ae99H
	DQ 0bed3fffdf0000000H, 0bd36c139bbface01H
	DQ 0bed0fffe80000000H, 0bd4578e60a3c176bH
	DQ 0becbfffe00000000H, 0bd3b5254714383f2H
	DQ 0bec7fffe80000000H, 0bd4764e185e2f8bbH
	DQ 0bec1ffff20000000H, 0bd4c67c0d84712a6H
	DQ 0beb7ffff40000000H, 0bd3f05250dd0685fH
	DQ 0bea7ffff80000000H, 0bd40b553538e0e0cH
	DQ 0, 0


;   log2 polynomial coefficients
clv     DQ 03fc47fd462b3b816H, 03e79c3a6966457eeH	; c1|c3
	DQ 0bfb550472a8bb463H, 0bfd62e4346694107H	; c2|c4


;-------Table T, D  so that movapd gives [ D | T ]
;-------Note that the exponent field of T is set to 000  (instead of 3ffH)
exp2_tbl DQ 03ff0000000000000H, 00000000000000000H
	 DQ 03ff0163da9fb3335H, 03c9b61299ab8cdb7H
	 DQ 03ff02c9a3e778061H, 0bc719083535b085dH
	 DQ 03ff04315e86e7f85H, 0bc90a31c1977c96eH
	 DQ 03ff059b0d3158574H, 03c8d73e2a475b465H
	 DQ 03ff0706b29ddf6deH, 0bc8c91dfe2b13c26H
	 DQ 03ff0874518759bc8H, 03c6186be4bb284ffH
	 DQ 03ff09e3ecac6f383H, 03c91487818316135H
	 DQ 03ff0b5586cf9890fH, 03c98a62e4adc610aH
	 DQ 03ff0cc922b7247f7H, 03c901edc16e24f71H
	 DQ 03ff0e3ec32d3d1a2H, 03c403a1727c57b52H
	 DQ 03ff0fb66affed31bH, 0bc6b9bedc44ebd7bH
	 DQ 03ff11301d0125b51H, 0bc96c51039449b39H
	 DQ 03ff12abdc06c31ccH, 0bc51b514b36ca5c7H
	 DQ 03ff1429aaea92de0H, 0bc932fbf9af1369eH
	 DQ 03ff15a98c8a58e51H, 03c82406ab9eeab09H
	 DQ 03ff172b83c7d517bH, 0bc819041b9d78a75H
	 DQ 03ff18af9388c8deaH, 0bc911023d1970f6bH
	 DQ 03ff1a35beb6fcb75H, 03c8e5b4c7b4968e4H
	 DQ 03ff1bbe084045cd4H, 0bc995386352ef607H
	 DQ 03ff1d4873168b9aaH, 03c9e016e00a2643cH
	 DQ 03ff1ed5022fcd91dH, 0bc91df98027bb78bH
	 DQ 03ff2063b88628cd6H, 03c8dc775814a8494H
	 DQ 03ff21f49917ddc96H, 03c82a97e9494a5edH
	 DQ 03ff2387a6e756238H, 03c99b07eb6c70572H
	 DQ 03ff251ce4fb2a63fH, 03c8ac155bef4f4a4H
	 DQ 03ff26b4565e27cddH, 03c82bd339940e9d9H
	 DQ 03ff284dfe1f56381H, 0bc9a4c3a8c3f0d7dH
	 DQ 03ff29e9df51fdee1H, 03c8612e8afad1255H
	 DQ 03ff2b87fd0dad990H, 0bc410adcd6381aa3H
	 DQ 03ff2d285a6e4030bH, 03c90024754db41d4H
	 DQ 03ff2ecafa93e2f56H, 03c71ca0f45d52383H
	 DQ 03ff306fe0a31b715H, 03c86f46ad23182e4H
	 DQ 03ff32170fc4cd831H, 03c8a9ce78e18047cH
	 DQ 03ff33c08b26416ffH, 03c932721843659a5H
	 DQ 03ff356c55f929ff1H, 0bc8b5cee5c4e4628H
	 DQ 03ff371a7373aa9cbH, 0bc963aeabf42eae1H
	 DQ 03ff38cae6d05d866H, 0bc9e958d3c9904bcH
	 DQ 03ff3a7db34e59ff7H, 0bc75e436d661f5e2H
	 DQ 03ff3c32dc313a8e5H, 0bc9efff8375d29c3H
	 DQ 03ff3dea64c123422H, 03c8ada0911f09ebbH
	 DQ 03ff3fa4504ac801cH, 0bc97d023f956f9f3H
	 DQ 03ff4160a21f72e2aH, 0bc5ef3691c309278H
	 DQ 03ff431f5d950a897H, 0bc81c7dde35f7998H
	 DQ 03ff44e086061892dH, 03c489b7a04ef80cfH
	 DQ 03ff46a41ed1d0057H, 03c9c944bd1648a76H
	 DQ 03ff486a2b5c13cd0H, 03c73c1a3b69062f0H
	 DQ 03ff4a32af0d7d3deH, 03c99cb62f3d1be56H
	 DQ 03ff4bfdad5362a27H, 03c7d4397afec42e2H
	 DQ 03ff4dcb299fddd0dH, 03c98ecdbbc6a7833H
	 DQ 03ff4f9b2769d2ca7H, 0bc94b309d25957e3H
	 DQ 03ff516daa2cf6642H, 0bc8f768569bd93eeH
	 DQ 03ff5342b569d4f82H, 0bc807abe1db13cacH
	 DQ 03ff551a4ca5d920fH, 0bc8d689cefede59aH
	 DQ 03ff56f4736b527daH, 03c99bb2c011d93acH
	 DQ 03ff58d12d497c7fdH, 03c8295e15b9a1de7H
	 DQ 03ff5ab07dd485429H, 03c96324c054647acH
	 DQ 03ff5c9268a5946b7H, 03c3c4b1b816986a2H
	 DQ 03ff5e76f15ad2148H, 03c9ba6f93080e65dH
	 DQ 03ff605e1b976dc09H, 0bc93e2429b56de47H
	 DQ 03ff6247eb03a5585H, 0bc9383c17e40b496H
	 DQ 03ff6434634ccc320H, 0bc8c483c759d8932H
	 DQ 03ff6623882552225H, 0bc9bb60987591c33H
	 DQ 03ff68155d44ca973H, 03c6038ae44f73e64H
	 DQ 03ff6a09e667f3bcdH, 0bc9bdd3413b26455H
	 DQ 03ff6c012750bdabfH, 0bc72895667ff0b0cH
	 DQ 03ff6dfb23c651a2fH, 0bc6bbe3a683c88aaH
	 DQ 03ff6ff7df9519484H, 0bc883c0f25860ef6H
	 DQ 03ff71f75e8ec5f74H, 0bc816e4786887a99H
	 DQ 03ff73f9a48a58174H, 0bc90a8d96c65d53bH
	 DQ 03ff75feb564267c9H, 0bc90245957316dd3H
	 DQ 03ff780694fde5d3fH, 03c9866b80a02162cH
	 DQ 03ff7a11473eb0187H, 0bc841577ee04992fH
	 DQ 03ff7c1ed0130c132H, 03c9f124cd1164dd5H
	 DQ 03ff7e2f336cf4e62H, 03c705d02ba15797eH
	 DQ 03ff80427543e1a12H, 0bc927c86626d972aH
	 DQ 03ff82589994cce13H, 0bc9d4c1dd41532d7H
	 DQ 03ff8471a4623c7adH, 0bc88d684a341cdfbH
	 DQ 03ff868d99b4492edH, 0bc9fc6f89bd4f6baH
	 DQ 03ff88ac7d98a6699H, 03c9994c2f37cb53aH
	 DQ 03ff8ace5422aa0dbH, 03c96e9f156864b26H
	 DQ 03ff8cf3216b5448cH, 0bc70d55e32e9e3aaH
	 DQ 03ff8f1ae99157736H, 03c85cc13a2e3976cH
	 DQ 03ff9145b0b91ffc6H, 0bc9dd6792e582523H
	 DQ 03ff93737b0cdc5e5H, 0bc675fc781b57ebbH
	 DQ 03ff95a44cbc8520fH, 0bc764b7c96a5f039H
	 DQ 03ff97d829fde4e50H, 0bc9d185b7c1b85d0H
	 DQ 03ff9a0f170ca07baH, 0bc9173bd91cee632H
	 DQ 03ff9c49182a3f090H, 03c7c7c46b071f2beH
	 DQ 03ff9e86319e32323H, 03c7824ca78e64c6eH
	 DQ 03ffa0c667b5de565H, 0bc9359495d1cd532H
	 DQ 03ffa309bec4a2d33H, 03c96305c7ddc36abH
	 DQ 03ffa5503b23e255dH, 0bc9d2f6edb8d41e1H
	 DQ 03ffa799e1330b358H, 03c9bcb7ecac563c6H
	 DQ 03ffa9e6b5579fdbfH, 03c90fac90ef7fd31H
	 DQ 03ffac36bbfd3f37aH, 0bc8f9234cae76cd0H
	 DQ 03ffae89f995ad3adH, 03c97a1cd345dcc81H
	 DQ 03ffb0e07298db666H, 0bc9bdef54c80e424H
	 DQ 03ffb33a2b84f15fbH, 0bc62805e3084d707H
	 DQ 03ffb59728de5593aH, 0bc9c71dfbbba6de3H
	 DQ 03ffb7f76f2fb5e47H, 0bc75584f7e54ac3aH
	 DQ 03ffba5b030a1064aH, 0bc9efcd30e54292eH
	 DQ 03ffbcc1e904bc1d2H, 03c823dd07a2d9e84H
	 DQ 03ffbf2c25bd71e09H, 0bc9efdca3f6b9c72H
	 DQ 03ffc199bdd85529cH, 03c811065895048ddH
	 DQ 03ffc40ab5fffd07aH, 03c9b4537e083c60aH
	 DQ 03ffc67f12e57d14bH, 03c92884dff483cacH
	 DQ 03ffc8f6d9406e7b5H, 03c71acbc48805c44H
	 DQ 03ffcb720dcef9069H, 03c7503cbd1e949dbH
	 DQ 03ffcdf0b555dc3faH, 0bc8dd83b53829d72H
	 DQ 03ffd072d4a07897cH, 0bc9cbc3743797a9cH
	 DQ 03ffd2f87080d89f2H, 0bc9d487b719d8577H
	 DQ 03ffd5818dcfba487H, 03c82ed02d75b3706H
	 DQ 03ffd80e316c98398H, 0bc911ec18beddfe8H
	 DQ 03ffda9e603db3285H, 03c9c2300696db532H
	 DQ 03ffdd321f301b460H, 03c92da5778f018c2H
	 DQ 03ffdfc97337b9b5fH, 0bc91a5cd4f184b5bH
	 DQ 03ffe264614f5a129H, 0bc97b627817a1496H
	 DQ 03ffe502ee78b3ff6H, 03c839e8980a9cc8fH
	 DQ 03ffe7a51fbc74c83H, 03c92d522ca0c8de1H
	 DQ 03ffea4afa2a490daH, 0bc9e9c23179c2893H
	 DQ 03ffecf482d8e67f1H, 0bc9c93f3b411ad8cH
	 DQ 03ffefa1bee615a27H, 03c9dc7f486a4b6b0H
	 DQ 03fff252b376bba97H, 03c93a1a5bf0d8e43H
	 DQ 03fff50765b6e4540H, 03c99d3e12dd8a18aH
	 DQ 03fff7bfdad9cbe14H, 0bc9dbb12d0063509H
	 DQ 03fffa7c1819e90d8H, 03c874853f3a5931eH
	 DQ 03fffd3c22b8f71f1H, 03c62eb74966579e7H
	

Shifter  DQ 04338000000000000H, 04338000000000000H	; 2^52+2^51|2^52+2^51
SIGMASK  DQ 0000fffffffffffffH, 0000fffffffffffffH
ONEMASK  DQ 03ff0000000000000H, 03ff0000000000000H
ABSVALMASK DQ 7fffffffffffffffH, 7fffffffffffffffH

	; exponential polynomial coefficients
cev     DQ 03f55d87fe78a6731H, 03fac6b08d704a0bfH  ; c3|c5
	DQ 03f83b2ab6fba4e77H, 03fcebfbdff82c58eH  ; c2|c4
	DQ 03fe62e42fefa39efH  ; c1




HALFSIG  DQ 0fffffffff8000000H
LHN      DQ 0bff7154740000000H   ; -log2(e) rounded to 27 bits
sNaN     DQ 07ff0000000000001H
INF      DQ 07ff0000000000000H
NEG_INF  DQ 0fff0000000000000H
NEG_ZERO DQ 08000000000000000H
EMIN     DQ 00010000000000000H
QIND     DQ 0fff8000000000000H	; QNAN indefinite

    ALIGN 16
CONST ENDS


$movsd MACRO op1, op2
LOCAL begin_movsd, end_movsd
begin_movsd:
movupd op1, op2
end_movsd:
org begin_movsd
db 0F2h
org end_movsd
ENDM



_TEXT SEGMENT PARA PUBLIC USE32 'CODE'
    ALIGN 16

PUBLIC _pow_pentium4, _CIpow_pentium4 
_CIpow_pentium4 PROC NEAR
	push   ebp
	mov    ebp,esp
        sub     esp,16               ; prepare place for argument
        and     esp,0fffffff0h
        fxch    st(1)
        fstp    qword ptr [esp]               ; base
        fstp    qword ptr [esp+8]             ; exponent
        call    _pow_pentium4
	leave
        ret
_pow_pentium4   label proc
   ; load first argument
   movlpd xmm0, QWORD PTR [esp+4]
   ; load constants
   movlpd xmm7, QWORD PTR [SIGMASK]
   movlpd xmm2, QWORD PTR [ONEMASK]

   andpd xmm7, xmm0 
   $movsd xmm4, xmm0
   psrlq xmm0, 64-12-8
   ; get first 7 bits after leading 1
   pextrw eax, xmm0, 0
   ; xmm7=first argument, with exponent set to 0+bias
   orpd xmm7, xmm2
   ; extract sign/exponent + next 4 bits
   pextrw ecx, xmm4, 3

   and eax, 0ffH
   add eax, 1
   and eax, 1feH
   ; get r1=x*rcp_t1
   mulsd  xmm7, QWORD PTR [rcp_t1+eax*4]
   ; load first reciprocal value (based on first 7 bits)
   movlpd xmm5, QWORD PTR [rcp_t1+eax*4]
   add eax, eax
   ; load first log2_table values (high, low) in xmm6
   movapd xmm6, QWORD PTR [log2_t1+eax*4]

   ; check sign/exponent of x
   mov edx, 7fefH
   ; x infinity/NaN or negative ?
   sub edx, ecx
   ; x denormal ?
   sub ecx, 0010H
   or ecx, edx
   cmp ecx, 80000000H
   jae SPECIAL_X

   mov ecx, 0
   ; set xmm1=2^8*(bias-0.5-2^{-8})
   mov edx, 3fe7fH
BACK_MAIN:
BACK_DENORMAL:
   movd xmm1, edx
   ; get k (exponent) + j (j=0 if mantissa<1.5, 1 otherwise)
   psubq xmm0, xmm1
   psrlq xmm0, 8
   ; convert to DP format
   cvtdq2pd xmm0, xmm0
   
   ; xmm1=mask for splitting argments in high/low parts
   movlpd xmm1, QWORD PTR [HALFSIG]

   ; copy r1 to xmm3, set exponent to 0+bias
   $movsd xmm3, xmm7 ;andpd xmm3, xmm7
   ; extract bits 7..14
   psrlq xmm7, 64-12-14
   pextrw eax, xmm7, 0

   ; set exponent of argument to 0+bias
   andpd xmm4, QWORD PTR [SIGMASK]

   and eax, 0ffH
   add eax, 1
   and eax, 1feH
   ; load second reciprocal value (based on 7 bit index)
   ; get r2=x*rcp_t1*rcp_t2
   mulsd xmm3, QWORD PTR [rcp_t2+eax*4]
   ; rcp_t1*rcp_t2 (exact multiplication)
   mulsd xmm5, QWORD PTR [rcp_t2+eax*4]
   add eax, eax
   ; load next log2_table values (high, low) to xmm6
   addpd xmm6, QWORD PTR [log2_t2+eax*4]
  
   orpd  xmm4, QWORD PTR [ONEMASK]
   ; add k
   addsd xmm6, xmm0
   ; get xH = high part of x
   andpd xmm1, xmm4

   ; copy r2 to xmm2
   $movsd xmm2, xmm3
   ; extract bits 13...21
   psrlq xmm3, 64-12-21
   pextrw eax, xmm3, 0

   ; xmm0 = mask for splitting term in high/low parts
   movlpd xmm0, QWORD PTR [HALFSIG]
   ; get xL = low part of x
   subsd xmm4, xmm1
   ; xmm7=-log2(e) in double precision (scaling factor for reduced argument)
   movlpd xmm7, QWORD PTR [LHN]

   and eax, 1ffH
   add eax, 1
   and eax, 3feH
   ; load third reciprocal value (based on 8 bit index)
   ; get rcp_t1*rcp_t2*rcp_t3 (exact multiplication)
   mulsd xmm5, QWORD PTR [rcp_t3+eax*4]
   ; get r3=x*rcp_t1*rcp_t2*rcp_t3
   mulsd xmm2, QWORD PTR [rcp_t3+eax*4]
   ; load next log2_table values (high, low) to xmm6
   addpd xmm6, QWORD PTR [log2_t3+eax*8] 


   ; xmm0=rcp_H
   andpd xmm0, xmm5
   ; xmm5=rcp_L
   subsd xmm5, xmm0
   ; reduced argument 
   addsd xmm7, xmm2

   ; copy rcp_H
   $movsd xmm3, xmm0
   ; rcp_H*xH
   mulsd xmm0, xmm1
   ; xH*rcp_L
   mulsd xmm1, xmm5
   ; rcp_H*xL
   mulsd xmm3, xmm4

   ; calculate rounding error for reduced argument: R-rcp_H*xH
   subsd xmm2, xmm0
   ; rcp_L*xL
   mulsd xmm4, xmm5
   ; copy xmm6=D1+D2+D3|k+T1+T2+T3
   $movsd xmm0, xmm6
   ; R-rcp_H*xH-rcp_L*xH
   subsd xmm2, xmm1
   ; add reduced argument to high order term: xmm6=D1+D2+D3|k+T1+T2+T3+Rh
   addsd xmm6, xmm7
  
   ; load y
   movlpd xmm1, QWORD PTR [esp+12]
   ; get sign/exponent
   pextrw eax, xmm1, 3

   ; R-rcp_H*xH-rcp_L*xH-rcp_H*xL
   subsd xmm2, xmm3
   ; get -Rh
   subsd xmm0, xmm6
   ; xmm3=HALFSIG mask
   movlpd xmm3, QWORD PTR [HALFSIG]

   ; get exponent for log2(x)
   pextrw edx, xmm6, 3

   ; E=R-rcp_H*xH-rcp_L*xH-rcp_H*xL-rcp_L*xL
   subsd xmm2, xmm4
 ; xmm4=k+T1+T2+T3+Rh
 $movsd xmm4, xmm6
   ; get Rl=R-Rh
   addsd xmm0, xmm7
   ; R=R-E
   subsd xmm7, xmm2
 ; xmm6=D1+D2+D3|k+T1+T2+T3+Rh+Eh
 subsd xmm6, xmm2
   ; xmm7=R|R
   unpcklpd xmm7, xmm7

   ; check if y is infinity/NaN
   and eax, 7ff0H
   cmp eax, 7ff0H
   jae SPECIAL_Y
   and edx, 7ff0H
   sub eax, 3ff0H
   add eax, edx
   ; y*log2(x)>=2^{11} ? (i.e. 2^{11}-eps-x<0)
   mov edx, 40a0H
   sub edx, eax
   ; avoid underflow on intermediate calculations (|y*log2(x)|<2^{-56} ?)
   sub eax, 3c70H
   or edx, eax
   cmp edx, 80000000H
   ; small input or UF/OF
   jae RETURN_ONE

BACK_XY_CHECK:
 ; -Eh
 subsd xmm4, xmm6
 ; -El
 subsd xmm2, xmm4
   ; xmm4=HALFSIG mask
   movlpd xmm4, QWORD PTR [HALFSIG]
   ; yH
   andpd xmm3, xmm1
   ; HH (high part of k+T1+T2+T3+Rh+Eh)
   andpd xmm4, xmm6

   ; add correction to reduced argument: Rl+El
   subsd xmm0, xmm2

   xorpd xmm2, xmm2
   mov edx, 4060H ;70H
   pinsrw xmm2, edx, 3

   ; copy yH
   $movsd xmm5, xmm3 
   ; yH*HH
   mulsd xmm3, xmm4
   ; HL
   subsd xmm6, xmm4
   ; yL
   subsd xmm1, xmm5
	
   ; get 2^7*(yH*HH)
   mulsd xmm3, xmm2  ;paddd xmm3, xmm2

   ; yH*HL
   mulsd xmm5, xmm6
   ; xmm2=cl1|cl3
   movapd xmm2, QWORD PTR [clv]
   ; HH*yL
   mulsd xmm4, xmm1

   ; get int(2^7*H)
   cvtsd2si eax, xmm3
   ; HL*yL
   mulsd xmm6, xmm1
   ; xmm1=cl2|cl4
   movapd xmm1, QWORD PTR [clv+16]

   ; yH*HL+yL*HH
   addsd xmm5, xmm4
   ; get D1+D2+D3
   pshufd xmm4, xmm6, 0eeH
   ; yH*HL+yL*HH+yL*HL
   addsd xmm5, xmm6

   ; underflow/possible overflow condition ?
   mov edx, 1ff7fH
   ; eax>=(2^10-1)*2^7
   sub edx, eax
   ; eax+bias*2^7<=59*2^7 ?
   add eax, 1e1ffH
   or edx, eax
   ; restore eax value
   sub eax, 1e1ffH
   ; check sign bit
   cmp edx, 0
   jle UF_OF_CASES


   ; get table index, and exponent of result
   ; ecx contains expected sign of the result, scaled by 2^11
   add ecx, eax
   and eax, 7fH
   ; get exponent of result (scaled by 2^7)
   and ecx, 0ffffff80h
   ; add exponent bias*2^7
   add ecx, 1ff80h

   ; D1+D2+D3+(Rl+El)
   addsd xmm4, xmm0
   ; xmm0=xmm3=2^7*H
   $movsd xmm0, xmm3
   
   ; (2^7)*H+Shifter (to round to integer)
   addsd xmm3, QWORD PTR [Shifter]


   ; cl1*R|cl3*R
   mulpd xmm2, xmm7

   ; int((2^7)*H)=((2^7)*H+Shifter)-Shifter
   subsd xmm3, QWORD PTR [Shifter]

   ; R^2|R^2
   mulpd xmm7, xmm7

   ; R_exp_h'=R_exp_h*(2^7)=(2^7)*H-int((2^7)*H)
   subsd xmm0, xmm3

   ; load table values
   add eax, eax
   add eax, eax
   add eax, eax
   add eax, eax
   ; D|T
   movapd xmm3, QWORD PTR [exp2_tbl+eax] 

   ; load ce3|ce5
   movapd xmm6, QWORD PTR [cev]


   ; cl2*R^2|cl4*R^2
   mulpd xmm1, xmm7
   ; cl1*R+cl2*R^2|cl3*R+cl4*R^2
   addpd xmm2, xmm1
   ; unpack cl1*R+cl2*R^2
   pshufd xmm1, xmm2, 0eeh
   ; *|cl3*R^3+cl4*R^4
   mulsd xmm2, xmm7
   ; xmm7=0
   xorpd xmm7, xmm7
   mov edx, 3f80H
   ; Pl14
   addsd xmm2, xmm1
   ; xmm7=scaling constant 
   pinsrw xmm7, edx, 3 
   ; low part of log2(x): D1+D2+D3+(Rl+E)+P14
   addsd xmm2, xmm4

   ; load ce1
   movlpd xmm4, QWORD PTR [cev+32]
   ; load 2^k 
   movd xmm1, ecx

UF_BACK:
   ; y*(D1+D2+D3+(Rl+E)+P14)
   mulsd xmm2, QWORD PTR [esp+12]
   ; get R_exp_h=2^{-7}*R_exp_h'
   mulsd xmm0, xmm7

   psllq xmm1, 52-7
   ; xmm1=2^k|2^k
   pshufd xmm1, xmm1, 044h

   ; load ce2|ce4
   movapd xmm7, QWORD PTR [cev+16]
   ; low part of y*log2(x): yH*HL+yL*HH+yL*HL+y*(D1+D2+D3+(Rl+E)+P14)
   addsd xmm5, xmm2

   ; get D*2^k|T*2^k
   mulpd xmm3, xmm1
   ; get R_exp=R_exp_h+yH*HL+yL*HH+yL*HL+y*(D1+D2+D3+(Rl+E)+P14)
   addsd xmm0, xmm5
   ; xmm0=R_exp|R_exp
   unpcklpd xmm0, xmm0

   ; ce3*R_exp|ce5*R_exp
   mulpd xmm6, xmm0
   ; ce1*R_exp
   mulsd xmm4, xmm0  
   ; R_exp^2|R_exp^2
   mulpd xmm0, xmm0
   ; ce2+ce3*R_exp|ce4+ce5*R_exp
   addpd xmm7, xmm6
   ; R_exp^2*(ce2+ce3*R_exp)|R_exp^2*(ce4+ce5*R_exp)
   mulpd xmm7, xmm0
   ; R_exp^2*(T*2^k)
   mulsd xmm0, xmm3
   ; unpack R_exp^2*(ce2+ce3*R_exp)
   pshufd xmm6, xmm7, 0eeh
   ; R_exp^4*(T*2^k)*(ce4+ce5*R_exp)
   mulsd xmm0, xmm7
   ; unpack D*2^k
   pshufd xmm5, xmm3, 0eeh
   ; R_exp^2*(T*2^k)*(ce2+ce3*R_exp)
   mulsd xmm6, xmm3
   ; ce1*(T*2^k)*R_exp
   mulsd xmm4, xmm3  

   ; P45*(T*2^k)+D*2^k  
   addsd xmm0, xmm5 
sub esp, 16
   ; P25*(T*2^k)+D*2^k
   addsd xmm0, xmm6
   ; P15*(T*2^k)+D*2^k
   addsd xmm0, xmm4

   ; T+P15*(T*2^k)+D*2^k
   addsd xmm0, xmm3

	movlpd    QWORD PTR [esp+4], xmm0       ; return result
	fld       QWORD PTR [esp+4]             ;
add esp, 16
	ret



SPECIAL_X:
   ; load y
   movlpd xmm1, QWORD PTR [esp+12]
   movlpd xmm3, QWORD PTR [ABSVALMASK]
   ; load low half of y in eax
   movd eax, xmm1
   $movsd xmm2, xmm1
   ; eliminate sign, load high half of y in ecx
   andpd xmm1, xmm3
   psrlq xmm1, 32
   movd ecx, xmm1
   ; y infinity/NaN ?
   cmp ecx, 7ff00000H
   jae Y_INF_NAN_CHECK_X
   ; y=+/- 0?
   or eax, ecx
   cmp eax, 0
   jz Y_ZERO

   ; denormal, positive x ? 
   cmp edx, 0
   jge DENORMAL_POS_X
   ; reconstruct sign/expon from edx=7fefH-s/exp
   neg edx
   add edx, 7fefH

   ; y integer ?
   ; xmm3=0fff00..0
   psllq xmm3,64-12
   ; set exponent of y to all 1's
   orpd xmm2, xmm3
   ; load bias-12
   mov ecx, 3ffH-12
   movd xmm3, ecx
   ; get exponent+64-52
   psrlq xmm1, 32-12
   psubd xmm1, xmm3
   ; xmm3=0
   pxor xmm3, xmm3
   ; if exponent+12<0, set shift count to 0
   pmaxsw xmm1, xmm3
   ; get fractional tail of y
   psllq xmm2, xmm1
   ; fractional tail=0 ? (i.e. y integer ?)
   pcmpeqd xmm2, xmm3
   pmovmskb eax, xmm2    

   ; take absolute value of x
   mov ecx, edx
   and edx, 7fffH
   ; check if x infinity/NaN
   cmp edx, 7ff0H
   jae INF_NAN_X

   ; x negative, finite
   ; y not integer ?
   and eax, 0ffH
   cmp eax, 0ffH
   jnz RET_INVALID

   ; y integer
   ; y odd integer ?
   movlpd xmm1, QWORD PTR [esp+12]
   movlpd xmm2, QWORD PTR [esp+12]
   ; load bias-11
   mov ecx, 3ffH-11
   movd xmm3, ecx
   ; get exponent+64-53
   andpd xmm1, QWORD PTR [ABSVALMASK]
   psrlq xmm1, 64-12
   psubd xmm1, xmm3
   ; xmm3=100..0
   movlpd xmm3, QWORD PTR [NEG_ZERO]
   ; get last integer bit, fractional tail of y
   psllq xmm2, xmm1
   ; last int. bit=0 ? (i.e. y is an odd integer ?)
   pcmpeqd xmm2, xmm3
   pmovmskb eax, xmm2
   and eax, 0ffH
   ; if eax!=ffH, set ecx=2^11, else set ecx=0
   mov ecx, 3ff01H
   ; set ecx=2^11*2^7 if y is an odd integer
   add ecx, eax
   and ecx, 40000H

   ; x denormal ?
   cmp edx, 0010H
   jb DENORMAL_X

   ; set xmm1=2^8*(bias-0.5-2^{-8})
   mov edx, 0bfe7fH

   ; load constants, return to main path
   movlpd xmm3, QWORD PTR [SIGMASK]
   movlpd xmm2, QWORD PTR [ONEMASK]
      
   jmp BACK_MAIN

Y_INF_NAN_CHECK_X:
   ; x NaN?
   movlpd xmm7, QWORD PTR [esp+4]
   movlpd xmm4, QWORD PTR [esp+4]
   movd edx, xmm7
   psrlq xmm7, 32
   movd eax, xmm7

   mov ecx, eax
   and eax, 7fffffffH
   cmp eax, 7ff00000H
   jb Y_INF_NAN
   ja X_NAN

   cmp edx, 0
   ja X_NAN
   jmp Y_INF_NAN

DENORMAL_POS_X:
   mov ecx, 0
DENORMAL_X:
   ; xmm0=2^64
   xorpd xmm0, xmm0
   mov eax, (3ffH+64)*16
   pinsrw xmm0, eax, 3 
   ; load constants
   movlpd xmm7, QWORD PTR [SIGMASK]
   movlpd xmm2, QWORD PTR [ONEMASK]

   ; scale x by 2^64
   mulsd xmm0, xmm4

   ; x=+/-0 ?
   movd edx, xmm4
   psrlq xmm4, 32
   movd eax, xmm4
   cmp edx, 0
   jz ZERO_X

BACK_DEN:
   andpd xmm7, xmm0 
   $movsd xmm4, xmm0
   andpd xmm0, QWORD PTR [ABSVALMASK]
   psrlq xmm0, 64-12-8
   ; get first 7 bits after leading 1
   pextrw eax, xmm0, 0
   orpd xmm7, xmm2

   and eax, 0ffH
   add eax, 1
   and eax, 1feH
   ; get r1=x*rcp_t1
   mulsd  xmm7, QWORD PTR [rcp_t1+eax*4]
   ; load first reciprocal value (based on first 7 bits)
   movlpd xmm5, QWORD PTR [rcp_t1+eax*4]
   add eax, eax
   ; load first log2_table values (high, low) in xmm6
   movapd xmm6, QWORD PTR [log2_t1+eax*4]

   ; 2^8*(bias+64-0.5-2^{-8})
   mov edx, 43e7fH 
   jmp BACK_DENORMAL

ZERO_X:
   mov edx, eax
   and edx, 7fffffffH
   cmp edx, 0
   jnz BACK_DEN

   ; get sign of y
   mov edx, DWORD PTR [esp+16]
   and edx, 80000000H
   cmp edx, 0
   jz ZERO_X_POS_Y 

   ; return -infinity if (y odd and x=-0), +infinity otherwise
   ; ecx=0 or 2^11*2^7
   shl ecx, 20-7
   ; eax=2^31 if (y odd and x=-0)
   and eax, ecx
   mov edx, 7ff00000H
   ; set sign of infinity
   or edx, eax
   ; load result
   movd xmm0, edx
   psllq xmm0, 32

   ; raise divide by zero
   movlpd xmm1, QWORD PTR [ONEMASK]
   movlpd xmm2, QWORD PTR [esp+4]
   divsd xmm1, xmm2

   mov edx, 27
   jmp CALL_LIBM_ERROR


ZERO_X_POS_Y:

   ; x=-0, and y odd integer ?
   ; ecx=0 or 2^11*2^7
   shl ecx, 20-7
   ; eax=2^31 if (y odd and x=-0)
   and eax, ecx
   cmp eax, 0
   jnz RET_NEG_ZERO

   ; return +0
   fldz
   ret


INF_NAN_X:
	; y finite, not zero
	; x NaN ?
        movlpd xmm3, QWORD PTR [SIGMASK]
	xorpd xmm1, xmm1
	; get significand bits
        andpd xmm3, xmm4
	; significand bits = 0 ?
	pcmpeqd xmm1, xmm3
	pmovmskb ecx, xmm1
	and ecx, 0ffH
	cmp ecx, 0ffH
        jnz X_NAN

	; x=+infinity ?
	pextrw ecx, xmm4, 3
	and ecx, 8000H
	cmp ecx,0
	jz X_INF

	; x=-infinity
	; y integer ?
   	and eax, 0ffH
   	cmp eax, 0ffH
	jnz X_NINF
	; y odd integer ?
	movlpd xmm1, QWORD PTR [esp+12]
	movlpd xmm2, QWORD PTR [esp+12]
   ; load bias-11
   mov ecx, 3ffH-11
   movd xmm3, ecx
   ; get exponent+64-53
   andpd xmm1, QWORD PTR [ABSVALMASK]
   psrlq xmm1, 64-12
   psubd xmm1, xmm3
   ; xmm3=0
   pxor xmm3, xmm3
   ; get last integer bit, fractional tail of y
   psllq xmm2, xmm1
   ; last int. bit=0 ? (i.e. y is an even integer ?)
   pcmpeqd xmm2, xmm3
   pmovmskb eax, xmm2
   and eax, 0ffH
   cmp eax, 0ffH
   jz X_NINF

   ; x=-infinity, y an odd integer
   movlpd xmm1, QWORD PTR [esp+12]
   pextrw eax, xmm1, 3
   and eax, 8000H
   cmp eax, 0
   ; y>0 ?
   jz RET_NINF
   ; y<0, return -0

RET_NEG_ZERO:
   fld [NEG_ZERO]
   ret	
    

RET_NINF:
   fld [NEG_INF]
   ret

X_NINF:
   ; x=-infinity, y not an odd integer
   movlpd xmm1, QWORD PTR [esp+12]
   pextrw eax, xmm1, 3
   and eax, 8000H
   cmp eax, 0
   ; y>0 ? (return infinity)
   jz RET_INF
   ; y<0, return 0
   fldz
   ret
 
X_INF:
	; y<0 ?
	movlpd xmm1, QWORD PTR [esp+12]
	pextrw eax, xmm1, 3
	and eax, 8000H
	cmp eax, 0
	jz RET_INF

	; y<0, return 0
	fldz
	ret


X_NAN:
    addsd xmm4, xmm4
; sub esp, 16
;   movlpd QWORD PTR [esp+4], xmm4
;   fld    QWORD PTR [esp+4]
; add esp, 16	
;   ret
    $movsd xmm0, xmm4
    mov edx, 1006
    jmp CALL_LIBM_ERROR

RET_INVALID:
    ; x=-0?
    movlpd xmm2, QWORD PTR [esp+4]
    movd eax, xmm2
    psrlq xmm2, 32
    movd edx, xmm2
    and edx, 7fffffffH
    or eax, edx
    mov ecx, 0
    cmp eax, 0
    jz ZERO_X

    ; raise INVALID exception
    movlpd xmm1, QWORD PTR [sNaN]
    movlpd xmm0, QWORD PTR [QIND]
    mulsd xmm1, xmm1
    mov edx, 28
    jmp CALL_LIBM_ERROR


SPECIAL_Y:

    ; load x, y
    movlpd xmm4, QWORD PTR [esp+4]
    movlpd xmm2, QWORD PTR [esp+12]
    ; x=+/-1 ?
    ; load lower bits of x
    movd eax, xmm4
    cmp eax, 0
    jnz Y_INF_NAN

    psrlq xmm4, 32
    movd edx, xmm4
    ; x=1 ?
    cmp edx, 3ff00000H
    jz RET_ONE
	
    ; x=-1 ?
    cmp edx, 0bff00000H
    jnz Y_INF_NAN

    ; y=NaN ? (xmm1 contains y)
    movlpd xmm3, QWORD PTR [SIGMASK]
    xorpd xmm1, xmm1
    ; get significand bits, to determine if y=NaN
    andpd xmm3, xmm2
    ; significand bits = 0 ?
    pcmpeqd xmm1, xmm3
    pmovmskb eax, xmm1
    cmp eax, 0ffH
    jnz RET_Y_NAN

    ; y=+/-infinity, return 1    
    fld1
    ret 


Y_INF_NAN:

    movlpd xmm3, QWORD PTR [SIGMASK]
    xorpd xmm1, xmm1
    ; get significand bits, to determine if y=NaN
    andpd xmm3, xmm2
    ; significand bits = 0 ?
    pcmpeqd xmm1, xmm3
    pmovmskb eax, xmm1
    and eax, 0ffH
    cmp eax, 0ffH
    jnz RET_Y_NAN

    ; y infinity, get sign
    pextrw eax, xmm2, 3
    ; get x
    movlpd xmm4, QWORD PTR [esp+4]
    and eax, 8000H
    ; x=-1 ? (ecx,edx=high, low parts of x)
    xor ecx, 0bff00000H
    or  edx, ecx
    cmp edx, 0
    ; if x=-1, return 1
    jz RET_ONE     
    cmp eax, 0
    jz Y_INF

    ; |x|<1 ?  ( |x|=1 will not take this path)
    pextrw eax, xmm4, 3
    and eax, 7ff0H
    cmp eax, 3ff0H
    jb RET_INF

    ; |x|>1, y=-infinity, return 0
    fldz 
    ret


Y_INF:
    ; y=+infinity
    ; |x|>=1 ?  ( |x|=1 will not take this path)
    pextrw eax, xmm4, 3
    and eax, 7ff0H
    cmp eax, 3ff0H
    jae RET_INF

    ; |x|<1, return 0
    fldz
    ret
    
RET_INF:
    fld QWORD PTR [INF]
    ret  


RET_Y_NAN:
    addsd xmm2, xmm2
; sub esp, 16
;   movlpd QWORD PTR [esp+4], xmm2
;   fld QWORD PTR [esp+4]
; add esp, 16
;   ret
    $movsd xmm0, xmm2
    mov edx, 1006
    jmp CALL_LIBM_ERROR

Y_ZERO: 

    ; x=0 ?
    movd eax, xmm4
    psrlq xmm4, 32
    movd edx, xmm4
    and edx, 7fffffffH
    mov ecx, eax
    or eax, edx
    movlpd xmm0, QWORD PTR [ONEMASK]
    mov edx, 26
    cmp eax, 0
    jz CALL_LIBM_ERROR

    ; x=NaN ?
    movd eax, xmm4
    mov edx, 29
    and eax, 7fffffffH
    cmp eax, 7ff00000H
    ; x=NaN
    ja CALL_LIBM_ERROR
    ; x!=NaN
    jb Y_ZERO_RET
    ; x=NaN ?
    cmp ecx,0
    ja CALL_LIBM_ERROR
    
Y_ZERO_RET:
    ; return 1 for any x
  sub esp, 16
    movlpd QWORD PTR [esp+4], xmm0
    fld QWORD PTR [esp+4]
  add esp, 16

    ret

RET_ONE:
    ; used for x=+/-1, special y
;     fld1
;     ret


     movlpd xmm1, QWORD PTR [QIND]
     movlpd xmm0, QWORD PTR [esp+12]
     ; set Invalid flag, if necessary
     addsd xmm0, xmm1
     
     mov edx, 28
     ; jmp cALL_LIBM_ERROR


CALL_LIBM_ERROR:
	;call libm_error_support(void *arg1,void *arg2,void *retval,error_types input_tag)
	sub esp, 28
	movlpd QWORD PTR [esp+16], xmm0
	mov DWORD PTR [esp+12],edx
	mov edx, esp
	add edx,16
	mov DWORD PTR [esp+8],edx
	add edx,16+8
	mov DWORD PTR [esp+4],edx
	sub edx, 8
	mov DWORD PTR [esp],edx
	call NEAR PTR __libm_error_support
;	movlpd xmm0, QWORD PTR [esp+16]

;	movlpd    QWORD PTR [esp+16], xmm0       ; return result
	fld       QWORD PTR [esp+16]             ;
	add esp,28
	ret


UF_OF_CASES:
   cmp eax,0
   jle UNDERFLOW_CASES

   ; if eax>=2^11*2^7, oF occurs
   cmp eax, 40000H
   jae RET_INF_OF

   push esi
   ; overflow
   ; get table index, and exponent of result
   mov edx, eax
   ; ecx contains expected sign of the result, scaled by 2^11
   and eax, 7fH
   ; add exponent (bias+bias)*2^7
   add ecx, 3ff00h
   ; edx+=(bias+(-bias)-1)*2^7  ; the same -1
   sub edx, 128
   and edx, 0ffffff80H
   push edi
   mov edi, 3ff0H
   jmp OF_CONT


UNDERFLOW_CASES:

   cmp eax, (2-1024)*256
   jle RET_ZERO_UF

   push esi
   ; get table index, and exponent of result
   mov edx, eax
   ; ecx contains expected sign of the result, scaled by 2^11
   and eax, 7fH
   ; add exponent (bias+1-bias)*2^7
   add ecx, 80h
   ; edx=exponent*2^7
   and edx, 0ffffff80H
   ; edx+=(bias+bias-1)*2^7
   add edx, 3fe80H
   push edi
   mov edi, 0

OF_CONT:
   ; D1+D2+D3+(Rl+E)
   addsd xmm4, xmm0
   ; xmm0=xmm3=2^7*H
   $movsd xmm0, xmm3
   
   ; (2^7)*H+Shifter (to round to integer)
   addsd xmm3, QWORD PTR [Shifter]

   ; esi=edx-bias*2^7
   mov esi, edx
   sub esi, 1ff80H

   ; cl1*R|cl3*R
   mulpd xmm2, xmm7

   ; int((2^7)*H)=((2^7)*H+Shifter)-Shifter
   subsd xmm3, QWORD PTR [Shifter]

   ; R^2|R^2
   mulpd xmm7, xmm7

   ; R_exp_h'=R_exp_h*(2^7)=(2^7)*H-int((2^7)*H)
   subsd xmm0, xmm3

   ; load table values
   add eax, eax
   add eax, eax
   add eax, eax
   add eax, eax
   ; D|T
   movapd xmm3, QWORD PTR [exp2_tbl+eax] 

   ; load ce3|ce5
   movapd xmm6, QWORD PTR [cev]


   ; cl2*R^2|cl4*R^2
   mulpd xmm1, xmm7
   ; cl1*R+cl2*R^2|cl3*R+cl4*R^2
   addpd xmm2, xmm1
   ; unpack cl1*R+cl2*R^2
   pshufd xmm1, xmm2, 0eeh
   ; *|cl3*R^3+cl4*R^4
   mulsd xmm2, xmm7
   ; Pl14
   addsd xmm2, xmm1
   ; low part of log2(x): D1+D2+D3+(Rl+E)+P14
   addsd xmm2, xmm4

   ; load ce1
   movlpd xmm4, QWORD PTR [cev+32]
   ; load 2^k2 
   movd xmm1, edx
   ; edx=-(edx-bias*2^7)/2^7
   sub edx, 1ff80H
   neg edx
   sar edx, 7

   add edx, 2
   ; if edx>=32, set edx to 64+
   mov eax, edx
   and eax, 32
   add edx, eax

   ; xmm7=0
   xorpd xmm7, xmm7
   mov eax, 3f80H
   ; xmm7=scaling constant 
   pinsrw xmm7, eax, 3 

   ; y*(D1+D2+D3+(Rl+E)+P14)
   mulsd xmm2, QWORD PTR [esp+12+4+4]
   ; get R_exp_h=2^{-7}*R_exp_h'
   mulsd xmm0, xmm7

   psllq xmm1, 52-7
   ; xmm1=2^k2|2^k2
   pshufd xmm1, xmm1, 044h

   ; load ce2|ce4
   movapd xmm7, QWORD PTR [cev+16]
   ; low part of y*log2(x): yH*HL+yL*HH+yL*HL+y*(D1+D2+D3+(Rl+E)+P14)
   addsd xmm5, xmm2

   ; get D*2^k|T*2^k
   mulpd xmm3, xmm1
   ; get R_exp=R_exp_h+yH*HL+yL*HH+yL*HL+y*(D1+D2+D3+(Rl+E)+P14)
   addsd xmm0, xmm5
   ; xmm0=R_exp|R_exp
   unpcklpd xmm0, xmm0

   ; ce3*R_exp|ce5*R_exp
   mulpd xmm6, xmm0
   ; ce1*R_exp
   mulsd xmm4, xmm0  
   ; R_exp^2|R_exp^2
   mulpd xmm0, xmm0
   ; ce2+ce3*R_exp|ce4+ce5*R_exp
   addpd xmm7, xmm6
   ; R_exp^2*(ce2+ce3*R_exp)|R_exp^2*(ce4+ce5*R_exp)
   mulpd xmm7, xmm0
   ; R_exp^2*(T*2^k)
   mulsd xmm0, xmm3
   ; unpack R_exp^2*(ce2+ce3*R_exp)
   pshufd xmm6, xmm7, 0eeh
   ; R_exp^4*(T*2^k)*(ce4+ce5*R_exp)
   mulsd xmm0, xmm7
   ; unpack D*2^k
   pshufd xmm5, xmm3, 0eeh
   ; R_exp^2*(T*2^k)*(ce2+ce3*R_exp)
   mulsd xmm6, xmm3
   ; ce1*(T*2^k)*R_exp
   mulsd xmm4, xmm3 

   ; xmm7=2^k'
   movd  xmm7, ecx
   psllq xmm7, 52-7 

   movd xmm2, edx
   pcmpeqd xmm1, xmm1
   psllq xmm1, xmm2

   ; P45*(T*2^k)+D*2^k  
   addsd xmm0, xmm5 
   ; P25*(T*2^k)+D*2^k
   addsd xmm0, xmm6

   ; Th
   andpd xmm1, xmm3

   ; P15*(T*2^k)+D*2^k
   addsd xmm0, xmm4
   ; xmm6=0
   xorpd xmm6, xmm6

   pcmpeqd xmm4, xmm4
   psllq xmm4, xmm2

   ; Tl
   subsd xmm3, xmm1
   ; xmm2=Th
   $movsd xmm2, xmm1

   ; (Th+(P15*(T*2^k)+D*2^k)_high)_high
   addsd xmm1, xmm0
   andpd xmm1, xmm4
   ; xmm6=(possible OF)?1:0
   pinsrw xmm6, edi, 3
   pop edi

   ; -(P15*(T*2^k)+D*2^k)_high
   subsd xmm2, xmm1

   ; (P15*(T*2^k)+D*2^k)_low
   addsd xmm0, xmm2

   ; Tl+(P15*(T*2^k)+D*2^k)_low
   addsd xmm0, xmm3

   cmp esi, 0
   jg  SCALE2

   pop esi
   ; final scaling by 2^k'
   mulsd xmm0, xmm7
   mulsd xmm1, xmm7

   ; final addition
   addsd xmm0, xmm1

   mulsd xmm6, xmm0
   addsd xmm0, xmm6

   ; overflow, or underflow
   pextrw eax, xmm0, 3
   and eax, 7ff0H
   mov edx, 24
   cmp eax, 7ff0H
   jz CALL_LIBM_ERROR

   mov edx, 25
   cmp eax, 0
   jz CALL_LIBM_ERROR

sub esp, 16
	movlpd    QWORD PTR [esp+4], xmm0       ; return result
	fld       QWORD PTR [esp+4]             ;
add esp, 16
	ret


SCALE2: 
   pop esi

   ; final addition
   addsd xmm0, xmm1
   ; final scaling by 2^k'
   mulsd xmm0, xmm7

   mulsd xmm6, xmm0
   addsd xmm0, xmm6

   ; overflow, or underflow
   pextrw eax, xmm0, 3
   and eax, 7ff0H
   mov edx, 24
   cmp eax, 7ff0H
   jz CALL_LIBM_ERROR

   mov edx, 25
   cmp eax, 0
   jz CALL_LIBM_ERROR

sub esp, 16
	movlpd    QWORD PTR [esp+4], xmm0       ; return result
	fld       QWORD PTR [esp+4]             ;
add esp, 16
	ret


RET_ZERO_UF:

   movlpd xmm0, QWORD PTR [EMIN]
   ; sign
   movd xmm1, ecx
   mulsd xmm0, xmm0

   ; set sign
   psllq xmm1, 63-18
   orpd xmm0, xmm1

   mov edx, 25
   jmp CALL_LIBM_ERROR

RET_INF_OF:

   mov edx, 24

   ; check sign
   cmp ecx, 0
   jz RET_INF_OF2

   movlpd xmm0, QWORD PTR [NEG_INF]
   jmp CALL_LIBM_ERROR

RET_INF_OF2:

   movlpd xmm0, QWORD PTR [INF]
   jmp CALL_LIBM_ERROR


RETURN_ONE:
   ; y|y
   pshufd xmm4, xmm1, 44H
   ; y*log2(x)_high
   mulpd xmm4, xmm6
   ; get exponent
   pextrw eax, xmm4, 3
   and eax, 7ff0H
   ; y*log2(x)>=2^{11} ? (i.e. 2^{11}-eps-x<0)
   mov edx, 40a0H
   sub edx, eax
   ; avoid underflow on intermediate calculations (|y*log2(x)|<2^{-56} ?)
   sub eax, 3c70H
   or edx, eax
   cmp edx, 80000000H
   ; if no OF/UF occurs, return to main path
   jb BACK_XY_CHECK




CONT_OF_UF:
   ; overflow/underflow ?
   cmp eax, 80000000H
   jb OF_UF

RET_ONE2:
   ; return +/- 1
   or ecx, 1ff80H
   movd xmm0, ecx
   psllq xmm0, 52-7

sub esp, 16
   movlpd [esp+4], xmm0
   fld QWORD PTR [esp+4]
add esp, 16
   ret

OF_UF:

   movlpd xmm4, [esp+4]
   pextrw edx, xmm4, 3
   and edx, 7ff0H
   sub edx, 3ff0H

   pextrw eax, xmm1, 3
   xor eax, edx
   and eax, 8000H
   cmp eax, 0
   jnz RET_ZERO_UF
   jmp RET_INF_OF


_CIpow_pentium4 ENDP

    ALIGN 16
_TEXT ENDS

    END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\i386\tan.asm ===
;***
;
;   Copyright (c) 1984-2001, Microsoft Corporation. All rights reserved.
;
;Revision History:
;
;*******************************************************************************

_TAN_ equ 1
include trig.asm
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\i386\sqrt.asm ===
;***
;
;   Copyright (c) 1984-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;        support for sqrt() function
;
;Revision History:
;
;*******************************************************************************

.xlist
        include cruntime.inc
        include elem87.inc
.list

        .data
extrn   _indefinite:tbyte
extrn   __fastflag:dword

_NAME_  db 'sqrt',0,0,0,0

        CODESEG

extrn   _startOneArgErrorHandling:near
extrn   _fload_withFB:near
extrn   _convertTOStoQNaN:near
extrn   _checkTOS_withFB:near
extrn   _math_exit:near
extrn   _fast_exit:near
extrn   _load_CW:near


; MUST BE MODIFIED
; arg                ErrorType        result
;-------------------------------------------
;QNaN                DOMAIN_QNAN      QNaN
;SNaN                DOMAIN           indefinite
;negative            DOMAIN           indefinite
;-infinity           DOMAIN           indefinite
;+infinity           -                infinity
;+0.0                -                +0.0
;-0.0                -                -0.0
;indefinite is like QNaN
;denormal        fld converts it to normal (80 bits)

        public sqrt,_CIsqrt
_CIsqrt        proc
        sub     esp,DBLSIZE+4                   ; for argument
        fst     qword ptr [esp]
        call    _checkTOS_withFB
        call    start
        add     esp,DBLSIZE+4
        ret

sqrt        label        proc
        lea     edx,[esp+4]
        call    _fload_withFB
start:
        push    edx                           ; allocate space for Control Word
        fstcw   [esp]                         ; store Control Word
        mov     eax,[esp+0ch]                 ; eax contains high dword

; at this point we have on stack: cw(4), ret_addr(4), arg1(8bytes)

        jz      inf_or_nan
        cmp     word ptr[esp], default_CW
        je      CW_is_set_to_default
        call    _load_CW                      ; use user's precision bits
CW_is_set_to_default:
        test    eax,80000000h
        jnz     test_if_x_zero
x_is_denormal:                                ; denormal is like normal
        fsqrt
exit:
        cmp     __fastflag,0
        jnz     _fast_exit

; prepare in registers arguments for math_exit
        mov     edx,OP_SQRT
        lea     ecx,[_NAME_]
        jmp     _math_exit

test_if_x_zero:                               ; x <= 0
        test    eax,7ff00000H
        jnz     negative_x
        test    eax,000fffffH
        jnz     negative_x                    ; denormal operand
        cmp     dword ptr[esp+8],0            ; test if low dword is zero
        jnz     negative_x                    ; denormal operand
        jmp     exit


not_infinity:
        call    _convertTOStoQNaN             ; eax MUST contain high dword
        jmp     _Error_handling               ; eax=error number
inf_or_nan:
        test    eax,000fffffh
        jnz     not_infinity
        cmp     dword ptr[esp+8],0            ; test if low dword is zero
        jnz     not_infinity
        and     eax,80000000H                 ; test sign of infinity
        jz      exit                          ; infinity is already in ST(0)
negative_x:
        fstp    st(0)
        fld     [_indefinite]
        mov     eax,DOMAIN
_Error_handling:
        cmp     __fastflag,0
        jnz     _fast_exit
        mov     edx,OP_SQRT
        lea     ecx,[_NAME_]
        call    _startOneArgErrorHandling
        pop     edx                           ; remove saved CW from stack
        ret
_CIsqrt        endp
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\i386\temp_context.h ===
//
// This is a temp file that defines to be defined data structures - WINNT.H
//

#define CONTEXT_EXTENDED_REGISTERS  (CONTEXT_i386 | 0x00000020L) // cpu specific extensions

#define MAXIMUM_SUPPORTED_EXTENSION     512

//
// Context Frame
//
//  This frame has a several purposes: 1) it is used as an argument to
//  NtContinue, 2) is is used to constuct a call frame for APC delivery,
//  and 3) it is used in the user level thread creation routines.
//
//  The layout of the record conforms to a standard call frame.
//

typedef struct _TEMP_CONTEXT {

    //
    // The flags values within this flag control the contents of
    // a CONTEXT record.
    //
    // If the context record is used as an input parameter, then
    // for each portion of the context record controlled by a flag
    // whose value is set, it is assumed that that portion of the
    // context record contains valid context. If the context record
    // is being used to modify a threads context, then only that
    // portion of the threads context will be modified.
    //
    // If the context record is used as an IN OUT parameter to capture
    // the context of a thread, then only those portions of the thread's
    // context corresponding to set flags will be returned.
    //
    // The context record is never used as an OUT only parameter.
    //

    DWORD ContextFlags;

    //
    // This section is specified/returned if CONTEXT_DEBUG_REGISTERS is
    // set in ContextFlags.  Note that CONTEXT_DEBUG_REGISTERS is NOT
    // included in CONTEXT_FULL.
    //

    DWORD   Dr0;
    DWORD   Dr1;
    DWORD   Dr2;
    DWORD   Dr3;
    DWORD   Dr6;
    DWORD   Dr7;

    //
    // This section is specified/returned if the
    // ContextFlags word contians the flag CONTEXT_FLOATING_POINT.
    //

    FLOATING_SAVE_AREA FloatSave;

    //
    // This section is specified/returned if the
    // ContextFlags word contians the flag CONTEXT_SEGMENTS.
    //

    DWORD   SegGs;
    DWORD   SegFs;
    DWORD   SegEs;
    DWORD   SegDs;

    //
    // This section is specified/returned if the
    // ContextFlags word contians the flag CONTEXT_INTEGER.
    //

    DWORD   Edi;
    DWORD   Esi;
    DWORD   Ebx;
    DWORD   Edx;
    DWORD   Ecx;
    DWORD   Eax;

    //
    // This section is specified/returned if the
    // ContextFlags word contians the flag CONTEXT_CONTROL.
    //

    DWORD   Ebp;
    DWORD   Eip;
    DWORD   SegCs;              // MUST BE SANITIZED
    DWORD   EFlags;             // MUST BE SANITIZED
    DWORD   Esp;
    DWORD   SegSs;

    //
    // This section is specified/returned if the ContextFlags word
    // contains the flag CONTEXT_EXTENDED_REGISTERS.
    // The format and contexts are processor specific
    //

    BYTE    ExtendedRegisters[MAXIMUM_SUPPORTED_EXTENSION];

} TEMP_CONTEXT, *PTEMP_CONTEXT;


typedef struct _TEMP_EXCEPTION_POINTERS {
    PEXCEPTION_RECORD ExceptionRecord;
    PTEMP_CONTEXT ContextRecord;
} TEMP_EXCEPTION_POINTERS, *PTEMP_EXCEPTION_POINTERS;


#define SIZE_OF_X87_REGISTERS       128
#define SIZE_OF_XMMI_REGISTERS      128
#define SIZE_OF_FX_REGISTERS        128
#define NUMBER_OF_REGISTERS         8


typedef struct _FLOATING_EXTENDED_SAVE_AREA {
    USHORT  ControlWord;
    USHORT  StatusWord;
    USHORT  TagWord;
    USHORT  ErrorOpcode;
    ULONG   ErrorOffset;
    ULONG   ErrorSelector;
    ULONG   DataOffset;
    ULONG   DataSelector;
    ULONG   MXCsr;
    ULONG   Reserved2;
    UCHAR   X87RegisterArea[SIZE_OF_FX_REGISTERS];
    UCHAR   XMMIRegisterArea[SIZE_OF_FX_REGISTERS];
    UCHAR   Reserved4[224];
} FLOATING_EXTENDED_SAVE_AREA, *PFLOATING_EXTENDED_SAVE_AREA;


typedef struct _MMX_AREA {
    MMX64    Mmx;
    _U64     Reserved;
} MMX_AREA, *PMMX_AREA;

typedef struct _X87_AREA {
    MMX_AREA Mm[NUMBER_OF_REGISTERS];
} X87_AREA, *PX87_AREA;

typedef struct _XMMI_AREA {
    XMMI128  Xmmi[NUMBER_OF_REGISTERS];
} XMMI_AREA, *PXMMI_AREA;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\i386\triga.asm ===
;***
;
;   Copyright (c) 1984-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;        support for asin() and acos() functions
;
;Revision History:
;
;*******************************************************************************

.xlist
        include cruntime.inc
        include elem87.inc
.list

        .data

ifdef         _ACOS_
    _NAME_ db 'acos',0,0,0,0
    _FUNC_    equ <acos>
    _IFUNC_   equ <_CIacos>
elseifdef _ASIN_
    _SIN_  equ 1
    _NAME_ db 'asin',0,0,0,0
    _FUNC_    equ <asin>
    _IFUNC_   equ <_CIasin>
endif

extrn   _indefinite:tbyte
extrn   __fastflag:dword
extrn   _piby2:tbyte

        CODESEG

extrn   _startOneArgErrorHandling:near
extrn   _fload_withFB:near
extrn   _convertTOStoQNaN:near
extrn   _checkTOS_withFB:near
extrn   _math_exit:near
extrn   _fast_exit:near
extrn   _load_CW:near


; arg                ErrorType        result
;------------------------------------------------
; |x| >1             DOMAIN           indefinite
;+/-infinity         DOMAIN           indefinite      |  ? Do we really need
;QNaN                DOMAIN_QNAN      QNaN            |  ? to distinguish them???
;SNaN                DOMAIN           indefinite      |  ? it costs 14 bytes per function
;indefinite is  like QNaN
;denormal        fld converts it to normal (80 bits)

        public _FUNC_,_IFUNC_
_IFUNC_ proc
        sub     esp,DBLSIZE+4                   ; for argument
        fst     qword ptr [esp]
        call    _checkTOS_withFB
        call    start
        add     esp, DBLSIZE+4
        ret

_FUNC_        label        proc
        lea     edx, [esp+4]
        call    _fload_withFB
start:
        push    edx                           ; allocate space for Control Word
        fstcw   [esp]                         ; store Control Word

; at this point we have on stack: cw(4), ret_addr(4), arg1(8bytes)

        jz      inf_or_nan
        cmp     word ptr[esp], default_CW
        je      CW_is_set_to_default
        call    _load_CW                      ; use user's precision bits
CW_is_set_to_default:
        cmp     eax,3ff00000H                 ; check if |x|>=1
        jae     x_huge

        fld1                                  ; load 1.0
        fadd    st, st(1)                     ; 1+x
        fld1                                  ; load 1.0
        fsub    st, st(2)                     ; 1-x
        fmul                                  ; (1+x)(1-x)
        fsqrt                                 ; sqrt((1+x)(1-x))
ifdef        _ACOS_
        fxch
endif
        fpatan                                ; fpatan(x,sqrt((1+x)(1-x)))

exit:
        cmp     __fastflag, 0
        jnz     _fast_exit

; prepare in registers arguments for math_exit
ifdef _ACOS_
        mov     edx,OP_ACOS
elseifdef _ASIN_
        mov     edx,OP_ASIN
endif
        lea     ecx,[_NAME_]
        jmp     _math_exit


x_huge: ja      not_in_range
        mov     eax,[esp+0cH]
        mov     ecx,eax
        and     eax,000fffffH
        or      eax,[esp+8]
        jnz     not_in_range
        and     ecx,80000000H
        fstp    st(0)                         ; remove TOS
ifdef        _ASIN_
        fld     _piby2                        ; asin(1) = pi/2
        jz      exit
        fchs                                  ; asin(-1) = -pi/2
        jmp     exit
elseifdef _ACOS_
        jz      ret_zero
        fldpi
        jmp     exit
ret_zero:
        fldz
        jmp     exit
endif



not_infinity:
        call    _convertTOStoQNaN             ; eax MUST contain high dword
        jmp     _Error_handling               ; eax=error number
inf_or_nan:
        test    eax, 000fffffh
        jnz     not_infinity
        cmp     dword ptr[esp+8], 0
        jne     not_infinity
not_in_range:
        fstp    st(0)
        fld     [_indefinite]
        mov     eax,DOMAIN
_Error_handling:
        cmp     __fastflag, 0
        jnz     _fast_exit

ifdef _ACOS_
        mov     edx,OP_ACOS
elseifdef _ASIN_
        mov     edx,OP_ASIN
endif
        lea     ecx,[_NAME_]
        call    _startOneArgErrorHandling
        pop     edx                           ; remove saved CW from stack
        ret

_IFUNC_        endp
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\i386\testfdiv.c ===
/***
*testfdiv.c - routine to test for correct operation of x86 FDIV instruction.
*
*	Copyright (c) 1994-2001, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	Detects early steppings of Pentium with incorrect FDIV tables using
*	'official' Intel test values. Returns 1 if flawed Pentium is detected,
*	0 otherwise.
*
*Revision History:
*	12-19-94  JWM	file added
*	12-22-94  JWM	Now safe for TNT, et al
*	01-13-95  JWM	underscores added for ANSI compatibility
*	12-12-95  SKS	Skip redundant Pentium test on uni-processor systems
*	12-13-95  SKS	Call LoadLibrary() rather than GetModuleHandle()
*			since "kernel32.dll" is always going to be present.
*	01-18-96  JWM	Now handles possible failure of SetThreadAffinityMask(),
*			incorporating various suggestions of MarkL.
*	05-29-96  JWM	No longer loops through affinity mask; instead, uses MarkL's
*			new IsProcessorFeaturePresent() API if possible, only tests
*			1st processor if not.
*
*******************************************************************************/

#include <windows.h>

int _ms_p5_test_fdiv(void)
{
    double dTestDivisor = 3145727.0;
    double dTestDividend = 4195835.0;
    double dRslt;

    _asm {
        fld    qword ptr [dTestDividend]
        fdiv   qword ptr [dTestDivisor]
        fmul   qword ptr [dTestDivisor]
        fsubr  qword ptr [dTestDividend]
        fstp   qword ptr [dRslt]
    }

    return (dRslt > 1.0);
}

/* 
 * Multiprocessor Pentium test: returns 1 if any processor is a flawed
 * Pentium, 0 otherwise.
 */

int _ms_p5_mp_test_fdiv(void)
{

    #define PF_FLOATING_POINT_PRECISION_ERRATA 0
    HINSTANCE LibInst;
    FARPROC pIsProcessorFeaturePresent;

    if ((LibInst = GetModuleHandle("KERNEL32")) &&
         (pIsProcessorFeaturePresent = GetProcAddress(LibInst, "IsProcessorFeaturePresent")))
        return (*pIsProcessorFeaturePresent)(PF_FLOATING_POINT_PRECISION_ERRATA);
    else
        return _ms_p5_test_fdiv();

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\i386\trig.asm ===
;***
;
;   Copyright (c) 1984-2001, Microsoft Corporation. All rights reserved.
;
;Purpose:
;        support for sin(), cos() and tan() functions
;
;Revision History:
;
;*******************************************************************************

.xlist
        include cruntime.inc
        include elem87.inc
.list

        .data
extrn   _indefinite:tbyte
extrn   __fastflag:dword
extrn   _pi_by_2_to_61:tbyte
extrn   _DEFAULT_CW_in_mem:word


ifdef           _COS_
    _NAME_ db 'cos',0
    _FUNC_    equ <cos>
    _IFUNC_   equ <_CIcos>
elseifdef       _TAN_
    _NAME_ db 'tan',0
    _FUNC_    equ <tan>
    _IFUNC_   equ <_CItan>
elseifdef       _SIN_
    _SIN_  equ 1
    _NAME_ db 'sin',0
    _FUNC_    equ <sin>
    _IFUNC_   equ <_CIsin>
endif
        CODESEG

extrn   _startOneArgErrorHandling:near
extrn   _fload_withFB:near
extrn   _convertTOStoQNaN:near
extrn   _checkTOS_withFB:near
extrn   _math_exit:near
extrn   _fast_exit:near


; arg                ErrorType        result
;-------------------------------------------
;+/-infinity         DOMAIN           indefinite      |  ? Do we really need
;QNaN                DOMAIN_QNAN      QNaN            |  ? to distinguish them???
;SNaN                DOMAIN           indefinite      |  ? it costs 14 bytes per function
;indefinite is  like QNaN
;denormal        fld converts it to normal (80 bits)

        public _FUNC_,_IFUNC_
_IFUNC_ proc
        sub     esp,DBLSIZE+4                   ; for argument
        fst     qword ptr [esp]
        call    _checkTOS_withFB
        call    start
        add     esp, DBLSIZE+4
        ret

_FUNC_        label        proc
        lea     edx, [esp+4]
        call    _fload_withFB
start:
        push    edx                           ; allocate space for Control Word
        fstcw   [esp]                         ; store Control Word

; at this point we have on stack: cw(4), ret_addr(4), arg1(8bytes)

        jz      inf_or_nan
        cmp     word ptr[esp], default_CW
        je      CW_is_set_to_default

; fsin/fcos/fptan are not affected by precizion bits.
; So we may ignore user's CW

        fldcw   _DEFAULT_CW_in_mem
CW_is_set_to_default:

ifdef         _COS_
        fcos
        fstsw   ax
elseifdef _SIN_
        fsin
        fstsw   ax
elseifdef _TAN_
        fptan
        fstsw   ax
endif
        sahf
        jp      reduce_arg
ifdef    _TAN_
        fstp    st(0)
endif
exit:
        cmp     __fastflag, 0
        jnz     _fast_exit

; prepare in registers arguments for math_exit
ifdef _COS_
        mov     edx,OP_COS
elseifdef _SIN_
        mov     edx,OP_SIN
elseifdef _TAN_
        mov     edx,OP_TAN
endif
        lea     ecx,[_NAME_]
        jmp     _math_exit


reduce_arg:
        fld     TBYTE PTR [_pi_by_2_to_61]
        fxch    st(1)
redux_loop:
        fprem1
        fstsw   ax
        sahf
        jp      redux_loop

;reapply
        fstp    st(1)
ifdef         _COS_
        fcos
elseifdef _SIN_
        fsin
elseifdef _TAN_
        fptan
        fstp    st(0)
endif
        jmp     exit

not_infinity:
        call    _convertTOStoQNaN             ; eax MUST contain high dword
        jmp     _Error_handling               ; eax=error number
inf_or_nan:
        test    eax, 000fffffh
        jnz     not_infinity
        cmp     dword ptr[esp+8], 0
        jne     not_infinity
        fstp    st(0)
        fld     [_indefinite]
        mov     eax,DOMAIN
_Error_handling:
        cmp     __fastflag, 0
        jnz     _fast_exit

ifdef _COS_
        mov     edx,OP_COS
elseifdef _SIN_
        mov     edx,OP_SIN
elseifdef _TAN_
        mov     edx,OP_TAN
endif
        lea     ecx,[_NAME_]
        call    _startOneArgErrorHandling
        pop     edx                           ; remove saved CW from stack
        ret

_IFUNC_        endp
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\i386\xmmi_fp_emul.c ===
/*****************************************************************************
 *                                                                           *
 *                           Intel Confidential                              *
 *                                                                           *
 *                                                                           *
 * XMMI_FP_emulate () - XMMI FP instruction emulation for the FP IEEE filter *
 *                                                                           *
 *                                                                           *
 * History:                                                                  *
 *    Marius Cornea-Hasegan, Mar 1998; modified Jun 1998; added DAZ Oct 2000 *
 *    marius.cornea@intel.com                                                *
 *                                                                           *
 *****************************************************************************/

// #define _DEBUG_FPU
// #define _XMMI_DEBUG

// XMMI_FP_Emulation () receives the input operands of a XMMI FP instruction 
// (operating on single-precision floating-point numbers and/or signed 
// integers), that might cause a floating-point exception (enabled or not).
//
// Arguments: PXMMI_ENV XmmiEnv
//
//  The type of every field (INPUT or OUTPUT) is indicated below:
//
//  typedef struct _XMMI_ENV {
//      ULONG Masks;                  //Mask values from MxCsr   INPUT
//      ULONG Fz;                     //Flush to Zero            INPUT
//      ULONG Rc;                     //Rounding                 INPUT
//      ULONG Precision;              //Precision                INPUT
//      ULONG Imm8;                   //imm8 predicate           INPUT
//      ULONG EFlags;                 //EFlags                   INPUT/OUTPUT
//      _FPIEEE_RECORD *Ieee;         //FP IEEE Record           INPUT/OUTPUT,
//                                                               field dependent
//  } XMMI_ENV, *PXMMI_ENV;
// 
//  The _FP_IEEE record and the _FPIEEE_VALUE are defined as:
//  
//  typedef struct {
//      unsigned int RoundingMode : 2;                   OUTPUT
//      unsigned int Precision : 3;                      OUTPUT
//      unsigned int Operation :12;                      INPUT
//      _FPIEEE_EXCEPTION_FLAGS Cause;                   OUTPUT
//      _FPIEEE_EXCEPTION_FLAGS Enable;                  OUTPUT
//      _FPIEEE_EXCEPTION_FLAGS Status;                  OUTPUT
//      _FPIEEE_VALUE Operand1;                          INPUT
//      _FPIEEE_VALUE Operand2;                          INPUT
//      _FPIEEE_VALUE Result;                            INPUT/OUTPUT,
//                                                       field dependent
//  } _FPIEEE_RECORD, *_PFPIEEE_RECORD;
//  
//  typedef struct {
//      union {
//          _FP32    Fp32Value;
//          _FP64    Fp64Value;
//          _FP80    Fp80Value;
//          _FP128   Fp128Value;
//          _I16     I16Value;
//          _I32     I32Value;
//          _I64     I64Value;
//          _U16     U16Value;
//          _U32     U32Value;
//          _U64     U64Value;
//          _BCD80   Bcd80Value;
//          char     *StringValue;
//          int      CompareValue;
//      } Value;                                         INPUT for operands,
//                                                       OUTPUT for result
//
//      unsigned int OperandValid : 1;                   INPUT for operands
//                                                       INPUT/OUTPUT for result
//      unsigned int Format : 4;                         INPUT
//  
//  } _FPIEEE_VALUE;
//
// Return Value: 
//   ExceptionRaised if an enabled floating-point exception condition is 
//       detected; in this case, the fields of XmmiEnv->Ieee are filled in
//       appropriately to be passed directly to a user exception handler; the
//       XmmiEnv->Ieee->Cause bits indicate the cause of the exception, but if
//       a denormal exception occurred, then no XmmiEnv->Ieee->Cause bit is set;
//       upon return from the user handler, the caller of XMMI_FP_emulate should
//       interpret the result for a compare instruction (CMPPS, CMPPS, COMISS,
//       UCOMISS); the Enable, Rounding, and Precision fields in _FPIEEE_RECORD
//       have to be checked too for possible changes by the user handler
//      
//   NoExceptionRaised if no floating-point exception condition occurred, or
//       if a disabled floating-point exception occurred; in this case,
//       XmmiEnv->Ieee->Result.Value contains the instruction's result, 
//       XmmiEnv->Ieee->Status contains the IEEE floating-point status flags
//
// Implementation Notes:
//
//   - the operation code in XmmiEnv->Ieee->Operation is changed as expected
//     by a user exception handler (even if no exception is raised):
//     from OP_ADDPS, OP_ADDSS to _FpCodeAdd
//     from OP_SUBPS, OP_SUBSS to _FpCodeSubtract
//     from OP_MULPS, OP_MULSS to _FpCodeMultiply
//     from OP_DIVPS, OP_DIVSS to _FpCodeDivide
//     from OP_CMPPS, OP_CMPSS to _FpCodeCompare
//     from OP_COMISS, OP_UCOMISS to _FpCodeCompare
//     from OP_CVTPI2PS, OP_CVTSI2SS to _FpCodeConvert
//     from OP_CVTPS2PI, OP_CVTSS2SI to _FpCodeConvert
//     from OP_CVTTPS2PI, OP_CVTTSS2SI to _FpCodeConvertTrunc
//     from OP_MAXPS, OP_MAXSS to _FpCodeMax
//     from OP_MINPS, OP_MINSS to _FpCodeMin
//     from OP_SQRTPS, OP_SQRTSS to _FpCodeSquareRoot
//
//
//   - for ADDPS, ADDSS, SUBPS, SUBSS, MULPS, MULSS, DIVPS, DIVSS:
//
//     - execute the operation with x86 instructions (fld, 
//       faddp/fsubp/fmulp/fdivp, and fstp), using the user
//       rounding mode, 24-bit significands, and 11-bit exponents for results
//     - if the invalid flag is set and the invalid exceptions are enabled, 
//       take an invalid trap (i.e. return RaiseException with the IEEE record
//       filled out appropriately)
//     - if any input operand is a NaN:
//       - if both operands are NaNs, return the first operand ("quietized" 
//         if SNaN)
//       - if only one operand is a NaN, return it ("quietized" if SNaN)
//       - set the invalid flag if needed, and return NoExceptionRaised
//     - if the denormal flag is set and the denormal exceptions are enabled, 
//       take a denormal trap (i.e. return RaiseException with the IEEE record
//       filled out appropriately [no Cause bit set])
//     - if the divide by zero flag is set (for DIVPS and DIVSS only) and the
//       divide by zero exceptions are enabled, take a divide by zero trap 
//       (i.e. return RaiseException with the IEEE record filled out 
//       appropriately)
//     - if the result is a NaN (QNaN Indefinite), the operation must have been
//       Inf - Inf, Inf * 0, Inf / Inf, or 0 / 0; set the invalid status flag
//       and return NoExceptionRaised
//     - determine whether the result is tiny or huge
//     - if the underflow traps are enabled and the result is tiny, take an
//       underflow trap (i.e. return RaiseException with the IEEE record 
//       filled out appropriately)
//     - if the overflow traps are enabled and the result is huge, take an
//       overflow trap (i.e. return RaiseException with the IEEE record 
//       filled out appropriately)
//     - re-do the operation with x86 instructions, using the user rounding
//       mode, 53-bit significands, and 11-bit exponents for results (this will
//       allow rounding to 24 bits without a double rounding error - needed for
//       the case the result requires denormalization) [cannot denormalize
//       without a possible double rounding error starting from a 24-bit
//       significand]
//     - round to 24 bits (or to less than 24 bits if denormalization is 
//       needed), for the case an inexact trap has to be taken, or if no
//       exception occurs
//     - if the result is inexact and the inexact exceptions are enabled, 
//       take an inexact trap (i.e. return RaiseException with the IEEE record
//       filled out appropriately); if the flush-to-zero mode is enabled and
//       the result is tiny, the result is flushed to zero
//     - if no exception has to be raised, the flush-to-zero mode is enabled,
//       and the result is tiny, then the result is flushed to zero; set the 
//       status flags and return NoExceptionRaised
//
//   - for CMPPS, CMPSS
//
//     - for EQ, UNORD, NEQ, ORD, SNaN operands signal invalid
//     - for LT, LE, NLT, NLE, QNaN/SNaN operands (one or both) signal invalid
//     - if the invalid exception condition is met and the invalid exceptions
//       are enabled, take an invalid trap (i.e. return RaiseException with the
//       IEEE record filled out appropriately)
//     - if any operand is a NaN and the compare type is EQ, LT, LE, or ORD, 
//       set the result to "false", set the value of the invalid status flag,
//       and return NoExceptionRaised
//     - if any operand is a NaN and the compare type is NEQ, NLT, NLE, or
//       UNORD, set the result to "false", set the value of the invalid status 
//       flag, and return NoExceptionRaised
//     - if any operand is denormal and the denormal exceptions are enabled, 
//       take a denormal trap (i.e. return RaiseException with the IEEE record
//       filled out appropriately [no Cause bit set])
//     - if no exception has to be raised, determine the result and return
//       NoExceptionRaised
//
//   - for COMISS, UCOMISS
//
//     - for COMISS, QNaN/SNaN operands (one or both) signal invalid
//     - for UCOMISS, SNaN operands (one or both) signal invalid
//     - if the invalid exception condition is met and the invalid exceptions
//       are enabled, take invalid trap (i.e. return RaiseException with the
//       IEEE record filled out appropriately)
//     - if any operand is a NaN, set OF, SF, AF = 000, ZF, PF, CF = 111,
//       set the value of the invalid status flag, and return NoExceptionRaised
//     - if any operand is denormal and the denormal exceptions are enabled, 
//       take a denormal trap (i.e. return RaiseException with the IEEE record
//       filled out appropriately [no Cause bit set])
//     - if no exception has to be raised, determine the result and set EFlags,
//       set the value of the invalid status flag, and return NoExceptionRaised
//
//   - for CVTPI2PS, CVTSI2SS
//
//     - execute the operation with x86 instructions (fild and fstp), using the
//       user rounding mode, 24-bit significands, and an 8-bit exponent for
//       the result
//     - if the inexact flag is set and the inexact exceptions are enabled, 
//       set the result and take an inexact trap (i.e. return RaiseException
//       with the IEEE record filled out appropriately)
//     - if no exception has to be raised, set the result, the value of the
//       inexact status flag and return NoExceptionRaised
//
//   - for CVTPS2PI, CVTSS2SI, CVTTPS2PI, CVTTSS2SI
//
//     - execute the operation with x86 instructions (fld and fistp), using
//       the user rounding mode for CVT* and chop for CVTT*
//     - if the invalid flag is set and the invalid exceptions are enabled, 
//       take an invalid trap (i.e. return RaiseException with the IEEE record
//       filled out appropriately) [the invalid operation condition occurs for 
//       any input operand that does not lead through conversion to a valid
//       32-bit signed integer; the result is in such cases the Integer
//       Indefinite value]
//     - set the result value
//     - if the inexact flag is set and the inexact exceptions are enabled, 
//       take an inexact trap (i.e. return RaiseException with the IEEE record
//       filled out appropriately)
//     - if no exception has to be raised, set the value of the invalid status
//       flag and of the inexact status flag and return NoExceptionRaised
//
//   - for MAXPS, MAXSS, MINPS, MINSS
//
//     - check for invalid exception (QNaN/SNaN operands signal invalid)
//     - if the invalid exception condition is met and the invalid exceptions
//       are enabled, take an invalid trap (i.e. return RaiseException with the
//       IEEE record filled out appropriately)
//     - if any operand is a NaN, set the result to the value of the second 
//       operand, set the invalid status flag to 1, and return NoExceptionRaised
//     - if any operand is denormal and the denormal exceptions are enabled, 
//       take a denormal trap (i.e. return RaiseException with the IEEE record
//       filled out appropriately [no Cause bit set])
//     - if no exception has to be raised, determine the result and return
//       NoExceptionRaised
//
//   - for SQRTPS, SQRTSS
//
//     - execute the operation with x86 instructions (fld, fsqrt, and fstp),
//       using the user rounding mode, 24-bit significands, and an 8-bit
//       exponent for the result
//     - if the invalid flag is set and the invalid exceptions are enabled, 
//       take an invalid trap (i.e. return RaiseException with the IEEE record
//       filled out appropriately)
//     - if the denormal flag is set and the denormal exceptions are enabled, 
//       take a denormal trap (i.e. return RaiseException with the IEEE record
//       filled out appropriately [no Cause bit set])
//     - if the result is inexact and the inexact exceptions are enabled, 
//       take an inexact trap (i.e. return RaiseException with the IEEE record
//       filled out appropriately)
//     - if no exception has to be raised, set the status flags and return
//       NoExceptionRaised
//


#include <wtypes.h>
#include <trans.h>
#include <float.h>
#include "xmmi_types.h"
#include "filter.h"
#ifdef _XMMI_DEBUG
#include "temp_context.h"
#include "debug.h"
#endif

// masks for individual status word bits
#define P_MASK 0x20
#define U_MASK 0x10
#define O_MASK 0x08
#define Z_MASK 0x04
#define D_MASK 0x02
#define I_MASK 0x01


// 32-bit constants
static unsigned ZEROFA[] = {0x00000000};
#define  ZEROF *(float *) ZEROFA
static unsigned NZEROFA[] = {0x80000000};
#define  NZEROF *(float *) NZEROFA
static unsigned POSINFFA[] = {0x7f800000};
#define POSINFF *(float *)POSINFFA
static unsigned NEGINFFA[] = {0xff800000};
#define NEGINFF *(float *)NEGINFFA

#ifdef _XMMI_DEBUG
static unsigned QNANINDEFFA[] = {0xffc00000};
#define QNANINDEFF *(float *)QNANINDEFFA
#endif


// 64-bit constants
static unsigned MIN_SINGLE_NORMALA [] = {0x00000000, 0x38100000}; 
    // +1.0 * 2^-126
#define MIN_SINGLE_NORMAL *(double *)MIN_SINGLE_NORMALA
static unsigned MAX_SINGLE_NORMALA [] = {0xe0000000, 0x47efffff}; 
    // +1.1...1*2^127
#define MAX_SINGLE_NORMAL *(double *)MAX_SINGLE_NORMALA
static unsigned TWO_TO_192A[] = {0x00000000, 0x4bf00000};
#define TWO_TO_192 *(double *)TWO_TO_192A
static unsigned TWO_TO_M192A[] = {0x00000000, 0x33f00000};
#define TWO_TO_M192 *(double *)TWO_TO_M192A


// auxiliary functions
static void Fill_FPIEEE_RECORD (PXMMI_ENV XmmiEnv);
static int issnanf (float f);
static int isnanf (float f);
static float quietf (float f);
static int isdenormalf (float f);



ULONG
XMMI_FP_Emulation (PXMMI_ENV XmmiEnv)

{

  float opd1, opd2, res;
  int iopd1; // for conversions from int to float
  int ires; // for conversions from float to int
  double dbl_res24; // needed to check tininess, to provide a scaled result to
      // an underflow/overflow trap handler, and in flush-to-zero
  unsigned int result_tiny;
  unsigned int result_huge;
  unsigned int rc, sw;
  unsigned long imm8;
  unsigned int invalid_exc;
  unsigned int denormal_exc;
  unsigned int cmp_res;


  // Note that ExceptionCode is always STATUS_FLOAT_MULTIPLE_FAULTS in the
  // calling routine, so we have to check first for faults, and then for traps


#ifdef _DEBUG_FPU
  unsigned int in_top;
  unsigned int out_top;
  char fp_env[108];
  unsigned short int *control_word, *status_word, *tag_word;

  // read status word
  sw = _status87 ();
  in_top = (sw >> 11) & 0x07;
  if (in_top != 0x0) printf ("XMMI_FP_Emulate WARNING: in_top = %d\n", in_top);
  __asm {
    fnsave fp_env;
  }
  control_word = (unsigned short *)fp_env;
  status_word = (unsigned short *)(fp_env + 2);
  tag_word = (unsigned short *)(fp_env + 8);
  if (*tag_word != 0xffff) printf ("XMMI_FP_Emulate WARNING: tag_word = %x\n", *tag_word);
#endif

  _asm {
    fninit;
  }

#ifdef _DEBUG_FPU
  // read status word
  sw = _status87 ();
  in_top = (sw >> 11) & 0x07;
  if (in_top != 0x0) 
    printf ("XMMI_FP_Emulate () XMMI_FP_Emulate () ERROR: in_top = %d\n", in_top);
  __asm {
    fnsave fp_env;
  }
  tag_word = (unsigned short *)(fp_env + 8);
  if (*tag_word != 0xffff) {
    printf ("XMMI_FP_Emulate () XMMI_FP_Emulate () ERROR: tag_word = %x\n",
        *tag_word);
    printf ("control, status, tag = %x %x %x %x %x %x\n",
        fp_env[0] & 0xff, fp_env[1] & 0xff, fp_env[4] & 0xff, 
        fp_env[5] & 0xff, fp_env[8] & 0xff, fp_env[9] & 0xff);
  }
#endif


#ifdef _XMMI_DEBUG
  print_FPIEEE_RECORD (XmmiEnv);
#endif

  result_tiny = 0;
  result_huge = 0;

  XmmiEnv->Ieee->RoundingMode = XmmiEnv->Rc;
  XmmiEnv->Ieee->Precision = XmmiEnv->Precision;

  switch (XmmiEnv->Ieee->Operation) {

    case OP_ADDPS:
    case OP_ADDSS:
    case OP_SUBPS:
    case OP_SUBSS:
    case OP_MULPS:
    case OP_MULSS:
    case OP_DIVPS:
    case OP_DIVSS:

      opd1 = XmmiEnv->Ieee->Operand1.Value.Fp32Value;
      opd2 = XmmiEnv->Ieee->Operand2.Value.Fp32Value;
      if (XmmiEnv->Daz) {
        if (isdenormalf (opd1)) opd1 = opd1 * (float)0.0;
        if (isdenormalf (opd2)) opd2 = opd2 * (float)0.0;
      }

      // adjust operation code
      switch (XmmiEnv->Ieee->Operation) {

        case OP_ADDPS:
        case OP_ADDSS:

          XmmiEnv->Ieee->Operation = _FpCodeAdd;
          break;

        case OP_SUBPS:
        case OP_SUBSS:

          XmmiEnv->Ieee->Operation = _FpCodeSubtract;
          break;

        case OP_MULPS:
        case OP_MULSS:

          XmmiEnv->Ieee->Operation = _FpCodeMultiply;
          break;

        case OP_DIVPS:
        case OP_DIVSS:

          XmmiEnv->Ieee->Operation = _FpCodeDivide;
          break;

        default:
          ; // will never occur

      }

      // execute the operation and check whether the invalid, denormal, or 
      // divide by zero flags are set and the respective exceptions enabled

      switch (XmmiEnv->Rc) {
        case _FpRoundNearest:
          rc = _RC_NEAR;
          break;
        case _FpRoundMinusInfinity:
          rc = _RC_DOWN;
          break;
        case _FpRoundPlusInfinity:
          rc = _RC_UP;
          break;
        case _FpRoundChopped:
          rc = _RC_CHOP;
          break;
        default:
          ; // internal error
      }

      _control87 (rc | _PC_24 | _MCW_EM, _MCW_EM | _MCW_RC | _MCW_PC);

      // compute result and round to the destination precision, with
      // "unbounded" exponent (first IEEE rounding)
      switch (XmmiEnv->Ieee->Operation) {

        case _FpCodeAdd:
          // perform the add
          __asm {
            fnclex; 
            // load input operands
            fld  DWORD PTR opd1; // may set the denormal or invalid status flags
            fld  DWORD PTR opd2; // may set the denormal or invalid status flags
            faddp st(1), st(0); // may set the inexact or invalid status flags
            // store result
            fstp  QWORD PTR dbl_res24; // exact
          }
          break;

        case _FpCodeSubtract:
          // perform the subtract
          __asm {
            fnclex; 
            // load input operands
            fld  DWORD PTR opd1; // may set the denormal or invalid status flags
            fld  DWORD PTR opd2; // may set the denormal or invalid status flags
            fsubp st(1), st(0); // may set the inexact or invalid status flags
            // store result
            fstp  QWORD PTR dbl_res24; // exact
          }
          break;

        case _FpCodeMultiply:
          // perform the multiply
          __asm {
            fnclex; 
            // load input operands
            fld  DWORD PTR opd1; // may set the denormal or invalid status flags
            fld  DWORD PTR opd2; // may set the denormal or invalid status flags
            fmulp st(1), st(0); // may set the inexact or invalid status flags
            // store result
            fstp  QWORD PTR dbl_res24; // exact
          }
          break;

        case _FpCodeDivide:
          // perform the divide
          __asm {
            fnclex; 
            // load input operands
            fld  DWORD PTR opd1; // may set the denormal or invalid status flags
            fld  DWORD PTR opd2; // may set the denormal or invalid status flags
            fdivp st(1), st(0); // may set the inexact, divide by zero, or 
                                // invalid status flags
            // store result
            fstp  QWORD PTR dbl_res24; // exact
          }
          break;

        default:
          ; // will never occur

      }

      // read status word
      sw = _status87 ();
      if (sw & _SW_ZERODIVIDE) sw = sw & ~0x00080000; // clear D flag for den/0

      // if invalid flag is set, and invalid exceptions are enabled, take trap
      if (!(XmmiEnv->Masks & I_MASK) && (sw & _SW_INVALID)) {

        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);
        XmmiEnv->Ieee->Status.InvalidOperation = 1;
        XmmiEnv->Flags |= I_MASK;
        // Cause = Enable & Status
        XmmiEnv->Ieee->Cause.InvalidOperation = 1;

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI_FP_Emulate () ERROR 1: in_top =%d != out_top = %d\n",
              in_top, out_top);
          exit (1);
        }
#endif

        return (ExceptionRaised);

      }

      // checking for NaN operands has priority over denormal exceptions; also
      // fix for the differences in treating two NaN inputs between the XMMI 
      // instructions and other x86 instructions
      if (isnanf (opd1) || isnanf (opd2)) {
        XmmiEnv->Ieee->Result.OperandValid = 1;

        if (isnanf (opd1) && isnanf (opd2))
            XmmiEnv->Ieee->Result.Value.Fp32Value = quietf (opd1);
        else
            XmmiEnv->Ieee->Result.Value.Fp32Value = (float)dbl_res24; 
                // conversion to single precision is exact
 
        XmmiEnv->Ieee->Status.Underflow = 0;
        XmmiEnv->Ieee->Status.Overflow = 0;
        XmmiEnv->Ieee->Status.Inexact = 0;
        XmmiEnv->Ieee->Status.ZeroDivide = 0;
        if (sw & _SW_INVALID) {
          XmmiEnv->Ieee->Status.InvalidOperation = 1;
          XmmiEnv->Flags |= I_MASK;
        } else {
          XmmiEnv->Ieee->Status.InvalidOperation = 0;
        }

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI_FP_Emulate () ERROR 2: in_top =%d != out_top = %d\n", 
             in_top, out_top);
          exit (1);
        }
#endif
        return (NoExceptionRaised);
      }

      // if denormal flag is set, and denormal exceptions are enabled, take trap
      if (!(XmmiEnv->Masks & D_MASK) && (sw & _SW_DENORMAL)) {

        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);

        // Note: the exception code is STATUS_FLOAT_INVALID in this case

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI_FP_Emulate () ERROR 3: in_top =%d != out_top = %d\n", 
             in_top, out_top);
          exit (1);
        }
#endif
        XmmiEnv->Flags |= D_MASK;
        return (ExceptionRaised);

      }

      // if divide by zero flag is set, and divide by zero exceptions are 
      // enabled, take trap (for divide only)
      if (!(XmmiEnv->Masks & Z_MASK) && (sw & _SW_ZERODIVIDE)) {

        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);
        XmmiEnv->Ieee->Status.ZeroDivide = 1;
        XmmiEnv->Flags |= Z_MASK;
        // Cause = Enable & Status
        XmmiEnv->Ieee->Cause.ZeroDivide = 1;

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI_FP_Emulate () ERROR 4: in_top =%d != out_top = %d\n", 
             in_top, out_top);
          exit (1);
        }
#endif
        return (ExceptionRaised);

      }

      // done if the result is a NaN (QNaN Indefinite)
      res = (float)dbl_res24;
      if (isnanf (res)) {
#ifdef _XMMI_DEBUG
        if (res != QNANINDEFF)
            fprintf (stderr, "XMMI_FP_Emulation () INTERNAL XMMI_FP_Emulate () ERROR: "
                "res = %f = %x is not QNaN Indefinite\n", 
                 (double)res, *(unsigned int *)&res);
#endif
        XmmiEnv->Ieee->Result.OperandValid = 1;
        XmmiEnv->Ieee->Result.Value.Fp32Value = res; // exact
        XmmiEnv->Ieee->Status.Underflow = 0;
        XmmiEnv->Ieee->Status.Overflow = 0;
        XmmiEnv->Ieee->Status.Inexact = 0;
        XmmiEnv->Ieee->Status.ZeroDivide = 0;
        XmmiEnv->Ieee->Status.InvalidOperation = 1; // sw & _SW_INVALID true
        XmmiEnv->Flags |= I_MASK;
  
#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI_FP_Emulate () ERROR 5: in_top =%d != out_top = %d\n", 
             in_top, out_top);
          exit (1);
        }
#endif
        return (NoExceptionRaised);
      }

      // dbl_res24 is not a NaN at this point

      if (sw & _SW_DENORMAL) XmmiEnv->Flags |= D_MASK;

      // check if the result is tiny
      // Note: (dbl_res24 == 0.0 && sw & _SW_INEXACT) cannot occur
      if (-MIN_SINGLE_NORMAL < dbl_res24 && dbl_res24 < 0.0 ||
            0.0 < dbl_res24 && dbl_res24 < MIN_SINGLE_NORMAL) {
        result_tiny = 1;
      }

      // check if the result is huge
      if (NEGINFF < dbl_res24 && dbl_res24 < -MAX_SINGLE_NORMAL || 
          MAX_SINGLE_NORMAL < dbl_res24 && dbl_res24 < POSINFF) { 
        result_huge = 1;
      }

      // at this point, there are no enabled I, D, or Z exceptions; the instr.
      // might lead to an enabled underflow, enabled underflow and inexact, 
      // enabled overflow, enabled overflow and inexact, enabled inexact, or
      // none of these; if there are no U or O enabled exceptions, re-execute
      // the instruction using iA32 stack single precision format, and the 
      // user's rounding mode; exceptions must have been disabled; an inexact
      // exception may be reported on the 24-bit faddp, fsubp, fmulp, or fdivp,
      // while an overflow or underflow (with traps disabled !) may be reported
      // on the fstp

      // check whether there is a underflow, overflow, or inexact trap to be 
      // taken

      // if the underflow traps are enabled and the result is tiny, take 
      // underflow trap
      if (!(XmmiEnv->Masks & U_MASK) && result_tiny) {
        dbl_res24 = TWO_TO_192 * dbl_res24; // exact
        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);
        XmmiEnv->Ieee->Status.Underflow = 1;
        XmmiEnv->Flags |= U_MASK;
        XmmiEnv->Ieee->Cause.Underflow = 1;
        XmmiEnv->Ieee->Result.OperandValid = 1;
        XmmiEnv->Ieee->Result.Value.Fp32Value = (float)dbl_res24; // exact

        if (sw & _SW_INEXACT) {
          XmmiEnv->Ieee->Status.Inexact = 1;
          XmmiEnv->Flags |= P_MASK;
        }

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI_FP_Emulate () ERROR 6: in_top =%d != out_top = %d\n", 
             in_top, out_top);
          exit (1);
        }
#endif
        return (ExceptionRaised);
      } 

      // if overflow traps are enabled and the result is huge, take
      // overflow trap
      if (!(XmmiEnv->Masks & O_MASK) &&  result_huge) {
        dbl_res24 = TWO_TO_M192 * dbl_res24; // exact
        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);
        XmmiEnv->Ieee->Status.Overflow = 1;
        XmmiEnv->Flags |= O_MASK;
        XmmiEnv->Ieee->Cause.Overflow = 1;
        XmmiEnv->Ieee->Result.OperandValid = 1;
        XmmiEnv->Ieee->Result.Value.Fp32Value = (float)dbl_res24; // exact 
 
        if (sw & _SW_INEXACT) {
          XmmiEnv->Ieee->Status.Inexact = 1;
          XmmiEnv->Flags |= P_MASK;
        }


#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI_FP_Emulate () ERROR 7: in_top =%d != out_top = %d\n", 
             in_top, out_top);
          exit (1);
        }
#endif
        return (ExceptionRaised);
      } 

      // calculate result for the case an inexact trap has to be taken, or
      // when no trap occurs (second IEEE rounding)

      switch (XmmiEnv->Ieee->Operation) {

        case _FpCodeAdd:
          // perform the add
          __asm {
            // load input operands
            fld  DWORD PTR opd1; // may set the denormal status flag
            fld  DWORD PTR opd2; // may set the denormal status flag
            faddp st(1), st(0); // rounded to 24 bits, may set the inexact 
                                // status flag
            // store result
            fstp  DWORD PTR res; // exact, will not set any flag
          }
          break;

        case _FpCodeSubtract:
          // perform the subtract
          __asm {
            // load input operands
            fld  DWORD PTR opd1; // may set the denormal status flag
            fld  DWORD PTR opd2; // may set the denormal status flag
            fsubp st(1), st(0); // rounded to 24 bits, may set the inexact
                                //  status flag
            // store result
            fstp  DWORD PTR res; // exact, will not set any flag
          }
          break;

        case _FpCodeMultiply:
          // perform the multiply
          __asm {
            // load input operands
            fld  DWORD PTR opd1; // may set the denormal status flag
            fld  DWORD PTR opd2; // may set the denormal status flag
            fmulp st(1), st(0); // rounded to 24 bits, may set the inexact
                                // status flag
            // store result
            fstp  DWORD PTR res; // exact, will not set any flag
          }
          break;

        case _FpCodeDivide:
          // perform the divide
          __asm {
            // load input operands
            fld  DWORD PTR opd1; // may set the denormal status flag
            fld  DWORD PTR opd2; // may set the denormal status flag
            fdivp st(1), st(0); // rounded to 24 bits, may set the inexact
                                // or divide by zero status flags
            // store result
            fstp  DWORD PTR res; // exact, will not set any flag
          }
          break;

        default:
          ; // will never occur

      }

      // read status word
      sw = _status87 ();

      // if inexact traps are enabled and result is inexact, take inexact trap
      if (!(XmmiEnv->Masks & P_MASK) && 
          ((sw & _SW_INEXACT) || (XmmiEnv->Fz && result_tiny))) {
        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);
        XmmiEnv->Ieee->Status.Inexact = 1;
        XmmiEnv->Flags |= P_MASK;
        XmmiEnv->Ieee->Cause.Inexact = 1;
        XmmiEnv->Ieee->Result.OperandValid = 1;
        if (result_tiny) {
          XmmiEnv->Ieee->Status.Underflow = 1;
          XmmiEnv->Flags |= U_MASK;
          // Note: the condition above is equivalent to
          // if (sw & _SW_UNDERFLOW) XmmiEnv->Ieee->Status.Underflow = 1; 
        }
        if (result_huge) {
          XmmiEnv->Ieee->Status.Overflow = 1;
          XmmiEnv->Flags |= O_MASK;
          // Note: the condition above is equivalent to
          // if (sw & _SW_OVERFLOW) XmmiEnv->Ieee->Status.Overflow = 1;
        }

        // if ftz = 1 and result is tiny, result = 0.0
        // (no need to check for underflow traps disabled: result tiny and
        // underflow traps enabled would have caused taking an underflow
        // trap above)
        if (XmmiEnv->Fz && result_tiny) {
            // Note: the condition above is equivalent to
            // if (XmmiEnv->Fz && (sw & _SW_UNDERFLOW))
          if (res > 0.0)
            res = ZEROF;
          else if (res < 0.0)
            res = NZEROF;
          // else leave res unchanged
        }

        XmmiEnv->Ieee->Result.Value.Fp32Value = res; 
#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI_FP_Emulate () ERROR 8: in_top =%d != out_top = %d\n", 
             in_top, out_top);
          exit (1);
        }
#endif
        return (ExceptionRaised);
      } 

      // if it got here, then there is no trap to be taken; the following must
      // hold: ((the MXCSR U exceptions are disabled  or
      //
      // the MXCSR underflow exceptions are enabled and the underflow flag is
      // clear and (the inexact flag is set or the inexact flag is clear and
      // the 24-bit result with unbounded exponent is not tiny)))
      // and (the MXCSR overflow traps are disabled or the overflow flag is
      // clear) and (the MXCSR inexact traps are disabled or the inexact flag
      // is clear)
      //
      // in this case, the result has to be delivered (the status flags are 
      // sticky, so they are all set correctly already)

#ifdef _XMMI_DEBUG
      // error if the condition stated above does not hold
      if (!((XmmiEnv->Masks & U_MASK || (!(XmmiEnv->Masks & U_MASK) && 
          !(sw & _SW_UNDERFLOW) && ((sw & _SW_INEXACT) || 
          !(sw & _SW_INEXACT) && !result_tiny))) &&
          ((XmmiEnv->Masks & O_MASK) || !(sw & _SW_OVERFLOW)) &&
          ((XmmiEnv->Masks & P_MASK) || !(sw & _SW_INEXACT)))) {
        fprintf (stderr, "XMMI_FP_Emulation () INTERNAL XMMI_FP_Emulate () ERROR for "
            "ADDPS/ADDSS/SUBPS/SUBSS/MULPS/MULSS/DIVPS/DIVSS\n");
      }
#endif

      XmmiEnv->Ieee->Result.OperandValid = 1;

      if (sw & _SW_UNDERFLOW) {
        XmmiEnv->Ieee->Status.Underflow = 1;
        XmmiEnv->Flags |= U_MASK;
      } else {
        XmmiEnv->Ieee->Status.Underflow = 0;
      }
      if (sw & _SW_OVERFLOW) {
        XmmiEnv->Ieee->Status.Overflow = 1;
        XmmiEnv->Flags |= O_MASK;
      } else {
        XmmiEnv->Ieee->Status.Overflow = 0;
      }
      if (sw & _SW_INEXACT) {
        XmmiEnv->Ieee->Status.Inexact = 1;
        XmmiEnv->Flags |= P_MASK;
      } else {
        XmmiEnv->Ieee->Status.Inexact = 0;
      }

      // if ftz = 1, and result is tiny (underflow traps must be disabled),
      // result = 0.0
      if (XmmiEnv->Fz && result_tiny) {
        if (res > 0.0)
          res = ZEROF;
        else if (res < 0.0)
          res = NZEROF;
        // else leave res unchanged

        XmmiEnv->Ieee->Status.Inexact = 1;
        XmmiEnv->Flags |= P_MASK;
        XmmiEnv->Ieee->Status.Underflow = 1;
        XmmiEnv->Flags |= U_MASK;
      }

      XmmiEnv->Ieee->Result.Value.Fp32Value = res; 

      // note that there is no way to
      // communicate to the caller that the denormal flag was set - we count
      // on the XMMI instruction to have set the denormal flag in MXCSR if
      // needed, regardless of the other components of the input operands
      // (invalid or not; the caller will have to update the underflow, 
      // overflow, and inexact flags in MXCSR)
      if (sw & _SW_ZERODIVIDE) {
        XmmiEnv->Ieee->Status.ZeroDivide = 1;
        XmmiEnv->Flags |= Z_MASK;
      } else {
        XmmiEnv->Ieee->Status.ZeroDivide = 0;
      }
      XmmiEnv->Ieee->Status.InvalidOperation = 0;

#ifdef _DEBUG_FPU
      // read status word
      sw = _status87 ();
      out_top = (sw >> 11) & 0x07;
      if (in_top != out_top) {
        printf ("XMMI_FP_Emulate () ERROR 9: in_top =%d != out_top = %d\n", 
             in_top, out_top);
        exit (1);
      }
#endif
      return (NoExceptionRaised);

      break;

    case OP_CMPPS:
    case OP_CMPSS:

      opd1 = XmmiEnv->Ieee->Operand1.Value.Fp32Value;
      opd2 = XmmiEnv->Ieee->Operand2.Value.Fp32Value;
      if (XmmiEnv->Daz) {
        if (isdenormalf (opd1)) opd1 = opd1 * (float)0.0;
        if (isdenormalf (opd2)) opd2 = opd2 * (float)0.0;
      }
      imm8 = XmmiEnv->Imm8 & 0x07;

      // adjust operation code
      XmmiEnv->Ieee->Operation = _FpCodeCompare;

      // check whether an invalid exception has to be raised

      switch (imm8) {

        case IMM8_EQ:
        case IMM8_UNORD:
        case IMM8_NEQ:
        case IMM8_ORD:
          if (issnanf (opd1) || issnanf (opd2))
              invalid_exc = 1; // SNaN operands signal invalid
          else
              invalid_exc = 0; // QNaN or other operands do not signal invalid
          // guard against the case when an SNaN operand was converted to 
          // QNaN by compiler generated code
          sw = _status87 ();
          if (sw & _SW_INVALID) invalid_exc = 1;
          break;
        case IMM8_LT:
        case IMM8_LE:
        case IMM8_NLT:
        case IMM8_NLE:
          if (isnanf (opd1) || isnanf (opd2))
              invalid_exc = 1; // SNaN/QNaN operands signal invalid
          else
              invalid_exc = 0; // other operands do not signal invalid
          break;
        default:
          ; // will never occur

      }

      // if invalid_exc = 1, and invalid exceptions are enabled, take trap
      if (invalid_exc && !(XmmiEnv->Masks & I_MASK)) {

        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);
        XmmiEnv->Ieee->Status.InvalidOperation = 1;
        XmmiEnv->Flags |= I_MASK;
        // Cause = Enable & Status
        XmmiEnv->Ieee->Cause.InvalidOperation = 1;

        // Note: the calling function will have to interpret the value returned
        // by the user handler, if execution is to be continued

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI_FP_Emulate () ERROR 10: in_top =%d != out_top = %d\n", 
             in_top, out_top);
          exit (1);
        }
#endif
        return (ExceptionRaised);

      }

      // checking for NaN operands has priority over denormal exceptions
      if (isnanf (opd1) || isnanf (opd2)) {

        switch (imm8) {

          case IMM8_EQ:
          case IMM8_LT:
          case IMM8_LE:
          case IMM8_ORD:
            cmp_res = 0x0;
            break;
          case IMM8_UNORD:
          case IMM8_NEQ:
          case IMM8_NLT:
          case IMM8_NLE:
            cmp_res = 0xffffffff;
            break;
          default:
            ; // will never occur

        }

        XmmiEnv->Ieee->Result.OperandValid = 1;
        XmmiEnv->Ieee->Result.Value.Fp32Value = *((float *)&cmp_res); 
            // may make U32Value
  
        XmmiEnv->Ieee->Status.Inexact = 0;
        XmmiEnv->Ieee->Status.Underflow = 0;
        XmmiEnv->Ieee->Status.Overflow = 0;
        XmmiEnv->Ieee->Status.ZeroDivide = 0;
        // Note that the denormal flag will not be updated by _fpieee_flt (),
        // even if an operand is denormal
        if (invalid_exc) {
          XmmiEnv->Ieee->Status.InvalidOperation = 1;
          XmmiEnv->Flags |= I_MASK;
        } else {
          XmmiEnv->Ieee->Status.InvalidOperation = 0;
        }
  
#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI_FP_Emulate () ERROR 11: in_top =%d != out_top = %d\n", 
             in_top, out_top);
          exit (1);
        }
#endif
        return (NoExceptionRaised);

      }

      // check whether a denormal exception has to be raised

      if (isdenormalf (opd1) || isdenormalf (opd2)) {
          denormal_exc = 1;
          XmmiEnv->Flags |= D_MASK;
      } else {
          denormal_exc = 0;
      }

      // if denormal_exc = 1, and denormal exceptions are enabled, take trap
      if (denormal_exc && !(XmmiEnv->Masks & D_MASK)) {

        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);

        // Note: the exception code is STATUS_FLOAT_INVALID in this case

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI_FP_Emulate () ERROR 12: in_top =%d != out_top = %d\n", 
             in_top, out_top);
          exit (1);
        }
#endif
        return (ExceptionRaised);

      }

      // no exception has to be raised, and no operand is a NaN; calculate 
      // and deliver the result

      if (opd1 < opd2) {

        switch (imm8) {
  
          case IMM8_LT:
          case IMM8_LE:
          case IMM8_NEQ:
          case IMM8_ORD:
            cmp_res = 0xffffffff;
            break;
          case IMM8_EQ:
          case IMM8_UNORD:
          case IMM8_NLT:
          case IMM8_NLE:
            cmp_res = 0x0;
            break;

          default:
            ; // will never occur
  
        }

      } else if (opd1 > opd2) {

        switch (imm8) {
  
          case IMM8_NEQ:
          case IMM8_NLT:
          case IMM8_NLE:
          case IMM8_ORD:
            cmp_res = 0xffffffff;
            break;

          case IMM8_EQ:
          case IMM8_LT:
          case IMM8_LE:
          case IMM8_UNORD:
            cmp_res = 0x0;
            break;

          default:
            ; // will never occur
  
        }

      } else if (opd1 == opd2) {

        switch (imm8) {
  
          case IMM8_EQ:
          case IMM8_LE:
          case IMM8_NLT:
          case IMM8_ORD:
            cmp_res = 0xffffffff;
            break;

          case IMM8_LT:
          case IMM8_UNORD:
          case IMM8_NEQ:
          case IMM8_NLE:
            cmp_res = 0x0;
            break;

          default:
            ; // will never occur
  
        }

      } else { // could eliminate this case

#ifdef _DEBUG_FPU
        fprintf (stderr, "XMMI_FP_Emulation () INTERNAL XMMI_FP_Emulate () ERROR for CMPPS/CMPSS\n");
#endif

      }

      XmmiEnv->Ieee->Result.OperandValid = 1;
      XmmiEnv->Ieee->Result.Value.Fp32Value = *((float *)&cmp_res); 
          // may make U32Value

      XmmiEnv->Ieee->Status.Inexact = 0;
      XmmiEnv->Ieee->Status.Underflow = 0;
      XmmiEnv->Ieee->Status.Overflow = 0;
      XmmiEnv->Ieee->Status.ZeroDivide = 0;
      // Note that the denormal flag will not be updated by _fpieee_flt (),
      // even if an operand is denormal
      XmmiEnv->Ieee->Status.InvalidOperation = 0;

#ifdef _DEBUG_FPU
      // read status word
      sw = _status87 ();
      out_top = (sw >> 11) & 0x07;
      if (in_top != out_top) {
        printf ("XMMI_FP_Emulate () ERROR 13: in_top =%d != out_top = %d\n", 
             in_top, out_top);
        exit (1);
      }
#endif
      return (NoExceptionRaised);

      break;

    case OP_COMISS:
    case OP_UCOMISS:

      opd1 = XmmiEnv->Ieee->Operand1.Value.Fp32Value;
      opd2 = XmmiEnv->Ieee->Operand2.Value.Fp32Value;
      if (XmmiEnv->Daz) {
        if (isdenormalf (opd1)) opd1 = opd1 * (float)0.0;
        if (isdenormalf (opd2)) opd2 = opd2 * (float)0.0;
      }

      // check whether an invalid exception has to be raised

      switch (XmmiEnv->Ieee->Operation) {

        case OP_COMISS:

          if (isnanf (opd1) || isnanf (opd2)) {
              invalid_exc = 1;
          } else
              invalid_exc = 0;
          break;

        case OP_UCOMISS:

          if (issnanf (opd1) || issnanf (opd2))
              invalid_exc = 1;
          else
              invalid_exc = 0;
          // guard against the case when an SNaN operand was converted to 
          // QNaN by compiler generated code
          sw = _status87 ();
          if (sw & _SW_INVALID) invalid_exc = 1;
          break;

        default:
          ; // will never occur

      }

      // adjust operation code
      XmmiEnv->Ieee->Operation = _FpCodeCompare;

      // if invalid_exc = 1, and invalid exceptions are enabled, take trap
      if (invalid_exc && !(XmmiEnv->Masks & I_MASK)) {

        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);
        XmmiEnv->Ieee->Status.InvalidOperation = 1;
        XmmiEnv->Flags |= I_MASK;
        // Cause = Enable & Status
        XmmiEnv->Ieee->Cause.InvalidOperation = 1;

        // Note: the calling function will have to interpret the value returned
        // by the user handler, if execution is to be continued

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI_FP_Emulate () ERROR 14: in_top =%d != out_top = %d\n", 
             in_top, out_top);
          exit (1);
        }
#endif
        return (ExceptionRaised);

      }

      // EFlags:
      // 333222222222211111111110000000000
      // 210987654321098765432109876543210
      //                      O   SZ A P C

      // checking for NaN operands has priority over denormal exceptions
      if (isnanf (opd1) || isnanf (opd2)) {


        // OF, SF, AF = 000, ZF, PF, CF = 111
        XmmiEnv->EFlags = (XmmiEnv->EFlags & 0xfffff76f) | 0x00000045;

        XmmiEnv->Ieee->Status.Inexact = 0;
        XmmiEnv->Ieee->Status.Underflow = 0;
        XmmiEnv->Ieee->Status.Overflow = 0;
        XmmiEnv->Ieee->Status.ZeroDivide = 0;
        // Note that the denormal flag will not be updated by _fpieee_flt (),
        // even if an operand is denormal
        if (invalid_exc) {
          XmmiEnv->Ieee->Status.InvalidOperation = 1;
          XmmiEnv->Flags |= I_MASK;
        } else {
          XmmiEnv->Ieee->Status.InvalidOperation = 0;
        }

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI_FP_Emulate () ERROR 15: in_top =%d != out_top = %d\n", 
             in_top, out_top);
          exit (1);
        }
#endif
        return (NoExceptionRaised);

      }

      // check whether a denormal exception has to be raised

      if (isdenormalf (opd1) || isdenormalf (opd2)) {
          denormal_exc = 1;
          XmmiEnv->Flags |= D_MASK;
      } else {
          denormal_exc = 0;
      }

      // if denormal_exc = 1, and denormal exceptions are enabled, take trap
      if (denormal_exc && !(XmmiEnv->Masks & D_MASK)) {

        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);

        // Note: the exception code is STATUS_FLOAT_INVALID in this case

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI_FP_Emulate () ERROR 16: in_top =%d != out_top = %d\n", 
             in_top, out_top);
          exit (1);
        }
#endif
        return (ExceptionRaised);

      }

      // no exception has to be raised, and no operand is a NaN; calculate 
      // and deliver the result

      // 333222222222211111111110000000000
      // 210987654321098765432109876543210
      //                      O   SZ A P C

      if (opd1 > opd2) {

        // OF, SF, AF = 000, ZF, PF, CF = 000
        XmmiEnv->EFlags = XmmiEnv->EFlags & 0xfffff72a;

      } else if (opd1 < opd2) {

        // OF, SF, AF = 000, ZF, PF, CF = 001
        XmmiEnv->EFlags = (XmmiEnv->EFlags & 0xfffff72b) | 0x00000001;

      } else if (opd1 == opd2) {

        // OF, SF, AF = 000, ZF, PF, CF = 100
        XmmiEnv->EFlags = (XmmiEnv->EFlags & 0xfffff76a) | 0x00000040;

      } else { // could eliminate this case

#ifdef _DEBUG_FPU
        fprintf (stderr, "XMMI_FP_Emulation () INTERNAL XMMI_FP_Emulate () ERROR for COMISS/UCOMISS\n");
#endif

      }

      XmmiEnv->Ieee->Status.Inexact = 0;
      XmmiEnv->Ieee->Status.Underflow = 0;
      XmmiEnv->Ieee->Status.Overflow = 0;
      XmmiEnv->Ieee->Status.ZeroDivide = 0;
      // Note that the denormal flag will not be updated by _fpieee_flt (),
      // even if an operand is denormal
      XmmiEnv->Ieee->Status.InvalidOperation = 0;

#ifdef _DEBUG_FPU
      // read status word
      sw = _status87 ();
      out_top = (sw >> 11) & 0x07;
      if (in_top != out_top) {
        printf ("XMMI_FP_Emulate () ERROR 17: in_top =%d != out_top = %d\n", 
             in_top, out_top);
        exit (1);
      }
#endif
      return (NoExceptionRaised);

      break;

    case OP_CVTPI2PS:
    case OP_CVTSI2SS:

      iopd1 = XmmiEnv->Ieee->Operand1.Value.I32Value;

      switch (XmmiEnv->Rc) {
        case _FpRoundNearest:
          rc = _RC_NEAR;
          break;
        case _FpRoundMinusInfinity:
          rc = _RC_DOWN;
          break;
        case _FpRoundPlusInfinity:
          rc = _RC_UP;
          break;
        case _FpRoundChopped:
          rc = _RC_CHOP;
          break;
        default:
          ; // internal error
      }

      // execute the operation and check whether the inexact flag is set
      // and the respective exception is enabled

      _control87 (rc | _PC_24 | _MCW_EM, _MCW_EM | _MCW_RC | _MCW_PC);

      // perform the conversion
      __asm {
        fnclex; 
        fild  DWORD PTR iopd1; // exact
        fstp  DWORD PTR res; // may set P
      }
 
      // read status word
      sw = _status87 ();

      // if inexact traps are enabled and result is inexact, take inexact trap
      if (!(XmmiEnv->Masks & P_MASK) && (sw & _SW_INEXACT)) {
        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);
        XmmiEnv->Ieee->Operation = _FpCodeConvert;
        XmmiEnv->Ieee->Status.Inexact = 1;
        XmmiEnv->Flags |= P_MASK;
        XmmiEnv->Ieee->Cause.Inexact = 1;
        XmmiEnv->Ieee->Result.OperandValid = 1;
        XmmiEnv->Ieee->Result.Value.Fp32Value = res; // exact

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI_FP_Emulate () ERROR 18: in_top =%d != out_top = %d\n", 
             in_top, out_top);
          exit (1);
        }
#endif
        return (ExceptionRaised);
      } 

      // if it got here, then there is no trap to be taken; in this case, 
      // the result has to be delivered

      XmmiEnv->Ieee->Result.OperandValid = 1;
      XmmiEnv->Ieee->Result.Value.Fp32Value = res; // exact

      if (sw & _SW_INEXACT) {
        XmmiEnv->Ieee->Status.Inexact = 1;
        XmmiEnv->Flags |= P_MASK;
      } else {
        XmmiEnv->Ieee->Status.Inexact = 0;
      }
      XmmiEnv->Ieee->Status.Underflow = 0;
      XmmiEnv->Ieee->Status.Overflow = 0;
      XmmiEnv->Ieee->Status.ZeroDivide = 0;
      XmmiEnv->Ieee->Status.InvalidOperation = 0;

#ifdef _DEBUG_FPU
      // read status word
      sw = _status87 ();
      out_top = (sw >> 11) & 0x07;
      if (in_top != out_top) {
        printf ("XMMI_FP_Emulate () ERROR 19: in_top =%d != out_top = %d\n", 
             in_top, out_top);
        exit (1);
      }
#endif
      return (NoExceptionRaised);

      break;

    case OP_CVTPS2PI:
    case OP_CVTSS2SI:
    case OP_CVTTPS2PI:
    case OP_CVTTSS2SI:

      opd1 = XmmiEnv->Ieee->Operand1.Value.Fp32Value;
      if (XmmiEnv->Daz) {
        if (isdenormalf (opd1)) opd1 = opd1 * (float)0.0;
      }

      // adjust the operation code
      switch (XmmiEnv->Ieee->Operation) {

        case OP_CVTPS2PI:
        case OP_CVTSS2SI:

          XmmiEnv->Ieee->Operation = _FpCodeConvert;
          break;

        case OP_CVTTPS2PI:
        case OP_CVTTSS2SI:

          XmmiEnv->Ieee->Operation = _FpCodeConvertTrunc;
          break;

        default:
          ; // will never occur

      }

      switch (XmmiEnv->Ieee->Operation) {

        case _FpCodeConvert:

          switch (XmmiEnv->Rc) {
            case _FpRoundNearest:
              rc = _RC_NEAR;
              break;
            case _FpRoundMinusInfinity:
              rc = _RC_DOWN;
              break;
            case _FpRoundPlusInfinity:
              rc = _RC_UP;
              break;
            case _FpRoundChopped:
              rc = _RC_CHOP;
              break;
            default:
              ; // internal error
          }

          break;

        case _FpCodeConvertTrunc:

          rc = _RC_CHOP;
          break;

        default:
          ; // will never occur

      }

      // execute the operation and check whether the inexact flag is set
      // and the respective exceptions enabled

      _control87 (rc | _PC_24 | _MCW_EM, _MCW_EM | _MCW_RC | _MCW_PC);

      // perform the conversion
      __asm {
        fnclex; 
        fld  DWORD PTR opd1; // may set the denormal [ignored] or invalid
                             // status flags
        fistp  DWORD PTR ires; // may set the inexact or invalid status
                               // flags (for NaN or out-of-range)
      }

      // read status word
      sw = _status87 ();

      // if invalid flag is set, and invalid exceptions are enabled, take trap
      if (!(XmmiEnv->Masks & I_MASK) && (sw & _SW_INVALID)) {
        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);
        XmmiEnv->Ieee->Status.InvalidOperation = 1;
        XmmiEnv->Flags |= I_MASK;
        // Cause = Enable & Status
        XmmiEnv->Ieee->Cause.InvalidOperation = 1;

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI_FP_Emulate () ERROR 20: in_top =%d != out_top = %d\n", 
             in_top, out_top);
          exit (1);
        }
#endif
        return (ExceptionRaised);

      }

      // at this point, there are no enabled invalid exceptions; the
      // instruction might have lead to an enabled inexact exception, or to
      // no exception at all

      XmmiEnv->Ieee->Result.Value.I32Value = ires;

      // if inexact traps are enabled and result is inexact, take inexact trap
      // (no flush-to-zero situation is possible)
      if (!(XmmiEnv->Masks & P_MASK) && (sw & _SW_INEXACT)) {
        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);
        XmmiEnv->Ieee->Status.Inexact = 1;
        XmmiEnv->Flags |= P_MASK;
        XmmiEnv->Ieee->Cause.Inexact = 1;
        XmmiEnv->Ieee->Result.OperandValid = 1;

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI_FP_Emulate () ERROR 21: in_top =%d != out_top = %d\n", 
             in_top, out_top);
          exit (1);
        }
#endif
        return (ExceptionRaised);
      } 

      // if it got here, then there is no trap to be taken; return result

      XmmiEnv->Ieee->Result.OperandValid = 1;

      if (sw & _SW_INEXACT) {
        XmmiEnv->Ieee->Status.Inexact = 1;
        XmmiEnv->Flags |= P_MASK;
      } else {
        XmmiEnv->Ieee->Status.Inexact = 0;
      }
      XmmiEnv->Ieee->Status.Underflow = 0;
      XmmiEnv->Ieee->Status.Overflow = 0;
      XmmiEnv->Ieee->Status.ZeroDivide = 0;
      if (sw & _SW_INVALID) {
        XmmiEnv->Ieee->Status.InvalidOperation = 1;
        XmmiEnv->Flags |= I_MASK;
      } else {
        XmmiEnv->Ieee->Status.InvalidOperation = 0;
      }

#ifdef _DEBUG_FPU
      // read status word
      sw = _status87 ();
      out_top = (sw >> 11) & 0x07;
      if (in_top != out_top) {
        printf ("XMMI_FP_Emulate () ERROR 22: in_top =%d != out_top = %d\n", 
             in_top, out_top);
        exit (1);
      }
#endif
      return (NoExceptionRaised);

      break;

    case OP_MAXPS:
    case OP_MAXSS:
    case OP_MINPS:
    case OP_MINSS:

      opd1 = XmmiEnv->Ieee->Operand1.Value.Fp32Value;
      opd2 = XmmiEnv->Ieee->Operand2.Value.Fp32Value;
      if (XmmiEnv->Daz) {
        if (isdenormalf (opd1)) opd1 = opd1 * (float)0.0;
        if (isdenormalf (opd2)) opd2 = opd2 * (float)0.0;
      }

      // adjust operation code
      switch (XmmiEnv->Ieee->Operation) {

        case OP_MAXPS:
        case OP_MAXSS:
          XmmiEnv->Ieee->Operation = _FpCodeFmax;
          break;

        case OP_MINPS:
        case OP_MINSS:
          XmmiEnv->Ieee->Operation = _FpCodeFmin;
          break;

        default:
          ; // will never occur

      }

      // check whether an invalid exception has to be raised

      if (isnanf (opd1) || isnanf (opd2))
          invalid_exc = 1;
      else
          invalid_exc = 0;

      // if invalid_exc = 1, and invalid exceptions are enabled, take trap
      if (invalid_exc && !(XmmiEnv->Masks & I_MASK)) {

        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);
        XmmiEnv->Ieee->Status.InvalidOperation = 1;
        XmmiEnv->Flags |= I_MASK;
        // Cause = Enable & Status
        XmmiEnv->Ieee->Cause.InvalidOperation = 1;

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI_FP_Emulate () ERROR 23: in_top =%d != out_top = %d\n", 
             in_top, out_top);
          exit (1);
        }
#endif
        return (ExceptionRaised);

      }

      // checking for NaN operands has priority over denormal exceptions

      if (invalid_exc) {

        XmmiEnv->Ieee->Result.OperandValid = 1;

        XmmiEnv->Ieee->Result.Value.Fp32Value = opd2;
  
        XmmiEnv->Ieee->Status.Inexact = 0;
        XmmiEnv->Ieee->Status.Underflow = 0;
        XmmiEnv->Ieee->Status.Overflow = 0;
        XmmiEnv->Ieee->Status.ZeroDivide = 0;
        XmmiEnv->Ieee->Status.InvalidOperation = 1;
        XmmiEnv->Flags |= I_MASK;
  
#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI_FP_Emulate () ERROR 24: in_top =%d != out_top = %d\n", 
             in_top, out_top);
          exit (1);
        }
#endif
        return (NoExceptionRaised);

      }

      // check whether a denormal exception has to be raised

      if (isdenormalf (opd1) || isdenormalf (opd2)) {
          denormal_exc = 1;
          XmmiEnv->Flags |= D_MASK;
      } else {
          denormal_exc = 0;
      }

      // if denormal_exc = 1, and denormal exceptions are enabled, take trap
      if (denormal_exc && !(XmmiEnv->Masks & D_MASK)) {

        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);

        // Note: the exception code is STATUS_FLOAT_INVALID in this case

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI_FP_Emulate () ERROR 25: in_top =%d != out_top = %d\n", 
             in_top, out_top);
          exit (1);
        }
#endif
        return (ExceptionRaised);

      }

      // no exception has to be raised, and no operand is a NaN; calculate 
      // and deliver the result

      if (opd1 < opd2) {

        switch (XmmiEnv->Ieee->Operation) {
          case _FpCodeFmax:
            XmmiEnv->Ieee->Result.Value.Fp32Value = opd2;
            break;
          case _FpCodeFmin:
            XmmiEnv->Ieee->Result.Value.Fp32Value = opd1;
            break;
          default:
            ; // will never occur
        }

      } else if (opd1 > opd2) {

        switch (XmmiEnv->Ieee->Operation) {
          case _FpCodeFmax:
            XmmiEnv->Ieee->Result.Value.Fp32Value = opd1;
            break;
          case _FpCodeFmin:
            XmmiEnv->Ieee->Result.Value.Fp32Value = opd2;
            break;
          default:
            ; // will never occur
        }

      } else if (opd1 == opd2) {

        XmmiEnv->Ieee->Result.Value.Fp32Value = opd2;

      } else { // could eliminate this case

#ifdef _DEBUG_FPU
        fprintf (stderr, "XMMI_FP_Emulation () INTERNAL XMMI_FP_Emulate () ERROR for MAXPS/MAXSS/MINPS/MINSS\n");
#endif

      }

      XmmiEnv->Ieee->Result.OperandValid = 1;

      XmmiEnv->Ieee->Status.Inexact = 0;
      XmmiEnv->Ieee->Status.Underflow = 0;
      XmmiEnv->Ieee->Status.Overflow = 0;
      XmmiEnv->Ieee->Status.ZeroDivide = 0;
      // Note that the denormal flag will not be updated by _fpieee_flt (),
      // even if an operand is denormal
      XmmiEnv->Ieee->Status.InvalidOperation = 0;

#ifdef _DEBUG_FPU
      // read status word
      sw = _status87 ();
      out_top = (sw >> 11) & 0x07;
      if (in_top != out_top) {
        printf ("XMMI_FP_Emulate () ERROR 26: in_top =%d != out_top = %d\n", 
             in_top, out_top);
        exit (1);
      }
#endif
      return (NoExceptionRaised);

      break;

    case OP_SQRTPS:
    case OP_SQRTSS:

      opd1 = XmmiEnv->Ieee->Operand1.Value.Fp32Value;
      if (XmmiEnv->Daz) {
        if (isdenormalf (opd1)) opd1 = opd1 * (float)0.0;
      }

      // adjust operation code
      XmmiEnv->Ieee->Operation = _FpCodeSquareRoot;

      // execute the operation and check whether the invalid, denormal, or 
      // inexact flags are set and the respective exceptions enabled

      switch (XmmiEnv->Rc) {
        case _FpRoundNearest:
          rc = _RC_NEAR;
          break;
        case _FpRoundMinusInfinity:
          rc = _RC_DOWN;
          break;
        case _FpRoundPlusInfinity:
          rc = _RC_UP;
          break;
        case _FpRoundChopped:
          rc = _RC_CHOP;
          break;
        default:
          ; // internal error
      }

      _control87 (rc | _PC_24 | _MCW_EM, _MCW_EM | _MCW_RC | _MCW_PC);

      // perform the square root
      __asm {
        fnclex; 
        fld  DWORD PTR opd1; // may set the denormal or invalid status flags
        fsqrt; // may set the inexact or invalid status flags
        fstp  DWORD PTR res; // exact
      }
 
      // read status word
      sw = _status87 ();
      if (sw & _SW_INVALID) sw = sw & ~0x00080000; // clr D flag for sqrt(-den)

      // if invalid flag is set, and invalid exceptions are enabled, take trap
      if (!(XmmiEnv->Masks & I_MASK) && (sw & _SW_INVALID)) {

        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);
        XmmiEnv->Ieee->Status.InvalidOperation = 1;
        XmmiEnv->Flags |= I_MASK;
        // Cause = Enable & Status
        XmmiEnv->Ieee->Cause.InvalidOperation = 1;

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI_FP_Emulate () ERROR 27: in_top =%d != out_top = %d\n", 
             in_top, out_top);
          exit (1);
        }
#endif
        return (ExceptionRaised);

      }

      if (sw & _SW_DENORMAL) XmmiEnv->Flags |= D_MASK;

      // if denormal flag is set, and denormal exceptions are enabled, take trap
      if (!(XmmiEnv->Masks & D_MASK) && (sw & _SW_DENORMAL)) {

        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI_FP_Emulate () ERROR 28: in_top =%d != out_top = %d\n", 
             in_top, out_top);
          exit (1);
        }
#endif
        return (ExceptionRaised);

      }

      // the result cannot be tiny

      // at this point, there are no enabled I or D or exceptions; the instr.
      // might lead to an enabled inexact exception or to no exception (this
      // includes the case of a NaN or negative operand); exceptions must have 
      // been disabled before calling this function; an inexact exception is
      // reported on the fsqrt

      // if (the MXCSR inexact traps are disabled or the inexact flag is clear)
      // then deliver the result (the status flags are sticky, so they are
      // all set correctly already)
 
      // if it got here, then there is either an inexact trap to be taken, or
      // no trap at all

      XmmiEnv->Ieee->Result.Value.Fp32Value = res; // exact

      // if inexact traps are enabled and result is inexact, take inexact trap
      if (!(XmmiEnv->Masks & P_MASK) && (sw & _SW_INEXACT)) {
        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);
        XmmiEnv->Ieee->Status.Inexact = 1;
        XmmiEnv->Flags |= P_MASK;
        XmmiEnv->Ieee->Cause.Inexact = 1;
        XmmiEnv->Ieee->Result.OperandValid = 1;

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI_FP_Emulate () ERROR 29: in_top =%d != out_top = %d\n", 
             in_top, out_top);
          exit (1);
        }
#endif
        return (ExceptionRaised);
      } 

      // no trap was taken

      XmmiEnv->Ieee->Result.OperandValid = 1;
 
      XmmiEnv->Ieee->Status.Underflow = 0;
      XmmiEnv->Ieee->Status.Overflow = 0;
      if (sw & _SW_INEXACT) {
        XmmiEnv->Ieee->Status.Inexact = 1;
        XmmiEnv->Flags |= P_MASK;
      } else {
        XmmiEnv->Ieee->Status.Inexact = 0;
      }

      // note that there is no way to
      // communicate to the caller that the denormal flag was set - we count
      // on the XMMI instruction to have set the denormal flag in MXCSR if
      // needed, regardless of the other components of the input operands
      // (invalid or not); the caller will have to update the inexact flag
      // in MXCSR
      XmmiEnv->Ieee->Status.ZeroDivide = 0;
      if (sw & _SW_INVALID) {
        XmmiEnv->Ieee->Status.InvalidOperation = 1;
        XmmiEnv->Flags = I_MASK; // no other flags set if invalid is set
      } else {
        XmmiEnv->Ieee->Status.InvalidOperation = 0;
      }

#ifdef _DEBUG_FPU
      // read status word
      sw = _status87 ();
      out_top = (sw >> 11) & 0x07;
      if (in_top != out_top) {
        printf ("XMMI_FP_Emulate () ERROR 30: in_top =%d != out_top = %d\n", 
             in_top, out_top);
        exit (1);
      }
#endif
      return (NoExceptionRaised);

      break;

    case OP_UNSPEC:

#ifdef _DEBUG_FPU
      fprintf (stderr, "XMMI_FP_Emulation internal error: unknown operation code OP_UNSPEC\n");
#endif

      break;

    default:
#ifdef _DEBUG_FPU
      fprintf (stderr, "XMMI_FP_Emulation internal error: unknown operation code %d\n", XmmiEnv->Ieee->Operation);
#endif
      break;
  }

}



static int
issnanf (float f)

{

  // checks whether f is a signaling NaN

  unsigned int *fp;

  fp = (unsigned int *)&f;

  if (((fp[0] & 0x7fc00000) == 0x7f800000) && ((fp[0] & 0x003fffff) != 0))
    return (1);
  else
    return (0);

}


static int
isnanf (float f)

{

  // checks whether f is a NaN

  unsigned int *fp;

  fp = (unsigned int *)&f;

  if (((fp[0] & 0x7f800000) == 0x7f800000) && ((fp[0] & 0x007fffff) != 0))
    return (1);
  else
    return (0);

}


static float
quietf (float f)

{

  // makes a signaling NaN quiet, and leaves a quiet NaN unchanged; does
  // not check that the input value f is a NaN

  unsigned int *fp;

  fp = (unsigned int *)&f;

  *fp = *fp | 0x00400000;
  return (f);

}


static int
isdenormalf (float f)

{

  // checks whether f is a denormal

  unsigned int *fp;

  fp = (unsigned int *)&f;

  if ((fp[0] & 0x7f800000) == 0x0 && (fp[0] & 0x007fffff) != 0x0)
    return (1);
  else
    return (0);

}


static void Fill_FPIEEE_RECORD (PXMMI_ENV XmmiEnv)

{

  // fill in part of the FP IEEE record

  XmmiEnv->Ieee->RoundingMode = XmmiEnv->Rc;
  XmmiEnv->Ieee->Precision = XmmiEnv->Precision;
  XmmiEnv->Ieee->Enable.Inexact = !(XmmiEnv->Masks & P_MASK);
  XmmiEnv->Ieee->Enable.Underflow = !(XmmiEnv->Masks & U_MASK);
  XmmiEnv->Ieee->Enable.Overflow = !(XmmiEnv->Masks & O_MASK);
  XmmiEnv->Ieee->Enable.ZeroDivide = !(XmmiEnv->Masks & Z_MASK);
  XmmiEnv->Ieee->Enable.InvalidOperation = !(XmmiEnv->Masks & I_MASK);
  XmmiEnv->Ieee->Status.Inexact = 0;
  XmmiEnv->Ieee->Status.Underflow = 0;
  XmmiEnv->Ieee->Status.Overflow = 0;
  XmmiEnv->Ieee->Status.ZeroDivide = 0;
  XmmiEnv->Ieee->Status.InvalidOperation = 0;
  // Cause = Enable & Status
  XmmiEnv->Ieee->Cause.Inexact = 0;
  XmmiEnv->Ieee->Cause.Underflow = 0;
  XmmiEnv->Ieee->Cause.Overflow = 0;
  XmmiEnv->Ieee->Cause.ZeroDivide = 0;
  XmmiEnv->Ieee->Cause.InvalidOperation = 0;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\i386\xmmi_types.h ===
/******************************Intel Confidential******************************/
/*++ 

Copyright (c) 1998-2001, Microsoft Corporation. All rights reserved.

Module Name:

    xmmi_types.h

Abstract:

    This module contains the xmmi data definitions.
   
Author:

    Ping L. Sager

Revision History:

--*/

//Debug
#ifdef _DEBUG
//Uncomment this line to debug.  This switch is also used to generated test cases.
//#define _XMMI_DEBUG
#endif

#ifndef _XMMI_TYPES_H
#define _XMMI_TYPES_H

#ifndef LITTLE_ENDIAN
#define LITTLE_ENDIAN       1
#endif

#define XMMI_INSTR          0
#define XMMI2_INSTR         1
#define XMMI2_OTHER         2
#define INSTR_SET_SUPPORTED 2   
#define INSTR_IN_OPTABLE    32

#define NoExceptionRaised   0
#define ExceptionRaised     1

//
// Definitions used to parse the memory references
// 
#define EAX_INDEX           0
#define ECX_INDEX           1
#define EDX_INDEX           2
#define EBX_INDEX           3
#define ESP_INDEX           4
#define EBP_INDEX           5
#define ESI_INDEX           6
#define EDI_INDEX           7

#define GET_REG(r)      (pctxt->r)
#define GET_REG_VIA_NDX(l,n) { \
    switch((n)&7) {   \
    case EAX_INDEX: l = pctxt->Eax; break; \
    case ECX_INDEX: l = pctxt->Ecx; break; \
    case EDX_INDEX: l = pctxt->Edx; break; \
    case EBX_INDEX: l = pctxt->Ebx; break; \
    case ESP_INDEX: l = pctxt->Esp; break; \
    case EBP_INDEX: l = pctxt->Ebp; break; \
    case ESI_INDEX: l = pctxt->Esi; break; \
    case EDI_INDEX: l = pctxt->Edi; break; \
    default: l=0; }                        \
}

#define GET_USER_UBYTE(p)   (*((UCHAR *)(p)))
#define GET_USER_ULONG(p)   (*((ULONG *)(p)))

//
// XMMI Instruction register set
//
typedef enum _XMMI_REGISTER_SET {
    xmmi0 =  0, 
    xmmi1 =  1, 
    xmmi2 =  2, 
    xmmi3 =  3,
    xmmi4 =  4, 
    xmmi5 =  5, 
    xmmi6 =  6, 
    xmmi7 =  7
} XMMI_REGISTER_SET;

#define MaskCW_RC   3   /* Rounding Control */
typedef enum _XMMI_ROUNDING_CONTROL {
    rc_near = 0,        /*   near */
    rc_down = 1,        /*   down */
    rc_up   = 2,        /*   up   */
    rc_chop = 3         /*   chop */
} XMMI_ROUNDING_CONTROL;


#define HAS_IMM8            1

#pragma pack(1)

//
// Instruction Information Table structure
//

typedef struct {
    ULONG Operation:12;       // Fp Operation code
    ULONG Op1Location:5;      // Location of 1st operand
    ULONG Op2Location:5;      // Location of 2nd operand
    ULONG Op3Location:3;      // imm8
    ULONG ResultLocation:5;   // Location of result
    ULONG NumArgs:2;          // # of args to the instruction 
} XMMI_INSTR_INFO, *PXMMI_INSTR_INFO;

//
// Instruction format
//

typedef struct {
    ULONG   Opcode1a:4;
    ULONG   Opcode1b:4;
    ULONG   RM:3;
    ULONG   Reg:3;
    ULONG   Mod:2;
    ULONG   Pad:16;
} XMMIINSTR, *PXMMIINSTR;


#ifdef LITTLE_ENDIAN

//
// Single Precision Type
//
typedef struct _FP32_TYPE {
    ULONG Significand:23;
    ULONG Exponent:8;   
    ULONG Sign:1;
} FP32_TYPE, *PFP32_TYPE;

//
// Double Precision Type
//
typedef struct _FP64_TYPE {
    ULONG SignificandLo;
    ULONG SignificandHi:20;
    ULONG Exponent:11;
    ULONG Sign:1;
} FP64_TYPE, *PFP64_TYPE;

//
// Exception Flags
//
typedef struct _XMMI_EXCEPTION_FLAGS {
    ULONG   ie:1;
    ULONG   de:1;
    ULONG   ze:1;
    ULONG   oe:1;
    ULONG   ue:1;
    ULONG   pe:1;
} XMMI_EXCEPTION_FLAGS, *PXMMI_EXCEPTION_FLAGS;

//
// Exception Masks
//
typedef struct _XMMI_EXCEPTION_MASKS {
    ULONG   im:1;
    ULONG   dm:1;
    ULONG   zm:1;
    ULONG   om:1;
    ULONG   um:1;
    ULONG   pm:1;
} XMMI_EXCEPTION_MASKS, *PXMMI_EXCEPTION_MASKS;

//
// Control/Status register
//
typedef struct _MXCSR {
    ULONG   ie:1;                      /* bit  0,  invalid operand exception */  
    ULONG   de:1;                      /* bit  1,  denormalized operand exception */       
    ULONG   ze:1;                      /* bit  2,  divide-by-zero exception */   
    ULONG   oe:1;                      /* bit  3,  numeric overflow exception */
    ULONG   ue:1;                      /* bit  4,  numeric underflow exception */
    ULONG   pe:1;                      /* bit  5,  inexact precision result exception */                                        
    ULONG   daz:1;                     /* bit  6,  reserved field before WMT C-Step */
    ULONG   im:1;                      /* bit  7,  invalid operand mask */
    ULONG   dm:1;                      /* bit  8,  denormalized operand mask */
    ULONG   zm:1;                      /* bit  9,  divide-by-zero mask */
    ULONG   om:1;                      /* bit  10, numeric overflow mask */
    ULONG   um:1;                      /* bit  11, numeric underflow mask */
    ULONG   pm:1;                      /* bit  12, inexact precision result mask */
    ULONG   Rc:2;                      /* bits 13-14, rounding control */
    ULONG   Fz:1;                      /* bit  15, flush to zero */
    ULONG   reserved2:16;              /* bits 16-31, reserved field */
} MXCSR, *PMXCSR;

#endif /* LITTLE_ENDIAN */

#pragma pack()

typedef struct _MXCSRReg {
    union {
        ULONG ul;
        MXCSR mxcsr;
    } u;
} MXCSRReg, *PMXCSRReg;

#define MXCSR_FLAGS_MASK 0x0000003f
#define MXCSR_MASKS_MASK 0x00001f80

//
// Define XMMI data types
//

/* type of 32 bit items */
typedef struct _XMMI32 {
    union {        
        ULONG     ul[1];
        USHORT    uw[2];
        UCHAR     ub[4];       
        LONG      l[1];        
        SHORT     w[2];        
        CHAR      b[4];       
        float     fs[1];      
        FP32_TYPE fp32;   
    } u;
} XMMI32, *PXMMI32;  

/* type of 64 bit items */
typedef struct _MMX64 {
    union {       
        DWORDLONG dl;       
        __int64   ull;
        ULONG     ul[2];        
        USHORT    uw[4];        
        UCHAR     ub[8];        
        LONGLONG  ll;        
        LONG      l[2];        
        SHORT     w[4];       
        CHAR      b[8];        
        float     fs[2];        
        FP32_TYPE fp32[2];        
        double    fd;        
        FP64_TYPE fp64;  
        _U64      u64;
    } u;
} MMX64, *PMMX64;  

/* type of 128 bit items */  
typedef struct _XMMI128 {   
    union {        
        DWORDLONG dl[2];       
        __int64   ull[2];
        ULONG     ul[4];        
        USHORT    uw[8];        
        UCHAR     ub[16];        
        LONGLONG  ll[2];        
        LONG      l[4];        
        SHORT     w[8];        
        CHAR      b[16];        
        float     fs[4];       
        FP32_TYPE fp32[4];        
        double    fd[2];       
        FP64_TYPE fp64[2];
        _FP128    fp128;
    } u;
} XMMI128, *PXMMI128;  


//
// Define fp enviornment data structure to store fp internal states for each data item in SIMD
//
typedef struct _XMMI_ENV {
    ULONG Masks;                  //Mask values from MxCsr
    ULONG Flags;                  //Exception flags
    ULONG Fz;                     //Flush to Zero
    ULONG Daz;                    //denormals are zero
    ULONG Rc;                     //Rounding
    ULONG Precision;              //Precision
    ULONG Imm8;                   //imm8 predicate
    ULONG EFlags;                 //EFLAGS
    _FPIEEE_RECORD *Ieee;         //Value description
} XMMI_ENV, *PXMMI_ENV;
    
// 
// Define fp environment data structure to keep track of fp internal states for SIMD
//
typedef struct _OPERAND {
    ULONG   OpLocation;               //Location of the operand
    ULONG   OpReg;                    //Register Number
    _FPIEEE_VALUE Op;                 //Value description
} OPERAND, *POPERAND;

typedef struct _XMMI_FP_ENV {
    ULONG IFlags;                     //Exception Flag values from the Processor MXCsr
    ULONG OFlags;                     //Exception Flag values from the Emulator (ORed)
    ULONG Raised[4];                  //Exception is raised or not for each data item
    ULONG Flags[4];                   //Exception Flag values for each data item
    ULONG OriginalOperation;          //Original opcode
    ULONG Imm8;                       //imm8 encoding
    ULONG EFlags;                     //EFlags values from the Emulator (ORed)
    OPERAND Operand1;                 //Operand1 (128 bits)
    OPERAND Operand2;                 //Operand2 (128 bits)
    OPERAND Result;                   //Result   (128 bits)
} XMMI_FP_ENV, *PXMMI_FP_ENV;
   
//
// encodings of imm8 for CMPPS, CMPSS
//

#define IMM8_EQ    0x00
#define IMM8_LT    0x01
#define IMM8_LE    0x02
#define IMM8_UNORD 0x03
#define IMM8_NEQ   0x04
#define IMM8_NLT   0x05
#define IMM8_NLE   0x06
#define IMM8_ORD   0x07

#ifdef _XMMI_DEBUG

#define DPrint(l,m)                { \
    if (l & DebugFlag) {             \
        printf m;                    \
        if (Console) _cprintf m;     \
    }                                \
}

#define PRINTF(m)                  { \
    printf m;                        \
    if (Console) _cprintf m;         \
}

#else

    #define DPrint(l,m)
    #define PRINTF(m)


#endif // DEBUG

#endif /* _XMMI_TYPES_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\i386\xmmi2_fp_emul.c ===
/*****************************************************************************
 *                                                                           *
 *                           Intel Confidential                              *
 *                                                                           *
 *                                                                           *
 * XMMI2_FP_emulate(): WNI FP instruction emulation for the FP IEEE filter   *
 *                                                                           *
 *                                                                           *
 * History:                                                                  *
 *    Marius Cornea-Hasegan, Nov 1999; added DAZ Oct 2000                    *
 *    marius.cornea@intel.com                                                *
 *                                                                           *
 *****************************************************************************/

//#define _DEBUG_FPU

// XMMI2_FP_Emulation () receives the input operands of an XMMI2 FP instruction 
// (operating on double-precision floating-point numbers and/or signed 
// integers), that might cause a floating-point exception (enabled or not).
//
// Arguments: PXMMI_ENV XmmiEnv
//
//  The type of every field (INPUT or OUTPUT) is indicated below:
//
//  typedef struct _XMMI_ENV {
//      ULONG Masks;                  //Mask values from MxCsr   INPUT
//      ULONG Fz;                     //Flush to Zero            INPUT
//      ULONG Rc;                     //Rounding                 INPUT
//      ULONG Precision;              //Precision                INPUT
//      ULONG Imm8;                   //imm8 predicate           INPUT
//      ULONG EFlags;                 //EFlags                   INPUT/OUTPUT
//      _FPIEEE_RECORD *Ieee;         //FP IEEE Record           INPUT/OUTPUT,
//                                                               field dependent
//  } XMMI_ENV, *PXMMI_ENV;
// 
//  The _FP_IEEE record and the _FPIEEE_VALUE are defined as:
//  
//  typedef struct {
//      unsigned int RoundingMode : 2;                   OUTPUT
//      unsigned int Precision : 3;                      OUTPUT
//      unsigned int Operation :12;                      INPUT
//      _FPIEEE_EXCEPTION_FLAGS Cause;                   OUTPUT
//      _FPIEEE_EXCEPTION_FLAGS Enable;                  OUTPUT
//      _FPIEEE_EXCEPTION_FLAGS Status;                  OUTPUT
//      _FPIEEE_VALUE Operand1;                          INPUT
//      _FPIEEE_VALUE Operand2;                          INPUT
//      _FPIEEE_VALUE Result;                            INPUT/OUTPUT,
//                                                       field dependent
//  } _FPIEEE_RECORD, *PFPIEEE_RECORD;
//  
//  typedef struct {
//      union {
//          _FP32    Fp64Value;
//          _FP64    Fp64Value;
//          _FP80    Fp80Value;
//          _FP128   Fp128Value;
//          _I16     I16Value;
//          _I32     I32Value;
//          _I64     I64Value;
//          _U16     U16Value;
//          _U32     U32Value;
//          _U64     U64Value;
//          _BCD80   Bcd80Value;
//          char     *StringValue;
//          int      CompareValue;
//      } Value;                                         INPUT for operands,
//                                                       OUTPUT for result
//
//      unsigned int OperandValid : 1;                   INPUT for operands
//                                                       INPUT/OUTPUT for result
//      unsigned int Format : 4;                         INPUT
//  
//  } _FPIEEE_VALUE;
//
// Return Value: 
//   ExceptionRaised if an enabled floating-point exception condition is 
//       detected; in this case, the fields of XmmiEnv->Ieee are filled in
//       appropriately to be passed directly to a user exception handler; the
//       XmmiEnv->Ieee->Cause bits indicate the cause of the exception, but if
//       a denormal exception occurred, then no XmmiEnv->Ieee->Cause bit is set;
//       upon return from the user handler,the caller of XMMI2_FP_emulate should
//       interpret the result for a compare instruction (CMPPD, CMPPD, COMISD,
//       UCOMISD); the Enable, Rounding, and Precision fields in _FPIEEE_RECORD
//       have to be checked too for possible changes by the user handler
//      
//   NoExceptionRaised if no floating-point exception condition occurred, or
//       if a disabled floating-point exception occurred; in this case,
//       XmmiEnv->Ieee->Result.Value contains the instruction's result, 
//       XmmiEnv->Ieee->Status contains the IEEE floating-point status flags
//
// Implementation Notes:
//
//   - the operation code in XmmiEnv->Ieee->Operation is changed as expected
//     by a user exception handler (even if no exception is raised):
//     from OP_ADDPD, OP_ADDSD to _FpCodeAdd
//     from OP_SUBPD, OP_SUBSD to _FpCodeSubtract
//     from OP_MULPD, OP_MULSD to _FpCodeMultiply
//     from OP_DIVPD, OP_DIVSD to _FpCodeDivide
//     from OP_CMPPD, OP_CMPSD to _FpCodeCompare
//     from OP_COMISD, OP_UCOMISD to _FpCodeCompare
//     from OP_CVTDQ2PS, OP_CVTPS2DQ, OP_CVTPD2PI, OP_CVTSD2SI, OP_CVTPD2DQ,
//         OP_CVTPS2PD, OP_CVTSS2SD, OP_CVTPD2PS, OP_CVTSD2SS to _FpCodeConvert
//     from OP_CVTTPS2DQ, OP_CVTTPD2PI, OP_CVTTSD2SI, OP_CVTTPD2DQ
//         to _FpCodeConvertTrunc
//     from OP_MAXPD, OP_MAXSD to _FpCodeMax
//     from OP_MINPD, OP_MINSD to _FpCodeMin
//     from OP_SQRTPD, OP_SQRTSD to _FpCodeSquareRoot
//
//

#include <wtypes.h>
#include <trans.h>
#include <float.h>
#include "xmmi_types.h"
#include "filter.h"
#ifdef _XMMI_DEBUG
#include "temp_context.h"
#include "debug.h"
#endif

// masks for individual status word bits
#define P_MASK 0x20
#define U_MASK 0x10
#define O_MASK 0x08
#define Z_MASK 0x04
#define D_MASK 0x02
#define I_MASK 0x01

// 32-bit constants
static unsigned ZEROFA[] = {0x00000000};
#define  ZEROF *(float *) ZEROFA
static unsigned NZEROFA[] = {0x80000000};
#define  NZEROF *(float *) NZEROFA

// 64-bit constants
static unsigned ZERODA[] = {0x00000000, 0x00000000};
#define  ZEROD *(double *) ZERODA
static unsigned NZERODA[] = {0x00000000, 0x80000000};
#define  NZEROD *(double *) NZERODA
static unsigned POSINFDA[] = {0x00000000, 0x7ff00000};
#define POSINFD *(float *)POSINFDA
static unsigned NEGINFDA[] = {0x00000000, 0xfff00000};
#define NEGINFD *(float *)NEGINFDA
#ifdef _DEBUG_FPU
static unsigned QNANINDEFDA[] = {0x00000000, 0xffc00000};
#define QNANINDEFD *(float *)QNANINDEFDA
#endif
static unsigned MIN_SINGLE_NORMALA [] = {0x00000000, 0x38100000};
    // +1.0 * 2^-126
#define MIN_SINGLE_NORMAL *(double *)MIN_SINGLE_NORMALA
static unsigned MAX_SINGLE_NORMALA [] = {0x70000000, 0x47efffff};
    // +1.1...1*2^127
#define MAX_SINGLE_NORMAL *(double *)MAX_SINGLE_NORMALA
static unsigned TWO_TO_192A[] = {0x00000000, 0x4bf00000};
#define TWO_TO_192 *(double *)TWO_TO_192A
static unsigned TWO_TO_M192A[] = {0x00000000, 0x33f00000};
#define TWO_TO_M192 *(double *)TWO_TO_M192A

// 80-bit constants
static unsigned POSINFDEA[] = {0x00000000, 0x80000000, 0x00007fff};
#define POSINFDE *(float *)POSINFDEA
static unsigned NEGINFDEA[] = {0x00000000, 0x80000000, 0x0000ffff};
#define NEGINFDE *(float *)NEGINFDEA
static unsigned MIN_DOUBLE_NORMALA [] = {0x00000000, 0x80000000, 0x00003c01}; 
    // +1.0 * 2^-1022
#define MIN_DOUBLE_NORMAL *(double *)MIN_DOUBLE_NORMALA
static unsigned MAX_DOUBLE_NORMALA [] = {0xfffff800, 0xffffffff, 0x000043fe}; 
    // +1.1...1*2^1023
#define MAX_DOUBLE_NORMAL *(double *)MAX_DOUBLE_NORMALA
static unsigned TWO_TO_1536A[] = {0x00000000, 0x80000000, 0x000045ff};
#define TWO_TO_1536 *(double *)TWO_TO_1536A
static unsigned TWO_TO_M1536A[] = {0x00000000, 0x80000000, 0x000039ff};
#define TWO_TO_M1536 *(double *)TWO_TO_M1536A


// auxiliary functions
static void Fill_FPIEEE_RECORD (PXMMI_ENV XmmiEnv);
static int iszerod (double);
static int isinfd (double);
static int issnand (double);
static int isnand (double);
static double quietd (double);
static int isdenormald (double);
static int isdenormalf (float f);



ULONG
XMMI2_FP_Emulation (PXMMI_ENV XmmiEnv)

{

  float opd24, res24;
  double opd1, opd2, res, dbl_res24;
  int iopd1; // for conversions from int to float
  int ires; // for conversions from float to int
  char dbl_ext_res64[10];
      // needed to check tininess, to provide a scaled result to
      // an underflow/overflow trap handler, and in flush-to-zero
  double dbl_res64;
  unsigned int result_tiny;
  unsigned int result_huge;
  unsigned int rc, sw;
  unsigned short sw1, sw2, sw3, sw4;
  unsigned long imm8;
  unsigned int invalid_exc;
  unsigned int denormal_exc;
  unsigned __int64 cmp_res;

  unsigned char min_double_normal[10];
  unsigned char max_double_normal[10];
  unsigned char posinfde[10];
  unsigned char neginfde[10];
  unsigned char two_to_1536[10];
  unsigned char two_to_m1536[10];

  // Note that ExceptionCode is always STATUS_FLOAT_MULTIPLE_FAULTS in the
  // calling routine, so we have to check first for faults, and then for traps

#ifdef _DEBUG_FPU
  unsigned int in_top;
  unsigned int out_top;
  char fp_env[108];
  unsigned short int *control_word, *status_word, *tag_word;

  // read status word
  sw = _status87 ();
  in_top = (sw >> 11) & 0x07;
  if (in_top != 0x0)
      printf ("XMMI2_FP_Emulation WARNING: in_top = %d\n", in_top);
  __asm {
    fnsave fp_env;
  }
  control_word = (unsigned short *)fp_env;
  status_word = (unsigned short *)(fp_env + 2);
  tag_word = (unsigned short *)(fp_env + 8);
  if (*tag_word != 0xffff)
      printf ("XMMI2_FP_Emulation WARNING: tag_word = %x\n",
      *tag_word);
#endif

  _asm {
    fninit;
  }

#ifdef _DEBUG_FPU
  // read status word
  sw = _status87 ();
  in_top = (sw >> 11) & 0x07;
  if (in_top != 0x0) 
    printf ("XMMI2_FP_Emulation () XMMI2_FP_Emulation () ERROR: in_top = %d\n", in_top);
  __asm {
    fnsave fp_env;
  }
  tag_word = (unsigned short *)(fp_env + 8);
  if (*tag_word != 0xffff) {
   printf ("XMMI2_FP_Emulation () XMMI2_FP_Emulation () ERROR: tag_word = %x\n",
        *tag_word);
    printf ("control, status, tag = %x %x %x %x %x %x\n", 
        fp_env[0] & 0xff, fp_env[1] & 0xff, fp_env[4] & 0xff, 
        fp_env[5] & 0xff, fp_env[8] & 0xff, fp_env[9] & 0xff);
  }
#endif


#ifdef _XMMI_DEBUG
  print_FPIEEE_RECORD (XmmiEnv);
#endif

  result_tiny = 0;
  result_huge = 0;

  XmmiEnv->Ieee->RoundingMode = XmmiEnv->Rc;
  XmmiEnv->Ieee->Precision = XmmiEnv->Precision;

  switch (XmmiEnv->Ieee->Operation) {

    case OP_ADDPD:
    case OP_ADDSD:
    case OP_SUBPD:
    case OP_SUBSD:
    case OP_MULPD:
    case OP_MULSD:
    case OP_DIVPD:
    case OP_DIVSD:

      opd1 = XmmiEnv->Ieee->Operand1.Value.Fp64Value;
      opd2 = XmmiEnv->Ieee->Operand2.Value.Fp64Value;
      if (XmmiEnv->Daz) {
        if (isdenormald (opd1)) opd1 = opd1 * 0.0;
        if (isdenormald (opd2)) opd2 = opd2 * 0.0;
      }

      // adjust operation code
      switch (XmmiEnv->Ieee->Operation) {

        case OP_ADDPD:
        case OP_ADDSD:

          XmmiEnv->Ieee->Operation = _FpCodeAdd;
          break;

        case OP_SUBPD:
        case OP_SUBSD:

          XmmiEnv->Ieee->Operation = _FpCodeSubtract;
          break;

        case OP_MULPD:
        case OP_MULSD:

          XmmiEnv->Ieee->Operation = _FpCodeMultiply;
          break;

        case OP_DIVPD:
        case OP_DIVSD:

          XmmiEnv->Ieee->Operation = _FpCodeDivide;
          break;

        default:
          ; // will never occur

      }

      // execute the operation and check whether the invalid, denormal, or 
      // divide by zero flags are set and the respective exceptions enabled

      switch (XmmiEnv->Rc) {
        case _FpRoundNearest:
          rc = _RC_NEAR;
          break;
        case _FpRoundMinusInfinity:
          rc = _RC_DOWN;
          break;
        case _FpRoundPlusInfinity:
          rc = _RC_UP;
          break;
        case _FpRoundChopped:
          rc = _RC_CHOP;
          break;
        default:
          ; // internal error
      }

      _control87 (rc | _PC_53 | _MCW_EM, _MCW_EM | _MCW_RC | _MCW_PC);

      // compute result and round to the destination precision, with
      // "unbounded" exponent (first IEEE rounding)
      switch (XmmiEnv->Ieee->Operation) {

        case _FpCodeAdd:
          // perform the add
          __asm {
            fnclex;
            // load input operands
            fld  QWORD PTR opd1; // may set the denormal or invalid status flags
            fld  QWORD PTR opd2; // may set the denormal or invalid status flags
            faddp st(1), st(0); // may set the inexact or invalid status flags
            // store result
            fstp  QWORD PTR dbl_res64;
          }
          __asm {
            fnclex; 
            // load input operands
            fld  QWORD PTR opd1; // may set the denormal or invalid status flags
            fld  QWORD PTR opd2; // may set the denormal or invalid status flags
            faddp st(1), st(0); // may set the inexact or invalid status flags
            // store result
            fstp  TBYTE PTR dbl_ext_res64; // exact
          }

          break;

        case _FpCodeSubtract:
          // perform the subtract
          __asm {
            fnclex;
            // load input operands
            fld  QWORD PTR opd1; // may set the denormal or invalid status flags
            fld  QWORD PTR opd2; // may set the denormal or invalid status flags
            fsubp st(1), st(0); // may set the inexact or invalid status flags
            // store result
            fstp  QWORD PTR dbl_res64;
          }
          __asm {
            fnclex; 
            // load input operands
            fld  QWORD PTR opd1; // may set the denormal or invalid status flags
            fld  QWORD PTR opd2; // may set the denormal or invalid status flags
            fsubp st(1), st(0); // may set the inexact or invalid status flags
            // store result
            fstp  TBYTE PTR dbl_ext_res64; // exact
          }
          break;

        case _FpCodeMultiply:
          // perform the multiply
          __asm {
            fnclex;
            // load input operands
            fld  QWORD PTR opd1; // may set the denormal or invalid status flags
            fld  QWORD PTR opd2; // may set the denormal or invalid status flags
            fmulp st(1), st(0); // may set the inexact or invalid status flags
            // store result
            fstp  QWORD PTR dbl_res64; // exact
          }
          __asm {
            fnclex; 
            // load input operands
            fld  QWORD PTR opd1; // may set the denormal or invalid status flags
            fld  QWORD PTR opd2; // may set the denormal or invalid status flags
            fmulp st(1), st(0); // may set the inexact or invalid status flags
            // store result
            fstp  TBYTE PTR dbl_ext_res64; // exact
          }
          break;

        case _FpCodeDivide:
          // perform the divide
          __asm {
            fnclex;
            // load input operands
            fld  QWORD PTR opd1; // may set the denormal or invalid status flags
            fld  QWORD PTR opd2; // may set the denormal or invalid status flags
            fdivp st(1), st(0); // may set the inexact, divide by zero, or
                                // invalid status flags
            // store result
            fstp  QWORD PTR dbl_res64; // exact
          }

          __asm {
            fnclex; 
            // load input operands
            fld  QWORD PTR opd1; // may set the denormal or invalid status flags
            fld  QWORD PTR opd2; // may set the denormal or invalid status flags
            fdivp st(1), st(0); // may set the inexact, divide by zero, or 
                                // invalid status flags
            // store result
            fstp  TBYTE PTR dbl_ext_res64; // exact
          }

          break;

        default:
          ; // will never occur

      }

      // read status word
      sw = _status87 ();
      if (sw & _SW_ZERODIVIDE) sw = sw & ~0x00080000; // clear D flag for den/0

      // if invalid flag is set, and invalid exceptions are enabled, take trap
      if (!(XmmiEnv->Masks & I_MASK) && (sw & _SW_INVALID)) {

        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);
        XmmiEnv->Ieee->Status.InvalidOperation = 1;
        XmmiEnv->Flags |= I_MASK;
        // Cause = Enable & Status
        XmmiEnv->Ieee->Cause.InvalidOperation = 1;

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI2_FP_Emulation () ERROR 1: in_top =%d != out_top = %d\n",
              in_top, out_top);
          exit (1);
        }
#endif

        return (ExceptionRaised);

      }

      // checking for NaN operands has priority over denormal exceptions; also
      // fix for the differences in treating two NaN inputs between the XMMI 
      // instructions and other x86 instructions
      if (isnand (opd1) || isnand (opd2)) {
        XmmiEnv->Ieee->Result.OperandValid = 1;

        if (isnand (opd1) && isnand (opd2))
            XmmiEnv->Ieee->Result.Value.Fp64Value = quietd (opd1);
        else
            XmmiEnv->Ieee->Result.Value.Fp64Value = dbl_res64;
 
        XmmiEnv->Ieee->Status.Underflow = 0;
        XmmiEnv->Ieee->Status.Overflow = 0;
        XmmiEnv->Ieee->Status.Inexact = 0;
        XmmiEnv->Ieee->Status.ZeroDivide = 0;
        if (sw & _SW_INVALID) {
          XmmiEnv->Ieee->Status.InvalidOperation = 1;
          XmmiEnv->Flags |= I_MASK;
        } else {
          XmmiEnv->Ieee->Status.InvalidOperation = 0;
        }

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI2_FP_Emulation () ERROR 2: in_top =%d != out_top = %d\n", 
             in_top, out_top);
          exit (1);
        }
#endif
        return (NoExceptionRaised);
      }

      // if denormal flag is set, and denormal exceptions are enabled, take trap
      if (!(XmmiEnv->Masks & D_MASK) && (sw & _SW_DENORMAL)) {

        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);

        // Note: the exception code is STATUS_FLOAT_INVALID in this case

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI2_FP_Emulation () ERROR 3: in_top =%d != out_top = %d\n", 
             in_top, out_top);
          exit (1);
        }
#endif
        XmmiEnv->Flags |= D_MASK;
        return (ExceptionRaised);

      }

      // if divide by zero flag is set, and divide by zero exceptions are 
      // enabled, take trap (for divide only)
      if (!(XmmiEnv->Masks & Z_MASK) && (sw & _SW_ZERODIVIDE)) {

        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);
        XmmiEnv->Ieee->Status.ZeroDivide = 1;
        XmmiEnv->Flags |= Z_MASK;
        // Cause = Enable & Status
        XmmiEnv->Ieee->Cause.ZeroDivide = 1;

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI2_FP_Emulation () ERROR 4: in_top =%d != out_top = %d\n",
             in_top, out_top);
          exit (1);
        }
#endif
        return (ExceptionRaised);

      }

      // done if the result is a NaN (QNaN Indefinite)
      res = dbl_res64;
      if (isnand (res)) {
#ifdef _DEBUG_FPU
      if (res != QNANINDEFD)
          fprintf (stderr, "XMMI2_FP_Emulation () INTERNAL XMMI2_FP_Emulation"
             " () ERROR: res = %f = %x is not QNaN Indefinite\n", 
              (double)res, *(unsigned int *)&res);
#endif
        XmmiEnv->Ieee->Result.OperandValid = 1;
        XmmiEnv->Ieee->Result.Value.Fp64Value = res; // exact
        XmmiEnv->Ieee->Status.Underflow = 0;
        XmmiEnv->Ieee->Status.Overflow = 0;
        XmmiEnv->Ieee->Status.Inexact = 0;
        XmmiEnv->Ieee->Status.ZeroDivide = 0;
        XmmiEnv->Ieee->Status.InvalidOperation = 1; // sw & _SW_INVALID true
        XmmiEnv->Flags |= I_MASK;
  
#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI2_FP_Emulation () ERROR 5: in_top =%d != out_top = %d\n", 
             in_top, out_top);
          exit (1);
        }
#endif
        return (NoExceptionRaised);
      }

      // dbl_ext_res64 is not a NaN at this point

      if (sw & _SW_DENORMAL) XmmiEnv->Flags |= D_MASK;

      // Note: (dbl_ext_res64 == 0.0 && sw & _SW_INEXACT) cannot occur

      // check if the result is tiny
      // if (-MIN_DOUBLE_NORMAL < dbl_ext_res64 && dbl_ext_res64 < 0.0 ||
      //     0.0 < dbl_ext_res64 && dbl_ext_res64 < MIN_DOUBLE_NORMAL)
      //   result_tiny = 1;

      memcpy (min_double_normal,  (char *)MIN_DOUBLE_NORMALA, 10);
      memcpy (max_double_normal,  (char *)MAX_DOUBLE_NORMALA, 10);
      memcpy (posinfde,  (char *)POSINFDEA, 10);
      memcpy (neginfde,  (char *)NEGINFDEA, 10);
      memcpy (two_to_1536, (char *)TWO_TO_1536A, 10);
      memcpy (two_to_m1536, (char *)TWO_TO_M1536A, 10);

      __asm {

        // -MIN_DOUBLE_NORMAL < dbl_ext_res64 
        fld  TBYTE PTR dbl_ext_res64;
        fld  TBYTE PTR min_double_normal;
        fchs; // -1.0*2^e_min in st(0)
        fcompp; // C3,C2,C0 = 001 if <
        fstsw WORD PTR sw1;

        // dbl_ext_res64 < 0.0
        fldz;
        fld  TBYTE PTR dbl_ext_res64; // dbl_ext_res64 in st(0)
        fcompp; // C3,C2,C0 = 001 if <
        fstsw WORD PTR sw2;

        // 0.0 < dbl_ext_res64 
        fld  TBYTE PTR dbl_ext_res64;
        fldz; // 0.0 in st(0)
        fcompp; // C3,C2,C0 = 001 if <
        fstsw WORD PTR sw3;

        // dbl_ext_res64 < MIN_DOUBLE_NORMAL
        fld  TBYTE PTR min_double_normal; 
        fld  TBYTE PTR dbl_ext_res64; // dbl_ext_res64 in st(0)
        fcompp; // C3,C2,C0 = 001 if <
        fstsw WORD PTR sw4;

      }

      if (((sw1 & 0x4500) == 0x0100) && ((sw2 & 0x4500) == 0x0100) ||
          ((sw3 & 0x4500) == 0x0100) && ((sw4 & 0x4500) == 0x0100)) {
        result_tiny = 1;
      }

      // check if the result is huge
      // if (NEGINFD<dbl_ext_res64 && dbl_ext_res64<-MAX_DOUBLE_NORMAL ||
      //     MAX_DOUBLE_NORMAL<dbl_ext_res64 && dbl_ext_res64<POSINFD)
      //   result_huge = 1;

      __asm {

        // NEGINFD < dbl_ext_res64
        fld  TBYTE PTR dbl_ext_res64;
        fld  TBYTE PTR neginfde; // -inf in st(0)
        fcompp; // C3,C2,C0 = 001 if <
        fstsw WORD PTR sw1;

        // dbl_ext_res64 < -MAX_DOUBLE_NORMAL
        fld  TBYTE PTR max_double_normal;
        fchs;
        fld  TBYTE PTR dbl_ext_res64; // dbl_ext_res64 in st(0)
        fcompp; // C3,C2,C0 = 001 if <
        fstsw WORD PTR sw2;

        // MAX_DOUBLE_NORMAL < dbl_ext_res64
        fld  TBYTE PTR dbl_ext_res64;
        fld  TBYTE PTR max_double_normal; // +1.1...1*2^e_max in st(0)
        fcompp; // C3,C2,C0 = 001 if <
        fstsw WORD PTR sw3;

        // dbl_ext_res64 < POSINFD
        fld  TBYTE PTR posinfde; 
        fld  TBYTE PTR dbl_ext_res64; // dbl_res_ext24 in st(0)
        fcompp; // C3,C2,C0 = 001 if <
        fstsw WORD PTR sw4;

      }

      if (((sw1 & 0x4500) == 0x0100) && ((sw2 & 0x4500) == 0x0100) ||
          ((sw3 & 0x4500) == 0x0100) && ((sw4 & 0x4500) == 0x0100)) {
        result_huge = 1;
      }


      // at this point, there are no enabled I, D, or Z exceptions; the instr.
      // might lead to an enabled underflow, enabled underflow and inexact, 
      // enabled overflow, enabled overflow and inexact, enabled inexact, or
      // none of these; if there are no U or O enabled exceptions, re-execute
      // the instruction using iA32 stack double precision format, and the 
      // user's rounding mode; exceptions must have been disabled before calling
      // this function; an inexact exception may be reported on the 64-bit
      // faddp, fsubp, fdivp, or on both the 64-bit and 53-bit conversions,
      // while an overflow or underflow (with traps disabled !) may be reported
      // on the conversion from dbl_res to res

      // check whether there is an underflow, overflow, or inexact trap to be 
      // taken

      // if the underflow traps are enabled and the result is tiny, take 
      // underflow trap
      if (!(XmmiEnv->Masks & U_MASK) && result_tiny) {

        // dbl_ext_res64 = TWO_TO_1536 * dbl_ext_res64; // exact
        __asm {
          fld  TBYTE PTR dbl_ext_res64;
          fld  TBYTE PTR two_to_1536;
          fmulp st(1), st(0);
          // store result
          fstp  QWORD PTR dbl_res64;
        }

        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);
        XmmiEnv->Ieee->Status.Underflow = 1;
        XmmiEnv->Flags |= U_MASK;
        XmmiEnv->Ieee->Cause.Underflow = 1;
        XmmiEnv->Ieee->Result.OperandValid = 1;

        XmmiEnv->Ieee->Result.Value.Fp64Value = dbl_res64; // exact

        if (sw & _SW_INEXACT) {
          XmmiEnv->Ieee->Status.Inexact = 1;
          XmmiEnv->Flags |= P_MASK;
        }

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI2_FP_Emulation () ERROR 6: in_top =%d != out_top = %d\n", 
             in_top, out_top);
          exit (1);
        }
#endif
        return (ExceptionRaised);
      } 

      // if overflow traps are enabled and the result is huge, take
      // overflow trap
      if (!(XmmiEnv->Masks & O_MASK) &&  result_huge) {

        // dbl_ext_res64 = TWO_TO_M1536 * dbl_ext_res64; // exact
        __asm {
          fld  TBYTE PTR dbl_ext_res64;
          fld  TBYTE PTR two_to_m1536;
          fmulp st(1), st(0);
          // store result
          fstp  QWORD PTR dbl_res64;
        }

        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);
        XmmiEnv->Ieee->Status.Overflow = 1;
        XmmiEnv->Flags |= O_MASK;
        XmmiEnv->Ieee->Cause.Overflow = 1;
        XmmiEnv->Ieee->Result.OperandValid = 1;
        XmmiEnv->Ieee->Result.Value.Fp64Value = dbl_res64; // exact 
 
        if (sw & _SW_INEXACT) {
          XmmiEnv->Ieee->Status.Inexact = 1;
          XmmiEnv->Flags |= P_MASK;
        }


#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI2_FP_Emulation () ERROR 7: in_top =%d != out_top = %d\n", 
             in_top, out_top);
          exit (1);
        }
#endif
        return (ExceptionRaised);
      } 

      // set user rounding mode, 64-bit precision (to avoid a double rounding
      // error in case the result requires denormalization), and disable all
      // exceptions 
      _control87 (rc | _PC_53 | _MCW_EM, _MCW_EM | _MCW_RC | _MCW_PC);

      // calculate result for the case an inexact trap has to be taken, or
      // when no trap occurs (second IEEE rounding)
      // may set P, U or O; may also involve denormalizing the result

      switch (XmmiEnv->Ieee->Operation) {

        case _FpCodeAdd:
          // perform the add
          __asm {
            // load input operands
            fld  QWORD PTR opd1; // may set the denormal status flag
            fld  QWORD PTR opd2; // may set the denormal status flag
            faddp st(1), st(0); // rounded to 64 bits, may set the inexact 
                                // or divide by zero status flags
            // store result
            fstp  QWORD PTR res;
          }
          break;

        case _FpCodeSubtract:
          // perform the subtract
          __asm {
            // load input operands
            fld  QWORD PTR opd1; // may set the denormal status flag
            fld  QWORD PTR opd2; // may set the denormal status flag
            fsubp st(1), st(0); // rounded to 64 bits, may set the inexact
                                //  status flag
            // store result
            fstp  QWORD PTR res;
          }
          break;

        case _FpCodeMultiply:
          // perform the multiply
          __asm {
            // load input operands
            fld  QWORD PTR opd1; // may set the denormal status flag
            fld  QWORD PTR opd2; // may set the denormal status flag
            fmulp st(1), st(0); // rounded to 64 bits, exact
            // store result
            fstp  QWORD PTR res;
          }

          break;

        case _FpCodeDivide:
          // perform the divide
          __asm {
            // load input operands
            fld  QWORD PTR opd1; // may set the denormal status flag
            fld  QWORD PTR opd2; // may set the denormal status flag
            fdivp st(1), st(0); // rounded to 64 bits, may set the inexact
                                // or divide by zero status flags
            // store result
            fstp  QWORD PTR res;
          }
          break;

        default:
          ; // will never occur

      }

      // read status word
      sw = _status87 ();

      if ((sw & _SW_INEXACT) && result_tiny) sw = sw | _SW_UNDERFLOW;

      // if inexact traps are enabled and result is inexact, take inexact trap
      if (!(XmmiEnv->Masks & P_MASK) && 
          ((sw & _SW_INEXACT) || (XmmiEnv->Fz && result_tiny))) {
        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);
        XmmiEnv->Ieee->Status.Inexact = 1;
        XmmiEnv->Flags |= P_MASK;
        XmmiEnv->Ieee->Cause.Inexact = 1;
        XmmiEnv->Ieee->Result.OperandValid = 1;
        if (result_tiny) {
          XmmiEnv->Ieee->Status.Underflow = 1;
          XmmiEnv->Flags |= U_MASK;
          // Note: the condition above is equivalent to
          // if (sw & _SW_UNDERFLOW) XmmiEnv->Ieee->Status.Underflow = 1; 
        }
        if (result_huge) {
          XmmiEnv->Ieee->Status.Overflow = 1;
          XmmiEnv->Flags |= O_MASK;
          // Note: the condition above is equivalent to
          // if (sw & _SW_OVERFLOW) XmmiEnv->Ieee->Status.Overflow = 1;
        }

        // if ftz = 1 and result is tiny, result = 0.0
        // (no need to check for underflow traps disabled: result tiny and
        // underflow traps enabled would have caused taking an underflow
        // trap above)
        if (XmmiEnv->Fz && result_tiny) {
            // Note: the condition above is equivalent to
            // if (XmmiEnv->Fz && (sw & _SW_UNDERFLOW))
          if (res > 0.0)
            res = ZEROD;
          else if (res < 0.0)
            res = NZEROD;
          // else leave res unchanged
        }

        XmmiEnv->Ieee->Result.Value.Fp64Value = res; 
#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI2_FP_Emulation () ERROR 8: in_top =%d != out_top = %d\n", 
             in_top, out_top);
          exit (1);
        }
#endif
        return (ExceptionRaised);
      } 

      // if it got here, then there is no trap to be taken; the following must
      // hold: ((the MXCSR U exceptions are disabled  or
      //
      // the MXCSR underflow exceptions are enabled and the underflow flag is
      // clear and (the inexact flag is set or the inexact flag is clear and
      // the 53-bit result with unbounded exponent is not tiny)))
      // and (the MXCSR overflow traps are disabled or the overflow flag is
      // clear) and (the MXCSR inexact traps are disabled or the inexact flag
      // is clear)
      //
      // in this case, the result has to be delivered (the status flags are 
      // sticky, so they are all set correctly already)

#ifdef _DEBUG_FPU
      // error if the condition stated above does not hold
      if (!((XmmiEnv->Masks & U_MASK || (!(XmmiEnv->Masks & U_MASK) && 
          !(sw & _SW_UNDERFLOW) && ((sw & _SW_INEXACT) || 
          !(sw & _SW_INEXACT) && !result_tiny))) &&
          ((XmmiEnv->Masks & O_MASK) || !(sw & _SW_OVERFLOW)) &&
          ((XmmiEnv->Masks & P_MASK) || !(sw & _SW_INEXACT)))) {
        fprintf (stderr, "XMMI2_FP_Emulation () INTERNAL XMMI2_FP_Emulation () ERROR for "
            "ADDPS/ADDSS/SUBPS/SUBSS/MULPS/MULSS/DIVPS/DIVSS\n");
      }
#endif

      XmmiEnv->Ieee->Result.OperandValid = 1;

      if (sw & _SW_UNDERFLOW) {
        XmmiEnv->Ieee->Status.Underflow = 1;
        XmmiEnv->Flags |= U_MASK;
      } else {
        XmmiEnv->Ieee->Status.Underflow = 0;
      }
      if (sw & _SW_OVERFLOW) {
        XmmiEnv->Ieee->Status.Overflow = 1;
        XmmiEnv->Flags |= O_MASK;
      } else {
        XmmiEnv->Ieee->Status.Overflow = 0;
      }
      if (sw & _SW_INEXACT) {
        XmmiEnv->Ieee->Status.Inexact = 1;
        XmmiEnv->Flags |= P_MASK;
      } else {
        XmmiEnv->Ieee->Status.Inexact = 0;
      }

      // if ftz = 1, and result is tiny (underflow traps must be disabled),
      // result = 0.0
      if (XmmiEnv->Fz && result_tiny) {
        if (res > 0.0)
          res = ZEROD;
        else if (res < 0.0)
          res = NZEROD;
        // else leave res unchanged

        XmmiEnv->Ieee->Status.Inexact = 1;
        XmmiEnv->Flags |= P_MASK;
        XmmiEnv->Ieee->Status.Underflow = 1;
        XmmiEnv->Flags |= U_MASK;
      }

      XmmiEnv->Ieee->Result.Value.Fp64Value = res; 

      // note that there is no way to
      // communicate to the caller that the denormal flag was set - we count
      // on the XMMI instruction to have set the denormal flag in MXCSR if
      // needed, regardless of the other components of the input operands
      // (invalid or not; the caller will have to update the underflow, 
      // overflow, and inexact flags in MXCSR)
      if (sw & _SW_ZERODIVIDE) {
        XmmiEnv->Ieee->Status.ZeroDivide = 1;
        XmmiEnv->Flags |= Z_MASK;
      } else {
        XmmiEnv->Ieee->Status.ZeroDivide = 0;
      }
      XmmiEnv->Ieee->Status.InvalidOperation = 0;

#ifdef _DEBUG_FPU
      // read status word
      sw = _status87 ();
      out_top = (sw >> 11) & 0x07;
      if (in_top != out_top) {
        printf ("XMMI2_FP_Emulation () ERROR 9: in_top =%d != out_top = %d\n", 
             in_top, out_top);
        exit (1);
      }
#endif
      return (NoExceptionRaised);

      break;

    case OP_CMPPD:
    case OP_CMPSD:

      opd1 = XmmiEnv->Ieee->Operand1.Value.Fp64Value;
      opd2 = XmmiEnv->Ieee->Operand2.Value.Fp64Value;
      if (XmmiEnv->Daz) {
        if (isdenormald (opd1)) opd1 = opd1 * 0.0;
        if (isdenormald (opd2)) opd2 = opd2 * 0.0;
      }
      imm8 = XmmiEnv->Imm8 & 0x07;

      // adjust operation code
      XmmiEnv->Ieee->Operation = _FpCodeCompare;

      // check whether an invalid exception has to be raised

      switch (imm8) {

        case IMM8_EQ:
        case IMM8_UNORD:
        case IMM8_NEQ:
        case IMM8_ORD:
          if (issnand (opd1) || issnand (opd2))
              invalid_exc = 1; // SNaN operands signal invalid
          else
              invalid_exc = 0; // QNaN or other operands do not signal invalid
          // guard against the case when an SNaN operand was converted to 
          // QNaN by compiler generated code
          sw = _status87 ();
          if (sw & _SW_INVALID) invalid_exc = 1;
          break;
        case IMM8_LT:
        case IMM8_LE:
        case IMM8_NLT:
        case IMM8_NLE:
          if (isnand (opd1) || isnand (opd2))
              invalid_exc = 1; // SNaN/QNaN operands signal invalid
          else
              invalid_exc = 0; // other operands do not signal invalid
          break;
        default:
          ; // will never occur

      }

      // if invalid_exc = 1, and invalid exceptions are enabled, take trap
      if (invalid_exc && !(XmmiEnv->Masks & I_MASK)) {

        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);
        XmmiEnv->Ieee->Status.InvalidOperation = 1;
        XmmiEnv->Flags |= I_MASK;
        // Cause = Enable & Status
        XmmiEnv->Ieee->Cause.InvalidOperation = 1;

        // Note: the calling function will have to interpret the value returned
        // by the user handler, if execution is to be continued

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
         printf ("XMMI2_FP_Emulation () ERROR 10: in_top =%d != out_top = %d\n", 
             in_top, out_top);
          exit (1);
        }
#endif
        return (ExceptionRaised);

      }

      // checking for NaN operands has priority over denormal exceptions
      if (isnand (opd1) || isnand (opd2)) {

        switch (imm8) {

          case IMM8_EQ:
          case IMM8_LT:
          case IMM8_LE:
          case IMM8_ORD:
            cmp_res = 0x0;
            break;
          case IMM8_UNORD:
          case IMM8_NEQ:
          case IMM8_NLT:
          case IMM8_NLE:
            cmp_res = 0xffffffffffffffff;
            break;
          default:
            ; // will never occur

        }

        XmmiEnv->Ieee->Result.OperandValid = 1;
        XmmiEnv->Ieee->Result.Value.Fp64Value = *((double *)&cmp_res); 
            // may make U32Value
  
        XmmiEnv->Ieee->Status.Inexact = 0;
        XmmiEnv->Ieee->Status.Underflow = 0;
        XmmiEnv->Ieee->Status.Overflow = 0;
        XmmiEnv->Ieee->Status.ZeroDivide = 0;
        // Note that the denormal flag will not be updated by _fpieee_flt (),
        // even if an operand is denormal
        if (invalid_exc) {
          XmmiEnv->Ieee->Status.InvalidOperation = 1;
          XmmiEnv->Flags |= I_MASK;
        } else {
          XmmiEnv->Ieee->Status.InvalidOperation = 0;
        }
  
#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
         printf ("XMMI2_FP_Emulation () ERROR 11: in_top =%d != out_top = %d\n",
             in_top, out_top);
          exit (1);
        }
#endif
        return (NoExceptionRaised);

      }

      // check whether a denormal exception has to be raised

      if (isdenormald (opd1) || isdenormald (opd2)) {
          denormal_exc = 1;
          XmmiEnv->Flags |= D_MASK;
      } else {
          denormal_exc = 0;
      }

      // if denormal_exc = 1, and denormal exceptions are enabled, take trap
      if (denormal_exc && !(XmmiEnv->Masks & D_MASK)) {

        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);

        // Note: the exception code is STATUS_FLOAT_INVALID in this case

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
         printf ("XMMI2_FP_Emulation () ERROR 12: in_top =%d != out_top = %d\n",
             in_top, out_top);
          exit (1);
        }
#endif
        return (ExceptionRaised);

      }

      // no exception has to be raised, and no operand is a NaN; calculate 
      // and deliver the result

      if (opd1 < opd2) {

        switch (imm8) {
  
          case IMM8_LT:
          case IMM8_LE:
          case IMM8_NEQ:
          case IMM8_ORD:
            cmp_res = 0xffffffffffffffff;
            break;
          case IMM8_EQ:
          case IMM8_UNORD:
          case IMM8_NLT:
          case IMM8_NLE:
            cmp_res = 0x0;
            break;

          default:
            ; // will never occur
  
        }

      } else if (opd1 > opd2) {

        switch (imm8) {
  
          case IMM8_NEQ:
          case IMM8_NLT:
          case IMM8_NLE:
          case IMM8_ORD:
            cmp_res = 0xffffffffffffffff;
            break;

          case IMM8_EQ:
          case IMM8_LT:
          case IMM8_LE:
          case IMM8_UNORD:
            cmp_res = 0x0;
            break;

          default:
            ; // will never occur
  
        }

      } else if (opd1 == opd2) {

        switch (imm8) {
  
          case IMM8_EQ:
          case IMM8_LE:
          case IMM8_NLT:
          case IMM8_ORD:
            cmp_res = 0xffffffffffffffff;
            break;

          case IMM8_LT:
          case IMM8_UNORD:
          case IMM8_NEQ:
          case IMM8_NLE:
            cmp_res = 0x0;
            break;

          default:
            ; // will never occur
  
        }

      } else { // could eliminate this case

#ifdef _DEBUG_FPU
        fprintf (stderr, "XMMI2_FP_Emulation () INTERNAL XMMI2_FP_Emulation ()"
            " ERROR for CMPPS/CMPSS\n");
#endif

      }

      XmmiEnv->Ieee->Result.OperandValid = 1;
      XmmiEnv->Ieee->Result.Value.Fp64Value = *((double *)&cmp_res); 
          // may make U32Value

      XmmiEnv->Ieee->Status.Inexact = 0;
      XmmiEnv->Ieee->Status.Underflow = 0;
      XmmiEnv->Ieee->Status.Overflow = 0;
      XmmiEnv->Ieee->Status.ZeroDivide = 0;
      // Note that the denormal flag will not be updated by _fpieee_flt (),
      // even if an operand is denormal
      XmmiEnv->Ieee->Status.InvalidOperation = 0;

#ifdef _DEBUG_FPU
      // read status word
      sw = _status87 ();
      out_top = (sw >> 11) & 0x07;
      if (in_top != out_top) {
        printf ("XMMI2_FP_Emulation () ERROR 13: in_top =%d != out_top = %d\n", 
             in_top, out_top);
        exit (1);
      }
#endif
      return (NoExceptionRaised);

      break;

    case OP_COMISD:
    case OP_UCOMISD:

      opd1 = XmmiEnv->Ieee->Operand1.Value.Fp64Value;
      opd2 = XmmiEnv->Ieee->Operand2.Value.Fp64Value;
      if (XmmiEnv->Daz) {
        if (isdenormald (opd1)) opd1 = opd1 * 0.0;
        if (isdenormald (opd2)) opd2 = opd2 * 0.0;
      }

      // check whether an invalid exception has to be raised

      switch (XmmiEnv->Ieee->Operation) {

        case OP_COMISD:

          if (isnand (opd1) || isnand (opd2)) {
              invalid_exc = 1;
          } else
              invalid_exc = 0;
          break;

        case OP_UCOMISD:

          if (issnand (opd1) || issnand (opd2))
              invalid_exc = 1;
          else
              invalid_exc = 0;
          // guard against the case when an SNaN operand was converted to 
          // QNaN by compiler generated code
          sw = _status87 ();
          if (sw & _SW_INVALID) invalid_exc = 1;
          break;

        default:
          ; // will never occur

      }

      // adjust operation code
      XmmiEnv->Ieee->Operation = _FpCodeCompare;

      // if invalid_exc = 1, and invalid exceptions are enabled, take trap
      if (invalid_exc && !(XmmiEnv->Masks & I_MASK)) {

        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);
        XmmiEnv->Ieee->Status.InvalidOperation = 1;
        XmmiEnv->Flags |= I_MASK;
        // Cause = Enable & Status
        XmmiEnv->Ieee->Cause.InvalidOperation = 1;

        // Note: the calling function will have to interpret the value returned
        // by the user handler, if execution is to be continued

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI2_FP_Emulation () ERROR 14: in_top =%d != out_top = "
              "%d\n", in_top, out_top);
          exit (1);
        }
#endif
        return (ExceptionRaised);

      }

      // EFlags:
      // 333222222222211111111110000000000
      // 210987654321098765432109876543210
      //                      O   SZ A P C

      // checking for NaN operands has priority over denormal exceptions
      if (isnand (opd1) || isnand (opd2)) {


        // OF, SF, AF = 000, ZF, PF, CF = 111
        XmmiEnv->EFlags = (XmmiEnv->EFlags & 0xfffff76f) | 0x00000045;

        XmmiEnv->Ieee->Status.Inexact = 0;
        XmmiEnv->Ieee->Status.Underflow = 0;
        XmmiEnv->Ieee->Status.Overflow = 0;
        XmmiEnv->Ieee->Status.ZeroDivide = 0;
        // Note that the denormal flag will not be updated by _fpieee_flt (),
        // even if an operand is denormal
        if (invalid_exc) {
          XmmiEnv->Ieee->Status.InvalidOperation = 1;
          XmmiEnv->Flags |= I_MASK;
        } else {
          XmmiEnv->Ieee->Status.InvalidOperation = 0;
        }

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI2_FP_Emulation () ERROR 15: in_top =%d != out_top = "
              "%d\n", in_top, out_top);
          exit (1);
        }
#endif
        return (NoExceptionRaised);

      }

      // check whether a denormal exception has to be raised

      if (isdenormald (opd1) || isdenormald (opd2)) {
          denormal_exc = 1;
          XmmiEnv->Flags |= D_MASK;
      } else {
          denormal_exc = 0;
      }

      // if denormal_exc = 1, and denormal exceptions are enabled, take trap
      if (denormal_exc && !(XmmiEnv->Masks & D_MASK)) {

        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);

        // Note: the exception code is STATUS_FLOAT_INVALID in this case

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI2_FP_Emulation () ERROR 16: in_top =%d != out_top = %d\n", 
             in_top, out_top);
          exit (1);
        }
#endif
        return (ExceptionRaised);

      }

      // no exception has to be raised, and no operand is a NaN; calculate 
      // and deliver the result

      // 333222222222211111111110000000000
      // 210987654321098765432109876543210
      //                      O   SZ A P C

      if (opd1 > opd2) {

        // OF, SF, AF = 000, ZF, PF, CF = 000
        XmmiEnv->EFlags = XmmiEnv->EFlags & 0xfffff72a;

      } else if (opd1 < opd2) {

        // OF, SF, AF = 000, ZF, PF, CF = 001
        XmmiEnv->EFlags = (XmmiEnv->EFlags & 0xfffff72b) | 0x00000001;

      } else if (opd1 == opd2) {

        // OF, SF, AF = 000, ZF, PF, CF = 100
        XmmiEnv->EFlags = (XmmiEnv->EFlags & 0xfffff76a) | 0x00000040;

      } else { // could eliminate this case

#ifdef _DEBUG_FPU
        fprintf (stderr, "XMMI2_FP_Emulation () INTERNAL XMMI2_FP_Emulation () "
            "ERROR for COMISS/UCOMISS\n");
#endif

      }

      XmmiEnv->Ieee->Status.Inexact = 0;
      XmmiEnv->Ieee->Status.Underflow = 0;
      XmmiEnv->Ieee->Status.Overflow = 0;
      XmmiEnv->Ieee->Status.ZeroDivide = 0;
      // Note that the denormal flag will not be updated by _fpieee_flt (),
      // even if an operand is denormal
      XmmiEnv->Ieee->Status.InvalidOperation = 0;

#ifdef _DEBUG_FPU
      // read status word
      sw = _status87 ();
      out_top = (sw >> 11) & 0x07;
      if (in_top != out_top) {
        printf ("XMMI2_FP_Emulation () ERROR 17: in_top =%d != out_top = %d\n", 
             in_top, out_top);
        exit (1);
      }
#endif
      return (NoExceptionRaised);

      break;

    case OP_CVTDQ2PS:

      iopd1 = XmmiEnv->Ieee->Operand1.Value.I32Value;

      switch (XmmiEnv->Rc) {
        case _FpRoundNearest:
          rc = _RC_NEAR;
          break;
        case _FpRoundMinusInfinity:
          rc = _RC_DOWN;
          break;
        case _FpRoundPlusInfinity:
          rc = _RC_UP;
          break;
        case _FpRoundChopped:
          rc = _RC_CHOP;
          break;
        default:
          ; // internal error
      }

      // execute the operation and check whether the inexact flag is set
      // and the respective exception is enabled

      _control87 (rc | _PC_24 | _MCW_EM, _MCW_EM | _MCW_RC | _MCW_PC);

      // perform the conversion
      __asm {
        fnclex; 
        fild  DWORD PTR iopd1; // exact
        fstp  DWORD PTR res24; // may set P
      }
 
      // read status word
      sw = _status87 ();

      // if inexact traps are enabled and result is inexact, take inexact trap
      if (!(XmmiEnv->Masks & P_MASK) && (sw & _SW_INEXACT)) {
        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);
        XmmiEnv->Ieee->Operation = _FpCodeConvert;
        XmmiEnv->Ieee->Status.Inexact = 1;
        XmmiEnv->Flags |= P_MASK;
        XmmiEnv->Ieee->Cause.Inexact = 1;
        XmmiEnv->Ieee->Result.OperandValid = 1;
        XmmiEnv->Ieee->Result.Value.Fp32Value = res24; // exact

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI2_FP_Emulation () ERROR 18: in_top =%d != out_top = %d\n", 
             in_top, out_top);
          exit (1);
        }
#endif
        return (ExceptionRaised);
      } 

      // if it got here, then there is no trap to be taken; in this case, 
      // the result has to be delivered

      XmmiEnv->Ieee->Result.OperandValid = 1;
      XmmiEnv->Ieee->Result.Value.Fp32Value = res24; // exact

      if (sw & _SW_INEXACT) {
        XmmiEnv->Ieee->Status.Inexact = 1;
        XmmiEnv->Flags |= P_MASK;
      } else {
        XmmiEnv->Ieee->Status.Inexact = 0;
      }
      XmmiEnv->Ieee->Status.Underflow = 0;
      XmmiEnv->Ieee->Status.Overflow = 0;
      XmmiEnv->Ieee->Status.ZeroDivide = 0;
      XmmiEnv->Ieee->Status.InvalidOperation = 0;

#ifdef _DEBUG_FPU
      // read status word
      sw = _status87 ();
      out_top = (sw >> 11) & 0x07;
      if (in_top != out_top) {
        printf ("XMMI2_FP_Emulation () ERROR 19: in_top =%d != out_top = %d\n", 
             in_top, out_top);
        exit (1);
      }
#endif
      return (NoExceptionRaised);

      break;

    case OP_CVTPS2DQ:
    case OP_CVTTPS2DQ:

      opd24 = XmmiEnv->Ieee->Operand1.Value.Fp32Value;
      if (XmmiEnv->Daz) {
        if (isdenormalf (opd24)) opd24 = opd24 * (float)0.0;
      }

      // adjust the operation code
      switch (XmmiEnv->Ieee->Operation) {

        case OP_CVTPS2DQ:

          XmmiEnv->Ieee->Operation = _FpCodeConvert;
          break;

        case OP_CVTTPS2DQ:

          XmmiEnv->Ieee->Operation = _FpCodeConvertTrunc;
          break;

        default:
          ; // will never occur

      }

      switch (XmmiEnv->Ieee->Operation) {

        case _FpCodeConvert:

          switch (XmmiEnv->Rc) {
            case _FpRoundNearest:
              rc = _RC_NEAR;
              break;
            case _FpRoundMinusInfinity:
              rc = _RC_DOWN;
              break;
            case _FpRoundPlusInfinity:
              rc = _RC_UP;
              break;
            case _FpRoundChopped:
              rc = _RC_CHOP;
              break;
            default:
              ; // internal error
          }

          break;

        case _FpCodeConvertTrunc:

          rc = _RC_CHOP;
          break;

        default:
          ; // will never occur

      }

      // execute the operation and check whether the inexact flag is set
      // and the respective exceptions enabled

      _control87 (rc | _PC_24 | _MCW_EM, _MCW_EM | _MCW_RC | _MCW_PC);

      // perform the conversion
      __asm {
        fnclex; 
        fld DWORD PTR opd24; // may set the denormal [ignored] or invalid
                             // status flags
        fistp DWORD PTR ires; // may set the inexact or invalid status
                               // flags (for NaN or out-of-range)
      }

      // read status word
      sw = _status87 ();

      // if invalid flag is set, and invalid exceptions are enabled, take trap
      if (!(XmmiEnv->Masks & I_MASK) && (sw & _SW_INVALID)) {
        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);
        XmmiEnv->Ieee->Status.InvalidOperation = 1;
        XmmiEnv->Flags |= I_MASK;
        // Cause = Enable & Status
        XmmiEnv->Ieee->Cause.InvalidOperation = 1;

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI2_FP_Emulation () ERROR 20: in_top =%d != out_top = %d\n", 
             in_top, out_top);
          exit (1);
        }
#endif
        return (ExceptionRaised);

      }

      // at this point, there are no enabled invalid exceptions; the
      // instruction might have lead to an enabled inexact exception, or to
      // no exception at all

      XmmiEnv->Ieee->Result.Value.I32Value = ires;

      // if inexact traps are enabled and result is inexact, take inexact trap
      // (no flush-to-zero situation is possible)
      if (!(XmmiEnv->Masks & P_MASK) && (sw & _SW_INEXACT)) {
        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);
        XmmiEnv->Ieee->Status.Inexact = 1;
        XmmiEnv->Flags |= P_MASK;
        XmmiEnv->Ieee->Cause.Inexact = 1;
        XmmiEnv->Ieee->Result.OperandValid = 1;

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI2_FP_Emulation () ERROR 21: in_top =%d != out_top = %d\n", 
             in_top, out_top);
          exit (1);
        }
#endif
        return (ExceptionRaised);
      } 

      // if it got here, then there is no trap to be taken; return result

      XmmiEnv->Ieee->Result.OperandValid = 1;

      if (sw & _SW_INEXACT) {
        XmmiEnv->Ieee->Status.Inexact = 1;
        XmmiEnv->Flags |= P_MASK;
      } else {
        XmmiEnv->Ieee->Status.Inexact = 0;
      }
      XmmiEnv->Ieee->Status.Underflow = 0;
      XmmiEnv->Ieee->Status.Overflow = 0;
      XmmiEnv->Ieee->Status.ZeroDivide = 0;
      if (sw & _SW_INVALID) {
        XmmiEnv->Ieee->Status.InvalidOperation = 1;
        XmmiEnv->Flags |= I_MASK;
      } else {
        XmmiEnv->Ieee->Status.InvalidOperation = 0;
      }

#ifdef _DEBUG_FPU
      // read status word
      sw = _status87 ();
      out_top = (sw >> 11) & 0x07;
      if (in_top != out_top) {
        printf ("XMMI2_FP_Emulation () ERROR 22: in_top =%d != out_top = %d\n", 
             in_top, out_top);
        exit (1);
      }
#endif
      return (NoExceptionRaised);

      break;

    case OP_CVTPD2PI:
    case OP_CVTSD2SI:
    case OP_CVTPD2DQ:
    case OP_CVTTPD2PI:
    case OP_CVTTSD2SI:
    case OP_CVTTPD2DQ:

      opd1 = XmmiEnv->Ieee->Operand1.Value.Fp64Value;
      if (XmmiEnv->Daz) {
        if (isdenormald (opd1)) opd1 = opd1 * 0.0;
      }

      // adjust the operation code
      switch (XmmiEnv->Ieee->Operation) {

        case OP_CVTPD2PI:
        case OP_CVTSD2SI:
        case OP_CVTPD2DQ:

          XmmiEnv->Ieee->Operation = _FpCodeConvert;
          break;

        case OP_CVTTPD2PI:
        case OP_CVTTSD2SI:
        case OP_CVTTPD2DQ:

          XmmiEnv->Ieee->Operation = _FpCodeConvertTrunc;
          break;

        default:
          ; // will never occur

      }

      switch (XmmiEnv->Ieee->Operation) {

        case _FpCodeConvert:

          switch (XmmiEnv->Rc) {
            case _FpRoundNearest:
              rc = _RC_NEAR;
              break;
            case _FpRoundMinusInfinity:
              rc = _RC_DOWN;
              break;
            case _FpRoundPlusInfinity:
              rc = _RC_UP;
              break;
            case _FpRoundChopped:
              rc = _RC_CHOP;
              break;
            default:
              ; // internal error
          }

          break;

        case _FpCodeConvertTrunc:

          rc = _RC_CHOP;
          break;

        default:
          ; // will never occur

      }

      // execute the operation and check whether the inexact flag is set
      // and the respective exceptions enabled

      _control87 (rc | _PC_53 | _MCW_EM, _MCW_EM | _MCW_RC | _MCW_PC);

      // perform the conversion
      __asm {
        fnclex; 
        fld  QWORD PTR opd1; // may set the denormal [ignored] or invalid
                             // status flags
        fistp  DWORD PTR ires; // may set the inexact or invalid status
                               // flags (for NaN or out-of-range)
      }

      // read status word
      sw = _status87 ();

      // if invalid flag is set, and invalid exceptions are enabled, take trap
      if (!(XmmiEnv->Masks & I_MASK) && (sw & _SW_INVALID)) {
        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);
        XmmiEnv->Ieee->Status.InvalidOperation = 1;
        XmmiEnv->Flags |= I_MASK;
        // Cause = Enable & Status
        XmmiEnv->Ieee->Cause.InvalidOperation = 1;

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI2_FP_Emulation () ERROR 20: in_top =%d != out_top = %d\n", 
             in_top, out_top);
          exit (1);
        }
#endif
        return (ExceptionRaised);

      }

      // at this point, there are no enabled invalid exceptions; the
      // instruction might have lead to an enabled inexact exception, or to
      // no exception at all

      XmmiEnv->Ieee->Result.Value.I32Value = ires;

      // if inexact traps are enabled and result is inexact, take inexact trap
      // (no flush-to-zero situation is possible)
      if (!(XmmiEnv->Masks & P_MASK) && (sw & _SW_INEXACT)) {
        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);
        XmmiEnv->Ieee->Status.Inexact = 1;
        XmmiEnv->Flags |= P_MASK;
        XmmiEnv->Ieee->Cause.Inexact = 1;
        XmmiEnv->Ieee->Result.OperandValid = 1;

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI2_FP_Emulation () ERROR 21: in_top =%d != out_top = %d\n", 
             in_top, out_top);
          exit (1);
        }
#endif
        return (ExceptionRaised);
      } 

      // if it got here, then there is no trap to be taken; return result

      XmmiEnv->Ieee->Result.OperandValid = 1;

      if (sw & _SW_INEXACT) {
        XmmiEnv->Ieee->Status.Inexact = 1;
        XmmiEnv->Flags |= P_MASK;
      } else {
        XmmiEnv->Ieee->Status.Inexact = 0;
      }
      XmmiEnv->Ieee->Status.Underflow = 0;
      XmmiEnv->Ieee->Status.Overflow = 0;
      XmmiEnv->Ieee->Status.ZeroDivide = 0;
      if (sw & _SW_INVALID) {
        XmmiEnv->Ieee->Status.InvalidOperation = 1;
        XmmiEnv->Flags |= I_MASK;
      } else {
        XmmiEnv->Ieee->Status.InvalidOperation = 0;
      }

#ifdef _DEBUG_FPU
      // read status word
      sw = _status87 ();
      out_top = (sw >> 11) & 0x07;
      if (in_top != out_top) {
        printf ("XMMI2_FP_Emulation () ERROR 22: in_top =%d != out_top = %d\n", 
             in_top, out_top);
        exit (1);
      }
#endif
      return (NoExceptionRaised);

      break;

    case OP_CVTPS2PD:
    case OP_CVTSS2SD:

      opd24 = XmmiEnv->Ieee->Operand1.Value.Fp32Value;
      if (XmmiEnv->Daz) {
        if (isdenormalf (opd24)) opd24 = opd24 * (float)0.0;
      }

      // adjust the operation code
      XmmiEnv->Ieee->Operation = _FpCodeConvert;

      switch (XmmiEnv->Rc) {
        case _FpRoundNearest:
          rc = _RC_NEAR;
          break;
        case _FpRoundMinusInfinity:
          rc = _RC_DOWN;
          break;
        case _FpRoundPlusInfinity:
          rc = _RC_UP;
          break;
        case _FpRoundChopped:
          rc = _RC_CHOP;
          break;
        default:
          ; // internal error
      }

      // execute the operation and check whether the invalid or denormal 
      // flag is set and the respective exception is enabled

      _control87 (rc | _PC_53 | _MCW_EM, _MCW_EM | _MCW_RC | _MCW_PC); // redun.

      // perform the conversion
      __asm {
        fnclex; 
        fld DWORD PTR opd24; // may set the denormal or invalid
                             // status flags; exact
        fstp QWORD PTR res; // store as a double; exact
      }

      // read status word
      sw = _status87 ();

      // if invalid flag is set, and invalid exceptions are enabled, take trap
      if (!(XmmiEnv->Masks & I_MASK) && (sw & _SW_INVALID)) {
        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);
        XmmiEnv->Ieee->Status.InvalidOperation = 1;
        XmmiEnv->Flags |= I_MASK;
        // Cause = Enable & Status
        XmmiEnv->Ieee->Cause.InvalidOperation = 1;

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI2_FP_Emulation () ERROR 20: in_top =%d != out_top = %d\n", 
             in_top, out_top);
          exit (1);
        }
#endif
        return (ExceptionRaised);

      }

      if (sw & _SW_DENORMAL) XmmiEnv->Flags |= D_MASK; // whether enabled or not

      // if denormal flag is set, and denormal exceptions are enabled, take trap
      if (!(XmmiEnv->Masks & D_MASK) && (sw & _SW_DENORMAL)) {

        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI_FP_Emulate () ERROR 28: in_top =%d != out_top = %d\n",
             in_top, out_top);
          exit (1);
        }
#endif
        return (ExceptionRaised);

      }

      // at this point, there are no enabled invalid or denormal exceptions;
      // the instruction did not lead to an enabled exception; return result

      XmmiEnv->Ieee->Result.Value.Fp64Value = res;
      XmmiEnv->Ieee->Result.OperandValid = 1;

      XmmiEnv->Ieee->Status.Inexact = 0;
      XmmiEnv->Ieee->Status.Underflow = 0;
      XmmiEnv->Ieee->Status.Overflow = 0;
      XmmiEnv->Ieee->Status.ZeroDivide = 0;
      if (sw & _SW_INVALID) {
        XmmiEnv->Ieee->Status.InvalidOperation = 1;
        XmmiEnv->Flags |= I_MASK;
      } else {
        XmmiEnv->Ieee->Status.InvalidOperation = 0;
      }

#ifdef _DEBUG_FPU
      // read status word
      sw = _status87 ();
      out_top = (sw >> 11) & 0x07;
      if (in_top != out_top) {
        printf ("XMMI2_FP_Emulation () ERROR 22: in_top =%d != out_top = %d\n", 
             in_top, out_top);
        exit (1);
      }
#endif
      return (NoExceptionRaised);

      break;

    case OP_CVTPD2PS:
    case OP_CVTSD2SS:

      opd1 = XmmiEnv->Ieee->Operand1.Value.Fp64Value;
      if (XmmiEnv->Daz) {
        if (isdenormald (opd1)) opd1 = opd1 * 0.0;
      }

      // adjust the operation code
      XmmiEnv->Ieee->Operation = _FpCodeConvert;

      switch (XmmiEnv->Rc) {
        case _FpRoundNearest:
          rc = _RC_NEAR;
          break;
        case _FpRoundMinusInfinity:
          rc = _RC_DOWN;
          break;
        case _FpRoundPlusInfinity:
          rc = _RC_UP;
          break;
        case _FpRoundChopped:
          rc = _RC_CHOP;
          break;
        default:
          ; // internal error
      }

      // execute the operation and check whether the invalid or denormal 
      // flag is set and the respective exception is enabled

      _control87 (rc | _PC_24 | _MCW_EM, _MCW_EM | _MCW_RC | _MCW_PC);

      // perform the conversion
      __asm {
        fnclex; 
        fld QWORD PTR opd1; // may set the denormal or invalid
                             // status flags; exact
        fstp DWORD PTR res24; // store as a single; may set the underflow/
                              // overflow and/or the inexact status flags
      }

      // read status word
      sw = _status87 ();

      // if invalid flag is set, and invalid exceptions are enabled, take trap
      if (!(XmmiEnv->Masks & I_MASK) && (sw & _SW_INVALID)) {
        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);
        XmmiEnv->Ieee->Status.InvalidOperation = 1;
        XmmiEnv->Flags |= I_MASK;
        // Cause = Enable & Status
        XmmiEnv->Ieee->Cause.InvalidOperation = 1;

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI2_FP_Emulation () ERROR 20: in_top =%d != out_top = %d\n", 
             in_top, out_top);
          exit (1);
        }
#endif
        return (ExceptionRaised);

      }

      if (sw & _SW_DENORMAL) XmmiEnv->Flags |= D_MASK; // whether enabled or not

      // if denormal flag is set, and denormal exceptions are enabled, take trap
      if (!(XmmiEnv->Masks & D_MASK) && (sw & _SW_DENORMAL)) {

        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI_FP_Emulate () ERROR 28: in_top =%d != out_top = %d\n",
             in_top, out_top);
          exit (1);
        }
#endif
        return (ExceptionRaised);

      }

      // done if opd1 is 0.0, inf, or NaN
      if (isnand (opd1) || isinfd (opd1) || iszerod (opd1)) {
        XmmiEnv->Ieee->Result.OperandValid = 1;
        XmmiEnv->Ieee->Result.Value.Fp32Value = res24;
        XmmiEnv->Ieee->Status.Underflow = 0;
        XmmiEnv->Ieee->Status.Overflow = 0;
        XmmiEnv->Ieee->Status.Inexact = 0;
        XmmiEnv->Ieee->Status.ZeroDivide = 0;
        if (sw & _SW_INVALID) {
          XmmiEnv->Ieee->Status.InvalidOperation = 1;
          XmmiEnv->Flags |= I_MASK;
        } else {
          XmmiEnv->Ieee->Status.InvalidOperation = 0;
        }
#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI_FP_Emulate () ERROR 5: in_top =%d != out_top = %d\n",
             in_top, out_top);
          exit (1);
        }
#endif
        return (NoExceptionRaised);
      }

      // at this point, there are no enabled I, or D exceptions, and the input
      // operand is not 0, infinity, or NaN; the instruction
      // might lead to an enabled underflow, enabled underflow and inexact,
      // enabled overflow, enabled overflow and inexact, enabled inexact, or
      // none of these; if there are no U or O enabled exceptions, the result
      // is res24

      // check whether there is an underflow, overflow, or inexact trap to be
      // taken

      // calculate the result to 24 bits, with 'unbounded' exponent
      __asm {
        fnclex;
        fld QWORD PTR opd1; // may set the denormal or invalid
                             // status flags (same as above)
        fld1; // +1.0
        fmulp st(1), st(0); // rounded to 24 bits; may set P
        fstp QWORD PTR dbl_res24; // store as a double; may set the underflow/
                              // overflow and/or the inexact status flags,
                              // but no new trap flags are set here
      }

      if (-MIN_SINGLE_NORMAL < dbl_res24 && dbl_res24 < MIN_SINGLE_NORMAL) {
        result_tiny = 1;
      }

      // check if the result is huge
      if (dbl_res24 < -MAX_SINGLE_NORMAL || MAX_SINGLE_NORMAL < dbl_res24) {
        result_huge = 1;
      }

      // if the underflow traps are enabled and the result is tiny, take
      // underflow trap
      if (!(XmmiEnv->Masks & U_MASK) && result_tiny) {
        // leave source and destination operands unchanged
        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);
        XmmiEnv->Ieee->Status.Underflow = 1;
        XmmiEnv->Flags |= U_MASK;
        XmmiEnv->Ieee->Cause.Underflow = 1;
        XmmiEnv->Ieee->Result.OperandValid = 0;

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI_FP_Emulate () ERROR 6: in_top =%d != out_top = %d\n",
             in_top, out_top);
          exit (1);
        }
#endif
        return (ExceptionRaised);
      }

      // if overflow traps are enabled and the result is huge, take
      // overflow trap
      if (!(XmmiEnv->Masks & O_MASK) &&  result_huge) {
        // leave source and destination operands unchanged
        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);
        XmmiEnv->Ieee->Status.Overflow = 1;
        XmmiEnv->Flags |= O_MASK;
        XmmiEnv->Ieee->Cause.Overflow = 1;
        XmmiEnv->Ieee->Result.OperandValid = 0;

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI_FP_Emulate () ERROR 7: in_top =%d != out_top = %d\n",
             in_top, out_top);
          exit (1);
        }
#endif
        return (ExceptionRaised);
      }


      // at this point, there are no enabled exceptions, or an enabled 
      // inexact exception; return the result from res24

      // if inexact traps are enabled and result is inexact, take inexact trap
      if (!(XmmiEnv->Masks & P_MASK) &&
          ((sw & _SW_INEXACT) || (XmmiEnv->Fz && result_tiny))) {
        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);
        XmmiEnv->Ieee->Status.Inexact = 1;
        XmmiEnv->Flags |= P_MASK;
        XmmiEnv->Ieee->Cause.Inexact = 1;
        XmmiEnv->Ieee->Result.OperandValid = 1;
        if (result_tiny) {
          XmmiEnv->Ieee->Status.Underflow = 1;
          XmmiEnv->Flags |= U_MASK;
          // Note: the condition above is equivalent to
          // if (sw & _SW_UNDERFLOW) XmmiEnv->Ieee->Status.Underflow = 1;
        }
        if (result_huge) {
          XmmiEnv->Ieee->Status.Overflow = 1;
          XmmiEnv->Flags |= O_MASK;
          // Note: the condition above is equivalent to
          // if (sw & _SW_OVERFLOW) XmmiEnv->Ieee->Status.Overflow = 1;
        }

        // if ftz = 1 and result is tiny, result = 0.0
        // (no need to check for underflow traps disabled: result tiny and
        // underflow traps enabled would have caused taking an underflow
        // trap above)
        if (XmmiEnv->Fz && result_tiny) {
            // Note: the condition above is equivalent to
            // if (XmmiEnv->Fz && (sw & _SW_UNDERFLOW))
          if (res24 > 0.0) // it might already be +0.0 from fmulp and/or fstp
            res24 = ZEROF;
          else if (res24 < 0.0) // it might already be -0.0 from fmulp/fstp
            res24 = NZEROF;
          // else leave res24 unchanged
        }

        XmmiEnv->Ieee->Result.Value.Fp32Value = res24;
#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI_FP_Emulate () ERROR 8: in_top =%d != out_top = %d\n",
             in_top, out_top);
          exit (1);
        }
#endif
        return (ExceptionRaised);
      }

      // if it got here, then there is no trap to be taken
 
      XmmiEnv->Ieee->Result.OperandValid = 1;

      if (sw & _SW_UNDERFLOW) {
        XmmiEnv->Ieee->Status.Underflow = 1;
        XmmiEnv->Flags |= U_MASK;
      } else {
        XmmiEnv->Ieee->Status.Underflow = 0;
      }
      if (sw & _SW_OVERFLOW) {
        XmmiEnv->Ieee->Status.Overflow = 1;
        XmmiEnv->Flags |= O_MASK;
      } else {
        XmmiEnv->Ieee->Status.Overflow = 0;
      }
      if (sw & _SW_INEXACT) {
        XmmiEnv->Ieee->Status.Inexact = 1;
        XmmiEnv->Flags |= P_MASK;
      } else {
        XmmiEnv->Ieee->Status.Inexact = 0;
      }

      // if ftz = 1, and result is tiny (underflow traps must be disabled),
      // result = 0.0
      if (XmmiEnv->Fz && result_tiny) {
        if (res24 > 0.0)
          res24 = ZEROF;
        else if (res24 < 0.0)
          res24 = NZEROF;
        // else leave res24 unchanged

        XmmiEnv->Ieee->Status.Inexact = 1;
        XmmiEnv->Flags |= P_MASK;
        XmmiEnv->Ieee->Status.Underflow = 1;
        XmmiEnv->Flags |= U_MASK;
      }
      XmmiEnv->Ieee->Result.Value.Fp32Value = res24;

      // note that there is no way to
      // communicate to the caller that the denormal flag was set - we count
      // on the XMMI instruction to have set the denormal flag in MXCSR if
      // needed, regardless of the other components of the input operands
      // (invalid or not; the caller will have to update the underflow,
      // overflow, and inexact flags in MXCSR)
      if (sw & _SW_INVALID) {
        XmmiEnv->Ieee->Status.InvalidOperation = 1;
        XmmiEnv->Flags |= I_MASK;
      } else {
        XmmiEnv->Ieee->Status.InvalidOperation = 0;
      }

#ifdef _DEBUG_FPU
      // read status word
      sw = _status87 ();
      out_top = (sw >> 11) & 0x07;
      if (in_top != out_top) {
        printf ("XMMI_FP_Emulate () ERROR 9: in_top =%d != out_top = %d\n",
             in_top, out_top);
        exit (1);
      }
#endif
      return (NoExceptionRaised);
      break;

    case OP_MAXPD:
    case OP_MAXSD:
    case OP_MINPD:
    case OP_MINSD:

      opd1 = XmmiEnv->Ieee->Operand1.Value.Fp64Value;
      opd2 = XmmiEnv->Ieee->Operand2.Value.Fp64Value;
      if (XmmiEnv->Daz) {
        if (isdenormald (opd1)) opd1 = opd1 * 0.0;
        if (isdenormald (opd2)) opd2 = opd2 * 0.0;
      }

      // adjust operation code
      switch (XmmiEnv->Ieee->Operation) {

        case OP_MAXPD:
        case OP_MAXSD:
          XmmiEnv->Ieee->Operation = _FpCodeFmax;
          break;

        case OP_MINPD:
        case OP_MINSD:
          XmmiEnv->Ieee->Operation = _FpCodeFmin;
          break;

        default:
          ; // will never occur

      }

      // check whether an invalid exception has to be raised

      if (isnand (opd1) || isnand (opd2))
          invalid_exc = 1;
      else
          invalid_exc = 0;

      // if invalid_exc = 1, and invalid exceptions are enabled, take trap
      if (invalid_exc && !(XmmiEnv->Masks & I_MASK)) {

        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);
        XmmiEnv->Ieee->Status.InvalidOperation = 1;
        XmmiEnv->Flags |= I_MASK;
        // Cause = Enable & Status
        XmmiEnv->Ieee->Cause.InvalidOperation = 1;

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI2_FP_Emulation () ERROR 23: in_top =%d != out_top = "
              "%d\n", in_top, out_top);
          exit (1);
        }
#endif
        return (ExceptionRaised);

      }

      // checking for NaN operands has priority over denormal exceptions

      if (invalid_exc) {

        XmmiEnv->Ieee->Result.OperandValid = 1;

        XmmiEnv->Ieee->Result.Value.Fp64Value = opd2;
  
        XmmiEnv->Ieee->Status.Inexact = 0;
        XmmiEnv->Ieee->Status.Underflow = 0;
        XmmiEnv->Ieee->Status.Overflow = 0;
        XmmiEnv->Ieee->Status.ZeroDivide = 0;
        XmmiEnv->Ieee->Status.InvalidOperation = 1;
        XmmiEnv->Flags |= I_MASK;
  
#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI2_FP_Emulation () ERROR 24: in_top =%d != out_top = "
             "%d\n", in_top, out_top);
          exit (1);
        }
#endif
        return (NoExceptionRaised);

      }

      // check whether a denormal exception has to be raised

      if (isdenormald (opd1) || isdenormald (opd2)) {
          denormal_exc = 1;
          XmmiEnv->Flags |= D_MASK;
      } else {
          denormal_exc = 0;
      }

      // if denormal_exc = 1, and denormal exceptions are enabled, take trap
      if (denormal_exc && !(XmmiEnv->Masks & D_MASK)) {

        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);

        // Note: the exception code is STATUS_FLOAT_INVALID in this case

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI2_FP_Emulation () ERROR 25: in_top =%d != out_top = "
             "%d\n", in_top, out_top);
          exit (1);
        }
#endif
        return (ExceptionRaised);

      }

      // no exception has to be raised, and no operand is a NaN; calculate 
      // and deliver the result

      if (opd1 < opd2) {

        switch (XmmiEnv->Ieee->Operation) {
          case _FpCodeFmax:
            XmmiEnv->Ieee->Result.Value.Fp64Value = opd2;
            break;
          case _FpCodeFmin:
            XmmiEnv->Ieee->Result.Value.Fp64Value = opd1;
            break;
          default:
            ; // will never occur
        }

      } else if (opd1 > opd2) {

        switch (XmmiEnv->Ieee->Operation) {
          case _FpCodeFmax:
            XmmiEnv->Ieee->Result.Value.Fp64Value = opd1;
            break;
          case _FpCodeFmin:
            XmmiEnv->Ieee->Result.Value.Fp64Value = opd2;
            break;
          default:
            ; // will never occur
        }

      } else if (opd1 == opd2) {

        XmmiEnv->Ieee->Result.Value.Fp64Value = opd2;

      } else { // could eliminate this case

#ifdef _DEBUG_FPU
        fprintf (stderr, 
            "XMMI2_FP_Emulation () INTERNAL XMMI2_FP_Emulation () ERROR for MAXPS/MAXSS/MINPS/MINSS\n");
#endif

      }

      XmmiEnv->Ieee->Result.OperandValid = 1;

      XmmiEnv->Ieee->Status.Inexact = 0;
      XmmiEnv->Ieee->Status.Underflow = 0;
      XmmiEnv->Ieee->Status.Overflow = 0;
      XmmiEnv->Ieee->Status.ZeroDivide = 0;
      // Note that the denormal flag will not be updated by _fpieee_flt (),
      // even if an operand is denormal
      XmmiEnv->Ieee->Status.InvalidOperation = 0;

#ifdef _DEBUG_FPU
      // read status word
      sw = _status87 ();
      out_top = (sw >> 11) & 0x07;
      if (in_top != out_top) {
        printf ("XMMI2_FP_Emulation () ERROR 26: in_top =%d != out_top = %d\n", 
             in_top, out_top);
        exit (1);
      }
#endif
      return (NoExceptionRaised);

      break;

    case OP_SQRTPD:
    case OP_SQRTSD:

      opd1 = XmmiEnv->Ieee->Operand1.Value.Fp64Value;
      if (XmmiEnv->Daz) {
        if (isdenormald (opd1)) opd1 = opd1 * 0.0;
      }

      // adjust operation code
      XmmiEnv->Ieee->Operation = _FpCodeSquareRoot;

      // execute the operation and check whether the invalid, denormal, or 
      // inexact flags are set and the respective exceptions enabled

      switch (XmmiEnv->Rc) {
        case _FpRoundNearest:
          rc = _RC_NEAR;
          break;
        case _FpRoundMinusInfinity:
          rc = _RC_DOWN;
          break;
        case _FpRoundPlusInfinity:
          rc = _RC_UP;
          break;
        case _FpRoundChopped:
          rc = _RC_CHOP;
          break;
        default:
          ; // internal error
      }

      _control87 (rc | _PC_53 | _MCW_EM, _MCW_EM | _MCW_RC | _MCW_PC);

      // perform the square root
      __asm {
        fnclex; 
        fld  QWORD PTR opd1; // may set the denormal or invalid status flags
        fsqrt; // may set the inexact or invalid status flags
        fstp  QWORD PTR res; // exact
      }
 
      // read status word
      sw = _status87 ();
      if (sw & _SW_INVALID) sw = sw & ~0x00080000; // clr D flag for sqrt(-den)

      // if invalid flag is set, and invalid exceptions are enabled, take trap
      if (!(XmmiEnv->Masks & I_MASK) && (sw & _SW_INVALID)) {

        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);
        XmmiEnv->Ieee->Status.InvalidOperation = 1;
        XmmiEnv->Flags |= I_MASK;
        // Cause = Enable & Status
        XmmiEnv->Ieee->Cause.InvalidOperation = 1;

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI2_FP_Emulation () ERROR 27: in_top =%d != out_top = "
              "%d\n", in_top, out_top);
          exit (1);
        }
#endif
        return (ExceptionRaised);

      }

      if (sw & _SW_DENORMAL) XmmiEnv->Flags |= D_MASK;

      // if denormal flag is set, and denormal exceptions are enabled, take trap
      if (!(XmmiEnv->Masks & D_MASK) && (sw & _SW_DENORMAL)) {

        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI2_FP_Emulation () ERROR 28: in_top =%d != out_top = %d\n", 
             in_top, out_top);
          exit (1);
        }
#endif
        return (ExceptionRaised);

      }

      // the result cannot be tiny

      // at this point, there are no enabled I or D or exceptions; the instr.
      // might lead to an enabled inexact exception or to no exception (this
      // includes the case of a NaN or negative operand); exceptions must have 
      // been disabled before calling this function; an inexact exception is
      // reported on the fsqrt

      // if (the MXCSR inexact traps are disabled or the inexact flag is clear)
      // then deliver the result (the status flags are sticky, so they are
      // all set correctly already)
 
      // if it got here, then there is either an inexact trap to be taken, or
      // no trap at all

      XmmiEnv->Ieee->Result.Value.Fp64Value = res; // exact

      // if inexact traps are enabled and result is inexact, take inexact trap
      if (!(XmmiEnv->Masks & P_MASK) && (sw & _SW_INEXACT)) {
        // fill in part of the FP IEEE record
        Fill_FPIEEE_RECORD (XmmiEnv);
        XmmiEnv->Ieee->Status.Inexact = 1;
        XmmiEnv->Flags |= P_MASK;
        XmmiEnv->Ieee->Cause.Inexact = 1;
        XmmiEnv->Ieee->Result.OperandValid = 1;

#ifdef _DEBUG_FPU
        // read status word
        sw = _status87 ();
        out_top = (sw >> 11) & 0x07;
        if (in_top != out_top) {
          printf ("XMMI2_FP_Emulation () ERROR 29: in_top =%d != out_top = %d\n", 
             in_top, out_top);
          exit (1);
        }
#endif
        return (ExceptionRaised);
      } 

      // no trap was taken

      XmmiEnv->Ieee->Result.OperandValid = 1;
 
      XmmiEnv->Ieee->Status.Underflow = 0;
      XmmiEnv->Ieee->Status.Overflow = 0;
      if (sw & _SW_INEXACT) {
        XmmiEnv->Ieee->Status.Inexact = 1;
        XmmiEnv->Flags |= P_MASK;
      } else {
        XmmiEnv->Ieee->Status.Inexact = 0;
      }

      // note that there is no way to
      // communicate to the caller that the denormal flag was set - we count
      // on the XMMI instruction to have set the denormal flag in MXCSR if
      // needed, regardless of the other components of the input operands
      // (invalid or not); the caller will have to update the inexact flag
      // in MXCSR
      XmmiEnv->Ieee->Status.ZeroDivide = 0;
      if (sw & _SW_INVALID) {
        XmmiEnv->Ieee->Status.InvalidOperation = 1;
        XmmiEnv->Flags = I_MASK; // no other flags set if invalid is set
      } else {
        XmmiEnv->Ieee->Status.InvalidOperation = 0;
      }

#ifdef _DEBUG_FPU
      // read status word
      sw = _status87 ();
      out_top = (sw >> 11) & 0x07;
      if (in_top != out_top) {
        printf ("XMMI2_FP_Emulation () ERROR 30: in_top =%d != out_top = %d\n", 
             in_top, out_top);
        exit (1);
      }
#endif
      return (NoExceptionRaised);

      break;

    case OP_UNSPEC:

#ifdef _DEBUG_FPU
      fprintf (stderr, 
         "XMMI2_FP_Emulation internal error: unknown operation code OP_UNSPEC\n");
#endif

      break;

    default:
#ifdef _DEBUG_FPU
      fprintf (stderr, 
          "XMMI2_FP_Emulation internal error: unknown operation code %d\n", 
          XmmiEnv->Ieee->Operation);
#endif
      break;
  }

}


static int
iszerod (double d)

{

  unsigned int *dp;

  dp = (unsigned int *)&d;

  if (((dp[1] & 0x7fffffff) == 0x0) && (dp[0] == 0x0))
    return (1);
  else
    return (0);

}


static int
isinfd (double d)

{

  unsigned int *dp;

  dp = (unsigned int *)&d;

  if (((dp[1] & 0x7fffffff) == 0x7ff80000) && (dp[0] == 0x0))
    return (1);
  else
    return (0);

}


static int
issnand (double d)

{

  unsigned int *dp;

  dp = (unsigned int *)&d;

  if (((dp[1] & 0x7ff80000) == 0x7ff00000) && 
      (((dp[1] & 0x0007ffff) != 0) || (dp[0] != 0)))
    return (1);
  else
    return (0);

}


static int
isnand (double d)

{

  unsigned int *qp;

  qp = (unsigned int *)&d;

  if (((qp[1] & 0x7ff00000) == 0x7ff00000) &&
      (((qp[1] & 0x000fffff) != 0x00000000) || qp[0] != 0x00000000))
    return (1);
  else
    return (0);

}


static double
quietd (double d)

{

  // makes a signaling NaN quiet, and leaves a quiet NaN unchanged; does
  // not check that the input value d is a NaN

  unsigned int *dp;

  dp = (unsigned int *)&d;

  dp[1] = dp[1] | 0x00080000;
  return (d);

}


static int
isdenormald (double d)

{

  unsigned int *dp;

  dp = (unsigned int *)&d;

  if (((dp[1] & 0x7ff00000) == 0x0) && 
      (((dp[1] & 0x000fffff) != 0) || (dp[0] != 0)))
    return (1);
  else
    return (0);

}


static int
isdenormalf (float f)

{

  // checks whether f is a denormal

  unsigned int *fp;

  fp = (unsigned int *)&f;

  if ((fp[0] & 0x7f800000) == 0x0 && (fp[0] & 0x007fffff) != 0x0)
    return (1);
  else
    return (0);

}


static void Fill_FPIEEE_RECORD (PXMMI_ENV XmmiEnv)

{

  // fill in part of the FP IEEE record

  XmmiEnv->Ieee->RoundingMode = XmmiEnv->Rc;
  XmmiEnv->Ieee->Precision = XmmiEnv->Precision;
  XmmiEnv->Ieee->Enable.Inexact = !(XmmiEnv->Masks & P_MASK);
  XmmiEnv->Ieee->Enable.Underflow = !(XmmiEnv->Masks & U_MASK);
  XmmiEnv->Ieee->Enable.Overflow = !(XmmiEnv->Masks & O_MASK);
  XmmiEnv->Ieee->Enable.ZeroDivide = !(XmmiEnv->Masks & Z_MASK);
  XmmiEnv->Ieee->Enable.InvalidOperation = !(XmmiEnv->Masks & I_MASK);
  XmmiEnv->Ieee->Status.Inexact = 0;
  XmmiEnv->Ieee->Status.Underflow = 0;
  XmmiEnv->Ieee->Status.Overflow = 0;
  XmmiEnv->Ieee->Status.ZeroDivide = 0;
  XmmiEnv->Ieee->Status.InvalidOperation = 0;
  // Cause = Enable & Status
  XmmiEnv->Ieee->Cause.Inexact = 0;
  XmmiEnv->Ieee->Cause.Underflow = 0;
  XmmiEnv->Ieee->Cause.Overflow = 0;
  XmmiEnv->Ieee->Cause.ZeroDivide = 0;
  XmmiEnv->Ieee->Cause.InvalidOperation = 0;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\ia64\acosf.s ===
.file "acosf.s"

// Copyright (c) 2000, 2001, Intel Corporation
// All rights reserved.
//
// Contributed 2/2/2000 by John Harrison, Ted Kubaska, Bob Norin, Shane Story,
// and Ping Tak Peter Tang of the Computational Software Lab, Intel Corporation.
//
// WARRANTY DISCLAIMER
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// Intel Corporation is the author of this code, and requests that all
// problem reports or change requests be submitted to it directly at
// http://developer.intel.com/opensource.

// History
//==============================================================
// 2/02/00  Initial version
// 6/28/00  Improved speed
// 6/31/00  Changed register allocation because of some duplicate macros
//          moved nan exit bundle up to gain a cycle.
// 8/15/00  Bundle added after call to __libm_error_support to properly
//          set [the previously overwritten] GR_Parameter_RESULT.
// 8/17/00  Changed predicate register macro-usage to direct predicate
//          names due to an assembler bug.
// 10/17/00 Improved speed of x=0 and x=1 paths, set D flag if x denormal.
// 3/13/01  Corrected sign of imm1 value in dep instruction.


// Description
//=========================================
// The acosf function computes the principle value of the arc sine of x.
// A doman error occurs for arguments not in the range [-1,+1].

// The acosf function returns the arc cosine in the range [0, +pi] radians.
// acos(1) returns +0
// acos(x) returns a Nan and raises the invalid exception for |x| >1 

// |x| <= sqrt(2)/2. get Ax and Bx

// poly_p1 = x p1
// poly_p3 = x2 p4 + p3
// poly_p1 = x2 (poly_p1) + x  = x2(x p1) + x
// poly_p2 = x2( poly_p3) + p2 = x2(x2 p4 + p3) + p2

// poly_Ax = x5(x2( poly_p3) + p2) + x2(x p1) + x
//         = x5(x2(x2 p4 + p3) + p2) + x2(x p1) + x

// poly_p7 = x2 p8 + p7
// poly_p5 = x2 p6 + p5

// poly_p7 = x4 p9 + (x2 p8 + p7)
// poly_Bx = x4 (x4 p9 + (x2 p8 + p7)) + x2 p6 + p5

// sinf1 = x11(x4 (x4 p9 + (x2 p8 + p7)) + x2 p6 + p5) + x5(x2(x2 p4 + p3) + p2) + x2(x p1) + x
//       = x19 p9 + x17 p8 + x15 p7 x13 p6 + x11 p5 + x9 p4 + x7 p3 + x5 p2 + x3 p1 + x
// answer1 = pi/2 - sinf1



// |x| >  sqrt(2)/2

// Get z = sqrt(1-x2)

// Get polynomial in t = 1-x2

// t2      = t t
// t4      = t2 t2

// poly_p4 = t p5 + p4
// poly_p1 = t p1 + 1

// poly_p6 = t p7 + p6
// poly_p2 = t p3 + p2

// poly_p8 = t p9 + p8

// poly_p4 = t2 poly_p6 + poly_p4
//         = t2 (t p7 + p6) + (t p5 + p4)

// poly_p2 = t2 poly_p2 + poly_p1
//         = t2 (t p3 + p2) + (t p1 + 1)

// poly_p4 = t4 poly_p8 + poly_p4
//         = t4 (t p9 + p8) + (t2 (t p7 + p6) + (t p5 + p4))

// P(t)    = poly_p2 + t4 poly_p8
//         = t2 (t p3 + p2) + (t p1 + 1) + t4 (t4 (t p9 + p8) + (t2 (t p7 + p6) + (t p5 + p4)))
//         = t3 p3 + t2 p2 + t p1 + 1 + t9 p9 + t8 p8 + t7 p7 + t6 p6 + t5 p5 + t4 p4


//  answer2 = sign(x) z P(t)       if x>0
//          = sign(x) z P(t) + pi  if x<0


//
// Assembly macros
//=========================================

// predicate registers
//acosf_pred_LEsqrt2by2            = p7
//acosf_pred_GTsqrt2by2            = p8

// integer registers
ACOSF_Addr1                      = r33
ACOSF_Addr2                      = r34
ACOSF_GR_1by2                    = r35

ACOSF_GR_3by2                    = r36
ACOSF_GR_5by2                    = r37

GR_SAVE_B0                    = r38
GR_SAVE_PFS                   = r39
GR_SAVE_GP                    = r40

GR_Parameter_X                = r41
GR_Parameter_Y                = r42
GR_Parameter_RESULT           = r43
GR_Parameter_TAG              = r44

// floating point registers

acosf_y                          = f32
acosf_abs_x                      = f33
acosf_x2                         = f34
acosf_sgn_x                      = f35

acosf_1by2                       = f36
acosf_3by2                       = f37
acosf_5by2                       = f38
acosf_coeff_P3                   = f39
acosf_coeff_P8                   = f40

acosf_coeff_P1                   = f41
acosf_coeff_P4                   = f42
acosf_coeff_P5                   = f43
acosf_coeff_P2                   = f44
acosf_coeff_P7                   = f45

acosf_coeff_P6                   = f46
acosf_coeff_P9                   = f47
acosf_x2                         = f48
acosf_x3                         = f49
acosf_x4                         = f50

acosf_x8                         = f51
acosf_x5                         = f52
acosf_const_piby2                = f53
acosf_const_sqrt2by2             = f54
acosf_x11                        = f55

acosf_poly_p1                    = f56
acosf_poly_p3                    = f57
acosf_sinf1                      = f58
acosf_poly_p2                    = f59
acosf_poly_Ax                    = f60

acosf_poly_p7                    = f61
acosf_poly_p5                    = f62
acosf_sgnx_t4                    = f63
acosf_poly_Bx                    = f64
acosf_t                          = f65

acosf_yby2                       = f66
acosf_B                          = f67
acosf_B2                         = f68
acosf_Az                         = f69
acosf_dz                         = f70

acosf_Sz                         = f71
acosf_d2z                        = f72
acosf_Fz                         = f73
acosf_z                          = f74
acosf_sgnx_z                     = f75

acosf_t2                         = f76
acosf_2poly_p4                   = f77
acosf_2poly_p6                   = f78
acosf_2poly_p1                   = f79
acosf_2poly_p2                   = f80

acosf_2poly_p8                   = f81
acosf_t4                         = f82
acosf_Pt                         = f83
acosf_sgnx_2poly_p2              = f84
acosf_sgn_x_piby2                = f85

acosf_poly_p7a                   = f86
acosf_2poly_p4a                  = f87
acosf_2poly_p4b                  = f88
acosf_2poly_p2a                  = f89
acosf_poly_p1a                   = f90





// Data tables
//==============================================================

.data

.align 16

acosf_coeff_1_table:
data8 0x3FC5555607DCF816 // P1
data8 0x3F9CF81AD9BAB2C6 // P4
data8 0x3FC59E0975074DF3 // P7
data8 0xBFA6F4CC2780AA1D // P6
data8 0x3FC2DD45292E93CB // P9
data8 0x3fe6a09e667f3bcd // sqrt(2)/2

acosf_coeff_2_table:
data8 0x3FA6F108E31EFBA6 // P3
data8 0xBFCA31BF175D82A0 // P8
data8 0x3FA30C0337F6418B // P5
data8 0x3FB332C9266CB1F9 // P2
data8 0x3ff921fb54442d18 // pi_by_2


.align 32
.global acosf

.section .text
.proc  acosf
.align 32

acosf:
 
// Load the addresses of the two tables.
// Then, load the coefficients and other constants.

{     .mfi 
     alloc      r32            = ar.pfs,1,8,4,0
     fnma.s1   acosf_t        =    f8,f8,f1
     dep.z ACOSF_GR_1by2 =    0x3f,24,8    // 0x3f000000
} 
{     .mfi 
     addl ACOSF_Addr1    =    @ltoff(acosf_coeff_1_table),gp
     fma.s1    acosf_x2       =    f8,f8,f0
     addl      ACOSF_Addr2    =    @ltoff(acosf_coeff_2_table),gp ;;
}

 
{     .mfi 
     ld8       ACOSF_Addr1    =    [ACOSF_Addr1]
     fmerge.s  acosf_abs_x    =    f1,f8
     dep ACOSF_GR_3by2 =    -1,r0,22,8     // 0x3fc00000
} 
{     .mlx 
     nop.m                      999
     movl      ACOSF_GR_5by2  =    0x40200000;;
}

 

{     .mfi 
     setf.s    acosf_1by2     =    ACOSF_GR_1by2
     fmerge.s  acosf_sgn_x    =    f8,f1
     nop.i                      999
} 
{     .mfi 
     ld8       ACOSF_Addr2    =    [ACOSF_Addr2]
     nop.f 0
     nop.i                      999;;
}

 
{     .mfi 
     setf.s    acosf_5by2     =    ACOSF_GR_5by2
     fcmp.lt.s1 p11,p12 = f8,f0
     nop.i                      999;;
}

{ .mmf 
     ldfpd     acosf_coeff_P1,acosf_coeff_P4 =    [ACOSF_Addr1],16
     setf.s    acosf_3by2     =    ACOSF_GR_3by2
     fclass.m.unc p8,p0      = f8, 0xc3 ;;	//@qnan | @snan
}

 
{     .mfi 
     ldfpd     acosf_coeff_P7,acosf_coeff_P6 =    [ACOSF_Addr1],16
     fma.s1    acosf_t2                      =    acosf_t,acosf_t,f0
     nop.i                                     999
} 
{     .mfi 
     ldfpd     acosf_coeff_P3,acosf_coeff_P8 =    [ACOSF_Addr2],16
     fma.s1    acosf_x4                      =    acosf_x2,acosf_x2,f0
     nop.i                                     999;;
}

 
{     .mfi 
     ldfpd     acosf_coeff_P9,acosf_const_sqrt2by2     =    [ACOSF_Addr1]
     fclass.m.unc p10,p0      = f8, 0x07	//@zero
     nop.i                                     999
} 
{     .mfi 
     ldfpd     acosf_coeff_P5,acosf_coeff_P2 =    [ACOSF_Addr2],16
     fma.s1    acosf_x3  =    f8,acosf_x2,f0
     nop.i                                     999;;
}

 
{     .mfi 
     ldfd      acosf_const_piby2   =    [ACOSF_Addr2]
     frsqrta.s1     acosf_B,p0                   =    acosf_t
     nop.i                                               999
} 
{     .mfb 
     nop.m                                               999
(p8) fma.s f8                = f8,f1,f0
(p8) br.ret.spnt   b0 ;;  // Exit if x=nan
}

 
{     .mfb 
     nop.m                 999
     fcmp.eq.s1 p6,p0 = acosf_abs_x,f1
(p10) br.cond.spnt  ACOSF_ZERO ;;     // Branch if x=0
} 
 
{     .mfi 
     nop.m                 999
     fcmp.gt.s1 p9,p0 = acosf_abs_x,f1
     nop.i                 999;;
} 
 
{     .mfi 
     nop.m                 999
     fma.s1    acosf_x8  =    acosf_x4,acosf_x4,f0
     nop.i                 999
} 
{     .mfb 
     nop.m                      999
     fma.s1    acosf_t4  =    acosf_t2,acosf_t2,f0
(p6) br.cond.spnt  ACOSF_ABS_ONE ;;     // Branch if |x|=1
} 

{     .mfi 
     nop.m                 999
     fma.s1    acosf_x5  =    acosf_x2,acosf_x3,f0
     nop.i                 999
}
{     .mfb 
(p9) mov            GR_Parameter_TAG = 59
     fma.s1    acosf_yby2     =    acosf_t,acosf_1by2,f0
(p9) br.cond.spnt  __libm_error_region ;;    // Branch if |x|>1
}


{     .mfi 
     nop.m                 999
     fma.s1    acosf_Az  =    acosf_t,acosf_B,f0
     nop.i                 999
} 
{     .mfi 
     nop.m                 999
     fma.s1    acosf_B2  =    acosf_B,acosf_B,f0
     nop.i                 999;;
}
 
{     .mfi 
     nop.m                      999
     fma.s1    acosf_poly_p1  =    f8,acosf_coeff_P1,f0
     nop.i                      999
} 
{     .mfi 
     nop.m                      999
     fma.s1    acosf_2poly_p1 =    acosf_coeff_P1,acosf_t,f1
     nop.i                      999;;
}

{     .mfi 
     nop.m                      999
     fma.s1    acosf_poly_p3  =    acosf_coeff_P4,acosf_x2,acosf_coeff_P3
     nop.i                      999
} 
{     .mfi 
     nop.m                      999
     fma.s1    acosf_2poly_p6 =    acosf_coeff_P7,acosf_t,acosf_coeff_P6
     nop.i                      999;;
} 

{     .mfi 
     nop.m                      999
     fma.s1    acosf_poly_p7  =    acosf_x2,acosf_coeff_P8,acosf_coeff_P7
     nop.i                      999
} 
{     .mfi 
     nop.m                      999
     fma.s1    acosf_2poly_p2 =    acosf_coeff_P3,acosf_t,acosf_coeff_P2
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                      999
     fma.s1    acosf_poly_p5  =    acosf_x2,acosf_coeff_P6,acosf_coeff_P5
     nop.i                      999
} 
{     .mfi 
     nop.m                      999
     fma.s1    acosf_2poly_p4 =    acosf_coeff_P5,acosf_t,acosf_coeff_P4
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                 999
     fma.s1    acosf_x11 =    acosf_x8,acosf_x3,f0
     nop.i                 999
} 
{     .mfi 
     nop.m                 999
     fnma.s1   acosf_dz  =    acosf_B2,acosf_yby2,acosf_1by2
     nop.i                 999;;
}

 
{     .mfi 
     nop.m                      999
     fma.s1    acosf_poly_p1a =    acosf_x2,acosf_poly_p1,f8
     nop.i                      999
}
{     .mfi 
     nop.m                      999
     fma.s1    acosf_2poly_p8 =    acosf_coeff_P9,acosf_t,acosf_coeff_P8
     nop.i                      999;;
}

 
// Get the absolute value of x and determine the region in which x lies

{     .mfi 
     nop.m                      999
     fcmp.le.s1     p7,p8 = acosf_abs_x,acosf_const_sqrt2by2
     nop.i                      999
} 
{     .mfi 
     nop.m                      999
     fma.s1    acosf_poly_p2  =    acosf_x2,acosf_poly_p3,acosf_coeff_P2
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                      999
     fma.s1    acosf_poly_p7a =    acosf_x4,acosf_coeff_P9,acosf_poly_p7
     nop.i                      999
} 
{     .mfi 
     nop.m                      999
     fma.s1    acosf_2poly_p2a =    acosf_2poly_p2,acosf_t2,acosf_2poly_p1
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                                                         999
(p8) fma.s1    acosf_sgnx_t4  =    acosf_sgn_x,acosf_t4,f0
     nop.i                                                         999
} 
{     .mfi 
     nop.m                      999
(p8) fma.s1    acosf_2poly_p4a =    acosf_2poly_p6,acosf_t2,acosf_2poly_p4
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                 999
(p8) fma.s1    acosf_Sz  =    acosf_5by2,acosf_dz,acosf_3by2
     nop.i                 999
} 
{     .mfi 
     nop.m                 999
(p8) fma.s1    acosf_d2z =    acosf_dz,acosf_dz,f0
     nop.i                 999;;
}

 
{     .mfi 
     nop.m                           999
(p8) fnma.d.s1   acosf_sgn_x_piby2 =    acosf_sgn_x,acosf_const_piby2,acosf_const_piby2
     nop.i                           999
} 
{     .mfi 
     nop.m                      999
(p7) fma.s1    acosf_poly_Ax  =    acosf_x5,acosf_poly_p2,acosf_poly_p1a
     nop.i                 999;;
} 
 
{     .mfi 
     nop.m                      999
(p7) fma.s1    acosf_poly_Bx  =    acosf_x4,acosf_poly_p7a,acosf_poly_p5
     nop.i                      999
} 
{     .mfi 
     nop.m                           999
(p8) fma.s1    acosf_sgnx_2poly_p2 =    acosf_sgn_x,acosf_2poly_p2a,f0
     nop.i                           999;;
} 
 
{     .mfi 
     nop.m                      999
     fcmp.eq.s0 p6,p0 = f8,f0      // Only purpose is to set D if x denormal
     nop.i                      999
}
{     .mfi 
     nop.m                      999
(p8) fma.s1    acosf_2poly_p4b =    acosf_2poly_p8,acosf_t4,acosf_2poly_p4a
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                      999
(p8) fma.s1    acosf_Fz  =    acosf_d2z,acosf_Sz,acosf_dz
     nop.i                 999;;
} 

 
{     .mfi 
     nop.m                 999
(p8) fma.d.s1  acosf_Pt  =    acosf_2poly_p4b,acosf_sgnx_t4,acosf_sgnx_2poly_p2
     nop.i                 999;;
} 
 
{     .mfi 
     nop.m                 999
(p8) fma.d.s1  acosf_z   =    acosf_Az,acosf_Fz,acosf_Az
     nop.i                 999 ;;
} 
 
{     .mfi 
     nop.m                      999
(p7) fma.d.s1  acosf_sinf1    =    acosf_x11,acosf_poly_Bx,acosf_poly_Ax
     nop.i                      999;;
} 
 
.pred.rel "mutex",p8,p7    //acosf_pred_GTsqrt2by2,acosf_pred_LEsqrt2by2
{     .mfi 
      nop.m            999
(p8)  fma.s     f8   =    acosf_z,acosf_Pt,acosf_sgn_x_piby2
      nop.i            999
} 
 
{     .mfb 
      nop.m            999
(p7)  fms.s     f8   =    acosf_const_piby2,f1,acosf_sinf1
      br.ret.sptk b0 ;;
} 

ACOSF_ZERO:
// Here if x=0
{     .mfb 
      nop.m                 999
      fma.s    f8 =    acosf_const_piby2,f1,f0  // acosf(0)=pi/2
      br.ret.sptk b0 ;;
} 


.pred.rel "mutex",p11,p12
ACOSF_ABS_ONE:
// Here if |x|=1
{     .mfi 
      nop.m                 999
(p11) fma.s    f8 =    acosf_const_piby2,f1,acosf_const_piby2 // acosf(-1)=pi
      nop.i                 999
} 
{     .mfb 
      nop.m                 999
(p12) fma.s    f8 =    f1,f0,f0 // acosf(1)=0
      br.ret.sptk b0 ;;
} 

.endp acosf


// Stack operations when calling error support.
//       (1)               (2)
//   sp   -> +          psp -> +
//           |                 |
//           |                 | <- GR_Y
//           |                 |
//           | <-GR_Y      Y2->|
//           |                 |
//           |                 | <- GR_X
//           |                 |
//  sp-64 -> +          sp ->  +
//    save ar.pfs          save b0
//    save gp


// Stack operations when calling error support.
//     (3) (call)              (4)
//  psp -> +                   sp -> +
//         |                         |
//    R3 ->| <- GR_RESULT            | -> f8
//         |                         |
//    Y2 ->| <- GR_Y                 |
//         |                         |
//    X1 ->|                         |
//         |                         |
//  sp ->  +                         +
//                              restore gp
//                              restore ar.pfs


.proc __libm_error_region
__libm_error_region:
.prologue
{ .mfi
        add   GR_Parameter_Y=-32,sp             // Parameter 2 value
                nop.f 999
.save   ar.pfs,GR_SAVE_PFS
        mov  GR_SAVE_PFS=ar.pfs                 // Save ar.pfs
}
{ .mfi
.fframe 64
        add sp=-64,sp                           // Create new stack
        nop.f 0
        mov GR_SAVE_GP=gp                       // Save gp
};;
{ .mmi
        stfs [GR_Parameter_Y] = f1,16         // Store Parameter 2 on stack
        add GR_Parameter_X = 16,sp              // Parameter 1 address
.save   b0, GR_SAVE_B0
        mov GR_SAVE_B0=b0                       // Save b0
};;

.body
{ .mfi
        nop.m 0
        frcpa.s0 f9,p0 = f0,f0
        nop.i 0
};;

{ .mib
        stfs [GR_Parameter_X] = f8            // Store Parameter 1 on stack
        add   GR_Parameter_RESULT = 0,GR_Parameter_Y
        nop.b 0                                 // Parameter 3 address
}
{ .mib
        stfs [GR_Parameter_Y] = f9           // Store Parameter 3 on stack
        add   GR_Parameter_Y = -16,GR_Parameter_Y
        br.call.sptk b0=__libm_error_support#   // Call error handling function
};;
{ .mmi
        nop.m 0
        nop.m 0
        add   GR_Parameter_RESULT = 48,sp
};;

{ .mmi
        ldfs  f8 = [GR_Parameter_RESULT]       // Get return result off stack
.restore
        add   sp = 64,sp                       // Restore stack pointer
        mov   b0 = GR_SAVE_B0                  // Restore return address
};;
{ .mib
        mov   gp = GR_SAVE_GP                  // Restore gp
        mov   ar.pfs = GR_SAVE_PFS             // Restore ar.pfs
        br.ret.sptk     b0                     // Return
};;

.endp __libm_error_region

.type   __libm_error_support#,@function
.global __libm_error_support#
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\ia64\acos.s ===
.file "acos.s"

// Copyright (c) 2000, 2001, Intel Corporation
// All rights reserved.
//
// Contributed 2/2/2000 by John Harrison, Ted Kubaska, Bob Norin, Shane Story,
// and Ping Tak Peter Tang of the Computational Software Lab, Intel Corporation.
//
// WARRANTY DISCLAIMER
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// Intel Corporation is the author of this code, and requests that all
// problem reports or change requests be submitted to it directly at
// http://developer.intel.com/opensource.

// History
//==============================================================
// 2/02/00  Initial version 
// 8/17/00  New and much faster algorithm.
// 8/30/00  Avoided bank conflicts on loads, shortened |x|=1 and x=0 paths,
//          fixed mfb split issue stalls.

// Description
//=========================================
// The acos function computes the principle value of the arc sine of x.
// A doman error occurs for arguments not in the range [-1,+1].

// The acos function returns the arc cosine in the range [0, +pi] radians.
// acos(1) returns +0, acos(-1) returns pi, acos(0) returns pi/2.
// acos(x) returns a Nan and raises the invalid exception for |x| >1

// The acos function is just like asin except that pi/2 is added at the end.

//
// Assembly macros
//=========================================


// predicate registers
//acos_pred_LEsqrt2by2            = p7
//acos_pred_GTsqrt2by2            = p8

// integer registers
ASIN_Addr1                      = r33
ASIN_Addr2                      = r34
ASIN_FFFE                       = r35

GR_SAVE_B0                      = r36
GR_SAVE_PFS                     = r37
GR_SAVE_GP                      = r38

GR_Parameter_X                  = r39
GR_Parameter_Y                  = r40
GR_Parameter_RESULT             = r41
GR_Parameter_Tag                = r42

// floating point registers
acos_coeff_P1                   = f32
acos_coeff_P2                   = f33
acos_coeff_P3                   = f34
acos_coeff_P4                   = f35

acos_coeff_P5                   = f36
acos_coeff_P6                   = f37
acos_coeff_P7                   = f38
acos_coeff_P8                   = f39
acos_coeff_P9                   = f40

acos_coeff_P10                  = f41
acos_coeff_P11                  = f42
acos_coeff_P12                  = f43
acos_coeff_P13                  = f44
acos_coeff_P14                  = f45

acos_coeff_P15                  = f46
acos_coeff_P16                  = f47
acos_coeff_P17                  = f48
acos_coeff_P18                  = f49
acos_coeff_P19                  = f50

acos_coeff_P20                  = f51
acos_coeff_P21                  = f52
acos_const_sqrt2by2             = f53
acos_const_piby2                = f54
acos_abs_x                      = f55

acos_tx                         = f56
acos_tx2                        = f57
acos_tx3                        = f58
acos_tx4                        = f59
acos_tx8                        = f60

acos_tx11                       = f61
acos_1poly_p8                   = f62
acos_1poly_p19                  = f63
acos_1poly_p4                   = f64
acos_1poly_p15                  = f65

acos_1poly_p6                   = f66
acos_1poly_p17                  = f67
acos_1poly_p0                   = f68
acos_1poly_p11                  = f69
acos_1poly_p2                   = f70

acos_1poly_p13                  = f71
acos_series_tx                  = f72
acos_t                          = f73
acos_t2                         = f74
acos_t3                         = f75

acos_t4                         = f76
acos_t8                         = f77
acos_t11                        = f78
acos_poly_p8                    = f79
acos_poly_p19                   = f80

acos_poly_p4                    = f81
acos_poly_p15                   = f82
acos_poly_p6                    = f83
acos_poly_p17                   = f84
acos_poly_p0                    = f85

acos_poly_p11                   = f86
acos_poly_p2                    = f87
acos_poly_p13                   = f88
acos_series_t                   = f89
acos_1by2                       = f90

acos_3by2                       = f91
acos_5by2                       = f92
acos_11by4                      = f93
acos_35by8                      = f94
acos_63by8                      = f95

acos_231by16                    = f96 
acos_y0                         = f97 
acos_H0                         = f98 
acos_S0                         = f99 
acos_d                          = f100

acos_l1                         = f101
acos_d2                         = f102
acos_T0                         = f103
acos_d1                         = f104
acos_e0                         = f105

acos_l2                         = f106
acos_d3                         = f107
acos_T3                         = f108
acos_S1                         = f109
acos_e1                         = f110

acos_z                          = f111
answer2                         = f112
acos_sgn_x                      = f113
acos_429by16                    = f114
acos_18by4                      = f115

acos_3by4                       = f116
acos_l3                         = f117
acos_T6                         = f118
acos_const_add                  = f119

// Data tables
//==============================================================

.data

.align 16

acos_coeff_1_table:
data8 0xE4E7E0A423A21249  , 0x00003FF8 //P7
data8 0xC2F7EE0200FCE2A5  , 0x0000C003 //P18
data8 0xB745D7F6C65C20E0  , 0x00003FF9 //P5
data8 0xF75E381A323D4D94  , 0x0000C002 //P16
data8 0x8959C2629C1024C0  , 0x0000C002 //P20
data8 0xAFF68E7D241292C5  , 0x00003FF8 //P9
data8 0xB6DB6DB7260AC30D  , 0x00003FFA //P3
data8 0xD0417CE2B41CB7BF  , 0x0000C000 //P14
data8 0x81D570FEA724E3E4  , 0x0000BFFD //P12
data8 0xAAAAAAAAAAAAC277  , 0x00003FFC //P1
data8 0xF534912FF3E7B76F  , 0x00003FFF //P21
data8 0xc90fdaa22168c235  , 0x00003fff // pi/2
data8 0x0000000000000000  , 0x00000000 // pad to avoid bank conflicts


acos_coeff_2_table:
data8 0x8E26AF5F29B39A2A  , 0x00003FF9 //P6
data8 0xB4F118A4B1015470  , 0x00004003 //P17
data8 0xF8E38E10C25990E0  , 0x00003FF9 //P4
data8 0x80F50489AEF1CAC6  , 0x00004002 //P15
data8 0x92728015172CFE1C  , 0x00004003 //P19
data8 0xBBC3D831D4595971  , 0x00003FF8 //P8
data8 0x999999999952A5C3  , 0x00003FFB //P2
data8 0x855576BE6F0975EC  , 0x00003FFF //P13
data8 0xF12420E778077D89  , 0x00003FFA //P11
data8 0xB6590FF4D23DE003  , 0x00003FF3 //P10
data8 0xb504f333f9de6484  , 0x00003ffe // sqrt(2)/2



.align 32
.global acos

.section .text
.proc  acos
.align 32


acos:
 
{     .mfi 
     alloc      r32               = ar.pfs,1,6,4,0
     fma.s1    acos_tx        =    f8,f8,f0
     addl      ASIN_Addr2     =    @ltoff(acos_coeff_2_table),gp
} 
{     .mfi 
     mov       ASIN_FFFE      =    0xFFFE
     fnma.s1   acos_t         =    f8,f8,f1
     addl      ASIN_Addr1     =    @ltoff(acos_coeff_1_table),gp
}
;;

 
{     .mfi 
     setf.exp       acos_1by2      =    ASIN_FFFE
     fmerge.s       acos_abs_x     =    f1,f8
     nop.i          999              ;;
} 
 

{     .mmf 
     ld8       ASIN_Addr1     =    [ASIN_Addr1]
     ld8       ASIN_Addr2     =    [ASIN_Addr2]
     fmerge.s  acos_sgn_x     =    f8,f1
} 
;;


{     .mfi 
     nop.m                      999
     fcmp.lt.s1  p11,p12  = f8, f0
     nop.i          999              ;;
} 
 
 
{     .mfi 
     ldfe      acos_coeff_P7  =    [ASIN_Addr1],16
     fma.s1    acos_tx2       =    acos_tx,acos_tx,f0
     nop.i                      999
} 
{     .mfi 
     ldfe      acos_coeff_P6  =    [ASIN_Addr2],16
     fma.s1    acos_t2        =    acos_t,acos_t,f0
     nop.i                      999;;
}

 
{     .mmf 
     ldfe      acos_coeff_P18 =    [ASIN_Addr1],16
     ldfe      acos_coeff_P17 =    [ASIN_Addr2],16
     fclass.m.unc p8,p0  = f8, 0xc3	//@qnan |@snan
} 
;;

 
{     .mmf 
     ldfe      acos_coeff_P5  =    [ASIN_Addr1],16
     ldfe      acos_coeff_P4  =    [ASIN_Addr2],16
     frsqrta.s1     acos_y0,p0     =    acos_t
} 
;;

 
{     .mfi 
     ldfe      acos_coeff_P16 =    [ASIN_Addr1],16
     fcmp.gt.s1 p9,p0 = acos_abs_x,f1
     nop.i                      999
} 
{     .mfb 
     ldfe      acos_coeff_P15 =    [ASIN_Addr2],16
(p8) fma.d     f8 = f8,f1,f0
(p8) br.ret.spnt b0
}
;;

 
{     .mmf 
     ldfe      acos_coeff_P20 =    [ASIN_Addr1],16
     ldfe      acos_coeff_P19 =    [ASIN_Addr2],16
     fclass.m.unc p10,p0 = f8, 0x07	//@zero
} 
;;

 
{     .mfi 
     ldfe      acos_coeff_P9  =    [ASIN_Addr1],16
     fma.s1    acos_t4        =    acos_t2,acos_t2,f0
(p9) mov GR_Parameter_Tag = 58 
} 
{     .mfi 
     ldfe      acos_coeff_P8  =    [ASIN_Addr2],16
     fma.s1    acos_3by2      =    acos_1by2,f1,f1
     nop.i                      999;;
}

 
{     .mfi 
     ldfe      acos_coeff_P2  =    [ASIN_Addr2],16
     fma.s1    acos_tx4       =    acos_tx2,acos_tx2,f0
     nop.i 999
} 
{     .mfb 
     ldfe      acos_coeff_P3  =    [ASIN_Addr1],16
     fma.s1    acos_t3        =    acos_t,acos_t2,f0
(p9) br.cond.spnt  __libm_error_region
}
;;

 
{     .mfi 
     ldfe      acos_coeff_P13 =    [ASIN_Addr2],16
     fma.s1    acos_H0        =    acos_y0,acos_1by2,f0
     nop.i                      999
} 
{     .mfi 
     ldfe      acos_coeff_P14 =    [ASIN_Addr1],16
     fma.s1    acos_S0        =    acos_y0,acos_t,f0
     nop.i                      999;;
}

 
{     .mfi 
     ldfe      acos_coeff_P11 =    [ASIN_Addr2],16
     fcmp.eq.s1  p6,p0  = acos_abs_x, f1
     nop.i                      999
} 
{     .mfi 
     ldfe      acos_coeff_P12 =    [ASIN_Addr1],16
     fma.s1    acos_tx3       =    acos_tx,acos_tx2,f0
     nop.i 999
}
;;

 
{     .mfi 
     ldfe      acos_coeff_P10 =    [ASIN_Addr2],16
     fma.s1    acos_1poly_p6  =    acos_tx,acos_coeff_P7,acos_coeff_P6
     nop.i                      999
} 
{     .mfi 
     ldfe      acos_coeff_P1  =    [ASIN_Addr1],16
     fma.s1    acos_poly_p6   =    acos_t,acos_coeff_P7,acos_coeff_P6
     nop.i                      999;;
}

 
{     .mfi 
     ldfe      acos_const_sqrt2by2 =    [ASIN_Addr2],16
     fma.s1    acos_5by2           =    acos_3by2,f1,f1
     nop.i                           999
} 
{     .mfi 
     ldfe      acos_coeff_P21 =    [ASIN_Addr1],16
     fma.s1    acos_11by4     =    acos_3by2,acos_3by2,acos_1by2
     nop.i                      999;;
}

 
{     .mfi 
     ldfe      acos_const_piby2    =    [ASIN_Addr1],16
     fma.s1    acos_poly_p17       =    acos_t,acos_coeff_P18,acos_coeff_P17
     nop.i                      999
} 
{     .mfb 
     nop.m                 999
     fma.s1    acos_3by4 =    acos_3by2,acos_1by2,f0
(p10) br.cond.spnt  ACOS_ZERO    // Branch to short path if x=0
}
;;

 
{     .mfi 
     nop.m                      999
     fma.s1    acos_poly_p15  =    acos_t,acos_coeff_P16,acos_coeff_P15
     nop.i                      999
} 
{     .mfb 
     nop.m                 999
     fnma.s1   acos_d    =    acos_S0,acos_H0,acos_1by2
(p6) br.cond.spnt  ACOS_ABS_ONE    // Branch to short path if |x|=1
}
;;

 
{     .mfi 
     nop.m                      999
     fma.s1    acos_poly_p19  =    acos_t,acos_coeff_P20,acos_coeff_P19
     nop.i                      999
} 
{     .mfi 
     nop.m                      999
     fma.s1    acos_poly_p4   =    acos_t,acos_coeff_P5,acos_coeff_P4
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                      999
     fma.s1    acos_1poly_p17 =    acos_tx,acos_coeff_P18,acos_coeff_P17
     nop.i                      999
} 
{     .mfi 
     nop.m                      999
     fma.s1    acos_poly_p8   =    acos_t,acos_coeff_P9,acos_coeff_P8
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                      999
     fms.s1    acos_35by8     =    acos_5by2,acos_11by4,acos_5by2
     nop.i                      999
} 
{     .mfi 
     nop.m                      999
     fma.s1    acos_63by8     =    acos_5by2,acos_11by4,f1
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                      999
     fma.s1    acos_poly_p13  =    acos_t,acos_coeff_P14,acos_coeff_P13
     nop.i                      999
} 
{     .mfi 
     nop.m                      999
     fma.s1    acos_18by4     =    acos_3by2,acos_5by2,acos_3by4
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                 999
     fma.s1    acos_l1   =    acos_5by2,acos_d,acos_3by2
     nop.i                 999
} 
{     .mfi 
     nop.m                 999
     fma.s1    acos_d2   =    acos_d,acos_d,f0
     nop.i                 999;;
}

 
{     .mfi 
     nop.m                      999
     fma.s1    acos_poly_p15  =    acos_t2,acos_poly_p17,acos_poly_p15
     nop.i                      999
} 
{     .mfi 
     nop.m                 999
     fma.s1    acos_T0   =    acos_d,acos_S0,f0
     nop.i                 999;;
}

 
{     .mfi 
     nop.m                      999
     fma.s1    acos_poly_p19  =    acos_t2,acos_coeff_P21,acos_poly_p19
     nop.i                      999
} 
{     .mfi 
     nop.m                      999
     fma.s1    acos_poly_p4   =    acos_t2,acos_poly_p6,acos_poly_p4
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                 999
     fma.s1    acos_d1   =    acos_35by8,acos_d,f0
     nop.i                 999
} 
{     .mfi 
     nop.m                      999
     fma.s1    acos_231by16   =    acos_3by2,acos_35by8,acos_63by8
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                      999
     fma.s1    acos_poly_p2   =    acos_t,acos_coeff_P3,acos_coeff_P2
     nop.i                      999
} 
{     .mfi 
     nop.m                      999
     fma.s1    acos_poly_p8   =    acos_t2,acos_coeff_P10,acos_poly_p8
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                      999
     fma.s1    acos_poly_p11  =    acos_t,acos_coeff_P12,acos_coeff_P11
     nop.i                      999
} 
{     .mfi 
     nop.m                 999
     fma.s1    acos_e0   =    acos_d2,acos_l1,acos_d
     nop.i                 999;;
}

 
{     .mfi 
     nop.m                      999
     fma.s1    acos_1poly_p15 =    acos_tx,acos_coeff_P16,acos_coeff_P15
     nop.i                      999
} 
{     .mfi 
     nop.m                      999
     fma.s1    acos_poly_p0   =    acos_t,acos_coeff_P1,f1
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                      999
     fma.s1    acos_1poly_p19 =    acos_tx,acos_coeff_P20,acos_coeff_P19
     nop.i                      999
} 
{     .mfi 
     nop.m                      999
     fma.s1    acos_1poly_p4  =    acos_tx,acos_coeff_P5,acos_coeff_P4
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                      999
     fma.s1    acos_1poly_p8  =    acos_tx,acos_coeff_P9,acos_coeff_P8
     nop.i                      999
} 
{     .mfi 
     nop.m                 999
     fma.s1    acos_l2   =    acos_231by16,acos_d,acos_63by8
     nop.i                 999;;
}

 
{     .mfi 
     nop.m                 999
     fma.s1    acos_d3   =    acos_d2,acos_d,f0
     nop.i                 999
} 
{     .mfi 
     nop.m                 999
     fma.s1    acos_T3   =    acos_d2,acos_T0,f0
     nop.i                 999;;
}

 
{     .mfi 
     nop.m                      999
     fma.s1    acos_429by16   =    acos_18by4,acos_11by4,acos_231by16
     nop.i                      999
} 
{     .mfi 
     nop.m                 999
     fma.s1    acos_S1   =    acos_e0,acos_S0,acos_S0
     nop.i                 999;;
}

 
{     .mfi 
     nop.m                      999
     fma.s1    acos_poly_p4   =    acos_t4,acos_poly_p8,acos_poly_p4
     nop.i                      999
} 
{     .mfi 
     nop.m                      999
     fma.s1    acos_poly_p15  =    acos_t4,acos_poly_p19,acos_poly_p15
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                      999
     fma.s1    acos_poly_p0   =    acos_t2,acos_poly_p2,acos_poly_p0
     nop.i                      999
} 
{     .mfi 
     nop.m                      999
     fma.s1    acos_poly_p11  =    acos_t2,acos_poly_p13,acos_poly_p11
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                 999
     fma.s1    acos_t8   =    acos_t4,acos_t4,f0
     nop.i                 999
} 
{     .mfi 
     nop.m                 999
     fma.s1    acos_e1   =    acos_d2,acos_l2,acos_d1
     nop.i                 999;;
}

 
{     .mfi 
     nop.m                      999
     fma.s1    acos_1poly_p4  =    acos_tx2,acos_1poly_p6,acos_1poly_p4
     nop.i                      999
} 
{     .mfi 
     nop.m                      999
     fma.s1    acos_1poly_p15 =    acos_tx2,acos_1poly_p17,acos_1poly_p15
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                      999
     fma.s1    acos_1poly_p8  =    acos_tx2,acos_coeff_P10,acos_1poly_p8
     nop.i                      999
} 
{     .mfi 
     nop.m                      999
     fma.s1    acos_1poly_p19 =    acos_tx2,acos_coeff_P21,acos_1poly_p19
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                      999
     fma.s1    acos_1poly_p2  =    acos_tx,acos_coeff_P3,acos_coeff_P2
     nop.i                      999
} 
{     .mfi 
     nop.m                      999
     fma.s1    acos_1poly_p13 =    acos_tx,acos_coeff_P14,acos_coeff_P13
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                      999
     fma.s1    acos_1poly_p0  =    acos_tx,acos_coeff_P1,f1
     nop.i                      999
} 
{     .mfi 
     nop.m                      999
     fma.s1    acos_1poly_p11 =    acos_tx,acos_coeff_P12,acos_coeff_P11
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                 999
     fma.s1    acos_l3   =    acos_429by16,acos_d,f0
     nop.i                 999
} 
{     .mfi 
     nop.m                 999
     fma.s1    acos_z    =    acos_e1,acos_T3,acos_S1
     nop.i                 999;;
}

 
{     .mfi 
     nop.m                      999
     fma.s1    acos_poly_p11  =    acos_t4,acos_poly_p15,acos_poly_p11
     nop.i                      999
} 
{     .mfi 
     nop.m                 999
     fma.s1    acos_T6   =    acos_T3,acos_d3,f0
     nop.i                 999;;
}

 
{     .mfi 
     nop.m                 999
     fma.s1    acos_t11  =    acos_t8,acos_t3,f0
     nop.i                 999
} 
{     .mfi 
     nop.m                      999
     fma.s1    acos_poly_p0   =    acos_t4,acos_poly_p4,acos_poly_p0
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                      999
     fma.s1    acos_1poly_p4  =    acos_tx4,acos_1poly_p8,acos_1poly_p4
     nop.i                      999
} 
{     .mfi 
     nop.m                      999
     fma.s1    acos_1poly_p15 =    acos_tx4,acos_1poly_p19,acos_1poly_p15
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                      999
     fma.s1    acos_1poly_p0  =    acos_tx2,acos_1poly_p2,acos_1poly_p0
     nop.i                      999
} 
{     .mfi 
     nop.m                      999
     fma.s1    acos_1poly_p11 =    acos_tx2,acos_1poly_p13,acos_1poly_p11
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                                                         999
//     fcmp.le.s1     acos_pred_LEsqrt2by2,acos_pred_GTsqrt2by2    =    acos_abs_x,acos_const_sqrt2by2
     fcmp.le.s1     p7,p8    =    acos_abs_x,acos_const_sqrt2by2
     nop.i                                                         999
} 
{     .mfi 
     nop.m                 999
     fma.s1    acos_tx8  =    acos_tx4,acos_tx4,f0
     nop.i                 999;;
}

 
{     .mfi 
     nop.m                 999
     fma.s1    acos_z    =    acos_l3,acos_T6,acos_z
     nop.i                 999;;
} 
 
{     .mfi
     nop.m                      999
     fma.s1    acos_series_t  =    acos_t11,acos_poly_p11,acos_poly_p0
     nop.i                      999
}
{    .mfi
     nop.m 999
(p11) fma.s1 acos_const_add = acos_const_piby2, f1, acos_const_piby2
     nop.i 999
}
;;

{ .mfi
      nop.m 999
(p12) fma.s1 acos_const_add = f1,f0,f0
      nop.i 999
}
;;
 
{     .mfi 
     nop.m                      999
     fma.s1    acos_1poly_p0  =    acos_tx4,acos_1poly_p4,acos_1poly_p0
     nop.i                      999
} 
{     .mfi 
     nop.m                      999
     fma.s1    acos_1poly_p11 =    acos_tx4,acos_1poly_p15,acos_1poly_p11
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                 999
     fma.s1    acos_tx11 =    acos_tx8,acos_tx3,f0
     nop.i                 999;;
} 
 
{     .mfi 
                         nop.m                 999
//(acos_pred_GTsqrt2by2)   fnma.s1      answer2   =    acos_z,acos_series_t,acos_const_piby2
(p8)   fnma.s1      answer2   =    acos_z,acos_series_t,f0
                         nop.i                 999;;
} 
 
{     .mfi 
     nop.m                      999
     fma.s1    acos_series_tx =    acos_tx11,acos_1poly_p11,acos_1poly_p0
     nop.i                      999;;
} 
 
{     .mfi 
                         nop.m                 999
//(acos_pred_GTsqrt2by2)   fnma.d     f8   =    acos_sgn_x,answer2,acos_const_piby2
(p8)   fnma.d     f8   =    acos_sgn_x,answer2,acos_const_add
                         nop.i                 999;;
} 
 
{     .mfb 
                         nop.m                 999
//(acos_pred_LEsqrt2by2)   fnma.d     f8   =    f8,acos_series_tx,acos_const_piby2
(p7)   fnma.d     f8   =    f8,acos_series_tx,acos_const_piby2
     br.ret.sptk b0 ;;
} 


ACOS_ZERO:
// Here if x=0
{     .mfb 
      nop.m                 999
      fma.d    f8 =    acos_const_piby2,f1,f0
      br.ret.sptk b0 ;;
} 


.pred.rel "mutex",p11,p12
ACOS_ABS_ONE:
// Here if |x|=1
{     .mfi 
      nop.m                 999
(p11) fma.d    f8 =    acos_const_piby2,f1,acos_const_piby2 // acos(-1)=pi
      nop.i                 999
} 
{     .mfb 
      nop.m                 999
(p12) fma.d    f8 =    f1,f0,f0 // acos(1)=0
      br.ret.sptk b0 ;;
} 


.endp acos

.proc __libm_error_region
__libm_error_region:
.prologue
{ .mfi
        add   GR_Parameter_Y=-32,sp             // Parameter 2 value
                nop.f 999
.save   ar.pfs,GR_SAVE_PFS
        mov  GR_SAVE_PFS=ar.pfs                 // Save ar.pfs
}
{ .mfi
.fframe 64
        add sp=-64,sp                           // Create new stack
        nop.f 0
        mov GR_SAVE_GP=gp                       // Save gp
};;
{ .mmi
        stfs [GR_Parameter_Y] = f1,16         // Store Parameter 2 on stack
        add GR_Parameter_X = 16,sp              // Parameter 1 address
.save   b0, GR_SAVE_B0
        mov GR_SAVE_B0=b0                       // Save b0
};;

.body
        frcpa.s0 f9,p0 = f0,f0
;;

{ .mib
        stfd [GR_Parameter_X] = f8            // Store Parameter 1 on stack
        add   GR_Parameter_RESULT = 0,GR_Parameter_Y
        nop.b 0                                 // Parameter 3 address
}
{ .mib
        stfd [GR_Parameter_Y] = f9,-16           // Store Parameter 3 on stack
        adds r32 = 48,sp
        br.call.sptk b0=__libm_error_support#   // Call error handling function
};;
{ .mmi
        ldfd  f8 = [r32]       // Get return result off stack
.restore
        add   sp = 64,sp                       // Restore stack pointer
        mov   b0 = GR_SAVE_B0                  // Restore return address
};;
{ .mib
        mov   gp = GR_SAVE_GP                  // Restore gp
        mov   ar.pfs = GR_SAVE_PFS             // Restore ar.pfs
        br.ret.sptk     b0                     // Return

};;

.endp __libm_error_region

.type   __libm_error_support,@function
.global __libm_error_support
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\ia64\atan.s ===
.file "atan.s"

// Copyright (c) 2000, 2001, Intel Corporation
// All rights reserved.
// 
// Contributed 2/2/2000 by John Harrison, Ted Kubaska, Bob Norin, Shane Story,
// and Ping Tak Peter Tang of the Computational Software Lab, Intel Corporation.
// 
// WARRANTY DISCLAIMER
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS 
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY 
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
// 
// Intel Corporation is the author of this code, and requests that all
// problem reports or change requests be submitted to it directly at 
// http://developer.intel.com/opensource.
//
// History
//==============================================================
// 2/02/00: Initial version
// 4/13/00: Improved speed
// 4/19/00: Removed the qualifying predicate from the fmerge.s that
//          takes the absolute value.
// 6/16/00: Reassigned FP registers to eliminate stalls on loads
// 8/30/00: Saved 5 cycles in main path by rearranging large argument logic
//          and delaying use of result of fcmp in load by 1 group
//
// API
//==============================================================
// double atan( double x);
//
// Overview of operation
//==============================================================
// atan(x) = sign(X)pi/2 - atan(1/x)
//
// We have two paths: |x| > 1 and |x| <= 1
//
// |x| >  1
// ==========================================
//
// c  = frcpa(x) which is approximately 1/x
//
// xc = 1- B
// B  = 1-xc
//
// Approximate 1/(1-B)^k by a polynomial in B, poly(B)
// k is 45.
//
// poly(B)     = 1 + r1 B + r2 B^2 + ...+ r10 B^10
//
// c^k         = (1-B)^k/x^k
// c^k/(1-B)^k = 1/x^k 
// c^k poly(B) = 1/x^k

// poly(x)     = series(atan(1/x)) = 1/x - 1/3x^3 + 1/5x^5 - 1/7x^7 .... + 1/45 x^45
//                                 = 1/x^45 ( x^44 - x^42/3 + x^40/5 - x^38/7 ... +1)
//                                 = 1/x^45 ( y^22 - y^21/3 + y^20/5 - y^19/7 ... +1)
//        
//                                 = c^45 poly(B) poly(x)
//                                 = c^45 r(B) q(y)

// q(y) = q0 + q1 y + q2 y^2 + ... + q22 y^22
// where q22 is 1.0

// atan(x) = sign(X)pi/2 -  c^45 r(B) q(y)

// |x| <=  1
// ==========================================
// poly(x)    = series(atan(x))   = x - x^3/3 + x^5/5 + .....
// poly(x)    = series(atan(x))   = x  + x^3(- 1/3 + x^2/5 + ..... +x^47/47)
// poly(x)    = series(atan(x))   = x  + x^3(p0 + x^2/5 + ..... + x^44/47)
// poly(x)    = series(atan(x))   = x  + x^3(p0 + y/5 + ..... + y^22/47)
   
// where p0 is about -1/3.

// atan(x) = poly(x)



// Special Values
//==============================================================
// atan(QNAN)  = QNAN
// atan(SNAN)  = quieted SNAN
// atan(+-inf) = +- pi/2     
// atan(+-0)   = +-0



// Registers used
//==============================================================

// predicate registers used: 
// p6 -> p11

// floating-point registers used:  
// f32 -> f127

// general registers used
// r32 -> r37

// Assembly macros
//==============================================================
atan_Pi_by_2                  = f32
atan_S_PI                     = f33
atan_ABS_f8                   = f34

atan_R0                       = f35
atan_R1                       = f36
atan_R2                       = f37
atan_R3                       = f38 
atan_R4                       = f39 
atan_R5                       = f40 
atan_R6                       = f41
atan_R7                       = f42
atan_R8                       = f43 
atan_R9                       = f44 
atan_R10                      = f45 

atan_Q0                       = f46

atan_Q1                       = f47 
atan_Q2                       = f48
atan_Q3                       = f49
atan_Q4                       = f50
atan_Q5                       = f51 
atan_Q6                       = f52 
atan_Q7                       = f53 
atan_Q8                       = f54 
atan_Q9                       = f55 
atan_Q10                      = f56 

atan_Q11                      = f57 
atan_Q12                      = f58
atan_Q13                      = f59
atan_Q14                      = f60
atan_Q15                      = f61 
atan_Q16                      = f62 
atan_Q17                      = f63 
atan_Q18                      = f64 
atan_Q19                      = f65 
atan_Q20                      = f66 
atan_Q21                      = f67 
atan_Q22                      = f68 

// P and Q constants are mutually exclusive 
// so they can share macro definitions
atan_P0                       = f46

atan_P1                       = f47 
atan_P2                       = f48
atan_P3                       = f49
atan_P4                       = f10
atan_P5                       = f11 
atan_P6                       = f12 
atan_P7                       = f13 
atan_P10                      = f103 

atan_P11                      = f114 
atan_P12                      = f58
atan_P13                      = f59
atan_P14                      = f60
atan_P15                      = f61 
atan_P16                      = f62 
atan_P17                      = f63 
atan_P18                      = f64 
atan_P19                      = f65 
atan_P20                      = f14 
atan_P21                      = f99 
atan_P22                      = f68 
// end of P constant macros

atan_C                        = f69
atan_Y                        = f70
atan_B                        = f71
atan_Z                        = f72
atan_V11                      = f73
atan_V12                      = f74

atan_V7                       = f75
atan_V8                       = f76

atan_W13                      = f77
atan_W11                      = f78

atan_V3                       = f79
atan_V4                       = f80

atan_G11                      = f81
atan_G12                      = f82
atan_G7                       = f83
atan_G8                       = f84

atan_Z1                       = f85
atan_W7                       = f86

atan_G3                       = f87
atan_W8                       = f88
atan_V9                       = f89
atan_V10                      = f90

atan_G10                      = f91
atan_W3                       = f92
atan_G4                       = f93
atan_G9                       = f94
                                
atan_G6                       = f95
atan_W4                       = f96
atan_Z2                       = f97
atan_V6                       = f98
                              
atan_V2                       = f99
atan_W6                       = f100
atan_W10                      = f101
atan_Y3                       = f102
                              
atan_G2                       = f103

atan_Y8                       = f104
                              
atan_G5                       = f105
atan_Z3                       = f106
atan_Z4                       = f107
atan_W2                       = f108
atan_V5                       = f109
                            
atan_W5                       = f110
atan_G1                       = f111
atan_Y11                      = f112
                             
atan_Z5                       = f113
atan_Z6                       = f114
atan_V1                       = f115
atan_W1                       = f116
                              
atan_Z7                       = f117
atan_Q                        = f118
atan_Z                        = f119
atan_abs_f8                   = f120                            

atan_V13                      = f121
atan_Xcub                     = f122
atan_Y12                      = f123
atan_P                        = f124

atan_NORM_f8                  = f125

atan_P8                       = f126
atan_P9                       = f127




atan_GR_AD_R                 = r14
atan_GR_AD_Q                 = r15
atan_GR_AD_P                 = r16
atan_GR_10172                = r17 
atan_GR_exp_f8               = r18 
atan_GR_signexp_f8           = r19
atan_GR_exp_mask             = r20




/////////////////////////////////////////////////////////////


.data

.align 16

double_atan_constants_R:
   data8 0xB36B46B9C5443CED, 0x0000401C  //R8
   data8 0x842633E0D126261F, 0x0000401F  //R9
   data8 0xBE04FFFFFFFF46E0, 0x00004010  //R4
   data8 0xE8C62000244D66E2, 0x00004013  //R5
   data8 0xF2790C001E3789B3, 0x00004016  //R6
   data8 0xDCD2CCF97D7C764F, 0x00004019  //R7
   data8 0xB40000000000000B, 0x00004004  //R1
   data8 0xB265F3D38F5EE28F, 0x00004021  //R10
   data8 0x8160000000000001, 0x00004009  //R2
   data8 0xFD5BFFFFFFFE55CD, 0x0000400C  //R3
   data8 0xC90FDAA22168C235, 0x00003FFF  // pi/2 

double_atan_constants_Q:
   data8 0xEBD602FA7761BC33, 0x00003FF9  //Q8
   data8 0x8CB1CABD6A91913C, 0x0000BFFA  //Q9
   data8 0x84C665C37D623CD2, 0x00003FF7  //Q4
   data8 0x8DE0D1673DAEA9BC, 0x0000BFF8  //Q5
   data8 0xF658ADBE2C6E6FCC, 0x00003FF8  //Q6

   data8 0xB56307BE1DD3FFB6, 0x0000BFF9  //Q7
   data8 0xAAAAAAAAAAAA8000, 0x0000BFFD  //Q21
   data8 0x8000000000000000, 0x00003FFF  //Q22
   data8 0x924924923A9D710C, 0x0000BFFC  //Q19
   data8 0xCCCCCCCCCC9380E7, 0x00003FFC  //Q20
 
   data8 0xA644DC250EFA2800, 0x00003FED  //Q0
   data8 0x83DEAE24EEBF5E44, 0x0000BFF1  //Q1
   data8 0xC758CCC64793D4EC, 0x00003FF3  //Q2
   data8 0xBFDC0B54E7C89DCE, 0x0000BFF5  //Q3
   data8 0x888855199D1290AF, 0x0000BFFB  //Q15

   data8 0x9D89D3BE514B0178, 0x00003FFB  //Q16
   data8 0xBA2E8B4DEC70282A, 0x0000BFFB  //Q17
   data8 0xE38E38DF9E9FC83B, 0x00003FFB  //Q18
   data8 0x9F8781CC990029D9, 0x00003FFA  //Q10
   data8 0xB0B39472DEBA3C79, 0x0000BFFA  //Q11

   data8 0xC2AFAEF8C85B0BC6, 0x00003FFA  //Q12
   data8 0xD780E539797525DD, 0x0000BFFA  //Q13
   data8 0xF0EDC449AC786DF9, 0x00003FFA  //Q14



double_atan_constants_P:
   data8 0xB1899EC590CDB8DF, 0x0000BFFA //P10
   data8 0xA1E79850A67D59B0, 0x00003FFA //P11
   data8 0x911D8B30C2A96E6D, 0x0000BFF3 //P20
   data8 0xB87233C68A640706, 0x00003FF0 //P21
   data8 0xD78E4B82F3C29D7A, 0x0000BFFA //P8

   data8 0xC2EBE37AF932C14F, 0x00003FFA //P9
   data8 0xBA2E8B94AA104DD6, 0x0000BFFB //P4
   data8 0x9D89D7A640B71D38, 0x00003FFB //P5
   data8 0x88887CA2CE9B2A40, 0x0000BFFB //P6
   data8 0xF0F017D57A919C1E, 0x00003FFA //P7

   data8 0xD0D635F230C80E06, 0x0000BFF8 //P16
   data8 0xE847BECA7209B479, 0x00003FF7 //P17
   data8 0xD14C6A2AAE0D5B07, 0x0000BFF6 //P18
   data8 0x915F612A5C469117, 0x00003FF5 //P19
   data8 0x921EDE5FD0DBBBE2, 0x0000BFFA //P12

   data8 0xFFD303C2C8535445, 0x00003FF9 //P13
   data8 0xD30DF50E295386F7, 0x0000BFF9 //P14
   data8 0x9E81F2B1BBD210A8, 0x00003FF9 //P15
   data8 0xAAAAAAAAAAAAA800, 0x0000BFFD //P0
   data8 0xCCCCCCCCCCC7D476, 0x00003FFC //P1

   data8 0x9249249247838066, 0x0000BFFC //P2
   data8 0xE38E38E302290D68, 0x00003FFB //P3
   data8 0xDF7F0A816F7E5025, 0x0000BFEC //P22


.align 32
.global atan#

////////////////////////////////////////////////////////



.section .text
.proc  atan#
.align 32

atan: 

{ .mmf
      addl      atan_GR_AD_P   = @ltoff(double_atan_constants_P), gp
      addl      atan_GR_AD_Q   = @ltoff(double_atan_constants_Q), gp
      fmerge.s  atan_ABS_f8  = f0,f8                       
}
;;

{ .mmf
      ld8 atan_GR_AD_P = [atan_GR_AD_P]
      ld8 atan_GR_AD_Q = [atan_GR_AD_Q]
      frcpa.s1     atan_C,p8 = f1,f8                                  
}
;;

{ .mmf
      addl      atan_GR_AD_R   = @ltoff(double_atan_constants_R), gp
      addl      atan_GR_exp_mask = 0x1ffff, r0
      fma.s1       atan_Y = f8,f8,f0                                  
}
;;

// This fnorm takes faults or sets fault flags
{ .mmf
      mov       atan_GR_10172 = 0x10172
      ld8 atan_GR_AD_R = [atan_GR_AD_R]
      fnorm     atan_NORM_f8  = f8
}
;;


// qnan snan inf norm     unorm 0 -+
// 1    1    0   0        0     1 11
// c                      7

// p9 set if we have a NAN or +-0

{ .mmf
      ldfe      atan_Q8  = [atan_GR_AD_Q],16 
      ldfe      atan_P10    = [atan_GR_AD_P],16                   
      fclass.m.unc p9, p0   = f8, 0xc7                         
}
;;


{ .mmi
      ldfe      atan_Q9  = [atan_GR_AD_Q],16 
      ldfe      atan_P11    = [atan_GR_AD_P],16                   
      nop.i 999   
}
;;

        
{ .mmf
      ldfe      atan_Q4      = [atan_GR_AD_Q],16 
      ldfe      atan_P20     = [atan_GR_AD_P],16                   
(p9)  fma.d.s0  f8          = f8,f1,f0
;;
}

// Exit if we have a NAN or +-0
{ .mmb
      ldfe      atan_Q5     = [atan_GR_AD_Q],16 
      ldfe      atan_P21    = [atan_GR_AD_P],16                   
(p9)  br.ret.spnt b0
;;
}


// p6 is TRUE if |x| <= 1
// p7 is TRUE if |x| >  1
{ .mmf
      ldfe      atan_Q6  = [atan_GR_AD_Q],16 
      ldfe      atan_P8  = [atan_GR_AD_P],16                   
      fcmp.le.unc  p6,p7 = atan_ABS_f8, f1 
;;
}


{ .mfi
      ldfe         atan_Q7  = [atan_GR_AD_Q],16 
      fma.s1       atan_Z   = atan_C, atan_C, f0                        
      nop.i 999   
}
{ .mfi
      ldfe         atan_P9  = [atan_GR_AD_P],16                   
      fnma.s1      atan_B   = atan_C,f8, f1                             
      nop.i 999    ;;
}


{ .mfi
      ldfe         atan_Q21  = [atan_GR_AD_Q],16 
      fma.s1       atan_V12  = atan_Y, atan_Y, f0                      
      nop.i 999   
}
{ .mfi
      ldfe         atan_P4    = [atan_GR_AD_P],16                   
      fma.s1       atan_Xcub  = f8, atan_Y  , f0                        
      nop.i 999   
;;
}


{ .mmi
(p7)  ldfe      atan_Q22         = [atan_GR_AD_Q],16 
(p6)  ldfe      atan_P5          = [atan_GR_AD_P],16                   
(p6)  cmp.eq.unc  p8,p0 = r0,r0
;;
}


{ .mmi
(p7)  ldfe      atan_Q19   = [atan_GR_AD_Q],16 
(p6)  ldfe      atan_P6    = [atan_GR_AD_P],16                   
(p7)  cmp.eq.unc  p9,p0 = r0,r0
;;
}


{ .mmi
(p7)  ldfe      atan_Q20  = [atan_GR_AD_Q],16 
(p6)  ldfe      atan_P7    = [atan_GR_AD_P],16                   
      nop.i 999   
;;
}

{ .mfi
(p7)  ldfe      atan_Q0  = [atan_GR_AD_Q],16 
(p6)  fma.s1       atan_V13 = atan_Y, atan_P11, atan_P10              
      nop.i 999   
}
{ .mfi
(p6)  ldfe      atan_P16    = [atan_GR_AD_P],16                   
(p7)  fma.s1       atan_V11 = atan_Y, atan_Q9, atan_Q8                
      nop.i 999    ;;
}


{ .mfi
(p7)  ldfe      atan_Q1  = [atan_GR_AD_Q],16 
(p7)  fma.s1       atan_G12 = atan_B, atan_B, f0                      
      nop.i 999   
}
{ .mfi
(p6)  ldfe      atan_P17    = [atan_GR_AD_P],16                   
      fma.s1       atan_V9  = atan_V12, atan_V12, f0                  
      nop.i 999    ;;
}


{ .mfi
(p7)  ldfe      atan_Q2  = [atan_GR_AD_Q],16 
(p6)  fma.s1       atan_W11 = atan_Y, atan_P21, atan_P20              
      nop.i 999   
}
{ .mfi
(p6)  ldfe      atan_P18    = [atan_GR_AD_P],16                   
(p7)  fma.s1       atan_V7  = atan_Y, atan_Q5, atan_Q4                
      nop.i 999    ;;
}

{ .mfi
(p7)  ldfe      atan_Q3  = [atan_GR_AD_Q],16 
(p7)  fma.s1    atan_Z1  = atan_Z, atan_Z, f0                      
      nop.i 999   
}
{ .mfi
(p6)  ldfe      atan_P19    = [atan_GR_AD_P],16                   
(p7)  fma.s1       atan_Y3  = atan_Y  , atan_V12, f0                  
      nop.i 999    ;;
}

{ .mfi
(p7)  ldfe      atan_R8  = [atan_GR_AD_R],16 
(p6)  fma.s1       atan_V11 = atan_Y, atan_P9, atan_P8                
      nop.i 999   
}
{ .mfi
(p6)  ldfe      atan_P12    = [atan_GR_AD_P],16                   
(p7)  fma.s1       atan_V8  = atan_Y, atan_Q7, atan_Q6                
      nop.i 999    ;;
}

{ .mmi
(p7)  ldfe      atan_R9     = [atan_GR_AD_R],16 
(p6)  ldfe      atan_P13    = [atan_GR_AD_P],16                   
      nop.i 999   
;;
}

{ .mfi
(p7)  ldfe      atan_R4  = [atan_GR_AD_R],16 
(p6)  fma.s1    atan_V7  = atan_Y, atan_P5, atan_P4                 
      nop.i 999   
}
{ .mfi
(p6)  ldfe      atan_P14    = [atan_GR_AD_P],16                   
(p7)  fma.s1       atan_W13 = atan_Y, atan_Q22, atan_Q21              
      nop.i 999    ;;
}


{ .mfi
(p7)  ldfe      atan_R5  = [atan_GR_AD_R],16 
(p6)  fma.s1    atan_Y12 = atan_V9 , atan_V9 , f0                   
      nop.i 999   
}
{ .mfi
(p6)  ldfe      atan_P15    = [atan_GR_AD_P],16                   
(p7)  fma.s1    atan_Y8 = atan_V9 , atan_V9 , f0                   
      nop.i 999    ;;
}


{ .mfi
(p7)  ldfe      atan_R6  = [atan_GR_AD_R],16 
(p6)  fma.s1    atan_V8  = atan_Y, atan_P7, atan_P6                 
      nop.i 999   
}
{ .mfi
(p6)  ldfe      atan_P0     = [atan_GR_AD_P],16                   
(p7)  fma.s1       atan_W11 = atan_Y, atan_Q20, atan_Q19              
      nop.i 999    ;;
}


{ .mfi
(p7)  ldfe      atan_R7  = [atan_GR_AD_R],16 
(p7)  fma.s1    atan_Z2  = atan_Z1 , atan_Z1,  f0                  
      nop.i 999   
}
{ .mfi
(p6)  ldfe      atan_P1     = [atan_GR_AD_P],16                   
(p6)  fma.s1       atan_V10 = atan_V12, atan_V13, atan_V11             
      nop.i 999    ;;
}

{ .mfi
(p7)  ldfe      atan_Q15 = [atan_GR_AD_Q],16 
(p6)  fma.s1    atan_W7  = atan_Y, atan_P17, atan_P16               
      nop.i 999   
}
{ .mfi
(p6)  ldfe      atan_P2     = [atan_GR_AD_P],16                   
(p7)  fma.s1       atan_V3  = atan_Y, atan_Q1 , atan_Q0               
      nop.i 999    ;;
}

{ .mfi
(p7)  ldfe      atan_Q16 = [atan_GR_AD_Q],16 
(p7)  fma.s1    atan_G9  = atan_G12, atan_G12, f0                  
      nop.i 999   
}
{ .mfi
(p6)  ldfe      atan_P3     = [atan_GR_AD_P],16                   
(p7)  fma.s1       atan_V6  = atan_V12, atan_V8,  atan_V7             
      nop.i 999    ;;
}


{ .mfi
(p7)  ldfe      atan_R1     = [atan_GR_AD_R],16 
(p6)  fma.s1       atan_W8  = atan_Y, atan_P19, atan_P18               
      nop.i 999   
}
{ .mfi
(p6)  ldfe      atan_P22    = [atan_GR_AD_P],16                   
(p7)  fma.s1       atan_V4  = atan_Y, atan_Q3 , atan_Q2               
      nop.i 999    ;;
}


{ .mfi
      getf.exp     atan_GR_signexp_f8  = atan_NORM_f8
(p7)  fma.s1       atan_Y11 = atan_Y3 , atan_Y8 , f0                  
      nop.i 999   
}
{ .mfi
(p7)  ldfe      atan_Q17    = [atan_GR_AD_Q],16 
(p6)  fma.s1       atan_V6  = atan_V12, atan_V8,  atan_V7             
      nop.i 999    ;;
}


{ .mfi
(p7)  ldfe      atan_Q18    = [atan_GR_AD_Q],16 
(p6)  fma.s1       atan_W3  = atan_Y, atan_P13, atan_P12               
      nop.i 999   
}
{ .mfi
(p7)  ldfe      atan_R10    = [atan_GR_AD_R],16 
(p7)  fma.s1       atan_G11 = atan_B, atan_R9 , atan_R8               
      nop.i 999    ;;
}


{ .mfi
(p7)  ldfe      atan_Q10    = [atan_GR_AD_Q],16 
(p7)  fma.s1    atan_Z3     = atan_Z1 , atan_Z2 , f0                  
      and       atan_GR_exp_f8 = atan_GR_signexp_f8,atan_GR_exp_mask
}
{ .mfi
(p7)  ldfe      atan_R2     = [atan_GR_AD_R],16 
(p7)  fma.s1       atan_Z4  = atan_Z2 , atan_Z2 , f0                  
      nop.i 999    ;;
}


{ .mfi
(p7)  ldfe      atan_Q11 = [atan_GR_AD_Q],16 
(p6)  fma.s1    atan_W4  = atan_Y, atan_P15, atan_P14               
      nop.i 999
}
{ .mfi
(p7)  ldfe      atan_R3     = [atan_GR_AD_R],16 
(p7)  fma.s1       atan_G7  = atan_B, atan_R5 , atan_R4               
      cmp.le.unc   p11,p0  = atan_GR_10172,atan_GR_exp_f8 
;;
}


{ .mmf
(p9)  ldfe      atan_Q12 = [atan_GR_AD_Q],16 
      ldfe      atan_S_PI     = [atan_GR_AD_R],16 
(p8)  fma.s1       atan_W6  = atan_V12, atan_W8,  atan_W7             
;;
}



{ .mfi
(p9)  ldfe      atan_Q13 = [atan_GR_AD_Q],16 
(p8)  fma.s1       atan_V3  = atan_Y, atan_P1 , atan_P0                
(p11) cmp.ne.and p6,p7 = r0,r0
}
{ .mfi
      nop.m 999
(p8)  fma.s1       atan_V5  = atan_V9 , atan_V10, atan_V6             
      nop.i 999    ;;
}


.pred.rel "mutex",p6,p7,p11
{ .mfi
(p7)  ldfe      atan_Q14 = [atan_GR_AD_Q],16 
(p6)  fma.s1       atan_Y12 = atan_V9 , atan_Y12, f0                   
      nop.i 999    
}
{ .mfi
      nop.m 999
(p7)  fma.s1    atan_G8  = atan_B, atan_R7 , atan_R6               
      nop.i 999    ;;
}


{ .mfi
      nop.m 999
(p6)  fma.s1       atan_V4  = atan_Y, atan_P3 , atan_P2                
      nop.i 999    
}
{ .mfi
      nop.m 999
(p7)  fma.s1       atan_W7  = atan_Y, atan_Q16, atan_Q15              
      nop.i 999    ;;
}


{ .mfi
      nop.m 999
(p6)  fma.s1       atan_W10 = atan_V12, atan_P22, atan_W11            
      nop.i 999    
}
{ .mfi
      nop.m 999
(p7)  fma.s1       atan_G3  = atan_B, atan_R1 , f1                    
      nop.i 999    ;;
}


{ .mfi
      nop.m 999
(p6)  fma.s1    atan_W2  = atan_V12, atan_W4 , atan_W3             
      nop.i 999    
}
{ .mfi
      nop.m 999
(p7)  fma.s1       atan_V2  = atan_V12, atan_V4 , atan_V3              
      nop.i 999    ;;
}

{ .mfi
      nop.m 999
(p7)  fma.s1       atan_W8  = atan_Y, atan_Q18, atan_Q17              
      nop.i 999   
}
{ .mfi
      nop.m 999
(p7)  fma.s1       atan_G10 = atan_G12, atan_R10, atan_G11            
      nop.i 999    ;;
}

{ .mfi
      nop.m 999
(p7)  fma.s1       atan_V10 = atan_V12, atan_Q10, atan_V11            
      nop.i 999    
}
{ .mfi
      nop.m 999
(p7)  fma.s1       atan_G6  = atan_G12, atan_G8 , atan_G7             
      nop.i 999    ;;
}


{ .mfi
      nop.m 999
(p6)  fma.s1       atan_V2  = atan_V12, atan_V4,  atan_V3             
      nop.i 999    
}
{ .mfi
      nop.m 999
(p7)  fma.s1       atan_G4  = atan_B  , atan_R3 , atan_R2             
      nop.i 999    ;;
}


{ .mfi
      nop.m 999
(p6)  fma.s1       atan_W5  = atan_V9 , atan_W10, atan_W6             
      nop.i 999    
}
{ .mfi
      nop.m 999
(p7)  fma.s1       atan_W3  = atan_Y  , atan_Q12, atan_Q11            
      nop.i 999    ;;
}


{ .mfi
      nop.m 999
(p7)  fma.s1       atan_Z5  = atan_Z3 , atan_Z4 , f0                  
      nop.i 999    
}
{ .mfi
      nop.m 999
(p7)  fma.s1       atan_W10 = atan_V12, atan_W13, atan_W11            
      nop.i 999    ;;
}


{ .mfi
      nop.m 999
(p7)  fma.s1       atan_W4  = atan_Y  , atan_Q14, atan_Q13            
      nop.i 999    
}
{ .mfi
      nop.m 999
(p7)  fma.s1       atan_W6  = atan_V12, atan_W8,  atan_W7             
      nop.i 999    ;;
}

{ .mfi
      nop.m 999
(p7)  fma.s1       atan_V5  = atan_V9 , atan_V10, atan_V6             
      nop.i 999    
}
{ .mfi
      nop.m 999
(p7)  fma.s1       atan_G5  = atan_G9 , atan_G10, atan_G6             
      nop.i 999    ;;
}


{ .mfi
      nop.m 999
(p6)  fma.s1       atan_V1  = atan_V9 , atan_V5 , atan_V2             
      nop.i 999    
}
{ .mfi
      nop.m 999
(p7)  fma.s1       atan_G2  = atan_G12, atan_G4 , atan_G3             
      nop.i 999    ;;
}


{ .mfi
      nop.m 999
(p6)  fma.s1       atan_W1  = atan_V9 , atan_W5 , atan_W2             
      nop.i 999    
}
{ .mfi
      nop.m 999
(p7)  fma.s1       atan_Z6  = atan_Z4 , atan_C  , f0                  
      nop.i 999    ;;
}

{ .mfi
      nop.m 999
      fmerge.s    atan_S_PI = f8, atan_S_PI
      nop.i 999     ;;
}


{ .mfi
      nop.m 999
(p7)  fma.s1       atan_W5  = atan_V9 , atan_W10, atan_W6             
      nop.i 999    
}
{ .mfi
      nop.m 999
(p7)  fma.s1       atan_W2  = atan_V12, atan_W4 , atan_W3             
      nop.i 999    ;;
}


{ .mfi
      nop.m 999
(p7)  fma.s1       atan_G1  = atan_G9 , atan_G5 , atan_G2             
      nop.i 999    
}
{ .mfi
      nop.m 999
(p7)  fma.s1       atan_V1  = atan_V9 , atan_V5 , atan_V2             
      nop.i 999    ;;
}


{ .mfi
      nop.m 999
(p6)  fma.s1       atan_P   = atan_Y12, atan_W1 , atan_V1              
      nop.i 999    
}
{ .mfi
      nop.m 999
(p7)  fma.s1       atan_Z7  = atan_Z5 , atan_Z6 , f0                  
      nop.i 999    ;;
}


{ .mfi
      nop.m 999
(p7)  fma.s1       atan_W1  = atan_V9 , atan_W5 , atan_W2             
      nop.i 999    ;;
}


{ .mfi
      nop.m 999
(p11) fma.d.s0  f8 = atan_S_PI,f1,f0
      nop.i 999
}
{ .mfi
      nop.m 999
(p7)  fma.s1       atan_Z   = atan_G1 , atan_Z7 , f0                  
      nop.i 999    ;;
}


{ .mfi
      nop.m 999
(p7)  fma.s1       atan_Q   = atan_Y11, atan_W1 , atan_V1             
      nop.i 999    ;;
}


{ .mfi
      nop.m 999
(p6)  fma.d.s0    f8       = atan_P  , atan_Xcub  , f8               
      nop.i 999    
}
{ .mfb
      nop.m 999
(p7)  fnma.d.s0    f8       = atan_Z  , atan_Q  , atan_S_PI           
      br.ret.sptk    b0    ;;
}

.endp atan
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\ia64\asin.s ===
.file "asin.s"

// Copyright (c) 2000, 2001, Intel Corporation
// All rights reserved.
//
// Contributed 2/2/2000 by John Harrison, Ted Kubaska, Bob Norin, Shane Story,
// and Ping Tak Peter Tang of the Computational Software Lab, Intel Corporation.
//
// WARRANTY DISCLAIMER
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// Intel Corporation is the author of this code, and requests that all
// problem reports or change requests be submitted to it directly at
// http://developer.intel.com/opensource.

// History
//==============================================================
// 2/02/00  Initial version 
// 8/17/00  New and much faster algorithm.
// 8/31/00  Avoided bank conflicts on loads, shortened |x|=1 path, 
//          fixed mfb split issue stalls.
// 12/19/00 Fixed small arg cases to force inexact, or inexact and underflow.

// Description
//=========================================
// The asin function computes the principle value of the arc sine of x.
// asin(0) returns 0, asin(1) returns pi/2, asin(-1) returns -pi/2.
// A doman error occurs for arguments not in the range [-1,+1].

// The asin function returns the arc sine in the range [-pi/2, +pi/2] radians.

//
// Assembly macros
//=========================================


// predicate registers
//asin_pred_LEsqrt2by2            = p7
//asin_pred_GTsqrt2by2            = p8

// integer registers
ASIN_Addr1                      = r33
ASIN_Addr2                      = r34
ASIN_FFFE                       = r35
ASIN_lnorm_sig                  = r36
ASIN_snorm_exp                  = r37

GR_SAVE_B0                      = r36
GR_SAVE_PFS                     = r37
GR_SAVE_GP                      = r38

GR_Parameter_X                  = r39
GR_Parameter_Y                  = r40
GR_Parameter_RESULT             = r41
GR_Parameter_Tag                = r42

// floating point registers
asin_coeff_P1                   = f32
asin_coeff_P2                   = f33
asin_coeff_P3                   = f34
asin_coeff_P4                   = f35

asin_coeff_P5                   = f36
asin_coeff_P6                   = f37
asin_coeff_P7                   = f38
asin_coeff_P8                   = f39
asin_coeff_P9                   = f40

asin_coeff_P10                  = f41
asin_coeff_P11                  = f42
asin_coeff_P12                  = f43
asin_coeff_P13                  = f44
asin_coeff_P14                  = f45

asin_coeff_P15                  = f46
asin_coeff_P16                  = f47
asin_coeff_P17                  = f48
asin_coeff_P18                  = f49
asin_coeff_P19                  = f50

asin_coeff_P20                  = f51
asin_coeff_P21                  = f52
asin_const_sqrt2by2             = f53
asin_const_piby2                = f54
asin_abs_x                      = f55

asin_tx                         = f56
asin_tx2                        = f57
asin_tx3                        = f58
asin_tx4                        = f59
asin_tx8                        = f60

asin_tx11                       = f61
asin_1poly_p8                   = f62
asin_1poly_p19                  = f63
asin_1poly_p4                   = f64
asin_1poly_p15                  = f65

asin_1poly_p6                   = f66
asin_1poly_p17                  = f67
asin_1poly_p0                   = f68
asin_1poly_p11                  = f69
asin_1poly_p2                   = f70

asin_1poly_p13                  = f71
asin_series_tx                  = f72
asin_t                          = f73
asin_t2                         = f74
asin_t3                         = f75

asin_t4                         = f76
asin_t8                         = f77
asin_t11                        = f78
asin_poly_p8                    = f79
asin_poly_p19                   = f80

asin_poly_p4                    = f81
asin_poly_p15                   = f82
asin_poly_p6                    = f83
asin_poly_p17                   = f84
asin_poly_p0                    = f85

asin_poly_p11                   = f86
asin_poly_p2                    = f87
asin_poly_p13                   = f88
asin_series_t                   = f89
asin_1by2                       = f90

asin_3by2                       = f91
asin_5by2                       = f92
asin_11by4                      = f93
asin_35by8                      = f94
asin_63by8                      = f95

asin_231by16                    = f96 
asin_y0                         = f97 
asin_H0                         = f98 
asin_S0                         = f99 
asin_d                          = f100

asin_l1                         = f101
asin_d2                         = f102
asin_T0                         = f103
asin_d1                         = f104
asin_e0                         = f105

asin_l2                         = f106
asin_d3                         = f107
asin_T3                         = f108
asin_S1                         = f109
asin_e1                         = f110

asin_z                          = f111
answer2                         = f112
asin_sgn_x                      = f113
asin_429by16                    = f114
asin_18by4                      = f115

asin_3by4                       = f116
asin_l3                         = f117
asin_T6                         = f118
asin_eps_exp                    = f119
asin_eps_sig                    = f120
asin_eps                        = f120

// Data tables
//==============================================================

.data

.align 16

asin_coeff_1_table:
data8 0xE4E7E0A423A21249  , 0x00003FF8 //P7
data8 0xC2F7EE0200FCE2A5  , 0x0000C003 //P18
data8 0xB745D7F6C65C20E0  , 0x00003FF9 //P5
data8 0xF75E381A323D4D94  , 0x0000C002 //P16
data8 0x8959C2629C1024C0  , 0x0000C002 //P20
data8 0xAFF68E7D241292C5  , 0x00003FF8 //P9
data8 0xB6DB6DB7260AC30D  , 0x00003FFA //P3
data8 0xD0417CE2B41CB7BF  , 0x0000C000 //P14
data8 0x81D570FEA724E3E4  , 0x0000BFFD //P12
data8 0xAAAAAAAAAAAAC277  , 0x00003FFC //P1
data8 0xF534912FF3E7B76F  , 0x00003FFF //P21
data8 0xc90fdaa22168c235  , 0x00003fff // pi/2
data8 0x0000000000000000  , 0x00000000 // pad to avoid data bank conflict


asin_coeff_2_table:
data8 0x8E26AF5F29B39A2A  , 0x00003FF9 //P6
data8 0xB4F118A4B1015470  , 0x00004003 //P17
data8 0xF8E38E10C25990E0  , 0x00003FF9 //P4
data8 0x80F50489AEF1CAC6  , 0x00004002 //P15
data8 0x92728015172CFE1C  , 0x00004003 //P19
data8 0xBBC3D831D4595971  , 0x00003FF8 //P8
data8 0x999999999952A5C3  , 0x00003FFB //P2
data8 0x855576BE6F0975EC  , 0x00003FFF //P13
data8 0xF12420E778077D89  , 0x00003FFA //P11
data8 0xB6590FF4D23DE003  , 0x00003FF3 //P10
data8 0xb504f333f9de6484  , 0x00003ffe // sqrt(2)/2



.align 32
.global asin

.section .text
.proc  asin
.align 32


asin:
 
{     .mfi 
     alloc      r32               = ar.pfs,1,6,4,0
     fma.s1    asin_tx        =    f8,f8,f0
     addl      ASIN_Addr2     =    @ltoff(asin_coeff_2_table),gp
} 
{     .mfi 
     mov       ASIN_FFFE      =    0xFFFE
     fnma.s1   asin_t         =    f8,f8,f1
     addl      ASIN_Addr1     =    @ltoff(asin_coeff_1_table),gp
}
;;

 
{     .mfi 
     setf.exp       asin_1by2      =    ASIN_FFFE
     fmerge.s       asin_abs_x     =    f1,f8
     nop.i          999              ;;
} 
 
{     .mmf 
     ld8       ASIN_Addr1     =    [ASIN_Addr1]
     ld8       ASIN_Addr2     =    [ASIN_Addr2]
     fmerge.s  asin_sgn_x     =    f8,f1 ;;
} 

 
{     .mfi 
     ldfe      asin_coeff_P7  =    [ASIN_Addr1],16
     fma.s1    asin_tx2       =    asin_tx,asin_tx,f0
     nop.i                      999
} 
{     .mfi 
     ldfe      asin_coeff_P6  =    [ASIN_Addr2],16
     fma.s1    asin_t2        =    asin_t,asin_t,f0
     nop.i                      999;;
}

 
{     .mmf 
     ldfe      asin_coeff_P18 =    [ASIN_Addr1],16
     ldfe      asin_coeff_P17 =    [ASIN_Addr2],16
     fclass.m.unc p8,p0  = f8, 0xc3	//@qnan |@snan
} 
;;
 
{     .mmf 
     ldfe           asin_coeff_P5  =    [ASIN_Addr1],16
     ldfe      asin_coeff_P4  =    [ASIN_Addr2],16
     frsqrta.s1     asin_y0,p0     =    asin_t
} 
;;
 
{     .mfi 
     ldfe      asin_coeff_P16 =    [ASIN_Addr1],16
     fcmp.gt.s1 p9,p0 = asin_abs_x,f1
     nop.i                      999
} 
{     .mfb 
     ldfe      asin_coeff_P15 =    [ASIN_Addr2],16
(p8) fma.d     f8 = f8,f1,f0
(p8) br.ret.spnt b0
}
;;

 
{     .mmf 
     ldfe      asin_coeff_P20 =    [ASIN_Addr1],16
     ldfe      asin_coeff_P19 =    [ASIN_Addr2],16
     fclass.m.unc p8,p0 = f8, 0x07	//@zero
} 
;;
 

{     .mfi 
     ldfe      asin_coeff_P9  =    [ASIN_Addr1],16
     fma.s1    asin_t4        =    asin_t2,asin_t2,f0
(p9) mov GR_Parameter_Tag = 61 
} 
{     .mfi 
     ldfe      asin_coeff_P8  =    [ASIN_Addr2],16
     fma.s1    asin_3by2      =    asin_1by2,f1,f1
     nop.i                      999;;
}

 
{     .mfi 
     ldfe      asin_coeff_P2  =    [ASIN_Addr2],16
     fma.s1    asin_tx4       =    asin_tx2,asin_tx2,f0
     nop.i                      999
} 
{     .mfb 
     ldfe      asin_coeff_P3  =    [ASIN_Addr1],16
     fma.s1    asin_t3        =    asin_t,asin_t2,f0
(p8) br.ret.spnt b0
}
;;

 
{     .mfi 
     ldfe      asin_coeff_P13 =    [ASIN_Addr2],16
     fma.s1    asin_H0        =    asin_y0,asin_1by2,f0
     nop.i                      999
} 
{     .mfb 
     ldfe      asin_coeff_P14 =    [ASIN_Addr1],16
     fma.s1    asin_S0        =    asin_y0,asin_t,f0
(p9) br.cond.spnt  __libm_error_region
}
;;

 
{     .mfi 
     ldfe      asin_coeff_P11 =    [ASIN_Addr2],16
     fcmp.eq.s1 p6,p0 = asin_abs_x,f1
     nop.i                      999
} 
{     .mfi 
     ldfe      asin_coeff_P12 =    [ASIN_Addr1],16
     fma.s1    asin_tx3       =    asin_tx,asin_tx2,f0
     nop.i                      999;;
}

 
{     .mfi 
     ldfe      asin_coeff_P10 =    [ASIN_Addr2],16
     fma.s1    asin_1poly_p6  =    asin_tx,asin_coeff_P7,asin_coeff_P6
     nop.i                      999
} 
{     .mfi 
     ldfe      asin_coeff_P1  =    [ASIN_Addr1],16
     fma.s1    asin_poly_p6   =    asin_t,asin_coeff_P7,asin_coeff_P6
     nop.i                      999;;
}

 
{     .mfi 
     ldfe      asin_const_sqrt2by2 =    [ASIN_Addr2],16
     fma.s1    asin_5by2           =    asin_3by2,f1,f1
     nop.i                           999
} 
{     .mfi 
     ldfe      asin_coeff_P21 =    [ASIN_Addr1],16
     fma.s1    asin_11by4     =    asin_3by2,asin_3by2,asin_1by2
     nop.i                      999;;
}

 
{     .mfi 
     ldfe      asin_const_piby2    =    [ASIN_Addr1],16
     fma.s1    asin_poly_p17       =    asin_t,asin_coeff_P18,asin_coeff_P17
     nop.i                           999
} 
{     .mfb 
     nop.m                 999
     fma.s1    asin_3by4 =    asin_3by2,asin_1by2,f0
(p6) br.cond.spnt  ASIN_ABS_1      // Branch to short exit if |x|=1
}
;;

 
{     .mfi 
     addl ASIN_lnorm_sig = -0x1,r0  // Form significand 0xffffffffffffffff
     fma.s1    asin_poly_p15  =    asin_t,asin_coeff_P16,asin_coeff_P15
     nop.i                      999
} 
{     .mfi 
     addl ASIN_snorm_exp = 0x0c001,r0  // Form small exponent
     fnma.s1   asin_d    =    asin_S0,asin_H0,asin_1by2
     nop.i                 999;;
}

 
// Form the exponent and significand of a small number
{     .mfi 
     setf.sig asin_eps_sig = ASIN_lnorm_sig
     fma.s1    asin_poly_p19  =    asin_t,asin_coeff_P20,asin_coeff_P19
     nop.i                      999
} 
{     .mfi 
     setf.exp asin_eps_exp = ASIN_snorm_exp
     fma.s1    asin_poly_p4   =    asin_t,asin_coeff_P5,asin_coeff_P4
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                      999
     fma.s1    asin_1poly_p17 =    asin_tx,asin_coeff_P18,asin_coeff_P17
     nop.i                      999
} 
{     .mfi 
     nop.m                      999
     fma.s1    asin_poly_p8   =    asin_t,asin_coeff_P9,asin_coeff_P8
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                      999
     fms.s1    asin_35by8     =    asin_5by2,asin_11by4,asin_5by2
     nop.i                      999
} 
{     .mfi 
     nop.m                      999
     fma.s1    asin_63by8     =    asin_5by2,asin_11by4,f1
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                      999
     fma.s1    asin_poly_p13  =    asin_t,asin_coeff_P14,asin_coeff_P13
     nop.i                      999
} 
{     .mfi 
     nop.m                      999
     fma.s1    asin_18by4     =    asin_3by2,asin_5by2,asin_3by4
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                 999
     fma.s1    asin_l1   =    asin_5by2,asin_d,asin_3by2
     nop.i                 999
} 
{     .mfi 
     nop.m                 999
     fma.s1    asin_d2   =    asin_d,asin_d,f0
     nop.i                 999;;
}

 
{     .mfi 
     nop.m                      999
     fma.s1    asin_poly_p15  =    asin_t2,asin_poly_p17,asin_poly_p15
     nop.i                      999
} 
{     .mfi 
     nop.m                 999
     fma.s1    asin_T0   =    asin_d,asin_S0,f0
     nop.i                 999;;
}

 
{     .mfi 
     nop.m                      999
     fma.s1    asin_poly_p19  =    asin_t2,asin_coeff_P21,asin_poly_p19
     nop.i                      999
} 
{     .mfi 
     nop.m                      999
     fma.s1    asin_poly_p4   =    asin_t2,asin_poly_p6,asin_poly_p4
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                 999
     fma.s1    asin_d1   =    asin_35by8,asin_d,f0
     nop.i                 999
} 
{     .mfi 
     nop.m                      999
     fma.s1    asin_231by16   =    asin_3by2,asin_35by8,asin_63by8
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                      999
     fma.s1    asin_poly_p2   =    asin_t,asin_coeff_P3,asin_coeff_P2
     nop.i                      999
} 
{     .mfi 
     nop.m                      999
     fma.s1    asin_poly_p8   =    asin_t2,asin_coeff_P10,asin_poly_p8
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                      999
     fma.s1    asin_poly_p11  =    asin_t,asin_coeff_P12,asin_coeff_P11
     nop.i                      999
} 
{     .mfi 
     nop.m                 999
     fma.s1    asin_e0   =    asin_d2,asin_l1,asin_d
     nop.i                 999;;
}

 
{     .mfi 
     nop.m                      999
     fma.s1    asin_1poly_p15 =    asin_tx,asin_coeff_P16,asin_coeff_P15
     nop.i                      999
} 
{     .mfi 
     nop.m                      999
     fma.s1    asin_poly_p0   =    asin_t,asin_coeff_P1,f1
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                      999
     fma.s1    asin_1poly_p19 =    asin_tx,asin_coeff_P20,asin_coeff_P19
     nop.i                      999
} 
{     .mfi 
     nop.m                      999
     fma.s1    asin_1poly_p4  =    asin_tx,asin_coeff_P5,asin_coeff_P4
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                      999
     fma.s1    asin_1poly_p8  =    asin_tx,asin_coeff_P9,asin_coeff_P8
     nop.i                      999
} 
{     .mfi 
     nop.m                 999
     fma.s1    asin_l2   =    asin_231by16,asin_d,asin_63by8
     nop.i                 999;;
}

 
{     .mfi 
     nop.m                 999
     fma.s1    asin_d3   =    asin_d2,asin_d,f0
     nop.i                 999
} 
{     .mfi 
     nop.m                 999
     fma.s1    asin_T3   =    asin_d2,asin_T0,f0
     nop.i                 999;;
}

 
{     .mfi 
     nop.m                      999
     fma.s1    asin_429by16   =    asin_18by4,asin_11by4,asin_231by16
     nop.i                      999
} 
{     .mfi 
     nop.m                 999
     fma.s1    asin_S1   =    asin_e0,asin_S0,asin_S0
     nop.i                 999;;
}

 
{     .mfi 
     nop.m                      999
     fma.s1    asin_poly_p4   =    asin_t4,asin_poly_p8,asin_poly_p4
     nop.i                      999
} 
{     .mfi 
     nop.m                      999
     fma.s1    asin_poly_p15  =    asin_t4,asin_poly_p19,asin_poly_p15
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                      999
     fma.s1    asin_poly_p0   =    asin_t2,asin_poly_p2,asin_poly_p0
     nop.i                      999
} 
{     .mfi 
     nop.m                      999
     fma.s1    asin_poly_p11  =    asin_t2,asin_poly_p13,asin_poly_p11
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                 999
     fma.s1    asin_t8   =    asin_t4,asin_t4,f0
     nop.i                 999
} 
{     .mfi 
     nop.m                 999
     fma.s1    asin_e1   =    asin_d2,asin_l2,asin_d1
     nop.i                 999;;
}

 
{     .mfi 
     nop.m                      999
     fma.s1    asin_1poly_p4  =    asin_tx2,asin_1poly_p6,asin_1poly_p4
     nop.i                      999
} 
{     .mfi 
     nop.m                      999
     fma.s1    asin_1poly_p15 =    asin_tx2,asin_1poly_p17,asin_1poly_p15
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                      999
     fma.s1    asin_1poly_p8  =    asin_tx2,asin_coeff_P10,asin_1poly_p8
     nop.i                      999
} 
{     .mfi 
     nop.m                      999
     fma.s1    asin_1poly_p19 =    asin_tx2,asin_coeff_P21,asin_1poly_p19
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                      999
     fma.s1    asin_1poly_p2  =    asin_tx,asin_coeff_P3,asin_coeff_P2
     nop.i                      999
} 
{     .mfi 
     nop.m                      999
     fma.s1    asin_1poly_p13 =    asin_tx,asin_coeff_P14,asin_coeff_P13
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                      999
     fma.s1    asin_1poly_p0  =    asin_tx,asin_coeff_P1,f1
     nop.i                      999
} 
{     .mfi 
     nop.m                      999
     fma.s1    asin_1poly_p11 =    asin_tx,asin_coeff_P12,asin_coeff_P11
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                 999
     fma.s1    asin_l3   =    asin_429by16,asin_d,f0
     nop.i                 999
} 
{     .mfi 
     nop.m                 999
     fma.s1    asin_z    =    asin_e1,asin_T3,asin_S1
     nop.i                 999;;
}

 
{     .mfi 
     nop.m                      999
     fma.s1    asin_poly_p11  =    asin_t4,asin_poly_p15,asin_poly_p11
     nop.i                      999
} 
{     .mfi 
     nop.m                 999
     fma.s1    asin_T6   =    asin_T3,asin_d3,f0
     nop.i                 999;;
}

 
{     .mfi 
     nop.m                 999
     fma.s1    asin_t11  =    asin_t8,asin_t3,f0
     nop.i                 999
} 
{     .mfi 
     nop.m                      999
     fma.s1    asin_poly_p0   =    asin_t4,asin_poly_p4,asin_poly_p0
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                      999
     fma.s1    asin_1poly_p4  =    asin_tx4,asin_1poly_p8,asin_1poly_p4
     nop.i                      999
} 
{     .mfi 
     nop.m                      999
     fma.s1    asin_1poly_p15 =    asin_tx4,asin_1poly_p19,asin_1poly_p15
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                      999
     fma.s1    asin_1poly_p0  =    asin_tx2,asin_1poly_p2,asin_1poly_p0
     nop.i                      999
} 
{     .mfi 
     nop.m                      999
     fma.s1    asin_1poly_p11 =    asin_tx2,asin_1poly_p13,asin_1poly_p11
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                                                         999
//     fcmp.le.s1     asin_pred_LEsqrt2by2,asin_pred_GTsqrt2by2    =    asin_abs_x,asin_const_sqrt2by2
     fcmp.le.s1     p7,p8    =    asin_abs_x,asin_const_sqrt2by2
     nop.i                                                         999
} 
{     .mfi 
     nop.m                 999
     fma.s1    asin_tx8  =    asin_tx4,asin_tx4,f0
     nop.i                 999;;
}

 
// Form a small number to force inexact flag for small args 
{     .mfi 
     nop.m                 999
     fmerge.se asin_eps = asin_eps_exp,asin_eps_sig
     nop.i                 999
} 
{     .mfi 
     nop.m                 999
     fma.s1    asin_z    =    asin_l3,asin_T6,asin_z
     nop.i                 999;;
} 
 
{     .mfi 
     nop.m                      999
     fma.s1    asin_series_t  =    asin_t11,asin_poly_p11,asin_poly_p0
     nop.i                      999;;
} 
 
{     .mfi 
     nop.m                      999
     fma.s1    asin_1poly_p0  =    asin_tx4,asin_1poly_p4,asin_1poly_p0
     nop.i                      999
} 
{     .mfi 
     nop.m                      999
     fma.s1    asin_1poly_p11 =    asin_tx4,asin_1poly_p15,asin_1poly_p11
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                 999
     fma.s1    asin_tx11 =    asin_tx8,asin_tx3,f0
     nop.i                 999;;
} 
 
{     .mfi 
                         nop.m                 999
//(asin_pred_GTsqrt2by2)   fnma.s1      answer2   =    asin_z,asin_series_t,asin_const_piby2
(p8)   fnma.s1      answer2   =    asin_z,asin_series_t,asin_const_piby2
                         nop.i                 999;;
} 
 
{     .mfi 
     nop.m                      999
     fma.s1    asin_series_tx =    asin_tx11,asin_1poly_p11,asin_1poly_p0
     nop.i                      999;;
} 
 
{     .mfi 
                         nop.m                 999
//(asin_pred_GTsqrt2by2)   fma.d     f8   =    asin_sgn_x,answer2,f0
(p8)   fma.d     f8   =    asin_sgn_x,answer2,f0
                         nop.i                 999;;
} 
 
// asin_eps is added only to force inexact and possibly underflow flag 
// in case asin_series_tx is zero
//
{     .mfi 
                         nop.m                 999
(p7)   fma.d     asin_eps   =    f8,asin_series_tx,asin_eps
                         nop.i                 999
} 
{     .mfb 
                         nop.m                 999
//(asin_pred_LEsqrt2by2)   fma.d     f8   =    f8,asin_series_tx,f0
(p7)   fma.d     f8   =    f8,asin_series_tx,f0
       br.ret.sptk b0
} 
;;


ASIN_ABS_1:
// Here for short exit if |x|=1
{     .mfb 
     nop.m                      999
     fma.d    f8 =    asin_sgn_x,asin_const_piby2,f0
     br.ret.sptk b0
} 
;;


.endp asin

.proc __libm_error_region
__libm_error_region:
.prologue
{ .mfi
        add   GR_Parameter_Y=-32,sp             // Parameter 2 value
                nop.f 999
.save   ar.pfs,GR_SAVE_PFS
        mov  GR_SAVE_PFS=ar.pfs                 // Save ar.pfs
}
{ .mfi
.fframe 64
        add sp=-64,sp                           // Create new stack
        nop.f 0
        mov GR_SAVE_GP=gp                       // Save gp
};;
{ .mmi
        stfs [GR_Parameter_Y] = f1,16         // Store Parameter 2 on stack
        add GR_Parameter_X = 16,sp              // Parameter 1 address
.save   b0, GR_SAVE_B0
        mov GR_SAVE_B0=b0                       // Save b0
};;

.body
        frcpa.s0 f9,p0 = f0,f0
;;

{ .mib
        stfd [GR_Parameter_X] = f8            // Store Parameter 1 on stack
        add   GR_Parameter_RESULT = 0,GR_Parameter_Y
        nop.b 0                                 // Parameter 3 address
}
{ .mib
        stfd [GR_Parameter_Y] = f9,-16           // Store Parameter 3 on stack
        adds r32 = 48,sp
        br.call.sptk b0=__libm_error_support#   // Call error handling function
};;
{ .mmi
        ldfd  f8 = [r32]       // Get return result off stack
.restore
        add   sp = 64,sp                       // Restore stack pointer
        mov   b0 = GR_SAVE_B0                  // Restore return address
};;
{ .mib
        mov   gp = GR_SAVE_GP                  // Restore gp
        mov   ar.pfs = GR_SAVE_PFS             // Restore ar.pfs
        br.ret.sptk     b0                     // Return

};;

.endp __libm_error_region

.type   __libm_error_support,@function
.global __libm_error_support
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\ia64\atan2.s ===
.file "atan2.s"

// Copyright (c) 2000, 2001, Intel Corporation
// All rights reserved.
// 
// Contributed 2/2/2000 by John Harrison, Ted Kubaska, Bob Norin, Shane Story,
// and Ping Tak Peter Tang of the Computational Software Lab, Intel Corporation.
// 
// WARRANTY DISCLAIMER
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS 
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY 
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
// 
// Intel Corporation is the author of this code, and requests that all
// problem reports or change requests be submitted to it directly at 
// http://developer.intel.com/opensource.
//
// History
//==============================================================
// 2/02/00  Initial version
// 4/04/00  Unwind support added
// 8/15/00  Bundle added after call to __libm_error_support to properly
//          set [the previously overwritten] GR_Parameter_RESULT.
// 8/17/00  Changed predicate register macro-usage to direct predicate
//          names due to an assembler bug.
// 9/28/00  Updated to set invalid on SNaN inputs
// 1/19/01  Fixed flags for small results
// 4/13/01  Rescheduled to make all paths faster
//
// API
//==============================================================
// double atan2(double Y, double X)
//
// Overview of operation
//==============================================================
//
// There are two basic paths: swap true and swap false.
// atan2(Y,X) ==> atan2(V/U) where U >= V. If Y > X, we must swap.
//
// p6  swap True    |Y| > |X| 
// p7  swap False   |Y| <= |X|
// p8  X+   (If swap=True p8=p9=0)
// p9  X-
//
// all the other predicates p10 thru p15 are false for the main path
//
// Simple trigonometric identities show
//   Region 1 (-45 to +45 degrees):  
//         X>0, |Y|<=X, V=Y, U=X     atan2(Y,X) = sgnY * (0 + atan(V/U))
//
//   Region 2 (-90 to -45 degrees, and +45 to +90 degrees):  
//         X>0, |Y|>X, V=X, U=Y      atan2(Y,X) = sgnY * (pi/2 - atan(V/U))
//
//   Region 3 (-135 to -90 degrees, and +90 to +135 degrees):  
//         X<0, |Y|>X, V=X, U=Y      atan2(Y,X) = sgnY * (pi/2 + atan(V/U))
//
//   Region 4 (-180 to -135 degrees, and +135 to +180 degrees):  
//         X<0, |Y|<=X, V=Y, U=X      atan2(Y,X) = sgnY * (pi - atan(V/U))
//
// So the result is always of the form atan2(Y,X) = P + sgnXY * atan(V/U)
//
// We compute atan(V/U) from the identity 
//      atan(z) + atan([(V/U)-z] / [1+(V/U)z])
//      where z is a limited precision approximation (16 bits) to V/U
//
// z is calculated with the assistance of the frcpa instruction.
//
// atan(z) is calculated by a polynomial z + z^3 * p(w),  w=z^2
// where p(w) = P0+P1*w+...+P22*w^22
//
// Let d = [(V/U)-z] / [1+(V/U)z]) = (V-U*z)/(U+V*z)
//
// Approximate atan(d) by d + P0*d^3
// Let F = 1/(U+V*z) * (1-a), where |a|< 2^-8.8.
// Compute q(a) = 1 + a + ... + a^5.
// Then F*q(a) approximates the reciprocal to more than 50 bits.

// Special values
//==============================================================
//              Y                 x          Result
//             +number           +inf        +0
//             -number           +inf        -0
//             +number           -inf        +pi
//             -number           -inf        -pi
//
//             +inf              +number     +pi/2
//             -inf              +number     -pi/2
//             +inf              -number     +pi/2
//             -inf              -number     -pi/2
//
//             +inf              +inf        +pi/4
//             -inf              +inf        -pi/4
//             +inf              -inf        +3pi/4
//             -inf              -inf        -3pi/4
//
//             +1                +1          +pi/4
//             -1                +1          -pi/4
//             +1                -1          +3pi/4
//             -1                -1          -3pi/4
//
//             +number           +0          +pi/2
//             -number           +0          -pi/2
//             +number           -0          +pi/2
//             -number           -0          -pi/2
//
//             +0                +number     +0 
//             -0                +number     -0 
//             +0                -number     +pi
//             -0                -number     -pi
//
//             +0                +0          +0 
//             -0                +0          -0 
//             +0                -0          +pi
//             -0                -0          -pi
//
//            Nan             anything      quiet Y
//            anything        NaN           quiet X

// atan2(+-0/+-0) sets double error tag to 37


// Assembly macros
//==============================================================

EXP_AD_P1                    = r33
EXP_AD_P2                    = r34
atan2_GR_sml_exp             = r35


GR_SAVE_B0                   = r35
GR_SAVE_GP                   = r36
GR_SAVE_PFS                  = r37

GR_Parameter_X               = r38
GR_Parameter_Y               = r39
GR_Parameter_RESULT          = r40
atan2_GR_tag                 = r41

atan2_Y                      = f8
atan2_X                      = f9

atan2_u1_X                   = f32
atan2_u1_Y                   = f33
atan2_z2_X                   = f34
atan2_z2_Y                   = f35

atan2_two                    = f36
atan2_B1sq_Y                 = f37
atan2_z1_X                   = f38
atan2_z1_Y                   = f39
atan2_B1X                    = f40

atan2_B1Y                    = f41
atan2_wp_X                   = f42
atan2_B1sq_X                 = f43
atan2_z                      = f44
atan2_w                      = f45

atan2_P0                     = f46
atan2_P1                     = f47
atan2_P2                     = f48
atan2_P3                     = f49
atan2_P4                     = f50

atan2_P5                     = f51
atan2_P6                     = f52
atan2_P7                     = f53
atan2_P8                     = f54
atan2_P9                     = f55

atan2_P10                    = f56
atan2_P11                    = f57
atan2_P12                    = f58
atan2_P13                    = f59
atan2_P14                    = f60

atan2_P15                    = f61
atan2_P16                    = f62
atan2_P17                    = f63
atan2_P18                    = f64
atan2_P19                    = f65

atan2_P20                    = f66
atan2_P21                    = f67
atan2_P22                    = f68
atan2_pi_by_2                = f69
atan2_V13                    = f70

atan2_W11                    = f71
atan2_E                      = f72
atan2_wp_Y                   = f73
atan2_V11                    = f74
atan2_V12                    = f75

atan2_V7                     = f76
atan2_V8                     = f77
atan2_W7                     = f78
atan2_W8                     = f79
atan2_W3                     = f80

atan2_W4                     = f81
atan2_V3                     = f82
atan2_V4                     = f83
atan2_F                      = f84
atan2_gV                     = f85

atan2_V10                    = f86
atan2_zcub                   = f87
atan2_V6                     = f88
atan2_V9                     = f89
atan2_W10                    = f90

atan2_W6                     = f91
atan2_W2                     = f92
atan2_V2                     = f93
atan2_alpha                  = f94
atan2_alpha_1                = f95

atan2_gVF                    = f96
atan2_V5                     = f97
atan2_W12                    = f98
atan2_W5                     = f99
atan2_alpha_sq               = f100

atan2_Cp                     = f101
atan2_V1                     = f102
atan2_ysq                    = f103
atan2_W1                     = f104
atan2_alpha_cub              = f105

atan2_C                      = f106
atan2_xsq                    = f107
atan2_d                      = f108
atan2_A_hi                   = f109
atan2_dsq                    = f110

atan2_pd                     = f111
atan2_A_lo                   = f112
atan2_A                      = f113
atan2_Pp                     = f114
atan2_sgnY                   = f115

atan2_pi                     = f116
atan2_3pi_by_4               = f117
atan2_pi_by_4                = f118


// These coefficients are for atan2. 
// You can also use this set to substitute those used in the |X| <= 1 case for atan; 
// BUT NOT vice versa.

/////////////////////////////////////////////////////////////


.data

.align 16

atan2_tb1:
data8 0xA21922DC45605EA1 ,  0x00003FFA // P11
data8 0xB199DD6D2675C40F ,  0x0000BFFA // P10
data8 0xC2F01E5DDD100DBE ,  0x00003FFA // P9
data8 0xD78F28FC2A592781 ,  0x0000BFFA // P8
data8 0xF0F03ADB3FC930D3 ,  0x00003FFA // P7
data8 0x88887EBB209E3543 ,  0x0000BFFB // P6
data8 0x9D89D7D55C3287A5 ,  0x00003FFB // P5
data8 0xBA2E8B9793955C77 ,  0x0000BFFB // P4
data8 0xE38E38E320A8A098 ,  0x00003FFB // P3
data8 0x9249249247E37913 ,  0x0000BFFC // P2
data8 0xCCCCCCCCCCC906CD ,  0x00003FFC // P1
data8 0xAAAAAAAAAAAAA8A9 ,  0x0000BFFD // P0
data8 0xC90FDAA22168C235 ,  0x00004000 // pi

atan2_tb2:
data8 0xCE585A259BD8374C ,  0x00003FF0 // P21
data8 0x9F90FB984D8E39D0 ,  0x0000BFF3 // P20
data8 0x9D3436AABE218776 ,  0x00003FF5 // P19
data8 0xDEC343E068A6D2A8 ,  0x0000BFF6 // P18
data8 0xF396268151CFB11C ,  0x00003FF7 // P17 
data8 0xD818B4BB43D84BF2 ,  0x0000BFF8 // P16
data8 0xA2270D30A90AA220 ,  0x00003FF9 // P15
data8 0xD5F4F2182E7A8725 ,  0x0000BFF9 // P14
data8 0x80D601879218B53A ,  0x00003FFA // P13
data8 0x9297B23CCFFB291F ,  0x0000BFFA // P12
data8 0xFE7E52D2A89995B3 ,  0x0000BFEC // P22
data8 0xC90FDAA22168C235 ,  0x00003FFF // pi/2
data8 0xC90FDAA22168C235 ,  0x00003FFE // pi/4
data8 0x96cbe3f9990e91a8 ,  0x00004000 // 3pi/4




.align 32
.global atan2#

////////////////////////////////////////////////////////

.section .text
.proc  atan2#
.align 32
atan2:


{ .mfi
           alloc        r32           = ar.pfs,1,5,4,0
           frcpa.s1     atan2_u1_X,p6 = f1,atan2_X
           nop.i 999
}
{ .mfi
           addl         EXP_AD_P1   = @ltoff(atan2_tb1), gp
           fma.s1       atan2_two  = f1,f1,f1 
           nop.i 999
;;
}

{ .mfi
           ld8  EXP_AD_P1 = [EXP_AD_P1]
           frcpa.s1     atan2_u1_Y,p7 = f1,atan2_Y
           nop.i 999
}
{ .mfi
           nop.m 999
           fma.s1       atan2_xsq  = atan2_X,atan2_X,f0 
           nop.i 999
;;
}

{ .mfi
           nop.m 999
           fclass.m p10,p0 = atan2_Y, 0xc3     // Test for y=nan
           nop.i 999
}
{ .mfi
           nop.m 999
           fma.s1       atan2_ysq  = atan2_Y,atan2_Y,f0 
           nop.i 999
}
;;

{ .mfi
           add  EXP_AD_P2 = 0xd0,EXP_AD_P1
           fclass.m p12,p0 = atan2_X, 0xc3     // Test for x nan
           nop.i 999
}
;;


// p10 Y NAN, quiet and return
{ .mfi
           ldfe         atan2_P11  = [EXP_AD_P1],16
           fmerge.s     atan2_sgnY = atan2_Y,f1
           nop.i 999
}
{ .mfb
           ldfe         atan2_P21  = [EXP_AD_P2],16
(p10)      fma.d f8 = atan2_Y,atan2_X,f0   // If y=nan, result quietized y
(p10)      br.ret.spnt b0        // Exit if y=nan
;;
}


{ .mfi 
           ldfe         atan2_P10  = [EXP_AD_P1],16
           fma.s1       atan2_z1_X = atan2_u1_X, atan2_Y, f0
           nop.i 999
}
{ .mfi 
           ldfe         atan2_P20  = [EXP_AD_P2],16
           fnma.s1      atan2_B1X  = atan2_u1_X, atan2_X, atan2_two
           nop.i 999
;;
}

{ .mfi 
           ldfe         atan2_P9   = [EXP_AD_P1],16
           fma.s1       atan2_z1_Y = atan2_u1_Y, atan2_X, f0
           nop.i 999
}
{ .mfi 
           ldfe         atan2_P19  = [EXP_AD_P2],16
           fnma.s1      atan2_B1Y  = atan2_u1_Y, atan2_Y, atan2_two
           nop.i 999
}
;;

{ .mfi 
           ldfe         atan2_P8   = [EXP_AD_P1],16
           fma.s1       atan2_z2_X = atan2_u1_X, atan2_ysq, f0
           nop.i 999
}
{ .mfi 
           ldfe         atan2_P18  = [EXP_AD_P2],16
           fma.s1       atan2_z2_Y = atan2_u1_Y, atan2_xsq, f0
           nop.i 999
}
;;

// p10 ==> x  inf     y ?
// p11 ==> x !inf     y ?
{ .mfi 
           ldfe         atan2_P7   = [EXP_AD_P1],16
           fclass.m p10,p11 = atan2_X, 0x23    // test for x inf
           nop.i 999
}
{ .mfb 
           ldfe         atan2_P17  = [EXP_AD_P2],16
(p12)      fma.d        f8 = atan2_X,atan2_Y,f0     // If x nan, result quiet x
(p12)      br.ret.spnt b0                 // Exit for x nan
;;
}

// p6 true if swap,    means |y| >  |x|    or ysq > xsq
// p7 true if no swap, means |x| >= |y|    or xsq >= ysq
{ .mmf 
           ldfe         atan2_P6   = [EXP_AD_P1],16
           ldfe         atan2_P16  = [EXP_AD_P2],16
           fcmp.ge.s1 p7,p6    = atan2_xsq, atan2_ysq
;;
}

{ .mfi
           ldfe         atan2_P5   = [EXP_AD_P1],16
           fma.s1       atan2_wp_X   = atan2_z1_X, atan2_z1_X, f0
           nop.i 999
}
{ .mfi
           ldfe         atan2_P15       = [EXP_AD_P2],16
           fma.s1       atan2_B1sq_X = atan2_B1X, atan2_B1X, f0
           nop.i 999
;;
}

{ .mfi
           ldfe         atan2_P4   = [EXP_AD_P1],16
(p6)       fma.s1       atan2_wp_Y   = atan2_z1_Y, atan2_z1_Y, f0
           nop.i 999
}
{ .mfi
           ldfe         atan2_P14  = [EXP_AD_P2],16
(p6)       fma.s1       atan2_B1sq_Y = atan2_B1Y, atan2_B1Y, f0
           nop.i 999
;;
}

{ .mfi
           ldfe         atan2_P3        = [EXP_AD_P1],16
(p6)       fma.s1       atan2_E         = atan2_z2_Y, atan2_B1Y, atan2_Y
           nop.i 999
}
{ .mfi
           ldfe         atan2_P13  = [EXP_AD_P2],16
(p7)       fma.s1       atan2_E         = atan2_z2_X, atan2_B1X, atan2_X
           nop.i 999
;;
}


{ .mfi
           ldfe         atan2_P2        = [EXP_AD_P1],16
(p6)       fma.s1       atan2_z         = atan2_z1_Y, atan2_B1Y, f0
           nop.i 999
}
{ .mfi
           ldfe         atan2_P12  = [EXP_AD_P2],16
(p7)       fma.s1       atan2_z         = atan2_z1_X, atan2_B1X, f0
           nop.i 999
;;
}


{ .mmf
           ldfe         atan2_P1        = [EXP_AD_P1],16
           ldfe         atan2_P22       = [EXP_AD_P2],16
           fcmp.eq.s0  p14,p15=atan2_X,atan2_Y  // Dummy for denorm and invalid
;;
}


// p12 ==> x  inf     y inf
// p13 ==> x  inf     y !inf
{ .mmf
           ldfe         atan2_P0        = [EXP_AD_P1],16
           ldfe         atan2_pi_by_2   = [EXP_AD_P2],16
(p10)      fclass.m.unc p12,p13 = atan2_Y, 0x23  // x inf, test if y inf
;;
}

{ .mfi
           ldfe         atan2_pi        = [EXP_AD_P1],16
(p6)       fma.s1       atan2_w         = atan2_wp_Y, atan2_B1sq_Y,f0
           nop.i 999
}
{ .mfi
           ldfe         atan2_pi_by_4       = [EXP_AD_P2],16
(p7)       fma.s1       atan2_w         = atan2_wp_X, atan2_B1sq_X,f0
           nop.i 999
;;
}

{ .mfi
           ldfe         atan2_3pi_by_4       = [EXP_AD_P2],16
(p11)      fclass.m.unc p9,p0 = atan2_Y, 0x23  // x not inf, test if y inf
           nop.i 999
;;
}

{ .mfi
           nop.m 999
(p12)      fcmp.gt.unc.s1 p10,p11 = atan2_X,f0 // x inf, y inf, test if x +inf
           nop.i 999
}
{ .mfi
           nop.m 999
(p6)       fnma.s1       atan2_gV        = atan2_Y, atan2_z, atan2_X 
           nop.i 999
;;
}

{ .mfi
           nop.m 999
           frcpa.s1     atan2_F,p0     = f1, atan2_E
           nop.i 999
}
{ .mfi
           nop.m 999
(p7)       fnma.s1       atan2_gV        = atan2_X, atan2_z, atan2_Y 
           nop.i 999
;;
}

// p13 ==> x  inf     y !inf
{ .mfi
           nop.m 999
(p13)      fcmp.gt.unc.s1 p14,p15 = atan2_X,f0 // x inf, y !inf, test if x +inf
           nop.i 999
}
{ .mfb
           nop.m 999
(p9)       fma.d  f8 = atan2_sgnY, atan2_pi_by_2, f0  // +-pi/2 if x !inf, y inf
(p9)       br.ret.spnt b0      // exit if x not inf, y inf, result is +-pi/2
;;
}

{ .mfi
           nop.m 999
           fma.s1       atan2_V13       = atan2_w, atan2_P11, atan2_P10
           nop.i 999
}
{ .mfi
           nop.m 999
           fma.s1       atan2_W11       = atan2_w, atan2_P21, atan2_P20
           nop.i 999
;;
}

{ .mfi
           nop.m 999
           fma.s1       atan2_V11       = atan2_w, atan2_P9, atan2_P8
           nop.i 999
}
{ .mfi
           nop.m 999
           fma.s1       atan2_V12       = atan2_w, atan2_w, f0
           nop.i 999
;;
}

{ .mfi
           nop.m 999
           fma.s1       atan2_V8        = atan2_w, atan2_P7 , atan2_P6 
           nop.i 999
}
{ .mfi
           nop.m 999
           fma.s1       atan2_W8        = atan2_w, atan2_P19, atan2_P18
           nop.i 999
;;
}

{ .mfi
           nop.m 999
           fnma.s1      atan2_alpha     = atan2_E, atan2_F, f1
           nop.i 999
}
{ .mfi
           nop.m 999
           fnma.s1      atan2_alpha_1   = atan2_E, atan2_F, atan2_two
           nop.i 999
;;
}


{ .mfi
           nop.m 999
           fma.s1       atan2_V7        = atan2_w, atan2_P5 , atan2_P4 
           nop.i 999
}
{ .mfi
           nop.m 999
           fma.s1       atan2_W7        = atan2_w, atan2_P17, atan2_P16 
           nop.i 999
;;
}

{ .mfi
           nop.m 999
           fma.s1       atan2_V4        = atan2_w, atan2_P3 , atan2_P2
           nop.i 999
}
{ .mfi
           nop.m 999
           fma.s1       atan2_W4        = atan2_w, atan2_P15, atan2_P14
           nop.i 999
;;
}

{ .mfi
           nop.m 999
           fma.s1       atan2_V3        = atan2_w, atan2_P1 , atan2_P0 
           nop.i 999
}
{ .mfi
           nop.m 999
           fma.s1       atan2_W3        = atan2_w, atan2_P13, atan2_P12 
           nop.i 999
;;
}

{ .mfi
           nop.m 999
           fma.s1       atan2_V10       = atan2_V12, atan2_V13, atan2_V11
           nop.i 999
}
{ .mfi
           nop.m 999
           fma.s1       atan2_gVF       = atan2_gV, atan2_F, f0
           nop.i 999
;;
}

{ .mfi
           nop.m 999
           fma.s1       atan2_alpha_sq  = atan2_alpha, atan2_alpha, f0  
           nop.i 999
}
{ .mfi
           nop.m 999
           fma.s1       atan2_Cp        = atan2_alpha, atan2_alpha_1, f1  
           nop.i 999
;;
}

{ .mfi
           nop.m 999
           fma.s1       atan2_V9        = atan2_V12, atan2_V12, f0
           nop.i 999
}
{ .mfi
           nop.m 999
           fma.s1       atan2_W10       = atan2_V12, atan2_P22 , atan2_W11
           nop.i 999
;;
}

{ .mfi
           nop.m 999
           fma.s1       atan2_V6        = atan2_V12, atan2_V8 , atan2_V7 
           nop.i 999
}
{ .mfi
           nop.m 999
           fma.s1       atan2_W6        = atan2_V12, atan2_W8 , atan2_W7
           nop.i 999
;;
}

{ .mfi
           nop.m 999
           fma.s1       atan2_V2        = atan2_V12, atan2_V4 , atan2_V3
           nop.i 999
}
{ .mfi
           nop.m 999
           fma.s1       atan2_W2        = atan2_V12, atan2_W4  , atan2_W3
           nop.i 999
;;
}

// p8 ==> y   0     x?
// p9 ==> y  !0     x?
{ .mfi
           nop.m 999
           fclass.m p8,p9 = atan2_Y, 0x07  // Test for y=0
           nop.i 999
}
{ .mfi
           nop.m 999
           fma.s1       atan2_zcub      = atan2_z, atan2_w, f0
           nop.i 999
;;
}

{ .mfi
           nop.m 999
           fma.s1       atan2_alpha_cub = atan2_alpha, atan2_alpha_sq, f0
           nop.i 999
}
{ .mfi
           nop.m 999
           fma.s1       atan2_C         = atan2_gVF, atan2_Cp, f0
           nop.i 999
;;
}

// p12 ==>  y0     x0
// p13 ==>  y0     x!0
{ .mfi
           nop.m 999
(p8)       fclass.m.unc p12,p13 = atan2_X, 0x07  // y=0, test if x is 0
           nop.i 999
}
{ .mfi
           nop.m 999
           fma.s1       atan2_W12       = atan2_V9, atan2_V9, f0
           nop.i 999
;;
}

{ .mfi
           nop.m 999
           fma.s1       atan2_V5        = atan2_V9, atan2_V10, atan2_V6
           nop.i 999
}
{ .mfi
           nop.m 999
           fma.s1       atan2_W5        = atan2_V9, atan2_W10, atan2_W6
           nop.i 999
;;
}


// p9 ==>  y!0    x0
{ .mfi
           nop.m 999
(p9)       fclass.m.unc p9,p0 = atan2_X, 0x07  // y not 0, test if x is 0
           nop.i 999
}
// p10 ==> X +INF, Y +-INF
{ .mfb
           nop.m 999
(p10)      fma.d       f8 = atan2_sgnY, atan2_pi_by_4, f0 // x=+inf, y=inf
(p10)      br.ret.spnt b0          // Exit for x=+inf, y=inf, result is +-pi/4
;;
}

.pred.rel "mutex",p11,p14
{ .mfi
           nop.m 999
(p14)      fmerge.s    f8 = atan2_sgnY, f0 // x=+inf, y !inf, result +-0
           nop.i 999
}
// p11 ==> X -INF, Y +-INF
{ .mfb
           nop.m 999
(p11)      fma.d       f8 = atan2_sgnY, atan2_3pi_by_4, f0 // x=-inf, y=inf
(p11)      br.ret.spnt b0          // Exit for x=-inf, y=inf, result is +-3pi/4
;;
}

{ .mfi
           nop.m 999
(p13)      fcmp.gt.unc.s1 p10,p11 = atan2_X,f0 // x not 0, y=0, test if x>0
           nop.i 999
}
{ .mfb
           nop.m 999
           fma.s1       atan2_d         = atan2_alpha_cub, atan2_C, atan2_C
(p14)      br.ret.spnt b0         // Exit if x=+inf, y !inf, result +-0
;;
}

{ .mfi
           nop.m 999
           fma.s1       atan2_W12       = atan2_V9, atan2_W12, f0
           nop.i 999
}
{ .mfb
           nop.m 999
(p9)       fma.d       f8 = atan2_sgnY, atan2_pi_by_2, f0 // x=0, y not 0
(p9)       br.ret.spnt b0      // Exit if x=0 and y not 0, result is +-pi/2 
;;
}

{ .mfi
           nop.m 999
           fma.s1       atan2_V1        = atan2_V9, atan2_V5, atan2_V2
           nop.i 999
}
{ .mfb
           nop.m 999
           fma.s1       atan2_W1        = atan2_V9, atan2_W5, atan2_W2
(p12)      br.spnt ATAN2_ERROR            // Branch if x=0 and y=0
;;
}

{ .mfi
           nop.m 999
(p10)      fmerge.s     f8              = atan2_sgnY, f0  // +-0 if x>0, y=0
           nop.i 999
}
{ .mfb
           nop.m 999
(p11)      fma.d        f8 = atan2_sgnY, atan2_pi, f0 // +-pi if x<0, y=0
(p13)      br.ret.spnt b0      // Exit if x!0 and y=0
;;
}

{ .mfb
           nop.m 999
(p15)      fma.d        f8              = atan2_sgnY, atan2_pi, f0
(p15)      br.ret.spnt b0         // Exit if x=-inf, y !inf, result +-pi
;;
}


{ .mfi
           nop.m 999
           fma.s1       atan2_pd        = atan2_P0, atan2_d, f0
           nop.i 999
}
{ .mfi
           nop.m 999
           fma.s1       atan2_dsq       = atan2_d, atan2_d, f0
           nop.i 999
;;
}


{ .mfi
           nop.m 999
           fma.s1       atan2_Pp        = atan2_W12, atan2_W1, atan2_V1
           nop.i 999
;;
}

// p8 true if no swap and X positive
// p9 true if no swap and X negative
// both are false is swap is true
{ .mfi
           nop.m 999
(p7)       fcmp.ge.unc.s1 p8,p9    = atan2_X,f0
           nop.i 999
}
{ .mfi
           nop.m 999
           fma.s1       atan2_A_lo      = atan2_pd, atan2_dsq, atan2_d
           nop.i 999
;;
}


{ .mfi
           nop.m 999
           fma.s1       atan2_A_hi      = atan2_zcub, atan2_Pp, atan2_z
           nop.i 999
;;
}


{ .mfi
           nop.m 999
           fma.s1       atan2_A         = atan2_A_hi, f1, atan2_A_lo
           nop.i 999
}
// For |Y| <= |X| and X > 0, result is A_hi + A_lo
{ .mfi
           nop.m 999
(p8)       fma.d       f8         = atan2_A_hi, f1, atan2_A_lo
           nop.i 999
;;
}

// For |Y| > |X|, result is  +- pi/2 - (A_hi + A_lo)
{ .mfi
           nop.m 999
(p6)       fms.d       f8         = atan2_sgnY, atan2_pi_by_2, atan2_A
           nop.i 999
}
// For |Y| <= |X|, and X < 0, result is  +- pi + (A_hi + A_lo)
{ .mfb
           nop.m 999
(p9)       fma.d        f8        = atan2_sgnY, atan2_pi, atan2_A
           br.ret.sptk  b0     
;;
}

ATAN2_ERROR:
// Here if x=0 and y=0
{ .mfi
          nop.m 999
          fclass.m p10,p11       = atan2_X,0x05  // Test if x=+0
          nop.i 999
}
;;

{ .mfi
          mov        atan2_GR_tag     = 37 
(p10)     fmerge.s     f10             = atan2_sgnY, f0 // x=+0, y=0
          nop.i 999 
}
{ .mfi
          nop.m 999
(p11)     fma.d        f10            = atan2_sgnY, atan2_pi, f0 // x=-0, y=0
          nop.i 999
;;
}
.endp atan2#


// Stack operations when calling error support.
//       (1)               (2)                          (3) (call)              (4)
//   sp   -> +          psp -> +                     psp -> +                   sp -> +
//           |                 |                            |                         |
//           |                 | <- GR_Y               R3 ->| <- GR_RESULT            | -> f8
//           |                 |                            |                         |
//           | <-GR_Y      Y2->|                       Y2 ->| <- GR_Y                 |
//           |                 |                            |                         |
//           |                 | <- GR_X               X1 ->|                         |
//           |                 |                            |                         |
//  sp-64 -> +          sp ->  +                     sp ->  +                         +
//    save ar.pfs          save b0                                               restore gp
//    save gp                                                                    restore ar.pfs


.proc __libm_error_region
__libm_error_region:
.prologue
// (1)
{ .mfi
        add   GR_Parameter_Y=-32,sp             // Parameter 2 value
        nop.f 999
.save   ar.pfs,GR_SAVE_PFS
        mov  GR_SAVE_PFS=ar.pfs                 // Save ar.pfs
}
{ .mfi
.fframe 64
        add sp=-64,sp                          // Create new stack
        nop.f 0
        mov GR_SAVE_GP=gp                      // Save gp
};;


// (2)
{ .mmi
        stfd [GR_Parameter_Y] = f8,16         // STORE Parameter 2 on stack
        add GR_Parameter_X = 16,sp            // Parameter 1 address
.save   b0, GR_SAVE_B0
        mov GR_SAVE_B0=b0                     // Save b0
};;

.body
// (3)
{ .mib
        stfd [GR_Parameter_X] = f9                   // STORE Parameter 1 on stack
        add   GR_Parameter_RESULT = 0,GR_Parameter_Y // Parameter 3 address
        nop.b 0                                 
}
{ .mib
        stfd [GR_Parameter_Y] = f10                  // STORE Parameter 3 on stack
        add   GR_Parameter_Y = -16,GR_Parameter_Y
        br.call.sptk b0=__libm_error_support#        // Call error handling function
};;
{ .mmi
        nop.m 0
        nop.m 0
        add   GR_Parameter_RESULT = 48,sp
};;

// (4)
{ .mmi
        ldfd  f8 = [GR_Parameter_RESULT]       // Get return result off stack
.restore
        add   sp = 64,sp                       // Restore stack pointer
        mov   b0 = GR_SAVE_B0                  // Restore return address
};;
{ .mib
        mov   gp = GR_SAVE_GP                  // Restore gp
        mov   ar.pfs = GR_SAVE_PFS             // Restore ar.pfs
        br.ret.sptk     b0                     // Return
};;

.endp __libm_error_region

.type   __libm_error_support#,@function
.global __libm_error_support#
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\ia64\asinf.s ===
.file "asinf.s"

// Copyright (c) 2000, 2001, Intel Corporation
// All rights reserved.
//
// Contributed 2/02/2000 by John Harrison, Ted Kubaska, Bob Norin, Shane Story,
// and Ping Tak Peter Tang of the Computational Software Lab, Intel Corporation.
//
// WARRANTY DISCLAIMER
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// Intel Corporation is the author of this code, and requests that all
// problem reports or change requests be submitted to it directly at
// http://developer.intel.com/opensource.

// History
//==============================================================
// 2/02/00  Initial version
// 6/28/00  Improved speed 
// 6/31/00  Changed register allocation because of some duplicate macros
//          moved nan exit bundle up to gain a cycle. 
// 8/08/00  Improved speed by avoiding SIR flush.
// 8/15/00  Bundle added after call to __libm_error_support to properly
//          set [the previously overwritten] GR_Parameter_RESULT.
// 8/17/00  Changed predicate register macro-usage to direct predicate
//          names due to an assembler bug.
// 10/17/00 Improved speed of x=0 and x=1 paths, set D flag if x denormal.
// 3/13/01  Corrected sign of imm1 value in dep instruction.

	
// Description
//=========================================
// The asinf function computes the arc sine of x in the range [-pi,+pi].
// A doman error occurs for arguments not in the range [-1,+1].
// asinf(+-0) returns +-0
// asinf(x) returns a Nan and raises the invalid exception for |x| >1 

// The acosf function returns the arc cosine in the range [0, +pi] radians.
// A doman error occurs for arguments not in the range [-1,+1].
// acosf(1) returns +0
// acosf(x) returns a Nan and raises the invalid exception for |x| >1


// |x| <= sqrt(2)/2. get Ax and Bx

// poly_p1 = x p1
// poly_p3 = x2 p4 + p3
// poly_p1 = x2 (poly_p1) + x  = x2(x p1) + x
// poly_p2 = x2( poly_p3) + p2 = x2(x2 p4 + p3) + p2

// poly_Ax = x5(x2( poly_p3) + p2) + x2(x p1) + x
//         = x5(x2(x2 p4 + p3) + p2) + x2(x p1) + x

// poly_p7 = x2 p8 + p7
// poly_p5 = x2 p6 + p5

// poly_p7 = x4 p9 + (poly_p7)
// poly_p7 = x4 p9 + (x2 p8 + p7)
// poly_Bx = x4 (x4 p9 + (x2 p8 + p7)) + x2 p6 + p5

// answer1 = x11(x4 (x4 p9 + (x2 p8 + p7)) + x2 p6 + p5) + x5(x2(x2 p4 + p3) + p2) + x2(x p1) + x
//         = x19 p9 + x17 p8 + x15 p7 x13 p6 + x11 p5 + x9 p4 + x7 p3 + x5 p2 + x3 p1 + x



// |x| >  sqrt(2)/2

// Get z = sqrt(1-x2)

// Get polynomial in t = 1-x2

// t2      = t t
// t4      = t2 t2

// poly_p4 = t p5 + p4
// poly_p1 = t p1 + 1

// poly_p6 = t p7 + p6
// poly_p2 = t p3 + p2

// poly_p8 = t p9 + p8

// poly_p4 = t2 poly_p6 + poly_p4
//         = t2 (t p7 + p6) + (t p5 + p4)

// poly_p2 = t2 poly_p2 + poly_p1
//         = t2 (t p3 + p2) + (t p1 + 1)

// poly_p4 = t4 poly_p8 + poly_p4
//         = t4 (t p9 + p8) + (t2 (t p7 + p6) + (t p5 + p4))

// P(t)    = poly_p2 + t4 poly_p8
//         = t2 (t p3 + p2) + (t p1 + 1) + t4 (t4 (t p9 + p8) + (t2 (t p7 + p6) + (t p5 + p4)))
//         = t3 p3 + t2 p2 + t p1 + 1 + t9 p9 + t8 p8 + t7 p7 + t6 p6 + t5 p5 + t4 p4


//  answer2 = - sign(x) z P(t) + (sign(x) pi/2)
//


// Assembly macros
//=========================================

// predicate registers
//asinf_pred_LEsqrt2by2            = p7
//asinf_pred_GTsqrt2by2            = p8

// integer registers
ASINF_Addr1                      = r33
ASINF_Addr2                      = r34
ASINF_GR_1by2                    = r35

ASINF_GR_3by2                    = r36
ASINF_GR_5by2                    = r37

GR_SAVE_B0                    = r38
GR_SAVE_PFS                   = r39
GR_SAVE_GP                    = r40

GR_Parameter_X                = r41
GR_Parameter_Y                = r42
GR_Parameter_RESULT           = r43
GR_Parameter_TAG              = r44

// floating point registers

asinf_y                          = f32
asinf_abs_x                      = f33
asinf_x2                         = f34
asinf_sgn_x                      = f35

asinf_1by2                       = f36
asinf_3by2                       = f37
asinf_5by2                       = f38
asinf_coeff_P3                   = f39
asinf_coeff_P8                   = f40

asinf_coeff_P1                   = f41
asinf_coeff_P4                   = f42
asinf_coeff_P5                   = f43
asinf_coeff_P2                   = f44
asinf_coeff_P7                   = f45

asinf_coeff_P6                   = f46
asinf_coeff_P9                   = f47
asinf_x2                         = f48
asinf_x3                         = f49
asinf_x4                         = f50

asinf_x8                         = f51
asinf_x5                         = f52
asinf_const_piby2                = f53
asinf_const_sqrt2by2             = f54
asinf_x11                        = f55

asinf_poly_p1                    = f56
asinf_poly_p3                    = f57
asinf_sinf1                      = f58
asinf_poly_p2                    = f59
asinf_poly_Ax                    = f60

asinf_poly_p7                    = f61
asinf_poly_p5                    = f62
asinf_sgnx_t4                    = f63
asinf_poly_Bx                    = f64
asinf_t                          = f65

asinf_yby2                       = f66
asinf_B                          = f67
asinf_B2                         = f68
asinf_Az                         = f69
asinf_dz                         = f70

asinf_Sz                         = f71
asinf_d2z                        = f72
asinf_Fz                         = f73
asinf_z                          = f74
asinf_sgnx_z                     = f75

asinf_t2                         = f76
asinf_2poly_p4                   = f77
asinf_2poly_p6                   = f78
asinf_2poly_p1                   = f79
asinf_2poly_p2                   = f80

asinf_2poly_p8                   = f81
asinf_t4                         = f82
asinf_Pt                         = f83
asinf_sgnx_2poly_p2              = f84
asinf_sgn_x_piby2                = f85

asinf_poly_p7a                   = f86
asinf_2poly_p4a                  = f87
asinf_2poly_p4b                  = f88
asinf_2poly_p2a                  = f89
asinf_poly_p1a                   = f90





// Data tables
//==============================================================

.data

.align 16

asinf_coeff_1_table:
data8 0x3FC5555607DCF816 // P1
data8 0x3F9CF81AD9BAB2C6 // P4
data8 0x3FC59E0975074DF3 // P7
data8 0xBFA6F4CC2780AA1D // P6
data8 0x3FC2DD45292E93CB // P9
data8 0x3fe6a09e667f3bcd // sqrt(2)/2

asinf_coeff_2_table:
data8 0x3FA6F108E31EFBA6 // P3
data8 0xBFCA31BF175D82A0 // P8
data8 0x3FA30C0337F6418B // P5
data8 0x3FB332C9266CB1F9 // P2
data8 0x3ff921fb54442d18 // pi_by_2


.align 32
.global asinf

.section .text
.proc  asinf
.align 32

asinf:
 
// Load the addresses of the two tables.
// Then, load the coefficients and other constants.

{     .mfi 
     alloc      r32            = ar.pfs,1,8,4,0
     fnma.s1   asinf_t        =    f8,f8,f1
     dep.z ASINF_GR_1by2 =    0x3f,24,8    // 0x3f000000
} 
{     .mfi 
     addl ASINF_Addr1    =    @ltoff(asinf_coeff_1_table),gp
     fma.s1    asinf_x2       =    f8,f8,f0
     addl      ASINF_Addr2    =    @ltoff(asinf_coeff_2_table),gp ;;
}

 
{     .mfi 
     ld8       ASINF_Addr1    =    [ASINF_Addr1]
     fmerge.s  asinf_abs_x    =    f1,f8
     dep ASINF_GR_3by2 =    -1,r0,22,8     // 0x3fc00000
} 
{     .mlx 
     nop.m                      999
     movl      ASINF_GR_5by2  =    0x40200000;;
}

 

{     .mfi 
     setf.s    asinf_1by2     =    ASINF_GR_1by2
     fmerge.s  asinf_sgn_x    =    f8,f1
     nop.i                      999
} 
{     .mfi 
     ld8       ASINF_Addr2    =    [ASINF_Addr2]
     nop.f 0
     nop.i                      999;;
}

 
{     .mfi 
     setf.s    asinf_5by2     =    ASINF_GR_5by2
     fcmp.lt.s1 p11,p12 = f8,f0
     nop.i                      999;;
}

{ .mmf 
     ldfpd     asinf_coeff_P1,asinf_coeff_P4 =    [ASINF_Addr1],16
     setf.s    asinf_3by2     =    ASINF_GR_3by2
     fclass.m.unc p8,p0      = f8, 0xc3 ;;	//@qnan | @snan
}

 
{     .mfi 
     ldfpd     asinf_coeff_P7,asinf_coeff_P6 =    [ASINF_Addr1],16
     fma.s1    asinf_t2                      =    asinf_t,asinf_t,f0
     nop.i                                     999
} 
{     .mfi 
     ldfpd     asinf_coeff_P3,asinf_coeff_P8 =    [ASINF_Addr2],16
     fma.s1    asinf_x4                      =    asinf_x2,asinf_x2,f0
     nop.i                                     999;;
}

 
{     .mfi 
     ldfpd     asinf_coeff_P9,asinf_const_sqrt2by2     =    [ASINF_Addr1]
     fclass.m.unc p10,p0      = f8, 0x07	//@zero
     nop.i                                     999
} 
{     .mfi 
     ldfpd     asinf_coeff_P5,asinf_coeff_P2 =    [ASINF_Addr2],16
     fma.s1    asinf_x3  =    f8,asinf_x2,f0
     nop.i                                     999;;
}

 
{     .mfi 
     ldfd      asinf_const_piby2   =    [ASINF_Addr2]
     frsqrta.s1     asinf_B,p0                   =    asinf_t
     nop.i                                               999
} 
{     .mfb 
     nop.m                                               999
(p8) fma.s f8                = f8,f1,f0
(p8) br.ret.spnt   b0 ;;  // Exit if x=nan
}

 
{     .mfb 
     nop.m                 999
     fcmp.eq.s1 p6,p0 = asinf_abs_x,f1
(p10) br.ret.spnt  b0 ;;     // Exit if x=0
} 
 
{     .mfi 
     nop.m                 999
     fcmp.gt.s1 p9,p0 = asinf_abs_x,f1
     nop.i                 999;;
} 
 
{     .mfi 
     nop.m                 999
     fma.s1    asinf_x8  =    asinf_x4,asinf_x4,f0
     nop.i                 999
} 
{     .mfb 
     nop.m                      999
     fma.s1    asinf_t4  =    asinf_t2,asinf_t2,f0
(p6) br.cond.spnt  ASINF_ABS_ONE ;;     // Branch if |x|=1
} 

{     .mfi 
     nop.m                 999
     fma.s1    asinf_x5  =    asinf_x2,asinf_x3,f0
     nop.i                 999
}
{     .mfb 
(p9) mov            GR_Parameter_TAG = 62
     fma.s1    asinf_yby2     =    asinf_t,asinf_1by2,f0
(p9) br.cond.spnt  __libm_error_region ;;    // Branch if |x|>1
}


{     .mfi 
     nop.m                 999
     fma.s1    asinf_Az  =    asinf_t,asinf_B,f0
     nop.i                 999
} 
{     .mfi 
     nop.m                 999
     fma.s1    asinf_B2  =    asinf_B,asinf_B,f0
     nop.i                 999;;
}
 
{     .mfi 
     nop.m                      999
     fma.s1    asinf_poly_p1  =    f8,asinf_coeff_P1,f0
     nop.i                      999
} 
{     .mfi 
     nop.m                      999
     fma.s1    asinf_2poly_p1 =    asinf_coeff_P1,asinf_t,f1
     nop.i                      999;;
}

{     .mfi 
     nop.m                      999
     fma.s1    asinf_poly_p3  =    asinf_coeff_P4,asinf_x2,asinf_coeff_P3
     nop.i                      999
} 
{     .mfi 
     nop.m                      999
     fma.s1    asinf_2poly_p6 =    asinf_coeff_P7,asinf_t,asinf_coeff_P6
     nop.i                      999;;
} 

{     .mfi 
     nop.m                      999
     fma.s1    asinf_poly_p7  =    asinf_x2,asinf_coeff_P8,asinf_coeff_P7
     nop.i                      999
} 
{     .mfi 
     nop.m                      999
     fma.s1    asinf_2poly_p2 =    asinf_coeff_P3,asinf_t,asinf_coeff_P2
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                      999
     fma.s1    asinf_poly_p5  =    asinf_x2,asinf_coeff_P6,asinf_coeff_P5
     nop.i                      999
} 
{     .mfi 
     nop.m                      999
     fma.s1    asinf_2poly_p4 =    asinf_coeff_P5,asinf_t,asinf_coeff_P4
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                 999
     fma.d.s1    asinf_x11 =    asinf_x8,asinf_x3,f0
     nop.i                 999
} 
{     .mfi 
     nop.m                 999
     fnma.s1   asinf_dz  =    asinf_B2,asinf_yby2,asinf_1by2
     nop.i                 999;;
}

 
{     .mfi 
     nop.m                      999
     fma.s1    asinf_poly_p1a =    asinf_x2,asinf_poly_p1,f8
     nop.i                      999
}
{     .mfi 
     nop.m                      999
     fma.s1    asinf_2poly_p8 =    asinf_coeff_P9,asinf_t,asinf_coeff_P8
     nop.i                      999;;
}

 
// Get the absolute value of x and determine the region in which x lies

{     .mfi 
     nop.m                      999
     fcmp.le.s1     p7,p8 = asinf_abs_x,asinf_const_sqrt2by2
     nop.i                      999
} 
{     .mfi 
     nop.m                      999
     fma.s1    asinf_poly_p2  =    asinf_x2,asinf_poly_p3,asinf_coeff_P2
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                      999
     fma.s1    asinf_poly_p7a =    asinf_x4,asinf_coeff_P9,asinf_poly_p7
     nop.i                      999
} 
{     .mfi 
     nop.m                      999
     fma.s1    asinf_2poly_p2a =    asinf_2poly_p2,asinf_t2,asinf_2poly_p1
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                                                         999
(p8) fma.s1    asinf_sgnx_t4  =    asinf_sgn_x,asinf_t4,f0
     nop.i                                                         999
} 
{     .mfi 
     nop.m                      999
(p8) fma.s1    asinf_2poly_p4a =    asinf_2poly_p6,asinf_t2,asinf_2poly_p4
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                 999
(p8) fma.s1    asinf_Sz  =    asinf_5by2,asinf_dz,asinf_3by2
     nop.i                 999
} 
{     .mfi 
     nop.m                 999
(p8) fma.s1    asinf_d2z =    asinf_dz,asinf_dz,f0
     nop.i                 999;;
}

 
{     .mfi 
     nop.m                           999
(p8) fma.s1   asinf_sgn_x_piby2 =    asinf_sgn_x,asinf_const_piby2,f0
     nop.i                           999
} 
{     .mfi 
     nop.m                      999
(p7) fma.d.s1    asinf_poly_Ax  =    asinf_x5,asinf_poly_p2,asinf_poly_p1a
     nop.i                 999;;
} 
 
{     .mfi 
     nop.m                      999
(p7) fma.d.s1    asinf_poly_Bx  =    asinf_x4,asinf_poly_p7a,asinf_poly_p5
     nop.i                      999
} 
{     .mfi 
     nop.m                           999
(p8) fma.s1    asinf_sgnx_2poly_p2 =    asinf_sgn_x,asinf_2poly_p2a,f0
     nop.i                           999;;
} 
 
{     .mfi 
     nop.m                      999
     fcmp.eq.s0 p6,p0 = f8,f0      // Only purpose is to set D if x denormal
     nop.i                      999
}
{     .mfi 
     nop.m                      999
(p8) fma.s1    asinf_2poly_p4b =    asinf_2poly_p8,asinf_t4,asinf_2poly_p4a
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                      999
(p8) fma.s1    asinf_Fz  =    asinf_d2z,asinf_Sz,asinf_dz
     nop.i                      999;;
} 

 
{     .mfi 
     nop.m                 999
(p8) fma.d.s1  asinf_Pt  =    asinf_2poly_p4b,asinf_sgnx_t4,asinf_sgnx_2poly_p2
     nop.i                 999;;
} 
 
{     .mfi 
     nop.m                 999
(p8) fma.d.s1  asinf_z   =    asinf_Az,asinf_Fz,asinf_Az
     nop.i                 999;;
} 
 
.pred.rel "mutex",p8,p7    //asinf_pred_GTsqrt2by2,asinf_pred_LEsqrt2by2
{     .mfi 
                         nop.m            999
(p8)  fnma.s     f8   =    asinf_z,asinf_Pt,asinf_sgn_x_piby2
                         nop.i            999
} 
 
{     .mfb 
                         nop.m            999
(p7)  fma.s    f8    =    asinf_x11,asinf_poly_Bx,asinf_poly_Ax
                         br.ret.sptk b0 ;;
} 

ASINF_ABS_ONE:
// Here for short exit if |x|=1
{     .mfb 
     nop.m                      999
     fma.s    f8 =    asinf_sgn_x,asinf_const_piby2,f0
     br.ret.sptk b0
} 
;;

.endp asinf

// Stack operations when calling error support.
//       (1)               (2)                  
//   sp   -> +          psp -> +               
//           |                 |     
//           |                 | <- GR_Y      
//           |                 |             
//           | <-GR_Y      Y2->|            
//           |                 |           
//           |                 | <- GR_X  
//           |                 |         
//  sp-64 -> +          sp ->  +        
//    save ar.pfs          save b0     
//    save gp                         


// Stack operations when calling error support.
//     (3) (call)              (4)
//  psp -> +                   sp -> +
//         |                         |
//    R3 ->| <- GR_RESULT            | -> f8
//         |                         |
//    Y2 ->| <- GR_Y                 |
//         |                         |
//    X1 ->|                         |
//         |                         |
//  sp ->  +                         +
//                              restore gp
//                              restore ar.pfs

.proc __libm_error_region
__libm_error_region:
.prologue
{ .mfi
        add   GR_Parameter_Y=-32,sp             // Parameter 2 value
                nop.f 999
.save   ar.pfs,GR_SAVE_PFS
        mov  GR_SAVE_PFS=ar.pfs                 // Save ar.pfs
}
{ .mfi
.fframe 64
        add sp=-64,sp                           // Create new stack
        nop.f 0
        mov GR_SAVE_GP=gp                       // Save gp
};;
{ .mmi
        stfs [GR_Parameter_Y] = f1,16         // Store Parameter 2 on stack
        add GR_Parameter_X = 16,sp              // Parameter 1 address
.save   b0, GR_SAVE_B0
        mov GR_SAVE_B0=b0                       // Save b0
};;

.body
{ .mfi
        nop.m 0
        frcpa.s0 f9,p0 = f0,f0
        nop.i 0
};;

{ .mib
        stfs [GR_Parameter_X] = f8            // Store Parameter 1 on stack
        add   GR_Parameter_RESULT = 0,GR_Parameter_Y
        nop.b 0                                 // Parameter 3 address
}
{ .mib
        stfs [GR_Parameter_Y] = f9           // Store Parameter 3 on stack
        add   GR_Parameter_Y = -16,GR_Parameter_Y
        br.call.sptk b0=__libm_error_support#   // Call error handling function
};;
{ .mmi
        nop.m 0
        nop.m 0
        add   GR_Parameter_RESULT = 48,sp
};;

{ .mmi
        ldfs  f8 = [GR_Parameter_RESULT]       // Get return result off stack
.restore
        add   sp = 64,sp                       // Restore stack pointer
        mov   b0 = GR_SAVE_B0                  // Restore return address
};;
{ .mib
        mov   gp = GR_SAVE_GP                  // Restore gp
        mov   ar.pfs = GR_SAVE_PFS             // Restore ar.pfs
        br.ret.sptk     b0                     // Return
};;

.endp __libm_error_region

.type   __libm_error_support#,@function
.global __libm_error_support#
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\ia64\atan2f.s ===
.file "atan2f.s"

// Copyright (c) 2000, 2001, Intel Corporation
// All rights reserved.
//
// Contributed 6/1/2000 by John Harrison, Ted Kubaska, Bob Norin, Shane Story,
// and Ping Tak Peter Tang of the Computational Software Lab, Intel Corporation.
//
// WARRANTY DISCLAIMER
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// Intel Corporation is the author of this code, and requests that all
// problem reports or change requests be submitted to it directly at
// http://developer.intel.com/opensource.

// History
//==============================================================
// 6/01/00  Initial version
// 8/15/00  Bundle added after call to __libm_error_support to properly
//          set [the previously overwritten] GR_Parameter_RESULT.
// 8/17/00  Changed predicate register macro-usage to direct predicate
//          names due to an assembler bug.
// 1/05/01  Fixed flag settings for denormal input.
// 1/19/01  Added documentation
// 1/30/01  Improved speed

// Description
//=========================================
// The atan2 function computes the principle value of the arc tangent of y/x using
// the signs of both arguments to determine the quadrant of the return value.
// A domain error may occur if both arguments are zero.

// The atan2 function returns the arc tangent of y/x in the range [-pi,+pi] radians.

//..
//..Let (v,u) = (y,x) if |y| <= |x|, and (v,u) = (x,y) otherwise. Note that
//..v and u can be negative. We state the relationship between atan2(y,x) and
//..atan(v/u).
//..
//..Let swap = false if v = y, and swap = true if v = x.
//..Define C according to the matrix
//..
//..                   TABLE FOR C
//..                              x +ve       x -ve
//..   no swap (swap = false)    sgn(y)*0     sgn(y)*pi
//..   swap    (swap = true )    sgn(y)*pi/2  sgn(y)*pi/2
//..
//..   atan2(y,x) =  C +  atan(v/u)  if no swap
//..   atan2(y,x) =  C -  atan(v/u)  if  swap
//..
//..These relationship is more efficient to compute as we accommodate signs in v and u
//..saving the need to obtain the absolute value before computation can proceed.
//..
//..Suppose (v,u) = (y,x), we calculate atan(v/u) as follows:
//..A = y * frcpa(x)    (so A = (y/x)(1 - beta))
//..atan(y/x) = atan(A) + atan( ((y/x)-A))/(1 + (y/x)A) ), the second term is 
//..a correction.
//..atan(A) is approximated by a polynomial 
//..A + p1 A^3 + p2 A^5 + ... + p10 A^21,
//..atan(G) is approximated as follows:
//..Let G = (y - Ax)/(x + Ay), atan(G) can be approximated by G + g * p1
//..where g is a limited precision approximation to G via g = (y - Ax)*frcpa(x + Ay).
//..
//..Suppose (v,u) = (x,y), we calculate atan(v/u) as follows:
//..Z = x * frcpa(y)    (so Z = (x/y)(1 - beta))
//..atan(x/y) = atan(Z) + atan( ((x/y)-Z))/(1 + (x/y)Z) ), the second term is 
//..a correction.
//..atan(Z) is approximated by a polynomial 
//..Z + p1 Z^3 + p2 Z^5 + ... + p10 Z^21,
//..atan(T) is approximated as follows:
//..Let T = (x - Ay)/(y + Ax), atan(T) can be approximated by T + t * p1
//..where t is a limited precision approximation to T via t = (x - Ay)*frcpa(y + Ax).
//..
//..
//..A = y * frcpa(x)
//..atan(A) ~=~ A + p1 A^3 + ... + P10 A^21
//..
//..This polynomial is computed as follows:
//..Asq = A*A; Acub = A*Asq, A4 = Asq*Asq 
//..A5 = Asq*Acub, A6 = Asq*A4; A11 = A5 * A6
//..
//..poly_A1 = p9 + Asq*p10, poly_A2 = p7 + Asq*p8, poly_A3 = p5 + Asq*p6
//..poly_A1 = poly_A2 + A4 * poly_A1
//..poly_A1 = poly_A3 + A4 * poly_A1
//..
//..poly_A4 = p1 * A
//,,poly_A5 = p3 + Asq * p4, poly_A4 = A + Asq*poly_A4
//..poly_A5 = p2 + Asq * poly_A5 
//..poly_A4 = poly_A4 + A5 * poly_A5
//..
//..atan_A = poly_A4 + A11 * poly_A1
//..
//..atan(G) is approximated as follows:
//..G_numer = y - A*x, G_denom = x + A*y
//..H1 = frcpa(G_denom)
//..H_beta = 1 - H1 * G_denom
//..H2 = H1 + H1 * H_beta
//..H_beta2 = H_beta*H_beta
//..H3 = H2 + H2*H_beta2
//..g = H1 * G_numer; gsq = g*g; atan_G = g*p1, atan_G = atan_G*gsq
//..atan_G = G_numer*H3 + atan_G
//..
//..
//..A = y * frcpa(x)
//..atan(A) ~=~ A + p1 A^3 + ... + P10 A^21
//..
//..This polynomial is computed as follows:
//..Asq = A*A; Acub = A*Asq, A4 = Asq*Asq 
//..A5 = Asq*Acub, A6 = Asq*A4; A11 = A5 * A6
//..
//..poly_A1 = p9 + Asq*p10, poly_A2 = p7 + Asq*p8, poly_A3 = p5 + Asq*p6
//..poly_A1 = poly_A2 + A4 * poly_A1
//..poly_A1 = poly_A3 + A4 * poly_A1
//..
//..poly_A4 = p1 * A
//,,poly_A5 = p3 + Asq * p4, poly_A4 = A + Asq*poly_A4
//..poly_A5 = p2 + Asq * poly_A5 
//..poly_A4 = poly_A4 + A5 * poly_A5
//..
//..atan_A = poly_A4 + A11 * poly_A1
//..
//..
//..====================================================================
//..	COEFFICIENTS USED IN THE COMPUTATION
//..====================================================================

//coef_pj, j = 1,2,...,10;  atan(A) ~=~ A + p1 A^3 + p2 A^5 + ... + p10 A^21
//
//  coef_p1          =      -.3333332707155439167401311806315789E+00
//  coef_p1   in dbl = BFD5 5555 1219 1621 
//
//  coef_p2          =       .1999967670926658391827857030875748E+00
//  coef_p2   in dbl = 3FC9 997E 7AFB FF4E 
//
//  coef_p3          =      -.1427989384500152360161563301087296E+00
//  coef_p3   in dbl = BFC2 473C 5145 EE38 
//
//  coef_p4          =       .1105852823460720770079031213661163E+00
//  coef_p4   in dbl = 3FBC 4F51 2B18 65F5 
//
//  coef_p5          =      -.8811839915595312348625710228448363E-01
//  coef_p5   in dbl = BFB6 8EED 6A8C FA32 
//
//  coef_p6          =       .6742329836955067042153645159059714E-01
//  coef_p6   in dbl = 3FB1 42A7 3D7C 54E3 
//
//  coef_p7          =      -.4468571068774672908561591262231909E-01
//  coef_p7   in dbl = BFA6 E10B A401 393F 
//
//  coef_p8          =       .2252333246746511135532726960586493E-01
//  coef_p8   in dbl = 3F97 105B 4160 F86B 
//
//  coef_p9          =      -.7303884867007574742501716845542314E-02
//  coef_p9   in dbl = BF7D EAAD AA33 6451 
//
//  coef_p10         =       .1109686868355312093949039454619058E-02
//  coef_p10  in dbl = 3F52 2E5D 33BC 9BAA 
//

// Special values
//==============================================================
//              Y                 x          Result
//             +number           +inf        +0
//             -number           +inf        -0
//             +number           -inf        +pi
//             -number           -inf        -pi
//
//             +inf              +number     +pi/2
//             -inf              +number     -pi/2
//             +inf              -number     +pi/2
//             -inf              -number     -pi/2
//
//             +inf              +inf        +pi/4
//             -inf              +inf        -pi/4
//             +inf              -inf        +3pi/4
//             -inf              -inf        -3pi/4
//
//             +1                +1          +pi/4
//             -1                +1          -pi/4
//             +1                -1          +3pi/4
//             -1                -1          -3pi/4
//
//             +number           +0          +pi/2    // does not raise DBZ
//             -number           +0          -pi/2    // does not raise DBZ
//             +number           -0          +pi/2    // does not raise DBZ
//             -number           -0          -pi/2    // does not raise DBZ
//
//             +0                +number     +0
//             -0                +number     -0
//             +0                -number     +pi
//             -0                -number     -pi
//
//             +0                +0          +0      // does not raise invalid
//             -0                +0          -0      // does not raise invalid
//             +0                -0          +pi     // does not raise invalid
//             -0                -0          -pi     // does not raise invalid
//
//            Nan             anything      quiet Y
//            anything        NaN           quiet X

// atan2(+-0/+-0) sets double error tag to 37
// atan2f(+-0/+-0) sets single error tag to 38
// These are domain errors.


//
// Assembly macros
//=========================================


// integer registers
atan2f_GR_Addr_1              = r33
atan2f_GR_Addr_2              = r34
GR_SAVE_B0                    = r35

GR_SAVE_PFS                   = r36
GR_SAVE_GP                    = r37

GR_Parameter_X                = r38
GR_Parameter_Y                = r39
GR_Parameter_RESULT           = r40
GR_Parameter_TAG              = r41

// floating point registers
atan2f_coef_p1         = f32
atan2f_coef_p10        = f33
atan2f_coef_p7         = f34
atan2f_coef_p6         = f35

atan2f_coef_p3         = f36
atan2f_coef_p2         = f37
atan2f_coef_p9         = f38
atan2f_coef_p8         = f39
atan2f_coef_p5         = f40

atan2f_coef_p4         = f41
atan2f_const_piby2     = f42
atan2f_const_pi        = f43
atan2f_const_piby4     = f44
atan2f_const_3piby4    = f45

atan2f_xsq             = f46
atan2f_ysq             = f47
atan2f_xy              = f48
atan2f_const_1         = f49
atan2f_sgn_Y           = f50

atan2f_Z0              = f51
atan2f_A0              = f52
atan2f_Z               = f53
atan2f_A               = f54
atan2f_C               = f55

atan2f_U               = f56
atan2f_Usq             = f57
atan2f_U4              = f58
atan2f_U6              = f59
atan2f_U8              = f60

atan2f_poly_u109       = f61
atan2f_poly_u87        = f62
atan2f_poly_u65        = f63
atan2f_poly_u43        = f64
atan2f_poly_u21        = f65

atan2f_poly_u10to7     = f66
atan2f_poly_u6to3      = f67
atan2f_poly_u10to3     = f68
atan2f_poly_u10to0     = f69
atan2f_poly_u210       = f70

atan2f_T_numer         = f71
atan2f_T_denom         = f72
atan2f_G_numer         = f73
atan2f_G_denom         = f74
atan2f_p1rnum          = f75

atan2f_R_denom         = f76
atan2f_R_numer         = f77
atan2f_pR              = f78
atan2f_pRC             = f79
atan2f_pQRC            = f80

atan2f_Q1              = f81
atan2f_Q_beta          = f82
atan2f_Q2              = f83
atan2f_Q_beta2         = f84
atan2f_Q3              = f85

atan2f_r               = f86
atan2f_rsq             = f87
atan2f_poly_atan_U     = f88


// predicate registers
//atan2f_Pred_Swap     = p6 // |y| >  |x|
//atan2f_Pred_noSwap   = p7 // |y| <= |x|
//atan2f_Pred_Xpos     = p8 //  x  >=  0
//atan2f_Pred_Xneg     = p9 //  x  <   0


.data

.align 16

atan2f_coef_table1:
data8 0xBFD5555512191621 // p1
data8 0x3F522E5D33BC9BAA // p10
data8 0xBFA6E10BA401393F // p7
data8 0x3FB142A73D7C54E3 // p6
data8 0xBFC2473C5145EE38 // p3
data8 0x3FC9997E7AFBFF4E // p2

atan2f_coef_table2:
data8 0xBF7DEAADAA336451 // p9
data8 0x3F97105B4160F86B // p8
data8 0xBFB68EED6A8CFA32 // p5
data8 0x3FBC4F512B1865F5 // p4
data8 0x3ff921fb54442d18 // pi/2
data8 0x400921fb54442d18 // pi
data8 0x3fe921fb54442d18 // pi/4
data8 0x4002d97c7f3321d2 // 3pi/4



.global atan2f

.text
.proc  atan2f
.align 32

atan2f:

 
 
{     .mfi 
     alloc      r32           = ar.pfs,1,5,4,0
     frcpa.s1  atan2f_Z0,p0     =    f1,f8   // Approx to 1/y
     nop.i  999
} 
{     .mfi 
     addl      atan2f_GR_Addr_1    =    @ltoff(atan2f_coef_table1),gp
     fma.s1    atan2f_xsq     =    f9,f9,f0
     nop.i  999 ;;
}

 
{     .mfi 
     ld8       atan2f_GR_Addr_1    =    [atan2f_GR_Addr_1]
     frcpa.s1  atan2f_A0,p0     =    f1,f9   // Approx to 1/x
     nop.i  999
} 
{     .mfi 
     nop.m  999
     fma.s1    atan2f_ysq     =    f8,f8,f0
     nop.i  999 ;;
}
 
{     .mfi 
     nop.m  999
     fcmp.ge.s1     p8,p9  =    f9,f0  // Set p8 if x>=0, p9 if x<0
     nop.i  999
}
{     .mfi 
     nop.m  999
     fma.s1    atan2f_xy     =    f9,f8,f0
     nop.i  999 ;;
}
 
 
{     .mfi 
     add   atan2f_GR_Addr_2 = 0x30, atan2f_GR_Addr_1
     fmerge.s  atan2f_sgn_Y   =    f8,f1
     nop.i  999 ;;
} 
 
{     .mmf 
     ldfpd     atan2f_coef_p1,atan2f_coef_p10 =    [atan2f_GR_Addr_1],16
     ldfpd     atan2f_coef_p9,atan2f_coef_p8 =    [atan2f_GR_Addr_2],16
     fclass.m  p10,p0 =    f9,0xe7	// Test x @inf|@snan|@qnan|@zero
} 
;;
 
{     .mfi 
     ldfpd     atan2f_coef_p7,atan2f_coef_p6 =    [atan2f_GR_Addr_1],16
     fma.s1    atan2f_T_denom =    atan2f_Z0,atan2f_xsq,f8
     nop.i  999
} 
{     .mfi 
     ldfpd     atan2f_coef_p5,atan2f_coef_p4     =    [atan2f_GR_Addr_2],16
     fma.s1    atan2f_Z                      =    atan2f_Z0,f9,f0
     nop.i  999 ;;
}

 
{     .mfi 
     ldfpd     atan2f_coef_p3,atan2f_coef_p2 =    [atan2f_GR_Addr_1],16
     fma.s1    atan2f_G_denom =    atan2f_A0,atan2f_ysq,f9
     nop.i  999
} 
{     .mfi 
     ldfpd     atan2f_const_piby2,atan2f_const_pi =    [atan2f_GR_Addr_2],16
     fma.s1    atan2f_A                           =    atan2f_A0,f8,f0
     nop.i  999 ;;
}

{     .mfi 
     ldfpd     atan2f_const_piby4,atan2f_const_3piby4 = [atan2f_GR_Addr_2]
     fclass.m  p11,p0 = f8,0xe7	// Test y @inf|@snan|@qnan|@zero
     nop.i  999
} 
{     .mfb 
     nop.m  999
     fnma.s1   atan2f_T_numer =    atan2f_Z0,atan2f_xy,f9
(p10) br.cond.spnt ATAN2F_XY_INF_NAN_ZERO ;;   // Branch on x nan,inf,zero
} 


// p6 if |y|>|x|, p7 if |x|>=|y| , use xsq and ysq for test
{     .mfi 
     nop.m  999
     fcmp.gt.s1 p6,p7 = atan2f_ysq,atan2f_xsq
     nop.i  999
}
{     .mfb 
     nop.m  999
     fnma.s1   atan2f_G_numer =    atan2f_A0,atan2f_xy,f8
(p11) br.cond.spnt ATAN2F_XY_INF_NAN_ZERO ;;  // Branch on y nan,inf,zero
}

 
{     .mfi 
     nop.m  999
(p8) fma.s1    atan2f_const_1 =    atan2f_sgn_Y,f0,f0
     nop.i  999
} 
{     .mfi 
     nop.m  999
(p9) fma.s1    atan2f_const_1 =    atan2f_sgn_Y,f1,f0
     nop.i  999 ;;
}

 
{     .mfi 
     nop.m  999
(p6) fnma.s1    atan2f_U       =    atan2f_Z,f1,f0
     nop.i  999
} 
{     .mfi 
     nop.m  999
(p6) fma.s1    atan2f_Usq     =    atan2f_Z,atan2f_Z,f0
     nop.i  999 ;;
} 

 
{     .mfi 
     nop.m  999
(p7) fma.s1    atan2f_U       =    atan2f_A,f1,f0
     nop.i  999
} 
{     .mfi 
     nop.m  999
(p7) fma.s1    atan2f_Usq     =    atan2f_A,atan2f_A,f0
     nop.i  999 ;;
}


{     .mfi 
     nop.m  999
(p6) frcpa.s1  atan2f_Q1,p0    =    f1,atan2f_T_denom
     nop.i  999
} 
{     .mfi 
     nop.m  999
(p6) fma.s1    atan2f_R_denom =   atan2f_T_denom,f1,f0
     nop.i  999 ;;
} 


{     .mfi 
     nop.m  999
(p7) frcpa.s1  atan2f_Q1,p0    =    f1,atan2f_G_denom
     nop.i  999
} 
{     .mfi 
     nop.m  999
(p7) fma.s1    atan2f_R_denom =   atan2f_G_denom,f1,f0
     nop.i  999 ;;
} 


{     .mfi 
     nop.m  999
(p6) fnma.s1    atan2f_R_numer =   atan2f_T_numer,f1,f0
     nop.i  999
} 
{     .mfi 
     nop.m  999
(p7) fma.s1    atan2f_R_numer =   atan2f_G_numer,f1,f0
     nop.i  999 ;;
} 

 
{     .mfi 
     nop.m  999
(p6) fnma.s1    atan2f_p1rnum =   atan2f_T_numer,atan2f_coef_p1,f0
     nop.i  999 ;;
} 
{     .mfi 
     nop.m  999
(p7) fma.s1    atan2f_p1rnum =   atan2f_G_numer,atan2f_coef_p1,f0
     nop.i  999 ;;
} 

 
{     .mfi 
     nop.m  999
     fma.s1    atan2f_U4 =    atan2f_Usq,atan2f_Usq,f0
     nop.i  999
}
{     .mfi 
     nop.m  999
     fma.s1    atan2f_poly_u109 = atan2f_Usq,atan2f_coef_p10,atan2f_coef_p9
     nop.i  999 ;;
} 
 
{     .mfi 
     nop.m  999
     fma.s1    atan2f_poly_u87 =    atan2f_Usq,atan2f_coef_p8,atan2f_coef_p7
     nop.i  999
} 
{     .mfi 
     nop.m  999
     fma.s1    atan2f_poly_u65 =    atan2f_Usq,atan2f_coef_p6,atan2f_coef_p5
     nop.i  999 ;;
}
 
 
{     .mfi 
     nop.m  999
     fma.s1    atan2f_poly_u43 =    atan2f_Usq,atan2f_coef_p4,atan2f_coef_p3
     nop.i  999
} 
{     .mfi 
     nop.m  999
     fnma.s1   atan2f_Q_beta  =    atan2f_Q1,atan2f_R_denom,f1
     nop.i  999 ;;
}


{     .mfi 
     nop.m  999
     fma.s1    atan2f_poly_u21 =    atan2f_Usq,atan2f_coef_p2,atan2f_coef_p1
     nop.i  999
} 
{     .mfi 
     nop.m  999
     fma.s1    atan2f_r  =    atan2f_Q1,atan2f_R_numer,f0
     nop.i  999 ;;
}

{     .mfi 
     nop.m  999
(p6) fma.s1    atan2f_C  =    atan2f_sgn_Y,atan2f_const_piby2,f0
     nop.i  999
} 
{     .mfi 
     nop.m  999
(p7) fma.s1    atan2f_C  =    atan2f_const_1,atan2f_const_pi,f0
     nop.i  999 ;;
} 

{     .mfi 
     nop.m  999
     fma.s1    atan2f_U6 =    atan2f_U4,atan2f_Usq,f0
     nop.i  999
}
{     .mfi 
     nop.m  999
     fma.s1    atan2f_U8 =    atan2f_U4,atan2f_U4,f0
     nop.i  999 ;;
}

{     .mfi 
     nop.m  999
     fma.s1    atan2f_poly_u10to7 = atan2f_U4,atan2f_poly_u109,atan2f_poly_u87
     nop.i  999
} 
{     .mfi 
     nop.m  999
     fma.s1    atan2f_pR = atan2f_p1rnum,atan2f_Q1,f0
     nop.i  999 ;;
} 

{     .mfi 
     nop.m  999
     fma.s1    atan2f_poly_u6to3 = atan2f_U4,atan2f_poly_u65,atan2f_poly_u43
     nop.i  999
} 
{     .mfi 
     nop.m  999
     fma.s1    atan2f_Q2 =    atan2f_Q1,atan2f_Q_beta,atan2f_Q1
     nop.i  999 ;;
}

{     .mfi 
     nop.m  999
     fma.s1    atan2f_Q_beta2 =    atan2f_Q_beta,atan2f_Q_beta,f0
     nop.i  999
} 
{     .mfi 
     nop.m  999
     fma.s1    atan2f_rsq     =    atan2f_r,atan2f_r,f0
     nop.i  999 ;;
}

{     .mfi 
     nop.m  999
     fma.s1    atan2f_poly_u210 = atan2f_Usq,atan2f_poly_u21,f1
     nop.i  999 ;;
} 
 
{     .mfi
     nop.m 999
     fcmp.eq.s0 p8,p0 = f8,f9      // Dummy op to set flag on denormal inputs
     nop.i 999
}
{     .mfi 
     nop.m  999
     fma.s1 atan2f_poly_u10to3 = atan2f_U8,atan2f_poly_u10to7,atan2f_poly_u6to3
     nop.i  999 ;;
} 

{     .mfi 
     nop.m                 999
     fma.s1    atan2f_Q3 =    atan2f_Q2,atan2f_Q_beta2,atan2f_Q2
     nop.i                 999
} 
{     .mfi 
     nop.m  999
     fma.s1    atan2f_pRC = atan2f_rsq,atan2f_pR,atan2f_C
     nop.i  999 ;;
} 
 
{     .mfi 
     nop.m  999
     fma.s1 atan2f_poly_u10to0 = atan2f_U6,atan2f_poly_u10to3,atan2f_poly_u210
     nop.i  999 ;;
} 

{     .mfi 
     nop.m  999
     fma.s1    atan2f_pQRC = atan2f_R_numer,atan2f_Q3,atan2f_pRC
     nop.i  999 ;;
} 

{     .mfb 
     nop.m  999
     fma.s.s0    f8 = atan2f_U,atan2f_poly_u10to0,atan2f_pQRC
     br.ret.sptk b0 ;;
} 



ATAN2F_XY_INF_NAN_ZERO:

{ .mfi
      nop.m 999
      fclass.m   p10,p0 = f8,0xc3	// Is y nan
      nop.i 999
}
;;

{ .mfi
      nop.m 999
      fclass.m   p12,p0 = f9,0xc3	// Is x nan
      nop.i 999
}
;;

{ .mfi
      nop.m 999
      fclass.m   p6,p0 = f9,0x21	// Is x +inf
      nop.i 999
}
{ .mfb
      nop.m 999
(p10) fma.s f8  = f9,f8,f0          // Result quietized y if y is nan
(p10) br.ret.spnt b0                // Exit if y is nan
}
;;


{ .mfi
      nop.m 999
(p6)  fclass.m.unc   p7,p8 = f8,0x23	// x +inf, is y inf
      nop.i 999
}
{ .mfb
      nop.m 999
(p12) fnorm.s f8 = f9               // Result quietized x if x is nan, y not nan
(p12) br.ret.spnt b0                // Exit if x is nan, y not nan
}
;;

// Here if x or y inf, or x or y zero
{ .mfi
      nop.m 999
      fcmp.eq.s0 p15,p0 = f8,f9     // Dummy op to set flag on denormal inputs
      nop.i 999
}
;;

{ .mfi
      nop.m 999
      fclass.m   p11,p12 = f9,0x22	// Is x -inf
      nop.i 999
}
{ .mfb
      nop.m 999
(p7)  fma.s f8 = atan2f_sgn_Y, atan2f_const_piby4,f0 // Result +-pi/4
(p7)  br.ret.spnt b0            // Exit if x +inf and y inf
}
;;

{ .mfb
      nop.m 999
(p8)  fmerge.s   f8 = f8,f0     // If x +inf and y not inf, result +-0
(p8)  br.ret.spnt b0            // Exit if x +inf and y not inf
}
;;

{ .mfi
      nop.m 999
(p12) fclass.m.unc   p13,p0 = f8,0x23	// x not -inf, is y inf
      nop.i 999
}
;;

{ .mfi
      nop.m 999
(p11) fclass.m.unc   p14,p15 = f8,0x23	// x -inf, is y inf
      nop.i 999
}
;;

{ .mfi
      nop.m 999
      fclass.m  p6,p7 = f9,0x7	// Is x zero
      nop.i 999
}
{ .mfb
      nop.m 999
(p13) fma.s   f8 = atan2f_sgn_Y, atan2f_const_piby2,f0 // Result +-pi/2
(p13) br.ret.spnt b0           // Exit if x not -inf and y inf
}
;;

{ .mfi
      nop.m 999
(p14) fma.s   f8 = atan2f_sgn_Y, atan2f_const_3piby4,f0 // Result +-3pi/4
      nop.i 999
}
{ .mfb
      nop.m 999
(p15) fma.s   f8 = atan2f_sgn_Y, atan2f_const_pi,f0 // Result +-pi
(p11) br.ret.spnt b0           // Exit if x -inf
}
;;

// Here if x or y zero
{ .mfi
      nop.m 999
(p7)  fclass.m.unc   p8,p9 = f9,0x19	// x not zero, y zero, is x > zero
      nop.i 999
}
;;

{ .mfi
      nop.m 999
(p6)  fclass.m.unc   p10,p11 = f8,0x7	// x zero, is y zero
      nop.i 999
}
;;

{ .mfi
      nop.m 999
(p8)  fmerge.s  f8 = f8, f0  // x > zero and y zero, result is +-zero
      nop.i 999
}
{ .mfb
      nop.m 999
(p9)  fma.s  f8 = atan2f_sgn_Y, atan2f_const_pi,f0 // x < 0, y 0, result +-pi
(p10) br.cond.spnt   __libm_error_region // Branch if x zero and y zero
}
;;

{ .mfb
      nop.m 999
(p11) fma.s  f8 = atan2f_sgn_Y, atan2f_const_piby2,f0 // x zero, y not zero
      br.ret.sptk b0         // Final special case exit
}
;;


.endp atan2f


.proc __libm_error_region
__libm_error_region:
.prologue
         mov            GR_Parameter_TAG      = 38
         fclass.m       p10,p11               = f9,0x5	// @zero | @pos
;;
(p10)    fmerge.s       f10                   = f8, f0
(p11)    fma.s          f10                   = atan2f_sgn_Y, atan2f_const_pi,f0
;;

{ .mfi
        add   GR_Parameter_Y=-32,sp             // Parameter 2 value
        nop.f 999
.save   ar.pfs,GR_SAVE_PFS
        mov  GR_SAVE_PFS=ar.pfs                 // Save ar.pfs
}

{ .mfi
.fframe 64
        add sp=-64,sp                           // Create new stack
        nop.f 0
        mov GR_SAVE_GP=gp                       // Save gp
}
;;

{ .mmi
        stfs [GR_Parameter_Y] = f9,16         // Store Parameter 2 on stack
        add GR_Parameter_X = 16,sp              // Parameter 1 address
.save   b0, GR_SAVE_B0
        mov GR_SAVE_B0=b0                       // Save b0
}
;;


.body
{ .mib
        stfs [GR_Parameter_X] = f8            // Store Parameter 1 on stack
        add   GR_Parameter_RESULT = 0,GR_Parameter_Y
        nop.b 0                                 // Parameter 3 address
}
{ .mib
        stfs [GR_Parameter_Y] = f10       // Store Parameter 3 on stack
        add   GR_Parameter_Y = -16,GR_Parameter_Y
        br.call.sptk b0=__libm_error_support#   // Call error handling function
}
;;
{ .mmi
        nop.m 0
        nop.m 0
        add   GR_Parameter_RESULT = 48,sp
};;

{ .mmi
        ldfs  f8 = [GR_Parameter_RESULT]       // Get return result off stack
.restore
        add   sp = 64,sp                       // Restore stack pointer
        mov   b0 = GR_SAVE_B0                  // Restore return address
}
;;

{ .mib
        mov   gp = GR_SAVE_GP                  // Restore gp
        mov   ar.pfs = GR_SAVE_PFS             // Restore ar.pfs
        br.ret.sptk     b0                     // Return
}
;;

.endp __libm_error_region

.type   __libm_error_support#,@function
.global __libm_error_support#
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\ia64\ceil.s ===
.file "ceil.s"

// Copyright (c) 2000, Intel Corporation
// All rights reserved.
// 
// Contributed 2/2/2000 by John Harrison, Ted Kubaska, Bob Norin, Shane Story,
// and Ping Tak Peter Tang of the Computational Software Lab, Intel Corporation.
// 
// WARRANTY DISCLAIMER
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS 
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY 
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
// 
// Intel Corporation is the author of this code, and requests that all
// problem reports or change requests be submitted to it directly at 
// http://developer.intel.com/opensource.
//
.align 32
.global ceil#

.section .text
.proc  ceil#
.align 32

// History
//==============================================================
// 2/02/00: Initial version
// 6/13/00: Improved speed
// 6/27/00: Eliminated incorrect invalid flag setting

// API
//==============================================================
// double ceil(double x)

// general input registers:  

ceil_GR_FFFF      = r14
ceil_GR_signexp   = r15
ceil_GR_exponent  = r16
ceil_GR_expmask   = r17
ceil_GR_bigexp    = r18


// predicate registers used: 

// p6  ==> Input is NaN, infinity, zero
// p7  ==> Input is denormal
// p8  ==> Input is <0
// p9  ==> Input is >=0
// p10 ==> Input is already an integer (bigger than largest integer)
// p11 ==> Input is not a large integer
// p12 ==> Input is a smaller integer
// p13 ==> Input is not an even integer, so inexact must be set
// p14 ==> Input is between -1 and 0, so result will be -0 and inexact


// floating-point registers used: 

CEIL_SIGNED_ZERO  = f7
CEIL_NORM_f8      = f9                        
CEIL_FFFF         = f10 
CEIL_INEXACT      = f11 
CEIL_FLOAT_INT_f8 = f12
CEIL_INT_f8       = f13
CEIL_adj          = f14
CEIL_MINUS_ONE    = f15

// Overview of operation
//==============================================================

// double ceil(double x)
// Return an integer value (represented as a double) that is the smallest 
// value not less than x
// This is x rounded toward +infinity to an integral value.
// Inexact is set if x != ceil(x)
// **************************************************************************

// Set denormal flag for denormal input and
// and take denormal fault if necessary.

// Is the input an integer value already?

// double_extended
// if the exponent is > 1003e => 3F(true) = 63(decimal)
// we have a significand of 64 bits 1.63-bits.
// If we multiply by 2^63, we no longer have a fractional part
// So input is an integer value already.

// double
// if the exponent is >= 10033 => 34(true) = 52(decimal)
// 34 + 3ff = 433
// we have a significand of 53 bits 1.52-bits. (implicit 1)
// If we multiply by 2^52, we no longer have a fractional part
// So input is an integer value already.

// single
// if the exponent is > 10016 => 17(true) = 23(decimal)
// we have a significand of 24 bits 1.23-bits. (implicit 1)
// If we multiply by 2^23, we no longer have a fractional part
// So input is an integer value already.

// If x is NAN, ZERO, or INFINITY, then  return

// qnan snan inf norm     unorm 0 -+
// 1    1    1   0        0     1 11     0xe7


ceil:

{ .mfi
      getf.exp ceil_GR_signexp  = f8
      fcvt.fx.trunc.s1     CEIL_INT_f8  = f8
      addl        ceil_GR_bigexp = 0x10033, r0
}
{ .mfi
      addl        ceil_GR_FFFF      = -1,r0
      fcmp.lt.s1  p8,p9 = f8,f0
      mov         ceil_GR_expmask    = 0x1FFFF ;;
}

// p7 ==> denorm
{ .mfi
      setf.sig    CEIL_FFFF  = ceil_GR_FFFF
      fclass.m    p7,p0 = f8, 0x0b
      nop.i 999
}
{ .mfi
      nop.m 999
      fnorm           CEIL_NORM_f8  = f8
      nop.i 999 ;;
}

// Form 0 with sign of input in case negative zero is needed
{ .mfi
      nop.m 999
      fmerge.s           CEIL_SIGNED_ZERO = f8, f0
      nop.i 999
}
{ .mfi
      nop.m 999
      fsub.s1           CEIL_MINUS_ONE = f0, f1
      nop.i 999 ;;
}

// p6 ==> NAN, INF, ZERO
{ .mfb
      nop.m 999
      fclass.m      p6,p10 = f8, 0xe7
(p7)  br.cond.spnt  CEIL_DENORM ;;
}

.pred.rel "mutex",p8,p9
CEIL_COMMON:
// Set adjustment to add to trunc(x) for result
//   If x>0,  adjustment is 1.0
//   If x<=0, adjustment is 0.0
{ .mfi
      and      ceil_GR_exponent = ceil_GR_signexp, ceil_GR_expmask
(p9)  fadd.s1  CEIL_adj = f1,f0
      nop.i 999
}
{ .mfi
      nop.m 999
(p8)  fadd.s1  CEIL_adj = f0,f0
      nop.i 999 ;;
}

{ .mfi
(p10) cmp.ge.unc    p10,p11 = ceil_GR_exponent, ceil_GR_bigexp
(p6)  fnorm.d f8 = f8
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p11) fcvt.xf         CEIL_FLOAT_INT_f8   = CEIL_INT_f8
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p10) fnorm.d f8 = CEIL_NORM_f8
      nop.i 999 ;;
}

// Is -1 < x < 0?  If so, result will be -0.  Special case it with p14 set.
{ .mfi
      nop.m 999
(p8)  fcmp.gt.unc.s1 p14,p0 = CEIL_NORM_f8, CEIL_MINUS_ONE
      nop.i 999 ;;
}

{ .mfi
(p14) cmp.ne  p11,p0 = r0,r0
(p14) fnorm.d f8 = CEIL_SIGNED_ZERO
      nop.i 999
}
{ .mfi
      nop.m 999
(p14) fmpy.s0     CEIL_INEXACT = CEIL_FFFF,CEIL_FFFF
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p11) fadd.d   f8 = CEIL_FLOAT_INT_f8,CEIL_adj
      nop.i 999 ;;
}
{ .mfi
      nop.m 999
(p11) fcmp.eq.unc.s1  p12,p13  = CEIL_FLOAT_INT_f8, CEIL_NORM_f8
      nop.i 999 ;;
}

// Set inexact if result not equal to input
{ .mfi
      nop.m 999
(p13) fmpy.s0     CEIL_INEXACT = CEIL_FFFF,CEIL_FFFF
      nop.i 999
}
// Set result to input if integer
{ .mfb
      nop.m 999
(p12) fnorm.d f8 = CEIL_NORM_f8
      br.ret.sptk    b0 ;;
}

// Here if input denorm
CEIL_DENORM:
{ .mfb
      getf.exp ceil_GR_signexp  = CEIL_NORM_f8
      fcvt.fx.trunc.s1     CEIL_INT_f8  = CEIL_NORM_f8
      br.cond.sptk  CEIL_COMMON ;;
}

.endp ceil
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\ia64\atanf.s ===
.file "atanf.s"

// Copyright (c) 2000, 2001, Intel Corporation
// All rights reserved.
//
// Contributed 2/2/2000 by John Harrison, Ted Kubaska, Bob Norin, Shane Story,
// and Ping Tak Peter Tang of the Computational Software Lab, Intel Corporation.
//
// WARRANTY DISCLAIMER
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// Intel Corporation is the author of this code, and requests that all
// problem reports or change requests be submitted to it directly at
// http://developer.intel.com/opensource.


// History
//==============================================================
// 2/20/00  Initial version
// 8/17/00  Changed predicate register macro-usage to direct predicate
//          names due to an assembler bug.

//
// Assembly macros
//==============================================================

// integer registers used
EXP_Addr1          = r33
EXP_Addr2          = r34

// floating point registers used
atanf_coeff_R4     = f32
atanf_coeff_R5     = f33
atanf_coeff_R1     = f34
atanf_coeff_R2     = f35

atanf_coeff_R3     = f36
atanf_coeff_P1     = f37
atanf_coeff_Q6     = f38
atanf_coeff_Q7     = f39
atanf_coeff_Q8     = f40

atanf_coeff_Q9     = f41
atanf_coeff_Q4     = f42
atanf_coeff_Q5     = f43
atanf_coeff_Q2     = f44
atanf_coeff_Q3     = f45

atanf_coeff_P5     = f46
atanf_coeff_P6     = f47
atanf_coeff_Q0     = f48
atanf_coeff_Q1     = f49
atanf_coeff_P7     = f50

atanf_coeff_P8     = f51
atanf_coeff_P3     = f52
atanf_coeff_P4     = f53
atanf_coeff_P9     = f54
atanf_coeff_P10    = f55

atanf_coeff_P2     = f56
atanf_piby2        = f57
atanf_z            = f58
atanf_b            = f59
atanf_zsq          = f60

atanf_sgn_x        = f61
atanf_sgnx_piby2   = f62
atanf_abs_x        = f63
atanf_t            = f64
atanf_xcub         = f65

atanf_tsq          = f66
atanf_t4           = f67
atanf_x5           = f68
atanf_x6           = f69
atanf_x11          = f70

atanf_poly_p1      = f71
atanf_poly_p2      = f72
atanf_poly_p3      = f73
atanf_poly_p4      = f74
atanf_poly_p5      = f75

atanf_poly_q1      = f76
atanf_poly_q2      = f77
atanf_poly_q3      = f78
atanf_poly_q4      = f79
atanf_poly_q5      = f80

atanf_poly_q       = f81
atanf_poly_r1      = f81
atanf_poly_r2      = f82
atanf_poly_r3      = f83
atanf_bsq          = f84
atanf_z4           = f85

atanf_z5           = f86
atanf_z8           = f87
atanf_z13          = f88
atanf_poly_r2      = f89
atanf_poly_r1      = f90

atanf_z8_bsq       = f91
atanf_poly_r       = f92
atanf_z21_poly_r   = f93
atanf_answer       = f8


// predicate registers used
//atanf_pred_LE1     = p6
//atanf_pred_GT1     = p7


.data

.align 16

atanf_coeff_1_table:
data8 0x40c4c241be751ff2  // r4
data8 0x40e9f300c2f3070b  // r5
data8 0x409babffef772075  // r3
data8 0xbfd5555512191621  // p1
data8 0x3fc9997e7afbff4e  // p2  = q8
data8 0xbfd5555512191621  // p1  = q9
data8 0x3f97105b4160f86b  // p8  = q2
data8 0xbfa6e10ba401393f  // p7  = q3
data8 0x3f522e5d33bc9baa  // p10 = q0
data8 0xbf7deaadaa336451  // p9  = q1
data8 0xbfc2473c5145ee38  // p3
data8 0x3fbc4f512b1865f5  // p4
data8 0x3fc9997e7afbff4e  // p2
data8 0x3ff921fb54442d18  // pi/2



atanf_coeff_2_table:
data8 0x4035000000004284  // r1
data8 0x406cdffff336a59b  // r2
data8 0x3fbc4f512b1865f5  // p4 = q6
data8 0xbfc2473c5145ee38  // p3 = q7
data8 0x3fb142a73d7c54e3  // p6 = q4
data8 0xbfb68eed6a8cfa32  // p5 = q5
data8 0xbfb68eed6a8cfa32  // p5
data8 0x3fb142a73d7c54e3  // p6
data8 0xbfa6e10ba401393f  // p7
data8 0x3f97105b4160f86b  // p8
data8 0xbf7deaadaa336451  // p9
data8 0x3f522e5d33bc9baa  // p10



.global atanf 

.text
.proc  atanf

.align 32
atanf:


{     .mfi 
     alloc      r32                  = ar.pfs,1,2,0,0
     frcpa.s1  atanf_z,p0   =    f1,f8
     addl      EXP_Addr2           =    @ltoff(atanf_coeff_2_table),gp
} 
{     .mfi 
     addl      EXP_Addr1 =    @ltoff(atanf_coeff_1_table),gp
     fma.s1    atanf_t   =    f8,f8,f0
     nop.i                 999;;
}

 
{     .mfi 
     nop.m                      999
     fmerge.s  atanf_sgn_x    =    f8,f1
     nop.i                      999;;
} 
 
{     .mfi 
     ld8       EXP_Addr1      =    [EXP_Addr1]
     fmerge.s  atanf_abs_x    =    f1,f8
     nop.i                      999
} 
{     .mfi 
     ld8       EXP_Addr2 =    [EXP_Addr2]
     nop.f                 999
     nop.i                 999;;
}

 
{     .mfi 
     nop.m                      999
     fclass.m  p8,p0   =    f8,0x7	// @zero
     nop.i                      999;;
} 
 
{     .mfi 
     nop.m                      999
     fcmp.eq.unc.s0 p9,p10    =    f8,f1
     nop.i                      999;;
} 
 
{     .mfi 
     ldfpd     atanf_coeff_R4,atanf_coeff_R5 =    [EXP_Addr1],16
     fnma.s1   atanf_b                       =    f8,atanf_z,f1
     nop.i                                     999
} 
{     .mfi 
     ldfpd     atanf_coeff_R1,atanf_coeff_R2 =    [EXP_Addr2],16
     fma.s1    atanf_zsq                     =    atanf_z,atanf_z,f0
     nop.i                                     999;;
}

 
{     .mfi 
     ldfpd     atanf_coeff_R3,atanf_coeff_P1 =    [EXP_Addr1],16
     fma.s1    atanf_xcub                    =    f8,atanf_t,f0
     nop.i                                     999
} 
{     .mfi 
     ldfpd     atanf_coeff_Q6,atanf_coeff_Q7 =    [EXP_Addr2],16
     fma.s1    atanf_tsq                     =    atanf_t,atanf_t,f0
     nop.i                                     999;;
}

 
{     .mfi 
     ldfpd          atanf_coeff_Q8,atanf_coeff_Q9 =    [EXP_Addr1],16
//     fcmp.le.s1     atanf_pred_LE1,atanf_pred_GT1 =    atanf_abs_x,f1
     fcmp.le.s1     p6,p7 =    atanf_abs_x,f1
     nop.i                                          999
} 
{     .mfi 
     ldfpd     atanf_coeff_Q4,atanf_coeff_Q5 =    [EXP_Addr2],16
     nop.f                                     999
     nop.i                                     999;;
}

 
{     .mfi 
     ldfpd     atanf_coeff_Q2,atanf_coeff_Q3 =    [EXP_Addr1],16
     fclass.m  p8,p0                  =    f8,0xe7	// @inf|@qnan|@snan|@zero
     nop.i                                     999
} 
{     .mfi 
     ldfpd     atanf_coeff_P5,atanf_coeff_P6 =    [EXP_Addr2],16
     nop.f                                     999
     nop.i                                     999;;
}

 
{     .mfi 
     ldfpd     atanf_coeff_Q0,atanf_coeff_Q1 =    [EXP_Addr1],16
     nop.f                                     999
     nop.i                                     999
} 
{     .mfi 
     ldfpd     atanf_coeff_P7,atanf_coeff_P8 =    [EXP_Addr2],16
     nop.f                                     999
     nop.i                                     999;;
}

 
{     .mfi 
     ldfpd     atanf_coeff_P3,atanf_coeff_P4 =    [EXP_Addr1],16
     fma.s1    atanf_bsq                     =    atanf_b,atanf_b,f0
     nop.i                                     999
} 
{     .mfi 
     ldfpd     atanf_coeff_P9,atanf_coeff_P10     =    [EXP_Addr2]
     fma.s1    atanf_z4                           =    atanf_zsq,atanf_zsq,f0
     nop.i                                          999;;
}

 
{     .mfi 
     ldfpd     atanf_coeff_P2,atanf_piby2    =    [EXP_Addr1]
     fma.s1    atanf_x6                      =    atanf_t,atanf_tsq,f0
     nop.i                                     999
} 
{     .mfi 
     nop.m                 999
     fma.s1    atanf_t4  =    atanf_tsq,atanf_tsq,f0
     nop.i                 999;;
}

 
{     .mfb 
     nop.m                 999
     fma.s1    atanf_x5  =    atanf_t,atanf_xcub,f0
(p8)  br.cond.spnt   ATANF_X_INF_NAN_ZERO
} 
;;
 
{     .mfi 
     nop.m                      999
     fma.s1    atanf_poly_r1  =    atanf_b,atanf_coeff_R1,f1
     nop.i                      999
} 
{     .mfi 
     nop.m                      999
     fma.s1    atanf_poly_r3  =    atanf_b,atanf_coeff_R5,atanf_coeff_R4
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                      999
     fma.s1    atanf_poly_r2  =    atanf_b,atanf_coeff_R3,atanf_coeff_R2
     nop.i                      999
} 
{     .mfi 
     nop.m                 999
     fma.s1    atanf_z8  =    atanf_z4,atanf_z4,f0
     nop.i                 999;;
}

 
{     .mfi 
     nop.m                      999
     fma.s1    atanf_poly_q2  =    atanf_t,atanf_coeff_Q5,atanf_coeff_Q4
     nop.i                      999
} 
{     .mfi 
     nop.m                      999
     fma.s1    atanf_poly_q3  =    atanf_t,atanf_coeff_Q7,atanf_coeff_Q6
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                 999
     fma.s1    atanf_z5  =    atanf_z,atanf_z4,f0
     nop.i                 999
} 
{     .mfi 
     nop.m                      999
     fma.s1    atanf_poly_q1  =    atanf_t,atanf_coeff_Q9,atanf_coeff_Q8
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                      999
     fma.s1    atanf_poly_q4  =    atanf_t,atanf_coeff_Q1,atanf_coeff_Q0
     nop.i                      999
} 
{     .mfi 
     nop.m                      999
     fma.s1    atanf_poly_q5  =    atanf_t,atanf_coeff_Q3,atanf_coeff_Q2
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                      999
     fma.s1    atanf_poly_p4  =    f8,atanf_coeff_P1,f0
     nop.i                      999
} 
{     .mfi 
     nop.m                      999
     fma.s1    atanf_poly_p5  =    atanf_t,atanf_coeff_P4,atanf_coeff_P3
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                      999
     fma.s1    atanf_poly_r1  =    atanf_z8,atanf_poly_r1,f0
     nop.i                      999
} 
{     .mfi 
     nop.m                      999
     fma.s1    atanf_z8_bsq   =    atanf_z8,atanf_bsq,f0
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                      999
     fma.s1    atanf_poly_q2  =    atanf_tsq,atanf_poly_q3,atanf_poly_q2
     nop.i                      999
} 
{     .mfi 
     nop.m                      999
     fma.s1    atanf_poly_r2  =    atanf_bsq,atanf_poly_r3,atanf_poly_r2
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                      999
     fma.s1    atanf_poly_p2  =    atanf_t,atanf_coeff_P8,atanf_coeff_P7
     nop.i                      999
} 
{     .mfi 
     nop.m                      999
     fma.s1    atanf_poly_q1  =    atanf_poly_q1,f1,atanf_tsq
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                 999
     fma.s1    atanf_z13 =    atanf_z5,atanf_z8,f0
     nop.i                 999
} 
{     .mfi 
     nop.m                      999
     fma.s1    atanf_poly_p1  =    atanf_t,atanf_coeff_P10,atanf_coeff_P9
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                      999
     fma.s1    atanf_poly_p4  =    atanf_t,atanf_poly_p4,f8
     nop.i                      999
} 
{     .mfi 
     nop.m                      999
     fma.s1    atanf_poly_q4  =    atanf_tsq,atanf_poly_q5,atanf_poly_q4
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                      999
     fma.s1    atanf_poly_p3  =    atanf_t,atanf_coeff_P6,atanf_coeff_P5
     nop.i                      999
} 
{     .mfi 
     nop.m                      999
     fma.s1    atanf_poly_p5  =    atanf_t,atanf_poly_p5,atanf_coeff_P2
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                 999
     fma.s1    atanf_x11 =    atanf_x5,atanf_x6,f0
     nop.i                 999
} 
{     .mfi 
     nop.m                      999
     fma.s1    atanf_poly_r   =    atanf_z8_bsq,atanf_poly_r2,atanf_poly_r1
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                           999
     fma       atanf_sgnx_piby2    =    atanf_sgn_x,atanf_piby2,f0
     nop.i                           999
} 
{     .mfi 
     nop.m                      999
     fma.s1    atanf_poly_q2  =    atanf_t4,atanf_poly_q1,atanf_poly_q2
     nop.i                      999;;
}

 
{     .mfi 
     nop.m                      999
     fma.s1    atanf_poly_p1  =    atanf_tsq,atanf_poly_p1,atanf_poly_p2
     nop.i                      999;;
} 
 
{     .mfi 
     nop.m                      999
     fma.s1    atanf_poly_p4  =    atanf_x5,atanf_poly_p5,atanf_poly_p4
     nop.i                      999;;
} 
 
{     .mfi 
     nop.m                           999
     fma.s1    atanf_z21_poly_r    =    atanf_z13,atanf_poly_r,f0
     nop.i                           999;;
} 
 
{     .mfi 
     nop.m                      999
     fma.s1    atanf_poly_q   =    atanf_t4,atanf_poly_q2,atanf_poly_q4
     nop.i                      999;;
} 
 
{     .mfi 
     nop.m                      999
     fma.s1    atanf_poly_p1  =    atanf_tsq,atanf_poly_p1,atanf_poly_p3
     nop.i                      999;;
} 
 
{     .mfi 
                    nop.m                      999
//(atanf_pred_GT1)    fnma.s    atanf_answer   =    atanf_poly_q,atanf_z21_poly_r,atanf_sgnx_piby2
(p7)    fnma.s    atanf_answer   =    atanf_poly_q,atanf_z21_poly_r,atanf_sgnx_piby2
                    nop.i                      999;;
} 
 
{     .mfb 
                    nop.m                      999
//(atanf_pred_LE1)    fma.s     atanf_answer   =    atanf_x11,atanf_poly_p1,atanf_poly_p4
(p6)    fma.s     atanf_answer   =    atanf_x11,atanf_poly_p1,atanf_poly_p4
                    br.ret.sptk b0
} 



ATANF_X_INF_NAN_ZERO:

      fclass.m p8,p9 = f8,0x23	// @inf
;;
(p8)  fmerge.s f8 = f8, atanf_piby2
;;
      fnorm.s f8 = f8
      br.ret.sptk b0

.endp atanf
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\ia64\cosh.s ===
.file "cosh.s"

// Copyright (c) 2000, 2001, Intel Corporation
// All rights reserved.
// 
// Contributed 2/2/2000 by John Harrison, Ted Kubaska, Bob Norin, Shane Story,
// and Ping Tak Peter Tang of the Computational Software Lab, Intel Corporation.
// 
// WARRANTY DISCLAIMER
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS 
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY 
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
// 
// Intel Corporation is the author of this code, and requests that all
// problem reports or change requests be submitted to it directly at 
// http://developer.intel.com/opensource.
//
// History
//==============================================================
// 2/02/00  Initial version 
// 4/04/00  Unwind support added
// 8/15/00  Bundle added after call to __libm_error_support to properly
//          set [the previously overwritten] GR_Parameter_RESULT.
// 5/07/01  Reworked to improve speed of all paths
//
// API
//==============================================================
// double = cosh(double)
// input  floating point f8
// output floating point f8
//
// Registers used
//==============================================================
// general registers: 
// r32 -> r47
// predicate registers used:
// p6 -> p11
// floating-point registers used:
// f9 -> f15; f32 -> f90; 
// f8 has input, then output
//
// Overview of operation
//==============================================================
// There are seven paths
// 1. 0 < |x| < 0.25          COSH_BY_POLY
// 2. 0.25 <=|x| < 32         COSH_BY_TBL
// 3. 32 <= |x| < 710.47586   COSH_BY_EXP (merged path with COSH_BY_TBL)
// 4. |x| >= 710.47586        COSH_HUGE
// 5. x=0                     Done with early exit
// 6. x=inf,nan               Done with early exit
// 7. x=denormal              COSH_DENORM
//
// For double we get overflow for x >= 4008 b19e 747d cfc3 ed8b
//                                  >= 710.475860073
//
//
// 1. COSH_BY_POLY   0 < |x| < 0.25
// ===============
// Evaluate cosh(x) by a 12th order polynomial
// Care is take for the order of multiplication; and P2 is not exactly 1/4!, 
// P3 is not exactly 1/6!, etc.
// cosh(x) = 1 + (P1*x^2 + P2*x^4 + P3*x^6 + P4*x^8 + P5*x^10 + P6*x^12)
//
// 2. COSH_BY_TBL   0.25 <= |x| < 32.0
// =============
// cosh(x) = cosh(B+R)
//         = cosh(B)cosh(R) + sinh(B)sinh(R)
// 
// ax = |x| = M*log2/64 + R
// B = M*log2/64
// M = 64*N + j 
//   We will calculate M and get N as (M-j)/64
//   The division is a shift.
// exp(B)  = exp(N*log2 + j*log2/64)
//         = 2^N * 2^(j*log2/64)
// cosh(B) = 1/2(e^B + e^-B)
//         = 1/2(2^N * 2^(j*log2/64) + 2^-N * 2^(-j*log2/64)) 
// cosh(B) = (2^(N-1) * 2^(j*log2/64) + 2^(-N-1) * 2^(-j*log2/64)) 
// sinh(B) = (2^(N-1) * 2^(j*log2/64) - 2^(-N-1) * 2^(-j*log2/64)) 
// 2^(j*log2/64) is stored as Tjhi + Tjlo , j= -32,....,32
// Tjhi is double-extended (80-bit) and Tjlo is single(32-bit)
//
// R = ax - M*log2/64
// R = ax - M*log2_by_64_hi - M*log2_by_64_lo
// exp(R) = 1 + R +R^2(1/2! + R(1/3! + R(1/4! + ... + R(1/n!)...)
//        = 1 + p_odd + p_even
//        where the p_even uses the A coefficients and the p_even uses 
//        the B coefficients
//
// So sinh(R) = 1 + p_odd + p_even -(1 -p_odd -p_even)/2 = p_odd
//    cosh(R) = 1 + p_even
//    cosh(B) = C_hi + C_lo
//    sinh(B) = S_hi
// cosh(x) = cosh(B)cosh(R) + sinh(B)sinh(R)
//
// 3. COSH_BY_EXP   32.0 <= |x| < 710.47586    ( 4008 b19e 747d cfc3 ed8b )
// ==============
// Can approximate result by exp(x)/2 in this region.
// Y_hi = Tjhi
// Y_lo = Tjhi * (p_odd + p_even) + Tjlo
// cosh(x) = Y_hi + Y_lo
//
// 4. COSH_HUGE     |x| >= 710.47586    ( 4008 b19e 747d cfc3 ed8b )
// ============
// Set error tag and call error support
//
//
// Assembly macros
//==============================================================
cosh_GR_ad1          = r34
cosh_GR_Mmj          = r34
cosh_GR_jshf         = r36
cosh_GR_M            = r35
cosh_GR_N            = r35
cosh_GR_exp_2tom57   = r36
cosh_GR_j            = r36
cosh_GR_joff         = r36
cosh_GR_exp_mask     = r37
cosh_GR_mJ           = r38
cosh_AD_mJ           = r38
cosh_GR_signexp_x    = r38
cosh_GR_signexp_0_5  = r38
cosh_GR_exp_0_25     = r39
cosh_GR_J            = r39
cosh_AD_J            = r39
cosh_GR_sig_inv_ln2  = r40
cosh_GR_exp_32       = r40
cosh_GR_exp_huge     = r40
cosh_GR_all_ones     = r40

cosh_GR_ad2e         = r41
cosh_GR_ad3          = r42
cosh_GR_ad4          = r43
cosh_GR_rshf         = r44
cosh_GR_ad2o         = r45
cosh_GR_rshf_2to57   = r46
cosh_GR_exp_denorm   = r46
cosh_GR_exp_x        = r47


GR_SAVE_PFS          = r41
GR_SAVE_B0           = r42
GR_SAVE_GP           = r43

GR_Parameter_X       = r44
GR_Parameter_Y       = r45
GR_Parameter_RESULT  = r46
GR_Parameter_TAG     = r47


cosh_FR_ABS_X        = f9 
cosh_FR_X2           = f10
cosh_FR_X4           = f11
cosh_FR_all_ones     = f13
cosh_FR_tmp          = f14
cosh_FR_RSHF         = f15

cosh_FR_Inv_log2by64 = f32
cosh_FR_log2by64_lo  = f33
cosh_FR_log2by64_hi  = f34
cosh_FR_A1           = f35

cosh_FR_A2           = f36
cosh_FR_A3           = f37
cosh_FR_Rcub         = f38
cosh_FR_M_temp       = f39
cosh_FR_R_temp       = f40

cosh_FR_Rsq          = f41
cosh_FR_R            = f42
cosh_FR_M            = f43
cosh_FR_B1           = f44
cosh_FR_B2           = f45

cosh_FR_B3           = f46
cosh_FR_peven_temp1  = f47
cosh_FR_peven_temp2  = f48
cosh_FR_peven        = f49
cosh_FR_podd_temp1   = f50

cosh_FR_podd_temp2   = f51
cosh_FR_podd         = f52
cosh_FR_poly65       = f53
cosh_FR_poly6543     = f53
cosh_FR_poly6to1     = f53
cosh_FR_poly43       = f54
cosh_FR_poly21       = f55

cosh_FR_INV_LN2_2TO63= f57
cosh_FR_RSHF_2TO57   = f58
cosh_FR_2TOM57       = f59
cosh_FR_smlst_oflow_input = f60

cosh_FR_pre_result   = f61
cosh_FR_huge         = f62
cosh_FR_spos         = f63
cosh_FR_sneg         = f64
cosh_FR_Tjhi         = f65

cosh_FR_Tjlo         = f66
cosh_FR_Tmjhi        = f67
cosh_FR_Tmjlo        = f68
cosh_FR_S_hi         = f69
cosh_FR_SC_hi_temp   = f70

cosh_FR_C_lo_temp1   = f71 
cosh_FR_C_lo_temp2   = f72 
cosh_FR_C_lo_temp3   = f73 
cosh_FR_C_lo_temp4   = f73 
cosh_FR_C_lo         = f74
cosh_FR_C_hi         = f75

cosh_FR_C_hi_temp1   = f76
cosh_FR_Y_hi         = f77 
cosh_FR_Y_lo_temp    = f78 
cosh_FR_Y_lo         = f79 
cosh_FR_NORM_X       = f80

cosh_FR_P1           = f81
cosh_FR_P2           = f82
cosh_FR_P3           = f83
cosh_FR_P4           = f84
cosh_FR_P5           = f85

cosh_FR_P6           = f86
cosh_FR_Tjhi_spos    = f87
cosh_FR_Tjlo_spos    = f88
cosh_FR_huge         = f89
cosh_FR_signed_hi_lo = f90


// Data tables
//==============================================================

// DO NOT CHANGE ORDER OF THESE TABLES
.data

.align 16
double_cosh_arg_reduction:
//   data8 0xB8AA3B295C17F0BC, 0x00004005  // 64/log2 -- signif loaded with setf
   data8 0xB17217F7D1000000, 0x00003FF8  // log2/64 high part
   data8 0xCF79ABC9E3B39804, 0x00003FD0  // log2/64 low part

double_cosh_p_table:
   data8 0xb19e747dcfc3ed8b, 0x00004008  // Smallest x to overflow (710.47586)
   data8 0x8FA02AC65BCBD5BC, 0x00003FE2  // P6
   data8 0xD00D00D1021D7370, 0x00003FEF  // P4
   data8 0xAAAAAAAAAAAAAB80, 0x00003FFA  // P2
   data8 0x93F27740C0C2F1CC, 0x00003FE9  // P5
   data8 0xB60B60B60B4FE884, 0x00003FF5  // P3
   data8 0x8000000000000000, 0x00003FFE  // P1

double_cosh_ab_table:
   data8 0xAAAAAAAAAAAAAAAC, 0x00003FFC  // A1
   data8 0x88888888884ECDD5, 0x00003FF8  // A2
   data8 0xD00D0C6DCC26A86B, 0x00003FF2  // A3
   data8 0x8000000000000002, 0x00003FFE  // B1
   data8 0xAAAAAAAAAA402C77, 0x00003FFA  // B2
   data8 0xB60B6CC96BDB144D, 0x00003FF5  // B3

double_cosh_j_table:
   data8 0xB504F333F9DE6484, 0x00003FFE, 0x1EB2FB13, 0x00000000
   data8 0xB6FD91E328D17791, 0x00003FFE, 0x1CE2CBE2, 0x00000000
   data8 0xB8FBAF4762FB9EE9, 0x00003FFE, 0x1DDC3CBC, 0x00000000
   data8 0xBAFF5AB2133E45FB, 0x00003FFE, 0x1EE9AA34, 0x00000000
   data8 0xBD08A39F580C36BF, 0x00003FFE, 0x9EAEFDC1, 0x00000000
   data8 0xBF1799B67A731083, 0x00003FFE, 0x9DBF517B, 0x00000000
   data8 0xC12C4CCA66709456, 0x00003FFE, 0x1EF88AFB, 0x00000000
   data8 0xC346CCDA24976407, 0x00003FFE, 0x1E03B216, 0x00000000
   data8 0xC5672A115506DADD, 0x00003FFE, 0x1E78AB43, 0x00000000
   data8 0xC78D74C8ABB9B15D, 0x00003FFE, 0x9E7B1747, 0x00000000
   data8 0xC9B9BD866E2F27A3, 0x00003FFE, 0x9EFE3C0E, 0x00000000
   data8 0xCBEC14FEF2727C5D, 0x00003FFE, 0x9D36F837, 0x00000000
   data8 0xCE248C151F8480E4, 0x00003FFE, 0x9DEE53E4, 0x00000000
   data8 0xD06333DAEF2B2595, 0x00003FFE, 0x9E24AE8E, 0x00000000
   data8 0xD2A81D91F12AE45A, 0x00003FFE, 0x1D912473, 0x00000000
   data8 0xD4F35AABCFEDFA1F, 0x00003FFE, 0x1EB243BE, 0x00000000
   data8 0xD744FCCAD69D6AF4, 0x00003FFE, 0x1E669A2F, 0x00000000
   data8 0xD99D15C278AFD7B6, 0x00003FFE, 0x9BBC610A, 0x00000000
   data8 0xDBFBB797DAF23755, 0x00003FFE, 0x1E761035, 0x00000000
   data8 0xDE60F4825E0E9124, 0x00003FFE, 0x9E0BE175, 0x00000000
   data8 0xE0CCDEEC2A94E111, 0x00003FFE, 0x1CCB12A1, 0x00000000
   data8 0xE33F8972BE8A5A51, 0x00003FFE, 0x1D1BFE90, 0x00000000
   data8 0xE5B906E77C8348A8, 0x00003FFE, 0x1DF2F47A, 0x00000000
   data8 0xE8396A503C4BDC68, 0x00003FFE, 0x1EF22F22, 0x00000000
   data8 0xEAC0C6E7DD24392F, 0x00003FFE, 0x9E3F4A29, 0x00000000
   data8 0xED4F301ED9942B84, 0x00003FFE, 0x1EC01A5B, 0x00000000
   data8 0xEFE4B99BDCDAF5CB, 0x00003FFE, 0x1E8CAC3A, 0x00000000
   data8 0xF281773C59FFB13A, 0x00003FFE, 0x9DBB3FAB, 0x00000000
   data8 0xF5257D152486CC2C, 0x00003FFE, 0x1EF73A19, 0x00000000
   data8 0xF7D0DF730AD13BB9, 0x00003FFE, 0x9BB795B5, 0x00000000
   data8 0xFA83B2DB722A033A, 0x00003FFE, 0x1EF84B76, 0x00000000
   data8 0xFD3E0C0CF486C175, 0x00003FFE, 0x9EF5818B, 0x00000000
   data8 0x8000000000000000, 0x00003FFF, 0x00000000, 0x00000000
   data8 0x8164D1F3BC030773, 0x00003FFF, 0x1F77CACA, 0x00000000
   data8 0x82CD8698AC2BA1D7, 0x00003FFF, 0x1EF8A91D, 0x00000000
   data8 0x843A28C3ACDE4046, 0x00003FFF, 0x1E57C976, 0x00000000
   data8 0x85AAC367CC487B15, 0x00003FFF, 0x9EE8DA92, 0x00000000
   data8 0x871F61969E8D1010, 0x00003FFF, 0x1EE85C9F, 0x00000000
   data8 0x88980E8092DA8527, 0x00003FFF, 0x1F3BF1AF, 0x00000000
   data8 0x8A14D575496EFD9A, 0x00003FFF, 0x1D80CA1E, 0x00000000
   data8 0x8B95C1E3EA8BD6E7, 0x00003FFF, 0x9D0373AF, 0x00000000
   data8 0x8D1ADF5B7E5BA9E6, 0x00003FFF, 0x9F167097, 0x00000000
   data8 0x8EA4398B45CD53C0, 0x00003FFF, 0x1EB70051, 0x00000000
   data8 0x9031DC431466B1DC, 0x00003FFF, 0x1F6EB029, 0x00000000
   data8 0x91C3D373AB11C336, 0x00003FFF, 0x1DFD6D8E, 0x00000000
   data8 0x935A2B2F13E6E92C, 0x00003FFF, 0x9EB319B0, 0x00000000
   data8 0x94F4EFA8FEF70961, 0x00003FFF, 0x1EBA2BEB, 0x00000000
   data8 0x96942D3720185A00, 0x00003FFF, 0x1F11D537, 0x00000000
   data8 0x9837F0518DB8A96F, 0x00003FFF, 0x1F0D5A46, 0x00000000
   data8 0x99E0459320B7FA65, 0x00003FFF, 0x9E5E7BCA, 0x00000000
   data8 0x9B8D39B9D54E5539, 0x00003FFF, 0x9F3AAFD1, 0x00000000
   data8 0x9D3ED9A72CFFB751, 0x00003FFF, 0x9E86DACC, 0x00000000
   data8 0x9EF5326091A111AE, 0x00003FFF, 0x9F3EDDC2, 0x00000000
   data8 0xA0B0510FB9714FC2, 0x00003FFF, 0x1E496E3D, 0x00000000
   data8 0xA27043030C496819, 0x00003FFF, 0x9F490BF6, 0x00000000
   data8 0xA43515AE09E6809E, 0x00003FFF, 0x1DD1DB48, 0x00000000
   data8 0xA5FED6A9B15138EA, 0x00003FFF, 0x1E65EBFB, 0x00000000
   data8 0xA7CD93B4E965356A, 0x00003FFF, 0x9F427496, 0x00000000
   data8 0xA9A15AB4EA7C0EF8, 0x00003FFF, 0x1F283C4A, 0x00000000
   data8 0xAB7A39B5A93ED337, 0x00003FFF, 0x1F4B0047, 0x00000000
   data8 0xAD583EEA42A14AC6, 0x00003FFF, 0x1F130152, 0x00000000
   data8 0xAF3B78AD690A4375, 0x00003FFF, 0x9E8367C0, 0x00000000
   data8 0xB123F581D2AC2590, 0x00003FFF, 0x9F705F90, 0x00000000
   data8 0xB311C412A9112489, 0x00003FFF, 0x1EFB3C53, 0x00000000
   data8 0xB504F333F9DE6484, 0x00003FFF, 0x1F32FB13, 0x00000000

.align 32
.global cosh#

.section .text
.proc  cosh#
.align 32

cosh: 

{ .mlx
      alloc r32 = ar.pfs,0,12,4,0                  
      movl  cosh_GR_sig_inv_ln2 = 0xb8aa3b295c17f0bc // significand of 1/ln2
}
{ .mlx
      addl cosh_GR_ad1   = @ltoff(double_cosh_arg_reduction), gp
      movl  cosh_GR_rshf_2to57 = 0x4778000000000000 // 1.10000 2^(63+57)
}
;;

{ .mfi
      ld8 cosh_GR_ad1 = [cosh_GR_ad1]
      fmerge.s      cosh_FR_ABS_X    = f0,f8
      mov  cosh_GR_exp_0_25 = 0x0fffd    // Form exponent for 0.25
}
{ .mfi
      nop.m 999
      fnorm.s1  cosh_FR_NORM_X = f8      
      mov cosh_GR_exp_2tom57 = 0xffff-57
}
;;

{ .mfi
      setf.d cosh_FR_RSHF_2TO57 = cosh_GR_rshf_2to57 // Form const 1.100 * 2^120
      fclass.m p10,p0 = f8, 0x0b         // Test for denorm
      mov  cosh_GR_exp_mask = 0x1ffff 
}
{ .mlx
      setf.sig cosh_FR_INV_LN2_2TO63 = cosh_GR_sig_inv_ln2 // Form 1/ln2 * 2^63
      movl  cosh_GR_rshf = 0x43e8000000000000 // 1.10000 2^63 for right shift
}
;;

{ .mfi
      getf.exp  cosh_GR_signexp_x = f8   // Extract signexp of x
      fclass.m  p7,p0 = f8, 0x07	// Test if x=0
      nop.i 999
}
{ .mfi
      setf.exp cosh_FR_2TOM57 = cosh_GR_exp_2tom57 // Form 2^-57 for scaling
      nop.f 999
      add  cosh_GR_ad3 = 0x90, cosh_GR_ad1  // Point to ab_table
}
;;

{ .mfi
      setf.d cosh_FR_RSHF = cosh_GR_rshf // Form right shift const 1.100 * 2^63
      fclass.m  p6,p0 = f8, 0xc3	// Test if x nan
      add  cosh_GR_ad4 = 0x4f0, cosh_GR_ad1 // Point to j_table midpoint
}
{ .mib
      add  cosh_GR_ad2e = 0x20, cosh_GR_ad1 // Point to p_table
      mov cosh_GR_all_ones = -1
(p10) br.cond.spnt  COSH_DENORM         // Branch if x denorm
}
;;

// Common path -- return here from COSH_DENORM if x is unnorm
COSH_COMMON:
{ .mfi
      ldfe            cosh_FR_smlst_oflow_input = [cosh_GR_ad2e],16
      fclass.m  p10,p0 = f8, 0x23	// Test if x inf
      and  cosh_GR_exp_x = cosh_GR_exp_mask, cosh_GR_signexp_x
}
{ .mfb
      ldfe            cosh_FR_log2by64_hi  = [cosh_GR_ad1],16       
(p7)  fma.d.s0   f8 = f1,f1,f0          // If x=0, result is 1.0
(p7)  br.ret.spnt   b0                  // Exit if x=0
}
;;

{ .mfi
// Make constant that will generate inexact when squared
      setf.sig cosh_FR_all_ones = cosh_GR_all_ones 
      nop.f 999
      cmp.ge p7,p0 = cosh_GR_exp_x, cosh_GR_exp_0_25  // Test x < 0.25
}
{ .mfb
      add  cosh_GR_ad2o = 0x30, cosh_GR_ad2e  // Point to p_table odd coeffs
(p6)  fma.d.s0   f8 = f8,f1,f8           // If x nan, return quietized nan
(p6)  br.ret.spnt     b0                 // Exit for x nan
}
;;

// Get the A coefficients for COSH_BY_TBL
// Calculate X2 = ax*ax for COSH_BY_POLY
{ .mfi
      ldfe            cosh_FR_log2by64_lo  = [cosh_GR_ad1],16       
(p10) fmerge.s  f8 = f0, f8             // If x inf, result is +inf
      nop.i 999
}
{ .mfb
      ldfe            cosh_FR_A1 = [cosh_GR_ad3],16            
      fma.s1        cosh_FR_X2 = cosh_FR_ABS_X, cosh_FR_ABS_X, f0
(p7)  br.cond.sptk    COSH_BY_TBL
}
;;

// Here if 0 < |x| < 0.25
COSH_BY_POLY: 
{ .mmf
      ldfe            cosh_FR_P6 = [cosh_GR_ad2e],16
      ldfe            cosh_FR_P5 = [cosh_GR_ad2o],16
      nop.f 999
}
;;

{ .mmi
      ldfe            cosh_FR_P4 = [cosh_GR_ad2e],16
      ldfe            cosh_FR_P3 = [cosh_GR_ad2o],16
      nop.i 999
}
;;

{ .mmi
      ldfe            cosh_FR_P2 = [cosh_GR_ad2e],16
      ldfe            cosh_FR_P1 = [cosh_GR_ad2o],16                 
      nop.i 999
}
;;

{ .mfi
      nop.m 999
      fma.s1        cosh_FR_X4 = cosh_FR_X2, cosh_FR_X2, f0
      nop.i 999
}
;;

{ .mfi
      nop.m 999
      fma.s1      cosh_FR_poly65 = cosh_FR_X2, cosh_FR_P6, cosh_FR_P5
      nop.i 999
}
{ .mfi
      nop.m 999
      fma.s1      cosh_FR_poly43 = cosh_FR_X2, cosh_FR_P4, cosh_FR_P3
      nop.i 999
}
;;

{ .mfi
      nop.m 999
      fma.s1      cosh_FR_poly21 = cosh_FR_X2, cosh_FR_P2, cosh_FR_P1
      nop.i 999
}
;;

{ .mfi
      nop.m 999
      fma.s1   cosh_FR_poly6543 = cosh_FR_X4, cosh_FR_poly65, cosh_FR_poly43
      nop.i 999
}
;;

{ .mfi
      nop.m 999
      fma.s1   cosh_FR_poly6to1 = cosh_FR_X4, cosh_FR_poly6543, cosh_FR_poly21
      nop.i 999
}
;;

// Dummy multiply to generate inexact
{ .mfi
      nop.m 999
      fmpy.s0      cosh_FR_tmp = cosh_FR_all_ones, cosh_FR_all_ones
      nop.i 999
}
{ .mfb
      nop.m 999
      fma.d.s0      f8 = cosh_FR_poly6to1, cosh_FR_X2, f1
      br.ret.sptk     b0                // Exit COSH_BY_POLY
}
;;



// Here if |x| >= 0.25
COSH_BY_TBL: 
// ******************************************************
// STEP 1 (TBL and EXP) - Argument reduction
// ******************************************************
// Get the following constants. 
// Inv_log2by64
// log2by64_hi
// log2by64_lo


// We want 2^(N-1) and 2^(-N-1). So bias N-1 and -N-1 and
// put them in an exponent.
// cosh_FR_spos = 2^(N-1) and cosh_FR_sneg = 2^(-N-1)
// 0xffff + (N-1)  = 0xffff +N -1
// 0xffff - (N +1) = 0xffff -N -1


// Calculate M and keep it as integer and floating point.
// M = round-to-integer(x*Inv_log2by64)
// cosh_FR_M = M = truncate(ax/(log2/64))
// Put the integer representation of M in cosh_GR_M
//    and the floating point representation of M in cosh_FR_M

// Get the remaining A,B coefficients
{ .mfb
      ldfe            cosh_FR_A2 = [cosh_GR_ad3],16            
      nop.f 999
(p10) br.ret.spnt  b0                   // Exit if x inf
}
;;

{ .mmi
      ldfe            cosh_FR_A3 = [cosh_GR_ad3],16 ;;
      ldfe            cosh_FR_B1 = [cosh_GR_ad3],16
      nop.i 999
}
;;

// Use constant (1.100*2^(63-6)) to get rounded M into rightmost significand
// |x| * 64 * 1/ln2 * 2^(63-6) + 1.1000 * 2^(63+(63-6))
{ .mfi
      nop.m 999
      fma.s1  cosh_FR_M_temp = cosh_FR_ABS_X, cosh_FR_INV_LN2_2TO63, cosh_FR_RSHF_2TO57
      mov  cosh_GR_signexp_0_5 = 0x0fffe // signexp of +0.5
}
;;

// Test for |x| >= overflow limit
{ .mfi
      nop.m 999
      fcmp.ge.s1  p6,p0 = cosh_FR_ABS_X, cosh_FR_smlst_oflow_input
      nop.i 999
}
;;

{ .mfi
      ldfe            cosh_FR_B2 = [cosh_GR_ad3],16
      nop.f 999
      nop.i 999
}
;;

// Subtract RSHF constant to get rounded M as a floating point value
// M_temp * 2^(63-6) - 2^63
{ .mfb
      ldfe            cosh_FR_B3 = [cosh_GR_ad3],16            
      fms.s1        cosh_FR_M = cosh_FR_M_temp, cosh_FR_2TOM57, cosh_FR_RSHF
(p6)  br.cond.spnt    COSH_HUGE  // Branch if result will overflow
}
;;

{ .mfi
      getf.sig        cosh_GR_M       = cosh_FR_M_temp                 
      nop.f 999
      nop.i 999
}
;;

// Calculate j. j is the signed extension of the six lsb of M. It 
// has a range of -32 thru 31.

// Calculate R
// ax - M*log2by64_hi
// R = (ax - M*log2by64_hi) - M*log2by64_lo

{ .mfi
      nop.m 999
      fnma.s1 cosh_FR_R_temp = cosh_FR_M, cosh_FR_log2by64_hi, cosh_FR_ABS_X
      and     cosh_GR_j = 0x3f, cosh_GR_M
}
;;

{ .mii
      nop.m 999
      shl     cosh_GR_jshf = cosh_GR_j, 0x2 ;;  // Shift j so can sign extend it
      sxt1    cosh_GR_jshf = cosh_GR_jshf
}
;;

// N = (M-j)/64
{ .mii
      mov     cosh_GR_exp_32 = 0x10004
      shr     cosh_GR_j = cosh_GR_jshf, 0x2 ;;   // Now j has range -32 to 31
      sub     cosh_GR_Mmj = cosh_GR_M, cosh_GR_j ;;   // M-j
}
;;

// The TBL and EXP branches are merged and predicated
// If TBL, p6 true, 0.25 <= |x| < 32
// If EXP, p7 true, 32 <= |x| < overflow_limit
//
{ .mfi
      cmp.ge p7,p6 = cosh_GR_exp_x, cosh_GR_exp_32 // Test if x >= 32
      fnma.s1  cosh_FR_R      = cosh_FR_M, cosh_FR_log2by64_lo, cosh_FR_R_temp 
      shr            cosh_GR_N = cosh_GR_Mmj, 0x6    // N = (M-j)/64 
}
;;

{ .mmi
      sub  r40 = cosh_GR_signexp_0_5, cosh_GR_N // signexp of 2^(-N-1)
      add  r39 = cosh_GR_signexp_0_5, cosh_GR_N // signexp of 2^(N-1)
      shl  cosh_GR_joff = cosh_GR_j,5         // Make j offset to j_table
}
;;

{ .mfi
      setf.exp            cosh_FR_spos = r39  // Form 2^(N-1)
      nop.f 999
      sub                 cosh_GR_mJ = r0, cosh_GR_joff // Table offset for -j
}
{ .mfi
      setf.exp            cosh_FR_sneg = r40  // Form 2^(-N-1)
      nop.f 999
      add                 cosh_GR_J  = r0, cosh_GR_joff // Table offset for +j
}
;;

// Get the address of the J table midpoint, add the offset 
{ .mmf
      add                  cosh_AD_mJ = cosh_GR_ad4, cosh_GR_mJ
      add                  cosh_AD_J  = cosh_GR_ad4, cosh_GR_J
      nop.f 999
}
;;

{ .mmf
      ldfe                 cosh_FR_Tmjhi = [cosh_AD_mJ],16                 
      ldfe                 cosh_FR_Tjhi  = [cosh_AD_J],16
      nop.f 999
}
;;

// ******************************************************
// STEP 2 (TBL and EXP)
// ******************************************************
// Calculate Rsquared and Rcubed in preparation for p_even and p_odd

{ .mmf
      ldfs                 cosh_FR_Tmjlo = [cosh_AD_mJ],16                 
      ldfs                 cosh_FR_Tjlo  = [cosh_AD_J],16                  
      fma.s1             cosh_FR_Rsq  = cosh_FR_R, cosh_FR_R, f0
}
;;


// Calculate p_even
// B_2 + Rsq *B_3
// B_1 + Rsq * (B_2 + Rsq *B_3)
// p_even = Rsq * (B_1 + Rsq * (B_2 + Rsq *B_3))
{ .mfi
      nop.m 999
      fma.s1          cosh_FR_peven_temp1 = cosh_FR_Rsq, cosh_FR_B3, cosh_FR_B2
      nop.i 999
}
// Calculate p_odd
// A_2 + Rsq *A_3
// A_1 + Rsq * (A_2 + Rsq *A_3)
// podd = R + Rcub * (A_1 + Rsq * (A_2 + Rsq *A_3))
{ .mfi
      nop.m 999
      fma.s1          cosh_FR_podd_temp1 = cosh_FR_Rsq, cosh_FR_A3, cosh_FR_A2
      nop.i 999
}
;;

{ .mfi
      nop.m 999
      fma.s1             cosh_FR_Rcub = cosh_FR_Rsq, cosh_FR_R, f0
      nop.i 999
}
;;

// 
// If TBL, 
// Calculate C_hi and C_lo, and S_hi
// SC_hi_temp = sneg * Tmjhi
// S_hi = spos * Tjhi - SC_hi_temp
// S_hi = spos * Tjhi - (sneg * Tmjhi)
// C_hi = spos * Tjhi + SC_hi_temp
// C_hi = spos * Tjhi + (sneg * Tmjhi)

{ .mfi
      nop.m 999
(p6)  fma.s1         cosh_FR_SC_hi_temp = cosh_FR_sneg, cosh_FR_Tmjhi, f0   
      nop.i 999
}
;;

// If TBL, 
// C_lo_temp3 = sneg * Tmjlo
// C_lo_temp4 = spos * Tjlo + C_lo_temp3
// C_lo_temp4 = spos * Tjlo + (sneg * Tmjlo)
{ .mfi
      nop.m 999
(p6)  fma.s1  cosh_FR_C_lo_temp3 =  cosh_FR_sneg, cosh_FR_Tmjlo, f0
      nop.i 999
}
;;

{ .mfi
      nop.m 999
      fma.s1  cosh_FR_peven_temp2 = cosh_FR_Rsq, cosh_FR_peven_temp1, cosh_FR_B1
      nop.i 999
}
{ .mfi
      nop.m 999
      fma.s1  cosh_FR_podd_temp2 = cosh_FR_Rsq, cosh_FR_podd_temp1, cosh_FR_A1
      nop.i 999
}
;;

// If EXP, 
// Compute 2^(N-1) * Tjhi and 2^(N-1) * Tjlo
{ .mfi
      nop.m 999
(p7)  fma.s1  cosh_FR_Tjhi_spos = cosh_FR_Tjhi, cosh_FR_spos, f0
      nop.i 999
}
{ .mfi
      nop.m 999
(p7)  fma.s1  cosh_FR_Tjlo_spos = cosh_FR_Tjlo, cosh_FR_spos, f0
      nop.i 999
}
;;

{ .mfi
      nop.m 999
(p6)  fma.s1  cosh_FR_C_hi = cosh_FR_spos, cosh_FR_Tjhi, cosh_FR_SC_hi_temp
      nop.i 999
}
;;

{ .mfi
      nop.m 999
(p6)  fms.s1  cosh_FR_S_hi = cosh_FR_spos, cosh_FR_Tjhi, cosh_FR_SC_hi_temp
      nop.i 999
}
{ .mfi
      nop.m 999
(p6)  fma.s1 cosh_FR_C_lo_temp4 = cosh_FR_spos, cosh_FR_Tjlo, cosh_FR_C_lo_temp3
      nop.i 999
}
;;

{ .mfi
      nop.m 999
      fma.s1          cosh_FR_peven = cosh_FR_Rsq, cosh_FR_peven_temp2, f0
      nop.i 999
}
{ .mfi
      nop.m 999
      fma.s1          cosh_FR_podd = cosh_FR_podd_temp2, cosh_FR_Rcub, cosh_FR_R
      nop.i 999
}
;;

// If TBL,
// C_lo_temp1 =  spos * Tjhi - C_hi
// C_lo_temp2 =  sneg * Tmjlo + C_lo_temp1
// C_lo_temp2 =  sneg * Tmjlo + (spos * Tjhi - C_hi)

{ .mfi
      nop.m 999
(p6)  fms.s1  cosh_FR_C_lo_temp1 =  cosh_FR_spos, cosh_FR_Tjhi,  cosh_FR_C_hi
      nop.i 999
}
;;

{ .mfi
      nop.m 999
(p6)  fma.s1 cosh_FR_C_lo_temp2 = cosh_FR_sneg, cosh_FR_Tmjhi, cosh_FR_C_lo_temp1       
      nop.i 999
}
;;

// If EXP,
// Y_hi = 2^(N-1) * Tjhi
// Y_lo = 2^(N-1) * Tjhi * (p_odd + p_even) + 2^(N-1) * Tjlo
{ .mfi
      nop.m 999
(p7)  fma.s1  cosh_FR_Y_lo_temp =  cosh_FR_peven, f1, cosh_FR_podd
      nop.i 999
}
;;

// If TBL,
// C_lo = C_lo_temp4 + C_lo_temp2
{ .mfi
      nop.m 999
(p6)  fma.s1         cosh_FR_C_lo = cosh_FR_C_lo_temp4, f1, cosh_FR_C_lo_temp2
      nop.i 999
}
;;

// If TBL,
// Y_hi = C_hi 
// Y_lo = S_hi*p_odd + (C_hi*p_even + C_lo)
{ .mfi
      nop.m 999
(p6)  fma.s1  cosh_FR_Y_lo_temp = cosh_FR_C_hi, cosh_FR_peven, cosh_FR_C_lo
      nop.i 999
}
;;

{ .mfi
      nop.m 999
(p7)  fma.s1  cosh_FR_Y_lo = cosh_FR_Tjhi_spos, cosh_FR_Y_lo_temp, cosh_FR_Tjlo_spos
      nop.i 999
}
;;

// Dummy multiply to generate inexact
{ .mfi
      nop.m 999
      fmpy.s0      cosh_FR_tmp = cosh_FR_all_ones, cosh_FR_all_ones
      nop.i 999
}
{ .mfi
      nop.m 999
(p6)  fma.s1       cosh_FR_Y_lo = cosh_FR_S_hi, cosh_FR_podd, cosh_FR_Y_lo_temp
      nop.i 999
}
;;

// f8 = answer = Y_hi + Y_lo
{ .mfi
      nop.m 999
(p7)  fma.d.s0   f8 = cosh_FR_Y_lo,  f1, cosh_FR_Tjhi_spos
      nop.i 999
}
;;

// f8 = answer = Y_hi + Y_lo
{ .mfb
      nop.m 999
(p6)  fma.d.s0  f8 = cosh_FR_Y_lo, f1, cosh_FR_C_hi
      br.ret.sptk     b0      // Exit for COSH_BY_TBL and COSH_BY_EXP
}
;;



// Here if x denorm or unorm
COSH_DENORM:
// Determine if x really a denorm and not a unorm
{ .mmf
      getf.exp  cosh_GR_signexp_x = cosh_FR_NORM_X
      mov  cosh_GR_exp_denorm = 0x0fc01   // Real denorms will have exp < this
      fmerge.s    cosh_FR_ABS_X = f0, cosh_FR_NORM_X
}
;;

{ .mfi
      nop.m 999
      fcmp.eq.s0  p10,p0 = f8, f0  // Set denorm flag
      nop.i 999
}
;;

// Set p8 if really a denorm
{ .mmi
      and  cosh_GR_exp_x = cosh_GR_exp_mask, cosh_GR_signexp_x ;;
      cmp.lt  p8,p9 = cosh_GR_exp_x, cosh_GR_exp_denorm
      nop.i 999
}
;;

{ .mfb
      nop.m 999
(p8)  fma.d.s0       f8 =  f8,f8,f1  // If x denorm, result=1+x^2
(p9)  br.cond.sptk  COSH_COMMON    // Return to main path if x unorm
}
;;
{ .mfb
      nop.m 999
      nop.f 999
      br.ret.sptk    b0            // Exit if x denorm
}
;;



// Here if |x| >= overflow limit
COSH_HUGE: 
// for COSH_HUGE, put 24000 in exponent
{ .mmi
      mov                cosh_GR_exp_huge = 0x15dbf ;;
      setf.exp            cosh_FR_huge  = cosh_GR_exp_huge
      nop.i 999
}
;;

{ .mfi
      nop.m 999
      fma.s1   cosh_FR_signed_hi_lo = cosh_FR_huge, f1, f1
      nop.i 999
}
;;

{ .mfi
      nop.m 999
      fma.d.s0  cosh_FR_pre_result = cosh_FR_signed_hi_lo, cosh_FR_huge, f0
      mov                 GR_Parameter_TAG = 64
}
;;

.endp cosh

// Stack operations when calling error support.
//       (1)               (2)                          (3) (call)              (4)
//   sp   -> +          psp -> +                     psp -> +                   sp -> +
//           |                 |                            |                         |
//           |                 | <- GR_Y               R3 ->| <- GR_RESULT            | -> f8
//           |                 |                            |                         |
//           | <-GR_Y      Y2->|                       Y2 ->| <- GR_Y                 |
//           |                 |                            |                         |
//           |                 | <- GR_X               X1 ->|                         |
//           |                 |                            |                         |
//  sp-64 -> +          sp ->  +                     sp ->  +                         +
//    save ar.pfs          save b0                                               restore gp
//    save gp                                                                    restore ar.pfs

.proc __libm_error_region
__libm_error_region:
COSH_ERROR_SUPPORT:
.prologue

// (1)
{ .mfi
        add   GR_Parameter_Y=-32,sp             // Parameter 2 value
        nop.f 0
.save   ar.pfs,GR_SAVE_PFS
        mov  GR_SAVE_PFS=ar.pfs                 // Save ar.pfs
}
{ .mfi
.fframe 64
        add sp=-64,sp                          // Create new stack
        nop.f 0
        mov GR_SAVE_GP=gp                      // Save gp
};;


// (2)
{ .mmi
        stfd [GR_Parameter_Y] = f0,16          // STORE Parameter 2 on stack
        add GR_Parameter_X = 16,sp             // Parameter 1 address
.save   b0, GR_SAVE_B0
        mov GR_SAVE_B0=b0                      // Save b0
};;

.body
// (3)
{ .mib
        stfd [GR_Parameter_X] = f8             // STORE Parameter 1 on stack
        add   GR_Parameter_RESULT = 0,GR_Parameter_Y   // Parameter 3 address
        nop.b 0                            
}
{ .mib
        stfd [GR_Parameter_Y] = cosh_FR_pre_result // STORE Parameter 3 on stack
        add   GR_Parameter_Y = -16,GR_Parameter_Y
        br.call.sptk b0=__libm_error_support#  // Call error handling function
};;
{ .mmi
        nop.m 0
        nop.m 0
        add   GR_Parameter_RESULT = 48,sp
};;

// (4)
{ .mmi
        ldfd  f8 = [GR_Parameter_RESULT]       // Get return result off stack
.restore
        add   sp = 64,sp                       // Restore stack pointer
        mov   b0 = GR_SAVE_B0                  // Restore return address
};;
{ .mib
        mov   gp = GR_SAVE_GP                  // Restore gp
        mov   ar.pfs = GR_SAVE_PFS             // Restore ar.pfs
        br.ret.sptk     b0                     // Return
};;

.endp __libm_error_region

.type   __libm_error_support#,@function
.global __libm_error_support#
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\ia64\ceilf.s ===
.file "ceilf.s"

// Copyright (c) 2000, 2001, Intel Corporation
// All rights reserved.
// 
// Contributed 2/2/2000 by John Harrison, Ted Kubaska, Bob Norin, Shane Story,
// and Ping Tak Peter Tang of the Computational Software Lab, Intel Corporation.
// 
// WARRANTY DISCLAIMER
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS 
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY 
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
// 
// Intel Corporation is the author of this code, and requests that all
// problem reports or change requests be submitted to it directly at 
// http://developer.intel.com/opensource.
//
.align 32
.global ceilf#

.section .text
.proc  ceilf#
.align 32

// History
//==============================================================
// 2/02/00: Initial version
// 6/13/00: Improved speed
// 6/27/00: Eliminated incorrect invalid flag setting

// API
//==============================================================
// float ceilf(float x)

// general input registers:  

ceil_GR_FFFF      = r14
ceil_GR_signexp   = r15
ceil_GR_exponent  = r16
ceil_GR_expmask   = r17
ceil_GR_bigexp    = r18


// predicate registers used: 

// p6  ==> Input is NaN, infinity, zero
// p7  ==> Input is denormal
// p8  ==> Input is <0
// p9  ==> Input is >=0
// p10 ==> Input is already an integer (bigger than largest integer)
// p11 ==> Input is not a large integer
// p12 ==> Input is a smaller integer
// p13 ==> Input is not an even integer, so inexact must be set
// p14 ==> Input is between -1 and 0, so result will be -0 and inexact


// floating-point registers used: 

CEIL_SIGNED_ZERO  = f7
CEIL_NORM_f8      = f9                        
CEIL_FFFF         = f10 
CEIL_INEXACT      = f11 
CEIL_FLOAT_INT_f8 = f12
CEIL_INT_f8       = f13
CEIL_adj          = f14
CEIL_MINUS_ONE    = f15

// Overview of operation
//==============================================================

// float ceilf(float x)
// Return an integer value (represented as a float) that is the smallest 
// value not less than x
// This is x rounded toward +infinity to an integral value.
// Inexact is set if x != ceilf(x)
// **************************************************************************

// Set denormal flag for denormal input and
// and take denormal fault if necessary.

// Is the input an integer value already?

// double_extended
// if the exponent is > 1003e => 3F(true) = 63(decimal)
// we have a significand of 64 bits 1.63-bits.
// If we multiply by 2^63, we no longer have a fractional part
// So input is an integer value already.

// double
// if the exponent is >= 10033 => 34(true) = 52(decimal)
// 34 + 3ff = 433
// we have a significand of 53 bits 1.52-bits. (implicit 1)
// If we multiply by 2^52, we no longer have a fractional part
// So input is an integer value already.

// single
// if the exponent is > 10016 => 17(true) = 23(decimal)
// we have a significand of 24 bits 1.23-bits. (implicit 1)
// If we multiply by 2^23, we no longer have a fractional part
// So input is an integer value already.

// If x is NAN, ZERO, or INFINITY, then  return

// qnan snan inf norm     unorm 0 -+
// 1    1    1   0        0     1 11     0xe7


ceilf:

{ .mfi
      getf.exp ceil_GR_signexp  = f8
      fcvt.fx.trunc.s1     CEIL_INT_f8  = f8
      addl        ceil_GR_bigexp = 0x10016, r0
}
{ .mfi
      addl        ceil_GR_FFFF      = -1,r0
      fcmp.lt.s1  p8,p9 = f8,f0
      mov         ceil_GR_expmask    = 0x1FFFF ;;
}

// p7 ==> denorm
{ .mfi
      setf.sig    CEIL_FFFF  = ceil_GR_FFFF
      fclass.m    p7,p0 = f8, 0x0b
      nop.i 999
}
{ .mfi
      nop.m 999
      fnorm           CEIL_NORM_f8  = f8
      nop.i 999 ;;
}

// Form 0 with sign of input in case negative zero is needed
{ .mfi
      nop.m 999
      fmerge.s           CEIL_SIGNED_ZERO = f8, f0
      nop.i 999
}
{ .mfi
      nop.m 999
      fsub.s1           CEIL_MINUS_ONE = f0, f1
      nop.i 999 ;;
}

// p6 ==> NAN, INF, ZERO
{ .mfb
      nop.m 999
      fclass.m      p6,p10 = f8, 0xe7
(p7)  br.cond.spnt  CEIL_DENORM ;;
}

.pred.rel "mutex",p8,p9
CEIL_COMMON:
// Set adjustment to add to trunc(x) for result
//   If x>0,  adjustment is 1.0
//   If x<=0, adjustment is 0.0
{ .mfi
      and      ceil_GR_exponent = ceil_GR_signexp, ceil_GR_expmask
(p9)  fadd.s1  CEIL_adj = f1,f0
      nop.i 999
}
{ .mfi
      nop.m 999
(p8)  fadd.s1  CEIL_adj = f0,f0
      nop.i 999 ;;
}

{ .mfi
(p10) cmp.ge.unc    p10,p11 = ceil_GR_exponent, ceil_GR_bigexp
(p6)  fnorm.s f8 = f8
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p11) fcvt.xf         CEIL_FLOAT_INT_f8   = CEIL_INT_f8
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p10) fnorm.s f8 = CEIL_NORM_f8
      nop.i 999 ;;
}

// Is -1 < x < 0?  If so, result will be -0.  Special case it with p14 set.
{ .mfi
      nop.m 999
(p8)  fcmp.gt.unc.s1 p14,p0 = CEIL_NORM_f8, CEIL_MINUS_ONE
      nop.i 999 ;;
}

{ .mfi
(p14) cmp.ne  p11,p0 = r0,r0
(p14) fnorm.s f8 = CEIL_SIGNED_ZERO
      nop.i 999
}
{ .mfi
      nop.m 999
(p14) fmpy.s0     CEIL_INEXACT = CEIL_FFFF,CEIL_FFFF
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p11) fadd.s   f8 = CEIL_FLOAT_INT_f8,CEIL_adj
      nop.i 999 ;;
}
{ .mfi
      nop.m 999
(p11) fcmp.eq.unc.s1  p12,p13  = CEIL_FLOAT_INT_f8, CEIL_NORM_f8
      nop.i 999 ;;
}

// Set inexact if result not equal to input
{ .mfi
      nop.m 999
(p13) fmpy.s0     CEIL_INEXACT = CEIL_FFFF,CEIL_FFFF
      nop.i 999
}
// Set result to input if integer
{ .mfb
      nop.m 999
(p12) fnorm.s f8 = CEIL_NORM_f8
      br.ret.sptk    b0 ;;
}

// Here if input denorm
CEIL_DENORM:
{ .mfb
      getf.exp ceil_GR_signexp  = CEIL_NORM_f8
      fcvt.fx.trunc.s1     CEIL_INT_f8  = CEIL_NORM_f8
      br.cond.sptk  CEIL_COMMON ;;
}

.endp ceilf
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\ia64\expf.s ===
.file "expf.s"

// Copyright (c) 2000, 2001, Intel Corporation
// All rights reserved.
//
// Contributed 2/2/2000 by John Harrison, Ted Kubaska, Bob Norin, Shane Story,
// and Ping Tak Peter Tang of the Computational Software Lab, Intel Corporation.
//
// WARRANTY DISCLAIMER
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// Intel Corporation is the author of this code, and requests that all
// problem reports or change requests be submitted to it directly at
// http://developer.intel.com/opensource.

// History
//==============================================================
// 4/04/00  Unwind update
// 4/04/00  Unwind support added
// 8/15/00  Bundle added after call to __libm_error_support to properly
//          set [the previously overwritten] GR_Parameter_RESULT.
// 8/21/00  Improvements to save 2 cycles on main path, and shorten x=0 case
// 12/07/00 Widen main path, shorten x=inf, nan paths
// 3/15/01  Fix monotonicity problem around x=0 for round to +inf
//
// Assembly macros
//==============================================================
// integer registers used

 exp_GR_0x0f                = r33
 exp_GR_0xf0                = r34

 EXP_AD_P_1                 = r36
 EXP_AD_P_2                 = r37
 EXP_AD_T1                  = r38
 EXP_AD_T2                  = r39
 exp_GR_Mint                = r40

 exp_GR_Mint_p_128          = r41
 exp_GR_Ind1                = r42
 EXP_AD_M1                  = r43
 exp_GR_Ind2                = r44
 EXP_AD_M2                  = r45

 exp_GR_min_oflow           = r46
 exp_GR_max_zero            = r47
 exp_GR_max_norm            = r48
 exp_GR_max_uflow           = r49
 exp_GR_min_norm            = r50

 exp_GR_17ones              = r51
 exp_GR_gt_ln               = r52
 exp_GR_T2_size             = r53
 exp_GR_bias                = r54
 exp_GR_signexp             = r55
 exp_GR_17ones_m1           = r56
 exp_GR_one                 = r57
 exp_GR_exp                 = r58



GR_SAVE_B0                    = r53
GR_SAVE_PFS                   = r55
GR_SAVE_GP                    = r54 

GR_Parameter_X                = r59
GR_Parameter_Y                = r60
GR_Parameter_RESULT           = r61
GR_Parameter_TAG              = r62

FR_X             = f10
FR_Y             = f1
FR_RESULT        = f8


// floating point registers used

 EXP_MIN_SGL_OFLOW_ARG      = f11
 EXP_MAX_SGL_ZERO_ARG       = f12
 EXP_MAX_SGL_NORM_ARG       = f13
 EXP_MAX_SGL_UFLOW_ARG      = f14
 EXP_MIN_SGL_NORM_ARG       = f15

 exp_coeff_P5               = f32
 exp_coeff_P6               = f33
 exp_coeff_P3               = f34
 exp_coeff_P4               = f35

 exp_coeff_P1               = f36
 exp_coeff_P2               = f37
 exp_Mx                     = f38
 exp_Mfloat                 = f39
 exp_R                      = f40

 exp_P1                     = f41
 exp_P2                     = f42
 exp_P3                     = f43
 exp_Rsq                    = f44
 exp_R4                     = f45

 exp_P4                     = f46
 exp_P5                     = f47
 exp_P6                     = f48
 exp_P7                     = f49
 exp_T1                     = f50

 exp_T2                     = f51
 exp_T                      = f52
 exp_A                      = f53
 exp_norm_f8                = f54
 exp_wre_urm_f8             = f55

 exp_ftz_urm_f8             = f56
 exp_gt_pln                 = f57


.data

.align 16

exp_coeff_1_table:
data8 0x3F56F35FDE4F8563 // p5
data8 0x3F2A378BEFECCFDD // p6
data8 0x3FE00000258C581D // p1
data8 0x3FC555557AE7B3D4 // p2


exp_coeff_2_table:
data8 0x3FA5551BB6592FAE // p3
data8 0x3F8110E8EBFFD485 // p4


exp_T2_table:
data8 0xa175cf9cd7d85844 , 0x00003f46 // exp(-128)
data8 0xdb7279415a1f9eed , 0x00003f47 // exp(-127)
data8 0x95213b242bd8ca5f , 0x00003f49 // exp(-126)
data8 0xcab03c968c989f83 , 0x00003f4a // exp(-125)
data8 0x89bdb674702961ad , 0x00003f4c // exp(-124)
data8 0xbb35a2eec278be35 , 0x00003f4d // exp(-123)
data8 0xfe71b17f373e7e7a , 0x00003f4e // exp(-122)
data8 0xace9a6ec52a39b63 , 0x00003f50 // exp(-121)
data8 0xeb03423fe393cf1c , 0x00003f51 // exp(-120)
data8 0x9fb52c5bcaef1693 , 0x00003f53 // exp(-119)
data8 0xd910b6377ed60bf1 , 0x00003f54 // exp(-118)
data8 0x9382dad8a9fdbfe4 , 0x00003f56 // exp(-117)
data8 0xc87d0a84dea869a3 , 0x00003f57 // exp(-116)
data8 0x883efb4c6d1087b0 , 0x00003f59 // exp(-115)
data8 0xb92d7373dce9a502 , 0x00003f5a // exp(-114)
data8 0xfbaeb020577fb0cb , 0x00003f5b // exp(-113)


exp_T1_table:
data8 0x8000000000000000 , 0x00003fff // exp(16 * 0)
data8 0x87975e8540010249 , 0x00004016 // exp(16 * 1) 
data8 0x8fa1fe625b3163ec , 0x0000402d // exp(16 * 2) 
data8 0x9826b576512a59d7 , 0x00004044 // exp(16 * 3) 
data8 0xa12cc167acbe6902 , 0x0000405b // exp(16 * 4) 
data8 0xaabbcdcc279f59e4 , 0x00004072 // exp(16 * 5) 
data8 0xb4dbfaadc045d16f , 0x00004089 // exp(16 * 6) 
data8 0xbf95e372ccdbf146 , 0x000040a0 // exp(16 * 7) 
data8 0xcaf2a62eea10bbfb , 0x000040b7 // exp(16 * 8) 
data8 0xd6fbeb62fddbd340 , 0x000040ce // exp(16 * 9) 
data8 0xe3bbee32e4a440ea , 0x000040e5 // exp(16 * 10)
data8 0xf13d8517c34199a8 , 0x000040fc // exp(16 * 11)
data8 0xff8c2b166241eedd , 0x00004113 // exp(16 * 12)
data8 0x875a04c0b38d6129 , 0x0000412b // exp(16 * 13)
data8 0x8f610127db6774d7 , 0x00004142 // exp(16 * 14)
data8 0x97e1dd87e5c20bb6 , 0x00004159 // exp(16 * 15)

// Argument Reduction
//  exp_Mx = (int)f8            ==> The value of f8 rounded to int is placed into the
//                                  significand of exp_Mx as a two's
//                                  complement number.

// Later we want to have exp_Mx in a general register. Do this with a getf.sig
// and call the general register exp_GR_Mint

//  exp_Mfloat = (float)(int)f8 ==> the two's complement number in
//                                  significand of exp_Mx is turned
//                                  into a floating point number.
//  R = 1 - exp_Mfloat          ==> reduced argument

// Core Approximation
// Calculate a series in R
//  R * p6 + p5
//  R * p4 + p3
//  R * p2 + p1
//  R^2
//  R^4
//  R^2(R * p6 + p5) + (R * p4 + p3)
//  R^2(R * p2 + p1)
//  R^4(R^2(R * p6 + p5) + (R * p4 + p3)) + (R^2(R * p2 + p1))
//  R + 1
//  exp(R) = (1 + R) + R^4(R^2(R * p6 + p5) + (R * p4 + p3)) + (R^2(R * p2 + p1))
//  exp(R) = 1 + R + R^2 * p1 + R^3 * p2 + R^4 * p3 + R^5 * p4 + R^6 * p5 + R^7 * p6

// Reconstruction
// signficand of exp_Mx is two's complement,
// -103 < x < 89
// The smallest single denormal is 2^-149 = ssdn
//    For e^x = ssdn
//        x   = log(ssdn) = -103.279
//    But with rounding result goes to ssdn until -103.972079
// The largest single normal is  1.<23 1's> 2^126 ~ 2^127 = lsn
//    For e^x = lsn
//        x   = log(lsn) = 88.7228
//
// expf overflows                       when x > 42b17218 = 88.7228
// expf returns largest single denormal when x = c2aeac50
// expf goes to zero when                    x < c2cff1b5 

// Consider range of 8-bit two's complement, -128 ---> 127
// Add 128; range becomes                       0 ---> 255

// The number (=i) in 0 ---> 255 is used as offset into two tables.

// i = abcd efgh = abcd * 16 + efgh = i1 * 16 + i2

// i1 = (exp_GR_Mint + 128)  & 0xf0 (show 0xf0 as -0x10 to avoid assembler error)
//                                  (The immediate in the AND is an 8-bit two's complement)
// i1 = i1 + start of T1 table (EXP_AD_T1)
//    Note that the entries in T1 are double-extended numbers on 16-byte boundaries
//    and that i1 is already shifted left by 16 after the AND.

// i2 must be shifted left by 4 before adding to the start of the table.
// i2 = ((exp_GR_Mint + 128)  & 0x0f) << 4
// i2 = i2 + start of T2 table (EXP_AD_T2)

// T      = T1 * T2
// A      = T * (1 + R)
// answer = T *  (R^2 * p1 + R^3 * p2 + R^4 * p3 + R^5 * p4 + R^6 * p5 + R^7 * p6) +
//          T *  (1 + R)
//        = T * exp(R)


.global expf#

.section .text
.proc  expf#
.align 32
expf:

{ .mfi
     alloc      r32            = ar.pfs,1,26,4,0
     fcvt.fx.s1   exp_Mx       =    f8
     mov       exp_GR_17ones   =    0x1FFFF
}
{ .mlx
     addl      EXP_AD_P_1      =    @ltoff(exp_coeff_1_table),gp
     movl      exp_GR_min_oflow = 0x42b17218    
}
;;

// Fnorm done to take any enabled faults
{ .mfi
     ld8       EXP_AD_P_1      =  [EXP_AD_P_1]
     fclass.m  p6,p0      = f8, 0x07	//@zero
     nop.i 999
}
{ .mfi
     add       exp_GR_max_norm = -1, exp_GR_min_oflow  // 0x42b17217
     fnorm     exp_norm_f8     =    f8
     nop.i 999
}
;;

{ .mfi
     setf.s    EXP_MIN_SGL_OFLOW_ARG = exp_GR_min_oflow  // 0x42b17218
     fclass.m  p7,p0      = f8, 0x22	// Test for x=-inf
     mov       exp_GR_0xf0 = 0x0f0
}
{ .mlx
     setf.s    EXP_MAX_SGL_NORM_ARG = exp_GR_max_norm
     movl      exp_GR_max_zero = 0xc2cff1b5    
}
;;


{ .mlx
     mov       exp_GR_0x0f = 0x00f
     movl      exp_GR_max_uflow = 0xc2aeac50    
}
{ .mfb
     nop.m 999
(p6) fma.s     f8 = f1,f1,f0
(p6) br.ret.spnt   b0        // quick exit for x=0
}
;;

{ .mfi
     setf.s    EXP_MAX_SGL_ZERO_ARG = exp_GR_max_zero
     fclass.m  p8,p0      = f8, 0x21	// Test for x=+inf
     adds      exp_GR_min_norm = 1, exp_GR_max_uflow  // 0xc2aeac51
}
{ .mfb
     ldfpd     exp_coeff_P5,exp_coeff_P6     =    [EXP_AD_P_1],16
(p7) fma.s     f8 = f0,f0,f0
(p7) br.ret.spnt   b0        // quick exit for x=-inf
}
;;

{ .mmf
     ldfpd     exp_coeff_P1,exp_coeff_P2     =    [EXP_AD_P_1],16
     setf.s    EXP_MAX_SGL_UFLOW_ARG = exp_GR_max_uflow
     fclass.m  p9,p0      = f8, 0xc3	// Test for x=nan
}
;;

{ .mmb
     ldfpd     exp_coeff_P3,exp_coeff_P4     =    [EXP_AD_P_1],16
     setf.s    EXP_MIN_SGL_NORM_ARG = exp_GR_min_norm
(p8) br.ret.spnt   b0        // quick exit for x=+inf
}
;;

// EXP_AD_P_1 now points to exp_T2_table
{ .mfi
     mov exp_GR_T2_size           = 0x100
     fcvt.xf   exp_Mfloat     =    exp_Mx
     nop.i 999
}
;;

{ .mfb
     getf.sig  exp_GR_Mint    =    exp_Mx
(p9) fmerge.s     f8 = exp_norm_f8, exp_norm_f8
(p9) br.ret.spnt   b0        // quick exit for x=nan
}
;;

{ .mmi
     getf.exp  exp_GR_signexp    =    exp_norm_f8
     mov      EXP_AD_T2       =  EXP_AD_P_1
     add      EXP_AD_T1       =  exp_GR_T2_size,EXP_AD_P_1 ;;
}


{ .mmi
     adds      exp_GR_Mint_p_128   =    0x80,exp_GR_Mint ;;
     and       exp_GR_Ind1      =    exp_GR_Mint_p_128, exp_GR_0xf0
     and       exp_GR_Ind2      =    exp_GR_Mint_p_128, exp_GR_0x0f ;;
}

// Divide arguments into the following categories:
//  Certain Underflow/zero  p11 - -inf < x <= MAX_SGL_ZERO_ARG 
//  Certain Underflow       p12 - MAX_SGL_ZERO_ARG < x <= MAX_SGL_UFLOW_ARG 
//  Possible Underflow      p13 - MAX_SGL_UFLOW_ARG < x < MIN_SGL_NORM_ARG
//  Certain Safe                - MIN_SGL_NORM_ARG <= x <= MAX_SGL_NORM_ARG
//  Possible Overflow       p14 - MAX_SGL_NORM_ARG < x < MIN_SGL_OFLOW_ARG
//  Certain Overflow        p15 - MIN_SGL_OFLOW_ARG <= x < +inf
//
// If the input is really a single arg, then there will never be "Possible
// Underflow" or "Possible Overflow" arguments.
//

{ .mfi
     add       EXP_AD_M1 =    exp_GR_Ind1,EXP_AD_T1
     fcmp.ge.s1  p15,p14 = exp_norm_f8,EXP_MIN_SGL_OFLOW_ARG
     nop.i 999
}
{ .mfi
     shladd       EXP_AD_M2                =    exp_GR_Ind2,4,EXP_AD_T2
     fms.s1    exp_R                    =    f1,f8,exp_Mfloat
     nop.i 999 ;;
}

{ .mfi
     ldfe           exp_T1    =    [EXP_AD_M1]
     fcmp.le.s1  p11,p12 = exp_norm_f8,EXP_MAX_SGL_ZERO_ARG
     mov  exp_GR_bias = 0xffff
}
;;

{ .mfb
      ldfe           exp_T2   =    [EXP_AD_M2]
(p14) fcmp.gt.s1  p14,p0 = exp_norm_f8,EXP_MAX_SGL_NORM_ARG
(p15) br.cond.spnt EXP_CERTAIN_OVERFLOW ;;
}

{ .mfb
      and  exp_GR_exp = exp_GR_signexp, exp_GR_17ones
(p12) fcmp.le.s1  p12,p0 = exp_norm_f8,EXP_MAX_SGL_UFLOW_ARG
(p11) br.cond.spnt EXP_CERTAIN_UNDERFLOW_ZERO
}
;;

{ .mfi
      sub  exp_GR_exp = exp_GR_exp, exp_GR_bias
(p13) fcmp.lt.s1  p13,p0 = exp_norm_f8,EXP_MIN_SGL_NORM_ARG
      nop.i 999
}
;;


{ .mfi
     nop.m                 999
     fma.s1    exp_Rsq   =    exp_R,exp_R,f0
     nop.i                 999
}
{ .mfi
     nop.m                 999
     fma.s1    exp_P3    =    exp_R,exp_coeff_P2,exp_coeff_P1
     nop.i                 999 
}
;;

{ .mfi
     nop.m                 999
     fma.s1    exp_P1    =    exp_R,exp_coeff_P6,exp_coeff_P5
     nop.i                 999 
}
{ .mfi
     nop.m                 999
     fma.s1    exp_P2    =    exp_R,exp_coeff_P4,exp_coeff_P3
     nop.i                 999
}
;;


{ .mfi
     nop.m                 999
     fma.s1    exp_P7    =    f1,exp_R,f1
     nop.i                 999
}
;;


{ .mfi
     nop.m                 999
     fma.s1    exp_P5    =    exp_Rsq,exp_P3,f0
     nop.i                 999
}
{ .mfi
     nop.m                 999
     fma.s1    exp_R4    =    exp_Rsq,exp_Rsq,f0
     nop.i                 999 
}
;;

{ .mfi
     nop.m                 999
     fma.s1    exp_T     =    exp_T1,exp_T2,f0
     nop.i                 999 
}
{ .mfi
     nop.m                 999
     fma.s1    exp_P4    =    exp_Rsq,exp_P1,exp_P2
     nop.i                 999 
}
;;

// There is a potential monotonicity problem in round to +inf.  If x is 
// very small and negative, exp_P7 (and exp_A) will round to 1.0, 
// whereas exp_P6 will be very small, but positive.  This would result in the 
// final calculation rounding to 3f800001.  To fix this, we test for |x|<=2^63.
// If so, the result will be set to 1+x.

{ .mfi
     cmp.ge  p6,p7 = -63, exp_GR_exp
     fma.s1    exp_A     =    exp_T,exp_P7,f0
     nop.i                 999
}
{ .mfi
     nop.m                 999
     fma.s1    exp_P6    =    exp_R4,exp_P4,exp_P5
     nop.i                 999
}
;;

{ .bbb
(p12) br.cond.spnt EXP_CERTAIN_UNDERFLOW
(p13) br.cond.spnt EXP_POSSIBLE_UNDERFLOW
(p14) br.cond.spnt EXP_POSSIBLE_OVERFLOW
}
;;

{ .mfi
     nop.m                 999
(p6) fma.s     f8   =    f1,f1,exp_norm_f8
     nop.i                 999
}
{ .mfb
     nop.m            999
(p7) fma.s     f8   =    exp_T,exp_P6,exp_A
     br.ret.sptk     b0
}
;;

EXP_POSSIBLE_OVERFLOW:

// We got an answer. EXP_MAX_SGL_NORM_ARG < x < EXP_MIN_SGL_OFLOW_ARG
// overflow is a possibility, not a certainty
// Set wre in s2 and perform the last operation with s2

// We define an overflow when the answer with
//    WRE set
//    user-defined rounding mode
// is lsn +1

// Is the exponent 1 more than the largest single?
// If so, go to ERROR RETURN, else (no overflow) get the answer and
// leave.

// Largest single is FE (biased single)
//                   FE - 7F + FFFF = 1007E

// Create + largest_single_plus_ulp
// Create - largest_single_plus_ulp

// Calculate answer with WRE set.

// Cases when answer is lsn+1  are as follows:

//           midpoint
//              |
//  lsn         |         lsn+1
// --+----------|----------+------------
//              |
//    +inf          +inf      -inf
//                  RN         RN
//                             RZ
// exp_gt_pln contains the floating point number lsn+1.
// The setf.exp puts 0x1007f in the exponent and 0x800... in the significand.

// If the answer is >= lsn+1, we have overflowed.
// Then p6 is TRUE. Set the overflow tag, save input in FR_X,
// do the final calculation for IEEE result, and branch to error return.

{ .mfi
       mov         exp_GR_gt_ln    = 0x1007F 
       fsetc.s2    0x7F,0x42
       nop.i 999
}
;;

{ .mfi
       setf.exp      exp_gt_pln    = exp_GR_gt_ln
       fma.s.s2    exp_wre_urm_f8  = exp_T,  exp_P6, exp_A
       nop.i 999
}
;;

{ .mfi
       nop.m 999
       fsetc.s2 0x7F,0x40
       nop.i 999
}
;;

{ .mfi
       nop.m 999
       fcmp.ge.unc.s1 p6, p0       =  exp_wre_urm_f8, exp_gt_pln
       nop.i 999
}
;;

{ .mfb
       nop.m 999
       nop.f 999
(p6)   br.cond.spnt EXP_CERTAIN_OVERFLOW  // Branch if really overflow
}
;;

{ .mfb
       nop.m 999
       fma.s        f8             = exp_T,  exp_P6, exp_A
       br.ret.sptk     b0                 // Exit if really no overflow
}
;;

EXP_CERTAIN_OVERFLOW:
{ .mmi
      sub   exp_GR_17ones_m1 = exp_GR_17ones, r0, 1 ;;
      setf.exp     f9 = exp_GR_17ones_m1
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
      fmerge.s FR_X = f8,f8
      nop.i 999
}
{ .mfb
      mov        GR_Parameter_TAG = 16
      fma.s       FR_RESULT = f9, f9, f0    // Set I,O and +INF result
      br.cond.sptk  __libm_error_region ;;                             
}

EXP_POSSIBLE_UNDERFLOW: 

// We got an answer. EXP_MAX_SGL_UFLOW_ARG < x < EXP_MIN_SGL_NORM_ARG
// underflow is a possibility, not a certainty

// We define an underflow when the answer with
//    ftz set
// is zero (tiny numbers become zero)

// Notice (from below) that if we have an unlimited exponent range,
// then there is an extra machine number E between the largest denormal and
// the smallest normal.

// So if with unbounded exponent we round to E or below, then we are
// tiny and underflow has occurred.

// But notice that you can be in a situation where we are tiny, namely
// rounded to E, but when the exponent is bounded we round to smallest
// normal. So the answer can be the smallest normal with underflow.

//                           E
// -----+--------------------+--------------------+-----
//      |                    |                    |
//   1.1...10 2^-7f      1.1...11 2^-7f      1.0...00 2^-7e  
//   0.1...11 2^-7e                                     (biased, 1)
//    largest dn                               smallest normal

// If the answer is = 0, we have underflowed.
// Then p6 is TRUE. Set the underflow tag, save input in FR_X,
// do the final calculation for IEEE result, and branch to error return.

{ .mfi
       nop.m 999
       fsetc.s2 0x7F,0x41
       nop.i 999
}
;;

{ .mfi
       nop.m 999
       fma.s.s2     exp_ftz_urm_f8  = exp_T,  exp_P6, exp_A
       nop.i 999
}
;;


{ .mfi
       nop.m 999
       fsetc.s2 0x7F,0x40
       nop.i 999
}
;;

{ .mfi
       nop.m 999
       fcmp.eq.unc.s1 p6, p0     =  exp_ftz_urm_f8, f0
       nop.i 999
}
;;

{ .mfb
       nop.m 999
       nop.f 999
(p6)   br.cond.spnt EXP_CERTAIN_UNDERFLOW  // Branch if really underflow 
}
;;

{ .mfb
       nop.m 999
       fma.s        f8             = exp_T,  exp_P6, exp_A
       br.ret.sptk     b0                  // Exit if really no underflow
}
;;

EXP_CERTAIN_UNDERFLOW:
{ .mfi
      nop.m 999
      fmerge.s FR_X = f8,f8
      nop.i 999
}
{ .mfb
      mov        GR_Parameter_TAG = 17
      fma.s       FR_RESULT  = exp_T, exp_P6, exp_A // Set I,U and tiny result
      br.cond.sptk  __libm_error_region ;;                             
}

EXP_CERTAIN_UNDERFLOW_ZERO:
{ .mmi
      mov   exp_GR_one = 1 ;;
      setf.exp     f9 = exp_GR_one
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
      fmerge.s FR_X = f8,f8
      nop.i 999
}
{ .mfb
      mov        GR_Parameter_TAG = 17
      fma.s       FR_RESULT = f9, f9, f0    // Set I,U and tiny (+0.0) result
      br.cond.sptk  __libm_error_region ;;                             
}

.endp expf


.proc __libm_error_region
__libm_error_region:
.prologue
{ .mfi
        add   GR_Parameter_Y=-32,sp             // Parameter 2 value
	nop.f 999
.save   ar.pfs,GR_SAVE_PFS
        mov  GR_SAVE_PFS=ar.pfs                 // Save ar.pfs
}
{ .mfi
.fframe 64
        add sp=-64,sp                           // Create new stack
        nop.f 0
        mov GR_SAVE_GP=gp                       // Save gp
};;
{ .mmi
        stfs [GR_Parameter_Y] = FR_Y,16         // Store Parameter 2 on stack
        add GR_Parameter_X = 16,sp              // Parameter 1 address
.save   b0, GR_SAVE_B0
        mov GR_SAVE_B0=b0                       // Save b0
};;
.body
{ .mfi
        stfs [GR_Parameter_X] = FR_X            // Store Parameter 1 on stack
        nop.f 0
        add   GR_Parameter_RESULT = 0,GR_Parameter_Y // Parameter 3 address
}
{ .mib
        stfs [GR_Parameter_Y] = FR_RESULT       // Store Parameter 3 on stack
        add   GR_Parameter_Y = -16,GR_Parameter_Y
        br.call.sptk b0=__libm_error_support#   // Call error handling function
};;

{ .mmi
        nop.m 0
        nop.m 0
        add   GR_Parameter_RESULT = 48,sp
};;

{ .mmi
        ldfs  f8 = [GR_Parameter_RESULT]       // Get return result off stack
.restore
        add   sp = 64,sp                       // Restore stack pointer
        mov   b0 = GR_SAVE_B0                  // Restore return address
};;
{ .mib
        mov   gp = GR_SAVE_GP                  // Restore gp 
        mov   ar.pfs = GR_SAVE_PFS             // Restore ar.pfs
        br.ret.sptk     b0                     // Return
};; 

.endp __libm_error_region


.type   __libm_error_support#,@function
.global __libm_error_support#
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\ia64\coshf.s ===
.file "coshf.s"

// Copyright (c) 2000, 2001, Intel Corporation
// All rights reserved.
// 
// Contributed 2/2/2000 by John Harrison, Ted Kubaska, Bob Norin, Shane Story,
// and Ping Tak Peter Tang of the Computational Software Lab, Intel Corporation.
// 
// WARRANTY DISCLAIMER
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS 
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY 
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
// 
// Intel Corporation is the author of this code, and requests that all
// problem reports or change requests be submitted to it directly at 
// http://developer.intel.com/opensource.
//
// History
//==============================================================
// 2/02/00  Initial version
// 2/16/00  The error tag for coshf overflow changed to 65 (from 64).
// 4/04/00  Unwind support added
// 8/15/00  Bundle added after call to __libm_error_support to properly
//          set [the previously overwritten] GR_Parameter_RESULT.
// 5/07/01  Reworked to improve speed of all paths
//
// API
//==============================================================
// float = coshf(float)
// input  floating point f8
// output floating point f8
//
// Registers used
//==============================================================
// general registers: 
// r32 -> r47
// predicate registers used:
// p6 -> p11
// floating-point registers used:
// f9 -> f15; f32 -> f90; 
// f8 has input, then output
//
// Overview of operation
//==============================================================
// There are seven paths
// 1. 0 < |x| < 0.25          COSH_BY_POLY
// 2. 0.25 <=|x| < 32         COSH_BY_TBL
// 3. 32 <= |x| < 89.415986   COSH_BY_EXP (merged path with COSH_BY_TBL)
// 4. |x| >= 89.415986        COSH_HUGE
// 5. x=0                     Done with early exit
// 6. x=inf,nan               Done with early exit
// 7. x=denormal              COSH_DENORM
//
// For float we get overflow for x >= 4005 b2d4 fc27 c173 18a0
//                                 >= 89.415986
//
//
// 1. COSH_BY_POLY   0 < |x| < 0.25
// ===============
// Evaluate cosh(x) by a 12th order polynomial
// Care is take for the order of multiplication; and P2 is not exactly 1/4!, 
// P3 is not exactly 1/6!, etc.
// cosh(x) = 1 + (P1*x^2 + P2*x^4 + P3*x^6 + P4*x^8 + P5*x^10 + P6*x^12)
//
// 2. COSH_BY_TBL   0.25 <= |x| < 32.0
// =============
// cosh(x) = cosh(B+R)
//         = cosh(B)cosh(R) + sinh(B)sinh(R)
// 
// ax = |x| = M*log2/64 + R
// B = M*log2/64
// M = 64*N + j 
//   We will calculate M and get N as (M-j)/64
//   The division is a shift.
// exp(B)  = exp(N*log2 + j*log2/64)
//         = 2^N * 2^(j*log2/64)
// cosh(B) = 1/2(e^B + e^-B)
//         = 1/2(2^N * 2^(j*log2/64) + 2^-N * 2^(-j*log2/64)) 
// cosh(B) = (2^(N-1) * 2^(j*log2/64) + 2^(-N-1) * 2^(-j*log2/64)) 
// sinh(B) = (2^(N-1) * 2^(j*log2/64) - 2^(-N-1) * 2^(-j*log2/64)) 
// 2^(j*log2/64) is stored as Tjhi + Tjlo , j= -32,....,32
// Tjhi is double-extended (80-bit) and Tjlo is single(32-bit)
//
// R = ax - M*log2/64
// R = ax - M*log2_by_64_hi - M*log2_by_64_lo
// exp(R) = 1 + R +R^2(1/2! + R(1/3! + R(1/4! + ... + R(1/n!)...)
//        = 1 + p_odd + p_even
//        where the p_even uses the A coefficients and the p_even uses 
//        the B coefficients
//
// So sinh(R) = 1 + p_odd + p_even -(1 -p_odd -p_even)/2 = p_odd
//    cosh(R) = 1 + p_even
//    cosh(B) = C_hi + C_lo
//    sinh(B) = S_hi
// cosh(x) = cosh(B)cosh(R) + sinh(B)sinh(R)
//
// 3. COSH_BY_EXP   32.0 <= |x| < 89.415986  ( 4005 b2d4 fc27 c173 18a0 )
// ==============
// Can approximate result by exp(x)/2 in this region.
// Y_hi = Tjhi
// Y_lo = Tjhi * (p_odd + p_even) + Tjlo
// cosh(x) = Y_hi + Y_lo
//
// 4. COSH_HUGE     |x| >= 89.415986  ( 4005 b2d4 fc27 c173 18a0 )
// ============
// Set error tag and call error support
//
//
// Assembly macros
//==============================================================
cosh_GR_ad1          = r34
cosh_GR_Mmj          = r34
cosh_GR_jshf         = r36
cosh_GR_M            = r35
cosh_GR_N            = r35
cosh_GR_exp_2tom57   = r36
cosh_GR_j            = r36
cosh_GR_joff         = r36
cosh_GR_exp_mask     = r37
cosh_GR_mJ           = r38
cosh_AD_mJ           = r38
cosh_GR_signexp_x    = r38
cosh_GR_signexp_0_5  = r38
cosh_GR_exp_0_25     = r39
cosh_GR_J            = r39
cosh_AD_J            = r39
cosh_GR_sig_inv_ln2  = r40
cosh_GR_exp_32       = r40
cosh_GR_exp_huge     = r40
cosh_GR_all_ones     = r40

cosh_GR_ad2e         = r41
cosh_GR_ad3          = r42
cosh_GR_ad4          = r43
cosh_GR_rshf         = r44
cosh_GR_ad2o         = r45
cosh_GR_rshf_2to57   = r46
cosh_GR_exp_denorm   = r46
cosh_GR_exp_x        = r47


GR_SAVE_PFS          = r41
GR_SAVE_B0           = r42
GR_SAVE_GP           = r43

GR_Parameter_X       = r44
GR_Parameter_Y       = r45
GR_Parameter_RESULT  = r46
GR_Parameter_TAG     = r47


cosh_FR_ABS_X        = f9 
cosh_FR_X2           = f10
cosh_FR_X4           = f11
cosh_FR_all_ones     = f13
cosh_FR_tmp          = f14
cosh_FR_RSHF         = f15

cosh_FR_Inv_log2by64 = f32
cosh_FR_log2by64_lo  = f33
cosh_FR_log2by64_hi  = f34
cosh_FR_A1           = f35

cosh_FR_A2           = f36
cosh_FR_A3           = f37
cosh_FR_Rcub         = f38
cosh_FR_M_temp       = f39
cosh_FR_R_temp       = f40

cosh_FR_Rsq          = f41
cosh_FR_R            = f42
cosh_FR_M            = f43
cosh_FR_B1           = f44
cosh_FR_B2           = f45

cosh_FR_B3           = f46
cosh_FR_peven_temp1  = f47
cosh_FR_peven_temp2  = f48
cosh_FR_peven        = f49
cosh_FR_podd_temp1   = f50

cosh_FR_podd_temp2   = f51
cosh_FR_podd         = f52
cosh_FR_poly65       = f53
cosh_FR_poly6543     = f53
cosh_FR_poly6to1     = f53
cosh_FR_poly43       = f54
cosh_FR_poly21       = f55

cosh_FR_INV_LN2_2TO63= f57
cosh_FR_RSHF_2TO57   = f58
cosh_FR_2TOM57       = f59
cosh_FR_smlst_oflow_input = f60

cosh_FR_pre_result   = f61
cosh_FR_huge         = f62
cosh_FR_spos         = f63
cosh_FR_sneg         = f64
cosh_FR_Tjhi         = f65

cosh_FR_Tjlo         = f66
cosh_FR_Tmjhi        = f67
cosh_FR_Tmjlo        = f68
cosh_FR_S_hi         = f69
cosh_FR_SC_hi_temp   = f70

cosh_FR_C_lo_temp1   = f71 
cosh_FR_C_lo_temp2   = f72 
cosh_FR_C_lo_temp3   = f73 
cosh_FR_C_lo_temp4   = f73 
cosh_FR_C_lo         = f74
cosh_FR_C_hi         = f75

cosh_FR_C_hi_temp1   = f76
cosh_FR_Y_hi         = f77 
cosh_FR_Y_lo_temp    = f78 
cosh_FR_Y_lo         = f79 
cosh_FR_NORM_X       = f80

cosh_FR_P1           = f81
cosh_FR_P2           = f82
cosh_FR_P3           = f83
cosh_FR_P4           = f84
cosh_FR_P5           = f85

cosh_FR_P6           = f86
cosh_FR_Tjhi_spos    = f87
cosh_FR_Tjlo_spos    = f88
cosh_FR_huge         = f89
cosh_FR_signed_hi_lo = f90


// Data tables
//==============================================================

// DO NOT CHANGE ORDER OF THESE TABLES
.data

.align 16
double_cosh_arg_reduction:
//   data8 0xB8AA3B295C17F0BC, 0x00004005  // 64/log2 -- signif loaded with setf
   data8 0xB17217F7D1000000, 0x00003FF8  // log2/64 high part
   data8 0xCF79ABC9E3B39804, 0x00003FD0  // log2/64 low part

double_cosh_p_table:
   data8 0xb2d4fc27c17318a0, 0x00004005  // Smallest x to overflow (89.415986)
   data8 0x8FA02AC65BCBD5BC, 0x00003FE2  // P6
   data8 0xD00D00D1021D7370, 0x00003FEF  // P4
   data8 0xAAAAAAAAAAAAAB80, 0x00003FFA  // P2
   data8 0x93F27740C0C2F1CC, 0x00003FE9  // P5
   data8 0xB60B60B60B4FE884, 0x00003FF5  // P3
   data8 0x8000000000000000, 0x00003FFE  // P1

double_cosh_ab_table:
   data8 0xAAAAAAAAAAAAAAAC, 0x00003FFC  // A1
   data8 0x88888888884ECDD5, 0x00003FF8  // A2
   data8 0xD00D0C6DCC26A86B, 0x00003FF2  // A3
   data8 0x8000000000000002, 0x00003FFE  // B1
   data8 0xAAAAAAAAAA402C77, 0x00003FFA  // B2
   data8 0xB60B6CC96BDB144D, 0x00003FF5  // B3

double_cosh_j_table:
   data8 0xB504F333F9DE6484, 0x00003FFE, 0x1EB2FB13, 0x00000000
   data8 0xB6FD91E328D17791, 0x00003FFE, 0x1CE2CBE2, 0x00000000
   data8 0xB8FBAF4762FB9EE9, 0x00003FFE, 0x1DDC3CBC, 0x00000000
   data8 0xBAFF5AB2133E45FB, 0x00003FFE, 0x1EE9AA34, 0x00000000
   data8 0xBD08A39F580C36BF, 0x00003FFE, 0x9EAEFDC1, 0x00000000
   data8 0xBF1799B67A731083, 0x00003FFE, 0x9DBF517B, 0x00000000
   data8 0xC12C4CCA66709456, 0x00003FFE, 0x1EF88AFB, 0x00000000
   data8 0xC346CCDA24976407, 0x00003FFE, 0x1E03B216, 0x00000000
   data8 0xC5672A115506DADD, 0x00003FFE, 0x1E78AB43, 0x00000000
   data8 0xC78D74C8ABB9B15D, 0x00003FFE, 0x9E7B1747, 0x00000000
   data8 0xC9B9BD866E2F27A3, 0x00003FFE, 0x9EFE3C0E, 0x00000000
   data8 0xCBEC14FEF2727C5D, 0x00003FFE, 0x9D36F837, 0x00000000
   data8 0xCE248C151F8480E4, 0x00003FFE, 0x9DEE53E4, 0x00000000
   data8 0xD06333DAEF2B2595, 0x00003FFE, 0x9E24AE8E, 0x00000000
   data8 0xD2A81D91F12AE45A, 0x00003FFE, 0x1D912473, 0x00000000
   data8 0xD4F35AABCFEDFA1F, 0x00003FFE, 0x1EB243BE, 0x00000000
   data8 0xD744FCCAD69D6AF4, 0x00003FFE, 0x1E669A2F, 0x00000000
   data8 0xD99D15C278AFD7B6, 0x00003FFE, 0x9BBC610A, 0x00000000
   data8 0xDBFBB797DAF23755, 0x00003FFE, 0x1E761035, 0x00000000
   data8 0xDE60F4825E0E9124, 0x00003FFE, 0x9E0BE175, 0x00000000
   data8 0xE0CCDEEC2A94E111, 0x00003FFE, 0x1CCB12A1, 0x00000000
   data8 0xE33F8972BE8A5A51, 0x00003FFE, 0x1D1BFE90, 0x00000000
   data8 0xE5B906E77C8348A8, 0x00003FFE, 0x1DF2F47A, 0x00000000
   data8 0xE8396A503C4BDC68, 0x00003FFE, 0x1EF22F22, 0x00000000
   data8 0xEAC0C6E7DD24392F, 0x00003FFE, 0x9E3F4A29, 0x00000000
   data8 0xED4F301ED9942B84, 0x00003FFE, 0x1EC01A5B, 0x00000000
   data8 0xEFE4B99BDCDAF5CB, 0x00003FFE, 0x1E8CAC3A, 0x00000000
   data8 0xF281773C59FFB13A, 0x00003FFE, 0x9DBB3FAB, 0x00000000
   data8 0xF5257D152486CC2C, 0x00003FFE, 0x1EF73A19, 0x00000000
   data8 0xF7D0DF730AD13BB9, 0x00003FFE, 0x9BB795B5, 0x00000000
   data8 0xFA83B2DB722A033A, 0x00003FFE, 0x1EF84B76, 0x00000000
   data8 0xFD3E0C0CF486C175, 0x00003FFE, 0x9EF5818B, 0x00000000
   data8 0x8000000000000000, 0x00003FFF, 0x00000000, 0x00000000
   data8 0x8164D1F3BC030773, 0x00003FFF, 0x1F77CACA, 0x00000000
   data8 0x82CD8698AC2BA1D7, 0x00003FFF, 0x1EF8A91D, 0x00000000
   data8 0x843A28C3ACDE4046, 0x00003FFF, 0x1E57C976, 0x00000000
   data8 0x85AAC367CC487B15, 0x00003FFF, 0x9EE8DA92, 0x00000000
   data8 0x871F61969E8D1010, 0x00003FFF, 0x1EE85C9F, 0x00000000
   data8 0x88980E8092DA8527, 0x00003FFF, 0x1F3BF1AF, 0x00000000
   data8 0x8A14D575496EFD9A, 0x00003FFF, 0x1D80CA1E, 0x00000000
   data8 0x8B95C1E3EA8BD6E7, 0x00003FFF, 0x9D0373AF, 0x00000000
   data8 0x8D1ADF5B7E5BA9E6, 0x00003FFF, 0x9F167097, 0x00000000
   data8 0x8EA4398B45CD53C0, 0x00003FFF, 0x1EB70051, 0x00000000
   data8 0x9031DC431466B1DC, 0x00003FFF, 0x1F6EB029, 0x00000000
   data8 0x91C3D373AB11C336, 0x00003FFF, 0x1DFD6D8E, 0x00000000
   data8 0x935A2B2F13E6E92C, 0x00003FFF, 0x9EB319B0, 0x00000000
   data8 0x94F4EFA8FEF70961, 0x00003FFF, 0x1EBA2BEB, 0x00000000
   data8 0x96942D3720185A00, 0x00003FFF, 0x1F11D537, 0x00000000
   data8 0x9837F0518DB8A96F, 0x00003FFF, 0x1F0D5A46, 0x00000000
   data8 0x99E0459320B7FA65, 0x00003FFF, 0x9E5E7BCA, 0x00000000
   data8 0x9B8D39B9D54E5539, 0x00003FFF, 0x9F3AAFD1, 0x00000000
   data8 0x9D3ED9A72CFFB751, 0x00003FFF, 0x9E86DACC, 0x00000000
   data8 0x9EF5326091A111AE, 0x00003FFF, 0x9F3EDDC2, 0x00000000
   data8 0xA0B0510FB9714FC2, 0x00003FFF, 0x1E496E3D, 0x00000000
   data8 0xA27043030C496819, 0x00003FFF, 0x9F490BF6, 0x00000000
   data8 0xA43515AE09E6809E, 0x00003FFF, 0x1DD1DB48, 0x00000000
   data8 0xA5FED6A9B15138EA, 0x00003FFF, 0x1E65EBFB, 0x00000000
   data8 0xA7CD93B4E965356A, 0x00003FFF, 0x9F427496, 0x00000000
   data8 0xA9A15AB4EA7C0EF8, 0x00003FFF, 0x1F283C4A, 0x00000000
   data8 0xAB7A39B5A93ED337, 0x00003FFF, 0x1F4B0047, 0x00000000
   data8 0xAD583EEA42A14AC6, 0x00003FFF, 0x1F130152, 0x00000000
   data8 0xAF3B78AD690A4375, 0x00003FFF, 0x9E8367C0, 0x00000000
   data8 0xB123F581D2AC2590, 0x00003FFF, 0x9F705F90, 0x00000000
   data8 0xB311C412A9112489, 0x00003FFF, 0x1EFB3C53, 0x00000000
   data8 0xB504F333F9DE6484, 0x00003FFF, 0x1F32FB13, 0x00000000

.align 32
.global coshf#

.section .text
.proc  coshf#
.align 32

coshf: 

{ .mlx
      alloc r32 = ar.pfs,0,12,4,0                  
      movl  cosh_GR_sig_inv_ln2 = 0xb8aa3b295c17f0bc // significand of 1/ln2
}
{ .mlx
      addl cosh_GR_ad1   = @ltoff(double_cosh_arg_reduction), gp
      movl  cosh_GR_rshf_2to57 = 0x4778000000000000 // 1.10000 2^(63+57)
}
;;

{ .mfi
      ld8 cosh_GR_ad1 = [cosh_GR_ad1]
      fmerge.s      cosh_FR_ABS_X    = f0,f8
      mov  cosh_GR_exp_0_25 = 0x0fffd    // Form exponent for 0.25
}
{ .mfi
      nop.m 999
      fnorm.s1  cosh_FR_NORM_X = f8      
      mov cosh_GR_exp_2tom57 = 0xffff-57
}
;;

{ .mfi
      setf.d cosh_FR_RSHF_2TO57 = cosh_GR_rshf_2to57 // Form const 1.100 * 2^120
      fclass.m p10,p0 = f8, 0x0b         // Test for denorm
      mov  cosh_GR_exp_mask = 0x1ffff 
}
{ .mlx
      setf.sig cosh_FR_INV_LN2_2TO63 = cosh_GR_sig_inv_ln2 // Form 1/ln2 * 2^63
      movl  cosh_GR_rshf = 0x43e8000000000000 // 1.10000 2^63 for right shift
}
;;

{ .mfi
      getf.exp  cosh_GR_signexp_x = f8   // Extract signexp of x
      fclass.m  p7,p0 = f8, 0x07	// Test if x=0
      nop.i 999
}
{ .mfi
      setf.exp cosh_FR_2TOM57 = cosh_GR_exp_2tom57 // Form 2^-57 for scaling
      nop.f 999
      add  cosh_GR_ad3 = 0x90, cosh_GR_ad1  // Point to ab_table
}
;;

{ .mfi
      setf.d cosh_FR_RSHF = cosh_GR_rshf // Form right shift const 1.100 * 2^63
      fclass.m  p6,p0 = f8, 0xc3	// Test if x nan
      add  cosh_GR_ad4 = 0x4f0, cosh_GR_ad1 // Point to j_table midpoint
}
{ .mib
      add  cosh_GR_ad2e = 0x20, cosh_GR_ad1 // Point to p_table
      mov cosh_GR_all_ones = -1
(p10) br.cond.spnt  COSH_DENORM         // Branch if x denorm
}
;;

// Common path -- return here from COSH_DENORM if x is unnorm
COSH_COMMON:
{ .mfi
      ldfe            cosh_FR_smlst_oflow_input = [cosh_GR_ad2e],16
      fclass.m  p10,p0 = f8, 0x23	// Test if x inf
      and  cosh_GR_exp_x = cosh_GR_exp_mask, cosh_GR_signexp_x
}
{ .mfb
      ldfe            cosh_FR_log2by64_hi  = [cosh_GR_ad1],16       
(p7)  fma.s.s0   f8 = f1,f1,f0          // If x=0, result is 1.0
(p7)  br.ret.spnt   b0                  // Exit if x=0
}
;;

{ .mfi
// Make constant that will generate inexact when squared
      setf.sig cosh_FR_all_ones = cosh_GR_all_ones 
      nop.f 999
      cmp.ge p7,p0 = cosh_GR_exp_x, cosh_GR_exp_0_25  // Test x < 0.25
}
{ .mfb
      add  cosh_GR_ad2o = 0x30, cosh_GR_ad2e  // Point to p_table odd coeffs
(p6)  fma.s.s0   f8 = f8,f1,f8           // If x nan, return quietized nan
(p6)  br.ret.spnt     b0                 // Exit for x nan
}
;;

// Get the A coefficients for COSH_BY_TBL
// Calculate X2 = ax*ax for COSH_BY_POLY
{ .mfi
      ldfe            cosh_FR_log2by64_lo  = [cosh_GR_ad1],16       
(p10) fmerge.s  f8 = f0, f8             // If x inf, result is +inf
      nop.i 999
}
{ .mfb
      ldfe            cosh_FR_A1 = [cosh_GR_ad3],16            
      fma.s1        cosh_FR_X2 = cosh_FR_ABS_X, cosh_FR_ABS_X, f0
(p7)  br.cond.sptk    COSH_BY_TBL
}
;;

// Here if 0 < |x| < 0.25
COSH_BY_POLY: 
{ .mmf
      ldfe            cosh_FR_P6 = [cosh_GR_ad2e],16
      ldfe            cosh_FR_P5 = [cosh_GR_ad2o],16
      nop.f 999
}
;;

{ .mmi
      ldfe            cosh_FR_P4 = [cosh_GR_ad2e],16
      ldfe            cosh_FR_P3 = [cosh_GR_ad2o],16
      nop.i 999
}
;;

{ .mmi
      ldfe            cosh_FR_P2 = [cosh_GR_ad2e],16
      ldfe            cosh_FR_P1 = [cosh_GR_ad2o],16                 
      nop.i 999
}
;;

{ .mfi
      nop.m 999
      fma.s1        cosh_FR_X4 = cosh_FR_X2, cosh_FR_X2, f0
      nop.i 999
}
;;

{ .mfi
      nop.m 999
      fma.s1      cosh_FR_poly65 = cosh_FR_X2, cosh_FR_P6, cosh_FR_P5
      nop.i 999
}
{ .mfi
      nop.m 999
      fma.s1      cosh_FR_poly43 = cosh_FR_X2, cosh_FR_P4, cosh_FR_P3
      nop.i 999
}
;;

{ .mfi
      nop.m 999
      fma.s1      cosh_FR_poly21 = cosh_FR_X2, cosh_FR_P2, cosh_FR_P1
      nop.i 999
}
;;

{ .mfi
      nop.m 999
      fma.s1   cosh_FR_poly6543 = cosh_FR_X4, cosh_FR_poly65, cosh_FR_poly43
      nop.i 999
}
;;

{ .mfi
      nop.m 999
      fma.s1   cosh_FR_poly6to1 = cosh_FR_X4, cosh_FR_poly6543, cosh_FR_poly21
      nop.i 999
}
;;

// Dummy multiply to generate inexact
{ .mfi
      nop.m 999
      fmpy.s0      cosh_FR_tmp = cosh_FR_all_ones, cosh_FR_all_ones
      nop.i 999
}
{ .mfb
      nop.m 999
      fma.s.s0      f8 = cosh_FR_poly6to1, cosh_FR_X2, f1
      br.ret.sptk     b0                // Exit COSH_BY_POLY
}
;;



// Here if |x| >= 0.25
COSH_BY_TBL: 
// ******************************************************
// STEP 1 (TBL and EXP) - Argument reduction
// ******************************************************
// Get the following constants. 
// Inv_log2by64
// log2by64_hi
// log2by64_lo


// We want 2^(N-1) and 2^(-N-1). So bias N-1 and -N-1 and
// put them in an exponent.
// cosh_FR_spos = 2^(N-1) and cosh_FR_sneg = 2^(-N-1)
// 0xffff + (N-1)  = 0xffff +N -1
// 0xffff - (N +1) = 0xffff -N -1


// Calculate M and keep it as integer and floating point.
// M = round-to-integer(x*Inv_log2by64)
// cosh_FR_M = M = truncate(ax/(log2/64))
// Put the integer representation of M in cosh_GR_M
//    and the floating point representation of M in cosh_FR_M

// Get the remaining A,B coefficients
{ .mfb
      ldfe            cosh_FR_A2 = [cosh_GR_ad3],16            
      nop.f 999
(p10) br.ret.spnt  b0                   // Exit if x inf
}
;;

{ .mmi
      ldfe            cosh_FR_A3 = [cosh_GR_ad3],16 ;;
      ldfe            cosh_FR_B1 = [cosh_GR_ad3],16
      nop.i 999
}
;;

// Use constant (1.100*2^(63-6)) to get rounded M into rightmost significand
// |x| * 64 * 1/ln2 * 2^(63-6) + 1.1000 * 2^(63+(63-6))
{ .mfi
      nop.m 999
      fma.s1  cosh_FR_M_temp = cosh_FR_ABS_X, cosh_FR_INV_LN2_2TO63, cosh_FR_RSHF_2TO57
      mov  cosh_GR_signexp_0_5 = 0x0fffe // signexp of +0.5
}
;;

// Test for |x| >= overflow limit
{ .mfi
      nop.m 999
      fcmp.ge.s1  p6,p0 = cosh_FR_ABS_X, cosh_FR_smlst_oflow_input
      nop.i 999
}
;;

{ .mfi
      ldfe            cosh_FR_B2 = [cosh_GR_ad3],16
      nop.f 999
      nop.i 999
}
;;

// Subtract RSHF constant to get rounded M as a floating point value
// M_temp * 2^(63-6) - 2^63
{ .mfb
      ldfe            cosh_FR_B3 = [cosh_GR_ad3],16            
      fms.s1        cosh_FR_M = cosh_FR_M_temp, cosh_FR_2TOM57, cosh_FR_RSHF
(p6)  br.cond.spnt    COSH_HUGE  // Branch if result will overflow
}
;;

{ .mfi
      getf.sig        cosh_GR_M       = cosh_FR_M_temp                 
      nop.f 999
      nop.i 999
}
;;

// Calculate j. j is the signed extension of the six lsb of M. It 
// has a range of -32 thru 31.

// Calculate R
// ax - M*log2by64_hi
// R = (ax - M*log2by64_hi) - M*log2by64_lo

{ .mfi
      nop.m 999
      fnma.s1 cosh_FR_R_temp = cosh_FR_M, cosh_FR_log2by64_hi, cosh_FR_ABS_X
      and     cosh_GR_j = 0x3f, cosh_GR_M
}
;;

{ .mii
      nop.m 999
      shl     cosh_GR_jshf = cosh_GR_j, 0x2 ;;  // Shift j so can sign extend it
      sxt1    cosh_GR_jshf = cosh_GR_jshf
}
;;

// N = (M-j)/64
{ .mii
      mov     cosh_GR_exp_32 = 0x10004
      shr     cosh_GR_j = cosh_GR_jshf, 0x2 ;;   // Now j has range -32 to 31
      sub     cosh_GR_Mmj = cosh_GR_M, cosh_GR_j ;;   // M-j
}
;;

// The TBL and EXP branches are merged and predicated
// If TBL, p6 true, 0.25 <= |x| < 32
// If EXP, p7 true, 32 <= |x| < overflow_limit
//
{ .mfi
      cmp.ge p7,p6 = cosh_GR_exp_x, cosh_GR_exp_32 // Test if x >= 32
      fnma.s1  cosh_FR_R      = cosh_FR_M, cosh_FR_log2by64_lo, cosh_FR_R_temp 
      shr            cosh_GR_N = cosh_GR_Mmj, 0x6    // N = (M-j)/64 
}
;;

{ .mmi
      sub  r40 = cosh_GR_signexp_0_5, cosh_GR_N // signexp of 2^(-N-1)
      add  r39 = cosh_GR_signexp_0_5, cosh_GR_N // signexp of 2^(N-1)
      shl  cosh_GR_joff = cosh_GR_j,5         // Make j offset to j_table
}
;;

{ .mfi
      setf.exp            cosh_FR_spos = r39  // Form 2^(N-1)
      nop.f 999
      sub                 cosh_GR_mJ = r0, cosh_GR_joff // Table offset for -j
}
{ .mfi
      setf.exp            cosh_FR_sneg = r40  // Form 2^(-N-1)
      nop.f 999
      add                 cosh_GR_J  = r0, cosh_GR_joff // Table offset for +j
}
;;

// Get the address of the J table midpoint, add the offset 
{ .mmf
      add                  cosh_AD_mJ = cosh_GR_ad4, cosh_GR_mJ
      add                  cosh_AD_J  = cosh_GR_ad4, cosh_GR_J
      nop.f 999
}
;;

{ .mmf
      ldfe                 cosh_FR_Tmjhi = [cosh_AD_mJ],16                 
      ldfe                 cosh_FR_Tjhi  = [cosh_AD_J],16
      nop.f 999
}
;;

// ******************************************************
// STEP 2 (TBL and EXP)
// ******************************************************
// Calculate Rsquared and Rcubed in preparation for p_even and p_odd

{ .mmf
      ldfs                 cosh_FR_Tmjlo = [cosh_AD_mJ],16                 
      ldfs                 cosh_FR_Tjlo  = [cosh_AD_J],16                  
      fma.s1             cosh_FR_Rsq  = cosh_FR_R, cosh_FR_R, f0
}
;;


// Calculate p_even
// B_2 + Rsq *B_3
// B_1 + Rsq * (B_2 + Rsq *B_3)
// p_even = Rsq * (B_1 + Rsq * (B_2 + Rsq *B_3))
{ .mfi
      nop.m 999
      fma.s1          cosh_FR_peven_temp1 = cosh_FR_Rsq, cosh_FR_B3, cosh_FR_B2
      nop.i 999
}
// Calculate p_odd
// A_2 + Rsq *A_3
// A_1 + Rsq * (A_2 + Rsq *A_3)
// podd = R + Rcub * (A_1 + Rsq * (A_2 + Rsq *A_3))
{ .mfi
      nop.m 999
      fma.s1          cosh_FR_podd_temp1 = cosh_FR_Rsq, cosh_FR_A3, cosh_FR_A2
      nop.i 999
}
;;

{ .mfi
      nop.m 999
      fma.s1             cosh_FR_Rcub = cosh_FR_Rsq, cosh_FR_R, f0
      nop.i 999
}
;;

// 
// If TBL, 
// Calculate C_hi and C_lo, and S_hi
// SC_hi_temp = sneg * Tmjhi
// S_hi = spos * Tjhi - SC_hi_temp
// S_hi = spos * Tjhi - (sneg * Tmjhi)
// C_hi = spos * Tjhi + SC_hi_temp
// C_hi = spos * Tjhi + (sneg * Tmjhi)

{ .mfi
      nop.m 999
(p6)  fma.s1         cosh_FR_SC_hi_temp = cosh_FR_sneg, cosh_FR_Tmjhi, f0   
      nop.i 999
}
;;

// If TBL, 
// C_lo_temp3 = sneg * Tmjlo
// C_lo_temp4 = spos * Tjlo + C_lo_temp3
// C_lo_temp4 = spos * Tjlo + (sneg * Tmjlo)
{ .mfi
      nop.m 999
(p6)  fma.s1  cosh_FR_C_lo_temp3 =  cosh_FR_sneg, cosh_FR_Tmjlo, f0
      nop.i 999
}
;;

{ .mfi
      nop.m 999
      fma.s1  cosh_FR_peven_temp2 = cosh_FR_Rsq, cosh_FR_peven_temp1, cosh_FR_B1
      nop.i 999
}
{ .mfi
      nop.m 999
      fma.s1  cosh_FR_podd_temp2 = cosh_FR_Rsq, cosh_FR_podd_temp1, cosh_FR_A1
      nop.i 999
}
;;

// If EXP, 
// Compute 2^(N-1) * Tjhi and 2^(N-1) * Tjlo
{ .mfi
      nop.m 999
(p7)  fma.s1  cosh_FR_Tjhi_spos = cosh_FR_Tjhi, cosh_FR_spos, f0
      nop.i 999
}
{ .mfi
      nop.m 999
(p7)  fma.s1  cosh_FR_Tjlo_spos = cosh_FR_Tjlo, cosh_FR_spos, f0
      nop.i 999
}
;;

{ .mfi
      nop.m 999
(p6)  fma.s1  cosh_FR_C_hi = cosh_FR_spos, cosh_FR_Tjhi, cosh_FR_SC_hi_temp
      nop.i 999
}
;;

{ .mfi
      nop.m 999
(p6)  fms.s1  cosh_FR_S_hi = cosh_FR_spos, cosh_FR_Tjhi, cosh_FR_SC_hi_temp
      nop.i 999
}
{ .mfi
      nop.m 999
(p6)  fma.s1 cosh_FR_C_lo_temp4 = cosh_FR_spos, cosh_FR_Tjlo, cosh_FR_C_lo_temp3
      nop.i 999
}
;;

{ .mfi
      nop.m 999
      fma.s1          cosh_FR_peven = cosh_FR_Rsq, cosh_FR_peven_temp2, f0
      nop.i 999
}
{ .mfi
      nop.m 999
      fma.s1          cosh_FR_podd = cosh_FR_podd_temp2, cosh_FR_Rcub, cosh_FR_R
      nop.i 999
}
;;

// If TBL,
// C_lo_temp1 =  spos * Tjhi - C_hi
// C_lo_temp2 =  sneg * Tmjlo + C_lo_temp1
// C_lo_temp2 =  sneg * Tmjlo + (spos * Tjhi - C_hi)

{ .mfi
      nop.m 999
(p6)  fms.s1  cosh_FR_C_lo_temp1 =  cosh_FR_spos, cosh_FR_Tjhi,  cosh_FR_C_hi
      nop.i 999
}
;;

{ .mfi
      nop.m 999
(p6)  fma.s1 cosh_FR_C_lo_temp2 = cosh_FR_sneg, cosh_FR_Tmjhi, cosh_FR_C_lo_temp1       
      nop.i 999
}
;;

// If EXP,
// Y_hi = 2^(N-1) * Tjhi
// Y_lo = 2^(N-1) * Tjhi * (p_odd + p_even) + 2^(N-1) * Tjlo
{ .mfi
      nop.m 999
(p7)  fma.s1  cosh_FR_Y_lo_temp =  cosh_FR_peven, f1, cosh_FR_podd
      nop.i 999
}
;;

// If TBL,
// C_lo = C_lo_temp4 + C_lo_temp2
{ .mfi
      nop.m 999
(p6)  fma.s1         cosh_FR_C_lo = cosh_FR_C_lo_temp4, f1, cosh_FR_C_lo_temp2
      nop.i 999
}
;;

// If TBL,
// Y_hi = C_hi 
// Y_lo = S_hi*p_odd + (C_hi*p_even + C_lo)
{ .mfi
      nop.m 999
(p6)  fma.s1  cosh_FR_Y_lo_temp = cosh_FR_C_hi, cosh_FR_peven, cosh_FR_C_lo
      nop.i 999
}
;;

{ .mfi
      nop.m 999
(p7)  fma.s1  cosh_FR_Y_lo = cosh_FR_Tjhi_spos, cosh_FR_Y_lo_temp, cosh_FR_Tjlo_spos
      nop.i 999
}
;;

// Dummy multiply to generate inexact
{ .mfi
      nop.m 999
      fmpy.s0      cosh_FR_tmp = cosh_FR_all_ones, cosh_FR_all_ones
      nop.i 999
}
{ .mfi
      nop.m 999
(p6)  fma.s1       cosh_FR_Y_lo = cosh_FR_S_hi, cosh_FR_podd, cosh_FR_Y_lo_temp
      nop.i 999
}
;;

// f8 = answer = Y_hi + Y_lo
{ .mfi
      nop.m 999
(p7)  fma.s.s0   f8 = cosh_FR_Y_lo,  f1, cosh_FR_Tjhi_spos
      nop.i 999
}
;;

// f8 = answer = Y_hi + Y_lo
{ .mfb
      nop.m 999
(p6)  fma.s.s0  f8 = cosh_FR_Y_lo, f1, cosh_FR_C_hi
      br.ret.sptk     b0      // Exit for COSH_BY_TBL and COSH_BY_EXP
}
;;



// Here if x denorm or unorm
COSH_DENORM:
// Determine if x really a denorm and not a unorm
{ .mmf
      getf.exp  cosh_GR_signexp_x = cosh_FR_NORM_X
      mov  cosh_GR_exp_denorm = 0x0ff81   // Real denorms will have exp < this
      fmerge.s    cosh_FR_ABS_X = f0, cosh_FR_NORM_X
}
;;

{ .mfi
      nop.m 999
      fcmp.eq.s0  p10,p0 = f8, f0  // Set denorm flag
      nop.i 999
}
;;

// Set p8 if really a denorm
{ .mmi
      and  cosh_GR_exp_x = cosh_GR_exp_mask, cosh_GR_signexp_x ;;
      cmp.lt  p8,p9 = cosh_GR_exp_x, cosh_GR_exp_denorm
      nop.i 999
}
;;

{ .mfb
      nop.m 999
(p8)  fma.s.s0       f8 =  f8,f8,f1  // If x denorm, result=1+x^2
(p9)  br.cond.sptk  COSH_COMMON    // Return to main path if x unorm
}
;;
{ .mfb
      nop.m 999
      nop.f 999
      br.ret.sptk    b0            // Exit if x denorm
}
;;



// Here if |x| >= overflow limit
COSH_HUGE: 
// for COSH_HUGE, put 24000 in exponent
{ .mmi
      mov                cosh_GR_exp_huge = 0x15dbf ;;
      setf.exp            cosh_FR_huge  = cosh_GR_exp_huge
      nop.i 999
}
;;

{ .mfi
      nop.m 999
      fma.s1   cosh_FR_signed_hi_lo = cosh_FR_huge, f1, f1
      nop.i 999
}
;;

{ .mfi
      nop.m 999
      fma.s.s0  cosh_FR_pre_result = cosh_FR_signed_hi_lo, cosh_FR_huge, f0
      mov                 GR_Parameter_TAG = 65
}
;;

.endp coshf

// Stack operations when calling error support.
//       (1)               (2)                          (3) (call)              (4)
//   sp   -> +          psp -> +                     psp -> +                   sp -> +
//           |                 |                            |                         |
//           |                 | <- GR_Y               R3 ->| <- GR_RESULT            | -> f8
//           |                 |                            |                         |
//           | <-GR_Y      Y2->|                       Y2 ->| <- GR_Y                 |
//           |                 |                            |                         |
//           |                 | <- GR_X               X1 ->|                         |
//           |                 |                            |                         |
//  sp-64 -> +          sp ->  +                     sp ->  +                         +
//    save ar.pfs          save b0                                               restore gp
//    save gp                                                                    restore ar.pfs

.proc __libm_error_region
__libm_error_region:
COSH_ERROR_SUPPORT:
.prologue

// (1)
{ .mfi
        add   GR_Parameter_Y=-32,sp             // Parameter 2 value
        nop.f 0
.save   ar.pfs,GR_SAVE_PFS
        mov  GR_SAVE_PFS=ar.pfs                 // Save ar.pfs
}
{ .mfi
.fframe 64
        add sp=-64,sp                          // Create new stack
        nop.f 0
        mov GR_SAVE_GP=gp                      // Save gp
};;


// (2)
{ .mmi
        stfs [GR_Parameter_Y] = f0,16          // STORE Parameter 2 on stack
        add GR_Parameter_X = 16,sp             // Parameter 1 address
.save   b0, GR_SAVE_B0
        mov GR_SAVE_B0=b0                      // Save b0
};;

.body
// (3)
{ .mib
        stfs [GR_Parameter_X] = f8             // STORE Parameter 1 on stack
        add   GR_Parameter_RESULT = 0,GR_Parameter_Y   // Parameter 3 address
        nop.b 0                            
}
{ .mib
        stfs [GR_Parameter_Y] = cosh_FR_pre_result // STORE Parameter 3 on stack
        add   GR_Parameter_Y = -16,GR_Parameter_Y
        br.call.sptk b0=__libm_error_support#  // Call error handling function
};;
{ .mmi
        nop.m 0
        nop.m 0
        add   GR_Parameter_RESULT = 48,sp
};;

// (4)
{ .mmi
        ldfs  f8 = [GR_Parameter_RESULT]       // Get return result off stack
.restore
        add   sp = 64,sp                       // Restore stack pointer
        mov   b0 = GR_SAVE_B0                  // Restore return address
};;
{ .mib
        mov   gp = GR_SAVE_GP                  // Restore gp
        mov   ar.pfs = GR_SAVE_PFS             // Restore ar.pfs
        br.ret.sptk     b0                     // Return
};;

.endp __libm_error_region


.type   __libm_error_support#,@function
.global __libm_error_support#
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\ia64\fabsf.s ===
.file "fabsf.s"

// Copyright (c) 2000, 2001, Intel Corporation
// All rights reserved.
// 
// Contributed 2/2/2000 by John Harrison, Ted Kubaska, Bob Norin, Shane Story,
// and Ping Tak Peter Tang of the Computational Software Lab, Intel Corporation.
// 
// WARRANTY DISCLAIMER
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS 
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY 
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
// 
// Intel Corporation is the author of this code, and requests that all
// problem reports or change requests be submitted to it directly at 
// http://developer.intel.com/opensource.
//
// History
//==============================================================
// 2/02/00: Initial version
//
// API
//==============================================================
//  float fabsf(float x)
//
// Overview of operation
//==============================================================
// returns absolute value of x 
//
// floating-point registers used: 1
// f8, input

.align 32
.global fabsf#

.section .text
.proc  fabsf#
.align 32

fabsf: 

// set invalid or denormal flags and take fault if
// necessary

{ .mfi
      nop.m 999
      fcmp.eq.unc.s0 p6,p7 = f8,f1             
      nop.i 999 ;;
}

{ .mfb
      nop.m 999
      fabs           f8 = f8                   
      br.ret.sptk    b0 ;;                        
}

.endp fabsf
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\ia64\exp.s ===
.file "exp.s"

// Copyright (c) 2000, 2001, Intel Corporation
// All rights reserved.
// 
// Contributed 2/2/2000 by John Harrison, Ted Kubaska, Bob Norin, Shane Story,
// and Ping Tak Peter Tang of the Computational Software Lab, Intel Corporation.
// 
// WARRANTY DISCLAIMER
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS 
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY 
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
// 
// Intel Corporation is the author of this code, and requests that all
// problem reports or change requests be submitted to it directly at 
// http://developer.intel.com/opensource.
//
// History
//==============================================================
// 2/02/00  Initial version 
// 3/07/00  exp(inf)  = inf but now does NOT call error support
//          exp(-inf) = 0   but now does NOT call error support
// 4/04/00  Unwind support added
// 8/15/00  Bundle added after call to __libm_error_support to properly
//          set [the previously overwritten] GR_Parameter_RESULT.
// 11/30/00 Reworked to shorten main path, widen main path to include all
//          args in normal range, and add quick exit for 0, nan, inf.
// 12/05/00 Loaded constants earlier with setf to save 2 cycles.

// API
//==============================================================
// double exp(double)

// Overview of operation
//==============================================================
// Take the input x. w is "how many log2/128 in x?"
//  w = x * 128/log2
//  n = int(w)
//  x = n log2/128 + r + delta

//  n = 128M + index_1 + 2^4 index_2
//  x = M log2 + (log2/128) index_1 + (log2/8) index_2 + r + delta

//  exp(x) = 2^M  2^(index_1/128)  2^(index_2/8) exp(r) exp(delta)
//       Construct 2^M
//       Get 2^(index_1/128) from table_1;
//       Get 2^(index_2/8)   from table_2;
//       Calculate exp(r) by series
//          r = x - n (log2/128)_high
//          delta = - n (log2/128)_low
//       Calculate exp(delta) as 1 + delta


// Special values 
//==============================================================
// exp(+0)    = 1.0
// exp(-0)    = 1.0

// exp(+qnan) = +qnan 
// exp(-qnan) = -qnan 
// exp(+snan) = +qnan 
// exp(-snan) = -qnan 

// exp(-inf)  = +0 
// exp(+inf)  = +inf

// Overfow and Underfow
//=======================
// exp(-x) = smallest double normal when
//     x = -708.396 = c086232bdd7abcd2

// exp(x) = largest double normal when
//     x = 709.7827 = 40862e42fefa39ef



// Registers used
//==============================================================
// Floating Point registers used: 
// f8, input
// f9 -> f15,  f32 -> f60

// General registers used: 
// r32 -> r60 

// Predicate registers used:
// p6 -> p15

// Assembly macros
//==============================================================

exp_GR_rshf                   = r33
EXP_AD_TB1                    = r34
EXP_AD_TB2                    = r35
EXP_AD_P                      = r36

exp_GR_N                      = r37
exp_GR_index_1                = r38
exp_GR_index_2_16             = r39

exp_GR_biased_M               = r40
exp_GR_index_1_16             = r41
EXP_AD_T1                     = r42
EXP_AD_T2                     = r43
exp_GR_sig_inv_ln2            = r44

exp_GR_17ones                 = r45
exp_GR_one                    = r46
exp_TB1_size                  = r47
exp_TB2_size                  = r48
exp_GR_rshf_2to56             = r49

exp_GR_gt_ln                  = r50
exp_GR_exp_2tom56             = r51

exp_GR_17ones_m1              = r52

GR_SAVE_B0                    = r53
GR_SAVE_PFS                   = r54
GR_SAVE_GP                    = r55
GR_SAVE_SP                    = r56

GR_Parameter_X                = r57
GR_Parameter_Y                = r58
GR_Parameter_RESULT           = r59
GR_Parameter_TAG              = r60


FR_X             = f10
FR_Y             = f1
FR_RESULT        = f8

EXP_RSHF_2TO56   = f6
EXP_INV_LN2_2TO63 = f7
EXP_W_2TO56_RSH  = f9
EXP_2TOM56       = f11
exp_P4           = f12 
exp_P3           = f13 
exp_P2           = f14 
exp_P1           = f15 

exp_ln2_by_128_hi  = f33 
exp_ln2_by_128_lo  = f34 

EXP_RSHF           = f35
EXP_Nfloat         = f36 
exp_W              = f37
exp_r              = f38
exp_f              = f39

exp_rsq            = f40
exp_rcube          = f41

EXP_2M             = f42
exp_S1             = f43
exp_T1             = f44

EXP_MIN_DBL_OFLOW_ARG = f45
EXP_MAX_DBL_ZERO_ARG  = f46
EXP_MAX_DBL_NORM_ARG  = f47
EXP_MAX_DBL_UFLOW_ARG = f48
EXP_MIN_DBL_NORM_ARG  = f49
exp_rP4pP3         = f50
exp_P_lo           = f51
exp_P_hi           = f52
exp_P              = f53
exp_S              = f54

EXP_NORM_f8        = f56   

exp_wre_urm_f8     = f57
exp_ftz_urm_f8     = f57

exp_gt_pln         = f58

exp_S2             = f59
exp_T2             = f60


// Data tables
//==============================================================

.data

.align 16

// ************* DO NOT CHANGE ORDER OF THESE TABLES ********************

// double-extended 1/ln(2)
// 3fff b8aa 3b29 5c17 f0bb be87fed0691d3e88
// 3fff b8aa 3b29 5c17 f0bc 
// For speed the significand will be loaded directly with a movl and setf.sig
//   and the exponent will be bias+63 instead of bias+0.  Thus subsequent
//   computations need to scale appropriately.
// The constant 128/ln(2) is needed for the computation of w.  This is also 
//   obtained by scaling the computations.
//
// Two shifting constants are loaded directly with movl and setf.d. 
//   1. EXP_RSHF_2TO56 = 1.1000..00 * 2^(63-7) 
//        This constant is added to x*1/ln2 to shift the integer part of
//        x*128/ln2 into the rightmost bits of the significand.
//        The result of this fma is EXP_W_2TO56_RSH.
//   2. EXP_RSHF       = 1.1000..00 * 2^(63) 
//        This constant is subtracted from EXP_W_2TO56_RSH * 2^(-56) to give
//        the integer part of w, n, as a floating-point number.
//        The result of this fms is EXP_Nfloat.


exp_table_1:
data8 0x40862e42fefa39f0 // smallest dbl overflow arg
data8 0xc0874c0000000000 // approx largest arg for zero result
data8 0x40862e42fefa39ef // largest dbl arg to give normal dbl result
data8 0xc086232bdd7abcd3 // largest dbl underflow arg
data8 0xc086232bdd7abcd2 // smallest dbl arg to give normal dbl result
data8 0x0                // pad
data8 0xb17217f7d1cf79ab , 0x00003ff7 // ln2/128 hi
data8 0xc9e3b39803f2f6af , 0x00003fb7 // ln2/128 lo

// Table 1 is 2^(index_1/128) where
// index_1 goes from 0 to 15

data8 0x8000000000000000 , 0x00003FFF
data8 0x80B1ED4FD999AB6C , 0x00003FFF
data8 0x8164D1F3BC030773 , 0x00003FFF
data8 0x8218AF4373FC25EC , 0x00003FFF
data8 0x82CD8698AC2BA1D7 , 0x00003FFF
data8 0x8383594EEFB6EE37 , 0x00003FFF
data8 0x843A28C3ACDE4046 , 0x00003FFF
data8 0x84F1F656379C1A29 , 0x00003FFF
data8 0x85AAC367CC487B15 , 0x00003FFF
data8 0x8664915B923FBA04 , 0x00003FFF
data8 0x871F61969E8D1010 , 0x00003FFF
data8 0x87DB357FF698D792 , 0x00003FFF
data8 0x88980E8092DA8527 , 0x00003FFF
data8 0x8955EE03618E5FDD , 0x00003FFF
data8 0x8A14D575496EFD9A , 0x00003FFF
data8 0x8AD4C6452C728924 , 0x00003FFF

// Table 2 is 2^(index_1/8) where
// index_2 goes from 0 to 7
exp_table_2:
data8 0x8000000000000000 , 0x00003FFF
data8 0x8B95C1E3EA8BD6E7 , 0x00003FFF
data8 0x9837F0518DB8A96F , 0x00003FFF
data8 0xA5FED6A9B15138EA , 0x00003FFF
data8 0xB504F333F9DE6484 , 0x00003FFF
data8 0xC5672A115506DADD , 0x00003FFF
data8 0xD744FCCAD69D6AF4 , 0x00003FFF
data8 0xEAC0C6E7DD24392F , 0x00003FFF


exp_p_table:
data8 0x3f8111116da21757 //P_4
data8 0x3fa55555d787761c //P_3
data8 0x3fc5555555555414 //P_2
data8 0x3fdffffffffffd6a //P_1


.align 32
.global exp#

.section .text
.proc  exp#
.align 32
exp: 

{ .mlx
      alloc      r32=ar.pfs,1,24,4,0                               
      movl exp_GR_sig_inv_ln2 = 0xb8aa3b295c17f0bc  // significand of 1/ln2
}
{ .mlx
      addl       EXP_AD_TB1    = @ltoff(exp_table_1), gp
      movl exp_GR_rshf_2to56 = 0x4768000000000000 ;;  // 1.10000 2^(63+56)
}
;;

// We do this fnorm right at the beginning to take any enabled
// faults and to normalize any input unnormals so that SWA is not taken.
{ .mfi
      ld8        EXP_AD_TB1    = [EXP_AD_TB1]
      fclass.m   p8,p0 = f8,0x07  // Test for x=0
      mov        exp_GR_17ones = 0x1FFFF                          
}
{ .mfi
      mov        exp_TB1_size  = 0x100
      fnorm      EXP_NORM_f8   = f8                                          
      mov exp_GR_exp_2tom56 = 0xffff-56
}
;;

// Form two constants we need
//  1/ln2 * 2^63  to compute  w = x * 1/ln2 * 128 
//  1.1000..000 * 2^(63+63-7) to right shift int(w) into the significand

{ .mmf
      setf.sig  EXP_INV_LN2_2TO63 = exp_GR_sig_inv_ln2 // form 1/ln2 * 2^63
      setf.d  EXP_RSHF_2TO56 = exp_GR_rshf_2to56 // Form const 1.100 * 2^(63+56)
      fclass.m   p9,p0 = f8,0x22  // Test for x=-inf
}
;;

{ .mlx
      setf.exp EXP_2TOM56 = exp_GR_exp_2tom56 // form 2^-56 for scaling Nfloat
      movl exp_GR_rshf = 0x43e8000000000000   // 1.10000 2^63 for right shift
}
{ .mfb
      mov        exp_TB2_size  = 0x80
(p8)  fma.d      f8 = f1,f1,f0           // quick exit for x=0
(p8)  br.ret.spnt b0
;;
}

{ .mfi
      ldfpd      EXP_MIN_DBL_OFLOW_ARG, EXP_MAX_DBL_ZERO_ARG = [EXP_AD_TB1],16
      fclass.m   p10,p0 = f8,0x21  // Test for x=+inf
      nop.i 999
}
{ .mfb
      nop.m 999
(p9)  fma.d      f8 = f0,f0,f0           // quick exit for x=-inf
(p9)  br.ret.spnt b0
;;                    
}

{ .mmf
      ldfpd      EXP_MAX_DBL_NORM_ARG, EXP_MAX_DBL_UFLOW_ARG = [EXP_AD_TB1],16
      setf.d  EXP_RSHF = exp_GR_rshf // Form right shift const 1.100 * 2^63
      fclass.m   p11,p0 = f8,0xc3  // Test for x=nan
;;
}

{ .mfb
      ldfd      EXP_MIN_DBL_NORM_ARG = [EXP_AD_TB1],16
      nop.f 999
(p10) br.ret.spnt b0               // quick exit for x=+inf
;;
}

{ .mfi
      ldfe       exp_ln2_by_128_hi  = [EXP_AD_TB1],16
      nop.f 999
      nop.i 999
;;
}


{ .mfb
      ldfe       exp_ln2_by_128_lo  = [EXP_AD_TB1],16
(p11) fmerge.s   f8 = EXP_NORM_f8, EXP_NORM_f8
(p11) br.ret.spnt b0               // quick exit for x=nan
;;
}

// After that last load, EXP_AD_TB1 points to the beginning of table 1

// W = X * Inv_log2_by_128
// By adding 1.10...0*2^63 we shift and get round_int(W) in significand.
// We actually add 1.10...0*2^56 to X * Inv_log2 to do the same thing.

{ .mfi
      nop.m 999
      fma.s1  EXP_W_2TO56_RSH  = EXP_NORM_f8, EXP_INV_LN2_2TO63, EXP_RSHF_2TO56
      nop.i 999
;;
}


// Divide arguments into the following categories:
//  Certain Underflow/zero  p11 - -inf < x <= MAX_DBL_ZERO_ARG 
//  Certain Underflow       p12 - MAX_DBL_ZERO_ARG < x <= MAX_DBL_UFLOW_ARG 
//  Possible Underflow      p13 - MAX_DBL_UFLOW_ARG < x < MIN_DBL_NORM_ARG
//  Certain Safe                - MIN_DBL_NORM_ARG <= x <= MAX_DBL_NORM_ARG
//  Possible Overflow       p14 - MAX_DBL_NORM_ARG < x < MIN_DBL_OFLOW_ARG
//  Certain Overflow        p15 - MIN_DBL_OFLOW_ARG <= x < +inf
//
// If the input is really a double arg, then there will never be "Possible
// Underflow" or "Possible Overflow" arguments.
//

{ .mfi
      add        EXP_AD_TB2 = exp_TB1_size, EXP_AD_TB1
      fcmp.ge.s1  p15,p14 = EXP_NORM_f8,EXP_MIN_DBL_OFLOW_ARG
      nop.i 999
;;                        
}

{ .mfi
      add        EXP_AD_P = exp_TB2_size, EXP_AD_TB2
      fcmp.le.s1  p11,p12 = EXP_NORM_f8,EXP_MAX_DBL_ZERO_ARG
      nop.i 999
;;
}

{ .mfb
      ldfpd      exp_P4, exp_P3  = [EXP_AD_P] ,16
(p14) fcmp.gt.unc.s1  p14,p0 = EXP_NORM_f8,EXP_MAX_DBL_NORM_ARG
(p15) br.cond.spnt EXP_CERTAIN_OVERFLOW
;;
}


// Nfloat = round_int(W) 
// The signficand of EXP_W_2TO56_RSH contains the rounded integer part of W,
// as a twos complement number in the lower bits (that is, it may be negative).
// That twos complement number (called N) is put into exp_GR_N.

// Since EXP_W_2TO56_RSH is scaled by 2^56, it must be multiplied by 2^-56
// before the shift constant 1.10000 * 2^63 is subtracted to yield EXP_Nfloat.
// Thus, EXP_Nfloat contains the floating point version of N


{ .mfi
      nop.m 999
(p12) fcmp.le.unc  p12,p0 = EXP_NORM_f8,EXP_MAX_DBL_UFLOW_ARG
      nop.i 999
}
{ .mfb
      ldfpd      exp_P2, exp_P1  = [EXP_AD_P]                                  
      fms.s1          EXP_Nfloat = EXP_W_2TO56_RSH, EXP_2TOM56, EXP_RSHF 
(p11) br.cond.spnt EXP_CERTAIN_UNDERFLOW_ZERO
;;
}

{ .mfi
      getf.sig        exp_GR_N        = EXP_W_2TO56_RSH
(p13) fcmp.lt.unc  p13,p0 = EXP_NORM_f8,EXP_MIN_DBL_NORM_ARG
      nop.i 999
;;
}


// exp_GR_index_1 has index_1
// exp_GR_index_2_16 has index_2 * 16
// exp_GR_biased_M has M
// exp_GR_index_1_16 has index_1 * 16

// r2 has true M
{ .mfi
      and            exp_GR_index_1 = 0x0f, exp_GR_N
      fnma.s1    exp_r   = EXP_Nfloat, exp_ln2_by_128_hi, EXP_NORM_f8 
      shr            r2 = exp_GR_N,  0x7
}
{ .mfi
      and            exp_GR_index_2_16 = 0x70, exp_GR_N
      fnma.s1    exp_f   = EXP_Nfloat, exp_ln2_by_128_lo, f1 
      nop.i 999
;;                            
}


// EXP_AD_T1 has address of T1                           
// EXP_AD_T2 has address if T2                            

{ .mmi
      addl           exp_GR_biased_M = 0xffff, r2 
      add            EXP_AD_T2 = EXP_AD_TB2, exp_GR_index_2_16 
      shladd         EXP_AD_T1 = exp_GR_index_1, 4, EXP_AD_TB1
;;                            
}


// Create Scale = 2^M
// r = x - Nfloat * ln2_by_128_hi 
// f = 1 - Nfloat * ln2_by_128_lo 

{ .mmi
      setf.exp        EXP_2M = exp_GR_biased_M                              
      ldfe       exp_T2  = [EXP_AD_T2]                                
      nop.i 999
;;
}

// Load T1 and T2
{ .mfi
      ldfe       exp_T1  = [EXP_AD_T1]                                
      nop.f 999
      nop.i 999
;;
}


{ .mfi
        nop.m 999
        fma.s1           exp_rsq = exp_r, exp_r, f0 
        nop.i 999
}
{ .mfi
        nop.m 999
        fma.s1        exp_rP4pP3 = exp_r, exp_P4, exp_P3               
        nop.i 999
;;
}



{ .mfi
        nop.m 999
        fma.s1           exp_rcube = exp_r, exp_rsq, f0 
        nop.i 999 
}
{ .mfi
        nop.m 999
        fma.s1        exp_P_lo  = exp_r, exp_rP4pP3, exp_P2            
        nop.i 999
;;
}


{ .mfi
        nop.m 999
        fma.s1        exp_P_hi  = exp_rsq, exp_P1, exp_r              
        nop.i 999
}
{ .mfi
        nop.m 999
        fma.s1        exp_S2  = exp_f,exp_T2,f0                       
        nop.i 999
;;
}

{ .mfi
        nop.m 999
        fma.s1        exp_S1  = EXP_2M,exp_T1,f0                      
        nop.i 999
;;
}


{ .mfi
        nop.m 999
        fma.s1        exp_P     = exp_rcube, exp_P_lo, exp_P_hi       
        nop.i 999
;;
}

{ .mfi
        nop.m 999
        fma.s1        exp_S   = exp_S1,exp_S2,f0                      
        nop.i 999
;;
}

{ .bbb
(p12)   br.cond.spnt  EXP_CERTAIN_UNDERFLOW
(p13)   br.cond.spnt  EXP_POSSIBLE_UNDERFLOW
(p14)   br.cond.spnt  EXP_POSSIBLE_OVERFLOW
;;
}


{ .mfb
        nop.m 999
        fma.d      f8 = exp_S, exp_P, exp_S 
        br.ret.sptk     b0 ;;               // Normal path exit 
}


EXP_POSSIBLE_OVERFLOW: 

// We got an answer. EXP_MAX_DBL_NORM_ARG < x < EXP_MIN_DBL_OFLOW_ARG
// overflow is a possibility, not a certainty

{ .mfi
	nop.m 999
        fsetc.s2 0x7F,0x42                                          
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
        fma.d.s2      exp_wre_urm_f8 = exp_S, exp_P, exp_S          
	nop.i 999 ;;
}

// We define an overflow when the answer with
//    WRE set
//    user-defined rounding mode
// is ldn +1

// Is the exponent 1 more than the largest double?
// If so, go to ERROR RETURN, else get the answer and 
// leave.

// Largest double is 7FE (biased double)
//                   7FE - 3FF + FFFF = 103FE
// Create + largest_double_plus_ulp
// Create - largest_double_plus_ulp
// Calculate answer with WRE set.

// Cases when answer is ldn+1  are as follows:
//  ldn                   ldn+1
// --+----------|----------+------------
//              | 
//    +inf          +inf      -inf
//                  RN         RN
//                             RZ 

{ .mfi
	nop.m 999
        fsetc.s2 0x7F,0x40                                          
        mov           exp_GR_gt_ln  = 0x103ff ;;                      
}

{ .mfi
        setf.exp      exp_gt_pln    = exp_GR_gt_ln                 
	nop.f 999
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
       fcmp.ge.unc.s1 p6, p0 =  exp_wre_urm_f8, exp_gt_pln 	  
	nop.i 999 ;;
}

{ .mfb
	nop.m 999
	nop.f 999
(p6)   br.cond.spnt EXP_CERTAIN_OVERFLOW ;; // Branch if really overflow
}

{ .mfb
	nop.m 999
       fma.d        f8 = exp_S, exp_P, exp_S                      
       br.ret.sptk     b0 ;;             // Exit if really no overflow
}

EXP_CERTAIN_OVERFLOW:
{ .mmi
      sub   exp_GR_17ones_m1 = exp_GR_17ones, r0, 1 ;;
      setf.exp     f9 = exp_GR_17ones_m1
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
      fmerge.s FR_X = f8,f8
      nop.i 999
}
{ .mfb
      mov        GR_Parameter_TAG = 14
      fma.d       FR_RESULT = f9, f9, f0    // Set I,O and +INF result
      br.cond.sptk  __libm_error_region ;;                             
}

EXP_POSSIBLE_UNDERFLOW: 

// We got an answer. EXP_MAX_DBL_UFLOW_ARG < x < EXP_MIN_DBL_NORM_ARG
// underflow is a possibility, not a certainty

// We define an underflow when the answer with
//    ftz set
// is zero (tiny numbers become zero)

// Notice (from below) that if we have an unlimited exponent range,
// then there is an extra machine number E between the largest denormal and
// the smallest normal.

// So if with unbounded exponent we round to E or below, then we are
// tiny and underflow has occurred.

// But notice that you can be in a situation where we are tiny, namely
// rounded to E, but when the exponent is bounded we round to smallest
// normal. So the answer can be the smallest normal with underflow.

//                           E
// -----+--------------------+--------------------+-----
//      |                    |                    |
//   1.1...10 2^-3fff    1.1...11 2^-3fff    1.0...00 2^-3ffe
//   0.1...11 2^-3ffe                                   (biased, 1)
//    largest dn                               smallest normal

{ .mfi
	nop.m 999
       fsetc.s2 0x7F,0x41                                          
	nop.i 999 ;;
}
{ .mfi
	nop.m 999
       fma.d.s2      exp_ftz_urm_f8 = exp_S, exp_P, exp_S          
	nop.i 999 ;;
}
{ .mfi
	nop.m 999
       fsetc.s2 0x7F,0x40                                          
	nop.i 999 ;;
}
{ .mfi
	nop.m 999
       fcmp.eq.unc.s1 p6, p0 =  exp_ftz_urm_f8, f0 	          
	nop.i 999 ;;
}
{ .mfb
	nop.m 999
	nop.f 999
(p6)   br.cond.spnt EXP_CERTAIN_UNDERFLOW ;; // Branch if really underflow
}
{ .mfb
	nop.m 999
       fma.d        f8 = exp_S, exp_P, exp_S                      
       br.ret.sptk     b0 ;;                // Exit if really no underflow
}

EXP_CERTAIN_UNDERFLOW:
{ .mfi
      nop.m 999
      fmerge.s FR_X = f8,f8
      nop.i 999
}
{ .mfb
      mov        GR_Parameter_TAG = 15
      fma.d       FR_RESULT  = exp_S, exp_P, exp_S // Set I,U and tiny result
      br.cond.sptk  __libm_error_region ;;                             
}

EXP_CERTAIN_UNDERFLOW_ZERO:
{ .mmi
      mov   exp_GR_one = 1 ;;
      setf.exp     f9 = exp_GR_one
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
      fmerge.s FR_X = f8,f8
      nop.i 999
}
{ .mfb
      mov        GR_Parameter_TAG = 15
      fma.d       FR_RESULT = f9, f9, f0    // Set I,U and tiny (+0.0) result
      br.cond.sptk  __libm_error_region ;;                             
}

.endp exp


.proc __libm_error_region
__libm_error_region:
.prologue
{ .mfi
        add   GR_Parameter_Y=-32,sp             // Parameter 2 value
        nop.f 0
.save   ar.pfs,GR_SAVE_PFS
        mov  GR_SAVE_PFS=ar.pfs                 // Save ar.pfs 
}
{ .mfi
.fframe 64 
        add sp=-64,sp                           // Create new stack
        nop.f 0
        mov GR_SAVE_GP=gp                       // Save gp
};;
{ .mmi
        stfd [GR_Parameter_Y] = FR_Y,16         // STORE Parameter 2 on stack
        add GR_Parameter_X = 16,sp              // Parameter 1 address
.save   b0, GR_SAVE_B0                      
        mov GR_SAVE_B0=b0                       // Save b0 
};;
.body
{ .mib
        stfd [GR_Parameter_X] = FR_X                  // STORE Parameter 1 on stack 
        add   GR_Parameter_RESULT = 0,GR_Parameter_Y  // Parameter 3 address 
	nop.b 0                                      
}
{ .mib
        stfd [GR_Parameter_Y] = FR_RESULT             // STORE Parameter 3 on stack
        add   GR_Parameter_Y = -16,GR_Parameter_Y  
        br.call.sptk b0=__libm_error_support#         // Call error handling function
};;
{ .mmi
        nop.m 0
        nop.m 0
        add   GR_Parameter_RESULT = 48,sp
};;
{ .mmi
        ldfd  f8 = [GR_Parameter_RESULT]       // Get return result off stack
.restore
        add   sp = 64,sp                       // Restore stack pointer
        mov   b0 = GR_SAVE_B0                  // Restore return address
};;
{ .mib
        mov   gp = GR_SAVE_GP                  // Restore gp 
        mov   ar.pfs = GR_SAVE_PFS             // Restore ar.pfs
        br.ret.sptk     b0                     // Return
};; 

.endp __libm_error_region
.type   __libm_error_support#,@function
.global __libm_error_support#
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\ia64\filter.c ===
//#########################################################################
//**
//**  Copyright  (C) 1996-2000 Intel Corporation. All rights reserved. 
//**
//** The information and source code contained herein is the exclusive 
//** property of Intel Corporation and may not be disclosed, examined
//** or reproduced in whole or in part without explicit written authorization 
//** from the company.
//**
//###########################################################################

//#define FPIEEE_FLT_DEBUG


/*****************************************************************************
 *  fpieee_flt.c - FP IEEE exception filter routine
 *
 *
 *  History:
 *    Marius Cornea 09/07/00
 *    marius.cornea@intel.com
 *
 *****************************************************************************/

#include "fpieee_flt.h"

/* the following two will be [re-]written (by Bernard Lint ?) */
static _FP128
GetFloatRegisterValue (unsigned int f, PCONTEXT Context);

static void
SetFloatRegisterValue (unsigned int f, _FP128 Value, PCONTEXT Context);

// Note: the I32* and U32* functions are needed because of the _I32 and _U32
// types in fpieee.h, different from the unsigned long used in _FP128

static _FP128 FPIeeeToFP128 (_FPIEEE_RECORD *);
static _FP128 FP32ToFP128 (_FP32);
static _FP128 FP32ToFP128modif (_FP32, int);
static void FP128ToFPIeee (_FPIEEE_RECORD *, int);
static _FP32 LowHalf (_FP128);
static _FP32 HighHalf (_FP128);
static int I32LowHalf (_FP128);
static int I32HighHalf (_FP128);
static unsigned int U32LowHalf (_FP128);
static unsigned int U32HighHalf (_FP128);
static _FP128 Combine (_FP32, _FP32);
static _FP128 I32Combine (int, int);
static _FP128 U32Combine (unsigned int, unsigned int);
static void UpdateRoundingMode (unsigned int, unsigned int, unsigned __int64 *,
    char *);
static void UpdatePrecision (unsigned int, unsigned int, unsigned __int64 *, char *);

/*
 *
 * _fpieee_flt () - IEEE FP filter routine
 *
 * Description:
 *   invokes the user trap handler for IEEE fp exceptions (P,U,O,Z,I) that are 
 *   enabled, providing it with the necessary information in an FPIEEE_RECORD
 *   data structure
 *
 *
 * Input parameters:
 *   unsigned __int64 eXceptionCode: the NT exception code
 *   PEXCEPTION_POINTERS p: a pointer to the NT EXCEPTION_POINTERS struct
 *   int handler (_FPIEEE_RECORD *): the user supplied ieee trap handler
 *
 *
 * Return value:
 *   returns the value returned by the user handler
 *
 */

int _fpieee_flt (unsigned long eXceptionCode,
                PEXCEPTION_POINTERS p,
                int (*handler)(_FPIEEE_RECORD *))

{

  PEXCEPTION_RECORD ExceptionRecord;
  PCONTEXT Context;
  unsigned __int64 *ExceptionInformation;
  char *ExceptionAddress;
  _FPIEEE_RECORD FpieeeRecord;
  int handler_return_value;
  unsigned int PR, PR1, PR2;
  unsigned __int64 BundleHigh;
  unsigned __int64 BundleLow;
  unsigned int ISRhigh;
  unsigned int ISRlow;
  unsigned int ei;
  unsigned int I_dis;
  unsigned int U_dis;
  unsigned int O_dis;
  unsigned int Z_dis;
  unsigned int D_dis;
  unsigned int V_dis;
  unsigned __int64 OpCode;
  unsigned __int64 FPSR;
  unsigned __int64 CFM;
  unsigned int rrbpr;
  unsigned int rrbfr;

  /* arguments to emulation functions */
  unsigned int sf;
  unsigned int qp;
  unsigned int f1;
  unsigned int f2;
  unsigned int f3;
  unsigned int f4;
  unsigned int p1;
  unsigned int p2;

  unsigned int pc;
  unsigned int rc;
  unsigned int wre;

  _FP128 FR1;
  _FP128 FR2;
  _FP128 FR3;
  _FP128 FR4;

  unsigned int EnableDenormal;
  unsigned int StatusDenormal;
  unsigned int CauseDenormal;

  unsigned int Operation;
  unsigned int Precision;
  unsigned int RoundingMode;
  unsigned int ResultFormat;

  unsigned __int64 old_fpsr;
  unsigned __int64 usr_fpsr;
  unsigned __int64 new_fpsr;

  /* for SIMD instructions */
  unsigned int SIMD_instruction;
  _FPIEEE_EXCEPTION_FLAGS LowStatus;
  _FPIEEE_EXCEPTION_FLAGS HighStatus;
  _FPIEEE_EXCEPTION_FLAGS LowCause;
  _FPIEEE_EXCEPTION_FLAGS HighCause;
  _FP128 newFR2;
  _FP128 newFR3;
  _FP128 newFR4;
  _FP32 FR1Low;
  _FP32 FR2Low;
  _FP32 FR3Low;
  _FP32 FR1High;
  _FP32 FR2High;
  _FP32 FR3High;
  unsigned int LowStatusDenormal;
  unsigned int HighStatusDenormal;
  unsigned int LowCauseDenormal;
  unsigned int HighCauseDenormal;
  int I32Low, I32High;
  unsigned int U32Low, U32High;



#ifdef FPIEEE_FLT_DEBUG
  printf ("********** FPIEEE_FLT_DEBUG **********\n");
  switch (eXceptionCode) {
    case STATUS_FLOAT_INVALID_OPERATION:
      printf ("STATUS_FLOAT_INVALID_OPERATION\n");
      break;
    case STATUS_FLOAT_DIVIDE_BY_ZERO:
      printf ("STATUS_FLOAT_DIVIDE_BY_ZERO\n");
      break;
    case STATUS_FLOAT_DENORMAL_OPERAND:
      printf ("STATUS_FLOAT_DENORMAL_OPERAND\n");
      break;
    case STATUS_FLOAT_INEXACT_RESULT:
      printf ("STATUS_FLOAT_INEXACT_RESULT\n");
      break;
    case STATUS_FLOAT_OVERFLOW:
      printf ("STATUS_FLOAT_OVERFLOW\n");
      break;
    case STATUS_FLOAT_UNDERFLOW:
      printf ("STATUS_FLOAT_UNDERFLOW\n");
      break;
    case STATUS_FLOAT_MULTIPLE_FAULTS:
      printf ("STATUS_FLOAT_MULTIPLE_FAULTS\n");
      break;
    case STATUS_FLOAT_MULTIPLE_TRAPS:
      printf ("STATUS_FLOAT_MULTIPLE_TRAPS\n");
      break;
    default:
      printf ("STATUS_FLOAT NOT IDENTIFIED\n");
      printf ("FPIEEE_FLT_DEBUG eXceptionCode = %8x\n", eXceptionCode);
      fflush (stdout);
      return (EXCEPTION_CONTINUE_SEARCH);
  }
#endif

  /* can get here only if ExceptionRecord->ExceptionCode 
   * corresponds to an IEEE exception */


  /* search for another handler if not an IEEE exception */
  if (eXceptionCode != STATUS_FLOAT_INVALID_OPERATION &&
        eXceptionCode != STATUS_FLOAT_DIVIDE_BY_ZERO &&
        eXceptionCode != STATUS_FLOAT_DENORMAL_OPERAND &&
        eXceptionCode != STATUS_FLOAT_UNDERFLOW &&
        eXceptionCode != STATUS_FLOAT_OVERFLOW &&
        eXceptionCode != STATUS_FLOAT_INEXACT_RESULT &&
        eXceptionCode != STATUS_FLOAT_MULTIPLE_FAULTS &&
        eXceptionCode != STATUS_FLOAT_MULTIPLE_TRAPS) {

        return (EXCEPTION_CONTINUE_SEARCH);

  }

  ExceptionRecord = p->ExceptionRecord;
  ExceptionInformation = ExceptionRecord->ExceptionInformation;
  Context = p->ContextRecord;

  FPSR = Context->StFPSR; // FP status register
#ifdef FPIEEE_FLT_DEBUG
  printf ("FPIEEE_FLT_DEBUG FPSR = %8x %8x\n", 
      (int)(FPSR >> 32) & 0xffffffff, (int)FPSR & 0xffffffff);
#endif

  if (ExceptionRecord->ExceptionInformation[0]) {

    /* this is a software generated exception; ExceptionInformation[0]
     * points to a data structure of type _FPIEEE_RECORD */

    // exception code should not be STATUS_FLOAT_MULTIPLE_FAULTS or
    // STATUS_FLOAT_MULTIPLE_TRAPS for a software generated exception
    if (eXceptionCode == STATUS_FLOAT_MULTIPLE_FAULTS ||
        eXceptionCode == STATUS_FLOAT_MULTIPLE_TRAPS) {
      fprintf (stderr, "IEEE Filter Internal Error: eXceptionCode \
          STATUS_FLOAT_MULTIPLE_FAULTS or STATUS_FLOAT_MULTIPLE_TRAPS \
          not supported in software generated IEEE exception\n");
      exit (1);
    }

    handler_return_value = handler((_FPIEEE_RECORD *)(ExceptionInformation[0]));

    return (handler_return_value);

  }

  /* get the instruction that caused the exception */

  ISRhigh = (unsigned int)
      ((ExceptionRecord->ExceptionInformation[4] >> 32) & 0x0ffffffff);
  ISRlow =  (unsigned int)
      (ExceptionRecord->ExceptionInformation[4] & 0x0ffffffff);
#ifdef FPIEEE_FLT_DEBUG
  printf ("FPIEEE_FLT_DEBUG ISRhigh = %x\n", ISRhigh);
  printf ("FPIEEE_FLT_DEBUG ISRlow = %x\n", ISRlow);
#endif

  /* excepting instruction in bundle: slot 0, 1, or 2 */
  ei = (ISRhigh >> 9) & 0x03;
#ifdef FPIEEE_FLT_DEBUG
  printf ("FPIEEE_FLT_DEBUG ei = %x\n", ei);
#endif

  ExceptionAddress = ExceptionRecord->ExceptionAddress;
#ifdef FPIEEE_FLT_DEBUG
  printf ("FPIEEE_FLT_DEBUG Context->StIIP = %I64x\n", Context->StIIP);
  printf ("FPIEEE_FLT_DEBUG ExceptionAddress = %I64x\n", ExceptionAddress);
#endif
  ExceptionAddress = (char *)((__int64)ExceptionAddress & 0xfffffffffffffff0);

  BundleLow = *((unsigned __int64 *)ExceptionAddress);
  BundleHigh = *(((unsigned __int64 *)ExceptionAddress) + 1);
#ifdef FPIEEE_FLT_DEBUG
  printf ("FPIEEE_FLT_DEBUG BundleLow = %8x %8x\n",
      (int)(BundleLow >> 32) & 0xffffffff, (int)BundleLow & 0xffffffff);
  printf ("FPIEEE_FLT_DEBUG BundleHigh = %8x %8x\n",
      (int)(BundleHigh >> 32) & 0xffffffff, (int)BundleHigh & 0xffffffff);
#endif

  CFM = Context->StIFS & 0x03fffffffff;
  rrbpr = (unsigned int)((CFM >> 32) & 0x3f);
  rrbfr = (unsigned int)((CFM >> 25) & 0x7f);
#ifdef FPIEEE_FLT_DEBUG
  printf ("FPIEEE_FLT_DEBUG: rrbpr = %x rrbfr = %x\n", rrbpr, rrbfr);
  printf ("FPIEEE_FLT_DEBUG: CFM = %8x %8x\n", 
      (int)(CFM >> 32) & 0xffffffff, (int)CFM & 0xffffffff);
#endif

  /* cut the faulting instruction opcode (41 bits) */
  if (ei == 0 ) { // no template for this case
    // OpCode = (BundleLow >> 5) & (unsigned __int64)0x01ffffffffff;
    fprintf (stderr, "IEEE Filter Internal Error: illegal template FXX\n");
    exit (1);
  } else if (ei == 1) { // templates: MFI, MFB
    OpCode = ((BundleHigh & (unsigned __int64)0x07fffff) << 18) |
        ((BundleLow >> 46) & (unsigned __int64)0x03ffff);
  } else if (ei == 2) { // templates: MMF
    OpCode = (BundleHigh >> 23) & (unsigned __int64)0x01ffffffffff;
  } else {
    // OpCode = 0; may need this to avoid compiler warning
    fprintf (stderr, "IEEE Filter Internal Error: instr. slot 3 is invalid\n");
    exit (1);
  }

#ifdef FPIEEE_FLT_DEBUG
  printf ("FPIEEE_FLT_DEBUG OpCode = %8x %8x\n",
      (int)(OpCode >> 32) & 0xffffffff, (int)OpCode & 0xffffffff);
#endif

  /* decode the instruction opcode; we could get here only
   * for FP instructions that caused an FP fault or trap
   */

  /* sf and qp have the same offset, for all the FP instructions */
  sf = (unsigned int)((OpCode >> 34) & (unsigned __int64)0x000000000003);

  // the floating-point exceptions must already be masked, but set the user
  // FPSR, with exceptions masked; note that they are not unmasked [again]
  // inside the IEEE handler; if execution is continued, exception masking
  // will be restored with the FPSR)

  // three different values of the FPSR are used:
  //   FPSR is the value at the time of the exception occurence; it will
  //       be modified to clear the user status flags and it will be
  //       updated to reflect changes made by the user exception handler
  //   old_fpsr is the value at the time _fpieee_flt () was invoked by
  //       the OS; it will be restored before returning from this function
  //   new_fpsr is old_fpsr with fp exceptions disabled (and status flags
  //       cleared)
  //   usr_fpsr is the value at the time of the exception occurence (just
  //       as FPSR, but without any change); it is used when re-executing
  //       the low or the high part of the excepting instruction for a
  //       SIMD instruction
  usr_fpsr = Context->StFPSR; // save for possible re-execution-FPSR may change
  __get_fpsr (&old_fpsr);
  new_fpsr = (old_fpsr | 0x3f) & ~((unsigned __int64)0x07e000 << (13 * sf));
      // user fpsr with disabled fp exceptions and clear flags
  __set_fpsr (&new_fpsr);


  /* this is a hardware generated exception; need to fill in the 
   * FPIEEE_RECORD data structure */

  /* get the qualifying predicate */
  qp = (unsigned int)(OpCode & (unsigned __int64)0x00000000003F);
  if (qp >= 16) qp = 16 + (rrbpr + qp - 16) % 48;
#ifdef FPIEEE_FLT_DEBUG
  printf ("FPIEEE_FLT_DEBUG: qp = %x\n", qp);
#endif
  /* read the rounding control and precision control from the FPSR */
  rc = (unsigned int)((FPSR >> (6 + 4 + 13 * sf)) & 0x03);
#ifdef FPIEEE_FLT_DEBUG
  printf ("FPIEEE_FLT_DEBUG: rc = %x\n", rc);
#endif
  pc = (unsigned int)((FPSR >> (6 + 2 + 13 * sf)) & 0x03);
#ifdef FPIEEE_FLT_DEBUG
  printf ("FPIEEE_FLT_DEBUG: pc = %x\n", pc);
#endif
  wre = (unsigned int)((FPSR >> (6 + 1 + 13 * sf)) & 0x01);
#ifdef FPIEEE_FLT_DEBUG
  printf ("FPIEEE_FLT_DEBUG: wre = %x\n", wre);
#endif

  /* read predicate register qp */
  PR = (unsigned int)((Context->Preds >> qp) & 0x01);
#ifdef FPIEEE_FLT_DEBUG
  printf ("FPIEEE_FLT_DEBUG: PR = %x\n", PR);
#endif

  if (PR == 0) {
    fprintf (stderr, "IEEE Filter Internal Error: qualifying \
        predicate PR[%2.2x] = 0\n", qp);
     exit (1);
  }

  /* fill in the rounding mode */
  switch (rc) {

    case rc_rn:
      RoundingMode = FpieeeRecord.RoundingMode = _FpRoundNearest;
      break;
    case rc_rm:
      RoundingMode = FpieeeRecord.RoundingMode = _FpRoundMinusInfinity;
      break;
    case rc_rp:
      RoundingMode = FpieeeRecord.RoundingMode = _FpRoundPlusInfinity;
      break;
    case rc_rz:
      RoundingMode = FpieeeRecord.RoundingMode = _FpRoundChopped;
      break;

  }

  /* fill in the precision mode */
  switch (pc) {

    case sf_single:
      Precision = FpieeeRecord.Precision = _FpPrecision24;
      break;

    case sf_double:
      Precision = FpieeeRecord.Precision = _FpPrecision53;
      break;

    case sf_double_extended:
      Precision = FpieeeRecord.Precision = _FpPrecision64;
      break;

    default:
      fprintf (stderr, "IEEE Filter Internal Error: pc = %x is invalid\n", pc);
      exit (1);

  }

  /* decode the fp environment information further more */

  /* I_dis = (sf != 0 && td == 1) || id == 1
   * U_dis = (sf != 0 && td == 1) || ud == 1
   * ... */
  I_dis = sf != 0 && ((FPSR >> (6 + 6 + 13 * sf)) & 0x01) ||
      ((FPSR >> 5) & 0x01);
  U_dis = sf != 0 && ((FPSR >> (6 + 6 + 13 * sf)) & 0x01) ||
      ((FPSR >> 4) & 0x01);
  O_dis = sf != 0 && ((FPSR >> (6 + 6 + 13 * sf)) & 0x01) ||
      ((FPSR >> 3) & 0x01);
  Z_dis = sf != 0 && ((FPSR >> (6 + 6 + 13 * sf)) & 0x01) ||
      ((FPSR >> 2) & 0x01);
  D_dis = sf != 0 && ((FPSR >> (6 + 6 + 13 * sf)) & 0x01) ||
      ((FPSR >> 1) & 0x01);
  V_dis = sf != 0 && ((FPSR >> (6 + 6 + 13 * sf)) & 0x01) ||
      ((FPSR >> 0) & 0x01);

#ifdef FPIEEE_FLT_DEBUG
  printf ("FPIEEE_FLT_DEBUG: I_dis = %x\n", I_dis);
  printf ("FPIEEE_FLT_DEBUG: U_dis = %x\n", U_dis);
  printf ("FPIEEE_FLT_DEBUG: O_dis = %x\n", O_dis);
  printf ("FPIEEE_FLT_DEBUG: Z_dis = %x\n", Z_dis);
  printf ("FPIEEE_FLT_DEBUG: D_dis = %x\n", D_dis);
  printf ("FPIEEE_FLT_DEBUG: V_dis = %x\n", V_dis);
#endif

  FpieeeRecord.Enable.InvalidOperation = !V_dis;
  EnableDenormal = !D_dis;
  FpieeeRecord.Enable.ZeroDivide = !Z_dis;
  FpieeeRecord.Enable.Overflow = !O_dis;
  FpieeeRecord.Enable.Underflow = !U_dis;
  FpieeeRecord.Enable.Inexact = !I_dis;

  // determine whether this is a scalar (non-SIMD), or a parallel (SIMD)
  // instruction
  if ((OpCode & F1_MIN_MASK) == F1_PATTERN) {
    // F1 instruction

    switch (OpCode & F1_MASK) {
      case FMA_PATTERN:
      case FMA_S_PATTERN:
      case FMA_D_PATTERN:
      case FMS_PATTERN:
      case FMS_S_PATTERN:
      case FMS_D_PATTERN:
      case FNMA_PATTERN:
      case FNMA_S_PATTERN:
      case FNMA_D_PATTERN:
        SIMD_instruction = 0;
        break;
      case FPMA_PATTERN:
      case FPMS_PATTERN:
      case FPNMA_PATTERN:
        SIMD_instruction = 1;
        break;
      default:
        // unrecognized instruction type
        fprintf (stderr, "IEEE Filter Internal Error: \
instruction opcode %8x %8x not recognized\n", 
            (int)(OpCode >> 32) & 0xffffffff, (int)OpCode & 0xffffffff);
        __set_fpsr (&old_fpsr); /* restore caller fpsr */
        return (EXCEPTION_CONTINUE_SEARCH);
    }

  } else if ((OpCode & F4_MIN_MASK) == F4_PATTERN) {
    // F4 instruction

    switch (OpCode & F4_MASK) {
      case FCMP_EQ_PATTERN:
      case FCMP_LT_PATTERN:
      case FCMP_LE_PATTERN:
      case FCMP_UNORD_PATTERN:
      case FCMP_EQ_UNC_PATTERN:
      case FCMP_LT_UNC_PATTERN:
      case FCMP_LE_UNC_PATTERN:
      case FCMP_UNORD_UNC_PATTERN:
        SIMD_instruction = 0;
        break;
      default:
        // unrecognized instruction type
        fprintf (stderr, "IEEE Filter Internal Error: \
instruction opcode %8x %8x not recognized\n",
            (int)(OpCode >> 32) & 0xffffffff, (int)OpCode & 0xffffffff);
        __set_fpsr (&old_fpsr); /* restore caller fpsr */
        return (EXCEPTION_CONTINUE_SEARCH);
    }

  } else if ((OpCode & F6_MIN_MASK) == F6_PATTERN) {
    // F6 instruction

    switch (OpCode & F6_MASK) {
      case FRCPA_PATTERN:
        SIMD_instruction = 0;
        break;
      case FPRCPA_PATTERN:
        SIMD_instruction = 1;
        break;
      default:
        // unrecognized instruction type
        fprintf (stderr, "IEEE Filter Internal Error: \
instruction opcode %8x %8x not recognized\n",
            (int)(OpCode >> 32) & 0xffffffff, (int)OpCode & 0xffffffff);
        __set_fpsr (&old_fpsr); /* restore caller fpsr */
        return (EXCEPTION_CONTINUE_SEARCH);
    }

  } else if ((OpCode & F7_MIN_MASK) == F7_PATTERN) {
    // F7 instruction

    switch (OpCode & F7_MASK) {
      case FRSQRTA_PATTERN:
        SIMD_instruction = 0;
        break;
      case FPRSQRTA_PATTERN:
        SIMD_instruction = 1;
        break;
      default:
        // unrecognized instruction type
        fprintf (stderr, "IEEE Filter Internal Error: \
instruction opcode %8x %8x not recognized\n",
            (int)(OpCode >> 32) & 0xffffffff, (int)OpCode & 0xffffffff);
        __set_fpsr (&old_fpsr); /* restore caller fpsr */
        return (EXCEPTION_CONTINUE_SEARCH);
    }

  } else if ((OpCode & F8_MIN_MASK) == F8_PATTERN) {
    // F8 instruction

    switch (OpCode & F8_MASK) {
      case FMIN_PATTERN:
      case FMAX_PATTERN:
      case FAMIN_PATTERN:
      case FAMAX_PATTERN:
        SIMD_instruction = 0;
        break;
      case FPMIN_PATTERN:
      case FPMAX_PATTERN:
      case FPAMIN_PATTERN:
      case FPAMAX_PATTERN:
      case FPCMP_EQ_PATTERN:
      case FPCMP_LT_PATTERN:
      case FPCMP_LE_PATTERN:
      case FPCMP_UNORD_PATTERN:
      case FPCMP_NEQ_PATTERN:
      case FPCMP_NLT_PATTERN:
      case FPCMP_NLE_PATTERN:
      case FPCMP_ORD_PATTERN:
        SIMD_instruction = 1;
        break;
      default:
        // unrecognized instruction type
        fprintf (stderr, "IEEE Filter Internal Error: \
instruction opcode %8x %8x not recognized\n",
            (int)(OpCode >> 32) & 0xffffffff, (int)OpCode & 0xffffffff);
        __set_fpsr (&old_fpsr); /* restore caller fpsr */
        return (EXCEPTION_CONTINUE_SEARCH);
    }

  } else if ((OpCode & F10_MIN_MASK) == F10_PATTERN) {
    // F10 instruction

    switch (OpCode & F10_MASK) {
      case FCVT_FX_PATTERN:
      case FCVT_FXU_PATTERN:
      case FCVT_FX_TRUNC_PATTERN:
      case FCVT_FXU_TRUNC_PATTERN:
        SIMD_instruction = 0;
        break;
      case FPCVT_FX_PATTERN:
      case FPCVT_FXU_PATTERN:
      case FPCVT_FX_TRUNC_PATTERN:
      case FPCVT_FXU_TRUNC_PATTERN:
        SIMD_instruction = 1;
        break;
      default:
        // unrecognized instruction type
        fprintf (stderr, "IEEE Filter Internal Error: \
instruction opcode %8x %8x not recognized\n",
            (int)(OpCode >> 32) & 0xffffffff, (int)OpCode & 0xffffffff);
        __set_fpsr (&old_fpsr); /* restore caller fpsr */
        return (EXCEPTION_CONTINUE_SEARCH);
    }

  } else {

    // unrecognized instruction type
    fprintf (stderr, "IEEE Filter Internal Error: \
instruction opcode %8x %8x not recognized\n",
        (int)(OpCode >> 32) & 0xffffffff, (int)OpCode & 0xffffffff);
    __set_fpsr (&old_fpsr); /* restore caller fpsr */
    return (EXCEPTION_CONTINUE_SEARCH);

  }

  if (eXceptionCode == STATUS_FLOAT_INVALID_OPERATION ||
      eXceptionCode == STATUS_FLOAT_DENORMAL_OPERAND ||
      eXceptionCode == STATUS_FLOAT_DIVIDE_BY_ZERO) {

    FpieeeRecord.Status.InvalidOperation = ((ISRlow & 0x0001) != 0);
    StatusDenormal = ((ISRlow & 0x0002) != 0);
    FpieeeRecord.Status.ZeroDivide = ((ISRlow & 0x0004) != 0);
    FpieeeRecord.Status.Overflow = 0;
    FpieeeRecord.Status.Underflow = 0;
    FpieeeRecord.Status.Inexact = 0;

  } else if (eXceptionCode == STATUS_FLOAT_UNDERFLOW ||
      eXceptionCode == STATUS_FLOAT_OVERFLOW ||
      eXceptionCode == STATUS_FLOAT_INEXACT_RESULT) {

    /* note that U and I or O and I may be set simultaneously in ISRlow */
    FpieeeRecord.Status.InvalidOperation = 0;
    StatusDenormal = 0;
    FpieeeRecord.Status.ZeroDivide = 0;
    FpieeeRecord.Status.Overflow = ((ISRlow & 0x0800) != 0);
    FpieeeRecord.Status.Underflow = ((ISRlow & 0x1000) != 0);
    FpieeeRecord.Status.Inexact = ((ISRlow & 0x2000) != 0);

  } else if (eXceptionCode == STATUS_FLOAT_MULTIPLE_FAULTS) {

    LowStatus.InvalidOperation = ((ISRlow & 0x0010) != 0);
    HighStatus.InvalidOperation = ((ISRlow & 0x0001) != 0);
    LowStatusDenormal = ((ISRlow & 0x0020) != 0);
    HighStatusDenormal = ((ISRlow & 0x0002) != 0);
    LowStatus.ZeroDivide = ((ISRlow & 0x0040) != 0);
    HighStatus.ZeroDivide = ((ISRlow & 0x0004) != 0);
    LowStatus.Overflow = 0;
    HighStatus.Overflow = 0;
    LowStatus.Underflow = 0;
    HighStatus.Underflow = 0;
    LowStatus.Inexact = 0;
    HighStatus.Inexact = 0;

  } else if (eXceptionCode == STATUS_FLOAT_MULTIPLE_TRAPS) {

    /* note that U and I or O and I may be set simultaneously in ISRlow */
    LowStatus.InvalidOperation = 0;
    HighStatus.InvalidOperation = 0;
    LowStatusDenormal = 0;
    HighStatusDenormal = 0;
    LowStatus.ZeroDivide = 0;
    HighStatus.ZeroDivide = 0;
    LowStatus.Overflow = ((ISRlow & 0x0080) != 0);
    HighStatus.Overflow = ((ISRlow & 0x0800) != 0);
    LowStatus.Underflow = ((ISRlow & 0x0100) != 0);
    HighStatus.Underflow = ((ISRlow & 0x1000) != 0);
    LowStatus.Inexact = ((ISRlow & 0x0200) != 0);
    HighStatus.Inexact = ((ISRlow & 0x2000) != 0);

  } // else { ; } // this case was checked above

  if (eXceptionCode == STATUS_FLOAT_MULTIPLE_FAULTS) {

    LowCause.InvalidOperation =
        FpieeeRecord.Enable.InvalidOperation && LowStatus.InvalidOperation;
    HighCause.InvalidOperation =
        FpieeeRecord.Enable.InvalidOperation && HighStatus.InvalidOperation;
    LowCauseDenormal = EnableDenormal && LowStatusDenormal;
    HighCauseDenormal = EnableDenormal && HighStatusDenormal;
    LowCause.ZeroDivide =
        FpieeeRecord.Enable.ZeroDivide && LowStatus.ZeroDivide;
    HighCause.ZeroDivide =
        FpieeeRecord.Enable.ZeroDivide && HighStatus.ZeroDivide;
    LowCause.Overflow = 0;
    HighCause.Overflow = 0;
    LowCause.Underflow = 0;
    HighCause.Underflow = 0;
    LowCause.Inexact = 0;
    HighCause.Inexact = 0;

    /* search for another handler if not an IEEE or denormal fault */
    if (!LowCause.InvalidOperation && !HighCause.InvalidOperation &&
        !LowCauseDenormal && !HighCauseDenormal &&
        !LowCause.ZeroDivide && !HighCause.ZeroDivide) {
      __set_fpsr (&old_fpsr); /* restore caller fpsr */
#ifdef FPIEEE_FLT_DEBUG
      printf ("FPIEEE_FLT_DEBUG: STATUS_FLOAT_MULTIPLE_FAULTS BUT NO Cause\n");
#endif
      return (EXCEPTION_CONTINUE_SEARCH);
    }

  } else if (eXceptionCode == STATUS_FLOAT_MULTIPLE_TRAPS) {

    LowCause.InvalidOperation = 0;
    HighCause.InvalidOperation = 0;
    LowCauseDenormal = 0;
    HighCauseDenormal = 0;
    LowCause.ZeroDivide = 0;
    HighCause.ZeroDivide = 0;
    LowCause.Overflow = FpieeeRecord.Enable.Overflow && LowStatus.Overflow;
    HighCause.Overflow = FpieeeRecord.Enable.Overflow && HighStatus.Overflow;
    LowCause.Underflow = FpieeeRecord.Enable.Underflow && LowStatus.Underflow;
    HighCause.Underflow = FpieeeRecord.Enable.Underflow && HighStatus.Underflow;
    if (LowCause.Overflow || LowCause.Underflow)
      LowCause.Inexact = 0;
    else
      LowCause.Inexact = FpieeeRecord.Enable.Inexact && LowStatus.Inexact;
    if (HighCause.Overflow || HighCause.Underflow)
      HighCause.Inexact = 0;
    else
      HighCause.Inexact = FpieeeRecord.Enable.Inexact && HighStatus.Inexact;

    /* search for another handler if not an IEEE or denormal trap */
    if (!LowCause.Overflow && !HighCause.Overflow &&
        !LowCause.Underflow && !HighCause.Underflow &&
        !LowCause.Inexact && !HighCause.Inexact) {
      __set_fpsr (&old_fpsr); /* restore caller fpsr */
#ifdef FPIEEE_FLT_DEBUG
      printf ("FPIEEE_FLT_DEBUG: STATUS_FLOAT_MULTIPLE_FAULTS BUT NO Cause\n");
#endif
      return (EXCEPTION_CONTINUE_SEARCH);
    }

  } else { // if (!SIMD_instruction)

    FpieeeRecord.Cause.InvalidOperation = FpieeeRecord.Enable.InvalidOperation
        && FpieeeRecord.Status.InvalidOperation;
    CauseDenormal = EnableDenormal && StatusDenormal;
    FpieeeRecord.Cause.ZeroDivide =
        FpieeeRecord.Enable.ZeroDivide && FpieeeRecord.Status.ZeroDivide;
    FpieeeRecord.Cause.Overflow =
        FpieeeRecord.Enable.Overflow && FpieeeRecord.Status.Overflow;
    FpieeeRecord.Cause.Underflow =
        FpieeeRecord.Enable.Underflow && FpieeeRecord.Status.Underflow;
    if (FpieeeRecord.Cause.Overflow || FpieeeRecord.Cause.Underflow)
      FpieeeRecord.Cause.Inexact = 0;
    else
      FpieeeRecord.Cause.Inexact =
          FpieeeRecord.Enable.Inexact && FpieeeRecord.Status.Inexact;

    /* search for another handler if not an IEEE exception */
    if (!FpieeeRecord.Cause.InvalidOperation &&
        !FpieeeRecord.Cause.ZeroDivide &&
        !CauseDenormal &&
        !FpieeeRecord.Cause.Overflow &&
        !FpieeeRecord.Cause.Underflow &&
        !FpieeeRecord.Cause.Inexact) {
      __set_fpsr (&old_fpsr); /* restore caller fpsr */
#ifdef FPIEEE_FLT_DEBUG
      printf ("FPIEEE_FLT_DEBUG: NON-SIMD FP EXCEPTION BUT NO Cause\n");
#endif
      return (EXCEPTION_CONTINUE_SEARCH);
    }

  }

  if ((eXceptionCode == STATUS_FLOAT_INVALID_OPERATION || 
      eXceptionCode == STATUS_FLOAT_DENORMAL_OPERAND ||
      eXceptionCode == STATUS_FLOAT_DIVIDE_BY_ZERO ||
      eXceptionCode == STATUS_FLOAT_OVERFLOW ||
      eXceptionCode == STATUS_FLOAT_UNDERFLOW ||
      eXceptionCode == STATUS_FLOAT_INEXACT_RESULT) && SIMD_instruction ||
      (eXceptionCode == STATUS_FLOAT_MULTIPLE_FAULTS ||
      eXceptionCode == STATUS_FLOAT_MULTIPLE_TRAPS) && !SIMD_instruction) {
    fprintf (stderr, "IEEE Filter Internal Error: Exception Code %8x and \
SIMD_instruction = %x not compatible for F1 instruction opcode %8x %8x\n",
          eXceptionCode, SIMD_instruction,
          (int)(OpCode >> 32) & 0xffffffff, (int)OpCode & 0xffffffff);
      exit (1);
  }

  /* decode the rest of the instruction */
  if ((OpCode & F1_MIN_MASK) == F1_PATTERN) {
    /* F1 instruction */
    // FMA, FMS, FNMA, FPMA, FPMS, FPNMA

#ifdef FPIEEE_FLT_DEBUG
    printf ("FPIEEE_FLT_DEBUG: F1 instruction\n");
#endif

    if (!SIMD_instruction && FpieeeRecord.Cause.ZeroDivide || 
        SIMD_instruction && (LowCause.ZeroDivide || HighCause.ZeroDivide)) {
      fprintf (stderr, "IEEE Filter Internal Error: Cause.ZeroDivide for \
F1 instruction opcode %8x %8x\n", 
          (int)(OpCode >> 32) & 0xffffffff, (int)OpCode & 0xffffffff);
      exit (1);
    }

    /* extract f4, f3, f2, and f1 */
    f4 = (unsigned int)((OpCode >> 27) & (unsigned __int64)0x00000000007F);
    if (f4 >= 32) f4 = 32 + (rrbfr + f4 - 32) % 96;
    f3 = (unsigned int)((OpCode >> 20) & (unsigned __int64)0x00000000007F);
    if (f3 >= 32) f3 = 32 + (rrbfr + f3 - 32) % 96;
    f2 = (unsigned int)((OpCode >> 13) & (unsigned __int64)0x00000000007F);
    if (f2 >= 32) f2 = 32 + (rrbfr + f2 - 32) % 96;
    f1 = (unsigned int)((OpCode >>  6) & (unsigned __int64)0x00000000007F);
    if (f1 >= 32) f1 = 32 + (rrbfr + f1 - 32) % 96;

#ifdef FPIEEE_FLT_DEBUG
    printf ("FPIEEE_FLT_DEBUG: f1 = %x\n", f1);
    printf ("FPIEEE_FLT_DEBUG: f2 = %x\n", f2);
    printf ("FPIEEE_FLT_DEBUG: f3 = %x\n", f3);
    printf ("FPIEEE_FLT_DEBUG: f4 = %x\n", f4);
#endif

    /* get source floating-point register values */
    FR3 = GetFloatRegisterValue (f3, Context);
    FR4 = GetFloatRegisterValue (f4, Context);
    FR2 = GetFloatRegisterValue (f2, Context);

#ifdef FPIEEE_FLT_DEBUG
    printf ("FPIEEE_FLT_DEBUG: FR2 = %08x %08x %08x %08x\n",
        FR2.W[3], FR2.W[2], FR2.W[1], FR2.W[0]);
    printf ("FPIEEE_FLT_DEBUG: FR3 = %08x %08x %08x %08x\n",
        FR3.W[3], FR3.W[2], FR3.W[1], FR3.W[0]);
    printf ("FPIEEE_FLT_DEBUG: FR4 = %08x %08x %08x %08x\n",
        FR4.W[3], FR4.W[2], FR4.W[1], FR4.W[0]);
#endif

    if (!SIMD_instruction) {

      // *** this is a non-SIMD instruction ***

      FpieeeRecord.Operand1.Format = _FpFormatFp82; /* 1 + 17 + 64 bits */
      FpieeeRecord.Operand1.OperandValid = 1;
      FpieeeRecord.Operand1.Value.Fp128Value = FR3;
      FpieeeRecord.Operand2.Format = _FpFormatFp82; /* 1 + 17 + 64 bits */
      FpieeeRecord.Operand2.OperandValid = 1;
      FpieeeRecord.Operand2.Value.Fp128Value = FR4;
      FpieeeRecord.Operand3.Format = _FpFormatFp82; /* 1 + 17 + 64 bits */
      FpieeeRecord.Operand3.OperandValid = 1;
      FpieeeRecord.Operand3.Value.Fp128Value = FR2;

      switch (OpCode & F1_MASK) {

        case FMA_PATTERN:

#ifdef FPIEEE_FLT_DEBUG
          printf ("FPIEEE_FLT_DEBUG F1 INSTRUCTION FMA\n");
#endif
          FpieeeRecord.Operation = _FpCodeFma;
          if (wre == 0)
            FpieeeRecord.Result.Format = _FpFormatFp80; /* 1+15+24/53/64 bits */
          else
            FpieeeRecord.Result.Format = _FpFormatFp82; /* 1+17+24/53/64 bits */
          break;

        case FMA_S_PATTERN:

          FpieeeRecord.Operation = _FpCodeFmaSingle;
          if (wre == 0)
            FpieeeRecord.Result.Format = _FpFormatFp32; /* 1+8+24 bits */
          else
            FpieeeRecord.Result.Format = _FpFormatFp82; /* 1+17+24 bits */
          break;

        case FMA_D_PATTERN:

#ifdef FPIEEE_FLT_DEBUG
          printf ("FPIEEE_FLT_DEBUG F1 INSTRUCTION FMA_D\n");
#endif
          FpieeeRecord.Operation = _FpCodeFmaDouble;
          if (wre == 0)
            FpieeeRecord.Result.Format = _FpFormatFp64; /* 1+11+53 bits */
          else
            FpieeeRecord.Result.Format = _FpFormatFp82; /* 1+17+53 bits */
          break;


        case FMS_PATTERN:

#ifdef FPIEEE_FLT_DEBUG
          printf ("FPIEEE_FLT_DEBUG F1 INSTRUCTION FMS\n");
#endif
          FpieeeRecord.Operation = _FpCodeFms;
          if (wre == 0)
            FpieeeRecord.Result.Format = _FpFormatFp80; /* 1+15+24/53/64 bits */
          else
            FpieeeRecord.Result.Format = _FpFormatFp82; /* 1+17+24/53/64 bits */
          break;

        case FMS_S_PATTERN:

#ifdef FPIEEE_FLT_DEBUG
          printf ("FPIEEE_FLT_DEBUG F1 INSTRUCTION FMS_S\n");
#endif
          FpieeeRecord.Operation = _FpCodeFmsSingle;
          if (wre == 0)
            FpieeeRecord.Result.Format = _FpFormatFp32; /* 1+8+24 bits */
          else
            FpieeeRecord.Result.Format = _FpFormatFp82; /* 1+17+24 bits */
          break;

        case FMS_D_PATTERN:

#ifdef FPIEEE_FLT_DEBUG
          printf ("FPIEEE_FLT_DEBUG F1 INSTRUCTION FMS_D\n");
#endif
          FpieeeRecord.Operation = _FpCodeFmsDouble;
          if (wre == 0)
            FpieeeRecord.Result.Format = _FpFormatFp64; /* 1+11+53 bits */
          else
            FpieeeRecord.Result.Format = _FpFormatFp82; /* 1+17+53 bits */
          break;

        case FNMA_PATTERN:

#ifdef FPIEEE_FLT_DEBUG
          printf ("FPIEEE_FLT_DEBUG F1 INSTRUCTION FNMA\n");
#endif
          FpieeeRecord.Operation = _FpCodeFnma;
          if (wre == 0)
            FpieeeRecord.Result.Format = _FpFormatFp80; /* 1+15+24/53/64 bits */
          else
            FpieeeRecord.Result.Format = _FpFormatFp82; /* 1+17+24/53/64 bits */
          break;

        case FNMA_S_PATTERN:

#ifdef FPIEEE_FLT_DEBUG
          printf ("FPIEEE_FLT_DEBUG F1 INSTRUCTION FNMA_S\n");
#endif
          FpieeeRecord.Operation = _FpCodeFnmaSingle;
          if (wre == 0)
            FpieeeRecord.Result.Format = _FpFormatFp32; /* 1+8+24 bits */
          else
            FpieeeRecord.Result.Format = _FpFormatFp82; /* 1+17+24 bits */
          break;

        case FNMA_D_PATTERN:

#ifdef FPIEEE_FLT_DEBUG
          printf ("FPIEEE_FLT_DEBUG F1 INSTRUCTION FNMA_D\n");
#endif
          FpieeeRecord.Operation = _FpCodeFnmaDouble;
          if (wre == 0)
            FpieeeRecord.Result.Format = _FpFormatFp64; /* 1+11+53 bits */
          else
            FpieeeRecord.Result.Format = _FpFormatFp82; /* 1+17+53 bits */
          break;

        default:
          /* unrecognized instruction type */
          fprintf (stderr, "IEEE Filter Internal Error: \
              non-SIMD F1 instruction opcode %8x %8x not recognized\n", 
              (int)(OpCode >> 32) & 0xffffffff, (int)OpCode & 0xffffffff);
          exit (1);

      }

      if (FpieeeRecord.Cause.InvalidOperation || CauseDenormal) {

        /* this is a fault - the result contains an invalid value */
        FpieeeRecord.Result.OperandValid = 0;
        handler_return_value = handler (&FpieeeRecord);

      } else if (FpieeeRecord.Cause.Overflow) {
 
        // this is a trap - the result contains a valid value
        FpieeeRecord.Result.OperandValid = 1;
        // get the result
        FpieeeRecord.Result.Value.Fp128Value =
            GetFloatRegisterValue (f1, Context);
#ifdef FPIEEE_FLT_DEBUG
        printf ("FPIEEE_FLT_DEBUG OVERFLOW: RES = %08x %08x %08x %08x\n",
            FpieeeRecord.Result.Value.Fp128Value.W[3],
            FpieeeRecord.Result.Value.Fp128Value.W[2],
            FpieeeRecord.Result.Value.Fp128Value.W[1],
            FpieeeRecord.Result.Value.Fp128Value.W[0]);
#endif

        // before calling the user handler, adjust the result to the
        // range imposed by the format
        FP128ToFPIeee (&FpieeeRecord, -1); // -1 indicates scaling direction 
        handler_return_value = handler (&FpieeeRecord);

      } else if (FpieeeRecord.Cause.Underflow) {

        // this is a trap - the result contains a valid value
        FpieeeRecord.Result.OperandValid = 1;
        // get the result
        FpieeeRecord.Result.Value.Fp128Value =
            GetFloatRegisterValue (f1, Context);
        // before calling the user handler, adjust the result to the
        // range imposed by the format
        FP128ToFPIeee (&FpieeeRecord, +1); // +1 indicates scaling direction 
        handler_return_value = handler (&FpieeeRecord);

      } else if (FpieeeRecord.Cause.Inexact) {

        // this is a trap - the result contains a valid value
        FpieeeRecord.Result.OperandValid = 1;
        // get the result
        FpieeeRecord.Result.Value.Fp128Value =
            GetFloatRegisterValue (f1, Context);
        // before calling the user handler, adjust the result to the
        // range imposed by the format
        FP128ToFPIeee (&FpieeeRecord, 0); // 0 indicates no scaling
        handler_return_value = handler (&FpieeeRecord);

      }

      if (handler_return_value == EXCEPTION_CONTINUE_EXECUTION) {

        // convert the result to 82-bit format
        FR1 = FPIeeeToFP128 (&FpieeeRecord);
#ifdef FPIEEE_FLT_DEBUG
        printf ("FPIEEE_FLT_DEBUG 1: CONVERTED FR1 = %08x %08x %08x %08x\n",
            FR1.W[3], FR1.W[2], FR1.W[1], FR1.W[0]);
#endif

        /* change the FPSR with values (possibly) set by the user handler, 
         * for continuing execution where the interruption occured */

        UpdateRoundingMode (FpieeeRecord.RoundingMode, sf, &FPSR, "F1");
        UpdatePrecision (FpieeeRecord.Precision, sf, &FPSR, "F1");

        I_dis = !FpieeeRecord.Enable.Inexact;
        U_dis = !FpieeeRecord.Enable.Underflow;
        O_dis = !FpieeeRecord.Enable.Overflow;
        Z_dis = !FpieeeRecord.Enable.ZeroDivide;
        V_dis = !FpieeeRecord.Enable.InvalidOperation;

        FPSR = FPSR & ~((unsigned __int64)0x03d) | (unsigned __int64)(I_dis << 5
            | U_dis << 4 | O_dis << 3 | Z_dis << 2 | V_dis);

        Context->StFPSR = FPSR;

        // set the result before continuing execution
        SetFloatRegisterValue (f1, FR1, Context);
        if (f1 < 32)
          Context->StIPSR = Context->StIPSR | (unsigned __int64)0x10; //set mfl bit
        else
          Context->StIPSR = Context->StIPSR | (unsigned __int64)0x20; //set mfh bit

        // if this is a fault, need to advance the instruction pointer
        if (FpieeeRecord.Cause.InvalidOperation || CauseDenormal) {

          if (ei == 0) { // no template for this case
            Context->StIPSR = Context->StIPSR & 0xfffff9ffffffffff;
            Context->StIPSR = Context->StIPSR | 0x0000020000000000;
          } else if (ei == 1) { // templates: MFI, MFB
            Context->StIPSR = Context->StIPSR & 0xfffff9ffffffffff;
            Context->StIPSR = Context->StIPSR | 0x0000040000000000;
          } else { // if (ei == 2) // templates: MMF
            Context->StIPSR = Context->StIPSR & 0xfffff9ffffffffff;
            Context->StIIP = Context->StIIP + 0x10;
          }

        }

      }

    } else { // if (SIMD_instruction)

      // *** this is a SIMD instruction ***

      // the half (halves) of the instruction that caused an enabled exception, 
      // are presented to the user-defined handler in the form of non-SIMD in-
      // struction(s); the half (if any) that did not cause an enabled exception
      // (i.e. caused no exception, or caused an exception that is disabled),
      // is re-executed if it is associated with a fault in the other half; in
      // this case, the other half is padded to calculate 0.0 * 0.0 + 0.0, that
      // will cause no exception; if it is associated with a trap in the other
      // half, its result is left unchanged

      switch (OpCode & F1_MASK) {

        case FPMA_PATTERN:
          Operation = _FpCodeFmaSingle;
          break;

        case FPMS_PATTERN:
          Operation = _FpCodeFmsSingle;
          break;

        case FPNMA_PATTERN:
          Operation = _FpCodeFnmaSingle;
          break;

        default:
          /* unrecognized instruction type */
          fprintf (stderr, "IEEE Filter Internal Error: \
              SIMD instruction opcode %8x %8x not recognized\n", 
              (int)(OpCode >> 32) & 0xffffffff, (int)OpCode & 0xffffffff);
          exit (1);

      }

      if (eXceptionCode == STATUS_FLOAT_MULTIPLE_FAULTS) {

        // hand the half (halves) that caused an enabled fault to the 
        // user handler; re-execute the other half (if any);
        // combine the results

        // Note that the convention chosen is for the processing to be 
        // performed in the order low first, high second, as SIMD operands
        // are stored in this order in memory in the little endian format 
        // (this order would have to be changed for big endian)

        if (LowCause.InvalidOperation || LowCauseDenormal) {

          // invoke the user handler and check the return value

          // fill in the remaining fields of the _FPIEEE_RECORD (rounding
          // and precision already filled in)

          FpieeeRecord.Operand1.Format = _FpFormatFp82; /* 1 + 8 + 24 bits */
          FpieeeRecord.Operand1.OperandValid = 1;
          FpieeeRecord.Operand1.Value.Fp128Value = FP32ToFP128 (LowHalf(FR3));
          FpieeeRecord.Operand2.Format = _FpFormatFp82; /* 1 + 8 + 24 bits */
          FpieeeRecord.Operand2.OperandValid = 1;
          FpieeeRecord.Operand2.Value.Fp128Value = FP32ToFP128 (LowHalf(FR4));
          FpieeeRecord.Operand3.Format = _FpFormatFp82; /* 1 + 8 + 24 bits */
          FpieeeRecord.Operand3.OperandValid = 1;
          FpieeeRecord.Operand3.Value.Fp128Value = FP32ToFP128 (LowHalf(FR2));

          FpieeeRecord.Result.Format = _FpFormatFp32; /* 1 + 8 + 24 bits */
          FpieeeRecord.Result.OperandValid = 0;

          FpieeeRecord.Operation = Operation;

          FpieeeRecord.Status.InvalidOperation = LowStatus.InvalidOperation;
          StatusDenormal = LowStatusDenormal;
          FpieeeRecord.Status.ZeroDivide = LowStatus.ZeroDivide;
          FpieeeRecord.Status.Overflow = LowStatus.Overflow;
          FpieeeRecord.Status.Underflow = LowStatus.Underflow;
          FpieeeRecord.Status.Inexact = LowStatus.Inexact;

          FpieeeRecord.Cause.InvalidOperation = LowCause.InvalidOperation;
          CauseDenormal = LowCauseDenormal;
          FpieeeRecord.Cause.ZeroDivide = LowCause.ZeroDivide; // 0
          FpieeeRecord.Cause.Overflow = LowCause.Overflow;
          FpieeeRecord.Cause.Underflow = LowCause.Underflow;
          FpieeeRecord.Cause.Inexact = LowCause.Inexact;

          // invoke the user-defined exception handler
          handler_return_value = handler (&FpieeeRecord);

          // return if not EXCEPTION_CONTINUE_EXECUTION
          if (handler_return_value != EXCEPTION_CONTINUE_EXECUTION) {

            __set_fpsr (&old_fpsr); /* restore caller fpsr */
            return (handler_return_value);

          }

          // clear the IEEE exception flags in the FPSR and
          // update the FPSR with values (possibly) set by the user handler
          // for the rounding mode, the precision mode, and the trap enable
          // bits; if the high half needs to be re-executed, the new FPSR
          // will be used, with status flags cleared; if it is 
          // forwarded to the user-defined handler, the new rounding and 
          // precision modes are also used (they are
          // already set in FpieeeRecord)

          UpdateRoundingMode (FpieeeRecord.RoundingMode, sf, &FPSR, "F1");
          UpdatePrecision (FpieeeRecord.Precision, sf, &FPSR, "F1");

          // Update the trap disable bits
          I_dis = !FpieeeRecord.Enable.Inexact;
          U_dis = !FpieeeRecord.Enable.Underflow;
          O_dis = !FpieeeRecord.Enable.Overflow;
          Z_dis = !FpieeeRecord.Enable.ZeroDivide;
          V_dis = !FpieeeRecord.Enable.InvalidOperation;
          // Note that D_dis cannot be updated by the IEEE user handler

          FPSR = FPSR & ~((unsigned __int64)0x03d) | (unsigned __int64)(I_dis
              << 5 | U_dis << 4 | O_dis << 3 | Z_dis << 2 | V_dis);

          // save the result for the low half
          FR1Low = FpieeeRecord.Result.Value.Fp32Value;

          // since there has been a call to the user handler and FPSR might
          // have changed (the Enable bits in particular), recalculate the 
          // Cause bits (if the HighEnable-s changed, there might be a 
          // change in the HighCause values) 
          // Note that the Status bits used are the original ones

          HighCause.InvalidOperation = FpieeeRecord.Enable.InvalidOperation &&
              HighStatus.InvalidOperation;
          HighCauseDenormal = EnableDenormal && HighStatusDenormal;
          HighCause.ZeroDivide =
              FpieeeRecord.Enable.ZeroDivide && HighStatus.ZeroDivide; // 0
          HighCause.Overflow = 0;
          HighCause.Underflow = 0;
          HighCause.Inexact = 0;

        } else { // if not (LowCause.InvalidOperation || LowCauseDenormal)

          // re-execute the low half of the instruction

          // modify the high halves of FR2, FR3, FR4
          newFR2 = Combine ((float)0.0, LowHalf (FR2));
          newFR3 = Combine ((float)0.0, LowHalf (FR3));
          newFR4 = Combine ((float)0.0, LowHalf (FR4));

#ifdef FPIEEE_FLT_DEBUG
        printf ("FPIEEE_FLT_DEBUG: WILL re-execute the low half\n");
        printf ("FPIEEE_FLT_DEBUG: usr_fpsr = %8x %8x\n",
            (int)(usr_fpsr >> 32) & 0xffffffff, (int)usr_fpsr & 0xffffffff);
        printf ("FPIEEE_FLT_DEBUG: newFR2 = %08x %08x %08x %08x\n",
            newFR2.W[3], newFR2.W[2], newFR2.W[1], newFR2.W[0]);
        printf ("FPIEEE_FLT_DEBUG: newFR3 = %08x %08x %08x %08x\n",
            newFR3.W[3], newFR3.W[2], newFR3.W[1], newFR3.W[0]);
        printf ("FPIEEE_FLT_DEBUG: newFR4 = %08x %08x %08x %08x\n",
            newFR4.W[3], newFR4.W[2], newFR4.W[1], newFR4.W[0]);
#endif

          switch (OpCode & F1_MASK) {

            case FPMA_PATTERN:
#ifdef FPIEEE_FLT_DEBUG
              printf ("FPIEEE_FLT_DEBUG: re-execute low half FPMA\n");
#endif
              _xrun3args (FPMA, &FPSR, &FR1, &newFR3, &newFR4, &newFR2);
#ifdef FPIEEE_FLT_DEBUG
              printf ("FPIEEE_FLT_DEBUG: FR1 AFT = %08x %08x %08x %08x\n",
                  FR1.W[3], FR1.W[2], FR1.W[1], FR1.W[0]);
#endif
              break;

            case FPMS_PATTERN:
#ifdef FPIEEE_FLT_DEBUG
            printf ("FPIEEE_FLT_DEBUG: re-execute low half FPMS\n");
#endif
            _xrun3args (FPMS, &FPSR, &FR1, &newFR3, &newFR4, &newFR2);
#ifdef FPIEEE_FLT_DEBUG
            printf ("FPIEEE_FLT_DEBUG: FR1 AFT = %08x %08x %08x %08x\n",
                FR1.W[3], FR1.W[2], FR1.W[1], FR1.W[0]);
#endif
              break;

            case FPNMA_PATTERN:
#ifdef FPIEEE_FLT_DEBUG
            printf ("FPIEEE_FLT_DEBUG: re-execute low half FPNMA\n");
#endif
            _xrun3args (FPNMA, &FPSR, &FR1, &newFR3, &newFR4, &newFR2);
#ifdef FPIEEE_FLT_DEBUG
            printf ("FPIEEE_FLT_DEBUG: FR1 AFT = %08x %08x %08x %08x\n",
                FR1.W[3], FR1.W[2], FR1.W[1], FR1.W[0]);
#endif
              break;

            default:
              // unrecognized instruction type
              fprintf (stderr, "IEEE Filter Internal Error: \
                  SIMD instruction opcode %8x %8x not recognized\n", 
                  (int)(OpCode >> 32) & 0xffffffff, (int)OpCode & 0xffffffff);
              exit (1);

          }

          FR1Low = LowHalf (FR1);

        } // end 'if not (LowCause.InvalidOperation || LowCauseDenormal)'

        if (HighCause.InvalidOperation || HighCauseDenormal) {

          // invoke the user-defined exception handler and check the return 
          // value; since this might be the second call to the user handler,
          // make sure all the _FPIEEE_RECORD fields are correct;
          // return if handler_return_value is not
          // EXCEPTION_CONTINUE_EXECUTION, otherwise combine the results

          // the rounding mode is either the initial one, or the one
          // set during the call to the user handler for the low half,
          // if there has been an enabled exception for it

          // the precision mode is either the initial one, or the one
          // set during the call to the user handler for the low half,
          // if there has been an enabled exception for it

          // the enable flags are either the initial ones, or the ones
          // set during the call to the user handler for the low half,
          // if there has been an enabled exception for it

          FpieeeRecord.Operand1.Format = _FpFormatFp82; /* 1+8+24 bits */
          FpieeeRecord.Operand1.OperandValid = 1;
          // operands have always _FpFormatFp82 and use Fp128Value
          FpieeeRecord.Operand1.Value.Fp128Value = FP32ToFP128(HighHalf(FR3));
          FpieeeRecord.Operand2.Format = _FpFormatFp82; /* 1+8+24 bits */
          FpieeeRecord.Operand2.OperandValid = 1;
          // operands have always _FpFormatFp82 and use Fp128Value
          FpieeeRecord.Operand2.Value.Fp128Value = FP32ToFP128(HighHalf(FR4));
          FpieeeRecord.Operand3.Format = _FpFormatFp82; /* 1+8+24 bits */
          FpieeeRecord.Operand3.OperandValid = 1;
          // operands have always _FpFormatFp82 and use Fp128Value
          FpieeeRecord.Operand3.Value.Fp128Value = FP32ToFP128(HighHalf(FR2));
          FpieeeRecord.Result.Format = _FpFormatFp32; /* 1 + 8 + 24 bits */
          FpieeeRecord.Result.OperandValid = 0;

          FpieeeRecord.Operation = Operation;

          FpieeeRecord.Status.InvalidOperation = HighStatus.InvalidOperation;
          StatusDenormal = HighStatusDenormal;
          FpieeeRecord.Status.ZeroDivide = HighStatus.ZeroDivide;
          FpieeeRecord.Status.Overflow = HighStatus.Overflow;
          FpieeeRecord.Status.Underflow = HighStatus.Underflow;
          FpieeeRecord.Status.Inexact = HighStatus.Inexact;

          FpieeeRecord.Cause.InvalidOperation = HighCause.InvalidOperation;
          CauseDenormal = HighCauseDenormal;
          FpieeeRecord.Cause.ZeroDivide = HighCause.ZeroDivide; // 0
          FpieeeRecord.Cause.Overflow = HighCause.Overflow;
          FpieeeRecord.Cause.Underflow = HighCause.Underflow;
          FpieeeRecord.Cause.Inexact = HighCause.Inexact;

          // invoke the user-defined exception handler
          handler_return_value = handler (&FpieeeRecord);

          // return if not EXCEPTION_CONTINUE_EXECUTION
          if (handler_return_value != EXCEPTION_CONTINUE_EXECUTION) {

            __set_fpsr (&old_fpsr); /* restore caller fpsr */
            return (handler_return_value);

          }

          // clear the IEEE exception flags in the FPSR and
          // update the FPSR with values (possibly) set by the user handler
          // for the rounding mode, the precision mode, and the trap enable
          // bits; if the high half needs to be re-executed, the new FPSR
          // will be used, with status flags cleared; if it is
          // forwarded to the user-defined handler, the new rounding and
          // precision modes are also used (they are
          // already set in FpieeeRecord)

          /* change the FPSR with values (possibly) set by the user handler,
           * for continuing execution where the interruption occured */
  
          UpdateRoundingMode (FpieeeRecord.RoundingMode, sf, &FPSR, "F1");
          UpdatePrecision (FpieeeRecord.Precision, sf, &FPSR, "F1");
  
          V_dis = !FpieeeRecord.Enable.InvalidOperation;
          Z_dis = !FpieeeRecord.Enable.ZeroDivide;
          O_dis = !FpieeeRecord.Enable.Overflow;
          U_dis = !FpieeeRecord.Enable.Underflow;
          I_dis = !FpieeeRecord.Enable.Inexact;
          // Note that D_dis cannot be updated by the IEEE user handler

          FPSR = FPSR & ~((unsigned __int64)0x03d) | (unsigned __int64)(I_dis
              << 5 | U_dis << 4 | O_dis << 3 | Z_dis << 2 | V_dis);

          // save the result for the high half
          FR1High = FpieeeRecord.Result.Value.Fp32Value;

        } else { //if not (HighCause.InvalidOperation || HighCauseDenormal)

          // re-execute the high half of the instruction

          // modify the low halves of FR2, FR3, FR4
          newFR2 = Combine (HighHalf (FR2), (float)0.0);
          newFR3 = Combine (HighHalf (FR3), (float)0.0);
          newFR4 = Combine (HighHalf (FR4), (float)0.0);

#ifdef FPIEEE_FLT_DEBUG
        printf ("FPIEEE_FLT_DEBUG: WILL re-execute the high half\n");
        printf ("FPIEEE_FLT_DEBUG: usr_fpsr = %8x %8x\n",
            (int)(usr_fpsr >> 32) & 0xffffffff, (int)usr_fpsr & 0xffffffff);
        printf ("FPIEEE_FLT_DEBUG: newFR2 = %08x %08x %08x %08x\n",
            newFR2.W[3], newFR2.W[2], newFR2.W[1], newFR2.W[0]);
        printf ("FPIEEE_FLT_DEBUG: newFR3 = %08x %08x %08x %08x\n",
            newFR3.W[3], newFR3.W[2], newFR3.W[1], newFR3.W[0]);
        printf ("FPIEEE_FLT_DEBUG: newFR4 = %08x %08x %08x %08x\n",
            newFR4.W[3], newFR4.W[2], newFR4.W[1], newFR4.W[0]);
        printf ("FPIEEE_FLT_DEBUG: FR1 BEF = %08x %08x %08x %08x\n",
            FR1.W[3], FR1.W[2], FR1.W[1], FR1.W[0]);
#endif

          switch (OpCode & F1_MASK) {

            case FPMA_PATTERN:
              _xrun3args (FPMA, &FPSR, &FR1, &newFR3, &newFR4, &newFR2);
              break;

            case FPMS_PATTERN:
              _xrun3args (FPMS, &FPSR, &FR1, &newFR3, &newFR4, &newFR2);
              break;

            case FPNMA_PATTERN:
              _xrun3args (FPNMA, &FPSR, &FR1, &newFR3, &newFR4, &newFR2);
              break;

            default:
              // unrecognized instruction type 
              fprintf (stderr, "IEEE Filter Internal Error: \
                  SIMD instruction opcode %8x %8x not recognized\n", 
                  (int)(OpCode >> 32) & 0xffffffff, (int)OpCode & 0xffffffff);
              exit (1);

          }

          FR1High = HighHalf (FR1);

        } // end 'if not (HighCause.InvalidOperation || HighCauseDenormal)'

        if (!LowCause.InvalidOperation && !HighCause.InvalidOperation &&
            !LowCauseDenormal && !HighCauseDenormal) {

          // should never get here
          fprintf (stderr, "IEEE Filter Internal Error: no enabled \
              exception (multiple fault) recognized in F1 instruction\n");
          exit (1);

        }

        // set the result
        Context->StFPSR = FPSR;

        // set the result before continuing execution
        FR1 = Combine (FR1High, FR1Low);
        SetFloatRegisterValue (f1, FR1, Context);
        if (f1 < 32)
          Context->StIPSR = Context->StIPSR | (unsigned __int64)0x10; //set mfl
        else
          Context->StIPSR = Context->StIPSR | (unsigned __int64)0x20; //set mfh

        // this is a fault; need to advance the instruction pointer
        if (ei == 0) { // no template for this case
          Context->StIPSR = Context->StIPSR & 0xfffff9ffffffffff;
          Context->StIPSR = Context->StIPSR | 0x0000020000000000;
        } else if (ei == 1) { // templates: MFI, MFB
          Context->StIPSR = Context->StIPSR & 0xfffff9ffffffffff;
          Context->StIPSR = Context->StIPSR | 0x0000040000000000;
        } else { // if (ei == 2) // templates: MMF
          Context->StIPSR = Context->StIPSR & 0xfffff9ffffffffff;
          Context->StIIP = Context->StIIP + 0x10;
        }

      } else if (eXceptionCode == STATUS_FLOAT_MULTIPLE_TRAPS) {

        // Note that the convention chosen is for the processing to be 
        // performed in the order low first, high second, as SIMD operands
        // are stored in this order in memory in the little endian format
        // (this order would have to be changed for big endian); unlike
        // in the case of multiple faults, where execution of the user
        // exception handler for the low half could determine changes in
        // the high half, for traps in the high half, the rounding mode, 
        // precision mode, and trap enable bits are the initial ones (as
        // there is not enough information available to always adjust
        // correctly the result and/or the status flags after changes in
        // rounding mode and/or trap enable bits during a call to the
        // user-defined exception handler for the low half of the SIMD
        // instruction); the modifications to the FPSR are ONLY those 
        // performed by the last call to the user defined exception handler

        // this is a trap - get the result
        FR1 = GetFloatRegisterValue (f1, Context);

        if (LowCause.Underflow || LowCause.Overflow || LowCause.Inexact) {

          // invoke the user handler and check the return value

          // fill in the remaining fields of the _FPIEEE_RECORD (rounding
          // and precision already filled in)

          FpieeeRecord.Operand1.Format = _FpFormatFp82; /* 1 + 8 + 24 bits */
          FpieeeRecord.Operand1.OperandValid = 1;
          FpieeeRecord.Operand1.Value.Fp128Value = FP32ToFP128 (LowHalf(FR3));
          FpieeeRecord.Operand2.Format = _FpFormatFp82; /* 1 + 8 + 24 bits */
          FpieeeRecord.Operand2.OperandValid = 1;
          FpieeeRecord.Operand2.Value.Fp128Value = FP32ToFP128 (LowHalf(FR4));
          FpieeeRecord.Operand3.Format = _FpFormatFp82; /* 1 + 8 + 24 bits */
          FpieeeRecord.Operand3.OperandValid = 1;
          FpieeeRecord.Operand3.Value.Fp128Value = FP32ToFP128 (LowHalf(FR2));

          FpieeeRecord.Result.Format = _FpFormatFp32; /* 1 + 8 + 24 bits */
          FpieeeRecord.Result.OperandValid = 1;
          if (LowCause.Underflow) FpieeeRecord.Result.Value.Fp128Value = 
                FP32ToFP128modif (LowHalf (FR1), -0x80);
          else if (LowCause.Overflow) FpieeeRecord.Result.Value.Fp128Value = 
                FP32ToFP128modif (LowHalf (FR1), 0x80);
          else if (LowCause.Inexact) FpieeeRecord.Result.Value.Fp128Value = 
                FP32ToFP128modif (LowHalf (FR1), 0x0);

          FpieeeRecord.Operation = Operation;

          FpieeeRecord.Status.InvalidOperation = LowStatus.InvalidOperation;
          FpieeeRecord.Status.ZeroDivide = LowStatus.ZeroDivide;
          StatusDenormal = LowStatusDenormal;
          FpieeeRecord.Status.Overflow = LowStatus.Overflow;
          FpieeeRecord.Status.Underflow = LowStatus.Underflow;
          FpieeeRecord.Status.Inexact = LowStatus.Inexact;

          FpieeeRecord.Cause.InvalidOperation = LowCause.InvalidOperation;
          FpieeeRecord.Cause.ZeroDivide = LowCause.ZeroDivide; // 0
          CauseDenormal = LowCauseDenormal;
          FpieeeRecord.Cause.Overflow = LowCause.Overflow;
          FpieeeRecord.Cause.Underflow = LowCause.Underflow;
          FpieeeRecord.Cause.Inexact = LowCause.Inexact;

          // before calling the user handler, adjust the result to the
          // range imposed by the format
          if (LowCause.Overflow) {

            FP128ToFPIeee (&FpieeeRecord, -1); // -1 indicates scaling direction

          } else if (LowCause.Underflow) {

            FP128ToFPIeee (&FpieeeRecord, +1); // +1 indicates scaling direction

          } else { // if (LowCause.Inexact) { // }

            FP128ToFPIeee (&FpieeeRecord, 0); // 0 indicates no scaling

          }

          // invoke the user-defined exception handler
          handler_return_value = handler (&FpieeeRecord);

          // return if not EXCEPTION_CONTINUE_EXECUTION
          if (handler_return_value != EXCEPTION_CONTINUE_EXECUTION) {

            __set_fpsr (&old_fpsr); /* restore caller fpsr */
            return (handler_return_value);

          }

          // clear the IEEE exception flags in the FPSR and
          // update the FPSR with values (possibly) set by the user handler
          // for the rounding mode, the precision mode, and the trap enable
          // bits; if the high half needs to be re-executed, the old FPSR
          // will be used; same if it is forwarded to the user-defined handler

          UpdateRoundingMode (FpieeeRecord.RoundingMode, sf, &FPSR, "F1");
          UpdatePrecision (FpieeeRecord.Precision, sf, &FPSR, "F1");

          // Update the trap disable bits
          V_dis = !FpieeeRecord.Enable.InvalidOperation;
          Z_dis = !FpieeeRecord.Enable.ZeroDivide;
          O_dis = !FpieeeRecord.Enable.Overflow;
          U_dis = !FpieeeRecord.Enable.Underflow;
          I_dis = !FpieeeRecord.Enable.Inexact;
          // Note that D_dis cannot be updated by the IEEE user handler

          FPSR = FPSR & ~((unsigned __int64)0x03d) | (unsigned __int64)(I_dis
              << 5 | U_dis << 4 | O_dis << 3 | Z_dis << 2 | V_dis);

          // save the result for the low half
          FR1Low = FpieeeRecord.Result.Value.Fp32Value;

        } else { 
          // if not (LowCause.Underflow || LowCause.Overflow || 
          //    LowCause.Inexact)

          // nothing to do for the low half of the instruction - the result
          // is correct

          FR1Low = LowHalf (FR1); // for uniformity

        } // end 'if not (LowCause.Underflow,  Overflow, or Inexact)'


        if (HighCause.Underflow || HighCause.Overflow || HighCause.Inexact) {

          // invoke the user-defined exception handler and check the return 
          // value; since this might be the second call to the user handler,
          // make sure all the _FPIEEE_RECORD fields are correct;
          // return if handler_return_value is not 
          // EXCEPTION_CONTINUE_EXECUTION, otherwise combine the results

          // the rounding mode is the initial one
          FpieeeRecord.RoundingMode = RoundingMode;

          // the precision mode is the initial one
          FpieeeRecord.Precision = Precision;

          // the enable flags are the initial ones
          FPSR = Context->StFPSR;
          V_dis = sf != 0 && ((FPSR >> (6 + 6 + 13 * sf)) & 0x01) 
              || ((FPSR >> 0) & 0x01);
          D_dis = sf != 0 && ((FPSR >> (6 + 6 + 13 * sf)) & 0x01) 
              || ((FPSR >> 1) & 0x01);
          Z_dis = sf != 0 && ((FPSR >> (6 + 6 + 13 * sf)) & 0x01) 
              || ((FPSR >> 2) & 0x01);
          O_dis = sf != 0 && ((FPSR >> (6 + 6 + 13 * sf)) & 0x01) 
              || ((FPSR >> 3) & 0x01);
          U_dis = sf != 0 && ((FPSR >> (6 + 6 + 13 * sf)) & 0x01) 
              || ((FPSR >> 4) & 0x01);
          I_dis = sf != 0 && ((FPSR >> (6 + 6 + 13 * sf)) & 0x01) 
              || ((FPSR >> 5) & 0x01);

          FpieeeRecord.Enable.InvalidOperation = !V_dis;
          EnableDenormal = !D_dis;
          FpieeeRecord.Enable.ZeroDivide = !Z_dis;
          FpieeeRecord.Enable.Overflow = !O_dis;
          FpieeeRecord.Enable.Underflow = !U_dis;
          FpieeeRecord.Enable.Inexact = !I_dis;

          FpieeeRecord.Operand1.Format = _FpFormatFp82; /* 1+8+24 bits */
          FpieeeRecord.Operand1.OperandValid = 1;
          FpieeeRecord.Operand1.Value.Fp128Value = FP32ToFP128(HighHalf(FR3));
          FpieeeRecord.Operand2.Format = _FpFormatFp82; /* 1+8+24 bits */
          FpieeeRecord.Operand2.OperandValid = 1;
          FpieeeRecord.Operand2.Value.Fp128Value = FP32ToFP128(HighHalf(FR4));
          FpieeeRecord.Operand3.Format = _FpFormatFp82; /* 1+8+24 bits */
          FpieeeRecord.Operand3.OperandValid = 1;
          FpieeeRecord.Operand3.Value.Fp128Value = FP32ToFP128(HighHalf(FR2));

          FpieeeRecord.Result.Format = _FpFormatFp32; /* 1 + 8 + 24 bits */
          FpieeeRecord.Result.OperandValid = 1;
          if (HighCause.Underflow) FpieeeRecord.Result.Value.Fp128Value = 
                FP32ToFP128modif (HighHalf (FR1), -0x80);
          else if (HighCause.Overflow) FpieeeRecord.Result.Value.Fp128Value = 
                FP32ToFP128modif (HighHalf (FR1), 0x80);
          else if (HighCause.Inexact) FpieeeRecord.Result.Value.Fp128Value = 
                FP32ToFP128modif (HighHalf (FR1), 0x0);

          FpieeeRecord.Operation = Operation;

          // use the initial values
          FpieeeRecord.Status.InvalidOperation = HighStatus.InvalidOperation;
          FpieeeRecord.Status.ZeroDivide = HighStatus.ZeroDivide;
          FpieeeRecord.Status.Overflow = HighStatus.Overflow;
          FpieeeRecord.Status.Underflow = HighStatus.Underflow;
          FpieeeRecord.Status.Inexact = HighStatus.Inexact;

          FpieeeRecord.Cause.InvalidOperation = HighCause.InvalidOperation;
          FpieeeRecord.Cause.ZeroDivide = HighCause.ZeroDivide; // 0
          FpieeeRecord.Cause.Overflow = HighCause.Overflow;
          FpieeeRecord.Cause.Underflow = HighCause.Underflow;
          FpieeeRecord.Cause.Inexact = HighCause.Inexact;

          // before calling the user handler, adjust the result to the
          // range imposed by the format
          if (HighCause.Overflow) {

            FP128ToFPIeee (&FpieeeRecord, -1); // -1 indicates scaling direction

          } else if (HighCause.Underflow) {

            FP128ToFPIeee (&FpieeeRecord, +1); // +1 indicates scaling direction

          } else { // if (HighCause.Inexact) { // }

            FP128ToFPIeee (&FpieeeRecord, 0); // 0 indicates no scaling

          }

          // invoke the user-defined exception handler
          handler_return_value = handler (&FpieeeRecord);

          // return if not EXCEPTION_CONTINUE_EXECUTION
          if (handler_return_value != EXCEPTION_CONTINUE_EXECUTION) {

            __set_fpsr (&old_fpsr); /* restore caller fpsr */
            return (handler_return_value);

          }

          // update the FPSR with values (possibly) set by the user handler
          // for the rounding mode, the precision mode, and the trap enable
          // bits; if the high half needs to be re-executed, the old FPSR
          // will be used; same if it is forwarded to the user-defined handler

          /* change the FPSR with values (possibly) set by the user handler,
           * for continuing execution where the interruption occured */
  
          UpdateRoundingMode (FpieeeRecord.RoundingMode, sf, &FPSR, "F1");
          UpdatePrecision (FpieeeRecord.Precision, sf, &FPSR, "F1");
  
          I_dis = !FpieeeRecord.Enable.Inexact;
          U_dis = !FpieeeRecord.Enable.Underflow;
          O_dis = !FpieeeRecord.Enable.Overflow;
          Z_dis = !FpieeeRecord.Enable.ZeroDivide;
          V_dis = !FpieeeRecord.Enable.InvalidOperation;
          // Note that D_dis cannot be updated by the IEEE user handler

          FPSR = FPSR & ~((unsigned __int64)0x03d) | (unsigned __int64)(I_dis
              << 5 | U_dis << 4 | O_dis << 3 | Z_dis << 2 | V_dis);

          // save the result for the high half
          FR1High = FpieeeRecord.Result.Value.Fp32Value;

        } else { 
          // if not (HighCause.Underflow, Overflow, or Inexact)

          // nothing to do for the high half of the instruction - the result
          // is correct

          FR1High = HighHalf (FR1); // for uniformity

        } // end 'if not (HighCause.Underflow, Overflow, or Inexact)'

        if (!LowCause.Underflow && !LowCause.Overflow && !LowCause.Inexact &&
            !HighCause.Underflow && !HighCause.Overflow && 
            !HighCause.Inexact) {

          // should never get here
          fprintf (stderr, "IEEE Filter Internal Error: no enabled \
              [multiple trap] exception recognized in F1 instruction\n");
          exit (1);

        }

        // set the result
        Context->StFPSR = FPSR;

        // set the result before continuing execution
        FR1 = Combine (FR1High, FR1Low);
        SetFloatRegisterValue (f1, FR1, Context);
        if (f1 < 32)
          Context->StIPSR = Context->StIPSR | (unsigned __int64)0x10; //set mfl
        else
          Context->StIPSR = Context->StIPSR | (unsigned __int64)0x20; //set mfh

      } // else { ; } // this case was caught above

    }

  } else if ((OpCode & F4_MIN_MASK) == F4_PATTERN) {
    /* F4 instruction, always non-SIMD */
    // FCMP

#ifdef FPIEEE_FLT_DEBUG
    printf ("FPIEEE_FLT_DEBUG: F4 instruction\n");
#endif

    if (FpieeeRecord.Cause.ZeroDivide ||
        FpieeeRecord.Cause.Overflow ||
        FpieeeRecord.Cause.Underflow ||
        FpieeeRecord.Cause.Inexact) {
      fprintf (stderr, "IEEE Filter Internal Error: Cause.ZeroDivide, \
Cause.Overflow, Cause.Underflow, or Cause.Inexact for \
F4 instruction opcode %8x %8x\n",
          (int)(OpCode >> 32) & 0xffffffff, (int)OpCode & 0xffffffff);
      exit (1);
    }

    /* ignore the EM computation model */

    /* extract p1, p2, f2, and f3 */
    p1 = (unsigned int)((OpCode >>  6) & (unsigned __int64)0x00000000003F);
    if (p1 >= 16) p1 = 16 + (rrbpr + p1 - 16) % 48;
    p2 = (unsigned int)((OpCode >> 27) & (unsigned __int64)0x00000000003f);
    if (p2 >= 16) p2 = 16 + (rrbpr + p2 - 16) % 48;
    f2 = (unsigned int)((OpCode >> 13) & (unsigned __int64)0x00000000007F);
    if (f2 >= 32) f2 = 32 + (rrbfr + f2 - 32) % 96;
    f3 = (unsigned int)((OpCode >> 20) & (unsigned __int64)0x00000000007F);
    if (f3 >= 32) f3 = 32 + (rrbfr + f3 - 32) % 96;

    /* get source floating-point register values */
    FR2 = GetFloatRegisterValue (f2, Context);
    FR3 = GetFloatRegisterValue (f3, Context);

    if (FpieeeRecord.Cause.InvalidOperation || CauseDenormal) {

      // *** this is a non-SIMD instruction ***

      FpieeeRecord.Operand1.Format = _FpFormatFp82; /* 1 + 17 + 64 bits */
      FpieeeRecord.Operand1.OperandValid = 1;
      FpieeeRecord.Operand1.Value.Fp128Value = FR2;
      FpieeeRecord.Operand2.Format = _FpFormatFp82; /* 1 + 17 + 64 bits */
      FpieeeRecord.Operand2.OperandValid = 1;
      FpieeeRecord.Operand2.Value.Fp128Value = FR3;
      FpieeeRecord.Operand3.OperandValid = 0;

      switch (OpCode & F4_MASK) {

        case FCMP_EQ_PATTERN:
        case FCMP_LT_PATTERN:
        case FCMP_LE_PATTERN:
        case FCMP_UNORD_PATTERN:
        case FCMP_EQ_UNC_PATTERN:
        case FCMP_LT_UNC_PATTERN:
        case FCMP_LE_UNC_PATTERN:
        case FCMP_UNORD_UNC_PATTERN:
          FpieeeRecord.Operation = _FpCodeCompare;
          FpieeeRecord.Result.Format = _FpFormatCompare;
          break;
  
        default:
          /* unrecognized instruction type */
          fprintf (stderr, "IEEE Filter Internal Error: \
              instruction opcode %8x %8x not recognized\n", 
              (int)(OpCode >> 32) & 0xffffffff, (int)OpCode & 0xffffffff);
          exit (1);

      }

      /* this is a fault - the result contains an invalid value */
      FpieeeRecord.Result.OperandValid = 0;

      handler_return_value = handler (&FpieeeRecord);

      if (handler_return_value == EXCEPTION_CONTINUE_EXECUTION) {

        // set the values of the result predicates
        switch (OpCode & F4_MASK) {
    
          case FCMP_EQ_PATTERN:
          case FCMP_EQ_UNC_PATTERN:
    
            switch (FpieeeRecord.Result.Value.CompareValue) {

              case _FpCompareEqual:
                PR1 = 1;
                PR2 = 0;
                break;

              case _FpCompareGreater:
              case _FpCompareLess:
              case _FpCompareUnordered:
                PR1 = 0;
                PR2 = 1;
                break;

              default:
                /* unrecognized FpieeeRecord.Result.Value.CompareValue */
                fprintf (stderr, "IEEE Filter Internal Error: \
                    FpieeeRecord.Result.Value.CompareValue %x not recognized \
                    for F4 instruction\n", 
                    FpieeeRecord.Result.Value.CompareValue);
                exit (1);
    
            }
            break;
    
          case FCMP_LT_PATTERN:
          case FCMP_LT_UNC_PATTERN:
    
            switch (FpieeeRecord.Result.Value.CompareValue) {
    
              case _FpCompareLess:
                PR1 = 1;
                PR2 = 0;
                break;
    
              case _FpCompareEqual:
              case _FpCompareGreater:
              case _FpCompareUnordered:
                PR1 = 0;
                PR2 = 1;
                break;
    
              default:
                /* unrecognized FpieeeRecord.Result.Value.CompareValue */
                fprintf (stderr, "IEEE Filter Internal Error: \
                    FpieeeRecord.Result.Value.CompareValue %x not recognized \
                    for F4 instruction\n", 
                    FpieeeRecord.Result.Value.CompareValue);
                exit (1);
    
            }
    
            break;
    
          case FCMP_LE_PATTERN:
          case FCMP_LE_UNC_PATTERN:
    
            switch (FpieeeRecord.Result.Value.CompareValue) {
    
              case _FpCompareEqual:
              case _FpCompareLess:
                PR1 = 1;
                PR2 = 0;
                break;
    
              case _FpCompareGreater:
              case _FpCompareUnordered:
                PR1 = 0;
                PR2 = 1;
                break;
    
              default:
                /* unrecognized FpieeeRecord.Result.Value.CompareValue */
                fprintf (stderr, "IEEE Filter Internal Error: \
                    FpieeeRecord.Result.Value.CompareValue %x not recognized \
                    for F4 instruction\n", 
                    FpieeeRecord.Result.Value.CompareValue);
                exit (1);
    
            }
    
            break;
    
          case FCMP_UNORD_PATTERN:
          case FCMP_UNORD_UNC_PATTERN:
    
            switch (FpieeeRecord.Result.Value.CompareValue) {
    
              case _FpCompareUnordered:
                PR1 = 1;
                PR2 = 0;
                break;
    
              case _FpCompareEqual:
              case _FpCompareLess:
              case _FpCompareGreater:
                PR1 = 0;
                PR2 = 1;
                break;
    
              default:
                /* unrecognized FpieeeRecord.Result.Value.CompareValue */
                fprintf (stderr, "IEEE Filter Internal Error: \
                    FpieeeRecord.Result.Value.CompareValue %x not recognized \
                    for F4 instruction\n", 
                    FpieeeRecord.Result.Value.CompareValue);
                exit (1);
    
            }
    
            break;
    
          default:
            // never gets here - this case filtered above
            fprintf (stderr, "IEEE Filter Internal Error: \
                instruction opcode %8x %8x is not valid at this point\n", 
                (int)(OpCode >> 32) & 0xffffffff, (int)OpCode & 0xffffffff);
            exit (1);
    
        }

        /* change the FPSR with values (possibly) set by the user handler, 
         * for continuing execution where the interruption occured */

        UpdateRoundingMode (FpieeeRecord.RoundingMode, sf, &FPSR, "F4");
        UpdatePrecision (FpieeeRecord.Precision, sf, &FPSR, "F4");

        I_dis = !FpieeeRecord.Enable.Inexact;
        U_dis = !FpieeeRecord.Enable.Underflow;
        O_dis = !FpieeeRecord.Enable.Overflow;
        Z_dis = !FpieeeRecord.Enable.ZeroDivide;
        V_dis = !FpieeeRecord.Enable.InvalidOperation;
        // Note that D_dis cannot be updated by the IEEE user handler

        FPSR = FPSR & ~((unsigned __int64)0x03d) | (unsigned __int64)(I_dis 
            << 5 | U_dis << 4 | O_dis << 3 | Z_dis << 2 | V_dis);

        Context->StFPSR = FPSR;

        // set the destination predicate register values before 
        // continuing execution
        Context->Preds &= (~(((unsigned __int64)1) << p1));
        Context->Preds |= (((unsigned __int64)(PR1 & 0x01)) << p1);
        Context->Preds &= (~(((unsigned __int64)1) << p2));
        Context->Preds |= (((unsigned __int64)(PR2 & 0x01)) << p2);

        // this is a fault - need to advance the instruction pointer
        if (ei == 0) { // no template for this case
          Context->StIPSR = Context->StIPSR & 0xfffff9ffffffffff;
          Context->StIPSR = Context->StIPSR | 0x0000020000000000;
        } else if (ei == 1) { // templates: MFI, MFB
          Context->StIPSR = Context->StIPSR & 0xfffff9ffffffffff;
          Context->StIPSR = Context->StIPSR | 0x0000040000000000;
        } else { // if (ei == 2) // templates: MMF
          Context->StIPSR = Context->StIPSR & 0xfffff9ffffffffff;
          Context->StIIP = Context->StIIP + 0x10;
        }

      }

    } else {

      fprintf (stderr, "IEEE Filter Internal Error: \
          exception code %x invalid or not recognized in F4 instruction\n",
          eXceptionCode);
      exit (1);

    }

  } else if ((OpCode & F6_MIN_MASK) == F6_PATTERN) {
    /* F6 instruction */
    // FRCPA, FPRCPA

#ifdef FPIEEE_FLT_DEBUG
    printf ("FPIEEE_FLT_DEBUG: F6 instruction\n");
#endif

    /* Note: the IEEE filter should be reached for these instructions
     * only when the value of  FR[f2]/FR[f3] is expected */

    /* extract p2, f3, f2, and f1 */
    p2 = (unsigned int)((OpCode >> 27) & (unsigned __int64)0x00000000003f);
    if (p2 >= 16) p2 = 16 + (rrbpr + p2 - 16) % 48;
    f3 = (unsigned int)((OpCode >> 20) & (unsigned __int64)0x00000000007F);
    if (f3 >= 32) f3 = 32 + (rrbfr + f3 - 32) % 96;
    f2 = (unsigned int)((OpCode >> 13) & (unsigned __int64)0x00000000007F);
    if (f2 >= 32) f2 = 32 + (rrbfr + f2 - 32) % 96;
    f1 = (unsigned int)((OpCode >>  6) & (unsigned __int64)0x00000000007F);
    if (f1 >= 32) f1 = 32 + (rrbfr + f1 - 32) % 96;

#ifdef FPIEEE_FLT_DEBUG
    printf ("FPIEEE_FLT_DEBUG: f1 = %x\n", f1);
    printf ("FPIEEE_FLT_DEBUG: f2 = %x\n", f2);
    printf ("FPIEEE_FLT_DEBUG: f3 = %x\n", f3);
    printf ("FPIEEE_FLT_DEBUG: p2 = %x\n", p2);
#endif

    /* get source floating-point register values */
    FR2 = GetFloatRegisterValue (f2, Context);
    FR3 = GetFloatRegisterValue (f3, Context);

    if (!SIMD_instruction) {

      // *** this is a non-SIMD instruction, FRCPA ***

      FpieeeRecord.Operand1.Format = _FpFormatFp82; /* 1 + 17 + 64 bits */
      FpieeeRecord.Operand1.OperandValid = 1;
      FpieeeRecord.Operand1.Value.Fp128Value = FR2;
      FpieeeRecord.Operand2.Format = _FpFormatFp82; /* 1 + 17 + 64 bits */
      FpieeeRecord.Operand2.OperandValid = 1;
      FpieeeRecord.Operand2.Value.Fp128Value = FR3;
      FpieeeRecord.Operand3.OperandValid = 0;

      switch (OpCode & F6_MASK) {

        case FRCPA_PATTERN:
          FpieeeRecord.Operation = _FpCodeDivide;
          FpieeeRecord.Result.Format = _FpFormatFp82; /* 1 + 17 + 64 bits */
          break;

        default:
          /* unrecognized instruction type */
          fprintf (stderr, "IEEE Filter Internal Error: \
              instruction opcode %8x %8x not recognized for FRCPA\n", 
              (int)(OpCode >> 32) & 0xffffffff, (int)OpCode & 0xffffffff);
          exit (1);

      }

      if (FpieeeRecord.Cause.InvalidOperation || CauseDenormal ||
          FpieeeRecord.Cause.ZeroDivide) {

        /* this is a fault - the result contains an invalid value */
        FpieeeRecord.Result.OperandValid = 0;

      } else if (FpieeeRecord.Cause.Overflow ||
          FpieeeRecord.Cause.Underflow ||
          FpieeeRecord.Cause.Inexact) {

        // this is a trap - the result contains a valid value
        FpieeeRecord.Result.OperandValid = 1;
        // get the result
        FpieeeRecord.Result.Value.Fp128Value =
            GetFloatRegisterValue (f1, Context);
        if (FpieeeRecord.Cause.Overflow)
            FP128ToFPIeee (&FpieeeRecord, -1); // -1 indicates scaling direction
        if (FpieeeRecord.Cause.Underflow)
            FP128ToFPIeee (&FpieeeRecord, +1); // +1 indicates scaling direction

      } else {

        // should never get here - this case was filtered above
        fprintf (stderr, "IEEE Filter Internal Error: exception cause invalid \
            or not recognized in F6 instruction; ISRlow = %x\n", ISRlow);
         exit (1);

      }

      handler_return_value = handler (&FpieeeRecord);

      // convert the result to 82-bit format
      FR1 = FPIeeeToFP128 (&FpieeeRecord);
#ifdef FPIEEE_FLT_DEBUG
        printf ("FPIEEE_FLT_DEBUG 2: CONVERTED FR1 = %08x %08x %08x %08x\n",
            FR1.W[3], FR1.W[2], FR1.W[1], FR1.W[0]);
#endif

      if (handler_return_value == EXCEPTION_CONTINUE_EXECUTION) {

        // set the result predicate
        PR2 = 0;

        /* change the FPSR with values (possibly) set by the user handler, 
         * for continuing execution where the interruption occured */

        UpdateRoundingMode (FpieeeRecord.RoundingMode, sf, &FPSR, "F6");
        UpdatePrecision (FpieeeRecord.Precision, sf, &FPSR, "F6");

        I_dis = !FpieeeRecord.Enable.Inexact;
        U_dis = !FpieeeRecord.Enable.Underflow;
        O_dis = !FpieeeRecord.Enable.Overflow;
        Z_dis = !FpieeeRecord.Enable.ZeroDivide;
        V_dis = !FpieeeRecord.Enable.InvalidOperation;

        FPSR = FPSR & ~((unsigned __int64)0x03d) | (unsigned __int64)(I_dis 
            << 5 | U_dis << 4 | O_dis << 3 | Z_dis << 2 | V_dis);

        Context->StFPSR = FPSR;

        // set the result before continuing execution
#ifdef FPIEEE_FLT_DEBUG
        printf ("FPIEEE_FLT_DEBUG F6: WILL SetFloatRegisterValue f1 = 0x%x FR1 = %08x %08x %08x %08x\n",
            f1, FR1.W[3], FR1.W[2], FR1.W[1], FR1.W[0]);
#endif
        SetFloatRegisterValue (f1, FR1, Context);
        if (f1 < 32)
          Context->StIPSR = Context->StIPSR | (unsigned __int64)0x10; //set mfl bit
        else
          Context->StIPSR = Context->StIPSR | (unsigned __int64)0x20; //set mfh bit
        Context->Preds &= (~(((unsigned __int64)1) << p2));
        Context->Preds |= (((unsigned __int64)(PR2 & 0x01)) << p2);

      }

      // if this is a fault, need to advance the instruction pointer
      if (FpieeeRecord.Cause.InvalidOperation || CauseDenormal ||
          FpieeeRecord.Cause.ZeroDivide) {

        if (ei == 0) { // no template for this case
          Context->StIPSR = Context->StIPSR & 0xfffff9ffffffffff;
          Context->StIPSR = Context->StIPSR | 0x0000020000000000;
        } else if (ei == 1) { // templates: MFI, MFB
          Context->StIPSR = Context->StIPSR & 0xfffff9ffffffffff;
          Context->StIPSR = Context->StIPSR | 0x0000040000000000;
        } else { // if (ei == 2) // templates: MMF
          Context->StIPSR = Context->StIPSR & 0xfffff9ffffffffff;
          Context->StIIP = Context->StIIP + 0x10;
        }

      }

    } else { // if (SIMD_instruction)

      // *** this is a SIMD instruction, FPRCPA ***

      // the half (halves) of the instruction that caused an enabled exception, 
      // are presented to the user-defined handler in the form of non-SIMD in-
      // struction(s); the half (if any) that did not cause an enabled exception
      // (i.e. caused no exception, or caused an exception that is disabled),
      // is re-executed since it is associated with a fault in the other half;
      // the other half is padded to calculate 1.0 / 1.0, that will cause no 
      // exception

      switch (OpCode & F6_MASK) {

        case FPRCPA_PATTERN:
          Operation = _FpCodeDivide;
          break;

        default:
          /* unrecognized instruction type */
          fprintf (stderr, "IEEE Filter Internal Error: SIMD \
              instruction opcode %8x %8x not recognized as FPRCPA\n", 
              (int)(OpCode >> 32) & 0xffffffff, (int)OpCode & 0xffffffff);
          exit (1);

      }

      // hand the half (halves) that caused an enabled fault to the 
      // user handler; re-execute the other half (if any);
      // combine the results

      // Note that the convention chosen is for the processing to be 
      // performed in the order low first, high second, as SIMD operands
      // are stored in this order in memory in the little endian format 
      // (this order would have to be changed for big endian)

      if (LowCause.InvalidOperation || LowCauseDenormal ||
          LowCause.ZeroDivide) {

        // invoke the user handler and check the return value

        // fill in the remaining fields of the _FPIEEE_RECORD (rounding
        // and precision already filled in)

        FpieeeRecord.Operand1.Format = _FpFormatFp82; /* 1 + 8 + 24 bits */
        FpieeeRecord.Operand1.OperandValid = 1;
        FpieeeRecord.Operand1.Value.Fp128Value = FP32ToFP128 (LowHalf (FR2));
        FpieeeRecord.Operand2.Format = _FpFormatFp82; /* 1 + 8 + 24 bits */
        FpieeeRecord.Operand2.OperandValid = 1;
        FpieeeRecord.Operand2.Value.Fp128Value = FP32ToFP128 (LowHalf (FR3));
        FpieeeRecord.Operand3.OperandValid = 0;

        FpieeeRecord.Result.Format = _FpFormatFp32; /* 1 + 8 + 24 bits */
        FpieeeRecord.Result.OperandValid = 0;

        FpieeeRecord.Operation = Operation;

        FpieeeRecord.Status.Inexact = LowStatus.Inexact;
        FpieeeRecord.Status.Underflow = LowStatus.Underflow;
        FpieeeRecord.Status.Overflow = LowStatus.Overflow;
        StatusDenormal = LowStatusDenormal;
        FpieeeRecord.Status.ZeroDivide = LowStatus.ZeroDivide;
        FpieeeRecord.Status.InvalidOperation = LowStatus.InvalidOperation;

        FpieeeRecord.Cause.Inexact = LowCause.Inexact;
        FpieeeRecord.Cause.Underflow = LowCause.Underflow;
        FpieeeRecord.Cause.Overflow = LowCause.Overflow;
        CauseDenormal = LowCauseDenormal;
        FpieeeRecord.Cause.ZeroDivide = LowCause.ZeroDivide;
        FpieeeRecord.Cause.InvalidOperation = LowCause.InvalidOperation;

        // invoke the user-defined exception handler
        handler_return_value = handler (&FpieeeRecord);

        // return if not EXCEPTION_CONTINUE_EXECUTION
        if (handler_return_value != EXCEPTION_CONTINUE_EXECUTION) {

          __set_fpsr (&old_fpsr); /* restore caller fpsr */
          return (handler_return_value);

        }

        // clear the IEEE exception flags in the FPSR and
        // update the FPSR with values (possibly) set by the user handler
        // for the rounding mode, the precision mode, and the trap enable
        // bits; if the high half needs to be re-executed, the new FPSR
        // will be used, with status flags cleared; if it is 
        // forwarded to the user-defined handler, the new rounding and 
        // precision modes are also used (they are
        // already set in FpieeeRecord)

        UpdateRoundingMode (FpieeeRecord.RoundingMode, sf, &FPSR, "F6");
        UpdatePrecision (FpieeeRecord.Precision, sf, &FPSR, "F6");

        // Update the trap disable bits
        I_dis = !FpieeeRecord.Enable.Inexact;
        U_dis = !FpieeeRecord.Enable.Underflow;
        O_dis = !FpieeeRecord.Enable.Overflow;
        Z_dis = !FpieeeRecord.Enable.ZeroDivide;
        V_dis = !FpieeeRecord.Enable.InvalidOperation;

        FPSR = FPSR & ~((unsigned __int64)0x03d) | (unsigned __int64)(I_dis
            << 5 | U_dis << 4 | O_dis << 3 | Z_dis << 2 | V_dis);

        // save the result for the low half
        FR1Low = FpieeeRecord.Result.Value.Fp32Value;

        // since there has been a call to the user handler and the FPSR 
        // might have changed (the Enable bits in particular), recalculate
        // the Cause bits (if the HighEnable-s changed, there might be a 
        // change in the HighCause values) 
        // Note that the Status bits used are the original ones

        HighCause.Inexact = 0;
        HighCause.Underflow = 0;
        HighCause.Overflow = 0;
        HighCause.ZeroDivide =
            FpieeeRecord.Enable.ZeroDivide && HighStatus.ZeroDivide;
        HighCauseDenormal = EnableDenormal && HighStatusDenormal;
        HighCause.InvalidOperation =
            FpieeeRecord.Enable.InvalidOperation &&
            HighStatus.InvalidOperation;

      } else { // if not (LowCause.InvalidOperation || LowCauseDenormal ||
          // LowCause.ZeroDivide)

        // do not re-execute the low half of the instruction - it would only
        // return an approximation of 1 / (low FR3); calculate instead the 
        // quotient (low FR2) / (low FR3) in single precision, using the 
        // correct rounding mode (the low half of the instruction did not 
        // cause any exception)

        // extract the low halves of FR2 and FR3
        FR2Low = LowHalf (FR2);
        FR3Low = LowHalf (FR3);

        // employ the user FPSR when calling _thmB; note that
        // the exception masks are those set by the user, and that an
        // underflow, overflow, or inexact exception might be raised

        // perform the single precision divide
        _thmB (&FR2Low, &FR3Low, &FR1Low, &FPSR); // FR1Low = FR2Low / FR3Low

#ifdef FPIEEE_FLT_DEBUG
        printf ("FPIEEE_FLT_DEBUG: F6 low res _thmB = %f = %x\n",
            FR1Low, *(unsigned int *)&FR1Low);
#endif

      } // end 'if not (LowCause.InvalidOperation || LowCauseDenormal ||
          // LowCause.ZeroDivide)'

      if (HighCause.InvalidOperation || HighCauseDenormal ||
          HighCause.ZeroDivide) {

        // invoke the user-defined exception handler and check the return 
        // value; since this might be the second call to the user handler,
        // make sure all the _FPIEEE_RECORD fields are correct;
        // return if handler_return_value is not
        // EXCEPTION_CONTINUE_EXECUTION, otherwise combine the results

        // the rounding mode is either the initial one, or the one
        // set during the call to the user handler for the low half,
        // if there has been an enabled exception for it

        // the precision mode is either the initial one, or the one
        // set during the call to the user handler for the low half,
        // if there has been an enabled exception for it

        // the enable flags are either the initial ones, or the ones
        // set during the call to the user handler for the low half,
        // if there has been an enabled exception for it

        FpieeeRecord.Operand1.Format = _FpFormatFp82; /* 1+8+24 bits */
        FpieeeRecord.Operand1.OperandValid = 1;
        FpieeeRecord.Operand1.Value.Fp128Value = FP32ToFP128 (HighHalf (FR2));
        FpieeeRecord.Operand2.Format = _FpFormatFp82; /* 1+8+24 bits */
        FpieeeRecord.Operand2.OperandValid = 1;
        FpieeeRecord.Operand2.Value.Fp128Value = FP32ToFP128 (HighHalf (FR3));
        FpieeeRecord.Operand3.OperandValid = 0;

        FpieeeRecord.Result.Format = _FpFormatFp32; /* 1 + 8 + 24 bits */
        FpieeeRecord.Result.OperandValid = 0;

        FpieeeRecord.Operation = Operation;

        FpieeeRecord.Status.Inexact = HighStatus.Inexact;
        FpieeeRecord.Status.Underflow = HighStatus.Underflow;
        FpieeeRecord.Status.Overflow = HighStatus.Overflow;
        StatusDenormal = HighStatusDenormal;
        FpieeeRecord.Status.ZeroDivide = HighStatus.ZeroDivide;
        FpieeeRecord.Status.InvalidOperation = HighStatus.InvalidOperation;

        FpieeeRecord.Cause.Inexact = HighCause.Inexact;
        FpieeeRecord.Cause.Underflow = HighCause.Underflow;
        FpieeeRecord.Cause.Overflow = HighCause.Overflow;
        CauseDenormal = HighCauseDenormal;
        FpieeeRecord.Cause.ZeroDivide = HighCause.ZeroDivide;
        FpieeeRecord.Cause.InvalidOperation = HighCause.InvalidOperation;

        // invoke the user-defined exception handler
        handler_return_value = handler (&FpieeeRecord);

        // return if not EXCEPTION_CONTINUE_EXECUTION
        if (handler_return_value != EXCEPTION_CONTINUE_EXECUTION) {

          __set_fpsr (&old_fpsr); /* restore caller fpsr */
          return (handler_return_value);

        }

        // clear the IEEE exception flags in the FPSR and
        // update the FPSR with values (possibly) set by the user handler
        // for the rounding mode, the precision mode, and the trap enable
        // bits; if the high half needs to be re-executed, the new FPSR
        // will be used, with status flags cleared; if it is
        // forwarded to the user-defined handler, the new rounding and
        // precision modes are also used (they are
        // already set in FpieeeRecord)

        /* change the FPSR with values (possibly) set by the user handler,
         * for continuing execution where the interruption occured */

        UpdateRoundingMode (FpieeeRecord.RoundingMode, sf, &FPSR, "F6");
        UpdatePrecision (FpieeeRecord.Precision, sf, &FPSR, "F6");

        I_dis = !FpieeeRecord.Enable.Inexact;
        U_dis = !FpieeeRecord.Enable.Underflow;
        O_dis = !FpieeeRecord.Enable.Overflow;
        Z_dis = !FpieeeRecord.Enable.ZeroDivide;
        V_dis = !FpieeeRecord.Enable.InvalidOperation;

        FPSR = FPSR & ~((unsigned __int64)0x03d) | (unsigned __int64)(I_dis 
            << 5 | U_dis << 4 | O_dis << 3 | Z_dis << 2 | V_dis);

        // save the result for the high half
        FR1High = FpieeeRecord.Result.Value.Fp32Value;

      } else { //if not (HighCause.InvalidOperation || HighCauseDenormal ||
          // HighCause.ZeroDivide)

        // do not re-execute the high half of the instruction - it would only
        // return an approximation of 1 / (high FR3); calculate instead the 
        // quotient (high FR2) / (high FR3) in single precision, using the 
        // correct rounding mode (the high half of the instruction did not 
        // cause any exception)

        // extract the high halves of FR2 and FR3
        FR2High = HighHalf (FR2);
        FR3High = HighHalf (FR3);

        // employ the user FPSR when calling _thmB; note that
        // the exception masks are those set by the user, and that an
        // underflow, overflow, or inexact exception might be raised

        // perform the single precision divide
        _thmB (&FR2High, &FR3High, &FR1High, &FPSR); // FR1High = FR2High/FR3High

#ifdef FPIEEE_FLT_DEBUG
        printf ("FPIEEE_FLT_DEBUG: F6 high res from _thmB = %f = %x\n",
            FR1High, *(unsigned int *)&FR1High);
#endif

      } // end 'if not (HighCause.InvalidOperation || HighCauseDenormal ||
          // HighCause.ZeroDivide)'

      if (!LowCause.InvalidOperation && !LowCause.ZeroDivide &&
          !LowCauseDenormal && !HighCause.InvalidOperation && 
          !HighCauseDenormal && !HighCause.ZeroDivide) {

        // should never get here
        fprintf (stderr, "IEEE Filter Internal Error: no enabled \
            exception (multiple fault) recognized in F6 instruction\n");
        exit (1);

      }

      // set the result predicate
      PR2 = 0;

      Context->StFPSR = FPSR;

      FR1 = Combine (FR1High, FR1Low);
      // set the results before continuing execution
      SetFloatRegisterValue (f1, FR1, Context);
      if (f1 < 32)
        Context->StIPSR = Context->StIPSR | (unsigned __int64)0x10; //set mfl bit
      else
        Context->StIPSR = Context->StIPSR | (unsigned __int64)0x20; //set mfh bit
      Context->Preds &= (~(((unsigned __int64)1) << p2));
      Context->Preds |= (((unsigned __int64)(PR2 & 0x01)) << p2);

      // if this is a fault, need to advance the instruction pointer
      if (FpieeeRecord.Cause.InvalidOperation || CauseDenormal ||
          FpieeeRecord.Cause.ZeroDivide) {

        if (ei == 0) { // no template for this case
          Context->StIPSR = Context->StIPSR & 0xfffff9ffffffffff;
          Context->StIPSR = Context->StIPSR | 0x0000020000000000;
        } else if (ei == 1) { // templates: MFI, MFB
          Context->StIPSR = Context->StIPSR & 0xfffff9ffffffffff;
          Context->StIPSR = Context->StIPSR | 0x0000040000000000;
        } else { // if (ei == 2) // templates: MMF
          Context->StIPSR = Context->StIPSR & 0xfffff9ffffffffff;
          Context->StIIP = Context->StIIP + 0x10;
        }

      }

    }

  } else if ((OpCode & F7_MIN_MASK) == F7_PATTERN) {
    /* F7 instruction */
    // FRSQRTA, FPRSQRTA

#ifdef FPIEEE_FLT_DEBUG
    printf ("FPIEEE_FLT_DEBUG: F7 instruction\n");
#endif

    if (!SIMD_instruction && 
        (FpieeeRecord.Cause.ZeroDivide ||
        FpieeeRecord.Cause.Overflow ||
        FpieeeRecord.Cause.Underflow) ||
        SIMD_instruction && 
        (LowCause.ZeroDivide || HighCause.ZeroDivide ||
        LowCause.Overflow || HighCause.Overflow ||
        LowCause.Underflow || HighCause.Underflow)) {
      fprintf (stderr, "IEEE Filter Internal Error: Cause.ZeroDivide, \
Cause.Overflow, or Cause.Underflow for \
F7 instruction opcode %8x %8x\n",
          (int)(OpCode >> 32) & 0xffffffff, (int)OpCode & 0xffffffff);
      exit (1);
    }

    /* Note: the IEEE filter should be reached for these instructions
     * only when the value of  sqrt(FR3) is expected */

    /* extract p2, f3, and f1 */
    p2 = (unsigned int)((OpCode >> 27) & (unsigned __int64)0x00000000003f);
    if (p2 >= 16) p2 = 16 + (rrbpr + p2 - 16) % 48;
    f3 = (unsigned int)((OpCode >> 20) & (unsigned __int64)0x00000000007F);
    if (f3 >= 32) f3 = 32 + (rrbfr + f3 - 32) % 96;
    f1 = (unsigned int)((OpCode >>  6) & (unsigned __int64)0x00000000007F);
    if (f1 >= 32) f1 = 32 + (rrbfr + f1 - 32) % 96;

    /* get source floating-point register value */
    FR3 = GetFloatRegisterValue (f3, Context);

    if (!SIMD_instruction) {

      // *** this is a non-SIMD instruction, FRSQRTA ***

      FpieeeRecord.Operand1.Format = _FpFormatFp82; /* 1 + 17 + 64 bits */
      FpieeeRecord.Operand1.OperandValid = 1;
      FpieeeRecord.Operand1.Value.Fp128Value = FR3;
      FpieeeRecord.Operand2.OperandValid = 0;
      FpieeeRecord.Operand3.OperandValid = 0;

      switch (OpCode & F7_MASK) {

        case FRSQRTA_PATTERN:
          FpieeeRecord.Operation = _FpCodeSquareRoot;
          FpieeeRecord.Result.Format = _FpFormatFp82; /* 1 + 17 + 64 bits */
          break;

        default:
          /* unrecognized instruction type */
          fprintf (stderr, "IEEE Filter Internal Error: \
              instruction opcode %8x %8x not recognized for FRSQRTA\n", 
              (int)(OpCode >> 32) & 0xffffffff, (int)OpCode & 0xffffffff);
          exit (1);

      }

      if (FpieeeRecord.Cause.InvalidOperation || CauseDenormal) {

        /* this is a fault - the result contains an invalid value */
        FpieeeRecord.Result.OperandValid = 0;

      } else if (FpieeeRecord.Cause.Inexact) {

        // this is a trap - the result contains a valid value
        FpieeeRecord.Result.OperandValid = 1;
        // get the result
        FpieeeRecord.Result.Value.Fp128Value =
            GetFloatRegisterValue (f1, Context);

      } else {

        fprintf (stderr, "IEEE Filter Internal Error: exception code %x invalid\
          or not recognized in F7 instruction\n", eXceptionCode);
        exit (1);

      }

      handler_return_value = handler (&FpieeeRecord);

      if (handler_return_value == EXCEPTION_CONTINUE_EXECUTION) {

        // convert the result to 82-bit format
        FR1 = FPIeeeToFP128 (&FpieeeRecord);
#ifdef FPIEEE_FLT_DEBUG
        printf ("FPIEEE_FLT_DEBUG 3: CONVERTED FR1 = %08x %08x %08x %08x\n",
            FR1.W[3], FR1.W[2], FR1.W[1], FR1.W[0]);
#endif

        /* change the FPSR with values (possibly) set by the user handler, 
         * for continuing execution where the interruption occured */

        UpdateRoundingMode (FpieeeRecord.RoundingMode, sf, &FPSR, "F7");
        UpdatePrecision (FpieeeRecord.Precision, sf, &FPSR, "F7");

        I_dis = !FpieeeRecord.Enable.Inexact;
        U_dis = !FpieeeRecord.Enable.Underflow;
        O_dis = !FpieeeRecord.Enable.Overflow;
        Z_dis = !FpieeeRecord.Enable.ZeroDivide;
        V_dis = !FpieeeRecord.Enable.InvalidOperation;

        FPSR = FPSR & ~((unsigned __int64)0x03d) | (unsigned __int64)(I_dis
            << 5 | U_dis << 4 | O_dis << 3 | Z_dis << 2 | V_dis);

        Context->StFPSR = FPSR;

        // set the result before continuing execution
        SetFloatRegisterValue (f1, FR1, Context);
        if (f1 < 32)
          Context->StIPSR = Context->StIPSR | (unsigned __int64)0x10; //set mfl bit
        else
          Context->StIPSR = Context->StIPSR | (unsigned __int64)0x20; //set mfh bit
        PR2 = 0;
        Context->Preds &= (~(((unsigned __int64)1) << p2));
        Context->Preds |= (((unsigned __int64)(PR2 & 0x01)) << p2);

        // if this is a fault, need to advance the instruction pointer
        if (FpieeeRecord.Cause.InvalidOperation || CauseDenormal) {

          if (ei == 0) { // no template for this case
            Context->StIPSR = Context->StIPSR & 0xfffff9ffffffffff;
            Context->StIPSR = Context->StIPSR | 0x0000020000000000;
          } else if (ei == 1) { // templates: MFI, MFB
            Context->StIPSR = Context->StIPSR & 0xfffff9ffffffffff;
            Context->StIPSR = Context->StIPSR | 0x0000040000000000;
          } else { // if (ei == 2) // templates: MMF
            Context->StIPSR = Context->StIPSR & 0xfffff9ffffffffff;
            Context->StIIP = Context->StIIP + 0x10;
          }

        }

      }

    } else { // if (SIMD_instruction)

      // *** this is a SIMD instruction, FPRSQRTA ***

      // the half (halves) of the instruction that caused an enabled exception, 
      // are presented to the user-defined handler in the form of non-SIMD in-
      // struction(s); the half (if any) that did not cause an enabled exception
      // (i.e. caused no exception, or caused an exception that is disabled),
      // is re-executed since it is associated with a fault in the other half;
      // the other half is padded to calculate sqrt (0.0), that will cause no 
      // exception (all are masked), but will generate a pair of square roots
      // in FR1

      switch (OpCode & F7_MASK) {

        case FPRSQRTA_PATTERN:
          Operation = _FpCodeSquareRoot;
          break;

        default:
          /* unrecognized instruction type */
          fprintf (stderr, "IEEE Filter Internal Error: SIMD \
              instruction opcode %8x %8x not recognized as FPRSQRTA\n", 
              (int)(OpCode >> 32) & 0xffffffff, (int)OpCode & 0xffffffff);
          exit (1);

      }

      // hand the half (halves) that caused an enabled fault to the 
      // user handler; re-execute the other half (if any);
      // combine the results

      // Note that the convention chosen is for the processing to be 
      // performed in the order low first, high second, as SIMD operands
      // are stored in this order in memory in the little endian format 
      // (this order would have to be changed for big endian)

      if (LowCause.InvalidOperation || LowCauseDenormal) {

        // invoke the user handler and check the return value

        // fill in the remaining fields of the _FPIEEE_RECORD (rounding
        // and precision already filled in)

        FpieeeRecord.Operand1.Format = _FpFormatFp82; /* 1 + 8 + 24 bits */
        FpieeeRecord.Operand1.OperandValid = 1;
        FpieeeRecord.Operand1.Value.Fp128Value = FP32ToFP128 (LowHalf (FR3));
        FpieeeRecord.Operand2.OperandValid = 0;
        FpieeeRecord.Operand3.OperandValid = 0;

        FpieeeRecord.Result.Format = _FpFormatFp32; /* 1 + 8 + 24 bits */
        FpieeeRecord.Result.OperandValid = 0;

        FpieeeRecord.Operation = Operation;

        FpieeeRecord.Status.Inexact = LowStatus.Inexact;
        FpieeeRecord.Status.Underflow = LowStatus.Underflow;
        FpieeeRecord.Status.Overflow = LowStatus.Overflow;
        StatusDenormal = LowStatusDenormal;
        FpieeeRecord.Status.ZeroDivide = LowStatus.ZeroDivide;
        FpieeeRecord.Status.InvalidOperation = LowStatus.InvalidOperation;

        FpieeeRecord.Cause.Inexact = LowCause.Inexact;
        FpieeeRecord.Cause.Underflow = LowCause.Underflow;
        FpieeeRecord.Cause.Overflow = LowCause.Overflow;
        CauseDenormal = LowCauseDenormal;
        FpieeeRecord.Cause.ZeroDivide = LowCause.ZeroDivide;
        FpieeeRecord.Cause.InvalidOperation = LowCause.InvalidOperation;

        // invoke the user-defined exception handler
        handler_return_value = handler (&FpieeeRecord);

        // return if not EXCEPTION_CONTINUE_EXECUTION
        if (handler_return_value != EXCEPTION_CONTINUE_EXECUTION) {

          __set_fpsr (&old_fpsr); /* restore caller fpsr */
          return (handler_return_value);

        }

        // clear the IEEE exception flags in the FPSR and
        // update the FPSR with values (possibly) set by the user handler
        // for the rounding mode, the precision mode, and the trap enable
        // bits; if the high half needs to be re-executed, the new FPSR
        // will be used, with status flags cleared; if it is 
        // forwarded to the user-defined handler, the new rounding and 
        // precision modes are also used (they are
        // already set in FpieeeRecord)

        UpdateRoundingMode (FpieeeRecord.RoundingMode, sf, &FPSR, "F7");
        UpdatePrecision (FpieeeRecord.Precision, sf, &FPSR, "F7");

        // Update the trap disable bits
        I_dis = !FpieeeRecord.Enable.Inexact;
        U_dis = !FpieeeRecord.Enable.Underflow;
        O_dis = !FpieeeRecord.Enable.Overflow;
        Z_dis = !FpieeeRecord.Enable.ZeroDivide;
        V_dis = !FpieeeRecord.Enable.InvalidOperation;

        FPSR = FPSR & ~((unsigned __int64)0x03d) | (unsigned __int64)(I_dis
            << 5 | U_dis << 4 | O_dis << 3 | Z_dis << 2 | V_dis);

        // save the result for the low half
        FR1Low = FpieeeRecord.Result.Value.Fp32Value;

        // since there has been a call to the user handler and the FPSR 
        // might have changed (the Enable bits in particular), recalculate
        // the Cause bits (if the HighEnable-s changed, there might be a 
        // change in the HighCause values) 
        // Note that the Status bits used are the original ones

        HighCause.Inexact = 0;
        HighCause.Underflow = 0;
        HighCause.Overflow = 0;
        HighCause.ZeroDivide =
            FpieeeRecord.Enable.ZeroDivide && HighStatus.ZeroDivide;
        HighCauseDenormal = EnableDenormal && HighStatusDenormal;
        HighCause.InvalidOperation =
            FpieeeRecord.Enable.InvalidOperation &&
            HighStatus.InvalidOperation;

      } else { // if not (LowCause.InvalidOperation || LowCauseDenormal)

        // do not re-execute the low half of the instruction - it would only
        // return an approximation of 1 / sqrt (low FR3); calculate instead
        // sqrt (low FR3) in single precision, using the correct rounding mode
        // (the low half of the instruction did not cause any exception)

        // extract the low half of FR3
        FR3Low = LowHalf (FR3);

        // employ the user FPSR when calling _thmH; note that
        // the exception masks are those set by the user, and that an
        // inexact exception might be raised

        // perform the single precision square root
        _thmH (&FR3Low, &FR1Low, &FPSR); // FR1Low = sqrt (FR3Low)

#ifdef FPIEEE_FLT_DEBUG
        printf ("FPIEEE_FLT_DEBUG: F7 low res from _thmH = %f = %x\n",
            FR1Low, *(unsigned int *)&FR1Low);
#endif

      } // end 'if not (LowCause.InvalidOperation || LowCauseDenormal)'

      if (HighCause.InvalidOperation || HighCauseDenormal) {

        // invoke the user-defined exception handler and check the return 
        // value; since this might be the second call to the user handler,
        // make sure all the _FPIEEE_RECORD fields are correct;
        // return if handler_return_value is not
        // EXCEPTION_CONTINUE_EXECUTION, otherwise combine the results

        // the rounding mode is either the initial one, or the one
        // set during the call to the user handler for the low half,
        // if there has been an enabled exception for it

        // the precision mode is either the initial one, or the one
        // set during the call to the user handler for the low half,
        // if there has been an enabled exception for it

        // the enable flags are either the initial ones, or the ones
        // set during the call to the user handler for the low half,
        // if there has been an enabled exception for it

        FpieeeRecord.Operand1.Format = _FpFormatFp82; /* 1+8+24 bits */
        FpieeeRecord.Operand1.OperandValid = 1;
        FpieeeRecord.Operand1.Value.Fp128Value = FP32ToFP128 (HighHalf (FR3));
        FpieeeRecord.Operand2.OperandValid = 0;
        FpieeeRecord.Operand3.OperandValid = 0;

        FpieeeRecord.Result.Format = _FpFormatFp32; /* 1 + 8 + 24 bits */
        FpieeeRecord.Result.OperandValid = 0;

        FpieeeRecord.Operation = Operation;

        FpieeeRecord.Status.Inexact = HighStatus.Inexact;
        FpieeeRecord.Status.Underflow = HighStatus.Underflow;
        FpieeeRecord.Status.Overflow = HighStatus.Overflow;
        StatusDenormal = HighStatusDenormal;
        FpieeeRecord.Status.ZeroDivide = HighStatus.ZeroDivide;
        FpieeeRecord.Status.InvalidOperation = HighStatus.InvalidOperation;

        FpieeeRecord.Cause.Inexact = HighCause.Inexact;
        FpieeeRecord.Cause.Underflow = HighCause.Underflow;
        FpieeeRecord.Cause.Overflow = HighCause.Overflow;
        CauseDenormal = HighCauseDenormal;
        FpieeeRecord.Cause.ZeroDivide = HighCause.ZeroDivide;
        FpieeeRecord.Cause.InvalidOperation = HighCause.InvalidOperation;

        // invoke the user-defined exception handler
        handler_return_value = handler (&FpieeeRecord);

        // return if not EXCEPTION_CONTINUE_EXECUTION
        if (handler_return_value != EXCEPTION_CONTINUE_EXECUTION) {

          __set_fpsr (&old_fpsr); /* restore caller fpsr */
          return (handler_return_value);

        }

        // clear the IEEE exception flags in the FPSR and
        // update the FPSR with values (possibly) set by the user handler
        // for the rounding mode, the precision mode, and the trap enable
        // bits; if the high half needs to be re-executed, the new FPSR
        // will be used, with status flags cleared; if it is
        // forwarded to the user-defined handler, the new rounding and
        // precision modes are also used (they are
        // already set in FpieeeRecord)

        /* change the FPSR with values (possibly) set by the user handler,
         * for continuing execution where the interruption occured */

        UpdateRoundingMode (FpieeeRecord.RoundingMode, sf, &FPSR, "F7");
        UpdatePrecision (FpieeeRecord.Precision, sf, &FPSR, "F7");

        I_dis = !FpieeeRecord.Enable.Inexact;
        U_dis = !FpieeeRecord.Enable.Underflow;
        O_dis = !FpieeeRecord.Enable.Overflow;
        Z_dis = !FpieeeRecord.Enable.ZeroDivide;
        V_dis = !FpieeeRecord.Enable.InvalidOperation;

        FPSR = FPSR & ~((unsigned __int64)0x03d) | (unsigned __int64)(I_dis 
            << 5 | U_dis << 4 | O_dis << 3 | Z_dis << 2 | V_dis);

        // save the result for the high half
        FR1High = FpieeeRecord.Result.Value.Fp32Value;

      } else { //if not (HighCause.InvalidOperation || HighCauseDenormal)

        // do not re-execute the high half of the instruction - it would only
        // return an approximation of 1 / sqrt (high FR3); calculate instead 
        // sqrt (high FR3) in single precision, using the correct rounding mode
        // (the high half of the instruction did not cause any exception)

        // extract the high half of FR3
        FR3High = HighHalf (FR3);

#ifdef FPIEEE_FLT_DEBUG
        printf ("FPIEEE_FLT_DEBUG: F7 FR3High = %f = %x\n", 
            FR3High, *((unsigned int *)&FR3High));
#endif

        // employ the user FPSR when calling _thmH; note that
        // the exception masks are those set by the user, and that an
        // inexact exception might be raised

        // perform the single precision square root
        _thmH (&FR3High, &FR1High, &FPSR); // FR1High = sqrt (FR3High)

#ifdef FPIEEE_FLT_DEBUG
        printf ("FPIEEE_FLT_DEBUG: F7 high res from _thmH = %f = %x\n",
            FR1High, *(unsigned int *)&FR1High);
#endif

      } // end 'if not (HighCause.InvalidOperation || HighCause.ZeroDivide)'

      if (!LowCause.InvalidOperation && !LowCauseDenormal &&
          !HighCause.InvalidOperation && !HighCauseDenormal) {

        // should never get here
        fprintf (stderr, "IEEE Filter Internal Error: no enabled \
exception (multiple fault) recognized in F7 instruction\n");
        exit (1);

      }

      // set the result predicate
      PR2 = 0;

      Context->StFPSR = FPSR;

      FR1 = Combine (FR1High, FR1Low);
      // set the results before continuing execution
      SetFloatRegisterValue (f1, FR1, Context);
      if (f1 < 32)
        Context->StIPSR = Context->StIPSR | (unsigned __int64)0x10; //set mfl bit
      else
        Context->StIPSR = Context->StIPSR | (unsigned __int64)0x20; //set mfh bit
      Context->Preds &= (~(((unsigned __int64)1) << p2));
      Context->Preds |= (((unsigned __int64)(PR2 & 0x01)) << p2);

      // if this is a fault, need to advance the instruction pointer
      if (FpieeeRecord.Cause.InvalidOperation || CauseDenormal) {

        if (ei == 0) { // no template for this case
          Context->StIPSR = Context->StIPSR & 0xfffff9ffffffffff;
          Context->StIPSR = Context->StIPSR | 0x0000020000000000;
        } else if (ei == 1) { // templates: MFI, MFB
          Context->StIPSR = Context->StIPSR & 0xfffff9ffffffffff;
        Context->StIPSR = Context->StIPSR | 0x0000040000000000;
        } else { // if (ei == 2) // templates: MMF
          Context->StIPSR = Context->StIPSR & 0xfffff9ffffffffff;
          Context->StIIP = Context->StIIP + 0x10;
        }

      }

    }

  } else if ((OpCode & F8_MIN_MASK) == F8_PATTERN) {
    /* F8 instruction */
    // FMIN, FMAX, FAMIN, FAMAX, FPMIN, FPMAX, FPAMIN, FPAMAX

#ifdef FPIEEE_FLT_DEBUG
    printf ("FPIEEE_FLT_DEBUG: F8 instruction\n");
#endif

    if (!SIMD_instruction &&
        (FpieeeRecord.Cause.ZeroDivide ||
        FpieeeRecord.Cause.Overflow ||
        FpieeeRecord.Cause.Underflow ||
        FpieeeRecord.Cause.Inexact) ||
        SIMD_instruction &&
        (LowCause.ZeroDivide || HighCause.ZeroDivide ||
        LowCause.Overflow || HighCause.Overflow ||
        LowCause.Underflow || HighCause.Underflow ||
        LowCause.Inexact || HighCause.Inexact)) {
      fprintf (stderr, "IEEE Filter Internal Error: Cause.ZeroDivide, \
Cause.Overflow, Cause.Underflow, or Cause.Inexact for \
F8 instruction opcode %8x %8x\n",
          (int)(OpCode >> 32) & 0xffffffff, (int)OpCode & 0xffffffff);
      exit (1);
    }

    /* extract f3, f2, and f1 */
    f3 = (unsigned int)((OpCode >> 20) & (unsigned __int64)0x00000000007F);
    if (f3 >= 32) f3 = 32 + (rrbfr + f3 - 32) % 96;
    f2 = (unsigned int)((OpCode >> 13) & (unsigned __int64)0x00000000007F);
    if (f2 >= 32) f2 = 32 + (rrbfr + f2 - 32) % 96;
    f1 = (unsigned int)((OpCode >>  6) & (unsigned __int64)0x00000000007F);
    if (f1 >= 32) f1 = 32 + (rrbfr + f1 - 32) % 96;

    /* get source floating-point register values */
    FR2 = GetFloatRegisterValue (f2, Context);
    FR3 = GetFloatRegisterValue (f3, Context);

    if (!SIMD_instruction) {

      // *** this is a non-SIMD instruction ***
      // (FMIN, FMAX, FAMIN, FAMAX)

      FpieeeRecord.Operand1.Format = _FpFormatFp82; /* 1 + 17 + 64 bits */
      FpieeeRecord.Operand1.OperandValid = 1;
      FpieeeRecord.Operand1.Value.Fp128Value = FR2;
      FpieeeRecord.Operand2.Format = _FpFormatFp82; /* 1 + 17 + 64 bits */
      FpieeeRecord.Operand2.OperandValid = 1;
      FpieeeRecord.Operand2.Value.Fp128Value = FR3;
      FpieeeRecord.Operand3.OperandValid = 0;

      switch (OpCode & F8_MASK) {

        case FMIN_PATTERN:
          FpieeeRecord.Operation = _FpCodeFmin;
          break;

        case FMAX_PATTERN:
          FpieeeRecord.Operation = _FpCodeFmax;
          break;

        case FAMIN_PATTERN:
          FpieeeRecord.Operation = _FpCodeFamin;
          break;

        case FAMAX_PATTERN:
          FpieeeRecord.Operation = _FpCodeFamax;
          break;

        default:
          /* unrecognized instruction type */
          fprintf (stderr, "IEEE Filter Internal Error: \
              non-SIMD F8 instruction opcode %8x %8x not recognized\n", 
              (int)(OpCode >> 32) & 0xffffffff, (int)OpCode & 0xffffffff);
          exit (1);

      }

      FpieeeRecord.Result.Format = _FpFormatFp82; /* 1+17+24/53/64 bits */

      /* this is a fault - the result contains an invalid value */
      FpieeeRecord.Result.OperandValid = 0;

      handler_return_value = handler (&FpieeeRecord);

      // convert the result to 82-bit format
      FR1 = FPIeeeToFP128 (&FpieeeRecord);
#ifdef FPIEEE_FLT_DEBUG
      printf ("FPIEEE_FLT_DEBUG 4: CONVERTED FR1 = %08x %08x %08x %08x\n",
          FR1.W[3], FR1.W[2], FR1.W[1], FR1.W[0]);
#endif

      if (handler_return_value == EXCEPTION_CONTINUE_EXECUTION) {

        /* change the FPSR with values (possibly) set by the user handler, 
         * for continuing execution where the interruption occured */

        UpdateRoundingMode (FpieeeRecord.RoundingMode, sf, &FPSR, "F8");
        UpdatePrecision (FpieeeRecord.Precision, sf, &FPSR, "F8");

        I_dis = !FpieeeRecord.Enable.Inexact;
        U_dis = !FpieeeRecord.Enable.Underflow;
        O_dis = !FpieeeRecord.Enable.Overflow;
        Z_dis = !FpieeeRecord.Enable.ZeroDivide;
        V_dis = !FpieeeRecord.Enable.InvalidOperation;

        FPSR = FPSR & ~((unsigned __int64)0x03d) | (unsigned __int64)(I_dis 
            << 5 | U_dis << 4 | O_dis << 3 | Z_dis << 2 | V_dis);

        Context->StFPSR = FPSR;

        // set the result before continuing execution
        SetFloatRegisterValue (f1, FR1, Context);
        if (f1 < 32)
          Context->StIPSR = Context->StIPSR | (unsigned __int64)0x10; //set mfl bit
        else
          Context->StIPSR = Context->StIPSR | (unsigned __int64)0x20; //set mfh bit

        // this is a fault; need to advance the instruction pointer
        if (ei == 0) { // no template for this case
          Context->StIPSR = Context->StIPSR & 0xfffff9ffffffffff;
          Context->StIPSR = Context->StIPSR | 0x0000020000000000;
        } else if (ei == 1) { // templates: MFI, MFB
          Context->StIPSR = Context->StIPSR & 0xfffff9ffffffffff;
          Context->StIPSR = Context->StIPSR | 0x0000040000000000;
        } else { // if (ei == 2) // templates: MMF
          Context->StIPSR = Context->StIPSR & 0xfffff9ffffffffff;
          Context->StIIP = Context->StIIP + 0x10;
        }

      }

    } else { // if (SIMD_instruction)

      // *** this is a SIMD instruction *** 
      // (FPMIN, FPMAX, FPAMIN, FPAMAX, FPCMP)

      // the half (halves) of the instruction that caused an enabled exception, 
      // are presented to the user-defined handler in the form of non-SIMD in-
      // struction(s); the half (if any) that did not cause an enabled exception
      // (i.e. caused no exception, or caused an exception that is disabled),
      // is re-executed; in this case, the other half is padded to calculate 
      // FPXXX (0.0, 0.0), that will cause no exception

      switch (OpCode & F8_MASK) {

        case FPMIN_PATTERN:
          Operation = _FpCodeFmin;
          ResultFormat = _FpFormatFp32; /* 1 + 8 + 24 bits */
          break;

        case FPMAX_PATTERN:
          Operation = _FpCodeFmax;
          ResultFormat = _FpFormatFp32; /* 1 + 8 + 24 bits */
          break;

        case FPAMIN_PATTERN:
          Operation = _FpCodeFamin;
          ResultFormat = _FpFormatFp32; /* 1 + 8 + 24 bits */
          break;

        case FPAMAX_PATTERN:
          Operation = _FpCodeFamax;
          ResultFormat = _FpFormatFp32; /* 1 + 8 + 24 bits */
          break;

        case FPCMP_EQ_PATTERN:
        case FPCMP_LT_PATTERN:
        case FPCMP_LE_PATTERN:
        case FPCMP_UNORD_PATTERN:
        case FPCMP_NEQ_PATTERN:
        case FPCMP_NLT_PATTERN:
        case FPCMP_NLE_PATTERN:
        case FPCMP_ORD_PATTERN:
          Operation = _FpCodeCompare;
          ResultFormat = _FpFormatCompare;
          break;

        default:
          /* unrecognized instruction type */
          fprintf (stderr, "IEEE Filter Internal Error: \
              F8 SIMD instruction opcode %8x %8x not recognized\n", 
              (int)(OpCode >> 32) & 0xffffffff, (int)OpCode & 0xffffffff);
          exit (1);

      }

      // hand the half (halves) that caused an enabled fault to the 
      // user handler; re-execute the other half (if any);
      // combine the results

      // Note that the convention chosen is for the processing to be 
      // performed in the order low first, high second, as SIMD operands
      // are stored in this order in memory in the little endian format 
      // (this order would have to be changed for big endian)

      if (LowCause.InvalidOperation  || LowCauseDenormal) {

        // invoke the user handler and check the return value

        // fill in the remaining fields of the _FPIEEE_RECORD (rounding
        // and precision already filled in)

        FpieeeRecord.Operand1.Format = _FpFormatFp82; /* 1 + 8 + 24 bits */
        FpieeeRecord.Operand1.OperandValid = 1;
        FpieeeRecord.Operand1.Value.Fp128Value = FP32ToFP128 (LowHalf (FR2));
        FpieeeRecord.Operand2.Format = _FpFormatFp82; /* 1 + 8 + 24 bits */
        FpieeeRecord.Operand2.OperandValid = 1;
        FpieeeRecord.Operand2.Value.Fp128Value = FP32ToFP128 (LowHalf (FR3));
        FpieeeRecord.Operand3.OperandValid = 0;

        FpieeeRecord.Result.Format = ResultFormat;
        FpieeeRecord.Result.OperandValid = 0;
        FpieeeRecord.Operation = Operation;

        FpieeeRecord.Status.Inexact = LowStatus.Inexact;
        FpieeeRecord.Status.Underflow = LowStatus.Underflow;
        FpieeeRecord.Status.Overflow = LowStatus.Overflow;
        FpieeeRecord.Status.ZeroDivide = LowStatus.ZeroDivide;
        StatusDenormal = LowStatusDenormal;
        FpieeeRecord.Status.InvalidOperation = LowStatus.InvalidOperation;

        FpieeeRecord.Cause.Inexact = LowCause.Inexact;
        FpieeeRecord.Cause.Underflow = LowCause.Underflow;
        FpieeeRecord.Cause.Overflow = LowCause.Overflow;
        FpieeeRecord.Cause.ZeroDivide = LowCause.ZeroDivide;
        CauseDenormal = LowCauseDenormal;
        FpieeeRecord.Cause.InvalidOperation = LowCause.InvalidOperation;

        // invoke the user-defined exception handler
        handler_return_value = handler (&FpieeeRecord);

        // return if not EXCEPTION_CONTINUE_EXECUTION
        if (handler_return_value != EXCEPTION_CONTINUE_EXECUTION) {

          __set_fpsr (&old_fpsr); /* restore caller fpsr */
          return (handler_return_value);

        }

        // clear the IEEE exception flags in the FPSR and
        // update the FPSR with values (possibly) set by the user handler
        // for the rounding mode, the precision mode, and the trap enable
        // bits; if the high half needs to be re-executed, the new FPSR
        // will be used, with status flags cleared; if it is 
        // forwarded to the user-defined handler, the new rounding and 
        // precision modes are also used (they are
        // already set in FpieeeRecord)

        UpdateRoundingMode (FpieeeRecord.RoundingMode, sf, &FPSR, "F8");
        UpdatePrecision (FpieeeRecord.Precision, sf, &FPSR, "F8");

        // Update the trap disable bits
        I_dis = !FpieeeRecord.Enable.Inexact;
        U_dis = !FpieeeRecord.Enable.Underflow;
        O_dis = !FpieeeRecord.Enable.Overflow;
        Z_dis = !FpieeeRecord.Enable.ZeroDivide;
        V_dis = !FpieeeRecord.Enable.InvalidOperation;

        FPSR = FPSR & ~((unsigned __int64)0x03d) | (unsigned __int64)(I_dis
            << 5 | U_dis << 4 | O_dis << 3 | Z_dis << 2 | V_dis);

        // save the result for the low half
        switch (OpCode & F8_MASK) {

          case FPMIN_PATTERN:
          case FPMAX_PATTERN:
          case FPAMIN_PATTERN:
          case FPAMAX_PATTERN:
            FR1Low = FpieeeRecord.Result.Value.Fp32Value;
            break;

          case FPCMP_EQ_PATTERN:
            switch (FpieeeRecord.Result.Value.CompareValue) {
              case _FpCompareEqual:
                U32Low = 0x0ffffffff;
                break;
              case _FpCompareGreater:
              case _FpCompareLess:
              case _FpCompareUnordered:
                U32Low = 0x0;
                break;
              default:
                /* unrecognized FpieeeRecord.Result.Value.CompareValue */
                fprintf (stderr, "IEEE Filter Internal Error: \
                    FpieeeRecord.Result.Value.CompareValue %x not recognized \
                    for F8 instruction\n",
                    FpieeeRecord.Result.Value.CompareValue);
                exit (1);
            }
            break;

          case FPCMP_LT_PATTERN:
            switch (FpieeeRecord.Result.Value.CompareValue) {
              case _FpCompareLess:
                U32Low = 0x0ffffffff;
                break;
              case _FpCompareGreater:
              case _FpCompareEqual:
              case _FpCompareUnordered:
                U32Low = 0x0;
                break;
              default:
                /* unrecognized FpieeeRecord.Result.Value.CompareValue */
                fprintf (stderr, "IEEE Filter Internal Error: \
                    FpieeeRecord.Result.Value.CompareValue %x not recognized \
                    for F8 instruction\n",
                    FpieeeRecord.Result.Value.CompareValue);
                exit (1);
            }
            break;

          case FPCMP_LE_PATTERN:
            switch (FpieeeRecord.Result.Value.CompareValue) {
              case _FpCompareEqual:
              case _FpCompareLess:
                U32Low = 0x0ffffffff;
                break;
              case _FpCompareGreater:
              case _FpCompareUnordered:
                U32Low = 0x0;
                break;
              default:
                /* unrecognized FpieeeRecord.Result.Value.CompareValue */
                fprintf (stderr, "IEEE Filter Internal Error: \
                    FpieeeRecord.Result.Value.CompareValue %x not recognized \
                    for F8 instruction\n",
                    FpieeeRecord.Result.Value.CompareValue);
                exit (1);
            }
            break;

          case FPCMP_UNORD_PATTERN:
            switch (FpieeeRecord.Result.Value.CompareValue) {
              case _FpCompareUnordered:
                U32Low = 0x0ffffffff;
                break;
              case _FpCompareEqual:
              case _FpCompareGreater:
              case _FpCompareLess:
                U32Low = 0x0;
                break;
              default:
                /* unrecognized FpieeeRecord.Result.Value.CompareValue */
                fprintf (stderr, "IEEE Filter Internal Error: \
                    FpieeeRecord.Result.Value.CompareValue %x not recognized \
                    for F8 instruction\n",
                    FpieeeRecord.Result.Value.CompareValue);
                exit (1);
            }
            break;

          case FPCMP_NEQ_PATTERN:
            switch (FpieeeRecord.Result.Value.CompareValue) {
              case _FpCompareGreater:
              case _FpCompareLess:
              case _FpCompareUnordered:
                U32Low = 0x0ffffffff;
                break;
              case _FpCompareEqual:
                U32Low = 0x0;
                break;
              default:
                /* unrecognized FpieeeRecord.Result.Value.CompareValue */
                fprintf (stderr, "IEEE Filter Internal Error: \
                    FpieeeRecord.Result.Value.CompareValue %x not recognized \
                    for F8 instruction\n",
                    FpieeeRecord.Result.Value.CompareValue);
                exit (1);
            }
            break;

          case FPCMP_NLT_PATTERN:
            switch (FpieeeRecord.Result.Value.CompareValue) {
              case _FpCompareEqual:
              case _FpCompareGreater:
                U32Low = 0x0ffffffff;
                break;
              case _FpCompareLess:
              case _FpCompareUnordered:
                U32Low = 0x0;
                break;
              default:
                /* unrecognized FpieeeRecord.Result.Value.CompareValue */
                fprintf (stderr, "IEEE Filter Internal Error: \
                    FpieeeRecord.Result.Value.CompareValue %x not recognized \
                    for F8 instruction\n",
                    FpieeeRecord.Result.Value.CompareValue);
                exit (1);
            }
            break;

          case FPCMP_NLE_PATTERN:
            switch (FpieeeRecord.Result.Value.CompareValue) {
              case _FpCompareGreater:
                U32Low = 0x0ffffffff;
                break;
              case _FpCompareEqual:
              case _FpCompareLess:
              case _FpCompareUnordered:
                U32Low = 0x0;
                break;
              default:
                /* unrecognized FpieeeRecord.Result.Value.CompareValue */
                fprintf (stderr, "IEEE Filter Internal Error: \
                    FpieeeRecord.Result.Value.CompareValue %x not recognized \
                    for F8 instruction\n",
                    FpieeeRecord.Result.Value.CompareValue);
                exit (1);
            }
            break;

          case FPCMP_ORD_PATTERN:
            switch (FpieeeRecord.Result.Value.CompareValue) {
              case _FpCompareEqual:
              case _FpCompareGreater:
              case _FpCompareLess:
                U32Low = 0x0ffffffff;
                break;
              case _FpCompareUnordered:
                U32Low = 0x0;
                break;
              default:
                /* unrecognized FpieeeRecord.Result.Value.CompareValue */
                fprintf (stderr, "IEEE Filter Internal Error: \
                    FpieeeRecord.Result.Value.CompareValue %x not recognized \
                    for F8 instruction\n",
                    FpieeeRecord.Result.Value.CompareValue);
                exit (1);
            }
            break;

          default: ; // this case was verified above

        }

        // since there has been a call to the user handler and FPSR might
        // have changed (the Enable bits in particular), recalculate the 
        // Cause bits (if the HighEnable-s changed, there might be a 
        // change in the HighCause values) 
        // Note that the Status bits used are the original ones

        HighCause.Inexact = 0;
        HighCause.Underflow = 0;
        HighCause.Overflow = 0;
        HighCause.ZeroDivide =
            FpieeeRecord.Enable.ZeroDivide && HighStatus.ZeroDivide;
        HighCauseDenormal = EnableDenormal && HighStatusDenormal;
        HighCause.InvalidOperation =
            FpieeeRecord.Enable.InvalidOperation &&
            HighStatus.InvalidOperation;
        // Note: the user handler does not affect the denormal enable bit

      } else if (LowCause.ZeroDivide) {

        fprintf (stderr, "IEEE Filter Internal Error: \
            LowCause.ZeroDivide in F8 instruction\n");
        exit (1);

      } else { // if not (LowCause.InvalidOperation || LowCauseDenormal ||
         // LowCause.ZeroDivide)

        // re-execute the low half of the instruction

        // modify the high halves of FR2, FR3
        switch (OpCode & F8_MASK) {

          case FPMIN_PATTERN:
          case FPMAX_PATTERN:
          case FPAMIN_PATTERN:
          case FPAMAX_PATTERN:
            newFR2 = Combine ((float)0.0, LowHalf (FR2));
            newFR3 = Combine ((float)0.0, LowHalf (FR3));
            break;

          case FPCMP_EQ_PATTERN:
          case FPCMP_LT_PATTERN:
          case FPCMP_LE_PATTERN:
          case FPCMP_UNORD_PATTERN:
          case FPCMP_NEQ_PATTERN:
          case FPCMP_NLT_PATTERN:
          case FPCMP_NLE_PATTERN:
          case FPCMP_ORD_PATTERN:
            newFR2 = U32Combine (0, U32LowHalf (FR2));
            newFR3 = U32Combine (0, U32LowHalf (FR3));

            break;

          default: ; // this case was verified above

        }

        switch (OpCode & F8_MASK) {

          case FPMIN_PATTERN:
            _xrun2args (FPMIN, &FPSR, &FR1, &newFR2, &newFR3);
            break;

          case FPMAX_PATTERN:
            _xrun2args (FPMAX, &FPSR, &FR1, &newFR2, &newFR3);
            break;

          case FPAMIN_PATTERN:
            _xrun2args (FPAMIN, &FPSR, &FR1, &newFR2, &newFR3);
            break;

          case FPAMAX_PATTERN:
            _xrun2args (FPAMAX, &FPSR, &FR1, &newFR2, &newFR3);
            break;

          case FPCMP_EQ_PATTERN:
            _xrun2args (FPCMP_EQ, &FPSR, &FR1, &newFR2, &newFR3);
            break;

          case FPCMP_LT_PATTERN:
            _xrun2args (FPCMP_LT, &FPSR, &FR1, &newFR2, &newFR3);
            break;

          case FPCMP_LE_PATTERN:
            _xrun2args (FPCMP_LE, &FPSR, &FR1, &newFR2, &newFR3);
            break;

          case FPCMP_UNORD_PATTERN:
            _xrun2args (FPCMP_UNORD, &FPSR, &FR1, &newFR2, &newFR3);
            break;

          case FPCMP_NEQ_PATTERN:
            _xrun2args (FPCMP_NEQ, &FPSR, &FR1, &newFR2, &newFR3);
            break;

          case FPCMP_NLT_PATTERN:
            _xrun2args (FPCMP_NLT, &FPSR, &FR1, &newFR2, &newFR3);
            break;

          case FPCMP_NLE_PATTERN:
            _xrun2args (FPCMP_NLE, &FPSR, &FR1, &newFR2, &newFR3);
            break;

          case FPCMP_ORD_PATTERN:
            _xrun2args (FPCMP_ORD, &FPSR, &FR1, &newFR2, &newFR3);
            break;

          default:
            // unrecognized instruction type
            fprintf (stderr, "IEEE Filter Internal Error: \
                F8 SIMD instruction opcode %8x %8x not recognized\n", 
                (int)(OpCode >> 32) & 0xffffffff, (int)OpCode & 0xffffffff);
            exit (1);

        }

        switch (OpCode & F8_MASK) {

          case FPMIN_PATTERN:
          case FPMAX_PATTERN:
          case FPAMIN_PATTERN:
          case FPAMAX_PATTERN:
            FR1Low = LowHalf (FR1);
            break;

          case FPCMP_EQ_PATTERN:
          case FPCMP_LT_PATTERN:
          case FPCMP_LE_PATTERN:
          case FPCMP_UNORD_PATTERN:
          case FPCMP_NEQ_PATTERN:
          case FPCMP_NLT_PATTERN:
          case FPCMP_NLE_PATTERN:
          case FPCMP_ORD_PATTERN:
            U32Low = U32LowHalf (FR1);
            break;

          default: ; // this case was verified above

        }

      } // end 'if not (LowCause.InvalidOperation || LowCauseDenormal ||
         // LowCause.ZeroDivide)'

      if (HighCause.InvalidOperation || HighCauseDenormal) {

        // invoke the user-defined exception handler and check the return 
        // value; since this might be the second call to the user handler,
        // make sure all the _FPIEEE_RECORD fields are correct;
        // return if handler_return_value is not
        // EXCEPTION_CONTINUE_EXECUTION, otherwise combine the results

        // the rounding mode is either the initial one, or the one
        // set during the call to the user handler for the low half,
        // if there has been an enabled exception for it

        // the precision mode is either the initial one, or the one
        // set during the call to the user handler for the low half,
        // if there has been an enabled exception for it

        // the enable flags are either the initial ones, or the ones
        // set during the call to the user handler for the low half,
        // if there has been an enabled exception for it

        FpieeeRecord.Operand1.Format = _FpFormatFp82; /* 1+8+24 bits */
        FpieeeRecord.Operand1.OperandValid = 1;
        FpieeeRecord.Operand1.Value.Fp128Value = FP32ToFP128 (HighHalf (FR2));
        FpieeeRecord.Operand2.Format = _FpFormatFp82; /* 1+8+24 bits */
        FpieeeRecord.Operand2.OperandValid = 1;
        FpieeeRecord.Operand2.Value.Fp128Value = FP32ToFP128 (HighHalf (FR3));
        FpieeeRecord.Operand3.OperandValid = 0;

        FpieeeRecord.Result.Format = ResultFormat;
        FpieeeRecord.Result.OperandValid = 0;

        FpieeeRecord.Operation = Operation;

        FpieeeRecord.Status.Inexact = HighStatus.Inexact;
        FpieeeRecord.Status.Underflow = HighStatus.Underflow;
        FpieeeRecord.Status.Overflow = HighStatus.Overflow;
        FpieeeRecord.Status.ZeroDivide = HighStatus.ZeroDivide;
        StatusDenormal = HighStatusDenormal;
        FpieeeRecord.Status.InvalidOperation = HighStatus.InvalidOperation;

        FpieeeRecord.Cause.Inexact = HighCause.Inexact;
        FpieeeRecord.Cause.Underflow = HighCause.Underflow;
        FpieeeRecord.Cause.Overflow = HighCause.Overflow;
        FpieeeRecord.Cause.ZeroDivide = HighCause.ZeroDivide;
        CauseDenormal = HighCauseDenormal;
        FpieeeRecord.Cause.InvalidOperation = HighCause.InvalidOperation;

        // invoke the user-defined exception handler
        handler_return_value = handler (&FpieeeRecord);

        // return if not EXCEPTION_CONTINUE_EXECUTION
        if (handler_return_value != EXCEPTION_CONTINUE_EXECUTION) {

          __set_fpsr (&old_fpsr); /* restore caller fpsr */
          return (handler_return_value);

        }

        // clear the IEEE exception flags in the FPSR and
        // update the FPSR with values (possibly) set by the user handler
        // for the rounding mode, the precision mode, and the trap enable
        // bits; if the high half needs to be re-executed, the new FPSR
        // will be used, with status flags cleared; if it is
        // forwarded to the user-defined handler, the new rounding and
        // precision modes are also used (they are
        // already set in FpieeeRecord)

        /* change the FPSR with values (possibly) set by the user handler,
         * for continuing execution where the interruption occured */

        UpdateRoundingMode (FpieeeRecord.RoundingMode, sf, &FPSR, "F8");
        UpdatePrecision (FpieeeRecord.Precision, sf, &FPSR, "F8");

        I_dis = !FpieeeRecord.Enable.Inexact;
        U_dis = !FpieeeRecord.Enable.Underflow;
        O_dis = !FpieeeRecord.Enable.Overflow;
        Z_dis = !FpieeeRecord.Enable.ZeroDivide;
        V_dis = !FpieeeRecord.Enable.InvalidOperation;

        FPSR = FPSR & ~((unsigned __int64)0x03d) | (unsigned __int64)(I_dis 
            << 5 | U_dis << 4 | O_dis << 3 | Z_dis << 2 | V_dis);

        // save the result for the high half
        switch (OpCode & F8_MASK) {

          case FPMIN_PATTERN:
          case FPMAX_PATTERN:
          case FPAMIN_PATTERN:
          case FPAMAX_PATTERN:
            FR1High = FpieeeRecord.Result.Value.Fp32Value;
            break;

          case FPCMP_EQ_PATTERN:
            switch (FpieeeRecord.Result.Value.CompareValue) {
              case _FpCompareEqual:
                U32High = 0x0ffffffff;
                break;
              case _FpCompareGreater:
              case _FpCompareLess:
              case _FpCompareUnordered:
                U32High = 0x0;
                break;
              default:
                /* unrecognized FpieeeRecord.Result.Value.CompareValue */
                fprintf (stderr, "IEEE Filter Internal Error: \
                    FpieeeRecord.Result.Value.CompareValue %x not recognized \
                    for F8 instruction\n",
                    FpieeeRecord.Result.Value.CompareValue);
                exit (1);
            }
            break;

          case FPCMP_LT_PATTERN:
            switch (FpieeeRecord.Result.Value.CompareValue) {
              case _FpCompareLess:
                U32High = 0x0ffffffff;
                break;
              case _FpCompareGreater:
              case _FpCompareEqual:
              case _FpCompareUnordered:
                U32High = 0x0;
                break;
              default:
                /* unrecognized FpieeeRecord.Result.Value.CompareValue */
                fprintf (stderr, "IEEE Filter Internal Error: \
                    FpieeeRecord.Result.Value.CompareValue %x not recognized \
                    for F8 instruction\n",
                    FpieeeRecord.Result.Value.CompareValue);
                exit (1);
            }
            break;

          case FPCMP_LE_PATTERN:
            switch (FpieeeRecord.Result.Value.CompareValue) {
              case _FpCompareEqual:
              case _FpCompareLess:
                U32High = 0x0ffffffff;
                break;
              case _FpCompareGreater:
              case _FpCompareUnordered:
                U32High = 0x0;
                break;
              default:
                /* unrecognized FpieeeRecord.Result.Value.CompareValue */
                fprintf (stderr, "IEEE Filter Internal Error: \
                    FpieeeRecord.Result.Value.CompareValue %x not recognized \
                    for F8 instruction\n",
                    FpieeeRecord.Result.Value.CompareValue);
                exit (1);
            }
            break;

          case FPCMP_UNORD_PATTERN:
            switch (FpieeeRecord.Result.Value.CompareValue) {
              case _FpCompareUnordered:
                U32High = 0x0ffffffff;
                break;
              case _FpCompareEqual:
              case _FpCompareGreater:
              case _FpCompareLess:
                U32High = 0x0;
                break;
              default:
                /* unrecognized FpieeeRecord.Result.Value.CompareValue */
                fprintf (stderr, "IEEE Filter Internal Error: \
                    FpieeeRecord.Result.Value.CompareValue %x not recognized \
                    for F8 instruction\n",
                    FpieeeRecord.Result.Value.CompareValue);
                exit (1);
            }
            break;

          case FPCMP_NEQ_PATTERN:
            switch (FpieeeRecord.Result.Value.CompareValue) {
              case _FpCompareGreater:
              case _FpCompareLess:
              case _FpCompareUnordered:
                U32High = 0x0ffffffff;
                break;
              case _FpCompareEqual:
                U32High = 0x0;
                break;
              default:
                /* unrecognized FpieeeRecord.Result.Value.CompareValue */
                fprintf (stderr, "IEEE Filter Internal Error: \
                    FpieeeRecord.Result.Value.CompareValue %x not recognized \
                    for F8 instruction\n",
                    FpieeeRecord.Result.Value.CompareValue);
                exit (1);
            }
            break;

          case FPCMP_NLT_PATTERN:
            switch (FpieeeRecord.Result.Value.CompareValue) {
              case _FpCompareEqual:
              case _FpCompareGreater:
                U32High = 0x0ffffffff;
                break;
              case _FpCompareLess:
              case _FpCompareUnordered:
                U32High = 0x0;
                break;
              default:
                /* unrecognized FpieeeRecord.Result.Value.CompareValue */
                fprintf (stderr, "IEEE Filter Internal Error: \
                    FpieeeRecord.Result.Value.CompareValue %x not recognized \
                    for F8 instruction\n",
                    FpieeeRecord.Result.Value.CompareValue);
                exit (1);
            }
            break;

          case FPCMP_NLE_PATTERN:
            switch (FpieeeRecord.Result.Value.CompareValue) {
              case _FpCompareGreater:
                U32High = 0x0ffffffff;
                break;
              case _FpCompareEqual:
              case _FpCompareLess:
              case _FpCompareUnordered:
                U32High = 0x0;
                break;
              default:
                /* unrecognized FpieeeRecord.Result.Value.CompareValue */
                fprintf (stderr, "IEEE Filter Internal Error: \
                    FpieeeRecord.Result.Value.CompareValue %x not recognized \
                    for F8 instruction\n",
                    FpieeeRecord.Result.Value.CompareValue);
                exit (1);
            }
            break;

          case FPCMP_ORD_PATTERN:
            switch (FpieeeRecord.Result.Value.CompareValue) {
              case _FpCompareEqual:
              case _FpCompareGreater:
              case _FpCompareLess:
                U32High = 0x0ffffffff;
                break;
              case _FpCompareUnordered:
                U32High = 0x0;
                break;
              default:
                /* unrecognized FpieeeRecord.Result.Value.CompareValue */
                fprintf (stderr, "IEEE Filter Internal Error: \
                    FpieeeRecord.Result.Value.CompareValue %x not recognized \
                    for F8 instruction\n",
                    FpieeeRecord.Result.Value.CompareValue);
                exit (1);
            }
            break;

          default: ; // this case was verified above

        }

      } else if (HighCause.ZeroDivide) {

        fprintf (stderr, "IEEE Filter Internal Error: \
            HighCause.ZeroDivide in F8 instruction\n");
        exit (1);

      } else { //if not (HighCause.InvalidOperation || HighCauseDenormal ||
          // HighCause.ZeroDivide)

        // re-execute the high half of the instruction

        // modify the low halves of FR2, and FR3
        switch (OpCode & F8_MASK) {

          case FPMIN_PATTERN:
          case FPMAX_PATTERN:
          case FPAMIN_PATTERN:
          case FPAMAX_PATTERN:
            newFR2 = Combine (HighHalf (FR2), (float)0.0);
            newFR3 = Combine (HighHalf (FR3), (float)0.0);
            break;

          case FPCMP_EQ_PATTERN:
          case FPCMP_LT_PATTERN:
          case FPCMP_LE_PATTERN:
          case FPCMP_UNORD_PATTERN:
          case FPCMP_NEQ_PATTERN:
          case FPCMP_NLT_PATTERN:
          case FPCMP_NLE_PATTERN:
          case FPCMP_ORD_PATTERN:
            newFR2 = U32Combine (U32HighHalf (FR2), 0);
            newFR3 = U32Combine (U32HighHalf (FR3), 0);
            break;

          default: ; // this case was verified above

        }

        switch (OpCode & F8_MASK) {

          case FPMIN_PATTERN:
            _xrun2args (FPMIN, &FPSR, &FR1, &newFR2, &newFR3);
            break;

          case FPMAX_PATTERN:
            _xrun2args (FPMAX, &FPSR, &FR1, &newFR2, &newFR3);
            break;

          case FPAMIN_PATTERN:
            _xrun2args (FPAMIN, &FPSR, &FR1, &newFR2, &newFR3);
            break;

          case FPAMAX_PATTERN:
            _xrun2args (FPAMAX, &FPSR, &FR1, &newFR2, &newFR3);
            break;

          case FPCMP_EQ_PATTERN:
            _xrun2args (FPCMP_EQ, &FPSR, &FR1, &newFR2, &newFR3);
            break;

          case FPCMP_LT_PATTERN:
            _xrun2args (FPCMP_LT, &FPSR, &FR1, &newFR2, &newFR3);
            break;

          case FPCMP_LE_PATTERN:
            _xrun2args (FPCMP_LE, &FPSR, &FR1, &newFR2, &newFR3);
            break;

          case FPCMP_UNORD_PATTERN:
            _xrun2args (FPCMP_UNORD, &FPSR, &FR1, &newFR2, &newFR3);
            break;

          case FPCMP_NEQ_PATTERN:
            _xrun2args (FPCMP_NEQ, &FPSR, &FR1, &newFR2, &newFR3);
            break;

          case FPCMP_NLT_PATTERN:
            _xrun2args (FPCMP_NLT, &FPSR, &FR1, &newFR2, &newFR3);
            break;

          case FPCMP_NLE_PATTERN:
            _xrun2args (FPCMP_NLE, &FPSR, &FR1, &newFR2, &newFR3);
            break;

          case FPCMP_ORD_PATTERN:
            _xrun2args (FPCMP_ORD, &FPSR, &FR1, &newFR2, &newFR3);
            break;

          default:
            // unrecognized instruction type
            fprintf (stderr, "IEEE Filter Internal Error: \
                F8 SIMD instruction opcode %8x %8x not recognized\n", 
                (int)(OpCode >> 32) & 0xffffffff, (int)OpCode & 0xffffffff);
            exit (1);

        }

        switch (OpCode & F8_MASK) {

          case FPMIN_PATTERN:
          case FPMAX_PATTERN:
          case FPAMIN_PATTERN:
          case FPAMAX_PATTERN:
            FR1High = HighHalf (FR1);
            break;

          case FPCMP_EQ_PATTERN:
          case FPCMP_LT_PATTERN:
          case FPCMP_LE_PATTERN:
          case FPCMP_UNORD_PATTERN:
          case FPCMP_NEQ_PATTERN:
          case FPCMP_NLT_PATTERN:
          case FPCMP_NLE_PATTERN:
          case FPCMP_ORD_PATTERN:
            U32High = U32HighHalf (FR1);
            break;

          default: ; // this case was verified above

        }

      } // end 'if not (HighCause.InvalidOperation || HighCauseDenormal ||
          // HighCause.ZeroDivide)

      if (!LowCause.InvalidOperation && !LowCauseDenormal &&
          !HighCause.InvalidOperation && !HighCauseDenormal) {

        // should never get here
        fprintf (stderr, "IEEE Filter Internal Error: no enabled \
            exception (multiple fault) recognized in F8 instruction\n");
        exit (1);

      }

      Context->StFPSR = FPSR;

      switch (OpCode & F8_MASK) {

        case FPMIN_PATTERN:
        case FPMAX_PATTERN:
        case FPAMIN_PATTERN:
        case FPAMAX_PATTERN:
          FR1 = Combine (FR1High, FR1Low);
          break;

        case FPCMP_EQ_PATTERN:
        case FPCMP_LT_PATTERN:
        case FPCMP_LE_PATTERN:
        case FPCMP_UNORD_PATTERN:
        case FPCMP_NEQ_PATTERN:
        case FPCMP_NLT_PATTERN:
        case FPCMP_NLE_PATTERN:
        case FPCMP_ORD_PATTERN:
          FR1 = U32Combine (U32High, U32Low);
          break;

        default: ; // this case was verified above

      }

      // set the result before continuing execution
      SetFloatRegisterValue (f1, FR1, Context);
      if (f1 < 32)
        Context->StIPSR = Context->StIPSR | (unsigned __int64)0x10; //set mfl bit
      else
        Context->StIPSR = Context->StIPSR | (unsigned __int64)0x20; //set mfh bit

      // this is a fault; need to advance the instruction pointer
      if (ei == 0) { // no template for this case
        Context->StIPSR = Context->StIPSR & 0xfffff9ffffffffff;
        Context->StIPSR = Context->StIPSR | 0x0000020000000000;
      } else if (ei == 1) { // templates: MFI, MFB
        Context->StIPSR = Context->StIPSR & 0xfffff9ffffffffff;
        Context->StIPSR = Context->StIPSR | 0x0000040000000000;
      } else { // if (ei == 2) // templates: MMF
        Context->StIPSR = Context->StIPSR & 0xfffff9ffffffffff;
        Context->StIIP = Context->StIIP + 0x10;
      }

    }

  } else if ((OpCode & F10_MIN_MASK) == F10_PATTERN) {
    /* F10 instruction */
    // FCVT, FPCVT

#ifdef FPIEEE_FLT_DEBUG
    printf ("FPIEEE_FLT_DEBUG: F10 instruction\n");
#endif

    if (!SIMD_instruction &&
        (FpieeeRecord.Cause.ZeroDivide ||
        FpieeeRecord.Cause.Overflow ||
        FpieeeRecord.Cause.Underflow) ||
        SIMD_instruction &&
        (LowCause.ZeroDivide || HighCause.ZeroDivide ||
        LowCause.Overflow || HighCause.Overflow ||
        LowCause.Underflow || HighCause.Underflow)) {
      fprintf (stderr, "IEEE Filter Internal Error: Cause.ZeroDivide, \
Cause.Overflow, Cause.Underflow, or Cause.Inexact for \
F10 instruction opcode %8x %8x\n",
          (int)(OpCode >> 32) & 0xffffffff, (int)OpCode & 0xffffffff);
      exit (1);
    }

    /* extract f2 and f1 */
    f2 = (unsigned int)((OpCode >> 13) & (unsigned __int64)0x00000000007F);
    if (f2 >= 32) f2 = 32 + (rrbfr + f2 - 32) % 96;
    f1 = (unsigned int)((OpCode >>  6) & (unsigned __int64)0x00000000007F);
    if (f1 >= 32) f1 = 32 + (rrbfr + f1 - 32) % 96;

    /* get source floating-point register value */
    FR2 = GetFloatRegisterValue (f2, Context);

    if (!SIMD_instruction) {

      // *** this is a non-SIMD instruction, FCVT ***

      FpieeeRecord.Operand1.Format = _FpFormatFp82; /* 1 + 17 + 64 bits */
      FpieeeRecord.Operand1.OperandValid = 1;
      FpieeeRecord.Operand1.Value.Fp128Value = FR2;
      FpieeeRecord.Operand2.OperandValid = 0;
      FpieeeRecord.Operand3.OperandValid = 0;

      switch (OpCode & F10_MASK) {

        case FCVT_FX_TRUNC_PATTERN:
          FpieeeRecord.Operation = _FpCodeConvertTrunc;
          FpieeeRecord.Result.Format = _FpFormatI64; 
          break;

        case FCVT_FXU_TRUNC_PATTERN:
          FpieeeRecord.Operation = _FpCodeConvertTrunc;
          FpieeeRecord.Result.Format = _FpFormatU64;
          break;

        case FCVT_FX_PATTERN:
          FpieeeRecord.Operation = _FpCodeConvert;
          FpieeeRecord.Result.Format = _FpFormatI64; 
          break;

        case FCVT_FXU_PATTERN:
          FpieeeRecord.Operation = _FpCodeConvert;
          FpieeeRecord.Result.Format = _FpFormatU64;
          break;

        default:
          /* unrecognized instruction type */
          fprintf (stderr, "IEEE Filter Internal Error: F10\
              non-SIMD instruction opcode %8x %8x not recognized\n", 
              (int)(OpCode >> 32) & 0xffffffff, (int)OpCode & 0xffffffff);
          exit (1);

      }

      if (FpieeeRecord.Cause.InvalidOperation || CauseDenormal) {

        /* this is a fault - the result contains an invalid value */
        FpieeeRecord.Result.OperandValid = 0;

        handler_return_value = handler (&FpieeeRecord);

        // convert the result to 82-bit format
        switch (OpCode & F10_MASK) {
          case FCVT_FX_PATTERN:
          case FCVT_FX_TRUNC_PATTERN:
            FR1.W[0] = FpieeeRecord.Result.Value.I64Value.W[0];
            FR1.W[1] = FpieeeRecord.Result.Value.I64Value.W[1];
            break;
          case FCVT_FXU_TRUNC_PATTERN:
          case FCVT_FXU_PATTERN:
            FR1.W[0] = FpieeeRecord.Result.Value.U64Value.W[0];
            FR1.W[1] = FpieeeRecord.Result.Value.U64Value.W[1];
            break;
          default: ; // this case caught above
        }
        FR1.W[2] = 0x0001003e;

      } else if (FpieeeRecord.Cause.Inexact) {

        // this is a trap - get the result
        switch (OpCode & F10_MASK) {

          case FCVT_FX_PATTERN:
          case FCVT_FX_TRUNC_PATTERN:
            FR1 = GetFloatRegisterValue (f1, Context);
            FpieeeRecord.Result.Value.I64Value.W[0] = FR1.W[0];
            FpieeeRecord.Result.Value.I64Value.W[1] = FR1.W[1];
            break;

          case FCVT_FXU_TRUNC_PATTERN:
          case FCVT_FXU_PATTERN:
            FR1 = GetFloatRegisterValue (f1, Context);
            FpieeeRecord.Result.Value.U64Value.W[0] = FR1.W[0];
            FpieeeRecord.Result.Value.U64Value.W[1] = FR1.W[1];
            break;

          default: // should never get here
            /* unrecognized instruction type */
            fprintf (stderr, "IEEE Filter Internal Error: F10 SIMD \
                instruction opcode %8x %8x not recognized\n", 
                (int)(OpCode >> 32) & 0xffffffff, (int)OpCode & 0xffffffff);
            exit (1);

        }

        // the result contains a valid value
        FpieeeRecord.Result.OperandValid = 1;

        handler_return_value = handler (&FpieeeRecord);

        // convert the result to 82-bit format
        switch (OpCode & F10_MASK) {
          case FCVT_FX_PATTERN:
          case FCVT_FX_TRUNC_PATTERN:
            FR1.W[0] = FpieeeRecord.Result.Value.I64Value.W[0];
            FR1.W[1] = FpieeeRecord.Result.Value.I64Value.W[1];
            break;
          case FCVT_FXU_TRUNC_PATTERN:
          case FCVT_FXU_PATTERN:
            FR1.W[0] = FpieeeRecord.Result.Value.U64Value.W[0];
            FR1.W[1] = FpieeeRecord.Result.Value.U64Value.W[1];
            break;
          default: ; // this case caught above
        }
        FR1.W[2] = 0x0001003e;
        FR1.W[3] = 0x00000000;

      } else {

        // should never get here - this case was filtered above
        fprintf (stderr, "IEEE Filter Internal Error: \
            exception code %x not recognized in non-SIMD F10 instruction\n",
            eXceptionCode);
        exit (1);

    }

      if (handler_return_value == EXCEPTION_CONTINUE_EXECUTION) {

        /* change the FPSR with values (possibly) set by the user handler, 
         * for continuing execution where the interruption occured */

        UpdateRoundingMode (FpieeeRecord.RoundingMode, sf, &FPSR, "F10");
        UpdatePrecision (FpieeeRecord.Precision, sf, &FPSR, "F10");

        I_dis = !FpieeeRecord.Enable.Inexact;
        U_dis = !FpieeeRecord.Enable.Underflow;
        O_dis = !FpieeeRecord.Enable.Overflow;
        Z_dis = !FpieeeRecord.Enable.ZeroDivide;
        V_dis = !FpieeeRecord.Enable.InvalidOperation;

        FPSR = FPSR & ~((unsigned __int64)0x03d) | (unsigned __int64)(I_dis 
            << 5 | U_dis << 4 | O_dis << 3 | Z_dis << 2 | V_dis);

        Context->StFPSR = FPSR;

        // set the result before continuing execution
        SetFloatRegisterValue (f1, FR1, Context);
        if (f1 < 32)
          Context->StIPSR = Context->StIPSR | (unsigned __int64)0x10; //set mfl bit
        else
          Context->StIPSR = Context->StIPSR | (unsigned __int64)0x20; //set mfh bit

        // if this is a fault, need to advance the instruction pointer
        if (FpieeeRecord.Cause.InvalidOperation || CauseDenormal) {

          if (ei == 0) { // no template for this case
            Context->StIPSR = Context->StIPSR & 0xfffff9ffffffffff;
            Context->StIPSR = Context->StIPSR | 0x0000020000000000;
          } else if (ei == 1) { // templates: MFI, MFB
            Context->StIPSR = Context->StIPSR & 0xfffff9ffffffffff;
            Context->StIPSR = Context->StIPSR | 0x0000040000000000;
          } else { // if (ei == 2) // templates: MMF
            Context->StIPSR = Context->StIPSR & 0xfffff9ffffffffff;
            Context->StIIP = Context->StIIP + 0x10;
          }

        }

      }

    } else { // if (SIMD_instruction)

      // *** this is a SIMD instruction, FPCVT ***

      // the half (halves) of the instruction that caused an enabled exception, 
      // are presented to the user-defined handler in the form of non-SIMD in-
      // struction(s); the half (if any) that did not cause an enabled exception
      // (i.e. caused no exception, or caused an exception that is disabled),
      // is re-executed if it is associated with a fault in the other half; in
      // this case, the other half is padded to convert 0.0, that
      // will cause no exception; if it is associated with a trap in the other
      // half, its result is left unchanged

      switch (OpCode & F10_MASK) {

        case FPCVT_FX_TRUNC_PATTERN:
        case FPCVT_FXU_TRUNC_PATTERN:
          Operation = _FpCodeConvertTrunc;
          break;

        case FPCVT_FX_PATTERN:
        case FPCVT_FXU_PATTERN:
          Operation = _FpCodeConvert;
          break;

        default:
          /* unrecognized instruction type */
          fprintf (stderr, "IEEE Filter Internal Error: \
              instruction opcode %8x %8x not recognized\n", 
              (int)(OpCode >> 32) & 0xffffffff, (int)OpCode & 0xffffffff);
          exit (1);

      }

      switch (OpCode & F10_MASK) {

        case FPCVT_FX_TRUNC_PATTERN:
        case FPCVT_FX_PATTERN:
          ResultFormat = _FpFormatI32;
          break;
        case FPCVT_FXU_TRUNC_PATTERN:
        case FPCVT_FXU_PATTERN:
          ResultFormat = _FpFormatU32;
          // break;

        // default: this case caught above

      }

      if (eXceptionCode == STATUS_FLOAT_MULTIPLE_FAULTS) {

        // hand the half (halves) that caused an enabled fault to the 
        // user handler; re-execute the other half (if any);
        // combine the results

        // Note that the convention chosen is for the processing to be 
        // performed in the order low first, high second, as SIMD operands
        // are stored in this order in memory in the little endian format 
        // (this order would have to be changed for big endian)

        if (LowCause.InvalidOperation  || LowCauseDenormal) {

          // invoke the user handler and check the return value

          // fill in the remaining fields of the _FPIEEE_RECORD (rounding
          // and precision already filled in)

          FpieeeRecord.Operand1.Format = _FpFormatFp82; /* 1 + 8 + 24 bits */
          FpieeeRecord.Operand1.OperandValid = 1;
          FpieeeRecord.Operand1.Value.Fp128Value = FP32ToFP128 (LowHalf(FR2));
          FpieeeRecord.Operand2.OperandValid = 0;
          FpieeeRecord.Operand3.OperandValid = 0;

          FpieeeRecord.Result.Format = ResultFormat;
          FpieeeRecord.Result.OperandValid = 0;

          FpieeeRecord.Operation = Operation;

          FpieeeRecord.Status.Inexact = LowStatus.Inexact;
          FpieeeRecord.Status.Underflow = LowStatus.Underflow;
          FpieeeRecord.Status.Overflow = LowStatus.Overflow;
          FpieeeRecord.Status.ZeroDivide = LowStatus.ZeroDivide;
          FpieeeRecord.Status.InvalidOperation = LowStatus.InvalidOperation;

          FpieeeRecord.Cause.Inexact = LowCause.Inexact;
          FpieeeRecord.Cause.Underflow = LowCause.Underflow;
          FpieeeRecord.Cause.Overflow = LowCause.Overflow;
          FpieeeRecord.Cause.ZeroDivide = LowCause.ZeroDivide;
          FpieeeRecord.Cause.InvalidOperation = LowCause.InvalidOperation;

          // invoke the user-defined exception handler
          handler_return_value = handler (&FpieeeRecord);

          // return if not EXCEPTION_CONTINUE_EXECUTION
          if (handler_return_value != EXCEPTION_CONTINUE_EXECUTION) {

            __set_fpsr (&old_fpsr); /* restore caller fpsr */
            return (handler_return_value);

          }

          // clear the IEEE exception flags in the FPSR and
          // update the FPSR with values (possibly) set by the user handler
          // for the rounding mode, the precision mode, and the trap enable
          // bits; if the high half needs to be re-executed, the new FPSR
          // will be used, with status flags cleared; if it is 
          // forwarded to the user-defined handler, the new rounding and 
          // precision modes are also used (they are
          // already set in FpieeeRecord)

          UpdateRoundingMode (FpieeeRecord.RoundingMode, sf, &FPSR, "F10");
          UpdatePrecision (FpieeeRecord.Precision, sf, &FPSR, "F10");

          // Update the trap disable bits
          I_dis = !FpieeeRecord.Enable.Inexact;
          U_dis = !FpieeeRecord.Enable.Underflow;
          O_dis = !FpieeeRecord.Enable.Overflow;
          Z_dis = !FpieeeRecord.Enable.ZeroDivide;
          V_dis = !FpieeeRecord.Enable.InvalidOperation;

          FPSR = FPSR & ~((unsigned __int64)0x03d) | (unsigned __int64)(I_dis 
              << 5 | U_dis << 4 | O_dis << 3 | Z_dis << 2 | V_dis);

          // save the result for the low half
          switch (OpCode & F10_MASK) {

            case FPCVT_FX_TRUNC_PATTERN:
            case FPCVT_FX_PATTERN:
              I32Low = FpieeeRecord.Result.Value.I32Value;
              break;

            case FPCVT_FXU_TRUNC_PATTERN:
            case FPCVT_FXU_PATTERN:
              U32Low = FpieeeRecord.Result.Value.U32Value;
              // break;

            // default: this case caught above

          }

          // since there has been a call to the user handler and FPSR might
          // have changed (the Enable bits in particular), recalculate the 
          // Cause bits (if the HighEnable-s changed, there might be a 
          // change in the HighCause values) 
          // Note that the Status bits used are the original ones

          HighCause.Inexact = 0;
          HighCause.Underflow = 0;
          HighCause.Overflow = 0;
          HighCause.ZeroDivide =
              FpieeeRecord.Enable.ZeroDivide && HighStatus.ZeroDivide;
          HighCauseDenormal = EnableDenormal && HighStatusDenormal;
          HighCause.InvalidOperation =
              FpieeeRecord.Enable.InvalidOperation &&
              HighStatus.InvalidOperation;
          // Note: the user handler does not affect the denormal enable bit

        } else if (LowCause.ZeroDivide) {

          fprintf (stderr, "IEEE Filter Internal Error: \
              LowCause.ZeroDivide in F10 instruction\n");
          exit (1);

        } else { // if not (LowCause.InvalidOperation || LowCauseDenormal ||
            // LowCause.ZeroDivide)

          // re-execute the low half of the instruction

          // modify the high half of FR2
          newFR2 = Combine ((float)0.0, LowHalf (FR2));

          switch (OpCode & F10_MASK) {

            case FPCVT_FX_TRUNC_PATTERN:
              _xrun1args (FPCVT_FX_TRUNC, &FPSR, &FR1, &newFR2);
              break;

            case FPCVT_FXU_TRUNC_PATTERN:
              _xrun1args (FPCVT_FXU_TRUNC, &FPSR, &FR1, &newFR2);
              break;

            case FPCVT_FX_PATTERN:
              _xrun1args (FPCVT_FX, &FPSR, &FR1, &newFR2);
              break;

            case FPCVT_FXU_PATTERN:
              _xrun1args (FPCVT_FXU, &FPSR, &FR1, &newFR2);
              break;

            default: ; // this case was caught above

          }

          switch (OpCode & F10_MASK) {

            case FPCVT_FX_TRUNC_PATTERN:
            case FPCVT_FX_PATTERN:
              I32Low = I32LowHalf (FR1);
              break;

            case FPCVT_FXU_TRUNC_PATTERN:
            case FPCVT_FXU_PATTERN:
              U32Low = U32LowHalf (FR1);
              // break;

            default: ; // this case was caught above

          }

        } // end 'if not (LowCause.InvalidOperation || LowCauseDenormal ||
            // LowCause.ZeroDivide)'

        if (HighCause.InvalidOperation || HighCauseDenormal) {

          // invoke the user-defined exception handler and check the return 
          // value; since this might be the second call to the user handler,
          // make sure all the _FPIEEE_RECORD fields are correct;
          // return if handler_return_value is not
          // EXCEPTION_CONTINUE_EXECUTION, otherwise combine the results

          // the rounding mode is either the initial one, or the one
          // set during the call to the user handler for the low half,
          // if there has been an enabled exception for it

          // the precision mode is either the initial one, or the one
          // set during the call to the user handler for the low half,
          // if there has been an enabled exception for it

          // the enable flags are either the initial ones, or the ones
          // set during the call to the user handler for the low half,
          // if there has been an enabled exception for it

          FpieeeRecord.Operand1.Format = _FpFormatFp82; /* 1+8+24 bits */
          FpieeeRecord.Operand1.OperandValid = 1;
          FpieeeRecord.Operand1.Value.Fp128Value = FP32ToFP128(HighHalf(FR2));
          FpieeeRecord.Operand2.OperandValid = 0;
          FpieeeRecord.Operand3.OperandValid = 0;

          FpieeeRecord.Result.Format = ResultFormat;
          FpieeeRecord.Result.OperandValid = 0;

          FpieeeRecord.Operation = Operation;

          FpieeeRecord.Status.Inexact = HighStatus.Inexact;
          FpieeeRecord.Status.Underflow = HighStatus.Underflow;
          FpieeeRecord.Status.Overflow = HighStatus.Overflow;
          FpieeeRecord.Status.ZeroDivide = HighStatus.ZeroDivide;
          StatusDenormal = HighStatusDenormal;
          FpieeeRecord.Status.InvalidOperation = HighStatus.InvalidOperation;

          FpieeeRecord.Cause.Inexact = HighCause.Inexact;
          FpieeeRecord.Cause.Underflow = HighCause.Underflow;
          FpieeeRecord.Cause.Overflow = HighCause.Overflow;
          FpieeeRecord.Cause.ZeroDivide = HighCause.ZeroDivide;
          CauseDenormal = HighCauseDenormal;
          FpieeeRecord.Cause.InvalidOperation = HighCause.InvalidOperation;

          // invoke the user-defined exception handler
          handler_return_value = handler (&FpieeeRecord);

          // return if not EXCEPTION_CONTINUE_EXECUTION
          if (handler_return_value != EXCEPTION_CONTINUE_EXECUTION) {

            __set_fpsr (&old_fpsr); /* restore caller fpsr */
            return (handler_return_value);

          }

          // clear the IEEE exception flags in the FPSR and
          // update the FPSR with values (possibly) set by the user handler
          // for the rounding mode, the precision mode, and the trap enable
          // bits

          /* change the FPSR with values (possibly) set by the user handler,
           * for continuing execution where the interruption occured */
  
          UpdateRoundingMode (FpieeeRecord.RoundingMode, sf, &FPSR, "F10");
          UpdatePrecision (FpieeeRecord.Precision, sf, &FPSR, "F10");

          // update the trap disable bits
          I_dis = !FpieeeRecord.Enable.Inexact;
          U_dis = !FpieeeRecord.Enable.Underflow;
          O_dis = !FpieeeRecord.Enable.Overflow;
          Z_dis = !FpieeeRecord.Enable.ZeroDivide;
          V_dis = !FpieeeRecord.Enable.InvalidOperation;

          FPSR = FPSR & ~((unsigned __int64)0x03d) | (unsigned __int64)(I_dis 
              << 5 | U_dis << 4 | O_dis << 3 | Z_dis << 2 | V_dis);

          // save the result for the high half
          switch (OpCode & F10_MASK) {

            case FPCVT_FX_TRUNC_PATTERN:
            case FPCVT_FX_PATTERN:
              I32High = FpieeeRecord.Result.Value.I32Value;
              break;

            case FPCVT_FXU_TRUNC_PATTERN:
            case FPCVT_FXU_PATTERN:
              U32High = FpieeeRecord.Result.Value.U32Value;
              // break;

            default: ; // this case was caught above

          }

        } else if (HighCause.ZeroDivide) {

          fprintf (stderr, "IEEE Filter Internal Error: \
              HighCause.ZeroDivide in F10 instruction\n");
          exit (1);

        } else { //if not (HighCause.InvalidOperation || HighCauseDenormal ||
           // HighCause.ZeroDivide)

          // re-execute the high half of the instruction

          // modify the low half of FR2
          newFR2 = Combine (HighHalf (FR2), (float)0.0);

          switch (OpCode & F10_MASK) {

            case FPCVT_FX_TRUNC_PATTERN:
              _xrun1args (FPCVT_FX_TRUNC, &FPSR, &FR1, &newFR2);
              break;

            case FPCVT_FXU_TRUNC_PATTERN:
              _xrun1args (FPCVT_FXU_TRUNC, &FPSR, &FR1, &newFR2);
              break;

            case FPCVT_FX_PATTERN:
              _xrun1args (FPCVT_FX, &FPSR, &FR1, &newFR2);
              break;

            case FPCVT_FXU_PATTERN:
              _xrun1args (FPCVT_FXU, &FPSR, &FR1, &newFR2);
              // break;

            default: ; // this case was caught above

          }

          switch (OpCode & F10_MASK) {

            case FPCVT_FX_TRUNC_PATTERN:
            case FPCVT_FX_PATTERN:
              I32High = I32HighHalf (FR1);
              break;

            case FPCVT_FXU_TRUNC_PATTERN:
            case FPCVT_FXU_PATTERN:
              U32High = U32HighHalf (FR1);
              // break;

            default: ; // this case was caught above

          }

        } // end 'if not (HighCause.InvalidOperation || HighCauseDenormal ||
            // HighCause.ZeroDivide)'

        if (!LowCause.InvalidOperation && !LowCauseDenormal &&
            !HighCause.InvalidOperation && !HighCauseDenormal) {

          // should never get here
          fprintf (stderr, "IEEE Filter Internal Error: no enabled \
              exception (multiple fault) recognized in F10 instruction\n");
          exit (1);

        }

        Context->StFPSR = FPSR;

        // set the result before continuing execution
        switch (OpCode & F10_MASK) {

          case FPCVT_FX_TRUNC_PATTERN:
          case FPCVT_FX_PATTERN:
            FR1 = I32Combine (I32High, I32Low);
            break;

          case FPCVT_FXU_TRUNC_PATTERN:
          case FPCVT_FXU_PATTERN:
            FR1 = U32Combine (U32High, U32Low);
            // break;

          default: ; // this case was caught above

        }

        // set the result before continuing execution
        SetFloatRegisterValue (f1, FR1, Context);
        if (f1 < 32)
          Context->StIPSR = Context->StIPSR | (unsigned __int64)0x10; //set mfl
        else
          Context->StIPSR = Context->StIPSR | (unsigned __int64)0x20; //set mfh

        // this is a fault; need to advance the instruction pointer
        if (ei == 0) { // no template for this case
          Context->StIPSR = Context->StIPSR & 0xfffff9ffffffffff;
          Context->StIPSR = Context->StIPSR | 0x0000020000000000;
        } else if (ei == 1) { // templates: MFI, MFB
          Context->StIPSR = Context->StIPSR & 0xfffff9ffffffffff;
          Context->StIPSR = Context->StIPSR | 0x0000040000000000;
        } else { // if (ei == 2) // templates: MMF
          Context->StIPSR = Context->StIPSR & 0xfffff9ffffffffff;
          Context->StIIP = Context->StIIP + 0x10;
        }

      } else if (eXceptionCode == STATUS_FLOAT_MULTIPLE_TRAPS) {

        // Note that the convention chosen is for the processing to be 
        // performed in the order low first, high second, as SIMD operands
        // are stored in this order in memory in the little endian format
        // (this order would have to be changed for big endian); unlike
        // in the case of multiple faults, where execution of the user
        // exception handler for the low half could determine changes in
        // the high half, for traps in the high half, the rounding mode, 
        // precision mode, and trap enable bits are the initial ones (as
        // there is not enough information available to always adjust
        // correctly the result and/or the status flags after changes in
        // rounding mode and/or trap enable bits during a call to the
        // user-defined exception handler for the low half of the SIMD
        // instruction); the modifications to the FPSR are ONLY those 
        // performed by the last call to the user defined exception handler

        // this is a trap - get the result
        FR1 = GetFloatRegisterValue (f1, Context);

        if (LowCause.Inexact) {

          // invoke the user handler and check the return value

          // fill in the remaining fields of the _FPIEEE_RECORD (rounding
          // and precision already filled in)

          FpieeeRecord.Operand1.Format = _FpFormatFp32; /* 1 + 8 + 24 bits */
          FpieeeRecord.Operand1.OperandValid = 1;
          FpieeeRecord.Operand1.Value.Fp32Value = LowHalf (FR2);
          FpieeeRecord.Operand2.OperandValid = 0;
          FpieeeRecord.Operand3.OperandValid = 0;

          switch (OpCode & F10_MASK) {

            case FPCVT_FX_TRUNC_PATTERN:
            case FPCVT_FX_PATTERN:
              FpieeeRecord.Result.Value.I32Value = I32LowHalf (FR1);
              break;

            case FPCVT_FXU_TRUNC_PATTERN:
            case FPCVT_FXU_PATTERN:
              FpieeeRecord.Result.Value.U32Value = U32LowHalf (FR1);
              // break;

            // default: this case caught above

          }
          FpieeeRecord.Result.Format = ResultFormat;
          FpieeeRecord.Result.OperandValid = 1;

          FpieeeRecord.Operation = Operation;

          FpieeeRecord.Status.Inexact = LowStatus.Inexact;
          FpieeeRecord.Status.Underflow = LowStatus.Underflow;
          FpieeeRecord.Status.Overflow = LowStatus.Overflow;
          FpieeeRecord.Status.ZeroDivide = LowStatus.ZeroDivide;
          StatusDenormal = LowStatusDenormal;
          FpieeeRecord.Status.InvalidOperation = LowStatus.InvalidOperation;

          FpieeeRecord.Cause.Inexact = LowCause.Inexact;
          FpieeeRecord.Cause.Underflow = LowCause.Underflow;
          FpieeeRecord.Cause.Overflow = LowCause.Overflow;
          FpieeeRecord.Cause.ZeroDivide = LowCause.ZeroDivide;
          CauseDenormal = LowCauseDenormal;
          FpieeeRecord.Cause.InvalidOperation = LowCause.InvalidOperation;

          // invoke the user-defined exception handler
          handler_return_value = handler (&FpieeeRecord);

          // return if not EXCEPTION_CONTINUE_EXECUTION
          if (handler_return_value != EXCEPTION_CONTINUE_EXECUTION) {

            __set_fpsr (&old_fpsr); /* restore caller fpsr */
            return (handler_return_value);

          }

          // clear the IEEE exception flags in the FPSR and
          // update the FPSR with values (possibly) set by the user handler
          // for the rounding mode, the precision mode, and the trap enable
          // bits; if the high half needs to be re-executed, the old FPSR
          // will be used; same if it is forwarded to the user-defined handler

          UpdateRoundingMode (FpieeeRecord.RoundingMode, sf, &FPSR, "F10");
          UpdatePrecision (FpieeeRecord.Precision, sf, &FPSR, "F10");

          // Update the trap disable bits
          I_dis = !FpieeeRecord.Enable.Inexact;
          U_dis = !FpieeeRecord.Enable.Underflow;
          O_dis = !FpieeeRecord.Enable.Overflow;
          Z_dis = !FpieeeRecord.Enable.ZeroDivide;
          V_dis = !FpieeeRecord.Enable.InvalidOperation;

          FPSR = FPSR & ~((unsigned __int64)0x03d) | (unsigned __int64)(I_dis 
              << 5 | U_dis << 4 | O_dis << 3 | Z_dis << 2 | V_dis);

          // save the result for the low half
          switch (OpCode & F10_MASK) {

            case FPCVT_FX_TRUNC_PATTERN:
            case FPCVT_FX_PATTERN:
              I32Low = FpieeeRecord.Result.Value.I32Value;
              break;

            case FPCVT_FXU_TRUNC_PATTERN:
            case FPCVT_FXU_PATTERN:
              U32Low = FpieeeRecord.Result.Value.U32Value;
              // break;

            default: ; // this case was caught above

          }

        } else if (LowCause.Underflow || LowCause.Overflow) {

          fprintf (stderr, "IEEE Filter Internal Error: \
              LowCause.Underflow or LowCause.Overflow in F10 instruction\n");
          exit (1);

        } else { // if not (LowCause.Inexact, Underflow, or Overflow)

          // nothing to do for the low half of the instruction - the result
          // is correct
          switch (OpCode & F10_MASK) {

            case FPCVT_FX_TRUNC_PATTERN:
            case FPCVT_FX_PATTERN:
              I32Low = I32LowHalf (FR1); // for uniformity
              break;

            case FPCVT_FXU_TRUNC_PATTERN:
            case FPCVT_FXU_PATTERN:
              U32Low = U32LowHalf (FR1); // for uniformity
              // break;

            default: ; // this case was caught above

          }

        } // end 'if not (LowCause.Underflow, Overflow, Inexact)'

        if (HighCause.Inexact) {

          // invoke the user-defined exception handler and check the return 
          // value; since this might be the second call to the user handler,
          // make sure all the _FPIEEE_RECORD fields are correct;
          // return if handler_return_value is not 
          // EXCEPTION_CONTINUE_EXECUTION, otherwise combine the results

          // the rounding mode is the initial one
          FpieeeRecord.RoundingMode = RoundingMode;

          // the precision mode is the initial one
          FpieeeRecord.Precision = Precision;

          // the enable flags are the initial ones
          FPSR = Context->StFPSR;
          I_dis = sf != 0 && ((FPSR >> (6 + 6 + 13 * sf)) & 0x01) 
              || ((FPSR >> 5) & 0x01);
          U_dis = sf != 0 && ((FPSR >> (6 + 6 + 13 * sf)) & 0x01) 
              || ((FPSR >> 4) & 0x01);
          O_dis = sf != 0 && ((FPSR >> (6 + 6 + 13 * sf)) & 0x01) 
              || ((FPSR >> 3) & 0x01);
          Z_dis = sf != 0 && ((FPSR >> (6 + 6 + 13 * sf)) & 0x01) 
              || ((FPSR >> 2) & 0x01);
          D_dis = sf != 0 && ((FPSR >> (6 + 6 + 13 * sf)) & 0x01) 
              || ((FPSR >> 1) & 0x01);
          V_dis = sf != 0 && ((FPSR >> (6 + 6 + 13 * sf)) & 0x01) 
              || ((FPSR >> 0) & 0x01);

          FpieeeRecord.Enable.Inexact = !I_dis;
          FpieeeRecord.Enable.Underflow = !U_dis;
          FpieeeRecord.Enable.Overflow = !O_dis;
          FpieeeRecord.Enable.ZeroDivide = !Z_dis;
          EnableDenormal = !D_dis;
          FpieeeRecord.Enable.InvalidOperation = !V_dis;

          FpieeeRecord.Operand1.Format = _FpFormatFp32; /* 1+8+24 bits */
          FpieeeRecord.Operand1.OperandValid = 1;
          FpieeeRecord.Operand1.Value.Fp32Value = HighHalf (FR2);
          FpieeeRecord.Operand2.OperandValid = 0;
          FpieeeRecord.Operand3.OperandValid = 0;

          switch (OpCode & F10_MASK) {

            case FPCVT_FX_TRUNC_PATTERN:
            case FPCVT_FX_PATTERN:
              FpieeeRecord.Result.Value.I32Value = I32HighHalf (FR1);
              break;

            case FPCVT_FXU_TRUNC_PATTERN:
            case FPCVT_FXU_PATTERN:
              FpieeeRecord.Result.Value.U32Value = U32HighHalf (FR1);
              // break;

            // default: this case caught above

          }
          FpieeeRecord.Result.Format = ResultFormat;
          FpieeeRecord.Result.OperandValid = 1;

          FpieeeRecord.Operation = Operation;

          // use the initial values
          FpieeeRecord.Status.Inexact = HighStatus.Inexact;
          FpieeeRecord.Status.Underflow = HighStatus.Underflow;
          FpieeeRecord.Status.Overflow = HighStatus.Overflow;
          FpieeeRecord.Status.ZeroDivide = HighStatus.ZeroDivide;
          StatusDenormal = HighStatusDenormal;
          FpieeeRecord.Status.InvalidOperation = HighStatus.InvalidOperation;

          FpieeeRecord.Cause.Inexact = HighCause.Inexact;
          FpieeeRecord.Cause.Underflow = HighCause.Underflow;
          FpieeeRecord.Cause.Overflow = HighCause.Overflow;
          FpieeeRecord.Cause.ZeroDivide = HighCause.ZeroDivide;
          CauseDenormal = HighCauseDenormal;
          FpieeeRecord.Cause.InvalidOperation = HighCause.InvalidOperation;

          // invoke the user-defined exception handler
          handler_return_value = handler (&FpieeeRecord);

          // return if not EXCEPTION_CONTINUE_EXECUTION
          if (handler_return_value != EXCEPTION_CONTINUE_EXECUTION) {

            __set_fpsr (&old_fpsr); /* restore caller fpsr */
            return (handler_return_value);

          }

          // clear the IEEE exception flags in the FPSR;
          // update the FPSR with values (possibly) set by the user handler
          // for the rounding mode, the precision mode, and the trap enable
          // bits, before continuing execution where the interruption occured
          UpdateRoundingMode (FpieeeRecord.RoundingMode, sf, &FPSR, "F10");
          UpdatePrecision (FpieeeRecord.Precision, sf, &FPSR, "F10");

          I_dis = !FpieeeRecord.Enable.Inexact;
          U_dis = !FpieeeRecord.Enable.Underflow;
          O_dis = !FpieeeRecord.Enable.Overflow;
          Z_dis = !FpieeeRecord.Enable.ZeroDivide;
          V_dis = !FpieeeRecord.Enable.InvalidOperation;

          FPSR = FPSR & ~((unsigned __int64)0x03d) | (unsigned __int64)(I_dis 
              << 5 | U_dis << 4 | O_dis << 3 | Z_dis << 2 | V_dis);

          // save the result for the high half
          switch (OpCode & F10_MASK) {

            case FPCVT_FX_TRUNC_PATTERN:
            case FPCVT_FX_PATTERN:
              I32High = FpieeeRecord.Result.Value.I32Value;
              break;

            case FPCVT_FXU_TRUNC_PATTERN:
            case FPCVT_FXU_PATTERN:
              U32High = FpieeeRecord.Result.Value.U32Value;
              // break;

            default: ; // this case was caught above

          }

        } else if (HighCause.Underflow || HighCause.Overflow) {

          fprintf (stderr, "IEEE Filter Internal Error: \
             HighCause.Underflow or HighCause.Overflow in F10 instruction\n");
          exit (1);

        } else { // if not (HighCause.Inexact, Underflow, or Overflow)

          // nothing to do for the high half of the instruction - the result
          // is correct
          switch (OpCode & F10_MASK) {

            case FPCVT_FX_TRUNC_PATTERN:
            case FPCVT_FX_PATTERN:
              I32High = I32HighHalf (FR1); // for uniformity
              break;

            case FPCVT_FXU_TRUNC_PATTERN:
            case FPCVT_FXU_PATTERN:
              U32High = U32HighHalf (FR1); // for uniformity
              // break;

            default: ; // this case was caught above

          }

        } // end 'if not (HighCause.Underflow, Overflow, or Inexact)'

        if (!LowCause.Inexact && !HighCause.Inexact) {

          // should never get here
          fprintf (stderr, "IEEE Filter Internal Error: no enabled \
              [multiple trap] exception recognized in F10 instruction\n");
          exit (1);

        }

        Context->StFPSR = FPSR;

        // set the result before continuing execution
        switch (OpCode & F10_MASK) {

          case FPCVT_FX_TRUNC_PATTERN:
          case FPCVT_FX_PATTERN:
            FR1 = I32Combine (I32High, I32Low);
            break;

          case FPCVT_FXU_TRUNC_PATTERN:
          case FPCVT_FXU_PATTERN:
            FR1 = U32Combine (U32High, U32Low);
            // break;

          default: ; // this case was caught above

        }

        // set the result before continuing execution
        SetFloatRegisterValue (f1, FR1, Context);
        if (f1 < 32)
          Context->StIPSR = Context->StIPSR | (unsigned __int64)0x10; //set mfl
        else
          Context->StIPSR = Context->StIPSR | (unsigned __int64)0x20; //set mfh

      } else {

        fprintf (stderr, "IEEE Filter Internal Error: exception \
            code %x invalid or not recognized in F10 SIMD instruction\n",
            eXceptionCode);
        exit (1);

      }

    }

  } else {

    /* unrecognized instruction type */
    fprintf (stderr, "IEEE Filter Internal Error: \
 instruction opcode %8x %8x not recognized\n", 
        (int)(OpCode >> 32) & 0xffffffff, (int)OpCode & 0xffffffff);
    exit (1);

  }

  /* the context record contains at this point the result(s) */
  __set_fpsr (&old_fpsr); /* restore caller fpsr */

  return (handler_return_value);

}




static _FP128
FPIeeeToFP128 (_FPIEEE_RECORD *pFpieeeRecord)

{

  _FP128 ReturnValue;

  unsigned __int64 significand;
  unsigned int exponent;
  unsigned int sign;
  _FP32 f32;
  _FP64 f64;
  _FP80 f80;
  unsigned int u32;
  unsigned __int64 u64;
  unsigned __int64 *pu64;
  char *p;


  // expand the result in the FPIEEE record to 1 + 17 + 64 = 82 bits; write
  // then in memory spill format, and return value

  switch (pFpieeeRecord->Result.Format) {

    case _FpFormatFp32: 
      // 1 + 8 + 24 bits, for _FpPrecision24
      // got _FP32 Fp32Value (float)
      f32 = pFpieeeRecord->Result.Value.Fp32Value;
      u32 = *((unsigned int *)&f32);
      sign = u32 >> 31;
      exponent = (u32 >> 23) & 0x0ff; // cut off the sign bit
      if (exponent == 0x0ff) {
        exponent = 0x01ffff; // special value
      } else if (exponent != 0) {
        exponent = exponent - 0x07f + 0x0ffff;
      }
      significand = ((unsigned __int64)(u32 & 0x07fffff) << 40); 
          // cut 23 bits and shift left
      if (exponent != 0) { 
        significand = (((unsigned __int64)1) << 63) | significand; 
          // not denormal - add J-bit
      }
#ifdef FPIEEE_FLT_DEBUG
      printf ("FPIEEE_FLT_DEBUG FPIeeeToFP128 32 sign exp signif =\
 %x %x %8x %8x\n", sign, exponent, 
          (int)(significand >> 32) & 0xffffffff, (int)significand & 0xffffffff);
#endif
      break;

    case _FpFormatFp64: 
      // 1 + 11 + 53 bits, for _FpPrecision53
      // got _FP64 Fp64Value (double)
      f64 = pFpieeeRecord->Result.Value.Fp64Value;
      u64 = *((unsigned __int64 *)&f64);
      sign = (unsigned int)(u64 >> 63);
      exponent = (unsigned int)((u64 >> 52) & 0x07ff); // cut off the sign bit
      significand = ((u64 & 0x0fffffffffffff) << 11);
          // cut 52 bits and shift left
      if (exponent == 0x07ff) { // special value
        exponent = 0x01ffff;
        significand = (((unsigned __int64)1) << 63) | significand;
      } else if (exponent == 0 && significand != (unsigned __int64)0) { // denormal
        exponent = 0xfc01;
      } else if (exponent != 0) {
        exponent = exponent - 0x03ff + 0x0ffff;
        significand = (((unsigned __int64)1) << 63) | significand;
      }
#ifdef FPIEEE_FLT_DEBUG
      printf ("FPIEEE_FLT_DEBUG FPIeeeToFP128 64 sign exp signif =\
 %x %x %8x %8x\n", sign, exponent, 
          (int)(significand >> 32) & 0xffffffff, (int)significand & 0xffffffff);
#endif
      break;

    case _FpFormatFp80: 
      // 1 + 15 + 24 bits if _FpPrecision24
      // 1 + 15 + 53 bits if _FpPrecision53
      // 1 + 15 + 64 bits if _FpPrecision64
      // got _FP80 Fp80Value (typedef struct { unsigned short W[5] })
      f80 = pFpieeeRecord->Result.Value.Fp80Value;
      sign = (f80.W[4] >> 15) & 0x01;
      exponent = f80.W[4] & 0x07fff; // cut off the sign bit
      pu64 = (unsigned __int64 *)&f80;
      significand = *pu64;
      if (exponent == 0x07fff) {
        exponent = 0x01ffff; // special value
      } else if (exponent == 0 && significand != (unsigned __int64)0) {
          // denormal
        ; // exponent remains 0x0 rather than 0xc001
      } else if (exponent != 0) {
        exponent = exponent - 0x03fff + 0x0ffff;
      }
#ifdef FPIEEE_FLT_DEBUG
      printf ("FPIEEE_FLT_DEBUG FPIeeeToFP128 80 sign exp signif =\
 %x %x %8x %8x\n", sign, exponent, 
          (int)(significand >> 32) & 0xffffffff, (int)significand & 0xffffffff);
#endif
      break;

    case _FpFormatFp82: 
      // 1 + 17 + 24 bits if _FpPrecision24
      // 1 + 17 + 53 bits if _FpPrecision53
      // 1 + 17 + 64 bits if _FpPrecision64
      // got _FP128 Fp128Value (typedef struct { unsigned __int64 W[4] })
      ReturnValue = pFpieeeRecord->Result.Value.Fp128Value;
#ifdef FPIEEE_FLT_DEBUG
      printf ("FPIEEE_FLT_DEBUG FPIeeeToFP128: RetVal = %08x %08x %08x %08x\n",
          ReturnValue.W[3], ReturnValue.W[2], 
          ReturnValue.W[1], ReturnValue.W[0]);
#endif
      return (ReturnValue);
      break;

    default:
      // should never get here: unrecognized pFpieeeRecord->Result.Format
      fprintf (stderr, "FPIeeeToFP128 () Error: \
          pFpieeeRecord->Result.Format %x not recognized\n", 
          pFpieeeRecord->Result.Format);
      exit (1);

  }

  p = (char *)(&ReturnValue);
  memcpy (p, (char *)&significand, 8);
  p[8] = exponent & 0x0ff;
  p[9] = (exponent >> 8) & 0x0ff;
  p[10] = (exponent >> 16) | (sign << 1);
  p[11] = 0;
  p[12] = 0;
  p[13] = 0;
  p[14] = 0;
  p[15] = 0;

#ifdef FPIEEE_FLT_DEBUG
  printf ("FPIEEE_FLT_DEBUG FPIeeeToFP128: ReturnValue = %08x %08x %08x %08x\n",
      ReturnValue.W[3], ReturnValue.W[2], ReturnValue.W[1], ReturnValue.W[0]);
#endif

  return (ReturnValue);

}




static void 
FP128ToFPIeee (_FPIEEE_RECORD *pFpieeeRecord, int scale)

{

  // called for O, U, or I; the result, a valid number, is received always in 
  // pFpieeeRecord->Result.Value.Fp128Value; it is scaled (if necessary), and
  // put into the Result.Format; effective only 32, 64, 80, and 82-bit formats

  unsigned __int64 significand;
  unsigned int exponent;
  unsigned int sign;
  _FP32 f32;
  _FP64 f64;
  unsigned int u32;
  unsigned __int64 u64;


  switch (pFpieeeRecord->Result.Format) {
    case _FpFormatFp32:
    case _FpFormatFp64:
    case _FpFormatFp80:
    case _FpFormatFp82:
      // extract sign, exponent, and significand
      sign = ((pFpieeeRecord->Result.Value.Fp128Value.W[2] & 0x020000) != 0);
      exponent = pFpieeeRecord->Result.Value.Fp128Value.W[2] & 0x1ffff;
      significand = 
          ((__int64)(pFpieeeRecord->Result.Value.Fp128Value.W[1])) << 32 |
          (((__int64)pFpieeeRecord->Result.Value.Fp128Value.W[0]) & 0xffffffff);
	  if(pFpieeeRecord->Result.Format==_FpFormatFp80 && exponent==0 && significand!=0) exponent=0xc001;
      break;
    default:
      // error - should never get here
      fprintf (stderr, "FP128ToFPIeee () Internal Error: \
          Result.Format %x not recognized\n", pFpieeeRecord->Result.Format);
      exit (1);
  }

  if (exponent == 0 && significand == (__int64)0) { // if the result is zero
    if(!sign) { // if the sign bit is 0, return positive 0 
      switch (pFpieeeRecord->Result.Format) {
        case _FpFormatFp32:  
          u32=0x0;
          pFpieeeRecord->Result.Value.Fp32Value = *((_FP32 *)&u32);
          break;
        case _FpFormatFp64:
          u64 = (__int64)0x0;
          pFpieeeRecord->Result.Value.Fp64Value = *((_FP64 *)&u64);
          break;
        case _FpFormatFp80:
          pFpieeeRecord->Result.Value.Fp80Value.W[4] =  0x0;
          pFpieeeRecord->Result.Value.Fp80Value.W[3] =  0x0;
          pFpieeeRecord->Result.Value.Fp80Value.W[2] =  0x0;
          pFpieeeRecord->Result.Value.Fp80Value.W[1] =  0x0;
          pFpieeeRecord->Result.Value.Fp80Value.W[0] =  0x0;
          break;
        case _FpFormatFp82:
          ; // do nothing, the positive 0 is already there
      }
    } else { // return negative 0 otherwise
      switch (pFpieeeRecord->Result.Format) {
        case _FpFormatFp32:  
          u32=0x80000000;
          pFpieeeRecord->Result.Value.Fp32Value = *((_FP32 *)&u32);
          break;
        case _FpFormatFp64:
          u64 = (((__int64)1) << 63);
          pFpieeeRecord->Result.Value.Fp64Value = *((_FP64 *)&u64);
          break;
        case _FpFormatFp80:
          pFpieeeRecord->Result.Value.Fp80Value.W[4] =  0x8000;
          pFpieeeRecord->Result.Value.Fp80Value.W[3] =  0x0;
          pFpieeeRecord->Result.Value.Fp80Value.W[2] =  0x0;
          pFpieeeRecord->Result.Value.Fp80Value.W[1] =  0x0;
          pFpieeeRecord->Result.Value.Fp80Value.W[0] =  0x0;
          break;
        case _FpFormatFp82:
          ; // do nothing, the negative 0 is already there
      }
    }
    return;
  } 

  if (!pFpieeeRecord->Cause.Overflow && !pFpieeeRecord->Cause.Underflow &&
      (exponent == 0x1ffff)) { // if the result is infinity for inexact exc.
    // if the sign bit is 0, return positive infinity
    if(!sign) { // if positive
      switch (pFpieeeRecord->Result.Format) {
        case _FpFormatFp32:  
          u32=0x7f800000;
          pFpieeeRecord->Result.Value.Fp32Value = *((_FP32 *)&u32);
          break;
        case _FpFormatFp64:
          u64 = 0x7ff0000000000000;
          pFpieeeRecord->Result.Value.Fp64Value = *((_FP64 *)&u64);
          break;
        case _FpFormatFp80:
          pFpieeeRecord->Result.Value.Fp80Value.W[4] =  0x7fff;
          pFpieeeRecord->Result.Value.Fp80Value.W[3] =  0x8000;
          pFpieeeRecord->Result.Value.Fp80Value.W[2] =  0x0;
          pFpieeeRecord->Result.Value.Fp80Value.W[1] =  0x0;
          pFpieeeRecord->Result.Value.Fp80Value.W[0] =  0x0;
          break;
        case _FpFormatFp82:
          ; // do nothing, the positive infinity is already there
      }
    } else { // return negative infinity
      switch (pFpieeeRecord->Result.Format) {
        case _FpFormatFp32:  
          u32=0xff800000;
          pFpieeeRecord->Result.Value.Fp32Value = *((_FP32 *)&u32);
          break;
        case _FpFormatFp64:
          u64 = 0xfff0000000000000;
          pFpieeeRecord->Result.Value.Fp64Value = *((_FP64 *)&u64);
          break;
        case _FpFormatFp80:
          pFpieeeRecord->Result.Value.Fp80Value.W[4] =  0xffff;
          pFpieeeRecord->Result.Value.Fp80Value.W[3] =  0x8000;
          pFpieeeRecord->Result.Value.Fp80Value.W[2] =  0x0;
          pFpieeeRecord->Result.Value.Fp80Value.W[1] =  0x0;
          pFpieeeRecord->Result.Value.Fp80Value.W[0] =  0x0;
          break;
        case _FpFormatFp82:
          ; // do nothing, the negative infinity is already there
      }
    }
    return;
  } 

  // adjust exponent
  // for any operands of fma, 2^(2e_min-2N+2) <= exp (fma) <= 2^(2e_max+2)
  // (same for fms, fnma, fpma, fpms, fpnma)
  switch (pFpieeeRecord->Result.Format) {
	  /* Exponent range for divide: bias+2*EMIN-PREC<=exponent<=bias+2*EMAX+PREC-2 */
    case _FpFormatFp32:
      if ((0xffff-2*(126+23)) <= exponent && exponent <= (0xffff+2*127+22)) {
        // all the valid results from operations on single precision floating-
        // point numbers fit in this range 0xfed5 <= exponent <= 0x100fe
        scale = scale * 192; // 192 = 3/4 * 2^8
        exponent += scale;	
      } else {
        // pFpieeeRecord->Result.Format = _FpFormatFp82 in conjunction (for
        // example) with _FpCodeFmaSingle (which expects 
        // pFpieeeRecord->Result.Format = _FpFormatFp32) will indicate that
        // the result is outside the range where it can be scaled as required
        // by the IEEE standard
        pFpieeeRecord->Result.Format = _FpFormatFp82;
		/* comment out warnings for confidence tests */
        /*printf ("IEEE FILTER fpieee_flt () / FP128ToFPIeee () WARNING: operands"
            " for single precision operation were out of the single precision "
            "range\n");*/
      }
      break;
    case _FpFormatFp64:
      if ((0xffff-2*(1022+52)) <= exponent && exponent <= (0xffff+2*1023+51)) {
        // all the valid results from operations on double precision floating-
        // point numbers fit in this range
        scale = scale * 1536; // 1536 = 3/4 * 2^11
        exponent += scale;
      } else {
        // pFpieeeRecord->Result.Format = _FpFormatFp82 in conjunction (for
        // example) with _FpCodeFmaDouble (which expects 
        // pFpieeeRecord->Result.Format = _FpFormatFp64) will indicate that
        // the result is outside the range where it can be scaled as required
        // by the IEEE standard
        pFpieeeRecord->Result.Format = _FpFormatFp82;
		/* comment out warnings for confidence tests */
        /*printf ("IEEE FILTER fpieee_flt () / FP128ToFPIeee () WARNING: operands"
            " for double precision operation were out of the double precision "
            "range\n");*/
      }
      break;
    case _FpFormatFp80:
      if ((0xffff-2*(16382+63)) <= exponent && exponent <= (0xffff+2*16383+62)) {
        // all the valid results from operations on double-extended precision 
        // floating-point numbers fit in this range
        scale = scale * 24576; // 24576 = 3/4 * 2^15
        exponent += scale;
      } else {
        // pFpieeeRecord->Result.Format = _FpFormatFp82 in conjunction (for
        // example) with _FpCodeFma and FPSR.sf.pc = 0x11 (which expects 
        // pFpieeeRecord->Result.Format = _FpFormatFp80) will indicate that
        // the result is outside the range where it can be scaled as required
        // by the IEEE standard
        pFpieeeRecord->Result.Format = _FpFormatFp82;
		/* comment out warnings for confidence tests */
        /*printf ("IEEE FILTER fpieee_flt () / FP128ToFPIeee () WARNING: operands"
            " for double-extended precision operation were out of the "
            " double-extended precision range\n"); */
      }
      break;
    case _FpFormatFp82:
      if (pFpieeeRecord->Cause.Overflow && (exponent < 0x1ffff))
          exponent += 0x20000;
      if (pFpieeeRecord->Cause.Underflow && (exponent > 0x0))
          exponent -= 0x20000;
      scale = scale * 98304; // 98304 = 3/4 * 2^17
      exponent += scale;
      exponent = exponent & 0x1ffff;
      break;
    default: ; // will never get here
  }

  switch (pFpieeeRecord->Result.Format) {
    case _FpFormatFp32:
      if (significand >> 63) 
          exponent = exponent - 0x0ffff + 0x07f; // unbiased now in [-60, +65]
      else
          exponent = 0;
      u32 = (sign ? 0x80000000 : 0x0) | (exponent << 23) | 
          (unsigned int)((significand >> 40) & 0x7fffff);
      f32 = *((_FP32 *)&u32);
#ifdef FPIEEE_FLT_DEBUG
      printf ("FPIEEE_FLT_DEBUG FP128ToFPIeee HW ADJ f32 = 0x%08x\n",
          *(int *)&f32);
#endif
      pFpieeeRecord->Result.Value.Fp32Value = f32;
      break;
    case _FpFormatFp64:
      if (significand >> 63) 
          exponent = exponent - 0x0ffff + 0x03ff;
      else
          exponent = 0;
      u64 = (sign ? (((__int64)1) << 63) : 0x0) | 
          (((unsigned __int64)exponent) << 52) |
          (unsigned __int64)(((significand >> 11) & 0xfffffffffffff));
      f64 = *((_FP64 *)&u64);
#ifdef FPIEEE_FLT_DEBUG
      printf ("FPIEEE_FLT_DEBUG FP128ToFPIeee HW ADJ f64 = 0x%I64x\n",
          *(unsigned __int64 *)&f64);
#endif
      pFpieeeRecord->Result.Value.Fp64Value = f64;
      break;
    case _FpFormatFp80:
      if (significand >> 63) 
          exponent = exponent - 0x0ffff + 0x03fff;
      else
          exponent = 0;
      pFpieeeRecord->Result.Value.Fp80Value.W[4] = (sign ? 0x8000 : 0x0) |
          (exponent & 0x7fff);
      pFpieeeRecord->Result.Value.Fp80Value.W[3] =
	  (unsigned short)((significand >> 48) & 0xffff);
      pFpieeeRecord->Result.Value.Fp80Value.W[2] =
	  (unsigned short)((significand >> 32) & 0xffff);
      pFpieeeRecord->Result.Value.Fp80Value.W[1] =
	  (unsigned short)((significand >> 16) & 0xffff);
      pFpieeeRecord->Result.Value.Fp80Value.W[0] =
	  (unsigned short)(significand & 0xffff);
#ifdef FPIEEE_FLT_DEBUG
      printf ("FPIEEE_FLT_DEBUG FP128ToFPIeee HW ADJ f80= \
%08x %08x %08x %08x %08x\n",
          pFpieeeRecord->Result.Value.Fp80Value.W[4],
          pFpieeeRecord->Result.Value.Fp80Value.W[3],
          pFpieeeRecord->Result.Value.Fp80Value.W[2],
          pFpieeeRecord->Result.Value.Fp80Value.W[1],
          pFpieeeRecord->Result.Value.Fp80Value.W[0]);
#endif
      break;
    case _FpFormatFp82:
      pFpieeeRecord->Result.Value.Fp128Value.W[3] = 0x0;
      pFpieeeRecord->Result.Value.Fp128Value.W[2] = (sign << 17) | exponent;
      pFpieeeRecord->Result.Value.Fp128Value.W[1] =
	  (unsigned long)(significand >> 32);
      pFpieeeRecord->Result.Value.Fp128Value.W[0] =
	  (unsigned long)(significand & 0xffffffff);
      break;
    default: ; // will never get here
  }

}




static void
UpdateRoundingMode (
    unsigned int RoundingMode, 
    unsigned int sf,
    unsigned __int64 *FPSR, char *name)

{

  switch (RoundingMode) {

    case _FpRoundNearest:
      *FPSR = (*FPSR & ~((unsigned __int64)RC_MASK << (6 + sf * 13 + 4)))
          | ((unsigned __int64)RN_MASK << (6 + sf * 13 + 4));
      break;

    case _FpRoundMinusInfinity:
      *FPSR = (*FPSR & ~((unsigned __int64)RC_MASK << (6 + sf * 13 + 4)))
          | ((unsigned __int64)RM_MASK << (6 + sf * 13 + 4));
      break;

    case _FpRoundPlusInfinity:
      *FPSR = (*FPSR & ~((unsigned __int64)RC_MASK << (6 + sf * 13 + 4)))
          | ((unsigned __int64)RP_MASK << (6 + sf * 13 + 4));
      break;

    case _FpRoundChopped:
      *FPSR = (*FPSR & ~((unsigned __int64)RC_MASK << (6 + sf * 13 + 4)))
          | ((unsigned __int64)RZ_MASK << (6 + sf * 13 + 4));
      break;

    default:
      /* should never get here: unrecognized FpieeeRecord.RoundingMode */
      fprintf (stderr, "IEEE Filter Internal Error: \
          FpieeeRecord.RoundingMode %x not recognized \
          for %s instruction\n", RoundingMode, name);
      exit (1);

  }

}




static void
UpdatePrecision (
    unsigned int Precision,
    unsigned int sf,
    unsigned __int64 *FPSR, char *name)

{

  switch (Precision) {

    case _FpPrecision64:
      *FPSR = (*FPSR & ~((unsigned __int64)PC_MASK << (6 + sf * 13 + 2)))
          | ((unsigned __int64)DBL_EXT_MASK << (6 + sf * 13 + 2));
      break;

    case _FpPrecision53:
      *FPSR = (*FPSR & ~((unsigned __int64)PC_MASK << (6 + sf * 13 + 2)))
          | ((unsigned __int64)DBL_MASK << (6 + sf * 13 + 2));
      break;

    case _FpPrecision24:
      *FPSR = (*FPSR & ~((unsigned __int64)PC_MASK << (6 + sf * 13 + 2)))
          | ((unsigned __int64)SGL_MASK << (6 + sf * 13 + 2));
      break;

    default:
      /* should never get here: unrecognized FpieeeRecord.Precision */
      fprintf (stderr, "IEEE Filter Internal Error: \
          FpieeeRecord.Precision %x not recognized \
          for %s instruction\n", Precision, name);
      exit (1);

  }

}




static _FP128
FP32ToFP128 (_FP32 f32)

{

  _FP128 f128;

  unsigned __int64 significand;
  unsigned int exponent;
  unsigned int sign;
  unsigned int u32;
  char *p;


  // expand the value in f32 to 1 + 17 + 64 = 82 bits; write
  // then in memory spill format, and return value

  // 1 + 8 + 24 bits, for _FpPrecision24
  // got _FP32 f32 (float)
  u32 = *((unsigned int *)&f32);
  sign = u32 >> 31;
  exponent = (u32 >> 23) & 0x0ff; // cut off the sign bit
  if (exponent == 0x0ff) {
    exponent = 0x01ffff; // special value
  } else if (exponent != 0) {
    exponent = exponent - 0x07f + 0x0ffff;
  }
  significand = ((unsigned __int64)(u32 & 0x07fffff) << 40); 
      // cut 23 bits and shift left
  if (exponent != 0) { 
    significand = (((unsigned __int64)1) << 63) | significand; 
      // not denormal - add J-bit
  }

  p = (char *)(&f128);
  memcpy (p, (char *)&significand, 8);
  p[8] = exponent & 0x0ff;
  p[9] = (exponent >> 8) & 0x0ff;
  p[10] = (exponent >> 16) | (sign << 1);
  p[11] = 0;
  p[12] = 0;
  p[13] = 0;
  p[14] = 0;
  p[15] = 0;

  return (f128);

}



static _FP128
FP32ToFP128modif (_FP32 f32, int adj_exp)

{

  _FP128 f128;

  unsigned __int64 significand;
  unsigned int exponent;
  unsigned int sign;
  unsigned int u32;
  char *p;


  // expand the value in f32 to 1 + 17 + 64 = 82 bits; write
  // then in memory spill format, and return value

  // 1 + 8 + 24 bits, for _FpPrecision24
  // got _FP32 f32 (float)
  u32 = *((unsigned int *)&f32);
  sign = u32 >> 31;
  exponent = (u32 >> 23) & 0x0ff; // cut off the sign bit
  significand = ((unsigned __int64)(u32 & 0x07fffff) << 40);
      // cut 23 bits and shift left
  if (exponent == 0x0ff) {
    exponent = 0x01ffff; // special value
    significand = (((unsigned __int64)1) << 63) | significand;
  } else if (exponent == 0 && significand != (unsigned __int64)0) { // denormal
    exponent = 0xff81;
  } else if (exponent != 0) {
    exponent = exponent - 0x07f + 0x0ffff;
    exponent += adj_exp;
    significand = (((unsigned __int64)1) << 63) | significand;
  }

  p = (char *)(&f128);
  memcpy (p, (char *)&significand, 8);
  p[8] = exponent & 0x0ff;
  p[9] = (exponent >> 8) & 0x0ff;
  p[10] = (exponent >> 16) | (sign << 1);
  p[11] = 0;
  p[12] = 0;
  p[13] = 0;
  p[14] = 0;
  p[15] = 0;

  return (f128);

}




static _FP32 
LowHalf (_FP128 FR)

{

  // return the floating-point number from the low half of FR

  _FP32 Low;
  unsigned __int64 ULLow;

  ULLow = FR.W[0];
  Low = *((_FP32 *)&ULLow);

  return (Low);

}




static _FP32
HighHalf (_FP128 FR)

{

  // return the floating-point number from the high half of FR

  _FP32 High;
  unsigned __int64 ULHigh;

  ULHigh = FR.W[1];
  High = *((_FP32 *)&ULHigh);

  return (High);

}




static int
I32LowHalf (_FP128 FR)

{

  // return the int from the low half of FR

  int Low;

  Low = (int)FR.W[0];
  return (Low);

}




static int
I32HighHalf (_FP128 FR)

{

  // return the int from the high half of FR

  unsigned int High;

  High = (unsigned int)FR.W[1];
  return (High);

}




static unsigned int
U32LowHalf (_FP128 FR)

{

  // return the unsigned int from the low half of FR

  unsigned int Low;

  Low = (unsigned int)FR.W[0];
  return (Low);

}




static unsigned int
U32HighHalf (_FP128 FR)

{

  // return the unsigned int from the high half of FR

  unsigned int High;

  High = (unsigned int)FR.W[1];
  return (High);

}




static _FP128 
Combine (_FP32 High, _FP32 Low)

{

  _FP128 FR;
  unsigned int ULLow, ULHigh;

  ULLow = *((unsigned int *)&Low);
  ULHigh = *((unsigned int *)&High);
 
  FR.W[0] = ULLow;
  FR.W[1] = ULHigh;
  FR.W[2] = (unsigned int)0x01003e;
  FR.W[3] = 0;

  return (FR);

}




static _FP128 
I32Combine (int High, int Low)

{

  _FP128 FR;

  FR.W[0] = (unsigned int)Low;
  FR.W[1] = (unsigned int)High;
  FR.W[2] = (unsigned int)0x01003e;
  FR.W[3] = 0;

  return (FR);

}




static _FP128 
U32Combine (unsigned int High, unsigned int Low)

{

  _FP128 FR;

  FR.W[0] = (unsigned int)Low;
  FR.W[1] = (unsigned int)High;
  FR.W[2] = (unsigned int)0x01003e;
  FR.W[3] = 0;

  return (FR);

}




static _FP128
GetFloatRegisterValue (unsigned int f, PCONTEXT Context)

{

  _FP128 FR82;
  unsigned __int64 *p1, *p2;


  p1 = (unsigned __int64 *)&FR82;

  if (f == 0) {

    /* + 0.0 */
    *p1 = 0;
    *(p1 + 1) = 0;

  } else if (f == 1) {

    /* + 1.0 */
    *p1 = 0x8000000000000000;
    *(p1 + 1) = 0x000000000000ffff;

  } else if (f >= 2 && f <= 127) {

    p2 = (unsigned __int64 *)&(Context->FltS0);
    p2 = p2 + 2 * (f - 2);
    *p1 = *p2;
    *(p1 + 1) = *(p2 + 1);

  } else {

    fprintf (stderr, "IEEE Filter / GetFloatRegisterValue () Internal Error: \
FP register number f = %x is not valid\n", f);
    exit (1);

  }

  return (FR82);

}




static void
SetFloatRegisterValue (unsigned int f, _FP128 Value, PCONTEXT Context)

{

  unsigned __int64 *p1, *p2;


  p2 = (unsigned __int64 *)&Value;

  if (f >= 2 && f <= 127) {

    p1 = (unsigned __int64 *)&(Context->FltS0);
    p1 = p1 + 2 * (f - 2);
    *p1 = *p2;
    *(p1 + 1) = *(p2 + 1);

  } else {

    fprintf (stderr, "IEEE Filter / SetFloatRegisterValue () Internal Error: \
FP register number f = %x is not valid\n", f);
    exit (1);

  }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\ia64\fabs.s ===
.file "fabs.s"

// Copyright (c) 2000, 2001, Intel Corporation
// All rights reserved.
// 
// Contributed 2/2/2000 by John Harrison, Ted Kubaska, Bob Norin, Shane Story,
// and Ping Tak Peter Tang of the Computational Software Lab, Intel Corporation.
// 
// WARRANTY DISCLAIMER
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS 
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY 
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
// 
// Intel Corporation is the author of this code, and requests that all
// problem reports or change requests be submitted to it directly at 
// http://developer.intel.com/opensource.
//
// History
//==============================================================
// 2/02/00: Initial version 
//
// API
//==============================================================
// double fabs  (double x)
//
// Overview of operation
//==============================================================
// returns absolute value of x 

// floating-point registers used: 1
// f8, input

.align 32
.global fabs#

.section .text
.proc  fabs#
.align 32



fabs: 

// set invalid or denormal flags and take fault if
// necessary

{ .mfi
      nop.m 999
      fcmp.eq.unc.s0 p6,p7 = f8,f1             
      nop.i 999 ;;
}

{ .mfb
      nop.m 999
      fmerge.s       f8 = f0,f8                   
      br.ret.sptk    b0 ;;                        
}

.endp fabs
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\ia64\floorf.s ===
.file "floorf.s"

// Copyright (c) 2000, 2001, Intel Corporation
// All rights reserved.
// 
// Contributed 2/2/2000 by John Harrison, Ted Kubaska, Bob Norin, Shane Story,
// and Ping Tak Peter Tang of the Computational Software Lab, Intel Corporation.
// 
// WARRANTY DISCLAIMER
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS 
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY 
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
// 
// Intel Corporation is the author of this code, and requests that all
// problem reports or change requests be submitted to it directly at 
// http://developer.intel.com/opensource.
//
.align 32
.global floorf#

.section .text
.proc  floorf#
.align 32

// History
//==============================================================
// 2/02/00: Initial version
// 6/13/00: Improved speed
// 6/27/00: Eliminated incorrect invalid flag setting
// 2/07/01: Corrected sign of zero result in round to -inf mode

// API
//==============================================================
// float floorf(float x)

// general input registers:  

floor_GR_FFFF      = r14
floor_GR_signexp   = r15
floor_GR_exponent  = r16
floor_GR_expmask   = r17
floor_GR_bigexp    = r18


// predicate registers used: 

// p6  ==> Input is NaN, infinity, zero
// p7  ==> Input is denormal
// p8  ==> Input is <0
// p9  ==> Input is >=0
// p10 ==> Input is already an integer (bigger than largest integer)
// p11 ==> Input is not a large integer
// p12 ==> Input is a smaller integer
// p13 ==> Input is not an even integer, so inexact must be set


// floating-point registers used: 

FLOOR_NORM_f8      = f9                        
FLOOR_FFFF         = f10 
FLOOR_INEXACT      = f11 
FLOOR_FLOAT_INT_f8 = f12
FLOOR_INT_f8       = f13
FLOOR_adj          = f14

// Overview of operation
//==============================================================

// float floorf(float x)
// Return an integer value (represented as a float) that is the largest 
// value not greater than x
// This is x rounded toward -infinity to an integral value.
// Inexact is set if x != floorf(x)
// **************************************************************************

// Set denormal flag for denormal input and
// and take denormal fault if necessary.

// Is the input an integer value already?

// double_extended
// if the exponent is > 1003e => 3F(true) = 63(decimal)
// we have a significand of 64 bits 1.63-bits.
// If we multiply by 2^63, we no longer have a fractional part
// So input is an integer value already.

// double
// if the exponent is >= 10033 => 34(true) = 52(decimal)
// 34 + 3ff = 433
// we have a significand of 53 bits 1.52-bits. (implicit 1)
// If we multiply by 2^52, we no longer have a fractional part
// So input is an integer value already.

// single
// if the exponent is > 10016 => 17(true) = 23(decimal)
// we have a significand of 24 bits 1.23-bits. (implicit 1)
// If we multiply by 2^23, we no longer have a fractional part
// So input is an integer value already.

// If x is NAN, ZERO, or INFINITY, then  return

// qnan snan inf norm     unorm 0 -+
// 1    1    1   0        0     1 11     0xe7


floorf:

{ .mfi
      getf.exp floor_GR_signexp  = f8
      fcvt.fx.trunc.s1     FLOOR_INT_f8  = f8
      addl        floor_GR_bigexp = 0x10016, r0
}
{ .mfi
      addl        floor_GR_FFFF      = -1,r0
      fcmp.lt.s1  p8,p9 = f8,f0
      mov         floor_GR_expmask    = 0x1FFFF ;;
}

// p7 ==> denorm
{ .mfi
      setf.sig    FLOOR_FFFF  = floor_GR_FFFF
      fclass.m    p7,p0 = f8, 0x0b
      nop.i 999
}
{ .mfi
      nop.m 999
      fnorm.s1           FLOOR_NORM_f8  = f8
      nop.i 999 ;;
}

// p6 ==> NAN, INF, ZERO
{ .mfb
      nop.m 999
      fclass.m      p6,p10 = f8, 0xe7
(p7)  br.cond.spnt  FLOOR_DENORM ;;
}

.pred.rel "mutex",p8,p9
FLOOR_COMMON:
// Set adjustment to subtract from trunc(x) for result
//   If x<0,  adjustment is -1.0
//   If x>=0, adjustment is 0.0
{ .mfi
      and      floor_GR_exponent = floor_GR_signexp, floor_GR_expmask
(p8)  fnma.s1  FLOOR_adj = f1,f1,f0
      nop.i 999
}
{ .mfi
      nop.m 999
(p9)  fadd.s1  FLOOR_adj = f0,f0
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
      fcmp.eq.s0  p12,p0 = f8,f0 // Dummy op to set denormal and invalid flag
      nop.i 999
}
{ .mfi
(p10) cmp.ge.unc    p10,p11 = floor_GR_exponent, floor_GR_bigexp
(p6)  fnorm.s f8 = f8
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p11) fcvt.xf         FLOOR_FLOAT_INT_f8   = FLOOR_INT_f8
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p10) fnorm.s f8 = FLOOR_NORM_f8
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p11) fadd.s   f8 = FLOOR_FLOAT_INT_f8,FLOOR_adj
      nop.i 999 ;;
}
{ .mfi
      nop.m 999
(p11) fcmp.eq.unc.s1  p12,p13  = FLOOR_FLOAT_INT_f8, FLOOR_NORM_f8
      nop.i 999 ;;
}

// Set inexact if result not equal to input
{ .mfi
      nop.m 999
(p13) fmpy.s0     FLOOR_INEXACT = FLOOR_FFFF,FLOOR_FFFF
      nop.i 999
}
// Set result to input if integer
{ .mfb
      nop.m 999
(p12) fnorm.s f8 = FLOOR_NORM_f8
      br.ret.sptk    b0 ;;
}

// Here if input denorm
FLOOR_DENORM:
{ .mfb
      getf.exp floor_GR_signexp  = FLOOR_NORM_f8
      fcvt.fx.trunc.s1     FLOOR_INT_f8  = FLOOR_NORM_f8
      br.cond.sptk  FLOOR_COMMON ;;
}

.endp floorf
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\ia64\floor.s ===
.file "floor.s"

// Copyright (c) 2000, 2001, Intel Corporation
// All rights reserved.
// 
// Contributed 2/2/2000 by John Harrison, Ted Kubaska, Bob Norin, Shane Story,
// and Ping Tak Peter Tang of the Computational Software Lab, Intel Corporation.
// 
// WARRANTY DISCLAIMER
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS 
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY 
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
// 
// Intel Corporation is the author of this code, and requests that all
// problem reports or change requests be submitted to it directly at 
// http://developer.intel.com/opensource.
//
.align 32
.global floor#

.section .text
.proc  floor#
.align 32

// History
//==============================================================
// 2/02/00: Initial version
// 3/22/00: Updated to improve performance 
// 6/13/00: Improved speed, fixed setting of inexact flag
// 6/27/00: Eliminated incorrect invalid flag setting
// 2/07/01: Corrected sign of zero result in round to -inf mode

// API
//==============================================================
// double floor(double x)

// general input registers:  

floor_GR_FFFF      = r14
floor_GR_signexp   = r15
floor_GR_exponent  = r16
floor_GR_expmask   = r17
floor_GR_bigexp    = r18


// predicate registers used: 

// p6  ==> Input is NaN, infinity, zero
// p7  ==> Input is denormal
// p8  ==> Input is <0
// p9  ==> Input is >=0
// p10 ==> Input is already an integer (bigger than largest integer)
// p11 ==> Input is not a large integer
// p12 ==> Input is a smaller integer
// p13 ==> Input is not an even integer, so inexact must be set


// floating-point registers used: 

FLOOR_NORM_f8      = f9                        
FLOOR_FFFF         = f10 
FLOOR_INEXACT      = f11 
FLOOR_FLOAT_INT_f8 = f12
FLOOR_INT_f8       = f13
FLOOR_adj          = f14

// Overview of operation
//==============================================================

// double floor(double x)
// Return an integer value (represented as a double) that is the largest 
// value not greater than x
// This is x rounded toward -infinity to an integral value.
// Inexact is set if x != floor(x)
// **************************************************************************

// Set denormal flag for denormal input and
// and take denormal fault if necessary.

// Is the input an integer value already?

// double_extended
// if the exponent is > 1003e => 3F(true) = 63(decimal)
// we have a significand of 64 bits 1.63-bits.
// If we multiply by 2^63, we no longer have a fractional part
// So input is an integer value already.

// double
// if the exponent is >= 10033 => 34(true) = 52(decimal)
// 34 + 3ff = 433
// we have a significand of 53 bits 1.52-bits. (implicit 1)
// If we multiply by 2^52, we no longer have a fractional part
// So input is an integer value already.

// single
// if the exponent is > 10016 => 17(true) = 23(decimal)
// we have a significand of 24 bits 1.23-bits. (implicit 1)
// If we multiply by 2^23, we no longer have a fractional part
// So input is an integer value already.

// If x is NAN, ZERO, or INFINITY, then  return

// qnan snan inf norm     unorm 0 -+
// 1    1    1   0        0     1 11     0xe7


floor:

{ .mfi
      getf.exp floor_GR_signexp  = f8
      fcvt.fx.trunc.s1     FLOOR_INT_f8  = f8
      addl        floor_GR_bigexp = 0x10033, r0
}
{ .mfi
      addl        floor_GR_FFFF      = -1,r0
      fcmp.lt.s1  p8,p9 = f8,f0
      mov         floor_GR_expmask    = 0x1FFFF ;;
}

// p7 ==> denorm
{ .mfi
      setf.sig    FLOOR_FFFF  = floor_GR_FFFF
      fclass.m    p7,p0 = f8, 0x0b
      nop.i 999
}
{ .mfi
      nop.m 999
      fnorm.s1           FLOOR_NORM_f8  = f8
      nop.i 999 ;;
}

// p6 ==> NAN, INF, ZERO
{ .mfb
      nop.m 999
      fclass.m      p6,p10 = f8, 0xe7
(p7)  br.cond.spnt  FLOOR_DENORM ;;
}

.pred.rel "mutex",p8,p9
FLOOR_COMMON:
// Set adjustment to subtract from trunc(x) for result
//   If x<0,  adjustment is -1.0
//   If x>=0, adjustment is 0.0
{ .mfi
      and      floor_GR_exponent = floor_GR_signexp, floor_GR_expmask
(p8)  fnma.s1  FLOOR_adj = f1,f1,f0
      nop.i 999
}
{ .mfi
      nop.m 999
(p9)  fadd.s1  FLOOR_adj = f0,f0
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
      fcmp.eq.s0  p12,p0 = f8,f0 // Dummy op to set denormal and invalid flag
      nop.i 999
}
{ .mfi
(p10) cmp.ge.unc    p10,p11 = floor_GR_exponent, floor_GR_bigexp
(p6)  fnorm.d f8 = f8
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p11) fcvt.xf         FLOOR_FLOAT_INT_f8   = FLOOR_INT_f8
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p10) fnorm.d f8 = FLOOR_NORM_f8
      nop.i 999 ;;
}


{ .mfi
      nop.m 999
(p11) fadd.d   f8 = FLOOR_FLOAT_INT_f8,FLOOR_adj
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p11) fcmp.eq.unc.s1  p12,p13  = FLOOR_FLOAT_INT_f8, FLOOR_NORM_f8
      nop.i 999 ;;
}

// Set inexact if result not equal to input
{ .mfi
      nop.m 999
(p13) fmpy.s0     FLOOR_INEXACT = FLOOR_FFFF,FLOOR_FFFF
      nop.i 999
}
// Set result to input if integer
{ .mfb
      nop.m 999
(p12) fnorm.d f8 = FLOOR_NORM_f8
      br.ret.sptk    b0 ;;
}

// Here if input denorm
FLOOR_DENORM:
{ .mfb
      getf.exp floor_GR_signexp  = FLOOR_NORM_f8
      fcvt.fx.trunc.s1     FLOOR_INT_f8  = FLOOR_NORM_f8
      br.cond.sptk  FLOOR_COMMON ;;
}

.endp floor
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\ia64\fmodf.s ===
.file "fmodf.s"
// Copyright (c) 2000, 2001, Intel Corporation
// All rights reserved.
//
// Contributed 2/2/2000 by John Harrison, Cristina Iordache, Ted Kubaska, 
// Bob Norin, Shane Story, and Ping Tak Peter Tang of the Computational 
// Software Lab, Intel Corporation.
//
// WARRANTY DISCLAIMER
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// Intel Corporation is the author of this code, and requests that all
// problem reports or change requests be submitted to it directly at
// http://developer.intel.com/opensource.
//
// History
//====================================================================
// 2/02/00  Initial version
// 3/02/00  New Algorithm
// 4/04/00  Unwind support added
// 8/15/00  Bundle added after call to __libm_error_support to properly
//          set [the previously overwritten] GR_Parameter_RESULT.
//11/28/00  Set FR_Y to f9
//
// API
//====================================================================
// float fmodf(float,float);   
//
// Overview of operation
//====================================================================
//  fmod(a,b)=a-i*b,
//  where i is an integer such that, if b!=0, 
//  |i|<|a/b| and |a/b-i|<1

// Algorithm
//====================================================================
// a). if |a|<|b|, return a
// b). get quotient and reciprocal overestimates accurate to 
//     33 bits (q2,y2)
// c). if the exponent difference (exponent(a)-exponent(b))
//     is less than 32, truncate quotient to integer and
//     finish in one iteration
// d). if exponent(a)-exponent(b)>=32 (q2>=2^32)
//     round quotient estimate to single precision (k=RN(q2)),
//     calculate partial remainder (a'=a-k*b), 
//     get quotient estimate (a'*y2), and repeat from c).

// Special cases
//====================================================================
// b=+/-0: return NaN, call libm_error_support
// a=+/-Inf, a=NaN or b=NaN: return NaN

// Registers used
//====================================================================
// Predicate registers: p6-p11
// General registers:   r2,r29,r32 (ar.pfs), r33-r39
// Floating point registers: f6-f15


.section .text

GR_SAVE_B0                    = r33
GR_SAVE_PFS                   = r34
GR_SAVE_GP                    = r35 
GR_SAVE_SP                    = r36

GR_Parameter_X                = r37
GR_Parameter_Y                = r38
GR_Parameter_RESULT           = r39
GR_Parameter_TAG              = r40

FR_X             = f10
FR_Y             = f9
FR_RESULT        = f8



.proc fmodf#
.align 32
.global fmodf#
.align 32

fmodf:
// inputs in f8, f9
// result in f8

{ .mfi
  alloc r32=ar.pfs,1,4,4,0
  // f6=|a|
  fmerge.s f6=f0,f8
  mov r2 = 0x0ffdd
}
  {.mfi
  nop.m 0
  // f7=|b|
  fmerge.s f7=f0,f9
  nop.i 0;;
}

{ .mfi
  setf.exp f11 = r2
  // (1) y0
  frcpa.s1 f10,p6=f6,f7
  nop.i 0
} 

// eliminate special cases
// Y +-NAN, +-inf, +-0?     p7
{ .mfi
      nop.m 999
      fclass.m.unc  p7,p0 = f9, 0xe7           
      nop.i 999;;
}

// qnan snan inf norm     unorm 0 -+
// 1    1    1   0        0     0 11
// e                      3
// X +-NAN, +-inf, ?        p9

{ .mfi
      nop.m 999
      fclass.m.unc  p9,p0 = f8, 0xe3           
      nop.i 999 
}

// |x| < |y|? Return x p8
{ .mfi
      nop.m 999
      fcmp.lt.unc.s1 p8,p0 = f6,f7             
      nop.i 999 ;;
}

{ .mfi
  nop.m 0
  // normalize y (if |x|<|y|)
  (p8) fma.s0 f9=f9,f1,f0
  nop.i 0;;
}

  { .mfi
  mov r2=0x1001f
  // (2) q0=a*y0
  (p6) fma.s1 f13=f6,f10,f0
  nop.i 0
} 
{ .mfi
  nop.m 0
  // (3) e0 = 1 - b * y0
  (p6) fnma.s1 f12=f7,f10,f1
  nop.i 0;;
} 

  {.mfi
  nop.m 0
  // normalize x (if |x|<|y|)
  (p8) fma.s.s0 f8=f8,f1,f0
  nop.i 0
} 
{.bbb
  (p9) br.cond.spnt FMOD_X_NAN_INF
  (p7) br.cond.spnt FMOD_Y_NAN_INF_ZERO
  // if |x|<|y|, return
  (p8) br.ret.spnt    b0;;
}

  {.mfi 
  nop.m 0
  // normalize x
  fma.s0 f6=f6,f1,f0
  nop.i 0
} 
{.mfi
  nop.m 0
  // normalize y
  fma.s0 f7=f7,f1,f0
  nop.i 0;;
}


  {.mfi
  // f15=2^32
  setf.exp f15=r2
  // (4) q1=q0+e0*q0
  (p6) fma.s1 f13=f12,f13,f13
  nop.i 0
} 
{ .mfi
  nop.m 0
  // (5) e1 = e0 * e0 + 2^-34
  (p6) fma.s1 f14=f12,f12,f11
  nop.i 0;;
} 
{.mlx
  nop.m 0
  movl r2=0x33a00000;;
} 
{ .mfi
  nop.m 0
  // (6) y1 = y0 + e0 * y0
  (p6) fma.s1 f10=f12,f10,f10
  nop.i 0;;
} 
{.mfi
  // set f12=1.25*2^{-24}
  setf.s f12=r2
  // (7) q2=q1+e1*q1
  (p6) fma.s1 f13=f13,f14,f13
  nop.i 0;;
} 
{.mfi
  nop.m 0
  fmerge.s f9=f8,f9
  nop.i 0
} 
{ .mfi
  nop.m 0
  // (8) y2 = y1 + e1 * y1
  (p6) fma.s1 f10=f14,f10,f10
  // set p6=0, p10=0
  cmp.ne.and p6,p10=r0,r0;;
} 

.align 32
loop24:
  {.mfi
  nop.m 0
  // compare q2, 2^32
  fcmp.lt.unc.s1 p8,p7=f13,f15
  nop.i 0
}
  {.mfi
  nop.m 0
  // will truncate quotient to integer, if exponent<32 (in advance)
  fcvt.fx.trunc.s1 f11=f13
  nop.i 0;;
}
  {.mfi
  nop.m 0
  // if exponent>32, round quotient to single precision (perform in advance)
  fma.s.s1 f13=f13,f1,f0
  nop.i 0;;
}
  {.mfi
  nop.m 0
  // set f12=sgn(a)
  (p8) fmerge.s f12=f8,f1
  nop.i 0
}
  {.mfi
  nop.m 0
  // normalize truncated quotient
  (p8) fcvt.xf f13=f11
  nop.i 0;;
}  
  { .mfi
  nop.m 0
  // calculate remainder (assuming f13=RZ(Q))
  (p7) fnma.s1 f14=f13,f7,f6
  nop.i 0
}
  {.mfi
  nop.m 0
  // also if exponent>32, round quotient to single precision 
  // and subtract 1 ulp: q=q-q*(1.25*2^{-24})
  (p7) fnma.s.s1 f11=f13,f12,f13
  nop.i 0;;
}

  {.mfi
  nop.m 0
  // (p8) calculate remainder (82-bit format)
  (p8) fnma.s1 f11=f13,f7,f6
  nop.i 0
}
  {.mfi
  nop.m 0
  // (p7) calculate remainder (assuming f11=RZ(Q))
  (p7) fnma.s1 f6=f11,f7,f6
  nop.i 0;;
}


  {.mfi
  nop.m 0
  // Final iteration (p8): is f6 the correct remainder (quotient was not overestimated) ?
  (p8) fcmp.lt.unc.s1 p6,p10=f11,f0
  nop.i 0;;
}
  {.mfi
  nop.m 0
  // get new quotient estimation: a'*y2
  (p7) fma.s1 f13=f14,f10,f0
  nop.i 0
}
  {.mfb
  nop.m 0
  // was f14=RZ(Q) ? (then new remainder f14>=0)
  (p7) fcmp.lt.unc.s1 p7,p9=f14,f0
  nop.b 0;;
}


.pred.rel "mutex",p6,p10
  {.mfb
  nop.m 0
  // add b to estimated remainder (to cover the case when the quotient was overestimated) 
  // also set correct sign by using f9=|b|*sgn(a), f12=sgn(a)
  (p6) fma.s.s0 f8=f11,f12,f9
  nop.b 0
}
  {.mfb
  nop.m 0
  // calculate remainder (single precision)
  // set correct sign of result before returning
  (p10) fma.s.s0 f8=f11,f12,f0
  (p8) br.ret.sptk b0;;
}
  {.mfi
  nop.m 0
  // if f13!=RZ(Q), get alternative quotient estimation: a''*y2
  (p7) fma.s1 f13=f6,f10,f0
  nop.i 0
}
  {.mfb
  nop.m 0
  // if f14 was RZ(Q), set remainder to f14
  (p9) mov f6=f14
  br.cond.sptk loop24;;
}

  {  .mmb
	nop.m 0				    
	nop.m 0				    
	br.ret.sptk b0;;
 }

FMOD_X_NAN_INF: 


// Y zero ?
{.mfi 
  nop.m 0
  fma.s1 f10=f9,f1,f0
  nop.i 0;;
}
{.mfi
 nop.m 0
 fcmp.eq.unc.s1 p11,p0=f10,f0
 nop.i 0;;
}
{.mib
  nop.m 0
  nop.i 0
  // if Y zero
  (p11) br.cond.spnt FMOD_Y_ZERO;;                        
}

// X infinity? Return QNAN indefinite
{ .mfi
      nop.m 999
      fclass.m.unc  p8,p9 = f8, 0x23 
      nop.i 999;; 
}
// Y NaN ?
{.mfi
	 nop.m 999
(p8) fclass.m p9,p8=f9,0xc3
	 nop.i 0;;
}
{.mfi
	nop.m 999
(p8)  frcpa.s0 f8,p0 = f8,f8           
    nop.i 0
} 
{ .mfi
      nop.m 999
	// also set Denormal flag if necessary
(p8)  fma.s0 f9=f9,f1,f0
      nop.i 999 ;;
}

{ .mfb
      nop.m 999
(p8)  fma.s f8=f8,f1,f0                     
	  nop.b 999 ;;                        
}

{ .mfb
      nop.m 999
(p9)  frcpa.s0 f8,p7=f8,f9                     
      br.ret.sptk    b0 ;;                        
}


FMOD_Y_NAN_INF_ZERO: 

// Y INF
{ .mfi
      nop.m 999
      fclass.m.unc  p7,p0 = f9, 0x23           
      nop.i 999 ;;
}

{ .mfb
      nop.m 999
(p7)  fma.s f8=f8,f1,f0                     
(p7)  br.ret.spnt    b0 ;;                        
}

// Y NAN?
{ .mfi
      nop.m 999
      fclass.m.unc  p9,p0 = f9, 0xc3           
      nop.i 999 ;;
}

{ .mfb
      nop.m 999
(p9)  fma.s f8=f9,f1,f0                     
(p9)  br.ret.spnt    b0 ;;                        
}

FMOD_Y_ZERO:
// Y zero? Must be zero at this point
// because it is the only choice left.
// Return QNAN indefinite

{.mfi
  nop.m 0
  // set Invalid
  frcpa f12,p0=f0,f0
  nop.i 999
}
// X NAN?
{ .mfi
      nop.m 999
      fclass.m.unc  p9,p10 = f8, 0xc3           
      nop.i 999 ;;
}
{ .mfi
      nop.m 999
(p10)  fclass.nm  p9,p10 = f8, 0xff           
      nop.i 999 ;;
}

{.mfi
 nop.m 999
 (p9) frcpa f11,p7=f8,f0
 nop.i 0;;
}

{ .mfi
      nop.m 999
(p10) frcpa f11,p7 = f0,f0           
nop.i 999;;
}

{ .mfi
      nop.m 999
      fmerge.s      f10 = f8, f8             
      nop.i 999
}

{ .mfi
      nop.m 999
      fma.s f8=f11,f1,f0                     
      nop.i 999;;
}

EXP_ERROR_RETURN: 


{ .mib
      nop.m 0
      mov GR_Parameter_TAG=122                                 
      br.sptk __libm_error_region;; 
}

.endp fmodf

.proc __libm_error_region
__libm_error_region:
.prologue
{ .mfi
        add   GR_Parameter_Y=-32,sp             // Parameter 2 value
        nop.f 0
.save   ar.pfs,GR_SAVE_PFS
        mov  GR_SAVE_PFS=ar.pfs                 // Save ar.pfs 
}
{ .mfi
.fframe 64 
        add sp=-64,sp                           // Create new stack
        nop.f 0
        mov GR_SAVE_GP=gp                       // Save gp
};;
{ .mmi
        stfs [GR_Parameter_Y] = FR_Y,16         // Save Parameter 2 on stack
        add GR_Parameter_X = 16,sp              // Parameter 1 address
.save   b0, GR_SAVE_B0                      
        mov GR_SAVE_B0=b0                       // Save b0 
};;
.body
{ .mib
        stfs [GR_Parameter_X] = FR_X            // Store Parameter 1 on stack 
        add   GR_Parameter_RESULT = 0,GR_Parameter_Y  
	nop.b 0                                 // Parameter 3 address
}
{ .mib
        stfs [GR_Parameter_Y] = FR_RESULT      // Store Parameter 3 on stack
        add   GR_Parameter_Y = -16,GR_Parameter_Y  
        br.call.sptk b0=__libm_error_support#;;  // Call error handling function
}
{ .mmi
        nop.m 0
        nop.m 0
        add   GR_Parameter_RESULT = 48,sp
};;
{ .mmi
        ldfs  f8 = [GR_Parameter_RESULT]       // Get return result off stack
.restore
        add   sp = 64,sp                       // Restore stack pointer
        mov   b0 = GR_SAVE_B0                  // Restore return address
};;
{ .mib
        mov   gp = GR_SAVE_GP                  // Restore gp 
        mov   ar.pfs = GR_SAVE_PFS             // Restore ar.pfs
        br.ret.sptk     b0                     // Return
};; 

.endp __libm_error_region

.type   __libm_error_support#,@function
.global __libm_error_support#
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\ia64\fpctrl.c ===
/***
*fpctrl.c - fp low level control and status routines
*
*   Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*   IEEE control and status routines for internal use.
*   These routines use machine specific constants while _controlfp,
*   _statusfp, and _clearfp use an abstracted control/status word
*
*Revision History:
*
*   03-31-92  GDP   written
*   05-12-92  GJF   Rewrote fdivr as fdivrp st(1),st to work around C8-32
*		    assertions.
*
*/

#include <trans.h>

extern uintptr_t _get_fpsr(void);
extern void _set_fpsr(uintptr_t);
extern void _fclrf(void);

/***	_statfp
*() -
*
*Purpose:
*	return user status word
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

uintptr_t _statfp()
{
    unsigned __int64 status;

    status = _get_fpsr();

    return status;
}

/***	_clrfp
*() -
*
*Purpose:
*	return user status word and clear status
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

uintptr_t _clrfp()
{
    uintptr_t status;

    status = _get_fpsr();
    _fclrf();

    return status;
}


/***	_ctrlfp
*() -
*
*Purpose:
*	return and set user control word
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

uintptr_t _ctrlfp(uintptr_t newctrl, uintptr_t _mask)
{
    uintptr_t oldCw;
    uintptr_t newCw;

    oldCw = _get_fpsr();

    newCw = (uintptr_t) ((newctrl & _mask) | (oldCw & ~_mask));
    newCw |= (oldCw & ~(unsigned __int64)0x0001f3f);

    _set_fpsr(newCw);

    return oldCw;
}



/***	_set_statfp
*() -
*
*Purpose:
*	force selected exception flags to 1
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

void _set_statfp(uintptr_t sw)
{
    unsigned __int64 status;

    status = _get_fpsr();

    status |= sw;

    _set_fpsr(status);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\ia64\fpieee_flt.h ===
//##########################################################################
//**
//**  Copyright  (C) 1996-2000 Intel Corporation. All rights reserved.
//**
//** The information and source code contained herein is the exclusive
//** property of Intel Corporation and may not be disclosed, examined
//** or reproduced in whole or in part without explicit written authorization
//** from the company.
//**
//###########################################################################

/*****************************************************************************
 *  fpieee_flt.h - include file for the FP IEEE exception filter routine
 *
 *
 *  History:
 *    Marius Cornea 09/07/00
 *    marius.cornea@intel.com
 *
 *****************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <fpieee.h>
#include <float.h>
#include <wtypes.h>

#define    rc_rn      0
#define    rc_rm      1
#define    rc_rp      2
#define    rc_rz      3

#define    sf_single                  0
#define    sf_double                  2
#define    sf_double_extended         3

#define EXCEPTION_MAXIMUM_PARAMETERS 15 /* maximum nr of exception parameters */

/******************************************************************
macro that helps add the LL on platforms other than NT
*******************************************************************/
#ifndef CONST_FORMAT
#ifndef WIN32

#define CONST_FORMAT(num) num##LL
#else
#define CONST_FORMAT(num) num

#endif
#endif

/* Define the masks and patterns for the different faulting FP instructions
 * Note: Fn_MIN_MASK and Fn_PATTERN need to be checked if new opcodes
 * are inserted in this function
 */

#define F1_MIN_MASK                     CONST_FORMAT(0x010000000000)
#define F1_PATTERN                      CONST_FORMAT(0x010000000000)

#define F1_MASK                         CONST_FORMAT(0x01F000000000)

#define FMA_PATTERN                     CONST_FORMAT(0x010000000000)
#define FMA_S_PATTERN                   CONST_FORMAT(0x011000000000)
#define FMA_D_PATTERN                   CONST_FORMAT(0x012000000000)
#define FPMA_PATTERN                    CONST_FORMAT(0x013000000000)

#define FMS_PATTERN                     CONST_FORMAT(0x014000000000)
#define FMS_S_PATTERN                   CONST_FORMAT(0x015000000000)
#define FMS_D_PATTERN                   CONST_FORMAT(0x016000000000)
#define FPMS_PATTERN                    CONST_FORMAT(0x017000000000)

#define FNMA_PATTERN                    CONST_FORMAT(0x018000000000)
#define FNMA_S_PATTERN                  CONST_FORMAT(0x019000000000)
#define FNMA_D_PATTERN                  CONST_FORMAT(0x01A000000000)
#define FPNMA_PATTERN                   CONST_FORMAT(0x01B000000000)


#define F4_MIN_MASK                     CONST_FORMAT(0x018000000000)
#define F4_PATTERN                      CONST_FORMAT(0x008000000000)

#define F4_MASK                         CONST_FORMAT(0x01F200001000)

#define FCMP_EQ_PATTERN                 CONST_FORMAT(0x008000000000)
#define FCMP_LT_PATTERN                 CONST_FORMAT(0x009000000000)
#define FCMP_LE_PATTERN                 CONST_FORMAT(0x008200000000)
#define FCMP_UNORD_PATTERN              CONST_FORMAT(0x009200000000)
#define FCMP_EQ_UNC_PATTERN             CONST_FORMAT(0x008000001000)
#define FCMP_LT_UNC_PATTERN             CONST_FORMAT(0x009000001000)
#define FCMP_LE_UNC_PATTERN             CONST_FORMAT(0x008200001000)
#define FCMP_UNORD_UNC_PATTERN          CONST_FORMAT(0x009200001000)


#define F6_MIN_MASK                     CONST_FORMAT(0x019200000000)
#define F6_PATTERN                      CONST_FORMAT(0x000200000000)

#define F6_MASK                         CONST_FORMAT(0x01F200000000)

#define FRCPA_PATTERN                   CONST_FORMAT(0x000200000000)
#define FPRCPA_PATTERN                  CONST_FORMAT(0x002200000000)


#define F7_MIN_MASK                     CONST_FORMAT(0x019200000000)
#define F7_PATTERN                      CONST_FORMAT(0x001200000000)

#define F7_MASK                         CONST_FORMAT(0x01F200000000)

#define FRSQRTA_PATTERN                 CONST_FORMAT(0x001200000000)
#define FPRSQRTA_PATTERN                CONST_FORMAT(0x003200000000)


#define F8_MIN_MASK                     CONST_FORMAT(0x018240000000)
#define F8_PATTERN                      CONST_FORMAT(0x000000000000)

#define F8_MASK                         CONST_FORMAT(0x01E3F8000000)

#define FMIN_PATTERN                    CONST_FORMAT(0x0000A0000000)
#define FMAX_PATTERN                    CONST_FORMAT(0x0000A8000000)
#define FAMIN_PATTERN                   CONST_FORMAT(0x0000B0000000)
#define FAMAX_PATTERN                   CONST_FORMAT(0x0000B8000000)
#define FPMIN_PATTERN                   CONST_FORMAT(0x0020A0000000)
#define FPMAX_PATTERN                   CONST_FORMAT(0x0020A8000000)
#define FPAMIN_PATTERN                  CONST_FORMAT(0x0020B0000000)
#define FPAMAX_PATTERN                  CONST_FORMAT(0x0020B8000000)
#define FPCMP_EQ_PATTERN                CONST_FORMAT(0x002180000000)
#define FPCMP_LT_PATTERN                CONST_FORMAT(0x002188000000)
#define FPCMP_LE_PATTERN                CONST_FORMAT(0x002190000000)
#define FPCMP_UNORD_PATTERN             CONST_FORMAT(0x002198000000)
#define FPCMP_NEQ_PATTERN               CONST_FORMAT(0x0021A0000000)
#define FPCMP_NLT_PATTERN               CONST_FORMAT(0x0021A8000000)
#define FPCMP_NLE_PATTERN               CONST_FORMAT(0x0021B0000000)
#define FPCMP_ORD_PATTERN               CONST_FORMAT(0x0021B8000000)


#define F10_MIN_MASK                    CONST_FORMAT(0x018240000000)
#define F10_PATTERN                     CONST_FORMAT(0x000040000000)

#define F10_MASK                        CONST_FORMAT(0x01E3F8000000)

#define FCVT_FX_PATTERN                 CONST_FORMAT(0x0000C0000000)
#define FCVT_FXU_PATTERN                CONST_FORMAT(0x0000C8000000)
#define FCVT_FX_TRUNC_PATTERN           CONST_FORMAT(0x0000D0000000)
#define FCVT_FXU_TRUNC_PATTERN          CONST_FORMAT(0x0000D8000000)
#define FPCVT_FX_PATTERN                CONST_FORMAT(0x0020C0000000)
#define FPCVT_FXU_PATTERN               CONST_FORMAT(0x0020C8000000)
#define FPCVT_FX_TRUNC_PATTERN          CONST_FORMAT(0x0020D0000000)
#define FPCVT_FXU_TRUNC_PATTERN         CONST_FORMAT(0x0020D8000000)


/* Masks for the rounding control bits */
#define RC_MASK                         CONST_FORMAT(0x03)
#define RN_MASK                         CONST_FORMAT(0x00)
#define RM_MASK                         CONST_FORMAT(0x01)
#define RP_MASK                         CONST_FORMAT(0x02)
#define RZ_MASK                         CONST_FORMAT(0x03)

/* Masks for the precision control bits */
#define PC_MASK                         CONST_FORMAT(0x03)
#define SGL_MASK                        CONST_FORMAT(0x00)
#define DBL_MASK                        CONST_FORMAT(0x02)
#define DBL_EXT_MASK                    CONST_FORMAT(0x03)



// opcodes for instructions that take one input operand (for run1args)
#define         FPRSQRTA                1  [not used - fprsqrta not re-executed]
#define         FPCVT_FX                2
#define         FPCVT_FXU               3
#define         FPCVT_FX_TRUNC          4
#define         FPCVT_FXU_TRUNC         5

// opcodes for instructions that take two input operands (for run2args)
#define         FPRCPA                  1  [not used - fprcpa not re-executed]
#define         FPCMP_EQ                2
#define         FPCMP_LT                3
#define         FPCMP_LE                4
#define         FPCMP_UNORD             5
#define         FPCMP_NEQ               6
#define         FPCMP_NLT               7
#define         FPCMP_NLE               8
#define         FPCMP_ORD               9
#define         FPMIN                   10
#define         FPMAX                   11
#define         FPAMIN                  12
#define         FPAMAX                  13

// opcodes for instructions that take three input operands (for run3args)
#define         FPMA                    1
#define         FPMS                    2
#define         FPNMA                   3


/* prototypes for helpers from support files written in asm */

void __get_fpsr (unsigned __int64 *);
void __set_fpsr (unsigned __int64 *);

void _xrun1args (int, unsigned __int64 *, _FP128 *, _FP128 *);
void _xrun2args (int, unsigned __int64 *, _FP128 *, _FP128 *, _FP128 *);
void _xrun3args (int, unsigned __int64 *, _FP128 *, _FP128 *, _FP128 *, _FP128 *);

void _thmB (_FP32 *, _FP32 *, _FP32 *, unsigned __int64 *);
void _thmH (_FP32 *, _FP32 *, unsigned __int64 *);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\ia64\fmod.s ===
.file "fmod.s"

// Copyright (c) 2000, 2001, Intel Corporation
// All rights reserved.
//
// Contributed 2/2/2000 by John Harrison, Cristina Iordache, Ted Kubaska,
// Bob Norin, Shane Story, and Ping Tak Peter Tang of the Computational
// Software Lab, Intel Corporation.
//
// WARRANTY DISCLAIMER
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// Intel Corporation is the author of this code, and requests that all
// problem reports or change requests be submitted to it directly at
// http://developer.intel.com/opensource.
//
// History
//====================================================================
// 2/02/00  Initial version
// 3/02/00  New Algorithm
// 4/04/00  Unwind support added
// 8/15/00  Bundle added after call to __libm_error_support to properly
//          set [the previously overwritten] GR_Parameter_RESULT.
//11/28/00  Set FR_Y to f9
//
// API
//====================================================================
// double fmod(double,double);   
//
// Overview of operation
//====================================================================
//  fmod(a,b)=a-i*b,
//  where i is an integer such that, if b!=0, 
//  |i|<|a/b| and |a/b-i|<1
//
// Algorithm
//====================================================================
// a). if |a|<|b|, return a
// b). get quotient and reciprocal overestimates accurate to 
//     33 bits (q2,y2)
// c). if the exponent difference (exponent(a)-exponent(b))
//     is less than 32, truncate quotient to integer and
//     finish in one iteration
// d). if exponent(a)-exponent(b)>=32 (q2>=2^32)
//     round quotient estimate to single precision (k=RN(q2)),
//     calculate partial remainder (a'=a-k*b), 
//     get quotient estimate (a'*y2), and repeat from c).
//
// Special cases
//====================================================================
// b=+/-0: return NaN, call libm_error_support
// a=+/-Inf, a=NaN or b=NaN: return NaN
//
// Registers used
//====================================================================
// Predicate registers: p6-p11
// General registers:   r2,r29,r32 (ar.pfs), r33-r39
// Floating point registers: f6-f15

.section .text


GR_SAVE_B0                    = r33
GR_SAVE_PFS                   = r34
GR_SAVE_GP                    = r35 
GR_SAVE_SP                    = r36

GR_Parameter_X                = r37
GR_Parameter_Y                = r38
GR_Parameter_RESULT           = r39
GR_Parameter_TAG              = r40

FR_X             = f10
FR_Y             = f9
FR_RESULT        = f8


.proc fmod#
.align 32
.global fmod#
.align 32

fmod:
// inputs in f8, f9
// result in f8

{ .mfi
  alloc r32=ar.pfs,1,4,4,0
  // f6=|a|
  fmerge.s f6=f0,f8
  mov r2 = 0x0ffdd
}
  {.mfi
  nop.m 0
  // f7=|b|
  fmerge.s f7=f0,f9
  nop.i 0;;
}

{ .mfi
  setf.exp f11 = r2
  // (1) y0
  frcpa.s1 f10,p6=f6,f7
  nop.i 0
} 

// Y +-NAN, +-inf, +-0?     p7
{ .mfi
      nop.m 999
      fclass.m.unc  p7,p0 = f9, 0xe7           
      nop.i 999;;
}

// qnan snan inf norm     unorm 0 -+
// 1    1    1   0        0     0 11
// e                      3
// X +-NAN, +-inf, ?        p9

{ .mfi
      nop.m 999
      fclass.m.unc  p9,p0 = f8, 0xe3           
      nop.i 999 
}

// |x| < |y|? Return x p8
{ .mfi
      nop.m 999
      fcmp.lt.unc.s1 p8,p0 = f6,f7             
      nop.i 999 ;;
}

{ .mfi
  nop.m 0
  // normalize y (if |x|<|y|)
  (p8) fma.s0 f9=f9,f1,f0
  nop.i 0;;
}

  { .mfi
  mov r2=0x1001f
  // (2) q0=a*y0
  (p6) fma.s1 f13=f6,f10,f0
  nop.i 0
} 
{ .mfi
  nop.m 0
  // (3) e0 = 1 - b * y0
  (p6) fnma.s1 f12=f7,f10,f1
  nop.i 0;;
} 

  {.mfi
  nop.m 0
  // normalize x (if |x|<|y|)
  (p8) fma.d.s0 f8=f8,f1,f0
  nop.i 0
} 
{.bbb
  (p9) br.cond.spnt FMOD_X_NAN_INF
  (p7) br.cond.spnt FMOD_Y_NAN_INF_ZERO
  // if |x|<|y|, return
  (p8) br.ret.spnt    b0;;
}

  {.mfi 
  nop.m 0
  // normalize x
  fma.s0 f6=f6,f1,f0
  nop.i 0
} 
{.mfi
  nop.m 0
  // normalize y
  fma.s0 f7=f7,f1,f0
  nop.i 0;;
}

  {.mfi
  // f15=2^32
  setf.exp f15=r2
  // (4) q1=q0+e0*q0
  (p6) fma.s1 f13=f12,f13,f13
  nop.i 0
} 
{ .mfi
  nop.m 0
  // (5) e1 = e0 * e0 + 2^-34
  (p6) fma.s1 f14=f12,f12,f11
  nop.i 0;;
} 
{.mlx
  nop.m 0
  movl r2=0x33a00000;;
} 
{ .mfi
  nop.m 0
  // (6) y1 = y0 + e0 * y0
  (p6) fma.s1 f10=f12,f10,f10
  nop.i 0;;
} 
{.mfi
  // set f12=1.25*2^{-24}
  setf.s f12=r2
  // (7) q2=q1+e1*q1
  (p6) fma.s1 f13=f13,f14,f13
  nop.i 0;;
} 
{.mfi
  nop.m 0
  fmerge.s f9=f8,f9
  nop.i 0
} 
{ .mfi
  nop.m 0
  // (8) y2 = y1 + e1 * y1
  (p6) fma.s1 f10=f14,f10,f10
  // set p6=0, p10=0
  cmp.ne.and p6,p10=r0,r0;;
} 

.align 32
loop53:
  {.mfi
  nop.m 0
  // compare q2, 2^32
  fcmp.lt.unc.s1 p8,p7=f13,f15
  nop.i 0
}
  {.mfi
  nop.m 0
  // will truncate quotient to integer, if exponent<32 (in advance)
  fcvt.fx.trunc.s1 f11=f13
  nop.i 0;;
}
  {.mfi
  nop.m 0
  // if exponent>32, round quotient to single precision (perform in advance)
  fma.s.s1 f13=f13,f1,f0
  nop.i 0;;
}
  {.mfi
  nop.m 0
  // set f12=sgn(a)
  (p8) fmerge.s f12=f8,f1
  nop.i 0
}
  {.mfi
  nop.m 0
  // normalize truncated quotient
  (p8) fcvt.xf f13=f11
  nop.i 0;;
}  
  { .mfi
  nop.m 0
  // calculate remainder (assuming f13=RZ(Q))
  (p7) fnma.s1 f14=f13,f7,f6
  nop.i 0
}
  {.mfi
  nop.m 0
  // also if exponent>32, round quotient to single precision 
  // and subtract 1 ulp: q=q-q*(1.25*2^{-24})
  (p7) fnma.s.s1 f11=f13,f12,f13
  nop.i 0;;
}

  {.mfi
  nop.m 0
  // (p8) calculate remainder (82-bit format)
  (p8) fnma.s1 f11=f13,f7,f6
  nop.i 0
}
  {.mfi
  nop.m 0
  // (p7) calculate remainder (assuming f11=RZ(Q))
  (p7) fnma.s1 f6=f11,f7,f6
  nop.i 0;;
}


  {.mfi
  nop.m 0
  // Final iteration (p8): is f6 the correct remainder (quotient was not overestimated) ?
  (p8) fcmp.lt.unc.s1 p6,p10=f11,f0
  nop.i 0;;
}
  {.mfi
  nop.m 0
  // get new quotient estimation: a'*y2
  (p7) fma.s1 f13=f14,f10,f0
  nop.i 0
}
  {.mfb
  nop.m 0
  // was f14=RZ(Q) ? (then new remainder f14>=0)
  (p7) fcmp.lt.unc.s1 p7,p9=f14,f0
  nop.b 0;;
}


.pred.rel "mutex",p6,p10
  {.mfb
  nop.m 0
  // add b to estimated remainder (to cover the case when the quotient was overestimated) 
  // also set correct sign by using f9=|b|*sgn(a), f12=sgn(a)
  (p6) fma.d.s0 f8=f11,f12,f9
  nop.b 0
}
  {.mfb
  nop.m 0
  // calculate remainder (single precision)
  // set correct sign of result before returning
  (p10) fma.d.s0 f8=f11,f12,f0
  (p8) br.ret.sptk b0;;
}
  {.mfi
  nop.m 0
  // if f13!=RZ(Q), get alternative quotient estimation: a''*y2
  (p7) fma.s1 f13=f6,f10,f0
  nop.i 0
}
  {.mfb
  nop.m 0
  // if f14 was RZ(Q), set remainder to f14
  (p9) mov f6=f14
  br.cond.sptk loop53;;
}



FMOD_X_NAN_INF: 

// Y zero ?
{.mfi 
  nop.m 0
  fma.s1 f10=f9,f1,f0
  nop.i 0;;
}
{.mfi
 nop.m 0
 fcmp.eq.unc.s1 p11,p0=f10,f0
 nop.i 0;;
}
{.mib
  nop.m 0
  nop.i 0
  // if Y zero
  (p11) br.cond.spnt FMOD_Y_ZERO;;                        
}

// X infinity? Return QNAN indefinite
{ .mfi
      nop.m 999
      fclass.m.unc  p8,p9 = f8, 0x23 
      nop.i 999;; 
}
// Y NaN ?
{.mfi
	 nop.m 999
(p8) fclass.m p9,p8=f9,0xc3
	 nop.i 0;;
}
{.mfi
	  nop.m 999
(p8)  frcpa.s0 f8,p0 = f8,f8           
      nop.i 0
} 
{ .mfi
      nop.m 999
	// also set Denormal flag if necessary
(p8)  fma.s0 f9=f9,f1,f0
      nop.i 999 ;;
}

{ .mfb
      nop.m 999
(p8)  fma.d f8=f8,f1,f0                     
	  nop.b 999 ;;                        
}

{ .mfb
      nop.m 999
(p9)  frcpa.s0 f8,p7=f8,f9                     
      br.ret.sptk   b0 ;;                        
}


FMOD_Y_NAN_INF_ZERO: 

// Y INF
{ .mfi
      nop.m 999
      fclass.m.unc  p7,p0 = f9, 0x23           
      nop.i 999 ;;
}

{ .mfb
      nop.m 999
(p7)  fma.d f8=f8,f1,f0                     
(p7)  br.ret.spnt    b0 ;;                        
}

// Y NAN?
{ .mfi
      nop.m 999
      fclass.m.unc  p9,p0 = f9, 0xc3           
      nop.i 999 ;;
}

{ .mfb
      nop.m 999
(p9)  fma.d f8=f9,f1,f0                     
(p9)  br.ret.spnt    b0 ;;                        
}

FMOD_Y_ZERO:
// Y zero? Must be zero at this point
// because it is the only choice left.
// Return QNAN indefinite

{.mfi
  nop.m 0
  // set Invalid
  frcpa f12,p0=f0,f0
  nop.i 0
}
// X NAN?
{ .mfi
      nop.m 999
      fclass.m.unc  p9,p10 = f8, 0xc3           
      nop.i 999 ;;
}
{ .mfi
      nop.m 999
(p10)  fclass.nm  p9,p10 = f8, 0xff           
      nop.i 999 ;;
}

{.mfi
 nop.m 999
 (p9) frcpa f11,p7=f8,f0
 nop.i 0;;
}

{ .mfi
      nop.m 999
(p10)  frcpa         f11,p7 = f9,f9           
      mov        GR_Parameter_TAG = 121 ;;                                 
}

{ .mfi
      nop.m 999
      fmerge.s      f10 = f8, f8             
      nop.i 999
}

{ .mfb
      nop.m 999
      fma.d f8=f11,f1,f0                     
      br.sptk __libm_error_region;; 
}

.endp fmod

.proc __libm_error_region
__libm_error_region:
.prologue
{ .mfi
        add   GR_Parameter_Y=-32,sp             // Parameter 2 value
        nop.f 0
.save   ar.pfs,GR_SAVE_PFS
        mov  GR_SAVE_PFS=ar.pfs                 // Save ar.pfs 
}
{ .mfi
.fframe 64 
        add sp=-64,sp                           // Create new stack
        nop.f 0
        mov GR_SAVE_GP=gp                       // Save gp
};;
{ .mmi
        stfd [GR_Parameter_Y] = FR_Y,16         // Save Parameter 2 on stack
        add GR_Parameter_X = 16,sp              // Parameter 1 address
.save   b0, GR_SAVE_B0                      
        mov GR_SAVE_B0=b0                       // Save b0 
};;
.body
{ .mib
        stfd [GR_Parameter_X] = FR_X            // Store Parameter 1 on stack 
        add   GR_Parameter_RESULT = 0,GR_Parameter_Y  
	nop.b 0                                 // Parameter 3 address
}
{ .mib
        stfd [GR_Parameter_Y] = FR_RESULT      // Store Parameter 3 on stack
        add   GR_Parameter_Y = -16,GR_Parameter_Y  
        br.call.sptk b0=__libm_error_support#  // Call error handling function
};;
{ .mmi
        nop.m 0
        nop.m 0
        add   GR_Parameter_RESULT = 48,sp
};;
{ .mmi
        ldfd  f8 = [GR_Parameter_RESULT]       // Get return result off stack
.restore
        add   sp = 64,sp                       // Restore stack pointer
        mov   b0 = GR_SAVE_B0                  // Restore return address
};;
{ .mib
        mov   gp = GR_SAVE_GP                  // Restore gp 
        mov   ar.pfs = GR_SAVE_PFS             // Restore ar.pfs
        br.ret.sptk     b0                     // Return
};; 

.endp __libm_error_region


.type   __libm_error_support#,@function
.global __libm_error_support#
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\ia64\huge.s ===
#ifdef _NTSDK
#ifdef CRTDLL
.global _HUGE_dll
#else
.global _HUGE
#endif
#else
.global _HUGE
#endif

	.sdata

#ifdef _NTSDK
#ifdef CRTDLL
_HUGE_dll:
#else
_HUGE:
#endif
#else
_HUGE:
#endif

        data8 0x7ff0000000000000


#include "ksia64.h"

        LEAF_ENTRY(_get_fpsr)

        mov       v0 = ar.fpsr
        br.ret.sptk b0

        LEAF_EXIT(_get_fpsr)

        LEAF_ENTRY(_set_fpsr)

        mov       ar.fpsr = a0
        br.ret.sptk b0

        LEAF_EXIT(_get_fpsr)

        LEAF_ENTRY(_scale)

        ldfe	 f10 = [a0]
        ;;
        getf.exp r30 = f10
        sxt4     a1 = a1
        ;;
        add      r30 = a1, r30
        ;;
        setf.exp f10 = r30
        ;;
        stfe	  [a0] = f10
        br.ret.sptk b0

        LEAF_EXIT(_scale)

        LEAF_ENTRY(_convert_fp80tofp64)

        ldfe	f10 = [a0]
        ;;
        fnorm.d f10 = f10
        ;;
        stfd	[a1] = f10
        br.ret.sptk b0

        LEAF_EXIT(_convert_fp80tofp64)

        LEAF_ENTRY(_convert_fp80tofp32)

        ldfe	f10 = [a0]
        ;;
        fnorm.s f10 = f10
        ;;
        stfs	[a1] = f10
        br.ret.sptk b0

        LEAF_EXIT(_convert_fp80tofp32)

        LEAF_ENTRY(_fclrf)
        
        fclrf.s0
        br.ret.sptk b0

        LEAF_EXIT(_fclrf)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\ia64\fpsr.s ===
//##########################################################################
//**
//**  Copyright  (C) 1996-2000 Intel Corporation. All rights reserved.
//**
//** The information and source code contained herein is the exclusive
//** property of Intel Corporation and may not be disclosed, examined
//** or reproduced in whole or in part without explicit written authorization
//** from the company.
//**
//###########################################################################

  .file "fpsr.s"
  .section .text
  .align 32

  .proc __set_fpsr#
  .global __set_fpsr#
__set_fpsr:
  alloc r31=ar.pfs,1,1,0,0  // r32, r33

  // &fpsr is in r32

  // load new fpsr in r33
  ld8 r33 = [r32];;
  // set new value of FPSR
  mov ar40 = r33;;
  // return
  br.ret.sptk b0

  .endp __set_fpsr

  .proc __get_fpsr#
  .global __get_fpsr#
__get_fpsr:
  alloc r31=ar.pfs,1,1,0,0  // r32, r33

  // &fpsr is in r32

  // get old value of FPSR
  mov r33 = ar40;;
  // store new fpsr from r33
  st8 [r32] = r33;;
  // return
  br.ret.sptk b0

  .endp __get_fpsr
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\ia64\frnd.s ===
.file "frnd.s"
  .section .text
  .proc  _frnd#
  .align 32
  .global _frnd#
  .align 32

_frnd:

  // CONVERT BEGINS HERE WITH ARGUMENT IN f8
{ .mmi
  // save the old fpsr in r2
  mov r2=ar40;;
  mov r3=r2
  nop.i 0
} { .mlx
  nop.m 0
  movl r8=0x02000;;
} { .mmi
  // clear sf0.V bit in r3
  andcm r3=r3,r8;;
  // set traps.PDV
  or r3=0x23,r3
  nop.i 0;;
} { .mib
  mov ar40=r3
  nop.i 0
  nop.b 0;;
} { .mfi
  nop.m 0
  fcvt.fx.s0 f7=f8
  nop.i 0;;
} { .mmi
  mov r3=ar40;;
  nop.m 0
  // examine the sf0.V bit (p6 = 1 if sf0.V set)
  tbit.z p6,p7=r3,0x0d;;
} { .mfb
  nop.m 0
(p6) fcvt.xf f8=f7
  nop.b 0;;
}
  // CONVERT ENDS HERE WITH RESULT IN f8
done:
{ .mmb
  mov ar40=r2
  // store result
  nop.m 0
  // return
  br.ret.sptk b0;;
}

  .endp _frnd
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\ia64\hypot.s ===
.file "hypot.asm"

// Copyright (c) 2000, Intel Corporation
// All rights reserved.
// 
// Contributed 2/2/2000 by John Harrison, Cristina Iordache, Ted Kubaska, 
// Bob Norin, Shane Story, and Ping Tak Peter Tang of the 
// Computational Software Lab, Intel Corporation.
// 
// WARRANTY DISCLAIMER
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS 
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY 
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
// 
// Intel Corporation is the author of this code, and requests that all
// problem reports or change requests be submitted to it directly at 
// http://developer.intel.com/opensource.
//
//*********************************************************************
//
// History: 
// 2/02/00  hand-optimized
// 4/04/00  Unwind support added
// 6/20/00  new version
// 8/15/00  Bundle added after call to __libm_error_support to properly
//          set [the previously overwritten] GR_Parameter_RESULT.
//
//*********************************************************************
//                           ___________
// Function:   hypot(x,y) = |(x^2 + y^2) = for double precision values
//             x and y
//             Also provides cabs functionality.
//
//*********************************************************************
//
// Resources Used:
//
//    Floating-Point Registers: f8  (Input and Return Value)
//                              f9  (Input)
//                              f6 -f15, f32-f34
//
//    General Purpose Registers:
//      r2,r3,r29 (Scratch)
//      r32-r36 (Locals)
//      r37-r40 (Used to pass arguments to error handling routine)
//
//    Predicate Registers:      p6 - p10
//
//*********************************************************************
//
// IEEE Special Conditions:
//
//    All faults and exceptions should be raised correctly.
//    Overflow can occur.
//    hypot(Infinity and anything) = +Infinity
//    hypot(QNaN and anything) = QNaN
//    hypot(SNaN and anything ) = QNaN
//
//*********************************************************************
//
// Implementation:
//  x2 = x * x   in double-extended
//  y2 = y * y   in double-extended
//  temp = x2 + y2   in double-extended
//  sqrt(temp) rounded to double 
//
//*********************************************************************

GR_SAVE_PFS         = r33
GR_SAVE_B0          = r34
GR_SAVE_GP          = r35
GR_Parameter_X      = r36
GR_Parameter_Y      = r37
GR_Parameter_RESULT = r38
GR_Parameter_TAG    = r39

FR_X                = f32
FR_Y                = f33
FR_RESULT           = f8

.section .text
.proc _cabs#
.global _cabs#
_cabs: 
.endp _cabs
.proc _hypot#
.global _hypot#
.align 64 

_hypot: 
{.mfi
  alloc r32= ar.pfs,0,4,4,0
  // Compute x*x
  fma.s1 f10=f8,f8,f0
  // r2=bias-1
  mov r2=0xfffe 
}
{.mfi
  // 63/8
  mov r3=0x40fc //0000
  // y*y
  fma.s1 f11=f9,f9,f0
  // r29=429/16
  mov r29=0x41d68;; //000
}

{ .mfi
     nop.m 0
//   Check if x is an Inf - if so return Inf even
//   if y is a NaN (C9X)
     fclass.m.unc p7, p6 = f8, 0x023
     shl r3=r3,16
}
{.mfi
	nop.m 0
  // if possible overflow, copy f8 to f32
  // set Denormal, if necessary 
  // (p8) 
  fma.d.s0 f32=f8,f1,f0
  nop.i 0;;
}
{ .mfi
     nop.m 0
//   Check if y is an Inf - if so return Inf even
//   if x is a NaN (C9X)
     fclass.m.unc p8, p9 = f9, 0x023
     shl r29=r29,12
}
{ .mfb
	 // f7=0.5
	 setf.exp f7=r2
//   For x=inf, multiply y by 1 to raise invalid on y an SNaN
//   (p7) fma.s0 f9=f9,f1,f0
     // copy f9 to f33; set Denormal, if necessary
	 fma.d.s0 f33=f9,f1,f0
     nop.b 0;;
}
{.mfb
  // f13=63/8
  setf.s f13=r3
  // is y Zero ?
  (p6) fclass.m p6,p0=f9,0x7
  nop.b 0
}
{.mlx
  nop.m 0
  movl r2=0x408c0000;;
}

{.mfi
  // f34=429/16
  setf.s f34=r29
  // is x Zero ?
  (p9) fclass.m p9,p0=f8,0x7
  // 231/16
  mov r3=0x4167;; //0000
}
{.mfi
  nop.m 0
  // a=x2+y2
  fma.s1 f12=f10,f1,f11
  nop.i 0;;
}
{.mfi
  nop.m 0
  // y not NaN ?
  (p9) fclass.m p8,p0=f9,0x3f
  shl r3=r3,16
}
{.mfi
  nop.m 0
  // f6=2
  fma.s1 f6=f1,f1,f1
  nop.i 0;;
}


{.mfi
  nop.m 0
  // x not NaN ?
  (p6) fclass.m p7,p0=f8,0x3f
  nop.i 0;;
}
{.mfi
  // f9=35/8
  setf.s f9=r2
  nop.f 0
  // 2*emax-2
  mov r2=0x107fb;;
}

{.mfb
  nop.m 0
  // if f8=Infinity or f9=Zero, return |f8|
  (p7) fmerge.s f8=f0,f32
  (p7) br.ret.spnt b0
}
{.mfb
  nop.m 0
  // if f9=Infinity or f8=Zero, return |f9|
  (p8) fmerge.s f8=f0,f33
  (p8) br.ret.spnt b0;;
}


{.mfi
  // f10 =231/16
  setf.s f10=r3
  // z0=frsqrta(a)
  frsqrta.s1 f8,p6=f12
  nop.i 0;;
}

{ .mfi
	 nop.m 0
//   Identify Natvals, Infs, NaNs, and Zeros 
//   and return result
     fclass.m.unc p7, p0 = f12, 0x1E7
     nop.i 0;;
} 
{.mfb
  // get exponent of x^2+y^2
  getf.exp r3=f12
  // if special case, set f8
  (p7) mov f8=f12
  (p7) br.ret.spnt b0;;
}


{.mfi
  nop.m 0
  // S0=a*z0
  (p6) fma.s1 f14=f12,f8,f0
  nop.i 0
}
{.mfi
  nop.m 0
  // H0=0.5*z0
  (p6) fma.s1 f15=f8,f7,f0
  nop.i 0;;
} 


{.mfi
  nop.m 0
  // f6=5/2
  fma.s1 f6=f7,f1,f6
  nop.i 0
}
{.mfi
  nop.m 0
  // f11=3/2
  fma.s1 f11=f7,f1,f1
  nop.i 0;;
}

{.mfi
  nop.m 0
  // d=0.5-S0*H0
  (p6) fnma.s1 f7=f14,f15,f7
  nop.i 0;;
}

{.mfi
  nop.m 0
  // P67=231/16+429/16*d
  (p6) fma.s1 f10=f34,f7,f10
  nop.i 0
}
{.mfi
  nop.m 0
  // P45=63/8*d+35/8
  (p6) fma.s1 f9=f13,f7,f9
  nop.i 0;;
}
{.mfi
  nop.m 0
  // P23=5/2*d+3/2
  (p6) fma.s1 f11=f6,f7,f11
  nop.i 0
}
{.mfi
  nop.m 0
  // d2=d*d
  (p6) fma.s1 f13=f7,f7,f0
  nop.i 0;;
}

{.mfi
  nop.m 0
  // P47=d2*P67+P45
  (p6) fma.s1 f10=f10,f13,f9
  nop.i 0
}
{.mfi
  nop.m 0
  // P13=d*P23+1
  (p6) fma.s1 f11=f11,f7,f1
  nop.i 0;;
}
{.mfi
  nop.m 0
  // d3=d2*d
  (p6) fma.s1 f13=f13,f7,f0
  nop.i 0;;
}

{.mfi
  nop.m 0
  // T0=d*S0
  (p6) fma.s1 f15=f7,f14,f0
  nop.i 0
}
{.mfi
  // Is x^2 + y^2 well less than the overflow 
  // threshold?
  (p6) cmp.lt.unc p7, p8 =  r3,r2
  // P=P13+d3*P47
  (p6) fma.s1 f10=f13,f10,f11
  nop.i 0;;
}

{.mfb
  nop.m 0
  // S=P*T0+S0
  fma.d.s0 f8=f10,f15,f14
  // No overflow in this case
  (p7) br.ret.sptk b0;;
}

{ .mfi
     nop.m 0  
(p8) fsetc.s2 0x7F,0x42 
     // Possible overflow path, must detect by
     // Setting widest range exponent with prevailing
     // rounding mode.
     nop.i 0 ;;
}


{ .mfi
   // bias+0x400 (bias+EMAX+1)
   (p8) mov r2=0x103ff
   // S=P*T0+S0
   (p8) fma.d.s2 f12=f10,f15,f14
   nop.i 0 ;;
}
{ .mfi
(p8) setf.exp f11 = r2
(p8) fsetc.s2 0x7F,0x40
//   Restore Original Mode in S2
     nop.i 0 ;;
}
{ .mfi
     nop.m 0 
(p8) fcmp.lt.unc.s1 p9, p10 =  f12, f11
     nop.i 0 ;;
}
{ .mib
     nop.m 0
     mov GR_Parameter_TAG = 46
	 // No overflow
(p9) br.ret.sptk b0;; 
}
.endp

.proc __libm_error_region
__libm_error_region:
.prologue
{ .mfi
        add   GR_Parameter_Y=-32,sp             // Parameter 2 value
        nop.f 0
.save   ar.pfs,GR_SAVE_PFS
        mov  GR_SAVE_PFS=ar.pfs                 // Save ar.pfs
}
{ .mfi
.fframe 64
        add sp=-64,sp                           // Create new stack
        nop.f 0
        mov GR_SAVE_GP=gp                       // Save gp
};;
{ .mmi
        stfd [GR_Parameter_Y] = FR_Y,16         // Save Parameter 2 on stack
        add GR_Parameter_X = 16,sp              // Parameter 1 address
.save   b0, GR_SAVE_B0
        mov GR_SAVE_B0=b0                       // Save b0
};;
.body
{ .mib
        stfd [GR_Parameter_X] = FR_X            // Store Parameter 1 on stack
        add   GR_Parameter_RESULT = 0,GR_Parameter_Y
        nop.b 0                                 // Parameter 3 address
}
{ .mib
        stfd [GR_Parameter_Y] = FR_RESULT      // Store Parameter 3 on stack
        add   GR_Parameter_Y = -16,GR_Parameter_Y
        br.call.sptk b0=__libm_error_support#  // Call error handling function
};;
{ .mmi
        nop.m 0
        nop.m 0
        add   GR_Parameter_RESULT = 48,sp
};;
{ .mmi
        ldfd  f8 = [GR_Parameter_RESULT]       // Get return result off stack
.restore
        add   sp = 64,sp                       // Restore stack pointer
        mov   b0 = GR_SAVE_B0                  // Restore return address
};;
{ .mib
        mov   gp = GR_SAVE_GP                  // Restore gp
        mov   ar.pfs = GR_SAVE_PFS             // Restore ar.pfs
        br.ret.sptk     b0                     // Return
};;
.endp 
.type   __libm_error_support#,@function
.global __libm_error_support#
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\ia64\hypotf.s ===
.file "hypotf.asm"

// Copyright (c) 2000, Intel Corporation
// All rights reserved.
// 
// Contributed 2/2/2000 by John Harrison, Cristina Iordache, Ted Kubaska, 
// Bob Norin, Shane Story, and Ping Tak Peter Tang of the 
// Computational Software Lab, Intel Corporation.
// 
// WARRANTY DISCLAIMER
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS 
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY 
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
// 
// Intel Corporation is the author of this code, and requests that all
// problem reports or change requests be submitted to it directly at 
// http://developer.intel.com/opensource.
//
//*********************************************************************
//
// History: 
// 2/02/00  hand-optimized
// 4/04/00  Unwind support added
// 6/26/00  new version
// 8/15/00  Bundle added after call to __libm_error_support to properly
//          set [the previously overwritten] GR_Parameter_RESULT.
//
//*********************************************************************
//                           ___________
// Function:   hypotf(x,y) = |(x^2 + y^2) = for single precision values
//             x and y
//             Also provides cabsf functionality.
//
//*********************************************************************
//
// Resources Used:
//
//    Floating-Point Registers: f8  (Input and Return Value)
//                              f9  (Input)
//                              f6 -f15
//
//    General Purpose Registers:
//      r2-r3   (Scratch)
//      r32-r36 (Locals)
//      r37-r40 (Used to pass arguments to error handling routine)
//
//    Predicate Registers:      p6 - p10
//
//*********************************************************************
//
// IEEE Special Conditions:
//
//    All faults and exceptions should be raised correctly.
//    Overflow can occur.
//    hypotf(Infinity and anything) = +Infinity
//    hypotf(QNaN and anything) = QNaN
//    hypotf(SNaN and anything ) = QNaN
//
//*********************************************************************
//
// Implementation:
//  x2 = x * x   in double-extended
//  y2 = y * y   in double-extended
//  temp = x2 + y2   in double-extended
//  sqrt(temp) rounded to single precision 
//
//*********************************************************************

GR_SAVE_PFS         = r33
GR_SAVE_B0          = r34
GR_SAVE_GP          = r35
GR_Parameter_X      = r36
GR_Parameter_Y      = r37
GR_Parameter_RESULT = r38
GR_Parameter_TAG    = r39

FR_X                = f14
FR_Y                = f15
FR_RESULT           = f8

.section .text
.proc _cabsf#
.global _cabsf#
_cabsf: 
.endp _cabsf
.proc _hypotf#
.global _hypotf#
.align 64 

_hypotf: 
{.mfi
  alloc r32= ar.pfs,0,4,4,0
  // Compute x*x
  fma.s1 f10=f8,f8,f0
  // r2=bias-1
  mov r2=0xfffe 
}
{.mfi
  nop.m 0
  // y*y
  fma.s1 f11=f9,f9,f0
  nop.i 0;;
}

{ .mfi
     nop.m 0
//   Check if x is an Inf - if so return Inf even
//   if y is a NaN (C9X)
     fclass.m.unc p7, p6 = f8, 0x023
     nop.i 0
}
{.mfi
  nop.m 0
  // if possible overflow, copy f8 to f14
  // set Denormal, if necessary 
  // (p8) 
  fma.s.s0 f14=f8,f1,f0
  nop.i 0;;
}

{ .mfi
     nop.m 0
//   Check if y is an Inf - if so return Inf even
//   if x is a NaN (C9X)
     fclass.m.unc p8, p9 = f9, 0x023
	 nop.i 0
}
{ .mfi
     nop.m 0
//   For x=inf, multiply y by 1 to raise invalid on y an SNaN
//   (p7) fma.s0 f9=f9,f1,f0
     // copy f9 to f15; set Denormal, if necessary
	 fma.s.s0 f15=f9,f1,f0
     nop.i 0;;
}
{.mfi
  nop.m 0
  // is y Zero ?
  (p6) fclass.m p6,p0=f9,0x7
  nop.i 0;;
}
{.mfi
  nop.m 0
  // is x Zero ?
  (p9) fclass.m p9,p0=f8,0x7
  nop.i 0;;
}

{.mfi
  // f7=0.5
  setf.exp f7=r2
  // a=x2+y2
  fma.s1 f12=f10,f1,f11
  nop.i 0;;
}

{.mfi
  nop.m 0
  // x not NaN ?
  (p6) fclass.m p7,p0=f8,0x3f
  nop.i 0
}
{.mfi
  // 2*emax-2
  mov r2=0x100fb
  // f6=2
  fma.s1 f6=f1,f1,f1
  nop.i 0;;
}

{.mfi
  nop.m 0
  // y not NaN ?
  (p9) fclass.m p8,p0=f9,0x3f
  nop.i 0;;
}

{.mfb
  nop.m 0
  // if f8=Infinity or f9=Zero, return |f8|
  (p7) fmerge.s f8=f0,f14
  (p7) br.ret.spnt b0
}
{.mfb
  nop.m 0
  // if f9=Infinity or f8=Zero, return |f9|
  (p8) fmerge.s f8=f0,f15
  (p8) br.ret.spnt b0;;
}

{ .mfi
	 nop.m 0
//   Identify Natvals, Infs, NaNs, and Zeros 
//   and return result
     fclass.m.unc p7, p0 = f12, 0x1E7
     nop.i 0
} 
{.mfi
  nop.m 0
  // z0=frsqrta(a)
  frsqrta.s1 f8,p6=f12
  nop.i 0;;
}

{.mfb
  // get exponent of x^2+y^2
  getf.exp r3=f12
  // if special case, set f8
  (p7) mov f8=f12
  (p7) br.ret.spnt b0;;
}


{.mfi
  nop.m 0
  // S0=a*z0
  (p6) fma.s1 f12=f12,f8,f0
  nop.i 0
}
{.mfi
  nop.m 0
  // H0=0.5*z0
  (p6) fma.s1 f10=f8,f7,f0
  nop.i 0;;
} 


{.mfi
  nop.m 0
  // f6=5/2
  fma.s1 f6=f7,f1,f6
  nop.i 0
}
{.mfi
  nop.m 0
  // f11=3/2
  fma.s1 f11=f7,f1,f1
  nop.i 0;;
}

{.mfi
  nop.m 0
  // d=0.5-S0*H0
  (p6) fnma.s1 f7=f12,f10,f7
  nop.i 0;;
}

{.mfi
  nop.m 0
  // P01=d+1
  (p6) fma.s1 f10=f1,f7,f1
  nop.i 0
}
{.mfi
  nop.m 0
  // P23=5/2*d+3/2
  (p6) fma.s1 f11=f6,f7,f11
  nop.i 0;;
}
{.mfi
  nop.m 0
  // d2=d*d
  (p6) fma.s1 f7=f7,f7,f0
  nop.i 0;;
}


{.mfi
  // Is x^2 + y^2 well less than the overflow 
  // threshold?
  (p6) cmp.lt.unc p7, p8 =  r3,r2
  // P=P01+d2*P23
  (p6) fma.s1 f10=f7,f11,f10
  nop.i 0;;
}

{.mfb
  nop.m 0
  // S=P*S0
  fma.s.s0 f8=f10,f12,f0
  // No overflow in this case
  (p7) br.ret.sptk b0;;
}

{ .mfi
     nop.m 0  
(p8) fsetc.s2 0x7F,0x42 
     // Possible overflow path, must detect by
     // Setting widest range exponent with prevailing
     // rounding mode.
     nop.i 0 ;;
}


{ .mfi
   // bias+0x400 (bias+EMAX+1)
   (p8) mov r2=0x1007f
   // S=P*S0
   (p8) fma.s.s2 f12=f10,f12,f0
   nop.i 0 ;;
}
{ .mfi
(p8) setf.exp f11 = r2
(p8) fsetc.s2 0x7F,0x40
//   Restore Original Mode in S2
     nop.i 0 ;;
}
{ .mfi
     nop.m 0 
(p8) fcmp.lt.unc.s1 p9, p10 =  f12, f11
     nop.i 0 ;;
}
{ .mib
     nop.m 0
     mov GR_Parameter_TAG = 47
	 // No overflow
(p9) br.ret.sptk b0;; 
}
.endp

.proc __libm_error_region
__libm_error_region:
.prologue
{ .mii
        add   GR_Parameter_Y=-32,sp             // Parameter 2 value
(p0)    mov   GR_Parameter_TAG = 47                   
.save   ar.pfs,GR_SAVE_PFS
        mov  GR_SAVE_PFS=ar.pfs                 // Save ar.pfs
}
{ .mfi
.fframe 64
        add sp=-64,sp                           // Create new stack
        nop.f 0
        mov GR_SAVE_GP=gp                       // Save gp
};;
{ .mmi
        stfs [GR_Parameter_Y] = FR_Y,16         // Store Parameter 2 on stack
        add GR_Parameter_X = 16,sp              // Parameter 1 address
.save   b0, GR_SAVE_B0
        mov GR_SAVE_B0=b0                       // Save b0
};;
.body
{ .mib
        stfs [GR_Parameter_X] = FR_X            // Store Parameter 1 on stack
        add   GR_Parameter_RESULT = 0,GR_Parameter_Y
        nop.b 0                                 // Parameter 3 address
}
{ .mib
        stfs [GR_Parameter_Y] = FR_RESULT       // Store Parameter 3 on stack
        add   GR_Parameter_Y = -16,GR_Parameter_Y
        br.call.sptk b0=__libm_error_support#   // Call error handling function
};;
{ .mmi
        nop.m 0
        nop.m 0
        add   GR_Parameter_RESULT = 48,sp
};;
{ .mmi
        ldfs  f8 = [GR_Parameter_RESULT]       // Get return result off stack
.restore
        add   sp = 64,sp                       // Restore stack pointer
        mov   b0 = GR_SAVE_B0                  // Restore return address
};;
{ .mib
        mov   gp = GR_SAVE_GP                  // Restore gp 
        mov   ar.pfs = GR_SAVE_PFS             // Restore ar.pfs
        br.ret.sptk     b0                     // Return
};; 

.endp __libm_error_region


.type   __libm_error_support#,@function
.global __libm_error_support#
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\ia64\isnan.s ===
.file "isnan.s"

// Copyright (c) 2000, 2001, Intel Corporation
// All rights reserved.
// 
// Contributed 2/2/2000 by John Harrison, Ted Kubaska, Bob Norin, Shane Story,
// and Ping Tak Peter Tang of the Computational Software Lab, Intel Corporation.
// 
// WARRANTY DISCLAIMER
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS 
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY 
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
// 
// Intel Corporation is the author of this code, and requests that all
// problem reports or change requests be submitted to it directly at 
// http://developer.intel.com/opensource.
//
// History
//==============================================================
// 2/02/00: Initial version

.align 32
.global _isnan#

.section .text
.proc  _isnan#
.align 32

// API
//==============================================================
// int _isnan  (double x)

// Overview of operation
//==============================================================
// returns 1 if x is a nan; 0 otherwise 
// takes no exceptions

// Registers used
//==============================================================

// general registers used:     
// r8 for return value

// floating-point registers used: 
// f8

// predicate registers used
// p6, p7

// qnan snan inf norm     unorm 0 -+
// 1    1    0   0        0     0 11

_isnan: 
{ .mfi
      nop.m 999
      fclass.m.unc   p6,p7 = f8,0xc3           
      nop.i 999 ;;
}

{ .mib
(p6)  addl           r8 = 0x1,r0               
(p7)  addl           r8 = 0x0,r0               
      br.ret.sptk    b0 ;;                        
}

.endp _isnan
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\ia64\libm_atan2_reg.s ===
.file "libm_atan2_reg.s"

// Copyright (c) 2000, 2001, Intel Corporation
// All rights reserved.
// 
// Contributed 2/2/2000 by John Harrison, Ted Kubaska, Bob Norin, Shane Story,
// and Ping Tak Peter Tang of the Computational Software Lab, Intel Corporation.
// 
// WARRANTY DISCLAIMER
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS 
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY 
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
// 
// Intel Corporation is the author of this code, and requests that all
// problem reports or change requests be submitted to it directly at 
// http://developer.intel.com/opensource.
//
// History
//==============================================================
// 2/02/00: Initial version
// 4/04/00  Unwind support added

.data

.align 64
Constants_atan:
data4   0x54442D18, 0x3FF921FB, 0x248D3132, 0x3E000000
// double pi/2, single lo_pi/2, two**(-3)
data4   0xAAAAAAA3, 0xAAAAAAAA, 0x0000BFFD, 0x00000000 // P_1
data4   0xCCCC54B2, 0xCCCCCCCC, 0x00003FFC, 0x00000000 // P_2
data4   0x47E4D0C2, 0x92492492, 0x0000BFFC, 0x00000000 // P_3
data4   0x58870889, 0xE38E38E0, 0x00003FFB, 0x00000000 // P_4
data4   0x290149F8, 0xBA2E895B, 0x0000BFFB, 0x00000000 // P_5
data4   0x250F733D, 0x9D88E6D4, 0x00003FFB, 0x00000000 // P_6
data4   0xFB8745A0, 0x884E51FF, 0x0000BFFB, 0x00000000 // P_7
data4   0x394396BD, 0xE1C7412B, 0x00003FFA, 0x00000000 // P_8
data4   0xAAAAA52F, 0xAAAAAAAA, 0x0000BFFD, 0x00000000 // Q_1
data4   0xC75B60D3, 0xCCCCCCCC, 0x00003FFC, 0x00000000 // Q_2
data4   0x011F1940, 0x924923AD, 0x0000BFFC, 0x00000000 // Q_3
data4   0x2A5F89BD, 0xE36F716D, 0x00003FFB, 0x00000000 // Q_4
//      Entries Tbl_hi  (double precision)
//      B = 1+Index/16+1/32  Index = 0
//      Entries Tbl_lo (single precision)
//      B = 1+Index/16+1/32  Index = 0
data4   0xA935BD8E, 0x3FE9A000, 0x23ACA08F, 0x00000000
// Entries Tbl_hi  (double precision) Index = 0,1,...,15
// B = 2^(-1)*(1+Index/16+1/32)
// Entries Tbl_lo (single precision)
// Index = 0,1,...,15  B = 2^(-1)*(1+Index/16+1/32)
data4   0x7F175A34, 0x3FDE77EB, 0x238729EE, 0x00000000
data4   0x73C1A40B, 0x3FE0039C, 0x249334DB, 0x00000000
data4   0x5B5B43DA, 0x3FE0C614, 0x22CBA7D1, 0x00000000
data4   0x88BE7C13, 0x3FE1835A, 0x246310E7, 0x00000000
data4   0xE2CC9E6A, 0x3FE23B71, 0x236210E5, 0x00000000
data4   0x8406CBCA, 0x3FE2EE62, 0x2462EAF5, 0x00000000
data4   0x1CD41719, 0x3FE39C39, 0x24B73EF3, 0x00000000
data4   0x5B795B55, 0x3FE44506, 0x24C11260, 0x00000000
data4   0x5BB6EC04, 0x3FE4E8DE, 0x242519EE, 0x00000000
data4   0x1F732FBA, 0x3FE587D8, 0x24D4346C, 0x00000000
data4   0x115D7B8D, 0x3FE6220D, 0x24ED487B, 0x00000000
data4   0x920B3D98, 0x3FE6B798, 0x2495FF1E, 0x00000000
data4   0x8FBA8E0F, 0x3FE74897, 0x223D9531, 0x00000000
data4   0x289FA093, 0x3FE7D528, 0x242B0411, 0x00000000
data4   0x576CC2C5, 0x3FE85D69, 0x2335B374, 0x00000000
data4   0xA99CC05D, 0x3FE8E17A, 0x24C27CFB, 0x00000000
//
//      Entries Tbl_hi  (double precision) Index = 0,1,...,15
//      B = 2^(-2)*(1+Index/16+1/32)
//      Entries Tbl_lo (single precision)
//      Index = 0,1,...,15  B = 2^(-2)*(1+Index/16+1/32)
//
data4   0x510665B5, 0x3FD025FA, 0x24263482, 0x00000000
data4   0x362431C9, 0x3FD1151A, 0x242C8DC9, 0x00000000
data4   0x67E47C95, 0x3FD20255, 0x245CF9BA, 0x00000000
data4   0x7A823CFE, 0x3FD2ED98, 0x235C892C, 0x00000000
data4   0x29271134, 0x3FD3D6D1, 0x2389BE52, 0x00000000
data4   0x586890E6, 0x3FD4BDEE, 0x24436471, 0x00000000
data4   0x175E0F4E, 0x3FD5A2E0, 0x2389DBD4, 0x00000000
data4   0x9F5FA6FD, 0x3FD68597, 0x2476D43F, 0x00000000
data4   0x52817501, 0x3FD76607, 0x24711774, 0x00000000
data4   0xB8DF95D7, 0x3FD84422, 0x23EBB501, 0x00000000
data4   0x7CD0C662, 0x3FD91FDE, 0x23883A0C, 0x00000000
data4   0x66168001, 0x3FD9F930, 0x240DF63F, 0x00000000
data4   0x5422058B, 0x3FDAD00F, 0x23FE261A, 0x00000000
data4   0x378624A5, 0x3FDBA473, 0x23A8CD0E, 0x00000000
data4   0x0AAD71F8, 0x3FDC7655, 0x2422D1D0, 0x00000000
data4   0xC9EC862B, 0x3FDD45AE, 0x2344A109, 0x00000000
//
//      Entries Tbl_hi  (double precision) Index = 0,1,...,15
//      B = 2^(-3)*(1+Index/16+1/32)
//      Entries Tbl_lo (single precision)
//      Index = 0,1,...,15  B = 2^(-3)*(1+Index/16+1/32)
//
data4   0x84212B3D, 0x3FC068D5, 0x239874B6, 0x00000000
data4   0x41060850, 0x3FC16465, 0x2335E774, 0x00000000
data4   0x171A535C, 0x3FC25F6E, 0x233E36BE, 0x00000000
data4   0xEDEB99A3, 0x3FC359E8, 0x239680A3, 0x00000000
data4   0xC6092A9E, 0x3FC453CE, 0x230FB29E, 0x00000000
data4   0xBA11570A, 0x3FC54D18, 0x230C1418, 0x00000000
data4   0xFFB3AA73, 0x3FC645BF, 0x23F0564A, 0x00000000
data4   0xE8A7D201, 0x3FC73DBD, 0x23D4A5E1, 0x00000000
data4   0xE398EBC7, 0x3FC8350B, 0x23D4ADDA, 0x00000000
data4   0x7D050271, 0x3FC92BA3, 0x23BCB085, 0x00000000
data4   0x601081A5, 0x3FCA217E, 0x23BC841D, 0x00000000
data4   0x574D780B, 0x3FCB1696, 0x23CF4A8E, 0x00000000
data4   0x4D768466, 0x3FCC0AE5, 0x23BECC90, 0x00000000
data4   0x4E1D5395, 0x3FCCFE65, 0x2323DCD2, 0x00000000
data4   0x864C9D9D, 0x3FCDF110, 0x23F53F3A, 0x00000000
data4   0x451D980C, 0x3FCEE2E1, 0x23CCB11F, 0x00000000
data4   0x54442D18, 0x400921FB, 0x33145C07, 0x3CA1A626 // I two doubles
data4   0x54442D18, 0x3FF921FB, 0x33145C07, 0x3C91A626 // I_by_2 two dbls
data4   0x54442D18, 0x3FE921FB, 0x33145C07, 0x3C81A626 // I_by_4 two dbls
data4   0x7F3321D2, 0x4002D97C, 0x4C9E8A0A, 0x3C9A7939 // 3I_by_4 two dbls
.section .text

.proc __libm_atan2_reg#
.global __libm_atan2_reg#
.align 64
__libm_atan2_reg:


{ .mfi
       alloc  r32 = ar.pfs,0,20,4,0
       mov f32 = f8
       nop.i 0
} 
{ .mmi
      nop.m 0
      addl           r39   = @ltoff(Constants_atan#), gp
      nop.i 999
}
;;

{ .mmi
      ld8 r39 = [r39]
      nop.m 999
      nop.i 999
}
;;

{ .mfi
       nop 999	// EMbo added ...
       mov f33 = f9
 nop.i 0
 } { .mfi
       nop 999	// EMbo added ...
       fclass.nm.unc p9,p0 = f32 ,0x1FF
       nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
       fclass.nm.unc p8,p0 = f33 ,0x1FF
	nop 999	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
       fclass.m.unc  p6,p0 = f33 ,0x103
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
       fclass.m.unc  p7,p0 = f32 ,0x103
	nop 999	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
       fclass.m.unc p12,p0 = f33 ,0x0C3
	nop 999;;	// EMbo added ...
 } { .mfb
	nop 999	// EMbo added ...
//
//     Check for NatVals.
//     Check for EM Unsupporteds
//     Check for NaNs.
//
       fclass.m.unc p13,p0 = f32 ,0x0C3
(p6)   br.cond.sptk ATAN_NATVAL;;
 } { .mbb
	nop 999	// EMbo added ...
(p7)   br.cond.sptk ATAN_NATVAL
(p8)   br.cond.sptk ATAN_UNSUPPORTED;;
 } { .mib
       add r40 = 96, r39
	nop 999	// EMbo added ...
(p9)   br.cond.sptk ATAN_UNSUPPORTED;;
 } { .mib
       ldfd  f50 = [r39],8
	nop 999	// EMbo added ...
(p12)  br.cond.sptk ATAN_NAN;;
 } { .mfb
	nop 999	// EMbo added ...
       fnorm.s1 f33 = f33
(p13)  br.cond.sptk ATAN_NAN;;
 } { .mfi
       ldfs  f51 = [r39],4
//
//     Remove sign bits from exponents
//     Load 2**(-3)
//     Normalize the input argument.
//
       fnorm.s1 f32 = f32
	nop 999	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
       mov f82 = f1
	nop 999;;	// EMbo added ...
 } { .mmi
	nop 999;;	// EMbo added ...
       ldfs  f78 = [r39],180
	nop 999;;	// EMbo added ...
 } { .mmi
       getf.exp r36 = f33;;
//
//     Get exp and sign of ArgX
//     Get exp and sign of ArgY
//     Load 2**(-3) and increment ptr to Q_4.
//
       getf.exp r37 = f32
       shr.u r36 = r36,17;;
 } { .mfi
	nop 999	// EMbo added ...
       fmerge.s f84 =  f1,f32
       shr.u r37 = r37,17;;
 } { .mfi
	nop 999	// EMbo added ...
//
//     ArgX_abs = |ArgX|
//     ArgY_abs = |ArgY|
//     sign_X is sign bit of ArgX
//     sign_Y is sign bit of ArgY
//
       fmerge.s f83 =  f1,f33
       cmp.eq.unc  p8,p9 = 0x00000, r37;;
 } { .mfi
	nop 999	// EMbo added ...
(p8)   fadd.s1 f34 = f0, f1
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
(p9)   fsub.s1 f34 = f0, f1
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
       fmin.s1 f36 = f83, f84
	nop 999	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
       fmax.s1 f35 = f83, f84
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
//
//     Is ArgX_abs >= ArgY_abs
//     Is sign_Y == 0?
//
       fcmp.ge.s1  p6,p7 = f83,f84
	nop 999;;	// EMbo added ...
 } { .mii
(p6)   cmp.eq.unc  p10, p11 =  0x00000, r36
(p6)   add r38 = r0, r0;;
//
//     U = max(ArgX_abs,ArgY_abs)
//     V = min(ArgX_abs,ArgY_abs)
//     if p6, swap = 0
//     if p7, swap = 1
//
//
//     Let M = 1.0
//     if p8, s_Y = 1.0
//     if p9, s_Y = -1.0
//
(p7)   add r38 = 1,r0;;
 } { .mfi
	nop 999	// EMbo added ...
       frcpa.s1 f37, p6 =  f36, f35
	nop 999;;	// EMbo added ...
 } { .mfb
	nop 999	// EMbo added ...
//
//     E = frcpa(V,U)
//
(p10)  fsub.s1 f82 = f82, f1
(p6)   br.cond.sptk ATAN_STEP2;;
 } { .mib
	nop 999	// EMbo added ...
	nop 999	// EMbo added ...
// /**************************************************/
// /********************* STEP2 **********************/
// /**************************************************/
       br.cond.spnt ATAN_SPECIAL_HANDLING;;
 }
ATAN_STEP2:
 { .mlx
	nop 999	// EMbo added ...
       movl r47 =  0x8400000000000000
 } { .mlx
	nop 999	// EMbo added ...
       movl r48 =  0x0000000000000100;;
 } { .mfi
	nop 999	// EMbo added ...
       fmpy.s1 f38 = f37, f36
	nop 999	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
       fcmp.lt.unc.s0  p0,p9 = f9,f1
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
       fcmp.lt.unc.s0  p0,p8 = f8,f1
	nop 999	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
//
//     Q = E * V
//
(p11)  fadd.s1 f82 = f82, f1
	nop 999;;	// EMbo added ...
 } { .mfi
       getf.sig r46 = f38
       fcmp.lt.unc p6,p7 = f38,f78
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
       fmpy.s1 f38 = f37, f36
       extr.u r42 = r46, 59, 4;;
 } { .mfi
	nop 999	// EMbo added ...
       fmpy.s1 f50 = f82, f50
       dep r47 = r42, r47, 59, 4
 } { .mfi
	nop 999	// EMbo added ...
       fmpy.s1 f51 = f82, f51
	nop 999;;	// EMbo added ...
 } { .mmi
	nop 999;;	// EMbo added ...
//
//     Is Q < 2**(-3)?
//
//
//     Do fcmp to raise any denormal operand
//     exceptions.
//
       getf.exp r45 = f38
	nop 999;;	// EMbo added ...
 } { .mib
//
//     lookup = b_1 b_2 b_3 B_4
//
//
//     Generate 1.b_1 b_2 b_3 b_4 1 0 0 0 ... 0
//
       andcm r41 = 0x0003, r45
	nop 999	// EMbo added ...
//
//     We waited a few extra cycles so P_lo and P_hi could be calculated.
//     Load the constant 256 for loading up table entries.
//
//    /**************************************************/
//    /********************* STEP3 **********************/
//    /**************************************************/
(p6)   br.cond.spnt ATAN_POLY;;
 } { .mii
       setf.sig f39 = r47
       cmp.eq.unc  p8, p9 =  0x0000, r41
//
//     z_hi = s exp 1.b_1 b_2 b_3 b_4 1 0 0 0 ... 0
//     point to beginning of Tbl_hi entries - k = 0.
//
       add r40 = 16, r39
 } { .mmi
       ldfe f73 = [r39],-16;;
(p9)   sub r41 = r41,r0,1
(p9)   add r40 = 16,r40
 } { .mfi
(p8)   ldfd  f48 = [r40],8
       fmpy.s1 f50 = f34, f50
       xor r38 = r36,r38;;
 } { .mmi
       ldfe f71 = [r39],-16;;
(p8)   ldfs  f49 = [r40],8
(p9)   pmpy2.r r41 = r41,r48;;
 } { .mfi
       ldfe f69 = [r39],-16
//
//     Let z_hi have exponent and sign of original Q
//     Load the Tbl_hi(0) else, increment pointer.
//
       fmerge.se f39 =  f38,f39
(p9)   shladd r42 = r42,0x0004,r41;;
 } { .mmi
(p9)   add r40 = r40, r42;;
(p9)   ldfd  f48 = [r40],8
	nop 999;;	// EMbo added ...
 } { .mmi
       ldfe f67 = [r39],-16;;
(p9)   ldfs  f49 = [r40],8
	nop 999	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
//
//     U_prime_hi = U + V * z_hi
//     Load the Tbl_lo(0)
//
       fma.s1 f40 = f36, f39, f35
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
       fnma.s1 f42 = f35, f39, f36
	nop 999	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
       mov f52 = f48
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
       frcpa.s1 f43, p6 =  f1, f40
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
//
//     U_prime_lo = U - U_prime_hi
//     k = k * 256 - result can be 0, 256, or 512.
//
       fsub.s1 f41 = f35, f40
       cmp.eq.unc  p7, p6 =  0x00000, r38
 } { .mfi
	nop 999	// EMbo added ...
       fmpy.s1 f52 = f34, f52
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
(p7)   fadd.s1 f54 = f0, f1
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
(p6)   fsub.s1 f54 = f0, f1
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
       fnma.s1 f80 = f43, f40, f1
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
       fadd.s1 f79 = f41, f40
	nop 999	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
       fma.s1 f41 = f36, f39, f41
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
       fma.s1 f56 = f54, f52, f50
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
       fma.s1 f43 = f80, f43, f43
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
//
//     U_prime_lo =  U - U_hold
//     lookup -> lookup * 16 + k
//
//
//     V_prime =  V - U * z_hi
//     U_prime_lo =  V * z_hi + U_prime_lo
//
       fsub.s1 f79 = f35, f79
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
       fnma.s1 f80 = f43, f40, f1
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
//
//     C_hi = frcpa(1,U_prime_hi)
//     U_prime_lo = U_prime_lo + U_hold
//
//
//     C_hi_hold = 1 - C_hi * U_prime_hi (1)
//
//
//     C_hi = C_hi + C_hi * C_hi_hold    (1)
//
//
//     C_hi_hold = 1 - C_hi * U_prime_hi (2)
//
       fadd.s1 f41 = f41, f79
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
//
//     C_hi = C_hi + C_hi * C_hi_hold    (2)
//
       fma.s1 f43 = f80, f43, f43
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
//
//     C_hi_hold = 1 - C_hi * U_prime_hi (3)
//
       fnma.s1 f80 = f43, f40, f1
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
//
//     C_hi = C_hi + C_hi * C_hi_hold    (3)
//
       fma.s1 f43 = f80, f43, f43
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
//
//     w_hi = V_prime * C_hi
//
       fmpy.s1 f44 = f42, f43
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
       fmpy.s1 f46 = f44, f44
	nop 999	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
//
//     wsq = w_hi * w_hi
//     w_lo =  = V_prime - w_hi * U_prime_hi
//
       fnma.s1 f45 = f44, f40, f42
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
       fma.s1 f47 = f46, f73, f71
	nop 999	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
//
//     poly = Q_3 + wsq * Q_4
//     w_lo =  = w_lo - w_hi * U_prime_lo
//
       fnma.s1 f45 = f44, f41, f45
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
       fma.s1 f47 = f46, f47, f69
	nop 999	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
//
//     poly = Q_2 + wsq * poly
//     w_lo =  = w_lo * C_hi
//
       fmpy.s1 f45 = f43, f45
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
       fma.s1 f47 = f46, f47, f67
	nop 999	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
//
//     poly = Q_1 + wsq * poly
//     A_lo = Tbl_lo + w_lo
//     swap = xor(swap,sign_X)
//
       fadd.s1 f53 = f49, f45
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
//
//     Is (swap) != 0 ?
//     poly = wsq * poly
//     A_hi = Tbl_hi
//
       fmpy.s1 f47 = f46, f47
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
//
//     poly = wsq * poly
//
//
//     if (p6) sigma = -1.0
//     if (p7) sigma =  1.0
//
       fmpy.s1 f47 = f44, f47
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
//
//     P_hi = s_Y * P_hi
//     A_lo = A_lo + poly
//
       fadd.s1 f53 = f53, f47
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
//
//     A_lo = A_lo + w_hi
//     A_hi = s_Y * A_hi
//
       fadd.s1 f53 = f53, f44
	nop 999;;	// EMbo added ...
 } { .mfb
	nop 999	// EMbo added ...
//
//     result_hi = P_hi + sigma * A_hi
//     result_lo = P_lo + sigma * A_lo
//
       fma.s1 f55 = f54, f53, f51
       br.cond.sptk RETURN_ATAN;;
} 
//
//     result  =  result_hi + result_lo * s_Y  (User Supplied Rounding Mode)
//
//            fma.d.s0 f57 = f55, f34, f56
//
// /**************************************************/
// /********************* STEP4 **********************/
// /**************************************************/
//
ATAN_POLY:
{ .mmi
       xor r38 = r36,r38
      addl           r39   = @ltoff(Constants_atan#), gp
      nop.i 999
}
;;

{ .mmi
      ld8 r39 = [r39]
      nop.m 999
      nop.i 999
}
;;


{ .mlx
	nop 999	// EMbo added ...
       movl r47 =  0x24005;;
 } { .mfi
       add r39 = 128, r39
       fnma.s1 f81 = f37, f35, f1
       cmp.eq.unc  p7, p6 =  0x00000, r38;;
 } { .mmf
	nop 999	// EMbo added ...
       ldfe f77 = [r39],-16
//
//     Iterate 3 times E = E + E*(1.0 - E*U)
//     Also load P_8, P_7, P_6, P_5, P_4
//     E_hold = 1.0 - E * U     (1)
//     A_temp = Q
//
       mov f85 = f38;;
 } { .mmf
	nop 999	// EMbo added ...
       ldfe f76 = [r39],-16
(p6)   fsub.s1 f54 = f0, f1;;
 } { .mmf
	nop 999	// EMbo added ...
       ldfe f75 = [r39],-16
//
//     E = E + E_hold*E         (1)
//     Point to P_8.
//
       fma.s1 f37 = f37, f81, f37;;
 } { .mmf
	nop 999	// EMbo added ...
       ldfe f74 = [r39],-16
       fnma.s1 f64 = f85, f35, f36;;
 } { .mmf
	nop 999	// EMbo added ...
       ldfe f72 = [r39],-16
(p7)   fadd.s1 f54 = f0, f1;;
 } { .mmf
	nop 999	// EMbo added ...
       ldfe f70 = [r39],-16
//
//     E_hold = 1.0 - E * U     (2)
//
       fnma.s1 f81 = f37, f35, f1;;
 } { .mmf
	nop 999	// EMbo added ...
       ldfe f68 = [r39],-16
       fmpy.s1 f50 = f34, f50;;
 } { .mmf
	nop 999	// EMbo added ...
       ldfe f66 = [r39],-16
       fmpy.d.s0 f67 = f67, f67
 } { .mfi
	nop 999	// EMbo added ...
//
//     E = E + E_hold*E         (2)
//
       fma.s1 f37 = f37, f81, f37
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
//
//     E_hold = 1.0 - E * U     (3)
//
       fnma.s1 f81 = f37, f35, f1
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
//
//     E = E + E_hold*E         (3)
//     At this point E approximates 1/U to roughly working precision
//     z = V*E approximates V/U
//
       fma.s1 f37 = f37, f81, f37
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
//
//     z =   V * E
//
       fmpy.s1 f59 = f36, f37
	nop 999	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
       fmpy.s1 f64 = f64, f37
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
//
//     zsq = z * z
//     Also load P_3
//
       fmpy.s1 f60 = f59, f59
	nop 999	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
       fadd.s1 f52 = f85, f64
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
       fma.s1 f62 = f60, f77, f76
	nop 999	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
       fma.s1 f63 = f60, f70, f68
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
//
//     z8 = zsq * zsq
//     Also load P_2
//
       fmpy.s1 f61 = f60, f60
	nop 999	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
       fsub.s1 f85 = f85, f52
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
       fmerge.s  f65 = f52,f52
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
       fma.s1 f62 = f60, f62, f75
	nop 999	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
       fma.s1 f63 = f60, f63, f66
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
//
//     z8 = z8 * z8
//     Also load P_1
//     poly1 = _4 + zsq*(P_5 + zsq*(P_6 + zsq*(P_7 + zsq*P_8)))
//     poly2 = zsq*(P_1 + zsq*(P_2 + zsq*P_3))
//
//
//     poly1 = P_7 + zsq * P_8
//     poly2 = P_2 + zsq * P_3
//     poly1 = P_4 + zsq*(P_5 + zsq*(P_6 + zsq*poly1))
//     poly2 = zsq*(P_1 + zsq*poly2)
//
//
//     poly1 = P_6 + zsq * poly1
//     poly2 = P_1 + zsq * poly2
//     poly1 = P_4 + zsq*(P_5 + zsq*poly1)
//     poly2 = zsq*poly2
//
       fmpy.s1 f61 = f61, f61
	nop 999	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
       fadd.s1 f64 = f85, f64
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
       fma.s1 f62 = f60, f62, f74
	nop 999	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
//
//     poly1 = P_5 + zsq * poly1
//     poly2 = zsq * poly2
//     poly1 = P_4 + zsq*poly1
//
       fmpy.s1 f63 = f63, f60
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
//
//     poly1 = P_4 + zsq * poly1
//     swap = xor(swap,sign_X)
//
       fma.s1 f62 = f60, f62, f72
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
//
//     poly = z8*poly1 + poly2  (Typo in writeup)
//     Is (swap) != 0 ?
//
//
//     z_lo = V - A_temp * U
//     if (p7) sigma =  1.0
//     Writeup shows A_temp as A_hi
//
//
//     z_lo = z_lo * E
//     if (p6) sigma = -1.0
//     z_lo = (V - A_temp * U) *E
//
//
//     Fixup added to force inexact later -
//     A_hi = A_temp + z_lo
//     z_lo = (A_temp - A_hi) + z_lo
//     z_lo = A_hi - z_lo -A_hi + z_lo = about 0
//
       fma.s1 f47 = f61, f62, f63
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
//
//     A_lo = z * poly + z_lo
//
       fma.s1 f53 = f59, f47, f64
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
       fadd.s1  f52 = f65, f53
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
       fsub.s1  f65 = f65, f52
	nop 999	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
       fmpy.s1 f52 = f34, f52
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
       fadd.s1  f53 = f65, f53
	nop 999	// EMbo added ...
 } { .mfi
       setf.exp f65 = r47
       fma.s1 f56 = f54, f52, f50
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
       fclass.m.unc  p6,p0 = f53,0x007
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
//
//     P_hi = s_Y * P_hi
//     A_hi = s_Y * A_hi
//
//
//     result_hi = P_hi + sigma * A_hi
//
(p6)   mov f53 = f65
	nop 999	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
//
//     tmp = P_hi - result_hi
//
       fsub.s1 f65 = f50, f56
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
       fma.s1 f65 = f52, f54, f65
	nop 999	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
//
//     tmp   = sigma * A_hi  + tmp
//     sigma = A_lo * sigma  + P_lo
//
       fma.s1 f54 = f53, f54, f51
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
//
//     result_lo = s_Y * sigma + tmp
//
       fma.s1 f55 = f34, f54, f65
	nop 999;;	// EMbo added ...
 } { .mfb
       nop.m 0
       mov f34 = f1
       br.cond.sptk RETURN_ATAN;;
}
//
//     result  =  result_hi + result_lo  (User Supplied Rounding Mode)
//
//            fadd.d.s0 f57 = f55, f56
ATAN_UNSUPPORTED:
ATAN_NATVAL:
 { .mfb
	nop 999	// EMbo added ...
//
//     Deal with the NatVal and unsupported cases.
//     Raise invalid if warrented.
//
       fmpy.d.s0 f57 = f8, f9
br.cond.sptk RETURN_ATAN;;
 }
ATAN_NAN:
 { .mfb
	nop 999	// EMbo added ...
//
//     If only one NaN, then generate the resulting
//     NaN and return - may raise invalid.
//
       fmpy.d.s0 f57 = f8, f9
       br.cond.sptk RETURN_ATAN;;
 }
ATAN_SPECIAL_HANDLING:

 { .mmf
       addl           r39   = @ltoff(Constants_atan#), gp
       nop.m 999
       fcmp.lt.s0 p0,p7 = f8,f1
 } 
;;

//
//     Raise denormal operand faults if necessary
//

{ .mfi
       ld8 r39 = [r39]
       fcmp.lt.s0 p0,p6 = f9,f1
	nop 999;;	// EMbo added ...
} 
;;



{ .mfi
	nop 999	// EMbo added ...
       fclass.m.unc p6,p7 = f32,0x007
	nop 999;;	// EMbo added ...
 } { .mlx
	nop 999	// EMbo added ...
       movl r47 = 992;;
 } { .mib
       add r39 = r39, r47
	nop 999	// EMbo added ...
(p7)   br.cond.sptk ATAN_ArgY_Not_ZERO;;
 } { .mfi
	nop 999	// EMbo added ...
(p6)   fclass.m.unc p14,p0 = f33,0x035
	nop 999	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
(p6)   fclass.m.unc p15,p0 = f33,0x036
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
(p6)   fclass.m.unc p13,p0 = f33,0x007
	nop 999	// EMbo added ...
 } { .mfi
       ldfd  f56 = [r39],8
	nop 999	// EMbo added ...
	nop 999;;	// EMbo added ...
 } { .mfi
       ldfd  f55 = [r39],-8
(p14)  fmerge.s f56 =  f32,f0
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
//
//     Return sign_Y * 0 when Y = +/-0 and X > 0
//
(p14)  fmerge.s f55 =  f32,f0
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
(p15)  fmerge.s f56 =  f32,f56
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
//
//     Return sign_Y * PI when X <  -0
//
//
(p15)  fmerge.s f55 =  f32,f55
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
       fadd.d.s0 f57 = f56,f55
      nop.i 0
 } { .bbb
//
//     Call error support function for atan(0,0)
//     - expected value already computed.
//
    nop.b 0
    nop.b 0
      br.cond.sptk RETURN_ATAN
 }
ATAN_ArgY_Not_ZERO:
 { .mfi
	nop 999	// EMbo added ...
       fclass.m.unc p9,p10 = f32,0x023
	nop 999;;	// EMbo added ...
 } { .mfb
	nop 999	// EMbo added ...
(p9)   fclass.m.unc p6,p0 = f33,0x017
(p10)  br.cond.sptk ATAN_ArgY_Not_INF;;
 } { .mfi
(p6)   add r39 = 16,r39
(p9)   fclass.m.unc p7,p0 = f33,0x021
	nop 999;;	// EMbo added ...
 } { .mmf
	nop 999	// EMbo added ...
       ldfd  f56 = [r39],8
(p9)   fclass.m.unc p8,p0 = f33,0x022;;
 } { .mbb
       ldfd  f55 = [r39],-8
	nop 999	// EMbo added ...
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
(p6)   fmerge.s f56 =  f32,f56
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
(p6)   fmerge.s f55 =  f32,f55
	nop 999;;	// EMbo added ...
 } { .mfb
	nop 999	// EMbo added ...
//
//     Load I/2 and adjust its sign.
//     Return +I/2 when ArgY = +Inf and ArgX = +/-0,normal
//     Return -I/2 when ArgY = -Inf and ArgX = +/-0,normal
//
(p6)   fadd.d.s0  f57 =   f56,  f55
(p6)   br.cond.sptk RETURN_ATAN;;
 } { .mmi
(p7)   add r39 = 32,r39;;
(p7)   ldfd  f56 = [r39],8
	nop 999;;	// EMbo added ...
 } { .mmi
	nop 999;;	// EMbo added ...
(p7)   ldfd  f55 = [r39],-8
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
(p7)   fmerge.s f56 =  f32,f56
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
(p7)   fmerge.s f55 =  f32,f55
	nop 999;;	// EMbo added ...
 } { .mfb
	nop 999	// EMbo added ...
//
//     Load PI/4 and adjust its sign.
//     Return +PI/4 when ArgY = +Inf and ArgX = +Inf
//     Return -PI/4 when ArgY = -Inf and ArgX = +Inf
//
(p7)   fadd.d.s0  f57 =   f56,  f55
(p7)   br.cond.sptk RETURN_ATAN;;
 } { .mmi
(p8)   add r39 = 48,r39;;
(p8)   ldfd f56 =[r39],8
	nop 999;;	// EMbo added ...
 } { .mmi
	nop 999;;	// EMbo added ...
(p8)   ldfd f55 =[r39],-8
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
(p8)   fmerge.s f56 =  f32,f56
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
(p8)   fmerge.s f55 =  f32,f55
	nop 999;;	// EMbo added ...
 } { .mfb
	nop 999	// EMbo added ...
//
//     Load I/4 and adjust its sign.
//     Return +3I/4 when ArgY = +Inf and ArgX = -Inf
//     Return -3I/4 when ArgY = -Inf and ArgX = -Inf
//
(p8)   fadd.d.s0  f57 =   f56,  f55
(p8)   br.cond.sptk RETURN_ATAN;;
 }
ATAN_ArgY_Not_INF:
 { .mfi
	nop 999	// EMbo added ...
       fclass.m.unc  p6,p0 = f33,0x007
	nop 999	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
       fclass.m.unc  p7,p0 = f33,0x021
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
       fclass.m.unc  p8,p0 = f33,0x022
(p6)   add r39 = 16,r39;;
 } { .mfi
(p6)   ldfd f56 =[r39],8
	nop 999	// EMbo added ...
	nop 999;;	// EMbo added ...
 } { .mmi
	nop 999;;	// EMbo added ...
(p6)   ldfd f55 =[r39],-8
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
(p6)   fmerge.s f56 =  f32,f56
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
(p6)   fmerge.s f55 =  f32,f55
	nop 999;;	// EMbo added ...
 } { .mfb
	nop 999	// EMbo added ...
//
//     return = sign_Y * I/2 when ArgX = +/-0
//
(p6)   fadd.d.s0 f57 = f56, f55
(p6)   br.cond.sptk RETURN_ATAN;;
 } { .mfi
	nop 999	// EMbo added ...
(p7)   fmerge.s f56 =  f32,f0
	nop 999	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
(p7)   fmerge.s f55 =  f32,f0
	nop 999;;	// EMbo added ...
 } { .mfb
	nop 999	// EMbo added ...
//
//     return = sign_Y * 0 when ArgX = Inf
//
(p7)   fadd.d.s0 f57 = f56, f55
(p7)   br.cond.sptk RETURN_ATAN;;
 } { .mfi
(p8)   ldfd f56 = [r39],8
	nop 999	// EMbo added ...
	nop 999;;	// EMbo added ...
 } { .mmi
	nop 999;;	// EMbo added ...
(p8)   ldfd f55 = [r39],-8
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
(p8)   fmerge.s f56 =  f32,f56
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
(p8)   fmerge.s f55 =  f32,f55
	nop 999;;	// EMbo added ...
 } { .mfi
	nop 999	// EMbo added ...
//
//     return = sign_Y * I when ArgX = -Inf
//
(p8)   fadd.d.s0  f57 =   f56,  f55
	nop 999	// EMbo added ...
 };;
RETURN_ATAN:
// mov    f8     = f57 ;;
// The answer is in f57.
// But Z_hi is f56
//     Z_lo is f55
//     s_Y  is f34
//     W is in f9 and untouched

{ .mfi
	nop 999	
mov    f8     = f56
        nop.i 0
};;

{ .mfi
	nop 999	
mov    f10    = f55
        nop.i 999
}
{ .mfb
	nop 999	
mov    f11    = f34
br.ret.sptk   b0
};;

.endp __libm_atan2_reg
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\ia64\isnanf.s ===
.file "isnanf.s"

// Copyright (c) 2000, 2001, Intel Corporation
// All rights reserved.
// 
// Contributed 2/2/2000 by John Harrison, Ted Kubaska, Bob Norin, Shane Story,
// and Ping Tak Peter Tang of the Computational Software Lab, Intel Corporation.
// 
// WARRANTY DISCLAIMER
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS 
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY 
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
// 
// Intel Corporation is the author of this code, and requests that all
// problem reports or change requests be submitted to it directly at 
// http://developer.intel.com/opensource.
//
// History
//==============================================================
// 2/02/00: Initial version


.align 32
.global _isnanf#

.section .text
.proc  _isnanf#
.align 32

// API
//==============================================================
// int _isnanf  (float x)

// Overview of operation
//==============================================================
// returns 1 if x is a nan; 0 otherwise
// does check for special input; takes no exceptions

// Registers used
//==============================================================

// general registers used:        1
// r8 for return value

// floating-point registers used: 1
// f8

// qnan snan inf norm     unorm 0 -+
// 1    1    0   0        0     0 11

_isnanf: 
{ .mfi
      nop.m 999
      fclass.m.unc   p6,p7 = f8,0xc3           
      nop.i 999 ;;
}
{ .mib
(p6)  addl           r8 = 0x1,r0               
(p7)  addl           r8 = 0x0,r0               
      br.ret.sptk    b0 ;;                        
}

.endp _isnanf
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\ia64\ieee.c ===
/***
*ieee.c - ieee control and status routines
*
*   Copyright (c) 1985-2001, Microsoft Corporation. All rights reserved.
*
*Purpose:
*   IEEE control and status routines.
*
*Revision History:
*
*   04-01-02  GDP   Rewritten to use abstract control and status words
*   06-06-01  GB    Added _DN_FLUSH
*
*/

#ifndef _IA64_
#define _IA64_
#endif

#include <trans.h>
#include <float.h>
#include <nt.h>
#include <signal.h>

extern unsigned __int64 _get_fpsr(void);
extern void _set_fpsr(unsigned __int64);
extern void _fclrf(void);

static unsigned int _abstract_sw(unsigned __int64 sw);
static unsigned int _abstract_cw(unsigned __int64 cw);
static unsigned __int64 _hw_cw(unsigned int abstr);

#define FS          (1<<6)
#define CWMASK      0x00001f7f
#define FTZ         0x00000040

/***
* _statusfp() -
*
*Purpose:
*	return abstract fp status word
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

unsigned int _statusfp()
{
    unsigned __int64 status;

    status = _get_fpsr();

    return _abstract_sw(status);
}


/***
*_clearfp() -
*
*Purpose:
*	return abstract	status word and clear status
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

unsigned int _clearfp()
{
    unsigned __int64 status;

    status = _get_fpsr();
    _fclrf();

    return _abstract_sw(status);
}



/***	_control87
*() -
*
*Purpose:
*	return and set abstract user fp control word
*	can modify EM_DENORMAL mask
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

unsigned int _control87(unsigned int newctrl, unsigned int mask)
{
    unsigned __int64 oldCw;
    unsigned __int64 newCw;
    unsigned int oldabs;
    unsigned int newabs;

    oldCw = _get_fpsr();

    oldabs = _abstract_cw(oldCw);

    newabs = (newctrl & mask) | (oldabs & ~mask);

    newCw = _hw_cw(newabs) | (oldCw & ~(unsigned __int64)CWMASK);

    _set_fpsr(newCw);

    return newabs;
}					/* _control87() */


/***	_controlfp
*() -
*
*Purpose:
*	return and set abstract user fp control word
*	cannot change denormal mask (ignores _EM_DENORMAL)
*	This is done for portable IEEE behavior on all platforms
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

unsigned int _controlfp(unsigned int newctrl, unsigned int mask)
{
    return _control87(newctrl, mask & ~_EM_DENORMAL);
}


/***
* _abstract_cw() - abstract control word
*
*Purpose:
*   produce a fp control word in abstracted (machine independent) form
*
*Entry:
*   cw:     machine control word
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

unsigned int _abstract_cw(unsigned __int64 cw)
{
    unsigned int abstr = 0;


    //
    // Set exception mask bits
    //

    if (cw & IEM_INVALID)
	abstr |= _EM_INVALID;
    if (cw & IEM_ZERODIVIDE)
	abstr |= _EM_ZERODIVIDE;
    if (cw & IEM_OVERFLOW)
	abstr |= _EM_OVERFLOW;
    if (cw & IEM_UNDERFLOW)
	abstr |= _EM_UNDERFLOW;
    if (cw & IEM_INEXACT)
	abstr |= _EM_INEXACT;
    if (cw & IEM_DENORMAL)
	abstr |= _EM_DENORMAL;

    //
    // Set rounding mode
    //

    switch (cw & IMCW_RC) {
    case IRC_NEAR:
	abstr |= _RC_NEAR;
	break;
    case IRC_UP:
	abstr |= _RC_UP;
	break;
    case IRC_DOWN:
	abstr |= _RC_DOWN;
	break;
    case IRC_CHOP:
	abstr |= _RC_CHOP;
	break;
    }

    // Flush to zero mode
    if (cw & FTZ) {
        abstr |= _DN_FLUSH;
    }

    //
    // Set Precision mode
    //

    switch (cw & IMCW_PC) {
    case IPC_64:
	abstr |= _PC_64;
	break;
    case IPC_53:
	abstr |= _PC_53;
	break;
    case IPC_24:
	abstr |= _PC_24;
	break;
    }

    return abstr;
}


/***
* _hw_cw() -  h/w control word
*
*Purpose:
*   produce a machine dependent fp control word
*
*
*Entry:
*   abstr:	abstract control word
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

unsigned __int64 _hw_cw(unsigned int abstr)
{
    //
    // Set standard infinity and denormal control bits
    //

    unsigned __int64 cw = 0;

    //
    // Set exception mask bits
    //

    if (abstr & _EM_INVALID)
	cw |= IEM_INVALID;
    if (abstr & _EM_ZERODIVIDE)
	cw |= IEM_ZERODIVIDE;
    if (abstr & _EM_OVERFLOW)
	cw |= IEM_OVERFLOW;
    if (abstr & _EM_UNDERFLOW)
	cw |= IEM_UNDERFLOW;
    if (abstr & _EM_INEXACT)
	cw |= IEM_INEXACT;
    if (abstr & _EM_DENORMAL)
	cw |= IEM_DENORMAL;

    //
    // Set rounding mode
    //

    switch (abstr & _MCW_RC) {
    case _RC_NEAR:
	cw |= IRC_NEAR;
	break;
    case _RC_UP:
	cw |= IRC_UP;
	break;
    case _RC_DOWN:
	cw |= IRC_DOWN;
	break;
    case _RC_CHOP:
	cw |= IRC_CHOP;
	break;
    }

    // Flush to zero mode
    if (abstr & _DN_FLUSH) {
        cw |= FTZ;
    }

    //
    // Set Precision mode
    //

    switch (abstr & _MCW_PC) {
    case _PC_64:
	cw |= IPC_64;
	break;
    case _PC_53:
	cw |= IPC_53;
	break;
    case _PC_24:
	cw |= IPC_24;
	break;
    }

    return cw;
}



/***
* _abstract_sw() - abstract fp status word
*
*Purpose:
*   produce an abstract (machine independent) fp status word
*
*
*Entry:
*   sw:     machine status word
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

unsigned int _abstract_sw(unsigned __int64 sw)
{
    unsigned int abstr = 0;


    if (sw & ISW_INVALID)
	abstr |= _SW_INVALID;
    if (sw & ISW_ZERODIVIDE)
	abstr |= _SW_ZERODIVIDE;
    if (sw & ISW_OVERFLOW)
	abstr |= _SW_OVERFLOW;
    if (sw & ISW_UNDERFLOW)
	abstr |= _SW_UNDERFLOW;
    if (sw & ISW_INEXACT)
	abstr |= _SW_INEXACT;
    if (sw & ISW_DENORMAL)
	abstr |= _SW_DENORMAL;

    return abstr;
}

/***
* _fpreset() - reset fp system
*
*Purpose:
*	reset fp environment to the default state
*	Also reset saved fp environment if invoked from a user's
*	signal handler
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/
void _fpreset()
{
    unsigned __int64 status = ICW | 0x9004802700002; /* fpsr.sf1.pc=3, wre=1, traps.dd=1 */ 
    PEXCEPTION_POINTERS excptrs = (PEXCEPTION_POINTERS) _pxcptinfoptrs;

    //
    // reset fp state
    //

    _set_fpsr(status);

    if (excptrs &&
        excptrs->ContextRecord->ContextFlags & CONTEXT_FLOATING_POINT) {
        // _fpreset has been invoked by a signal handler which in turn
        // has been invoked by the CRT filter routine. In this case
        // the saved fp context should be cleared, so that the change take
        // effect on continuation.

        excptrs->ContextRecord->StFPSR = ICW;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\ia64\ldexpf.s ===
.file "ldexpf.s"

// Copyright (c) 2000, 2001, Intel Corporation
// All rights reserved.
// 
// Contributed 2/2/2000 by John Harrison, Ted Kubaska, Bob Norin, Shane Story,
// and Ping Tak Peter Tang of the Computational Software Lab, Intel Corporation.
// 
// WARRANTY DISCLAIMER
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS 
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY 
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
// 
// Intel Corporation is the author of this code, and requests that all
// problem reports or change requests be submitted to it directly at 
// http://developer.intel.com/opensource.
//
// History
//==============================================================
// 2/02/00  Initial version
// 1/26/01  ldexpf completely reworked and now standalone version 
//
// API
//==============================================================
// float = ldexpf  (float x, int n) 
// input  floating point f8 and int n (r33) 
// output floating point f8
//
// Returns x* 2**n using an fma and detects overflow
// and underflow.   
//
//

FR_Big         = f6
FR_NBig        = f7
FR_Floating_X  = f8
FR_Result      = f8
FR_Result2     = f9
FR_Result3     = f11
FR_Norm_X      = f12
FR_Two_N       = f14
FR_Two_to_Big  = f15

GR_N_Biased    = r15
GR_Big         = r16
GR_NBig        = r17
GR_Scratch     = r18
GR_Scratch1    = r19
GR_Bias        = r20
GR_N_as_int    = r21

GR_SAVE_B0          = r32
GR_SAVE_GP          = r33
GR_SAVE_PFS         = r34
GR_Parameter_X      = r35
GR_Parameter_Y      = r36
GR_Parameter_RESULT = r37
GR_Tag              = r38

.align 32
.global ldexpf

.section .text
.proc  ldexpf
.align 32

ldexpf: 

//
//   Is x NAN, INF, ZERO, +-?
//   Build the exponent Bias
//
{    .mfi
     alloc         r32=ar.pfs,1,2,4,0
     fclass.m.unc  p7,p0 = FR_Floating_X, 0xe7 //@snan | @qnan | @inf | @zero
     addl          GR_Bias = 0x0FFFF,r0
}

//
//   Sign extend input
//   Is N zero?
//   Normalize x
//
{    .mfi
     cmp.eq.unc    p6,p0 = r33,r0  
     fnorm.s1      FR_Norm_X  =   FR_Floating_X 
     sxt4          GR_N_as_int = r33
}
;;

//
//   Normalize x
//   Branch and return special values.
//   Create -35000
//   Create 35000
//
{    .mfi
     addl          GR_Big = 35000,r0
     nop.f         0
     add           GR_N_Biased = GR_Bias,GR_N_as_int
}
{    .mfb
     addl          GR_NBig = -35000,r0
(p7) fma.s.s0      FR_Result = FR_Floating_X,f1, f0 
(p7) br.ret.spnt   b0  
};;

//
//   Build the exponent Bias
//   Return x when N = 0
//
{    .mfi
     setf.exp      FR_Two_N = GR_N_Biased                   
     nop.f         0
     addl          GR_Scratch1  = 0x063BF,r0 
}
{    .mfb
     addl          GR_Scratch  = 0x019C3F,r0 
(p6) fma.s.s0      FR_Result = FR_Floating_X,f1, f0 
(p6) br.ret.spnt   b0  
};;

//
//   Create 2*big
//   Create 2**-big 
//   Is N > 35000     
//   Is N < -35000     
//   Raise Denormal operand flag with compare
//   Main path, create 2**N
//
{    .mfi
     setf.exp      FR_NBig = GR_Scratch1                  
     nop.f         0
     cmp.ge.unc    p6, p0 = GR_N_as_int, GR_Big
}
{    .mfi
     setf.exp      FR_Big = GR_Scratch                  
     fcmp.ge.s0    p0,p11 = FR_Floating_X,f0
     cmp.le.unc    p8, p0 = GR_N_as_int, GR_NBig
};;

//
//   Adjust 2**N if N was very small or very large
//
{    .mfi
     nop.m 0
(p6) fma.s1        FR_Two_N = FR_Big,f1,f0
     nop.i 0
}
{ .mlx
     nop.m 999
     movl          GR_Scratch = 0x000000000003007F 
};;


{    .mfi
     nop.m 0
(p8) fma.s1        FR_Two_N = FR_NBig,f1,f0
     nop.i 0
}
{    .mlx
     nop.m 999
     movl          GR_Scratch1= 0x000000000001007F 
};;

//   Set up necessary status fields 
//
//   S0 user supplied status
//   S2 user supplied status + WRE + TD  (Overflows)
//   S3 user supplied status + FZ + TD   (Underflows)
//
{    .mfi
     nop.m 999
     fsetc.s3      0x7F,0x41
     nop.i 999
}
{    .mfi
     nop.m 999
     fsetc.s2      0x7F,0x42
     nop.i 999
};;

//
//   Do final operation
//
{    .mfi
     setf.exp      FR_NBig = GR_Scratch
     fma.s.s0      FR_Result = FR_Two_N,FR_Norm_X,f0 
     nop.i         999
}
{    .mfi
     nop.m         999
     fma.s.s3      FR_Result3 = FR_Two_N,FR_Norm_X,f0 
     nop.i         999
};;
{    .mfi
     setf.exp      FR_Big = GR_Scratch1
     fma.s.s2      FR_Result2 = FR_Two_N,FR_Norm_X,f0 
     nop.i         999
};;

//   Check for overflow or underflow.
//   Restore s3
//   Restore s2
//
{    .mfi
     nop.m 0
     fsetc.s3      0x7F,0x40
     nop.i 999 
}
{    .mfi
     nop.m 0
     fsetc.s2      0x7F,0x40
     nop.i 999
};;

//
//   Is the result zero?
//
{    .mfi
     nop.m 999
     fclass.m.unc  p6, p0 =  FR_Result3, 0x007
     nop.i 999 
} 
{    .mfi
     addl          GR_Tag = 148, r0
     fcmp.ge.unc.s1 p7, p8 = FR_Result2 , FR_Big
     nop.i 0
};;

//
//   Detect masked underflow - Tiny + Inexact Only
//
{    .mfi
     nop.m 999
(p6) fcmp.neq.unc.s1 p6, p0 = FR_Result , FR_Result2
     nop.i 999 
};; 

//
//   Is result bigger the allowed range?
//   Branch out for underflow
//
{    .mfb
(p6) addl           GR_Tag = 149, r0
(p8) fcmp.le.unc.s1 p9, p10 = FR_Result2 , FR_NBig
(p6) br.cond.spnt   ldexpf_UNDERFLOW 
};;

//
//   Branch out for overflow
//
{ .mbb
     nop.m 0
(p7) br.cond.spnt   ldexpf_OVERFLOW 
(p9) br.cond.spnt   ldexpf_OVERFLOW 
};;

//
//   Return from main path.
//
{    .mfb
     nop.m 999
     nop.f 0
     br.ret.sptk     b0;;                   
}

.endp ldexpf
.proc __libm_error_region
__libm_error_region:

ldexpf_OVERFLOW: 
ldexpf_UNDERFLOW: 

//
// Get stack address of N
//
.prologue
{ .mfi
    add   GR_Parameter_Y=-32,sp         
    nop.f 0
.save   ar.pfs,GR_SAVE_PFS
    mov  GR_SAVE_PFS=ar.pfs              
}
//
// Adjust sp 
//
{ .mfi
.fframe 64
   add sp=-64,sp                         
   nop.f 0
   mov GR_SAVE_GP=gp       
};;

//
//  Store N on stack in correct position 
//  Locate the address of x on stack
//
{ .mmi
   st8 [GR_Parameter_Y] =  GR_N_as_int,16       
   add GR_Parameter_X = 16,sp          
.save   b0, GR_SAVE_B0
   mov GR_SAVE_B0=b0                  
};;

//
// Store x on the stack.
// Get address for result on stack.
//
.body
{ .mib
   stfs [GR_Parameter_X] = FR_Norm_X 
   add   GR_Parameter_RESULT = 0,GR_Parameter_Y   
   nop.b 0
}
{ .mib
   stfs [GR_Parameter_Y] = FR_Result                 
   add   GR_Parameter_Y = -16,GR_Parameter_Y
   br.call.sptk b0=__libm_error_support#   
};;

//
//  Get location of result on stack
//
{ .mmi
   nop.m 0
   nop.m 0
   add   GR_Parameter_RESULT = 48,sp    
};;

//
//  Get the new result 
//
{ .mmi
   ldfs  FR_Result = [GR_Parameter_RESULT]      
.restore
   add   sp = 64,sp                       
   mov   b0 = GR_SAVE_B0                  
};;

//
//  Restore gp, ar.pfs and return
//
{ .mib
   mov   gp = GR_SAVE_GP                  
   mov   ar.pfs = GR_SAVE_PFS             
   br.ret.sptk     b0                  
};;

.endp __libm_error_region 

.type   __libm_error_support#,@function
.global __libm_error_support#
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\ia64\libm_error.c ===
//     
// Copyright (c) 2000, Intel Corporation
// All rights reserved.
//
// Contributed 2/2/2000 by John Harrison, Ted Kubaska, Bob Norin, Shane Story, James
// Edwards, and Ping Tak Peter Tang of the Computational Software Lab, Intel Corporation.
//
// WARRANTY DISCLAIMER
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS 
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// Intel Corporation is the author of this code, and requests that all
// problem reports or change requests be submitted to it directly at
// http://developer.intel.com/opensource.
//
// History
//==============================================================
// 2/02/00: Initial version
// 3/22/00: Updated to support flexible and dynamic error handling. 
//

#include <errno.h>
#include <stdio.h>
#include "libm_support.h"

_LIB_VERSION_TYPE
#if defined( __MS__ )
_LIB_VERSION = _MS_;
#elif defined( _POSIX_ )
_LIB_VERSION = __POSIX__;
#elif defined( __XOPEN__ )
_LIB_VERSION = _XOPEN_;
#elif defined( __SVID__ )
_LIB_VERSION = _SVID_;
#elif defined( __IEEE__ )
_LIB_VERSION = _IEEE_;
#else
_LIB_VERSION = _ISOC_;
#endif

void __libm_error_support(void *arg1,void *arg2,void *retval,error_types input_tag)
{


# ifdef __cplusplus
struct __exception exc;
# else 
struct exception  exc;
# endif 

struct exceptionf excf;

const char float_inf[4] = {0x00,0x00,0x80,0x7F};
const char float_huge[4] = {0xFF,0xFF,0x7F,0x7F};
const char float_zero[4] = {0x00,0x00,0x00,0x00};
const char float_neg_inf[4] = {0x00,0x00,0x80,0xFF};
const char float_neg_huge[4] = {0xFF,0xFF,0x7F,0xFF};
const char float_neg_zero[4] = {0x00,0x00,0x00,0x80};

const char double_inf[8] = {0x00,0x00,0x00,0x00,0x00,0x00,0xF0,0x7F}; 
const char double_huge[8] = {0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xEF,0x7F};
const char double_zero[8] = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
const char double_neg_inf[8] = {0x00,0x00,0x00,0x00,0x00,0x00,0xF0,0xFF}; 
const char double_neg_huge[8] = {0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xEF,0xFF};
const char double_neg_zero[8] = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80};

const char long_double_inf[10] = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xFF,0x7F}; 
const char long_double_huge[10] = {0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFE,0x7F};
const char long_double_zero[10] = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
const char long_double_neg_inf[10] = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xFF,0xFF}; 
const char long_double_neg_huge[10] = {0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFE,0xFF};
const char long_double_neg_zero[10] = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80};

#define RETVAL_HUGE_VALD *(double *)retval = *(double *) double_inf
#define RETVAL_NEG_HUGE_VALD *(double *)retval = *(double *) double_neg_inf
#define RETVAL_HUGED *(double *)retval = (double) *(float *)float_huge
#define RETVAL_NEG_HUGED *(double *)retval = (double) *(float *) float_neg_huge 

#define RETVAL_HUGE_VALF *(float *)retval =  *(float *) float_inf
#define RETVAL_NEG_HUGE_VALF *(float *)retval = *(float *) float_neg_inf
#define RETVAL_HUGEF *(float *)retval = *(float *) float_huge
#define RETVAL_NEG_HUGEF *(double *)retval = *(float *) float_neg_huge 

#define RETVAL_ZEROD *(double *)retval = *(double *)double_zero 
#define RETVAL_ZEROF *(float *)retval = *(float *)float_zero 

#define RETVAL_NEG_ZEROD *(double *)retval = *(double *)double_neg_zero 
#define RETVAL_NEG_ZEROF *(float *)retval = *(float *)float_neg_zero 

#define RETVAL_ONED *(double *)retval = 1.0 
#define RETVAL_ONEF *(float *)retval = 1.0f 

#ifdef __MS__
#define NOT_MATHERRD exc.arg1=*(double *)arg1;exc.arg2=*(double *)arg2;exc.retval=*(double *)retval;if(!_matherr(&exc))
#define NOT_MATHERRF excf.arg1=*(float *)arg1;excf.arg2=*(float *)arg2;excf.retval=*(float *)retval;if(!_matherr(&excf))
#else
#define NOT_MATHERRD exc.arg1=*(double *)arg1;exc.arg2=*(double *)arg2;exc.retval=*(double *)retval;if(!matherr(&exc))
#define NOT_MATHERRF excf.arg1=*(float *)arg1;excf.arg2=*(float *)arg2;excf.retval=*(float *)retval;if(!matherrf(&excf))
#endif

#define ifSVID if(_LIB_VERSION==_SVID_)

#define NAMED exc.name  
#define NAMEF excf.name  

//
// These should work OK for MS because they are ints -
// leading underbars are not necessary.
//

#define DOMAIN          1
#define SING            2
#define OVERFLOW        3
#define UNDERFLOW       4
#define TLOSS           5
#define PLOSS           6

#define SINGD exc.type = SING
#define DOMAIND exc.type = DOMAIN 
#define OVERFLOWD exc.type = OVERFLOW 
#define UNDERFLOWD exc.type = UNDERFLOW 
#define TLOSSD exc.type = TLOSS 
#define SINGF excf.type = SING
#define DOMAINF excf.type = DOMAIN 
#define OVERFLOWF excf.type = OVERFLOW 
#define UNDERFLOWF excf.type = UNDERFLOW 
#define TLOSSF excf.type = TLOSS 

#define INPUT_XD (exc.arg1=*(double*)arg1)
#define INPUT_XF (excf.arg1=*(float*)arg1)
#define INPUT_YD (exc.arg1=*(double*)arg2)
#define INPUT_YF (excf.arg1=*(float*)arg2)
#define INPUT_RESD (*(double *)retval)
#define INPUT_RESF (*(float *)retval)

#if     defined( __MS__)
#define WRITEL_LOG_ZERO 
#define WRITED_LOG_ZERO 
#define WRITEF_LOG_ZERO 
#define WRITEL_LOG_NEGATIVE
#define WRITED_LOG_NEGATIVE
#define WRITEF_LOG_NEGATIVE
#define WRITEL_Y0_ZERO 
#define WRITED_Y0_ZERO 
#define WRITEF_Y0_ZERO 
#define WRITEL_Y0_NEGATIVE
#define WRITED_Y0_NEGATIVE
#define WRITEF_Y0_NEGATIVE
#define WRITEL_Y1_ZERO
#define WRITED_Y1_ZERO
#define WRITEF_Y1_ZERO
#define WRITEL_Y1_NEGATIVE
#define WRITED_Y1_NEGATIUE
#define WRITEF_Y1_NEGATIVE
#define WRITEL_YN_ZERO
#define WRITED_YN_ZERO
#define WRITEF_YN_ZERO
#define WRITEL_YN_NEGATIVE
#define WRITED_YN_NEGATIVE
#define WRITEF_YN_NEGATIVE
#define WRITEL_LOG1P_ZERO
#define WRITED_LOG1P_ZERO
#define WRITEF_LOG1P_ZERO
#define WRITEL_LOG1P_NEGATIVE
#define WRITED_LOG1P_NEGATIVE
#define WRITEF_LOG1P_NEGATIVE
#define WRITEL_LOG10_ZERO
#define WRITED_LOG10_ZERO
#define WRITEF_LOG10_ZERO
#define WRITEL_LOG10_NEGATIVE
#define WRITED_LOG10_NEGATIVE
#define WRITEF_LOG10_NEGATIVE
#define WRITEL_POW_ZERO_TO_ZERO
#define WRITED_POW_ZERO_TO_ZERO
#define WRITEF_POW_ZERO_TO_ZERO
#define WRITEL_POW_ZERO_TO_NEGATIVE
#define WRITED_POW_ZERO_TO_NEGATIVE
#define WRITEF_POW_ZERO_TO_NEGATIVE
#define WRITEL_POW_NEG_TO_NON_INTEGER
#define WRITED_POW_NEG_TO_NON_INTEGER
#define WRITEF_POW_NEG_TO_NON_INTEGER
#define WRITEL_ATAN2_ZERO_BY_ZERO
#define WRITED_ATAN2_ZERO_BY_ZERO
#define WRITEF_ATAN2_ZERO_BY_ZERO
#define WRITEL_SQRT
#define WRITED_SQRT
#define WRITEF_SQRT
#define WRITEL_FMOD
#define WRITED_FMOD
#define WRITEF_FMOD
#define WRITEL_REM 
#define WRITED_REM 
#define WRITEF_REM 
#define WRITEL_ACOS
#define WRITED_ACOS
#define WRITEF_ACOS
#define WRITEL_ASIN
#define WRITED_ASIN
#define WRITEF_ASIN
#define WRITEL_ACOSH
#define WRITED_ACOSH
#define WRITEF_ACOSH
#define WRITEL_ATANH_GT_ONE
#define WRITED_ATANH_GT_ONE
#define WRITEF_ATANH_GT_ONE
#define WRITEL_ATANH_EQ_ONE
#define WRITED_ATANH_EQ_ONE
#define WRITEF_ATANH_EQ_ONE
#define WRITEL_LGAMMA_NEGATIVE
#define WRITED_LGAMMA_NEGATIVE
#define WRITEF_LGAMMA_NEGATIVE
#define WRITEL_GAMMA_NEGATIVE
#define WRITED_GAMMA_NEGATIVE
#define WRITEF_GAMMA_NEGATIVE
#define WRITEL_J0_TLOSS
#define WRITEL_Y0_TLOSS
#define WRITEL_J1_TLOSS
#define WRITEL_Y1_TLOSS
#define WRITEL_JN_TLOSS
#define WRITEL_YN_TLOSS
#define WRITED_J0_TLOSS
#define WRITED_Y0_TLOSS
#define WRITED_J1_TLOSS
#define WRITED_Y1_TLOSS
#define WRITED_JN_TLOSS
#define WRITED_YN_TLOSS
#define WRITEF_J0_TLOSS
#define WRITEF_Y0_TLOSS
#define WRITEF_J1_TLOSS
#define WRITEF_Y1_TLOSS
#define WRITEF_JN_TLOSS
#define WRITEF_YN_TLOSS
#else
#define WRITEL_LOG_ZERO fputs("logl: SING error\n",stderr)
#define WRITED_LOG_ZERO fputs("log: SING error\n",stderr)
#define WRITEF_LOG_ZERO fputs("logf: SING error\n",stderr)
#define WRITEL_LOG_NEGATIVE fputs("logl: DOMAIN error\n",stderr)
#define WRITED_LOG_NEGATIVE fputs("log: DOMAIN error\n",stderr)
#define WRITEF_LOG_NEGATIVE fputs("logf: DOMAIN error\n",stderr)
#define WRITEL_Y0_ZERO fputs("y0l: DOMAIN error\n",stderr)
#define WRITED_Y0_ZERO fputs("y0: DOMAIN error\n",stderr)
#define WRITEF_Y0_ZERO fputs("y0f: DOMAIN error\n",stderr)
#define WRITEL_Y0_NEGATIVE fputs("y0l: DOMAIN error\n",stderr)
#define WRITED_Y0_NEGATIVE fputs("y0: DOMAIN error\n",stderr)
#define WRITEF_Y0_NEGATIVE fputs("y0f: DOMAIN error\n",stderr)
#define WRITEL_Y1_ZERO fputs("y1l: DOMAIN error\n",stderr)
#define WRITED_Y1_ZERO fputs("y1: DOMAIN error\n",stderr)
#define WRITEF_Y1_ZERO fputs("y1f: DOMAIN error\n",stderr)
#define WRITEL_Y1_NEGATIVE fputs("y1l: DOMAIN error\n",stderr)
#define WRITED_Y1_NEGATIUE fputs("y1: DOMAIN error\n",stderr)
#define WRITEF_Y1_NEGATIVE fputs("y1f: DOMAIN error\n",stderr)
#define WRITEL_YN_ZERO fputs("ynl: DOMAIN error\n",stderr)
#define WRITED_YN_ZERO fputs("yn: DOMAIN error\n",stderr)
#define WRITEF_YN_ZERO fputs("ynf: DOMAIN error\n",stderr)
#define WRITEL_YN_NEGATIVE fputs("ynl: DOMAIN error\n",stderr)
#define WRITED_YN_NEGATIVE fputs("yn: DOMAIN error\n",stderr)
#define WRITEF_YN_NEGATIVE fputs("ynf: DOMAIN error\n",stderr)
#define WRITEL_LOG1P_ZERO fputs("log1pl: SING error\n",stderr)
#define WRITED_LOG1P_ZERO fputs("log1p: SING error\n",stderr)
#define WRITEF_LOG1P_ZERO fputs("log1pf: SING error\n",stderr)
#define WRITEL_LOG1P_NEGATIVE fputs("log1pl: DOMAIN error\n",stderr)
#define WRITED_LOG1P_NEGATIVE fputs("log1p: DOMAIN error\n",stderr)
#define WRITEF_LOG1P_NEGATIVE fputs("log1pf: DOMAIN error\n",stderr)
#define WRITEL_LOG10_ZERO fputs("log10l: SING error\n",stderr)
#define WRITED_LOG10_ZERO fputs("log10: SING error\n",stderr) 
#define WRITEF_LOG10_ZERO fputs("log10f: SING error\n",stderr)
#define WRITEL_LOG10_NEGATIVE fputs("log10l: DOMAIN error\n",stderr)
#define WRITED_LOG10_NEGATIVE fputs("log10: DOMAIN error\n",stderr)
#define WRITEF_LOG10_NEGATIVE fputs("log10f: DOMAIN error\n",stderr)
#define WRITEL_POW_ZERO_TO_ZERO fputs("powl(0,0): DOMAIN error\n",stderr)
#define WRITED_POW_ZERO_TO_ZERO fputs("pow(0,0): DOMAIN error\n",stderr)
#define WRITEF_POW_ZERO_TO_ZERO fputs("powf(0,0): DOMAIN error\n",stderr)
#define WRITEL_POW_ZERO_TO_NEGATIVE fputs("powl(0,negative): DOMAIN error\n",stderr)
#define WRITED_POW_ZERO_TO_NEGATIVE fputs("pow(0,negative): DOMAIN error\n",stderr)
#define WRITEF_POW_ZERO_TO_NEGATIVE fputs("powf(0,negative): DOMAIN error\n",stderr)
#define WRITEL_POW_NEG_TO_NON_INTEGER fputs("powl(negative,non-integer): DOMAIN error\n",stderr)
#define WRITED_POW_NEG_TO_NON_INTEGER fputs("pow(negative,non-integer): DOMAIN error\n",stderr)
#define WRITEF_POW_NEG_TO_NON_INTEGER fputs("powf(negative,non-integer): DOMAIN error\n",stderr)
#define WRITEL_ATAN2_ZERO_BY_ZERO fputs("atan2l: DOMAIN error\n",stderr)
#define WRITED_ATAN2_ZERO_BY_ZERO fputs("atan2: DOMAIN error\n",stderr)
#define WRITEF_ATAN2_ZERO_BY_ZERO fputs("atan2f: DOMAIN error\n",stderr)
#define WRITEL_SQRT fputs("sqrtl: DOMAIN error\n",stderr)
#define WRITED_SQRT fputs("sqrt: DOMAIN error\n",stderr)
#define WRITEF_SQRT fputs("sqrtf: DOMAIN error\n",stderr)
#define WRITEL_FMOD fputs("fmodl: DOMAIN error\n",stderr)
#define WRITED_FMOD fputs("fmod: DOMAIN error\n",stderr)
#define WRITEF_FMOD fputs("fmodf: DOMAIN error\n",stderr)
#define WRITEL_REM fputs("remainderl: DOMAIN error\n",stderr)
#define WRITED_REM fputs("remainder: DOMAIN error\n",stderr)
#define WRITEF_REM fputs("remainderf: DOMAIN error\n",stderr)
#define WRITEL_ACOS fputs("acosl: DOMAIN error\n",stderr)
#define WRITED_ACOS fputs("acos: DOMAIN error\n",stderr)
#define WRITEF_ACOS fputs("acosf: DOMAIN error\n",stderr)
#define WRITEL_ASIN fputs("asinl: DOMAIN error\n",stderr)
#define WRITED_ASIN fputs("asin: DOMAIN error\n",stderr)
#define WRITEF_ASIN fputs("asinf: DOMAIN error\n",stderr)
#define WRITEL_ACOSH fputs("acoshl: DOMAIN error\n",stderr)
#define WRITED_ACOSH fputs("acosh: DOMAIN error\n",stderr)
#define WRITEF_ACOSH fputs("acoshf: DOMAIN error\n",stderr)
#define WRITEL_ATANH_GT_ONE fputs("atanhl: DOMAIN error\n",stderr)
#define WRITED_ATANH_GT_ONE fputs("atanh: DOMAIN error\n",stderr)
#define WRITEF_ATANH_GT_ONE fputs("atanhf: DOMAIN error\n",stderr)
#define WRITEL_ATANH_EQ_ONE fputs("atanhl: SING error\n",stderr)
#define WRITED_ATANH_EQ_ONE fputs("atanh: SING error\n",stderr)
#define WRITEF_ATANH_EQ_ONE fputs("atanhf: SING error\n",stderr)
#define WRITEL_LGAMMA_NEGATIVE fputs("lgammal: SING error\n",stderr)
#define WRITED_LGAMMA_NEGATIVE fputs("lgamma: SING error\n",stderr)
#define WRITEF_LGAMMA_NEGATIVE fputs("lgammaf: SING error\n",stderr)
#define WRITEL_GAMMA_NEGATIVE fputs("gammal: SING error\n",stderr)
#define WRITED_GAMMA_NEGATIVE fputs("gamma: SING error\n",stderr)
#define WRITEF_GAMMA_NEGATIVE fputs("gammaf: SING error\n",stderr)
#define WRITEL_J0_TLOSS  fputs("j0l: TLOSS error\n",stderr)
#define WRITEL_Y0_TLOSS  fputs("y0l: TLOSS error\n",stderr)
#define WRITEL_J1_TLOSS  fputs("j1l: TLOSS error\n",stderr)
#define WRITEL_Y1_TLOSS  fputs("y1l: TLOSS error\n",stderr)
#define WRITEL_JN_TLOSS  fputs("jnl: TLOSS error\n",stderr)
#define WRITEL_YN_TLOSS  fputs("ynl: TLOSS error\n",stderr)
#define WRITED_J0_TLOSS  fputs("j0: TLOSS error\n",stderr)
#define WRITED_Y0_TLOSS  fputs("y0: TLOSS error\n",stderr)
#define WRITED_J1_TLOSS  fputs("j1: TLOSS error\n",stderr)
#define WRITED_Y1_TLOSS  fputs("y1: TLOSS error\n",stderr)
#define WRITED_JN_TLOSS  fputs("jn: TLOSS error\n",stderr)
#define WRITED_YN_TLOSS  fputs("yn: TLOSS error\n",stderr)
#define WRITEF_J0_TLOSS  fputs("j0f: TLOSS error\n",stderr)
#define WRITEF_Y0_TLOSS  fputs("y0f: TLOSS error\n",stderr)
#define WRITEF_J1_TLOSS  fputs("j1f: TLOSS error\n",stderr)
#define WRITEF_Y1_TLOSS  fputs("y1f: TLOSS error\n",stderr)
#define WRITEF_JN_TLOSS  fputs("jnf: TLOSS error\n",stderr)
#define WRITEF_YN_TLOSS  fputs("ynf: TLOSS error\n",stderr)
#endif

/***********************/
/* IEEE Path           */
/***********************/
if(_LIB_VERSION==_IEEE_) return;

/***********************/
/* C9X Path           */
/***********************/
else if(_LIB_VERSION==_ISOC_) 
{
  switch(input_tag)
  {
    case log_zero:
    case logf_zero:
    case log10_zero:
    case log10f_zero:
    case exp_overflow:  
    case expf_overflow: 
    case expm1_overflow:  
    case expm1f_overflow: 
    case hypot_overflow:
    case hypotf_overflow:
    case sinh_overflow: 
    case sinhf_overflow: 
    case atanh_eq_one:  
    case atanhf_eq_one:  
    case scalb_overflow:
    case scalbf_overflow:
    case cosh_overflow:
    case coshf_overflow:
    case nextafter_overflow:
    case nextafterf_overflow:
    case ldexp_overflow:
    case ldexpf_overflow:
    case lgamma_overflow:
    case lgammaf_overflow:
    case lgamma_negative:
    case lgammaf_negative:
    case gamma_overflow:
    case gammaf_overflow:
    case gamma_negative:
    case gammaf_negative:
    {
         ERRNO_RANGE; break;
    }
    case log_negative:
    case logf_negative:
    case log10_negative:
    case log10f_negative:
    case log1p_negative:
    case log1pf_negative:
    case sqrt_negative:
    case sqrtf_negative:
    case atan2_zero:
    case atan2f_zero:
    case powl_zero_to_negative:
    case powl_neg_to_non_integer:
    case pow_zero_to_negative:
    case pow_neg_to_non_integer:
    case powf_zero_to_negative:
    case powf_neg_to_non_integer:
    case fmod_by_zero:
    case fmodf_by_zero:
    case atanh_gt_one:  
    case atanhf_gt_one:  
    case acos_gt_one: 
    case acosf_gt_one: 
    case asin_gt_one: 
    case asinf_gt_one: 
    case logb_zero: 
    case logbf_zero:
    case acosh_lt_one:
    case acoshf_lt_one:
    case y0l_zero:
    case y0_zero:
    case y0f_zero:
    case y1l_zero:
    case y1_zero:
    case y1f_zero:
    case ynl_zero:
    case yn_zero:
    case ynf_zero:
    case y0_negative:
    case y0f_negative:
    case y1_negative:
    case y1f_negative:
    case yn_negative:
    case ynf_negative:
    {
         ERRNO_DOMAIN; break;
    }
   }
   return;
}

/***********************/
/* _POSIX_ Path        */
/***********************/

else if(_LIB_VERSION==__POSIX__)
{
switch(input_tag)
  {
  case gamma_overflow:
  case lgamma_overflow:
  {
       RETVAL_HUGE_VALD; ERRNO_RANGE; break;
  }
  case gammaf_overflow:
  case lgammaf_overflow:
  {
       RETVAL_HUGE_VALF; ERRNO_RANGE; break;
  }
  case gamma_negative:
  case gammaf_negative:
  case lgamma_negative:
  case lgammaf_negative:
  {
       ERRNO_DOMAIN; break;
  }
  case ldexp_overflow:
  case ldexp_underflow:
  case ldexpf_overflow:
  case ldexpf_underflow:
  {
       ERRNO_RANGE; break;
  }
  case atanh_gt_one: 
  case atanh_eq_one: 
    /* atanh(|x| >= 1) */
    {
       ERRNO_DOMAIN; break;
    }
  case atanhf_gt_one: 
  case atanhf_eq_one: 
    /* atanhf(|x| >= 1) */
    {
       ERRNO_DOMAIN; break;
    }
  case sqrt_negative: 
    /* sqrt(x < 0) */
    {
       ERRNO_DOMAIN; break;
    }
  case sqrtf_negative: 
    /* sqrtf(x < 0) */
    {
       ERRNO_DOMAIN; break;
    }
  case y0_zero:
  case y1_zero:
  case yn_zero:
    /* y0(0) */
    /* y1(0) */
    /* yn(0) */
    {
       RETVAL_NEG_HUGE_VALD; ERRNO_DOMAIN; break;
    }
  case y0f_zero:
  case y1f_zero:
  case ynf_zero:
    /* y0f(0) */
    /* y1f(0) */
    /* ynf(0) */
    {
       RETVAL_NEG_HUGE_VALF; ERRNO_DOMAIN; break;
    }
  case y0_negative:
  case y1_negative:
  case yn_negative:
    /* y0(x < 0) */
    /* y1(x < 0) */
    /* yn(x < 0) */
    {
       RETVAL_NEG_HUGE_VALD; ERRNO_DOMAIN; break;
    } 
  case y0f_negative:
  case y1f_negative:
  case ynf_negative:
    /* y0f(x < 0) */
    /* y1f(x < 0) */
    /* ynf(x < 0) */
    {
       RETVAL_NEG_HUGE_VALF; ERRNO_DOMAIN; break;
    } 
  case log_zero:
  case log1p_zero:
  case log10_zero:
   /* log(0) */
   /* log1p(0) */
   /* log10(0) */
    {
       RETVAL_NEG_HUGE_VALD; ERRNO_RANGE; break;
    }
  case logf_zero:
  case log1pf_zero:
  case log10f_zero:
    /* logf(0) */
    /* log1pf(0) */
    /* log10f(0) */
    {
       RETVAL_NEG_HUGE_VALF; ERRNO_RANGE; break;
    }
  case log_negative:
  case log1p_negative:
  case log10_negative:
    /* log(x < 0) */
    /* log1p(x < 0) */
    /* log10(x < 0) */
    {
       RETVAL_NEG_HUGE_VALD; ERRNO_DOMAIN; break;
    } 
  case logf_negative:
  case log1pf_negative:
  case log10f_negative:
    /* logf(x < 0) */
    /* log1pf(x < 0) */
    /* log10f(x < 0) */
    {
       RETVAL_NEG_HUGE_VALF; ERRNO_DOMAIN; break;
    } 
  case exp_overflow:
    /* exp overflow */
    {
       RETVAL_HUGE_VALD; ERRNO_RANGE; break;
    }
  case expf_overflow:
    /* expf overflow */
    {
       RETVAL_HUGE_VALF; ERRNO_RANGE; break;
    }
  case exp_underflow:
    /* exp underflow */
    {
       RETVAL_ZEROD; ERRNO_RANGE; break;
    }
  case expf_underflow:
    /* expf underflow */
    {
       RETVAL_ZEROF; ERRNO_RANGE; break;
    }
  case j0_gt_loss:
  case y0_gt_loss:
  case j1_gt_loss:
  case y1_gt_loss:
  case jn_gt_loss:
  case yn_gt_loss:
    /* jn and yn double > XLOSS */
    {
       RETVAL_ZEROD; ERRNO_RANGE; break;
    }
  case j0f_gt_loss:
  case y0f_gt_loss:
  case j1f_gt_loss:
  case y1f_gt_loss:
  case jnf_gt_loss:
  case ynf_gt_loss:
    /* j0n and y0n > XLOSS */
    {
       RETVAL_ZEROF; ERRNO_RANGE; break;
    }
  case pow_zero_to_zero:
    /* pow 0**0 */
    {
       break;
    }
  case powf_zero_to_zero:
    /* powf 0**0 */
    {
       break;
    }
  case pow_overflow:
    /* pow(x,y) overflow */
    {
       if (INPUT_RESD < 0) RETVAL_NEG_HUGE_VALD;
       else RETVAL_HUGE_VALD;
       ERRNO_RANGE; break;
    }
  case powf_overflow:
    /* powf(x,y) overflow */
    {
       if (INPUT_RESF < 0) RETVAL_NEG_HUGE_VALF;
       else RETVAL_HUGE_VALF;
       ERRNO_RANGE; break;
    }
  case pow_underflow:
    /* pow(x,y) underflow */
    {
       RETVAL_ZEROD; ERRNO_RANGE; break;
    }
  case  powf_underflow:
    /* powf(x,y) underflow */
    {
       RETVAL_ZEROF; ERRNO_RANGE; break;
    }
  case pow_zero_to_negative:
    /* 0**neg */
    {
       ERRNO_DOMAIN; break;
    }
  case  powf_zero_to_negative:
    /* 0**neg */
    {
       ERRNO_DOMAIN; break;
    }
  case pow_neg_to_non_integer:
    /* neg**non_integral */
    {
       ERRNO_DOMAIN; break;
    }
  case  powf_neg_to_non_integer:
    /* neg**non-integral */
    {
       ERRNO_DOMAIN; break;
    }
  case  pow_nan_to_zero:
    /* pow(NaN,0.0) */
    {
       break;
    }
  case  powf_nan_to_zero:
    /* powf(NaN,0.0) */
    {
       break;
    }
  case atan2_zero:
    /* atan2(0,0) */
    {
       RETVAL_ZEROD; ERRNO_DOMAIN; break;
    }
  case
    atan2f_zero:
    /* atan2f(0,0) */
    {
       RETVAL_ZEROF; ERRNO_DOMAIN; break;
    }
  case expm1_overflow:
    /* expm1 overflow */
    {
       ERRNO_RANGE; break;
    }
  case expm1f_overflow:
    /* expm1f overflow */
    {
       ERRNO_RANGE; break;
    }
  case expm1_underflow:
    /* expm1 underflow */
    {
       ERRNO_RANGE; break;
    }
  case expm1f_underflow:
    /* expm1f underflow */
    {
       ERRNO_RANGE; break;
    }
  case hypot_overflow:
    /* hypot overflow */
    {
       RETVAL_HUGE_VALD; ERRNO_RANGE; break;
    }
  case hypotf_overflow:
    /* hypotf overflow */
    {
       RETVAL_HUGE_VALF; ERRNO_RANGE; break;
    }
  case scalb_underflow:
    /* scalb underflow */
    {
       if (INPUT_XD < 0) RETVAL_NEG_ZEROD; 
       else RETVAL_ZEROD;
       ERRNO_RANGE; break;
    }
  case scalbf_underflow:
    /* scalbf underflow */
    {
       if (INPUT_XF < 0) RETVAL_NEG_ZEROF; 
       else RETVAL_ZEROF;
       ERRNO_RANGE; break;
    }
  case scalb_overflow:
    /* scalb overflow */
    {
       if (INPUT_XD < 0) RETVAL_NEG_HUGE_VALD; 
       else RETVAL_HUGE_VALD;
       ERRNO_RANGE; break;
    }
  case scalbf_overflow:
    /* scalbf overflow */
    {
       if (INPUT_XF < 0) RETVAL_NEG_HUGE_VALF; 
       else RETVAL_HUGE_VALF;
       ERRNO_RANGE; break;
    }
  case acosh_lt_one:
    /* acosh(x < 1) */
    {
       ERRNO_DOMAIN; break;
    }
  case acoshf_lt_one:
    /* acoshf(x < 1) */
    {
        ERRNO_DOMAIN; break;
    }
  case acos_gt_one:
    /* acos(x > 1) */
    {
       RETVAL_ZEROD;ERRNO_DOMAIN; break;
    }
  case acosf_gt_one:
    /* acosf(x > 1) */
    {
       RETVAL_ZEROF;ERRNO_DOMAIN; break;
    }
  case asin_gt_one:
    /* asin(x > 1) */
    {
       RETVAL_ZEROD; ERRNO_DOMAIN; break;
    }
  case asinf_gt_one:
    /* asinf(x > 1) */
    {
       RETVAL_ZEROF; ERRNO_DOMAIN; break;
    }
  case remainder_by_zero:
  case fmod_by_zero:
    /* fmod(x,0) */
    {
       ERRNO_DOMAIN; break;
    }
  case remainderf_by_zero:
  case fmodf_by_zero:
    /* fmodf(x,0) */
    {
       ERRNO_DOMAIN; break;
    }
  case cosh_overflow:
    /* cosh overflows */
    {
       RETVAL_HUGE_VALD; ERRNO_RANGE; break;
    }
  case coshf_overflow:
    /* coshf overflows */
    {
       RETVAL_HUGE_VALF; ERRNO_RANGE; break;
    }
  case sinh_overflow:
    /* sinh overflows */
    {
       if (INPUT_XD > 0) RETVAL_HUGE_VALD;
       else RETVAL_NEG_HUGE_VALD;
       ERRNO_RANGE; break;
    }
  case sinhf_overflow:
    /* sinhf overflows */
    {
       if (INPUT_XF > 0) RETVAL_HUGE_VALF;
       else RETVAL_NEG_HUGE_VALF;
       ERRNO_RANGE; break;
    }
  case logb_zero:
   /* logb(0) */
   {
      ERRNO_DOMAIN; break;
   }
  case logbf_zero:
   /* logbf(0) */
   {
      ERRNO_DOMAIN; break;
   }
}
return;
/* _POSIX_ */
}

/***************************************/
/* __SVID__, __MS__ and __XOPEN__ Path */
/***************************************/
else 
{
  switch(input_tag)
  {
  case ldexp_overflow:
  case ldexp_underflow:
  case ldexpf_overflow:
  case ldexpf_underflow:
  {
       ERRNO_RANGE; break;
  }
  case sqrt_negative: 
    /* sqrt(x < 0) */
    {
       DOMAIND; NAMED = "sqrt";
       ifSVID 
       {
         
         RETVAL_ZEROD;
         NOT_MATHERRD 
         {
           WRITED_SQRT;
           ERRNO_DOMAIN;
         }
       }
       else
       { /* NaN already computed */
         NOT_MATHERRD {ERRNO_DOMAIN;}
       } 
       *(double *)retval = exc.retval;	
       break;
    }
  case sqrtf_negative: 
    /* sqrtf(x < 0) */
    {
       DOMAINF; NAMEF = "sqrtf"; 
       ifSVID 
       {
         RETVAL_ZEROF;
         NOT_MATHERRF 
         {
           WRITEF_SQRT;
           ERRNO_DOMAIN;
         }
       }
       else
       {
         NOT_MATHERRF {ERRNO_DOMAIN;}
       }
#ifdef __MS__
       *(float *)retval = (float) excf.retval;	
#elif
       *(float *)retval = excf.retval;	
#endif
       break;
    }
  case log_zero:
    /* log(0) */
    {
       SINGD; NAMED="log"; 
       ifSVID 
       {
         RETVAL_NEG_HUGED;
         NOT_MATHERRD 
         {
           WRITED_LOG_ZERO;
           ERRNO_DOMAIN;
         }  
       }
       else
       {
         RETVAL_NEG_HUGE_VALD;
         NOT_MATHERRD {ERRNO_DOMAIN;}
       }
       *(double *)retval = exc.retval;	
       break;
    }
  case logf_zero:
    /* logf(0) */
    {
       SINGF; NAMEF="logf"; 
       ifSVID 
       {
         RETVAL_NEG_HUGEF; 
         NOT_MATHERRF
         {
            WRITEF_LOG_ZERO;
            ERRNO_DOMAIN;
         }
       }
       else
       {
         RETVAL_NEG_HUGE_VALF; 
         NOT_MATHERRF {ERRNO_DOMAIN;}
       }
#ifdef __MS__
       *(float *)retval = (float) excf.retval;	
#elif
       *(float *)retval = excf.retval;	
#endif
       break;
    }

  case log_negative:
    /* log(x < 0) */
    {
       DOMAIND; NAMED="log";
       ifSVID 
       {
         RETVAL_NEG_HUGED;
         NOT_MATHERRD 
         {
           WRITED_LOG_NEGATIVE;
           ERRNO_DOMAIN;
         }
       }
       else
       {
#ifndef __MS__
         RETVAL_NEG_HUGE_VALD;
#endif
         NOT_MATHERRD {ERRNO_DOMAIN;}
       }
       *(double *)retval = exc.retval;	
       break;
    } 
  case logf_negative:
    /* logf(x < 0) */
    {
       DOMAINF; NAMEF="logf";
       ifSVID 
       {
         RETVAL_NEG_HUGEF;
         NOT_MATHERRF 
         {
           WRITEF_LOG_NEGATIVE;
           ERRNO_DOMAIN;
         }
       }  
       else
       {
#ifndef __MS__
         RETVAL_NEG_HUGE_VALF;
#endif
         NOT_MATHERRF{ERRNO_DOMAIN;}
       }
#ifdef __MS__
       *(float *)retval = (float) excf.retval;	
#elif
       *(float *)retval = excf.retval;	
#endif
       break;
    }
  case log1p_zero:
    /* log1p(-1) */
    {
       SINGD; NAMED="log1p";
       ifSVID 
       {
         RETVAL_NEG_HUGED;
         NOT_MATHERRD
         {
           WRITED_LOG1P_ZERO;
           ERRNO_DOMAIN;
         }
       }
       else
       {
         RETVAL_NEG_HUGE_VALD;
         NOT_MATHERRD {ERRNO_DOMAIN;}
       }
       *(double *)retval = exc.retval;
       break;
    }
  case log1pf_zero:
    /* log1pf(-1) */
    {
       SINGF; NAMEF="log1pf";
       ifSVID 
       {
         RETVAL_NEG_HUGEF;
         NOT_MATHERRF
         {
           WRITEF_LOG1P_ZERO;
           ERRNO_DOMAIN;
         }
       }
       else
       {
         RETVAL_NEG_HUGE_VALF;
         NOT_MATHERRF {}ERRNO_DOMAIN;
       }
#ifdef __MS__
       *(float *)retval = (float) excf.retval;	
#elif
       *(float *)retval = excf.retval;	
#endif
       break;
    } 
 case log1p_negative:
   /* log1p(x < -1) */
   {
      DOMAIND; NAMED="log1p";
      ifSVID
      {
        RETVAL_NEG_HUGED;
        NOT_MATHERRD
        {
          WRITED_LOG1P_NEGATIVE;
          ERRNO_DOMAIN;
        }
      }
      else 
      {
#ifndef __MS__
        RETVAL_NEG_HUGE_VALD;
#endif
        NOT_MATHERRD {ERRNO_DOMAIN;}
      }
      *(double *)retval = exc.retval;
      break;
   }
 case log1pf_negative:
   /* log1pf(x < -1) */
   {
      DOMAINF; NAMEF="log1pf";
      ifSVID
      {
        RETVAL_NEG_HUGEF;
        NOT_MATHERRF
        {
          WRITEF_LOG1P_NEGATIVE;
          ERRNO_DOMAIN;
        }
      }
      else 
      {
#ifndef __MS__
        RETVAL_NEG_HUGE_VALF;
#endif
        NOT_MATHERRF {ERRNO_DOMAIN;}
      }
#ifdef __MS__
       *(float *)retval = (float) excf.retval;	
#elif
       *(float *)retval = excf.retval;	
#endif
      break;
   }
  case log10_zero:
    /* log10(0) */
    {
       SINGD; NAMED="log10";
       ifSVID 
       {
         RETVAL_NEG_HUGED;
         NOT_MATHERRD
         {
           WRITED_LOG10_ZERO;
           ERRNO_RANGE;
         }
       }
       else
       {
         RETVAL_NEG_HUGE_VALD;
         NOT_MATHERRD {ERRNO_DOMAIN;}
       }
       *(double *)retval = exc.retval;	
       break;
    }
  case log10f_zero:
    /* log10f(0) */
    {
       SINGF; NAMEF="log10f";
       ifSVID 
       {
         RETVAL_NEG_HUGEF;
         NOT_MATHERRF
         {
           WRITEF_LOG10_ZERO;
           ERRNO_RANGE;
         }
       }
       else
       {
         RETVAL_NEG_HUGE_VALF;
         NOT_MATHERRF {ERRNO_DOMAIN;}
       }
#ifdef __MS__
       *(float *)retval = (float) excf.retval;	
#elif
       *(float *)retval = excf.retval;	
#endif
       break;
    }
  case log10_negative:
    /* log10(x < 0) */
    {
       DOMAIND; NAMED="log10";
       ifSVID 
       {
         RETVAL_NEG_HUGED;
         NOT_MATHERRD 
         {
           WRITED_LOG10_NEGATIVE;
           ERRNO_DOMAIN;
         }
       }  
       else
       {
#ifndef __MS__
         RETVAL_NEG_HUGE_VALD;
#endif
         NOT_MATHERRD {ERRNO_DOMAIN;}
       }
       *(double *)retval = exc.retval;	
       break;
    }
  case log10f_negative:
    /* log10f(x < 0) */
    {
       DOMAINF; NAMEF="log10f";
       ifSVID 
       {
         RETVAL_NEG_HUGEF;
         NOT_MATHERRF 
         {
           WRITEF_LOG10_NEGATIVE;
           ERRNO_DOMAIN;
         }
       }
       else
       {
#ifndef __MS__
         RETVAL_NEG_HUGE_VALF;
#endif
         NOT_MATHERRF {ERRNO_DOMAIN;}
       }
#ifdef __MS__
       *(float *)retval = (float) excf.retval;	
#elif
       *(float *)retval = excf.retval;	
#endif
       break;
    }
  case exp_overflow:
    /* exp overflow */
    {
       OVERFLOWD; NAMED="exp";
       ifSVID 
       {
         RETVAL_HUGED;
       }
       else
       {
         RETVAL_HUGE_VALD;
       }
       NOT_MATHERRD {ERRNO_RANGE;}
       *(double *)retval = exc.retval;	
       break;
    }
  case expf_overflow:
    /* expf overflow */
    {
       OVERFLOWF; NAMEF="expf";
       ifSVID 
       {
         RETVAL_HUGEF;
       }
       else
       {
         RETVAL_HUGE_VALF;
       }
       NOT_MATHERRF {ERRNO_RANGE;}
#ifdef __MS__
       *(float *)retval = (float) excf.retval;	
#elif
       *(float *)retval = excf.retval;	
#endif
       break;
    }
  case exp_underflow:
    /* exp underflow */
    {
       UNDERFLOWD; NAMED="exp"; RETVAL_ZEROD;
       NOT_MATHERRD {ERRNO_RANGE;}
       *(double *)retval = exc.retval;	
       break;
    }
  case expf_underflow:
    /* expf underflow */
    {
       UNDERFLOWF; NAMEF="expf"; RETVAL_ZEROF;
       NOT_MATHERRF {ERRNO_RANGE;}
#ifdef __MS__
       *(float *)retval = (float) excf.retval;	
#elif
       *(float *)retval = excf.retval;	
#endif
       break;
    }
  case pow_zero_to_zero:
    /* pow 0**0 */
    {
       DOMAIND; NAMED="pow";
       ifSVID 
       {
         RETVAL_ZEROD;
         NOT_MATHERRD 
         {
            WRITED_POW_ZERO_TO_ZERO;
            ERRNO_RANGE;
         }
         *(double *)retval = exc.retval;	
       }
       else RETVAL_ONED;
       break;
    }
  case powf_zero_to_zero:
    /* powf 0**0 */
    {
       DOMAINF; NAMEF="powf";
       ifSVID 
       {
         RETVAL_ZEROF;
         NOT_MATHERRF 
         {
          WRITEF_POW_ZERO_TO_ZERO;
          ERRNO_RANGE;
         }
#ifdef __MS__
       *(float *)retval = (float) excf.retval;	
#elif
       *(float *)retval = excf.retval;	
#endif
       }
       else RETVAL_ONEF;
       break;
    }
  case pow_overflow:
    /* pow(x,y) overflow */
    {
       OVERFLOWD; NAMED = "pow";
       ifSVID 
       {
         if (INPUT_XD < 0) RETVAL_NEG_HUGED;
         else RETVAL_HUGED;
       }
       else
       { 
         if (INPUT_XD < 0) RETVAL_NEG_HUGE_VALD;
         else RETVAL_HUGE_VALD;
       }
       NOT_MATHERRD {ERRNO_RANGE;}
       *(double *)retval = exc.retval;	
       break;
    }
  case powf_overflow:
    /* powf(x,y) overflow */
    {
       OVERFLOWF; NAMEF = "powf";
       ifSVID 
       {
         if (INPUT_XF < 0) RETVAL_NEG_HUGEF;
         else RETVAL_HUGEF; 
       }
       else
       { 
         if (INPUT_XF < 0) RETVAL_NEG_HUGE_VALF;
         else RETVAL_HUGE_VALF;
       }
       NOT_MATHERRF {ERRNO_RANGE;}
#ifdef __MS__
       *(float *)retval = (float) excf.retval;	
#elif
       *(float *)retval = excf.retval;	
#endif
       break;
    }
  case pow_underflow:
    /* pow(x,y) underflow */
    {
       UNDERFLOWD; NAMED = "pow"; RETVAL_ZEROD;
       NOT_MATHERRD {ERRNO_RANGE;}
       *(double *)retval = exc.retval;	
       break;
    }
  case powf_underflow:
    /* powf(x,y) underflow */
    {
       UNDERFLOWF; NAMEF = "powf"; RETVAL_ZEROF;
       NOT_MATHERRF {ERRNO_RANGE;}
#ifdef __MS__
       *(float *)retval = (float) excf.retval;	
#elif
       *(float *)retval = excf.retval;	
#endif
       break;
    }
  case pow_zero_to_negative:
    /* 0**neg */
    {
       DOMAIND; NAMED = "pow";
       ifSVID 
       { 
         RETVAL_ZEROD;
         NOT_MATHERRD 
         {
           WRITED_POW_ZERO_TO_NEGATIVE;
           ERRNO_DOMAIN;
         }
       }
       else
       {
#ifndef __MS__
         RETVAL_NEG_HUGE_VALD;
#endif
         NOT_MATHERRD {ERRNO_DOMAIN;}
       }
       *(double *)retval = exc.retval;	
       break;
    }
  case powf_zero_to_negative:
    /* 0**neg */
    {
       DOMAINF; NAMEF = "powf";
       RETVAL_NEG_HUGE_VALF;
       ifSVID 
       { 
         RETVAL_ZEROF;
         NOT_MATHERRF 
         {
            WRITEF_POW_ZERO_TO_NEGATIVE;
            ERRNO_DOMAIN;
         }
       }
       else
       {
#ifndef __MS__
         RETVAL_NEG_HUGE_VALF;
#endif
         NOT_MATHERRF {ERRNO_DOMAIN;}
       }
#ifdef __MS__
       *(float *)retval = (float) excf.retval;	
#elif
       *(float *)retval = excf.retval;	
#endif
       break;
    }
  case pow_neg_to_non_integer:
    /* neg**non_integral */
    {
       DOMAIND; NAMED = "pow";
       ifSVID 
       { 
         RETVAL_ZEROD;
         NOT_MATHERRD 
         {
            WRITED_POW_NEG_TO_NON_INTEGER;
            ERRNO_DOMAIN;
         }
       }
       else
       {
         NOT_MATHERRD {ERRNO_DOMAIN;}
       }
       *(double *)retval = exc.retval;	
       break;
    }
  case powf_neg_to_non_integer:
    /* neg**non-integral */
    {
       DOMAINF; NAMEF = "powf";
       ifSVID 
       { 
         RETVAL_ZEROF;
         NOT_MATHERRF 
         {
            WRITEF_POW_NEG_TO_NON_INTEGER;
            ERRNO_DOMAIN;
         }
       }
       else
       {
         NOT_MATHERRF {ERRNO_DOMAIN;}
       }
#ifdef __MS__
       *(float *)retval = (float) excf.retval;	
#elif
       *(float *)retval = excf.retval;	
#endif
       break;
    }
  case pow_nan_to_zero:
    /* pow(NaN,0.0) */
    /* Special Error */
    {
       DOMAIND; NAMED = "pow"; INPUT_XD; INPUT_YD;
       exc.retval = *(double *)arg1; 
       if (!_matherr(&exc)) ERRNO_DOMAIN;
       *(double *)retval = exc.retval;	
       break;
    }
  case powf_nan_to_zero:
    /* powf(NaN,0.0) */
    /* Special Error */
    {
       DOMAINF; NAMEF = "powf"; INPUT_XF; INPUT_YF;
#ifdef __MS__
       excf.retval = *(double *)arg1; 
#elif
       excf.retval = *(float *)arg1; 
#endif
       if (!_matherrf(&excf)) ERRNO_DOMAIN;
#ifdef __MS__
       *(float *)retval = (float) excf.retval;	
#elif
       *(float *)retval = excf.retval;	
#endif
       break;
    }
  case atan2_zero:
    /* atan2(0.0,0.0) */
    {
       DOMAIND; NAMED = "atan2"; 
#ifndef __MS__
       RETVAL_ZEROD;
#endif
       NOT_MATHERRD 
       {
         ifSVID 
         { 
            WRITED_ATAN2_ZERO_BY_ZERO;
         }
         ERRNO_DOMAIN;
       }
       *(double *)retval = exc.retval;	
       break;
    }
  case atan2f_zero:
    /* atan2f(0.0,0.0) */
    {
       DOMAINF; NAMEF = "atan2f"; 
#ifndef __MS__
       RETVAL_ZEROF;
#endif
       NOT_MATHERRF 
         ifSVID  
         {
            WRITEF_ATAN2_ZERO_BY_ZERO;
         }
       ERRNO_DOMAIN;
#ifdef __MS__
       *(float *)retval = (float) excf.retval;	
#elif
       *(float *)retval = excf.retval;	
#endif
       break;
    }
  case expm1_overflow:
    /* expm1(finite) overflow */
    /* Overflow is the only documented */
    /* special value. */
    {
      ERRNO_RANGE;
      break;
    }
  case expm1f_overflow:
    /* expm1f(finite) overflow */
    {
      ERRNO_RANGE;
      break;
    }
  case expm1_underflow:
    /* expm1(finite) underflow */
    /* Underflow is not documented */
    /* special value. */
    {
      ERRNO_RANGE;
      break;
    }
  case expm1f_underflow:
    /* expm1f(finite) underflow */
    {
      ERRNO_RANGE;
      break;
    }
  case scalb_underflow:
    /* scalb underflow */
    {
       UNDERFLOWD; NAMED = "scalb"; 
       if (INPUT_XD < 0.0) RETVAL_NEG_ZEROD;
       else  RETVAL_ZEROD;
       NOT_MATHERRD {ERRNO_RANGE;} 
       *(double *)retval = exc.retval;	
       break;
    }
  case scalbf_underflow:
    /* scalbf underflow */
    {
       UNDERFLOWF; NAMEF = "scalbf";
       if (INPUT_XF < 0.0) RETVAL_NEG_ZEROF;
       else  RETVAL_ZEROF;
       NOT_MATHERRF {ERRNO_RANGE;} 
#ifdef __MS__
       *(float *)retval = (float) excf.retval;	
#elif
       *(float *)retval = excf.retval;	
#endif
       break;
    }
  case scalb_overflow:
    /* scalb overflow */
    {
       OVERFLOWD; NAMED = "scalb"; 
       if (INPUT_XD < 0) RETVAL_NEG_HUGE_VALD;
       else RETVAL_HUGE_VALD;
       NOT_MATHERRD {ERRNO_RANGE;} 
       *(double *)retval = exc.retval;	
       break;
    }
  case scalbf_overflow:
    /* scalbf overflow */
    {
       OVERFLOWF; NAMEF = "scalbf"; 
       if (INPUT_XF < 0) RETVAL_NEG_HUGE_VALF;
       else RETVAL_HUGE_VALF;
       NOT_MATHERRF {ERRNO_RANGE;} 
#ifdef __MS__
       *(float *)retval = (float) excf.retval;	
#elif
       *(float *)retval = excf.retval;	
#endif
       break;
    }
  case hypot_overflow:
    /* hypot overflow */
    {
       OVERFLOWD; NAMED = "hypot";
       ifSVID
       { 
         RETVAL_HUGED;
       }
       else
       {
         RETVAL_HUGE_VALD;
       }
       NOT_MATHERRD {ERRNO_RANGE;}
       *(double *)retval = exc.retval;	
       break;
    }
  case hypotf_overflow:
    /* hypotf overflow */
    { 
       OVERFLOWF; NAMEF = "hypotf"; 
       ifSVID 
       {
         RETVAL_HUGEF;
       }
       else
       {
         RETVAL_HUGE_VALF;
       }
       NOT_MATHERRF {ERRNO_RANGE;}
#ifdef __MS__
       *(float *)retval = (float) excf.retval;	
#elif
       *(float *)retval = excf.retval;	
#endif
       break;
    }
  case acos_gt_one:
    /* acos(x > 1) */
    {
       DOMAIND; NAMED = "acos";
#ifndef __MS__
       RETVAL_ZEROD;
#endif
       ifSVID 
       {
         NOT_MATHERRD
         {
           WRITED_ACOS;
           ERRNO_DOMAIN;
         }
       }
       else
       {
         NOT_MATHERRD {ERRNO_DOMAIN;}
       }
       *(double *)retval = exc.retval;
       break;
    }
  case acosf_gt_one:
    /* acosf(x > 1) */
    {
       DOMAINF; NAMEF = "acosf"; 
#ifndef __MS__
       RETVAL_ZEROF;
#endif
       ifSVID 
       {
         NOT_MATHERRF 
         {
           WRITEF_ACOS;
           ERRNO_DOMAIN;
         }
       }
       else
       {
         NOT_MATHERRF {ERRNO_DOMAIN;}
       } 
#ifdef __MS__
       *(float *)retval = (float)excf.retval;	
#elif
       *(float *)retval = excf.retval;	
#endif
       break;
    }
  case asin_gt_one:
    /* asin(x > 1) */
    {
       DOMAIND; NAMED = "asin";
#ifndef __MS__
       RETVAL_ZEROD;
#endif
       ifSVID 
       {
         NOT_MATHERRD
         {
           WRITED_ASIN;
           ERRNO_DOMAIN;
         }
       }
       else
       {
         NOT_MATHERRD {ERRNO_DOMAIN;}
       }
       *(double *)retval = exc.retval;
       break;
    }
  case asinf_gt_one:
    /* asinf(x > 1) */
    {
       DOMAINF; NAMEF = "asinf";
#ifndef __MS__
       RETVAL_ZEROF;
#endif
       ifSVID 
       {
         NOT_MATHERRF 
         {
            WRITEF_ASIN;
            ERRNO_DOMAIN;
         }
       }
       else
       {
         NOT_MATHERRF {ERRNO_DOMAIN;}
       } 
#ifdef __MS__
       *(float *)retval = (float) excf.retval;	
#elif
       *(float *)retval = excf.retval;	
#endif
       break;
    }
 case cosh_overflow:
   /* cosh overflow */
   {
      OVERFLOWD; NAMED="cosh";
      ifSVID
      {
        RETVAL_HUGED;
      }
      else 
      {
        RETVAL_HUGE_VALD;
      }
      NOT_MATHERRD {ERRNO_RANGE;}
      *(double *)retval = exc.retval;
      break;
   }
 case coshf_overflow:
   /* coshf overflow */
   {
      OVERFLOWF; NAMEF="coshf";
      ifSVID
      {
        RETVAL_HUGEF;
      }
      else 
      {
        RETVAL_HUGE_VALF;
      }
      NOT_MATHERRF {ERRNO_RANGE;}
#ifdef __MS__
       *(float *)retval = (float) excf.retval;	
#elif
       *(float *)retval = excf.retval;	
#endif
      break;
   }
 case sinh_overflow:
   /* sinh overflow */
   {
      OVERFLOWD; NAMED="sinh";
      ifSVID
      {
        if (INPUT_XD > 0.0) RETVAL_HUGED;
        else RETVAL_NEG_HUGED;
      }
      else 
      {
        if (INPUT_XD > 0.0) RETVAL_HUGE_VALD;
        else RETVAL_NEG_HUGE_VALD;
      }
      NOT_MATHERRD {ERRNO_RANGE;}
      *(double *)retval = exc.retval;
      break;
   }
 case sinhf_overflow:
   /* sinhf overflow */
   {
      OVERFLOWF; NAMEF="sinhf";
      ifSVID
      {
        if( INPUT_XF > 0.0) RETVAL_HUGEF;
        else RETVAL_NEG_HUGEF;
      }
      else 
      {
        if (INPUT_XF > 0.0) RETVAL_HUGE_VALF;
        else RETVAL_NEG_HUGE_VALF;
      }
      NOT_MATHERRF {ERRNO_RANGE;}
#ifdef __MS__
       *(float *)retval = (float) excf.retval;	
#elif
       *(float *)retval = excf.retval;	
#endif
      break;
   }
  case acosh_lt_one:
    /* acosh(x < 1) */
    {
       DOMAIND; NAMED="acosh";
       ifSVID 
       {
         NOT_MATHERRD
         {
          WRITEL_ACOSH;
          ERRNO_DOMAIN;
         }
       }
       else NOT_MATHERRD {ERRNO_DOMAIN;}
       *(double *)retval = exc.retval;
       break;
    }
  case acoshf_lt_one:
    /* acoshf(x < 1) */
    {
       DOMAINF; NAMEF="acoshf";
       ifSVID 
       {
         NOT_MATHERRF
         {
           WRITEF_ACOSH;
           ERRNO_DOMAIN;
         }
       }
       else
       {
         NOT_MATHERRF {ERRNO_DOMAIN;}
       }
#ifdef __MS__
       *(float *)retval = (float) excf.retval;	
#elif
       *(float *)retval = excf.retval;	
#endif
       ERRNO_DOMAIN; break;
    }
  case atanh_gt_one:
    /* atanh(|x| > 1) */
    {
       DOMAIND; NAMED="atanh";
       ifSVID 
       {
         NOT_MATHERRD
         {
           WRITED_ATANH_GT_ONE;
           ERRNO_DOMAIN;
         }
       }
       else
       {
         NOT_MATHERRD {ERRNO_DOMAIN;}
       }
       break;
    }
  case atanhf_gt_one:
    /* atanhf(|x| > 1) */
    {
       DOMAINF; NAMEF="atanhf";
       ifSVID 
       {
         NOT_MATHERRF
         {
           WRITEF_ATANH_GT_ONE;
           ERRNO_DOMAIN;
         }
       }
       else
       {
         NOT_MATHERRF {ERRNO_DOMAIN;}
       }
       break;
    }
  case atanh_eq_one:
    /* atanh(|x| == 1) */
    {
       SINGD; NAMED="atanh";
       ifSVID 
       {
         NOT_MATHERRD
         {
           WRITED_ATANH_EQ_ONE;
           ERRNO_DOMAIN;
         }
       }
       else
       {
       NOT_MATHERRD {ERRNO_DOMAIN;}
       }
       break;
    }
  case atanhf_eq_one:
    /* atanhf(|x| == 1) */
    {
       SINGF; NAMEF="atanhf";
       ifSVID 
       {
         NOT_MATHERRF
         {
           WRITEF_ATANH_EQ_ONE;
           ERRNO_DOMAIN;
         }
       }
       else
       {
         NOT_MATHERRF {ERRNO_DOMAIN;}
       }
       break;
    }
  case gamma_overflow:
    /* gamma overflow */
    {
       OVERFLOWD; NAMED="gamma";
       ifSVID 
       {
         RETVAL_HUGED;
       }
         else
       {
         RETVAL_HUGE_VALD;
       }
       NOT_MATHERRD {ERRNO_RANGE;}
       *(double *)retval = exc.retval;
       break;
    }
  case gammaf_overflow:
    /* gammaf overflow */
    {
       OVERFLOWF; NAMEF="gammaf";
       ifSVID 
       {
         RETVAL_HUGEF;
       }
       else
       {
         RETVAL_HUGE_VALF;
       }
       NOT_MATHERRF {ERRNO_RANGE;}
#ifdef __MS__
       *(float *)retval = (float) excf.retval;	
#elif
       *(float *)retval = excf.retval;	
#endif
       break;
    }
  case lgamma_overflow:
    /* lgamma overflow */
    {
       OVERFLOWD; NAMED="lgamma";
       ifSVID 
       {
         RETVAL_HUGED;
       }
       else
       {
         RETVAL_HUGE_VALD;
       }
       NOT_MATHERRD {ERRNO_RANGE;}
       *(double *)retval = exc.retval;
       break;
    }
  case lgammaf_overflow:
    /* lgammaf overflow */
    {
       OVERFLOWF; NAMEF="lgammaf";
       ifSVID 
       {
         RETVAL_HUGEF;
       }
       else
       {
         RETVAL_HUGE_VALF;
       }
       NOT_MATHERRF {ERRNO_RANGE;}
#ifdef __MS__
       *(float *)retval = (float) excf.retval;	
#elif
       *(float *)retval = excf.retval;	
#endif
       break;
    }
  case lgamma_negative:
    /* lgamma -int or 0 */
    {
       SINGD; NAMED="lgamma";
       ifSVID 
       {
         RETVAL_HUGED;
         NOT_MATHERRD
         {
           WRITED_LGAMMA_NEGATIVE;
           ERRNO_DOMAIN;
         }
       }
       else
       {
         RETVAL_HUGE_VALD;
         NOT_MATHERRD {ERRNO_DOMAIN;}
       }
       *(double *)retval = exc.retval;	
       break;
    }
  case lgammaf_negative:
    /* lgammaf -int or 0 */
    {
       SINGF; NAMEF="lgammaf";
       ifSVID 
       {
         RETVAL_HUGEF;
         NOT_MATHERRF
         {
           WRITEF_LGAMMA_NEGATIVE;
           ERRNO_DOMAIN;
         }
       }
       else
       {
         RETVAL_HUGE_VALF;
         NOT_MATHERRF {ERRNO_DOMAIN;}
       }
#ifdef __MS__
       *(float *)retval = (float) excf.retval;	
#elif
       *(float *)retval = excf.retval;	
#endif
       break;
    }
  case gamma_negative:
    /* gamma -int or 0 */
    {
       SINGD; NAMED="gamma";
       ifSVID 
       {
         RETVAL_HUGED;
         NOT_MATHERRD
         {
            WRITED_GAMMA_NEGATIVE;
            ERRNO_DOMAIN;
         }
       }
       else
       {
         RETVAL_HUGE_VALD;
         NOT_MATHERRD {ERRNO_DOMAIN;}
       }
       *(double *)retval = exc.retval;	
       break;
    }
  case gammaf_negative:
    /* gammaf -int or 0 */
    {
       SINGF; NAMEF="gammaf";
       ifSVID 
       {
         RETVAL_HUGEF;
         NOT_MATHERRF
         {
            WRITEF_GAMMA_NEGATIVE;
            ERRNO_DOMAIN;
         }
       }
       else
       {
         RETVAL_HUGE_VALF;
         NOT_MATHERRF {ERRNO_DOMAIN;}
       }
#ifdef __MS__
       *(float *)retval = (float) excf.retval;	
#elif
       *(float *)retval = excf.retval;	
#endif
       break;
    }
  case j0_gt_loss:
    /* j0 > loss */
    {
       TLOSSD; NAMED="j0";
       RETVAL_ZEROD;
       ifSVID 
       {
         NOT_MATHERRD
         {
            WRITED_J0_TLOSS;
            ERRNO_RANGE;
         }
       }
       else
       {
         NOT_MATHERRD {ERRNO_RANGE;}
       }
       *(double*)retval = exc.retval;	
       break;
    }
  case j0f_gt_loss:
    /* j0f > loss */
    {
       TLOSSF; NAMEF="j0f";
       RETVAL_ZEROF;
       ifSVID 
       {
         NOT_MATHERRF
         {
            WRITEF_J0_TLOSS;
            ERRNO_RANGE;
         }
       }
       else
       {
         NOT_MATHERRF {ERRNO_RANGE;}
       }
#ifdef __MS__
       *(float *)retval = (float) excf.retval;	
#elif
       *(float *)retval = excf.retval;	
#endif
       break;
    }
  case j1_gt_loss:
    /* j1 > loss */
    {
       TLOSSD; NAMED="j1";
       RETVAL_ZEROD;
       ifSVID 
       {
         NOT_MATHERRD
         {
            WRITED_J1_TLOSS;
            ERRNO_RANGE;
         }
       }
       else
       {
         NOT_MATHERRD {ERRNO_RANGE;}
       }
       *(double*)retval = exc.retval;	
       break;
    }
  case j1f_gt_loss:
    /* j1f > loss */
    {
       TLOSSF; NAMEF="j1f";
       RETVAL_ZEROF;
       ifSVID 
       {
         NOT_MATHERRF
         {
            WRITEF_J1_TLOSS;
            ERRNO_RANGE;
         }
       }
       else
       {
         NOT_MATHERRF {ERRNO_RANGE;}
       }
#ifdef __MS__
       *(float *)retval = (float) excf.retval;	
#elif
       *(float *)retval = excf.retval;	
#endif
       break;
    }
  case jn_gt_loss:
    /* jn > loss */
    {
       TLOSSD; NAMED="jn";
       RETVAL_ZEROD;
       ifSVID 
       {
         NOT_MATHERRD
         {
            WRITED_JN_TLOSS;
            ERRNO_RANGE;
         }
       }
       else
       {
         NOT_MATHERRD {ERRNO_RANGE;}
       }
       *(double*)retval = exc.retval;	
       break;
    }
  case jnf_gt_loss:
    /* jnf > loss */
    {
       TLOSSF; NAMEF="jnf";
       RETVAL_ZEROF;
       ifSVID 
       {
         NOT_MATHERRF
         {
            WRITEF_JN_TLOSS;
            ERRNO_RANGE;
         }
       }
       else
       {
         NOT_MATHERRF {ERRNO_RANGE;}
       }
#ifdef __MS__
       *(float *)retval = (float) excf.retval;	
#elif
       *(float *)retval = excf.retval;	
#endif
       break;
    }
  case y0_gt_loss:
    /* y0 > loss */
    {
       TLOSSD; NAMED="y0";
       RETVAL_ZEROD;
       ifSVID 
       {
         NOT_MATHERRD
         {
            WRITED_Y0_TLOSS;
            ERRNO_RANGE;
         }
       }
       else
       {
         NOT_MATHERRD {ERRNO_RANGE;}
       }
       *(double*)retval = exc.retval;
       break;
    }
  case y0f_gt_loss:
    /* y0f > loss */
    {
       TLOSSF; NAMEF="y0f";
       RETVAL_ZEROF;
       ifSVID 
       {
         NOT_MATHERRF
         {
            WRITEF_Y0_TLOSS;
            ERRNO_RANGE;
         }
       }
       else
       {
         NOT_MATHERRF {ERRNO_RANGE;}
       }
#ifdef __MS__
       *(float *)retval = (float) excf.retval;	
#elif
       *(float *)retval = excf.retval;	
#endif
       break;
    }
  case y0_zero:
    /* y0(0) */
    {
       DOMAIND; NAMED="y0";
       ifSVID 
       {
         RETVAL_NEG_HUGED;
         NOT_MATHERRD 
         {
           WRITED_Y0_ZERO;
           ERRNO_DOMAIN;
         }
       }
       else
       {
#ifndef __MS__
         RETVAL_NEG_HUGE_VALD; 
#endif
         NOT_MATHERRD {ERRNO_DOMAIN;}
       }
       *(double *)retval = exc.retval;	
       break;
    }
  case y0f_zero:
    /* y0f(0) */
    {
       DOMAINF; NAMEF="y0f";
       ifSVID 
       {
         RETVAL_NEG_HUGEF;
         NOT_MATHERRF 
         {
           WRITEF_Y0_ZERO;
           ERRNO_DOMAIN;
         }
       }
       else
       {
#ifndef __MS__
         RETVAL_NEG_HUGE_VALF;
#endif
         NOT_MATHERRF {ERRNO_DOMAIN;}
       }
#ifdef __MS__
       *(float *)retval = (float) excf.retval;	
#elif
       *(float *)retval = excf.retval;	
#endif
       break;
    }
  case y1_gt_loss:
    /* y1 > loss */
    {
       TLOSSD; NAMED="y1";
       RETVAL_ZEROD;
       ifSVID 
       {
         NOT_MATHERRD
         {
            WRITED_Y1_TLOSS;
            ERRNO_RANGE;
         }
       }
       else
       {
         NOT_MATHERRD {ERRNO_RANGE;}
       }
       *(double*)retval = exc.retval;
       break;
    }
  case y1f_gt_loss:
    /* y1f > loss */
    {
       TLOSSF; NAMEF="y1f";
       RETVAL_ZEROF;
       ifSVID 
       {
         NOT_MATHERRF
         {
            WRITEF_Y1_TLOSS;
            ERRNO_RANGE;
         }
       }
       else
       {
         NOT_MATHERRF {ERRNO_RANGE;}
       }
#ifdef __MS__
       *(float *)retval = (float) excf.retval;	
#elif
       *(float *)retval = excf.retval;	
#endif
       break;
    }
  case y1_zero:
    /* y1(0) */
    {
       DOMAIND; NAMED="y1";
       ifSVID 
       {
         RETVAL_NEG_HUGED;
         NOT_MATHERRD 
         {
           WRITED_Y1_ZERO;
           ERRNO_DOMAIN;
         }
       }
       else
       {
#ifndef __MS__
         RETVAL_NEG_HUGE_VALD;
#endif
         NOT_MATHERRD {ERRNO_DOMAIN;}
       }
       *(double *)retval = exc.retval;	
       break;
    }
  case y1f_zero:
    /* y1f(0) */
    {
       DOMAINF; NAMEF="y1f";
       ifSVID 
       {
         RETVAL_NEG_HUGEF;
         NOT_MATHERRF 
         {
           WRITEF_Y1_ZERO;
           ERRNO_DOMAIN;
         }
       }else
       {
#ifndef __MS__
         RETVAL_NEG_HUGE_VALF;
#endif
         NOT_MATHERRF {ERRNO_DOMAIN;}
       }
#ifdef __MS__
       *(float *)retval = (float) excf.retval;	
#elif
       *(float *)retval = excf.retval;	
#endif
       break;
    }
  case yn_gt_loss:
    /* yn > loss */
    {
       TLOSSD; NAMED="yn";
       RETVAL_ZEROD;
       ifSVID 
       {
         NOT_MATHERRD
         {
            WRITED_YN_TLOSS;
            ERRNO_RANGE;
         }
       }
       else
       {
         NOT_MATHERRD {ERRNO_RANGE;}
       }
       *(double*)retval = exc.retval;
       break;
    }
  case ynf_gt_loss:
    /* ynf > loss */
    {
       TLOSSF; NAMEF="ynf";
       RETVAL_ZEROF;
       ifSVID 
       {
         NOT_MATHERRF
         {
            WRITEF_YN_TLOSS;
            ERRNO_RANGE;
         }
       }
       else
       {
         NOT_MATHERRF {ERRNO_RANGE;}
       }
#ifdef __MS__
       *(float *)retval = (float) excf.retval;	
#elif
       *(float *)retval = excf.retval;	
#endif
       break;
    }
  case yn_zero:
    /* yn(0) */
    {
       DOMAIND; NAMED="yn";
       ifSVID 
       {
         RETVAL_NEG_HUGED;
         NOT_MATHERRD 
         {
           WRITED_YN_ZERO;
           ERRNO_DOMAIN;
         }
       }
       else
       {
#ifndef __MS__
         RETVAL_NEG_HUGE_VALD;
#endif
         NOT_MATHERRD {ERRNO_DOMAIN;}
       }
       *(double *)retval = exc.retval;	
       break;
    }
  case ynf_zero:
    /* ynf(0) */
    {
       DOMAINF; NAMEF="ynf";
       ifSVID 
       {
         RETVAL_NEG_HUGEF;
         NOT_MATHERRF 
         {
           WRITEF_YN_ZERO;
           ERRNO_DOMAIN;
         }
       }
       else
       {
#ifndef __MS__
         RETVAL_NEG_HUGE_VALF; 
#endif
         NOT_MATHERRF {ERRNO_DOMAIN;}
       }
#ifdef __MS__
       *(float *)retval = (float) excf.retval;	
#elif
       *(float *)retval = excf.retval;	
#endif
       break;
    }
  case y0_negative:
    /* y0(x<0) */
    {
       DOMAIND; NAMED="y0";
       ifSVID 
       {
         RETVAL_NEG_HUGED;
         NOT_MATHERRD 
         {
           WRITED_Y0_NEGATIVE;
           ERRNO_DOMAIN;
         }
       }
       else
       {
#ifndef __MS__
         RETVAL_NEG_HUGE_VALD; 
#endif
         NOT_MATHERRD {ERRNO_DOMAIN;}
       }
       *(double *)retval = exc.retval;	
       break;
    }
  case y0f_negative:
    /* y0f(x<0) */
    {
       DOMAINF; NAMEF="y0f";
       ifSVID 
       {
         RETVAL_NEG_HUGEF;
         NOT_MATHERRF 
         {
           WRITEF_Y0_NEGATIVE;
           ERRNO_DOMAIN;
         }
       }
       else
       {
#ifndef __MS__
         RETVAL_NEG_HUGE_VALF; 
#endif
         NOT_MATHERRF {ERRNO_DOMAIN;}
       }
#ifdef __MS__
       *(float *)retval = (float) excf.retval;	
#elif
       *(float *)retval = excf.retval;	
#endif
       break;
    }
  case y1_negative:
    /* y1(x<0) */
    {
       DOMAIND; NAMED="y1";
       ifSVID 
       {
         RETVAL_NEG_HUGED;
         NOT_MATHERRD 
         {
           WRITED_Y1_NEGATIUE;
           ERRNO_DOMAIN;
         }
       }
       else
       {
#ifndef __MS__
         RETVAL_NEG_HUGE_VALD; 
#endif
         NOT_MATHERRD {ERRNO_DOMAIN;}
       }
       *(double *)retval = exc.retval;	
       break;
    }
  case y1f_negative:
    /* y1f(x<0) */
    {
       DOMAINF; NAMEF="y1f";
       ifSVID 
       {
         RETVAL_NEG_HUGEF;
         NOT_MATHERRF 
         {
           WRITEF_Y1_NEGATIVE;
           ERRNO_DOMAIN;
         }
       }
       else
       {
#ifndef __MS__
         RETVAL_NEG_HUGE_VALF; 
#endif
         NOT_MATHERRF {ERRNO_DOMAIN;}
       }
#ifdef __MS__
       *(float *)retval = (float) excf.retval;	
#elif
       *(float *)retval = excf.retval;	
#endif
       break;
    }
  case yn_negative:
    /* yn(x<0) */
    {
       DOMAIND; NAMED="yn";
       ifSVID 
       {
         RETVAL_NEG_HUGED;
         NOT_MATHERRD 
         {
           WRITED_YN_NEGATIVE;
           ERRNO_DOMAIN;
         }
       }
       else
       {
#ifndef __MS__
         RETVAL_NEG_HUGE_VALD; 
#endif
         NOT_MATHERRD {ERRNO_DOMAIN;}
       }
       *(double *)retval = exc.retval;	
       break;
    }
  case ynf_negative:
    /* ynf(x<0) */
    {
       DOMAINF; NAMEF="ynf";
       ifSVID 
       {
         RETVAL_NEG_HUGEF;
         NOT_MATHERRF 
         {
           WRITEF_YN_NEGATIVE;
           ERRNO_DOMAIN;
         }
       }
       else
       {
#ifndef __MS__
         RETVAL_NEG_HUGE_VALF; 
#endif
         NOT_MATHERRF {ERRNO_DOMAIN;}
       }
#ifdef __MS__
       *(float *)retval = (float) excf.retval;	
#elif
       *(float *)retval = excf.retval;	
#endif
       break;
    }
  case fmod_by_zero: 
    /* fmod(x,0) */
    {
       DOMAIND; NAMED = "fmod";
       ifSVID 
       {
         *(double *)retval = *(double *)arg1;
         NOT_MATHERRD 
         {
           WRITED_FMOD;
           ERRNO_DOMAIN;
         }
       }
       else
       { /* NaN already computed */
         NOT_MATHERRD {ERRNO_DOMAIN;}
       } 
       *(double *)retval = exc.retval;	
       break;
    }
  case fmodf_by_zero: 
    /* fmodf(x,0) */
    {
       DOMAINF; NAMEF = "fmodf"; 
       ifSVID 
       {
#ifdef __MS__
         *(double *)retval = *(double *)arg1;
#elif
         *(float *)retval = *(float *)arg1;
#endif
         NOT_MATHERRF 
         {
           WRITEF_FMOD;
           ERRNO_DOMAIN;
         }
       }
       else
       {
         NOT_MATHERRF {ERRNO_DOMAIN;}
       } 
#ifdef __MS__
       *(float *)retval = (float) excf.retval;	
#elif
       *(float *)retval = excf.retval;	
#endif
       break;
    }
  case remainder_by_zero: 
    /* remainder(x,0) */
    {
       DOMAIND; NAMED = "remainder";
       ifSVID 
       {
         NOT_MATHERRD 
         {
           WRITED_REM;
           ERRNO_DOMAIN;
         }
       }
       else
       { /* NaN already computed */
         NOT_MATHERRD {ERRNO_DOMAIN;}
       } 
       *(double *)retval = exc.retval;	
       break;
    }
  case remainderf_by_zero: 
    /* remainderf(x,0) */
    {
       DOMAINF; NAMEF = "remainderf"; 
       ifSVID 
       {
         NOT_MATHERRF 
         {
           WRITEF_REM;
           ERRNO_DOMAIN;
         }
       }
       else
       {
         NOT_MATHERRF {ERRNO_DOMAIN;}
       } 
#ifdef __MS__
       *(float *)retval = (float) excf.retval;	
#elif
       *(float *)retval = excf.retval;	
#endif
       break;
    }
   }
   return;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\ia64\ldexp.s ===
.file "ldexp.s"

// Copyright (c) 2000, 2001, Intel Corporation
// All rights reserved.
// 
// Contributed 2/2/2000 by John Harrison, Ted Kubaska, Bob Norin, Shane Story,
// and Ping Tak Peter Tang of the Computational Software Lab, Intel Corporation.
// 
// WARRANTY DISCLAIMER
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS 
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY 
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
// 
// Intel Corporation is the author of this code, and requests that all
// problem reports or change requests be submitted to it directly at 
// http://developer.intel.com/opensource.
//
// History
//==============================================================
// 2/02/00  Initial version
// 1/26/01  ldex pcompletely reworked and now standalone version 
//
// API
//==============================================================
// double = ldexp  (double x, int n) 
// input  floating point f8 and int n (r33) 
// output floating point f8
//
// Returns x* 2**n using an fma and detects overflow
// and underflow.   
//
//

FR_Big         = f6
FR_NBig        = f7
FR_Floating_X  = f8
FR_Result      = f8
FR_Result2     = f9
FR_Result3     = f11
FR_Norm_X      = f12
FR_Two_N       = f14
FR_Two_to_Big  = f15

GR_N_Biased    = r15
GR_Big         = r16
GR_NBig        = r17
GR_Scratch     = r18
GR_Scratch1    = r19
GR_Bias        = r20
GR_N_as_int    = r21

GR_SAVE_B0          = r32
GR_SAVE_GP          = r33
GR_SAVE_PFS         = r34
GR_Parameter_X      = r35
GR_Parameter_Y      = r36
GR_Parameter_RESULT = r37
GR_Tag              = r38

.align 32
.global ldexp

.section .text
.proc  ldexp
.align 32

ldexp: 

//
//   Is x NAN, INF, ZERO, +-?
//   Build the exponent Bias
//
{    .mfi
     alloc         r32=ar.pfs,1,2,4,0
     fclass.m.unc  p7,p0 = FR_Floating_X, 0xe7 //@snan | @qnan | @inf | @zero
     addl          GR_Bias = 0x0FFFF,r0
}

//
//   Sign extend input
//   Is N zero?
//   Normalize x
//
{    .mfi
     cmp.eq.unc    p6,p0 = r33,r0  
     fnorm.s1      FR_Norm_X  =   FR_Floating_X 
     sxt4          GR_N_as_int = r33
}
;;

//
//   Normalize x
//   Branch and return special values.
//   Create -35000
//   Create 35000
//
{    .mfi
     addl          GR_Big = 35000,r0
     nop.f 0
     add           GR_N_Biased = GR_Bias,GR_N_as_int
}
{    .mfb
     addl          GR_NBig = -35000,r0
(p7) fma.d.s0      FR_Result = FR_Floating_X,f1, f0 
(p7) br.ret.spnt   b0  
};;

//
//   Build the exponent Bias
//   Return x when N = 0
//
{    .mfi
     setf.exp      FR_Two_N = GR_N_Biased                   
     nop.f 0
     addl          GR_Scratch1  = 0x063BF,r0 
}
{    .mfb
     addl          GR_Scratch  = 0x019C3F,r0 
(p6) fma.d.s0      FR_Result = FR_Floating_X,f1, f0 
(p6) br.ret.spnt   b0  
};;

//
//   Create 2*big
//   Create 2**-big 
//   Is N > 35000     
//   Is N < -35000     
//   Raise Denormal operand flag with compare
//   Main path, create 2**N
//
{    .mfi
     setf.exp      FR_NBig = GR_Scratch1                  
     nop.f 0
     cmp.ge.unc    p6, p0 = GR_N_as_int, GR_Big
}
{    .mfi
     setf.exp      FR_Big = GR_Scratch                  
     fcmp.ge.s0    p0,p11 = FR_Floating_X,f0
     cmp.le.unc    p8, p0 = GR_N_as_int, GR_NBig
};;

//
//   Adjust 2**N if N was very small or very large
//
{    .mfi
     nop.m 0
(p6) fma.s1        FR_Two_N = FR_Big,f1,f0
     nop.i 0
}
{ .mlx
     nop.m 999
     movl          GR_Scratch = 0x00000000000303FF 
};;


{    .mfi
     nop.m 0
(p8) fma.s1        FR_Two_N = FR_NBig,f1,f0
     nop.i 0
}
{    .mlx
     nop.m 999
     movl          GR_Scratch1= 0x00000000000103FF 
};;

//   Set up necessary status fields 
//
//   S0 user supplied status
//   S2 user supplied status + WRE + TD  (Overflows)
//   S3 user supplied status + FZ + TD   (Underflows)
//
{    .mfi
     nop.m 999
     fsetc.s3      0x7F,0x41
     nop.i 999
}
{    .mfi
     nop.m 999
     fsetc.s2      0x7F,0x42
     nop.i 999
};;

//
//   Do final operation
//
{    .mfi
     setf.exp     FR_NBig = GR_Scratch
     fma.d.s0     FR_Result = FR_Two_N,FR_Norm_X,f0 
     nop.i                           999
}
{    .mfi
     nop.m                           999
     fma.d.s3     FR_Result3 = FR_Two_N,FR_Norm_X,f0 
     nop.i                           999
};;
{    .mfi
     setf.exp     FR_Big = GR_Scratch1
     fma.d.s2     FR_Result2 = FR_Two_N,FR_Norm_X,f0 
     nop.i                           999
};;

//
//   Check for overflow or underflow.
//   Restore s3
//   Restore s2
//
{    .mfi
     nop.m 0
     fsetc.s3     0x7F,0x40
     nop.i 999 
}
{    .mfi
     nop.m 0
     fsetc.s2     0x7F,0x40
     nop.i 999
};;

//
//   Is the result zero?
//
{    .mfi
     nop.m 999
     fclass.m.unc p6, p0 =  FR_Result3, 0x007
     nop.i 999 
} 
{    .mfi
     addl           GR_Tag = 146, r0
     fcmp.ge.unc.s1 p7, p8 = FR_Result2 , FR_Big
     nop.i 0
};;

//
//   Detect masked underflow - Tiny + Inexact Only
//
{    .mfi
     nop.m 999
(p6) fcmp.neq.unc.s1 p6, p0 = FR_Result , FR_Result2
     nop.i 999 
};; 

//
//   Is result bigger the allowed range?
//   Branch out for underflow
//
{    .mfb
(p6) addl            GR_Tag = 147, r0
(p8) fcmp.le.unc.s1  p9, p10 = FR_Result2 , FR_NBig
(p6) br.cond.spnt    LDEXP_UNDERFLOW 
};;

//
//   Branch out for overflow
//
{ .mbb
     nop.m 0
(p7) br.cond.spnt    LDEXP_OVERFLOW 
(p9) br.cond.spnt    LDEXP_OVERFLOW 
};;

//
//   Return from main path.
//
{    .mfb
     nop.m 999
     nop.f 0
     br.ret.sptk     b0;;                   
}

.endp ldexp
.proc __libm_error_region
__libm_error_region:

LDEXP_OVERFLOW: 
LDEXP_UNDERFLOW: 

//
// Get stack address of N
//
.prologue
{ .mfi
    add   GR_Parameter_Y=-32,sp         
    nop.f 0
.save   ar.pfs,GR_SAVE_PFS
    mov  GR_SAVE_PFS=ar.pfs              
}
//
// Adjust sp 
//
{ .mfi
.fframe 64
   add sp=-64,sp                         
   nop.f 0
   mov GR_SAVE_GP=gp       
};;

//
//  Store N on stack in correct position 
//  Locate the address of x on stack
//
{ .mmi
   st8 [GR_Parameter_Y] =  GR_N_as_int,16       
   add GR_Parameter_X = 16,sp          
.save   b0, GR_SAVE_B0
   mov GR_SAVE_B0=b0                  
};;

//
// Store x on the stack.
// Get address for result on stack.
//
.body
{ .mib
   stfd [GR_Parameter_X] = FR_Norm_X 
   add   GR_Parameter_RESULT = 0,GR_Parameter_Y   
   nop.b 0
}
{ .mib
   stfd [GR_Parameter_Y] = FR_Result                 
   add   GR_Parameter_Y = -16,GR_Parameter_Y
   br.call.sptk b0=__libm_error_support#   
};;

//
//  Get location of result on stack
//
{ .mmi
   nop.m 0
   nop.m 0
   add   GR_Parameter_RESULT = 48,sp    
};;

//
//  Get the new result 
//
{ .mmi
   ldfd  FR_Result = [GR_Parameter_RESULT]      
.restore
   add   sp = 64,sp                       
   mov   b0 = GR_SAVE_B0                  
};;

//
//  Restore gp, ar.pfs and return
//
{ .mib
   mov   gp = GR_SAVE_GP                  
   mov   ar.pfs = GR_SAVE_PFS             
   br.ret.sptk     b0                  
};;

.endp __libm_error_region 

.type   __libm_error_support#,@function
.global __libm_error_support#
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\ia64\libm_reduce.s ===
.file "libm_reduce.s"

// Copyright (c) 2000, 2001, Intel Corporation
// All rights reserved.
// 
// Contributed 2/2/2000 by John Harrison, Ted Kubaska, Bob Norin, Shane Story,
// and Ping Tak Peter Tang of the Computational Software Lab, Intel Corporation.
// 
// WARRANTY DISCLAIMER
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS 
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY 
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
// 
// Intel Corporation is the author of this code, and requests that all
// problem reports or change requests be submitted to it directly at 
// http://developer.intel.com/opensource.
//
// History:  02/02/00 Initial Version
//
//*********************************************************************
//*********************************************************************
//
// Function:   __libm_pi_by_two_reduce(x) return r, c, and N where
//             x = N * pi/4 + (r+c) , where |r+c| <= pi/4.
//             This function is not designed to be used by the
//             general user.
//
//*********************************************************************
//
// Accuracy:       Returns double-precision values
//
//*********************************************************************
//
// Resources Used:
//
//    Floating-Point Registers: f32-f70
//
//    General Purpose Registers:
//      r8  = return value N
//      r32 = Address of x
//      r33 = Address of where to place r and then c 
//      r34-r64
//
//    Predicate Registers:      p6-p14
//
//*********************************************************************
//
// IEEE Special Conditions:
//
//    No condions should be raised. 
//
//*********************************************************************
//
// I. Introduction
// ===============
//
// For the forward trigonometric functions sin, cos, sincos, and
// tan, the original algorithms for IA 64 handle arguments up to 
// 1 ulp less than 2^63 in magnitude. For double-extended arguments x,
// |x| >= 2^63, this routine returns CASE, N and r_hi, r_lo where
// 
//    x  is accurately approximated by
//    2*K*pi  +  N * pi/2  +  r_hi + r_lo,  |r_hi+r_lo| <= pi/4.
//    CASE = 1 or 2.
//    CASE is 1 unless |r_hi + r_lo| < 2^(-33).
// 
// The exact value of K is not determined, but that information is
// not required in trigonometric function computations.
// 
// We first assume the argument x in question satisfies x >= 2^(63). 
// In particular, it is positive. Negative x can be handled by symmetry:
// 
//   -x  is accurately approximated by
//         -2*K*pi  +  (-N) * pi/2  -  (r_hi + r_lo),  |r_hi+r_lo| <= pi/4.
// 
// The idea of the reduction is that
// 
// 	x  *  2/pi   =   N_big  +  N  +  f,	|f| <= 1/2
// 
// Moreover, for double extended x, |f| >= 2^(-75). (This is an
// non-obvious fact found by enumeration using a special algorithm
// involving continued fraction.) The algorithm described below 
// calculates N and an accurate approximation of f.
// 
// Roughly speaking, an appropriate 256-bit (4 X 64) portion of 
// 2/pi is multiplied with x to give the desired information.
// 
// II. Representation of 2/PI
// ==========================
// 
// The value of 2/pi in binary fixed-point is
// 
//            .101000101111100110......
// 
// We store 2/pi in a table, starting at the position corresponding
// to bit position 63 
// 
//   bit position  63 62 ... 0   -1 -2 -3 -4 -5 -6 -7  ....  -16576
// 
// 	 	0  0  ... 0  . 1  0  1  0  1  0  1  ....    X
//                 
//                              ^
// 	     	             |__ implied binary pt 
// 
// III. Algorithm
// ==============
// 
// This describes the algorithm in the most natural way using
// unsigned interger multiplication. The implementation section 
// describes how the integer arithmetic is simulated.
// 
// STEP 0. Initialization
// ----------------------
// 
// Let the input argument x be 
// 
//     x = 2^m * ( 1. b_1 b_2 b_3 ... b_63 ),  63 <= m <= 16383.
// 
// The first crucial step is to fetch four 64-bit portions of 2/pi. 
// To fulfill this goal, we calculate the bit position L of the
// beginning of these 256-bit quantity by
// 
//     L :=  62 - m.
// 
// Note that -16321 <= L <= -1 because 63 <= m <= 16383; and that 
// the storage of 2/pi is adequate.
// 
// Fetch P_1, P_2, P_3, P_4 beginning at bit position L thus:
// 
//      bit position  L  L-1  L-2    ...  L-63
// 
//      P_1    =      b   b    b     ...    b
// 
// each b can be 0 or 1. Also, let P_0 be the two bits correspoding to
// bit positions L+2 and L+1. So, when each of the P_j is interpreted
// with appropriate scaling, we have
//
//      2/pi  =  P_big  + P_0 + (P_1 + P_2 + P_3 + P_4)  +  P_small
// 
// Note that P_big and P_small can be ignored. The reasons are as follow.
// First, consider P_big. If P_big = 0, we can certainly ignore it.
// Otherwise, P_big >= 2^(L+3). Now, 
// 
//        P_big * ulp(x) >=  2^(L+3) * 2^(m-63)
// 		      >=  2^(65-m  +  m-63 )
// 		      >=  2^2
// 
// Thus, P_big * x is an integer of the form 4*K. So
// 
// 	x = 4*K * (pi/2) + x*(P_0 + P_1 + P_2 + P_3 + P_4)*(pi/2)
//                + x*P_small*(pi/2).
// 
// Hence, P_big*x corresponds to information that can be ignored for
// trigonometic function evaluation.
// 
// Next, we must estimate the effect of ignoring P_small. The absolute
// error made by ignoring P_small is bounded by
// 
//       |P_small * x|  <=  ulp(P_4) * x
// 		     <=  2^(L-255) * 2^(m+1)
// 		     <=  2^(62-m-255 + m + 1)
// 		     <=  2^(-192)
// 
// Since for double-extended precision, x * 2/pi = integer + f, 
// 0.5 >= |f| >= 2^(-75), the relative error introduced by ignoring
// P_small is bounded by 2^(-192+75) <= 2^(-117), which is acceptable.
// 
// Further note that if x is split into x_hi + x_lo where x_lo is the
// two bits corresponding to bit positions 2^(m-62) and 2^(m-63); then
// 
// 	P_0 * x_hi 
// 
// is also an integer of the form 4*K; and thus can also be ignored.
// Let M := P_0 * x_lo which is a small integer. The main part of the
// calculation is really the multiplication of x with the four pieces
// P_1, P_2, P_3, and P_4.
// 
// Unless the reduced argument is extremely small in magnitude, it
// suffices to carry out the multiplication of x with P_1, P_2, and
// P_3. x*P_4 will be carried out and added on as a correction only 
// when it is found to be needed. Note also that x*P_4 need not be
// computed exactly. A straightforward multiplication suffices since
// the rounding error thus produced would be bounded by 2^(-3*64),
// that is 2^(-192) which is small enough as the reduced argument
// is bounded from below by 2^(-75).
// 
// Now that we have four 64-bit data representing 2/pi and a
// 64-bit x. We first need to calculate a highly accurate product
// of x and P_1, P_2, P_3. This is best understood as integer
// multiplication.
// 
// 
// STEP 1. Multiplication
// ----------------------
// 
// 
//                     ---------   ---------   ---------
// 	             |  P_1  |   |  P_2  |   |  P_3  |
// 	             ---------   ---------   ---------
// 
//                                            ---------
// 	      X                              |   X   |
// 	                                     ---------
//      ----------------------------------------------------
//
//                                 ---------   ---------
//	                         |  A_hi |   |  A_lo |
//	                         ---------   ---------
//
//
//                    ---------   ---------
//	             |  B_hi |   |  B_lo |
//	             ---------   ---------
//
//
//        ---------   ---------  
//	 |  C_hi |   |  C_lo |  
//	 ---------   ---------  
//
//      ====================================================
//       ---------   ---------   ---------   ---------
//	 |  S_0  |   |  S_1  |   |  S_2  |   |  S_3  |
//	 ---------   ---------   ---------   ---------
//
//
//
// STEP 2. Get N and f
// -------------------
// 
// Conceptually, after the individual pieces S_0, S_1, ..., are obtained,
// we have to sum them and obtain an integer part, N, and a fraction, f.
// Here, |f| <= 1/2, and N is an integer. Note also that N need only to
// be known to module 2^k, k >= 2. In the case when |f| is small enough,
// we would need to add in the value x*P_4.
// 
// 
// STEP 3. Get reduced argument
// ----------------------------
// 
// The value f is not yet the reduced argument that we seek. The
// equation
// 
// 	x * 2/pi = 4K  + N  + f
// 
// says that
// 
//         x   =  2*K*pi  + N * pi/2  +  f * (pi/2).
// 
// Thus, the reduced argument is given by
// 
// 	reduced argument =  f * pi/2.
// 
// This multiplication must be performed to extra precision.
// 
// IV. Implementation
// ==================
// 
// Step 0. Initialization
// ----------------------
// 
// Set sgn_x := sign(x); x := |x|; x_lo := 2 lsb of x.
// 
// In memory, 2/pi is stored contigously as
// 
//  0x00000000 0x00000000 0xA2F....
//                       ^
//                       |__ implied binary bit
// 
// Given x = 2^m * 1.xxxx...xxx; we calculate L := 62 - m. Thus
// -1 <= L <= -16321. We fetch from memory 5 integer pieces of data.
// 
// P_0 is the two bits corresponding to bit positions L+2 and L+1
// P_1 is the 64-bit starting at bit position  L
// P_2 is the 64-bit starting at bit position  L-64
// P_3 is the 64-bit starting at bit position  L-128
// P_4 is the 64-bit starting at bit position  L-192
// 
// For example, if m = 63, P_0 would be 0 and P_1 would look like
// 0xA2F...
// 
// If m = 65, P_0 would be the two msb of 0xA, thus, P_0 is 10 in binary.
// P_1 in binary would be  1 0 0 0 1 0 1 1 1 1 .... 
//  
// Step 1. Multiplication
// ----------------------
// 
// At this point, P_1, P_2, P_3, P_4 are integers. They are
// supposed to be interpreted as
// 
//  2^(L-63)     * P_1;
//  2^(L-63-64)  * P_2;
//  2^(L-63-128) * P_3;
// 2^(L-63-192) * P_4;
// 
// Since each of them need to be multiplied to x, we would scale
// both x and the P_j's by some convenient factors: scale each
// of P_j's up by 2^(63-L), and scale x down by 2^(L-63).
// 
//   p_1 := fcvt.xf ( P_1 )
//   p_2 := fcvt.xf ( P_2 ) * 2^(-64)
//   p_3 := fcvt.xf ( P_3 ) * 2^(-128)
//   p_4 := fcvt.xf ( P_4 ) * 2^(-192)
//   x   := replace exponent of x by -1
//          because 2^m    * 1.xxxx...xxx  * 2^(L-63)
//          is      2^(-1) * 1.xxxx...xxx
// 
// We are now faced with the task of computing the following
// 
//                     ---------   ---------   ---------
// 	             |  P_1  |   |  P_2  |   |  P_3  |
// 	             ---------   ---------   ---------
// 
//                                             ---------
// 	      X                              |   X   |
// 	                                     ---------
//       ----------------------------------------------------
// 
//                                 ---------   ---------
// 	                         |  A_hi |   |  A_lo |
// 	                         ---------   ---------
// 
//                     ---------   ---------
// 	             |  B_hi |   |  B_lo |
// 	             ---------   ---------
// 
//         ---------   ---------  
// 	 |  C_hi |   |  C_lo |  
// 	 ---------   ---------  
// 
//      ====================================================
//       -----------   ---------   ---------   ---------
//       |    S_0  |   |  S_1  |   |  S_2  |   |  S_3  |
//       -----------   ---------   ---------   ---------
//        ^          ^
//        |          |___ binary point
//        |
//        |___ possibly one more bit
// 
// Let FPSR3 be set to round towards zero with widest precision
// and exponent range. Unless an explicit FPSR is given, 
// round-to-nearest with widest precision and exponent range is
// used.
// 
// Define sigma_C := 2^63; sigma_B := 2^(-1); sigma_C := 2^(-65).
// 
// Tmp_C := fmpy.fpsr3( x, p_1 );
// If Tmp_C >= sigma_C then
//    C_hi := Tmp_C;
//    C_lo := x*p_1 - C_hi ...fma, exact
// Else
//    C_hi := fadd.fpsr3(sigma_C, Tmp_C) - sigma_C
// 			...subtraction is exact, regardless
// 			...of rounding direction
//    C_lo := x*p_1 - C_hi ...fma, exact
// End If
// 
// Tmp_B := fmpy.fpsr3( x, p_2 );
// If Tmp_B >= sigma_B then
//    B_hi := Tmp_B;
//    B_lo := x*p_2 - B_hi ...fma, exact
// Else
//    B_hi := fadd.fpsr3(sigma_B, Tmp_B) - sigma_B
// 			...subtraction is exact, regardless
// 			...of rounding direction
//    B_lo := x*p_2 - B_hi ...fma, exact
// End If
// 
// Tmp_A := fmpy.fpsr3( x, p_3 );
// If Tmp_A >= sigma_A then
//    A_hi := Tmp_A;
//    A_lo := x*p_3 - A_hi ...fma, exact
// Else
//    A_hi := fadd.fpsr3(sigma_A, Tmp_A) - sigma_A
// 			...subtraction is exact, regardless
// 			...of rounding direction
//    A_lo := x*p_3 - A_hi ...fma, exact
// End If
// 
// ...Note that C_hi is of integer value. We need only the
// ...last few bits. Thus we can ensure C_hi is never a big 
// ...integer, freeing us from overflow worry.
// 
// Tmp_C := fadd.fpsr3( C_hi, 2^(70) ) - 2^(70);
// ...Tmp_C is the upper portion of C_hi
// C_hi := C_hi - Tmp_C
// ...0 <= C_hi < 2^7
// 
// Step 2. Get N and f
// -------------------
// 
// At this point, we have all the components to obtain 
// S_0, S_1, S_2, S_3 and thus N and f. We start by adding
// C_lo and B_hi. This sum together with C_hi gives a good
// estimation of N and f. 
// 
// A := fadd.fpsr3( B_hi, C_lo )
// B := max( B_hi, C_lo )
// b := min( B_hi, C_lo )
// 
// a := (B - A) + b	...exact. Note that a is either 0
// 			...or 2^(-64).
// 
// N := round_to_nearest_integer_value( A );
// f := A - N;		...exact because lsb(A) >= 2^(-64)
// 			...and |f| <= 1/2.
// 
// f := f + a		...exact because a is 0 or 2^(-64);
// 			...the msb of the sum is <= 1/2
// 			...lsb >= 2^(-64).
// 
// N := convert to integer format( C_hi + N );
// M := P_0 * x_lo;
// N := N + M;
// 
// If sgn_x == 1 (that is original x was negative)
// N := 2^10 - N
// ...this maintains N to be non-negative, but still
// ...equivalent to the (negated N) mod 4.
// End If
// 
// If |f| >= 2^(-33)
// 
// ...Case 1
// CASE := 1
// g := A_hi + B_lo;
// s_hi := f + g;
// s_lo := (f - s_hi) + g;
// 
// Else
// 
// ...Case 2
// CASE := 2
// A := fadd.fpsr3( A_hi, B_lo )
// B := max( A_hi, B_lo )
// b := min( A_hi, B_lo )
// 
// a := (B - A) + b	...exact. Note that a is either 0
// 			...or 2^(-128).
// 
// f_hi := A + f;
// f_lo := (f - f_hi) + A;
// ...this is exact.
// ...f-f_hi is exact because either |f| >= |A|, in which
// ...case f-f_hi is clearly exact; or otherwise, 0<|f|<|A|
// ...means msb(f) <= msb(A) = 2^(-64) => |f| = 2^(-64).
// ...If f = 2^(-64), f-f_hi involves cancellation and is
// ...exact. If f = -2^(-64), then A + f is exact. Hence
// ...f-f_hi is -A exactly, giving f_lo = 0.
// 
// f_lo := f_lo + a;
// 
// If |f| >= 2^(-50) then
//    s_hi := f_hi;
//    s_lo := f_lo;
// Else
//    f_lo := (f_lo + A_lo) + x*p_4
//    s_hi := f_hi + f_lo
//    s_lo := (f_hi - s_hi) + f_lo
// End If
// 
// End If
// 
// Step 3. Get reduced argument
// ----------------------------
// 
// If sgn_x == 0 (that is original x is positive)
// 
// D_hi := Pi_by_2_hi
// D_lo := Pi_by_2_lo
// ...load from table
// 
// Else
// 
// D_hi := neg_Pi_by_2_hi
// D_lo := neg_Pi_by_2_lo
// ...load from table
// End If
// 
// r_hi :=  s_hi*D_hi
// r_lo :=  s_hi*D_hi - r_hi   	...fma
// r_lo := (s_hi*D_lo + r_lo) + s_lo*D_hi
// 
// Return  CASE, N, r_hi, r_lo
// 
FR_X       = f32 
FR_N       = f33 
FR_p_1     = f34 
FR_TWOM33  = f35 
FR_TWOM50  = f36 
FR_g       = f37 
FR_p_2     = f38 
FR_f       = f39 
FR_s_lo    = f40 
FR_p_3     = f41 
FR_f_abs   = f42 
FR_D_lo    = f43 
FR_p_4     = f44 
FR_D_hi    = f45 
FR_Tmp2_C  = f46 
FR_s_hi    = f47 
FR_sigma_A = f48 
FR_A       = f49 
FR_sigma_B = f50 
FR_B       = f51 
FR_sigma_C = f52 
FR_b       = f53 
FR_ScaleP2 = f54 
FR_ScaleP3 = f55 
FR_ScaleP4 = f56 
FR_Tmp_A   = f57 
FR_Tmp_B   = f58 
FR_Tmp_C   = f59 
FR_A_hi    = f60 
FR_f_hi    = f61 
FR_r_hi    = f62 
FR_A_lo    = f63 
FR_B_hi    = f64 
FR_a       = f65 
FR_B_lo    = f66 
FR_f_lo    = f67
FR_r_lo    = f68 
FR_C_hi    = f69 
FR_C_lo    = f70 

GR_N       = r8
GR_Address_of_Input  = r32 
GR_Address_of_Outputs = r33 
GR_Exp_x   = r36 
GR_Temp    = r37 
GR_BIASL63 = r38 
GR_CASE    = r39
GR_x_lo    = r40 
GR_sgn_x   = r41 
GR_M       = r42
GR_BASE    = r43
GR_LENGTH1 = r44
GR_LENGTH2 = r45
GR_ASUB    = r46
GR_P_0     = r47
GR_P_1     = r48 
GR_P_2     = r49 
GR_P_3     = r50 
GR_P_4     = r51 
GR_START   = r52
GR_SEGMENT = r53
GR_A       = r54
GR_B       = r55 
GR_C       = r56
GR_D       = r57
GR_E       = r58
GR_TEMP1   = r59 
GR_TEMP2   = r60 
GR_TEMP3   = r61 
GR_TEMP4   = r62 
GR_TEMP5   = r63
GR_TEMP6   = r64

.align 64

.data

Constants_Bits_of_2_by_pi:
data8 0x0000000000000000,0xA2F9836E4E441529
data8 0xFC2757D1F534DDC0,0xDB6295993C439041
data8 0xFE5163ABDEBBC561,0xB7246E3A424DD2E0
data8 0x06492EEA09D1921C,0xFE1DEB1CB129A73E
data8 0xE88235F52EBB4484,0xE99C7026B45F7E41
data8 0x3991D639835339F4,0x9C845F8BBDF9283B
data8 0x1FF897FFDE05980F,0xEF2F118B5A0A6D1F
data8 0x6D367ECF27CB09B7,0x4F463F669E5FEA2D
data8 0x7527BAC7EBE5F17B,0x3D0739F78A5292EA
data8 0x6BFB5FB11F8D5D08,0x56033046FC7B6BAB
data8 0xF0CFBC209AF4361D,0xA9E391615EE61B08
data8 0x6599855F14A06840,0x8DFFD8804D732731
data8 0x06061556CA73A8C9,0x60E27BC08C6B47C4
data8 0x19C367CDDCE8092A,0x8359C4768B961CA6
data8 0xDDAF44D15719053E,0xA5FF07053F7E33E8
data8 0x32C2DE4F98327DBB,0xC33D26EF6B1E5EF8
data8 0x9F3A1F35CAF27F1D,0x87F121907C7C246A
data8 0xFA6ED5772D30433B,0x15C614B59D19C3C2
data8 0xC4AD414D2C5D000C,0x467D862D71E39AC6
data8 0x9B0062337CD2B497,0xA7B4D55537F63ED7
data8 0x1810A3FC764D2A9D,0x64ABD770F87C6357
data8 0xB07AE715175649C0,0xD9D63B3884A7CB23
data8 0x24778AD623545AB9,0x1F001B0AF1DFCE19
data8 0xFF319F6A1E666157,0x9947FBACD87F7EB7
data8 0x652289E83260BFE6,0xCDC4EF09366CD43F
data8 0x5DD7DE16DE3B5892,0x9BDE2822D2E88628
data8 0x4D58E232CAC616E3,0x08CB7DE050C017A7
data8 0x1DF35BE01834132E,0x6212830148835B8E
data8 0xF57FB0ADF2E91E43,0x4A48D36710D8DDAA
data8 0x425FAECE616AA428,0x0AB499D3F2A6067F
data8 0x775C83C2A3883C61,0x78738A5A8CAFBDD7
data8 0x6F63A62DCBBFF4EF,0x818D67C12645CA55
data8 0x36D9CAD2A8288D61,0xC277C9121426049B
data8 0x4612C459C444C5C8,0x91B24DF31700AD43
data8 0xD4E5492910D5FDFC,0xBE00CC941EEECE70
data8 0xF53E1380F1ECC3E7,0xB328F8C79405933E
data8 0x71C1B3092EF3450B,0x9C12887B20AB9FB5
data8 0x2EC292472F327B6D,0x550C90A7721FE76B
data8 0x96CB314A1679E279,0x4189DFF49794E884
data8 0xE6E29731996BED88,0x365F5F0EFDBBB49A
data8 0x486CA46742727132,0x5D8DB8159F09E5BC
data8 0x25318D3974F71C05,0x30010C0D68084B58
data8 0xEE2C90AA4702E774,0x24D6BDA67DF77248
data8 0x6EEF169FA6948EF6,0x91B45153D1F20ACF
data8 0x3398207E4BF56863,0xB25F3EDD035D407F
data8 0x8985295255C06437,0x10D86D324832754C
data8 0x5BD4714E6E5445C1,0x090B69F52AD56614
data8 0x9D072750045DDB3B,0xB4C576EA17F9877D
data8 0x6B49BA271D296996,0xACCCC65414AD6AE2
data8 0x9089D98850722CBE,0xA4049407777030F3
data8 0x27FC00A871EA49C2,0x663DE06483DD9797
data8 0x3FA3FD94438C860D,0xDE41319D39928C70
data8 0xDDE7B7173BDF082B,0x3715A0805C93805A
data8 0x921110D8E80FAF80,0x6C4BFFDB0F903876
data8 0x185915A562BBCB61,0xB989C7BD401004F2
data8 0xD2277549F6B6EBBB,0x22DBAA140A2F2689
data8 0x768364333B091A94,0x0EAA3A51C2A31DAE
data8 0xEDAF12265C4DC26D,0x9C7A2D9756C0833F
data8 0x03F6F0098C402B99,0x316D07B43915200C
data8 0x5BC3D8C492F54BAD,0xC6A5CA4ECD37A736
data8 0xA9E69492AB6842DD,0xDE6319EF8C76528B
data8 0x6837DBFCABA1AE31,0x15DFA1AE00DAFB0C
data8 0x664D64B705ED3065,0x29BF56573AFF47B9
data8 0xF96AF3BE75DF9328,0x3080ABF68C6615CB
data8 0x040622FA1DE4D9A4,0xB33D8F1B5709CD36
data8 0xE9424EA4BE13B523,0x331AAAF0A8654FA5
data8 0xC1D20F3F0BCD785B,0x76F923048B7B7217
data8 0x8953A6C6E26E6F00,0xEBEF584A9BB7DAC4
data8 0xBA66AACFCF761D02,0xD12DF1B1C1998C77
data8 0xADC3DA4886A05DF7,0xF480C62FF0AC9AEC
data8 0xDDBC5C3F6DDED01F,0xC790B6DB2A3A25A3
data8 0x9AAF009353AD0457,0xB6B42D297E804BA7
data8 0x07DA0EAA76A1597B,0x2A12162DB7DCFDE5
data8 0xFAFEDB89FDBE896C,0x76E4FCA90670803E
data8 0x156E85FF87FD073E,0x2833676186182AEA
data8 0xBD4DAFE7B36E6D8F,0x3967955BBF3148D7
data8 0x8416DF30432DC735,0x6125CE70C9B8CB30
data8 0xFD6CBFA200A4E46C,0x05A0DD5A476F21D2
data8 0x1262845CB9496170,0xE0566B0152993755
data8 0x50B7D51EC4F1335F,0x6E13E4305DA92E85
data8 0xC3B21D3632A1A4B7,0x08D4B1EA21F716E4
data8 0x698F77FF2780030C,0x2D408DA0CD4F99A5
data8 0x20D3A2B30A5D2F42,0xF9B4CBDA11D0BE7D
data8 0xC1DB9BBD17AB81A2,0xCA5C6A0817552E55
data8 0x0027F0147F8607E1,0x640B148D4196DEBE
data8 0x872AFDDAB6256B34,0x897BFEF3059EBFB9
data8 0x4F6A68A82A4A5AC4,0x4FBCF82D985AD795
data8 0xC7F48D4D0DA63A20,0x5F57A4B13F149538
data8 0x800120CC86DD71B6,0xDEC9F560BF11654D
data8 0x6B0701ACB08CD0C0,0xB24855510EFB1EC3
data8 0x72953B06A33540C0,0x7BDC06CC45E0FA29
data8 0x4EC8CAD641F3E8DE,0x647CD8649B31BED9
data8 0xC397A4D45877C5E3,0x6913DAF03C3ABA46
data8 0x18465F7555F5BDD2,0xC6926E5D2EACED44
data8 0x0E423E1C87C461E9,0xFD29F3D6E7CA7C22
data8 0x35916FC5E0088DD7,0xFFE26A6EC6FDB0C1
data8 0x0893745D7CB2AD6B,0x9D6ECD7B723E6A11
data8 0xC6A9CFF7DF7329BA,0xC9B55100B70DB2E2
data8 0x24BA74607DE58AD8,0x742C150D0C188194
data8 0x667E162901767A9F,0xBEFDFDEF4556367E
data8 0xD913D9ECB9BA8BFC,0x97C427A831C36EF1
data8 0x36C59456A8D8B5A8,0xB40ECCCF2D891234
data8 0x576F89562CE3CE99,0xB920D6AA5E6B9C2A
data8 0x3ECC5F114A0BFDFB,0xF4E16D3B8E2C86E2
data8 0x84D4E9A9B4FCD1EE,0xEFC9352E61392F44
data8 0x2138C8D91B0AFC81,0x6A4AFBD81C2F84B4
data8 0x538C994ECC2254DC,0x552AD6C6C096190B
data8 0xB8701A649569605A,0x26EE523F0F117F11
data8 0xB5F4F5CBFC2DBC34,0xEEBC34CC5DE8605E
data8 0xDD9B8E67EF3392B8,0x17C99B5861BC57E1
data8 0xC68351103ED84871,0xDDDD1C2DA118AF46
data8 0x2C21D7F359987AD9,0xC0549EFA864FFC06
data8 0x56AE79E536228922,0xAD38DC9367AAE855
data8 0x3826829BE7CAA40D,0x51B133990ED7A948
data8 0x0569F0B265A7887F,0x974C8836D1F9B392
data8 0x214A827B21CF98DC,0x9F405547DC3A74E1
data8 0x42EB67DF9DFE5FD4,0x5EA4677B7AACBAA2
data8 0xF65523882B55BA41,0x086E59862A218347
data8 0x39E6E389D49EE540,0xFB49E956FFCA0F1C
data8 0x8A59C52BFA94C5C1,0xD3CFC50FAE5ADB86
data8 0xC5476243853B8621,0x94792C8761107B4C
data8 0x2A1A2C8012BF4390,0x2688893C78E4C4A8
data8 0x7BDBE5C23AC4EAF4,0x268A67F7BF920D2B
data8 0xA365B1933D0B7CBD,0xDC51A463DD27DDE1
data8 0x6919949A9529A828,0xCE68B4ED09209F44
data8 0xCA984E638270237C,0x7E32B90F8EF5A7E7
data8 0x561408F1212A9DB5,0x4D7E6F5119A5ABF9
data8 0xB5D6DF8261DD9602,0x36169F3AC4A1A283
data8 0x6DED727A8D39A9B8,0x825C326B5B2746ED
data8 0x34007700D255F4FC,0x4D59018071E0E13F
data8 0x89B295F364A8F1AE,0xA74B38FC4CEAB2BB

Constants_Bits_of_pi_by_2:
data4 0x2168C234,0xC90FDAA2,0x00003FFF,0x00000000
data4 0x80DC1CD1,0xC4C6628B,0x00003FBF,0x00000000

.section .text
.proc __libm_pi_by_2_reduce#
.global __libm_pi_by_2_reduce#
.align 64 

__libm_pi_by_2_reduce: 

//    X is at the address in Address_of_Input
//    Place the two-piece result at the address in Address_of_Outputs
//    r followed by c
//    N is returned

{ .mmf
alloc  r34 = ar.pfs,2,34,0,0
      ldfe  FR_X = [GR_Address_of_Input]
      fsetc.s3 0x00,0x7F ;;
}
{ .mlx
	nop.m 999
      movl GR_BIASL63 = 0x1003E
}
;;


//    L         -1-2-3-4
//    0 0 0 0 0. 1 0 1 0
//    M          0 1 2 .... 63, 64 65 ... 127, 128
//     ---------------------------------------------
//    Segment 0.        1     ,      2       ,    3
//    START = M - 63                        M = 128 becomes 65
//    LENGTH1  = START & 0x3F               65 become position 1
//    SEGMENT  = shr(START,6) + 1      0 maps to 1,   64 maps to 2,
//    LENGTH2  = 64 - LENGTH1
//    Address_BASE = shladd(SEGMENT,3) + BASE



{ .mmi
      nop.m 999
      addl           GR_BASE   = @ltoff(Constants_Bits_of_2_by_pi#), gp
      nop.i 999
}
;;

{ .mmi
      ld8 GR_BASE = [GR_BASE]
      nop.m 999
      nop.i 999
}
;;


{ .mlx
	nop.m 999
      movl GR_TEMP5 = 0x000000000000FFFE
}
{ .mmi
	nop.m 999 ;;
      setf.exp FR_sigma_B = GR_TEMP5
	nop.i 999
}
{ .mlx
	nop.m 999
      movl GR_TEMP6 = 0x000000000000FFBE ;;
}
//    Define sigma_C := 2^63; sigma_B := 2^(-1); sigma_A := 2^(-65).
{ .mfi
      setf.exp FR_sigma_A = GR_TEMP6
	nop.f 999
	nop.i 999 ;;
}
//    Special Code for testing DE arguments 
//          movl GR_BIASL63 = 0x0000000000013FFE
//          movl GR_x_lo = 0xFFFFFFFFFFFFFFFF
//          setf.exp FR_X = GR_BIASL63
//          setf.sig FR_ScaleP3 = GR_x_lo
//          fmerge.se FR_X = FR_X,FR_ScaleP3
//    Set sgn_x := sign(x); x := |x|; x_lo := 2 lsb of x.
//    2/pi is stored contigously as
//    0x00000000 0x00000000.0xA2F....
//    M = EXP - BIAS  ( M >= 63)
//    Given x = 2^m * 1.xxxx...xxx; we calculate L := 62 - m.
//    Thus -1 <= L <= -16321.
{ .mmf
      getf.exp GR_Exp_x = FR_X
      getf.sig GR_x_lo = FR_X
      fabs FR_X = FR_X ;;
}
{ .mii
      and  GR_x_lo = 0x03,GR_x_lo
      extr.u GR_M = GR_Exp_x,0,17 ;;
      sub  GR_START = GR_M,GR_BIASL63
}
{ .mmi
	nop.m 999 ;;
      and  GR_LENGTH1 = 0x3F,GR_START
      shr.u  GR_SEGMENT = GR_START,6
}
{ .mmi
	nop.m 999 ;;
      add  GR_SEGMENT = 0x1,GR_SEGMENT
      sub  GR_LENGTH2 = 0x40,GR_LENGTH1
}
//    P_0 is the two bits corresponding to bit positions L+2 and L+1
//    P_1 is the 64-bit starting at bit position  L
//    P_2 is the 64-bit starting at bit position  L-64
//    P_3 is the 64-bit starting at bit position  L-128
//    P_4 is the 64-bit starting at bit position  L-192
//    P_1 is made up of Alo and Bhi
//    P_1 = deposit Alo, position 0, length2  into P_1,position length1
//          deposit Bhi, position length2, length1 into P_1, position 0
//    P_2 is made up of Blo and Chi
//    P_2 = deposit Blo, position 0, length2  into P_2, position length1
//          deposit Chi, position length2, length1 into P_2, position 0
//    P_3 is made up of Clo and Dhi
//    P_3 = deposit Clo, position 0, length2  into P_3, position length1
//          deposit Dhi, position length2, length1 into P_3, position 0
//    P_4 is made up of Clo and Dhi
//    P_4 = deposit Dlo, position 0, length2  into P_4, position length1
//          deposit Ehi, position length2, length1 into P_4, position 0
{ .mmi
      cmp.le.unc p6,p7 = 0x2,GR_LENGTH1 ;;
      shladd GR_BASE = GR_SEGMENT,3,GR_BASE
(p7)  cmp.eq.unc p8,p9 = 0x1,GR_LENGTH1 ;;
}
{ .mmi
	nop.m 999
//    ld_64 A at Base and increment Base by 8
//    ld_64 B at Base and increment Base by 8
//    ld_64 C at Base and increment Base by 8
//    ld_64 D at Base and increment Base by 8
//    ld_64 E at Base and increment Base by 8
//                                          A/B/C/D
//                                    ---------------------
//    A, B, C, D, and E look like    | length1 | length2   |
//                                    ---------------------
//                                       hi        lo
      ld8 GR_A = [GR_BASE],8
      extr.u GR_sgn_x = GR_Exp_x,17,1 ;;
}
{ .mmf
	nop.m 999
      ld8 GR_B = [GR_BASE],8
      fmerge.se FR_X = FR_sigma_B,FR_X ;;
}
{ .mii
      ld8 GR_C = [GR_BASE],8
(p8)  extr.u GR_Temp = GR_A,63,1 ;;
      shl GR_TEMP1 = GR_A,GR_LENGTH1
}
{ .mii
      ld8 GR_D = [GR_BASE],8
//    If length1 >= 2,
//       P_0 = deposit Ahi, position length2, 2 bit into P_0 at position 0.
(p6)     shr.u GR_P_0 = GR_A,GR_LENGTH2 ;;
      shl GR_TEMP2 = GR_B,GR_LENGTH1
}
{ .mii
      ld8 GR_E = [GR_BASE],-40
      shr.u GR_P_1 = GR_B,GR_LENGTH2 ;;
      shr.u GR_P_2 = GR_C,GR_LENGTH2
}
//    Else
//       Load 16 bit of ASUB from (Base_Address_of_A - 2)
//       P_0 = ASUB & 0x3
//       If length1 == 0,
//          P_0 complete
//       Else
//          Deposit element 63 from Ahi and place in element 0 of P_0.
//       Endif
//    Endif
{ .mii
(p7)  ld2 GR_ASUB = [GR_BASE],8
      shl GR_TEMP3 = GR_C,GR_LENGTH1 ;;
      shl GR_TEMP4 = GR_D,GR_LENGTH1
}
{ .mii
	nop.m 999
      shr.u GR_P_3 = GR_D,GR_LENGTH2 ;;
      shr.u GR_P_4 = GR_E,GR_LENGTH2
}
{ .mii
(p7)  and GR_P_0 = 0x03,GR_ASUB
(p6)     and GR_P_0 = 0x03,GR_P_0 ;;
      or GR_P_1 = GR_P_1,GR_TEMP1
}
{ .mmi
(p8)  and GR_P_0 = 0x1,GR_P_0 ;;
      or GR_P_2 = GR_P_2,GR_TEMP2
(p8)  shl GR_P_0 = GR_P_0,0x1 ;;
}
{ .mii
	nop.m 999
      or GR_P_3 = GR_P_3,GR_TEMP3
(p8)  or GR_P_0 = GR_P_0,GR_Temp
}
{ .mmi
      setf.sig FR_p_1 = GR_P_1 ;;
      setf.sig FR_p_2 = GR_P_2
      or GR_P_4 = GR_P_4,GR_TEMP4 ;;
}
{ .mmi
	nop.m 999 ;;
      setf.sig FR_p_3 = GR_P_3
      pmpy2.r GR_M = GR_P_0,GR_x_lo
}
{ .mlx
      setf.sig FR_p_4 = GR_P_4
//    P_1, P_2, P_3, P_4 are integers. They should be
//    2^(L-63)     * P_1;
//    2^(L-63-64)  * P_2;
//    2^(L-63-128) * P_3;
//    2^(L-63-192) * P_4;
//    Since each of them need to be multiplied to x, we would scale
//    both x and the P_j's by some convenient factors: scale each
//    of P_j's up by 2^(63-L), and scale x down by 2^(L-63).
//    p_1 := fcvt.xf ( P_1 )
//    p_2 := fcvt.xf ( P_2 ) * 2^(-64)
//    p_3 := fcvt.xf ( P_3 ) * 2^(-128)
//    p_4 := fcvt.xf ( P_4 ) * 2^(-192)
//    x= Set x's exp to -1 because 2^m*1.x...x *2^(L-63)=2^(-1)*1.x...xxx
//             ---------   ---------   ---------
//             |  P_1  |   |  P_2  |   |  P_3  |
//             ---------   ---------   ---------
//                                           ---------
//	      X                              |   X   |
//	                                     ---------
//      ----------------------------------------------------
//                               ---------   ---------
//	                         |  A_hi |   |  A_lo |
//	                         ---------   ---------
//                   ---------   ---------
//	             |  B_hi |   |  B_lo |
//	             ---------   ---------
//       ---------   ---------
//	 |  C_hi |   |  C_lo |
//	 ---------   ---------
//     ====================================================
//    -----------   ---------   ---------   ---------
//    |    S_0  |   |  S_1  |   |  S_2  |   |  S_3  |
//    -----------   ---------   ---------   ---------
//    |            |___ binary point
//    |___ possibly one more bit
//
//    Let FPSR3 be set to round towards zero with widest precision
//    and exponent range. Unless an explicit FPSR is given,
//    round-to-nearest with widest precision and exponent range is
//    used.
      movl GR_TEMP1 = 0x000000000000FFBF
}
{ .mmi
	nop.m 999 ;;
      setf.exp FR_ScaleP2 = GR_TEMP1
	nop.i 999
}
{ .mlx
	nop.m 999
      movl GR_TEMP4 = 0x000000000001003E
}
{ .mmi
	nop.m 999 ;;
      setf.exp FR_sigma_C = GR_TEMP4
	nop.i 999
}
{ .mlx
	nop.m 999
      movl GR_TEMP2 = 0x000000000000FF7F ;;
}
{ .mmf
	nop.m 999
      setf.exp FR_ScaleP3 = GR_TEMP2
      fcvt.xuf.s1 FR_p_1 = FR_p_1 ;;
}
{ .mfi
	nop.m 999
      fcvt.xuf.s1 FR_p_2 = FR_p_2
	nop.i 999
}
{ .mlx
	nop.m 999
      movl GR_Temp = 0x000000000000FFDE ;;
}
{ .mmf
	nop.m 999
      setf.exp FR_TWOM33 = GR_Temp
      fcvt.xuf.s1 FR_p_3 = FR_p_3 ;;
}
{ .mfi
	nop.m 999
      fcvt.xuf.s1 FR_p_4 = FR_p_4
	nop.i 999 ;;
}
{ .mfi
	nop.m 999
//    Tmp_C := fmpy.fpsr3( x, p_1 );
//    Tmp_B := fmpy.fpsr3( x, p_2 );
//    Tmp_A := fmpy.fpsr3( x, p_3 );
//    If Tmp_C >= sigma_C then
//      C_hi := Tmp_C;
//      C_lo := x*p_1 - C_hi ...fma, exact
//    Else
//      C_hi := fadd.fpsr3(sigma_C, Tmp_C) - sigma_C
//      C_lo := x*p_1 - C_hi ...fma, exact
//    End If
//    If Tmp_B >= sigma_B then
//      B_hi := Tmp_B;
//      B_lo := x*p_2 - B_hi ...fma, exact
//    Else
//      B_hi := fadd.fpsr3(sigma_B, Tmp_B) - sigma_B
//      B_lo := x*p_2 - B_hi ...fma, exact
//    End If
//    If Tmp_A >= sigma_A then
//      A_hi := Tmp_A;
//      A_lo := x*p_3 - A_hi ...fma, exact
//    Else
//      A_hi := fadd.fpsr3(sigma_A, Tmp_A) - sigma_A
//      Exact, regardless ...of rounding direction
//      A_lo := x*p_3 - A_hi ...fma, exact
//    Endif
      fmpy.s3 FR_Tmp_C = FR_X,FR_p_1
	nop.i 999 ;;
}
{ .mfi
	nop.m 999
      fmpy.s1 FR_p_2 = FR_p_2,FR_ScaleP2
	nop.i 999
}
{ .mlx
	nop.m 999
      movl GR_Temp = 0x0000000000000400
}
{ .mlx
	nop.m 999
      movl GR_TEMP3 = 0x000000000000FF3F ;;
}
{ .mmf
	nop.m 999
      setf.exp FR_ScaleP4 = GR_TEMP3
      fmpy.s1 FR_p_3 = FR_p_3,FR_ScaleP3 ;;
}
{ .mlx
	nop.m 999
      movl GR_TEMP4 = 0x0000000000010045 ;;
}
{ .mmf
	nop.m 999
      setf.exp FR_Tmp2_C = GR_TEMP4
      fmpy.s3 FR_Tmp_B = FR_X,FR_p_2 ;;
}
{ .mfi
	nop.m 999
      fcmp.ge.unc.s1 p12,  p9 = FR_Tmp_C,FR_sigma_C
	nop.i 999 ;;
}
{ .mfi
	nop.m 999
      fmpy.s3 FR_Tmp_A = FR_X,FR_p_3
	nop.i 999 ;;
}
{ .mfi
	nop.m 999
(p12) mov FR_C_hi = FR_Tmp_C
	nop.i 999 ;;
}
{ .mfi
      addl           GR_BASE   = @ltoff(Constants_Bits_of_pi_by_2#), gp
(p9)  fadd.s3 FR_C_hi = FR_sigma_C,FR_Tmp_C
	nop.i 999
}
;;



//   End If
//   Step 3. Get reduced argument
//   If sgn_x == 0 (that is original x is positive)
//      D_hi := Pi_by_2_hi
//      D_lo := Pi_by_2_lo
//      Load from table
//   Else
//      D_hi := neg_Pi_by_2_hi
//      D_lo := neg_Pi_by_2_lo
//      Load from table
//   End If


{ .mmi
      ld8 GR_BASE = [GR_BASE]
      nop.m 999
      nop.i 999
}
;;


{ .mfi
     ldfe FR_D_hi = [GR_BASE],16
      fmpy.s1 FR_p_4 = FR_p_4,FR_ScaleP4
	nop.i 999 ;;
}
{ .mfi
     ldfe FR_D_lo = [GR_BASE],0
      fcmp.ge.unc.s1 p13, p10 = FR_Tmp_B,FR_sigma_B
	nop.i 999 ;;
}
{ .mfi
	nop.m 999
(p13) mov FR_B_hi = FR_Tmp_B
	nop.i 999
}
{ .mfi
	nop.m 999
(p12) fms.s1 FR_C_lo = FR_X,FR_p_1,FR_C_hi
	nop.i 999 ;;
}
{ .mfi
	nop.m 999
(p10) fadd.s3 FR_B_hi = FR_sigma_B,FR_Tmp_B
	nop.i 999
}
{ .mfi
	nop.m 999
(p9)  fsub.s1 FR_C_hi = FR_C_hi,FR_sigma_C
	nop.i 999 ;;
}
{ .mfi
	nop.m 999
      fcmp.ge.unc.s1 p14, p11 = FR_Tmp_A,FR_sigma_A
	nop.i 999 ;;
}
{ .mfi
	nop.m 999
(p14) mov FR_A_hi = FR_Tmp_A
	nop.i 999 ;;
}
{ .mfi
	nop.m 999
(p11) fadd.s3 FR_A_hi = FR_sigma_A,FR_Tmp_A
	nop.i 999 ;;
}
{ .mfi
	nop.m 999
(p9)  fms.s1 FR_C_lo = FR_X,FR_p_1,FR_C_hi
      cmp.eq.unc p12,p9 = 0x1,GR_sgn_x
}
{ .mfi
	nop.m 999
(p13) fms.s1 FR_B_lo = FR_X,FR_p_2,FR_B_hi
	nop.i 999 ;;
}
{ .mfi
	nop.m 999
(p10) fsub.s1 FR_B_hi = FR_B_hi,FR_sigma_B
	nop.i 999
}
{ .mfi
	nop.m 999
//    Note that C_hi is of integer value. We need only the
//    last few bits. Thus we can ensure C_hi is never a big
//    integer, freeing us from overflow worry.
//    Tmp_C := fadd.fpsr3( C_hi, 2^(70) ) - 2^(70);
//    Tmp_C is the upper portion of C_hi
      fadd.s3 FR_Tmp_C = FR_C_hi,FR_Tmp2_C
	nop.i 999 ;;
}
{ .mfi
	nop.m 999
(p14) fms.s1 FR_A_lo = FR_X,FR_p_3,FR_A_hi
	nop.i 999
}
{ .mfi
	nop.m 999
(p11) fsub.s1 FR_A_hi = FR_A_hi,FR_sigma_A
	nop.i 999 ;;
}
{ .mfi
	nop.m 999
//    *******************
//    Step 2. Get N and f
//    *******************
//    We have all the components to obtain
//    S_0, S_1, S_2, S_3 and thus N and f. We start by adding
//    C_lo and B_hi. This sum together with C_hi estimates
//    N and f well.
//    A := fadd.fpsr3( B_hi, C_lo )
//    B := max( B_hi, C_lo )
//    b := min( B_hi, C_lo )
      fadd.s3 FR_A = FR_B_hi,FR_C_lo
	nop.i 999
}
{ .mfi
	nop.m 999
(p10) fms.s1 FR_B_lo = FR_X,FR_p_2,FR_B_hi
	nop.i 999 ;;
}
{ .mfi
	nop.m 999
      fsub.s1 FR_Tmp_C = FR_Tmp_C,FR_Tmp2_C
	nop.i 999 ;;
}
{ .mfi
	nop.m 999
      fmax.s1 FR_B = FR_B_hi,FR_C_lo
	nop.i 999 ;;
}
{ .mfi
	nop.m 999
      fmin.s1 FR_b = FR_B_hi,FR_C_lo
	nop.i 999
}
{ .mfi
	nop.m 999
(p11) fms.s1 FR_A_lo = FR_X,FR_p_3,FR_A_hi
	nop.i 999 ;;
}
{ .mfi
	nop.m 999
//    N := round_to_nearest_integer_value( A );
      fcvt.fx.s1 FR_N = FR_A
	nop.i 999 ;;
}
{ .mfi
	nop.m 999
//    C_hi := C_hi - Tmp_C ...0 <= C_hi < 2^7
      fsub.s1 FR_C_hi = FR_C_hi,FR_Tmp_C
	nop.i 999 ;;
}
{ .mfi
	nop.m 999
//    a := (B - A) + b: Exact - note that a is either 0 or 2^(-64).
      fsub.s1 FR_a = FR_B,FR_A
	nop.i 999 ;;
}
{ .mfi
	nop.m 999
//    f := A - N; Exact because lsb(A) >= 2^(-64) and |f| <= 1/2.
      fnorm.s1 FR_N = FR_N
	nop.i 999
}
{ .mfi
	nop.m 999
      fadd.s1 FR_a = FR_a,FR_b
	nop.i 999 ;;
}
{ .mfi
	nop.m 999
      fsub.s1 FR_f = FR_A,FR_N
	nop.i 999
}
{ .mfi
	nop.m 999
//    N := convert to integer format( C_hi + N );
//    M := P_0 * x_lo;
//    N := N + M;
      fadd.s1 FR_N = FR_N,FR_C_hi
	nop.i 999 ;;
}
{ .mfi
	nop.m 999
//    f = f + a	Exact because a is 0 or 2^(-64);
//    the msb of the sum is <= 1/2 and lsb >= 2^(-64).
      fadd.s1 FR_f = FR_f,FR_a
	nop.i 999
}
{ .mfi
	nop.m 999
//
//    Create 2**(-33)
//
      fcvt.fx.s1 FR_N = FR_N
	nop.i 999 ;;
}
{ .mfi
	nop.m 999
      fabs FR_f_abs = FR_f
	nop.i 999 ;;
}
{ .mfi
      getf.sig GR_N = FR_N
	nop.f 999
	nop.i 999 ;;
}
{ .mii
	nop.m 999
	nop.i 999 ;;
      add GR_N = GR_N,GR_M ;;
}
//    If sgn_x == 1 (that is original x was negative)
//       N := 2^10 - N
//       this maintains N to be non-negative, but still
//       equivalent to the (negated N) mod 4.
//    End If
{ .mii
(p12) sub GR_N = GR_Temp,GR_N
     cmp.eq.unc p12,p9 = 0x0,GR_sgn_x ;;
	nop.i 999
}
{ .mfi
	nop.m 999
      fcmp.ge.unc.s1 p13, p10 = FR_f_abs,FR_TWOM33
	nop.i 999 ;;
}
{ .mfi
	nop.m 999
(p9) fsub.s1 FR_D_hi = f0, FR_D_hi
	nop.i 999 ;;
}
{ .mfi
	nop.m 999
(p10)    fadd.s3 FR_A = FR_A_hi,FR_B_lo
	nop.i 999
}
{ .mfi
	nop.m 999
(p13)    fadd.s1 FR_g = FR_A_hi,FR_B_lo
	nop.i 999 ;;
}
{ .mfi
	nop.m 999
(p10)    fmax.s1 FR_B = FR_A_hi,FR_B_lo
	nop.i 999
}
{ .mfi
	nop.m 999
(p9) fsub.s1 FR_D_lo = f0, FR_D_lo
	nop.i 999 ;;
}
{ .mfi
	nop.m 999
(p10)    fmin.s1 FR_b = FR_A_hi,FR_B_lo
	nop.i 999 ;;
}
{ .mfi
	nop.m 999
     fsetc.s3 0x7F,0x40
	nop.i 999
}
{ .mlx
	nop.m 999
(p10)    movl GR_Temp = 0x000000000000FFCD ;;
}
{ .mmf
	nop.m 999
(p10)    setf.exp FR_TWOM50 = GR_Temp
(p10)    fadd.s1 FR_f_hi = FR_A,FR_f ;;
}
{ .mfi
	nop.m 999
//       a := (B - A) + b	Exact.
//       Note that a is either 0 or 2^(-128).
//       f_hi := A + f;
//       f_lo := (f - f_hi) + A
//       f_lo=f-f_hi is exact because either |f| >= |A|, in which
//       case f-f_hi is clearly exact; or otherwise, 0<|f|<|A|
//       means msb(f) <= msb(A) = 2^(-64) => |f| = 2^(-64).
//       If f = 2^(-64), f-f_hi involves cancellation and is
//       exact. If f = -2^(-64), then A + f is exact. Hence
//       f-f_hi is -A exactly, giving f_lo = 0.
//       f_lo := f_lo + a;
(p10)    fsub.s1 FR_a = FR_B,FR_A
	nop.i 999
}
{ .mfi
	nop.m 999
(p13)    fadd.s1 FR_s_hi = FR_f,FR_g
	nop.i 999 ;;
}
{ .mlx
	nop.m 999
//    If |f| >= 2^(-33)
//       Case 1
//       CASE := 1
//       g := A_hi + B_lo;
//       s_hi := f + g;
//       s_lo := (f - s_hi) + g;
(p13)    movl GR_CASE = 0x1 ;;
}
{ .mlx
	nop.m 999
//   Else
//       Case 2
//       CASE := 2
//       A := fadd.fpsr3( A_hi, B_lo )
//       B := max( A_hi, B_lo )
//       b := min( A_hi, B_lo )
(p10)    movl GR_CASE = 0x2
}
{ .mfi
	nop.m 999
(p10)    fsub.s1 FR_f_lo = FR_f,FR_f_hi
	nop.i 999 ;;
}
{ .mfi
	nop.m 999
(p10)    fadd.s1 FR_a = FR_a,FR_b
	nop.i 999
}
{ .mfi
	nop.m 999
(p13)    fsub.s1 FR_s_lo = FR_f,FR_s_hi
	nop.i 999 ;;
}
{ .mfi
	nop.m 999
(p13)    fadd.s1 FR_s_lo = FR_s_lo,FR_g
	nop.i 999 ;;
}
{ .mfi
	nop.m 999
(p10)    fcmp.ge.unc.s1 p14, p11 = FR_f_abs,FR_TWOM50
	nop.i 999 ;;
}
{ .mfi
	nop.m 999
//
//       Create 2**(-50)
(p10)    fadd.s1 FR_f_lo = FR_f_lo,FR_A
	nop.i 999 ;;
}
{ .mfi
	nop.m 999
//       If |f| >= 2^(-50) then
//          s_hi := f_hi;
//          s_lo := f_lo;
//       Else
//          f_lo := (f_lo + A_lo) + x*p_4
//          s_hi := f_hi + f_lo
//          s_lo := (f_hi - s_hi) + f_lo
//       End If
(p14)  mov FR_s_hi = FR_f_hi
	nop.i 999 ;;
}
{ .mfi
	nop.m 999
(p10)    fadd.s1 FR_f_lo = FR_f_lo,FR_a
	nop.i 999 ;;
}
{ .mfi
	nop.m 999
(p14)  mov FR_s_lo = FR_f_lo
	nop.i 999
}
{ .mfi
	nop.m 999
(p11)  fadd.s1 FR_f_lo = FR_f_lo,FR_A_lo
	nop.i 999 ;;
}
{ .mfi
	nop.m 999
(p11)  fma.s1 FR_f_lo = FR_X,FR_p_4,FR_f_lo
	nop.i 999 ;;
}
{ .mfi
	nop.m 999
(p11)  fadd.s1 FR_s_hi = FR_f_hi,FR_f_lo
	nop.i 999 ;;
}
{ .mfi
	nop.m 999
//   r_hi :=  s_hi*D_hi
//   r_lo :=  s_hi*D_hi - r_hi  with fma
//   r_lo := (s_hi*D_lo + r_lo) + s_lo*D_hi
     fmpy.s1 FR_r_hi = FR_s_hi,FR_D_hi
	nop.i 999
}
{ .mfi
	nop.m 999
(p11)  fsub.s1 FR_s_lo = FR_f_hi,FR_s_hi
	nop.i 999 ;;
}
{ .mfi
	nop.m 999
     fms.s1 FR_r_lo = FR_s_hi,FR_D_hi,FR_r_hi
	nop.i 999
}
{ .mfi
	nop.m 999
(p11)  fadd.s1 FR_s_lo = FR_s_lo,FR_f_lo
	nop.i 999 ;;
}
{ .mmi
	nop.m 999 ;;
//   Return  N, r_hi, r_lo
//   We do not return CASE
     stfe [GR_Address_of_Outputs] = FR_r_hi,16
	nop.i 999 ;;
}
{ .mfi
	nop.m 999
     fma.s1 FR_r_lo = FR_s_hi,FR_D_lo,FR_r_lo
	nop.i 999 ;;
}
{ .mfi
	nop.m 999
     fma.s1 FR_r_lo = FR_s_lo,FR_D_hi,FR_r_lo
	nop.i 999 ;;
}
{ .mmi
	nop.m 999 ;;
     stfe [GR_Address_of_Outputs] = FR_r_lo,-16
	nop.i 999
}
{ .mib
	nop.m 999
	nop.i 999
     br.ret.sptk   b0 ;;
}

.endp __libm_pi_by_2_reduce
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\ia64\logb.s ===
.file "logb.s"

// Copyright (c) 2000, 2001, Intel Corporation
// All rights reserved.
// 
// Contributed 2/2/2000 by John Harrison, Ted Kubaska, Bob Norin, Shane Story,
// and Ping Tak Peter Tang of the Computational Software Lab, Intel Corporation.
// 
// WARRANTY DISCLAIMER
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS 
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY 
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
// 
// Intel Corporation is the author of this code, and requests that all
// problem reports or change requests be submitted to it directly at 
// http://developer.intel.com/opensource.
//
// History
//==============================================================
// 2/02/00  Initial version
// 2/16/00  Modified to conform to C9X 
// 3/16/00  Improved speed
// 4/04/00  Unwind support added
// 5/30/00  Fixed bug when x double-extended denormal
// 8/15/00  Bundle added after call to __libm_error_support to properly
//          set [the previously overwritten] GR_Parameter_RESULT.
//
// API
//==============================================================
// double _logb( double x);
//
// Overview of operation
//==============================================================
// The logb function extracts the exponent of x as an integer in 
// floating-point format. 
// logb computes log2 of x as a double
//
// logb is similar to ilogb but differs in the  following ways:
//         +-inf
//            ilogb: returns INT_MAX
//             logb: returns +inf
//         Nan  returns FP_LOGBNAN (which is either INT_MAX or INT_MIN)
//            ilogb: returns INT_MAX (7fffffff)
//             logb: returns QNAN (quietized SNAN)
//         0    returns FP_ILOGB0 (which is either INT_MIN or -INT_MAX)
//            ilogb: returns -INT_MAX (80000001)
//             logb: returns -inf, raises the divide-by-zero exception,
//                   and calls libm_error_support to set domain error
//
// Registers used
//==============================================================
// general registers used: 
// ar.pfs r32 
// r33 -> r37
// r38 -> r41 used as parameters to error path
//
// predicate registers used: 
// p6, p7, p8
// floating-point registers used: 
// f9, f10, f11
// f8, input

GR_SAVE_B0          = r34
GR_SAVE_GP          = r35
GR_SAVE_PFS         = r32

GR_Parameter_X      = r38
GR_Parameter_Y      = r39
GR_Parameter_RESULT = r40

.align 32
.global _logb#

.section .text
.proc  _logb#
.align 32


_logb: 

// qnan snan inf norm     unorm 0 -+
// 0    0    0   0        1     0 11
// 0                      b
{ .mfi
      alloc          r32=ar.pfs,1,5,4,0
      fclass.m.unc  p8,p0 = f8, 0x0b
      nop.i 999
}
// X NORMAL
// r37 = exp(f8) - - 0xffff
// sig(f8) = r37
// f8 = convert_to_fp (sig))
{ .mfi
      getf.exp      r35 = f8
      fnorm         f10=f8
      nop.i 999 ;;
}

// qnan snan inf norm     unorm 0 -+
// 1    1    1   0        0     0 11
// e                      3
{ .mmf
      mov      r33 = 0xffff
      mov      r34 = 0x1ffff
      fclass.m.unc  p6,p0 = f8, 0xe3 ;;
}

{ .mfb
      and           r36 = r35, r34
      fclass.m.unc  p7,p0 = f8, 0x07
(p8)  br.cond.spnt  LOGB_DENORM ;;
}

{ .mib
      sub           r37 = r36, r33
      nop.i 999
(p6)  br.cond.spnt  LOGB_NAN_INF ;;
}

{ .mib
      setf.sig      f9  = r37
      nop.i 999
(p7)  br.cond.spnt  LOGB_ZERO ;;
}

{ .mfi
      nop.m 999
      fcvt.xf       f10 = f9
      nop.i 999 ;;
}

{ .mfb
      nop.m 999
      fnorm.d       f8 = f10
      br.ret.sptk    b0 ;;
}

LOGB_DENORM:
// Form signexp of 2^64 in case need to scale denormal
// Check to see if double-extended denormal
{ .mfi
      mov r38 = 0x1003f
      fclass.m.unc  p8,p0 = f10, 0x0b
      nop.i 999 ;;
}

// Form 2^64 in case need to scale denormal
{ .mfi
      setf.exp f11 = r38
      nop.f 999
      nop.i 999 ;;
}

// If double-extended denormal add 64 to exponent bias for scaling
// If double-extended denormal form x * 2^64 which is normal
{ .mfi
(p8)  add r33 = 64, r33
(p8)  fmpy f10 = f10, f11    
      nop.i 999 ;;
}

// Logic is the same as normal path but use normalized input
{ .mmi
      getf.exp      r35 = f10 ;;
      nop.m 999
      nop.i 999 ;;
}

{ .mmi
      and           r36 = r35, r34 ;;
      sub           r37 = r36, r33
      nop.i 999 ;;
}

{ .mmi
      setf.sig      f9  = r37
      nop.m 999
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
      fcvt.xf       f10 = f9
      nop.i 999 ;;
}

{ .mfb
      nop.m 999
      fnorm.d       f8 = f10
      br.ret.sptk    b0 ;;
}

LOGB_NAN_INF: 

// X NAN or INFINITY, return f8 * f8
{ .mfb
      nop.m 999
      fma.d      f8= f8,f8,f0
      br.ret.sptk   b0 ;;
}

.endp _logb#

// Stack operations when calling error support.
//       (1)               (2)                          (3) (call)              (4)
//   sp   -> +          psp -> +                     psp -> +                   sp -> +
//           |                 |                            |                         |
//           |                 | <- GR_Y               R3 ->| <- GR_RESULT            | -> f8
//           |                 |                            |                         |
//           | <-GR_Y      Y2->|                       Y2 ->| <- GR_Y                 |
//           |                 |                            |                         |
//           |                 | <- GR_X               X1 ->|                         |
//           |                 |                            |                         |
//  sp-64 -> +          sp ->  +                     sp ->  +                         +
//    save ar.pfs          save b0                                               restore gp
//    save gp                                                                    restore ar.pfs



.proc __libm_error_region
__libm_error_region:
LOGB_ZERO: 
.prologue

// f9  = |f8|
// f10 = -f9 = -|f8|
// f9  = 1.0/f10 = -1.0/-|f8|

{ .mfi 
      mov           r41 = 151      // Error code
      fmerge.s      f9 = f0,f8
      nop.i 999
}
;;


{ .mfi
      nop.m 999
      fmerge.ns     f10 = f0,f9
      nop.i 999
}
;;

// (1)
{ .mfi
        add   GR_Parameter_Y=-32,sp             // Parameter 2 value
        frcpa         f9,p6 = f1,f10
.save   ar.pfs,GR_SAVE_PFS
        mov  GR_SAVE_PFS=ar.pfs                 // Save ar.pfs
}
{ .mfi
.fframe 64
        add sp=-64,sp                          // Create new stack
        nop.f 0
        mov GR_SAVE_GP=gp                      // Save gp
};;


// (2)
{ .mmi
        stfd [GR_Parameter_Y] = f0,16         // STORE Parameter 2 on stack
        add GR_Parameter_X    = 16,sp         // Parameter 1 address
.save   b0, GR_SAVE_B0
        mov GR_SAVE_B0=b0                     // Save b0
};;

.body
// (3)
{ .mib
        stfd [GR_Parameter_X] = f8            // STORE Parameter 1 on stack
        add   GR_Parameter_RESULT = 0,GR_Parameter_Y    // Parameter 3 address
        nop.b 0                                         
}
{ .mib
        stfd [GR_Parameter_Y] = f9            // Store Parameter 3 on stack
        add   GR_Parameter_Y = -16,GR_Parameter_Y
        br.call.sptk b0=__libm_error_support# // Call error handling function
};;
{ .mmi
        nop.m 0
        nop.m 0
        add   GR_Parameter_RESULT = 48,sp
};;

// (4)
{ .mmi
        ldfd  f8 = [GR_Parameter_RESULT]       // Get return result off stack
.restore
        add   sp = 64,sp                       // Restore stack pointer
        mov   b0 = GR_SAVE_B0                  // Restore return address
};;
{ .mib
        mov   gp = GR_SAVE_GP                  // Restore gp
        mov   ar.pfs = GR_SAVE_PFS             // Restore ar.pfs
        br.ret.sptk   b0
};;

.endp __libm_error_region


.type   __libm_error_support#,@function
.global __libm_error_support#
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\ia64\libm_support.h ===
//  
// Copyright (c) 2000, Intel Corporation
// All rights reserved.
//
// Contributed 2/2/2000 by John Harrison, Ted Kubaska, Bob Norin, Shane Story, 
// and Ping Tak Peter Tang of the Computational Software Lab, Intel Corporation.
//
// WARRANTY DISCLAIMER
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS 
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// Intel Corporation is the author of this code, and requests that all
// problem reports or change requests be submitted to it directly at
// http://developer.intel.com/opensource.
//

// History: 02/02/2000 Initial version 
//          2/28/2000 added tags for logb and nextafter
//          3/22/2000 Changes to support _LIB_VERSION variable
//                    and filled some enum gaps. Added support for C99.  
//

#define SIZE_INT_32
#define __MS__

float __libm_frexp_4f( float x, int*  exp);
float __libm_frexp_8f( double x, int*  exp);
double __libm_frexp_4( double x, int*  exp);
double __libm_frexp_8( double x, int*  exp);
void __libm_sincos_pi4(double,double*,double*,int);
void __libm_y0y1(double , double *, double *);
void __libm_j0j1(double , double *, double *);
double __libm_lgamma_kernel(double,int*,int,int);
double __libm_j0(double);
double __libm_j1(double);
double __libm_jn(int,double);
double __libm_y0(double);
double __libm_y1(double);
double __libm_yn(int,double);

extern double rint(double);
extern double sqrt(double);
extern double fabs(double);
extern double log(double);
extern double sin(double);
extern double exp(double);
extern double modf(double, double *);
extern double asinh(double);
extern double acosh(double);
extern double atanh(double);
extern double tanh(double);
extern double erf(double);
extern double erfc(double);
extern double j0(double);
extern double j1(double);
extern double jn(int, double);
extern double y0(double);
extern double y1(double);
extern double yn(int, double);

extern float  fabsf(float);
extern float  asinhf(float);
extern float  acoshf(float);
extern float  atanhf(float);
extern float  tanhf(float);
extern float  erff(float);
extern float  erfcf(float);
extern float  j0f(float);
extern float  j1f(float);
extern float  jnf(int, float);
extern float  y0f(float);
extern float  y1f(float);
extern float  ynf(int, float);

#if !(defined(SIZE_INT_32) || defined(SIZE_INT_64))
    #error integer size not established; define SIZE_INT_32 or SIZE_INT_64
#endif

struct fp64 { /*/ sign:1 exponent:11 significand:52 (implied leading 1)*/
  unsigned lo_significand:32;
  unsigned hi_significand:20;
  unsigned exponent:11;
  unsigned sign:1;
};

#define HI_SIGNIFICAND_LESS(X, HI) ((X)->hi_significand < 0x ## HI)
#define f64abs(x) ((x) < 0.0 ? -(x) : (x))

typedef enum
{
  logl_zero=0,   logl_negative,                  /*  0,  1 */
  log_zero,      log_negative,                   /*  2,  3 */
  logf_zero,     logf_negative,                  /*  4,  5 */
  log10l_zero,   log10l_negative,                /*  6,  7 */
  log10_zero,    log10_negative,                 /*  8,  9 */
  log10f_zero,   log10f_negative,                /* 10, 11 */
  expl_overflow, expl_underflow,                 /* 12, 13 */
  exp_overflow,  exp_underflow,                  /* 14, 15 */
  expf_overflow, expf_underflow,                 /* 16, 17 */
  powl_overflow, powl_underflow,                 /* 18, 19 */
  powl_zero_to_zero,                             /* 20     */
  powl_zero_to_negative,                         /* 21     */
  powl_neg_to_non_integer,                       /* 22     */
  powl_nan_to_zero,                              /* 23     */
  pow_overflow,  pow_underflow,                  /* 24, 25 */
  pow_zero_to_zero,                              /* 26     */ 
  pow_zero_to_negative,                          /* 27     */
  pow_neg_to_non_integer,                        /* 28     */
  pow_nan_to_zero,                               /* 29     */
  powf_overflow, powf_underflow,                 /* 30, 31 */
  powf_zero_to_zero,                             /* 32     */
  powf_zero_to_negative,                         /* 33     */ 
  powf_neg_to_non_integer,                       /* 34     */ 
  powf_nan_to_zero,                              /* 35     */
  atan2l_zero,                                   /* 36     */
  atan2_zero,                                    /* 37     */
  atan2f_zero,                                   /* 38     */
  expm1l_overflow,                               /* 39     */
  expm1l_underflow,                              /* 40     */
  expm1_overflow,                                /* 41     */
  expm1_underflow,                               /* 42     */
  expm1f_overflow,                               /* 43     */
  expm1f_underflow,                              /* 44     */
  hypotl_overflow,                               /* 45     */
  hypot_overflow,                                /* 46     */
  hypotf_overflow,                               /* 47     */
  sqrtl_negative,                                /* 48     */
  sqrt_negative,                                 /* 49     */
  sqrtf_negative,                                /* 50     */
  scalbl_overflow, scalbl_underflow,             /* 51,52  */
  scalb_overflow,  scalb_underflow,              /* 53,54  */
  scalbf_overflow, scalbf_underflow,             /* 55,56  */
  acosl_gt_one, acos_gt_one, acosf_gt_one,       /* 57, 58, 59 */
  asinl_gt_one, asin_gt_one, asinf_gt_one,       /* 60, 61, 62 */
  coshl_overflow, cosh_overflow, coshf_overflow, /* 63, 64, 65 */
  y0l_zero, y0l_negative,y0l_gt_loss,            /* 66, 67, 68 */
  y0_zero, y0_negative,y0_gt_loss,               /* 69, 70, 71 */
  y0f_zero, y0f_negative,y0f_gt_loss,            /* 72, 73, 74 */
  y1l_zero, y1l_negative,y1l_gt_loss,            /* 75, 76, 77 */ 
  y1_zero, y1_negative,y1_gt_loss,               /* 78, 79, 80 */ 
  y1f_zero, y1f_negative,y1f_gt_loss,            /* 81, 82, 83 */ 
  ynl_zero, ynl_negative,ynl_gt_loss,            /* 84, 85, 86 */
  yn_zero, yn_negative,yn_gt_loss,               /* 87, 88, 89 */
  ynf_zero, ynf_negative,ynf_gt_loss,            /* 90, 91, 92 */
  j0l_gt_loss,                                   /* 93 */ 
  j0_gt_loss,                                    /* 94 */
  j0f_gt_loss,                                   /* 95 */
  j1l_gt_loss,                                   /* 96 */
  j1_gt_loss,                                    /* 97 */
  j1f_gt_loss,                                   /* 98 */
  jnl_gt_loss,                                   /* 99 */
  jn_gt_loss,                                    /* 100 */
  jnf_gt_loss,                                   /* 101 */
  lgammal_overflow, lgammal_negative,lgammal_reserve, /* 102, 103, 104 */
  lgamma_overflow, lgamma_negative,lgamma_reserve,    /* 105, 106, 107 */
  lgammaf_overflow, lgammaf_negative, lgammaf_reserve,/* 108, 109, 110 */
  gammal_overflow,gammal_negative, gammal_reserve,    /* 111, 112, 113 */
  gamma_overflow, gamma_negative, gamma_reserve,      /* 114, 115, 116 */
  gammaf_overflow,gammaf_negative,gammaf_reserve,     /* 117, 118, 119 */   
  fmodl_by_zero,                                 /* 120 */
  fmod_by_zero,                                  /* 121 */
  fmodf_by_zero,                                 /* 122 */
  remainderl_by_zero,                            /* 123 */
  remainder_by_zero,                             /* 124 */
  remainderf_by_zero,                            /* 125 */
  sinhl_overflow, sinh_overflow, sinhf_overflow, /* 126, 127, 128 */
  atanhl_gt_one, atanhl_eq_one,                  /* 129, 130 */
  atanh_gt_one, atanh_eq_one,                    /* 131, 132 */
  atanhf_gt_one, atanhf_eq_one,                  /* 133, 134 */
  acoshl_lt_one,                                 /* 135 */
  acosh_lt_one,                                  /* 136 */
  acoshf_lt_one,                                 /* 137 */
  log1pl_zero,   log1pl_negative,                /* 138, 139 */
  log1p_zero,    log1p_negative,                 /* 140, 141 */
  log1pf_zero,   log1pf_negative,                /* 142, 143 */
  ldexpl_overflow,   ldexpl_underflow,           /* 144, 145 */
  ldexp_overflow,    ldexp_underflow,            /* 146, 147 */
  ldexpf_overflow,   ldexpf_underflow,           /* 148, 149 */
  logbl_zero,   logb_zero, logbf_zero,            /* 150, 151,152 */
  nextafterl_overflow,   nextafter_overflow,  nextafterf_overflow            /* 153, 154,155 */
} error_types;

void __libm_error_support(void*,void*,void*,error_types);

#define BIAS_64  1023
#define EXPINF_64  2047

#define DOUBLE_HEX(HI, LO) 0x ## LO, 0x ## HI

static const unsigned INF[] = {
    DOUBLE_HEX(7ff00000, 00000000),
    DOUBLE_HEX(fff00000, 00000000)
};

static const double _zeroo = 0.0;
static const double _bigg = 1.0e300;
static const double _ponee = 1.0;
static const double _nonee = -1.0; 

#define INVALID    (_zeroo * *((double*)&INF[0]))
#define PINF       *((double*)&INF[0]) 
#define NINF       -PINF 
#define PINF_DZ    (_ponee/_zeroo) 
#define X_TLOSS    1.41484755040568800000e+16

# ifdef __cplusplus
struct __exception
{
  int type;
  char *name;
  double arg1, arg2, retval;
};
# else

struct exception
{
  int type;
  char *name;
  double arg1, arg2, retval;
};
#endif

#ifdef __MS__
#define exceptionf exception
#elif
struct exceptionf
{
  int type;
  char *name;
  float arg1, arg2, retval;
};

struct exceptionl
{
  int type;
  char *name;
  long double arg1, arg2, retval;
};

#endif


#ifdef __MS__
#define _matherrf _matherr
#else
extern int matherrf(struct exceptionf*);
#endif

# ifdef __cplusplus
#ifdef __MS__
extern int _matherr(struct __exception*);
#else
extern int matherr(struct __exception*);
#endif
# else 
#ifdef __MS__
extern int _matherr(struct exception*);
# else 
extern int matherr(struct exception*);
# endif
# endif

// exception is a reserved name in C++

extern int matherrl(struct exceptionl*);

/* Set these appropriately to make thread Safe */

#define ERRNO_RANGE  errno = ERANGE
#define ERRNO_DOMAIN errno = EDOM

// Add code to support _LIB_VERSION

typedef enum
{
    _IEEE_ = -1, // IEEE-like behavior
    _SVID_,      // SysV, Rel. 4 behavior
    _XOPEN_,     // Unix98
    __POSIX__,     // Posix
    _ISOC_,      // ISO C9X
    _MS_         // Microsoft version     
} _LIB_VERSION_TYPE;

extern _LIB_VERSION_TYPE _LIB_VERSION;

// This is a run-time variable and may effect
// floating point behavior of the libm functions
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\ia64\log.s ===
.file "log.s"

// Copyright (c) 2000, 2001, Intel Corporation
// All rights reserved.
// 
// Contributed 2/2/2000 by John Harrison, Ted Kubaska, Bob Norin, Shane Story,
// and Ping Tak Peter Tang of the Computational Software Lab, Intel Corporation.
// 
// WARRANTY DISCLAIMER
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS 
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY 
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
// 
// Intel Corporation is the author of this code, and requests that all
// problem reports or change requests be submitted to it directly at 
// http://developer.intel.com/opensource.
//
// History
//==============================================================
// 2/02/00  Initial version
// 4/04/00  Unwind support added
// 6/16/00  Updated table to be rounded correctly
// 8/15/00  Bundle added after call to __libm_error_support to properly
//          set [the previously overwritten] GR_Parameter_RESULT.
// 8/17/00  Improved speed of main path by 5 cycles
//          Shortened path for x=1.0
// 1/09/01  Improved speed, fixed flags for neg denormals
//
//
// API
//==============================================================
// double log(double)
// double log10(double)
//
// Overview of operation
//==============================================================
// Background
//
// Consider  x = 2^N 1.f1 f2 f3 f4...f63
// Log(x) = log(frcpa(x) x/frcpa(x))
//        = log(1/frcpa(x)) + log(frcpa(x) x)
//        = -log(frcpa(x)) + log(frcpa(x) x)
//
// frcpa(x)       = 2^-N frcpa((1.f1 f2 ... f63)
//
// -log(frcpa(x)) = -log(C) 
//                = -log(2^-N) - log(frcpa(1.f1 f2 ... f63))
//
// -log(frcpa(x)) = -log(C) 
//                = +Nlog2 - log(frcpa(1.f1 f2 ... f63))
//
// -log(frcpa(x)) = -log(C) 
//                = +Nlog2 + log(frcpa(1.f1 f2 ... f63))
//
// Log(x) = log(1/frcpa(x)) + log(frcpa(x) x)

// Log(x) =  +Nlog2 + log(1./frcpa(1.f1 f2 ... f63)) + log(frcpa(x) x)
// Log(x) =  +Nlog2 - log(/frcpa(1.f1 f2 ... f63))   + log(frcpa(x) x)
// Log(x) =  +Nlog2 + T                              + log(frcpa(x) x)
//
// Log(x) =  +Nlog2 + T                     + log(C x)
//
// Cx = 1 + r
//
// Log(x) =  +Nlog2 + T  + log(1+r)
// Log(x) =  +Nlog2 + T  + Series( r - r^2/2 + r^3/3 - r^4/4 ....)
//
// 1.f1 f2 ... f8 has 256 entries.
// They are 1 + k/2^8, k = 0 ... 255
// These 256 values are the table entries.
//
// Implementation
//===============
// CASE 1:  |x-1| >= 2^-6
// C = frcpa(x)
// r = C * x - 1
//
// Form rseries = r + P1*r^2 + P2*r^3 + P3*r^4 + P4*r^5 + P5*r^6
//
// x = f * 2*n where f is 1.f_1f_2f_3....f_63
// Nfloat = float(n)  where n is the true unbiased exponent
// pre-index = f_1f_2....f_8
// index = pre_index * 16
// get the dxt table entry at index + offset = T
//
// result = (T + Nfloat * log(2)) + rseries
//
// The T table is calculated as follows
// Form x_k = 1 + k/2^8 where k goes from 0... 255
//      y_k = frcpa(x_k)
//      log(1/y_k)  in quad and round to double-extended

// CASE 2:  |x-1| < 2^-6
// w = x - 1
//
// Form wseries = w + Q1*w^2 + Q2*w^3 + ... + Q7*w^8 + Q8*w^9
//
// result = wseries

// Special values 
//==============================================================


// log(+0)    = -inf
// log(-0)    = -inf

// log(+qnan) = +qnan 
// log(-qnan) = -qnan 
// log(+snan) = +qnan 
// log(-snan) = -qnan 

// log(-n)    = QNAN Indefinite
// log(-inf)  = QNAN Indefinite 

// log(+inf)  = +inf

// Registers used
//==============================================================
// Floating Point registers used: 
// f8, input
// f9 -> f15,  f32 -> f68

// General registers used:  
// r32 -> r51

// Predicate registers used:
// p6 -> p15

// p8 log base e
// p6 log base e special
// p9 used in the frcpa
// p13 log base e large W
// p14 log base e small w

// p7 log base 10
// p10 log base 10 large W
// p11 log base 10 small w
// p12 log base 10 special

// Assembly macros
//==============================================================

log_int_Nfloat   = f9 
log_Nfloat       = f10 

log_P5           = f11 
log_P4           = f12 
log_P3           = f13 
log_P2           = f14 
log_half         = f15

log_log2         = f32 
log_T            = f33 

log_rp_p4        = f34 
log_rp_p32       = f35 
log_rp_p2        = f36 
log_w6           = f37
log_rp_p10       = f38
log_rcube        = f39
log_rsq          = f40 

log_T_plus_Nlog2 = f41 
log_w3           = f42

log_r            = f43
log_C            = f44

log_w            = f45
log_Q8           = f46
log_Q7           = f47
log_Q4           = f48 
log_Q3           = f49
log_Q6           = f50 
log_Q5           = f51
log_Q2           = f52
log_Q1           = f53 
log_P1           = f53 

log_rp_q7        = f54 
log_rp_q65       = f55
log_Qlo          = f56

log_rp_q3        = f57
log_rp_q21       = f58
log_Qhi          = f59

log_wsq          = f60
log_w4           = f61
log_Q            = f62

log_inv_ln10     = f63
log_log10_hi     = f64
log_log10_lo     = f65
log_rp_q10       = f66
log_NORM_f8      = f67
log_r2P_r        = f68 

// ===================================

log_GR_exp_17_ones               = r33
log_GR_exp_16_ones               = r34
log_GR_exp_f8                    = r35
log_GR_signexp_f8                = r36
log_GR_true_exp_f8               = r37
log_GR_significand_f8            = r38
log_GR_half_exp                  = r39
log_GR_index                     = r39
log_AD_1                         = r40
log_GR_signexp_w                 = r41
log_GR_fff9                      = r42
log_AD_2                         = r43
log_GR_exp_w                     = r44

GR_SAVE_B0                       = r45
GR_SAVE_GP                       = r46
GR_SAVE_PFS                      = r47

GR_Parameter_X                   = r48
GR_Parameter_Y                   = r49
GR_Parameter_RESULT              = r50
log_GR_tag                       = r51


// Data tables
//==============================================================

.data

.align 16

log_table_1:
data8 0xBFC5555DA7212371 // P5
data8 0x3FC999A19EEF5826 // P4
data8 0x3FBC756AC654273B // Q8
data8 0xBFC001A42489AB4D // Q7
data8 0x3FC99999999A169B // Q4
data8 0xBFD00000000019AC // Q3
log_table_2:
data8 0xBFCFFFFFFFFEF009 // P3
data8 0x3FD555555554ECB2 // P2
data8 0x3FC2492479AA0DF8 // Q6
data8 0xBFC5555544986F52 // Q5
data8 0x3FD5555555555555 // Q2
data8 0xBFE0000000000000 // Q1, P1 = -0.5


data8 0xde5bd8a937287195, 0x00003ffd  // double-extended 1/ln(10)
data8 0xb17217f7d1cf79ac, 0x00003ffe  // log2
//      b17217f7d1cf79ab c9e3b39803f2f6a


data8 0x80200aaeac44ef38 , 0x00003ff6 //   log(1/frcpa(1+  0/2^-8))

data8 0xc09090a2c35aa070 , 0x00003ff7 //   log(1/frcpa(1+  1/2^-8))
data8 0xa0c94fcb41977c75 , 0x00003ff8 //   log(1/frcpa(1+  2/2^-8))
data8 0xe18b9c263af83301 , 0x00003ff8 //   log(1/frcpa(1+  3/2^-8))
data8 0x8d35c8d6399c30ea , 0x00003ff9 //   log(1/frcpa(1+  4/2^-8))
data8 0xadd4d2ecd601cbb8 , 0x00003ff9 //   log(1/frcpa(1+  5/2^-8))

data8 0xce95403a192f9f01 , 0x00003ff9 //   log(1/frcpa(1+  6/2^-8))
data8 0xeb59392cbcc01096 , 0x00003ff9 //   log(1/frcpa(1+  7/2^-8))
data8 0x862c7d0cefd54c5d , 0x00003ffa //   log(1/frcpa(1+  8/2^-8))
data8 0x94aa63c65e70d499 , 0x00003ffa //   log(1/frcpa(1+  9/2^-8))
data8 0xa54a696d4b62b382 , 0x00003ffa //   log(1/frcpa(1+ 10/2^-8))

data8 0xb3e4a796a5dac208 , 0x00003ffa //   log(1/frcpa(1+ 11/2^-8))
data8 0xc28c45b1878340a9 , 0x00003ffa //   log(1/frcpa(1+ 12/2^-8))
data8 0xd35c55f39d7a6235 , 0x00003ffa //   log(1/frcpa(1+ 13/2^-8))
data8 0xe220f037b954f1f5 , 0x00003ffa //   log(1/frcpa(1+ 14/2^-8))
data8 0xf0f3389b036834f3 , 0x00003ffa //   log(1/frcpa(1+ 15/2^-8))

data8 0xffd3488d5c980465 , 0x00003ffa //   log(1/frcpa(1+ 16/2^-8))
data8 0x87609ce2ed300490 , 0x00003ffb //   log(1/frcpa(1+ 17/2^-8))
data8 0x8ede9321e8c85927 , 0x00003ffb //   log(1/frcpa(1+ 18/2^-8))
data8 0x96639427f2f8e2f4 , 0x00003ffb //   log(1/frcpa(1+ 19/2^-8))
data8 0x9defad3e8f73217b , 0x00003ffb //   log(1/frcpa(1+ 20/2^-8))

data8 0xa582ebd50097029c , 0x00003ffb //   log(1/frcpa(1+ 21/2^-8))
data8 0xac06dbe75ab80fee , 0x00003ffb //   log(1/frcpa(1+ 22/2^-8))
data8 0xb3a78449b2d3ccca , 0x00003ffb //   log(1/frcpa(1+ 23/2^-8))
data8 0xbb4f79635ab46bb2 , 0x00003ffb //   log(1/frcpa(1+ 24/2^-8))
data8 0xc2fec93a83523f3f , 0x00003ffb //   log(1/frcpa(1+ 25/2^-8))

data8 0xc99af2eaca4c4571 , 0x00003ffb //   log(1/frcpa(1+ 26/2^-8))
data8 0xd1581106472fa653 , 0x00003ffb //   log(1/frcpa(1+ 27/2^-8))
data8 0xd8002560d4355f2e , 0x00003ffb //   log(1/frcpa(1+ 28/2^-8))
data8 0xdfcb43b4fe508632 , 0x00003ffb //   log(1/frcpa(1+ 29/2^-8))
data8 0xe67f6dff709d4119 , 0x00003ffb //   log(1/frcpa(1+ 30/2^-8))

data8 0xed393b1c22351280 , 0x00003ffb //   log(1/frcpa(1+ 31/2^-8))
data8 0xf5192bff087bcc35 , 0x00003ffb //   log(1/frcpa(1+ 32/2^-8))
data8 0xfbdf4ff6dfef2fa3 , 0x00003ffb //   log(1/frcpa(1+ 33/2^-8))
data8 0x81559a97f92f9cc7 , 0x00003ffc //   log(1/frcpa(1+ 34/2^-8))
data8 0x84be72bce90266e8 , 0x00003ffc //   log(1/frcpa(1+ 35/2^-8))

data8 0x88bc74113f23def2 , 0x00003ffc //   log(1/frcpa(1+ 36/2^-8))
data8 0x8c2ba3edf6799d11 , 0x00003ffc //   log(1/frcpa(1+ 37/2^-8))
data8 0x8f9dc92f92ea08b1 , 0x00003ffc //   log(1/frcpa(1+ 38/2^-8))
data8 0x9312e8f36efab5a7 , 0x00003ffc //   log(1/frcpa(1+ 39/2^-8))
data8 0x968b08643409ceb6 , 0x00003ffc //   log(1/frcpa(1+ 40/2^-8))

data8 0x9a062cba08a1708c , 0x00003ffc //   log(1/frcpa(1+ 41/2^-8))
data8 0x9d845b3abf95485c , 0x00003ffc //   log(1/frcpa(1+ 42/2^-8))
data8 0xa06fd841bc001bb4 , 0x00003ffc //   log(1/frcpa(1+ 43/2^-8))
data8 0xa3f3a74652fbe0db , 0x00003ffc //   log(1/frcpa(1+ 44/2^-8))
data8 0xa77a8fb2336f20f5 , 0x00003ffc //   log(1/frcpa(1+ 45/2^-8))

data8 0xab0497015d28b0a0 , 0x00003ffc //   log(1/frcpa(1+ 46/2^-8))
data8 0xae91c2be6ba6a615 , 0x00003ffc //   log(1/frcpa(1+ 47/2^-8))
data8 0xb189d1b99aebb20b , 0x00003ffc //   log(1/frcpa(1+ 48/2^-8))
data8 0xb51cced5de9c1b2c , 0x00003ffc //   log(1/frcpa(1+ 49/2^-8))
data8 0xb819bee9e720d42f , 0x00003ffc //   log(1/frcpa(1+ 50/2^-8))

data8 0xbbb2a0947b093a5d , 0x00003ffc //   log(1/frcpa(1+ 51/2^-8))
data8 0xbf4ec1505811684a , 0x00003ffc //   log(1/frcpa(1+ 52/2^-8))
data8 0xc2535bacfa8975ff , 0x00003ffc //   log(1/frcpa(1+ 53/2^-8))
data8 0xc55a3eafad187eb8 , 0x00003ffc //   log(1/frcpa(1+ 54/2^-8))
data8 0xc8ff2484b2c0da74 , 0x00003ffc //   log(1/frcpa(1+ 55/2^-8))

data8 0xcc0b1a008d53ab76 , 0x00003ffc //   log(1/frcpa(1+ 56/2^-8))
data8 0xcfb6203844b3209b , 0x00003ffc //   log(1/frcpa(1+ 57/2^-8))
data8 0xd2c73949a47a19f5 , 0x00003ffc //   log(1/frcpa(1+ 58/2^-8))
data8 0xd5daae18b49d6695 , 0x00003ffc //   log(1/frcpa(1+ 59/2^-8))
data8 0xd8f08248cf7e8019 , 0x00003ffc //   log(1/frcpa(1+ 60/2^-8))

data8 0xdca7749f1b3e540e , 0x00003ffc //   log(1/frcpa(1+ 61/2^-8))
data8 0xdfc28e033aaaf7c7 , 0x00003ffc //   log(1/frcpa(1+ 62/2^-8))
data8 0xe2e012a5f91d2f55 , 0x00003ffc //   log(1/frcpa(1+ 63/2^-8))
data8 0xe600064ed9e292a8 , 0x00003ffc //   log(1/frcpa(1+ 64/2^-8))
data8 0xe9226cce42b39f60 , 0x00003ffc //   log(1/frcpa(1+ 65/2^-8))

data8 0xec4749fd97a28360 , 0x00003ffc //   log(1/frcpa(1+ 66/2^-8))
data8 0xef6ea1bf57780495 , 0x00003ffc //   log(1/frcpa(1+ 67/2^-8))
data8 0xf29877ff38809091 , 0x00003ffc //   log(1/frcpa(1+ 68/2^-8))
data8 0xf5c4d0b245cb89be , 0x00003ffc //   log(1/frcpa(1+ 69/2^-8))
data8 0xf8f3afd6fcdef3aa , 0x00003ffc //   log(1/frcpa(1+ 70/2^-8))

data8 0xfc2519756be1abc7 , 0x00003ffc //   log(1/frcpa(1+ 71/2^-8))
data8 0xff59119f503e6832 , 0x00003ffc //   log(1/frcpa(1+ 72/2^-8))
data8 0x8147ce381ae0e146 , 0x00003ffd //   log(1/frcpa(1+ 73/2^-8))
data8 0x82e45f06cb1ad0f2 , 0x00003ffd //   log(1/frcpa(1+ 74/2^-8))
data8 0x842f5c7c573cbaa2 , 0x00003ffd //   log(1/frcpa(1+ 75/2^-8))

data8 0x85ce471968c8893a , 0x00003ffd //   log(1/frcpa(1+ 76/2^-8))
data8 0x876e8305bc04066d , 0x00003ffd //   log(1/frcpa(1+ 77/2^-8))
data8 0x891012678031fbb3 , 0x00003ffd //   log(1/frcpa(1+ 78/2^-8))
data8 0x8a5f1493d766a05f , 0x00003ffd //   log(1/frcpa(1+ 79/2^-8))
data8 0x8c030c778c56fa00 , 0x00003ffd //   log(1/frcpa(1+ 80/2^-8))

data8 0x8da85df17e31d9ae , 0x00003ffd //   log(1/frcpa(1+ 81/2^-8))
data8 0x8efa663e7921687e , 0x00003ffd //   log(1/frcpa(1+ 82/2^-8))
data8 0x90a22b6875c6a1f8 , 0x00003ffd //   log(1/frcpa(1+ 83/2^-8))
data8 0x91f62cc8f5d24837 , 0x00003ffd //   log(1/frcpa(1+ 84/2^-8))
data8 0x93a06cfc3857d980 , 0x00003ffd //   log(1/frcpa(1+ 85/2^-8))

data8 0x94f66d5e6fd01ced , 0x00003ffd //   log(1/frcpa(1+ 86/2^-8))
data8 0x96a330156e6772f2 , 0x00003ffd //   log(1/frcpa(1+ 87/2^-8))
data8 0x97fb3582754ea25b , 0x00003ffd //   log(1/frcpa(1+ 88/2^-8))
data8 0x99aa8259aad1bbf2 , 0x00003ffd //   log(1/frcpa(1+ 89/2^-8))
data8 0x9b0492f6227ae4a8 , 0x00003ffd //   log(1/frcpa(1+ 90/2^-8))

data8 0x9c5f8e199bf3a7a5 , 0x00003ffd //   log(1/frcpa(1+ 91/2^-8))
data8 0x9e1293b9998c1daa , 0x00003ffd //   log(1/frcpa(1+ 92/2^-8))
data8 0x9f6fa31e0b41f308 , 0x00003ffd //   log(1/frcpa(1+ 93/2^-8))
data8 0xa0cda11eaf46390e , 0x00003ffd //   log(1/frcpa(1+ 94/2^-8))
data8 0xa22c8f029cfa45aa , 0x00003ffd //   log(1/frcpa(1+ 95/2^-8))

data8 0xa3e48badb7856b34 , 0x00003ffd //   log(1/frcpa(1+ 96/2^-8))
data8 0xa5459a0aa95849f9 , 0x00003ffd //   log(1/frcpa(1+ 97/2^-8))
data8 0xa6a79c84480cfebd , 0x00003ffd //   log(1/frcpa(1+ 98/2^-8))
data8 0xa80a946d0fcb3eb2 , 0x00003ffd //   log(1/frcpa(1+ 99/2^-8))
data8 0xa96e831a3ea7b314 , 0x00003ffd //   log(1/frcpa(1+100/2^-8))

data8 0xaad369e3dc544e3b , 0x00003ffd //   log(1/frcpa(1+101/2^-8))
data8 0xac92e9588952c815 , 0x00003ffd //   log(1/frcpa(1+102/2^-8))
data8 0xadfa035aa1ed8fdc , 0x00003ffd //   log(1/frcpa(1+103/2^-8))
data8 0xaf6219eae1ad6e34 , 0x00003ffd //   log(1/frcpa(1+104/2^-8))
data8 0xb0cb2e6d8160f753 , 0x00003ffd //   log(1/frcpa(1+105/2^-8))

data8 0xb2354249ad950f72 , 0x00003ffd //   log(1/frcpa(1+106/2^-8))
data8 0xb3a056e98ef4a3b4 , 0x00003ffd //   log(1/frcpa(1+107/2^-8))
data8 0xb50c6dba52c6292a , 0x00003ffd //   log(1/frcpa(1+108/2^-8))
data8 0xb679882c33876165 , 0x00003ffd //   log(1/frcpa(1+109/2^-8))
data8 0xb78c07429785cedc , 0x00003ffd //   log(1/frcpa(1+110/2^-8))

data8 0xb8faeb8dc4a77d24 , 0x00003ffd //   log(1/frcpa(1+111/2^-8))
data8 0xba6ad77eb36ae0d6 , 0x00003ffd //   log(1/frcpa(1+112/2^-8))
data8 0xbbdbcc915e9bee50 , 0x00003ffd //   log(1/frcpa(1+113/2^-8))
data8 0xbd4dcc44f8cf12ef , 0x00003ffd //   log(1/frcpa(1+114/2^-8))
data8 0xbec0d81bf5b531fa , 0x00003ffd //   log(1/frcpa(1+115/2^-8))

data8 0xc034f19c139186f4 , 0x00003ffd //   log(1/frcpa(1+116/2^-8))
data8 0xc14cb69f7c5e55ab , 0x00003ffd //   log(1/frcpa(1+117/2^-8))
data8 0xc2c2abbb6e5fd56f , 0x00003ffd //   log(1/frcpa(1+118/2^-8))
data8 0xc439b2c193e6771e , 0x00003ffd //   log(1/frcpa(1+119/2^-8))
data8 0xc553acb9d5c67733 , 0x00003ffd //   log(1/frcpa(1+120/2^-8))

data8 0xc6cc96e441272441 , 0x00003ffd //   log(1/frcpa(1+121/2^-8))
data8 0xc8469753eca88c30 , 0x00003ffd //   log(1/frcpa(1+122/2^-8))
data8 0xc962cf3ce072b05c , 0x00003ffd //   log(1/frcpa(1+123/2^-8))
data8 0xcadeba8771f694aa , 0x00003ffd //   log(1/frcpa(1+124/2^-8))
data8 0xcc5bc08d1f72da94 , 0x00003ffd //   log(1/frcpa(1+125/2^-8))

data8 0xcd7a3f99ea035c29 , 0x00003ffd //   log(1/frcpa(1+126/2^-8))
data8 0xcef93860c8a53c35 , 0x00003ffd //   log(1/frcpa(1+127/2^-8))
data8 0xd0192f68a7ed23df , 0x00003ffd //   log(1/frcpa(1+128/2^-8))
data8 0xd19a201127d3c645 , 0x00003ffd //   log(1/frcpa(1+129/2^-8))
data8 0xd2bb92f4061c172c , 0x00003ffd //   log(1/frcpa(1+130/2^-8))

data8 0xd43e80b2ee8cc8fc , 0x00003ffd //   log(1/frcpa(1+131/2^-8))
data8 0xd56173601fc4ade4 , 0x00003ffd //   log(1/frcpa(1+132/2^-8))
data8 0xd6e6637efb54086f , 0x00003ffd //   log(1/frcpa(1+133/2^-8))
data8 0xd80ad9f58f3c8193 , 0x00003ffd //   log(1/frcpa(1+134/2^-8))
data8 0xd991d1d31aca41f8 , 0x00003ffd //   log(1/frcpa(1+135/2^-8))

data8 0xdab7d02231484a93 , 0x00003ffd //   log(1/frcpa(1+136/2^-8))
data8 0xdc40d532cde49a54 , 0x00003ffd //   log(1/frcpa(1+137/2^-8))
data8 0xdd685f79ed8b265e , 0x00003ffd //   log(1/frcpa(1+138/2^-8))
data8 0xde9094bbc0e17b1d , 0x00003ffd //   log(1/frcpa(1+139/2^-8))
data8 0xe01c91b78440c425 , 0x00003ffd //   log(1/frcpa(1+140/2^-8))

data8 0xe14658f26997e729 , 0x00003ffd //   log(1/frcpa(1+141/2^-8))
data8 0xe270cdc2391e0d23 , 0x00003ffd //   log(1/frcpa(1+142/2^-8))
data8 0xe3ffce3a2aa64922 , 0x00003ffd //   log(1/frcpa(1+143/2^-8))
data8 0xe52bdb274ed82887 , 0x00003ffd //   log(1/frcpa(1+144/2^-8))
data8 0xe6589852e75d7df6 , 0x00003ffd //   log(1/frcpa(1+145/2^-8))

data8 0xe786068c79937a7d , 0x00003ffd //   log(1/frcpa(1+146/2^-8))
data8 0xe91903adad100911 , 0x00003ffd //   log(1/frcpa(1+147/2^-8))
data8 0xea481236f7d35bb0 , 0x00003ffd //   log(1/frcpa(1+148/2^-8))
data8 0xeb77d48c692e6b14 , 0x00003ffd //   log(1/frcpa(1+149/2^-8))
data8 0xeca84b83d7297b87 , 0x00003ffd //   log(1/frcpa(1+150/2^-8))

data8 0xedd977f4962aa158 , 0x00003ffd //   log(1/frcpa(1+151/2^-8))
data8 0xef7179a22f257754 , 0x00003ffd //   log(1/frcpa(1+152/2^-8))
data8 0xf0a450d139366ca7 , 0x00003ffd //   log(1/frcpa(1+153/2^-8))
data8 0xf1d7e0524ff9ffdb , 0x00003ffd //   log(1/frcpa(1+154/2^-8))
data8 0xf30c29036a8b6cae , 0x00003ffd //   log(1/frcpa(1+155/2^-8))

data8 0xf4412bc411ea8d92 , 0x00003ffd //   log(1/frcpa(1+156/2^-8))
data8 0xf576e97564c8619d , 0x00003ffd //   log(1/frcpa(1+157/2^-8))
data8 0xf6ad62fa1b5f172f , 0x00003ffd //   log(1/frcpa(1+158/2^-8))
data8 0xf7e499368b55c542 , 0x00003ffd //   log(1/frcpa(1+159/2^-8))
data8 0xf91c8d10abaffe22 , 0x00003ffd //   log(1/frcpa(1+160/2^-8))

data8 0xfa553f7018c966f3 , 0x00003ffd //   log(1/frcpa(1+161/2^-8))
data8 0xfb8eb13e185d802c , 0x00003ffd //   log(1/frcpa(1+162/2^-8))
data8 0xfcc8e3659d9bcbed , 0x00003ffd //   log(1/frcpa(1+163/2^-8))
data8 0xfe03d6d34d487fd2 , 0x00003ffd //   log(1/frcpa(1+164/2^-8))
data8 0xff3f8c7581e9f0ae , 0x00003ffd //   log(1/frcpa(1+165/2^-8))

data8 0x803e029e280173ae , 0x00003ffe //   log(1/frcpa(1+166/2^-8))
data8 0x80dca10cc52d0757 , 0x00003ffe //   log(1/frcpa(1+167/2^-8))
data8 0x817ba200632755a1 , 0x00003ffe //   log(1/frcpa(1+168/2^-8))
data8 0x821b05f3b01d6774 , 0x00003ffe //   log(1/frcpa(1+169/2^-8))
data8 0x82bacd623ff19d06 , 0x00003ffe //   log(1/frcpa(1+170/2^-8))

data8 0x835af8c88e7a8f47 , 0x00003ffe //   log(1/frcpa(1+171/2^-8))
data8 0x83c5f8299e2b4091 , 0x00003ffe //   log(1/frcpa(1+172/2^-8))
data8 0x8466cb43f3d87300 , 0x00003ffe //   log(1/frcpa(1+173/2^-8))
data8 0x850803a67c80ca4b , 0x00003ffe //   log(1/frcpa(1+174/2^-8))
data8 0x85a9a1d11a23b461 , 0x00003ffe //   log(1/frcpa(1+175/2^-8))

data8 0x864ba644a18e6e05 , 0x00003ffe //   log(1/frcpa(1+176/2^-8))
data8 0x86ee1182dcc432f7 , 0x00003ffe //   log(1/frcpa(1+177/2^-8))
data8 0x875a925d7e48c316 , 0x00003ffe //   log(1/frcpa(1+178/2^-8))
data8 0x87fdaa109d23aef7 , 0x00003ffe //   log(1/frcpa(1+179/2^-8))
data8 0x88a129ed4becfaf2 , 0x00003ffe //   log(1/frcpa(1+180/2^-8))

data8 0x89451278ecd7f9cf , 0x00003ffe //   log(1/frcpa(1+181/2^-8))
data8 0x89b29295f8432617 , 0x00003ffe //   log(1/frcpa(1+182/2^-8))
data8 0x8a572ac5a5496882 , 0x00003ffe //   log(1/frcpa(1+183/2^-8))
data8 0x8afc2d0ce3b2dadf , 0x00003ffe //   log(1/frcpa(1+184/2^-8))
data8 0x8b6a69c608cfd3af , 0x00003ffe //   log(1/frcpa(1+185/2^-8))

data8 0x8c101e106e899a83 , 0x00003ffe //   log(1/frcpa(1+186/2^-8))
data8 0x8cb63de258f9d626 , 0x00003ffe //   log(1/frcpa(1+187/2^-8))
data8 0x8d2539c5bd19e2b1 , 0x00003ffe //   log(1/frcpa(1+188/2^-8))
data8 0x8dcc0e064b29e6f1 , 0x00003ffe //   log(1/frcpa(1+189/2^-8))
data8 0x8e734f45d88357ae , 0x00003ffe //   log(1/frcpa(1+190/2^-8))

data8 0x8ee30cef034a20db , 0x00003ffe //   log(1/frcpa(1+191/2^-8))
data8 0x8f8b0515686d1d06 , 0x00003ffe //   log(1/frcpa(1+192/2^-8))
data8 0x90336bba039bf32f , 0x00003ffe //   log(1/frcpa(1+193/2^-8))
data8 0x90a3edd23d1c9d58 , 0x00003ffe //   log(1/frcpa(1+194/2^-8))
data8 0x914d0de2f5d61b32 , 0x00003ffe //   log(1/frcpa(1+195/2^-8))

data8 0x91be0c20d28173b5 , 0x00003ffe //   log(1/frcpa(1+196/2^-8))
data8 0x9267e737c06cd34a , 0x00003ffe //   log(1/frcpa(1+197/2^-8))
data8 0x92d962ae6abb1237 , 0x00003ffe //   log(1/frcpa(1+198/2^-8))
data8 0x9383fa6afbe2074c , 0x00003ffe //   log(1/frcpa(1+199/2^-8))
data8 0x942f0421651c1c4e , 0x00003ffe //   log(1/frcpa(1+200/2^-8))

data8 0x94a14a3845bb985e , 0x00003ffe //   log(1/frcpa(1+201/2^-8))
data8 0x954d133857f861e7 , 0x00003ffe //   log(1/frcpa(1+202/2^-8))
data8 0x95bfd96468e604c4 , 0x00003ffe //   log(1/frcpa(1+203/2^-8))
data8 0x9632d31cafafa858 , 0x00003ffe //   log(1/frcpa(1+204/2^-8))
data8 0x96dfaabd86fa1647 , 0x00003ffe //   log(1/frcpa(1+205/2^-8))

data8 0x9753261fcbb2a594 , 0x00003ffe //   log(1/frcpa(1+206/2^-8))
data8 0x9800c11b426b996d , 0x00003ffe //   log(1/frcpa(1+207/2^-8))
data8 0x9874bf4d45ae663c , 0x00003ffe //   log(1/frcpa(1+208/2^-8))
data8 0x99231f5ee9a74f79 , 0x00003ffe //   log(1/frcpa(1+209/2^-8))
data8 0x9997a18a56bcad28 , 0x00003ffe //   log(1/frcpa(1+210/2^-8))

data8 0x9a46c873a3267e79 , 0x00003ffe //   log(1/frcpa(1+211/2^-8))
data8 0x9abbcfc621eb6cb6 , 0x00003ffe //   log(1/frcpa(1+212/2^-8))
data8 0x9b310cb0d354c990 , 0x00003ffe //   log(1/frcpa(1+213/2^-8))
data8 0x9be14cf9e1b3515c , 0x00003ffe //   log(1/frcpa(1+214/2^-8))
data8 0x9c5710b8cbb73a43 , 0x00003ffe //   log(1/frcpa(1+215/2^-8))

data8 0x9ccd0abd301f399c , 0x00003ffe //   log(1/frcpa(1+216/2^-8))
data8 0x9d7e67f3bdce8888 , 0x00003ffe //   log(1/frcpa(1+217/2^-8))
data8 0x9df4ea81a99daa01 , 0x00003ffe //   log(1/frcpa(1+218/2^-8))
data8 0x9e6ba405a54514ba , 0x00003ffe //   log(1/frcpa(1+219/2^-8))
data8 0x9f1e21c8c7bb62b3 , 0x00003ffe //   log(1/frcpa(1+220/2^-8))

data8 0x9f956593f6b6355c , 0x00003ffe //   log(1/frcpa(1+221/2^-8))
data8 0xa00ce1092e5498c3 , 0x00003ffe //   log(1/frcpa(1+222/2^-8))
data8 0xa0c08309c4b912c1 , 0x00003ffe //   log(1/frcpa(1+223/2^-8))
data8 0xa1388a8c6faa2afa , 0x00003ffe //   log(1/frcpa(1+224/2^-8))
data8 0xa1b0ca7095b5f985 , 0x00003ffe //   log(1/frcpa(1+225/2^-8))

data8 0xa22942eb47534a00 , 0x00003ffe //   log(1/frcpa(1+226/2^-8))
data8 0xa2de62326449d0a3 , 0x00003ffe //   log(1/frcpa(1+227/2^-8))
data8 0xa357690f88bfe345 , 0x00003ffe //   log(1/frcpa(1+228/2^-8))
data8 0xa3d0a93f45169a4b , 0x00003ffe //   log(1/frcpa(1+229/2^-8))
data8 0xa44a22f7ffe65f30 , 0x00003ffe //   log(1/frcpa(1+230/2^-8))

data8 0xa500c5e5b4c1aa36 , 0x00003ffe //   log(1/frcpa(1+231/2^-8))
data8 0xa57ad064eb2ebbc2 , 0x00003ffe //   log(1/frcpa(1+232/2^-8))
data8 0xa5f5152dedf4384e , 0x00003ffe //   log(1/frcpa(1+233/2^-8))
data8 0xa66f9478856233ec , 0x00003ffe //   log(1/frcpa(1+234/2^-8))
data8 0xa6ea4e7cca02c32e , 0x00003ffe //   log(1/frcpa(1+235/2^-8))

data8 0xa765437325341ccf , 0x00003ffe //   log(1/frcpa(1+236/2^-8))
data8 0xa81e21e6c75b4020 , 0x00003ffe //   log(1/frcpa(1+237/2^-8))
data8 0xa899ab333fe2b9ca , 0x00003ffe //   log(1/frcpa(1+238/2^-8))
data8 0xa9157039c51ebe71 , 0x00003ffe //   log(1/frcpa(1+239/2^-8))
data8 0xa991713433c2b999 , 0x00003ffe //   log(1/frcpa(1+240/2^-8))

data8 0xaa0dae5cbcc048b3 , 0x00003ffe //   log(1/frcpa(1+241/2^-8))
data8 0xaa8a27ede5eb13ad , 0x00003ffe //   log(1/frcpa(1+242/2^-8))
data8 0xab06de228a9e3499 , 0x00003ffe //   log(1/frcpa(1+243/2^-8))
data8 0xab83d135dc633301 , 0x00003ffe //   log(1/frcpa(1+244/2^-8))
data8 0xac3fb076adc7fe7a , 0x00003ffe //   log(1/frcpa(1+245/2^-8))

data8 0xacbd3cbbe47988f1 , 0x00003ffe //   log(1/frcpa(1+246/2^-8))
data8 0xad3b06b1a5dc57c3 , 0x00003ffe //   log(1/frcpa(1+247/2^-8))
data8 0xadb90e94af887717 , 0x00003ffe //   log(1/frcpa(1+248/2^-8))
data8 0xae3754a218f7c816 , 0x00003ffe //   log(1/frcpa(1+249/2^-8))
data8 0xaeb5d9175437afa2 , 0x00003ffe //   log(1/frcpa(1+250/2^-8))

data8 0xaf349c322e9c7cee , 0x00003ffe //   log(1/frcpa(1+251/2^-8))
data8 0xafb39e30d1768d1c , 0x00003ffe //   log(1/frcpa(1+252/2^-8))
data8 0xb032df51c2c93116 , 0x00003ffe //   log(1/frcpa(1+253/2^-8))
data8 0xb0b25fd3e6035ad9 , 0x00003ffe //   log(1/frcpa(1+254/2^-8))
data8 0xb1321ff67cba178c , 0x00003ffe //   log(1/frcpa(1+255/2^-8))


   
.align 32
.global log#
.global log10#

// log10 has p7 true, p8 false
// log   has p8 true, p7 false

.section .text
.proc  log10#
.align 32

log10: 
{ .mfi
     alloc     r32=ar.pfs,1,15,4,0                    
     frcpa.s1  log_C,p9 = f1,f8                 
     cmp.eq.unc     p7,p8         = r0, r0 
}
{ .mfb
     addl           log_AD_1   = @ltoff(log_table_1), gp
     fnorm.s1 log_NORM_f8 = f8 
     br.sptk        LOG_LOG10_X 
}
;;

.endp log10



.section .text
.proc  log#
.align 32
log: 

{ .mfi
     alloc     r32=ar.pfs,1,15,4,0                    
     frcpa.s1  log_C,p9 = f1,f8                 
     cmp.eq.unc     p8,p7         = r0, r0 
}
{ .mfi
     addl           log_AD_1   = @ltoff(log_table_1), gp
     fnorm.s1 log_NORM_f8 = f8 
     nop.i 999
}
;;

LOG_LOG10_X:

{ .mfi
     ld8 log_AD_1 = [log_AD_1]
     fclass.m.unc p15,p0 = f8, 0x0b            // Test for x=unorm
     mov        log_GR_fff9 = 0xfff9
}
{ .mfi
     mov       log_GR_half_exp = 0x0fffe
     fms.s1     log_w = f8,f1,f1              
     mov       log_GR_exp_17_ones = 0x1ffff
}
;;

{ .mmi
     getf.exp   log_GR_signexp_f8 = f8 // If x unorm then must recompute
     setf.exp   log_half = log_GR_half_exp  // Form 0.5 = -Q1
     nop.i 999
}
;;

{ .mmb
     adds log_AD_2 = 0x30, log_AD_1
     mov       log_GR_exp_16_ones = 0xffff
(p15) br.cond.spnt LOG_DENORM     
}
;;

LOG_COMMON:
{.mfi
     ldfpd      log_P5,log_P4 = [log_AD_1],16           
     fclass.m.unc p6,p0 = f8, 0xc3             // Test for x=nan
     and        log_GR_exp_f8 = log_GR_signexp_f8, log_GR_exp_17_ones  
}
{.mfi
     ldfpd      log_P3,log_P2 = [log_AD_2],16           
     nop.f 999
     nop.i 999
}
;;

{ .mfi
     ldfpd      log_Q8,log_Q7 = [log_AD_1],16           
     fclass.m.unc p11,p0 = f8, 0x21            // Test for x=+inf
     sub       log_GR_true_exp_f8 = log_GR_exp_f8, log_GR_exp_16_ones 
}
{ .mfi
     ldfpd      log_Q6,log_Q5 = [log_AD_2],16           
     nop.f 999
     nop.i 999
}
;;


{ .mfi
     ldfpd      log_Q4,log_Q3 = [log_AD_1],16           
     fma.s1     log_wsq     = log_w, log_w, f0
     nop.i 999
}
{ .mfb
     ldfpd      log_Q2,log_Q1 = [log_AD_2],16           
(p6) fma.d.s0   f8 = f8,f1,f0      // quietize nan result if x=nan
(p6) br.ret.spnt b0                // Exit for x=nan
}
;;


{ .mfi
     setf.sig  log_int_Nfloat = log_GR_true_exp_f8
     fcmp.eq.s1 p10,p0 = log_NORM_f8, f1  // Test for x=+1.0
     nop.i 999
}
{ .mfb
     nop.m 999
     fms.s1     log_r = log_C,f8,f1
(p11) br.ret.spnt b0               // Exit for x=+inf
}
;;


{ .mmf
     getf.sig   log_GR_significand_f8 = log_NORM_f8 
     ldfe       log_inv_ln10 = [log_AD_2],16      
     fclass.m.unc p6,p0 = f8, 0x07        // Test for x=0
}
;;


{ .mfb
     nop.m 999
(p10) fmerge.s f8 = f0, f0
(p10) br.ret.spnt b0                // Exit for x=1.0
;;
}

{ .mfi
     getf.exp   log_GR_signexp_w = log_w
     fclass.m.unc p12,p0 = f8, 0x3a       // Test for x neg norm, unorm, inf
     shl        log_GR_index = log_GR_significand_f8,1            
}
;;

{ .mfi
     ldfe       log_log2 = [log_AD_2],16   
     fnma.s1    log_rp_q10 = log_half, log_wsq, log_w
     shr.u     log_GR_index = log_GR_index,56
}
{ .mfb
     nop.m 999
     fma.s1      log_w3      = log_wsq, log_w, f0
(p6) br.cond.spnt LOG_ZERO_NEG      // Branch if x=0
;;
}
 

{ .mfi
     and log_GR_exp_w = log_GR_exp_17_ones, log_GR_signexp_w
     fma.s1      log_w4      = log_wsq, log_wsq, f0
     nop.i 999
}
{ .mfb
     shladd log_AD_2 = log_GR_index,4,log_AD_2
     fma.s1     log_rsq     = log_r, log_r, f0                   
(p12) br.cond.spnt LOG_ZERO_NEG     // Branch if x<0
;;
}

{ .mfi
     ldfe       log_T = [log_AD_2]
     fma.s1    log_rp_p4   = log_P5, log_r, log_P4
     nop.i 999
}
{ .mfi
     nop.m 999
     fma.s1      log_rp_p32 = log_P3, log_r, log_P2
     nop.i 999
;;
}


{ .mfi
     nop.m 999
     fma.s1    log_rp_q7   = log_Q8, log_w, log_Q7
     nop.i 999
}
{ .mfi
     nop.m 999
     fma.s1    log_rp_q65  = log_Q6, log_w, log_Q5
     nop.i 999
;;
}

//    p13 <== large w log
//    p14 <== small w log
{ .mfi
(p8) cmp.ge.unc p13,p14 = log_GR_exp_w, log_GR_fff9
     fma.s1    log_rp_q3   = log_Q4, log_w, log_Q3
     nop.i 999
;;
}

//    p10 <== large w log10
//    p11 <== small w log10
{ .mfi
(p7) cmp.ge.unc p10,p11 = log_GR_exp_w, log_GR_fff9
     fcvt.xf   log_Nfloat = log_int_Nfloat
     nop.i 999
}

{ .mfi
     nop.m 999
     fma.s1    log_rp_q21  = log_Q2, log_w3, log_rp_q10
     nop.i 999 ;;
}

{ .mfi
     nop.m 999
     fma.s1    log_rcube   = log_rsq, log_r, f0
     nop.i 999
}
{ .mfi
     nop.m 999
     fma.s1    log_rp_p10   = log_rsq, log_P1, log_r
     nop.i 999
;;
}

{ .mfi
     nop.m 999
     fcmp.eq.s0 p6,p0 = f8,f0         // Sets flag on +denormal input
     nop.i 999
}
{ .mfi
     nop.m 999
     fma.s1     log_rp_p2   = log_rp_p4, log_rsq, log_rp_p32
     nop.i 999
;;
}


{ .mfi
     nop.m 999
     fma.s1        log_w6     = log_w3, log_w3, f0           
     nop.i 999 
}
{ .mfi
     nop.m 999
     fma.s1        log_Qlo     = log_rp_q7, log_wsq, log_rp_q65           
     nop.i 999 
}
;;

{ .mfi
     nop.m 999
     fma.s1        log_Qhi     = log_rp_q3, log_w4, log_rp_q21
     nop.i 999 ;;
}


{ .mfi
     nop.m 999
     fma.s1        log_T_plus_Nlog2 = log_Nfloat,log_log2, log_T    
     nop.i 999 ;;
}

{ .mfi
     nop.m 999
     fma.s1        log_r2P_r = log_rp_p2, log_rcube, log_rp_p10           
     nop.i 999 ;;
}


//    small w, log   <== p14
{ .mfi
     nop.m 999
(p14) fma.d        f8       = log_Qlo, log_w6, log_Qhi          
     nop.i 999
}
{ .mfi
     nop.m 999
     fma.s1        log_Q       = log_Qlo, log_w6, log_Qhi          
     nop.i 999 ;;
}


{ .mfi
     nop.m 999
(p10) fma.s1        log_log10_hi     = log_T_plus_Nlog2, log_inv_ln10,f0
     nop.i 999  ;;
}

//    large w, log   <== p13
.pred.rel "mutex",p13,p10
{ .mfi
      nop.m 999
(p13) fadd.d        f8              = log_T_plus_Nlog2, log_r2P_r 
      nop.i 999 
}
{ .mfi
      nop.m 999
(p10) fma.s1     log_log10_lo     = log_inv_ln10, log_r2P_r,f0
      nop.i 999  ;;
}


//    small w, log10 <== p11
{ .mfi
      nop.m 999
(p11) fma.d      f8 = log_inv_ln10,log_Q,f0                         
      nop.i 999 ;;
}

//    large w, log10 <== p10
{ .mfb
      nop.m 999
(p10) fma.d      f8                = log_log10_hi, f1, log_log10_lo 
      br.ret.sptk     b0 
;;
}

LOG_DENORM:
{ .mfb
     getf.exp   log_GR_signexp_f8 = log_NORM_f8 
     nop.f 999
     br.cond.sptk LOG_COMMON
}
;;

LOG_ZERO_NEG: 

// qnan snan inf norm     unorm 0 -+
// 0    0    0   0        0     1 11      0x7
// 0    0    1   1        1     0 10      0x3a

// Save x (f8) in f10
{ .mfi
     nop.m 999
     fmerge.s f10 = f8,f8 
     nop.i 999  ;;
}

// p8 p9  means  ln(+-0)  = -inf
// p7 p10 means  log(+-0) = -inf

//    p13 means  ln(-)
//    p14 means  log(-)


{ .mfi
     nop.m 999
     fmerge.ns   f6 = f1,f1            // Form -1.0
     nop.i 999  ;;
}

// p9  means  ln(+-0)  = -inf
// p10 means  log(+-0) = -inf
// Log(+-0) = -inf 

{ .mfi
	nop.m 999
(p8)  fclass.m.unc  p9,p0 = f10, 0x07           
	nop.i 999
}
{ .mfi
	nop.m 999
(p7)  fclass.m.unc  p10,p0 = f10, 0x07           
	nop.i 999 ;;
}


// p13  ln(-)
// p14  log(-)

// Log(-inf, -normal, -unnormal) = QNAN indefinite
{ .mfi
	nop.m 999
(p8)  fclass.m.unc  p13,p0 = f10, 0x3a           
	nop.i 999 
}
{ .mfi
	nop.m 999
(p7)  fclass.m.unc  p14,p0 = f10, 0x3a           
	nop.i 999  ;;
}


.pred.rel "mutex",p9,p10
{ .mfi
(p9)     mov        log_GR_tag = 2       
(p9)    frcpa f8,p11 = f6,f0                   
            nop.i 999
}
{ .mfi
(p10)    mov        log_GR_tag = 8       
(p10)   frcpa f8,p12 = f6,f0                   
            nop.i 999 ;;
}

.pred.rel "mutex",p13,p14
{ .mfi
(p13)    mov        log_GR_tag = 3       
(p13)    frcpa f8,p11 = f0,f0                   
            nop.i 999
}
{ .mfb
(p14)    mov        log_GR_tag = 9       
(p14)   frcpa f8,p12 = f0,f0                   
        br.cond.sptk __libm_error_region ;; 
}
.endp log


// Stack operations when calling error support.
//       (1)               (2)                          (3) (call)              (4)
//   sp   -> +          psp -> +                     psp -> +                   sp -> +
//           |                 |                            |                         |
//           |                 | <- GR_Y               R3 ->| <- GR_RESULT            | -> f8
//           |                 |                            |                         |
//           | <-GR_Y      Y2->|                       Y2 ->| <- GR_Y                 |
//           |                 |                            |                         |
//           |                 | <- GR_X               X1 ->|                         |
//           |                 |                            |                         |
//  sp-64 -> +          sp ->  +                     sp ->  +                         +
//    save ar.pfs          save b0                                               restore gp
//    save gp                                                                    restore ar.pfs



.proc __libm_error_region
__libm_error_region:
.prologue

// (1)
{ .mfi
        add   GR_Parameter_Y=-32,sp             // Parameter 2 value
        nop.f 0
.save   ar.pfs,GR_SAVE_PFS
        mov  GR_SAVE_PFS=ar.pfs                 // Save ar.pfs
}
{ .mfi
.fframe 64
        add sp=-64,sp                          // Create new stack
        nop.f 0
        mov GR_SAVE_GP=gp                      // Save gp
};;


// (2)
{ .mmi
        stfd [GR_Parameter_Y] = f1,16         // STORE Parameter 2 on stack
        add GR_Parameter_X = 16,sp            // Parameter 1 address
.save   b0, GR_SAVE_B0
        mov GR_SAVE_B0=b0                     // Save b0
};;

.body
// (3)
{ .mib
        stfd [GR_Parameter_X] = f10                   // STORE Parameter 1 on stack
        add   GR_Parameter_RESULT = 0,GR_Parameter_Y  // Parameter 3 address
        nop.b 0                             
}
{ .mib
        stfd [GR_Parameter_Y] = f8                    // STORE Parameter 3 on stack
        add   GR_Parameter_Y = -16,GR_Parameter_Y
        br.call.sptk b0=__libm_error_support#         // Call error handling function
};;

{ .mmi
        nop.m 0
        nop.m 0
        add   GR_Parameter_RESULT = 48,sp
};;

// (4)
{ .mmi
        ldfd  f8 = [GR_Parameter_RESULT]       // Get return result off stack
.restore
        add   sp = 64,sp                       // Restore stack pointer
        mov   b0 = GR_SAVE_B0                  // Restore return address
};;
{ .mib
        mov   gp = GR_SAVE_GP                  // Restore gp
        mov   ar.pfs = GR_SAVE_PFS             // Restore ar.pfs
        br.ret.sptk     b0                     // Return
};;

.endp __libm_error_region


.type   __libm_error_support#,@function
.global __libm_error_support#
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\ia64\logbf.s ===
.file "logbf.s"

// Copyright (c) 2000, 2001, Intel Corporation
// All rights reserved.
// 
// Contributed 2/2/2000 by John Harrison, Ted Kubaska, Bob Norin, Shane Story,
// and Ping Tak Peter Tang of the Computational Software Lab, Intel Corporation.
// 
// WARRANTY DISCLAIMER
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS 
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY 
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
// 
// Intel Corporation is the author of this code, and requests that all
// problem reports or change requests be submitted to it directly at 
// http://developer.intel.com/opensource.
//
// History
//==============================================================
// 2/02/00  Initial version
// 2/16/00  Modified to conform to C9X 
// 3/16/00  Improved speed
// 4/04/00  Unwind support added
// 5/30/00  Fixed bug when x double-extended denormal
// 8/15/00  Bundle added after call to __libm_error_support to properly
//          set [the previously overwritten] GR_Parameter_RESULT.
//
// API
//==============================================================
// float _logbf( float x);
//
// Overview of operation
//==============================================================
// The logbf function extracts the exponent of x as an integer in 
// floating-point format. 
// logbf computes log2 of x as a float

// logbf is similar to ilogbf but differs in the  following ways:
//         +-inf
//            ilogbf: returns INT_MAX
//             logbf: returns +inf
//         Nan  returns FP_LOGBNAN (which is either INT_MAX or INT_MIN)
//            ilogbf: returns INT_MAX (7fffffff)
//             logbf: returns QNAN (quietized SNAN)
//         0    returns FP_ILOGB0 (which is either INT_MIN or -INT_MAX)
//            ilogbf: returns -INT_MAX (80000001)
//             logbf: returns -inf, raises the divide-by-zero exception,
//                   and calls libm_error_support to set domain error
//
// Registers used
//==============================================================
// general registers used: 
// ar.pfs r32 
// r33 -> r37
// r38 -> r41 used as parameters to error path
//
// predicate registers used: 
// p6, p7, p8
//
// floating-point registers used: 
// f9, f10, f11
// f8, input

GR_SAVE_B0                    = r34
// r40 is address of table of coefficients
GR_SAVE_PFS                   = r32
GR_SAVE_GP                    = r35 

GR_Parameter_X                = r38
GR_Parameter_Y                = r39
GR_Parameter_RESULT           = r40
GR_Parameter_TAG              = r41

FR_X             = f8
FR_Y             = f0
FR_RESULT        = f10


.align 32
.global _logbf#

.section .text
.proc  _logbf#
.align 32


_logbf: 

// qnan snan inf norm     unorm 0 -+
// 0    0    0   0        1     0 11
// 0                      b
{ .mfi
      alloc          r32=ar.pfs,1,5,4,0
      fclass.m.unc  p8,p0 = f8, 0x0b
      nop.i 999
}
// X NORMAL
// r37 = exp(f8) - - 0xffff
// sig(f8) = r37
// f8 = convert_to_fp (sig))
{ .mfi
      getf.exp      r35 = f8
      fnorm         f10=f8
      nop.i 999 ;;
}

// qnan snan inf norm     unorm 0 -+
// 1    1    1   0        0     0 11
// e                      3
{ .mmf
      mov      r33 = 0xffff
      mov      r34 = 0x1ffff
      fclass.m.unc  p6,p0 = f8, 0xe3 ;;
}

{ .mfb
      and           r36 = r35, r34
      fclass.m.unc  p7,p0 = f8, 0x07
(p8)  br.cond.spnt  LOGB_DENORM ;;
}

{ .mib
      sub           r37 = r36, r33
      nop.i 999
(p6)  br.cond.spnt  LOGB_NAN_INF ;;
}

{ .mib
      setf.sig      f9  = r37
      nop.i 999
(p7)  br.cond.spnt  LOGB_ZERO ;;
}

{ .mfi
      nop.m 999
      fcvt.xf       f10 = f9
      nop.i 999 ;;
}

{ .mfb
      nop.m 999
      fnorm.s       f8 = f10
      br.ret.sptk    b0 ;;
}

LOGB_DENORM:
// Form signexp of 2^64 in case need to scale denormal
// Check to see if double-extended denormal
{ .mfi
      mov r38 = 0x1003f
      fclass.m.unc  p8,p0 = f10, 0x0b
      nop.i 999 ;;
}

// Form 2^64 in case need to scale denormal
{ .mfi
      setf.exp f11 = r38
      nop.f 999
      nop.i 999 ;;
}

// If double-extended denormal add 64 to exponent bias for scaling
// If double-extended denormal form x * 2^64 which is normal
{ .mfi
(p8)  add r33 = 64, r33
(p8)  fmpy f10 = f10, f11    
      nop.i 999 ;;
}

// Logic is the same as normal path but use normalized input
{ .mmi
      getf.exp      r35 = f10 ;;
      nop.m 999
      nop.i 999 ;;
}

{ .mmi
      and           r36 = r35, r34 ;;
      sub           r37 = r36, r33
      nop.i 999 ;;
}

{ .mmi
      setf.sig      f9  = r37
      nop.m 999
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
      fcvt.xf       f10 = f9
      nop.i 999 ;;
}

{ .mfb
      nop.m 999
      fnorm.s       f8 = f10
      br.ret.sptk    b0 ;;
}

LOGB_NAN_INF: 

// X NAN or INFINITY, return f8 * f8
{ .mfb
      nop.m 999
      fma.s      f8= f8,f8,f0
      br.ret.sptk   b0 ;;
}

LOGB_ZERO: 

// X ZERO
// return -1.0/fabs(f8)=-inf, set divide-by-zero flag, call error support
{ .mfi
      nop.m 999
      fmerge.s      f9 = f0,f8
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
      fmerge.ns     f10 = f0,f9
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
      frcpa         f10,p6 = f1,f10
      nop.i 999 ;;
}

.endp _logbf


.proc __libm_error_region
__libm_error_region:
.prologue
{ .mii
        add   GR_Parameter_Y=-32,sp             // Parameter 2 value
        mov   GR_Parameter_TAG = 152                   
.save   ar.pfs,GR_SAVE_PFS
        mov  GR_SAVE_PFS=ar.pfs                 // Save ar.pfs
}
{ .mfi
.fframe 64
        add sp=-64,sp                           // Create new stack
        nop.f 0
        mov GR_SAVE_GP=gp                       // Save gp
};;
{ .mmi
        stfs [GR_Parameter_Y] = FR_Y,16         // Store Parameter 2 on stack
        add GR_Parameter_X = 16,sp              // Parameter 1 address
.save   b0, GR_SAVE_B0
        mov GR_SAVE_B0=b0                       // Save b0
};;
.body
{ .mib
        stfs [GR_Parameter_X] = FR_X            // Store Parameter 1 on stack
        add   GR_Parameter_RESULT = 0,GR_Parameter_Y
        nop.b 0                                 // Parameter 3 address
}
{ .mib
        stfs [GR_Parameter_Y] = FR_RESULT       // Store Parameter 3 on stack
        add   GR_Parameter_Y = -16,GR_Parameter_Y
        br.call.sptk b0=__libm_error_support#   // Call error handling function
};;
{ .mmi
        nop.m 0
        nop.m 0
        add   GR_Parameter_RESULT = 48,sp
};;
{ .mmi
        ldfs  f8 = [GR_Parameter_RESULT]       // Get return result off stack
.restore
        add   sp = 64,sp                       // Restore stack pointer
        mov   b0 = GR_SAVE_B0                  // Restore return address
};;
{ .mib
        mov   gp = GR_SAVE_GP                  // Restore gp 
        mov   ar.pfs = GR_SAVE_PFS             // Restore ar.pfs
        br.ret.sptk     b0                     // Return
};; 

.endp __libm_error_region



.type   __libm_error_support#,@function
.global __libm_error_support#
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\ia64\modf.s ===
.file "modf.s"

// Copyright (c) 2000, 2001, Intel Corporation
// All rights reserved.
// 
// Contributed 2/2/2000 by John Harrison, Ted Kubaska, Bob Norin, Shane Story,
// and Ping Tak Peter Tang of the Computational Software Lab, Intel Corporation.
// 
// WARRANTY DISCLAIMER
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS 
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY 
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
// 
// Intel Corporation is the author of this code, and requests that all
// problem reports or change requests be submitted to it directly at 
// http://developer.intel.com/opensource.
//
// History
//==============================================================
// 2/02/00: Initial version
// 4/04/00: Improved speed, corrected result for NaN input
// 12/22/00 Fixed so inexact flag is never set, and invalid is not set for 
//            qnans nor for inputs larger than 2^63.
//
// API
//==============================================================
// double modf(double x, double *iptr)
// break a floating point x number into fraction and an exponent
//
// input  floating point f8, address in r33
// output floating point f8 (x fraction), and *iptr (x integral part)
//
// OVERVIEW
//==============================================================
//
// NO FRACTIONAL PART: HUGE
// If
// for double-extended
// If the true exponent is greater than or equal 63
//      1003e ==> 1003e -ffff = 3f = 63(dec)
// for double
// If the true exponent is greater than or equal 52
//                10033 -ffff = 34 = 52(dec)
// for single
// If the true exponent is greater than or equal 23
//                10016 -ffff = 17 = 23(dec)
// then
// we are already an integer (p9 true)

// NO INTEGER PART:    SMALL
//     Is f8 exponent less than register bias (that is, is it
//     less than 1). If it is, get the right sign of
//     zero and store this in iptr.

// CALCULATION: NOT HUGE, NOT SMALL
// To get the integer part
// Take the floating-point  input and truncate 
//   then convert  this integer to fp  Call it  MODF_INTEGER_PART

// Subtract  MODF_INTEGER_PART from MODF_NORM_F8 to get fraction part
// Then put fraction part in f8 
//      put integer  part MODF_INTEGER_PART into *iptr

// Registers used
//==============================================================

// predicate registers used: 
// p6 - p13

//                      0xFFFF           0x10033
// -----------------------+-----------------+-------------
//              SMALL     |      NORMAL     | HUGE
//    p11 --------------->|<----- p12 ----->| <-------------- p9
//    p10 --------------------------------->|
//    p13 --------------------------------------------------->|
//

// floating-point registers used: 
MODF_NORM_F8               = f9
MODF_FRACTION_PART         = f10
MODF_INTEGER_PART          = f11
MODF_INT_INTEGER_PART      = f12


// general registers used 
modf_signexp    = r14
modf_GR_no_frac = r15
modf_GR_FFFF    = r16
modf_17_ones    = r17 
modf_exp        = r18
// r33 = iptr
     

.align 32
.global modf#

.section .text
.proc  modf#
.align 32


// Main path is p9, p11, p8 FALSE and p12 TRUE

// Assume input is normalized and get signexp
// Normalize input just in case
// Form exponent bias 
modf: 
{ .mfi
      getf.exp  modf_signexp = f8
      fnorm          MODF_NORM_F8  = f8
      addl           modf_GR_FFFF  = 0xffff, r0
}
// Get integer part of input
// Form exponent mask
{ .mfi
      nop.m 999
      fcvt.fx.trunc.s1  MODF_INT_INTEGER_PART   = f8
      mov  modf_17_ones     = 0x1ffff ;;
}

// Is x nan or inf?
// qnan snan inf norm     unorm 0 -+
// 1    1    1   0        0     0 11 = 0xe3 NAN_INF
// Form biased exponent where input only has an integer part
{ .mfi
      nop.m 999
      fclass.m.unc p6,p13 = f8, 0xe3
      addl modf_GR_no_frac = 0x10033, r0 ;;
}

// Mask to get exponent
// Is x unnorm?
// qnan snan inf norm     unorm 0 -+
// 0    0    0   0        1     0 11 = 0x0b UNORM
// Set p13 to indicate calculation path, else p6 if nan or inf 
{ .mfi
      and       modf_exp = modf_17_ones, modf_signexp 
      fclass.m.unc p8,p0 = f8, 0x0b
      nop.i 999 ;;
}

// p11 <== SMALL, no integer part, fraction is everyting
// p9  <== HUGE,  no fraction part, integer is everything
// p12 <== NORMAL, fraction part and integer part
{ .mii
(p13) cmp.lt.unc p11,p10 = modf_exp, modf_GR_FFFF
      nop.i 999
      nop.i 999 ;;
}

// Is x inf? p6 if inf, p7 if nan
{ .mfb
(p10) cmp.ge.unc p9,p12  = modf_exp, modf_GR_no_frac
(p6)  fclass.m.unc p6,p7 = f8, 0x23
(p8)  br.cond.spnt MODF_DENORM ;;
}

MODF_COMMON:
// For HUGE set fraction to signed 0
{ .mfi
      nop.m 999
(p9)  fmerge.s f8 = f8,f0
      nop.i 999
}
// For HUGE set integer part to normalized input
{ .mfi
      nop.m 999
(p9)  fnorm.d MODF_INTEGER_PART = MODF_NORM_F8
      nop.i 999 ;;
}

// For SMALL set fraction to normalized input, integer part to signed 0
{ .mfi
      nop.m 999
(p11) fmerge.s MODF_INTEGER_PART = f8,f0
      nop.i 999
}
{ .mfi
      nop.m 999
(p11) fnorm.d f8 = MODF_NORM_F8
      nop.i 999 ;;
}

// For NORMAL float the integer part
{ .mfi
      nop.m 999
(p12) fcvt.xf    MODF_INTEGER_PART = MODF_INT_INTEGER_PART
      nop.i 999 ;;
}

// If x inf set integer part to INF, fraction to signed 0
{ .mfi
(p6)  stfd [r33] = MODF_NORM_F8
(p6)  fmerge.s  f8 = f8,f0
      nop.i 999 ;;
}

// If x nan set integer and fraction parts to NaN (quietized)
{ .mfi
(p7)  stfd [r33] = MODF_NORM_F8
(p7)  fmerge.s  f8 = MODF_NORM_F8, MODF_NORM_F8
      nop.i 999 ;;
}

{ .mmi
(p9)  stfd [r33] = MODF_INTEGER_PART
      nop.m 999
      nop.i 999 ;;
}

// For NORMAL compute fraction part
{ .mfi
(p11) stfd [r33] = MODF_INTEGER_PART
(p12) fms.d.s0   f8 = MODF_NORM_F8,f1, MODF_INTEGER_PART
      nop.i 999 ;;
}

// For NORMAL test if fraction part is zero; if so append correct sign
{ .mfi
      nop.m 999
(p12) fcmp.eq.unc p7,p0 = MODF_NORM_F8, MODF_INTEGER_PART
      nop.i 999 ;;
}

{ .mfi
(p12) stfd [r33] = MODF_INTEGER_PART
      nop.f 999
      nop.i 999 ;;
}

// For NORMAL if fraction part is zero append sign of input
{ .mfb
      nop.m 999
(p7)  fmerge.s f8 = MODF_NORM_F8, f0
      br.ret.sptk    b0 ;;
}

MODF_DENORM:
// If x unorm get signexp from normalized input
// If x unorm get integer part from normalized input
{ .mfi
      getf.exp  modf_signexp = MODF_NORM_F8
      fcvt.fx.trunc.s1  MODF_INT_INTEGER_PART   = MODF_NORM_F8
      nop.i 999 ;;
}

// If x unorm mask to get exponent
{ .mmi
      and       modf_exp = modf_17_ones, modf_signexp ;;
      cmp.lt.unc p11,p10 = modf_exp, modf_GR_FFFF
      nop.i 999 ;;
}

{ .mfb
(p10) cmp.ge.unc p9,p12  = modf_exp, modf_GR_no_frac
      nop.f 999
      br.cond.spnt MODF_COMMON ;;
}

.endp modf
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\ia64\libm_tan.s ===
.file "libm_tan.s"

// Copyright (c) 2000, Intel Corporation
// All rights reserved.
// 
// Contributed 2/2/2000 by John Harrison, Ted Kubaska, Bob Norin, Shane Story,
// and Ping Tak Peter Tang of the Computational Software Lab, Intel Corporation.
// 
// WARRANTY DISCLAIMER
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS 
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY 
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
// 
// Intel Corporation is the author of this code, and requests that all
// problem reports or change requests be submitted to it directly at 
// http://developer.intel.com/opensource.
//
//*********************************************************************
//
// History:  
// 02/02/00 Initial Version 
// 4/04/00  Unwind support added
//
//*********************************************************************
//
// Function:   tan(x) = tangent(x), for double precision x values
//
//*********************************************************************
//
// Accuracy:       Very accurate for double-precision values  
//
//*********************************************************************
//
// Resources Used:
//
//    Floating-Point Registers: f8 (Input and Return Value)
//                              f9-f15
//                              f32-f112
//
//    General Purpose Registers:
//      r32-r48
//      r49-r50 (Used to pass arguments to pi_by_2 reduce routine)
//
//    Predicate Registers:      p6-p15
//
//*********************************************************************
//
// IEEE Special Conditions:
//
//    Denormal  fault raised on denormal inputs
//    Overflow exceptions do not occur
//    Underflow exceptions raised when appropriate for tan 
//    (No specialized error handling for this routine)
//    Inexact raised when appropriate by algorithm
//
//    tan(SNaN) = QNaN
//    tan(QNaN) = QNaN
//    tan(inf) = QNaN
//    tan(+/-0) = +/-0
//
//*********************************************************************
//
// Mathematical Description
//
// We consider the computation of FPTAN of Arg. Now, given
//
//      Arg = N pi/2  + alpha,          |alpha| <= pi/4,
//
// basic mathematical relationship shows that
//
//      tan( Arg ) =  tan( alpha )     if N is even;
//                 = -cot( alpha )      otherwise.
//
// The value of alpha is obtained by argument reduction and
// represented by two working precision numbers r and c where
//
//      alpha =  r  +  c     accurately.
//
// The reduction method is described in a previous write up.
// The argument reduction scheme identifies 4 cases. For Cases 2
// and 4, because |alpha| is small, tan(r+c) and -cot(r+c) can be
// computed very easily by 2 or 3 terms of the Taylor series
// expansion as follows:
//
// Case 2:
// -------
//
//      tan(r + c) = r + c + r^3/3          ...accurately
//        -cot(r + c) = -1/(r+c) + r/3          ...accurately
//
// Case 4:
// -------
//
//      tan(r + c) = r + c + r^3/3 + 2r^5/15     ...accurately
//        -cot(r + c) = -1/(r+c) + r/3 + r^3/45     ...accurately
//
//
// The only cases left are Cases 1 and 3 of the argument reduction
// procedure. These two cases will be merged since after the
// argument is reduced in either cases, we have the reduced argument
// represented as r + c and that the magnitude |r + c| is not small
// enough to allow the usage of a very short approximation.
//
// The greatest challenge of this task is that the second terms of
// the Taylor series for tan(r) and -cot(r)
//
//      r + r^3/3 + 2 r^5/15 + ...
//
// and
//
//      -1/r + r/3 + r^3/45 + ...
//
// are not very small when |r| is close to pi/4 and the rounding
// errors will be a concern if simple polynomial accumulation is
// used. When |r| < 2^(-2), however, the second terms will be small
// enough (5 bits or so of right shift) that a normal Horner
// recurrence suffices. Hence there are two cases that we consider
// in the accurate computation of tan(r) and cot(r), |r| <= pi/4.
//
// Case small_r: |r| < 2^(-2)
// --------------------------
//
// Since Arg = N pi/4 + r + c accurately, we have
//
//      tan(Arg) =  tan(r+c)            for N even,
//            = -cot(r+c)          otherwise.
//
// Here for this case, both tan(r) and -cot(r) can be approximated
// by simple polynomials:
//
//      tan(r) =    r + P1_1 r^3 + P1_2 r^5 + ... + P1_9 r^19
//        -cot(r) = -1/r + Q1_1 r   + Q1_2 r^3 + ... + Q1_7 r^13
//
// accurately. Since |r| is relatively small, tan(r+c) and
// -cot(r+c) can be accurately approximated by replacing r with
// r+c only in the first two terms of the corresponding polynomials.
//
// Note that P1_1 (and Q1_1 for that matter) approximates 1/3 to
// almost 64 sig. bits, thus
//
//      P1_1 (r+c)^3 =  P1_1 r^3 + c * r^2     accurately.
//
// Hence,
//
//      tan(r+c) =    r + P1_1 r^3 + P1_2 r^5 + ... + P1_9 r^19
//                     + c*(1 + r^2)
//
//        -cot(r+c) = -1/(r+c) + Q1_1 r   + Q1_2 r^3 + ... + Q1_7 r^13
//               + Q1_1*c
//
//
// Case normal_r: 2^(-2) <= |r| <= pi/4
// ------------------------------------
//
// This case is more likely than the previous one if one considers
// r to be uniformly distributed in [-pi/4 pi/4].
//
// The required calculation is either
//
//      tan(r + c)  =  tan(r)  +  correction,  or
//        -cot(r + c)  = -cot(r)  +  correction.
//
// Specifically,
//
//      tan(r + c) =  tan(r) + c tan'(r)  + O(c^2)
//              =  tan(r) + c sec^2(r) + O(c^2)
//              =  tan(r) + c SEC_sq     ...accurately
//                as long as SEC_sq approximates sec^2(r)
//                to, say, 5 bits or so.
//
// Similarly,
//
//        -cot(r + c) = -cot(r) - c cot'(r)  + O(c^2)
//              = -cot(r) + c csc^2(r) + O(c^2)
//              = -cot(r) + c CSC_sq     ...accurately
//                as long as CSC_sq approximates csc^2(r)
//                to, say, 5 bits or so.
//
// We therefore concentrate on accurately calculating tan(r) and
// cot(r) for a working-precision number r, |r| <= pi/4 to within
// 0.1% or so.
//
// We will employ a table-driven approach. Let
//
//      r = sgn_r * 2^k * 1.b_1 b_2 ... b_5 ... b_63
//        = sgn_r * ( B + x )
//
// where
//
//      B = 2^k * 1.b_1 b_2 ... b_5 1
//         x = |r| - B
//
// Now,
//                   tan(B)  +   tan(x)
//      tan( B + x ) =  ------------------------
//                   1 -  tan(B)*tan(x)
//
//               /                         \
//               |   tan(B)  +   tan(x)          |

//      = tan(B) +  | ------------------------ - tan(B) |
//               |     1 -  tan(B)*tan(x)          |
//               \                         /
//
//                 sec^2(B) * tan(x)
//      = tan(B) + ------------------------
//                 1 -  tan(B)*tan(x)
//
//                (1/[sin(B)*cos(B)]) * tan(x)
//      = tan(B) + --------------------------------
//                      cot(B)  -  tan(x)
//
//
// Clearly, the values of tan(B), cot(B) and 1/(sin(B)*cos(B)) are
// calculated beforehand and stored in a table. Since
//
//      |x| <= 2^k * 2^(-6)  <= 2^(-7)  (because k = -1, -2)
//
// a very short polynomial will be sufficient to approximate tan(x)
// accurately. The details involved in computing the last expression
// will be given in the next section on algorithm description.
//
//
// Now, we turn to the case where cot( B + x ) is needed.
//
//
//                   1 - tan(B)*tan(x)
//      cot( B + x ) =  ------------------------
//                   tan(B)  +  tan(x)
//
//               /                           \
//               |   1 - tan(B)*tan(x)              |

//      = cot(B) +  | ----------------------- - cot(B) |
//               |     tan(B)  +  tan(x)            |
//               \                           /
//
//               [tan(B) + cot(B)] * tan(x)
//      = cot(B) - ----------------------------
//                   tan(B)  +  tan(x)
//
//                (1/[sin(B)*cos(B)]) * tan(x)
//      = cot(B) - --------------------------------
//                      tan(B)  +  tan(x)
//
//
// Note that the values of tan(B), cot(B) and 1/(sin(B)*cos(B)) that
// are needed are the same set of values needed in the previous
// case.
//
// Finally, we can put all the ingredients together as follows:
//
//      Arg = N * pi/2 +  r + c          ...accurately
//
//      tan(Arg) =  tan(r) + correction    if N is even;
//            = -cot(r) + correction    otherwise.
//
// For Cases 2 and 4,
//
//     Case 2:
//     tan(Arg) =  tan(r + c) = r + c + r^3/3           N even
//              = -cot(r + c) = -1/(r+c) + r/3           N odd
//     Case 4:
//     tan(Arg) =  tan(r + c) = r + c + r^3/3 + 2r^5/15  N even
//              = -cot(r + c) = -1/(r+c) + r/3 + r^3/45  N odd
//
//
// For Cases 1 and 3,
//
//     Case small_r: |r| < 2^(-2)
//
//      tan(Arg) =  r + P1_1 r^3 + P1_2 r^5 + ... + P1_9 r^19
//                     + c*(1 + r^2)               N even
//
//                  = -1/(r+c) + Q1_1 r   + Q1_2 r^3 + ... + Q1_7 r^13
//               + Q1_1*c                    N odd
//
//     Case normal_r: 2^(-2) <= |r| <= pi/4
//
//      tan(Arg) =  tan(r) + c * sec^2(r)     N even
//               = -cot(r) + c * csc^2(r)     otherwise
//
//     For N even,
//
//      tan(Arg) = tan(r) + c*sec^2(r)
//               = tan( sgn_r * (B+x) ) + c * sec^2(|r|)
//                  = sgn_r * ( tan(B+x)  + sgn_r*c*sec^2(|r|) )
//                  = sgn_r * ( tan(B+x)  + sgn_r*c*sec^2(B) )
//
// since B approximates |r| to 2^(-6) in relative accuracy.
//
//                 /            (1/[sin(B)*cos(B)]) * tan(x)
//    tan(Arg) = sgn_r * | tan(B) + --------------------------------
//                 \                     cot(B)  -  tan(x)
//                                        \
//                       + CORR  |

//                                     /
// where
//
//    CORR = sgn_r*c*tan(B)*SC_inv(B);  SC_inv(B) = 1/(sin(B)*cos(B)).
//
// For N odd,
//
//      tan(Arg) = -cot(r) + c*csc^2(r)
//               = -cot( sgn_r * (B+x) ) + c * csc^2(|r|)
//                  = sgn_r * ( -cot(B+x)  + sgn_r*c*csc^2(|r|) )
//                  = sgn_r * ( -cot(B+x)  + sgn_r*c*csc^2(B) )
//
// since B approximates |r| to 2^(-6) in relative accuracy.
//
//                 /            (1/[sin(B)*cos(B)]) * tan(x)
//    tan(Arg) = sgn_r * | -cot(B) + --------------------------------
//                 \                     tan(B)  +  tan(x)
//                                        \
//                       + CORR  |

//                                     /
// where
//
//    CORR = sgn_r*c*cot(B)*SC_inv(B);  SC_inv(B) = 1/(sin(B)*cos(B)).
//
//
// The actual algorithm prescribes how all the mathematical formulas
// are calculated.
//
//
// 2. Algorithmic Description
// ==========================
//
// 2.1 Computation for Cases 2 and 4.
// ----------------------------------
//
// For Case 2, we use two-term polynomials.
//
//    For N even,
//
//    rsq := r * r
//    Result := c + r * rsq * P1_1
//    Result := r + Result          ...in user-defined rounding
//
//    For N odd,
//    S_hi  := -frcpa(r)               ...8 bits
//    S_hi  := S_hi + S_hi*(1 + S_hi*r)     ...16 bits
//    S_hi  := S_hi + S_hi*(1 + S_hi*r)     ...32 bits
//    S_hi  := S_hi + S_hi*(1 + S_hi*r)     ...64 bits
//    S_lo  := S_hi*( (1 + S_hi*r) + S_hi*c )
//    ...S_hi + S_lo is -1/(r+c) to extra precision
//    S_lo  := S_lo + Q1_1*r
//
//    Result := S_hi + S_lo     ...in user-defined rounding
//
// For Case 4, we use three-term polynomials
//
//    For N even,
//
//    rsq := r * r
//    Result := c + r * rsq * (P1_1 + rsq * P1_2)
//    Result := r + Result          ...in user-defined rounding
//
//    For N odd,
//    S_hi  := -frcpa(r)               ...8 bits
//    S_hi  := S_hi + S_hi*(1 + S_hi*r)     ...16 bits
//    S_hi  := S_hi + S_hi*(1 + S_hi*r)     ...32 bits
//    S_hi  := S_hi + S_hi*(1 + S_hi*r)     ...64 bits
//    S_lo  := S_hi*( (1 + S_hi*r) + S_hi*c )
//    ...S_hi + S_lo is -1/(r+c) to extra precision
//    rsq   := r * r
//    P      := Q1_1 + rsq*Q1_2
//    S_lo  := S_lo + r*P
//
//    Result := S_hi + S_lo     ...in user-defined rounding
//
//
// Note that the coefficients P1_1, P1_2, Q1_1, and Q1_2 are
// the same as those used in the small_r case of Cases 1 and 3
// below.
//
//
// 2.2 Computation for Cases 1 and 3.
// ----------------------------------
// This is further divided into the case of small_r,
// where |r| < 2^(-2), and the case of normal_r, where |r| lies between
// 2^(-2) and pi/4.
//
// Algorithm for the case of small_r
// ---------------------------------
//
// For N even,
//      rsq   := r * r
//      Poly1 := rsq*(P1_1 + rsq*(P1_2 + rsq*P1_3))
//      r_to_the_8    := rsq * rsq
//      r_to_the_8    := r_to_the_8 * r_to_the_8
//      Poly2 := P1_4 + rsq*(P1_5 + rsq*(P1_6 + ... rsq*P1_9))
//      CORR  := c * ( 1 + rsq )
//      Poly  := Poly1 + r_to_the_8*Poly2
//      Result := r*Poly + CORR
//      Result := r + Result     ...in user-defined rounding
//      ...note that Poly1 and r_to_the_8 can be computed in parallel
//      ...with Poly2 (Poly1 is intentionally set to be much
//      ...shorter than Poly2 so that r_to_the_8 and CORR can be hidden)
//
// For N odd,
//      S_hi  := -frcpa(r)               ...8 bits
//      S_hi  := S_hi + S_hi*(1 + S_hi*r)     ...16 bits
//      S_hi  := S_hi + S_hi*(1 + S_hi*r)     ...32 bits
//      S_hi  := S_hi + S_hi*(1 + S_hi*r)     ...64 bits
//      S_lo  := S_hi*( (1 + S_hi*r) + S_hi*c )
//      ...S_hi + S_lo is -1/(r+c) to extra precision
//      S_lo  := S_lo + Q1_1*c
//
//      ...S_hi and S_lo are computed in parallel with
//      ...the following
//      rsq := r*r
//      P   := Q1_1 + rsq*(Q1_2 + rsq*(Q1_3 + ... + rsq*Q1_7))
//
//      Result :=  r*P + S_lo
//      Result :=  S_hi  +  Result      ...in user-defined rounding
//
//
// Algorithm for the case of normal_r
// ----------------------------------
//
// Here, we first consider the computation of tan( r + c ). As
// presented in the previous section,
//
//      tan( r + c )  =  tan(r) + c * sec^2(r)
//                 =  sgn_r * [ tan(B+x) + CORR ]
//      CORR = sgn_r * c * tan(B) * 1/[sin(B)*cos(B)]
//
// because sec^2(r) = sec^(|r|), and B approximate |r| to 6.5 bits.
//
//      tan( r + c ) =
//           /           (1/[sin(B)*cos(B)]) * tan(x)
//      sgn_r * | tan(B) + --------------------------------  +
//           \                     cot(B)  -  tan(x)
//                                \
//                          CORR  |

//                                /
//
// The values of tan(B), cot(B) and 1/(sin(B)*cos(B)) are
// calculated beforehand and stored in a table. Specifically,
// the table values are
//
//      tan(B)                as  T_hi  +  T_lo;
//      cot(B)             as  C_hi  +  C_lo;
//      1/[sin(B)*cos(B)]  as  SC_inv
//
// T_hi, C_hi are in  double-precision  memory format;
// T_lo, C_lo are in  single-precision  memory format;
// SC_inv     is  in extended-precision memory format.
//
// The value of tan(x) will be approximated by a short polynomial of
// the form
//
//      tan(x)  as  x  +  x * P, where
//           P  =   x^2 * (P2_1 + x^2 * (P2_2 + x^2 * P2_3))
//
// Because |x| <= 2^(-7), cot(B) - x approximates cot(B) - tan(x)
// to a relative accuracy better than 2^(-20). Thus, a good
// initial guess of 1/( cot(B) - tan(x) ) to initiate the iterative
// division is:
//
//      1/(cot(B) - tan(x))      is approximately
//      1/(cot(B) -   x)         is
//      tan(B)/(1 - x*tan(B))    is approximately
//      T_hi / ( 1 - T_hi * x )  is approximately
//
//      T_hi * [ 1 + (Thi * x) + (T_hi * x)^2 ]
//
// The calculation of tan(r+c) therefore proceed as follows:
//
//      Tx     := T_hi * x
//      xsq     := x * x
//
//      V_hi     := T_hi*(1 + Tx*(1 + Tx))
//      P     := xsq * (P1_1 + xsq*(P1_2 + xsq*P1_3))
//      ...V_hi serves as an initial guess of 1/(cot(B) - tan(x))
//         ...good to about 20 bits of accuracy
//
//      tanx     := x + x*P
//      D     := C_hi - tanx
//      ...D is a double precision denominator: cot(B) - tan(x)
//
//      V_hi     := V_hi + V_hi*(1 - V_hi*D)
//      ....V_hi approximates 1/(cot(B)-tan(x)) to 40 bits
//
//      V_lo     := V_hi * ( [ (1 - V_hi*C_hi) + V_hi*tanx ]
//                           - V_hi*C_lo )   ...observe all order
//         ...V_hi + V_lo approximates 1/(cot(B) - tan(x))
//      ...to extra accuracy
//
//      ...               SC_inv(B) * (x + x*P)
//      ...   tan(B) +      ------------------------- + CORR
//         ...                cot(B) - (x + x*P)
//      ...
//      ... = tan(B) + SC_inv(B)*(x + x*P)*(V_hi + V_lo) + CORR
//      ...
//
//      Sx     := SC_inv * x
//      CORR     := sgn_r * c * SC_inv * T_hi
//
//      ...put the ingredients together to compute
//      ...               SC_inv(B) * (x + x*P)
//      ...   tan(B) +      ------------------------- + CORR
//         ...                cot(B) - (x + x*P)
//      ...
//      ... = tan(B) + SC_inv(B)*(x + x*P)*(V_hi + V_lo) + CORR
//      ...
//      ... = T_hi + T_lo + CORR +
//      ...    Sx * V_hi + Sx * V_lo + Sx * P *(V_hi + V_lo)
//
//      CORR := CORR + T_lo
//      tail := V_lo + P*(V_hi + V_lo)
//         tail := Sx * tail  +  CORR
//      tail := Sx * V_hi  +  tail
//         T_hi := sgn_r * T_hi
//
//         ...T_hi + sgn_r*tail  now approximate
//      ...sgn_r*(tan(B+x) + CORR) accurately
//
//      Result :=  T_hi + sgn_r*tail  ...in user-defined
//                           ...rounding control
//      ...It is crucial that independent paths be fully
//      ...exploited for performance's sake.
//
//
// Next, we consider the computation of -cot( r + c ). As
// presented in the previous section,
//
//        -cot( r + c )  =  -cot(r) + c * csc^2(r)
//                 =  sgn_r * [ -cot(B+x) + CORR ]
//      CORR = sgn_r * c * cot(B) * 1/[sin(B)*cos(B)]
//
// because csc^2(r) = csc^(|r|), and B approximate |r| to 6.5 bits.
//
//        -cot( r + c ) =
//           /             (1/[sin(B)*cos(B)]) * tan(x)
//      sgn_r * | -cot(B) + --------------------------------  +
//           \                     tan(B)  +  tan(x)
//                                \
//                          CORR  |

//                                /
//
// The values of tan(B), cot(B) and 1/(sin(B)*cos(B)) are
// calculated beforehand and stored in a table. Specifically,
// the table values are
//
//      tan(B)                as  T_hi  +  T_lo;
//      cot(B)             as  C_hi  +  C_lo;
//      1/[sin(B)*cos(B)]  as  SC_inv
//
// T_hi, C_hi are in  double-precision  memory format;
// T_lo, C_lo are in  single-precision  memory format;
// SC_inv     is  in extended-precision memory format.
//
// The value of tan(x) will be approximated by a short polynomial of
// the form
//
//      tan(x)  as  x  +  x * P, where
//           P  =   x^2 * (P2_1 + x^2 * (P2_2 + x^2 * P2_3))
//
// Because |x| <= 2^(-7), tan(B) + x approximates tan(B) + tan(x)
// to a relative accuracy better than 2^(-18). Thus, a good
// initial guess of 1/( tan(B) + tan(x) ) to initiate the iterative
// division is:
//
//      1/(tan(B) + tan(x))      is approximately
//      1/(tan(B) +   x)         is
//      cot(B)/(1 + x*cot(B))    is approximately
//      C_hi / ( 1 + C_hi * x )  is approximately
//
//      C_hi * [ 1 - (C_hi * x) + (C_hi * x)^2 ]
//
// The calculation of -cot(r+c) therefore proceed as follows:
//
//      Cx     := C_hi * x
//      xsq     := x * x
//
//      V_hi     := C_hi*(1 - Cx*(1 - Cx))
//      P     := xsq * (P1_1 + xsq*(P1_2 + xsq*P1_3))
//      ...V_hi serves as an initial guess of 1/(tan(B) + tan(x))
//         ...good to about 18 bits of accuracy
//
//      tanx     := x + x*P
//      D     := T_hi + tanx
//      ...D is a double precision denominator: tan(B) + tan(x)
//
//      V_hi     := V_hi + V_hi*(1 - V_hi*D)
//      ....V_hi approximates 1/(tan(B)+tan(x)) to 40 bits
//
//      V_lo     := V_hi * ( [ (1 - V_hi*T_hi) - V_hi*tanx ]
//                           - V_hi*T_lo )   ...observe all order
//         ...V_hi + V_lo approximates 1/(tan(B) + tan(x))
//      ...to extra accuracy
//
//      ...               SC_inv(B) * (x + x*P)
//      ...  -cot(B) +      ------------------------- + CORR
//         ...                tan(B) + (x + x*P)
//      ...
//      ... =-cot(B) + SC_inv(B)*(x + x*P)*(V_hi + V_lo) + CORR
//      ...
//
//      Sx     := SC_inv * x
//      CORR     := sgn_r * c * SC_inv * C_hi
//
//      ...put the ingredients together to compute
//      ...               SC_inv(B) * (x + x*P)
//      ...  -cot(B) +      ------------------------- + CORR
//         ...                tan(B) + (x + x*P)
//      ...
//      ... =-cot(B) + SC_inv(B)*(x + x*P)*(V_hi + V_lo) + CORR
//      ...
//      ... =-C_hi - C_lo + CORR +
//      ...    Sx * V_hi + Sx * V_lo + Sx * P *(V_hi + V_lo)
//
//      CORR := CORR - C_lo
//      tail := V_lo + P*(V_hi + V_lo)
//         tail := Sx * tail  +  CORR
//      tail := Sx * V_hi  +  tail
//         C_hi := -sgn_r * C_hi
//
//         ...C_hi + sgn_r*tail now approximates
//      ...sgn_r*(-cot(B+x) + CORR) accurately
//
//      Result :=  C_hi + sgn_r*tail   in user-defined rounding control
//      ...It is crucial that independent paths be fully
//      ...exploited for performance's sake.
//
// 3. Implementation Notes
// =======================
//
//   Table entries T_hi, T_lo; C_hi, C_lo; SC_inv
//
//   Recall that 2^(-2) <= |r| <= pi/4;
//
//      r = sgn_r * 2^k * 1.b_1 b_2 ... b_63
//
//   and
//
//        B = 2^k * 1.b_1 b_2 b_3 b_4 b_5 1
//
//   Thus, for k = -2, possible values of B are
//
//          B = 2^(-2) * ( 1 + index/32  +  1/64 ),
//      index ranges from 0 to 31
//
//   For k = -1, however, since |r| <= pi/4 = 0.78...
//   possible values of B are
//
//        B = 2^(-1) * ( 1 + index/32  +  1/64 )
//      index ranges from 0 to 19.
//
//

.data

.align 128

TAN_BASE_CONSTANTS:
data4    0x4B800000, 0xCB800000, 0x38800000, 0xB8800000 // two**24, -two**24
                                                        // two**-14, -two**-14
data4    0x4E44152A, 0xA2F9836E, 0x00003FFE, 0x00000000 // two_by_pi
data4    0xCE81B9F1, 0xC84D32B0, 0x00004016, 0x00000000 // P_0
data4    0x2168C235, 0xC90FDAA2, 0x00003FFF, 0x00000000 // P_1
data4    0xFC8F8CBB, 0xECE675D1, 0x0000BFBD, 0x00000000 // P_2
data4    0xACC19C60, 0xB7ED8FBB, 0x0000BF7C, 0x00000000 // P_3
data4    0x5F000000, 0xDF000000, 0x00000000, 0x00000000 // two_to_63, -two_to_63
data4    0x6EC6B45A, 0xA397E504, 0x00003FE7, 0x00000000 // Inv_P_0
data4    0xDBD171A1, 0x8D848E89, 0x0000BFBF, 0x00000000 // d_1
data4    0x18A66F8E, 0xD5394C36, 0x0000BF7C, 0x00000000 // d_2
data4    0x2168C234, 0xC90FDAA2, 0x00003FFE, 0x00000000 // PI_BY_4
data4    0x2168C234, 0xC90FDAA2, 0x0000BFFE, 0x00000000 // MPI_BY_4
data4    0x3E800000, 0xBE800000, 0x00000000, 0x00000000 // two**-2, -two**-2
data4    0x2F000000, 0xAF000000, 0x00000000, 0x00000000 // two**-33, -two**-33
data4    0xAAAAAABD, 0xAAAAAAAA, 0x00003FFD, 0x00000000 // P1_1
data4    0x88882E6A, 0x88888888, 0x00003FFC, 0x00000000 // P1_2
data4    0x0F0177B6, 0xDD0DD0DD, 0x00003FFA, 0x00000000 // P1_3
data4    0x646B8C6D, 0xB327A440, 0x00003FF9, 0x00000000 // P1_4
data4    0x1D5F7D20, 0x91371B25, 0x00003FF8, 0x00000000 // P1_5
data4    0x61C67914, 0xEB69A5F1, 0x00003FF6, 0x00000000 // P1_6
data4    0x019318D2, 0xBEDD37BE, 0x00003FF5, 0x00000000 // P1_7
data4    0x3C794015, 0x9979B146, 0x00003FF4, 0x00000000 // P1_8
data4    0x8C6EB58A, 0x8EBD21A3, 0x00003FF3, 0x00000000 // P1_9
data4    0xAAAAAAB4, 0xAAAAAAAA, 0x00003FFD, 0x00000000 // Q1_1
data4    0x0B5FC93E, 0xB60B60B6, 0x00003FF9, 0x00000000 // Q1_2
data4    0x0C9BBFBF, 0x8AB355E0, 0x00003FF6, 0x00000000 // Q1_3
data4    0xCBEE3D4C, 0xDDEBBC89, 0x00003FF2, 0x00000000 // Q1_4
data4    0x5F80BBB6, 0xB3548A68, 0x00003FEF, 0x00000000 // Q1_5
data4    0x4CED5BF1, 0x91362560, 0x00003FEC, 0x00000000 // Q1_6
data4    0x8EE92A83, 0xF189D95A, 0x00003FE8, 0x00000000 // Q1_7
data4    0xAAAB362F, 0xAAAAAAAA, 0x00003FFD, 0x00000000 // P2_1
data4    0xE97A6097, 0x88888886, 0x00003FFC, 0x00000000 // P2_2
data4    0x25E716A1, 0xDD108EE0, 0x00003FFA, 0x00000000 // P2_3
//
//  Entries T_hi   double-precision memory format
//  Index = 0,1,...,31  B = 2^(-2)*(1+Index/32+1/64)
//  Entries T_lo  single-precision memory format
//  Index = 0,1,...,31  B = 2^(-2)*(1+Index/32+1/64)
//
data4    0x62400794, 0x3FD09BC3, 0x23A05C32, 0x00000000
data4    0xDFFBC074, 0x3FD124A9, 0x240078B2, 0x00000000
data4    0x5BD4920F, 0x3FD1AE23, 0x23826B8E, 0x00000000
data4    0x15E2701D, 0x3FD23835, 0x22D31154, 0x00000000
data4    0x63739C2D, 0x3FD2C2E4, 0x2265C9E2, 0x00000000
data4    0xAFEEA48B, 0x3FD34E36, 0x245C05EB, 0x00000000
data4    0x7DBB35D1, 0x3FD3DA31, 0x24749F2D, 0x00000000
data4    0x67321619, 0x3FD466DA, 0x2462CECE, 0x00000000
data4    0x1F94A4D5, 0x3FD4F437, 0x246D0DF1, 0x00000000
data4    0x740C3E6D, 0x3FD5824D, 0x240A85B5, 0x00000000
data4    0x4CB1E73D, 0x3FD61123, 0x23F96E33, 0x00000000
data4    0xAD9EA64B, 0x3FD6A0BE, 0x247C5393, 0x00000000
data4    0xB804FD01, 0x3FD73125, 0x241F3B29, 0x00000000
data4    0xAB53EE83, 0x3FD7C25E, 0x2479989B, 0x00000000
data4    0xE6640EED, 0x3FD8546F, 0x23B343BC, 0x00000000
data4    0xE8AF1892, 0x3FD8E75F, 0x241454D1, 0x00000000
data4    0x53928BDA, 0x3FD97B35, 0x238613D9, 0x00000000
data4    0xEB9DE4DE, 0x3FDA0FF6, 0x22859FA7, 0x00000000
data4    0x99ECF92D, 0x3FDAA5AB, 0x237A6D06, 0x00000000
data4    0x6D8F1796, 0x3FDB3C5A, 0x23952F6C, 0x00000000
data4    0x9CFB8BE4, 0x3FDBD40A, 0x2280FC95, 0x00000000
data4    0x87943100, 0x3FDC6CC3, 0x245D2EC0, 0x00000000
data4    0xB736C500, 0x3FDD068C, 0x23C4AD7D, 0x00000000
data4    0xE1DDBC31, 0x3FDDA16D, 0x23D076E6, 0x00000000
data4    0xEB515A93, 0x3FDE3D6E, 0x244809A6, 0x00000000
data4    0xE6E9E5F1, 0x3FDEDA97, 0x220856C8, 0x00000000
data4    0x1963CE69, 0x3FDF78F1, 0x244BE993, 0x00000000
data4    0x7D635BCE, 0x3FE00C41, 0x23D21799, 0x00000000
data4    0x1C302CD3, 0x3FE05CAB, 0x248A1B1D, 0x00000000
data4    0xDB6A1FA0, 0x3FE0ADB9, 0x23D53E33, 0x00000000
data4    0x4A20BA81, 0x3FE0FF72, 0x24DB9ED5, 0x00000000
data4    0x153FA6F5, 0x3FE151D9, 0x24E9E451, 0x00000000
//
//  Entries T_hi   double-precision memory format
//  Index = 0,1,...,19  B = 2^(-1)*(1+Index/32+1/64)
//  Entries T_lo  single-precision memory format
//  Index = 0,1,...,19  B = 2^(-1)*(1+Index/32+1/64)
//
data4    0xBA1BE39E, 0x3FE1CEC4, 0x24B60F9E, 0x00000000
data4    0x5ABD9B2D, 0x3FE277E4, 0x248C2474, 0x00000000
data4    0x0272B110, 0x3FE32418, 0x247B8311, 0x00000000
data4    0x890E2DF0, 0x3FE3D38B, 0x24C55751, 0x00000000
data4    0x46236871, 0x3FE4866D, 0x24E5BC34, 0x00000000
data4    0x45E044B0, 0x3FE53CEE, 0x24001BA4, 0x00000000
data4    0x82EC06E4, 0x3FE5F742, 0x24B973DC, 0x00000000
data4    0x25DF43F9, 0x3FE6B5A1, 0x24895440, 0x00000000
data4    0xCAFD348C, 0x3FE77844, 0x240021CA, 0x00000000
data4    0xCEED6B92, 0x3FE83F6B, 0x24C45372, 0x00000000
data4    0xA34F3665, 0x3FE90B58, 0x240DAD33, 0x00000000
data4    0x2C1E56B4, 0x3FE9DC52, 0x24F846CE, 0x00000000
data4    0x27041578, 0x3FEAB2A4, 0x2323FB6E, 0x00000000
data4    0x9DD8C373, 0x3FEB8E9F, 0x24B3090B, 0x00000000
data4    0x65C9AA7B, 0x3FEC709B, 0x2449F611, 0x00000000
data4    0xACCF8435, 0x3FED58F4, 0x23616A7E, 0x00000000
data4    0x97635082, 0x3FEE480F, 0x24C2FEAE, 0x00000000
data4    0xF0ACC544, 0x3FEF3E57, 0x242CE964, 0x00000000
data4    0xF7E06E4B, 0x3FF01E20, 0x2480D3EE, 0x00000000
data4    0x8A798A69, 0x3FF0A125, 0x24DB8967, 0x00000000
//
//  Entries C_hi   double-precision memory format
//  Index = 0,1,...,31  B = 2^(-2)*(1+Index/32+1/64)
//  Entries C_lo  single-precision memory format
//  Index = 0,1,...,31  B = 2^(-2)*(1+Index/32+1/64)
//
data4    0xE63EFBD0, 0x400ED3E2, 0x259D94D4, 0x00000000
data4    0xC515DAB5, 0x400DDDB4, 0x245F0537, 0x00000000
data4    0xBE19A79F, 0x400CF57A, 0x25D4EA9F, 0x00000000
data4    0xD15298ED, 0x400C1A06, 0x24AE40A0, 0x00000000
data4    0x164B2708, 0x400B4A4C, 0x25A5AAB6, 0x00000000
data4    0x5285B068, 0x400A855A, 0x25524F18, 0x00000000
data4    0x3FFA549F, 0x4009CA5A, 0x24C999C0, 0x00000000
data4    0x646AF623, 0x4009188A, 0x254FD801, 0x00000000
data4    0x6084D0E7, 0x40086F3C, 0x2560F5FD, 0x00000000
data4    0xA29A76EE, 0x4007CDD2, 0x255B9D19, 0x00000000
data4    0x6C8ECA95, 0x400733BE, 0x25CB021B, 0x00000000
data4    0x1F8DDC52, 0x4006A07E, 0x24AB4722, 0x00000000
data4    0xC298AD58, 0x4006139B, 0x252764E2, 0x00000000
data4    0xBAD7164B, 0x40058CAB, 0x24DAF5DB, 0x00000000
data4    0xAE31A5D3, 0x40050B4B, 0x25EA20F4, 0x00000000
data4    0x89F85A8A, 0x40048F21, 0x2583A3E8, 0x00000000
data4    0xA862380D, 0x400417DA, 0x25DCC4CC, 0x00000000
data4    0x1088FCFE, 0x4003A52B, 0x2430A492, 0x00000000
data4    0xCD3527D5, 0x400336CC, 0x255F77CF, 0x00000000
data4    0x5760766D, 0x4002CC7F, 0x25DA0BDA, 0x00000000
data4    0x11CE02E3, 0x40026607, 0x256FF4A2, 0x00000000
data4    0xD37BBE04, 0x4002032C, 0x25208AED, 0x00000000
data4    0x7F050775, 0x4001A3BD, 0x24B72DD6, 0x00000000
data4    0xA554848A, 0x40014789, 0x24AB4DAA, 0x00000000
data4    0x323E81B7, 0x4000EE65, 0x2584C440, 0x00000000
data4    0x21CF1293, 0x40009827, 0x25C9428D, 0x00000000
data4    0x3D415EEB, 0x400044A9, 0x25DC8482, 0x00000000
data4    0xBD72C577, 0x3FFFE78F, 0x257F5070, 0x00000000
data4    0x75EFD28E, 0x3FFF4AC3, 0x23EBBF7A, 0x00000000
data4    0x60B52DDE, 0x3FFEB2AF, 0x22EECA07, 0x00000000
data4    0x35204180, 0x3FFE1F19, 0x24191079, 0x00000000
data4    0x54F7E60A, 0x3FFD8FCA, 0x248D3058, 0x00000000
//
//  Entries C_hi   double-precision memory format
//  Index = 0,1,...,19  B = 2^(-1)*(1+Index/32+1/64)
//  Entries C_lo  single-precision memory format
//  Index = 0,1,...,19  B = 2^(-1)*(1+Index/32+1/64)
//
data4    0x79F6FADE, 0x3FFCC06A, 0x239C7886, 0x00000000
data4    0x891662A6, 0x3FFBB91F, 0x250BD191, 0x00000000
data4    0x529F155D, 0x3FFABFB6, 0x256CC3E6, 0x00000000
data4    0x2E964AE9, 0x3FF9D300, 0x250843E3, 0x00000000
data4    0x89DCB383, 0x3FF8F1EF, 0x2277C87E, 0x00000000
data4    0x7C87DBD6, 0x3FF81B93, 0x256DA6CF, 0x00000000
data4    0x1042EDE4, 0x3FF74F14, 0x2573D28A, 0x00000000
data4    0x1784B360, 0x3FF68BAF, 0x242E489A, 0x00000000
data4    0x7C923C4C, 0x3FF5D0B5, 0x2532D940, 0x00000000
data4    0xF418EF20, 0x3FF51D88, 0x253C7DD6, 0x00000000
data4    0x02F88DAE, 0x3FF4719A, 0x23DB59BF, 0x00000000
data4    0x49DA0788, 0x3FF3CC66, 0x252B4756, 0x00000000
data4    0x0B980DB8, 0x3FF32D77, 0x23FE585F, 0x00000000
data4    0xE56C987A, 0x3FF2945F, 0x25378A63, 0x00000000
data4    0xB16523F6, 0x3FF200BD, 0x247BB2E0, 0x00000000
data4    0x8CE27778, 0x3FF17235, 0x24446538, 0x00000000
data4    0xFDEFE692, 0x3FF0E873, 0x2514638F, 0x00000000
data4    0x33154062, 0x3FF0632C, 0x24A7FC27, 0x00000000
data4    0xB3EF115F, 0x3FEFC42E, 0x248FD0FE, 0x00000000
data4    0x135D26F6, 0x3FEEC9E8, 0x2385C719, 0x00000000
//
//  Entries SC_inv in Swapped IEEE format (extended)
//  Index = 0,1,...,31  B = 2^(-2)*(1+Index/32+1/64)
//
data4    0x1BF30C9E, 0x839D6D4A, 0x00004001, 0x00000000
data4    0x554B0EB0, 0x80092804, 0x00004001, 0x00000000
data4    0xA1CF0DE9, 0xF959F94C, 0x00004000, 0x00000000
data4    0x77378677, 0xF3086BA0, 0x00004000, 0x00000000
data4    0xCCD4723C, 0xED154515, 0x00004000, 0x00000000
data4    0x1C27CF25, 0xE7790944, 0x00004000, 0x00000000
data4    0x8DDACB88, 0xE22D037D, 0x00004000, 0x00000000
data4    0x89C73522, 0xDD2B2D8A, 0x00004000, 0x00000000
data4    0xBB2C1171, 0xD86E1A23, 0x00004000, 0x00000000
data4    0xDFF5E0F9, 0xD3F0E288, 0x00004000, 0x00000000
data4    0x283BEBD5, 0xCFAF16B1, 0x00004000, 0x00000000
data4    0x0D88DD53, 0xCBA4AFAA, 0x00004000, 0x00000000
data4    0xCA67C43D, 0xC7CE03CC, 0x00004000, 0x00000000
data4    0x0CA0DDB0, 0xC427BC82, 0x00004000, 0x00000000
data4    0xF13D8CAB, 0xC0AECD57, 0x00004000, 0x00000000
data4    0x71ECE6B1, 0xBD606C38, 0x00004000, 0x00000000
data4    0xA44C4929, 0xBA3A0A96, 0x00004000, 0x00000000
data4    0xE5CCCEC1, 0xB7394F6F, 0x00004000, 0x00000000
data4    0x9637D8BC, 0xB45C1203, 0x00004000, 0x00000000
data4    0x92CB051B, 0xB1A05528, 0x00004000, 0x00000000
data4    0x6BA2FFD0, 0xAF04432B, 0x00004000, 0x00000000
data4    0x7221235F, 0xAC862A23, 0x00004000, 0x00000000
data4    0x5F00A9D1, 0xAA2478AF, 0x00004000, 0x00000000
data4    0x81E082BF, 0xA7DDBB0C, 0x00004000, 0x00000000
data4    0x45684FEE, 0xA5B0987D, 0x00004000, 0x00000000
data4    0x627A8F53, 0xA39BD0F5, 0x00004000, 0x00000000
data4    0x6EC5C8B0, 0xA19E3B03, 0x00004000, 0x00000000
data4    0x91CD7C66, 0x9FB6C1F0, 0x00004000, 0x00000000
data4    0x1FA3DF8A, 0x9DE46410, 0x00004000, 0x00000000
data4    0xA8F6B888, 0x9C263139, 0x00004000, 0x00000000
data4    0xC27B0450, 0x9A7B4968, 0x00004000, 0x00000000
data4    0x5EE614EE, 0x98E2DB7E, 0x00004000, 0x00000000
//
//  Entries SC_inv in Swapped IEEE format (extended)
//  Index = 0,1,...,19  B = 2^(-1)*(1+Index/32+1/64)
//
data4    0x13B2B5BA, 0x969F335C, 0x00004000, 0x00000000
data4    0xD4C0F548, 0x93D446D9, 0x00004000, 0x00000000
data4    0x61B798AF, 0x9147094F, 0x00004000, 0x00000000
data4    0x758787AC, 0x8EF317CC, 0x00004000, 0x00000000
data4    0xB99EEFDB, 0x8CD498B3, 0x00004000, 0x00000000
data4    0xDFF8BC37, 0x8AE82A7D, 0x00004000, 0x00000000
data4    0xE3C55D42, 0x892AD546, 0x00004000, 0x00000000
data4    0xD15573C1, 0x8799FEA9, 0x00004000, 0x00000000
data4    0x435A4B4C, 0x86335F88, 0x00004000, 0x00000000
data4    0x3E93A87B, 0x84F4FB6E, 0x00004000, 0x00000000
data4    0x80A382FB, 0x83DD1952, 0x00004000, 0x00000000
data4    0xA4CB8C9E, 0x82EA3D7F, 0x00004000, 0x00000000
data4    0x6861D0A8, 0x821B247C, 0x00004000, 0x00000000
data4    0x63E8D244, 0x816EBED1, 0x00004000, 0x00000000
data4    0x27E4CFC6, 0x80E42D91, 0x00004000, 0x00000000
data4    0x28E64AFD, 0x807ABF8D, 0x00004000, 0x00000000
data4    0x863B4FD8, 0x8031EF26, 0x00004000, 0x00000000
data4    0xAE8C11FD, 0x800960AD, 0x00004000, 0x00000000
data4    0x5FDBEC21, 0x8000E147, 0x00004000, 0x00000000
data4    0xA07791FA, 0x80186650, 0x00004000, 0x00000000

Arg                 = f8   
Result              = f8
U_2                 = f10
rsq                =  f11
C_hi                = f12
C_lo                = f13
T_hi                = f14
T_lo                = f15

N_0                 = f32
d_1                 = f33
MPI_BY_4            = f34
tail                = f35
tanx                = f36
Cx                  = f37
Sx                  = f38
sgn_r               = f39
CORR                = f40
P                   = f41
D                   = f42
ArgPrime            = f43
P_0                 = f44

P2_1                = f45
P2_2                = f46
P2_3                = f47

P1_1                = f45
P1_2                = f46
P1_3                = f47

P1_4                = f48
P1_5                = f49
P1_6                = f50
P1_7                = f51
P1_8                = f52
P1_9                = f53

TWO_TO_63           = f54
NEGTWO_TO_63        = f55
x                   = f56
xsq                 = f57
Tx                  = f58
Tx1                 = f59
Set                 = f60
poly1               = f61
poly2               = f62
Poly                = f63
Poly1               = f64
Poly2               = f65
r_to_the_8          = f66
B                   = f67
SC_inv              = f68
Pos_r               = f69
N_0_fix             = f70
PI_BY_4             = f71
NEGTWO_TO_NEG2      = f72
TWO_TO_24           = f73
TWO_TO_NEG14        = f74
TWO_TO_NEG33        = f75
NEGTWO_TO_24        = f76
NEGTWO_TO_NEG14     = f76
NEGTWO_TO_NEG33     = f77
two_by_PI           = f78
N                   = f79
N_fix               = f80
P_1                 = f81
P_2                 = f82
P_3                 = f83
s_val               = f84
w                   = f85
c                   = f86
r                   = f87
Z                   = f88
A                   = f89
a                   = f90
t                   = f91
U_1                 = f92
d_2                 = f98
TWO_TO_NEG2         = f94
Q1_1                = f95
Q1_2                = f96
Q1_3                = f97
Q1_4                = f98
Q1_5                = f99
Q1_6                = f100
Q1_7                = f101
Q1_8                = f102
S_hi                = f103
S_lo                = f104
V_hi                = f105
V_lo                = f106
U_hi                = f107
U_lo                = f108
U_hiabs             = f109
V_hiabs             = f110
V                   = f111
Inv_P_0             = f112

GR_SAVE_B0     = r33
GR_SAVE_GP     = r34
GR_SAVE_PFS    = r35

delta1         = r36
table_ptr1     = r37
table_ptr2     = r38
i_0            = r39
i_1            = r40 
N_fix_gr       = r41 
N_inc          = r42 
exp_Arg        = r43 
exp_r          = r44 
sig_r          = r45 
lookup         = r46   
table_offset   = r47 
Create_B       = r48 

GR_Parameter_X = r49
GR_Parameter_r = r50



.global __libm_tan
.section .text
.proc __libm_tan


__libm_tan: 

{ .mfi
alloc r32 = ar.pfs, 0,17,2,0
(p0)   fclass.m.unc  p6,p0 = Arg, 0x1E7
       nop.i 999
}
;;

{ .mfi
       nop.m 999
(p0)   fclass.nm.unc  p7,p0 = Arg, 0x1FF
       nop.i 999
}
;;

{ .mfi
(p0)  addl           table_ptr1   = @ltoff(TAN_BASE_CONSTANTS), gp
       nop.f 999
       nop.i 999
}
;;

{ .mmi
      ld8 table_ptr1 = [table_ptr1]
      nop.m 999
      nop.i 999
}
;;

//
//     Check for NatVals, Infs , NaNs, and Zeros 
//     Check for everything - if false, then must be pseudo-zero
//     or pseudo-nan.
//     Local table pointer
//

{ .mbb
(p0)   add table_ptr2 = 96, table_ptr1
(p6)   br.cond.spnt __libm_TAN_SPECIAL 
(p7)   br.cond.spnt __libm_TAN_SPECIAL ;;
}
//
//     Point to Inv_P_0
//     Branch out to deal with unsupporteds and special values. 
//

{ .mmf
(p0)   ldfs TWO_TO_24 = [table_ptr1],4
(p0)   ldfs TWO_TO_63 = [table_ptr2],4
//
//     Load -2**24, load -2**63.
//
(p0)   fcmp.eq.s0 p0, p6 = Arg, f1 ;;
}

{ .mfi
(p0)   ldfs NEGTWO_TO_63 = [table_ptr2],12
(p0)   fnorm.s1     Arg = Arg
	nop.i 999
}
//
//     Load 2**24, Load 2**63.
//

{ .mmi
(p0)   ldfs NEGTWO_TO_24 = [table_ptr1],12 ;;
//
//     Do fcmp to generate Denormal exception 
//     - can't do FNORM (will generate Underflow when U is unmasked!)
//     Normalize input argument.
//
(p0)   ldfe two_by_PI = [table_ptr1],16
	nop.i 999
}

{ .mmi
(p0)   ldfe Inv_P_0 = [table_ptr2],16 ;;
(p0)   ldfe d_1 = [table_ptr2],16
	nop.i 999
}
//
//     Decide about the paths to take:
//     PR_1 and PR_3 set if -2**24 < Arg < 2**24 - CASE 1 OR 2
//     OTHERWISE - CASE 3 OR 4
//     Load inverse of P_0 .
//     Set PR_6 if Arg <= -2**63
//     Are there any Infs, NaNs, or zeros?
//

{ .mmi
(p0)   ldfe P_0 = [table_ptr1],16 ;;
(p0)   ldfe d_2 = [table_ptr2],16
	nop.i 999
}
//
//     Set PR_8 if Arg <= -2**24
//     Set PR_6 if Arg >=  2**63
//

{ .mmi
(p0)   ldfe P_1 = [table_ptr1],16 ;;
(p0)   ldfe PI_BY_4 = [table_ptr2],16
	nop.i 999
}
//
//     Set PR_8 if Arg >= 2**24
//

{ .mmi
(p0)   ldfe P_2 = [table_ptr1],16 ;;
(p0)   ldfe   MPI_BY_4 = [table_ptr2],16
	nop.i 999
}
//
//     Load  P_2 and PI_BY_4
//

{ .mfi
(p0)   ldfe   P_3 = [table_ptr1],16
	nop.f 999
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
(p0)   fcmp.le.unc.s1 p6,p7 = Arg,NEGTWO_TO_63
	nop.i 999
}

{ .mfi
	nop.m 999
(p0)   fcmp.le.unc.s1 p8,p9 = Arg,NEGTWO_TO_24
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
(p7)   fcmp.ge.s1 p6,p0 = Arg,TWO_TO_63
	nop.i 999
}

{ .mfi
	nop.m 999
(p9)   fcmp.ge.s1 p8,p0 = Arg,TWO_TO_24
	nop.i 999 ;;
}

{ .mib
	nop.m 999
	nop.i 999
//
//     Load  P_3 and -PI_BY_4
//
(p6)   br.cond.spnt TAN_ARG_TOO_LARGE ;;
}

{ .mib
	nop.m 999
	nop.i 999
//
//     Load 2**(-2).
//     Load -2**(-2).
//     Branch out if we have a special argument.
//     Branch out if the magnitude of the input argument is too large
//     - do this branch before the next.
//
(p8)   br.cond.spnt TAN_LARGER_ARG ;;
}
//
//     Branch to Cases 3 or 4 if Arg <= -2**24 or Arg >= 2**24
//

{ .mfi
(p0)   ldfs TWO_TO_NEG2 = [table_ptr2],4
//     ARGUMENT REDUCTION CODE - CASE 1 and 2
//     Load 2**(-2).
//     Load -2**(-2).
(p0)   fmpy.s1 N = Arg,two_by_PI
	nop.i 999 ;;
}

{ .mfi
(p0)   ldfs NEGTWO_TO_NEG2 = [table_ptr2],12
//
//     N = Arg * 2/pi
//
(p0)   fcmp.lt.unc.s1 p8,p9= Arg,PI_BY_4
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//     if Arg < pi/4,  set PR_8.
//
(p8)   fcmp.gt.s1 p8,p9= Arg,MPI_BY_4
	nop.i 999 ;;
}
//
//     Case 1: Is |r| < 2**(-2).
//     Arg is the same as r in this case.
//     r = Arg
//     c = 0
//

{ .mfi
(p8)   mov N_fix_gr = r0
//
//     if Arg > -pi/4, reset PR_8.
//     Select the case when |Arg| < pi/4 - set PR[8] = true.
//     Else Select the case when |Arg| >= pi/4 - set PR[9] = true.
//
(p0)   fcvt.fx.s1 N_fix = N
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//     Grab the integer part of N .
//
(p8)   mov r = Arg
	nop.i 999
}

{ .mfi
	nop.m 999
(p8)   mov c = f0
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
(p8)   fcmp.lt.unc.s1 p10, p11 = Arg, TWO_TO_NEG2
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
(p10)  fcmp.gt.s1 p10,p0 = Arg, NEGTWO_TO_NEG2
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//     Case 2: Place integer part of N in GP register.
//
(p9)   fcvt.xf N = N_fix
	nop.i 999 ;;
}

{ .mib
(p9)   getf.sig N_fix_gr = N_fix
	nop.i 999
//
//     Case 2: Convert integer N_fix back to normalized floating-point value.
//
(p10)  br.cond.spnt TAN_SMALL_R ;;
}

{ .mib
	nop.m 999
	nop.i 999
(p8)   br.cond.sptk TAN_NORMAL_R ;;
}
//
//     Case 1: PR_3 is only affected  when PR_1 is set.
//

{ .mmi
(p9)   ldfs TWO_TO_NEG33 = [table_ptr2], 4 ;;
//
//     Case 2: Load 2**(-33).
//
(p9)   ldfs NEGTWO_TO_NEG33 = [table_ptr2], 4
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//     Case 2: Load -2**(-33).
//
(p9)   fnma.s1 s_val = N, P_1, Arg
	nop.i 999
}

{ .mfi
	nop.m 999
(p9)   fmpy.s1 w = N, P_2
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//     Case 2: w = N * P_2
//     Case 2: s_val = -N * P_1  + Arg
//
(p0)   fcmp.lt.unc.s1 p9,p8 = s_val, TWO_TO_NEG33
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//     Decide between case_1 and case_2 reduce:
//
(p9)   fcmp.gt.s1 p9, p8 = s_val, NEGTWO_TO_NEG33
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//     Case 1_reduce:  s <= -2**(-33) or s >= 2**(-33)
//     Case 2_reduce: -2**(-33) < s < 2**(-33)
//
(p8)   fsub.s1 r = s_val, w
	nop.i 999
}

{ .mfi
	nop.m 999
(p9)   fmpy.s1 w = N, P_3
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
(p9)   fma.s1  U_1 = N, P_2, w
	nop.i 999
}

{ .mfi
	nop.m 999
//
//     Case 1_reduce: Is |r| < 2**(-2), if so set PR_10
//     else set PR_11.
//
(p8)   fsub.s1 c = s_val, r
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//     Case 1_reduce: r = s + w (change sign)
//     Case 2_reduce: w = N * P_3 (change sign)
//
(p8)   fcmp.lt.unc.s1 p10, p11 = r, TWO_TO_NEG2
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
(p10)  fcmp.gt.s1 p10, p11 = r, NEGTWO_TO_NEG2
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
(p9)   fsub.s1 r = s_val, U_1
	nop.i 999
}

{ .mfi
	nop.m 999
//
//     Case 1_reduce: c is complete here.
//     c = c + w (w has not been negated.)
//     Case 2_reduce: r is complete here - continue to calculate c .
//     r = s - U_1
//
(p9)   fms.s1 U_2 = N, P_2, U_1
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//     Case 1_reduce: c = s - r
//     Case 2_reduce: U_1 = N * P_2 + w
//
(p8)   fsub.s1 c = c, w
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
(p9)   fsub.s1 s_val = s_val, r
	nop.i 999
}

{ .mfb
	nop.m 999
//
//     Case 2_reduce:
//     U_2 = N * P_2 - U_1
//     Not needed until later.
//
(p9)   fadd.s1 U_2 = U_2, w
//
//     Case 2_reduce:
//     s = s - r
//     U_2 = U_2 + w
//
(p10)  br.cond.spnt TAN_SMALL_R ;;
}

{ .mib
	nop.m 999
	nop.i 999
(p11)  br.cond.sptk TAN_NORMAL_R ;;
}

{ .mii
	nop.m 999
//
//     Case 2_reduce:
//     c = c - U_2
//     c is complete here
//     Argument reduction ends here.
//
(p9)   extr.u i_1 = N_fix_gr, 0, 1 ;;
(p9)   cmp.eq.unc p11, p12 = 0x0000,i_1 ;;
}

{ .mfi
	nop.m 999
//
//     Is i_1  even or odd?
//     if i_1 == 0, set p11, else set p12.
//
(p11)  fmpy.s1 rsq = r, Z
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
(p12)  frcpa.s1 S_hi,p0 = f1, r
	nop.i 999
}

//
//     Case 1: Branch to SMALL_R or NORMAL_R.
//     Case 1 is done now.
//

{ .mfi
(p9)  addl           table_ptr1   = @ltoff(TAN_BASE_CONSTANTS), gp
(p9)   fsub.s1 c = s_val, U_1
	nop.i 999 ;;
}
;;

{ .mmi
(p9)  ld8 table_ptr1 = [table_ptr1]
      nop.m 999
      nop.i 999
}
;;

{ .mmi
(p9)   add table_ptr1 = 224, table_ptr1 ;;
(p9)   ldfe P1_1 = [table_ptr1],144
	nop.i 999 ;;
}
//
//     Get [i_1] -  lsb of N_fix_gr .
//     Load P1_1 and point to Q1_1 .
//

{ .mfi
(p9)   ldfe Q1_1 = [table_ptr1] , 0
//
//     N even: rsq = r * Z
//     N odd:  S_hi = frcpa(r)
//
(p12)  fmerge.ns S_hi = S_hi, S_hi
	nop.i 999
}

{ .mfi
	nop.m 999
//
//     Case 2_reduce:
//     c = s - U_1
//
(p9)   fsub.s1 c = c, U_2
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
(p12)  fma.s1  poly1 = S_hi, r, f1
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//     N odd:  Change sign of S_hi
//
(p11)  fmpy.s1 rsq = rsq, P1_1
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
(p12)  fma.s1 S_hi = S_hi, poly1, S_hi
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//     N even: rsq = rsq * P1_1
//     N odd:  poly1 =  1.0 +  S_hi * r    16 bits partial  account for necessary
//
(p11)  fma.s1 Result = r, rsq, c
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//     N even: Result = c  + r * rsq
//     N odd:  S_hi  = S_hi + S_hi*poly1  16 bits account for necessary
//
(p12)  fma.s1 poly1 = S_hi, r, f1
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//     N even: Result = Result + r
//     N odd:  poly1  = 1.0 + S_hi * r        32 bits partial
//
(p11)  fadd.s0 Result = r, Result
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
(p12)  fma.s1  S_hi = S_hi, poly1, S_hi
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//     N even: Result1 = Result + r
//     N odd:   S_hi  = S_hi * poly1 + S_hi   32 bits
//
(p12)  fma.s1 poly1 = S_hi, r, f1
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//     N odd:  poly1  =  S_hi * r + 1.0       64 bits partial
//
(p12)  fma.s1 S_hi = S_hi, poly1, S_hi
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//     N odd:  poly1  =  S_hi * poly + 1.0    64 bits
//
(p12)  fma.s1 poly1 = S_hi, r, f1
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//     N odd:  poly1  =  S_hi * r + 1.0
//
(p12)  fma.s1 poly1 = S_hi, c, poly1
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//     N odd:  poly1  =  S_hi * c + poly1
//
(p12)  fmpy.s1 S_lo = S_hi, poly1
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//     N odd:  S_lo  =  S_hi *  poly1
//
(p12)  fma.s1 S_lo = Q1_1, r, S_lo
	nop.i 999
}

{ .mfi
	nop.m 999
//
//     N odd:  Result =  S_hi + S_lo
//
(p0)   fmpy.s0 Q1_1 = Q1_1, Q1_1
	nop.i 999 ;;
}

{ .mfb
	nop.m 999
//
//     N odd:  S_lo  =  S_lo + Q1_1 * r
//
(p12)  fadd.s0 Result = S_hi, S_lo
//
//     Do a dummy multiply to raise inexact.
//
(p0)   br.ret.sptk b0 ;;
}
TAN_LARGER_ARG: 

{ .mmf
(p0)  addl           table_ptr1   = @ltoff(TAN_BASE_CONSTANTS), gp
      nop.m 999
(p0)  fmpy.s1 N_0 = Arg, Inv_P_0 
}
;;

//
// ARGUMENT REDUCTION CODE - CASE 3 and 4
//
//
//    Adjust table_ptr1 to beginning of table.
//    N_0 = Arg * Inv_P_0
//


{ .mmi
(p0)  ld8 table_ptr1 = [table_ptr1]
      nop.m 999
      nop.i 999
}
;;


{ .mmi
(p0)  add table_ptr1 = 8, table_ptr1 ;;
//
//    Point to  2*-14
//
(p0)  ldfs TWO_TO_NEG14 = [table_ptr1], 4
	nop.i 999 ;;
}
//
//    Load 2**(-14).
//

{ .mmi
(p0)  ldfs NEGTWO_TO_NEG14 = [table_ptr1], 180 ;;
//
//    N_0_fix  = integer part of N_0 .
//    Adjust table_ptr1 to beginning of table.
//
(p0)  ldfs TWO_TO_NEG2 = [table_ptr1], 4
	nop.i 999 ;;
}
//
//    Make N_0 the integer part.
//

{ .mfi
(p0)  ldfs NEGTWO_TO_NEG2 = [table_ptr1]
//
//    Load -2**(-14).
//
(p0)  fcvt.fx.s1 N_0_fix = N_0
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
(p0)  fcvt.xf N_0 = N_0_fix
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
(p0)  fnma.s1 ArgPrime = N_0, P_0, Arg
	nop.i 999
}

{ .mfi
	nop.m 999
(p0)  fmpy.s1 w = N_0, d_1
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//    ArgPrime = -N_0 * P_0 + Arg
//    w  = N_0 * d_1
//
(p0)  fmpy.s1 N = ArgPrime, two_by_PI
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//    N = ArgPrime * 2/pi
//
(p0)  fcvt.fx.s1 N_fix = N
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//    N_fix is the integer part.
//
(p0)  fcvt.xf N = N_fix
	nop.i 999 ;;
}

{ .mfi
(p0)  getf.sig N_fix_gr = N_fix
	nop.f 999
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//    N is the integer part of the reduced-reduced argument.
//    Put the integer in a GP register.
//
(p0)  fnma.s1 s_val = N, P_1, ArgPrime
	nop.i 999
}

{ .mfi
	nop.m 999
(p0)  fnma.s1 w = N, P_2, w
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//    s_val = -N*P_1 + ArgPrime
//    w = -N*P_2 + w
//
(p0)  fcmp.lt.unc.s1 p11, p10 = s_val, TWO_TO_NEG14
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
(p11) fcmp.gt.s1 p11, p10 = s_val, NEGTWO_TO_NEG14
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//    Case 3: r = s_val + w (Z complete)
//    Case 4: U_hi = N_0 * d_1
//
(p10) fmpy.s1 V_hi = N, P_2
	nop.i 999
}

{ .mfi
	nop.m 999
(p11) fmpy.s1 U_hi = N_0, d_1
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//    Case 3: r = s_val + w (Z complete)
//    Case 4: U_hi = N_0 * d_1
//
(p11) fmpy.s1 V_hi = N, P_2
	nop.i 999
}

{ .mfi
	nop.m 999
(p11) fmpy.s1 U_hi = N_0, d_1
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//    Decide between case 3 and 4:
//    Case 3:  s <= -2**(-14) or s >= 2**(-14)
//    Case 4: -2**(-14) < s < 2**(-14)
//
(p10) fadd.s1 r = s_val, w
	nop.i 999
}

{ .mfi
	nop.m 999
(p11) fmpy.s1 w = N, P_3
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//    Case 4: We need abs of both U_hi and V_hi - dont
//    worry about switched sign of V_hi .
//
(p11) fsub.s1 A = U_hi, V_hi
	nop.i 999
}

{ .mfi
	nop.m 999
//
//    Case 4: A =  U_hi + V_hi
//    Note: Worry about switched sign of V_hi, so subtract instead of add.
//
(p11) fnma.s1 V_lo = N, P_2, V_hi
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
(p11) fms.s1 U_lo = N_0, d_1, U_hi
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
(p11) fabs V_hiabs = V_hi
	nop.i 999
}

{ .mfi
	nop.m 999
//
//    Case 4: V_hi = N * P_2
//            w = N * P_3
//    Note the product does not include the (-) as in the writeup
//    so (-) missing for V_hi and w .
(p10) fadd.s1 r = s_val, w
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//    Case 3: c = s_val - r
//    Case 4: U_lo = N_0 * d_1 - U_hi
//
(p11) fabs U_hiabs = U_hi
	nop.i 999
}

{ .mfi
	nop.m 999
(p11) fmpy.s1 w = N, P_3
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//    Case 4: Set P_12 if U_hiabs >= V_hiabs
//
(p11) fadd.s1 C_hi = s_val, A
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//    Case 4: C_hi = s_val + A
//
(p11) fadd.s1 t = U_lo, V_lo
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//    Case 3: Is |r| < 2**(-2), if so set PR_7
//    else set PR_8.
//    Case 3: If PR_7 is set, prepare to branch to Small_R.
//    Case 3: If PR_8 is set, prepare to branch to Normal_R.
//
(p10) fsub.s1 c = s_val, r
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//    Case 3: c = (s - r) + w (c complete)
//
(p11) fcmp.ge.unc.s1 p12, p13 = U_hiabs, V_hiabs
	nop.i 999
}

{ .mfi
	nop.m 999
(p11) fms.s1 w = N_0, d_2, w
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//    Case 4: V_hi = N * P_2
//            w = N * P_3
//    Note the product does not include the (-) as in the writeup
//    so (-) missing for V_hi and w .
//
(p10) fcmp.lt.unc.s1 p14, p15 = r, TWO_TO_NEG2
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
(p14) fcmp.gt.s1 p14, p15 = r, NEGTWO_TO_NEG2
	nop.i 999 ;;
}

{ .mfb
	nop.m 999
//
//    Case 4: V_lo = -N * P_2 - V_hi (U_hi is in place of V_hi in writeup)
//    Note: the (-) is still missing for V_hi .
//    Case 4: w = w + N_0 * d_2
//    Note: the (-) is now incorporated in w .
//
(p10) fadd.s1 c = c, w
//
//    Case 4: t = U_lo + V_lo
//    Note: remember V_lo should be (-), subtract instead of add. NO
//
(p14) br.cond.spnt TAN_SMALL_R ;;
}

{ .mib
	nop.m 999
	nop.i 999
(p15) br.cond.spnt TAN_NORMAL_R ;;
}

{ .mfi
	nop.m 999
//
//    Case 3: Vector off when |r| < 2**(-2).  Recall that PR_3 will be true.
//    The remaining stuff is for Case 4.
//
(p12) fsub.s1 a = U_hi, A
(p11) extr.u i_1 = N_fix_gr, 0, 1 ;;
}

{ .mfi
	nop.m 999
//
//    Case 4: C_lo = s_val - C_hi
//
(p11) fadd.s1 t = t, w
	nop.i 999
}

{ .mfi
	nop.m 999
(p13) fadd.s1 a = V_hi, A
	nop.i 999 ;;
}

//
//    Case 4: a = U_hi - A
//            a = V_hi - A (do an add to account for missing (-) on V_hi
//

{ .mfi
(p11)  addl           table_ptr1   = @ltoff(TAN_BASE_CONSTANTS), gp
(p11) fsub.s1 C_lo = s_val, C_hi
	nop.i 999
}
;;

{ .mmi
(p11) ld8 table_ptr1 = [table_ptr1]
      nop.m 999
      nop.i 999
}
;;

//
//    Case 4: a = (U_hi - A)  + V_hi
//            a = (V_hi - A)  + U_hi
//    In each case account for negative missing form V_hi .
//
//
//    Case 4: C_lo = (s_val - C_hi) + A
//

{ .mmi
(p11) add table_ptr1 = 224, table_ptr1 ;;
(p11) ldfe P1_1 = [table_ptr1], 16
	nop.i 999 ;;
}

{ .mfi
(p11) ldfe P1_2 = [table_ptr1], 128
//
//    Case 4: w = U_lo + V_lo  + w
//
(p12) fsub.s1 a = a, V_hi
	nop.i 999 ;;
}
//
//    Case 4: r = C_hi + C_lo
//

{ .mfi
(p11) ldfe Q1_1 = [table_ptr1], 16
(p11) fadd.s1 C_lo = C_lo, A
	nop.i 999 ;;
}
//
//    Case 4: c = C_hi - r
//    Get [i_1] - lsb of N_fix_gr.
//

{ .mfi
(p11) ldfe Q1_2 = [table_ptr1], 16
	nop.f 999
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
(p13) fsub.s1 a = U_hi, a
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
(p11) fadd.s1 t = t, a
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//    Case 4: t = t + a
//
(p11) fadd.s1 C_lo = C_lo, t
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//    Case 4: C_lo = C_lo + t
//
(p11) fadd.s1 r = C_hi, C_lo
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
(p11) fsub.s1 c = C_hi, r
	nop.i 999
}

{ .mfi
	nop.m 999
//
//    Case 4: c = c + C_lo  finished.
//    Is i_1  even or odd?
//    if i_1 == 0, set PR_4, else set PR_5.
//
// r and c have been computed.
// We known whether this is the sine or cosine routine.
// Make sure ftz mode is set - should be automatic when using wre
(p0)  fmpy.s1 rsq = r, r
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
(p11) fadd.s1 c = c , C_lo
(p11) cmp.eq.unc p11, p12 =  0x0000, i_1 ;;
}

{ .mfi
	nop.m 999
(p12) frcpa.s1 S_hi, p0 = f1, r
	nop.i 999
}

{ .mfi
	nop.m 999
//
//    N odd: Change sign of S_hi
//
(p11) fma.s1 Result = rsq, P1_2, P1_1
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
(p12) fma.s1 P = rsq, Q1_2, Q1_1
	nop.i 999
}

{ .mfi
	nop.m 999
//
//    N odd:  Result  =  S_hi + S_lo      (User supplied rounding mode for C1)
//
(p0)  fmpy.s0 Q1_1 =  Q1_1, Q1_1
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//    N even: rsq = r * r
//    N odd:  S_hi = frcpa(r)
//
(p12) fmerge.ns S_hi = S_hi, S_hi
	nop.i 999
}

{ .mfi
	nop.m 999
//
//    N even: rsq = rsq * P1_2 + P1_1
//    N odd:  poly1 =  1.0 +  S_hi * r    16 bits partial  account for necessary
//
(p11) fmpy.s1 Result = rsq, Result
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
(p12) fma.s1 poly1 = S_hi, r,f1
	nop.i 999
}

{ .mfi
	nop.m 999
//
//    N even: Result =  Result * rsq
//    N odd:  S_hi  = S_hi + S_hi*poly1  16 bits account for necessary
//
(p11) fma.s1 Result = r, Result, c
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
(p12) fma.s1 S_hi = S_hi, poly1, S_hi
	nop.i 999
}

{ .mfi
	nop.m 999
//
//    N odd:   S_hi  = S_hi * poly1 + S_hi   32 bits
//
(p11) fadd.s0 Result= r, Result
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
(p12) fma.s1 poly1 =  S_hi, r, f1
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//    N even: Result = Result * r + c
//    N odd:  poly1  = 1.0 + S_hi * r        32 bits partial
//
(p12) fma.s1 S_hi = S_hi, poly1, S_hi
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
(p12) fma.s1 poly1 = S_hi, r, f1
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//    N even: Result1 = Result + r  (Rounding mode S0)
//    N odd:  poly1  =  S_hi * r + 1.0       64 bits partial
//
(p12) fma.s1 S_hi = S_hi, poly1, S_hi
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//    N odd:  poly1  =  S_hi * poly + S_hi    64 bits
//
(p12) fma.s1 poly1 = S_hi, r, f1
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//    N odd:  poly1  =  S_hi * r + 1.0
//
(p12) fma.s1 poly1 = S_hi, c, poly1
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//    N odd:  poly1  =  S_hi * c + poly1
//
(p12) fmpy.s1 S_lo = S_hi, poly1
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//    N odd:  S_lo  =  S_hi *  poly1
//
(p12) fma.s1 S_lo = P, r, S_lo
	nop.i 999 ;;
}

{ .mfb
	nop.m 999
//
//    N odd:  S_lo  =  S_lo + r * P
//
(p12) fadd.s0 Result = S_hi, S_lo
//
//    Do dummy multiply to raise inexact.
//
(p0)   br.ret.sptk b0 ;;
}
TAN_SMALL_R: 

{ .mii
	nop.m 999
(p0)  extr.u i_1 = N_fix_gr, 0, 1 ;;
(p0)  cmp.eq.unc p11, p12 = 0x0000, i_1
}

{ .mfi
	nop.m 999
(p0)  fmpy.s1 rsq = r, r
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
(p12) frcpa.s1 S_hi, p0 = f1, r
	nop.i 999
}

{ .mfi
(p0)  addl           table_ptr1   = @ltoff(TAN_BASE_CONSTANTS), gp
        nop.f 999
        nop.i 999
}
;;

{ .mmi
(p0)  ld8 table_ptr1 = [table_ptr1]
      nop.m 999
      nop.i 999
}
;;

// *****************************************************************
// *****************************************************************
// *****************************************************************

{ .mmi
(p0)  add table_ptr1 = 224, table_ptr1 ;;
(p0)  ldfe P1_1 = [table_ptr1], 16
	nop.i 999 ;;
}
//    r and c have been computed.
//    We known whether this is the sine or cosine routine.
//    Make sure ftz mode is set - should be automatic when using wre
//    |r| < 2**(-2)

{ .mfi
(p0)  ldfe P1_2 = [table_ptr1], 16
(p11) fmpy.s1 r_to_the_8 = rsq, rsq
	nop.i 999 ;;
}
//
//    Set table_ptr1 to beginning of constant table.
//    Get [i_1] - lsb of N_fix_gr.
//

{ .mfi
(p0)  ldfe P1_3 = [table_ptr1], 96
//
//    N even: rsq = r * r
//    N odd:  S_hi = frcpa(r)
//
(p12) fmerge.ns S_hi = S_hi, S_hi
	nop.i 999 ;;
}
//
//    Is i_1  even or odd?
//    if i_1 == 0, set PR_11.
//    if i_1 != 0, set PR_12.
//

{ .mfi
(p11) ldfe P1_9 = [table_ptr1], -16
//
//    N even: Poly2 = P1_7 + Poly2 * rsq
//    N odd:  poly2 = Q1_5 + poly2 * rsq
//
(p11) fadd.s1 CORR = rsq, f1
	nop.i 999 ;;
}

{ .mmi
(p11) ldfe P1_8 = [table_ptr1], -16 ;;
//
//    N even: Poly1 = P1_2 + P1_3 * rsq
//    N odd:  poly1 =  1.0 +  S_hi * r     
//    16 bits partial  account for necessary (-1)
//
(p11) ldfe P1_7 = [table_ptr1], -16
	nop.i 999 ;;
}
//
//    N even: Poly1 = P1_1 + Poly1 * rsq
//    N odd:  S_hi  =  S_hi + S_hi * poly1)     16 bits account for necessary
//

{ .mfi
(p11) ldfe P1_6 = [table_ptr1], -16
//
//    N even: Poly2 = P1_5 + Poly2 * rsq
//    N odd:  poly2 = Q1_3 + poly2 * rsq
//
(p11) fmpy.s1 r_to_the_8 = r_to_the_8, r_to_the_8
	nop.i 999 ;;
}
//
//    N even: Poly1 =  Poly1 * rsq
//    N odd:  poly1  = 1.0 + S_hi * r         32 bits partial
//

{ .mfi
(p11) ldfe P1_5 = [table_ptr1], -16
(p12) fma.s1 poly1 =  S_hi, r, f1
	nop.i 999 ;;
}
//
//    N even: CORR =  CORR * c
//    N odd:  S_hi  =  S_hi * poly1 + S_hi    32 bits
//

//
//    N even: Poly2 = P1_6 + Poly2 * rsq
//    N odd:  poly2 = Q1_4 + poly2 * rsq
//
{ .mmf
(p0)  addl           table_ptr2   = @ltoff(TAN_BASE_CONSTANTS), gp
(p11) ldfe P1_4 = [table_ptr1], -16
(p11) fmpy.s1 CORR =  CORR, c
}
;;


{ .mmi
(p0)  ld8 table_ptr2 = [table_ptr2]
      nop.m 999
      nop.i 999
}
;;


{ .mii
(p0)  add table_ptr2 = 464, table_ptr2
	nop.i 999 ;;
	nop.i 999
}

{ .mfi
	nop.m 999
(p11) fma.s1 Poly1 = P1_3, rsq, P1_2
	nop.i 999 ;;
}

{ .mfi
(p0)  ldfe Q1_7 = [table_ptr2], -16
(p12) fma.s1 S_hi = S_hi, poly1, S_hi
	nop.i 999 ;;
}

{ .mfi
(p0)  ldfe Q1_6 = [table_ptr2], -16
(p11) fma.s1 Poly2 = P1_9, rsq, P1_8
	nop.i 999 ;;
}

{ .mmi
(p0)  ldfe Q1_5 = [table_ptr2], -16 ;;
(p12) ldfe Q1_4 = [table_ptr2], -16
	nop.i 999 ;;
}

{ .mfi
(p12) ldfe Q1_3 = [table_ptr2], -16
//
//    N even: Poly2 = P1_8 + P1_9 * rsq
//    N odd:  poly2 = Q1_6 + Q1_7 * rsq
//
(p11) fma.s1 Poly1 = Poly1, rsq, P1_1
	nop.i 999 ;;
}

{ .mfi
(p12) ldfe Q1_2 = [table_ptr2], -16
(p12) fma.s1 poly1 = S_hi, r, f1
	nop.i 999 ;;
}

{ .mfi
(p12) ldfe Q1_1 = [table_ptr2], -16
(p11) fma.s1 Poly2 = Poly2, rsq, P1_7
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//    N even: CORR =  rsq + 1
//    N even: r_to_the_8 =  rsq * rsq
//
(p11) fmpy.s1 Poly1 = Poly1, rsq
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
(p12) fma.s1 S_hi = S_hi, poly1, S_hi
	nop.i 999
}

{ .mfi
	nop.m 999
(p12) fma.s1 poly2 = Q1_7, rsq, Q1_6
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
(p11) fma.s1 Poly2 = Poly2, rsq, P1_6
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
(p12) fma.s1 poly1 = S_hi, r, f1
	nop.i 999
}

{ .mfi
	nop.m 999
(p12) fma.s1 poly2 = poly2, rsq, Q1_5
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
(p11) fma.s1 Poly2= Poly2, rsq, P1_5
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
(p12) fma.s1 S_hi =  S_hi, poly1, S_hi
	nop.i 999
}

{ .mfi
	nop.m 999
(p12) fma.s1 poly2 = poly2, rsq, Q1_4
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//    N even: r_to_the_8 = r_to_the_8 * r_to_the_8
//    N odd:  poly1  =  S_hi * r + 1.0       64 bits partial
//
(p11) fma.s1 Poly2 = Poly2, rsq, P1_4
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//    N even: Result = CORR + Poly * r
//    N odd:  P = Q1_1 + poly2 * rsq
//
(p12) fma.s1 poly1 = S_hi, r, f1
	nop.i 999
}

{ .mfi
	nop.m 999
(p12) fma.s1 poly2 = poly2, rsq, Q1_3
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//    N even: Poly2 = P1_4 + Poly2 * rsq
//    N odd:  poly2 = Q1_2 + poly2 * rsq
//
(p11) fma.s1 Poly = Poly2, r_to_the_8, Poly1
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
(p12) fma.s1 poly1 = S_hi, c, poly1
	nop.i 999
}

{ .mfi
	nop.m 999
(p12) fma.s1 poly2 = poly2, rsq, Q1_2
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//    N even: Poly = Poly1 + Poly2 * r_to_the_8
//    N odd:  S_hi =  S_hi * poly1 + S_hi    64 bits
//
(p11) fma.s1 Result = Poly, r, CORR
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//    N even: Result =  r + Result  (User supplied rounding mode)
//    N odd:  poly1  =  S_hi * c + poly1
//
(p12) fmpy.s1 S_lo = S_hi, poly1
	nop.i 999
}

{ .mfi
	nop.m 999
(p12) fma.s1 P = poly2, rsq, Q1_1
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//    N odd:  poly1  =  S_hi * r + 1.0
//
(p11) fadd.s0 Result = Result, r
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//    N odd:  S_lo  =  S_hi *  poly1
//
(p12) fma.s1 S_lo = Q1_1, c, S_lo
	nop.i 999
}

{ .mfi
	nop.m 999
//
//    N odd:  Result = Result + S_hi  (user supplied rounding mode)
//
(p0)  fmpy.s0 Q1_1 = Q1_1, Q1_1
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//    N odd:  S_lo  =  Q1_1 * c + S_lo
//
(p12) fma.s1 Result = P, r, S_lo
	nop.i 999 ;;
}

{ .mfb
	nop.m 999
//
//    N odd:  Result =  S_lo + r * P
//
(p12) fadd.s0 Result = Result, S_hi
//
//    Do multiply to raise inexact.
//
(p0)   br.ret.sptk b0 ;;
}
TAN_NORMAL_R: 

{ .mfi
(p0)  getf.sig sig_r = r
// *******************************************************************
// *******************************************************************
// *******************************************************************
//
//    r and c have been computed.
//    Make sure ftz mode is set - should be automatic when using wre
//
//
//    Get [i_1] -  lsb of N_fix_gr alone.
//
(p0)  fmerge.s  Pos_r = f1, r
(p0)  extr.u i_1 = N_fix_gr, 0, 1 ;;
}

{ .mfi
	nop.m 999
(p0)  fmerge.s  sgn_r =  r, f1
(p0)  cmp.eq.unc p11, p12 = 0x0000, i_1 ;;
}

{ .mfi
	nop.m 999
	nop.f 999
(p0)  extr.u lookup = sig_r, 58, 5
}

{ .mlx
	nop.m 999
(p0)  movl Create_B = 0x8200000000000000 ;;
}

{ .mfi
(p0)  addl           table_ptr1   = @ltoff(TAN_BASE_CONSTANTS), gp
	nop.f 999
(p0)  dep Create_B = lookup, Create_B, 58, 5
}
;;

//
//    Get [i_1] -  lsb of N_fix_gr alone.
//    Pos_r = abs (r)
//


{ .mmi
      ld8 table_ptr1 = [table_ptr1]
      nop.m 999
      nop.i 999
}
;;


{ .mmi
	nop.m 999
(p0)  setf.sig B = Create_B
//
//    Set table_ptr1 and table_ptr2 to base address of
//    constant table.
//
(p0)  add table_ptr1 = 480, table_ptr1 ;;
}

{ .mmb
	nop.m 999
//
//    Is i_1 or i_0  == 0 ?
//    Create the constant  1 00000 1000000000000000000000...
//
(p0)  ldfe P2_1 = [table_ptr1], 16
	nop.b 999
}

{ .mmi
	nop.m 999 ;;
(p0)  getf.exp exp_r = Pos_r
	nop.i 999
}
//
//    Get r's exponent
//    Get r's significand
//

{ .mmi
(p0)  ldfe P2_2 = [table_ptr1], 16 ;;
//
//    Get the 5 bits or r for the lookup.   1.xxxxx ....
//    from sig_r.
//    Grab  lsb of exp of B
//
(p0)  ldfe P2_3 = [table_ptr1], 16
	nop.i 999 ;;
}

{ .mii
	nop.m 999
(p0)  andcm table_offset = 0x0001, exp_r ;;
(p0)  shl table_offset = table_offset, 9 ;;
}

{ .mii
	nop.m 999
//
//    Deposit   0 00000 1000000000000000000000... on
//              1 xxxxx yyyyyyyyyyyyyyyyyyyyyy...,
//    getting rid of the ys.
//    Is  B = 2** -2 or  B= 2** -1? If 2**-1, then
//    we want an offset of 512 for table addressing.
//
(p0)  shladd table_offset = lookup, 4, table_offset ;;
//
//    B =  ........ 1xxxxx 1000000000000000000...
//
(p0)  add table_ptr1 = table_ptr1, table_offset ;;
}

{ .mmb
	nop.m 999
//
//   B =  ........ 1xxxxx 1000000000000000000...
//   Convert B so it has the same exponent as Pos_r
//
(p0)  ldfd T_hi = [table_ptr1], 8
	nop.b 999 ;;
}

//
//    x = |r| - B
//    Load T_hi.
//    Load C_hi.
//

{ .mmf
(p0)  addl           table_ptr2   = @ltoff(TAN_BASE_CONSTANTS), gp
(p0)  ldfs T_lo = [table_ptr1]
(p0)  fmerge.se B = Pos_r, B
}
;;

{ .mmi
      ld8 table_ptr2 = [table_ptr2]
      nop.m 999
      nop.i 999
}
;;

{ .mii
(p0)  add table_ptr2 = 1360, table_ptr2
	nop.i 999 ;;
(p0)  add table_ptr2 = table_ptr2, table_offset ;;
}

{ .mfi
(p0)  ldfd C_hi = [table_ptr2], 8
(p0)  fsub.s1 x = Pos_r, B
	nop.i 999 ;;
}

{ .mii
(p0)  ldfs C_lo = [table_ptr2],255
	nop.i 999 ;;
//
//    xsq = x * x
//    N even: Tx = T_hi * x
//    Load T_lo.
//    Load C_lo - increment pointer to get SC_inv 
//    - cant get all the way, do an add later.
//
(p0)  add table_ptr2 = 569, table_ptr2 ;;
}
//
//    N even: Tx1 = Tx + 1
//    N odd:  Cx1 = 1 - Cx
//

{ .mfi
(p0)  ldfe SC_inv = [table_ptr2], 0
	nop.f 999
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
(p0)  fmpy.s1 xsq = x, x
	nop.i 999
}

{ .mfi
	nop.m 999
(p11) fmpy.s1 Tx = T_hi, x
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
(p12) fmpy.s1 Cx = C_hi, x
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//    N odd: Cx = C_hi * x
//
(p0)  fma.s1 P = P2_3, xsq, P2_2
	nop.i 999
}

{ .mfi
	nop.m 999
//
//    N even and odd: P = P2_3 + P2_2 * xsq
//
(p11) fadd.s1 Tx1 = Tx, f1
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//    N even: D = C_hi - tanx
//    N odd: D = T_hi + tanx
//
(p11) fmpy.s1 CORR = SC_inv, T_hi
	nop.i 999
}

{ .mfi
	nop.m 999
(p0)  fmpy.s1 Sx = SC_inv, x
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
(p12) fmpy.s1 CORR = SC_inv, C_hi
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
(p12) fsub.s1 V_hi = f1, Cx
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
(p0)  fma.s1 P = P, xsq, P2_1
	nop.i 999
}

{ .mfi
	nop.m 999
//
//    N even and odd: P = P2_1 + P * xsq
//
(p11) fma.s1 V_hi = Tx, Tx1, f1
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//    N even: Result  = sgn_r * tail + T_hi (user rounding mode for C1)
//    N odd:  Result  = sgn_r * tail + C_hi (user rounding mode for C1)
//
(p0)  fmpy.s0 P2_1 = P2_1, P2_1
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
(p0)  fmpy.s1 CORR = CORR, c
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
(p12) fnma.s1 V_hi = Cx,V_hi,f1
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//    N even: V_hi = Tx * Tx1 + 1
//    N odd: Cx1 = 1 - Cx * Cx1
//
(p0)  fmpy.s1 P = P, xsq
	nop.i 999
}

{ .mfi
	nop.m 999
//
//    N even and odd: P = P * xsq
//
(p11) fmpy.s1 V_hi = V_hi, T_hi
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//    N even and odd: tail = P * tail + V_lo
//
(p11) fmpy.s1 T_hi = sgn_r, T_hi
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
(p0)  fmpy.s1 CORR = CORR, sgn_r
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
(p12) fmpy.s1 V_hi = V_hi,C_hi
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//    N even: V_hi = T_hi * V_hi
//    N odd: V_hi  = C_hi * V_hi
//
(p0)  fma.s1 tanx = P, x, x
	nop.i 999
}

{ .mfi
	nop.m 999
(p12) fnmpy.s1 C_hi = sgn_r, C_hi
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//    N even: V_lo = 1 - V_hi + C_hi
//    N odd: V_lo = 1 - V_hi + T_hi
//
(p11) fadd.s1 CORR = CORR, T_lo
	nop.i 999
}

{ .mfi
	nop.m 999
(p12) fsub.s1 CORR = CORR, C_lo
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//    N even and odd: tanx = x + x * P
//    N even and odd: Sx = SC_inv * x
//
(p11) fsub.s1 D = C_hi, tanx
	nop.i 999
}

{ .mfi
	nop.m 999
(p12) fadd.s1 D = T_hi, tanx
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//    N odd: CORR = SC_inv * C_hi
//    N even: CORR = SC_inv * T_hi
//
(p0)  fnma.s1 D = V_hi, D, f1
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//    N even and odd: D = 1 - V_hi * D
//    N even and odd: CORR = CORR * c
//
(p0)  fma.s1 V_hi = V_hi, D, V_hi
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//    N even and odd: V_hi = V_hi + V_hi * D
//    N even and odd: CORR = sgn_r * CORR
//
(p11) fnma.s1 V_lo = V_hi, C_hi, f1
	nop.i 999
}

{ .mfi
	nop.m 999
(p12) fnma.s1 V_lo = V_hi, T_hi, f1
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//    N even: CORR = COOR + T_lo
//    N odd: CORR = CORR - C_lo
//
(p11) fma.s1 V_lo = tanx, V_hi, V_lo
	nop.i 999
}

{ .mfi
	nop.m 999
(p12) fnma.s1 V_lo = tanx, V_hi, V_lo
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//    N even: V_lo = V_lo + V_hi * tanx
//    N odd: V_lo = V_lo - V_hi * tanx
//
(p11) fnma.s1 V_lo = C_lo, V_hi, V_lo
	nop.i 999
}

{ .mfi
	nop.m 999
(p12) fnma.s1 V_lo = T_lo, V_hi, V_lo
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//    N  even: V_lo = V_lo - V_hi * C_lo
//    N  odd: V_lo = V_lo - V_hi * T_lo
//
(p0)  fmpy.s1 V_lo = V_hi, V_lo
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//    N even and odd: V_lo = V_lo * V_hi
//
(p0)  fadd.s1 tail = V_hi, V_lo
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//    N even and odd: tail = V_hi + V_lo
//
(p0)  fma.s1 tail = tail, P, V_lo
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//    N even: T_hi = sgn_r * T_hi
//    N odd : C_hi = -sgn_r * C_hi
//
(p0)  fma.s1 tail = tail, Sx, CORR
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//    N even and odd: tail = Sx * tail + CORR
//
(p0)  fma.s1 tail = V_hi, Sx, tail
	nop.i 999 ;;
}

{ .mfi
	nop.m 999
//
//    N even an odd: tail = Sx * V_hi + tail
//
(p11) fma.s0 Result = sgn_r, tail, T_hi
	nop.i 999
}

{ .mfb
	nop.m 999
(p12) fma.s0 Result = sgn_r, tail, C_hi
//
//    Do a multiply to raise inexact.
//
(p0)   br.ret.sptk b0 ;;
}

.endp __libm_tan



// *******************************************************************
// *******************************************************************
// *******************************************************************
//
//     Special Code to handle very large argument case.
//     Call int pi_by_2_reduce(&x,&r)
//     for |arguments| >= 2**63
//     (Arg or x) is in f8
//     Address to save r and c as double

//                 (1)                    (2)                 (3) (call)         (4)
//            sp -> +               psp -> +            psp -> +           sp ->  +
//                  |                      |                   |                  |
//                  |                r50 ->| <- r50      f0  ->|           r50 -> | -> c
//                  |                      |                   |                  |
//         sp-32 -> | <- r50          f0 ->|             f0  ->| <- r50    r49 -> | -> r
//                  |                      |                   |                  |
//                  |               r49  ->| <- r49     Arg  ->| <- r49           | -> x
//                  |                      |                   |                  |
//         sp -64 ->|             sp -64 ->|          sp -64 ->|                  |
//
//            save pfs           save b0                                     restore gp
//            save gp                                                        restore b0
//                                                                           restore pfs



.proc __libm_callout
__libm_callout:
TAN_ARG_TOO_LARGE: 
.prologue
// (1)
{ .mfi
        add   GR_Parameter_r =-32,sp                        // Parameter: r address
        nop.f 0
.save   ar.pfs,GR_SAVE_PFS
        mov  GR_SAVE_PFS=ar.pfs                 // Save ar.pfs
}
{ .mfi
.fframe 64
        add sp=-64,sp                           // Create new stack
        nop.f 0
        mov GR_SAVE_GP=gp                       // Save gp
};;

// (2)
{ .mmi
        stfe [GR_Parameter_r ] = f0,16                      // Clear Parameter r on stack
        add  GR_Parameter_X = 16,sp                        // Parameter x address
.save   b0, GR_SAVE_B0
        mov GR_SAVE_B0=b0                       // Save b0
};;

// (3)
.body
{ .mib
        stfe [GR_Parameter_r ] = f0,-16                     // Clear Parameter c on stack
        nop.i 0
        nop.b 0
}
{ .mib
        stfe [GR_Parameter_X] = Arg                        // Store Parameter x on stack
        nop.i 0
(p0)    br.call.sptk b0=__libm_pi_by_2_reduce#
}
;;


// (4)
{ .mmi
        mov   gp = GR_SAVE_GP                  // Restore gp
(p0)    mov   N_fix_gr = r8 
        nop.i 999
}
;;

{ .mmi
(p0)    ldfe  Arg        =[GR_Parameter_X],16
(p0)    ldfs  TWO_TO_NEG2 = [table_ptr2],4
        nop.i 999
}
;;


{ .mmb
(p0)    ldfe  r =[GR_Parameter_r ],16
(p0)    ldfs  NEGTWO_TO_NEG2 = [table_ptr2],4
        nop.b 999 ;;
}

{ .mfi
(p0)    ldfe  c =[GR_Parameter_r ]
        nop.f 999
        nop.i 999 ;;
}

{ .mfi
        nop.m 999
//
//     Is |r| < 2**(-2)
//
(p0)   fcmp.lt.unc.s1  p6, p0 = r, TWO_TO_NEG2
        mov   b0 = GR_SAVE_B0                  // Restore return address
}
;;

{ .mfi
       nop.m 999
(p6)   fcmp.gt.unc.s1  p6, p0 = r, NEGTWO_TO_NEG2
       mov   ar.pfs = GR_SAVE_PFS             // Restore ar.pfs
}
;;

{ .mbb
.restore
        add   sp = 64,sp                       // Restore stack pointer
(p6)   br.cond.spnt TAN_SMALL_R
(p0)   br.cond.sptk TAN_NORMAL_R 
}
;;
.endp __libm_callout


.proc __libm_TAN_SPECIAL
__libm_TAN_SPECIAL:

//
//     Code for NaNs, Unsupporteds, Infs, or +/- zero ?
//     Invalid raised for Infs and SNaNs.
//

{ .mfb
	nop.m 999
(p0)   fmpy.s0 Arg = Arg, f0
(p0)   br.ret.sptk b0 
}
.endp __libm_TAN_SPECIAL


.type __libm_pi_by_2_reduce#,@function
.global __libm_pi_by_2_reduce#
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\ia64\modff.s ===
.file "modff.s"

// Copyright (c) 2000, 2001, Intel Corporation
// All rights reserved.
// 
// Contributed 2/2/2000 by John Harrison, Ted Kubaska, Bob Norin, Shane Story,
// and Ping Tak Peter Tang of the Computational Software Lab, Intel Corporation.
// 
// WARRANTY DISCLAIMER
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS 
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY 
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
// 
// Intel Corporation is the author of this code, and requests that all
// problem reports or change requests be submitted to it directly at 
// http://developer.intel.com/opensource.
//
// History
//==============================================================
// 2/02/00: Initial version
// 4/04/00: Improved speed, corrected result for NaN input
// 12/22/00 Fixed so inexact flag is never set, and invalid is not set for 
//            qnans nor for inputs larger than 2^63.
//
// API
//==============================================================
// float modff(float x, float *iptr)
// break a floating point x number into fraction and an exponent
//
// input  floating point f8, address in r33
// output floating point f8 (x fraction), and *iptr (x integral part)
//
// OVERVIEW
//==============================================================

// NO FRACTIONAL PART: HUGE
// If
// for double-extended
// If the true exponent is greater than or equal 63
//      1003e ==> 1003e -ffff = 3f = 63(dec)
// for double
// If the true exponent is greater than or equal 52
//                10033 -ffff = 34 = 52(dec)
// for single
// If the true exponent is greater than or equal 23
//                10016 -ffff = 17 = 23(dec)
// then
// we are already an integer (p9 true)

// NO INTEGER PART:    SMALL
//     Is f8 exponent less than register bias (that is, is it
//     less than 1). If it is, get the right sign of
//     zero and store this in iptr.

// CALCULATION: NOT HUGE, NOT SMALL
// To get the integer part
// Take the floating-point  input and truncate 
//   then convert  this integer to fp  Call it  MODF_INTEGER_PART

// Subtract  MODF_INTEGER_PART from MODF_NORM_F8 to get fraction part
// Then put fraction part in f8 
//      put integer  part MODF_INTEGER_PART into *iptr

// Registers used
//==============================================================

// predicate registers used: 
// p6 - p13

//                      0xFFFF           0x10016
// -----------------------+-----------------+-------------
//              SMALL     |      NORMAL     | HUGE
//    p11 --------------->|<----- p12 ----->| <-------------- p9
//    p10 --------------------------------->|
//    p13 --------------------------------------------------->|
//

// floating-point registers used: 
MODF_NORM_F8               = f9
MODF_FRACTION_PART         = f10
MODF_INTEGER_PART          = f11
MODF_INT_INTEGER_PART      = f12


// general registers used 
modf_signexp    = r14
modf_GR_no_frac = r15
modf_GR_FFFF    = r16
modf_17_ones    = r17 
modf_exp        = r18
// r33 = iptr
     

.align 32
.global modff#

.section .text
.proc  modff#
.align 32


// Main path is p9, p11, p8 FALSE and p12 TRUE

// Assume input is normalized and get signexp
// Normalize input just in case
// Form exponent bias 
modff: 
{ .mfi
      getf.exp  modf_signexp = f8
      fnorm          MODF_NORM_F8  = f8
      addl           modf_GR_FFFF  = 0xffff, r0
}
// Get integer part of input
// Form exponent mask
{ .mfi
      nop.m 999
      fcvt.fx.trunc.s1  MODF_INT_INTEGER_PART   = f8
      mov  modf_17_ones     = 0x1ffff ;;
}

// Is x nan or inf?
// qnan snan inf norm     unorm 0 -+
// 1    1    1   0        0     0 11 = 0xe3 NAN_INF
// Form biased exponent where input only has an integer part
{ .mfi
      nop.m 999
      fclass.m.unc p6,p13 = f8, 0xe3
      addl modf_GR_no_frac = 0x10016, r0 ;;
}

// Mask to get exponent
// Is x unnorm?
// qnan snan inf norm     unorm 0 -+
// 0    0    0   0        1     0 11 = 0x0b UNORM
// Set p13 to indicate calculation path, else p6 if nan or inf 
{ .mfi
      and       modf_exp = modf_17_ones, modf_signexp 
      fclass.m.unc p8,p0 = f8, 0x0b
      nop.i 999 ;;
}

// p11 <== SMALL, no integer part, fraction is everyting
// p9  <== HUGE,  no fraction part, integer is everything
// p12 <== NORMAL, fraction part and integer part
{ .mii
(p13) cmp.lt.unc p11,p10 = modf_exp, modf_GR_FFFF
      nop.i 999
      nop.i 999 ;;
}

// Is x inf? p6 if inf, p7 if nan
{ .mfb
(p10) cmp.ge.unc p9,p12  = modf_exp, modf_GR_no_frac
(p6)  fclass.m.unc p6,p7 = f8, 0x23
(p8)  br.cond.spnt MODF_DENORM ;;
}

MODF_COMMON:
// For HUGE set fraction to signed 0
{ .mfi
      nop.m 999
(p9)  fmerge.s f8 = f8,f0
      nop.i 999
}
// For HUGE set integer part to normalized input
{ .mfi
      nop.m 999
(p9)  fnorm.s MODF_INTEGER_PART = MODF_NORM_F8
      nop.i 999 ;;
}

// For SMALL set fraction to normalized input, integer part to signed 0
{ .mfi
      nop.m 999
(p11) fmerge.s MODF_INTEGER_PART = f8,f0
      nop.i 999
}
{ .mfi
      nop.m 999
(p11) fnorm.s f8 = MODF_NORM_F8
      nop.i 999 ;;
}

// For NORMAL float the integer part
{ .mfi
      nop.m 999
(p12) fcvt.xf    MODF_INTEGER_PART = MODF_INT_INTEGER_PART
      nop.i 999 ;;
}

// If x inf set integer part to INF, fraction to signed 0
{ .mfi
(p6)  stfs [r33] = MODF_NORM_F8
(p6)  fmerge.s  f8 = f8,f0
      nop.i 999 ;;
}

// If x nan set integer and fraction parts to NaN (quietized)
{ .mfi
(p7)  stfs [r33] = MODF_NORM_F8
(p7)  fmerge.s  f8 = MODF_NORM_F8, MODF_NORM_F8
      nop.i 999 ;;
}

{ .mmi
(p9)  stfs [r33] = MODF_INTEGER_PART
      nop.m 999
      nop.i 999 ;;
}

// For NORMAL compute fraction part
{ .mfi
(p11) stfs [r33] = MODF_INTEGER_PART
(p12) fms.s.s0   f8 = MODF_NORM_F8,f1, MODF_INTEGER_PART
      nop.i 999 ;;
}

// For NORMAL test if fraction part is zero; if so append correct sign
{ .mfi
      nop.m 999
(p12) fcmp.eq.unc p7,p0 = MODF_NORM_F8, MODF_INTEGER_PART
      nop.i 999 ;;
}

{ .mfi
(p12) stfs [r33] = MODF_INTEGER_PART
      nop.f 999
      nop.i 999 ;;
}

// For NORMAL if fraction part is zero append sign of input
{ .mfb
      nop.m 999
(p7)  fmerge.s f8 = MODF_NORM_F8, f0
      br.ret.sptk    b0 ;;
}

MODF_DENORM:
// If x unorm get signexp from normalized input
// If x unorm get integer part from normalized input
{ .mfi
      getf.exp  modf_signexp = MODF_NORM_F8
      fcvt.fx.trunc.s1  MODF_INT_INTEGER_PART   = MODF_NORM_F8
      nop.i 999 ;;
}

// If x unorm mask to get exponent
{ .mmi
      and       modf_exp = modf_17_ones, modf_signexp ;;
      cmp.lt.unc p11,p10 = modf_exp, modf_GR_FFFF
      nop.i 999 ;;
}

{ .mfb
(p10) cmp.ge.unc p9,p12  = modf_exp, modf_GR_no_frac
      nop.f 999
      br.cond.spnt MODF_COMMON ;;
}

.endp modff
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\ia64\logf.s ===
.file "logf.s"

// Copyright (c) 2000, 2001, Intel Corporation
// All rights reserved.
// 
// Contributed 2/2/2000 by John Harrison, Ted Kubaska, Bob Norin, Shane Story,
// and Ping Tak Peter Tang of the Computational Software Lab, Intel Corporation.
// 
// WARRANTY DISCLAIMER
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS 
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY 
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
// 
// Intel Corporation is the author of this code, and requests that all
// problem reports or change requests be submitted to it directly at 
// http://developer.intel.com/opensource.
//
// History
//==============================================================
// 3/01/00  Initial version
// 8/15/00  Bundle added after call to __libm_error_support to properly
//          set [the previously overwritten] GR_Parameter_RESULT.
// 1/10/01  Improved speed, fixed flags for neg denormals
//
//
// API
//==============================================================
// float logf(float)
// float log10f(float)
//
// Overview of operation
//==============================================================
// Background
//
// Consider  x = 2^N 1.f1 f2 f3 f4...f63
// Log(x) = log(frcpa(x) x/frcpa(x))
//        = log(1/frcpa(x)) + log(frcpa(x) x)
//        = -log(frcpa(x)) + log(frcpa(x) x)
//
// frcpa(x)       = 2^-N frcpa((1.f1 f2 ... f63)
//
// -log(frcpa(x)) = -log(C) 
//                = -log(2^-N) - log(frcpa(1.f1 f2 ... f63))
//
// -log(frcpa(x)) = -log(C) 
//                = +Nlog2 - log(frcpa(1.f1 f2 ... f63))
//
// -log(frcpa(x)) = -log(C) 
//                = +Nlog2 + log(frcpa(1.f1 f2 ... f63))
//
// Log(x) = log(1/frcpa(x)) + log(frcpa(x) x)

// Log(x) =  +Nlog2 + log(1./frcpa(1.f1 f2 ... f63)) + log(frcpa(x) x)
// Log(x) =  +Nlog2 - log(/frcpa(1.f1 f2 ... f63))   + log(frcpa(x) x)
// Log(x) =  +Nlog2 + T                              + log(frcpa(x) x)
//
// Log(x) =  +Nlog2 + T                     + log(C x)
//
// Cx = 1 + r
//
// Log(x) =  +Nlog2 + T  + log(1+r)
// Log(x) =  +Nlog2 + T  + Series( r - r^2/2 + r^3/3 - r^4/4 ....)
//
// 1.f1 f2 ... f8 has 256 entries.
// They are 1 + k/2^8, k = 0 ... 255
// These 256 values are the table entries.
//
// Implementation
//===============
// CASE 1:  |x-1| >= 2^-8
// C = frcpa(x)
// r = C * x - 1
//
// Form rseries = r + P1*r^2 + P2*r^3 + P3*r^4
//
// x = f * 2*n where f is 1.f_1f_2f_3....f_63
// Nfloat = float(n)  where n is the true unbiased exponent
// pre-index = f_1f_2....f_8
// index = pre_index * 16
// get the dxt table entry at index + offset = T
//
// result = (T + Nfloat * log(2)) + rseries
//
// The T table is calculated as follows
// Form x_k = 1 + k/2^8 where k goes from 0... 255
//      y_k = frcpa(x_k)
//      log(1/y_k)  in quad and round to double

// CASE 2:  |x-1| < 2^-6
// w = x - 1
//
// Form wseries = w + Q1*w^2 + Q2*w^3 + Q3*w^4
//
// result = wseries

// Special values 
//==============================================================


// log(+0)    = -inf
// log(-0)    = -inf

// log(+qnan) = +qnan 
// log(-qnan) = -qnan 
// log(+snan) = +qnan 
// log(-snan) = -qnan 

// log(-n)    = QNAN Indefinite
// log(-inf)  = QNAN Indefinite 

// log(+inf)  = +inf

// Registers used
//==============================================================
// Floating Point registers used: 
// f8, input
// f9 -> f15,  f32 -> f47

// General registers used:  
// r32 -> r51

// Predicate registers used:
// p6 -> p15

// p8 log base e
// p6 log base e special
// p9 used in the frcpa
// p13 log base e large W
// p14 log base e small w

// p7 log base 10
// p10 log base 10 large W
// p11 log base 10 small w
// p12 log base 10 special

// Assembly macros
//==============================================================

log_int_Nfloat   = f9 
log_Nfloat       = f10 

log_P3           = f11 
log_P2           = f12 
log_P1           = f13 
log_inv_ln10     = f14
log_log2         = f15 

log_w            = f32
log_T            = f33 
log_rp_p32       = f34 
log_rp_p2        = f35 
log_rp_p10       = f36
log_rsq          = f37 
log_T_plus_Nlog2 = f38 
log_r            = f39
log_C            = f40
log_rp_q32       = f41
log_rp_q2        = f42
log_rp_q10       = f43
log_wsq          = f44
log_Q            = f45
log_inv_ln10     = f46
log_NORM_f8      = f47

// ===================================

log_GR_exp_17_ones               = r33
log_GR_exp_16_ones               = r34
log_GR_exp_f8                    = r35
log_GR_signexp_f8                = r36
log_GR_true_exp_f8               = r37
log_GR_significand_f8            = r38
log_GR_index                     = r39
log_AD_1                         = r40
log_GR_signexp_w                 = r41
log_GR_fff7                      = r42
log_AD_2                         = r43
log_GR_exp_w                     = r44

GR_SAVE_B0                       = r45
GR_SAVE_GP                       = r46
GR_SAVE_PFS                      = r47

GR_Parameter_X                   = r48
GR_Parameter_Y                   = r49
GR_Parameter_RESULT              = r50
log_GR_tag                       = r51


// Data tables
//==============================================================

.data

.align 16

log_table_1:
data8 0xbfd0001008f39d59    // p3
data8 0x3fd5556073e0c45a    // p2

log_table_2:
data8 0xbfdffffffffaea15    // p1
data8 0x3fdbcb7b1526e50e    // 1/ln10
data8 0x3fe62e42fefa39ef    // Log(2)
data8 0x0                   // pad

data8 0x3F60040155D5889E    //log(1/frcpa(1+   0/256)
data8 0x3F78121214586B54    //log(1/frcpa(1+   1/256)
data8 0x3F841929F96832F0    //log(1/frcpa(1+   2/256)
data8 0x3F8C317384C75F06    //log(1/frcpa(1+   3/256)
data8 0x3F91A6B91AC73386    //log(1/frcpa(1+   4/256)
data8 0x3F95BA9A5D9AC039    //log(1/frcpa(1+   5/256)
data8 0x3F99D2A8074325F4    //log(1/frcpa(1+   6/256)
data8 0x3F9D6B2725979802    //log(1/frcpa(1+   7/256)
data8 0x3FA0C58FA19DFAAA    //log(1/frcpa(1+   8/256)
data8 0x3FA2954C78CBCE1B    //log(1/frcpa(1+   9/256)
data8 0x3FA4A94D2DA96C56    //log(1/frcpa(1+  10/256)
data8 0x3FA67C94F2D4BB58    //log(1/frcpa(1+  11/256)
data8 0x3FA85188B630F068    //log(1/frcpa(1+  12/256)
data8 0x3FAA6B8ABE73AF4C    //log(1/frcpa(1+  13/256)
data8 0x3FAC441E06F72A9E    //log(1/frcpa(1+  14/256)
data8 0x3FAE1E6713606D07    //log(1/frcpa(1+  15/256)
data8 0x3FAFFA6911AB9301    //log(1/frcpa(1+  16/256)
data8 0x3FB0EC139C5DA601    //log(1/frcpa(1+  17/256)
data8 0x3FB1DBD2643D190B    //log(1/frcpa(1+  18/256)
data8 0x3FB2CC7284FE5F1C    //log(1/frcpa(1+  19/256)
data8 0x3FB3BDF5A7D1EE64    //log(1/frcpa(1+  20/256)
data8 0x3FB4B05D7AA012E0    //log(1/frcpa(1+  21/256)
data8 0x3FB580DB7CEB5702    //log(1/frcpa(1+  22/256)
data8 0x3FB674F089365A7A    //log(1/frcpa(1+  23/256)
data8 0x3FB769EF2C6B568D    //log(1/frcpa(1+  24/256)
data8 0x3FB85FD927506A48    //log(1/frcpa(1+  25/256)
data8 0x3FB9335E5D594989    //log(1/frcpa(1+  26/256)
data8 0x3FBA2B0220C8E5F5    //log(1/frcpa(1+  27/256)
data8 0x3FBB0004AC1A86AC    //log(1/frcpa(1+  28/256)
data8 0x3FBBF968769FCA11    //log(1/frcpa(1+  29/256)
data8 0x3FBCCFEDBFEE13A8    //log(1/frcpa(1+  30/256)
data8 0x3FBDA727638446A2    //log(1/frcpa(1+  31/256)
data8 0x3FBEA3257FE10F7A    //log(1/frcpa(1+  32/256)
data8 0x3FBF7BE9FEDBFDE6    //log(1/frcpa(1+  33/256)
data8 0x3FC02AB352FF25F4    //log(1/frcpa(1+  34/256)
data8 0x3FC097CE579D204D    //log(1/frcpa(1+  35/256)
data8 0x3FC1178E8227E47C    //log(1/frcpa(1+  36/256)
data8 0x3FC185747DBECF34    //log(1/frcpa(1+  37/256)
data8 0x3FC1F3B925F25D41    //log(1/frcpa(1+  38/256)
data8 0x3FC2625D1E6DDF57    //log(1/frcpa(1+  39/256)
data8 0x3FC2D1610C86813A    //log(1/frcpa(1+  40/256)
data8 0x3FC340C59741142E    //log(1/frcpa(1+  41/256)
data8 0x3FC3B08B6757F2A9    //log(1/frcpa(1+  42/256)
data8 0x3FC40DFB08378003    //log(1/frcpa(1+  43/256)
data8 0x3FC47E74E8CA5F7C    //log(1/frcpa(1+  44/256)
data8 0x3FC4EF51F6466DE4    //log(1/frcpa(1+  45/256)
data8 0x3FC56092E02BA516    //log(1/frcpa(1+  46/256)
data8 0x3FC5D23857CD74D5    //log(1/frcpa(1+  47/256)
data8 0x3FC6313A37335D76    //log(1/frcpa(1+  48/256)
data8 0x3FC6A399DABBD383    //log(1/frcpa(1+  49/256)
data8 0x3FC70337DD3CE41B    //log(1/frcpa(1+  50/256)
data8 0x3FC77654128F6127    //log(1/frcpa(1+  51/256)
data8 0x3FC7E9D82A0B022D    //log(1/frcpa(1+  52/256)
data8 0x3FC84A6B759F512F    //log(1/frcpa(1+  53/256)
data8 0x3FC8AB47D5F5A310    //log(1/frcpa(1+  54/256)
data8 0x3FC91FE49096581B    //log(1/frcpa(1+  55/256)
data8 0x3FC981634011AA75    //log(1/frcpa(1+  56/256)
data8 0x3FC9F6C407089664    //log(1/frcpa(1+  57/256)
data8 0x3FCA58E729348F43    //log(1/frcpa(1+  58/256)
data8 0x3FCABB55C31693AD    //log(1/frcpa(1+  59/256)
data8 0x3FCB1E104919EFD0    //log(1/frcpa(1+  60/256)
data8 0x3FCB94EE93E367CB    //log(1/frcpa(1+  61/256)
data8 0x3FCBF851C067555F    //log(1/frcpa(1+  62/256)
data8 0x3FCC5C0254BF23A6    //log(1/frcpa(1+  63/256)
data8 0x3FCCC000C9DB3C52    //log(1/frcpa(1+  64/256)
data8 0x3FCD244D99C85674    //log(1/frcpa(1+  65/256)
data8 0x3FCD88E93FB2F450    //log(1/frcpa(1+  66/256)
data8 0x3FCDEDD437EAEF01    //log(1/frcpa(1+  67/256)
data8 0x3FCE530EFFE71012    //log(1/frcpa(1+  68/256)
data8 0x3FCEB89A1648B971    //log(1/frcpa(1+  69/256)
data8 0x3FCF1E75FADF9BDE    //log(1/frcpa(1+  70/256)
data8 0x3FCF84A32EAD7C35    //log(1/frcpa(1+  71/256)
data8 0x3FCFEB2233EA07CD    //log(1/frcpa(1+  72/256)
data8 0x3FD028F9C7035C1C    //log(1/frcpa(1+  73/256)
data8 0x3FD05C8BE0D9635A    //log(1/frcpa(1+  74/256)
data8 0x3FD085EB8F8AE797    //log(1/frcpa(1+  75/256)
data8 0x3FD0B9C8E32D1911    //log(1/frcpa(1+  76/256)
data8 0x3FD0EDD060B78081    //log(1/frcpa(1+  77/256)
data8 0x3FD122024CF0063F    //log(1/frcpa(1+  78/256)
data8 0x3FD14BE2927AECD4    //log(1/frcpa(1+  79/256)
data8 0x3FD180618EF18ADF    //log(1/frcpa(1+  80/256)
data8 0x3FD1B50BBE2FC63B    //log(1/frcpa(1+  81/256)
data8 0x3FD1DF4CC7CF242D    //log(1/frcpa(1+  82/256)
data8 0x3FD214456D0EB8D4    //log(1/frcpa(1+  83/256)
data8 0x3FD23EC5991EBA49    //log(1/frcpa(1+  84/256)
data8 0x3FD2740D9F870AFB    //log(1/frcpa(1+  85/256)
data8 0x3FD29ECDABCDFA04    //log(1/frcpa(1+  86/256)
data8 0x3FD2D46602ADCCEE    //log(1/frcpa(1+  87/256)
data8 0x3FD2FF66B04EA9D4    //log(1/frcpa(1+  88/256)
data8 0x3FD335504B355A37    //log(1/frcpa(1+  89/256)
data8 0x3FD360925EC44F5D    //log(1/frcpa(1+  90/256)
data8 0x3FD38BF1C3337E75    //log(1/frcpa(1+  91/256)
data8 0x3FD3C25277333184    //log(1/frcpa(1+  92/256)
data8 0x3FD3EDF463C1683E    //log(1/frcpa(1+  93/256)
data8 0x3FD419B423D5E8C7    //log(1/frcpa(1+  94/256)
data8 0x3FD44591E0539F49    //log(1/frcpa(1+  95/256)
data8 0x3FD47C9175B6F0AD    //log(1/frcpa(1+  96/256)
data8 0x3FD4A8B341552B09    //log(1/frcpa(1+  97/256)
data8 0x3FD4D4F3908901A0    //log(1/frcpa(1+  98/256)
data8 0x3FD501528DA1F968    //log(1/frcpa(1+  99/256)
data8 0x3FD52DD06347D4F6    //log(1/frcpa(1+ 100/256)
data8 0x3FD55A6D3C7B8A8A    //log(1/frcpa(1+ 101/256)
data8 0x3FD5925D2B112A59    //log(1/frcpa(1+ 102/256)
data8 0x3FD5BF406B543DB2    //log(1/frcpa(1+ 103/256)
data8 0x3FD5EC433D5C35AE    //log(1/frcpa(1+ 104/256)
data8 0x3FD61965CDB02C1F    //log(1/frcpa(1+ 105/256)
data8 0x3FD646A84935B2A2    //log(1/frcpa(1+ 106/256)
data8 0x3FD6740ADD31DE94    //log(1/frcpa(1+ 107/256)
data8 0x3FD6A18DB74A58C5    //log(1/frcpa(1+ 108/256)
data8 0x3FD6CF31058670EC    //log(1/frcpa(1+ 109/256)
data8 0x3FD6F180E852F0BA    //log(1/frcpa(1+ 110/256)
data8 0x3FD71F5D71B894F0    //log(1/frcpa(1+ 111/256)
data8 0x3FD74D5AEFD66D5C    //log(1/frcpa(1+ 112/256)
data8 0x3FD77B79922BD37E    //log(1/frcpa(1+ 113/256)
data8 0x3FD7A9B9889F19E2    //log(1/frcpa(1+ 114/256)
data8 0x3FD7D81B037EB6A6    //log(1/frcpa(1+ 115/256)
data8 0x3FD8069E33827231    //log(1/frcpa(1+ 116/256)
data8 0x3FD82996D3EF8BCB    //log(1/frcpa(1+ 117/256)
data8 0x3FD85855776DCBFB    //log(1/frcpa(1+ 118/256)
data8 0x3FD8873658327CCF    //log(1/frcpa(1+ 119/256)
data8 0x3FD8AA75973AB8CF    //log(1/frcpa(1+ 120/256)
data8 0x3FD8D992DC8824E5    //log(1/frcpa(1+ 121/256)
data8 0x3FD908D2EA7D9512    //log(1/frcpa(1+ 122/256)
data8 0x3FD92C59E79C0E56    //log(1/frcpa(1+ 123/256)
data8 0x3FD95BD750EE3ED3    //log(1/frcpa(1+ 124/256)
data8 0x3FD98B7811A3EE5B    //log(1/frcpa(1+ 125/256)
data8 0x3FD9AF47F33D406C    //log(1/frcpa(1+ 126/256)
data8 0x3FD9DF270C1914A8    //log(1/frcpa(1+ 127/256)
data8 0x3FDA0325ED14FDA4    //log(1/frcpa(1+ 128/256)
data8 0x3FDA33440224FA79    //log(1/frcpa(1+ 129/256)
data8 0x3FDA57725E80C383    //log(1/frcpa(1+ 130/256)
data8 0x3FDA87D0165DD199    //log(1/frcpa(1+ 131/256)
data8 0x3FDAAC2E6C03F896    //log(1/frcpa(1+ 132/256)
data8 0x3FDADCCC6FDF6A81    //log(1/frcpa(1+ 133/256)
data8 0x3FDB015B3EB1E790    //log(1/frcpa(1+ 134/256)
data8 0x3FDB323A3A635948    //log(1/frcpa(1+ 135/256)
data8 0x3FDB56FA04462909    //log(1/frcpa(1+ 136/256)
data8 0x3FDB881AA659BC93    //log(1/frcpa(1+ 137/256)
data8 0x3FDBAD0BEF3DB165    //log(1/frcpa(1+ 138/256)
data8 0x3FDBD21297781C2F    //log(1/frcpa(1+ 139/256)
data8 0x3FDC039236F08819    //log(1/frcpa(1+ 140/256)
data8 0x3FDC28CB1E4D32FD    //log(1/frcpa(1+ 141/256)
data8 0x3FDC4E19B84723C2    //log(1/frcpa(1+ 142/256)
data8 0x3FDC7FF9C74554C9    //log(1/frcpa(1+ 143/256)
data8 0x3FDCA57B64E9DB05    //log(1/frcpa(1+ 144/256)
data8 0x3FDCCB130A5CEBB0    //log(1/frcpa(1+ 145/256)
data8 0x3FDCF0C0D18F326F    //log(1/frcpa(1+ 146/256)
data8 0x3FDD232075B5A201    //log(1/frcpa(1+ 147/256)
data8 0x3FDD490246DEFA6B    //log(1/frcpa(1+ 148/256)
data8 0x3FDD6EFA918D25CD    //log(1/frcpa(1+ 149/256)
data8 0x3FDD9509707AE52F    //log(1/frcpa(1+ 150/256)
data8 0x3FDDBB2EFE92C554    //log(1/frcpa(1+ 151/256)
data8 0x3FDDEE2F3445E4AF    //log(1/frcpa(1+ 152/256)
data8 0x3FDE148A1A2726CE    //log(1/frcpa(1+ 153/256)
data8 0x3FDE3AFC0A49FF40    //log(1/frcpa(1+ 154/256)
data8 0x3FDE6185206D516E    //log(1/frcpa(1+ 155/256)
data8 0x3FDE882578823D52    //log(1/frcpa(1+ 156/256)
data8 0x3FDEAEDD2EAC990C    //log(1/frcpa(1+ 157/256)
data8 0x3FDED5AC5F436BE3    //log(1/frcpa(1+ 158/256)
data8 0x3FDEFC9326D16AB9    //log(1/frcpa(1+ 159/256)
data8 0x3FDF2391A2157600    //log(1/frcpa(1+ 160/256)
data8 0x3FDF4AA7EE03192D    //log(1/frcpa(1+ 161/256)
data8 0x3FDF71D627C30BB0    //log(1/frcpa(1+ 162/256)
data8 0x3FDF991C6CB3B379    //log(1/frcpa(1+ 163/256)
data8 0x3FDFC07ADA69A910    //log(1/frcpa(1+ 164/256)
data8 0x3FDFE7F18EB03D3E    //log(1/frcpa(1+ 165/256)
data8 0x3FE007C053C5002E    //log(1/frcpa(1+ 166/256)
data8 0x3FE01B942198A5A1    //log(1/frcpa(1+ 167/256)
data8 0x3FE02F74400C64EB    //log(1/frcpa(1+ 168/256)
data8 0x3FE04360BE7603AD    //log(1/frcpa(1+ 169/256)
data8 0x3FE05759AC47FE34    //log(1/frcpa(1+ 170/256)
data8 0x3FE06B5F1911CF52    //log(1/frcpa(1+ 171/256)
data8 0x3FE078BF0533C568    //log(1/frcpa(1+ 172/256)
data8 0x3FE08CD9687E7B0E    //log(1/frcpa(1+ 173/256)
data8 0x3FE0A10074CF9019    //log(1/frcpa(1+ 174/256)
data8 0x3FE0B5343A234477    //log(1/frcpa(1+ 175/256)
data8 0x3FE0C974C89431CE    //log(1/frcpa(1+ 176/256)
data8 0x3FE0DDC2305B9886    //log(1/frcpa(1+ 177/256)
data8 0x3FE0EB524BAFC918    //log(1/frcpa(1+ 178/256)
data8 0x3FE0FFB54213A476    //log(1/frcpa(1+ 179/256)
data8 0x3FE114253DA97D9F    //log(1/frcpa(1+ 180/256)
data8 0x3FE128A24F1D9AFF    //log(1/frcpa(1+ 181/256)
data8 0x3FE1365252BF0865    //log(1/frcpa(1+ 182/256)
data8 0x3FE14AE558B4A92D    //log(1/frcpa(1+ 183/256)
data8 0x3FE15F85A19C765B    //log(1/frcpa(1+ 184/256)
data8 0x3FE16D4D38C119FA    //log(1/frcpa(1+ 185/256)
data8 0x3FE18203C20DD133    //log(1/frcpa(1+ 186/256)
data8 0x3FE196C7BC4B1F3B    //log(1/frcpa(1+ 187/256)
data8 0x3FE1A4A738B7A33C    //log(1/frcpa(1+ 188/256)
data8 0x3FE1B981C0C9653D    //log(1/frcpa(1+ 189/256)
data8 0x3FE1CE69E8BB106B    //log(1/frcpa(1+ 190/256)
data8 0x3FE1DC619DE06944    //log(1/frcpa(1+ 191/256)
data8 0x3FE1F160A2AD0DA4    //log(1/frcpa(1+ 192/256)
data8 0x3FE2066D7740737E    //log(1/frcpa(1+ 193/256)
data8 0x3FE2147DBA47A394    //log(1/frcpa(1+ 194/256)
data8 0x3FE229A1BC5EBAC3    //log(1/frcpa(1+ 195/256)
data8 0x3FE237C1841A502E    //log(1/frcpa(1+ 196/256)
data8 0x3FE24CFCE6F80D9A    //log(1/frcpa(1+ 197/256)
data8 0x3FE25B2C55CD5762    //log(1/frcpa(1+ 198/256)
data8 0x3FE2707F4D5F7C41    //log(1/frcpa(1+ 199/256)
data8 0x3FE285E0842CA384    //log(1/frcpa(1+ 200/256)
data8 0x3FE294294708B773    //log(1/frcpa(1+ 201/256)
data8 0x3FE2A9A2670AFF0C    //log(1/frcpa(1+ 202/256)
data8 0x3FE2B7FB2C8D1CC1    //log(1/frcpa(1+ 203/256)
data8 0x3FE2C65A6395F5F5    //log(1/frcpa(1+ 204/256)
data8 0x3FE2DBF557B0DF43    //log(1/frcpa(1+ 205/256)
data8 0x3FE2EA64C3F97655    //log(1/frcpa(1+ 206/256)
data8 0x3FE3001823684D73    //log(1/frcpa(1+ 207/256)
data8 0x3FE30E97E9A8B5CD    //log(1/frcpa(1+ 208/256)
data8 0x3FE32463EBDD34EA    //log(1/frcpa(1+ 209/256)
data8 0x3FE332F4314AD796    //log(1/frcpa(1+ 210/256)
data8 0x3FE348D90E7464D0    //log(1/frcpa(1+ 211/256)
data8 0x3FE35779F8C43D6E    //log(1/frcpa(1+ 212/256)
data8 0x3FE36621961A6A99    //log(1/frcpa(1+ 213/256)
data8 0x3FE37C299F3C366A    //log(1/frcpa(1+ 214/256)
data8 0x3FE38AE2171976E7    //log(1/frcpa(1+ 215/256)
data8 0x3FE399A157A603E7    //log(1/frcpa(1+ 216/256)
data8 0x3FE3AFCCFE77B9D1    //log(1/frcpa(1+ 217/256)
data8 0x3FE3BE9D503533B5    //log(1/frcpa(1+ 218/256)
data8 0x3FE3CD7480B4A8A3    //log(1/frcpa(1+ 219/256)
data8 0x3FE3E3C43918F76C    //log(1/frcpa(1+ 220/256)
data8 0x3FE3F2ACB27ED6C7    //log(1/frcpa(1+ 221/256)
data8 0x3FE4019C2125CA93    //log(1/frcpa(1+ 222/256)
data8 0x3FE4181061389722    //log(1/frcpa(1+ 223/256)
data8 0x3FE42711518DF545    //log(1/frcpa(1+ 224/256)
data8 0x3FE436194E12B6BF    //log(1/frcpa(1+ 225/256)
data8 0x3FE445285D68EA69    //log(1/frcpa(1+ 226/256)
data8 0x3FE45BCC464C893A    //log(1/frcpa(1+ 227/256)
data8 0x3FE46AED21F117FC    //log(1/frcpa(1+ 228/256)
data8 0x3FE47A1527E8A2D3    //log(1/frcpa(1+ 229/256)
data8 0x3FE489445EFFFCCC    //log(1/frcpa(1+ 230/256)
data8 0x3FE4A018BCB69835    //log(1/frcpa(1+ 231/256)
data8 0x3FE4AF5A0C9D65D7    //log(1/frcpa(1+ 232/256)
data8 0x3FE4BEA2A5BDBE87    //log(1/frcpa(1+ 233/256)
data8 0x3FE4CDF28F10AC46    //log(1/frcpa(1+ 234/256)
data8 0x3FE4DD49CF994058    //log(1/frcpa(1+ 235/256)
data8 0x3FE4ECA86E64A684    //log(1/frcpa(1+ 236/256)
data8 0x3FE503C43CD8EB68    //log(1/frcpa(1+ 237/256)
data8 0x3FE513356667FC57    //log(1/frcpa(1+ 238/256)
data8 0x3FE522AE0738A3D8    //log(1/frcpa(1+ 239/256)
data8 0x3FE5322E26867857    //log(1/frcpa(1+ 240/256)
data8 0x3FE541B5CB979809    //log(1/frcpa(1+ 241/256)
data8 0x3FE55144FDBCBD62    //log(1/frcpa(1+ 242/256)
data8 0x3FE560DBC45153C7    //log(1/frcpa(1+ 243/256)
data8 0x3FE5707A26BB8C66    //log(1/frcpa(1+ 244/256)
data8 0x3FE587F60ED5B900    //log(1/frcpa(1+ 245/256)
data8 0x3FE597A7977C8F31    //log(1/frcpa(1+ 246/256)
data8 0x3FE5A760D634BB8B    //log(1/frcpa(1+ 247/256)
data8 0x3FE5B721D295F10F    //log(1/frcpa(1+ 248/256)
data8 0x3FE5C6EA94431EF9    //log(1/frcpa(1+ 249/256)
data8 0x3FE5D6BB22EA86F6    //log(1/frcpa(1+ 250/256)
data8 0x3FE5E6938645D390    //log(1/frcpa(1+ 251/256)
data8 0x3FE5F673C61A2ED2    //log(1/frcpa(1+ 252/256)
data8 0x3FE6065BEA385926    //log(1/frcpa(1+ 253/256)
data8 0x3FE6164BFA7CC06B    //log(1/frcpa(1+ 254/256)
data8 0x3FE62643FECF9743    //log(1/frcpa(1+ 255/256)

   
.align 32
.global logf#
.global log10f#

// log10 has p7 true, p8 false
// log   has p8 true, p7 false

.section .text
.proc  log10f#
.align 32

log10f: 
{ .mfi
     alloc     r32=ar.pfs,1,15,4,0                    
     frcpa.s1  log_C,p9 = f1,f8                 
     cmp.eq.unc     p7,p8         = r0, r0 
}
{ .mfb
     addl           log_AD_1   = @ltoff(log_table_1), gp
     fnorm.s1 log_NORM_f8 = f8 
     br.sptk        LOG_LOG10_X 
}
;;

.endp log10f



.section .text
.proc  logf#
.align 32
logf: 

{ .mfi
     alloc     r32=ar.pfs,1,15,4,0                    
     frcpa.s1  log_C,p9 = f1,f8                 
     cmp.eq.unc     p8,p7         = r0, r0 
}
{ .mfi
     addl           log_AD_1   = @ltoff(log_table_1), gp
     fnorm.s1 log_NORM_f8 = f8 
     nop.i 999
}
;;

LOG_LOG10_X:

{ .mfi
     getf.exp   log_GR_signexp_f8 = f8 // If x unorm then must recompute
     fclass.m.unc p15,p0 = f8, 0x0b            // Test for x=unorm
     mov        log_GR_fff7 = 0xfff7
}
{ .mfi
     ld8 log_AD_1 = [log_AD_1]
     fms.s1     log_w = f8,f1,f1              
     mov       log_GR_exp_17_ones = 0x1ffff
}
;;

{ .mmi
     getf.sig   log_GR_significand_f8 = f8 // If x unorm then must recompute
     mov       log_GR_exp_16_ones = 0xffff
     nop.i 999
}
;;

{ .mmb
     adds log_AD_2 = 0x10, log_AD_1
     and        log_GR_exp_f8 = log_GR_signexp_f8, log_GR_exp_17_ones  
(p15) br.cond.spnt LOG_DENORM     
}
;;

LOG_COMMON:
{.mfi
     ldfpd      log_P3,log_P2 = [log_AD_1],16           
     fclass.m.unc p6,p0 = f8, 0xc3             // Test for x=nan
     shl        log_GR_index = log_GR_significand_f8,1            
}
{.mfi
     sub       log_GR_true_exp_f8 = log_GR_exp_f8, log_GR_exp_16_ones 
     nop.f 999
     nop.i 999
}
;;

{ .mfi
     ldfpd      log_P1,log_inv_ln10 = [log_AD_2],16           
     fclass.m.unc p11,p0 = f8, 0x21            // Test for x=+inf
     shr.u     log_GR_index = log_GR_index,56
}
{ .mfi
     setf.sig  log_int_Nfloat = log_GR_true_exp_f8
     nop.f 999
     nop.i 999
}
;;


{ .mfi
     ldfd       log_log2 = [log_AD_2],16   
     fma.s1     log_wsq     = log_w, log_w, f0
     nop.i 999
}
{ .mfb
     nop.m 999
(p6) fma.s.s0   f8 = f8,f1,f0      // quietize nan result if x=nan
(p6) br.ret.spnt b0                // Exit for x=nan
}
;;


{ .mfi
     shladd log_AD_2 = log_GR_index,3,log_AD_2
     fcmp.eq.s1 p10,p0 = log_NORM_f8, f1  // Test for x=+1.0
     nop.i 999
}
{ .mfb
     nop.m 999
     fms.s1     log_r = log_C,f8,f1
(p11) br.ret.spnt b0               // Exit for x=+inf
}
;;


{ .mmf
     nop.m 999
     nop.m 999
     fclass.m.unc p6,p0 = f8, 0x07        // Test for x=0
}
;;


{ .mfb
     ldfd       log_T = [log_AD_2]
(p10) fmerge.s f8 = f0, f0
(p10) br.ret.spnt b0                // Exit for x=1.0
;;
}

{ .mfi
     getf.exp   log_GR_signexp_w = log_w
     fclass.m.unc p12,p0 = f8, 0x3a       // Test for x neg norm, unorm, inf
     nop.i 999
}
;;

{ .mmb
     nop.m 999
     nop.m 999
(p6) br.cond.spnt LOG_ZERO_NEG      // Branch if x=0
;;
}
 

{ .mfi
     and log_GR_exp_w = log_GR_exp_17_ones, log_GR_signexp_w
     nop.f 999
     nop.i 999
}
{ .mfb
     nop.m 999
     fma.s1     log_rsq     = log_r, log_r, f0                   
(p12) br.cond.spnt LOG_ZERO_NEG     // Branch if x<0
;;
}

{ .mfi
     nop.m 999
     fma.s1      log_rp_p32 = log_P3, log_r, log_P2
     nop.i 999
}
{ .mfi
     nop.m 999
     fma.s1    log_rp_q32   = log_P3, log_w, log_P2
     nop.i 999
;;
}

{ .mfi
     nop.m 999
     fcvt.xf   log_Nfloat = log_int_Nfloat
     nop.i 999 ;;
}

{ .mfi
     nop.m 999
     fma.s1    log_rp_p10   = log_P1, log_r, f1
     nop.i 999
}
{ .mfi
     nop.m 999
     fma.s1    log_rp_q10  = log_P1, log_w, f1
     nop.i 999
;;
}

//    p13 <== large w log
//    p14 <== small w log
{ .mfi
(p8) cmp.ge.unc p13,p14 = log_GR_exp_w, log_GR_fff7
     fcmp.eq.s0 p6,p0 = f8,f0         // Sets flag on +denormal input
     nop.i 999
;;
}

//    p10 <== large w log10
//    p11 <== small w log10
{ .mfi
(p7) cmp.ge.unc p10,p11 = log_GR_exp_w, log_GR_fff7
     nop.f 999
     nop.i 999 ;;
}

{ .mfi
     nop.m 999
     fma.s1        log_T_plus_Nlog2 = log_Nfloat,log_log2, log_T    
     nop.i 999 ;;
}


{ .mfi
     nop.m 999
     fma.s1     log_rp_p2   = log_rp_p32, log_rsq, log_rp_p10
     nop.i 999
}
{ .mfi
     nop.m 999
     fma.s1     log_rp_q2   = log_rp_q32, log_wsq, log_rp_q10
     nop.i 999
;;
}


//    small w, log   <== p14
{ .mfi
     nop.m 999
(p14) fma.s        f8       = log_rp_q2, log_w, f0
     nop.i 999
}
{ .mfi
     nop.m 999
(p11) fma.s1        log_Q       = log_rp_q2, log_w, f0
     nop.i 999 ;;
}


//    large w, log   <== p13
.pred.rel "mutex",p13,p10
{ .mfi
      nop.m 999
(p13) fma.s        f8        = log_rp_p2, log_r, log_T_plus_Nlog2
      nop.i 999 
}
{ .mfi
      nop.m 999
(p10) fma.s1     log_Q     = log_rp_p2, log_r, log_T_plus_Nlog2
      nop.i 999  ;;
}


//    log10
{ .mfb
      nop.m 999
(p7)  fma.s      f8 = log_inv_ln10,log_Q,f0                         
      br.ret.sptk     b0 
;;
}


LOG_DENORM:
{ .mmi
     getf.exp   log_GR_signexp_f8 = log_NORM_f8 
     nop.m 999
     nop.i 999
}
;;
{ .mmb
     getf.sig   log_GR_significand_f8 = log_NORM_f8 
     and        log_GR_exp_f8 = log_GR_signexp_f8, log_GR_exp_17_ones  
     br.cond.sptk LOG_COMMON
}
;;

LOG_ZERO_NEG: 

// qnan snan inf norm     unorm 0 -+
// 0    0    0   0        0     1 11      0x7
// 0    0    1   1        1     0 10      0x3a

// Save x (f8) in f10
{ .mfi
     nop.m 999
     fmerge.s f10 = f8,f8 
     nop.i 999  ;;
}

// p8 p9  means  ln(+-0)  = -inf
// p7 p10 means  log(+-0) = -inf

//    p13 means  ln(-)
//    p14 means  log(-)


{ .mfi
     nop.m 999
     fmerge.ns   f6 = f1,f1            // Form -1.0
     nop.i 999  ;;
}

// p9  means  ln(+-0)  = -inf
// p10 means  log(+-0) = -inf
// Log(+-0) = -inf 

{ .mfi
	nop.m 999
(p8)  fclass.m.unc  p9,p0 = f10, 0x07           
	nop.i 999
}
{ .mfi
	nop.m 999
(p7)  fclass.m.unc  p10,p0 = f10, 0x07           
	nop.i 999 ;;
}


// p13  ln(-)
// p14  log(-)

// Log(-inf, -normal, -unnormal) = QNAN indefinite
{ .mfi
	nop.m 999
(p8)  fclass.m.unc  p13,p0 = f10, 0x3a           
	nop.i 999 
}
{ .mfi
	nop.m 999
(p7)  fclass.m.unc  p14,p0 = f10, 0x3a           
	nop.i 999  ;;
}


.pred.rel "mutex",p9,p10
{ .mfi
(p9)     mov        log_GR_tag = 4       
(p9)    frcpa f8,p11 = f6,f0                   
            nop.i 999
}
{ .mfi
(p10)    mov        log_GR_tag = 10       
(p10)   frcpa f8,p12 = f6,f0                   
            nop.i 999 ;;
}

.pred.rel "mutex",p13,p14
{ .mfi
(p13)    mov        log_GR_tag = 5       
(p13)    frcpa f8,p11 = f0,f0                   
            nop.i 999
}
{ .mfb
(p14)    mov        log_GR_tag = 11       
(p14)   frcpa f8,p12 = f0,f0                   
        br.cond.sptk __libm_error_region ;; 
}
.endp log


// Stack operations when calling error support.
//       (1)               (2)                          (3) (call)              (4)
//   sp   -> +          psp -> +                     psp -> +                   sp -> +
//           |                 |                            |                         |
//           |                 | <- GR_Y               R3 ->| <- GR_RESULT            | -> f8
//           |                 |                            |                         |
//           | <-GR_Y      Y2->|                       Y2 ->| <- GR_Y                 |
//           |                 |                            |                         |
//           |                 | <- GR_X               X1 ->|                         |
//           |                 |                            |                         |
//  sp-64 -> +          sp ->  +                     sp ->  +                         +
//    save ar.pfs          save b0                                               restore gp
//    save gp                                                                    restore ar.pfs



.proc __libm_error_region
__libm_error_region:
.prologue

// (1)
{ .mfi
        add   GR_Parameter_Y=-32,sp             // Parameter 2 value
        nop.f 0
.save   ar.pfs,GR_SAVE_PFS
        mov  GR_SAVE_PFS=ar.pfs                 // Save ar.pfs
}
{ .mfi
.fframe 64
        add sp=-64,sp                          // Create new stack
        nop.f 0
        mov GR_SAVE_GP=gp                      // Save gp
};;


// (2)
{ .mmi
        stfs [GR_Parameter_Y] = f1,16         // STORE Parameter 2 on stack
        add GR_Parameter_X = 16,sp            // Parameter 1 address
.save   b0, GR_SAVE_B0
        mov GR_SAVE_B0=b0                     // Save b0
};;

.body
// (3)
{ .mib
        stfs [GR_Parameter_X] = f10                   // STORE Parameter 1 on stack
        add   GR_Parameter_RESULT = 0,GR_Parameter_Y  // Parameter 3 address
        nop.b 0                             
}
{ .mib
        stfs [GR_Parameter_Y] = f8                    // STORE Parameter 3 on stack
        add   GR_Parameter_Y = -16,GR_Parameter_Y
        br.call.sptk b0=__libm_error_support#         // Call error handling function
};;

{ .mmi
        nop.m 0
        nop.m 0
        add   GR_Parameter_RESULT = 48,sp
};;

// (4)
{ .mmi
        ldfs  f8 = [GR_Parameter_RESULT]       // Get return result off stack
.restore
        add   sp = 64,sp                       // Restore stack pointer
        mov   b0 = GR_SAVE_B0                  // Restore return address
};;
{ .mib
        mov   gp = GR_SAVE_GP                  // Restore gp
        mov   ar.pfs = GR_SAVE_PFS             // Restore ar.pfs
        br.ret.sptk     b0                     // Return
};;

.endp __libm_error_region


.type   __libm_error_support#,@function
.global __libm_error_support#
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\ia64\rerun.s ===
//##########################################################################
//**
//**  Copyright  (C) 1996-2000 Intel Corporation. All rights reserved. 
//**
//** The information and source code contained herein is the exclusive 
//** property of Intel Corporation and may not be disclosed, examined
//** or reproduced in whole or in part without explicit written authorization 
//** from the company.
//**
//###########################################################################

  .file "rerun.s"
  .section .text
  .align 32

  .proc _xrun1args#
  .global _xrun1args#
  .align 32
_xrun1args:
  alloc	r31=ar.pfs,4,4,0,0  // r32, r33, r34, r35, r36, r37, r38, r39

  // OpCode is in r32
  // &fpsr is in r33
  // &fr1 (output) is in r34
  // &fr2 (input) is in r35

  // save old FPSR in r36
  mov.m r36 = ar40
  // save predicates in r38
  mov r38 = pr;;
  // load fpsr in r37
  ld8 r37 = [r33];;
  // set new value of FPSR
  mov ar40 = r37;;
  // clear predicates
  movl r39 = 0x0000000000000001;;
  // load clear predicates from r39
  mov pr = r39,0x1ffff;;
  // load input argument into f8
  ldf.fill f8 = [r35];;
  cmp4.eq p1, p2 = 1, r32;;  // fprsqrta [not used]
  (p2) cmp4.eq.unc p2, p3 = 2, r32;; // fpcvt_fx
  (p3) cmp4.eq.unc p3, p4 = 3, r32;; // fpcvt_fxu
  (p4) cmp4.eq.unc p4, p5 = 4, r32;; // fpcvt_fx_trunc
  (p5) cmp4.eq.unc p5, p6 = 5, r32;; // fpcvt_fxu_trunc
  (p1) fprsqrta.s0 f9,p7 = f8;; // 1/sqrt(f8) in f9
  (p2) fpcvt.fx.s0 f9 = f8;;
  (p3) fpcvt.fxu.s0 f9 = f8;;
  (p4) fpcvt.fx.trunc.s0 f9 = f8;;
  (p5) fpcvt.fxu.trunc.s0 f9 = f8;;
  (p6) mov f9 = f0 // return 0
  // restore predicates from r38
  mov pr = r38,0x1ffff;;
  // store result
  stf.spill [r34] = f9;;
  // save FPSR
  mov.m r37 = ar40;;
  st8 [r33] = r37
  // restore FPSR
  mov ar40 = r36;;
  // return
  br.ret.sptk b0
  .endp _xrun1args


  .proc  _xrun2args#
  .global _xrun2args#
  .align 32

_xrun2args:
  alloc	r31=ar.pfs,5,4,0,0  // r32, r33, r34, r35, r36, r37, r38, r39, r40

  // OpCode is in r32
  // &fpsr is in r33
  // &fr1 (output) is in r34
  // &fr2 (input) is in r35
  // &fr3 (input) is in r36

  // save old FPSR in r37
  mov r37 = ar40
  // save predicates in r39
  mov r39 = pr;;
  // load fpsr in r38
  ld8 r38 = [r33];;
  // set new value of FPSR
  mov ar40 = r38;;
  // clear predicates
  movl r40 = 0x0000000000000001;;
  // load clear predicates from r40
  mov pr = r40,0x1ffff;;
  // load first input argument into f8
  ldf.fill f8 = [r35]
  // load second input argument into f9
  ldf.fill f9 = [r36];;
  cmp4.eq p1, p2 = 1, r32;;  // fprcpa [not used - fprcpa not re-executed]
  (p2) cmp4.eq.unc p2, p3 = 2, r32;; // fpcmp_eq
  (p3) cmp4.eq.unc p3, p4 = 3, r32;; // fpcmp_lt
  (p4) cmp4.eq.unc p4, p5 = 4, r32;; // fpcmp_le
  (p5) cmp4.eq.unc p5, p6 = 5, r32;; // fpcmp_unord
  (p6) cmp4.eq.unc p6, p7 = 6, r32;; // fpcmp_neq
  (p7) cmp4.eq.unc p7, p8 = 7, r32;; // fpcmp_nlt
  (p8) cmp4.eq.unc p8, p9 = 8, r32;; // fpcmp_nle
  (p9) cmp4.eq.unc p9, p10 = 9, r32;; // fpcmp_ord
  (p10) cmp4.eq.unc p10, p11 = 10, r32;; // fpmin
  (p11) cmp4.eq.unc p11, p12 = 11, r32;; // fpmax
  (p12) cmp4.eq.unc p12, p13 = 12, r32;; // fpamin
  (p13) cmp4.eq.unc p13, p14 = 13, r32;; // fpamax
  (p1) fprcpa.s0 f10 , p15 = f8, f9;; // 1 / f3 in f4
  (p2) fpcmp.eq.s0 f10 = f8, f9;;
  (p3) fpcmp.lt.s0 f10 = f8, f9;;
  (p4) fpcmp.le.s0 f10 = f8, f9;;
  (p5) fpcmp.unord.s0 f10 = f8, f9;;
  (p6) fpcmp.neq.s0 f10 = f8, f9;;
  (p7) fpcmp.nlt.s0 f10 = f8, f9;;
  (p8) fpcmp.nle.s0 f10 = f8, f9;;
  (p9) fpcmp.ord.s0 f10 = f8, f9;;
  (p10) fpmin.s0 f10 = f8, f9;;
  (p11) fpmax.s0 f10 = f8, f9;;
  (p12) fpamin.s0 f10 = f8, f9;;
  (p13) fpamax.s0 f10 = f8, f9;;
  (p14) mov f10 = f0 // return 0
  // restore predicates from r39
  mov pr = r39,0x1ffff;;
  // store result
  stf.spill [r34] = f10
  // save FPSR
  mov.m r38 = ar40;;
  st8 [r33] = r38
  // restore FPSR
  mov ar40 = r37;;
  // return
  br.ret.sptk b0
  .endp _xrun2args


  .proc  _xrun3args#
  .global _xrun3args#
  .align 32

_xrun3args:
  alloc	r31=ar.pfs,6,4,0,0  // r32, r33, r34, r35, r36, r37, r38, r39, r40, r41

  // OpCode is in r32
  // &fpsr is in r33
  // &fr1 (output) is in r34
  // &fr2 (input) is in r35
  // &fr3 (input) is in r36
  // &fr4 (input) is in r37

  // save old FPSR in r38
  mov r38 = ar40
  // save predicates in r40
  mov r40 = pr;;
  // load fpsr in r39
  ld8 r39 = [r33];;
  // set new value of FPSR
  mov ar40 = r39;;
  // clear predicates
  movl r41 = 0x0000000000000001;;
  // load clear predicates from r41
  mov pr = r41,0x1ffff;;
  // load first input argument into f8
  ldf.fill f8 = [r35]
  // load second input argument into f9
  ldf.fill f9 = [r36];;
  // load third input argument into f10
  ldf.fill f10 = [r37];;
  cmp4.eq p1, p2 = 1, r32;; // fpma
  (p2) cmp4.eq.unc p2, p3 = 2, r32;; // fpms
  (p3) cmp4.eq.unc p3, p4 = 3, r32;; // fpnma
  (p1) fpma.s0 f11 = f8, f9, f10;; // f11 = f8 * f9 + f10
  (p2) fpms.s0 f11 = f8, f9, f10;; // f11 = f8 * f9 - f10
  (p3) fpnma.s0 f11 = f8, f9, f10;; // f11 = -f8 * f9 + f10
  (p4) mov f11 = f0 // return 0
  // restore predicates from r40
  mov pr = r40,0x1ffff;;
  // store result
  stf.spill [r34] = f11
  // save FPSR
  mov.m r39 = ar40;;
  st8 [r33] = r39
  // restore FPSR
  mov ar40 = r38
  // return
  br.ret.sptk b0
  .endp _xrun3args


  .proc  _thmB#
  .global _thmB#
  .align 32

_thmB:
  alloc r31=ar.pfs,4,2,0,0  // r32, r33, r34, r35, r36, r37

  // &a is in r32 
  // &b is in r33 
  // &div is in r34 (the address of the divide result)
  // &fpsr is in r35

  // general registers used: r31, r32, r33, r34, r35, r36, r37
  // predicate registers used: p6
  // floating-point registers used: f6, f7, f8

  // save old FPSR in r36
  mov r36 = ar40
  // load fpsr in r37
  ld8 r37 = [r35];;
  // set new value of FPSR
  mov ar40 = r37
  // load a, the first argument, in f6
  ldfs f6 = [r32];;
  // load b, the second argument, in f7
  ldfs f7 = [r33];;
  // Step (1)
  // y0 = 1 / b in f8
  frcpa.s0 f8,p6=f6,f7;;
  // Step (2)
  // q0 = a * y0 in f6
  (p6) fma.s1 f6=f6,f8,f0
  // Step (3)
  // e0 = 1 - b * y0 in f7
  (p6) fnma.s1 f7=f7,f8,f1;;
  // Step (4)
  // q1 = q0 + e0 * q0 in f6
  (p6) fma.s1 f6=f7,f6,f6
  // Step (5)
  // e1 = e0 * e0 in f7
  (p6) fma.s1 f7=f7,f7,f0;;
  // Step (6)
  // q2 = q1 + e1 * q1 in f6
  (p6) fma.s1 f6=f7,f6,f6
  // Step (7)
  // e2 = e1 * e1 in f7
  (p6) fma.s1 f7=f7,f7,f0;;
  // Step (8)
  // q3 = q2 + e2 * q2 in f6
  (p6) fma.d.s1 f6=f7,f6,f6;;
  // Step (9)
  // q3' = q3 in f8
  (p6) fma.s.s0 f8=f6,f1,f0;;
  // store result
  stfs [r34]=f8
  // save fpsr
  mov.m r37 = ar40;;
  st8 [r35] = r37
  // restore FPSR
  mov ar40 = r36;;
  // return
  br.ret.sptk b0

  .endp _thmB


  .proc  _thmH#
  .global _thmH#
  .align 32

_thmH:
  alloc r31=ar.pfs,3,2,0,0  // r32, r33, r34, r35, r36

  // &a is in r32
  // &sqrt is in r33 (the address of the sqrt result)
  // &fpsr in r34

  // general registers used: r31, r32, r33, r34, r35
  // predicate registers used: p6
  // floating-point registers used: f6, f7, f8, f9, f10, f11, f12

  //  save old FPSR in r35
  mov r35 = ar40
  // load fpsr in r36
  ld8 r36 = [r34];;
  // set new value of FPSR
  mov ar40 = r36
  // exponent of +1/2 in r2
  movl r2 = 0x0fffe;;
  // +1/2 in f7
  setf.exp f7 = r2
  // load the argument a in f6
  ldfs f6 = [r32];;
  // Step (1)
  // y0 = 1/sqrt(a) in f8
  frsqrta.s0 f8,p6=f6;;
  // Step (2)
  // h = +1/2 * a in f9
  (p6) fma.s1 f9=f7,f6,f0
  // Step (3)
  // t1 = y0 * y0 in f10
  (p6) fma.s1 f10=f8,f8,f0;;
  // Step (4)
  // t2 = 1/2 - t1 * h in f10
  (p6) fnma.s1 f10=f10,f9,f7;;
  // Step (5)
  // y1 = y0 + t2 * y0 in f8
  (p6) fma.s1 f8=f10,f8,f8;;
  // Step (6)
  // S = a * y1 in f10
  (p6) fma.s1 f10=f6,f8,f0
  // Step (7)
  // t3 = y1 * h in f9
  (p6) fma.s1 f9=f8,f9,f0
  // Step (8)
  // H = 1/2 * y1 in f11
  (p6) fma.s1 f11=f7,f8,f0;;
  // Step (9)
  // d = a - S * S in f12
  (p6) fnma.s1 f12=f10,f10,f6
  // Step (10)
  // t4 = 1/2 - t3 * y1 in f7
  (p6) fnma.s1 f7=f9,f8,f7;;
  // Step (11)
  // S1 = S + d * H in f8
  (p6) fma.s.s1 f8=f12,f11,f10
  // Step (12)
  // H1 = H + t4 * H in f7
  (p6) fma.s1 f7=f7,f11,f11;;
  // Step (13)
  // d1 = a - S1 * S1 in f6
  (p6) fnma.s1 f6=f8,f8,f6;;
  // Step (14)
  // R = S1 + d1 * H1 in f8
  (p6) fma.s.s0 f8=f6,f7,f8;;
  // store result
  stfs [r33]=f8
  // save fpsr
  mov.m r36 = ar40;;
  st8 [r34] = r36
  // restore FPSR
  mov ar40 = r35;;
  // return
  br.ret.sptk b0

  .endp _thmH
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\ia64\nt_tran.c ===
#include <math.h>
#include <trans.h>

#pragma function(asinf, acosf, atan2f, atanf, ceilf, expf, fabsf, floorf, fmodf, log10f, logf, powf, sinf, cosf, sinhf, coshf, sqrtf, tanf, tanhf)

float __cdecl asinf (float x) {return (float)asin((double) x);}

float __cdecl acosf (float x) {return (float)acos((double) x);}

float __cdecl atan2f (float v, float u) {return (float)atan2((double) v, (double) u); }

float __cdecl atanf (float x) {return (float)atan((double) x);}

float __cdecl ceilf (float x) {return (float)ceil((double) x);}

float __cdecl expf (float x) {return (float)exp((double) x);}

float __cdecl fabsf (float x) {return (float)fabs((double) x);}

float __cdecl floorf (float x) {return (float)floor((double) x);}

float __cdecl fmodf(float x, float y) {return ((float)fmod((double)x, (double)y));}

float __cdecl log10f (float x) {return (float)log10((double) x);}

float __cdecl logf (float x) {return (float)log((double) x);}

float __cdecl powf (float x, float y) {return (float)pow((double) x, (double) y);}

float __cdecl sinf (float x) {return (float)sin((double) x);}

float __cdecl cosf (float x) {return (float)cos((double) x);}

float __cdecl sinhf (float x) {return (float)sinh((double) x);}

float __cdecl coshf (float x) {return (float)cosh((double) x);}

float __cdecl sqrtf (float x) {return (float)sqrt((double) x);}

float __cdecl tanf (float x) {return (float)tan((double) x);}

float __cdecl tanhf (float x) {return (float)tanh((double) x);}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\ia64\sincos.s ===
.file "sincos.s"

// Copyright (c) 2000, Intel Corporation
// All rights reserved.
// 
// Contributed 2/2/2000 by John Harrison, Ted Kubaska, Bob Norin, Shane Story,
// and Ping Tak Peter Tang of the Computational Software Lab, Intel Corporation.
// 
// WARRANTY DISCLAIMER
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS 
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY 
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
// 
// Intel Corporation is the author of this code, and requests that all
// problem reports or change requests be submitted to it directly at 
// http://developer.intel.com/opensource.
//
// History
//==============================================================
// 2/02/00  Initial revision 
// 4/02/00  Unwind support added.
// 6/16/00  Updated tables to enforce symmetry
// 8/31/00  Saved 2 cycles in main path, and 9 in other paths.
// 9/20/00  The updated tables regressed to an old version, so reinstated them

// API
//==============================================================
// double sin( double x);
// double cos( double x);
//
// Overview of operation
//==============================================================
//
// Step 1
// ======
// Reduce x to region -1/2*pi/2^k ===== 0 ===== +1/2*pi/2^k
//    divide x by pi/2^k. 
//    Multiply by 2^k/pi.  
//    nfloat = Round result to integer (round-to-nearest) 
// 
// r = x -  nfloat * pi/2^k 
//    Do this as (x -  nfloat * HIGH(pi/2^k)) - nfloat * LOW(pi/2^k) for increased accuracy. 
//    pi/2^k is stored as two numbers that when added make pi/2^k. 
//       pi/2^k = HIGH(pi/2^k) + LOW(pi/2^k) 
// 
// x = (nfloat * pi/2^k) + r 
//    r is small enough that we can use a polynomial approximation 
//    and is referred to as the reduced argument.  
// 
// Step 3
// ======
// Take the unreduced part and remove the multiples of 2pi.  
// So nfloat = nfloat (with lower k+1 bits cleared) + lower k+1 bits
// 
//    nfloat (with lower k+1 bits cleared) is a multiple of 2^(k+1) 
//    N * 2^(k+1)
//    nfloat * pi/2^k = N * 2^(k+1) * pi/2^k + (lower k+1 bits) * pi/2^k
//    nfloat * pi/2^k = N * 2 * pi + (lower k+1 bits) * pi/2^k
//    nfloat * pi/2^k = N2pi + M * pi/2^k
// 
// 
// Sin(x) = Sin((nfloat * pi/2^k) + r)
//        = Sin(nfloat * pi/2^k) * Cos(r) + Cos(nfloat * pi/2^k) * Sin(r)
// 
//          Sin(nfloat * pi/2^k) = Sin(N2pi + Mpi/2^k) 
//                               = Sin(N2pi)Cos(Mpi/2^k) + Cos(N2pi)Sin(Mpi/2^k)
//                               = Sin(Mpi/2^k)
// 
//          Cos(nfloat * pi/2^k) = Cos(N2pi + Mpi/2^k) 
//                               = Cos(N2pi)Cos(Mpi/2^k) + Sin(N2pi)Sin(Mpi/2^k)
//                               = Cos(Mpi/2^k)
// 
// Sin(x) = Sin(Mpi/2^k) Cos(r) + Cos(Mpi/2^k) Sin(r)
// 
// 
// Step 4
// ======
// 0 <= M < 2^(k+1)
// There are 2^(k+1) Sin entries in a table.
// There are 2^(k+1) Cos entries in a table.
// 
// Get Sin(Mpi/2^k) and Cos(Mpi/2^k) by table lookup.
// 
// 
// Step 5
// ======
// Calculate Cos(r) and Sin(r) by polynomial approximation.
// 
// Cos(r) = 1 + r^2 q1  + r^4 q2 + r^6 q3 + ... = Series for Cos
// Sin(r) = r + r^3 p1  + r^5 p2 + r^7 p3 + ... = Series for Sin
//
// and the coefficients q1, q2, ... and p1, p2, ... are stored in a table
// 
// 
// Calculate
// Sin(x) = Sin(Mpi/2^k) Cos(r) + Cos(Mpi/2^k) Sin(r)
// 
// as follows
// 
//    Sm = Sin(Mpi/2^k) and Cm = Cos(Mpi/2^k)
//    rsq = r*r
// 
// 
//    P = p1 + r^2p2 + r^4p3 + r^6p4
//    Q = q1 + r^2q2 + r^4q3 + r^6q4
// 
//       rcub = r * rsq 
//       Sin(r) = r + rcub * P
//              = r + r^3p1  + r^5p2 + r^7p3 + r^9p4 + ... = Sin(r)
// 
//            The coefficients are not exactly these values, but almost.
// 
//            p1 = -1/6  = -1/3!
//            p2 = 1/120 =  1/5!
//            p3 = -1/5040 = -1/7!
//            p4 = 1/362889 = 1/9!
// 
//       P =  r + rcub * P
// 
//    Answer = Sm Cos(r) + Cm P 
// 
//       Cos(r) = 1 + rsq Q
//       Cos(r) = 1 + r^2 Q
//       Cos(r) = 1 + r^2 (q1 + r^2q2 + r^4q3 + r^6q4)
//       Cos(r) = 1 + r^2q1 + r^4q2 + r^6q3 + r^8q4 + ...
// 
//       Sm Cos(r) = Sm(1 + rsq Q)
//       Sm Cos(r) = Sm + Sm rsq Q
//       Sm Cos(r) = Sm + s_rsq Q
//       Q         = Sm + s_rsq Q 
// 
// Then,
// 
//    Answer = Q + Cm P


// Registers used
//==============================================================
// general input registers: 
// r32 -> r45 

// predicate registers used:  
// p6 -> p13

// floating-point registers used:  31
// f9 -> f15
// f32 -> f54

// Assembly macros
//==============================================================
sind_W                       = f10
sind_int_Nfloat              = f11
sind_Nfloat                  = f12

sind_r                       = f13
sind_rsq                     = f14
sind_rcub                    = f15

sind_Inv_Pi_by_16            = f32
sind_Pi_by_16_hi             = f33
sind_Pi_by_16_lo             = f34

sind_Inv_Pi_by_64            = f35
sind_Pi_by_64_hi             = f36
sind_Pi_by_64_lo             = f37

sind_Sm                      = f38
sind_Cm                      = f39

sind_P1                      = f40
sind_Q1                      = f41
sind_P2                      = f42
sind_Q2                      = f43
sind_P3                      = f44
sind_Q3                      = f45
sind_P4                      = f46
sind_Q4                      = f47

sind_P_temp1                 = f48
sind_P_temp2                 = f49

sind_Q_temp1                 = f50
sind_Q_temp2                 = f51

sind_P                       = f52
sind_Q                       = f53

sind_srsq                    = f54

/////////////////////////////////////////////////////////////

sind_r_signexp               = r36
sind_AD_beta_table           = r37
sind_r_sincos                = r38

sind_r_exp                   = r39
sind_r_17_ones               = r40

GR_SAVE_PFS                  = r41
GR_SAVE_B0                   = r42
GR_SAVE_GP                   = r43


.data

.align 16
double_sind_pi:
   data8 0xA2F9836E4E44152A, 0x00004001 // 16/pi
//         c90fdaa22168c234 
   data8 0xC90FDAA22168C234, 0x00003FFC // pi/16 hi
//         c4c6628b80dc1cd1  29024e088a
   data8 0xC4C6628B80DC1CD1, 0x00003FBC

double_sind_pq_k4:
   data8 0x3EC71C963717C63A // P4
   data8 0x3EF9FFBA8F191AE6 // Q4
   data8 0xBF2A01A00F4E11A8 // P3
   data8 0xBF56C16C05AC77BF // Q3
   data8 0x3F8111111110F167 // P2
   data8 0x3FA555555554DD45 // Q2
   data8 0xBFC5555555555555 // P1
   data8 0xBFDFFFFFFFFFFFFC // Q1


double_sin_cos_beta_k4:

data8 0x0000000000000000 , 0x00000000 // sin( 0 pi/16)  S0
data8 0x8000000000000000 , 0x00003fff // cos( 0 pi/16)  C0

data8 0xc7c5c1e34d3055b3 , 0x00003ffc // sin( 1 pi/16)  S1
data8 0xfb14be7fbae58157 , 0x00003ffe // cos( 1 pi/16)  C1

data8 0xc3ef1535754b168e , 0x00003ffd // sin( 2 pi/16)  S2
data8 0xec835e79946a3146 , 0x00003ffe // cos( 2 pi/16)  C2

data8 0x8e39d9cd73464364 , 0x00003ffe // sin( 3 pi/16)  S3
data8 0xd4db3148750d181a , 0x00003ffe // cos( 3 pi/16)  C3

data8 0xb504f333f9de6484 , 0x00003ffe // sin( 4 pi/16)  S4
data8 0xb504f333f9de6484 , 0x00003ffe // cos( 4 pi/16)  C4


data8 0xd4db3148750d181a , 0x00003ffe // sin( 5 pi/16)  C3
data8 0x8e39d9cd73464364 , 0x00003ffe // cos( 5 pi/16)  S3

data8 0xec835e79946a3146 , 0x00003ffe // sin( 6 pi/16)  C2
data8 0xc3ef1535754b168e , 0x00003ffd // cos( 6 pi/16)  S2

data8 0xfb14be7fbae58157 , 0x00003ffe // sin( 7 pi/16)  C1
data8 0xc7c5c1e34d3055b3 , 0x00003ffc // cos( 7 pi/16)  S1

data8 0x8000000000000000 , 0x00003fff // sin( 8 pi/16)  C0
data8 0x0000000000000000 , 0x00000000 // cos( 8 pi/16)  S0


data8 0xfb14be7fbae58157 , 0x00003ffe // sin( 9 pi/16)  C1
data8 0xc7c5c1e34d3055b3 , 0x0000bffc // cos( 9 pi/16)  -S1

data8 0xec835e79946a3146 , 0x00003ffe // sin(10 pi/16)  C2
data8 0xc3ef1535754b168c , 0x0000bffd // cos(10 pi/16)  -S2

data8 0xd4db3148750d181a , 0x00003ffe // sin(11 pi/16)  C3
data8 0x8e39d9cd73464364 , 0x0000bffe // cos(11 pi/16)  -S3

data8 0xb504f333f9de6484 , 0x00003ffe // sin(12 pi/16)  S4
data8 0xb504f333f9de6484 , 0x0000bffe // cos(12 pi/16)  -S4


data8 0x8e39d9cd73464364 , 0x00003ffe // sin(13 pi/16) S3
data8 0xd4db3148750d181a , 0x0000bffe // cos(13 pi/16) -C3

data8 0xc3ef1535754b168e , 0x00003ffd // sin(14 pi/16) S2
data8 0xec835e79946a3146 , 0x0000bffe // cos(14 pi/16) -C2

data8 0xc7c5c1e34d3055b3 , 0x00003ffc // sin(15 pi/16) S1
data8 0xfb14be7fbae58157 , 0x0000bffe // cos(15 pi/16) -C1

data8 0x0000000000000000 , 0x00000000 // sin(16 pi/16) S0
data8 0x8000000000000000 , 0x0000bfff // cos(16 pi/16) -C0

data8 0xc7c5c1e34d3055b3 , 0x0000bffc // sin(17 pi/16) -S1
data8 0xfb14be7fbae58157 , 0x0000bffe // cos(17 pi/16) -C1

data8 0xc3ef1535754b168e , 0x0000bffd // sin(18 pi/16) -S2
data8 0xec835e79946a3146 , 0x0000bffe // cos(18 pi/16) -C2

data8 0x8e39d9cd73464364 , 0x0000bffe // sin(19 pi/16) -S3
data8 0xd4db3148750d181a , 0x0000bffe // cos(19 pi/16) -C3

data8 0xb504f333f9de6484 , 0x0000bffe // sin(20 pi/16) -S4
data8 0xb504f333f9de6484 , 0x0000bffe // cos(20 pi/16) -S4


data8 0xd4db3148750d181a , 0x0000bffe // sin(21 pi/16) -C3
data8 0x8e39d9cd73464364 , 0x0000bffe // cos(21 pi/16) -S3

data8 0xec835e79946a3146 , 0x0000bffe // sin(22 pi/16) -C2
data8 0xc3ef1535754b168e , 0x0000bffd // cos(22 pi/16) -S2

data8 0xfb14be7fbae58157 , 0x0000bffe // sin(23 pi/16) -C1
data8 0xc7c5c1e34d3055b3 , 0x0000bffc // cos(23 pi/16) -S1

data8 0x8000000000000000 , 0x0000bfff // sin(24 pi/16) -C0
data8 0x0000000000000000 , 0x00000000 // cos(24 pi/16) S0


data8 0xfb14be7fbae58157 , 0x0000bffe // sin(25 pi/16) -C1
data8 0xc7c5c1e34d3055b3 , 0x00003ffc // cos(25 pi/16) S1

data8 0xec835e79946a3146 , 0x0000bffe // sin(26 pi/16) -C2
data8 0xc3ef1535754b168e , 0x00003ffd // cos(26 pi/16) S2

data8 0xd4db3148750d181a , 0x0000bffe // sin(27 pi/16) -C3
data8 0x8e39d9cd73464364 , 0x00003ffe // cos(27 pi/16) S3

data8 0xb504f333f9de6484 , 0x0000bffe // sin(28 pi/16) -S4
data8 0xb504f333f9de6484 , 0x00003ffe // cos(28 pi/16) S4


data8 0x8e39d9cd73464364 , 0x0000bffe // sin(29 pi/16) -S3
data8 0xd4db3148750d181a , 0x00003ffe // cos(29 pi/16) C3

data8 0xc3ef1535754b168e , 0x0000bffd // sin(30 pi/16) -S2
data8 0xec835e79946a3146 , 0x00003ffe // cos(30 pi/16) C2

data8 0xc7c5c1e34d3055b3 , 0x0000bffc // sin(31 pi/16) -S1
data8 0xfb14be7fbae58157 , 0x00003ffe // cos(31 pi/16) C1

data8 0x0000000000000000 , 0x00000000 // sin(32 pi/16) S0
data8 0x8000000000000000 , 0x00003fff // cos(32 pi/16) C0
   
.align 32
.global sin#
.global cos#

////////////////////////////////////////////////////////
// There are two entry points: sin and cos 


// If from sin, p8 is true
// If from cos, p9 is true

.section .text
.proc  sin#
.align 32

sin: 

// The initial fnorm will take any unmasked faults and
// normalize any single/double unorms

{ .mfi
      alloc          r32=ar.pfs,1,13,0,0               
(p0)  fnorm     f8  = f8   
(p0)  cmp.eq.unc     p8,p9         = r0, r0            
}
{ .mib
(p0)  addl           r33   = @ltoff(double_sind_pi), gp
(p0)  mov            sind_r_sincos = 0x0               
(p0)  br.sptk        SIND_SINCOS ;;                       
}

.endp sin    


.section .text
.proc  cos#
.align 32
cos: 

// The initial fnorm will take any unmasked faults and
// normalize any single/double unorms
{ .mfi
      alloc          r32=ar.pfs,1,13,0,0               
(p0)  fnorm     f8  = f8   
(p0)  cmp.eq.unc     p9,p8         = r0, r0            
}
{ .mib
(p0)  addl           r33   = @ltoff(double_sind_pi), gp
(p0)  mov            sind_r_sincos = 0x8               
(p0)  br.sptk        SIND_SINCOS ;;
}



////////////////////////////////////////////////////////
// All entry points end up here.
// If from sin, sind_r_sincos is 0 and p8 is true
// If from cos, sind_r_sincos is 8 = 2^(k-1) and p9 is true
// We add sind_r_sincos to N

SIND_SINCOS:

{ .mmi
      ld8 r33 = [r33]
(p0)  addl           r34   = @ltoff(double_sind_pq_k4), gp
(p0)  mov       sind_r_17_ones    = 0x1ffff
}
;;

{ .mfi
      ld8 r34 = [r34]
      nop.f 999
      nop.i 999 ;;
}

// 0x10009 is register_bias + 10.
// So if f8 > 2^10 = Gamma, go to DBX
{ .mii
(p0)  ldfe      sind_Inv_Pi_by_16 = [r33],16          
(p0)  mov       r35 = 0x10009
      nop.i 999 ;;
}

// Start loading P, Q coefficients
{ .mmi
(p0)  ldfpd      sind_P4,sind_Q4 = [r34],16                 
(p0)  addl           sind_AD_beta_table   = @ltoff(double_sin_cos_beta_k4), gp
      nop.i 999 ;;
}

// SIN(0)
{ .mfi
      ld8 sind_AD_beta_table = [sind_AD_beta_table]
(p8)  fclass.m.unc  p6,p0 = f8, 0x07           
      nop.i 999 ;;
}


// COS(0)
{ .mfi
(p0)  getf.exp  sind_r_signexp    = f8                
(p9)  fclass.m.unc  p7,p0 = f8, 0x07           
      nop.i 999
}
{ .mfi
(p0)  ldfe      sind_Pi_by_16_hi  = [r33],16          
      nop.f 999
      nop.i 999 ;;
}

{ .mfb
(p0)  ldfe      sind_Pi_by_16_lo  = [r33],16          
      nop.f 999
(p6)  br.ret.spnt    b0 ;;
}

{ .mfb
(p0)  and       sind_r_exp = sind_r_17_ones, sind_r_signexp
(p7)  fmerge.s      f8 = f1,f1                
(p7)  br.ret.spnt    b0 ;;
}

// p10 is true if we must call DBX SIN
// p10 is true if f8 exp is > 0x10009 (which includes all ones
//    NAN or inf)

{ .mib
(p0)  ldfpd      sind_P3,sind_Q3 = [r34],16                 
(p0)  cmp.ge.unc  p10,p0 = sind_r_exp,r35 
(p10) br.cond.spnt   SIND_DBX ;;
}

{ .mfi
(p0)  ldfpd      sind_P2,sind_Q2 = [r34],16                 
      nop.f 999
      nop.i 999 ;;
}

// sind_W          = x * sind_Inv_Pi_by_16
{ .mfi
(p0)  ldfpd      sind_P1,sind_Q1 = [r34]
(p0)  fma.s1    sind_W   = f8,          sind_Inv_Pi_by_16, f0     
      nop.i 999 ;;
}


// sind_int_Nfloat = Round_Int_Nearest(sind_W)
// sind_r          = -sind_Nfloat * sind_Pi_by_16_hi + x
// sind_r          = sind_r -sind_Nfloat * sind_Pi_by_16_lo 
{ .mfi
      nop.m 999
(p0)  fcvt.fx.s1  sind_int_Nfloat = sind_W                             
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p0)  fcvt.xf     sind_Nfloat = sind_int_Nfloat                        
      nop.i 999 ;;
}

// get N = (int)sind_int_Nfloat 
// Add 2^(k-1) (which is in sind_r_sincos) to N 

{ .mfi
(p0)  getf.sig  r43 = sind_int_Nfloat
      nop.f 999
      nop.i 999 ;;
}

{ .mmi
(p0)  add       r43 = r43, sind_r_sincos ;;
(p0)  and       r44 = 0x1f,r43              
      nop.i 999 ;;
}

// Get M (least k+1 bits of N)
// Add 32*M to address of sin_cos_beta table
{ .mfi
      nop.m 999
(p0)  fnma.s1  sind_r      = sind_Nfloat, sind_Pi_by_16_hi,  f8     
(p0)  shl       r44 = r44,5 ;;
}

{ .mmi
(p0)  add       r45 = r44, sind_AD_beta_table
      nop.m 999
      nop.i 999 ;;
}

{ .mmi
(p0)  ldfe      sind_Sm = [r45],16 ;;
(p0)  ldfe      sind_Cm = [r45]                      
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p0)  fnma.s1  sind_r      = sind_Nfloat, sind_Pi_by_16_lo,  sind_r 
      nop.i 999 ;;
}

// get rsq 
{ .mfi
      nop.m 999
(p0)  fma.s1   sind_rsq  = sind_r, sind_r,   f0  
      nop.i 999 ;;
}

// form P and Q series
{ .mfi
      nop.m 999
(p0)  fma.s1      sind_P_temp1 = sind_rsq, sind_P4, sind_P3       
      nop.i 999
}

{ .mfi
      nop.m 999
(p0)  fma.s1      sind_Q_temp1 = sind_rsq, sind_Q4, sind_Q3       
      nop.i 999 ;;
}

// get rcube and sm*rsq 
{ .mfi
      nop.m 999
(p0)  fmpy.s1     sind_srsq    = sind_Sm,sind_rsq                 
      nop.i 999
}

{ .mfi
      nop.m 999
(p0)  fmpy.s1     sind_rcub    = sind_r, sind_rsq                 
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p0)  fma.s1      sind_Q_temp2 = sind_rsq, sind_Q_temp1, sind_Q2  
      nop.i 999
}

{ .mfi
      nop.m 999
(p0)  fma.s1      sind_P_temp2 = sind_rsq, sind_P_temp1, sind_P2  
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p0)  fma.s1      sind_Q       = sind_rsq, sind_Q_temp2, sind_Q1  
      nop.i 999
}

{ .mfi
      nop.m 999
(p0)  fma.s1      sind_P       = sind_rsq, sind_P_temp2, sind_P1  
      nop.i 999 ;;
}

// Get final P and Q
{ .mfi
      nop.m 999
(p0)  fma.s1   sind_Q = sind_srsq,sind_Q, sind_Sm     
      nop.i 999
}

{ .mfi
      nop.m 999
(p0)  fma.s1   sind_P = sind_rcub,sind_P, sind_r      
      nop.i 999 ;;
}

// Final calculation
{ .mfb
      nop.m 999
(p0)  fma.d    f8     = sind_Cm, sind_P, sind_Q       
(p0)  br.ret.sptk    b0 ;;
}
.endp cos#



.proc __libm_callout_1
__libm_callout_1:
SIND_DBX: 
.prologue
{ .mfi
        nop.m 0
        nop.f 0
.save   ar.pfs,GR_SAVE_PFS
        mov  GR_SAVE_PFS=ar.pfs
}
;;

{ .mfi
        mov GR_SAVE_GP=gp
        nop.f 0
.save   b0, GR_SAVE_B0
        mov GR_SAVE_B0=b0
}

.body
{ .mbb
      nop.m 999
(p9)  br.cond.spnt   COSD_DBX 
(p8)  br.call.spnt.many   b0=__libm_sin_double_dbx# ;;
}
;;


// if we come out of __libm_sin_double_dbx#
// we want to ensure that p9 is false.

{ .mii
         nop.m 999
         nop.i 999
(p0)  cmp.eq.unc p8,p9 = r0,r0                               
;;
}

COSD_DBX: 
{ .mib
      nop.m 999
      nop.i 999
(p9)  br.call.spnt.many   b0=__libm_cos_double_dbx# ;;
}


{ .mfi
(p0)   mov gp        = GR_SAVE_GP
       nop.f  999
(p0)   mov b0        = GR_SAVE_B0
}
;;

{ .mib
      nop.m 999
(p0)  mov ar.pfs    = GR_SAVE_PFS
(p0)  br.ret.sptk     b0 ;;
}
.endp  __libm_callout_1



// ====================================================================
// ====================================================================

// These functions calculate the sin and cos for inputs
// greater than 2^10 
// __libm_sin_double_dbx# and __libm_cos_double_dbx#

//*********************************************************************
//*********************************************************************
//
// Function:   Combined sin(x) and cos(x), where
//
//             sin(x) = sine(x), for double precision x values
//             cos(x) = cosine(x), for double precision x values
//
//*********************************************************************
//
// Accuracy:       Within .7 ulps for 80-bit floating point values
//                 Very accurate for double precision values
//
//*********************************************************************
//
// Resources Used:
//
//    Floating-Point Registers: f8 (Input and Return Value) 
//                              f32-f99
//
//    General Purpose Registers:
//      r32-r43 
//      r44-r45 (Used to pass arguments to pi_by_2 reduce routine)
//
//    Predicate Registers:      p6-p13
//
//*********************************************************************
//
//  IEEE Special Conditions:
//
//    Denormal  fault raised on denormal inputs
//    Overflow exceptions do not occur
//    Underflow exceptions raised when appropriate for sin 
//    (No specialized error handling for this routine)
//    Inexact raised when appropriate by algorithm
//
//    sin(SNaN) = QNaN
//    sin(QNaN) = QNaN
//    sin(inf) = QNaN 
//    sin(+/-0) = +/-0
//    cos(inf) = QNaN 
//    cos(SNaN) = QNaN
//    cos(QNaN) = QNaN
//    cos(0) = 1
// 
//*********************************************************************
//
//  Mathematical Description
//  ========================
//
//  The computation of FSIN and FCOS is best handled in one piece of 
//  code. The main reason is that given any argument Arg, computation 
//  of trigonometric functions first calculate N and an approximation 
//  to alpha where
//
//  Arg = N pi/2 + alpha, |alpha| <= pi/4.
//
//  Since
//
//  cos( Arg ) = sin( (N+1) pi/2 + alpha ),
//
//  therefore, the code for computing sine will produce cosine as long 
//  as 1 is added to N immediately after the argument reduction 
//  process.
//
//  Let M = N if sine
//      N+1 if cosine.  
//
//  Now, given
//
//  Arg = M pi/2  + alpha, |alpha| <= pi/4,
//
//  let I = M mod 4, or I be the two lsb of M when M is represented 
//  as 2's complement. I = [i_0 i_1]. Then
//
//  sin( Arg ) = (-1)^i_0  sin( alpha )	if i_1 = 0,
//             = (-1)^i_0  cos( alpha )     if i_1 = 1.
//
//  For example:
//       if M = -1, I = 11   
//         sin ((-pi/2 + alpha) = (-1) cos (alpha)
//       if M = 0, I = 00   
//         sin (alpha) = sin (alpha)
//       if M = 1, I = 01   
//         sin (pi/2 + alpha) = cos (alpha)
//       if M = 2, I = 10   
//         sin (pi + alpha) = (-1) sin (alpha)
//       if M = 3, I = 11   
//         sin ((3/2)pi + alpha) = (-1) cos (alpha)
//
//  The value of alpha is obtained by argument reduction and 
//  represented by two working precision numbers r and c where
//
//  alpha =  r  +  c     accurately.
//
//  The reduction method is described in a previous write up.
//  The argument reduction scheme identifies 4 cases. For Cases 2 
//  and 4, because |alpha| is small, sin(r+c) and cos(r+c) can be 
//  computed very easily by 2 or 3 terms of the Taylor series 
//  expansion as follows:
//
//  Case 2:
//  -------
//
//  sin(r + c) = r + c - r^3/6	accurately
//  cos(r + c) = 1 - 2^(-67)	accurately
//
//  Case 4:
//  -------
//
//  sin(r + c) = r + c - r^3/6 + r^5/120	accurately
//  cos(r + c) = 1 - r^2/2 + r^4/24		accurately
//
//  The only cases left are Cases 1 and 3 of the argument reduction 
//  procedure. These two cases will be merged since after the 
//  argument is reduced in either cases, we have the reduced argument 
//  represented as r + c and that the magnitude |r + c| is not small 
//  enough to allow the usage of a very short approximation.
//
//  The required calculation is either
//
//  sin(r + c)  =  sin(r)  +  correction,  or
//  cos(r + c)  =  cos(r)  +  correction.
//
//  Specifically,
//
//	sin(r + c) = sin(r) + c sin'(r) + O(c^2)
//		   = sin(r) + c cos (r) + O(c^2)
//		   = sin(r) + c(1 - r^2/2)  accurately.
//  Similarly,
//
//	cos(r + c) = cos(r) - c sin(r) + O(c^2)
//		   = cos(r) - c(r - r^3/6)  accurately.
//
//  We therefore concentrate on accurately calculating sin(r) and 
//  cos(r) for a working-precision number r, |r| <= pi/4 to within
//  0.1% or so.
//
//  The greatest challenge of this task is that the second terms of 
//  the Taylor series
//	
//	r - r^3/3! + r^r/5! - ...
//
//  and
//
//	1 - r^2/2! + r^4/4! - ...
//
//  are not very small when |r| is close to pi/4 and the rounding 
//  errors will be a concern if simple polynomial accumulation is 
//  used. When |r| < 2^-3, however, the second terms will be small 
//  enough (6 bits or so of right shift) that a normal Horner 
//  recurrence suffices. Hence there are two cases that we consider 
//  in the accurate computation of sin(r) and cos(r), |r| <= pi/4.
//
//  Case small_r: |r| < 2^(-3)
//  --------------------------
//
//  Since Arg = M pi/4 + r + c accurately, and M mod 4 is [i_0 i_1],
//  we have
//
//	sin(Arg) = (-1)^i_0 * sin(r + c)	if i_1 = 0
//		 = (-1)^i_0 * cos(r + c) 	if i_1 = 1
//
//  can be accurately approximated by
//
//  sin(Arg) = (-1)^i_0 * [sin(r) + c]	if i_1 = 0
//           = (-1)^i_0 * [cos(r) - c*r] if i_1 = 1
//
//  because |r| is small and thus the second terms in the correction 
//  are unneccessary.
//
//  Finally, sin(r) and cos(r) are approximated by polynomials of 
//  moderate lengths.
//
//  sin(r) =  r + S_1 r^3 + S_2 r^5 + ... + S_5 r^11
//  cos(r) =  1 + C_1 r^2 + C_2 r^4 + ... + C_5 r^10
//
//  We can make use of predicates to selectively calculate 
//  sin(r) or cos(r) based on i_1. 
//
//  Case normal_r: 2^(-3) <= |r| <= pi/4
//  ------------------------------------
//
//  This case is more likely than the previous one if one considers
//  r to be uniformly distributed in [-pi/4 pi/4]. Again,
// 
//  sin(Arg) = (-1)^i_0 * sin(r + c)	if i_1 = 0
//           = (-1)^i_0 * cos(r + c) 	if i_1 = 1.
//
//  Because |r| is now larger, we need one extra term in the 
//  correction. sin(Arg) can be accurately approximated by
//
//  sin(Arg) = (-1)^i_0 * [sin(r) + c(1-r^2/2)]      if i_1 = 0
//           = (-1)^i_0 * [cos(r) - c*r*(1 - r^2/6)]    i_1 = 1.
//
//  Finally, sin(r) and cos(r) are approximated by polynomials of 
//  moderate lengths.
//
//	sin(r) =  r + PP_1_hi r^3 + PP_1_lo r^3 + 
//	              PP_2 r^5 + ... + PP_8 r^17
//
//	cos(r) =  1 + QQ_1 r^2 + QQ_2 r^4 + ... + QQ_8 r^16
//
//  where PP_1_hi is only about 16 bits long and QQ_1 is -1/2. 
//  The crux in accurate computation is to calculate 
//
//  r + PP_1_hi r^3   or  1 + QQ_1 r^2
//
//  accurately as two pieces: U_hi and U_lo. The way to achieve this 
//  is to obtain r_hi as a 10 sig. bit number that approximates r to 
//  roughly 8 bits or so of accuracy. (One convenient way is
//
//  r_hi := frcpa( frcpa( r ) ).)
//
//  This way,
//
//	r + PP_1_hi r^3 =  r + PP_1_hi r_hi^3 +
//	                        PP_1_hi (r^3 - r_hi^3)
//		        =  [r + PP_1_hi r_hi^3]  +  
//			   [PP_1_hi (r - r_hi) 
//			      (r^2 + r_hi r + r_hi^2) ]
//		        =  U_hi  +  U_lo
//
//  Since r_hi is only 10 bit long and PP_1_hi is only 16 bit long,
//  PP_1_hi * r_hi^3 is only at most 46 bit long and thus computed 
//  exactly. Furthermore, r and PP_1_hi r_hi^3 are of opposite sign 
//  and that there is no more than 8 bit shift off between r and 
//  PP_1_hi * r_hi^3. Hence the sum, U_hi, is representable and thus 
//  calculated without any error. Finally, the fact that 
//
//	|U_lo| <= 2^(-8) |U_hi|
//
//  says that U_hi + U_lo is approximating r + PP_1_hi r^3 to roughly 
//  8 extra bits of accuracy.
//
//  Similarly,
//
//	1 + QQ_1 r^2  =  [1 + QQ_1 r_hi^2]  +
//	                    [QQ_1 (r - r_hi)(r + r_hi)]
//		      =  U_hi  +  U_lo.
//		      
//  Summarizing, we calculate r_hi = frcpa( frcpa( r ) ). 
//
//  If i_1 = 0, then
//
//    U_hi := r + PP_1_hi * r_hi^3
//    U_lo := PP_1_hi * (r - r_hi) * (r^2 + r*r_hi + r_hi^2)
//    poly := PP_1_lo r^3 + PP_2 r^5 + ... + PP_8 r^17
//    correction := c * ( 1 + C_1 r^2 )
//
//  Else ...i_1 = 1
//
//    U_hi := 1 + QQ_1 * r_hi * r_hi
//    U_lo := QQ_1 * (r - r_hi) * (r + r_hi)
//    poly := QQ_2 * r^4 + QQ_3 * r^6 + ... + QQ_8 r^16
//    correction := -c * r * (1 + S_1 * r^2)
//
//  End
//
//  Finally,
// 
//	V := poly + ( U_lo + correction )
//
//                 /    U_hi  +  V         if i_0 = 0
//	result := |
//                 \  (-U_hi) -  V         if i_0 = 1
//
//  It is important that in the last step, negation of U_hi is 
//  performed prior to the subtraction which is to be performed in 
//  the user-set rounding mode. 
//
//
//  Algorithmic Description
//  =======================
//
//  The argument reduction algorithm is tightly integrated into FSIN 
//  and FCOS which share the same code. The following is complete and 
//  self-contained. The argument reduction description given 
//  previously is repeated below.
//
//
//  Step 0. Initialization. 
//
//   If FSIN is invoked, set N_inc := 0; else if FCOS is invoked,
//   set N_inc := 1.
//
//  Step 1. Check for exceptional and special cases.
//
//   * If Arg is +-0, +-inf, NaN, NaT, go to Step 10 for special 
//     handling.
//   * If |Arg| < 2^24, go to Step 2 for reduction of moderate
//     arguments. This is the most likely case.
//   * If |Arg| < 2^63, go to Step 8 for pre-reduction of large
//     arguments.
//   * If |Arg| >= 2^63, go to Step 10 for special handling.
//
//  Step 2. Reduction of moderate arguments.
//
//  If |Arg| < pi/4 	...quick branch
//     N_fix := N_inc	(integer)
//     r     := Arg
//     c     := 0.0
//     Branch to Step 4, Case_1_complete
//  Else 		...cf. argument reduction
//     N     := Arg * two_by_PI	(fp)
//     N_fix := fcvt.fx( N )	(int)
//     N     := fcvt.xf( N_fix )
//     N_fix := N_fix + N_inc
//     s     := Arg - N * P_1	(first piece of pi/2)
//     w     := -N * P_2	(second piece of pi/2)
//
//     If |s| >= 2^(-33)
//        go to Step 3, Case_1_reduce
//     Else
//        go to Step 7, Case_2_reduce
//     Endif
//  Endif
//
//  Step 3. Case_1_reduce.
//
//  r := s + w
//  c := (s - r) + w	...observe order
//   
//  Step 4. Case_1_complete
//
//  ...At this point, the reduced argument alpha is
//  ...accurately represented as r + c.
//  If |r| < 2^(-3), go to Step 6, small_r.
//
//  Step 5. Normal_r.
//
//  Let [i_0 i_1] by the 2 lsb of N_fix.
//  FR_rsq  := r * r
//  r_hi := frcpa( frcpa( r ) )
//  r_lo := r - r_hi
//
//  If i_1 = 0, then
//    poly := r*FR_rsq*(PP_1_lo + FR_rsq*(PP_2 + ... FR_rsq*PP_8))
//    U_hi := r + PP_1_hi*r_hi*r_hi*r_hi	...any order
//    U_lo := PP_1_hi*r_lo*(r*r + r*r_hi + r_hi*r_hi)
//    correction := c + c*C_1*FR_rsq		...any order
//  Else
//    poly := FR_rsq*FR_rsq*(QQ_2 + FR_rsq*(QQ_3 + ... + FR_rsq*QQ_8))
//    U_hi := 1 + QQ_1 * r_hi * r_hi		...any order
//    U_lo := QQ_1 * r_lo * (r + r_hi)
//    correction := -c*(r + S_1*FR_rsq*r)	...any order
//  Endif
//
//  V := poly + (U_lo + correction)	...observe order
//
//  result := (i_0 == 0?   1.0 : -1.0)
//
//  Last instruction in user-set rounding mode
//
//  result := (i_0 == 0?   result*U_hi + V :
//                        result*U_hi - V)
//
//  Return
//
//  Step 6. Small_r.
// 
//  ...Use flush to zero mode without causing exception
//    Let [i_0 i_1] be the two lsb of N_fix.
//
//  FR_rsq := r * r
//
//  If i_1 = 0 then
//     z := FR_rsq*FR_rsq; z := FR_rsq*z *r
//     poly_lo := S_3 + FR_rsq*(S_4 + FR_rsq*S_5)
//     poly_hi := r*FR_rsq*(S_1 + FR_rsq*S_2)
//     correction := c
//     result := r
//  Else
//     z := FR_rsq*FR_rsq; z := FR_rsq*z
//     poly_lo := C_3 + FR_rsq*(C_4 + FR_rsq*C_5)
//     poly_hi := FR_rsq*(C_1 + FR_rsq*C_2) 
//     correction := -c*r
//     result := 1
//  Endif
//
//  poly := poly_hi + (z * poly_lo + correction)
//
//  If i_0 = 1, result := -result
//
//  Last operation. Perform in user-set rounding mode
//
//  result := (i_0 == 0?     result + poly :
//                          result - poly )
//  Return
//
//  Step 7. Case_2_reduce.
//
//  ...Refer to the write up for argument reduction for 
//  ...rationale. The reduction algorithm below is taken from
//  ...argument reduction description and integrated this.
//
//  w := N*P_3
//  U_1 := N*P_2 + w		...FMA
//  U_2 := (N*P_2 - U_1) + w	...2 FMA
//  ...U_1 + U_2 is  N*(P_2+P_3) accurately
//   
//  r := s - U_1
//  c := ( (s - r) - U_1 ) - U_2
//
//  ...The mathematical sum r + c approximates the reduced
//  ...argument accurately. Note that although compared to
//  ...Case 1, this case requires much more work to reduce
//  ...the argument, the subsequent calculation needed for
//  ...any of the trigonometric function is very little because
//  ...|alpha| < 1.01*2^(-33) and thus two terms of the 
//  ...Taylor series expansion suffices.
//
//  If i_1 = 0 then
//     poly := c + S_1 * r * r * r	...any order
//     result := r
//  Else
//     poly := -2^(-67)
//     result := 1.0
//  Endif
//   
//  If i_0 = 1, result := -result
//
//  Last operation. Perform in user-set rounding mode
//
//  result := (i_0 == 0?     result + poly :
//                           result - poly )
//   
//  Return
//
//  
//  Step 8. Pre-reduction of large arguments.
// 
//  ...Again, the following reduction procedure was described
//  ...in the separate write up for argument reduction, which
//  ...is tightly integrated here.

//  N_0 := Arg * Inv_P_0
//  N_0_fix := fcvt.fx( N_0 )
//  N_0 := fcvt.xf( N_0_fix)
   
//  Arg' := Arg - N_0 * P_0
//  w := N_0 * d_1
//  N := Arg' * two_by_PI
//  N_fix := fcvt.fx( N )
//  N := fcvt.xf( N_fix )
//  N_fix := N_fix + N_inc 
//
//  s := Arg' - N * P_1
//  w := w - N * P_2
//
//  If |s| >= 2^(-14)
//     go to Step 3
//  Else
//     go to Step 9
//  Endif
//
//  Step 9. Case_4_reduce.
// 
//    ...first obtain N_0*d_1 and -N*P_2 accurately
//   U_hi := N_0 * d_1		V_hi := -N*P_2
//   U_lo := N_0 * d_1 - U_hi	V_lo := -N*P_2 - U_hi	...FMAs
//
//   ...compute the contribution from N_0*d_1 and -N*P_3
//   w := -N*P_3
//   w := w + N_0*d_2
//   t := U_lo + V_lo + w		...any order
//
//   ...at this point, the mathematical value
//   ...s + U_hi + V_hi  + t approximates the true reduced argument
//   ...accurately. Just need to compute this accurately.
//
//   ...Calculate U_hi + V_hi accurately:
//   A := U_hi + V_hi
//   if |U_hi| >= |V_hi| then
//      a := (U_hi - A) + V_hi
//   else
//      a := (V_hi - A) + U_hi
//   endif
//   ...order in computing "a" must be observed. This branch is
//   ...best implemented by predicates.
//   ...A + a  is U_hi + V_hi accurately. Moreover, "a" is 
//   ...much smaller than A: |a| <= (1/2)ulp(A).
//
//   ...Just need to calculate   s + A + a + t
//   C_hi := s + A		t := t + a
//   C_lo := (s - C_hi) + A	
//   C_lo := C_lo + t
//
//   ...Final steps for reduction
//   r := C_hi + C_lo
//   c := (C_hi - r) + C_lo
//
//   ...At this point, we have r and c
//   ...And all we need is a couple of terms of the corresponding
//   ...Taylor series.
//
//   If i_1 = 0
//      poly := c + r*FR_rsq*(S_1 + FR_rsq*S_2)
//      result := r
//   Else
//      poly := FR_rsq*(C_1 + FR_rsq*C_2)
//      result := 1
//   Endif
//
//   If i_0 = 1, result := -result
//
//   Last operation. Perform in user-set rounding mode
//
//   result := (i_0 == 0?     result + poly :
//                            result - poly )
//   Return
//  
//   Large Arguments: For arguments above 2**63, a Payne-Hanek
//   style argument reduction is used and pi_by_2 reduce is called.
//
 

.data
.align 64 

FSINCOS_CONSTANTS:

data4 0x4B800000, 0xCB800000, 0x00000000,0x00000000 // two**24, -two**24
data4 0x4E44152A, 0xA2F9836E, 0x00003FFE,0x00000000 // Inv_pi_by_2
data4 0xCE81B9F1, 0xC84D32B0, 0x00004016,0x00000000 // P_0 
data4 0x2168C235, 0xC90FDAA2, 0x00003FFF,0x00000000 // P_1 
data4 0xFC8F8CBB, 0xECE675D1, 0x0000BFBD,0x00000000 // P_2 
data4 0xACC19C60, 0xB7ED8FBB, 0x0000BF7C,0x00000000 // P_3 
data4 0x5F000000, 0xDF000000, 0x00000000,0x00000000 // two_to_63, -two_to_63
data4 0x6EC6B45A, 0xA397E504, 0x00003FE7,0x00000000 // Inv_P_0 
data4 0xDBD171A1, 0x8D848E89, 0x0000BFBF,0x00000000 // d_1 
data4 0x18A66F8E, 0xD5394C36, 0x0000BF7C,0x00000000 // d_2 
data4 0x2168C234, 0xC90FDAA2, 0x00003FFE,0x00000000 // pi_by_4 
data4 0x2168C234, 0xC90FDAA2, 0x0000BFFE,0x00000000 // neg_pi_by_4 
data4 0x3E000000, 0xBE000000, 0x00000000,0x00000000 // two**-3, -two**-3
data4 0x2F000000, 0xAF000000, 0x9E000000,0x00000000 // two**-33, -two**-33, -two**-67
data4 0xA21C0BC9, 0xCC8ABEBC, 0x00003FCE,0x00000000 // PP_8 
data4 0x720221DA, 0xD7468A05, 0x0000BFD6,0x00000000 // PP_7 
data4 0x640AD517, 0xB092382F, 0x00003FDE,0x00000000 // PP_6 
data4 0xD1EB75A4, 0xD7322B47, 0x0000BFE5,0x00000000 // PP_5 
data4 0xFFFFFFFE, 0xFFFFFFFF, 0x0000BFFD,0x00000000 // C_1 
data4 0x00000000, 0xAAAA0000, 0x0000BFFC,0x00000000 // PP_1_hi 
data4 0xBAF69EEA, 0xB8EF1D2A, 0x00003FEC,0x00000000 // PP_4 
data4 0x0D03BB69, 0xD00D00D0, 0x0000BFF2,0x00000000 // PP_3 
data4 0x88888962, 0x88888888, 0x00003FF8,0x00000000 // PP_2
data4 0xAAAB0000, 0xAAAAAAAA, 0x0000BFEC,0x00000000 // PP_1_lo 
data4 0xC2B0FE52, 0xD56232EF, 0x00003FD2,0x00000000 // QQ_8
data4 0x2B48DCA6, 0xC9C99ABA, 0x0000BFDA,0x00000000 // QQ_7
data4 0x9C716658, 0x8F76C650, 0x00003FE2,0x00000000 // QQ_6
data4 0xFDA8D0FC, 0x93F27DBA, 0x0000BFE9,0x00000000 // QQ_5
data4 0xAAAAAAAA, 0xAAAAAAAA, 0x0000BFFC,0x00000000 // S_1 
data4 0x00000000, 0x80000000, 0x0000BFFE,0x00000000 // QQ_1 
data4 0x0C6E5041, 0xD00D00D0, 0x00003FEF,0x00000000 // QQ_4 
data4 0x0B607F60, 0xB60B60B6, 0x0000BFF5,0x00000000 // QQ_3 
data4 0xAAAAAA9B, 0xAAAAAAAA, 0x00003FFA,0x00000000 // QQ_2 
data4 0xFFFFFFFE, 0xFFFFFFFF, 0x0000BFFD,0x00000000 // C_1 
data4 0xAAAA719F, 0xAAAAAAAA, 0x00003FFA,0x00000000 // C_2 
data4 0x0356F994, 0xB60B60B6, 0x0000BFF5,0x00000000 // C_3
data4 0xB2385EA9, 0xD00CFFD5, 0x00003FEF,0x00000000 // C_4 
data4 0x292A14CD, 0x93E4BD18, 0x0000BFE9,0x00000000 // C_5
data4 0xAAAAAAAA, 0xAAAAAAAA, 0x0000BFFC,0x00000000 // S_1 
data4 0x888868DB, 0x88888888, 0x00003FF8,0x00000000 // S_2 
data4 0x055EFD4B, 0xD00D00D0, 0x0000BFF2,0x00000000 // S_3 
data4 0x839730B9, 0xB8EF1C5D, 0x00003FEC,0x00000000 // S_4
data4 0xE5B3F492, 0xD71EA3A4, 0x0000BFE5,0x00000000 // S_5
data4 0x38800000, 0xB8800000, 0x00000000            // two**-14, -two**-14

FR_Input_X        = f8 
FR_Neg_Two_to_M3  = f32 
FR_Two_to_63      = f32 
FR_Two_to_24      = f33 
FR_Pi_by_4        = f33 
FR_Two_to_M14     = f34 
FR_Two_to_M33     = f35 
FR_Neg_Two_to_24  = f36 
FR_Neg_Pi_by_4    = f36 
FR_Neg_Two_to_M14 = f37 
FR_Neg_Two_to_M33 = f38 
FR_Neg_Two_to_M67 = f39 
FR_Inv_pi_by_2    = f40 
FR_N_float        = f41 
FR_N_fix          = f42 
FR_P_1            = f43 
FR_P_2            = f44 
FR_P_3            = f45 
FR_s              = f46 
FR_w              = f47 
FR_c              = f48 
FR_r              = f49 
FR_Z              = f50 
FR_A              = f51 
FR_a              = f52 
FR_t              = f53 
FR_U_1            = f54 
FR_U_2            = f55 
FR_C_1            = f56 
FR_C_2            = f57 
FR_C_3            = f58 
FR_C_4            = f59 
FR_C_5            = f60 
FR_S_1            = f61 
FR_S_2            = f62 
FR_S_3            = f63 
FR_S_4            = f64 
FR_S_5            = f65 
FR_poly_hi        = f66 
FR_poly_lo        = f67 
FR_r_hi           = f68 
FR_r_lo           = f69 
FR_rsq            = f70 
FR_r_cubed        = f71 
FR_C_hi           = f72 
FR_N_0            = f73 
FR_d_1            = f74 
FR_V              = f75 
FR_V_hi           = f75 
FR_V_lo           = f76 
FR_U_hi           = f77 
FR_U_lo           = f78 
FR_U_hiabs        = f79 
FR_V_hiabs        = f80 
FR_PP_8           = f81 
FR_QQ_8           = f81 
FR_PP_7           = f82 
FR_QQ_7           = f82 
FR_PP_6           = f83 
FR_QQ_6           = f83 
FR_PP_5           = f84 
FR_QQ_5           = f84 
FR_PP_4           = f85 
FR_QQ_4           = f85 
FR_PP_3           = f86 
FR_QQ_3           = f86 
FR_PP_2           = f87 
FR_QQ_2           = f87 
FR_QQ_1           = f88 
FR_N_0_fix        = f89 
FR_Inv_P_0        = f90 
FR_corr           = f91 
FR_poly           = f92 
FR_d_2            = f93 
FR_Two_to_M3      = f94 
FR_Neg_Two_to_63  = f94 
FR_P_0            = f95 
FR_C_lo           = f96 
FR_PP_1           = f97 
FR_PP_1_lo        = f98 
FR_ArgPrime       = f99 

GR_Table_Base  = r32 
GR_Table_Base1 = r33 
GR_i_0         = r34
GR_i_1         = r35
GR_N_Inc       = r36 
GR_Sin_or_Cos  = r37 

GR_SAVE_B0     = r39
GR_SAVE_GP     = r40
GR_SAVE_PFS    = r41

.section .text
.proc __libm_sin_double_dbx#
.align 64 
__libm_sin_double_dbx: 

{ .mlx
alloc GR_Table_Base = ar.pfs,0,12,2,0
(p0)   movl GR_Sin_or_Cos = 0x0 ;;
}

{ .mmi
      nop.m 999
(p0)  addl           GR_Table_Base   = @ltoff(FSINCOS_CONSTANTS#), gp
      nop.i 999
}
;;

{ .mmi
      ld8 GR_Table_Base = [GR_Table_Base]
      nop.m 999
      nop.i 999
}
;;


{ .mib
      nop.m 999
      nop.i 999
(p0)   br.cond.sptk SINCOS_CONTINUE ;;
}

.endp __libm_sin_double_dbx#

.section .text
.proc __libm_cos_double_dbx#
__libm_cos_double_dbx: 

{ .mlx
alloc GR_Table_Base= ar.pfs,0,12,2,0
(p0)   movl GR_Sin_or_Cos = 0x1 ;;
}

{ .mmi
      nop.m 999
(p0)  addl           GR_Table_Base   = @ltoff(FSINCOS_CONSTANTS#), gp
      nop.i 999
}
;;

{ .mmi
      ld8 GR_Table_Base = [GR_Table_Base]
      nop.m 999
      nop.i 999
}
;;

//
//     Load Table Address
//
SINCOS_CONTINUE: 

{ .mmi
(p0)   add GR_Table_Base1 = 96, GR_Table_Base
(p0)   ldfs	FR_Two_to_24 = [GR_Table_Base], 4
       nop.i 999
}
;;

{ .mmi
      nop.m 999
//
//     Load 2**24, load 2**63.
//
(p0)   ldfs	FR_Neg_Two_to_24 = [GR_Table_Base], 12
(p0)   mov   r41 = ar.pfs ;;
}

{ .mfi
(p0)   ldfs	FR_Two_to_63 = [GR_Table_Base1], 4
//
//     Check for unnormals - unsupported operands. We do not want
//     to generate denormal exception
//     Check for NatVals, QNaNs, SNaNs, +/-Infs
//     Check for EM unsupporteds
//     Check for Zero 
//
(p0)   fclass.m.unc  p6, p8 =  FR_Input_X, 0x1E3
(p0)   mov   r40 = gp ;;
}

{ .mfi
      nop.m 999
(p0)   fclass.nm.unc p8, p0 =  FR_Input_X, 0x1FF
// GR_Sin_or_Cos denotes 
(p0)   mov   r39 = b0
}

{ .mfb
(p0)   ldfs	FR_Neg_Two_to_63 = [GR_Table_Base1], 12
(p0)   fclass.m.unc p10, p0 = FR_Input_X, 0x007
(p6)   br.cond.spnt SINCOS_SPECIAL ;;
}

{ .mib
      nop.m 999
      nop.i 999
(p8)   br.cond.spnt SINCOS_SPECIAL ;;
}

{ .mib
      nop.m 999
      nop.i 999
//
//     Branch if +/- NaN, Inf.
//     Load -2**24, load -2**63.
//
(p10)  br.cond.spnt SINCOS_ZERO ;;
}

{ .mmb
(p0)   ldfe	FR_Inv_pi_by_2 = [GR_Table_Base], 16
(p0)   ldfe	FR_Inv_P_0 = [GR_Table_Base1], 16
      nop.b 999 ;;
}

{ .mmb
      nop.m 999
(p0)   ldfe		FR_d_1 = [GR_Table_Base1], 16
      nop.b 999 ;;
}
//
//     Raise possible denormal operand flag with useful fcmp
//     Is x <= -2**63
//     Load Inv_P_0 for pre-reduction
//     Load Inv_pi_by_2
//

{ .mmb
(p0)   ldfe		FR_P_0 = [GR_Table_Base], 16
(p0)   ldfe	FR_d_2 = [GR_Table_Base1], 16
      nop.b 999 ;;
}
//
//     Load P_0
//     Load d_1
//     Is x >= 2**63
//     Is x <= -2**24?
//

{ .mmi
(p0)   ldfe	FR_P_1 = [GR_Table_Base], 16 ;;
//
//     Load P_1
//     Load d_2
//     Is x >= 2**24?
//
(p0)   ldfe	FR_P_2 = [GR_Table_Base], 16
      nop.i 999 ;;
}

{ .mmf
      nop.m 999
(p0)   ldfe	FR_P_3 = [GR_Table_Base], 16
(p0)   fcmp.le.unc.s1	p7, p8 = FR_Input_X, FR_Neg_Two_to_24
}

{ .mfi
      nop.m 999
//
//     Branch if +/- zero.
//     Decide about the paths to take:
//     If -2**24 < FR_Input_X < 2**24 - CASE 1 OR 2 
//     OTHERWISE - CASE 3 OR 4 
//
(p0)   fcmp.le.unc.s0	p10, p11 = FR_Input_X, FR_Neg_Two_to_63
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p8)   fcmp.ge.s1 p7, p0 = FR_Input_X, FR_Two_to_24
      nop.i 999
}

{ .mfi
(p0)   ldfe	FR_Pi_by_4 = [GR_Table_Base1], 16
(p11)  fcmp.ge.s1	p10, p0 = FR_Input_X, FR_Two_to_63
      nop.i 999 ;;
}

{ .mmi
(p0)   ldfe	FR_Neg_Pi_by_4 = [GR_Table_Base1], 16 ;;
(p0)   ldfs	FR_Two_to_M3 = [GR_Table_Base1], 4
      nop.i 999 ;;
}

{ .mib
(p0)   ldfs	FR_Neg_Two_to_M3 = [GR_Table_Base1], 12
      nop.i 999
//
//     Load P_2
//     Load P_3
//     Load pi_by_4
//     Load neg_pi_by_4
//     Load 2**(-3)
//     Load -2**(-3).
//
(p10)  br.cond.spnt SINCOS_ARG_TOO_LARGE ;;
}

{ .mib
      nop.m 999
      nop.i 999
//
//     Branch out if x >= 2**63. Use Payne-Hanek Reduction
//
(p7)   br.cond.spnt SINCOS_LARGER_ARG ;;
}

{ .mfi
      nop.m 999
// 
//     Branch if Arg <= -2**24 or Arg >= 2**24 and use pre-reduction.
//
(p0)   fma.s1	FR_N_float = FR_Input_X, FR_Inv_pi_by_2, f0
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p0)   fcmp.lt.unc.s1	p6, p7 = FR_Input_X, FR_Pi_by_4
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
// 
//     Select the case when |Arg| < pi/4 
//     Else Select the case when |Arg| >= pi/4 
//
(p0)   fcvt.fx.s1 FR_N_fix = FR_N_float
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
//
//     N  = Arg * 2/pi
//     Check if Arg < pi/4
//
(p6)   fcmp.gt.s1 p6, p7 = FR_Input_X, FR_Neg_Pi_by_4
      nop.i 999 ;;
}
//
//     Case 2: Convert integer N_fix back to normalized floating-point value.
//     Case 1: p8 is only affected  when p6 is set
//

{ .mfi
(p7)   ldfs FR_Two_to_M33 = [GR_Table_Base1], 4
//
//     Grab the integer part of N and call it N_fix
//
(p6)   fmerge.se FR_r = FR_Input_X, FR_Input_X
//     If |x| < pi/4, r = x and c = 0 
//     lf |x| < pi/4, is x < 2**(-3).
//     r = Arg 
//     c = 0
(p6)   mov GR_N_Inc = GR_Sin_or_Cos ;;
}

{ .mmf
      nop.m 999
(p7)   ldfs FR_Neg_Two_to_M33 = [GR_Table_Base1], 4
(p6)   fmerge.se FR_c = f0, f0
}

{ .mfi
      nop.m 999
(p6)   fcmp.lt.unc.s1	p8, p9 = FR_Input_X, FR_Two_to_M3
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
//
//     lf |x| < pi/4, is -2**(-3)< x < 2**(-3) - set p8.
//     If |x| >= pi/4, 
//     Create the right N for |x| < pi/4 and otherwise 
//     Case 2: Place integer part of N in GP register
//
(p7)   fcvt.xf FR_N_float = FR_N_fix
      nop.i 999 ;;
}

{ .mmf
      nop.m 999
(p7)   getf.sig	GR_N_Inc = FR_N_fix
(p8)   fcmp.gt.s1 p8, p0 = FR_Input_X, FR_Neg_Two_to_M3 ;;
}

{ .mib
      nop.m 999
      nop.i 999
//
//     Load 2**(-33), -2**(-33)
//
(p8)   br.cond.spnt SINCOS_SMALL_R ;;
}

{ .mib
      nop.m 999
      nop.i 999
(p6)   br.cond.sptk SINCOS_NORMAL_R ;;
}
//
//     if |x| < pi/4, branch based on |x| < 2**(-3) or otherwise.
//
//
//     In this branch, |x| >= pi/4.
// 

{ .mfi
(p0)   ldfs FR_Neg_Two_to_M67 = [GR_Table_Base1], 8
//
//     Load -2**(-67)
// 
(p0)   fnma.s1	FR_s = FR_N_float, FR_P_1, FR_Input_X
//
//     w = N * P_2
//     s = -N * P_1  + Arg
//
(p0)   add GR_N_Inc = GR_N_Inc, GR_Sin_or_Cos
}

{ .mfi
      nop.m 999
(p0)   fma.s1	FR_w = FR_N_float, FR_P_2, f0
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
// 
//     Adjust N_fix by N_inc to determine whether sine or
//     cosine is being calculated
//
(p0)   fcmp.lt.unc.s1 p7, p6 = FR_s, FR_Two_to_M33
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p7)   fcmp.gt.s1 p7, p6 = FR_s, FR_Neg_Two_to_M33
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
//     Remember x >= pi/4.
//     Is s <= -2**(-33) or s >= 2**(-33) (p6)
//     or -2**(-33) < s < 2**(-33) (p7)
(p6)   fms.s1 FR_r = FR_s, f1, FR_w
      nop.i 999
}

{ .mfi
      nop.m 999
(p7)   fma.s1 FR_w = FR_N_float, FR_P_3, f0
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p7)   fma.s1 FR_U_1 = FR_N_float, FR_P_2, FR_w
      nop.i 999
}

{ .mfi
      nop.m 999
(p6)   fms.s1 FR_c = FR_s, f1, FR_r
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
// 
//     For big s: r = s - w: No futher reduction is necessary 
//     For small s: w = N * P_3 (change sign) More reduction
//
(p6)   fcmp.lt.unc.s1 p8, p9 = FR_r, FR_Two_to_M3
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p8)   fcmp.gt.s1 p8, p9 = FR_r, FR_Neg_Two_to_M3
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p7)   fms.s1 FR_r = FR_s, f1, FR_U_1
      nop.i 999
}

{ .mfb
      nop.m 999
//
//     For big s: Is |r| < 2**(-3)?
//     For big s: c = S - r
//     For small s: U_1 = N * P_2 + w
//
//     If p8 is set, prepare to branch to Small_R.
//     If p9 is set, prepare to branch to Normal_R.
//     For big s,  r is complete here.
//
(p6)   fms.s1 FR_c = FR_c, f1, FR_w
// 
//     For big s: c = c + w (w has not been negated.)
//     For small s: r = S - U_1
//
(p8)   br.cond.spnt	SINCOS_SMALL_R ;;
}

{ .mib
      nop.m 999
      nop.i 999
(p9)   br.cond.sptk	SINCOS_NORMAL_R ;;
}

{ .mfi
(p7)   add GR_Table_Base1 = 224, GR_Table_Base1
//
//     Branch to SINCOS_SMALL_R or SINCOS_NORMAL_R
//
(p7)   fms.s1 FR_U_2 = FR_N_float, FR_P_2, FR_U_1
// 
//     c = S - U_1
//     r = S_1 * r
//
//
(p7)   extr.u	GR_i_1 = GR_N_Inc, 0, 1
}

{ .mmi
      nop.m 999 ;;
//
//     Get [i_0,i_1] - two lsb of N_fix_gr.
//     Do dummy fmpy so inexact is always set.
//
(p7)   cmp.eq.unc p9, p10 = 0x0, GR_i_1
(p7)   extr.u	GR_i_0 = GR_N_Inc, 1, 1 ;;
}
// 
//     For small s: U_2 = N * P_2 - U_1
//     S_1 stored constant - grab the one stored with the
//     coefficients.
// 

{ .mfi
(p7)   ldfe FR_S_1 = [GR_Table_Base1], 16
//
//     Check if i_1 and i_0  != 0
//
(p10)  fma.s1	FR_poly = f0, f1, FR_Neg_Two_to_M67
(p7)   cmp.eq.unc p11, p12 = 0x0, GR_i_0 ;;
}

{ .mfi
      nop.m 999
(p7)   fms.s1	FR_s = FR_s, f1, FR_r
      nop.i 999
}

{ .mfi
      nop.m 999
// 
//     S = S - r
//     U_2 = U_2 + w
//     load S_1
//
(p7)   fma.s1	FR_rsq = FR_r, FR_r, f0
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p7)   fma.s1	FR_U_2 = FR_U_2, f1, FR_w
      nop.i 999
}

{ .mfi
      nop.m 999
(p7)   fmerge.se FR_Input_X = FR_r, FR_r
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p10)  fma.s1 FR_Input_X = f0, f1, f1
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
// 
//     FR_rsq = r * r
//     Save r as the result.
//
(p7)   fms.s1	FR_c = FR_s, f1, FR_U_1
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
// 
//     if ( i_1 ==0) poly = c + S_1*r*r*r
//     else Result = 1
//
(p12)  fnma.s1 FR_Input_X = FR_Input_X, f1, f0
      nop.i 999
}

{ .mfi
      nop.m 999
(p7)   fma.s1	FR_r = FR_S_1, FR_r, f0
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p7)   fma.d.s0	FR_S_1 = FR_S_1, FR_S_1, f0
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
//
//     If i_1 != 0, poly = 2**(-67)
//
(p7)   fms.s1 FR_c = FR_c, f1, FR_U_2
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
// 
//     c = c - U_2
// 
(p9)   fma.s1 FR_poly = FR_r, FR_rsq, FR_c
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
//
//     i_0 != 0, so Result = -Result
//
(p11)  fma.d.s0 FR_Input_X = FR_Input_X, f1, FR_poly
      nop.i 999 ;;
}

{ .mfb
      nop.m 999
(p12)  fms.d.s0 FR_Input_X = FR_Input_X, f1, FR_poly
//
//     if (i_0 == 0),  Result = Result + poly
//     else            Result = Result - poly
//
(p0)   br.ret.sptk   b0 ;;
}
SINCOS_LARGER_ARG: 

{ .mfi
      nop.m 999
(p0)   fma.s1 FR_N_0 = FR_Input_X, FR_Inv_P_0, f0
      nop.i 999
}
;;

//     This path for argument > 2*24 
//     Adjust table_ptr1 to beginning of table.
//

{ .mmi
      nop.m 999
(p0)  addl           GR_Table_Base   = @ltoff(FSINCOS_CONSTANTS#), gp
      nop.i 999
}
;;

{ .mmi
      ld8 GR_Table_Base = [GR_Table_Base]
      nop.m 999
      nop.i 999
}
;;


// 
//     Point to  2*-14 
//     N_0 = Arg * Inv_P_0
//

{ .mmi
(p0)   add GR_Table_Base = 688, GR_Table_Base ;;
(p0)   ldfs FR_Two_to_M14 = [GR_Table_Base], 4
      nop.i 999 ;;
}

{ .mfi
(p0)   ldfs FR_Neg_Two_to_M14 = [GR_Table_Base], 0
      nop.f 999
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
//
//     Load values 2**(-14) and -2**(-14)
//
(p0)   fcvt.fx.s1 FR_N_0_fix = FR_N_0
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
//
//     N_0_fix  = integer part of N_0
//
(p0)   fcvt.xf FR_N_0 = FR_N_0_fix 
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
//
//     Make N_0 the integer part
//
(p0)   fnma.s1 FR_ArgPrime = FR_N_0, FR_P_0, FR_Input_X
      nop.i 999
}

{ .mfi
      nop.m 999
(p0)   fma.s1 FR_w = FR_N_0, FR_d_1, f0
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
//
//     Arg' = -N_0 * P_0 + Arg
//     w  = N_0 * d_1
//
(p0)   fma.s1 FR_N_float = FR_ArgPrime, FR_Inv_pi_by_2, f0
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
//
//     N = A' * 2/pi	
//
(p0)   fcvt.fx.s1 FR_N_fix = FR_N_float
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
//
//     N_fix is the integer part	
//
(p0)   fcvt.xf FR_N_float = FR_N_fix 
      nop.i 999 ;;
}

{ .mfi
(p0)   getf.sig GR_N_Inc = FR_N_fix
      nop.f 999
      nop.i 999 ;;
}

{ .mii
      nop.m 999
      nop.i 999 ;;
(p0)   add GR_N_Inc = GR_N_Inc, GR_Sin_or_Cos ;;
}

{ .mfi
      nop.m 999
//
//     N is the integer part of the reduced-reduced argument.
//     Put the integer in a GP register
//
(p0)   fnma.s1 FR_s = FR_N_float, FR_P_1, FR_ArgPrime
      nop.i 999
}

{ .mfi
      nop.m 999
(p0)   fnma.s1 FR_w = FR_N_float, FR_P_2, FR_w
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
//
//     s = -N*P_1 + Arg'
//     w = -N*P_2 + w
//     N_fix_gr = N_fix_gr + N_inc
//
(p0)   fcmp.lt.unc.s1 p9, p8 = FR_s, FR_Two_to_M14
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p9)   fcmp.gt.s1 p9, p8 = FR_s, FR_Neg_Two_to_M14
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
//
//     For |s|  > 2**(-14) r = S + w (r complete)
//     Else       U_hi = N_0 * d_1
//
(p9)   fma.s1 FR_V_hi = FR_N_float, FR_P_2, f0
      nop.i 999
}

{ .mfi
      nop.m 999
(p9)   fma.s1 FR_U_hi = FR_N_0, FR_d_1, f0
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
//
//     Either S <= -2**(-14) or S >= 2**(-14)
//     or -2**(-14) < s < 2**(-14)
//
(p8)   fma.s1 FR_r = FR_s, f1, FR_w
      nop.i 999
}

{ .mfi
      nop.m 999
(p9)   fma.s1 FR_w = FR_N_float, FR_P_3, f0
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
//
//     We need abs of both U_hi and V_hi - don't
//     worry about switched sign of V_hi.
//
(p9)   fms.s1 FR_A = FR_U_hi, f1, FR_V_hi
      nop.i 999
}

{ .mfi
      nop.m 999
//
//     Big s: finish up c = (S - r) + w (c complete)	
//     Case 4: A =  U_hi + V_hi
//     Note: Worry about switched sign of V_hi, so subtract instead of add.
//
(p9)   fnma.s1 FR_V_lo = FR_N_float, FR_P_2, FR_V_hi
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p9)   fms.s1 FR_U_lo = FR_N_0, FR_d_1, FR_U_hi
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p9)   fmerge.s FR_V_hiabs = f0, FR_V_hi
      nop.i 999
}

{ .mfi
      nop.m 999
//     For big s: c = S - r
//     For small s do more work: U_lo = N_0 * d_1 - U_hi
//
(p9)   fmerge.s FR_U_hiabs = f0, FR_U_hi
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
//
//     For big s: Is |r| < 2**(-3)	
//     For big s: if p12 set, prepare to branch to Small_R.
//     For big s: If p13 set, prepare to branch to Normal_R.
//
(p8)   fms.s1 FR_c = FR_s, f1, FR_r 
      nop.i 999
}

{ .mfi
      nop.m 999
//
//     For small S: V_hi = N * P_2
//                  w = N * P_3
//     Note the product does not include the (-) as in the writeup
//     so (-) missing for V_hi and w.
//
(p8)   fcmp.lt.unc.s1 p12, p13 = FR_r, FR_Two_to_M3
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p12)  fcmp.gt.s1 p12, p13 = FR_r, FR_Neg_Two_to_M3
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p8)   fma.s1 FR_c = FR_c, f1, FR_w
      nop.i 999
}

{ .mfb
      nop.m 999
(p9)   fms.s1 FR_w = FR_N_0, FR_d_2, FR_w
(p12)  br.cond.spnt SINCOS_SMALL_R ;;
}

{ .mib
      nop.m 999
      nop.i 999
(p13)  br.cond.sptk SINCOS_NORMAL_R ;;
}

{ .mfi
      nop.m 999
// 
//     Big s: Vector off when |r| < 2**(-3).  Recall that p8 will be true. 
//     The remaining stuff is for Case 4.
//     Small s: V_lo = N * P_2 + U_hi (U_hi is in place of V_hi in writeup)
//     Note: the (-) is still missing for V_lo.
//     Small s: w = w + N_0 * d_2
//     Note: the (-) is now incorporated in w.
//
(p9)   fcmp.ge.unc.s1 p10, p11 = FR_U_hiabs, FR_V_hiabs
(p0)   extr.u	GR_i_1 = GR_N_Inc, 0, 1 ;;
}

{ .mfi
      nop.m 999
//
//     C_hi = S + A
//
(p9)   fma.s1 FR_t = FR_U_lo, f1, FR_V_lo
(p0)   extr.u	GR_i_0 = GR_N_Inc, 1, 1 ;;
}

{ .mfi
      nop.m 999
//
//     t = U_lo + V_lo 
//
//
(p10)  fms.s1 FR_a = FR_U_hi, f1, FR_A
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p11)  fma.s1 FR_a = FR_V_hi, f1, FR_A
      nop.i 999
}
;;

{ .mmi
      nop.m 999
(p0)  addl           GR_Table_Base   = @ltoff(FSINCOS_CONSTANTS#), gp
      nop.i 999
}
;;

{ .mmi
      ld8 GR_Table_Base = [GR_Table_Base]
      nop.m 999
      nop.i 999
}
;;


{ .mfi
(p0)   add GR_Table_Base = 528, GR_Table_Base
//
//     Is U_hiabs >= V_hiabs?
//
(p9)   fma.s1 FR_C_hi = FR_s, f1, FR_A
      nop.i 999 ;;
}

{ .mmi
(p0)   ldfe FR_C_1 = [GR_Table_Base], 16 ;;
(p0)   ldfe FR_C_2 = [GR_Table_Base], 64
      nop.i 999 ;;
}

{ .mmf
      nop.m 999
//
//     c = c + C_lo  finished.
//     Load  C_2
//
(p0)   ldfe	FR_S_1 = [GR_Table_Base], 16
//
//     C_lo = S - C_hi 
//
(p0)   fma.s1 FR_t = FR_t, f1, FR_w ;;
}
//
//     r and c have been computed.
//     Make sure ftz mode is set - should be automatic when using wre
//     |r| < 2**(-3)
//     Get [i_0,i_1] - two lsb of N_fix.
//     Load S_1
//

{ .mfi
(p0)   ldfe FR_S_2 = [GR_Table_Base], 64
//
//     t = t + w	
//
(p10)  fms.s1 FR_a = FR_a, f1, FR_V_hi
(p0)   cmp.eq.unc p9, p10 = 0x0, GR_i_0
}

{ .mfi
      nop.m 999
//
//     For larger u than v: a = U_hi - A
//     Else a = V_hi - A (do an add to account for missing (-) on V_hi
//
(p0)   fms.s1 FR_C_lo = FR_s, f1, FR_C_hi
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p11)  fms.s1 FR_a = FR_U_hi, f1, FR_a
(p0)   cmp.eq.unc p11, p12 = 0x0, GR_i_1
}

{ .mfi
      nop.m 999
//
//     If u > v: a = (U_hi - A)  + V_hi
//     Else      a = (V_hi - A)  + U_hi
//     In each case account for negative missing from V_hi.
//
(p0)   fma.s1 FR_C_lo = FR_C_lo, f1, FR_A
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
//
//     C_lo = (S - C_hi) + A	
//
(p0)   fma.s1 FR_t = FR_t, f1, FR_a
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
//
//     t = t + a 
//
(p0)   fma.s1 FR_C_lo = FR_C_lo, f1, FR_t
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
//
//     C_lo = C_lo + t
//     Adjust Table_Base to beginning of table
//
(p0)   fma.s1 FR_r = FR_C_hi, f1, FR_C_lo
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
//
//     Load S_2
//
(p0)   fma.s1 FR_rsq = FR_r, FR_r, f0
      nop.i 999
}

{ .mfi
      nop.m 999
//
//     Table_Base points to C_1
//     r = C_hi + C_lo
//
(p0)   fms.s1 FR_c = FR_C_hi, f1, FR_r
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
//
//     if i_1 ==0: poly = S_2 * FR_rsq + S_1
//     else        poly = C_2 * FR_rsq + C_1
//
(p11)  fma.s1 FR_Input_X = f0, f1, FR_r
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p12)  fma.s1 FR_Input_X = f0, f1, f1
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
//
//     Compute r_cube = FR_rsq * r	
//
(p11)  fma.s1 FR_poly = FR_rsq, FR_S_2, FR_S_1
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p12)  fma.s1 FR_poly = FR_rsq, FR_C_2, FR_C_1
      nop.i 999
}

{ .mfi
      nop.m 999
//
//     Compute FR_rsq = r * r
//     Is i_1 == 0 ?
//
(p0)   fma.s1 FR_r_cubed = FR_rsq, FR_r, f0
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
//
//     c = C_hi - r
//     Load  C_1
//
(p0)   fma.s1 FR_c = FR_c, f1, FR_C_lo
      nop.i 999
}

{ .mfi
      nop.m 999
//
//     if i_1 ==0: poly = r_cube * poly + c
//     else        poly = FR_rsq * poly
//
(p10)  fms.s1 FR_Input_X = f0, f1, FR_Input_X
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
//
//     if i_1 ==0: Result = r
//     else        Result = 1.0
//
(p11)  fma.s1 FR_poly = FR_r_cubed, FR_poly, FR_c
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p12)  fma.s1 FR_poly = FR_rsq, FR_poly, f0
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
//
//     if i_0 !=0: Result = -Result 
//
(p9)   fma.d.s0 FR_Input_X = FR_Input_X, f1, FR_poly
      nop.i 999 ;;
}

{ .mfb
      nop.m 999
(p10)  fms.d.s0 FR_Input_X = FR_Input_X, f1, FR_poly
//
//     if i_0 == 0: Result = Result + poly
//     else         Result = Result - poly
//
(p0)   br.ret.sptk   b0 ;;
}
SINCOS_SMALL_R: 

{ .mii
      nop.m 999
(p0)  	extr.u	GR_i_1 = GR_N_Inc, 0, 1 ;;
//
//
//      Compare both i_1 and i_0 with 0.
//      if i_1 == 0, set p9.
//      if i_0 == 0, set p11.
//
(p0)  	cmp.eq.unc p9, p10 = 0x0, GR_i_1 ;;
}

{ .mfi
      nop.m 999
(p0)  	fma.s1 FR_rsq = FR_r, FR_r, f0
(p0)  	extr.u	GR_i_0 = GR_N_Inc, 1, 1 ;;
}

{ .mfi
      nop.m 999
//
// 	Z = Z * FR_rsq 
//
(p10)	fnma.s1	FR_c = FR_c, FR_r, f0
(p0)  	cmp.eq.unc p11, p12 = 0x0, GR_i_0
}
;;

// ******************************************************************
// ******************************************************************
// ******************************************************************
//      r and c have been computed.
//      We know whether this is the sine or cosine routine.
//      Make sure ftz mode is set - should be automatic when using wre
//      |r| < 2**(-3)
//
//      Set table_ptr1 to beginning of constant table.
//      Get [i_0,i_1] - two lsb of N_fix_gr.
//

{ .mmi
      nop.m 999
(p0)  addl           GR_Table_Base   = @ltoff(FSINCOS_CONSTANTS#), gp
      nop.i 999
}
;;

{ .mmi
      ld8 GR_Table_Base = [GR_Table_Base]
      nop.m 999
      nop.i 999
}
;;


// 
//      Set table_ptr1 to point to S_5.
//      Set table_ptr1 to point to C_5.
//      Compute FR_rsq = r * r
//

{ .mfi
(p9)  	add GR_Table_Base = 672, GR_Table_Base
(p10)	fmerge.s FR_r = f1, f1
(p10) 	add GR_Table_Base = 592, GR_Table_Base ;;
}
// 
//      Set table_ptr1 to point to S_5.
//      Set table_ptr1 to point to C_5.
//

{ .mmi
(p9)  	ldfe FR_S_5 = [GR_Table_Base], -16 ;;
//
//      if (i_1 == 0) load S_5
//      if (i_1 != 0) load C_5
//
(p9)  	ldfe FR_S_4 = [GR_Table_Base], -16
      nop.i 999 ;;
}

{ .mmf
(p10) 	ldfe FR_C_5 = [GR_Table_Base], -16
// 
//      Z = FR_rsq * FR_rsq
//
(p9)  	ldfe FR_S_3 = [GR_Table_Base], -16
//
//      Compute FR_rsq = r * r
//      if (i_1 == 0) load S_4
//      if (i_1 != 0) load C_4
//
(p0)   	fma.s1 FR_Z = FR_rsq, FR_rsq, f0 ;;
}
//
//      if (i_1 == 0) load S_3
//      if (i_1 != 0) load C_3
//

{ .mmi
(p9)  	ldfe FR_S_2 = [GR_Table_Base], -16 ;;
//
//      if (i_1 == 0) load S_2
//      if (i_1 != 0) load C_2
//
(p9)  	ldfe FR_S_1 = [GR_Table_Base], -16
      nop.i 999
}

{ .mmi
(p10) 	ldfe FR_C_4 = [GR_Table_Base], -16 ;;
(p10)  	ldfe FR_C_3 = [GR_Table_Base], -16
      nop.i 999 ;;
}

{ .mmi
(p10) 	ldfe FR_C_2 = [GR_Table_Base], -16 ;;
(p10) 	ldfe FR_C_1 = [GR_Table_Base], -16
      nop.i 999
}

{ .mfi
      nop.m 999
//
//      if (i_1 != 0):
//      poly_lo = FR_rsq * C_5 + C_4
//      poly_hi = FR_rsq * C_2 + C_1
//
(p9)  	fma.s1 FR_Z = FR_Z, FR_r, f0
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
//
//      if (i_1 == 0) load S_1
//      if (i_1 != 0) load C_1
//
(p9)  	fma.s1 FR_poly_lo = FR_rsq, FR_S_5, FR_S_4
      nop.i 999
}

{ .mfi
      nop.m 999
//
//      c = -c * r
//      dummy fmpy's to flag inexact.
//
(p9)	fma.d.s0 FR_S_4 = FR_S_4, FR_S_4, f0
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
//
//      poly_lo = FR_rsq * poly_lo + C_3
//      poly_hi = FR_rsq * poly_hi
//
(p0)    fma.s1	FR_Z = FR_Z, FR_rsq, f0
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p9)  	fma.s1 FR_poly_hi = FR_rsq, FR_S_2, FR_S_1
      nop.i 999
}

{ .mfi
      nop.m 999
//
//      if (i_1 == 0):
//      poly_lo = FR_rsq * S_5 + S_4
//      poly_hi = FR_rsq * S_2 + S_1
//
(p10) 	fma.s1 FR_poly_lo = FR_rsq, FR_C_5, FR_C_4
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
//
//      if (i_1 == 0):
//      Z = Z * r  for only one of the small r cases - not there
//      in original implementation notes.
// 
(p9)  	fma.s1 FR_poly_lo = FR_rsq, FR_poly_lo, FR_S_3
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p10) 	fma.s1 FR_poly_hi = FR_rsq, FR_C_2, FR_C_1
      nop.i 999
}

{ .mfi
      nop.m 999
(p10)	fma.d.s0 FR_C_1 = FR_C_1, FR_C_1, f0
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p9)  	fma.s1 FR_poly_hi = FR_poly_hi, FR_rsq, f0
      nop.i 999
}

{ .mfi
      nop.m 999
//
//      poly_lo = FR_rsq * poly_lo + S_3
//      poly_hi = FR_rsq * poly_hi
//
(p10) 	fma.s1 FR_poly_lo = FR_rsq, FR_poly_lo, FR_C_3
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p10) 	fma.s1 FR_poly_hi = FR_poly_hi, FR_rsq, f0
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
//
// 	if (i_1 == 0): dummy fmpy's to flag inexact
// 	r = 1
//
(p9)	fma.s1 FR_poly_hi = FR_r, FR_poly_hi, f0
      nop.i 999
}

{ .mfi
      nop.m 999
//
// 	poly_hi = r * poly_hi 
//
(p0)    fma.s1	FR_poly = FR_Z, FR_poly_lo, FR_c
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p12)	fms.s1	FR_r = f0, f1, FR_r
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
//
//      poly_hi = Z * poly_lo + c	
// 	if i_0 == 1: r = -r     
//
(p0) 	fma.s1	FR_poly = FR_poly, f1, FR_poly_hi
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p12)	fms.d.s0 FR_Input_X = FR_r, f1, FR_poly
      nop.i 999
}

{ .mfb
      nop.m 999
//
//      poly = poly + poly_hi	
//
(p11)	fma.d.s0 FR_Input_X = FR_r, f1, FR_poly
//
//      if (i_0 == 0) Result = r + poly
//      if (i_0 != 0) Result = r - poly
//
(p0)   br.ret.sptk   b0 ;;
}
SINCOS_NORMAL_R: 

{ .mii
      nop.m 999
(p0)	extr.u	GR_i_1 = GR_N_Inc, 0, 1 ;;
//
//      Set table_ptr1 and table_ptr2 to base address of
//      constant table.
(p0)	cmp.eq.unc p9, p10 = 0x0, GR_i_1 ;;
}

{ .mfi
      nop.m 999
(p0)	fma.s1	FR_rsq = FR_r, FR_r, f0
(p0)	extr.u	GR_i_0 = GR_N_Inc, 1, 1 ;;
}

{ .mfi
      nop.m 999
(p0)	frcpa.s1 FR_r_hi, p6 = f1, FR_r
(p0)	cmp.eq.unc p11, p12 = 0x0, GR_i_0
}
;;

// ******************************************************************
// ******************************************************************
// ******************************************************************
//
//      r and c have been computed.
//      We known whether this is the sine or cosine routine.
//      Make sure ftz mode is set - should be automatic when using wre
//      Get [i_0,i_1] - two lsb of N_fix_gr alone.
//

{ .mmi
      nop.m 999
(p0)  addl           GR_Table_Base   = @ltoff(FSINCOS_CONSTANTS#), gp
      nop.i 999
}
;;

{ .mmi
      ld8 GR_Table_Base = [GR_Table_Base]
      nop.m 999
      nop.i 999
}
;;


{ .mfi
(p10)	add GR_Table_Base = 384, GR_Table_Base
(p12)	fms.s1 FR_Input_X = f0, f1, f1
(p9)	add GR_Table_Base = 224, GR_Table_Base ;;
}

{ .mmf
      nop.m 999
(p10)	ldfe FR_QQ_8 = [GR_Table_Base], 16
//
//      if (i_1==0) poly = poly * FR_rsq + PP_1_lo
//      else        poly = FR_rsq * poly
//
(p11)	fma.s1 FR_Input_X = f0, f1, f1 ;;
}

{ .mmf
(p10)	ldfe FR_QQ_7 = [GR_Table_Base], 16
//
// 	Adjust table pointers based on i_0 
//      Compute rsq = r * r
//
(p9)	ldfe FR_PP_8 = [GR_Table_Base], 16
(p0)	fma.s1 FR_r_cubed = FR_r, FR_rsq, f0 ;;
}

{ .mmf
(p9)	ldfe FR_PP_7 = [GR_Table_Base], 16
(p10)	ldfe FR_QQ_6 = [GR_Table_Base], 16
//
//      Load PP_8 and QQ_8; PP_7 and QQ_7
//
(p0)	frcpa.s1 FR_r_hi, p6 = f1, FR_r_hi ;;
}
//
//      if (i_1==0) poly =   PP_7 + FR_rsq * PP_8.
//      else        poly =   QQ_7 + FR_rsq * QQ_8.
//

{ .mmb
(p9)	ldfe FR_PP_6 = [GR_Table_Base], 16
(p10)	ldfe FR_QQ_5 = [GR_Table_Base], 16
      nop.b 999 ;;
}

{ .mmb
(p9)	ldfe FR_PP_5 = [GR_Table_Base], 16
(p10)	ldfe FR_S_1 = [GR_Table_Base], 16
      nop.b 999 ;;
}

{ .mmb
(p10)	ldfe FR_QQ_1 = [GR_Table_Base], 16
(p9)	ldfe FR_C_1 = [GR_Table_Base], 16
      nop.b 999 ;;
}

{ .mmi
(p10)	ldfe FR_QQ_4 = [GR_Table_Base], 16 ;;
(p9)	ldfe FR_PP_1 = [GR_Table_Base], 16
      nop.i 999 ;;
}

{ .mmf
(p10)	ldfe FR_QQ_3 = [GR_Table_Base], 16
//
//      if (i_1=0) corr = corr + c*c
//      else       corr = corr * c 
//
(p9)	ldfe FR_PP_4 = [GR_Table_Base], 16
(p10)	fma.s1 FR_poly = FR_rsq, FR_QQ_8, FR_QQ_7 ;;
}
//
//      if (i_1=0) poly = rsq * poly + PP_5 
//      else       poly = rsq * poly + QQ_5 
//      Load PP_4 or QQ_4
//

{ .mmf
(p9)	ldfe FR_PP_3 = [GR_Table_Base], 16
(p10)	ldfe FR_QQ_2 = [GR_Table_Base], 16
//
//      r_hi =   frcpa(frcpa(r)).
//      r_cube = r * FR_rsq.
//
(p9)	fma.s1 FR_poly = FR_rsq, FR_PP_8, FR_PP_7 ;;
}
//
//      Do dummy multiplies so inexact is always set. 
//

{ .mfi
(p9)	ldfe FR_PP_2 = [GR_Table_Base], 16
//
//      r_lo = r - r_hi	
//
(p9)	fma.s1 FR_U_lo = FR_r_hi, FR_r_hi, f0
      nop.i 999 ;;
}

{ .mmf
      nop.m 999
(p9)	ldfe FR_PP_1_lo = [GR_Table_Base], 16
(p10)	fma.s1 FR_corr = FR_S_1, FR_r_cubed, FR_r
}

{ .mfi
      nop.m 999
(p10)	fma.s1 FR_poly = FR_rsq, FR_poly, FR_QQ_6
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
//
//      if (i_1=0) U_lo = r_hi * r_hi
//      else       U_lo = r_hi + r
//
(p9)	fma.s1 FR_corr = FR_C_1, FR_rsq, f0
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
//
//      if (i_1=0) corr = C_1 * rsq
//      else       corr = S_1 * r_cubed + r
//
(p9)	fma.s1 FR_poly = FR_rsq, FR_poly, FR_PP_6
      nop.i 999
}

{ .mfi
      nop.m 999
(p10)	fma.s1 FR_U_lo = FR_r_hi, f1, FR_r
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
//
//      if (i_1=0) U_hi = r_hi + U_hi 
//      else       U_hi = QQ_1 * U_hi + 1
//
(p9)	fma.s1 FR_U_lo = FR_r, FR_r_hi, FR_U_lo
      nop.i 999
}

{ .mfi
      nop.m 999
//
//      U_hi = r_hi * r_hi	
//
(p0)	fms.s1 FR_r_lo = FR_r, f1, FR_r_hi
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
//
//      Load PP_1, PP_6, PP_5, and C_1
//      Load QQ_1, QQ_6, QQ_5, and S_1
//
(p0)	fma.s1 FR_U_hi = FR_r_hi, FR_r_hi, f0
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p10)	fma.s1 FR_poly = FR_rsq, FR_poly, FR_QQ_5
      nop.i 999
}

{ .mfi
      nop.m 999
(p10)	fnma.s1	FR_corr = FR_corr, FR_c, f0
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
//
//      if (i_1=0) U_lo = r * r_hi + U_lo 
//      else       U_lo = r_lo * U_lo
//
(p9)	fma.s1 FR_corr = FR_corr, FR_c, FR_c
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p9)	fma.s1 FR_poly = FR_rsq, FR_poly, FR_PP_5
      nop.i 999
}

{ .mfi
      nop.m 999
//
//      if (i_1 =0) U_hi = r + U_hi
//      if (i_1 =0) U_lo = r_lo * U_lo 
//      
//
(p9)	fma.d.s0 FR_PP_5 = FR_PP_5, FR_PP_4, f0
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p9)	fma.s1 FR_U_lo = FR_r, FR_r, FR_U_lo
      nop.i 999
}

{ .mfi
      nop.m 999
(p10)	fma.s1 FR_U_lo = FR_r_lo, FR_U_lo, f0
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
//
//      if (i_1=0) poly = poly * rsq + PP_6
//      else       poly = poly * rsq + QQ_6 
//
(p9)	fma.s1 FR_U_hi = FR_r_hi, FR_U_hi, f0
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p10)	fma.s1 FR_poly = FR_rsq, FR_poly, FR_QQ_4
      nop.i 999
}

{ .mfi
      nop.m 999
(p10)	fma.s1 FR_U_hi = FR_QQ_1, FR_U_hi, f1
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p10)	fma.d.s0 FR_QQ_5 = FR_QQ_5, FR_QQ_5, f0
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
//
//      if (i_1!=0) U_hi = PP_1 * U_hi  
//      if (i_1!=0) U_lo = r * r  + U_lo  
//      Load PP_3 or QQ_3
//
(p9)	fma.s1 FR_poly = FR_rsq, FR_poly, FR_PP_4
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p9)	fma.s1 FR_U_lo = FR_r_lo, FR_U_lo, f0
      nop.i 999
}

{ .mfi
      nop.m 999
(p10)	fma.s1 FR_U_lo = FR_QQ_1,FR_U_lo, f0
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p9)	fma.s1 FR_U_hi = FR_PP_1, FR_U_hi, f0
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p10)	fma.s1 FR_poly = FR_rsq, FR_poly, FR_QQ_3
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
//
//      Load PP_2, QQ_2
//
(p9)	fma.s1 FR_poly = FR_rsq, FR_poly, FR_PP_3
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
//
//      if (i_1==0) poly = FR_rsq * poly  + PP_3
//      else        poly = FR_rsq * poly  + QQ_3
//      Load PP_1_lo
//
(p9)	fma.s1 FR_U_lo = FR_PP_1, FR_U_lo, f0
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
//
//      if (i_1 =0) poly = poly * rsq + pp_r4
//      else        poly = poly * rsq + qq_r4
//
(p9)	fma.s1 FR_U_hi = FR_r, f1, FR_U_hi
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p10)	fma.s1 FR_poly = FR_rsq, FR_poly, FR_QQ_2
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
//
//      if (i_1==0) U_lo =  PP_1_hi * U_lo
//      else        U_lo =  QQ_1 * U_lo
//
(p9)	fma.s1 FR_poly = FR_rsq, FR_poly, FR_PP_2
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
//
//      if (i_0==0)  Result = 1
//      else         Result = -1
//
(p0) 	fma.s1 FR_V = FR_U_lo, f1, FR_corr
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p10)	fma.s1 FR_poly = FR_rsq, FR_poly, f0
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
//
//      if (i_1==0) poly =  FR_rsq * poly + PP_2
//      else poly =  FR_rsq * poly + QQ_2
// 
(p9)	fma.s1 FR_poly = FR_rsq, FR_poly, FR_PP_1_lo
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p10)	fma.s1 FR_poly = FR_rsq, FR_poly, f0
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
//
//      V = U_lo + corr
//
(p9)	fma.s1 FR_poly = FR_r_cubed, FR_poly, f0
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
//
//      if (i_1==0) poly = r_cube * poly
//      else        poly = FR_rsq * poly
//
(p0)	fma.s1	FR_V = FR_poly, f1, FR_V
      nop.i 999 ;;
}

{ .mfi
      nop.m 999
(p12)	fms.d.s0 FR_Input_X = FR_Input_X, FR_U_hi, FR_V
      nop.i 999
}

{ .mfb
      nop.m 999
//
//      V = V + poly	
//
(p11)	fma.d.s0 FR_Input_X = FR_Input_X, FR_U_hi, FR_V
//
//      if (i_0==0) Result = Result * U_hi + V
//      else        Result = Result * U_hi - V
//
(p0)   br.ret.sptk   b0 ;;
}

//
//      If cosine, FR_Input_X = 1
//      If sine, FR_Input_X = +/-Zero (Input FR_Input_X)
//      Results are exact, no exceptions
//
SINCOS_ZERO:

{ .mmb
(p0)    cmp.eq.unc p6, p7 = 0x1, GR_Sin_or_Cos
      nop.m 999
      nop.b 999 ;;
}

{ .mfi
      nop.m 999
(p7)    fmerge.s FR_Input_X = FR_Input_X, FR_Input_X
      nop.i 999
}

{ .mfb
      nop.m 999
(p6)    fmerge.s FR_Input_X = f1, f1
(p0)   br.ret.sptk   b0 ;;
}

SINCOS_SPECIAL:

//
//      Path for Arg = +/- QNaN, SNaN, Inf
//      Invalid can be raised. SNaNs
//      become QNaNs
//

{ .mfb
      nop.m 999
(p0)    fmpy.d.s0 FR_Input_X = FR_Input_X, f0
(p0)    br.ret.sptk   b0 ;;
}
.endp __libm_cos_double_dbx#



//
//      Call int pi_by_2_reduce(double* x, double *y)
//      for |arguments| >= 2**63
//      Address to save r and c as double 
//
//      
//      psp    sp+64
//             sp+48  -> f0 c
//      r45    sp+32  -> f0 r
//      r44 -> sp+16  -> InputX  
//      sp     sp     -> scratch provided to callee



.proc __libm_callout_2
__libm_callout_2:
SINCOS_ARG_TOO_LARGE:

.prologue
{ .mfi
        add   r45=-32,sp                        // Parameter: r address
        nop.f 0
.save   ar.pfs,GR_SAVE_PFS
        mov  GR_SAVE_PFS=ar.pfs                 // Save ar.pfs
}
{ .mfi
.fframe 64
        add sp=-64,sp                           // Create new stack
        nop.f 0
        mov GR_SAVE_GP=gp                       // Save gp
};;
{ .mmi
        stfe [r45] = f0,16                      // Clear Parameter r on stack
        add  r44 = 16,sp                        // Parameter x address
.save   b0, GR_SAVE_B0
        mov GR_SAVE_B0=b0                       // Save b0
};;
.body
{ .mib
        stfe [r45] = f0,-16                     // Clear Parameter c on stack
        nop.i 0
        nop.b 0
}
{ .mib
        stfe [r44] = FR_Input_X                 // Store Parameter x on stack
        nop.i 0
(p0)    br.call.sptk b0=__libm_pi_by_2_reduce# ;;
};;


{ .mii
(p0)    ldfe  FR_Input_X =[r44],16
//
//      Get r and c off stack
//
(p0)    adds  GR_Table_Base1 = -16, GR_Table_Base1
//
//      Get r and c off stack
//
(p0)    add   GR_N_Inc = GR_Sin_or_Cos,r8 ;;
}
{ .mmb
(p0)    ldfe  FR_r =[r45],16
//
//      Get X off the stack
//      Readjust Table ptr
//
(p0)    ldfs FR_Two_to_M3 = [GR_Table_Base1],4
        nop.b 999 ;;
}
{ .mmb
(p0)    ldfs FR_Neg_Two_to_M3 = [GR_Table_Base1],0
(p0)    ldfe  FR_c =[r45]
        nop.b 999 ;;
}

{ .mfi
.restore
        add   sp = 64,sp                       // Restore stack pointer
(p0)    fcmp.lt.unc.s1  p6, p0 = FR_r, FR_Two_to_M3
        mov   b0 = GR_SAVE_B0                  // Restore return address
};;
{ .mib
        mov   gp = GR_SAVE_GP                  // Restore gp
        mov   ar.pfs = GR_SAVE_PFS             // Restore ar.pfs
        nop.b 0
};;


{ .mfi
      nop.m 999
(p6)    fcmp.gt.unc.s1	p6, p0 = FR_r, FR_Neg_Two_to_M3
      nop.i 999 ;;
}

{ .mib
      nop.m 999
      nop.i 999
(p6)    br.cond.spnt SINCOS_SMALL_R ;;
}

{ .mib
      nop.m 999
      nop.i 999
(p0)    br.cond.sptk SINCOS_NORMAL_R ;;
}

.endp __libm_callout_2

.type   __libm_pi_by_2_reduce#,@function
.global __libm_pi_by_2_reduce#


.type __libm_sin_double_dbx#,@function
.global __libm_sin_double_dbx#
.type __libm_cos_double_dbx#,@function
.global __libm_cos_double_dbx#
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\ia64\sincosf.s ===
.file "sincosf.s"

// Copyright (c) 2000, 2001, Intel Corporation
// All rights reserved.
//
// Contributed 2/2/2000 by John Harrison, Ted Kubaska, Bob Norin, Shane Story,
// and Ping Tak Peter Tang of the Computational Software Lab, Intel Corporation.
//
// WARRANTY DISCLAIMER
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// Intel Corporation is the author of this code, and requests that all
// problem reports or change requests be submitted to it directly at
// http://developer.intel.com/opensource.


// History
//==============================================================
// 2/02/00  Initial version
// 4/02/00  Unwind support added.
// 5/10/00  Improved speed with new algorithm.
// 8/08/00  Improved speed by avoiding SIR flush.
// 8/17/00  Changed predicate register macro-usage to direct predicate
//          names due to an assembler bug.
// 8/30/00  Put sin_of_r before sin_tbl_S_cos_of_r to gain a cycle 
// 1/02/00  Fixed flag settings, improved speed.
//
// API
//==============================================================
// float sinf( float x);
// float cosf( float x);
//
// Assembly macros
//==============================================================

// SIN_Sin_Flag               = p6
// SIN_Cos_Flag               = p7

// integer registers used

 SIN_AD_PQ_1                = r33
 SIN_AD_PQ_2                = r33
 sin_GR_sincos_flag         = r34
 sin_GR_Mint                = r35

 sin_GR_index               = r36
 gr_tmp                     = r37

 GR_SAVE_B0                 = r37
 GR_SAVE_GP                 = r38
 GR_SAVE_PFS                = r39


// floating point registers used

 sin_coeff_P1               = f32
 sin_coeff_P2               = f33
 sin_coeff_Q1               = f34
 sin_coeff_Q2               = f35
 sin_coeff_P4               = f36
 sin_coeff_P5               = f37
 sin_coeff_Q3               = f38
 sin_coeff_Q4               = f39
 sin_Mx                     = f40
 sin_Mfloat                 = f41
 sin_tbl_S                  = f42
 sin_tbl_C                  = f43
 sin_r                      = f44
 sin_rcube                  = f45
 sin_tsq                    = f46
 sin_r7                     = f47
 sin_t                      = f48
 sin_poly_p2                = f49
 sin_poly_p1                = f50
 fp_tmp                     = f51
 sin_poly_p3                = f52
 sin_poly_p4                = f53
 sin_of_r                   = f54
 sin_S_t                    = f55
 sin_poly_q2                = f56
 sin_poly_q1                = f57
 sin_S_tcube                = f58
 sin_poly_q3                = f59
 sin_poly_q4                = f60
 sin_tbl_S_tcube            = f61
 sin_tbl_S_cos_of_r         = f62

 sin_coeff_Q5               = f63
 sin_coeff_Q6               = f64
 sin_coeff_P3               = f65

 sin_poly_q5                = f66
 sin_poly_q12               = f67
 sin_poly_q3456             = f68
 fp_tmp2                    = f69
 SIN_NORM_f8                = f70


.data

.align 16

sin_coeff_1_table:
data8 0xBF56C16C16BF6462       // q3
data8 0x3EFA01A0128B9EBC       // q4
data8 0xBE927E42FDF33FFE       // q5
data8 0x3E21DA5C72A446F3       // q6
data8 0x3EC71DD1D5E421A4       // p4
data8 0xBE5AC5C9D0ACF95A       // p5
data8 0xBFC55555555554CA       // p1
data8 0x3F811111110F2395       // p2
data8 0xBFE0000000000000       // q1
data8 0x3FA55555555554EF       // q2
data8 0xBF2A01A011232913       // p3
data8 0x0000000000000000       // pad
 

/////////////////////////////////////////

data8 0xBFE1A54991426566   //sin(-32)
data8 0x3FEAB1F5305DE8E5   //cos(-32)
data8 0x3FD9DBC0B640FC81   //sin(-31)
data8 0x3FED4591C3E12A20   //cos(-31)
data8 0x3FEF9DF47F1C903D   //sin(-30)
data8 0x3FC3BE82F2505A52   //cos(-30)
data8 0x3FE53C7D20A6C9E7   //sin(-29)
data8 0xBFE7F01658314E47   //cos(-29)
data8 0xBFD156853B4514D6   //sin(-28)
data8 0xBFEECDAAD1582500   //cos(-28)
data8 0xBFEE9AA1B0E5BA30   //sin(-27)
data8 0xBFD2B266F959DED5   //cos(-27)
data8 0xBFE866E0FAC32583   //sin(-26)
data8 0x3FE4B3902691A9ED   //cos(-26)
data8 0x3FC0F0E6F31E809D   //sin(-25)
data8 0x3FEFB7EEF59504FF   //cos(-25)
data8 0x3FECFA7F7919140F   //sin(-24)
data8 0x3FDB25BFB50A609A   //cos(-24)
data8 0x3FEB143CD0247D02   //sin(-23)
data8 0xBFE10CF7D591F272   //cos(-23)
data8 0x3F8220A29F6EB9F4   //sin(-22)
data8 0xBFEFFFADD8D4ACDA   //cos(-22)
data8 0xBFEAC5E20BB0D7ED   //sin(-21)
data8 0xBFE186FF83773759   //cos(-21)
data8 0xBFED36D8F55D3CE0   //sin(-20)
data8 0x3FDA1E043964A83F   //cos(-20)
data8 0xBFC32F2D28F584CF   //sin(-19)
data8 0x3FEFA377DE108258   //cos(-19)
data8 0x3FE8081668131E26   //sin(-18)
data8 0x3FE52150815D2470   //cos(-18)
data8 0x3FEEC3C4AC42882B   //sin(-17)
data8 0xBFD19C46B07F58E7   //cos(-17)
data8 0x3FD26D02085F20F8   //sin(-16)
data8 0xBFEEA5257E962F74   //cos(-16)
data8 0xBFE4CF2871CEC2E8   //sin(-15)
data8 0xBFE84F5D069CA4F3   //cos(-15)
data8 0xBFEFB30E327C5E45   //sin(-14)
data8 0x3FC1809AEC2CA0ED   //cos(-14)
data8 0xBFDAE4044881C506   //sin(-13)
data8 0x3FED09CDD5260CB7   //cos(-13)
data8 0x3FE12B9AF7D765A5   //sin(-12)
data8 0x3FEB00DA046B65E3   //cos(-12)
data8 0x3FEFFFEB762E93EB   //sin(-11)
data8 0x3F7220AE41EE2FDF   //cos(-11)
data8 0x3FE1689EF5F34F52   //sin(-10)
data8 0xBFEAD9AC890C6B1F   //cos(-10)
data8 0xBFDA6026360C2F91   //sin( -9)
data8 0xBFED27FAA6A6196B   //cos( -9)
data8 0xBFEFA8D2A028CF7B   //sin( -8)
data8 0xBFC29FBEBF632F94   //cos( -8)
data8 0xBFE50608C26D0A08   //sin( -7)
data8 0x3FE81FF79ED92017   //cos( -7)
data8 0x3FD1E1F18AB0A2C0   //sin( -6)
data8 0x3FEEB9B7097822F5   //cos( -6)
data8 0x3FEEAF81F5E09933   //sin( -5)
data8 0x3FD22785706B4AD9   //cos( -5)
data8 0x3FE837B9DDDC1EAE   //sin( -4)
data8 0xBFE4EAA606DB24C1   //cos( -4)
data8 0xBFC210386DB6D55B   //sin( -3)
data8 0xBFEFAE04BE85E5D2   //cos( -3)
data8 0xBFED18F6EAD1B446   //sin( -2)
data8 0xBFDAA22657537205   //cos( -2)
data8 0xBFEAED548F090CEE   //sin( -1)
data8 0x3FE14A280FB5068C   //cos( -1)
data8 0x0000000000000000   //sin(  0)
data8 0x3FF0000000000000   //cos(  0)
data8 0x3FEAED548F090CEE   //sin(  1)
data8 0x3FE14A280FB5068C   //cos(  1)
data8 0x3FED18F6EAD1B446   //sin(  2)
data8 0xBFDAA22657537205   //cos(  2)
data8 0x3FC210386DB6D55B   //sin(  3)
data8 0xBFEFAE04BE85E5D2   //cos(  3)
data8 0xBFE837B9DDDC1EAE   //sin(  4)
data8 0xBFE4EAA606DB24C1   //cos(  4)
data8 0xBFEEAF81F5E09933   //sin(  5)
data8 0x3FD22785706B4AD9   //cos(  5)
data8 0xBFD1E1F18AB0A2C0   //sin(  6)
data8 0x3FEEB9B7097822F5   //cos(  6)
data8 0x3FE50608C26D0A08   //sin(  7)
data8 0x3FE81FF79ED92017   //cos(  7)
data8 0x3FEFA8D2A028CF7B   //sin(  8)
data8 0xBFC29FBEBF632F94   //cos(  8)
data8 0x3FDA6026360C2F91   //sin(  9)
data8 0xBFED27FAA6A6196B   //cos(  9)
data8 0xBFE1689EF5F34F52   //sin( 10)
data8 0xBFEAD9AC890C6B1F   //cos( 10)
data8 0xBFEFFFEB762E93EB   //sin( 11)
data8 0x3F7220AE41EE2FDF   //cos( 11)
data8 0xBFE12B9AF7D765A5   //sin( 12)
data8 0x3FEB00DA046B65E3   //cos( 12)
data8 0x3FDAE4044881C506   //sin( 13)
data8 0x3FED09CDD5260CB7   //cos( 13)
data8 0x3FEFB30E327C5E45   //sin( 14)
data8 0x3FC1809AEC2CA0ED   //cos( 14)
data8 0x3FE4CF2871CEC2E8   //sin( 15)
data8 0xBFE84F5D069CA4F3   //cos( 15)
data8 0xBFD26D02085F20F8   //sin( 16)
data8 0xBFEEA5257E962F74   //cos( 16)
data8 0xBFEEC3C4AC42882B   //sin( 17)
data8 0xBFD19C46B07F58E7   //cos( 17)
data8 0xBFE8081668131E26   //sin( 18)
data8 0x3FE52150815D2470   //cos( 18)
data8 0x3FC32F2D28F584CF   //sin( 19)
data8 0x3FEFA377DE108258   //cos( 19)
data8 0x3FED36D8F55D3CE0   //sin( 20)
data8 0x3FDA1E043964A83F   //cos( 20)
data8 0x3FEAC5E20BB0D7ED   //sin( 21)
data8 0xBFE186FF83773759   //cos( 21)
data8 0xBF8220A29F6EB9F4   //sin( 22)
data8 0xBFEFFFADD8D4ACDA   //cos( 22)
data8 0xBFEB143CD0247D02   //sin( 23)
data8 0xBFE10CF7D591F272   //cos( 23)
data8 0xBFECFA7F7919140F   //sin( 24)
data8 0x3FDB25BFB50A609A   //cos( 24)
data8 0xBFC0F0E6F31E809D   //sin( 25)
data8 0x3FEFB7EEF59504FF   //cos( 25)
data8 0x3FE866E0FAC32583   //sin( 26)
data8 0x3FE4B3902691A9ED   //cos( 26)
data8 0x3FEE9AA1B0E5BA30   //sin( 27)
data8 0xBFD2B266F959DED5   //cos( 27)
data8 0x3FD156853B4514D6   //sin( 28)
data8 0xBFEECDAAD1582500   //cos( 28)
data8 0xBFE53C7D20A6C9E7   //sin( 29)
data8 0xBFE7F01658314E47   //cos( 29)
data8 0xBFEF9DF47F1C903D   //sin( 30)
data8 0x3FC3BE82F2505A52   //cos( 30)
data8 0xBFD9DBC0B640FC81   //sin( 31)
data8 0x3FED4591C3E12A20   //cos( 31)
data8 0x3FE1A54991426566   //sin( 32)
data8 0x3FEAB1F5305DE8E5   //cos( 32)

//////////////////////////////////////////


.global sinf
.global cosf

.text
.proc cosf
.align 32


cosf:
{ .mfi
     alloc          r32                      = ar.pfs,1,7,0,0
     fcvt.fx.s1     sin_Mx                   =    f8
     cmp.ne    p6,p7     =    r0,r0        // p7 set if cos
}
{ .mfi
     addl           SIN_AD_PQ_1              =    @ltoff(sin_coeff_1_table),gp
     fnorm.s0 SIN_NORM_f8 = f8        // Sets denormal or invalid
     mov sin_GR_sincos_flag = 0x0
}
;;

{ .mfi
     ld8       SIN_AD_PQ_1    =    [SIN_AD_PQ_1]
     fclass.m.unc  p9,p0      =    f8, 0x07
     cmp.ne p8,p0 = r0,r0
}
{ .mfb
     nop.m 999
     nop.f 999
     br.sptk SINCOSF_COMMON
}
;;

.endp cosf


.text
.proc  sinf
.align 32

sinf:
{ .mfi
     alloc          r32                      = ar.pfs,1,7,0,0
     fcvt.fx.s1     sin_Mx                   =    f8
     cmp.eq    p6,p7     =    r0,r0        // p6 set if sin
}
{ .mfi
     addl           SIN_AD_PQ_1              =    @ltoff(sin_coeff_1_table),gp
     fnorm.s0 SIN_NORM_f8 = f8        // Sets denormal or invalid
     mov sin_GR_sincos_flag = 0x1
}
;;

{ .mfi
     ld8       SIN_AD_PQ_1    =    [SIN_AD_PQ_1]
     fclass.m.unc  p8,p0      =    f8, 0x07
     cmp.ne p9,p0 = r0,r0
}
{ .mfb
     nop.m 999
     nop.f 999
     br.sptk SINCOSF_COMMON
}
;;


SINCOSF_COMMON:

// Here with p6 if sin, p7 if cos, p8 if sin(0), p9 if cos(0)


{ .mmf
     ldfpd      sin_coeff_Q3, sin_coeff_Q4     = [SIN_AD_PQ_1], 16
     nop.m 999
     fclass.m.unc  p11,p0      =    f8, 0x23	// Test for x=inf
}
;;

{ .mfb
     ldfpd      sin_coeff_Q5, sin_coeff_Q6     = [SIN_AD_PQ_1], 16
     fclass.m.unc  p10,p0      =    f8, 0xc3	// Test for x=nan
(p8) br.ret.spnt b0                   // Exit for sin(0)
}
{ .mfb
     nop.m 999
(p9) fma.s      f8 = f1,f1,f0
(p9) br.ret.spnt b0                   // Exit for cos(0)
}
;;

{ .mmf
     ldfpd      sin_coeff_P4, sin_coeff_P5     = [SIN_AD_PQ_1], 16
     addl gr_tmp = -1,r0
     fcvt.xf    sin_Mfloat                     =    sin_Mx
}
;;

{     .mfi
     getf.sig  sin_GR_Mint    =    sin_Mx
(p11) frcpa.s0      f8,p13      =    f0,f0  // qnan indef if x=inf
     nop.i 999
}
{     .mfb
     ldfpd      sin_coeff_P1, sin_coeff_P2     = [SIN_AD_PQ_1], 16
     nop.f 999
(p11) br.ret.spnt b0                   // Exit for x=inf
}
;;

{     .mfi
     ldfpd      sin_coeff_Q1, sin_coeff_Q2     = [SIN_AD_PQ_1], 16
     nop.f                      999
     cmp.ge    p8,p9          = -33,sin_GR_Mint
}
{     .mfb
     add       sin_GR_index   =    32,sin_GR_Mint
(p10) fma.s      f8 = f8,f1,f0         // Force qnan if x=nan
(p10) br.ret.spnt b0                   // Exit for x=nan
}
;;

{ .mmi
     ldfd      sin_coeff_P3   = [SIN_AD_PQ_1], 16
(p9) cmp.le    p8,p0        = 33, sin_GR_Mint 
     shl       sin_GR_index   =    sin_GR_index,4
}
;;


{     .mfi
     setf.sig fp_tmp = gr_tmp  // Create constant such that fmpy sets inexact
     fnma.s1   sin_r     =    f1,sin_Mfloat,SIN_NORM_f8
(p8) cmp.eq.unc p11,p12=sin_GR_sincos_flag,r0  // p11 if must call dbl cos
                                               // p12 if must call dbl sin
}
{    .mbb
     add       SIN_AD_PQ_2    =    sin_GR_index,SIN_AD_PQ_1
(p11) br.cond.spnt COS_DOUBLE
(p12) br.cond.spnt SIN_DOUBLE
}
;;

.pred.rel "mutex",p6,p7    //SIN_Sin_Flag, SIN_Cos_Flag
{     .mmi
(p6) ldfpd     sin_tbl_S,sin_tbl_C =    [SIN_AD_PQ_2]
(p7) ldfpd     sin_tbl_C,sin_tbl_S =    [SIN_AD_PQ_2]
               nop.i                           999
}
;;

{     .mfi
     nop.m                 999
(p6) fclass.m.unc p8,p0 = f8, 0x0b // If sin, note denormal input to set uflow
     nop.i                 999
}
{     .mfi
     nop.m                 999
     fma.s1    sin_t     =    sin_r,sin_r,f0
     nop.i                 999
}
;;

{     .mfi
     nop.m                 999
     fma.s1    sin_rcube =    sin_t,sin_r,f0
     nop.i                 999
}
{     .mfi
     nop.m                 999
     fma.s1    sin_tsq   =    sin_t,sin_t,f0
     nop.i                 999
}
;;

{     .mfi
     nop.m                      999
     fma.s1    sin_poly_q3    =    sin_t,sin_coeff_Q4,sin_coeff_Q3
     nop.i                      999
}
{     .mfi
     nop.m                      999
     fma.s1    sin_poly_q5    =    sin_t,sin_coeff_Q6,sin_coeff_Q5
     nop.i                      999
}
;;

{     .mfi
     nop.m                      999
     fma.s1    sin_poly_p1    =    sin_t,sin_coeff_P5,sin_coeff_P4
     nop.i                      999
}
{     .mfi
     nop.m                      999
     fma.s1    sin_poly_p2    =    sin_t,sin_coeff_P2,sin_coeff_P1
     nop.i                      999
}
;;

{     .mfi
     nop.m                      999
     fma.s1    sin_poly_q1    =    sin_t,sin_coeff_Q2,sin_coeff_Q1
     nop.i                      999
}
{     .mfi
     nop.m                      999
     fma.s1    sin_S_t   =    sin_t,sin_tbl_S,f0
     nop.i                      999
}
;;

{     .mfi
     nop.m                 999
(p8) fmpy.s.s0 fp_tmp2 = f8,f8  // Dummy mult to set underflow if sin(denormal)
     nop.i                 999
}
{     .mfi
     nop.m                 999
     fma.s1    sin_r7    =    sin_rcube,sin_tsq,f0
     nop.i                 999
}
;;

{     .mfi
     nop.m                      999
     fma.s1    sin_poly_q3456 =    sin_tsq,sin_poly_q5,sin_poly_q3
     nop.i                      999
}
;;

{     .mfi
     nop.m                      999
     fma.s1    sin_poly_p3    =    sin_t,sin_poly_p1,sin_coeff_P3
     nop.i                      999
}
{     .mfi
     nop.m                      999
     fma.s1    sin_poly_p4    =    sin_rcube,sin_poly_p2,sin_r
     nop.i                      999
}
;;

{     .mfi
     nop.m                           999
     fma.s1    sin_tbl_S_tcube     =    sin_S_t,sin_tsq,f0
     nop.i                           999
}
{     .mfi
     nop.m                      999
     fma.s1    sin_poly_q12   =    sin_S_t,sin_poly_q1,sin_tbl_S
     nop.i                      999
}
;;

{     .mfi
     nop.m                 999
     fma.d.s1  sin_of_r  =    sin_r7,sin_poly_p3,sin_poly_p4
     nop.i                 999
}
;;

{     .mfi
     nop.m                           999
     fma.d.s1  sin_tbl_S_cos_of_r  =    sin_tbl_S_tcube,sin_poly_q3456,sin_poly_q12
     nop.i                           999
}
{     .mfi
     nop.m                           999
     fmpy.s0   fp_tmp = fp_tmp, fp_tmp  // Dummy mult to set inexact
     nop.i                           999
}
;;


.pred.rel "mutex",p6,p7    //SIN_Sin_Flag, SIN_Cos_Flag
{     .mfi
               nop.m            999
//(SIN_Sin_Flag) fma.s     f8   =    sin_tbl_C,sin_of_r,sin_tbl_S_cos_of_r
(p6) fma.s     f8   =    sin_tbl_C,sin_of_r,sin_tbl_S_cos_of_r
               nop.i            999
}
{     .mfb
               nop.m            999
//(SIN_Cos_Flag) fnma.s    f8   =    sin_tbl_C,sin_of_r,sin_tbl_S_cos_of_r
(p7) fnma.s    f8   =    sin_tbl_C,sin_of_r,sin_tbl_S_cos_of_r
               br.ret.sptk     b0
}

.endp sinf


.proc SIN_DOUBLE 
SIN_DOUBLE:
.prologue
{ .mfi
        nop.m 0
        nop.f 0
.save   ar.pfs,GR_SAVE_PFS
        mov  GR_SAVE_PFS=ar.pfs
}
;;

{ .mfi
        mov GR_SAVE_GP=gp
        nop.f 0
.save   b0, GR_SAVE_B0
        mov GR_SAVE_B0=b0
}

.body
{ .mmb
       nop.m 999
       nop.m 999
       br.call.sptk.many   b0=sin 
}
;;

{ .mfi
       mov gp        = GR_SAVE_GP
       nop.f 999
       mov b0        = GR_SAVE_B0
}
;;

{ .mfi
      nop.m 999
      fma.s f8 = f8,f1,f0
      mov ar.pfs    = GR_SAVE_PFS
}
{ .mib
      nop.m 999
      nop.i 999
      br.ret.sptk     b0 
}
;;

.endp  SIN_DOUBLE 


.proc COS_DOUBLE 
COS_DOUBLE:
.prologue
{ .mfi
        nop.m 0
        nop.f 0
.save   ar.pfs,GR_SAVE_PFS
        mov  GR_SAVE_PFS=ar.pfs
}
;;

{ .mfi
        mov GR_SAVE_GP=gp
        nop.f 0
.save   b0, GR_SAVE_B0
        mov GR_SAVE_B0=b0
}

.body
{ .mmb
       nop.m 999
       nop.m 999
       br.call.sptk.many   b0=cos 
}
;;

{ .mfi
       mov gp        = GR_SAVE_GP
       nop.f 999
       mov b0        = GR_SAVE_B0
}
;;

{ .mfi
      nop.m 999
      fma.s f8 = f8,f1,f0
      mov ar.pfs    = GR_SAVE_PFS
}
{ .mib
      nop.m 999
      nop.i 999
      br.ret.sptk     b0 
}
;;

.endp  COS_DOUBLE 



.type sin,@function
.global sin 
.type cos,@function
.global cos
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\ia64\pow.s ===
.file "pow.s"

// Copyright (c) 2000-2002, Intel Corporation
// All rights reserved.
//
// Contributed 2/2/2000 by John Harrison, Ted Kubaska, Bob Norin, Shane Story,
// and Ping Tak Peter Tang of the Computational Software Lab, Intel Corporation.
//
// WARRANTY DISCLAIMER
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// Intel Corporation is the author of this code, and requests that all
// problem reports or change requests be submitted to it directly at
// http://developer.intel.com/opensource.
//
// History
//==============================================================
// 2/02/00  Initial version
// 2/03/00  Added p12 to definite over/under path. With odd power we did not
//          maintain the sign of x in this path.
// 4/04/00  Unwind support added
// 4/19/00  pow(+-1,inf) now returns NaN
//          pow(+-val, +-inf) returns 0 or inf, but now does not call error support
//          Added s1 to fcvt.fx because invalid flag was incorrectly set.
// 8/15/00  Bundle added after call to __libm_error_support to properly
//          set [the previously overwritten] GR_Parameter_RESULT.
// 9/07/00  Improved performance by eliminating bank conflicts and other stalls,
//          and tweaking the critical path
// 9/08/00  Per c99, pow(+-1,inf) now returns 1, and pow(+1,nan) returns 1
// 9/28/00  Updated NaN**0 path 
// 1/20/01  Fixed denormal flag settings.
// 2/13/01  Improved speed.
// 3/19/01  Reordered exp polynomial to improve speed and eliminate monotonicity
//          problem in round up, down, and to zero modes.  Also corrected 
//          overflow result when x negative, y odd in round up, down, zero.
// 6/14/01  Added brace missing from bundle
// 12/10/01 Corrected case where x negative, 2^52 <= |y| < 2^53, y odd integer.
// 12/20/01 Fixed monotonity problem in round to nearest.
// 02/08/02 Fixed overflow/underflow cases that were not calling error support.
//
// API
//==============================================================
// double pow(double)
// float  powf(float)
//
// Overview of operation
//==============================================================
//
// Three steps...
// 1. Log(x)
// 2. y Log(x)
// 3. exp(y log(x))
// 
// This means we work with the absolute value of x and merge in the sign later.
//      Log(x) = G + delta + r -rsq/2 + p
// G,delta depend on the exponent of x and table entries. The table entries are
// indexed by the exponent of x, called K.
// 
// The G and delta come out of the reduction; r is the reduced x.
// 
// B = frcpa(x)
// xB-1 is small means that B is the approximate inverse of x.
// 
//      Log(x) = Log( (1/B)(Bx) )
//             = Log(1/B) + Log(Bx)
//             = Log(1/B) + Log( 1 + (Bx-1))
// 
//      x  = 2^K 1.x_1x_2.....x_52
//      B= frcpa(x) = 2^-k Cm 
//      Log(1/B) = Log(1/(2^-K Cm))
//      Log(1/B) = Log((2^K/ Cm))
//      Log(1/B) = K Log(2) + Log(1/Cm)
// 
//      Log(x)   = K Log(2) + Log(1/Cm) + Log( 1 + (Bx-1))
// 
// If you take the significand of x, set the exponent to true 0, then Cm is
// the frcpa. We tabulate the Log(1/Cm) values. There are 256 of them.
// The frcpa table is indexed by 8 bits, the x_1 thru x_8.
// m = x_1x_2...x_8 is an 8-bit index.
// 
//      Log(1/Cm) = log(1/frcpa(1+m/256)) where m goes from 0 to 255.
// 
// We tabluate as two doubles, T and t, where T +t is the value itself.
// 
//      Log(x)   = (K Log(2)_hi + T) + (Log(2)_hi + t) + Log( 1 + (Bx-1))
//      Log(x)   =  G + delta           + Log( 1 + (Bx-1))
// 
// The Log( 1 + (Bx-1)) can be calculated as a series in r = Bx-1.
// 
//      Log( 1 + (Bx-1)) = r - rsq/2 + p
// 
// Then,
//    
//      yLog(x) = yG + y delta + y(r-rsq/2) + yp
//      yLog(x) = Z1 + e3      + Z2         + Z3 + (e2 + e3)
// 
// 
//     exp(yLog(x)) = exp(Z1 + Z2 + Z3) exp(e1 + e2 + e3)
//
//
//       exp(Z3) is another series.
//       exp(e1 + e2 + e3) is approximated as f3 = 1 + (e1 + e2 + e3)
//
//       Z1 (128/log2) = number of log2/128 in Z1 is N1
//       Z2 (128/log2) = number of log2/128 in Z2 is N2
//
//       s1 = Z1 - N1 log2/128
//       s2 = Z2 - N2 log2/128
//
//       s = s1 + s2
//       N = N1 + N2
//
//       exp(Z1 + Z2) = exp(Z)
//       exp(Z)       = exp(s) exp(N log2/128)
//
//       exp(r)       = exp(Z - N log2/128)
//
//      r = s + d = (Z - N (log2/128)_hi) -N (log2/128)_lo
//                =  Z - N (log2/128) 
//
//      Z         = s+d +N (log2/128)
//
//      exp(Z)    = exp(s) (1+d) exp(N log2/128)
//
//      N = M 128 + n
//
//      N log2/128 = M log2 + n log2/128
//
//      n is 8 binary digits = n_7n_6...n_1
//
//      n log2/128 = n_7n_6n_5 16 log2/128 + n_4n_3n_2n_1 log2/128
//      n log2/128 = n_7n_6n_5 log2/8 + n_4n_3n_2n_1 log2/128
//      n log2/128 = I2 log2/8 + I1 log2/128
//
//      N log2/128 = M log2 + I2 log2/8 + I1 log2/128 
//
//      exp(Z)    = exp(s) (1+d) exp(log(2^M) + log(2^I2/8) + log(2^I1/128))
//      exp(Z)    = exp(s) (1+d1) (1+d2)(2^M) 2^I2/8 2^I1/128
//      exp(Z)    = exp(s) f1 f2 (2^M) 2^I2/8 2^I1/128
//
// I1, I2 are table indices. Use a series for exp(s).
// Then get exp(Z) 
//
//     exp(yLog(x)) = exp(Z1 + Z2 + Z3) exp(e1 + e2 + e3)
//     exp(yLog(x)) = exp(Z) exp(Z3) f3 
//     exp(yLog(x)) = exp(Z)f3 exp(Z3)  
//     exp(yLog(x)) = A exp(Z3)  
//
// We actually calculate exp(Z3) -1.
// Then, 
//     exp(yLog(x)) = A + A( exp(Z3)   -1)
//

// Table Generation
//==============================================================

// The log values
// ==============
// The operation (K*log2_hi) must be exact. K is the true exponent of x.
// If we allow gradual underflow (denormals), K can be represented in 12 bits
// (as a two's complement number). We assume 13 bits as an engineering precaution.
// 
//           +------------+----------------+-+
//           |  13 bits   | 50 bits        | |
//           +------------+----------------+-+
//           0            1                66
//                        2                34
// 
// So we want the lsb(log2_hi) to be 2^-50
// We get log2 as a quad-extended (15-bit exponent, 128-bit significand)
// 
//      0 fffe b17217f7d1cf79ab c9e3b39803f2f6af (4...)
// 
// Consider numbering the bits left to right, starting at 0 thru 127.
// Bit 0 is the 2^-1 bit; bit 49 is the 2^-50 bit.
// 
//  ...79ab
//     0111 1001 1010 1011
//     44
//     89
// 
// So if we shift off the rightmost 14 bits, then (shift back only 
// the top half) we get
// 
//      0 fffe b17217f7d1cf4000 e6af278ece600fcb dabc000000000000
// 
// Put the right 64-bit signficand in an FR register, convert to double;
// it is exact. Put the next 128 bits into a quad register and round to double.
// The true exponent of the low part is -51.
// 
// hi is 0 fffe b17217f7d1cf4000
// lo is 0 ffcc e6af278ece601000
// 
// Convert to double memory format and get
// 
// hi is 0x3fe62e42fefa39e8
// lo is 0x3cccd5e4f1d9cc02 
// 
// log2_hi + log2_lo is an accurate value for log2.
// 
// 
// The T and t values
// ==================
// A similar method is used to generate the T and t values.
// 
// K * log2_hi + T  must be exact.
// 
// Smallest T,t
// ----------
// The smallest T,t is 
//       T                   t
// data8 0x3f60040155d58800, 0x3c93bce0ce3ddd81  log(1/frcpa(1+0/256))=  +1.95503e-003
// 
// The exponent is 0x3f6 (biased)  or -9 (true).
// For the smallest T value, what we want is to clip the significand such that
// when it is shifted right by 9, its lsb is in the bit for 2^-51. The 9 is the specific 
// for the first entry. In general, it is 0xffff - (biased 15-bit exponent).

// Independently, what we have calculated is the table value as a quad precision number.
// Table entry 1 is
// 0 fff6 80200aaeac44ef38 338f77605fdf8000
// 
// We store this quad precision number in a data structure that is
//    sign:           1 
//    exponent:      15
//    signficand_hi: 64 (includes explicit bit)
//    signficand_lo: 49
// Because the explicit bit is included, the significand is 113 bits.
// 
// Consider significand_hi for table entry 1.
// 
// 
// +-+--- ... -------+--------------------+
// | |
// +-+--- ... -------+--------------------+
// 0 1               4444444455555555556666
//                   2345678901234567890123
// 
// Labeled as above, bit 0 is 2^0, bit 1 is 2^-1, etc.
// Bit 42 is 2^-42. If we shift to the right by 9, the bit in
// bit 42 goes in 51.
// 
// So what we want to do is shift bits 43 thru 63 into significand_lo.
// This is shifting bit 42 into bit 63, taking care to retain the shifted-off bits.
// Then shifting (just with signficaand_hi) back into bit 42. 
//  
// The shift_value is 63-42 = 21. In general, this is 
//      63 - (51 -(0xffff - 0xfff6))
// For this example, it is
//      63 - (51 - 9) = 63 - 42  = 21
// 
// This means we are shifting 21 bits into significand_lo.  We must maintain more
// that a 128-bit signficand not to lose bits. So before the shift we put the 128-bit 
// significand into a 256-bit signficand and then shift.
// The 256-bit significand has four parts: hh, hl, lh, and ll.
// 
// Start off with
//      hh         hl         lh         ll
//      <64>       <49><15_0> <64_0>     <64_0>
// 
// After shift by 21 (then return for significand_hi),
//      <43><21_0> <21><43>   <6><58_0>  <64_0>
// 
// Take the hh part and convert to a double. There is no rounding here.
// The conversion is exact. The true exponent of the high part is the same as the
// true exponent of the input quad.
// 
// We have some 64 plus significand bits for the low part. In this example, we have
// 70 bits. We want to round this to a double. Put them in a quad and then do a quad fnorm.
// For this example the true exponent of the low part is 
//      true_exponent_of_high - 43 = true_exponent_of_high - (64-21)
// In general, this is 
//      true_exponent_of_high - (64 - shift_value)  
// 
// 
// Largest T,t
// ----------
// The largest T,t is
// data8 0x3fe62643fecf9742, 0x3c9e3147684bd37d    log(1/frcpa(1+255/256))=  +6.92171e-001
// 
// Table entry 256 is
// 0 fffe b1321ff67cba178c 51da12f4df5a0000
// 
// The shift value is 
//      63 - (51 -(0xffff - 0xfffe)) = 13
// 
// The true exponent of the low part is 
//      true_exponent_of_high - (64 - shift_value)
//      -1 - (64-13) = -52
// Biased as a double, this is 0x3cb
// 
// 
// 
// So then lsb(T) must be >= 2^-51
// msb(Klog2_hi) <= 2^12
// 
//              +--------+---------+
//              |       51 bits    | <== largest T
//              +--------+---------+
//              | 9 bits | 42 bits | <== smallest T
// +------------+----------------+-+
// |  13 bits   | 50 bits        | |
// +------------+----------------+-+



// Special Cases
//==============================================================

//                                   double     float
// overflow                          error 24   30

// underflow                         error 25   31

// X zero  Y zero
//  +0     +0                 +1     error 26   32
//  -0     +0                 +1     error 26   32
//  +0     -0                 +1     error 26   32
//  -0     -0                 +1     error 26   32

// X zero  Y negative
//  +0     -odd integer       +inf   error 27   33  divide-by-zero
//  -0     -odd integer       -inf   error 27   33  divide-by-zero
//  +0     !-odd integer      +inf   error 27   33  divide-by-zero
//  -0     !-odd integer      +inf   error 27   33  divide-by-zero
//  +0     -inf               +inf   error 27   33  divide-by-zero
//  -0     -inf               +inf   error 27   33  divide-by-zero

// X zero  Y positve
//  +0     +odd integer       +0
//  -0     +odd integer       -0
//  +0     !+odd integer      +0
//  -0     !+odd integer      +0
//  +0     +inf               +0
//  -0     +inf               +0
//  +0     Y NaN              quiet Y               invalid if Y SNaN
//  -0     Y NaN              quiet Y               invalid if Y SNaN

// X one
//  -1     Y inf              +1
//  -1     Y NaN              quiet Y               invalid if Y SNaN
//  +1     Y NaN              +1                    invalid if Y SNaN
//  +1     Y any else         +1

// X -     Y not integer      QNAN   error 28   34  invalid

// X NaN   Y 0                +1     error 29   35
// X NaN   Y NaN              quiet X               invalid if X or Y SNaN
// X NaN   Y any else         quiet X               invalid if X SNaN
// X !+1   Y NaN              quiet Y               invalid if Y SNaN


// X +inf  Y >0               +inf
// X -inf  Y >0, !odd integer +inf
// X -inf  Y >0, odd integer  -inf

// X +inf  Y <0               +0
// X -inf  Y <0, !odd integer +0
// X -inf  Y <0, odd integer  -0

// X +inf  Y =0               +1
// X -inf  Y =0               +1

// |X|<1   Y +inf             +0
// |X|<1   Y -inf             +inf
// |X|>1   Y +inf             +inf
// |X|>1   Y -inf             +0

// X any   Y =0               +1

// Assembly macros
//==============================================================

// integer registers used

pow_AD_Tt                 = r33
pow_GR_FFF7               = r34
pow_GR_exp_Y              = r34 // duplicate
pow_GR_17ones             = r35

pow_AD_P                  = r36
pow_AD_Q                  = r37
pow_AD_tbl1               = r38
pow_AD_tbl2               = r39
pow_GR_exp_X              = r40
pow_GR_true_exp_X         = r40 // duplicate

pow_GR_offset             = r41
pow_GR_exp_Xm1            = r42
pow_GR_sig_X              = r43
pow_GR_signexp_X          = r44
pow_GR_xneg_yodd          = r45

pow_GR_signexp_Xm1        = r46
pow_GR_int_W1             = r47
pow_GR_int_W2             = r48
pow_GR_int_N              = r49
pow_GR_index1             = r50

pow_GR_index2             = r51
pow_AD_T1                 = r52
pow_AD_T2                 = r53
pow_int_GR_M              = r54
pow_GR_10033              = r55

pow_GR_16ones             = r56
pow_GR_sig_int_Y          = r57
pow_GR_sign_Y_Gpr         = r58
pow_GR_17ones_m1          = r59
pow_GR_one                = r60
pow_GR_sign_Y             = r60 

pow_GR_signexp_Y_Gpr      = r61 
pow_GR_exp_Y_Gpr          = r62 
pow_GR_true_exp_Y_Gpr     = r63 
pow_GR_signexp_Y          = r64 
pow_GR_x_one              = r66 
pow_GR_y_zero             = r67 
pow_GR_exp_2toM63         = r68 
pow_GR_big_pos            = r69
pow_GR_big_neg            = r70

GR_SAVE_B0                = r65
GR_SAVE_GP                = r66
GR_SAVE_PFS               = r67

GR_Parameter_X            = r68
GR_Parameter_Y            = r69
GR_Parameter_RESULT       = r70
pow_GR_tag                = r71


// floating point registers used

POW_B                     = f32
POW_NORM_X                = f33
POW_Xm1                   = f34
POW_r1                    = f34
POW_P4                    = f35

POW_P5                    = f36
POW_NORM_Y                = f37
POW_Q2                    = f38
POW_Q3                    = f39
POW_P2                    = f40

POW_P3                    = f41
POW_P0                    = f42
POW_log2_lo               = f43
POW_r                     = f44
POW_Q0_half               = f45

POW_Q1                    = f46  
POW_tmp                   = f47  
POW_log2_hi               = f48
POW_Q4                    = f49
POW_P1                    = f50

POW_log2_by_128_hi        = f51
POW_inv_log2_by_128       = f52
POW_rsq                   = f53
POW_Yrcub                 = f54
POW_log2_by_128_lo        = f55

POW_v6                    = f56
POW_xsq                   = f57
POW_v4                    = f58
POW_v2                    = f59
POW_T                     = f60

POW_Tt                    = f61
POW_RSHF                  = f62
POW_v21ps                 = f63
POW_s4                    = f64
POW_twoV                  = f65

POW_U                     = f66
POW_G                     = f67
POW_delta                 = f68
POW_v3                    = f69
POW_V                     = f70

POW_p                     = f71
POW_Z1                    = f72
POW_e3                    = f73
POW_e2                    = f74
POW_Z2                    = f75

POW_e1                    = f76
POW_W1                    = f77
POW_UmZ2                  = f78
POW_W2                    = f79
POW_Z3                    = f80

POW_int_W1                = f81
POW_e12                   = f82
POW_int_W2                = f83
POW_UmZ2pV                = f84
POW_Z3sq                  = f85

POW_e123                  = f86
POW_N1float               = f87
POW_N2float               = f88
POW_f3                    = f89
POW_q                     = f90

POW_s1                    = f91
POW_Nfloat                = f92
POW_s2                    = f93
POW_f2                    = f94
POW_f1                    = f95

POW_T1                    = f96
POW_T2                    = f97
POW_2M                    = f98
POW_s                     = f99
POW_f12                   = f100

POW_ssq                   = f101
POW_T1T2                  = f102
POW_1ps                   = f103
POW_A                     = f104
POW_es                    = f105

POW_Xp1                   = f106
POW_int_K                 = f107
POW_K                     = f108
POW_f123                  = f109
POW_Gpr                   = f110

POW_Y_Gpr                 = f111 
POW_int_Y                 = f112
POW_abs_q                 = f114
POW_2toM63                = f115

POW_float_int_Y           = f116
POW_ftz_urm_f8            = f117
POW_wre_urm_f8            = f118
POW_big_neg               = f119
POW_big_pos               = f120

// Data tables
//==============================================================

.data

.align 16

pow_table_P:
data8 0x8000F7B249FF332D, 0x0000BFFC  // P_5
data8 0xAAAAAAA9E7902C7F, 0x0000BFFC  // P_3
data8 0x80000000000018E5, 0x0000BFFD  // P_1
data8 0xb8aa3b295c17f0bc, 0x00004006  // inv_ln2_by_128


data8 0x3FA5555555554A9E // Q_2
data8 0x3F8111124F4DD9F9 // Q_3
data8 0x3FE0000000000000 // Q_0
data8 0x3FC5555555554733 // Q_1
data8 0x3F56C16D9360FFA0 // Q_4
data8 0x43e8000000000000 // Right shift constant for exp
data8 0xc9e3b39803f2f6af, 0x00003fb7  // ln2_by_128_lo
data8 0x0000000000000000 // pad to eliminate bank conflicts with pow_table_Q
data8 0x0000000000000000 // pad to eliminate bank conflicts with pow_table_Q

pow_table_Q:
data8 0x9249FE7F0DC423CF, 0x00003FFC  // P_4
data8 0xCCCCCCCC4ED2BA7F, 0x00003FFC  // P_2
data8 0xAAAAAAAAAAAAB505, 0x00003FFD  // P_0
data8 0x3fe62e42fefa39e8, 0x3cccd5e4f1d9cc02 // log2 hi lo =  +6.93147e-001
data8 0xb17217f7d1cf79ab, 0x00003ff7  // ln2_by_128_hi


pow_Tt:
data8 0x3f60040155d58800, 0x3c93bce0ce3ddd81 // log(1/frcpa(1+0/256))=  +1.95503e-003
data8 0x3f78121214586a00, 0x3cb540e0a5cfc9bc // log(1/frcpa(1+1/256))=  +5.87661e-003
data8 0x3f841929f9683200, 0x3cbdf1d57404da1f // log(1/frcpa(1+2/256))=  +9.81362e-003
data8 0x3f8c317384c75f00, 0x3c69806208c04c22 // log(1/frcpa(1+3/256))=  +1.37662e-002
data8 0x3f91a6b91ac73380, 0x3c7874daa716eb32 // log(1/frcpa(1+4/256))=  +1.72376e-002
data8 0x3f95ba9a5d9ac000, 0x3cacbb84e08d78ac // log(1/frcpa(1+5/256))=  +2.12196e-002
data8 0x3f99d2a807432580, 0x3cbcf80538b441e1 // log(1/frcpa(1+6/256))=  +2.52177e-002
data8 0x3f9d6b2725979800, 0x3c6095e5c8f8f359 // log(1/frcpa(1+7/256))=  +2.87291e-002
data8 0x3fa0c58fa19dfa80, 0x3cb4c5d4e9d0dda2 // log(1/frcpa(1+8/256))=  +3.27573e-002
data8 0x3fa2954c78cbce00, 0x3caa932b860ab8d6 // log(1/frcpa(1+9/256))=  +3.62953e-002
data8 0x3fa4a94d2da96c40, 0x3ca670452b76bbd5 // log(1/frcpa(1+10/256))=  +4.03542e-002
data8 0x3fa67c94f2d4bb40, 0x3ca84104f9941798 // log(1/frcpa(1+11/256))=  +4.39192e-002
data8 0x3fa85188b630f040, 0x3cb40a882cbf0153 // log(1/frcpa(1+12/256))=  +4.74971e-002
data8 0x3faa6b8abe73af40, 0x3c988d46e25c9059 // log(1/frcpa(1+13/256))=  +5.16017e-002
data8 0x3fac441e06f72a80, 0x3cae3e930a1a2a96 // log(1/frcpa(1+14/256))=  +5.52072e-002
data8 0x3fae1e6713606d00, 0x3c8a796f6283b580 // log(1/frcpa(1+15/256))=  +5.88257e-002
data8 0x3faffa6911ab9300, 0x3c5193070351e88a // log(1/frcpa(1+16/256))=  +6.24574e-002
data8 0x3fb0ec139c5da600, 0x3c623f2a75eb992d // log(1/frcpa(1+17/256))=  +6.61022e-002
data8 0x3fb1dbd2643d1900, 0x3ca649b2ef8927f0 // log(1/frcpa(1+18/256))=  +6.97605e-002
data8 0x3fb2cc7284fe5f00, 0x3cbc5e86599513e2 // log(1/frcpa(1+19/256))=  +7.34321e-002
data8 0x3fb3bdf5a7d1ee60, 0x3c90bd4bb69dada3 // log(1/frcpa(1+20/256))=  +7.71173e-002
data8 0x3fb4b05d7aa012e0, 0x3c54e377c9b8a54f // log(1/frcpa(1+21/256))=  +8.08161e-002
data8 0x3fb580db7ceb5700, 0x3c7fdb2f98354cde // log(1/frcpa(1+22/256))=  +8.39975e-002
data8 0x3fb674f089365a60, 0x3cb9994c9d3301c1 // log(1/frcpa(1+23/256))=  +8.77219e-002
data8 0x3fb769ef2c6b5680, 0x3caaec639db52a79 // log(1/frcpa(1+24/256))=  +9.14602e-002
data8 0x3fb85fd927506a40, 0x3c9f9f99a3cf8e25 // log(1/frcpa(1+25/256))=  +9.52125e-002
data8 0x3fb9335e5d594980, 0x3ca15c3abd47d99a // log(1/frcpa(1+26/256))=  +9.84401e-002
data8 0x3fba2b0220c8e5e0, 0x3cb4ca639adf6fc3 // log(1/frcpa(1+27/256))=  +1.02219e-001
data8 0x3fbb0004ac1a86a0, 0x3ca7cb81bf959a59 // log(1/frcpa(1+28/256))=  +1.05469e-001
data8 0x3fbbf968769fca00, 0x3cb0c646c121418e // log(1/frcpa(1+29/256))=  +1.09274e-001
data8 0x3fbccfedbfee13a0, 0x3ca0465fce24ab4b // log(1/frcpa(1+30/256))=  +1.12548e-001
data8 0x3fbda727638446a0, 0x3c82803f4e2e6603 // log(1/frcpa(1+31/256))=  +1.15832e-001
data8 0x3fbea3257fe10f60, 0x3cb986a3f2313d1a // log(1/frcpa(1+32/256))=  +1.19677e-001
data8 0x3fbf7be9fedbfde0, 0x3c97d16a6a621cf4 // log(1/frcpa(1+33/256))=  +1.22985e-001
data8 0x3fc02ab352ff25f0, 0x3c9cc6baad365600 // log(1/frcpa(1+34/256))=  +1.26303e-001
data8 0x3fc097ce579d2040, 0x3cb9ba16d329440b // log(1/frcpa(1+35/256))=  +1.29633e-001
data8 0x3fc1178e8227e470, 0x3cb7bc671683f8e6 // log(1/frcpa(1+36/256))=  +1.33531e-001
data8 0x3fc185747dbecf30, 0x3c9d1116f66d2345 // log(1/frcpa(1+37/256))=  +1.36885e-001
data8 0x3fc1f3b925f25d40, 0x3c8162c9ef939ac6 // log(1/frcpa(1+38/256))=  +1.40250e-001
data8 0x3fc2625d1e6ddf50, 0x3caad3a1ec384fc3 // log(1/frcpa(1+39/256))=  +1.43627e-001
data8 0x3fc2d1610c868130, 0x3cb3ad997036941b // log(1/frcpa(1+40/256))=  +1.47015e-001
data8 0x3fc340c597411420, 0x3cbc2308262c7998 // log(1/frcpa(1+41/256))=  +1.50414e-001
data8 0x3fc3b08b6757f2a0, 0x3cb2170d6cdf0526 // log(1/frcpa(1+42/256))=  +1.53825e-001
data8 0x3fc40dfb08378000, 0x3c9bb453c4f7b685 // log(1/frcpa(1+43/256))=  +1.56677e-001
data8 0x3fc47e74e8ca5f70, 0x3cb836a48fdfce9d // log(1/frcpa(1+44/256))=  +1.60109e-001
data8 0x3fc4ef51f6466de0, 0x3ca07a43919aa64b // log(1/frcpa(1+45/256))=  +1.63553e-001
data8 0x3fc56092e02ba510, 0x3ca85006899d97b0 // log(1/frcpa(1+46/256))=  +1.67010e-001
data8 0x3fc5d23857cd74d0, 0x3ca30a5ba6e7abbe // log(1/frcpa(1+47/256))=  +1.70478e-001
data8 0x3fc6313a37335d70, 0x3ca905586f0ac97e // log(1/frcpa(1+48/256))=  +1.73377e-001
data8 0x3fc6a399dabbd380, 0x3c9b2c6657a96684 // log(1/frcpa(1+49/256))=  +1.76868e-001
data8 0x3fc70337dd3ce410, 0x3cb50bc52f55cdd8 // log(1/frcpa(1+50/256))=  +1.79786e-001
data8 0x3fc77654128f6120, 0x3cad2eb7c9a39efe // log(1/frcpa(1+51/256))=  +1.83299e-001
data8 0x3fc7e9d82a0b0220, 0x3cba127e90393c01 // log(1/frcpa(1+52/256))=  +1.86824e-001
data8 0x3fc84a6b759f5120, 0x3cbd7fd52079f706 // log(1/frcpa(1+53/256))=  +1.89771e-001
data8 0x3fc8ab47d5f5a300, 0x3cbfae141751a3de // log(1/frcpa(1+54/256))=  +1.92727e-001
data8 0x3fc91fe490965810, 0x3cb69cf30a1c319e // log(1/frcpa(1+55/256))=  +1.96286e-001
data8 0x3fc981634011aa70, 0x3ca5bb3d208bc42a // log(1/frcpa(1+56/256))=  +1.99261e-001
data8 0x3fc9f6c407089660, 0x3ca04d68658179a0 // log(1/frcpa(1+57/256))=  +2.02843e-001
data8 0x3fca58e729348f40, 0x3c99f5411546c286 // log(1/frcpa(1+58/256))=  +2.05838e-001
data8 0x3fcabb55c31693a0, 0x3cb9a5350eb327d5 // log(1/frcpa(1+59/256))=  +2.08842e-001
data8 0x3fcb1e104919efd0, 0x3c18965fcce7c406 // log(1/frcpa(1+60/256))=  +2.11855e-001
data8 0x3fcb94ee93e367c0, 0x3cb503716da45184 // log(1/frcpa(1+61/256))=  +2.15483e-001
data8 0x3fcbf851c0675550, 0x3cbdf1b3f7ab5378 // log(1/frcpa(1+62/256))=  +2.18516e-001
data8 0x3fcc5c0254bf23a0, 0x3ca7aab9ed0b1d7b // log(1/frcpa(1+63/256))=  +2.21558e-001
data8 0x3fccc000c9db3c50, 0x3c92a7a2a850072a // log(1/frcpa(1+64/256))=  +2.24609e-001
data8 0x3fcd244d99c85670, 0x3c9f6019120edf4c // log(1/frcpa(1+65/256))=  +2.27670e-001
data8 0x3fcd88e93fb2f450, 0x3c6affb96815e081 // log(1/frcpa(1+66/256))=  +2.30741e-001
data8 0x3fcdedd437eaef00, 0x3c72553595897976 // log(1/frcpa(1+67/256))=  +2.33820e-001
data8 0x3fce530effe71010, 0x3c90913b020fa182 // log(1/frcpa(1+68/256))=  +2.36910e-001
data8 0x3fceb89a1648b970, 0x3c837ba4045bfd25 // log(1/frcpa(1+69/256))=  +2.40009e-001
data8 0x3fcf1e75fadf9bd0, 0x3cbcea6d13e0498d // log(1/frcpa(1+70/256))=  +2.43117e-001
data8 0x3fcf84a32ead7c30, 0x3ca5e3a67b3c6d77 // log(1/frcpa(1+71/256))=  +2.46235e-001
data8 0x3fcfeb2233ea07c0, 0x3cba0c6f0049c5a6 // log(1/frcpa(1+72/256))=  +2.49363e-001
data8 0x3fd028f9c7035c18, 0x3cb0a30b06677ff6 // log(1/frcpa(1+73/256))=  +2.52501e-001
data8 0x3fd05c8be0d96358, 0x3ca0f1c77ccb5865 // log(1/frcpa(1+74/256))=  +2.55649e-001
data8 0x3fd085eb8f8ae790, 0x3cbd513f45fe7a97 // log(1/frcpa(1+75/256))=  +2.58174e-001
data8 0x3fd0b9c8e32d1910, 0x3c927449047ca006 // log(1/frcpa(1+76/256))=  +2.61339e-001
data8 0x3fd0edd060b78080, 0x3c89b52d8435f53e // log(1/frcpa(1+77/256))=  +2.64515e-001
data8 0x3fd122024cf00638, 0x3cbdd976fabda4bd // log(1/frcpa(1+78/256))=  +2.67701e-001
data8 0x3fd14be2927aecd0, 0x3cb02f90ad0bc471 // log(1/frcpa(1+79/256))=  +2.70257e-001
data8 0x3fd180618ef18ad8, 0x3cbd003792c71a98 // log(1/frcpa(1+80/256))=  +2.73461e-001
data8 0x3fd1b50bbe2fc638, 0x3ca9ae64c6403ead // log(1/frcpa(1+81/256))=  +2.76675e-001
data8 0x3fd1df4cc7cf2428, 0x3cb43f0455f7e395 // log(1/frcpa(1+82/256))=  +2.79254e-001
data8 0x3fd214456d0eb8d0, 0x3cb0fbd748d75d30 // log(1/frcpa(1+83/256))=  +2.82487e-001
data8 0x3fd23ec5991eba48, 0x3c906edd746b77e2 // log(1/frcpa(1+84/256))=  +2.85081e-001
data8 0x3fd2740d9f870af8, 0x3ca9802e6a00a670 // log(1/frcpa(1+85/256))=  +2.88333e-001
data8 0x3fd29ecdabcdfa00, 0x3cacecef70890cfa // log(1/frcpa(1+86/256))=  +2.90943e-001
data8 0x3fd2d46602adcce8, 0x3cb97911955f3521 // log(1/frcpa(1+87/256))=  +2.94214e-001
data8 0x3fd2ff66b04ea9d0, 0x3cb12dabe191d1c9 // log(1/frcpa(1+88/256))=  +2.96838e-001
data8 0x3fd335504b355a30, 0x3cbdf9139df924ec // log(1/frcpa(1+89/256))=  +3.00129e-001
data8 0x3fd360925ec44f58, 0x3cb253e68977a1e3 // log(1/frcpa(1+90/256))=  +3.02769e-001
data8 0x3fd38bf1c3337e70, 0x3cb3d283d2a2da21 // log(1/frcpa(1+91/256))=  +3.05417e-001
data8 0x3fd3c25277333180, 0x3cadaa5b035eae27 // log(1/frcpa(1+92/256))=  +3.08735e-001
data8 0x3fd3edf463c16838, 0x3cb983d680d3c108 // log(1/frcpa(1+93/256))=  +3.11399e-001
data8 0x3fd419b423d5e8c0, 0x3cbc86dd921c139d // log(1/frcpa(1+94/256))=  +3.14069e-001
data8 0x3fd44591e0539f48, 0x3c86a76d6dc2782e // log(1/frcpa(1+95/256))=  +3.16746e-001
data8 0x3fd47c9175b6f0a8, 0x3cb59a2e013c6b5f // log(1/frcpa(1+96/256))=  +3.20103e-001
data8 0x3fd4a8b341552b08, 0x3c93f1e86e468694 // log(1/frcpa(1+97/256))=  +3.22797e-001
data8 0x3fd4d4f390890198, 0x3cbf5e4ea7c5105a // log(1/frcpa(1+98/256))=  +3.25498e-001
data8 0x3fd501528da1f960, 0x3cbf58da53e9ad10 // log(1/frcpa(1+99/256))=  +3.28206e-001
data8 0x3fd52dd06347d4f0, 0x3cb98a28cebf6eef // log(1/frcpa(1+100/256))=  +3.30921e-001
data8 0x3fd55a6d3c7b8a88, 0x3c9c76b67c2d1fd4 // log(1/frcpa(1+101/256))=  +3.33644e-001
data8 0x3fd5925d2b112a58, 0x3c9029616a4331b8 // log(1/frcpa(1+102/256))=  +3.37058e-001
data8 0x3fd5bf406b543db0, 0x3c9fb8292ecfc820 // log(1/frcpa(1+103/256))=  +3.39798e-001
data8 0x3fd5ec433d5c35a8, 0x3cb71a1229d17eec // log(1/frcpa(1+104/256))=  +3.42545e-001
data8 0x3fd61965cdb02c18, 0x3cbba94fe1dbb8d2 // log(1/frcpa(1+105/256))=  +3.45300e-001
data8 0x3fd646a84935b2a0, 0x3c9ee496d2c9ae57 // log(1/frcpa(1+106/256))=  +3.48063e-001
data8 0x3fd6740add31de90, 0x3cb1da3a6c7a9dfd // log(1/frcpa(1+107/256))=  +3.50833e-001
data8 0x3fd6a18db74a58c0, 0x3cb494c257add8dc // log(1/frcpa(1+108/256))=  +3.53610e-001
data8 0x3fd6cf31058670e8, 0x3cb0b244a70a8da9 // log(1/frcpa(1+109/256))=  +3.56396e-001
data8 0x3fd6f180e852f0b8, 0x3c9db7aefa866720 // log(1/frcpa(1+110/256))=  +3.58490e-001
data8 0x3fd71f5d71b894e8, 0x3cbe91c4bf324957 // log(1/frcpa(1+111/256))=  +3.61289e-001
data8 0x3fd74d5aefd66d58, 0x3cb06b3d9bfac023 // log(1/frcpa(1+112/256))=  +3.64096e-001
data8 0x3fd77b79922bd378, 0x3cb727d8804491f4 // log(1/frcpa(1+113/256))=  +3.66911e-001
data8 0x3fd7a9b9889f19e0, 0x3ca2ef22df5bc543 // log(1/frcpa(1+114/256))=  +3.69734e-001
data8 0x3fd7d81b037eb6a0, 0x3cb8fd3ba07a7ece // log(1/frcpa(1+115/256))=  +3.72565e-001
data8 0x3fd8069e33827230, 0x3c8bd1e25866e61a // log(1/frcpa(1+116/256))=  +3.75404e-001
data8 0x3fd82996d3ef8bc8, 0x3ca5aab9f5928928 // log(1/frcpa(1+117/256))=  +3.77538e-001
data8 0x3fd85855776dcbf8, 0x3ca56f33337789d6 // log(1/frcpa(1+118/256))=  +3.80391e-001
data8 0x3fd8873658327cc8, 0x3cbb8ef0401db49d // log(1/frcpa(1+119/256))=  +3.83253e-001
data8 0x3fd8aa75973ab8c8, 0x3cbb9961f509a680 // log(1/frcpa(1+120/256))=  +3.85404e-001
data8 0x3fd8d992dc8824e0, 0x3cb220512a53732d // log(1/frcpa(1+121/256))=  +3.88280e-001
data8 0x3fd908d2ea7d9510, 0x3c985f0e513bfb5c // log(1/frcpa(1+122/256))=  +3.91164e-001
data8 0x3fd92c59e79c0e50, 0x3cb82e073fd30d63 // log(1/frcpa(1+123/256))=  +3.93332e-001
data8 0x3fd95bd750ee3ed0, 0x3ca4aa7cdb6dd8a8 // log(1/frcpa(1+124/256))=  +3.96231e-001
data8 0x3fd98b7811a3ee58, 0x3caa93a5b660893e // log(1/frcpa(1+125/256))=  +3.99138e-001
data8 0x3fd9af47f33d4068, 0x3cac294b3b3190ba // log(1/frcpa(1+126/256))=  +4.01323e-001
data8 0x3fd9df270c1914a0, 0x3cbe1a58fd0cd67e // log(1/frcpa(1+127/256))=  +4.04245e-001
data8 0x3fda0325ed14fda0, 0x3cb1efa7950fb57e // log(1/frcpa(1+128/256))=  +4.06442e-001
data8 0x3fda33440224fa78, 0x3c8915fe75e7d477 // log(1/frcpa(1+129/256))=  +4.09379e-001
data8 0x3fda57725e80c380, 0x3ca72bd1062b1b7f // log(1/frcpa(1+130/256))=  +4.11587e-001
data8 0x3fda87d0165dd198, 0x3c91f7845f58dbad // log(1/frcpa(1+131/256))=  +4.14539e-001
data8 0x3fdaac2e6c03f890, 0x3cb6f237a911c509 // log(1/frcpa(1+132/256))=  +4.16759e-001
data8 0x3fdadccc6fdf6a80, 0x3c90ddc4b7687169 // log(1/frcpa(1+133/256))=  +4.19726e-001
data8 0x3fdb015b3eb1e790, 0x3c692dd7d90e1e8e // log(1/frcpa(1+134/256))=  +4.21958e-001
data8 0x3fdb323a3a635948, 0x3c6f85655cbe14de // log(1/frcpa(1+135/256))=  +4.24941e-001
data8 0x3fdb56fa04462908, 0x3c95252d841994de // log(1/frcpa(1+136/256))=  +4.27184e-001
data8 0x3fdb881aa659bc90, 0x3caa53a745a3642f // log(1/frcpa(1+137/256))=  +4.30182e-001
data8 0x3fdbad0bef3db160, 0x3cb32f2540dcc16a // log(1/frcpa(1+138/256))=  +4.32437e-001
data8 0x3fdbd21297781c28, 0x3cbd8e891e106f1d // log(1/frcpa(1+139/256))=  +4.34697e-001
data8 0x3fdc039236f08818, 0x3c809435af522ba7 // log(1/frcpa(1+140/256))=  +4.37718e-001
data8 0x3fdc28cb1e4d32f8, 0x3cb3944752fbd81e // log(1/frcpa(1+141/256))=  +4.39990e-001
data8 0x3fdc4e19b84723c0, 0x3c9a465260cd3fe5 // log(1/frcpa(1+142/256))=  +4.42267e-001
data8 0x3fdc7ff9c74554c8, 0x3c92447d5b6ca369 // log(1/frcpa(1+143/256))=  +4.45311e-001
data8 0x3fdca57b64e9db00, 0x3cb44344a8a00c82 // log(1/frcpa(1+144/256))=  +4.47600e-001
data8 0x3fdccb130a5ceba8, 0x3cbefaddfb97b73f // log(1/frcpa(1+145/256))=  +4.49895e-001
data8 0x3fdcf0c0d18f3268, 0x3cbd3e7bfee57898 // log(1/frcpa(1+146/256))=  +4.52194e-001
data8 0x3fdd232075b5a200, 0x3c9222599987447c // log(1/frcpa(1+147/256))=  +4.55269e-001
data8 0x3fdd490246defa68, 0x3cabafe9a767a80d // log(1/frcpa(1+148/256))=  +4.57581e-001
data8 0x3fdd6efa918d25c8, 0x3cb58a2624e1c6fd // log(1/frcpa(1+149/256))=  +4.59899e-001
data8 0x3fdd9509707ae528, 0x3cbdc3babce578e7 // log(1/frcpa(1+150/256))=  +4.62221e-001
data8 0x3fddbb2efe92c550, 0x3cb0ac0943c434a4 // log(1/frcpa(1+151/256))=  +4.64550e-001
data8 0x3fddee2f3445e4a8, 0x3cbba9d07ce820e8 // log(1/frcpa(1+152/256))=  +4.67663e-001
data8 0x3fde148a1a2726c8, 0x3cb6537e3375b205 // log(1/frcpa(1+153/256))=  +4.70004e-001
data8 0x3fde3afc0a49ff38, 0x3cbfed5518dbc20e // log(1/frcpa(1+154/256))=  +4.72350e-001
data8 0x3fde6185206d5168, 0x3cb6572601f73d5c // log(1/frcpa(1+155/256))=  +4.74702e-001
data8 0x3fde882578823d50, 0x3c9b24abd4584d1a // log(1/frcpa(1+156/256))=  +4.77060e-001
data8 0x3fdeaedd2eac9908, 0x3cb0ceb5e4d2c8f7 // log(1/frcpa(1+157/256))=  +4.79423e-001
data8 0x3fded5ac5f436be0, 0x3ca72f21f1f5238e // log(1/frcpa(1+158/256))=  +4.81792e-001
data8 0x3fdefc9326d16ab8, 0x3c85081a1639a45c // log(1/frcpa(1+159/256))=  +4.84166e-001
data8 0x3fdf2391a21575f8, 0x3cbf11015bdd297a // log(1/frcpa(1+160/256))=  +4.86546e-001
data8 0x3fdf4aa7ee031928, 0x3cb3795bc052a2d1 // log(1/frcpa(1+161/256))=  +4.88932e-001
data8 0x3fdf71d627c30bb0, 0x3c35c61f0f5a88f3 // log(1/frcpa(1+162/256))=  +4.91323e-001
data8 0x3fdf991c6cb3b378, 0x3c97d99419be6028 // log(1/frcpa(1+163/256))=  +4.93720e-001
data8 0x3fdfc07ada69a908, 0x3cbfe9341ded70b1 // log(1/frcpa(1+164/256))=  +4.96123e-001
data8 0x3fdfe7f18eb03d38, 0x3cb85718a640c33f // log(1/frcpa(1+165/256))=  +4.98532e-001
data8 0x3fe007c053c5002c, 0x3cb3addc9c065f09 // log(1/frcpa(1+166/256))=  +5.00946e-001
data8 0x3fe01b942198a5a0, 0x3c9d5aa4c77da6ac // log(1/frcpa(1+167/256))=  +5.03367e-001
data8 0x3fe02f74400c64e8, 0x3cb5a0ee4450ef52 // log(1/frcpa(1+168/256))=  +5.05793e-001
data8 0x3fe04360be7603ac, 0x3c9dd00c35630fe0 // log(1/frcpa(1+169/256))=  +5.08225e-001
data8 0x3fe05759ac47fe30, 0x3cbd063e1f0bd82c // log(1/frcpa(1+170/256))=  +5.10663e-001
data8 0x3fe06b5f1911cf50, 0x3cae8da674af5289 // log(1/frcpa(1+171/256))=  +5.13107e-001
data8 0x3fe078bf0533c568, 0x3c62241edf5fd1f7 // log(1/frcpa(1+172/256))=  +5.14740e-001
data8 0x3fe08cd9687e7b0c, 0x3cb3007febcca227 // log(1/frcpa(1+173/256))=  +5.17194e-001
data8 0x3fe0a10074cf9018, 0x3ca496e84603816b // log(1/frcpa(1+174/256))=  +5.19654e-001
data8 0x3fe0b5343a234474, 0x3cb46098d14fc90a // log(1/frcpa(1+175/256))=  +5.22120e-001
data8 0x3fe0c974c89431cc, 0x3cac0a7cdcbb86c6 // log(1/frcpa(1+176/256))=  +5.24592e-001
data8 0x3fe0ddc2305b9884, 0x3cb2f753210410ff // log(1/frcpa(1+177/256))=  +5.27070e-001
data8 0x3fe0eb524bafc918, 0x3c88affd6682229e // log(1/frcpa(1+178/256))=  +5.28726e-001
data8 0x3fe0ffb54213a474, 0x3cadeefbab9af993 // log(1/frcpa(1+179/256))=  +5.31214e-001
data8 0x3fe114253da97d9c, 0x3cbaf1c2b8bc160a // log(1/frcpa(1+180/256))=  +5.33709e-001
data8 0x3fe128a24f1d9afc, 0x3cb9cf4df375e650 // log(1/frcpa(1+181/256))=  +5.36210e-001
data8 0x3fe1365252bf0864, 0x3c985a621d4be111 // log(1/frcpa(1+182/256))=  +5.37881e-001
data8 0x3fe14ae558b4a92c, 0x3ca104c4aa8977d1 // log(1/frcpa(1+183/256))=  +5.40393e-001
data8 0x3fe15f85a19c7658, 0x3cbadf26e540f375 // log(1/frcpa(1+184/256))=  +5.42910e-001
data8 0x3fe16d4d38c119f8, 0x3cb3aea11caec416 // log(1/frcpa(1+185/256))=  +5.44592e-001
data8 0x3fe18203c20dd130, 0x3cba82d1211d1d6d // log(1/frcpa(1+186/256))=  +5.47121e-001
data8 0x3fe196c7bc4b1f38, 0x3cb6267acc4f4f4a // log(1/frcpa(1+187/256))=  +5.49656e-001
data8 0x3fe1a4a738b7a33c, 0x3c858930213c987d // log(1/frcpa(1+188/256))=  +5.51349e-001
data8 0x3fe1b981c0c9653c, 0x3c9bc2a4a30f697b // log(1/frcpa(1+189/256))=  +5.53895e-001
data8 0x3fe1ce69e8bb1068, 0x3cb7ae6199cf2a00 // log(1/frcpa(1+190/256))=  +5.56447e-001
data8 0x3fe1dc619de06944, 0x3c6b50bb38388177 // log(1/frcpa(1+191/256))=  +5.58152e-001
data8 0x3fe1f160a2ad0da0, 0x3cbd05b2778a5e1d // log(1/frcpa(1+192/256))=  +5.60715e-001
data8 0x3fe2066d7740737c, 0x3cb32e828f9c6bd6 // log(1/frcpa(1+193/256))=  +5.63285e-001
data8 0x3fe2147dba47a390, 0x3cbd579851b8b672 // log(1/frcpa(1+194/256))=  +5.65001e-001
data8 0x3fe229a1bc5ebac0, 0x3cbb321be5237ce8 // log(1/frcpa(1+195/256))=  +5.67582e-001
data8 0x3fe237c1841a502c, 0x3cb3b56e0915ea64 // log(1/frcpa(1+196/256))=  +5.69306e-001
data8 0x3fe24cfce6f80d98, 0x3cb34a4d1a422919 // log(1/frcpa(1+197/256))=  +5.71898e-001
data8 0x3fe25b2c55cd5760, 0x3cb237401ea5015e // log(1/frcpa(1+198/256))=  +5.73630e-001
data8 0x3fe2707f4d5f7c40, 0x3c9d30f20acc8341 // log(1/frcpa(1+199/256))=  +5.76233e-001
data8 0x3fe285e0842ca380, 0x3cbc4d866d5f21c0 // log(1/frcpa(1+200/256))=  +5.78842e-001
data8 0x3fe294294708b770, 0x3cb85e14d5dc54fa // log(1/frcpa(1+201/256))=  +5.80586e-001
data8 0x3fe2a9a2670aff0c, 0x3c7e6f8f468bbf91 // log(1/frcpa(1+202/256))=  +5.83207e-001
data8 0x3fe2b7fb2c8d1cc0, 0x3c930ffcf63c8b65 // log(1/frcpa(1+203/256))=  +5.84959e-001
data8 0x3fe2c65a6395f5f4, 0x3ca0afe20b53d2d2 // log(1/frcpa(1+204/256))=  +5.86713e-001
data8 0x3fe2dbf557b0df40, 0x3cb646be1188fbc9 // log(1/frcpa(1+205/256))=  +5.89350e-001
data8 0x3fe2ea64c3f97654, 0x3c96516fa8df33b2 // log(1/frcpa(1+206/256))=  +5.91113e-001
data8 0x3fe3001823684d70, 0x3cb96d64e16d1360 // log(1/frcpa(1+207/256))=  +5.93762e-001
data8 0x3fe30e97e9a8b5cc, 0x3c98ef96bc97cca0 // log(1/frcpa(1+208/256))=  +5.95531e-001
data8 0x3fe32463ebdd34e8, 0x3caef1dc9a56c1bf // log(1/frcpa(1+209/256))=  +5.98192e-001
data8 0x3fe332f4314ad794, 0x3caa4f0ac5d5fa11 // log(1/frcpa(1+210/256))=  +5.99970e-001
data8 0x3fe348d90e7464cc, 0x3cbe7889f0516acd // log(1/frcpa(1+211/256))=  +6.02643e-001
data8 0x3fe35779f8c43d6c, 0x3ca96bbab7245411 // log(1/frcpa(1+212/256))=  +6.04428e-001
data8 0x3fe36621961a6a98, 0x3ca31f32262db9fb // log(1/frcpa(1+213/256))=  +6.06217e-001
data8 0x3fe37c299f3c3668, 0x3cb15c72c107ee29 // log(1/frcpa(1+214/256))=  +6.08907e-001
data8 0x3fe38ae2171976e4, 0x3cba42a2554b2dd4 // log(1/frcpa(1+215/256))=  +6.10704e-001
data8 0x3fe399a157a603e4, 0x3cb99c62286d8919 // log(1/frcpa(1+216/256))=  +6.12504e-001
data8 0x3fe3afccfe77b9d0, 0x3ca11048f96a43bd // log(1/frcpa(1+217/256))=  +6.15210e-001
data8 0x3fe3be9d503533b4, 0x3ca4022f47588c3e // log(1/frcpa(1+218/256))=  +6.17018e-001
data8 0x3fe3cd7480b4a8a0, 0x3cb4ba7afc2dc56a // log(1/frcpa(1+219/256))=  +6.18830e-001
data8 0x3fe3e3c43918f76c, 0x3c859673d064b8ba // log(1/frcpa(1+220/256))=  +6.21554e-001
data8 0x3fe3f2acb27ed6c4, 0x3cb55c6b452a16a8 // log(1/frcpa(1+221/256))=  +6.23373e-001
data8 0x3fe4019c2125ca90, 0x3cb8c367879c5a31 // log(1/frcpa(1+222/256))=  +6.25197e-001
data8 0x3fe4181061389720, 0x3cb2c17a79c5cc6c // log(1/frcpa(1+223/256))=  +6.27937e-001
data8 0x3fe42711518df544, 0x3ca5f38d47012fc5 // log(1/frcpa(1+224/256))=  +6.29769e-001
data8 0x3fe436194e12b6bc, 0x3cb9854d65a9b426 // log(1/frcpa(1+225/256))=  +6.31604e-001
data8 0x3fe445285d68ea68, 0x3ca3ff9b3a81cd81 // log(1/frcpa(1+226/256))=  +6.33442e-001
data8 0x3fe45bcc464c8938, 0x3cb0a2d8011a6c05 // log(1/frcpa(1+227/256))=  +6.36206e-001
data8 0x3fe46aed21f117fc, 0x3c8a2be41f8e9f3d // log(1/frcpa(1+228/256))=  +6.38053e-001
data8 0x3fe47a1527e8a2d0, 0x3cba4a83594fab09 // log(1/frcpa(1+229/256))=  +6.39903e-001
data8 0x3fe489445efffcc8, 0x3cbf306a23dcbcde // log(1/frcpa(1+230/256))=  +6.41756e-001
data8 0x3fe4a018bcb69834, 0x3ca46c9285029fd1 // log(1/frcpa(1+231/256))=  +6.44543e-001
data8 0x3fe4af5a0c9d65d4, 0x3cbbc1db897580e3 // log(1/frcpa(1+232/256))=  +6.46405e-001
data8 0x3fe4bea2a5bdbe84, 0x3cb84d880d7ef775 // log(1/frcpa(1+233/256))=  +6.48271e-001
data8 0x3fe4cdf28f10ac44, 0x3cb3ec4b7893ce1f // log(1/frcpa(1+234/256))=  +6.50140e-001
data8 0x3fe4dd49cf994058, 0x3c897224d59d3408 // log(1/frcpa(1+235/256))=  +6.52013e-001
data8 0x3fe4eca86e64a680, 0x3cbccf620f24f0cd // log(1/frcpa(1+236/256))=  +6.53889e-001
data8 0x3fe503c43cd8eb68, 0x3c3f872c65971084 // log(1/frcpa(1+237/256))=  +6.56710e-001
data8 0x3fe513356667fc54, 0x3cb9ca64cc3d52c8 // log(1/frcpa(1+238/256))=  +6.58595e-001
data8 0x3fe522ae0738a3d4, 0x3cbe708164c75968 // log(1/frcpa(1+239/256))=  +6.60483e-001
data8 0x3fe5322e26867854, 0x3cb9988ba4aea615 // log(1/frcpa(1+240/256))=  +6.62376e-001
data8 0x3fe541b5cb979808, 0x3ca1662e3a6b95f5 // log(1/frcpa(1+241/256))=  +6.64271e-001
data8 0x3fe55144fdbcbd60, 0x3cb3acd4ca45c1e0 // log(1/frcpa(1+242/256))=  +6.66171e-001
data8 0x3fe560dbc45153c4, 0x3cb4988947959fed // log(1/frcpa(1+243/256))=  +6.68074e-001
data8 0x3fe5707a26bb8c64, 0x3cb3017fe6607ba9 // log(1/frcpa(1+244/256))=  +6.69980e-001
data8 0x3fe587f60ed5b8fc, 0x3cbe7a3266366ed4 // log(1/frcpa(1+245/256))=  +6.72847e-001
data8 0x3fe597a7977c8f30, 0x3ca1e12b9959a90e // log(1/frcpa(1+246/256))=  +6.74763e-001
data8 0x3fe5a760d634bb88, 0x3cb7c365e53d9602 // log(1/frcpa(1+247/256))=  +6.76682e-001
data8 0x3fe5b721d295f10c, 0x3cb716c2551ccbf0 // log(1/frcpa(1+248/256))=  +6.78605e-001
data8 0x3fe5c6ea94431ef8, 0x3ca02b2ed0e28261 // log(1/frcpa(1+249/256))=  +6.80532e-001
data8 0x3fe5d6bb22ea86f4, 0x3caf43a8bbb2f974 // log(1/frcpa(1+250/256))=  +6.82462e-001
data8 0x3fe5e6938645d38c, 0x3cbcedc98821b333 // log(1/frcpa(1+251/256))=  +6.84397e-001
data8 0x3fe5f673c61a2ed0, 0x3caa385eef5f2789 // log(1/frcpa(1+252/256))=  +6.86335e-001
data8 0x3fe6065bea385924, 0x3cb11624f165c5b4 // log(1/frcpa(1+253/256))=  +6.88276e-001
data8 0x3fe6164bfa7cc068, 0x3cbad884f87073fa // log(1/frcpa(1+254/256))=  +6.90222e-001
data8 0x3fe62643fecf9740, 0x3cb78c51da12f4df // log(1/frcpa(1+255/256))=  +6.92171e-001


// Table 1 is 2^(index_1/128) where
// index_1 goes from 0 to 15
pow_tbl1:
data8 0x8000000000000000 , 0x00003FFF
data8 0x80B1ED4FD999AB6C , 0x00003FFF
data8 0x8164D1F3BC030773 , 0x00003FFF
data8 0x8218AF4373FC25EC , 0x00003FFF
data8 0x82CD8698AC2BA1D7 , 0x00003FFF
data8 0x8383594EEFB6EE37 , 0x00003FFF
data8 0x843A28C3ACDE4046 , 0x00003FFF
data8 0x84F1F656379C1A29 , 0x00003FFF
data8 0x85AAC367CC487B15 , 0x00003FFF
data8 0x8664915B923FBA04 , 0x00003FFF
data8 0x871F61969E8D1010 , 0x00003FFF
data8 0x87DB357FF698D792 , 0x00003FFF
data8 0x88980E8092DA8527 , 0x00003FFF
data8 0x8955EE03618E5FDD , 0x00003FFF
data8 0x8A14D575496EFD9A , 0x00003FFF
data8 0x8AD4C6452C728924 , 0x00003FFF


// Table 2 is 2^(index_1/8) where
// index_2 goes from 0 to 7
pow_tbl2:
data8 0x8000000000000000 , 0x00003FFF
data8 0x8B95C1E3EA8BD6E7 , 0x00003FFF
data8 0x9837F0518DB8A96F , 0x00003FFF
data8 0xA5FED6A9B15138EA , 0x00003FFF
data8 0xB504F333F9DE6484 , 0x00003FFF
data8 0xC5672A115506DADD , 0x00003FFF
data8 0xD744FCCAD69D6AF4 , 0x00003FFF
data8 0xEAC0C6E7DD24392F , 0x00003FFF

.global pow

.section .text
.proc  pow
.align 32

pow:

{ .mfi
          alloc         r32=ar.pfs,1,35,4,0 
          fms.s1 POW_Xm1 = f8,f1,f1   // Will be used for r1 if x>0
          mov           pow_GR_17ones  = 0x1FFFF
}
{ .mfi
          addl          pow_AD_P   = @ltoff(pow_table_P), gp
          fma.s1 POW_Xp1 = f8,f1,f1   // Will be used for r1 if x<0
          nop.i 999
;;
}


// Get exponent of x.  Will be used to calculate K.
{ .mfi
          getf.exp      pow_GR_signexp_X    = f8
          frcpa.s1      POW_B, p6   = f1,f8
          nop.i 999
}
{ .mfi
          ld8 pow_AD_P = [pow_AD_P]
          fma.s1        POW_NORM_X     = f8,f1,f0
          mov           pow_GR_FFF7    = 0xFFF7
}
;;



// Get significand of x.  Will be used to get index to fetch T, Tt.
// p13 = TRUE ==> X is unorm
// DOUBLE 0x10033  exponent limit at which y is an integer
// SINGLE 0x10016
{ .mfi
          getf.sig      pow_GR_sig_X        = f8
          fclass.m  p13,p0          = f8, 0x0b  // Test for x unorm
          addl pow_GR_10033                 = 0x10033, r0
}
{ .mfi
          mov           pow_GR_16ones   = 0xFFFF
          fma.s1        POW_NORM_Y     = f9,f1,f0
          nop.i 999
}
;;


// p14 = TRUE ==> X is ZERO
{ .mfi
          adds          pow_AD_Tt       = pow_Tt - pow_table_P,  pow_AD_P
          fclass.m  p14,p15          = f8, 0x07
          and           pow_GR_exp_X        = pow_GR_signexp_X, pow_GR_17ones
}
{ .mfi
          adds          pow_AD_Q       = pow_table_Q - pow_table_P,  pow_AD_P
          nop.f 999
          nop.i 999
}
;;

{ .mfi
          ldfe          POW_P5         = [pow_AD_P], 16
          fcmp.lt.s1 p8,p9 = f8, f0    // Test for x<0
          shl           pow_GR_offset       = pow_GR_sig_X, 1
}
{ .mib
          ldfe          POW_P4         = [pow_AD_Q], 16
          sub       pow_GR_true_exp_X       = pow_GR_exp_X, pow_GR_16ones
(p13)     br.cond.spnt POW_X_DENORM
}
;;


// Continue normal and denormal paths here
POW_COMMON:
// p11 = TRUE ==> Y is a NAN
{ .mfi
          ldfe          POW_P3         = [pow_AD_P], 16
          fclass.m  p11,p0         = f9, 0xc3
          shr.u     pow_GR_offset           = pow_GR_offset,56
}
{ .mfi
          ldfe          POW_P2         = [pow_AD_Q], 16
          nop.f 999
          mov pow_GR_y_zero = 0
}
;;



// Compute xsq to decide later if |x|=1
// p11 = TRUE ==> Y is a NaN
{ .mfi
          setf.sig POW_int_K                = pow_GR_true_exp_X
(p15)     fms.s1        POW_r          = POW_B, POW_NORM_X,f1
          shladd pow_AD_Tt = pow_GR_offset, 4, pow_AD_Tt
}
{ .mfi
          nop.m 999
(p8)      fnma.s1        POW_Xm1       = POW_Xp1,f1,f0
          nop.i 999
}
;;



// p12 = TRUE if Y is ZERO
{ .mfi
          ldfe          POW_P1         = [pow_AD_P], 16
          fclass.m      p12,p0              = f9, 0x07
          nop.i 999
}
{ .mfb
          ldfe          POW_P0         = [pow_AD_Q], 16
          fma.s1        POW_xsq = POW_NORM_X, POW_NORM_X, f0
(p11)     br.cond.spnt   POW_Y_NAN
}
;;


.pred.rel "mutex",p8,p9
// Get exponent of |x|-1 to use in comparison to 2^-8
{ .mmf
(p8)      getf.exp      pow_GR_signexp_Xm1  = POW_Xp1
(p9)      getf.exp      pow_GR_signexp_Xm1  = POW_Xm1
          fcvt.fx.s1   POW_int_Y            = POW_NORM_Y
}
;;


// p11 = TRUE ==> X is a NAN
{ .mfi
          ldfpd         POW_log2_hi, POW_log2_lo  = [pow_AD_Q], 16
          fclass.m      p11,p0              = f8, 0xc3
          nop.i 999
}
{ .mfi
          ldfpd  POW_T, POW_Tt              = [pow_AD_Tt], 16
          nop.f 999
(p12)     mov pow_GR_y_zero = 1
}
;;


// p14 = TRUE ==> X is zero
//    p15 = TRUE ==> X is zero AND Y is negative
//    p10 = TRUE ==> X is zero AND Y is >= zero 
//    p8  = TRUE ==> X is zero AND Y is zero
{ .mfi
          ldfe          POW_inv_log2_by_128 = [pow_AD_P], 16
(p14)     fcmp.lt.unc.s1 p15, p10           = f9,f0
(p14)     cmp.ne.unc p8,p0 = pow_GR_y_zero,r0
}
{ .mfi
          nop.m 999
          nop.f 999
          and       pow_GR_exp_Xm1          = pow_GR_signexp_Xm1, pow_GR_17ones
} 
;;


// Determine if we will use the |x| near 1 path (p6) or normal path (p7)
// p9  = TRUE ==> X is a NAN and Y is a zero
// p13 = TRUE ==> X is a NAN and Y is anything else
{ .mfi
          getf.exp  pow_GR_signexp_Y        = POW_NORM_Y 
(p11)     fclass.m.unc  p9,p13             = f9, 0x07
          cmp.lt p6,p7                      = pow_GR_exp_Xm1, pow_GR_FFF7
}
{ .mfi
          ldfpd  POW_Q2, POW_Q3             = [pow_AD_P], 16
          fma.s1        POW_rsq             = POW_r, POW_r,f0
          nop.i 999
;;
}

// If on the x near 1 path, assign r1 to r and r1*r1 to rsq
{ .mfi
          ldfpd  POW_Q0_half, POW_Q1             = [pow_AD_P], 16
(p6)      fma.s1    POW_r                 = POW_r1, f1, f0
          nop.i 999
}
{ .mfb
          nop.m 999
(p6)      fma.s1    POW_rsq                 = POW_r1, POW_r1, f0
(p8)      br.cond.spnt POW_X_0_Y_0   // Branch if x zero and y zero
;;
}


{ .mfi
          ldfpd   POW_Q4, POW_RSHF          = [pow_AD_P], 16
(p7)      fma.s1 POW_v6                     = POW_r,  POW_P5, POW_P4
          and pow_GR_exp_Y                   = pow_GR_signexp_Y, pow_GR_17ones
}
{ .mfb
          mov pow_GR_exp_2toM63             = 0xffc0  // Exponent of 2^-63
(p6)      fma.s1 POW_v6                     = POW_r1, POW_P5, POW_P4
(p9)      br.cond.spnt POW_X_NAN_Y_0
}
;;


{ .mfi
          setf.exp POW_2toM63 = pow_GR_exp_2toM63  // Form 2^-63 for test of q
(p7)      fma.s1 POW_v4                     = POW_P3, POW_r,  POW_P2 
          andcm pow_GR_sign_Y               = pow_GR_signexp_Y, pow_GR_17ones
}
{ .mfi
          nop.m 999
(p6)      fma.s1 POW_v4                     = POW_P3, POW_r1, POW_P2 
          nop.i 999
}
;;

{ .mfi
          nop.m 999
          fcvt.xf POW_K                     = POW_int_K
          nop.i 999
}
{ .mfb
          nop.m 999
(p13)     fma.d.s0 f8                       = f8,f1,f0
(p13)     br.ret.spnt  b0    // Exit if x nan, y anything but zero
}
;;
          
// p10 = TRUE ==> X is zero  AND Y is positive
//  p8  = TRUE ==> X is zero  AND Y is outside integer range (treat as even int)
//                   return +0
//  p9  = TRUE ==> X is zero  AND Y is within integer range (may not be integer) 
{ .mfi
(p10)     cmp.gt.unc p8,p9                  =  pow_GR_exp_Y, pow_GR_10033
(p6)      fmerge.s POW_delta                 = f0,f0
          nop.i 999
}
{ .mfb
          nop.m 999
(p6)      fma.s1 POW_G                       = f0,f0,f0
(p12)     br.cond.spnt POW_Y_0   // Branch if y=zero, x not zero or nan
}
;;

{ .mfi
          getf.sig pow_GR_sig_int_Y         = POW_int_Y
          fnma.s1 POW_twoV                   = POW_NORM_Y, POW_rsq,f0
          nop.i 999
}
{ .mfi
          nop.m 999
          fma.s1 POW_U                      = POW_NORM_Y,POW_r,f0
          nop.i 999
}
;;

{ .mfi
          ldfe      POW_log2_by_128_lo      = [pow_AD_P], 16
(p6)      fma.s1 POW_v2                     = POW_P1, POW_r1, POW_P0 
          nop.i 999
}
{ .mfi
          ldfe          POW_log2_by_128_hi  = [pow_AD_Q], 16
(p7)      fma.s1 POW_v2                     = POW_P1, POW_r,  POW_P0 
          nop.i 999
}
;;


{ .mfi
          nop.m 999
          fcvt.xf   POW_float_int_Y               = POW_int_Y
          nop.i 999
}
{ .mfi
          nop.m 999
          fma.s1 POW_v3                     = POW_v6, POW_rsq,  POW_v4 
          adds          pow_AD_tbl1       = pow_tbl1 - pow_Tt,  pow_AD_Q
}
;;

{ .mfi
          nop.m 999
(p7)      fma.s1 POW_delta                  = POW_K, POW_log2_lo, POW_Tt
          nop.i 999
}
{ .mfi
          nop.m 999
(p7)      fma.s1 POW_G                      = POW_K, POW_log2_hi, POW_T 
          adds pow_AD_tbl2                  = pow_tbl2 - pow_tbl1,  pow_AD_tbl1
}
;;


{ .mfi
          nop.m 999
          fms.s1 POW_e2                     = POW_NORM_Y, POW_r, POW_U
          nop.i 999
}
{ .mfi
          nop.m 999
          fma.s1 POW_Z2                     = POW_twoV, POW_Q0_half, POW_U
          nop.i 999
}
;;

// p11 = TRUE ==> X is NEGATIVE but not inf
// p8  = TRUE ==> X is zero  AND Y is outside intger range (treat as even int)
//                return +0
{ .mfi
          nop.m 999
          fclass.m  p11,p0                  = f8, 0x1a
          nop.i 999
}
{ .mfb
          nop.m 999
(p8)      fma.d.s0 f8                      = f0,f0,f0
(p8)      br.ret.spnt b0
}
;;

{ .mfi 
          nop.m 999
          fma.s1 POW_Yrcub                 = POW_rsq, POW_U, f0
          nop.i 999
}
{ .mfi 
          nop.m 999
          fma.s1 POW_p                      = POW_rsq, POW_v3, POW_v2
          nop.i 999
}
;;


// p11 = TRUE ==> X is NEGATIVE but not inf
//    p12 = TRUE ==> X is NEGATIVE  AND  Y  already even int
//    p13 = TRUE ==> X is NEGATIVE  AND  Y possible int
{ .mfi
          nop.m 999
          fma.s1 POW_Z1                     = POW_NORM_Y, POW_G, f0
(p11)     cmp.gt.unc  p12,p13                = pow_GR_exp_Y, pow_GR_10033
}
{ .mfi
          nop.m 999
          fma.s1 POW_e3                     = POW_NORM_Y, POW_delta, f0
          nop.i 999
}
;;

// p9  = TRUE ==> X is zero  AND Y is within integer range (may not be integer)
//    p6 = TRUE ==>  X is zero  AND  Y is an integer (may be even or odd)
//    p7 = TRUE ==>  X is zero  AND  Y is NOT an integer, return +0
{ .mfi
          nop.m 999
(p9)      fcmp.eq.unc.s1 p6,p7             = POW_float_int_Y,  POW_NORM_Y
          nop.i 999
}
{ .mfi 
          nop.m 999
          fma.s1 POW_Gpr                    = POW_G, f1, POW_r
          nop.i 999
}
;;

// By adding RSHF (1.1000...*2^63) we put integer part in rightmost significand
{ .mfi
          nop.m 999
          fma.s1 POW_W2  = POW_Z2, POW_inv_log2_by_128, POW_RSHF
          nop.i 999
}
{ .mfi
          nop.m 999
          fms.s1 POW_UmZ2                   = POW_U, f1, POW_Z2
          nop.i 999
}
;;


// If x=0 and y>0, test y and flag denormal
// p6  = TRUE ==>  X is zero  AND  Y is an integer (may be even or odd)
//    p8 = TRUE ==>  X is zero  AND  Y is an odd  integer
//    p9 = TRUE ==>  X is zero  AND  Y is an even integer
{ .mfi
          nop.m 999
(p10)     fcmp.eq.s0 p15,p0 = f9,f0
(p6)      tbit.nz.unc  p8,p9                = pow_GR_sig_int_Y,0
}
{ .mfi
          nop.m 999
          fma.s1 POW_Z3                      = POW_p, POW_Yrcub, f0
          nop.i 999
}
;;

// By adding RSHF (1.1000...*2^63) we put integer part in rightmost significand
{ .mfi
          nop.m 999
          fms.s1 POW_e1                     = POW_NORM_Y, POW_G, POW_Z1
          nop.i 999
}
{ .mfi
          nop.m 999
          fma.s1 POW_W1  = POW_Z1, POW_inv_log2_by_128, POW_RSHF
          nop.i 999
}
;;

{ .mfi
          nop.m 999
(p7)      fma.d.s0 f8  = f0,f0,f0  // Result +0 if x zero and y not integer
          nop.i 999
}
{ .mfb
          nop.m 999
          fma.s1 POW_Y_Gpr                  = POW_NORM_Y, POW_Gpr, f0
(p8)      br.ret.spnt b0        // Exit if x zero and y odd integer
}
;;

// By subtracting RSHF we get rounded integer POW_N2float
// p15 = TRUE ==> X_0_Y_NEG
{ .mfi
          nop.m 999
          fms.s1 POW_N2float  = POW_W2, f1, POW_RSHF
          nop.i 999
}
{ .mfb
          nop.m 999
          fma.s1 POW_UmZ2pV                 = POW_twoV,POW_Q0_half,POW_UmZ2
(p15)     br.cond.spnt POW_X_0_Y_NEG
}
;;



{ .mfi
          nop.m 999
          fma.s1 POW_Z3sq                   = POW_Z3, POW_Z3, f0
          nop.i 999
}
{ .mfb
          nop.m 999
          fma.s1 POW_v4                     = POW_Z3, POW_Q3, POW_Q2
(p7)      br.ret.spnt b0     // Exit if x zero and y not an integer
}
;;



// Extract rounded integer from rightmost significand of POW_W2
// By subtracting RSHF we get rounded integer POW_N1float
{ .mfi
          getf.sig pow_GR_int_W2             = POW_W2
          fms.s1 POW_N1float  = POW_W1, f1, POW_RSHF
          nop.i 999
}
{ .mfi
          nop.m 999
          fma.s1 POW_v2                     = POW_Z3, POW_Q1, POW_Q0_half
          nop.i 999
}
;;


// p13 = TRUE ==> X is NEGATIVE  AND  Y possible int
//     p10 = TRUE ==> X is NEG and Y is an int
//     p12 = TRUE ==> X is NEG and Y is not an int
{ .mfi
          nop.m 999
(p13)     fcmp.eq.unc.s1 p10,p12             = POW_float_int_Y,  POW_NORM_Y
          mov pow_GR_xneg_yodd = 0
}
{ .mfb
          nop.m 999
(p9)      fma.d.s0 f8  = f0,f0,f0   // Result +0 if x zero and y even integer
(p9)      br.ret.spnt b0    // Exit if x zero and y even integer
}
;;


{ .mfi
          nop.m 999
          fnma.s1 POW_s2 = POW_N2float, POW_log2_by_128_hi, POW_Z2
          nop.i 999
}
{ .mfi
          nop.m 999
          fma.s1 POW_e2                     = POW_e2,f1,POW_UmZ2pV
          nop.i 999
}
;;

// Extract rounded integer from rightmost significand of POW_W1
// Test if x inf
{ .mfi
          getf.sig pow_GR_int_W1             = POW_W1
          fclass.m p15,p0 = POW_NORM_X,  0x23
          nop.i 999
}
{ .mfb
          nop.m 999
          fnma.s1 POW_f2  = POW_N2float, POW_log2_by_128_lo, f1
(p12)     br.cond.spnt POW_X_NEG_Y_NONINT  // Branch if x neg, y not integer
}
;;

// p11 = TRUE ==> X is +1.0
// p12 = TRUE ==> X is NEGATIVE  AND Y is an odd integer
{ .mfi
          getf.exp pow_GR_signexp_Y_Gpr       = POW_Y_Gpr
          fcmp.eq.s1 p11,p0 = POW_NORM_X, f1
(p10)     tbit.nz.unc  p12,p0                = pow_GR_sig_int_Y,0
}
{ .mfi
          nop.m 999
          fma.s1 POW_v3                     = POW_Z3sq, POW_Q4, POW_v4
          nop.i 999
}
;;


{ .mfi
          add pow_GR_int_N                   = pow_GR_int_W1, pow_GR_int_W2
          fnma.s1 POW_f1  = POW_N1float, POW_log2_by_128_lo, f1
          nop.i 999
}
{ .mfb
          nop.m 999
          fnma.s1 POW_s1  = POW_N1float, POW_log2_by_128_hi, POW_Z1
(p15)     br.cond.spnt POW_X_INF
}
;;


// Test x and y and flag denormal
{ .mfi
          and pow_GR_index1                  = 0x0f, pow_GR_int_N
          fcmp.eq.s0 p15,p0 = f8,f9
          shr r2                             = pow_GR_int_N, 7
}
{ .mfi
          and pow_GR_exp_Y_Gpr               = pow_GR_signexp_Y_Gpr, pow_GR_17ones
(p11)     fma.d.s0 f8 = f1,f1,f0    // If x=1, result is +1
          and pow_GR_index2                  = 0x70, pow_GR_int_N
}
;;



{ .mfi
          shladd pow_AD_T1                   = pow_GR_index1, 4, pow_AD_tbl1
          fcmp.eq.s1 p7,p0 = POW_NORM_Y, f1  // Test for y=1.0
          sub pow_GR_true_exp_Y_Gpr          = pow_GR_exp_Y_Gpr, pow_GR_16ones
}
{ .mfi
          add pow_AD_T2                      = pow_AD_tbl2, pow_GR_index2
          fma.s1  POW_e12                     = POW_e1,f1,POW_e2
          addl pow_int_GR_M                  = 0xFFFF, r2
}
;;


{ .mfi
          ldfe POW_T1                        = [pow_AD_T1]
          nop.f 999
          andcm pow_GR_sign_Y_Gpr            = pow_GR_signexp_Y_Gpr, pow_GR_17ones
}
{ .mib
          ldfe POW_T2                        = [pow_AD_T2]
(p12)     mov pow_GR_xneg_yodd = 1
(p11)     br.ret.spnt b0        // Early exit if x=1.0, result is +1
}
;;


{ .mfb
          setf.exp POW_2M                    = pow_int_GR_M
          fma.s1 POW_q                       = POW_Z3sq, POW_v3, POW_v2
(p7)      br.ret.spnt b0        // Early exit if y=1.0, result is x
}
;;


// double: p8 TRUE ==> |Y(G + r)| >= 10
// single: p8 TRUE ==> |Y(G + r)| >= 7

// double
//     -2^10  -2^9             2^9   2^10
// -----+-----+----+ ... +-----+-----+-----
//  p8  |             p9             |  p8
//      |     |       p10      |     |  
// single
//     -2^7   -2^6             2^6   2^7
// -----+-----+----+ ... +-----+-----+-----
//  p8  |             p9             |  p8
//      |     |       p10      |     |


{ .mfi
          cmp.le p8,p9                       = 10, pow_GR_true_exp_Y_Gpr
          fma.s1 POW_s                       = POW_s1, f1, POW_s2
          nop.i 999
}
{ .mfi
          nop.m 999
          fma.s1 POW_f12                     = POW_f1, POW_f2,f0
          nop.i 999
}
;;


{ .mfb
(p9)      cmp.le.unc p0,p10                  = 9, pow_GR_true_exp_Y_Gpr
          nop.f 999
(p8)      br.cond.spnt POW_OVER_UNDER_X_NOT_INF
}
;;



// Form signexp of constants to indicate overflow
{ .mmf
          mov         pow_GR_big_pos         = 0x103ff 
          mov         pow_GR_big_neg         = 0x303ff 
          fma.s1 POW_e123                    = POW_e12, f1, POW_e3
}
;;


// Form big positive and negative constants to test for possible overflow
{ .mmf
          setf.exp POW_big_pos               = pow_GR_big_pos
          setf.exp POW_big_neg               = pow_GR_big_neg
          fma.s1 POW_q                       = POW_Z3sq, POW_q, POW_Z3
}
;;


{ .mfi
          nop.m 999 
          fma.s1 POW_ssq                     = POW_s, POW_s, f0
          nop.i 999
}
{ .mfi
          nop.m 999 
          fma.s1 POW_v4                      = POW_s, POW_Q3, POW_Q2
          nop.i 999
}
;;

{ .mfi
          nop.m 999
          fma.s1 POW_v2                      = POW_s, POW_Q1, POW_Q0_half
          nop.i 999
}
{ .mfi
          nop.m 999
          fma.s1 POW_1ps                     = f1,f1,POW_s
          nop.i 999
}
;;

// f123 = f12*(e123+1) = f12*e123+f12
{ .mfi
          nop.m 999
          fma.s1 POW_f123                    = POW_e123,POW_f12,POW_f12
          nop.i 999
}
{ .mfi
          nop.m 999
          fma.s1 POW_T1T2                    = POW_T1, POW_T2, f0
          nop.i 999
}
;;

{ .mfi
          nop.m 999
          fma.s1 POW_v3                     = POW_ssq, POW_Q4, POW_v4
          cmp.ne p12,p13 = pow_GR_xneg_yodd, r0
}
;;

{ .mfi
          nop.m 999
          fma.s1 POW_v21ps                  = POW_ssq, POW_v2, POW_1ps
          nop.i 999
}
{ .mfi
          nop.m 999
          fma.s1 POW_s4                     = POW_ssq, POW_ssq, f0
          nop.i 999
}
;;


{ .mfi
          nop.m 999
(p12)     fnma.s1 POW_A                    =  POW_2M, POW_T1T2, f0
          nop.i 999
}
{ .mfi
          nop.m 999
(p13)     fma.s1 POW_A                      =  POW_2M, POW_T1T2, f0
          cmp.eq p14,p11 = r0,r0   // Initialize p14 on, p11 off
}
;;

{ .mfi
          nop.m 999
          fmerge.s POW_abs_q = f0, POW_q    // Form |q| so can test its size
          nop.i 999
}
;;

{ .mfi
(p10)     cmp.eq p0,p14 = r0,r0    // Turn off p14 if no overflow
          fma.s1 POW_es                     = POW_s4,  POW_v3, POW_v21ps
          nop.i 999
}
{ .mfi
          nop.m 999
          fma.s1 POW_A                      = POW_A, POW_f123, f0
          nop.i 999
}
;;

{ .mfi
// Test for |q| < 2^-63.  If so then reverse last two steps of the result
// to avoid monotonicity problems for results near 1.0 in round up/down/zero.
// p11 will be set if need to reverse the order, p14 if not.
          nop.m 999
(p10)     fcmp.lt p11,p14 = POW_abs_q, POW_2toM63 // Test |q| <2^-63
          nop.i 999
}
;;

.pred.rel "mutex",p11,p14
{ .mfi
          nop.m 999
(p14)     fma.s1 POW_A                      = POW_A, POW_es, f0
          nop.i 999
}
{ .mfi
          nop.m 999
(p11)     fma.s1 POW_A                      = POW_A, POW_q, POW_A
          nop.i 999
}
;;

// Dummy op to set inexact if |q| < 2^-63
{ .mfi
          nop.m 999
(p11)     fma.d.s0 POW_tmp                  = POW_A, POW_q, POW_A
          nop.i 999
}
;;

{ .mfi
          nop.m 999
(p14)     fma.d.s0 f8                          = POW_A, POW_q, POW_A
          nop.i 999
}
{ .mfb
          nop.m 999
(p11)     fma.d.s0 f8                          = POW_A, POW_es, f0
(p10)     br.ret.sptk     b0
}
;;




// POSSIBLE_OVER_UNDER
// p6 = TRUE ==> Y_Gpr negative
// Result is already computed.  We just need to know if over/underflow occurred.

{ .mfb
        cmp.eq p0,p6                      = pow_GR_sign_Y_Gpr, r0
        nop.f 999
(p6)    br.cond.spnt POW_POSSIBLE_UNDER 
}
;;

// POSSIBLE_OVER
// We got an answer. 
// overflow is a possibility, not a certainty


// We define an overflow when the answer with
//    WRE set
//    user-defined rounding mode

// double
// Largest double is 7FE (biased double)
//                   7FE - 3FF + FFFF = 103FE
// Create + largest_double_plus_ulp
// Create - largest_double_plus_ulp
// Calculate answer with WRE set.

// single
// Largest single is FE (biased double)
//                   FE - 7F + FFFF = 1007E
// Create + largest_single_plus_ulp
// Create - largest_single_plus_ulp
// Calculate answer with WRE set.

// Cases when answer is ldn+1  are as follows:
//  ldn                   ldn+1
// --+----------|----------+------------
//              |
//    +inf          +inf      -inf
//                  RN         RN
//                             RZ


// Put in s2 (td set, wre set)
{ .mfi
        nop.m 999
        fsetc.s2 0x7F,0x42
        nop.i 999 
}
;;


{ .mfi
        nop.m 999
        fma.d.s2 POW_wre_urm_f8                    = POW_A, POW_q, POW_A
        nop.i 999
}
;;

// Return s2 to default
{ .mfi
        nop.m 999
        fsetc.s2 0x7F,0x40
        nop.i 999
}
;;


// p7 = TRUE ==> yes, we have an overflow
{ .mfi
        nop.m 999
        fcmp.ge.s1 p7, p8                    =  POW_wre_urm_f8, POW_big_pos
        nop.i 999
}
;;

{ .mfi
        nop.m 999
(p8)    fcmp.le.s1 p7, p0                    =  POW_wre_urm_f8, POW_big_neg
        nop.i 999
}
;;

{ .mbb
(p7)   mov pow_GR_tag                            = 24
(p7)   br.cond.spnt __libm_error_region     // Branch if overflow
       br.ret.sptk     b0                   // Exit if did not overflow
}
;;


POW_POSSIBLE_UNDER:
// We got an answer. input was < -2^9 but > -2^10 (double)
// We got an answer. input was < -2^6 but > -2^7  (float)
// underflow is a possibility, not a certainty

// We define an underflow when the answer with
//    ftz set
// is zero (tiny numbers become zero)
// Notice (from below) that if we have an unlimited exponent range,
// then there is an extra machine number E between the largest denormal and
// the smallest normal.
// So if with unbounded exponent we round to E or below, then we are
// tiny and underflow has occurred.
// But notice that you can be in a situation where we are tiny, namely
// rounded to E, but when the exponent is bounded we round to smallest
// normal. So the answer can be the smallest normal with underflow.
//                           E
// -----+--------------------+--------------------+-----
//      |                    |                    |
//   1.1...10 2^-3fff    1.1...11 2^-3fff    1.0...00 2^-3ffe
//   0.1...11 2^-3ffe                                   (biased, 1)
//    largest dn                               smallest normal


// Put in s2 (td set, ftz set)
{ .mfi
        nop.m 999
        fsetc.s2 0x7F,0x41
        nop.i 999 
}
;;

{ .mfi
        nop.m 999
        fma.d.s2 POW_ftz_urm_f8                    = POW_A, POW_q, POW_A
        nop.i 999
}
;;


// Return s2 to default
{ .mfi
        nop.m 999
        fsetc.s2 0x7F,0x40
        nop.i 999 
}
;;


// p7 = TRUE ==> yes, we have an underflow
{ .mfi
        nop.m 999
        fcmp.eq.s1 p7, p0                     =  POW_ftz_urm_f8, f0
        nop.i 999 
}
;;


{ .mbb
(p7)    mov pow_GR_tag                           = 25
(p7)    br.cond.spnt __libm_error_region      // Branch if underflow
        br.ret.sptk     b0                    // Exit if did not underflow
}
;;



POW_X_DENORM:
// Here if x unorm. Use the NORM_X for getf instructions, and the back
// to normal path
{ .mfi
        getf.exp      pow_GR_signexp_X    = POW_NORM_X
        nop.f 999
        nop.i 999
}
;;

{ .mfi
        getf.sig      pow_GR_sig_X        = POW_NORM_X
        nop.f 999
        nop.i 999
}
;;

{ .mfi
        and           pow_GR_exp_X        = pow_GR_signexp_X, pow_GR_17ones
        nop.f 999
        nop.i 999
}
;;

{ .mib
        sub       pow_GR_true_exp_X       = pow_GR_exp_X, pow_GR_16ones
        shl           pow_GR_offset       = pow_GR_sig_X, 1
        br.cond.sptk    POW_COMMON
}
;;


POW_X_0_Y_0:
// When X is +-0 and Y is +-0, IEEE returns 1.0 
// We call error support with this value 

{ .mfb
        mov pow_GR_tag                     = 26
        fma.d.s0 f8                        = f1,f1,f0
        br.cond.sptk __libm_error_region
}
;;


POW_Y_0:
// Here for y zero, x anything but zero and nan
// Set flag if x denormal
// Result is +1.0
{ .mfi
        nop.m 999
        fcmp.eq.s0 p6,p0 = f8,f0    // Sets flag if x denormal
        nop.i 999
}
{ .mfb
        nop.m 999
        fma.d.s0 f8 = f1,f1,f0
        br.ret.sptk b0
}
;;


POW_X_INF:
// Here when X is +-inf

// X +inf  Y +inf             +inf  
// X -inf  Y +inf             +inf 

// X +inf  Y >0               +inf    
// X -inf  Y >0, !odd integer +inf     <== (-inf)^0.5 = +inf !!
// X -inf  Y >0,  odd integer  -inf   

// X +inf  Y -inf             +0   
// X -inf  Y -inf             +0  

// X +inf  Y <0               +0      
// X -inf  Y <0, !odd integer +0     
// X -inf  Y <0, odd integer  -0    

// X + inf Y=+0                +1
// X + inf Y=-0                +1
// X - inf Y=+0                +1
// X - inf Y=-0                +1

// p13 == Y negative
// p14 == Y positive

// p6 == Y is a floating point number outside the integer.
//       Hence it is an integer and is even.
//       p13 == (Y negative) 
//          return +inf
//       p14 == (Y positive)
//          return +0



// p7 == Y is a floating point number within the integer range.
//      p9  == (int_Y = NORM_Y), Y is an integer, which may be odd or even.
//           p11 odd
//              p13 == (Y negative)    
//                 return (sign_of_x)inf
//              p14 == (Y positive) 
//                 return (sign_of_x)0
//           pxx even                
//              p13 == (Y negative) 
//                 return +inf     
//              p14 == (Y positive)
//                 return +0     

//      pxx == Y is not an integer
//           p13 == (Y negative) 
//                 return +inf
//           p14 == (Y positive)
//                 return +0
// 

// If x=inf, test y and flag denormal
{ .mfi
          nop.m 999
          fcmp.eq.s0 p10,p11 = f9,f0
          nop.i 999
}
;;

{ .mfi
          nop.m 999
          fcmp.lt p13,p14                    = POW_NORM_Y,f0 
          cmp.gt  p6,p7                      = pow_GR_exp_Y, pow_GR_10033
}
{ .mfi
          nop.m 999
          fclass.m p12,p0                    = f9, 0x23 //@inf
          nop.i 999
}
;;


{ .mfi
          nop.m 999
          fclass.m p15,p0                    = f9, 0x07	//@zero
          nop.i 999
}
;;

{ .mfb
          nop.m 999
(p15)     fmerge.s f8 = f1,f1      // Return +1.0 if x=inf, y=0
(p15)     br.ret.spnt b0           // Exit if x=inf, y=0
}
;;

        
{ .mfi
          nop.m 999
(p14)     frcpa.s1 f8,p10 = f1,f0  // If x=inf, y>0, assume result +inf
          nop.i 999
}
{ .mfb
          nop.m 999
(p13)     fma.s1 f8 = f0,f0,f0     // If x=inf, y<0, assume result +0.0
(p12)     br.ret.spnt b0           // Exit if x=inf, y=inf
}
;;

   
// Here if x=inf, and 0 < |y| < inf.  Need to correct results if y odd integer.
{ .mfi
          nop.m 999
(p7)      fcmp.eq.unc.s1 p9,p0 = POW_float_int_Y,  POW_NORM_Y // Is y integer?
          nop.i 999
}
;;

{ .mfi
          nop.m 999
          nop.f 999
(p9)      tbit.nz.unc p11,p0 = pow_GR_sig_int_Y,0  // Test for y odd integer
}
;;

{ .mfb
          nop.m 999
(p11)     fmerge.s f8 = POW_NORM_X,f8    // If y odd integer use sign of x
          br.ret.sptk b0                 // Exit for x=inf, 0 < |y| < inf
}
;;



POW_X_0_Y_NEG:
// When X is +-0 and Y is negative, IEEE returns 
// X     Y           answer
// +0    -odd int    +inf
// -0    -odd int    -inf

// +0    !-odd int   +inf
// -0    !-odd int   +inf


// p6 == Y is a floating point number outside the integer.
//       Hence it is an integer and is even.
//       return +inf

// p7 == Y is a floating point number within the integer range.
//      p9  == (int_Y = NORM_Y), Y is an integer, which may be odd or even.
//           p11 odd
//              return (sign_of_x)inf
//           p12 even
//              return +inf
//      p10 == Y is not an integer
//         return +inf
// 
// 

{ .mfi
          nop.m 999
          nop.f 999
          cmp.gt  p6,p7                      = pow_GR_exp_Y, pow_GR_10033
}
;;


{ .mfi
          mov pow_GR_tag                     = 27
(p7)      fcmp.eq.unc.s1 p9,p10              = POW_float_int_Y,  POW_NORM_Y
          nop.i 999
}
;;


{ .mfb
          nop.m 999
(p6)      frcpa.s0 f8,p13                       = f1, f0
(p6)      br.cond.sptk __libm_error_region
}
;;

{ .mfb
          nop.m 999
(p10)     frcpa.s0 f8,p13                       = f1, f0
(p10)     br.cond.sptk __libm_error_region
}
;;



{ .mib
          nop.m 999
(p9)      tbit.nz.unc p11,p12                = pow_GR_sig_int_Y,0
          nop.b 999
}
;;



{ .mfi
          nop.m 999
(p12)     frcpa.s0 f8,p13                      = f1,f0
          nop.i 999
}
;;

{ .mfb
          nop.m 999
(p11)     frcpa f8,p13                      = f1,f8 
          br.cond.sptk __libm_error_region
}
;;




POW_X_NEG_Y_NONINT:
// When X is negative and Y is a non-integer, IEEE
// returns a qnan indefinite.
// We call error support with this value 

{ .mfb
         mov pow_GR_tag                     = 28
         frcpa f8,p6                        = f0,f0
         br.cond.sptk __libm_error_region
}
;;




POW_X_NAN_Y_0:
// When X is a NAN and Y is zero, IEEE returns 1.
// We call error support with this value.

{ .mfi
         nop.m 0
         fma.d.s0 f10 = f8,f1,f0 
         nop.i 0
}
{ .mfb
         mov pow_GR_tag                     = 29
         fma.d.s0 f8 = f0,f0,f1 
         br.cond.sptk __libm_error_region
}
;;


POW_OVER_UNDER_X_NOT_INF:

// p8 is TRUE for overflow
// p9 is TRUE for underflow

// if y is infinity, we should not over/underflow


{ .mfi
          nop.m 999
          fcmp.eq.s1     p14, p13            = POW_xsq,f1
          cmp.eq p8,p9                       = pow_GR_sign_Y_Gpr, r0
}
;;

{ .mfi
          nop.m 999
(p14)     fclass.m.unc       p15, p0         = f9, 0x23
          nop.i 999
}
{ .mfi
          nop.m 999
(p13)     fclass.m.unc       p11,p0         = f9, 0x23
          nop.i 999
}
;;

// p15 = TRUE if |x|=1, y=inf, return +1
{ .mfb
          nop.m 999
(p15)     fma.d.s0          f8              = f1,f1,f0
(p15)     br.ret.spnt b0
}
;;

.pred.rel "mutex",p8,p9
{  .mfb
(p8)      setf.exp           f8              = pow_GR_17ones
(p9)      fmerge.s           f8              = f0,f0
(p11)     br.ret.sptk b0
}

{ .mfb
          nop.m 999
          nop.f 999
          br.cond.sptk POW_OVER_UNDER_ERROR
}
;;

POW_Y_NAN:

// Is x = +1 then result is +1, else result is quiet Y
{ .mfi
       nop.m 999
       fcmp.eq.s1         p10,p9               = POW_NORM_X, f1 
       nop.i 999
}
;;

{ .mfi
       nop.m 999
(p10)  fcmp.eq.s0 p6,p0 = f9,f1   // Set invalid, even if x=+1
       nop.i 999
}
;;

{ .mfi
       nop.m 999
(p10)  fma.d.s0 f8 = f1,f1,f0 
       nop.i 999
}
{ .mfb
       nop.m 999
(p9)   fma.d.s0 f8 = f9,f8,f0 
       br.ret.sptk b0             // Exit y=nan
}
;;


POW_OVER_UNDER_ERROR:

{ .mfi
          nop.m 999
          fmerge.s f10                      = POW_NORM_X,POW_NORM_X
          nop.i 999
}
{ .mfi
          sub   pow_GR_17ones_m1            = pow_GR_17ones, r0, 1
          nop.f 999
          mov pow_GR_one                    = 0x1
}
;;

// overflow
{ .mmb
(p8)     mov pow_GR_tag                     = 24
(p8)     setf.exp f11                       = pow_GR_17ones_m1
         nop.b 999
}
;;

        
// underflow
{ .mmi
(p9)    mov pow_GR_tag                     = 25
(p9)    setf.exp f11                       = pow_GR_one
        nop.i 999
}
;;


// p12 x is negative and y is an odd integer 


{ .mfi
        nop.m 999
        fma.d.s0 f8                           = f11, f11, f0
        nop.i 999
}
;;

{ .mfi
        nop.m 999
(p12)   fnma.d.s0 f8                          = f11, f11, f0
        nop.i 999
}
;;


.endp pow


// Stack operations when calling error support.
//       (1)               (2)                          (3) (call)              (4)
//   sp   -> +          psp -> +                     psp -> +                   sp -> +
//           |                 |                            |                         |
//           |                 | <- GR_Y               R3 ->| <- GR_RESULT            | -> f8
//           |                 |                            |                         |
//           | <-GR_Y      Y2->|                       Y2 ->| <- GR_Y                 |
//           |                 |                            |                         |
//           |                 | <- GR_X               X1 ->|                         |
//           |                 |                            |                         |
//  sp-64 -> +          sp ->  +                     sp ->  +                         +
//    save ar.pfs          save b0                                               restore gp
//    save gp                                                                    restore ar.pfs



.proc __libm_error_region
__libm_error_region:

// Answer is inf for overflow and 0 for underflow.
.prologue
// (1)
{ .mfi
        add   GR_Parameter_Y=-32,sp             // Parameter 2 value
        nop.f 0
.save   ar.pfs,GR_SAVE_PFS
        mov  GR_SAVE_PFS=ar.pfs                 // Save ar.pfs
}
{ .mfi
.fframe 64
        add sp=-64,sp                          // Create new stack
        nop.f 0
        mov GR_SAVE_GP=gp                      // Save gp
};;


// (2)
{ .mmi
        stfd [GR_Parameter_Y] = POW_NORM_Y,16 // STORE Parameter 2 on stack
        add GR_Parameter_X = 16,sp            // Parameter 1 address
.save   b0, GR_SAVE_B0
        mov GR_SAVE_B0=b0                     // Save b0
};;

.body
// (3)
{ .mib
        stfd [GR_Parameter_X] = POW_NORM_X              // STORE Parameter 1 on stack
        add   GR_Parameter_RESULT = 0,GR_Parameter_Y    // Parameter 3 address
        nop.b 0                                
}
{ .mib
        stfd [GR_Parameter_Y] = f8                      // STORE Parameter 3 on stack
        add   GR_Parameter_Y = -16,GR_Parameter_Y
        br.call.sptk b0=__libm_error_support#           // Call error handling function
};;
{ .mmi
        add   GR_Parameter_RESULT = 48,sp
        nop.m 0
        nop.i 0
};;

// (4)
{ .mmi
        ldfd  f8 = [GR_Parameter_RESULT]       // Get return result off stack
.restore
        add   sp = 64,sp                       // Restore stack pointer
        mov   b0 = GR_SAVE_B0                  // Restore return address
};;
{ .mib
        mov   gp = GR_SAVE_GP                  // Restore gp
        mov   ar.pfs = GR_SAVE_PFS             // Restore ar.pfs
        br.ret.sptk     b0                     // Return
};;

.endp __libm_error_region

.type   __libm_error_support#,@function
.global __libm_error_support#
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\crts\fpw32\tran\ia64\powf.s ===
.file "powf.s"

// Copyright (c) 2000, 2001, Intel Corporation
// All rights reserved.
//
// Contributed 2/2/2000 by John Harrison, Ted Kubaska, Bob Norin, Shane Story,
// and Ping Tak Peter Tang of the Computational Software Lab, Intel Corporation.
//
// WARRANTY DISCLAIMER
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL INTEL OR ITS
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// Intel Corporation is the author of this code, and requests that all
// problem reports or change requests be submitted to it directly at
// http://developer.intel.com/opensource.
//
// History
//==============================================================
// 2/02/00  Initial version
// 2/03/00  Added p12 to definite over/under path. With odd power we did not
//          maintain the sign of x in this path.
// 4/04/00  Unwind support added
// 4/19/00  pow(+-1,inf) now returns NaN
//          pow(+-val, +-inf) returns 0 or inf, but now does not call error support
//          Added s1 to fcvt.fx because invalid flag was incorrectly set.
// 8/15/00  Bundle added after call to __libm_error_support to properly
//          set [the previously overwritten] GR_Parameter_RESULT.
// 9/07/00  Improved performance by eliminating bank conflicts and other stalls,
//          and tweaking the critical path
// 9/08/00  Per c99, pow(+-1,inf) now returns 1, and pow(+1,nan) returns 1
// 9/28/00  Updated NaN**0 path 
// 1/20/01  Fixed denormal flag settings.
// 2/13/01  Improved speed.
// 3/19/01  Reordered exp polynomial to improve speed and eliminate monotonicity
//          problem in round up, down, and to zero modes.  Also corrected 
//          overflow result when x negative, y odd in round up, down, zero.
// 6/14/01  Added brace missing from bundle
// 12/10/01 Corrected case where x negative, 2^23 <= |y| < 2^24, y odd integer.
// 02/08/02 Fixed overflow/underflow cases that were not calling error support.
//
// API
//==============================================================
// double pow(double)
// float  powf(float)
//
// Overview of operation
//==============================================================
//
// Three steps...
// 1. Log(x)
// 2. y Log(x)
// 3. exp(y log(x))
// 
// This means we work with the absolute value of x and merge in the sign later.
//      Log(x) = G + delta + r -rsq/2 + p
// G,delta depend on the exponent of x and table entries. The table entries are
// indexed by the exponent of x, called K.
// 
// The G and delta come out of the reduction; r is the reduced x.
// 
// B = frcpa(x)
// xB-1 is small means that B is the approximate inverse of x.
// 
//      Log(x) = Log( (1/B)(Bx) )
//             = Log(1/B) + Log(Bx)
//             = Log(1/B) + Log( 1 + (Bx-1))
// 
//      x  = 2^K 1.x_1x_2.....x_52
//      B= frcpa(x) = 2^-k Cm 
//      Log(1/B) = Log(1/(2^-K Cm))
//      Log(1/B) = Log((2^K/ Cm))
//      Log(1/B) = K Log(2) + Log(1/Cm)
// 
//      Log(x)   = K Log(2) + Log(1/Cm) + Log( 1 + (Bx-1))
// 
// If you take the significand of x, set the exponent to true 0, then Cm is
// the frcpa. We tabulate the Log(1/Cm) values. There are 256 of them.
// The frcpa table is indexed by 8 bits, the x_1 thru x_8.
// m = x_1x_2...x_8 is an 8-bit index.
// 
//      Log(1/Cm) = log(1/frcpa(1+m/256)) where m goes from 0 to 255.
// 
// We tabluate as two doubles, T and t, where T +t is the value itself.
// 
//      Log(x)   = (K Log(2)_hi + T) + (Log(2)_hi + t) + Log( 1 + (Bx-1))
//      Log(x)   =  G + delta           + Log( 1 + (Bx-1))
// 
// The Log( 1 + (Bx-1)) can be calculated as a series in r = Bx-1.
// 
//      Log( 1 + (Bx-1)) = r - rsq/2 + p
// 
// Then,
//    
//      yLog(x) = yG + y delta + y(r-rsq/2) + yp
//      yLog(x) = Z1 + e3      + Z2         + Z3 + (e2 + e3)
// 
// 
//     exp(yLog(x)) = exp(Z1 + Z2 + Z3) exp(e1 + e2 + e3)
//
//
//       exp(Z3) is another series.
//       exp(e1 + e2 + e3) is approximated as f3 = 1 + (e1 + e2 + e3)
//
//       Z1 (128/log2) = number of log2/128 in Z1 is N1
//       Z2 (128/log2) = number of log2/128 in Z2 is N2
//
//       s1 = Z1 - N1 log2/128
//       s2 = Z2 - N2 log2/128
//
//       s = s1 + s2
//       N = N1 + N2
//
//       exp(Z1 + Z2) = exp(Z)
//       exp(Z)       = exp(s) exp(N log2/128)
//
//       exp(r)       = exp(Z - N log2/128)
//
//      r = s + d = (Z - N (log2/128)_hi) -N (log2/128)_lo
//                =  Z - N (log2/128) 
//
//      Z         = s+d +N (log2/128)
//
//      exp(Z)    = exp(s) (1+d) exp(N log2/128)
//
//      N = M 128 + n
//
//      N log2/128 = M log2 + n log2/128
//
//      n is 8 binary digits = n_7n_6...n_1
//
//      n log2/128 = n_7n_6n_5 16 log2/128 + n_4n_3n_2n_1 log2/128
//      n log2/128 = n_7n_6n_5 log2/8 + n_4n_3n_2n_1 log2/128
//      n log2/128 = I2 log2/8 + I1 log2/128
//
//      N log2/128 = M log2 + I2 log2/8 + I1 log2/128 
//
//      exp(Z)    = exp(s) (1+d) exp(log(2^M) + log(2^I2/8) + log(2^I1/128))
//      exp(Z)    = exp(s) (1+d1) (1+d2)(2^M) 2^I2/8 2^I1/128
//      exp(Z)    = exp(s) f1 f2 (2^M) 2^I2/8 2^I1/128
//
// I1, I2 are table indices. Use a series for exp(s).
// Then get exp(Z) 
//
//     exp(yLog(x)) = exp(Z1 + Z2 + Z3) exp(e1 + e2 + e3)
//     exp(yLog(x)) = exp(Z) exp(Z3) f3 
//     exp(yLog(x)) = exp(Z)f3 exp(Z3)  
//     exp(yLog(x)) = A exp(Z3)  
//
// We actually calculate exp(Z3) -1.
// Then, 
//     exp(yLog(x)) = A + A( exp(Z3)   -1)
//

// Table Generation
//==============================================================

// The log values
// ==============
// The operation (K*log2_hi) must be exact. K is the true exponent of x.
// If we allow gradual underflow (denormals), K can be represented in 12 bits
// (as a two's complement number). We assume 13 bits as an engineering precaution.
// 
//           +------------+----------------+-+
//           |  13 bits   | 50 bits        | |
//           +------------+----------------+-+
//           0            1                66
//                        2                34
// 
// So we want the lsb(log2_hi) to be 2^-50
// We get log2 as a quad-extended (15-bit exponent, 128-bit significand)
// 
//      0 fffe b17217f7d1cf79ab c9e3b39803f2f6af (4...)
// 
// Consider numbering the bits left to right, starting at 0 thru 127.
// Bit 0 is the 2^-1 bit; bit 49 is the 2^-50 bit.
// 
//  ...79ab
//     0111 1001 1010 1011
//     44
//     89
// 
// So if we shift off the rightmost 14 bits, then (shift back only 
// the top half) we get
// 
//      0 fffe b17217f7d1cf4000 e6af278ece600fcb dabc000000000000
// 
// Put the right 64-bit signficand in an FR register, convert to double;
// it is exact. Put the next 128 bits into a quad register and round to double.
// The true exponent of the low part is -51.
// 
// hi is 0 fffe b17217f7d1cf4000
// lo is 0 ffcc e6af278ece601000
// 
// Convert to double memory format and get
// 
// hi is 0x3fe62e42fefa39e8
// lo is 0x3cccd5e4f1d9cc02 
// 
// log2_hi + log2_lo is an accurate value for log2.
// 
// 
// The T and t values
// ==================
// A similar method is used to generate the T and t values.
// 
// K * log2_hi + T  must be exact.
// 
// Smallest T,t
// ----------
// The smallest T,t is 
//       T                   t
// data8 0x3f60040155d58800, 0x3c93bce0ce3ddd81  log(1/frcpa(1+0/256))=  +1.95503e-003
// 
// The exponent is 0x3f6 (biased)  or -9 (true).
// For the smallest T value, what we want is to clip the significand such that
// when it is shifted right by 9, its lsb is in the bit for 2^-51. The 9 is the specific 
// for the first entry. In general, it is 0xffff - (biased 15-bit exponent).

// Independently, what we have calculated is the table value as a quad precision number.
// Table entry 1 is
// 0 fff6 80200aaeac44ef38 338f77605fdf8000
// 
// We store this quad precision number in a data structure that is
//    sign:           1 
//    exponent:      15
//    signficand_hi: 64 (includes explicit bit)
//    signficand_lo: 49
// Because the explicit bit is included, the significand is 113 bits.
// 
// Consider significand_hi for table entry 1.
// 
// 
// +-+--- ... -------+--------------------+
// | |
// +-+--- ... -------+--------------------+
// 0 1               4444444455555555556666
//                   2345678901234567890123
// 
// Labeled as above, bit 0 is 2^0, bit 1 is 2^-1, etc.
// Bit 42 is 2^-42. If we shift to the right by 9, the bit in
// bit 42 goes in 51.
// 
// So what we want to do is shift bits 43 thru 63 into significand_lo.
// This is shifting bit 42 into bit 63, taking care to retain the shifted-off bits.
// Then shifting (just with signficaand_hi) back into bit 42. 
//  
// The shift_value is 63-42 = 21. In general, this is 
//      63 - (51 -(0xffff - 0xfff6))
// For this example, it is
//      63 - (51 - 9) = 63 - 42  = 21
// 
// This means we are shifting 21 bits into significand_lo.  We must maintain more
// that a 128-bit signficand not to lose bits. So before the shift we put the 128-bit 
// significand into a 256-bit signficand and then shift.
// The 256-bit significand has four parts: hh, hl, lh, and ll.
// 
// Start off with
//      hh         hl         lh         ll
//      <64>       <49><15_0> <64_0>     <64_0>
// 
// After shift by 21 (then return for significand_hi),
//      <43><21_0> <21><43>   <6><58_0>  <64_0>
// 
// Take the hh part and convert to a double. There is no rounding here.
// The conversion is exact. The true exponent of the high part is the same as the
// true exponent of the input quad.
// 
// We have some 64 plus significand bits for the low part. In this example, we have
// 70 bits. We want to round this to a double. Put them in a quad and then do a quad fnorm.
// For this example the true exponent of the low part is 
//      true_exponent_of_high - 43 = true_exponent_of_high - (64-21)
// In general, this is 
//      true_exponent_of_high - (64 - shift_value)  
// 
// 
// Largest T,t
// ----------
// The largest T,t is
// data8 0x3fe62643fecf9742, 0x3c9e3147684bd37d    log(1/frcpa(1+255/256))=  +6.92171e-001
// 
// Table entry 256 is
// 0 fffe b1321ff67cba178c 51da12f4df5a0000
// 
// The shift value is 
//      63 - (51 -(0xffff - 0xfffe)) = 13
// 
// The true exponent of the low part is 
//      true_exponent_of_high - (64 - shift_value)
//      -1 - (64-13) = -52
// Biased as a double, this is 0x3cb
// 
// 
// 
// So then lsb(T) must be >= 2^-51
// msb(Klog2_hi) <= 2^12
// 
//              +--------+---------+
//              |       51 bits    | <== largest T
//              +--------+---------+
//              | 9 bits | 42 bits | <== smallest T
// +------------+----------------+-+
// |  13 bits   | 50 bits        | |
// +------------+----------------+-+



// Special Cases
//==============================================================

//                                   double     float
// overflow                          error 24   30

// underflow                         error 25   31

// X zero  Y zero
//  +0     +0                 +1     error 26   32
//  -0     +0                 +1     error 26   32
//  +0     -0                 +1     error 26   32
//  -0     -0                 +1     error 26   32

// X zero  Y negative
//  +0     -odd integer       +inf   error 27   33  divide-by-zero
//  -0     -odd integer       -inf   error 27   33  divide-by-zero
//  +0     !-odd integer      +inf   error 27   33  divide-by-zero
//  -0     !-odd integer      +inf   error 27   33  divide-by-zero
//  +0     -inf               +inf   error 27   33  divide-by-zero
//  -0     -inf               +inf   error 27   33  divide-by-zero

// X zero  Y positve
//  +0     +odd integer       +0
//  -0     +odd integer       -0
//  +0     !+odd integer      +0
//  -0     !+odd integer      +0
//  +0     +inf               +0
//  -0     +inf               +0
//  +0     Y NaN              quiet Y               invalid if Y SNaN
//  -0     Y NaN              quiet Y               invalid if Y SNaN

// X one
//  -1     Y inf              +1
//  -1     Y NaN              quiet Y               invalid if Y SNaN
//  +1     Y NaN              +1                    invalid if Y SNaN
//  +1     Y any else         +1

// X -     Y not integer      QNAN   error 28   34  invalid

// X NaN   Y 0                +1     error 29   35
// X NaN   Y NaN              quiet X               invalid if X or Y SNaN
// X NaN   Y any else         quiet X               invalid if X SNaN
// X !+1   Y NaN              quiet Y               invalid if Y SNaN


// X +inf  Y >0               +inf
// X -inf  Y >0, !odd integer +inf
// X -inf  Y >0, odd integer  -inf

// X +inf  Y <0               +0
// X -inf  Y <0, !odd integer +0
// X -inf  Y <0, odd integer  -0

// X +inf  Y =0               +1
// X -inf  Y =0               +1

// |X|<1   Y +inf             +0
// |X|<1   Y -inf             +inf
// |X|>1   Y +inf             +inf
// |X|>1   Y -inf             +0

// X any   Y =0               +1

// Assembly macros
//==============================================================

// integer registers used

pow_AD_Tt                 = r33
pow_GR_FFF7               = r34
pow_GR_exp_Y              = r34 // duplicate
pow_GR_17ones             = r35

pow_AD_P                  = r36
pow_AD_Q                  = r37
pow_AD_tbl1               = r38
pow_AD_tbl2               = r39
pow_GR_exp_X              = r40
pow_GR_true_exp_X         = r40 // duplicate

pow_GR_offset             = r41
pow_GR_exp_Xm1            = r42
pow_GR_sig_X              = r43
pow_GR_signexp_X          = r44
pow_GR_xneg_yodd          = r45

pow_GR_signexp_Xm1        = r46
pow_GR_int_W1             = r47
pow_GR_int_W2             = r48
pow_GR_int_N              = r49
pow_GR_index1             = r50

pow_GR_index2             = r51
pow_AD_T1                 = r52
pow_AD_T2                 = r53
pow_int_GR_M              = r54
pow_GR_10033              = r55

pow_GR_16ones             = r56
pow_GR_sig_int_Y          = r57
pow_GR_sign_Y_Gpr         = r58
pow_GR_17ones_m1          = r59
pow_GR_one                = r60
pow_GR_sign_Y             = r60 

pow_GR_signexp_Y_Gpr      = r61 
pow_GR_exp_Y_Gpr          = r62 
pow_GR_true_exp_Y_Gpr     = r63 
pow_GR_signexp_Y          = r64 
pow_GR_x_one              = r66 
pow_GR_y_zero             = r67 
pow_GR_big_pos            = r69
pow_GR_big_neg            = r70

GR_SAVE_B0                = r65
GR_SAVE_GP                = r66
GR_SAVE_PFS               = r67

GR_Parameter_X            = r68
GR_Parameter_Y            = r69
GR_Parameter_RESULT       = r70
pow_GR_tag                = r71


// floating point registers used

POW_B                     = f32
POW_NORM_X                = f33
POW_Xm1                   = f34
POW_r1                    = f34
POW_P4                    = f35

POW_P5                    = f36
POW_NORM_Y                = f37
POW_Q2                    = f38
POW_Q3                    = f39
POW_P2                    = f40

POW_P3                    = f41
POW_P0                    = f42
POW_log2_lo               = f43
POW_r                     = f44
POW_Q0_half               = f45

POW_Q1                    = f46  
POW_tmp                   = f47  
POW_log2_hi               = f48
POW_Q4                    = f49
POW_P1                    = f50

POW_log2_by_128_hi        = f51
POW_inv_log2_by_128       = f52
POW_rsq                   = f53
POW_Yrcub                 = f54
POW_log2_by_128_lo        = f55

POW_v6                    = f56
POW_xsq                   = f57
POW_v4                    = f58
POW_v2                    = f59
POW_T                     = f60

POW_Tt                    = f61
POW_RSHF                  = f62
POW_v21ps                 = f63
POW_s4                    = f64
POW_twoV                  = f65

POW_U                     = f66
POW_G                     = f67
POW_delta                 = f68
POW_v3                    = f69
POW_V                     = f70

POW_p                     = f71
POW_Z1                    = f72
POW_e3                    = f73
POW_e2                    = f74
POW_Z2                    = f75

POW_e1                    = f76
POW_W1                    = f77
POW_UmZ2                  = f78
POW_W2                    = f79
POW_Z3                    = f80

POW_int_W1                = f81
POW_e12                   = f82
POW_int_W2                = f83
POW_UmZ2pV                = f84
POW_Z3sq                  = f85

POW_e123                  = f86
POW_N1float               = f87
POW_N2float               = f88
POW_f3                    = f89
POW_q                     = f90

POW_s1                    = f91
POW_Nfloat                = f92
POW_s2                    = f93
POW_f2                    = f94
POW_f1                    = f95

POW_T1                    = f96
POW_T2                    = f97
POW_2M                    = f98
POW_s                     = f99
POW_f12                   = f100

POW_ssq                   = f101
POW_T1T2                  = f102
POW_1ps                   = f103
POW_A                     = f104
POW_es                    = f105

POW_Xp1                   = f106
POW_int_K                 = f107
POW_K                     = f108
POW_f123                  = f109
POW_Gpr                   = f110

POW_Y_Gpr                 = f111 
POW_int_Y                 = f112
POW_2Mqp1                 = f113

POW_float_int_Y           = f116
POW_ftz_urm_f8            = f117
POW_wre_urm_f8            = f118
POW_big_neg               = f119
POW_big_pos               = f120


// Data tables
//==============================================================

.data

.align 16

pow_table_P:
data8 0x8000F7B249FF332D, 0x0000BFFC  // P_5
data8 0xAAAAAAA9E7902C7F, 0x0000BFFC  // P_3
data8 0x80000000000018E5, 0x0000BFFD  // P_1
data8 0xb8aa3b295c17f0bc, 0x00004006  // inv_ln2_by_128


data8 0x3FA5555555554A9E // Q_2
data8 0x3F8111124F4DD9F9 // Q_3
data8 0x3FE0000000000000 // Q_0
data8 0x3FC5555555554733 // Q_1
data8 0x3F56C16D9360FFA0 // Q_4
data8 0x43e8000000000000 // Right shift constant for exp
data8 0xc9e3b39803f2f6af, 0x00003fb7  // ln2_by_128_lo
data8 0x0000000000000000 // pad to eliminate bank conflicts with pow_table_Q
data8 0x0000000000000000 // pad to eliminate bank conflicts with pow_table_Q

pow_table_Q:
data8 0x9249FE7F0DC423CF, 0x00003FFC  // P_4
data8 0xCCCCCCCC4ED2BA7F, 0x00003FFC  // P_2
data8 0xAAAAAAAAAAAAB505, 0x00003FFD  // P_0
data8 0x3fe62e42fefa39e8, 0x3cccd5e4f1d9cc02 // log2 hi lo =  +6.93147e-001
data8 0xb17217f7d1cf79ab, 0x00003ff7  // ln2_by_128_hi


pow_Tt:
data8 0x3f60040155d58800, 0x3c93bce0ce3ddd81 // log(1/frcpa(1+0/256))=  +1.95503e-003
data8 0x3f78121214586a00, 0x3cb540e0a5cfc9bc // log(1/frcpa(1+1/256))=  +5.87661e-003
data8 0x3f841929f9683200, 0x3cbdf1d57404da1f // log(1/frcpa(1+2/256))=  +9.81362e-003
data8 0x3f8c317384c75f00, 0x3c69806208c04c22 // log(1/frcpa(1+3/256))=  +1.37662e-002
data8 0x3f91a6b91ac73380, 0x3c7874daa716eb32 // log(1/frcpa(1+4/256))=  +1.72376e-002
data8 0x3f95ba9a5d9ac000, 0x3cacbb84e08d78ac // log(1/frcpa(1+5/256))=  +2.12196e-002
data8 0x3f99d2a807432580, 0x3cbcf80538b441e1 // log(1/frcpa(1+6/256))=  +2.52177e-002
data8 0x3f9d6b2725979800, 0x3c6095e5c8f8f359 // log(1/frcpa(1+7/256))=  +2.87291e-002
data8 0x3fa0c58fa19dfa80, 0x3cb4c5d4e9d0dda2 // log(1/frcpa(1+8/256))=  +3.27573e-002
data8 0x3fa2954c78cbce00, 0x3caa932b860ab8d6 // log(1/frcpa(1+9/256))=  +3.62953e-002
data8 0x3fa4a94d2da96c40, 0x3ca670452b76bbd5 // log(1/frcpa(1+10/256))=  +4.03542e-002
data8 0x3fa67c94f2d4bb40, 0x3ca84104f9941798 // log(1/frcpa(1+11/256))=  +4.39192e-002
data8 0x3fa85188b630f040, 0x3cb40a882cbf0153 // log(1/frcpa(1+12/256))=  +4.74971e-002
data8 0x3faa6b8abe73af40, 0x3c988d46e25c9059 // log(1/frcpa(1+13/256))=  +5.16017e-002
data8 0x3fac441e06f72a80, 0x3cae3e930a1a2a96 // log(1/frcpa(1+14/256))=  +5.52072e-002
data8 0x3fae1e6713606d00, 0x3c8a796f6283b580 // log(1/frcpa(1+15/256))=  +5.88257e-002
data8 0x3faffa6911ab9300, 0x3c5193070351e88a // log(1/frcpa(1+16/256))=  +6.24574e-002
data8 0x3fb0ec139c5da600, 0x3c623f2a75eb992d // log(1/frcpa(1+17/256))=  +6.61022e-002
data8 0x3fb1dbd2643d1900, 0x3ca649b2ef8927f0 // log(1/frcpa(1+18/256))=  +6.97605e-002
data8 0x3fb2cc7284fe5f00, 0x3cbc5e86599513e2 // log(1/frcpa(1+19/256))=  +7.34321e-002
data8 0x3fb3bdf5a7d1ee60, 0x3c90bd4bb69dada3 // log(1/frcpa(1+20/256))=  +7.71173e-002
data8 0x3fb4b05d7aa012e0, 0x3c54e377c9b8a54f // log(1/frcpa(1+21/256))=  +8.08161e-002
data8 0x3fb580db7ceb5700, 0x3c7fdb2f98354cde // log(1/frcpa(1+22/256))=  +8.39975e-002
data8 0x3fb674f089365a60, 0x3cb9994c9d3301c1 // log(1/frcpa(1+23/256))=  +8.77219e-002
data8 0x3fb769ef2c6b5680, 0x3caaec639db52a79 // log(1/frcpa(1+24/256))=  +9.14602e-002
data8 0x3fb85fd927506a40, 0x3c9f9f99a3cf8e25 // log(1/frcpa(1+25/256))=  +9.52125e-002
data8 0x3fb9335e5d594980, 0x3ca15c3abd47d99a // log(1/frcpa(1+26/256))=  +9.84401e-002
data8 0x3fba2b0220c8e5e0, 0x3cb4ca639adf6fc3 // log(1/frcpa(1+27/256))=  +1.02219e-001
data8 0x3fbb0004ac1a86a0, 0x3ca7cb81bf959a59 // log(1/frcpa(1+28/256))=  +1.05469e-001
data8 0x3fbbf968769fca00, 0x3cb0c646c121418e // log(1/frcpa(1+29/256))=  +1.09274e-001
data8 0x3fbccfedbfee13a0, 0x3ca0465fce24ab4b // log(1/frcpa(1+30/256))=  +1.12548e-001
data8 0x3fbda727638446a0, 0x3c82803f4e2e6603 // log(1/frcpa(1+31/256))=  +1.15832e-001
data8 0x3fbea3257fe10f60, 0x3cb986a3f2313d1a // log(1/frcpa(1+32/256))=  +1.19677e-001
data8 0x3fbf7be9fedbfde0, 0x3c97d16a6a621cf4 // log(1/frcpa(1+33/256))=  +1.22985e-001
data8 0x3fc02ab352ff25f0, 0x3c9cc6baad365600 // log(1/frcpa(1+34/256))=  +1.26303e-001
data8 0x3fc097ce579d2040, 0x3cb9ba16d329440b // log(1/frcpa(1+35/256))=  +1.29633e-001
data8 0x3fc1178e8227e470, 0x3cb7bc671683f8e6 // log(1/frcpa(1+36/256))=  +1.33531e-001
data8 0x3fc185747dbecf30, 0x3c9d1116f66d2345 // log(1/frcpa(1+37/256))=  +1.36885e-001
data8 0x3fc1f3b925f25d40, 0x3c8162c9ef939ac6 // log(1/frcpa(1+38/256))=  +1.40250e-001
data8 0x3fc2625d1e6ddf50, 0x3caad3a1ec384fc3 // log(1/frcpa(1+39/256))=  +1.43627e-001
data8 0x3fc2d1610c868130, 0x3cb3ad997036941b // log(1/frcpa(1+40/256))=  +1.47015e-001
data8 0x3fc340c597411420, 0x3cbc2308262c7998 // log(1/frcpa(1+41/256))=  +1.50414e-001
data8 0x3fc3b08b6757f2a0, 0x3cb2170d6cdf0526 // log(1/frcpa(1+42/256))=  +1.53825e-001
data8 0x3fc40dfb08378000, 0x3c9bb453c4f7b685 // log(1/frcpa(1+43/256))=  +1.56677e-001
data8 0x3fc47e74e8ca5f70, 0x3cb836a48fdfce9d // log(1/frcpa(1+44/256))=  +1.60109e-001
data8 0x3fc4ef51f6466de0, 0x3ca07a43919aa64b // log(1/frcpa(1+45/256))=  +1.63553e-001
data8 0x3fc56092e02ba510, 0x3ca85006899d97b0 // log(1/frcpa(1+46/256))=  +1.67010e-001
data8 0x3fc5d23857cd74d0, 0x3ca30a5ba6e7abbe // log(1/frcpa(1+47/256))=  +1.70478e-001
data8 0x3fc6313a37335d70, 0x3ca905586f0ac97e // log(1/frcpa(1+48/256))=  +1.73377e-001
data8 0x3fc6a399dabbd380, 0x3c9b2c6657a96684 // log(1/frcpa(1+49/256))=  +1.76868e-001
data8 0x3fc70337dd3ce410, 0x3cb50bc52f55cdd8 // log(1/frcpa(1+50/256))=  +1.79786e-001
data8 0x3fc77654128f6120, 0x3cad2eb7c9a39efe // log(1/frcpa(1+51/256))=  +1.83299e-001
data8 0x3fc7e9d82a0b0220, 0x3cba127e90393c01 // log(1/frcpa(1+52/256))=  +1.86824e-001
data8 0x3fc84a6b759f5120, 0x3cbd7fd52079f706 // log(1/frcpa(1+53/256))=  +1.89771e-001
data8 0x3fc8ab47d5f5a300, 0x3cbfae141751a3de // log(1/frcpa(1+54/256))=  +1.92727e-001
data8 0x3fc91fe490965810, 0x3cb69cf30a1c319e // log(1/frcpa(1+55/256))=  +1.96286e-001
data8 0x3fc981634011aa70, 0x3ca5bb3d208bc42a // log(1/frcpa(1+56/256))=  +1.99261e-001
data8 0x3fc9f6c407089660, 0x3ca04d68658179a0 // log(1/frcpa(1+57/256))=  +2.02843e-001
data8 0x3fca58e729348f40, 0x3c99f5411546c286 // log(1/frcpa(1+58/256))=  +2.05838e-001
data8 0x3fcabb55c31693a0, 0x3cb9a5350eb327d5 // log(1/frcpa(1+59/256))=  +2.08842e-001
data8 0x3fcb1e104919efd0, 0x3c18965fcce7c406 // log(1/frcpa(1+60/256))=  +2.11855e-001
data8 0x3fcb94ee93e367c0, 0x3cb503716da45184 // log(1/frcpa(1+61/256))=  +2.15483e-001
data8 0x3fcbf851c0675550, 0x3cbdf1b3f7ab5378 // log(1/frcpa(1+62/256))=  +2.18516e-001
data8 0x3fcc5c0254bf23a0, 0x3ca7aab9ed0b1d7b // log(1/frcpa(1+63/256))=  +2.21558e-001
data8 0x3fccc000c9db3c50, 0x3c92a7a2a850072a // log(1/frcpa(1+64/256))=  +2.24609e-001
data8 0x3fcd244d99c85670, 0x3c9f6019120edf4c // log(1/frcpa(1+65/256))=  +2.27670e-001
data8 0x3fcd88e93fb2f450, 0x3c6affb96815e081 // log(1/frcpa(1+66/256))=  +2.30741e-001
data8 0x3fcdedd437eaef00, 0x3c72553595897976 // log(1/frcpa(1+67/256))=  +2.33820e-001
data8 0x3fce530effe71010, 0x3c90913b020fa182 // log(1/frcpa(1+68/256))=  +2.36910e-001
data8 0x3fceb89a1648b970, 0x3c837ba4045bfd25 // log(1/frcpa(1+69/256))=  +2.40009e-001
data8 0x3fcf1e75fadf9bd0, 0x3cbcea6d13e0498d // log(1/frcpa(1+70/256))=  +2.43117e-001
data8 0x3fcf84a32ead7c30, 0x3ca5e3a67b3c6d77 // log(1/frcpa(1+71/256))=  +2.46235e-001
data8 0x3fcfeb2233ea07c0, 0x3cba0c6f0049c5a6 // log(1/frcpa(1+72/256))=  +2.49363e-001
data8 0x3fd028f9c7035c18, 0x3cb0a30b06677ff6 // log(1/frcpa(1+73/256))=  +2.52501e-001
data8 0x3fd05c8be0d96358, 0x3ca0f1c77ccb5865 // log(1/frcpa(1+74/256))=  +2.55649e-001
data8 0x3fd085eb8f8ae790, 0x3cbd513f45fe7a97 // log(1/frcpa(1+75/256))=  +2.58174e-001
data8 0x3fd0b9c8e32d1910, 0x3c927449047ca006 // log(1/frcpa(1+76/256))=  +2.61339e-001
data8 0x3fd0edd060b78080, 0x3c89b52d8435f53e // log(1/frcpa(1+77/256))=  +2.64515e-001
data8 0x3fd122024cf00638, 0x3cbdd976fabda4bd // log(1/frcpa(1+78/256))=  +2.67701e-001
data8 0x3fd14be2927aecd0, 0x3cb02f90ad0bc471 // log(1/frcpa(1+79/256))=  +2.70257e-001
data8 0x3fd180618ef18ad8, 0x3cbd003792c71a98 // log(1/frcpa(1+80/256))=  +2.73461e-001
data8 0x3fd1b50bbe2fc638, 0x3ca9ae64c6403ead // log(1/frcpa(1+81/256))=  +2.76675e-001
data8 0x3fd1df4cc7cf2428, 0x3cb43f0455f7e395 // log(1/frcpa(1+82/256))=  +2.79254e-001
data8 0x3fd214456d0eb8d0, 0x3cb0fbd748d75d30 // log(1/frcpa(1+83/256))=  +2.82487e-001
data8 0x3fd23ec5991eba48, 0x3c906edd746b77e2 // log(1/frcpa(1+84/256))=  +2.85081e-001
data8 0x3fd2740d9f870af8, 0x3ca9802e6a00a670 // log(1/frcpa(1+85/256))=  +2.88333e-001
data8 0x3fd29ecdabcdfa00, 0x3cacecef70890cfa // log(1/frcpa(1+86/256))=  +2.90943e-001
data8 0x3fd2d46602adcce8, 0x3cb97911955f3521 // log(1/frcpa(1+87/256))=  +2.94214e-001
data8 0x3fd2ff66b04ea9d0, 0x3cb12dabe191d1c9 // log(1/frcpa(1+88/256))=  +2.96838e-001
data8 0x3fd335504b355a30, 0x3cbdf9139df924ec // log(1/frcpa(1+89/256))=  +3.00129e-001
data8 0x3fd360925ec44f58, 0x3cb253e68977a1e3 // log(1/frcpa(1+90/256))=  +3.02769e-001
data8 0x3fd38bf1c3337e70, 0x3cb3d283d2a2da21 // log(1/frcpa(1+91/256))=  +3.05417e-001
data8 0x3fd3c25277333180, 0x3cadaa5b035eae27 // log(1/frcpa(1+92/256))=  +3.08735e-001
data8 0x3fd3edf463c16838, 0x3cb983d680d3c108 // log(1/frcpa(1+93/256))=  +3.11399e-001
data8 0x3fd419b423d5e8c0, 0x3cbc86dd921c139d // log(1/frcpa(1+94/256))=  +3.14069e-001
data8 0x3fd44591e0539f48, 0x3c86a76d6dc2782e // log(1/frcpa(1+95/256))=  +3.16746e-001
data8 0x3fd47c9175b6f0a8, 0x3cb59a2e013c6b5f // log(1/frcpa(1+96/256))=  +3.20103e-001
data8 0x3fd4a8b341552b08, 0x3c93f1e86e468694 // log(1/frcpa(1+97/256))=  +3.22797e-001
data8 0x3fd4d4f390890198, 0x3cbf5e4ea7c5105a // log(1/frcpa(1+98/256))=  +3.25498e-001
data8 0x3fd501528da1f960, 0x3cbf58da53e9ad10 // log(1/frcpa(1+99/256))=  +3.28206e-001
data8 0x3fd52dd06347d4f0, 0x3cb98a28cebf6eef // log(1/frcpa(1+100/256))=  +3.30921e-001
data8 0x3fd55a6d3c7b8a88, 0x3c9c76b67c2d1fd4 // log(1/frcpa(1+101/256))=  +3.33644e-001
data8 0x3fd5925d2b112a58, 0x3c9029616a4331b8 // log(1/frcpa(1+102/256))=  +3.37058e-001
data8 0x3fd5bf406b543db0, 0x3c9fb8292ecfc820 // log(1/frcpa(1+103/256))=  +3.39798e-001
data8 0x3fd5ec433d5c35a8, 0x3cb71a1229d17eec // log(1/frcpa(1+104/256))=  +3.42545e-001
data8 0x3fd61965cdb02c18, 0x3cbba94fe1dbb8d2 // log(1/frcpa(1+105/256))=  +3.45300e-001
data8 0x3fd646a84935b2a0, 0x3c9ee496d2c9ae57 // log(1/frcpa(1+106/256))=  +3.48063e-001
data8 0x3fd6740add31de90, 0x3cb1da3a6c7a9dfd // log(1/frcpa(1+107/256))=  +3.50833e-001
data8 0x3fd6a18db74a58c0, 0x3cb494c257add8dc // log(1/frcpa(1+108/256))=  +3.53610e-001
data8 0x3fd6cf31058670e8, 0x3cb0b244a70a8da9 // log(1/frcpa(1+109/256))=  +3.56396e-001
data8 0x3fd6f180e852f0b8, 0x3c9db7aefa866720 // log(1/frcpa(1+110/256))=  +3.58490e-001
data8 0x3fd71f5d71b894e8, 0x3cbe91c4bf324957 // log(1/frcpa(1+111/256))=  +3.61289e-001
data8 0x3fd74d5aefd66d58, 0x3cb06b3d9bfac023 // log(1/frcpa(1+112/256))=  +3.64096e-001
data8 0x3fd77b79922bd378, 0x3cb727d8804491f4 // log(1/frcpa(1+113/256))=  +3.66911e-001
data8 0x3fd7a9b9889f19e0, 0x3ca2ef22df5bc543 // log(1/frcpa(1+114/256))=  +3.69734e-001
data8 0x3fd7d81b037eb6a0, 0x3cb8fd3ba07a7ece // log(1/frcpa(1+115/256))=  +3.72565e-001
data8 0x3fd8069e33827230, 0x3c8bd1e25866e61a // log(1/frcpa(1+116/256))=  +3.75404e-001
data8 0x3fd82996d3ef8bc8, 0x3ca5aab9f5928928 // log(1/frcpa(1+117/256))=  +3.77538e-001
data8 0x3fd85855776dcbf8, 0x3ca56f33337789d6 // log(1/frcpa(1+118/256))=  +3.80391e-001
data8 0x3fd8873658327cc8, 0x3cbb8ef0401db49d // log(1/frcpa(1+119/256))=  +3.83253e-001
data8 0x3fd8aa75973ab8c8, 0x3cbb9961f509a680 // log(1/frcpa(1+120/256))=  +3.85404e-001
data8 0x3fd8d992dc8824e0, 0x3cb220512a53732d // log(1/frcpa(1+121/256))=  +3.88280e-001
data8 0x3fd908d2ea7d9510, 0x3c985f0e513bfb5c // log(1/frcpa(1+122/256))=  +3.91164e-001
data8 0x3fd92c59e79c0e50, 0x3cb82e073fd30d63 // log(1/frcpa(1+123/256))=  +3.93332e-001
data8 0x3fd95bd750ee3ed0, 0x3ca4aa7cdb6dd8a8 // log(1/frcpa(1+124/256))=  +3.96231e-001
data8 0x3fd98b7811a3ee58, 0x3caa93a5b660893e // log(1/frcpa(1+125/256))=  +3.99138e-001
data8 0x3fd9af47f33d4068, 0x3cac294b3b3190ba // log(1/frcpa(1+126/256))=  +4.01323e-001
data8 0x3fd9df270c1914a0, 0x3cbe1a58fd0cd67e // log(1/frcpa(1+127/256))=  +4.04245e-001
data8 0x3fda0325ed14fda0, 0x3cb1efa7950fb57e // log(1/frcpa(1+128/256))=  +4.06442e-001
data8 0x3fda33440224fa78, 0x3c8915fe75e7d477 // log(1/frcpa(1+129/256))=  +4.09379e-001
data8 0x3fda57725e80c380, 0x3ca72bd1062b1b7f // log(1/frcpa(1+130/256))=  +4.11587e-001
data8 0x3fda87d0165dd198, 0x3c91f7845f58dbad // log(1/frcpa(1+131/256))=  +4.14539e-001
data8 0x3fdaac2e6c03f890, 0x3cb6f237a911c509 // log(1/frcpa(1+132/256))=  +4.16759e-001
data8 0x3fdadccc6fdf6a80, 0x3c90ddc4b7687169 // log(1/frcpa(1+133/256))=  +4.19726e-001
data8 0x3fdb015b3eb1e790, 0x3c692dd7d90e1e8e // log(1/frcpa(1+134/256))=  +4.21958e-001
data8 0x3fdb323a3a635948, 0x3c6f85655cbe14de // log(1/frcpa(1+135/256))=  +4.24941e-001
data8 0x3fdb56fa04462908, 0x3c95252d841994de // log(1/frcpa(1+136/256))=  +4.27184e-001
data8 0x3fdb881aa659bc90, 0x3caa53a745a3642f // log(1/frcpa(1+137/256))=  +4.30182e-001
data8 0x3fdbad0bef3db160, 0x3cb32f2540dcc16a // log(1/frcpa(1+138/256))=  +4.32437e-001
data8 0x3fdbd21297781c28, 0x3cbd8e891e106f1d // log(1/frcpa(1+139/256))=  +4.34697e-001
data8 0x3fdc039236f08818, 0x3c809435af522ba7 // log(1/frcpa(1+140/256))=  +4.37718e-001
data8 0x3fdc28cb1e4d32f8, 0x3cb3944752fbd81e // log(1/frcpa(1+141/256))=  +4.39990e-001
data8 0x3fdc4e19b84723c0, 0x3c9a465260cd3fe5 // log(1/frcpa(1+142/256))=  +4.42267e-001
data8 0x3fdc7ff9c74554c8, 0x3c92447d5b6ca369 // log(1/frcpa(1+143/256))=  +4.45311e-001
data8 0x3fdca57b64e9db00, 0x3cb44344a8a00c82 // log(1/frcpa(1+144/256))=  +4.47600e-001
data8 0x3fdccb130a5ceba8, 0x3cbefaddfb97b73f // log(1/frcpa(1+145/256))=  +4.49895e-001
data8 0x3fdcf0c0d18f3268, 0x3cbd3e7bfee57898 // log(1/frcpa(1+146/256))=  +4.52194e-001
data8 0x3fdd232075b5a200, 0x3c9222599987447c // log(1/frcpa(1+147/256))=  +4.55269e-001
data8 0x3fdd490246defa68, 0x3cabafe9a767a80d // log(1/frcpa(1+148/256))=  +4.57581e-001
data8 0x3fdd6efa918d25c8, 0x3cb58a2624e1c6fd // log(1/frcpa(1+149/256))=  +4.59899e-001
data8 0x3fdd9509707ae528, 0x3cbdc3babce578e7 // log(1/frcpa(1+150/256))=  +4.62221e-001
data8 0x3fddbb2efe92c550, 0x3cb0ac0943c434a4 // log(1/frcpa(1+151/256))=  +4.64550e-001
data8 0x3fddee2f3445e4a8, 0x3cbba9d07ce820e8 // log(1/frcpa(1+152/256))=  +4.67663e-001
data8 0x3fde148a1a2726c8, 0x3cb6537e3375b205 // log(1/frcpa(1+153/256))=  +4.70004e-001
data8 0x3fde3afc0a49ff38, 0x3cbfed5518dbc20e // log(1/frcpa(1+154/256))=  +4.72350e-001
data8 0x3fde6185206d5168, 0x3cb6572601f73d5c // log(1/frcpa(1+155/256))=  +4.74702e-001
data8 0x3fde882578823d50, 0x3c9b24abd4584d1a // log(1/frcpa(1+156/256))=  +4.77060e-001
data8 0x3fdeaedd2eac9908, 0x3cb0ceb5e4d2c8f7 // log(1/frcpa(1+157/256))=  +4.79423e-001
data8 0x3fded5ac5f436be0, 0x3ca72f21f1f5238e // log(1/frcpa(1+158/256))=  +4.81792e-001
data8 0x3fdefc9326d16ab8, 0x3c85081a1639a45c // log(1/frcpa(1+159/256))=  +4.84166e-001
data8 0x3fdf2391a21575f8, 0x3cbf11015bdd297a // log(1/frcpa(1+160/256))=  +4.86546e-001
data8 0x3fdf4aa7ee031928, 0x3cb3795bc052a2d1 // log(1/frcpa(1+161/256))=  +4.88932e-001
data8 0x3fdf71d627c30bb0, 0x3c35c61f0f5a88f3 // log(1/frcpa(1+162/256))=  +4.91323e-001
data8 0x3fdf991c6cb3b378, 0x3c97d99419be6028 // log(1/frcpa(1+163/256))=  +4.93720e-001
data8 0x3fdfc07ada69a908, 0x3cbfe9341ded70b1 // log(1/frcpa(1+164/256))=  +4.96123e-001
data8 0x3fdfe7f18eb03d38, 0x3cb85718a640c33f // log(1/frcpa(1+165/256))=  +4.98532e-001
data8 0x3fe007c053c5002c, 0x3cb3addc9c065f09 // log(1/frcpa(1+166/256))=  +5.00946e-001
data8 0x3fe01b942198a5a0, 0x3c9d5aa4c77da6ac // log(1/frcpa(1+167/256))=  +5.03367e-001
data8 0x3fe02f74400c64e8, 0x3cb5a0ee4450ef52 // log(1/frcpa(1+168/256))=  +5.05793e-001
data8 0x3fe04360be7603ac, 0x3c9dd00c35630fe0 // log(1/frcpa(1+169/256))=  +5.08225e-001
data8 0x3fe05759ac47fe30, 0x3cbd063e1f0bd82c // log(1/frcpa(1+170/256))=  +5.10663e-001
data8 0x3fe06b5f1911cf50, 0x3cae8da674af5289 // log(1/frcpa(1+171/256))=  +5.13107e-001
data8 0x3fe078bf0533c568, 0x3c62241edf5fd1f7 // log(1/frcpa(1+172/256))=  +5.14740e-001
data8 0x3fe08cd9687e7b0c, 0x3cb3007febcca227 // log(1/frcpa(1+173/256))=  +5.17194e-001
data8 0x3fe0a10074cf9018, 0x3ca496e84603816b // log(1/frcpa(1+174/256))=  +5.19654e-001
data8 0x3fe0b5343a234474, 0x3cb46098d14fc90a // log(1/frcpa(1+175/256))=  +5.22120e-001
data8 0x3fe0c974c89431cc, 0x3cac0a7cdcbb86c6 // log(1/frcpa(1+176/256))=  +5.24592e-001
data8 0x3fe0ddc2305b9884, 0x3cb2f753210410ff // log(1/frcpa(1+177/256))=  +5.27070e-001
data8 0x3fe0eb524bafc918, 0x3c88affd6682229e // log(1/frcpa(1+178/256))=  +5.28726e-001
data8 0x3fe0ffb54213a474, 0x3cadeefbab9af993 // log(1/frcpa(1+179/256))=  +5.31214e-001
data8 0x3fe114253da97d9c, 0x3cbaf1c2b8bc160a // log(1/frcpa(1+180/256))=  +5.33709e-001
data8 0x3fe128a24f1d9afc, 0x3cb9cf4df375e650 // log(1/frcpa(1+181/256))=  +5.36210e-001
data8 0x3fe1365252bf0864, 0x3c985a621d4be111 // log(1/frcpa(1+182/256))=  +5.37881e-001
data8 0x3fe14ae558b4a92c, 0x3ca104c4aa8977d1 // log(1/frcpa(1+183/256))=  +5.40393e-001
data8 0x3fe15f85a19c7658, 0x3cbadf26e540f375 // log(1/frcpa(1+184/256))=  +5.42910e-001
data8 0x3fe16d4d38c119f8, 0x3cb3aea11caec416 // log(1/frcpa(1+185/256))=  +5.44592e-001
data8 0x3fe18203c20dd130, 0x3cba82d1211d1d6d // log(1/frcpa(1+186/256))=  +5.47121e-001
data8 0x3fe196c7bc4b1f38, 0x3cb6267acc4f4f4a // log(1/frcpa(1+187/256))=  +5.49656e-001
data8 0x3fe1a4a738b7a33c, 0x3c858930213c987d // log(1/frcpa(1+188/256))=  +5.51349e-001
data8 0x3fe1b981c0c9653c, 0x3c9bc2a4a30f697b // log(1/frcpa(1+189/256))=  +5.53895e-001
data8 0x3fe1ce69e8bb1068, 0x3cb7ae6199cf2a00 // log(1/frcpa(1+190/256))=  +5.56447e-001
data8 0x3fe1dc619de06944, 0x3c6b50bb38388177 // log(1/frcpa(1+191/256))=  +5.58152e-001
data8 0x3fe1f160a2ad0da0, 0x3cbd05b2778a5e1d // log(1/frcpa(1+192/256))=  +5.60715e-001
data8 0x3fe2066d7740737c, 0x3cb32e828f9c6bd6 // log(1/frcpa(1+193/256))=  +5.63285e-001
data8 0x3fe2147dba47a390, 0x3cbd579851b8b672 // log(1/frcpa(1+194/256))=  +5.65001e-001
data8 0x3fe229a1bc5ebac0, 0x3cbb321be5237ce8 // log(1/frcpa(1+195/256))=  +5.67582e-001
data8 0x3fe237c1841a502c, 0x3cb3b56e0915ea64 // log(1/frcpa(1+196/256))=  +5.69306e-001
data8 0x3fe24cfce6f80d98, 0x3cb34a4d1a422919 // log(1/frcpa(1+197/256))=  +5.71898e-001
data8 0x3fe25b2c55cd5760, 0x3cb237401ea5015e // log(1/frcpa(1+198/256))=  +5.73630e-001
data8 0x3fe2707f4d5f7c40, 0x3c9d30f20acc8341 // log(1/frcpa(1+199/256))=  +5.76233e-001
data8 0x3fe285e0842ca380, 0x3cbc4d866d5f21c0 // log(1/frcpa(1+200/256))=  +5.78842e-001
data8 0x3fe294294708b770, 0x3cb85e14d5dc54fa // log(1/frcpa(1+201/256))=  +5.80586e-001
data8 0x3fe2a9a2670aff0c, 0x3c7e6f8f468bbf91 // log(1/frcpa(1+202/256))=  +5.83207e-001
data8 0x3fe2b7fb2c8d1cc0, 0x3c930ffcf63c8b65 // log(1/frcpa(1+203/256))=  +5.84959e-001
data8 0x3fe2c65a6395f5f4, 0x3ca0afe20b53d2d2 // log(1/frcpa(1+204/256))=  +5.86713e-001
data8 0x3fe2dbf557b0df40, 0x3cb646be1188fbc9 // log(1/frcpa(1+205/256))=  +5.89350e-001
data8 0x3fe2ea64c3f97654, 0x3c96516fa8df33b2 // log(1/frcpa(1+206/256))=  +5.91113e-001
data8 0x3fe3001823684d70, 0x3cb96d64e16d1360 // log(1/frcpa(1+207/256))=  +5.93762e-001
data8 0x3fe30e97e9a8b5cc, 0x3c98ef96bc97cca0 // log(1/frcpa(1+208/256))=  +5.95531e-001
data8 0x3fe32463ebdd34e8, 0x3caef1dc9a56c1bf // log(1/frcpa(1+209/256))=  +5.98192e-001
data8 0x3fe332f4314ad794, 0x3caa4f0ac5d5fa11 // log(1/frcpa(1+210/256))=  +5.99970e-001
data8 0x3fe348d90e7464cc, 0x3cbe7889f0516acd // log(1/frcpa(1+211/256))=  +6.02643e-001
data8 0x3fe35779f8c43d6c, 0x3ca96bbab7245411 // log(1/frcpa(1+212/256))=  +6.04428e-001
data8 0x3fe36621961a6a98, 0x3ca31f32262db9fb // log(1/frcpa(1+213/256))=  +6.06217e-001
data8 0x3fe37c299f3c3668, 0x3cb15c72c107ee29 // log(1/frcpa(1+214/256))=  +6.08907e-001
data8 0x3fe38ae2171976e4, 0x3cba42a2554b2dd4 // log(1/frcpa(1+215/256))=  +6.10704e-001
data8 0x3fe399a157a603e4, 0x3cb99c62286d8919 // log(1/frcpa(1+216/256))=  +6.12504e-001
data8 0x3fe3afccfe77b9d0, 0x3ca11048f96a43bd // log(1/frcpa(1+217/256))=  +6.15210e-001
data8 0x3fe3be9d503533b4, 0x3ca4022f47588c3e // log(1/frcpa(1+218/256))=  +6.17018e-001
data8 0x3fe3cd7480b4a8a0, 0x3cb4ba7afc2dc56a // log(1/frcpa(1+219/256))=  +6.18830e-001
data8 0x3fe3e3c43918f76c, 0x3c859673d064b8ba // log(1/frcpa(1+220/256))=  +6.21554e-001
data8 0x3fe3f2acb27ed6c4, 0x3cb55c6b452a16a8 // log(1/frcpa(1+221/256))=  +6.23373e-001
data8 0x3fe4019c2125ca90, 0x3cb8c367879c5a31 // log(1/frcpa(1+222/256))=  +6.25197e-001
data8 0x3fe4181061389720, 0x3cb2c17a79c5cc6c // log(1/frcpa(1+223/256))=  +6.27937e-001
data8 0x3fe42711518df544, 0x3ca5f38d47012fc5 // log(1/frcpa(1+224/256))=  +6.29769e-001
data8 0x3fe436194e12b6bc, 0x3cb9854d65a9b426 // log(1/frcpa(1+225/256))=  +6.31604e-001
data8 0x3fe445285d68ea68, 0x3ca3ff9b3a81cd81 // log(1/frcpa(1+226/256))=  +6.33442e-001
data8 0x3fe45bcc464c8938, 0x3cb0a2d8011a6c05 // log(1/frcpa(1+227/256))=  +6.36206e-001
data8 0x3fe46aed21f117fc, 0x3c8a2be41f8e9f3d // log(1/frcpa(1+228/256))=  +6.38053e-001
data8 0x3fe47a1527e8a2d0, 0x3cba4a83594fab09 // log(1/frcpa(1+229/256))=  +6.39903e-001
data8 0x3fe489445efffcc8, 0x3cbf306a23dcbcde // log(1/frcpa(1+230/256))=  +6.41756e-001
data8 0x3fe4a018bcb69834, 0x3ca46c9285029fd1 // log(1/frcpa(1+231/256))=  +6.44543e-001
data8 0x3fe4af5a0c9d65d4, 0x3cbbc1db897580e3 // log(1/frcpa(1+232/256))=  +6.46405e-001
data8 0x3fe4bea2a5bdbe84, 0x3cb84d880d7ef775 // log(1/frcpa(1+233/256))=  +6.48271e-001
data8 0x3fe4cdf28f10ac44, 0x3cb3ec4b7893ce1f // log(1/frcpa(1+234/256))=  +6.50140e-001
data8 0x3fe4dd49cf994058, 0x3c897224d59d3408 // log(1/frcpa(1+235/256))=  +6.52013e-001
data8 0x3fe4eca86e64a680, 0x3cbccf620f24f0cd // log(1/frcpa(1+236/256))=  +6.53889e-001
data8 0x3fe503c43cd8eb68, 0x3c3f872c65971084 // log(1/frcpa(1+237/256))=  +6.56710e-001
data8 0x3fe513356667fc54, 0x3cb9ca64cc3d52c8 // log(1/frcpa(1+238/256))=  +6.58595e-001
data8 0x3fe522ae0738a3d4, 0x3cbe708164c75968 // log(1/frcpa(1+239/256))=  +6.60483e-001
data8 0x3fe5322e26867854, 0x3cb9988ba4aea615 // log(1/frcpa(1+240/256))=  +6.62376e-001
data8 0x3fe541b5cb979808, 0x3ca1662e3a6b95f5 // log(1/frcpa(1+241/256))=  +6.64271e-001
data8 0x3fe55144fdbcbd60, 0x3cb3acd4ca45c1e0 // log(1/frcpa(1+242/256))=  +6.66171e-001
data8 0x3fe560dbc45153c4, 0x3cb4988947959fed // log(1/frcpa(1+243/256))=  +6.68074e-001
data8 0x3fe5707a26bb8c64, 0x3cb3017fe6607ba9 // log(1/frcpa(1+244/256))=  +6.69980e-001
data8 0x3fe587f60ed5b8fc, 0x3cbe7a3266366ed4 // log(1/frcpa(1+245/256))=  +6.72847e-001
data8 0x3fe597a7977c8f30, 0x3ca1e12b9959a90e // log(1/frcpa(1+246/256))=  +6.74763e-001
data8 0x3fe5a760d634bb88, 0x3cb7c365e53d9602 // log(1/frcpa(1+247/256))=  +6.76682e-001
data8 0x3fe5b721d295f10c, 0x3cb716c2551ccbf0 // log(1/frcpa(1+248/256))=  +6.78605e-001
data8 0x3fe5c6ea94431ef8, 0x3ca02b2ed0e28261 // log(1/frcpa(1+249/256))=  +6.80532e-001
data8 0x3fe5d6bb22ea86f4, 0x3caf43a8bbb2f974 // log(1/frcpa(1+250/256))=  +6.82462e-001
data8 0x3fe5e6938645d38c, 0x3cbcedc98821b333 // log(1/frcpa(1+251/256))=  +6.84397e-001
data8 0x3fe5f673c61a2ed0, 0x3caa385eef5f2789 // log(1/frcpa(1+252/256))=  +6.86335e-001
data8 0x3fe6065bea385924, 0x3cb11624f165c5b4 // log(1/frcpa(1+253/256))=  +6.88276e-001
data8 0x3fe6164bfa7cc068, 0x3cbad884f87073fa // log(1/frcpa(1+254/256))=  +6.90222e-001
data8 0x3fe62643fecf9740, 0x3cb78c51da12f4df // log(1/frcpa(1+255/256))=  +6.92171e-001


// Table 1 is 2^(index_1/128) where
// index_1 goes from 0 to 15
pow_tbl1:
data8 0x8000000000000000 , 0x00003FFF
data8 0x80B1ED4FD999AB6C , 0x00003FFF
data8 0x8164D1F3BC030773 , 0x00003FFF
data8 0x8218AF4373FC25EC , 0x00003FFF
data8 0x82CD8698AC2BA1D7 , 0x00003FFF
data8 0x8383594EEFB6EE37 , 0x00003FFF
data8 0x843A28C3ACDE4046 , 0x00003FFF
data8 0x84F1F656379C1A29 , 0x00003FFF
data8 0x85AAC367CC487B15 , 0x00003FFF
data8 0x8664915B923FBA04 , 0x00003FFF
data8 0x871F61969E8D1010 , 0x00003FFF
data8 0x87DB357FF698D792 , 0x00003FFF
data8 0x88980E8092DA8527 , 0x00003FFF
data8 0x8955EE03618E5FDD , 0x00003FFF
data8 0x8A14D575496EFD9A , 0x00003FFF
data8 0x8AD4C6452C728924 , 0x00003FFF


// Table 2 is 2^(index_1/8) where
// index_2 goes from 0 to 7
pow_tbl2:
data8 0x8000000000000000 , 0x00003FFF
data8 0x8B95C1E3EA8BD6E7 , 0x00003FFF
data8 0x9837F0518DB8A96F , 0x00003FFF
data8 0xA5FED6A9B15138EA , 0x00003FFF
data8 0xB504F333F9DE6484 , 0x00003FFF
data8 0xC5672A115506DADD , 0x00003FFF
data8 0xD744FCCAD69D6AF4 , 0x00003FFF
data8 0xEAC0C6E7DD24392F , 0x00003FFF

.global powf

.section .text
.proc  powf
.align 32

powf:

{ .mfi
          alloc         r32=ar.pfs,1,35,4,0 
          fms.s1 POW_Xm1 = f8,f1,f1   // Will be used for r1 if x>0
          mov           pow_GR_17ones  = 0x1FFFF
}
{ .mfi
          addl          pow_AD_P   = @ltoff(pow_table_P), gp
          fma.s1 POW_Xp1 = f8,f1,f1   // Will be used for r1 if x<0
          nop.i 999
;;
}


// Get exponent of x.  Will be used to calculate K.
{ .mfi
          getf.exp      pow_GR_signexp_X    = f8
          frcpa.s1      POW_B, p6   = f1,f8
          nop.i 999
}
{ .mfi
          ld8 pow_AD_P = [pow_AD_P]
          fma.s1        POW_NORM_X     = f8,f1,f0
          mov           pow_GR_FFF7    = 0xFFF7
}
;;



// Get significand of x.  Will be used to get index to fetch T, Tt.
// p13 = TRUE ==> X is unorm
// DOUBLE 0x10033  exponent limit at which y is an integer
// SINGLE 0x10016
{ .mfi
          getf.sig      pow_GR_sig_X        = f8
          fclass.m  p13,p0          = f8, 0x0b  // Test for x unorm
          addl pow_GR_10033                 = 0x10033, r0
}
{ .mfi
          mov           pow_GR_16ones   = 0xFFFF
          fma.s1        POW_NORM_Y     = f9,f1,f0
          nop.i 999
}
;;


// p14 = TRUE ==> X is ZERO
{ .mfi
          adds          pow_AD_Tt       = pow_Tt - pow_table_P,  pow_AD_P
          fclass.m  p14,p15          = f8, 0x07
          and           pow_GR_exp_X        = pow_GR_signexp_X, pow_GR_17ones
}
{ .mfi
          adds          pow_AD_Q       = pow_table_Q - pow_table_P,  pow_AD_P
          nop.f 999
          nop.i 999
}
;;

{ .mfi
          ldfe          POW_P5         = [pow_AD_P], 16
          fcmp.lt.s1 p8,p9 = f8, f0    // Test for x<0
          shl           pow_GR_offset       = pow_GR_sig_X, 1
}
{ .mib
          ldfe          POW_P4         = [pow_AD_Q], 16
          sub       pow_GR_true_exp_X       = pow_GR_exp_X, pow_GR_16ones
(p13)     br.cond.spnt POW_X_DENORM
}
;;


// Continue normal and denormal paths here
POW_COMMON:
// p11 = TRUE ==> Y is a NAN
{ .mfi
          ldfe          POW_P3         = [pow_AD_P], 16
          fclass.m.unc  p11,p0         = f9, 0xc3
          shr.u     pow_GR_offset           = pow_GR_offset,56
}
{ .mfi
          ldfe          POW_P2         = [pow_AD_Q], 16
          nop.f 999
          mov pow_GR_y_zero = 0
}
;;



// Compute xsq to decide later if |x|=1
// p11 = TRUE ==> Y is a NaN
{ .mfi
          setf.sig POW_int_K                = pow_GR_true_exp_X
(p15)     fms.s1        POW_r          = POW_B, POW_NORM_X,f1
          shladd pow_AD_Tt = pow_GR_offset, 4, pow_AD_Tt
}
{ .mfi
          nop.m 999
(p8)      fnma.s1        POW_Xm1       = POW_Xp1,f1,f0
          nop.i 999
}
;;



// p12 = TRUE if Y is ZERO
{ .mfi
          ldfe          POW_P1         = [pow_AD_P], 16
          fclass.m.unc  p12,p0              = f9, 0x07
          nop.i 999
}
{ .mfb
          ldfe          POW_P0         = [pow_AD_Q], 16
          fma.s1        POW_xsq = POW_NORM_X, POW_NORM_X, f0
(p11)     br.cond.spnt   POW_Y_NAN
}
;;


.pred.rel "mutex",p8,p9
// Get exponent of |x|-1 to use in comparison to 2^-8
{ .mmf
(p8)      getf.exp      pow_GR_signexp_Xm1  = POW_Xp1
(p9)      getf.exp      pow_GR_signexp_Xm1  = POW_Xm1
          fcvt.fx.s1   POW_int_Y            = POW_NORM_Y
}
;;


// p11 = TRUE ==> X is a NAN
{ .mfi
          ldfpd         POW_log2_hi, POW_log2_lo  = [pow_AD_Q], 16
          fclass.m.unc  p11,p0              = f8, 0xc3
          nop.i 999
}	
{ .mfi
          ldfpd  POW_T, POW_Tt              = [pow_AD_Tt], 16
          nop.f 999
(p12)     mov pow_GR_y_zero = 1
}
;;


// p14 = TRUE ==> X is zero
//    p15 = TRUE ==> X is zero AND Y is negative
//    p10 = TRUE ==> X is zero AND Y is >= zero 
//    p8  = TRUE ==> X is zero AND Y is zero
{ .mfi
          ldfe          POW_inv_log2_by_128 = [pow_AD_P], 16
(p14)     fcmp.lt.unc.s1 p15, p10           = f9,f0
(p14)     cmp.ne.unc p8,p0 = pow_GR_y_zero,r0
}
{ .mfi
          nop.m 999
          nop.f 999
          and       pow_GR_exp_Xm1          = pow_GR_signexp_Xm1, pow_GR_17ones
} 
;;


// Determine if we will use the |x| near 1 path (p6) or normal path (p7)
// p9  = TRUE ==> X is a NAN and Y is a zero
// p13 = TRUE ==> X is a NAN and Y is anything else
{ .mfi
          getf.exp  pow_GR_signexp_Y        = POW_NORM_Y 
(p11)     fclass.m.unc  p9,p13             = f9, 0x07
          cmp.lt.unc p6,p7                  = pow_GR_exp_Xm1, pow_GR_FFF7
}
{ .mfi
          ldfpd  POW_Q2, POW_Q3             = [pow_AD_P], 16
          fma.s1        POW_rsq             = POW_r, POW_r,f0
          nop.i 999
;;
}

// If on the x near 1 path, assign r1 to r and r1*r1 to rsq
{ .mfi
          ldfpd  POW_Q0_half, POW_Q1             = [pow_AD_P], 16
(p6)      fma.s1    POW_r                 = POW_r1, f1, f0
          nop.i 999
}
{ .mfb
          nop.m 999
(p6)      fma.s1    POW_rsq                 = POW_r1, POW_r1, f0
(p8)      br.cond.spnt POW_X_0_Y_0   // Branch if x zero and y zero
;;
}


{ .mfi
          ldfpd   POW_Q4, POW_RSHF          = [pow_AD_P], 16
(p7)      fma.s1 POW_v6                     = POW_r,  POW_P5, POW_P4
          and pow_GR_exp_Y                   = pow_GR_signexp_Y, pow_GR_17ones
}
{ .mfb
          nop.m 999
(p6)      fma.s1 POW_v6                     = POW_r1, POW_P5, POW_P4
(p9)      br.cond.spnt POW_X_NAN_Y_0
}
;;


{ .mfi
          nop.m 999
(p7)      fma.s1 POW_v4                     = POW_P3, POW_r,  POW_P2 
          andcm pow_GR_sign_Y               = pow_GR_signexp_Y, pow_GR_17ones
}
{ .mfi
          nop.m 999
(p6)      fma.s1 POW_v4                     = POW_P3, POW_r1, POW_P2 
          nop.i 999
}
;;

{ .mfi
          nop.m 999
          fcvt.xf POW_K                     = POW_int_K
          nop.i 999
}
{ .mfb
          nop.m 999
(p13)     fma.s f8                           = f8,f1,f0
(p13)     br.ret.spnt  b0    // Exit if x nan, y anything but zero
}
;;
          
// p10 = TRUE ==> X is zero  AND Y is positive
//  p8  = TRUE ==> X is zero  AND Y is outside integer range (treat as even int)
//                   return +0
//  p9  = TRUE ==> X is zero  AND Y is within integer range (may not be integer) 
{ .mfi
(p10)     cmp.gt.unc p8,p9                  =  pow_GR_exp_Y, pow_GR_10033
(p6)      fmerge.s POW_delta                 = f0,f0
          nop.i 999
}
{ .mfb
          nop.m 999
(p6)      fma.s1 POW_G                       = f0,f0,f0
(p12)     br.cond.spnt POW_Y_0   // Branch if y=zero, x not zero or nan
}
;;

{ .mfi
          getf.sig pow_GR_sig_int_Y         = POW_int_Y
          fnma.s1 POW_twoV                   = POW_NORM_Y, POW_rsq,f0
          nop.i 999
}
{ .mfi
          nop.m 999
          fma.s1 POW_U                      = POW_NORM_Y,POW_r,f0
          nop.i 999
}
;;

{ .mfi
          ldfe      POW_log2_by_128_lo      = [pow_AD_P], 16
(p6)      fma.s1 POW_v2                     = POW_P1, POW_r1, POW_P0 
          nop.i 999
}
{ .mfi
          ldfe          POW_log2_by_128_hi  = [pow_AD_Q], 16
(p7)      fma.s1 POW_v2                     = POW_P1, POW_r,  POW_P0 
          nop.i 999
}
;;


{ .mfi
          nop.m 999
          fcvt.xf   POW_float_int_Y               = POW_int_Y
          nop.i 999
}
{ .mfi
          nop.m 999
          fma.s1 POW_v3                     = POW_v6, POW_rsq,  POW_v4 
          adds          pow_AD_tbl1       = pow_tbl1 - pow_Tt,  pow_AD_Q
}
;;

{ .mfi
          nop.m 999
(p7)      fma.s1 POW_delta                  = POW_K, POW_log2_lo, POW_Tt
          nop.i 999
}
{ .mfi
          nop.m 999
(p7)      fma.s1 POW_G                      = POW_K, POW_log2_hi, POW_T 
          adds pow_AD_tbl2                  = pow_tbl2 - pow_tbl1,  pow_AD_tbl1
}
;;


{ .mfi
          nop.m 999
          fms.s1 POW_e2                     = POW_NORM_Y, POW_r, POW_U
          nop.i 999
}
{ .mfi
          nop.m 999
          fma.s1 POW_Z2                     = POW_twoV, POW_Q0_half, POW_U
          nop.i 999
}
;;

// p11 = TRUE ==> X is NEGATIVE but not inf
// p8  = TRUE ==> X is zero  AND Y is outside intger range (treat as even int)
//                return +0
{ .mfi
          nop.m 999
          fclass.m.unc  p11,p0              = f8, 0x1a
          nop.i 999
}
{ .mfb
          nop.m 999
(p8)      fma.s f8                          = f0,f0,f0
(p8)      br.ret.spnt b0
}
;;

{ .mfi 
          nop.m 999
          fma.s1 POW_Yrcub                 = POW_rsq, POW_U, f0
          nop.i 999
}
{ .mfi 
          nop.m 999
          fma.s1 POW_p                      = POW_rsq, POW_v3, POW_v2
          nop.i 999
}
;;


// p11 = TRUE ==> X is NEGATIVE but not inf
//    p12 = TRUE ==> X is NEGATIVE  AND  Y  already even int
//    p13 = TRUE ==> X is NEGATIVE  AND  Y possible int
{ .mfi
          nop.m 999
          fma.s1 POW_Z1                     = POW_NORM_Y, POW_G, f0
(p11)     cmp.gt.unc  p12,p13                = pow_GR_exp_Y, pow_GR_10033
}
{ .mfi
          nop.m 999
          fma.s1 POW_e3                     = POW_NORM_Y, POW_delta, f0
          nop.i 999
}
;;

// p9  = TRUE ==> X is zero  AND Y is within integer range (may not be integer)
//    p6 = TRUE ==>  X is zero  AND  Y is an integer (may be even or odd)
//    p7 = TRUE ==>  X is zero  AND  Y is NOT an integer, return +0
{ .mfi
          nop.m 999
(p9)      fcmp.eq.unc.s1 p6,p7             = POW_float_int_Y,  POW_NORM_Y
          nop.i 999
}
{ .mfi 
          nop.m 999
          fma.s1 POW_Gpr                    = POW_G, f1, POW_r
          nop.i 999
}
;;

// By adding RSHF (1.1000...*2^63) we put integer part in rightmost significand
{ .mfi
          nop.m 999
          fma.s1 POW_W2  = POW_Z2, POW_inv_log2_by_128, POW_RSHF
          nop.i 999
}
{ .mfi
          nop.m 999
          fms.s1 POW_UmZ2                   = POW_U, f1, POW_Z2
          nop.i 999
}
;;


// If x=0 and y>0, test y and flag denormal
// p6  = TRUE ==>  X is zero  AND  Y is an integer (may be even or odd)
//    p8 = TRUE ==>  X is zero  AND  Y is an odd  integer
//    p9 = TRUE ==>  X is zero  AND  Y is an even integer
{ .mfi
          nop.m 999
(p10)     fcmp.eq.s0 p15,p0 = f9,f0
(p6)      tbit.nz.unc  p8,p9                = pow_GR_sig_int_Y,0
}
{ .mfi
          nop.m 999
          fma.s1 POW_Z3                      = POW_p, POW_Yrcub, f0
          nop.i 999
}
;;

// By adding RSHF (1.1000...*2^63) we put integer part in rightmost significand
{ .mfi
          nop.m 999
          fms.s1 POW_e1                     = POW_NORM_Y, POW_G, POW_Z1
          nop.i 999
}
{ .mfi
          nop.m 99