riteInt32(EmfPlusStream, flags);
            WriteInt32(EmfPlusStream, matrixPresent);
            WriteInt32(EmfPlusStream, glyphCount);
            WriteBytes(EmfPlusStream, textData, sizeText);
            WriteBytes(EmfPlusStream, positionData, sizePositions);

            if (matrix != NULL)
            {
                WriteMatrix(EmfPlusStream, *matrix);
            }

            // align
            if ((glyphCount & 0x01) != 0)
            {
                sizeText = 0;
                EmfPlusStream->Write(&sizeText, sizeof(WCHAR), NULL);
            }

            WriteGdiComment();  // is down-level for this record

            if (EmfPlusStream->IsValid())
            {
                return Ok;
            }
            SetValid(FALSE);
        }
        WARNING(("Failed to write DrawDriverString record"));
        return Win32Error;
    }
    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   IMetafileRecord interface method - RecordSave.
*
* Arguments:
*
*   [IN]  gstate - the pushed state (restore to state before this)
*
* Return Value:
*
*   NONE
*
* Created:
*
*   6/15/1999 DCurtis
*
\**************************************************************************/
GpStatus
MetafileRecorder::RecordSave(
    INT         gstate
    )
{
    // If doing down-level only, then EmfPlusStream will be NULL
    if (EmfPlusStream != NULL)
    {
        if (IsValid())
        {
            UINT32              dataSize = sizeof(UINT32/* index */);
            EmfPlusRecordType   type     = EmfPlusRecordTypeSave;
            INT                 index    = SaveRestoreStack.GetCount();

            SaveRestoreStack.Add(gstate);

            WriteRecordHeader(dataSize, type);
            WriteInt32(EmfPlusStream, index);
            // WriteGdiComment(); no down-level for this record

            if (EmfPlusStream->IsValid())
            {
                return Ok;
            }
            SetValid(FALSE);
        }
        WARNING(("Failed to write Save record"));
        return Win32Error;
    }
    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   IMetafileRecord interface method - RecordRestore.
*
* Arguments:
*
*   [IN]  gstate - the pushed state (restore to state before this)
*
* Return Value:
*
*   NONE
*
* Created:
*
*   6/15/1999 DCurtis
*
\**************************************************************************/
GpStatus
MetafileRecorder::RecordRestore(
    INT         gstate
    )
{
    // If doing down-level only, then EmfPlusStream will be NULL
    if (EmfPlusStream != NULL)
    {
        if (IsValid())
        {
            INT         count = SaveRestoreStack.GetCount();
            INT *       stack = SaveRestoreStack.GetDataBuffer();

            if ((count > 0) && (stack != NULL))
            {
                UINT32              dataSize = sizeof(UINT32/* index */);
                EmfPlusRecordType   type     = EmfPlusRecordTypeRestore;

                do
                {
                    if (stack[--count] == gstate)
                    {
                        SaveRestoreStack.SetCount(count);
                        WriteRecordHeader(dataSize, type);
                        WriteInt32(EmfPlusStream, count);
                        // WriteGdiComment(); no down-level for this record

                        if (EmfPlusStream->IsValid())
                        {
                            return Ok;
                        }
                        SetValid(FALSE);
                        break;
                    }
                } while (count > 0);
            }
        }
        WARNING(("Failed to write Restore record"));
        return Win32Error;
    }
    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   IMetafileRecord interface method - RecordBeginContainer.
*
* Arguments:
*
*   [IN]  destRect       - rect to draw container inside of
*   [IN]  srcRect        - maps source size to destRect
*   [IN]  srcUnit        - units of srcRect
*   [IN]  containerState - the pushed state (restore to state before this)
*
* Return Value:
*
*   NONE
*
* Created:
*
*   6/15/1999 DCurtis
*
\**************************************************************************/
GpStatus
MetafileRecorder::RecordBeginContainer(
    const GpRectF &             destRect,
    const GpRectF &             srcRect,
    GpPageUnit                  srcUnit,
    INT                         containerState
    )
{
    // If doing down-level only, then EmfPlusStream will be NULL
    if (EmfPlusStream != NULL)
    {
        if (IsValid())
        {
            UINT32              dataSize = GDIP_RECTF_SIZE /* destRect */ +
                                           GDIP_RECTF_SIZE /* srcRect */ +
                                           sizeof(UINT32/* index */);
            EmfPlusRecordType   type     = EmfPlusRecordTypeBeginContainer;
            INT                 index    = SaveRestoreStack.GetCount();
            INT                 flags    = srcUnit;

            ASSERT((flags & (~GDIP_EPRFLAGS_PAGEUNIT)) == 0);

            if (index >= MaxStackSize)
            {
                MaxStackSize = index + 1;
            }

            SaveRestoreStack.Add(containerState);

            WriteRecordHeader(dataSize, type, flags);
            WriteRect(EmfPlusStream, destRect);
            WriteRect(EmfPlusStream, srcRect);
            WriteInt32(EmfPlusStream, index);
            // WriteGdiComment(); no down-level for this record

            if (EmfPlusStream->IsValid())
            {
                return Ok;
            }
            SetValid(FALSE);
        }
        WARNING(("Failed to write BeginContainer record"));
        return Win32Error;
    }
    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   IMetafileRecord interface method - RecordBeginContainer.
*
* Arguments:
*
*   [IN]  containerState - the pushed state (restore to state before this)
*
* Return Value:
*
*   NONE
*
* Created:
*
*   6/15/1999 DCurtis
*
\**************************************************************************/
GpStatus
MetafileRecorder::RecordBeginContainer(
    INT                         containerState
    )
{
    // If doing down-level only, then EmfPlusStream will be NULL
    if (EmfPlusStream != NULL)
    {
        if (IsValid())
        {
            UINT32              dataSize = sizeof(UINT32/* index */);
            EmfPlusRecordType   type     = EmfPlusRecordTypeBeginContainerNoParams;
            INT                 index    = SaveRestoreStack.GetCount();
            INT                 flags    = 0;

            if (index >= MaxStackSize)
            {
                MaxStackSize = index + 1;
            }

            SaveRestoreStack.Add(containerState);

            WriteRecordHeader(dataSize, type, flags);
            WriteInt32(EmfPlusStream, index);
            // WriteGdiComment(); no down-level for this record

            if (EmfPlusStream->IsValid())
            {
                return Ok;
            }
            SetValid(FALSE);
        }
        WARNING(("Failed to write BeginContainer record"));
        return Win32Error;
    }
    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   IMetafileRecord interface method - RecordEndContainer.
*
* Arguments:
*
*   [IN]  containerState - the pushed state (restore to state before this)
*
* Return Value:
*
*   NONE
*
* Created:
*
*   6/15/1999 DCurtis
*
\**************************************************************************/
GpStatus
MetafileRecorder::RecordEndContainer(
    INT                         containerState
    )
{
    // If doing down-level only, then EmfPlusStream will be NULL
    if (EmfPlusStream != NULL)
    {
        if (IsValid())
        {
            INT         count = SaveRestoreStack.GetCount();
            INT *       stack = SaveRestoreStack.GetDataBuffer();

            if ((count > 0) && (stack != NULL))
            {
                UINT32              dataSize = sizeof(UINT32/* index */);
                EmfPlusRecordType   type     = EmfPlusRecordTypeEndContainer;

                do
                {
                    if (stack[--count] == containerState)
                    {
                        SaveRestoreStack.SetCount(count);
                        WriteRecordHeader(dataSize, type);
                        WriteInt32(EmfPlusStream, count);
                        // WriteGdiComment(); no down-level for this record

                        if (EmfPlusStream->IsValid())
                        {
                            return Ok;
                        }
                        SetValid(FALSE);
                        break;
                    }
                } while (count > 0);
            }
        }
        WARNING(("Failed to write EndContainer record"));
        return Win32Error;
    }
    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   IMetafileRecord interface method - RecordSetWorldTransform.
*
* Arguments:
*
*   [IN]  matrix - matrix to set in graphics
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   6/15/1999 DCurtis
*
\**************************************************************************/
GpStatus
MetafileRecorder::RecordSetWorldTransform(
    const GpMatrix &            matrix
    )
{
    // If doing down-level only, then EmfPlusStream will be NULL
    if (EmfPlusStream != NULL)
    {
        if (IsValid())
        {
            UINT32              dataSize = GDIP_MATRIX_SIZE;
            EmfPlusRecordType   type     = EmfPlusRecordTypeSetWorldTransform;

            WriteRecordHeader(dataSize, type);
            WriteMatrix(EmfPlusStream, matrix);
            // WriteGdiComment(); no down-level for this record

            if (EmfPlusStream->IsValid())
            {
                return Ok;
            }
            SetValid(FALSE);
        }
        WARNING(("Failed to write SetWorldTransform record"));
        return Win32Error;
    }
    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   IMetafileRecord interface method - RecordResetWorldTransform.
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   6/15/1999 DCurtis
*
\**************************************************************************/
GpStatus
MetafileRecorder::RecordResetWorldTransform()
{
    return RecordZeroDataRecord(EmfPlusRecordTypeResetWorldTransform, 0);
}

/**************************************************************************\
*
* Function Description:
*
*   IMetafileRecord interface method - RecordMultiplyWorldTransform.
*
* Arguments:
*
*   [IN]  matrix - matrix to set in graphics
*   [IN]  order  - Append or Prepend
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   6/15/1999 DCurtis
*
\**************************************************************************/
GpStatus
MetafileRecorder::RecordMultiplyWorldTransform(
    const GpMatrix &            matrix,
    GpMatrixOrder               order
    )
{
    // If doing down-level only, then EmfPlusStream will be NULL
    if (EmfPlusStream != NULL)
    {
        if (IsValid())
        {
            UINT32              dataSize = GDIP_MATRIX_SIZE;
            EmfPlusRecordType   type     = EmfPlusRecordTypeMultiplyWorldTransform;
            INT                 flags    = 0;

            if (order == MatrixOrderAppend)
            {
                flags |= GDIP_EPRFLAGS_APPEND;
            }

            WriteRecordHeader(dataSize, type, flags);
            WriteMatrix(EmfPlusStream, matrix);
            // WriteGdiComment(); no down-level for this record

            if (EmfPlusStream->IsValid())
            {
                return Ok;
            }
            SetValid(FALSE);
        }
        WARNING(("Failed to write MultiplyWorldTransform record"));
        return Win32Error;
    }
    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   IMetafileRecord interface method - RecordTranslateWorldTransform.
*
* Arguments:
*
*   [IN]  dx     - x translation
*   [IN]  dy     - y translation
*   [IN]  order  - Append or Prepend
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   6/15/1999 DCurtis
*
\**************************************************************************/
GpStatus
MetafileRecorder::RecordTranslateWorldTransform(
    REAL                        dx,
    REAL                        dy,
    GpMatrixOrder               order
    )
{
    // If doing down-level only, then EmfPlusStream will be NULL
    if (EmfPlusStream != NULL)
    {
        if (IsValid())
        {
            UINT32              dataSize = sizeof(dx) + sizeof(dy);
            EmfPlusRecordType   type     = EmfPlusRecordTypeTranslateWorldTransform;
            INT                 flags    = 0;

            if (order == MatrixOrderAppend)
            {
                flags |= GDIP_EPRFLAGS_APPEND;
            }

            WriteRecordHeader(dataSize, type, flags);
            WriteReal(EmfPlusStream, dx);
            WriteReal(EmfPlusStream, dy);
            // WriteGdiComment(); no down-level for this record

            if (EmfPlusStream->IsValid())
            {
                return Ok;
            }
            SetValid(FALSE);
        }
        WARNING(("Failed to write TranslateWorldTransform record"));
        return Win32Error;
    }
    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   IMetafileRecord interface method - RecordScaleWorldTransform.
*
* Arguments:
*
*   [IN]  sx     - x scale
*   [IN]  sy     - y scale
*   [IN]  order  - Append or Prepend
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   6/15/1999 DCurtis
*
\**************************************************************************/
GpStatus
MetafileRecorder::RecordScaleWorldTransform(
    REAL                        sx,
    REAL                        sy,
    GpMatrixOrder               order
    )
{
    // If doing down-level only, then EmfPlusStream will be NULL
    if (EmfPlusStream != NULL)
    {
        if (IsValid())
        {
            UINT32              dataSize = sizeof(sx) + sizeof(sy);
            EmfPlusRecordType   type     = EmfPlusRecordTypeScaleWorldTransform;
            INT                 flags    = 0;

            if (order == MatrixOrderAppend)
            {
                flags |= GDIP_EPRFLAGS_APPEND;
            }

            WriteRecordHeader(dataSize, type, flags);
            WriteReal(EmfPlusStream, sx);
            WriteReal(EmfPlusStream, sy);
            // WriteGdiComment(); no down-level for this record

            if (EmfPlusStream->IsValid())
            {
                return Ok;
            }
            SetValid(FALSE);
        }
        WARNING(("Failed to write ScaleWorldTransform record"));
        return Win32Error;
    }
    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   IMetafileRecord interface method - RecordRotateWorldTransform.
*
* Arguments:
*
*   [IN]  angle  - rotation angle
*   [IN]  order  - Append or Prepend
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   6/15/1999 DCurtis
*
\**************************************************************************/
GpStatus
MetafileRecorder::RecordRotateWorldTransform(
    REAL                        angle,
    GpMatrixOrder               order
    )
{
    // If doing down-level only, then EmfPlusStream will be NULL
    if (EmfPlusStream != NULL)
    {
        if (IsValid())
        {
            UINT32              dataSize = sizeof(angle);
            EmfPlusRecordType   type     = EmfPlusRecordTypeRotateWorldTransform;
            INT                 flags    = 0;

            if (order == MatrixOrderAppend)
            {
                flags |= GDIP_EPRFLAGS_APPEND;
            }

            WriteRecordHeader(dataSize, type, flags);
            WriteReal(EmfPlusStream, angle);
            // WriteGdiComment(); no down-level for this record

            if (EmfPlusStream->IsValid())
            {
                return Ok;
            }
            SetValid(FALSE);
        }
        WARNING(("Failed to write RotateWorldTransform record"));
        return Win32Error;
    }
    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   IMetafileRecord interface method - RecordSetPageTransform.
*
* Arguments:
*
*   [IN]  unit   - units to use
*   [IN]  scale  - scale factor to apply
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   6/15/1999 DCurtis
*
\**************************************************************************/
GpStatus
MetafileRecorder::RecordSetPageTransform(
    GpPageUnit                  unit,
    REAL                        scale
    )
{
    // If doing down-level only, then EmfPlusStream will be NULL
    if (EmfPlusStream != NULL)
    {
        if (IsValid())
        {
            UINT32              dataSize = sizeof(scale);
            EmfPlusRecordType   type     = EmfPlusRecordTypeSetPageTransform;
            INT                 flags    = unit;

            ASSERT((flags & (~GDIP_EPRFLAGS_PAGEUNIT)) == 0);

            WriteRecordHeader(dataSize, type, flags);
            WriteReal(EmfPlusStream, scale);
            // WriteGdiComment(); no down-level for this record

            if (EmfPlusStream->IsValid())
            {
                return Ok;
            }
            SetValid(FALSE);
        }
        WARNING(("Failed to write SetPageTransform record"));
        return Win32Error;
    }
    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   IMetafileRecord interface method - RecordResetClip.
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   6/15/1999 DCurtis
*
\**************************************************************************/
GpStatus
MetafileRecorder::RecordResetClip()
{
    return RecordZeroDataRecord(EmfPlusRecordTypeResetClip, 0);
}

/**************************************************************************\
*
* Function Description:
*
*   IMetafileRecord interface method - RecordSetClip.
*
* Arguments:
*
*   [IN]  rect        - set clipping to this rect
*   [IN]  combineMode - the combine operator (and, or, xor, exclude, complement)
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   6/15/1999 DCurtis
*
\**************************************************************************/
GpStatus
MetafileRecorder::RecordSetClip(
    const GpRectF &             rect,
    CombineMode                 combineMode
    )
{
    // If doing down-level only, then EmfPlusStream will be NULL
    if (EmfPlusStream != NULL)
    {
        if (IsValid())
        {
            UINT32              dataSize = GDIP_RECTF_SIZE;
            EmfPlusRecordType   type     = EmfPlusRecordTypeSetClipRect;
            INT                 flags    = (combineMode << 8);

            ASSERT((flags & (~GDIP_EPRFLAGS_COMBINEMODE)) == 0);

            WriteRecordHeader(dataSize, type, flags);
            WriteRect(EmfPlusStream, rect);
            // WriteGdiComment(); no down-level for this record

            if (EmfPlusStream->IsValid())
            {
                return Ok;
            }
            SetValid(FALSE);
        }
        WARNING(("Failed to write SetClipRect record"));
        return Win32Error;
    }
    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   IMetafileRecord interface method - RecordSetClip.
*
* Arguments:
*
*   [IN]  region      - set clipping to this region
*   [IN]  combineMode - the combine operator (and, or, xor, exclude, complement)
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   6/15/1999 DCurtis
*
\**************************************************************************/
GpStatus
MetafileRecorder::RecordSetClip(
    GpRegion *                  region,
    CombineMode                 combineMode
    )
{
    // If doing down-level only, then EmfPlusStream will be NULL
    if (EmfPlusStream != NULL)
    {
        if (IsValid())
        {
            UINT32              dataSize = 0;
            EmfPlusRecordType   type     = EmfPlusRecordTypeSetClipRegion;
            INT                 flags    = (combineMode << 8);
            UINT32              metaRegionId;

            ASSERT((flags & (~GDIP_EPRFLAGS_COMBINEMODE)) == 0);

            RecordObject(region, &metaRegionId);
            ASSERT((metaRegionId & (~GDIP_EPRFLAGS_METAOBJECTID)) == 0);
            flags |= metaRegionId;

            WriteRecordHeader(dataSize, type, flags);
            // WriteGdiComment(); no down-level for this record

            if (EmfPlusStream->IsValid())
            {
                return Ok;
            }
            SetValid(FALSE);
        }
        WARNING(("Failed to write SetClipRegion record"));
        return Win32Error;
    }
    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   IMetafileRecord interface method - RecordSetClip.
*
* Arguments:
*
*   [IN]  path        - set clipping to this path
*   [IN]  combineMode - the combine operator (and, or, xor, exclude, complement)
*   [IN]  isDevicePath- if path is already in device units
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   6/15/1999 DCurtis
*
\**************************************************************************/
GpStatus
MetafileRecorder::RecordSetClip(
    GpPath *                    path,
    CombineMode                 combineMode,
    BOOL                        isDevicePath
    )
{
    // If doing down-level only, then EmfPlusStream will be NULL
    if (EmfPlusStream != NULL)
    {
        if (IsValid())
        {
            UINT32              dataSize = 0;
            EmfPlusRecordType   type     = EmfPlusRecordTypeSetClipPath;
            INT                 flags    = (combineMode << 8);
            UINT32              metaPathId;

            ASSERT((flags & (~GDIP_EPRFLAGS_COMBINEMODE)) == 0);

            RecordObject(path, &metaPathId);
            ASSERT((metaPathId & (~GDIP_EPRFLAGS_METAOBJECTID)) == 0);
            flags |= metaPathId;

            if (isDevicePath)
            {
                flags |= GDIP_EPRFLAGS_ISDEVICEPATH;
            }

            WriteRecordHeader(dataSize, type, flags);
            // WriteGdiComment(); no down-level for this record

            if (EmfPlusStream->IsValid())
            {
                return Ok;
            }
            SetValid(FALSE);
        }
        WARNING(("Failed to write SetClipPath record"));
        return Win32Error;
    }
    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   IMetafileRecord interface method - RecordOffsetClip.
*
* Arguments:
*
*   [IN]  dx   - x translation amount
*   [IN]  dy   - y translation amount
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   6/15/1999 DCurtis
*
\**************************************************************************/
GpStatus
MetafileRecorder::RecordOffsetClip(
    REAL                        dx,
    REAL                        dy
    )
{
    // If doing down-level only, then EmfPlusStream will be NULL
    if (EmfPlusStream != NULL)
    {
        if (IsValid())
        {
            UINT32              dataSize = sizeof(dx) + sizeof(dy);
            EmfPlusRecordType   type     = EmfPlusRecordTypeOffsetClip;

            WriteRecordHeader(dataSize, type);
            WriteReal(EmfPlusStream, dx);
            WriteReal(EmfPlusStream, dy);
            // WriteGdiComment(); no down-level for this record

            if (EmfPlusStream->IsValid())
            {
                return Ok;
            }
            SetValid(FALSE);
        }
        WARNING(("Failed to write OffsetClip record"));
        return Win32Error;
    }
    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   IMetafileRecord interface method - RecordGetDC.
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   NONE
*
* Created:
*
*   6/15/1999 DCurtis
*
\**************************************************************************/
GpStatus
MetafileRecorder::RecordGetDC()
{
    // If doing down-level only, then EmfPlusStream will be NULL
    if (EmfPlusStream != NULL)
    {
        GpStatus status = RecordZeroDataRecord(EmfPlusRecordTypeGetDC, 0);
        // WriteGdiComment();  // is down-level for this record
        // WriteGdiComment will only flush if writing EMF+ dual,
        // but for EMF+-only, we also have to flush GetDC records!
        EmfPlusStream->Flush();
        return status;
    }
    return Ok;
}

// Write a record with no data besides the EMF+ record header
GpStatus
MetafileRecorder::RecordZeroDataRecord(
    EmfPlusRecordType   type,
    INT                 flags
    )
{
    // If doing down-level only, then EmfPlusStream will be NULL
    if (EmfPlusStream != NULL)
    {
        if (IsValid())
        {
            UINT32              dataSize = 0;

            WriteRecordHeader(dataSize, type, flags);
            // WriteGdiComment(); no down-level for this record

            if (EmfPlusStream->IsValid())
            {
                return Ok;
            }
            SetValid(FALSE);
        }
        WARNING(("Failed to write record"));
        return Win32Error;
    }
    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   IMetafileRecord interface method - RecordSetAntiAliasMode.
*
* Arguments:
*
*   [IN]  newMode   - new anti aliasing mode
*
* Return Value:
*
*   NONE
*
* Created:
*
*   6/15/1999 DCurtis
*
\**************************************************************************/
GpStatus
MetafileRecorder::RecordSetAntiAliasMode(
    BOOL                        newMode
    )
{
    return RecordZeroDataRecord(EmfPlusRecordTypeSetAntiAliasMode,
                                newMode ? GDIP_EPRFLAGS_ANTIALIAS : 0);
}

/**************************************************************************\
*
* Function Description:
*
*   IMetafileRecord interface method - RecordSetTextRenderingHint.
*
* Arguments:
*
*   [IN]  newMode   - new rendering hint
*
* Return Value:
*
*   NONE
*
* Created:
*
*
\**************************************************************************/
GpStatus
MetafileRecorder::RecordSetTextRenderingHint(
    TextRenderingHint               newMode
    )
{
    ASSERT ((newMode & (~GDIP_EPRFLAGS_TEXTRENDERINGHINT)) == 0);
    return RecordZeroDataRecord(EmfPlusRecordTypeSetTextRenderingHint, newMode);
}

/**************************************************************************\
*
* Function Description:
*
*   IMetafileRecord interface method - RecordSetTextContrast.
*
* Arguments:
*
*   [IN]  gammaValue   - new contrast value
*
* Return Value:
*
*   NONE
*
* Created:
*
*
\**************************************************************************/
GpStatus
MetafileRecorder::RecordSetTextContrast(
    UINT                    contrast
    )
{
    ASSERT ((contrast & (~GDIP_EPRFLAGS_CONTRAST)) == 0);
    return RecordZeroDataRecord(EmfPlusRecordTypeSetTextContrast, contrast);
}

/**************************************************************************\
*
* Function Description:
*
*   IMetafileRecord interface method - RecordSetInterpolationMode.
*
* Arguments:
*
*   [IN]  newMode   - new interpolation mode
*
* Return Value:
*
*   NONE
*
* Created:
*
*   5/1/2000 DCurtis
*
\**************************************************************************/
GpStatus
MetafileRecorder::RecordSetInterpolationMode(
    InterpolationMode           newMode
    )
{
    ASSERT ((newMode & (~GDIP_EPRFLAGS_INTERPOLATIONMODE)) == 0);
    return RecordZeroDataRecord(EmfPlusRecordTypeSetInterpolationMode, newMode);
}

/**************************************************************************\
*
* Function Description:
*
*   IMetafileRecord interface method - RecordSetPixelOffsetMode.
*
* Arguments:
*
*   [IN]  newMode   - new pixel offset mode
*
* Return Value:
*
*   NONE
*
* Created:
*
*   5/1/2000 DCurtis
*
\**************************************************************************/
GpStatus
MetafileRecorder::RecordSetPixelOffsetMode(
    PixelOffsetMode             newMode
    )
{
    ASSERT ((newMode & (~GDIP_EPRFLAGS_PIXELOFFSETMODE)) == 0);
    return RecordZeroDataRecord(EmfPlusRecordTypeSetPixelOffsetMode, newMode);
}

/**************************************************************************\
*
* Function Description:
*
*   IMetafileRecord interface method - RecordSetRenderingOrigin.
*
* Arguments:
*
*   [IN]  x, y   - new rendering origin
*
* Return Value:
*
*   NONE
*
* Created:
*
*   5/4/2000 asecchia
*
\**************************************************************************/
GpStatus
MetafileRecorder::RecordSetRenderingOrigin(
    INT x,
    INT y
)
{
    // If doing down-level only, then EmfPlusStream will be NULL
    if (EmfPlusStream != NULL)
    {
        if (IsValid())
        {
            UINT32              dataSize = sizeof(x) + sizeof(y);
            EmfPlusRecordType   type     = EmfPlusRecordTypeSetRenderingOrigin;

            WriteRecordHeader(dataSize, type);
            WriteInt32(EmfPlusStream, x);
            WriteInt32(EmfPlusStream, y);

            if (EmfPlusStream->IsValid())
            {
                return Ok;
            }
            SetValid(FALSE);
        }
        WARNING(("Failed to write SetRenderingOrigin record"));
        return Win32Error;
    }
    return Ok;
}


/**************************************************************************\
*
* Function Description:
*
*   IMetafileRecord interface method - RecordSetCompositingMode.
*
* Arguments:
*
*   [IN]  newMode   - new compositing mode
*
* Return Value:
*
*   NONE
*
* Created:
*
*   10/11/1999 AGodfrey
*
\**************************************************************************/
GpStatus
MetafileRecorder::RecordSetCompositingMode(
    GpCompositingMode newMode
    )
{
    ASSERT ((newMode & (~GDIP_EPRFLAGS_COMPOSITINGMODE)) == 0);
    return RecordZeroDataRecord(EmfPlusRecordTypeSetCompositingMode, newMode);
}

/**************************************************************************\
*
* Function Description:
*
*   IMetafileRecord interface method - RecordSetCompositingQuality.
*
* Arguments:
*
*   [IN]  newQuality   - new quality setting
*
* Return Value:
*
*   NONE
*
* Created:
*
*   04/22/2000 AGodfrey
*
\**************************************************************************/
GpStatus
MetafileRecorder::RecordSetCompositingQuality(
    GpCompositingQuality newQuality
    )
{
    ASSERT ((newQuality & (~GDIP_EPRFLAGS_COMPOSITINGQUALITY)) == 0);
    return RecordZeroDataRecord(EmfPlusRecordTypeSetCompositingQuality, newQuality);
}

/**************************************************************************\
*
* Function Description:
*
*   IMetafileRecord interface method - RecordComment.
*
* Arguments:
*
*   [IN]  sizeData - number of bytes of data
*   [IN]  data     - pointer to the data
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   6/29/1999 DCurtis
*
\**************************************************************************/
GpStatus
MetafileRecorder::RecordComment(
    UINT            sizeData,
    const BYTE *    data
    )
{
    if (IsValid() && (sizeData > 0) && (data != NULL))
    {
        // If doing down-level only, then EmfPlusStream will be NULL
        if (EmfPlusStream != NULL)
        {
            UINT32              dataSize = (sizeData + 3) & (~3);
            EmfPlusRecordType   type     = EmfPlusRecordTypeComment;
            INT                 pad      = dataSize - sizeData;
            INT                 flags    = pad;

            WriteRecordHeader(dataSize, type, flags);
            WriteBytes(EmfPlusStream, data, sizeData);
            while(pad--)
            {
                WriteByte(EmfPlusStream, 0);
            }
            // WriteGdiComment(); no down-level for this record

            if (EmfPlusStream->IsValid())
            {
                return Ok;
            }
            SetValid(FALSE);
        }
        else if (Type == EmfTypeEmfOnly)
        {
            GdiComment(MetafileHdc, sizeData, data);
            return Ok;
        }
    }
    WARNING(("Failed to write Comment record"));
    return GenericError;
}

GpStatus
MetafileRecorder::RecordHeader(
    INT                 logicalDpiX,
    INT                 logicalDpiY,
    INT                 emfPlusFlags
    )
{
    // Don't need to check for EmfPlusStream or Valid

    UINT32              dataSize     = sizeof(EmfPlusHeaderRecord);
    EmfPlusRecordType   type         = EmfPlusRecordTypeHeader;
    INT                 flags        = 0;

    if (Type != EmfTypeEmfPlusOnly)
    {
        flags |= GDIP_EPRFLAGS_EMFPLUSDUAL;
    }

    EmfPlusHeaderRecord emfPlusHeader(emfPlusFlags, logicalDpiX, logicalDpiY);

    WriteRecordHeader(dataSize, type, flags);
    WriteBytes(EmfPlusStream, &emfPlusHeader, sizeof(emfPlusHeader));

    // We have to flush the EMF+ header immediately to guarantee that it
    // is the first record in the EMF after the EMF header.  Otherwise,
    // CloneColorAdjusted fails, because immediately after the metafile
    // constructor, it calls Play into the new metafile which writes a
    // SaveDC record into the metafile.
    EmfPlusStream->Flush();

    if (EmfPlusStream->IsValid())
    {
        return Ok;
    }
    SetValid(FALSE);
    WARNING(("Failed to write Metafile Header record"));
    return Win32Error;
}

VOID
MetafileRecorder::RecordEndOfFile()
{
    RecordZeroDataRecord(EmfPlusRecordTypeEndOfFile, 0);
}

extern "C"
int CALLBACK
EnumEmfToStream(
    HDC                     hdc,
    HANDLETABLE FAR *       gdiHandleTable,
    CONST ENHMETARECORD *   emfRecord,
    int                     numHandles,
    LPARAM                  stream
    );

/**************************************************************************\
*
* Function Description:
*
*   IMetafileRecord interface method - EndRecording.
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   NONE
*
* Created:
*
*   6/15/1999 DCurtis
*
\**************************************************************************/
VOID
MetafileRecorder::EndRecording()
{
    GpMetafile::MetafileState   state = GpMetafile::InvalidMetafileState;

    if (IsValid() && (Metafile->State == GpMetafile::RecordingMetafileState))
    {
        INT         success = 1;    // assume success

        // If doing down-level only, then EmfPlusStream will be NULL
        if (EmfPlusStream != NULL)
        {
            // Force a flush of the Stream buffer to the EMF+ file
            EmfPlusStream->Flush();

            // We put a no-op PatBlt into the metafile to guarantee that
            // the header of the metafile has the same size bounds and
            // frame rect that GDI+ has recorded so that the EMF will
            // play back the same way, whether GDI plays it back or we do.
            // Otherwise, this may not be the case.  For example, on a
            // bezier curve, the GDI+ bounds would include the control
            // points, whereas the down-level representation may not.

            // If we haven't written any records to the file, then XMinDevice
            // and other bounds are still initialized at FLT_MAX and can cause
            // an exception. We don't need the empty PatBlt record in that case
            // because we haven't written anything.
            if (BoundsInit != FALSE)
            {
                // Try to match the GDI+ rasterizer
                INT     left   = RasterizerCeiling(XMinDevice);
                INT     top    = RasterizerCeiling(YMinDevice);
                INT     right  = RasterizerCeiling(XMaxDevice); // exclusive
                INT     bottom = RasterizerCeiling(YMaxDevice); // exclusive

                // to get the inclusive right and bottom, we'd now
                // have to subtract 1 from each of them
                if ((right > left) && (bottom > top))
                {
                    Metafile->MetaGraphics->NoOpPatBlt(left, top, right - left, bottom - top);
                }
            }

            // must be the last record in the file, except the EMF EOF record
            RecordEndOfFile();
            EmfPlusStream->Flush();
        }

        HENHMETAFILE    hEmf = CloseEnhMetaFile(MetafileHdc);

        if (hEmf == NULL)
        {
            goto Done;
        }

        // Get the EMF header
        ENHMETAHEADER3      emfHeader;
        if ((GetEnhMetaFileHeader(hEmf, sizeof(emfHeader),
                                  (ENHMETAHEADER*)(&emfHeader)) <= 0) ||
            !EmfHeaderIsValid(emfHeader))
        {
            DeleteEnhMetaFile(hEmf);
            goto Done;
        }

#if DBG
        if ((emfHeader.rclBounds.right  == -1) &&
            (emfHeader.rclBounds.bottom == -1) &&
            (emfHeader.rclBounds.left   ==  0) &&
            (emfHeader.rclBounds.top    ==  0))
        {
            WARNING1("Empty metafile -- no drawing records");
        }
#endif

        MetafileHeader *    header       = &Metafile->Header;
        INT32               emfPlusFlags = header->EmfPlusFlags;

        // Save the header and various other info in the Metafile
        Metafile->Hemf         = hEmf;
        Metafile->MaxStackSize = MaxStackSize;
        header->EmfPlusFlags   = emfPlusFlags;
        header->EmfHeader      = emfHeader;
        header->Size           = emfHeader.nBytes;

        // Set the bounds in the Metafile header
        {
            REAL    multiplierX = header->DpiX / 2540.0f;
            REAL    multiplierY = header->DpiY / 2540.0f;

            // The frameRect is inclusive-inclusive, but the bounds in
            // the header is inclusive-exclusive.
            REAL    x = (multiplierX * (REAL)(emfHeader.rclFrame.left));
            REAL    y = (multiplierY * (REAL)(emfHeader.rclFrame.top));
            REAL    w = (multiplierX * (REAL)(emfHeader.rclFrame.right -
                                              emfHeader.rclFrame.left)) + 1.0f;
            REAL    h = (multiplierY * (REAL)(emfHeader.rclFrame.bottom -
                                              emfHeader.rclFrame.top)) + 1.0f;
            header->X      = GpRound(x);
            header->Y      = GpRound(y);
            header->Width  = GpRound(w);
            header->Height = GpRound(h);
        }

        // The metafile is either supposed to be in memory, in a file,
        // or in a stream.

        // If it goes in a file, we're done unless we need to rewrite
        // any of the header information.
        if (Metafile->Filename != NULL)
        {
            state = GpMetafile::DoneRecordingMetafileState;
        }
        else
        {
            // If it goes in memory, we're done.

            // If it goes in a stream, then we have to write
            // the bits to the stream.

            if (Metafile->Stream != NULL)
            {
                // Write the emf data buffer to the stream,
                // and leave the stream position at the end of the metafile.
                if (!::EnumEnhMetaFile(NULL, hEmf, EnumEmfToStream,
                    Metafile->Stream, NULL))
                {
                    WARNING(("Problem retrieving EMF Data"));
                    DeleteEnhMetaFile(hEmf);
                    Metafile->Hemf = NULL;
                    goto Done;
                }

                // Don't need the Stream any longer
                Metafile->Stream->Release();
                Metafile->Stream = NULL;
            }
            state = GpMetafile::DoneRecordingMetafileState;
        }
    }
    else
    {
        DeleteEnhMetaFile(CloseEnhMetaFile(MetafileHdc));
        WARNING(("Metafile in wrong state in EndRecording"));
    }

Done:
    Metafile->MetaGraphics->Metafile = NULL; // Graphics can't point to us anymore
    Metafile->MetaGraphics->SetValid(FALSE); // Don't allow anymore operations on
                                           // the graphics
    Metafile->MetaGraphics = NULL;         // graphics is not valid any more
    Metafile->State        = state;
    delete this;
}

#if 0
inline INT
WriteActualSize(
    IStream *   stream,
    LONGLONG &  startOfRecord,
    ULONG       actualSize
    )
{
    ASSERT (actualSize > 0);

    // get to size field
    INT success = SeekFromStart(stream, startOfRecord + sizeof(INT32));

    if (success)
    {
        success &= WriteInt32(stream, actualSize);
    }

    // get back to end of record
    success &= SeekFromStart(stream, startOfRecord + actualSize);

    return success;
}
#endif

/**************************************************************************\
*
* Function Description:
*
*   Write an object (pen, brush, image, region, path, font) to metafile by
*   writing its header, calling its serialize method, and then re-writing
*   the size.
*
* Arguments:
*
*   [IN]  type           - the record type
*   [IN]  flags          - any flags for the record header
*   [IN]  object         - pointer to the object to be recorded
*   [IN]  metaObjectId   - ID to store in file that identifies object
*   [IN]  extraData      - any extra data to store with object
*   [IN]  extraDataSize  - size in BYTES of extraData
*
* Return Value:
*
*   INT - 1 if we succeeded, else 0 if we failed
*
* Created:
*
*   6/15/1999 DCurtis
*
\**************************************************************************/
VOID
MetafileRecorder::WriteObject(
    ObjectType                  type,
    const GpObject *            object,
    UINT32                      metaObjectId
    )
{
    ULONG               objectDataSize  = object->GetDataSize();
    INT                 flags = ((INT)type << 8);

    ASSERT((objectDataSize & 0x03) == 0);
    ASSERT((flags & (~GDIP_EPRFLAGS_OBJECTTYPE)) == 0);
    ASSERT((metaObjectId & (~GDIP_EPRFLAGS_METAOBJECTID)) == 0);
    ASSERT(objectDataSize != 0);    // cannot have an empty object

    flags |= metaObjectId;

    WriteRecordHeader(objectDataSize, EmfPlusRecordTypeObject, flags, NULL);

    if (object->GetData(EmfPlusStream) != Ok)
    {
        WARNING(("GetData failed"));
    }
    EmfPlusStream->EndObjectRecord();
}

VOID
MetafileRecorder::RecordObject(
    const GpObject *            object,
    UINT32*                     metaObjectId
    )
{
    if (object)
    {
        ObjectType      type  = object->GetObjectType();

        if (ObjectList.IsInList(object, type, metaObjectId))
        {
            ObjectList.UpdateMRU(*metaObjectId);
        }
        else
        {
            ObjectList.InsertAt(object, metaObjectId);
            WriteObject(type, object, *metaObjectId);
        }
    }
    else
    {
        *metaObjectId = GDIP_OBJECTID_NONE;
    }
}

// This is for backward compatiblity.  If we are using a new object
// (such as a new kind of brush), then we can record a backup object
// for down-level apps to use when they see a new object that they
// don't know how to deal with.
GpStatus
MetafileRecorder::RecordBackupObject(
    const GpObject *            object
    )
{
    WriteObject(object->GetObjectType(), object, GDIP_BACKUP_OBJECTID) ;
    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   Write the initial portion of an EMF+ record.  Every EMF+ record contains
*   a size, a type, and some flags.  Many also contain a rect that specifies
*   the bounds of a drawing operation in REAL device units.
*
* Arguments:
*
*   [IN]  size         - the size of the record (excluding the header)
*   [IN]  type         - the EMF+ record type
*   [IN]  flags        - any flags that are defined for this record
*   [IN]  deviceBounds - bounds of drawing operation, or NULL
*
* Return Value:
*
*   INT - 1 if we succeeded, else 0 if we failed
*
* Created:
*
*   6/15/1999 DCurtis
*
\**************************************************************************/
VOID
MetafileRecorder::WriteRecordHeader(
    UINT32                      dataSize,
    EmfPlusRecordType           type,
    INT                         flags,          // 16 bits of flags
    const GpRectF *             deviceBounds
    )
{
    ASSERT((dataSize & 0x03) == 0);

    EmfPlusStream->WriteRecordHeader(dataSize, type, flags);

    NumRecords++;

    if (deviceBounds != NULL)
    {
        // If the bounds aren't initalized then make sure we have 4 valid
        // coordinates
        ASSERT(BoundsInit ||
               ((deviceBounds->X < XMinDevice) &&
                (deviceBounds->GetRight() > XMaxDevice) &&
                (deviceBounds->Y < YMinDevice) &&
                (deviceBounds->GetBottom() > YMaxDevice)));
        BoundsInit = TRUE;
        // Update the device bounds
        if (deviceBounds->X < XMinDevice)
        {
            XMinDevice = deviceBounds->X;
        }
        if (deviceBounds->GetRight() > XMaxDevice)
        {
            XMaxDevice = deviceBounds->GetRight();  // exclusive
        }
        if (deviceBounds->Y < YMinDevice)
        {
            YMinDevice = deviceBounds->Y;
        }
        if (deviceBounds->GetBottom() > YMaxDevice)
        {
            YMaxDevice = deviceBounds->GetBottom(); // exclusive
        }
    }
}

/**************************************************************************\
*
* Function Description:
*
*   If the brush is a 32-bit solid color, then return the solid color as
*   the brush value and set the flags to indicate it's a solid color.
*   Otherwise, record the brush and return the metafile brush id as the
*   brush value.
*
* Arguments:
*
*   [IN]  brush      - the brush that needs to be recorded
*   [OUT] brushValue - the 32-bit color or metafile brush ID
*   [OUT] flags      - set if we're using a solid color
*
* Return Value:
*
*   INT - 1 if we succeeded, else 0 if we failed
*
* Created:
*
*   6/15/1999 DCurtis
*
\**************************************************************************/
VOID
MetafileRecorder::GetBrushValueForRecording(
    const GpBrush *brush,
    UINT32        &brushValue,
    INT           &flags
    )
{
    if (brush->GetBrushType() == BrushTypeSolidColor)
    {
        const GpSolidFill * solidBrush = static_cast<const GpSolidFill *>(brush);
        brushValue = solidBrush->GetColor().GetValue();
        flags |= GDIP_EPRFLAGS_SOLIDCOLOR;
    }
    else
    {
        RecordObject(brush, &brushValue);
    }
}

/**************************************************************************\
*
* Function Description:
*
*   GpMetafile constructor for write/read access to a metafile.  (Write must
*   precede the read.)
*
*   This version records an EMF+ to memory.  The type specifies whether
*   to record dual GDI records or not.
*
*   If the frameRect is NULL, it will be calculated by accumulating the
*   device bounds of the metafile.  Otherwise, the supplied frameRect and
*   corresponding frameUnit will be used to record the frameRect in the
*   metafile header. The frameRect is inclusive-inclusive, which means
*   that the width value is actually 1 less than the actual width.
*   For example, a width of 0 is accepted and really means a width of 1.
*
*   If the optional description is supplied, it will become part of the
*   EMF header.
*
* Arguments:
*
*   [IN]  fileName      - where to write the metafile
*   [IN]  referenceHdc  - an HDC to use as a reference for creating metafile
*   [IN]  type          - whether to record EMF+-only or EMF+-dual
*   [IN]  frameRect     - optional frame rect for recording in header
*   [IN]  frameUnit     - the units of the frameRect
*   [IN]  description   - optional metafile description
*
* Return Value:
*
*   NONE
*
* Created:
*
*   6/15/1999 DCurtis
*
\**************************************************************************/
GpMetafile::GpMetafile(
    HDC                 referenceHdc,
    EmfType             type,
    const GpRectF *     frameRect,      // can be NULL
    MetafileFrameUnit   frameUnit,      // if NULL frameRect, doesn't matter
    const WCHAR *       description     // can be NULL
    ) : GpImage(ImageTypeMetafile)
{
    ASSERT(referenceHdc != NULL);

    InitDefaults();

    if ((referenceHdc != NULL) &&
        InitForRecording(
            referenceHdc,
            type,
            frameRect,      // can be NULL
            frameUnit,      // if NULL frameRect, doesn't matter
            description     // can be NULL
            ))
    {
        State = RecordingMetafileState;
    }
}

/**************************************************************************\
*
* Function Description:
*
*   GpMetafile constructor for write/read access to a metafile.  (Write must
*   precede the read.)
*
*   This version records an EMF+ to a file.  The type specifies whether
*   to record dual GDI records or not.
*
*   If the frameRect is NULL, it will be calculated by accumulating the
*   device bounds of the metafile.  Otherwise, the supplied frameRect and
*   corresponding frameUnit will be used to record the frameRect in the
*   metafile header. The frameRect is inclusive-inclusive, which means
*   that the width value is actually 1 less than the actual width.
*   For example, a width of 0 is accepted and really means a width of 1.
*
*   If the optional description is supplied, it will become part of the
*   EMF header.
*
* Arguments:
*
*   [IN]  fileName      - where to write the metafile
*   [IN]  referenceHdc  - an HDC to use as a reference for creating metafile
*   [IN]  type          - whether to record EMF+-only or EMF+-dual
*   [IN]  frameRect     - optional frame rect for recording in header
*   [IN]  frameUnit     - the units of the frameRect
*   [IN]  description   - optional metafile description
*
* Return Value:
*
*   NONE
*
* Created:
*
*   6/15/1999 DCurtis
*
\**************************************************************************/
GpMetafile::GpMetafile(
    const WCHAR*        fileName,
    HDC                 referenceHdc,
    EmfType             type,
    const GpRectF *     frameRect,      // can be NULL
    MetafileFrameUnit   frameUnit,      // if NULL frameRect, doesn't matter
    const WCHAR *       description     // can be NULL
    ) : GpImage(ImageTypeMetafile)
{
    ASSERT((fileName != NULL) && (referenceHdc != NULL));

    InitDefaults();

    if ((fileName != NULL) && (referenceHdc != NULL) &&
        ((Filename = UnicodeStringDuplicate(fileName)) != NULL) &&
        InitForRecording(
            referenceHdc,
            type,
            frameRect,      // can be NULL
            frameUnit,      // if NULL frameRect, doesn't matter
            description     // can be NULL
            ))
    {
        State = RecordingMetafileState;
    }
}

/**************************************************************************\
*
* Function Description:
*
*   GpMetafile constructor for write/read access to a metafile.  (Write must
*   precede the read.)
*
*   This version records an EMF+ to a file.  The type specifies whether
*   to record dual GDI records or not.
*
*   The metafile is first recorded to a temporary file, then it is copied
*   from the file into the stream.
*
*   If the frameRect is NULL, it will be calculated by accumulating the
*   device bounds of the metafile.  Otherwise, the supplied frameRect and
*   corresponding frameUnit will be used to record the frameRect in the
*   metafile header. The frameRect is inclusive-inclusive, which means
*   that the width value is actually 1 less than the actual width.
*   For example, a width of 0 is accepted and really means a width of 1.
*
*   If the optional description is supplied, it will become part of the
*   EMF header.
*
* Arguments:
*
*   [IN]  stream        - where to copy the metafile, after it's recorded
*   [IN]  referenceHdc  - an HDC to use as a reference for creating metafile
*   [IN]  type          - whether to record EMF+-only or EMF+-dual
*   [IN]  frameRect     - optional frame rect for recording in header
*   [IN]  frameUnit     - the units of the frameRect
*   [IN]  description   - optional metafile description
*
* Return Value:
*
*   NONE
*
* Created:
*
*   6/15/1999 DCurtis
*
\**************************************************************************/
GpMetafile::GpMetafile(
    IStream *           stream,
    HDC                 referenceHdc,
    EmfType             type,
    const GpRectF *     frameRect,      // can be NULL
    MetafileFrameUnit   frameUnit,      // if NULL frameRect, doesn't matter
    const WCHAR *       description     // can be NULL
    ) : GpImage(ImageTypeMetafile)
{
    ASSERT((stream != NULL) && (referenceHdc != NULL));

    InitDefaults();

    if ((stream != NULL) && (referenceHdc != NULL))
    {
        if (InitForRecording(
                referenceHdc,
                type,
                frameRect,      // can be NULL
                frameUnit,      // if NULL frameRect, doesn't matter
                description     // can be NULL
                ))
        {
            stream->AddRef();
            Stream = stream;
            State = RecordingMetafileState;
        }
    }
}

inline HDC CreateEmf(
    HDC             referenceHdc,
    const WCHAR *   fileName,
    RECT *          frameRect
    )
{
    HDC         metafileHdc = NULL;

    if (Globals::IsNt)
    {
        metafileHdc = CreateEnhMetaFileW(referenceHdc, fileName, frameRect, NULL);
    }
    else
    {
        AnsiStrFromUnicode fileBuffer(fileName);

        if (fileBuffer.IsValid())
        {
            metafileHdc = CreateEnhMetaFileA(referenceHdc, fileBuffer, frameRect, NULL);
        }
    }
    return metafileHdc;
}

static BOOL
GetFrameRectInMM100Units(
    HDC                 hdc,
    const GpRectF *     frameRect,
    MetafileFrameUnit   frameUnit,
    RECT &              rclFrame
    )
{
    SIZEL   szlDevice;              // Size of device in pels
    SIZEL   szlMillimeters;         // Size of device in millimeters
    REAL    dpiX;
    REAL    dpiY;

    // NOTE: We have to use the szlDevice and szlMillimeters to get
    // the dpi (instead of getting it directly from LOGPIXELSX/Y)
    // so that the frame rect that is calculated for the metafile by GDI
    // matches the one that GDI+ would have calculated.  Because it's
    // these 2 metrics that the GDI metafile code uses to get the frame
    // rect from the bounds, not the logical DPI.

    szlDevice.cx      = ::GetDeviceCaps(hdc, HORZRES);
    szlDevice.cy      = ::GetDeviceCaps(hdc, VERTRES);
    szlMillimeters.cx = ::GetDeviceCaps(hdc, HORZSIZE);
    szlMillimeters.cy = ::GetDeviceCaps(hdc, VERTSIZE);

    if ((szlDevice.cx <= 0) || (szlDevice.cy <= 0) ||
        (szlMillimeters.cx <= 0) || (szlMillimeters.cy <= 0))
    {
        WARNING(("GetDeviceCaps failed"));
        return FALSE;
    }

    // Now get the real DPI, adjusted for the round-off error.
    dpiX = ((REAL)(szlDevice.cx) / (REAL)(szlMillimeters.cx)) * 25.4f;
    dpiY = ((REAL)(szlDevice.cy) / (REAL)(szlMillimeters.cy)) * 25.4f;

    GpRectF     frameRectMM100;

    FrameToMM100(frameRect, (GpPageUnit)frameUnit, frameRectMM100,
                 dpiX, dpiY);

    rclFrame.left   = GpRound(frameRectMM100.X);
    rclFrame.top    = GpRound(frameRectMM100.Y);
    rclFrame.right  = GpRound(frameRectMM100.GetRight());
    rclFrame.bottom = GpRound(frameRectMM100.GetBottom());
    
    // Make sure the .01MM frameRect is valid
    // It's okay for left == right, because the frameRect
    // is inclusive-inclusive.
    if ((rclFrame.left > rclFrame.right) ||
        (rclFrame.top  > rclFrame.bottom))
    {
        WARNING(("Invalid GDI frameRect"));
        return FALSE;
    }

    return TRUE;
}

/**************************************************************************\
*
* Function Description:
*
*   Convert a frameRect in any units, to a frame rect that is in .01 MM units.
*
* Arguments:
*
*   [IN]  frameRect      - the source frameRect
*   [IN]  frameUnit      - the units of the source frameRect
*   [OUT] frameRectMM100 - the frameRect in inch units
*   [IN]  dpiX           - the horizontal DPI
*   [IN]  dpiY           - the vertical   DPI
*
* Return Value:
*
*   NONE
*
* Created:
*
*   6/15/1999 DCurtis
*
\**************************************************************************/
static VOID
FrameToMM100(
    const GpRectF *         frameRect,
    GpPageUnit              frameUnit,
    GpRectF &               frameRectMM100,
    REAL                    dpiX,               // only used for pixel case
    REAL                    dpiY
    )
{
    REAL        pixelsToMM100X   = (2540.0f / dpiX);
    REAL        pixelsToMM100Y   = (2540.0f / dpiY);

    // The GDI frameRect has right and bottom values that are
    // inclusive, whereas the GDI+ frameRect has GetRight() and
    // GetBottom() values that are exclusive (because GDI+ rects
    // are specified with width/height, not right/bottom.  To convert
    // from the GDI+ value to the GDI value, we have to subtract 1 pixel.
    // This means that we first convert the units to pixel units, then 
    // subtract one, then convert to MM100 units.
    switch (frameUnit)
    {
    default:
        ASSERT(0);
        // FALLTHRU

    case UnitPixel:             // Each unit represents one device pixel.
        frameRectMM100.X      = frameRect->X * pixelsToMM100X;
        frameRectMM100.Y      = frameRect->Y * pixelsToMM100Y;
        frameRectMM100.Width  = frameRect->Width;
        frameRectMM100.Height = frameRect->Height;
        break;

    case UnitPoint:             // Each unit represents 1/72 inch.
        frameRectMM100.X      = frameRect->X * (2540.0f / 72.0f);
        frameRectMM100.Y      = frameRect->Y * (2540.0f / 72.0f);
        frameRectMM100.Width  = frameRect->Width  * (dpiX / 72.0f);
        frameRectMM100.Height = frameRect->Height * (dpiY / 72.0f);
        break;

    case UnitInch:              // Each unit represents 1 inch.
        frameRectMM100.X      = frameRect->X * 2540.0f;
        frameRectMM100.Y      = frameRect->Y * 2540.0f;
        frameRectMM100.Width  = frameRect->Width  * dpiX;
        frameRectMM100.Height = frameRect->Height * dpiY;
        break;

    case UnitDocument:          // Each unit represents 1/300 inch.
        frameRectMM100.X      = frameRect->X * (2540.0f / 300.0f);
        frameRectMM100.Y      = frameRect->Y * (2540.0f / 300.0f);
        frameRectMM100.Width  = frameRect->Width  * (dpiX / 300.0f);
        frameRectMM100.Height = frameRect->Height * (dpiY / 300.0f);
        break;

    case UnitMillimeter:        // Each unit represents 1 millimeter.
                                // One Millimeter is 0.03937 inches
                                // One Inch is 25.4 millimeters
        frameRectMM100.X      = frameRect->X * (100.0f);
        frameRectMM100.Y      = frameRect->Y * (100.0f);
        frameRectMM100.Width  = frameRect->Width  * (dpiX / 25.4f);
        frameRectMM100.Height = frameRect->Height * (dpiY / 25.4f);
        break;
    }
    frameRectMM100.Width  = (frameRectMM100.Width  - 1.0f) * pixelsToMM100X;
    frameRectMM100.Height = (frameRectMM100.Height - 1.0f) * pixelsToMM100Y;
}

BOOL
GpMetafile::InitForRecording(
    HDC                 referenceHdc,
    EmfType             type,
    const GpRectF *     frameRect,      // can be NULL
    MetafileFrameUnit   frameUnit,      // if NULL frameRect, doesn't matter
    const WCHAR *       description     // can be NULL
    )
{
    RECT *  frameRectParam = NULL;
    RECT    rclFrame;

    if (frameRect != NULL)
    {
        // Validate the frameRect
        // 0 is allowed, since the frameRect is inclusive-inclusive, which
        // means that a width of 0 is actually a width of 1
        if ((frameRect->Width < 0.0f) || (frameRect->Height < 0.0f))
        {
            WARNING(("Invalid frameRect"));
            return FALSE;
        }

        if (frameUnit == MetafileFrameUnitGdi)
        {
            // Typically, the GDI+ frameRect is inclusive/exclusive
            // as far as the GetLeft()/GetRight() values go, but the
            // MetafileFrameUnitGdi unit is a special type of unit
            // that specifies compatibility with GDI which is
            // inclusive/inclusive, so we don't do any adjustment
            // on those values at all -- we just assume they are ready
            // to pass directly to GDI.
            rclFrame.left   = GpRound(frameRect->X);
            rclFrame.top    = GpRound(frameRect->Y);
            rclFrame.right  = GpRound(frameRect->GetRight());
            rclFrame.bottom = GpRound(frameRect->GetBottom());

            // Make sure the .01MM frameRect is valid
            // It's okay for left == right, because the GDI frameRect
            // is inclusive-inclusive.
            if ((rclFrame.left > rclFrame.right) ||
                (rclFrame.top  > rclFrame.bottom))
            {
                WARNING(("Invalid GDI frameRect"));
                return FALSE;
            }
        }
        else
        {
            if (!GetFrameRectInMM100Units(referenceHdc, frameRect, frameUnit, rclFrame))
            {
                return FALSE;
            }
        }

        frameRectParam = &rclFrame;
    }
    
    HDC     metafileHdc;

    // Now create the metafile HDC
    // Note that FileName might be NULL
    metafileHdc = CreateEmf(referenceHdc, Filename, frameRectParam);
    if (metafileHdc == NULL)
    {
        return FALSE;       // failed
    }

    // Now get the dpi based on the metafileHdc (which could be different
    // than the referenceHdc).
    
    SIZEL   szlDevice;              // Size of metafile device in pels
    SIZEL   szlMillimeters;         // Size of metafile device in millimeters
    GpRectF metafileBounds;
    
    // NOTE: We have to use the szlDevice and szlMillimeters to get
    // the dpi (instead of getting it directly from LOGPIXELSX/Y)
    // so that the frame rect that is calculated for the metafile by GDI
    // matches the one that GDI+ would have calculated.  Because it's
    // these 2 metrics that the GDI metafile code uses to get the frame
    // rect from the bounds, not the logical DPI.

    szlDevice.cx      = ::GetDeviceCaps(metafileHdc, HORZRES);
    szlDevice.cy      = ::GetDeviceCaps(metafileHdc, VERTRES);
    szlMillimeters.cx = ::GetDeviceCaps(metafileHdc, HORZSIZE);
    szlMillimeters.cy = ::GetDeviceCaps(metafileHdc, VERTSIZE);

    if ((szlDevice.cx <= 0) || (szlDevice.cy <= 0) ||
        (szlMillimeters.cx <= 0) || (szlMillimeters.cy <= 0))
    {
        WARNING(("GetDeviceCaps failed"));
        goto ErrorExit;
    }

    REAL    dpiX;
    REAL    dpiY;
    REAL    dpmmX = (REAL)(szlDevice.cx) / (REAL)(szlMillimeters.cx);
    REAL    dpmmY = (REAL)(szlDevice.cy) / (REAL)(szlMillimeters.cy);

    // Now get the real DPI, adjusted for the round-off error.
    dpiX = dpmmX * 25.4f;
    dpiY = dpmmY * 25.4f;

    // Set the DPI in the metafile
    this->Header.DpiX = dpiX;
    this->Header.DpiY = dpiY;

    // NOTE: On Win9x there are some hi-res printer drivers that use a
    // different resolution for the metafileHdc than they do for the 
    // referenceHdc (Probably to avoid overflow.)  The problem with that 
    // is, that the differing resolutions make it impossible for us to 
    // know which frameRect to use, because we don't know for certain 
    // what DPI the application is going to assume to do its drawing -- 
    // whether the metafile resolution or the printer resolution.  In any
    // case, it's a safe bet that the original frameRect is wrong.

    if (!Globals::IsNt && (frameRectParam != NULL) &&
        (::GetDeviceCaps(metafileHdc, LOGPIXELSX) != ::GetDeviceCaps(referenceHdc, LOGPIXELSX)))
    {
        frameRectParam = NULL;  // give up on the frameRect

        // Now recreate the metafile HDC
        ::DeleteEnhMetaFile(::CloseEnhMetaFile(metafileHdc));
        metafileHdc = CreateEmf(referenceHdc, Filename, frameRectParam);
        if (metafileHdc == NULL)
        {
            return FALSE;       // failed
        }
    }

    // The metafileBounds are used as the bounds for FillRegion
    // calls when the region has infinite bounds, to keep from
    // exploding the bounds of the metafile.
    if (frameRectParam != NULL)
    {

        dpmmX *= 0.01f;
        dpmmY *= 0.01f;

        metafileBounds.X      = rclFrame.left * dpmmX;
        metafileBounds.Y      = rclFrame.top  * dpmmY;
        metafileBounds.Width  = (rclFrame.right  - rclFrame.left) * dpmmX;
        metafileBounds.Height = (rclFrame.bottom - rclFrame.top)  * dpmmY;
    }
    else
    {
        metafileBounds.X      = 0.0f;
        metafileBounds.Y      = 0.0f;
        metafileBounds.Width  = (REAL)szlDevice.cx - 1; // metafile bounds are inclusive
        metafileBounds.Height = (REAL)szlDevice.cy - 1;
    }

    // Now create the recorder object
    MetafileRecorder *  recorder = new MetafileRecorder(
                                        this,
                                        type,
                                        metafileHdc,
                                        (frameRectParam != NULL),
                                        szlMillimeters,
                                        metafileBounds);
    if (CheckValid(recorder))
    {
        MetaGraphics = GpGraphics::GetForMetafile(recorder, type, metafileHdc);
        if (MetaGraphics != NULL)
        {
            if (MetaGraphics->IsValid())
            {
                return TRUE;
            }
            recorder->SetValid(FALSE);// so we don't record stuff in EndRecording
            delete MetaGraphics;    // calls EndRecording which deletes recorder
            MetaGraphics = NULL;
        }
        else
        {
            delete recorder;
        }
    }
ErrorExit:
    DeleteEnhMetaFile(CloseEnhMetaFile(metafileHdc));
    return FALSE;
}

// Returns NULL if the metafile was opened for reading or if already got
// the context for writing.
GpGraphics *
GpMetafile::GetGraphicsContext()
{
    if (!RequestedMetaGraphics)
    {
        RequestedMetaGraphics = TRUE;
        return MetaGraphics;
    }
    WARNING(("Requesting MetaGraphics more than once"));
    return NULL;
}

GpStatus 
GpMetafile::SetDownLevelRasterizationLimit(
    UINT                    metafileRasterizationLimitDpi
    )
{
    ASSERT(IsValid());
    // 0 means restore it to the default value; otherwise, the minumum is 10 dpi
    if ((metafileRasterizationLimitDpi == 0) || (metafileRasterizationLimitDpi >= 10))
    {
        if ((State == GpMetafile::RecordingMetafileState) &&
            (MetaGraphics != NULL))
        {
            MetaGraphics->Context->SetMetafileDownLevelRasterizationLimit(metafileRasterizationLimitDpi);
            return Ok;
        }
        WARNING1("Metafile in Wrong State for this operation");
        return WrongState;
    }
    WARNING1("rasterizationDpiLimit is non-zero but too small");
    return InvalidParameter;
}

GpStatus 
GpMetafile::GetDownLevelRasterizationLimit(
    UINT *                  metafileRasterizationLimitDpi
    ) const
{
    ASSERT(metafileRasterizationLimitDpi != NULL);
    ASSERT(IsValid());
    if ((State == GpMetafile::RecordingMetafileState) &&
        (MetaGraphics != NULL))
    {
        *metafileRasterizationLimitDpi = MetaGraphics->Context->GetMetafileDownLevelRasterizationLimit();
        return Ok;
    }
    WARNING1("Metafile in Wrong State for this operation");
    return WrongState;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\entry\object.cpp ===
/**************************************************************************\
*
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   Object.cpp
*
* Abstract:
*
*   Object factory for playing metafiles
*
* Created:
*
*   9/10/1999 DCurtis
*
\**************************************************************************/

#include "precomp.hpp"
#include "..\imaging\api\comutils.hpp"

GpObject * 
GpObject::Factory(
    ObjectType          type,
    const ObjectData *  objectData,
    UINT                size
    )
{
    GpObject *  object = NULL;
    
    ASSERT(ObjectTypeIsValid(type));

    switch (type)
    {
    case ObjectTypeBrush:
        if (size >= sizeof(ObjectTypeData))
        {
            GpBrushType brushType = (GpBrushType)(((ObjectTypeData *)objectData)->Type);

            switch(brushType)
            {
            case BrushTypeSolidColor:
                object = new GpSolidFill();
                break;
    
            case BrushTypeHatchFill:
                object = new GpHatch();
                break;
    
            case BrushTypeTextureFill:
                object = new GpTexture();
                break;
/*
            // Removed for v1    
            case BrushRectGrad:
                object = new GpRectGradient();
                break;
*/
            case BrushTypeLinearGradient:
                object = new GpLineGradient();
                break;
/*
            // Removed for v1    
            case BrushRadialGrad:
                object = new GpRadialGradient();
                break;
    
            case BrushTriangleGrad:
                object = new GpTriangleGradient();
                break;
*/
            case BrushTypePathGradient:
                object = new GpPathGradient();
                break;
    
            default:
                ASSERT(0);          // unsupported brush type
                break;
            }
        }
        else
        {
            WARNING(("size is too small"));
        }
        break;

    case ObjectTypePen:
        object = new GpPen(GpColor(0,0,0), 1.0f);
        break;
        
    case ObjectTypePath:
        object = new GpPath();
        break;
        
    case ObjectTypeRegion:
        object = new GpRegion();
        break;
        
    case ObjectTypeImage:
        ASSERT(size >= sizeof(INT32));
        if (size >= sizeof(INT32))
        {
            GpImageType imageType = (GpImageType)(((ObjectTypeData *)objectData)->Type);

            switch(imageType)
            {
            case ImageTypeBitmap:
                object = new GpBitmap();
                break;
        
            case ImageTypeMetafile:
                object = new GpMetafile();
                break;

            default:
                ASSERT(0);          // unsupported image type
                break;
            }
        }
        break;
        
    case ObjectTypeFont:
        object = new GpFont();
        break;

    case ObjectTypeStringFormat:
        object = new GpStringFormat();
        break;
        
    case ObjectTypeImageAttributes:
        object = new GpImageAttributes();
        break;
        
    case ObjectTypeCustomLineCap:
        if (size >= sizeof(ObjectTypeData))
        {
            CustomLineCapType capType = (CustomLineCapType)(((ObjectTypeData *)objectData)->Type);

            switch(capType)
            {
            case CustomLineCapTypeDefault:
                object = new GpCustomLineCap();
                break;
    
            case CustomLineCapTypeAdjustableArrow:
                object = new GpAdjustableArrowCap();
                break;
    
            default:
                ASSERT(0);          // unsupported CustomLineCapType
                break;
            }
        }
        else
        {
            WARNING(("size is too small"));
        }
        break;

    default:                    // unsupported object type
        ASSERT(0);
        break;
    }

    return object;
}

class ExternalObjectData
{
public:
    UINT32      DataSize;
    UINT32      DataCRC;
};

UINT 
GpObject::GetExternalDataSize() const
{
    UINT    dataSize = this->GetDataSize();
    
    ASSERT(dataSize >= sizeof(ObjectData));
    ASSERT((dataSize & 0x03) == 0);
    
    return sizeof(ExternalObjectData) + dataSize;
}

GpStatus 
GpObject::GetExternalData(
    BYTE *      dataBuffer, 
    UINT &      size
    )
{
    ASSERT((dataBuffer != NULL) && (size > 0));
    
    if (size < (sizeof(ExternalObjectData) + sizeof(ObjectData)))
    {
        return InsufficientBuffer;
    }
    size -= sizeof(ExternalObjectData);
    BYTE *  objectData = dataBuffer + sizeof(ExternalObjectData);
    
    UINT        checkSum = 0;
    GpStatus    status = this->GetData(objectData, size);
    if (status == Ok)
    {
        checkSum = Crc32(objectData, size, 0);
    }
    
    ((ExternalObjectData *)dataBuffer)->DataSize = size;
    ((ExternalObjectData *)dataBuffer)->DataCRC  = checkSum;
    
    size += sizeof(ExternalObjectData);
    
    return status;
}

GpStatus 
GpObject::SetExternalData(
    const BYTE *    dataBuffer, 
    UINT            size
    )
{
    ASSERT((dataBuffer != NULL) && (size > 0));
    
    if (size < (sizeof(ExternalObjectData) + sizeof(ObjectData)))
    {
        return InsufficientBuffer;
    }
    
    size -= sizeof(ExternalObjectData);
    UINT    dataSize = ((ExternalObjectData *)dataBuffer)->DataSize;
    
    if (size < dataSize)
    {
        return InsufficientBuffer;
    }

    const BYTE *  objectData = dataBuffer + sizeof(ExternalObjectData);
    UINT          checkSum   = Crc32(objectData, dataSize, 0);
    
    if (((ExternalObjectData *)dataBuffer)->DataCRC != checkSum)
    {
        return InvalidParameter;
    }
    
    return this->SetData(objectData, size);
}

class ObjectBufferStream : public IUnknownBase<IStream>
{
public:
    ObjectBufferStream(BYTE * dataBuffer, UINT size)
    {
        ASSERT((dataBuffer != NULL) && (size > 0));
        
        DataBuffer = dataBuffer;
        BufferSize = size;
        Position   = 0;
        Valid      = TRUE;
    }
    
    ~ObjectBufferStream()
    {
    }

    BOOL IsValid() const
    {
        return Valid;
    }

    // how much data did we fill up?
    ULONG GetSize() const { return Position; } 

    HRESULT STDMETHODCALLTYPE Write(
        VOID const HUGEP *pv, 
        ULONG cb, 
        ULONG *pcbWritten) 
    {
        if (cb == 0)
        {
            if (pcbWritten != NULL)
            {
                *pcbWritten = cb;
            }
            return S_OK;
        }

        ASSERT (pv != NULL);

        if (Valid)
        {
            ULONG   spaceLeft = BufferSize - Position;
            
            if (cb <= spaceLeft)
            {
                GpMemcpy(DataBuffer + Position, pv, cb);
                Position += cb;
                if (pcbWritten != NULL)
                {
                    *pcbWritten = cb;
                }
                return S_OK;
            }

            // copy what we can
            if (spaceLeft > 0)
            {
                GpMemcpy(DataBuffer + Position, pv, spaceLeft);
                Position += spaceLeft;
            }

            if (pcbWritten != NULL)
            {
                *pcbWritten = spaceLeft;
            }

            Valid = FALSE;  // tried to write past end of DataBuffer
            WARNING(("Tried to write past end of DataBuffer"));
        }
        return E_FAIL;
    }

    HRESULT STDMETHODCALLTYPE Read(
        VOID HUGEP *pv, 
        ULONG cb, 
        ULONG *pcbRead)
    {
        return E_NOTIMPL;
    }

    HRESULT STDMETHODCALLTYPE Seek(
        LARGE_INTEGER dlibMove, 
        DWORD dwOrigin, 
        ULARGE_INTEGER *plibNewPosition) 
    {
        return E_NOTIMPL;
    }

    HRESULT STDMETHODCALLTYPE SetSize(
        ULARGE_INTEGER libNewSize) 
    {
        return E_NOTIMPL;
    }

    HRESULT STDMETHODCALLTYPE CopyTo(
        IStream *pstm, 
        ULARGE_INTEGER cb, 
        ULARGE_INTEGER *pcbRead, 
        ULARGE_INTEGER *pcbWritten) 
    {
        return E_NOTIMPL;
    }

    HRESULT STDMETHODCALLTYPE Commit(
        DWORD grfCommitFlags) 
    {
        return E_NOTIMPL;
    }

    HRESULT STDMETHODCALLTYPE Revert(VOID) 
    {
        return E_NOTIMPL;
    }

    HRESULT STDMETHODCALLTYPE LockRegion(
        ULARGE_INTEGER libOffset, 
        ULARGE_INTEGER cb, 
        DWORD dwLockType) 
    {
        return E_NOTIMPL;
    }
    
    HRESULT STDMETHODCALLTYPE UnlockRegion(
        ULARGE_INTEGER libOffset, 
        ULARGE_INTEGER cb, 
        DWORD dwLockType) 
    {
        return E_NOTIMPL;
    }

    HRESULT STDMETHODCALLTYPE Stat(
        STATSTG *pstatstg, 
        DWORD grfStatFlag) 
    {
        return E_NOTIMPL;
    }

    HRESULT STDMETHODCALLTYPE Clone(
        IStream **ppstm) 
    {
        return E_NOTIMPL;
    }

private:
    BYTE *  DataBuffer;
    ULONG   BufferSize;
    ULONG   Position;
    BOOL    Valid;
};

GpStatus 
GpObject::GetData(
    BYTE *      dataBuffer, 
    UINT &      size
    ) const
{
    if ((dataBuffer != NULL) && (size > 0))
    {
        ObjectBufferStream  objectBufferStream(dataBuffer, size);
        
        this->GetData(&objectBufferStream);
        size = objectBufferStream.GetSize();
        return objectBufferStream.IsValid() ? Ok : InsufficientBuffer;
    }
    size = 0;
    return InvalidParameter;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\entry\ntfsstream.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   NtfsStream.cpp
*
* Abstract:
*
*   This file provides the Flat File IStream definition.
*
* Created:
*
*   4/26/1999 Mike Hillberg
*
\**************************************************************************/

#include "precomp.hpp"
#include "LargeInt.hpp"
#include "time.h"
#include "FileTime.hpp"
#include "NtfsStream.hpp"

IStream *
CreateStreamOnFile(
    const OLECHAR * pwcsName,
    UINT            access  // GENERIC_READ and/or GENERIC_WRITE
    )
{
    HANDLE          hFile;
    FileStream *    stream;
    UINT            disposition;
    DWORD           grfMode = STGM_SHARE_EXCLUSIVE;
    DWORD           shareMode = 0;
    
    switch (access)
    {
    case GENERIC_READ:
        disposition = OPEN_EXISTING;
        shareMode = FILE_SHARE_READ;
        grfMode |= STGM_READ;
        break;
    
    case GENERIC_WRITE:
        disposition = CREATE_ALWAYS;
        grfMode |= STGM_WRITE;
        break;
        
    // Note that OPEN_ALWAYS does NOT clear existing file attributes (like size)    
    case GENERIC_READ|GENERIC_WRITE:
        disposition = OPEN_ALWAYS;
        grfMode |= STGM_READWRITE;
        break;
        
    default:
        return NULL;
    }

    if (Globals::IsNt)
    {
        hFile = CreateFileW(pwcsName, access, shareMode, NULL, 
                            disposition, FILE_ATTRIBUTE_NORMAL, NULL);
    }
    else // Windows 9x - non-Unicode
    {
        AnsiStrFromUnicode nameStr(pwcsName);

        if (nameStr.IsValid())
        {
            hFile =  CreateFileA(nameStr, access, shareMode, NULL, 
                                 disposition, FILE_ATTRIBUTE_NORMAL, NULL);
        }
        else
        {
            hFile = INVALID_HANDLE_VALUE;
        }
    }

    if ((hFile != INVALID_HANDLE_VALUE) && (hFile != NULL))
    {
        stream = new FileStream();
        if (stream != NULL)
        {
            HRESULT     hResult;
            
            hResult = stream->Init(hFile, grfMode, pwcsName);
                                   
            if (!FAILED(hResult))
            {
                return stream;
            }
            delete stream;
        }
        CloseHandle(hFile);
    }
    return NULL;
}

//+----------------------------------------------------------------------------
//
//  Method:     FileStream::AddRef (IUnknown)
//
//+----------------------------------------------------------------------------

ULONG
FileStream::AddRef()
{
    LONG cRefs;

    cRefs = InterlockedIncrement( &_cRefs );
    return cRefs;
}


//+----------------------------------------------------------------------------
//
//  Method:     FileStream::Release (IUnknown)
//
//+----------------------------------------------------------------------------

ULONG
FileStream::Release()
{
    ULONG ulRet = InterlockedDecrement( &_cRefs );

    if( 0 == ulRet )
        delete this;

    return( ulRet );
}


//+----------------------------------------------------------------------------
//
//  Method:     FileStream::AddRef (IUnknown)
//
//+----------------------------------------------------------------------------

HRESULT
FileStream::QueryInterface(
        REFIID riid,
        void** ppv )
{
    HRESULT sc=S_OK;

    if( IsEqualIID( riid, IID_IUnknown )
        ||
        IsEqualIID( riid, IID_IStream )
        ||
        IsEqualIID( riid, IID_ISequentialStream ) )
    {
        *ppv = static_cast<IStream*>(this);
        AddRef();
        return( S_OK );
    }
    else
    {
        return( E_NOINTERFACE );
    }

    return sc;
}


//+----------------------------------------------------------------------------
//
//  Method:     FileStream::Seek (IStream)
//
//+----------------------------------------------------------------------------

HRESULT
FileStream::Seek(
        LARGE_INTEGER dlibMove,
        DWORD dwOrigin,
        ULARGE_INTEGER *puliNewPos)
{
    HRESULT sc = S_OK;
    LARGE_INTEGER liFileSize;
    LARGE_INTEGER liNewPos;

    Lock( INFINITE );

    switch( dwOrigin )
    {
    case STREAM_SEEK_SET:
        liNewPos.QuadPart = dlibMove.QuadPart;
        break;

    case STREAM_SEEK_CUR:
        liNewPos.QuadPart = _liCurrentSeekPosition.QuadPart + dlibMove.QuadPart;
        break;

    case STREAM_SEEK_END:
        liFileSize.LowPart = GetFileSize( _hFile,
                                         (ULONG*)(&liFileSize.HighPart) );

        if( 0xFFFFFFFF == liFileSize.LowPart && NO_ERROR != GetLastError() )
        {
            nffChk( HRESULT_FROM_WIN32( GetLastError() ) );
        }

        liNewPos.QuadPart = liFileSize.QuadPart + dlibMove.QuadPart;
        break;

    default:
        break;
    }

    // Compatibility with Docfile.  Seeking < 0 fails.
    if( liNewPos.QuadPart < 0 )
        nffErr( EH_Err, STG_E_INVALIDFUNCTION );

    _liCurrentSeekPosition = liNewPos;


    // If desired, give the caller the now-current seek position.
    if( NULL != puliNewPos )
        *puliNewPos = _liCurrentSeekPosition;

EH_Err:
    Unlock();
    return( sc );
}


//+----------------------------------------------------------------------------
//
//  Method:     FileStream::SetSize (IStream)
//
//+----------------------------------------------------------------------------

HRESULT
FileStream::SetSize(
        ULARGE_INTEGER uliNewSize)
{
    HRESULT sc = S_OK;
    CLargeInteger liEOF;

    if ( uliNewSize.HighPart != 0 )
        nffErr(EH_Err, STG_E_INVALIDFUNCTION);


    Lock( INFINITE );

    nffChk( CheckReverted() );

    // If this stream is mapped, set the size accordingly

    sc = SetFileSize( CULargeInteger(uliNewSize) );

    if( !FAILED(sc) )
        sc = S_OK;

EH_Err:

    Unlock();
    return( sc);

}

//+----------------------------------------------------------------------------
//
//  Method:     FileStream::CopyTo (IStream)
//
//+----------------------------------------------------------------------------

HRESULT
FileStream::CopyTo(
        IStream *pstm,
        ULARGE_INTEGER cb,
        ULARGE_INTEGER *pcbRead,
        ULARGE_INTEGER *pcbWritten)
{

    HRESULT sc = S_OK;
    PVOID pv = NULL;
    ULONG cbRead = 0, cbWritten = 0;
    CULargeInteger cbReadTotal = 0, cbWrittenTotal = 0;
    CLargeInteger liZero = 0;
    CULargeInteger uliOriginalSourcePosition, uliOriginalDestPosition;
    CULargeInteger cbSourceSize, cbDestSize;
    ULONG cbPerCopy = 0;
    STATSTG statstg;
    CULargeInteger cbRequested = cb;
    BOOL fCopyForward;

    Lock( INFINITE );

    nffChk( CheckReverted() );

    if( NULL == pstm)
        nffErr( EH_Err, STG_E_INVALIDPARAMETER );

    // Determine how much we'll copy at a time.
    // As of this writing, STREAMBUFFERSIZE is 8192 bytes

    if( cbRequested > STREAMBUFFERSIZE )
        cbPerCopy = STREAMBUFFERSIZE;
    else
        cbPerCopy = cbRequested.LowPart;

    //  ------------------------------------------------------------------
    //  Get the current stream sizes/positions, and adjust the destination
    //  size if necessary
    //  ------------------------------------------------------------------

    nffChk( this->Seek( liZero, STREAM_SEEK_CUR, &uliOriginalSourcePosition ) );

    nffChk( pstm->Seek( liZero, STREAM_SEEK_CUR, &uliOriginalDestPosition ) );

    nffChk( this->Stat( &statstg, STATFLAG_NONAME ) );

    cbSourceSize = statstg.cbSize;

    nffChk( pstm->Stat( &statstg, STATFLAG_NONAME ) );

    cbDestSize = statstg.cbSize;

    // Ensure the sizes are valid (we can't handle anything with the high bit
    // set, because Seek takes a signed offset).

    if( static_cast<CLargeInteger>(cbSourceSize) < 0
        ||
        static_cast<CLargeInteger>(cbDestSize) < 0 )
    {
        nffErr( EH_Err, STG_E_INVALIDHEADER );
    }

    // Don't copy more than the source stream has available
    if( cbRequested > cbSourceSize - uliOriginalSourcePosition )
        cbRequested = cbSourceSize - uliOriginalSourcePosition;

    // If necessary, grow the destination stream.

    if( cbSourceSize - uliOriginalSourcePosition > cbDestSize - uliOriginalDestPosition )
    {
        cbDestSize = cbSourceSize - uliOriginalSourcePosition + uliOriginalDestPosition;
        nffChk( pstm->SetSize( cbDestSize ) );
    }

    //  ----------------------
    //  Allocate a copy buffer
    //  ----------------------

    nffMem( pv = CoTaskMemAlloc( cbPerCopy ) );

    //  -----------------------------------------------------------------------------
    //  Determine if we're copying forwards (high seek position to low) or backwards.
    //  -----------------------------------------------------------------------------

    fCopyForward = TRUE;
    if( uliOriginalSourcePosition < uliOriginalDestPosition )
    {
        // E.g., say we're copying 15 bytes from offset 0 to offset 5,
        // and we're only able to copy 10 bytes at a time.
        // If we copy bytes 0-9 to offset 5, we'll end up overwriting
        // bytes 10-14, and be unable to complete the copy.
        // So instead, we'll copy bytes 5-14 to offset 10, and finish
        // up by copying bytes 0-4 to offset 5.

        fCopyForward = FALSE;

        // To do this kind of backwards copy, we need to start by seeking
        // towards the end of the stream.

        CULargeInteger uliNewSourcePosition, uliNewDestPosition;

        uliNewSourcePosition = cbSourceSize - cbPerCopy;
        nffChk( this->Seek( uliNewSourcePosition, STREAM_SEEK_SET, NULL ) );

        uliNewDestPosition = cbDestSize - cbPerCopy;
        nffChk( pstm->Seek( uliNewDestPosition, STREAM_SEEK_SET, NULL ) );

    }

    //  --------------
    //  Copy in chunks
    //  --------------

    cbPerCopy = cbRequested > cbPerCopy ? cbPerCopy : cbRequested.LowPart;
    while( cbRequested > 0 )
    {
        // Read from the source
        nffChk( this->Read( pv, cbPerCopy, &cbRead ) );

        if( cbRead != cbPerCopy )
            nffErr(EH_Err, STG_E_READFAULT);

        cbReadTotal += cbRead;

        // Write to the dest
        nffChk( pstm->Write( pv, cbPerCopy, &cbWritten ) );

        if( cbWritten != cbPerCopy )
            nffErr( EH_Err, STG_E_WRITEFAULT );

        cbWrittenTotal += cbWritten;

        // Adjust the amount remaining to be copied
        cbRequested -= cbPerCopy;


        // Determine how much to copy in the next iteration (this will
        // always be cbPerCopy until the last iteration).  If copying
        // backwards, we need to manually adjust the seek pointer.

        cbPerCopy = (cbRequested > cbPerCopy) ? cbPerCopy : cbRequested.LowPart;
        if( !fCopyForward && (cbRequested > 0))
        {
            nffChk( this->Seek( -static_cast<CLargeInteger>(cbPerCopy+STREAMBUFFERSIZE),
                                                STREAM_SEEK_CUR, NULL ) );

            nffChk( pstm->Seek( -static_cast<CLargeInteger>(cbPerCopy+STREAMBUFFERSIZE),
                                                STREAM_SEEK_CUR, NULL ) );
        }

    }

    // If we were backward-copying, adjust the seek pointers
    // as if we had forward-copied

    if( !fCopyForward )
    {
        uliOriginalSourcePosition += cbReadTotal;
        nffChk( this->Seek( uliOriginalSourcePosition, STREAM_SEEK_SET, NULL ) );

        uliOriginalDestPosition += cbWrittenTotal;
        nffChk( pstm->Seek( uliOriginalDestPosition, STREAM_SEEK_SET, NULL ) );
    }

    //  ----
    //  Exit
    //  ----

    if( NULL != pcbRead )
        *pcbRead = cbReadTotal;
    if( NULL != pcbWritten )
        *pcbWritten = cbWrittenTotal;

EH_Err:

    if( NULL != pv )
        CoTaskMemFree(pv);

    Unlock();
    return(sc);

}


//+----------------------------------------------------------------------------
//
//  Method:     FileStream::Commit (IStream)
//
//+----------------------------------------------------------------------------

HRESULT
FileStream::Commit( DWORD grfCommitFlags )
{
    HRESULT sc = S_OK;

    Lock( INFINITE );

    nffChk( CheckReverted() );

    // NTRAID#NTBUG9-368729-2001-04-13-gilmanw "ISSUE: FileStream object - handle other stream commit flags"
    // Are there other commit flags that need to be handled?

    if( !(STGC_DANGEROUSLYCOMMITMERELYTODISKCACHE  & grfCommitFlags) )
    {
        if( !FlushFileBuffers( _hFile ))
            sc = HRESULT_FROM_WIN32( GetLastError() );
    }

EH_Err:
    Unlock();
    return sc;

}


//+----------------------------------------------------------------------------
//
//  Method:     FileStream::Revert (IStream)
//
//+----------------------------------------------------------------------------

HRESULT
FileStream::Revert(void)
{
    // We only support direct-mode.

    return CheckReverted();
}



//+----------------------------------------------------------------------------
//
//  Method:     FileStream::LockRegion (IStream)
//
//+----------------------------------------------------------------------------

HRESULT
FileStream::LockRegion(
    ULARGE_INTEGER libOffset,
    ULARGE_INTEGER cb,
    DWORD dwLockType)
{
    HRESULT sc = S_OK;

    Lock( INFINITE );

    nffChk( CheckReverted() );

    // NTRAID#NTBUG9-368745-2001-04-13-gilmanw "ISSUE: FileStream::LockRegion - handle other lock flags"
    // Are all the lock types supported here?

    if (dwLockType != LOCK_EXCLUSIVE && dwLockType != LOCK_ONLYONCE)
        nffErr( EH_Err, STG_E_INVALIDFUNCTION );

    if( !LockFile( _hFile, libOffset.LowPart, libOffset.HighPart,
                   cb.LowPart, cb.HighPart))
    {
        nffErr( EH_Err, HRESULT_FROM_WIN32( GetLastError() ));
    }

EH_Err:

    Unlock();
    return( sc );

}


//+----------------------------------------------------------------------------
//
//  Method:     FileStream::Stat (IStream)
//
//+----------------------------------------------------------------------------

HRESULT
FileStream::Stat(
        STATSTG *pstatstg,
        DWORD grfStatFlag)
{
    STATSTG statstg;
    HRESULT sc = S_OK;

    BY_HANDLE_FILE_INFORMATION ByHandleFileInformation;

    statstg.pwcsName = NULL;

    Lock( INFINITE );

    nffChk( CheckReverted() );

    ZeroMemory((void*)&statstg, sizeof(STATSTG));

    // Get the name, if desired

    if( (STATFLAG_NONAME & grfStatFlag) )
        statstg.pwcsName = NULL;
    else
    {
        nffMem( statstg.pwcsName = reinterpret_cast<WCHAR*>
                                   ( CoTaskMemAlloc( sizeof(WCHAR)*(UnicodeStringLength(_pwcsName) + 1) )));
        UnicodeStringCopy( statstg.pwcsName, _pwcsName );
    }

    // Get the type
    statstg.type = STGTY_STREAM;

    statstg.grfLocksSupported = LOCK_EXCLUSIVE | LOCK_ONLYONCE;

    // Get the size & times.

    if( !GetFileInformationByHandle( _hFile, &ByHandleFileInformation ))
        nffErr( EH_Err, HRESULT_FROM_WIN32( GetLastError() ));

    statstg.cbSize.LowPart = ByHandleFileInformation.nFileSizeLow;
    statstg.cbSize.HighPart = ByHandleFileInformation.nFileSizeHigh;

    // We get a time back in ByHandleFileInformation, but it's the file's times,
    // not the streams times.  So really the stream times are not supported, and
    // we'll just set them to zero.

    statstg.mtime = statstg.atime = statstg.ctime = CFILETIME(0);

    // Get the STGM modes
    statstg.grfMode = _grfMode & ~STGM_CREATE;

    *pstatstg = statstg;

EH_Err:
    if( FAILED(sc) && NULL != statstg.pwcsName )
        CoTaskMemFree( statstg.pwcsName );

    Unlock();
    return( sc );

}



//+----------------------------------------------------------------------------
//
//  Method:     FileStream::Clone (IStream)
//
//+----------------------------------------------------------------------------

HRESULT
FileStream::Clone(
        IStream** ppstm)
{
    // NTRAID#NTBUG9-368747-2001-04-13-gilmanw "ISSUE: FileStream::Clone returns E_NOTIMPL"

    return( E_NOTIMPL );
}


//+----------------------------------------------------------------------------
//
//  Method:     FileStream::Read (IStream)
//
//+----------------------------------------------------------------------------

HRESULT
FileStream::Read(
        void* pv,
        ULONG cb,
        ULONG* pcbRead)
{
    LARGE_INTEGER   lOffset;
    HRESULT         sc     = S_OK;
    ULONG           cbRead = 0;

    lOffset.LowPart  = _liCurrentSeekPosition.LowPart;
    lOffset.HighPart = _liCurrentSeekPosition.HighPart;

    if (lOffset.HighPart < 0)
    {
        return( TYPE_E_SIZETOOBIG );
    }

    Lock( INFINITE );

    nffChk( CheckReverted() );

    if(SetFilePointer(_hFile, lOffset.LowPart, &lOffset.HighPart, 
                      FILE_BEGIN) == INVALID_SET_FILE_POINTER)
    {
        nffChk( HRESULT_FROM_WIN32(GetLastError()));
    }

    if(!ReadFile(_hFile, pv, cb, &cbRead, NULL))
    {
        nffChk( HRESULT_FROM_WIN32(GetLastError()));
    }

    _liCurrentSeekPosition += cbRead;
    if( NULL != pcbRead )
        *pcbRead = cbRead;

EH_Err:

    Unlock();
    return( sc );

}


//+----------------------------------------------------------------------------
//
//  Method:     FileStream::Write (IStream)
//
//+----------------------------------------------------------------------------

HRESULT
FileStream::Write(
        const void* pv,
        ULONG cb,
        ULONG* pcbWritten)
{
    LARGE_INTEGER   lOffset;
    HRESULT         sc = S_OK;
    ULONG           cbWritten = 0;

    lOffset.LowPart  = _liCurrentSeekPosition.LowPart;
    lOffset.HighPart = _liCurrentSeekPosition.HighPart;

    if (lOffset.HighPart < 0)
    {
        return( TYPE_E_SIZETOOBIG );
    }

    Lock( INFINITE );

    nffChk( CheckReverted() );

    if(SetFilePointer(_hFile, lOffset.LowPart, &lOffset.HighPart, 
                      FILE_BEGIN) == INVALID_SET_FILE_POINTER)
    {
        nffChk( HRESULT_FROM_WIN32(GetLastError()));
    }

    if(!WriteFile(_hFile, pv, cb, &cbWritten, NULL))
    {
        nffChk(HRESULT_FROM_WIN32(GetLastError()));
    }

    _liCurrentSeekPosition += cbWritten;

    if( NULL != pcbWritten )
        *pcbWritten = cbWritten;

EH_Err:

    Unlock();
    return( sc );

}


//+-------------------------------------------------------------------
//
//  Member:     FileStream  Constructor
//
//--------------------------------------------------------------------

FileStream::FileStream(  )
{
    _cRefs = 1;
    _grfMode = 0;
    _hFile = INVALID_HANDLE_VALUE;
    _liCurrentSeekPosition = 0;
    _pwcsName = NULL;
    _bCritSecInitialized = FALSE;

    __try
    {
        InitializeCriticalSection( &_critsec );
        _bCritSecInitialized = TRUE;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        // If we've thrown then _bCritSecInitialized will be FALSE and
        // Init() will automatically fail.
    }

}


//+-------------------------------------------------------------------
//
//  Member:     FileStream  Destructor
//
//--------------------------------------------------------------------

FileStream::~FileStream()
{

    // Close the file
    if( INVALID_HANDLE_VALUE != _hFile )
        CloseHandle( _hFile );

    if( NULL != _pwcsName )
        CoTaskMemFree( _pwcsName );

    if (_bCritSecInitialized)
    {
        // We don't need to reset _bCrisSecInitialized to FALSE since the
        // object has been destroyed
        DeleteCriticalSection( &_critsec );
    }
}


//+-------------------------------------------------------------------
//
//  Member:     FileStream::Init
//
//--------------------------------------------------------------------

HRESULT
FileStream::Init(
        HANDLE hFile,               // File handle of this Stream.
        DWORD grfMode,              // Open Modes
        const OLECHAR * pwcsName)   // Name of the Stream
{
    // If we couldn't allocate the critical section then return an Error
    if (!_bCritSecInitialized)
    {
        return E_FAIL;
    }

    HRESULT sc=S_OK;
    HANDLE ev;

    // We now own this file handle, and are responsible for closing it.
    _hFile = hFile;

    // Save the STGM_ flags so we can return them in a Stat call.
    _grfMode = grfMode;

    // Save the stream name

    if( NULL != _pwcsName )
    {
        CoTaskMemFree( _pwcsName );
        _pwcsName = NULL;
    }

    if( NULL != pwcsName )
    {
        nffMem( _pwcsName = reinterpret_cast<WCHAR*>
                            ( CoTaskMemAlloc( sizeof(WCHAR)*(UnicodeStringLength(pwcsName) + 1) )));
        UnicodeStringCopy( _pwcsName, pwcsName );
    }

EH_Err:
    return sc;
}


//+----------------------------------------------------------------------------
//
//  FileStream    Non-Interface::ShutDown
//
//  Flush data, Close File handle and mark the object as reverted.
//  This is called when the Storage is released and when the Oplock Breaks.
//
//+----------------------------------------------------------------------------

HRESULT
FileStream::ShutDown()
{
    HRESULT sc=S_OK;

    if( INVALID_HANDLE_VALUE == _hFile )
        return S_OK;

    //
    // Close the file/stream handle and mark the IStream object as
    // Reverted by giving the file handle an invalid value.
    //
    CloseHandle(_hFile);
    _hFile = INVALID_HANDLE_VALUE;

    return S_OK;
}


//+----------------------------------------------------------------------------
//
//  FileStream::SetFileSize (private, non-interface method)
//
//  Set the size of the _hFile.  This is used by the IStream & IMappedStream
//  SetSize methods
//
//+----------------------------------------------------------------------------

HRESULT // private
FileStream::SetFileSize( const CULargeInteger &uliNewSize )
{
    HRESULT sc = S_OK;
    CLargeInteger liEOF;

    // We have to convert uliNewSize into a LARGE_INTEGER, so ensure that it can
    // be cast without loss of data.

    liEOF = static_cast<CLargeInteger>(uliNewSize);
    if( liEOF < 0 )
        nffErr( EH_Err, STG_E_INVALIDPARAMETER );

    // Move to what will be the new end-of-file position.

    liEOF.LowPart = SetFilePointer( _hFile, liEOF.LowPart,
                                    &liEOF.HighPart, FILE_BEGIN );
    if( 0xFFFFFFFF == liEOF.LowPart && NO_ERROR != GetLastError() )
        nffErr( EH_Err, HRESULT_FROM_WIN32( GetLastError() ));

    // Set this as the new eof

    if( !SetEndOfFile( _hFile ))
        nffErr( EH_Err, HRESULT_FROM_WIN32( GetLastError() ));

EH_Err:

    return( sc );

}


HRESULT
FileStream::UnlockRegion(
        ULARGE_INTEGER libOffset,
        ULARGE_INTEGER cb,
        DWORD dwLockType)
{
    HRESULT sc = S_OK;

    Lock( INFINITE );

    nffChk( CheckReverted() );

    if (dwLockType != LOCK_EXCLUSIVE && dwLockType != LOCK_ONLYONCE)
    {
        nffErr( EH_Err, STG_E_INVALIDFUNCTION );
    }

    if( !UnlockFile(_hFile, libOffset.LowPart, libOffset.HighPart,
                    cb.LowPart, cb.HighPart))
    {
        nffErr( EH_Err, HRESULT_FROM_WIN32(GetLastError()) );
    }

EH_Err:

    Unlock();
    return( sc );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\entry\ntfsstream.hpp ===
/**************************************************************************\
* 
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   NtfsStream.hpp
*
* Abstract:
*
*   This file provides the Flat File IStream implementation.
*
* Created:
*
*   4/26/1999 Mike Hillberg
*
\**************************************************************************/

#pragma once

#ifndef _NTFSSTREAM_HPP
#define _NTFSSTREAM_HPP

#define ErrJmp(comp, label, errval, var) \
{\
    var = errval;\
    goto label;\
}

#define nffErr(l, e) ErrJmp(nff, l, e, sc)

#define nffChkTo(l, e) if (FAILED(sc = (e))) nffErr(l, sc) else 1
#define nffChk(e) nffChkTo(EH_Err, e)

#define nffHChkTo(l, e) if (FAILED(sc = DfGetScode(e))) nffErr(l, sc) else 1
#define nffHChk(e) nffHChkTo(EH_Err, e)

#define nffMemTo(l, e) \
    if ((e) == NULL) nffErr(l, STG_E_INSUFFICIENTMEMORY) else 1
#define nffMem(e) nffMemTo(EH_Err, e)

#define nffBoolTo(l, e) if (!(e)) nffErr(l, LAST_STG_SCODE) else 1
#define nffBool(e)   nffBoolTo(EH_Err, e)

#define STREAMBUFFERSIZE 8192


////////////////////////////////////////////////////////////////
//  IStream for a file stream.
//
class FileStream : public IStream
{

    //  ------------
    //  Construction
    //  ------------

public:

    FileStream(  );
    virtual ~FileStream();
    virtual HRESULT Init( HANDLE hFile,
                          DWORD grfMode,
                          const OLECHAR *pwcsName );

    //  --------
    //  IUnknown
    //  --------

    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObject);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);


    //  -------
    //  IStream
    //  -------

    HRESULT STDMETHODCALLTYPE Read(
        /* [length_is][size_is][out] */ void __RPC_FAR *pv,
        /* [in] */ ULONG cb,
        /* [out] */ ULONG __RPC_FAR *pcbRead);

    HRESULT STDMETHODCALLTYPE Write(
        /* [size_is][in] */ const void __RPC_FAR *pv,
        /* [in] */ ULONG cb,
        /* [out] */ ULONG __RPC_FAR *pcbWritten);

    HRESULT STDMETHODCALLTYPE Seek(
        /* [in] */ LARGE_INTEGER dlibMove,
        /* [in] */ DWORD dwOrigin,
        /* [out] */ ULARGE_INTEGER __RPC_FAR *plibNewPosition);

    HRESULT STDMETHODCALLTYPE SetSize(
        /* [in] */ ULARGE_INTEGER libNewSize);

    HRESULT STDMETHODCALLTYPE CopyTo(
        /* [unique][in] */ IStream __RPC_FAR *pstm,
        /* [in] */ ULARGE_INTEGER cb,
        /* [out] */ ULARGE_INTEGER __RPC_FAR *pcbRead,
        /* [out] */ ULARGE_INTEGER __RPC_FAR *pcbWritten);

    HRESULT STDMETHODCALLTYPE Commit(
        /* [in] */ DWORD grfCommitFlags);

    HRESULT STDMETHODCALLTYPE Revert(void);

    HRESULT STDMETHODCALLTYPE LockRegion(
        /* [in] */ ULARGE_INTEGER libOffset,
        /* [in] */ ULARGE_INTEGER cb,
        /* [in] */ DWORD dwLockType);

    HRESULT STDMETHODCALLTYPE UnlockRegion(
        /* [in] */ ULARGE_INTEGER libOffset,
        /* [in] */ ULARGE_INTEGER cb,
        /* [in] */ DWORD dwLockType);

    HRESULT STDMETHODCALLTYPE Stat(
        /* [out] */ STATSTG __RPC_FAR *pstatstg,
        /* [in] */ DWORD grfStatFlag);

    HRESULT STDMETHODCALLTYPE Clone(
        /* [out] */ IStream __RPC_FAR *__RPC_FAR *ppstm);

public:

    inline BOOL IsWriteable();
    HRESULT CheckReverted();


    //  ----------------
    //  Internal Methods
    //  ----------------

protected:

    virtual HRESULT ShutDown();
    HRESULT Delete();

private:

    HRESULT SetFileSize( const CULargeInteger &uliNewSize );
    HRESULT Rename( const WCHAR *pwcsName, BOOL fOverWrite );

    inline HRESULT Lock( DWORD dwTimeout );
    inline HRESULT Unlock();

    static HRESULT DeleteStream( HANDLE *phStream );

    HANDLE GetFileHandle();


    //  --------------
    //  Internal State
    //  --------------

private:

    CRITICAL_SECTION    _critsec;
    BOOL                _bCritSecInitialized;
    WCHAR *             _pwcsName;

    DWORD               _grfMode;               // The mode used to open the IStream
    HANDLE              _hFile;                 // File represented by this stream

    LONG                _cRefs;                 // Reference count


    // This class maintains its own copy of the seek pointer, different from
    // the underlying file's.  This is necessary so that the IStream methods mantain
    // a consistent seek location, even when methods on e.g. IMappedStream are called.

    CLargeInteger       _liCurrentSeekPosition;

};   // class FileStream


inline HANDLE
FileStream::GetFileHandle()
{
    return _hFile;
}

inline HRESULT
FileStream::CheckReverted()
{
    if(INVALID_HANDLE_VALUE == _hFile)
        return STG_E_REVERTED;

    return S_OK;
}


inline BOOL
GrfModeIsWriteable( DWORD grfMode )
{
    return( (STGM_WRITE & grfMode) || (STGM_READWRITE & grfMode) );
}


inline BOOL
FileStream::IsWriteable()
{
    return( GrfModeIsWriteable( _grfMode ));
}


inline HRESULT
FileStream::Lock( DWORD dwTimeout )
{
    EnterCriticalSection( &_critsec );
    return( S_OK );
}


inline HRESULT
FileStream::Unlock()
{
    LeaveCriticalSection( &_critsec );
    return( S_OK );
}

#endif // _NTFSSTREAM_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\entry\object.hpp ===
/**************************************************************************\
*
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   Object.hpp
*
* Abstract:
*
*   GpObject interface class
*
* Created:
*
*   4/22/1999 DCurtis
*
\**************************************************************************/

#ifndef _OBJECT_HPP
#define _OBJECT_HPP

// The version must be changed when any EMF+ record is changed, including
// when an object record is changed.
// Changes that invalidate previous files require a major version number change.
// Other changes just require a minor version number change.
#define EMFPLUS_VERSION             0xdbc01001
#define EMFPLUS_MAJORVERSION_BITS   0xFFFFF000
#define EMFPLUS_MINORVERSION_BITS   0x00000FFF

// The GetData methods for all objects must all return a data buffer that
// has a version number as the first INT32 field.
class ObjectData
{
public:
    INT32       Version;

    ObjectData()
    {
        Version = EMFPLUS_VERSION;
    }

    // We should be able to understand the data format as long as the
    // major version numbers match.  The code must be able to handle
    // minor version number changes.
    BOOL MajorVersionMatches() const
    {
        return MajorVersionMatches(Version);
    }

    static BOOL MajorVersionMatches(INT version)
    {
        return ((version & EMFPLUS_MAJORVERSION_BITS) ==
                (EMFPLUS_VERSION & EMFPLUS_MAJORVERSION_BITS));
    }
};

class ObjectTypeData : public ObjectData
{
public:
    INT32       Type;
};

VOID InitVersionInfo();

enum EmfPlusRecordType;
enum ColorAdjustType;
class GpRecolor;

class GpObject
{
public:
    GpObject()
    {
        Uid = 0;
        Tag = ObjectTagInvalid;    // Invalid state
    }

    virtual ~GpObject()
    {
        // Force the object to be invalid so we can't reuse this
        // deleted object accidentally.
        Tag = ObjectTagInvalid;    // Invalid state
    }
    virtual BOOL IsValid() const = 0;
    BOOL IsValid(ObjectTag objectTag) const
    {
    #ifdef _X86_
        // We have to guarantee that the Tag field doesn't move for
        // versioning to work between releases of GDI+.
        ASSERT(offsetof(GpObject, Tag) == 4);
    #endif

        ASSERT((objectTag & 0xff) == '1');

    #if DBG
        if (Tag == ObjectTagInvalid)
        {
            WARNING1("Invalid Object");
        }
        else if ((Tag & 0xff) != '1')
        {
            WARNING1("Object created by different version of GDI+")
        }
        else
        {
            ASSERT(objectTag == Tag);
        }
    #endif

        return (objectTag == Tag);
    }
    VOID SetValid(ObjectTag objectTag)
    {
        ASSERT((objectTag == ObjectTagInvalid) || ((objectTag & 0xff) == '1'))
        Tag = objectTag;
    }

    virtual ObjectType GetObjectType() const = 0;
    virtual UINT GetDataSize() const = 0;
    virtual GpStatus GetData(BYTE * dataBuffer, UINT & size) const;
    virtual GpStatus GetData(IStream * stream) const = 0;
    virtual GpStatus SetData(const BYTE * dataBuffer, UINT size) = 0;
    virtual GpStatus ColorAdjust(
        GpRecolor *             recolor,
        ColorAdjustType         type
        )
    {
        return Ok;
    }
    virtual VOID Dispose() { delete this; }

    UINT GetExternalDataSize() const;
    GpStatus GetExternalData(BYTE * dataBuffer, UINT & size);
    GpStatus SetExternalData(const BYTE * data, UINT size);

    UINT GetUid() const
    {   if(Uid == 0)
        {
            Uid = GpObject::GenerateUniqueness();
        }
        return (UINT)Uid;
    }
    VOID UpdateUid() { Uid = 0; }

    // SetUid is useful in cloning operations.
    VOID SetUid(UINT newUid) { Uid = (LONG_PTR)newUid; }

    // Object factory for creating an object from metafile memory
    static GpObject *
    Factory(
        ObjectType          type,
        const ObjectData *  objectData,
        UINT                size
        );

    static LONG_PTR
    GenerateUniqueness(
        )
    {
        LONG_PTR Uid;

        // !!! Until we get a way to make sure GDI+ has been initialized when
        // !!! using it as a static lib, we need this check because if there
        // !!! is a global object, this could get called before
        // !!! InitializeGdiplus() is called (for static lib case).

        if (!Globals::VersionInfoInitialized)
        {
            InitVersionInfo();
        }

        // Use InterlockedCompareExchangeFunction instead of
        // InterlockedIncrement, because InterlockedIncrement doesn't work
        // the way we need it to on Win9x.

        do
        {
            Uid = Uniqueness;
        } while (CompareExchangeLong_Ptr(&Uniqueness, (Uid + 1), Uid) != Uid);

        return (Uid + 1);
    }

private:
    // These members are declared as LONG_PTR because they have to be aligned
    // to, and sized according to the minimum atomically exchangable object.
    // On x86 this is 32bits and on IA64 this is 64bits.
    static LONG_PTR     Uniqueness;

    // We now use an ObjectTag to determine if the object is valid
    // instead of using a BOOL.  This is much more robust and helps
    // with debugging.  It also enables us to version our objects
    // more easily with a version number in the ObjectTag.
    ObjectTag           Tag;    // Keep this as the 1st value in the object!
    mutable LONG_PTR            Uid;
};

#endif // !_OBJECT_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\entry\path.cpp ===
/**************************************************************************\
*
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   path.cpp
*
* Abstract:
*
*   Implementation of the GpPath and DpPath classes
*
* Revision History:
*
*   12/11/1998 davidx
*       Add path functions.
*
*   12/07/1998 davidx
*       Initial placeholders.
*
\**************************************************************************/

#include "precomp.hpp"

//-------------------------------------------------------------
// ReversePath(), CombinePaths(), CalculateGradientArray(), and
// GetMajorAndMinorAxis(), and GetFastAngle are defined in
// PathWidener.cpp.
//-------------------------------------------------------------

extern GpStatus
ReversePath(
    INT count,
    GpPointF* points,
    BYTE* types
    );

extern INT
CombinePaths(
    INT count,
    GpPointF* points,
    BYTE* types,
    INT count1,
    const GpPointF* points1,
    const BYTE* types1,
    BOOL forward1,
    INT count2,
    const GpPointF* points2,
    const BYTE* types2,
    BOOL forward2,
    BOOL connect
    );

extern GpStatus
CalculateGradientArray(
    GpPointF* grad,
    REAL* distances,
    const GpPointF* points,
    INT count
    );

extern GpStatus
GetMajorAndMinorAxis(
    REAL* majorR,
    REAL* minorR,
    const GpMatrix* matrix
    );

VOID NormalizeAngle(REAL* angle, REAL width, REAL height);

INT NormalizeArcAngles(
    REAL* startAngle,
    REAL* sweepAngle,
    REAL width,
    REAL height
    );

// Note that this is different from GpPathData.

class MetaPathData : public ObjectData
{
public:
    UINT32      Count;
    INT32       Flags;
};


/**************************************************************************\
*
* Function Description:
*
*   Get the path data.
*
* Arguments:
*
*   [IN] dataBuffer - fill this buffer with the data
*   [IN/OUT] size   - IN - size of buffer; OUT - number bytes written
*
* Return Value:
*
*   GpStatus - Ok or error code
*
* Created:
*
*   9/13/1999 DCurtis
*
\**************************************************************************/
GpStatus
DpPath::GetData(
    IStream *   stream
    ) const
{
    ASSERT (stream != NULL);

    INT                 count      = Points.GetCount();
    MetafilePointData   pointData(Points.GetDataBuffer(), count);
    UINT                pointsSize = pointData.GetDataSize();
    INT                 flags      = pointData.GetFlags();

    if (FillMode == FillModeWinding)
    {
        flags |= GDIP_EPRFLAGS_WINDINGFILL;
    }

    MetaPathData    pathData;
    pathData.Count = count;
    pathData.Flags = flags;
    stream->Write(&pathData, sizeof(pathData), NULL);

    stream->Write(pointData.GetData(), pointsSize, NULL);
    stream->Write(Types.GetDataBuffer(), count, NULL);

    // align
    if ((count & 0x03) != 0)
    {
        INT     pad = 0;
        stream->Write(&pad, 4 - (count & 0x03), NULL);
    }

    return Ok;
}

UINT
DpPath::GetDataSize() const
{
    INT                 count      = Points.GetCount();
    MetafilePointData   pointData(Points.GetDataBuffer(), count);
    UINT                pointsSize = pointData.GetDataSize();
    UINT                dataSize   = sizeof(MetaPathData) + pointsSize + count;

    return ((dataSize + 3) & (~3)); // align
}

/**************************************************************************\
*
* Function Description:
*
*   Read the path object from memory.
*
* Arguments:
*
*   [IN] memory - the data that was read from the stream
*   [IN] size   - the size of the memory data
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   4/26/1999 DCurtis
*
\**************************************************************************/
GpStatus
DpPath::SetData(
    const BYTE *    dataBuffer,
    UINT            size
    )
{
    Points.Reset();
    Types.Reset();

    if (dataBuffer == NULL)
    {
        WARNING(("dataBuffer is NULL"));
        return InvalidParameter;
    }

    if (size >= sizeof(MetaPathData))
    {
        const MetaPathData *    pathData = reinterpret_cast<const MetaPathData *>(dataBuffer);

        if (!pathData->MajorVersionMatches())
        {
            WARNING(("Version number mismatch"));
            return InvalidParameter;
        }

        InitDefaultState(::GetFillMode(pathData->Flags));
        SetValid(TRUE);

        INT     count = pathData->Count;

        if (count > 0)
        {
            UINT        pointDataSize;

            if ((pathData->Flags & GDIP_EPRFLAGS_COMPRESSED) != 0)
            {
                pointDataSize = count * sizeof(GpPoint16);
            }
            else
            {
                pointDataSize = count * sizeof(GpPointF);
            }

            if (size >= sizeof(MetaPathData) + count + pointDataSize)
            {
                GpPointF *      points = Points.AddMultiple(count);
                BYTE *          types  = Types.AddMultiple(count);
                const BYTE *    typeData;
                const BYTE *    pointData = dataBuffer + sizeof(MetaPathData);

                if ((points != NULL) && (types != NULL))
                {
                    if ((pathData->Flags & GDIP_EPRFLAGS_COMPRESSED) != 0)
                    {
                        BYTE *  tmp = NULL;

                        ::GetPointsForPlayback(
                                pointData,
                                size - (sizeof(MetaPathData) + count),
                                count,
                                pathData->Flags,
                                sizeof(GpPointF) * count,
                                (BYTE *)points,
                                tmp);
                        typeData = pointData + (count * 4);
                    }
                    else
                    {
                        GpMemcpy(points, pointData, count * sizeof(points[0]));
                        typeData = pointData + (count * sizeof(points[0]));
                    }
                    GpMemcpy(types, typeData, count);

                    if (ValidatePathTypes(types, count, &SubpathCount, &HasBezier))
                    {
                        UpdateUid();
                        return Ok;
                    }
                }
            }
            else
            {
                WARNING(("size is too small"));
            }
        }
    }
    else
    {
        WARNING(("size is too small"));
    }

    SetValid(FALSE);
    return GenericError;
}

/**************************************************************************\
*
* Function Description:
*
*   Construct a new GpPath object using the specified path data
*
* Arguments:
*
*   [IN] points - Point to an array of path points
*   [IN] types - Specify path point types
*   count - Number of path points
*   fillMode - Path fill mode
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

GpPath::GpPath(
    const GpPointF* points,
    const BYTE* types,
    INT count,
    GpFillMode fillMode
    )
{
    SetValid(FALSE);

    // Validate function parameters

    if (count <= 0 ||
        (count > 0 && (!points || !types)) ||
        (fillMode != FillModeAlternate && fillMode != FillModeWinding))
    {
        WARNING(("Invalid path data in GpPath::GpPath"));
        return;
    }

    InitDefaultState(fillMode);

    // Validate path point types

    if (!ValidatePathTypes(types, count, &SubpathCount, &HasBezier))
    {
        WARNING(("Invalid path type information"));
        return;
    }

    // Copy path point and type information

    SetValid(Types.AddMultiple(types, count) == Ok &&
             Points.AddMultiple(points, count) == Ok);

    if(IsValid()) {
        // Make sure the first point is the start type.

        Types.First() = PathPointTypeStart;
    }
}


//--------------------------------
// Constructor for polygon.
//--------------------------------

GpPath::GpPath(
    const GpPointF *points,
    INT count,
    GpPointF *stackPoints,
    BYTE *stackTypes,
    INT stackCount,
    GpFillMode fillMode,
    DpPathFlags flags
    ) : DpPath(points, count, stackPoints, stackTypes, stackCount,
            fillMode, flags)
{
    InvalidateCache();
}

//--------------------------------
// Copy constructor.
//--------------------------------

GpPath::GpPath(const GpPath* path) : DpPath(path)
{
    SetValid(path != NULL);

    InvalidateCache();
}


/**************************************************************************\
*
* Function Description:
*
*   Copies the path data.  Points and Types array in pathData
*   must be allocated by the caller.
*
* Arguments:
*
*   [OUT] pathData - the path data.
*
* Return Value:
*
*   TRUE if successfull.
*
\**************************************************************************/

GpStatus
DpPath::GetPathData(GpPathData* pathData)
{
    if ((!pathData) || (!pathData->Points) || (!pathData->Types) || (pathData->Count < 0))
        return InvalidParameter;

    INT count = GetPointCount();
    const GpPointF* points = GetPathPoints();
    const BYTE* types = GetPathTypes();

    if (pathData->Count >= count)
    {
        if (count > 0)
        {
            GpMemcpy(pathData->Points, points, count*sizeof(GpPointF));
            GpMemcpy(pathData->Types, types, count);
        }

        pathData->Count = count;
        return Ok;
    }
    else
        return OutOfMemory;
}

/**************************************************************************\
*
* Function Description:
*
*   Set a marker at the current location.  You cannot set a marker at the
*   first position.
*
* Arguments:
*
*   None
*
* Return Value:
*
*   Status
*
\**************************************************************************/

GpStatus
GpPath::SetMarker()
{
    INT count = Types.GetCount();
    BYTE* types = Types.GetDataBuffer();

    // Don't set a marker at the first point.

    if(count > 1 && types)
    {
        types[count - 1] |= PathPointTypePathMarker;
        UpdateUid();
    }

    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   Clears all the markers in the path.
*
* Arguments:
*
*   None
*
* Return Value:
*
*   Status
*
\**************************************************************************/

GpStatus
GpPath::ClearMarkers()
{
    INT count = Types.GetCount();
    BYTE* types = Types.GetDataBuffer();

    BOOL modified = FALSE;

    if(count > 0 && types)
    {
        for(INT i = 0; i < count; i++)
        {
            if(types[i] & PathPointTypePathMarker)
            {
                types[i] &= ~PathPointTypePathMarker;
                modified = TRUE;
            }
        }
    }

    if(modified)
    {
        UpdateUid();
    }

    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   Set the path data.
*
* Arguments:
*
*   [IN] pathData - the path data.
*
* Return Value:
*
*   TRUE if successfull.
*
\**************************************************************************/

GpStatus
DpPath::SetPathData(const GpPathData* pathData)
{
    if(!pathData || pathData->Count <= 0)
        return InvalidParameter;

    INT count = pathData->Count;
    DpPathIterator iter(pathData->Points, pathData->Types, count);

    if(!iter.IsValid())
        return InvalidParameter;

    Points.Reset(FALSE);
    Types.Reset(FALSE);

    GpPointF* points = Points.AddMultiple(count);
    BYTE* types = Types.AddMultiple(count);

    if(points && types)
    {
        INT number, startIndex, endIndex;
        BOOL isClosed = FALSE;

        while(number = iter.NextSubpath(&startIndex, &endIndex, &isClosed))
        {
            GpMemcpy(
                points,
                pathData->Points + startIndex,
                number*sizeof(GpPointF)
                );
            GpMemcpy(
                types,
                pathData->Types + startIndex,
                number
                );

            points += number;
            types += number;
       }

        SetValid(TRUE);
        HasBezier = iter.HasCurve();
        Flags = PossiblyNonConvex;
        SubpathCount = iter.GetSubpathCount();
        IsSubpathActive = !isClosed;
        UpdateUid();
        return Ok;
    }
    else
        return OutOfMemory;
}

// Determine if the specified points form a rectangle that is axis aligned.
// Do the test in the coordinate space specified by the matrix (if present).
// Covert the REAL values to FIX4 values so that the test is compatible
// with what the rasterizer would do.
// If transformedBounds is not NULL, return the rect (if it is a rect)
// in the transformed (device) space.
BOOL 
IsRectanglePoints(
    const GpPointF* points,
    INT count,
    const GpMatrix * matrix,
    GpRectF * transformedBounds
    )
{
    if(count < 4 || count > 5)
        return FALSE;

    GpPointF    transformedPoints[5];
    
    if ((matrix != NULL) && (!matrix->IsIdentity()))
    {
        matrix->Transform(points, transformedPoints, count);
        points = transformedPoints;
    }
    
    PointFix4   fix4Points[5];
    
    fix4Points[0].Set(points[0].X, points[0].Y);

    if(count == 5)
    {
        fix4Points[4].Set(points[4].X, points[4].Y);

        if(fix4Points[0].X != fix4Points[4].X || fix4Points[0].Y != fix4Points[4].Y)
            return FALSE;
    }

    fix4Points[1].Set(points[1].X, points[1].Y);
    fix4Points[2].Set(points[2].X, points[2].Y);
    fix4Points[3].Set(points[3].X, points[3].Y);

    REAL    maxValue;

    if (fix4Points[0].Y == fix4Points[1].Y)
    {
        if ((fix4Points[2].Y == fix4Points[3].Y) &&
            (fix4Points[0].X == fix4Points[3].X) &&
            (fix4Points[1].X == fix4Points[2].X))
        {
            if (transformedBounds != NULL)
            {
                transformedBounds->X = min(points[0].X, points[1].X);
                maxValue = max(points[0].X, points[1].X);
                transformedBounds->Width = maxValue - transformedBounds->X;

                transformedBounds->Y = min(points[0].Y, points[2].Y);
                maxValue = max(points[0].Y, points[2].Y);
                transformedBounds->Height = maxValue - transformedBounds->Y;
            }
            return TRUE;
        }
    }
    else if ((fix4Points[0].X == fix4Points[1].X) &&
             (fix4Points[2].X == fix4Points[3].X) &&
             (fix4Points[0].Y == fix4Points[3].Y) &&
             (fix4Points[1].Y == fix4Points[2].Y))
    {
        if (transformedBounds != NULL)
        {
            transformedBounds->X = min(points[0].X, points[2].X);
            maxValue = max(points[0].X, points[2].X);
            transformedBounds->Width = maxValue - transformedBounds->X;

            transformedBounds->Y = min(points[0].Y, points[1].Y);
            maxValue = max(points[0].Y, points[1].Y);
            transformedBounds->Height = maxValue - transformedBounds->Y;
        }
        return TRUE;
    }
    return FALSE;
}

BOOL
GpPath::IsRectangle(
    const GpMatrix * matrix,
    GpRectF * transformedBounds
    ) const
{
    if((SubpathCount != 1) || HasBezier)
        return FALSE;

    INT count = GetPointCount();
    GpPointF* points = Points.GetDataBuffer();

    return IsRectanglePoints(points, count, matrix, transformedBounds);
}

BOOL
DpPath::IsRectangle(
    const GpMatrix * matrix,
    GpRectF * transformedBounds
    ) const
{
    if ((GetSubpathCount() != 1) || HasCurve())
        return FALSE;

    INT count = GetPointCount();
    GpPointF* points = Points.GetDataBuffer();

    return IsRectanglePoints(points, count, matrix, transformedBounds);
}

/**************************************************************************\
*
* Function Description:
*
*   Determine if the receiver and path represent the same path
*
* Arguments:
*
*   [IN] path - GpPath to compare
*
* Return Value:
*
*   TRUE if the paths are the same.
*
* Created - 5/27/99 peterost
*
\**************************************************************************/

BOOL GpPath::IsEqual(const GpPath* path) const
{
    if (path == this)
        return TRUE;

    INT    count;

    if (IsValid() == path->IsValid() &&
        (count=GetPointCount()) == path->GetPointCount() &&
        HasBezier == path->HasBezier &&
        FillMode == path->FillMode &&
        Flags == path->Flags &&
        IsSubpathActive == path->IsSubpathActive &&
        SubpathCount == path->SubpathCount)
    {
        BYTE*     types = path->Types.GetDataBuffer();
        BYTE*     mytypes = Types.GetDataBuffer();
        GpPointF* points = path->Points.GetDataBuffer();
        GpPointF* mypoints = Points.GetDataBuffer();

        for (INT i=0; i<count; i++)
        {
            if (types[i] != mytypes[i] ||
                points[i].X != mypoints[i].X ||
                points[i].Y != mypoints[i].Y)
            {
                return FALSE;
            }
        }
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

VOID
GpPath::InitDefaultState(
    GpFillMode fillMode
    )

{
    DpPath::InitDefaultState(fillMode);
    InvalidateCache();
}


/**************************************************************************\
*
* Function Description:
*
*   Validate path point type information
*
* Arguments:
*
*   [IN] types - Point to an array of path point types
*   count - Number of points
*   subpathCount - Return the number of subpaths
*   hasBezier - Return whether the path has Bezier segments
*   [IN] needsFirstPointToBeStartPoint - TRUE if this data needs to start
*                                       with a StartPoint. (Default is TRUE)
*
* Return Value:
*
*   TRUE if the path point type information is valid
*   FALSE otherwise
*
\**************************************************************************/

BOOL
DpPath::ValidatePathTypes(
    const BYTE* types,
    INT count,
    INT* subpathCount,
    BOOL* hasBezier
    )
{
    DpPathTypeIterator iter(types, count);

    if(!iter.IsValid())
    {
        WARNING(("Invalid path type information"));
        return FALSE;
    }

    *subpathCount = iter.GetSubpathCount();
    *hasBezier = iter.HasCurve();

    return iter.IsValid();
}

/**************************************************************************\
*
* Function Description:
*
*   Private helper function to add points to a path object
*
* Arguments:
*
*   [IN] points - Specify the points to be added
*   count - Number of points to add
*
* Return Value:
*
*   Point to location in the point type data buffer
*   that corresponds to the *SECOND* path point added.
*
*   The first point type is always handled inside this
*   function:
*
*   1. If either the previous subpath is closed, or addClosedFigure
*      parameter is TRUE, the first point type will be StartPoint.
*
*   2. Otherwise, the previous subpath is open and addClosedFigure
*      parameter is FALSE. We have two separate cases to handle:
*
*      2.1 if the first point to be added is the same as the last
*          point of the open subpath, then the first point is ignored.
*
*      2.2 otherwise, the first point type will be LinePoint.
*
*   NULL if there is an error. In this case, existing path
*   data is not affected.
*
* Note:
*
*   We assume the caller has already obtained a lock
*   on the path object.
*
\**************************************************************************/

BYTE*
GpPath::AddPointHelper(
    const GpPointF* points,
    INT count,
    BOOL addClosedFigure
    )
{
    // If we're adding a closed figure, then make sure
    // there is no more currently active subpath.

    if (addClosedFigure)
        StartFigure();

    INT origCount = GetPointCount();

    BOOL isDifferentPoint = TRUE;

    // Check if the first point is the same as the last point.

    if(IsSubpathActive && origCount > 0)
    {
        GpPointF lastPt = Points.Last();
        if ((REALABS(points->X - lastPt.X) < REAL_EPSILON) &&
            (REALABS(points->Y - lastPt.Y) < REAL_EPSILON) )
        {
            if(count == 1)
                return NULL;

            // case 2.1 above
            // Skip the first point and its type.

            count--;
            points++;
            isDifferentPoint = FALSE;
        }
    }

    // Resize Points and Types

    GpPointF* pointbuf = Points.AddMultiple(count);
    BYTE* typebuf = Types.AddMultiple(count);

    if(pointbuf == NULL || typebuf == NULL)
    {
        // Resize the original size.

        Points.SetCount(origCount);
        Types.SetCount(origCount);

        return NULL;
    }

    // Record the type of the first point (Start or Line Point).

    if (!IsSubpathActive)
    {
        // case 1 above

        *typebuf++ = PathPointTypeStart;
        SubpathCount++; // Starting a new subpath.
    }
    else
    {
        // If the first point is different, add a Line type.
        // Otherwise, skip the first point and its type.

        if(isDifferentPoint)
        {
            // case 2.2 above

            *typebuf++ = PathPointTypeLine;
        }
    }

    // Copy path point data

    GpMemcpy(pointbuf, points, count*sizeof(GpPointF));

    // Subpath is active if the added figure is not closed.

    if(!addClosedFigure)
        IsSubpathActive = TRUE;

    UpdateUid();
    InvalidateCache();

    // Return the starting location for the new point type data
    // From the second point type.

    return typebuf;
}


/**************************************************************************\
*
* Function Description:
*
*   Add a series of line segments to the current path object
*
* Arguments:
*
*   [IN] points - Specify the line points
*   count - Number of points
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

GpStatus
GpPath::AddLines(
    const GpPointF* points,
    INT count
    )
{
    ASSERT(IsValid());

    // Validate function parameters

    if (points == NULL || count < 1)
        return InvalidParameter;

    InvalidateCache();

    // Call the internal helper function to add the points

    BYTE* types = AddPointHelper(points, count, FALSE);

    if (types == NULL)
    {
        if(count > 1)
            return OutOfMemory;
        else
            return Ok;
    }

    // Set path point type information

    GpMemset(types, PathPointTypeLine, count-1);
//    IsSubpathActive = TRUE;   This is set in AddPointHelper. - ikkof
    UpdateUid();

    return Ok;
}


/**************************************************************************\
*
* Function Description:
*
*   Add rectangles to the current path object
*
* Arguments:
*
*   [IN] rects - Specify the rectangles to be added
*   count - Number of rectangles
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

GpStatus
GpPath::AddRects(
    const GpRectF* rect,
    INT count
    )
{
    if (count < 1 || rect == NULL)
        return InvalidParameter;

    // NOTE: We don't need a lock here because
    //  AddPolygon will handle it.

    // Add one rectangle at a time as a polygon

    GpPointF points[4];
    GpStatus status;

    for ( ; count--; rect++)
    {
        if (rect->IsEmptyArea())
            continue;

        // NOTE: Rectangle points are added in clockwise
        // order, starting from the top-left corner.

        points[0].X = rect->GetLeft();      // top-left
        points[0].Y = rect->GetTop();
        points[1].X = rect->GetRight();     // top-right
        points[1].Y = rect->GetTop();
        points[2].X = rect->GetRight();     // bottom-right
        points[2].Y = rect->GetBottom();
        points[3].X = rect->GetLeft();      // bottom-left
        points[3].Y = rect->GetBottom();

        if ((status = AddPolygon(points, 4)) != Ok)
            return status;
    }

    return Ok;
}

GpStatus
GpPath::AddRects(
    const RECT*     rects,
    INT             count
    )
{
    if ((count < 1) || (rects == NULL))
    {
        return InvalidParameter;
    }

    // NOTE: We don't need a lock here because
    //  AddPolygon will handle it.

    // Add one rectangle at a time as a polygon

    GpPointF points[4];
    GpStatus status;

    for ( ; count--; rects++)
    {
        if ((rects->left >= rects->right) || (rects->top >= rects->bottom))
        {
            continue;
        }

        // NOTE: Rectangle points are added in clockwise
        // order, starting from the top-left corner.

        points[0].X = (REAL)rects->left;        // top-left
        points[0].Y = (REAL)rects->top;
        points[1].X = (REAL)rects->right;       // top-right
        points[1].Y = (REAL)rects->top;
        points[2].X = (REAL)rects->right;       // bottom-right
        points[2].Y = (REAL)rects->bottom;
        points[3].X = (REAL)rects->left;        // bottom-left
        points[3].Y = (REAL)rects->bottom;

        if ((status = AddPolygon(points, 4)) != Ok)
        {
            return status;
        }
    }

    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   Add a polygon to the current path object
*
* Arguments:
*
*   [IN] Specify the polygon points
*   count - Number of points
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

GpStatus
GpPath::AddPolygon(
    const GpPointF* points,
    INT count
    )
{
    ASSERT(IsValid());

    if (count < 3 || points == NULL)
    {
        return InvalidParameter;
    }

    // Check if the last point is the same as the first point.
    // If so, ignore it.

    if (count > 3 &&
        points[0].X == points[count-1].X &&
        points[0].Y == points[count-1].Y)
    {
        count--;
    }

    // Call the internal helper function to add the points

    BYTE* types = AddPointHelper(points, count, TRUE);

    InvalidateCache();
    
    if (types == NULL)
    {
        return OutOfMemory;
    }

    // Set path point type information

    GpMemset(types, PathPointTypeLine, count-2);
    types[count-2] = PathPointTypeLine | PathPointTypeCloseSubpath;

    UpdateUid();

    return Ok;
}


#define PI          TOREAL(3.1415926535897932)
#define HALF_PI     TOREAL(1.5707963267948966)


/**************************************************************************\
*
* Function Description:
*
*   Convert an angle defined in a box with (width, height) to
*   an angle defined in a square box.
*   In other words, this shrink x- and y-coordinates by width and height,
*   and then calculates the new angle.
*
* Arguments:
*
*   [IN/OUT] angle - the angle is given in degrees and return it in radian.
*   [IN] width  - the width of the box.
*   [IN] height - the height of the box.
*
* Return Value:
*
*   NONE
*
* History:
*
*   02/22/1999 ikkof
*       Created it.
*
\**************************************************************************/

VOID
NormalizeAngle(REAL* angle, REAL width, REAL height)
{
    REAL a = *angle;

    // Set the angle between 0 and 360 degrees.

    a = GpModF(a, 360);

    if(a < 0 || a > 360)
    {
        // The input data may have been too large or loo small
        // to calculate the mode.  In that case, set to 0.

        a = 0;
    }

    if(width != height)
    {
        INT plane = 1;
        REAL b = a;

        if(a <= 90)
            plane = 1;
        else if(a <= 180)
        {
            plane = 2;
            b = 180 - a;
        }
        else if(a <= 270)
        {
            plane = 3;
            b = a - 180;
        }
        else
        {
            plane = 4;
            b = 360 - a;
        }

        b = b*PI/180;   // Convert to radian

        // Get the normalized angle in the plane 1.

        a = TOREAL( atan2(width*sin(b), height*cos(b)) );

        // Adjust to the angle in one of 4 planes.

        switch(plane)
        {
            case 1:
            default:
                break;

            case 2:
                a = PI - a;
                break;

            case 3:
                a = PI + a;
                break;

            case 4:
                a = 2*PI - a;
                break;
        }
    }
    else
    {
        a = a*PI/180;   // Convert to radian.
    }

    *angle = a;
}


/**************************************************************************\
*
* Function Description:
*
*   Convert the start and sweep angles defined in a box with (width, height)
*   to an angle defined in a square box.
*   In other words, this shrink x- and y-coordinates by width and height,
*   and then calculates the new angles.
*
* Arguments:
*
*   [IN/OUT] startAngle - it is given in degrees and return it in radian.
*   [IN/OUT] sweepAngle - it is given in degrees and return it in radian.
*   [IN] width  - the width of the box.
*   [IN] height - the height of the box.
*
* Return Value:
*
*   INT - +1 if sweeping in clockwise and -1 in counterclockwise.
*
* History:
*
*   02/22/1999 ikkof
*       Created it.
*
\**************************************************************************/

INT
NormalizeArcAngles(
    REAL* startAngle,
    REAL* sweepAngle,
    REAL width,
    REAL height
    )
{
    REAL a0 = *startAngle;  // The start angle.
    REAL dA = *sweepAngle;
    REAL a1 = a0 + dA;      // The end angle.
    INT sweepSign;

    if(dA > 0)
        sweepSign = 1;
    else
    {
        sweepSign = - 1;
        dA = - dA;  // Convert to a positive sweep angle.
    }

    // Normalize the start and end angle.

    NormalizeAngle(&a0, width, height);
    NormalizeAngle(&a1, width, height);

    if(dA < 360)
    {
        if(sweepSign > 0)
        {
            dA = a1 - a0;
        }
        else
        {
            dA = a0 - a1;
        }
        if(dA < 0)
            dA += 2*PI;
    }
    else
        dA = 2*PI;  // Don't sweep more than once.

    *startAngle = a0;
    *sweepAngle = dA;

    return sweepSign;
}


/**************************************************************************\
*
* Function Description:
*
*   Convert an elliptical arc to a series of Bezier curve segments
*
* Arguments:
*
*   points - Specify a point buffer for returning Bezier control points
*       The array should be able to hold 13 elements or more.
*   rect - Specify the bounding box for the ellipse
*   startAngle - Start angle (in elliptical space and degrees)
*   sweepAngle - Sweep angle
*       positive to sweep clockwise
*       negative to sweep counterclockwise
*
* Return Value:
*
*   Number of Bezier control points generated
*   0 if sweep angle is 0
*   -1 if bounding rectangle is empty
*
\**************************************************************************/

INT
GpPath::GetArcPoints(
    GpPointF* points,
    const GpRectF& rect,
    REAL startAngle,
    REAL sweepAngle
    )
{
    if (rect.IsEmptyArea())
        return -1;
    else if (sweepAngle == 0)
        return 0;

    // Determine which direction we should sweep
    // and clamp sweep angle to a max of 360 degrees
    // Both start and sweep angles are conveted to radian.

    INT sweepSign = NormalizeArcAngles(
        &startAngle,
        &sweepAngle,
        rect.Width,
        rect.Height);

    // Temporary variables

    REAL dx, dy;
    REAL w2, h2;

    w2 = rect.Width / 2;
    h2 = rect.Height / 2;
    dx = rect.X + w2;
    dy = rect.Y + h2;

    // Determine the number of Bezier segments needed

    int segments, count;
    GpMatrix m;

    segments = (INT) (sweepAngle / HALF_PI);

    if (segments*HALF_PI < sweepAngle)
        segments++;

    if (segments == 0)
        segments = 1;
    else if (segments > 4)
        segments = 4;

    count = segments*3 + 1;

    while (segments--)
    {
        // Compute the Bezier control points in unit-circle space

        REAL A, C, S;
        REAL x, y;

        A = (sweepAngle > HALF_PI) ? HALF_PI/2 : sweepAngle/2;
        C = REALCOS(A);
        S = REALSIN(A);

        x = (4 - C) / 3;
        y = (3 - C) * S / (3 + 3*C);

        if (sweepSign > 0)
        {
            // clockwise sweep

            points[0].X = C;
            points[0].Y = -S;
            points[1].X = x;
            points[1].Y = -y;
            points[2].X = x;
            points[2].Y = y;
            points[3].X = C;
            points[3].Y = S;
        }
        else
        {
            // counterclockwise sweep

            points[0].X = C;
            points[0].Y = S;
            points[1].X = x;
            points[1].Y = y;
            points[2].X = x;
            points[2].Y = -y;
            points[3].X = C;
            points[3].Y = -S;
        }

        // Transform the control points to elliptical space

        m.Reset();
        m.Translate(dx, dy);
        m.Scale(w2, h2);
        REAL theta = (startAngle + sweepSign*A)*180/PI;
        m.Rotate(theta);    // Rotate takes degrees.

        if(segments > 0)
            m.Transform(points, 3);
        else
            m.Transform(points, 4); // Include the last point.

        if(sweepSign > 0)
            startAngle += HALF_PI;
        else
            startAngle -= HALF_PI;
        sweepAngle -= HALF_PI;
        points += 3;
    }

    return count;
}


/**************************************************************************\
*
* Function Description:
*
*   Add an elliptical arc to the current path object
*
* Arguments:
*
*   rect - Specify the bounding rectangle for the ellipse
*   startAngle - Starting angle for the arc
*   sweepAngle - Sweep angle for the arc
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

GpStatus
GpPath::AddArc(
    const GpRectF& rect,
    REAL startAngle,
    REAL sweepAngle
    )
{
    GpPointF points[13];
    INT count;
    BOOL isClosed = FALSE;

    if(sweepAngle >= 360)
    {
        sweepAngle = 360;
        isClosed = TRUE;
    }
    else if(sweepAngle <= - 360)
    {
        sweepAngle = - 360;
        isClosed = TRUE;
    }

    // Convert arc to Bezier curve segments

    count = GetArcPoints(points, rect, startAngle, sweepAngle);

    // Add resulting Bezier curve segment to the path

    GpStatus status = Ok;

    if(count > 0)
    {
        AddBeziers(points, count);
        if(isClosed)
            CloseFigure();
    }
    else if(count < 0)
        status = InvalidParameter;

    InvalidateCache();

    return status;
}


/**************************************************************************\
*
* Function Description:
*
*   Add an ellipse to the current path object
*
* Arguments:
*
*   rect - Bounding rectangle for the ellipse
*
* Return Value:
*
*   Status code
*
* History:
*
*   02/22/1999 ikkof
*       Defined an array of a circle with radius 1 and used it.
*
\**************************************************************************/

GpStatus
GpPath::AddEllipse(
    const GpRectF& rect
    )
{
    GpPointF points[13];
    INT count = 13;
    REAL u_cir = 4*(REALSQRT(2.0) - 1)/3;
    GpPointF center;
    REAL    wHalf, hHalf;

    wHalf = rect.Width/2;
    hHalf = rect.Height/2;
    center.X = rect.X + wHalf;
    center.Y = rect.Y + hHalf;

    // 4 Bezier segment of a circle with radius 1.

    points[ 0].X = 1;       points[ 0].Y = 0;
    points[ 1].X = 1;       points[ 1].Y = u_cir;
    points[ 2].X = u_cir;   points[ 2].Y = 1;
    points[ 3].X = 0;       points[ 3].Y = 1;
    points[ 4].X = -u_cir;  points[ 4].Y = 1;
    points[ 5].X = -1;      points[ 5].Y = u_cir;
    points[ 6].X = -1;      points[ 6].Y = 0;
    points[ 7].X = -1;      points[ 7].Y = -u_cir;
    points[ 8].X = -u_cir;  points[ 8].Y = -1;
    points[ 9].X = 0;       points[ 9].Y = -1;
    points[10].X = u_cir;   points[10].Y = -1;
    points[11].X = 1;       points[11].Y = -u_cir;
    points[12].X = 1;       points[12].Y = 0;

    // Scale to the appropriate size.

    for(INT i = 0; i < count; i++)
    {
        points[i].X = points[i].X*wHalf + center.X;
        points[i].Y = points[i].Y*hHalf + center.Y;
    }

    // Add resulting Bezier curve segments to the path

    GpStatus status;

    StartFigure();
    status = AddBeziers(points, count);
    CloseFigure();

    InvalidateCache();
    UpdateUid();

    return status;
}


/**************************************************************************\
*
* Function Description:
*
*   Add an elliptical pie to the current path object
*
* Arguments:
*
*   rect - Bounding rectangle for the ellipse
*   startAngle - Specify the starting angle for the pie
*   sweepAngle - Sweep angle for the pie
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

GpStatus
GpPath::AddPie(
    const GpRectF& rect,
    REAL startAngle,
    REAL sweepAngle
    )
{
    GpPointF pt;

    StartFigure();

    // Add the center point.

    pt.X = rect.X + rect.Width/2;
    pt.Y = rect.Y + rect.Height/2;
    GpStatus status = AddLines(&pt, 1);

    // Add the arc points.

    if(status == Ok)
        status = AddArc(rect, startAngle, sweepAngle);

    CloseFigure();

    InvalidateCache();
    UpdateUid();

    return status;
}


/**************************************************************************\
*
* Function Description:
*
*   Add Bezier curve segments to the current path object
*
* Arguments:
*
*   [IN] points - Specify Bezier control points
*   count - Number of points
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

GpStatus
GpPath::AddBeziers(
    const GpPointF* points,
    INT count
    )
{
    // Number of points must be 3 * N + 1
    if ((!points) || (count < 4) || (count % 3 != 1))
    {
    	return InvalidParameter;
    }

    // Check if the first point is the same as the last point.
    INT firstType;
    INT origCount = GetPointCount();

    if(!IsSubpathActive)
    {
        SubpathCount++; // Starting a new subpath.
        firstType = PathPointTypeStart;
    }
    else
    {
        if (origCount > 0)
        {
            GpPointF lastPt = Points.Last();
            if ((REALABS(points[0].X - lastPt.X) < REAL_EPSILON) &&
                (REALABS(points[0].Y - lastPt.Y) < REAL_EPSILON))
            {
                firstType = -1; // Indicating no copying of the first point.
                points++;
                count--;
            }
            else
            {
                firstType = PathPointTypeLine;
            }
        }
        else
        {
            SubpathCount++;
            firstType = PathPointTypeStart;
        }
    }

    // Resize Points and Types
    GpPointF* pointBuf = Points.AddMultiple(count);
    BYTE* typeBuf = Types.AddMultiple(count);

    if(pointBuf == NULL || typeBuf == NULL)
    {
        // Resize the original size.

        Points.SetCount(origCount);
        Types.SetCount(origCount);

        return OutOfMemory;
    }

    GpMemcpy(pointBuf, points, count * sizeof(GpPointF));
    GpMemset(typeBuf, PathPointTypeBezier, count);
    
    if(firstType == PathPointTypeStart)
        typeBuf[0] = PathPointTypeStart;
    else if(firstType == PathPointTypeLine)
        typeBuf[0] = PathPointTypeLine;

    IsSubpathActive = TRUE;
    HasBezier = TRUE;

    InvalidateCache();
    UpdateUid();

    return Ok;
}

GpStatus
GpPath::AddBezier(
    const GpPointF& pt1,
    const GpPointF& pt2,
    const GpPointF& pt3,
    const GpPointF& pt4
    )
{
    GpPointF points[4];

    points[0] = pt1;
    points[1] = pt2;
    points[2] = pt3;
    points[3] = pt4;

    return AddBeziers(points, 4);
}

GpStatus
GpPath::AddBezier(
    REAL x1, REAL y1,
    REAL x2, REAL y2,
    REAL x3, REAL y3,
    REAL x4, REAL y4
    )
{
    GpPointF points[4];

    points[0].X = x1;
    points[0].Y = y1;
    points[1].X = x2;
    points[1].Y = y2;
    points[2].X = x3;
    points[2].Y = y3;
    points[3].X = x4;
    points[3].Y = y4;

    return AddBeziers(points, 4);
}


/**************************************************************************\
*
* Function Description:
*
*   Add a path to the current path object.
*   When connect is TRUE, this combine the end point of the current
*   path and the start point of the given path if both paths are
*   open.
*   If either path is closed, the two paths will not be connected
*   even if connect is set to TRUE.
*
* Arguments:
*
*   [IN] points - Specify a subpath points
*   [IN] types - Specify a subpath control types.
*   [IN] count - Number of points
*   [IN] connect - TRUE if two open paths needs to be connected.
*
* Return Value:
*
*   Status code
*
*   02/09/2000 ikkof
*       Created it.
*
\**************************************************************************/

GpStatus
GpPath::AddPath(
    const GpPointF* points,
    const BYTE* types,
    INT count,
    BOOL connect
    )
{
    GpStatus status = Ok;
    
    if(points == NULL || types == NULL || count <= 0)
    {
        return InvalidParameter;
    }

    INT count1 = GetPointCount();
    INT count2 = count;
    const GpPointF* points2 = points;
    const BYTE* types2 = types;

    INT totalCount = count1 + count2;
    BOOL forward1 = TRUE, forward2 = TRUE;

    status = Points.ReserveSpace(count2);
    
    if(status != Ok)
    {
        return status;
    }
    
    status = Types.ReserveSpace(count2);
    
    if(status != Ok)
    {
        return status;
    }
    
    GpPointF* outPoints = Points.GetDataBuffer();
    BYTE* outTypes = Types.GetDataBuffer();
    const GpPointF* points1 = outPoints;
    const BYTE* types1 = outTypes;

    totalCount = CombinePaths(
        totalCount, 
        outPoints,
        outTypes,
        count1, 
        points1, 
        types1, 
        forward1,
        count2, 
        points2, 
        types2, 
        forward2,
        connect
    );

    if( (totalCount >= count1) &&
        ValidatePathTypes(outTypes, totalCount, &SubpathCount, &HasBezier))
    {
        count2 = totalCount - count1;
        Points.AdjustCount(count2);
        Types.AdjustCount(count2);
        
        // Turn on the active subpath so that we can connect lines to this
        // path.
        // In order to not connect, call CloseFigure after adding.
        
        IsSubpathActive = !IsClosedType(Types[Types.GetCount()-1]);
        
        InvalidateCache();
        UpdateUid();

        return Ok;
    }
    else
    {
        return InvalidParameter;
    }
}

GpStatus
GpPath::AddPath(const GpPath* path, BOOL connect)
{
    if(!path)
    {
        return InvalidParameter;
    }

    INT count2 = path->GetPointCount();
    const GpPointF* points2 = path->GetPathPoints();
    const BYTE* types2 = path->GetPathTypes();

    return AddPath(points2, types2, count2, connect);
}

/**************************************************************************\
*
* Function Description:
*
* Reverse the direction of the path.
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   Status code
*
*   02/09/2000 ikkof
*       Created it.
*
\**************************************************************************/

GpStatus
GpPath::Reverse()
{
    if(!IsValid())
        return InvalidParameter;

    INT count = GetPointCount();
    GpPointF* points = Points.GetDataBuffer();
    BYTE* types = Types.GetDataBuffer();

    GpStatus status = Ok;

    if(count > 1)
        status = ::ReversePath(count, points, types);
    UpdateUid();

    return status;
}

GpStatus
GpPath::GetLastPoint(GpPointF* lastPoint)
{
    INT count = GetPointCount();
    if(count <= 0 || lastPoint == NULL)
        return InvalidParameter;

    GpPointF* points = Points.GetDataBuffer();

    // Return the last point.

    *lastPoint = points[count - 1];

    return Ok;
}

GpPath*
GpPath::GetOpenPath()
{
    BOOL openPath = TRUE;
    return GetOpenOrClosedPath(openPath);
}

GpPath*
GpPath::GetClosedPath()
{
    BOOL openPath = FALSE;
    return GetOpenOrClosedPath(openPath);
}

GpPath*
GpPath::GetOpenOrClosedPath(BOOL openPath)
{
    INT startIndex, endIndex;
    BOOL isClosed;
    const GpPointF* points = Points.GetDataBuffer();
    const BYTE* types = Types.GetDataBuffer();

    DpPathIterator iter(points, types, GetPointCount());

    GpPath* path = new GpPath(FillMode);

    if(path)
    {
        INT segmentCount = 0;
        while(iter.NextSubpath(&startIndex, &endIndex, &isClosed))
        {
            if(isClosed != openPath)
            {
//                path->AddSubpath(points + startIndex, types + startIndex,
//                        endIndex - startIndex + 1);

                BOOL connect = FALSE;
                path->AddPath(points + startIndex, types + startIndex,
                        endIndex - startIndex + 1, connect);
                segmentCount++;
            }
        }

        if(segmentCount == 0)
        {
            delete path;
            path = NULL;
        }
    }

    return path;
}


/**************************************************************************\
*
* Function Description:
*
*   Add an open cardinal spline curve to the current path object
*
* Arguments:
*
*   [IN] points - Specify the spline points
*   count - Number of points
*   tension - Tension parameter
*   offset - Index of the first point we're interested in
*   numberOfSegments - Number of curve segments
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

#define DEFAULT_TENSION 0.5

GpStatus
GpPath::AddCurve(
    const GpPointF* points,
    INT count,
    REAL tension,
    INT offset,
    INT numberOfSegments
    )
{
    // Verify input parameters

    if (points == NULL ||
        count < 2 ||
        offset < 0 ||
        offset >= count ||
        numberOfSegments < 1 ||
        numberOfSegments >= count-offset)
    {
        return InvalidParameter;
    }

    // Convert spline points to Bezier control points

    GpPointF* bezierPoints;
    INT bezierCount;

    bezierPoints = ConvertSplineToBezierPoints(
                        points,
                        count,
                        offset,
                        numberOfSegments,
                        tension,
                        &bezierCount);

    if (bezierPoints == NULL)
        return OutOfMemory;

    // Add the resulting Bezier segments to the current path

    GpStatus status;

    status = AddBeziers(bezierPoints, bezierCount);
    delete[] bezierPoints;

    return status;
}

GpStatus
GpPath::AddCurve(
    const GpPointF* points,
    INT count
    )
{
    return AddCurve(points,
                    count,
                    DEFAULT_TENSION,
                    0,
                    count-1);
}


/**************************************************************************\
*
* Function Description:
*
*   Add a closed cardinal spline curve to the current path object
*
* Arguments:
*
*   [IN] points - Specify the spline points
*   count - Number of points
*   tension - Tension parameter
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

GpStatus
GpPath::AddClosedCurve(
    const GpPointF* points,
    INT count,
    REAL tension
    )
{
    // Verify input parameters

    if (points == NULL || count <= 2)
        return InvalidParameter;

    // Convert spline points to Bezier control points

    GpPointF* bezierPoints;
    INT bezierCount;

    bezierPoints = ConvertSplineToBezierPoints(
                        points,
                        count,
                        0,
                        count,
                        tension,
                        &bezierCount);

    if (bezierPoints == NULL)
        return OutOfMemory;

    // Add the resulting Bezier segments as a closed curve

    GpStatus status;

    StartFigure();
    status = AddBeziers(bezierPoints, bezierCount);
    CloseFigure();

    delete[] bezierPoints;

    InvalidateCache();
    UpdateUid();

    return status;
}

GpStatus
GpPath::AddClosedCurve(
    const GpPointF* points,
    INT count
    )
{
    return AddClosedCurve(points, count, DEFAULT_TENSION);
}


/**************************************************************************\
*
* Function Description:
*
*   Convert cardinal spline curve points to Bezier curve control points
*
* Arguments:
*
*   [IN] points - Array of spline curve points
*   count - Number of points in the "points" array
*   offset - Specify the index of the first control point in
*       the "points" array that the curve should start from
*   numberOfSegments - Specify the number of curve segments to draw
*   tension - Specify the tension parameter
*   bezierCount - Return the number of Bezier control points
*
* Return Value:
*
*   Pointer to an array of Bezier control points
*   NULL if there is an error
*
* Reference:
*
*   Spline Tutorial Notes
*   Technical Memo No. 77
*   Alvy Ray Smith
*   Presented as tutorial notes at the 1983 SIGGRAPH, July 1983
*   and the SIGGRAPH, July 1984
*
* Notes:
*
*   Support for cardinal spline curves
*
*   Cardinal splines are local interpolating splines, i.e. they
*   pass through their control points and they maintain
*   first-order continuity at their control points.
*
*   a cardinal spline is specified by three parameters:
*       a set of control points P1, ..., Pn
*       tension parameter a
*       close flag
*
*   If n is 1, then the spline degenerates into a single point P1.
*   If n > 1 and the close flag is false, the spline consists of
*   n-1 cubic curve segments. The first curve segment starts from
*   P1 and ends at P2. The last segment starts at Pn-1 and ends at Pn.
*
*   The cubic curve segment from Pi to Pi+1 is determined by
*   4 control points:
*       Pi-1 = (xi-1, yi-1)
*       Pi = (xi, yi)
*       Pi+1 = (xi+1, yi+1)
*       Pi+2 = (xi+2, yi+2)
*
*   The parametric equation is defined as:
*
*       [ X(t) Y(t) ] = [t^3 t^2 t 1] * M * [ xi-1 yi-1 ]
*                                           [ xi   yi   ]
*                                           [ xi+1 yi+1 ]
*                                           [ xi+2 yi+2 ]
*
*   where t ranges from 0 to 1 and M is a 4x4 matrix satisfying
*   the following constraints:
*
*       X(0) = xi               interpolating through control points
*       X(1) = xi+1
*       X'(0) = a(xi+1 - xi-1)  first-order continuity
*       X'(1) = a(xi+2 - xi)
*
*   In the case of segments from P1 to P2 and from Pn-1 to Pn,
*   we replicate the first and last control points, i.e. we
*   define P0 = P1 and Pn+1 = Pn.
*
*   If the close flag is true, we have an additional curve segment
*   from Pn to Pn+1 = P1. For the segments near the beginning and
*   the end of the spline, we wrap around the control points, i.e.
*   P0 = Pn, Pn+1 = P1, and Pn+2 = P2.
*
\**************************************************************************/

GpPointF*
GpPath::ConvertSplineToBezierPoints(
    const GpPointF* points,
    INT count,
    INT offset,
    INT numberOfSegments,
    REAL tension,
    INT* bezierCount
    )
{
    BOOL closed;
    GpPointF* bezierPoints;

    ASSERT(count > 1 &&
           offset >= 0 &&
           offset < count &&
           numberOfSegments > 0 &&
           numberOfSegments <= count-offset);

    // Curve is closed if the number of segments is equal to
    // the number of curve points

    closed = (numberOfSegments == count);

    // Allocate memory to hold Bezier control points

    *bezierCount = numberOfSegments*3 + 1;
    bezierPoints = new GpPointF[*bezierCount];

    if (bezierPoints == NULL)
        return NULL;

    // Convert each spline segment to a Bezier segment
    // resulting in 3 additional Bezier points

    GpPointF buffer[4], *q;
    const GpPointF* p;
    REAL a3;

    a3 = tension / 3;
    q = bezierPoints;
    *q = points[offset];

    for (INT index=offset; index < offset+numberOfSegments; index++)
    {
        if (index > 1 && index < count-2)
            p = points + (index-1);
        else
        {
            // Points near the beginning and end of the curve
            // require special attention

            if (closed)
            {
                // If the curve is closed, make sure the control points
                // wrap around the beginning and end of the array.

                buffer[0] = points[(index-1+count) % count];
                buffer[1] = points[index];
                buffer[2] = points[(index+1) % count];
                buffer[3] = points[(index+2) % count];
            }
            else
            {
                // If the curve is not closed, replicate the first
                // and last point in the array.

                buffer[0] = points[(index > 0) ? (index-1) : 0];
                buffer[1] = points[index];
                buffer[2] = points[(index+1 < count) ? (index+1) : (count-1)];
                buffer[3] = points[(index+2 < count) ? (index+2) : (count-1)];
            }

            p = buffer;
        }

        q[1].X = -a3*p[0].X + p[1].X + a3*p[2].X;
        q[1].Y = -a3*p[0].Y + p[1].Y + a3*p[2].Y;
        q[2].X =  a3*p[1].X + p[2].X - a3*p[3].X;
        q[2].Y =  a3*p[1].Y + p[2].Y - a3*p[3].Y;
        q[3] = p[2];

        q += 3;
    }

    return bezierPoints;
}


/**************************************************************************\
*
* Function Description:
*
*   Transform all path points by the specified matrix
*
* Arguments:
*
*   matrix - Transform matrix
*
* Return Value:
*
*   NONE
*
* Created:
*
*   02/08/1999 ikkof
*       Created it.
*
\**************************************************************************/

VOID
GpPath::Transform(
    const GpMatrix *matrix
    )
{
    ASSERT(IsValid());

    if(matrix)
    {
        INT count = GetPointCount();
        GpPointF* points = Points.GetDataBuffer();

        matrix->Transform(points, count);
        UpdateUid();
        InvalidateCache();
    }
}

// Debug only.

#if DBG
void DpPath::DisplayPath() {
    INT size = GetPointCount();

    const GpPointF *points = GetPathPoints();
    const BYTE *types = GetPathTypes();

    for(int i=0; i<size; i++)
    {
        WARNING(("points[%d].X = %ff;", i, points[i].X));
        WARNING(("points[%d].Y = %ff;", i, points[i].Y));
        WARNING(("types[%d] = 0x%x;", i, types[i]));
    }
}
#endif



/**************************************************************************\
*
* Function Description:
*
*   Callback to accumulate the flattened edges that the Rasterizer emits.
*
* Arguments:
*
*    VOID *context,        // pointer to the resulting path.
*    POINT *pointArray,    // Points to a 28.4 array of size 'vertexCount'
*    INT vertexCount,      // number of points to add.
*    BOOL lastSubpath      // The last point in this array is the last point
*                          // in a closed subpath.
*
* Return Value:
*   BOOL
*
* History:
*
*  10/25/2000  asecchia & ericvan
*       Created it.
*
\**************************************************************************/

BOOL PathFlatteningCallback(
    VOID *context,
    POINT *pointArray,    // Points to a 28.4 array of size 'vertexCount'
                          //   Note that we may modify the contents!
    INT vertexCount,
    PathEnumerateTermination lastSubpath      // Last point in the subpath.
    )
{
    GpPath *result = static_cast<GpPath*>(context);
    GpPointF *pointcast = (GpPointF*)(pointArray);
    
    INT count = vertexCount;
    
    // Don't add the last point if it's closed because the rasterizer 
    // emitted it twice - once for the first point.
    
    if(lastSubpath == PathEnumerateCloseSubpath)
    {
        count--;
    }
    
    for(INT i = 0; i < count; i++)
    {
        // Convert the point array to real in place.
        
        pointcast[i].X = FIX4TOREAL(pointArray[i].x);
        pointcast[i].Y = FIX4TOREAL(pointArray[i].y);
    }
    
    // Add all the edges to the path as lines.
    
    GpStatus status = result->AddLines(pointcast, count);
    
    if(status == Ok)
    {
        if(lastSubpath == PathEnumerateCloseSubpath)
        {
            // last point in a subpath - close it.
            status = result->CloseFigure();
        }
        if(lastSubpath == PathEnumerateEndSubpath)
        {
            // last point in an open subpath.
            result->StartFigure();
        }
    }
    
    return (status == Ok);
}

/**************************************************************************\
*
* Function Description:
*
*   Flatten the path. The input matrix is the world to device transform.
*   Our rasterizer will flatten at about 2/3 of a device pixel. In order
*   to handle different flatness tolerances, we scale the path proportionally
*   and pretend that it is bigger when we give it to the rasterizer for 
*   flattening. It flattens at 2/3 of a device pixel in this mocked up 
*   device space and we undo the flatness scale effectively redefining what
*   size a device pixel is. This allows us to flatten to an arbitrary
*   flatness tolerance.
*
* Arguments:
*
*   [IN] matrix -   Specifies the transform
*                   When matrix is NULL, the identity matrix is used.
*   [IN] flatness - the flattening tolerance
*
* Return Value:
*
*   Status
*
* Created:
*
*   10/25/2000  asecchia & ericvan
*       Created it.
*
\**************************************************************************/

GpStatus
GpPath::Flatten(
    DynByteArray *flattenTypes,
    DynPointFArray *flattenPoints,
    const GpMatrix *matrix,
    const REAL flatness
    ) const
{
    // Enumerate the path.

    FIXEDPOINTPATHENUMERATEFUNCTION pathEnumerationFunction = PathFlatteningCallback;

    GpPath result;

    // Calculate the scale - multiply by 16 for the rasterizer's 28.4 fixed
    // point math. This 16x transform is implicitly reversed as we accumulate 
    // the points from the rasterizer in our callback function
    
    REAL deviceFlatness = flatness/FlatnessDefault;
    REAL flatnessInv = (16.0f)/deviceFlatness;
    
    GpMatrix transform;
    
    if(matrix)
    {
        transform = *matrix;
    }
    
    // apply the flatness transform so that we rasterize at an appropriately
    // scaled resolution. We undo this part of the transform (not the 16x) 
    // at the end of this function.
    
    transform.AppendScale(flatnessInv, flatnessInv);
    

    // Do it.
    
    if (!FixedPointPathEnumerate(
        this, 
        &transform, 
        NULL,
        PathEnumerateTypeFlatten,   // don't automatically close open subpaths.
        pathEnumerationFunction, 
        &result
    ))
    {
         return(OutOfMemory);
    }

    // undo the implicit flatness transform.
    
    transform.Reset();
    transform.Scale(deviceFlatness, deviceFlatness);
    result.Transform(&transform);

    // Copy the points over. We should be using a detach on the DynArrays
    // because we're throwing the temporary one away.

    flattenPoints->Reset(FALSE);
    flattenTypes->Reset(FALSE);
    flattenPoints->AddMultiple(result.GetPathPoints(), result.GetPointCount());
    flattenTypes->AddMultiple(result.GetPathTypes(), result.GetPointCount());
    
    return Ok;
}

GpStatus
GpPath::Flatten(
    const GpMatrix *matrix,
    const REAL flatness
    )
{
    GpStatus status = Ok;
    
    // Only flatten if it has beziers.
    
    if(HasBezier)
    {
        DynPointFArray flattenPoints;
        DynByteArray flattenTypes;
        
        status = Flatten(
            &flattenTypes,
            &flattenPoints,
            matrix,
            flatness
        );
        
        if(status==Ok)
        {
            // Copy the points over. We should be using a detach on the DynArrays
            // because we're throwing the temporary one away.
        
            Points.ReplaceWith(&flattenPoints);
            Types.ReplaceWith(&flattenTypes);
            
            // Update to reflect the changed state of the path.
            
            HasBezier = FALSE;
            InvalidateCache();
            UpdateUid();
        }
    }
    else
    {
        // Flatten transforms the path even if it's already flat.
        // Note: Transform(NULL) <=> Identity transform which is a NOP.
        
        Transform(matrix);
    }

    return status;
}


/**************************************************************************\
*
* Function Description:
*
* Warp and flattens the control points and stores
* the results to the arrays of the flatten points.
*
* Arguments:
*
*   [IN] matrix - Specifies the transform
*   [IN] destPoint - The destination quad.
*   [IN] count - the number of the quad points (3 or 4).
*   [IN] srcRect - the original rectangle to warp.
*   [IN] warpMode - Perspective or Bilinear (default is Bilinear).
*
* Return Value:
*
*   Status
*
* Created:
*
*   11/10/1999 ikkof
*       Created it.
*
\**************************************************************************/

GpStatus
GpPath::WarpAndFlatten(
    DynByteArray* flattenTypes,
    DynPointFArray* flattenPoints,
    const GpMatrix* matrix,
    const GpPointF* destPoint,
    INT count,
    const GpRectF& srcRect,
    WarpMode warpMode
    )
{
    GpXPath xpath(this, srcRect, destPoint, count, warpMode);

    return xpath.Flatten(flattenTypes, flattenPoints, matrix);
}

/**************************************************************************\
*
* Function Description:
*
* Warps and flattens the control points and transform itself to
* the flatten path.
*
* Arguments:
*
*   [IN] matrix - Specifies the transform
*                   The identity matrix is used when matrix is NULL.
*   [IN] destPoint - The destination quad.
*   [IN] count - the number of the quad points (3 or 4).
*   [IN] srcRect - the original rectangle to warp.
*   [IN] warpMode - Perspective or Bilinear (default is Bilinear).
*
* Return Value:
*
*   Status
*
* Created:
*
*   11/10/1999 ikkof
*       Created it.
*
\**************************************************************************/

GpStatus
GpPath::WarpAndFlattenSelf(
    GpMatrix* matrix,
    const GpPointF* destPoint,
    INT count,
    const GpRectF& srcRect,
    WarpMode warpMode
    )
{
    GpMatrix identity;   // Identity matrix

    GpXPath xpath(this, srcRect, destPoint, count, warpMode);

    const INT buffSize = 32;
    BYTE typesBuffer[buffSize];
    GpPointF pointsBuffer[buffSize];

    DynByteArray flattenTypes(&typesBuffer[0], buffSize);
    DynPointFArray flattenPoints(&pointsBuffer[0], buffSize);

    if(matrix == NULL)
        matrix = &identity; // Use the identity matrix

    GpStatus status = xpath.Flatten(&flattenTypes, &flattenPoints, matrix);

    if(status == Ok)
    {
        INT flattenCount = flattenPoints.GetCount();
        Points.Reset(FALSE);
        Types.Reset(FALSE);
        Points.AddMultiple(flattenPoints.GetDataBuffer(), flattenCount);
        Types.AddMultiple(flattenTypes.GetDataBuffer(), flattenCount);
        HasBezier = FALSE;

        UpdateUid();
        InvalidateCache();
    }

    return status;
}

/**************************************************************************\
*
* Function Description:
*  
*   convert a 2 segment closed subpath emitted by the region conversion
*   to a correct winding path.
*
* Arguments:
*
*   [IN] p - the path.
*
* Created:
*
*   09/21/2000 asecchia
*       Created it.
*
\**************************************************************************/

struct PathBound
{
    REAL xmin;
    REAL ymin;
    REAL xmax;
    REAL ymax;
    INT count;
    GpPointF *points;
    BYTE *types;
    bool reverse;
    
    void Init(INT c, GpPointF *p, BYTE *t)
    {
        reverse = false;
        points = p;
        types = t;
        count = c;
    }
};

void ComputeBoundingBox(
    GpPathPointIterator &i, 
    PathBound *p
)
{
    GpPointF *point = i.CurrentItem();
    p->xmax = p->xmin = point->X;
    p->ymax = p->ymin = point->Y;
    
    while(!i.IsDone())
    {
        point = i.CurrentItem();
        if(point->X < p->xmin) { p->xmin = point->X; }
        if(point->X > p->xmax) { p->xmax = point->X; }
        if(point->Y < p->ymin) { p->ymin = point->Y; }
        if(point->Y > p->ymax) { p->ymax = point->Y; }
        i.Next();
    }
}

bool Contains(PathBound &pb1, PathBound &pb2)
{
    return ( 
        (pb1.xmin <= pb2.xmin) &&
        (pb1.ymin <= pb2.ymin) &&
        (pb1.xmax >= pb2.xmax) &&
        (pb1.ymax >= pb2.ymax)     
    );
}

void ConvertRegionOutputToWinding(GpPath **p)
{
    ASSERT(*p);
    
    GpPathPointIterator iPoints(
        (GpPointF*)(*p)->GetPathPoints(),
        (BYTE*)(*p)->GetPathTypes(),
        (*p)->GetPointCount()
    );
    
    GpSubpathIterator iSubpath(&iPoints);
    
    GpPointF *points;
    BYTE *types;
    INT count;
    GpPath *ret = new GpPath(FillModeWinding);
    
    // if we're out of memory, simply give them back their path.
    
    if(!ret) { return; }
    
    GpPath *sub;
    DynArray<PathBound> bounds;
    PathBound pb;
    
    // Iterate through all the subpaths culling information for the following
    // algorithm. This is O(n) in the number of points. 
    // The information we need is the starting point for each subpath and
    // the bounding box.
    
    while(!iSubpath.IsDone())
    {
        count = -iSubpath.CurrentIndex();
        points = iSubpath.CurrentItem();
        types = iSubpath.CurrentType();
        iSubpath.Next();
        count += iSubpath.CurrentIndex();
        
        GpPathPointIterator iSubpathPoint( points, types, count );
        
        pb.Init(count, points, types);
        ComputeBoundingBox( iSubpathPoint, &pb );
        bounds.Add(pb);
    }
    
    // Double loop through all the subpaths figuring out the containment 
    // relationships.
    // For every level of containment, flip the reverse bit.
    // E.g. for a subpath that's contained by 5 other rectangles, start at
    // false and apply 5x(!)   !!!!!false == true  which means flip this path.
    // this is O(n^2) in the number of subpaths.
    
    count = bounds.GetCount();
    int i, j;
    
    for(i=1; i<count; i++)
    {
        for(j=i-1; j>=0; j--)
        {
            if(Contains(bounds[i], bounds[j]))
            {
                bounds[j].reverse = !bounds[j].reverse;
                continue;
            }
            
            if(Contains(bounds[j], bounds[i]))
            {
                bounds[i].reverse = !bounds[i].reverse;
            }
        }
    }
    
    // Now reverse all the subpaths that need to be reversed.
    // Accumulate the results into the array.
    
    for(i=0; i<count; i++)
    {
        sub = new GpPath(
            bounds[i].points, 
            bounds[i].types, 
            bounds[i].count
        );
        
        if(!sub)
        {
            // if we failed to make our temporary path, stop and return
            // what we've accumulated so far.
            
            WARNING(("ran out of memory accumulating the path"));
            break;
        }
        
        if(bounds[i].reverse)
        {
            sub->Reverse();
        }
        
        ret->AddPath(sub, FALSE);
        
        delete sub;
    }
    
    delete *p;
    *p = ret;
}

/**************************************************************************\
*
* Function Description:
*  
*   GetWidenedPath. Returns a widened version of the path. The path is widened
*   according to the pen and the result is transformed according to the input
*   matrix. When flattening the path the matrix is used as the world to device
*   transform and the flatness tolerance is applied.
*
*   This function handles inset and outset pen alignments.
*
* Arguments:
*
*   [IN] pen      - pen - specifies width for widening
*   [IN] matrix   - world to device transform.
*   [IN] flatness - number of device pixels of error allowed for flattening
*
* Return:
*   
*   GpPath *      - widened path. NULL on failure.
*                 - !!! this should return the path in an OUT parameter and
*                 -     propagate the GpStatus correctly.
*
* Created:
*
*   09/31/2000 asecchia
*       Rewrote it.
*
\**************************************************************************/

GpPath*
GpPath::GetWidenedPath(
    const GpPen *pen,
    const GpMatrix *matrix,
    REAL flatness
    ) const
{
    ASSERT(pen);
    
    // Redefine a NULL input matrix to be Identity for the duration of this
    // routine.
    
    GpMatrix transform;
    if(!matrix)
    {
        matrix = &transform;
    }
    
    DpPen *internalPen = NULL;
    internalPen = const_cast<GpPen*>(pen)->GetDevicePen();
    
    ASSERT(internalPen);
    
    if (internalPen->PenAlignment != PenAlignmentInset)
    {
        // Use the standard widening code for non-inset or non-outset pen.

        return GetWidenedPathInternal(
            internalPen,
            matrix,
            flatness,
            FALSE          // standard pen
        );
    }
    else
    {
        // Do the Inset Pen.
        
        // Our technique is as follows. See the inset pen spec in the 
        // gdiplus\specs directory.
        // First, inset pen is defined as widening to the inside of the path
        // which only has meaning for closed segments. Behaviour for open 
        // segments is unchanged (center pen).
        // We widen the path at 2x the stroke width using a center pen.
        // For round dash caps, we use a double-round or 'B' cap. We also
        // mirror the compound line pattern across the spine of the path.
        // Then we import the widened path as a region and clip against the
        // original path converted to a region. What's left is a region 
        // which contains the widened inset pen. This is converted to a path
        // and we're done.

        // Copy the pen. Note that this will copy the *pointer* to the Brush
        // but this is ok because the DpPen (insetPen) doesn't have a 
        // destructor and so won't attempt to free any state.
        
        // We will need an insetPen for the closed subpath segments and a
        // centerPen for the open subpath segments.
        
        DpPen insetPen = *internalPen;
        DpPen centerPen = *internalPen;
        
        // Use a double width center pen and then clip off the outside creating
        // a single width insetPen.
        
        insetPen.Width *= 2.0f;
        insetPen.PenAlignment = PenAlignmentCenter;
        centerPen.PenAlignment = PenAlignmentCenter;
        
        // Copy the compound array duplicating the compound array in reverse
        // and rescaling back to [0,1] interval (i.e. mirror along the spine).
        
        if( internalPen->CompoundCount > 0)
        {
            insetPen.CompoundArray = (REAL*)GpMalloc(
               sizeof(REAL)*insetPen.CompoundCount*2
            );
            
            // Check the GpMalloc for out of memory.
            
            if(insetPen.CompoundArray == NULL)
            {
                return NULL;
            }
            
            // Copy the pen->CompoundArray and duplicate it in reverse (mirror).
            // rescale to the interval [0, 1]
            
            for(INT i=0; i<insetPen.CompoundCount; i++)
            {
                // copy and scale range [0, 1] to [0, 0.5]
                
                insetPen.CompoundArray[i] = internalPen->CompoundArray[i]/2.0f;
                
                // copy and scale range [0, 1] to [0.5, 1] reversed.
                
                insetPen.CompoundArray[insetPen.CompoundCount*2-i-1] = 
                    1.0f - internalPen->CompoundArray[i]/2.0f;
            }
            
            // we have double the number of entries now.
            
            insetPen.CompoundCount *= 2;
        }

        // Create an iterator to step through each subpath.
        
        GpPathPointIterator pathIterator(
            (GpPointF*)GetPathPoints(),
            (BYTE*)GetPathTypes(),
            GetPointCount()
        );
        
        GpSubpathIterator subPathIterator(
            &pathIterator
        );
        
        // Some temporary variables.
        
        GpPointF *points;
        BYTE *types;
        INT subPathCount;
        GpPath *widenedPath = NULL;
        GpPath *subPath = NULL;

        // Accumulate the widened sub paths in this returnPath.
                
        GpPath *returnPath = new GpPath(FillModeWinding);
        
        // loop while there are more subpaths and the returnPath is not NULL
        // This implicitly checks that returnPath was allocated correctly.
        
        while(returnPath && !subPathIterator.IsDone())
        {   
            // Get the data for the current subpath.
                
            points = subPathIterator.CurrentItem();
            types = subPathIterator.CurrentType();
            subPathCount = -subPathIterator.CurrentIndex();
            subPathIterator.Next();
            subPathCount += subPathIterator.CurrentIndex();

            // Create a path object representing the current sub path.
            
            subPath = new GpPath(points, types, subPathCount);
            
            if(!subPath)
            {
                // failed the allocation.
                
                delete returnPath;
                returnPath = NULL;
                break;
            }

            // Is this subpath closed?
            
            BOOL isClosed = IsClosedType(types[subPathCount-1]);

            // Widen the subPath with the inset pen for closed and
            // center pen for open.
            
            widenedPath = subPath->GetWidenedPathInternal(
                (isClosed) ? &insetPen : &centerPen,
                matrix,
                flatness,
                isClosed            // Inset/Outset pen?
            );
                    
            // don't need the subPath anymore - we have the widened version.
            
            delete subPath;
            subPath = NULL;
            
            // Check if the widener succeeded.
            
            if(!widenedPath || !widenedPath->IsValid())
            {
                delete widenedPath;
                widenedPath = NULL;
                delete returnPath;
                returnPath = NULL;
                break;
            }
            
            if(isClosed)
            {
                // Region to path.
                
                // The widenedPath has already been transformed by the widener
                // according to the matrix. Use the identity to convert the 
                // widenedPath to a region, but use the matrix to transform the
                // (still untransformed) original matrix to a region.
                
                GpMatrix identityMatrix;
                const GpMatrix *scaleMatrix = &identityMatrix;
                
                if(matrix)
                {
                    scaleMatrix = matrix;
                }
                
                DpRegion srcRgn(widenedPath, &identityMatrix);
                DpRegion clipRgn((DpPath*)(this), scaleMatrix);// const and type cast.
        
                // Clip the region
                
                GpStatus clip = Ok;
                
                if(internalPen->PenAlignment == PenAlignmentInset)
                {
                    // Inset pen is an And operation.
                    
                    clip = srcRgn.And(&clipRgn);
                }
                
                GpPath *clippedPath;
                
                if(clip == Ok)
                {  
                    clippedPath = new GpPath(&srcRgn);
                    
                    if(!clippedPath)
                    {
                        delete widenedPath;
                        widenedPath = NULL;
                        delete returnPath;
                        returnPath = NULL;
                        break;
                    }
                    
                    ConvertRegionOutputToWinding(&clippedPath);
                    
                    // Accumulate the current subpath that we've just clipped
                    // for inset/outset into the final result.
                    
                    returnPath->AddPath(clippedPath, FALSE);
                    
                    delete clippedPath;
                    clippedPath = NULL;
                }
            }
            else
            {
                // Accumulate the center pen widened path for the open
                // subpath segment.
                
                returnPath->AddPath(widenedPath, FALSE);
            }
        
            delete widenedPath;
            widenedPath = NULL;
        }
        
        // clean up.
                
        if(internalPen->CompoundCount > 0)
        {
            // we allocated a new piece of memory, throw it away.
            // Make sure we're not trying to throw away the original pen
            // CompoundArray - only free the temporary one if we created it.
            
            ASSERT(insetPen.CompoundArray != internalPen->CompoundArray);
            GpFree(insetPen.CompoundArray);
            insetPen.CompoundArray = NULL;
        }
        
        return returnPath;
    }
}

/**************************************************************************\
*
* Function Description:
*
*   The sweep phase of a mark-sweep path point deletion algorithm
*   This will delete all points marked with PathPointTypeInternalUse.
*
*   If it deletes a start marker, it'll make the next valid point a start
*   point.
* 
*   NOTE:
*   If the algorithm encounters a closed subpath marker it will simply 
*   delete it. Because this algorithm is used for trimming the ends of 
*   open subpath segments (during endcapping), this is the desired behaviour, 
*   but may not be strictly correct for other uses.
*   
*   The points to be deleted are marked by oring in the 
*   PathPointTypeInternalUse flag. This flag is used by the widener as an 
*   internal flag and as a deletion mask for this code. These two usages 
*   do not (and should not) overlap.
*
* Created:
*
*   10/07/2000 asecchia
*       created it.
*
\**************************************************************************/

VOID GpPath::EraseMarkedSegments()
{
    // Get pointers to the source buffers.
    
    GpPointF *dstPoints = Points.GetDataBuffer();
    BYTE *dstTypes =  Types.GetDataBuffer();
    INT count = Points.GetCount();
    
    
    INT delete_count = 0;
    INT i=0;
    GpPointF *srcPoints = dstPoints;
    BYTE *srcTypes = dstTypes;
    
    bool deleted_start_marker = false;
    
    while(i<count)
    {
        // Skip all the points marked for deletion.
        
        if((*srcTypes) & PathPointTypeInternalUse)
        {
            delete_count++;
            
            // if we ever encounter a start marker, keep track of that fact.
            
            deleted_start_marker |= 
                (((*srcTypes) & PathPointTypePathTypeMask) == PathPointTypeStart);
        }
        else
        {
            // If we have deleted some stuff, move the data up.
            
            if(srcTypes!=dstTypes)
            {
                *dstPoints = *srcPoints;
                *dstTypes = *srcTypes;
                
                // if we deleted a start marker in the last deletion run, 
                // make the next non-deleted point a start marker.
                // Note: if the whole subpath is marked for deletion and
                // it's the last subpath, then we won't do this code because
                // we'll terminate the while loop first. This protects against
                // overwriting our buffer.
                
                if(deleted_start_marker)
                {
                    *dstTypes &= ~PathPointTypePathTypeMask;
                    *dstTypes |= PathPointTypeStart;
                }
            }
            
            deleted_start_marker = false;
        
            // increment to the next element.
            
            dstPoints++;
            dstTypes++;
        }
        
        // increment these every iteration through the loop.
        
        srcTypes++;
        srcPoints++;
        i++;
    }
    
    // update the DynArrays so that they reflect the new (deleted) count.
    
    Points.AdjustCount(-delete_count);
    Types.AdjustCount(-delete_count);
    
    InvalidateCache();
    UpdateUid();
}


/**************************************************************************\
*
* Function Description:
*
*   Returns a widened version of the path. This routine does not handle 
*   inset or outset pen alignments. The input insetPen parameter specifies
*   if we should double widen the path in preparation for inset or outset
*   pen modes. This has impact on dash caps and dash length.
*
* Return
* 
*   GpPath - the widened path. NULL if this routine fails.
*
* Arguments:
*
*   [IN] pen      - pen - specifies width for widening
*   [IN] matrix   - world to device transform.
*   [IN] flatness - number of device pixels of error allowed for flattening
*   [IN] insetPen - flag specifying if inset pen is being used.
*
* Return:
*   
*   GpPath *      - widened path. NULL on failure.
*                 - !!! this should return the path in an OUT parameter and
*                 -     propagate the GpStatus correctly.
*
* Created:
*
*   10/05/2000 asecchia
*       rewrote it.
*
\**************************************************************************/

GpPath*
GpPath::GetWidenedPathInternal(
    const DpPen *pen,
    const GpMatrix *matrix,
    REAL flatness,
    BOOL insetPen
    ) const
{
    ASSERT(pen);
    ASSERT(matrix);
    ASSERT(pen->PenAlignment!=PenAlignmentInset);
    
    GpStatus status = Ok;
    
    GpMatrix invMatrix(*matrix);
    if(Ok != invMatrix.Invert())
    {
        ONCE(WARNING(("GetWidenedPath: failed to invert the matrix")));
        return NULL;
    }
    
    // This is a const function. We cannot modify 'this' so we clone
    // the path in order to flatten it.
    
    GpPath* path = this->Clone();
    if(path == NULL) { return NULL; }
    if(Ok != (status = path->Flatten(matrix, flatness)))
    {
        ONCE(WARNING(("GetWidenedPath: failed to flatten the path (%x)", status)));
        return NULL;
    }
    
    // Undo the Flatten matrix transform so that we can widen in world space.
    // This is required so that we correctly compute the device resolution 
    // minimum pen width for nominal pens.
    
    path->Transform(&invMatrix);
    
    // Do all the path decorations before widening. This is to ensure that
    // the decorations have all of the original path information to operate
    // on --- the widening/decoration process is lossy so they have to be
    // performed in the right order.
    
    // First apply the end caps. This decoration must be applied before 
    // dashing the path.
    // Need to loop through all the subpaths, apply the end caps and 
    // fix up the path segments so they don't exit the cap incorrectly.
    // put all the caps in a path for later use. We will apply these caps
    // when we're done widening.
    
    GpPath *caps = NULL;
    
    if(GpEndCapCreator::PenNeedsEndCapCreator(pen))
    {    
        // Create an instance of the GpEndCapCreator which will create
        // our endcap aggregate path.
        
        GpEndCapCreator ecc(
            path, 
            const_cast<DpPen*>(pen), 
            matrix, 
            0.0f, 0.0f,
            TRUE
        );
        
        // CreateCapPath will mark the points in the path for deletion if 
        // it's necessary to trim the path to fit the cap.
        
        status = ecc.CreateCapPath(&caps);
        if(status != Ok) 
        { 
            return NULL; 
        }
        
        // Remove the points marked for deletion in the cap trimming step.
        
        path->EraseMarkedSegments();
    }
    
    // Apply the dash decorations. Note that this will bounce on an empty path.
    
    GpPath* dashPath = NULL;

    if( (pen) && 
        (pen->DashStyle != DashStyleSolid) &&
        (path->GetPointCount() > 0)
    )
    {
        // the width is artificially expanded by 2 if the pen is inset. 
        // we need to factor this into the dash length and scale by 0.5.
        
        dashPath = path->CreateDashedPath(
            pen, 
            matrix, 
            0.0f,     // not used
            0.0f,     // not used
            (insetPen) ? 0.5f : 1.0f,
            TRUE
        );
        
        // If we successfully got a dashed version of *path, delete
        // the old one and return the new one.
        
        if(dashPath)
        {
            delete path;
            path = dashPath;
        }
    }
    
    // Only do the widening if we have some points left in our 
    // path after trimming
    
    if(path->GetPointCount() > 0)
    {
        // Create a widener object. Note that if path has no points left, this
        // will bounce immediately with an invalid widener.
    
        GpPathWidener widener(
            path,
            pen,
            matrix,
            0.0f,    // not used
            0.0f,    // not used
            TRUE,    // not used
            insetPen
        );
        
        // We're done with this now.
        
        delete path;
        path = NULL;
    
        // Check if we have a valid Widener object.
        
        if(!widener.IsValid()) 
        { 
            status = OutOfMemory; 
        }
    
        // Get the widened path.
    
        if(status == Ok) 
        { 
            status = widener.Widen(&path); 
        }
    }
    else
    {
        delete path;
        path = caps;
        caps = NULL;
    }

    // paranoid checking the return from the widener.
    
    if((status == Ok) && (path != NULL))
    {
        // Add the endcaps to the widened path. AddPath will bounce a NULL 
        // caps pointer with InvalidParameter. For our purposes that is 
        // considered correctly handled and we continue. 
        
        path->AddPath(caps, FALSE);
                                    
        if(path->IsValid())
        {
            // Transform into the requested destination device space.
            
            path->Transform(matrix);
        }
    }
    
    // Delete the caps before returning. If we had caps, we've copied them
    // into path, otherwise caps is NULL. Or we failed to widen. Either way
    // we must not leak memory.
    
    delete caps;
    caps = NULL;

    return path;
}

/**************************************************************************\
*
* Function Description:
*
* This widenes itself.
*
* Arguments:
*
*   [IN] pen - the pen.
*   [IN] matrix - Specifies the transform
*   [IN] dpiX - the X-resolution.
*   [IN] dpiY - the Y-resolution.
*
* Return Value:
*
*   Ok if successfull.
*
* Created:
*
*   09/27/1999 ikkof
*       Created it.
*
\**************************************************************************/

GpStatus
GpPath::Widen(
    GpPen *pen,
    GpMatrix *matrix,
    REAL flatness
    )
{
    if(pen==NULL)
    {
        return InvalidParameter;
    }
    
    GpMatrix transform;  // Identity matrix

    if(matrix)
    {
        transform = *matrix;
    }

    GpPath* widenedPath = GetWidenedPath(
        pen,
        &transform,
        flatness
    );

    if(widenedPath)
    {
        Points.Reset(FALSE);
        Types.Reset(FALSE);
        INT count = widenedPath->GetPointCount();
        Points.AddMultiple(widenedPath->Points.GetDataBuffer(), count);
        Types.AddMultiple(widenedPath->Types.GetDataBuffer(), count);
        SubpathCount = widenedPath->SubpathCount;
        HasBezier = widenedPath->HasBezier;
        Flags = widenedPath->Flags;
        FillMode = FillModeWinding;
        delete widenedPath;

        GpStatus status = Ok;

        InvalidateCache();
        UpdateUid();

        return status;
    }
    else
    {
        return OutOfMemory;
    }
}

// Get the flattened path.

const DpPath *
GpPath::GetFlattenedPath(
    const GpMatrix* matrix,
    DpEnumerationType type,
    const DpPen* pen
    ) const
{
    GpPath* flattenedPath = NULL;

    if(type == Flattened)
    {
        flattenedPath = Clone();
        
        if(flattenedPath)
        {
            GpStatus status = flattenedPath->Flatten(matrix);
            
            if(Ok != status)
            {
                // Out of memory or flatten returned some other error,
                // however we can't return a status code from this routine.
                
                delete flattenedPath;
                flattenedPath = NULL;
            }
        }
    }
    else if(type == Widened)
    {
        flattenedPath = GetWidenedPath(
            GpPen::GetPen(pen),
            matrix,
            FlatnessDefault
        );
    }

    return flattenedPath;
}



/**************************************************************************\
*
* Function Description:
*
* Checks if the given point in World coordinate is inside of
* the path.  The matrix is used to render path in specific resolution.
* Usually, Graphics's World to Device matrix is used.  If matrix is NULL,
* the identity matrix is used.
*
* Arguments:
*
*   [IN] point - A test point in World coordinate
*   [OUT] isVisible - TRUE is the test point is inside of the path.
*   [IN] matrix - A matrix to render path.  Identity is used if NULL.
*
* Return Value:
*
*   Ok if successfull.
*
* Created:
*
*   10/05/1999 ikkof
*       Created it.
*
\**************************************************************************/

GpStatus
GpPath::IsVisible(
    GpPointF* point,
    BOOL* isVisible,
    GpMatrix* matrix)
{
    GpMatrix m;

    if(matrix)
        m = *matrix;

    GpRegion rgn(this);

    if(rgn.IsValid())
        return rgn.IsVisible(point, &m, isVisible);

    *isVisible = FALSE;
    return GenericError;
}


/**************************************************************************\
*
* Function Description:
*
* Checks if the given point in World coordinate is inside of
* the path outline.  The matrix is used to render path in specific resolution.
* Usually, Graphics's World to Device matrix is used.  If matrix is NULL,
* the identity matrix is used.
*
* Arguments:
*
*   [IN] point - A test point in World coordinate
*   [OUT] isVisible - TRUE is the test point is inside of the path.
*   [IN] pen - A pen to draw the outline.
*   [IN] matrix - A matrix to render path.  Identity is used if NULL.
*   [IN] dpiX - x-resolution of the device.
*   [IN] dpiY - y-resolution of the device.
*
* Return Value:
*
*   Ok if successfull.
*
* Created:
*
*   10/05/1999 ikkof
*       Created it.
*
\**************************************************************************/

GpStatus
GpPath::IsOutlineVisible(
    GpPointF* point,
    BOOL* isVisible,
    GpPen* pen,
    GpMatrix* matrix,
    REAL dpiX,
    REAL dpiY
    )
{
    if ((dpiX <= 0) || (dpiY <= 0))
    {
        dpiX = Globals::DesktopDpiX;
        dpiY = Globals::DesktopDpiY;
    }

    // If the given pen is not a solid line,
    // clone the pen and set its dash type to Solid.
    // We do line hit testing in solid lines.

    GpPen* pen1 = NULL;
    if(pen && pen->GetDashStyle() != DashStyleSolid)
    {
        pen1 = pen->Clone();
        if(pen1)
           pen1->SetDashStyle(DashStyleSolid);
    }
    else
        pen1 = pen;

    if(pen1 == NULL)
    {
        *isVisible = FALSE;
        return Ok;
    }

    // Create a widened path in the transformed coordinates.

    GpPath* widenedPath = GetWidenedPath(
        pen1,
        matrix,
        FlatnessDefault
    );

    if(pen1 != pen)
        delete pen1;

    GpStatus status = Ok;

    if(widenedPath)
    {
        // Since the widened path is already transformed, we have to
        // transform the given point.

        GpPointF    transformedPoint = *point;
        if(matrix)
            matrix->Transform(&transformedPoint);

        status = widenedPath->IsVisible(&transformedPoint, isVisible, NULL);
        delete widenedPath;
    }
    else
    {
        *isVisible = FALSE;
    }

    return status;
}

// Is the current dash segment a line segment?
// If false it's a space segment.

inline bool IsLineSegment(GpIterator<REAL> &dashIt)
{
    // line segment starts on even indices.

    return bool( !(dashIt.CurrentIndex() & 0x1) );
}

// Emit a line segment if it is not degenerate.
// Return true if emitted, false if degenerate

bool EmitLineSegment(
    GpPathPointIterator &dstPath,
    GpPointF p0,
    GpPointF p1,
    bool isLineStart
)
{
    GpPointF *currentPoint;
    BYTE *currentType;

    if( (REALABS(p0.X-p1.X) < REAL_EPSILON) &&
        (REALABS(p0.Y-p1.Y) < REAL_EPSILON) )
    {
        // Don't emit a line segment if it has zero length.
        return false;
    }

    // If the last emitted line ends at the same point that this next
    // one starts, we don't need a new start record.

    if(isLineStart)
    {
        // start point.
        currentPoint = dstPath.CurrentItem();
        *currentPoint = p0;
        currentType = dstPath.CurrentType();
        *currentType = PathPointTypeStart | PathPointTypeDashMode;

        dstPath.Next();
    }

    // end point.
    currentPoint = dstPath.CurrentItem();
    *currentPoint = p1;
    currentType = dstPath.CurrentType();
    *currentType = PathPointTypeLine | PathPointTypeDashMode;

    dstPath.Next();

    return true;
}

INT
getDashData(
    BYTE* newTypes,
    GpPointF* newPts,
    INT estimateCount,
    REAL penWidth,
    REAL dashOffset,
    const REAL* dashArray,
    INT dashCount,
    const BYTE* types,
    const GpPointF* points,
    INT numOfPoints,
    BOOL isClosed,
    const REAL* distances
    )
{
    ASSERT(estimateCount >= numOfPoints);
    ASSERT(types && points);

    // Code assumes first point != last point for closed paths.  If first
    // point == last point, decrease point count
    if (isClosed && numOfPoints &&
        points[0].X == points[numOfPoints-1].X &&
        points[0].Y == points[numOfPoints-1].Y)
    {
        numOfPoints--;
    }


    if(!newTypes || !newPts)
    {
        return 0;
    }

    // Make the iterators.

    GpArrayIterator<GpPointF> pathIterator(
        const_cast<GpPointF*>(points),
        numOfPoints
    );
    GpArrayIterator<REAL> pathBaseDistance(
        const_cast<REAL*>(distances),
        numOfPoints
    );
    
    GpPathPointIterator dstPath(newPts, newTypes, estimateCount);
    
    GpArrayIterator<REAL> dashBaseIterator(
        const_cast<REAL*>(dashArray),
        dashCount
    );

    // Compute the length of the dash

    REAL dashLength = 0.0f;
    while(!dashBaseIterator.IsDone())
    {
        dashLength += *(dashBaseIterator.CurrentItem());
        dashBaseIterator.Next();
    }
    ASSERT(dashLength > -REAL_EPSILON);


    // Do the offset initialization.

    dashBaseIterator.SeekFirst();

    REAL distance = GpModF(dashOffset, dashLength);
    REAL delta;

    // Compute the position in the dash array corresponding to the
    // specified offset.

    while(!dashBaseIterator.IsDone())
    {
        delta = *(dashBaseIterator.CurrentItem());
        if(distance < delta)
        {
            // set to the remaining piece of the dash.
            distance = delta-distance;
            break;
        }
        distance -= delta;
        dashBaseIterator.Next();
    }

    // The dashIterator is now set to point to the correct
    // dash for the first segment.

    // These are circular arrays to repeat the dash pattern.

    GpCircularIterator<REAL> dashIterator(&dashBaseIterator);


    // This is the distance into the current dash segment that we're going
    // to start at.

    REAL currentDashLength = distance;
    REAL currentSegmentLength;

    GpPointF p0, p1;
    GpVector2D sD;     // segment direction.

    // Used to track if we need to emit a segment start record.

    bool emittedPathSegment = false;

    if(isClosed)
    {
        // set up everything off the last item and then point to
        // the first item to start the process.

        pathBaseDistance.SeekFirst();

        pathIterator.SeekLast();
        p0 = *(pathIterator.CurrentItem());

        pathIterator.SeekFirst();
        p1 = *(pathIterator.CurrentItem());

        // get the distance between the first and last points.

        GpVector2D seg = p1-p0;
        currentSegmentLength = seg.Norm();
    }
    else
    {
        // Get the first point in the array.

        p0 = *(pathIterator.CurrentItem());

        // already initialized to the first point, start on the next one.

        pathIterator.Next();
        pathBaseDistance.Next();

        // distance between point n and point n+1 is stored in
        // distance[n+1]. distance[0] is the distance between the first
        // and last points.

        currentSegmentLength = *(pathBaseDistance.CurrentItem());
    }

    // reference the distances as circular so that we can simplify the
    // internal algorithm by not having to check when we query for the
    // next segment in the last iteration of the loop.

    GpCircularIterator<REAL> pathDistance(&pathBaseDistance);

    while( !pathIterator.IsDone() )
    {
        if(currentDashLength > currentSegmentLength)
        {
            // The remaining dash segment length is longer than the remaining
            // path segment length.
            // Finish the path segment.

            // Note that we've moved along the dash segment.

            currentDashLength -= currentSegmentLength;

            p1 = *(pathIterator.CurrentItem());

            if(IsLineSegment(dashIterator))
            {
                // emit a line. Add the start record only if we didn't just
                // emit a path segment. If we're emitting a series of path
                // segments to complete one dash, we can't have any start
                // records inbetween the segments otherwise we'll end up with
                // spurious endcaps in the middle of the lines.

                emittedPathSegment = EmitLineSegment(
                    dstPath,
                    p0, p1,
                    !emittedPathSegment
                );
            }
            else
            {
                emittedPathSegment = false;
            }

            p0 = p1;

            // Keep these two in sync.

            pathDistance.Next();
            pathIterator.Next();

            currentSegmentLength = *(pathDistance.CurrentItem());
        }
        else
        {
            // The remaining path segment length is longer than the remaining
            // dash segment length.
            // Finish the dash segment.

            // Compute position between start and end point of the current
            // path segment where we finish with this dash segment.

            ASSERT(REALABS(currentSegmentLength)>REAL_EPSILON);
            sD = *(pathIterator.CurrentItem());
            sD -= p0;
            sD *= currentDashLength/currentSegmentLength;

            // Move along the path segment by the amount left in the
            // dash segment.

            currentSegmentLength -= currentDashLength;

            p1 = p0 + sD;

            if(IsLineSegment(dashIterator))
            {
                // emit a line. Add the start record only if we didn't just
                // emit a path segment.

                EmitLineSegment(
                    dstPath,
                    p0, p1,
                    !emittedPathSegment
                );
            }

            p0 = p1;

            // dashIterator is circular, so this should keep wrapping through
            // the dash array.

            dashIterator.Next();

            // Get the new dash length.

            currentDashLength = *(dashIterator.CurrentItem());
            emittedPathSegment = false;
        }
    }
    
    INT size = dstPath.CurrentIndex();

    if(!isClosed && size != 0 && numOfPoints != 0)
    {
        BYTE *type;
        REAL halfPenWidth2 = penWidth * penWidth / 4.0f;

        // Turn off dash mode for the last segment if the last
        // point is very close to the last dash segment.
        if (distance_squared(points[numOfPoints-1], newPts[size-1]) < halfPenWidth2)
        {
            dstPath.Prev();
            type = dstPath.CurrentType();
            *type &= ~PathPointTypeDashMode;
        }

        // Turn off dash mode for the first segment if the first
        // point is very close to the first dash segment.
        if (distance_squared(points[0], newPts[0]) < halfPenWidth2)
        {
            dstPath.SeekFirst();
            type = dstPath.CurrentType();
            *type &= ~PathPointTypeDashMode;
        }
    }

    // return the number of entries added to the dstPath array.

    return (size);
}

/**************************************************************************\
*
* Function Description:
*
* Creates a dashed path.
*
* Arguments:
*
*   [IN] pen - This pen contains the dash info.
*   [IN] matrix - The transformation where the dash patterns are calculated.
*                   But the dashed path is transformed back to the World
*                   coordinates.
*   [IN] dpiX - x-resolution.
*   [IN] dpiY - y-resolution.
*
* Return Value:
*
*   returns a dashed path.
*
* Created:
*
*   01/27/2000 ikkof
*       Created it.
*
\**************************************************************************/

GpPath*
GpPath::CreateDashedPath(
    const GpPen* pen,
    const GpMatrix* matrix,
    REAL dpiX,
    REAL dpiY,
    REAL dashScale,
    BOOL needDashCaps
    ) const
{
    if(pen == NULL)
        return NULL;

    DpPen* dpPen = ((GpPen* ) pen)->GetDevicePen();

    return CreateDashedPath(dpPen, matrix, dpiX, dpiY, dashScale, needDashCaps);
}

/**************************************************************************\
*
* Function Description:
*
* Returns TRUE if the given points have non-horizontal or non-vertical
*   edges.
*
*
* Created:
*
*   04/07/2000 ikkof
*       Created it.
*
\**************************************************************************/

inline
BOOL
hasDiagonalEdges(
    GpPointF* points,
    INT count
    )
{
    if(!points || count <= 1)
        return FALSE;

    GpPointF *curPt, *nextPt;
    curPt = points;
    nextPt = points + 1;

    BOOL foundDiagonal = FALSE;
    INT i = 1;

    while(!foundDiagonal && i < count)
    {
        if((curPt->X == nextPt->X) || (curPt->Y == nextPt->Y))
        {
            // This is either horizontal or vertical edges.
            // Go to the next edge.

            curPt++;
            nextPt++;
            i++;
        }
        else
            foundDiagonal = TRUE;
    }

    return foundDiagonal;
}

GpPath*
GpPath::CreateDashedPath(
    const DpPen* dpPen,
    const GpMatrix* matrix,
    REAL dpiX,
    REAL dpiY,
    REAL dashScale,
    BOOL needDashCaps
    ) const
{
    FPUStateSaver::AssertMode();


    GpPointF* points = Points.GetDataBuffer();
    INT numOfPoints = GetPointCount();

    if(dpPen == NULL)
        return NULL;

    if(
        dpPen->DashStyle == DashStyleSolid ||
        dpPen->DashCount == 0 ||
        dpPen->DashArray == NULL
    )
        return NULL;

    REAL penWidth = dpPen->Width;
    GpUnit unit = dpPen->Unit;
    BOOL isWorldUnit = TRUE;

    REAL dashUnit;
    {
        // The minimum pen width 
        REAL minimumPenWidth = 1.0f;
        
        if(REALABS(dashScale-0.5f) < REAL_EPSILON)
        {
            minimumPenWidth = 4.0f;
        }
        
        if(unit != UnitWorld)
        {
            isWorldUnit = FALSE;
            penWidth = ::GetDeviceWidth(penWidth, unit, dpiX);
    
            // Prevent the extremely thin line and dashes.
    
            dashUnit = max(penWidth, minimumPenWidth);
        }
        else
        {
            REAL majorR, minorR;
    
            // Calculate the device width.
    
            ::GetMajorAndMinorAxis(&majorR, &minorR, matrix);
            REAL maxWidth = penWidth*majorR;
            REAL minWidth = penWidth*minorR;
    
            // If the device width becomes less than 1, strech the penWidth
            // so that the device width becomes 1.
            // If we're doing the inset pen, then the path is scaled up double
            // in size and we need to scale by the inverse.
            // Also, the minimum pen width needs to be 2 not 1 in this case 
            // because we will remove half the line width. dashScale is 1/2 
            // in this case so we divide by it.
    
            dashUnit = penWidth;
            
            if(maxWidth < minimumPenWidth)
            {
                dashUnit = minimumPenWidth/majorR;
            }
        }
    }

    dashUnit *= dashScale;

    GpMatrix mat, invMat;

    if(matrix)
    {
        mat = *matrix;
        invMat = mat;
    }

    if(invMat.IsInvertible())
    {
        invMat.Invert();
    }
    else
    {
        WARNING(("Inverse matrix does not exist."));

        return NULL;
    }

    INT dashCount = dpPen->DashCount;
    REAL* dashArray = (REAL*) GpMalloc(dashCount*sizeof(REAL));
    if(dashArray)
    {
        GpMemcpy(dashArray, dpPen->DashArray, dashCount*sizeof(REAL));

        // Adjust the dash interval according the stroke width.

        for(INT i = 0; i < dashCount; i++)
        {
            dashArray[i] *= dashUnit;
        }
    }
    else
    {
        return NULL;
    }

    GpPath* newPath = Clone();

    if(newPath && newPath->IsValid())
    {
        // Flatten in the resolution given by the matrix.

        newPath->Flatten(&mat);

        if(isWorldUnit)
        {
            // Transform back to the World Unit.
            // When the pen is in WorldUnit, transform the path
            // before detDashData() is called.

            newPath->Transform(&invMat);
        }

        BYTE *types = newPath->Types.GetDataBuffer();
        points = newPath->Points.GetDataBuffer();
        numOfPoints = newPath->GetPointCount();

        GpPointF* grad = (GpPointF*) GpMalloc((numOfPoints + 1)*sizeof(GpPointF));
        REAL* distances = (REAL*) GpMalloc((numOfPoints + 1)*sizeof(REAL));

        if(grad == NULL || distances == NULL)
        {
            GpFree(grad);
            GpFree(dashArray);
            delete newPath;

            return NULL;
        }

        // Calculate the distance of each segment.

        INT i;

        REAL dashLength = 0;

        for(i = 0; i < dashCount; i++)
            dashLength += dashArray[i];

        // Make sure count is an even number.
        // !!! [asecchia] this looks completely bogus.
        // surely we should have ASSERTed that this is true at this point
        // and ensured that it was true by parameter validation at the API?

        if(dashCount & 0x01)
            dashCount ++;

        // Compute the dash adjustment for the dash cap length here. This
        // is outside of the subpath loop so it only gets computed once
        // and therefore doesn't get applied to further subpath segments
        // multiple times.

        if (needDashCaps)
        {
            GpPen *gppen = GpPen::GetPen(dpPen);
            if (gppen != NULL)
            {
                gppen->AdjustDashArrayForCaps(
                    dashUnit,
                    dashArray,
                    dashCount
                );
            }
        }


        DynByteArray dashTypes;
        DynPointFArray dashPoints;

        BYTE* newTypes = NULL;
        GpPointF* newPts = NULL;

        DpPathIterator iter(points, types, numOfPoints);

        INT startIndex, endIndex;
        BOOL isClosed;
        REALD totalLength = 0;
        INT totalCount = 0;
        BOOL isSingleSubpath = iter.GetSubpathCount() == 1;

        while(iter.NextSubpath(&startIndex, &endIndex, &isClosed))
        {
            GpPointF startPt, lastPt, nextPt;
            REAL dx, dy;
            REALD length;
            startPt = points[startIndex];
            lastPt = startPt;

            totalLength = 0;
            INT k = 0;
            INT segmentCount = endIndex - startIndex + 1;

            CalculateGradientArray(grad, distances,
                points + startIndex, segmentCount);

            for(i = 1; i < segmentCount; i++)
                totalLength += distances[i];

            if(isClosed)
                totalLength += distances[0];

            // Estimate the required points.

            INT estimateCount
                = GpCeiling(TOREAL(totalLength*dashCount/dashLength))
                    + numOfPoints;

            // For extra caution, multiply by 2.

            estimateCount <<= 1;

            // Allocate new types and buffers

            if(newTypes)
            {
                BYTE* newTypes1 = (BYTE*) GpRealloc(
                                            newTypes,
                                            estimateCount*sizeof(BYTE));
                if(newTypes1)
                    newTypes = newTypes1;
                else
                    goto cleanUp;
            }
            else
            {
                newTypes = (BYTE*) GpMalloc(estimateCount*sizeof(BYTE));
                if(!newTypes)
                    goto cleanUp;
            }

            if(newPts)
            {
                GpPointF* newPts1 = (GpPointF*) GpRealloc(
                                                newPts,
                                                estimateCount*sizeof(GpPointF));
                if(newPts1)
                    newPts = newPts1;
                else
                    goto cleanUp;
            }
            else
            {
                newPts = (GpPointF*) GpMalloc(estimateCount*sizeof(GpPointF));
                if(!newPts)
                    goto cleanUp;
            }
 
            // Adjust the dash offset if necessary.
 
            REAL dashCapOffsetAdjustment = 0.0f;
            if (needDashCaps)
            {
                GpPen *gppen = GpPen::GetPen(dpPen);
                if ((gppen != NULL) && isClosed)
                {
                    // Fix for Whistler Bug 178774
                    // Since dash caps are no longer 'inset' when they are
                    // rendered, it is possible that on closed paths, the dash caps
                    // on the start and end of a closed path will overlap. This
                    // offset will leave sufficient space for the two caps. However,
                    // this fix is not bullet-proof. It will *always* work if the
                    // Dash Offset is 0. However, if it is non-zero, it is possible
                    // that the offset will counter-act the adjustment and there
                    // will be some dash overlap at the start/end of closed paths.
                    // I believe this is acceptable since VISIO 2000, Office9 and
                    // PhotoDraw 2000 v2 also have the collision problem.
                    // The real solution is to enforce a minimum spacing between the
                    // start and end or merge the start/end segments if they collide.
    
                    dashCapOffsetAdjustment =
                        2.0f * gppen->GetDashCapInsetLength(dashUnit);
                }
            }
            
            INT newCount = getDashData(
                newTypes,
                newPts,
                estimateCount,
                penWidth,
                // Shouldn't the offset be scaled dashUnit instead of penWidth?
                dpPen->DashOffset * penWidth - dashCapOffsetAdjustment,
                dashArray,
                dashCount,
                types + startIndex,
                points + startIndex,
                endIndex - startIndex + 1,
                isClosed,
                distances
            );

            if(newCount)
            {
                dashTypes.AddMultiple(newTypes, newCount);
                dashPoints.AddMultiple(newPts, newCount);
            }

        }

        totalCount = dashPoints.GetCount();
        if(totalCount > 0)
        {
            GpPathData pathData;
            pathData.Count = totalCount;
            pathData.Types = dashTypes.GetDataBuffer();
            pathData.Points = dashPoints.GetDataBuffer();

            newPath->SetPathData(&pathData);

            if(!isWorldUnit)
            {
                // Transform back to the World Unit.
                // When the pen is in WorldUnit, it is already transformed
                // before detDashData() is called.

                newPath->Transform(&invMat);
            }

        }
        else
        {
            delete newPath;
            newPath = NULL;
        }

        GpFree(newTypes);
        GpFree(newPts);
        GpFree(distances);
        GpFree(grad);
        GpFree(dashArray);

        return newPath;

cleanUp:
        GpFree(newTypes);
        GpFree(newPts);
        GpFree(distances);
        GpFree(grad);
        GpFree(dashArray);
        delete newPath;

        return NULL;
    }
    else
    {
        GpFree(dashArray);

        if(newPath)
            delete newPath;

        return NULL;
    }
}


/**************************************************************************\
*
* Function Description
*
*   ComputeWindingModeOutline
*   (so called RemoveSelfIntersections)
*
*   This computes the winding mode fill outline for the path. It's designed to 
*   produce a path that will look the same as a winding mode fill if it's 
*   filled with an alternate fill.
*
* Arguments:
*
*   matrix   - world to device matrix - used for flattening.
*   flatness - number of device pixels of error in the flattening tolerance.
*            - Pass FlatnessDefault for default behaviour.
*
* Return Value:
*
*   GpStatus
*
* History:
*
*   06/16/1999 t-wehunt
*       Created it.
*   10/31/2000 asecchia
*       rewrote, rename.
*
\**************************************************************************/

GpStatus
GpPath::ComputeWindingModeOutline(
    const GpMatrix *matrix, 
    REAL flatness, 
    BOOL *wereIntersectsRemoved
)
{
    PathSelfIntersectRemover corrector;
    DynPointFArray newPoints;  // Array that will hold the new points.
    DynIntArray polyCounts;    // Array that will hold the numPoints for each
                               // new polygon.
    INT numPolys;              // count of new polygons created
    INT numPoints;             // count of new points created
    GpStatus status = Ok;      // holds return status of commmands

    // Must clone the path because this could fail while we're accumulating
    // the new path and we'd end up returning an invalid path.
    // If we return InvalidParameter or some other failure code, we'll return
    // with the original path intact.
    
    GpPath *path = Clone();
    
    if(path == NULL)
    {
        return OutOfMemory;
    }

    status = path->Flatten(matrix, flatness);
    if(Ok != status)
    {
        goto Done;
    }

    INT pointCount = path->GetPointCount();
    GpPointF *pathPts = const_cast<GpPointF*>(path->GetPathPoints());
    BYTE *pathTypes = const_cast<BYTE*>(path->GetPathTypes());

    if (pointCount == 0)
    {
        goto Done;
    }

    // Add the subpaths to the Path corrector
    INT ptIndex=0; // ptIndex tracks the current index in the array of points.
    INT count=0;   // the size of the current subpath.

    // Init the corrector with the number of points we will be adding.
    if ((status = corrector.Init(pointCount)) != Ok)
    {
        goto Done;
    }

    while (ptIndex < pointCount)
    {
        if (pathTypes[ptIndex] == PathPointTypeStart && ptIndex != 0)
        {
            // Add the next subpath to the PathCorrector. the start index of the subpath is
            // determined using the current index minus the current subPath size.
            if ((status =
                corrector.AddPolygon(pathPts + ptIndex-count, count)) != Ok)
            {
                goto Done;
            }
            // set count to 1 since this is the first point in the new subpath
            count = 1;
        } else
        {
            count++;
        }
        ptIndex++;
    }
    // Add the last subpath that is implicitly ended by the last point.
    if (ptIndex != 0)
    {
        // Add the next subpath to the PathCorrector. the start index of the subpath is
        // determined using the current index minus the current subPath size.
        if ((status =
            corrector.AddPolygon(pathPts + ptIndex-count, count)) != Ok)
        {
            goto Done;
        }
    }

    if ((status = corrector.RemoveSelfIntersects()) != Ok)
    {
        goto Done;
    }

    if ((status = corrector.GetNewPoints(&newPoints, &polyCounts)) != Ok)
    {
        goto Done;
    }

    // clear out the old path data so we can replace with the newly corrected one.
    path->Reset();

    // Now that we have the corrected path, add it back.
    GpPointF *curPoints = newPoints.GetDataBuffer();
    for (INT i=0;i<polyCounts.GetCount();i++)
    {
        if(polyCounts[i] > 1)
        {
            if ((status = path->AddPolygon(curPoints,polyCounts[i])) != Ok)
            {
                goto Done;
            }
        }
        else
        {
            WARNING(("degenerate polygon created by the SelfIntersectRemover"));
        }

        curPoints += polyCounts[i];
    }

    if (wereIntersectsRemoved != NULL)
    {
        *wereIntersectsRemoved = corrector.PathWasModified();
    }
    
    
    // Clear the state in the path. There is only one failure path following 
    // this and it leaves the path in an invalid state anyway, so we can do 
    // Reset here. Reset ensures that the cache is invalidated and the 
    // UID is recomputed.
    
    Reset();
    
    // Swap the path data pointers - free the old ones.
    
    if(Ok != Points.ReplaceWith((DynArray<GpPointF> *) (&path->Points)) ||
       Ok != Types.ReplaceWith((DynArray<BYTE> *) (&path->Types)))
    {
        // If the final commit fails due to low memory, we are hosed,
        // we wiped out some of our path data and can't convert from the
        // local copy, so set our status to invalid and fail the call.
        
        SetValid(FALSE);
        status = OutOfMemory;
        goto Done;
    }
    
    // Need to remember the subpath count.
    
    SubpathCount = path->SubpathCount;

    Done:
    
    delete path;
    
    return status;
}


VOID DpPath::InitDefaultState(GpFillMode fillMode)
{
    HasBezier = FALSE;
    FillMode = fillMode;
    Flags = PossiblyNonConvex;
    IsSubpathActive = FALSE;
    SubpathCount = 0;

    Types.Reset(FALSE);     // FALSE - don't free the memory
    Points.Reset(FALSE);    // FALSE - don't free the memory

    SetValid(TRUE);
    UpdateUid();
}

DpPath::DpPath(const DpPath* path)
{
    if(path)
    {
        HasBezier = path->HasBezier;
        FillMode = path->FillMode;
        Flags = path->Flags;
        IsSubpathActive = path->IsSubpathActive;
        SubpathCount = path->SubpathCount;

        BYTE *types = path->Types.GetDataBuffer();
        GpPointF* points = path->Points.GetDataBuffer();
        INT count = path->GetPointCount();

        SetValid((count == 0) || ((Types.AddMultiple(types, count) == Ok) &&
                                  (Points.AddMultiple(points, count) == Ok)));
    }
    else
        SetValid(FALSE);
}


/**************************************************************************\
*
* Function Description:
*
*   Offset all path points by the specified amount
*
* Arguments:
*
*   dx, dy - Amount to offset along x- and y- direction
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

VOID
DpPath::Offset(
    REAL dx,
    REAL dy
    )
{
    ASSERT(IsValid());

    INT count = GetPointCount();
    GpPointF* pts = Points.GetDataBuffer();

    if (count > 0)
    {
        UpdateUid();
    }
    while (count--)
    {
        pts->X += dx;
        pts->Y += dy;
        pts++;
    }
}


/**************************************************************************\
*
* Function Description:
*
*   Create a driver DpPath class.
*
* Arguments:
*
*   [IN] fillMode - Specify the path fill mode
*
* Return Value:
*
*   IsValid() is FALSE if failure.
*
* History:
*
*   12/08/1998 andrewgo
*       Created it.
*
\**************************************************************************/

DpPath::DpPath(
    const GpPointF *points,
    INT count,
    GpPointF *stackPoints,
    BYTE *stackTypes,
    INT stackCount,
    GpFillMode fillMode,
    DpPathFlags pathFlags
    ) : Types(stackTypes, stackCount), Points(stackPoints, stackCount)
{
    ASSERT((fillMode == FillModeAlternate) ||
           (fillMode == FillModeWinding));

    InitDefaultState(fillMode);
    Flags = pathFlags;

    // We can call this method with no points, just to set up
    // the stackPoints/stackTypes

    if (count > 0)
    {
        BYTE *types;

        if ((types = Types.AddMultiple(count)) != NULL)
        {
            *types++ = PathPointTypeStart;
            GpMemset(types, PathPointTypeLine, count - 1);
            SetValid(Points.AddMultiple(points, count) == Ok);

            if(IsValid()) 
            {
                IsSubpathActive = TRUE;
                SubpathCount = 1;
            }
        }
        else
        {
            SetValid(FALSE);
        }
    }
}

/**************************************************************************\
*
* Function Description:
*
*   Close the currently active subpath in a path object
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   Status code
*
* History:
*
*   01/15/1999 ikkof
*       Created it.
*
\**************************************************************************/

GpStatus
DpPath::CloseFigure()
{
    ASSERT(IsValid());

    // Check if there is an active subpath

    if (IsSubpathActive)
    {
        // If so, mark the last point as the end of a subpath

        Types.Last() |= PathPointTypeCloseSubpath;
        StartFigure();
    }

    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   Close all open subpaths in a path object
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   Status code
*
* History:
*
*   01/15/1999 ikkof
*       Created it.
*
\**************************************************************************/

GpStatus
DpPath::CloseFigures()
{
    ASSERT(IsValid());

    // Go through all path points.
    // Notice that the loop index starts from 1 below.

    INT i, count = GetPointCount();
    BYTE* types = Types.GetDataBuffer();

    for (i=1; i < count; i++)
    {
        if (types[i] == PathPointTypeStart)
            types[i-1] |= PathPointTypeCloseSubpath;
    }

    if (count > 1)
        types[count-1] |= PathPointTypeCloseSubpath;

    StartFigure();
    return Ok;
}


/**************************************************************************\
*
* Function Description:
*
*   Calculates the bounds of a path
*
* Arguments:
*
*   [OUT] bounds - Specify the place to stick the bounds
*   [IN] matrix - Matrix used to transform the bounds
*   [IN] pen - the pen data.
*   [IN] dpiX, dpiY - the resolution of x and y directions.
*
* Return Value:
*
*   NONE
*
* History:
*
*   12/08/1998 andrewgo
*       Created it.
*
\**************************************************************************/

GpStatus
GpPath::GetBounds(
    GpRect *bounds,
    const GpMatrix *matrix,
    const DpPen* pen,
    REAL dpiX,
    REAL dpiY
    ) const
{
    if(bounds == NULL)
        return InvalidParameter;

    GpRectF boundsF;

    FPUStateSaver fpuState;

    GpStatus status = GetBounds(&boundsF, matrix, pen, dpiX, dpiY);

    if(status == Ok)
        status = BoundsFToRect(&boundsF, bounds);

    return status;
}

VOID
GpPath::CalcCacheBounds() const
{

    INT count = GetPointCount();
    GpPointF *point = Points.GetDataBuffer();

    if(count <= 1)
    {
        ResetCacheBounds();
        return;
    }

    REAL left, right, top, bottom;

    left   = point->X;
    right  = left;
    top    = point->Y;
    bottom = top;

    INT i;
    for (i = 1, point++; i < count; i++, point++)
    {
        if (point->X < left)
        {
            left = point->X;
        }
        else if (point->X > right)
        {
            right = point->X;
        }

        if (point->Y < top)
        {
            top = point->Y;
        }
        else if (point->Y > bottom)
        {
            bottom = point->Y;
        }
    }
    CacheBounds.X = left;
    CacheBounds.Width = right - left;
    CacheBounds.Y = top;
    CacheBounds.Height = bottom - top;

    if(CacheBounds.Width < POINTF_EPSILON && CacheBounds.Height < POINTF_EPSILON)
    {
        ResetCacheBounds();
        return;
    }

    CacheFlags = kCacheBoundsValid;

}


/**************************************************************************\
*
* Function Description:
*
*   Calculates the sharpest angle in a path.
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   NONE
*
* History:
*
*   10/04/2000 asecchia
*       Created it.
*
* Remarks:
*
*   This is an expensive function, if it's ever used in a performance 
*   critical scenario it should be recoded to use the dot product of the
*   segments and perform the angle comparison in the cosine domain.
*   The cost of normalizing the vectors should be cheaper than the 
*   atan algorithm used below.
*
*
\**************************************************************************/

VOID
GpPath::CalcSharpestAngle() const
{
    if(CacheFlags & kSharpestAngleValid)
    {
        return;
    }

    UpdateCacheBounds();

    // Walk the path and find the smallest angle between two 
    // adjacent segments.
    
    GpPathPointIterator pIter(
        (GpPointF*)GetPathPoints(),
        (BYTE*)GetPathTypes(),
        GetPointCount()
    );
    
    GpSubpathIterator pSubpath(&pIter);
    
    GpPointF *points;
    BOOL isClosed;
    
    GpPointF *p0, *p1;
    GpVector2D v;
    REAL lastAngle;
    REAL currAngle;
    REAL minAngle = 2*PI;
    REAL tempAngle;
    bool first = true;
    INT iter, i;
    
    
    while(!pSubpath.IsDone())
    {
        // Compute the length of the subpath.
        
        INT startIndex = pSubpath.CurrentIndex();
        points = pSubpath.CurrentItem();
        pSubpath.Next();
        INT elementCount = pSubpath.CurrentIndex() - startIndex;
        
        // Work out if it's a closed subpath.
        // Leave the subpath iterator in the same state.
        
        pIter.Prev();
        isClosed = (*(pIter.CurrentType()) & PathPointTypeCloseSubpath) ==
            PathPointTypeCloseSubpath;
        pIter.Next();
        
        // Create a GpPointF iterator.
        
        GpArrayIterator<GpPointF> iSubpath(points, elementCount);
        GpCircularIterator<GpPointF> iCirc(&iSubpath);
        
        // Initialize the first point.
        
        p0 = iCirc.CurrentItem();
        iCirc.Next();
        iter = elementCount;
        first = true;
        
        // include the endpoint wrap if it's closed
        
        if(isClosed)
        {
            iter += 2;
        }
        
        for(i = 1; i < iter; i++)
        {
            // Get the current point.
            
            p1 = iCirc.CurrentItem();
            
            // Translate to the origin and compute the angle between this line
            // and the x axis.
            // atan2 returns values in the -PI..PI range.
            
            v = (*p1)-(*p0);
            currAngle = (REAL)atan2(v.Y, v.X);

            // If we have enough data to do an angle computation, work it out.
            // We require two line segments to do a computation (3 end points).
            // If it's closed, we'll loop around the subpath past the beginning
            // again in order to get the right amount of points.
                       
            if( !first )
            {
                // reverse the direction of the last segment by adding PI and
                // compute the difference.
                
                tempAngle = lastAngle + PI;     // range 0 .. 2PI
                
                // Clamp back to the -PI..PI range
                
                if(tempAngle > PI)
                {
                    tempAngle -= 2*PI;
                }
                
                // Difference
                
                tempAngle = currAngle - tempAngle;
                
                // Clamp back to the -PI..PI range
                // Note that the extremes are tempAngle either -2PI or 2PI
                
                if(tempAngle > PI)
                {
                    tempAngle -= 2*PI;
                }
                
                if(tempAngle < -PI)
                {
                    tempAngle += 2*PI;
                }
                
                // new minimum angle?
                // We care about angle magnitude - not sign.
                
                if( minAngle > REALABS(tempAngle) )
                {
                    minAngle = REALABS(tempAngle);
                }
                
            }
            
            // iterate
            
            first = false;
            lastAngle = currAngle;
            iCirc.Next();
            p0 = p1;
        }
    }
    
    SharpestAngle = minAngle;
    CacheFlags |= kSharpestAngleValid;
}

GpStatus
GpPath::GetBounds(
    GpRectF *bounds,                // Resulting bounds in device-space
    const GpMatrix *matrix,
    const DpPen* pen,
    REAL dpiX,
    REAL dpiY
    ) const
{
    if(bounds == NULL)
        return InvalidParameter;

    ASSERT(IsValid());

    if ((dpiX <= 0) || (dpiY <= 0))
    {
        dpiX = Globals::DesktopDpiX;
        dpiY = Globals::DesktopDpiY;
    }

    INT count = GetPointCount();
    GpPointF *point = Points.GetDataBuffer();

    if ((count == 0) || (point == NULL))
    {
        bounds->X = 0;
        bounds->Y = 0;
        bounds->Width = 0;
        bounds->Height = 0;
    }
    else
    {
        REAL left, right, top, bottom;

        UpdateCacheBounds();

        left = CacheBounds.X;
        right = left + CacheBounds.Width;
        top = CacheBounds.Y;
        bottom = top + CacheBounds.Height;

        TransformBounds(matrix, left, top, right, bottom, bounds);

        if(pen)
        {
            BOOL needsJoinDelta = TRUE;

            if(count <= 2)
                needsJoinDelta = FALSE;

            GpPen* gpPen = GpPen::GetPen(pen);

            // takes into account the cap width AND the pen width - JBronsk
            REAL delta = gpPen->GetMaximumCapWidth(matrix, dpiX, dpiY);
 
            if(needsJoinDelta)
            {
                // Since the join might be a miter type, we need to provide the
                // sharpest angle in the path to see how big the join will be.
                // We have the method GetSharpestAngle() that figues this out.
                // But, this is really expensive since you have to iterate over
                // all the points and do some trig. So, lets assume the worst
                // case, which is a really sharp angle (0 rad).
                const REAL sharpestAngle = 0.0f;
                REAL delta1 = gpPen->GetMaximumJoinWidth(
                            sharpestAngle, matrix, dpiX, dpiY);
                if(delta1 > delta)
                    delta = delta1;
            }

            // Only pad the bounds if there is something non-zero to pad
            if (bounds->Width > REAL_EPSILON ||
                bounds->Height > REAL_EPSILON)
            {
                bounds->X -= delta;
                bounds->Y -= delta;
                bounds->Width += 2*delta;
                bounds->Height += 2*delta;
            }

        }
    }

    return Ok;
}


/*************************************************\
* AddGlyphPath
* History:
*
*   Sept/23/1999 Xudong Wu [tessiew]
*       Created it.
*
\************************************************/
GpStatus
GpPath::AddGlyphPath(
    GpGlyphPath* glyphPath,
    REAL x,
    REAL y,
    const GpMatrix * matrix
)
{
    ASSERT(IsValid());
    ASSERT(glyphPath->IsValid());

    if (!IsValid() || !glyphPath->IsValid())
        return InvalidParameter;

    INT count = glyphPath->pointCount;

    if (count == 0)  // nothing to add
        return Ok;

    GpPointF* points = (GpPointF*) glyphPath->points;
    BYTE* types = glyphPath->types;

    if (glyphPath->hasBezier)
        HasBezier = TRUE;

    INT origCount = GetPointCount();
    GpPointF* pointbuf = Points.AddMultiple(count);
    BYTE* typebuf = Types.AddMultiple(count);

    if (!pointbuf || !typebuf)
    {
        Points.SetCount(origCount);
        Types.SetCount(origCount);

        return OutOfMemory;
    }

    // apply the font xform

    for (INT i = 0; i < count; i++)
    {
        pointbuf[i] = points[i];
        if (matrix)
            matrix->Transform(pointbuf + i);
        pointbuf[i].X += x;
        pointbuf[i].Y += y;
    }

    GpMemcpy(typebuf, types, count*sizeof(BYTE));
    SubpathCount += glyphPath->curveCount;
    UpdateUid();
    InvalidateCache();

    return Ok;
}


/*************************************************\
* AddString()
* History:
*
*   19th Oct 199  dbrown  created
*
\************************************************/
GpStatus
GpPath::AddString(
    const WCHAR          *string,
    INT                   length,
    const GpFontFamily   *family,
    INT                   style,
    REAL                  emSize,
    const RectF          *layoutRect,
    const GpStringFormat *format
)
{
    FPUStateSaver fpuState; // Guarantee initialised FP context
    ASSERT(string && family && layoutRect);

    GpStatus      status;
    GpTextImager *imager;

    status = newTextImager(
        string,
        length,
        layoutRect->Width,
        layoutRect->Height,
        family,
        style,
        emSize,
        format,
        NULL,
        &imager,
        TRUE        // Allow use of simple text imager
    );

    if (status != Ok)
    {
        return status;
    }

    status = imager->AddToPath(this, &PointF(layoutRect->X, layoutRect->Y));
    delete imager;
    UpdateUid();
    InvalidateCache();
    return status;
}


// !!! why not convert to a DpRegion and convert it to a path the same way
// as the constructor that takes a DpRegion?
GpPath::GpPath(HRGN hRgn)
{
    ASSERT((hRgn != NULL) && (GetObjectTypeInternal(hRgn) == OBJ_REGION));

    InitDefaultState(FillModeWinding);

    ASSERT(IsValid());

    BYTE stackBuffer[1024];

    // If our stack buffer is big enough, get the clipping contents
    // in one gulp:

    RGNDATA *regionBuffer = (RGNDATA*)&stackBuffer[0];
    INT newSize = ::GetRegionData(hRgn, sizeof(stackBuffer), regionBuffer);

    // The spec says that  GetRegionData returns '1' in the event of
    // success, but NT returns the actual number of bytes written if
    // successful, and returns '0' if the buffer wasn't large enough:

    if ((newSize < 1) || (newSize > sizeof(stackBuffer)))
    {
        // Our stack buffer wasn't big enough.  Figure out the required
        // size:

        newSize = ::GetRegionData(hRgn, 0, NULL);
        if (newSize > 1)
        {
            regionBuffer = (RGNDATA*)GpMalloc(newSize);
            if (regionBuffer == NULL)
            {
                SetValid(FALSE);
                return;
            }

            // Initialize to a decent result in the unlikely event of
            // failure of GetRegionData:

            regionBuffer->rdh.nCount = 0;

            ::GetRegionData(hRgn, newSize, regionBuffer);
        }
    }

    // Add the rects from the region to the path

    if(regionBuffer->rdh.nCount > 0)
    {
        if (this->AddRects((RECT*)&(regionBuffer->Buffer[0]),
                           regionBuffer->rdh.nCount) != Ok)
        {
            SetValid(FALSE);
        }
    }

    // Free the temporary buffer if one was allocated:

    if (regionBuffer != (RGNDATA*) &stackBuffer[0])
    {
        GpFree(regionBuffer);
    }
}

// create a path from a GDI+ region
GpPath::GpPath(
    const DpRegion*     region
    )
{
    InitDefaultState(FillModeAlternate);

    if (region == NULL)
    {
        return;
    }

    RegionToPath    convertRegion;
    DynPointArray   pointsArray;

    if (convertRegion.ConvertRegionToPath(region, pointsArray, Types))
    {
        int             count;
        int             i;
        GpPointF *      realPoints;
        GpPoint *       points;

        count  = Types.GetCount();

        if ((count <= 0) || (pointsArray.GetCount() != count) ||
            (!ValidatePathTypes(Types.GetDataBuffer(), count, &SubpathCount, &HasBezier)))
        {
            goto NotValid;
        }
        // else it is valid

        // add all the space for the count in the Points up front
        realPoints = Points.AddMultiple(count);
        if (realPoints == NULL)
        {
            goto NotValid;
        }

        // add the points, converting from int to real
        points = pointsArray.GetDataBuffer();
        i = 0;
        do
        {
            realPoints[i].X = (REAL)points[i].X;
            realPoints[i].Y = (REAL)points[i].Y;
        } while (++i < count);

        SetValid(TRUE);

        // Make sure the first point is the start type.
        ASSERT(Types[0] == PathPointTypeStart);

        return;
    }

NotValid:
    WARNING(("Failed to convert a region to a path"));
    this->Reset();
    SetValid(FALSE);
}


/**************************************************************************\
*
* Function Description:
*
*   Returns a const pointer to the internal SubpathInfoCache. This structure
*   holds the data representing the position and size of each subpath in 
*   the path data structures.
*
* History:
*
*   10/20/2000 asecchia
*       Created.
*
\**************************************************************************/

DynArray<GpPath::SubpathInfo> *GpPath::GetSubpathInformation() const
{
    if((CacheFlags & kSubpathInfoValid) == 0)
    {
        ComputeSubpathInformationCache();
        ASSERT((CacheFlags & kSubpathInfoValid) == kSubpathInfoValid)
    }
    
    return &SubpathInfoCache;
}


/**************************************************************************\
*
* Function Description:
*
*   Computes the Subpath information cache and marks it as valid.
*   This code walks the entire path and stores the start and count for
*   each subpath. It also notes if the subpath is closed or open.
*
* History:
*
*   10/20/2000 asecchia
*       Created.
*
\**************************************************************************/
    
VOID GpPath::ComputeSubpathInformationCache() const
{
    // Get the path data:
    
    GpPointF *points = Points.GetDataBuffer();
    BYTE *types = Types.GetDataBuffer();
    INT count = Points.GetCount();

    // Clear out any old cached subpath state.
    
    SubpathInfoCache.Reset();

    INT i = 0;  // current position in the path.
    INT c = 0;  // current count of the current subpath.

    // <= so that we can implicitly handle the last subpath without
    // duplicating the code for the inner loop.
    
    while(i <= count)
    {
        // i==count means we hit the end - and potentially need to look at
        // the last subpath. Otherwise look at the most recent subpath if 
        // we find a new start marker.
        
        if( ((i==count) || IsStartType(types[i])) && (i != 0))
        {
            // Found a subpath.
            
            SubpathInfo subpathInfo;
            
            subpathInfo.StartIndex = i-c;
            subpathInfo.Count = c;
            subpathInfo.IsClosed = IsClosedType(types[i-1]);
            
            SubpathInfoCache.Add(subpathInfo);
            
            // We're actually on the first point of the next subpath.
            // (or we're about to terminate the loop)
            
            c = 1;
        } 
        else
        {
            c++;
        }
        i++;
    }
    
    // Mark the subpath information cache as valid.
    
    CacheFlags |= kSubpathInfoValid;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\entry\pathselfintersectremover.hpp ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   Path Self Intersection Remover.
*
* Abstract:
*
*   Classes and functions used to remove self intersections in paths.
*   Given a path, it produces one or more polygons which can be used to 
*   draw a widened path that is safe to use alternate fill mode with.
*   
* Notes:
* 
*   Modified from Office code from John Bowler (at least that is what
*   ericvan told me). Apparently owned by some 'KasiaK', but no idea
*   who that is. (He is apparently retired)
*   CAUTION: Not thoroughly tested yet for arbitrary paths.
*
*   API:
*     Init(estimatedNumPts);
*     AddPolygon(pathPts, numPts);
*     RemoveSelfIntersects();
*     GetNewPoints(newPts, polyCounts, numPolys, numTotalPts);
*
* Created:
*
*   06/06/1999 t-wehunt
*
\**************************************************************************/

#ifndef _PATH_INTERSECT_REMOVER_H
#define _PATH_INTERSECT_REMOVER_H



extern REAL FP_INF;

// Forward declarations
class PathSelfIntersectRemover;
class Edge;

// Comparison function for DynSortArray
typedef INT (*DynSortArrayCompareFunc)(
    PathSelfIntersectRemover*, 
    Edge*, 
    Edge*
);



/*****************************************************************************
 Subtract two points
*****************************************************************************/
inline GpPointF SubtractPoint(const GpPointF &pt1, const GpPointF &pt2)
{
   return GpPointF(pt1.X-pt2.X,pt1.Y-pt2.Y);
}

#ifdef USE_OBSOLETE_DYNSORTARRAY

/*****************************************************************************
DynSortArray

Contains a new method that will perform a sorted insertion into the (already
sorted) array.
*****************************************************************************/

//
// NOTE: This class should be avoided by all performance critical code.
// The InsertAt method is O(n) and very easily leads to O(n^3) insert
// sorting algorithms.
//

template <class T>
class DynSortArray : public DynArray<T>
{
public:
    
    // Add a new element to the array at position index.
    // index'th element moves index + 1.
    // CAUTION! could cause a big performance hit if the array is large!
    
    GpStatus InsertAt(INT index, const T& newItem)
    {
        return DynArrayImpl::AddMultipleAt(sizeof(T), index, 1, &newItem);
    }
    
    // Insert multiple items starting at index'th element.
    // index'th element moves index + n, etc...
    // CAUTION! could cause a big performance hit if the array is large!

    GpStatus AddMultipleAt(INT index, const T* newItems, INT n)
    {
        return DynArrayImpl::AddMultipleAt(sizeof(T), index, n, newItems);
    }
    
    // Another variation of AddMultipleAt above.
    //
    // In this case, the data for the new elements are
    // not available. Instead, we'll do the following:
    //  (1) shift the old data over just as AddMultipleAt
    //  (2) reserve the space for additional elements
    //  (3) increase the Count by the number of additional elements
    //  (4) return a pointer to the first new elements
    // CAUTION! could cause a big performance hit if the array is large!

    T *AddMultipleAt(INT index, INT n)
    {
        return static_cast<T *>(DynArrayImpl::AddMultipleAt(sizeof(T), index, n));
    }

    // Deletes n items from the array starting at the index'th position.
    // CAUTION! could cause a big performance hit if the array is large!

    GpStatus DeleteMultipleAt(INT index, INT n)
    {
        return DynArrayImpl::DeleteMultipleAt(sizeof(T), index, n);
    }

    // Deletes one item from the array at the index'th position.
    // CAUTION! could cause a big performance hit if the array is large!
    
    GpStatus DeleteAt(INT index)
    {
        return DynArrayImpl::DeleteMultipleAt(sizeof(T), index, 1);
    }

    GpStatus InsertSorted(
        T &newItem, 
        DynSortArrayCompareFunc compareFunc, 
        VOID *userData
    );
};

#endif

/*****************************************************************************
Edge

Edge represents an edge of a polygon. It stores its end points
as indices to the array of points.

*****************************************************************************/

// represents the terminator of the list.

#define LIST_END -1


class Edge
{
    private:
        PathSelfIntersectRemover *Parent;
        Edge() {}
        
    public:

    BOOL CloseReal(const REAL val1, const REAL val2);

    VOID SetParent(PathSelfIntersectRemover *aParent)
    {
        Parent = aParent;
    }

    Edge(PathSelfIntersectRemover *aParent)
    {
        SetParent(aParent);
    }

    // Next pointer. This is an index into the array for the next element
    // in the Edge list. -1 indicates NULL.
    
    INT Next;
    
    // Begin and End are the indecies to the array of points.  The edge
    // has a direction, which is important when we determine winding numbers.
    // Edge goes from Begin to End.
    
    INT Begin;
    INT End;

    // When we look for intersections of edges, we need to sort them based on
    // the smallest x, therefore we want to store the edge, so that SortBegin
    // refers always to the "smaller" end point of this edge.
    INT SortBegin;
    INT SortEnd;

    // This is the y value at which the edge is currently crossed by a 
    // scan line
    REAL YCur;

    // Original slope of the edge.  We want to keep it around even if the
    // is broken up into small pieces and the end points change.
    // We store the slope as the original begin and end points.
    INT OrigBegin;
    INT OrigEnd;

    // Normalize the edge - ie. update SortBegin and SortEnd.
    VOID Normalize();

    // Return TRUE if the edge is vertical.
    BOOL IsVertical();

    VOID MarkOutside();
};


/*****************************************************************************
EdgeArray

Array of line segments.
*****************************************************************************/
typedef DynSortArray<Edge> EdgeArray;

/*****************************************************************************
PointListNode

Structure used to maintain the order of points and some additional
information about them.  It is used to create a linked list in an array and
then to construct final paths.
Notice the designation List for this structure instead of array.
*****************************************************************************/

struct PointListNode
{
    INT Prev;      // Previous record
    INT Next;      // Next record

    // Duplicate point - For example, if two edges intersect and they are
    // broken up, there are two points needed in order to maintain the
    // correct edge directions for the path.  These two points are identical,
    // so we will call them duplicates.  Each of them stores an index to the
    // other one.  Note that it doesn't mean that allpoints with the same
    // x and y values are duplicates.  This is only 1-1 correspondence for
    // points created from intersections.
    INT Dup;

    // Is this point inside or outside.  Actually, this applies to the edge
    // coming out of this point.
    BOOL Inside;

    // Has this point been consumed during the final creation of resulting
    // paths.  Initially set to FALSE and changed to TRUE when the point is
    // copied to the resulting array.
    BOOL Used;
};

/*****************************************************************************
PathSelfIntersectRemover

Path Self Intersection Remover Class.

It is given input polygons and returns polygons with all self intersections
removed.  The number of returned polygons can be 1, 2 or more.
See comments for the methods for more details on input and output arguments.

API:
  Init(estimatedNumPts);
  AddPolygon(pathPts, numPts);
  RemoveSelfIntersects();
  GetNewPoints(newPts, polyCounts, numPolys, numTotalPts);
*****************************************************************************/

class PathSelfIntersectRemover
{
public:

    PathSelfIntersectRemover() :
        NumPts(0),
        PathPts(),
        PtList(),
        ActiveVertEdges(),
        ResultPts(),
        CanAddPts(TRUE),
        AddToActive1(NULL),
        AddToActive2(NULL),
        AddToActive3(NULL)
    {
        AddToActive1.SetParent(this);
        AddToActive2.SetParent(this);
        AddToActive3.SetParent(this);
        IntersectsWereRemoved = FALSE;
    }

    ~PathSelfIntersectRemover() {}
    
    // Initialize PathSelfIntersectRemover for the given number of points, 
    // numPts. numPts can be an approximate number of points that will be 
    // added to the PathSelfIntersectRemover class for correction. Init 
    // allocates memory for DynArrays.
    
    GpStatus Init(INT numPts);

    // Add one polygon to the class.
    
    GpStatus AddPolygon(const GpPointF *ptrPt, INT numPtsToAdd);

    // Correct the path.
    
    GpStatus RemoveSelfIntersects();

    // Returns the new path.  New path contains of 1 or more subpaths
    // The subpaths are stored as a list of points and a list of points 
    // per polygon.
    
    GpStatus GetNewPoints(DynPointFArray *pts, DynIntArray *polyCounts);

    BOOL PathWasModified() {return IntersectsWereRemoved;}

private:

    // QuickSort a list of edges from First (F) to Last (L) inclusive.
    // This function uses the CompareLine comparison function to determine
    // the ordering.
    
    void QuickSortEdges(Edge *F, Edge *L);

    // This function moves edges from the list pointed to by pInactiveIndex
    // into the list pointed to by pActiveIndex. The sort order for the Active
    // list is determined by the 'compare' function. Edges are selected from the 
    // Inactive list based on xCurrent.
    
    void InsertNewEdges(
        INT *pActiveIndex,     // IN/OUT
        INT *pInactiveIndex,   // IN/OUT
        REAL xCurrent,
        DynSortArrayCompareFunc compare
    );

    // Delete Edge at index from the list pointed to by pListHead. The edge is 
    // orphaned (Next points to LIST_END). This function returns false if 
    // index is not present in the list.
    
    bool DeleteEdgeFromList(INT *pListHead, INT index);
    
    // Insert Edge at index into the list pointed to by pListHead. The sort 
    // order is determined by the 'compare' function. The index'th element 
    // must be an orphan (not a member of any list) - this 
    // function ASSERTs this condition.
    
    void InsertEdgeIntoList(
        INT *pListHead, 
        INT index, 
        DynSortArrayCompareFunc compare
    );
    
    // Remove edges from active edge array.
    
    void ClearActiveListExclusiveX();
    void ClearActiveListInclusiveX();

    GpPointF *GetInactivePoint(INT *pInactiveIndex, bool begin);
    
    // Return true if two numbers are very close.  This depends on the size
    // of the largest number to be compared, which is set in InsertPoints().
    // If no points are inserted, the comparison defaults to using REAL_EPSILON
    
    inline BOOL CloseReal(const REAL val1, const REAL val2)
    {
        return (REALABS(val1-val2) < REAL_EPSILON);
    }

    // Return true if two points are very close
    inline BOOL ClosePt(const GpPointF &pt1, const GpPointF &pt2)
    {
        return (CloseReal(pt1.X, pt2.X) &&
                CloseReal(pt1.Y, pt2.Y));
    }

    
    // Find all intersections between all line segments.  Returns FALSE if
    //  out of memory 
    BOOL FindIntersects();

    // TODO: Since we have a different function for each phase, we don't need
    //       plntFrom any more in both of these methods
    // Add new edges, which are active for the new scan line (x value stored
    //  in xCur.  ptrFrom - array to get the edges.
    //  Returns FALSE on out of memory.
    void AddActiveForX(INT *inactiveHead);

    // Update duplicate points: the two points overlap, connect their lists
    //  of duplicates.
    VOID UpdateDups(INT pt1, INT pt2);

    BOOL IsLinked(INT loop, INT inew);

    // Add new edges, which are active for the new scan line (x value stored
    //  in xCur.  This one is used in the second phase only.
    //  Returns FALSE on out of memory.
    void AddActiveForXScan(INT *inactiveHead);


    // Find all intersections for the current X value.  Intersection points
    //  will be inserted into the Edges array and information about their
    //  order into PtList.
    // Returns FALSE on out of memory.
    BOOL FindIntersectsForX();

    // Calculate new current y values for edges in the active edge array.
    //  For vertical edges, it will pick the maximum y.
    VOID RecalcActiveYCur();

    // Eliminate edges/points which are inside.  In other words, performes 
    //  a line sweep algorithm (similar to scan conversion) and calculates 
    //  winding number on both sides of every edge.  If the winding is 0 
    //  (outside the path) on any sides of the edge, the edge is marked as 
    //  an outside edge.  All other edges are marked as inside.  Edges are 
    //  marked through their begin point in array PtList. 
    // Returns FALSE on out of memory.
    BOOL EliminatePoints(VOID);

    // Finds the x value of the closest end point (in x) - the next scan line.
    //  Depending on the phase of the algorithm, it needs to look at edges in
    //  different arrays.  The new value is stored in xCur.
    //  Returns FALSE if there are no more points to look at - we are done.
    BOOL ClosestActive(INT arrayIndex);

    // Scan through all active edges during the phase of edge elimination.
    //  Calculates winding number to the left and to the right of the current
    //  x value - xCur.  Whenever finds an edge wich has 0 on one side, marks
    //  it as an outside edge.
    BOOL ScanActive();

    // Breaks edge ptrEdge. We have found intersection point intersectPt, which is
    //  guranteed to be somewhere on the line segment (not an end point).
    //  The 'left' part of the edge will either remain in the active edges
    //  or will be removed (only if the intersection point has the current
    //  x value.  In the latter case, the right edge segment will need to be
    //  inserted to active edges, otherwise (the former case) it will go
    //  to Pass1Edges.  If it needs to go to active edges, Breakedge cannot
    //  insert it because it would disrupt the order of edges there before
    //  both edges broken up are handled.  The caller would have to handle
    //  the insertion in such case.  Therefore, we return the new line
    //  segment newEdge and a BOOL value specifying if the caller has to 
    //  insert the newEdge edge.
    // dupIndex is the index of the duplicate point created by this 
    //  intersection:
    //  When two edges intersect, we have to insert two points (identical)
    //  to maintain the same shape of the polygon.  These two points are
    //  called duplicates.
    //  Return FALSE on out of memory.
    BOOL BreakEdge(
        Edge *ptrEdge, 
        GpPointF *intersectPt, 
        Edge *newEdge, 
        INT dupIndex
        );

    BOOL BreakEdgeIn3(
        Edge *ptrEdge, 
        GpPointF *ptrPt1, 
        GpPointF *ptrPt2, 
        Edge *ptrNew1,
        Edge *ptrNew2, 
        INT dupIndex1, 
        INT dupIndex2
        );

    // Insert numEdges edges joining points stored in array Edges.  First 
    // point has index firstIndex.  There must be numEdges+1 points to 
    // create numEdges edges.
    GpStatus InsertEdges(INT firstIndex, INT numEdges);

    // Insert points information to relevant arrays.
    GpStatus InsertPoints(const GpPointF *pts, INT numPts);

    // Returns TRUE if lines ptrEdge1 and ptrEdge2 overlap.
    //  There are 4 ways in which edges can overlap and depending on the
    //  case, either none, one or both edges need to be broken up.  In some
    //  cases one edge may need to broken into 3 pieces.
    //  Return values:
    //    split1     - set to TRUE if ptrEdge1 needs to be split
    //    split2     - set to TRUE if ptrEdge2 needs to be split
    //    split3     - set to TRUE if an edge needs to be broken into 3 pieces
    //    intersect1     - intersection point (where edge needs to be split)
    //    intersect2     - second point (if edge needs to be broken in 3 pieces or
    //                 for the second edge if both edges need to broken up)
    //    dupIndex1  - index of the duplicate point to intersect1,
    //    dupIndex2  - index of the duplicate point to intersect2,
    BOOL Overlap(
        Edge *ptrEdge1, 
        Edge *ptrEdge2, 
        GpPointF *intersect1, 
        GpPointF *intersect2, 
        BOOL *split1,
        BOOL *split2, 
        BOOL *split3, 
        INT *dupIndex1, 
        INT *dupIndex2
        );

    // Method to find the intersection point between edges 
    //    ptrEdge1 and ptrEdge2.
    //    Returns one of the following values:
    //        DONOT_INTERS
    //        COMMON_POINT
    //        INTERSECT
    //        COLINEAR
    //    If the return value == INTERSECT, intersectPt contains the point of 
    //    intersection.
    INT IntersectEdge(Edge *ptrEdge1, Edge *ptrEdge2, GpPointF *intersectPt);

    // IsTIntersection returns TRUE if the intersection point intersectPt is
    //  the same as an end point of one of the edges ptrEdge1 and ptrEdge2.
    // If it is, splitFirst will be TRUE if the first edge needs to be broken
    //  up (intersectPt is an end point of ptrEdge2), FALSE if the second one 
    //  needs to be broken up.  intersectIndex contains the index of the end 
    //  point which is the same as the intersection point. 
    BOOL IsTIntersection(
        Edge *ptrEdge1, 
        Edge *ptrEdge2, 
        GpPointF *intersectPt, 
        BOOL *splitFirst, 
        INT *intersectIndex
        );

    // Returns TRUE if the two lines ptrEdge1 and ptrEdge2 share a common 
    // end point. If they do, commonPt will contain this point.
    BOOL IsCommonPt(Edge *ptrEdge1, Edge *ptrEdge2, GpPointF *commonPt);

    // After the process of eliminating edges and marking points as inside
    //  and outside, we need to go through the linked list of points and
    //  build paths from the edges which are outside.  CollectPath will
    //  collect one path starting from point with index firstIndex.
    //  CollectPath doesn't check if firstIndex is marked as Inside or Outside.
    //  CollectPath returns FALSE on out of memory 
    BOOL CollectPath(INT firstIndex);

    // Return TRUE if all points have been used (added to the resulting paths)
    //  or are inside.  If returns FALSE, returns the index to the next unused
    //  point 
    BOOL AllPointsUsed(INT *nextUnusedPt);

    // Marks vertical edges as oustide.
    VOID MarkVertOutside();

    // Remove all vertical edges from the vertical edge array, which do not
    //  overlap with the give y value 
    VOID RemoveVert(REAL y, BOOL inclusive);

    VOID RemoveVertAll();

    // Returns TRUE if edge ptrEdge doesn't belong to the y interval of edges
    //  stored in ActiveVertEdges.
    BOOL NewInterval(Edge *ptrEdge);

    // Delete edges from the active edge table;  Indecies of edges to delete
    //  are stored in EdgeToDelete1..3.  Deletes the highest index edge first.
    // Returns NULL if fails due to out of memory error.
    BOOL DeleteEdges();

    // Add new edges to the active edge table.  The edges are stored in
    //  AddToActive1..3.  FlgAdd1..3 specify if the given edge needs to
    //  be added or not.  Returns if fails due to out of memory.
    BOOL AddNewEdges();

    // Store the edge in PathSelfIntersectRemover for now, so that it can be later added 
    // to active edges.  Copies the edge, so ptrEdge doesn't need to be kept
    // after this method returns.
    VOID MarkToAdd(Edge *ptrEdge);

    // Store the edge index for later deletion
    VOID MarkToDelete(INT index);

    friend INT CompareYCurLine(
        PathSelfIntersectRemover *ptrCorrector, 
        Edge *ptrEdge1, 
        Edge *ptrEdge2
        );
    friend INT 
        CompareYScanCurLine(
        PathSelfIntersectRemover *ptrCorrector, 
        Edge *ptrEdge1, 
        Edge *ptrEdge2
        );
    friend INT CompareLine(
        PathSelfIntersectRemover *ptrCorrector, 
        Edge *ptrEdge1, 
        Edge *ptrEdge2);
    friend INT CompareVertLine(
        PathSelfIntersectRemover *ptrCorrector, 
        Edge *ptrEdge1, 
        Edge *ptrEdge2
        );
    friend Edge;

    INT NumPts;                     // Total #of points stored for corrections
    REAL XCur;                      // Current x value for the scan line
    DynArray<GpPointF> PathPts;     // array of points
    DynArray<GpPointF> ResultPts;   // array of points for the resulting paths
    DynArray<PointListNode> PtList; // array with order information for points
    
    DynArray<Edge> EdgeList;        // List holding all the edges.
    INT ActiveEdgeList;             // Head index for the Active Edges
    INT InactiveEdgeList;           // Head index for the inactive edges
    
    EdgeArray ActiveVertEdges;      //array with active vertical edges

    Edge AddToActive1; //lines which will need to be added to Active edges
    Edge AddToActive2; //these lines are created when edges are broken up
    Edge AddToActive3; //

    BOOL FlgAdd1;      //flags specifying which of the above three lines
    BOOL FlgAdd2;      //need to be active
    BOOL FlgAdd3;      //

    INT EdgesToDelete1;//indices of edges, which need to be deleted
    INT EdgesToDelete2;//from active, -1 for all three values means
    INT EdgesToDelete3;//that there are no edges to delete

    BOOL CanAddPts;     // Can we still add new points to the class,
                        // We can't after the correction process has started

    BOOL IntersectsWereRemoved;
};

/*****************************************************************************
Comparison functions used for array sorting.
*****************************************************************************/

/*---------------------------------------------------------------------------
Function used to compare lines when we sort them by x coordinate of the
Begin point (SortBegin - smaller x).
-------------------------------------------------------------KasiaK---------*/
INT CompareLine(
    PathSelfIntersectRemover *ptrCorrector, 
    Edge *ptrEdge1, 
    Edge *ptrEdge2
    );

/*---------------------------------------------------------------------------
Function used to compare vertical lines when we scan them.
-------------------------------------------------------------KasiaK---------*/
INT CompareVertLine(
    PathSelfIntersectRemover *ptrCorrector, 
    Edge *ptrEdge1, 
    Edge *ptrEdge2
    );

/*---------------------------------------------------------------------------
Function used to sort edges by current y value when we scan them in order to
find all intersections of line segments.  If y's are the same, sorts based
on slopes.
-------------------------------------------------------------KasiaK---------*/
INT CompareYCurLine(
    PathSelfIntersectRemover *ptrCorrector, 
    Edge *ptrEdge1, 
    Edge *ptrEdge2
    );

/*---------------------------------------------------------------------------
Same as CompareYCurLine, but if y-'s are the same, pots left edges before
right ones before looking at slopes.
-------------------------------------------------------------KasiaK---------*/
INT CompareYScanCurLine(
    PathSelfIntersectRemover *ptrCorrector, 
    Edge *ptrEdge1, 
    Edge *ptrEdge2
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\entry\path.hpp ===
/**************************************************************************\
*
* Copyright (c) 1998-1999  Microsoft Corporation
*
* Module Name:
*
*   path.hpp
*
* Abstract:
*
*   Path related declarations
*
* Revision History:
*
*   12/06/1998 davidx
*       Created it.
*
*   06/16/1999 t-wehunt
*       Added RemoveSelfIntersections().
*
\**************************************************************************/

#ifndef _PATH_HPP
#define _PATH_HPP

// This is used by the widener as an internal flag and as a deletion mask for
// the endcap placement code. These two usages do not overlap.

const INT PathPointTypeInternalUse  = 0x40;

/*
// PathPointType is defined in GdiplusEnums.h.
// Internally, we can use 0x40 for the internal use.

//--------------------------------------------------------------------------
// Path point types (only the lowest 8 bits are used.)
//  The lowest 3 bits are interpreted as point type
//  The higher 5 bits are reserved for flags.
//--------------------------------------------------------------------------

enum PathPointType
{
    PathPointTypeStart           = 0,    // move
    PathPointTypeLine            = 1,    // line
    PathPointTypeBezier          = 3,    // default Beizer (= cubic Bezier)
    PathPointTypePathTypeMask    = 0x07, // type mask (lowest 3 bits).
    PathPointTypeDashMode        = 0x10, // currently in dash mode.
    PathPointTypePathMarker      = 0x20, // a marker for the path.
    PathPointTypeCloseSubpath    = 0x80, // closed flag

    // Path types used for advanced path.

    PathPointTypeBezier2    = 2,    // quadratic Beizer
    PathPointTypeBezier3    = 3,    // cubic Bezier
    PathPointTypeBezier4    = 4,    // quartic (4th order) Beizer
    PathPointTypeBezier5    = 5,    // quintic (5th order) Bezier
    PathPointTypeBezier6    = 6     // hexaic (6th order) Bezier
};
*/

class GpGlyphPath;

inline BOOL IsStartType(BYTE type)
{
    return ((type & PathPointTypePathTypeMask) == 
               PathPointTypeStart);
}

inline BOOL IsClosedType(BYTE type)
{
    return ((type & PathPointTypeCloseSubpath) == 
               PathPointTypeCloseSubpath);
}

inline BOOL IsDashType(BYTE type)
{
    return ((type & PathPointTypeDashMode) == 
               PathPointTypeDashMode);
}


class GpPath : public DpPath
{
friend class GpGraphics;
friend class GpPathGradient;

public:

    // Path constructors

    GpPath(GpFillMode fillMode = FillModeAlternate)
    {
        InitDefaultState(fillMode);
        SetValid(TRUE);
    }

    GpPath(const GpPointF* points,
           const BYTE* types,
           INT count,
           GpFillMode fillMode = FillModeAlternate);

    GpPath(
        const GpPointF *points,
        INT count,
        GpPointF *stackPoints,
        BYTE *stackTypes,
        INT stackCount,
        GpFillMode fillMode = FillModeAlternate,
        DpPathFlags flags = PossiblyNonConvex
        );

    GpPath(HRGN hRgn);              // create a path from a GDI region handle
    GpPath(const DpRegion* region); // create a path from a GDI+ region

    // Get the lock object

    GpLockable *GetObjectLock()
    {
        return &Lockable;
    }

    GpPath* Clone() const
    {
        ASSERT(IsValid())

        GpPath* path = new GpPath(this);

        CheckValid(path);
        return path;
    }

    GpStatus Reset(GpFillMode fillMode = FillModeAlternate)
    {

        // !!! bhouse We should allow reseting invalid paths

        ASSERT(IsValid());

        InitDefaultState(fillMode);
        return Ok;
    }

    virtual GpStatus
    GetBounds(
        GpRect *bounds,
        const GpMatrix *matrix = NULL,
        const DpPen* pen = NULL,
        REAL dpiX = 0,
        REAL dpiY = 0
        ) const;

    virtual GpStatus
    GetBounds(
        GpRectF *bounds,
        const GpMatrix *matrix = NULL,
        const DpPen* pen = NULL,
        REAL dpiX = 0,
        REAL dpiY = 0
        ) const;

    REAL GetSharpestAngle() const
    {

        if(!(CacheFlags & kSharpestAngleValid))
            CalcSharpestAngle();

        return SharpestAngle;
    }

    // Set a marker at the current location.

    GpStatus SetMarker();

    // Clear all markers.

    GpStatus ClearMarkers();

    // Add lines to the path object

    GpStatus AddLine(const GpPointF& pt1, const GpPointF& pt2)
    {
        GpPointF points[2];

        points[0] = pt1;
        points[1] = pt2;

        return AddLines(points, 2);
    }

    GpStatus AddLine(REAL x1, REAL y1, REAL x2, REAL y2)
    {
        GpPointF points[2];

        points[0].X = x1;
        points[0].Y = y1;
        points[1].X = x2;
        points[1].Y = y2;

        return AddLines(points, 2);
    }

    GpStatus AddLines(const GpPointF* points, INT count);

    // Add an arc to the path object

    GpStatus AddArc(const GpRectF& rect, REAL startAngle, REAL sweepAngle);

    GpStatus AddArc(REAL x, REAL y, REAL width, REAL height,
                    REAL startAngle, REAL sweepAngle)
    {
        GpRectF rect(x, y, width, height);
        return AddArc(rect, startAngle, sweepAngle);
    }

    // Add Bezier curves to the path object

    GpStatus AddBezier(const GpPointF& pt1, const GpPointF& pt2,
                       const GpPointF& pt3, const GpPointF& pt4);
    GpStatus AddBezier(REAL x1, REAL y1, REAL x2, REAL y2,
                       REAL x3, REAL y3, REAL x4, REAL y4);
    GpStatus AddBeziers(const GpPointF* points, INT count);

    // Add cardinal splines to the path object

    GpStatus AddCurve(const GpPointF* points, INT count);
    GpStatus AddCurve(const GpPointF* points, INT count, REAL tension,
                      INT offset, INT numberOfSegments);
    GpStatus AddClosedCurve(const GpPointF* points, INT count);
    GpStatus AddClosedCurve(const GpPointF* points, INT count, REAL tension);

    // Add closed shapes to the path object

    GpStatus AddRects(const GpRectF* rects, INT count);
    GpStatus AddRects(const RECT* rects, INT count);
    GpStatus AddPolygon(const GpPointF* points, INT count);
    GpStatus AddEllipse(const GpRectF& rect);
    GpStatus AddPie(const GpRectF& rect, REAL startAngle, REAL sweepAngle);

    GpStatus AddRect(const GpRectF& rect)
    {
        return AddRects(&rect, 1);
    }

    GpStatus AddEllipse(REAL x, REAL y, REAL width, REAL height)
    {
        GpRectF rect(x, y, width, height);
        return AddEllipse(rect);
    }

    GpStatus AddPie(REAL x, REAL y, REAL width, REAL height,
                    REAL startAngle, REAL sweepAngle)
    {
        GpRectF rect(x, y, width, height);
        return AddPie(rect, startAngle, sweepAngle);
    }

    // Add a path to the path object

    GpStatus AddPath(const GpPointF* points, const BYTE* types, INT count,
                        BOOL connect);
    GpStatus AddPath(const GpPath* path, BOOL connect);

    // Reverse the direction of a path.

    GpStatus Reverse();

    GpStatus GetLastPoint(GpPointF* point);

    // used by font

    GpStatus MoveTo(const GpPointF point);
    GpStatus AddPoints(const GpPointF* points, ULONG count, PathPointType type);
    GpStatus AddGlyphPath(GpGlyphPath *glyphPath, REAL x, REAL y, const GpMatrix * matrix = 0);

    GpStatus AddString(
        const WCHAR          *string,
        INT                   length,
        const GpFontFamily   *family,
        INT                   style,
        REAL                  emSize,
        const RectF          *layoutRect,
        const GpStringFormat *format
    );

    // Get the flatten data.

    virtual GpStatus Flatten(
        DynByteArray *flattenTypes,
        DynPointFArray *flattenPoints,
        const GpMatrix *matrix = NULL,
        const REAL flatness = FlatnessDefault
    ) const;


    // Flatten this path.
    
    GpStatus Flatten(
        const GpMatrix *matrix = NULL,
        const REAL flatness = FlatnessDefault
    );

    // Get the morph and flatten data.

    GpStatus WarpAndFlatten(
        DynByteArray* flattenTypes,
        DynPointFArray* flattenPoints,
        const GpMatrix* matrix,
        const GpPointF* destPoint,
        INT count,
        const GpRectF& srcRect,
        WarpMode warpMode = WarpModePerspective
        );

    // Morph and flatten itself.

    GpStatus WarpAndFlattenSelf(
        GpMatrix* matrix,
        const GpPointF* destPoint,
        INT count,
        const GpRectF& srcRect,
        WarpMode warpMode = WarpModePerspective
        );                  // Morph to the flatten points.

    // Widen the path object

    GpPath*
    GetWidenedPath(
        const GpPen* pen,
        const GpMatrix* matrix = NULL,
        REAL flatness = FlatnessDefault
        ) const;

    GpStatus
    Widen(
        GpPen* pen,
        GpMatrix* matrix = NULL,
        REAL flatness = FlatnessDefault
    );

    // Get the flattened path.

    virtual const DpPath *
    GetFlattenedPath(
        const GpMatrix* matrix,
        DpEnumerationType type,
        const DpPen* pen = NULL
        ) const;

    // Dreate a dashed path. (override)

    GpPath*
    CreateDashedPath(
        const GpPen* pen,
        const GpMatrix* matrix,
        REAL dpiX,
        REAL dpiY,
        REAL dashScale = 1.0f,
        BOOL needDashCaps = TRUE
        ) const;

    GpPath*
    CreateDashedPath(
        const DpPen* pen,
        const GpMatrix* matrix,
        REAL dpiX,
        REAL dpiY,
        REAL dashScale = 1.0f,
        BOOL needDashCaps = TRUE
        ) const;

    // Get the open and closed portion of the current path.

    GpPath* GetOpenPath();
    GpPath* GetClosedPath();

    // Determine if the path is empty, i.e. with no points

    BOOL IsEmpty() const
    {
        return GetPointCount() == 0;
    }

    BOOL IsRectangle(
        const GpMatrix * matrix,
        GpRectF * transformedBounds = NULL
        ) const;

    // Determine if path consists of a single polygon/polyline.

    BOOL IsPolygon() const
    {
        return (SubpathCount == 1) && !HasBezier;
    }

    // Return true if the two objects represent identical paths

    BOOL IsEqual(const GpPath* path) const;

    // Transform the path by the specified matrix

    VOID Transform(const GpMatrix * matrix);

    VOID SetHasBezier(BOOL _hasBezier)  { HasBezier = _hasBezier; }

    // Hit testing

    GpStatus IsVisible(
        GpPointF* point,
        BOOL* isVisible,
        GpMatrix* matrix = NULL);

    GpStatus IsOutlineVisible(GpPointF* point, BOOL* isVisible, GpPen* pen,
                    GpMatrix* matrix = NULL, REAL dpiX = 0, REAL dpiY = 0);


    // DDI entry point handlers for DpPath

    static GpPath* GetPath(const DpPath* path)
    {
        return (GpPath*)(path);
    }

    static DpPath* DriverCreateWidenedPath(
        const DpPath* path,
        const DpPen* pen,
        DpContext* context,
        BOOL outline
    );
    
    static VOID DriverDeletePath(DpPath* path);

    static DpPath* DriverClonePath(DpPath* path);

    static VOID DriverTransformPath(DpPath* path, GpMatrix* matrix);

    // Compute the winding mode outline.
    
    GpStatus ComputeWindingModeOutline(
        const GpMatrix *matrix, 
        REAL flatness, 
        BOOL *wereIntersectsRemoved = NULL
    );
    
    // Used for a mark-sweep point deletion algorithm in the path.
    
    VOID EraseMarkedSegments();

    virtual DynArray<SubpathInfo> *GetSubpathInformation() const;

protected:

    VOID ComputeSubpathInformationCache() const;

    GpPath(const GpPath* path);

    GpPath *GetWidenedPathInternal(
        const DpPen *pen,
        const GpMatrix *matrix,
        REAL flatness = FlatnessDefault,
        BOOL insetPen = FALSE
    ) const;

protected:

    BYTE*
    AddPointHelper(
        const GpPointF* points,
        INT count,
        BOOL addClosedFigure
        );

    GpPath*
    GetOpenOrClosedPath(BOOL openPath);

    static GpPointF*
    ConvertSplineToBezierPoints(
        const GpPointF* points,
        INT count,
        INT offset,
        INT numberOfSegments,
        REAL tension,
        INT* bezierCount
        );

    static INT
    GetArcPoints(
        GpPointF* points,
        const GpRectF& rect,
        REAL startAngle,
        REAL sweepAngle
        );

    VOID InitDefaultState(GpFillMode fillMode);

    VOID ResetCacheBounds() const
    {
        CacheFlags = (kCacheBoundsValid | kSharpestAngleValid);
        SharpestAngle = 2;
        CacheBounds.X = 0;
        CacheBounds.Y = 0;
        CacheBounds.Width = 0;
        CacheBounds.Height = 0;
    }

    VOID InvalidateCache() const
    {
        CacheFlags = 0;
    }

    VOID UpdateCacheBounds() const
    {
        if(!(CacheFlags & kCacheBoundsValid))
            CalcCacheBounds();
    }

    VOID CalcCacheBounds() const;
    VOID CalcSharpestAngle() const;

    // Data Members:
    protected:

    GpLockable Lockable;    // object lock

    enum {
        kCacheBoundsValid = 1,
        kSharpestAngleValid = 2,
        kSubpathInfoValid = 4
    };

    mutable ULONG CacheFlags;
    mutable GpRectF CacheBounds;
    mutable REAL SharpestAngle;
    
    // Some small number of subpaths for our initial allocation should suffice
    // for most usage scenarios.
    
    mutable DynArrayIA<SubpathInfo, 3> SubpathInfoCache;
};

class GpPathIterator : public DpPathIterator
{
public:
    GpPathIterator(GpPath* path) : DpPathIterator(path)
    {
    }

    virtual INT GetCount()
    {
        if(IsValid())
            return Count;
        else
            return 0;
    }

    virtual INT GetSubpathCount()
    {
        if(IsValid())
            return SubpathCount;
        else
            return 0;
    }

    // This iterator is not used for the extended path.

    virtual BOOL IsValid() {return (DpPathIterator::IsValid() && !ExtendedPath);}

    // Get the lock object

    GpLockable *GetObjectLock()
    {
        return &Lockable;
    }

protected:

    GpLockable Lockable;
};

#endif // !_PATH_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\entry\pathselfintersectremover.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   Path Self Intersection Remover Class.
*
* Abstract:
*
*   Classes and functions used to remove self intersections in paths.
*   Given a path, it produces one or more polygons which can be used to 
*   draw a widened path that is safe to use alternate fill mode with.
*
* Notes:
* 
*   Modified from Office code frOm John Bowler (at least that is what
*   ericvan told me). Apparently owned by some 'KasiaK', but no idea
*   who that is. (He is apparently retired)
*   CAUTION: Not thoroughly tested yet for arbitrary paths.
*
*   API:
*     Init(EstimatedNumPts);
*     AddPolygon(pathPts, numPts);
*     RemoveSelfIntersects();
*     GetNewPoints(newPts, polyCounts, numPolys, numTotalPts);
*
* Created:
*
*   06/06/1999 t-wehunt
*
\**************************************************************************/

#include "precomp.hpp"

// Return values for IntersectEdge
#define DONOT_INTERS 0
#define COMMON_POINT 1
#define INTERSECT    2
#define COLINEAR     3

// Used to produce the IEEE floating-point representation of infinity.
// Note that a few compile warnings have to be turned off to stop
// warnings about constant arithmetic overflow.

#pragma warning (disable : 4056 4756)
#define FP_INF (FLT_MAX+FLT_MAX)

/**************************************************************************\
*
* Function Description:
*
*   Insert a new item into a sorted dynamic array, keeping it sorted.
*
* Arguments:
*
*  newItem     - new item to be inserted
*  compareFunc - comparison function to be used for insertion.
*  userData    - User-specified data for use by the compare func.
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   6/15/1999 t-wehunt
*
\**************************************************************************/

template <class T>
GpStatus 
DynSortArray<T>::InsertSorted(
    T &newItem, 
    DynSortArrayCompareFunc compareFunc,
    VOID *userData
    )
{
    // insert item into sorted position of list.
    T *cur;
    INT pos = 0;
    GpStatus status;

    cur = GetDataBuffer();

    {
        INT sgn = 1; 
        unsigned iMin = 0;
        unsigned iMid = 0;
        unsigned iEnd = GetCount();
        while (iMin != iEnd)
        {
           iMid = iMin + (iEnd-iMin)/2;
           //Assert(iMid != iMac);
           sgn = compareFunc(
               (PathSelfIntersectRemover*)userData,
               &GetDataBuffer()[iMid],
               &newItem
               );
           if (sgn == 0)
           {
              // newItem already in sorted list, return index.
              return Ok;
           }
           if (sgn < 0)   // x(iMid) < x(p)
              iMin = iMid+1;
           else
              iEnd = iMid;
        }

        pos = iMin;
    }

    status = InsertAt(pos,newItem);
    if (status != Ok)
    {
        return status;
    }

    cur = &GetDataBuffer()[pos];

    return Ok;
}

/****************************************************************************\
    Private helper functions
\****************************************************************************/

/**************************************************************************\
*
* Function Description:
*
*   Return the sign of an INT
*
* Arguments:
*
*  newItem     - new item to be inserted
*  compareFunc - comparison function to be used for insertion.
*  userData    - User-specified data for use by the compare func.
*
* Return Value:
*
*   1 if greater than zero
*   0 if equal to zero
*  -1 if less than zero
*
* Created:
*
*   6/15/1999 t-wehunt
*
\**************************************************************************/

inline INT SignReal(const REAL i) { return (i > 0) - (i < 0); }

/**************************************************************************\
*
* Function Description:
*
*   Insert an edge into a linked list. This assumes the edge is an 
*   orphaned edge (not connected in a current list). Use DeleteEdgeFromList
*   to orphan an edge if it's already in a list.
*
*   This uses a double indirection pointer to track the address of the 
*   Next pointer that points to the current element rather than actually
*   tracking the current element. This simplifies the code significantly.
*
* Created:
*
*   12/23/2000 asecchia
*
\**************************************************************************/

void PathSelfIntersectRemover::InsertEdgeIntoList(
    INT *pListHead,
    INT index,
    DynSortArrayCompareFunc compare
)
{
    ASSERT(EdgeList[index].Next == LIST_END);
    ASSERT(index >= 0);
    ASSERT(pListHead);
    
    INT *pIndex = pListHead;
    Edge *newEdge = &EdgeList[index];
    
    // Calculate the YCur for this edge.
    
    newEdge->YCur = PathPts[newEdge->SortBegin].Y;
    newEdge->SortBegin = newEdge->Begin;
    newEdge->SortEnd = newEdge->End;
    newEdge->Normalize();

    
    while(*pIndex != LIST_END)
    {
        if(compare(this, &EdgeList[*pIndex], newEdge) != -1)
        {
            // if we find the right spot, exit the search loop.
            
            break;
        }
    
        // keep looking...
        
        pIndex = &EdgeList[*pIndex].Next;
    }
    
    // Do the insertion
    
    newEdge->Next = *pIndex;
    *pIndex = index;
}


/**************************************************************************\
*
* Function Description:
*
*   Delete an edge from a linked list.
*   This uses a double indirection pointer to track the address of the 
*   Next pointer that points to the current element rather than actually
*   tracking the current element. This simplifies the code significantly.
*
*   Returns true if it found and deleted the edge, false otherwise.
*
* Created:
*
*   12/23/2000 asecchia
*
\**************************************************************************/

bool PathSelfIntersectRemover::DeleteEdgeFromList(
    INT *pListHead,
    INT index
)
{
    ASSERT(index >= 0);
    ASSERT(pListHead);
    
    INT *pIndex = pListHead;
    
    while(*pIndex != LIST_END)
    {
        if(*pIndex == index)
        {
            // found it.
            *pIndex = EdgeList[index].Next;   // point past the deleted item.
            EdgeList[index].Next = LIST_END;  // disconnect the deleted item.
            return true;
        }
        
        // keep looking...
        
        pIndex = &EdgeList[*pIndex].Next;
    }
    return false;
}

/**************************************************************************\
*
* Function Description:
*
*   Insert edges into the active edge list.
*   This function takes a sorted block of edges from the pInactiveIndex list
*   and inserts them sorted into the pActiveIndex list in linear time.
*   The block from the pInactiveIndex list is known to be contiguous.
*
*   Actually the source list and destination list are not sorted with the
*   same sorting comparison function and therefore we can't optimize based
*   on the known sort order of the destination. This is inefficient. Making
*   them use the same sort order and fixing the active edge traversal code
*   to compute the winding numbers would probably work better - it would
*   allow us an O(n) merge sort here.
*
* Created:
*
*   03/25/2000 andrewgo
*   12/17/2000 asecchia - copied from aarasterizer.cpp and modified for the
*                         PathSelfIntersectRemover. When we have the time 
*                         we should really merge these two pieces of code.                       
*
\**************************************************************************/

void PathSelfIntersectRemover::InsertNewEdges(
    INT *pActiveIndex,     // IN/OUT
    INT *pInactiveIndex,   // IN/OUT
    REAL xCurrent,
    DynSortArrayCompareFunc compare
    )
{
    ASSERT(pInactiveIndex);
    
    while(
        (*pInactiveIndex != LIST_END) &&
        ((PathPts[EdgeList[*pInactiveIndex].SortBegin].X < xCurrent) ||
         (CloseReal(xCurrent, PathPts[EdgeList[*pInactiveIndex].SortBegin].X))
        )) 
    {
        // this is an edge we should move.
        
        INT index = *pInactiveIndex;
        
        // delete this element from the inactive list.
        // this updates pInactiveIndex for the next iteration of the loop.
        
        *pInactiveIndex = EdgeList[*pInactiveIndex].Next;
        EdgeList[index].Next = LIST_END;

        // Insert into the active list from the current active position. 
                    
        InsertEdgeIntoList(pActiveIndex, index, compare);
    
        // Update the active list pointer.
        
        // Can't do this currently - our source and dest have different 
        // sort order. Were we sure that our source and destination were
        // sorted with the same comparison function, we could remember the
        // current position here and continue where we left off next time
        // round - this would change the complexity from O(n^2) to O(n).
        // Currently this is not critical path because it's used on the 
        // active edge list (small relative to the inactive list).
        
        //pActiveIndex = &EdgeList[index].Next;
    } 
}

/**************************************************************************\
*
* Function Description:
*
*  Normalize the edge - ie. update SortBegin and SortEnd.
*
*  All lines have sorted begin and end.  Begin.X is always X <= than End.X.
*  If they are equal, Begin.Y <= End.Y
*
* Arguments:
*
*   None
*
* Return Value:
*
*   None
*
* Created:
*
*   6/15/1999 t-wehunt
*
\**************************************************************************/

VOID Edge::Normalize()
{

    if (Parent->PathPts[Begin].X < Parent->PathPts[End].X)
    {
        return;
    }

    if ((Parent->PathPts[Begin].X == Parent->PathPts[End].X) &&
        (Parent->PathPts[Begin].Y <= Parent->PathPts[End].Y))
    {
        return;
    }

    // swap the points;
    SortBegin = End;
    SortEnd   = Begin;

    return;
}

/**************************************************************************\
*
* Function Description:
*
*   Return TRUE if the real numbers are close.  This uses the parent's 
*   comparison criteria.
*
* Arguments:
*
*   [IN] val1, val2 - REAL numbers to be compared for closeness
*
* Return Value:
*
*  TRUE or FALSE
*
* Created:
*
*   9/11/2000 peterost
*
\**************************************************************************/

inline BOOL Edge::CloseReal(const REAL val1, const REAL val2)
{
    return Parent->CloseReal(val1, val2);
}

/**************************************************************************\
*
* Function Description:
*
*   Return TRUE if the edge is vertical.
*
* Arguments:
*
*   None
*
* Return Value:
*
*  TRUE or FALSE
*
* Created:
*
*   6/15/1999 t-wehunt
*
\**************************************************************************/

BOOL Edge::IsVertical()
{
    return (CloseReal(Parent->PathPts[Begin].X,
                      Parent->PathPts[End].X));
}

/**************************************************************************\
*
* Function Description:
*
*  Mark the edge as outside
*
* Arguments:
*
*   None
*
* Return Value:
*
*
* Created:
*
*   6/15/1999 t-wehunt
*
\**************************************************************************/

VOID Edge::MarkOutside()
{
    PointListNode *ptNode = NULL;
    ptNode = &Parent->PtList[Begin];
    ptNode->Inside = FALSE;
}

/**************************************************************************\
*
* Function Description:
*
*   Initialize PathSelfIntersectRemover with for the given number of path points.  The 
*   number of points doesn't have to be exact, it just initializes arrays 
*   to avoid reallocation later.
*
* Arguments:
*
*   numPts - number of points that will be added to the path.
*
* Return Value:
*
*   GpStatus.
*
* Created:
*
*   6/15/1999 t-wehunt
*
\**************************************************************************/

GpStatus PathSelfIntersectRemover::Init(INT numPts)
{
    BOOL failed=FALSE;
    GpStatus status;
    
    // !!!: Decide what the initial number of elements should be.
    //      In general, we usually will have one extra intersection
    //      per vertex in the inset path. - KasiaK

    // Initialize array with points
    failed |= PathPts.ReserveSpace(numPts+1) != Ok;
    
   // Initialize array with order information
    failed |= PtList.ReserveSpace(2*numPts) != Ok;

    failed |= EdgeList.ReserveSpace(2*numPts) != Ok;
    
    ActiveEdgeList = LIST_END;
    InactiveEdgeList = LIST_END;

    if (failed) 
    {
        return OutOfMemory;   
    }
    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   Add a single polygon to the PathSelfIntersectRemover class.
*   You cannot AddPolygon() after calling RemoveSelfIntersects().
*
* Arguments:
*
*   ptrPts      - points to add.
*   numPtsToAdd - number of points to add.
*
* Return Value:
*
*   GpStatus.  
*
* Created:
*
*   6/15/1999 t-wehunt
*
\**************************************************************************/

GpStatus 
PathSelfIntersectRemover::AddPolygon(
    const GpPointF *ptrPts,
    INT numPtsToAdd
    )
{
    // Cannot add points after fixing path.
    
    ASSERT(CanAddPts);
    ASSERT(ptrPts != NULL);
    
    if (numPtsToAdd < 2) 
    {
        return Ok;
    }
        
    GpStatus status;
    
    // Make sure there is enough room in the arrays:
    
    status = PathPts.ReserveSpace(numPtsToAdd+1);
    
    if (status != Ok)
    {
        return status;
    }
    
    INT oldNumPts = NumPts;
    if (InsertPoints(ptrPts, numPtsToAdd)          != Ok ||
        InsertEdges(oldNumPts, NumPts-oldNumPts-1) != Ok)
    {
        return GenericError;
    }
    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*  Insert points information to relevant arrays. 
*
* Arguments:
*
*   pts - points to add to the class.
*   numPts - number of points we want to add.
*
* Return Value:
*
*   GpStatus.
*
* Created:
*
*   6/15/1999 t-wehunt
*
\**************************************************************************/

GpStatus 
PathSelfIntersectRemover::InsertPoints(
    const GpPointF *pts,
    INT numPts
    )
{
    INT FirstIndex = NumPts;
    PointListNode ptNode;
    GpPointF pt(0,0);

    GpStatus status;

    // We don't want to add 0-length edges
    // Also, we don't want to add very thin spikes, for example
    // when pts[n] == pts[n+2] (or almost the same.  We will just
    // skip pts[n+1] and pts[n+2].
    pt = pts[0];
    if ((status = PathPts.Add(pt)) != Ok)
    {
        return status;
    }
    NumPts++;
    for (INT i = 1; i < numPts; i++)
    {
        if (!IsClosePointF(pts[i], pts[i-1]))
        {
            if ((status = PathPts.Add(pts[i])) != Ok)
            {
                return status;
            }
        
            NumPts++;
        }
    }

    // Add the first point to close the path
    if (!IsClosePointF(pts[0], pts[numPts-1]))
    {
        pt = pts[0];
        if ((status = PathPts.Add(pt)) != Ok)
        {
            return status;
        }
        NumPts++;
    }
    
    // If all the points were equal we hit this point with NumPts set to 1
    // which is a degenerate polygon.
    // Make sure we handle this correctly.
    
    if(NumPts < 2)
    {
        ONCE(WARNING(("Degenerate polygon in InsertPoints")));
        PathPts.SetCount(0);
        NumPts = 0;
        return Ok;
    }

    // Initialize the linked list;

    // If this is not the first set of points to be added, update
    // the next ptr in the last element of the existing list


    if (FirstIndex != 0 && PtList.GetCount() > 0)
    {
        PtList.Last().Next = FirstIndex;
    }

    // index 0:
    ptNode.Prev   = FirstIndex-1;  // -1 means NULL;
    if (NumPts == FirstIndex+1) // only one point is being added
    {
        ptNode.Next = -1;
        ptNode.Dup = -1;  // if we added one point, there is no dup
    }
    else
    {
        ptNode.Next = FirstIndex+1;
        ptNode.Dup = NumPts-1;  // the first point is same as closing point
    }
    ptNode.Inside = TRUE;
    ptNode.Used = FALSE;
    if ((status = PtList.Add(ptNode)) != Ok)
    {
        return status;
    }

    //indecies 1..NumPts-1
    INT ptIndex;
    for (ptIndex = FirstIndex+1; ptIndex < NumPts-1; ptIndex++)
    {
        ptNode.Prev   = ptIndex-1;  // -1 means NULL;
        ptNode.Next   = ptIndex+1;
        ptNode.Dup    = -1;
        ptNode.Inside = TRUE;
        ptNode.Used   = FALSE;
        if ((status = PtList.Add(ptNode)) != Ok)
        {
            return status;
        }
    }

    //index NumPts
    ptNode.Prev   = ptIndex-1;
    ptNode.Next   = -1;   // -1 means NULL;
    ptNode.Dup    = FirstIndex; // the first point is same as closing point
    ptNode.Inside = TRUE;
    ptNode.Used   = FALSE;
    if ((status = PtList.Add(ptNode)) != Ok)
    {
        return status;
    }
        
    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   Perform a simple partition sort on a list indexing into the vector list.
*   The result is a sorted index array keyed on the vertex array Y1 coordinate.
*   The index array is sorted in place and in ascending order.
*
* Arguments:
*
*   v is the vertex list.
*   F, L - First and Last pointer in the index array.
*
* Created:
*
*  09/16/2000 asecchia
*
\**************************************************************************/

void PathSelfIntersectRemover::QuickSortEdges(
    Edge *F,
    Edge *L
)
{
    if(F < L)
    {
        // Find the median position.
        
        Edge median = *(F + (L-F)/2);
        
        Edge *i = F;
        Edge *j = L;
        
        while(i<j)
        {
            // seek for elements in the wrong partition.
            
            // compare edges:
            while(CompareLine(this, i, &median) == -1) { i++; }
            while(CompareLine(this, j, &median) == 1)  { j--; }
            
            if(i>=j) { break; }
            
            // Swap.
            
            Edge temp = *i;
            *i = *j;
            *j = temp;
            
            // tie breaker - handle the case where *i == *j == *median, but
            // i != j. Only possible with multiple copies of the same entry.
            
            if(CompareLine(this, i, j) == 0) { i++; }
        }
        
        // Call recursively for the two sub-partitions. The partitions don't 
        // include position i because it is correctly positioned.
        
        QuickSortEdges(F, i-1);
        QuickSortEdges(i+1, L);
    }
}




/**************************************************************************\
*
* Function Description:
*
*  Insert numEdges edges joining points stored in array PathPts.  First point 
*  has index firstIndex.  There must be numEdges+1 points to create numEdges
*  edges.
*
*   NOTE: NumEdges CAN be negative! The function will then just return.
*         This can potentially happen when called from AddPolygon().
*
* Arguments:
*
*   firstIndex - index of first point in PathPts array.
*   numEdges   - number of edges to add.
*
* Return Value:
*
*   GpStatus.
*
* Created:
*
*   6/15/1999 t-wehunt
*  10/19/2000 asecchia  rewrote it to support quicksort instead of insert sort.
*
\**************************************************************************/

GpStatus PathSelfIntersectRemover::InsertEdges(INT firstIndex, INT numEdges)
{
    // Handle the empty polygon up front.
    
    if(numEdges == 0)
    {
        return Ok;
    }
    
    // Alloc space for all the edges up front.
    
    Edge *edges = EdgeList.AddMultiple(numEdges);
    if (edges == NULL)
    {
        return OutOfMemory;
    }
    
    // Create an edge with it's parent pointer.
    
    Edge newEdge(this);

    for (INT i = 0; i < numEdges; i++)
    {
        newEdge.Begin     = i+firstIndex;
        newEdge.End       = i+1+firstIndex;
        newEdge.SortBegin = i+firstIndex;
        newEdge.SortEnd   = i+1+firstIndex;

        newEdge.Normalize();

        newEdge.YCur = 0;   // make debugging easier

        newEdge.OrigBegin = newEdge.SortBegin;
        newEdge.OrigEnd   = newEdge.SortEnd;

        //Edge insertion
        
        edges[i] = newEdge;
    }
    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   Check if two lines intersect.
*   NOTE:  Lines also intersect if an end point of one line is anywhere in the
*   middle (between the end points) of the other line.
*   
*   This algorithm was stolen from the NT path code with some modifications
*   based on an algorithm presented in Graphics Gems III.
*   We can try to speed it up by comparing bounding boxes of the two lines,
*   however, according to GG III, this may or may not speed up the 
*   calculations.
*
* Arguments:
*
*   ptrEdge1, ptrEdge2 - edges to intersect.
*   [OUT] intersectPt      - the intersection point if lines INTERSECT 
*                        or have a COMMON_POINT, 
*
* Return Value:
*
*   DONOT_INTERS - lines don't intersect
*   COMMON_POINT - they share a common end point
*   INTERSECT    - they intersect
*   COLINEAR     - they arecolinear.
*
* Created:
*
*   6/15/1999 t-wehunt
*
\**************************************************************************/

INT
PathSelfIntersectRemover::IntersectEdge(
    Edge *ptrEdge1, 
    Edge *ptrEdge2, 
    GpPointF *intersectPt
    )
{
    GpPointF *pfpvBegin1;             // Start point of first line segment
    GpPointF *pfpvEnd1;               // End point of the first line segment
    GpPointF *pfpvBegin2;             // Start point of second line segment
    GpPointF *pfpvEnd2;               // End point of the second line segment

    GpPointF fpvVec1(0,0);            // Direction of first line segment
    GpPointF fpvVec2(0,0);            // Direction of second line segment
    GpPointF fpvVec3(0,0);

    // Get the actual coordinates of the points.

    pfpvBegin1 = &PathPts[ptrEdge1->Begin];
    pfpvEnd1 = &PathPts[ptrEdge1->End];
    fpvVec1 = SubtractPoint(*pfpvEnd1,*pfpvBegin1);

    // Nothing intersects with an empty line.
    
    if( REALABS(fpvVec1.X) < REAL_EPSILON &&
        REALABS(fpvVec1.Y) < REAL_EPSILON )
    {
        return(DONOT_INTERS);
    }

    pfpvBegin2 = &PathPts[ptrEdge2->Begin];
    pfpvEnd2 = &PathPts[ptrEdge2->End];
    fpvVec2 = SubtractPoint(*pfpvEnd2,*pfpvBegin2);
    
    // Nothing intersects with an empty line.
    
    if( REALABS(fpvVec2.X) < REAL_EPSILON &&
        REALABS(fpvVec2.Y) < REAL_EPSILON )
    {
        return(DONOT_INTERS);
    }
    
    fpvVec3 = SubtractPoint(*pfpvBegin2,*pfpvBegin1);

//
// A -direction 1
// D -direction 2
// C -vec3 ->

//  The intersection is computed by:
//
//  intersect = pptBegin1 + lambda * A
//  intersect = pptBegin2 + beta * D
//
//            Cx(-Dy) + Cy(Dx)
//  lambda =  ------------------------------
//            (Ax)(-Dy) + (Ay)(Dx)
//
//              Cx(Dy) + Cy(-Dx)
//  beta =    ---------------------
//            (Ax)(Dy) + (-Ay)(Dx)
//
    REAL efTerm1;
    REAL efTerm2;
    REAL efNum1;
    REAL efDenom;
    REAL efColinX;
    REAL efColinY;
    REAL efTemp;

// Cx (-Dy)

    efNum1 = fpvVec3.X;
    efColinX = efNum1;
    efTerm2 = -fpvVec2.Y;
    efNum1 *= efTerm2;

// Cy (Dx)
    
    efTerm1 = fpvVec3.Y;
    efColinY = efTerm1;
    efTerm2 = fpvVec2.X;
    efTerm1 *= efTerm2;
    efNum1 += efTerm1;

// (Ax)(-Dy)

    efDenom = fpvVec1.X;
    efTerm2 = -fpvVec2.Y;
    efDenom *= efTerm2;

// (Ay)(Dx)

    efTerm1 = fpvVec1.Y;
    efTerm2 = fpvVec2.X;
    efTerm1 *= efTerm2;
    efDenom += efTerm1;

    if (CloseReal(efDenom, 0))
    //if (efDenom == 0)
    {
        // they are colinear, but are they on the same line?
        efTemp = -fpvVec1.Y;
        efColinX *= efTemp;
        efTemp = fpvVec1.X;
        efColinY *= efTemp;
        efColinX += efColinY;
        //  if (efColinX == 0)
        if (CloseReal(efColinX, 0))
        {
         return(COLINEAR);
        }
        else
        {
            return(DONOT_INTERS);
        }
    }

    // Check if they share a common end point

    if (ptrEdge2->End == ptrEdge1->Begin   || 
        ptrEdge2->End == ptrEdge1->End     ||
        ptrEdge2->Begin == ptrEdge1->Begin || 
        ptrEdge2->Begin == ptrEdge1->End)
    {
        return COMMON_POINT;
    }

    if (ClosePt(*pfpvBegin1, *pfpvBegin2))
    {
        UpdateDups(ptrEdge1->Begin, ptrEdge2->Begin);
        return COMMON_POINT;
    }
    if (ClosePt(*pfpvBegin1, *pfpvEnd2))
    {
        UpdateDups(ptrEdge1->Begin, ptrEdge2->End);
        return COMMON_POINT;
    }

    if (ClosePt(*pfpvEnd1, *pfpvEnd2))
    {
        UpdateDups(ptrEdge1->End, ptrEdge2->End);
        return COMMON_POINT;
    }
    
    if (ClosePt(*pfpvEnd1, *pfpvBegin2))
    {
        UpdateDups(ptrEdge1->End, ptrEdge2->Begin);
        return COMMON_POINT;
    }

// lambda
    efNum1 /= efDenom;

    if (efNum1 < 0.0)
    {
        return(DONOT_INTERS);
    }
    else if (efNum1 > 1.0)
    {
        return (DONOT_INTERS);
    }
    else
    {
        REAL efNum2;
        REAL efBetaPart1;
        REAL efBetaPart2;

        // find beta
        efNum2 = -fpvVec3.X;
        efBetaPart2 = fpvVec1.Y;
        efNum2 *= efBetaPart2;
        efBetaPart1 = -fpvVec3.Y;
        efBetaPart2 = -fpvVec1.X;
        efBetaPart1 *= efBetaPart2;
        efNum2 += efBetaPart1;
        efNum2 /= efDenom;
        if (efNum2 < 0.0)
        {
            return(DONOT_INTERS);
        }
        else if (efNum2 > 1.0)
        {
            return (DONOT_INTERS);
        }
   }

    // pptBegin1 + lambda * A

    // Following should be nice to the REAL unit - multiply-add instructions
    // can be used.
    efTerm1 = fpvVec1.X * efNum1 + pfpvBegin1->X;
    efTerm2 = fpvVec1.Y * efNum1 + pfpvBegin1->Y;

    intersectPt->X = efTerm1;
    intersectPt->Y = efTerm2;

    // Because of errors, we may still end up with the intersection
    // point as a common point:
    if (IsCommonPt(ptrEdge1, ptrEdge2, intersectPt))
    {
        return COMMON_POINT;
    }

    return(INTERSECT);
}

/**************************************************************************\
*
* Function Description:
*
*  Find all self intersections of the paths and break up the edges.
*
*  This is considered 'Phase 1' of the algorithm.
*
* Arguments:
*
*   None.
*
* Return Value:
*
*   FALSE if out of memory.
*
* Created:
*
*   6/15/1999 t-wehunt
*
\**************************************************************************/

BOOL PathSelfIntersectRemover::FindIntersects()
{
    // Initialize the array of active edges.
    // Take the first edge from the edge array InactiveEdgeList and add it to 
    // the active edgs. Add all other edges, which start at the same x.

    INT numRemoved = 0;

    if (EdgeList.GetCount() <= 0)
    {
        return FALSE;
    }

    XCur = PathPts[EdgeList[InactiveEdgeList].SortBegin].X;

    // "move" all edges starting at XCur to the active edge array
    // PathPts in the active edge array will be sorted by y for the
    // given XCur.
    
    AddActiveForX(&InactiveEdgeList);

    while (TRUE)
    {
        // Find all intersections among the current edges
        
        if (!FindIntersectsForX())
        {
            return FALSE;
        }

        // if there are no edges left, we have found all intersections
        // we can stop even if active edges array is not empty, or maybe
        // it must be empty then?  TODO: Kasiak
        
        if (InactiveEdgeList == LIST_END)
        {
            break;
        }

        if (!ClosestActive(InactiveEdgeList))
        {
            break;
        }

        // Remove all edges which end before (or on) XCur
        
        ClearActiveListInclusiveX();
        
        AddActiveForX(&InactiveEdgeList);
    }

    // remove everything else from the ActiveEdgeList
    
    XCur = FP_INF;
    ClearActiveListInclusiveX();

    return TRUE;
}


/**************************************************************************\
*
* Function Description:
*
*   IsTIntersection returns TRUE if the intersection point intersectPt is
*   the same as an end point of one of the edges ptrEdge1 and ptrEdge2.  If 
*   it is, pfFirst will be TRUE if the first edge needs to be broken (intersectPt
*   is an end point of ptrEdge2), FALSE if the second one needs to be broken
*   up.  intersectIndex contains the index of the end point which is the same
*   as the intersection point.
*
* Arguments:
*
*   ptrEdge1, 
*   ptrEdge2 - the two edges to check for T-intersections
*   intersectPt  - the intersection point previously found for the edges.
*   [OUT] splitFirst - TRUE if the first edge needs to be split. FALSE if 
*                      the second edge.
*   [OUT] intersectIndex - index of endpoint which is the same as intersectPt if it
*                      is a T-intersection.
*
* Return Value:
*
*   TRUE or FALSE
*
* Created:
*
*   6/15/1999 t-wehunt
*
\**************************************************************************/

BOOL PathSelfIntersectRemover::IsTIntersection(
    Edge *ptrEdge1, 
    Edge *ptrEdge2, 
    GpPointF *intersectPt, 
    BOOL *splitFirst,
    INT *intersectIndex
    )
{
    GpPointF &begin1 = PathPts[ptrEdge1->SortBegin];
    GpPointF &begin2 = PathPts[ptrEdge2->SortBegin];
    GpPointF &end1 = PathPts[ptrEdge1->SortEnd];
    GpPointF &end2 = PathPts[ptrEdge2->SortEnd];

    if (ClosePt(end1, *intersectPt))
    {
        // only ptrEdge2 needs to be broken up
        *splitFirst = FALSE;
        *intersectIndex = ptrEdge1->SortEnd;
        return TRUE;
    }
    else if(ClosePt(end2, *intersectPt))
    {
        // only ptrEdge1
        *splitFirst = TRUE;
        *intersectIndex = ptrEdge2->SortEnd;
        return TRUE;
    }
    else if(ClosePt(begin1, *intersectPt))
    {
        // only ptrEdge2
        *splitFirst = FALSE;
        *intersectIndex = ptrEdge1->SortBegin;
        return TRUE;
    }
    else if(ClosePt(begin2, *intersectPt))
    {
        // only ptrEdge1
        *splitFirst = TRUE;
        *intersectIndex = ptrEdge2->SortBegin;
        return TRUE;
    }

    return FALSE;
}

/**************************************************************************\
*
* Function Description:
*
*   Returns TRUE if the two lines ptrEdge1 and ptrEdge2 share a common 
*   end point. If they do, pptInter will contain this point.
*
* Arguments:
*
*
* Return Value:
*
*
* Created:
*
*   6/15/1999 t-wehunt
*
\**************************************************************************/

BOOL 
PathSelfIntersectRemover::IsCommonPt(
    Edge *ptrEdge1,
    Edge *ptrEdge2,
    GpPointF *commonPt
    )
{
    GpPointF &begin1 = PathPts[ptrEdge1->SortBegin];
    GpPointF &begin2 = PathPts[ptrEdge2->SortBegin];
    GpPointF &end1 = PathPts[ptrEdge1->SortEnd];
    GpPointF &end2 = PathPts[ptrEdge2->SortEnd];

    if (ClosePt(end1, *commonPt) && ClosePt(end2, *commonPt))
    {
        UpdateDups(ptrEdge1->End, ptrEdge2->End);
        return TRUE;
    }
    else if(ClosePt(end1, *commonPt) && ClosePt(begin2, *commonPt))
    {
        UpdateDups(ptrEdge1->End, ptrEdge2->Begin);
        return TRUE;
    }
    else if(ClosePt(begin1, *commonPt) && ClosePt(begin2, *commonPt))
    {
        UpdateDups(ptrEdge1->Begin, ptrEdge2->Begin);
        return TRUE;
    }
    else if(ClosePt(begin1, *commonPt) && ClosePt(end2, *commonPt))
    {
        UpdateDups(ptrEdge1->Begin, ptrEdge2->End);
        return TRUE;
    }

    return FALSE;
}

/**************************************************************************\
*
* Function Description:
*
*   Returns TRUE if point with index inew is already in the "list" of dups
*   for point with index loop.
*
* Arguments:
*
*
* Return Value:
*
*
* Created:
*
*   6/15/1999 t-wehunt
*
\**************************************************************************/

BOOL PathSelfIntersectRemover::IsLinked(INT loop, INT inew)
{
    PointListNode *ptNode;

    ptNode = &PtList[loop];
    BOOL isLinked = FALSE;
    INT i = ptNode->Dup;
    INT prev_i = -1;    // Added to prevent an infinite loop.

    while(!isLinked && i != -1 && i != prev_i && i != loop)
    {
        if(i == inew)
        {
            isLinked = TRUE;
            break;
        }

        ptNode = &PtList[i];
        prev_i = i;
        i = ptNode->Dup;
    }

    return isLinked;
}

/**************************************************************************\
*
* Function Description:
*
*   Joins the list of duplicate points for points pt1 and pt2.
*
* Arguments:
*
*
* Return Value:
*
*
* Created:
*
*   6/15/1999 t-wehunt
*
\**************************************************************************/
VOID PathSelfIntersectRemover::UpdateDups(INT pt1, INT pt2)
{
    PointListNode *ptNode1;
    PointListNode *ptNode2;

    if (pt1 == pt2)
    {
        WARNING(("NOT REACHED"));
        return;
    }

    ptNode1 = &PtList[pt1];
    ptNode2 = &PtList[pt2];

    if ((ptNode1->Dup == -1) && (ptNode2->Dup == -1))
    {
        ptNode1->Dup = pt2;
        ptNode2->Dup = pt1;
        return;
    }

    if ((ptNode1->Dup == -1) && (ptNode2->Dup != -1))
    {
        ptNode1->Dup = ptNode2->Dup;
        ptNode2->Dup = pt1;
        return;
    }

    if ((ptNode1->Dup != -1) && (ptNode2->Dup == -1))
    {
        ptNode2->Dup = ptNode1->Dup;
        ptNode1->Dup = pt2;
        return;
    }

    if ((ptNode1->Dup != -1) && (ptNode2->Dup != -1))
    {
        if (!IsLinked(pt1, pt2))
        {
            INT dupTemp;

            dupTemp = ptNode2->Dup;
            ptNode2->Dup = ptNode1->Dup;
            ptNode1->Dup = dupTemp;
        }
        return;
    }
}

/**************************************************************************\
*
* Function Description:
*
*   Delete edges from the active edge table;  Indices of edges to delete
*   are stored in EdgesToDelete1..3.  Deletes the highest index edge first.
*   Returns NULL if fails due to out of memory error.
*
* Arguments:
*
*
* Return Value:
*
*
* Created:
*
*   6/15/1999 t-wehunt
*
\**************************************************************************/

BOOL PathSelfIntersectRemover::DeleteEdges()
{
    INT minIndex;
    INT midIndex;
    INT maxIndex;

    if (EdgesToDelete1 > EdgesToDelete2)
    {
        if (EdgesToDelete1 > EdgesToDelete3)
        {
            minIndex = EdgesToDelete1;
            if (EdgesToDelete2 > EdgesToDelete3)
            {
                midIndex = EdgesToDelete2;
                maxIndex = EdgesToDelete3;
            }
            else
            {
                midIndex = EdgesToDelete3;
                maxIndex = EdgesToDelete2;
            }
        }
        else
        {
            minIndex = EdgesToDelete3;
            midIndex = EdgesToDelete1;
            maxIndex = EdgesToDelete2;
        }
    }
    else
    {
        if (EdgesToDelete2 > EdgesToDelete3)
        {
            minIndex = EdgesToDelete2;
            if (EdgesToDelete1 > EdgesToDelete3)
            {
                midIndex = EdgesToDelete1;
                maxIndex = EdgesToDelete3;
            }
            else
            {
                midIndex = EdgesToDelete3;
                maxIndex = EdgesToDelete1;
            }
        }
        else
        {
            minIndex = EdgesToDelete3;
            midIndex = EdgesToDelete2;
            maxIndex = EdgesToDelete1;
        }
    }
    
    if (minIndex == -1)
    {
        return TRUE;
    }
    // delete the first one
    if (!DeleteEdgeFromList(&ActiveEdgeList, minIndex))
    {
        return FALSE;
    }

    if (midIndex == -1)
    {
        return TRUE;
    }
    // delete the second one
    if (!DeleteEdgeFromList(&ActiveEdgeList, midIndex))
    {
        return FALSE;
    }

    if (maxIndex == -1)
    {
        return TRUE;
    }
    // delete the third one
    if (!DeleteEdgeFromList(&ActiveEdgeList, maxIndex))
    {
      return FALSE;
    }

    return TRUE;
}

/**************************************************************************\
*
* Function Description:
*
*    Edge with index index into the array of Active edges needs to be deleted.
*    Store its index for deletion.
*
* Arguments:
*
*
* Return Value:
*
*
* Created:
*
*   6/15/1999 t-wehunt
*
\**************************************************************************/

VOID PathSelfIntersectRemover::MarkToDelete(INT index)
{
    ASSERT((EdgesToDelete1 == -1) || 
           (EdgesToDelete2 == -1) || 
           (EdgesToDelete3 == -1));

    if (EdgesToDelete1 == -1 )
    {
        EdgesToDelete1 = index;
        return;
    }

    if (EdgesToDelete2 == -1 )
    {
        EdgesToDelete2 = index;
        return;
    }

    if (EdgesToDelete3 == -1 )
    {
        EdgesToDelete3 = index;
        return;
    }
    return; // error
}

/**************************************************************************\
*
* Function Description:
*
*   Edge ptrEdge needs to be added to the array with Active edges.  Make a 
*   copy of the edge and store it, so that it can be later added.
*   We have to add new edges after the edges marked for deletion are deleted.
*
* Arguments:
*
*
* Return Value:
*
*
* Created:
*
*   6/15/1999 t-wehunt
*
\**************************************************************************/

VOID PathSelfIntersectRemover::MarkToAdd(Edge *ptrEdge)
{
    ASSERT(!(FlgAdd1 && FlgAdd2 && FlgAdd3));

    if (!FlgAdd1)
    {
        AddToActive1 = *ptrEdge;
        FlgAdd1 = TRUE;
        return;
    }                                                                                 

    if (!FlgAdd2)
    {
        AddToActive2 = *ptrEdge;
        FlgAdd2 = TRUE;
        return;
    }

    if (!FlgAdd3)
    {
        AddToActive3 = *ptrEdge;
        FlgAdd3 = TRUE;
        return;
    }
    return;  // this the error condition, which should never happen.
}

/**************************************************************************\
*
* Function Description:
*
*   Add new edges to the active edge table.  The edges are stored in
*   AddToActive1..3.  flag FlgAdd1..3 specify if the given edge needs to
*   be added or not.  Returns if fails due to out of memory.
*
* Arguments:
*
*
* Return Value:
*
*
* Created:
*
*   6/15/1999 t-wehunt
*
\**************************************************************************/

BOOL PathSelfIntersectRemover::AddNewEdges()
{
    if (FlgAdd1)
    {
        AddToActive1.SortBegin = AddToActive1.Begin;
        AddToActive1.SortEnd = AddToActive1.End;
        AddToActive1.Normalize();
        AddToActive1.YCur = PathPts[AddToActive1.SortBegin].Y;
        
        AddToActive1.Next = LIST_END;
        
        //Edge Insertion
        
        if(Ok != EdgeList.Add(AddToActive1))
        {
            return FALSE;  // out of memory.
        }
        
        InsertEdgeIntoList(
            &ActiveEdgeList, 
            EdgeList.GetCount()-1, 
            CompareYCurLine
        );
   }
    
    if (FlgAdd2)
    {
        AddToActive2.SortBegin = AddToActive2.Begin;
        AddToActive2.SortEnd = AddToActive2.End;
        AddToActive2.Normalize();
        AddToActive2.YCur = PathPts[AddToActive2.SortBegin].Y;
        
        AddToActive2.Next = LIST_END;
        
        //Edge Insertion
        
        if(Ok != EdgeList.Add(AddToActive2))
        {
            return FALSE;  // out of memory.
        }
        
        InsertEdgeIntoList(
            &ActiveEdgeList, 
            EdgeList.GetCount()-1, 
            CompareYCurLine
        );
   }

    if (FlgAdd3)
    {
        AddToActive3.SortBegin = AddToActive3.Begin;
        AddToActive3.SortEnd = AddToActive3.End;
        AddToActive3.Normalize();
        AddToActive3.YCur = PathPts[AddToActive3.SortBegin].Y;
        
        AddToActive3.Next = LIST_END;
        
        //Edge Insertion
        
        if(Ok != EdgeList.Add(AddToActive3))
        {
            return FALSE;  // out of memory.
        }
        
        InsertEdgeIntoList(
            &ActiveEdgeList, 
            EdgeList.GetCount()-1,
            CompareYCurLine
        );
    }

    return TRUE;
}

/**************************************************************************\
*
* Function Description:
*
*   Find all intersections for the current X value.  Intersection points
*   will be inserted into the Edges array and information about their
*   order into PtList. Returns FALSE on out of memory.
*
* Arguments:
*
*
* Return Value:
*
*
* Created:
*
*   6/15/1999 t-wehunt
*
\**************************************************************************/

BOOL PathSelfIntersectRemover::FindIntersectsForX()
{
    Edge *ptrEdge1 = NULL;
    Edge *ptrEdge2 = NULL;
    Edge *ptrEdge3 = NULL;

    // If we find an intersection, we will be breaking up edges - need two more
    // line variables for the new edges.
    Edge newEdge1(this);
    Edge newEdge2(this);

    GpPointF intersectPt(0,0);
    INT result = DONOT_INTERS;
    BOOL breakFirst = TRUE;
    INT dup1 = -1;
    INT dup2 = -1;
    INT ptIndex1 = -1;
    INT ptIndex2 = -1;
    PointListNode *ptNode = NULL;
    INT edgeIndex1, edgeIndex2, edgeIndexOld;
    REAL yCur2;
    BOOL deleteEdge1;
    BOOL deleteEdge2;
    BOOL edge1Deleted;
    BOOL edge2Deleted;

    // Go through all active edges but consider only consecutive pairs of egdes
    // because they are sorted in y.  There is no need to check every edge with
    // every other edge in general case.  However, when we have multiple edges
    // with the same current y value and end points, we have to consider all of
    // them.

    edgeIndexOld = LIST_END;
    edgeIndex1 = ActiveEdgeList;
    
    if(edgeIndex1 == LIST_END)
    {
        return TRUE;
    }
    
    edgeIndex2 = EdgeList[ActiveEdgeList].Next;
    
    while (edgeIndex1 != LIST_END && edgeIndex2 != LIST_END)
    {
        edge1Deleted = FALSE;
        edge2Deleted = FALSE;
        
        // Get the next two edges
        
        ptrEdge1 = &EdgeList[edgeIndex1];
        ptrEdge2 = &EdgeList[edgeIndex2];
        
        yCur2 = ptrEdge2->YCur;

        FlgAdd1 = FALSE;
        FlgAdd2 = FALSE;
        FlgAdd3 = FALSE;

        EdgesToDelete1 = -1;
        EdgesToDelete2 = -1;
        EdgesToDelete3 = -1;

        // Do they intersect?
        result = IntersectEdge(ptrEdge1, ptrEdge2, &intersectPt);
        if (result == INTERSECT)
        {
            // check if both edges need to be broken up, we may have
            // a "T" intersection
            if (IsTIntersection(ptrEdge1, ptrEdge2, &intersectPt, 
                &breakFirst, &dup1))
            {
                // only one edge needs to be broken up
                // The index of the new point will be:
                ptIndex1 = PathPts.GetCount();
                // Update the dup field
                // we have idup from IsTIntersection - it returned the index of
                // the end point which is the same as the point of intersection
                // It is a duplicate of the new point
                ptNode = &PtList[dup1];
                if (ptNode->Dup == -1)
                {
                    ptNode->Dup = ptIndex1;
                }
                else
                {
                    dup1 = ptNode->Dup;
                    ptNode->Dup = ptIndex1;
                }
                if (breakFirst)
                {
                    // we need to break up the first edge
                    if (!BreakEdge(ptrEdge1, &intersectPt, &newEdge2, dup1))
                    {
                        return FALSE;
                    }
                    
                    // BreakEdge can cause a realloc, thus invalidating
                    // ptrEdge1 and ptrEdge2
                    
                    ptrEdge1 = &EdgeList[edgeIndex1];
                    ptrEdge2 = &EdgeList[edgeIndex2];

                    
                    // Check if the left side of ptIntersect shouldn't be 
                    // removed. This is the case when
                    //  ptrEdge1->yCur == intersectPt.y && intersectPt.x == xCur;
                    if (ptrEdge1->YCur >= intersectPt.Y && intersectPt.X <= XCur)
                    {
                        MarkToDelete(edgeIndex1);
                        edge1Deleted = TRUE;
                    }
                }
                else
                {
                    // we need to break up the first edge
                    if (!BreakEdge(ptrEdge2, &intersectPt, &newEdge1, dup1))
                    {
                        return FALSE;
                    }
                    
                    // BreakEdge can cause a realloc, thus invalidating
                    // ptrEdge1 and ptrEdge2
                    
                    ptrEdge1 = &EdgeList[edgeIndex1];
                    ptrEdge2 = &EdgeList[edgeIndex2];
                    
                    // Check if the left side of ptIntersect shouldn't be 
                    // removed. This is the case when
                    //  ptrEdge2->yCur == intersectPt.y && intersectPt.x == xCur;
                    if (ptrEdge2->YCur >= intersectPt.Y && intersectPt.X <= XCur)
                    {
                        MarkToDelete(edgeIndex2);
                        edge2Deleted = TRUE;
                    }
                }
            }
            else
            {
                // both need to be broken up
                // We need to add two new points.  They are identical and 
                // will be duplicates.  Let's get thei indecies.
                ptIndex1 = PathPts.GetCount();
                ptIndex2 = ptIndex1+1;
                if (!BreakEdge(ptrEdge1, &intersectPt, &newEdge2, ptIndex2))
                    return FALSE;
                
                // BreakEdge can cause a realloc, thus invalidating
                // ptrEdge1 and ptrEdge2
                
                ptrEdge1 = &EdgeList[edgeIndex1];
                ptrEdge2 = &EdgeList[edgeIndex2];
                
                if (!BreakEdge(ptrEdge2, &intersectPt, &newEdge1, ptIndex1))
                    return FALSE;
                
                // BreakEdge can cause a realloc, thus invalidating
                // ptrEdge1 and ptrEdge2
                
                ptrEdge1 = &EdgeList[edgeIndex1];
                ptrEdge2 = &EdgeList[edgeIndex2];
                
                // Let's delete what we will not need any more - the left hand
                // sides of the old edges only if the intersection point is on
                // the scanline
                deleteEdge2 = (ptrEdge2->YCur >= intersectPt.Y && 
                              intersectPt.X <= XCur);
                deleteEdge1 = (ptrEdge1->YCur >= intersectPt.Y && 
                              intersectPt.X <= XCur);
                if (deleteEdge2)
                {
                    MarkToDelete(edgeIndex2);
                    edge2Deleted = TRUE;
                }

                if (deleteEdge1)
                {
                    MarkToDelete(edgeIndex1);
                    edge1Deleted = TRUE;
                }
            }
        }
        else if (result == COLINEAR)
        {
            BOOL three;
            GpPointF intersectPt2(0,0);
            BOOL breakSecond;
            // The line segments must overlap or both are vertical...
            // Find out if they overlap and if this is the case,
            // Let's pick the begin point with the greater x.
            // Overlap will check if the two edges overlap and return
            // a point of intersection as well as information of which edge
            // to break up.
            if (Overlap(ptrEdge1, ptrEdge2, &intersectPt, &intersectPt2, &breakFirst,
                                &breakSecond,  &three, &dup1, &dup2))
            {
                if (breakFirst)
                {
                    if (!three)
                    {
                        // As before, get the index, so we can set up 
                        // the duplicates
                        ptIndex1 = PathPts.GetCount();
                        // Update the dup field
                        ptNode = &PtList[dup1];
                        if (ptNode->Dup == -1)
                        {
                            ptNode->Dup = ptIndex1;
                        }
                        else
                        {
                            dup1 = ptNode->Dup;
                            ptNode->Dup = ptIndex1;
                        }
                        if (!BreakEdge(ptrEdge1, &intersectPt, &newEdge2, dup1))
                        {
                            return FALSE;
                        }
                        
                        // BreakEdge can cause a realloc, thus invalidating
                        // ptrEdge1 and ptrEdge2
                        
                        ptrEdge1 = &EdgeList[edgeIndex1];
                        ptrEdge2 = &EdgeList[edgeIndex2];
                        
                    }
                    else
                    {
                        ptIndex1 = PathPts.GetCount();
                        ptIndex2 = ptIndex1+1;
                        // we need to break this edge into 3 pieces
                
                        // Update the dup field
                        ptNode = &PtList[dup1];
                        if (ptNode->Dup == -1)
                        {
                            ptNode->Dup = ptIndex1;
                        }
                        else
                        {
                            dup1 = ptNode->Dup;
                            ptNode->Dup = ptIndex1;
                        }
                
                        // Update the dup field
                        ptNode = &PtList[dup2];
                        if (ptNode->Dup == -1)
                        {
                            ptNode->Dup = ptIndex2;
                        }
                        else
                        {
                            dup2 = ptNode->Dup;
                            ptNode->Dup = ptIndex2;
                        }
                        if (!BreakEdgeIn3(ptrEdge1, &intersectPt, &intersectPt2, 
                            &newEdge1, &newEdge2, dup1, dup2))
                        {
                            return FALSE;
                        }
                        
                        // BreakEdge can cause a realloc, thus invalidating
                        // ptrEdge1 and ptrEdge2
                        
                        ptrEdge1 = &EdgeList[edgeIndex1];
                        ptrEdge2 = &EdgeList[edgeIndex2];
                    }
                    deleteEdge1 = (ptrEdge1->YCur >= intersectPt.Y && 
                                  intersectPt.X <= XCur);
                    if (deleteEdge1)
                    {
                        MarkToDelete(edgeIndex1);
                        edge1Deleted = TRUE;
                    }
                }
                if (breakSecond)
                {
                    if (!three)
                    {
                        // break ptrEdge2
                        // Update the dup field
                        ptIndex1 = PathPts.GetCount();
                        ptNode = &PtList[dup2];
                        if (ptNode->Dup == -1)
                        {
                            ptNode->Dup = ptIndex1;
                        }
                        else
                        {
                            dup2 = ptNode->Dup;
                            ptNode->Dup = ptIndex1;
                        }
                        if (!BreakEdge(ptrEdge2, &intersectPt2, &newEdge1, dup2))
                        {
                            return FALSE;
                        }
                        
                        // BreakEdge can cause a realloc, thus invalidating
                        // ptrEdge1 and ptrEdge2
                        
                        ptrEdge1 = &EdgeList[edgeIndex1];
                        ptrEdge2 = &EdgeList[edgeIndex2];

                        deleteEdge2 = ptrEdge2->YCur >= intersectPt2.Y && 
                                      intersectPt2.X     <= XCur;

                        if (deleteEdge2)
                        {
                            MarkToDelete(edgeIndex2);
                            edge2Deleted = TRUE;
                        }
                    }
                    else
                    {
                        ptIndex1 = PathPts.GetCount();
                        ptIndex2 = ptIndex1+1;
                        // we need to break this edge into 3 pieces
                
                        // Update the dup field
                        ptNode = &PtList[dup1];
                        if (ptNode->Dup == -1)
                        {
                            ptNode->Dup = ptIndex1;
                        }
                        else
                        {
                            dup1 = ptNode->Dup;
                            ptNode->Dup = ptIndex1;
                        }
                
                        // Update the dup field
                        ptNode = &PtList[dup2];
                        if (ptNode->Dup == -1)
                        {
                            ptNode->Dup = ptIndex2;
                        }
                        else
                        {
                            dup2 = ptNode->Dup;
                            ptNode->Dup = ptIndex2;
                        }
                        if (!BreakEdgeIn3(ptrEdge2, &intersectPt, &intersectPt2, 
                            &newEdge1, &newEdge2, dup1, dup2))
                        {
                            return FALSE;
                        }
                        
                        // BreakEdge can cause a realloc, thus invalidating
                        // ptrEdge1 and ptrEdge2
                        
                        ptrEdge1 = &EdgeList[edgeIndex1];
                        ptrEdge2 = &EdgeList[edgeIndex2];

                        deleteEdge2 = ptrEdge2->YCur >= intersectPt.Y &&
                                      intersectPt.X      <= XCur;

                        if (deleteEdge2)
                        {
                            MarkToDelete(edgeIndex2);
                            edge2Deleted = TRUE;
                        }
                    }
                }
            }
        }
        
        bool modifiedList = false;

        // If we're deleting any edges, we've modified the list.
        
        if((EdgesToDelete1 != -1) ||
           (EdgesToDelete2 != -1) ||
           (EdgesToDelete3 != -1))
        {
            modifiedList = true;
        }
        
        if (!DeleteEdges())
        {
            return FALSE;
        }
        
        // If we're adding any edges, we've modified the list.
        
        if(FlgAdd1 || FlgAdd2 || FlgAdd3)
        {
            modifiedList = true;
        }
        
        if (!AddNewEdges())
        {
            return FALSE;
        }
        
        
        // Note: We check all vertically adjacent pairs of edges. Because
        // the AET is sorted vertically and we're only looking for the 
        // intersection with the x coordinate closest to XCur, this is
        // sufficient (and O(n) instead of O(n^2)).
        
        if(modifiedList)
        {
            // back up to a stable position if we invalidate our list.
            // this makes assumptions on where in the list we add or 
            // delete elements based on the sort order for the ActiveEdgeList.
            
            edgeIndex1 = edgeIndexOld;
            
            if(edgeIndexOld == LIST_END)
            {
                edgeIndex1 = ActiveEdgeList;
            }
            
            if(edgeIndex1 != LIST_END)
            {
                edgeIndex2 = EdgeList[edgeIndex1].Next;
            }
        }
        else
        {
            edgeIndexOld = edgeIndex1;
            edgeIndex2 = EdgeList[edgeIndex2].Next;
            edgeIndex1 = EdgeList[edgeIndex1].Next;
        }
    }
    return TRUE;
}

/**************************************************************************\
*
* Function Description:
*
*      Returns TRUE if two collinear edges ptrEdge1 and ptrEdge2 overlap.
*      There are 4 ways in which edges can overlap and depending on the
*      case, either none, one or both edges need to be broken up.  In some
*      cases one edge may need to broken into 3 pieces.
*      Return values:
*        split1     - set to TRUE if ptrEdge1 needs to be split
*        split2     - set to TRUE if ptrEdge2 needs to be split
*        split3     - set to TRUE if an edge needs to be broken into 3 pieces
*        intersect1     - intersection point (where edge needs to be split)
*        intersect2     - second point (if the edge needs to be broken into 3
*                     pieces or for the second edge if both edges need to 
*                     be broken up)
*        dupIndex1  - index of the duplicate point to intersect1,
*        dupIndex2  - index of the duplicate point to intersect2,
*
* Arguments:
*
*
* Return Value:
*
*
* Created:
*
*   6/15/1999 t-wehunt
*
\**************************************************************************/

BOOL PathSelfIntersectRemover::Overlap(
    Edge *ptrEdge1, 
    Edge *ptrEdge2, 
    GpPointF *intersect1, 
    GpPointF *intersect2, 
    BOOL *split1,
    BOOL *split2, 
    BOOL *split3, 
    INT *dupIndex1, 
    INT *dupIndex2
    )
{
    // We are assuming that the lines are colinear and they both belong
    // to the active edges table which means that their x ranges overlap
    // We need to check if they are vertical and if yes, find out if their
    // y ranges overlap.  If they are not vertical, they must overlap or
    // they share a common end point.

    *split3 = FALSE;

    GpPointF &begin1 = PathPts[ptrEdge1->SortBegin];
    GpPointF &begin2 = PathPts[ptrEdge2->SortBegin];
    GpPointF &end1 = PathPts[ptrEdge1->SortEnd];
    GpPointF &end2 = PathPts[ptrEdge2->SortEnd];

    // Calculate bounding box for each edge:
    GpPointF min1(
        min(begin1.X, end1.X),
        min(begin1.Y, end1.Y));
    GpPointF max1(
        max(begin1.X, end1.X),
        max(begin1.Y, end1.Y));
    GpPointF min2(
        min(begin2.X, end2.X),
        min(begin2.Y, end2.Y));
    GpPointF max2(
        max(begin2.X, end2.X),
        max(begin2.Y, end2.Y));
        
    // Abort if the bounding box of either edge is empty.
    
    if(IsClosePointF(min1, max1) ||
       IsClosePointF(min2, max2) )
    {
        return FALSE;
    }

    // If the edges are not vertical, they must overlap, because both of them
    // are in the active edge array.  We only need to chose a point, which will
    // be used as an intersection point.
    if (!ptrEdge1->IsVertical())
    {
        // Let's check first if they share a common end point

        // if they share just a common point, return FALSE
        if (CloseReal(min1.X,max2.X))
        {
            // We have to update the dups of the shared point

            if (ptrEdge1->SortBegin != ptrEdge2->SortEnd)
            {
                UpdateDups(ptrEdge1->SortBegin, ptrEdge2->SortEnd);
                return FALSE;
            }
        }   
        
        if (CloseReal(min2.X,max1.X))
        {
            // We have to update the dups of the shared point

            if (ptrEdge1->SortEnd != ptrEdge2->SortBegin)
            {
                UpdateDups(ptrEdge1->SortEnd, ptrEdge2->SortBegin);
                return FALSE;
            }
        }

        // the edges must overlap, we need to break both of them

        // There are 4 different ways in which edges may overlap

        // case4: edges are identical
        //  ----------------
        //  ----------------
        // No edges need to be broken up, but do we need to update some
        // dup values?
        if (CloseReal(max1.X, max2.X) && CloseReal(min1.X, min2.X))
        {
            // for now, we will return FALSE
            // I think, that it should be OK.
            // TODO: - Review
            // !!! Is this still ok? - t-wehunt

            if (ptrEdge1->SortBegin != ptrEdge2->SortBegin)
                UpdateDups(ptrEdge1->SortBegin, ptrEdge2->SortBegin);

            if (ptrEdge1->SortEnd != ptrEdge2->SortEnd)
                UpdateDups(ptrEdge1->SortEnd, ptrEdge2->SortEnd);

            return FALSE;
        }

        // case2: the edges overlap and share one end point
        //  --------------
        //  ----------------------
        //  The longer edge needs to be broken into 2 pieces
        if (CloseReal(min1.X, min2.X) && max1.X < max2.X)
        {
            //  --------------
            //  ----------------------
            // We have to update the dups of the shared point

            if (ptrEdge1->SortBegin != ptrEdge2->SortBegin)
            {
                UpdateDups(ptrEdge1->SortBegin, ptrEdge2->SortBegin);
            }
            *split1 = FALSE;
            *split2 = TRUE;
            *dupIndex2 = ptrEdge1->SortEnd;
            *intersect2 = PathPts[*dupIndex2];
            return TRUE;
        }
        else if (CloseReal(min1.X, min2.X) && max1.X > max2.X)
        {
            //  ----------------------
            //  --------------
            // We have to update the dups of the shared point

            if (ptrEdge1->SortBegin != ptrEdge2->SortBegin)
            {
                UpdateDups(ptrEdge1->SortBegin, ptrEdge2->SortBegin);
            }
            *split1 = TRUE;
            *split2 = FALSE;
            *dupIndex1 = ptrEdge2->SortEnd;
            *intersect1 = PathPts[*dupIndex1];
            return TRUE;
        }
        else if (CloseReal(max1.X, max2.X) && min1.X > min2.X)
        {
            //  ----------------------
            //          --------------
            // We have to update the dups of the shared point

            if (ptrEdge1->SortEnd != ptrEdge2->SortEnd)
            {
                UpdateDups(ptrEdge1->SortEnd, ptrEdge2->SortEnd);
            }
            *split1 = FALSE;
            *split2 = TRUE;
            *dupIndex2 = ptrEdge1->SortBegin;
            *intersect2 = PathPts[*dupIndex2];
            return TRUE;
        }
        else if (CloseReal(max1.X, max2.X) && min1.X < min2.X)
        {
            //          --------------
            //  ----------------------
            // We have to update the dups of the shared point

            if (ptrEdge1->SortEnd != ptrEdge2->SortEnd)
            {
                UpdateDups(ptrEdge1->SortEnd, ptrEdge2->SortEnd);
            }
            *split1 = TRUE;
            *split2 = FALSE;
            *dupIndex1 = ptrEdge2->SortBegin;
            *intersect1 = PathPts[*dupIndex1];
            return TRUE;
        }

        // case1: one is "inside" of another 
        //       ---------
        //   -----------------
        // In this case, the longer edge has to be broken into 3 pieces

        if (min1.X < min2.X && max1.X > max2.X)
        {
            // intersection points are the end points of the second edge
            // we are breaking up the first edge
            *split1 = TRUE;
            *split2 = FALSE;
            *split3 = TRUE;
            *dupIndex1 = ptrEdge2->SortBegin;
            *dupIndex2 = ptrEdge2->SortEnd;
            *intersect1 = PathPts[*dupIndex1];
            *intersect2 = PathPts[*dupIndex2];
            return TRUE;
        }
        else if (min1.X > min2.X && max1.X < max2.X)
        {
            // intersection points are the end points of the first edge
            // we are breaking up the second edge
            *split1 = FALSE;
            *split2 = TRUE;
            *split3 = TRUE;
            *dupIndex1 = ptrEdge1->SortBegin;
            *dupIndex2 = ptrEdge1->SortEnd;
            *intersect1 = PathPts[*dupIndex1];
            *intersect2 = PathPts[*dupIndex2];
            return TRUE;
        }

        // case3: edges overlap
        // ---------------
        //         -----------------
        // Each edge has to be broken up INT 2 pieces
        else if (max1.X < max2.X && min1.X < min2.X)
        {
            *split1 = TRUE;
            *split2 = TRUE;
            *dupIndex1 = ptrEdge2->SortBegin;
            *dupIndex2 = ptrEdge1->SortEnd;
            *intersect1 = PathPts[*dupIndex1];
            *intersect2 = PathPts[*dupIndex2];
            return TRUE;
        }
        else if (max2.X < max1.X && min2.X < min1.X)
        {
        //         -----------------
        // ---------------
            *split1 = TRUE;
            *split2 = TRUE;
            *dupIndex1 = ptrEdge2->SortEnd;
            *dupIndex2 = ptrEdge1->SortBegin;
            *intersect1 = PathPts[*dupIndex1];
            *intersect2 = PathPts[*dupIndex2];
            return TRUE;
        }
    }

    // The edges are vertical.
    // We have to test for the same cases using y intervals

    // if they share just a common point, return FALSE
    if (CloseReal(min1.Y, max2.Y))
    {
        // We have to update the dups of the shared point

        if (ptrEdge1->SortBegin != ptrEdge2->SortEnd)
        {
            UpdateDups(ptrEdge1->SortBegin, ptrEdge2->SortEnd);
        }
        return FALSE;
    }   

    if (CloseReal(min2.Y, max1.Y))
    {
        // We have to update the dups of the shared point

        if (ptrEdge1->SortEnd != ptrEdge2->SortBegin)
        {
            UpdateDups(ptrEdge1->SortEnd, ptrEdge2->SortBegin);
        }
        return FALSE;
    }
    
    // These edges may not overlap at all
    if (min1.Y > max2.Y)
    {
        return FALSE;
    }

    if (min2.Y > max1.Y)
    {
        return FALSE;
    }

    // case4: edges are identical
    //  ----------------
    //  ----------------
    // No edges need to be broken up, but do we need to update some
    // dup values?
    if (CloseReal(max1.Y, max2.Y) && CloseReal(min1.Y, min2.Y))
    {
        // for now, we will return FALSE
        // I think, that it should be OK.
        // TODO: - Review
        // !!! IS this still ok? - t-wehunt
        if (ptrEdge1->SortBegin != ptrEdge2->SortBegin)
        {
            UpdateDups(ptrEdge1->SortBegin, ptrEdge2->SortBegin);
        }
        if (ptrEdge1->SortEnd != ptrEdge2->SortEnd)
        {
            UpdateDups(ptrEdge1->SortEnd, ptrEdge2->SortEnd);
        }
        return FALSE;
    }

    // case2: the edges overlap and share one end point
    //  --------------
    //  ----------------------
    //  The longer edge needs to be broken into 2 pieces
    if (CloseReal(min1.Y, min2.Y) && max1.Y < max2.Y)
    {
        //  --------------
        //  ----------------------
        // We have to update the dups of the shared point

        if (ptrEdge1->SortBegin != ptrEdge2->SortBegin)
        {
            UpdateDups(ptrEdge1->SortBegin, ptrEdge2->SortBegin);
        }
        *split1 = FALSE;
        *split2 = TRUE;
        *dupIndex2 = ptrEdge1->SortEnd;
        *intersect2 = PathPts[*dupIndex2];
        return TRUE;
    }
    else if (CloseReal(min1.Y, min2.Y) && max1.Y > max2.Y)
    {
        //  ----------------------
        //  --------------
        // We have to update the dups of the shared point

        if (ptrEdge1->SortBegin != ptrEdge2->SortBegin)
        {
            UpdateDups(ptrEdge1->SortBegin, ptrEdge2->SortBegin);
        }
        *split1 = TRUE;
        *split2 = FALSE;
        *dupIndex1 = ptrEdge2->SortEnd;
        *intersect1 = PathPts[*dupIndex1];
        return TRUE;
    }
    else if (CloseReal(max1.Y, max2.Y) && min1.Y > min2.Y)
    {
        //  ----------------------
        //          --------------
        // We have to update the dups of the shared point

        if (ptrEdge1->SortEnd != ptrEdge2->SortEnd)
        {
            UpdateDups(ptrEdge1->SortEnd, ptrEdge2->SortEnd);
        }
        *split1 = FALSE;
        *split2 = TRUE;
        *dupIndex2 = ptrEdge1->SortBegin;
        *intersect2 = PathPts[*dupIndex2];
        return TRUE;
    }
    else if (CloseReal(max1.Y, max2.Y) && min1.Y < min2.Y)
    {
        //          --------------
        //  ----------------------
        // We have to update the dups of the shared point

        if (ptrEdge1->SortEnd != ptrEdge2->SortEnd)
        {
            UpdateDups(ptrEdge1->SortEnd, ptrEdge2->SortEnd);
        }
        *split1 = TRUE;
        *split2 = FALSE;
        *dupIndex1 = ptrEdge2->SortBegin;
        *intersect1 = PathPts[*dupIndex1];
        return TRUE;
    }

    // case1: one is "inside" of another 
    //       ---------
    //   -----------------
    // In this case, the longer edge has to be broken into 3 pieces

    if (min1.Y < min2.Y && max1.Y > max2.Y)
    {
        // intersection points are the end points of the second edge
        // we are breaking up the first edge
        *split1 = TRUE;
        *split2 = FALSE;
        *split3 = TRUE;
        *dupIndex1 = ptrEdge2->SortBegin;
        *dupIndex2 = ptrEdge2->SortEnd;
        *intersect1 = PathPts[*dupIndex1];
        *intersect2 = PathPts[*dupIndex2];
        return TRUE;
    }
    else if(min1.Y > min2.Y && max1.Y < max2.Y)
    {
        // intersection points are the end points of the first edge
        // we are breaking up the second edge
        *split1 = FALSE;
        *split2 = TRUE;
        *split3 = TRUE;
        *dupIndex1 = ptrEdge1->SortBegin;
        *dupIndex2 = ptrEdge1->SortEnd;
        *intersect1 = PathPts[*dupIndex1];
        *intersect2 = PathPts[*dupIndex2];
        return TRUE;
    }


    // case3: edges overlap
    // ---------------
    //         -----------------
    // Each edge has to be broken up INT 2 pieces
    else if (max1.Y < max2.Y && min1.Y < min2.Y)
    {
        *split1 = TRUE;
        *split2 = TRUE;
        *dupIndex1 = ptrEdge2->SortBegin;
        *dupIndex2 = ptrEdge1->SortEnd;
        *intersect1 = PathPts[*dupIndex1];
        *intersect2 = PathPts[*dupIndex2];
        return TRUE;
    }
    else if (max2.Y < max1.Y && min2.Y < min1.Y)
    {
    //         -----------------
    // ---------------
        *split1 = TRUE;
        *split2 = TRUE;
        *dupIndex1 = ptrEdge2->SortEnd;
        *dupIndex2 = ptrEdge1->SortBegin;
        *intersect1 = PathPts[*dupIndex1];
        *intersect2 = PathPts[*dupIndex2];
        return TRUE;
    }

    WARNING(("Couldn't resolve overlapping edges"));
    return FALSE; // Shouldn't get here
}

/**************************************************************************\
*
* Function Description:
*
*  Break edge in 3 pieces.
*
* Arguments:
*
*
* Return Value:
*
*
* Created:
*
*   6/15/1999 t-wehunt
*
\**************************************************************************/

BOOL PathSelfIntersectRemover::BreakEdgeIn3(
    Edge *ptrEdge, 
    GpPointF *ptrPt1, 
    GpPointF *ptrPt2, 
    Edge *ptrNew1,
    Edge *ptrNew2, 
    INT dupIndex1, 
    INT dupIndex2
    )
{
    INT iptt1, ipto1;    // Indecies to the point arrays
    INT iptt2, ipto2;
    PointListNode ptord1; // Pointers to the linked list and point information
    PointListNode ptord2;
    PointListNode *pptordBeg = NULL;
    PointListNode *pptordEnd = NULL;

    // Let's first add the intersection points to the array of points.
    // Don't add identical points to the last point in the path.
    // iptt is the index of this point
    GpPointF &lastPt = PathPts.Last();
    if (ClosePt(*ptrPt1, lastPt))
    {
        return FALSE;
    }
    
    if (PathPts.Add(*ptrPt1) != Ok)
    {
        return FALSE;
    }
    else
    {
        iptt1 = (PathPts.GetCount())-1;
    }

    if (PathPts.Add(*ptrPt2) != Ok)
    {
        return FALSE;
    }
    else
    {
        iptt2 = (PathPts.GetCount())-1;
    }

    // we have to figure out how to link in the new points, it depends on
    // the direction of the new edge; iptt1 has the x coordinate <= than
    // iptt2.

    if (ptrEdge->Begin == ptrEdge->SortBegin)
    {
        // PointListNode record for the new point.
        ptord1.Prev = ptrEdge->Begin;
        ptord1.Next = iptt2;

        ptord2.Prev = iptt1;
        ptord2.Next = ptrEdge->End;
    }
    else
    {
        // PointListNode record for the new point.
        ptord1.Prev = iptt2;
        ptord1.Next = ptrEdge->End;

        ptord2.Prev = ptrEdge->Begin;
        ptord2.Next = iptt1;
    }

    // Update the duplicate field with the iptDup value passed in
    ptord1.Dup = dupIndex1;
    ptord2.Dup = dupIndex2;

    // Inside set to TRUE is the default
    ptord1.Inside = TRUE;
    ptord1.Used = FALSE;

    ptord2.Inside = TRUE;
    ptord2.Used = FALSE;

    // And now add it to the array.
    if (PtList.Add(ptord1) != Ok)
    {
        return FALSE;
    }
    else
    {
        ipto1 = (PtList.GetCount()-1);
    }

    if (PtList.Add(ptord2) != Ok)
    {
        return FALSE;
    }
    else
    {
        ipto2 = (PtList.GetCount()-1);
    }

    // Update ptord records for next and prev
    pptordBeg = &PtList[ptrEdge->Begin];
    pptordEnd = &PtList[ptrEdge->End];
    if (ptrEdge->Begin == ptrEdge->SortBegin)
    {
        pptordBeg->Next = ipto1;
        pptordEnd->Prev = ipto2;
    }
    else
    {
        pptordBeg->Next = ipto2;
        pptordEnd->Prev = ipto1;
    }

    // Both arrays - ptt and pto must have exactly the same # of elements
    ASSERTMSG((iptt2 == ipto2),("Assert failed."));

    //GpPointF pfpvBegin = *(PathPts.PGet(ptrEdge->SortBegin));
    //GpPointF pfpvEnd = *(PathPts.PGet(ptrEdge->SortEnd));

    // Lets create the new line segments.  The sorted order of 
    // end points is easy - intersection point must be before the SortEnd.
    ptrNew1->SortBegin = iptt1;
    ptrNew1->SortEnd = iptt2;

    // remember the original end point of the edge
    ptrNew1->OrigBegin = ptrEdge->OrigBegin;
    ptrNew1->OrigEnd = ptrEdge->OrigEnd;

    ptrNew2->SortBegin = iptt2;
    ptrNew2->SortEnd = ptrEdge->SortEnd;

    // remember the original end point of the edge
    ptrNew2->OrigBegin = ptrEdge->OrigBegin;
    ptrNew2->OrigEnd = ptrEdge->OrigEnd;

    // Also iptt (new point) becomes the new SortEnd of the old edge
    ptrEdge->SortEnd = iptt1;

    // Now, depending on whether the edge being broken up was swapped or not,
    // the new edges need to be swapped
    if (ptrEdge->Begin == ptrEdge->SortBegin)
    {
        // not swapped
        ptrEdge->End = iptt1;
        ptrNew1->Begin = ptrNew1->SortBegin;
        ptrNew1->End = ptrNew1->SortEnd;
        ptrNew2->Begin = ptrNew2->SortBegin;
        ptrNew2->End = ptrNew2->SortEnd;
    }
    else
    {
        // swapped
        ptrEdge->Begin = iptt1;
        ptrNew1->Begin = ptrNew1->SortEnd;
        ptrNew1->End = ptrNew1->SortBegin;
        ptrNew2->Begin = ptrNew2->SortEnd;
        ptrNew2->End = ptrNew2->SortBegin;
    }
    
    ptrNew1->Next = LIST_END;
    ptrNew2->Next = LIST_END;

    // If the point of intersection is on the scan line, we need to insert
    // the new edge to the Active table, otherwise to the table with edges
    // to process.

    if (CloseReal(XCur, ptrPt1->X))
    {
        MarkToAdd(ptrNew1);
    }
    else
    {
        if(Ok != EdgeList.Add(*ptrNew1))
        {
            return FALSE;  // out of memory
        }
        
        InsertEdgeIntoList(
            &InactiveEdgeList, 
            EdgeList.GetCount()-1, 
            CompareLine
        );
    }

    if (CloseReal(XCur, ptrPt2->X))
    {
        MarkToAdd(ptrNew2);
    }
    else
    {
        if(Ok != EdgeList.Add(*ptrNew2))
        {
            return FALSE;  // out of memory
        }
        
        InsertEdgeIntoList(
            &InactiveEdgeList, 
            EdgeList.GetCount()-1, 
            CompareLine
        );
    }

    return TRUE;
}

/**************************************************************************\
*
* Function Description:
*
*   Breaks edge ptrEdge.  We have found intersection point intersectPt, which is
*   guranteed to be somewhere on the line segment (not an end point).
*   The 'left' part of the edge will either remain in the active edges
*   or will be removed (only if the intersection point has the current
*   x value.  In the latter case, the right edge segment will need to be
*   inserted to active edges, otherwise (the former case) it will go
*   to InactiveEdgeList.  If it needs to go to active edges, Breakedge cannot
*   insert it because it would disrupt the order of edges there before
*   both edges broken up are handled.  The caller would have to handle
*   the insertion in such case.  Therefore, we return the new line
*   segment newEdge and a BOOL value specifying if the caller has to insert 
*   the newEdge edge.
*   dupIndex is the index of the duplicate point created by this intersection:
*   When two edges intersect, we have to insert two points (identical)
*   to maintain the same shape of the polygon.  These two points are
*   called duplicates.
*   Return FALSE on out of memory.
*
* Arguments:
*
*
* Return Value:
*
*
* Created:
*
*   6/15/1999 t-wehunt
*
\**************************************************************************/

BOOL PathSelfIntersectRemover::BreakEdge(
    Edge *ptrEdge, 
    GpPointF *intersectPt, 
    Edge *newEdge, 
    INT dupIndex
    )
{
    INT iptt, ipto;    // Indecies to the point arrays
    PointListNode ptNode; // Pointers to the linked list and point information
    PointListNode *ptNodeBeg = NULL;
    PointListNode *ptNodeEnd = NULL;

    // Let's first add the intersection point to the array of points.

    if (PathPts.Add(*intersectPt) != Ok)
    {
        return FALSE;
    }
    else
    {
        iptt = (PathPts.GetCount())-1;
    }

    // PointListNode record for the new point.  It is in the middle of the 
    // edge, so Begin and End point of the edge will be its previous and next
    ptNode.Prev = ptrEdge->Begin;
    ptNode.Next = ptrEdge->End;
    // Update the duplicate field with the dupIndex value passed in
    ptNode.Dup = dupIndex;
    // Inside set to TRUE is the default
    ptNode.Inside = TRUE;
    ptNode.Used = FALSE;

    // And now add it to the array.
    if (PtList.Add(ptNode) != Ok)
    {
        return FALSE;
    }
    else
    {
        ipto = (PtList.GetCount()-1);
    }

    // Update ptNode records for next and prev
    ptNodeBeg = &PtList[ptrEdge->Begin];
    ptNodeEnd = &PtList[ptrEdge->End];
    ptNodeBeg->Next = ipto;
    ptNodeEnd->Prev = ipto;

    // Both arrays - ptt and pto must have exactly the same # of elements
    ASSERTMSG((iptt == ipto),("Assert failed."));

    // remember the original end point of the edge
    newEdge->OrigBegin = ptrEdge->OrigBegin;
    newEdge->OrigEnd = ptrEdge->OrigEnd;

    // Lets create the new line segment.  The sorted order of end points 
    // is easy - intersection point must be before the SortEnd.
    newEdge->SortBegin = iptt;
    newEdge->SortEnd = ptrEdge->SortEnd;

    // Also iptt (new point) becomes the new SortEnd of the old edge
    ptrEdge->SortEnd = iptt;

    // Now, depending on whether the edge being broken up was swapped or not,
    // the new edges need to be swapped
    if (ptrEdge->Begin == ptrEdge->SortBegin)
    {
        // not swapped
        ptrEdge->End = iptt;
        newEdge->Begin = newEdge->SortBegin;
        newEdge->End = newEdge->SortEnd;
    }
    else
    {
        // swapped
        ptrEdge->Begin = iptt;
        newEdge->Begin = newEdge->SortEnd;
        newEdge->End = newEdge->SortBegin;
    }
    
    newEdge->Next = LIST_END;

    // If the point of intersection is on the scan line, we need to insert
    // the new edge to the Active table, otherwise to the table with edges
    // to process.

    if (CloseReal(XCur, intersectPt->X))
    {
        MarkToAdd(newEdge);
    }
    else
    {
        if(Ok != EdgeList.Add(*newEdge))
        {
            return FALSE;  // out of memory
        }
        
        InsertEdgeIntoList(
            &InactiveEdgeList, 
            EdgeList.GetCount()-1, 
            CompareLine
        );
    }

    return TRUE;
}

/**************************************************************************\
*
* Function Description:
*
*   Eliminate Self Intersections in a widened path
*
* Arguments:
*
*
* Return Value:
*
*
* Created:
*
*   6/15/1999 t-wehunt
*
\**************************************************************************/

GpStatus PathSelfIntersectRemover::RemoveSelfIntersects()
{
    CanAddPts = FALSE;

    // ------  Phase 1:
    
    INT count = EdgeList.GetCount();
    if (count <= 0)
    {
        return Ok;  //nothing to correct
    }

    // Sort all the edges in EdgeList array.
    
    Edge *edges = EdgeList.GetDataBuffer();
    QuickSortEdges(edges, edges+count-1);
    
    InactiveEdgeList = 0;   // Point to the first element in the inactive list.
    
    // Initialize the linked list Next pointers:
    
    for(int i = 0; i < count-1; i++)
    {
        EdgeList[i].Next = i+1;
    }
    
    EdgeList[i].Next = LIST_END;

    if (!FindIntersects())
    {
        return GenericError;
    }
    
    
    // ------  Phase 2:
    
    // FindIntersects orphans all the edges from the list. Reconstruct and 
    // re-sort using QuickSort. This works out faster because the incremental
    // sort during FindIntersects would have been at least O(n^2).
    
    count = EdgeList.GetCount(); 
    
    // we never actually delete anything from the array - only from the 
    // linked list, so if we had count > 0 above, we must have a larger or
    // the same count now.
    
    ASSERT(count > 0);
    
    // Sort all the edges in the EdgeList array.
    
    edges = EdgeList.GetDataBuffer();
    QuickSortEdges(edges, edges+count-1);
    
    InactiveEdgeList = 0;   // Point to the first element in the inactive list.
    
    // Initialize the linked list Next pointers:
    
    for(int i = 0; i < count-1; i++)
    {
        EdgeList[i].Next = i+1;
    }
    
    EdgeList[i].Next = LIST_END;

    if(!EliminatePoints())
    {
        return GenericError;
    }
    
    // ... move on to phase 3 - collection.
    
    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   Eliminate Self Intersections.
*
*   This is considered 'Phase 2' of the algorithm.
*
* Arguments:
*
*
* Return Value:
*
*
* Created:
*
*   6/15/1999 t-wehunt
*
\**************************************************************************/

BOOL PathSelfIntersectRemover::EliminatePoints()
{
    // Initialize the array of active edges.
    // Take the first edge from the edge array and add it to the active edgs.
    // Add all other edges, which start at the same x.

    if (InactiveEdgeList == LIST_END)
    {
        return FALSE;
    }

    XCur = PathPts[EdgeList[InactiveEdgeList].SortBegin].X;

    // "move" all edges starting at xCur to the active edge array
    // PathPts in the active edge array will be sorted by y for the
    // given xCur.
    
    AddActiveForXScan(&InactiveEdgeList);

    // As long as the Active edge array is not empty, keep scanning
    
    while (TRUE)
    {
        // Scan the active edge array for the current XCur;
        if (!ScanActive())
        {
            return FALSE;
        }

        RemoveVertAll();

        // Update the XCur using edges from InactiveEdgeList
        if (!ClosestActive(InactiveEdgeList))
        {
            break;
        }

        // Remove all edges which end BEFORE XCur;
        
        ClearActiveListExclusiveX();

        // Add new edges, which begin at XCur
        AddActiveForXScan(&InactiveEdgeList);
    }
    return TRUE;
}


/**************************************************************************\
*
* Function Description:
*
*    Scan through all active edges during the phase of edge elimination.
*    Calculates winding number to the left and to the right of the current
*    x value - XCur.  Whenever finds an edge which has 0 winding number
*    on one side, marks it as an outside edge.
*
* Arguments:
*
*
* Return Value:
*
*
* Created:
*
*   6/15/1999 t-wehunt
*
\**************************************************************************/

BOOL PathSelfIntersectRemover::ScanActive()
{
    Edge *ptrEdge = NULL;
    Edge *plnNext = NULL;

    GpPointF *pfpvBegin = NULL;
    GpPointF *pfpvEnd = NULL;

    // We are starting from the outside.
    INT lwindLeft = 0;
    INT lwindRight = 0;

    // Look at all edges in the ective edge array.
    INT index = ActiveEdgeList;
    
    while (index != LIST_END)
    {
        ptrEdge = &EdgeList[index];
        index = ptrEdge->Next;

        // Get the end points
        ASSERTMSG((ptrEdge->SortBegin < PathPts.GetCount()), ("FATAL ERROR."));
        pfpvBegin = &PathPts[ptrEdge->SortBegin];

        ASSERTMSG((ptrEdge->SortEnd < PathPts.GetCount()), ("FATAL ERROR."));
        pfpvEnd = &PathPts[ptrEdge->SortEnd];

        // Is it vertical?
        if (ptrEdge->IsVertical())
        {
            if (NewInterval(ptrEdge))
            {
                if (lwindLeft == 0 || lwindRight == 0)
                {
                    MarkVertOutside();
                }
            }
            RemoveVert(ptrEdge->YCur, TRUE /*inclusive*/);

            //add it to the active vertical edges
            //Edge insertion
            if (ActiveVertEdges.InsertSorted(*ptrEdge, 
                (DynSortArrayCompareFunc)&(CompareVertLine),
                this) != Ok)
            {
                return FALSE;
            }
        }
        else
        {
            if (lwindLeft == 0 || lwindRight == 0)
            {
                MarkVertOutside();
            }

            RemoveVert(ptrEdge->YCur, TRUE /*inclusive*/);

            // Edge is not vertical, does it have an end point 
            // on this scan line
            if ((!CloseReal(pfpvBegin->X, XCur)) && 
                (!CloseReal(pfpvEnd->X, XCur)))
            {
                // we are crossing edge in the middle, so both winding numbers
                // need to be updated
                if (lwindLeft == 0 || lwindRight == 0)
                {
                    ptrEdge->MarkOutside();
                }
                if (ptrEdge->SortBegin == ptrEdge->Begin)
                {
                    lwindLeft++;
                    lwindRight++;
                }
                else
                {
                    lwindLeft--;
                    lwindRight--;
                }
                if (lwindLeft == 0 || lwindRight == 0)
                {
                    ptrEdge->MarkOutside();
                }
            }
            else if ((CloseReal(pfpvBegin->X, XCur)) && 
                    (!CloseReal(pfpvEnd->X, XCur)))
            {
                //right edge
                if (lwindRight == 0)
                {
                    ptrEdge->MarkOutside();
                }
                if (ptrEdge->SortBegin == ptrEdge->Begin)
                {
                    lwindRight++;
                }
                else
                {
                    lwindRight--;
                }
                if (lwindRight == 0)
                {
                    ptrEdge->MarkOutside();
                }
            }
            else if ((!CloseReal(pfpvBegin->X, XCur)) && 
                      (CloseReal(pfpvEnd->X, XCur)))
            {
                //left edge
                if (lwindLeft == 0)
                {
                    ptrEdge->MarkOutside();
                }
                if (ptrEdge->SortBegin == ptrEdge->Begin)
                {
                    lwindLeft++;
                }
                else
                {
                    lwindLeft--;
                }
                if (lwindLeft == 0)
                {
                    ptrEdge->MarkOutside();
                }
            }
            else
            {

                WARNING(("Edge is not vertical, but not in XCur"));
            }
            // if we crossed to te outside, all current vertical edges need 
            // to be marked
            if (lwindLeft == 0 || lwindRight == 0)
            {
                MarkVertOutside();
            }
            RemoveVert(ptrEdge->YCur, TRUE /*inclusive*/);
        }
        
    }
    return TRUE;
}

/**************************************************************************\
*
* Function Description:
*
*  Mark the one or two of the current vertical edges as outside.
*  If there is an even number of edge going in both directions, it means that
*  the winding number is the same on both sides.  Since we are being called,
*  it must be 0.  In this case, we pick one edge going up and one edge going
*  down and mark both of them as outside.
*  If there is more edges going in one direction than another, then the winding
*  numbers are different, but one of them is 0.  We pick one of the edges from
*  that set edges (up or down) which is larger.  So if more edges go down, we
*  pick one of those edges and mark them as outside.
*
* Arguments:
*
*
* Return Value:
*
*
* Created:
*
*   6/15/1999 t-wehunt
*
\**************************************************************************/

VOID PathSelfIntersectRemover::MarkVertOutside()
{
    Edge *ptrEdge = NULL;
    INT index = 0;
    INT ndown = 0;
    INT nup = 0;
    INT idown = -1;
    INT iup = -1;

    // we will mark the first one

    while (index < ActiveVertEdges.GetCount() )
    {
        //PGet on edges
        ptrEdge = &ActiveVertEdges[index];
        if (ptrEdge->SortBegin == ptrEdge->Begin)
        {
            //goes down
            ndown++;
            idown = index;
        }
        else
        {
            nup++;
            iup = index;
        }
        index++;
    }

    if (ndown > nup)
    {
        //PGet on edges
        ptrEdge = &ActiveVertEdges[idown];
        ptrEdge->MarkOutside();
    }
    else if (nup > ndown)
    {
        //PGet on edges
        ptrEdge = &ActiveVertEdges[iup];
        ptrEdge->MarkOutside();
    }
    else
    {
        if (nup != 0)
        {
            if (iup > -1)
            {
                //PGet on edges
                ptrEdge = &ActiveVertEdges[iup];
                ptrEdge->MarkOutside();
            }
        }
        if (ndown != 0)
        {
            if (idown > -1)
            {
                //PGet on edges
                ptrEdge = &ActiveVertEdges[idown];
                ptrEdge->MarkOutside();
            }
        }
    }
}

/**************************************************************************\
*
* Function Description:
*
*    Returns TRUE if edge ptrEdge belongs to a different interval than the
*    edges currently stored in ActiveVertEdges.
*
* Arguments:
*
*
* Return Value:
*
*
* Created:
*
*   6/15/1999 t-wehunt
*
\**************************************************************************/

BOOL PathSelfIntersectRemover::NewInterval(Edge *ptrEdge)
{
    Edge *plnOld;
    
    if (ActiveVertEdges.GetCount() <= 0)
    {
        return FALSE;
    }

    //PGet on edges
    plnOld = &ActiveVertEdges.First();

    REAL fpY1, fpY2;

    fpY1 = PathPts[plnOld->SortEnd].Y;
    fpY2 = PathPts[ptrEdge->SortEnd].Y;
    
    if (CloseReal(fpY1, fpY2))
    {
        return FALSE;
    }

    if (fpY1 < fpY2)
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

/**************************************************************************\
*
* Function Description:
*
*  Remove all the edges from the active edge array.
*
* Arguments:
*
*
* Return Value:
*
*
* Created:
*
*   6/15/1999 t-wehunt
*
\**************************************************************************/

VOID PathSelfIntersectRemover::RemoveVertAll()
{
    if( ActiveVertEdges.GetCount() > 0)
    {
        ActiveVertEdges.Reset(FALSE);
    }
}

/**************************************************************************\
*
* Function Description:
*
*  Remove vertical edges which have end points below given y value.
*
* Arguments:
*
*
* Return Value:
*
*
* Created:
*
*   6/15/1999 t-wehunt
*
\**************************************************************************/

VOID PathSelfIntersectRemover::RemoveVert(REAL y, BOOL inclusive)
{
    Edge *ptrEdge = NULL;

    // edges are sorted, so as soon as we find an end point with y value > y
    // we are done
    while (ActiveVertEdges.GetCount() > 0)
    {
        //PGet on edges
        ptrEdge = &ActiveVertEdges.First();
        REAL fpY;
        fpY = PathPts[ptrEdge->SortEnd].Y;
        if (inclusive)
        {
            if (fpY < y || CloseReal(fpY,y))
            {
                ActiveVertEdges.DeleteAt(0);
            }
            else
            {
                return;
            }
        }
        else
        {
            if (fpY < y && (!CloseReal(fpY,y)))
            {
                ActiveVertEdges.DeleteAt(0);
            }
            else
            {
                return;
            }
        }
    }
}

/**************************************************************************\
*
* Function Description:
*
*  Scan the ActiveEdgeList for all edges which end at XCur (inclusive) and
*  simply orphan them. This is used in the first phase of the algorithm
*  (FindIntersects) which passes each edge from the InactiveEdgeList through
*  the ActiveEdgeList. When the edges are no longer needed they're removed
*  from all lists.
*
* Created
*
*  12/27/2000 asecchia
*
\**************************************************************************/

void PathSelfIntersectRemover::ClearActiveListInclusiveX()
{
    INT *pIndex = &ActiveEdgeList;
    
    while(*pIndex != LIST_END)
    {
        Edge *pEdge = &EdgeList[*pIndex];
        GpPointF *pSortEnd = &PathPts[pEdge->SortEnd];

        // inclusive check.
        
        if((pSortEnd->X < XCur) || CloseReal(pSortEnd->X, XCur))
        {
            // delete the item and advance.
            
            *pIndex = pEdge->Next;     // point past the deleted item. 
            pEdge->Next = LIST_END;    // disconnect the deleted item. 
        }
        else
        {
            pIndex = &EdgeList[*pIndex].Next;
        }
    }
}

/**************************************************************************\
*
* Function Description:
*
*  Remove from ActiveEdgeList all edges which end at XCur. This uses
*  an exclusive check. This code is used for the second phase of the algorithm
*  (EliminatePoints). Each edge removed is orphaned from the list because
*  the linked list representation will not be used after this phase.
*
* Created:
*
*    12/23/2000 asecchia
*
\**************************************************************************/

void PathSelfIntersectRemover::ClearActiveListExclusiveX()
{
    INT *pIndex = &ActiveEdgeList;
    
    while(*pIndex != LIST_END)
    {
        Edge *pEdge = &EdgeList[*pIndex];
        GpPointF *pSortEnd = &PathPts[pEdge->SortEnd];

        // exclusive check.
        
        if((pSortEnd->X < XCur) && !CloseReal(pSortEnd->X, XCur))
        {
            // delete the item and advance.
            
            *pIndex = pEdge->Next;     // point past the deleted item. 
            pEdge->Next = LIST_END;    // disconnect the deleted item. 
        }
        else
        {
            pIndex = &EdgeList[*pIndex].Next;
        }
    }
}

/**************************************************************************\
*
* Function Description:
*
*    Add all edges with begin point at xCur to the active edge table.
*    Update the index piLn to the edge array to point to the next edge, which
*    will have to be considered.
*
* Arguments:
*
*
* Return Value:
*
*
* Created:
*
*   6/15/1999 t-wehunt
*
\**************************************************************************/

void PathSelfIntersectRemover::AddActiveForX(INT *inactiveHead)
{
    // We have a new current x, let's calculate new curent Y's for each edge
    // They are needed to insert the new active edges in the right order
    
    RecalcActiveYCur();
    
    InsertNewEdges(
        &ActiveEdgeList,  // insert
        inactiveHead,     // remove
        XCur,
        CompareYCurLine
    );
}

/**************************************************************************\
*
* Function Description:
*
*    Add all edges with begin point at xCur to the active edge table.
*    Update the index piLn to the edge array to point to the next edge, which
*    will have to be considered.
*
* Arguments:
*
*
* Return Value:
*
*
* Created:
*
*   6/15/1999 t-wehunt
*
\**************************************************************************/

void PathSelfIntersectRemover::AddActiveForXScan(INT *inactiveHead)
{
    // We have a new current x, let's calculate new curent Y's for each edge
    // They are needed to insert the new active edges in the right order
    
    RecalcActiveYCur();

    InsertNewEdges(
        &ActiveEdgeList,   // insert
        inactiveHead,      // remove
        XCur,
        CompareYScanCurLine
    );
}

/**************************************************************************\
*
* Function Description:
*
*  Calculate the yCur position for each edge in the active edge table.
*
* Arguments:
*
*
* Return Value:
*
*
* Created:
*
*   6/15/1999 t-wehunt
*
\**************************************************************************/

VOID PathSelfIntersectRemover::RecalcActiveYCur(VOID)
{
    REAL dx = 0;
    REAL dy = 0;
    REAL dxCur = 0;

    GpPointF fpvBegin(0,0);
    GpPointF fpvEnd(0,0);
    GpPointF fpvOrigBegin(0,0);
    GpPointF fpvOrigEnd(0,0);

    Edge *ptrEdge = NULL;
    INT active = ActiveEdgeList;

    // Go through all active egdes
    
    while(active != LIST_END)
    {
        ptrEdge = &EdgeList[active];

        // If the edge will have an end point at XCur,
        // use this end point's y value.
        
        fpvBegin = PathPts[ptrEdge->SortBegin];
        fpvEnd = PathPts[ptrEdge->SortEnd];
        fpvOrigBegin = PathPts[ptrEdge->OrigBegin];
        fpvOrigEnd = PathPts[ptrEdge->OrigEnd];
        
        if ((XCur == fpvEnd.X) || (fpvEnd.X == fpvBegin.X))
        {
            ptrEdge->YCur = fpvEnd.Y;
        }
        else
        {
            // Calculate the slope numerator and denominator
            dx = fpvOrigEnd.X - fpvOrigBegin.X;
            dy = fpvOrigEnd.Y - fpvOrigBegin.Y;
            dxCur = XCur - fpvOrigBegin.X;
            ptrEdge->YCur = dy * dxCur / dx + fpvOrigBegin.Y;
        }
        
        active = EdgeList[active].Next;
    }
}

/**************************************************************************\
*
* Function Description:
*
*   Compare two lines.  Lines are sorted based on the yCur value.  
*   If yCur's are identical, lines are sorted based on the begin point.
*
* Arguments:
*
*
* Return Value:
*
*   -1 if ptrEdge1 < ptrEdge2
*    0 if ther are equal
*    1 if ptrEdge1 > ptrEdge2
*
* Created:
*
*   6/15/1999 t-wehunt
*
\**************************************************************************/

INT 
CompareYScanCurLine(
    PathSelfIntersectRemover *ptrCorrector, 
    Edge *ptrEdge1, 
    Edge *ptrEdge2
    )
{
    if (!ptrEdge1->CloseReal(ptrEdge1->YCur, ptrEdge2->YCur))
    {   
        if(ptrEdge1->YCur < ptrEdge2->YCur)
        {
            return -1;
        }
        if(ptrEdge1->YCur > ptrEdge2->YCur)
        {
            return 1;
        }
    }
    // All left and vertical edges need to go before right edges if they have
    // the same yCur;
    // A left edge has a begin point < xCur, right edge x = xCur

    BOOL fLeft1 = TRUE;
    BOOL fLeft2 = TRUE;

    fLeft1 = ((ptrCorrector->PathPts[ptrEdge1->SortBegin].X < 
               ptrCorrector->XCur                                    &&
               ptrEdge1->CloseReal(ptrCorrector->PathPts[ptrEdge1->SortEnd].X,
                         ptrCorrector->XCur))                        ||
               ptrEdge1->IsVertical());
    fLeft2 = ((ptrCorrector->PathPts[ptrEdge2->SortBegin].X < 
               ptrCorrector->XCur                                    &&
               ptrEdge2->CloseReal(ptrCorrector->PathPts[ptrEdge2->SortEnd].X,
                         ptrCorrector->XCur))                        ||
               ptrEdge2->IsVertical());

    if (fLeft1 && (!fLeft2))
        return 1;
    if ((!fLeft1) && fLeft2)
        return -1;

    REAL slope1(0.0);
    REAL slope2(0.0);

    // For vertical edges, we actually store them as +/-INF, and 
    // can use the sign to determine the direction.
    
    if (ptrEdge1->IsVertical())
    {
        // Avoid (inf x 0) which causes a real indefinite.
        
        if( REALABS(
            ptrCorrector->PathPts[ptrEdge1->OrigEnd].Y - 
            ptrCorrector->PathPts[ptrEdge1->OrigBegin].Y
            ) > REAL_EPSILON
        )
        {
            slope1 = SignReal( ptrCorrector->PathPts[ptrEdge1->OrigEnd].Y
                - ptrCorrector->PathPts[ptrEdge1->OrigBegin].Y) 
                * FP_INF;
        }
    }
    else
    {
        // Avoid divide by zero.
        
        if( REALABS(
            ptrCorrector->PathPts[ptrEdge1->OrigEnd].X - 
            ptrCorrector->PathPts[ptrEdge1->OrigBegin].X 
            ) > REAL_EPSILON
        )
        {
            slope1 = ptrCorrector->PathPts[ptrEdge1->OrigEnd].Y
                            - ptrCorrector->PathPts[ptrEdge1->OrigBegin].Y;
    
            slope1 = slope1 /
                            (ptrCorrector->PathPts[ptrEdge1->OrigEnd].X
                            - ptrCorrector->PathPts[ptrEdge1->OrigBegin].X);
        }
    }

    if (ptrEdge2->IsVertical())
    {
        // Avoid (inf x 0) which causes a real indefinite.
        
        if( REALABS(
            ptrCorrector->PathPts[ptrEdge2->OrigEnd].Y - 
            ptrCorrector->PathPts[ptrEdge2->OrigBegin].Y
            ) > REAL_EPSILON
        )
        {
            slope2 = SignReal(ptrCorrector->PathPts[ptrEdge2->OrigEnd].Y
                - ptrCorrector->PathPts[ptrEdge2->OrigBegin].Y)
                * FP_INF;
        }
    }
    else
    {
        // Avoid divide by zero.
        
        if( REALABS(
            ptrCorrector->PathPts[ptrEdge2->OrigEnd].X - 
            ptrCorrector->PathPts[ptrEdge2->OrigBegin].X
            ) > REAL_EPSILON
        )
        {
            slope2 = ptrCorrector->PathPts[ptrEdge2->OrigEnd].Y
                            - ptrCorrector->PathPts[ptrEdge2->OrigBegin].Y;
    
            slope2 = slope2 /
                            (ptrCorrector->PathPts[ptrEdge2->OrigEnd].X
                            - ptrCorrector->PathPts[ptrEdge2->OrigBegin].X);
        }
    }

    if (slope1 < slope2)
        return -1;

    if (slope1 > slope2)
        return 1;

    // slopes are equal

    if (ptrCorrector->PathPts[ptrEdge1->SortEnd].Y < 
        ptrCorrector->PathPts[ptrEdge2->SortEnd].Y)
        return -1;

    if (ptrCorrector->PathPts[ptrEdge1->SortEnd].Y > 
        ptrCorrector->PathPts[ptrEdge2->SortEnd].Y)
        return 1;

    // (ptrCorrector->PathPts.PGet(ptrEdge1->SortEnd))->Y == 
    // (ptrCorrector->PathPts.PGet(ptrEdge2->SortEnd))->Y

    if (ptrCorrector->PathPts[ptrEdge1->SortEnd].X < 
        ptrCorrector->PathPts[ptrEdge2->SortEnd].X)
        return -1;

    if (ptrCorrector->PathPts[ptrEdge1->SortEnd].X > 
        ptrCorrector->PathPts[ptrEdge2->SortEnd].X)
        return 1;

    // Now, all point coordinates are exactly the same, but in some cases,
    // we may have two identical edges with the coordinates, these edges 
    // may have different points (actual indecies into points array, not 
    // coordinate values). We want to consider them as identical only if 
    // the indecies are the same.

    if (ptrEdge1->SortBegin < ptrEdge2->SortBegin)
        return -1;

    if (ptrEdge1->SortBegin > ptrEdge2->SortBegin)
        return 1;

    if (ptrEdge1->SortEnd < ptrEdge2->SortEnd)
        return -1;

    if (ptrEdge1->SortEnd > ptrEdge2->SortEnd)
        return 1;

    return 0;
}

/**************************************************************************\
*
* Function Description:
*
*   Compare two lines.  Lines are sorted based on the yCur value.
*   If yCur's are identical, lines are sorted based on the begin point.
*
* Arguments:
*
*
* Return Value:
*
*   -1 if ptrEdge1 < ptrEdge2
*    0 if ther are equal
*    1 if ptrEdge1 > ptrEdge2
*
* Created:
*
*   6/15/1999 t-wehunt
*
\**************************************************************************/

INT 
CompareYCurLine(
    PathSelfIntersectRemover *ptrCorrector, 
    Edge *ptrEdge1, 
    Edge *ptrEdge2
    )
{
    if (!ptrEdge1->CloseReal(ptrEdge1->YCur, ptrEdge2->YCur))
    {
        if(ptrEdge1->YCur < ptrEdge2->YCur)
            return -1;

        if(ptrEdge1->YCur > ptrEdge2->YCur)
            return 1;
    }

    // We have to sort based on slope.

    REAL slope1(0.0);
    REAL slope2(0.0);

    // For vertical edges, we actually store them as +/-INF, and 
    // can use the sign to determine the direction.
    if (ptrEdge1->IsVertical())
    {
        // Avoid INF * 0.
        
        if( REALABS(
            ptrCorrector->PathPts[ptrEdge1->OrigEnd].Y - 
            ptrCorrector->PathPts[ptrEdge1->OrigBegin].Y
            ) > REAL_EPSILON
        )
        {
            
            slope1 = SignReal(
                ptrCorrector->PathPts[ptrEdge1->OrigEnd].Y - 
                ptrCorrector->PathPts[ptrEdge1->OrigBegin].Y ) * FP_INF;
        }
    }
    else
    {
        // Avoid divide by zero.
        
        if( REALABS(
            ptrCorrector->PathPts[ptrEdge1->OrigEnd].X - 
            ptrCorrector->PathPts[ptrEdge1->OrigBegin].X
            ) > REAL_EPSILON
        )
        {
            slope1 = ptrCorrector->PathPts[ptrEdge1->OrigEnd].Y
                            - ptrCorrector->PathPts[ptrEdge1->OrigBegin].Y;
    
            slope1 = slope1 /
                            (ptrCorrector->PathPts[ptrEdge1->OrigEnd].X
                            - ptrCorrector->PathPts[ptrEdge1->OrigBegin].X);
        }
    }

    if (ptrEdge2->IsVertical())
    {
        // Avoid INF * 0.
        
        if( REALABS(
            ptrCorrector->PathPts[ptrEdge2->OrigEnd].Y - 
            ptrCorrector->PathPts[ptrEdge2->OrigBegin].Y
            ) > REAL_EPSILON
        )
        {
            slope2 = SignReal(
                ptrCorrector->PathPts[ptrEdge2->OrigEnd].Y - 
                ptrCorrector->PathPts[ptrEdge2->OrigBegin].Y) * FP_INF;
        }
    }
    else
    {
        // Avoid divide by zero.
        
        if( REALABS( 
            ptrCorrector->PathPts[ptrEdge2->OrigEnd].X -
            ptrCorrector->PathPts[ptrEdge2->OrigBegin].X
            ) > REAL_EPSILON
        )
        {
            slope2 = ptrCorrector->PathPts[ptrEdge2->OrigEnd].Y - 
                     ptrCorrector->PathPts[ptrEdge2->OrigBegin].Y;
    
            slope2 = slope2 /
                            (ptrCorrector->PathPts[ptrEdge2->OrigEnd].X
                            - ptrCorrector->PathPts[ptrEdge2->OrigBegin].X);
        }
    }

    if (slope1 < slope2)
        return -1;

    if (slope1 > slope2)
        return 1;

    // slopes are equal

    if (ptrCorrector->PathPts[ptrEdge1->SortEnd].Y < 
        ptrCorrector->PathPts[ptrEdge2->SortEnd].Y)
        return -1;

    if (ptrCorrector->PathPts[ptrEdge1->SortEnd].Y > 
        ptrCorrector->PathPts[ptrEdge2->SortEnd].Y)
        return 1;

    // (ptrCorrector->PathPts.PGet(ptrEdge1->SortEnd))->Y == 
    // (ptrCorrector->PathPts.PGet(ptrEdge2->SortEnd))->Y

    if (ptrCorrector->PathPts[ptrEdge1->SortEnd].X < 
        ptrCorrector->PathPts[ptrEdge2->SortEnd].X)
        return -1;

    if (ptrCorrector->PathPts[ptrEdge1->SortEnd].X > 
        ptrCorrector->PathPts[ptrEdge2->SortEnd].X)
        return 1;

    // Now, all point coordinates are exactly the same, but in some cases,
    // we may have two identical edges with the coordinates, these edges 
    // may have different points (actual indecies into points array, not 
    // coordinate values). We want to consider them as identical only if the 
    // indecies are the same.

    if (ptrEdge1->SortBegin < ptrEdge2->SortBegin)
        return -1;

    if (ptrEdge1->SortBegin > ptrEdge2->SortBegin)
        return 1;

    if (ptrEdge1->SortEnd < ptrEdge2->SortEnd)
        return -1;

    if (ptrEdge1->SortEnd > ptrEdge2->SortEnd)
        return 1;

    return 0;
}

/**************************************************************************\
*
* Function Description:
*
*  Compares lines based on the y coordinate of the end point.
*
* Arguments:
*
*
* Return Value:
*
*
* Created:
*
*   6/15/1999 t-wehunt
*
\**************************************************************************/

INT
CompareVertLine(
    PathSelfIntersectRemover *ptrCorrector, 
    Edge *ptrEdge1, 
    Edge *ptrEdge2
    )
{
    if(ptrCorrector->PathPts[ptrEdge1->SortEnd].Y < 
        ptrCorrector->PathPts[ptrEdge2->SortEnd].Y)
        return -1;

    if(ptrCorrector->PathPts[ptrEdge1->SortEnd].Y > 
        ptrCorrector->PathPts[ptrEdge2->SortEnd].Y)
        return 1;

    if(ptrCorrector->PathPts[ptrEdge1->SortBegin].Y < 
        ptrCorrector->PathPts[ptrEdge2->SortBegin].Y)
        return -1;

    if(ptrCorrector->PathPts[ptrEdge1->SortBegin].Y > 
        ptrCorrector->PathPts[ptrEdge2->SortBegin].Y)
        return 1;

    // Now, all point coordinates are exactly the same, but in some cases, 
    // we may have two identical edges with the coordinates, these edges may 
    // have different points (actual indecies into points array, not 
    // coordinate values). We want to consider them as identical only if the 
    // indecies are the same.

    if (ptrEdge1->SortBegin < ptrEdge2->SortBegin)
        return -1;

    if (ptrEdge1->SortBegin > ptrEdge2->SortBegin)
        return 1;

    if (ptrEdge1->SortEnd < ptrEdge2->SortEnd)
        return -1;

    if (ptrEdge1->SortEnd > ptrEdge2->SortEnd)
        return 1;

    return 0;
}

/**************************************************************************\
*
* Function Description:
*
*    Finds the x value of the closest end point (in x) - the next scan line.
*    Depending on the phase of the algorithm, it needs to look at edges in
*    different arrays.  The new value is stored in XCur.
*    Returns FALSE if there are no more points to look at - we are done.
*    In this case, XCur is set to longLast.
*
* Arguments:
*
*
* Return Value:
*
*
* Created:
*
*   6/15/1999 t-wehunt
*
\**************************************************************************/

BOOL PathSelfIntersectRemover::ClosestActive(INT arrayIndex)
{
    REAL xClosest = 0;

    // We need to find the next X value for the scan line:
    // take the minimum of any end point of active edges and the begin point
    // of the first edge which will be inserted to active edges.

    // Let's first look at the possible new edge
    
    if (arrayIndex == LIST_END)       // no more edges to add
    {
        xClosest = FP_INF;
    }
    else
    {
        xClosest = PathPts[EdgeList[arrayIndex].SortBegin].X;
    }

    INT active = ActiveEdgeList;

    // Now, look at all active edges
    
    while (active != LIST_END)
    {
        REAL xActive = PathPts[EdgeList[active].SortEnd].X;
        
        if((xClosest > xActive) && 
           (xActive > XCur) && 
           (!CloseReal(xActive, XCur)))
        {
            xClosest = xActive;
        }
        
        active = EdgeList[active].Next;
    }
    
    if (xClosest != FP_INF)
    {
        XCur = xClosest;
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

/**************************************************************************\
*
* Function Description:
*
*   Returns the new path.  New path contains of 1 or more subpaths.
*   The subpaths are stored as a list of points and a list of points 
*   per polygon.
*
* Arguments:
*
*
* Return Value:
*
*
* Created:
*
*   6/15/1999 t-wehunt
*
\**************************************************************************/

GpStatus PathSelfIntersectRemover::GetNewPoints(
    DynPointFArray *pts, 
    DynIntArray *polyCounts
    )
{
    GpPointF *pptToCopy = NULL;
    INT iptFirst = 0;
    GpStatus status;

    if (PathPts.GetCount() <= 0)
    {
        return Ok;
    }

    if (PtList.GetCount() <= 0)
    {
        return Ok;
    }

    // Initialize the array which will contain the resulting paths
    // We don't know haw many points we are going to have
    // Guess?  TODO!
    if ((status = pts->ReserveSpace(2*PathPts.GetCount()/3)) != Ok)
    {
        return status;
    }

    if ((status = polyCounts->ReserveSpace(2*PathPts.GetCount())) != Ok)
    {
        return status;
    }

    // Collect paths as long as there are unused (outside) points
    INT cptOld = 0;
    INT npt = 0;

    while (!AllPointsUsed(&iptFirst))
    {
        if (!CollectPath(iptFirst))
        {
            return GenericError;
        }
        // How many points do we have in the last path?
        npt = ResultPts.GetCount() - cptOld;
        // Add the point count to the poly array
        if ((status = polyCounts->Add(npt)) != Ok)
        {
            return status;
        }
        // Save the count of points
        cptOld = ResultPts.GetCount();
    }

    pts->ReplaceWith(&ResultPts);

    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*    Return TRUE if all points have been used (added to the resulting paths)
*    or are inside.  If returns FALSE, returns the index to the next unused
*    point.
*
* Arguments:
*
*
* Return Value:
*
*
* Created:
*
*   6/15/1999 t-wehunt
*
\**************************************************************************/

BOOL PathSelfIntersectRemover::AllPointsUsed(INT *piptUnUsed)
{
    PointListNode *ptNode = NULL;
    INT iptord = 0;

    // TODO:  Create a static or a member which would remember the last
    // point returned here, so we don't have to start from the beginning each
    // time

    IntersectsWereRemoved = FALSE;
    while (iptord != -1)
    {
        if (iptord >= PtList.GetCount())
        {
            break;
        }
        ptNode = &PtList[iptord];
        if (!ptNode->Used)
        {
            if (ptNode->Inside)
            { 
                IntersectsWereRemoved = TRUE;
                iptord = ptNode->Next;
            } 
            else
            {
                *piptUnUsed = iptord;
                return FALSE;
            }
        }
        else
        {
            iptord = ptNode->Next;
        }
    }

    *piptUnUsed = -1;
    return TRUE;
}

/**************************************************************************\
*
* Function Description:
*
*    After the process of eliminating edges and marking points as inside
*    and outside, we need to go through the linked list of points and
*    build paths from the edges which are outside.  CollectPath will
*    collect one path starting from point with index iptFirst.  It
*    returns the actual value of this point in pptFirst.
*    CollectPath doesn't check if iptFirst is marked as Inside or Outside.
*    CollectPath returns FALSE on out of memory.
*
* Arguments:
*
*
* Return Value:
*
*
* Created:
*
*   6/15/1999 t-wehunt
*
\**************************************************************************/

BOOL PathSelfIntersectRemover::CollectPath(INT iptFirst)
{
    PointListNode *ptNode = NULL;
    GpPointF *pfpvThis = NULL;
    INT iptord = iptFirst;
    GpPointF fpvFirst(0,0);

    // Copy the first point, it always belongs to the path, we don't check
    // here if it is outside.  AllPointsUsed did that.

    if (ResultPts.Add(PathPts[iptFirst]) != Ok)
    {
        return FALSE;
    }

    // Store the point, so we can compare with it
    fpvFirst = PathPts[iptFirst];

    // Get the index of the next point and update the fUsed field for the
    // copied point.
    ptNode = &PtList[iptord];
    ptNode->Used = TRUE;
    iptord = ptNode->Next;
    BOOL fhavePptord = FALSE;

    // The end of a subpath will have the next iptord == -1
    while(iptord != -1)
    {
        if (!fhavePptord)
        {
            ptNode = &PtList[iptord];
        }
        fhavePptord = FALSE;
        if (ptNode->Inside)
        {
            // The edge starting in this point is inside, but the
            // point itself isn't.
            // If it is the closing point (the same as the first one)
            // return the collected subpath.
            pfpvThis = &PathPts[iptord];
            if (ClosePt(*pfpvThis, fpvFirst))
            {
                ptNode->Used = TRUE;
                return TRUE;
            }

            // If the point is not the same as the first one and we have
            // already been here, something is wrong
            if (ptNode->Used)
            {
                WARNING(("We have an infinite loop"));
                iptord = -1;
                return FALSE;
            }
            else
            {
                //This is the beginning of an inside edge, our path changes.
                //Let's get the duplicate point
                INT oldiptord = iptord;
                ptNode->Used = TRUE;
                iptord = ptNode->Dup;
                if (iptord >= 0)
                {
                    ptNode = &PtList[iptord];
                }
                else
                {
                    WARNING(("Dup is negative (1)"));
                    return FALSE;
                }
                while (ptNode->Inside || ptNode->Used)
                {
                    iptord = ptNode->Dup;
                    if (iptord == oldiptord)
                    {
                        WARNING(("Loop, cannot find a duplicate"));
                        return FALSE; 
                    }
                    else if (iptord >= 0)
                    {
                        ptNode = &PtList[iptord];
                    }
                    else
                    {
                        WARNING(("Dup is negative (2)"));
                        return FALSE;
                    }
                }
                fhavePptord = TRUE;
            }
        }
        else
        {
            // The point is outside
            if (ptNode->Used)
            {
                //This may be a longer list of dups, keep looking
                INT oldiptord2 = iptord;
                ptNode->Used = TRUE;
                iptord = ptNode->Dup;
                if (iptord >= 0)
                {
                    ptNode = &PtList[iptord];
                }
                else
                {
                    WARNING(("Dup is negative (3)"));
                    return FALSE;
                }
                while (ptNode->Inside || ptNode->Used)
                {
                    iptord = ptNode->Dup;
                    if (iptord == oldiptord2)
                    {
                        WARNING(("Loop, cannot find a duplicate (2)"));
                        return FALSE;
                    }
                    else if (iptord >= 0)
                    {
                        ptNode = &PtList[iptord];
                    }
                    else
                    {
                        WARNING(("Dup is negative (4)"));
                        return FALSE;
                    }
                }
                fhavePptord = TRUE;
            }
            else
            {
                //New point, everything is OK
                if (ResultPts.Add(PathPts[iptord]) != Ok)
                {
                    WARNING(("Could not append to array"));
                    return FALSE;
                }
                ptNode->Used = TRUE;
                iptord = ptNode->Next;
            }
        }
    }

    return TRUE;
}

/**************************************************************************\
*
* Function Description:
*
*   Function used to compare lines when we sort them by x coordinate of the
*   Begin point (SortBegin - smaller x).
*
* Arguments:
*
*
* Return Value:
*
*
* Created:
*
*   6/15/1999 t-wehunt
*
\**************************************************************************/

INT CompareLine(
    PathSelfIntersectRemover *ptrCorrector, 
    Edge *ptrEdge1, 
    Edge *ptrEdge2
    )
{
    //PGet on edges
    if (ptrCorrector->PathPts[ptrEdge1->SortBegin].X < 
        ptrCorrector->PathPts[ptrEdge2->SortBegin].X)
        return -1;

    if (ptrCorrector->PathPts[ptrEdge1->SortBegin].X > 
        ptrCorrector->PathPts[ptrEdge2->SortBegin].X)
        return 1;

    if (ptrCorrector->PathPts[ptrEdge1->SortBegin].Y < 
        ptrCorrector->PathPts[ptrEdge2->SortBegin].Y)
        return -1;

    if (ptrCorrector->PathPts[ptrEdge1->SortBegin].Y > 
        ptrCorrector->PathPts[ptrEdge2->SortBegin].Y)
        return 1;

    // Begin points must be exactly the same
    if (ptrCorrector->PathPts[ptrEdge1->SortEnd].X < 
        ptrCorrector->PathPts[ptrEdge2->SortEnd].X)
        return -1;

    if (ptrCorrector->PathPts[ptrEdge1->SortEnd].X > 
        ptrCorrector->PathPts[ptrEdge2->SortEnd].X)
        return 1;

    if (ptrCorrector->PathPts[ptrEdge1->SortEnd].Y < 
        ptrCorrector->PathPts[ptrEdge2->SortEnd].Y)
        return -1;

    if (ptrCorrector->PathPts[ptrEdge1->SortEnd].Y > 
        ptrCorrector->PathPts[ptrEdge2->SortEnd].Y)
        return 1;

    // Now, all point coordinates are exactly the same, but in some cases,
    // we may have two identical edges with the coordinates, these edges 
    // may have different points (actual indecies into points array, not 
    // coordinate values). We want to consider them as identical only if the 
    // indecies are the same.

    if (ptrEdge1->SortBegin < ptrEdge2->SortBegin)
        return -1;

    if (ptrEdge1->SortBegin > ptrEdge2->SortBegin)
        return 1;

    if (ptrEdge1->SortEnd < ptrEdge2->SortEnd)
        return -1;

    if (ptrEdge1->SortEnd > ptrEdge2->SortEnd)
        return 1;

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\entry\pen.cpp ===
/**************************************************************************\
*
* Copyright (c) 1998  Microsoft Corporation
*
* Abstract:
*
*   Implementation of GpPen class
*
* Revision History:
*
*   12/08/1998 andrewgo
*       Initial placeholders.
*
*   01/06/1999 ikkof
*       Added the implementation of GpGeometricPen.
\**************************************************************************/

#include "precomp.hpp"

//-------------------------------------------------------------
// GetMajorAndMinorAxis() is defined in PathWidener.cpp.
//-------------------------------------------------------------

extern GpStatus
GetMajorAndMinorAxis(
    REAL* majorR,
    REAL* minorR,
    const GpMatrix* matrix
    );

/**************************************************************************\
*
* Function Description:
*
* This converts the given width with the given physical unit to
* the device unit.  You cannot use this function when
* unit is WorldUnit.
*
* Arguments:
*
*   [IN] width  - the width in the given unit.
*   [IN] unit   - the unit of the width (must not be WorldUnit).
*   [IN] dpi    - dots per inch of the device.
*
* Return Value:
*
*   The device width.
*
*   04/15/1999 ikkof
*       Created it.
*
\**************************************************************************/

VOID GpPen::Set(const GpColor& color, REAL penWidth, GpUnit unit)
{
    // UnitDisplay is device-dependent and cannot be used for a pen size
    ASSERT(unit != UnitDisplay);

    if(DevicePen.CustomStartCap)
        delete DevicePen.CustomStartCap;

    if(DevicePen.CustomEndCap)
        delete DevicePen.CustomEndCap;

    if(DevicePen.DashArray)
        GpFree(DevicePen.DashArray);

    if(DevicePen.CompoundArray)
        GpFree(DevicePen.CompoundArray);


    InitDefaultState(penWidth, unit);

    if(Brush)
    {
        SetColor((GpColor *) &color);
    }
    else
    {
        Brush = new GpSolidFill(color);
        if(Brush)
        {
            DevicePen.Brush = Brush->GetDeviceBrush();
        }
        else
        {
            SetValid(FALSE);
        }
    }

    UpdateUid();
}

GpPen::GpPen(const GpColor& color, REAL penWidth, GpUnit unit)
{
    // UnitDisplay is device-dependent and cannot be used for a pen size
    ASSERT(unit != UnitDisplay);

    InitDefaultState(penWidth, unit);
    Brush = new GpSolidFill(color);
    if(Brush)
    {
        DevicePen.Brush = Brush->GetDeviceBrush();
    }
    else
    {
        SetValid(FALSE);
    }
}

GpPen::GpPen(const GpBrush* brush, REAL penWidth, GpUnit unit)
{
    // UnitDisplay is device-dependent and cannot be used for a pen size
    ASSERT(unit != UnitDisplay);

    InitDefaultState(penWidth, unit);
    Brush = brush->Clone();
    if(Brush)
    {
        DevicePen.Brush = Brush->GetDeviceBrush();
    }
    else
    {
        SetValid(FALSE);
    }
}

GpPen::GpPen(GpLineTexture* lineTexture, REAL penWidth, GpUnit unit)
{
    // UnitDisplay is device-dependent and cannot be used for a pen size
    ASSERT(unit != UnitDisplay);

    // !!! Needs to be implemented.
    // !!! Remember to change GdipCreatePen3 - it currently just returns
    //     NotImplemented.

    RIP(("GpPen with line texture not implemented"));
    SetValid(FALSE);
}

VOID GpPen::InitDefaultState(REAL penWidth, GpUnit unit)
{
    // UnitDisplay is device-dependent and cannot be used for a pen size
    ASSERT(unit != UnitDisplay);

    // !! Look at DeviceBrush.Type
    DevicePen.Type = PenTypeSolidColor;
    DevicePen.Width = penWidth;
    DevicePen.Unit = unit;
    DevicePen.StartCap = LineCapFlat;
    DevicePen.EndCap = LineCapFlat;
    DevicePen.Join = LineJoinMiter;
    DevicePen.MiterLimit = 10;    // PS's default miter limit.
    DevicePen.PenAlignment = PenAlignmentCenter;

    DevicePen.DashStyle = DashStyleSolid;
    DevicePen.DashCap = LineCapFlat;
    DevicePen.DashCount = 0;
    DevicePen.DashOffset = 0;
    DevicePen.DashArray = NULL;

    DevicePen.CompoundCount = 0;
    DevicePen.CompoundArray = NULL;

    DevicePen.CustomStartCap = NULL;
    DevicePen.CustomEndCap = NULL;

    DevicePen.Xform.Reset();
    
    SetValid(TRUE);
    UpdateUid();
}

GpPen::GpPen(const GpPen* pen)
{
    GpStatus status = Ok;

    // Initialize pointer members so that we don't delete garbage
    Brush = NULL;
    DevicePen.Brush = NULL;
    DevicePen.DashArray = NULL;
    DevicePen.CompoundArray = NULL;
    DevicePen.CustomStartCap = NULL;
    DevicePen.CustomEndCap = NULL;

    if(pen && pen->IsValid())
    {
        // Copy the base state.
        
        DevicePen = pen->DevicePen;
        
        // Don't copy pointer references to other objects.
        
        Brush = NULL;
        DevicePen.Brush = NULL;
        DevicePen.DashArray = NULL;
        DevicePen.CompoundArray = NULL;
        DevicePen.CustomStartCap = NULL;
        DevicePen.CustomEndCap = NULL;
        
        // Explicitly clone the pointer references to other objects.

        if(pen->Brush)
        {
            Brush = pen->Brush->Clone();
            DevicePen.Brush = Brush->GetDeviceBrush();
        }
        else
        {
            status = GenericError;
        }

        if( status == Ok )
        {   
            if( (pen->DevicePen.DashArray) && 
                (DevicePen.DashCount > 0)
            )
            {
                DevicePen.DashArray = (REAL*) GpMalloc(DevicePen.DashCount*sizeof(REAL));
                if(DevicePen.DashArray)
                {
                    GpMemcpy(DevicePen.DashArray, pen->DevicePen.DashArray, DevicePen.DashCount*sizeof(REAL));
                }
                else
                {
                    status = OutOfMemory;
                }
            }
            else
            {
                // If there is no dash array data, this must be a solid line.
                
                ASSERT(DevicePen.DashStyle == DashStyleSolid);
    
                DevicePen.DashCount = 0;
                DevicePen.DashArray = NULL;
            }
        }

        // Set the compound array if necessary.

        if( status == Ok )
        {
            if( (pen->DevicePen.CompoundArray) && 
                (DevicePen.CompoundCount > 0)
            )
            {
                DevicePen.CompoundArray = (REAL*) GpMalloc(DevicePen.CompoundCount*sizeof(REAL));
                if(DevicePen.CompoundArray)
                {
                    GpMemcpy(DevicePen.CompoundArray, pen->DevicePen.CompoundArray, DevicePen.CompoundCount*sizeof(REAL));
                }
                else
                {
                    status = OutOfMemory;
                }
            }
            else
            {
                DevicePen.CompoundCount = 0;
                DevicePen.CompoundArray = NULL;
            }
        }
        
        // Copy the start custom cap.

        if( status == Ok )
        {
            if( DevicePen.StartCap == LineCapCustom )
            {
                // This could happen with our metafile recorder,
                // because saving Custom Line Caps was not implemented.
                if (pen->DevicePen.CustomStartCap == NULL)
                {
                    WARNING1("CustomStartCap type with NULL pointer");
                    DevicePen.StartCap = LineCapFlat;
                }
                else
                {
                    GpCustomLineCap* clonedCap = static_cast<GpCustomLineCap*>
                                (pen->DevicePen.CustomStartCap)->Clone();
                    if(clonedCap)
                    {
                        DevicePen.CustomStartCap = clonedCap;
                    }
                    else
                    {
                        status = OutOfMemory;
                    }
                }
            }
        }
        
        // Copy the end custom cap.

        if( status == Ok )
        {
            if( DevicePen.EndCap == LineCapCustom )
            {
                // This could happen with our metafile recorder,
                // because saving Custom Line Caps was not implemented.
                if (pen->DevicePen.CustomEndCap == NULL)
                {
                    WARNING1("CustomEndCap type with NULL pointer");
                    DevicePen.EndCap = LineCapFlat;
                }
                else
                {
                    GpCustomLineCap* clonedCap = static_cast<GpCustomLineCap*>
                                (pen->DevicePen.CustomEndCap)->Clone();
                    if(clonedCap)
                    {
                        DevicePen.CustomEndCap = clonedCap;
                    }
                    else
                    {
                        status = OutOfMemory;
                    }
                }
            }
        }

    }
    else
    {
        // Can't make a valid pen from an invalid input pen.
        
        status = GenericError;    
    }
    
    if(status == Ok)
    {
        SetValid(TRUE);
    }
    else
    {
        // Failed cloning the pen.
        
        // Clean up possible memory allocation so we don't leak even under
        // low memory conditions. Note we rely on GpFree and delete handling
        // NULL pointers here.
        
        delete Brush;
        Brush = NULL;                   // InitializeDefaultState() does not set
        DevicePen.Brush = NULL;         // these fields - clear them explicitly.
        
        GpFree(DevicePen.DashArray);
        GpFree(DevicePen.CompoundArray);
        
        delete DevicePen.CustomStartCap;
        delete DevicePen.CustomEndCap;
        
        // Clean the pen.
        
        InitDefaultState(1.0f, UnitWorld);
        
        // This is not a valid object.
        
        SetValid(FALSE);
    }
}

// Clone() return NULL if the cloning fails.

GpPen* GpPen::Clone()
{
    GpPen* clonedPen =  new GpPen(this);

    if(clonedPen && clonedPen->IsValid())
        return clonedPen;
    else
    {
        if(clonedPen)
            delete clonedPen;
        return NULL;
    }
}

GpStatus
GpPen::GetMaximumWidth(
        REAL* width,
        const GpMatrix* matrix) const
{
    if(DevicePen.Unit != UnitWorld)
        return InvalidParameter;

    GpMatrix trans;
    if(matrix)
        trans = *matrix;

    if(!DevicePen.Xform.IsTranslate())
        trans.Prepend(DevicePen.Xform);

    REAL majorR, minorR;

    ::GetMajorAndMinorAxis(&majorR, &minorR, &trans);
    majorR *= DevicePen.Width;
    minorR *= DevicePen.Width;

    if(minorR < 1.42f)   // This is a litte bit larger than sqrt(2).
    {
        minorR = 1.42f;
        majorR = 1.42f;
    }

    *width = majorR;

    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   This function takes a join angle and computes the length of the miter
*   based on this angle and a given miter length limit.
*   This can be scaled by the pen width to give the length of an arbitrary
*   pen miter.
*
*   In this picture, 2a is the angle of the join. The pen width is w and the 
*   desired output is the length of the miter join (l).
*
*   Note that the line labled w is perpendecular to the inside and outside 
*   widended lines. Then the formula is derived as follows:
*
*         sin(a) = w/l   [opposite over hypotenuse on right angled triangle]
*    <=>  l = w/sin(a)
*
*
*                     /|\
*                    /a|a\
*                   /  |  \
*                  /   |   \
*                 /    |l   \
*                /     |     \ <-- right angle
*               /--__  |  __--\
*              /   w --|-- w   \
*             /       / \       \
*            /       /   \       \
*        outside     inside     outside
*
* NOTE: 
*
*   This routine returns the miter length (l) for a pen width w==1.0f. 
*   The caller is responsible for scaling length by the pen width.
*
*   If the length of 1/sin(a) is greater than the miterLimit, the miterLimit
*   is returned. (including infinite length joins).
*                        
* Arguments:
*
*   [IN] angle      - join angle in radians
*   [IN] miterLimit - maximum miter length (not scaled by pen width).
*
* Return Value:
*
*   Pen width independent miter length.
*
*   10/02/2000 asecchia
*       Created it.
*
\**************************************************************************/


REAL GpPen::ComputeMiterLength(
    REAL angle,
    REAL miterLimit
    )
{
    // use the simple miter join formula 
    // length = (penwidth)/sin(angle/2)
    // because we're pen independent, use 1.0 for pen width and rely
    // on the caller to scale by the pen width.
    
    REAL length = (REAL)sin(0.5*angle);
    
    // Check for an infinite miter...
    
    if(REALABS(length) < REAL_EPSILON)
    {
        return miterLimit;
    }
    
    length = 1.0f / length;
    
    return min(miterLimit, length);
}



REAL
GpPen::GetMaximumJoinWidth(
    REAL sharpestAngle,
    const GpMatrix* matrix,
    REAL dpiX,
    REAL dpiY) const
{
    REAL delta;

    if ((matrix != NULL) && (DevicePen.IsOnePixelWideSolid(matrix, dpiX)))
    {
        delta = 0.5;
    }
    else
    {
        REAL maximumWidth;
        REAL delta0;

        REAL scale = 1.0;

        switch(DevicePen.PenAlignment)
        {
        case PenAlignmentCenter:
            scale = 0.5f;
            break;

        // use 1.0 for the inset pen. If the path is open, we render with a
        // center pen.
        
        // NOTE: a scale of 0.0 is sufficient for all inset pen rendering 
        // provided all subpaths are closed. In the widener, we detect the
        // open subpaths and render them with a center pen. To accommodate 
        // this, we increase the scale here. Theoretically we could use 
        // scale = 0.5f for the inset pen (same as center pen), but this 
        // bounds is an overestimate anyway and being wrong by one pixel too
        // small is way worse (crash) than being wrong and too big.
        
        case PenAlignmentInset:
            scale = 1.0f;
            break;
        }

        if(GetMaximumWidth(&maximumWidth, matrix) == Ok)
        {
            delta0 = maximumWidth;
        }
        else
        {
            maximumWidth = ::GetDeviceWidth(
                                DevicePen.Width,
                                DevicePen.Unit,
                                dpiX);
            delta0 = maximumWidth;
        }

        if(DevicePen.Join == LineJoinMiter ||
           DevicePen.Join == LineJoinMiterClipped)
        {
            REAL miterLimit = DevicePen.MiterLimit;

            delta = delta0*miterLimit;

            if(delta > 20)
            {
                delta = ComputeMiterLength(
                    sharpestAngle,
                    miterLimit
                );

                // scale by the pen width.
                
                delta *= delta0;
            }
        }
        else
        {
            delta = delta0;
        }

        delta *= scale;
    }

    return delta;
}

REAL
GpPen::GetMaximumCapWidth(
        const GpMatrix* matrix,
        REAL dpiX,
        REAL dpiY) const
{
    REAL maximumWidth;
    REAL delta0;

    if(GetMaximumWidth(&maximumWidth, matrix) == Ok)
    {
        delta0 = maximumWidth;
    }
    else
    {
        maximumWidth = ::GetDeviceWidth(
                            DevicePen.Width,
                            DevicePen.Unit,
                            dpiX);
        delta0 = maximumWidth;
    }

    REAL delta = delta0;

    GpLineCap startCap = DevicePen.StartCap;
    GpLineCap endCap = DevicePen.EndCap;

    REAL delta1;

    GpCustomLineCap* customCap = NULL;

    if(startCap == LineCapCustom && DevicePen.CustomStartCap)
    {
        customCap = static_cast<GpCustomLineCap *> (DevicePen.CustomStartCap);
        delta1 = customCap->GetRadius(delta0, 1.0f);
    }
    else
    {
        if(!(startCap & LineCapAnchorMask))
            delta1 = 0.5f*delta0;
        else
            delta1 = 2.0f*(delta0 + 1);
    }
    if(delta < delta1)
        delta = delta1;


    if(endCap == LineCapCustom && DevicePen.CustomEndCap)
    {
        customCap = static_cast<GpCustomLineCap *> (DevicePen.CustomEndCap);
        delta1 = customCap->GetRadius(delta0, 1.0f);
    }
    else
    {
        if(!(endCap & LineCapAnchorMask))
            delta1 = 0.5f*delta0;
        else
            delta1 = 2.0f*(delta0 + 2);
    }
    if(delta < delta1)
        delta = delta1;

    return delta;
}

VOID
GpPen::SetDashCap(GpDashCap dashCap)
{
    // Note: Internally we use a GpLineCap type to store the dash cap type.
    // So we need to convert between GpLineCap and GpDashCap.
    // However, we should change the internal usage to GpDashCap in v2.
    // - JBronsk
    GpLineCap lineCap = LineCapFlat;
    switch (dashCap)
    {
    case DashCapRound:
    	lineCap = LineCapRound;
    	break;
    case DashCapTriangle:
    	lineCap = LineCapTriangle;
    	break;
    // all others map to LineCapFlat
    }
    
    GpStatus status = SetDashStyleWithDashCap(DevicePen.DashStyle, lineCap);
    if(status == Ok)
    {
        DevicePen.DashCap = lineCap;
    }
}

GpStatus
GpPen::SetDashStyle(
    GpDashStyle dashStyle
    )
{
    return SetDashStyleWithDashCap(dashStyle, DevicePen.DashCap);
}

GpStatus
GpPen::SetDashStyleWithDashCap(
    GpDashStyle dashStyle,
    GpLineCap dashCap
    )
{
    GpStatus status = Ok;
    REAL    style[6];
    INT     count;

    switch(dashStyle)
    {
    case DashStyleSolid:
        count = 0;
        break;

    case DashStyleDash:
        count = 2;
        style[0] = 3;   // a dash
        style[1] = 1;   // a space
        break;

    case DashStyleDot:
        count = 2;
        style[0] = 1;   // a dot
        style[1] = 1;   // a space
        break;

    case DashStyleDashDot:
        count = 4;
        style[0] = 3;   // a dash
        style[1] = 1;   // a space
        style[2] = 1;   // a dot
        style[3] = 1;   // a space
        break;

    case DashStyleDashDotDot:
        count = 6;
        style[0] = 3;   // a dash
        style[1] = 1;   // a space
        style[2] = 1;   // a dot
        style[3] = 1;   // a space
        style[4] = 1;   // a dot
        style[5] = 1;   // a space
        break;
    
    case DashStyleCustom:
        
        // We assume that the custom dash has been set at the API.
        // The remaining code in this routine is for initializing an appropriate
        // dash array, which we already have in this case, so we're done.
        
        DevicePen.DashStyle = dashStyle;
        return Ok;

    default:
        // The dash style must be one of the predefined ones.
        status = InvalidParameter;
    }

    if(status != Ok)
    {
        return status;
    }

    if(DevicePen.DashCount < count)
    {
        REAL* newArray = (REAL*) GpMalloc(count*sizeof(REAL));

        if(newArray)
        {
            GpFree(DevicePen.DashArray);
            DevicePen.DashArray = newArray;
        }
        else
        {
            status = OutOfMemory;
        }
    }

    if(status == Ok)
    {
        // initialize the DashArray.
        GpMemcpy(DevicePen.DashArray, &style[0], count*sizeof(REAL));
        DevicePen.DashStyle = dashStyle;
        DevicePen.DashCount = count;
        UpdateUid();
    }

    return status;
}

GpStatus
GpPen::SetDashArray(
    const REAL* dashArray,
    INT count
    )
{
    ASSERT(dashArray && count > 0);

    // Make sure the all elements are positive.
    INT         i = 0;
    GpStatus    status = Ok;

    while(status == Ok && i < count)
    {
        if(dashArray[i++] <= 0)
            status = InvalidParameter;
    }

    if(status != Ok)
        return status;

    REAL* newArray = (REAL*) GpRealloc(DevicePen.DashArray, count*sizeof(REAL));

    if(!newArray)
        return OutOfMemory;

    GpMemcpy(newArray, dashArray, count*sizeof(REAL));

    DevicePen.DashStyle = DashStyleCustom;
    DevicePen.DashArray = newArray;
    DevicePen.DashCount = count;
    UpdateUid();

    return Ok;
}

GpStatus
GpPen::GetDashArray(
    REAL* dashArray,
    INT count
    ) const
{
    ASSERT(dashArray != NULL && count <= DevicePen.DashCount);

    GpStatus status = Ok;

    if(dashArray == NULL || count > DevicePen.DashCount)
        return InvalidParameter;

    if(DevicePen.DashArray)
        GpMemcpy(dashArray, DevicePen.DashArray, count*sizeof(REAL));
    else
        status = OutOfMemory;

    return status;
}

GpStatus
GpPen::SetCompoundArray(
    const REAL* compoundArray,
    INT count
    )
{
    // count must be a positive even number.

    if(compoundArray == NULL || count <= 0 || (count & 0x01))
    {
        return InvalidParameter;
    }

    // count is 2 or more here...
    
    // Compound Inset pens aren't implemented yet.
    // The code for correctly handling minimum width compound sub lines
    // is missing.
    
    if(DevicePen.PenAlignment == PenAlignmentInset)
    {
        return NotImplemented;
    }

    // Make sure the all elements are monitonically increasing
    // and its values are between 0 and 1.

    GpStatus    status = Ok;
    REAL        lastValue, nextValue;

    lastValue = compoundArray[0];
    if(lastValue < 0.0f || lastValue > 1.0f)
        status = InvalidParameter;

    INT i = 1;

    while(status == Ok && i < count)
    {
        nextValue = compoundArray[i++];
        if(nextValue < lastValue || nextValue > 1.0f)
            status = InvalidParameter;

        lastValue = nextValue;
    }

    if(status != Ok)
        return status;

    REAL* newArray = (REAL*) GpRealloc(DevicePen.CompoundArray, count*sizeof(REAL));

    if(!newArray)
        return OutOfMemory;

    GpMemcpy(newArray, compoundArray, count*sizeof(REAL));

    DevicePen.CompoundArray = newArray;
    DevicePen.CompoundCount = count;
    UpdateUid();

    return Ok;
}

GpStatus
GpPen::GetCompoundArray(
    REAL* compoundArray,
    INT count
    )
{
    ASSERT(compoundArray != NULL && count <= DevicePen.CompoundCount);

    if(compoundArray == NULL || count > DevicePen.CompoundCount)
        return InvalidParameter;

    if(DevicePen.CompoundArray && count > 0)
        GpMemcpy(compoundArray, DevicePen.CompoundArray, count*sizeof(REAL));

    return Ok;
}

GpStatus
GpPen::SetCustomStartCap(
    const GpCustomLineCap* customCap
    )
{
    if(DevicePen.CustomStartCap)
        delete DevicePen.CustomStartCap;

    // Reset the standard start cap to the default one.

    DevicePen.CustomStartCap = NULL;
    DevicePen.StartCap = LineCapFlat;

    if(customCap)
    {
        DevicePen.CustomStartCap = customCap->Clone();
        DevicePen.StartCap = LineCapCustom;
    }

    UpdateUid();
    return Ok;
}

GpStatus
GpPen::GetCustomStartCap(
    GpCustomLineCap** customCap
    )
{
    if(DevicePen.CustomStartCap)
        *customCap = static_cast<GpCustomLineCap*>
                (DevicePen.CustomStartCap)->Clone();
    else
        *customCap = NULL;

    return Ok;
}

GpStatus
GpPen::SetCustomEndCap(
    const GpCustomLineCap* customCap
    )
{
    if(DevicePen.CustomEndCap)
        delete DevicePen.CustomEndCap;

    // Reset the standard start cap to the default one.

    DevicePen.CustomEndCap = NULL;
    DevicePen.EndCap = LineCapFlat;

    if(customCap)
    {
        DevicePen.CustomEndCap = customCap->Clone();
        DevicePen.EndCap = LineCapCustom;
    }

    UpdateUid();
    return Ok;
}

GpStatus
GpPen::GetCustomEndCap(
    GpCustomLineCap** customCap
    )
{
    if(DevicePen.CustomEndCap)
        *customCap = static_cast<GpCustomLineCap*>
                (DevicePen.CustomEndCap)->Clone();
    else
        *customCap = NULL;

    return Ok;
}

GpStatus
GpPen::MultiplyTransform(const GpMatrix& matrix,
                                   GpMatrixOrder order)
{
    GpStatus    status = Ok;

    if (matrix.IsInvertible())
    {
        if (order == MatrixOrderPrepend)
        {
            DevicePen.Xform.Prepend(matrix);
        }
        else
        {
            DevicePen.Xform.Append(matrix);
        }
    }
    else
        status = InvalidParameter;

    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   Answer true if the two pen instances are equivalent, meaning they
*   are indistinguishable when rendering.
*
* Arguments:
*
*   [IN] pen - pen to compare this against

* Return Value:
*
*   TRUE if equivalent.
*
* Created:
*
*   6/14/1999 peterost
*
\**************************************************************************/

BOOL
GpPen::IsEqual(
    const GpPen *  pen
    )
    const
{
    ASSERT(pen != NULL);

    if (pen == this)
        return TRUE;

    BOOL isEqual = TRUE;

    if (DevicePen.IsEqual(&pen->DevicePen) &&
        DevicePen.DashStyle == pen->DevicePen.DashStyle &&
        DevicePen.CompoundCount == pen->DevicePen.CompoundCount &&
        Brush->IsEqual(pen->Brush) &&
        DevicePen.Xform.IsEqual(&pen->DevicePen.Xform))
    {
        // We need to check the equality further if the dash style
        // is not a solid line.

        if (DevicePen.DashStyle != DashStyleSolid)
        {
            if(DevicePen.DashStyle != DashStyleCustom)
            {
                // A case of the preset dash pattern.
                // Check only for the offset difference.

                if(DevicePen.DashOffset != pen->DevicePen.DashOffset)
                    isEqual = FALSE;
            }
            else
            {
                if (DevicePen.DashCount == pen->DevicePen.DashCount &&
                    DevicePen.DashOffset == pen->DevicePen.DashOffset &&
                    DevicePen.DashArray != NULL &&
                    pen->DevicePen.DashArray != NULL)
                {
                    INT i = 0;

                    while(i < DevicePen.DashCount && isEqual)
                    {
                        if (DevicePen.DashArray[i] != pen->DevicePen.DashArray[i])
                        {
                            isEqual = FALSE;
                        }
                        i++;
                    }
                }
                else
                {
                    isEqual = FALSE;
                }
            }
        }

        // Check for the compound lines.

        if(isEqual && DevicePen.CompoundCount > 0)
        {
            if(DevicePen.CompoundArray && pen->DevicePen.CompoundArray)
            {
                INT j = 0;

                while(j < DevicePen.CompoundCount && isEqual)
                {
                    if(DevicePen.CompoundArray[j] != pen->DevicePen.CompoundArray[j])
                    {
                        isEqual = FALSE;
                    }
                    j++;
                }
            }
            else
            {
                isEqual = FALSE;
            }
        }
    }
    else
    {
        isEqual = FALSE;
    }

    return isEqual;
}

// For GetData and SetData methods
#define GDIP_PENFLAGS_TRANSFORM             0x00000001
#define GDIP_PENFLAGS_STARTCAP              0x00000002
#define GDIP_PENFLAGS_ENDCAP                0x00000004
#define GDIP_PENFLAGS_JOIN                  0x00000008
#define GDIP_PENFLAGS_MITERLIMIT            0x00000010
#define GDIP_PENFLAGS_DASHSTYLE             0x00000020
#define GDIP_PENFLAGS_DASHCAP               0x00000040
#define GDIP_PENFLAGS_DASHOFFSET            0x00000080
#define GDIP_PENFLAGS_DASHARRAY             0x00000100
#define GDIP_PENFLAGS_NONCENTER             0x00000200
#define GDIP_PENFLAGS_COMPOUNDARRAY         0x00000400
#define GDIP_PENFLAGS_CUSTOMSTARTCAP        0x00000800
#define GDIP_PENFLAGS_CUSTOMENDCAP          0x00001000

class PenData : public ObjectTypeData
{
public:
    INT32       Flags;
    INT32       Unit;
    REAL        Width;
};

/**************************************************************************\
*
* Function Description:
*
*   Get the pen data.
*
* Arguments:
*
*   [IN] dataBuffer - fill this buffer with the data
*   [IN/OUT] size   - IN - size of buffer; OUT - number bytes written
*
* Return Value:
*
*   GpStatus - Ok or error code
*
* Created:
*
*   9/13/1999 DCurtis
*
\**************************************************************************/
GpStatus
GpPen::GetData(
    IStream *   stream
    ) const
{
    if (Brush == NULL)
    {
        WARNING(("Brush is NULL"));
        return Ok;
    }

    ASSERT (stream != NULL);

    INT         flags    = 0;

    if (!DevicePen.Xform.IsIdentity())
    {
        flags |= GDIP_PENFLAGS_TRANSFORM;
    }

    INT     customStartCapSize = 0;
    INT     customEndCapSize   = 0;

    if (DevicePen.StartCap != LineCapFlat)
    {
        if (DevicePen.StartCap == LineCapCustom)
        {
            if ((DevicePen.CustomStartCap != NULL) &&
                DevicePen.CustomStartCap->IsValid() &&
                ((customStartCapSize = DevicePen.CustomStartCap->GetDataSize()) > 0))
            {
                flags |= GDIP_PENFLAGS_STARTCAP | GDIP_PENFLAGS_CUSTOMSTARTCAP;
            }
        }
        else
        {
            flags |= GDIP_PENFLAGS_STARTCAP;
        }
    }

    if (DevicePen.EndCap != LineCapFlat)
    {
        if (DevicePen.EndCap == LineCapCustom)
        {
            if ((DevicePen.CustomEndCap != NULL) &&
                DevicePen.CustomEndCap->IsValid() &&
                ((customEndCapSize = DevicePen.CustomEndCap->GetDataSize()) > 0))
            {
                flags |= GDIP_PENFLAGS_ENDCAP | GDIP_PENFLAGS_CUSTOMENDCAP;
            }
        }
        else
        {
            flags |= GDIP_PENFLAGS_ENDCAP;
        }
    }

    if (DevicePen.Join != LineJoinMiter)
    {
        flags |= GDIP_PENFLAGS_JOIN;
    }

    if (DevicePen.MiterLimit != 10)
    {
        flags |= GDIP_PENFLAGS_MITERLIMIT;
    }

    // DashStyleCustom is handled by hasDashArray
    if ((DevicePen.DashStyle != DashStyleSolid) && (DevicePen.DashStyle != DashStyleCustom))
    {
        flags |= GDIP_PENFLAGS_DASHSTYLE;
    }

    if (DevicePen.DashCap != LineCapFlat)
    {
        flags |= GDIP_PENFLAGS_DASHCAP;
    }

    if (DevicePen.DashOffset != 0)
    {
        flags |= GDIP_PENFLAGS_DASHOFFSET;
    }

    if ((DevicePen.DashStyle == DashStyleCustom) &&
        (DevicePen.DashArray != NULL) &&
        (DevicePen.DashCount > 0))
    {
        flags |= GDIP_PENFLAGS_DASHARRAY;
    }

    if (DevicePen.PenAlignment != PenAlignmentCenter)
    {
        flags |= GDIP_PENFLAGS_NONCENTER;
    }

    if ((DevicePen.CompoundArray != NULL) && (DevicePen.CompoundCount > 0))
    {
        flags |= GDIP_PENFLAGS_COMPOUNDARRAY;
    }

    PenData     penData;
    penData.Type  = DevicePen.Type;
    penData.Flags = flags;
    penData.Unit  = DevicePen.Unit;
    penData.Width = DevicePen.Width;
    stream->Write(&penData, sizeof(penData), NULL);

    if (flags & GDIP_PENFLAGS_TRANSFORM)
    {
        DevicePen.Xform.WriteMatrix(stream);
    }

    if (flags & GDIP_PENFLAGS_STARTCAP)
    {
        stream->Write(&DevicePen.StartCap, sizeof(INT32), NULL);
    }

    if (flags & GDIP_PENFLAGS_ENDCAP)
    {
        stream->Write(&DevicePen.EndCap, sizeof(INT32), NULL);
    }

    if (flags & GDIP_PENFLAGS_JOIN)
    {
        stream->Write(&DevicePen.Join, sizeof(INT32), NULL);
    }

    if (flags & GDIP_PENFLAGS_MITERLIMIT)
    {
        stream->Write(&DevicePen.MiterLimit, sizeof(REAL), NULL);
    }

    if (flags & GDIP_PENFLAGS_DASHSTYLE)
    {
        stream->Write(&DevicePen.DashStyle, sizeof(INT32), NULL);
    }

    if (flags & GDIP_PENFLAGS_DASHCAP)
    {
        stream->Write(&DevicePen.DashCap, sizeof(INT32), NULL);
    }

    if (flags & GDIP_PENFLAGS_DASHOFFSET)
    {
        stream->Write(&DevicePen.DashOffset, sizeof(REAL), NULL);
    }

    if (flags & GDIP_PENFLAGS_DASHARRAY)
    {
        stream->Write(&DevicePen.DashCount, sizeof(INT32), NULL);
        stream->Write(DevicePen.DashArray, DevicePen.DashCount * sizeof(REAL), NULL);
    }

    if (flags & GDIP_PENFLAGS_NONCENTER)
    {
        stream->Write(&DevicePen.PenAlignment, sizeof(INT32), NULL);
    }

    if (flags & GDIP_PENFLAGS_COMPOUNDARRAY)
    {
        stream->Write(&DevicePen.CompoundCount, sizeof(INT32), NULL);
        stream->Write(DevicePen.CompoundArray, DevicePen.CompoundCount * sizeof(REAL), NULL);
    }

    GpStatus status;

    if (flags & GDIP_PENFLAGS_CUSTOMSTARTCAP)
    {
        stream->Write(&customStartCapSize, sizeof(INT32), NULL);
        if ((status = DevicePen.CustomStartCap->GetData(stream)) != Ok)
        {
            return status;
        }
    }

    if (flags & GDIP_PENFLAGS_CUSTOMENDCAP)
    {
        stream->Write(&customEndCapSize, sizeof(INT32), NULL);
        if ((status = DevicePen.CustomEndCap->GetData(stream)) != Ok)
        {
            return status;
        }
    }

    status = Brush->GetData(stream);

    return status;
}

UINT
GpPen::GetDataSize() const
{
    if (Brush == NULL)
    {
        WARNING(("Brush is NULL"));
        return 0;
    }

    UINT        dataSize = sizeof(PenData);

    if (!DevicePen.Xform.IsIdentity())
    {
        dataSize += GDIP_MATRIX_SIZE;
    }

    INT     customStartCapSize = 0;
    INT     customEndCapSize   = 0;

    if (DevicePen.StartCap != LineCapFlat)
    {
        if (DevicePen.StartCap == LineCapCustom)
        {
            if ((DevicePen.CustomStartCap != NULL) &&
                DevicePen.CustomStartCap->IsValid() &&
                ((customStartCapSize = DevicePen.CustomStartCap->GetDataSize()) > 0))
            {
                // startcap + sizeof custom cap + custom cap
                dataSize += sizeof(INT32) + sizeof(INT32) + customStartCapSize;
            }
        }
        else
        {
            dataSize += sizeof(INT32);
        }
    }

    if (DevicePen.EndCap != LineCapFlat)
    {
        if (DevicePen.EndCap == LineCapCustom)
        {
            if ((DevicePen.CustomEndCap != NULL) &&
                DevicePen.CustomEndCap->IsValid() &&
                ((customEndCapSize = DevicePen.CustomEndCap->GetDataSize()) > 0))
            {
                // endcap + sizeof custom cap + custom cap
                dataSize += sizeof(INT32) + sizeof(INT32) + customEndCapSize;
            }
        }
        else
        {
            dataSize += sizeof(INT32);
        }
    }

    if (DevicePen.Join != LineJoinMiter)
    {
        dataSize += sizeof(INT32);
    }

    if (DevicePen.MiterLimit != 10)
    {
        dataSize += sizeof(REAL);
    }

    // DashStyleCustom is handled by hasDashArray
    if ((DevicePen.DashStyle != DashStyleSolid) && (DevicePen.DashStyle != DashStyleCustom))
    {
        dataSize += sizeof(INT32);
    }

    if (DevicePen.DashCap != LineCapFlat)
    {
        dataSize += sizeof(INT32);
    }

    if (DevicePen.DashOffset != 0)
    {
        dataSize += sizeof(REAL);
    }

    if ((DevicePen.DashStyle == DashStyleCustom) &&
        (DevicePen.DashArray != NULL) &&
        (DevicePen.DashCount > 0))
    {
        dataSize += sizeof(INT32) + (DevicePen.DashCount * sizeof(REAL));
    }

    if (DevicePen.PenAlignment != PenAlignmentCenter)
    {
        dataSize += sizeof(INT32);
    }

    if ((DevicePen.CompoundArray != NULL) && (DevicePen.CompoundCount > 0))
    {
        dataSize += sizeof(INT32) + (DevicePen.CompoundCount * sizeof(REAL));
    }

    dataSize += Brush->GetDataSize();

    return dataSize;
}

/**************************************************************************\
*
* Function Description:
*
*   Read the pen object from memory.
*
* Arguments:
*
*   [IN] dataBuffer - the data that was read from the stream
*   [IN] size - the size of the data
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   4/26/1999 DCurtis
*
\**************************************************************************/
GpStatus
GpPen::SetData(
    const BYTE *        dataBuffer,
    UINT                size
    )
{
    if (dataBuffer == NULL)
    {
        WARNING(("dataBuffer is NULL"));
        return InvalidParameter;
    }

    if (size < sizeof(PenData))
    {
        WARNING(("size too small"));
        return InvalidParameter;
    }

    const PenData *     penData = reinterpret_cast<const PenData *>(dataBuffer);

    if (!penData->MajorVersionMatches())
    {
        WARNING(("Version number mismatch"));
        return InvalidParameter;
    }

    InitDefaultState(penData->Width, static_cast<GpUnit>(penData->Unit));

    dataBuffer += sizeof(PenData);
    size       -= sizeof(PenData);

    if (penData->Flags & GDIP_PENFLAGS_TRANSFORM)
    {
        if (size < GDIP_MATRIX_SIZE)
        {
            WARNING(("size too small"));
            goto ErrorExit;
        }
        DevicePen.Xform.SetMatrix((REAL *)dataBuffer);
        dataBuffer += GDIP_MATRIX_SIZE;
        size       -= GDIP_MATRIX_SIZE;
    }

    if (penData->Flags & GDIP_PENFLAGS_STARTCAP)
    {
        if (size < sizeof(INT32))
        {
            WARNING(("size too small"));
            goto ErrorExit;
        }
        DevicePen.StartCap = (GpLineCap) ((INT32 *)dataBuffer)[0];
        dataBuffer += sizeof(INT32);
        size       -= sizeof(INT32);
    }

    if (penData->Flags & GDIP_PENFLAGS_ENDCAP)
    {
        if (size < sizeof(INT32))
        {
            WARNING(("size too small"));
            goto ErrorExit;
        }
        DevicePen.EndCap = (GpLineCap) ((INT32 *)dataBuffer)[0];
        dataBuffer += sizeof(INT32);
        size       -= sizeof(INT32);
    }

    if (penData->Flags & GDIP_PENFLAGS_JOIN)
    {
        if (size < sizeof(INT32))
        {
            WARNING(("size too small"));
            goto ErrorExit;
        }
        DevicePen.Join = (GpLineJoin) ((INT32 *)dataBuffer)[0];
        dataBuffer += sizeof(INT32);
        size       -= sizeof(INT32);
    }

    if (penData->Flags & GDIP_PENFLAGS_MITERLIMIT)
    {
        if (size < sizeof(REAL))
        {
            WARNING(("size too small"));
            goto ErrorExit;
        }
        DevicePen.MiterLimit = ((REAL *)dataBuffer)[0];
        dataBuffer += sizeof(REAL);
        size       -= sizeof(REAL);
    }

    if (penData->Flags & GDIP_PENFLAGS_DASHSTYLE)
    {
        if (size < sizeof(INT32))
        {
            WARNING(("size too small"));
            goto ErrorExit;
        }
        this->SetDashStyle((GpDashStyle)((INT32 *)dataBuffer)[0]);
        dataBuffer += sizeof(INT32);
        size       -= sizeof(INT32);
    }

    if (penData->Flags & GDIP_PENFLAGS_DASHCAP)
    {
        if (size < sizeof(INT32))
        {
            WARNING(("size too small"));
            goto ErrorExit;
        }
        DevicePen.DashCap = (GpLineCap) ((INT32 *)dataBuffer)[0];
        dataBuffer += sizeof(INT32);
        size       -= sizeof(INT32);
    }

    if (penData->Flags & GDIP_PENFLAGS_DASHOFFSET)
    {
        if (size < sizeof(REAL))
        {
            WARNING(("size too small"));
            goto ErrorExit;
        }
        DevicePen.DashOffset = ((REAL *)dataBuffer)[0];
        dataBuffer += sizeof(REAL);
        size       -= sizeof(REAL);
    }

    if (penData->Flags & GDIP_PENFLAGS_DASHARRAY)
    {
        if (size < sizeof(INT32))
        {
            WARNING(("size too small"));
            goto ErrorExit;
        }

        INT count = ((INT32 *)dataBuffer)[0];
        dataBuffer += sizeof(INT32);
        size       -= sizeof(INT32);

        if (size < (count * sizeof(REAL)))
        {
            WARNING(("size too small"));
            goto ErrorExit;
        }
        this->SetDashArray((REAL *)dataBuffer, count);
        dataBuffer += (count * sizeof(REAL));
        size       -= (count * sizeof(REAL));
    }

    if (penData->Flags & GDIP_PENFLAGS_NONCENTER)
    {
        if (size < sizeof(INT32))
        {
            WARNING(("size too small"));
            goto ErrorExit;
        }
        DevicePen.PenAlignment = (GpPenAlignment) ((INT32 *)dataBuffer)[0];
        dataBuffer += sizeof(INT32);
        size       -= sizeof(INT32);
    }

    if (penData->Flags & GDIP_PENFLAGS_COMPOUNDARRAY)
    {
        if (size < sizeof(INT32))
        {
            WARNING(("size too small"));
            goto ErrorExit;
        }

        INT count = ((INT32 *)dataBuffer)[0];
        dataBuffer += sizeof(INT32);
        size       -= sizeof(INT32);

        if (size < (count * sizeof(REAL)))
        {
            WARNING(("size too small"));
            goto ErrorExit;
        }

        this->SetCompoundArray((REAL *)dataBuffer, count);
        dataBuffer += (count * sizeof(REAL));
        size       -= (count * sizeof(REAL));
    }

    if (penData->Flags & GDIP_PENFLAGS_CUSTOMSTARTCAP)
    {
        if (size < sizeof(INT32))
        {
            WARNING(("size too small"));
            goto ErrorExit;
        }

        UINT    capSize = ((INT32 *)dataBuffer)[0];
        dataBuffer += sizeof(INT32);
        size       -= sizeof(INT32);

        if ((size < capSize) || (capSize < sizeof(ObjectTypeData)))
        {
            WARNING(("size too small"));
            goto ErrorExit;
        }

        ASSERT(DevicePen.CustomStartCap == NULL);
        DevicePen.CustomStartCap = (GpCustomLineCap *)GpObject::Factory(ObjectTypeCustomLineCap, (const ObjectData *)dataBuffer, capSize);

        if ((DevicePen.CustomStartCap == NULL) ||
            (DevicePen.CustomStartCap->SetData(dataBuffer, capSize) != Ok) ||
            !DevicePen.CustomStartCap->IsValid())
        {
            WARNING(("Failure getting CustomStartCap"));
            goto ErrorExit;
        }

        dataBuffer += capSize;
        size       -= capSize;
    }

    if (penData->Flags & GDIP_PENFLAGS_CUSTOMENDCAP)
    {
        if (size < sizeof(INT32))
        {
            WARNING(("size too small"));
            goto ErrorExit;
        }

        UINT    capSize = ((INT32 *)dataBuffer)[0];
        dataBuffer += sizeof(INT32);
        size       -= sizeof(INT32);

        if ((size < capSize) || (capSize < sizeof(ObjectTypeData)))
        {
            WARNING(("size too small"));
            goto ErrorExit;
        }

        ASSERT(DevicePen.CustomEndCap == NULL);
        DevicePen.CustomEndCap = (GpCustomLineCap *)GpObject::Factory(ObjectTypeCustomLineCap, (const ObjectData *)dataBuffer, capSize);

        if ((DevicePen.CustomEndCap == NULL) ||
            (DevicePen.CustomEndCap->SetData(dataBuffer, capSize) != Ok) ||
            !DevicePen.CustomEndCap->IsValid())
        {
            WARNING(("Failure getting CustomEndCap"));
            goto ErrorExit;
        }

        dataBuffer += capSize;
        size       -= capSize;
    }

    if (Brush != NULL)
    {
        Brush->Dispose();
        Brush = NULL;
    }

    if (size >= sizeof(ObjectTypeData))
    {
        Brush = (GpBrush *)GpObject::Factory(ObjectTypeBrush, (const ObjectData *)dataBuffer, size);
        if (Brush != NULL)
        {
            if ((Brush->SetData(dataBuffer, size) == Ok) && Brush->IsValid())
            {
                DevicePen.Brush = Brush->GetDeviceBrush();
                SetValid(TRUE);
                UpdateUid();
                return Ok;
            }
            Brush->Dispose();
            Brush = NULL;
        }
    }
    WARNING(("Failure getting brush"));

ErrorExit:
    SetValid(FALSE);
    return GenericError;
}

GpStatus
GpPen::ColorAdjust(
    GpRecolor *             recolor,
    ColorAdjustType         type
    )
{
    ASSERT(recolor != NULL);
    if (type == ColorAdjustTypeDefault)
    {
        type = ColorAdjustTypePen;
    }

    if (Brush != NULL)
    {
        Brush->ColorAdjust(recolor, type);
    }

    return Ok;
}

GpStatus
GpPen::GetColor(
    ARGB *argb
    ) const
{
    if (Brush->GetBrushType() == BrushTypeSolidColor)
    {
        GpSolidFill * solidBrush = (GpSolidFill *) Brush;

        *argb = solidBrush->GetColor().GetValue();

        return Ok;
    }

    return InvalidParameter;
}

GpStatus
GpPen::SetColor(
    GpColor *       color
    )
{
    if (Brush->GetBrushType() == BrushTypeSolidColor)
    {
        GpSolidFill * solidBrush = (GpSolidFill *) Brush;

        if (solidBrush->GetColor().GetValue() == color->GetValue())
        {
            return Ok;
        }

        // !!! bhouse why do we allocate another brush just to change the
        // pen's color !!!!
    }

    GpSolidFill *newBrush = new GpSolidFill(*color);

    if (newBrush != NULL)
    {
        if (newBrush->IsValid())
        {
            delete Brush;
            Brush = newBrush;
            DevicePen.Brush = Brush->GetDeviceBrush();
            UpdateUid();
            return Ok;
        }
        delete newBrush;
    }

    return GenericError;

}

GpStatus
GpPen::SetBrush(
    GpBrush *       brush
    )
{
    // Don't set the brush if it is the same color as the current one,
    // because that makes metafiles unnecessarily large.
    if ((Brush->GetBrushType() == BrushTypeSolidColor) &&
        (brush->GetBrushType() == BrushTypeSolidColor))
    {
        GpSolidFill * solidBrush = (GpSolidFill *) Brush;
        GpSolidFill * newSolidBrush = (GpSolidFill *) brush;

        if(solidBrush->GetColor().GetValue() ==
           newSolidBrush->GetColor().GetValue())
        {
            return Ok;
        }
    }

    GpBrush *   newBrush = brush->Clone();

    if (newBrush != NULL)
    {
        if (newBrush->IsValid())
        {
            delete Brush;
            Brush = newBrush;
            DevicePen.Brush = Brush->GetDeviceBrush();
            UpdateUid();
            return Ok;
        }
        delete newBrush;
    }
    return GenericError;
}

GpPenType
GpPen::GetPenType(
    )
{
    GpPenType type = PenTypeUnknown;

    if(Brush)
    {
        switch(Brush->GetBrushType())
        {
        case BrushTypeSolidColor:
            type = PenTypeSolidColor;
            break;

        case BrushTypeHatchFill:
            type = PenTypeHatchFill;
            break;

        case BrushTypeTextureFill:
            type = PenTypeTextureFill;
            break;
/*
        case BrushRectGrad:
            type = PenFillRectGrad;
            break;

        case BrushRadialGrad:
            type = PenFillRadialGrad;
            break;

        case BrushTriangleGrad:
            type = PenFillTriangleGrad;
            break;
*/
        case BrushTypePathGradient:
            type = PenTypePathGradient;
            break;

        case BrushTypeLinearGradient:
            type = PenTypeLinearGradient;
            break;

        default:
            break;
        }
    }

    // We must implement LineTexture case.

    return type;
}


/**************************************************************************\
*
* Function Description:
*
*   Adjust the dash array for dash caps if present.
*
*   Note that unlike line caps, dash caps do not extend the length
*   of the subpath, they are inset. So we shorten the dash segments
*   that draw a line and lengthen the dash segments that are spaces
*   by a factor of 2x the dash unit in order to leave space for the
*   caps that will be added by the widener.
*
*   This fixes Whistler bug #126476.
*
* Arguments:
*
*   [IN] dashCap - dash cap type
*   [IN] dashUnit - dash size - typically the pen width
*   [IN/OUT] dashArray - array containing the dash pattern that is adjusted.
*   [IN] dashCount - count of elements in the dash array
*
* Return Value:
*
*   None.
*
* History:
*
*   9/27/2000 jbronsk
*       Created.
*
*  12/06/2000 aaronlie
*       Moved from GpPath
*
\**************************************************************************/

VOID
GpPen::AdjustDashArrayForCaps(
    REAL dashUnit,
    REAL *dashArray,
    INT dashCount
    ) const
{
    REAL adjustmentLength = 2.0f *
        GetDashCapInsetLength(dashUnit);

    if (adjustmentLength > 0.0f)
    {
        const REAL minimumDashValue = dashUnit * 0.001f; // a small number
        for (int i = 0; i < dashCount; i++)
        {
            if (i & 0x1) // index is odd - so this is a space
            {
                // lengthen the spaces
                dashArray[i] += adjustmentLength;
            }
            else // index is even - so this is a line
            {
                // shorten the lines
                dashArray[i] -= adjustmentLength;
                // check if we have made the dash too small
                // (as in the case of 'dots')
                if (dashArray[i] < minimumDashValue)
                {
                    dashArray[i] = minimumDashValue;
                }
            }
        }
    }
}


/**************************************************************************\
*
* Function Description:
*
* Computes the length of the inset required to accomodate a particular
* dash cap type, since dash caps are contained within the dash length.
*
* Arguments:
*
*   [IN] dashUnit - pen width
*
* Return Value:
*
*   The amount that a dash needs to be inset on each end in order to
*   accomodate any dash caps.
*
* History:
*
*   9/27/2000 jbronsk
*       Created.
*
*  12/06/2000 aaronlie
*       Moved from GpPath
*
\**************************************************************************/

REAL
GpPen::GetDashCapInsetLength(
    REAL dashUnit
    ) const
{
    REAL insetLength = 0.0f;

    // dash caps can only be flat, round, or triangle
    switch(GetDashCap())
    {
    case LineCapFlat:
        insetLength = 0.0f;
        break;

    case LineCapRound:
    case LineCapTriangle:
        insetLength = dashUnit * 0.5f;
        break;
   }

   return insetLength;
}


/**************************************************************************\
*
* Function Description:
*
*   Does a quick check to see if the path can be rendered as a solid
*   pixel wide line.
*
* Arguments:
*
*   [IN] cappedDpiX - the resolution of the x direction
*   [IN] worldToDevice - World transform
*
* Return Value:
*
*   TRUE if okay to be rendered as a one pixel line
*
* History:
*
*   12/17/1999 ikkof
*       Created it.
*
\**************************************************************************/

BOOL
DpPen::IsOnePixelWideSolid(
    const GpMatrix *worldToDevice,
    REAL dpiX
    ) const
{
    return this->IsSimple() && this->IsOnePixelWide(worldToDevice, dpiX);
}

/**************************************************************************\
*
* Function Description:
*
*   Does a quick check to see if the path can be rendered as a one
*   pixel wide line.
*
* Arguments:
*
*   [IN] cappedDpiX - the resolution of the x direction
*   [IN] worldToDevice - World transform
*
* Return Value:
*
*   TRUE if okay to be rendered as a one pixel line
*
* History:
*
*   10/6/2000 - peterost - factored out fron IsOnePixelWideSolid
*
\**************************************************************************/

BOOL
DpPen::IsOnePixelWide(
    const GpMatrix *worldToDevice,
    REAL dpiX
    ) const
{
    BOOL useOnePixelPath = FALSE;

    const REAL minimumPenWidth = 1.5f;

    // !!![andrewgo] This determination of a single pixel wide line is
    //               unbelievably expensive

    // !!![andrewgo] This width check should be done simply using
    //               the world-to-device transform!  It would be
    //               faster and simpler!

    REAL width = this->Width;
    GpUnit unit = this->Unit;

    if(unit == UnitWorld)
    {
        if(worldToDevice == NULL || worldToDevice->IsTranslate())
        {
            if(width <= minimumPenWidth)
                useOnePixelPath = TRUE;
        }
        else if(worldToDevice->IsTranslateScale())
        {
            REAL m11 = worldToDevice->GetM11();
            REAL m22 = worldToDevice->GetM22();
            REAL maxScale = max(REALABS(m11), REALABS(m22));

            if(width*maxScale <= minimumPenWidth)
                useOnePixelPath = TRUE;
        }
        else
        {
            // This is a general transform.

            REAL majorR, minorR;    // Radii for major and minor axis.

            if(::GetMajorAndMinorAxis(
                &majorR,
                &minorR,
                worldToDevice) == Ok)
            {
                if(width*majorR <= minimumPenWidth)
                    useOnePixelPath = TRUE;
            }
        }
    }
    else
    {
        // Since GDI+ only uses the World Uinit, this code is not called
        // any more.

        width = ::GetDeviceWidth(width, unit, dpiX);
        if(width <= minimumPenWidth)
            useOnePixelPath = TRUE;
    }

    return useOnePixelPath;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\entry\pathwidener.hpp ===
/**************************************************************************\
*
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   PathWidener.hpp
*
* Abstract:
*
*   Class used for Path widening
*
* Revision History:
*
*   11/24/99 ikkof
*       Created it.
*
\**************************************************************************/

#ifndef _PATHWIDENER_HPP
#define _PATHWIDENER_HPP

enum GpLineCapMode
{
    LineCapDefaultMode = 0,
    LineCapDashMode = 1
};

class GpPathWidener
{
private:
    // We now use an ObjectTag to determine if the object is valid
    // instead of using a BOOL.  This is much more robust and helps
    // with debugging.  It also enables us to version our objects
    // more easily with a version number in the ObjectTag.
    ObjectTag           Tag;    // Keep this as the 1st value in the object!

protected:
    VOID SetValid(BOOL valid)
    {
        Tag = valid ? ObjectTagPathWidener : ObjectTagInvalid;
    }

public:

    GpPathWidener(
        const GpPointF* points,
        const BYTE* types,
        INT count,
        const DpPen* pen,
        const GpMatrix* matrix,
        REAL dpiX,
        REAL dpiY,
        BOOL isAntiAliased,
        BOOL isInsetPen = FALSE
        )
    {
        Initialize(
            points, 
            types, 
            count, 
            pen, 
            matrix, 
            dpiX, 
            dpiY,
            isAntiAliased, 
            isInsetPen
        );
    }
    
    GpPathWidener(
        GpPath *path,
        const DpPen* pen,
        const GpMatrix* matrix,
        REAL dpiX,
        REAL dpiY,
        BOOL isAntiAliased,
        BOOL isInsetPen = FALSE
        )
    {
        const GpPointF* points = path->GetPathPoints();
        const BYTE* types = path->GetPathTypes();
        INT count = path->GetPointCount();

        Initialize(
            points, 
            types, 
            count, 
            pen, 
            matrix, 
            dpiX, 
            dpiY,
            isAntiAliased, 
            isInsetPen
        );
    }

    GpPathWidener(
        const GpPointF* points,
        const BYTE* types,
        INT count,
        const DpPen* pen,
        const GpMatrix* matrix,
        REAL dpiX,
        REAL dpiY,
        BOOL isAntiAliased,
        BYTE* centerTypesBuffer,
        GpPointF* centerPointsBuffer,
        GpPointF* gradientsBuffer,
        GpPointF* normalsBuffer,
        BYTE* leftTypesBuffer,
        GpPointF* leftPointsBuffer,
        BYTE* rightTypesBuffer,
        GpPointF* rightPointsBuffer,
        INT bufferCount,
        BOOL isInsetPen = FALSE
        ) : CenterTypes(centerTypesBuffer, bufferCount),
            CenterPoints(centerPointsBuffer, bufferCount),
            Gradients(gradientsBuffer, bufferCount),
            Normals(normalsBuffer, bufferCount),
            LeftTypes(leftTypesBuffer, bufferCount),
            LeftPoints(leftPointsBuffer, bufferCount),
            RightTypes(rightTypesBuffer, bufferCount),
            RightPoints(rightPointsBuffer, bufferCount)
    {
        Initialize(points, types, count, pen, matrix, dpiX, dpiY,
            isAntiAliased, isInsetPen);
    }            

    ~GpPathWidener()
    {
        SetValid(FALSE);    // so we don't use a deleted object
    }

    GpStatus Widen(
        DynPointFArray* widenedPoints,
        DynByteArray* widenedTypes
        );
    
    GpStatus Widen(GpPath **path);

    BOOL IsValid() const
    {
        ASSERT((Tag == ObjectTagPathWidener) || (Tag == ObjectTagInvalid)); 
    #if DBG
        if (Tag == ObjectTagInvalid)
        {
            WARNING1("Invalid PathWidener");
        }
    #endif

        return (Tag == ObjectTagPathWidener);
    }

    REAL GetPenDelta();


protected:
    VOID Initialize(
        const GpPointF* points,
        const BYTE* types,
        INT count,
        const DpPen* pen,
        const GpMatrix* matrix,
        REAL dpiX,
        REAL dpiY,
        BOOL isAntiAliased,
        BOOL isInsetPen = FALSE
        );

    GpStatus WidenSubpath(
        DynPointFArray* widenedPoints,
        DynByteArray* widenedTypes,
        REAL leftWidth,
        REAL rightWidth,
        INT startIndex,
        INT endIndex,
        BOOL isClosed,
        GpLineCap startCap,
        GpLineCap endCap,
        BOOL useBevelJoinInside
        );

    GpStatus CalculateGradients(
        INT startIndex,
        INT endIndex
        );

    GpStatus CalculateNormals(
        REAL leftWidth,
        REAL rightWidth
        );

    GpStatus SetPolygonJoin(
        REAL leftWidth,
        REAL rightWidth,
        BOOL isAntialiased
        );

    GpStatus SetStartCapInset(
        REAL inset
        )
    {
        Inset1 = inset;

        return Ok;
    }

    GpStatus SetEndCapInset(
        REAL inset
        )
    {
        Inset2 = inset;

        return Ok;
    }
        
    VOID WidenFirstPoint(
        REAL leftWidth,
        REAL rightWidth,
        GpLineJoin lineJoin,
        REAL miterLimit2,
        GpPointF* leftPoints,
        BYTE* leftTypes,
        INT* addedLeftCount,
        GpPointF* rightPoints,
        BYTE* rightTypes,
        INT* addedRightCount,
        GpPointF* leftEndPt,
        GpPointF* rightEndPt,
        const GpPointF* grad,
        const GpPointF* norm,
        const GpPointF* dataPoints,
        INT dataCount,
        GpPointF* lastPt,
        const REAL* firstInsets,
        INT flag
    );

    GpStatus
    WidenEachPathType(
        BYTE pathType,
        REAL leftWidth,
        REAL rightWidth,
        GpLineJoin lineJoin,
        REAL miterLimit2,
        GpPointF* leftPoints,
        BYTE* leftTypes,
        INT* addedLeftCount,
        GpPointF* rightPoints,
        BYTE* rightTypes,
        INT* addedRightCount,
        const GpPointF* grad,
        const GpPointF* norm,
        const GpPointF* dataPoints,
        INT dataCount,
        GpPointF* lastPt,
        const REAL* lastInsets,
        INT flag
        );

    GpStatus
    WidenLinePoints(
        REAL leftWidth,
        REAL rightWidth,
        GpLineJoin lineJoin,
        REAL miterLimit2,
        GpPointF* leftPoints,
        BYTE* leftTypes,
        INT* addedLeftCount,
        GpPointF* rightPoints,
        BYTE* rightTypes,
        INT* addedRightCount,
        const GpPointF* grad,
        const GpPointF* norm,
        const GpPointF* dataPoints,
        INT dataCount,
        GpPointF* lastPt,
        const REAL* lastInsets,
        INT flag
        );

    GpStatus
    WidenBezierPoints(
        REAL leftWidth,
        REAL rightWidth,
        GpLineJoin lineJoin,
        REAL miterLimit2,
        GpPointF* leftPoints,
        BYTE* leftTypes,
        INT* addedLeftCount,
        GpPointF* rightPoints,
        BYTE* rightTypes,
        INT* addedRightCount,
        const GpPointF* grad,
        const GpPointF* norm,
        const GpPointF* dataPoints,
        INT dataCount,
        GpPointF* lastPt,
        const REAL* lastInsets,
        INT flag
        );
    
    GpStatus SetCaps(
        GpLineCap startCap,
        GpLineCap endCap,
        const GpPointF& startPoint,
        const GpPointF& startGrad,
        const GpPointF& startNorm,
        const GpPointF& endPoint,
        const GpPointF& endGrad,
        const GpPointF& endNorm,
        REAL leftWidth,
        REAL rightWidth,
        const GpPointF *points,
        INT pointCount
        );

    GpStatus SetCustomFillCaps(
        GpCustomLineCap* customStartCap,
        GpCustomLineCap* customEndCap,
        const GpPointF& startPoint,
        const GpPointF& endPoint,
        REAL leftWidth,
        REAL rightWidth,
        const GpPointF *centerPoints,
        const BYTE *centerTypes,
        INT centerPointCount,
        DynPointFArray *startCapPoints,
        DynPointFArray *endCapPoints,
        DynByteArray *startCapTypes,
        DynByteArray *endCapTypes
        );

    GpStatus SetCustomStrokeCaps(
        GpCustomLineCap* customStartCap,
        GpCustomLineCap* customEndCap,
        const GpPointF& startPoint,
        const GpPointF& endPoint,
        REAL leftWidth,
        REAL rightWidth,
        const GpPointF *centerPoints,
        const BYTE *centerTypes,
        INT centerPointCount,
        DynPointFArray *startCapPoints,
        DynPointFArray *endCapPoints,
        DynByteArray *startCapTypes,
        DynByteArray *endCapTypes
        );

    GpStatus SetRoundCap(
        const GpPointF& point,
        const GpPointF& grad,
        BOOL isStartCap,
        REAL leftWidth,
        REAL rightWidth
        );
    
    GpStatus SetDoubleRoundCap(
        const GpPointF& point,
        const GpPointF& grad,
        BOOL isStartCap,
        REAL leftWidth,
        REAL rightWidth
        );

    GpStatus SetTriangleCap(
        const GpPointF& point,
        const GpPointF& grad,
        BOOL isStartCap,
        REAL leftWidth,
        REAL rightWidth,
        const GpPointF *points,
        INT pointCount
        );

    GpStatus CombineSubpathOutlines(
        DynPointFArray* widenedPoints,
        DynByteArray* widenedTypes,
        BOOL isClosed,
        BOOL closeStartCap = FALSE,
        BOOL closeEndCap = FALSE
        );
    
    GpStatus CombineClosedCaps(
        DynPointFArray* widenedPoints,
        DynByteArray* widenedTypes,
        DynPointFArray *daStartCapPoints,
        DynPointFArray *daEndCapPoints,
        DynByteArray *daStartCapTypes,
        DynByteArray *daEndCapTypes
        );

    GpStatus AddCompoundCaps(
        DynPointFArray* widenedPoints,
        DynByteArray* widenedTypes,
        REAL leftWidth,
        REAL rightWidth,
        INT startIndex,
        INT endIndex,
        GpLineCap startCap,
        GpLineCap endCap
        );
    
    REAL GetSubpathPenMiterDelta(BOOL isClosed);

protected:
    DpPathIterator Iterator;
	DynByteArray CenterTypes;
    DynPointFArray CenterPoints;
    DynPointFArray Gradients;
    DynPointFArray Normals;

    DynByteArray LeftTypes;
    DynPointFArray LeftPoints;
    DynByteArray RightTypes;
    DynPointFArray RightPoints;

    BOOL InsetPenMode;           // are we doing inset pen using a center pen.
    const DpPen* Pen;
    GpMatrix XForm;
    GpMatrix InvXForm;
    REAL UnitScale;             // Scale factor for Page to Device units
    REAL StrokeWidth;
    REAL OriginalStrokeWidth;   // StrokeWidth is clamped to a minimum value
                                // but OriginalStrokeWidth is actual transformed
                                // pen width.
    REAL MinimumWidth;
    REAL MaximumWidth;
    BOOL IsAntiAliased;
    BOOL NeedsToTransform;
    BOOL NeedsToAdjustNormals;

    REAL DpiX;
    REAL DpiY;

    DynPointFArray JoinPolygonPoints;
    DynRealArray JoinPolygonAngles;

    // CapTypes1 and CapPoints1 are used for the start cap and left join.

    DynByteArray CapTypes1;
    DynPointFArray CapPoints1;
    REAL Inset1;    // Inset value for the starting position.
    
    // CapTypes2 and CapPoints2 are used for the end cap and right join.

    DynByteArray CapTypes2;
    DynPointFArray CapPoints2;
    REAL Inset2;    // Inset value for the ending position.
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\entry\pathwidener.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1999 - 2000  Microsoft Corporation
*
* Module Name:
*
*   PathWidener.cpp
*
* Abstract:
*
*   Implementation of the GpPathWidener class
*
* Revision History:
*
*   11/23/99 ikkof
*       Created it
*
\**************************************************************************/

#include "precomp.hpp"

// 4*(REALSQRT(2.0) - 1)/3
#define U_CIR ((REAL)(0.552284749))



// Define DEBUG_PATHWIDENER if debugging is necessary.

//#define DEBUG_PATHWIDENER

GpStatus ReversePath(INT count,GpPointF* points,BYTE* types);

const BOOL USE_POLYGON_JOIN = FALSE;

INT
CombinePaths(
    INT count,
    GpPointF* points,
    BYTE* types,
    INT count1,
    const GpPointF* points1,
    const BYTE* types1,
    BOOL forward1,
    INT count2,
    const GpPointF* points2,
    const BYTE* types2,
    BOOL forward2,
    BOOL connect
    );

GpStatus
CalculateGradientArray(
    GpPointF* grad,
    REAL* distances,
    const GpPointF* points,
    INT count
    );

GpStatus
GetMajorAndMinorAxis(
    REAL* majorR,
    REAL* minorR,
    const GpMatrix* matrix
    );

enum
{
    WideningClosed = 1,
    WideningFirstType = 2,
    WideningLastType = 4,
    WideningLastPointSame = 8,
    WideningNeedsToAdjustNormals = 16,
    WideningUseBevelJoinInside = 32
};

enum GpTurningDirection
{
    NotTurning = 0,
    TurningBack = 1,
    TurningRight = 2,
    TurningLeft = 3,
    NotMoving = -1
};

GpTurningDirection
getJoin(
    GpLineJoin lineJoin,
    const GpPointF& point,
    const GpPointF& grad1,
    const GpPointF& grad2,
    const GpPointF& norm1,
    const GpPointF& norm2,
    REAL leftWidth,
    REAL rightWidth,
    INT *leftCount,
    GpPointF *leftPoints,
    BOOL *leftInside,
    INT *rightCount,
    GpPointF *rightPoints,
    BOOL *rightInside,
    BOOL needsToAdjustNormals,
    REAL miterLimit2
    );

/**************************************************************************\
*
* Function Description:
*
*   This reverses the path data.
*
* Arguments:
*
*   [IN] count - the number of points.
*   [IN/OUT] points - the data points to be reversed.
*   [IN/OUT] types - the data types to be reversed.
*
* Return Value:
*
*   Status
*
\**************************************************************************/

GpStatus
ReversePath(
    INT count,
    GpPointF* points,
    BYTE* types
    )
{
    DpPathTypeIterator iter(types, count);

    if(!iter.IsValid())
        return InvalidParameter;

    INT startIndex, endIndex;
    BOOL isClosed;
    BOOL isStartDashMode, isEndDashMode;
    BOOL wasMarkerEnd = FALSE;

    INT i;

    while(iter.NextSubpath(&startIndex, &endIndex, &isClosed))
    {
        if((types[startIndex] & PathPointTypeDashMode) != 0)
            isStartDashMode = TRUE;
        else
            isStartDashMode = FALSE;
        if((types[endIndex] & PathPointTypeDashMode) != 0)
            isEndDashMode = TRUE;
        else
            isEndDashMode = FALSE;

        BOOL isMarkerEnd
            = (types[endIndex] & PathPointTypePathMarker) != 0;

        BYTE startType = types[startIndex]; // Save the first type.

        // Shift type points.

        for(i = startIndex + 1; i <= endIndex; i++)
        {
            types[i - 1] = types[i];
        }

        // Clear the close subpapth flag for original type (now at endIndex - 1).

        if(endIndex > 0)
            types[endIndex - 1] &= ~PathPointTypeCloseSubpath;
        
        types[endIndex] = PathPointTypeStart;

        if(isStartDashMode)
            types[startIndex] |= PathPointTypeDashMode;
        else
            types[startIndex] &= ~PathPointTypeDashMode;

        if(isEndDashMode)
            types[endIndex] |= PathPointTypeDashMode;
        else
            types[endIndex] &= ~PathPointTypeDashMode;

        // Add the dash and close flag.

        if(isClosed)
            types[startIndex] |= PathPointTypeCloseSubpath;
        else
            types[startIndex] &= ~PathPointTypeCloseSubpath;

        // Shift the marker flag by 1 from the original position.
        // This means we have to shift by 2 since the types array
        // was shifted by -1.

        for(i = endIndex; i >= startIndex + 2; i--)
        {
            if(types[i - 2] & PathPointTypePathMarker)
                types[i] |= PathPointTypePathMarker;
            else
                types[i] &= ~PathPointTypePathMarker;
        }
        
        // Shift Marker flag from the startIndex.

        if(startType & PathPointTypePathMarker)
            types[startIndex + 1] |= PathPointTypePathMarker;
        else
            types[startIndex + 1] &= ~PathPointTypePathMarker;
        
        // Shift Marker flag from the end of the previous subpath.

        if(wasMarkerEnd)
            types[startIndex] |= PathPointTypePathMarker;
        else
            types[startIndex] &= ~PathPointTypePathMarker;

        wasMarkerEnd = isMarkerEnd;

        // Keep the location of the internal flag.  So we must
        // shift back by 1.

        for(i = endIndex; i >= startIndex + 1; i--)
        {
            if(types[i - 1] & PathPointTypeInternalUse)
                types[i] |= PathPointTypeInternalUse;
            else
                types[i] &= ~PathPointTypeInternalUse;
        }
        if(startType & PathPointTypeInternalUse)
            types[startIndex] |= PathPointTypeInternalUse;
        else
            types[startIndex] &= ~PathPointTypeInternalUse;
    }

    // Reverse the points and types data.

    INT halfCount = count/2;
    for(i = 0; i < halfCount; i++)
    {
        GpPointF tempPt;
        BYTE tempType;

        tempPt = points[count - 1 - i];
        tempType = types[count - 1 - i];
        points[count - 1 - i] = points[i];
        types[count -1 - i] = types[i];
        points[i] = tempPt;
        types[i] = tempType;
    }       
    
#ifdef DEBUG_PATHWIDENER
    DpPathTypeIterator iter2(types, count);

    if(!iter2.IsValid())
    {
        WARNING(("ReversePath: failed."));
        return GenericError;
    }
#endif

    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   This combines the two open segments each of which is continuous.
*   The data is returned to points1 and types1.  They must be allocated
*   at least the array size of count1 + count2.
*
* Arguments:
*
*   [IN] count1 - the number of points of the first path.
*   [IN/OUT] points1 - the first path points.
*   [IN/OUT] types1 - the first path types.
*   [IN] forward1 - the direction of the first path. TRUE if forward.
*   [IN] count2 - the number of points of the second path.
*   [IN] points2 - the second path points.
*   [IN] types2 - the second path types.
*   [IN] forward2 - the direction of the second path.  TRUE if forward.
*
* Return Value:
*
*   The total number of points of the combined path.
*
\**************************************************************************/

INT
combineTwoOpenSegments(
    INT count1,
    GpPointF* points1,
    BYTE* types1,
    BOOL forward1,
    INT count2,
    GpPointF* points2,
    BYTE* types2,
    BOOL forward2
    )
{
    GpStatus status = Ok;

    if(
        count1 < 0 || !points1 || !types1 ||
        count2 < 0 || !points2 || !types2
        )
        return 0;
    
    if(!forward1 && count1 > 0)
    {
        status = ::ReversePath(count1, points1, types1);
        if(status != Ok)
            return 0;
    }

    if(!forward2 && count2 > 0)
    {
        status = ::ReversePath(count2, points2, types2);
        if(status != Ok)
            return 0;
    }

    INT offset = 0;

    if(count1 > 0 && count2 > 0)
    {
        if(REALABS(points1[count1 - 1].X - points2[0].X) +
            REALABS(points1[count1 - 1].Y - points2[0].Y)
            < POINTF_EPSILON
            )
            offset = 1;
    }

    if(count2 - offset > 0)
    {
        GpMemcpy(
            points1 + count1,
            points2 + offset,
            (count2 - offset)*sizeof(GpPointF)
            );
        GpMemcpy(
            types1 + count1,
            types2 + offset,
            count2 - offset
            );
    }

    BYTE saveType = types1[0];
    types1[0] = PathPointTypeLine |
        (saveType & ~PathPointTypePathTypeMask);

    // Make sure the first path is not closed.

    if(count1 > 0)
    {
        if(types1[count1 - 1] & PathPointTypeCloseSubpath)
            types1[count1 - 1] &= ~PathPointTypeCloseSubpath;
    }


    // Set the first point type of the second path correctly.

    if(offset == 0)
    {
        saveType = types1[count1];
        types1[count1] = PathPointTypeLine |
            (saveType & ~PathPointTypePathTypeMask);
    }

    // Make sure this path is not closed.

    INT total = count1 + count2 - offset;

    if(total > 0)
    {
        if(types1[total - 1] & PathPointTypeCloseSubpath)
            types1[total - 1] &= ~PathPointTypeCloseSubpath;
    }

    return total;
}


/**************************************************************************\
*
* Function Description:
*
*   This combines the two closed segments each of which is made of closed
*   segments.
*   The data is returned to points1 and types1.  They must be allocated
*   at least the array size of count1 + count2.
*
* Arguments:
*
*   [IN] count1 - the number of points of the first path.
*   [IN/OUT] points1 - the first path points.
*   [IN/OUT] types1 - the first path types.
*   [IN] forward1 - the direction of the first path. TRUE if forward.
*   [IN] count2 - the number of points of the second path.
*   [IN] points2 - the second path points.
*   [IN] types2 - the second path types.
*   [IN] forward2 - the direction of the second path.  TRUE if forward.
*
* Return Value:
*
*   The total number of points of the combined path.
*
\**************************************************************************/

INT
combineClosedSegments(
    INT count1,
    GpPointF* points1,
    BYTE* types1,
    BOOL forward1,
    INT count2,
    GpPointF* points2,
    BYTE* types2,
    BOOL forward2
    )
{
    GpStatus status = Ok;

    if(
        count1 < 0 || !points1 || !types1 ||
        count2 < 0 || !points2 || !types2
        )
        return 0;
    
    if(count1 == 0 && count2 == 0)
        return 0;

    if(!forward1 && count1 > 0)
    {
        status = ::ReversePath(count1, points1, types1);
        if(status != Ok)
            return 0;
    }

    if(!forward2 && count2 > 0)
    {
        status = ::ReversePath(count2, points2, types2);
        if(status != Ok)
            return 0;
    }

    // Make sure the first path is closed.
    
    types1[0] = PathPointTypeStart;
    if(count1 > 0)
    {        
        if((types1[count1 - 1] & PathPointTypeCloseSubpath) == 0)
            types1[count1 - 1] |= PathPointTypeCloseSubpath;
    }

    INT total = count1 + count2;

    if(count2 > 0)
    {
        GpMemcpy(points1 + count1, points2, count2*sizeof(GpPointF));
        GpMemcpy(types1 + count1, types2, count2);
        BYTE saveType = types1[count1];
        types1[count1] = PathPointTypeStart |
            (saveType & ~PathPointTypePathTypeMask);

        // Make sure the second path is closed.
        
        types1[total - 1] |= PathPointTypeCloseSubpath;
    }

    return total;
}

/**************************************************************************\
*
* Function Description:
*
*   This combines the two data points.  This is a general algorithm.
*   The output buffers (points and types) can be the same as the
*   first input buffers (points1 and types1).  In that case, both
*   buffers must be allocated at least to the array size of
*   count1 + count2.
*
* Arguments:
*
*   [IN] count - the allocated number of points (>= count1 + count2).
*   [OUT] points - the combined data points.
*   [OUT] types - the combined data types.
*   [IN] count1 - the number of points of the first path.
*   [IN] points1 - the first path points.
*   [IN] types1 - the first path types.
*   [IN] forward1 - the direction of the first path. TRUE if forward.
*   [IN] count2 - the number of points of the second path.
*   [IN] points2 - the second path points.
*   [IN] types2 - the second path types.
*   [IN] forward2 - the direction of the second path.  TRUE if forward.
*   [IN] connect - TRUE if the second line needs to be connected.
*
* Return Value:
*
*   The total number of points of the combined path.
*
\**************************************************************************/

INT
CombinePaths(
    INT count,
    GpPointF* points,
    BYTE* types,
    INT count1,
    const GpPointF* points1,
    const BYTE* types1,
    BOOL forward1,
    INT count2,
    const GpPointF* points2,
    const BYTE* types2,
    BOOL forward2,
    BOOL connect
    )
{
    if(!points || !types || count < count1 + count2
        || count1 < 0 || !points1 || !types1
        || count2 < 0 || !points2 || !types2)
        return 0;
    
    // Check if the returning buffers are the same as the
    // first input buffers.

    INT resultCount = 0;
    if(points != points1 || types != types1)
    {
        if(points == points1 || types == types1)
        {
            // The both output buffer must be different.
            // If either of them is the same, don't combine
            // the path.

            return 0;
        }

        if(count1 > 0)
        {
            // Copy the first path.

            DpPathIterator iter1(points1, types1, count1);

            if(!iter1.IsValid())
                return 0;

            resultCount = iter1.Enumerate(points, types, count1);

            if(resultCount <= 0)
                return 0;
        }
    }
    else
    {
        // Both output buffers are the same as the first output
        // buffers.

        resultCount = count1;
    }

    GpStatus status = Ok;
    BOOL path1Closed;

    if(!forward1 && resultCount > 0)
    {
        status = ::ReversePath(resultCount, points, types);
        if(status != Ok)
            return 0;
    }

    if(count2 <= 0)
    {
        // No need to add the second path.

        return resultCount;
    }

    // Regard the empty path as a closed path.

    path1Closed = TRUE;

    if(resultCount > 0)
    {
        // Check the last point of path1.

        if((types[resultCount - 1] & PathPointTypeCloseSubpath))
            path1Closed = TRUE;
        else
            path1Closed = FALSE;
    }

    INT totalCount = 0;
    totalCount += resultCount;

    DpPathIterator iter2(points2, types2, count2);

    if(!iter2.IsValid())
        return 0;

    GpPointF* pts2 = points + resultCount;
    BYTE* typs2 = types + resultCount;

    resultCount = iter2.Enumerate(pts2, typs2, count2);

    if(resultCount <= 0)
        return 0;

    if(!forward2)
    {
        status = ::ReversePath(resultCount, pts2, typs2);
        if(status != Ok)
            return 0;
    }

    // Check if the first subpath of path2 is closed or not.

    BOOL path2Closed;

    DpPathTypeIterator iter3(typs2, resultCount);
    if(!iter3.IsValid())
        return 0;

    INT startIndex, endIndex;
    iter3.NextSubpath(&startIndex, &endIndex, &path2Closed);

    BYTE saveType= typs2[0];

    if(path1Closed || path2Closed)
    {
        typs2[0] = PathPointTypeStart |
            (saveType & ~PathPointTypePathTypeMask);
    }
    else
    {
        // Both paths are opened.

        if(connect)
        {
            typs2[0] = PathPointTypeLine |
                (saveType & ~PathPointTypePathTypeMask);

            // Check if the end point of path1 and the start point of path2
            // are the same.  If so, skip this point.

            if(REALABS(pts2[-1].X - pts2[0].X)
                + REALABS(pts2[-1].Y - pts2[0].Y) < POINTF_EPSILON)
            {
                for(INT i = 0; i < resultCount - 1; i++)
                {
                    pts2[i] = pts2[i + 1];
                    typs2[i] = typs2[i + 1];
                }
                resultCount--;
            }
        }
        else
        {
            typs2[0] = PathPointTypeStart |
                (saveType & ~PathPointTypePathTypeMask);
        }
    }

    totalCount += resultCount;

    return totalCount;
}

/**************************************************************************\
*
* Function Description:
*
*   Removes the degenerate points and copy only non-degenerate points.
*   It is assumed that points and types array are allocated so that
*   they can hold at least "count" number of elements.
*
* Arguments:
*
*   [IN] pathType - the type of the path data to be added.
*   [OUT] points - the copied data points.
*   [OUT] types - the copied data types.
*   [IN] dataPoints - the original data points.
*   [IN] count - the number of the original data points.
*   [IN/OUT] lastPt - the last point.
*
* Return Value:
*
*   The total number of copied points.
*
\**************************************************************************/

INT copyNonDegeneratePoints(
    BYTE pathType,
    GpPointF* points,
    BYTE* types,
    const GpPointF* dataPoints,
    const BYTE* dataTypes,
    INT count,
    GpPointF* lastPt
    )
{
    GpPointF nextPt;
    INT addedCount = 0;

    if(pathType == PathPointTypeLine)
    {
        // Add only the different points.

        for(INT i = 0; i < count; i++)
        {
            nextPt = *dataPoints++;

            if( (REALABS(nextPt.X - lastPt->X) > REAL_EPSILON) ||
                (REALABS(nextPt.Y - lastPt->Y) > REAL_EPSILON) )
            {
                *points++ = nextPt;
                *lastPt = nextPt;
                addedCount++;
            }
        }
        if(addedCount > 0)
        {
            GpMemset(types, pathType, addedCount);
        }
    }
    else
    {
        // In case of Bezier, we need to do
        // degenerate case test for future.

        addedCount = count;

        if(addedCount > 0)
        {
            if(dataTypes)
            {
                GpMemcpy(types, dataTypes, addedCount);
            }
            else
            {
                GpMemset(types, pathType, addedCount);
            }

            GpMemcpy(
                points,
                dataPoints,
                addedCount*sizeof(GpPointF)
            );
        }
        else
        {
            addedCount = 0;
        }
    }

    return addedCount;
}


/**************************************************************************\
*
* Function Description:
*
*   This calculates the major and minor radius of an oval
*   when the unit cricle is transformed by the given matrix.
*   For further details, see ikkof's notes on Pen Transform.
*
* Arguments:
*
*   [OUT] majorR - the major radius.
*   [OUT] minorR - the minor radius.
*   [IN] matrix - the matrix to transform the unit circle.
*
* Return Value:
*
*   Status
*
*   01/28/00 ikkof
*       Created it
*
\**************************************************************************/

GpStatus
GetMajorAndMinorAxis(REAL* majorR, REAL* minorR, const GpMatrix* matrix)
{
    if(matrix == NULL)
    {
        // Regard this as an identity matrix.
        *majorR = 1;
        *minorR = 1;
        return Ok;
    }

    REAL m11 = matrix->GetM11();
    REAL m12 = matrix->GetM12();
    REAL m21 = matrix->GetM21();
    REAL m22 = matrix->GetM22();

    REAL d1 = ((m11*m11 + m12*m12) - (m21*m21 + m22*m22))/2;
    REAL d2 = m11*m21 + m12*m22;
    REAL D = d1*d1 + d2*d2;
    if(D > 0)
        D = REALSQRT(D);

    REAL r0 = (m11*m11 + m12*m12 + m21*m21 + m22*m22)/2;

    REAL r1 = REALSQRT(r0 + D);
    REAL r2 = REALSQRT(r0 - D);
    
    // They should be positive numbers.  Prevent the floating
    // point underflow.

    if(r1 <= CPLX_EPSILON)
        r1 = CPLX_EPSILON;
    if(r2 <= CPLX_EPSILON)
        r2 = CPLX_EPSILON;

    *majorR = r1;
    *minorR = r2;

    return Ok;
}

VOID
GpPathWidener::Initialize(
    const GpPointF* points,
    const BYTE* types,
    INT count,
    const DpPen* pen,
    const GpMatrix* matrix,
    REAL dpiX,               // These parameters are not really used
    REAL dpiY,               //
    BOOL isAntiAliased,      // This one is definitely not used.
    BOOL isInsetPen 
    )
{
    SetValid(FALSE);

    Inset1 = 0;
    Inset2 = 0;
    NeedsToTransform = FALSE;
    IsAntiAliased = isAntiAliased;

    // nothing to widen, so return an invalid widener.
    
    if( (!pen) || (count == 0) )
    {
        return;
    }

    Pen = pen;
    GpUnit unit = Pen->Unit;
    InsetPenMode = isInsetPen;

    if(unit == UnitWorld)
        NeedsToTransform = FALSE;
    else
        NeedsToTransform = TRUE;

    GpMatrix penTrans = ((DpPen*) Pen)->Xform;
    BOOL hasPenTransform = FALSE;

    if(!NeedsToTransform && !penTrans.IsTranslate())
    {
        hasPenTransform = TRUE;
        penTrans.RemoveTranslation();
    }

    if(matrix)
        XForm = *matrix;    // Otherwise XForm remains Identity.

    if(hasPenTransform)
    {
        XForm.Prepend(penTrans);
    }


    DpiX = dpiX;
    DpiY = dpiY;
    
    // 0 means use the Desktop DPI
        
    if ((REALABS(DpiX) < REAL_EPSILON) || 
        (REALABS(DpiY) < REAL_EPSILON)    )
    {
        DpiX = Globals::DesktopDpiX;
        DpiY = Globals::DesktopDpiY;
    }


    StrokeWidth = Pen->Width;
    
    if(!NeedsToTransform)
    {
        REAL majorR, minorR;

        ::GetMajorAndMinorAxis(&majorR, &minorR, &XForm);
        MaximumWidth = StrokeWidth*majorR;
        MinimumWidth = StrokeWidth*minorR;
        UnitScale = min (majorR, minorR);
    }
    else
    {
        UnitScale = ::GetDeviceWidth(1.0f, unit, dpiX);
        StrokeWidth = UnitScale * StrokeWidth;
        MinimumWidth = StrokeWidth;
    }

    OriginalStrokeWidth = StrokeWidth;
    
    // Set minimum width to 1.0 (plus a bit for possible precision errors), 
    // so that narrow width pens don't end up leaving gaps in the line.
    REAL minWidth = 1.000001f; 
    
    if(InsetPenMode)
    {
        minWidth *= 2.0f;
        
        // Dashes smaller than a pixel are dropping out entirely in inset 
        // pen because of the rasterizer pixel level clipping that is taking
        // place. We increase the minimum width of dashed lines making them
        // roughly 4.0f. This also helps address the weird moire aliasing 
        // effects with the really small dash-dot round lines.
        
        if(Pen->DashStyle != DashStyleSolid)
        {
            minWidth *= 2.0f;
        }
    }

    if(!NeedsToTransform)
    {
        if(MinimumWidth < minWidth) 
        {
            NeedsToTransform = TRUE;
            StrokeWidth = minWidth;
            MaximumWidth = minWidth;
            MinimumWidth = minWidth;

            // Ignore the pen transform.
            
            XForm.Reset();
            if(matrix)
                XForm = *matrix;
            
            hasPenTransform = FALSE;
            penTrans.Reset();
        }
    }

    InvXForm = XForm;
    if(InvXForm.IsInvertible())
    {
        InvXForm.Invert();

        if(hasPenTransform)
            penTrans.Invert();
    }
    else
    {
        WARNING(("The matrix is degenerate for path widening constructor."));
        return;
    }

    const GpPointF* points1 = points;
    GpPointF pointBuffer[32];
    GpPointF* points2 = pointBuffer;

    if((hasPenTransform && !NeedsToTransform)|| (NeedsToTransform && !XForm.IsIdentity()))
    {
        if(count > 32)
        {
            points2 = (GpPointF*) GpMalloc(count*sizeof(GpPointF));
        }

        if(points2)
        {
            GpMemcpy(points2, points, count*sizeof(GpPointF));

            if(hasPenTransform && !NeedsToTransform)
            {
                // Apply the inverse transform of Pen.
                
                penTrans.Transform(points2, count);
            }
            else
            {
                // Transform to the device coordinates.

                XForm.Transform(points2, count);
            }

            points1 = points2;
        }
        else
        {
            WARNING(("Not enough memory for path widening constructor."));
            return;
        }
    }

    DpPathIterator iter(points1, types, count);

    if(!iter.IsValid())
    {
        if(points2 != pointBuffer)
        {
            GpFree(points2);
        }
        return;
    }

    // Make sure given poins are not degenerate.

    BOOL degenerate = TRUE;
    INT k = 1;

    while(degenerate && k < count)
    {
        if(points1[k-1].X != points1[k].X || points1[k-1].Y != points1[k].Y)
            degenerate = FALSE;
        k++;
    }
    if(degenerate)
    {
        if(points2 != pointBuffer)
        {
            GpFree(points2);
        }
        WARNING(("Input data is degenerate for widening."));
        return;
    }
    
    GpStatus status = Ok;
    INT startIndex, endIndex;
    BOOL isClosed;
    INT dataCount = 0;
    BYTE* ctrTypes = NULL;
    GpPointF* ctrPoints = NULL;
    GpPointF lastPt, nextPt;

    while(iter.NextSubpath(&startIndex, &endIndex, &isClosed) && status == Ok)
    {
        INT typeStartIndex, typeEndIndex;
        BYTE pathType;
        BOOL isFirstPoint = TRUE;

        while(iter.NextPathType(&pathType, &typeStartIndex, &typeEndIndex)
                && status == Ok)
        {
            INT segmentCount;
            const GpPointF* dataPoints = NULL;
            const BYTE* dataTypes = NULL;

            nextPt = points1[typeStartIndex];

            switch(pathType)
            {
            case PathPointTypeStart:
                break;

            case PathPointTypeBezier:
            
                // The path must be flattened before calling widen.
                
                ASSERT(FALSE);
                break;
                
            case PathPointTypeLine:
            default:    // And all other types are treated as line points.

                // Get the data for the Line segment.

                segmentCount = typeEndIndex - typeStartIndex + 1;
                dataPoints = points1 + typeStartIndex;
                dataTypes = NULL;
                break;
            }

            if(status == Ok && pathType != PathPointTypeStart)
            {
                // Allocate memory for CenterTypes and CenterPoints.

                status = CenterTypes.ReserveSpace(segmentCount);
                if(status == Ok)
                    status = CenterPoints.ReserveSpace(segmentCount);

                if(status == Ok)
                {
                    ctrTypes = CenterTypes.GetDataBuffer();
                    ctrPoints = CenterPoints.GetDataBuffer();
                }
                else
                {
                    ctrTypes = NULL;
                    ctrPoints = NULL;
                }

                if(ctrTypes && ctrPoints)
                {
                    BYTE nextType;

                    INT n = CenterTypes.GetCount();
                    ctrTypes += n;
                    ctrPoints += n;

                    dataCount = 0;
                    
                    // Add the first point.

                    if(isFirstPoint)
                    {
                        // We must check the dash mode
                        // for the first point of the subpath.

                        nextType = PathPointTypeStart;
                        if(iter.IsDashMode(typeStartIndex))
                            nextType |= PathPointTypeDashMode;
                        else
                            nextType &= ~PathPointTypeDashMode;

                        *ctrTypes++ = nextType;
                        *ctrPoints++ = nextPt;
                        lastPt = nextPt;
                        isFirstPoint = FALSE;
                        dataCount++;
                    }
                    else
                    {
                        // Don't copy the first
                        // if it is the same as the last point.

                        if(lastPt.X != nextPt.X || lastPt.Y != nextPt.Y)
                        {
                            // We don't have to check dash mode
                            // for the intermediate points.

                            nextType = PathPointTypeLine;

                            *ctrTypes++ = nextType;
                            *ctrPoints++ = nextPt;
                            lastPt = nextPt;
                            dataCount++;
                        }
                    }

                    // Add the remaining points.

                    segmentCount--;
                    dataPoints++;
                    if(dataTypes)
                        dataTypes++;
                    INT addedCount = copyNonDegeneratePoints(
                                        pathType,
                                        ctrPoints,
                                        ctrTypes,
                                        dataPoints,
                                        dataTypes,
                                        segmentCount,
                                        &lastPt);
                    dataCount += addedCount;

                    CenterTypes.AdjustCount(dataCount);
                    CenterPoints.AdjustCount(dataCount);
                }
                else
                    status = OutOfMemory;
            }
            lastPt = points1[typeEndIndex];
        }

        if(status == Ok)
        {
            ctrTypes = CenterTypes.GetDataBuffer();
            dataCount = CenterTypes.GetCount();

            if(isClosed)
                ctrTypes[dataCount - 1] |= PathPointTypeCloseSubpath;
            else
                ctrTypes[dataCount - 1] &= ~PathPointTypeCloseSubpath;

            // We must check the dash mode for the last
            // point of the subpath.

            if(iter.IsDashMode(endIndex))
                ctrTypes[dataCount - 1] |= PathPointTypeDashMode;
            else
                ctrTypes[dataCount - 1] &= ~PathPointTypeDashMode;
        }
    }

    if(points2 != pointBuffer)
    {
        GpFree(points2);
    }

    if(status == Ok)
	{
		ctrPoints = CenterPoints.GetDataBuffer();
        ctrTypes = CenterTypes.GetDataBuffer();
        dataCount = CenterPoints.GetCount();

        Iterator.SetData(ctrPoints, ctrTypes, dataCount);
		SetValid(Iterator.IsValid());

#ifdef DEBUG_PATHWIDENER

		if(!IsValid())
		{
			WARNING(("PathWidener is invalid."));
		}

#endif
	}
}

/**************************************************************************\
*
* Function Description:
*
*   Calculates the unit gradient vectors of points as array of
*   (count + 1).  All the memories must be allocated and be checked
*   by the caller.
*
*   The first element of the gradient is from the end point to the
*   the start point.  If the end point is identical to the start point,
*   the previous point is used.
*   The last element of the gradient is from the start point to the end
*   point.  If the start point is identical to the end point, the next
*   point is used.
*   If distances array is not NULL, this returns the distance of each
*   segments.
*
* Arguments:
*
*   [OUT] grad - The gradient array of (count + 1) elements.
*   [OUT] distances - The distance array of (count + 1) elements or NULL.
*   [IN] points - The given points of count elements.
*   [IN] count - The number of given points.
*
* Return Value:
*
*   Status
*
\**************************************************************************/

GpStatus
CalculateGradientArray(
    GpPointF* grad,
    REAL* distances,
    const GpPointF* points,
    INT count
    )
{
    GpPointF* grad1 = grad;
    REAL* distances1 = distances;
    const GpPointF* points1 = points;

    // Go to the starting point of this subpath.

    GpPointF startPt, endPt, lastPt, nextPt;

    startPt = *points1;

    INT i = count - 1;
    BOOL different = FALSE;
    points1 += i;   // Go to the end point.

    while(i > 0 && !different)
    {
        endPt = *points1--;

        if(endPt.X != startPt.X || endPt.Y != startPt.Y)
            different = TRUE;

        i--;
    }

    if(!different)
    {
        // All points are the same.

        WARNING(("Trying to calculate the gradients for degenerate points."));
        return GenericError;
    }

    points1 = points;
    lastPt = endPt;

    i = 0;

    while(i <= count)
    {
        REAL dx, dy, d;

        if(i < count)
            nextPt = *points1++;
        else
            nextPt = startPt;
        
        dx = nextPt.X - lastPt.X;
        dy = nextPt.Y - lastPt.Y;
        d = dx*dx + dy*dy;

        if(d > 0)
        {
            d = REALSQRT(d);
            dx /= d;
            dy /= d;
        }
        grad1->X = dx;
        grad1->Y = dy;

        // Record the distance only when the given distance array is not NULL.

        if(distances)
            *distances1++ = d;

        grad1++;
        lastPt = nextPt;
        i++;
    }

    // Make sure the last gradient is not 0.

    grad1 = grad + count;
    if(grad1->X == 0 && grad1->Y == 0)
    {
        // The start and end point are the same.  Find
        // the next non-zero gradient.

        i = 1;
        grad1 = grad + i;

        while(i < count)
        {
            if(grad1->X != 0 || grad1->Y != 0)
            {
                grad[count] = *grad1;

                if(distances)
                    distances[count] = distances[i];
                break;
            }
            i++;
            grad1++;
        }
    }

    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   Calculates the normal gradient of points between startIndex
*   and endIndex.  The last element of the gradient is from endIndex
*   to startIndex.  If the next point is identical to the previous point,
*   the gradient is set to (0, 0).
*
* Arguments:
*
*   [IN] startIndex - the starting index.
*   [IN] endIndex - the ending index.
*
* Return Value:
*
*   Status
*
\**************************************************************************/

GpStatus
GpPathWidener::CalculateGradients(INT startIndex, INT endIndex)
{
    GpPointF* points0 = CenterPoints.GetDataBuffer();
    INT count = endIndex - startIndex + 1;

    if(!points0 || count <= 0)
        return GenericError;

    Gradients.Reset(FALSE);

    GpPointF* grad = Gradients.AddMultiple(count + 1);

    if(!grad)
        return OutOfMemory;

    GpPointF* points = points0 + startIndex;

    return CalculateGradientArray(grad, NULL, points, count);
}


GpStatus
GpPathWidener::CalculateNormals(
    REAL leftWidth,
    REAL rightWidth
    )
{
    NeedsToAdjustNormals = FALSE;

    INT count = Gradients.GetCount();
    GpPointF* grad0 = Gradients.GetDataBuffer();

    if(count <= 0)
    {
        WARNING(("Gradients must be calculated\n"
                 "before the normals are calculated."));
        return GenericError;
    }

    Normals.Reset(FALSE);
    GpPointF* norm0 = Normals.AddMultiple(count);

    if(!norm0)
        return OutOfMemory;


    GpPointF* norm = norm0;
    GpPointF* grad = grad0;

    // Calculate the left normals.

    INT i;

    for(i = 0; i < count; i++)
    {
        norm->X = grad->Y;
        norm->Y = - grad->X;
        norm++;
        grad++;
    }

    if(IsAntiAliased)
        return Ok;

    // Check if the minimum width is less than 1.0.

    REAL width = REALABS(leftWidth - rightWidth);

    if(width*MinimumWidth >= 1.0f)
        return Ok;

    NeedsToAdjustNormals = TRUE;
    
    if(!NeedsToTransform)
    {
        // Transform to the device space.
        // When NeedsToTransform is TRUE, the gradient is already
        // calculated in the device coordinates.

        if(!XForm.IsIdentity())
            XForm.VectorTransform(norm0, count);
    }

    // Set the minimum line width to be just over 1.0
    REAL criteria = 1.00005f;
    REAL value;
    
    if(width > 0)
        value = criteria/width;
    else
        value = criteria*MinimumWidth/1.0f;

    norm = norm0;

    for(i = 0; i < count; i++)
    {
        REAL xx = REALABS(norm->X);
        REAL yy = REALABS(norm->Y);

        if(xx >= yy)
        {
            if(width*xx < criteria)
            {
                if(norm->X >= 0)
                    norm->X = value;
                else
                    norm->X = - value;

                norm->Y = 0;
            }
        }
        else
        {
            if(width*yy < criteria)
            {
                if(norm->Y >= 0)
                    norm->Y = value;
                else
                    norm->Y = - value;

                norm->X = 0;
            }
        }

        norm++;
    }

    if(!NeedsToTransform)
    {
        // Transform back to the world space in case of
        // a non fixed width pen.

        if(!InvXForm.IsIdentity())
            InvXForm.VectorTransform(norm0, count);
    }

    return Ok;
}

GpStatus
GpPathWidener::Widen(GpPath **path)
{
    // Must be a pointer to a path pointer that is NULL.
    
    ASSERT(path != NULL);
    ASSERT(*path == NULL);
    
    GpStatus status = Ok;
    
    // Get the widened path points and types into the 
    // dynarray objects.
    
    DynPointFArray widenedPoints;
    DynByteArray widenedTypes;
    
    status = Widen(
        &widenedPoints,
        &widenedTypes
    );

    if(status != Ok) { return status; }
    
    // Remove the internal flag.

    INT pathCount = widenedTypes.GetCount();
    BYTE* pathTypes = widenedTypes.GetDataBuffer();
    for(INT i = 0; i < pathCount; i++, pathTypes++)
    {
        if(*pathTypes & PathPointTypeInternalUse)
        {
            *pathTypes &= ~PathPointTypeInternalUse;
        }
    }

    // If everything worked, create a new path
    // from the widened points.
    
    if(status == Ok)
    {
        *path = new GpPath(
            widenedPoints.GetDataBuffer(),
            widenedTypes.GetDataBuffer(),
            widenedPoints.GetCount(),
            FillModeWinding
        );
        
        if(*path == NULL) { status = OutOfMemory; }
    }        
    
    return status;
}

GpStatus
GpPathWidener::Widen(
    DynPointFArray* widenedPoints,
    DynByteArray* widenedTypes
    )
{
    FPUStateSaver::AssertMode();
    
    if(!IsValid() || !widenedPoints || !widenedTypes)
    {
        return InvalidParameter;
    }

    const GpPointF* centerPoints = CenterPoints.GetDataBuffer();
    const BYTE* centerTypes = CenterTypes.GetDataBuffer();
    INT centerCount = CenterPoints.GetCount();

    INT startIndex, endIndex;
    BOOL isClosed;
    GpStatus status = Ok;
    
    DynPointFArray customStartCapPoints;
    DynPointFArray customEndCapPoints;
    DynByteArray customStartCapTypes;
    DynByteArray customEndCapTypes;

    // Clear the data in widenedPoints and widenedTypes.

    widenedPoints->Reset(FALSE);
    widenedTypes->Reset(FALSE);

    REAL width = OriginalStrokeWidth;

    INT compoundCount = Pen->CompoundCount;

    REAL* compoundArray = NULL;
    INT cpCount;

    if(compoundCount > 0)
        cpCount = compoundCount;
    else
        cpCount = 2;

    REAL compoundArray0[8];

    if(cpCount <= 8)
        compoundArray = &compoundArray0[0];
    else
        compoundArray = (REAL*) GpMalloc(cpCount*sizeof(REAL));

    INT kk;

    if(compoundArray)
    {
        // Don't attempt to draw a compound line that is empty, or is aliased and has
        // more line components than the width of the line.  It can be rounded out of
        // existance
        if(compoundCount > 0 && 
           (IsAntiAliased || (compoundCount / 2) <= (width * UnitScale)))
        {
            // Don't attempt to draw a compound line that is less than 0.5 device
            // units in width.  These can disappear when rasterized, depending on
            // what Y coordinate they fall on.
            if ((UnitScale * width) >= 0.5f)
            {
                GpMemcpy(compoundArray, Pen->CompoundArray, compoundCount*sizeof(REAL));

                for(kk = 0; kk < compoundCount; kk++)
                {
                    compoundArray[kk] *= width;
                }
            }
            else
            {
                compoundArray[0] = 0;
                compoundArray[1] = 0.5f;
                if (cpCount > 2)
                {
                    cpCount = 2;
                }
            }
            
        }
        else
        {
            compoundArray[0] = 0;
            compoundArray[1] = StrokeWidth;
            if (cpCount > 2)
            {
                cpCount = 2;
            }
        }
    }
    else
    {
        SetValid(FALSE);
        return OutOfMemory;
    }


    REAL left0, right0;
    BOOL isCenteredPen = FALSE;
    BOOL needsToFlip = FALSE;

    if(Pen->PenAlignment == PenAlignmentInset)
    {
        // Check if the coordinates are flipped.
        // If the determinant of the transform matrix is negative,
        // the coordinate system is flipped.

        if(XForm.IsInvertible() && XForm.GetDeterminant() < 0)
            needsToFlip = TRUE;
    }

    // OriginalStrokeWidth is required for the compound lines, but we're
    // widening now and StrokeWidth == max(OriginalStrokeWidth, MinimumWidth)
    // which is the value we need to widen at in order to avoid dropping out
    // lines.
    
    width = StrokeWidth;
    
    switch(Pen->PenAlignment)
    {
    case PenAlignmentInset:
        if(!needsToFlip)
            left0 = 0;                    // Same as right align.
        else
            left0 = width;  // Same as left align.
        break;

    case PenAlignmentCenter:
    default:
        left0 = width/2;
        isCenteredPen = TRUE;
    }

    right0 = left0 - width;

    REAL startInset0 = 0, endInset0 = 0;
    GpCustomLineCap* customStartCap = NULL;
    GpCustomLineCap* customEndCap = NULL;

    while(Iterator.NextSubpath(&startIndex, &endIndex, &isClosed)
		&& status == Ok)
    {
        GpLineCap startCap = Pen->StartCap;
        GpLineCap endCap = Pen->EndCap;
        BYTE startType = centerTypes[startIndex];
        BYTE endType = centerTypes[endIndex];

        GpLineCapMode startCapMode = LineCapDefaultMode;
        GpLineCapMode endCapMode = LineCapDefaultMode;

        if(startType & PathPointTypeDashMode)
        {
            startCap = Pen->DashCap;
            startCapMode = LineCapDashMode;
        }
        else
        {
            // If the start cap is one of the anchor caps, default the widener
            // to using the dashcap for the startCap.
            
            if(((startCap & LineCapAnchorMask) != 0) ||
                 (startCap == LineCapCustom))
            {
                startCap = Pen->DashCap;
            }
        }
        
        if(endType & PathPointTypeDashMode)
        {
            endCap = Pen->DashCap;
            endCapMode = LineCapDashMode;
        }
        else
        {
            // If the end cap is one of the anchor caps, default the widener
            // to using the dashcap for the endCap.
            
            if(((endCap & LineCapAnchorMask) != 0) ||
                 (endCap == LineCapCustom))
            {
                endCap = Pen->DashCap;
            }
        }

        if(InsetPenMode)
        {
            // Inset pen only supports these caps.
            
            if(endCap != LineCapRound && endCap != LineCapFlat)
            {
                endCap = LineCapFlat;
            }
            if(startCap != LineCapRound && startCap != LineCapFlat)
            {
                startCap = LineCapFlat;
            }
        }

        Inset1 = Inset2 = 0.0f;
        if(startCap == LineCapSquare)
        {
            Inset1 = -0.5f*StrokeWidth;
        }
        if(endCap == LineCapSquare)
        {
            Inset2 = -0.5f*StrokeWidth;
        }

        status = CalculateGradients(startIndex, endIndex);

        kk = 0;

        BOOL isCompoundLine = FALSE;
        GpLineCap startCap1 = startCap;
        GpLineCap endCap1 = endCap;
        
        if(cpCount > 2)
        {
            // Don't add the caps for the individual
            // compound line.

            isCompoundLine = TRUE;
            startCap1 = LineCapFlat;
            endCap1 = LineCapFlat;
        }

        while(kk < cpCount && status == Ok)
        {
            REAL leftWidth = left0 - compoundArray[kk];
            REAL rightWidth = left0 - compoundArray[kk + 1];

            if(REALABS(leftWidth-rightWidth)>REAL_EPSILON)
            {
                status = CalculateNormals(leftWidth, rightWidth);
                if(status != Ok) { break; }
                
                // Check if we can use the Bevel join for inside lines.
    
                BOOL useBevelJoinInside = isCenteredPen && !isCompoundLine;
        
                if(USE_POLYGON_JOIN)
                {
                    status = SetPolygonJoin(leftWidth, rightWidth, FALSE);
                }
    
                status = WidenSubpath(
                    widenedPoints,
                    widenedTypes,
                    leftWidth,
                    rightWidth,
                    startIndex,
                    endIndex,
                    isClosed,
                    startCap1,
                    endCap1,
                    useBevelJoinInside
                );
                
                Iterator.RewindSubpath();
            }

            kk += 2;
        }
        // Add the compound line caps if necessary.

        if(status == Ok && isCompoundLine && !isClosed)
        {
            status = AddCompoundCaps(
                widenedPoints,
                widenedTypes,
                left0,
                right0,
                startIndex,
                endIndex,
                startCap,
                endCap
            );
        }

    }

    if(status != Ok) { return status; }

    GpPointF* pts;
    INT count;

    if(!NeedsToTransform)
    {
        GpMatrix penTrans = ((DpPen*) Pen)->Xform;
        BOOL hasPenTransform = FALSE;

        if(!penTrans.IsTranslate())
        {
            hasPenTransform = TRUE;
            penTrans.RemoveTranslation();

            pts = widenedPoints->GetDataBuffer();
            count = widenedPoints->GetCount();
            penTrans.Transform(pts, count);
        }
    }
    else if(!InvXForm.IsIdentity())
    {
        // Case of the Fixed width pen.

        pts = widenedPoints->GetDataBuffer();
        count = widenedPoints->GetCount();
        InvXForm.Transform(pts, count);
    }

#ifdef DEBUG_PATHWIDENER

    if(status == Ok)
    {
        DpPathTypeIterator iter2(widenedTypes->GetDataBuffer(),
            widenedTypes->GetCount());

        if(!iter2.IsValid())
        {
            WARNING(("Widening result is not valid."));
            status = GenericError;
        }
    }
    
#endif

    if(status == Ok)
        SetValid(TRUE);

    if(compoundArray != &compoundArray0[0])
        GpFree(compoundArray);

    return status;
}


GpStatus
GpPathWidener::WidenSubpath(
    DynPointFArray* widenedPoints,
    DynByteArray* widenedTypes,
    REAL leftWidth,
    REAL rightWidth,
    INT startIndex,
    INT endIndex,
    BOOL isClosed,
    GpLineCap startCap,
    GpLineCap endCap,
    BOOL useBevelJoinInside
    )
{
    const GpPointF* centerPoints = CenterPoints.GetDataBuffer();
    const BYTE* centerTypes = CenterTypes.GetDataBuffer();
    INT centerCount = CenterPoints.GetCount();

    GpLineJoin lineJoin = Pen->Join;
    REAL miterLimit2 = Pen->MiterLimit;
    miterLimit2 *= miterLimit2;

    INT typeStartIndex, typeEndIndex;
    BYTE pathType;
    BOOL isFirstType = TRUE;
    BOOL isLastType = FALSE;
    BOOL isLastPointSame;
    GpPointF startPt, endPt;

    startPt = centerPoints[startIndex];
    endPt = centerPoints[endIndex];

    if(startPt.X != endPt.X || startPt.Y != endPt.Y)
        isLastPointSame = FALSE;
    else
        isLastPointSame = TRUE;

    // Reset the left and right buffers.

    LeftTypes.Reset(FALSE);
    LeftPoints.Reset(FALSE);
    RightTypes.Reset(FALSE);
    RightPoints.Reset(FALSE);

    INT subpathCount = endIndex - startIndex + 1;
    INT joinMultiplier = 2;

    if(lineJoin == LineJoinRound)
        joinMultiplier = 7;

    GpStatus status = LeftTypes.ReserveSpace(joinMultiplier*subpathCount);
    if(status == Ok)
        status = LeftPoints.ReserveSpace(joinMultiplier*subpathCount);
    if(status == Ok)
        status = RightTypes.ReserveSpace(joinMultiplier*subpathCount);
    if(status == Ok)
        status = RightPoints.ReserveSpace(joinMultiplier*subpathCount);

    if(status != Ok)
        return status;

    // Get Gradient data buffer.

    GpPointF *grad0, *norm0;
    
    grad0 = Gradients.GetDataBuffer();
    norm0 = Normals.GetDataBuffer();

    // Get Left and Right data buffers.

    GpPointF*   leftPoints0 = LeftPoints.GetDataBuffer();
    BYTE*       leftTypes0 = LeftTypes.GetDataBuffer();
    GpPointF*   rightPoints0 = RightPoints.GetDataBuffer();
    BYTE*       rightTypes0 = RightTypes.GetDataBuffer();

    GpPointF lastPt, nextPt;
    GpPointF leftEndPt, rightEndPt;

    INT leftCount = 0, rightCount = 0;

    INT flag = 0;

    if(isClosed)
        flag |= WideningClosed;
    if(isFirstType)
        flag |= WideningFirstType;
    if(isLastType)
        flag |= WideningLastType;
    if(isLastPointSame)
        flag |= WideningLastPointSame;
    if(NeedsToAdjustNormals)
        flag |= WideningNeedsToAdjustNormals;
    if(useBevelJoinInside)
        flag |= WideningUseBevelJoinInside;

    const GpPointF* dataPoints = centerPoints + startIndex;
    INT dataCount = endIndex - startIndex + 1;

    REAL firstInsets[2], lastInsets[2];

    // Never inset more than the length of the line for the first inset, and
    // never more than the amount left on the line after the first inset
    // has been applied.  This can result in odd endcaps and dashcaps when you 
    // have a line that ends in the middle of a short dash segment.
    
    REAL linelength = REALSQRT(
        distance_squared(
            centerPoints[startIndex],
            centerPoints[endIndex]
         )
     );
    
    firstInsets[0] = min(Inset1, linelength);
    firstInsets[1] = min(Inset1, linelength);
    lastInsets[0] = min(Inset2, linelength-firstInsets[0]);
    lastInsets[1] = min(Inset2, linelength-firstInsets[1]);

    WidenFirstPoint(
        leftWidth,
        rightWidth,
        lineJoin,
        miterLimit2,
        leftPoints0,
        leftTypes0,
        &leftCount,
        rightPoints0,
        rightTypes0,
        &rightCount,
        &leftEndPt,
        &rightEndPt,
        grad0,
        norm0,
        dataPoints,
        dataCount,
        &lastPt,
        &firstInsets[0],
        flag
    );

    // Iterate through all subtypes in the current subpath.

    while(Iterator.NextPathType(&pathType, &typeStartIndex, &typeEndIndex)
            && status == Ok)
    {
        // Offset index from the current subpath.

        INT offsetIndex = typeStartIndex - startIndex;
        GpPointF*   grad = grad0 + offsetIndex;
        GpPointF*   norm = norm0 + offsetIndex;
        
        // Get the starting data buffers of the current subtypes.

        dataPoints = centerPoints + typeStartIndex;
        dataCount = typeEndIndex - typeStartIndex + 1;

        // Get the starting buffers for the left and right data.

        GpPointF*   leftPoints = leftPoints0 + leftCount;
        BYTE*       leftTypes = leftTypes0 + leftCount;
        GpPointF*   rightPoints = rightPoints0 + rightCount;
        BYTE*       rightTypes = rightTypes0 + rightCount;

        INT addedLeftCount = 0, addedRightCount = 0;

        if(pathType != PathPointTypeStart)
        {
            if(typeEndIndex == endIndex)
                isLastType = TRUE;

            flag = 0;

            if(isClosed)
                flag |= WideningClosed;
            if(isFirstType)
                flag |= WideningFirstType;
            if(isLastType)
                flag |= WideningLastType;
            if(isLastPointSame)
                flag |= WideningLastPointSame;
            if(NeedsToAdjustNormals)
                flag |= WideningNeedsToAdjustNormals;
            if(useBevelJoinInside)
                flag |= WideningUseBevelJoinInside;

            status = WidenEachPathType(
                pathType,
                leftWidth,
                rightWidth,
                lineJoin,
                miterLimit2,
                leftPoints,
                leftTypes,
                &addedLeftCount,
                rightPoints,
                rightTypes,
                &addedRightCount,
                grad,
                norm,
                dataPoints,
                dataCount,
                &lastPt,
                &lastInsets[0],
                flag
            );

            leftCount += addedLeftCount;
            rightCount += addedRightCount;
            if(isFirstType && (leftCount > 0 || rightCount > 0))
                isFirstType = FALSE;
        }
        lastPt = centerPoints[typeEndIndex];

    }

    if(status == Ok)
    {
        LeftTypes.SetCount(leftCount);
        LeftPoints.SetCount(leftCount);
        RightTypes.SetCount(rightCount);
        RightPoints.SetCount(rightCount);
    }
    else
        return status;

    GpPointF startPoint, endPoint;
    GpPointF startGrad, endGrad;
    GpPointF startNorm, endNorm;

    startPoint = *(centerPoints + startIndex);
    endPoint = *(centerPoints + endIndex);
    startGrad = grad0[1];
    endGrad = grad0[endIndex - startIndex];
    startNorm = norm0[1];
    endNorm = norm0[endIndex - startIndex];

    status = SetCaps(
        startCap,
        endCap,
        startPoint,
        startGrad,
        startNorm,
        endPoint,
        endGrad,
        endNorm,
        leftWidth,
        rightWidth,
        centerPoints + startIndex,
        endIndex - startIndex + 1
    );

    status = CombineSubpathOutlines(
        widenedPoints,
        widenedTypes,
        isClosed
    );

    return status;
}



GpStatus
GpPathWidener::SetPolygonJoin(
    REAL leftWidth,
    REAL rightWidth,
    BOOL isAntialiased
    )
{
    // This codes is intended to non-pen transform and in WorldUnit for now.

    REAL minimumWidth = MinimumWidth;
    if(leftWidth - rightWidth < StrokeWidth)
        minimumWidth = (leftWidth - rightWidth)/StrokeWidth;

    const INT maxPolyCount = 8;
    INT count = 0;
    GpPointF points[maxPolyCount];
    REAL grads[maxPolyCount];

    JoinPolygonPoints.Reset(FALSE);
    JoinPolygonAngles.Reset(FALSE);
  
    // Define Hobby's polygon.

    if(minimumWidth < 1.06)
    {
        count = 4;
        points[0].X =  0.0f;    points[0].Y = -0.5f;
        points[1].X =  0.5f;    points[1].Y =  0.0f;
        points[2].X =  0.0f;    points[2].Y =  0.5f;
        points[3].X = -0.5f;    points[3].Y =  0.0f;
    }
    else if(minimumWidth < 1.5)
    {
        count = 4;
        points[0].X = -0.5f;    points[0].Y = -0.5f;
        points[1].X =  0.5f;    points[1].Y = -0.5f;
        points[2].X =  0.5f;    points[2].Y =  0.5f;
        points[3].X = -0.5f;    points[3].Y =  0.5f;
    }
    else if(minimumWidth < 1.77)
    {
        count = 4;
        points[0].X =  0.0f;    points[0].Y = -1.0f;
        points[1].X =  1.0f;    points[1].Y =  0.0f;
        points[2].X =  0.0f;    points[2].Y =  1.0f;
        points[3].X = -1.0f;    points[3].Y =  0.0f;
    }
    else if(minimumWidth < 2.02)
    {
        count = 6;
        points[0].X = -0.5f;    points[0].Y = -1.0f;
        points[1].X =  0.5f;    points[1].Y = -1.0f;
        points[2].X =  1.0f;    points[2].Y =  0.0f;
        points[3].X =  0.5f;    points[3].Y =  1.0f;
        points[4].X = -0.5f;    points[4].Y =  1.0f;
        points[5].X = -1.0f;    points[5].Y =  0.0f;
    }
    else if(minimumWidth < 2.48)
    {
        count = 8;
        points[0].X = -0.5f;    points[0].Y = -1.0f;
        points[1].X =  0.5f;    points[1].Y = -1.0f;
        points[2].X =  1.0f;    points[2].Y = -0.5f;
        points[3].X =  1.0f;    points[3].Y =  0.5f;
        points[4].X =  0.5f;    points[4].Y =  1.0f;
        points[5].X = -0.5f;    points[5].Y =  1.0f;
        points[6].X = -1.0f;    points[6].Y =  0.5f;
        points[7].X = -1.0f;    points[7].Y = -0.5f;
    }
    else if(minimumWidth < 2.5)
    {
        count = 4;
        points[0].X = -1.0f;    points[0].Y = -1.0f;
        points[1].X =  1.0f;    points[1].Y = -1.0f;
        points[2].X =  1.0f;    points[2].Y =  1.0f;
        points[3].X = -1.0f;    points[3].Y =  1.0f;
    }
    else if(minimumWidth < 2.91)
    {
        count = 8;
        points[0].X =  0.0f;    points[0].Y = -1.5f;
        points[1].X =  1.0f;    points[1].Y = -1.0f;
        points[2].X =  1.5f;    points[2].Y =  0.0f;
        points[3].X =  1.0f;    points[3].Y =  1.0f;
        points[4].X =  0.0f;    points[4].Y =  1.5f;
        points[5].X = -1.0f;    points[5].Y =  1.0f;
        points[6].X = -1.5f;    points[6].Y =  0.0f;
        points[7].X = -1.0f;    points[7].Y = -1.0f;
    }
    else
        count = 0;

    if(count > 0)
    {
        GpPointF dP;

        for(INT i = 0; i < count - 1; i++)
        {
            dP = points[i + 1] - points[i];
            GetFastAngle(&grads[i], dP);
        }

        dP = points[0] - points[count - 1];
        GetFastAngle(&grads[count - 1], dP);



        REAL lastAngle = grads[0];
        REAL nextAngle;

/*
        // Find out the smallest gradient.

        INT i0 = 0;        
        for(i = 1; i < count; i++)
        {
            nextAngle = grads[i];
            if(nextAngle < lastAngle)
                i0 = i;
            lastAngle = nextAngle;
        }

        // Rearrange so that the polygon starts with the smallest
        // gradient.

        if(i0 > 1)
        {
            GpPointF tempPointsBuff[maxPolyCount];
            REAL tempGradsBuff[maxPolyCount];

            GpMemcpy(&tempPointsBuff[0], &points[0], i0*sizeof(GpPointF));
            GpMemcpy(&tempGradsBuff[0], &grads[0], i0);
            GpMemcpy(&points[0],
                &points[i0], (count - i0)*sizeof(GpPointF));
            GpMemcpy(&grads[0], &grads[i0], count - i0);
            GpMemcpy(&points[count - i0], &tempPointsBuff[0],
                i0*sizeof(GpPointF));
            GpMemcpy(&grads[count - i0], &tempGradsBuff[0], i0);
        }
*/

        BOOL monotonic = TRUE;
        i = 1;
        lastAngle = grads[0];

        while(monotonic && i < count)
        {
            nextAngle = grads[i];
            if(nextAngle < lastAngle)
                monotonic = FALSE;
            i++;
            lastAngle = nextAngle;
        }

        ASSERTMSG(monotonic, ("Polygon for join is not concave."));
    }

    if(count > 0)
    {
        JoinPolygonPoints.AddMultiple(&points[0], count);
        JoinPolygonAngles.AddMultiple(&grads[0], count);
    }

    return Ok;
}

INT getVertexID(const GpPointF& vector, BOOL forLeftEdge, INT count, const REAL* grads)
{
    INT left, right, middle;
    REAL angle = 0.0f;

    GetFastAngle(&angle, vector);

    if(!forLeftEdge)
    {
        angle += 4;
        if(angle >= 8)
            angle -= 8;
    }

    if(angle <= grads[0])
        return 0;

    if(angle >= grads[count - 1])
        return count - 1;

    INT i = 1;

    while(angle >= grads[i] && i < count)
    {
        i++;
    }

    return i - 1;
}
    
GpStatus
GpPathWidener::AddCompoundCaps(
    DynPointFArray* widenedPoints,
    DynByteArray* widenedTypes,
    REAL leftWidth,
    REAL rightWidth,
    INT startIndex,
    INT endIndex,
    GpLineCap startCap,
    GpLineCap endCap
    )
{
    const GpPointF* centerPoints = CenterPoints.GetDataBuffer();
    const BYTE* centerTypes = CenterTypes.GetDataBuffer();
    INT centerCount = CenterPoints.GetCount();
    const GpPointF* grad0 = Gradients.GetDataBuffer();
    const GpPointF* norm0 = Normals.GetDataBuffer();

    GpPointF startPoint, endPoint;
    GpPointF startGrad, endGrad;
    GpPointF startNorm, endNorm;

    startPoint = *(centerPoints + startIndex);
    endPoint = *(centerPoints + endIndex);
    startGrad = grad0[1];
    endGrad = grad0[endIndex - startIndex];
    startNorm = norm0[1];
    endNorm = norm0[endIndex - startIndex];
    
    GpStatus status;
    status = SetCaps(
        startCap, 
        endCap,
        startPoint, 
        startGrad, 
        startNorm,
        endPoint,
        endGrad, 
        endNorm,
        leftWidth, 
        rightWidth,
        centerPoints + startIndex,
        endIndex - startIndex + 1
    );

    status = CombineClosedCaps(
        widenedPoints, 
        widenedTypes,
        &CapPoints1,
        &CapPoints2,
        &CapTypes1,
        &CapTypes2
    );

    return status;
}
    
GpStatus
GpPathWidener::SetCaps(
    GpLineCap startCap,
    GpLineCap endCap,
    const GpPointF& startPoint,
    const GpPointF& startGrad,
    const GpPointF& startNorm,
    const GpPointF& endPoint,
    const GpPointF& endGrad,
    const GpPointF& endNorm,
    REAL leftWidth,
    REAL rightWidth,
    const GpPointF *points,
    INT pointCount
    )
{
    GpStatus status = Ok;

    CapPoints1.Reset(FALSE);
    CapTypes1.Reset(FALSE);
    CapPoints2.Reset(FALSE);
    CapTypes2.Reset(FALSE);

    switch(startCap)
    {
    case LineCapRound:
        if(InsetPenMode)
        {
            status = SetDoubleRoundCap(
                startPoint, 
                startGrad, 
                TRUE, 
                leftWidth, 
                rightWidth
            );
        }
        else
        {
            status = SetRoundCap(
                startPoint, 
                startGrad, 
                TRUE, 
                leftWidth, 
                rightWidth
            );
        }
        break;

    case LineCapTriangle:
        ASSERT(!InsetPenMode);
        status = SetTriangleCap(startPoint, startGrad, TRUE, leftWidth, rightWidth, points, pointCount);
        break;
    
    default:
        // Flat cap.
        
        break;
    }

    switch(endCap)
    {
    case LineCapRound:
        if(InsetPenMode)
        {
            status = SetDoubleRoundCap(
                endPoint, 
                endGrad, 
                FALSE, 
                leftWidth, 
                rightWidth
            );
        }
        else
        {
            status = SetRoundCap(
                endPoint, 
                endGrad, 
                FALSE, 
                leftWidth, 
                rightWidth
            );
        }
        break;

    case LineCapTriangle:
        ASSERT(!InsetPenMode);
        status = SetTriangleCap(endPoint, endGrad, FALSE, leftWidth, rightWidth, points, pointCount);
        break;
    
    default:
        // Flat cap.
        
        break;
    }

    return status;
}

VOID modifyEdges(
    GpPointF* leftPoints,
    BYTE* leftTypes,
    INT* leftCount,
    INT* leftOffset,
    GpPointF* rightPoints,
    BYTE* rightTypes,
    INT* rightCount,
    INT* rightOffset,
    GpPointF* grad,
    INT gradCount
    )
{
    INT leftOffset1 = 0;
    INT rightOffset1 = 0;
    INT leftCount0 = *leftCount;
    INT rightCount0 = *rightCount;
    INT leftCount1 = leftCount0;
    INT rightCount1 = rightCount0;

    if(gradCount > 2)
    {
        GpPointF firstGrad = grad[1];
        GpPointF lastGrad = grad[gradCount - 2];

        GpPointF dP;
        if(leftCount0 > 2)
        {
            dP.X = leftPoints[1].X - leftPoints[0].X;
            dP.Y = leftPoints[1].Y - leftPoints[0].Y;
            if(dP.X*firstGrad.X + dP.Y*firstGrad.Y < 0)
            {
                leftPoints[0] = leftPoints[1];
            }
            dP.X = leftPoints[leftCount0 - 1].X
                - leftPoints[leftCount0 - 2].X;
            dP.Y = leftPoints[leftCount0 - 1].Y
                - leftPoints[leftCount0 - 2].Y;
            if(dP.X*lastGrad.X + dP.Y*lastGrad.Y < 0)
            {
                leftPoints[leftCount0 - 1]
                    = leftPoints[leftCount0 - 2];
            }
        }

        if(rightCount0 > 2)
        {
            dP.X = rightPoints[1].X - rightPoints[0].X;
            dP.Y = rightPoints[1].Y - rightPoints[0].Y;
            if(dP.X*firstGrad.X + dP.Y*firstGrad.Y < 0)
            {
                rightPoints[0] = rightPoints[1];
            }
            dP.X = rightPoints[rightCount0 - 1].X
                - rightPoints[rightCount0 - 2].X;
            dP.Y = rightPoints[rightCount0 - 1].Y
                - rightPoints[rightCount0 - 2].Y;
            if(dP.X*lastGrad.X + dP.Y*lastGrad.Y < 0)
            {
                rightPoints[rightCount0 - 1]
                    = rightPoints[rightCount0 - 2];
            }
        }
    }

    *leftCount = leftCount1;
    *leftOffset = leftOffset1;
    *rightCount = rightCount1;
    *rightOffset = rightOffset1;
}


/**************************************************************************\
*
* Function Description:
*
*   Combines left path, right path, start cap, and end cap.
*
* Arguments:
*
*   [OUT] windedPoints - Output point data.
*   [OUT] widnedTypes - Output type data.
*   [IN] isClosed - TRUE is the current suppat is closed.
*   [IN] closeStartCap - TRUE if the start cap needs to be closed.
*   [IN] closeEndCap - TRUE if the end cap needs to be closed.
*
* Return Value:
*
*   Status
*
\**************************************************************************/

GpStatus
GpPathWidener::CombineSubpathOutlines(
    DynPointFArray* widenedPoints,
    DynByteArray* widenedTypes,
    BOOL isClosed,
    BOOL closeStartCap,
    BOOL closeEndCap
    )
{
    GpStatus status = Ok;

    INT startCapCount = CapPoints1.GetCount();
    GpPointF* startCapPoints = CapPoints1.GetDataBuffer();
    BYTE* startCapTypes = CapTypes1.GetDataBuffer();
    INT endCapCount = CapPoints2.GetCount();
    GpPointF* endCapPoints = CapPoints2.GetDataBuffer();
    BYTE* endCapTypes = CapTypes2.GetDataBuffer();
        
    BYTE* leftTypes;
    GpPointF* leftPoints;
    BYTE* rightTypes;
    GpPointF* rightPoints;
    INT leftCount, rightCount;

    leftCount = LeftPoints.GetCount();
    leftTypes = LeftTypes.GetDataBuffer();
    leftPoints = LeftPoints.GetDataBuffer();
    rightCount = RightPoints.GetCount();
    rightTypes = RightTypes.GetDataBuffer();
    rightPoints = RightPoints.GetDataBuffer();

    if(!isClosed)
    {        
        GpPointF *grad = Gradients.GetDataBuffer();
        INT gradCount = Gradients.GetCount();
        INT leftOffset, rightOffset;

        modifyEdges(leftPoints, leftTypes, &leftCount, &leftOffset,
                rightPoints, rightTypes, &rightCount, &rightOffset,
                grad, gradCount);

        leftPoints += leftOffset;
        leftTypes += leftOffset;
        rightPoints += rightOffset;
        rightTypes += rightOffset;
    }

    status = widenedPoints->ReserveSpace(
                leftCount + rightCount + startCapCount + endCapCount + 2);
    if(status == Ok)
        status = widenedTypes->ReserveSpace(
                leftCount + rightCount + startCapCount + endCapCount + 2);

    GpPointF* wPts = NULL;
    BYTE* wTypes = NULL;

    if(status == Ok)
    {
        wPts = widenedPoints->GetDataBuffer();
        wTypes = widenedTypes->GetDataBuffer();
    }

    if(wPts && wTypes)
    {
        // Set the pointers to the current location.

        INT count0 = widenedPoints->GetCount();
        wPts += count0;
        wTypes += count0;

        INT resultCount;
        BOOL isStartCapClosed = FALSE;
        BOOL isEndCapClosed = FALSE;

        if(isClosed)
        {
            leftTypes[leftCount - 1] |= PathPointTypeCloseSubpath;
            rightTypes[rightCount - 1] |= PathPointTypeCloseSubpath;
        }
        else
        {
            if(startCapCount > 0)
            {
                if(!closeStartCap)
                {
                    if(startCapTypes[startCapCount - 1] & PathPointTypeCloseSubpath)
                        isStartCapClosed = TRUE;
                }
                else
                {
                    // Force the start cap to be closed.

                    startCapTypes[startCapCount - 1] |= PathPointTypeCloseSubpath;
                    isStartCapClosed = TRUE;
                }
            }

            if(endCapCount > 0)
            {
                if(!closeEndCap)
                {
                    if(endCapTypes[endCapCount - 1] & PathPointTypeCloseSubpath)
                        isEndCapClosed = TRUE;
                }
                else
                {
                    // Force the end cap to be closed.

                    endCapTypes[endCapCount - 1] |= PathPointTypeCloseSubpath;
                    isEndCapClosed = TRUE;
                }
            }
        }

        if(isClosed || (startCapCount == 0 && endCapCount == 0))
        {
            BOOL connect = TRUE;
            resultCount =
                ::CombinePaths(leftCount + rightCount, wPts, wTypes,
                leftCount, leftPoints, leftTypes, TRUE,
                rightCount, rightPoints, rightTypes, FALSE,
                connect);
        }
        else
        {
            resultCount = leftCount;

            if(leftCount > 0)
            {
                GpMemcpy(wPts, leftPoints, leftCount*sizeof(GpPointF));
                GpMemcpy(wTypes, leftTypes, leftCount);
            }
            
            if(endCapCount > 0 && !isEndCapClosed)
            {
                resultCount =
                    combineTwoOpenSegments(
                        resultCount, wPts, wTypes, TRUE,
                        endCapCount, endCapPoints, endCapTypes, TRUE);
            }

            if(rightCount > 0)
            {
                resultCount =
                    combineTwoOpenSegments(
                        resultCount, wPts, wTypes, TRUE,
                        rightCount, rightPoints, rightTypes, FALSE);
            }

            if(startCapCount > 0 && !isStartCapClosed)
            {
                resultCount =
                    combineTwoOpenSegments(
                        resultCount, wPts, wTypes, TRUE,
                        startCapCount, startCapPoints, startCapTypes, TRUE);
            }

            wTypes[0] = PathPointTypeStart;
        }

        if(resultCount > 0)
        {
            // If the original subpath is open, the combined path needs to be
            // closed.  If the original path is closed, the left and
            // right paths are already closed.

            if(!isClosed)
            {
                wTypes[resultCount - 1] |= PathPointTypeCloseSubpath;

                // Add the closed caps.

                if(endCapCount > 0 && isEndCapClosed)
                {
                    resultCount =
                        combineClosedSegments(
                            resultCount, wPts, wTypes, TRUE,
                            endCapCount, endCapPoints, endCapTypes, TRUE);
                }

                if(startCapCount > 0 && isStartCapClosed)
                {
                    resultCount =
                        combineClosedSegments(
                            resultCount, wPts, wTypes, TRUE,
                            startCapCount, startCapPoints, startCapTypes, TRUE);
                }
            }

            widenedPoints->AdjustCount(resultCount);
            widenedTypes->AdjustCount(resultCount);
        }
        else
            status = GenericError;
    }
    else
        status = OutOfMemory;

    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   Combines the closed cap paths.
*
* Arguments:
*
*   [OUT] windedPoints - Output point data.
*   [OUT] widnedTypes - Output type data.
*
* Return Value:
*
*   Status
*
\**************************************************************************/

GpStatus
GpPathWidener::CombineClosedCaps(
    DynPointFArray* widenedPoints,
    DynByteArray* widenedTypes,
    DynPointFArray *daStartCapPoints,
    DynPointFArray *daEndCapPoints,
    DynByteArray *daStartCapTypes,
    DynByteArray *daEndCapTypes
    )
{
    GpStatus status = Ok;

    INT startCapCount = daStartCapPoints->GetCount();
    GpPointF* startCapPoints = daStartCapPoints->GetDataBuffer();
    BYTE* startCapTypes = daStartCapTypes->GetDataBuffer();
    INT endCapCount = daEndCapPoints->GetCount();
    GpPointF* endCapPoints = daEndCapPoints->GetDataBuffer();
    BYTE* endCapTypes = daEndCapTypes->GetDataBuffer();

    if(startCapCount == 0 && endCapCount == 0)
    {
        return status;
    }

    status = widenedPoints->ReserveSpace(startCapCount + endCapCount);
    if(status == Ok)
        status = widenedTypes->ReserveSpace(startCapCount + endCapCount);

    GpPointF* wPts = NULL;
    BYTE* wTypes = NULL;

    if(status == Ok)
    {
        wPts = widenedPoints->GetDataBuffer();
        wTypes = widenedTypes->GetDataBuffer();
    }
    else
        status = OutOfMemory;

    if(status == Ok && wPts && wTypes)
    {
        INT count0 = widenedPoints->GetCount();

        // Make sure the previous path is closed.

        if(count0 > 0)
            wTypes[count0 - 1] |= PathPointTypeCloseSubpath;

        // Set the pointers to the current location.

        wPts += count0;
        wTypes += count0;

        INT resultCount = 0;

        if(startCapCount > 0)
        {
           // Force the start cap to be closed.

            startCapTypes[startCapCount - 1] |= PathPointTypeCloseSubpath;
            resultCount =
                combineClosedSegments(
                    resultCount, wPts, wTypes, TRUE,
                    startCapCount, startCapPoints, startCapTypes, TRUE);
        }

        if(endCapCount > 0)
        {
            // Force the end cap to be closed.

            endCapTypes[endCapCount - 1] |= PathPointTypeCloseSubpath;
            resultCount =
                combineClosedSegments(
                    resultCount, wPts, wTypes, TRUE,
                    endCapCount, endCapPoints, endCapTypes, TRUE);
        }

        widenedPoints->AdjustCount(resultCount);
        widenedTypes->AdjustCount(resultCount);
    }

    return status;
}

GpTurningDirection
getTurningDirection(
    REAL* crossProduct,
    const GpPointF& grad1,
    const GpPointF& grad2
    )
{
    ASSERT(crossProduct);

    GpTurningDirection direction = NotTurning;
    *crossProduct = 0;

    // Handle the degenerate cases.

    GpPointF v;

    if(( (REALABS(grad1.X) < REAL_EPSILON) && 
         (REALABS(grad1.Y) < REAL_EPSILON)     ) || 
       ( (REALABS(grad2.X) < REAL_EPSILON) && 
         (REALABS(grad2.Y) < REAL_EPSILON)     )
      )
    {
        return NotTurning;
    }
    
    // Handle the case of straight or nearly straight lines.
    // The following constant is completely bogus - we need a number here
    // and we're fairly certain it must be small. Probably a better estimate
    // would be some fraction of a device pixel over the length of the line - 
    // if we can figure out how big that is.

    const REAL gradErr = 0.00001f;
    
    if(distance_squared(grad1, grad2) < gradErr)
    {
        direction = NotTurning;

        return direction;
    }

    // Calculate the cross product.

    REAL cross = grad1.X*grad2.Y - grad1.Y*grad2.X;

    // When it comes here, the lines are turning.
    // Get the turning direction.

    if (REALABS(cross) <= REAL_EPSILON)
    {
        direction = TurningBack;
        cross = 0;
    }
    else
    {
        if(cross > 0)
        {
            direction = TurningRight;
        }
        else // if(cross < 0)
        {
            direction = TurningLeft;
        }
    }

    *crossProduct = cross;
    
    return direction;
}

/**************************************************************************\
*
* Function Description:
*
*   Calculates if the miter join will exceed the miter limit.
*
* Arguments:
*
*   [IN] grad1 - the unit tangent vector of the last edge.
*   [IN] grad2 - the unit tangent vector of the current edge.
*   [IN] miterLimit2 - the square of the Miter limit.
*
* Return Value:
*
*   TRUE if the miter limit of this join is exceeded
*
\**************************************************************************/

BOOL
getMiterExceeded(
    const GpPointF& grad1,
    const GpPointF& grad2,
    REAL miterLimit2
    )
{
    REAL cross = grad1.X*grad2.Y - grad1.Y*grad2.X;

    // If cross product is zero, the lines are colinear and can be
    // turning back on themselves.
    if (REALABS(cross) <= REAL_EPSILON)
    {
        return TRUE;
    }

    // Get the normal direction for the miter join.
    GpPointF v(0, 0);
    v.X = grad1.X - grad2.X;
    v.Y = grad1.Y - grad2.Y;

    // Test the miter limit.  
    REAL test = v.X*v.X + v.Y*v.Y - cross*cross*miterLimit2;

    return test > 0;
}

/**************************************************************************\
*
* Function Description:
*
*   Calculates the vector for Miter or Bevel join.  This vector represents
*   the shift to the left along the moving direction.
*   In case of Miter join, when the Miter join exceeds the miter limit,
*   this returns the Bevel join.
*
* Arguments:
*
*   [OUT] vector - the left shift for the Miter join.  This must be
*                   allocated at least for the dimension of 2.
*   [OUT] count - the number of join points.
*   [IN] miterLimit2 - the square of the Miter limit.
*   [IN] grad1 - the unit tangent vector of the last edge.
*   [IN] grad2 - the unit tangent vector of the current edge.
*
* Return Value:
*
*   Turning direction from the last edge to the current edge.
*
\**************************************************************************/

GpTurningDirection
getMiterBevelJoin(
    const GpPointF& point,
    const GpPointF& grad1,
    const GpPointF& grad2,
    const GpPointF& norm1,
    const GpPointF& norm2,
    REAL leftWidth,
    REAL rightWidth,
    INT *leftCount,
    GpPointF *leftPoints,
    BOOL* leftInside,
    INT *rightCount,
    GpPointF *rightPoints,
    BOOL* rightInside,
    BOOL needsToAdjustNormals,
    REAL miterLimit2,
    BOOL isMiter,
    BOOL useBevelJoinInside
    )
{
    *leftInside = FALSE;
    *rightInside = FALSE;

    if(miterLimit2 <= 1)
        isMiter = FALSE;

    GpTurningDirection direction = NotTurning;

    // Handle the degenerate cases.

    GpPointF v(0, 0);
    REAL cross;

    direction = getTurningDirection(&cross, grad1, grad2);

    if(direction == NotMoving)
    {
        *leftCount = 0;
        *rightCount = 0;
        return direction;
    }
    else if(direction == NotTurning)
    {
        if(norm1.X != 0 || norm1.Y != 0)
            v = norm1;
        else
            v = norm2;

        leftPoints[0].X = point.X + leftWidth*v.X;
        leftPoints[0].Y = point.Y + leftWidth*v.Y;
        *leftCount = 1;

        rightPoints[0].X = point.X + rightWidth*v.X;
        rightPoints[0].Y = point.Y + rightWidth*v.Y;
        *rightCount = 1;

        return direction;
    }

    if(cross > 0)
    {
        // Right Turn

        // If the width is positive, this point is outside.
        // For the zero width, we regard this as non-inside point.

        if(leftWidth >= 0)
            *leftInside = FALSE;
        else
            *leftInside = TRUE;

        if(rightWidth >= 0)
            *rightInside = FALSE;
        else
            *rightInside = TRUE;
    }
    else
    {
        // Left Turn

        // If the width is negative, this point is outside.
        // For the zero width, we regard this as non-inside point.

        if(leftWidth <= 0)
            *leftInside = FALSE;
        else
            *leftInside = TRUE;

        if(rightWidth <= 0)
            *rightInside = FALSE;
        else
            *rightInside = TRUE;
    }

    BOOL isLeftMiterJoin = FALSE, isRightMiterJoin = FALSE;
    REAL leftShift1 = 0, rightShift1 = 0;
    REAL leftShift2 = 0, rightShift2 = 0;

    if(isMiter && cross != 0)
    {
        REAL test = 0;

        // Get the normal direction for the miter join.

        v.X = grad1.X - grad2.X;
        v.Y = grad1.Y - grad2.Y;

        // Test the miter limit.  
        
        test = v.X*v.X + v.Y*v.Y - cross*cross*miterLimit2;

        if(test <= 0 )
        {
            // Use the miter join.

            if(needsToAdjustNormals)
            {
                // Use adjusted normals so that aliased thin lines
                // won't disappear.

                REAL c1, c2;        
                
                c1 = norm2.X*grad2.Y - norm2.Y*grad2.X;
                c2 = norm1.X*grad1.Y - norm1.Y*grad1.X;
                v.X = c1*grad1.X - c2*grad2.X;
                v.Y = c1*grad1.Y - c2*grad2.Y;
            }

            v.X /= cross;
            v.Y /= cross;

            GpPointF *outPoints, *inPoints;
            REAL outWidth, inWidth;
            INT *outCount, *inCount;

            if(cross > 0)
            {
                // When a miter join is used, set the inside flag to
                // FALSE since there is no overlap.

                isLeftMiterJoin = TRUE;
                *leftInside = FALSE;

                if(useBevelJoinInside)
                {
                    if(*rightInside)
                        isRightMiterJoin = FALSE;
                    else
                    {
                        // When the right edges are outside,
                        // we cannot use Bevel join since
                        // Bevel join shape will actually appear.

                        isRightMiterJoin = TRUE;
                    }
                }
                else
                {
                    // When a miter join is used, set the inside flag to
                    // FALSE since there is no overlap.

                    isRightMiterJoin = TRUE;
                    *rightInside = FALSE;
                }
            }
            else
            {
                // When a miter join is used, set the inside flag to
                // FALSE since there is no overlap.

                isRightMiterJoin = TRUE;
                *rightInside = FALSE;

                if(useBevelJoinInside)
                {
                    if(*leftInside)
                        isLeftMiterJoin = FALSE;
                    else
                    {
                        // When the right edges are outside,
                        // we cannot use Bevel join since
                        // Bevel join shape will actually appear.

                        isLeftMiterJoin = TRUE;
                    }
                }
                else
                {
                    // When a miter join is used, set the inside flag to
                    // FALSE since there is no overlap.

                    isLeftMiterJoin = TRUE;
                    *leftInside = FALSE;
                }
            }
        }
        else
        {
            // The turn is too sharp and it exceeds the miter limit.
            // We must chop off the miter join tips.

            REAL n1n1 = 1, n2n2 = 1, g1n1 = 0, g2n2 = 0;

            if(needsToAdjustNormals)
            {
                n1n1 = norm1.X*norm1.X + norm1.Y*norm1.Y;
                n2n2 = norm2.X*norm2.X + norm2.Y*norm2.Y;
                g1n1 = grad1.X*norm1.X + grad1.Y*norm1.Y;
                g2n2 = grad2.X*norm2.X + grad2.Y*norm2.Y;
            }

            if(miterLimit2 > max(n1n1, n2n2))
            {
                if(*leftInside == FALSE)
                {
                    REAL lWidth;

                    if(cross > 0)
                        lWidth = leftWidth;     // Right Turn
                    else
                        lWidth = - leftWidth;   // Left Turn

                    leftShift1 = (REALSQRT(miterLimit2 - n1n1 + g1n1*g1n1)
                                - g1n1)*lWidth;
                    leftShift2 = (REALSQRT(miterLimit2 - n2n2 + g2n2*g2n2)
                                + g2n2)*lWidth;
                }

                if(*rightInside == FALSE)
                {
                    REAL rWidth;

                    if(cross > 0)
                        rWidth = rightWidth;    // Right Turn
                    else
                        rWidth = - rightWidth;  // Left Turn

                    rightShift1 = (REALSQRT(miterLimit2 - n1n1 + g1n1*g1n1)
                                - g1n1)*rWidth;
                    rightShift2 = (REALSQRT(miterLimit2 - n2n2 + g2n2*g2n2)
                                + g2n2)*rWidth;
                }
            }
        }
    }
        
    if(isLeftMiterJoin)
    {
        leftPoints[0].X = point.X + leftWidth*v.X;
        leftPoints[0].Y = point.Y + leftWidth*v.Y;
        *leftCount = 1;
    }
    else
    {
        leftPoints[0].X = point.X + leftWidth*norm1.X + leftShift1*grad1.X;
        leftPoints[0].Y = point.Y + leftWidth*norm1.Y + leftShift1*grad1.Y;
        leftPoints[1].X = point.X + leftWidth*norm2.X - leftShift2*grad2.X;
        leftPoints[1].Y = point.Y + leftWidth*norm2.Y - leftShift2*grad2.Y;
        
        // Check if two points are degenerate.

        if(REALABS(leftPoints[1].X - leftPoints[0].X) +
                REALABS(leftPoints[1].Y - leftPoints[0].Y)
                > POINTF_EPSILON)
        {
            *leftCount = 2;
        }
        else
        {
            // Since there is no overlap, set the inside flag to FALSE.

            *leftCount = 1;
            *leftInside = FALSE;
        }

    }

    if(isRightMiterJoin)
    {
        rightPoints[0].X = point.X + rightWidth*v.X;
        rightPoints[0].Y = point.Y + rightWidth*v.Y;
        *rightCount = 1;
    }
    else
    {
        rightPoints[0].X = point.X + rightWidth*norm1.X + rightShift1*grad1.X;
        rightPoints[0].Y = point.Y + rightWidth*norm1.Y + rightShift1*grad1.Y;
        rightPoints[1].X = point.X + rightWidth*norm2.X - rightShift2*grad2.X;
        rightPoints[1].Y = point.Y + rightWidth*norm2.Y - rightShift2*grad2.Y;

        // Check if two points are degenerate.

        if(REALABS(rightPoints[1].X - rightPoints[0].X) +
                REALABS(rightPoints[1].Y - rightPoints[0].Y)
                > POINTF_EPSILON)
        {
            *rightCount = 2;
        }
        else
        {
            // Since there is no overlap, set the inside flag to FALSE.

            *rightCount = 1;
            *rightInside = FALSE;
        }
    }

    return direction;
}

enum GpRoundJoinFlag
{
	NeedsNone = 0,
	NeedsOnlyRoundJoin = 1,
	NeedsOnlyNonRoundJoin = 2,
	NeedsBoth = 3
};

/**************************************************************************\
*
* Function Description:
*
*   From the given point and the two tangent vectors of the two edges,
*   and the radius of the round join, this returns the verteces for
*   left edges and right edges of the round join for the current point.
*   This is used when the bending angle is less than 90 degrees
*   and is called by GetRoundJoin.
*
* Arguments:
*
*   [IN] point -    The current points in the original path.
*   [IN] grad1 -    The tangent of the current edge.
*   [IN] grad2 -       The tangent of the next edge.
*   [IN] dot -      The dot product of grad1 and grad2.
*   [IN] leftWidth -	The left width of the round join.
*	[IN] rightWidth -	The right width of the round join.
*   [OUT] leftCount -   The count of the left points.
*   [OUT] leftPoints -  The left points.
*   [OUT] rightCount -  The count of the right points.
*   [OUT] rightPoints - The right points.
*
* Both leftPoints and rightPoints must have at least dimension of 4.
* If leftCount is positive (negative), this means the left edges are
*   lines with leftCount points (cubic Bezier curves with -leftCount
*   control points).
* If rightCount is positive (negative), this means the right edges are
*   lines with rightCount points (cubic Bezier curves with -rightCount
*   control points).
*
* Return Value:
*
*   None
*
*   06/16/99 ikkof
*       Created it
*
\**************************************************************************/

VOID
getSmallRoundJoin(
    const GpPointF& point,
    const GpPointF& grad1,
    const GpPointF& grad2,
    const GpPointF& norm1,
    const GpPointF& norm2,
    REAL leftWidth,
    REAL rightWidth,
    INT *leftCount,
    GpPointF *leftPoints,
    INT *rightCount,
    GpPointF *rightPoints,
	REAL dot,
    REAL cross,
    BOOL needsToAdjustNormals,
    REAL miterLimit2,
	INT condition,
    BOOL useBevelJoinInside
    )
{
    if((condition & NeedsBoth) == 0)
    {
        *leftCount = 0;
        *rightCount = 0;

        return;
    }

    GpPointF n1, n2;
    n1 = norm1;
    n2 = norm2;

    REAL k;
    REAL almostStraight = 1.0f - 0.01f;

    if(dot < almostStraight)
    {
        // Obtain the distance from the first control point
        // or from the last control point.
        // For its derivation, see ikkof's notes for "Round Joins".

        REAL cross1 = cross;
        if(cross < 0)
            cross1 = - cross;
        k = 4*(REALSQRT(2*(1 - dot)) - cross1)/(3*(1 - dot));

        GpPointF *outPoints, *inPoints;
        INT *outCount, *inCount;

		REAL outWidth, inWidth;

        if(cross >= 0)
        {
            // The left edges are round join.

            outPoints = leftPoints;
            inPoints = rightPoints;
            outCount = leftCount;
            inCount = rightCount;
			outWidth = leftWidth;
			inWidth = rightWidth;
        }
        else
        {
            // The right edges are round join.

            outPoints = rightPoints;
            inPoints = leftPoints;
            outCount = rightCount;
            inCount = leftCount;
			outWidth = - rightWidth;
			inWidth = - leftWidth;
            n1.X = - n1.X;
            n1.Y = - n1.Y;
            n2.X = - n2.X;
            n2.Y = - n2.Y;
        }


        // Get the normal direction for the miter join.

        GpPointF v;

        v.X = grad1.X - grad2.X;
        v.Y = grad1.Y - grad2.Y;

        // Test the miter limit.

        BOOL useMiterJoin = FALSE;;

        // Reduce the miter limit

        miterLimit2 = 3*3;

        // Note that abs(cross) == abs(cross1) from the definition.

        if(REALABS(cross1) >= REAL_EPSILON)
        {
            REAL test = v.X*v.X + v.Y*v.Y - cross*cross*miterLimit2;
            if(test <= 0)
            {
                useMiterJoin = TRUE;
                v.X /= cross1;
                v.Y /= cross1;
            }
        }

        useMiterJoin = useMiterJoin && !useBevelJoinInside;

        REAL k1;
        if(outWidth > 0)
        {
            if(condition & NeedsOnlyRoundJoin)
            {
                k1 = outWidth*k;
                outPoints[0].X = point.X + outWidth*n1.X;
                outPoints[0].Y = point.Y + outWidth*n1.Y;
                outPoints[1].X = outPoints[0].X + k1*grad1.X;
                outPoints[1].Y = outPoints[0].Y + k1*grad1.Y;
                outPoints[3].X = point.X + outWidth*n2.X;
                outPoints[3].Y = point.Y + outWidth*n2.Y;
                outPoints[2].X = outPoints[3].X - k1*grad2.X;
                outPoints[2].Y = outPoints[3].Y - k1*grad2.Y;
                *outCount = -4;    // Indicate "-" for Bezier
            }
            else
                *outCount = 0;
        }
        else
        {
            if(condition & NeedsOnlyNonRoundJoin)
            {
                if(outWidth == 0)
                {
                    outPoints[0] = point;
                    *outCount = 1;
                }
                else
                {
                    if(useMiterJoin)
                    {
                        outPoints[0].X = point.X + outWidth*v.X;
                        outPoints[0].Y = point.Y + outWidth*v.Y;
                        *outCount = 1;
                    }
                    else
                    {            
                        outPoints[0].X = point.X + outWidth*n1.X;
                        outPoints[0].Y = point.Y + outWidth*n1.Y;
                        outPoints[1].X = point.X + outWidth*n2.X;
                        outPoints[1].Y = point.Y + outWidth*n2.Y;
                        *outCount = 2;
                    }
                }
            }
            else
                *outCount = 0;
        }

        if(inWidth > 0)
        {
            if(condition & NeedsOnlyRoundJoin)
            {
                k1 = inWidth*k;
                inPoints[0].X = point.X + inWidth*n1.X;
                inPoints[0].Y = point.Y + inWidth*n1.Y;
                inPoints[1].X = inPoints[0].X + k1*grad1.X;
                inPoints[1].Y = inPoints[0].Y + k1*grad1.Y;
                inPoints[3].X = point.X + inWidth*n2.X;
                inPoints[3].Y = point.Y + inWidth*n2.Y;
                inPoints[2].X = inPoints[3].X - k1*grad2.X;
                inPoints[2].Y = inPoints[3].Y - k1*grad2.Y;
                *inCount = -4;    // Indicate "-" for Bezier
            }
            else
                *inCount = 0;
        }
        else
        {
            if(condition & NeedsOnlyNonRoundJoin)
            {
                if(inWidth == 0)
                {
                    inPoints[0] = point;
                    *inCount = 1;
                }
                else
                {
                    if(useMiterJoin)
                    {
                        inPoints[0].X = point.X + inWidth*v.X;
                        inPoints[0].Y = point.Y + inWidth*v.Y;
                        *inCount = 1;
                    }
                    else
                    {
                        inPoints[0].X = point.X + inWidth*n1.X;
                        inPoints[0].Y = point.Y + inWidth*n1.Y;
                        inPoints[1].X = point.X + inWidth*n2.X;
                        inPoints[1].Y = point.Y + inWidth*n2.Y;
                        *inCount = 2;
                    }
                }
            }
            else
                *inCount = 0;
        }
    }
    else
    {
        if(condition & NeedsOnlyNonRoundJoin)
        {
            // This is a straight line.

            leftPoints[0].X = point.X + leftWidth*n1.X;
            leftPoints[0].Y = point.Y + leftWidth*n1.Y;
            *leftCount = 1;

            rightPoints[0].X = point.X + rightWidth*n1.X;
            rightPoints[0].Y = point.Y + rightWidth*n1.Y;
            *rightCount = 1;
        }
        else
        {
            *leftCount = 0;
            *rightCount = 0;
        }
    }
}

/**************************************************************************\
*
* Function Description:
*
*   From the given previous, current, and next points and the radius
*   of the round join, this returns the verteces for left edges and
*   right edges of the round join for the current point.
*
* Arguments:
*
*   [IN] points -		The previous, current, and next points
*                       in the original path.
*   [IN] leftWidth -	The left width of the round join.
*	[IN] rightWidth -	The right width of the round join.
*   [OUT] leftCount -   The count of the left points.
*   [OUT] leftPoints -  The left points.
*   [OUT] rightCount -  The count of the right points.
*   [OUT] rightPoints - The right points.
*
* Both leftPoints and rightPoints must have at least dimension of 7.
* If leftCount is positive (negative), this means the left edges are
*   lines with leftCount points (cubic Bezier curves with -leftCount
*   control points).
* If rightCount is positive (negative), this means the right edges are
*   lines with rightCount points (cubic Bezier curves with -rightCount
*   control points).
*
* Return Value:
*
*   FALSE if the current point coindes with the previous point or
*       the next point.  Otherwise, this returns TRUE.
*
*   06/16/99 ikkof
*       Created it
*
\**************************************************************************/

GpTurningDirection
getRoundJoin(
    const GpPointF& point,
    const GpPointF& grad1,
    const GpPointF& grad2,
    const GpPointF& norm1,
    const GpPointF& norm2,
    REAL leftWidth,
    REAL rightWidth,
    INT* leftCount,
    GpPointF* leftPoints,
    BOOL* leftInside,
    INT* rightCount,
    GpPointF* rightPoints,
    BOOL* rightInside,
    BOOL needsToAdjustNormals,
    REAL miterLimit2,
    BOOL useBevelJoinInside
    )
{
    //!!! We need to update inside flags for Round joins later.

    *leftInside = FALSE;
    *rightInside = FALSE;
        
    ASSERT(leftPoints && rightPoints);
    ASSERT(leftCount && rightCount);

	REAL radius = leftWidth;

    // When it comes here, the three points are not degenerate.
    
    REAL dot = grad1.X*grad2.X + grad1.Y*grad2.Y;  // dot product.

    REAL cross;
    GpTurningDirection direction = getTurningDirection(
                        &cross, grad1, grad2);
//                        &cross, grad1, grad2, norm1, norm2);

    // If dot >= 0 (the bending angle is less than or equal to 90 degrees,
    // we can approximate this arc with one cubic Beizer curve.
    
    INT condition;
    REAL smallErr = - 0.001f;
    if(dot > smallErr)
    {
        condition = NeedsBoth;
        getSmallRoundJoin(point, grad1, grad2, norm1, norm2,
                leftWidth, rightWidth,
                leftCount, leftPoints, rightCount, rightPoints,
                dot, cross, needsToAdjustNormals, miterLimit2,
                condition, useBevelJoinInside);
    }
    else
    {
        // The bending angle is larger than 90 and less than or
        // equal to 180 degrees.
        // We can approximate this arc with two cubic Beizer curves.

        GpPointF *pts1, *pts2;
        INT count1, count2;

        pts1 = leftPoints;
        pts2 = rightPoints;

        // First obtain the non-round join parts.

        condition = NeedsOnlyNonRoundJoin;

        getSmallRoundJoin(point, grad1, grad2, norm1, norm2,
            leftWidth, rightWidth,
            &count1, pts1, &count2, pts2,
            dot, cross, needsToAdjustNormals, miterLimit2,
            condition, useBevelJoinInside);

        INT cnt1, cnt2;

        if(count1 > 0)
            cnt1 = count1;
        else
            cnt1 = 0;

        if(count2 > 0)
            cnt2 = count2;
        else
            cnt2 = 0;

        pts1 += cnt1;
        pts2 += cnt2;
        *leftCount = cnt1;
        *rightCount = cnt2;

        // Obtain the middle unit gradient vector.

        GpPointF midNorm;
        midNorm.X = norm1.X + norm2.X;
        midNorm.Y = norm1.Y + norm2.Y;

        if(midNorm.X != 0 || midNorm.Y != 0)
        {
            REAL dm = midNorm.X*midNorm.X + midNorm.Y*midNorm.Y;
            dm = REALSQRT(dm);
            midNorm.X /= dm;
            midNorm.Y /= dm;
        }
        else
        {
            midNorm.X = - norm1.Y;
            midNorm.Y = norm1.X;
        }

        GpPointF lm;

        // Rotate the mid normal +90 degrees.

        lm.X = - midNorm.Y;
        lm.Y = midNorm.X;

        // Obtain the first half of the round join.

        condition = NeedsOnlyRoundJoin;

        dot = grad1.X*lm.X + grad1.Y*lm.Y;
        cross = grad1.X*lm.Y - grad1.Y*lm.X;
        getSmallRoundJoin(point, grad1, lm, norm1, midNorm,
            leftWidth, rightWidth,
            &count1, pts1, &count2, pts2,
            dot, cross, needsToAdjustNormals, miterLimit2,
            condition, useBevelJoinInside);

        // Note that since the end point of the first half of
        // the round join and the start point of the second
        // of the round join are the same, don't copy
        // the end point of the first half of the round join.

        if(count1 < 0)
            cnt1 = - count1 - 1;
        else
            cnt1 = 0;

        if(count2 < 0)
            cnt2 = - count2 - 1;
        else
            cnt2 = 0;

        pts1 += cnt1;
        pts2 += cnt2;
        *leftCount += cnt1;
        *rightCount += cnt2;

        // Obtain the second half of the round join.

        dot = lm.X*grad2.X + lm.Y*grad2.Y;
        cross = lm.X*grad2.Y - lm.Y*grad2.X;
        getSmallRoundJoin(point, lm, grad2, midNorm, norm2,
            leftWidth, rightWidth,
            &count1, pts1, &count2, pts2,
            dot, cross, needsToAdjustNormals, miterLimit2,
            condition, useBevelJoinInside);

        // Combines the two curves or lines.
        
        if(count1 < 0)
            cnt1 += - count1;
        else
            cnt1 = 0;

        if(count2 < 0)
            cnt2 += - count2;
        else
            cnt2 = 0;

        if(cnt1 > 0)
            *leftCount = - cnt1;
        if(cnt2 > 0)
            *rightCount = - cnt2;
    }

    return direction;
}

/**************************************************************************\
*
* Function Description:
*
*   Calculates the vector for Miter or Bevel join.  This vector represents
*   the shift to the left along the moving direction.
*   In case of Miter join, when the Miter join exceeds the miter limit,
*   this returns the Bevel join.
*
* Arguments:
*
*   [OUT] vector - the left shift for the Miter join.  This must be
*                   allocated at least for the dimension of 2.
*   [OUT] count - the number of join points.
*   [IN] miterLimit2 - the square of the Miter limit.
*   [IN] grad1 - the unit tangent vector of the last edge.
*   [IN] grad2 - the unit tangent vector of the current edge.
*
* Return Value:
*
*   Turning direction from the last edge to the current edge.
*
\**************************************************************************/

GpTurningDirection
getHobbyJoin(
    const GpPointF& point,
    const GpPointF& grad1,
    const GpPointF& grad2,
    INT polyCount,
    const GpPointF* polyPoints,
    const REAL* polyAngles,
//    const GpPointF& norm1,
//    const GpPointF& norm2,
    REAL leftWidth,
    REAL rightWidth,
    INT *leftCount,
    GpPointF *leftPoints,
    INT *rightCount,
    GpPointF *rightPoints,
    BOOL needsToAdjustNormals,
    REAL miterLimit2,
    BOOL isMiter,
    BOOL useBevelJoinInside
    )
{
    if(miterLimit2 <= 1)
        isMiter = FALSE;

    GpTurningDirection direction = NotTurning;

    // Handle the degenerate cases.

    GpPointF v;
    REAL cross;

    direction = getTurningDirection(&cross, grad1, grad2);

    if(direction == NotMoving)
    {
        *leftCount = 0;
        *rightCount = 0;
        return direction;
    }

    // Find the left vertex ids.

    INT leftIndex1, leftIndex2;
    leftIndex1 = getVertexID(grad1, TRUE, polyCount, polyAngles);
    leftIndex2 = getVertexID(grad2, TRUE, polyCount, polyAngles);

    INT i;

    if(direction == TurningLeft)
    {
        *leftCount = 2;
        leftPoints[0] = point + polyPoints[leftIndex1];
        leftPoints[1] = point + polyPoints[leftIndex2];
    }
    else if(direction == TurningRight)
    {
        if(leftIndex2 > leftIndex1)
        {
            *leftCount = leftIndex2 - leftIndex1 + 1;

            for(i = 0; i <= leftIndex2 - leftIndex1; i++)
                leftPoints[i] = point + polyPoints[i + leftIndex1];
        }
        else if(leftIndex2 < leftIndex1)
        {
            *leftCount = polyCount - leftIndex1 + leftIndex2 + 1;

            for(i = 0; i < polyCount - leftIndex1; i++)
                leftPoints[i] = point + polyPoints[i + leftIndex1];

            for(i = 0; i <= leftIndex2; i++)
                leftPoints[polyCount - leftIndex1 + i]
                    = point + polyPoints[i];
        }
        else
        {
            *leftCount = 1;
            leftPoints[0] = point + polyPoints[leftIndex1];
        }
    }
    else
    {
        *leftCount = 1;
        leftPoints[0] = point + polyPoints[leftIndex1];
    }

    INT rightIndex1, rightIndex2;
    rightIndex1 = getVertexID(grad1, FALSE, polyCount, polyAngles);
    rightIndex2 = getVertexID(grad2, FALSE, polyCount, polyAngles);

    if(direction == TurningRight)
    {
        *rightCount = 2;
        rightPoints[0] = point + polyPoints[rightIndex1];
        rightPoints[1] = point + polyPoints[rightIndex2];
    }
    else if(direction == TurningLeft)
    {
        if(rightIndex1 > rightIndex2)
        {
            *rightCount = rightIndex1 - rightIndex2 + 1;

            for(i = 0; i <= rightIndex1 - rightIndex2; i++)
                rightPoints[i] = point + polyPoints[rightIndex1 - i];
        }
        else if(rightIndex1 < rightIndex2)
        {
            *rightCount = polyCount - rightIndex2 + rightIndex1 + 1;

            for(i = 0; i <= rightIndex1; i++)
                rightPoints[i] = point + polyPoints[rightIndex1 - i];

            for(i = 0; i < polyCount - rightIndex2; i++)
                rightPoints[rightIndex1 + 1 + i]
                    = point + polyPoints[polyCount - i - 1];
        }
        else
        {
            *rightCount = 1;
            rightPoints[0] = point + polyPoints[rightIndex1];
        }
    }
    else
    {
        *rightCount = 1;
        rightPoints[0] = point + polyPoints[rightIndex1];
    }

    return direction;
}

GpTurningDirection
getJoin(
    GpLineJoin lineJoin,
    const GpPointF& point,
    const GpPointF& grad1,
    const GpPointF& grad2,
    const GpPointF& norm1,
    const GpPointF& norm2,
    REAL leftWidth,
    REAL rightWidth,
    INT *leftCount,
    GpPointF *leftPoints,
    BOOL *leftInside,
    INT *rightCount,
    GpPointF *rightPoints,
    BOOL *rightInside,
    BOOL needsToAdjustNormals,
    REAL miterLimit2,
    BOOL useBevelJoinInside
    )
{
    BOOL isMiter = TRUE;

    GpTurningDirection direction;

    switch(lineJoin)
    {
    case LineJoinBevel:
        isMiter = FALSE;            // Fall through to Miter case.
        
    case LineJoinMiterClipped:
        // Treat Miter clipped joints that exceed the miter limit as
        // beveled joints.  Fall through to Miter case.
        if (lineJoin == LineJoinMiterClipped &&
            getMiterExceeded(grad1, grad2, miterLimit2))
        {
            isMiter = FALSE;
        }
        
    case LineJoinMiter:
        direction = getMiterBevelJoin(point, grad1, grad2, norm1, norm2,
                        leftWidth, rightWidth,
                        leftCount, leftPoints, leftInside,
                        rightCount, rightPoints, rightInside,
                        needsToAdjustNormals, miterLimit2, isMiter, useBevelJoinInside);
        break;

    case LineJoinRound:
        direction = getRoundJoin(point, grad1, grad2, norm1, norm2,
                        leftWidth, rightWidth,
                        leftCount, leftPoints, leftInside,
                        rightCount, rightPoints, rightInside,
                        needsToAdjustNormals, miterLimit2, useBevelJoinInside);
        break;
    }

    return direction;
}


/**************************************************************************\
*
* Function Description:
*
*   From the given the reference point, gradient, and widths,
*   this returns the verteces for the round cap.
*   The direction of the round cap is always clockwise.
*
* Arguments:
*
*   [IN] point -   The reference point.
*   [IN] grad -   The gradient.
*   [IN] isStartCap - TRUE if this is the start cap.
*   [IN] leftWidth -   The left width from the reference.
*   [IN] rightWidth -   The right width from the reference point.
*
*
* Return Value:
*
*   Ok if successfull.
*
*   06/16/99 ikkof
*       Created it
*
\**************************************************************************/

GpStatus
GpPathWidener::SetRoundCap(
    const GpPointF& point,
    const GpPointF& grad,
    BOOL isStartCap,
    REAL leftWidth,
    REAL rightWidth
    )
{
    if( (REALABS(grad.X) < REAL_EPSILON) && 
        (REALABS(grad.Y) < REAL_EPSILON) )
    {
        return InvalidParameter;
    }
    
    GpPointF* capPoints = NULL;
    BYTE* capTypes = NULL;

    if(isStartCap)
    {
        CapPoints1.Reset(FALSE);
        CapTypes1.Reset(FALSE);
        capPoints = CapPoints1.AddMultiple(7);
        if(capPoints)
            capTypes = CapTypes1.AddMultiple(7);

        if(!capPoints || !capTypes)
            return OutOfMemory;
    }
    else
    {
        CapPoints2.Reset(FALSE);
        CapTypes2.Reset(FALSE);
        capPoints = CapPoints2.AddMultiple(7);
        if(capPoints)
            capTypes = CapTypes2.AddMultiple(7);

        if(!capPoints || !capTypes)
            return OutOfMemory;
    }

    GpMemset(capTypes, PathPointTypeBezier, 7);
    capTypes[0] = PathPointTypeLine;

    GpPointF tangent;

    if(isStartCap)
    {
        tangent.X = - grad.X;
        tangent.Y = - grad.Y;
    }
    else
        tangent = grad;

    REAL radius = (leftWidth - rightWidth)/2;
    GpPointF center;

    center.X = point.X + (leftWidth + rightWidth)*grad.Y/2;
    center.Y = point.Y - (leftWidth + rightWidth)*grad.X/2;

    if(isStartCap)
    {
        center.X -= Inset1*tangent.X;
        center.Y -= Inset1*tangent.Y;
    }
    else
    {
        center.X -= Inset2*tangent.X;
        center.Y -= Inset2*tangent.Y;
    }

    REAL s1, c1;

    // Direction of the left normal multipled by radius.

    c1 = radius*tangent.Y;
    s1 = - radius*tangent.X;

    // 2 Bezier segments for a half circle with radius 1.

    REAL u_cir = U_CIR;
    capPoints[ 0].X = 1;       capPoints[ 0].Y = 0;
    capPoints[ 1].X = 1;       capPoints[ 1].Y = u_cir;
    capPoints[ 2].X = u_cir;   capPoints[ 2].Y = 1;
    capPoints[ 3].X = 0;       capPoints[ 3].Y = 1;
    capPoints[ 4].X = -u_cir;  capPoints[ 4].Y = 1;
    capPoints[ 5].X = -1;      capPoints[ 5].Y = u_cir;
    capPoints[ 6].X = -1;      capPoints[ 6].Y = 0;

    // Rotate, scale, and translate the original half circle.

    for(INT i = 0; i < 7; i++)
    {
        REAL x, y;

        x = capPoints[i].X;
        y = capPoints[i].Y;
        capPoints[i].X = (c1*x - s1*y) + center.X;
        capPoints[i].Y = (s1*x + c1*y) + center.Y;
    }

    return Ok;
}


/**************************************************************************\
*
* Function Description:
*
*    Creates a double round cap for inset pen ('B' shaped)
*
* Arguments:
*
*   [IN] point -   The reference point.
*   [IN] grad -   The gradient.
*   [IN] isStartCap - TRUE if this is the start cap.
*   [IN] leftWidth -   The left width from the reference.
*   [IN] rightWidth -   The right width from the reference point.
*
*
* Return Value:
*
*   Ok if successfull.
*
*   10/01/2000 asecchia
*       Created it
*
\**************************************************************************/

GpStatus
GpPathWidener::SetDoubleRoundCap(
    const GpPointF& point,
    const GpPointF& grad,
    BOOL isStartCap,
    REAL leftWidth,
    REAL rightWidth
    )
{
    if( (REALABS(grad.X) < REAL_EPSILON) && 
        (REALABS(grad.Y) < REAL_EPSILON) )
    {
        return InvalidParameter;
    }
    
    GpPointF* capPoints = NULL;
    BYTE* capTypes = NULL;

    if(isStartCap)
    {
        CapPoints1.Reset(FALSE);
        CapTypes1.Reset(FALSE);
        capPoints = CapPoints1.AddMultiple(14);
        if(capPoints)
            capTypes = CapTypes1.AddMultiple(14);

        if(!capPoints || !capTypes)
            return OutOfMemory;
    }
    else
    {
        CapPoints2.Reset(FALSE);
        CapTypes2.Reset(FALSE);
        capPoints = CapPoints2.AddMultiple(14);
        if(capPoints)
            capTypes = CapTypes2.AddMultiple(14);

        if(!capPoints || !capTypes)
            return OutOfMemory;
    }

    GpMemset(capTypes, PathPointTypeBezier, 14);
    capTypes[0] = PathPointTypeLine;
    capTypes[7] = PathPointTypeLine;

    GpPointF tangent;

    if(isStartCap)
    {
        tangent.X = - grad.X;
        tangent.Y = - grad.Y;
    }
    else
        tangent = grad;

    REAL radius = (leftWidth - rightWidth)/2;
    GpPointF center;

    center.X = point.X + (leftWidth + rightWidth)*grad.Y/2;
    center.Y = point.Y - (leftWidth + rightWidth)*grad.X/2;

    if(isStartCap)
    {
        center.X -= Inset1*tangent.X;
        center.Y -= Inset1*tangent.Y;
    }
    else
    {
        center.X -= Inset2*tangent.X;
        center.Y -= Inset2*tangent.Y;
    }

    REAL s1, c1;

    // Direction of the left normal multipled by radius.

    c1 = radius*tangent.Y;
    s1 = - radius*tangent.X;

    // 2 Bezier segments for a half circle with radius 1.

    REAL u_cir = U_CIR;
    capPoints[ 0].X = 1;       capPoints[ 0].Y = 0;
    capPoints[ 1].X = 1;       capPoints[ 1].Y = u_cir;
    capPoints[ 2].X = u_cir;   capPoints[ 2].Y = 1;
    capPoints[ 3].X = 0;       capPoints[ 3].Y = 1;
    capPoints[ 4].X = -u_cir;  capPoints[ 4].Y = 1;
    capPoints[ 5].X = -1;      capPoints[ 5].Y = u_cir;
    capPoints[ 6].X = -1;      capPoints[ 6].Y = 0;
    
    // Create the second bump and scale the first one.
    
    for(int i=0; i<7; i++)
    {
        capPoints[i+7].X = capPoints[i].X * 0.5f-0.5f;
        capPoints[i+7].Y = capPoints[i].Y * 0.5f;
        capPoints[i].X = 0.5f + capPoints[i].X * 0.5f;
        capPoints[i].Y = capPoints[i].Y * 0.5f;
    }

    // Rotate, scale, and translate the original half circle.

    for(INT i = 0; i < 14; i++)
    {
        REAL x, y;

        x = capPoints[i].X;
        y = capPoints[i].Y;
        capPoints[i].X = (c1*x - s1*y) + center.X;
        capPoints[i].Y = (s1*x + c1*y) + center.Y;
    }

    return Ok;
}

GpStatus
GpPathWidener::SetTriangleCap(
    const GpPointF& point,
    const GpPointF& grad,
    BOOL isStartCap,
    REAL leftWidth,
    REAL rightWidth,
    const GpPointF *points,
    INT pointCount
    )
{
    if( (REALABS(grad.X) < REAL_EPSILON) && 
        (REALABS(grad.Y) < REAL_EPSILON) )
    {
        return InvalidParameter;
    }

    GpPointF* capPoints = NULL;
    BYTE* capTypes = NULL;
    
    DynByteArray *capTypesArray;
    DynPointFArray *capPointsArray;   
    

    if(isStartCap)
    {
        CapPoints1.Reset(FALSE);
        CapTypes1.Reset(FALSE);
        capPoints = CapPoints1.AddMultiple(3);
        if(capPoints)
            capTypes = CapTypes1.AddMultiple(3);

        if(!capPoints || !capTypes)
            return OutOfMemory;
    }
    else
    {
        CapPoints2.Reset(FALSE);
        CapTypes2.Reset(FALSE);
        capPoints = CapPoints2.AddMultiple(3);
        if(capPoints)
            capTypes = CapTypes2.AddMultiple(3);

        if(!capPoints || !capTypes)
            return OutOfMemory;
    }

    GpMemset(&capTypes[0], PathPointTypeLine, 3);


    GpPointF norm, tangent;

    norm.X = grad.Y;
    norm.Y = - grad.X;

    if(isStartCap)
    {
        tangent.X = - grad.X;
        tangent.Y = - grad.Y;
    }
    else
    {
        tangent = grad;
    }

    GpPointF leftPt, rightPt;

    leftPt.X = point.X + leftWidth*norm.X;
    leftPt.Y = point.Y + leftWidth*norm.Y;
    rightPt.X = point.X + rightWidth*norm.X;
    rightPt.Y = point.Y + rightWidth*norm.Y;
    
    GpPointF center;
    
    REAL width = REALABS(leftWidth-rightWidth);
    
    center.X = 0.5f*(leftPt.X + rightPt.X + width*tangent.X);
    center.Y = 0.5f*(leftPt.Y + rightPt.Y + width*tangent.Y);
    
    capPoints[1] = center;

    if(isStartCap)
    {
        capPoints[0] = rightPt;
        capPoints[2] = leftPt;
    }
    else
    {
        capPoints[0] = leftPt;
        capPoints[2] = rightPt;
    }

    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   Add the first widened point of the current path type.
*
* Arguments:
*
*   [IN] leftWidth -	The left width for widened line.
*	[IN] rightWidth -	The right width for the widened line.
*   [IN] lineJoin -     The type of the line join.
*   [OUT] leftPoints1 - The buffer for the left points.
*   [OUT] leftTypes1 -   The buffer for the left types.
*   [OUT] addedLeftCount - The number of the added left points and types.
*   [OUT] rightPoints1 - The buffer for the right points.
*   [OUT] rightTypes1 - The buffer for the right types.
*   [OUT] addedRightCount - The number of the added right points and types.
*   [OUT] leftEndPt -   The end point of the left line for the current
*                       subpath.  This is calculated only for the first
*                       subpath point.
*   [OUT] rightEndPt -  The end point of the right line for tha current
*                       subpath.  This is calculated only for the first
*                       subpath point.
*   [IN] grad -         The gradients of the center points for the
*                       current path type.
*   [IN] dataPoints -   The center points data for the current path type
*   [IN] dataCount -    The number of data points in the current path type.
*   [IN/OUT] lastPt -   The last point used in calculations.
*   [IN] flag -         The flag to indicates the various properties
*                       of the current subpath and type.
*
*
* Return Value:
*
*   NONE
*
*   01/24/2000 ikkof
*       Created it
*
\**************************************************************************/

VOID
GpPathWidener::WidenFirstPoint(
    REAL leftWidth,
    REAL rightWidth,
    GpLineJoin lineJoin,
    REAL miterLimit2,
    GpPointF* leftPoints,
    BYTE* leftTypes,
    INT* addedLeftCount,
    GpPointF* rightPoints,
    BYTE* rightTypes,
    INT* addedRightCount,
    GpPointF* leftEndPt,
    GpPointF* rightEndPt,
    const GpPointF* grad,
    const GpPointF* norm,
    const GpPointF* dataPoints,
    INT dataCount,
    GpPointF* lastPt,
    const REAL* firstInsets,
    INT flag
    )
{
    GpPointF nextPt = dataPoints[0];
    GpPointF grad1, grad2;
    GpPointF norm1, norm2;


    INT leftCount = 0;
    INT rightCount = 0;
    grad1 = *grad++;
    grad2 = *grad;
    norm1 = *norm++;
    norm2 = *norm;

    INT numOfAddedFirstPts = 0;

    if(flag & WideningFirstType)
    {
        BOOL needsToAdjustNormals = FALSE;

        GpLineJoin lineJoin1 = lineJoin;
        if(flag & WideningNeedsToAdjustNormals)
        {
            needsToAdjustNormals = TRUE;
            lineJoin1 = LineJoinMiter;  // Don't use RoundJoin.
        }

		if(!(flag & WideningClosed))
        {
            lineJoin1 = LineJoinBevel;
        }

	    const INT bufferCount = 32;
        GpPointF lPts[bufferCount], rPts[bufferCount];
        INT lCnt, rCnt;
        GpTurningDirection direction;
        BOOL useBevelJoinInside = (flag & WideningUseBevelJoinInside) != 0;

        INT polyCount = JoinPolygonPoints.GetCount();
        const GpPointF* polyPoints = JoinPolygonPoints.GetDataBuffer();
        const REAL* polyAngles = JoinPolygonAngles.GetDataBuffer();

        BOOL leftInside = FALSE, rightInside = FALSE;

        if(polyCount > 0)
            direction = getHobbyJoin(
    //                        lineJoin1,
						    nextPt,
						    grad1,
						    grad2,
                            polyCount,
                            polyPoints,
                            polyAngles,
                            leftWidth,
                            rightWidth,
                            &lCnt,
                            &lPts[0],
                            &rCnt,
                            &rPts[0],
                            needsToAdjustNormals,
						    miterLimit2,
                            FALSE,   // IsMiter
                            useBevelJoinInside
						    );
        else
            direction = getJoin(
                        lineJoin1,
						nextPt,
						grad1,
						grad2,
                        norm1,
                        norm2,
                        leftWidth,
                        rightWidth,
                        &lCnt,
                        &lPts[0],
                        &leftInside,
                        &rCnt,
                        &rPts[0],
                        &rightInside,
                        needsToAdjustNormals,
						miterLimit2,
                        useBevelJoinInside
						);

        //!!! Inside flag check
        if(leftInside)
        {
            ASSERT((lCnt & 0x01) == 0);
        }

        
        //!!! Inside flag check
        if(rightInside)
        {
            ASSERT((rCnt & 0x01) == 0);
        }

        *leftEndPt = lPts[0];
        *rightEndPt = rPts[0];

		BYTE pathType;

        if(flag & WideningClosed)
        {
            if(lCnt > 0)
            {
                pathType = PathPointTypeLine;
            }
            else if(lCnt < 0)
            {
                lCnt = - lCnt;
                pathType = PathPointTypeBezier;
            }

            if(lCnt > 0)
            {
                //!!! Inside flag check
                if(leftInside)
                {
                    ASSERT((lCnt & 0x01) == 0);
                }

                if(leftInside)
                    pathType |= PathPointTypeInternalUse;
                GpMemset(leftTypes, pathType, lCnt);
                leftTypes[0] = PathPointTypeStart;
                if(leftInside)
                    leftTypes[0] |= PathPointTypeInternalUse;

                GpMemcpy(leftPoints, &lPts[0], lCnt*sizeof(GpPointF));
                leftTypes += lCnt;
                leftPoints += lCnt;
                leftCount += lCnt;
            }

            if(rCnt > 0)
            {
                pathType = PathPointTypeLine;
            }
            else if(rCnt < 0)
            {
                rCnt = - rCnt;
                pathType = PathPointTypeBezier;
            }

            if(rCnt > 0)
            {
                //!!! Inside flag check
                if(rightInside)
                {
                    ASSERT((rCnt & 0x01) == 0);
                }

                if(rightInside)
                    pathType |= PathPointTypeInternalUse;
                GpMemset(rightTypes, pathType, rCnt);
                rightTypes[0] = PathPointTypeStart;
                if(rightInside)
                    rightTypes[0] |= PathPointTypeInternalUse;

                GpMemcpy(rightPoints, &rPts[0], rCnt*sizeof(GpPointF));
                rightTypes += rCnt;
                rightPoints += rCnt;
                rightCount += rCnt;
            }
        }
        else
        {
            // The path is not closed.  Bevel join is used.

            GpPointF leftStartPt;
            GpPointF rightStartPt;
            INT index;

            if(lCnt == 1)
                index = 0;
            else
                index = 1;
            leftStartPt = lPts[index];

            if(rCnt == 1)
                index = 0;
            else
                index = 1;
            rightStartPt = rPts[index];

            if(!(flag & WideningClosed) && firstInsets[0] != 0)
            {
                leftStartPt.X += firstInsets[0]*grad2.X;
                leftStartPt.Y += firstInsets[0]*grad2.Y;
            }

            if(!(flag & WideningClosed) && firstInsets[1] != 0)
            {
                rightStartPt.X += firstInsets[1]*grad2.X;
                rightStartPt.Y += firstInsets[1]*grad2.Y;
            }

            *leftTypes++ = PathPointTypeStart;
            *rightTypes++ = PathPointTypeStart;
            *leftPoints = leftStartPt;
            *rightPoints = rightStartPt;

            leftPoints++;
            rightPoints++;
            leftCount++;
            rightCount++;
        }

        *lastPt = nextPt;
    }
    else
    {
        leftCount = rightCount = 0;
    }

    *addedLeftCount = leftCount;
    *addedRightCount = rightCount;
}

/**************************************************************************\
*
* Function Description:
*
*   Add the widened points for Lines
*
* For the arguments, See comments for widenFirstPoints
*
\**************************************************************************/

GpStatus
GpPathWidener::WidenLinePoints(
    REAL leftWidth,
    REAL rightWidth,
    GpLineJoin lineJoin,
    REAL miterLimit2,
    GpPointF* leftPoints,
    BYTE* leftTypes,
    INT* addedLeftCount,
    GpPointF* rightPoints,
    BYTE* rightTypes,
    INT* addedRightCount,
    const GpPointF* grad,
    const GpPointF* norm,
    const GpPointF* dataPoints,
    INT dataCount,
    GpPointF* lastPt,
    const REAL* lastInsets,
    INT flag
    )
{
    GpPointF grad1, grad2;
    GpPointF norm1, norm2;

    // Skip the first point since it is already added either by
    // widenFirstPoint() or by the widen call of the previous type.

    dataPoints++;
    dataCount--;  // The number of the remaining points.

    // Also skip the first gradient.

    grad++;
    grad1 = *grad++;
    norm++;
    norm1 = *norm++;

    BOOL isLastType = FALSE;

    if(flag & WideningLastType)
        isLastType = TRUE;

    BOOL needsToAdjustNormals = FALSE;

    GpLineJoin lineJoin1 = lineJoin;
    if(flag & WideningNeedsToAdjustNormals)
    {
        needsToAdjustNormals = TRUE;
        lineJoin1 = LineJoinMiter;  // Don't use RoundJoin.
    }

    INT leftCount = 0, rightCount = 0;
    BOOL isLastPoint = FALSE;
    BYTE pathType = PathPointTypeLine;

    INT jmax = dataCount;
    if(isLastType)
    {
        if(flag & WideningClosed)
        {
            if(!(flag & WideningLastPointSame))
            {
                // When the subpath is closed, and the last point is not
                // the same as the start point, don't regard this as
                // the last type.  Add points as usual.

                isLastType = FALSE;
            }
            else
            {
                // No need to add the last point since this is already
                // added by the first point.

                jmax--;
            }
        }
    }

	BOOL useBevelJoinInside = (flag & WideningUseBevelJoinInside) != 0;

    INT polyCount = JoinPolygonPoints.GetCount();
    const GpPointF* polyPoints = JoinPolygonPoints.GetDataBuffer();
    const REAL* polyAngles = JoinPolygonAngles.GetDataBuffer();

    INT i, j;
    for(j = 0; j < jmax; j++)
    {
        GpPointF nextPt = *dataPoints;

        if(isLastType && (j == dataCount - 1))
        {
			isLastPoint = TRUE;
            lineJoin1 = LineJoinBevel;
        }

        if(lastPt->X != nextPt.X || lastPt->Y != nextPt.Y)
        {
            grad2 = *grad;
            norm2 = *norm;

            const INT bufferCount = 32;
            GpPointF lPts[bufferCount], rPts[bufferCount];
            INT lCnt, rCnt;
            GpTurningDirection direction;
            BOOL leftInside = FALSE, rightInside = FALSE;

            if(polyCount > 0)
                direction = getHobbyJoin(
        //                        lineJoin1,
						        nextPt,
						        grad1,
						        grad2,
                                polyCount,
                                polyPoints,
                                polyAngles,
                                leftWidth,
                                rightWidth,
                                &lCnt,
                                &lPts[0],
                                &rCnt,
                                &rPts[0],
                                needsToAdjustNormals,
						        miterLimit2,
                                FALSE,   // IsMiter
                                useBevelJoinInside
						        );
            else
                direction = getJoin(
                                lineJoin1,
						        nextPt,
						        grad1,
						        grad2,
                                norm1,
                                norm2,
                                leftWidth,
                                rightWidth,
                                &lCnt,
                                &lPts[0],
                                &leftInside,
                                &rCnt,
                                &rPts[0],
                                &rightInside,
                                needsToAdjustNormals,
						        miterLimit2,
                                useBevelJoinInside
						        );

            //!!! Inside flag check
            if(leftInside)
            {
                ASSERT((lCnt & 0x01) == 0);
            }

        
            //!!! Inside flag check
            if(rightInside)
            {
                ASSERT((rCnt & 0x01) == 0);
            }

            if(isLastPoint)
            {
                lCnt = 1;
                rCnt = 1;
                leftInside = FALSE;
                rightInside = FALSE;

                if(lastInsets[0] != 0)
                {
                    lPts[0].X -= lastInsets[0]*grad1.X;
                    lPts[0].Y -= lastInsets[0]*grad1.Y;
                }

                if(lastInsets[1] != 0)
                {
                    rPts[0].X -= lastInsets[1]*grad1.X;
                    rPts[0].Y -= lastInsets[1]*grad1.Y;
                }
            }

            if(lCnt > 0)
            {
                pathType = PathPointTypeLine;
            }
            else if(lCnt < 0)
            {
                lCnt = - lCnt;
                pathType = PathPointTypeBezier;
            }

            if(lCnt > 0)
            {
                //!!! Inside flag check
                if(leftInside)
                {
                    ASSERT((lCnt & 0x01) == 0);
                }

                if(leftInside)
                    pathType |= PathPointTypeInternalUse;
                GpMemset(leftTypes, pathType, lCnt);
                leftTypes[0] = PathPointTypeLine;
                if(leftInside)
                    leftTypes[0] |= PathPointTypeInternalUse;

                GpMemcpy(leftPoints, &lPts[0], lCnt*sizeof(GpPointF));
                leftTypes += lCnt;
                leftPoints += lCnt;
                leftCount += lCnt;
            }

            if(rCnt > 0)
            {
                pathType = PathPointTypeLine;
            }
            else if(rCnt < 0)
            {
                rCnt = - rCnt;
                pathType = PathPointTypeBezier;
            }
            
            if(rCnt > 0)
            {
                //!!! Inside flag check
                if(rightInside)
                {
                    ASSERT((rCnt & 0x01) == 0);
                }

                if(rightInside)
                    pathType |= PathPointTypeInternalUse;
                GpMemset(rightTypes, pathType, rCnt);
                rightTypes[0] = PathPointTypeLine;
                if(rightInside)
                    rightTypes[0] |= PathPointTypeInternalUse;

                GpMemcpy(rightPoints, &rPts[0], rCnt*sizeof(GpPointF));
                rightTypes += rCnt;
                rightPoints += rCnt;
                rightCount += rCnt;
            }
            
            grad1 = grad2;
            norm1 = norm2;
            *lastPt = nextPt;        
        }
        
        grad++;
        norm++;
        dataPoints++;
    }
    
    *addedLeftCount = leftCount;
    *addedRightCount = rightCount;

    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   Add the widened points for Beziers
*
* For the arguments, See comments for widenFirstPoints
*
\**************************************************************************/

GpStatus
GpPathWidener::WidenBezierPoints(
    REAL leftWidth,
    REAL rightWidth,
    GpLineJoin lineJoin,
    REAL miterLimit2,
    GpPointF* leftPoints,
    BYTE* leftTypes,
    INT* addedLeftCount,
    GpPointF* rightPoints,
    BYTE* rightTypes,
    INT* addedRightCount,
    const GpPointF* grad,
    const GpPointF* norm,
    const GpPointF* dataPoints,
    INT dataCount,
    GpPointF* lastPt,
    const REAL* lastInsets,
    INT flag
    )
{
    //!!! Kink removal has not been considered here yet.

    GpPointF grad1, grad2;
    GpPointF norm1, norm2;

    // Skip the first point since it is already added either by
    // widenFirstPoint() or by the widen call of the previous type.

    dataPoints++;
    dataCount--;  // The number of the remaining points.

    // Also skip the first gradient.

    grad++;
    grad1 = *grad++;

    norm++;
    norm1 = *norm++;

	BOOL isLastType = FALSE;

    if(flag & WideningLastType)
        isLastType = TRUE;

    BOOL needsToAdjustNormals = FALSE;

    GpLineJoin lineJoin1 = lineJoin;
    if(flag & WideningNeedsToAdjustNormals)
    {
        needsToAdjustNormals = TRUE;
        lineJoin1 = LineJoinMiter;  // Don't use RoundJoin.
    }

    INT remainder = dataCount % 3;
    INT bezierCount = dataCount/3;

    ASSERT(remainder == 0); // dataCount must be multiple of 3.

    INT leftCount = 0, rightCount = 0;
    BOOL isLastPoint = FALSE;
    BYTE pathType = PathPointTypeBezier;

    if(isLastType)
    {
        if((flag & WideningClosed) && !(flag & WideningLastPointSame))
        {
            // When the subpath is closed, and the last point is not
            // the same as the start point, don't regard this as
            // the last type.  Add points as usual.

            isLastType = FALSE;
        }

        // When the path is closed and the last point is the same,
        // we must do the special treatment since the last join points
        // were already added as the first join points.
        // So keep isLastType to TRUE for this case.
    }

	BOOL useBevelJoinInside = flag & WideningUseBevelJoinInside;

    INT i, j;
    for(j = 0; j < bezierCount; j++)
    {
        for(INT k = 0; k < 3; k++)
        {
            GpPointF nextPt = *dataPoints;

            if(k < 2)
            {
                // Second and third control point.

                lineJoin1 = LineJoinMiter;
            }
            else
            {
                // The last control point.

//                lineJoin1 = lineJoin;
                lineJoin1 = LineJoinRound;
            }

            if(isLastType
                && (j == bezierCount - 1) && (k == 2))
            {
			    isLastPoint = TRUE;

                if(!(flag & WideningClosed))
                {
                    // When the subpath is not closed, make the
                    // last join as Bevel join.

                    lineJoin1 = LineJoinBevel;

                    // When the subpath is closed, use the current
                    // join.
                }
                else
                {
                    lineJoin1 = LineJoinRound;
                }
            }

            grad2 = *grad;
            norm2 = *norm;
            GpPointF lPts[7], rPts[7];
            INT lCnt, rCnt;
            GpTurningDirection direction;
            BOOL leftInside = FALSE, rightInside = FALSE;

            direction = getJoin(
                            lineJoin1,
						    nextPt,
						    grad1,
						    grad2,
                            norm1,
                            norm2,
                            leftWidth,
                            rightWidth,
                            &lCnt,
                            &lPts[0],
                            &leftInside,
                            &rCnt,
                            &rPts[0],
                            &rightInside,
                            needsToAdjustNormals,
						    miterLimit2,
                            useBevelJoinInside
						    );

			if(k < 2)
            {
                // In case that the miter join was not availabe
                // for k < 2, take the average of two vectors.

                if(lCnt == 2)
                {
                    lPts[0].X = (lPts[0].X + lPts[1].X)/2;
                    lPts[0].Y = (lPts[0].Y + lPts[1].Y)/2;
                }
                lCnt = 1;

                if(rCnt == 2)
                {
                    rPts[0].X = (rPts[0].X + rPts[1].X)/2;
                    rPts[0].Y = (rPts[0].Y + rPts[1].Y)/2;
                }
                rCnt = 1;
            }

            if(isLastPoint)
            {
                // In order to keep the 3n point format for the Bezier
                // curves, we must add the first point of the join
                // points as the last point of the last Bezier segment.

                if(!(flag & WideningClosed))
                {
                    lCnt = 1;
                    rCnt = 1;

                    if(lastInsets[0] != 0)
                    {
                        lPts[0].X -= lastInsets[0]*grad1.X;
                        lPts[0].Y -= lastInsets[0]*grad1.Y;
                    }

                    if(lastInsets[1] != 0)
                    {
                        rPts[0].X -= lastInsets[1]*grad1.X;
                        rPts[0].Y -= lastInsets[1]*grad1.Y;
                    }
                }
            }

            *leftPoints++ = lPts[0];
            *leftTypes++ = pathType;
            leftCount++;

            *rightPoints++ = rPts[0];
            *rightTypes++ = pathType;
            rightCount++;

            if(k == 2)
            {
                if(lCnt > 1)
                {
                    *leftPoints++ = lPts[1];
                    *leftTypes++ = PathPointTypeLine;
                    leftCount++;
                }
                else if(lCnt < 0)
                {
                    lCnt = - lCnt;
                    ASSERT(lCnt % 3 == 1);
                    GpMemcpy(leftPoints, &lPts[1], (lCnt - 1)*sizeof(GpPointF));
                    GpMemset(leftTypes, pathType, lCnt - 1);
                    leftPoints += lCnt - 1;
                    leftTypes += lCnt - 1;
                    leftCount += lCnt - 1;
                }

                if(rCnt > 1)
                {
                    *rightPoints++ = rPts[1];
                    *rightTypes++ = PathPointTypeLine;
                    rightCount++;
                }
                else if(rCnt < 0)
                {
                    rCnt = - rCnt;
                    ASSERT(rCnt % 3 == 1);
                    GpMemcpy(rightPoints, &rPts[1], (rCnt - 1)*sizeof(GpPointF));
                    GpMemset(rightTypes, pathType, rCnt - 1);
                    rightPoints += rCnt - 1;
                    rightTypes += rCnt - 1;
                    rightCount += rCnt - 1;
                }
            }

            grad1 = grad2;
            norm1 = norm2;
            *lastPt = nextPt;        
        
            grad++;
            norm++;
            dataPoints++;
        }
    }
    
    *addedLeftCount = leftCount;
    *addedRightCount = rightCount;

    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   Add the widened points for each path type.
*
* For the arguments, See comments for widenFirstPoints
*
\**************************************************************************/

GpStatus
GpPathWidener::WidenEachPathType(
    BYTE pathType,
    REAL leftWidth,
    REAL rightWidth,
    GpLineJoin lineJoin,
    REAL miterLimit2,
    GpPointF* leftPoints,
    BYTE* leftTypes,
    INT* addedLeftCount,
    GpPointF* rightPoints,
    BYTE* rightTypes,
    INT* addedRightCount,
    const GpPointF* grad,
    const GpPointF* norm,
    const GpPointF* dataPoints,
    INT dataCount,
    GpPointF* lastPt,
    const REAL* lastInsets,
    INT flag
    )
{
    GpStatus status = GenericError;

    switch(pathType)
    {
    case PathPointTypeLine:
        status = WidenLinePoints(
            leftWidth,
            rightWidth,
            lineJoin,
            miterLimit2,
            leftPoints,
            leftTypes,
            addedLeftCount,
            rightPoints,
            rightTypes,
            addedRightCount,
            grad,
            norm,
            dataPoints,
            dataCount,
            lastPt,
            lastInsets,
            flag);
        break;

    case PathPointTypeBezier:
        status = WidenBezierPoints(
            leftWidth,
            rightWidth,
            lineJoin,
            miterLimit2,
            leftPoints,
            leftTypes,
            addedLeftCount,
            rightPoints,
            rightTypes,
            addedRightCount,
            grad,
            norm,
            dataPoints,
            dataCount,
            lastPt,
            lastInsets,
            flag);
        break;

    default:
        WARNING(("Trying to widen undefined types."));
        break;
    }

    return status;
}

REAL
getCapDelta(
    const DpPen* pen
    )
{
    GpLineCap startCap = pen->StartCap;
    GpLineCap endCap = pen->EndCap;
    GpLineCap dashCap = pen->DashCap;

    REAL delta = 0, delta1;

    if(!(startCap & LineCapAnchorMask))
        delta1 = 0.5f;
    else
        delta1 = 3.0f;  // We must adjust later.

    if(delta < delta1)
        delta = delta1;

    if(!(endCap & LineCapAnchorMask))
        delta1 = 0.5f;
    else
        delta1 = 3.0f;  // We must adjust later.

    if(delta < delta1)
        delta = delta1;

    if(!(dashCap & LineCapAnchorMask))
        delta1 = 0.5f;
    else
        delta1 = 3.0f;  // We must adjust later.

    if(delta < delta1)
        delta = delta1;

    //!!! Add cutom line case.

    return 1.0f;
}

/**************************************************************************\
*
* Function Description:
*
*   This calculates the extra width due to pen.
*
* Arguments:
*
*   None
*
* Return Value:
*
*   The extra width.
*
*   02/29/00 ikkof
*       Created it
*
\**************************************************************************/

REAL
GpPathWidener::GetPenDelta()
{
    const GpPointF* centerPoints = CenterPoints.GetDataBuffer();
    const BYTE* centerTypes = CenterTypes.GetDataBuffer();
    INT centerCount = CenterPoints.GetCount();

    INT startIndex, endIndex;
    BOOL isClosed;
    GpStatus status = Ok;

    REAL scale;

    switch(Pen->PenAlignment)
    {
    case PenAlignmentCenter:
    default:
        scale = 0.5f;
        break;
    }

    REAL capDelta = getCapDelta(Pen);

    REAL joinDelta = 1.0f;

    if(Pen->Join == LineJoinMiter ||
       Pen->Join == LineJoinMiterClipped)
    {
        while(Iterator.NextSubpath(&startIndex, &endIndex, &isClosed)
		    && status == Ok)
        {
            status = CalculateGradients(startIndex, endIndex);

            if(status == Ok)
            {
                REAL delta = GetSubpathPenMiterDelta(isClosed);
                if(delta > joinDelta)
                    joinDelta = delta;
            }
        }

        if(status != Ok)
        {
            // We have to use the possible maximum for miter join.
            // Usually this is an over-estimate since the most path
            // don't have very sharp edges which correspond to miter limit.

            joinDelta = Pen->MiterLimit;
        }
    }

    REAL penDelta = max(joinDelta, capDelta)*scale;

    if(NeedsToTransform)
    {
        // This is already in device unit.

        penDelta *= StrokeWidth;
    }
    else
    {
        // Convert the width to the device unit.

        penDelta *= MaximumWidth;
    }
    if(penDelta < 1)
        penDelta = 1;

    return penDelta;
}

/**************************************************************************\
*
* Function Description:
*
*   This calculates the extra within a subpath due to a pen.
*   This is called by GetPenDelta().
*
* Arguments:
*
*   None
*
* Return Value:
*
*   The extra width.
*
*   02/29/00 ikkof
*       Created it
*
\**************************************************************************/

REAL
GpPathWidener::GetSubpathPenMiterDelta(
    BOOL isClosed
    )
{
    INT count = Gradients.GetCount();

    GpPointF* grad0 = Gradients.GetDataBuffer();

    INT imin, imax;
    if(isClosed)
    {
        imin = 0;
        imax = count - 1;
    }
    else
    {
        imin = 1;
        imax = count - 2;
    }

    GpPointF* grad = grad0 + imin;
    GpPointF prevGrad = *grad++;
    GpPointF nextGrad;

    REAL dot = 0;

    for(INT i = imin; i < imax; i++)
    {
        nextGrad = *grad++;
        REAL dot1 = prevGrad.X*nextGrad.X + prevGrad.Y*nextGrad.Y;
        prevGrad = nextGrad;

        if(dot1 < dot)
            dot = dot1;
    }

    REAL cosHalfTheta = (dot + 1.0f)*0.5f;
    REAL miterDelta = Pen->MiterLimit;

    // If the miterDelta is smaller than the miter limit, calculate it.

    if(cosHalfTheta > 0 && cosHalfTheta*miterDelta*miterDelta > 1)
    {
        cosHalfTheta = REALSQRT(cosHalfTheta);
        miterDelta = 1.0f/cosHalfTheta;
    }

    return miterDelta;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\entry\precomp.hpp ===
// stddef.h is needed for 'offsetof'

#include <stddef.h>

#include <objbase.h>
#include <icm.h>

#include "..\Runtime\Runtime.hpp"
#include "..\Common\Common.hpp"

#include "..\..\privinc\imaging.h"
#include "..\..\privinc\pixelformats.h"

#include "..\..\ddkinc\ddiplus.hpp"
#include "..\PDrivers\ConvertToGdi.hpp"

// Hack:
#include "..\Render\scan.hpp"
#include "..\Render\scandib.hpp"
// EndHack

#include "iterator.hpp"

#include "device.hpp"
#include "..\PDrivers\hp_vdp.h"
#include "..\PDrivers\PDrivers.hpp"

#include "vectormath.hpp"
#include "geometry.hpp"
#include "object.hpp"
#include "region.hpp"
#include "stringFormat.hpp"
#include "XBezier.hpp"
#include "PathSelfIntersectRemover.hpp"
#include "path.hpp"
#include "CustomLineCap.hpp"
#include "endcap.hpp"
#include "PathWidener.hpp"
#include "QuadTransforms.hpp"
#include "XPath.hpp"
#include "ImageAttr.hpp"
#include "gpbitmap.hpp"
#include "brush.hpp"
#include "pen.hpp"
#include "Metafile.hpp"
#include "regiontopath.hpp"

// Hack:
#include "..\Render\output.hpp"
#include "..\Render\aarasterizer.hpp"
// EndHack

#include "initialize.hpp"

// font stuff

#define _NO_DDRAWINT_NO_COM

#include "..\fondrv\tt\ttfd\fontddi.h"

extern "C" {
#include "..\fondrv\tt\ttfd\fdsem.h"
#include "..\fondrv\tt\ttfd\mapfile.h"
};

#include "intMap.hpp"
#include "fontface.hpp"
#include "facerealization.hpp"
#include "fontfile.hpp"
#include "fontable.hpp"
#include "FontLinking.hpp"
#include "family.hpp"
#include "font.hpp"
#include "fontfilecache.hpp"
#include "fontcollection.hpp"
#include "aatext.hpp"

#include "graphics.hpp"

#include "TextImager.hpp"
#include "DrawGlyphData.hpp"

#include "fastText.hpp"

#include "..\imaging\api\ColorPal.hpp"
#include "..\imaging\api\Bitmap.hpp"
#include "..\imaging\api\Recolor.hpp"
#include "CachedBitmap.hpp"
#include "copyonwritebitmap.hpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\entry\pen.hpp ===
/**************************************************************************\
*
* Copyright (c) 1998  Microsoft Corporation
*
* Abstract:
*
*   Pen API related declarations
*
* Revision History:
*
*   12/09/1998 andrewgo
*       Flesh out pen interfaces.
*
*   12/08/1998 andrewgo
*       Created it.
*
\**************************************************************************/

#ifndef _PEN_HPP
#define _PEN_HPP

//--------------------------------------------------------------------------
// Abstract base class for various pen types
//--------------------------------------------------------------------------

class GpLineTexture;
class GpCustomLineCap;

class GpPen : public GpObject
{
protected:
    VOID SetValid(BOOL valid)
    {
        GpObject::SetValid(valid ? ObjectTagPen : ObjectTagInvalid);
    }

public:

    // Constructors

    GpPen(
        const GpColor& color,
        REAL penWidth,
        GpUnit unit = UnitWorld
        );

    GpPen(
        const GpBrush* brush,
        REAL penWidth,
        GpUnit = UnitWorld
        );

    GpPen(
        GpLineTexture* lineTexture,
        REAL penWidth,
        GpUnit = UnitWorld
        );

    // Make a copy of the pen object

    GpPen* Clone();

    // Virtual destructor

    virtual ~GpPen()
    {
        if(Brush)
            delete Brush;

        if(DevicePen.CustomStartCap)
            delete DevicePen.CustomStartCap;

        if(DevicePen.CustomEndCap)
            delete DevicePen.CustomEndCap;

        GpFree(DevicePen.DashArray);
        GpFree(DevicePen.CompoundArray);
    }

    // Get the lock object

    GpLockable *GetObjectLock() const
    {
        return &Lockable;
    }

    // Check if the pen object is valid

    virtual BOOL IsValid() const
    {
        return GpObject::IsValid(ObjectTagPen);
    }

    // Determine if pens are equivalent

    virtual BOOL IsEqual(const GpPen * pen) const;

    virtual ObjectType GetObjectType() const { return ObjectTypePen; }

    virtual UINT GetDataSize() const;
    virtual GpStatus GetData(IStream * stream) const;
    virtual GpStatus SetData(const BYTE * dataBuffer, UINT size);

    virtual GpStatus ColorAdjust(
        GpRecolor *             recolor,
        ColorAdjustType         type
        );

    // Set/get fill attributes

    VOID Set(
        const GpColor& color,
        REAL penWidth,
        GpUnit = UnitWorld
        );

    GpStatus SetColor(GpColor* color);

    GpStatus GetColor(ARGB *argb) const;

    GpStatus SetBrush(GpBrush* brush);

    GpBrush* GetBrush()
    {
        return Brush;
    }

    GpBrush* GetClonedBrush()
    {
        if(Brush)
        {
            return Brush->Clone();
        }
        else
            return NULL;
    }

    GpPenType GetPenType();

    GpStatus SetLineTexture(GpLineTexture* lineTexture);
    GpLineTexture* GetLineTexture();

    // Set/get pen transform

    GpStatus SetTransform(const GpMatrix& matrix)
    {
        GpStatus    status = Ok;

        // Keep the transform invertible

        if (matrix.IsInvertible())
        {
            DevicePen.Xform = matrix;
            UpdateUid();
        }
        else
            status = InvalidParameter;

        return status;
    }

    GpStatus GetTransform(GpMatrix* matrix) const
    {
        *matrix = DevicePen.Xform;

        return Ok;
    }

    GpStatus ResetTransform()
    {
        if (!DevicePen.Xform.IsIdentity())
        {
            DevicePen.Xform.Reset();
            UpdateUid();
        }

        return Ok;
    }

    GpStatus MultiplyTransform(const GpMatrix& matrix,
                                    GpMatrixOrder order = MatrixOrderPrepend);

    GpStatus TranslateTransform(REAL dx, REAL dy,
                                    GpMatrixOrder order = MatrixOrderPrepend)
    {
        DevicePen.Xform.Translate(dx, dy, order);
        UpdateUid();

        return Ok;
    }

    GpStatus ScaleTransform(REAL sx, REAL sy,
                                    GpMatrixOrder order = MatrixOrderPrepend)
    {
        DevicePen.Xform.Scale(sx, sy, order);
        UpdateUid();

        return Ok;
    }

    GpStatus RotateTransform(REAL angle,
                                    GpMatrixOrder order = MatrixOrderPrepend)
    {
        DevicePen.Xform.Rotate(angle, order);
        UpdateUid();

        return Ok;
    }

    // See if the pen has a non-identity transform.
    BOOL HasTransform() const
    {
        return !DevicePen.Xform.IsIdentity();
    }

    // Set/get line caps: start, end, and dash

    VOID SetStartCap(GpLineCap startCap)
    {
        DevicePen.StartCap = startCap;
        if(DevicePen.CustomStartCap)
        {
            delete DevicePen.CustomStartCap;
            DevicePen.CustomStartCap = NULL;
        }
        UpdateUid();
    }

    VOID SetEndCap(GpLineCap endCap)
    {
        DevicePen.EndCap = endCap;
        if(DevicePen.CustomEndCap)
        {
            delete DevicePen.CustomEndCap;
            DevicePen.CustomEndCap = NULL;
        }
        UpdateUid();
    }

    GpLineCap GetStartCap() const
    {
        return DevicePen.StartCap;
    }

    GpLineCap GetEndCap() const
    {
        return DevicePen.EndCap;
    }

    VOID SetLineCap(GpLineCap startCap, GpLineCap endCap, GpDashCap dashCap)
    {
        DevicePen.StartCap = startCap;
        DevicePen.EndCap = endCap;
        SetDashCap(dashCap);
        UpdateUid();
    }

    GpStatus SetCustomStartCap(const GpCustomLineCap* customCap);
    GpStatus GetCustomStartCap(GpCustomLineCap** customCap);
    GpStatus SetCustomEndCap(const GpCustomLineCap* customCap);
    GpStatus GetCustomEndCap(GpCustomLineCap** customCap);

    // Set/get line join

    VOID SetLineJoin(GpLineJoin lineJoin)
    {
        DevicePen.Join = lineJoin;
        UpdateUid();
    }

    GpLineJoin GetLineJoin() const
    {
        return DevicePen.Join;
    }

    VOID SetMiterLimit(REAL miterLimit)
    {
        DevicePen.MiterLimit = max(1.0f, miterLimit);
        UpdateUid();
    }

    REAL GetMiterLimit() const
    {
        return DevicePen.MiterLimit;
    }

    GpStatus SetPenAlignment(GpPenAlignment penMode)
    {
        // Compound Inset pens aren't implemented yet.
        // The code for correctly handling minimum width compound sub lines
        // is missing.
        
        if((penMode==PenAlignmentInset) && 
           (DevicePen.CompoundCount!=0))
        {
            return NotImplemented;
        }
        
        DevicePen.PenAlignment = penMode;
        UpdateUid();
        
        return Ok;
    }

    GpPenAlignment GetPenAlignment() const
    {
        return DevicePen.PenAlignment;
    }

    // Set/get dash attributes

    GpDashStyle GetDashStyle() const
    {
        return DevicePen.DashStyle;
    }

    GpDashCap GetDashCap() const
    {
    	// Note: Internally we use a GpLineCap type to store the dash cap type.
    	// So we need to convert between GpLineCap and GpDashCap.
    	// However, we should change the internal usage to GpDashCap in v2.
    	// - JBronsk
    	GpDashCap dashCap = DashCapFlat;
    	switch (DevicePen.DashCap)
    	{
    	case LineCapRound:
    		dashCap = DashCapRound;
    		break;
    	case LineCapTriangle:
    		dashCap = DashCapTriangle;
    		break;
    	// all others map to DashCapFlat
    	}
        return dashCap;
    }
 
    VOID SetDashCap(GpDashCap dashCap);

    GpStatus SetDashStyle(GpDashStyle dashStyle);

    VOID SetDashOffset(REAL dashOffset)
    {
        DevicePen.DashOffset = dashOffset;
        UpdateUid();
    }

    REAL GetDashOffset() const
    {
        return DevicePen.DashOffset;
    }

    INT GetDashCount() const
    {
        return DevicePen.DashCount;
    }

    GpStatus GetDashArray(REAL* dashArray, INT count) const;

    DpPen * GetDevicePen()
    {
        return & DevicePen;
    }

    VOID SetWidth(REAL penWidth)
    {
        DevicePen.Width = penWidth;
        UpdateUid();
    }


    REAL GetWidth() const
    {
        return DevicePen.Width;
    }

    REAL GetMaximumJoinWidth(
            REAL sharpestAngle,
            const GpMatrix* matrix,
            REAL dpiX,
            REAL dpiY) const;

    REAL GetMaximumCapWidth(
            const GpMatrix* matrix,
            REAL dpiX,
            REAL dpiY) const;

    VOID SetUnit(GpUnit unit)
    {
        // UnitDisplay is device-dependent and cannot be used for a pen size
        ASSERT(unit != UnitDisplay);

        DevicePen.Unit = unit;
        UpdateUid();
    }

    GpUnit GetUnit() const
    {
        return DevicePen.Unit;
    }

    GpStatus SetDashArray(const REAL* dashArray, INT count);

    INT GetCompoundCount() const
    {
        return DevicePen.CompoundCount;
    }

    GpStatus SetCompoundArray(const REAL* compoundArray, INT count);

    GpStatus GetCompoundArray(REAL* compoundArray, INT count);

    BOOL IsOpaque() const
    {
        return Brush->IsOpaque();
    }

    BOOL IsSolid() const
    {
        return Brush->IsSolid();
    }

    COLORREF ToCOLORREF() const
    {
        return Brush->ToCOLORREF();
    }

    REAL GetCapDelta();

    static GpPen * GetPen(const DpPen * pen)
    {
        return (GpPen *) ((BYTE *) pen - offsetof(GpPen, DevicePen));
    }

    static REAL ComputeMiterLength(
        REAL angle,
        REAL miterLimit
    );

    VOID
    AdjustDashArrayForCaps(
        REAL dashUnit,
        REAL *dashArray,
        INT dashCount
        ) const;

    REAL
    GetDashCapInsetLength(
        REAL dashUnit
        ) const;
        
private:

    VOID InitDefaultState(REAL penWidth, GpUnit unit);
    GpStatus SetDashStyleWithDashCap(GpDashStyle dashStyle, GpLineCap dashCap);

    // GetMaximumWidth is used only for UnitWorld.

    GpStatus GetMaximumWidth(REAL* width, const GpMatrix* matrix) const;

protected:

    mutable GpLockable Lockable;

    GpBrush *   Brush;

    DpPen       DevicePen;

    GpPen()
    {
        DevicePen.InitDefaults();
        SetValid(TRUE);
    }

    GpPen(const GpPen* pen);
};


#endif _PEN_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\entry\printer.hpp ===
/**************************************************************************\
*
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   printer.h
*
* Abstract:
*
*   Printer related header inclusions
*
* Revision History:
*
*   6/21/1999 ericvan
*       Created it.
*
\**************************************************************************/

#ifndef PRINTER_HPP
#define PRINTER_HPP

#define GDIPLUS_UNI_INIT       4607
#define GDIPLUS_UNI_ESCAPE     4606

typedef struct _GDIPPRINTINIT
{
    DWORD dwSize;

    ULONG numPalEntries;
    ULONG palEntries[256];

    BOOL  usePal;
    DWORD dwMode;
    FLONG flRed;
    FLONG flGre;
    FLONG flBlu;
}
GDIPPRINTINIT, *PGDIPPRINTINIT;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\entry\quadtransforms.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1999 - 2000  Microsoft Corporation
*
* Abstract:
*
*   Quad Transforms
*
* History:
*
*   03/17/1999 ikkof
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"

INT solveQuadraticEquationForQuadTransform(REAL a, REAL b, REAL c, REAL* x);

// Constants used in GpQuadAnalyzer

#define EdgeHorizontal  0
#define EdgeDown        1
#define EdgeUp          2

VOID
GpQuadAnalyzer::SetQuadAnalyzer(const GpPointF* points)
{
    Left = Right = points[0].X;
    Top = Bottom = points[0].Y;

    for(INT i = 0; i < 4; i++)
    {
        INT j = i + 1;
        if(j == 4)
            j = 0;

        if(points[i].Y < points[j].Y)
        {
            Directions[i] = EdgeDown;
            Y1[i] = points[i].Y;
            Y2[i] = points[j].Y;
            X1[i] = points[i].X;
            DxDy[i] = (points[j].X - points[i].X)/(points[j].Y - points[i].Y);
        }
        else if(points[i].Y > points[j].Y)
        {
            Directions[i] = EdgeUp;
            Y1[i] = points[j].Y;
            Y2[i] = points[i].Y;
            X1[i] = points[j].X;
            DxDy[i] = (points[j].X - points[i].X)/(points[j].Y - points[i].Y);
        }
        else    // Horizontal
        {
            Directions[i] = EdgeHorizontal;
            Y1[i] = points[i].Y;
            Y2[i] = points[i].Y;
            X1[i] = points[i].X;
            DxDy[i] = 0;    // It is not used.
        }

        if(points[i].X < Left)
            Left = points[i].X;
        else if(points[i].X > Right)
            Right = points[i].X;

        if(points[i].Y < Top)
            Top = points[i].Y;
        else if(points[i].Y > Bottom)
            Bottom = points[i].Y;
    }
}

// Get the x-spans of a quad and returns the number of
// pairs of x-spans.

INT
GpQuadAnalyzer::GetXSpans(REAL* xSpans, REAL y)
{
    if(y < Top || y >= Bottom)
        return 0;

    INT count = 0;

    for(INT i = 0; i < 4; i++)
    {        
        if(Directions[i] != EdgeHorizontal && y >= Y1[i] && y < Y2[i])
            xSpans[count++] = X1[i] + DxDy[i]*(y - Y1[i]);
    }

    return (count >> 1);
}

VOID
GpBilinearTransform::Initialize()
{
    GpMemset(&SrcRect, 0, sizeof(GpRectF));
    GpMemset(&DstBounds, 0, sizeof(GpRectF));
    GpMemset(&A, 0, sizeof(GpPointF));
    GpMemset(&B, 0, sizeof(GpPointF));
    GpMemset(&C, 0, sizeof(GpPointF));
    GpMemset(&D, 0, sizeof(GpPointF));

    C_VV = C_V = 0;

    FixedValue = -1.0f;

#ifdef TEST_QUADTRANSFORMS
    // For testing purpose only.

    GpMemset(&Verteces[0], 0, 4*sizeof(GpPointF));

#endif
}

/**************************************************************************\
*
*     P0         P1
*     ------------
*     |           \
*     |            \
*     |             \
*     |              \
*     ----------------\
*     P2              P3
*
\**************************************************************************/

GpStatus
GpBilinearTransform::SetBilinearTransform(
    const GpRectF& rect,
    const GpPointF* points,
    INT count,
    REAL fixed
    )
{
    BOOL test = ((points != NULL) && (count == 3 || count == 4));
    ASSERT(test);

    if(!test)
        return InvalidParameter;

    SrcRect = rect;

    REAL left, right, top, bottom;

    left = right = points[0].X;
    top = bottom = points[0].Y;

    for(INT i = 1; i < count; i++)
    {
        if(points[i].X < left)
            left = points[i].X;
        else if(points[i].X > right)
            right = points[i].X;

        if(points[i].Y < top)
            top = points[i].Y;
        else if(points[i].Y > bottom)
            bottom = points[i].Y;
    }

    GpPointF quad[4];

    quad[0] = points[0];
    quad[1] = points[1];
    quad[3] = points[2];

    if(count == 4)
    {
        A.X = points[0].X - points[1].X - points[2].X + points[3].X;
        A.Y = points[0].Y - points[1].Y - points[2].Y + points[3].Y;

        quad[2] = points[3];
    }
    else
    {
        // This is a palallelogram.

        A.X = 0;
        A.Y = 0;

        // Obtain the fourth vertex.

        REAL x3 = points[1].X + points[2].X - points[0].X;
        REAL y3 = points[1].Y + points[2].Y - points[0].Y;

        if(x3 < left)
            left = x3;
        else if(x3 > right)
            right = x3;

        if(y3 < top)
            top = y3;
        else if(y3 > bottom)
            bottom = y3;

        quad[2].X = x3;
        quad[2].Y = y3;
    }

    B.X = points[1].X - points[0].X;
    B.Y = points[1].Y - points[0].Y;
    C.X = points[2].X - points[0].X;
    C.Y = points[2].Y - points[0].Y;
    D = points[0];

    if(A.X != C.X || A.Y != C.Y)
        C_VV = A.X*C.Y - A.Y*C.X;
    else
        C_VV = 0;
    C_V = B.X*C.Y - B.Y*C.X;

    DstBounds.X = left;
    DstBounds.Y = top;
    DstBounds.Width = right - left;
    DstBounds.Height = bottom - top;

    QAnalyzer.SetQuadAnalyzer(&quad[0]);

    FixedValue = fixed;

#ifdef TEST_QUADTRANSFORMS
    // For testing purpose only.

    GpMemcpy(&Verteces[0], points, count*sizeof(GpPointF));
    if(count == 3)
    {
        // Set the fourth vertex.

        Verteces[3].X = points[1].X + points[2].X - points[0].X;
        Verteces[3].Y = points[1].Y + points[2].Y - points[0].Y;
    }

#endif

    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
* Solve the quadratic equation of a branch which reduces
* to x = - c/b when a is very small.  This returns the number of
* appropriate solution which is either 0 or 1.
*
* a x^2 + b x + c = 0.
*
*   12/22/1999 ikkof
*       Created it.
\**************************************************************************/

INT solveQuadraticEquationForQuadTransform(REAL a, REAL b, REAL c, REAL* x)
{
    INT n = 0;
    REAL x1 = 0, x2 = 0;

    if(a != 0)
    {
        REAL D = b*b - 4*a*c;

        if(D > 0)
        {
            n = 2;
            D = REALSQRT(D);

            if(b >= 0)
            {
                x1 = (2*c)/(-b - D);
                x2 = (-b - D)/(2*a);
            }
            else
            {
                x1 = (2*c)/(-b + D);
                x2 = (-b + D)/(2*a);
            }

            if(x1 < 0 || x1 > 1)
            {
                if(x2 >= 0 && x2 <= 1)
                {
                    REAL temp = x1;
                    x1 = x2;
                    x2 = temp;
                }
            }

        }
        else if(D == 0)
        {
            n = 1;
            x1 = - b/(2*a);
        }
    }
    else
    {
        // This is a linear equation.

        if(b != 0)
        {
            n = 1;
            x1 = - c/b;
        }
    }

    x[0] = x1;
    x[1] = x2;

    return n;
}

/**************************************************************************\
*
* Function Description:
*
*   This returns the x-spans of the current quad at given y
*   between xmin and xmax.
*
* Arguments:
*
*   [OUT] xSpans    - the x-spans
*   [IN] y          - y-coordinate to evaluate.
*   [IN] xmin       - the minimum x (inclusive)
*   [IN] xmax       - the maximum x (exclusive)
*
* Return Value:
*
*   INT - Retuns the number of x-span pairs (0, 1, or 2).
*
* Created:
*
*   01/04/2000 ikkof
*
\**************************************************************************/

INT
GpBilinearTransform::GetXSpans(
    INT* xSpans,
    INT y,
    INT xmin,
    INT xmax
    )
{
    REAL realY = TOREAL(y);

    if(
        realY < DstBounds.Y
        || realY >= DstBounds.Y + DstBounds.Height
        || TOREAL(xmax) < DstBounds.X
        || TOREAL(xmin) >= DstBounds.X + DstBounds.Width
     )
        return 0;   // Do the quick rejection.

    REAL x[4];
    INT index = (QAnalyzer.GetXSpans(&x[0], realY) << 1);

    // Sort x in ascending order.

    if(index >= 2)
    {
        for(INT i = 0; i < index - 1; i++)
        {
            for(INT j = i + 1; j < index; j++)
            {
                if(x[j] < x[i])
                {
                    REAL temp = x[i];
                    x[i] = x[j];
                    x[j] = temp;
                }
            }
        }
    }
    else
        return 0;   // No x-span in the given y.

    // Check for the first span.

    if(x[0] >= xmax || x[1] <= xmin)
    {
        x[0] = x[2];
        x[1] = x[3];
        index -= 2;
    }
    else
    {
        x[0] = max(x[0], xmin);
        x[1] = min(x[1], xmax);
    }

    if(index >= 4)
    {
        // Check for the second span

        if(x[2] >= xmax || x[3] <= xmin)
            index -= 2;
        else
        {
            x[2] = max(x[2], xmin);
            x[3] = min(x[3], xmax);
        }
    }

    INT j = 0;

    for(INT i = 0; i < index; i += 2)
    {
        // Use Ceiling for both since xmin is inclusive
        // and xmax is exclusive (hence the real inclusive
        // span is being bounded by Celing and Floor).

        xSpans[j] = GpCeiling(x[i]);
        xSpans[j + 1] = GpCeiling(x[i+1]);
        if(xSpans[j + 1] > xSpans[j])
            j += 2;
    }

    return j/2;
}

BOOL
GpBilinearTransform::GetSourceParameter(
    REAL* u,
    REAL* v,
    const GpPointF& point
    )
{
    if (FixedValue >= 0)
    {
        *u = FixedValue;
        *v = FixedValue;
        return TRUE;
    }
    
    REAL b, c, vv[2];
    GpPointF dD;

    dD.X = D.X - point.X;
    dD.Y = D.Y - point.Y;

    b = C_V + A.X*dD.Y - A.Y*dD.X;
    c = B.X*dD.Y - B.Y*dD.X;

    INT num = solveQuadraticEquationForQuadTransform(C_VV, b, c, &vv[0]);

    if(num == 0)
        return FALSE;

    REAL u1 = 0, v1 = 0, u2 = 0, v2 = 0;

    BOOL firstSolutionOk = FALSE;
    BOOL secondSolutionOk = FALSE;

    firstSolutionOk = TRUE;

    v1 = vv[0];
    REAL denomX = A.X*v1 + B.X;
    REAL denomY = A.Y*v1 + B.Y;

    if(REALABS(denomX) > REALABS(denomY))
    {
        u1 = - (C.X*v1 + dD.X)/denomX;
    }
    else if(REALABS(denomY) > 0)
    {
        u1 = - (C.Y*v1 + dD.Y)/denomY;
    }
    else    // Both denomX and denomY = 0.
        firstSolutionOk = FALSE;

    if(num == 2)
    {
        // Allow 1 % error between 0 and 1.

        if(u1 < -0.02f || u1 > 1.02f || v1 < -0.02f || v1 > 1.02f || !firstSolutionOk)
        {
            // We may be picking a wrong solution.  Evaluate the other.

            secondSolutionOk = TRUE;

            v2 = vv[1];
            denomX = A.X*v2 + B.X;
            denomY = A.Y*v2 + B.Y;
            if(REALABS(denomX) > REALABS(denomY))
            {
                u2 = - (C.X*v2 + dD.X)/denomX;
            }
            else if(REALABS(denomY) > 0)
            {
                u2 = - (C.Y*v2 + dD.Y)/denomY;
            }
            else    // Both denomX and denomY = 0.
                secondSolutionOk = FALSE;

            // Allow 1 % error between 0 and 1.

            if(secondSolutionOk
                && u2 >= - 0.02f && u2 <= 1.02f && v2 >= -0.02f && v2 <= 1.02f)
            {
                REAL temp = u1;
                u1 = u2;
                u2 = temp;

                temp = v1;
                v1 = v2;
                v2 = temp;
            }
            else secondSolutionOk = FALSE;
        }
    }

    if(firstSolutionOk || secondSolutionOk > 0)
    {
        u[0] = u1;
        v[0] = v1;
        u[1] = u2;
        v[1] = v2;

        return TRUE;    // success
    }
    else
        return FALSE;   // no valid parameter.
}


/**************************************************************************\
*
* Function Description:
*
*   This returns the x-spans and uv arrays of the current quad at given y
*   between xmin and xmax.
*
* Arguments:
*
*   [OUT] u         - u-array
*   [OUT] v         - v-array
*   [OUT] xSpans    - the x-spans
*   [IN] y          - y-coordinate to evaluate.
*   [IN] xmin       - the minimum x (inclusive)
*   [IN] xmax       - the maximum x (exclusive)
*
* Return Value:
*
*   INT - Retuns the number of x-span pairs (0, 1, or 2).
*
* Created:
*
*   01/04/2000 ikkof
*
\**************************************************************************/

INT
GpBilinearTransform::GetSourceParameterArrays(
    REAL* u,
    REAL* v,
    INT* xSpans,
    INT y,
    INT xmin,
    INT xmax
    )
{
    ASSERT(u && v && xSpans);

    INT pairCount = GetXSpans(xSpans, y, xmin, xmax);

    INT count = 0;

    REAL u1[2], v1[2];

    GpMemset(&u1[0], 0, 2*sizeof(REAL));
    GpMemset(&v1[0], 0, 2*sizeof(REAL));

    for(INT k = 0; k < pairCount; k++)
    {
        GpPointF destPt;
        destPt.Y = TOREAL(y);
        destPt.X = TOREAL(xSpans[2*k]);

        BOOL firstPoint = TRUE;
        INT width = xSpans[2*k + 1] - xSpans[2*k];

        for(INT i = 0; i < width; i++)
        {
            BOOL success = GetSourceParameter(&u1[0], &v1[0], destPt);
            if(!success)
                WARNING(("There is no solution for quadratic equation."));

            *(u + count) = u1[0];
            *(v + count) = v1[0];

            count++;

            destPt.X += 1;
        }
    }

    return pairCount;
}

/**************************************************************************\
*
* This converts lines to quadratic Beziers.
*
* [IN] points:  the line points
* [IN] count:   the number of line points.
* [OUT] q:      the quadratic Bezier control points.
*
* The array size of q must be larger than or equal to 2*count - 1.
*
\**************************************************************************/

GpStatus
GpBilinearTransform::ConvertLines(
    const GpPointF* points,
    INT count,
    GpPointF* q)
{
    ASSERT(points && q);
    ASSERT(count >= 2);

    REAL mx, my, nx, ny;

    GpPointF pt1, pt2;

    pt1 = points[0];

    INT j = 0;
    for(INT i = 1; i < count; i++)
    {
        pt2 = points[i];
        mx = (pt2.X - pt1.X)/SrcRect.Width;
        my = (pt2.Y - pt1.Y)/SrcRect.Height;
        nx = (pt1.X - SrcRect.X)/SrcRect.Width;
        ny = (pt1.Y - SrcRect.Y)/SrcRect.Height;

        GpPointF c0, c1, c2;
        REAL temp;

        temp = mx*my;
        c2.X = temp*A.X;
        c2.Y = temp*A.Y;
        temp = mx*ny + my*nx;
        c1.X = temp*A.X + mx*B.X + my*C.X;
        c1.Y = temp*A.Y + mx*B.Y + my*C.Y;
        temp = nx*ny;
        c0.X = temp*A.X + nx*B.X + ny*C.X + D.X;
        c0.Y = temp*A.Y + nx*B.Y + ny*C.Y + D.Y;

        if(j == 0)
            q[j++] = c0;
        q[j].X = c0.X + c1.X/2;
        q[j++].Y = c0.Y + c1.Y/2;
        q[j].X = c0.X + c1.X + c2.X;
        q[j++].Y = c0.Y + c1.Y + c2.Y;

        pt1 = pt2;
    }

    return Ok;
}
    

/**************************************************************************\
*
* This converts lines to quadratic Beziers.
*
* [IN] points:  the line points
* [IN] count:   the number of line points.
* [OUT] data:   the quadratic Bezier control points.
*
* The array size of q must be larger than or equal to 2*(2*count - 1).
*
\**************************************************************************/

GpStatus
GpBilinearTransform::ConvertLines(
    const GpPointF* points,
    INT count,
    REALD* data)
{
    ASSERT(points && data);
    ASSERT(count >= 2);

    REALD mx, my, nx, ny;

    GpPointF pt1, pt2;

    pt1 = points[0];

    INT j = 0;
    for(INT i = 1; i < count; i++)
    {
        pt2 = points[i];
        mx = (pt2.X - pt1.X)/SrcRect.Width;
        my = (pt2.Y - pt1.Y)/SrcRect.Height;
        nx = (pt1.X - SrcRect.X)/SrcRect.Width;
        ny = (pt1.Y - SrcRect.Y)/SrcRect.Height;

        GpPointD c0, c1, c2;
        REALD temp;

        temp = mx*my;
        c2.X = temp*A.X;
        c2.Y = temp*A.Y;
        temp = mx*ny + my*nx;
        c1.X = temp*A.X + mx*B.X + my*C.X;
        c1.Y = temp*A.Y + mx*B.Y + my*C.Y;
        temp = nx*ny;
        c0.X = temp*A.X + nx*B.X + ny*C.X + D.X;
        c0.Y = temp*A.Y + nx*B.Y + ny*C.Y + D.Y;

        if(j == 0)
        {
            *data++ = c0.X;
            *data++ = c0.Y;
            j++;
        }

        *data++ = c0.X + c1.X/2;
        *data++ = c0.Y + c1.Y/2;

        *data++ = c0.X + c1.X + c2.X;
        *data++ = c0.Y + c1.Y + c2.Y;

        j += 2;

        pt1 = pt2;
    }

    return Ok;
}
    

/**************************************************************************\
*
* This converts cubic Beziers to 6-th order Beziers.
*
* [IN] points:  the cubic Bezier control points
* [IN] count:   the number of the control points.
* [OUT] q:      the 6-th order Bezier control points.
*
* The array size of q must be larger than or equal to 2*count - 1.
*
\**************************************************************************/

GpStatus
GpBilinearTransform::ConvertCubicBeziers(
    const GpPointF* srcQ,
    INT count,
    GpPointF* q
    )
{
    ASSERT(srcQ && q);
    ASSERT(count > 3 && (count % 3 == 1));
    
    GpPointF a0, a1, a2, a3;

    INT j = 0;
    for(INT i = 1; i < count; i += 3)
    {
        a0.X = (srcQ[i - 1].X - SrcRect.X)/SrcRect.Width;
        a0.Y = (srcQ[i - 1].Y - SrcRect.Y)/SrcRect.Height;
        a1.X = 3*(srcQ[i].X - srcQ[i - 1].X)/SrcRect.Width;
        a1.Y = 3*(srcQ[i].Y - srcQ[i - 1].Y)/SrcRect.Height;
        a2.X = 3*(srcQ[i - 1].X - srcQ[i].X - srcQ[i].X + srcQ[i + 1].X)/SrcRect.Width;
        a2.Y = 3*(srcQ[i - 1].Y - srcQ[i].Y - srcQ[i].Y + srcQ[i + 1].Y)/SrcRect.Height;
        a3.X = (srcQ[i + 2].X - srcQ[i - 1].X + 3*(srcQ[i].X - srcQ[i + 1].X))/SrcRect.Width;
        a3.Y = (srcQ[i + 2].Y - srcQ[i - 1].Y + 3*(srcQ[i].Y - srcQ[i + 1].Y))/SrcRect.Height;

        REAL temp;
        GpPointF c[7];

        temp = a3.X*a3.Y;
        c[6].X = temp*A.X;
        c[6].Y = temp*A.Y;
    
        temp = a3.X*a2.Y + a2.X*a3.Y;
        c[5].X = temp*A.X;
        c[5].Y = temp*A.Y;

        temp = a3.X*a1.Y + a2.X*a2.Y + a1.X*a3.Y;
        c[4].X = temp*A.X;
        c[4].Y = temp*A.Y;

        temp = a3.X*a0.Y + a2.X*a1.Y + a1.X*a2.Y + a0.X*a3.Y;
        c[3].X = temp*A.X + a3.X*B.X + a3.Y*C.X;
        c[3].Y = temp*A.Y + a3.X*B.Y + a3.Y*C.Y;

        temp = a2.X*a0.Y + a1.X*a1.Y + a0.X*a2.Y;
        c[2].X = temp*A.X + a2.X*B.X + a2.Y*C.X;
        c[2].Y = temp*A.Y + a2.X*B.Y + a2.Y*C.Y;

        temp = a1.X*a0.Y + a0.X*a1.Y;
        c[1].X = temp*A.X + a1.X*B.X + a1.Y*C.X;
        c[1].Y = temp*A.Y + a1.X*B.Y + a1.Y*C.Y;

        temp = a0.X*a0.Y;
        c[0].X = temp*A.X + a0.X*B.X + a0.Y*C.X + D.X;
        c[0].Y = temp*A.Y + a0.X*B.Y + a0.Y*C.Y + D.Y;

        if(j == 0)
            q[j++] = c[0];
        q[j].X = c[0].X + c[1].X/6;
        q[j++].Y = c[0].Y + c[1].Y/6;
        q[j].X = c[0].X + c[1].X/3 + c[2].X/15;
        q[j++].Y = c[0].Y + c[1].Y/3 + c[2].Y/15;
        q[j].X = c[0].X + c[1].X/2 + c[2].X/5 + c[3].X/20;
        q[j++].Y = c[0].Y + c[1].Y/2 + c[2].Y/5 + c[3].Y/20;
        q[j].X = c[0].X + 2*c[1].X/3 + 2*c[2].X/5 + c[3].X/5 + c[4].X/15;
        q[j++].Y = c[0].Y + 2*c[1].Y/3 + 2*c[2].Y/5 + c[3].Y/5 + c[4].Y/15;
        q[j].X = c[0].X + 5*c[1].X/6 + 2*c[2].X/3 + c[3].X/2 + c[4].X/3 + c[5].X/6;
        q[j++].Y = c[0].Y + 5*c[1].Y/6 + 2*c[2].Y/3 + c[3].Y/2 + c[4].Y/3 + c[5].Y/6;
        q[j].X = c[0].X + c[1].X + c[2].X + c[3].X + c[4].X + c[5].X + c[6].X;
        q[j++].Y = c[0].Y + c[1].Y + c[2].Y + c[3].Y + c[4].Y + c[5].Y + c[6].Y;
    }

    return Ok;
}

/**************************************************************************\
*
* This converts cubic Beziers to 6-th order Beziers.
*
* [IN] points:  the cubic Bezier control points
* [IN] count:   the number of the control points.
* [OUT] q:      the 6-th order Bezier control points.
*
* The array size of q must be larger than or equal to 2*count - 1.
*
\**************************************************************************/

GpStatus
GpBilinearTransform::ConvertCubicBeziers(
    const GpPointF* srcQ,
    INT count,
    REALD* data
    )
{
    ASSERT(srcQ && data);
    ASSERT(count > 3 && (count % 3 == 1));
    
    GpPointD a0, a1, a2, a3;

    INT j = 0;
    for(INT i = 1; i < count; i += 3)
    {
        a0.X = (srcQ[i - 1].X - SrcRect.X)/SrcRect.Width;
        a0.Y = (srcQ[i - 1].Y - SrcRect.Y)/SrcRect.Height;
        a1.X = 3*(srcQ[i].X - srcQ[i - 1].X)/SrcRect.Width;
        a1.Y = 3*(srcQ[i].Y - srcQ[i - 1].Y)/SrcRect.Height;
        a2.X = 3*(srcQ[i - 1].X - srcQ[i].X - srcQ[i].X + srcQ[i + 1].X)/SrcRect.Width;
        a2.Y = 3*(srcQ[i - 1].Y - srcQ[i].Y - srcQ[i].Y + srcQ[i + 1].Y)/SrcRect.Height;
        a3.X = (srcQ[i + 2].X - srcQ[i - 1].X + 3*(srcQ[i].X - srcQ[i + 1].X))/SrcRect.Width;
        a3.Y = (srcQ[i + 2].Y - srcQ[i - 1].Y + 3*(srcQ[i].Y - srcQ[i + 1].Y))/SrcRect.Height;

        REALD temp;
        GpPointD c[7];

        temp = a3.X*a3.Y;
        c[6].X = temp*A.X;
        c[6].Y = temp*A.Y;
    
        temp = a3.X*a2.Y + a2.X*a3.Y;
        c[5].X = temp*A.X;
        c[5].Y = temp*A.Y;

        temp = a3.X*a1.Y + a2.X*a2.Y + a1.X*a3.Y;
        c[4].X = temp*A.X;
        c[4].Y = temp*A.Y;

        temp = a3.X*a0.Y + a2.X*a1.Y + a1.X*a2.Y + a0.X*a3.Y;
        c[3].X = temp*A.X + a3.X*B.X + a3.Y*C.X;
        c[3].Y = temp*A.Y + a3.X*B.Y + a3.Y*C.Y;

        temp = a2.X*a0.Y + a1.X*a1.Y + a0.X*a2.Y;
        c[2].X = temp*A.X + a2.X*B.X + a2.Y*C.X;
        c[2].Y = temp*A.Y + a2.X*B.Y + a2.Y*C.Y;

        temp = a1.X*a0.Y + a0.X*a1.Y;
        c[1].X = temp*A.X + a1.X*B.X + a1.Y*C.X;
        c[1].Y = temp*A.Y + a1.X*B.Y + a1.Y*C.Y;

        temp = a0.X*a0.Y;
        c[0].X = temp*A.X + a0.X*B.X + a0.Y*C.X + D.X;
        c[0].Y = temp*A.Y + a0.X*B.Y + a0.Y*C.Y + D.Y;

        if(j == 0)
        {
            *data++ = c[0].X;
            *data++ = c[0].Y;
            j++;
        }

        *data++ = c[0].X + c[1].X/6;
        *data++ = c[0].Y + c[1].Y/6;

        *data++ = c[0].X + c[1].X/3 + c[2].X/15;
        *data++ = c[0].Y + c[1].Y/3 + c[2].Y/15;

        *data++ = c[0].X + c[1].X/2 + c[2].X/5 + c[3].X/20;
        *data++ = c[0].Y + c[1].Y/2 + c[2].Y/5 + c[3].Y/20;

        *data++ = c[0].X + 2*c[1].X/3 + 2*c[2].X/5 + c[3].X/5 + c[4].X/15;
        *data++ = c[0].Y + 2*c[1].Y/3 + 2*c[2].Y/5 + c[3].Y/5 + c[4].Y/15;
        
        *data++ = c[0].X + 5*c[1].X/6 + 2*c[2].X/3 + c[3].X/2 + c[4].X/3 + c[5].X/6;
        *data++ = c[0].Y + 5*c[1].Y/6 + 2*c[2].Y/3 + c[3].Y/2 + c[4].Y/3 + c[5].Y/6;
        
        *data++ = c[0].X + c[1].X + c[2].X + c[3].X + c[4].X + c[5].X + c[6].X;
        *data++ = c[0].Y + c[1].Y + c[2].Y + c[3].Y + c[4].Y + c[5].Y + c[6].Y;

        j += 6;    
    }

    return Ok;
}


/**************************************************************************\
*
*     P0         P1
*     ------------
*     |           \
*     |            \
*     |             \
*     |              \
*     ----------------\
*     P2              P3
*
\**************************************************************************/

GpPerspectiveTransform::GpPerspectiveTransform(
    const GpRectF& rect,
    const GpPointF* pts,
    INT count
    )
{
    ASSERT(count == 3 || count == 4)
    
    SrcRect = rect;

    REAL left, right, top, bottom;

    left = right = pts[0].X;
    top = bottom = pts[0].Y;

    for(INT i = 1; i < count; i++)
    {
        if(pts[i].X < left)
            left = pts[i].X;
        else if(pts[i].X > right)
            right = pts[i].X;

        if(pts[i].Y < top)
            top = pts[i].Y;
        else if(pts[i].Y > bottom)
            bottom = pts[i].Y;
    }

    if(count == 4)
    {
        REAL dx1, dx2, dy1, dy2;
        REAL sx, sy, det;

        dx1 = pts[1].X - pts[3].X;
        dy1 = pts[1].Y - pts[3].Y;
        dx2 = pts[2].X - pts[3].X;
        dy2 = pts[2].Y - pts[3].Y;
        sx = pts[0].X - pts[1].X - pts[2].X + pts[3].X;
        sy = pts[0].Y - pts[1].Y - pts[2].Y + pts[3].Y;
        det = dx1*dy2 - dy1*dx2;
        M02 = (sx*dy2 - sy*dx2)/det;
        M12 = (dx1*sy - dy1*sx)/det;
    }
    else
    {
        // This is a palallelogram.

        M02 = 0;
        M12 = 0;

        // Obtain the fourth vertex.

        REAL x3 = pts[1].X + pts[2].X - pts[0].X;
        REAL y3 = pts[1].Y + pts[2].Y - pts[0].Y;

        if(x3 < left)
            left = x3;
        else if(x3 > right)
            right = x3;

        if(y3 < top)
            top = y3;
        else if(y3 > bottom)
            bottom = y3;
    }

    M00 = pts[1].X - pts[0].X + M02*pts[1].X;
    M01 = pts[1].Y - pts[0].Y + M02*pts[1].Y;
    M10 = pts[2].X - pts[0].X + M12*pts[2].X;
    M11 = pts[2].Y - pts[0].Y + M12*pts[2].Y;
    M20 = pts[0].X;
    M21 = pts[0].Y;
    M22 = 1;

    DstBounds.X = left;
    DstBounds.Y = top;
    DstBounds.Width = right - left;
    DstBounds.Height = bottom - top;
}


/**************************************************************************\
*
* This converts the points to the perspective points
*
* [IN] points:  the point data
* [IN] count:   the number of points.
* [OUT] q:      the perspective point data.
*
* The array size of q must be larger than or equal to count.
*
\**************************************************************************/

GpStatus
GpPerspectiveTransform::ConvertPoints(
    const GpPointF* points,
    INT count,
    GpPoint3F* q
    )
{
    ASSERT(points && q);
    ASSERT(count > 0);

    const GpPointF* pts = points;
    GpPoint3F* qPts = q;

    while(count > 0)
    {
        REAL u, v;

        u = (pts->X - SrcRect.X)/SrcRect.Width;
        v = (pts->Y - SrcRect.Y)/SrcRect.Height;

        qPts->X = u*M00 + v*M10 + M20;
        qPts->Y = u*M01 + v*M11 + M21;
        qPts->Z = u*M02 + v*M12 + 1;

        pts++;
        qPts++;
        count--;
    }

    return Ok;
}
    

/**************************************************************************\
*
* This converts the points to the perspective points
*
* [IN] points:  the point data
* [IN] count:   the number of points.
* [OUT] xpoints: the perspective point data.
*
*
\**************************************************************************/

GpStatus
GpPerspectiveTransform::ConvertPoints(
    const GpPointF* points,
    INT count,
    GpXPoints* xpoints
    )
{

    ASSERT(points && xpoints && count > 0);
    
    if(!points || !xpoints || count <= 0)
        return InvalidParameter;

    REALD* data = xpoints->Data;
/*
    REALD* data = (REALD*) GpMalloc(3*count*sizeof(REALD));


    if(!data)
        return OutOfMemory;

    // Use this data for xpoints.

    xpoints->SetData(data, 3, count, FALSE);
*/
 
    const GpPointF* pts = points;

    while(count > 0)
    {
        REAL u, v;

        u = (pts->X - SrcRect.X)/SrcRect.Width;
        v = (pts->Y - SrcRect.Y)/SrcRect.Height;

        *data++ = u*M00 + v*M10 + M20;
        *data++ = u*M01 + v*M11 + M21;
        *data++ = u*M02 + v*M12 + 1;

        pts++;
        count--;
    }

    return Ok;
}


class GpQuadData
{
    GpBilinearTransform BLTransform;
    GpQuadData();
    GpStatus SetQuad(
        const GpRectF& rect,
        const GpPointF* points
        );

    GpStatus OutputSpan(ARGB* buffer, INT compositingMode,
                INT y, INT &xMin, INT &xMax);
};

GpStatus
GpQuadData::SetQuad(
    const GpRectF& rect,
    const GpPointF* points
    )
{
    return BLTransform.SetBilinearTransform(rect, points, 4);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\entry\region.hpp ===
/**************************************************************************\
*
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   Region.hpp
*
* Abstract:
*
*   Region API related declarations
*
* Created:
*
*   2/3/1999 DCurtis
*
\**************************************************************************/

#ifndef _REGION_HPP
#define _REGION_HPP

// Specifies that a RegionData node is a leaf node, rather than a node that
// combines 2 children nodes.
#define REGIONTYPE_LEAF     0x10000000

// A RegionData node can be empty or infinite or it can contain a rect,
// a path, or two children nodes (left and right) that are combined with a
// boolean operator.  Children nodes are specified by their index into the
// dynamic array called CombineData of GpRegion.
struct RegionData
{
friend class GpRegion;

public:
    enum NodeType
    {
        TypeAnd        = CombineModeIntersect,
        TypeOr         = CombineModeUnion,
        TypeXor        = CombineModeXor,
        TypeExclude    = CombineModeExclude,
        TypeComplement = CombineModeComplement,
        TypeRect       = REGIONTYPE_LEAF | 0,
        TypePath       = REGIONTYPE_LEAF | 1,
        TypeEmpty      = REGIONTYPE_LEAF | 2,
        TypeInfinite   = REGIONTYPE_LEAF | 3,
        TypeNotValid   = 0xFFFFFFFF,
    };

protected:
    NodeType            Type;

    union
    {
        struct      // rect data (can't be GpRectF cause of constructor)
        {
            REAL        X;
            REAL        Y;
            REAL        Width;
            REAL        Height;
        };
        struct
        {
            GpPath *    Path;   // copy of path
            BOOL        Lazy;   // if the path is a lazy copy or not
        };
        struct
        {
            INT         Left;   // index of left child
            INT         Right;  // index of right child
        };
    };
};

typedef DynArray<RegionData> DynRegionDataArray;

class GpRegion : public GpObject, public RegionData
{
friend class GpGraphics;
protected:
    mutable GpLockable  Lockable;
    mutable BOOL        RegionOk;       // if DeviceRegion is valid
    mutable DpRegion    DeviceRegion;   // region coverage, in device units
    mutable GpMatrix    Matrix;         // last matrix used for DeviceRegion

    DynRegionDataArray  CombineData;    // combined region data, if any

protected:
    VOID SetValid(BOOL valid)
    {
        GpObject::SetValid(valid ? ObjectTagRegion : ObjectTagInvalid);
    }

protected:
    // doesn't change the region itself, just the device region
    GpStatus 
    UpdateDeviceRegion(
        GpMatrix *          matrix
        ) const;

    // doesn't change the region itself, just the device region
    GpStatus 
    CreateLeafDeviceRegion(
        const RegionData *  regionData,
        DpRegion *          region
        ) const;

    // doesn't change the region itself, just the device region
    GpStatus 
    CreateDeviceRegion(
        const RegionData *  regionData,
        DpRegion *          region
        ) const;

    GpStatus
    TransformLeaf(
        GpMatrix *          matrix,
        RegionData *        data
        );

    INT
    GetRegionDataSize(
        const RegionData *  regionData
        ) const;
        
    GpStatus
    GetRegionData(
        IStream *               stream,
        const RegionData *      regionData
        ) const;

    GpStatus
    SetRegionData(
        const BYTE * &  regionDataBuffer,
        UINT &          regionDataSize,
        RegionData *    regionData,
        RegionData *    regionDataArray,
        INT &           nextArrayIndex,
        INT             arraySize
        );

public:
    GpRegion();
    GpRegion(const GpRectF * rect);
    GpRegion(const GpPath * path);
    GpRegion(const GpRegion * region, BOOL lazy = FALSE);
    GpRegion(const BYTE * regionDataBuffer, UINT size);
    GpRegion(HRGN hRgn);
    ~GpRegion();

    virtual BOOL IsValid() const 
    { 
        // If the region came from a different version of GDI+, its tag
        // will not match, and it won't be considered valid.
        return ((Type != TypeNotValid) && GpObject::IsValid(ObjectTagRegion));
    }

    VOID FreePathData();

    GpLockable *GetObjectLock()      // Get the lock object
    {
        return &Lockable;
    }

    virtual ObjectType GetObjectType() const { return ObjectTypeRegion; }
    virtual UINT GetDataSize() const;
    virtual GpStatus GetData(IStream * stream) const;
    virtual GpStatus SetData(const BYTE * dataBuffer, UINT size);

    VOID Set(const GpRectF * rect)
    {
        Set(rect->X, rect->Y, rect->Width, rect->Height);
    }
    VOID Set(REAL x, REAL y, REAL width, REAL height);
    GpStatus Set(const GpPath * path);
    GpStatus Set(const GpRegion * region, BOOL lazy = FALSE);
    GpStatus Set(
        const BYTE *    regionDataBuffer,   // NULL means set to empty
        UINT            regionDataSize
        );

    VOID SetInfinite();
    VOID SetEmpty();

    GpStatus GetBounds(GpGraphics * graphics, GpRectF * bounds,
                       BOOL device = FALSE) const;
    GpStatus GetBounds(GpMatrix * matrix, GpRect *  bounds) const;

    GpStatus GetHRgn(GpGraphics * graphics, HRGN * hRgn) const;

    GpStatus GetRegionScans(GpRect  *rects, INT *count, const GpMatrix *matrix) const;
    GpStatus GetRegionScans(GpRectF *rects, INT *count, const GpMatrix *matrix) const;

    GpStatus IsVisible(GpPointF * point,  GpMatrix * matrix, BOOL * isVisible) const;
    GpStatus IsVisible(GpRectF * rect,    GpMatrix * matrix, BOOL * isVisible) const;
    GpStatus IsVisible(GpRegion * region, GpMatrix * matrix, BOOL * isVisible) const;

    GpStatus IsEmpty   (GpMatrix * matrix, BOOL * isEmpty) const;
    GpStatus IsInfinite(GpMatrix * matrix, BOOL * isInfinite) const;
    GpStatus IsEqual   (GpRegion * region, GpMatrix * matrix, BOOL * isEqual) const;
    BOOL     IsOnePath () const
    {
        ASSERT(IsValid());
    
        return ((Type & REGIONTYPE_LEAF) != 0);
    }
    BOOL     IsRect () const
    {
        return (IsOnePath() && (Type != TypePath));
    }
    const GpPath * GetPath() const
    {
        ASSERT(Type == TypePath);
        return Path;
    }

    GpStatus Transform(GpMatrix * matrix);
    GpStatus Offset   (REAL xOffset, REAL yOffset);

    GpStatus Combine(
        const GpRectF *     rect,
        CombineMode         combineMode
        );

    GpStatus Combine(
        const GpPath *      path,
        CombineMode         combineMode
        );

    GpStatus Combine(
        GpRegion *          region,
        CombineMode         combineMode
        );

    GpStatus And (GpRectF * rect)
    {
        return Combine (rect, CombineModeIntersect);
    }

    GpStatus And (GpPath * path)
    {
        return Combine (path, CombineModeIntersect);
    }

    GpStatus And (GpRegion * region)
    {
        return Combine (region, CombineModeIntersect);
    }

    GpStatus Or (GpRectF * rect)
    {
        return Combine (rect, CombineModeUnion);
    }

    GpStatus Or (GpPath * path)
    {
        return Combine (path, CombineModeUnion);
    }

    GpStatus Or (GpRegion * region)
    {
        return Combine (region, CombineModeUnion);
    }

    GpStatus Xor (GpRectF * rect)
    {
        return Combine (rect, CombineModeXor);
    }

    GpStatus Xor (GpPath * path)
    {
        return Combine (path, CombineModeXor);
    }

    GpStatus Xor (GpRegion * region)
    {
        return Combine (region, CombineModeXor);
    }

    GpStatus Exclude (GpRectF * rect)
    {
        return Combine (rect, CombineModeExclude);
    }

    GpStatus Exclude (GpPath * path)
    {
        return Combine (path, CombineModeExclude);
    }

    GpStatus Exclude (GpRegion * region)
    {
        return Combine (region, CombineModeExclude);
    }

    GpStatus Complement (GpRectF * rect)
    {
        return Combine (rect, CombineModeComplement);
    }

    GpStatus Complement (GpPath * path)
    {
        return Combine (path, CombineModeComplement);
    }

    GpStatus Complement (GpRegion * region)
    {
        return Combine (region, CombineModeComplement);
    }

};

#endif _REGION_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\entry\quadtransforms.hpp ===
/**************************************************************************\
* 
* Copyright (c) 1999  Microsoft Corporation
*
* Abstract:
*
*   Quad Transforms
*
* History:
*
*   03/17/1999 ikkof
*       Created it.
*
\**************************************************************************/

#ifndef _QUADTRAMSFOPRMS_HPP
#define _QUADTRAMSFOPRMS_HPP

//#define TEST_QUADTRANSFORMS

class GpXPoints;

class GpQuadAnalyzer
{
public:
    GpQuadAnalyzer() {Initialize();}
    VOID SetQuadAnalyzer(const GpPointF* points);
    INT GetXSpans(REAL* xSpans, REAL y);

protected:
    VOID Initialize()
    {
        Top = Bottom = Left = Right = 0;
        GpMemset(&Y1[0], 0, 4*sizeof(REAL));
        GpMemset(&Y2[0], 0, 4*sizeof(REAL));
        GpMemset(&Directions[0], 0, 4);
        GpMemset(&DxDy[0], 0, 4*sizeof(REAL));
    }

protected:
    REAL Top;
    REAL Bottom;
    REAL Left;
    REAL Right;

    REAL Y1[4];
    REAL Y2[4];
    BYTE Directions[4];
    REAL X1[4];
    REAL DxDy[4];
};

class GpBilinearTransform
{
protected:
    GpRectF SrcRect;
    GpRectF DstBounds;
    GpPointF A;
    GpPointF B;
    GpPointF C;
    GpPointF D;

    REAL C_VV;
    REAL C_V;

    GpQuadAnalyzer QAnalyzer;

    REAL FixedValue;   // Set to positive number if this transform
                       // represents a single fixed value over its
                       // entire area.

#ifdef TEST_QUADTRANSFORMS
    // For testing purpose only.

    GpPointF Verteces[4];

#endif

public:
    GpBilinearTransform() {Initialize();}
    GpBilinearTransform(const GpRectF& rect, const GpPointF* points, INT count)
    {
        Initialize();
        SetBilinearTransform(rect, points, count);
    }

    GpStatus ConvertLines(const GpPointF* points, INT count, GpPointF* q);
    GpStatus ConvertLines(const GpPointF* points, INT count, REALD* data);
    GpStatus ConvertCubicBeziers(const GpPointF* srcQ, INT count, GpPointF* q);
    GpStatus ConvertCubicBeziers(const GpPointF* srcQ, INT count, REALD* data);
    GpStatus SetBilinearTransform(const GpRectF& rect, const GpPointF* points, INT count, REAL fixed=-1.0f);
    INT GetSourceParameterArrays(
            REAL* u,
            REAL* v,
            INT* xSpans,
            INT y,
            INT xmin,
            INT xmax
            );

protected:
    VOID Initialize();
    INT GetXSpans(INT* xSpans, INT y, INT xmin, INT xmax);
    BOOL GetSourceParameter(REAL* u, REAL* v, const GpPointF& point);
};

class GpPerspectiveTransform
{
protected:
    GpRectF SrcRect;
    GpRectF DstBounds;
    REAL M00, M01, M02;
    REAL M10, M11, M12;
    REAL M20, M21, M22;

public:
    GpPerspectiveTransform(const GpRectF& rect, const GpPointF* points, INT count);
    GpStatus ConvertPoints(const GpPointF* points, INT count, GpPoint3F* q);
    GpStatus ConvertPoints(const GpPointF* points, INT count, GpXPoints* xpoints);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\entry\region.cpp ===
/**************************************************************************\
*
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   Region.cpp
*
* Abstract:
*
*   Implementation of GpRegion class
*
* Created:
*
*   2/3/1999 DCurtis
*
\**************************************************************************/

#include "precomp.hpp"

#define COMBINE_STEP_SIZE   4   // takes 2 for each combine operation

LONG_PTR GpObject::Uniqueness = (0xdbc - 1);   // for setting Uid of Objects

/**************************************************************************\
*
* Function Description:
*
*   Default constructor.  Sets the default state of the region to
*   be infinite.
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   NONE
*
* Created:
*
*   2/3/1999 DCurtis
*
\**************************************************************************/
GpRegion::GpRegion()
{
    SetValid(TRUE);     // default is valid

    // Default is infinite
    RegionOk = TRUE;

    Type = TypeInfinite;
}

/**************************************************************************\
*
* Function Description:
*
*   Constructor.  Sets the region to the specified rect.
*
* Arguments:
*
*   [IN] rect - rect to initialize the region to
*
* Return Value:
*
*   NONE
*
* Created:
*
*   2/3/1999 DCurtis
*
\**************************************************************************/
GpRegion::GpRegion(
    const GpRectF *       rect
    )
{
    ASSERT(rect != NULL);

    SetValid(TRUE);     // default is valid

    RegionOk = FALSE;

    X      = rect->X;
    Y      = rect->Y;
    Width  = rect->Width;
    Height = rect->Height;
    Type   = TypeRect;
}

/**************************************************************************\
*
* Function Description:
*
*   Constructor.  Sets the region to a copy of the specified path.
*
* Arguments:
*
*   [IN] path - path to initialize the region to
*
* Return Value:
*
*   NONE
*
* Created:
*
*   2/3/1999 DCurtis
*
\**************************************************************************/
GpRegion::GpRegion(
    const GpPath *          path
    )
{
    ASSERT(path != NULL);

    SetValid(TRUE);     // default is valid

    RegionOk = FALSE;

    Lazy = FALSE;
    Path = path->Clone();
    Type = (Path != NULL) ? TypePath : TypeNotValid;
}

/**************************************************************************\
*
* Function Description:
*
*   Constructor.  Sets the region using the specified region data buffer.
*
* Arguments:
*
*   [IN] regionDataBuffer - should contain data that describes the region
*
* Return Value:
*
*   NONE
*
* Created:
*
*   9/3/1999 DCurtis
*
\**************************************************************************/
GpRegion::GpRegion(
    const BYTE *    regionDataBuffer,
    UINT            size
    )
{
    ASSERT(regionDataBuffer != NULL);

    SetValid(TRUE);     // default is valid

    RegionOk = FALSE;
    Type     = TypeEmpty;   // so FreePathData works correctly

    if (this->SetExternalData(regionDataBuffer, size) != Ok)
    {
        Type = TypeNotValid;
    }
}

/**************************************************************************\
*
* Function Description:
*
*   Constructor.  Sets the region to a copy of the specified path.
*
* Arguments:
*
*   [IN] region - region to initialize the region to
*
* Return Value:
*
*   NONE
*
* Created:
*
*   2/3/1999 DCurtis
*
\**************************************************************************/
GpRegion::GpRegion(
    const GpRegion *    region,
    BOOL                lazy
    )
{
    SetValid(TRUE);     // default is valid

    RegionOk = FALSE;

    // We set the type here to avoid the assert in GpRegion::Set when the
    // uninitialized Type is equal to TypeNotValid
    Type = TypeEmpty;

    Set(region, lazy);
}

/**************************************************************************\
*
* Function Description:
*
*   Destructor.  Frees any copied path data associated with the region.
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   NONE
*
* Created:
*
*   2/3/1999 DCurtis
*
\**************************************************************************/
GpRegion::~GpRegion()
{
    FreePathData();
}

/**************************************************************************\
*
* Function Description:
*
*   When a region is created from a path, a copy of that path is stored in
*   the region.  This method frees up any of those copies that have been
*   saved in the region.
*
*   It also resets the CombineData back to having no children.
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   NONE
*
* Created:
*
*   2/3/1999 DCurtis
*
\**************************************************************************/
VOID
GpRegion::FreePathData()
{
    if (Type == TypePath)
    {
        if (!Lazy)
        {
            delete Path;
        }
    }
    else
    {
        INT     count = CombineData.GetCount();

        if (count > 0)
        {
            RegionData *    data = CombineData.GetDataBuffer();
            ASSERT (data != NULL);

            do
            {
                if ((data->Type == TypePath) && (!data->Lazy))
                {
                    delete data->Path;
                }
                data++;

            } while (--count > 0);
        }
        CombineData.Reset();
    }
}

/**************************************************************************\
*
* Function Description:
*
*   Set the region to the specified rectangle.
*
* Arguments:
*
*   [IN]  rect - the rect, in world units
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   2/3/1999 DCurtis
*
\**************************************************************************/
VOID
GpRegion::Set(
    REAL    x, 
    REAL    y, 
    REAL    width, 
    REAL    height
    )
{
    ASSERT(IsValid());

    // handle flipped rects
    if (width < 0)
    {
        x += width;
        width = -width;
    }
    
    if (height < 0)
    {
        y += height;
        height = -height;
    }

    // crop to infinity
    if (x < INFINITE_MIN)
    {
        if (width < INFINITE_SIZE)
        {
            width -= (INFINITE_MIN - x);
        }
        x = INFINITE_MIN;
    }
    if (y < INFINITE_MIN)
    {
        if (height < INFINITE_SIZE)
        {
            height -= (INFINITE_MIN - y);
        }
        y = INFINITE_MIN;
    }

    if ((width > REAL_EPSILON) && (height > REAL_EPSILON))
    {
        if (width >= INFINITE_SIZE)
        {
            if (height >= INFINITE_SIZE)
            {
                SetInfinite();
                return;
            }
            width = INFINITE_SIZE;  // crop to infinite
        }
        else if (height > INFINITE_SIZE)
        {
            height = INFINITE_SIZE; // crop to infinite
        }

        UpdateUid();
        if (RegionOk)
        {
            RegionOk = FALSE;
            DeviceRegion.SetEmpty();
        }
        FreePathData();

        X      = x;
        Y      = y;
        Width  = width;
        Height = height;
        Type   = TypeRect;

        return;
    }
    else
    {
        SetEmpty();
    }
}

/**************************************************************************\
*
* Function Description:
*
*   Set the region to be infinite.
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   2/9/1999 DCurtis
*
\**************************************************************************/
VOID
GpRegion::SetInfinite()
{
    ASSERT(IsValid());

    UpdateUid();
    DeviceRegion.SetInfinite();
    RegionOk = TRUE;

    FreePathData();

    X      = INFINITE_MIN;
    Y      = INFINITE_MIN;
    Width  = INFINITE_SIZE;
    Height = INFINITE_SIZE;
    Type   = TypeInfinite;

    return;
}

/**************************************************************************\
*
* Function Description:
*
*   Set the region to be empty.
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   2/9/1999 DCurtis
*
\**************************************************************************/
VOID
GpRegion::SetEmpty()
{
    ASSERT(IsValid());

    UpdateUid();
    DeviceRegion.SetEmpty();
    RegionOk = TRUE;

    FreePathData();

    X      = 0;
    Y      = 0;
    Width  = 0;
    Height = 0;
    Type   = TypeEmpty;

    return;
}

/**************************************************************************\
*
* Function Description:
*
*   Set the region to the specified path.
*
* Arguments:
*
*   [IN]  path - the path, in world units
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   2/3/1999 DCurtis
*
\**************************************************************************/
GpStatus
GpRegion::Set(
    const GpPath *      path
    )
{
    ASSERT(IsValid());
    ASSERT(path != NULL);

    UpdateUid();
    if (RegionOk)
    {
        RegionOk = FALSE;
        DeviceRegion.SetEmpty();
    }
    FreePathData();

    Lazy = FALSE;
    Path = path->Clone();
    if (Path != NULL)
    {
        Type = TypePath;
        return Ok;
    }
    Type = TypeNotValid;
    return GenericError;
}

/**************************************************************************\
*
* Function Description:
*
*   Set the region to be a copy of the specified region.
*
* Arguments:
*
*   [IN]  region - the region to copy
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   2/3/1999 DCurtis
*
\**************************************************************************/
GpStatus
GpRegion::Set(
    const GpRegion *    region,
    BOOL                lazy
    )
{
    ASSERT(IsValid());
    ASSERT((region != NULL) && (region->IsValid()));

    if (region == this)
    {
        return Ok;
    }

    UpdateUid();
    if (RegionOk)
    {
        RegionOk = FALSE;
        DeviceRegion.SetEmpty();
    }
    FreePathData();

    if ((region->Type & REGIONTYPE_LEAF) != 0)
    {
        *this = *(const_cast<GpRegion *>(region));
        if (Type == TypePath)
        {
            if (!lazy)
            {
                Lazy = FALSE;
                if ((Path = Path->Clone()) == NULL)
                {
                    Type = TypeNotValid;
                    return GenericError;
                }
            }
            else    // lazy copy
            {
                Lazy = TRUE;
            }
        }
        return Ok;
    }
    else
    {
        INT     count = region->CombineData.GetCount();

        ASSERT(count > 0);

        Type = TypeNotValid;

        RegionData *    data = CombineData.AddMultiple(count);
        if (data != NULL)
        {
            BOOL    error = FALSE;

            GpMemcpy (data, region->CombineData.GetDataBuffer(),
                      count * sizeof(*data));

            while (count--)
            {
                if (data->Type == TypePath)
                {
                    if (!lazy)
                    {
                        data->Lazy = FALSE;
                        if ((data->Path = data->Path->Clone()) == NULL)
                        {
                            data->Type = TypeNotValid;
                            error = TRUE;
                            // don't break out or else FreePathData will free
                            // paths that don't belong to us.
                        }
                    }
                    else    // lazy copy
                    {
                        data->Lazy = TRUE;
                    }
                }
                data++;
            }
            if (!error)
            {
                Type  = region->Type;
                Left  = region->Left;
                Right = region->Right;
                return Ok;
            }
            FreePathData();
        }
    }
    return GenericError;
}

/**************************************************************************\
*
* Function Description:
*
*   Combine the region with the specified rect, using the boolean
*   operator specified by the type.
*
* Arguments:
*
*   [IN]  rect        - the rect to combine with the current region
*   [IN]  combineMode - the combine operator (and, or, xor, exclude, complement)
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   2/3/1999 DCurtis
*
\**************************************************************************/
GpStatus
GpRegion::Combine(
    const GpRectF *     rect,
    CombineMode         combineMode
    )
{
    ASSERT(IsValid());
    ASSERT(rect != NULL);
    ASSERT(CombineModeIsValid(combineMode));

    if (combineMode == CombineModeReplace)
    {
        this->Set(rect);
        return Ok;
    }

    if (Type == TypeInfinite)
    {
        if (combineMode == CombineModeIntersect)
        {
            this->Set(rect);
            return Ok;
        }
        else if (combineMode == CombineModeUnion)
        {
            return Ok;  // nothing to do, already infinite
        }
        else if (combineMode == CombineModeComplement)
        {
            this->SetEmpty();
            return Ok;
        }
    }
    else if (Type == TypeEmpty)
    {
        if ((combineMode == CombineModeUnion) ||
            (combineMode == CombineModeXor)   ||
            (combineMode == CombineModeComplement))
        {
            this->Set(rect);
        }
        // if combineMode is Intersect or Exclude, just leave it empty
        return Ok;
    }

    // Now we know this region is not empty
    
    REAL    x      = rect->X;
    REAL    y      = rect->Y;
    REAL    width  = rect->Width;
    REAL    height = rect->Height;
    
    // handle flipped rects
    if (width < 0)
    {
        x += width;
        width = -width;
    }
    
    if (height < 0)
    {
        y += height;
        height = -height;
    }

    // crop to infinity
    if (x < INFINITE_MIN)
    {
        if (width < INFINITE_SIZE)
        {
            width -= (INFINITE_MIN - x);
        }
        x = INFINITE_MIN;
    }
    if (y < INFINITE_MIN)
    {
        if (height < INFINITE_SIZE)
        {
            height -= (INFINITE_MIN - y);
        }
        y = INFINITE_MIN;
    }

    BOOL    isEmptyRect = ((width <= REAL_EPSILON) || (height <= REAL_EPSILON));
    
    if (isEmptyRect)
    {
        if ((combineMode == CombineModeIntersect) ||
            (combineMode == CombineModeComplement))
        {
            SetEmpty();
        }
        // if combineMode is Union or Xor or Exclude, just leave it alone
        return Ok;
    }

    // Now we know the rect is not empty

    // See if the rect is infinite
    if (width >= INFINITE_SIZE)
    {
        if (height >= INFINITE_SIZE)
        {
            GpRegion    infiniteRegion;
            return this->Combine(&infiniteRegion, combineMode);
        }
        width = INFINITE_SIZE;  // crop to infinite
    }
    else if (height > INFINITE_SIZE)
    {
        height = INFINITE_SIZE; // crop to infinite
    }

    // The rect is neither infinite nor empty    

    UpdateUid();
    if (RegionOk)
    {
        RegionOk = FALSE;
        DeviceRegion.SetEmpty();
    }

    INT                 index = CombineData.GetCount();
    RegionData *        data  = CombineData.AddMultiple(2);

    if (data != NULL)
    {
        data[0] = *this;

        data[1].Type   = TypeRect;
        data[1].X      = x;
        data[1].Y      = y;
        data[1].Width  = width;
        data[1].Height = height;

        Type  = (NodeType)combineMode;
        Left  = index;
        Right = index + 1;
        return Ok;
    }

    FreePathData();
    Type = TypeNotValid;
    return GenericError;
}

/**************************************************************************\
*
* Function Description:
*
*   Combine the region with the specified path, using the boolean
*   operator specified by the type.
*
* Arguments:
*
*   [IN]  path        - the path to combine with the current region
*   [IN]  combineMode - the combine operator (and, or, xor, exclude, complement)
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   2/3/1999 DCurtis
*
\**************************************************************************/
GpStatus
GpRegion::Combine(
    const GpPath *      path,
    CombineMode         combineMode
    )
{
    ASSERT(IsValid());
    ASSERT(path != NULL);
    ASSERT(CombineModeIsValid(combineMode));

    if (combineMode == CombineModeReplace)
    {
        return this->Set(path);
    }

    if (Type == TypeInfinite)
    {
        if (combineMode == CombineModeIntersect)
        {
            this->Set(path);
            return Ok;
        }
        else if (combineMode == CombineModeUnion)
        {
            return Ok;  // nothing to do, already infinite
        }
        else if (combineMode == CombineModeComplement)
        {
            this->SetEmpty();
            return Ok;
        }
    }
    else if (Type == TypeEmpty)
    {
        if ((combineMode == CombineModeUnion) ||
            (combineMode == CombineModeXor)   ||
            (combineMode == CombineModeComplement))
        {
            this->Set(path);
        }
        // if combineMode is Intersect or Exclude, just leave it empty
        return Ok;
    }

    // Now we know this region is not empty

    if (RegionOk)
    {
        RegionOk = FALSE;
        DeviceRegion.SetEmpty();
    }

    GpPath *    pathCopy = path->Clone();
    if (pathCopy != NULL)
    {
        INT                 index = CombineData.GetCount();
        RegionData *        data  = CombineData.AddMultiple(2);

        if (data != NULL)
        {
            data[0] = *this;

            data[1].Type = TypePath;
            data[1].Lazy = FALSE;
            data[1].Path = pathCopy;

            Type  = (NodeType)combineMode;
            Left  = index;
            Right = index + 1;
            UpdateUid();
            return Ok;
        }
        delete pathCopy;
    }
    FreePathData();
    Type = TypeNotValid;
    return GenericError;
}

/**************************************************************************\
*
* Function Description:
*
*   Combine the region with the specified region, using the boolean
*   operator specified by the type.
*
* Arguments:
*
*   [IN]  region      - the region to combine with the current region
*   [IN]  combineMode - the combine operator (and, or, xor, exclude, complement)
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   2/3/1999 DCurtis
*
\**************************************************************************/
GpStatus
GpRegion::Combine(
    GpRegion *          region,
    CombineMode         combineMode
    )
{
    ASSERT(IsValid());
    ASSERT((region != NULL) && region->IsValid());
    ASSERT(CombineModeIsValid(combineMode));

    if (combineMode == CombineModeReplace)
    {
        return this->Set(region);
    }

    if (region->Type == TypeEmpty)
    {
        if ((combineMode == CombineModeIntersect) ||
            (combineMode == CombineModeComplement))
        {
            SetEmpty();
        }
        // if combineMode is Union or Xor or Exclude, just leave it alone
        return Ok;
    }

    // Now we know the input region is not empty

    if (region->Type == TypeInfinite)
    {
        if (combineMode == CombineModeIntersect)
        {
            return Ok;
        }
        else if (combineMode == CombineModeUnion)
        {
            SetInfinite();
            return Ok;
        }
        else if ((combineMode == CombineModeXor) ||
                 (combineMode == CombineModeComplement))
        {
            if (Type == TypeInfinite)
            {
                SetEmpty();
                return Ok;
            }
        }
        if (combineMode == CombineModeExclude)
        {
            SetEmpty();
            return Ok;
        }
    }

    if (Type == TypeInfinite)
    {
        if (combineMode == CombineModeIntersect)
        {
            this->Set(region);
            return Ok;
        }
        else if (combineMode == CombineModeUnion)
        {
            return Ok;  // nothing to do, already infinite
        }
        else if (combineMode == CombineModeComplement)
        {
            this->SetEmpty();
            return Ok;
        }
    }
    else if (Type == TypeEmpty)
    {
        if ((combineMode == CombineModeUnion) ||
            (combineMode == CombineModeXor)   ||
            (combineMode == CombineModeComplement))
        {
            this->Set(region);
        }
        // if combineMode is Intersect or Exclude, just leave it empty
        return Ok;
    }

    // Now we know this region is not empty

    if (RegionOk)
    {
        RegionOk = FALSE;
        DeviceRegion.SetEmpty();
    }

    INT                 regionCount = region->CombineData.GetCount();
    INT                 index = CombineData.GetCount();
    RegionData *        data  = CombineData.AddMultiple(2 + regionCount);

    if (data != NULL)
    {
        data[regionCount]     = *this;
        data[regionCount + 1] = *region;

        if (regionCount > 0)
        {
            RegionData *    srcData = region->CombineData.GetDataBuffer();
            INT             i       = 0;
            BOOL            error   = FALSE;
            GpPath *        path;

            do
            {
                data[i] = srcData[i];
                if ((data[i].Type & REGIONTYPE_LEAF) == 0)
                {
                    data[i].Left  += index;
                    data[i].Right += index;
                }
                else if (data[i].Type == TypePath)
                {
                    data[i].Lazy = FALSE;
                    path = data[i].Path->Clone();
                    data[i].Path = path;
                    if (path == NULL)
                    {
                        data[i].Type = TypeNotValid;
                        error = TRUE;
                        // don't break out
                    }
                }

            } while (++i < regionCount);
            data[regionCount+1].Left  += index;
            data[regionCount+1].Right += index;
            index += regionCount;
            if (error)
            {
                goto ErrorExit;
            }
        }
        else if (region->Type == TypePath)
        {
            data[1].Lazy = FALSE;
            data[1].Path = region->Path->Clone();
            if (data[1].Path == NULL)
            {
                data[1].Type = TypeNotValid;
                goto ErrorExit;
            }
        }

        Type  = (NodeType)combineMode;
        Left  = index;
        Right = index + 1;
        UpdateUid();
        return Ok;
    }
ErrorExit:
    FreePathData();
    Type = TypeNotValid;
    return GenericError;
}

GpStatus
GpRegion::CreateLeafDeviceRegion(
    const RegionData *  regionData,
    DpRegion *          region
    ) const
{
    GpStatus        status = GenericError;

    switch (regionData->Type)
    {
      case TypeRect:
        if ((regionData->Width > 0) &&
            (regionData->Height > 0))
        {
            // If the transform is a simple scaling transform, life is a
            // little easier:
            if (Matrix.IsTranslateScale())
            {
                GpRectF     rect(regionData->X,
                                 regionData->Y,
                                 regionData->Width,
                                 regionData->Height);

                Matrix.TransformRect(rect);

                // Use ceiling to stay compatible with rasterizer
                // Don't take the ceiling of the width directly,
                // because it introduces additional round-off error.
                // For example, if rect.X is 1.7 and rect.Width is 47.2,
                // then if we took the ceiling of the width, the right
                // coordinate will end up being 50, instead of 49.
                INT     xMin = RasterizerCeiling(rect.X);
                INT     yMin = RasterizerCeiling(rect.Y);
                INT     xMax = RasterizerCeiling(rect.GetRight());
                INT     yMax = RasterizerCeiling(rect.GetBottom());

                region->Set(xMin, yMin, xMax - xMin, yMax - yMin);
                status = Ok;
            }
            else
            {
                GpPointF    points[4];
                REAL        left;
                REAL        right;
                REAL        top;
                REAL        bottom;

                left   = regionData->X;
                top    = regionData->Y;
                right  = regionData->X + regionData->Width;
                bottom = regionData->Y + regionData->Height;

                points[0].X = left;
                points[0].Y = top;
                points[1].X = right;
                points[1].Y = top;
                points[2].X = right;
                points[2].Y = bottom;
                points[3].X = left;
                points[3].Y = bottom;

                const INT   stackCount = 4;
                GpPointF    stackPoints[stackCount];
                BYTE        stackTypes[stackCount];

                GpPath path(points,
                            4,
                            stackPoints,
                            stackTypes,
                            stackCount,
                            FillModeAlternate,
                            DpPath::Convex);

                if (path.IsValid())
                {
                    status = region->Set(&path, &Matrix);
                }
            }
        }
        else
        {
            region->SetEmpty();
            status = Ok;
        }
        break;

      case TypePath:
        status = region->Set(regionData->Path, &Matrix);
        break;

      case TypeEmpty:
        region->SetEmpty();
        status = Ok;
        break;

      case TypeInfinite:
        region->SetInfinite();
        status = Ok;
        break;

      default:
        ASSERT(0);
        break;
    }
    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   Creates a DpRegion (device coordinate region) using the data in the
*   specified RegionData node and using the current transformation matrix.
*   This may involve creating a region for children nodes and then combining
*   the children into a single device region.
*
* Arguments:
*
*   [IN]  regionData - the world coordinate region to convert to device region
*   [OUT] region     - the created/combined device region
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   2/3/1999 DCurtis
*
\**************************************************************************/
GpStatus
GpRegion::CreateDeviceRegion(
    const RegionData *  regionData,
    DpRegion *          region
    ) const
{
    ASSERT(IsValid());

    GpStatus        status;
    RegionData *    regionDataLeft;

    regionDataLeft  = &(CombineData[regionData->Left]);

    if ((regionDataLeft->Type & REGIONTYPE_LEAF) != 0)
    {
        status = CreateLeafDeviceRegion(regionDataLeft, region);
    }
    else
    {
        status = CreateDeviceRegion(regionDataLeft, region);
    }

    if (status == Ok)
    {
        DpRegion        regionRight;
        RegionData *    regionDataRight;

        regionDataRight = &(CombineData[regionData->Right]);

        if ((regionDataRight->Type & REGIONTYPE_LEAF) != 0)
        {
            status = CreateLeafDeviceRegion(regionDataRight, &regionRight);
        }
        else
        {
            status = CreateDeviceRegion(regionDataRight, &regionRight);
        }

        if (status == Ok)
        {
            switch (regionData->Type)
            {
              case TypeAnd:
                status = region->And(&regionRight);
                break;

              case TypeOr:
                status = region->Or(&regionRight);
                break;

              case TypeXor:
                status = region->Xor(&regionRight);
                break;

              case TypeExclude:
                status = region->Exclude(&regionRight);
                break;

              case TypeComplement:
                status = region->Complement(&regionRight);
                break;

              default:
                ASSERT(0);
                break;
            }
        }
    }
    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   Checks if the current DeviceRegion is up-to-date with the specified
*   matrix.  If not, then it recreates the DeviceRegion using the matrix.
*
* Arguments:
*
*   [IN]  matrix - the world-to-device transformation matrix
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   2/3/1999 DCurtis
*
\**************************************************************************/
GpStatus
GpRegion::UpdateDeviceRegion(
    GpMatrix *          matrix
    ) const
{
    ASSERT(IsValid());

    if (RegionOk && matrix->IsEqual(&Matrix))
    {
        return Ok;
    }
    Matrix = *matrix;

    GpStatus    status;

    if ((this->Type & REGIONTYPE_LEAF) != 0)
    {
        status = CreateLeafDeviceRegion(this, &DeviceRegion);
    }
    else
    {
        status = CreateDeviceRegion(this, &DeviceRegion);
    }
    RegionOk = (status == Ok);
    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   Get the bounds of the region, in world units.
*
* Arguments:
*
*   [IN]  matrix - world-to-device transformation matrix
*   [OUT] bounds - bounding rect of region, in world units
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   2/3/1999 DCurtis
*
\**************************************************************************/
GpStatus
GpRegion::GetBounds(
    GpGraphics *        graphics,
    GpRectF *           bounds,
    BOOL                device
    ) const
{
    ASSERT((graphics != NULL) && (bounds != NULL));
    ASSERT(IsValid() && graphics->IsValid());

    // Note we can't lock graphics, cause it gets locked in its calls

    GpStatus        status = Ok;

    switch (Type)
    {
      case TypeRect:
        if (!device)
        {
            bounds->X      = X;
            bounds->Y      = Y;
            bounds->Width  = Width;
            bounds->Height = Height;
        }
        else
        {
            GpMatrix    worldToDevice;

            graphics->GetWorldToDeviceTransform(&worldToDevice);

            TransformBounds(&worldToDevice, X, Y, X + Width, Y + Height,bounds);
        }
        break;

      case TypePath:
          {
            GpMatrix    worldToDevice;

            if (device)
            {
                graphics->GetWorldToDeviceTransform(&worldToDevice);
            }
            // else leave it as identity
            Path->GetBounds(bounds, &worldToDevice);
          }
        break;

      case TypeInfinite:
        bounds->X      = INFINITE_MIN;
        bounds->Y      = INFINITE_MIN;
        bounds->Width  = INFINITE_SIZE;
        bounds->Height = INFINITE_SIZE;
        break;

      case TypeAnd:
      case TypeOr:
      case TypeXor:
      case TypeExclude:
      case TypeComplement:
        {
            GpMatrix    worldToDevice;

            graphics->GetWorldToDeviceTransform(&worldToDevice);

            if (UpdateDeviceRegion(&worldToDevice) == Ok)
            {
                GpRect      deviceBounds;

                DeviceRegion.GetBounds(&deviceBounds);

                if (device)
                {
                    bounds->X      = TOREAL(deviceBounds.X);
                    bounds->Y      = TOREAL(deviceBounds.Y);
                    bounds->Width  = TOREAL(deviceBounds.Width);
                    bounds->Height = TOREAL(deviceBounds.Height);
                    break;
                }
                else
                {
                    GpMatrix    deviceToWorld;

                    if (graphics->GetDeviceToWorldTransform(&deviceToWorld)==Ok)
                    {
                        TransformBounds(
                                &deviceToWorld,
                                TOREAL(deviceBounds.X),
                                TOREAL(deviceBounds.Y),
                                TOREAL(deviceBounds.X + deviceBounds.Width),
                                TOREAL(deviceBounds.Y + deviceBounds.Height),
                                bounds);
                        break;
                    }
                }
            }
        }
        status = GenericError;
        // FALLTHRU

      default:  // TypeEmpty
        bounds->X      = 0;
        bounds->Y      = 0;
        bounds->Width  = 0;
        bounds->Height = 0;
        break;
    }
    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   Get the bounds of the region, in device units.
*
* Arguments:
*
*   [IN]  matrix - world-to-device transformation matrix
*   [OUT] bounds - bounding rect of region, in device units
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   2/3/1999 DCurtis
*
\**************************************************************************/
GpStatus
GpRegion::GetBounds(
    GpMatrix *          matrix,
    GpRect *            bounds
    ) const
{
    ASSERT(IsValid());
    ASSERT((matrix != NULL) && (bounds != NULL));

    GpStatus        status = Ok;

    switch (Type)
    {
      case TypeInfinite:
        bounds->X      = INFINITE_MIN;
        bounds->Y      = INFINITE_MIN;
        bounds->Width  = INFINITE_SIZE;
        bounds->Height = INFINITE_SIZE;
        break;

      default:
        if (UpdateDeviceRegion(matrix) == Ok)
        {
            DeviceRegion.GetBounds(bounds);
            break;
        }
        status = GenericError;
        // FALLTHRU

      case TypeEmpty:
        bounds->X      = 0;
        bounds->Y      = 0;
        bounds->Width  = 0;
        bounds->Height = 0;
        break;
    }
    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   Get the HRGN corresponding to the region
*
* Arguments:
*
*   [IN]  graphics - a reference graphics for conversion to device units
*                    (can be NULL)
*   [OUT] hRgn     - the GDI region
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   7/6/1999 DCurtis
*
\**************************************************************************/
GpStatus
GpRegion::GetHRgn(
    GpGraphics *        graphics,
    HRGN *              hRgn
    ) const
{
    ASSERT(IsValid());
    ASSERT(hRgn != NULL);

    GpMatrix    worldToDevice;

    if (graphics != NULL)
    {
        graphics->GetWorldToDeviceTransform(&worldToDevice);
    }

    if (UpdateDeviceRegion(&worldToDevice) == Ok)
    {
        if ((*hRgn = DeviceRegion.GetHRgn()) != (HRGN)INVALID_HANDLE_VALUE)
        {
            return Ok;
        }
    }
    else
    {
        *hRgn = (HRGN)INVALID_HANDLE_VALUE;
    }
    return GenericError;
}

GpStatus
GpRegion::GetRegionScans(
    GpRect *            rects,
    INT *               count,
    const GpMatrix *    matrix
    ) const
{
    ASSERT(IsValid());
    ASSERT(count != NULL);
    ASSERT(matrix != NULL);

    if (UpdateDeviceRegion(const_cast<GpMatrix*>(matrix)) == Ok)
    {
        *count = DeviceRegion.GetRects(rects);
        return Ok;
    }
    else
    {
        *count = 0;
    }
    return GenericError;
}

GpStatus
GpRegion::GetRegionScans(
    GpRectF *           rects,
    INT *               count,
    const GpMatrix *          matrix
    ) const
{
    ASSERT(IsValid());
    ASSERT(count != NULL);
    ASSERT(matrix != NULL);

    if (UpdateDeviceRegion(const_cast<GpMatrix*>(matrix)) == Ok)
    {
        *count = DeviceRegion.GetRects(rects);
        return Ok;
    }
    else
    {
        *count = 0;
    }
    return GenericError;
}

/**************************************************************************\
*
* Function Description:
*
*   Determine if the specified point is visible (inside) the region.
*
* Arguments:
*
*   [IN]  point     - the point, in world units
*   [IN]  matrix    - the world-to-device transformation matrix to use
*   [OUT] isVisible - if the point is visible or not
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   2/3/1999 DCurtis
*
\**************************************************************************/
GpStatus
GpRegion::IsVisible (
    GpPointF *          point,
    GpMatrix *          matrix,
    BOOL *              isVisible
    ) const
{
    ASSERT(IsValid());
    ASSERT(matrix != NULL);
    ASSERT(point != NULL);
    ASSERT(isVisible != NULL);

    if (UpdateDeviceRegion(matrix) == Ok)
    {
        GpPointF    transformedPoint = *point;

        matrix->Transform(&transformedPoint);

        *isVisible = DeviceRegion.PointInside(GpRound(transformedPoint.X),
                                              GpRound(transformedPoint.Y));
        return Ok;
    }

    *isVisible = FALSE;
    return GenericError;
}

/**************************************************************************\
*
* Function Description:
*
*   Determine if the specified rect is inside or overlaps the region.
*
* Arguments:
*
*   [IN]  rect      - the rect, in world units
*   [IN]  matrix    - the world-to-device transformation matrix to use
*   [OUT] isVisible - if the rect is visible or not
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   2/3/1999 DCurtis
*
\**************************************************************************/
GpStatus
GpRegion::IsVisible(
    GpRectF *           rect,
    GpMatrix *          matrix,
    BOOL *              isVisible
    ) const
{
    ASSERT(IsValid());
    ASSERT(matrix != NULL);
    ASSERT(rect != NULL);

    if (UpdateDeviceRegion(matrix) == Ok)
    {
        // If the transform is a simple scaling transform, life is a
        // little easier:
        if (Matrix.IsTranslateScale())
        {
            GpRectF     transformRect(*rect);

            Matrix.TransformRect(transformRect);

            // Use ceiling to stay compatible with rasterizer
            INT     x = GpCeiling(transformRect.X);
            INT     y = GpCeiling(transformRect.Y);

            *isVisible = DeviceRegion.RectVisible(
                                x, y,
                                x + GpCeiling(transformRect.Width),
                                y + GpCeiling(transformRect.Height));
            return Ok;
        }
        else
        {
            REAL        left   = rect->X;
            REAL        top    = rect->Y;
            REAL        right  = rect->X + rect->Width;
            REAL        bottom = rect->Y + rect->Height;
            GpRectF     bounds;
            GpRect      deviceBounds;
            GpRect      regionBounds;

            TransformBounds(matrix, left, top, right, bottom, &bounds);
            GpStatus status = BoundsFToRect(&bounds, &deviceBounds);
            DeviceRegion.GetBounds(&regionBounds);

            // try trivial reject
            if (status != Ok || !regionBounds.IntersectsWith(deviceBounds))
            {
                *isVisible = FALSE;
                return status;
            }

            // couldn't reject, so do full test
            GpPointF    points[4];

            points[0].X = left;
            points[0].Y = top;
            points[1].X = right;
            points[1].Y = top;
            points[2].X = right;
            points[2].Y = bottom;
            points[3].X = left;
            points[3].Y = bottom;

            const INT   stackCount = 4;
            GpPointF    stackPoints[stackCount];
            BYTE        stackTypes[stackCount];

            GpPath path(points,
                        4,
                        stackPoints,
                        stackTypes,
                        stackCount,
                        FillModeAlternate,
                        DpPath::Convex);

            if (path.IsValid())
            {
                DpRegion    region(&path, matrix);

                if (region.IsValid())
                {
                    *isVisible = DeviceRegion.RegionVisible(&region);
                    return Ok;
                }
            }
        }
    }
    *isVisible = FALSE;
    return GenericError;
}

/**************************************************************************\
*
* Function Description:
*
*   Determine if the specified region is inside or overlaps the region.
*
* Arguments:
*
*   [IN]  region    - the region
*   [IN]  matrix    - the world-to-device transformation matrix to use
*   [OUT] isVisible - if the region is visible or not
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   2/3/1999 DCurtis
*
\**************************************************************************/
GpStatus
GpRegion::IsVisible(
    GpRegion *          region,
    GpMatrix *          matrix,
    BOOL *              isVisible
    ) const
{
    ASSERT(IsValid());
    ASSERT(matrix != NULL);
    ASSERT((region != NULL) && (region->IsValid()));

    if ((UpdateDeviceRegion(matrix) == Ok) &&
        (region->UpdateDeviceRegion(matrix) == Ok))
    {
        *isVisible = DeviceRegion.RegionVisible(&(region->DeviceRegion));
        return Ok;
    }
    *isVisible = FALSE;
    return GenericError;
}

/**************************************************************************\
*
* Function Description:
*
*   Determine if the region is empty, i.e. if it has no coverage area.
*
* Arguments:
*
*   [IN]  matrix  - the world-to-device transformation matrix to use
*   [OUT] isEmpty - if the region is empty or not
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   01/06/1999 DCurtis
*
\**************************************************************************/
GpStatus
GpRegion::IsEmpty(
    GpMatrix *          matrix,
    BOOL *              isEmpty
    ) const
{
    ASSERT(IsValid());
    ASSERT(matrix != NULL);

    if (Type == TypeEmpty)
    {
        *isEmpty = TRUE;
        return Ok;
    }

    if (UpdateDeviceRegion(matrix) == Ok)
    {
        *isEmpty = DeviceRegion.IsEmpty();
        return Ok;
    }
    *isEmpty = FALSE;
    return GenericError;
}

/**************************************************************************\
*
* Function Description:
*
*   Determine if the region is infinite, i.e. if it has infinite coverage area.
*
* Arguments:
*
*   [IN]  matrix     - the world-to-device transformation matrix to use
*   [OUT] isInfinite - if the region is infinite or not
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   01/06/1999 DCurtis
*
\**************************************************************************/
GpStatus
GpRegion::IsInfinite(
    GpMatrix *          matrix,
    BOOL *              isInfinite
    ) const
{
    ASSERT(IsValid());
    ASSERT(matrix != NULL);

    if (Type == TypeInfinite)
    {
        *isInfinite = TRUE;
        return Ok;
    }

    // We have this here for cases like the following:
    //      This region was OR'ed with another region that was infinite.
    //      We wouldn't know this region was infinite now without checking
    //      the device region.
    if (UpdateDeviceRegion(matrix) == Ok)
    {
        *isInfinite = DeviceRegion.IsInfinite();
        return Ok;
    }
    *isInfinite = FALSE;
    return GenericError;
}

/**************************************************************************\
*
* Function Description:
*
*   Determine if the specified region is equal, in coverage area, to
*   this region.
*
* Arguments:
*
*   [IN]  region  - the region to check equality with
*   [IN]  matrix  - the world-to-device transformation matrix to use
*   [OUT] isEqual - if the regions are equal or not
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   01/06/1999 DCurtis
*
\**************************************************************************/
GpStatus
GpRegion::IsEqual(
    GpRegion *          region,
    GpMatrix *          matrix,
    BOOL *              isEqual
    ) const
{
    ASSERT(IsValid());
    ASSERT(matrix != NULL);
    ASSERT((region != NULL) && (region->IsValid()));

    if ((UpdateDeviceRegion(matrix) == Ok) &&
        (region->UpdateDeviceRegion(matrix) == Ok))
    {
        *isEqual = DeviceRegion.IsEqual(&(region->DeviceRegion));
        return Ok;
    }
    *isEqual = FALSE;
    return GenericError;
}


/**************************************************************************\
*
* Function Description:
*
*   Translate (offset) the region by the specified delta/offset values.
*
* Arguments:
*
*   [IN]  xOffset - amount to offset in X (world units)
*   [IN]  yOffset - amount to offset in Y
*
* Return Value:
*
*   NONE
*
* Created:
*
*   01/06/1999 DCurtis
*
\**************************************************************************/
GpStatus
GpRegion::Offset(
    REAL        xOffset,
    REAL        yOffset
    )
{
    ASSERT(IsValid());

    if ((xOffset == 0) && (yOffset == 0))
    {
        return Ok;
    }

    // Note that if performance is a problem, there's lots we could do here.
    // For example, we could keep track of the offset, and only apply it
    // when updating the device region.  We could even avoid re-rasterizing
    // the device region.

    switch (Type)
    {
      case TypeEmpty:
      case TypeInfinite:
        return Ok;  // do nothing

      case TypeRect:
        UpdateUid();
        X += xOffset;
        Y += yOffset;
        break;

      case TypePath:
        UpdateUid();
        if (Lazy)
        {
            Path = Path->Clone();
            Lazy = FALSE;
            if (Path == NULL)
            {
                Type = TypeNotValid;
                return GenericError;
            }
        }
        Path->Offset(xOffset, yOffset);
        break;

      default:
        UpdateUid();
        {
            INT             count = CombineData.GetCount();
            RegionData *    data  = CombineData.GetDataBuffer();
            NodeType        type;

            ASSERT ((count > 0) && (data != NULL));

            do
            {
                type = data->Type;

                if (type == TypeRect)
                {
                    data->X += xOffset;
                    data->Y += yOffset;
                }
                else if (type == TypePath)
                {
                    if (data->Lazy)
                    {
                        data->Path = data->Path->Clone();
                        data->Lazy = FALSE;
                        if (data->Path == NULL)
                        {
                            data->Type = TypeNotValid;
                            FreePathData();
                            Type = TypeNotValid;
                            return GenericError;
                        }
                    }
                    data->Path->Offset(xOffset, yOffset);
                }
                data++;

            } while (--count > 0);
        }
        break;
    }

    if (RegionOk)
    {
        RegionOk = FALSE;
        DeviceRegion.SetEmpty();
    }
    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   Transform a leaf node by the specified matrix.  This could result in a
*   rect being converted into a path.  Ignores non-leaf nodes.  No reason
*   to transform empty/infinite nodes.
*
* Arguments:
*
*   [IN]     matrix - the transformation matrix to apply
*   [IN/OUT] data   - the node to transform
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   02/08/1999 DCurtis
*
\**************************************************************************/
GpStatus
GpRegion::TransformLeaf(
    GpMatrix *      matrix,
    RegionData *    data
    )
{
    switch (data->Type)
    {
      // case TypeEmpty:
      // case TypeInfinite:
      // case TypeAnd, TypeOr, TypeXor, TypeExclude, TypeComplement:
      default:
        return Ok;      // do nothing

      case TypeRect:
        {
            if (matrix->IsTranslateScale())
            {
                GpRectF     rect(data->X,
                                 data->Y,
                                 data->Width,
                                 data->Height);
                matrix->TransformRect(rect);

                data->X      = rect.X;
                data->Y      = rect.Y;
                data->Width  = rect.Width;
                data->Height = rect.Height;

                return Ok;
            }
            else
            {
                GpPath *        path = new GpPath(FillModeAlternate);

                if (path != NULL)
                {
                    if (path->IsValid())
                    {
                        GpPointF    points[4];
                        REAL        left;
                        REAL        right;
                        REAL        top;
                        REAL        bottom;

                        left   = data->X;
                        top    = data->Y;
                        right  = data->X + data->Width;
                        bottom = data->Y + data->Height;

                        points[0].X = left;
                        points[0].Y = top;
                        points[1].X = right;
                        points[1].Y = top;
                        points[2].X = right;
                        points[2].Y = bottom;
                        points[3].X = left;
                        points[3].Y = bottom;

                        matrix->Transform(points, 4);

                        if (path->AddLines(points, 4) == Ok)
                        {
                            data->Path = path;
                            data->Lazy = FALSE;
                            data->Type = TypePath;
                            return Ok;
                        }
                    }
                    delete path;
                }
                data->Type = TypeNotValid;
            }
        }
        return GenericError;

      case TypePath:
        if (data->Lazy)
        {
            data->Path = data->Path->Clone();
            data->Lazy = FALSE;
            if (data->Path == NULL)
            {
                data->Type = TypeNotValid;
                return GenericError;
            }
        }
        data->Path->Transform(matrix);
        return Ok;
    }
}

/**************************************************************************\
*
* Function Description:
*
*   Transform a region with the specified matrix.
*
* Arguments:
*
*   [IN]     matrix - the transformation matrix to apply
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   02/08/1999 DCurtis
*
\**************************************************************************/
GpStatus
GpRegion::Transform(
    GpMatrix *      matrix
    )
{
    ASSERT(IsValid());

    if (matrix->IsIdentity() || (Type == TypeInfinite) || (Type == TypeEmpty))
    {
        return Ok;
    }

    UpdateUid();
    if (RegionOk)
    {
        RegionOk = FALSE;
        DeviceRegion.SetEmpty();
    }

    if ((Type & REGIONTYPE_LEAF) != 0)
    {
        return TransformLeaf(matrix, this);
    }
    else
    {
        BOOL            error = FALSE;
        INT             count = CombineData.GetCount();
        RegionData *    data  = CombineData.GetDataBuffer();

        ASSERT((count > 0) && (data != NULL));

        do
        {
            error |= (TransformLeaf(matrix, data++) != Ok);

        } while (--count > 0);

        if (!error)
        {
            return Ok;
        }
    }

    FreePathData();
    Type = TypeNotValid;
    return GenericError;
}

class RegionRecordData : public ObjectData
{
public:
    INT32       NodeCount;
};


GpStatus
GpRegion::SetData(
    const BYTE *    dataBuffer,
    UINT            size
    )
{
    if (dataBuffer == NULL)
    {
        WARNING(("dataBuffer is NULL"));
        return InvalidParameter;
    }

    return this->Set(dataBuffer, size);
}

GpStatus
GpRegion::Set(
    const BYTE *    regionDataBuffer,   // NULL means set to empty
    UINT            regionDataSize
    )
{
    GpStatus        status = Ok;

    if (regionDataBuffer != NULL)
    {
        if (regionDataSize < sizeof(RegionRecordData))
        {
            WARNING(("size too small"));
            status = InsufficientBuffer;
            goto SetEmptyRegion;
        }

        if (!((RegionRecordData *)regionDataBuffer)->MajorVersionMatches())
        {
            WARNING(("Version number mismatch"));
            status = InvalidParameter;
            goto SetEmptyRegion;
        }

        UpdateUid();
        if (RegionOk)
        {
            RegionOk = FALSE;
            DeviceRegion.SetEmpty();
        }
        FreePathData();

        RegionData *    regionDataArray = NULL;
        INT             nodeCount = ((RegionRecordData *)regionDataBuffer)->NodeCount;

        if (nodeCount > 0)
        {
            regionDataArray = CombineData.AddMultiple(nodeCount);
            if (regionDataArray == NULL)
            {
                Type = TypeNotValid;
                return OutOfMemory;
            }
        }
        regionDataBuffer += sizeof(RegionRecordData);
        regionDataSize   -= sizeof(RegionRecordData);

        INT     nextArrayIndex = 0;
        status = SetRegionData(regionDataBuffer, regionDataSize,
                               this, regionDataArray,
                               nextArrayIndex, nodeCount);
        if (status == Ok)
        {
            ASSERT(nextArrayIndex == nodeCount);
            return Ok;
        }
        Type = TypeNotValid;
        return status;
    }
SetEmptyRegion:
    SetEmpty();
    return status;
}

GpStatus
GpRegion::SetRegionData(
    const BYTE * &  regionDataBuffer,
    UINT &          regionDataSize,
    RegionData *    regionData,
    RegionData *    regionDataArray,
    INT &           nextArrayIndex,
    INT             arraySize
    )
{
    for (;;)
    {
        if (regionDataSize < sizeof(INT32))
        {
            WARNING(("size too small"));
            return InsufficientBuffer;
        }

        regionData->Type = (NodeType)(((INT32 *)regionDataBuffer)[0]);
        regionDataBuffer += sizeof(INT32);
        regionDataSize   -= sizeof(INT32);

        if ((regionData->Type & REGIONTYPE_LEAF) != 0)
        {
            switch (regionData->Type)
            {
            case TypeRect:
                if (regionDataSize < (4 * sizeof(REAL)))
                {
                    WARNING(("size too small"));
                    return InsufficientBuffer;
                }

                regionData->X      = ((REAL *)regionDataBuffer)[0];
                regionData->Y      = ((REAL *)regionDataBuffer)[1];
                regionData->Width  = ((REAL *)regionDataBuffer)[2];
                regionData->Height = ((REAL *)regionDataBuffer)[3];

                regionDataBuffer += (4 * sizeof(REAL));
                regionDataSize   -= (4 * sizeof(REAL));
                break;

            case TypePath:
                {
                    if (regionDataSize < sizeof(INT32))
                    {
                        WARNING(("size too small"));
                        return InsufficientBuffer;
                    }

                    GpPath *    path = new GpPath();
                    UINT        pathSize  = ((INT32 *)regionDataBuffer)[0];

                    regionDataBuffer += sizeof(INT32);
                    regionDataSize   -= sizeof(INT32);

                    if (path == NULL)
                    {
                        return OutOfMemory;
                    }

                    UINT        tmpPathSize = pathSize;

                    if ((path->SetData(regionDataBuffer, tmpPathSize) != Ok) ||
                        (!path->IsValid()))
                    {
                        delete path;
                        return InvalidParameter;
                    }
                    regionDataBuffer += pathSize;
                    regionDataSize   -= pathSize;

                    regionData->Path = path;
                    regionData->Lazy = FALSE;
                }
                break;

            case TypeEmpty:
            case TypeInfinite:
                break;

            default:
                ASSERT(0);
                break;
            }
            break;  // get out of loop
        }
        else // it's not a leaf node
        {
            if ((regionDataArray == NULL) ||
                (nextArrayIndex >= arraySize))
            {
                ASSERT(0);
                return InvalidParameter;
            }
            regionData->Left = nextArrayIndex++;

            // traverse left
            GpStatus status = SetRegionData(regionDataBuffer,
                                            regionDataSize,
                                            regionDataArray + regionData->Left,
                                            regionDataArray,
                                            nextArrayIndex,
                                            arraySize);
            if (status != Ok)
            {
                return status;
            }

            if (nextArrayIndex >= arraySize)
            {
                ASSERT(0);
                return InvalidParameter;
            }
            regionData->Right = nextArrayIndex++;

            // traverse right using tail-end recursion
            regionData = regionDataArray + regionData->Right;
        }
    }
    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   Serialize all the region data into a single memory buffer.  If the
*   buffer is NULL, just return the number of bytes required in the buffer.
*
* Arguments:
*
*   [IN]     regionDataBuffer - the memory buffer to fill with region data
*
* Return Value:
*
*   INT - Num Bytes required (or used) to fill with region data
*
* Created:
*
*   09/01/1999 DCurtis
*
\**************************************************************************/
GpStatus
GpRegion::GetData(
    IStream *   stream
    ) const
{
    ASSERT (stream != NULL);

    RegionRecordData    regionRecordData;
    regionRecordData.NodeCount = CombineData.GetCount();
    stream->Write(&regionRecordData, sizeof(regionRecordData), NULL);

    return this->GetRegionData(stream, this);
}

UINT
GpRegion::GetDataSize() const
{
    return sizeof(RegionRecordData) + this->GetRegionDataSize(this);
}

/**************************************************************************\
*
* Function Description:
*
*   Recurse through the region data structure to determine how many bytes
*   are required to hold all the region data.
*
* Arguments:
*
*   [IN]     regionData - the region data node to start with
*
* Return Value:
*
*   INT - the size in bytes from this node down
*
* Created:
*
*   09/01/1999 DCurtis
*
\**************************************************************************/
INT
GpRegion::GetRegionDataSize(
    const RegionData *      regionData
    ) const
{
    INT     size = 0;

    for (;;)
    {
        size += sizeof(INT32);   // for the type of this node

        if ((regionData->Type & REGIONTYPE_LEAF) != 0)
        {
            switch (regionData->Type)
            {
              case TypeRect:
                size += (4 * sizeof(REAL)); // for the rect data
                break;

              case TypePath:
                size += sizeof(INT32) + regionData->Path->GetDataSize();
                ASSERT((size & 0x03) == 0);
                break;

              case TypeEmpty:
              case TypeInfinite:
                break;

              default:
                ASSERT(0);
                break;
            }
            break;  // get out of loop
        }
        else // it's not a leaf node
        {
            // traverse left
            size += GetRegionDataSize(&(CombineData[regionData->Left]));

            // traverse right using tail-end recursion
            regionData = &(CombineData[regionData->Right]);
        }
    }
    return size;
}

/**************************************************************************\
*
* Function Description:
*
*   Recurse through the region data structure writing each region data
*   node to the memory buffer.
*
* Arguments:
*
*   [IN]     regionData       - the region data node to start with
*   [IN]     regionDataBuffer - the memory buffer to write the data to
*
* Return Value:
*
*   BYTE * - the next memory location to write to
*
* Created:
*
*   09/01/1999 DCurtis
*
\**************************************************************************/
GpStatus
GpRegion::GetRegionData(
    IStream *               stream,
    const RegionData *      regionData
    ) const
{
    ASSERT(stream != NULL);

    GpStatus    status   = Ok;
    UINT        pathSize;
    REAL        rectBuffer[4];

    for (;;)
    {
        stream->Write(&regionData->Type, sizeof(INT32), NULL);

        if ((regionData->Type & REGIONTYPE_LEAF) != 0)
        {
            switch (regionData->Type)
            {
            case TypeRect:
                rectBuffer[0] = regionData->X;
                rectBuffer[1] = regionData->Y;
                rectBuffer[2] = regionData->Width;
                rectBuffer[3] = regionData->Height;
                stream->Write(rectBuffer, 4 * sizeof(rectBuffer[0]), NULL);
                break;

            case TypePath:
                pathSize = regionData->Path->GetDataSize();
                ASSERT((pathSize & 0x03) == 0);
                stream->Write(&pathSize, sizeof(INT32), NULL);
                status = regionData->Path->GetData(stream);
                break;

            case TypeEmpty:
            case TypeInfinite:
                break;

            default:
                ASSERT(0);
                break;
            }
            break;  // get out of loop
        }
        else // it's not a leaf node
        {
            // traverse left
            status = GetRegionData(stream, &(CombineData[regionData->Left]));

            // traverse right using tail-end recursion
            regionData = &(CombineData[regionData->Right]);
        }
        if (status != Ok)
        {
            break;
        }
    }
    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   Constructor.  Sets the region to a copy of the specified path.
*
* Arguments:
*
*   [IN] path - path to initialize the region to
*
* Return Value:
*
*   NONE
*
* Created:
*
*   2/3/1999 DCurtis
*
\**************************************************************************/
GpRegion::GpRegion(
    HRGN                    hRgn
    )
{
    ASSERT(hRgn != NULL);

    SetValid(TRUE);     // default is valid

    RegionOk = FALSE;
    Lazy = FALSE;
    Type = TypeNotValid;
    Path = new GpPath(hRgn);

    if (CheckValid(Path))
    {
        Type = TypePath;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\entry\regiontopath.hpp ===
/******************************Module*Header*******************************\
* 
* Copyright (c) 1999 Microsoft Corporation
*
* Module Name:
*
*   Region to Path Conversion Class
*
* Abstract:
*
*   Converts an arbitrary GpRegion to GpPath equivalent.  It first
*   analyzes the GpRegion for simple conversion cases which it handles.
*   If the region is complex, then it invokes Kirk Olynyk's region to
*   path conversion routine.
*
* Notes:
*
*
* Created:
*
*   10/29/1999 ericvan
*
\**************************************************************************/

/*********************************Class************************************\
* class RTP_EPATHOBJ : publci EPATHOBJ                                     *
*                                                                          *
*   Adds diagonalization.                                                  *
*                                                                          *
* Public Interface:                                                        *
*                                                                          *
* History:                                                                 *
*  Wed 15-Sep-1993 10:06:05 by Kirk Olynyk [kirko]                         *
* Wrote it.                                                                *
\**************************************************************************/

/**************************************************************************\
*  class RTP_PATHMEMOBJ : public PATHMEMOBJ                                *
*                                                                          *
* This class is for converting regions to paths                            *
*                                                                          *
\**************************************************************************/

const FLONG LastPointFlag = 1;
const UINT MAX_ENUMERATERECTS = 20;

class RegionToPath
{
private:
    BOOL        bMoreToEnum;

    const DpRegion  *region;
    DynByteArray  *types;
    DynByteArray  inTypes;          // accumulated types
    DynPointArray *points;
    DynPointArray inPoints;         // accumulated points

    GpPoint*    curPoint;
    BYTE*       curType;

    GpPoint*    firstPoint;      // first point in current subpath
    GpPoint*    lastPoint;
    BOOL        endSubpath;
    
    INT         outPts;         // number of points in output buffer
    GpPoint     writePts[2];    // output buffer
    GpPoint     AB;             // aptfx[1] - aptfx[0]

    INT         curIndex;       // start of circular buffer (current corner)
    INT         lastCount;      //

    INT         numPts;
    FLONG       flags[3];
    GpPoint     pts[3];

    FLONG       afl[3];         // array of flags for the vertices
    UINT        aptfx[3];       // array of vertex positions

public:

    RegionToPath() {}
    ~RegionToPath() {}

    BOOL ConvertRegionToPath(const DpRegion* region,
                             DynPointArray& newPoints,
                             DynByteArray& newTypes);

private:

    BOOL DiagonalizePath();
    BOOL FetchNextPoint();
    BOOL WritePoint();

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\entry\regiontopath.cpp ===
/**************************************************************************\
*                                                                          *
* Copyright (c) 1998  Microsoft Corporation                                *
*                                                                          *
* Module Name:                                                             *
*                                                                          *
*   Region to Path Conversion class.                                       *
*                                                                          *
* Abstract:                                                                *
*                                                                          *
*   Code from Kirk Olynyk [kirko] created 14-Sep-1993.  This code will     *
*   convert rectangular regions to a path by analyzing the DDA pattern.    *
*                                                                          *
* Discussion:                                                              *
*                                                                          *
* Input                                                                    *
*                                                                          *
*     The input to the diagonalization routing is a rectangular            *
*     path whose vertices have integer endpoints.  Moreover it             *
*     is required that the path always has the region on its               *
*     left and that successive lines are mutually orthogonal.              *
*                                                                          *
*     All paths are in device 28.4 coordinates.  (Since all of             *
*     the input coordinates are integers, the fractional part of all       *
*     coordinates is zero.)                                                *
*                                                                          *
* Output                                                                   *
*                                                                          *
*     A path that contains the same pixels as the originl path.            *
*                                                                          *
* Filling Convention                                                       *
*                                                                          *
*     Any region bounded by two non-horizontal lines is closed             *
*     on the left and open on the right. If the region is bounded          *
*     by two horizontal lines, it is closed on the top and open on         *
*     bottom.                                                              *
*                                                                          *
* Definition                                                               *
*                                                                          *
*     A CORNER is subsequence of two lines from the orignal axial path.    *
*     It is convenient to partition the set of corners into two classes;   *
*     HORIZONTAL-VERTIAL and VERTICAL-HORIZONTAL.                          *
*                                                                          *
*     A corner is "diagonalizable" the original two lines can be replaced  *
*     by a single diagonal line such that same pixels would be rendered    *
*     (using the filling convention defined above).                        *
*                                                                          *
*                                                                          *
* Nomenclature                                                             *
*                                                                          *
*       S ::= "SOUTH" ::= one pixel move in +y-direction                   *
*       N ::= "NORTH" ::= one pixel move in -y-direction                   *
*       E ::= "EAST"  ::= one pixel move in +x direction                   *
*       W ::= "WEST"  ::= one pixel move in -x direction                   *
*                                                                          *
*     The set of diagonalizable corners are described by                   *
*     the following regular expressions:                                   *
*                                                                          *
*      DIAGONALIZABLE CORNERS                                              *
*                                                                          *
*         S(E+|W+)  a one pixel move in the +y-direction                   *
*                   followed by at least one pixel in any horizontal       *
*                   direction                                              *
*                                                                          *
*         S+W       an arbitary number of pixels in the +y-direction       *
*                   followed by a single pixel move in the                 *
*                   negative x-direction.                                  *
*                                                                          *
*         EN+       a one pixel move in the positive x-direction           *
*                   followed by at least one pixel move in the negative    *
*                   x-direction                                            *
*                                                                          *
*         (E+|W+)N  at least one-pixel move in the horizontal followed     *
*                   by a single pixel move in the negative                 *
*                   y-direction.                                           *
*                                                                          *
* Algorithm                                                                *
*                                                                          *
* BEGIN                                                                    *
*    <For each corner in the orginal path>                                 *
*    BEGIN                                                                 *
*        <if the corner is diagonalizable> THEN                            *
*                                                                          *
*            <just draw a single diagonal line>                            *
*        ELSE                                                              *
*            <draw both legs of the original corner>                       *
*    END                                                                   *
*                                                                          *
*    <Go around the path once again, merging successive                    *
*     identical moves into single lines>                                   *
* END                                                                      *
*                                                                          *
*     In the code, both of these steps are done in parallel                *
*                                                                          *
* Further Improvements                                                     *
*                                                                          *
*  The output path the I generate with this algorithm will contain only    *
*  points that were vertices of the original axial path. A larger of       *
*  regular expressions could be searched for if I were willing to          *
*  consider using new vertices for the output path. For example            *
*  the regular exprssios N+WN and S+ES describe two "chicane turns" that   *
*  can be diagonalized. The price to be paid is the a more complex         *
*  code path.                                                              *
*                                                                          *
\**************************************************************************/

#include "precomp.hpp"

/******************************Public*Routine******************************\
* RegionToPath::ConvertRegionToPath                                        *
*                                                                          *
*   Takes an enumerable clip region as input and outputs a path            *
*                                                                          *
* Assumptions                                                              *
*                                                                          *
*   0. *this is the original path which will not be changed.               *
*   1. All points on the path lie on integers                              *
*   2. All subpaths have the inside on the left                            *
*   3. All subpaths are closed                                             *
*                                                                          *
* History:                                                                 *
*  Mon 13-Sep-1993 15:53:50 by Kirk Olynyk [kirko]                         *
* Wrote it.                                                                *
\**************************************************************************/

BOOL RegionToPath::ConvertRegionToPath(const DpRegion* inRegion,
                                       DynPointArray& newPoints,
                                       DynByteArray& newTypes)
{
    BOOL result;

    curIndex = 0;
    
    // initialize array to reasonable no. of points + types

    points = &newPoints;
    types = &newTypes;
    
    newPoints.Reset();
    newTypes.Reset();
    
    region = inRegion;

    if (region->IsSimple()) 
    {
        GpRect bounds;

        region->GetBounds(&bounds);

        newPoints.Add(GpPoint(bounds.X, bounds.Y));
        newPoints.Add(GpPoint(bounds.X + bounds.Width, bounds.Y));
        newPoints.Add(GpPoint(bounds.X + bounds.Width, bounds.Y + bounds.Height));
        newPoints.Add(GpPoint(bounds.X, bounds.Y + bounds.Height));
        
        newTypes.Add(PathPointTypeStart);
        newTypes.Add(PathPointTypeLine);
        newTypes.Add(PathPointTypeLine);
        newTypes.Add(PathPointTypeLine | PathPointTypeCloseSubpath);

        return TRUE;
    }
    
    inPoints.Reset();
    inTypes.Reset();

    // convert region to right angle piecewise line segments
    if (region->GetOutlinePoints(inPoints, inTypes) == TRUE)
    {   
        curPoint = (GpPoint*) inPoints.GetDataBuffer();
        curType = (BYTE*) inTypes.GetDataBuffer();

        BOOL result = TRUE;
        
        lastPoint = &inPoints.Last();

        while (curPoint<=lastPoint && result) 
        {
            endSubpath = FALSE;
            firstPoint = curPoint;
            result = DiagonalizePath();
        }

	        return result;
    }
    else
        return FALSE;
}

/******************************Public*Routine******************************\
* RTP_PATHMEMOBJ::bWritePoint                                              *
*                                                                          *
* This routine takes as input a candidate point for writing. However       *
* this routine is smart in that it analyzes the stream of candidate        *
* points looking for consecutive sub-sets of points that all lie on the    *
* same line. When such a case is recognized, then only the endpoints of    *
* the interpolating line are actually added to the output path.            *
*                                                                          *
* I do not go to a great deal of trouble to determine if a candidate       *
* point is on a line. All that I do is to see if the vector increment      *
* to the new point  is the same as the increment between prior points      *
* in the input path.                                                       *
*                                                                          *
* History:                                                                 *
*  Mon 13-Sep-1993 15:53:35 by Kirk Olynyk [kirko]                         *
* Wrote it.                                                                *
\**************************************************************************/

BOOL RegionToPath::WritePoint()
{
    GpPoint  NewAB;
    BOOL result = TRUE;
    int  jA = curIndex;

    if (outPts == 2)
    {
        NewAB.X = pts[jA].X - writePts[1].X;
        NewAB.Y = pts[jA].Y - writePts[1].Y;
        
        if (NewAB.X != AB.X || NewAB.Y != AB.Y)
        {
            points->Add(writePts[0]);
            types->Add(PathPointTypeLine);
            
            writePts[0] = writePts[1];
            AB = NewAB;
        }

        writePts[1] = pts[jA];
    }
    else if (outPts == 0)
    {
        writePts[0] = pts[jA];
        outPts += 1;
    }
    else if (outPts == 1)
    {
        writePts[1] = pts[jA];
        AB.X = writePts[1].X - writePts[0].X;
        AB.Y = writePts[1].Y - writePts[0].Y;
        outPts += 1;
    }
    else
    {
        RIP(("RegionToPath::WritePoint -- point count is bad"));
        result = FALSE;
    }
    
    return(result);
}

/******************************Public*Routine******************************\
* bFetchNextPoint  ... in sub-path                                         *
*                                                                          *
* History:                                                                 *
*  Tue 14-Sep-1993 14:13:01 by Kirk Olynyk [kirko]                         *
* Wrote it.                                                                *
\**************************************************************************/

BOOL RegionToPath::FetchNextPoint()
{
    INT oldIndex = curIndex;

    curIndex = (curIndex + 1) % 3;

    // only output the first point if at end of a subpath
    if (endSubpath)
    {
        // end of subpath, add first point on end of new path
        flags[oldIndex] = 0;
        pts[oldIndex] = *firstPoint;
        return TRUE;
    }
    
    pts[oldIndex] = *curPoint;

    // check for end subpath only?
    if (*curType & PathPointTypeCloseSubpath)
    {
        endSubpath = TRUE;
        flags[oldIndex] = LastPointFlag;
    }
    else
    {
        flags[oldIndex] = 0;
    }
    curPoint++;
    curType++;

    return TRUE;
}

/******************************Public*Routine******************************\
* Path2Region::bDiagonalizeSubPathRTP_PATHMEMOBJ::bDiagonalizeSubPath      *
*                                                                          *
* History:                                                                 *
*  Tue 14-Sep-1993 12:47:49 by Kirk Olynyk [kirko]                         *
* Wrote it.                                                                *
\**************************************************************************/

inline VOID RotateBackward(INT& x, INT& y, INT& z)
{
    INT temp;

    temp = x;
    x = z;
    z = y;
    y = temp;
}

inline VOID RotateForward(INT& x, INT& y, INT& z)
{
    INT temp;

    temp = x;
    x = y;
    y = z;
    z = temp;
}

BOOL RegionToPath::DiagonalizePath()
{
    INT AB;               // Length of leg A->B
    INT BC;               // Length of second leg B->C

    INT bH;                // set to 1 if second leg is horizontal
    INT jA,jB,jC;
    
    register BOOL bRet = TRUE; // if FALSE then return immediately
                               // otherwise keep processing.

    outPts  = 0;              // no points so far in the write buffer
    curIndex = 0;             // set the start of the circular buffer
    lastCount = 0;

    // Fill the circular buffer with the first three points of the
    // path. The three member buffer, defines two successive lines, or
    // one corner (the path is guaranteed to be composed of alternating
    // lines along the x-axis and y-axis). I shall label the three vertices
    // of the corner A,B, and C. The point A always resides at ax[j],
    // point B resides at ax[iMod3[j+1]], and point C resides at
    // ax[iMod3[j+2]] where j can have one of the values 0, 1, 2.

    if (bRet = FetchNextPoint() && FetchNextPoint() && FetchNextPoint())
    {
        ASSERTMSG(curIndex == 0, ("RegionToPath::DiagonalizeSubPath()"
                                  " -- curIndex != 0"));

        // bH ::= <is the second leg of the corner horizontal?>
        //
        // if the second leg of the corner is horizontal set bH=1 otherwise
        // set bH=0. Calculate the length of the first leg of the corner
        // and save it in fxAB. Note that I do not need to use the iMod3
        // modulus operation since j==0.

        if (pts[2].Y == pts[1].Y)
        {
            bH = 1;
            AB = pts[1].Y - pts[0].Y;
        }
        else
        {
            bH = 0;
            AB = pts[1].X - pts[0].X;
        }

        // Start a new subpath at the first point of the subpath.

        points->Add(pts[0]);
        types->Add(PathPointTypeStart);
        
        jA = 0;
        jB = 1;
        jC = 2;
    }

    while (bRet)
    {
        
        if (!(flags[jA] & LastPointFlag))
        {
            // Assert that the the legs of the corner are along
            // the axes, and that the two legs are mutually
            // orthogonal

            ASSERTMSG(pts[jC].X == pts[jB].X || pts[jC].Y == pts[jB].Y,
                ("Bad Path :: C-B is not axial"));
            
            ASSERTMSG(pts[jA].X == pts[jB].X || pts[jA].Y == pts[jB].Y,
                ("Bad Path :: B-A is not axial"));
            
            ASSERTMSG(
                (pts[jC].X - pts[jB].X) *
                (pts[jB].X - pts[jA].X)
                +
                (pts[jC].Y - pts[jB].Y) *
                (pts[jB].Y - pts[jA].Y)
                == 0,
                ("Bad Path :: B-A is not orthogonal to C-B")
                );
        }
        
        // If the first vertex of the corner is the last point in the
        // original subpath then we terminate the processing.  This point
        // has either been recorded with PATHMEMOBJ::bMoveTo or
        // PATHMEMOBJ::bPolyLineTo.  All that remains is to close the
        // subpath which is done outside the while loop

        if (flags[jA] & LastPointFlag)
            break;

        // There are two paths through the following if-else clause
        // They are for VERTICAL-HORIZONTAL and HORIZONTAL-VERTICAL
        // corners respectively. These two clauses are identical
        // except for the interchange of ".x" with ".y". It might be
        // a good idea to have macros or subrouines for these sections
        // in order that they be guranteed to be identical.

        // Is the second leg of the corner horizontal?

        if (bH)
        {
            // Yes, the second leg of the corner is horizontal

            BC = pts[jC].X - pts[jB].X;

            // Is the corner diagonalizable?

            if ((AB > 0) && ((AB == 1) || (BC == -1)))
            {
                // Yes, the corner is diagonalizable
                //
                // If the middle of the corner was the last point in the
                // original path then the last point in the output path
                // is the first point in the corner. This is because the
                // last line in the output path is this diagonalized
                // corner which will be produced automatically by the
                // CloseFigure() call after this while-loop. Thus, in
                // this case we would just break out of the loop.

                if (flags[jB] & LastPointFlag)
                    break;

                // The corner is diagonalizable. This means that we are no
                // longer interested in the first two points of this corner.
                // We therefore fetch the next two points of the path
                // an place them in our circular corner-buffer.

                if (!(bRet = FetchNextPoint() && FetchNextPoint()))
                    break;

                // under modulo 3 arithmetic, incrementing by 2 is
                // equivalent to decrementing by 1

                RotateBackward(jA,jB,jC);

                // fxAB is set to the length of the first leg of the new
                // corner.

                AB = pts[jB].Y - pts[jA].Y;
            }
            else
            {
                // No, the corner is not diagonalizable
                //
                // The corner cannot be diagonalized. Advance the corner
                // to the next point in the original path. The orientation
                // of the second leg of the corner will change. The length
                // of the first leg of the new corner is set equal to the
                // length of the second leg of the previous corner.

                if (!(bRet = FetchNextPoint()))
                    break;

                RotateForward(jA,jB,jC);
                bH  ^= 1;
                AB = BC;
            }
        }
        else
        {
            // Diagonalize the HORIZONTAL->VERTICAL corner

            BC = pts[jC].Y - pts[jB].Y;
            if ((BC < 0) && ((AB == 1) || (BC == -1)))
            {
                if (flags[jB] & LastPointFlag)
                    break;
                
                if (!(bRet = FetchNextPoint() && FetchNextPoint()))
                    break;
                
                RotateBackward(jA,jB,jC);
                AB = pts[jB].X - pts[jA].X;
            }
            else
            {
                if (!(bRet = FetchNextPoint()))
                    break;
                
                RotateForward(jA,jB,jC);
                bH  ^= 1;
                AB  = BC;
            }
        }
        
        if (!(bRet = WritePoint()))
            break;
        
    }

    if (bRet)
    {
        ASSERTMSG(outPts == 2, ("GDI Region To Path -- numPts is not 2"));

        points->Add(writePts[0]);
        points->Add(writePts[1]);
        types->Add(PathPointTypeLine);
        types->Add(PathPointTypeLine | PathPointTypeCloseSubpath);
    }

    return(bRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\entry\stringformat.cpp ===
/**************************************************************************\
*
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   stringFormat.cpp
*
* Abstract:
*
*   Implementation for the string formatting class
*
* Revision History:
*
*   12 April 2000  dbrown
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"


GpStringFormat *GpStringFormat::GenericDefaultPointer     = NULL;
GpStringFormat *GpStringFormat::GenericTypographicPointer = NULL;

BYTE GpStringFormat::GenericDefaultStaticBuffer    [sizeof(GpStringFormat)] = {0};
BYTE GpStringFormat::GenericTypographicStaticBuffer[sizeof(GpStringFormat)] = {0};


GpStringFormat *GpStringFormat::GenericDefault()
{
    if (GenericDefaultPointer != NULL)
    {
        return GenericDefaultPointer;
    }

    // Initialise static GpStringFormat class

    // Create the GpStringFormat without allocating memory by using object placement
    GenericDefaultPointer = new(GenericDefaultStaticBuffer) GpStringFormat();
    ASSERT(GenericDefaultPointer->Flags == DefaultFormatFlags);
    GenericDefaultPointer->LeadingMargin  = DefaultMargin;
    GenericDefaultPointer->TrailingMargin = DefaultMargin;
    GenericDefaultPointer->Tracking       = DefaultTracking;
    GenericDefaultPointer->Trimming       = StringTrimmingCharacter;
    GenericDefaultPointer->Permanent      = TRUE;

    return GenericDefaultPointer;
}

GpStringFormat *GpStringFormat::GenericTypographic()
{
    if (GenericTypographicPointer != NULL)
    {
        return GenericTypographicPointer;
    }

    // Initialise static GpStringFormat class

    // Create the GpStringFormat without allocating memory by using object placement
    GenericTypographicPointer = new(GenericTypographicStaticBuffer) GpStringFormat();
    GenericTypographicPointer->Flags |= (StringFormatFlagsNoFitBlackBox | StringFormatFlagsNoClip | StringFormatFlagsLineLimit);
    GenericTypographicPointer->LeadingMargin  = 0.0;
    GenericTypographicPointer->TrailingMargin = 0.0;
    GenericTypographicPointer->Tracking       = 1.0;
    GenericTypographicPointer->Trimming       = StringTrimmingNone;
    GenericTypographicPointer->Permanent      = TRUE;

    return GenericTypographicPointer;
}

GpStringFormat *GpStringFormat::Clone() const
{
    // Get a binary copy
    GpStringFormat *newFormat = new GpStringFormat();

    if (newFormat)
    {
        newFormat->Flags             = Flags;
        newFormat->Language          = Language;
        newFormat->StringAlign       = StringAlign;
        newFormat->LineAlign         = LineAlign;
        newFormat->DigitSubstitute   = DigitSubstitute;
        newFormat->DigitLanguage     = DigitLanguage;
        newFormat->FirstTabOffset    = FirstTabOffset;
        newFormat->TabStops          = NULL;
        newFormat->CountTabStops     = CountTabStops;
        newFormat->HotkeyPrefix      = HotkeyPrefix;
        newFormat->LeadingMargin     = LeadingMargin;
        newFormat->TrailingMargin    = TrailingMargin;
        newFormat->Tracking          = Tracking;
        newFormat->Trimming          = Trimming;
        newFormat->RangeCount        = RangeCount;
        newFormat->Permanent         = NULL;

        newFormat->UpdateUid();

        if (TabStops)
        {
            REAL *newTabStops = NULL;

            newTabStops = new REAL [CountTabStops];

            if (newTabStops)
            {
                newFormat->TabStops = newTabStops;

                GpMemcpy(newFormat->TabStops, TabStops, sizeof(REAL) * CountTabStops);
            }
            else
            {
                delete newFormat;
                return NULL;
            }
        }

        if (Ranges)
        {
            CharacterRange *newRanges = NULL;

            newRanges = new CharacterRange [RangeCount];

            if (newRanges)
            {
                newFormat->Ranges = newRanges;

                for (INT i = 0; i < RangeCount; i++)
                {
                    newFormat->Ranges[i] = Ranges[i];
                }
            }
            else
            {
                if (TabStops)
                {
                    delete [] TabStops;
                }
                delete newFormat;
                newFormat = NULL;
            }
        }
    }

    return newFormat;
}


GpStatus GpStringFormat::SetMeasurableCharacterRanges(
    INT     rangeCount,
    const CharacterRange *ranges
)
{
    BOOL updated = FALSE;
    CharacterRange *newRanges = NULL;

    if (ranges && rangeCount > 0)
    {
        newRanges = new CharacterRange [rangeCount];

        if (!newRanges)
        {
            return OutOfMemory;
        }
    }

    if (Ranges)
    {
        //  Clear old ranges

        delete [] Ranges;

        Ranges = NULL;
        RangeCount = 0;
        updated = TRUE;
    }

    if (newRanges)
    {
        for (INT i = 0; i < rangeCount; i++)
        {
            newRanges[i] = ranges[i];
        }

        Ranges = newRanges;
        RangeCount = rangeCount;
        updated = TRUE;
    }

    if (updated)
    {
        UpdateUid();
    }
    return Ok;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\entry\textimager.hpp ===
#ifndef _TEXTIMAGER_HPP
#define _TEXTIMAGER_HPP


#define DriverStringOptionsMetaPlay  0x80000000



class GpTextImager
{
friend class FullTextImager;

public:
    GpTextImager() : IsMetaFileRecording(FALSE) {};


    virtual ~GpTextImager() {};

    virtual Status GetStatus() const = 0;

    virtual GpStatus Draw(GpGraphics *graphics, const PointF *origin) = 0;

    virtual GpStatus AddToPath(GpPath *path, const PointF *origin) = 0;

    virtual GpStatus Measure(
        GpGraphics *graphics,
        REAL       *nearGlyphEdge,      // Excudes overhang
        REAL       *farGlyphEdge,       // Excludes overhang
        REAL       *textDepth,
        INT        *codepointsFitted,
        INT        *linesFilled
    ) = 0;

    virtual GpStatus MeasureRanges(
        GpGraphics      *graphics,
        const PointF    *origin,
        GpRegion        **regions
    ) = 0;

    static void CleanupTextImager();

    BOOL &GetMetaFileRecordingFlag()
    {
        return IsMetaFileRecording;
    }

protected:
    BOOL IsMetaFileRecording;

};


/////   newTextImager
//
//      Creates a new text imager.
//
//      If any form of error occurs during the imager creation, an error status
//      is returned, and any allocated memory is released.


GpStatus newTextImager(
    const WCHAR           *string,
    INT                    length,
    REAL                   width,
    REAL                   height,
    const GpFontFamily    *family,
    INT                    style,
    REAL                   size,
    const GpStringFormat  *format,
    const GpBrush         *brush,
    GpTextImager         **imager,
    BOOL                   singleUse    // Enables use of simple formatter when no format passed
);





/////   ReadCmap - in engine\text\imager\cmap.cpp

GpStatus ReadCmap(
    BYTE           *cmapTable,
    INT             cmapLength,
    IntMap<UINT16> *cmap,
    BOOL           *bSymbol
);


/////   ReadMtx - in engine\text\imager\hmtx.cpp
//
//      Reads hmtx or vmtx table

GpStatus ReadMtx(
    BYTE           *Mtx,
    UINT            MtxLength,
    INT             numGlyphs,
    INT             numberOfLongMetrics,
    IntMap<UINT16> *designAdvance
);

GpStatus ReadMtxSidebearing(
    BYTE           *mtx,
    UINT            mtxLength,
    INT             numGlyphs,
    INT             numberOfLongMetrics,
    IntMap<UINT16> *sidebearing
);


/////   in engine\text\uniscribe\gsub.cxx
//
//      Examine gsub or mort for 'vert' features and supported scripts

void LoadVerticalSubstitution(
    const BYTE     *gsub,
    UINT16         *substitutionCount,
    const UINT16  **originals,    // returned as pointer into gsub, not endian converted
    const UINT16  **substitutions // returned as pointer into gsub, not endian converted
);

void LoadMortVerticalSubstitution(
    BYTE           *mort,
    UINT16         *substitutionCount,
    const UINT16  **originals,    // returned as pointer into mort, not endian converted
    const UINT16  **substitutions // returned as pointer into mort, not endian converted
);

void SubstituteVerticalGlyphs(
    UINT16        *glyphs,        // InOut
    UINT16         glyphCount,
    UINT16         substitutionCount,
    const UINT16  *originals,
    const UINT16  *substitutions
);



/**************************************************************************\
*
* SplitTransform:
*
*   Separates a transform into the sequence
*
*   o  scale        x always positive, y positive or negative
*   o  rotate       0 - 2pi
*   o  shear        along original x (as a positive or negative factor of y)
*   o  translate    any x,y
*
* Arguments:
*
*   IN   transform
*   OUT  scale
*   OUT  rotate
*   OUT  shear
*   OUT  translate
*
* Return Value:
*
*   none
*
* Created:
*
*   06/18/99 dbrown
*
* !!!
*   SplitTransform should probably be in matrix.hpp
*
\**************************************************************************/

void SplitTransform(
    const GpMatrix  &matrix,
    PointF          &scale,
    REAL            &rotate,
    REAL            &shear,
    PointF          &translate
);




/////   DetermineStringComplexity
//
//      Returns whether string contains complex script characters and/or digits. 

void DetermineStringComplexity(
    const UINT16 *string, 
    INT           length, 
    BOOL         *complex, 
    BOOL         *digitSeen
);


// SetTextLinesAntialiasMode
// make underline/strikeout/path rendering consistent with text antialiasing mode
// turn it on for AntiAlias and AntiAliasGridFit (excluding 'gasp' table case)
class SetTextLinesAntialiasMode
{
    GpGraphics *    Graphics;
    BOOL            OldMode;
public:
    SetTextLinesAntialiasMode(GpGraphics * graphics, const GpFaceRealization * faceRealization)
        : Graphics(0), OldMode(0)
    {
        SetAAMode(graphics, faceRealization);
    }
    void SetAAMode(GpGraphics * graphics, const GpFaceRealization * faceRealization)
    {
        ASSERT(!Graphics); // otherwise we lose old AA mode
        Graphics = graphics;
        if (!Graphics)
        {
            ASSERT(!faceRealization);
        }
        else
        {
            OldMode = Graphics->GetAntiAliasMode();

            ASSERT(faceRealization);

            TextRenderingHint hint = faceRealization->IsPathFont()
                ? Graphics->GetTextRenderingHintInternal()
                : faceRealization->RealizationMethod();

            BOOL newMode = FALSE;
            if (hint == TextRenderingHintAntiAlias)
                newMode = TRUE;
            else if (hint == TextRenderingHintAntiAliasGridFit)
            {
                if (faceRealization->IsPathFont())
                    newMode = TRUE;
                else
                {
                    if (faceRealization->IsHorizontalTransform() ||  faceRealization->IsVerticalTransform())
                        newMode = FALSE; // otherwise underline looks fuzzy
                    else
                        newMode = TRUE;
                }
            }
            Graphics->SetAntiAliasMode(newMode);
        }
    }
    ~SetTextLinesAntialiasMode()
    {
        if (Graphics)
            Graphics->SetAntiAliasMode(OldMode);
    }
}; // class SetTextLinesAntialiasMode

// This class is used if we call public GpGraphics methods
// from another public GpGraphics method to avoid extra GDI+ records
// We have to set g->Metafile to NULL so we don't record all the GDI+ records
// in the metafile again -- only the down-level ones.
class EmfPlusDisabler
{
    IMetafileRecord **  MetafileRef;
    IMetafileRecord *   SavedMetafile;
public:
    EmfPlusDisabler(IMetafileRecord ** metafileRef)
    {
        MetafileRef = metafileRef;
        SavedMetafile = *MetafileRef;
        *MetafileRef = 0;
    }
    ~EmfPlusDisabler()
    {
        *MetafileRef = SavedMetafile;
    }
}; // class EmfPlusDisabler

#endif // _TEXTIMAGER_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\entry\stringformat.hpp ===
/**************************************************************************\
*
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   stringFormat.hpp
*
* Abstract:
*
*   String and text format definition
*
* Revision History:
*
*   08/05/1999 dbrown
*       Created it.
*
\**************************************************************************/

#ifndef _STRINGFORMAT_HPP
#define _STRINGFORMAT_HPP

const REAL DefaultMargin   = REAL(1.0/6.0);
const REAL DefaultTracking = REAL(1.03);
const REAL DefaultBottomMargin = REAL(1.0/8.0);

const INT DefaultFormatFlags = 0;

const StringTrimming DefaultTrimming = StringTrimmingCharacter;

// Private StringFormatFlags

const INT StringFormatFlagsPrivateNoGDI                = 0x80000000;
const INT StringFormatFlagsPrivateAlwaysUseFullImager  = 0x40000000;
const INT StringFormatFlagsPrivateUseNominalAdvance    = 0x20000000;
const INT StringFormatFlagsPrivateFormatPersisted      = 0x10000000;

class StringFormatRecordData : public ObjectData
{
public:
    INT32                    Flags;
    LANGID                   Language;
    GpStringAlignment        StringAlign;
    GpStringAlignment        LineAlign;
    GpStringDigitSubstitute  DigitSubstitute;
    LANGID                   DigitLanguage;
    REAL                     FirstTabOffset;
    INT32                    HotkeyPrefix;
    REAL                     LeadingMargin;
    REAL                     TrailingMargin;
    REAL                     Tracking;
    StringTrimming           Trimming;
    INT32                    CountTabStops;
    INT32                    RangeCount;
};

//
// Represent a string format object
//

class GpStringFormat : public GpObject
{
protected:
    VOID SetValid(BOOL valid)
    {
        GpObject::SetValid(valid ? ObjectTagStringFormat : ObjectTagInvalid);
    }

public:

    GpStringFormat() :
        Flags                 (DefaultFormatFlags),
        Language              (LANG_NEUTRAL),
        StringAlign           (StringAlignmentNear),
        LineAlign             (StringAlignmentNear),
        DigitSubstitute       (StringDigitSubstituteUser),
        DigitLanguage         (LANG_NEUTRAL),
        FirstTabOffset        (0.0),
        TabStops              (NULL),
        CountTabStops         (0),
        HotkeyPrefix          (HotkeyPrefixNone),
        LeadingMargin         (DefaultMargin),
        TrailingMargin        (DefaultMargin),
        Tracking              (DefaultTracking),
        Trimming              (StringTrimmingCharacter),
        Ranges                (NULL),
        RangeCount            (0),
        Permanent             (FALSE)
    {
        SetValid(TRUE);     // default is valid
    }

    GpStringFormat(INT flags, LANGID language) :
        Flags                 (flags),
        Language              (language),
        StringAlign           (StringAlignmentNear),
        LineAlign             (StringAlignmentNear),
        DigitSubstitute       (StringDigitSubstituteUser),
        DigitLanguage         (LANG_NEUTRAL),
        FirstTabOffset        (0.0),
        TabStops              (NULL),
        CountTabStops         (0),
        HotkeyPrefix          (HotkeyPrefixNone),
        LeadingMargin         (DefaultMargin),
        TrailingMargin        (DefaultMargin),
        Tracking              (DefaultTracking),
        Trimming              (StringTrimmingCharacter),
        Ranges                (NULL),
        RangeCount            (0),
        Permanent             (FALSE)
    {
        SetValid(TRUE);     // default is valid
    }

    ~GpStringFormat()
    {
        if (TabStops)
            delete [] TabStops;

        if (Ranges)
            delete [] Ranges;
    }


    static GpStringFormat *GenericDefault();
    static GpStringFormat *GenericTypographic();

    static void DestroyStaticObjects()
    {
        // these objects are created as a static but constructed in the
        // GenericDefault() and GenericTypographic(). we need to destruct
        // it just in case the user called SetTapStop which allocate memory
        // inside this object and by this way we prevent any memory leak.

        if (GenericDefaultPointer != NULL)
        {
            GenericDefaultPointer->~GpStringFormat();

            // Zero the memory - this is risky code, so we want the memory
            // to match what it was when GDI+ started up.

            memset(GenericDefaultPointer, 0, sizeof(GpStringFormat));

            GenericDefaultPointer = NULL;
        }

        if (GenericTypographicPointer != NULL)
        {
            GenericTypographicPointer->~GpStringFormat();

            // Zero the memory - this is risky code, so we want the memory
            // to match what it was when GDI+ started up.

            memset(GenericTypographicPointer, 0, sizeof(GpStringFormat));

            GenericTypographicPointer = NULL;
        }

        return;
    }

    GpStringFormat *Clone() const;


    GpStatus SetFormatFlags(INT flags)
    {
        if (Flags != flags)
        {
            Flags = flags;
            UpdateUid();
        }
        return Ok;
    }

    INT GetFormatFlags() const
    {
        return Flags;
    }

    GpStatus SetAlign(GpStringAlignment align)
    {
        if (StringAlign != align)
        {
            StringAlign = align;
            UpdateUid();
        }
        return Ok;
    }

    GpStatus GetAlign(GpStringAlignment *align) const
    {
        *align = StringAlign;
        return Ok;
    }

    GpStringAlignment GetPhysicalAlignment() const
    {
        if (    !(Flags & StringFormatFlagsDirectionRightToLeft)
            ||  StringAlign == StringAlignmentCenter
            ||  Flags & StringFormatFlagsDirectionVertical)
        {
            return StringAlign;
        }
        else if (StringAlign == StringAlignmentNear)
        {
            return StringAlignmentFar; // RTL near = right
        }
        else
        {
            return StringAlignmentNear; // RTL far = left
        }
    }

    GpStringAlignment GetAlign() const
    {
        return StringAlign;
    }


    GpStatus SetLineAlign(GpStringAlignment align)
    {
        if (LineAlign != align)
        {
            LineAlign = align;
            UpdateUid();
        }
        return Ok;
    }

    GpStatus GetLineAlign(GpStringAlignment *align) const
    {
        *align = LineAlign;
        return Ok;
    }

    GpStringAlignment GetLineAlign() const
    {
        return LineAlign;
    }


    GpStatus SetHotkeyPrefix (INT hotkeyPrefix)
    {
        if (HotkeyPrefix != hotkeyPrefix)
        {
            HotkeyPrefix = hotkeyPrefix;
            UpdateUid();
        }
        return Ok;
    }

    GpStatus GetHotkeyPrefix (INT *hotkeyPrefix) const
    {
        if (!hotkeyPrefix)
            return InvalidParameter;

        *hotkeyPrefix = HotkeyPrefix;
        return Ok;
    }

    INT GetHotkeyPrefix () const
    {
        return HotkeyPrefix;
    }


    GpStatus SetTabStops (
        REAL    firstTabOffset,
        INT     countTabStops,
        const REAL *tabStops
    )
    {
        if (countTabStops > 0)
        {
            //  We do not support negative tabulation (tab position
            //  advances in the opposite direction of reading order)

            if (firstTabOffset < 0)
            {
                return NotImplemented;
            }

            for (INT i = 0; i < countTabStops; i++)
            {
                if (tabStops[i] < 0)
                {
                    return NotImplemented;
                }
            }

            REAL *newTabStops = new REAL [countTabStops];

            if (!newTabStops)
            {
                return OutOfMemory;
            }

            if (TabStops)
            {
                delete [] TabStops;
            }

            TabStops = newTabStops;

            GpMemcpy (TabStops, tabStops, sizeof(REAL) * countTabStops);
            CountTabStops   = countTabStops;
            FirstTabOffset  = firstTabOffset;
            UpdateUid();
        }
        return Ok;
    }

    GpStatus GetTabStopCount (
        INT     *countTabStops
    ) const
    {
        if (!countTabStops)
        {
            return InvalidParameter;
        }

        *countTabStops = CountTabStops;

        return Ok;
    }

    GpStatus GetTabStops (
        REAL    *firstTabOffset,
        INT     countTabStops,
        REAL    *tabStops
    ) const
    {
        if (   !firstTabOffset
            || !tabStops)
        {
            return InvalidParameter;
        }

        INT count;

        if (countTabStops <= CountTabStops)
            count = countTabStops;
        else
            count = CountTabStops;

        GpMemcpy(tabStops, TabStops, sizeof(REAL) * count);

        *firstTabOffset = FirstTabOffset;

        return Ok;
    }

    INT GetTabStops (
        REAL    *firstTabOffset,
        REAL    **tabStops
    ) const
    {
        *firstTabOffset = FirstTabOffset;
        *tabStops       = TabStops;

        return CountTabStops;
    }


    GpStatus SetMeasurableCharacterRanges(
        INT     rangeCount,
        const CharacterRange *ranges
    );


    INT GetMeasurableCharacterRanges(
        CharacterRange **ranges = NULL
    ) const
    {
        if (ranges)
        {
            *ranges = Ranges;
        }
        return RangeCount;
    }


    GpStatus SetDigitSubstitution(
        LANGID                 language,
        StringDigitSubstitute  substitute = StringDigitSubstituteNational
    )
    {
        if (DigitSubstitute != substitute || DigitLanguage != language)
        {
            DigitSubstitute = substitute;
            DigitLanguage   = language;
            UpdateUid();
        }
        return Ok;
    }

    GpStatus GetDigitSubstitution(
        LANGID                 *language,
        StringDigitSubstitute  *substitute
    ) const
    {
        if(substitute)
        {
            *substitute = DigitSubstitute;
        }
        if(language)
        {
            *language   = DigitLanguage;
        }
        return Ok;
    }

    GpStatus SetLeadingMargin(REAL margin)
    {
        if (LeadingMargin != margin)
        {
            LeadingMargin = margin;
            UpdateUid();
        }
        return Ok;
    }

    REAL GetLeadingMargin() const
    {
        return LeadingMargin;
    }


    GpStatus SetTrailingMargin(REAL margin)
    {
        if (TrailingMargin != margin)
        {
            TrailingMargin = margin;
            UpdateUid();
        }
        return Ok;
    }

    REAL GetTrailingMargin() const
    {
        return TrailingMargin;
    }


    GpStatus SetTracking(REAL tracking)
    {
        if (Tracking != tracking)
        {
            Tracking = tracking;
            UpdateUid();
        }
        return Ok;
    }

    REAL GetTracking() const
    {
        return Tracking;
    }



    GpStatus SetTrimming(StringTrimming trimming)
    {
        if (Trimming != trimming)
        {
            Trimming = trimming;
            UpdateUid();
        }
        return Ok;
    }

    GpStatus GetTrimming(StringTrimming *trimming) const
    {
        ASSERT(trimming != NULL);
        if (trimming == NULL)
        {
            return InvalidParameter;
        }
        *trimming = Trimming;
        return Ok;
    }

    virtual BOOL IsValid() const
    {
        // If the string format came from a different version of GDI+, its tag
        // will not match, and it won't be considered valid.
        return GpObject::IsValid(ObjectTagStringFormat);
    }

    virtual ObjectType GetObjectType() const { return ObjectTypeStringFormat; }

    virtual GpStatus GetData(IStream * stream) const
    {
        ASSERT (stream);

        StringFormatRecordData  stringFormatData;

        stringFormatData.Flags             = Flags;
        stringFormatData.Language          = Language;
        stringFormatData.StringAlign       = StringAlign;
        stringFormatData.LineAlign         = LineAlign;
        stringFormatData.DigitSubstitute   = DigitSubstitute;
        stringFormatData.DigitLanguage     = DigitLanguage;
        stringFormatData.FirstTabOffset    = FirstTabOffset;
        stringFormatData.LineAlign         = LineAlign;
        stringFormatData.CountTabStops     = CountTabStops;
        stringFormatData.HotkeyPrefix      = HotkeyPrefix;
        stringFormatData.LeadingMargin     = LeadingMargin;
        stringFormatData.TrailingMargin    = TrailingMargin;
        stringFormatData.Tracking          = Tracking;
        stringFormatData.Trimming          = Trimming;
        stringFormatData.CountTabStops     = CountTabStops;
        stringFormatData.RangeCount        = RangeCount;

        stream->Write(
            &stringFormatData,
            sizeof(stringFormatData),
            NULL
        );

        stream->Write(
            TabStops,
            CountTabStops * sizeof(TabStops[0]),
            NULL
        );

        stream->Write(
            Ranges,
            RangeCount * sizeof(Ranges[0]),
            NULL
        );

        return Ok;
    }

    virtual UINT GetDataSize() const
    {
        UINT    size = sizeof(StringFormatRecordData);

        size += (CountTabStops * sizeof(TabStops[0]));
        size += (RangeCount * sizeof(Ranges[0]));

        return size;
    }

    virtual GpStatus SetData(const BYTE * dataBuffer, UINT size)
    {
        if ((dataBuffer == NULL) || (size < (sizeof(StringFormatRecordData) - sizeof(REAL))))
        {
            WARNING(("dataBuffer too small"));
            return InvalidParameter;
        }

        const StringFormatRecordData *stringFormatData =
            (const StringFormatRecordData *)dataBuffer;

        if (!stringFormatData->MajorVersionMatches())
        {
            WARNING(("Version number mismatch"));
            return InvalidParameter;
        }

        Flags                 = stringFormatData->Flags | StringFormatFlagsPrivateFormatPersisted;
        Language              = stringFormatData->Language;
        StringAlign           = stringFormatData->StringAlign;
        LineAlign             = stringFormatData->LineAlign;
        DigitSubstitute       = stringFormatData->DigitSubstitute;
        DigitLanguage         = stringFormatData->DigitLanguage;
        FirstTabOffset        = stringFormatData->FirstTabOffset;
        LineAlign             = stringFormatData->LineAlign;
        CountTabStops         = stringFormatData->CountTabStops;
        HotkeyPrefix          = stringFormatData->HotkeyPrefix;
        LeadingMargin         = stringFormatData->LeadingMargin;
        TrailingMargin        = stringFormatData->TrailingMargin;
        Tracking              = stringFormatData->Tracking;
        Trimming              = stringFormatData->Trimming;
        CountTabStops         = stringFormatData->CountTabStops;
        RangeCount            = stringFormatData->RangeCount;


        if (size <
            (  sizeof(StringFormatRecordData)
             + sizeof(TabStops[0]) * CountTabStops
             + sizeof(Ranges[0]) * RangeCount))
        {
            return InvalidParameter;
        }


        //  Propagate tab stops

        if (TabStops)
        {
            delete [] TabStops;
        }

        TabStops = new REAL [CountTabStops];
        if (TabStops == NULL)
        {
            return OutOfMemory;
        }

        REAL *tabStops = (REAL *)(&stringFormatData[1]);
        for (INT i = 0; i < CountTabStops; i++)
        {
            TabStops[i] = tabStops[i];
        }


        //  Propagate ranges

        if (Ranges)
        {
            delete [] Ranges;
        }

        Ranges = new CharacterRange [RangeCount];
        if (Ranges == NULL)
        {
            if (TabStops)
            {
                delete [] TabStops;
            }
            return OutOfMemory;
        }

        CharacterRange *ranges = (CharacterRange *)(&tabStops[CountTabStops]);
        for (INT i = 0; i < RangeCount; i++)
        {
            Ranges[i] = ranges[i];
        }

        UpdateUid();

        return Ok;
    }

    BOOL IsPermanent() const
    {
        return Permanent;
    }

    // we override the new operator for this class just to use it for object
    // placement. we didn't make the new placemenet global because it will
    // conflict with office because they link with GdiPlus statically.
    // we didn't override the delete operator because it is fine to use the
    // global one in \engine\runtime\Mem.h

    void* operator new(size_t size)
    {
        return GpMalloc(size);
    }

    void* operator new(size_t size, void* p)
    {
        return p;
    }

    // Digit Substitution
    const ItemScript GetDigitScript() const
    {
        return GetDigitSubstitutionsScript(DigitSubstitute, DigitLanguage);
    }

private:

    INT                      Flags;
    LANGID                   Language;
    GpStringAlignment        StringAlign;
    GpStringAlignment        LineAlign;
    GpStringDigitSubstitute  DigitSubstitute;
    LANGID                   DigitLanguage;
    REAL                     FirstTabOffset;
    REAL                    *TabStops;       // absolute tab stops in world unit
    INT                      CountTabStops;
    INT                      HotkeyPrefix;
    REAL                     LeadingMargin;  // relative to body font em size
    REAL                     TrailingMargin; // relative to body font em size
    REAL                     Tracking;       // scale factor
    GpStringTrimming         Trimming;
    CharacterRange          *Ranges;         // character ranges
    INT                      RangeCount;     // number of ranges
    BOOL                     Permanent;

    GpStringFormat(const GpStringFormat &format)
    {
        // This should never get called! Use Clone instead!
        ASSERT(FALSE);
    }


    // The following static variables support the generic StringFormats

    // Pointers (initialised at load time to null)

    static GpStringFormat *GenericDefaultPointer;
    static GpStringFormat *GenericTypographicPointer;

    // Memory allocation for generic structures. Note that we must allocate
    // load time memory as BYTE arrays to avoid creating a dependency on
    // the CRT for class construction.
    // The definitions (which specify the size) are in StringFormat.cpp.

    static BYTE GenericDefaultStaticBuffer[];
    static BYTE GenericTypographicStaticBuffer[];
};

#endif // !_STRINGFORMAT_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\entry\vectormath.hpp ===
/**************************************************************************
*
* Copyright (c) 2000 Microsoft Corporation
*
* Module Name:
*
*   Vector/Matrix mathematics
*
* Abstract:
*
*   Defines some vector mathematics for use by the ICM conversion code.
*
* Notes:
*
*   <optional>
*
* Created:
*
*   04/08/2000 asecchia
*      Created it.
*
**************************************************************************/

#ifndef _VECTORMATH_HPP
#define _VECTORMATH_HPP

#define VECTORSIZE 3

namespace VectorMath {


class Vector
{
    public:
    friend class Matrix;
    Vector() {}
    Vector(REAL x, REAL y, REAL z)
    {
        ASSERT((VECTORSIZE==3));
        data[0]=x;
        data[1]=y;
        data[2]=z;
    }

    Vector operator *(REAL k)
    {
        Vector v;
        for(int i=0; i<VECTORSIZE; i++) 
        {
            v.data[i] = data[i] * k;
        }
        return v;
    }

    Vector operator +(Vector V)
    {
        Vector v;
        for(int i=0; i<VECTORSIZE; i++) 
        {
            v.data[i] = data[i] + V.data[i];
        }
        return v;
    }
    
    REAL operator *(Vector V)
    {
        REAL r = 0.0f;
        for(int i=0; i<VECTORSIZE; i++) 
        {
            r += data[i] * V.data[i];
        }
        return r;
    }

    REAL data[VECTORSIZE];
};


class Matrix
{
    public:
    friend class Vector;

    Matrix() {}
    Matrix(REAL a, REAL b, REAL c,
           REAL d, REAL e, REAL f,
           REAL g, REAL h, REAL i)
    {
        ASSERT((VECTORSIZE==3));
        data[0][0] = a;
        data[0][1] = b;
        data[0][2] = c;
        data[1][0] = d;
        data[1][1] = e;
        data[1][2] = f;
        data[2][0] = g;
        data[2][1] = h;
        data[2][2] = i;
    }

    // Diagonalize a vector
    Matrix(Vector V)
    {
        ASSERT((VECTORSIZE==3));
        data[0][0] = V.data[0];
        data[1][0] = 0;
        data[2][0] = 0;
        data[0][1] = 0;
        data[1][1] = V.data[1];
        data[2][1] = 0;
        data[0][2] = 0;
        data[1][2] = 0;
        data[2][2] = V.data[2];
    }

    Matrix operator *(REAL k)
    {
        Matrix m;
        for(int i=0; i<VECTORSIZE; i++)
        {
            for(int j=0; j<VECTORSIZE; j++)
            {
                m.data[i][j] = data[i][j] * k;
            }
        }
        return m;
    }

    Vector operator *(Vector v)
    {
        Vector R(0,0,0);

        for(int j=0; j<VECTORSIZE; j++)
        {
            for(int i=0; i<VECTORSIZE; i++)
            {
                R.data[j] += data[j][i] * v.data[i];
            }
        }

        return R;
    }

    Matrix operator *(Matrix m)
    {
        Matrix R(0,0,0,
                 0,0,0,
                 0,0,0);

        for(int j=0; j<VECTORSIZE; j++) 
        {
            for(int i=0; i<VECTORSIZE; i++)
            {
                for(int k=0; k<VECTORSIZE; k++)
                {
                    R.data[j][i] += data[j][k] * m.data[k][i];
                }
            }
        }

        return R;
    }

    // Flip the matrix along the main diagonal
    Matrix Transpose() 
    {
        Matrix R;

        for(int j=0; j<VECTORSIZE; j++)
        {
            for(int i=0; i<VECTORSIZE; i++) 
            {
                R.data[j][i] = data[i][j];
            }
        }

        return R;
    }

    REAL Determinant() 
    {
        ASSERT((VECTORSIZE==3));
        return (
          // Compute the 3x3 matrix determinant.
            -data[0][2]*data[1][1]*data[2][0] + 
             data[0][1]*data[1][2]*data[2][0] + 
             data[0][2]*data[1][0]*data[2][1] - 
             data[0][0]*data[1][2]*data[2][1] - 
             data[0][1]*data[1][0]*data[2][2] + 
             data[0][0]*data[1][1]*data[2][2]
        );
    }

    Matrix Adjoint()
    {
        ASSERT((VECTORSIZE==3));
        Matrix m(
         // Adjoint matrix - transpose of the cofactor matrix.

            -data[1][2]*data[2][1] + data[1][1]*data[2][2],
             data[0][2]*data[2][1] - data[0][1]*data[2][2],
            -data[0][2]*data[1][1] + data[0][1]*data[1][2],

             data[1][2]*data[2][0] - data[1][0]*data[2][2], 
            -data[0][2]*data[2][0] + data[0][0]*data[2][2],
             data[0][2]*data[1][0] - data[0][0]*data[1][2],

            -data[1][1]*data[2][0] + data[1][0]*data[2][1],
             data[0][1]*data[2][0] - data[0][0]*data[2][1],
            -data[0][1]*data[1][0] + data[0][0]*data[1][1]

        );
        return m;
    }

    Matrix Inverse()
    {
        Matrix m;
        m = Adjoint();
        REAL det = Determinant();
        if(REALABS(det) < REAL_EPSILON) 
        {
            m = Matrix(0,0,0,0,0,0,0,0,0);
        }
        else 
        {
            m = m * (1.0f/det);
        }
        return m;
    }

    REAL data[VECTORSIZE][VECTORSIZE];
};

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\entry\xpath.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1999  Microsoft Corporation
*
* Abstract:
*
*   Implementation of XBezier class and its DDA.
*
* History:
*
*   11/08/1999 ikkof
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"

    // Path types used for advanced path.

// !!! [asecchia] 
// this is a very clumsy hack to enable the XPath stuff to work.
// we should have an internal set of enum values that are different
// from the external ones.

#define PathPointTypeBezier2 2    // quadratic Beizer
#define PathPointTypeBezier4 4    // quartic (4th order) Beizer
#define PathPointTypeBezier5 5    // quintic (5th order) Bezier
#define PathPointTypeBezier6 6    // hexaic (6th order) Bezier



GpXPath::GpXPath(const GpPath* path)
{
    InitDefaultState();

    if(!path || !path->IsValid())
		return;
	
	INT count = path->GetPointCount();
    const GpPointF *pts = ((GpPath*) path)->GetPathPoints();
    const BYTE *types = ((GpPath*) path)->GetPathTypes();

	if(pts && types && count > 0)
	{
		Types = (BYTE*) GpMalloc(count);
		XPoints.Count = count;
		XPoints.Dimension = 2;
		XPoints.Data = (REALD*) GpMalloc(2*count*sizeof(REALD));
        XPoints.IsDataAllocated = TRUE;

		if(Types && XPoints.Data)
		{
			GpMemcpy(Types, types, count);
			REALD* data = XPoints.Data;
			for(INT i = 0; i < count; i++)
			{
				*data++ = pts->X;
				*data++ = pts->Y;
				pts++;
			}
			SetValid(TRUE);
		}
		FillMode = ((GpPath*) path)->GetFillMode();
	}
}

GpXPath::GpXPath(
	const GpPath* path,
    const GpRectF& rect,
    const GpPointF* points,
    INT count,
	WarpMode warpMode
	)
{
    InitDefaultState();

    if(warpMode == WarpModePerspective)
        ConvertToPerspectivePath(path, rect, points, count);
    else if(warpMode == WarpModeBilinear)
        ConvertToBilinearPath(path, rect, points, count);
}

GpStatus
GpXPath::ConvertToPerspectivePath(
    const GpPath* path,
    const GpRectF& rect,
    const GpPointF* points,
    INT count
    )
{
    ASSERT(path && path->IsValid());

	if(!path || !path->IsValid())
		return InvalidParameter;

	// Obtain the path points.

	const GpPointF* pathPts = ((GpPath*) path)->GetPathPoints();
    const BYTE* pathTypes = ((GpPath*) path)->GetPathTypes();
	INT pathCount = path->GetPointCount();

    BYTE* types = (BYTE*) GpMalloc(pathCount);

    if(!types)
        return OutOfMemory;

    GpMemcpy(types, pathTypes, pathCount);

    // Set the perspective transform.

	GpPerspectiveTransform trans(rect, points, count);
    
	// Convert the path points to 3D perspective points.

    REALD* data = (REALD*) GpMalloc(3*pathCount*sizeof(REALD));

	if(!data)
		return OutOfMemory;

    // Use this data for xpoints.

	XPoints.Count = pathCount;
    XPoints.Dimension = 3;
    XPoints.Data = data;
    XPoints.IsDataAllocated = TRUE;

    Types = types;
    GpStatus status = trans.ConvertPoints(pathPts, pathCount, &XPoints);

    if(status == Ok)
        SetValid(TRUE);

    return status;
}

GpStatus
GpXPath::ConvertToBilinearPath(
    const GpPath* path,
    const GpRectF& rect,
    const GpPointF* points,
    INT count
    )
{
    ASSERT(path && path->IsValid());

	if(!path || !path->IsValid())
		return InvalidParameter;

	// Obtain the path points.

	const GpPointF* pathPts = ((GpPath*) path)->GetPathPoints();
	const BYTE* pathTypes = ((GpPath*) path)->GetPathTypes();
	INT pathCount = path->GetPointCount();

    // The maximum data size of the bilinear transform is
    // 2*pathCount - 1.  Here set it as 2*pathCount.

    INT dimension = 2;
	INT maxCount = 2*pathCount;
	REALD* data = (REALD*) GpMalloc(dimension*maxCount*sizeof(REALD));
    BYTE* types = (BYTE*) GpMalloc(maxCount);

	if(!data || !types)
    {
        GpFree(data);
        GpFree(types);

		return OutOfMemory;
    }
    
	GpMemset(types, 0, maxCount);

    // Set the bilinear transform.

	GpBilinearTransform trans(rect, points, count);

    DpPathIterator iter(pathPts, pathTypes, pathCount);

    INT startIndex, endIndex;
    BOOL isClosed;
    GpStatus status = Ok;
    REALD* dataPtr = data;

    INT totalCount = 0; // Number of control points.

    while(
		iter.NextSubpath(
		&startIndex, &endIndex, &isClosed)
		&& status == Ok
		)
    {
        INT typeStartIndex, typeEndIndex;
        BYTE pathType;
        BOOL isFirstPoint = TRUE;

        while(
			iter.NextPathType(&pathType, &typeStartIndex, &typeEndIndex)
            && status == Ok
			)
        {
            // Starting point of the current suptype
            // and the number of points.

            const GpPointF* pts = pathPts + typeStartIndex;
            INT typeCount = typeEndIndex - typeStartIndex + 1;

            switch(pathType)
            {
			case PathPointTypeBezier3:
                trans.ConvertCubicBeziers(pts, typeCount, dataPtr);
                pts += typeCount - 1;
                dataPtr += dimension*2*(typeCount - 1);

                if(isFirstPoint)
                {
                    *(types + totalCount) = PathPointTypeStart;
                    totalCount++;
                }
                
                GpMemset(types + totalCount, PathPointTypeBezier6, 2*(typeCount - 1));
                totalCount += 2*(typeCount - 1);
                isFirstPoint = FALSE;
                break;           
            
            case PathPointTypeLine:
                trans.ConvertLines(pts, typeCount, dataPtr);
                pts += typeCount - 1;
                dataPtr += dimension*2*(typeCount - 1);

                if(isFirstPoint)
                {
                    *(types + totalCount) = PathPointTypeStart;
                    totalCount++;
                }

                GpMemset(types + totalCount, PathPointTypeBezier2, 2*(typeCount - 1));
                totalCount += 2*(typeCount - 1);
                isFirstPoint = FALSE;
                break;

            case PathPointTypeStart:
            case PathPointTypeBezier2:
            case PathPointTypeBezier4:
            case PathPointTypeBezier5:
	    case PathPointTypeBezier6:
            default:
                // Should not have any of those types in GpPath.
                
                ASSERT(0);
                break;
            }
        }
    }

    Types = types;
    XPoints.Count = totalCount;
    XPoints.Dimension = dimension;
    XPoints.Data = data;
    XPoints.IsDataAllocated = TRUE;
    SetValid(TRUE);

    return Ok;
}

GpStatus
GpXPath::Flatten(
    DynByteArray* flattenTypes,
    DynPointFArray* flattenPoints,
    const GpMatrix *matrix
    )
{
    GpStatus status = Ok;

    ASSERT(matrix);

    FPUStateSaver fpuState;  // Setup the FPU state.

    flattenPoints->Reset(FALSE);
    flattenTypes->Reset(FALSE);

	INT dimension = XPoints.Dimension;
	REALD* data = XPoints.Data;

    GpXPathIterator iter(this);

    INT startIndex, endIndex;
    BOOL isClosed;

	GpPointF* ptsBuffer = NULL;

    while(
		iter.NextSubpath(
		&startIndex, &endIndex, &isClosed)
		&& status == Ok
		)
    {
        INT typeStartIndex, typeEndIndex;
        BYTE pathType;
        BOOL isFirstPoint = TRUE;

        while(
			iter.NextPathType(&pathType, &typeStartIndex, &typeEndIndex)
            && status == Ok
			)
        {
			INT count, index;
			BYTE* types;
			GpPointF* pts;

            switch(pathType)
            {
            case PathPointTypeStart:
                break;

            case PathPointTypeBezier2:
			case PathPointTypeBezier3:
			case PathPointTypeBezier4:
			case PathPointTypeBezier5:
			case PathPointTypeBezier6:
				{
					BOOL dontCopy = FALSE;
					GpXBezier bezier;
					GpXPoints xpoints;
					INT order;

					xpoints.SetData(
						data + typeStartIndex*dimension,
						dimension,
						typeEndIndex - typeStartIndex + 1,
						dontCopy	// Don't copy the data.
						);
					order = (INT) pathType;
					if(bezier.SetBeziers(order, xpoints) == Ok)
					{
						// Flatten() flattens Bezier.
						// The flattened points are already transformed.
						
                        DynPointFArray bezierFlattenPts;

                        bezier.Flatten(&bezierFlattenPts, matrix);
//						count = bezier.GetFlattenCount();
                        count = bezierFlattenPts.GetCount();

						// Check if there is already the first point.
						if(!isFirstPoint)
							count--;    // Don't add the first point.

						if (count > 0)
						{

							if((types = flattenTypes->AddMultiple(count)) != NULL)
							{
//								pts = bezier.GetFlattenData();
                                pts = bezierFlattenPts.GetDataBuffer();

								if(!isFirstPoint)
									pts++;  // Skip the first point.

								flattenPoints->AddMultiple(pts, count);
								GpMemset(types, PathPointTypeLine, count);
								if(isFirstPoint)
									types[0] = PathPointTypeStart;

								isFirstPoint = FALSE;
							}
							else
								status = OutOfMemory;

						}

					}
					else
						status =InvalidParameter;
				}

                break;           
            
            case PathPointTypeLine:
            default:
                count = typeEndIndex - typeStartIndex + 1;

                if(!isFirstPoint)
                    count--;

                if((types = flattenTypes->AddMultiple(count)) != NULL)
                {
                    // Set the type.

					GpMemset(types, PathPointTypeLine, count);
                    if(isFirstPoint)
                        types[0] = PathPointTypeStart;

					// Get the first data.

					REALD* dataPtr = data + typeStartIndex*dimension;
					if(!isFirstPoint)
						dataPtr += dimension;	// Skip the first point.

                    // Allocate the point buffer to save
					// for the flatten points.

					pts = (GpPointF*) GpRealloc(ptsBuffer,
						count*sizeof(GpPointF));

					if(!pts)
					{
						status = OutOfMemory;
						break;
					}
					else
						ptsBuffer = pts;

					// Copy the data

					GpPointF* ptsPtr = pts;

					for(INT k = 0; k < count; k++)
					{
						// Simply copy the first 2 elments
						// of the data as the x and y component.

						REALD x, y, w;

                        x = *dataPtr++;
						y = *dataPtr++;

                        // Do the perspective projection if
                        // dimension  is higher than 2.

                        if(dimension > 2)
                        {
                            w = *dataPtr;
                            x /= w;
                            y /= w;
                        }

                        ptsPtr->X = TOREAL(x);
                        ptsPtr->Y = TOREAL(y);

						ptsPtr++;
						
						// Skip the rest.

						if(dimension > 2)
							dataPtr += (dimension - 2);
					}

                    // Add to the flatten points.

					index = flattenPoints->GetCount();
					flattenPoints->AddMultiple(pts, count);

                    // Get the data biffer of the flatten points.

					pts = flattenPoints->GetDataBuffer();

                    // Transform the newly added points.

					matrix->Transform(pts + index, count);

                    isFirstPoint = FALSE;
                }
                
                break;
            }
        }

        // This is the end of the current subpath.  Close subpath
        // if necessary.

        if(isClosed)
        {
             BYTE* typeBuffer = flattenTypes->GetDataBuffer();
             INT lastCount = flattenTypes->GetCount();
             typeBuffer[lastCount - 1] |= PathPointTypeCloseSubpath;
        }
    }

	if(ptsBuffer)
		GpFree(ptsBuffer);

    return status;
}


/**************************************************************************\
*
* GpXPathIterator class
*
*   11/08/1999 ikkof
*       Created it.
*
\**************************************************************************/

GpXPathIterator::GpXPathIterator(GpXPath* xpath)
{
    Initialize();

    if(xpath && xpath->IsValid())
    {
        TotalCount = xpath->GetPointCount();
        XPoints.SetData(
            xpath->GetPathPoints(),
            xpath->GetPointDimension(),
            TotalCount,
            FALSE   // Don't copy data.
            );
        Types = xpath->GetPathTypes();
    }

    // Check if this path is valid.

    if(
        XPoints.Data
        && XPoints.Dimension > 0
        && XPoints.Count > 0
        && Types
        && TotalCount > 0
        )
    {
        SetValid(TRUE);
    }
}

VOID
GpXPathIterator::Initialize()
{
//    XPath = NULL;
    Types = NULL;
    TotalCount = 0;
    Index = 0;
    SubpathStartIndex = 0;
    SubpathEndIndex = 0;
    TypeStartIndex = 0;
    TypeEndIndex = 0;
    SetValid(FALSE);
}


INT
GpXPathIterator::Enumerate(GpXPoints* xpoints, BYTE* types)
{
    if(!IsValid())
        return 0;

    ASSERT(xpoints && types);
    if(xpoints == NULL || types == NULL)
        return 0;

    INT inputSize = xpoints->Dimension*xpoints->Count;

    ASSERT(xpoints->Data && inputSize > 0);
    if(xpoints->Data == NULL || inputSize <= 0)
        return 0;

    if(Index >= TotalCount)
        return 0;

    // Make sure the resultant dimension is the same as
    // the internal dimension.

    INT dimension = XPoints.Dimension;
    if(xpoints->Dimension != dimension)
    {
        xpoints->Dimension = dimension;
        xpoints->Count = inputSize/dimension;
    }

    INT number = min(TotalCount - Index, xpoints->Count);
    GpMemcpy(
        xpoints->Data,
        XPoints.Data + Index*dimension,
        number*dimension*sizeof(REALD));
    GpMemcpy(types, Types + Index, number*sizeof(BYTE));

    Index += number;
    
    return number;
}

INT
GpXPathIterator::NextSubpath(INT* startIndex, INT* endIndex, BOOL *isClosed)
{
    if(!IsValid())
        return 0;
    
    INT count = TotalCount;

    if(SubpathEndIndex >= count - 1)
        return 0;

    const BYTE* types = Types;

    INT i;

    // Set the starting index of the current subpath.

    if(SubpathEndIndex == 0)
    {
        SubpathStartIndex = 0;
        i = 1;
    }
    else
    {
        SubpathStartIndex = SubpathEndIndex + 1;
        SubpathEndIndex = SubpathStartIndex;
        i = SubpathStartIndex + 1;
    }

    BOOL hasData = FALSE;
    INT segmentCount = 0;

    while(i < count)
    {
        // Do the move segments.

        segmentCount = 0;
        while(i < count && (types[i] & PathPointTypePathTypeMask) == PathPointTypeStart)
        {
            segmentCount++;
            if(hasData)
            {
                break;
            }
            else
            {
                SubpathStartIndex = i;
                SubpathEndIndex = SubpathStartIndex;
                i++;
            }
        }
        if(segmentCount > 0 && hasData)
        {
            SubpathEndIndex = i - 1;
            break;
        }
        
        // Do the non-move segments.
        
        segmentCount = 0;
        BYTE nextType = types[i] & PathPointTypePathTypeMask;
        while(i < count && (types[i] & PathPointTypePathTypeMask) == nextType)
        {
            i++;
            segmentCount++;
        }
        if(segmentCount > 0)
        {
            hasData = TRUE;
        }
    }

    *startIndex = SubpathStartIndex;
    if(i >= count)
        SubpathEndIndex = count - 1;    // The last subpath.
    *endIndex = SubpathEndIndex;
    segmentCount = SubpathEndIndex - SubpathStartIndex + 1;
    if(segmentCount <= 1)   // Start and end point is the same.
        segmentCount = 0;

    if(segmentCount > 1)
    {
        // If there is the close flag or the start and end points match,
        // this subpath is closed.

        if(
            (types[SubpathEndIndex] & PathPointTypeCloseSubpath)
            || XPoints.AreEqualPoints(SubpathStartIndex, SubpathEndIndex)
        )
        {
            *isClosed = TRUE;
        }
        else
            *isClosed = FALSE;
    }
    else
        *isClosed = FALSE;
    
    // Set the current index to the starting index of the current subpath.

    Index = SubpathStartIndex;

    // Set the start and end index of type to be the starting index of
    // the current subpath.  NextPathType() will start from the
    // beginning of the current subpath.

    TypeStartIndex = TypeEndIndex = SubpathStartIndex;

    return segmentCount;
}


INT
GpXPathIterator::EnumerateSubpath(
    GpXPoints* xpoints,
    BYTE* types
    )
{
    if(!IsValid())
        return 0;

    ASSERT(xpoints && types);
    if(xpoints == NULL || types == NULL)
        return 0;
    
    INT inputSize = xpoints->Dimension*xpoints->Count;

    ASSERT(xpoints->Data && inputSize > 0);
    if(xpoints->Data == NULL || inputSize <= 0)
        return 0;

    if(Index > SubpathEndIndex)
        return 0;

    // Make sure the resultant dimension is the same as
    // the internal dimension.

    INT dimension = XPoints.Dimension;
    if(xpoints->Dimension != dimension)
    {
        xpoints->Dimension = dimension;
        xpoints->Count = inputSize/dimension;
    }

    INT number = min(SubpathEndIndex - Index + 1, xpoints->Count);

    GpMemcpy(
        xpoints->Data,
        XPoints.Data + Index*dimension,
        number*dimension*sizeof(REALD));
    GpMemcpy(types, Types + Index, number*sizeof(BYTE));

    Index += number;
    
    return number;
}


INT
GpXPathIterator::NextPathType(
    BYTE* pathType,
    INT* startIndex,
    INT* endIndex
    )
{
    if(!IsValid())
        return 0;
    
    if(TypeEndIndex >= SubpathEndIndex)
        return 0;   // There is no more segment in the current subpath.

    INT count = SubpathEndIndex + 1;    // Limit for the ending index.
    const BYTE* types = Types;

    TypeStartIndex = TypeEndIndex;
    INT i = TypeStartIndex;
    INT segmentCount = 0;

    i++;    // Go to the next point.

    while(i < count)
    {
        // Do the move segments.

        segmentCount = 0;
        while(i < count && (types[i] & PathPointTypePathTypeMask) == PathPointTypeStart)
        {
            // Move the start and end index.

            TypeStartIndex = i;
            TypeEndIndex = TypeStartIndex;
            i++;
            segmentCount++;
        }
        
        // Do the non-move segments.
        
        segmentCount = 0;
        BYTE nextType = types[i] & PathPointTypePathTypeMask;
        while(i < count && (types[i] & PathPointTypePathTypeMask) == nextType)
        {
            i++;
            segmentCount++;
        }
        if(segmentCount > 0)
        {
            TypeEndIndex = TypeStartIndex + segmentCount;
            *pathType = nextType;
            break;
        }
    }

    *startIndex = TypeStartIndex;
    *endIndex = TypeEndIndex;
    segmentCount = TypeEndIndex - TypeStartIndex + 1;
    if(segmentCount <= 1)
    {
        // Start and End type index is the same.  This means there is
        // no more segment left.

        segmentCount = 0;
    }

    // Set the current index to the starting index of the current subpath.

    Index = TypeStartIndex;

    return segmentCount;   
}


INT
GpXPathIterator::EnumeratePathType(
    GpXPoints* xpoints,
    BYTE* types
    )
{
    if(!IsValid())
        return 0;

    ASSERT(xpoints && types);
    if(xpoints == NULL || types == NULL)
        return 0;
    
    INT inputSize = xpoints->Dimension*xpoints->Count;

    ASSERT(xpoints->Data && inputSize > 0);
    if(xpoints->Data == NULL || inputSize <= 0)
        return 0;

    if(Index > TypeEndIndex)
        return 0;

    // Make sure the resultant dimension is the same as
    // the internal dimension.

    INT dimension = XPoints.Dimension;
    if(xpoints->Dimension != dimension)
    {
        xpoints->Dimension = dimension;
        xpoints->Count = inputSize/dimension;
    }

    INT number = min(TypeEndIndex - Index + 1, xpoints->Count);

    GpMemcpy(
        xpoints->Data,
        XPoints.Data + Index*dimension,
        number*dimension*sizeof(REALD));
    GpMemcpy(types, Types + Index, number*sizeof(BYTE));

    Index += number;
    
    return number;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\entry\xbezier.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1999  Microsoft Corporation
*
* Abstract:
*
*   Implementation of XBezier class and its DDA.
*
* History:
*
*   11/05/1999 ikkof
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"

//==========================================================================
// GpXBezier class
//==========================================================================

GpXBezier::~GpXBezier()
{
    if(Data)
        GpFree(Data);
}

GpStatus
GpXBezier::SetBeziers(INT order, const GpPointF* points, INT count)
{
    ASSERT(points && order > 1 && count > order && count % order == 1);

    if(!points || order <= 1 || count <= order || count % order != 1)
        return InvalidParameter;

    GpStatus status = Ok;
    INT totalSize = 2*count*sizeof(REALD);

    REALD* data = (REALD*) GpRealloc(Data, totalSize);
    if(data)
    {
        REALD* dataPtr = data;
        GpPointF* ptr = (GpPointF*) points;

        for(INT i = 0; i < count; i++)
        {
            *dataPtr++ = ptr->X;
            *dataPtr++ = ptr->Y;
            ptr++;
        }

        NthOrder = order;
        Dimension = 2;
        Count = count;
        Data = data;
        status = Ok;
    }
    else
        status = OutOfMemory;

    return status;
}

GpStatus
GpXBezier::SetBeziers(INT order, const GpXPoints& xpoints)
{
    ASSERT(xpoints.Count % order == 1);
    if(xpoints.Count % order != 1)
        return InvalidParameter;

    INT totalSize = xpoints.Dimension*xpoints.Count*sizeof(REALD);

    REALD* data = (REALD*) GpRealloc(Data, totalSize);
    if(data)
    {
        NthOrder = order;
        Dimension = xpoints.Dimension;
        Count = xpoints.Count;
        GpMemcpy(data, xpoints.Data, totalSize);
        Data = data;
    }

    return Ok;
}


/**************************************************************************\
*
* Function Description:
*
* Flattens the series of Bezier control points and stores
* the results to the arrays of the flatten points.
*
* Arguments:
*
*   [OUT] flattenPts - the returned flattend points.
*   [IN] matrix - Specifies the transform
*
* Return Value:
*
*   NONE
*
* Created:
*
*   11/05/1999 ikkof
*       Created it.
*
\**************************************************************************/
   
GpStatus
GpXBezier::Flatten(
    DynPointFArray* flattenPts,
    const GpMatrix *matrix
    )
{
    if(flattenPts == NULL)
        return InvalidParameter;

    GpXBezierDDA dda;
    REALD*  bezierData = Data;
    INT bezierDataStep = Dimension*NthOrder;
    BOOL isFirstBezier = TRUE;

    INT count = Count;

    flattenPts->Reset(FALSE);

    while(count > 1)
    {
        FlattenEachBezier(
            flattenPts,
            dda,
            isFirstBezier,
            matrix,
            bezierData);

        count -= NthOrder;
        bezierData += bezierDataStep;
        isFirstBezier = FALSE;
    }

    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
* Transforms the control points.
*
* Arguments:
*
*   [IN] matrix - Specifies the transform
*
* Return Value:
*
*   NONE
*
* Created:
*
*   11/05/1999 ikkof
*       Created it.
*
\**************************************************************************/
   
VOID
GpXBezier::Transform(
    GpMatrix *matrix
    )
{
    FPUStateSaver fpuState;

    if(matrix == NULL || !Data || Count <= 0)
        return;

    // Since this is the 2D transform, we transform only
    // the first two component.

    GpPointF pt;
    INT j = 0;

    for(INT i = 0; i < Count; i++)
    {
        pt.X = TOREAL(Data[j]);
        pt.Y = TOREAL(Data[j+1]);
        matrix->Transform(&pt, 1);
        Data[j] = pt.X;
        Data[j + 1] = pt.Y;
        j += Dimension;
    }
    
    return;
}

/**************************************************************************\
*
* Function Description:
*
*   Returns the bounds in the specified transform.
*   This first calculates the bounds of the control points
*   in the world coordinates.
*   Then it converts the bounds in the given transform.
*   Therefore, this is bigger than the real bounds.
*
* Arguments:
*
*   [IN] matrix - Specifies the transform
*   [OUT] bounds - Returns the bounding rectangle
*
* Return Value:
*
*   NONE
*
* Created:
*
*   12/16/1998 ikkof
*       Created it.
*
\**************************************************************************/

VOID
GpXBezier::GetBounds(
    GpMatrix* matrix,
    GpRect* bounds
    )
{
    ASSERT(IsValid());

    // Currently only Dimension = 2 case is implemented.

    if(Dimension != 2)
        return;

    INT count = Count;

    if (count == 0)
    {
        bounds->X = 0;
        bounds->Y = 0;
        bounds->Width = 0;
        bounds->Height = 0;
    }
    else
    {
        FPUStateSaver fpuState;

        REALD* data = Data;

        REALD left = *data;
        REALD right = left;
        REALD top = *data++;
        REALD bottom = top;
        count--;
        REALD x, y;

        while(count > 0)
        {
            x = *data++;
            y = *data++;

            if (x < left)
                left = x;
            if (y < top)
                top = y;
            if (x > right)
                right = x;
            if (y > bottom)
                bottom = y;
            count--;
        }

        GpRectF     boundsF;
        TransformBounds(
            matrix,
            TOREAL(left),
            TOREAL(top),
            TOREAL(right),
            TOREAL(bottom), &boundsF);
        BoundsFToRect(&boundsF, bounds);
    }
}

GpStatus
GpXBezier::Get2DPoints(
    GpPointF* points,
    INT count,
    const REALD* dataPoints,
    const GpMatrix* matrix)
{
    ASSERT(points && dataPoints && count > 0);

    if(points && dataPoints && count > 0)
    {
        FPUStateSaver fpuState;

        GpPointF* ptr = points;
        const REALD* dataPtr = dataPoints;
        INT i, j = 0;
        GpMatrix identityMatrix;
        const GpMatrix* mat = matrix;
        if(!mat)
            mat = &identityMatrix;

        switch(Dimension)
        {
        case 2:
            for(i = 0; i < count; i++)
            {
                ptr->X = TOREAL(*dataPtr++);
                ptr->Y = TOREAL(*dataPtr++);
                ptr++;
            }
            mat->Transform(points, count);
            break;

        case 3:
            for(i = 0; i < count; i++)
            {
                REALD x, y, w;
                x = *dataPtr++;
                y = *dataPtr++;
                w = *dataPtr++;

                // Do the perspective projection.

                ptr->X = TOREAL(x/w);
                ptr->Y = TOREAL(y/w);
                ptr++;
            }
            mat->Transform(points, count);

        default:
            // Not implemented yet.
            break;
        }

        return Ok;
    }

    return InvalidParameter;
}

/**************************************************************************\
*
* Function Description:
*
* Flattens a given cubic Bezier curve.
*
* Arguments:
*
*   [OUT] flattenPts - the returned flattend points.
*   [IN] points - the four control points for a Cubic Bezier
*
* Return Value:
*
*   NONE
*
* Created:
*
*   02/10/1999 ikkof
*       Created it.
*
\**************************************************************************/

GpStatus
GpXBezier::FlattenEachBezier(
    DynPointFArray* flattenPts,
    GpXBezierDDA& dda,
    BOOL isFirstBezier,
    const GpMatrix *matrix,
    const REALD* bezierData
    )
{
    GpPointF pts[7];

    if(Get2DPoints(&pts[0], NthOrder + 1, bezierData, matrix) != Ok)
        return GenericError;

    // Use DDA to flatten a Bezier.

    GpPointF nextPt;

    GpXPoints xpoints(&pts[0], NthOrder + 1);

    if(xpoints.Data == NULL)
        return OutOfMemory;

    dda.SetBezier(xpoints, FlatnessLimit, DistanceLimit);
    dda.InitDDA(&nextPt);

    GpPointF buffer[BZ_BUFF_SIZE];
    INT count = 0;

    // If this is the first Bezier curve, add the first point.

    if(isFirstBezier)
    {
        buffer[count++] = nextPt;
    }

    while(dda.GetNextPoint(&nextPt))
    {
        if(count < BZ_BUFF_SIZE)
            buffer[count++] = nextPt;
        else
        {
            flattenPts->AddMultiple(&buffer[0], count);
            buffer[0] = nextPt;
            count = 1;
        }
        dda.MoveForward();
    }
    
    // Add the last point.

    if(count < BZ_BUFF_SIZE)
        buffer[count++] = nextPt;
    else
    {
        flattenPts->AddMultiple(&buffer[0], count);
        buffer[0] = nextPt;
        count = 1;
    }
    flattenPts->AddMultiple(&buffer[0], count);

    return Ok;
}


/**************************************************************************\
*
* Function Description:
*
* Initialized constants needed for DDA of General Bezier.
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   NONE
*
* Created:
*
*   02/10/1999 ikkof
*       Created it.
*
\**************************************************************************/

GpXBezierConstants::GpXBezierConstants()
{
    INT i, j;


    for(i = 0; i <= 6; i++)
    {
        GpMemset(&H[i][0], 0, 7*sizeof(REAL));
        GpMemset(&D[i][0], 0, 7*sizeof(REAL));
        GpMemset(&S[i][0], 0, 7*sizeof(REAL));
    }

    // Matrix for half step
    H[0][0] = 1;
    H[1][0] = 0.5;      // = 1/2
    H[1][1] = 0.5;      // = 1/2
    H[2][0] = 0.25;     // = 1/4
    H[2][1] = 0.5;      // = 1/2
    H[2][2] = 0.25;     // = 1/4
    H[3][0] = 0.125;    // = 1/8
    H[3][1] = 0.375;    // = 3/8
    H[3][2] = 0.375;    // = 3/8
    H[3][3] = 0.125;    // = 1/8
    H[4][0] = 0.0625;   // = 1/16
    H[4][1] = 0.25;     // = 1/4
    H[4][2] = 0.375;    // = 3/8
    H[4][3] = 0.25;     // = 1/4
    H[4][4] = 0.0625;   // = 1/16
    H[5][0] = 0.03125;  // = 1/32
    H[5][1] = 0.15625;  // = 5/32
    H[5][2] = 0.3125;   // = 5/16
    H[5][3] = 0.3125;   // = 5/16
    H[5][4] = 0.15625;  // = 5/32
    H[5][5] = 0.03125;  // = 1/32
    H[6][0] = 0.015625; // = 1/64
    H[6][1] = 0.09375;  // = 3/32
    H[6][2] = 0.234375; // = 15/64
    H[6][3] = 0.3125;   // = 5/16
    H[6][4] = 0.234375; // = 15/64
    H[6][5] = 0.09375;  // = 3/32
    H[6][6] = 0.015625; // = 1/64

    // Matrix for double step
    D[0][0] = 1;
    D[1][0] = -1;
    D[1][1] = 2;
    D[2][0] = 1;
    D[2][1] = -4;
    D[2][2] = 4;
    D[3][0] = -1;
    D[3][1] = 6;
    D[3][2] = -12;
    D[3][3] = 8;
    D[4][0] = 1;
    D[4][1] = -8;
    D[4][2] = 24;
    D[4][3] = -32;
    D[4][4] = 16;
    D[5][0] = -1;
    D[5][1] = 10;
    D[5][2] = -40;
    D[5][3] = 80;
    D[5][4] = -80;
    D[5][5] = 32;
    D[6][0] = 1;
    D[6][1] = -12;
    D[6][2] = 60;
    D[6][3] = -160;
    D[6][4] = 240;
    D[6][5] = -192;
    D[6][6] = 64;

    // Matrix for one step
    S[0][0] = 1;
    S[1][0] = 2;
    S[1][1] = -1;
    S[2][0] = 4;
    S[2][1] = -4;
    S[2][2] = 1;
    S[3][0] = 8;
    S[3][1] = -12;
    S[3][2] = 6;
    S[3][3] = -1;
    S[4][0] = 16;
    S[4][1] = -32;
    S[4][2] = 24;
    S[4][3] = -8;
    S[4][4] = 1;
    S[5][0] = 32;
    S[5][1] = -80;
    S[5][2] = 80;
    S[5][3] = -40;
    S[5][4] = 10;
    S[5][5] = -1;
    S[6][0] = 64;
    S[6][1] = -192;
    S[6][2] = 240;
    S[6][3] = -160;
    S[6][4] = 60;
    S[6][5] = -12;
    S[6][6] = 1;

    F[0][0] = 1;
    F[0][1] = 1;
    F[0][2] = 1;
    F[0][3] = 1;
    F[0][4] = 1;
    F[0][5] = 1;
    F[0][6] = 1;
    F[1][1] = 1;
    F[1][2] = 2;
    F[1][3] = 3;
    F[1][4] = 4;
    F[1][5] = 5;
    F[1][6] = 6;
    F[2][2] = 1;
    F[2][3] = 3;
    F[2][4] = 6;
    F[2][5] = 10;
    F[2][6] = 15;
    F[3][3] = 1;
    F[3][4] = 4;
    F[3][5] = 10;
    F[3][6] = 20;
    F[4][4] = 1;
    F[4][5] = 5;
    F[4][6] = 15;
    F[5][5] = 1;
    F[5][6] = 6;
    F[6][6] = 1;

    H6[0][0] = 1;
    H6[1][0] = 1;
    H6[1][1] = 1.0/6;
    H6[2][0] = 1;
    H6[2][1] = 1.0/3;
    H6[2][2] = 1.0/15;
    H6[3][0] = 1;
    H6[3][1] = 1.0/2;
    H6[3][2] = 1.0/5;
    H6[3][3] = 1.0/20;
    H6[4][0] = 1;
    H6[4][1] = 2.0/3;
    H6[4][2] = 2.0/5;
    H6[4][3] = 1.0/5;
    H6[4][4] = 1.0/15;
    H6[5][0] = 1;
    H6[5][1] = 5.0/6;
    H6[5][2] = 2.0/3;
    H6[5][3] = 1.0/2;
    H6[5][4] = 1.0/3;
    H6[5][5] = 1.0/6;
    H6[6][0] = 1;
    H6[6][1] = 1;
    H6[6][2] = 1;
    H6[6][3] = 1;
    H6[6][4] = 1;
    H6[6][5] = 1;
    H6[6][6] = 1;

    G6[0][0] = 1;
    G6[1][0] = -6;
    G6[1][1] = 6;
    G6[2][0] = 15;
    G6[2][1] = -30;
    G6[2][2] = 15;
    G6[3][0] = -20;
    G6[3][1] = 60;
    G6[3][2] = -60;
    G6[3][3] = 20;
    G6[4][0] = 15;
    G6[4][1] = -60;
    G6[4][2] = 90;
    G6[4][3] = -60;
    G6[4][4] = 15;
    G6[5][0] = -6;
    G6[5][1] = 30;
    G6[5][2] = -60;
    G6[5][3] = 60;
    G6[5][4] = -30;
    G6[5][5] = 6;
    G6[6][0] = 1;
    G6[6][1] = -6;
    G6[6][2] = 15;
    G6[6][3] = -20;
    G6[6][4] = 15;
    G6[6][5] = -6;
    G6[6][6] = 1;
}

GpStatus
GpXPoints::Transform(const GpMatrix* matrix)
{
    return TransformPoints(matrix, Data, Dimension, Count);
}

GpStatus
GpXPoints::TransformPoints(
    const GpMatrix* matrix,
    REALD* data,
    INT dimension,
    INT count
    )
{
    if(matrix == NULL || data == NULL
        || dimension == 0 || count == 0)
        return Ok;

    // !! This code should consider using Matrix->Transform.
    if(dimension >= 2)
    {
        FPUStateSaver fpuState;

        INT j = 0;

        // Transform only the first two axis.

        for(INT i = 0; i < count; i++)
        {
            GpPointF pt;

            pt.X = TOREAL(data[j]);
            pt.Y = TOREAL(data[j + 1]);
            matrix->Transform(&pt);
            data[j] = pt.X;
            data[j + 1] = pt.Y;
            
            j += dimension;
        }

        return Ok;
    }
    else
        return GenericError;
}


//==========================================================================
// Cubic Bezier class
//
// GpXBezierDDA class
//
// This is based on GDI's flatten path methods written
// by Paul Butzi and J. Andrew Gossen.
// Ikko Fushiki wrote this with different parameters
// and different flatness tests.
//==========================================================================

VOID
GpXBezierDDA::Initialize(
    VOID
    )
{
    INT i;

    T = 0;
    Dt = 1;
    NthOrder = 0;
    GpMemset(&P[0], 0, 16*sizeof(REALD));
    GpMemset(&Q[0], 0, 16*sizeof(REALD));

    NSteps = 1;
    
    // In order to avoid the later multiplication, we pre-multiply
    // the flatness limit by 3.
    FlatnessLimit = 3*FLATNESS_LIMIT;
    DistanceLimit = DISTANCE_LIMIT;
}

/**************************************************************************\
*
* Function Description:
*
* Set the control points of a CubicBezier.
*
* Arguments:
*
*   [IN] points - the four control points for a Cubic Bezier
*   [IN] flatnessLimit - used for flattening
*   [IN] distanceLimit - used for flattening
*
* Return Value:
*
*   NONE
*
* Created:
*
*   02/10/1999 ikkof
*       Created it.
*
\**************************************************************************/

VOID
GpXBezierDDA::SetBezier(
    const GpXPoints& xpoints,
    REAL flatnessLimit,
    REAL distanceLimit    
    )
{
    if(xpoints.Data == NULL)
        return;

    T = 0;
    Dt = 1;
    NthOrder = 0;
    INT totalCount = xpoints.Count*xpoints.Dimension;

    // This can handle the two dimensional Bezier of 6-th order
    // and the three and four dimensional Bezier of 3rd order.

    ASSERT(totalCount < 16);

    NthOrder = xpoints.Count - 1;
    Dimension = xpoints.Dimension;

    GpMemcpy(&Q[0], xpoints.Data, totalCount*sizeof(REALD));

    SetPolynomicalCoefficients();

    NSteps = 1;
    
    // In order to avoid the later multiplication, we pre-multiply
    // the flatness limit by 3.
    FlatnessLimit = 3*flatnessLimit;
    DistanceLimit = distanceLimit;
}

VOID
GpXBezierDDA::SetPolynomicalCoefficients(
    VOID
    )
{
    if(NthOrder == 6)
    {
        for(INT i = 0; i <= 6; i++)
        {
            REALD x[4];
            GpMemset(&x[0], 0, Dimension*sizeof(REALD));
            
            INT k, k0;

            for(INT j = 0; j <= i; j++)
            {
                k0 = Dimension*j;
                k = 0;

                while(k < Dimension)
                {
                    x[k] += C.G6[i][j]*Q[k0 + k];
                    k++;
                }
            }

            k0 = Dimension*i;
            GpMemcpy(&P[k0], &x[0], Dimension*sizeof(REALD));
        }
    }
}


/**************************************************************************\
*
* Function Description:
*
* Initializes DDA for CubicBezier and make one step forward.
* This must be called before GetNextPoint() is called.
*
* Arguments:
*
*   [OUT] pt - Returns the start point
*
* Return Value:
*
*   NONE
*
* Created:
*
*   02/10/1999 ikkof
*       Created it.
*
\**************************************************************************/

VOID
GpXBezierDDA::InitDDA(
    GpPointF* pt
    )
{
    switch(Dimension)
    {
    case 2:
        pt->X = (REAL) Q[0];
        pt->Y = (REAL) Q[1];
        break;

    case 3:
        // Do something
        break;

    default:
        // Do something
        break;
    }

    INT shift = 2;

    // Subdivide fast until it is flat enough
    while(NeedsSubdivide(FlatnessLimit))
    {
        HalveStepSize();
//        FastShrinkStepSize(shift);
    }

    // If it is subdivided too much, expand it.
    if((NSteps & 1) == 0)
    {
        // If the current subdivide is too small,
        // double it up.
        while(NSteps > 1 && !NeedsSubdivide(FlatnessLimit/4))
        {
            DoubleStepSize();
        }
    }

    // Take the first step forward.
    TakeStep();
}

/**************************************************************************\
*
* Function Description:
*
* Shrinks the current Bezier segment to half.
* The section of t = 0 -> 1/2 of the current
* Beizer segment becomes the new current segment.
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   NONE
*
* Created:
*
*   02/10/1999 ikkof
*       Created it.
*
\**************************************************************************/

VOID
GpXBezierDDA::HalveStepSize(
    VOID
    )
{
    INT i, j;
    REALD x[4];
    
    i = NthOrder;

    while(i >= 0)
    {
        j = i;

        GpMemset(&x[0], 0, Dimension*sizeof(REALD));
        
        INT k0, k;

        while(j >= 0)
        {
            k0 = Dimension*j;
            k = 0;
            while(k < Dimension)
            {
                x[k] += C.H[i][j]*Q[k0 + k];
                k++;
            }
               
            j--;
        }

        k0 = Dimension*i;
        GpMemcpy(&Q[k0], &x[0], Dimension*sizeof(REALD));
        i--;
    }

    NSteps <<= 1;   // The number of steps needed is doubled.
    Dt *= 0.5;
}

/**************************************************************************\
*
* Function Description:
*
* Doubles the current Bezier segment.
* The section of t = 0 -> 2 of the current
* Bezier segment becomes the new current segment.
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   NONE
*
* Created:
*
*   02/10/1999 ikkof
*       Created it.
*
\**************************************************************************/

VOID
GpXBezierDDA::DoubleStepSize(
    VOID
    )
{
    INT i, j;
    REALD   x[4];
    
    i = NthOrder;

    while(i >= 0)
    {
        j = i;

        GpMemset(&x[0], 0, Dimension*sizeof(REALD));

        INT k, k0;

        while(j >= 0)
        {
            k0 = Dimension*j;
            k = 0;

            while(k < Dimension)
            {
                x[k] += C.D[i][j]*Q[k0 + k];
                k++;
            }
            
            j--;
        }

        k0 = Dimension*i;
        GpMemcpy(&Q[k0], &x[0], Dimension*sizeof(REALD));
        i--;
    }

    NSteps >>= 1;   // The number of steps needed is halved.
    Dt *= 2;
}

/**************************************************************************\
*
* Function Description:
*
* Shrinks the current Bezier segment by (2^shift).
* The section of t = 0 -> 1/(2^shift) of the current
* Beizer segment becomes the new current segment.
* If shift > 0, this shrinks the step size.
* If shift < 0, this enlarge the step size.
*
* halfStepSize() is equal to fastShrinkStepSize(1).
* doubleStepSize() is equal to fastShrinkStepSize(-1).
*
* Arguments:
*
*   [INT] shift - the bits to shift
*
* Return Value:
*
*   NONE
*
* Created:
*
*   02/10/1998 ikkof
*       Created it.
*
\**************************************************************************/

VOID
GpXBezierDDA::FastShrinkStepSize(
    INT shift
    )
{
/*
    INT n = 1;
    if(shift > 0) {
        n <<= shift;
        Cx /= n;
        Cy /= n;
        n <<= shift;
        Bx /= n;
        By /= n;
        n <<= shift;
        Ax /= n;
        Ay /= n;

        NSteps <<= shift;   // Increase the number of steps.
    }
    else if(shift < 0) {
        n <<= - shift;
        Cx *= n;
        Cy *= n;
        n <<= - shift;
        Bx *= n;
        By *= n;
        n <<= - shift;
        Ax *= n;
        Ay *= n;

        NSteps >>= - shift; // Reduce the number of steps.
    }

    // Dx and Dy remain the same.
*/
}

/**************************************************************************\
*
* Function Description:
*
* Advances the current Bezeir segment to the next one.
* The section of t = 1 -> 2 of the current Bezier segment
* becoms the new current segment.
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   NONE
*
* Created:
*
*   12/16/1998 ikkof
*       Created it.
*
\**************************************************************************/

VOID
GpXBezierDDA::TakeStep(
    VOID
    )
{
    REALD p[16];

    INT i, j;
    REALD x[4];
    
    i = NthOrder;

    if(NthOrder != 6)
    {
        while(i >= 0)
        {
            j = i;

            GpMemset(&x[0], 0, Dimension*sizeof(REALD));

            INT k0, k;

            while(j >= 0)
            {
                k0 = Dimension*(NthOrder - j);
                k = 0;

                while(k < Dimension)
                {
                    x[k] += C.S[i][j]*Q[k0 + k];
                    k++;
                }
                j--;
            }

            k0 = Dimension*i;
            k = 0;

            while(k < Dimension)
            {
                p[k0 + k] = x[k];
                k++;
            }
            i--;
        }

        GpMemcpy(&Q[0], &p[0], Dimension*(NthOrder + 1)*sizeof(REALD));
    }
    else
        TakeConvergentStep();

    NSteps--;   // Reduce one step.
    T += Dt;
}

VOID
GpXBezierDDA::TakeConvergentStep(
    VOID
    )
{
    REALD t[7], dt[7];
    INT i, j;

    t[0] = dt[0] = 1;
    for(i = 1; i <= 6; i++)
    {
        t[i] = t[i-1]*T;
        dt[i] = dt[i-1]*Dt;
    }

    REALD c[16];
    REALD x[4];
    INT k0, k;

    for(i = 0; i <= 6; i++)
    {
        GpMemset(&x[0], 0, Dimension*sizeof(REALD));

        for(j = i; j <= 6; j++)
        {
            k0 = Dimension*j;

            for(k = 0; k < Dimension; k++)
            {
                x[k] += C.F[i][j]*t[j-i]*dt[i]*P[k0 + k];
            }
        }

        k0 = Dimension*i;
        GpMemcpy(&c[k0], &x[0], Dimension*sizeof(REALD));
    }

    for(i = 0; i <= 6; i++)
    {
        GpMemset(&x[0], 0, Dimension*sizeof(REALD));

        for(j = 0; j <= i; j++)
        {
            k0 = Dimension*j;
            
            for(k = 0; k < Dimension; k++)
            {
                x[k] += C.H6[i][j]*c[k0 + k];
            }
        }
        
        k0 = Dimension*i;
        GpMemcpy(&Q[k0], &x[0], Dimension*sizeof(REALD));
    }
}
    
BOOL
GpXBezierDDA::Get2DDistanceVector(
    REALD* dx,
    REALD* dy,
    INT from,
    INT to
    )
{
    REALD p0[16], p1[16];
    INT k0, k;

    if(from < 0 || from > NthOrder || to < 0 || to > NthOrder)
        return FALSE;

    k0 = from*Dimension;
    GpMemcpy(&p0[0], &Q[k0], Dimension*sizeof(REALD));

    k0 = to*Dimension;
    GpMemcpy(&p1[0], &Q[k0], Dimension*sizeof(REALD));

    *dx = p1[0] - p0[0];
    *dy = p1[1] - p0[1];

    return TRUE;
}

/**************************************************************************\
*
* Function Description:
*
* Reurns true if more subdivision is necessary.
*
* Arguments:
*
*   [IN] flatnessLimit - flatness parameter
*
* Return Value:
*
*   Returns true if subdivision is necessary. Otherwise this returns false.
*
* Created:
*
*   02/10/1999 ikkof
*       Created it.
*
\**************************************************************************/

BOOL
GpXBezierDDA::NeedsSubdivide(
    REAL flatnessLimit
    )
{
    REALD mx, my;
    REALD baseLen;
    REALD dx, dy;

    // Get the base line vector.

    if(!Get2DDistanceVector(&dx, &dy, 0, NthOrder))
        return FALSE;
    
    // Get the perpendicular vector to the base line

    mx = - dy;
    my = dx;

    // Approximate the distance by absolute values of x and y components.
 
    baseLen = fabs(mx) + fabs(my);

    BOOL needsSubdivide = FALSE;

    // First check if the base length is larger than the distance limit.
    if(baseLen > DistanceLimit)
    {
        // Pre-multiply baseLen by flatness limit for convenience.
        baseLen *= flatnessLimit;
        
        INT i = 1;

        while(i < NthOrder && !needsSubdivide)
        {
            Get2DDistanceVector(&dx, &dy, 0, i);

            if(fabs(dx*mx + dy*my) > baseLen)
                needsSubdivide = TRUE;
            i++;
        }
    }

    return needsSubdivide;
}

/**************************************************************************\
*
* Function Description:
*
* Returns the current start point.
* If this has reached the end point, this returns false.
*
* Arguments:
*
*   [OUT] pt - the current start point.
*
* Return Value:
*
*   Returns true if there is a next point.
*
* Created:
*
*   02/10/1999 ikkof
*       Created it.
*
\**************************************************************************/

BOOL
GpXBezierDDA::GetNextPoint(
    GpPointF* pt
    )
{
    // Copy the current start point;

    FPUStateSaver fpuState;

    switch(Dimension)
    {
    case 2:
        pt->X = TOREAL(Q[0]);
        pt->Y = TOREAL(Q[1]);
        break;

    case 3:
    default:
        // Do something for projection.
        return FALSE;
    }

    if(NSteps != 0)
        return TRUE;
    else
        return FALSE;   // Congratulations!  You have reached the end.
}

/**************************************************************************\
*
* Function Description:
*
* Moves to the next Bezier segment
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   NONE
*
* Created:
*
*   02/10/1999 ikkof
*       Created it.
*
\**************************************************************************/

VOID
GpXBezierDDA::MoveForward(
    VOID
    )
{
    // If the current subdivide is too big,
    // subdivide it.
    while(NeedsSubdivide(FlatnessLimit))
    {
        HalveStepSize();
    }


    if((NSteps & 1) == 0)
    {
        // If the current subdivide is too small,
        // double it up.
        while(NSteps > 1 && !NeedsSubdivide(FlatnessLimit/4))
        {
            DoubleStepSize();
        }
    }

    // Move to the next Bezier segment.
    TakeStep();
}

/**************************************************************************\
*
* Function Description:
*
* Returns the control points of the last Bezier segment
* which ends at the current point.
* The current point is given by calling getNextPoint().
* pts[] must have the dimension of 4.
*
* Arguments:
*
*   [OUT] pts - the Bezier control points
*
* Return Value:
*
*   NONE
*
* Created:
*
*   02/10/1999 ikkof
*       Created it.
*
\**************************************************************************/

INT
GpXBezierDDA::GetControlPoints(
        GpXPoints* xpoints
    )
{
    ASSERT(xpoints);

    if(xpoints == NULL)
        return 0;

    INT totalCount = Dimension*(NthOrder + 1);
    REALD* buff = (REALD*) GpRealloc(xpoints->Data, totalCount*sizeof(REALD));
    if(buff)
    {
        GpMemcpy(buff, &Q[0], Dimension*(NthOrder + 1)*sizeof(REALD));
        xpoints->Count = NthOrder + 1;
        xpoints->Dimension = Dimension;
        xpoints->Data = buff;

        return NthOrder + 1;
    }
    else
        return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\entry\xbezier.hpp ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   XBezier.hpp
*
* Abstract:
*
*   Interface of GpXBezier and its DDA classes
*
* Revision History:
*
*   11/05/1999 ikkof
*       Created it.
*
\**************************************************************************/

#ifndef _XBEZIER_HPP
#define _XBEZIER_HPP

#define FLATNESS_LIMIT      0.25
#define DISTANCE_LIMIT      2.0
#define BZ_BUFF_SIZE    32

class GpXPoints
{
friend class GpXPath;
friend class GpXBezier;

public:

    INT Dimension;
    INT Count;  // Number of Points
    REALD* Data;

protected:
    BOOL IsDataAllocated;

public:

    GpXPoints()
    {
        Initialize();
    }

    // When XPoints is created from a given data with copyData = FALSE,
    // the caller is responsible for deleting the data after XPoints is no longer
    // used.

    GpXPoints(REALD* data, INT dimension, INT count, BOOL copyData = TRUE)
    {
        Initialize();
        SetData(data, dimension, count, copyData);
    }

    GpXPoints(GpPointF* points, INT count)
    {
        Initialize();

        if(points && count > 0)
        {
            Data = (REALD*) GpMalloc(2*count*sizeof(REALD));
            if(Data)
            {
                INT i = 0, j = 0;

                while(j < count)
                {
                    Data[i++] = points[j].X;
                    Data[i++] = points[j].Y;
                    j++;
                }
                Dimension = 2;
                Count = count;
                IsDataAllocated = TRUE;
            }
        }
    }

    GpXPoints(GpPointD* points, INT count)
    {
        Initialize();

        if(points && count > 0)
        {
            Data = (REALD*) GpMalloc(2*count*sizeof(REALD));
            if(Data)
            {
                INT i = 0, j = 0;

                while(j < count)
                {
                    Data[i++] = points[j].X;
                    Data[i++] = points[j].Y;
                    j++;
                }
                Dimension = 2;
                Count = count;
                IsDataAllocated = TRUE;
            }
        }
    }

    REALD* GetData() {return Data;}

    // When XPoints is created from a given data with copyData = FALSE,
    // the caller is responsible for deleting the data after XPoints is no longer
    // used.

    GpStatus
    SetData(REALD* data, INT dimension, INT count, BOOL copyData = TRUE)
    {
        GpStatus status = Ok;

        if(data && dimension > 0 || count > 0)
        {
            REALD* newData = NULL;

            if(copyData)
            {
               INT totalSize = dimension*count*sizeof(REALD);
               if(IsDataAllocated)
                   newData = (REALD*) GpRealloc(Data, totalSize);
               else
                   newData = (REALD*) GpMalloc(totalSize);

                if(newData)
                {
                    GpMemcpy(newData, data, totalSize);
                    IsDataAllocated;
                }
                else
                    status = OutOfMemory;
            }
            else
            {
                if(Data && IsDataAllocated)
                    GpFree(Data);
                newData = data;
                IsDataAllocated = FALSE;
            }

            if(status == Ok)
            {
                Dimension = dimension;
                Count = count;
                Data = newData;
            }
        }
        else
            status = InvalidParameter;

        return status;
    }

    GpStatus Transform(const GpMatrix* matrix);

    BOOL AreEqualPoints(INT index1, INT index2)
    {
        if(index1 < 0 || index1 >= Count
            || index2 < 0 || index2 >= Count || Data == NULL)
            return FALSE;   // either index is out of the range or no data.

        BOOL areEqual = TRUE;
        if(index1 != index2)
        {
            REALD* data1 = Data + index1*Dimension;
            REALD* data2 = Data + index2*Dimension;
            INT k = 0;
            while(k < Dimension && areEqual)
            {
                if(*data1++ != *data2++)
                    areEqual = FALSE;
                k++;
            }
        }

        return areEqual;
    }
            
    static GpStatus
    GpXPoints::TransformPoints(
        const GpMatrix* matrix,
        REALD* data,
        INT dimension,
        INT count
        );

    ~GpXPoints()
    {
        if(Data && IsDataAllocated)
            GpFree(Data);
    }

protected:
    VOID Initialize()
    {
        Dimension = 0;
        Count = 0;
        Data = NULL;
        IsDataAllocated = FALSE;
    }
};

//********************************************************
// GpXBezierDDA class
//********************************************************

class GpXBezierConstants
{
friend class GpXBezierDDA;

private:
    REALD   H[7][7];    // Half step
    REALD   D[7][7];    // Double step
    REALD   S[7][7];    // One step
    REALD   F[7][7];    // Polynomical transform.
    REALD   H6[7][7];   // Poly to Bez transform in 6th order.
    REALD   G6[7][7];   // Bez to Poly transform in 6th order.

public:
    GpXBezierConstants();
};

class GpXBezierDDA
{
protected:
    GpXBezierConstants C;

protected:
    REALD   T;
    REALD   Dt;
    REALD   Q[16];
    REALD   P[16];
    INT     NthOrder;
    INT     Dimension;
    INT     NSteps;
    REAL    FlatnessLimit;
    REAL    DistanceLimit;

public:

public:

    GpXBezierDDA() { Initialize(); }

    GpXBezierDDA(
        const GpXPoints& xpoints,
        REAL flatnessLimit = FLATNESS_LIMIT,
        REAL distanceLimit = DISTANCE_LIMIT
        )
    {
        Initialize();
        SetBezier(xpoints, flatnessLimit, distanceLimit);
    }

    VOID
    SetBezier(
        const GpXPoints& xpoints,
        REAL flatnessLimit = FLATNESS_LIMIT,
        REAL distanceLimit = DISTANCE_LIMIT
        );

    INT  GetSteps() { return NSteps; }

    VOID InitDDA(GpPointF* pt);
    VOID HalveStepSize();
    VOID DoubleStepSize();
    VOID FastShrinkStepSize(INT shift);
    VOID TakeStep();
    BOOL NeedsSubdivide(REAL itsFlatnessLimit);
    BOOL GetNextPoint(GpPointF* pt);
    VOID MoveForward();
    INT GetControlPoints(GpXPoints* xpoints);

protected:

    VOID Initialize();
    VOID SetPolynomicalCoefficients();
    VOID TakeConvergentStep();
    BOOL Get2DDistanceVector(REALD* dx, REALD* dy, INT from, INT to);
};

//************************************
// XBezier class
//************************************

#define NthOrderMax     6

class GpXBezier 
{
private:
    // We now use an ObjectTag to determine if the object is valid
    // instead of using a BOOL.  This is much more robust and helps
    // with debugging.  It also enables us to version our objects
    // more easily with a version number in the ObjectTag.
    ObjectTag           Tag;    // Keep this as the 1st value in the object!

protected:
    VOID SetValid(BOOL valid)
    {
        Tag = valid ? ObjectTagGpBezier : ObjectTagInvalid;
    }

public:
    BOOL IsValid() const
    {
        ASSERT((Tag == ObjectTagGpBezier) || (Tag == ObjectTagInvalid)); 
    #if DBG
        if (Tag == ObjectTagInvalid)
        {
            WARNING1("Invalid GpBezier");
        }
    #endif

        return (Tag == ObjectTagGpBezier);
    }

    GpXBezier()
    {
        Initialize();
    }

    GpXBezier(INT order, const GpPointF* points, INT count)
    {        
        Initialize();
        SetValid(SetBeziers(order, points, count));
    }

    GpXBezier(INT order, const GpXPoints& xpoints)
    {
        Initialize();
        SetValid(SetBeziers(order, xpoints));
    }

    ~GpXBezier();

    GpStatus SetBeziers(INT order, const GpPointF* points, INT count);

    GpStatus SetBeziers(INT order, const GpXPoints& xpoints);

    virtual INT GetControlCount() {return Count;}
    virtual VOID GetBounds(GpMatrix* matrix, GpRect* bounds);
    virtual VOID Transform(GpMatrix* matrix);
    virtual GpStatus Flatten(
                        DynPointFArray* flattenPts,
                        const GpMatrix* matrix);

protected:

    VOID Initialize()
    {
        NthOrder = 0;
        Dimension = 0;
        Count = 0;
        Data = NULL;
        FlatnessLimit = FLATNESS_LIMIT;
        DistanceLimit = DISTANCE_LIMIT;
        SetValid(TRUE);
    }

    GpStatus
    FlattenEachBezier(
        DynPointFArray* flattenPts,
        GpXBezierDDA& dda,
        BOOL isFirstBezier,
        const GpMatrix* matrix,
        const REALD* bezierData
        );

    GpStatus
    Get2DPoints(
        GpPointF* points,
        INT count,
        const REALD* dataPoints,
        const GpMatrix* matrix = NULL);

    GpStatus CheckInputData(const GpPointF* points, INT count)
    {
        GpStatus status = InvalidParameter;
        if(NthOrder > 0)
        {
            if(count > NthOrder)
            {
                INT reminder = count % NthOrder;
                if(reminder == 1 && points !=NULL)
                    status = Ok;
            }
        }
        else    // NthOrder <= 0
        {
            if(count > 1 && points != NULL)
            {
                if(count <= NthOrderMax + 1)
                {
                    NthOrder = count - 1;
                    status = Ok;
                }
            }
        }

        return status;
    }

protected:  // GDI+ INTERNAL
    // Following are the two values to determin the flatness.
    REAL            FlatnessLimit;  // The maximum flateness.
    REAL            DistanceLimit;  // The minimum distance.

private:    // GDI+ INTERNAL
    INT NthOrder;
    INT Dimension;
    INT Count;
    REALD*  Data;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\flat\gpverp.h ===
/**************************************************************************
*
* Copyright (c) 2001 Microsoft Corporation
*
* Module Name:
*
*   GpVerp
*
*   GDI+ version number control.
*
**************************************************************************/

#pragma once

#include <ntverp.h>

// NOTE: we use the NT version number and build number. If we choose to 
// have finer grain build numbers for any reason, we can override the
// minor (QFE) number for sub-NT build numbers.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\flat\flatddi.cpp ===
/**************************************************************************\
*
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   flatddi.cpp
*
* Abstract:
*
*   Flat GDI+ DDI API wrappers
*
* Revision History:
*
*   1/14/2k ericvan
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"

DpPath*
WINGDIPAPI
DpcCreateWidenedPath(
    const DpPath* path, 
    const DpPen* pen, 
    DpContext* context,
    BOOL outline
    )
{
    ASSERT(path && pen);
    
    // context can be NULL
    return GpPath::DriverCreateWidenedPath(
        path, 
        pen, 
        context,
        outline
    );
}

VOID
WINGDIPAPI
DpcDeletePath(
    DpPath* path
    )
{
    ASSERT(path);
    
    GpPath::DriverDeletePath(path);
}

DpPath*
WINGDIPAPI
DpcClonePath(
    DpPath* path
    )
{
    ASSERT(path);

    return GpPath::DriverClonePath(path);
}

VOID
WINGDIPAPI
DpcTransformPath(
    DpPath* path,
    GpMatrix* matrix
    )
{
    ASSERT(path);   // matrix can be NULL.

    GpPath::DriverTransformPath(path, matrix);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\flat\flatapi.inc ===
MONITOR(GdipDisplayPaletteWindowNotify),
MONITOR(GdipCreatePath),
MONITOR(GdipCreatePath2),
MONITOR(GdipCreatePath2I),
MONITOR(GdipClonePath),
MONITOR(GdipDeletePath),
MONITOR(GdipResetPath),
MONITOR(GdipGetPointCount),
MONITOR(GdipGetPathTypes),
MONITOR(GdipGetPathPoints),
MONITOR(GdipGetPathPointsI),
MONITOR(GdipGetPathFillMode),
MONITOR(GdipSetPathFillMode),
MONITOR(GdipSetPathData),
MONITOR(GdipGetPathData),
MONITOR(GdipStartPathFigure),
MONITOR(GdipClosePathFigure),
MONITOR(GdipClosePathFigures),
MONITOR(GdipSetPathMarker),
MONITOR(GdipClearPathMarkers),
MONITOR(GdipReversePath),
MONITOR(GdipGetPathLastPoint),
MONITOR(GdipAddPathLine),
MONITOR(GdipAddPathLineI),
MONITOR(GdipAddPathLine2),
MONITOR(GdipAddPathLine2I),
MONITOR(GdipAddPathArc),
MONITOR(GdipAddPathArcI),
MONITOR(GdipAddPathBezier),
MONITOR(GdipAddPathBezierI),
MONITOR(GdipAddPathBeziers),
MONITOR(GdipAddPathBeziersI),
MONITOR(GdipAddPathCurve),
MONITOR(GdipAddPathCurveI),
MONITOR(GdipAddPathCurve2),
MONITOR(GdipAddPathCurve2I),
MONITOR(GdipAddPathCurve3),
MONITOR(GdipAddPathCurve3I),
MONITOR(GdipAddPathClosedCurve),
MONITOR(GdipAddPathClosedCurveI),
MONITOR(GdipAddPathClosedCurve2),
MONITOR(GdipAddPathClosedCurve2I),
MONITOR(GdipAddPathRectangle),
MONITOR(GdipAddPathRectangleI),
MONITOR(GdipAddPathRectangles),
MONITOR(GdipAddPathRectanglesI),
MONITOR(GdipAddPathEllipse),
MONITOR(GdipAddPathEllipseI),
MONITOR(GdipAddPathPie),
MONITOR(GdipAddPathPieI),
MONITOR(GdipAddPathPolygon),
MONITOR(GdipAddPathPolygonI),
MONITOR(GdipAddPathPath),
MONITOR(GdipAddPathString),
MONITOR(GdipAddPathStringI),
MONITOR(GdipFlattenPath),
MONITOR(GdipWidenPath),
MONITOR(GdipWidenPathWithMinimumResolutions),
MONITOR(GdipWindingModeOutline),
MONITOR(GdipWarpPath),
MONITOR(GdipTransformPath),
MONITOR(GdipGetPathWorldBounds),
MONITOR(GdipGetPathWorldBoundsI),
MONITOR(GdipIsVisiblePathPoint),
MONITOR(GdipIsVisiblePathPointI),
MONITOR(GdipIsOutlineVisiblePathPoint),
MONITOR(GdipIsOutlineVisiblePathPointI),
MONITOR(GdipCreatePathIter),
MONITOR(GdipDeletePathIter),
MONITOR(GdipPathIterNextSubpath),
MONITOR(GdipPathIterNextSubpathPath),
MONITOR(GdipPathIterNextPathType),
MONITOR(GdipPathIterNextMarker),
MONITOR(GdipPathIterNextMarkerPath),
MONITOR(GdipPathIterGetCount),
MONITOR(GdipPathIterGetSubpathCount),
MONITOR(GdipPathIterIsValid),
MONITOR(GdipPathIterHasCurve),
MONITOR(GdipPathIterRewind),
MONITOR(GdipPathIterEnumerate),
MONITOR(GdipPathIterCopyData),
MONITOR(GdipCreateMatrix),
MONITOR(GdipCreateMatrix2),
MONITOR(GdipCreateMatrix3),
MONITOR(GdipCreateMatrix3I),
MONITOR(GdipCloneMatrix),
MONITOR(GdipDeleteMatrix),
MONITOR(GdipSetMatrixElements),
MONITOR(GdipMultiplyMatrix),
MONITOR(GdipTranslateMatrix),
MONITOR(GdipScaleMatrix),
MONITOR(GdipRotateMatrix),
MONITOR(GdipShearMatrix),
MONITOR(GdipInvertMatrix),
MONITOR(GdipTransformMatrixPoints),
MONITOR(GdipTransformMatrixPointsI),
MONITOR(GdipVectorTransformMatrixPoints),
MONITOR(GdipVectorTransformMatrixPointsI),
MONITOR(GdipGetMatrixElements),
MONITOR(GdipIsMatrixInvertible),
MONITOR(GdipIsMatrixIdentity),
MONITOR(GdipIsMatrixEqual),
MONITOR(GdipCreateRegion),
MONITOR(GdipCreateRegionRect),
MONITOR(GdipCreateRegionRectI),
MONITOR(GdipCreateRegionPath),
MONITOR(GdipCreateRegionRgnData),
MONITOR(GdipCreateRegionHrgn),
MONITOR(GdipCloneRegion),
MONITOR(GdipDeleteRegion),
MONITOR(GdipSetInfinite),
MONITOR(GdipSetEmpty),
MONITOR(GdipCombineRegionRect),
MONITOR(GdipCombineRegionRectI),
MONITOR(GdipCombineRegionPath),
MONITOR(GdipCombineRegionRegion),
MONITOR(GdipTranslateRegion),
MONITOR(GdipTranslateRegionI),
MONITOR(GdipTransformRegion),
MONITOR(GdipGetRegionBounds),
MONITOR(GdipGetRegionBoundsI),
MONITOR(GdipGetRegionHRgn),
MONITOR(GdipIsEmptyRegion),
MONITOR(GdipIsInfiniteRegion),
MONITOR(GdipIsEqualRegion),
MONITOR(GdipGetRegionDataSize),
MONITOR(GdipGetRegionData),
MONITOR(GdipIsVisibleRegionPoint),
MONITOR(GdipIsVisibleRegionPointI),
MONITOR(GdipIsVisibleRegionRect),
MONITOR(GdipIsVisibleRegionRectI),
MONITOR(GdipGetRegionScansCount),
MONITOR(GdipGetRegionScans),
MONITOR(GdipGetRegionScansI),
MONITOR(GdipCloneBrush),
MONITOR(GdipDeleteBrush),
MONITOR(GdipGetBrushType),
MONITOR(GdipCreateHatchBrush),
MONITOR(GdipGetHatchStyle),
MONITOR(GdipGetHatchForegroundColor),
MONITOR(GdipGetHatchBackgroundColor),
MONITOR(GdipCreateTexture),
MONITOR(GdipCreateTexture2),
MONITOR(GdipCreateTextureIA),
MONITOR(GdipCreateTexture2I),
MONITOR(GdipSetTextureTransform),
MONITOR(GdipGetTextureTransform),
MONITOR(GdipResetTextureTransform),
MONITOR(GdipMultiplyTextureTransform),
MONITOR(GdipTranslateTextureTransform),
MONITOR(GdipScaleTextureTransform),
MONITOR(GdipRotateTextureTransform),
MONITOR(GdipSetTextureWrapMode),
MONITOR(GdipGetTextureWrapMode),
MONITOR(GdipGetTextureImage),
MONITOR(GdipCreateSolidFill),
MONITOR(GdipSetSolidFillColor),
MONITOR(GdipGetSolidFillColor),
MONITOR(GdipCreateLineBrush),
MONITOR(GdipCreateLineBrushI),
MONITOR(GdipCreateLineBrushFromRect),
MONITOR(GdipCreateLineBrushFromRectI),
MONITOR(GdipCreateLineBrushFromRectWithAngle),
MONITOR(GdipCreateLineBrushFromRectWithAngleI),
MONITOR(GdipSetLineColors),
MONITOR(GdipGetLineColors),
MONITOR(GdipGetLineRect),
MONITOR(GdipGetLineRectI),
MONITOR(GdipSetLineGammaCorrection),
MONITOR(GdipGetLineGammaCorrection),
MONITOR(GdipGetLineBlendCount),
MONITOR(GdipGetLineBlend),
MONITOR(GdipSetLineBlend),
MONITOR(GdipGetLinePresetBlendCount),
MONITOR(GdipGetLinePresetBlend),
MONITOR(GdipSetLinePresetBlend),
MONITOR(GdipSetLineSigmaBlend),
MONITOR(GdipSetLineLinearBlend),
MONITOR(GdipSetLineWrapMode),
MONITOR(GdipGetLineWrapMode),
MONITOR(GdipSetLineTransform),
MONITOR(GdipGetLineTransform),
MONITOR(GdipResetLineTransform),
MONITOR(GdipMultiplyLineTransform),
MONITOR(GdipTranslateLineTransform),
MONITOR(GdipScaleLineTransform),
MONITOR(GdipRotateLineTransform),
MONITOR(GdipCreatePathGradient),
MONITOR(GdipCreatePathGradientI),
MONITOR(GdipCreatePathGradientFromPath),
MONITOR(GdipGetPathGradientCenterColor),
MONITOR(GdipSetPathGradientCenterColor),
MONITOR(GdipGetPathGradientSurroundColorsWithCount),
MONITOR(GdipSetPathGradientSurroundColorsWithCount),
MONITOR(GdipGetPathGradientPath),
MONITOR(GdipSetPathGradientPath),
MONITOR(GdipGetPathGradientCenterPoint),
MONITOR(GdipGetPathGradientCenterPointI),
MONITOR(GdipSetPathGradientCenterPoint),
MONITOR(GdipSetPathGradientCenterPointI),
MONITOR(GdipGetPathGradientPointCount),
MONITOR(GdipGetPathGradientSurroundColorCount),
MONITOR(GdipGetPathGradientRect),
MONITOR(GdipGetPathGradientRectI),
MONITOR(GdipSetPathGradientGammaCorrection),
MONITOR(GdipGetPathGradientGammaCorrection),
MONITOR(GdipGetPathGradientBlendCount),
MONITOR(GdipGetPathGradientBlend),
MONITOR(GdipSetPathGradientBlend),
MONITOR(GdipGetPathGradientPresetBlendCount),
MONITOR(GdipGetPathGradientPresetBlend),
MONITOR(GdipSetPathGradientPresetBlend),
MONITOR(GdipSetPathGradientSigmaBlend),
MONITOR(GdipSetPathGradientLinearBlend),
MONITOR(GdipGetPathGradientWrapMode),
MONITOR(GdipSetPathGradientWrapMode),
MONITOR(GdipGetPathGradientTransform),
MONITOR(GdipSetPathGradientTransform),
MONITOR(GdipResetPathGradientTransform),
MONITOR(GdipMultiplyPathGradientTransform),
MONITOR(GdipTranslatePathGradientTransform),
MONITOR(GdipScalePathGradientTransform),
MONITOR(GdipRotatePathGradientTransform),
MONITOR(GdipGetPathGradientFocusScales),
MONITOR(GdipSetPathGradientFocusScales),
MONITOR(GdipCreatePen1),
MONITOR(GdipCreatePen2),
MONITOR(GdipClonePen),
MONITOR(GdipDeletePen),
MONITOR(GdipSetPenWidth),
MONITOR(GdipGetPenWidth),
MONITOR(GdipSetPenUnit),
MONITOR(GdipGetPenUnit),
MONITOR(GdipSetPenLineCap197819),
MONITOR(GdipSetPenStartCap),
MONITOR(GdipSetPenEndCap),
MONITOR(GdipSetPenDashCap197819),
MONITOR(GdipGetPenStartCap),
MONITOR(GdipGetPenEndCap),
MONITOR(GdipGetPenDashCap197819),
MONITOR(GdipSetPenLineJoin),
MONITOR(GdipGetPenLineJoin),
MONITOR(GdipSetPenCustomStartCap),
MONITOR(GdipGetPenCustomStartCap),
MONITOR(GdipSetPenCustomEndCap),
MONITOR(GdipGetPenCustomEndCap),
MONITOR(GdipSetPenMiterLimit),
MONITOR(GdipGetPenMiterLimit),
MONITOR(GdipSetPenMode),
MONITOR(GdipGetPenMode),
MONITOR(GdipSetPenTransform),
MONITOR(GdipGetPenTransform),
MONITOR(GdipResetPenTransform),
MONITOR(GdipMultiplyPenTransform),
MONITOR(GdipTranslatePenTransform),
MONITOR(GdipScalePenTransform),
MONITOR(GdipRotatePenTransform),
MONITOR(GdipSetPenColor),
MONITOR(GdipGetPenColor),
MONITOR(GdipSetPenBrushFill),
MONITOR(GdipGetPenBrushFill),
MONITOR(GdipGetPenFillType),
MONITOR(GdipGetPenDashStyle),
MONITOR(GdipSetPenDashStyle),
MONITOR(GdipGetPenDashOffset),
MONITOR(GdipSetPenDashOffset),
MONITOR(GdipGetPenDashCount),
MONITOR(GdipSetPenDashArray),
MONITOR(GdipGetPenDashArray),
MONITOR(GdipGetPenCompoundCount),
MONITOR(GdipSetPenCompoundArray),
MONITOR(GdipGetPenCompoundArray),
MONITOR(GdipCreateCustomLineCap),
MONITOR(GdipCloneCustomLineCap),
MONITOR(GdipGetCustomLineCapType),
MONITOR(GdipDeleteCustomLineCap),
MONITOR(GdipSetCustomLineCapStrokeCaps),
MONITOR(GdipGetCustomLineCapStrokeCaps),
MONITOR(GdipSetCustomLineCapStrokeJoin),
MONITOR(GdipGetCustomLineCapStrokeJoin),
MONITOR(GdipSetCustomLineCapBaseCap),
MONITOR(GdipGetCustomLineCapBaseCap),
MONITOR(GdipSetCustomLineCapBaseInset),
MONITOR(GdipGetCustomLineCapBaseInset),
MONITOR(GdipSetCustomLineCapWidthScale),
MONITOR(GdipGetCustomLineCapWidthScale),
MONITOR(GdipCreateAdjustableArrowCap),
MONITOR(GdipSetAdjustableArrowCapHeight),
MONITOR(GdipGetAdjustableArrowCapHeight),
MONITOR(GdipSetAdjustableArrowCapWidth),
MONITOR(GdipGetAdjustableArrowCapWidth),
MONITOR(GdipSetAdjustableArrowCapMiddleInset),
MONITOR(GdipGetAdjustableArrowCapMiddleInset),
MONITOR(GdipSetAdjustableArrowCapFillState),
MONITOR(GdipGetAdjustableArrowCapFillState),
MONITOR(GdipLoadImageFromStream),
MONITOR(GdipLoadImageFromFile),
MONITOR(GdipLoadImageFromStreamICM),
MONITOR(GdipLoadImageFromFileICM),
MONITOR(GdipGetEncoderParameterListSize),
MONITOR(GdipGetEncoderParameterList),
MONITOR(GdipSaveImageToStream),
MONITOR(GdipSaveImageToFile),
MONITOR(GdipSaveAdd),
MONITOR(GdipSaveAddImage),
MONITOR(GdipImageGetFrameDimensionsCount),
MONITOR(GdipImageGetFrameDimensionsList),
MONITOR(GdipImageGetFrameCount),
MONITOR(GdipImageSelectActiveFrame),
MONITOR(GdipImageRotateFlip),
MONITOR(GdipGetPropertyCount),
MONITOR(GdipGetPropertyIdList),
MONITOR(GdipGetPropertyItemSize),
MONITOR(GdipGetPropertyItem),
MONITOR(GdipGetPropertySize),
MONITOR(GdipGetAllPropertyItems),
MONITOR(GdipRemovePropertyItem),
MONITOR(GdipSetPropertyItem),
MONITOR(GdipCloneImage),
MONITOR(GdipDisposeImage),
MONITOR(GdipGetImageGraphicsContext),
MONITOR(GdipGetImageBounds),
MONITOR(GdipGetImageDimension),
MONITOR(GdipGetImageWidth),
MONITOR(GdipGetImageHeight),
MONITOR(GdipGetImageHorizontalResolution),
MONITOR(GdipGetImageVerticalResolution),
MONITOR(GdipGetImageFlags),
MONITOR(GdipGetImageRawFormat),
MONITOR(GdipGetImagePixelFormat),
MONITOR(GdipGetImagePalette),
MONITOR(GdipSetImagePalette),
MONITOR(GdipGetImagePaletteSize),
MONITOR(GdipGetImageType),
MONITOR(GdipGetImageThumbnail),
MONITOR(GdipImageForceValidation),
MONITOR(GdipCreateBitmapFromStream),
MONITOR(GdipCreateBitmapFromFile),
MONITOR(GdipCreateBitmapFromStreamICM),
MONITOR(GdipCreateBitmapFromFileICM),
MONITOR(GdipCreateBitmapFromScan0),
MONITOR(GdipCreateBitmapFromGraphics),
MONITOR(GdipCreateBitmapFromDirectDrawSurface),
MONITOR(GdipCreateBitmapFromGdiDib),
MONITOR(GdipCreateBitmapFromHBITMAP),
MONITOR(GdipCreateHBITMAPFromBitmap),
MONITOR(GdipCreateBitmapFromHICON),
MONITOR(GdipCreateBitmapFromResource),
MONITOR(GdipCreateHICONFromBitmap),
MONITOR(GdipCloneBitmapArea),
MONITOR(GdipCloneBitmapAreaI),
MONITOR(GdipBitmapLockBits),
MONITOR(GdipBitmapUnlockBits),
MONITOR(GdipBitmapGetPixel),
MONITOR(GdipBitmapSetPixel),
MONITOR(GdipBitmapSetResolution),
MONITOR(GdipCreateImageAttributes),
MONITOR(GdipCloneImageAttributes),
MONITOR(GdipDisposeImageAttributes),
MONITOR(GdipSetImageAttributesToIdentity),
MONITOR(GdipResetImageAttributes),
MONITOR(GdipSetImageAttributesColorMatrix),
MONITOR(GdipSetImageAttributesThreshold),
MONITOR(GdipSetImageAttributesGamma),
MONITOR(GdipSetImageAttributesNoOp),
MONITOR(GdipSetImageAttributesColorKeys),
MONITOR(GdipSetImageAttributesOutputChannel),
MONITOR(GdipSetImageAttributesOutputChannelColorProfile),
MONITOR(GdipSetImageAttributesRemapTable),
MONITOR(GdipSetImageAttributesCachedBackground),
MONITOR(GdipSetImageAttributesWrapMode),
MONITOR(GdipSetImageAttributesICMMode),
MONITOR(GdipGetImageAttributesAdjustedPalette),
MONITOR(GdipCreateFromHDC),
MONITOR(GdipCreateFromHDC2),
MONITOR(GdipCreateFromHWND),
MONITOR(GdipCreateFromHWNDICM),
MONITOR(GdipDeleteGraphics),
MONITOR(GdipFlush),
MONITOR(GdipSetRenderingOrigin),
MONITOR(GdipGetRenderingOrigin),
MONITOR(GdipSetCompositingMode),
MONITOR(GdipGetCompositingMode),
MONITOR(GdipSetCompositingQuality),
MONITOR(GdipGetCompositingQuality),
MONITOR(GdipSetSmoothingMode),
MONITOR(GdipGetSmoothingMode),
MONITOR(GdipSetPixelOffsetMode),
MONITOR(GdipGetPixelOffsetMode),
MONITOR(GdipSetTextRenderingHint),
MONITOR(GdipSetTextGammaValue),
MONITOR(GdipGetTextGammaValue),
MONITOR(GdipSetTextContrast),
MONITOR(GdipGetTextContrast),
MONITOR(GdipGetTextRenderingHint),
MONITOR(GdipSetInterpolationMode),
MONITOR(GdipGetInterpolationMode),
MONITOR(GdipSetWorldTransform),
MONITOR(GdipResetWorldTransform),
MONITOR(GdipMultiplyWorldTransform),
MONITOR(GdipTranslateWorldTransform),
MONITOR(GdipScaleWorldTransform),
MONITOR(GdipRotateWorldTransform),
MONITOR(GdipGetWorldTransform),
MONITOR(GdipResetPageTransform),
MONITOR(GdipGetPageUnit),
MONITOR(GdipSetPageUnit),
MONITOR(GdipGetPageScale),
MONITOR(GdipSetPageScale),
MONITOR(GdipGetDpiX),
MONITOR(GdipGetDpiY),
MONITOR(GdipTransformPoints),
MONITOR(GdipTransformPointsI),
MONITOR(GdipGetNearestColor),
MONITOR(GdipDrawLine),
MONITOR(GdipDrawLineI),
MONITOR(GdipDrawLines),
MONITOR(GdipDrawLinesI),
MONITOR(GdipDrawArc),
MONITOR(GdipDrawArcI),
MONITOR(GdipDrawBezier),
MONITOR(GdipDrawBezierI),
MONITOR(GdipDrawBeziers),
MONITOR(GdipDrawBeziersI),
MONITOR(GdipDrawRectangle),
MONITOR(GdipDrawRectangleI),
MONITOR(GdipDrawRectangles),
MONITOR(GdipDrawRectanglesI),
MONITOR(GdipDrawEllipse),
MONITOR(GdipDrawEllipseI),
MONITOR(GdipDrawPie),
MONITOR(GdipDrawPieI),
MONITOR(GdipDrawPolygon),
MONITOR(GdipDrawPolygonI),
MONITOR(GdipDrawPath),
MONITOR(GdipDrawCurve),
MONITOR(GdipDrawCurveI),
MONITOR(GdipDrawCurve2),
MONITOR(GdipDrawCurve2I),
MONITOR(GdipDrawCurve3),
MONITOR(GdipDrawCurve3I),
MONITOR(GdipDrawClosedCurve),
MONITOR(GdipDrawClosedCurveI),
MONITOR(GdipDrawClosedCurve2),
MONITOR(GdipDrawClosedCurve2I),
MONITOR(GdipGraphicsClear),
MONITOR(GdipFillRectangle),
MONITOR(GdipFillRectangleI),
MONITOR(GdipFillRectangles),
MONITOR(GdipFillRectanglesI),
MONITOR(GdipFillPolygon),
MONITOR(GdipFillPolygonI),
MONITOR(GdipFillPolygon2),
MONITOR(GdipFillPolygon2I),
MONITOR(GdipFillEllipse),
MONITOR(GdipFillEllipseI),
MONITOR(GdipFillPie),
MONITOR(GdipFillPieI),
MONITOR(GdipFillPath),
MONITOR(GdipFillClosedCurve),
MONITOR(GdipFillClosedCurveI),
MONITOR(GdipFillClosedCurve2),
MONITOR(GdipFillClosedCurve2I),
MONITOR(GdipFillRegion),
MONITOR(GdipDrawString),
MONITOR(GdipMeasureString),
MONITOR(GdipMeasureCharacterRanges),
MONITOR(GdipDrawDriverString),
MONITOR(GdipMeasureDriverString),
MONITOR(GdipGetFamilyName),
MONITOR(GdipDrawImage),
MONITOR(GdipDrawImageI),
MONITOR(GdipDrawImageRect),
MONITOR(GdipDrawImageRectI),
MONITOR(GdipDrawImagePoints),
MONITOR(GdipDrawImagePointsI),
MONITOR(GdipDrawImagePointRect),
MONITOR(GdipDrawImagePointRectI),
MONITOR(GdipDrawImageRectRect),
MONITOR(GdipDrawImageRectRectI),
MONITOR(GdipDrawImagePointsRect),
MONITOR(GdipDrawImagePointsRectI),
MONITOR(GdipEnumerateMetafileDestPoint),
MONITOR(GdipEnumerateMetafileDestPointI),
MONITOR(GdipEnumerateMetafileDestRect),
MONITOR(GdipEnumerateMetafileDestRectI),
MONITOR(GdipEnumerateMetafileDestPoints),
MONITOR(GdipEnumerateMetafileDestPointsI),
MONITOR(GdipEnumerateMetafileSrcRectDestPoint),
MONITOR(GdipEnumerateMetafileSrcRectDestPointI),
MONITOR(GdipEnumerateMetafileSrcRectDestRect),
MONITOR(GdipEnumerateMetafileSrcRectDestRectI),
MONITOR(GdipEnumerateMetafileSrcRectDestPoints),
MONITOR(GdipEnumerateMetafileSrcRectDestPointsI),
MONITOR(GdipPlayMetafileRecord),
MONITOR(GdipSetClipGraphics),
MONITOR(GdipSetClipRect),
MONITOR(GdipSetClipRectI),
MONITOR(GdipSetClipPath),
MONITOR(GdipSetClipRegion),
MONITOR(GdipSetClipHrgn),
MONITOR(GdipResetClip),
MONITOR(GdipTranslateClip),
MONITOR(GdipTranslateClipI),
MONITOR(GdipGetClip),
MONITOR(GdipGetClipBounds),
MONITOR(GdipGetClipBoundsI),
MONITOR(GdipIsClipEmpty),
MONITOR(GdipGetVisibleClipBounds),
MONITOR(GdipGetVisibleClipBoundsI),
MONITOR(GdipIsVisibleClipEmpty),
MONITOR(GdipIsVisiblePoint),
MONITOR(GdipIsVisiblePointI),
MONITOR(GdipIsVisibleRect),
MONITOR(GdipIsVisibleRectI),
MONITOR(GdipSaveGraphics),
MONITOR(GdipRestoreGraphics),
MONITOR(GdipBeginContainer),
MONITOR(GdipBeginContainer2),
MONITOR(GdipBeginContainerI),
MONITOR(GdipEndContainer),
MONITOR(GdipGetMetafileHeaderFromWmf),
MONITOR(GdipGetMetafileHeaderFromEmf),
MONITOR(GdipGetMetafileHeaderFromFile),
MONITOR(GdipGetMetafileHeaderFromStream),
MONITOR(GdipGetMetafileHeaderFromMetafile),
MONITOR(GdipGetHemfFromMetafile),
MONITOR(GdipCreateStreamOnFile),
MONITOR(GdipCreateMetafileFromWmf),
MONITOR(GdipCreateMetafileFromEmf),
MONITOR(GdipCreateMetafileFromFile),
MONITOR(GdipCreateMetafileFromWmfFile),
MONITOR(GdipCreateMetafileFromStream),
MONITOR(GdipRecordMetafile),
MONITOR(GdipRecordMetafileI),
MONITOR(GdipRecordMetafileFileName),
MONITOR(GdipRecordMetafileFileNameI),
MONITOR(GdipRecordMetafileStream),
MONITOR(GdipRecordMetafileStreamI),
MONITOR(GdipSetMetafileDownLevelRasterizationLimit),
MONITOR(GdipGetMetafileDownLevelRasterizationLimit),
MONITOR(GdipGetImageDecodersSize),
MONITOR(GdipGetImageDecoders),
MONITOR(GdipGetImageEncodersSize),
MONITOR(GdipGetImageEncoders),
MONITOR(GdipAlloc),
MONITOR(GdipFree),
MONITOR(GdipCreateFontFamilyFromName),
MONITOR(GdipGetGenericFontFamilySansSerif),
MONITOR(GdipGetGenericFontFamilySerif),
MONITOR(GdipGetGenericFontFamilyMonospace),
MONITOR(GdipCreateFont),
MONITOR(GdipDeleteFontFamily),
MONITOR(GdipCloneFontFamily),
MONITOR(GdipGetFamily),
MONITOR(GdipGetFontStyle),
MONITOR(GdipGetLogFontA),
MONITOR(GdipGetLogFontW),
MONITOR(GdipGetFontSize),
MONITOR(GdipGetFontUnit),
MONITOR(GdipGetFontHeight),
MONITOR(GdipGetFontHeightGivenDPI),
MONITOR(GdipCloneFont),
MONITOR(GdipDeleteFont),
MONITOR(GdipGetGraphicsPixel),
MONITOR(GdipGetDC),
MONITOR(GdipReleaseDC),
MONITOR(GdipComment),
MONITOR(GdipIsStyleAvailable),
MONITOR(GdipGetEmHeight),
MONITOR(GdipGetCellAscent),
MONITOR(GdipGetCellDescent),
MONITOR(GdipGetLineSpacing),
MONITOR(GdipCreateFontFromDC),
MONITOR(GdipCreateFontFromLogfontA),
MONITOR(GdipCreateFontFromLogfontW),
MONITOR(GdipNewInstalledFontCollection),
MONITOR(GdipNewPrivateFontCollection),
MONITOR(GdipDeletePrivateFontCollection),
MONITOR(GdipGetFontCollectionFamilyCount),
MONITOR(GdipGetFontCollectionFamilyList),
MONITOR(GdipPrivateAddFontFile),
MONITOR(GdipPrivateAddMemoryFont),
MONITOR(GdipSetFontSize),
MONITOR(GdipCreateStringFormat),
MONITOR(GdipStringFormatGetGenericDefault),
MONITOR(GdipStringFormatGetGenericTypographic),
MONITOR(GdipCloneStringFormat),
MONITOR(GdipDeleteStringFormat),
MONITOR(GdipSetStringFormatFlags),
MONITOR(GdipGetStringFormatFlags),
MONITOR(GdipSetStringFormatLineSpacing),
MONITOR(GdipGetStringFormatLineSpacingAmount),
MONITOR(GdipGetStringFormatLineSpacingMethod),
MONITOR(GdipSetStringFormatAlign),
MONITOR(GdipGetStringFormatAlign),
MONITOR(GdipSetStringFormatLineAlign),
MONITOR(GdipGetStringFormatLineAlign),
MONITOR(GdipSetStringFormatHotkeyPrefix),
MONITOR(GdipGetStringFormatHotkeyPrefix),
MONITOR(GdipSetStringFormatTabStops),
MONITOR(GdipGetStringFormatTabStopCount),
MONITOR(GdipGetStringFormatTabStops),
MONITOR(GdipSetStringFormatMeasurableCharacterRanges),
MONITOR(GdipGetStringFormatMeasurableCharacterRangeCount),
MONITOR(GdipSetStringFormatDigitSubstitution),
MONITOR(GdipGetStringFormatDigitSubstitution),
MONITOR(GdipSetStringFormatTrimming),
MONITOR(GdipGetStringFormatTrimming),
MONITOR(GdipCreateCachedBitmap),
MONITOR(GdipDeleteCachedBitmap),
MONITOR(GdipDrawCachedBitmap),
MONITOR(GdipMonitorControl),
MONITOR(GdipTestControl),
MONITOR(GdiplusStartup),
MONITOR(GdiplusShutdown),
MONITOR(GdipCreateHalftonePalette),
MONITOR(GdiplusNotificationHook),
MONITOR(GdiplusNotificationUnhook),
MONITOR(GdipEmfToWmfBits),
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\flat\flatapi.cpp ===
/**************************************************************************\
*
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   flatapi.cpp
*
* Abstract:
*
*   Flat GDI+ API wrappers
*
* Revision History:
*
*   12/13/1998 davidx
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"
#include "GdiplusFlat.h"
#include "gpverp.h"

#if DBG
#include <mmsystem.h>
#endif

extern "C" {


//--------------------------------------------------------------------------
//  CheckParameter(p)
//
//     If p evaluates to FALSE, then we currently assert.  In future,
//     we can simply return an invalid parameter status which throws
//     an exception.
//
//  CheckObjectBusy(p)
//
//     Not implemented.  Bails out if object is currently being used.
//
//--------------------------------------------------------------------------
//
// !!!: Only include NULL & IsValid checks in checked builds?
//
// !!!: Instead of deleting object, call a Dispose() method, so far
//       only Bitmap supports this.
//
// !!!: Lock Matrix objects, what about color?
//
// !! Better error checking.  For 'I' APIs which convert from Point to PointI,
//    etc.  Verify count & point are valid first.
//
// !! Change ObjectLock to mutable memory and GetObjectLock() to a const member.
//

#define CheckParameter(cond) \
            if (! (cond)) \
                return InvalidParameter;

#define CheckParameterValid(obj) \
            if (!(obj) || !((obj)->IsValid())) \
                return InvalidParameter;

#define CheckOptionalParameterValid(obj) \
            if ((obj) && (!(obj)->IsValid())) \
                return InvalidParameter;

#define CheckObjectBusy(obj) \
      GpLock lock##obj(obj->GetObjectLock()); \
      if (!(lock##obj).IsValid()) \
            return ObjectBusy;

#define CheckOptionalObjectBusy(obj) \
      GpLock lock##obj(obj ? obj->GetObjectLock() : NULL); \
      if (obj && (!(lock##obj).IsValid())) \
            return ObjectBusy;

// We should put an assert in here so that we stop in the debugger if anyone
// does this.

#define CheckObjectBusyForDelete(obj) \
      GpLock lock##obj(obj->GetObjectLock()); \
      if (!(lock##obj).IsValid())             \
      {                                       \
            WARNING(("Silent memory leak deleting object %p.", obj)); \
            WARNING(("Object lock held by another thread."));\
            WARNING(("Incorrect synchronization by the calling application."));\
            return ObjectBusy;                \
      }                                       \
      lock##obj.MakePermanentLock();

#define CheckColorParameter(color) \
            ;           

#define LazilyInitializeGdiplus

#define CheckGdiplusInitialized \
    { GdiplusStartupCriticalSection critsec; \
      if (Globals::LibraryInitRefCount <= 0) \
          return GdiplusNotInitialized; \
    }

#define CheckGdiplusInitialized_ReturnNULL \
    { GdiplusStartupCriticalSection critsec; \
      if (Globals::LibraryInitRefCount <= 0) \
          return NULL; \
    }

    
#define MaskPixelFormat(pixel) (pixel & 0xFFFFFF)
    

#if DBG

// This class asserts that GDI+ is in an initialized state, to be used in
// our entry-point functions in a debug build.
//
// We assert both at the start and the end of the call, and we make sure that
// we don't hold the critical section for the duration of the API (else this
// would serialize all our calls on debug builds.)

class InitAsserter
{
public:
    InitAsserter() {
        GdiplusStartupCriticalSection critsec;
        ASSERTMSG(Globals::LibraryInitRefCount > 0, ("GDI+ API called before GdiplusStartup/after GdiplusShutdown."));
    }
    ~InitAsserter() {
        GdiplusStartupCriticalSection critsec;
        ASSERTMSG(Globals::LibraryInitRefCount > 0, ("GDI+ API called before GdiplusStartup/after GdiplusShutdown."));
    }
};
#endif

#ifdef GP_ENABLE_MONITORS
#ifdef GP_RELEASE_BUILD
    #define DEFINE_MONITOR(a)
#else
    #define DEFINE_MONITOR(a) GpBlockMonitor blockMonitor(MONITOR(a));
#endif
#else
    #define DEFINE_MONITOR(a)
#endif    

// Define this to do something on each API entry point.
// This is a debugging aid for complex instruction streams (e.g. Office)
// [agodfrey] Well, it just became more than a mere debugging aid...
// [asecchia] Now it's definitely more than a debugging aid...
//            FPUStateSaver was being forgotten on many of our APIs so
//            it's now in here and therefore will be included in all of
//            our APIs (except Startup and Shutdown).

#if DBG
    #define API_ENTRY(a) \
        DEFINE_MONITOR(a) \
        LazilyInitializeGdiplus; \
        VERBOSE(("GDI+ API " #a)); \
        InitAsserter __initAsserter; \
        FPUStateSaver fps;

    #define API_ENTRY_NO_INITCHECK(a) \
        DEFINE_MONITOR(a) \
        VERBOSE(("GDI+ API ", #a));
#else

    #define API_ENTRY(a) \
        DEFINE_MONITOR(a) \
        LazilyInitializeGdiplus;\
        FPUStateSaver fps;

    #define API_ENTRY_NO_INITCHECK(a) \
        DEFINE_MONITOR(a)
#endif

GdiplusStartupOutput gStartupOutput = {
    NotificationStartup,
    NotificationShutdown
};

GpStatus WINAPI
GdiplusStartup(
    OUT ULONG_PTR *token,
    const GdiplusStartupInput *input,
    OUT GdiplusStartupOutput *output)
{
    API_ENTRY_NO_INITCHECK(GdiplusStartup);

    if (   (!token)
        || (!input)
        || (input->SuppressBackgroundThread && !output))
    {
        return InvalidParameter;
    }

    if (input->GdiplusVersion != 1)
    {
        return UnsupportedGdiplusVersion;
    }

    GdiplusStartupCriticalSection critsec;

    // Should never happen, because GdiplusShutdown won't decrement below zero.

    if (Globals::LibraryInitRefCount == 0)
    {
        // Note: We can't allocate anything before this point

        GpStatus ret = InternalGdiplusStartup(input);

        if (ret != Ok) return ret;

        Globals::LibraryInitToken = GenerateInitToken();
    }

    ASSERT(Globals::LibraryInitRefCount >= 0);

    *token = Globals::LibraryInitToken + Globals::LibraryInitRefCount;
    Globals::LibraryInitRefCount++;

    if (input->SuppressBackgroundThread)
    {
        *output = gStartupOutput;
    }
    return Ok;
}

VOID WINAPI
GdiplusShutdown(
    ULONG_PTR token)
{
    API_ENTRY_NO_INITCHECK(GdiplusShutdown);

    GdiplusStartupCriticalSection critsec;

    // Should never happen, because we won't decrement below zero.

    ASSERT(Globals::LibraryInitRefCount >= 0);

    if (Globals::LibraryInitRefCount == 0)
    {
        // Return - i.e. ignore the extra shutdown call

        RIP(("Too many calls to GdiplusShutdown"));
        return;
    }

    if (Globals::LibraryInitRefCount == 1)
    {
        // Shut down for real

        Globals::LibraryInitToken = 0;

        InternalGdiplusShutdown();

        // No allocation/deallocation can happen after this point
    }
    else if (token == Globals::LibraryInitToken)
    {
        // The first client to initialize is shutting down; we must clean up
        // after this one since it defines certain global behavior.

        Globals::UserDebugEventProc = NULL;
    }

    Globals::LibraryInitRefCount--;
}

GpStatus WINAPI
GdiplusNotificationHook(
    OUT ULONG_PTR *token)
{
    API_ENTRY(GdiplusNotificationHook);

    {
        GdiplusStartupCriticalSection critsec;

        // It's illegal to call this API if you're using a background thread.

        if (Globals::ThreadNotify)
        {
            return GenericError;
        }
    }

    return NotificationStartup(token);
}

VOID WINAPI
GdiplusNotificationUnhook(
    ULONG_PTR token)
{
    API_ENTRY(GdiplusNotificationUnhook);

    {
        GdiplusStartupCriticalSection critsec;

        // It's illegal to call this API if you're using a background thread.

        if (Globals::ThreadNotify)
        {
            return;
        }
    }

    NotificationShutdown(token);
}

GpStatus
WINGDIPAPI
GdipCreatePath(GpFillMode fillMode, GpPath **outPath)
{
    API_ENTRY(GdipCreatePath);
    CheckGdiplusInitialized; // We do this in all our object creation API's

    CheckParameter(outPath);

    GpPath * path;

    path = (GpPath *) InterlockedExchangePointer((PVOID *) &Globals::PathLookAside, NULL);

    if(path  != NULL)
    {
        path->GetObjectLock()->Reset();
        path->Reset(fillMode);
    }
    else
    {
        path = new (GpPathTag, TRUE) GpPath(fillMode);
    }


    if (CheckValid(path))
    {
        *outPath = path;
        return Ok;
    }
    else
        return OutOfMemory;
}

GpStatus
WINGDIPAPI
GdipCreatePath2(
    GDIPCONST GpPointF* points,
    GDIPCONST BYTE* types,
    INT count,
    GpFillMode fillMode,
    GpPath **path
    )
{
    API_ENTRY(GdipCreatePath2);
    CheckGdiplusInitialized; // We do this in all our object creation API's

    CheckParameter(path && points && types);

    *path = new (GpPathTag, TRUE) GpPath(points, types, count, fillMode);

    if (CheckValid(*path))
    {
        return Ok;
    }
    else
        return OutOfMemory;
}

GpStatus
WINGDIPAPI
GdipCreatePath2I(
    GDIPCONST GpPoint* points,
    GDIPCONST BYTE* types,
    INT count,
    GpFillMode fillMode,
    GpPath **path
    )
{
    API_ENTRY(GdipCreatePath2I);
    CheckGdiplusInitialized; // We do this in all our object creation API's

    CheckParameter(path && points && types);

    StackBuffer buffer;

    GpPointF* pointsF = (GpPointF*) buffer.GetBuffer(count*sizeof(GpPointF));

    if(!pointsF) return OutOfMemory;

    for (INT i=0; i<count; i++)
    {
        pointsF[i].X = TOREAL(points[i].X);
        pointsF[i].Y = TOREAL(points[i].Y);
    }

    *path = new (GpPathTag, TRUE) GpPath(pointsF, types, count, fillMode);

    if (CheckValid(*path))
    {
        return Ok;
    }
    else
        return OutOfMemory;
}

GpStatus
WINGDIPAPI
GdipClonePath(
    GpPath* path,
    GpPath** clonepath
    )
{
    API_ENTRY(GdipClonePath);
    CheckParameter(clonepath);
    CheckParameterValid(path);
    CheckObjectBusy(path);

    *clonepath = path->Clone();

    if (*clonepath)
    {
        // Make sure we tag this allocation as an API allocation
        GpTagMalloc(*clonepath, GpPathTag, TRUE);
        return Ok;
    }
    else
        return OutOfMemory;
}

GpStatus
WINGDIPAPI
GdipDeletePath(
    GpPath* path
    )
{
    API_ENTRY(GdipDeletePath);
    // NOTE: Do NOT call CheckParameterValid(), because we need to free
    // the object, even if it's not in a valid state.

    CheckParameter(path);
    CheckObjectBusyForDelete(path);

    path = (GpPath *) InterlockedExchangePointer((PVOID *) &Globals::PathLookAside, path);

    if(path != NULL)
    {
        delete path;
    }

    return Ok;
}

GpStatus
WINGDIPAPI
GdipResetPath(
    GpPath* path
    )
{
    API_ENTRY(GdipResetPath);
    CheckParameterValid(path);
    CheckObjectBusy(path);

    return path->Reset();
}

GpStatus
WINGDIPAPI
GdipGetPointCount(
    GpPath* path,
    INT *count
    )
{
    API_ENTRY(GdipGetPointCount);
    CheckParameter(count);
    CheckParameterValid(path);
    CheckObjectBusy(path);

    *count = path->GetPointCount();

    return Ok;
}

GpStatus
WINGDIPAPI
GdipGetPathTypes(
    GpPath* path,
    BYTE* types,
    INT count
    )
{
    API_ENTRY(GdipGetPathTypes);
    CheckParameter(types && count > 0);
    CheckParameterValid(path);
    CheckObjectBusy(path);

    INT pathCount;

    pathCount = path->GetPointCount();

    if (pathCount > count)
        return InsufficientBuffer;

    if (pathCount < 0)
        return GenericError;

    GpMemcpy(types, path->GetPathTypes(), pathCount);

    return Ok;
}

GpStatus
WINGDIPAPI
GdipGetPathPoints(
    GpPath* path,
    GpPointF* points,
    INT count
    )
{
    API_ENTRY(GdipGetPathPoints);
    // NOTE: Race condition between GetPointCount() & GetPathPoints()
    //       we need a manually invokable lock here.

    CheckParameter(points && count > 0);
    CheckParameterValid(path);
    CheckObjectBusy(path);

    INT pathCount;

    pathCount = path->GetPointCount();

    if (pathCount > count)
        return InsufficientBuffer;

    if (pathCount < 0)
        return GenericError;

    GpMemcpy(points, path->GetPathPoints(), pathCount*sizeof(GpPointF));

    return Ok;
}

GpStatus
WINGDIPAPI
GdipGetPathPointsI(
    GpPath* path,
    GpPoint* points,
    INT count
    )
{
    API_ENTRY(GdipGetPathPointsI);
    // NOTE: Race condition between GetPointCount() & GetPathPoints()
    //       we need a manually invokable lock here.

    CheckParameter(points && count > 0);
    CheckParameterValid(path);
    CheckObjectBusy(path);

    INT pathCount;

    pathCount = path->GetPointCount();

    if (pathCount > count)
        return InsufficientBuffer;

    if (pathCount < 0)
        return GenericError;


    GDIPCONST GpPointF *pointsF = path->GetPathPoints();

    for (INT i=0; i<count; i++)
    {
        points[i].X = GpRound(pointsF[i].X);
        points[i].Y = GpRound(pointsF[i].Y);
    }

    return Ok;
}


GpStatus
WINGDIPAPI
GdipGetPathFillMode(
    GpPath *path,
    GpFillMode *fillmode
    )
{
    API_ENTRY(GdipGetPathFillMode);
    CheckParameter(fillmode);
    CheckParameterValid(path);
    CheckObjectBusy(path);

    *fillmode = (GpFillMode)path->GetFillMode();

    return Ok;
}

GpStatus
WINGDIPAPI
GdipSetPathFillMode(
    GpPath *path,
    GpFillMode fillmode
    )
{
    API_ENTRY(GdipSetPathFillMode);
    CheckParameterValid(path);
    CheckObjectBusy(path);

    path->SetFillMode(fillmode);

    return Ok;
}

GpStatus
WINGDIPAPI
GdipSetPathData(
    GpPath *path,
    GpPathData* pathData
    )
{
    API_ENTRY(GdipSetPathData);
    CheckParameterValid(path);
    CheckObjectBusy(path);

    return path->SetPathData(pathData);
}

GpStatus
WINGDIPAPI
GdipGetPathData(
    GpPath *path,
    GpPathData* pathData
    )
{
    API_ENTRY(GdipGetPathData);
    CheckParameterValid(path);
    CheckObjectBusy(path);

    return path->GetPathData(pathData);
}

GpStatus
WINGDIPAPI
GdipStartPathFigure(
    GpPath *path
    )
{
    API_ENTRY(GdipStartPathFigure);
    CheckParameterValid(path);
    CheckObjectBusy(path);

    path->StartFigure();

    return Ok;
}

GpStatus
WINGDIPAPI
GdipClosePathFigure(
    GpPath *path
    )
{
    API_ENTRY(GdipClosePathFigure);
    CheckParameterValid(path);
    CheckObjectBusy(path);

    return path->CloseFigure();
}

GpStatus
WINGDIPAPI
GdipClosePathFigures(
    GpPath *path
    )
{
    API_ENTRY(GdipClosePathFigures);
    CheckParameterValid(path);
    CheckObjectBusy(path);

    return path->CloseFigures();
}

GpStatus
WINGDIPAPI
GdipSetPathMarker(
    GpPath *path
    )
{
    API_ENTRY(GdipSetPathMarker);
    CheckParameterValid(path);
    CheckObjectBusy(path);

    return path->SetMarker();
}

GpStatus
WINGDIPAPI
GdipClearPathMarkers(
    GpPath *path
    )
{
    API_ENTRY(GdipClearPathMarkers);
    CheckParameterValid(path);
    CheckObjectBusy(path);

    return path->ClearMarkers();
}

GpStatus
WINGDIPAPI
GdipReversePath(
    GpPath* path
    )
{
    API_ENTRY(GdipReversePath);
    CheckParameterValid(path);
    CheckObjectBusy(path);

    return path->Reverse();
}

GpStatus
WINGDIPAPI
GdipGetPathLastPoint(
    GpPath* path,
    GpPointF* lastPoint
    )
{
    API_ENTRY(GdipGetPathLastPoint);
    CheckParameter(lastPoint);
    CheckParameterValid(path);
    CheckObjectBusy(path);

    return path->GetLastPoint(lastPoint);
}

GpStatus
WINGDIPAPI
GdipAddPathLine(
    GpPath *path,
    REAL x1,
    REAL y1,
    REAL x2,
    REAL y2
    )
{
    API_ENTRY(GdipAddPathLine);
    CheckParameterValid(path);
    CheckObjectBusy(path);

    return path->AddLine(x1, y1, x2, y2);
}

GpStatus
WINGDIPAPI
GdipAddPathLineI(
    GpPath *path,
    INT x1,
    INT y1,
    INT x2,
    INT y2
    )
{
    API_ENTRY(GdipAddPathLineI);
    return GdipAddPathLine(path, TOREAL(x1), TOREAL(y1), TOREAL(x2), TOREAL(y2));
}

GpStatus
WINGDIPAPI
GdipAddPathLine2(
    GpPath *path,
    GDIPCONST GpPointF *points,
    INT count)
{
    API_ENTRY(GdipAddPathLine2);
    CheckParameter(points && count > 0);
    CheckParameterValid(path);
    CheckObjectBusy(path);

    return path->AddLines(points, count);
}

GpStatus
WINGDIPAPI
GdipAddPathLine2I(
    GpPath *path,
    GDIPCONST GpPoint *points,
    INT count)
{
    API_ENTRY(GdipAddPathLine2I);
    StackBuffer buffer;

    GpPointF* pointsF = (GpPointF*) buffer.GetBuffer(count*sizeof(GpPointF));

    if(!pointsF) return OutOfMemory;

    for (INT i=0; i<count; i++)
    {
        pointsF[i].X = TOREAL(points[i].X);
        pointsF[i].Y = TOREAL(points[i].Y);
    }

    GpStatus status = GdipAddPathLine2(path, pointsF, count);

    return status;
}

GpStatus
WINGDIPAPI
GdipAddPathArc(
    GpPath *path,
    REAL x,
    REAL y,
    REAL width,
    REAL height,
    REAL startAngle,
    REAL sweepAngle
    )
{
    API_ENTRY(GdipAddPathArc);
    CheckParameterValid(path);
    CheckObjectBusy(path);

    return path->AddArc(
        x,
        y,
        width,
        height,
        startAngle,
        sweepAngle
    );
}

GpStatus
WINGDIPAPI
GdipAddPathArcI(
    GpPath *path,
    INT x,
    INT y,
    INT width,
    INT height,
    REAL startAngle,
    REAL sweepAngle
    )
{
    API_ENTRY(GdipAddPathArcI);
   return GdipAddPathArc(path,
                         TOREAL(x),
                         TOREAL(y),
                         TOREAL(width),
                         TOREAL(height),
                         startAngle,
                         sweepAngle);
}

GpStatus
WINGDIPAPI
GdipAddPathBezier(
    GpPath *path,
    REAL x1,
    REAL y1,
    REAL x2,
    REAL y2,
    REAL x3,
    REAL y3,
    REAL x4,
    REAL y4
    )
{
    API_ENTRY(GdipAddPathBezier);
   CheckParameterValid(path);
   CheckObjectBusy(path);

   return path->AddBezier(x1,
                          y1,
                          x2,
                          y2,
                          x3,
                          y3,
                          x4,
                          y4);
}

GpStatus
WINGDIPAPI
GdipAddPathBezierI(
    GpPath *path,
    INT x1,
    INT y1,
    INT x2,
    INT y2,
    INT x3,
    INT y3,
    INT x4,
    INT y4
    )
{
    API_ENTRY(GdipAddPathBezierI);
   return GdipAddPathBezier(path,
                            TOREAL(x1),
                            TOREAL(y1),
                            TOREAL(x2),
                            TOREAL(y2),
                            TOREAL(x3),
                            TOREAL(y3),
                            TOREAL(x4),
                            TOREAL(y4));
}

GpStatus
WINGDIPAPI
GdipAddPathBeziers(
    GpPath *path,
    GDIPCONST GpPointF *points,
    INT count
    )
{
    API_ENTRY(GdipAddPathBeziers);
   CheckParameter(points && count > 0);
   CheckParameterValid(path);
   CheckObjectBusy(path);

   return path->AddBeziers(points, count);
}


GpStatus
WINGDIPAPI
GdipAddPathBeziersI(
    GpPath *path,
    GDIPCONST GpPoint *points,
    INT count
    )
{
    API_ENTRY(GdipAddPathBeziersI);
   StackBuffer buffer;

   GpPointF* pointsF = (GpPointF*) buffer.GetBuffer(count*sizeof(GpPointF));

   if(!pointsF) return OutOfMemory;

   for (INT i=0; i<count; i++)
   {
       pointsF[i].X = TOREAL(points[i].X);
       pointsF[i].Y = TOREAL(points[i].Y);
   }

   GpStatus status = GdipAddPathBeziers(path, pointsF, count);

   return status;
}

GpStatus
WINGDIPAPI
GdipAddPathCurve(
    GpPath *path,
    GDIPCONST GpPointF *points,
    INT count
    )
{
    API_ENTRY(GdipAddPathCurve);
   CheckParameter(points && count > 0);
   CheckParameterValid(path);
   CheckObjectBusy(path);

   return path->AddCurve(points, count);
}


GpStatus
WINGDIPAPI
GdipAddPathCurveI(
    GpPath *path,
    GDIPCONST GpPoint *points,
    INT count
    )
{
    API_ENTRY(GdipAddPathCurveI);
   CheckParameter(points && count > 0);

   StackBuffer buffer;

   GpPointF* pointsF = (GpPointF*) buffer.GetBuffer(count*sizeof(GpPointF));

   if(!pointsF) return OutOfMemory;

   for (INT i=0; i<count; i++)
   {
       pointsF[i].X = TOREAL(points[i].X);
       pointsF[i].Y = TOREAL(points[i].Y);
   }

   GpStatus status = GdipAddPathCurve(path, pointsF, count);

   return status;
}

GpStatus
WINGDIPAPI
GdipAddPathCurve2(
    GpPath *path,
    GDIPCONST GpPointF *points,
    INT count,
    REAL tension
    )
{
    API_ENTRY(GdipAddPathCurve2);
   CheckParameter(points && count > 0);
   CheckParameterValid(path);
   CheckObjectBusy(path);

   INT offset = 0;
   INT numOfSegments = count - 1;

   return path->AddCurve(points, count, tension, offset, numOfSegments);
}

GpStatus
WINGDIPAPI
GdipAddPathCurve2I(
    GpPath *path,
    GDIPCONST GpPoint *points,
    INT count,
    REAL tension
    )
{
    API_ENTRY(GdipAddPathCurve2I);
   CheckParameter(points && count > 0);

   StackBuffer buffer;

   GpPointF* pointsF = (GpPointF*) buffer.GetBuffer(count*sizeof(GpPointF));

   if(!pointsF) return OutOfMemory;

   for (INT i=0; i<count; i++)
   {
       pointsF[i].X = TOREAL(points[i].X);
       pointsF[i].Y = TOREAL(points[i].Y);
   }

   GpStatus status = GdipAddPathCurve2(path, pointsF, count, tension);

   return status;
}

GpStatus
WINGDIPAPI
GdipAddPathCurve3(
    GpPath *path,
    GDIPCONST GpPointF *points,
    INT count,
    INT offset,
    INT numberOfSegments,
    REAL tension
    )
{
    API_ENTRY(GdipAddPathCurve3);
   CheckParameter(points && count > 0);
   CheckParameterValid(path);
   CheckObjectBusy(path);

   return path->AddCurve(points, count, tension, offset, numberOfSegments);
}

GpStatus
WINGDIPAPI
GdipAddPathCurve3I(
    GpPath *path,
    GDIPCONST GpPoint *points,
    INT count,
    INT offset,
    INT numberOfSegments,
    REAL tension
    )
{
    API_ENTRY(GdipAddPathCurve3I);
   StackBuffer buffer;

   GpPointF* pointsF = (GpPointF*) buffer.GetBuffer(count*sizeof(GpPointF));

   if(!pointsF) return OutOfMemory;

   for (INT i=0; i<count; i++)
   {
       pointsF[i].X = TOREAL(points[i].X);
       pointsF[i].Y = TOREAL(points[i].Y);
   }

   GpStatus status = GdipAddPathCurve3(path, pointsF, count, offset, numberOfSegments, tension);

   return status;
}

GpStatus
WINGDIPAPI
GdipAddPathClosedCurve(
    GpPath *path,
    GDIPCONST GpPointF *points,
    INT count
    )
{
    API_ENTRY(GdipAddPathClosedCurve);
   CheckParameter(points && count > 0);
   CheckParameterValid(path);
   CheckObjectBusy(path);

   return path->AddClosedCurve(points, count);
}

GpStatus
WINGDIPAPI
GdipAddPathClosedCurveI(
    GpPath *path,
    GDIPCONST GpPoint *points,
    INT count
    )
{
    API_ENTRY(GdipAddPathClosedCurveI);
   StackBuffer buffer;

   GpPointF* pointsF = (GpPointF*) buffer.GetBuffer(count*sizeof(GpPointF));

   if(!pointsF) return OutOfMemory;

   for (INT i=0; i<count; i++)
   {
       pointsF[i].X = TOREAL(points[i].X);
       pointsF[i].Y = TOREAL(points[i].Y);
   }

   GpStatus status = GdipAddPathClosedCurve(path, pointsF, count);

   return status;
}

GpStatus
WINGDIPAPI
GdipAddPathClosedCurve2(
    GpPath *path,
    GDIPCONST GpPointF *points,
    INT count,
    REAL tension
    )
{
    API_ENTRY(GdipAddPathClosedCurve2);
   CheckParameter(points && count > 0);
   CheckParameterValid(path);
   CheckObjectBusy(path);

   return path->AddClosedCurve(points, count, tension);
}

GpStatus
WINGDIPAPI
GdipAddPathClosedCurve2I(
    GpPath *path,
    GDIPCONST GpPoint *points,
    INT count,
    REAL tension
    )
{
    API_ENTRY(GdipAddPathClosedCurve2I);
   StackBuffer buffer;

   GpPointF* pointsF = (GpPointF*) buffer.GetBuffer(count*sizeof(GpPointF));

   if(!pointsF) return OutOfMemory;

   for (INT i=0; i<count; i++)
   {
       pointsF[i].X = TOREAL(points[i].X);
       pointsF[i].Y = TOREAL(points[i].Y);
   }

   GpStatus status = GdipAddPathClosedCurve2(path, pointsF, count, tension);

   return status;
}

GpStatus
WINGDIPAPI
GdipAddPathRectangle(
    GpPath *path,
    REAL x,
    REAL y,
    REAL width,
    REAL height
    )
{
    API_ENTRY(GdipAddPathRectangle);
   CheckParameterValid(path);
   CheckObjectBusy(path);

   GpRectF rect(x, y, width, height);

   return path->AddRect(rect);
}

GpStatus
WINGDIPAPI
GdipAddPathRectangleI(
    GpPath *path,
    INT x,
    INT y,
    INT width,
    INT height
    )
{
    API_ENTRY(GdipAddPathRectangleI);
   return GdipAddPathRectangle(path, TOREAL(x), TOREAL(y), TOREAL(width), TOREAL(height));
}

GpStatus
WINGDIPAPI
GdipAddPathRectangles(
    GpPath *path,
    GDIPCONST GpRectF *rects,
    INT count
    )
{
    API_ENTRY(GdipAddPathRectangles);
   CheckParameter(rects && count > 0);
   CheckParameterValid(path);
   CheckObjectBusy(path);

   return path->AddRects(rects, count);
}

GpStatus
WINGDIPAPI
GdipAddPathRectanglesI(
    GpPath *path,
    GDIPCONST GpRect *rects,
    INT count
    )
{
    API_ENTRY(GdipAddPathRectanglesI);
   StackBuffer buffer;

   GpRectF *rectsF = (GpRectF*) buffer.GetBuffer(count*sizeof(GpRectF));

   if(!rectsF) return OutOfMemory;

   for (INT i=0; i<count; i++)
   {
       rectsF[i].X = TOREAL(rects[i].X);
       rectsF[i].Y = TOREAL(rects[i].Y);
       rectsF[i].Width = TOREAL(rects[i].Width);
       rectsF[i].Height = TOREAL(rects[i].Height);
   }

   GpStatus status = GdipAddPathRectangles(path, rectsF, count);

   return status;
}

GpStatus
WINGDIPAPI
GdipAddPathEllipse(
    GpPath* path,
    REAL x,
    REAL y,
    REAL width,
    REAL height
    )
{
    API_ENTRY(GdipAddPathEllipse);
    // Idea: What about just putting "GpRectF rect" as the parameter,
    //       no copying, the stack image should match the structure
    //       avoiding an additional copy.

    CheckParameterValid(path);
    CheckObjectBusy(path);

    GpRectF rect(x, y, width, height);

    return path->AddEllipse(rect);
}

GpStatus
WINGDIPAPI
GdipAddPathEllipseI(
    GpPath* path,
    INT x,
    INT y,
    INT width,
    INT height
    )
{
    API_ENTRY(GdipAddPathEllipseI);
    return GdipAddPathEllipse(path, TOREAL(x), TOREAL(y), TOREAL(width), TOREAL(height));
}

GpStatus
WINGDIPAPI
GdipAddPathPie(
    GpPath *path,
    REAL x,
    REAL y,
    REAL width,
    REAL height,
    REAL startAngle,
    REAL sweepAngle
    )
{
    API_ENTRY(GdipAddPathPie);
   CheckParameterValid(path);
   CheckObjectBusy(path);

   return path->AddPie(x, y, width, height, startAngle, sweepAngle);
}

GpStatus
WINGDIPAPI
GdipAddPathPieI(
    GpPath *path,
    INT x,
    INT y,
    INT width,
    INT height,
    REAL startAngle,
    REAL sweepAngle
    )
{
    API_ENTRY(GdipAddPathPieI);
   return GdipAddPathPie(path,
                         TOREAL(x),
                         TOREAL(y),
                         TOREAL(width),
                         TOREAL(height),
                         startAngle,
                         sweepAngle);
}

GpStatus
WINGDIPAPI
GdipAddPathPolygon(
    GpPath *path,
    GDIPCONST GpPointF *points,
    INT count
    )
{
    API_ENTRY(GdipAddPathPolygon);
   CheckParameter(points && count > 0);
   CheckParameterValid(path);
   CheckObjectBusy(path);

   return path->AddPolygon(points, count);
}

GpStatus
WINGDIPAPI
GdipAddPathPolygonI(
    GpPath *path,
    GDIPCONST GpPoint *points,
    INT count
    )
{
    API_ENTRY(GdipAddPathPolygonI);
   StackBuffer buffer;

   GpPointF* pointsF = (GpPointF*) buffer.GetBuffer(count*sizeof(GpPointF));

   if(!pointsF) return OutOfMemory;

   for (INT i=0; i<count; i++)
   {
       pointsF[i].X = TOREAL(points[i].X);
       pointsF[i].Y = TOREAL(points[i].Y);
   }

   GpStatus status = GdipAddPathPolygon(path, pointsF, count);

   return status;
}


GpStatus
WINGDIPAPI
GdipAddPathPath(
    GpPath *path,
    GDIPCONST GpPath* addingPath,
    BOOL connect
    )
{
    API_ENTRY(GdipAddPathPath);
   CheckParameterValid(path);
   CheckObjectBusy(path);

   return path->AddPath(addingPath, connect);
}

static inline
EmptyString(const WCHAR * string, INT length)
{
    return (length == 0 || length == -1 && string[0] == 0);
}

static inline
void SetEmptyRectF(RectF * boundingBox)
{
    boundingBox->X = boundingBox->Y = boundingBox->Width = boundingBox->Height = 0.0;
}

GpStatus
WINGDIPAPI
GdipAddPathString(
    GpPath                   *path,
    GDIPCONST WCHAR          *string,
    INT                       length,
    GDIPCONST GpFontFamily   *family,
    INT                       style,
    REAL                      emSize,
    GDIPCONST RectF          *layoutRect,
    GDIPCONST GpStringFormat *format
)
{
    API_ENTRY(GdipAddPathString);

    CheckParameter(string && layoutRect);
    CheckParameterValid(path);
    CheckObjectBusy(path);

    if (EmptyString(string, length))
    {
        return Ok;
    }


    GlobalTextLock lock;

    CheckParameterValid(family);
    CheckOptionalParameterValid(format);

    return path->AddString(
        string,
        length,
        family,
        style,
        emSize,
        layoutRect,
        format
    );
}

GpStatus
WINGDIPAPI
GdipAddPathStringI(
    GpPath                   *path,
    GDIPCONST WCHAR          *string,
    INT                       length,
    GDIPCONST GpFontFamily   *family,
    INT                       style,
    REAL                      emSize,
    GDIPCONST Rect           *layoutRect,
    GDIPCONST GpStringFormat *format
)
{
    API_ENTRY(GdipAddPathStringI);
    CheckParameter(layoutRect);

    // Not necessary to check all paramaters - they are validated
    // in the called function.

    GpRectF rectf(TOREAL(layoutRect->X), TOREAL(layoutRect->Y),
                  TOREAL(layoutRect->Width), TOREAL(layoutRect->Height));

    return GdipAddPathString(path, string, length, family, style, emSize,
                             &rectf, format);
}


GpStatus
WINGDIPAPI
GdipFlattenPath(
    GpPath *path,
    GpMatrix* matrix,
    REAL flatness
    )
{
    API_ENTRY(GdipFlattenPath);
    CheckParameterValid(path);
    CheckObjectBusy(path);
    CheckOptionalParameterValid(matrix);
    CheckOptionalObjectBusy(matrix);


    return path->Flatten(matrix, flatness);
}

GpStatus WINGDIPAPI
GdipWindingModeOutline(
    GpPath *path,
    GpMatrix *matrix,
    REAL flatness
)
{
    API_ENTRY(GdipWindingModeOutline);


    CheckParameterValid(path);
    CheckObjectBusy(path);
    CheckOptionalParameterValid(matrix);
    CheckOptionalObjectBusy(matrix);

    return path->ComputeWindingModeOutline(matrix, flatness);
}


GpStatus
WINGDIPAPI
GdipWidenPath(
    GpPath *path,
    GpPen *pen,
    GpMatrix *matrix,
    REAL flatness
)
{
    API_ENTRY(GdipWidenPath);


    CheckParameterValid(path);
    CheckParameterValid(pen);
    CheckObjectBusy(path);
    CheckObjectBusy(pen);
    CheckOptionalParameterValid(matrix);
    CheckOptionalObjectBusy(matrix);

    return path->Widen(pen, matrix, flatness);
}



GpStatus
WINGDIPAPI
GdipWarpPath(
    GpPath *path,
    GpMatrix* matrix,
    GDIPCONST GpPointF *points,
    INT count,
    REAL srcx,
    REAL srcy,
    REAL srcwidth,
    REAL srcheight,
    WarpMode warpMode,
    REAL flatness
    )
{
    API_ENTRY(GdipWarpPath);
    CheckParameterValid(path);
    CheckObjectBusy(path);
    CheckParameter(points && count > 0);
    CheckOptionalParameterValid(matrix);
    CheckOptionalObjectBusy(matrix);

    GpRectF srcRect(srcx, srcy, srcwidth, srcheight);


   // The flatness parameter is not implemented yet.

    return path->WarpAndFlattenSelf(matrix, points, count, srcRect, warpMode);
}

GpStatus
WINGDIPAPI
GdipTransformPath(
    GpPath *path,
    GpMatrix *matrix
    )
{
    API_ENTRY(GdipTransformPath);
    if(matrix == NULL)
        return Ok;  // No need to transform.

    CheckParameterValid(path);
    CheckParameterValid(matrix);
    CheckObjectBusy(path);
    CheckObjectBusy(matrix);

    path->Transform(matrix);

    return Ok;
}

GpStatus
WINGDIPAPI
GdipGetPathWorldBounds(
    GpPath* path,
    GpRectF* bounds,
    GDIPCONST GpMatrix *matrix,
    GDIPCONST GpPen *pen
    )
{
    API_ENTRY(GdipGetPathWorldBounds);
    CheckParameterValid(path);
    CheckObjectBusy(path);
    CheckParameter(bounds);
    CheckOptionalParameterValid(pen);
    CheckOptionalParameterValid(matrix);
    CheckOptionalObjectBusy(pen);
    CheckOptionalObjectBusy(matrix);


    // matrix and pen can be NULL.
    // So don't use CheckParameter for matrix and pen.

    GpStatus status = Ok;

    if(pen == NULL)
        status = path->GetBounds(bounds, const_cast<GpMatrix*>(matrix));
    else
        status = path->GetBounds(bounds,
                                 const_cast<GpMatrix*>(matrix),
                                 const_cast<GpPen*>(pen)->GetDevicePen());

    return status;
}

GpStatus
WINGDIPAPI
GdipGetPathWorldBoundsI(
    GpPath* path,
    GpRect* bounds,
    GDIPCONST GpMatrix *matrix,
    GDIPCONST GpPen *pen)
{
    API_ENTRY(GdipGetPathWorldBoundsI);
    CheckParameterValid(path);
    CheckObjectBusy(path);
    CheckParameter(bounds);
    CheckOptionalParameterValid(pen);
    CheckOptionalParameterValid(matrix);
    CheckOptionalObjectBusy(pen);
    CheckOptionalObjectBusy(matrix);

    // matrix and pen can be NULL.
    // So don't use CheckParameter for matrix and pen.

    GpStatus status = Ok;

    if(pen == NULL)
        status = path->GetBounds(bounds, const_cast<GpMatrix*>(matrix));
    else
        status = path->GetBounds(bounds,
                                 const_cast<GpMatrix*>(matrix),
                                 const_cast<GpPen*>(pen)->GetDevicePen());
    return status;
}

GpStatus
WINGDIPAPI
GdipIsVisiblePathPoint(
    GpPath* path,
    REAL x,
    REAL y,
    GpGraphics *graphics,
    BOOL *result
    )
{
    API_ENTRY(GdipIsVisiblePathPoint);
    CheckParameter(result);
    CheckParameterValid(path);
    CheckObjectBusy(path);

    GpPointF pt(x, y);
    GpMatrix worldToDevice;


    Status status = Ok;

    if(graphics)
    {
        CheckParameterValid(graphics);
        CheckObjectBusy(graphics);

        graphics->GetWorldToDeviceTransform(&worldToDevice);

        status = path->IsVisible(&pt, result, &worldToDevice);
    }
    else
        status = path->IsVisible(&pt, result);  // Use the default.

    return status;
}

GpStatus
WINGDIPAPI
GdipIsVisiblePathPointI(
    GpPath* path,
    INT x,
    INT y,
    GpGraphics *graphics,
    BOOL *result
    )
{
    API_ENTRY(GdipIsVisiblePathPointI);
    return GdipIsVisiblePathPoint(path,
                                  TOREAL(x),
                                  TOREAL(y),
                                  graphics,
                                  result);
}

GpStatus
WINGDIPAPI
GdipIsOutlineVisiblePathPoint(
    GpPath* path,
    REAL x,
    REAL y,
    GpPen *pen,
    GpGraphics *graphics,
    BOOL *result
    )
{
    API_ENTRY(GdipIsOutlineVisiblePathPoint);
    CheckParameter(result);
    CheckParameterValid(path);
    CheckObjectBusy(path);
    CheckParameterValid(pen);
    CheckObjectBusy(pen);

    GpPointF pt(x, y);
    GpMatrix worldToDevice;


    Status status = Ok;

    if(graphics)
    {
        CheckParameterValid(graphics);
        CheckObjectBusy(graphics);

        graphics->GetWorldToDeviceTransform(&worldToDevice);

        REAL dpiX = graphics->GetDpiX();
        REAL dpiY = graphics->GetDpiY();

        status = path->IsOutlineVisible(&pt, result, pen,
                &worldToDevice, dpiX, dpiY);
    }
    else
        status = path->IsOutlineVisible(&pt, result, pen);  // Use the default.

    return status;
}

GpStatus
WINGDIPAPI
GdipIsOutlineVisiblePathPointI(
    GpPath* path,
    INT x,
    INT y,
    GpPen *pen,
    GpGraphics *graphics,
    BOOL *result
    )
{
    API_ENTRY(GdipIsOutlineVisiblePathPointI);
    return GdipIsOutlineVisiblePathPoint(path,
                                         TOREAL(x),
                                         TOREAL(y),
                                         pen,
                                         graphics,
                                         result);
}

GpStatus WINGDIPAPI
GdipCreatePathIter(
    GpPathIterator **iterator,
    GpPath* path
    )
{
    API_ENTRY(GdipCreatePathIter);
    CheckGdiplusInitialized; // We do this in all our object creation API's

    CheckParameter(iterator);

    *iterator = new GpPathIterator(path);

    if (CheckValid(*iterator))
        return Ok;
    else
        return OutOfMemory;
}

GpStatus
WINGDIPAPI
GdipDeletePathIter(
    GpPathIterator *iterator
    )
{
    API_ENTRY(GdipDeletePathIter);
    // NOTE: Do NOT call CheckParameterValid(), because we need to free
    // the object, even if it's not in a valid state.
    CheckParameter(iterator);
    CheckObjectBusyForDelete(iterator);

    delete iterator;

    return Ok;
}

GpStatus WINGDIPAPI
GdipPathIterNextSubpath(
    GpPathIterator* iterator,
    INT* resultCount,
    INT* startIndex,
    INT* endIndex,
    BOOL* isClosed)
{
    API_ENTRY(GdipPathIterNextSubpath);
    CheckParameterValid(iterator);
    CheckObjectBusy(iterator);
    CheckParameter(resultCount);
    CheckParameter(startIndex);
    CheckParameter(endIndex);
    CheckParameter(isClosed);

    *resultCount = iterator->NextSubpath(startIndex, endIndex, isClosed);

    return Ok;
}

GpStatus WINGDIPAPI
GdipPathIterNextSubpathPath(
    GpPathIterator* iterator,
    INT* resultCount,
    GpPath* path,
    BOOL* isClosed)
{
    API_ENTRY(GdipPathIterNextSubpathPath);
    CheckParameterValid(iterator);
    CheckObjectBusy(iterator);
    CheckParameter(resultCount);
    CheckParameter(isClosed);

    *resultCount = iterator->NextSubpath(path, isClosed);

    return Ok;
}

GpStatus WINGDIPAPI
GdipPathIterNextPathType(
    GpPathIterator* iterator,
    INT* resultCount,
    BYTE* pathType,
    INT* startIndex,
    INT* endIndex
    )
{
    API_ENTRY(GdipPathIterNextPathType);
    CheckParameterValid(iterator);
    CheckObjectBusy(iterator);
    CheckParameter(resultCount);
    CheckParameter(pathType);
    CheckParameter(startIndex);
    CheckParameter(endIndex);

    *resultCount = iterator->NextPathType(pathType, startIndex, endIndex);

    return Ok;
}

GpStatus WINGDIPAPI
GdipPathIterNextMarker(
    GpPathIterator* iterator,
    INT* resultCount,
    INT* startIndex,
    INT* endIndex)
{
    API_ENTRY(GdipPathIterNextMarker);
    CheckParameterValid(iterator);
    CheckObjectBusy(iterator);
    CheckParameter(resultCount);
    CheckParameter(startIndex);
    CheckParameter(endIndex);

    *resultCount = iterator->NextMarker(startIndex, endIndex);

    return Ok;
}

GpStatus WINGDIPAPI
GdipPathIterNextMarkerPath(
    GpPathIterator* iterator,
    INT* resultCount,
    GpPath* path)
{
    API_ENTRY(GdipPathIterNextMarkerPath);
    CheckParameterValid(iterator);
    CheckObjectBusy(iterator);
    CheckParameter(resultCount);

    *resultCount = iterator->NextMarker(path);

    return Ok;
}

GpStatus WINGDIPAPI
GdipPathIterGetCount(
    GpPathIterator* iterator,
    INT* count
    )
{
    API_ENTRY(GdipPathIterGetCount);
    CheckParameterValid(iterator);
    CheckObjectBusy(iterator);
    CheckParameter(count);

    *count = iterator->GetCount();

     return Ok;
}

GpStatus WINGDIPAPI
GdipPathIterGetSubpathCount(
    GpPathIterator* iterator,
    INT* count
    )
{
    API_ENTRY(GdipPathIterGetSubpathCount);
    CheckParameterValid(iterator);
    CheckObjectBusy(iterator);
    CheckParameter(count);

    *count = iterator->GetSubpathCount();

    return Ok;
}

GpStatus WINGDIPAPI
GdipPathIterIsValid(
    GpPathIterator* iterator,
    BOOL* valid
    )
{
    API_ENTRY(GdipPathIterIsValid);
    CheckParameterValid(iterator);
    CheckObjectBusy(iterator);
    CheckParameter(valid);

    *valid = iterator->IsValid();

    return Ok;
}

GpStatus WINGDIPAPI
GdipPathIterHasCurve(
    GpPathIterator* iterator,
    BOOL* hasCurve
    )
{
    API_ENTRY(GdipPathIterHasCurve);
    CheckParameterValid(iterator);
    CheckObjectBusy(iterator);
    CheckParameter(hasCurve);

    *hasCurve = iterator->HasCurve();

    return Ok;
}

GpStatus WINGDIPAPI
GdipPathIterRewind(
    GpPathIterator* iterator
    )
{
    API_ENTRY(GdipPathIterRewind);
    CheckParameterValid(iterator);
    CheckObjectBusy(iterator);

    iterator->Rewind();

    return Ok;
}

GpStatus WINGDIPAPI
GdipPathIterEnumerate(
    GpPathIterator* iterator,
    INT* resultCount,
    GpPointF *points,
    BYTE *types,
    INT count)
{
    API_ENTRY(GdipPathIterEnumerate);
    CheckParameterValid(iterator);
    CheckObjectBusy(iterator);
    CheckParameter(resultCount);
    CheckParameter(points);
    CheckParameter(types);

    *resultCount = iterator->Enumerate(points, types, count);

    return Ok;
}

GpStatus WINGDIPAPI
GdipPathIterCopyData(
    GpPathIterator* iterator,
    INT* resultCount,
    GpPointF* points,
    BYTE* types,
    INT startIndex,
    INT endIndex)
{
    API_ENTRY(GdipPathIterCopyData);
    CheckParameterValid(iterator);
    CheckObjectBusy(iterator);
    CheckParameter(resultCount);
    CheckParameter(points);
    CheckParameter(types);

    *resultCount = iterator->CopyData(points, types, startIndex, endIndex);

    return Ok;
}

GpStatus
WINGDIPAPI
GdipCreateMatrix(GpMatrix **matrix)
{
    API_ENTRY(GdipCreateMatrix);
    CheckGdiplusInitialized; // We do this in all our object creation API's

    CheckParameter(matrix);

    *matrix = new GpMatrix();

    if (CheckValid(*matrix))
        return Ok;
    else
        return OutOfMemory;
}

GpStatus
WINGDIPAPI
GdipCreateMatrix2(
    REAL m11,
    REAL m12,
    REAL m21,
    REAL m22,
    REAL dx,
    REAL dy,
    GpMatrix ** outMatrix
    )
{
    API_ENTRY(GdipCreateMatrix2);
    CheckGdiplusInitialized; // We do this in all our object creation API's

    CheckParameter(outMatrix);

    GpMatrix * matrix;

    matrix = (GpMatrix *) InterlockedExchangePointer((PVOID *) &Globals::MatrixLookAside, NULL);

    if(matrix == NULL)
    {
        matrix = new GpMatrix(m11, m12, m21, m22, dx, dy);
    }
    else
    {
        matrix->GetObjectLock()->Reset();
        matrix->SetMatrix(m11, m12, m21, m22, dx, dy);
    }

    if (CheckValid(matrix))
    {
        *outMatrix = matrix;
        return Ok;
    }
    else
    {
        return OutOfMemory;
    }
}

GpStatus
WINGDIPAPI
GdipCreateMatrix3(
    GDIPCONST GpRectF *rect,
    GDIPCONST GpPointF *dstplg,
    GpMatrix **matrix
    )
{
    API_ENTRY(GdipCreateMatrix3);
    CheckGdiplusInitialized; // We do this in all our object creation API's

    CheckParameter(matrix && rect && dstplg);

    *matrix = new GpMatrix(dstplg, *rect);

    if (CheckValid(*matrix))
        return Ok;
    else
        return OutOfMemory;
}

GpStatus
WINGDIPAPI
GdipCreateMatrix3I(
    GDIPCONST GpRect *rect,
    GDIPCONST GpPoint *dstplg,
    GpMatrix **matrix
    )
{
    API_ENTRY(GdipCreateMatrix3I);
    CheckGdiplusInitialized; // We do this in all our object creation API's

    GpRectF rectf(TOREAL(rect->X), TOREAL(rect->Y), TOREAL(rect->Width), TOREAL(rect->Height));
    GpPointF dstplgf[3] = { GpPointF(TOREAL(dstplg[0].X), TOREAL(dstplg[0].Y)),
                            GpPointF(TOREAL(dstplg[1].X), TOREAL(dstplg[1].Y)),
                            GpPointF(TOREAL(dstplg[2].X), TOREAL(dstplg[2].Y)) };

    return GdipCreateMatrix3(&rectf, dstplgf, matrix);
}

GpStatus
WINGDIPAPI
GdipCloneMatrix(
    GpMatrix *matrix,
    GpMatrix **clonematrix
    )
{
    API_ENTRY(GdipCloneMatrix);
    CheckParameter(clonematrix);
    CheckParameterValid(matrix);
    CheckObjectBusy(matrix);

    *clonematrix = matrix->Clone();

    if (CheckValid(*clonematrix))
        return Ok;
    else
        return OutOfMemory;
}

GpStatus
WINGDIPAPI
GdipDeleteMatrix(
    GpMatrix *matrix
    )
{
    API_ENTRY(GdipDeleteMatrix);
    // NOTE: Do NOT call CheckParameterValid(), because we need to free
    // the object, even if it's not in a valid state.
    CheckParameter(matrix);
    CheckObjectBusyForDelete(matrix);

    if(matrix != NULL)
    {

        matrix = (GpMatrix *) InterlockedExchangePointer((PVOID *) &Globals::MatrixLookAside, (PVOID) matrix);

        if(matrix != NULL)
        {
            delete matrix;
        }
    }

    return Ok;
}

GpStatus
WINGDIPAPI
GdipSetMatrixElements(
    GpMatrix *matrix,
    REAL m11,
    REAL m12,
    REAL m21,
    REAL m22,
    REAL dx,
    REAL dy
    )
{
    API_ENTRY(GdipSetMatrixElements);
   CheckParameterValid(matrix);
   CheckObjectBusy(matrix);

   REAL m[6] = { m11, m12, m21, m22, dx, dy };

   matrix->SetMatrix((REAL*) &m);

   return Ok;
}

GpStatus
WINGDIPAPI
GdipMultiplyMatrix(
    GpMatrix *matrix,
    GpMatrix *matrix2,
    GpMatrixOrder order
    )
{
    API_ENTRY(GdipMultiplyMatrix);
    CheckParameterValid(matrix);
    CheckObjectBusy(matrix);
    CheckParameterValid(matrix2);
    CheckObjectBusy(matrix2);
    CheckParameter(MatrixOrderIsValid(order));
    
    if (order == MatrixOrderPrepend)
        matrix->Prepend(*matrix2);
    else
        matrix->Append(*matrix2);

    return Ok;
}

GpStatus
WINGDIPAPI
GdipTranslateMatrix(
    GpMatrix *matrix,
    REAL offsetX,
    REAL offsetY,
    GpMatrixOrder order
    )
{
    API_ENTRY(GdipTranslateMatrix);
    CheckParameterValid(matrix);
    CheckObjectBusy(matrix);
    CheckParameter(MatrixOrderIsValid(order));

    matrix->Translate(offsetX, offsetY, order);

    return Ok;
}

GpStatus
WINGDIPAPI
GdipScaleMatrix(
    GpMatrix *matrix,
    REAL scaleX,
    REAL scaleY,
    GpMatrixOrder order
    )
{
    API_ENTRY(GdipScaleMatrix);
    CheckParameterValid(matrix);
    CheckObjectBusy(matrix);
    CheckParameter(MatrixOrderIsValid(order));

    matrix->Scale(scaleX, scaleY, order);

    return Ok;
}

GpStatus
WINGDIPAPI
GdipRotateMatrix(
    GpMatrix *matrix,
    REAL angle,
    GpMatrixOrder order
    )
{
    API_ENTRY(GdipRotateMatrix);
    CheckParameterValid(matrix);
    CheckObjectBusy(matrix);
    CheckParameter(MatrixOrderIsValid(order));

    matrix->Rotate(angle, order);

    return Ok;
}

GpStatus
WINGDIPAPI
GdipShearMatrix(
    GpMatrix *matrix,
    REAL shearX,
    REAL shearY,
    GpMatrixOrder order
    )
{
    API_ENTRY(GdipShearMatrix);
    CheckParameterValid(matrix);
    CheckObjectBusy(matrix);
    CheckParameter(MatrixOrderIsValid(order));

    matrix->Shear(shearX, shearY, order);

    return Ok;
}

GpStatus
WINGDIPAPI
GdipInvertMatrix(GpMatrix *matrix)
{
    API_ENTRY(GdipInvertMatrix);
   CheckParameterValid(matrix);
   CheckObjectBusy(matrix);

   return matrix->Invert();
}

GpStatus
WINGDIPAPI
GdipTransformMatrixPoints(
    GpMatrix *matrix,
    GpPointF *pts,
    INT count
    )
{
    API_ENTRY(GdipTransformMatrixPoints);
   CheckParameter(pts && count > 0);
   CheckParameterValid(matrix);
   CheckObjectBusy(matrix);

   matrix->Transform(pts, count);

   return Ok;
}

GpStatus
WINGDIPAPI
GdipTransformMatrixPointsI(
    GpMatrix *matrix,
    GpPoint *points,
    INT count
    )
{
    API_ENTRY(GdipTransformMatrixPointsI);
   StackBuffer buffer;

   GpPointF* pointsF = (GpPointF*) buffer.GetBuffer(count*sizeof(GpPointF));

   if(!pointsF) return OutOfMemory;

   for (INT i=0; i<count; i++)
   {
       pointsF[i].X = TOREAL(points[i].X);
       pointsF[i].Y = TOREAL(points[i].Y);
   }

   GpStatus status = GdipTransformMatrixPoints(matrix, pointsF, count);

   // convert back, rounding is a problem...

   if (status == Ok)
   {
       for (INT i=0; i<count; i++)
       {
           points[i].X = GpRound(pointsF[i].X);
           points[i].Y = GpRound(pointsF[i].Y);
       }
   }

   return status;
}

GpStatus
WINGDIPAPI
GdipVectorTransformMatrixPoints(
    GpMatrix *matrix,
    GpPointF *pointsF,
    INT count
    )
{
    API_ENTRY(GdipVectorTransformMatrixPoints);
   CheckParameter(pointsF && count > 0);
   CheckParameterValid(matrix);
   CheckObjectBusy(matrix);

   matrix->VectorTransform(pointsF, count);

   return Ok;
}

GpStatus
WINGDIPAPI
GdipVectorTransformMatrixPointsI(
    GpMatrix *matrix,
    GpPoint *points,
    INT count
    )
{
    API_ENTRY(GdipVectorTransformMatrixPointsI);
   CheckParameter(points && count > 0);
   CheckParameterValid(matrix);
   CheckObjectBusy(matrix);

   StackBuffer buffer;

   GpPointF* pointsF = (GpPointF*) buffer.GetBuffer(count*sizeof(GpPointF));

   if(!pointsF) return OutOfMemory;

   for (INT i=0; i<count; i++)
   {
       pointsF[i].X = TOREAL(points[i].X);
       pointsF[i].Y = TOREAL(points[i].Y);
   }

   matrix->VectorTransform(pointsF, count);

   // convert back, rounding is a problem...


   for (i=0; i<count; i++)
   {
        points[i].X = GpRound(pointsF[i].X);
        points[i].Y = GpRound(pointsF[i].Y);
   }

   return Ok;
}

GpStatus
WINGDIPAPI
GdipGetMatrixElements(
    GDIPCONST GpMatrix *matrix,
    REAL *m
   )
{
    API_ENTRY(GdipGetMatrixElements);
   CheckParameter(m);
   CheckParameterValid(matrix);
   CheckObjectBusy(matrix);

   matrix->GetMatrix(m);

   return Ok;
}

GpStatus
WINGDIPAPI
GdipIsMatrixInvertible(
    GDIPCONST GpMatrix *matrix,
    BOOL *result
    )
{
    API_ENTRY(GdipIsMatrixInvertible);
   CheckParameter(result);
   CheckParameterValid(matrix);
   CheckObjectBusy(matrix);

   *result = matrix->IsInvertible();

   return Ok;
}

GpStatus
WINGDIPAPI
GdipIsMatrixIdentity(
    GDIPCONST GpMatrix *matrix,
    BOOL *result
    )
{
    API_ENTRY(GdipIsMatrixIdentity);
   CheckParameter(result);
   CheckParameterValid(matrix);
   CheckObjectBusy(matrix);

   *result = matrix->IsIdentity();

   return Ok;
}

GpStatus
WINGDIPAPI
GdipIsMatrixEqual(
    GDIPCONST GpMatrix *matrix,
    GDIPCONST GpMatrix *matrix2,
    BOOL *result
    )
{
    API_ENTRY(GdipIsMatrixEqual);
    CheckParameter(result);
    CheckParameterValid(matrix);
    CheckObjectBusy(matrix);

    if (matrix != matrix2)
    {
        CheckParameterValid(matrix2);
        CheckObjectBusy(matrix2);

        *result = matrix->IsEqual(matrix2);
    }
    else
    {
        *result = TRUE;
    }

    return Ok;
}

GpStatus
WINGDIPAPI
GdipCreateRegion(
    GpRegion **region
    )
{
    API_ENTRY(GdipCreateRegion);
    CheckGdiplusInitialized; // We do this in all our object creation API's

    CheckParameter(region);

    *region = new GpRegion();

    if (CheckValid(*region))
        return Ok;
    else
        return OutOfMemory;
}

GpStatus
WINGDIPAPI
GdipCreateRegionRect(
    GDIPCONST GpRectF *rect,
    GpRegion **region
    )
{
    API_ENTRY(GdipCreateRegionRect);
    CheckGdiplusInitialized; // We do this in all our object creation API's

    CheckParameter(region && rect);

    *region = new GpRegion(rect);

    if (CheckValid(*region))
        return Ok;
    else
        return OutOfMemory;
}

GpStatus
WINGDIPAPI
GdipCreateRegionRectI(
    GDIPCONST GpRect *rect,
    GpRegion **region
    )
{
    API_ENTRY(GdipCreateRegionRectI);
    CheckGdiplusInitialized; // We do this in all our object creation API's

    GpRectF rectf(TOREAL(rect->X),
                  TOREAL(rect->Y),
                  TOREAL(rect->Width),
                  TOREAL(rect->Height));

    return GdipCreateRegionRect(&rectf, region);
}

GpStatus
WINGDIPAPI
GdipCreateRegionPath(
    GpPath *path,
    GpRegion **region
    )
{
    API_ENTRY(GdipCreateRegionPath);
    CheckGdiplusInitialized; // We do this in all our object creation API's

    CheckParameter(region);
    CheckParameterValid(path);
    CheckObjectBusy(path);

    *region = new GpRegion(path);

    if (CheckValid(*region))
        return Ok;
    else
        return OutOfMemory;
}

GpStatus
WINGDIPAPI
GdipCreateRegionRgnData(
    GDIPCONST BYTE *regionData,
    INT size,
    GpRegion **region
    )
{
    API_ENTRY(GdipCreateRegionRgnData);
    CheckGdiplusInitialized; // We do this in all our object creation API's

    CheckParameter(regionData);
    CheckParameter(region);

    *region = new GpRegion(regionData, size);

    if (CheckValid(*region))
        return Ok;
    else
        return GenericError;
}

GpStatus
WINGDIPAPI
GdipCreateRegionHrgn(
    HRGN hRgn,
    GpRegion **region
    )
{
    API_ENTRY(GdipCreateRegionHrgn);
    CheckGdiplusInitialized; // We do this in all our object creation API's

    CheckParameter(region && hRgn && (GetObjectTypeInternal(hRgn) == OBJ_REGION));

    *region = new GpRegion(hRgn);

    if (CheckValid(*region))
        return Ok;
    else
        return OutOfMemory;
}

GpStatus
WINGDIPAPI
GdipCloneRegion(
    GpRegion *region,
    GpRegion **cloneregion
    )
{
    API_ENTRY(GdipCloneRegion);
    CheckParameter(cloneregion);
    CheckParameterValid(region);
    CheckObjectBusy(region);

    *cloneregion = new GpRegion(region);

    if (CheckValid(*cloneregion))
        return Ok;
    else
        return OutOfMemory;
}

GpStatus
WINGDIPAPI
GdipDeleteRegion(
    GpRegion *region
    )
{
    API_ENTRY(GdipDeleteRegion);
    // NOTE: Do NOT call CheckParameterValid(), because we need to free
    // the object, even if it's not in a valid state.
    CheckParameter(region);
    CheckObjectBusyForDelete(region);

    delete region;

    return Ok;
}

GpStatus
WINGDIPAPI
GdipSetInfinite(
    GpRegion *region
)
{
    API_ENTRY(GdipSetInfinite);
    CheckParameterValid(region);
    CheckObjectBusy(region);

    region->SetInfinite();
    return Ok;
}

GpStatus
WINGDIPAPI
GdipSetEmpty(
    GpRegion *region
)
{
    API_ENTRY(GdipSetEmpty);
    CheckParameterValid(region);
    CheckObjectBusy(region);

    region->SetEmpty();
    return Ok;
}

GpStatus
WINGDIPAPI
GdipCombineRegionRect(
    GpRegion *                region,
    GDIPCONST GpRectF *       rect,
    CombineMode               combineMode
    )
{
    API_ENTRY(GdipCombineRegionRect);
    CheckParameter(rect);
    CheckParameterValid(region);
    CheckObjectBusy(region);
    CheckParameter(CombineModeIsValid(combineMode));

    return region->Combine(rect, combineMode);
}

GpStatus
WINGDIPAPI
GdipCombineRegionRectI(
    GpRegion *                region,
    GDIPCONST GpRect *        rect,
    CombineMode               combineMode
    )
{
    API_ENTRY(GdipCombineRegionRectI);
    GpRectF rectf(TOREAL(rect->X),
                  TOREAL(rect->Y),
                  TOREAL(rect->Width),
                  TOREAL(rect->Height));

    return GdipCombineRegionRect(region, &rectf, combineMode);
}

GpStatus
WINGDIPAPI
GdipCombineRegionPath(
    GpRegion *      region,
    GpPath *        path,
    CombineMode     combineMode
    )
{
    API_ENTRY(GdipCombineRegionPath);
    CheckParameterValid(region);
    CheckParameterValid(path);
    CheckObjectBusy(region);
    CheckObjectBusy(path);
    CheckParameter(CombineModeIsValid(combineMode));

    return region->Combine(path, combineMode);
}

GpStatus
WINGDIPAPI
GdipCombineRegionRegion(
    GpRegion *      region,
    GpRegion *      region2,
    CombineMode     combineMode
    )
{
    API_ENTRY(GdipCombineRegionRegion);
    CheckParameterValid(region);
    CheckObjectBusy(region);
    CheckParameterValid(region2);
    CheckObjectBusy(region2);
    CheckParameter(CombineModeIsValid(combineMode));

    return region->Combine(region2, combineMode);
}

GpStatus
WINGDIPAPI
GdipTranslateRegion(
    GpRegion *region,
    REAL dx,
    REAL dy
    )
{
    API_ENTRY(GdipTranslateRegion);
   CheckParameter(region);
   CheckParameterValid(region);

   region->Offset(dx, dy);

   return Ok;
}

GpStatus
WINGDIPAPI
GdipTranslateRegionI(
    GpRegion *region,
    INT dx,
    INT dy
    )
{
    API_ENTRY(GdipTranslateRegionI);
   return GdipTranslateRegion(region, TOREAL(dx), TOREAL(dy));
}

GpStatus
WINGDIPAPI
GdipTransformRegion(
    GpRegion *region,
    GpMatrix *matrix
    )
{
    API_ENTRY(GdipTransformRegion);
   CheckParameterValid(matrix);
   CheckObjectBusy(matrix);
   CheckParameterValid(region);
   CheckObjectBusy(region);

   return region->Transform(matrix);
}

GpStatus
WINGDIPAPI
GdipGetRegionBounds(
    GpRegion *region,
    GpGraphics *graphics,
    GpRectF *rect
    )
{
    API_ENTRY(GdipGetRegionBounds);
    CheckParameter(rect);
    CheckParameterValid(region);
    CheckObjectBusy(region);
    CheckParameterValid(graphics);
    CheckObjectBusy(graphics);


    return region->GetBounds(graphics, rect);
}

GpStatus
WINGDIPAPI
GdipGetRegionBoundsI(
    GpRegion *region,
    GpGraphics *graphics,
    GpRect *rect
    )
{
    API_ENTRY(GdipGetRegionBoundsI);
    CheckParameter(rect);
    CheckParameterValid(region);
    CheckObjectBusy(region);
    CheckParameterValid(graphics);
    CheckObjectBusy(graphics);


    GpRectF     rectF;
    GpStatus    status = region->GetBounds(graphics, &rectF);

    if (status == Ok)
    {
        rect->X      = GpRound(rectF.X);
        rect->Y      = GpRound(rectF.Y);
        rect->Width  = GpRound(rectF.Width);
        rect->Height = GpRound(rectF.Height);
    }
    return status;
}

GpStatus
WINGDIPAPI
GdipGetRegionHRgn(
    GpRegion *region,
    GpGraphics *graphics,   // can be NULL
    HRGN *hRgn
    )
{
    API_ENTRY(GdipGetRegionHRgn);
    CheckParameter(hRgn);
    CheckParameterValid(region);
    CheckObjectBusy(region);


    if (graphics != NULL)
    {
        CheckParameterValid(graphics);
        CheckObjectBusy(graphics);
        return region->GetHRgn(graphics, hRgn);
    }
    return region->GetHRgn((GpGraphics*)NULL, hRgn);
}

GpStatus
WINGDIPAPI
GdipIsEmptyRegion(
    GpRegion *region,
    GpGraphics *graphics,
    BOOL *result
    )
{
    API_ENTRY(GdipIsEmptyRegion);
    CheckParameter(result);
    CheckParameterValid(region);
    CheckObjectBusy(region);
    CheckParameterValid(graphics);
    CheckObjectBusy(graphics);

    GpMatrix worldToDevice;

    Status status;

    graphics->GetWorldToDeviceTransform(&worldToDevice);

    status = region->IsEmpty(&worldToDevice, result);

    return status;
}

GpStatus
WINGDIPAPI
GdipIsInfiniteRegion(
    GpRegion *region,
    GpGraphics *graphics,
    BOOL *result
    )
{
    API_ENTRY(GdipIsInfiniteRegion);
    CheckParameter(result);
    CheckParameterValid(region);
    CheckObjectBusy(region);
    CheckParameterValid(graphics);
    CheckObjectBusy(graphics);

    GpMatrix worldToDevice;

    Status status;

    graphics->GetWorldToDeviceTransform(&worldToDevice);

    status = region->IsInfinite(&worldToDevice, result);

    return status;
}

GpStatus
WINGDIPAPI
GdipIsEqualRegion(
    GpRegion *region,
    GpRegion *region2,
    GpGraphics *graphics,
    BOOL *result
    )
{
    API_ENTRY(GdipIsEqualRegion);
    CheckParameter(result);
    CheckParameterValid(region);
    CheckObjectBusy(region);
    CheckParameterValid(graphics);
    CheckObjectBusy(graphics);

    Status status;

    if (region != region2)
    {
        CheckParameterValid(region2);
        CheckObjectBusy(region2);


        GpMatrix worldToDevice;

        graphics->GetWorldToDeviceTransform(&worldToDevice);

        status = region->IsEqual(region2, &worldToDevice, result);
    }
    else
    {
        *result = TRUE;
        status = Ok;
    }

    return status;
}

GpStatus
WINGDIPAPI
GdipGetRegionDataSize(
    GpRegion *  region,
    UINT *       bufferSize
    )
{
    API_ENTRY(GdipGetRegionDataSize);
    CheckParameterValid(region);
    CheckObjectBusy(region);
    CheckParameter(bufferSize);


    if ((*bufferSize = region->GetExternalDataSize()) > 0)
    {
        return Ok;
    }
    return GenericError;
}

GpStatus
WINGDIPAPI
GdipGetRegionData(
    GpRegion *  region,
    BYTE *      buffer,
    UINT         bufferSize,
    UINT *       sizeFilled
    )
{
    API_ENTRY(GdipGetRegionData);
    CheckParameterValid(region);
    CheckObjectBusy(region);
    CheckParameter(buffer);
    CheckParameter(bufferSize > 0);


    UINT    filled = bufferSize;

    GpStatus status = region->GetExternalData(buffer, filled);

    ASSERT((INT)filled <= bufferSize);
    if (sizeFilled != NULL)
    {
        *sizeFilled = filled;
    }

    return status;
}

GpStatus
WINGDIPAPI
GdipIsVisibleRegionPoint(
    GpRegion *region,
    REAL x,
    REAL y,
    GpGraphics *graphics,
    BOOL *result
    )
{
    API_ENTRY(GdipIsVisibleRegionPoint);
    CheckParameter(result);
    CheckParameterValid(region);
    CheckObjectBusy(region);


    Status status;

    GpPointF pt(x, y);
    GpMatrix worldToDevice;

    if (graphics != NULL)
    {
        CheckParameterValid(graphics);
        CheckObjectBusy(graphics);

        graphics->GetWorldToDeviceTransform(&worldToDevice);
    }

    status = region->IsVisible(&pt, &worldToDevice, result);

    return status;
}

GpStatus
WINGDIPAPI
GdipIsVisibleRegionPointI(
    GpRegion *region,
    INT x,
    INT y,
    GpGraphics *graphics,
    BOOL *result
    )
{
    API_ENTRY(GdipIsVisibleRegionPointI);
    return GdipIsVisibleRegionPoint(region, TOREAL(x), TOREAL(y), graphics, result);
}

GpStatus
WINGDIPAPI
GdipIsVisibleRegionRect(
    GpRegion *region,
    REAL x,
    REAL y,
    REAL width,
    REAL height,
    GpGraphics *graphics,
    BOOL *result
    )
{
    API_ENTRY(GdipIsVisibleRegionRect);
    CheckParameter(result);
    CheckParameterValid(region);
    CheckObjectBusy(region);


    Status status;

    GpRectF rect(x, y, width, height);
    GpMatrix worldToDevice;

    if (graphics != NULL)
    {
        CheckParameterValid(graphics);
        CheckObjectBusy(graphics);

        graphics->GetWorldToDeviceTransform(&worldToDevice);
    }

    status = region->IsVisible(&rect, &worldToDevice, result);

    return status;
}


GpStatus
WINGDIPAPI
GdipIsVisibleRegionRectI(
    GpRegion *region,
    INT x,
    INT y,
    INT width,
    INT height,
    GpGraphics *graphics,
    BOOL *result
    )
{
    API_ENTRY(GdipIsVisibleRegionRectI);
    return GdipIsVisibleRegionRect(region,
                                   TOREAL(x),
                                   TOREAL(y),
                                   TOREAL(width),
                                   TOREAL(height),
                                   graphics,
                                   result);
}

GpStatus
WINGDIPAPI
GdipGetRegionScansCount(
    GpRegion *region,
    UINT *count,
    GpMatrix *matrix
    )
{
    API_ENTRY(GdipGetRegionScansCount);
    CheckParameterValid(region);
    CheckObjectBusy(region);
    CheckParameter(count);
    CheckParameterValid(matrix);
    CheckObjectBusy(matrix);


    // !! Rewrite this API to be more efficient
    return region->GetRegionScans((GpRect*)NULL,
                                  (INT*)count,
                                  matrix);
}

// If rects is NULL, return the count of rects in the region.
// Otherwise, assume rects is big enough to hold all the region rects
// and fill them in and return the number of rects filled in.
GpStatus
WINGDIPAPI
GdipGetRegionScans(
    GpRegion *region,
    GpRectF *rects,     // NULL to just get the count
    INT *count,
    GpMatrix *matrix
    )
{
    API_ENTRY(GdipGetRegionScans);
    CheckParameterValid(region);
    CheckObjectBusy(region);
    CheckParameter(count);
    CheckParameterValid(matrix);
    CheckObjectBusy(matrix);


    // !! Rewrite this API to verify IN count is sufficient
    return region->GetRegionScans(rects, count, matrix);
}

// If rects is NULL, return the count of rects in the region.
// Otherwise, assume rects is big enough to hold all the region rects
// and fill them in and return the number of rects filled in.
GpStatus
WINGDIPAPI
GdipGetRegionScansI(
    GpRegion *region,
    GpRect *rects,      // NULL to just get the count
    INT *count,
    GpMatrix *matrix
    )
{
    API_ENTRY(GdipGetRegionScansI);
    CheckParameterValid(region);
    CheckObjectBusy(region);
    CheckParameter(count);
    CheckParameterValid(matrix);
    CheckObjectBusy(matrix);


    return region->GetRegionScans(rects, count, matrix);
}

GpStatus
WINGDIPAPI
GdipCloneBrush(
    GpBrush *brush,
    GpBrush **clonebrush
    )
{
    API_ENTRY(GdipCloneBrush);
    CheckParameter(clonebrush);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    *clonebrush = brush->Clone();

    if (CheckValid(*clonebrush))
        return Ok;
    else
        return OutOfMemory;
}

GpStatus
WINGDIPAPI
GdipDeleteBrush(
    GpBrush *brush
    )
{
    API_ENTRY(GdipDeleteBrush);
    // NOTE: Do NOT call CheckParameterValid(), because we need to free
    // the object, even if it's not in a valid state.
    CheckParameter(brush);
    CheckObjectBusyForDelete(brush);

    delete brush;

    return Ok;
}

GpStatus
WINGDIPAPI
GdipGetBrushType(
    GpBrush *brush,
    GpBrushType *type
    )
{
    API_ENTRY(GdipGetBrushType);
    CheckParameter(type);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    *type = brush->GetBrushType();

    return Ok;
}

GpStatus
WINGDIPAPI
GdipCreateHatchBrush(
    GpHatchStyle hatchstyle,
    ARGB forecol,
    ARGB backcol,
    GpHatch **hatch
    )
{
    API_ENTRY(GdipCreateHatchBrush);
    CheckGdiplusInitialized; // We do this in all our object creation API's

    CheckParameter((hatchstyle >= HatchStyleMin) && (hatchstyle <= HatchStyleMax));
    CheckParameter(hatch);
    CheckColorParameter(forecol);
    CheckColorParameter(backcol);

    GpColor fore(forecol);
    GpColor back(backcol);

    *hatch = new GpHatch(hatchstyle, fore, back);

    if (CheckValid(*hatch))
        return Ok;
    else
        return OutOfMemory;
}

GpStatus
WINGDIPAPI
GdipGetHatchStyle(
    GpHatch *brush,
    GpHatchStyle *hatchStyle
    )
{
    API_ENTRY(GdipGetHatchStyle);
    CheckParameter(hatchStyle);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    *hatchStyle = brush->GetHatchStyle();

    return Ok;
}

GpStatus
WINGDIPAPI
GdipGetHatchForegroundColor(
    GpHatch *brush,
    ARGB *argb
    )
{
    API_ENTRY(GdipGetHatchForegroundColor);
    CheckParameter(argb);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    GpColor foreColor;

    GpStatus status = brush->GetForegroundColor((GpColor*)&foreColor);

    *argb = foreColor.GetValue();

    return status;
}

GpStatus
WINGDIPAPI
GdipGetHatchBackgroundColor(
    GpHatch *brush,
    ARGB *argb
    )
{
    API_ENTRY(GdipGetHatchBackgroundColor);
    CheckParameter(argb);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    GpColor backColor;

    GpStatus status = brush->GetBackgroundColor((GpColor*)&backColor);

    *argb = backColor.GetValue();

    return status;
}

GpStatus
WINGDIPAPI
GdipCreateTexture(
    GpImage *image,
    GpWrapMode wrapmode,
    GpTexture **texture
    )
{
    API_ENTRY(GdipCreateTexture);
    CheckGdiplusInitialized; // We do this in all our object creation API's

    CheckParameter(texture);
    CheckParameterValid(image);
    CheckObjectBusy(image);


    *texture = new GpTexture(image, wrapmode);

    if (CheckValid(*texture))
        return Ok;
    else
        return OutOfMemory;
}

GpStatus
WINGDIPAPI
GdipCreateTexture2(
    GpImage *image,
    GpWrapMode wrapmode,
    REAL x,
    REAL y,
    REAL width,
    REAL height,
    GpTexture **texture
    )
{
    API_ENTRY(GdipCreateTexture2);
    CheckGdiplusInitialized; // We do this in all our object creation API's

    CheckParameter(texture);
    CheckParameterValid(image);
    CheckObjectBusy(image);

    GpRectF rect(x, y, width, height);


    *texture = new GpTexture(image, wrapmode, rect);

    if (CheckValid(*texture))
        return Ok;
    else
        return OutOfMemory;
}
GpStatus
WINGDIPAPI
GdipCreateTextureIA(
    GpImage *image,
    GDIPCONST GpImageAttributes *imageAttributes,
    REAL x,
    REAL y,
    REAL width,
    REAL height,
    GpTexture **texture
    )
{
    API_ENTRY(GdipCreateTextureIA);
    CheckGdiplusInitialized; // We do this in all our object creation API's

    CheckParameter(texture);
    CheckParameterValid(image);
    CheckObjectBusy(image);
    CheckOptionalParameterValid(imageAttributes);
    CheckOptionalObjectBusy(imageAttributes);

    GpRectF rect(x, y, width, height);


    *texture = new GpTexture(image, rect, imageAttributes);

    if (CheckValid(*texture))
        return Ok;
    else
        return OutOfMemory;
}

GpStatus
WINGDIPAPI
GdipCreateTexture2I(
    GpImage *image,
    GpWrapMode wrapmode,
    INT x,
    INT y,
    INT width,
    INT height,
    GpTexture **texture
    )
{
    API_ENTRY(GdipCreateTexture2I);
    CheckGdiplusInitialized; // We do this in all our object creation API's

   return GdipCreateTexture2(image,
                             wrapmode,
                             TOREAL(x),
                             TOREAL(y),
                             TOREAL(width),
                             TOREAL(height),
                             texture);
}

GpStatus
WINGDIPAPI
GdipCreateTextureIAI(
    GpImage *image,
    GDIPCONST GpImageAttributes *imageAttributes,
    INT x,
    INT y,
    INT width,
    INT height,
    GpTexture **texture
    )
{

    return GdipCreateTextureIA(image,
                               imageAttributes,
                               TOREAL(x),
                               TOREAL(y),
                               TOREAL(width),
                               TOREAL(height),
                               texture);
}

GpStatus
WINGDIPAPI
GdipSetTextureTransform(
    GpTexture *brush,
    GDIPCONST GpMatrix *matrix
    )
{
    API_ENTRY(GdipSetTextureTransform);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);
    CheckParameterValid(matrix);
    CheckObjectBusy(matrix);

    return brush->SetTransform(*matrix);
}

GpStatus
WINGDIPAPI
GdipGetTextureTransform(
    GpTexture *brush,
    GpMatrix *matrix
    )
{
    API_ENTRY(GdipGetTextureTransform);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);
    CheckParameterValid(matrix);
    CheckObjectBusy(matrix);

    return brush->GetTransform(matrix);
}

GpStatus
WINGDIPAPI
GdipResetTextureTransform(
    GpTexture* brush)
{
    API_ENTRY(GdipResetTextureTransform);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    return brush->ResetTransform();
}

GpStatus
WINGDIPAPI
GdipMultiplyTextureTransform(
    GpTexture* brush,
    GDIPCONST GpMatrix *matrix,
    GpMatrixOrder order)
{
    API_ENTRY(GdipMultiplyTextureTransform);
    if(matrix == NULL)
        return Ok;

    CheckParameterValid(brush);
    CheckObjectBusy(brush);
    CheckParameterValid(matrix);
    CheckObjectBusy(matrix);

    return brush->MultiplyTransform(*matrix, order);
}

GpStatus
WINGDIPAPI
GdipTranslateTextureTransform(
    GpTexture* brush,
    REAL dx,
    REAL dy,
    GpMatrixOrder order
    )
{
    API_ENTRY(GdipTranslateTextureTransform);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);
    CheckParameter(MatrixOrderIsValid(order));

    return brush->TranslateTransform(dx, dy, order);
}

GpStatus
WINGDIPAPI
GdipScaleTextureTransform(
    GpTexture* brush,
    REAL sx,
    REAL sy,
    GpMatrixOrder order
    )
{
    API_ENTRY(GdipScaleTextureTransform);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);
    CheckParameter(MatrixOrderIsValid(order));

    return brush->ScaleTransform(sx, sy, order);
}

GpStatus
WINGDIPAPI
GdipRotateTextureTransform(
    GpTexture* brush,
    REAL angle,
    GpMatrixOrder order
    )
{
    API_ENTRY(GdipRotateTextureTransform);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);
    CheckParameter(MatrixOrderIsValid(order));

    return brush->RotateTransform(angle, order);
}

GpStatus
WINGDIPAPI
GdipSetTextureWrapMode(
    GpTexture *brush,
    GpWrapMode wrapmode
    )
{
    API_ENTRY(GdipSetTextureWrapMode);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    brush->SetWrapMode(wrapmode);

    return Ok;
}

GpStatus
WINGDIPAPI
GdipGetTextureWrapMode(
    GpTexture *brush,
    GpWrapMode *wrapmode
    )
{
    API_ENTRY(GdipGetTextureWrapMode);
    CheckParameter(wrapmode);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    *wrapmode = (GpWrapMode)brush->GetWrapMode();

    return Ok;
}

GpStatus
WINGDIPAPI
GdipGetTextureImage(
    GpTexture *brush,
    GpImage **image
    )
{
    API_ENTRY(GdipGetTextureImage);
    // GetImage returns a pointer to the internal GpImage structure. Because
    // we have to create a new Image wrapper around it and give it to the caller
    // at the API level, we return a clone so they can throw it away without
    // destroying our internal brush structure.
    GpImage *imgtmp;
    imgtmp = brush->GetImage();
    *image = imgtmp->Clone();
    return Ok;
}

GpStatus
WINGDIPAPI
GdipCreateSolidFill(
    ARGB color,
    GpSolidFill **solidfill
    )
{
    API_ENTRY(GdipCreateSolidFill);
    CheckGdiplusInitialized; // We do this in all our object creation API's

    CheckParameter(solidfill);
    CheckColorParameter(color);

    *solidfill = new GpSolidFill(GpColor(color));

    if (CheckValid(*solidfill))
        return Ok;
    else
        return OutOfMemory;
}

GpStatus
WINGDIPAPI
GdipSetSolidFillColor(
    GpSolidFill *brush,
    ARGB color
    )
{
    API_ENTRY(GdipSetSolidFillColor);
    CheckColorParameter(color);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    brush->SetColor(GpColor(color));

    return Ok;
}

GpStatus
WINGDIPAPI
GdipGetSolidFillColor(
    GpSolidFill *brush,
    ARGB *color
    )
{
    API_ENTRY(GdipGetSolidFillColor);
    CheckParameter(color);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    *color = (brush->GetColor()).GetValue();

    return Ok;
}

GpStatus
WINGDIPAPI
GdipCreateLineBrush(
    GDIPCONST GpPointF* point1,
    GDIPCONST GpPointF* point2,
    ARGB color1,
    ARGB color2,
    GpWrapMode wrapmode,
    GpLineGradient **linegrad
    )
{
    API_ENTRY(GdipCreateLineBrush);
    CheckGdiplusInitialized; // We do this in all our object creation API's

    CheckParameter(linegrad && point1 && point2);
    CheckColorParameter(color1);
    CheckColorParameter(color2);

    if(wrapmode == WrapModeClamp)
    {
        return InvalidParameter;
    }

    GpColor c1(color1);
    GpColor c2(color2);

    *linegrad = new GpLineGradient(*point1, *point2, c1, c2, wrapmode);

    if (CheckValid(*linegrad))
        return Ok;
    else
        return OutOfMemory;
}

GpStatus
WINGDIPAPI
GdipCreateLineBrushI(
    GDIPCONST GpPoint* point1,
    GDIPCONST GpPoint* point2,
    ARGB color1,
    ARGB color2,
    GpWrapMode wrapmode,
    GpLineGradient **linegrad
    )
{
    API_ENTRY(GdipCreateLineBrushI);
    CheckGdiplusInitialized; // We do this in all our object creation API's

    CheckColorParameter(color1);
    CheckColorParameter(color2);
    CheckParameter(point1 && point2);

    if(wrapmode == WrapModeClamp)
    {
        return InvalidParameter;
    }

    GpPointF point1F(TOREAL(point1->X), TOREAL(point1->Y));
    GpPointF point2F(TOREAL(point2->X), TOREAL(point2->Y));

    return GdipCreateLineBrush(&point1F,
                               &point2F,
                               color1,
                               color2,
                               wrapmode,
                               linegrad);
}

GpStatus
WINGDIPAPI
GdipCreateLineBrushFromRect(
    GDIPCONST GpRectF* rect,
    ARGB color1,
    ARGB color2,
    LinearGradientMode mode,
    GpWrapMode wrapmode,
    GpLineGradient **linegrad)
{
    API_ENTRY(GdipCreateLineBrushFromRect);
    CheckGdiplusInitialized; // We do this in all our object creation API's

    CheckColorParameter(color1);
    CheckColorParameter(color2);
    CheckParameter(linegrad && rect);

    if(wrapmode == WrapModeClamp)
    {
        return InvalidParameter;
    }

    GpColor c1(color1);
    GpColor c2(color2);

    *linegrad = new GpLineGradient(*rect, c1, c2, mode, wrapmode);

    if (CheckValid(*linegrad))
        return Ok;
    else
        return OutOfMemory;
}

GpStatus
WINGDIPAPI
GdipCreateLineBrushFromRectI(
    GDIPCONST GpRect* rect,
    ARGB color1,
    ARGB color2,
    LinearGradientMode mode,
    GpWrapMode wrapmode,
    GpLineGradient **linegrad)
{
    API_ENTRY(GdipCreateLineBrushFromRectI);
    CheckGdiplusInitialized; // We do this in all our object creation API's

    CheckColorParameter(color1);
    CheckColorParameter(color2);
    CheckParameter(rect);

    if(wrapmode == WrapModeClamp)
    {
        return InvalidParameter;
    }

    GpRectF rectF(TOREAL(rect->X),
                  TOREAL(rect->Y),
                  TOREAL(rect->Width),
                  TOREAL(rect->Height));

    return GdipCreateLineBrushFromRect(&rectF,
                                       color1,
                                       color2,
                                       mode,
                                       wrapmode,
                                       linegrad);
}

GpStatus
WINGDIPAPI
GdipCreateLineBrushFromRectWithAngle(
    GDIPCONST GpRectF* rect,
    ARGB color1,
    ARGB color2,
    REAL angle,
    BOOL isAngleScalable,
    GpWrapMode wrapmode,
    GpLineGradient **linegrad)
{
    API_ENTRY(GdipCreateLineBrushFromRectWithAngle);
    CheckGdiplusInitialized; // We do this in all our object creation API's

    CheckColorParameter(color1);
    CheckColorParameter(color2);
    CheckParameter(linegrad && rect);

    if(wrapmode == WrapModeClamp)
    {
        return InvalidParameter;
    }

    GpColor c1(color1);
    GpColor c2(color2);

    *linegrad = new GpLineGradient(*rect, c1, c2, angle,
                        isAngleScalable, wrapmode);

    if (CheckValid(*linegrad))
        return Ok;
    else
        return OutOfMemory;
}

GpStatus
WINGDIPAPI
GdipCreateLineBrushFromRectWithAngleI(
    GDIPCONST GpRect* rect,
    ARGB color1,
    ARGB color2,
    REAL angle,
    BOOL isAngleScalable,
    GpWrapMode wrapmode,
    GpLineGradient **linegrad)
{
    API_ENTRY(GdipCreateLineBrushFromRectWithAngleI);
    CheckGdiplusInitialized; // We do this in all our object creation API's

    CheckColorParameter(color1);
    CheckColorParameter(color2);
    CheckParameter(rect);

    if(wrapmode == WrapModeClamp)
    {
        return InvalidParameter;
    }

    GpRectF rectF(TOREAL(rect->X),
                  TOREAL(rect->Y),
                  TOREAL(rect->Width),
                  TOREAL(rect->Height));

    return GdipCreateLineBrushFromRectWithAngle(&rectF,
                                       color1,
                                       color2,
                                       angle,
                                       isAngleScalable,
                                       wrapmode,
                                       linegrad);
}

GpStatus
WINGDIPAPI
GdipSetLineColors(
    GpLineGradient *brush,
    ARGB argb1,
    ARGB argb2
    )
{
    API_ENTRY(GdipSetLineColors);
    CheckColorParameter(argb1);
    CheckColorParameter(argb2);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    GpColor c1(argb1);
    GpColor c2(argb2);

    brush->SetLineColors(c1, c2);

    return Ok;
}

GpStatus
WINGDIPAPI
GdipGetLineColors(
    GpLineGradient *brush,
    ARGB *argb
    )
{
    API_ENTRY(GdipGetLineColors);
   CheckParameter(argb);
   CheckParameterValid(brush);
   CheckObjectBusy(brush);

   GpColor colors[2];
   brush->GetLineColors(&colors[0]);

   argb[0] = colors[0].GetValue();
   argb[1] = colors[1].GetValue();

   return Ok;
}

GpStatus
WINGDIPAPI
GdipGetLineRect(
    GpLineGradient *brush,
    GpRectF *rect
    )
{
    API_ENTRY(GdipGetLineRect);
   CheckParameter(rect);
   CheckParameterValid(brush);
   CheckObjectBusy(brush);

   brush->GetRect(*rect);

   return Ok;
}

GpStatus
WINGDIPAPI
GdipGetLineRectI(
    GpLineGradient *brush,
    GpRect *rect
    )
{
    API_ENTRY(GdipGetLineRectI);
    CheckParameter(rect);

    GpRectF rectF;

    GpStatus status = GdipGetLineRect(brush, &rectF);

    if (status == Ok)
    {

        rect->X = GpRound(rectF.X);
        rect->Y = GpRound(rectF.Y);
        rect->Width = GpRound(rectF.Width);
        rect->Height = GpRound(rectF.Height);
    }

    return status;
}

GpStatus
WINGDIPAPI
GdipSetLineGammaCorrection(
    GpLineGradient *brush,
    BOOL useGammaCorrection
    )
{
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    brush->SetGammaCorrection(useGammaCorrection);
    return Ok;
}

GpStatus
WINGDIPAPI
GdipGetLineGammaCorrection(
    GpLineGradient *brush,
    BOOL *useGammaCorrection)
{
    CheckParameter(useGammaCorrection);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    *useGammaCorrection = brush->GetGammaCorrection();

    return Ok;
}

GpStatus
WINGDIPAPI
GdipGetLineBlendCount(
    GpLineGradient *brush,
    INT *count
    )
{
    API_ENTRY(GdipGetLineBlendCount);
   CheckParameter(count);
   CheckParameterValid(brush);
   CheckObjectBusy(brush);

   *count = brush->GetBlendCount();

   return Ok;
}

GpStatus
WINGDIPAPI
GdipGetLineBlend(
    GpLineGradient *brush,
    REAL *blend,
    REAL *positions,
    INT count
    )
{
    API_ENTRY(GdipGetLineBlend);
   CheckParameter(blend);
   CheckParameter(positions);
   CheckParameterValid(brush);
   CheckObjectBusy(brush);

   return brush->GetBlend(blend, positions, count);
}

GpStatus
WINGDIPAPI
GdipSetLineBlend(
    GpLineGradient *brush,
    GDIPCONST REAL *blend,
    GDIPCONST REAL *positions,
    INT count
    )
{
    API_ENTRY(GdipSetLineBlend);
   CheckParameter(blend);
   CheckParameter(positions);
   CheckParameterValid(brush);
   CheckObjectBusy(brush);

   return brush->SetBlend(blend, positions, count);
}

GpStatus
WINGDIPAPI
GdipGetLinePresetBlendCount(
    GpLineGradient *brush,
    INT *count
    )
{
    API_ENTRY(GdipGetLinePresetBlendCount);
    CheckParameter(count);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    *count = brush->GetPresetBlendCount();

    return Ok;
}

GpStatus
WINGDIPAPI
GdipGetLinePresetBlend(
    GpLineGradient *brush,
    ARGB *blend,
    REAL *blendPositions,
    INT count
    )
{
    API_ENTRY(GdipGetLinePresetBlend);
    CheckParameter(blend);
    CheckParameter(blendPositions);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    if (count <= 0)
    {
        return InvalidParameter;
    }

    if (count < brush->GetPresetBlendCount())
    {
        return InsufficientBuffer;
    }

    StackBuffer buffer;

    GpColor* gpcolors = (GpColor*) buffer.GetBuffer(count*sizeof(GpColor));

    if(!gpcolors) return OutOfMemory;

    if (gpcolors)
    {
        GpStatus status = brush->GetPresetBlend(gpcolors, blendPositions, count);

        for(INT i = 0; i < count; i++)
        {
            blend[i] = gpcolors[i].GetValue();
        }

        return status;
    }
    else
        return OutOfMemory;
}

GpStatus
WINGDIPAPI
GdipSetLinePresetBlend(
    GpLineGradient *brush,
    GDIPCONST ARGB *blend,
    GDIPCONST REAL *blendPositions,
    INT count
    )
{
    API_ENTRY(GdipSetLinePresetBlend);
    CheckParameter(blend);
    CheckParameter(blendPositions);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    CheckParameter(count > 0)

    // blend positions must start at 0.0 and end at 1.0
    if (REALABS(blendPositions[0]) > REAL_EPSILON ||
        REALABS(1.0f - blendPositions[count-1]) > REAL_EPSILON)
    {
        return InvalidParameter;
    }

    StackBuffer buffer;

    GpColor* gpcolors = (GpColor*) buffer.GetBuffer(count*sizeof(GpColor));

    if(!gpcolors) return OutOfMemory;

    if(gpcolors)
    {
        for(INT i = 0; i < count; i++)
        {
            gpcolors[i].SetColor(blend[i]);
        }

        GpStatus status = brush->SetPresetBlend(gpcolors, blendPositions, count);

        return status;
    }
    else
        return OutOfMemory;
}

GpStatus
WINGDIPAPI
GdipSetLineSigmaBlend(
    GpLineGradient *brush,
    REAL focus,
    REAL scale
    )
{
    API_ENTRY(GdipSetLineSigmaBlend);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    return brush->SetSigmaBlend(focus, scale);
}

GpStatus
WINGDIPAPI
GdipSetLineLinearBlend(
    GpLineGradient *brush,
    REAL focus,
    REAL scale
    )
{
    API_ENTRY(GdipSetLineLinearBlend);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    return brush->SetLinearBlend(focus, scale);
}

GpStatus
WINGDIPAPI
GdipSetLineWrapMode(
    GpLineGradient *brush,
    GpWrapMode wrapmode
    )
{
    API_ENTRY(GdipSetLineWrapMode);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);
    GpStatus status = Ok;

    if(wrapmode != WrapModeClamp)
        brush->SetWrapMode(wrapmode);
    else
        status = InvalidParameter;

    return status;
}

GpStatus
WINGDIPAPI
GdipGetLineWrapMode(
    GpLineGradient *brush,
    GpWrapMode *wrapmode
    )
{
    API_ENTRY(GdipGetLineWrapMode);
   CheckParameter(wrapmode);
   CheckParameterValid(brush);
   CheckObjectBusy(brush);

   *wrapmode = (GpWrapMode)brush->GetWrapMode();

   return Ok;
}

GpStatus
WINGDIPAPI
GdipSetLineTransform(
    GpLineGradient *brush,
    GDIPCONST GpMatrix *matrix
    )
{
    API_ENTRY(GdipSetLineTransform);
   CheckParameterValid(brush);
   CheckObjectBusy(brush);
   CheckParameterValid(matrix);
   CheckObjectBusy(matrix);

   return brush->SetTransform(*matrix);
}

GpStatus
WINGDIPAPI
GdipGetLineTransform(
    GpLineGradient *brush,
    GpMatrix *matrix
    )
{
    API_ENTRY(GdipGetLineTransform);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);
    CheckParameterValid(matrix);
    CheckObjectBusy(matrix);

    return brush->GetTransform(matrix);
}

GpStatus
WINGDIPAPI
GdipResetLineTransform(
    GpLineGradient* brush)
{
    API_ENTRY(GdipResetLineTransform);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    return brush->ResetTransform();
}

GpStatus
WINGDIPAPI
GdipMultiplyLineTransform(
    GpLineGradient* brush,
    GDIPCONST GpMatrix *matrix,
    GpMatrixOrder order)
{
    API_ENTRY(GdipMultiplyLineTransform);
    if(matrix == NULL)
        return Ok;

    CheckParameterValid(brush);
    CheckObjectBusy(brush);
    CheckParameterValid(matrix);
    CheckObjectBusy(matrix);

    return brush->MultiplyTransform(*matrix, order);
}

GpStatus
WINGDIPAPI
GdipTranslateLineTransform(
    GpLineGradient* brush,
    REAL dx,
    REAL dy,
    GpMatrixOrder order
    )
{
    API_ENTRY(GdipTranslateLineTransform);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);
    CheckParameter(MatrixOrderIsValid(order));

    return brush->TranslateTransform(dx, dy, order);
}

GpStatus
WINGDIPAPI
GdipScaleLineTransform(
    GpLineGradient* brush,
    REAL sx,
    REAL sy,
    GpMatrixOrder order
    )
{
    API_ENTRY(GdipScaleLineTransform);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);
    CheckParameter(MatrixOrderIsValid(order));

    return brush->ScaleTransform(sx, sy, order);
}

GpStatus
WINGDIPAPI
GdipRotateLineTransform(
    GpLineGradient* brush,
    REAL angle,
    GpMatrixOrder order
    )
{
    API_ENTRY(GdipRotateLineTransform);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);
    CheckParameter(MatrixOrderIsValid(order));

    return brush->RotateTransform(angle, order);
}

GpStatus
WINGDIPAPI
GdipCreatePathGradient(
    GDIPCONST GpPointF* points,
    INT count,
    GpWrapMode wrapMode,
    GpPathGradient **brush
    )
{
    API_ENTRY(GdipCreatePathGradient);
    CheckGdiplusInitialized; // We do this in all our object creation API's

    CheckParameter(brush);

    *brush = new GpPathGradient(points, count, wrapMode);

    if (CheckValid(*brush))
        return Ok;
    else
        return OutOfMemory;
}

GpStatus
WINGDIPAPI
GdipCreatePathGradientI(
    GDIPCONST GpPoint* points,
    INT count,
    GpWrapMode wrapMode,
    GpPathGradient **brush
    )
{
    API_ENTRY(GdipCreatePathGradientI);
    CheckGdiplusInitialized; // We do this in all our object creation API's

    CheckParameter(points);

    StackBuffer buffer;

    GpPointF* pointsF = (GpPointF*) buffer.GetBuffer(count*sizeof(GpPointF));

    if(!pointsF) return OutOfMemory;

    for (INT i=0; i<count; i++)
    {
         pointsF[i].X = TOREAL(points[i].X);
         pointsF[i].Y = TOREAL(points[i].Y);
    }

    GpStatus status = GdipCreatePathGradient(pointsF, count, wrapMode, brush);

    return status;
}

GpStatus
WINGDIPAPI
GdipCreatePathGradientFromPath(
    GDIPCONST GpPath* path,
    GpPathGradient **brush
    )
{
    API_ENTRY(GdipCreatePathGradientFromPath);
    CheckGdiplusInitialized; // We do this in all our object creation API's

    CheckParameter(brush);

    *brush = new GpPathGradient(path);

    if (CheckValid(*brush))
        return Ok;
    else
        return OutOfMemory;
}

GpStatus
WINGDIPAPI
GdipGetPathGradientCenterColor(
    GpPathGradient *brush,
    ARGB* color
    )
{
    API_ENTRY(GdipGetPathGradientCenterColor);
    CheckParameter(color);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    GpColor center;
    brush->GetCenterColor(&center);
    *color = center.GetValue();

    return Ok;
}

GpStatus
WINGDIPAPI
GdipSetPathGradientCenterColor(
    GpPathGradient *brush,
    ARGB color
    )
{
    API_ENTRY(GdipSetPathGradientCenterColor);
    CheckColorParameter(color);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    GpColor center(color);
    brush->SetCenterColor(center);

    return Ok;
}

GpStatus
WINGDIPAPI
GdipGetPathGradientSurroundColorsWithCount(
    GpPathGradient *brush,
    ARGB* colors,
    INT* count
    )
{
    API_ENTRY(GdipGetPathGradientSurroundColorsWithCount);
    CheckParameter(colors);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    INT count1 = brush->GetNumberOfPoints();

    if(*count < count1 || count1 <= 0)
        return InvalidParameter;

    count1 = min(*count, count1);

    ARGB lastValue, nextValue;

    INT n = 1;

    for(INT i = 0; i < count1; i++)
    {
        GpColor color;

        brush->GetSurroundColor(&color, i);
        nextValue = color.GetValue();
        colors[i] = nextValue;

        if(i > 0)
        {
            if(nextValue != lastValue)
                n = i + 1;
        }
        lastValue = nextValue;
    }

    *count = n;

    return Ok;
}

GpStatus
WINGDIPAPI
GdipSetPathGradientSurroundColorsWithCount(
    GpPathGradient *brush,
    GDIPCONST ARGB* colors,
    INT* count
    )
{
    API_ENTRY(GdipSetPathGradientSurroundColorsWithCount);
    CheckParameter(colors);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    INT count1 = brush->GetNumberOfPoints();

    INT minCount = min(*count, count1);

    if(*count > count1 || minCount < 1)
    {
        return InvalidParameter;
    }

    GpColor *gpColors = new GpColor[count1];

    if(NULL == gpColors)
    {
        return OutOfMemory;
    }

    INT i;
    for(i = 0; i < minCount; i++)
    {
        gpColors[i].SetColor(colors[i]);
    }

    if(minCount < count1)
    {
        for(i = minCount; i < count1; i++)
        {
            gpColors[i].SetColor(colors[minCount - 1]);
        }
    }

    *count = minCount;
    GpStatus status = brush->SetSurroundColors(gpColors);

    delete[] gpColors;

    return Ok;
}

GpStatus
WINGDIPAPI
GdipGetPathGradientPath(
    GpPathGradient *brush,
    GpPath *path
    )
{
    API_ENTRY(GdipGetPathGradientPath);
    return NotImplemented;
}

GpStatus
WINGDIPAPI
GdipSetPathGradientPath(
    GpPathGradient *brush,
    GDIPCONST GpPath *path
    )
{
    API_ENTRY(GdipSetPathGradientPath);
    return NotImplemented;
}

GpStatus
WINGDIPAPI
GdipGetPathGradientCenterPoint(
    GpPathGradient *brush,
    GpPointF* point
    )
{
    API_ENTRY(GdipGetPathGradientCenterPoint);
    CheckParameter(point);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    return brush->GetCenterPoint(point);
}

GpStatus
WINGDIPAPI
GdipGetPathGradientCenterPointI(
    GpPathGradient *brush,
    GpPoint* point
    )
{
    API_ENTRY(GdipGetPathGradientCenterPointI);
    CheckParameter(point);

    GpPointF pointF;

    GpStatus status = GdipGetPathGradientCenterPoint(brush, &pointF);

    if (status == Ok)
    {

         point->X = GpRound(pointF.X);
         point->Y = GpRound(pointF.Y);
    }

    return status;
}

GpStatus
WINGDIPAPI
GdipSetPathGradientCenterPoint(
    GpPathGradient *brush,
    GDIPCONST GpPointF* point
    )
{
    API_ENTRY(GdipSetPathGradientCenterPoint);
    CheckParameter(point);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    return brush->SetCenterPoint(*point);
}

GpStatus
WINGDIPAPI
GdipSetPathGradientCenterPointI(
    GpPathGradient *brush,
    GDIPCONST GpPoint* point
    )
{
    API_ENTRY(GdipSetPathGradientCenterPointI);
    CheckParameter(point);

    GpPointF pointF(TOREAL(point->X), TOREAL(point->Y));

    return GdipSetPathGradientCenterPoint(brush, &pointF);
}

GpStatus
WINGDIPAPI
GdipGetPathGradientPointCount(
    GpPathGradient *brush,
    INT* count)
{
    API_ENTRY(GdipGetPathGradientPointCount);
    CheckParameter(count);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    *count = brush->GetNumberOfPoints();

    return Ok;
}

GpStatus
WINGDIPAPI
GdipGetPathGradientSurroundColorCount(
    GpPathGradient *brush,
    INT* count)
{
    API_ENTRY(GdipGetPathGradientSurroundColorCount);
    CheckParameter(count);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    *count = brush->GetNumberOfColors();

    return Ok;
}

GpStatus
WINGDIPAPI
GdipGetPathGradientRect(
    GpPathGradient *brush,
    GpRectF *rect
    )
{
    API_ENTRY(GdipGetPathGradientRect);
    CheckParameter(rect);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    brush->GetRect(*rect);

    return Ok;
}

GpStatus
WINGDIPAPI
GdipGetPathGradientRectI(
    GpPathGradient *brush,
    GpRect *rect
    )
{
    API_ENTRY(GdipGetPathGradientRectI);
    CheckParameter(rect);

    GpRectF rectF;

    GpStatus status = GdipGetPathGradientRect(brush, &rectF);

    if (status == Ok)
    {

        rect->X = GpRound(rectF.X);
        rect->Y = GpRound(rectF.Y);
        rect->Width = GpRound(rectF.Width);
        rect->Height = GpRound(rectF.Height);
    }

    return status;
}

GpStatus
WINGDIPAPI
GdipSetPathGradientGammaCorrection(
    GpPathGradient *brush,
    BOOL useGammaCorrection
    )
{
    API_ENTRY(GdipSetPathGradientGammaCorrection);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    brush->SetGammaCorrection(useGammaCorrection);
    return Ok;
}

GpStatus
WINGDIPAPI
GdipGetPathGradientGammaCorrection(
    GpPathGradient *brush,
    BOOL *useGammaCorrection)
{
    API_ENTRY(GdipGetPathGradientGammaCorrection);
    CheckParameter(useGammaCorrection);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    *useGammaCorrection = brush->GetGammaCorrection();

    return Ok;
}

GpStatus
WINGDIPAPI
GdipGetPathGradientBlendCount(
    GpPathGradient *brush,
    INT *count
    )
{
    API_ENTRY(GdipGetPathGradientBlendCount);
    CheckParameter(count);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    *count = brush->GetBlendCount();

    return Ok;
}

GpStatus
WINGDIPAPI
GdipGetPathGradientBlend(
    GpPathGradient *brush,
    REAL *blend,
    REAL *positions,
    INT count
    )
{
    API_ENTRY(GdipGetPathGradientBlend);
    CheckParameter(blend);
    CheckParameter(positions);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    return brush->GetBlend(blend, positions, count);
}

GpStatus
WINGDIPAPI
GdipSetPathGradientBlend(
    GpPathGradient *brush,
    GDIPCONST REAL *blend,
    GDIPCONST REAL *positions,
    INT count
    )
{
    API_ENTRY(GdipSetPathGradientBlend);
    CheckParameter(blend);
    CheckParameter(positions);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    return brush->SetBlend(blend, positions, count);
}

GpStatus
WINGDIPAPI
GdipGetPathGradientPresetBlendCount(
    GpPathGradient *brush,
    INT *count
    )
{
    API_ENTRY(GdipGetPathGradientPresetBlendCount);
   CheckParameter(count);
   CheckParameterValid(brush);
   CheckObjectBusy(brush);

   *count = brush->GetPresetBlendCount();

   return Ok;
}

GpStatus
WINGDIPAPI
GdipGetPathGradientPresetBlend(
    GpPathGradient *brush,
    ARGB *blend,
    REAL *blendPositions,
    INT count
    )
{
    API_ENTRY(GdipGetPathGradientPresetBlend);
    CheckParameter(blend);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    StackBuffer buffer;

    GpColor* gpcolors = (GpColor*) buffer.GetBuffer(count*sizeof(GpColor));

    if(!gpcolors) return OutOfMemory;

    if (gpcolors)
    {
        GpStatus status = brush->GetPresetBlend(gpcolors, blendPositions, count);

        for(INT i = 0; i < count; i++)
        {
            blend[i] = gpcolors[i].GetValue();
        }

        return status;
    }
    else
        return OutOfMemory;
}

GpStatus
WINGDIPAPI
GdipSetPathGradientPresetBlend(
    GpPathGradient *brush,
    GDIPCONST ARGB *blend,
    GDIPCONST REAL *blendPositions,
    INT count
    )
{
    API_ENTRY(GdipSetPathGradientPresetBlend);
    CheckParameter(blend);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    CheckParameter(count > 0);

    // blend positions must start at 0.0 and end at 1.0
    if (REALABS(blendPositions[0]) > REAL_EPSILON ||
        REALABS(1.0f - blendPositions[count-1]) > REAL_EPSILON)
    {
        return InvalidParameter;
    }

    StackBuffer buffer;

    GpColor* gpcolors = (GpColor*) buffer.GetBuffer(count*sizeof(GpColor));

    if(!gpcolors) return OutOfMemory;

    if(gpcolors)
    {
        for(INT i = 0; i < count; i++)
        {
            gpcolors[i].SetColor(blend[i]);
        }

        GpStatus status = brush->SetPresetBlend(gpcolors, blendPositions, count);

        return status;
    }
    else
        return OutOfMemory;
}

GpStatus
WINGDIPAPI
GdipSetPathGradientSigmaBlend(
    GpPathGradient *brush,
    REAL focus,
    REAL scale
    )
{
    API_ENTRY(GdipSetPathGradientSigmaBlend);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    return brush->SetSigmaBlend(focus, scale);
}

GpStatus
WINGDIPAPI
GdipSetPathGradientLinearBlend(
    GpPathGradient *brush,
    REAL focus,
    REAL scale
    )
{
    API_ENTRY(GdipSetPathGradientLinearBlend);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    return brush->SetLinearBlend(focus, scale);
}

GpStatus
WINGDIPAPI
GdipGetPathGradientWrapMode(
    GpPathGradient *brush,
    GpWrapMode *wrapmode
    )
{
    API_ENTRY(GdipGetPathGradientWrapMode);
    CheckParameter(wrapmode);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    *wrapmode = (GpWrapMode)brush->GetWrapMode();

    return Ok;
}

GpStatus
WINGDIPAPI
GdipSetPathGradientWrapMode(
    GpPathGradient *brush,
    GpWrapMode wrapmode
    )
{
    API_ENTRY(GdipSetPathGradientWrapMode);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    brush->SetWrapMode(wrapmode);

    return Ok;
}

GpStatus
WINGDIPAPI
GdipGetPathGradientTransform(
    GpPathGradient *brush,
    GpMatrix *matrix
    )
{
    API_ENTRY(GdipGetPathGradientTransform);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);
    CheckParameterValid(matrix);
    CheckObjectBusy(matrix);

    return brush->GetTransform(matrix);
}

GpStatus
WINGDIPAPI
GdipSetPathGradientTransform(
    GpPathGradient *brush,
    GpMatrix *matrix
    )
{
    API_ENTRY(GdipSetPathGradientTransform);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);
    CheckParameterValid(matrix);
    CheckObjectBusy(matrix);

    return brush->SetTransform(*matrix);
}

GpStatus
WINGDIPAPI
GdipResetPathGradientTransform(
    GpPathGradient* brush)
{
    API_ENTRY(GdipResetPathGradientTransform);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    return brush->ResetTransform();
}

GpStatus
WINGDIPAPI
GdipMultiplyPathGradientTransform(
    GpPathGradient* brush,
    GDIPCONST GpMatrix *matrix,
    GpMatrixOrder order)
{
    API_ENTRY(GdipMultiplyPathGradientTransform);
    if(matrix == NULL)
        return Ok;

    CheckParameterValid(brush);
    CheckObjectBusy(brush);
    CheckParameterValid(matrix);
    CheckObjectBusy(matrix);

    return brush->MultiplyTransform(*matrix, order);
}

GpStatus
WINGDIPAPI
GdipTranslatePathGradientTransform(
    GpPathGradient* brush,
    REAL dx,
    REAL dy,
    GpMatrixOrder order
    )
{
    API_ENTRY(GdipTranslatePathGradientTransform);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);
    CheckParameter(MatrixOrderIsValid(order));

    return brush->TranslateTransform(dx, dy, order);
}

GpStatus
WINGDIPAPI
GdipScalePathGradientTransform(
    GpPathGradient* brush,
    REAL sx,
    REAL sy,
    GpMatrixOrder order
    )
{
    API_ENTRY(GdipScalePathGradientTransform);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);
    CheckParameter(MatrixOrderIsValid(order));

    return brush->ScaleTransform(sx, sy, order);
}

GpStatus
WINGDIPAPI
GdipRotatePathGradientTransform(
    GpPathGradient* brush,
    REAL angle,
    GpMatrixOrder order
    )
{
    API_ENTRY(GdipRotatePathGradientTransform);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);
    CheckParameter(MatrixOrderIsValid(order));

    return brush->RotateTransform(angle, order);
}

GpStatus
WINGDIPAPI
GdipGetPathGradientFocusScales(
    GpPathGradient *brush,
    REAL* xScale,
    REAL* yScale
    )
{
    API_ENTRY(GdipGetPathGradientFocusScales);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);
    CheckParameter(xScale);
    CheckParameter(yScale);

    return brush->GetFocusScales(xScale, yScale);
}

GpStatus
WINGDIPAPI
GdipSetPathGradientFocusScales(
    GpPathGradient *brush,
    REAL xScale,
    REAL yScale
    )
{
    API_ENTRY(GdipSetPathGradientFocusScales);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    return brush->SetFocusScales(xScale, yScale);
}

GpStatus
WINGDIPAPI
GdipCreatePen1(
    ARGB color,
    REAL width,
    GpUnit unit,
    GpPen ** outPen
    )
{
    API_ENTRY(GdipCreatePen1);
    CheckGdiplusInitialized; // We do this in all our object creation API's

    CheckColorParameter(color);
    CheckParameter(outPen);

    // UnitDisplay is NOT valid; its only use is for Page Transforms
    CheckParameter((unit >= UnitWorld) && (unit <= UnitMillimeter) && (unit != UnitDisplay));

    GpPen * pen;

    pen = (GpPen *) InterlockedExchangePointer((PVOID *) &Globals::PenLookAside, NULL);

    if(pen == NULL)
    {
        pen = new GpPen(GpColor(color), width, unit);
    }
    else
    {
        pen->GetObjectLock()->Reset();
        pen->Set(GpColor(color), width, unit);
    }

    if (CheckValid(pen))
    {
        *outPen = pen;
        return Ok;
    }
    else
        return OutOfMemory;
}

GpStatus
WINGDIPAPI
GdipCreatePen2(
    GpBrush *brush,
    REAL width,
    GpUnit unit,
    GpPen **pen
    )
{
    API_ENTRY(GdipCreatePen2);
    CheckGdiplusInitialized; // We do this in all our object creation API's

    CheckParameter(pen);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    // UnitDisplay is NOT valid; its only use is for Page Transforms
    CheckParameter(
        (unit >= UnitWorld) &&
        (unit <= UnitMillimeter) &&
        (unit != UnitDisplay)
    );

    *pen = new GpPen(brush, width, unit);

    if (CheckValid(*pen))
        return Ok;
    else
        return OutOfMemory;
}

GpStatus
WINGDIPAPI
GdipClonePen(
    GpPen *pen,
    GpPen **clonepen
    )
{
    API_ENTRY(GdipClonePen);
    CheckParameter(clonepen);
    CheckParameterValid(pen);
    CheckObjectBusy(pen);

    *clonepen = pen->Clone();

    if (CheckValid(*clonepen))
        return Ok;
    else
        return OutOfMemory;
}

GpStatus
WINGDIPAPI
GdipDeletePen(
    GpPen *pen
    )
{
    API_ENTRY(GdipDeletePen);
    // NOTE: Do NOT call CheckParameterValid(), because we need to free
    // the object, even if it's not in a valid state.
    CheckParameter(pen);
    CheckObjectBusyForDelete(pen);

    // !!! [asecchia] only use the pen lookaside for solid pens.
    // it turns out that if we use pens containing TextureBrushes, we require
    // the stream to remain valid for the lifetime of the pen object in the
    // lookaside.

    if(pen->IsSolid())
    {
        pen = (GpPen *) InterlockedExchangePointer((PVOID *) &Globals::PenLookAside, pen);
    }

    if(pen != NULL)
    {
        delete pen;
    }

    return Ok;
}

GpStatus
WINGDIPAPI
GdipSetPenWidth(
    GpPen *pen,
    REAL width
    )
{
    API_ENTRY(GdipSetPenWidth);
   CheckParameterValid(pen);
   CheckObjectBusy(pen);

   pen->SetWidth(width);

   return Ok;
}

GpStatus
WINGDIPAPI
GdipGetPenWidth(
    GpPen *pen,
    REAL *width
    )
{
    API_ENTRY(GdipGetPenWidth);
   CheckParameter(width);
   CheckParameterValid(pen);
   CheckObjectBusy(pen);

   *width = pen->GetWidth();

   return Ok;
}

GpStatus
WINGDIPAPI
GdipSetPenUnit(
    GpPen *pen,
    GpUnit unit
    )
{
    API_ENTRY(GdipSetPenUnit);
    CheckParameterValid(pen);
    CheckObjectBusy(pen);

    // UnitDisplay is NOT valid; its only use is for Page Transforms
    CheckParameter((unit >= UnitWorld) && (unit <= UnitMillimeter) && (unit != UnitDisplay));

    pen->SetUnit(unit);

    return Ok;
}

GpStatus
WINGDIPAPI
GdipGetPenUnit(
    GpPen *pen,
    GpUnit* unit
    )
{
    API_ENTRY(GdipGetPenUnit);
   CheckParameter(unit);
   CheckParameterValid(pen);
   CheckObjectBusy(pen);

   *unit = pen->GetUnit();

   return Ok;
}

GpStatus
WINGDIPAPI
GdipSetPenLineCap197819(
    GpPen *pen,
    GpLineCap startCap,
    GpLineCap endCap,
    GpDashCap dashCap
    )
{
    API_ENTRY(GdipSetPenLineCap197819);
    CheckParameterValid(pen);
    CheckObjectBusy(pen);

    pen->SetLineCap(startCap, endCap, dashCap);

    return Ok;
}

GpStatus
WINGDIPAPI
GdipSetPenStartCap(
    GpPen *pen,
    GpLineCap startCap
    )
{
    API_ENTRY(GdipSetPenStartCap);
   CheckParameterValid(pen);
   CheckObjectBusy(pen);

   pen->SetStartCap(startCap);

   return Ok;
}

GpStatus
WINGDIPAPI
GdipSetPenEndCap(
    GpPen *pen,
    GpLineCap endCap
    )
{
    API_ENTRY(GdipSetPenEndCap);
   CheckParameterValid(pen);
   CheckObjectBusy(pen);

   pen->SetEndCap(endCap);

   return Ok;
}

GpStatus
WINGDIPAPI
GdipSetPenDashCap197819(
    GpPen *pen,
    GpDashCap dashCap
    )
{
    API_ENTRY(GdipSetPenDashCap197819);
   CheckParameterValid(pen);
   CheckObjectBusy(pen);

   pen->SetDashCap(dashCap);

   return Ok;
}

GpStatus
WINGDIPAPI
GdipGetPenStartCap(
    GpPen *pen,
    GpLineCap *startCap
    )
{
    API_ENTRY(GdipGetPenStartCap);
   CheckParameter(startCap);
   CheckParameterValid(pen);
   CheckObjectBusy(pen);

   *startCap = pen->GetStartCap();

   return Ok;
}

GpStatus
WINGDIPAPI
GdipGetPenEndCap(
    GpPen *pen,
    GpLineCap *endCap
    )
{
    API_ENTRY(GdipGetPenEndCap);
   CheckParameter(endCap);
   CheckParameterValid(pen);
   CheckObjectBusy(pen);

   *endCap = pen->GetEndCap();

   return Ok;
}

GpStatus
WINGDIPAPI
GdipGetPenDashCap197819(
    GpPen *pen,
    GpDashCap *dashCap
    )
{
   API_ENTRY(GdipGetPenDashCap197819);
   CheckParameter(dashCap);
   CheckParameterValid(pen);
   CheckObjectBusy(pen);

   *dashCap = pen->GetDashCap();

   return Ok;
}

GpStatus
WINGDIPAPI
GdipSetPenLineJoin(
    GpPen *pen,
    GpLineJoin lineJoin
    )
{
    API_ENTRY(GdipSetPenLineJoin);
   CheckParameterValid(pen);
   CheckObjectBusy(pen);

   pen->SetLineJoin(lineJoin);

   return Ok;
}

GpStatus
WINGDIPAPI
GdipGetPenLineJoin(
    GpPen *pen,
    GpLineJoin *lineJoin
    )
{
    API_ENTRY(GdipGetPenLineJoin);
   CheckParameter(lineJoin);
   CheckParameterValid(pen);
   CheckObjectBusy(pen);

   *lineJoin = pen->GetLineJoin();

   return Ok;
}

GpStatus
WINGDIPAPI
GdipSetPenCustomStartCap(
    GpPen *pen,
    GpCustomLineCap* customCap
    )
{
    API_ENTRY(GdipSetPenCustomStartCap);
   CheckParameterValid(customCap);
   CheckObjectBusy(customCap);
   CheckParameterValid(pen);
   CheckObjectBusy(pen);

   return pen->SetCustomStartCap(customCap);
}

GpStatus
WINGDIPAPI
GdipGetPenCustomStartCap(
    GpPen *pen,
    GpCustomLineCap** customCap
    )
{
    API_ENTRY(GdipGetPenCustomStartCap);
   CheckParameter(customCap);
   CheckParameterValid(pen);
   CheckObjectBusy(pen);

   return pen->GetCustomStartCap(customCap);
}

GpStatus
WINGDIPAPI
GdipSetPenCustomEndCap(
    GpPen *pen,
    GpCustomLineCap* customCap
    )
{
    API_ENTRY(GdipSetPenCustomEndCap);
   CheckParameterValid(customCap);
   CheckObjectBusy(customCap);
   CheckParameterValid(pen);
   CheckObjectBusy(pen);

   return pen->SetCustomEndCap(customCap);
}

GpStatus
WINGDIPAPI
GdipGetPenCustomEndCap(
    GpPen *pen,
    GpCustomLineCap** customCap
    )
{
    API_ENTRY(GdipGetPenCustomEndCap);
   CheckParameter(customCap);
   CheckParameterValid(pen);
   CheckObjectBusy(pen);

   return pen->GetCustomEndCap(customCap);
}

GpStatus
WINGDIPAPI
GdipSetPenMiterLimit(
    GpPen *pen,
    REAL miterLimit
    )
{
    API_ENTRY(GdipSetPenMiterLimit);
   CheckParameterValid(pen);
   CheckObjectBusy(pen);

   pen->SetMiterLimit(miterLimit);

   return Ok;
}

GpStatus
WINGDIPAPI
GdipGetPenMiterLimit(
    GpPen *pen,
    REAL *miterLimit
    )
{
    API_ENTRY(GdipGetPenMiterLimit);
   CheckParameter(miterLimit);
   CheckParameterValid(pen);
   CheckObjectBusy(pen);

   *miterLimit = pen->GetMiterLimit();

   return Ok;
}

GpStatus
WINGDIPAPI
GdipSetPenMode(
    GpPen *pen,
    GpPenAlignment penMode
    )
{
    API_ENTRY(GdipSetPenMode);
    CheckParameterValid(pen);
    CheckObjectBusy(pen);

    return pen->SetPenAlignment(penMode);
}

GpStatus
WINGDIPAPI
GdipGetPenMode(
    GpPen *pen,
    GpPenAlignment *penMode
    )
{
    API_ENTRY(GdipGetPenMode);
   CheckParameter(penMode);
   CheckParameterValid(pen);
   CheckObjectBusy(pen);

   *penMode = pen->GetPenAlignment();

   return Ok;
}


GpStatus
WINGDIPAPI
GdipSetPenTransform(
    GpPen *pen,
    GpMatrix *matrix
    )
{
    API_ENTRY(GdipSetPenTransform);
    CheckParameterValid(pen);
    CheckObjectBusy(pen);
    CheckParameterValid(matrix);
    CheckObjectBusy(matrix);
    
    return pen->SetTransform(*matrix);
}

GpStatus
WINGDIPAPI
GdipGetPenTransform(
    GpPen *pen,
    GpMatrix *matrix
    )
{
    API_ENTRY(GdipGetPenTransform);
    CheckParameterValid(pen);
    CheckObjectBusy(pen);
    CheckParameterValid(matrix);
    CheckObjectBusy(matrix);

    return pen->GetTransform(matrix);
}

GpStatus
WINGDIPAPI
GdipResetPenTransform(
    GpPen *pen)
{
    API_ENTRY(GdipResetPenTransform);
    CheckParameterValid(pen);
    CheckObjectBusy(pen);

    return pen->ResetTransform();
}

GpStatus
WINGDIPAPI
GdipMultiplyPenTransform(
    GpPen *pen,
    GDIPCONST GpMatrix *matrix,
    GpMatrixOrder order)
{
    API_ENTRY(GdipMultiplyPenTransform);
    if(matrix == NULL)
        return Ok;

    CheckParameterValid(pen);
    CheckObjectBusy(pen);
    CheckParameterValid(matrix);
    CheckObjectBusy(matrix);

    return pen->MultiplyTransform(*matrix, order);
}

GpStatus
WINGDIPAPI
GdipTranslatePenTransform(
    GpPen* pen,
    REAL dx,
    REAL dy,
    GpMatrixOrder order
    )
{
    API_ENTRY(GdipTranslatePenTransform);
    CheckParameterValid(pen);
    CheckObjectBusy(pen);
    CheckParameter(MatrixOrderIsValid(order));

    return pen->TranslateTransform(dx, dy, order);
}

GpStatus
WINGDIPAPI
GdipScalePenTransform(
    GpPen* pen,
    REAL sx,
    REAL sy,
    GpMatrixOrder order
    )
{
    API_ENTRY(GdipScalePenTransform);
    CheckParameterValid(pen);
    CheckObjectBusy(pen);
    CheckParameter(MatrixOrderIsValid(order));

    return pen->ScaleTransform(sx, sy, order);
}

GpStatus
WINGDIPAPI
GdipRotatePenTransform(
    GpPen* pen,
    REAL angle,
    GpMatrixOrder order
    )
{
    API_ENTRY(GdipRotatePenTransform);
    CheckParameterValid(pen);
    CheckObjectBusy(pen);
    CheckParameter(MatrixOrderIsValid(order));

    return pen->RotateTransform(angle, order);
}

GpStatus
WINGDIPAPI
GdipSetPenColor(
    GpPen *pen,
    ARGB argb
    )
{
    API_ENTRY(GdipSetPenColor);
    CheckColorParameter(argb);
    CheckParameterValid(pen);
    CheckObjectBusy(pen);

    GpColor color(argb);

    return pen->SetColor(&color);
}

GpStatus
WINGDIPAPI
GdipGetPenColor(
    GpPen *pen,
    ARGB *argb
    )
{
    API_ENTRY(GdipGetPenColor);
   CheckParameter(argb);
   CheckParameterValid(pen);
   CheckObjectBusy(pen);

   ARGB temp;
   Status status = pen->GetColor(&temp);
   *argb = temp;

   return status;
}

GpStatus
WINGDIPAPI
GdipSetPenBrushFill(
    GpPen *pen,
    GpBrush *brush
    )
{
    API_ENTRY(GdipSetPenBrushFill);
   CheckParameterValid(pen);
   CheckObjectBusy(pen);
   CheckParameterValid(brush);
   CheckObjectBusy(brush);

   return pen->SetBrush(brush);
}

GpStatus
WINGDIPAPI
GdipGetPenBrushFill(
    GpPen *pen,
    GpBrush **brush
    )
{
    API_ENTRY(GdipGetPenBrushFill);
   CheckParameterValid(pen);
   CheckObjectBusy(pen);
   CheckParameter(brush);

   *brush = pen->GetClonedBrush();

   return Ok;
}

GpStatus
WINGDIPAPI
GdipGetPenFillType(
    GpPen *pen,
    GpPenType* type
    )
{
    API_ENTRY(GdipGetPenFillType);
   CheckParameterValid(pen);
   CheckObjectBusy(pen);
   CheckParameter(type);

   *type = pen->GetPenType();

   return Ok;
}

GpStatus
WINGDIPAPI
GdipGetPenDashStyle(
    GpPen *pen,
    GpDashStyle *dashstyle
    )
{
    API_ENTRY(GdipGetPenDashStyle);
   CheckParameter(dashstyle);
   CheckParameterValid(pen);
   CheckObjectBusy(pen);

   *dashstyle = (GpDashStyle)pen->GetDashStyle();

   return Ok;
}

GpStatus
WINGDIPAPI
GdipSetPenDashStyle(
    GpPen *pen,
    GpDashStyle dashstyle
    )
{
    API_ENTRY(GdipSetPenDashStyle);
   CheckParameterValid(pen);
   CheckObjectBusy(pen);

   pen->SetDashStyle(dashstyle);

   return Ok;
}

GpStatus
WINGDIPAPI
GdipGetPenDashOffset(
    GpPen *pen,
    REAL *offset
    )
{
    API_ENTRY(GdipGetPenDashOffset);
    CheckParameter(offset);
    CheckParameterValid(pen);
    CheckObjectBusy(pen);

    *offset = pen->GetDashOffset();

    return Ok;
}

GpStatus
WINGDIPAPI
GdipSetPenDashOffset(
    GpPen *pen,
    REAL offset
    )
{
    API_ENTRY(GdipSetPenDashOffset);
    CheckParameterValid(pen);
    CheckObjectBusy(pen);

    pen->SetDashOffset(offset);

    return Ok;
}

GpStatus
WINGDIPAPI
GdipGetPenDashCount(
    GpPen *pen,
    INT *count
    )
{
    API_ENTRY(GdipGetPenDashCount);
    CheckParameter(count);
    CheckParameterValid(pen);
    CheckObjectBusy(pen);

    *count = pen->GetDashCount();

    return Ok;
}

GpStatus
WINGDIPAPI
GdipSetPenDashArray(
    GpPen *pen,
    GDIPCONST REAL *dash,
    INT count
    )
{
    API_ENTRY(GdipSetPenDashArray);
    CheckParameter(dash);
    CheckParameterValid(pen);
    CheckObjectBusy(pen);

    return pen->SetDashArray(dash, count);
}

GpStatus
WINGDIPAPI
GdipGetPenDashArray(
    GpPen *pen,
    REAL *dash,
    INT count
    )
{
    API_ENTRY(GdipGetPenDashArray);
    CheckParameter(dash);
    CheckParameterValid(pen);
    CheckObjectBusy(pen);

    return pen->GetDashArray(dash, count);
}


GpStatus
WINGDIPAPI
GdipGetPenCompoundCount(
    GpPen *pen,
    INT *count
    )
{
    API_ENTRY(GdipGetPenCompoundCount);
    CheckParameter(count);
    CheckParameterValid(pen);
    CheckObjectBusy(pen);

    *count = pen->GetCompoundCount();

    return Ok;
}

GpStatus
WINGDIPAPI
GdipSetPenCompoundArray(
    GpPen *pen,
    GDIPCONST REAL *compoundArray,
    INT count
    )
{
    API_ENTRY(GdipSetPenCompoundArray);
    CheckParameter(compoundArray);
    CheckParameterValid(pen);
    CheckObjectBusy(pen);

    return pen->SetCompoundArray(compoundArray, count);
}

GpStatus
WINGDIPAPI
GdipGetPenCompoundArray(
    GpPen *pen,
    REAL *compoundArray,
    INT count
    )
{
    API_ENTRY(GdipGetPenCompoundArray);
    CheckParameter(compoundArray);
    CheckParameterValid(pen);
    CheckObjectBusy(pen);

    return pen->GetCompoundArray(compoundArray, count);
}

GpStatus
WINGDIPAPI
GdipCreateCustomLineCap(
    GpPath* fillPath,
    GpPath* strokePath,
    GpLineCap baseCap,
    REAL baseInset,
    GpCustomLineCap **customCap
    )
{
    API_ENTRY(GdipCreateCustomLineCap);
    CheckGdiplusInitialized; // We do this in all our object creation API's

    // fillPath or strokePath can be NULL.

    CheckParameter(customCap);
    CheckParameter((fillPath != NULL) || (strokePath != NULL));
    CheckOptionalParameterValid(fillPath);
    CheckOptionalObjectBusy(fillPath);
    CheckOptionalParameterValid(strokePath);
    CheckOptionalObjectBusy(strokePath);

    *customCap = new GpCustomLineCap(fillPath, strokePath, baseCap, baseInset);

    if (*customCap)
    {
        if((*customCap)->IsValid())
        {
            return Ok;
        }
        
        // This failed to create correctly. Retrieve the failure code.
        
        GpStatus status = (*customCap)->GetCreationStatus();
        delete *customCap;
        *customCap = NULL;
        return status;
    }
    else
    {
        return OutOfMemory;
    }
}

GpStatus
WINGDIPAPI
GdipCloneCustomLineCap(
    GpCustomLineCap *customCap,
    GpCustomLineCap **newCustomCap
    )
{
    API_ENTRY(GdipCloneCustomLineCap);
   CheckParameterValid(customCap);
   CheckObjectBusy(customCap);

   *newCustomCap = customCap->Clone();

    if (*newCustomCap)
    {
        if((*newCustomCap)->IsValid())
        {
            return Ok;
        }
        
        // This failed to create correctly. Retrieve the failure code.
        
        GpStatus status = (*newCustomCap)->GetCreationStatus();
        delete *newCustomCap;
        *newCustomCap = NULL;
        return status;
    }
    else
    {
        return OutOfMemory;
    }
}


GpStatus
WINGDIPAPI
GdipGetCustomLineCapType(
    GpCustomLineCap* customCap,
    CustomLineCapType* type
    )
{
    API_ENTRY(GdipGetCustomLineCapType);
   CheckParameter(type);
   CheckParameterValid(customCap);
   CheckObjectBusy(customCap);

   *type = customCap->GetType();

   return Ok;
}

GpStatus
WINGDIPAPI
GdipDeleteCustomLineCap(
    GpCustomLineCap* customCap
    )
{
    API_ENTRY(GdipDeleteCustomLineCap);
    // NOTE: Do NOT call CheckParameterValid(), because we need to free
    // the object, even if it's not in a valid state.
    CheckParameter(customCap);
    CheckObjectBusyForDelete(customCap);

    delete customCap;

    return Ok;
}

GpStatus
WINGDIPAPI
GdipSetCustomLineCapStrokeCaps(
    GpCustomLineCap* customCap,
    GpLineCap startCap,
    GpLineCap endCap)
{
    API_ENTRY(GdipSetCustomLineCapStrokeCaps);
    CheckParameterValid(customCap);
    CheckObjectBusy(customCap);

    return customCap->SetStrokeCaps(startCap, endCap);
}

GpStatus
WINGDIPAPI
GdipGetCustomLineCapStrokeCaps(
    GpCustomLineCap* customCap,
    GpLineCap* startCap,
    GpLineCap* endCap
    )
{
    API_ENTRY(GdipGetCustomLineCapStrokeCaps);
    CheckParameterValid(customCap);
    CheckObjectBusy(customCap);
    CheckParameter(startCap);
    CheckParameter(endCap);

    return customCap->GetStrokeCaps(startCap, endCap);
}

GpStatus
WINGDIPAPI
GdipSetCustomLineCapStrokeJoin(
    GpCustomLineCap* customCap,
    GpLineJoin lineJoin
    )
{
    API_ENTRY(GdipSetCustomLineCapStrokeJoin);
    CheckParameterValid(customCap);
    CheckObjectBusy(customCap);

    return customCap->SetStrokeJoin(lineJoin);
}

GpStatus
WINGDIPAPI
GdipGetCustomLineCapStrokeJoin(
    GpCustomLineCap* customCap,
    GpLineJoin* lineJoin
    )
{
    API_ENTRY(GdipGetCustomLineCapStrokeJoin);
    CheckParameterValid(customCap);
    CheckObjectBusy(customCap);
    CheckParameter(lineJoin);

    return customCap->GetStrokeJoin(lineJoin);
}

GpStatus
WINGDIPAPI
GdipSetCustomLineCapBaseCap(
    GpCustomLineCap* customCap,
    GpLineCap baseCap
    )
{
    API_ENTRY(GdipSetCustomLineCapBaseCap);
    CheckParameterValid(customCap);
    CheckObjectBusy(customCap);

    return customCap->SetBaseCap(baseCap);
}

GpStatus
WINGDIPAPI
GdipGetCustomLineCapBaseCap(
    GpCustomLineCap* customCap,
    GpLineCap* baseCap
    )
{
    API_ENTRY(GdipGetCustomLineCapBaseCap);
    CheckParameterValid(customCap);
    CheckObjectBusy(customCap);
    CheckParameter(baseCap);

    return customCap->GetBaseCap(baseCap);
}

GpStatus
WINGDIPAPI
GdipSetCustomLineCapBaseInset(
    GpCustomLineCap* customCap,
    REAL inset
    )
{
    API_ENTRY(GdipSetCustomLineCapBaseInset);
    CheckParameterValid(customCap);
    CheckObjectBusy(customCap);

    return customCap->SetBaseInset(inset);
}

GpStatus
WINGDIPAPI
GdipGetCustomLineCapBaseInset(
    GpCustomLineCap* customCap,
    REAL* inset
    )
{
    API_ENTRY(GdipGetCustomLineCapBaseInset);
    CheckParameterValid(customCap);
    CheckObjectBusy(customCap);
    CheckParameter(inset);

    return customCap->GetBaseInset(inset);
}

GpStatus
WINGDIPAPI
GdipSetCustomLineCapWidthScale(
    GpCustomLineCap* customCap,
    REAL widthScale
    )
{
    API_ENTRY(GdipSetCustomLineCapWidthScale);
    CheckParameterValid(customCap);
    CheckObjectBusy(customCap);

    return customCap->SetWidthScale(widthScale);
}

GpStatus WINGDIPAPI
GdipGetCustomLineCapWidthScale(
    GpCustomLineCap* customCap,
    REAL* widthScale
    )
{
    API_ENTRY(GdipGetCustomLineCapWidthScale);
    CheckParameterValid(customCap);
    CheckObjectBusy(customCap);
    CheckParameter(widthScale);

    return customCap->GetWidthScale(widthScale);
}

GpStatus
WINGDIPAPI
GdipCreateAdjustableArrowCap(
    REAL height,
    REAL width,
    BOOL isFilled,
    GpAdjustableArrowCap **cap)
{
    API_ENTRY(GdipCreateAdjustableArrowCap);
    CheckGdiplusInitialized; // We do this in all our object creation API's

    CheckParameter(cap);

    *cap = new GpAdjustableArrowCap(height, width, isFilled);

    if(*cap)
        return Ok;
    else
        return OutOfMemory;
}

GpStatus
WINGDIPAPI
GdipSetAdjustableArrowCapHeight(
    GpAdjustableArrowCap* cap,
    REAL height
    )
{
    API_ENTRY(GdipSetAdjustableArrowCapHeight);
    CheckParameterValid(cap);
    CheckObjectBusy(cap);

    return cap->SetHeight(height);
}

GpStatus
WINGDIPAPI
GdipGetAdjustableArrowCapHeight(
    GpAdjustableArrowCap* cap,
    REAL* height
    )
{
    API_ENTRY(GdipGetAdjustableArrowCapHeight);
    CheckParameterValid(cap);
    CheckObjectBusy(cap);
    CheckParameter(height);

    *height = cap->GetHeight();

    return Ok;
}

GpStatus
WINGDIPAPI
GdipSetAdjustableArrowCapWidth(
    GpAdjustableArrowCap* cap,
    REAL width
    )
{
    API_ENTRY(GdipSetAdjustableArrowCapWidth);
    CheckParameterValid(cap);
    CheckObjectBusy(cap);

    return cap->SetWidth(width);
}

GpStatus
WINGDIPAPI
GdipGetAdjustableArrowCapWidth(
    GpAdjustableArrowCap* cap,
    REAL* width
    )
{
    API_ENTRY(GdipGetAdjustableArrowCapWidth);
    CheckParameterValid(cap);
    CheckObjectBusy(cap);
    CheckParameter(width);

    *width = cap->GetWidth();

    return Ok;
}

GpStatus
WINGDIPAPI
GdipSetAdjustableArrowCapMiddleInset(
    GpAdjustableArrowCap* cap,
    REAL middleInset
    )
{
    API_ENTRY(GdipSetAdjustableArrowCapMiddleInset);
    CheckParameterValid(cap);
    CheckObjectBusy(cap);

    return cap->SetMiddleInset(middleInset);
}

GpStatus
WINGDIPAPI
GdipGetAdjustableArrowCapMiddleInset(
    GpAdjustableArrowCap* cap,
    REAL* middleInset
    )
{
    API_ENTRY(GdipGetAdjustableArrowCapMiddleInset);
    CheckParameterValid(cap);
    CheckObjectBusy(cap);
    CheckParameter(middleInset);

    *middleInset = cap->GetMiddleInset();

    return Ok;
}

GpStatus
WINGDIPAPI
GdipSetAdjustableArrowCapFillState(
    GpAdjustableArrowCap* cap,
    BOOL fillState
    )
{
    API_ENTRY(GdipSetAdjustableArrowCapFillState);
    CheckParameterValid(cap);
    CheckObjectBusy(cap);

    return cap->SetFillState(fillState);
}

GpStatus
WINGDIPAPI
GdipGetAdjustableArrowCapFillState(
    GpAdjustableArrowCap* cap,
    BOOL* fillState
    )
{
    API_ENTRY(GdipGetAdjustableArrowCapFillState);
    CheckParameterValid(cap);
    CheckObjectBusy(cap);
    CheckParameter(fillState);

    *fillState = cap->IsFilled();

    return Ok;
}

GpStatus
WINGDIPAPI
GdipLoadImageFromStream(
    IStream* stream,
    GpImage **image
    )
{
    API_ENTRY(GdipLoadImageFromStream);
    CheckParameter(image && stream);


    *image = GpImage::LoadImage(stream);

    // !!! Can't use CheckValid() since destructor is protected.

    if (*image)
    {
        if ((*image)->IsValid())
        {
            (*image)->SetICMConvert(FALSE);
            return Ok;
        }
        (*image)->Dispose();
        *image = NULL;
        return InvalidParameter;
    }
    return OutOfMemory;
}

GpStatus
WINGDIPAPI
GdipLoadImageFromFile(
    GDIPCONST WCHAR* filename,
    GpImage** image
    )
{
    API_ENTRY(GdipLoadImageFromFile);
    CheckParameter(image && filename);


    *image = GpImage::LoadImage(filename);

    if (*image)
    {
        if ((*image)->IsValid())
        {
            (*image)->SetICMConvert(FALSE);
            return Ok;
        }
        (*image)->Dispose();
        *image = NULL;
        return InvalidParameter;
    }
    return OutOfMemory;
}

GpStatus
WINGDIPAPI
GdipLoadImageFromStreamICM(
    IStream* stream,
    GpImage **image
    )
{
    API_ENTRY(GdipLoadImageFromStreamICM);
    CheckParameter(image && stream);


    *image = GpImage::LoadImage(stream);

    // !!! Can't use CheckValid() since destructor is protected.

    if (*image)
    {
        if ((*image)->IsValid())
        {
            (*image)->SetICMConvert(TRUE);
            return Ok;
        }
        (*image)->Dispose();
        *image = NULL;
        return InvalidParameter;
    }
    return OutOfMemory;
}

GpStatus
WINGDIPAPI
GdipLoadImageFromFileICM(
    GDIPCONST WCHAR* filename,
    GpImage** image
    )
{
    API_ENTRY(GdipLoadImageFromFileICM);
    CheckParameter(image && filename);


    *image = GpImage::LoadImage(filename);

    if (*image)
    {
        if ((*image)->IsValid())
        {
            (*image)->SetICMConvert(TRUE);
            return Ok;
        }
        (*image)->Dispose();
        *image = NULL;
        return InvalidParameter;
    }
    return OutOfMemory;
}


GpStatus
WINGDIPAPI
GdipGetEncoderParameterListSize(
    GpImage         *image,
    GDIPCONST CLSID *clsidEncoder,
    UINT            *size
    )
{
    API_ENTRY(GdipGetEncoderParameterListSize);
    CheckParameter(image && clsidEncoder);
    CheckObjectBusy(image);

    return image->GetEncoderParameterListSize(const_cast<CLSID*>(clsidEncoder), size);
}

GpStatus
WINGDIPAPI
GdipGetEncoderParameterList(
    GpImage           *image,
    GDIPCONST CLSID   *clsidEncoder,
    UINT               size,
    EncoderParameters *buffer
    )
{
    API_ENTRY(GdipGetEncoderParameterList);
    CheckParameter(image && clsidEncoder);
    CheckObjectBusy(image);

    return image->GetEncoderParameterList(const_cast<CLSID*>(clsidEncoder), size, buffer);
}

GpStatus
WINGDIPAPI
GdipSaveImageToStream(
    GpImage *image,
    IStream* stream,
    GDIPCONST CLSID* clsidEncoder,
    GDIPCONST EncoderParameters* encoderParams
    )
{
    API_ENTRY(GdipSaveImageToStream);
    CheckParameter(image && stream && clsidEncoder);
    CheckObjectBusy(image);

    return image->SaveToStream(stream,
                               const_cast<CLSID*>(clsidEncoder),
                               const_cast<EncoderParameters*>(encoderParams));
}

GpStatus
WINGDIPAPI
GdipSaveImageToFile(
    GpImage *image,
    GDIPCONST WCHAR* filename,
    GDIPCONST CLSID* clsidEncoder,
    GDIPCONST EncoderParameters* encoderParams
    )
{
    API_ENTRY(GdipSaveImageToFile);
    CheckParameter(image && filename && clsidEncoder);
    CheckObjectBusy(image);

    return image->SaveToFile(filename,
                             const_cast<CLSID*>(clsidEncoder),
                             const_cast<EncoderParameters*>(encoderParams));
}

GpStatus
WINGDIPAPI
GdipSaveAdd(
    GpImage *image,
    GDIPCONST EncoderParameters* encoderParams
    )
{
    API_ENTRY(GdipSaveAdd);
    CheckParameter(image && encoderParams);
    CheckObjectBusy(image);

    return image->SaveAdd(const_cast<EncoderParameters*>(encoderParams));
}

GpStatus
WINGDIPAPI
GdipSaveAddImage(
    GpImage*            image,
    GpImage*            newImage,
    GDIPCONST EncoderParameters*  encoderParams
    )
{
    API_ENTRY(GdipSaveAddImage);
    CheckParameter(image && newImage && encoderParams);
    CheckObjectBusy(image);

    return image->SaveAdd(newImage, const_cast<EncoderParameters*>(encoderParams));
}

GpStatus
WINGDIPAPI
GdipImageGetFrameDimensionsCount(
    GpImage*    image,
    UINT*       count
    )
{
    API_ENTRY(GdipImageGetFrameDimensionsCount);
    CheckParameter(image);
    CheckObjectBusy(image);
    return image->GetFrameDimensionsCount(count);
}

GpStatus
WINGDIPAPI
GdipImageGetFrameDimensionsList(
    GpImage*    image,
    GUID*       dimensionIDs,
    UINT        count
    )
{
    API_ENTRY(GdipImageGetFrameDimensionsList);
    CheckParameter(image);
    CheckObjectBusy(image);
    return image->GetFrameDimensionsList(dimensionIDs, count);
}

GpStatus
WINGDIPAPI
GdipImageGetFrameCount(
    GpImage*    image,
    GDIPCONST GUID* dimensionID,
    UINT*       count
    )
{
    API_ENTRY(GdipImageGetFrameCount);
    CheckParameter(image);
    CheckObjectBusy(image);
    return image->GetFrameCount(dimensionID, count);
}

GpStatus
WINGDIPAPI
GdipImageSelectActiveFrame(
    GpImage*    image,
    GDIPCONST GUID* dimensionID,
    UINT        frameIndex
    )
{
    API_ENTRY(GdipImageSelectActiveFrame);
    CheckParameter(image);
    CheckObjectBusy(image);
    return image->SelectActiveFrame(dimensionID, frameIndex);
}

GpStatus
WINGDIPAPI
GdipImageRotateFlip(
    GpImage*        image,
    RotateFlipType  rfType
    )
{
    API_ENTRY(GdipImageRotateFlip);
    CheckParameter(image);
    CheckObjectBusy(image);
    return image->RotateFlip(rfType);
}

GpStatus
WINGDIPAPI
GdipGetPropertyCount(
    GpImage*    image,
    UINT* numOfProperty
    )
{
    API_ENTRY(GdipGetPropertyCount);
    CheckParameter(image);
    CheckObjectBusy(image);
    return image->GetPropertyCount(numOfProperty);
}

GpStatus
WINGDIPAPI
GdipGetPropertyIdList(
    GpImage*    image,
    UINT        numOfProperty,
    PROPID*     list
    )
{
    API_ENTRY(GdipGetPropertyIdList);
    CheckParameter(image);
    CheckObjectBusy(image);
    return image->GetPropertyIdList(numOfProperty, list);
}

GpStatus
WINGDIPAPI
GdipGetPropertyItemSize(
    GpImage*    image,
    PROPID      propId,
    UINT*       size
    )
{
    API_ENTRY(GdipGetPropertyItemSize);
    CheckParameter(image);
    CheckObjectBusy(image);
    return image->GetPropertyItemSize(propId, size);
}

GpStatus
WINGDIPAPI
GdipGetPropertyItem(
    GpImage*        image,
    PROPID          propId,
    UINT            propSize,
    PropertyItem*   buffer
    )
{
    API_ENTRY(GdipGetPropertyItem);
    CheckParameter(image);
    CheckObjectBusy(image);
    return image->GetPropertyItem(propId, propSize, buffer);
}

GpStatus
WINGDIPAPI
GdipGetPropertySize(
    GpImage*    image,
    UINT*       totalBufferSize,
    UINT*       numProperties
    )
{
    API_ENTRY(GdipGetPropertySize);
    CheckParameter(image);
    CheckObjectBusy(image);
    return image->GetPropertySize(totalBufferSize, numProperties);
}

GpStatus
WINGDIPAPI
GdipGetAllPropertyItems(
    GpImage*    image,
    UINT        totalBufferSize,
    UINT        numProperties,
    PropertyItem* allItems
    )
{
    API_ENTRY(GdipGetAllPropertyItems);
    CheckParameter(image);
    CheckObjectBusy(image);
    return image->GetAllPropertyItems(totalBufferSize, numProperties, allItems);
}

GpStatus
WINGDIPAPI
GdipRemovePropertyItem(
    GpImage*    image,
    PROPID      propId
    )
{
    API_ENTRY(GdipRemovePropertyItem);
    CheckParameter(image);
    CheckObjectBusy(image);
    return image->RemovePropertyItem(propId);
}

GpStatus
WINGDIPAPI
GdipSetPropertyItem(
    GpImage*                   image,
    GDIPCONST PropertyItem*    item
    )
{
    API_ENTRY(GdipSetPropertyItem);
    CheckParameter(image && item);
    CheckObjectBusy(image);
    return image->SetPropertyItem(const_cast<PropertyItem*>(item));
}

GpStatus
WINGDIPAPI
GdipCloneImage(
    GpImage* image,
    GpImage** cloneimage
    )
{
    API_ENTRY(GdipCloneImage);
   CheckParameter(cloneimage);
   CheckParameterValid(image);
   CheckObjectBusy(image);

   *cloneimage = image->Clone();

   if (*cloneimage)
       return Ok;
   else
       return OutOfMemory;

   // !!!: There is no destructor to invoke.  Leave it to Clone to
   //       verify correct creation.
}

GpStatus
WINGDIPAPI
GdipDisposeImage(
    GpImage *image
    )
{
    API_ENTRY(GdipDisposeImage);
    // NOTE: Do NOT call CheckParameterValid(), because we need to free
    // the object, even if it's not in a valid state.
    CheckParameter(image);

    if (image->GetImageType() == ImageTypeMetafile)
    {
        // If the user still has the graphics associated with the metafile,
        // then we have to lock it, to prevent them from using it while
        // we're busy deleting the metafile object.  The metafile dispose
        // method will set the graphics to invalid, so the only thing
        // they can do with the graphics is to delete it after this call.

        GpMetafile *    metafile = (GpMetafile *)image;
        GpGraphics *    g = metafile->PrivateAPIForGettingMetafileGraphicsContext();
        CheckOptionalObjectBusy(g);
        CheckObjectBusyForDelete(metafile);
        metafile->Dispose();
        return Ok;
    }

    CheckObjectBusyForDelete(image);

    image->Dispose();

    return Ok;
}

GpStatus
WINGDIPAPI
GdipGetImageGraphicsContext(
    GpImage *image,
    GpGraphics **graphics
    )
{
    API_ENTRY(GdipGetImageGraphicsContext);
   CheckParameter(graphics);
   CheckParameterValid(image);
   CheckObjectBusy(image);

   *graphics = image->GetGraphicsContext();

   if (CheckValid(*graphics))
       return Ok;
   else
       return OutOfMemory;
}

GpStatus
WINGDIPAPI
GdipGetImageBounds(
    GpImage *image,
    GpRectF *srcRect,
    GpPageUnit *srcUnit
    )
{
    API_ENTRY(GdipGetImageBounds);
    CheckParameter(srcRect && srcUnit);
    CheckParameterValid(image);
    CheckObjectBusy(image);

    return image->GetBounds(srcRect, srcUnit);
}


GpStatus
WINGDIPAPI
GdipGetImageDimension(
    GpImage *image,
    REAL *width,
    REAL *height
    )
{
    API_ENTRY(GdipGetImageDimension);
    CheckParameter(width && height);
    CheckParameterValid(image);
    CheckObjectBusy(image);

    return image->GetPhysicalDimension(width, height);
}

GpStatus
WINGDIPAPI
GdipGetImageWidth(
    GpImage *image,
    UINT *width
    )
{
    API_ENTRY(GdipGetImageWidth);
    CheckParameter(width);
    CheckParameterValid(image);
    CheckObjectBusy(image);

    ImageInfo imageinfo;

    GpStatus status = image->GetImageInfo(&imageinfo);

    if (status == Ok)
    {
        *width = imageinfo.Width;
    }

    return status;
}

GpStatus
WINGDIPAPI
GdipGetImageHeight(
    GpImage *image,
    UINT *height
    )
{
    API_ENTRY(GdipGetImageHeight);
    CheckParameter(height);
    CheckParameterValid(image);
    CheckObjectBusy(image);

    ImageInfo imageinfo;

    GpStatus status = image->GetImageInfo(&imageinfo);

    if (status == Ok)
    {
        *height = imageinfo.Height;
    }

    return status;
}

GpStatus
WINGDIPAPI
GdipGetImageHorizontalResolution(
    GpImage *image,
    REAL *resolution
    )
{
    API_ENTRY(GdipGetImageHorizontalResolution);
    CheckParameter(resolution);
    CheckParameterValid(image);
    CheckObjectBusy(image);

    ImageInfo imageinfo;

    GpStatus status = image->GetImageInfo(&imageinfo);

    if (status == Ok)
    {
        *resolution = (REAL) imageinfo.Xdpi;
    }

    return status;
}

GpStatus
WINGDIPAPI
    GdipGetImageVerticalResolution(
    GpImage *image,
    REAL *resolution
    )
{
    API_ENTRY(GdipGetImageVerticalResolution);
    CheckParameter(resolution);
    CheckParameterValid(image);
    CheckObjectBusy(image);

    ImageInfo imageinfo;

    GpStatus status = image->GetImageInfo(&imageinfo);

    if (status == Ok)
    {
        *resolution = (REAL) imageinfo.Ydpi;
    }

    return status;
}

GpStatus
WINGDIPAPI
    GdipGetImageFlags(
    GpImage *image,
    UINT *flags
    )
{
    API_ENTRY(GdipGetImageFlags);
    CheckParameter(flags);
    CheckParameterValid(image);
    CheckObjectBusy(image);

    ImageInfo imageinfo;

    GpStatus status = image->GetImageInfo(&imageinfo);

    if (status == Ok)
    {
        *flags = imageinfo.Flags;
    }

    return status;
}

GpStatus
WINGDIPAPI
    GdipGetImageRawFormat(
    GpImage *image,
    GUID *format
    )
{
    API_ENTRY(GdipGetImageRawFormat);
    CheckParameter(format);
    CheckParameterValid(image);
    CheckObjectBusy(image);

    ImageInfo imageinfo;

    GpStatus status = image->GetImageInfo(&imageinfo);

    if (status == Ok)
    {
        *format = imageinfo.RawDataFormat;
    }

    return status;
}

GpStatus
WINGDIPAPI
    GdipGetImagePixelFormat(
    GpImage *image,
    PixelFormat *format
    )
{
    API_ENTRY(GdipGetImagePixelFormat);
    CheckParameter(format);
    CheckParameterValid(image);
    CheckObjectBusy(image);

    ImageInfo imageinfo;

    GpStatus status = image->GetImageInfo(&imageinfo);

    if (status == Ok)
    {
        //!!!need conversion to PixelFormat
        *format = (PixelFormat) MaskPixelFormat(imageinfo.PixelFormat);
    }

    return status;
}

GpStatus WINGDIPAPI
GdipGetImagePalette(GpImage *image, ColorPalette *palette, INT size)
{
    API_ENTRY(GdipGetImagePalette);
    CheckParameter(palette);
    CheckParameterValid(image);
    CheckObjectBusy(image);

    return image->GetPalette(palette, size);
}

GpStatus WINGDIPAPI
GdipSetImagePalette(GpImage *image, GDIPCONST ColorPalette *palette)
{
    API_ENTRY(GdipSetImagePalette);
    CheckParameter(palette);
    CheckParameterValid(image);
    CheckObjectBusy(image);

    return image->SetPalette(const_cast<ColorPalette*>(palette));
}

GpStatus WINGDIPAPI
GdipGetImagePaletteSize(GpImage *image, INT *size)
{
    API_ENTRY(GdipGetImagePaletteSize);

  CheckParameter(size);
  CheckParameterValid(image);
  CheckObjectBusy(image);

  *size = image->GetPaletteSize();

  // Note: image->GetPaletteSize() will return zero if and only if there is
  // something wrong in the whole pipeline, like a bad image, out of memory etc.

  if (*size == 0)
  {
      return GenericError;
  }
  else
  {
    return Ok;
  }
}




GpStatus
WINGDIPAPI
GdipGetImageType(
    GpImage* image,
    ImageType* type
    )
{
    API_ENTRY(GdipGetImageType);
    CheckParameter(type);
    CheckParameterValid(image);
    CheckObjectBusy(image);

    *type = (ImageType)image->GetImageType();

    return Ok;
}

GpStatus
WINGDIPAPI
GdipGetImageThumbnail(
    GpImage* image,
    UINT thumbWidth,
    UINT thumbHeight,
    GpImage** thumbImage,
    GetThumbnailImageAbort callback,
    VOID * callbackData
    )
{
    API_ENTRY(GdipGetImageThumbnail);
    CheckParameter(thumbImage);
    CheckParameterValid(image);
    CheckObjectBusy(image);

    *thumbImage = image->GetThumbnail(thumbWidth, thumbHeight, callback, callbackData);

    if (*thumbImage)
        return Ok;
    else
        return OutOfMemory;
}

GpStatus
WINGDIPAPI
GdipImageForceValidation(GpImage* image)
{
    API_ENTRY(GdipImageForceValidation);
    CheckParameterValid(image);
    CheckObjectBusy(image);

    // Metafiles don't need a force decode

    if (image->GetImageType() == ImageTypeBitmap)
        return (static_cast<GpBitmap*>(image))->ForceValidation();
    else
        return Ok;
}

GpStatus
WINGDIPAPI
GdipCreateBitmapFromStream(
    IStream* stream,
    GpBitmap** bitmap
    )
{
    API_ENTRY(GdipCreateBitmapFromStream);
    CheckGdiplusInitialized; // We do this in all our object creation API's

    CheckParameter(bitmap && stream);

    *bitmap = NULL;

    // See if the stream is a metafile


    GpMetafile* metafile = new GpMetafile(stream);

    if (metafile != NULL)
    {
        if (metafile->IsValid())
        {
            // If it is a {EMF, WMF} file, then we get a raster version of it
            // Note: GetBitmap() might return NULL if there is anything wrong
            // with the Metafile

            *bitmap = metafile->GetBitmap();
            metafile->Dispose();
            goto SkipRasterImage;
        }

        metafile->Dispose();
    }

    if ( NULL == *bitmap )
    {
        // it's not a valid metafile -- it must be a bitmap

        *bitmap = new GpBitmap(stream);
    }

SkipRasterImage:
    // !!! Can't use CheckValid() since destructor is protected.

    if (*bitmap)
    {
        if ((*bitmap)->IsValid())
        {
            (*bitmap)->SetICMConvert(FALSE);
            return Ok;
        }
        else
        {
            (*bitmap)->Dispose();
            *bitmap = NULL;
            return InvalidParameter;
        }
    }
    else
    {
        return OutOfMemory;
    }
}

GpStatus
WINGDIPAPI
GdipCreateBitmapFromFile(
    GDIPCONST WCHAR* filename,
    GpBitmap** bitmap
    )
{
    API_ENTRY(GdipCreateBitmapFromFile);
    CheckGdiplusInitialized; // We do this in all our object creation API's

    CheckParameter(bitmap && filename);

    *bitmap = NULL;


    // Try a metafile first always
    GpMetafile* metafile;
    metafile = new GpMetafile(filename);

    if (metafile)
    {
        if (metafile->IsValid())
        {
            *bitmap = metafile->GetBitmap();
            metafile->Dispose();
            goto SkipRasterImage;
        }

        metafile->Dispose();
    }

    // If it is not a metafile, then check if this is a raster image

    if ( NULL == *bitmap )
    {
        *bitmap = new GpBitmap(filename);
    }

    // !!! Can't use CheckValid() since destructor is protected.
SkipRasterImage:

    if (*bitmap)
    {
        if ((*bitmap)->IsValid())
        {
            (*bitmap)->SetICMConvert(FALSE);
            return Ok;
        }
        else
        {
            (*bitmap)->Dispose();
            *bitmap = NULL;
            return InvalidParameter;
        }
    }
    else
    {
        return OutOfMemory;
    }
}

GpStatus
WINGDIPAPI
GdipCreateBitmapFromStreamICM(
    IStream* stream,
    GpBitmap** bitmap
    )
{
    API_ENTRY(GdipCreateBitmapFromStreamICM);
    CheckGdiplusInitialized; // We do this in all our object creation API's

    CheckParameter(bitmap && stream);

    *bitmap = NULL;

    // See if the stream is a metafile


    GpMetafile* metafile = new GpMetafile(stream);

    if (metafile != NULL)
    {
        if (metafile->IsValid())
        {
            *bitmap = metafile->GetBitmap();
            metafile->Dispose();
            goto SkipRasterImage;
        }

        metafile->Dispose();
    }

    if ( NULL == *bitmap )
    {
        // it's not a valid metafile -- it must be a bitmap
        *bitmap = new GpBitmap(stream);
    }

    // !!! Can't use CheckValid() since destructor is protected.
SkipRasterImage:

    if (*bitmap)
    {
        if ((*bitmap)->IsValid())
        {
            (*bitmap)->SetICMConvert(TRUE);
            return Ok;
        }
        else
        {
            (*bitmap)->Dispose();
            *bitmap = NULL;
            return InvalidParameter;
        }
    }
    else
    {
        return OutOfMemory;
    }
}

GpStatus
WINGDIPAPI
GdipCreateBitmapFromFileICM(
    GDIPCONST WCHAR* filename,
    GpBitmap** bitmap
    )
{
    API_ENTRY(GdipCreateBitmapFromFileICM);
    CheckGdiplusInitialized; // We do this in all our object creation API's

    CheckParameter(bitmap && filename);

    // copied from GpImage::LoadImage

    *bitmap = NULL;


    // Try a metafile first always
    GpMetafile* metafile;
    metafile = new GpMetafile(filename);

    if (metafile)
    {
        if (metafile->IsValid())
        {
            *bitmap = metafile->GetBitmap();
            metafile->Dispose();
            goto SkipRasterImage;
        }

        metafile->Dispose();
    }

    // If it is not a metafile, then check if this is a raster image

    if ( NULL == *bitmap )
    {
        *bitmap = new GpBitmap(filename);
    }

    // !!! Can't use CheckValid() since destructor is protected.

SkipRasterImage:
    if (*bitmap)
    {
        if ((*bitmap)->IsValid())
        {
            (*bitmap)->SetICMConvert(TRUE);
            return Ok;
        }
        else
        {
            (*bitmap)->Dispose();
            *bitmap = NULL;
            return InvalidParameter;
        }
    }
    else
    {
        return OutOfMemory;
    }
}


GpStatus
WINGDIPAPI
GdipCreateBitmapFromScan0(
    INT width,
    INT height,
    INT stride,
    PixelFormatID format,
    BYTE* scan0,
    GpBitmap** bitmap
    )
{
    API_ENTRY(GdipCreateBitmapFromScan0);
    CheckGdiplusInitialized; // We do this in all our object creation API's

    CheckParameter(bitmap);
    format = MaskPixelFormat(format);


    if (scan0 == NULL)
    {
        *bitmap = new GpBitmap(width, height, format);
    }
    else
    {
        CheckParameter(stride);
        *bitmap = new GpBitmap(width, height, stride, format, scan0);
    }

    // !!! Can't use CheckValid() since destructor is protected.

    if (*bitmap)
    {
        if ((*bitmap)->IsValid())
            return Ok;
        else
        {
            (*bitmap)->Dispose();
            *bitmap = NULL;
            return InvalidParameter;
        }
    }
    else
    {
        return OutOfMemory;
    }
}

GpStatus
WINGDIPAPI
GdipCreateBitmapFromGraphics(
    INT width,
    INT height,
    GpGraphics* graphics,
    GpBitmap** bitmap
    )
{
    API_ENTRY(GdipCreateBitmapFromGraphics);
    CheckGdiplusInitialized; // We do this in all our object creation API's

    CheckParameter(bitmap);
    CheckParameterValid(graphics);
    CheckObjectBusy(graphics);

    //!!!TODO: temp use 32bpp argb

    #ifdef NO_PREMULTIPLIED_ALPHA
    *bitmap = new GpBitmap(width, height, PIXFMT_32BPP_ARGB, graphics);
    #else
    *bitmap = new GpBitmap(width, height, PIXFMT_32BPP_PARGB, graphics);
    #endif

    // !!! Can't use CheckValid() since destructor is protected.

    if (*bitmap)
    {
        if ((*bitmap)->IsValid())
            return Ok;
        else
        {
            (*bitmap)->Dispose();
            *bitmap = NULL;
            return InvalidParameter;
        }
    }
    else
    {
        return OutOfMemory;
    }
}

GpStatus
WINGDIPAPI
GdipCreateBitmapFromDirectDrawSurface(
    IDirectDrawSurface7 * surface,
    GpBitmap** bitmap
    )
{
    API_ENTRY(GdipCreateBitmapFromDirectDrawSurface);
    CheckGdiplusInitialized; // We do this in all our object creation API's

    CheckParameter(bitmap);
    CheckParameter(surface);

    *bitmap = new GpBitmap(surface);

    // !!! Can't use CheckValid() since destructor is protected.

    if (*bitmap)
    {
        if ((*bitmap)->IsValid())
            return Ok;
        else
        {
            (*bitmap)->Dispose();
            *bitmap = NULL;

            return InvalidParameter;
        }
    }

    return OutOfMemory;
}

GpStatus
WINGDIPAPI
GdipCreateBitmapFromGdiDib(
    GDIPCONST BITMAPINFO* gdiBitmapInfo,
    VOID* gdiBitmapData,
    GpBitmap** bitmap
    )
{
    API_ENTRY(GdipCreateBitmapFromGdiDib);
    CheckGdiplusInitialized; // We do this in all our object creation API's

    CheckParameter(bitmap);
    CheckParameter(gdiBitmapInfo);
    CheckParameter(gdiBitmapData);

    *bitmap = new GpBitmap(const_cast<BITMAPINFO*>(gdiBitmapInfo),
                           gdiBitmapData,
                           FALSE);

    // !!! Can't use CheckValid() since destructor is protected.

    if (*bitmap)
    {
        if ((*bitmap)->IsValid())
            return Ok;
        else
        {
            (*bitmap)->Dispose();
            *bitmap = NULL;
            return InvalidParameter;
        }
    }
    else
    {
        return OutOfMemory;
    }
}

GpStatus
WINGDIPAPI
GdipCreateBitmapFromHBITMAP(
    HBITMAP hbm,
    HPALETTE hpal,
    GpBitmap** bitmap
    )
{
    API_ENTRY(GdipCreateBitmapFromHBITMAP);
    CheckGdiplusInitialized; // We do this in all our object creation API's

    CheckParameter(bitmap);

    return GpBitmap::CreateFromHBITMAP(hbm, hpal, bitmap);
}

GpStatus
WINGDIPAPI
GdipCreateHBITMAPFromBitmap(
    GpBitmap* bitmap,
    HBITMAP* hbmReturn,
    ARGB background
    )
{
    API_ENTRY(GdipCreateHBITMAPFromBitmap);
    CheckGdiplusInitialized; // We do this in all our object creation API's

    CheckColorParameter(background);
    CheckParameter(hbmReturn);
    CheckParameterValid(bitmap);
    CheckObjectBusy(bitmap);

    return bitmap->CreateHBITMAP(hbmReturn, background);
}

GpStatus
WINGDIPAPI
GdipCreateBitmapFromHICON(
    HICON hicon,
    GpBitmap** bitmap
    )
{
    API_ENTRY(GdipCreateBitmapFromHICON);
    CheckGdiplusInitialized; // We do this in all our object creation API's

    CheckParameter(bitmap);

    return GpBitmap::CreateFromHICON(hicon, bitmap);
}

GpStatus
WINGDIPAPI
GdipCreateBitmapFromResource(HINSTANCE hInstance,
                             GDIPCONST WCHAR* lpBitmapName,
                             GpBitmap** bitmap)
{
    API_ENTRY(GdipCreateBitmapFromResource);
    CheckGdiplusInitialized; // We do this in all our object creation API's

    CheckParameter(bitmap);

    return GpBitmap::CreateFromResource(hInstance, const_cast<WCHAR*>(lpBitmapName), bitmap);
}

GpStatus
WINGDIPAPI
GdipCreateHICONFromBitmap(
    GpBitmap* bitmap,
    HICON* hiconReturn)
{
    API_ENTRY(GdipCreateHICONFromBitmap);
    CheckGdiplusInitialized; // We do this in all our object creation API's

    CheckParameter(hiconReturn);
    CheckParameterValid(bitmap);
    CheckObjectBusy(bitmap);

    return bitmap->CreateHICON(hiconReturn);
}

GpStatus
WINGDIPAPI
GdipCloneBitmapArea(
    REAL x,
    REAL y,
    REAL width,
    REAL height,
    PixelFormatID format,
    GpBitmap *srcBitmap,
    GpBitmap **dstBitmap
    )
{
    API_ENTRY(GdipCloneBitmapArea);
    format = MaskPixelFormat(format);

   return GdipCloneBitmapAreaI(GpRound(x), GpRound(y),
                               GpRound(width), GpRound(height),
                               format, srcBitmap, dstBitmap);
}

GpStatus
WINGDIPAPI
GdipCloneBitmapAreaI(
    INT x,
    INT y,
    INT width,
    INT height,
    PixelFormatID format,
    GpBitmap *srcBitmap,
    GpBitmap **dstBitmap
    )
{
    API_ENTRY(GdipCloneBitmapAreaI);
   CheckParameter(dstBitmap);
   CheckParameterValid(srcBitmap);
   CheckObjectBusy(srcBitmap);

   format = MaskPixelFormat(format);

   GpRect rect(x, y, width, height);

   *dstBitmap = srcBitmap->Clone(&rect, format);

   if (*dstBitmap)
       return Ok;
   else
       return OutOfMemory;
}

GpStatus
WINGDIPAPI
GdipBitmapLockBits(
    GpBitmap* bitmap,
    GDIPCONST GpRect* rect,   // can be NULL
    UINT flags,
    PixelFormatID format,
    BitmapData* lockedBitmapData
)
{
    API_ENTRY(GdipBitmapLockBits);
    CheckParameter(lockedBitmapData);
    CheckParameterValid(bitmap);
    CheckObjectBusy(bitmap);

    format = MaskPixelFormat(format);

    return bitmap->LockBits(rect, flags, format, lockedBitmapData);
}

GpStatus
WINGDIPAPI
GdipBitmapUnlockBits(
    GpBitmap* bitmap,
    BitmapData* lockedBitmapData
)
{
    API_ENTRY(GdipBitmapUnlockBits);
    CheckParameter(lockedBitmapData);
    CheckParameterValid(bitmap);
    CheckObjectBusy(bitmap);

    return bitmap->UnlockBits(lockedBitmapData);
}

GpStatus
WINGDIPAPI
GdipBitmapGetPixel(
    GpBitmap* bitmap,
    INT x,
    INT y,
    ARGB *color
)
{
    API_ENTRY(GdipBitmapGetPixel);
    CheckParameter(color);
    CheckParameterValid(bitmap);
    CheckObjectBusy(bitmap);

    ARGB temp;
    Status status = bitmap->GetPixel(x, y, &temp);
    *color = temp;

    return status;
}

GpStatus
WINGDIPAPI
GdipBitmapSetPixel(
    GpBitmap* bitmap,
    INT x,
    INT y,
    ARGB color
)
{
    API_ENTRY(GdipBitmapSetPixel);
    CheckColorParameter(color);
    CheckParameterValid(bitmap);
    CheckObjectBusy(bitmap);

    return bitmap->SetPixel(x, y, color);
}

GpStatus
WINGDIPAPI
GdipBitmapSetResolution(
    GpBitmap* bitmap,
    REAL xdpi,
    REAL ydpi
)
{
    API_ENTRY(GdipBitmapSetResolution);
    CheckParameterValid(bitmap);
    CheckObjectBusy(bitmap);

    return bitmap->SetResolution(xdpi, ydpi);
}

GpStatus
WINGDIPAPI
GdipCreateImageAttributes(GpImageAttributes **imageattr)
{
    API_ENTRY(GdipCreateImageAttributes);
    CheckGdiplusInitialized; // We do this in all our object creation API's

    CheckParameter(imageattr);

    *imageattr = new GpImageAttributes();

    if (*imageattr)
    {
        if ((*imageattr)->IsValid())
        {
            return Ok;
        }
        else
        {
            (*imageattr)->Dispose();
            *imageattr = NULL;
            return OutOfMemory;
        }
    }
    else
    {
        return OutOfMemory;
    }
}

GpStatus
WINGDIPAPI
GdipCloneImageAttributes(
    GDIPCONST GpImageAttributes *imageattr,
    GpImageAttributes **cloneImageAttr
)
{
    API_ENTRY(GdipCloneImageAttributes);
    CheckParameter(cloneImageAttr);
    CheckParameterValid(imageattr);
    CheckObjectBusy(imageattr);

    *cloneImageAttr = imageattr->Clone();

    if (*cloneImageAttr)
        return Ok;
    else
        return OutOfMemory;
}

GpStatus
WINGDIPAPI
GdipDisposeImageAttributes(
    GpImageAttributes *imageattr
)
{
    API_ENTRY(GdipDisposeImageAttributes);
    // NOTE: Do NOT call CheckParameterValid(), because we need to free
    // the object, even if it's not in a valid state.
    CheckParameter(imageattr);
    CheckObjectBusyForDelete(imageattr);

    imageattr->Dispose();

    return Ok;
}

GpStatus
WINGDIPAPI
GdipSetImageAttributesToIdentity(
    GpImageAttributes *imageattr,
    ColorAdjustType type
)
{
    API_ENTRY(GdipSetImageAttributesToIdentity);
    CheckParameterValid(imageattr);
    CheckObjectBusy(imageattr);
    CheckParameter(ColorAdjustTypeIsValid(type));

    return imageattr->SetToIdentity(type);
}

GpStatus
WINGDIPAPI
GdipResetImageAttributes(
    GpImageAttributes *imageattr,
    ColorAdjustType type
)
{
    API_ENTRY(GdipResetImageAttributes);
    CheckParameterValid(imageattr);
    CheckObjectBusy(imageattr);
    CheckParameter(ColorAdjustTypeIsValid(type));

    return imageattr->Reset(type);
}

GpStatus
WINGDIPAPI
GdipSetImageAttributesColorMatrix(
    GpImageAttributes *imageattr,
    ColorAdjustType type,
    BOOL enableFlag,
    GDIPCONST ColorMatrix* colorMatrix,
    GDIPCONST ColorMatrix* grayMatrix,
    ColorMatrixFlags flags
)
{
    API_ENTRY(GdipSetImageAttributesColorMatrix);
    CheckParameterValid(imageattr);
    CheckObjectBusy(imageattr);
    CheckParameter(ColorAdjustTypeIsValid(type));

    // Note: GpImageAttributes::SetColorMatrix will validate
    //       colorMatrix since it may be valid to pass NULL
    //       (such as when enableFlag is FALSE).

    return imageattr->SetColorMatrix(type,
                                     enableFlag,
                                     const_cast<ColorMatrix*>(colorMatrix),
                                     const_cast<ColorMatrix*>(grayMatrix), flags);
}

GpStatus
WINGDIPAPI
GdipSetImageAttributesThreshold(
    GpImageAttributes *imageattr,
    ColorAdjustType type,
    BOOL enableFlag,
    REAL threshold
)
{
    API_ENTRY(GdipSetImageAttributesThreshold);
    CheckParameterValid(imageattr);
    CheckObjectBusy(imageattr);
    CheckParameter(ColorAdjustTypeIsValid(type));

    return imageattr->SetThreshold(type, enableFlag, threshold);
}

GpStatus
WINGDIPAPI
GdipSetImageAttributesGamma(
    GpImageAttributes *imageattr,
    ColorAdjustType type,
    BOOL enableFlag,
    REAL gamma
)
{
    API_ENTRY(GdipSetImageAttributesGamma);
    CheckParameterValid(imageattr);
    CheckObjectBusy(imageattr);
    CheckParameter(ColorAdjustTypeIsValid(type));

    return imageattr->SetGamma(type, enableFlag, gamma);
}

GpStatus
WINGDIPAPI
GdipSetImageAttributesNoOp(
    GpImageAttributes *imageattr,
    ColorAdjustType type,
    BOOL enableFlag
)
{
    API_ENTRY(GdipSetImageAttributesNoOp);
    CheckParameterValid(imageattr);
    CheckObjectBusy(imageattr);
    CheckParameter(ColorAdjustTypeIsValid(type));

    return imageattr->SetNoOp(type, enableFlag);
}

GpStatus
WINGDIPAPI
GdipSetImageAttributesColorKeys(
    GpImageAttributes *imageattr,
    ColorAdjustType type,
    BOOL enableFlag,
    ARGB argbLow,
    ARGB argbHigh
)
{
    API_ENTRY(GdipSetImageAttributesColorKeys);
    CheckColorParameter(argbLow);
    CheckColorParameter(argbHigh);
    CheckParameterValid(imageattr);
    CheckObjectBusy(imageattr);
    CheckParameter(ColorAdjustTypeIsValid(type));

    Color colorLow(argbLow);
    Color colorHigh(argbHigh);

    return imageattr->SetColorKeys(type, enableFlag, &colorLow, &colorHigh);
}

GpStatus
WINGDIPAPI
GdipSetImageAttributesOutputChannel(
    GpImageAttributes *imageattr,
    ColorAdjustType type,
    BOOL enableFlag,
    ColorChannelFlags channelFlags
)
{
    API_ENTRY(GdipSetImageAttributesOutputChannel);
    CheckParameterValid(imageattr);
    CheckObjectBusy(imageattr);
    CheckParameter(ColorAdjustTypeIsValid(type));

    return imageattr->SetOutputChannel(type, enableFlag, channelFlags);
}

GpStatus
WINGDIPAPI
GdipSetImageAttributesOutputChannelColorProfile(
    GpImageAttributes *imageattr,
    ColorAdjustType type,
    BOOL enableFlag,
    GDIPCONST WCHAR *colorProfileFilename)
{
    API_ENTRY(GdipSetImageAttributesOutputChannelColorProfile);
    CheckParameterValid(imageattr);
    CheckObjectBusy(imageattr);
    CheckParameter(ColorAdjustTypeIsValid(type));

    // Note: GpImageAttributes::SetOutputChannelProfile will validate
    //       colorProfileFilename since it may be valid to pass NULL
    //       (such as when enableFlag is FALSE).

    return imageattr->SetOutputChannelProfile(type, enableFlag,
                                              const_cast<WCHAR*>(colorProfileFilename));
}

GpStatus
WINGDIPAPI
GdipSetImageAttributesRemapTable(
    GpImageAttributes *imageattr,
    ColorAdjustType type,
    BOOL enableFlag,
    UINT mapSize,
    GDIPCONST ColorMap *map
)
{
    API_ENTRY(GdipSetImageAttributesRemapTable);
    CheckParameterValid(imageattr);
    CheckObjectBusy(imageattr);
    CheckParameter(ColorAdjustTypeIsValid(type));

    return imageattr->SetRemapTable(type, enableFlag, mapSize, const_cast<ColorMap*>(map));
}

GpStatus
WINGDIPAPI
GdipSetImageAttributesCachedBackground(
    GpImageAttributes *imageattr,
    BOOL enableFlag
)
{
    API_ENTRY(GdipSetImageAttributesCachedBackground);
    CheckParameterValid(imageattr);
    CheckObjectBusy(imageattr);

    return imageattr->SetCachedBackground(enableFlag);
}

GpStatus
WINGDIPAPI
GdipSetImageAttributesWrapMode(
    GpImageAttributes *imageAttr,
    WrapMode wrap,
    ARGB argb,
    BOOL clamp
)
{
    API_ENTRY(GdipSetImageAttributesWrapMode);
    CheckColorParameter(argb);
    CheckParameterValid(imageAttr);
    CheckObjectBusy(imageAttr);

    return imageAttr->SetWrapMode(wrap, argb, clamp);
}

GpStatus WINGDIPAPI
GdipGetImageAttributesAdjustedPalette(
    GpImageAttributes *imageAttr,
    ColorPalette * colorPalette,
    ColorAdjustType colorAdjustType
    )
{
    API_ENTRY(GdipGetImageAttributesAdjustedPalette);
    CheckParameterValid(imageAttr);
    CheckObjectBusy(imageAttr);
    CheckParameter((colorPalette != NULL) && (colorPalette->Count > 0));
    CheckParameter((colorAdjustType >= ColorAdjustTypeBitmap) &&
                   (colorAdjustType < ColorAdjustTypeCount));

    imageAttr->GetAdjustedPalette(colorPalette, colorAdjustType);

    return Ok;
}

GpStatus
WINGDIPAPI
GdipCreateFromHDC(
    HDC hdc,
    GpGraphics** graphics
    )
{
    API_ENTRY(GdipCreateFromHDC);
    CheckGdiplusInitialized; // We do this in all our object creation API's

   CheckParameter(graphics);


   *graphics = GpGraphics::GetFromHdc(hdc);

   if (CheckValid(*graphics))
       return Ok;
   else
       return OutOfMemory;
}

GpStatus
WINGDIPAPI
GdipCreateFromHDC2(
    HDC hdc,
    HANDLE hdevice,
    GpGraphics** graphics
    )
{
    API_ENTRY(GdipCreateFromHDC2);
    CheckGdiplusInitialized; // We do this in all our object creation API's

   CheckParameter(graphics);


   *graphics = GpGraphics::GetFromHdc(hdc, hdevice);

   if (CheckValid(*graphics))
       return Ok;
   else
       return OutOfMemory;
}

GpStatus
WINGDIPAPI
GdipCreateFromHWND(
    HWND hwnd,
    GpGraphics** graphics
    )
{
    API_ENTRY(GdipCreateFromHWND);
    CheckGdiplusInitialized; // We do this in all our object creation API's

   CheckParameter(graphics);

   *graphics = GpGraphics::GetFromHwnd(hwnd);

   if (CheckValid(*graphics))
       return Ok;
   else
       return OutOfMemory;
}

GpStatus
WINGDIPAPI
GdipCreateFromHWNDICM(
    HWND hwnd,
    GpGraphics** graphics
    )
{
    API_ENTRY(GdipCreateFromHWNDICM);
    CheckGdiplusInitialized; // We do this in all our object creation API's

   CheckParameter(graphics);

   *graphics = GpGraphics::GetFromHwnd(hwnd, IcmModeOn);

   if (CheckValid(*graphics))
       return Ok;
   else
       return OutOfMemory;
}

GpStatus
WINGDIPAPI
GdipDeleteGraphics(
    GpGraphics* graphics
    )
{
    API_ENTRY(GdipDeleteGraphics);
    // NOTE: Do NOT call CheckParameterValid(), because we need to free
    // the object, even if it's not in a valid state.
    CheckParameter(graphics);
    CheckObjectBusyForDelete(graphics);


    delete graphics;

    return Ok;
}

GpStatus
WINGDIPAPI
GdipFlush(
    GpGraphics* graphics,
    GpFlushIntention intention
    )
{
    API_ENTRY(GdipFlush);
    CheckParameter(graphics);
    CheckObjectBusy(graphics);


    graphics->Flush(intention);

    return Ok;
}


GpStatus
WINGDIPAPI
GdipSetRenderingOrigin(
    GpGraphics* graphics,
    INT x,
    INT y
    )
{
    API_ENTRY(GdipSetRenderingOrigin);
    CheckParameterValid(graphics);
    CheckObjectBusy(graphics);

    graphics->SetRenderingOrigin(x, y);

    return Ok;
}

GpStatus
WINGDIPAPI
GdipGetRenderingOrigin(
    GpGraphics *graphics,
    INT *x,
    INT *y
    )
{
    API_ENTRY(GdipGetRenderingOrigin);
    CheckParameter(x);
    CheckParameter(y);
    CheckParameterValid(graphics);
    CheckObjectBusy(graphics);

    graphics->GetRenderingOrigin(x, y);

    return Ok;
}



GpStatus
WINGDIPAPI
GdipSetCompositingMode(
    GpGraphics* graphics,
    CompositingMode newMode
    )
{
    API_ENTRY(GdipSetCompositingMode);
    CheckParameterValid(graphics);
    CheckObjectBusy(graphics);

    graphics->SetCompositingMode(newMode);

    return Ok;
}

GpStatus
WINGDIPAPI
GdipGetCompositingMode(
    GpGraphics *graphics,
    CompositingMode *mode
    )
{
    API_ENTRY(GdipGetCompositingMode);
    CheckParameter(mode);
    CheckParameterValid(graphics);
    CheckObjectBusy(graphics);

    *mode = graphics->GetCompositingMode();

    return Ok;
}

GpStatus
WINGDIPAPI
GdipSetCompositingQuality(
    GpGraphics* graphics,
    CompositingQuality newQuality
    )
{
    API_ENTRY(GdipSetCompositingQuality);
    CheckParameterValid(graphics);
    CheckObjectBusy(graphics);

    graphics->SetCompositingQuality(newQuality);

    return Ok;
}

GpStatus
WINGDIPAPI
GdipGetCompositingQuality(
    GpGraphics *graphics,
    CompositingQuality *quality
    )
{
    API_ENTRY(GdipGetCompositingQuality);
    CheckParameter(quality);
    CheckParameterValid(graphics);
    CheckObjectBusy(graphics);

    *quality = graphics->GetCompositingQuality();

    return Ok;
}

GpStatus
WINGDIPAPI
GdipSetSmoothingMode(
    GpGraphics* graphics,
    SmoothingMode smoothingMode
    )
{
    API_ENTRY(GdipSetSmoothingMode);
   CheckParameterValid(graphics);
   CheckObjectBusy(graphics);

   // For now, have it so that a Rendering hint of 1
   // means antialiasing ON and a Rendering Hint of 0
   // means Off.

   switch(smoothingMode)
   {
   case SmoothingModeDefault:
   case SmoothingModeHighSpeed:
   case SmoothingModeNone:
       graphics->SetAntiAliasMode(FALSE);
       break;

   case SmoothingModeHighQuality:
   case SmoothingModeAntiAlias:
       graphics->SetAntiAliasMode(TRUE);
       break;

   default:
       // unknown rendering mode
       return InvalidParameter;
   }

   return Ok;
}

GpStatus
WINGDIPAPI
GdipGetSmoothingMode(
    GpGraphics *graphics,
    SmoothingMode *smoothingMode
    )
{
    API_ENTRY(GdipGetSmoothingMode);
   CheckParameter(smoothingMode);
   CheckParameterValid(graphics);
   CheckObjectBusy(graphics);

   BOOL aaOn = graphics->GetAntiAliasMode();

   if (aaOn)
   {
       *smoothingMode = SmoothingModeAntiAlias;
   }
   else
   {
       *smoothingMode = SmoothingModeNone;
   }

   return Ok;
}

GpStatus
WINGDIPAPI
GdipSetPixelOffsetMode(
    GpGraphics* graphics,
    PixelOffsetMode newMode
    )
{
    API_ENTRY(GdipSetPixelOffsetMode);
    CheckParameterValid(graphics);
    CheckObjectBusy(graphics);
    CheckParameter((newMode >= PixelOffsetModeDefault) &&
                   (newMode <= PixelOffsetModeHalf));

    graphics->SetPixelOffsetMode(newMode);
    return Ok;
}

GpStatus
WINGDIPAPI
GdipGetPixelOffsetMode(
    GpGraphics *graphics,
    PixelOffsetMode *pixelOffsetMode
    )
{
    API_ENTRY(GdipGetPixelOffsetMode);
   CheckParameter(pixelOffsetMode);
   CheckParameterValid(graphics);
   CheckObjectBusy(graphics);

   *pixelOffsetMode = graphics->GetPixelOffsetMode();
   return Ok;
}

GpStatus
WINGDIPAPI
GdipSetTextRenderingHint(
    GpGraphics* graphics,
    TextRenderingHint newMode
    )
{
    API_ENTRY(GdipSetTextRenderingHint);
   CheckParameterValid(graphics);
   CheckObjectBusy(graphics);

   // For now, have it so that a Rendering hint of 1
   // means antialiasing ON and a Rendering Hint of 0
   // means Off.

   switch(newMode)
   {
   case TextRenderingHintSystemDefault:
   case TextRenderingHintSingleBitPerPixelGridFit:
   case TextRenderingHintSingleBitPerPixel:
   case TextRenderingHintAntiAlias:
   case TextRenderingHintAntiAliasGridFit:
   case TextRenderingHintClearTypeGridFit:
       graphics->SetTextRenderingHint(newMode);
       break;

   default:
       // unknown rendering mode
       return InvalidParameter;
   }

   return Ok;
}

GpStatus
WINGDIPAPI
GdipSetTextContrast(
    GpGraphics* graphics,
    UINT        contrast
    )
{
    API_ENTRY(GdipSetTextContrast);
   CheckParameterValid(graphics);
   CheckObjectBusy(graphics);

   return graphics->SetTextContrast(contrast);
}

GpStatus
WINGDIPAPI
GdipGetTextContrast(
    GpGraphics* graphics,
    UINT      * contrast
    )
{
    API_ENTRY(GdipGetTextContrast);
   CheckParameter(contrast);
   CheckParameterValid(graphics);
   CheckObjectBusy(graphics);

   *contrast = graphics->GetTextContrast();

   return Ok;
}


GpStatus
WINGDIPAPI
GdipGetTextRenderingHint(
    GpGraphics *graphics,
    TextRenderingHint *mode
    )
{
    API_ENTRY(GdipGetTextRenderingHint);
   CheckParameter(mode);
   CheckParameterValid(graphics);
   CheckObjectBusy(graphics);

   *mode = graphics->GetTextRenderingHint();

   return Ok;
}

GpStatus
WINGDIPAPI
GdipSetInterpolationMode(
    GpGraphics* graphics,
    InterpolationMode interpolationMode
    )
{
    API_ENTRY(GdipSetInterpolationMode);
   CheckParameterValid(graphics);
   CheckObjectBusy(graphics);
   CheckParameter((interpolationMode >= InterpolationModeDefault) &&
                  (interpolationMode <= InterpolationModeHighQualityBicubic));

   if(Globals::ForceBilinear)
   {
       if(interpolationMode != InterpolationModeNearestNeighbor)
       {
           interpolationMode = InterpolationModeBilinear;
       }
   }
   else
   {
       if(interpolationMode == InterpolationModeDefault ||
          interpolationMode == InterpolationModeLowQuality)
       {
           interpolationMode = InterpolationModeBilinear;
       }
       else if(interpolationMode == InterpolationModeHighQuality)
       {
           interpolationMode = InterpolationModeHighQualityBicubic;
       }
   }

   graphics->SetInterpolationMode(interpolationMode);

   return Ok;
}

GpStatus
WINGDIPAPI
GdipGetInterpolationMode(
    GpGraphics* graphics,
    InterpolationMode *interpolationMode
    )
{
    API_ENTRY(GdipGetInterpolationMode);
   CheckParameterValid(graphics);
   CheckObjectBusy(graphics);

   *interpolationMode = graphics->GetInterpolationMode();

   return Ok;
}

GpStatus
WINGDIPAPI
GdipSetWorldTransform(
    GpGraphics *graphics,
    GpMatrix *matrix
    )
{
    API_ENTRY(GdipSetWorldTransform);
   CheckParameterValid(graphics);
   CheckObjectBusy(graphics);
   CheckParameterValid(matrix);
   CheckObjectBusy(matrix);
    
   return graphics->SetWorldTransform(*matrix);
}

GpStatus
WINGDIPAPI
GdipResetWorldTransform(
    GpGraphics *graphics
    )
{
    API_ENTRY(GdipResetWorldTransform);
   CheckParameterValid(graphics);
   CheckObjectBusy(graphics);

   return graphics->ResetWorldTransform();
}

GpStatus
WINGDIPAPI
GdipMultiplyWorldTransform(
    GpGraphics *graphics,
    GDIPCONST GpMatrix *matrix,
    GpMatrixOrder order
    )
{
    API_ENTRY(GdipMultiplyWorldTransform);
    if(matrix == NULL)
        return Ok;

    CheckParameterValid(graphics);
    CheckObjectBusy(graphics);
    CheckParameterValid(matrix);
    CheckObjectBusy(matrix);
    CheckParameter(MatrixOrderIsValid(order));

    return graphics->MultiplyWorldTransform(*matrix, order);
}

GpStatus
WINGDIPAPI
GdipTranslateWorldTransform(
    GpGraphics *graphics,
    REAL dx,
    REAL dy,
    GpMatrixOrder order
    )
{
    API_ENTRY(GdipTranslateWorldTransform);
    CheckParameterValid(graphics);
    CheckObjectBusy(graphics);
    CheckParameter(MatrixOrderIsValid(order));

    return graphics->TranslateWorldTransform(dx, dy, order);
}

GpStatus
WINGDIPAPI
GdipScaleWorldTransform(
    GpGraphics *graphics,
    REAL sx,
    REAL sy,
    GpMatrixOrder order
    )
{
    API_ENTRY(GdipScaleWorldTransform);
    CheckParameterValid(graphics);
    CheckObjectBusy(graphics);
    CheckParameter(MatrixOrderIsValid(order));
    
    return graphics->ScaleWorldTransform(sx, sy, order);
}

GpStatus
WINGDIPAPI
GdipRotateWorldTransform(
    GpGraphics *graphics,
    REAL angle,
    GpMatrixOrder order
    )
{
    API_ENTRY(GdipRotateWorldTransform);
    CheckParameterValid(graphics);
    CheckObjectBusy(graphics);
    CheckParameter(MatrixOrderIsValid(order));

    return graphics->RotateWorldTransform(angle, order);
}

GpStatus
WINGDIPAPI
GdipGetWorldTransform(
    GpGraphics *graphics,
    GpMatrix *matrix
    )
{
    API_ENTRY(GdipGetWorldTransform);
    CheckParameter(matrix);
    CheckObjectBusy(matrix);
    CheckParameterValid(graphics);
    CheckObjectBusy(graphics);

    graphics->GetWorldTransform(*matrix);
    return Ok;
}

GpStatus
WINGDIPAPI
GdipResetPageTransform(
    GpGraphics *graphics
    )
{
    API_ENTRY(GdipResetPageTransform);
   CheckParameterValid(graphics);
   CheckObjectBusy(graphics);

   return graphics->ResetPageTransform();
}

GpStatus
WINGDIPAPI
GdipGetPageUnit(
    GpGraphics* graphics,
    GpPageUnit* unit
    )
{
    API_ENTRY(GdipGetPageUnit);
   CheckParameter(unit);
   CheckParameterValid(graphics);
   CheckObjectBusy(graphics);

   *unit = graphics->GetPageUnit();

   return Ok;
}

GpStatus
WINGDIPAPI
GdipSetPageUnit(
    GpGraphics* graphics,
    GpPageUnit unit
    )
{
    API_ENTRY(GdipSetPageUnit);
    CheckParameterValid(graphics);
    CheckObjectBusy(graphics);

   // PageUnit can't be world
    CheckParameter((unit > UnitWorld) && (unit <= UnitMillimeter));

    return graphics->SetPageUnit(unit);
}

GpStatus
WINGDIPAPI
GdipGetPageScale(
    GpGraphics* graphics,
    REAL* scale
    )
{
    API_ENTRY(GdipGetPageScale);
   CheckParameter(scale);
   CheckParameterValid(graphics);
   CheckObjectBusy(graphics);

   *scale = graphics->GetPageScale();

   return Ok;
}

GpStatus
WINGDIPAPI
GdipSetPageScale(
    GpGraphics* graphics,
    REAL scale
    )
{
    API_ENTRY(GdipSetPageScale);
   CheckParameterValid(graphics);
   CheckObjectBusy(graphics);

   return graphics->SetPageScale(scale);
}

GpStatus
WINGDIPAPI
GdipGetDpiX(
    GpGraphics* graphics,
    REAL* dpi
    )
{
    API_ENTRY(GdipGetDpiX);
   CheckParameter(dpi);
   CheckParameterValid(graphics);
   CheckObjectBusy(graphics);

   *dpi = graphics->GetDpiX();

   return Ok;
}

GpStatus
WINGDIPAPI
GdipGetDpiY(
    GpGraphics* graphics,
    REAL* dpi
    )
{
    API_ENTRY(GdipGetDpiY);
   CheckParameter(dpi);
   CheckParameterValid(graphics);
   CheckObjectBusy(graphics);

   *dpi = graphics->GetDpiY();

   return Ok;
}

GpStatus
WINGDIPAPI
GdipTransformPoints(
    GpGraphics *graphics,
    GpCoordinateSpace destSpace,
    GpCoordinateSpace srcSpace,
    GpPointF *points,
    INT count
    )
{
    API_ENTRY(GdipTransformPoints);
   CheckParameter(points && count > 0);
   CheckParameterValid(graphics);
   CheckObjectBusy(graphics);

   return graphics->TransformPoints(points, count, srcSpace, destSpace);
}

GpStatus
WINGDIPAPI
GdipTransformPointsI(
    GpGraphics *graphics,
    GpCoordinateSpace destSpace,
    GpCoordinateSpace srcSpace,
    GpPoint *points,
    INT count
    )
{
    API_ENTRY(GdipTransformPointsI);
   CheckParameter(points && count > 0);
   CheckParameterValid(graphics);
   CheckObjectBusy(graphics);

   INT i;
   StackBuffer buffer;

   GpPointF* pointsF = (GpPointF*) buffer.GetBuffer(count*sizeof(GpPointF));

   if(!pointsF) return OutOfMemory;

   for (i=0; i<count; i++)
   {
       pointsF[i].X = TOREAL(points[i].X);
       pointsF[i].Y = TOREAL(points[i].Y);
   }

   GpStatus status = graphics->TransformPoints(pointsF, count, srcSpace, destSpace);

   for (i=0; i<count; i++)
   {
       points[i].X = GpRound(pointsF[i].X);
       points[i].Y = GpRound(pointsF[i].Y);
   }

   return status;
}

//------------------------------------------------------------------------
// GetNearestColor (for <= 8bpp surfaces)
//------------------------------------------------------------------------

GpStatus
WINGDIPAPI
GdipGetNearestColor(
    GpGraphics *graphics,
    ARGB *argb
    )
{
    API_ENTRY(GdipGetNearestColor);
    CheckParameter(argb);
    CheckColorParameter(*argb);
    CheckParameterValid(graphics);
    CheckObjectBusy(graphics);

    ARGB temp = graphics->GetNearestColor(*argb);
    *argb = temp;
    return Ok;
}

// defined in Engine\render\Halftone.cpp
extern HPALETTE WINGDIPAPI GdipCreateHalftonePalette();

GpStatus
WINGDIPAPI
GdipDrawLine(
    GpGraphics *graphics,
    GpPen *pen,
    REAL x1,
    REAL y1,
    REAL x2,
    REAL y2
    )
{
    API_ENTRY(GdipDrawLine);
    CheckParameterValid(graphics);
    CheckObjectBusy(graphics);
    CheckParameterValid(pen);
    CheckObjectBusy(pen);


    return graphics->DrawLine(pen, x1, y1, x2, y2);
}

GpStatus
WINGDIPAPI
GdipDrawLineI(
    GpGraphics *graphics,
    GpPen *pen,
    INT x1,
    INT y1,
    INT x2,
    INT y2
    )
{
    API_ENTRY(GdipDrawLineI);
    return GdipDrawLine(graphics, pen, TOREAL(x1), TOREAL(y1), TOREAL(x2), TOREAL(y2));
}

GpStatus
WINGDIPAPI
GdipDrawLines(
    GpGraphics *graphics,
    GpPen *pen,
    GDIPCONST GpPointF *points,
    INT count
    )
{
    API_ENTRY(GdipDrawLines);
   CheckParameter(points && count > 0);
   CheckParameterValid(graphics);
   CheckObjectBusy(graphics);
   CheckParameterValid(pen);
   CheckObjectBusy(pen);


   return graphics->DrawLines(pen, points, count);
}

GpStatus
WINGDIPAPI
GdipDrawLinesI(
    GpGraphics *graphics,
    GpPen *pen,
    GDIPCONST GpPoint *points,
    INT count
    )
{
    API_ENTRY(GdipDrawLinesI);
   StackBuffer buffer;

   GpPointF* pointsF = (GpPointF*) buffer.GetBuffer(count*sizeof(GpPointF));

   if(!pointsF) return OutOfMemory;

   for (INT i=0; i<count; i++)
   {
       pointsF[i].X = TOREAL(points[i].X);
       pointsF[i].Y = TOREAL(points[i].Y);
   }

   GpStatus status = GdipDrawLines(graphics, pen, pointsF, count);

   return status;
}

GpStatus
WINGDIPAPI
GdipDrawArc(
    GpGraphics *graphics,
    GpPen *pen,
    REAL x,
    REAL y,
    REAL width,
    REAL height,
    REAL startAngle,
    REAL sweepAngle
    )
{
    API_ENTRY(GdipDrawArc);
   CheckParameterValid(graphics);
   CheckObjectBusy(graphics);
   CheckParameterValid(pen);
   CheckObjectBusy(pen);


   return graphics->DrawArc(pen, x, y, width, height, startAngle, sweepAngle);
}

GpStatus
WINGDIPAPI
GdipDrawArcI(
    GpGraphics *graphics,
    GpPen *pen,
    INT x,
    INT y,
    INT width,
    INT height,
    REAL startAngle,
    REAL sweepAngle
    )
{
    API_ENTRY(GdipDrawArcI);
   return GdipDrawArc(graphics, pen, TOREAL(x), TOREAL(y),
                      TOREAL(width), TOREAL(height), startAngle, sweepAngle);
}

GpStatus
WINGDIPAPI
GdipDrawBezier(
    GpGraphics *graphics,
    GpPen *pen,
    REAL x1,
    REAL y1,
    REAL x2,
    REAL y2,
    REAL x3,
    REAL y3,
    REAL x4,
    REAL y4
    )
{
    API_ENTRY(GdipDrawBezier);
   CheckParameterValid(graphics);
   CheckObjectBusy(graphics);
   CheckParameterValid(pen);
   CheckObjectBusy(pen);


   return graphics->DrawBezier(pen, x1, y1, x2, y2, x3, y3, x4, y4);
}

GpStatus
WINGDIPAPI
GdipDrawBezierI(
    GpGraphics *graphics,
    GpPen *pen,
    INT x1,
    INT y1,
    INT x2,
    INT y2,
    INT x3,
    INT y3,
    INT x4,
    INT y4
    )
{
    API_ENTRY(GdipDrawBezierI);
   return GdipDrawBezier(graphics, pen, TOREAL(x1), TOREAL(y1),
                         TOREAL(x2), TOREAL(y2), TOREAL(x3), TOREAL(y3),
                         TOREAL(x4), TOREAL(y4));
}

GpStatus
WINGDIPAPI
GdipDrawBeziers(
    GpGraphics *graphics,
    GpPen *pen,
    GDIPCONST GpPointF *points,
    INT count
    )
{
    API_ENTRY(GdipDrawBeziers);
   CheckParameter(points && count > 0);
   CheckParameterValid(graphics);
   CheckObjectBusy(graphics);
   CheckParameterValid(pen);
   CheckObjectBusy(pen);


   return graphics->DrawBeziers(pen, points, count);
}

GpStatus
WINGDIPAPI
GdipDrawBeziersI(
    GpGraphics *graphics,
    GpPen *pen,
    GDIPCONST GpPoint *points,
    INT count
    )
{
    API_ENTRY(GdipDrawBeziersI);
    
    // Must check these parameters because we use them before calling into
    // GdipDrawBeziers
    
    CheckParameter(points && count > 0);
    
    StackBuffer buffer;

    GpPointF* pointsF = (GpPointF*) buffer.GetBuffer(count*sizeof(GpPointF));

    if(!pointsF) return OutOfMemory;

    for (INT i=0; i<count; i++)
    {
        pointsF[i].X = TOREAL(points[i].X);
        pointsF[i].Y = TOREAL(points[i].Y);
    }

    GpStatus status = GdipDrawBeziers(graphics, pen, pointsF, count);

    return status;
}

GpStatus
WINGDIPAPI
GdipDrawRectangle(
    GpGraphics *graphics,
    GpPen *pen,
    REAL x,
    REAL y,
    REAL width,
    REAL height)
{
    API_ENTRY(GdipDrawRectangle);
   CheckParameterValid(graphics);
   CheckObjectBusy(graphics);
   CheckParameterValid(pen);
   CheckObjectBusy(pen);


   return graphics->DrawRect(pen, x, y, width, height);
}

GpStatus
WINGDIPAPI
GdipDrawRectangleI(
    GpGraphics *graphics,
    GpPen *pen,
    INT x,
    INT y,
    INT width,
    INT height)
{
    API_ENTRY(GdipDrawRectangleI);
   return GdipDrawRectangle(graphics, pen,
                            TOREAL(x), TOREAL(y),
                            TOREAL(width), TOREAL(height));
}

GpStatus
WINGDIPAPI
GdipDrawRectangles(
    GpGraphics *graphics,
    GpPen *pen,
    GDIPCONST GpRectF *rects,
    INT count
    )
{
    API_ENTRY(GdipDrawRectangles);
   CheckParameter(rects && count > 0);
   CheckParameterValid(graphics);
   CheckObjectBusy(graphics);
   CheckParameterValid(pen);
   CheckObjectBusy(pen);


   return graphics->DrawRects(pen, rects, count);
}

GpStatus
WINGDIPAPI
GdipDrawRectanglesI(
    GpGraphics *graphics,
    GpPen *pen,
    GDIPCONST GpRect *rects,
    INT count
    )
{
    API_ENTRY(GdipDrawRectanglesI);
    CheckParameter(rects && count > 0);
   
   StackBuffer buffer;

   GpRectF *rectsF = (GpRectF*) buffer.GetBuffer(count*sizeof(GpRectF));

   if(!rectsF) return OutOfMemory;

   for (INT i=0; i<count; i++)
   {
       rectsF[i].X = TOREAL(rects[i].X);
       rectsF[i].Y = TOREAL(rects[i].Y);
       rectsF[i].Width = TOREAL(rects[i].Width);
       rectsF[i].Height = TOREAL(rects[i].Height);
   }

   GpStatus status = GdipDrawRectangles(graphics, pen, rectsF, count);

   return status;
}

GpStatus
WINGDIPAPI
GdipDrawEllipse(
    GpGraphics *graphics,
    GpPen *pen,
    REAL x,
    REAL y,
    REAL width,
    REAL height
    )
{
    API_ENTRY(GdipDrawEllipse);
   CheckParameterValid(graphics);
   CheckObjectBusy(graphics);
   CheckParameterValid(pen);
   CheckObjectBusy(pen);


   return graphics->DrawEllipse(pen, x, y, width, height);
}

GpStatus
WINGDIPAPI
GdipDrawEllipseI(
    GpGraphics *graphics,
    GpPen *pen,
    INT x,
    INT y,
    INT width,
    INT height
    )
{
    API_ENTRY(GdipDrawEllipseI);
   return GdipDrawEllipse(graphics, pen,
                          TOREAL(x), TOREAL(y),
                          TOREAL(width), TOREAL(height));
}

GpStatus
WINGDIPAPI
GdipDrawPie(
    GpGraphics *graphics,
    GpPen *pen,
    REAL x,
    REAL y,
    REAL width,
    REAL height,
    REAL startAngle,
    REAL sweepAngle
    )
{
    API_ENTRY(GdipDrawPie);
   CheckParameterValid(graphics);
   CheckObjectBusy(graphics);
   CheckParameterValid(pen);
   CheckObjectBusy(pen);


   return graphics->DrawPie(pen, x, y, width, height, startAngle, sweepAngle);
}

GpStatus
WINGDIPAPI
GdipDrawPieI(
    GpGraphics *graphics,
    GpPen *pen,
    INT x,
    INT y,
    INT width,
    INT height,
    REAL startAngle,
    REAL sweepAngle
    )
{
    API_ENTRY(GdipDrawPieI);
   return GdipDrawPie(graphics, pen,
                      TOREAL(x), TOREAL(y),
                      TOREAL(width), TOREAL(height),
                      startAngle, sweepAngle);
}

GpStatus
WINGDIPAPI
GdipDrawPolygon(
    GpGraphics *graphics,
    GpPen *pen,
    GDIPCONST GpPointF *points,
    INT count)
{
    API_ENTRY(GdipDrawPolygon);
   CheckParameter(points && count > 0);
   CheckParameterValid(graphics);
   CheckObjectBusy(graphics);
   CheckParameterValid(pen);
   CheckObjectBusy(pen);


   return graphics->DrawPolygon(pen, points, count);
}

GpStatus
WINGDIPAPI
GdipDrawPolygonI(
    GpGraphics *graphics,
    GpPen *pen,
    GDIPCONST GpPoint *points,
    INT count)
{
    API_ENTRY(GdipDrawPolygonI);
   StackBuffer buffer;

   GpPointF *pointsF = (GpPointF*) buffer.GetBuffer(count*sizeof(GpPointF));

   if(!pointsF) return OutOfMemory;

   for (INT i=0; i<count; i++)
   {
       pointsF[i].X = TOREAL(points[i].X);
       pointsF[i].Y = TOREAL(points[i].Y);
   }

   GpStatus status = GdipDrawPolygon(graphics, pen, pointsF, count);

   return status;
}

GpStatus
WINGDIPAPI
GdipDrawPath(
    GpGraphics *graphics,
    GpPen *pen,
    GpPath *path)
{
    API_ENTRY(GdipDrawPath);
    CheckParameterValid(graphics);
    CheckObjectBusy(graphics);
    CheckParameterValid(pen);
    CheckObjectBusy(pen);
    CheckParameterValid(path);
    CheckObjectBusy(path);


    return graphics->DrawPath(pen, path);
}

GpStatus
WINGDIPAPI
GdipDrawCurve(
    GpGraphics *graphics,
    GpPen *pen,
    GDIPCONST GpPointF *points,
    INT count
    )
{
    API_ENTRY(GdipDrawCurve);
   CheckParameter(points && count > 0);
   CheckParameterValid(graphics);
   CheckObjectBusy(graphics);
   CheckParameterValid(pen);
   CheckObjectBusy(pen);


   return graphics->DrawCurve(pen, points, count);
}

GpStatus
WINGDIPAPI
GdipDrawCurveI(
    GpGraphics *graphics,
    GpPen *pen,
    GDIPCONST GpPoint *points,
    INT count
    )
{
    API_ENTRY(GdipDrawCurveI);
   StackBuffer buffer;

   GpPointF *pointsF = (GpPointF*) buffer.GetBuffer(count*sizeof(GpPointF));

   if(!pointsF) return OutOfMemory;

   for (INT i=0; i<count; i++)
   {
       pointsF[i].X = TOREAL(points[i].X);
       pointsF[i].Y = TOREAL(points[i].Y);
   }

   GpStatus status = GdipDrawCurve(graphics, pen, pointsF, count);

   return status;
}

GpStatus
WINGDIPAPI
GdipDrawCurve2(
    GpGraphics *graphics,
    GpPen *pen,
    GDIPCONST GpPointF *points,
    INT count,
    REAL tension
    )
{
    API_ENTRY(GdipDrawCurve2);
   CheckParameter(points && count > 0);
   CheckParameterValid(graphics);
   CheckObjectBusy(graphics);
   CheckParameterValid(pen);
   CheckObjectBusy(pen);


   return graphics->DrawCurve(pen, points, count, tension, 0, count - 1);
}

GpStatus
WINGDIPAPI
GdipDrawCurve2I(
    GpGraphics *graphics,
    GpPen *pen,
    GDIPCONST GpPoint *points,
    INT count,
    REAL tension
    )
{
    API_ENTRY(GdipDrawCurve2I);
   StackBuffer buffer;

   GpPointF *pointsF = (GpPointF*) buffer.GetBuffer(count*sizeof(GpPointF));

   if(!pointsF) return OutOfMemory;

   for (INT i=0; i<count; i++)
   {
       pointsF[i].X = TOREAL(points[i].X);
       pointsF[i].Y = TOREAL(points[i].Y);
   }

   GpStatus status = GdipDrawCurve2(graphics, pen, pointsF, count, tension);

   return status;
}

GpStatus
WINGDIPAPI
GdipDrawCurve3(
    GpGraphics *graphics,
    GpPen *pen,
    GDIPCONST GpPointF *points,
    INT count,
    INT offset,
    INT numberOfSegments,
    REAL tension
    )
{
    API_ENTRY(GdipDrawCurve3);
   CheckParameter(points && count > 0);
   CheckParameterValid(graphics);
   CheckObjectBusy(graphics);
   CheckParameterValid(pen);
   CheckObjectBusy(pen);


   return graphics->DrawCurve(pen, points, count, tension,
                              offset, numberOfSegments);
}

GpStatus
WINGDIPAPI
GdipDrawCurve3I(
    GpGraphics *graphics,
    GpPen *pen,
    GDIPCONST GpPoint *points,
    INT count,
    INT offset,
    INT numberOfSegments,
    REAL tension
    )
{
    API_ENTRY(GdipDrawCurve3I);
   StackBuffer buffer;

   GpPointF *pointsF = (GpPointF*) buffer.GetBuffer(count*sizeof(GpPointF));

   if(!pointsF) return OutOfMemory;

   for (INT i=0; i<count; i++)
   {
       pointsF[i].X = TOREAL(points[i].X);
       pointsF[i].Y = TOREAL(points[i].Y);
   }

   GpStatus status = GdipDrawCurve3(graphics, pen, pointsF, count,
                                    offset, numberOfSegments, tension);

   return status;
}

GpStatus
WINGDIPAPI
GdipDrawClosedCurve(
    GpGraphics *graphics,
    GpPen *pen,
    GDIPCONST GpPointF *points,
    INT count)
{
    API_ENTRY(GdipDrawClosedCurve);
   CheckParameter(points && count > 0);
   CheckParameterValid(graphics);
   CheckObjectBusy(graphics);
   CheckParameterValid(pen);
   CheckObjectBusy(pen);


   return graphics->DrawClosedCurve(pen, points, count);
}

GpStatus
WINGDIPAPI
GdipDrawClosedCurveI(
    GpGraphics *graphics,
    GpPen *pen,
    GDIPCONST GpPoint *points,
    INT count)
{
    API_ENTRY(GdipDrawClosedCurveI);
   StackBuffer buffer;

   GpPointF *pointsF = (GpPointF*) buffer.GetBuffer(count*sizeof(GpPointF));

   if(!pointsF) return OutOfMemory;

   for (INT i=0; i<count; i++)
   {
       pointsF[i].X = TOREAL(points[i].X);
       pointsF[i].Y = TOREAL(points[i].Y);
   }

   GpStatus status = GdipDrawClosedCurve(graphics, pen, pointsF, count);

   return status;
}

GpStatus
WINGDIPAPI
GdipDrawClosedCurve2(
    GpGraphics *graphics,
    GpPen *pen,
    GDIPCONST GpPointF *points,
    INT count,
    REAL tension)
{
    API_ENTRY(GdipDrawClosedCurve2);
   CheckParameter(points && count > 0);
   CheckParameterValid(graphics);
   CheckObjectBusy(graphics);
   CheckParameterValid(pen);
   CheckObjectBusy(pen);


   return graphics->DrawClosedCurve(pen, points, count, tension);
}

GpStatus
WINGDIPAPI
GdipDrawClosedCurve2I(
    GpGraphics *graphics,
    GpPen *pen,
    GDIPCONST GpPoint *points,
    INT count,
    REAL tension)
{
    API_ENTRY(GdipDrawClosedCurve2I);
   StackBuffer buffer;

   GpPointF *pointsF = (GpPointF*) buffer.GetBuffer(count*sizeof(GpPointF));

   if(!pointsF) return OutOfMemory;

   for (INT i=0; i<count; i++)
   {
       pointsF[i].X = TOREAL(points[i].X);
       pointsF[i].Y = TOREAL(points[i].Y);
   }

   GpStatus status = GdipDrawClosedCurve2(graphics, pen, pointsF, count, tension);

   return status;
}

GpStatus WINGDIPAPI
GdipGraphicsClear(
    GpGraphics *graphics,
    ARGB color)
{
    API_ENTRY(GdipGraphicsClear);
    CheckColorParameter(color);
    CheckParameterValid(graphics);
    CheckObjectBusy(graphics);

    return graphics->Clear(GpColor(color));
}

GpStatus
WINGDIPAPI
GdipFillRectangle(
    GpGraphics *graphics,
    GpBrush *fill,
    REAL x,
    REAL y,
    REAL width,
    REAL height)
{
    API_ENTRY(GdipFillRectangle);
   CheckParameterValid(graphics);
   CheckObjectBusy(graphics);
   CheckParameterValid(fill);
   CheckObjectBusy(fill);


   return graphics->FillRect(fill, x, y, width, height);
}

GpStatus
WINGDIPAPI
GdipFillRectangleI(
    GpGraphics *graphics,
    GpBrush *fill,
    INT x,
    INT y,
    INT width,
    INT height)
{
    API_ENTRY(GdipFillRectangleI);
   return GdipFillRectangle(graphics, fill, TOREAL(x), TOREAL(y), TOREAL(width), TOREAL(height));
}

GpStatus
WINGDIPAPI
GdipFillRectangles(
    GpGraphics *graphics,
    GpBrush *fill,
    GDIPCONST GpRectF *rects,
    INT count)
{
    API_ENTRY(GdipFillRectangles);
   CheckParameter(rects && count > 0);
   CheckParameterValid(graphics);
   CheckObjectBusy(graphics);
   CheckParameterValid(fill);
   CheckObjectBusy(fill);


   return graphics->FillRects(fill, rects, count);
}

GpStatus
WINGDIPAPI
GdipFillRectanglesI(
    GpGraphics *graphics,
    GpBrush *fill,
    GDIPCONST GpRect *rects,
    INT count)
{
    API_ENTRY(GdipFillRectanglesI);
    StackBuffer buffer;

    GpRectF *rectsF = (GpRectF*) buffer.GetBuffer(count*sizeof(GpRectF));

    if(!rectsF) return OutOfMemory;

    for (INT i=0; i<count; i++)
    {
        rectsF[i].X = TOREAL(rects[i].X);
        rectsF[i].Y = TOREAL(rects[i].Y);
        rectsF[i].Width = TOREAL(rects[i].Width);
        rectsF[i].Height = TOREAL(rects[i].Height);
    }

    GpStatus status = GdipFillRectangles(graphics, fill, rectsF, count);

    return status;
}

GpStatus
WINGDIPAPI
GdipFillPolygon(
    GpGraphics *graphics,
    GpBrush *fill,
    GDIPCONST GpPointF *points,
    INT count,
    GpFillMode fillMode
    )
{
    API_ENTRY(GdipFillPolygon);
   CheckParameter(points && count > 0);
   CheckParameterValid(graphics);
   CheckObjectBusy(graphics);
   CheckParameterValid(fill);
   CheckObjectBusy(fill);


   return graphics->FillPolygon(fill, points, count, fillMode);
}

GpStatus
WINGDIPAPI
GdipFillPolygonI(
    GpGraphics *graphics,
    GpBrush *fill,
    GDIPCONST GpPoint *points,
    INT count,
    GpFillMode fillMode
    )
{
    API_ENTRY(GdipFillPolygonI);
   StackBuffer buffer;

   GpPointF *pointsF = (GpPointF*) buffer.GetBuffer(count*sizeof(GpPointF));

   if(!pointsF) return OutOfMemory;

   for (INT i=0; i<count; i++)
   {
       pointsF[i].X = TOREAL(points[i].X);
       pointsF[i].Y = TOREAL(points[i].Y);
   }

   GpStatus status = GdipFillPolygon(graphics, fill, pointsF, count, fillMode);

   return status;
}

GpStatus
WINGDIPAPI
GdipFillPolygon2(
    GpGraphics *graphics,
    GpBrush *fill,
    GDIPCONST GpPointF *points,
    INT count
    )
{
    API_ENTRY(GdipFillPolygon2);
   CheckParameter(points && count > 0);
   CheckParameterValid(graphics);
   CheckObjectBusy(graphics);
   CheckParameterValid(fill);
   CheckObjectBusy(fill);


   return graphics->FillPolygon(fill, points, count);
}

GpStatus
WINGDIPAPI
GdipFillPolygon2I(
    GpGraphics *graphics,
    GpBrush *fill,
    GDIPCONST GpPoint *points,
    INT count
    )
{
    API_ENTRY(GdipFillPolygon2I);
   StackBuffer buffer;

   GpPointF *pointsF = (GpPointF*) buffer.GetBuffer(count*sizeof(GpPointF));

   if(!pointsF) return OutOfMemory;

   for (INT i=0; i<count; i++)
   {
       pointsF[i].X = TOREAL(points[i].X);
       pointsF[i].Y = TOREAL(points[i].Y);
   }

   GpStatus status = GdipFillPolygon2(graphics, fill, pointsF, count);

   return status;
}

GpStatus
WINGDIPAPI
GdipFillEllipse(
    GpGraphics *graphics,
    GpBrush *fill,
    REAL x,
    REAL y,
    REAL width,
    REAL height
    )
{
    API_ENTRY(GdipFillEllipse);
   CheckParameterValid(graphics);
   CheckObjectBusy(graphics);
   CheckParameterValid(fill);
   CheckObjectBusy(fill);


   return graphics->FillEllipse(fill, x, y, width, height);
}

GpStatus
WINGDIPAPI
GdipFillEllipseI(
    GpGraphics *graphics,
    GpBrush *fill,
    INT x,
    INT y,
    INT width,
    INT height
    )
{
    API_ENTRY(GdipFillEllipseI);
   return GdipFillEllipse(graphics, fill, TOREAL(x), TOREAL(y),
                          TOREAL(width), TOREAL(height));
}

GpStatus
WINGDIPAPI
GdipFillPie(
    GpGraphics *graphics,
    GpBrush *fill,
    REAL x,
    REAL y,
    REAL width,
    REAL height,
    REAL startAngle,
    REAL sweepAngle
    )
{
    API_ENTRY(GdipFillPie);
   CheckParameterValid(graphics);
   CheckObjectBusy(graphics);
   CheckParameterValid(fill);
   CheckObjectBusy(fill);


   return graphics->FillPie(fill, x, y, width, height, startAngle, sweepAngle);
}

GpStatus
WINGDIPAPI
GdipFillPieI(
    GpGraphics *graphics,
    GpBrush *fill,
    INT x,
    INT y,
    INT width,
    INT height,
    REAL startAngle,
    REAL sweepAngle
    )
{
    API_ENTRY(GdipFillPieI);
   return GdipFillPie(graphics, fill, TOREAL(x), TOREAL(y),
                      TOREAL(width), TOREAL(height), startAngle, sweepAngle);
}

GpStatus
WINGDIPAPI
GdipFillPath(
    GpGraphics *graphics,
    GpBrush *fill,
    GpPath *path
    )
{
    API_ENTRY(GdipFillPath);
   CheckParameterValid(graphics);
   CheckObjectBusy(graphics);
   CheckParameterValid(fill);
   CheckObjectBusy(fill);
   CheckParameterValid(path);
   CheckObjectBusy(path);


   return graphics->FillPath(fill, path);
}

GpStatus
WINGDIPAPI
GdipFillClosedCurve(
    GpGraphics *graphics,
    GpBrush *fill,
    GDIPCONST GpPointF *points,
    INT count
    )
{
    API_ENTRY(GdipFillClosedCurve);
   CheckParameter(points && count > 0);
   CheckParameterValid(graphics);
   CheckObjectBusy(graphics);
   CheckParameterValid(fill);
   CheckObjectBusy(fill);


   return graphics->FillClosedCurve(fill, points, count);
}

GpStatus
WINGDIPAPI
GdipFillClosedCurveI(
    GpGraphics *graphics,
    GpBrush *fill,
    GDIPCONST GpPoint *points,
    INT count
    )
{
    API_ENTRY(GdipFillClosedCurveI);
   StackBuffer buffer;

   GpPointF *pointsF = (GpPointF*) buffer.GetBuffer(count*sizeof(GpPointF));

   if(!pointsF) return OutOfMemory;

   for (INT i=0; i<count; i++)
   {
       pointsF[i].X = TOREAL(points[i].X);
       pointsF[i].Y = TOREAL(points[i].Y);
   }

   GpStatus status = GdipFillClosedCurve(graphics, fill, pointsF, count);

   return status;
}

GpStatus
WINGDIPAPI
GdipFillClosedCurve2(
    GpGraphics *graphics,
    GpBrush *fill,
    GDIPCONST GpPointF *points,
    INT count,
    REAL tension,
    GpFillMode fillMode
    )
{
    API_ENTRY(GdipFillClosedCurve2);
   CheckParameter(points && count > 0);
   CheckParameterValid(graphics);
   CheckObjectBusy(graphics);
   CheckParameterValid(fill);
   CheckObjectBusy(fill);


   return graphics->FillClosedCurve(fill, points, count, tension, fillMode);
}


GpStatus
WINGDIPAPI
GdipFillClosedCurve2I(
    GpGraphics *graphics,
    GpBrush *fill,
    GDIPCONST GpPoint *points,
    INT count,
    REAL tension,
    GpFillMode fillMode
    )
{
    API_ENTRY(GdipFillClosedCurve2I);
   StackBuffer buffer;

   GpPointF *pointsF = (GpPointF*) buffer.GetBuffer(count*sizeof(GpPointF));

   if(!pointsF) return OutOfMemory;

   for (INT i=0; i<count; i++)
   {
       pointsF[i].X = TOREAL(points[i].X);
       pointsF[i].Y = TOREAL(points[i].Y);
   }

   GpStatus status = GdipFillClosedCurve2(graphics, fill, pointsF, count, tension, fillMode);

   return status;
}

GpStatus
WINGDIPAPI
GdipFillRegion(
    GpGraphics *graphics,
    GpBrush *fill,
    GpRegion *region
    )
{
    API_ENTRY(GdipFillRegion);
   CheckParameterValid(graphics);
   CheckObjectBusy(graphics);
   CheckParameterValid(fill);
   CheckObjectBusy(fill);
   CheckParameterValid(region);
   CheckObjectBusy(region);


   return graphics->FillRegion(fill, region);
}

GpStatus
WINGDIPAPI
GdipDrawString(
    GpGraphics               *graphics,
    GDIPCONST WCHAR          *string,
    INT                      length,
    GDIPCONST GpFont         *font,
    GDIPCONST RectF          *layoutRect,
    GDIPCONST GpStringFormat *stringFormat,
    GDIPCONST GpBrush        *brush
)
{
    API_ENTRY(GdipDrawString);
    CheckParameter(string && layoutRect);
    CheckParameterValid(graphics);
    CheckObjectBusy(graphics);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    if (EmptyString(string, length))
    {
        return Ok;
    }


    GlobalTextLock lock;

    CheckParameterValid(font);
    CheckOptionalParameterValid(stringFormat);

    return graphics->DrawString(
        string,
        length,
        font,
        layoutRect,
        stringFormat,
        brush);
}

GpStatus
WINGDIPAPI
GdipMeasureString(
    GpGraphics               *graphics,
    GDIPCONST WCHAR          *string,
    INT                       length,
    GDIPCONST GpFont         *font,
    GDIPCONST RectF          *layoutRect,
    GDIPCONST GpStringFormat *stringFormat,
    RectF                    *boundingBox,
    INT                      *codepointsFitted,   // Optional parameter
    INT                      *linesFilled         // Optional parameter
)
{
    API_ENTRY(GdipMeasureString);
    CheckParameter(string && layoutRect && boundingBox);
    CheckParameterValid(graphics);
    CheckObjectBusy(graphics);

    if (EmptyString(string, length))
    {
        SetEmptyRectF(boundingBox);
        if (codepointsFitted)
            *codepointsFitted = 0;
        if (linesFilled)
            *linesFilled = 0;
        return Ok;
    }


    GlobalTextLock lock;

    CheckParameterValid(font);
    CheckOptionalParameterValid(stringFormat);

    return graphics->MeasureString(
        string,
        length,
        font,
        layoutRect,
        stringFormat,
        boundingBox,
        codepointsFitted,
        linesFilled
    );
}

GpStatus
WINGDIPAPI
GdipMeasureCharacterRanges(
    GpGraphics               *graphics,
    GDIPCONST WCHAR          *string,
    INT                       length,
    GDIPCONST GpFont         *font,
    GDIPCONST RectF          &layoutRect,
    GDIPCONST GpStringFormat *stringFormat,
    INT                       regionCount,
    GpRegion                **regions
)
{
    API_ENTRY(GdipMeasureCharacterRanges);
    CheckParameter(string && (&layoutRect));
    CheckParameterValid(graphics);
    CheckObjectBusy(graphics);
    CheckParameterValid(font);
    CheckOptionalParameterValid(stringFormat);
    CheckParameter(regions);

    if (EmptyString(string, length))
    {
        return InvalidParameter;
    }


    GlobalTextLock lock;

    GpStatus status = graphics->MeasureCharacterRanges(
        string,
        length,
        font,
        layoutRect,
        stringFormat,
        regionCount,
        regions
    );

    return status;
}


GpStatus
WINGDIPAPI
GdipDrawDriverString(
    GpGraphics *graphics,
    GDIPCONST UINT16 *text,
    INT length,
    GDIPCONST GpFont *font,
    GDIPCONST GpBrush *brush,
    GDIPCONST PointF *positions,
    INT flags,
    GDIPCONST GpMatrix *matrix
)
{
    API_ENTRY(GdipDrawDriverString);
    CheckParameterValid(graphics);
    CheckObjectBusy(graphics);
    CheckOptionalParameterValid(matrix);
    CheckOptionalObjectBusy(matrix);
    CheckParameterValid(brush);
    CheckObjectBusy(brush);

    CheckParameter(text && positions);

    if (length == -1 && !(flags & DriverStringOptionsCmapLookup))
    {
        return InvalidParameter;
    }
    if (EmptyString(text, length))
    {
        return Ok;
    }


    GlobalTextLock lock;

    CheckParameterValid(font);

    return graphics->DrawDriverString(
        text,
        length,
        font,
        brush,
        positions,
        flags,
        matrix
    );
}

GpStatus
WINGDIPAPI
GdipMeasureDriverString(
    GpGraphics *graphics,
    GDIPCONST UINT16 *text,
    INT length,
    GDIPCONST GpFont *font,
    GDIPCONST PointF *positions,
    INT flags,
    GDIPCONST GpMatrix *matrix,
    RectF *boundingBox
)
{
    API_ENTRY(GdipMeasureDriverString);
    GpStatus status;
    CheckParameterValid(graphics);
    CheckObjectBusy(graphics);
    CheckOptionalParameterValid(matrix);
    CheckOptionalObjectBusy(matrix);

    CheckParameter(text && positions && boundingBox);

    if (length == -1 && !(flags & DriverStringOptionsCmapLookup))
    {
        return InvalidParameter;
    }

    if (EmptyString(text, length))
    {
        SetEmptyRectF(boundingBox);
        return Ok;
    }


    GlobalTextLock lock;

    CheckParameterValid(font);

    return graphics->MeasureDriverString(
        text,
        length,
        font,
        positions,
        flags,
        matrix,
        boundingBox
    );
}

GpStatus
WINGDIPAPI
GdipGetFamilyName(
    GDIPCONST GpFontFamily *family,
    WCHAR                   name[LF_FACESIZE],
    LANGID                  language
)
{
    API_ENTRY(GdipGetFamilyName);

    GlobalTextLock lock;

    CheckParameterValid(family);

    return family->GetFamilyName(name, language);
}

/// end font/text stuff - move to end



GpStatus
WINGDIPAPI
GdipDrawImage(
    GpGraphics *graphics,
    GpImage *image,
    REAL x,
    REAL y
    )
{
    API_ENTRY(GdipDrawImage);
   CheckParameterValid(graphics);
   CheckObjectBusy(graphics);
   CheckParameterValid(image);
   CheckObjectBusy(image);


   return graphics->DrawImage(image, x, y);
}


GpStatus
WINGDIPAPI
GdipDrawImageI(
    GpGraphics *graphics,
    GpImage *image,
    INT x,
    INT y
    )
{
    API_ENTRY(GdipDrawImageI);
   return GdipDrawImage(graphics, image, TOREAL(x), TOREAL(y));
}

GpStatus
WINGDIPAPI
GdipDrawImageRect(
    GpGraphics *graphics,
    GpImage *image,
    REAL x,
    REAL y,
    REAL width,
    REAL height
    )
{
    API_ENTRY(GdipDrawImageRect);
   CheckParameterValid(graphics);
   CheckObjectBusy(graphics);
   CheckParameterValid(image);
   CheckObjectBusy(image);


   return graphics->DrawImage(image, x, y, width, height);
}


GpStatus
WINGDIPAPI
GdipDrawImageRectI(
    GpGraphics *graphics,
    GpImage *image,
    INT x,
    INT y,
    INT width,
    INT height
    )
{
    API_ENTRY(GdipDrawImageRectI);
   return GdipDrawImageRect(graphics, image, TOREAL(x), TOREAL(y), TOREAL(width), TOREAL(height));
}

GpStatus
WINGDIPAPI
GdipDrawImagePoints(
    GpGraphics *graphics,
    GpImage *image,
    GDIPCONST GpPointF *points,
    INT count
    )
{
    API_ENTRY(GdipDrawImagePoints);
   CheckParameter(points && count > 0);
   CheckParameterValid(graphics);
   CheckObjectBusy(graphics);
   CheckParameterValid(image);
   CheckObjectBusy(image);


   return graphics->DrawImage(image, points, count);
}

GpStatus
WINGDIPAPI
GdipDrawImagePointsI(
    GpGraphics *graphics,
    GpImage *image,
    GDIPCONST GpPoint *points,
    INT count
    )
{
    API_ENTRY(GdipDrawImagePointsI);
    CheckParameter(points && count > 0);

    StackBuffer buffer;

    GpPointF *pointsF = (GpPointF*) buffer.GetBuffer(count*sizeof(GpPointF));

    if(!pointsF) return OutOfMemory;

    for (INT i=0; i<count; i++)
    {
        pointsF[i].X = TOREAL(points[i].X);
        pointsF[i].Y = TOREAL(points[i].Y);
    } 

    GpStatus status = GdipDrawImagePoints(graphics, image, pointsF, count);

    return status;
}

GpStatus
WINGDIPAPI
GdipDrawImagePointRect(
    GpGraphics *graphics,
    GpImage *image,
    REAL x,
    REAL y,
    REAL srcx,
    REAL srcy,
    REAL srcwidth,
    REAL srcheight,
    GpPageUnit srcUnit
    )
{
    API_ENTRY(GdipDrawImagePointRect);
    CheckParameterValid(graphics);
    CheckObjectBusy(graphics);
    CheckParameterValid(image);
    CheckObjectBusy(image);
    CheckParameter(SrcUnitIsValid((Unit)srcUnit));
    
    // This additional check is required because we don't support the other 
    // source units in drawimage yet. RAID 311474
    
    if(UnitPixel != srcUnit)
    {
        return NotImplemented;
    }

    GpRectF srcRect(srcx, srcy, srcwidth, srcheight);


    return graphics->DrawImage(image, x, y, srcRect, srcUnit);
}

GpStatus
WINGDIPAPI
GdipDrawImagePointRectI(
    GpGraphics *graphics,
    GpImage *image,
    INT x,
    INT y,
    INT srcx,
    INT srcy,
    INT srcwidth,
    INT srcheight,
    GpPageUnit srcUnit
    )
{
    API_ENTRY(GdipDrawImagePointRectI);
   return GdipDrawImagePointRect(graphics, image, TOREAL(x), TOREAL(y), TOREAL(srcx),
                                 TOREAL(srcy), TOREAL(srcwidth), TOREAL(srcheight),
                                 srcUnit);
}

GpStatus
WINGDIPAPI
GdipDrawImageRectRect(
    GpGraphics *graphics,
    GpImage *image,
    REAL dstx,
    REAL dsty,
    REAL dstwidth,
    REAL dstheight,
    REAL srcx,
    REAL srcy,
    REAL srcwidth,
    REAL srcheight,
    GpPageUnit srcUnit,
    GDIPCONST GpImageAttributes* imageAttributes,
    DrawImageAbort callback,
    VOID * callbackData
    )
{
    API_ENTRY(GdipDrawImageRectRect);
    CheckParameterValid(graphics);
    CheckObjectBusy(graphics);
    CheckParameterValid(image);
    CheckObjectBusy(image);
    CheckParameter(SrcUnitIsValid((Unit)srcUnit));
    
    // This additional check is required because we don't support the other 
    // source units in drawimage yet. RAID 311474
    
    if(UnitPixel != srcUnit)
    {
        return NotImplemented;
    }
    
    CheckOptionalParameterValid(imageAttributes);
    CheckOptionalObjectBusy(imageAttributes);

    GpRectF srcrect(srcx, srcy, srcwidth, srcheight);
    GpRectF destrect(dstx, dsty, dstwidth, dstheight);


    return graphics->DrawImage(image, destrect, srcrect, srcUnit,
                               imageAttributes, callback, callbackData);
}

GpStatus
WINGDIPAPI
GdipDrawImageRectRectI(
    GpGraphics *graphics,
    GpImage *image,
    INT dstx,
    INT dsty,
    INT dstwidth,
    INT dstheight,
    INT srcx,
    INT srcy,
    INT srcwidth,
    INT srcheight,
    GpPageUnit srcUnit,
    GDIPCONST GpImageAttributes* imageAttributes,
    DrawImageAbort callback,
    VOID * callbackData
    )
{
    API_ENTRY(GdipDrawImageRectRectI);
   return GdipDrawImageRectRect(graphics, image, TOREAL(dstx), TOREAL(dsty),
                                TOREAL(dstwidth), TOREAL(dstheight),
                                TOREAL(srcx), TOREAL(srcy), TOREAL(srcwidth),
                                TOREAL(srcheight), srcUnit,
                                imageAttributes, callback, callbackData);
}

GpStatus
WINGDIPAPI
GdipDrawImagePointsRect(
    GpGraphics *graphics,
    GpImage *image,
    GDIPCONST GpPointF *points,
    INT count,
    REAL srcx,
    REAL srcy,
    REAL srcwidth,
    REAL srcheight,
    GpPageUnit srcUnit,
    GDIPCONST GpImageAttributes* imageAttributes,
    DrawImageAbort callback,
    VOID * callbackData
    )
{
    API_ENTRY(GdipDrawImagePointsRect);
    CheckParameter(points && count > 0);
    CheckParameterValid(graphics);
    CheckObjectBusy(graphics);
    CheckParameterValid(image);
    CheckObjectBusy(image);
    CheckParameter(SrcUnitIsValid((Unit)srcUnit));
    
    // This additional check is required because we don't support the other 
    // source units in drawimage yet. RAID 311474
    
    if(UnitPixel != srcUnit)
    {
        return NotImplemented;
    }
    
    CheckOptionalParameterValid(imageAttributes);
    CheckOptionalObjectBusy(imageAttributes);

    GpRectF srcrect(srcx, srcy, srcwidth, srcheight);


    return graphics->DrawImage(image, points, count, srcrect, srcUnit,
                               imageAttributes, callback, callbackData);
}

GpStatus
WINGDIPAPI
GdipDrawImagePointsRectI(
    GpGraphics *graphics,
    GpImage *image,
    GDIPCONST GpPoint *points,
    INT count,
    INT srcx,
    INT srcy,
    INT srcwidth,
    INT srcheight,
    GpPageUnit srcUnit,
    GDIPCONST GpImageAttributes* imageAttributes,
    DrawImageAbort callback,
    VOID * callbackData
    )
{
    API_ENTRY(GdipDrawImagePointsRectI);
    CheckParameter(points && count > 0);
   
    StackBuffer buffer;

    GpPointF *pointsF = (GpPointF*) buffer.GetBuffer(count*sizeof(GpPointF));

    if(!pointsF) return OutOfMemory;

    for (INT i=0; i<count; i++)
    {
        pointsF[i].X = TOREAL(points[i].X);
        pointsF[i].Y = TOREAL(points[i].Y);
    }

    GpStatus status = GdipDrawImagePointsRect(
        graphics, 
        image, 
        pointsF, 
        count,
        TOREAL(srcx), 
        TOREAL(srcy), 
        TOREAL(srcwidth),
        TOREAL(srcheight), 
        srcUnit,
        imageAttributes, 
        callback, 
        callbackData
    );

    return status;
}

GpStatus WINGDIPAPI
GdipEnumerateMetafileDestPoint(
    GpGraphics *            graphics,
    GDIPCONST GpMetafile *  metafile,
    GDIPCONST PointF &      destPoint,
    EnumerateMetafileProc   callback,
    VOID *                  callbackData,
    GDIPCONST GpImageAttributes *     imageAttributes
    )
{
    API_ENTRY(GdipEnumerateMetafileDestPoint);
    CheckParameter(callback);
    CheckParameterValid(graphics);
    CheckObjectBusy(graphics);
    CheckParameterValid(metafile);
    CheckObjectBusy(metafile);
    CheckOptionalParameterValid(imageAttributes);
    CheckOptionalObjectBusy(imageAttributes);


    // Only the current thread can play back records from this enumeration
    metafile->SetThreadId(GetCurrentThreadId());
    return graphics->EnumerateMetafile(
                        metafile,
                        destPoint,
                        callback,
                        callbackData,
                        imageAttributes
                        );
    metafile->SetThreadId(0);
}

GpStatus WINGDIPAPI
GdipEnumerateMetafileDestPointI(
    GpGraphics *            graphics,
    GDIPCONST GpMetafile *  metafile,
    GDIPCONST Point &       destPoint,
    EnumerateMetafileProc   callback,
    VOID *                  callbackData,
    GDIPCONST GpImageAttributes *     imageAttributes
    )
{
    API_ENTRY(GdipEnumerateMetafileDestPointI);
    GpPointF    destPointF(TOREAL(destPoint.X), TOREAL(destPoint.Y));

    return GdipEnumerateMetafileDestPoint(
                graphics,
                metafile,
                destPointF,
                callback,
                callbackData,
                imageAttributes
                );
}

GpStatus WINGDIPAPI
GdipEnumerateMetafileDestRect(
    GpGraphics *            graphics,
    GDIPCONST GpMetafile *  metafile,
    GDIPCONST RectF &       destRect,
    EnumerateMetafileProc   callback,
    VOID *                  callbackData,
    GDIPCONST GpImageAttributes *     imageAttributes
    )
{
    API_ENTRY(GdipEnumerateMetafileDestRect);
    CheckParameter(callback);
    CheckParameterValid(graphics);
    CheckObjectBusy(graphics);
    CheckParameterValid(metafile);
    CheckObjectBusy(metafile);
    CheckOptionalParameterValid(imageAttributes);
    CheckOptionalObjectBusy(imageAttributes);


    // Only the current thread can play back records from this enumeration
    metafile->SetThreadId(GetCurrentThreadId());
    return graphics->EnumerateMetafile(
                        metafile,
                        destRect,
                        callback,
                        callbackData,
                        imageAttributes
                        );
    metafile->SetThreadId(0);
}

GpStatus WINGDIPAPI
GdipEnumerateMetafileDestRectI(
    GpGraphics *            graphics,
    GDIPCONST GpMetafile *  metafile,
    GDIPCONST Rect &        destRect,
    EnumerateMetafileProc   callback,
    VOID *                  callbackData,
    GDIPCONST GpImageAttributes *     imageAttributes
    )
{
    API_ENTRY(GdipEnumerateMetafileDestRectI);
    GpRectF     destRectF(TOREAL(destRect.X), TOREAL(destRect.Y),
                          TOREAL(destRect.Width), TOREAL(destRect.Height));

    return GdipEnumerateMetafileDestRect(
                graphics,
                metafile,
                destRectF,
                callback,
                callbackData,
                imageAttributes
                );
}

GpStatus WINGDIPAPI
GdipEnumerateMetafileDestPoints(
    GpGraphics *            graphics,
    GDIPCONST GpMetafile *  metafile,
    GDIPCONST PointF *      destPoints,
    INT                     count,
    EnumerateMetafileProc   callback,
    VOID *                  callbackData,
    GDIPCONST GpImageAttributes *     imageAttributes
    )
{
    API_ENTRY(GdipEnumerateMetafileDestPoints);
    CheckParameter(callback);
    CheckParameterValid(graphics);
    CheckObjectBusy(graphics);
    CheckParameterValid(metafile);
    CheckObjectBusy(metafile);
    CheckOptionalParameterValid(imageAttributes);
    CheckOptionalObjectBusy(imageAttributes);


    // Only the current thread can play back records from this enumeration
    metafile->SetThreadId(GetCurrentThreadId());
    return graphics->EnumerateMetafile(
                        metafile,
                        destPoints,
                        count,
                        callback,
                        callbackData,
                        imageAttributes
                        );
    metafile->SetThreadId(0);
}

GpStatus WINGDIPAPI
GdipEnumerateMetafileDestPointsI(
    GpGraphics *            graphics,
    GDIPCONST GpMetafile *      metafile,
    GDIPCONST Point *           destPoints,
    INT                     count,
    EnumerateMetafileProc   callback,
    VOID *                  callbackData,
    GDIPCONST GpImageAttributes *     imageAttributes
    )
{
    API_ENTRY(GdipEnumerateMetafileDestPointsI);
    CheckParameter(destPoints && (count > 0));

    StackBuffer buffer;

    GpPointF *destPointsF = (GpPointF*) buffer.GetBuffer(count*sizeof(GpPointF));

    if(!destPointsF) return OutOfMemory;

    for (INT i = 0; i < count; i++)
    {
        destPointsF[i].X = TOREAL(destPoints[i].X);
        destPointsF[i].Y = TOREAL(destPoints[i].Y);
    }

    return GdipEnumerateMetafileDestPoints(
                graphics,
                metafile,
                destPointsF,
                count,
                callback,
                callbackData,
                imageAttributes
                );
}

GpStatus WINGDIPAPI
GdipEnumerateMetafileSrcRectDestPoint(
    GpGraphics *            graphics,
    GDIPCONST GpMetafile *  metafile,
    GDIPCONST PointF &      destPoint,
    GDIPCONST RectF &       srcRect,
    Unit                    srcUnit,
    EnumerateMetafileProc   callback,
    VOID *                  callbackData,
    GDIPCONST GpImageAttributes *     imageAttributes
    )
{
    API_ENTRY(GdipEnumerateMetafileSrcRectDestPoint);
    CheckParameter(callback);
    CheckParameterValid(graphics);
    CheckObjectBusy(graphics);
    CheckParameterValid(metafile);
    CheckObjectBusy(metafile);
    CheckParameter(SrcUnitIsValid((Unit)srcUnit));
    CheckOptionalParameterValid(imageAttributes);
    CheckOptionalObjectBusy(imageAttributes);


    // Only the current thread can play back records from this enumeration
    metafile->SetThreadId(GetCurrentThreadId());
    return graphics->EnumerateMetafile(
                        metafile,
                        destPoint,
                        srcRect,
                        srcUnit,
                        callback,
                        callbackData,
                        imageAttributes
                        );
    metafile->SetThreadId(0);
}

GpStatus WINGDIPAPI
GdipEnumerateMetafileSrcRectDestPointI(
    GpGraphics *            graphics,
    GDIPCONST GpMetafile *  metafile,
    GDIPCONST Point &       destPoint,
    GDIPCONST Rect &        srcRect,
    Unit                    srcUnit,
    EnumerateMetafileProc   callback,
    VOID *                  callbackData,
    GDIPCONST GpImageAttributes *     imageAttributes
    )
{
    API_ENTRY(GdipEnumerateMetafileSrcRectDestPointI);
    GpPointF    destPointF(TOREAL(destPoint.X), TOREAL(destPoint.Y));
    GpRectF     srcRectF(TOREAL(srcRect.X), TOREAL(srcRect.Y),
                         TOREAL(srcRect.Width), TOREAL(srcRect.Height));

    return GdipEnumerateMetafileSrcRectDestPoint(
                graphics,
                metafile,
                destPointF,
                srcRectF,
                srcUnit,
                callback,
                callbackData,
                imageAttributes
                );
}

GpStatus WINGDIPAPI
GdipEnumerateMetafileSrcRectDestRect(
    GpGraphics *            graphics,
    GDIPCONST GpMetafile *  metafile,
    GDIPCONST RectF &       destRect,
    GDIPCONST RectF &       srcRect,
    Unit                    srcUnit,
    EnumerateMetafileProc   callback,
    VOID *                  callbackData,
    GDIPCONST GpImageAttributes *     imageAttributes
    )
{
    API_ENTRY(GdipEnumerateMetafileSrcRectDestRect);
    CheckParameter(callback);
    CheckParameterValid(graphics);
    CheckObjectBusy(graphics);
    CheckParameterValid(metafile);
    CheckObjectBusy(metafile);
    CheckParameter(SrcUnitIsValid((Unit)srcUnit));
    CheckOptionalParameterValid(imageAttributes);
    CheckOptionalObjectBusy(imageAttributes);


    // Only the current thread can play back records from this enumeration
    metafile->SetThreadId(GetCurrentThreadId());
    return graphics->EnumerateMetafile(
                        metafile,
                        destRect,
                        srcRect,
                        srcUnit,
                        callback,
                        callbackData,
                        imageAttributes
                        );
    metafile->SetThreadId(0);
}

GpStatus WINGDIPAPI
GdipEnumerateMetafileSrcRectDestRectI(
    GpGraphics *            graphics,
    GDIPCONST GpMetafile *  metafile,
    GDIPCONST Rect &        destRect,
    GDIPCONST Rect &        srcRect,
    Unit                    srcUnit,
    EnumerateMetafileProc   callback,
    VOID *                  callbackData,
    GDIPCONST GpImageAttributes *     imageAttributes
    )
{
    API_ENTRY(GdipEnumerateMetafileSrcRectDestRectI);
    GpRectF     destRectF(TOREAL(destRect.X), TOREAL(destRect.Y),
                          TOREAL(destRect.Width), TOREAL(destRect.Height));
    GpRectF     srcRectF(TOREAL(srcRect.X), TOREAL(srcRect.Y),
                         TOREAL(srcRect.Width), TOREAL(srcRect.Height));

    return GdipEnumerateMetafileSrcRectDestRect(
                graphics,
                metafile,
                destRectF,
                srcRectF,
                srcUnit,
                callback,
                callbackData,
                imageAttributes
                );
}

GpStatus WINGDIPAPI
GdipEnumerateMetafileSrcRectDestPoints(
    GpGraphics *            graphics,
    GDIPCONST GpMetafile *  metafile,
    GDIPCONST PointF *      destPoints,
    INT                     count,
    GDIPCONST RectF &       srcRect,
    Unit                    srcUnit,
    EnumerateMetafileProc   callback,
    VOID *                  callbackData,
    GDIPCONST GpImageAttributes *     imageAttributes
    )
{
    API_ENTRY(GdipEnumerateMetafileSrcRectDestPoints);
    CheckParameter(callback);
    CheckParameterValid(graphics);
    CheckObjectBusy(graphics);
    CheckParameterValid(metafile);
    CheckObjectBusy(metafile);
    CheckParameter(SrcUnitIsValid((Unit)srcUnit));
    CheckOptionalParameterValid(imageAttributes);
    CheckOptionalObjectBusy(imageAttributes);


    // Only the current thread can play back records from this enumeration
    metafile->SetThreadId(GetCurrentThreadId());
    return graphics->EnumerateMetafile(
                        metafile,
                        destPoints,
                        count,
                        srcRect,
                        srcUnit,
                        callback,
                        callbackData,
                        imageAttributes
                        );
    metafile->SetThreadId(0);
}

GpStatus WINGDIPAPI
GdipEnumerateMetafileSrcRectDestPointsI(
    GpGraphics *            graphics,
    GDIPCONST GpMetafile *  metafile,
    GDIPCONST Point *       destPoints,
    INT                     count,
    GDIPCONST Rect &        srcRect,
    Unit                    srcUnit,
    EnumerateMetafileProc   callback,
    VOID *                  callbackData,
    GDIPCONST GpImageAttributes *     imageAttributes
    )
{
    API_ENTRY(GdipEnumerateMetafileSrcRectDestPointsI);
    CheckParameter(destPoints && (count > 0));

    GpRectF     srcRectF(TOREAL(srcRect.X), TOREAL(srcRect.Y),
                         TOREAL(srcRect.Width), TOREAL(srcRect.Height));

    StackBuffer buffer;

    GpPointF *destPointsF = (GpPointF*) buffer.GetBuffer(count*sizeof(GpPointF));

    if(!destPointsF) return OutOfMemory;

    for (INT i = 0; i < count; i++)
    {
        destPointsF[i].X = TOREAL(destPoints[i].X);
        destPointsF[i].Y = TOREAL(destPoints[i].Y);
    }

    return GdipEnumerateMetafileSrcRectDestPoints(
                graphics,
                metafile,
                destPointsF,
                count,
                srcRectF,
                srcUnit,
                callback,
                callbackData,
                imageAttributes
                );
}

GpStatus
WINGDIPAPI
GdipPlayMetafileRecord(
    GDIPCONST GpMetafile *  metafile,
    EmfPlusRecordType       recordType,
    UINT                    flags,
    UINT                    dataSize,
    GDIPCONST BYTE *        data
    )
{
    API_ENTRY(GdipPlayMetafileRecord);
    CheckParameterValid(metafile);
    CheckParameter(recordType);

    // The metafile must be already locked by the enumerator
    GpLock lockMetafile (metafile->GetObjectLock());
    if (lockMetafile.IsValid())
    {
        return InvalidParameter;
    }

    // Only the current thread can play back records from this enumeration
    if (GetCurrentThreadId() != metafile->GetThreadId())
    {
        return ObjectBusy;
    }


    return metafile->PlayRecord(recordType, flags, dataSize, data);
}

GpStatus
WINGDIPAPI
GdipSetClipGraphics(
    GpGraphics *    graphics,
    GpGraphics *    srcgraphics,
    CombineMode     combineMode
    )
{
    API_ENTRY(GdipSetClipGraphics);
    CheckParameterValid(graphics);
    CheckObjectBusy(graphics);
    CheckParameterValid(srcgraphics);
    CheckObjectBusy(srcgraphics);
    CheckParameter(CombineModeIsValid(combineMode));


    return graphics->SetClip(srcgraphics, combineMode);
}

GpStatus
WINGDIPAPI
GdipSetClipRect(
    GpGraphics *    graphics,
    REAL            x,
    REAL            y,
    REAL            width,
    REAL            height,
    CombineMode     combineMode
    )
{
    API_ENTRY(GdipSetClipRect);
    CheckParameterValid(graphics);
    CheckObjectBusy(graphics);
    CheckParameter(CombineModeIsValid(combineMode));

    GpRectF rect(x, y, width, height);


    return graphics->SetClip(rect, combineMode);
}

GpStatus
WINGDIPAPI
GdipSetClipRectI(
    GpGraphics *    graphics,
    INT             x,
    INT             y,
    INT             width,
    INT             height,
    CombineMode     combineMode
    )
{
    API_ENTRY(GdipSetClipRectI);
    return GdipSetClipRect(graphics, TOREAL(x), TOREAL(y),
                           TOREAL(width), TOREAL(height), combineMode);
}

GpStatus
WINGDIPAPI
GdipSetClipPath(
    GpGraphics *    graphics,
    GpPath *        path,
    CombineMode     combineMode
    )
{
    API_ENTRY(GdipSetClipPath);
    CheckParameterValid(graphics);
    CheckObjectBusy(graphics);
    CheckParameterValid(path);
    CheckObjectBusy(path);
    CheckParameter(CombineModeIsValid(combineMode));


    return graphics->SetClip(path, combineMode);
}

GpStatus
WINGDIPAPI
GdipSetClipRegion(
    GpGraphics *    graphics,
    GpRegion *      region,
    CombineMode     combineMode
    )
{
    API_ENTRY(GdipSetClipRegion);
    CheckParameterValid(graphics);
    CheckObjectBusy(graphics);
    CheckParameterValid(region);
    CheckObjectBusy(region);
    CheckParameter(CombineModeIsValid(combineMode));


    return graphics->SetClip(region, combineMode);
}

GpStatus
WINGDIPAPI
GdipSetClipHrgn(
    GpGraphics *    graphics,
    HRGN            hRgn,
    CombineMode     combineMode
    )
{
    API_ENTRY(GdipSetClipHrgn);
    CheckParameterValid(graphics);
    CheckObjectBusy(graphics);
    CheckParameter(hRgn && (GetObjectTypeInternal(hRgn) == OBJ_REGION));
    CheckParameter(CombineModeIsValid(combineMode));


    return graphics->SetClip(hRgn, combineMode);
}

GpStatus
WINGDIPAPI
GdipResetClip(
    GpGraphics *graphics
    )
{
    API_ENTRY(GdipResetClip);
    CheckParameterValid(graphics);
    CheckObjectBusy(graphics);

    return graphics->ResetClip();
}

GpStatus
WINGDIPAPI
GdipTranslateClip(
    GpGraphics *graphics,
    REAL dx,
    REAL dy
    )
{
    API_ENTRY(GdipTranslateClip);
    CheckParameterValid(graphics);
    CheckObjectBusy(graphics);


    return graphics->OffsetClip(dx, dy);
}

GpStatus
WINGDIPAPI
GdipTranslateClipI(
    GpGraphics *graphics,
    INT dx,
    INT dy
    )
{
    API_ENTRY(GdipTranslateClipI);
    return GdipTranslateClip(graphics, TOREAL(dx), TOREAL(dy));
}

GpStatus
WINGDIPAPI
GdipGetClip(
    GpGraphics *graphics,
    GpRegion *region
    )
{
    API_ENTRY(GdipGetClip);
    CheckParameter(region);
    CheckObjectBusy(region);
    CheckParameterValid(graphics);
    CheckObjectBusy(graphics);

    return graphics->GetClip(region);
}

GpStatus
WINGDIPAPI
GdipGetClipBounds(
    GpGraphics *graphics,
    GpRectF *rect
    )
{
    API_ENTRY(GdipGetClipBounds);
    CheckParameter(rect);
    CheckParameterValid(graphics);
    CheckObjectBusy(graphics);

    graphics->GetClipBounds(*rect);

    return Ok;
}

GpStatus
WINGDIPAPI
GdipGetClipBoundsI(
    GpGraphics *graphics,
    GpRect *rect
    )
{
    API_ENTRY(GdipGetClipBoundsI);
    CheckParameter(rect);
    CheckParameterValid(graphics);
    CheckObjectBusy(graphics);

    RectF rectf;

    graphics->GetClipBounds(rectf);

    rect->X = GpRound(rectf.X);
    rect->Y = GpRound(rectf.Y);
    rect->Width = GpRound(rectf.Width);
    rect->Height = GpRound(rectf.Height);

    return Ok;
}

GpStatus
WINGDIPAPI
GdipIsClipEmpty(
    GpGraphics *graphics,
    BOOL *result
    )
{
    API_ENTRY(GdipIsClipEmpty);
    CheckParameter(result);
    CheckParameterValid(graphics);
    CheckObjectBusy(graphics);

    *result = graphics->IsClipEmpty();

    return Ok;
}

GpStatus
WINGDIPAPI
GdipGetVisibleClipBounds(
    GpGraphics *graphics,
    GpRectF *rect
    )
{
    API_ENTRY(GdipGetVisibleClipBounds);
    CheckParameter(rect);
    CheckParameterValid(graphics);
    CheckObjectBusy(graphics);

    graphics->GetVisibleClipBounds(*rect);

    return Ok;
}

GpStatus
WINGDIPAPI
GdipGetVisibleClipBoundsI(
    GpGraphics *graphics,
    GpRect *rect
    )
{
    API_ENTRY(GdipGetVisibleClipBoundsI);
    CheckParameter(rect);
    CheckParameterValid(graphics);
    CheckObjectBusy(graphics);

    RectF rectf;

    graphics->GetVisibleClipBounds(rectf);

    rect->X = GpRound(rectf.X);
    rect->Y = GpRound(rectf.Y);
    rect->Width = GpRound(rectf.Width);
    rect->Height = GpRound(rectf.Height);

    return Ok;
}

GpStatus
WINGDIPAPI
GdipIsVisibleClipEmpty(
    GpGraphics *graphics,
    BOOL *result
    )
{
    API_ENTRY(GdipIsVisibleClipEmpty);
    CheckParameter(result);
    CheckParameterValid(graphics);
    CheckObjectBusy(graphics);

    *result = graphics->IsVisibleClipEmpty();

    return Ok;
}

GpStatus
WINGDIPAPI
GdipIsVisiblePoint(
    GpGraphics *graphics,
    REAL x,
    REAL y,
    BOOL *result
    )
{
    API_ENTRY(GdipIsVisiblePoint);
    CheckParameter(result);
    CheckParameterValid(graphics);
    CheckObjectBusy(graphics);

    GpPointF pt(x,y);


    *result = graphics->IsVisible(pt);

    return Ok;
}

GpStatus
WINGDIPAPI
GdipIsVisiblePointI(
    GpGraphics *graphics,
    INT x,
    INT y,
    BOOL *result
    )
{
    API_ENTRY(GdipIsVisiblePointI);
    return GdipIsVisiblePoint(graphics, TOREAL(x), TOREAL(y), result);
}

GpStatus
WINGDIPAPI
GdipIsVisibleRect(
    GpGraphics *graphics,
    REAL x,
    REAL y,
    REAL width,
    REAL height,
    BOOL *result
    )
{
    API_ENTRY(GdipIsVisibleRect);
    CheckParameter(result);
    CheckParameterValid(graphics);
    CheckObjectBusy(graphics);

    GpRectF rect(x, y, width, height);


    *result = graphics->IsVisible(rect);

    return Ok;
}

GpStatus
WINGDIPAPI
GdipIsVisibleRectI(
    GpGraphics *graphics,
    INT x,
    INT y,
    INT width,
    INT height,
    BOOL *result
    )
{
    API_ENTRY(GdipIsVisibleRectI);
    return GdipIsVisibleRect(graphics, TOREAL(x), TOREAL(y),
                             TOREAL(width), TOREAL(height), result);
}

GpStatus
WINGDIPAPI
GdipSaveGraphics(
    GpGraphics *graphics,
    GraphicsState *state
    )
{
    API_ENTRY(GdipSaveGraphics);
    CheckParameter(state);
    CheckParameterValid(graphics);
    CheckObjectBusy(graphics);

    *state = (GraphicsState)graphics->Save();

    return Ok;
}

GpStatus
WINGDIPAPI
GdipRestoreGraphics(
    GpGraphics *graphics,
    GraphicsState state
    )
{
    API_ENTRY(GdipRestoreGraphics);
   CheckParameterValid(graphics);
   CheckObjectBusy(graphics);

   graphics->Restore((INT)state);

   return Ok;
}


GpStatus
WINGDIPAPI
GdipBeginContainer(
    GpGraphics *graphics,
    GDIPCONST GpRectF *dstrect,
    GDIPCONST GpRectF *srcrect,
    GpPageUnit unit,
    GraphicsContainer *state
    )
{
    API_ENTRY(GdipBeginContainer);
    CheckParameter(state && dstrect && srcrect);
    CheckParameterValid(graphics);
    CheckObjectBusy(graphics);
    CheckParameter(SrcUnitIsValid((Unit)unit));


    *state = (GraphicsContainer)graphics->BeginContainer(*dstrect, *srcrect, unit);

    return Ok;
}

GpStatus
WINGDIPAPI
GdipBeginContainer2(
    GpGraphics *graphics,
    GraphicsContainer *state
    )
{
    API_ENTRY(GdipBeginContainer2);
   CheckParameter(state);
   CheckParameterValid(graphics);
   CheckObjectBusy(graphics);


   *state = (GraphicsContainer)graphics->BeginContainer();

   return Ok;
}

GpStatus
WINGDIPAPI
GdipBeginContainerI(
    GpGraphics *graphics,
    GDIPCONST GpRect *dstrect,
    GDIPCONST GpRect *srcrect,
    GpPageUnit unit,
    GraphicsContainer *state
    )
{
    API_ENTRY(GdipBeginContainerI);
   GpRectF dstrectF(TOREAL(dstrect->X), TOREAL(dstrect->Y), TOREAL(dstrect->Width), TOREAL(dstrect->Height));
   GpRectF srcrectF(TOREAL(srcrect->X), TOREAL(srcrect->Y), TOREAL(srcrect->Width), TOREAL(srcrect->Height));

   return GdipBeginContainer(graphics, &dstrectF, &srcrectF, unit, state);
}

GpStatus
WINGDIPAPI
GdipEndContainer(
    GpGraphics *graphics,
    GraphicsContainer state
    )
{
    API_ENTRY(GdipEndContainer);
   CheckParameterValid(graphics);
   CheckObjectBusy(graphics);

   graphics->EndContainer((INT)state);

   return Ok;
}

GpStatus
WINGDIPAPI
GdipGetMetafileHeaderFromWmf(
    HMETAFILE           hWmf,
    GDIPCONST WmfPlaceableFileHeader *     wmfPlaceableFileHeader,
    MetafileHeader *    header
    )
{
    API_ENTRY(GdipGetMetafileHeaderFromWmf);
    CheckParameter(hWmf && wmfPlaceableFileHeader);


    return GetMetafileHeader(hWmf, wmfPlaceableFileHeader, *header);
}

GpStatus
WINGDIPAPI
GdipGetMetafileHeaderFromEmf(
    HENHMETAFILE        hEmf,
    MetafileHeader *    header
    )
{
    API_ENTRY(GdipGetMetafileHeaderFromEmf);
    CheckParameter(hEmf);


    return GetMetafileHeader(hEmf, *header);
}

GpStatus
WINGDIPAPI
GdipGetMetafileHeaderFromFile(
    GDIPCONST WCHAR*        filename,
    MetafileHeader *    header
    )
{
    API_ENTRY(GdipGetMetafileHeaderFromFile);
    CheckParameter(filename);


    return GetMetafileHeader(filename, *header);
}

GpStatus
WINGDIPAPI
GdipGetMetafileHeaderFromStream(
    IStream *           stream,
    MetafileHeader *    header
    )
{
    API_ENTRY(GdipGetMetafileHeaderFromStream);
    CheckParameter(stream);


    return GetMetafileHeader(stream, *header);
}

GpStatus
WINGDIPAPI
GdipGetMetafileHeaderFromMetafile(
    GpMetafile *        metafile,
    MetafileHeader *    header
    )
{
    API_ENTRY(GdipGetMetafileHeaderFromMetafile);
    CheckParameterValid(metafile);
    CheckObjectBusy(metafile);


    metafile->GetHeader(*header);

    return Ok;
}

GpStatus
WINGDIPAPI
GdipGetHemfFromMetafile(
    GpMetafile *        metafile,
    HENHMETAFILE *      hEmf
    )
{
    API_ENTRY(GdipGetHemfFromMetafile);
    CheckParameter(hEmf);

    *hEmf = NULL;   // init to NULL in case the metafile is busy or invalid (Windows bug 216941)

    CheckParameterValid(metafile);
    CheckObjectBusy(metafile);

    return metafile->GetHemf(hEmf);
}

GpStatus
WINGDIPAPI
GdipCreateStreamOnFile(
    GDIPCONST WCHAR *   filename,
    UINT            access,     // GENERIC_READ and/or GENERIC_WRITE
    IStream **      stream
    )
{
    // We don't support this API anymore, simply return NotImplemented
    /*
    API_ENTRY(GdipCreateStreamOnFile);
    CheckGdiplusInitialized; // We do this in all our object creation API's

    CheckParameter(filename && stream);
    CheckParameter((access & (GENERIC_READ | GENERIC_WRITE)) != 0);

    if ((*stream = CreateStreamOnFile(filename, access)) != NULL)
    {
        return Ok;
    }
    return GenericError;
    */
    return NotImplemented;
}
GpStatus
WINGDIPAPI
GdipCreateMetafileFromWmf(
    HMETAFILE       hWmf,
    BOOL            deleteWmf,
    GDIPCONST WmfPlaceableFileHeader * wmfPlaceableFileHeader,  // can be NULL
    GpMetafile **   metafile
    )
{
    API_ENTRY(GdipCreateMetafileFromWmf);
    CheckGdiplusInitialized; // We do this in all our object creation API's

    CheckParameter(hWmf && metafile);


    *metafile = new GpMetafile(hWmf, wmfPlaceableFileHeader, deleteWmf);

    if (*metafile)
    {
        if ((*metafile)->IsValid())
        {
            return Ok;
        }
        (*metafile)->Dispose();
        *metafile = NULL;
    }
    return GenericError;
}

GpStatus
WINGDIPAPI
GdipCreateMetafileFromEmf(
    HENHMETAFILE    hEmf,
    BOOL            deleteEmf,
    GpMetafile **   metafile
    )
{
    API_ENTRY(GdipCreateMetafileFromEmf);
    CheckGdiplusInitialized; // We do this in all our object creation API's

    CheckParameter(hEmf && metafile);


    *metafile = new GpMetafile(hEmf, deleteEmf);

    if (*metafile)
    {
        if ((*metafile)->IsValid())
        {
            return Ok;
        }
        (*metafile)->Dispose();
        *metafile = NULL;
    }
    return GenericError;
}

GpStatus
WINGDIPAPI
GdipCreateMetafileFromFile(
    GDIPCONST WCHAR*    filename,
    GpMetafile **   metafile
    )
{
    API_ENTRY(GdipCreateMetafileFromFile);
    CheckGdiplusInitialized; // We do this in all our object creation API's

    CheckParameter(filename && metafile);


    *metafile = new GpMetafile(filename);

    if (*metafile)
    {
        if ((*metafile)->IsValid())
        {
            return Ok;
        }
        (*metafile)->Dispose();
        *metafile = NULL;
    }
    return GenericError;
}

GpStatus
WINGDIPAPI
GdipCreateMetafileFromWmfFile(
    GDIPCONST WCHAR*            filename,
    GDIPCONST WmfPlaceableFileHeader *   wmfPlaceableFileHeader,  // can be NULL
    GpMetafile **               metafile
    )
{
    API_ENTRY(GdipCreateMetafileFromWmfFile);
    CheckGdiplusInitialized; // We do this in all our object creation API's

    CheckParameter(filename && metafile);


    *metafile = new GpMetafile(filename, wmfPlaceableFileHeader);

    if (*metafile)
    {
        if ((*metafile)->IsValid())
        {
            return Ok;
        }
        (*metafile)->Dispose();
        *metafile = NULL;
    }
    return GenericError;
}

GpStatus
WINGDIPAPI
GdipCreateMetafileFromStream(
    IStream *       stream,
    GpMetafile **   metafile
    )
{
    API_ENTRY(GdipCreateMetafileFromStream);
    CheckGdiplusInitialized; // We do this in all our object creation API's

    CheckParameter(stream && metafile);


    *metafile = new GpMetafile(stream);

    if (*metafile)
    {
        if ((*metafile)->IsValid())
        {
            return Ok;
        }
        (*metafile)->Dispose();
        *metafile = NULL;
    }
    return GenericError;
}

GpStatus
WINGDIPAPI
GdipRecordMetafile(
    HDC                 referenceHdc,
    EmfType             type,
    GDIPCONST GpRectF *     frameRect,
    MetafileFrameUnit   frameUnit,
    GDIPCONST WCHAR *       description,
    GpMetafile **       metafile
    )
{
    API_ENTRY(GdipRecordMetafile);
    CheckParameter(referenceHdc && metafile);
    CheckParameter(EmfTypeIsValid(type));
    CheckParameter(MetafileFrameUnitIsValid(frameUnit));


    *metafile = new GpMetafile(referenceHdc, type, frameRect, frameUnit, description);

    if (*metafile)
    {
        if ((*metafile)->IsValid())
        {
            return Ok;
        }
        (*metafile)->Dispose();
        *metafile = NULL;
    }
    return GenericError;
}

GpStatus
WINGDIPAPI
GdipRecordMetafileI(
    HDC                 referenceHdc,
    EmfType             type,
    GDIPCONST GpRect *      frameRect,
    MetafileFrameUnit   frameUnit,
    GDIPCONST WCHAR *       description,
    GpMetafile **       metafile
    )
{
    API_ENTRY(GdipRecordMetafileI);
    CheckParameter(referenceHdc && frameRect);
    CheckParameter(EmfTypeIsValid(type));
    CheckParameter(MetafileFrameUnitIsValid(frameUnit));

    GpRectF frameRectF(TOREAL(frameRect->X),
                       TOREAL(frameRect->Y),
                       TOREAL(frameRect->Width),
                       TOREAL(frameRect->Height));

    return GdipRecordMetafile(referenceHdc,
                              type,
                              &frameRectF,
                              frameUnit,
                              description,
                              metafile);
}

GpStatus
WINGDIPAPI
GdipRecordMetafileFileName(
    GDIPCONST WCHAR*        fileName,
    HDC                 referenceHdc,
    EmfType             type,
    GDIPCONST GpRectF *     frameRect,
    MetafileFrameUnit   frameUnit,
    GDIPCONST WCHAR *       description,
    GpMetafile **       metafile
    )
{
    API_ENTRY(GdipRecordMetafileFileName);
    CheckParameter(fileName && referenceHdc && metafile);
    CheckParameter(EmfTypeIsValid(type));
    CheckParameter(MetafileFrameUnitIsValid(frameUnit));


    *metafile = new GpMetafile(fileName, referenceHdc, type, frameRect, frameUnit, description);

    if (*metafile)
    {
        if ((*metafile)->IsValid())
        {
            return Ok;
        }
        (*metafile)->Dispose();
        *metafile = NULL;
    }
    return GenericError;
}

GpStatus
WINGDIPAPI
GdipRecordMetafileFileNameI(
    GDIPCONST WCHAR*        fileName,
    HDC                 referenceHdc,
    EmfType             type,
    GDIPCONST GpRect *      frameRect,
    MetafileFrameUnit   frameUnit,
    GDIPCONST WCHAR *       description,
    GpMetafile **       metafile
    )
{
    API_ENTRY(GdipRecordMetafileFileNameI);
    CheckParameter(referenceHdc && frameRect);
    CheckParameter(EmfTypeIsValid(type));
    CheckParameter(MetafileFrameUnitIsValid(frameUnit));

    GpRectF frameRectF(TOREAL(frameRect->X),
                       TOREAL(frameRect->Y),
                       TOREAL(frameRect->Width),
                       TOREAL(frameRect->Height));

    return GdipRecordMetafileFileName(fileName,
                                      referenceHdc,
                                      type,
                                      &frameRectF,
                                      frameUnit,
                                      description,
                                      metafile);
}


GpStatus
WINGDIPAPI
GdipRecordMetafileStream(
    IStream *           stream,
    HDC                 referenceHdc,
    EmfType             type,
    GDIPCONST GpRectF *     frameRect,
    MetafileFrameUnit   frameUnit,
    GDIPCONST WCHAR *       description,
    GpMetafile **       metafile
    )
{
    API_ENTRY(GdipRecordMetafileStream);
    CheckParameter(stream && referenceHdc && metafile);
    CheckParameter(EmfTypeIsValid(type));
    CheckParameter(MetafileFrameUnitIsValid(frameUnit));


    *metafile = new GpMetafile(stream, referenceHdc, type, frameRect, frameUnit, description);

    if (*metafile)
    {
        if ((*metafile)->IsValid())
        {
            return Ok;
        }
        (*metafile)->Dispose();
        *metafile = NULL;
    }
    return GenericError;
}

GpStatus
WINGDIPAPI
GdipRecordMetafileStreamI(
    IStream *           stream,
    HDC                 referenceHdc,
    EmfType             type,
    GDIPCONST GpRect *      frameRect,
    MetafileFrameUnit   frameUnit,
    GDIPCONST WCHAR *       description,
    GpMetafile **       metafile
    )
{
    API_ENTRY(GdipRecordMetafileStreamI);
    CheckParameter(referenceHdc && frameRect);
    CheckParameter(EmfTypeIsValid(type));
    CheckParameter(MetafileFrameUnitIsValid(frameUnit));

    GpRectF frameRectF(TOREAL(frameRect->X),
                       TOREAL(frameRect->Y),
                       TOREAL(frameRect->Width),
                       TOREAL(frameRect->Height));

    return GdipRecordMetafileStream(stream,
                                    referenceHdc,
                                    type,
                                    &frameRectF,
                                    frameUnit,
                                    description,
                                    metafile);
}

GpStatus 
WINGDIPAPI
GdipSetMetafileDownLevelRasterizationLimit(
    GpMetafile *            metafile,
    UINT                    metafileRasterizationLimitDpi
    )
{
    API_ENTRY(GdipSetMetafileDownLevelRasterizationLimit);
    CheckParameterValid(metafile);
    CheckObjectBusy(metafile);

    // Since the rasterization limit is actually set in the graphics,
    // we check if the graphics is busy too.
    GpGraphics *    g = metafile->PrivateAPIForGettingMetafileGraphicsContext();
    CheckOptionalObjectBusy(g);
    
    return metafile->SetDownLevelRasterizationLimit(metafileRasterizationLimitDpi);
}

GpStatus WINGDIPAPI
GdipGetMetafileDownLevelRasterizationLimit(
    GDIPCONST GpMetafile *  metafile,
    UINT *                  metafileRasterizationLimitDpi
    )
{
    API_ENTRY(GdipGetMetafileDownLevelRasterizationLimit);
    CheckParameterValid(metafile);
    CheckObjectBusy(metafile);
    CheckParameter(metafileRasterizationLimitDpi);

    // Since the rasterization limit is actually set in the graphics,
    // we check if the graphics is busy too.
    GpGraphics *    g = metafile->PrivateAPIForGettingMetafileGraphicsContext();
    CheckOptionalObjectBusy(g);


    return metafile->GetDownLevelRasterizationLimit(metafileRasterizationLimitDpi);
}

// Codec management APIs

#define COPYCODECINFOSTR(_f)            \
        dst->_f = (GDIPCONST WCHAR*) buf;   \
        size = SizeofWSTR(cur->_f);     \
        memcpy(buf, cur->_f, size);     \
        buf += size

/**************************************************************************\
*
* Function Description:
*
*   Returns, via the OUT arguments, the number of installed decoders
*   and how much memory is needed to store the ImageCodecInfo for all the
*   decoders.  size tells how much memory the caller should allocate for
*   the call to GdipGetImageDecoders.
*
* Arguments:
*   numDecoders -- number of installed decoders
*   size        -- size (in bytes) of the ImageCodecInfo's of the decoders
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

GpStatus
WINGDIPAPI
GdipGetImageDecodersSize(OUT UINT *numDecoders, OUT UINT *size)
{
    API_ENTRY(GdipGetImageDecodersSize);
    // Acquire global critical section

    ImagingCritSec critsec;

    ReloadCachedCodecInfo();

    CachedCodecInfo* cur;

    // Count the number of selected codecs
    // and figure the amount of memory we need to allocate

    *numDecoders = 0;
    *size = 0;

    for (cur = CachedCodecs; cur; cur = cur->next)
    {
        if (cur->Flags & IMGCODEC_DECODER)
        {
            (*numDecoders)++;
            *size += cur->structSize;
        }
    }
    // Global critical section is released in critsec destructor
    return Ok;
}


/**************************************************************************\
*
* Function Description:
*
*   Given the number of decoders (numDecoders), the size of
*   the incoming buffer (size), and a pointer to the buffer (decoders),
*   fill the buffer with the decoder information.
*
* Arguments:
*   numDecoders -- number of installed decoders
*   size        -- size (in bytes) of the ImageCodecInfo's of the decoders
*   decoders    -- pointer to a buffer to fill in the ImageCodecInfo
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

GpStatus
WINGDIPAPI
GdipGetImageDecoders(UINT numDecoders,
                     UINT size,
                     ImageCodecInfo *decoders)
{
    API_ENTRY(GdipGetImageDecoders);
    GpStatus rv;
    HRESULT hResult;
    BYTE *buf;
    ImageCodecInfo* dst;
    CachedCodecInfo* cur;
    UINT numDecodersCheck = 0;
    UINT sizeCheck = 0;

    // Acquire global critical section

    ImagingCritSec critsec;

    if (decoders == NULL)
    {
        rv = GenericError;
        goto done;
    }

    GdipGetImageDecodersSize(&numDecodersCheck, &sizeCheck);
    // Check that the number of codecs (and size) now equals the number
    // that the user thinks there is.
    if ((numDecoders != numDecodersCheck) || (size != sizeCheck))
    {
        rv = GenericError;
        goto done;
    }
    // ASSERT: The result placed in sizeCheck is not used throughout
    // the rest of this function.

    buf = (BYTE *) decoders;

    // Copy codec information to the output buffer

    dst = decoders;
    buf += numDecoders * sizeof(ImageCodecInfo);

    for (cur = CachedCodecs; cur; cur = cur->next)
    {
        if ((cur->Flags & IMGCODEC_DECODER) == 0)
            continue;

        // First do a simple memory copy

        *dst = *static_cast<ImageCodecInfo *>(cur);

        // Then modify the pointer fields

        COPYCODECINFOSTR(CodecName);
        COPYCODECINFOSTR(FormatDescription);
        COPYCODECINFOSTR(FilenameExtension);
        COPYCODECINFOSTR(MimeType);

        if (size = cur->SigCount*cur->SigSize)
        {
            dst->SigPattern = buf;
            memcpy(buf, cur->SigPattern, size);
            buf += size;

            dst->SigMask = buf;
            memcpy(buf, cur->SigMask, size);
            buf += size;
        }

        dst++;
    }

    rv = Ok;

    // Global critical section is released in critsec destructor

done:
    return rv;
}


/**************************************************************************\
*
* Function Description:
*
*   Returns, via the OUT arguments, the number of installed encoders
*   and how much memory is needed to store the ImageCodecInfo for all the
*   encoders.  size tells how much memory the caller should allocate for
*   the call to GdipGetImageEncoders.
*
* Arguments:
*   numDecoders -- number of installed encoders
*   size        -- size (in bytes) of the ImageCodecInfo's of the encoders
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

GpStatus
WINGDIPAPI
GdipGetImageEncodersSize(OUT UINT *numEncoders, OUT UINT *size)
{
    API_ENTRY(GdipGetImageEncodersSize);
    // Acquire global critical section

    ImagingCritSec critsec;

    ReloadCachedCodecInfo();

    CachedCodecInfo* cur;

    // Count the number of selected codecs
    // and figure the amount of memory we need to allocate

    *numEncoders = 0;
    *size = 0;

    for (cur = CachedCodecs; cur; cur = cur->next)
    {
        if (cur->Flags & IMGCODEC_ENCODER)
        {
            (*numEncoders)++;
            *size += cur->structSize;
        }
    }
    // Global critical section is released in critsec destructor
    return Ok;
}


/**************************************************************************\
*
* Function Description:
*
*   Given the number of encoders (numEncoders), the size of
*   the incoming buffer (size), and a pointer to the buffer (encoders),
*   fill the buffer with the encoder information.
*
* Arguments:
*   numEncoders -- number of installed encoders
*   size        -- size (in bytes) of the ImageCodecInfo's of the encoders
*   encoders    -- pointer to a buffer to fill in the ImageCodecInfo
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

GpStatus
WINGDIPAPI
GdipGetImageEncoders(UINT numEncoders,
                     UINT size,
                     ImageCodecInfo *encoders)
{
    API_ENTRY(GdipGetImageEncoders);
    GpStatus rv;
    HRESULT hResult;
    BYTE *buf;
    ImageCodecInfo* dst;
    CachedCodecInfo* cur;
    UINT numEncodersCheck = 0;
    UINT sizeCheck = 0;

    // Acquire global critical section

    ImagingCritSec critsec;

    if (encoders == NULL)
    {
        rv = GenericError;
        goto done;
    }

    GdipGetImageEncodersSize(&numEncodersCheck, &sizeCheck);

    // Check that the number of codecs (and size) now equals the number
    // that the user thinks there is.
    if ((numEncoders != numEncodersCheck) || (size != sizeCheck))
    {
        rv = GenericError;
        goto done;
    }
    // ASSERT: The result placed in sizeCheck is not used throughout
    // the rest of this function.

    buf = (BYTE *) encoders;

    // Copy codec information to the output buffer

    dst = encoders;
    buf += numEncoders * sizeof(ImageCodecInfo);

    for (cur = CachedCodecs; cur; cur = cur->next)
    {
        if ((cur->Flags & IMGCODEC_ENCODER) == 0)
            continue;

        // First do a simple memory copy

        *dst = *static_cast<ImageCodecInfo*>(cur);

        // Then modify the pointer fields

        COPYCODECINFOSTR(CodecName);
        COPYCODECINFOSTR(FormatDescription);
        COPYCODECINFOSTR(FilenameExtension);
        COPYCODECINFOSTR(MimeType);

        if (size = cur->SigCount*cur->SigSize)
        {
            dst->SigPattern = buf;
            memcpy(buf, cur->SigPattern, size);
            buf += size;

            dst->SigMask = buf;
            memcpy(buf, cur->SigMask, size);
            buf += size;
        }

        dst++;
    }

    rv = Ok;

    // Global critical section is released in critsec destructor

done:
    return rv;
}

void*
WINGDIPAPI
GdipAlloc(
    size_t size
)
{
    API_ENTRY(GdipAlloc);
    CheckGdiplusInitialized_ReturnNULL;

    #if DBG
    return GpMallocAPI(size);
    #else
    return GpMalloc(size);
    #endif
}

void
WINGDIPAPI
GdipFree(
    void* ptr
)
{
    API_ENTRY(GdipFree);
    GpFree(ptr);
}

/// Out of place font/text stuff

GpStatus
WINGDIPAPI
GdipCreateFontFamilyFromName(GDIPCONST WCHAR *name,
                             GpFontCollection *fontCollection,
                             GpFontFamily **fontFamily)
{
    API_ENTRY(GdipCreateFontFamilyFromName);
    CheckGdiplusInitialized; // We do this in all our object creation API's

    CheckParameter(name && fontFamily);

    GlobalTextLock lock;

    CheckOptionalParameterValid(fontCollection);

    return GpFontFamily::CreateFontFamilyFromName(
                            name,
                            fontCollection,
                            fontFamily);
}


GpStatus
WINGDIPAPI
GdipGetGenericFontFamilySansSerif(GpFontFamily **nativeFamily)
{
    API_ENTRY(GdipGetGenericFontFamilySansSerif);
    CheckParameter(nativeFamily);
    return GpFontFamily::GetGenericFontFamilySansSerif(nativeFamily);
}

GpStatus
WINGDIPAPI
GdipGetGenericFontFamilySerif(GpFontFamily **nativeFamily)
{
    API_ENTRY(GdipGetGenericFontFamilySerif);
    CheckParameter(nativeFamily);
    return GpFontFamily::GetGenericFontFamilySerif(nativeFamily);
}

GpStatus
WINGDIPAPI
GdipGetGenericFontFamilyMonospace(GpFontFamily **nativeFamily)
{
    API_ENTRY(GdipGetGenericFontFamilyMonospace);
    CheckParameter(nativeFamily);
    return GpFontFamily::GetGenericFontFamilyMonospace(nativeFamily);
}


GpStatus
WINGDIPAPI
GdipCreateFont(
    GDIPCONST GpFontFamily *fontFamily,
    REAL                size,
    INT                 style,
    Unit                unit,
    GpFont            **font
)
{
    API_ENTRY(GdipCreateFont);
    CheckGdiplusInitialized; // We do this in all our object creation API's

    GpStatus status = Ok;
    // check parameters
    CheckParameter(font);

    // UnitDisplay is NOT valid; its only use is for Page Transforms
    if (size <= 0 ||
//        (style < StyleRegular || style > StyleStrikeout) ||
        (unit < UnitWorld || unit > UnitMillimeter || unit == UnitDisplay))
    {
        return InvalidParameter;
    }

    GlobalTextLock lock;

    CheckParameterValid(fontFamily);

    if (*font = new GpFont(size, fontFamily, style, unit)) {
        if (!(*font)->GetFace()) {
           delete *font;
           *font = NULL;
           status = FontStyleNotFound;
        }
     }
    else
    {
        status = OutOfMemory;
    }

    return status;
}


GpStatus
WINGDIPAPI
GdipDeleteFontFamily(GpFontFamily *gpFontFamily)
{
    API_ENTRY(GdipDeleteFontFamily);
    // NOTE: Do NOT call CheckParameterValid(), because we need to free
    // the object, even if it's not in a valid state.
    CheckParameter(gpFontFamily);

    GlobalTextLock lock;

    gpFontFamily->DecFontFamilyRef();

    if (gpFontFamily->IsFileLoaded(FALSE))
    {
        // Try to delete the font file (RemoveFontFile) for each Face[].
        // This also will have the side effect of attempting to delete
        // any deletable GpFontFamily objects.
        UINT iFace = 0;
        UINT iLastFace = 0;
        GpFontFace *face = NULL;

        // Compute the index of the last non-NULL Face[] pointer.
        for (iFace = 0; iFace < NumFontFaces; iFace++)
        {
            face = gpFontFamily->GetFaceAbsolute(iFace);
            if (face != NULL)
            {
                iLastFace = iFace;
            }
        }

        for (iFace = 0; iFace <= iLastFace; iFace++)
        {
            face = gpFontFamily->GetFaceAbsolute(iFace);
            // Try to remove the font file if RemoveFontFile has
            // already been called on it.
            // Note that if iFace == iLastFace, then the call to
            // RemoveFontFile below might delete this gpFontFamily object,
            // which means the Face[] pointers would be garbage.  This is
            // why the for loop index goes up to iLastFace.
            if (face && face->pff->bRemoved)
            {
                GpFontCollection* actualFontCollection;
                actualFontCollection = gpFontFamily->GetFontCollection();
                actualFontCollection = actualFontCollection ?
                                        actualFontCollection :
                                        GpInstalledFontCollection::GetGpInstalledFontCollection();

                actualFontCollection->GetFontTable()->RemoveFontFile(face->pff->pwszPathname_);
            }
        }
    }

    return Ok;
}

GpStatus
WINGDIPAPI
GdipCloneFontFamily(GpFontFamily *gpFontFamily, GpFontFamily **gpClonedFontFamily)
{
    API_ENTRY(GdipCloneFontFamily);
    CheckParameter(gpClonedFontFamily);

    GlobalTextLock lock;

    CheckParameterValid(gpFontFamily);

    gpFontFamily->IncFontFamilyRef();
    *gpClonedFontFamily = gpFontFamily;

    return Ok;
}

GpStatus
WINGDIPAPI
GdipGetFamily(GpFont *font, GpFontFamily **family)
{
    API_ENTRY(GdipGetFamily);
    CheckParameter(family);

    GlobalTextLock lock;

    CheckParameterValid(font);

    *family = const_cast<GpFontFamily *>(font->GetFamily());

    return Ok;

}

GpStatus
WINGDIPAPI
GdipGetFontStyle(GpFont *font, INT *style)
{
    API_ENTRY(GdipGetFontStyle);
    CheckParameter(style);

    GlobalTextLock lock;

    CheckParameterValid(font);
    *style = font->GetStyle();

    return Ok;
}

GpStatus
WINGDIPAPI
GdipGetLogFontA(GpFont * font, GpGraphics *graphics, LOGFONTA * logfontA)
{
    API_ENTRY(GdipGetLogFontA);
    CheckParameter(logfontA);
    CheckParameterValid(graphics);
    CheckObjectBusy(graphics);


    GlobalTextLock lock;

    CheckParameterValid(font);
    font->GetLogFontA(graphics, logfontA);

    return Ok;
}

GpStatus
WINGDIPAPI
GdipGetLogFontW(GpFont * font, GpGraphics *graphics, LOGFONTW * logfontW)
{
    API_ENTRY(GdipGetLogFontW);
    CheckParameter(logfontW);
    CheckParameterValid(graphics);
    CheckObjectBusy(graphics);


    GlobalTextLock lock;

    CheckParameterValid(font);
    font->GetLogFontW(graphics, logfontW);

    return Ok;
}

GpStatus
WINGDIPAPI
GdipGetFontSize(GpFont *font, REAL *size)
{
    API_ENTRY(GdipGetFontSize);
    CheckParameter(size);

    GlobalTextLock lock;

    CheckParameterValid(font);
    *size = font->GetEmSize();

    return Ok;
}


GpStatus
WINGDIPAPI
GdipGetFontUnit(GpFont *font, Unit *unit)
{
    API_ENTRY(GdipGetFontUnit);
    CheckParameter(unit);

    GlobalTextLock lock;

    CheckParameterValid(font);
    *unit = font->GetUnit();

    return Ok;
}


GpStatus
WINGDIPAPI
GdipGetFontHeight(GDIPCONST GpFont *font, GDIPCONST GpGraphics *graphics, REAL *height)
{
    API_ENTRY(GdipGetFontHeight);
    CheckParameter(height);
    CheckOptionalParameterValid(graphics);
    CheckOptionalObjectBusy(graphics);

    GlobalTextLock lock;

    CheckParameterValid(font);
    return font->GetHeight(graphics, height);
}


GpStatus
WINGDIPAPI
GdipGetFontHeightGivenDPI(GDIPCONST GpFont *font, REAL dpi, REAL *height)
{
    API_ENTRY(GdipGetFontHeight);
    CheckParameter(height);

    GlobalTextLock lock;

    CheckParameterValid(font);
    return font->GetHeight(dpi, height);
}


GpStatus
WINGDIPAPI
GdipCloneFont(
    GpFont* font,
    GpFont** cloneFont
    )
{
    API_ENTRY(GdipCloneFont);
    CheckParameter(cloneFont);

    GlobalTextLock lock;

    CheckParameterValid(font);
    *cloneFont = font->Clone();

    if (*cloneFont)
        return Ok;
    else
        return OutOfMemory;
}

GpStatus
WINGDIPAPI
GdipDeleteFont(
    GpFont* font
    )
{
    API_ENTRY(GdipDeleteFont);
    // NOTE: Do NOT call CheckParameterValid(), because we need to free
    // the object, even if it's not in a valid state.
    CheckParameter(font);

    GlobalTextLock lock;

    delete font;

    return Ok;
}

/// End out of place font/text stuff

GpStatus
WINGDIPAPI
GdipGetDC(
    GpGraphics*     graphics,
    HDC *           hdc
    )
{
    API_ENTRY(GdipGetDC);
    CheckParameter(hdc);
    CheckParameterValid(graphics);

    // NOTE: We have to leave the graphics locked until the GdipReleaseDC call

    LONG *      lockCount = (graphics->GetObjectLock())->GetLockCount();
    LONG        result    = InterlockedIncrement(lockCount);

    if (result != 0)
    {
        InterlockedDecrement(lockCount);
        return ObjectBusy;
    }

    if ((*hdc = graphics->GetHdc()) == NULL)
    {
        InterlockedDecrement(lockCount);
        return InvalidParameter;
    }

    graphics->LockedByGetDC = -1;   // set graphics GetDC lock
    return Ok;
}

GpStatus
WINGDIPAPI
GdipReleaseDC(
    GpGraphics*     graphics,
    HDC             hdc
    )
{
    API_ENTRY(GdipReleaseDC);
    CheckParameter(hdc);
    CheckParameterValid(graphics);

    // NOTE: The graphics should already be locked from the GdipGetDC call

    LONG        result;

    if ((InterlockedIncrement(&(graphics->LockedByGetDC)) != 0) ||
        (!(graphics->GetObjectLock())->IsLocked()))
    {
        InterlockedDecrement(&(graphics->LockedByGetDC));
        return InvalidParameter;
    }

    graphics->ReleaseHdc(hdc);

    InterlockedDecrement((graphics->GetObjectLock())->GetLockCount());

    return Ok;
}

GpStatus
WINGDIPAPI
GdipComment(
    GpGraphics*     graphics,
    UINT            sizeData,
    GDIPCONST BYTE *    data
    )
{
    API_ENTRY(GdipComment);
    CheckParameter(data && (sizeData > 0));
    CheckParameterValid(graphics);
    CheckObjectBusy(graphics);

    return graphics->Comment(sizeData, data);
}


// FontFamily

/// GdipCreateFontFamilyFromName should be moved here

/// GdipEnumerableFonts should be moved here

/// GdipEnumerateFonts should be moved here

/// GdipGetFamilyName should be moved here

GpStatus
WINGDIPAPI
GdipIsStyleAvailable(GDIPCONST GpFontFamily *family, INT style, BOOL * IsAvailable)
{
    API_ENTRY(GdipIsStyleAvailable);
    CheckParameter(IsAvailable);

    GlobalTextLock lock;

    CheckParameterValid(family);
    *IsAvailable = family->IsStyleAvailable(style);

    return Ok;
}

GpStatus
WINGDIPAPI
GdipGetEmHeight(GDIPCONST GpFontFamily *family, INT style, UINT16 * EmHeight)
{
    API_ENTRY(GdipGetEmHeight);
    CheckParameter(EmHeight);

    GlobalTextLock lock;

    CheckParameterValid(family);
    *EmHeight = family->GetDesignEmHeight(style);

    return Ok;

}

GpStatus
WINGDIPAPI
GdipGetCellAscent(GDIPCONST GpFontFamily *family, INT style, UINT16 * CellAscent)
{
    API_ENTRY(GdipGetCellAscent);
    CheckParameter(CellAscent);

    GlobalTextLock lock;

    CheckParameterValid(family);
    *CellAscent = family->GetDesignCellAscent(style);

    return Ok;
}

GpStatus
WINGDIPAPI
GdipGetCellDescent(GDIPCONST GpFontFamily *family, INT style, UINT16 * CellDescent)
{
    API_ENTRY(GdipGetCellDescent);
    CheckParameter(CellDescent);

    GlobalTextLock lock;

    CheckParameterValid(family);
    *CellDescent = family->GetDesignCellDescent(style);

    return Ok;
}

GpStatus
WINGDIPAPI
GdipGetLineSpacing(GDIPCONST GpFontFamily *family, INT style, UINT16 * LineSpacing)
{
    API_ENTRY(GdipGetLineSpacing);
    CheckParameter(LineSpacing);

    GlobalTextLock lock;

    CheckParameterValid(family);
    *LineSpacing = family->GetDesignLineSpacing(style);

    return Ok;
}

// Font

GpStatus
WINGDIPAPI
GdipCreateFontFromDC(
    HDC        hdc,
    GpFont   **font
)
{
    API_ENTRY(GdipCreateFontFromDC);
    CheckGdiplusInitialized; // We do this in all our object creation API's

    GpStatus status = GenericError;
    CheckParameter(hdc);

    GlobalTextLock lock;

    if (*font = new GpFont(hdc))
    {
        // we should fail in case we don't have valid font family. (non-true type font selected in the hdc)
        if (!(*font)->IsValid())
        {
           delete *font;
           *font = NULL;
           status = NotTrueTypeFont;
        }
        else
            status = Ok;
    }

    return status;
}

GpStatus
WINGDIPAPI
GdipCreateFontFromLogfontA(
    HDC              hdc,
    GDIPCONST LOGFONTA  *logfont,
    GpFont         **font
)
{
    API_ENTRY(GdipCreateFontFromLogfontA);
    CheckGdiplusInitialized; // We do this in all our object creation API's

    GpStatus status = GenericError;
    CheckParameter(hdc && logfont);

    GlobalTextLock lock;

    if (*font = new GpFont(hdc, const_cast<LOGFONTA*>(logfont)))
    {
        // we should fail in case we don't have valid font family. (non-true type font selected in the hdc)
        if (!(*font)->IsValid())
        {
           delete *font;
           *font = NULL;
           status = NotTrueTypeFont;
        }
        else
            status = Ok;
    }

    return status;
}

GpStatus
WINGDIPAPI
GdipCreateFontFromLogfontW(
    HDC             hdc,
    GDIPCONST LOGFONTW  *logfont,
    GpFont          **font
)
{
    API_ENTRY(GdipCreateFontFromLogfontW);
    CheckGdiplusInitialized; // We do this in all our object creation API's

    GpStatus status = GenericError;
    CheckParameter(hdc && logfont);

    GlobalTextLock lock;

    if (*font = new GpFont(hdc, const_cast<LOGFONTW*>(logfont)))
    {
        // we should fail in case we don't have valid font family. (non-true type font selected in the hdc)
        if (!(*font)->IsValid())
        {
           delete *font;
           *font = NULL;
           status = NotTrueTypeFont;
        }
        else
            status = Ok;
    }

    return status;
}

/// GdipCreateFont should be moved here

/// GdipCloneFont should be moved here

/// GdipDeleteFont should be moved here

/// GdipGetFamily should be moved here

/// GdipGetFontStyle should be moved here

/// GdipGetFontSize should be moved here


GpStatus
WINGDIPAPI
GdipNewInstalledFontCollection(GpFontCollection** fontCollection)
{
    API_ENTRY(GdipNewInstalledFontCollection);
    CheckParameter (fontCollection);

    GlobalTextLock lock;

    *fontCollection = GpInstalledFontCollection::GetGpInstalledFontCollection();

    return (*fontCollection ? Ok : FileNotFound);
}

GpStatus
WINGDIPAPI
GdipNewPrivateFontCollection(GpFontCollection** fontCollection)
{
    API_ENTRY(GdipNewPrivateFontCollection);
    CheckParameter (fontCollection);

    GlobalTextLock lock;

    *fontCollection = new GpPrivateFontCollection;

    return (*fontCollection ? Ok : GenericError);
}

GpStatus
WINGDIPAPI
GdipDeletePrivateFontCollection(GpFontCollection** fontCollection)
{
    API_ENTRY(GdipDeletePrivateFontCollection);
    // NOTE: Do NOT call CheckParameterValid(), because we need to free
    // the object, even if it's not in a valid state.
    CheckParameter (fontCollection);

    GlobalTextLock lock;

    delete static_cast<GpPrivateFontCollection *>(*fontCollection);

    *fontCollection = NULL;

    return Ok;
}

GpStatus
WINGDIPAPI
GdipGetFontCollectionFamilyCount(
    GpFontCollection*   fontCollection,
    INT       *             numFound
    )
{
    API_ENTRY(GdipGetFontCollectionFamilyCount);
    CheckParameter (numFound);

    GlobalTextLock lock;

    CheckParameterValid(fontCollection);
    *numFound = fontCollection->GetFamilyCount();

    return Ok;
}

GpStatus
WINGDIPAPI
GdipGetFontCollectionFamilyList(
    GpFontCollection* fontCollection,
    INT             numSought,
    GpFontFamily*   gpfamilies[],
    INT*            numFound
    )
{
    API_ENTRY(GdipGetFontCollectionFamilyList);
    GpStatus status;
    CheckParameter(gpfamilies);
    CheckParameter (numFound);

    GlobalTextLock lock;

    CheckParameterValid(fontCollection);
    return fontCollection->GetFamilies(
        numSought,
        gpfamilies,
        numFound);
}

GpStatus
WINGDIPAPI
GdipPrivateAddFontFile(
    GpFontCollection* fontCollection,
    GDIPCONST WCHAR* filename
    )
{
    API_ENTRY(GdipPrivateAddFontFile);
    CheckParameter (filename);

    // We can cast the fontCollection because we know that this
    // function is called only from PrivateFontCollection::AddFontFile,
    // and so we know that fontCollection really was constructed as
    // a PrivateFontCollection.
    GlobalTextLock lock;

    CheckParameterValid(fontCollection);
    return static_cast<GpPrivateFontCollection *>
        (fontCollection)->AddFontFile(filename);
}

GpStatus
WINGDIPAPI
GdipPrivateAddMemoryFont(
    GpFontCollection* fontCollection,
    GDIPCONST void* memory,
    INT length
    )
{
    API_ENTRY(GdipPrivateAddMemoryFont);
    CheckParameter (memory);

    // We can cast the fontCollection because we know that this
    // function is called only from PrivateFontCollection::AddMemoryFontFile,
    // and so we know that fontCollection really was constructed as
    // an PrivateFontCollection.
    GlobalTextLock lock;

    CheckParameterValid(fontCollection);
    return static_cast<GpPrivateFontCollection *>
        (fontCollection)->AddMemoryFont(memory, length);
}

GpStatus
WINGDIPAPI
GdipSetFontSize(GpFont *font, REAL size, Unit unit)
{
    API_ENTRY(GdipSetFontSize);

    GlobalTextLock lock;

    CheckParameterValid(font);

    // UnitDisplay is NOT valid; its only use is for Page Transforms
    if ((unit >= UnitWorld) && (unit <= UnitMillimeter) && (unit != UnitDisplay))
    {
        font->SetEmSize(size);
        font->SetUnit(unit);
        return Ok;
    }
    else
    {
        return GenericError;
    }
}


GpStatus
WINGDIPAPI
GdipCreateStringFormat(
    INT               formatAttributes,
    LANGID            language,
    GpStringFormat  **format
)
{
    API_ENTRY(GdipCreateStringFormat);
    CheckGdiplusInitialized; // We do this in all our object creation API's

    CheckParameter(format);

    GlobalTextLock lock;

    *format = new GpStringFormat(formatAttributes, language);

    return format ? Ok : OutOfMemory;
}

GpStatus
WINGDIPAPI
GdipStringFormatGetGenericDefault(GpStringFormat **format)
{
    API_ENTRY(GdipStringFormatGetGenericDefault);
    CheckParameter(format);

    GlobalTextLock lock;
    *format = GpStringFormat::GenericDefault();
    return Ok;
}

GpStatus
WINGDIPAPI
GdipStringFormatGetGenericTypographic(GpStringFormat **format)
{
    API_ENTRY(GdipStringFormatGetGenericTypographic);
    CheckParameter(format);
    GlobalTextLock lock;
    *format = GpStringFormat::GenericTypographic();
    return Ok;
}

GpStatus
WINGDIPAPI
GdipCloneStringFormat(
    GDIPCONST GpStringFormat *format,
    GpStringFormat **newFormat)
{
    API_ENTRY(GdipCloneStringFormat);
    CheckParameter(newFormat);

    GlobalTextLock lock;
    CheckParameterValid(format);

    *newFormat = format->Clone();

    return newFormat == NULL ? OutOfMemory : Ok;
}

GpStatus
WINGDIPAPI
GdipDeleteStringFormat(GpStringFormat *format)
{
    API_ENTRY(GdipDeleteStringFormat);
    // NOTE: Do NOT call CheckParameterValid(), because we need to free
    // the object, even if it's not in a valid state.
    CheckParameter(format);

    GlobalTextLock lock;

    if (!format->IsPermanent())
    {
        delete format;
    }

    return Ok;
}

GpStatus
WINGDIPAPI
GdipSetStringFormatFlags(GpStringFormat *format, INT flags)
{
    API_ENTRY(GdipSetStringFormatFlags);

    GlobalTextLock lock;
    CheckParameterValid(format);

    format->SetFormatFlags(flags);
    return Ok;
}

GpStatus
WINGDIPAPI
GdipGetStringFormatFlags(GDIPCONST GpStringFormat *format, INT *flags)
{
    API_ENTRY(GdipGetStringFormatFlags);
    CheckParameter(flags);

    GlobalTextLock lock;
    CheckParameterValid(format);
    *flags = format->GetFormatFlags();

    return Ok;
}

GpStatus
WINGDIPAPI
GdipSetStringFormatAlign(
    GpStringFormat   *format,
    StringAlignment   align)
{
    API_ENTRY(GdipSetStringFormatAlign);
    GlobalTextLock lock;
    CheckParameterValid(format);

    CheckParameter(    align >= StringAlignmentNear
                   &&  align <= StringAlignmentFar);

    return format->SetAlign(align);
}

GpStatus
WINGDIPAPI
GdipGetStringFormatAlign(
    GDIPCONST GpStringFormat *format,
    StringAlignment            *align)
{
    API_ENTRY(GdipGetStringFormatAlign);
    CheckParameter(align);
    GlobalTextLock lock;
    CheckParameterValid(format);

    return format->GetAlign(align);
}

GpStatus
WINGDIPAPI
GdipSetStringFormatLineAlign(
    GpStringFormat   *format,
    StringAlignment   align)
{
    API_ENTRY(GdipSetStringFormatLineAlign);

    GlobalTextLock lock;
    CheckParameterValid(format);

    CheckParameter(    align >= StringAlignmentNear
                   &&  align <= StringAlignmentFar);

    return format->SetLineAlign(align);
}

GpStatus
WINGDIPAPI
GdipGetStringFormatLineAlign(
    GDIPCONST GpStringFormat *format,
    StringAlignment          *align)
{
    API_ENTRY(GdipGetStringFormatLineAlign);
    CheckParameter(align);
    GlobalTextLock lock;
    CheckParameterValid(format);

    return format->GetLineAlign(align);
}


GpStatus
WINGDIPAPI
GdipSetStringFormatHotkeyPrefix(
    GpStringFormat *format,
    INT             hotkeyPrefix)
{
    API_ENTRY(GdipSetStringFormatHotkeyPrefix);
    CheckParameter(    hotkeyPrefix >= HotkeyPrefixNone
                   &&  hotkeyPrefix <= HotkeyPrefixHide);

    GlobalTextLock lock;
    CheckParameterValid(format);

    return format->SetHotkeyPrefix(hotkeyPrefix);
}

GpStatus
WINGDIPAPI
GdipGetStringFormatHotkeyPrefix(
    GDIPCONST GpStringFormat *format,
    INT                      *hotkeyPrefix)
{
    API_ENTRY(GdipGetStringFormatHotkeyPrefix);
    CheckParameter(hotkeyPrefix);
    GlobalTextLock lock;
    CheckParameterValid(format);

    return format->GetHotkeyPrefix(hotkeyPrefix);
}

GpStatus
WINGDIPAPI
GdipSetStringFormatTabStops(
    GpStringFormat  *format,
    REAL            firstTabOffset,
    INT             count,
    GDIPCONST REAL            *tabStops
)
{
    API_ENTRY(GdipSetStringFormatTabStops);
    CheckParameter(tabStops);
    GlobalTextLock lock;
    CheckParameterValid(format);

    return format->SetTabStops (
                firstTabOffset,
                count,
                tabStops
           );
}

GpStatus
WINGDIPAPI
GdipGetStringFormatTabStopCount(
    GDIPCONST GpStringFormat    *format,
    INT                     *count
)
{
    API_ENTRY(GdipGetStringFormatTabStopCount);
    CheckParameter(count);
    GlobalTextLock lock;
    CheckParameterValid(format);

    return format->GetTabStopCount (count);
}

GpStatus
WINGDIPAPI
GdipGetStringFormatTabStops(
    GDIPCONST GpStringFormat    *format,
    INT                     count,
    REAL                    *firstTabOffset,
    REAL                    *tabStops
)
{
    API_ENTRY(GdipGetStringFormatTabStops);
    CheckParameter(firstTabOffset && tabStops);
    GlobalTextLock lock;
    CheckParameterValid(format);

    return format->GetTabStops (
                firstTabOffset,
                count,
                tabStops
           );
}

GpStatus
WINGDIPAPI
GdipGetStringFormatMeasurableCharacterRangeCount(
    GDIPCONST GpStringFormat    *format,
    INT                         *count
)
{
    API_ENTRY(GdipGetStringFormatMeasurableCharacterRangeCount);
    CheckParameter(count);
    CheckParameterValid(format);

    *count = format->GetMeasurableCharacterRanges();
    return Ok;
}

GpStatus
WINGDIPAPI
GdipSetStringFormatMeasurableCharacterRanges(
    GpStringFormat              *format,
    INT                         rangeCount,
    GDIPCONST CharacterRange    *ranges
)
{
    API_ENTRY(GdipSetStringFormatMeasurableCharacterRanges);
    CheckParameter(ranges);
    CheckParameterValid(format);

    if (rangeCount > 32)
    {
        return ValueOverflow;
    }

    return format->SetMeasurableCharacterRanges(
        rangeCount,
        ranges
    );
    return Ok;
}

GpStatus
WINGDIPAPI
GdipSetStringFormatDigitSubstitution(
    GpStringFormat       *format,
    LANGID                language,
    StringDigitSubstitute substitute
)
{
    API_ENTRY(GdipSetStringFormatDigitSubstitution);
    GlobalTextLock lock;
    CheckParameterValid(format);

    return format->SetDigitSubstitution (
                language,
                substitute
           );
}

GpStatus
WINGDIPAPI
GdipGetStringFormatDigitSubstitution(
    GDIPCONST GpStringFormat        *format,
    LANGID                *language,
    StringDigitSubstitute *substitute
)
{
    API_ENTRY(GdipGetStringFormatDigitSubstitution);
    GlobalTextLock lock;
    CheckParameterValid(format);

    return format->GetDigitSubstitution (
                language,
                substitute
           );
}

GpStatus
WINGDIPAPI
GdipSetStringFormatTrimming(
    GpStringFormat  *format,
    StringTrimming   trimming
)
{
    API_ENTRY(GdipSetStringFormatTrimming);
    CheckParameter(    trimming >= StringTrimmingNone
                   &&  trimming <= StringTrimmingEllipsisPath);
    GlobalTextLock lock;
    CheckParameterValid(format);

    return format->SetTrimming(trimming);
}

GpStatus
WINGDIPAPI
GdipGetStringFormatTrimming(
    GDIPCONST GpStringFormat *format,
    StringTrimming       *trimming
)
{
    API_ENTRY(GdipGetStringFormatTrimming);
    CheckParameter(trimming);
    GlobalTextLock lock;
    CheckParameterValid(format);

    return format->GetTrimming(trimming);
}

GpStatus
WINGDIPAPI
GdipCreateCachedBitmap(
    GpBitmap *bitmap,
    GpGraphics *graphics,
    GpCachedBitmap **nativeCachedBitmap
)
{
    API_ENTRY(GdipCreateCachedBitmap);
    CheckGdiplusInitialized; // We do this in all our object creation API's

    CheckParameter(nativeCachedBitmap);

    // must have a bitmap and a graphics to create a CachedBitmap.
    // Also we must lock both objects for the duration of this call
    // because we can't have any other APIs modifying them.

    CheckParameterValid(graphics);
    CheckObjectBusy(graphics);
    CheckParameterValid(bitmap);
    CheckObjectBusy(bitmap);

    *nativeCachedBitmap = new GpCachedBitmap(bitmap, graphics);
    if(nativeCachedBitmap)
    {
        return Ok;
    }
    else
    {
        return OutOfMemory;
    }

}

GpStatus WINGDIPAPI
GdipDeleteCachedBitmap(GpCachedBitmap *nativeCachedBitmap)
{
    API_ENTRY(GdipDeleteCachedBitmap);

    // NOTE: Do NOT call CheckParameterValid(), because we need to free
    // the object, even if it's not in a valid state.
    CheckParameter(nativeCachedBitmap);

    // Grab the lock for the duration of the delete so that we bounce if
    // someone is busy rendering on it.

    // !!! [asecchia] note this will bounce if the object is locked and then
    // the deletion will fail. This will cause the app to leak memory because
    // there is no way to check the return status from delete.
    // This problem is common to all our deletion APIs

    CheckObjectBusyForDelete(nativeCachedBitmap);

    delete nativeCachedBitmap;

    return Ok;
}

GpStatus WINGDIPAPI
GdipDrawCachedBitmap(
    GpGraphics *nativeGraphics,
    GpCachedBitmap *cb,
    INT x,
    INT y
)
{
    API_ENTRY(GdipDrawCachedBitmap);
    // Check the input parameters for NULL

    CheckParameterValid(nativeGraphics);
    CheckParameterValid(cb);

    // Grab the lock to make sure nobody is currently trying to delete the
    // object under us.

    CheckObjectBusy(cb);

    // Grab the lock on the GpGraphics

    CheckObjectBusy(nativeGraphics);

    return (nativeGraphics->DrawCachedBitmap(cb, x, y));
}

// The palette must be freed and recreated whenever the Desktop colors change
HPALETTE
WINGDIPAPI
GdipCreateHalftonePalette()
{
    API_ENTRY(GdipCreateHalftonePalette);

    // !!! [agodfrey]: I bet we haven't documented the fact that the user
    //     has to call this any time the desktop colors change.
    //     Also, I don't know why we read 12 colors instead of 4 (I thought
    //     there were only 4 magic colors.)

    HPALETTE    hpalette;
    HDC         hdc = ::GetDC(NULL);  // Get a screen DC

    if (hdc != NULL)
    {
        // See if we need to get the desktop colors
        if ((::GetDeviceCaps(hdc, RASTERCAPS) & RC_PALETTE) &&
            (::GetSystemPaletteUse(hdc) == SYSPAL_STATIC) &&
            (::GetDeviceCaps(hdc, SIZEPALETTE) == 256))
        {
            // We have to get the desktop colors to guarantee
            // a XO_TRIVIAL translate in GDI.

            // First Entry is always Black
            ::GetSystemPaletteEntries(hdc, 1, 9,
                                      Win9xHalftonePalette.palPalEntry + 1);

            // We only can handle changes to the first 3 of the last 10
            ::GetSystemPaletteEntries(hdc, 246, 3,
                                      Win9xHalftonePalette.palPalEntry + 246);
        }
        ::ReleaseDC(NULL, hdc);
    }
    hpalette = ::CreatePalette((LOGPALETTE *)(&Win9xHalftonePalette));
    return hpalette;
}

GpStatus
WINGDIPAPI
GdipMonitorControl(GpMonitorControlEnum control, void * param)
{
    API_ENTRY(GdipMonitorControl);

    if(Globals::Monitors == NULL)
    {
        Globals::Monitors = new GpMonitors;

        if(Globals::Monitors == NULL)
            return OutOfMemory;
    }

    return Globals::Monitors->Control(control, param);
}

GpStatus
WINGDIPAPI
GdipTestControl(GpTestControlEnum control, void * param)
{
    API_ENTRY(GdipTestControl);

    GpStatus result = Ok;

    switch(control)
    {
    case TestControlForceBilinear:
        Globals::ForceBilinear = *((BOOL *) param);
        break;

    case TestControlNoICM:
        Globals::NoICM = *((BOOL *) param);
        break;

    case TestControlGetBuildNumber:
        *((INT32 *) param) = VER_PRODUCTBUILD;
        break;

    default:
        result = InvalidParameter;
        break;
    }

    return result;
}

UINT
WINGDIPAPI
GdipEmfToWmfBits(HENHMETAFILE hemf,
                 UINT         cbData16,
                 LPBYTE       pData16,
                 INT          iMapMode,
                 INT          eFlags)
{
    API_ENTRY(GdipEmfToWmfBits);
    return ConvertEmfToPlaceableWmf(
            hemf,
            cbData16,
            pData16,
            iMapMode,
            eFlags);
}

// Version information for debugging purposes
UINT32 GpBuildNumber = VER_PRODUCTBUILD;

} // end of extern "C"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\entry\xpath.hpp ===
/**************************************************************************\
* 
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   XPath.hpp
*
* Abstract:
*
*   Interface of GpXPath and its iterator classes
*
* Revision History:
*
*   11/08/1999 ikkof
*       Created it.
*
\**************************************************************************/

#ifndef _XPATH_HPP
#define _XPATH_HPP

enum XPathFlags
{
    HasBezierFlag   = 1,
    IsRationalFlag  = 2
};

class GpXPath
{
private:
    // We now use an ObjectTag to determine if the object is valid
    // instead of using a BOOL.  This is much more robust and helps
    // with debugging.  It also enables us to version our objects
    // more easily with a version number in the ObjectTag.
    ObjectTag           Tag;    // Keep this as the 1st value in the object!

protected:
    VOID SetValid(BOOL valid)
    {
        Tag = valid ? ObjectTagXPath : ObjectTagInvalid;
    }

protected:
    INT Flags;
    BYTE* Types;
    GpXPoints XPoints;
    GpFillMode FillMode;
    INT SubpathCount;       // number of subpaths

public:
    GpXPath(const GpPath* path);
	GpXPath(
		const GpPath* path,
		const GpRectF& rect,
		const GpPointF* points,
		INT count,
		WarpMode warpMode
		);

    ~GpXPath()
    {
        if(Types)
            GpFree(Types);

        SetValid(FALSE);    // so we don't use a deleted object
    }

    INT GetPointCount()
    {
        return XPoints.Count;
    }

    INT GetPointDimension()
    {
        return XPoints.Dimension;
    }

    REALD* GetPathPoints()
    {
        return XPoints.Data;
    }

    BYTE* GetPathTypes()
    {
        return Types;
    }

    VOID SetFillMode(GpFillMode fillMode)
    {
        FillMode = fillMode;
    }

    GpFillMode GetFillMode()
    {
        return FillMode;
    }

    VOID SetBezierFlag()
    {
        Flags |= HasBezierFlag;
    }

    BOOL HasBezier()
    {
        if(Flags & HasBezierFlag)
            return TRUE;
        else
            return FALSE;
    }

    VOID SetRationalFlag()
    {
        Flags |= IsRationalFlag;
    }

    BOOL IsRational()
    {
        if(Flags & IsRationalFlag)
            return TRUE;
        else
            return FALSE;
    }

    BOOL IsValid() const
    {
        ASSERT((Tag == ObjectTagXPath) || (Tag == ObjectTagInvalid)); 
    #if DBG
        if (Tag == ObjectTagInvalid)
        {
            WARNING1("Invalid XPath");
        }
    #endif

        return (Tag == ObjectTagXPath);
    }

    GpStatus
    Flatten(
        DynByteArray* flattenTypes,
        DynPointFArray* flattenPoints,
        const GpMatrix *matrix
        );

protected:

    VOID InitDefaultState()
    {
        SetValid(FALSE);
        Flags = 0;
        Types = NULL;
        FillMode = FillModeAlternate;
        SubpathCount = 0;
    }

    GpStatus
    ConvertToPerspectivePath(
        const GpPath* path,
        const GpRectF& rect,
        const GpPointF* points,
        INT count
        );

    GpStatus
    ConvertToBilinearPath(
        const GpPath* path,
        const GpRectF& rect,
        const GpPointF* points,
        INT count
        );

};


class GpXPathIterator
{
private:
    // We now use an ObjectTag to determine if the object is valid
    // instead of using a BOOL.  This is much more robust and helps
    // with debugging.  It also enables us to version our objects
    // more easily with a version number in the ObjectTag.
    ObjectTag           Tag;    // Keep this as the 1st value in the object!

protected:
    VOID SetValid(BOOL valid)
    {
        Tag = valid ? ObjectTagXPathIterator : ObjectTagInvalid;
    }

public:
    GpXPathIterator(GpXPath* xpath);
    ~GpXPathIterator()
    {
        SetValid(FALSE);    // so we don't use a deleted object
    }
    INT Enumerate(GpXPoints* xpoints, BYTE* types);
    INT NextSubpath(INT* startIndex, INT* endIndex, BOOL* isClosed);
    INT EnumerateSubpath(GpXPoints* xpoints, BYTE* types);
    INT NextPathType(BYTE* pathType, INT* startIndex, INT* endIndex);
    INT EnumeratePathType(GpXPoints* xpoints, BYTE* types);

    BOOL IsValid() const
    {
        ASSERT((Tag == ObjectTagXPathIterator) || (Tag == ObjectTagInvalid)); 
    #if DBG
        if (Tag == ObjectTagInvalid)
        {
            WARNING1("Invalid XPathIterator");
        }
    #endif

        return (Tag == ObjectTagXPathIterator);
    }

private:
    VOID Initialize();

private:
    const BYTE* Types;
    GpXPoints XPoints;
    INT TotalCount;
    INT Index;
    INT SubpathStartIndex;
    INT SubpathEndIndex;
    INT TypeStartIndex;
    INT TypeEndIndex;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\flat\sources.inc ===
#****************************** File Header ******************************\
# File Name: Sources.Inc
#
# Copyright (c) 1999, Microsoft Corporation
#
# Project specific SOURCES file.
#
#***************************************************************************/

!ifndef GDIPROOT
GDIPROOT=$(ADVCORE_PATH)\gdiplus
!endif

!include $(GDIPROOT)\sources.inc

MAJORCOMP=windows
MINORCOMP=gdiplus
TARGETPATH=$(_OBJ_DIR)

## SubSystem must be 4.00 to load on Win95

SUBSYSTEM_VERSION=4.00
USE_MAPSYM=1

C_DEFINES=$(C_DEFINES) -DWINVER=0x0500
INCLUDES=..;..\..;..\..\..\sdkinc;..\..\..\ddkinc;..\..\Entry
INCLUDES=$(INCLUDES);$(GDIPIMG)\api

SYNCHRONIZE_DRAIN=1

SOURCES=\
        ..\FlatApi.cpp \
        ..\FlatDdi.cpp \
        ..\gdiplus.rc

COMBINELIBS=                                              \
        ..\..\render\$(O)\Render.lib                      \
        ..\..\PDrivers\$(O)\PDrivers.lib                  \
        ..\..\Common\$(O)\Common.lib                      \
        ..\..\Entry\$(O)\Entry.lib                        \
        ..\..\ddi\$(O)\ddi.lib                            \
        ..\..\fondrv\tt\scaler\$(O)\fscaler.lib           \
        ..\..\fondrv\tt\ttfd\$(O)\ttfd.lib                \
        ..\..\gpmf3216\$(O)\gpmf3216.lib                  \
        ..\..\Text\lib\$(O)\gpotls.lib                    \
        ..\..\Text\lib\$(O)\unilib.lib                    \
        ..\..\Text\lib\$(O)\shaping.lib                   \
        ..\..\Text\lib\$(O)\TextImager.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\flat\precomp.hpp ===
#include "..\Runtime\Runtime.hpp"
#include "..\Common\Common.hpp"

#include "..\..\privinc\imaging.h"
#include "codecmgr.hpp"
#include "imgutils.hpp"
//#include "..\..\sdkinc\GdiplusFontFamily.h"

#include "..\..\ddkinc\ddiplus.hpp"

// Hack
#include "..\Render\scan.hpp"
#include "..\Render\scandib.hpp"
// EndHack

#include "initialize.hpp"
#include "Object.hpp"
#include "DpRegion.hpp"
#include "region.hpp"
#include "intmap.hpp"
#include "..\fondrv\tt\ttfd\fontddi.h"
#include "fontFace.hpp"
#include "family.hpp"
#include "font.hpp"
#include "stringFormat.hpp"
#include "fontable.hpp"
#include "fontlinking.hpp"
#include "..\fondrv\tt\ttfd\mapfile.h"
#include "fontfile.hpp"
#include "fontcollection.hpp"
#include "path.hpp"
#include "ImageAttr.hpp"
#include "gpbitmap.hpp"
#include "brush.hpp"
#include "CustomLineCap.hpp"
#include "pen.hpp"
#include "Metafile.hpp"
#include "DrawGlyphData.hpp"

#include "device.hpp"
#include "graphics.hpp"
#include "QuadTransforms.hpp"
#include "CachedBitmap.hpp"
#include "..\common\monitors.hpp"
#include "..\common\testcontrol.hpp"
#include "..\render\httables.hpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\flat\lib\makefile.inc ===
$(O)\gdipstat.lib: $(O)\gpbroken.lib
        workaround.bat $(O)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\flat\officehack\officehack.cpp ===
#include <windows.h>
#include <initguid.h>
#include "imgguids.h"
#include "gdiplusmem.h"
#include <math.h>

typedef VOID (__cdecl *DEBUGEVENTFUNCTION)(INT level, CHAR *message);

extern "C" BOOL __stdcall InitializeGdiplus(DEBUGEVENTFUNCTION debugEventFunction) { return TRUE; }
extern "C" VOID __stdcall UninitializeGdiplus() {}

extern "C" void *GpMalloc(size_t size) {
    return GdipAlloc(size);
}

extern "C" void GpFree(void *p) {
    GdipFree(p);
}

extern "C" void *GpMallocDebug(size_t size, char *fileName, INT lineNumber) {
    return GdipAlloc(size);
}
namespace GpRuntime
{
    double __stdcall Exp(double x)
    {
        return exp(x);
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\flat\dll\dllentry.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   GDIPLUS.DLL entry point
*
* Abstract:
*
*   DLL initialization and uninitialization.
*
* Revision History:
*
*   09/08/1999 agodfrey
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"

/**************************************************************************\
*
* DllInitialize:
*
*   This is the very first function call into GDI+, and takes place
*   when the DLL is first loaded.  We do some one-time initialization
*   here.
*
*   NOTE: Add GDI+ specific functionality to InitializeGdiplus(), not here!
*
* Revision History:
*
*   12/02/1998 andrewgo
*       Created it.
*   09/08/1999 agodfrey
*       Moved to Flat\Dll\DllEntry.cpp
*
\**************************************************************************/

//
// DLL instance handle
//

extern HINSTANCE DllInstance;

extern "C"
BOOL
DllMain(
    HINSTANCE   dllHandle,
    ULONG       reason,
    CONTEXT*    context
    )
{
    BOOL b = TRUE;

    switch (reason)
    {
    case DLL_PROCESS_ATTACH:
        {
            DllInstance = dllHandle;

            __try
            {
                GdiplusStartupCriticalSection::InitializeCriticalSection();
            }
            __except(EXCEPTION_EXECUTE_HANDLER)
            {
                // We couldn't allocate the criticalSection
                // Return an error
                b = FALSE;
            }
    
            // To improve the working set, we tell the system we don't
            // want any DLL_THREAD_ATTACH calls:
    
            DisableThreadLibraryCalls((HINSTANCE) dllHandle);
    
            break;
        }    

    case DLL_PROCESS_DETACH:
        // If we could use an assertion here, I'd assert that 
        // Globals::LibraryInitRefCount == 0.
        // But ASSERT would crash here, since we've shut down already.
        
        GdiplusStartupCriticalSection::DeleteCriticalSection();
        break;
    }

    return(b);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\flat\crtcheck\crtcheck.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   C runtime reference detector
*
* Abstract:
*
*   This is used to create the dummy CrtCheck.DLL, which checks
*   that we aren't using any illegal CRT functions.
*
*   CrtCheck.DLL isn't expected to run - this is only a linking test.
*
*   Because Office disallows use of MSVCRT, we can only call CRT functions
*   that are either provided by Office or reimplemented by us.
*
* Notes:
*
*   
*
* Created:
*
*   09/01/1999 agodfrey
*
\**************************************************************************/

#ifdef  _WIN64
typedef unsigned __int64 size_t;
#else
typedef unsigned int     size_t;
#endif
typedef unsigned short wchar_t;
typedef char *  va_list;
typedef long    time_t;

/*
    The following references are supported by Office
*/

extern "C" {    
    long __cdecl _ftol(float) { return 0; }
}

extern "C" const int _except_handler3 = 0;
extern "C" const int _except_list = 0;
extern "C" const int _fltused = 0;    

int __cdecl _purecall(void) { return 0; }
extern "C" const int _chkstk = 0;

// They told us they didn't support memmove, but it turns out that they have a
// definition for it. Anyway, some references to it crept in while crtcheck
// was broken, so this has to be here until that's resolved.
extern "C" void *  __cdecl memmove(void *, const void *, size_t) { return 0; }

/*
    The following references are implemented by us
*/

extern "C" {
    int __stdcall DllInitialize(int, int, int) { return 0; }
}

/* The following functions have intrinsic forms, 
   so we can use them safely:
   atan, atan2, cos, log, log10, sin, sqrt, tan
        
   If the /Og compiler option is not specified (e.g. in checked builds),
   the compiler generates out-of-line references to _CIatan etc., so we
   need to define them here.
   
   exp is an exception. It's in MSDN's list of intrinsic functions, but
   the compiler doesn't inline it if you specify /Os (optimize for space),
   which is what we always use. So we can't use exp, even though it's
   intrinsic. Use our replacement (Exp) instead.
*/
   
extern "C" {
//  We can't use this:
//  double  __cdecl _CIexp(double) { return 0; }

    double  __cdecl _CIatan(double) { return 0; }
    double  __cdecl _CIatan2(double, double) { return 0; }
    double  __cdecl _CIcos(double) { return 0; }
    double  __cdecl _CIlog(double) { return 0; }
    double  __cdecl _CIlog10(double) { return 0; }
    double  __cdecl _CIsin(double) { return 0; }
    double  __cdecl _CIsqrt(double) { return 0; }
    double  __cdecl _CItan(double) { return 0; }
}

/*
    The following references are needed for debugging.
    But they're only legal in the checked build.
    
    3/6/00 [agodfrey]: Office wants our debug builds too, so I'm checking
        with them on the legality of these references.
*/        

#ifdef DBG
extern "C" {
    int __cdecl rand(void) { return 0; }
    void __cdecl srand(unsigned int) { }
    time_t __cdecl time(time_t *) { return 0; }

    char *  __cdecl strrchr(const char *, int) { return 0; }
    int __cdecl printf(const char *, ...) { return 0; }
    int __cdecl _vsnprintf(char *, size_t, const char *, va_list) { return 0; }
    int __cdecl _snprintf(char *, size_t, const char *, ...) { return 0; }

// (* sigh *)
    void *  __cdecl memcpy(void *, const void *, size_t);
#pragma function(memcpy)    
    void *  __cdecl memcpy(void *, const void *, size_t) { return 0; }

    int __cdecl vsprintf(char *, const char *, va_list) { return 0; }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\flat\dll\makefile.inc ===
$(O)\gdiplus.def: gdiplus.def
    $(C_PREPROCESSOR) gdiplus.def > $@

$(O)\gdiplus.static.def: gdiplus.def
    $(C_PREPROCESSOR) gdiplus.def /DGP_STATIC_BUILD > $@


$(SDK_LIB_DEST)\$(ALT_PROJECT_TARGET)\$(TARGET_DIRECTORY)\gdiplus.lib : $(O)\gdiplus.lib
    $(PUBLISH_CMD) {$?=$@}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\fondrv\tt\scaler\fnt.h ===
/*
	File:       fnt.h

	Contains:   xxx put contents here (or delete the whole line) xxx

	Written by: xxx put name of writer here (or delete the whole line) xxx

	Copyright:  (c) 1987-1990, 1992 by Apple Computer, Inc., all rights reserved.
				(c) 1989-1999. Microsoft Corporation, all rights reserved.

	Change History (most recent first):

				 7/10/99  BeatS		Add support for native SP fonts, vertical RGB
		  <>     4/30/97    CB      ClaudeBe, catching infinite loops/recursions
	      <>     2/21/97    CB      ClaudeBe, scaled component in composite glyphs
	      <>     2/05/96    CB      ClaudeBe, add bHintForGray in globalGS
	   <11+>     9/15/90    MR,rb   Change pvx and pvy to proj.[xy].  Same for freedom vector.
									Conditionalize vectors for Fracts or ShortFracts.
		<10>     7/26/90    MR      rearrange local graphic state, remove unused parBlockPtr
		 <9>     7/18/90    MR      change loop variable from long to short, and other Ansi-changes
		 <8>     7/13/90    MR      Prototypes for function pointers
		 <5>      6/4/90    MR      Remove MVT
		 <4>      5/3/90    RB      replaced dropoutcontrol with scancontrolin and scancontrol out
									in global graphics state
		 <3>     3/20/90    CL      fields for multiple preprograms fields for ppemDot6 and
									pointSizeDot6 changed SROUND to take D/2 as argument
		 <2>     2/27/90    CL      Added DSPVTL[] instruction.  Dropoutcontrol scanconverter and
									SCANCTRL[] instruction
	   <3.1>    11/14/89    CEL     Fixed two small bugs/feature in RTHG, and RUTG. Added SROUND &
									S45ROUND.
	   <3.0>     8/28/89    sjk     Cleanup and one transformation bugfix
	   <2.2>     8/14/89    sjk     1 point contours now OK
	   <2.1>      8/8/89    sjk     Improved encryption handling
	   <2.0>      8/2/89    sjk     Just fixed EASE comment
	   <1.7>      8/1/89    sjk     Added composites and encryption. Plus some enhancements.
	   <1.6>     6/13/89    SJK     Comment
	   <1.5>      6/2/89    CEL     16.16 scaling of metrics, minimum recommended ppem, point size 0
									bug, correct transformed integralized ppem behavior, pretty much
									so
	   <1.4>     5/26/89    CEL     EASE messed up on "c" comments
	  <,1.3>     5/26/89    CEL     Integrated the new Font Scaler 1.0 into Spline Fonts

	To Do:
*/
/*  rwb 4/24/90 Replaced dropoutControl with scanControlIn and scanControlOut in
		global graphics state. 
		<3+>     3/20/90    mrr     Added support for IDEFs.  Made funcDefs long aligned
									by storing int16 length instead of int32 end.
*/

#ifndef FNT_DEFINED
#define FNT_DEFINED

#define STUBCONTROL 0x10000
#define NODOCONTROL 0x20000

#define FNT_PIXELSIZE  ((F26Dot6)0x40)
#define FNT_PIXELSHIFT 6

// public phantom points (cf. scale.c for private phantom points), relative to number of points in glyph
#define LEFTSIDEBEARING		0
#define RIGHTSIDEBEARING	1

#define TOPSIDEBEARING		2
#define BOTTOMSIDEBEARING	3

#define VECTORTYPE	ShortFract

#define NON90DEGTRANS_ROTATED	0x01
#define NON90DEGTRANS_STRETCH	0x02

#ifdef FSCFG_SUBPIXEL
/* For the SubPixel hinting flag field, internal flags */
#define FNT_SP_SUB_PIXEL			0x0001      /* set when calling fs_NewTransformation() */
#define FNT_SP_COMPATIBLE_WIDTH		0x0002      /* set when calling fs_NewTransformation() */
#define FNT_SP_VERTICAL_DIRECTION	0x0004		// set when calling fs_NewTransformation()
#define FNT_SP_BGR_ORDER			0x0008		// set when calling fs_NewTransformation()

#define SPCF_iupxCalled				0x0001		// individual bits of GlobalGS.subPixelCompatibilityFlags
#define SPCF_iupyCalled				0x0002
#define SPCF_inDiagEndCtrl			0x0004
#define SPCF_inVacuformRound		0x0008
#define SPCF_inSkippableDeltaFn		0x0010
#define SPCF_detectedDandIStroke	0x0100
#define SPCF_detectedJellesSpacing	0x0200
#define SPCF_detectedVacuformRound	0x0400
#define SPCF_detectedTomsDiagonal	0x0800


#endif // FSCFG_SUBPIXEL

#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA

	#define BADREL	0x01
	#define DONE	0x02
	#define DOING	0x04

	// Data structure for information leap. This information leap is necessary because of the following reason:
	// Technically, what we're doing is to automatically add on-the-fly in-line deltas to the stream of instructions. Such deltas appear
	// after an incoming "link" (MIRP, MDRP), but before one or more outgoing "links". If one of these outgoing links controls a stroke,
	// then this stroke's phase may need to be adjusted (by a delta). However, we don't know whether any of the outgoing links controls a
	// stroke, nor which one, until we've interpreted them all, at which point it is too late to apply a delta, because the delta has to be
	// applied before any outgoing links (dependency). Conversely, the incoming link does not bear any information that would suggest that
	// it links to a stroke (don't know the future). To make matters worse, it is possible that in the stream of instructions the link that
	// controls a stroke comes at the very end of the TT code, even though there may have been many other, unrelated instructions inbetween.
	// Therefore, we have to interpert the entire TT code (upto the IUP instruction in the SP direction) before we know all we need to 
	// calculate and apply the phase control.
	
	typedef struct {
		int16 parent0,parent1; // -1 for none
		int16 child; // for black links (we can satisfy 1 phase shift only, hence no need for several children), else -1
		uint16 flags; // BADREL, DONE, DOING
		F26Dot6 phaseShift;
	} PhaseControlRelation; // 12 bytes (?)
	
#endif

typedef struct VECTOR {
	VECTORTYPE x;
	VECTORTYPE y;
} VECTOR;

typedef struct {
	F26Dot6 *x;         /* The Points the Interpreter modifies */
	F26Dot6 *y;         /* The Points the Interpreter modifies */
	F26Dot6 *ox;        /* Old Points */
	F26Dot6 *oy;        /* Old Points */
	F26Dot6 *oox;       /* Old Unscaled Points, really ints */
	F26Dot6 *ooy;       /* Old Unscaled Points, really ints */
	uint8   *onCurve;   /* indicates if a point is on or off the curve */
	int16   *sp;        /* Start points */
	int16   *ep;        /* End points */
	uint8   *f;         /* Internal flags, one byte for every point */
	int16   nc;         /* Number of contours */
	uint8   *fc;         /* contour flags, one byte for every contour */
#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	boolean phaseControlExecuted;
	PhaseControlRelation *pcr;
#endif
} fnt_ElementType;

/* flags for contour flags : */
#define OUTLINE_MISORIENTED 1

typedef struct {
	int32 start;        /* offset to first instruction */
	uint16 length;      /* number of bytes to execute <4> */
	uint16 pgmIndex;    /* index to appropriate preprogram for this func (0..1) */
} fnt_funcDef;

/* <4> pretty much the same as fnt_funcDef, with the addition of opCode */
typedef struct {
	int32 start;
	uint16 length;
	uint8  pgmIndex;
	uint8  opCode;
} fnt_instrDef;

typedef struct {
	uint8 *    Instruction;
	uint32     Length;
} fnt_pgmList;

struct fnt_LocalGraphicStateType;
typedef void (FS_CALLBACK_PROTO *FntTraceFunc)(struct fnt_LocalGraphicStateType*, uint8*);

#ifdef FSCFG_REENTRANT
typedef uint8* (*FntFunc)(struct fnt_LocalGraphicStateType*, uint8*, int32);
typedef void (*FntMoveFunc)(struct fnt_LocalGraphicStateType*, fnt_ElementType*, int32, F26Dot6);
typedef F26Dot6 (*FntProject)(struct fnt_LocalGraphicStateType*, F26Dot6, F26Dot6);
typedef void (*InterpreterFunc)(struct fnt_LocalGraphicStateType*, uint8*, uint8*);
typedef F26Dot6 (*FntRoundFunc)(struct fnt_LocalGraphicStateType*, F26Dot6, F26Dot6);
#else 
typedef uint8* (*FntFunc)(uint8*, int32);
typedef void (*FntMoveFunc)(fnt_ElementType*, int32, F26Dot6);
typedef F26Dot6 (*FntProject)(F26Dot6 x, F26Dot6 y);
typedef void (*InterpreterFunc)(uint8*, uint8*);
typedef F26Dot6 (*FntRoundFunc)(F26Dot6 xin, F26Dot6 engine);
#endif 

typedef struct {

/* PARAMETERS CHANGEABLE BY TT INSTRUCTIONS */
	F26Dot6 wTCI;                   /* width table cut in */
	F26Dot6 sWCI;                   /* single width cut in */
	F26Dot6 scaledSW;               /* scaled single width */
	int32 scanControl;              /* controls kind and when of dropout control */
	int32 instructControl;          /* controls gridfitting and default setting */
	
	F26Dot6 minimumDistance;        /* moved from local gs  7/1/90  */
	FntRoundFunc RoundValue;        /*                              */
#ifdef FSCFG_SUBPIXEL
	uint16		roundState;			// see comments in interp.c
#endif
	F26Dot6 periodMask;             /* ~(gs->period-1)              */
	VECTORTYPE period45;            /*                              */
	int16   period;                 /* for power of 2 periods       */
	int16   phase;                  /*                              */
	int16   threshold;              /* moved from local gs  7/1/90  */

	int16 deltaBase;
	int16 deltaShift;
	int16 angleWeight;
	int16 sW;                       /* single width, expressed in the same units as the character */
	int8 autoFlip;                  /* The auto flip Boolean */
	int8 pad;   
#ifndef FSCFG_NOPAD_PARAMETER_BLOCK_4
	int16 pad2;   
#endif 
} fnt_ParameterBlock;               /* this is exported to client */

#define PREPROGRAM     0
#define FONTPROGRAM    1
#define GLYPHPROGRAM   2

#define MAXPREPROGRAMS 2

#ifdef FSCFG_SUBPIXEL
	#define maxDeltaFunctions	4
#endif

typedef struct fnt_ScaleRecord {
	Fixed fixedScale;       /* Slow Scale */
	int32 denom;            /* Fast and Medium Scale */
	int32 numer;            /* Fast and Medium Scale */
	int32 shift;            /* Fast Scale */
} fnt_ScaleRecord;

typedef F26Dot6 (*GlobalGSScaleFunc)(fnt_ScaleRecord*, F26Dot6);

typedef struct fnt_GlobalGraphicStateType {
	F26Dot6* stackBase;             /* the stack area */
	F26Dot6* store;                 /* the storage area */
	F26Dot6* controlValueTable;     /* the control value table */
	
	uint16  pixelsPerEm;            /* number of pixels per em as an integer */
	uint16  pointSize;              /* the requested point size as an integer */
	Fixed   fpem;                   /* fractional pixels per em    <3> */
	F26Dot6 engine[4];              /* Engine Characteristics */
	
	fnt_ParameterBlock defaultParBlock; /* variables settable by TT instructions */
	fnt_ParameterBlock localParBlock;

	/* Only the above is exported to Client throught FontScaler.h */

/* VARIABLES NOT DIRECTLY MANIPULABLE BY TT INSTRUCTIONS  */
	
	fnt_funcDef*    funcDef;           /* function Definitions identifiers */
	fnt_instrDef*   instrDef;         /* instruction Definitions identifiers */
	GlobalGSScaleFunc ScaleFuncXChild; /* child scaling when !bSameTransformAsMaster */
	GlobalGSScaleFunc ScaleFuncYChild; /* child scaling when !bSameTransformAsMaster */
	GlobalGSScaleFunc ScaleFuncX;
	GlobalGSScaleFunc ScaleFuncY;
	GlobalGSScaleFunc ScaleFuncCVT;
	fnt_pgmList     pgmList[MAXPREPROGRAMS];  /* each program ptr is in here */
	
/* These are parameters used by the call back function */
	fnt_ScaleRecord   scaleXChild; /* child scaling when !bSameTransformAsMaster */
	fnt_ScaleRecord   scaleYChild; /* child scaling when !bSameTransformAsMaster */
	fnt_ScaleRecord   scaleX;
	fnt_ScaleRecord   scaleY;
	fnt_ScaleRecord   scaleCVT;

	Fixed           cvtStretchX;
	Fixed           cvtStretchY;

	int8            identityTransformation;  /* true/false  (does not mean identity from a global sense) */
	int8            non90DegreeTransformation; /* bit 0 is 1 if non-90 degree, bit 1 is 1 if x scale doesn't equal y scale */
	Fixed           xStretch;           /* Tweaking for glyphs under transformational stress <4> */
	Fixed           yStretch;           /* Tweaking for glyphs under transformational stress <4> */
	
	int8            init;               /* executing preprogram ?? */
	/* !!! Should not be uint8, instead fnt_ProgramIndex */
	uint8           pgmIndex;           /* which preprogram is current */
	int32           instrDefCount;      /* number of currently defined IDefs */
	uint8			bSameStretch;
	uint8			bCompositeGlyph;	/* Flag that indicates composite glyph */
	LocalMaxProfile *	 maxp;
	uint16          cvtCount;
	Fixed           interpScalarX;      /* scalar for instructable things */
	Fixed           interpScalarY;      /* scalar for instructable things */
	Fixed           fxMetricScalarX;    /* scalar for metric things */
	Fixed           fxMetricScalarY;    /* scalar for metric things */
	/* int16  pad2; */

	boolean	bHintForGray;
	uint8			bSameTransformAsMaster;	/* for composite glyph, indicate the the sub-componenent has the same scaling than the master glyph */
	uint8			bOriginalPointIsInvalid;/* original point are invalid, we need to use ox/oy instead of scaling oox/ooy */

	uint32		ulMaxJumpCounter;			/* jump counter used to catch infinite loops */
	uint32		ulMaxRecursiveCall;		/* recursive calls counter used to check the level of recursion */
    ClientIDType            clientID;  /* client private id/stamp, it's saved here to allow a trace function to access it */
#ifdef FSCFG_SECURE
	F26Dot6* stackMax;             /* maximum stack area */
	int32      maxPointsIncludePhantom;  /* in an individual glyph, including maxCompositePoints  */
#endif // FSCFG_SECURE
	uint16	uBoldSimulVertShift; /* vertical and horizontal (along baseline) shift for embolding simulation */
	uint16	uBoldSimulHorShift;
	F26Dot6	fxScaledDescender; /* scaled descender, used to clip emboldening if necessary */
#ifdef FSCFG_SUBPIXEL
	uint16	flHintForSubPixel;
	uint16	subPixelCompatibilityFlags;
	uint16	numDeltaFunctionsDetected;		  // fns to implement delta instr for range of ppem sizes or odd delta size use SHPIX,
	uint16	deltaFunction[maxDeltaFunctions]; // keep track of these cases to intelligently skip SHPIX
	Fixed	compatibleWidthStemConcertina;
#endif // FSCFG_SUBPIXEL
	boolean bHintAtEmSquare;        /* hint at the design resolution, this flag is used for sub-pixel position
									   or text animation where we want to turn off gridfitting hinting
									   but for fonts where glyphs are build by hinting, we still want the
									   glyph shape to be correct */
} fnt_GlobalGraphicStateType;

/* 
 * This is the local graphics state  
 */
typedef struct fnt_LocalGraphicStateType {
	fnt_ElementType *CE0, *CE1, *CE2;   /* The character element pointers */
	VECTOR proj;                        /* Projection Vector */
	VECTOR free;                        /* Freedom Vector */
	VECTOR oldProj;                     /* Old Projection Vector */
	F26Dot6 *stackPointer;

	uint8 *insPtr;                      /* Pointer to the instruction we are about to execute */
	fnt_ElementType *elements;
	fnt_GlobalGraphicStateType *globalGS;
		FntTraceFunc TraceFunc;

	int32 Pt0, Pt1, Pt2;           /* The internal reference points */
	int16 roundToGrid;
	int32 loop;                         /* The loop variable */
	uint8 opCode;                       /* The instruction we are executing */
	uint8 padByte;
	int16 padWord;

	/* Above is exported to client in FontScaler.h */

	VECTORTYPE pfProj; /* = pvx * fvx + pvy * fvy */

	FntMoveFunc MovePoint;
	FntProject Project;
	FntProject OldProject;
	InterpreterFunc Interpreter;
#ifdef FSCFG_REENTRANT
		F26Dot6 (*GetCVTEntry) (struct fnt_LocalGraphicStateType*,int32);
		F26Dot6 (*GetSingleWidth) (struct fnt_LocalGraphicStateType*);
#else 
		F26Dot6 (*GetCVTEntry) (int32 n);
		F26Dot6 (*GetSingleWidth) (void);
#endif 
	FntMoveFunc ChangeCvt;
	Fixed       cvtDiagonalStretch;

	int16       MIRPCode;               /* for fast or slow MIRP's */

	ErrorCode   ercReturn;              /* NO_ERR unless illegal instruction */
	uint8       *pbyEndInst;            /* one past last instruction */
	uint8       *pbyStartInst;          /* used to detect a jump before the begining of the program */

	uint32		ulJumpCounter;			/* jump counter used to catch infinite loops */
	uint32		ulRecursiveCall;		/* recursive calls counter used to check the level of recursion */
#ifdef FSCFG_SUBPIXEL
	uint16		inSubPixelDirection;
#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	int16		pt0,pt1;
#endif
#endif
} fnt_LocalGraphicStateType;

#endif  /* FNT_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\fondrv\tt\scaler\fnterr.c ===
/**********************************************************************
	
	fnterr.c -- Error Support Routines.

	(c) Copyright 1992  Microsoft Corp.
	All rights reserved.

	This source file provides support for debugging routines in fnt.c
	(and macjob.c to a much lesser extent).  This module keys on the
	 #define FSCFG_FNTERR which is defined in fsconfig.h

	 7/28/92 dj         First cut.
	 8/12/94 deanb      included fnterr.h for mac
	12/07/94 deanb		changed %x to %hx or %lx; %d to %hd

 **********************************************************************/

#define FSCFG_INTERNAL

#include "fsconfig.h"
#include "fnterr.h"

#ifdef FSCFG_FNTERR
#include <stdio.h>
#include <string.h>
#include <ctype.h>

/* FILE * fopen(); */
int    abs (int);
/*
int    strlen (char*);
int    strcmp (char*, char*);
int    strcpy (char*, char*);
int    strncpy( char*, char *, int);
*/

#define ERR_MAX_IFS      8
#define ERR_MAX_CODE     16
#define ERR_MAX_FNAME    80
#define ERR_MAX_MSG  512

static int               errOpc;
static int               errBreak;
static int               errIfOk  = 1;
static unsigned short    errSize  = 0;
static unsigned short    errCode  = 0;
static int               errIfNdx = 0;
static long              errInstCount;
static int               errIfs[ERR_MAX_IFS];
static char              errOpName[ERR_MAX_CODE];
static char              errFname[ERR_MAX_FNAME];
static char            * errOpcs[] =
{
  "SVTCA_0",
  "SVTCA_1",
  "SPVTCA",
  "SPVTCA",
  "SFVTCA",
  "SFVTCA",
  "SPVTL",
  "SPVTL",
  "SFVTL",
  "SFVTL",
  "WPV",
  "WFV",
  "RPV",
  "RFV",
  "SFVTPV",
  "ISECT",
  "SetLocalGraphicState",
  "SetLocalGraphicState",
  "SetLocalGraphicState",
  "SetElementPtr",
  "SetElementPtr",
  "SetElementPtr",
  "SetElementPtr",
  "SetLocalGraphicState",
  "SetRoundState",
  "SetRoundState",
  "LMD",
  "ELSE",
  "JMPR",
  "LWTCI",
  "LSWCI",
  "LSW",
  "DUP",
  "SetLocalGraphicState",
  "CLEAR",
  "SWAP",
  "DEPTH",
  "CINDEX",
  "MINDEX",
  "ALIGNPTS",
  "RAW",
  "UTP",
  "LOOPCALL",
  "CALL",
  "FDEF",
  "IllegalInstruction",
  "MDAP",
  "MDAP",
  "IUP",
  "IUP",
  "SHP",
  "SHP",
  "SHC",
  "SHC",
  "SHE",
  "SHE",
  "SHPIX",
  "IP",
  "MSIRP",
  "MSIRP",
  "ALIGNRP",
  "SetRoundState",
  "MIAP",
  "MIAP",
  "NPUSHB",
  "NPUSHW",
  "WS",
  "RS",
  "WCVT",
  "RCVT",
  "RC",
  "RC",
  "WC",
  "MD",
  "MD",
  "MPPEM",
  "MPS",
  "FLIPON",
  "FLIPOFF",
  "DEBUG",
  "BinaryOperand",
  "BinaryOperand",
  "BinaryOperand",
  "BinaryOperand",
  "BinaryOperand",
  "BinaryOperand",
  "UnaryOperand",
  "UnaryOperand",
  "IF",
  "EIF",
  "BinaryOperand",
  "BinaryOperand",
  "UnaryOperand",
  "DELTAP1",
  "SDB",
  "SDS",
  "BinaryOperand",
  "BinaryOperand",
  "BinaryOperand",
  "BinaryOperand",
  "UnaryOperand",
  "UnaryOperand",
  "UnaryOperand",
  "UnaryOperand",
  "ROUND",
  "ROUND",
  "ROUND",
  "ROUND",
  "NROUND",
  "NROUND",
  "NROUND",
  "NROUND",
  "WCVTFOD",
  "DELTAP2",
  "DELTAP3",
  "DELTAC1",
  "DELTAC2",
  "DELTAC3",
  "SROUND",
  "S45ROUND",
  "JROT",
  "JROF",
  "SetRoundState",
  "IllegalInstruction",
  "SetRoundState",
  "SetRoundState",
  "SANGW",
  "AA",
  "FLIPPT",
  "FLIPRGON",
  "FLIPRGOFF",
  "IDefPatch",
  "IDefPatch",
  "SCANCTRL",
  "SDPVTL",
  "SDPVTL",
  "GETINFO",
  "IDEF",
  "ROTATE",
  "BinaryOperand",
  "BinaryOperand",
  "SCANTYPE",
  "INSTCTRL",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "PUSHB",
  "PUSHB",
  "PUSHB",
  "PUSHB",
  "PUSHB",
  "PUSHB",
  "PUSHB",
  "PUSHB",
  "PUSHW",
  "PUSHW",
  "PUSHW",
  "PUSHW",
  "PUSHW",
  "PUSHW",
  "PUSHW",
  "PUSHW",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP"
};

/*
  errOutput() - writes an error to standard out and to a log file.  the
  log file is always opened and closes in order to avoid file corruption
  by an application gone wild.
*/
static void errOutput( char * );
static void errOutput( char * msg )
{
  static  int firsttime = 1;
  FILE  * fp;

  printf("%s", msg);
  fp = fopen ("compfont.err", (firsttime ? "w" : "a"));
  if (fp)
  {
	fprintf (fp, "%s", msg);
	fclose (fp);
  }
  firsttime = 0;
  return;
}

/*
  errPrint() - used to generate a useful (?) error message based on the 
  error 'flag' and the parameters ('v1..v4').
*/
static void errPrint (int, long, long, long, long);
static void errPrint (int flag, long v1, long v2, long v3, long v4)
{
  char   msg[ERR_MAX_MSG];
  char * opcodeName;
  char   c;
  int    i;

/*
  build the context line.  it indicates the file being processed, the point
  size, the character code (or glyph index), as well as the releative inst 
  number of this instruction for this code.
*/
  i  = sprintf (msg,   "\n*** ERROR*** ");
  i += sprintf (msg+i, "\"%s\", ", errFname);
  i += sprintf (msg+i, "%hd Point, ", errSize);
  i += sprintf (msg+i, "Code %hd (0x%hX), ", errCode, errCode);
  i += sprintf (msg+i, "Inst: #%ld\n", errInstCount);

/*
  build the error line.  it indicates the name of the instruction followed
  by the actual error information.  note: finding the actual opcode name
  for some the instructions is sorta kludgy.  names like "SetLocalGraphicState",
  and "BinaryOperand" are not actual instructions.  In these cases, look to
  the second character of the name - if it is lower case, then we need to 
  work a little harder, so look to 'errOpName' (which should be set by this
  point) it should contain the correct instruction name.
*/
  c = *(errOpcs[errOpc]+1);
  opcodeName =(islower(c) && strlen(errOpName)) ? errOpName : errOpcs[errOpc];
  i += sprintf (msg+i, "(%s) ", opcodeName);
  errOpName[0] = '\0';

/*
  output what you have so far and then process the error
*/
  errOutput (msg);
  switch (flag)
  {
	case ERR_RANGE:
	  sprintf (msg, "Value out of range: value = %ld, range = %ld .. %ld\n",
				v1, v2, v3); 
	  break;
	case ERR_ASSERTION:
	  sprintf (msg, "Assertion check failed\n"); 
	  break;
	case ERR_CVT:
	  sprintf (msg, "CVT out of range: CVT = %ld, range = %ld .. %ld\n",
				v1, v2, v3); 
	  break;
	case ERR_FDEF:
	  sprintf (msg, "FDEF out of range: FDEF = %ld, range = %ld .. %ld\n",
				v1, v2, v3); 
	  break;
	case ERR_ELEMENT:
	  sprintf (msg, "Element %ld exceeds max elements (%ld)\n", v1, v2, v3); 
	  break;
	case ERR_CONTOUR:
	  i = sprintf (msg, "CONTOUR out of range: ");
	sprintf (msg+i, "CONTOUR = %ld, range = %ld .. %ld\n", v1, v2, v3); 
	  break;
	case ERR_POINT:
	  i = sprintf (msg, "POINT out of range: ");
	sprintf (msg+i, "POINT = %ld, range = %ld .. %ld\n", v1, v2, v3); 
	  break;
	case ERR_INDEX:
	  i = sprintf (msg, "POINT 0x%lX is neither element[0] ", v1);
	  sprintf( msg+i, "(0x%lX) nor element[1] (0x%lX)\n", v2, v3); 
	  break;
	case ERR_STORAGE:
	  i = sprintf (msg, "Storage index out of range: ");
	sprintf (msg+i, "Index = %ld, range = %ld .. %ld\n", v1, v2, v3); 
	  break;
	case ERR_STACK:
	  i = sprintf (msg, "Stack pointer out of range: ");
	sprintf (msg+i, "Pointer = %ld, range = %ld .. %ld\n", v1, v2, v3); 
	  break;
	case ERR_VECTOR:
	  sprintf (msg, "Illegal (x.y) vector: (%ld.%ld)\n", v1, v2); 
	  break;
	case ERR_LARGER:
	  sprintf (msg, "Value too small: %ld is not larger than %ld\n", v2, v1); 
	  break;
	case ERR_INT8:
	  sprintf (msg, "Value too large: 0x%lX exceeds 1 byte capacity\n", v1);
	  break;
	case ERR_INT16:
	  sprintf (msg, "Value too large: 0x%lX exceeds 2 byte capacity\n", v1);
	  break;
	case ERR_SCANMODE:
	  sprintf (msg, "Invalid scan mode: %ld\n", v1);
	  break;
	case ERR_SELECTOR:
	  sprintf (msg, "Invalid scan value: %ld\n", v1);
	  break;
	case ERR_STATE:
	  i = sprintf (msg, "Boundry limit error: xmin = ");
	  sprintf (msg+1, "%ld, xmax = %ld, ymin = %ld, ymax = %ld\n",
				v1, v2, v3, v4); 
	  break;
	case ERR_GETSINGLEWIDTHNIL:
	  sprintf (msg, "Sanity: Single width is nil\n");
	  break;
	case ERR_GETCVTENTRYNIL:
	  sprintf (msg, "Sanity: CVT Entry is nil\n");
	  break;
	case ERR_INVOPC:
	  sprintf (msg, "Invalid opcode: %ld\n", v1);
	  break;
	case ERR_UNBALANCEDIF:
	  sprintf (msg, "Unbalanced: missing %s instruction\n",
				( v1 > 0 ) ? "EIF" : "IF" );
	  break;
	default:
	  sprintf (msg, "Unknown Error:\n");
	  break;
  }

/*
  output the rest and return
*/
  errOutput (msg);
  return;
}

/*
  fnterr_Context() - called before any other fnterr routine.  it records
  the job name, character size and character code / glyph index.
*/
void fnterr_Context (int sw, char * str, unsigned short sz, unsigned short cd)
{
/*
  record a piece of the context
*/
  switch (sw)
  {
	case ERR_CONTEXT_FILE:
	  strncpy ( errFname, str, ERR_MAX_FNAME);
	  errFname[ERR_MAX_FNAME-1] = '\0';
	  break;
	case ERR_CONTEXT_SIZE:
	  errSize = sz;
	  break;
	case ERR_CONTEXT_CODE:
	  errCode = cd;
	  break;
  }

/*
  reset errOpName to be NULL before we start any real processing
*/
  errOpName[0] = '\0';
  return;
}

/*
  fnterr_Start() - called before the main execute loop of fnt_Execute() and
  fnt_TraceExecute().  it resets the instruction count to zero, and errBreak
  to 0 (ie: don't break out of execution loop).  set up IF/EIF counter for
  this level.
*/
void fnterr_Start (void)
{
  errInstCount = 0L;
  errBreak = 0;

  if (errIfOk && (++errIfNdx < ERR_MAX_IFS ))
	errIfs[errIfNdx] = 0;
  else
	errIfOk = 0;

  return;
}

/*
  fnterr_Record() - called inside the main execute loop of fnt_Execute()
  and fnt_TraceExecute().  it increments the instruction count, and resets
  the opcode number.  IFs or EIFs are accounted for. (note: other IFs and
  EIFs will be accounted for by calls to ERR_IF() in fnt.c)
*/
void fnterr_Record (int opc)
{
  errInstCount++;
  errOpc = opc;

  if (!strcmp ("IF", errOpcs[errOpc]))
	fnterr_If (1);
  else if (!strcmp ("EIF", errOpcs[errOpc]))
	fnterr_If (-1);

  return;
}

/*
  fnterr_Report() - called inside the main execute loop of fnt_Execute()
  and fnt_TraceExecute().  it calls errPrint() (with the passed parameters)
  to note the error, and sets errBreak so that the execution loop will end.
*/
void fnterr_Report (int flag, long v1, long v2, long v3, long v4)
{
  errPrint (flag, v1, v2, v3, v4);
  errBreak = 1;
  return;
}

/*
  fnterr_Break() - returns the value of errBreak.  if a non-zero valid is
  returned (re: fnterr_Report()), the main execute loop of fnt_Execute()
  or fnt_TraceExecute() will terminate.
*/
int fnterr_Break (void)
{
  return (errBreak);
}

/*
  fnterr_Opc() - called by combinate fnt calls to indicate the actual
  opcode errGet() can use.  this is a kludgy way to get around the non
  real opcode name in the errOpcs[] table.
*/
void fnterr_Opc (char *opc)
{
  strcpy (errOpName, opc);
  return;
}

/*
  fnterr_End() - called after the main execute loop of fnt_Execute() and
  fnt_TraceExecute().  it checks for balanced IF/EIF pairs.
*/
void fnterr_End (void)
{
  if (errIfOk)
  {
	if (errIfs[errIfNdx])
	  errPrint (ERR_UNBALANCEDIF, (long)errIfs[errIfNdx], 0L, 0L, 0L);
	if (--errIfNdx < 0)
	  errIfOk = 0;
  }
  return;
}

/*
  fnterr_If() - records IF/EIF activity inside of fnt_IF(), fnt_ELSE() and
  fnt_EIF() (re: fnt.c).
*/
void fnterr_If (int val)
{
  if (errIfOk)
	errIfs[errIfNdx] += val;
  return;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\fondrv\tt\scaler\fnterr.h ===
#ifndef _FNTERR_H
#define _FNTERR_H
/**********************************************************************
	
	fnterr.h -- Error Support Routines prototypes.

	(c) Copyright 1992  Microsoft Corp.
	All rights reserved.

	This header file provides prototypes for the fnterr.c 
	 source module.  This module keys on the #define FSCFG_FNTERR
	which is defined in fsconfig.h

	 7/28/92 dj         First cut.

 **********************************************************************/


#ifdef FSCFG_FNTERR

#define ERR_RANGE                 1
#define ERR_ASSERTION             2
#define ERR_CVT                   3
#define ERR_FDEF                  4
#define ERR_ELEMENT               5
#define ERR_INDEX                 6
#define ERR_STORAGE               7
#define ERR_STACK                 8
#define ERR_POINT                 9
#define ERR_POINT_TLP             10
#define ERR_POINT_PP              11
#define ERR_CONTOUR               12
#define ERR_VECTOR                13
#define ERR_LARGER                14
#define ERR_INT8                  15
#define ERR_INT16                 16
#define ERR_SCANMODE              17
#define ERR_SELECTOR              18
#define ERR_STATE                 19
#define ERR_GETSINGLEWIDTHNIL     20
#define ERR_GETCVTENTRYNIL        21
#define ERR_INVOPC                22
#define ERR_UNBALANCEDIF          23

#define ERR_CONTEXT_FILE          0
#define ERR_CONTEXT_SIZE          1
#define ERR_CONTEXT_CODE          2

#define ERR_CONTEXT(a,b,c,d)      fnterr_Context((a),(b),(c),(d))
#define ERR_START()               fnterr_Start()
#define ERR_RECORD(a)             fnterr_Record((int)(a))
#define ERR_REPORT(a,b,c,d,e)     fnterr_Report((int)(a),(long)(b),(long)(c),(long)(d),(long)(e))
#define ERR_BREAK()               { if ( fnterr_Break() ) break; }
#define ERR_OPC(a)                fnterr_Opc(a)
#define ERR_END()                 fnterr_End()
#define ERR_IF(a)                 fnterr_If(a)

void fnterr_Context (int, char *, unsigned short, unsigned short);
void fnterr_Start (void);
void fnterr_Record (int);
void fnterr_Report (int, long, long, long, long);
int  fnterr_Break (void);
void fnterr_Opc (char*);
void fnterr_End (void);
void fnterr_If (int);

#else

#define ERR_CONTEXT(a,b,c,d)
#define ERR_START()
#define ERR_RECORD(a)
#define ERR_REPORT(a,b,c,d,e)     DEBUGGER ()
#define ERR_BREAK()
#define ERR_OPC(a)
#define ERR_END()
#define ERR_IF(a)

#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\fondrv\tt\scaler\fontmath.h ===
/*
		File:           fontmath.h

		Contains:       xxx put contents here xxx

		Written by:     xxx put writers here xxx

		Copyright:      c 1990 by Apple Computer, Inc., all rights reserved.
						(c) 1989-1997. Microsoft Corporation, all rights reserved.

		Change History (most recent first):

				  <>     2/21/97		CB				ClaudeBe, add mth_UnitarySquare for scaled component in composite glyphs
				 <4>    11/27/90        MR              make pascal declaration a macro, conditionalize traps -vs-
																		externs for Fix/Frac math routines. [ph]
				 <3>     11/5/90        MR              Move [U]SHORTMUL into fscdefs.h Rename FixMulDiv to LongMulDiv.
																		[rb]
				 <2>    10/20/90        MR              Add some new math routines (stolen from skia). [rj]
				 <1>     4/11/90        dba             first checked in

		To Do:
*/
#ifdef __cplusplus
extern "C" {
#endif

#define HIWORDMASK              0xffff0000
#define LOWORDMASK              0x0000ffff
#define DOT6ONEHALF             0x00000020
#define ONESHORTFRAC            (1 << 14)

#define ROUNDFIXTOINT( x )      (int16)((((Fixed) x) + ONEHALFFIX) >> 16)
#define ROUNDFIXED( x )         (((x) + (Fixed)ONEHALFFIX) & (Fixed)HIWORDMASK)
#define DOT6TOFIX(n)            ((Fixed) (n) << 10)
#define FIXEDTODOT6(n)          (F26Dot6) (((n) + ((1) << (9))) >> 10)
#define INTTOFIX(n)             ((Fixed) (n) << 16)
#define INTTODOT6(n)            ((F26Dot6) (n) << 6)
#define FS_HIWORD(n)            ((uint16)((uint32)(n) >> 16))
#define FS_LOWORD(n)            ((uint16)(n))
#define LOWSIXBITS              0x3F


#ifndef __TOOLUTILS__
FS_MAC_PASCAL Fixed FS_PC_PASCAL FixMul(Fixed,Fixed)   FS_MAC_TRAP(0xA868);
FS_MAC_PASCAL Fixed FS_PC_PASCAL FixRatio (int16 sA, int16 sB);
#endif

#ifndef __FIXMATH__
FS_MAC_PASCAL Fixed FS_PC_PASCAL FixDiv(Fixed,Fixed)  FS_MAC_TRAP(0xA84D);
FS_MAC_PASCAL Fract FS_PC_PASCAL FracMul(Fract,Fract) FS_MAC_TRAP(0xA84A);
FS_MAC_PASCAL Fract FS_PC_PASCAL FracDiv(Fract,Fract) FS_MAC_TRAP(0xA84B);
FS_MAC_PASCAL Fract FS_PC_PASCAL FracSqrt(Fract)      FS_MAC_TRAP(0xA849);
#endif


ShortFract      TMP_CONV NEAR ShortFracDot (ShortFract x, ShortFract y);
F26Dot6         TMP_CONV NEAR ShortFracMul (F26Dot6 x, ShortFract y);
ShortFract      TMP_CONV NEAR ShortFracDiv (ShortFract x, ShortFract y);
F26Dot6         TMP_CONV NEAR Mul26Dot6 (F26Dot6 a, F26Dot6 b);
F26Dot6         TMP_CONV NEAR Div26Dot6 (F26Dot6 num, F26Dot6 den);
int16           TMP_CONV NEAR MulDivShorts (int16 x, int16 y, int16 z);


#define MulDiv26Dot6(a,b,c) LongMulDiv(a,b,c)

int32 LongMulDiv(int32 a, int32 b, int32 c);     /* (a*b)/c */

int32 ShortMulDiv(int32 a, int16 b, int16 c);     /* (a*b)/c */

ShortFract ShortFracMulDiv(ShortFract,ShortFract,ShortFract);

void mth_FixXYMul (Fixed* x, Fixed* y, transMatrix* matrix);
void mth_FixVectorMul (vectorType* v, transMatrix* matrix);

/*
 *   B = A * B;     <4>
 *
 *         | a  b  0  |
 *    B =  | c  d  0  | * B;
 *         | 0  0  1  |
 */
void mth_MxConcat2x2 (transMatrix* matrixA, transMatrix* matrixB);

/*
 * scales a matrix by sx and sy.
 *
 *              | sx 0  0  |
 *    matrix =  | 0  sy 0  | * matrix;
 *              | 0  0  1  |
 */
void mth_MxScaleAB (Fixed sx, Fixed sy, transMatrix *matrixB);

boolean mth_IsMatrixStretched (transMatrix*trans);

boolean mth_Identity (transMatrix *matrix);
boolean mth_PositiveSquare (transMatrix *matrix);
boolean mth_PositiveRectangle (transMatrix *matrix);

/*
 * unitary Square
 *
 *              | +-1    0  0  |
 *    matrix =  |   0  +-1  0  |
 *              |   0    0  1  |
 */

boolean mth_UnitarySquare (transMatrix *matrix);

boolean mth_SameStretch (Fixed fxScaleX, Fixed fxScaleY);

boolean mth_GeneralRotation (transMatrix *matrix);
uint16 mth_90degRotationFactor (transMatrix *matrix);
uint16 mth_90degRotationFactorForEmboldening (transMatrix *matrix);
uint16 mth_90degClosestRotationFactor (transMatrix *matrix);
void mth_Non90DegreeTransformation(transMatrix *matrix, boolean *non90degreeRotation, boolean *nonUniformStretching);

int32 mth_CountLowZeros (uint32 n );
Fixed mth_max_abs (Fixed a, Fixed b);

int32 mth_GetShift (uint32 n);

void mth_ReduceMatrix(transMatrix *trans);

void mth_IntelMul (
	int32           lNumPts,
	F26Dot6 *       fxX,
	F26Dot6 *       fxY,
	transMatrix *   trans,
	Fixed           fxXStretch,
	Fixed           fxYStretch);

void    mth_FoldPointSizeResolution(
	Fixed           fxPointSize,
	int16           sXResolution,
	int16           sYResolution,
	transMatrix *   trans);

/*********************************************************************/

/*  Scan Converter Math Functions Appended for now         <5> DeanB */

/*********************************************************************/

int32 PowerOf2(
		int32                   /* + or - 32 bit value */
);

FS_PUBLIC int16 mth_DivShiftShort(int16 sValue, int16 sFactor);
FS_PUBLIC int32 mth_DivShiftLong(int32 sValue, int16 sFactor);

/*********************************************************************/
#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\fondrv\tt\scaler\fsconfig.h ===
/*
	File:       fsconfig.h : (Portable "Standard C" version)

	Written by: Lenox Brassell

	Contains:   #define directives for FontScaler build options

   Copyright:  c 1989-1993 by Microsoft Corp., all rights reserved.

	Change History (most recent first):
		<3>      4/21/93 GregH Documented file
		<2>      7/16/92    DJ      Added fnt_Report_Error() declaration.
		<1>      8/27/91    LB      Created file.

	Usage:  This file is "#include"-ed as the first statement in
			"fscdefs.h".  This file contains platform-specific
			override definitions for the following #define-ed data
		types and macros, which have default definitions in
		"fscdefs.h":

	Purpose:

		This file gives the integrator a place to override the
		default definitions of these items, as well as a place
		to define other configuration-specific macros.

	Definitions:

		The following type definitations can be changed. The defaults have been
		set up for a 32-bit system. Caveat emptor: any change to the defaults may
		severly effect performace or place severe limitations on the capabilities
		of the TrueType rasterizer.

				F26Dot6
					 This is currently defined as a fixed point 26.6 number.
					 If changed to short, it is a 10.6 number.

		The following definition changes the return type for all Font Scalar
		Client Interface calls.

				FS_ENTRY

		The following definition changes the calling convention for all Font
		Scalar Client Interface calls.  By default, the rasterizer uses register
		calling conventions because of the performance gains.

				FS_ENTRY_PROTO

		The following definitions are used for all private and public entry points
		in the TrueType Rasterizer. By default FS_PRIVATE is set to static, but
		for some uses, like profiling and debugging this is undesirable, and
		FS_PRIVATE can be set to null. FS_PUBLIC defaults to null.

				FS_PRIVATE
				FS_PUBLIC

		The following definitions are used for calling conventions to external
		math routines. The Macintosh has external math routines that use pascal
		calling conventions. To enable these, the FS_MAC_PASCAL must be set to
		"pascal". Similary the FS_PC_PASCAL variable needs to be set to "pascal"
		when calling external routines using pascal calling conventions.

				FS_MAC_PASCAL
				FS_PC_PASCAL

		This definition is used for calling Macintosh ToolBox routines. If the
		rasterizer is implemented on a non-Macintosh platform, this Macro should
		be null.

				FS_MAC_TRAP

		These macros are used to override the C memcpy and memset routines

				MEMCPY
				MEMSET

		These math routines can be hooked out by system routines.

				SHORTDIV
				SHORTMUL

		These macros are used to convert big-endian to little-endian. When
		running on a big-endian platform these macros are not necessary.

				SWAPL
				SWAPW
				SWAPWINC

		These macros are used to replace some math routines by faster assembly
		language routines. The notation used for the assembly language routines
		should indicate the processor targeted. For example:

				#define CompMul   CompMul386
				#define CompDiv   CompDiv386
				#define FracSqrt      FracSqrt386

	The following definitions change the way the TrueType rasterizer works on
	specific implementations. These definitions are usually switches that are
	defined or not defined.

		FSCFG_DEBUG

		This is used to create a debugging version of the rasterizer. This
		version does additional error checking and creates a debugger trap
		when the TrueType DEBUG instruction is called.

		FSCFG_FNTERR

		This is used to create a error checking version of the rasterizer. With
		this set, parameters passed to TrueType instructions are range checked.
		If any instructions fails a test, a error message is returned.

		FSCFG_MOVEABLE_MEMBASE

		This is used to implement moveable memory bases. If it is possible that
		the address of a memory base could change between a Font Scaler Client
		Interface call, then this flag should be set in the rasterizer.

		FSCFG_MICROSOFT_KK

		This flag is used to implement the Microsoft KK version of the TrueType
		rasterizer. The effect of this flag is to use a slightly different
		algorithm for parsing the Format 2 cmap table.

		FSCFG_BIG_ENDIAN

		This flag indicates the target platform of the rasterizer uses big-endian
		representation of multiple-byte integers. If this flag is not set, SWAP
		macros are used to convert all multiple-byte integers read from TrueType
		Font Files.

		FSCFG_REENTRANT

		This flag indicates that the TrueType rasterizer should be reentrant.
		This allows multiple treads of execution through the executable and gives
		better system through put on multi-threaded/process environments. Slight
		performance gains are possible when not setting this flag in single tasking
		environments.

		FSCFG_NO_INITIALIZED_DATA

		This flag should be set for platforms that do not support static
		initialization of data. With this flag, a new Font Scalar Client Interface
		call fs_InitializeData needs to be made.

		FSCFG_USESTATCARD

		This flag is set to turn on stat card timing services in the rasterizer.
		This can be used to collect timing information for profiling.
		
		FSCFG_USE_MASK_SHIFT

		This flag is set to enable bitmask generated by shifting rather than by
		table lookup.  Shifted bitmasks use less memory and MAY be faster than
		table bitmasks.  On Big-Endian platforms shifted bitmasks will produce
		bitmaps that are identical to Apple's definition (same byte order).
		Table bitmaps will be identical for all platforms.

		FSCFG_DISABLE_GRAYSCALE

		This flag is set to disable all grayscale functions and save a little
		code space along the way. If defined, all grayscale functions return
		a BAD_GRAY_LEVEL_ERR error code.

		FSCFG_FONTOGRAPHER_BUG

		Fontographer 3.5 has a bug. This is causing numerous symbol fonts to
		have the critical error : Inst: RCVT CVT Out of range. CVT = 255
		This flag is meant to be set under Windows. If will cause additional
		memory to be allocated for the CVT if necessary in order to be sure
		that this illegal read will access memory within the legal range.
		Under a secure rasterizer, this flag will cause RCVT with CVT <= 255
		and CVT > NumCvt to be classified as error instead of critical error

		FSCFG_EUDC_EDITOR_BUG

		The EUDC editor under NT 4.0 has a bug and create bogous fonts.
        	The EUDC editor set maxp->maxStackElements to 0 and use 1 stack element
        	in the pre/font program. If this flag is defined, we will ensure that
        	at least one StackElement is reserved to avoid memory corruption.

       		FSCFG_CONVERT_GRAY_LEVELS

        	with grayscale embedded bitmap, the number of gray levels can be different than expected
        	4, 16, 256 instead of 5, 17, 65. If FSCFG_CONVERT_GRAY_LEVELS is defined, a conversion will be done
        	in the rasterizer to the expected number of gray levels

       FSCFG_SUBPIXEL

        will activate the SubPixel code

		FSCFG_SUBPIXEL_STANDALONE

		will activate a special variant of the SubPixel code for the stand-alone rasterizer
		
        	FSCFG_SECURE

        	Enable critical error checking in the TrueType rasterizer.

		MAC_INIT

		This flag indicates that the TrueType rasterizer will be implemented as
		a Macintosh Init.

		UNNAMED_UNION

		This flag is set for compilers that implement unnamed unions

                ClientIDType

                This definition allow the change the type definition for ClientID. If you are using ClientID to pass a pointer
                and compiling the TrueType rasterizer for a platform where pointer are bigger than 32 bits, 
                you need to change this definition.

        FSCFG_NEW_GRAY_FILTER

        This flag indicates that we should use the new 6x6 filter over the
        4x4 overscale in fsc_CalcGrayMap.
*/

/* #define FSCFG_MICROSOFT_KK   */
/* #define FSCFG_USESTATCARD      */
/* #define FSCFG_NO_INITIALIZED_DATA */
/* #define FSCFG_FNTERR           */
/* #define FSCFG_DEBUG            */
/* #define FSCFG_MOVABLE_MEM_BASE */
/* #define FSCFG_BIG_ENDIAN   */
/* #define FSCFG_NO_INITIALIZED_DATA */
/* #define FSCFG_USE_MASK_SHIFT */
/* #define FSCFG_DISABLE_GRAYSCALE */

#define FSCFG_REENTRANT

#define FSCFG_FONTOGRAPHER_BUG

#define FSCFG_EUDC_EDITOR_BUG

#define FSCFG_SECURE

#define FSCFG_CONVERT_GRAY_LEVELS

#define FSCFG_SUBPIXEL

#define FSCFG_NEW_GRAY_FILTER // Customize filter for GDI+


/* Windows NT, is moving the definition of the internal rasterizer key in fscaler.h for optimization purpose */
#define FSCFG_MOVE_KEY_IN_DOT_H

/* !!! This should be removed */
#define NOT_ON_THE_MAC

/* Assembly Optimization Switches */

/* #define CompMul      CompMul386  */
/* #define CompDiv      CompDiv386  */
/* #define FracSqrt     FracSqrt386 */

// use RtlRoutines for memory operations

// in all uses in the rasterizer MEMSET  is used to zero out the mem

// to get the prototype for RtlZeroMemory and RtlCopyMemory :

#ifdef FSCFG_INTERNAL
#include "nt.h"
#include "ntrtl.h"

#if DBG
/* to activate rasterizer assertions : */
VOID __cdecl TtfdDbgPrint(PCHAR DebugMessage,...);
    
VOID EngDebugBreak(
    VOID
    );

#define FS_ASSERT(expression, message) { if (!(expression)) { TtfdDbgPrint(message); EngDebugBreak();} }
#define Assert(expression) { if (!(expression)) { TtfdDbgPrint("FONT: TrueType rasterizer internal assert"); EngDebugBreak();} }
#endif // DBG

#endif

#define MEMSET(dst, value, size) RtlZeroMemory(dst, size)
#define MEMCPY(dst, src, size)   RtlCopyMemory(dst, src, size)


// easier to debug with no static functions [BODIND]

#define FS_PRIVATE

// interface to the outside world [bodind]

#define FS_ENTRY_PROTO           __cdecl
#define FS_CALLBACK_PROTO	 __cdecl

// client ID is commonly used to pass a pointer to a structure, for backwards compatibility it
// need to be at least a 32 bits value, to get ready for the 64 bits platform, we define it as ULONG_PTR

#define ClientIDType ULONG_PTR

// only do stamp checking in the debug version

// #if DBG
// #define DEBUGSTAMP
// #endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\fondrv\tt\scaler\fontmath.c ===
/*
	File:       FontMath.c

	Contains:   xxx put contents here xxx

	Written by: xxx put writers here xxx

	Copyright:  (c) 1987-1990, 1992 by Apple Computer, Inc., all rights reserved.
				(c) 1989-1997. Microsoft Corporation, all rights reserved.

	Change History (most recent first):

		  <>     2/21/97	CB		ClaudeBe, add mth_UnitarySquare for scaled component in composite glyphs
		 <3>     11/9/90    MR      Fix CompDiv when numer and denom have zero hi longs. [rb]
		 <2>     11/5/90    MR      Remove Types.h from include list, rename FixMulDiv to LongMulDiv
									[rb]
		 <1>    10/20/90    MR      Math routines for font scaler. [rj]

	To Do:
*/

// Has anybody ever thought of replacing some of the 64bit arithmetic in here (and probably in other places)
// by "native" __int64 arithmetic, at least in the INTEL case? Could be faster, since the compiler gets to do
// the inline code, and would be ready for future 64bit architectures. Just a thought. B.St.

#define FSCFG_INTERNAL

#include "fscdefs.h"
#include "fserror.h"
#include "fontmath.h"

#define HIBITSET                      0x80000000UL
#define POSINFINITY               0x7FFFFFFFUL
#define NEGINFINITY               0x80000000UL
#define POINTSPERINCH               72
#define ALMOSTZERO 33
#define ISNOTPOWEROF2(n)        ((n) & ((n)-1))
#define CLOSETOONE(x)   ((x) >= ONEFIX-ALMOSTZERO && (x) <= ONEFIX+ALMOSTZERO)
#define MAKEABS(x)  if (x < 0) x = -x
#define FXABS(x)  ((x) >= 0L ? (x) : -(x))
#define FRACT2FIX(n)    (((n) + (1 << (sizeof (Fract) - 3))) >> 14)

#define FASTMUL26LIMIT      46340
#define FASTDIV26LIMIT  (1L << 25)

#define USHORTMUL(a, b) ((uint32)((uint32)(uint16)(a)*(uint32)(uint16)(b)))

boolean mth_Max45Trick (Fixed x, Fixed y);

/*******************************************************************/

/* local prototypes */

void CompMul(int32 src1, int32 src2, int32 dst[2]);

int32 CompDiv(int32 src1, int32 src2[2]);

/*******************************************************************/

#ifndef CompMul

void CompMul(int32 lSrc1, int32 lSrc2, int32 alDst[2])
{
	boolean     bNegative;
	uint32      ulDstLo;
	uint32      ulDstHi;
	uint16      usSrc1lo;
	uint16      usSrc1hi;
	uint16      usSrc2lo;
	uint16      usSrc2hi;
	uint32      ulTemp;

	bNegative = (lSrc1 ^ lSrc2) < 0;

	if (lSrc1 < 0)
	{
		lSrc1 = -lSrc1;
	}
	if (lSrc2 < 0)
	{
		lSrc2 = -lSrc2;
	}

	usSrc1hi = (uint16)(lSrc1 >> 16);
	usSrc1lo = (uint16)lSrc1;
	usSrc2hi = (uint16)(lSrc2 >> 16);
	usSrc2lo = (uint16)lSrc2;
	ulTemp   = (uint32)usSrc1hi * (uint32)usSrc2lo + (uint32)usSrc1lo * (uint32)usSrc2hi;
	ulDstHi  = (uint32)usSrc1hi * (uint32)usSrc2hi + (ulTemp >> 16);
	ulDstLo  = (uint32)usSrc1lo * (uint32)usSrc2lo;
	ulTemp <<= 16;
	ulDstLo += ulTemp;
	ulDstHi += (uint32)(ulDstLo < ulTemp);

	if (bNegative)
	{
		ulDstLo = (uint32)-((int32)ulDstLo);

		if (ulDstLo != 0L)
		{
			ulDstHi = ~ulDstHi;
		}
		else
		{
			ulDstHi = (uint32)-((int32)ulDstHi);
		}
	}

	alDst[0] = (int32)ulDstHi;
	alDst[1] = (int32)ulDstLo;
}
#endif

/*******************************************************************/

#ifndef CompDiv

int32 CompDiv(int32 lSrc1, int32 alSrc2[2])
{
	boolean     bNegative;
	uint32      ulSrc1Lo;
	uint32      ulSrc1Hi;
	uint32      ulSrc2Lo;
	uint32      ulSrc2Hi;
	uint32      ulResult;
	uint32      ulPlace;

	int32    lResult;

	ulSrc2Hi = (uint32)alSrc2[0];
	ulSrc2Lo = (uint32)alSrc2[1];

	bNegative = ((int32)ulSrc2Hi ^ lSrc1) < 0;

	if ((int32)ulSrc2Hi < 0L)
	{
		ulSrc2Lo = (uint32)-((int32)ulSrc2Lo);

		if (ulSrc2Lo != 0L)
		{
			ulSrc2Hi = ~ulSrc2Hi;
		}
		else
		{
			ulSrc2Hi = (uint32)-((int32)ulSrc2Hi);
		}
	}
	if (lSrc1 < 0)
	{
		lSrc1 = -lSrc1;
	}

	ulResult = 0;
	ulPlace = HIBITSET >> 1;

	ulSrc1Hi = (uint32)lSrc1;

	if (ulSrc1Hi & 1)
	{
		ulSrc1Lo = HIBITSET;
	}
	else
	{
		ulSrc1Lo = 0;
	}

	ulSrc1Hi >>= 1;
	ulSrc2Lo += ulSrc1Hi;
	ulSrc2Hi += (uint32)(ulSrc2Lo < ulSrc1Hi);      /* round the result */

	if (ulSrc2Hi > ulSrc1Hi || ulSrc2Hi == ulSrc1Hi && ulSrc2Lo >= ulSrc1Lo)
	{
		if (bNegative)
		{
			return (int32)NEGINFINITY;
		}
		else
		{
			return (int32)POSINFINITY;
		}
	}

	while (ulPlace && ulSrc2Hi)
	{
		ulSrc1Lo >>= 1;
		if (ulSrc1Hi & 1)
		{
			ulSrc1Lo += HIBITSET;
		}
		ulSrc1Hi >>= 1;
		if (ulSrc1Hi < ulSrc2Hi)
		{
			/* 64 bit subtract */
			ulSrc2Hi -= ulSrc1Hi;
			ulSrc2Hi -= (uint32)(ulSrc1Lo > ulSrc2Lo);
			ulSrc2Lo -= ulSrc1Lo;

			ulResult += ulPlace;
		}
		else if (ulSrc1Hi == ulSrc2Hi && ulSrc1Lo <= ulSrc2Lo)
		{
			ulSrc2Hi = 0;
			ulSrc2Lo -= ulSrc1Lo;
			ulResult += ulPlace;
		}
		ulPlace >>= 1;
	}
	if (ulSrc2Lo >= (uint32)lSrc1)   /* Assert(lSrc1 >= 0)   */
	{
		ulResult += ulSrc2Lo/(uint32)lSrc1;
	}
	if (bNegative)
	{
		lResult = -((int32)ulResult);
	}
	else
	{
		lResult = (int32)ulResult;
	}
	return lResult;
}
#endif

/*******************************************************************/

/*
 *  a*b/c
 */
int32 LongMulDiv(int32 a, int32 b, int32 c)
{
	int32 temp[2];

	 CompMul(a, b, temp);
	return CompDiv(c, temp);
}

/*******************************************************************/

F26Dot6 ShortFracMul (F26Dot6 aDot6, ShortFract b)
{
	int32       lTemp[2];
	uint32      ulLow;
	F26Dot6     fxProduct;

	CompMul(aDot6, b, lTemp);

	ulLow = (((uint32)lTemp[1]) >> 13) + 1;           /* rounds up */
	fxProduct = (F26Dot6)(lTemp[0] << 18) + (F26Dot6)(ulLow >> 1);

	return (fxProduct);
}

/*******************************************************************/

ShortFract ShortFracDot (ShortFract a, ShortFract b)
{
	return (ShortFract)((((int32)a * (int32)b) + (1L << 13)) >> 14);
}


int32 ShortMulDiv(int32 a, int16 b, int16 c)
{
	return LongMulDiv(a, (int32)b, (int32)c);
}

int16 MulDivShorts (int16 a, int16 b, int16 c)
{
	return (int16)LongMulDiv((int32)a, (int32)b, (int32)c);
}

/*
 *  Total precision routine to multiply two 26.6 numbers        <3>
 */
F26Dot6 Mul26Dot6(F26Dot6 a, F26Dot6 b)
{
	 int32 negative = false;
	uint16 al, bl, ah, bh;
	uint32 lowlong, midlong, hilong;

	if ((a <= FASTMUL26LIMIT) && (b <= FASTMUL26LIMIT) && (a >= -FASTMUL26LIMIT) && (b >= -FASTMUL26LIMIT))
		  return (F26Dot6)((int32)(a * b + (1 << 5)) >> 6);                            /* fast case */

	if (a < 0) { a = -a; negative = true; }
	if (b < 0) { b = -b; negative ^= true; }

	 al = FS_LOWORD(a); ah = FS_HIWORD(a);
	 bl = FS_LOWORD(b); bh = FS_HIWORD(b);

	midlong = USHORTMUL(al, bh) + USHORTMUL(ah, bl);
	 hilong = USHORTMUL(ah, bh) + (uint32)FS_HIWORD(midlong);
	midlong <<= 16;
	midlong += 1 << 5;
	lowlong = USHORTMUL(al, bl) + midlong;
	hilong += (uint32)(lowlong < midlong);

	midlong = (lowlong >> 6) | (hilong << 26);
	if( negative)
	{
		return  (F26Dot6)-((int32)midlong);
	}
	else
	{
		return (F26Dot6)midlong;
	}
}

/*
 *  Total precision routine to divide two 26.6 numbers          <3>
 */
F26Dot6 Div26Dot6(F26Dot6 num, F26Dot6 den)
{
	 int32 negative = false;
	uint32 hinum, lownum, hiden, lowden, result, place;

	if (den == 0L)
	{
		if (num < 0L )
		{
				return (F26Dot6)NEGINFINITY;
		}
		else
		{
			return (F26Dot6)POSINFINITY;
		}
	}

	if ( (num <= FASTDIV26LIMIT) && (num >= -FASTDIV26LIMIT) )          /* fast case */
		  return (F26Dot6)(((int32)num << 6) / den);

	if (num < 0)
	{
		num = -num;
		negative = true;
	}
	if (den < 0)
	{
		den = -den;
		negative ^= true;
	}

	hinum = ((uint32)num >> 26);
	lownum = ((uint32)num << 6);
	hiden = (uint32)den;
	lowden = 0;
	result = 0;
	place = HIBITSET;

	if (hinum >= hiden)
	{
		if( negative )
		{
				return (F26Dot6)(uint32)NEGINFINITY;
		}
		else
		{
			return (F26Dot6)POSINFINITY;
		}
	}

	while (place)
	{
		lowden >>= 1;
		if (hiden & 1)
		{
			lowden += HIBITSET;
		}
		hiden >>= 1;
		if (hiden < hinum)
		{
			hinum -= hiden;
			hinum -= (uint32)(lowden > lownum);
			lownum -= lowden;
			result += place;
		}
		else if (hiden == hinum && lowden <= lownum)
		{
			hinum = 0;
			lownum -= lowden;
			result += place;
		}
		place >>= 1;
	}

	if (negative)
	{
		return (F26Dot6)-((int32)result);
	}
	else
	{
		return (F26Dot6)result;
	}
}

ShortFract ShortFracDiv(ShortFract num,ShortFract denum)
{
	return (ShortFract)(((int32)(num) << 14) / (int32)denum);
}

ShortFract ShortFracMulDiv(ShortFract numA,ShortFract numB,ShortFract denum)
{
	return (ShortFract) LongMulDiv ((int32) numA,(int32) numB, (int32)denum);
}

/* ------------------------------------------------------------ */

#ifndef FSCFG_USE_EXTERNAL_FIXMATH
/*  Here we define Fixed [16.16] and Fract [2.30] precision 
 *  multiplication and division functions and a Fract square root 
 *  function which are compatible with those in the Macintosh toolbox.
 *
 *  The division functions load the 32-bit numerator into the "middle"
 *  bits of a 64-bit numerator, then call the 64-bit by 32-bit CompDiv()
 *  function defined above, which can return a NEGINFINITY or POSINFINITY
 *  overflow return code.
 *
 *  The multiply functions call the 32-bit by 32-bit CompMul() function
 *  defined above which produces a 64-bit result, then they extract the
 *  "interesting" 32-bits from the middle of the 64-bit result and test 
 *  for overflow.
 *
 *  The GET32(a,i) macro defined below extracts a 32-bit value with "i" 
 *  bits of fractional precision from the 64-bit value in "a", a 2-element
 *  array of longs.
 *
 *  The CHKOVF(a,i,v) macro tests the most significant bits of the 
 *  64-bit value in "a", a 2-element array of longs, and tests the 
 *  32-bit result "v" for overflow.  "v" is defined as having "i" bits
 *  of fractional precision.
 *
 *  BIT() and OVFMASK() are "helper" macros used by GET32() and CHKOVF().
 *
 *  BIT(i) returns a mask with the "i"-th bit set.
 *  OVFMASK(i) returns a mask with the most-significant "32-i" bits set.
 */

#define BIT(i)          (1L<<(i))
#define OVFMASK(i)   ( ~0L ^ ( ((uint32)BIT(i)) - 1 ) )
#define CHKOVF(a,i,v)   (\
		( ((uint32)(a)[0] & OVFMASK(i))==0)          ? ( (v)>=0 ?(v) :POSINFINITY) : \
		( ((uint32)(a)[0] & OVFMASK(i))==OVFMASK(i)) ? ( (v)<=0 ?(v) :NEGINFINITY) : \
		( ((uint32)(a)[0] & BIT(31))                 ? POSINFINITY   :NEGINFINITY)   \
	)
#define GET32(b,a,i) \
((((a)[0]<<(32-(i))) | (int32)((uint32)((a)[1])>>(i))) + \
(int32)!!( ((a)[1] & BIT((i)-1))  && ( b ? ( ( ((a)[1] & ~OVFMASK(i-1) )) & ~OVFMASK(i-1) ) : TRUE ) ) )

FS_MAC_PASCAL Fixed FS_PC_PASCAL FixMul (Fixed fxA, Fixed fxB)
{
 	int32 alCompProd[2];
	Fixed fxProd;
	int  bNegative=FALSE;

	if  (fxA == 0 || fxB == 0)
		return 0;

	if( ((fxA > 0) && (fxB < 0)) || ((fxA < 0) && (fxB > 0)) )
		bNegative = TRUE;

        CompMul ((int32)fxA, (int32)fxB, alCompProd);

	fxProd = (Fixed)GET32 (bNegative,alCompProd,16);

	return (Fixed)CHKOVF(alCompProd,16,fxProd);
}

FS_MAC_PASCAL Fixed FS_PC_PASCAL FixDiv (Fixed fxA, Fixed fxB)
{
	int32 alCompProd[2];
	
	alCompProd[0] = fxA >> 16;
	alCompProd[1] = fxA << 16;

	return CompDiv ((int32)fxB, alCompProd);
}

FS_MAC_PASCAL Fixed FS_PC_PASCAL FixRatio (int16 sA, int16 sB)
{
	int32 alCompProd[2];
	
	alCompProd[0] = ((int32)(sA)) >> 16;
	alCompProd[1] = ((int32)(sA)) << 16;

	return CompDiv ((int32)(sB), alCompProd);
}

FS_MAC_PASCAL Fract FS_PC_PASCAL FracMul (Fract frA, Fract frB)
{
	int32 alCompProd[2];
	Fract frProd;
	int  bNegative=FALSE;

	if  (frA == 0 || frB == 0)
		return 0;

	if( ((frA > 0) && (frB < 0)) || ((frA < 0) && (frB > 0)) )
		bNegative = TRUE;

        CompMul (frA,frB,alCompProd);
	frProd = (Fract)GET32 (bNegative,alCompProd,30);

	return (Fract)CHKOVF(alCompProd,30,frProd);
}

FS_MAC_PASCAL Fract FS_PC_PASCAL FracDiv (Fract frA, Fract frB)
{
	int32 alCompProd[2];

	alCompProd[0] = frA >> 2;
	alCompProd[1] = frA << 30;
	return CompDiv ((int32)frB, alCompProd);
}

/*******************************************************************/

#ifndef FracSqrt

/* 
   Fract FracSqrt (Fract xf)
   Input:  xf           2.30 fixed point value
   Return: sqrt(xf)     2.30 fixed point value
*/

FS_MAC_PASCAL Fract FS_PC_PASCAL FracSqrt (Fract xf)
{
	Fract b = 0L;
	uint32 c, d, x = xf;
	
	if (xf < 0) return (NEGINFINITY);

	/*
	The algorithm extracts one bit at a time, starting from the
	left, and accumulates the square root in b.  The algorithm 
	takes advantage of the fact that non-negative input values
	range from zero to just under two, and corresponding output
	ranges from zero to just under sqrt(2).  Input is assigned
	to temporary value x (unsigned) so we can use the sign bit
	for more precision.
	*/
	
	if (x >= 0x40000000)
	{
		x -= 0x40000000; 
		b  = 0x40000000; 
	}

	/*
	This is the main loop.  If we had more precision, we could 
	do everything here, but the lines above perform the first
	iteration (to align the 2.30 radix properly in b, and to 
	preserve full precision in x without overflow), and afterward 
	we do two more iterations.
	*/
	
	for (c = 0x10000000; c; c >>= 1)
	{
		d = b + c;
		if (x >= d)
		{
			x -= d; 
			b += (c<<1); 
		}
		x <<= 1;
	}

	/*
	Iteration to get last significant bit.
	
	This code has been reduced beyond recognition, but basically,
	at this point c == 1L>>1 (phantom bit on right).  We would
	like to shift x and d left 1 bit when we enter this iteration,
	instead of at the end.  That way we could get phantom bit in
	d back into the word.  Unfortunately, that may cause overflow
	in x.  The solution is to break d into b+c, subtract b from x,
	then shift x left, then subtract c<<1 (1L).
	*/
	
	if (x > (uint32)b) /* if (x == b) then (x < d).  We want to test (x >= d). */
	{
		x -= b;
		x <<= 1;
		x -= 1L;
		b += 1L; /* b += (c<<1) */
	}
	else
	{
		x <<= 1;
	}

	/* 
	Final iteration is simple, since we don't have to maintain x.
	We just need to calculate the bit to the right of the least
	significant bit in b, and use the result to round our final answer.
	*/
	
	return ( b + (Fract)(x>(uint32)b) );
}

#endif  /* FracSqrt */

/*******************************************************************/

#endif


/* TRANSFORMATION ROUTINES */

/*
 *  Good for transforming fixed point values.  Assumes NO translate  <4>
 */
void mth_FixXYMul (Fixed*x, Fixed*y, transMatrix*matrix)
{
  Fixed xTemp, yTemp;
  Fixed *m0, *m1;

  m0 = (Fixed *) & matrix->transform[0][0];
  m1 = (Fixed *) & matrix->transform[1][0];

  xTemp = *x;
  yTemp = *y;
  *x = FixMul (*m0++, xTemp) + FixMul (*m1++, yTemp);
  *y = FixMul (*m0++, xTemp) + FixMul (*m1++, yTemp);

#ifndef PC_OS   /* Never a perspecitive with Windows */ /* !!!DISCUSS   */

  if (*m0 || *m1)     /* these two are Fracts */
  {
	Fixed tmp = FracMul (*m0, xTemp) + FracMul (*m1, yTemp);
	tmp += matrix->transform[2][2];
	if (tmp && tmp != ONEFIX)
	{
	  *x = FixDiv (*x, tmp);
	  *y = FixDiv (*y, tmp);
	}
  }
#endif
}


/*
 *  This could be faster        <4>
 */
void mth_FixVectorMul (vectorType*v, transMatrix*matrix)
{
  mth_FixXYMul (&v->x, &v->y, matrix);
}


/*
 *   B = A * B;     <4>
 *
 *         | a  b  0  |
 *    B =  | c  d  0  | * B;
 *         | 0  0  1  |
 */
void mth_MxConcat2x2 (transMatrix*A, transMatrix*B)
{
  Fixed storage[6];
  Fixed * s = storage;
  int32 i, j;

  for (j = 0; j < 2; j++)
	for (i = 0; i < 3; i++)
	  *s++ = FixMul (A->transform[j][0], B->transform[0][i]) + FixMul (A->transform[j][1], B->transform[1][i]);

  {
	Fixed*dst = &B->transform[2][0];
	Fixed*src = s;
	int16 i;
	for (i = 5; i >= 0; --i)
	  *--dst = *--src;
  }
}


/*
 * scales a matrix by sx and sy.
 *
 *
 *              | sx 0  0  |
 *    matrix =  | 0  sy 0  | * matrix;
 *              | 0  0  1  |
 *
 */
void mth_MxScaleAB (Fixed sx, Fixed sy, transMatrix *matrixB)
{
  int32       i;
  Fixed  *m = (Fixed *) & matrixB->transform[0][0];

  for (i = 0; i < 3; i++, m++)
	*m = FixMul (sx, *m);

  for (i = 0; i < 3; i++, m++)
	*m = FixMul (sy, *m);
}


/*
 *  Return 45 degreeness
 */
#ifndef PC_OS   /* !!!DISCUSS   */
boolean mth_Max45Trick (Fixed x, Fixed y)
{
  MAKEABS (x);
  MAKEABS (y);

  if (x < y)      /* make sure x > y */
  {
	Fixed z = x;
	x = y;
	y = z;
  }

  return  (x - y <= ALMOSTZERO);
}
#else
  #define mth_Max45Trick(x,y)     (x == y || x == -y)
#endif


/*
 *  Sets bPhaseShift to true if X or Y are at 45 degrees, flaging the outline
 *  to be moved in the low bit just before scan-conversion.
 *  Sets [xy]Stretch factors to be applied before hinting.
 *  Returns true if the contours need to be reversed.
 */
boolean mth_IsMatrixStretched (transMatrix*trans)
{
  Fixed*matrix = &trans->transform[0][0];
  Fixed x, y;
  int32 i;
  boolean   bPhaseShift;

  bPhaseShift = FALSE;

  for (i = 0; i < 2; i++, matrix++)
  {
	x = *matrix++;
	y = *matrix++;
	bPhaseShift |= mth_Max45Trick (x, y);
  }
  return( bPhaseShift );
}


/*
 * Returns true if we have the identity matrix.
 */

boolean mth_PositiveSquare (transMatrix *matrix)
{
	return (matrix->transform[0][0] == matrix->transform[1][1] && matrix->transform[0][1] == 0 && matrix->transform[1][0] == 0 && matrix->transform[1][1] >= 0);
}

boolean mth_Identity (transMatrix *matrix)
{
	return (matrix->transform[0][0] == matrix->transform[1][1] && matrix->transform[0][1] == 0 && matrix->transform[1][0] == 0 && matrix->transform[0][0] == ONEFIX);
}


boolean mth_PositiveRectangle (transMatrix *matrix)
{
	 return (matrix->transform[0][1] == 0 && matrix->transform[1][0] == 0 && matrix->transform[0][0] >= 0 && matrix->transform[1][1] >= 0);
}

/*
 * unitary Square
 *
 *              | +-1    0  0  |
 *    matrix =  |   0  +-1  0  |
 *              |   0    0  1  |
 */

boolean mth_UnitarySquare (transMatrix *matrix)
{
	return (matrix->transform[0][1] == 0 && matrix->transform[1][0] == 0 && FXABS(matrix->transform[0][0]) == FXABS(matrix->transform[1][1]) && FXABS(matrix->transform[0][0]) == ONEFIX);
}

boolean mth_SameStretch (Fixed fxScaleX, Fixed fxScaleY)
{
	return(fxScaleX == fxScaleY);
}

boolean mth_GeneralRotation (transMatrix *matrix)
{
  return ((matrix->transform[0][0] || matrix->transform[1][1]) && (matrix->transform[1][0] || matrix->transform[0][1]));
}

/* for a rotation that is a multiple of 90 degrees, return the multiplier factor */
/* for non 90 degree rotations, return 4  (this is used for sbit rotations) */

uint16 mth_90degRotationFactor (transMatrix *matrix)
{
	if (matrix->transform[1][0] == 0 && matrix->transform[0][1] == 0)
    {
    	if (matrix->transform[0][0] > 0 && matrix->transform[1][1] > 0)
            return (0);
    	else if (matrix->transform[0][0] < 0 && matrix->transform[1][1] < 0)
            return (2);
    }
	else if (matrix->transform[0][0] == 0 && matrix->transform[1][1] == 0)
    {
        if (matrix->transform[1][0] < 0 && matrix->transform[0][1] > 0)
            return (1);
       	else if (matrix->transform[1][0] > 0 && matrix->transform[0][1] < 0)
            return (3);
	}
    return (4);                 /* non 90 degree rotation */
}

uint16 mth_90degRotationFactorForEmboldening (transMatrix *matrix)
{
	if (matrix->transform[1][0] == 0 && matrix->transform[0][1] == 0)
    {
		if (matrix->transform[0][0] > 0){
			if(matrix->transform[1][1] > 0)
				return (0);	// 0 degree with sx>0 & sy>0 or 180 degree with sx<0 & sy<0
			else
				return (4); // 0 degree with sx>0 & sy<0 or 180 degree with sx<0 & sy>0
		}
		else if (matrix->transform[0][0] < 0){
			if(matrix->transform[1][1] < 0)
				return (2); // 180 degree with sx>0 & sy>0 or 0 degree with sx<0 & sy<0
			else
				return (6); // 180 degree with sx>0 & sy<0 or 0 degree with sx<0 & sy>0
		}
    }
	else if (matrix->transform[0][0] == 0 && matrix->transform[1][1] == 0)
    {
        if (matrix->transform[1][0] < 0){
			if(matrix->transform[0][1] > 0)
				return (1); // 90 degree with sx>0 & sy>0 or 270 degree with sx<0 & sy<0
			else
				return (7); // 270 degree with sx>0 & sy<0 or 90 degree with sx<0 & sy>0
		}
       	else if (matrix->transform[1][0] > 0){
			if(matrix->transform[0][1] < 0)
				return (3); // 270 degree with sx>0 & sy>0 or 90 degree with sx<0 & sy<0
			else
				return (5); // 90 degree with sx>0 & sy<0 or 270 degree with sx<0 & sy>0
		}
	}
    return (8);                 /* non 90 degree rotation */
}

/* This is for Italic simulation.

/* return values with non-vertical
			Sx>0 & Sy>0		Sx>0 & Sy<0		Sx<0 & Sy>0		Sx<0 & Sy<0
0   degree	0				4				6				2
90  degree	1				5				7				3
180 degree	2				6				4				0
270 degree	3				7				5				1

/* return values with vertical
			Sx>0 & Sy>0		Sx>0 & Sy<0		Sx<0 & Sy>0		Sx<0 & Sy<0
0   degree	1				7				5				3
90  degree	2				4				6				0
180 degree	3				5				7				1
270 degree	0				6				4				2
*/

uint16 mth_90degClosestRotationFactor (transMatrix *matrix)
{
	if (matrix->transform[0][0] > 0 && matrix->transform[0][1] == 0 && matrix->transform[1][0] > 0 && matrix->transform[1][1] > 0 ||
        matrix->transform[0][0] > 0 && matrix->transform[0][1] < 0 && matrix->transform[1][0] == 0 && matrix->transform[1][1] > 0 ) 
        return (0); 
	else if (matrix->transform[0][0] == 0 && matrix->transform[0][1] > 0 && matrix->transform[1][0] < 0 && matrix->transform[1][1] > 0 ||
             matrix->transform[0][0] > 0 && matrix->transform[0][1] > 0 && matrix->transform[1][0] < 0 && matrix->transform[1][1] == 0 ) 
        return (1); 
	else if (matrix->transform[0][0] < 0 && matrix->transform[0][1] == 0 && matrix->transform[1][0] < 0 && matrix->transform[1][1] < 0 ||
             matrix->transform[0][0] < 0 && matrix->transform[0][1] > 0 && matrix->transform[1][0] == 0 && matrix->transform[1][1] < 0 ) 
        return (2); 
	else if (matrix->transform[0][0] == 0 && matrix->transform[0][1] < 0 && matrix->transform[1][0] > 0 && matrix->transform[1][1] < 0 ||
             matrix->transform[0][0] < 0 && matrix->transform[0][1] < 0 && matrix->transform[1][0] > 0 && matrix->transform[1][1] ==  0 ) 
        return (3); 
	else if (matrix->transform[0][0] > 0 && matrix->transform[0][1] == 0 && matrix->transform[1][0] > 0 && matrix->transform[1][1] < 0 ||
			 matrix->transform[0][0] > 0 && matrix->transform[0][1] > 0 && matrix->transform[1][0] == 0 && matrix->transform[1][1] < 0 ) 
        return (4); 
	else if (matrix->transform[0][0] == 0 && matrix->transform[0][1] > 0 && matrix->transform[1][0] > 0 && matrix->transform[1][1] > 0 ||
             matrix->transform[0][0] < 0 && matrix->transform[0][1] > 0 && matrix->transform[1][0] > 0 && matrix->transform[1][1] == 0 ) 
        return (5); 
	else if (matrix->transform[0][0] < 0 && matrix->transform[0][1] == 0 && matrix->transform[1][0] < 0 && matrix->transform[1][1] > 0 ||
             matrix->transform[0][0] < 0 && matrix->transform[0][1] < 0 && matrix->transform[1][0] == 0 && matrix->transform[1][1] > 0 ) 
        return (6); 
	else if (matrix->transform[0][0] == 0 && matrix->transform[0][1] < 0 && matrix->transform[1][0] < 0 && matrix->transform[1][1] < 0 ||
             matrix->transform[0][0] > 0 && matrix->transform[0][1] < 0 && matrix->transform[1][0] < 0 && matrix->transform[1][1] ==  0 ) 
        return (7); 
    // anything else
    else
        return (8); 
}

void mth_Non90DegreeTransformation(transMatrix *matrix, boolean *non90degreeRotation, boolean *nonUniformStretching) {
	Fixed Xx,Xy,Yx,Yy;

	// first, we apply the matrix to the base vectors X = (1, 0) and Y = (0, 1)
	// this seemingly trivial step tends to be a hidden trap because there are two ways to apply a matrix to a vector, prefix and postfix.
	// in the rasterizer we seem to apply matrices as postfix operators, i.e.
	//
	//          (a00 a01)
	// (x, y) * (       ) = (a00*x + a10*y, a01*x + a11*y)
	//          (a10 a11)
	//
	//   apply to X = (1, 0)           apply to Y = (0, 1)
	Xx = matrix->transform[0][0]; Yx = matrix->transform[1][0];
	Xy = matrix->transform[0][1]; Yy = matrix->transform[1][1];

	// then we test whether the transformation shears the coordinates
	// if so, the transformed base vectors are no longer perpendicular, so we test their dot product against 0
	// notice that due to the limited precision of the fixed point representation , we may introduce a numerical error in general. 	
	// however, we're interested in identifying special cases like multiples of 90 rotations, for which one of the components
	// of the transformed vectors will be 0, hence the dot product should be accurate in these cases.
	if (FixMul(Xx,Yx) + FixMul(Xy,Yy) == 0) { // we're perpendicular

		// next we analyze whether the transformation rotates by a multiple of 90 or not
		// rotations which are multiples of 90 have 0s in either both non-diagonal matrix elements or both diagonal matrix elements
		// notice that this analysis includes mirrorings in x or y, which are handled in much the same way
		*non90degreeRotation = !(Xx == 0 && Yy == 0 || Xy == 0 && Yx == 0);

		// finally we analyze whether the transformation stretches the coordinates uniformly or not
		// for uniform stretchings the transformed base vectors have the same lengths
		// notice again that due to limited precision we may introduce a numerical error which we can ignore for the same reasons
		*nonUniformStretching = FixMul(Xx,Xx) + FixMul(Xy,Xy) != FixMul(Yx,Yx) + FixMul(Yy,Yy);
	
	} else { // we're sheared
		
		// here, we analyze whether the transformation rotates the x-axis by a multiple of 90 or not
		// we do not consider the y-axis because we don't want to exclude italicized fonts
		// for a multiple of 90 rotation, the transformed base vector X is either [anti-]parallel or perpendicular to its original
		// to be perpendicular, its x-component must be 0, hence a00 = 0; to be [anti-]parallel, its y-component must be 0, hence a01 = 0
		*non90degreeRotation = !(Xx == 0 || Xy == 0);

		// finally, we need to know whether the transformation stretches the coordinates at all
		// we know already that the stretching is not uniform, except in the unlikely case that the transformation rotates the y-axis
		// relative to the x-axis, which is a combination of stretching in y (actually, squeezing) by a particular amount, followed by
		// shearing, which stretches the y-axis again. For the correct combination of squeezing and shearing, this yields a uniform
		// stretching. For italicizing characters, this is an unlikely scenario, as italics tend to have the same [x-]height as their
		// roman ancestors. Italicizing is achieved by a shearing without separate stretching, which is a much more likely scenario.
		// For the reasons of their likelyhood, we consider shearing a uniform stretching, but not the rotation of the y-axis. Further-
		// more, for the purpose of identifying special cases, we do so only for rotations by multiples of 90, and only if the area
		// of the parallelogram defined by the two transformed base vectors remains 1, which is what happens under shearing. The area
		// of the parallelogram equals the determinant of the matrix. All other cases are considered proper non-uniform stretchings.
		
		*nonUniformStretching = *non90degreeRotation || FixMul(Xx,Xx) + FixMul(Xy,Xy) != ONEFIX || FixMul(Xx,Yy) - FixMul(Xy,Yx) != ONEFIX;
	}

} // mth_Non90DegreeTransformation

/*
 * mth_GetShift
 * return 2log of n if n is a power of 2 otherwise -1;
 */
int32 mth_GetShift( uint32 n )
{
		if (ISNOTPOWEROF2(n) || !n)
				return -1;
		else
				return mth_CountLowZeros( n );
}

int32 mth_CountLowZeros( uint32 n )
{
		  int32 shift = 0;
		  uint32    one = 1;
		for (shift = 0; !( n & one ); shift++)
				n >>= 1;
		return shift;
}

Fixed mth_max_abs (Fixed a, Fixed b)
{
  if (a < 0)
	a = -a;
  if (b < 0)
	b = -b;
  return (a > b ? a : b);
}

/*
 *  Call this guy before you use the matrix.  He does two things:
 *      He folds any perspective-translation back into perspective,
 *       and then changes the [2][2] element from a Fract to a fixed.
 */
void mth_ReduceMatrix(transMatrix *trans)
{
	Fixed a, *matrix = &trans->transform[0][0];
	Fract bottom = matrix[8];

/*
 *  First, fold translation into perspective, if any.
 */
	a = matrix[2];

	if (a != 0)
	{
		matrix[0] -= LongMulDiv(a, matrix[6], bottom);
		matrix[1] -= LongMulDiv(a, matrix[7], bottom);
	}

	a = matrix[5];

	if (a != 0)
	{
		matrix[3] -= LongMulDiv(a, matrix[6], bottom);
		matrix[4] -= LongMulDiv(a, matrix[7], bottom);
	}
	matrix[6] = matrix[7] = 0;
	matrix[8] = FRACT2FIX(bottom);      /* make this guy a fixed for XYMul routines */
}

void mth_IntelMul (
	int32           lNumPts,
	F26Dot6 *       fxX,
	F26Dot6 *       fxY,
	transMatrix *   trans,
	Fixed           fxXStretch,
	Fixed           fxYStretch)

{
	Fixed   fxM00;
	Fixed   fxM01;
	Fixed   fxM10;
	Fixed   fxM11;
	Fixed   fxOrigX;
	Fixed   fxOrigY;

	if (fxXStretch == 0L || fxYStretch == 0L)
	{
		for (--lNumPts; lNumPts >= 0; --lNumPts)
		{
			*fxY++ = 0;
			*fxX++ = 0;
		}
	}
	else
	{
		if(fxXStretch != ONEFIX)
		{
			fxM00 = FixDiv (trans->transform[0][0], fxXStretch);
			fxM01 = FixDiv (trans->transform[0][1], fxXStretch);
		}
		else
		{
			fxM00 = trans->transform[0][0];
			fxM01 = trans->transform[0][1];
		}

		if(fxYStretch != ONEFIX)
		{
			fxM10 = FixDiv (trans->transform[1][0], fxYStretch);
			fxM11 = FixDiv (trans->transform[1][1], fxYStretch);
		}
		else
		{
			fxM10 = trans->transform[1][0];
			fxM11 = trans->transform[1][1];
		}

		for (--lNumPts; lNumPts >= 0; --lNumPts)
		{
			fxOrigX = *fxX;
			fxOrigY = *fxY;

			*fxX++ = (F26Dot6) (FixMul (fxM00, fxOrigX) + FixMul (fxM10, fxOrigY));
			*fxY++ = (F26Dot6) (FixMul (fxM01, fxOrigX) + FixMul (fxM11, fxOrigY));
		}
	}
}


/*
 *  Fold the point size and resolution into the matrix
 */

void    mth_FoldPointSizeResolution(
	Fixed           fxPointSize,
	int16           sXResolution,
	int16           sYResolution,
	transMatrix *   trans)
{
	Fixed fxScale;

	fxScale = ShortMulDiv(fxPointSize, sYResolution, POINTSPERINCH);
	trans->transform[0][1] = FixMul( trans->transform[0][1], fxScale );
	trans->transform[1][1] = FixMul( trans->transform[1][1], fxScale );
	trans->transform[2][1] = FixMul( trans->transform[2][1], fxScale );

	fxScale = ShortMulDiv(fxPointSize, sXResolution, POINTSPERINCH);
	trans->transform[0][0] = FixMul( trans->transform[0][0], fxScale );
	trans->transform[1][0] = FixMul( trans->transform[1][0], fxScale );
	trans->transform[2][0] = FixMul( trans->transform[2][0], fxScale );
}


/*********************************************************************/

/*  Find the power of 2 greater than the absolute value of passed parameter  */

int32 PowerOf2(
		int32 lValue )
{
	static const int32 iTable[] = { 0, 1, 2, 2, 3, 3, 3, 3,
								  4, 4, 4, 4, 4, 4, 4, 4  };

	if (lValue < 0L)
	{
		lValue = -lValue;
	}

	if (lValue < (1L << 16))
	{
		if (lValue < (1L << 8))
		{
			if (lValue < (1L << 4))
			{
				return (iTable[lValue]);
			}
			else
			{
				return (iTable[lValue >> 4] + 4);
			}
		}
		else
		{
			if (lValue < (1L << 12))
			{
				return (iTable[lValue >> 8] + 8);
			}
			else
			{
				return (iTable[lValue >> 12] + 12);
			}
		}
	}
	else
	{
		if (lValue < (1L << 24))
		{
			if (lValue < (1L << 20))
			{
				return (iTable[lValue >> 16] + 16);
			}
			else
			{
				return (iTable[lValue >> 20] + 20);
			}
		}
		else
		{
			if (lValue < (1L << 28))
			{
				return (iTable[lValue >> 24] + 24);
			}
			else
			{
				return (iTable[lValue >> 28] + 28);
			}
		}
	}
}

/********************************************************************/

/* divide by shifting for translation invariant negatives */

FS_PUBLIC int16 mth_DivShiftShort(int16 sValue, int16 sFactor)
{
	return (int16)mth_DivShiftLong((int32)sValue, sFactor);
}

FS_PUBLIC int32 mth_DivShiftLong(int32 lValue, int16 sFactor)
{
	switch (sFactor)
	{
	case 0:
	case 1:
		break;
	case 2:
		lValue >>= 1;
		break;
	case 4:
		lValue >>= 2;
		break;
	case 8:
		lValue >>= 3;
		break;
	default:
		if (lValue >= 0)
		{
			lValue /= (int32)sFactor;
		}
		else
		{
			lValue = ((lValue - (int32)sFactor + 1) / (int32)sFactor);
		}
		break;
	}
	return lValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\fondrv\tt\scaler\fsglue.c ===
/*++
	File:       FSglue.c

	Contains:   xxx put contents here (or delete the whole line) xxx

	Written by: xxx put name of writer here (or delete the whole line) xxx

	Copyright:  (c) 1987-1990, 1992 by Apple Computer, Inc., all rights reserved.
				(c) 1989-1999. Microsoft Corporation, all rights reserved.

	Change History (most recent first):


				 7/10/99  BeatS		Add support for native SP fonts, vertical RGB
		 <>     10/14/97    CB      rename ASSERT into FS_ASSERT
		 <>     02/21/97    CB      ClaudeBe, scaled component in composite glyphs
		 <>     12/14/95    CB      add usNonScaledAH and sNonScaledTSB to  GlyphData
		 <7>    11/27/90    MR      Need two scalars: one for (possibly rounded) outlines and cvt,
													and one (always fractional) metrics. [rb]
		 <6>    11/16/90    MR      Add SnapShotOutline to make instructions after components work
													[rb]
		 <5>     11/9/90    MR      Unrename fsg_ReleaseProgramPtrs to RELEASESFNTFRAG. [rb]
		 <4>     11/5/90    MR      Change globalGS.ppemDot6 to globalGS.fpem, change all instrPtr
													and curve flags to uint8. [rb]
		 <3>    10/31/90    MR      Add bit-field option for integer or fractional scaling [rb]
		 <2>    10/20/90    MR      Change matrix[2][2] back to a fract (in response to change in
													skia). However, ReduceMatrix converts it to a fixed after it has
													been used to "regularize" the matrix. Changed scaling routines
													for outline and CVT to use integer pixelsPerEm. Removed
													scaleFunc from the splineKey. Change some routines that were
													calling FracDiv and FixDiv to use LongMulDiv and ShortMulDiv for
													greater speed and precision. Removed fsg_InitScaling. [rb]
		<20>     8/22/90    MR      Only call fixmul when needed in finalComponentPass loop
		<19>      8/1/90    MR      Add line to set non90DegreeTransformation
		<18>     7/26/90    MR      remove references to metricInfo junk, don't include ToolUtils.h
		<17>     7/18/90    MR      Change error return type to int, split WorkSpace routine into
													two calls, added SWAPW macros
		<16>     7/14/90    MR      Fixed reference to const SQRT2 to FIXEDSQRT2
		<15>     7/13/90    MR      Ansi-C stuff, tried to use correct sizes for variables to avoid
									coercion (sp?)
		<12>     6/21/90    MR      Add calls to ReleaseSfntFrag
		<11>      6/4/90    MR      Remove MVT, change matrix to have bottom right element be a
									fixed.
		<10>      6/1/90    MR      Thou shalt not pay no more attention to the MVT!
		<8+>     5/29/90    MR      look for problem in Max45Trick
		 <8>     5/21/90    RB      bugfix in fsg_InitInterpreterTrans setting key->imageState
		 <7>      5/9/90    MR      Fix bug in MoreThanXYStretch
		 <6>      5/4/90    RB      support for new scan converter and decryption          mrr - add
									fsg_ReverseContours and key->reverseContour         to account
									for glyphs that are flipped.         This keeps the
									winding-number correct for         the scan converter.  Mike
									fixed fsg_Identity
		 <5>      5/3/90    RB      support for new scan converter and decryption  mrr - add
									fsg_ReverseContours and key->reverseContour to account for
									glyphs that are flipped. This keeps the winding-number correct
									for the scan converter.
		 <4>     4/10/90    CL      Fixed infinite loop counter - changed uint16 to int16 (Mikey).
		 <3>     3/20/90    CL      Added HasPerspective for finding fast case
									Removed #ifdef SLOW, OLD
									Changed NormalizeTransformation to use fpem (16.16) and to use max instead of length
									and to loop instead of recurse.
									Removed compensation for int ppem in fsg_InitInterpreterTrans (not needed with fpem)
									Greased loops in PreTransformGlyph, PostTransformGlyph, LocalPostTransformGlyph,
													 ShiftChar, ZeroOutTwilightZone, InitLocalT
									Changed GetPreMultipliers to special case unit vector * 2x2 matrix
									Added support for ppemDot6 and pointSizeDot6
									Changed fsg_MxMul to treat the perspective elements as Fracts
									arrays to pointers in ScaleChar
									Fixed bugs in loops in posttransformglyph, convert loops to --numPts >= 0
		 <2>     2/27/90    CL      It reconfigures itself during runtime !  New lsb and rsb
									calculation.  Shift bug in instructed components:  New error
									code for missing but needed table. (0x1409)  Optimization which
									has to do with shifting and copying ox/x and oy/y.  Fixed new
									format bug.  Changed transformed width calculation.  Fixed
									device metrics for transformed uninstructed sidebearing
									characters.  Dropoutcontrol scanconverter and SCANCTRL[]
									instruction.  Fixed transformed component bug.
									
	   <3.3>    11/14/89    CEL     Left Side Bearing should work right for any transformation. The
									phantom points are in, even for components in a composite glyph.
									They should also work for transformations. Device metric are
									passed out in the output data structure. This should also work
									with transformations. Another leftsidebearing along the advance
									width vector is also passed out. whatever the metrics are for
									the component at it's level. Instructions are legal in
									components. The old perspective bug has been fixed. The
									transformation is internally automatically normalized. This
									should also solve the overflow problem we had. Changed
									sidebearing point calculations to use 16.16 precision. For zero
									or negative numbers in my tricky/fast square root computation it
									would go instable and loop forever. It was not able to handle
									large transformations correctly. This has been fixed and the
									normalization may call it self recursively to gain extra
									precision! It used to normalize an identity transformation
									unecessarily.
	   <3.2>     10/6/89    CEL     Phantom points were removed causing a rounding of last 2 points
									bug. Characters would become distorted.
	   <3.1>     9/27/89    CEL     Fixed transformation anchor point bug.
	   <3.0>     8/28/89    sjk     Cleanup and one transformation bugfix
	   <2.2>     8/14/89    sjk     1 point contours now OK
	   <2.1>      8/8/89    sjk     Improved encryption handling
	   <2.0>      8/2/89    sjk     Just fixed EASE comment
	   <1.5>      8/1/89    sjk     Added composites and encryption. Plus some
									enhanclocalpostements.
	   <1.4>     6/13/89    SJK     Comment
	   <1.3>      6/2/89    CEL     16.16 scaling of metrics, minimum recommended ppem, point size 0
									bug, correct transformed integralized ppem behavior, pretty much
									so
	   <1.2>     5/26/89    CEL     EASE messed up on "c" comments
	  <y1.1>  5/26/89    CEL     Integrated the new Font Scaler 1.0 into Spline Fonts
	   <1.0>     5/25/89    CEL     Integrated 1.0 Font scaler into Bass code for the first time.

	To Do:
*/
/* rwb r/24/90 - Add support for scanControlIn and scanControlOut variables in global graphiscs
 * state
 */
/** System Includes **/

#define FSCFG_INTERNAL

/** FontScaler's Includes **/
#include "fserror.h"
#include "fscdefs.h"
#include "fontmath.h"
#include "fnt.h"
#include "interp.h"
#include "sfntaccs.h"
#include "fsglue.h"
#include "scale.h"

/*  CONSTANTS   */

/*  These constants are used for interpreting the scan control and scan type
	fields returned by the interpreter. They are documented in the TrueType
	specification under the SCANCTRL and SCANTYPE instructions.
 */

#define SCANINFO_SIZE_MASK   0x000000FF
#define SCANINFO_FLAGS_MASK  0x00003F00
#define SCANINFO_TYPE_MASK   0xFFFF0000
#define SCANINFO_SIZE_CLEAR  ~SCANINFO_SIZE_MASK
#define SCANINFO_FLAGS_CLEAR ~SCANINFO_FLAGS_MASK
#define SCANINFO_TYPE_CLEAR  ~SCANINFO_TYPE_MASK
#define SCANINFO_FLAGS_DONT  0x00003800
#define SCANINFO_FLAGS_DO    0x00000700
#define SCANCTRL_SIZE_MASK                   0x000000FF
#define SCANCTRL_DROPOUT_ALL_SIZES           0xFF
#define SCANCTRL_DROPOUT_IF_LESS             0x0100
#define SCANCTRL_DROPOUT_IF_ROTATED          0x0200
#define SCANCTRL_DROPOUT_IF_STRETCHED        0x0400
#define SCANCTRL_NODROP_UNLESS_LESS          0x0800
#define SCANCTRL_NODROP_UNLESS_ROTATED       0x1000
#define SCANCTRL_NODROP_UNLESS_STRETCH       0x2000
#define SCANTYPE_UNINITIALIZED               0xFFFF

/* fo the key->imageState field */
#define IMAGESTATE_ROTATED      0x0400
#define IMAGESTATE_STRETCHED    0x1000
#define IMAGESTATE_NON_POS_RECT 0x2000
#define IMAGESTATE_SIZE_MASK    0x00FF
#define IMAGESTATE_MAX_PPEM_SIZE 0x000000FF

#define COMPOSITE_ROOT                  0
#define MAX_TWILIGHT_CONTOURS       1
#define DEFAULT_COMPONENT_ELEMENTS  3UL
#define DEFAULT_COMPONENT_DEPTH     1UL
static  const   transMatrix   IdentTransform =
	{{{ONEFIX,      0,      0},
	  {     0, ONEFIX,      0},
	  {     0,      0, ONEFIX}}};

/*********** macros ************/

#define MAX(a, b)   (((a) > (b)) ? (a) : (b))

#define CHECK_GLYPHDATA(pglyphdata) FS_ASSERT((( (pglyphdata)->acIdent[0] == 'G') &&                            \
											( (pglyphdata)->acIdent[1] == 'D')),"Illegal GlyphData pointer");
#define MAX_COMPONENT_DEPTH(pMaxProfile) (uint32)MAX (pMaxProfile->maxComponentDepth, DEFAULT_COMPONENT_DEPTH)
#define MAX_COMPONENT_ELEMENTS(pMaxProfile) (uint32)MAX (pMaxProfile->maxComponentElements, DEFAULT_COMPONENT_ELEMENTS)

#define MAX_NESTED_GLYPHS(pMaxProfile) (uint32)((MAX_COMPONENT_DEPTH(pMaxProfile) + 1) + MAX_COMPONENT_ELEMENTS(pMaxProfile));

/**********************************************************************************/
/*  TYPEDEFS    */

typedef enum {
	glyphSimple,
	glyphIncompleteComposite,
	glyphComposite,
	glyphUndefined
} GlyphTypes;


/* Glyph Data   */

typedef struct GlyphData GlyphData;

struct GlyphData{
	char        acIdent[2];             /* Identifier for GlyphData                         */
	GlyphData * pSibling;               /* Pointer to siblings                              */
	GlyphData * pChild;                 /* Pointer to children                              */
	GlyphData * pParent;                /* Pointer to parent                                */
	sfac_GHandle hGlyph;                /* Handle for font access                           */
	GlyphTypes  GlyphType;              /* Type of glyph                                    */
	uint16      usGlyphIndex;           /* Glyph Index                                      */
	BBOX        bbox;                   /* Bounding box for glyph                           */
	uint16      usNonScaledAW;          /* Nonscaled Advance Width                          */
	uint16      usNonScaledAH;          /* Nonscaled Advance Height                         */
	int16       sNonScaledLSB;          /* Nonscaled Left Side Bearing                      */
	int16       sNonScaledTSB;          /* Nonscaled Top Side Bearing                       */
	uint16      usDepth;                /* Depth of Glyph in composite tree                 */
	sfac_ComponentTypes MultiplexingIndicator;/* Flag for arguments of composites                */
	boolean     bRoundXYToGrid;         /* Round composite offsets to grid                  */
	int16       sXOffset;               /* X offset for composite (if supplied)             */
	int16       sYOffset;               /* Y offset for composite (if supplied)             */
	uint16      usAnchorPoint1;         /* Anchor Point 1 for composites (if not offsets)   */
	uint16      usAnchorPoint2;         /* Anchor Point 2 for composites (if not offsets)   */
	transMatrix mulT;                   /* Transformation matrix for composite              */
	boolean     bUseChildMetrics;       /* Should use child metrics?                        */
	boolean     bUseMyMetrics;          /* Is glyph USE_MY_METRICS?                         */
	boolean     bScaleCompositeOffset; 	/* false by default, Apple scale the composite offset, MS doesn't */ 
	point       ptDevLSB;               /* Left Side Bearing Point                          */
	point       ptDevRSB;               /* Right Side Bearing Point                         */
	uint16      usScanType;             /* ScanType value for this glyph                    */
	uint16      usSizeOfInstructions;   /* Size (in bytes) of glyph instructions            */
	uint8 *     pbyInstructions;        /* Pointer to glyph instructions                    */
	fnt_ElementType * pGlyphElement;    /* Current glyph element pointer                    */

	/* the following variables were added to allow correct handling of scaled/rotated coposite glyphs */
	transMatrix currentTMatrix;         /* current Transf matrix, composite + user transform */
	boolean     bSameTransformAsMaster; /* same transformation as the master glyph, no composite scaling or rotation  */
	int16       sNonScaledTopOriginX;   /* Nonscaled Top Origin X                            */
};

/**********************************************************************************/

/* PRIVATE PROTOTYPES <4> */

FS_PRIVATE void fsg_GetOutlineSizeAndOffsets(
	uint16      usMaxPoints,
	uint16      usMaxContours,
	fsg_OutlineFieldInfo * offsetPtr,
	uint32 *    pulOutlineSize,
	uint32 *    pulReusableMarker);

FS_PRIVATE ErrorCode    fsg_CreateGlyphData(
	sfac_ClientRec *    ClientInfo,         /* sfnt Client information           */
	LocalMaxProfile *   pMaxProfile,        /* Max Profile Table                     */
	fsg_TransformRec *  TransformInfo,      /* Transformation information        */
	void *              pvGlobalGS,         /* GlobalGS                              */
	fsg_WorkSpaceAddr * pWorkSpaceAddr,     /* WorkSpace Address                     */
	fnt_ElementType *   pTwilightElement,   /* Twilight zone element */
	FntTraceFunc        traceFunc,          /* Trace function for interpreter   */
	boolean             bUseHints,          /* True if glyph is gridfitted       */
	uint16 *            pusScanType,        /* ScanType value                        */
	boolean *           pbGlyphHasOutline,  /* Outline for glyph                 */
	uint16 *            pusNonScaledAW);     /* Return NonScaled Advance Width    */
	
FS_PRIVATE ErrorCode   fsg_ExecuteGlyph(
	sfac_ClientRec *    ClientInfo,         /* sfnt Client information           */
	LocalMaxProfile *   pMaxProfile,        /* Max Profile Table                     */
	fsg_TransformRec *  TransformInfo,      /* Transformation information         */
	uint32              ulGlyphDataCount,   /* Max nested components */
	void *              pvGlobalGS,         /* GlobalGS                              */
	GlyphData *         pGlyphData,         /* GlyphData pointer                     */
	fsg_WorkSpaceAddr * pWorkSpaceAddr,     /* WorkSpace Address                     */
	fnt_ElementType *   pTwilightElement,   /* Twilight zone element */
	FntTraceFunc        traceFunc,          /* Trace function for interpreter    */
	boolean             bUseHints,          /* True if glyph is gridfitted       */
	boolean *           pbHasOutline,      /* True if glyph has outline         */
    uint32*             pCompositePoints,   /* total number of point for composites, to check for overflow */
    uint32*             pCompositeContours); /* total number of contours for composites, to check for overflow */
	
FS_PRIVATE void fsg_ChooseNextGlyph(
	fsg_WorkSpaceAddr * pWorkSpaceAddr,     /* WorkSpace Address        */
	GlyphData *         pGlyphData,         /* GlyphData pointer        */
	GlyphData **        ppNextGlyphData);   /* Next GlyphData pointer   */

FS_PRIVATE ErrorCode    fsg_SimpleInnerGridFit (
	void *              pvGlobalGS,
	fnt_ElementType *   pTwilightElement,
	fnt_ElementType *   pGlyphElement,
	boolean             bUseHints,
	FntTraceFunc        traceFunc,
	uint16              usEmResolution,
	uint16              usNonScaledAW,
	uint16              usNonScaledAH,
	int16               sNonScaledLSB,
	int16               sNonScaledTSB,
	int16               sNonScaledTopOriginX,
	boolean				bSameTransformAsMaster, /* local transf. same as master transf.   */
	transMatrix		    CurrentTMatrix,               /* Current Transformation   */
	BBOX *              bbox,
	uint16              usSizeOfInstructions,
	uint8 *             instructionPtr,
	uint16 *            pusScanType,
	uint16 *            pusScanControl,
	boolean *           pbChangeScanControl);

FS_PRIVATE ErrorCode    fsg_CompositeInnerGridFit (
	void *              pvGlobalGS,
	fnt_ElementType *   pTwilightElement,
	fnt_ElementType *   pGlyphElement,
	boolean             bUseHints,
	FntTraceFunc        traceFunc,
	uint16              usEmResolution,
	uint16              usNonScaledAW,
	uint16              usNonScaledAH,
	int16               sNonScaledLSB,
	int16               sNonScaledTSB,
	int16               sNonScaledTopOriginX,
	boolean				bSameTransformAsMaster, /* local transf. same as master transf.   */
	transMatrix		    CurrentTMatrix,               /* Current Transformation   */
	BBOX *              bbox,
	uint16              usSizeOfInstructions,
	uint8 *             instructionPtr,
	uint16 *            pusScanType,
	uint16 *            pusScanControl,
	boolean *           pbChangeScanControl);

FS_PRIVATE void fsg_LinkChild(
	GlyphData *     pGlyphData,             /* GlyphData pointer        */
	GlyphData *     pChildGlyphData);       /* Child GlyphData pointer  */

FS_PRIVATE void fsg_MergeGlyphData(
	void *          pvGlobalGS,             /* GlobalGS            */
	GlyphData *     pChildGlyphData,       /* GlyphData pointer     */
	uint16          usEmResolution);

FS_PRIVATE void fsg_TransformChild(
	GlyphData *     pGlyphData);            /* GlyphData pointer    */

FS_PRIVATE void fsg_MergeScanType(
	GlyphData *     pGlyphData,             /* GlyphData pointer    */
	GlyphData *     pParentGlyphData);      /* GlyphData pointer    */

FS_PRIVATE boolean fsg_DoScanControl(
	uint16 usScanControl,
	uint32 ulImageState);

FS_PRIVATE void fsg_InitializeGlyphDataMemory(
	uint32                  ulGlyphDataCount,
	fsg_WorkSpaceAddr *     pWorkSpaceAddr);/* WorkSpace Address    */

FS_PRIVATE  ErrorCode fsg_AllocateGlyphDataMemory(
	uint32                  ulGlyphDataCount,
	fsg_WorkSpaceAddr *     pWorkSpaceAddr, /* WorkSpace Address    */
	GlyphData **            ppGlyphData);   /* GlyphData pointer    */

FS_PRIVATE void fsg_DeallocateGlyphDataMemory(
	fsg_WorkSpaceAddr * pWorkSpaceAddr,     /* WorkSpace Address    */
	GlyphData *         pGlyphData);        /* GlyphData pointer    */

FS_PRIVATE void fsg_InitializeGlyphData(
	GlyphData *             pGlyphData,     /* GlyphData pointer    */
	fsg_WorkSpaceAddr *     pWorkSpaceAddr, /* WorkSpace Address    */
	uint16                  usGlyphIndex,   /* Glyph Index          */
	uint16                  usDepth);       /* Glyph depth          */

FS_PRIVATE void fsg_CheckFit(
	int32       lSize1,
	int32       lSize2,
	int32       lSize3,
	int32       lTotalSize,
	uint32 *    pfResult);

FS_PRIVATE void  fsg_Embold(
	fsg_WorkSpaceAddr * pWorkSpaceAddr,
	void *              pvGlobalGS,
	boolean             bUseHints, /* True if glyph is gridfitted       */
	boolean             bBitmapEmboldening
#ifdef FSCFG_SUBPIXEL
	,boolean            bSubPixel
#endif // FSCFG_SUBPIXEL
	);     

void fsg_CheckOutlineOrientation (fnt_ElementType *pElement);

/* FSGlue Code  */

/* ..............MEMORY MANAGEMENT ROUTINES................ */


/*                                                              
 * fsg_PrivateFontSpaceSize : This data should remain intact for the life of the sfnt
 *              because function and instruction defs may be defined in the font program
 *              and/or the preprogram.
 */
/*

	 PRIVATE SPACE Memory Layout

typedef struct fsg_PrivateSpaceOffsets {
	 0  +===========+   ---------------------  <- PrivateSpaceOffsets.offset_storage;
		|           |
		|           |   TrueType Storage
		|           |
		+===========+   ---------------------  <- PrivateSpaceOffsets.offset_functions;
		|           |
		|           |   TrueType Function Defs
		|           |
		+===========+   ---------------------  <- PrivateSpaceOffsets.offset_instrDefs;
		|           |
		|           |   TrueType Instruction Defs
		|           |
		+===========+   ---------------------  <- PrivateSpaceOffsets.offset_controlValues;
		|           |
		|           |   TrueType Scaled CVT
		|           |
		+===========+   ---------------------  <- PrivateSpaceOffsets.offset_globalGS;
		| pStack    |
		| pStorage  |
		| pCVT      |
		| pFDEF     |   TrueType Global GS
		| pIDEF     |
		| pFPGM     |
		| pPPGM     |
		| pGlyphPgm |
		+===========+   ---------------------  <- PrivateSpaceOffsets.offset_FontProgram;
		|           |
		|           |   TrueType Font Program
		|           |
		+===========+   ---------------------  <- PrivateSpaceOffsets.offset_PreProgram;
		|           |
		|           |   TrueType Pre Program
		|           |
		+===========+   ---------------------  <- PrivateSpaceOffsets.offset_TwilightZone;
		|   poox    |
		+-----------+
		|    pox    |
		+-----------+
		|    px     |   Twilight Element
		+-----------+
		:   ...     :
		+-----------+
		|    pep    |
		+-----------+
		|    nc     |
		+===========+   ---------------------  <- PrivateSpaceOffsets.offset_TwilightOutline;
		|x[maxtzpts]|   Twilight Outline
		+-----------+
		|y[maxtzpts]|
		+-----------+
		:   ...     :
		+-----------+
		|ep[maxtzct]|
		+-----------+
		|ox[maxtzpt]|
		+-----------+
		|oox[mxtzpt]|
		+-----------+
		:   ...     :
		+-----------+
		|f[maxtzpts]|
		+===========+   ---------------------

*/
FS_PUBLIC uint32  fsg_PrivateFontSpaceSize (
	sfac_ClientRec *            ClientInfo,
	LocalMaxProfile *           pMaxProfile,      /* Max Profile Table    */
	fsg_PrivateSpaceOffsets *   PrivateSpaceOffsets)
{
	uint32  ulOutlineSize;
	uint32  ulReusableMarker;   /* Unused dummy variable */
    uint32  ulLastOffset;

	PrivateSpaceOffsets->offset_storage         = 0L;
	PrivateSpaceOffsets->offset_functions       = PrivateSpaceOffsets->offset_storage         + (uint32)sizeof (F26Dot6) * (uint32)pMaxProfile->maxStorage;
	PrivateSpaceOffsets->offset_instrDefs       = PrivateSpaceOffsets->offset_functions   + (uint32)sizeof (fnt_funcDef) * (uint32)pMaxProfile->maxFunctionDefs;
	PrivateSpaceOffsets->offset_controlValues   = PrivateSpaceOffsets->offset_instrDefs   + (uint32)sizeof (fnt_instrDef) * (uint32)pMaxProfile->maxInstructionDefs;     /* <4> */
	PrivateSpaceOffsets->offset_globalGS        = PrivateSpaceOffsets->offset_controlValues + (uint32)sizeof (F26Dot6) *
		((uint32)SFAC_LENGTH (ClientInfo, sfnt_controlValue) / (uint32)sizeof (sfnt_ControlValue));

	ALIGN(voidPtr, PrivateSpaceOffsets->offset_globalGS);
#ifdef FSCFG_SUBPIXEL
	PrivateSpaceOffsets->offset_storageSubPixel         = PrivateSpaceOffsets->offset_globalGS    + (uint32)sizeof (fnt_GlobalGraphicStateType);
	PrivateSpaceOffsets->offset_functionsSubPixel       = PrivateSpaceOffsets->offset_storageSubPixel         + (uint32)sizeof (F26Dot6) * (uint32)pMaxProfile->maxStorage;
	PrivateSpaceOffsets->offset_instrDefsSubPixel       = PrivateSpaceOffsets->offset_functionsSubPixel   + (uint32)sizeof (fnt_funcDef) * (uint32)pMaxProfile->maxFunctionDefs;
	PrivateSpaceOffsets->offset_controlValuesSubPixel   = PrivateSpaceOffsets->offset_instrDefsSubPixel   + (uint32)sizeof (fnt_instrDef) * (uint32)pMaxProfile->maxInstructionDefs;     /* <4> */
	PrivateSpaceOffsets->offset_globalGSSubPixel        = PrivateSpaceOffsets->offset_controlValuesSubPixel + (uint32)sizeof (F26Dot6) *
		((uint32)SFAC_LENGTH (ClientInfo, sfnt_controlValue) / (uint32)sizeof (sfnt_ControlValue));

	ALIGN(voidPtr, PrivateSpaceOffsets->offset_globalGSSubPixel);
	PrivateSpaceOffsets->offset_FontProgram     = PrivateSpaceOffsets->offset_globalGSSubPixel + (uint32)sizeof (fnt_GlobalGraphicStateType);
#else
	PrivateSpaceOffsets->offset_FontProgram     = PrivateSpaceOffsets->offset_globalGS    + (uint32)sizeof (fnt_GlobalGraphicStateType);
#endif // FSCFG_SUBPIXEL
	PrivateSpaceOffsets->offset_PreProgram      = PrivateSpaceOffsets->offset_FontProgram + (uint32)SFAC_LENGTH (ClientInfo, sfnt_fontProgram);

    PrivateSpaceOffsets->offset_TwilightZone    = PrivateSpaceOffsets->offset_PreProgram      + (uint32)SFAC_LENGTH (ClientInfo, sfnt_preProgram);
	ALIGN(voidPtr, PrivateSpaceOffsets->offset_TwilightZone);

#ifdef FSCFG_SUBPIXEL
    PrivateSpaceOffsets->offset_TwilightZoneSubPixel    = PrivateSpaceOffsets->offset_TwilightZone + (uint32)sizeof (fnt_ElementType);
	ALIGN(voidPtr, PrivateSpaceOffsets->offset_TwilightZoneSubPixel);
/*
	Setup the twilight zone element data structure. This data structure will
	contain all of the address into the twilight zone outline space.
*/
	PrivateSpaceOffsets->offset_TwilightOutline = PrivateSpaceOffsets->offset_TwilightZoneSubPixel + (uint32)sizeof (fnt_ElementType);
	ALIGN(int32, PrivateSpaceOffsets->offset_TwilightOutline);
#else
/*
	Setup the twilight zone element data structure. This data structure will
	contain all of the address into the twilight zone outline space.
*/
	PrivateSpaceOffsets->offset_TwilightOutline = PrivateSpaceOffsets->offset_TwilightZone + (uint32)sizeof (fnt_ElementType);
	ALIGN(int32, PrivateSpaceOffsets->offset_TwilightOutline);
    ulLastOffset = PrivateSpaceOffsets->offset_TwilightOutline;
#endif // FSCFG_SUBPIXEL

/*
	Setup Twilight Zone outline space. This space contains all of the components
	to describe a Twilight Zone outline. Set the offset to our current position,
	and as we calculate the size of this outline space, update the field
	offsets e.g. x, ox, oox, &c.
*/
	/*** Outline -- TWILIGHT ZONE ***/

	fsg_GetOutlineSizeAndOffsets(
		pMaxProfile->maxTwilightPoints,
		MAX_TWILIGHT_CONTOURS,
		&(PrivateSpaceOffsets->TwilightOutlineFieldOffsets),
		&ulOutlineSize,
		&ulReusableMarker);

#ifdef FSCFG_SUBPIXEL
	PrivateSpaceOffsets->offset_TwilightOutlineSubPixel = PrivateSpaceOffsets->offset_TwilightOutline + ulOutlineSize;
	ALIGN(int32, PrivateSpaceOffsets->offset_TwilightOutlineSubPixel);
    ulLastOffset = PrivateSpaceOffsets->offset_TwilightOutlineSubPixel;
#endif // FSCFG_SUBPIXEL

#ifdef FSCFG_FONTOGRAPHER_BUG
/*
		Fontographer 3.5 has a bug. This is causing numerous symbol fonts to
		have the critical error : Inst: RCVT CVT Out of range. CVT = 255
		This flag is meant to be set under Windows. If will cause additional
		memory to be allocated for the CVT if necessary in order to be sure
		that this illegal read will access memory within the legal range.
		Under a secure rasterizer, this flag will cause RCVT with CVT <= 255
		and CVT > NumCvt to be classified as error instead of critical error */

	if ((ulLastOffset + ulOutlineSize) - PrivateSpaceOffsets->offset_controlValues < 256 * (uint32)sizeof (F26Dot6))
	{
		ulOutlineSize = (256 * (uint32)sizeof (F26Dot6)) + PrivateSpaceOffsets->offset_controlValues - ulLastOffset;
	}
#endif // FSCFG_FONTOGRAPHER_BUG

	return ((ulLastOffset + ulOutlineSize) - PrivateSpaceOffsets->offset_storage);
}


/*                          
 * fsg_WorkSpaceSetOffsets : This stuff changes with each glyph
 *
 * Computes the workspace size and sets the offsets into it.
 *
 */

/*

	WORKSPACE Memory Layout

	  0 +===========+    ---------------------  <- WorkSpaceOffsets.ulGlyphElementOffset
		|   poox    |
		+-----------+
		|    pox    |
		+-----------+
		|    px     |   Glyph Element 1
		+-----------+
		:   ...     :
		+-----------+
		|    pep    |
		+-----------+
		|    nc     |
		+===========+   ---------------------
		|   poox    |
		+-----------+
		|    pox    |
		+-----------+
		|    px     |   Glyph Element 2
		+-----------+
		:   ...     :
		+-----------+
		|    pep    |
		+-----------+
		|    nc     |
		+===========+   ---------------------
		|           |
		:           :          :
		|           |
		+===========+   ---------------------
		|   poox    |
		+-----------+
		|    pox    |
		+-----------+
		|    px     |   Glyph Element [MaxComponentDepth + 1]
		+-----------+
		:   ...     :
		+-----------+
		|    pep    |
		+-----------+
		|    nc     |
		+===========+   ---------------------  <- WorkSpaceOffsets.ulGlyphOutlineOffset
		|x[maxpts]  |   Glyph Outline
		+-----------+
		|y[maxpts]  |
		+-----------+
		:   ...     :
		+-----------+
		|ep[maxctrs]|
		+-----------+
		|ox[maxpts] |   <- WorkSpaceOffsets.ulReusableMemoryOffset


        !!! with SubPixel, we need to put the ulReusableMemoryOffset after ox because of the conversion done in GetContourData !!!
		+-----------+
		|oox[maxpts]|
		+-----------+
		:   ...     :
		+-----------+
		|f[maxpts]  |
		+===========+   ---------------------  <- WorkSpaceOffsets.ulGlyphDataByteSetBaseOffset
		| T| F| T| F|
		+-----------+
		| F| F| F| F|
		+-----------+
		| F| F| F| F|   Glyph Data Allocation ByteSet
		+-----------+   (number of bytes = ulGlyphDataCount)
		| F| F| F| F|
		+-----------+
		| F| F| F| F|
		+===========+   ---------------------  <- WorkSpaceOffsets.ulGlyphDataBaseOffset
		|  acIdent  |
		+-----------+
		| pSibling  |
		+-----------+
		|  pChild   |
		+-----------+
		|  pParent  |
		+-----------+   GlyphData 1
		|  hGlyph   |
		+-----------+
		| GlyphType |
		+-----------+
		:           :
		+-----------+
		|GlyphElemnt|
		+===========+   ---------------------
		|  acIdent  |
		+-----------+
		| pSibling  |
		+-----------+
		|  pChild   |
		+-----------+
		|  pParent  |
		+-----------+   GlyphData 2
		|  hGlyph   |
		+-----------+
		| GlyphType |
		+-----------+
		:           :
		+-----------+
		|GlyphElemnt|
		+===========+   ---------------------
		|           |
		:           :           :
		|           |
		+===========+   ---------------------
		|  acIdent  |
		+-----------+
		| pSibling  |
		+-----------+
		|  pChild   |
		+-----------+
		|  pParent  |
		+-----------+   GlyphData [ulGlyphDataCount]
		|  hGlyph   |
		+-----------+
		| GlyphType |
		+-----------+
		:           :
		+-----------+
		|GlyphElemnt|
		+===========+   ---------------------  <- WorkSpaceOffsets.ulStackOffset
		|           |
		|           |
		|           |   Stack
		|           |
		|           |
		|           |
		+===========+   ---------------------

*/

FS_PUBLIC uint32    fsg_WorkSpaceSetOffsets (
	LocalMaxProfile *        pMaxProfile,    /* Max Profile Table    */
	fsg_WorkSpaceOffsets *  WorkSpaceOffsets,
	int32 *                 plExtraWorkSpace)
{
	uint32                       ulOutlineDataSize;
	uint32                       ulWorkSpacePos;
	uint32                       ulGlyphDataCount;
    uint16                       maxStackElements;

	ulWorkSpacePos = 0UL;

/*
	Setup the glyph element data array. This data structure contains all of the
	addresses into the glyph outline space. There are the same number of glyph
	element arrays as there are outline spaces; this allows us to handle the
	worstcase composite in the font.
*/
	WorkSpaceOffsets->ulGlyphElementOffset = ulWorkSpacePos;
	ulWorkSpacePos += (uint32)sizeof (fnt_ElementType) *
		  (uint32)(MAX_COMPONENT_DEPTH(pMaxProfile) + 1);

/*** Outline -- GLYPH *****/
/*
	Setup Glyph outline space. This space contains all of the components
	to describe a Glyph outline. Set the offset to our current position,
	and as we calculate the size of this outline space, update the elemental
	offsets e.g. x, ox, oox, &c.

	Once we have calculated the size of one outline space, we will duly note
	its size, and then add enough space to handle the outlines for the worst
	case composite depth in the font.
*/
	ALIGN(int16, ulWorkSpacePos);
	WorkSpaceOffsets->ulGlyphOutlineOffset = ulWorkSpacePos; /* Remember start of Glyph Element */

	fsg_GetOutlineSizeAndOffsets(
		(uint16)(PHANTOMCOUNT + MAX (pMaxProfile->maxPoints, pMaxProfile->maxCompositePoints)),
		(uint16)MAX (pMaxProfile->maxContours, pMaxProfile->maxCompositeContours),
		&(WorkSpaceOffsets->GlyphOutlineFieldOffsets),
		&ulOutlineDataSize,
		(uint32 *)&(WorkSpaceOffsets->ulReusableMemoryOffset));

	/* Adjust Reusable memory marker to be based from zero, rather than GlyphOutline */

	WorkSpaceOffsets->ulReusableMemoryOffset += WorkSpaceOffsets->ulGlyphOutlineOffset;

	ulWorkSpacePos += ulOutlineDataSize;
/*
	Set the GlyphData ByteSet array. This array is used to track the memory used
	in GlyphData. Each entry in this array is a boolean.  One needs to also
	calculate the number of GlyphData's that will be needed to handle the
	worstcase composite in the font.
*/
	ALIGN(boolean, ulWorkSpacePos);
	WorkSpaceOffsets->ulGlyphDataByteSetOffset = ulWorkSpacePos;
	ulGlyphDataCount = MAX_NESTED_GLYPHS(pMaxProfile);

	ulWorkSpacePos += ulGlyphDataCount * (uint32)sizeof (boolean);
/*
	Set up the GlyphData array. This array contains the information needed
	to describe composites and components for a glyph.
*/
	ALIGN(voidPtr, ulWorkSpacePos);
	WorkSpaceOffsets->ulGlyphDataOffset = ulWorkSpacePos;
	ulWorkSpacePos += (uint32)sizeof(GlyphData) * ulGlyphDataCount;


	ALIGN(F26Dot6, ulWorkSpacePos);
	WorkSpaceOffsets->ulStackOffset = ulWorkSpacePos;

    maxStackElements = pMaxProfile->maxStackElements;

#ifdef FSCFG_EUDC_EDITOR_BUG
    if (maxStackElements == 0)
    {
        maxStackElements = 1;
    }
#endif // FSCFG_EUDC_EDITOR_BUG

	ulWorkSpacePos += (uint32)maxStackElements * (uint32)sizeof (F26Dot6);

/* Calculate amount of extra memory */

	*plExtraWorkSpace = (int32)ulWorkSpacePos - (int32)WorkSpaceOffsets->ulReusableMemoryOffset;
	WorkSpaceOffsets->ulMemoryBase6Offset = 0L;
	WorkSpaceOffsets->ulMemoryBase7Offset = 0L;

/* Return the total size of the WorkSpace memory.   */

	return(ulWorkSpacePos);

}

FS_PRIVATE void fsg_GetOutlineSizeAndOffsets(
	uint16                  usMaxPoints,
	uint16                  usMaxContours,
	fsg_OutlineFieldInfo *  offsetPtr,
	uint32 *                pulOutlineSize,
	uint32 *                pulReusableMarker)

{
	uint32      ulArraySize;

	offsetPtr->onCurve = 0;

	*pulOutlineSize    = (uint32)usMaxPoints * (uint32)sizeof (uint8);
	ALIGN(int16, *pulOutlineSize);

	offsetPtr->sp   = *pulOutlineSize;
	ulArraySize = (uint32)usMaxContours * (uint32)sizeof (int16);
	*pulOutlineSize += ulArraySize;
	offsetPtr->ep   = *pulOutlineSize;
	*pulOutlineSize += ulArraySize;

	/* need to be before the reusable marker, now that this flag is exported */
	offsetPtr->fc       = *pulOutlineSize;
	*pulOutlineSize    += (uint32)usMaxContours * (uint32)sizeof (uint8);

	ALIGN(F26Dot6, *pulOutlineSize);
	offsetPtr->x       = *pulOutlineSize;
	ulArraySize = (uint32)usMaxPoints * (uint32)sizeof (F26Dot6);
	*pulOutlineSize    += ulArraySize;
	offsetPtr->y       = *pulOutlineSize;
	*pulOutlineSize    += ulArraySize;

#ifndef FSCFG_SUBPIXEL
	*pulReusableMarker = *pulOutlineSize;
	ALIGN(voidPtr, *pulReusableMarker);
#endif // FSCFG_SUBPIXEL
	/* Everything below this point can be reused during contour scanning */

	offsetPtr->ox      = *pulOutlineSize;
	*pulOutlineSize    += ulArraySize;

#ifdef FSCFG_SUBPIXEL
	*pulReusableMarker = *pulOutlineSize;
	ALIGN(voidPtr, *pulReusableMarker);
#endif // FSCFG_SUBPIXEL

    offsetPtr->oy      = *pulOutlineSize;
	*pulOutlineSize    += ulArraySize;

    offsetPtr->oox     = *pulOutlineSize;
	*pulOutlineSize    += ulArraySize;
	offsetPtr->ooy     = *pulOutlineSize;
	*pulOutlineSize    += ulArraySize;

	offsetPtr->f       = *pulOutlineSize;
	*pulOutlineSize    += (uint32)usMaxPoints * (uint32)sizeof (uint8);

    ALIGN(int32, *pulOutlineSize);

#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	offsetPtr->pcr      = *pulOutlineSize;
	*pulOutlineSize    += (uint32)usMaxPoints * (uint32)sizeof (PhaseControlRelation);
#endif

}


FS_PUBLIC void  fsg_UpdatePrivateSpaceAddresses(
	sfac_ClientRec *        ClientInfo,     /* Cached sfnt information  */
	LocalMaxProfile *       pMaxProfile,     /* Max Profile Table         */
	char *                  pPrivateFontSpace,
	fsg_PrivateSpaceOffsets * PrivateSpaceOffsets,
	void *                  pvStack,        /* pointer to stack         */
	void **                 pvFontProgram,  /* pointer to font program  */
	void **                 pvPreProgram)   /* pointer to pre program   */
{
	void *                       pvGlobalGS;
	void *                       pvCVT;          /* pointer to CVT  */
	void *                       pvStore;
	void *                       pvFuncDef;
	void *                       pvInstrDef;
	uint32                       ulLengthFontProgram, ulLengthPreProgram;

	pvCVT =         pPrivateFontSpace + PrivateSpaceOffsets->offset_controlValues;
	pvStore =       pPrivateFontSpace + PrivateSpaceOffsets->offset_storage;
	pvFuncDef =     pPrivateFontSpace + PrivateSpaceOffsets->offset_functions;
	pvInstrDef =    pPrivateFontSpace + PrivateSpaceOffsets->offset_instrDefs;
	pvGlobalGS =    pPrivateFontSpace + PrivateSpaceOffsets->offset_globalGS;

	*pvFontProgram =  pPrivateFontSpace + PrivateSpaceOffsets->offset_FontProgram;
	ulLengthFontProgram = SFAC_LENGTH(ClientInfo, sfnt_fontProgram);
	*pvPreProgram =   pPrivateFontSpace + PrivateSpaceOffsets->offset_PreProgram;
	ulLengthPreProgram = SFAC_LENGTH(ClientInfo, sfnt_preProgram);

	itrp_UpdateGlobalGS(pvGlobalGS, pvCVT, pvStore, pvFuncDef, pvInstrDef, pvStack,
		pMaxProfile, (uint16)((uint32)SFAC_LENGTH (ClientInfo, sfnt_controlValue) / (uint32)sizeof (sfnt_ControlValue)),
		ulLengthFontProgram, *pvFontProgram, ulLengthPreProgram, *pvPreProgram, ClientInfo->lClientID);

#ifdef FSCFG_SUBPIXEL
    /* prepare the second pvGlobalGS for SubPixel compatible width */
	pvCVT =         pPrivateFontSpace + PrivateSpaceOffsets->offset_controlValuesSubPixel;
	pvStore =       pPrivateFontSpace + PrivateSpaceOffsets->offset_storageSubPixel;
	pvFuncDef =     pPrivateFontSpace + PrivateSpaceOffsets->offset_functionsSubPixel;
	pvInstrDef =    pPrivateFontSpace + PrivateSpaceOffsets->offset_instrDefsSubPixel;
	pvGlobalGS =    pPrivateFontSpace + PrivateSpaceOffsets->offset_globalGSSubPixel;

	itrp_UpdateGlobalGS(pvGlobalGS, pvCVT, pvStore, pvFuncDef, pvInstrDef, pvStack,
		pMaxProfile, (uint16)((uint32)SFAC_LENGTH (ClientInfo, sfnt_controlValue) / (uint32)sizeof (sfnt_ControlValue)),
		ulLengthFontProgram, *pvFontProgram, ulLengthPreProgram, *pvPreProgram, ClientInfo->lClientID);
#endif // FSCFG_SUBPIXEL

}

FS_PUBLIC void  fsg_UpdateWorkSpaceAddresses(
	char *                  pWorkSpace,
	fsg_WorkSpaceOffsets *  WorkSpaceOffsets,
	fsg_WorkSpaceAddr *     pWorkSpaceAddr)
{
	pWorkSpaceAddr->pStack = (F26Dot6 *)(WorkSpaceOffsets->ulStackOffset + pWorkSpace);
	pWorkSpaceAddr->pGlyphOutlineBase = WorkSpaceOffsets->ulGlyphOutlineOffset + pWorkSpace;
	pWorkSpaceAddr->pGlyphElement = (fnt_ElementType *)(WorkSpaceOffsets->ulGlyphElementOffset + pWorkSpace);
	pWorkSpaceAddr->pGlyphDataByteSet = (boolean *)(WorkSpaceOffsets->ulGlyphDataByteSetOffset + pWorkSpace);
	pWorkSpaceAddr->pvGlyphData = (void *)(WorkSpaceOffsets->ulGlyphDataOffset + pWorkSpace);
	pWorkSpaceAddr->pReusableMemoryMarker = WorkSpaceOffsets->ulReusableMemoryOffset + pWorkSpace;
}

FS_PUBLIC void  fsg_UpdateWorkSpaceElement(
	fsg_WorkSpaceOffsets *  WorkSpaceOffsets,
	fsg_WorkSpaceAddr *     pWorkSpaceAddr)
{
	char *                  pOutlineBase;
	fnt_ElementType *       pGlyphElement;        /* Address of Glyph Element array   */
	fsg_OutlineFieldInfo *  pOffset;

	pOutlineBase =  (char *)pWorkSpaceAddr->pGlyphOutlineBase;
	pGlyphElement = pWorkSpaceAddr->pGlyphElement;

	/* Note: only the first level glyph element has address updated. Second */
	/* levels are updated when referenced.                                           */

	pOffset             = & (WorkSpaceOffsets->GlyphOutlineFieldOffsets);

	pGlyphElement->x        = (F26Dot6 *) (pOutlineBase + pOffset->x);
	pGlyphElement->y        = (F26Dot6 *) (pOutlineBase + pOffset->y);
	pGlyphElement->ox       = (F26Dot6 *) (pOutlineBase + pOffset->ox);
	pGlyphElement->oy       = (F26Dot6 *) (pOutlineBase + pOffset->oy);
	pGlyphElement->oox      = (F26Dot6 *) (pOutlineBase + pOffset->oox);
	pGlyphElement->ooy      = (F26Dot6 *) (pOutlineBase + pOffset->ooy);
	pGlyphElement->sp       = (int16 *) (pOutlineBase + pOffset->sp);
	pGlyphElement->ep       = (int16 *) (pOutlineBase + pOffset->ep);
	pGlyphElement->onCurve  = (uint8 *) (pOutlineBase + pOffset->onCurve);
	pGlyphElement->f        = (uint8 *) (pOutlineBase + pOffset->f);

	pGlyphElement->fc       = (uint8 *) (pOutlineBase + pOffset->fc);

#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	pGlyphElement->pcr      = (PhaseControlRelation *) (pOutlineBase + pOffset->pcr);
#endif
}

FS_PUBLIC void *    fsg_QueryGlobalGS(
	char *                  pPrivateFontSpace,
	fsg_PrivateSpaceOffsets * PrivateSpaceOffsets)
{
	return ((void *)(pPrivateFontSpace + PrivateSpaceOffsets->offset_globalGS));
}

#ifdef FSCFG_SUBPIXEL
FS_PUBLIC void *    fsg_QueryGlobalGSSubPixel(
	char *                  pPrivateFontSpace,
	fsg_PrivateSpaceOffsets * PrivateSpaceOffsets)
{
	return ((void *)(pPrivateFontSpace + PrivateSpaceOffsets->offset_globalGSSubPixel));
}
#endif // FSCFG_SUBPIXEL

FS_PUBLIC void *      fsg_QueryTwilightElement(
	char *                  pPrivateFontSpace,
	fsg_PrivateSpaceOffsets * PrivateSpaceOffsets)
{
	fnt_ElementType *        pTwilightElement; /* Address of Twilight Zone Element */
	fsg_OutlineFieldInfo *  pOffset;
	char *                       pTemp;

	pOffset                 = &(PrivateSpaceOffsets->TwilightOutlineFieldOffsets);
	pTemp                   = pPrivateFontSpace + PrivateSpaceOffsets->offset_TwilightOutline;
	pTwilightElement        = (fnt_ElementType *)(pPrivateFontSpace + PrivateSpaceOffsets->offset_TwilightZone);

	pTwilightElement->x         = (F26Dot6 *) (pTemp + pOffset->x);
	pTwilightElement->y         = (F26Dot6 *) (pTemp + pOffset->y);
	pTwilightElement->ox        = (F26Dot6 *) (pTemp + pOffset->ox);
	pTwilightElement->oy        = (F26Dot6 *) (pTemp + pOffset->oy);
	pTwilightElement->oox       = (F26Dot6 *) (pTemp + pOffset->oox);
	pTwilightElement->ooy       = (F26Dot6 *) (pTemp + pOffset->ooy);
	pTwilightElement->sp        = (int16 *) (pTemp + pOffset->sp);
	pTwilightElement->ep        = (int16 *) (pTemp + pOffset->ep);
	pTwilightElement->onCurve   = (uint8 *) (pTemp + pOffset->onCurve);
	pTwilightElement->f         = (uint8 *) (pTemp + pOffset->f);

	pTwilightElement->fc        = (uint8 *) (pTemp + pOffset->fc);

#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	pTwilightElement->pcr		= (PhaseControlRelation *) (pTemp + pOffset->pcr);
#endif

	return (void *)pTwilightElement;
}

#ifdef FSCFG_SUBPIXEL
FS_PUBLIC void *      fsg_QueryTwilightElementSubPixel(
	char *                  pPrivateFontSpace,
	fsg_PrivateSpaceOffsets * PrivateSpaceOffsets)
{
	fnt_ElementType *        pTwilightElement; /* Address of Twilight Zone Element */
	fsg_OutlineFieldInfo *  pOffset;
	char *                       pTemp;

	pOffset                 = &(PrivateSpaceOffsets->TwilightOutlineFieldOffsets);
	pTemp                   = pPrivateFontSpace + PrivateSpaceOffsets->offset_TwilightOutlineSubPixel;
	pTwilightElement        = (fnt_ElementType *)(pPrivateFontSpace + PrivateSpaceOffsets->offset_TwilightZoneSubPixel);

	pTwilightElement->x         = (F26Dot6 *) (pTemp + pOffset->x);
	pTwilightElement->y         = (F26Dot6 *) (pTemp + pOffset->y);
	pTwilightElement->ox        = (F26Dot6 *) (pTemp + pOffset->ox);
	pTwilightElement->oy        = (F26Dot6 *) (pTemp + pOffset->oy);
	pTwilightElement->oox       = (F26Dot6 *) (pTemp + pOffset->oox);
	pTwilightElement->ooy       = (F26Dot6 *) (pTemp + pOffset->ooy);
	pTwilightElement->sp        = (int16 *) (pTemp + pOffset->sp);
	pTwilightElement->ep        = (int16 *) (pTemp + pOffset->ep);
	pTwilightElement->onCurve   = (uint8 *) (pTemp + pOffset->onCurve);
	pTwilightElement->f         = (uint8 *) (pTemp + pOffset->f);

#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	pTwilightElement->pcr		= (PhaseControlRelation *) (pTemp + pOffset->pcr);
#endif
	return (void *)pTwilightElement;
}
#endif // FSCFG_SUBPIXEL

FS_PUBLIC void *      fsg_QueryStack(fsg_WorkSpaceAddr * pWorkSpaceAddr)
{
    /* we don't allow the stack to be used to pass informations between pre-program and glyph program
       or between two glyph programs */
	return ((void *)pWorkSpaceAddr->pStack);
}

FS_PUBLIC void *      fsg_QueryReusableMemory(
	char *                  pWorkSpace,
	fsg_WorkSpaceOffsets *  WorkSpaceOffsets)
{
	return pWorkSpace + WorkSpaceOffsets->ulReusableMemoryOffset;
}

FS_PUBLIC void  fsg_CheckWorkSpaceForFit(
	fsg_WorkSpaceOffsets *  WorkSpaceOffsets,
	int32                   lExtraWorkSpace,
	int32                   lMGWorkSpace,
	int32 *                 plSizeBitmap1,
	int32 *                 plSizeBitmap2)
{
	uint32              ulMemoryOffset;

	ulMemoryOffset = WorkSpaceOffsets->ulReusableMemoryOffset;

	ulMemoryOffset += (uint32)lMGWorkSpace;  /* correct for MeasureGlyph Workspace */
	lExtraWorkSpace -= lMGWorkSpace;

	WorkSpaceOffsets->ulMemoryBase6Offset = 0L;
	WorkSpaceOffsets->ulMemoryBase7Offset = 0L;

	/* Save original sizes */

	WorkSpaceOffsets->ulMemoryBase6Size = *plSizeBitmap1;
	WorkSpaceOffsets->ulMemoryBase7Size = *plSizeBitmap2;

	if( *plSizeBitmap1 > *plSizeBitmap2)
	{
		if( *plSizeBitmap1 <= lExtraWorkSpace )
		{
			WorkSpaceOffsets->ulMemoryBase6Offset = ulMemoryOffset;
			ulMemoryOffset += (uint32)*plSizeBitmap1;

			if (( *plSizeBitmap2 <= lExtraWorkSpace - *plSizeBitmap1 ) &&
				( *plSizeBitmap2 > 0L ))
			{
				WorkSpaceOffsets->ulMemoryBase7Offset = ulMemoryOffset;
				*plSizeBitmap2 = 0L;
			}
			*plSizeBitmap1 = 0L;
		}
		else if (( *plSizeBitmap2 <= lExtraWorkSpace ) &&
				 ( *plSizeBitmap2 > 0L))
		{
			WorkSpaceOffsets->ulMemoryBase7Offset = ulMemoryOffset;
			*plSizeBitmap2 = 0L;
		}

	}
	else  /* (plSizeBitmap1 <= *plSizeBitmap2) */
	{
		if(( *plSizeBitmap2 <= lExtraWorkSpace ) &&
		   ( *plSizeBitmap2 > 0L ))
		{
			WorkSpaceOffsets->ulMemoryBase7Offset = ulMemoryOffset;
			ulMemoryOffset += (uint32)*plSizeBitmap2;

			if (( *plSizeBitmap1 <= lExtraWorkSpace - *plSizeBitmap2 ) &&
				 ( *plSizeBitmap1 > 0L ))
			{
				WorkSpaceOffsets->ulMemoryBase6Offset = ulMemoryOffset;
				*plSizeBitmap1 = 0L;
			}
			*plSizeBitmap2 = 0L;
		}
		else if (( *plSizeBitmap1 <= lExtraWorkSpace ) &&
				 ( *plSizeBitmap1 > 0L ))
		{
			WorkSpaceOffsets->ulMemoryBase6Offset = ulMemoryOffset;
			*plSizeBitmap1 = 0L;
		}
	}
}

FS_PUBLIC void  fsg_GetRealBitmapSizes(
	fsg_WorkSpaceOffsets *  WorkSpaceOffsets,
	int32 *                 plSizeBitmap1,
	int32 *                 plSizeBitmap2)
{
	 *plSizeBitmap1 = WorkSpaceOffsets->ulMemoryBase6Size;
	 *plSizeBitmap2 = WorkSpaceOffsets->ulMemoryBase7Size;
}

FS_PUBLIC void  fsg_SetUpWorkSpaceBitmapMemory(
	char *                  pWorkSpace,
	fsg_WorkSpaceOffsets *  WorkSpaceOffsets,
	char *                  pClientBitmapPtr2,
	char *                  pClientBitmapPtr3,
	char **                 ppMemoryBase6,
	char **                 ppMemoryBase7)
{
	if(WorkSpaceOffsets->ulMemoryBase6Offset != 0L)
	{
		*ppMemoryBase6 = WorkSpaceOffsets->ulMemoryBase6Offset + (char *)pWorkSpace;
	}
	else
	{
		*ppMemoryBase6 = pClientBitmapPtr2;
	}

	if(WorkSpaceOffsets->ulMemoryBase7Offset != 0L)
	{
		  *ppMemoryBase7 = WorkSpaceOffsets->ulMemoryBase7Offset + (char *)pWorkSpace;
	}
	else
	{
		*ppMemoryBase7 = pClientBitmapPtr3;
	}
}

FS_PUBLIC void  fsg_GetWorkSpaceExtra(
	char *                  pWorkSpace,
	fsg_WorkSpaceOffsets *  WorkSpaceOffsets,
	char **                 ppWorkSpaceExtra)
{
	 *ppWorkSpaceExtra = (char *)(pWorkSpace + WorkSpaceOffsets->ulReusableMemoryOffset);
}

FS_PUBLIC void  fsg_QueryPPEM(
	void *      pvGlobalGS,
	uint16 *    pusPPEM)
{
	scl_QueryPPEM(pvGlobalGS, pusPPEM);
}

/*  Return PPEM in both X and Y and 90 degree rotation factor for sbit matching */

FS_PUBLIC void  fsg_QueryPPEMXY(
	void *              pvGlobalGS,
	fsg_TransformRec *  TransformInfo,
	uint16 *            pusPPEMX,
	uint16 *            pusPPEMY,
	uint16 *            pusRotation)
{
	*pusRotation = mth_90degRotationFactor( &TransformInfo->currentTMatrix );
	scl_QueryPPEMXY(pvGlobalGS, pusPPEMX, pusPPEMY);
}


/*  FSGlue Access Routines  */

FS_PUBLIC void  fsg_GetContourData(
	fsg_WorkSpaceAddr * pWorkSpaceAddr,
#ifdef FSCFG_SUBPIXEL
	boolean				bSubPixel,            
#endif // FSCFG_SUBPIXEL
	F26Dot6 **          pX,
	F26Dot6 **          pY,
	int16 **            pSp,
	int16 **            pEp,
	uint8 **            pOnCurve,
	uint8 **            pFc,
	uint16 *            pNc)
{
	fnt_ElementType *   pElement;

	pElement = pWorkSpaceAddr->pGlyphElement;

	*pX =       pElement->x;
	*pY =       pElement->y;
	*pSp =      pElement->sp;
	*pEp =      pElement->ep;
	*pOnCurve = pElement->onCurve;
	*pFc =     pElement->fc;
	*pNc      = (uint16)pElement->nc;
#ifdef FSCFG_SUBPIXEL
	if (bSubPixel)
	{
		/* we scale down the coordinate from x,y into ox, oy and return those */
		scl_ScaleDownFromSubPixelOverscale(pElement);
		*pX =       pElement->ox;
	}
#endif // FSCFG_SUBPIXEL
}

FS_PUBLIC uint32      fsg_GetContourDataSize(
	fsg_WorkSpaceAddr * pWorkSpaceAddr)
{
	fnt_ElementType *   pElement;

	pElement = pWorkSpaceAddr->pGlyphElement;

	return( scl_GetContourDataSize( pElement ) );
}

FS_PUBLIC void  fsg_DumpContourData(
	fsg_WorkSpaceAddr * pWorkSpaceAddr,
	uint8 **            ppbyOutline)
{
	fnt_ElementType *   pElement;

	pElement = pWorkSpaceAddr->pGlyphElement;

	scl_DumpContourData(pElement, ppbyOutline);
}

FS_PUBLIC void  fsg_RestoreContourData(
	uint8 **        ppbyOutline,
	F26Dot6 **      ppX,
	F26Dot6 **      ppY,
	int16 **        ppSp,
	int16 **        ppEp,
	uint8 **        ppOnCurve,
	uint8 **        ppFc,
	uint16 *        pNc)
{
	fnt_ElementType     pElement;

	scl_RestoreContourData(&pElement, ppbyOutline);

	*ppX =          pElement.x;
	*ppY =          pElement.y;
	*ppSp =         pElement.sp;
	*ppEp =         pElement.ep;
	*ppOnCurve =    pElement.onCurve;
	*ppFc =         pElement.fc;
	*pNc =          (uint16)pElement.nc;
}

FS_PUBLIC void  fsg_GetDevAdvanceWidth(
	fsg_WorkSpaceAddr * pWorkSpaceAddr,
	point *             pDevAdvanceWidth)
{
	fnt_ElementType *   pElement;

	pElement = pWorkSpaceAddr->pGlyphElement;

	scl_CalcDevAdvanceWidth(pElement, pDevAdvanceWidth);
}

FS_PUBLIC void  fsg_GetDevAdvanceHeight(
	fsg_WorkSpaceAddr * pWorkSpaceAddr,
	point *             pDevAdvanceHeight)
{
	fnt_ElementType *   pElement;

	pElement = pWorkSpaceAddr->pGlyphElement;

	scl_CalcDevAdvanceHeight(pElement, pDevAdvanceHeight);
}

FS_PUBLIC void  fsg_GetScaledCVT(
	char *                      pPrivateFontSpace,
	fsg_PrivateSpaceOffsets *   PrivateSpaceOffsets,
	F26Dot6 **                  ppScaledCVT)
{
	*ppScaledCVT = (F26Dot6 *)(pPrivateFontSpace + PrivateSpaceOffsets->offset_controlValues);
}

FS_PUBLIC void  fsg_45DegreePhaseShift(
	fsg_WorkSpaceAddr * pWorkSpaceAddr)
{
	fnt_ElementType *   pElement;

	pElement = pWorkSpaceAddr->pGlyphElement;

	scl_45DegreePhaseShift(pElement);
}

FS_PUBLIC void  fsg_UpdateAdvanceWidth (
	fsg_TransformRec *  TransformInfo,
	void *              pvGlobalGS,
	uint16              usNonScaledAW,
	vectorType *        AdvanceWidth)
{
	AdvanceWidth->y = 0;
	scl_ScaleAdvanceWidth(
		pvGlobalGS,
		AdvanceWidth,
		usNonScaledAW,
		TransformInfo->bPositiveSquare,
		TransformInfo->usEmResolution,
		&TransformInfo->currentTMatrix);
}

FS_PUBLIC void  fsg_UpdateAdvanceHeight (
	fsg_TransformRec *  TransformInfo,
	void *              pvGlobalGS,
	uint16              usNonScaledAH,
	vectorType *        AdvanceHeight)
{
	AdvanceHeight->x = 0;
	scl_ScaleAdvanceHeight(
		pvGlobalGS,
		AdvanceHeight,
		usNonScaledAH,
		TransformInfo->bPositiveSquare,
		TransformInfo->usEmResolution,
		&TransformInfo->currentTMatrix);
}


FS_PUBLIC void  fsg_ScaleVerticalMetrics (
    fsg_TransformRec *  TransformInfo,
    void *              pvGlobalGS,
	uint16              usNonScaledAH,
    int16               sNonScaledTSB,
	vectorType *        pvecAdvanceHeight,
	vectorType *        pvecTopSideBearing )
{
	pvecAdvanceHeight->x = 0;           /* start with x values at zero */
	pvecTopSideBearing->x = 0;          /* since 'vmtx' refers to y values */

    scl_ScaleVerticalMetrics (
    	pvGlobalGS,
    	usNonScaledAH,
    	sNonScaledTSB,
		TransformInfo->bPositiveSquare,
		TransformInfo->usEmResolution,
		&TransformInfo->currentTMatrix,
    	pvecAdvanceHeight,
    	pvecTopSideBearing);
}


FS_PUBLIC void  fsg_CalcLSBsAndAdvanceWidths(
	fsg_WorkSpaceAddr *     pWorkSpaceAddr,
	F26Dot6                 fxXMin,
	F26Dot6                 fxYMax,
	point *                 devAdvanceWidth,
	point *                 devLeftSideBearing,
	point *                 LeftSideBearing,
	point *                 devLeftSideBearingLine,
	point *                 LeftSideBearingLine)
{
	fnt_ElementType *   pElement;

	pElement = pWorkSpaceAddr->pGlyphElement;

	scl_CalcLSBsAndAdvanceWidths(
		pElement,
		fxXMin,
		fxYMax,
		devAdvanceWidth,
		devLeftSideBearing,
		LeftSideBearing,
		devLeftSideBearingLine,
		LeftSideBearingLine);
}

FS_PUBLIC void  fsg_CalcTSBsAndAdvanceHeights(
	fsg_WorkSpaceAddr *     pWorkSpaceAddr,
	F26Dot6                 fxXMin,
	F26Dot6                 fxYMax,
	point *                 devAdvanceHeight,
	point *                 devTopSideBearing,
	point *                 TopSideBearing,
	point *                 devTopSideBearingLine,
	point *                 TopSideBearingLine)
{
	fnt_ElementType *   pElement;

	pElement = pWorkSpaceAddr->pGlyphElement;

	scl_CalcTSBsAndAdvanceHeights(
		pElement,
		fxXMin,
		fxYMax,
		devAdvanceHeight,
		devTopSideBearing,
		TopSideBearing,
		devTopSideBearingLine,
		TopSideBearingLine);
}

FS_PUBLIC boolean   fsg_IsTransformStretched(
	fsg_TransformRec *  TransformInfo)
{
	return (boolean)(( TransformInfo->ulImageState & IMAGESTATE_STRETCHED ) == IMAGESTATE_STRETCHED);
}

FS_PUBLIC boolean   fsg_IsTransformRotated(
	fsg_TransformRec *  TransformInfo)
{
	return (boolean)(( TransformInfo->ulImageState & IMAGESTATE_ROTATED ) == IMAGESTATE_ROTATED);
}

/*  Control Routines    */

FS_PUBLIC ErrorCode fsg_InitInterpreterTrans (
	fsg_TransformRec *  TransformInfo,
	void *              pvGlobalGS,
	Fixed               fxPointSize,
	int16               sXResolution,
	int16               sYResolution,
	boolean           bHintAtEmSquare,
	uint16            usEmboldWeightx,     /* scaling factor in x between 0 and 40 (20 means 2% fo the height) */
	uint16              usEmboldWeighty,     /* scaling factor in y between 0 and 40 (20 means 2% fo the height) */
	int16               sWinDescender,
	int32               lDescDev,               /* descender in device metric, used for clipping */
	int16 *				psBoldSimulHorShift,   /* shift for emboldening simulation, horizontally */
	int16 *				psBoldSimulVertShift   /* shift for emboldening simulation, vertically */
	)
{
	ErrorCode       error;
	uint32          ulPixelsPerEm;
	transMatrix *   trans;

	trans = &TransformInfo->currentTMatrix;

	error = scl_InitializeScaling(
		pvGlobalGS,
		TransformInfo->bIntegerScaling,
		&TransformInfo->currentTMatrix,
		TransformInfo->usEmResolution,
		fxPointSize,
		sXResolution,
		sYResolution,
		usEmboldWeightx,       /* scaling factor in x between 0 and 40 (20 means 2% fo the height) */
		usEmboldWeighty,      /* scaling factor in y between 0 and 40 (20 means 2% fo the height) */
		sWinDescender,
		lDescDev,
		psBoldSimulHorShift,   /* shift for emboldening simulation, horizontally */
		psBoldSimulVertShift,   /* shift for emboldening simulation, vertically */
		bHintAtEmSquare,
		&ulPixelsPerEm);

	if(error)
	{
		return error;
	}

	TransformInfo->bPhaseShift = false;

	if ( ulPixelsPerEm > IMAGESTATE_MAX_PPEM_SIZE )
	{
		TransformInfo->ulImageState = (uint32)IMAGESTATE_MAX_PPEM_SIZE;
	}
	else
	{
		TransformInfo->ulImageState = ulPixelsPerEm;
	}

	TransformInfo->bPositiveSquare = mth_PositiveSquare( trans );

	if ( !(mth_PositiveRectangle( trans )))
	{
		TransformInfo->ulImageState |= IMAGESTATE_NON_POS_RECT;
	}

	if ( !(TransformInfo->bPositiveSquare) )
	{
		if( mth_GeneralRotation (trans))
		{
			TransformInfo->ulImageState |=  IMAGESTATE_ROTATED;
		}

		TransformInfo->ulImageState |= IMAGESTATE_STRETCHED;

		TransformInfo->bPhaseShift = mth_IsMatrixStretched(trans); /*<8>*/
	}

	TransformInfo->bEmboldSimulation = ((usEmboldWeightx != 0) || (usEmboldWeighty != 0)); 

	return NO_ERR;
}

FS_PUBLIC void  fsg_SetHintFlags(
	void *              pvGlobalGS,
	boolean				bHintForGray
#ifdef FSCFG_SUBPIXEL
	,uint16				flHintForSubPixel
#endif // FSCFG_SUBPIXEL
    )
{
	scl_SetHintFlags(
		pvGlobalGS,
		bHintForGray
#ifdef FSCFG_SUBPIXEL
	    ,flHintForSubPixel
#endif // FSCFG_SUBPIXEL
        );
}
/*
 *  All this guy does is record FDEFs and IDEFs, anything else is ILLEGAL
 */
FS_PUBLIC ErrorCode fsg_RunFontProgram(
	void *                  pvGlobalGS,               /* GlobalGS     */
	fsg_WorkSpaceAddr *     pWorkSpaceAddr,
	void *                  pvTwilightElement,
	FntTraceFunc           traceFunc)
{
	return itrp_ExecuteFontPgm (
		(fnt_ElementType *)pvTwilightElement,
		pWorkSpaceAddr->pGlyphElement,
		pvGlobalGS,
		traceFunc);
}

/*
 * fsg_RunPreProgram
 *
 * Runs the pre-program and scales the control value table
 *
 */
FS_PUBLIC ErrorCode fsg_RunPreProgram (
	sfac_ClientRec *    ClientInfo,
	LocalMaxProfile *   pMaxProfile,     /* Max Profile Table    */
	fsg_TransformRec *  TransformInfo,
	void *              pvGlobalGS,
	fsg_WorkSpaceAddr * pWorkSpaceAddr,
	void *              pvTwilightElement,
	FntTraceFunc        traceFunc)
{
	ErrorCode           result;
	F26Dot6 *           pfxCVT;
	fnt_ElementType *   pTwilightElement;

	pTwilightElement = (fnt_ElementType *)pvTwilightElement;

	result = itrp_SetDefaults (pvGlobalGS, TransformInfo->fxPixelDiameter);

	if (result != NO_ERR)
	{
		return result;
	}

	scl_GetCVTPtr(pvGlobalGS, &pfxCVT);

	result = sfac_CopyCVT(ClientInfo, pfxCVT);

	if (result != NO_ERR)
	{
		return result;
	}

	scl_ScaleCVT (pvGlobalGS, pfxCVT);

	scl_InitializeTwilightContours(
		pTwilightElement,
		(int16)pMaxProfile->maxTwilightPoints,
		MAX_TWILIGHT_CONTOURS);

	scl_ZeroOutlineData(
		pTwilightElement,
		pMaxProfile->maxTwilightPoints,
		MAX_TWILIGHT_CONTOURS);

	result = itrp_ExecutePrePgm (
		pTwilightElement,
		pWorkSpaceAddr->pGlyphElement,
		pvGlobalGS,
		traceFunc);

	return result;
}

/*
 *      fsg_GridFit
 */
FS_PUBLIC ErrorCode fsg_GridFit (
	sfac_ClientRec *    ClientInfo,     /* sfnt Client information      */
	LocalMaxProfile *   pMaxProfile,    /* Max Profile Table            */
	fsg_TransformRec *  TransformInfo,  /* Transformation information   */
	void *              pvGlobalGS,     /* GlobalGS                     */
	fsg_WorkSpaceAddr * pWorkSpaceAddr,
	void *              pvTwilightElement,
	FntTraceFunc        traceFunc,
	boolean             bUseHints,
	uint16 *            pusScanType,
	boolean *           pbGlyphHasOutline,
	uint16 *            pusNonScaledAW,
	boolean            bBitmapEmboldening
#ifdef FSCFG_SUBPIXEL
	,boolean			bSubPixel
#endif // FSCFG_SUBPIXEL
	)
{
	ErrorCode           result;
	fnt_ElementType *   pTwilightElement;
	fnt_GlobalGraphicStateType *globalGS;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	pTwilightElement = (fnt_ElementType *)pvTwilightElement;

	scl_InitializeTwilightContours(
		pTwilightElement,
		(int16)pMaxProfile->maxTwilightPoints,
		MAX_TWILIGHT_CONTOURS);

	result = fsg_CreateGlyphData (
		ClientInfo,
		pMaxProfile,
		TransformInfo,
		pvGlobalGS,
		pWorkSpaceAddr,
		pTwilightElement,
		traceFunc,
		bUseHints,
		pusScanType,
		pbGlyphHasOutline,
		pusNonScaledAW);

	if(result == NO_ERR)
	{
		if (TransformInfo->bEmboldSimulation)
		{
			fsg_Embold( pWorkSpaceAddr, pvGlobalGS, bUseHints, bBitmapEmboldening
#ifdef FSCFG_SUBPIXEL
	                ,bSubPixel
#endif // FSCFG_SUBPIXEL
            );
			if(*pusNonScaledAW)
				*pusNonScaledAW +=  (TransformInfo->usEmResolution * 2 - 1) / 100; /* adjust pusNonScaledAW by 2% of Em height */
		}

		if ((TransformInfo->ulImageState & (IMAGESTATE_NON_POS_RECT)) || globalGS->bHintAtEmSquare)
		{
			scl_PostTransformGlyph (
				pvGlobalGS,
				pWorkSpaceAddr->pGlyphElement,
				&TransformInfo->currentTMatrix);
		}

		/* apply the translation part of the transformation matrix */
		scl_ApplyTranslation (
			pWorkSpaceAddr->pGlyphElement,
			&TransformInfo->currentTMatrix,
			bUseHints,
			globalGS->bHintAtEmSquare
#ifdef FSCFG_SUBPIXEL
	        ,bSubPixel
#endif // FSCFG_SUBPIXEL
            );
	}
	return result;
}

FS_PRIVATE ErrorCode    fsg_CreateGlyphData(
	sfac_ClientRec *    ClientInfo,         /* sfnt Client information           */
	LocalMaxProfile *   pMaxProfile,        /* Max Profile Table                     */
	fsg_TransformRec *  TransformInfo,      /* Transformation information        */
	void *              pvGlobalGS,         /* GlobalGS                              */
	fsg_WorkSpaceAddr * pWorkSpaceAddr,     /* WorkSpace Address                     */
	fnt_ElementType *   pTwilightElement,   /* Twilight zone element */
	FntTraceFunc        traceFunc,          /* Trace function for interpreter    */
	boolean             bUseHints,          /* True if glyph is gridfitted       */
	uint16 *            pusScanType,        /* ScanType value                        */
	boolean *           pbGlyphHasOutline,  /* Outline for glyph                 */
	uint16 *            pusNonScaledAW)     /* Return NonScaled Advance Width    */
{
	GlyphData * pGlyphData;
	GlyphData * pNextGlyphData;
	boolean      bHasOutline;
	uint32       ulGlyphDataCount;
	ErrorCode   ReturnCode;
    uint32      CompositePoints = 0;
    uint32      CompositeContours = 0;

	*pbGlyphHasOutline = FALSE;
	bHasOutline = FALSE;

	ulGlyphDataCount = MAX_NESTED_GLYPHS(pMaxProfile);

	fsg_InitializeGlyphDataMemory(ulGlyphDataCount, pWorkSpaceAddr);
	ReturnCode = fsg_AllocateGlyphDataMemory(ulGlyphDataCount, pWorkSpaceAddr, &pGlyphData); /* Allocates GlyphData for topmost   */
	if(ReturnCode != NO_ERR)
	{
		return ReturnCode;
	}
												 /* parent  */
	fsg_InitializeGlyphData(pGlyphData, pWorkSpaceAddr,
		ClientInfo->usGlyphIndex, COMPOSITE_ROOT);

	while(pGlyphData != NULL)
	{
		CHECK_GLYPHDATA( pGlyphData );

		ReturnCode = fsg_ExecuteGlyph(
			ClientInfo,
			pMaxProfile,
			TransformInfo,
			ulGlyphDataCount,
			pvGlobalGS,
			pGlyphData,
			pWorkSpaceAddr,
			pTwilightElement,
			traceFunc,
			bUseHints,
			&bHasOutline,
            &CompositePoints,
            &CompositeContours);
		if(ReturnCode)
		{
			return ReturnCode;
		}
		*pbGlyphHasOutline |= bHasOutline;
		*pusScanType = pGlyphData->usScanType;
		fsg_ChooseNextGlyph(pWorkSpaceAddr, pGlyphData, &pNextGlyphData);
		*pusNonScaledAW = pGlyphData->usNonScaledAW;
		pGlyphData = pNextGlyphData;
	}

	return NO_ERR;
}

FS_PRIVATE ErrorCode    fsg_ExecuteGlyph(
	sfac_ClientRec *    ClientInfo,         /* sfnt Client information           */
	LocalMaxProfile *   pMaxProfile,        /* Max Profile Table                     */
	fsg_TransformRec *  TransformInfo,      /* Transformation information         */
	uint32              ulGlyphDataCount,   /* Max Number of nested glyphs */
	void *              pvGlobalGS,         /* GlobalGS                              */
	GlyphData *         pGlyphData,         /* GlyphData pointer                     */
	fsg_WorkSpaceAddr * pWorkSpaceAddr,     /* WorkSpace Address                      */
	fnt_ElementType *   pTwilightElement,   /* Twilight zone element */
	FntTraceFunc        traceFunc,          /* Trace function for interpreter    */
	boolean             bUseHints,          /* True if glyph is gridfitted       */
	boolean *           pbHasOutline,       /* True if glyph has outline         */
    uint32*                pCompositePoints,/* total number of point for composites, to check for overflow */
    uint32*                pCompositeContours)  /* total number of contours for composites, to check for overflow */
{
	ErrorCode       ReturnCode;
	boolean         bCompositeGlyph;
	boolean         bLastComponent;
	boolean         bWeHaveInstructions;
	boolean         bWeHaveCompositeInstructions;
	boolean         bScanInfoChanged;
	boolean 		bWeHaveAScale;
	uint16          usScanType;
	uint16          usScanControl;
	GlyphData *     pChildGlyphData;
	uint16          usComponentElementCount;
	uint16          contour;

	*pbHasOutline = FALSE;

	if (pGlyphData->GlyphType == glyphUndefined)
	{
		if(pGlyphData->pParent != NULL)
		{
			scl_IncrementChildElement(pGlyphData->pGlyphElement, pGlyphData->pParent->pGlyphElement);
		} else {
			pGlyphData->currentTMatrix = TransformInfo->currentTMatrix;
		}

		ReturnCode = sfac_ReadGlyphHeader(ClientInfo, pGlyphData->usGlyphIndex,
			&pGlyphData->hGlyph, &bCompositeGlyph, pbHasOutline,
			&pGlyphData->pGlyphElement->nc, &pGlyphData->bbox);

		if(ReturnCode != NO_ERR)
		{
			return ReturnCode;
		}

		/* Get advance width, advance height, left side bearing and top side bearing information  */

		ReturnCode = sfac_ReadGlyphMetrics(
			ClientInfo, pGlyphData->usGlyphIndex,
			&pGlyphData->usNonScaledAW, &pGlyphData->usNonScaledAH, 
			&pGlyphData->sNonScaledLSB, &pGlyphData->sNonScaledTSB, &pGlyphData->sNonScaledTopOriginX);

		if(ReturnCode != NO_ERR)
		{
			return ReturnCode;
		}

		if (bCompositeGlyph)
		{
			pGlyphData->GlyphType = glyphIncompleteComposite;
		}
		else
		{
			pGlyphData->GlyphType = glyphSimple;
		}
	}

	if (pGlyphData->GlyphType == glyphSimple)
	{
		ReturnCode = sfac_ReadOutlineData(
			pGlyphData->pGlyphElement->onCurve,
			pGlyphData->pGlyphElement->ooy, pGlyphData->pGlyphElement->oox,
			&pGlyphData->hGlyph, pMaxProfile, *pbHasOutline, pGlyphData->pGlyphElement->nc,
			pGlyphData->pGlyphElement->sp, pGlyphData->pGlyphElement->ep,
			&pGlyphData->usSizeOfInstructions, &pGlyphData->pbyInstructions,
            pCompositePoints, pCompositeContours);

		if(ReturnCode != NO_ERR)
		{
			return ReturnCode;
		}


        fsg_CheckOutlineOrientation (pGlyphData->pGlyphElement);

        ReturnCode = fsg_SimpleInnerGridFit(
			pvGlobalGS,
			pTwilightElement,
			pGlyphData->pGlyphElement,
			bUseHints,
			traceFunc,
			TransformInfo->usEmResolution,
			pGlyphData->usNonScaledAW,
			pGlyphData->usNonScaledAH,
			pGlyphData->sNonScaledLSB,
			pGlyphData->sNonScaledTSB,
			pGlyphData->sNonScaledTopOriginX,
			pGlyphData->bSameTransformAsMaster, /* current transf. same as master transf.   */
			pGlyphData->currentTMatrix, /* current transf. : user + composite transf. */
			&pGlyphData->bbox,
			pGlyphData->usSizeOfInstructions,
			pGlyphData->pbyInstructions,
			&usScanType,
			&usScanControl,
			&bScanInfoChanged);

		if(ReturnCode != NO_ERR)
		{
			return ReturnCode;
		}

		if( ! fsg_DoScanControl(usScanControl, TransformInfo->ulImageState))
		{
			pGlyphData->usScanType = SK_NODROPOUT;
		}
		else
		{
			pGlyphData->usScanType = usScanType;
		}

		// here we update the contour orientation bit if necessary, to reflect the final orientation of the contours in the composite
		if (FixMul(pGlyphData->mulT.transform[0][0],pGlyphData->mulT.transform[1][1]) - FixMul(pGlyphData->mulT.transform[0][1],pGlyphData->mulT.transform[1][0]) < 0) {
			for (contour = 0; contour < pGlyphData->pGlyphElement->nc; contour++) {
				pGlyphData->pGlyphElement->fc[contour] ^= OUTLINE_MISORIENTED;
			}
		}

		if (pGlyphData->pParent != NULL)
		{
			fsg_MergeGlyphData(pvGlobalGS, pGlyphData, TransformInfo->usEmResolution);
		}

		ReturnCode = sfac_ReleaseGlyph(ClientInfo, &pGlyphData->hGlyph);

		if(ReturnCode != NO_ERR)
		{
			return ReturnCode;
		}

		pGlyphData->pbyInstructions = 0;
		pGlyphData->usSizeOfInstructions = 0;
	}
	else if (pGlyphData->GlyphType == glyphComposite)
	{
		ReturnCode = fsg_CompositeInnerGridFit(
			pvGlobalGS,
			pTwilightElement,
			pGlyphData->pGlyphElement,
			bUseHints,
			traceFunc,
			TransformInfo->usEmResolution,
			pGlyphData->usNonScaledAW,
			pGlyphData->usNonScaledAH,
			pGlyphData->sNonScaledLSB,
			pGlyphData->sNonScaledTSB,
			pGlyphData->sNonScaledTopOriginX,
			pGlyphData->bSameTransformAsMaster, /* current transf. same as master transf.   */
			pGlyphData->currentTMatrix, /* current transf. : user + composite transf. */
			&pGlyphData->bbox,
			pGlyphData->usSizeOfInstructions,
			pGlyphData->pbyInstructions,
			&usScanType,
			&usScanControl,
			&bScanInfoChanged);

		if(ReturnCode != NO_ERR)
		{
			return ReturnCode;
		}

		if (pGlyphData->bUseChildMetrics)
		{
			scl_SetSideBearingPoints(
				pGlyphData->pGlyphElement,
				&pGlyphData->ptDevLSB,
				&pGlyphData->ptDevRSB);
		}

		/* If composite has set SCANCTRL, use that value, otherwise merged children */

		if(bScanInfoChanged)
		{
			if( ! fsg_DoScanControl(usScanControl, TransformInfo->ulImageState))
			{
				pGlyphData->usScanType = SK_NODROPOUT;
			}
			else
			{
				pGlyphData->usScanType = usScanType;
			}
		}

		if (pGlyphData->pParent != NULL)
		{
			fsg_MergeGlyphData(pvGlobalGS, pGlyphData, TransformInfo->usEmResolution);
		}

		ReturnCode = sfac_ReleaseGlyph(ClientInfo, &pGlyphData->hGlyph);

		if(ReturnCode != NO_ERR)
		{
			return ReturnCode;
		}

		pGlyphData->pbyInstructions = 0;
		pGlyphData->usSizeOfInstructions = 0;
	}
	else if (pGlyphData->GlyphType == glyphIncompleteComposite)
	{
		bLastComponent = FALSE;
		bWeHaveInstructions = FALSE;
		bWeHaveCompositeInstructions = FALSE;

		pGlyphData->GlyphType = glyphComposite;

		usComponentElementCount = 0;

		do
		{
			if(pGlyphData->usDepth + 1UL > MAX_COMPONENT_DEPTH(pMaxProfile))
			{
				return BAD_MAXP_DATA;
			}

			usComponentElementCount++;

			if(usComponentElementCount > MAX_COMPONENT_ELEMENTS(pMaxProfile))
			{
				return BAD_MAXP_DATA;
			}

			ReturnCode = fsg_AllocateGlyphDataMemory(ulGlyphDataCount, pWorkSpaceAddr, &pChildGlyphData);
			if(ReturnCode != NO_ERR)
			{
				return ReturnCode;
			}

			fsg_InitializeGlyphData(
				pChildGlyphData,
				pWorkSpaceAddr,
				NULL_GLYPH,
				(uint16)(pGlyphData->usDepth + 1U) );

			fsg_LinkChild(pGlyphData, pChildGlyphData);

			ReturnCode = sfac_ReadComponentData(
				&pGlyphData->hGlyph,
				&pChildGlyphData->MultiplexingIndicator,
				&pChildGlyphData->bRoundXYToGrid,
				&pChildGlyphData->bUseMyMetrics,
				&pChildGlyphData->bScaleCompositeOffset,
				&bWeHaveInstructions,
				&pChildGlyphData->usGlyphIndex,
				&pChildGlyphData->sXOffset,
				&pChildGlyphData->sYOffset,
				&pChildGlyphData->usAnchorPoint1,
				&pChildGlyphData->usAnchorPoint2,
				&pChildGlyphData->mulT,
				&bWeHaveAScale,
				&bLastComponent);

            if (pChildGlyphData->usGlyphIndex >= pMaxProfile->numGlyphs)
            {
                return COMPOSITE_INVALID_GLYPH_INDEX;
            }

			if (bWeHaveAScale)
			{
				mth_MxConcat2x2( &pChildGlyphData->mulT, &pChildGlyphData->currentTMatrix );
				if (!mth_UnitarySquare(&pChildGlyphData->mulT))
				{
					pChildGlyphData->bSameTransformAsMaster	= FALSE; /* the component is scaled/rotated */
				}

			}

			if(ReturnCode != NO_ERR)
			{
				return ReturnCode;
			}

			bWeHaveCompositeInstructions |= bWeHaveInstructions;
		}
		while (!bLastComponent);

		if(bWeHaveCompositeInstructions)
		{
			ReturnCode = sfac_ReadCompositeInstructions(
				&pGlyphData->hGlyph,
				&pGlyphData->pbyInstructions,
				&pGlyphData->usSizeOfInstructions);

			if(ReturnCode != NO_ERR)
			{
				return ReturnCode;
			}
		}

	}
	return NO_ERR;
}


/*
 *      fsg_SimpleInnerGridFit
 */
FS_PRIVATE ErrorCode    fsg_SimpleInnerGridFit (
	void *              pvGlobalGS,
	fnt_ElementType *   pTwilightElement,
	fnt_ElementType *   pGlyphElement,
	boolean             bUseHints,
	FntTraceFunc        traceFunc,
	uint16              usEmResolution,
	uint16              usNonScaledAW,
	uint16              usNonScaledAH,
	int16               sNonScaledLSB,
	int16               sNonScaledTSB,
	int16               sNonScaledTopOriginX,
	boolean				bSameTransformAsMaster, /* local transf. same as master transf.   */
	transMatrix			CurrentTMatrix,                  /* Current Transformation   */
	BBOX *              bbox,
	uint16              usSizeOfInstructions,
	uint8 *             instructionPtr,
	uint16 *            pusScanType,
	uint16 *            pusScanControl,
	boolean *           pbChangeScanControl)
{
	ErrorCode           result;
/*
	On entry to fsg_SimpleInnerGrid fit the element structure should
	contain only valid original points (oox, ooy). The original points
	will be scaled into the old points (ox, oy) and those will be
	copied into the current points (x, y).
*/
	itrp_SetCompositeFlag(pvGlobalGS, FALSE);

	itrp_QueryScanInfo(pvGlobalGS, pusScanType, pusScanControl);
	*pbChangeScanControl = FALSE;

	scl_CalcOrigPhantomPoints(pGlyphElement, bbox, sNonScaledLSB, sNonScaledTSB, usNonScaledAW, usNonScaledAH, sNonScaledTopOriginX);

	if (itrp_bApplyHints(pvGlobalGS) && bUseHints)
	{
		itrp_SetSameTransformFlag(pvGlobalGS, bSameTransformAsMaster);

		if (!bSameTransformAsMaster)
		{
			scl_InitializeChildScaling(
				pvGlobalGS,
				CurrentTMatrix,
				usEmResolution);
		}

		/* hint and same transformation as master glyph */
		scl_ScaleOldCharPoints (pGlyphElement, pvGlobalGS);
		scl_ScaleOldPhantomPoints (pGlyphElement, pvGlobalGS);

		scl_AdjustOldCharSideBearing(pGlyphElement
#ifdef FSCFG_SUBPIXEL
			, pvGlobalGS
#endif
			);
		scl_AdjustOldPhantomSideBearing(pGlyphElement
#ifdef FSCFG_SUBPIXEL
			, pvGlobalGS
#endif
			);

		scl_CopyCurrentCharPoints(pGlyphElement);
		scl_CopyCurrentPhantomPoints(pGlyphElement);

		scl_RoundCurrentSideBearingPnt(pGlyphElement, pvGlobalGS, usEmResolution);

		if (usSizeOfInstructions > 0)
		{
			scl_ZeroOutlineFlags(pGlyphElement);

			result = itrp_ExecuteGlyphPgm (
				pTwilightElement,
				pGlyphElement,
				instructionPtr,
				instructionPtr + usSizeOfInstructions,
				pvGlobalGS,
				traceFunc,
				pusScanType,
				pusScanControl,
				pbChangeScanControl);

			if(result != NO_ERR)
			{
				return result;
			}

		}

		if (!bSameTransformAsMaster)
		{
			/* scale back to fixed FUnits */
			scl_ScaleBackCurrentCharPoints (pGlyphElement, pvGlobalGS);
			scl_ScaleBackCurrentPhantomPoints (pGlyphElement, pvGlobalGS);
		}
	}
	else 
		/* no hints */
	{
		if (bSameTransformAsMaster)
		{
			/* no hint and same transformation as master glyph */
			/* as ox/oy are not used in this case, we shouldn't need to first
			   scale the original coordinate oox/ooy into ox/oy before copying
			   them into the current coordinate x/y, the code is left as it
			   for historic reason */
			scl_ScaleOldCharPoints (pGlyphElement, pvGlobalGS);
			scl_ScaleOldPhantomPoints (pGlyphElement, pvGlobalGS);

			scl_CopyCurrentCharPoints(pGlyphElement);
			scl_CopyCurrentPhantomPoints(pGlyphElement);
		}
		else
		{
			/* no hint and different transformation as master glyph */
			/* we shift directly the original coordinates oox/ooy into the
			   current coordinates x/y in FixedFUnits,
			   as ox/oy are not used in this case, we don't need to do
			   a temporary copy into ox/oy */
			scl_OriginalCharPointsToCurrentFixedFUnits (pGlyphElement);
			scl_OriginalPhantomPointsToCurrentFixedFUnits (pGlyphElement);
		}
	}

	return NO_ERR;
}


/*
 *      fsg_CompositeInnerGridFit
 */
FS_PRIVATE ErrorCode    fsg_CompositeInnerGridFit (
	void *              pvGlobalGS,
	fnt_ElementType *   pTwilightElement,
	fnt_ElementType *   pGlyphElement,
	boolean             bUseHints,
	FntTraceFunc        traceFunc,
	uint16              usEmResolution,
	uint16              usNonScaledAW,
	uint16              usNonScaledAH,
	int16               sNonScaledLSB,
	int16               sNonScaledTSB,
	int16               sNonScaledTopOriginX,
	boolean				bSameTransformAsMaster, /* local transf. same as master transf.   */
	transMatrix		    CurrentTMatrix,               /* Current Transformation   */
	BBOX *              bbox,
	uint16              usSizeOfInstructions,
	uint8 *             instructionPtr,
	uint16 *            pusScanType,
	uint16 *            pusScanControl,
	boolean *           pbChangeScanControl)
{
	ErrorCode             result;
/*
	On entry to fsg_CompositeInnerGridFit, the current points (x, y)
	are the only valid points in the element. We copy the current points
	onto the old points (ox, oy)
*/
	itrp_SetCompositeFlag(pvGlobalGS, TRUE);

	itrp_QueryScanInfo(pvGlobalGS, pusScanType, pusScanControl);
	*pbChangeScanControl = FALSE;

	/* Note: The original composite character points are invalid at this point. */
	/*       The interpreter handles this case correctly for composites.        */

	scl_CalcOrigPhantomPoints(pGlyphElement, bbox, sNonScaledLSB, sNonScaledTSB, usNonScaledAW, usNonScaledAH, sNonScaledTopOriginX);
																  
	scl_CopyOldCharPoints(pGlyphElement);


	if (itrp_bApplyHints(pvGlobalGS) && bUseHints)
	{
		itrp_SetSameTransformFlag(pvGlobalGS, bSameTransformAsMaster);

		if (!bSameTransformAsMaster)
		{
			scl_InitializeChildScaling(
				pvGlobalGS,
				CurrentTMatrix,
				usEmResolution);
			scl_ScaleFixedCurrentCharPoints (pGlyphElement, pvGlobalGS);
		}

		scl_ScaleOldPhantomPoints (pGlyphElement, pvGlobalGS);

		scl_AdjustOldSideBearingPoints(pGlyphElement
#ifdef FSCFG_SUBPIXEL
			, pvGlobalGS
#endif
			);

		scl_CopyCurrentPhantomPoints(pGlyphElement);

		scl_RoundCurrentSideBearingPnt(pGlyphElement, pvGlobalGS, usEmResolution);

		if (usSizeOfInstructions > 0)
		{
			scl_ZeroOutlineFlags(pGlyphElement);

			result = itrp_ExecuteGlyphPgm (
				pTwilightElement,
				pGlyphElement,
				instructionPtr,
				instructionPtr + usSizeOfInstructions,
				pvGlobalGS,
				traceFunc,
				pusScanType,
				pusScanControl,
				pbChangeScanControl);

			if(result != NO_ERR)
			{
				return result;
			}
		}

		if (!bSameTransformAsMaster)
		{
			/* scale back to fixed FUnits */
			scl_ScaleBackCurrentCharPoints (pGlyphElement, pvGlobalGS);
			scl_ScaleBackCurrentPhantomPoints (pGlyphElement, pvGlobalGS);
		}

	}
	else 
	{
		if (bSameTransformAsMaster)
		{
			/* no hint and same transformation as master glyph */
			/* as ox/oy are not used in this case, we shouldn't need to first
			   scale the original coordinate oox/ooy into ox/oy before copying
			   them into the current coordinate x/y, the code is left as it
			   for historic reason */
			scl_ScaleOldPhantomPoints (pGlyphElement, pvGlobalGS);

			scl_CopyCurrentPhantomPoints(pGlyphElement);

		}
		else
		{
			/* no hint and different transformation as master glyph */
			/* we shift directly the original coordinates oox/ooy into the
			   current coordinates x/y in FixedFUnits,
			   as ox/oy are not used in this case, we don't need to do
			   a temporary copy into ox/oy */
			scl_OriginalPhantomPointsToCurrentFixedFUnits (pGlyphElement);

		}
	}

	return NO_ERR;
}

FS_PRIVATE void fsg_ChooseNextGlyph(
	fsg_WorkSpaceAddr * pWorkSpaceAddr, /* WorkSpace Address        */
	GlyphData *         pGlyphData,     /* GlyphData pointer        */
	GlyphData **        ppNextGlyphData)/* Next GlyphData pointer   */
{
	if (pGlyphData->pChild != NULL)
	{
		*ppNextGlyphData = pGlyphData->pChild;
		CHECK_GLYPHDATA( *ppNextGlyphData );
		pGlyphData->pChild = NULL;
	}
	else
	{
		*ppNextGlyphData = pGlyphData->pSibling;
		fsg_DeallocateGlyphDataMemory(pWorkSpaceAddr, pGlyphData);
	}
}

#ifdef FSCFG_SUBPIXEL
long fsg_AnalyzeCurrentTransformationMatrix(transMatrix *CTM);
long fsg_AnalyzeCurrentTransformationMatrix(transMatrix *CTM) {
	if (CTM->transform[0][1] == 0 && CTM->transform[1][0] == 0) return 0; // Identity, 180 rotation, mirroring in x or y
	if (CTM->transform[0][0] == 0 && CTM->transform[1][1] == 0) return 1; // 90 rotation, 270 rotation, or any combination of these rotation with a mirroring in x or y
	return 2; // assume arbitrary rotation
} // fsg_AnalyzeCurrentTransformationMatrix
#endif

FS_PRIVATE void fsg_MergeGlyphData(
	void *          pvGlobalGS,             /* GlobalGS            */
	GlyphData *     pChildGlyphData,       /* GlyphData pointer     */
	uint16          usEmResolution)
{
	fnt_ElementType * pChildElement;
	fnt_ElementType * pParentElement;
	F26Dot6         fxXOffset, fxYOffset;
	GlyphData *     pParentGlyphData; /* Parent GlyphData pointer   */
#ifdef FSCFG_SUBPIXEL
	RotationParity	rotationParity;
#endif

	CHECK_GLYPHDATA(pChildGlyphData);
	pParentGlyphData = pChildGlyphData->pParent;
	CHECK_GLYPHDATA(pParentGlyphData);

	pChildElement = pChildGlyphData->pGlyphElement;
	pParentElement = pParentGlyphData->pGlyphElement;

	fsg_TransformChild(pChildGlyphData);

	if (!pChildGlyphData->bSameTransformAsMaster && pChildGlyphData->pParent->bSameTransformAsMaster)
	{
		/* coordinates need to be converted from fixed FUnits to user space */
		/* scaling the cordinate of the child glyph from fixed FUnits to user space,
		   scaling from original coordinate x/y to original coordinate x/y 
		   this is done to have the child and parent glyph at the same coordinate space */

		/* use the master transform */
		itrp_SetSameTransformFlag(pvGlobalGS, TRUE);

		scl_ScaleFixedCurrentCharPoints(pChildElement, pvGlobalGS);
		scl_ScaleFixedCurrentPhantomPoints(pChildElement, pvGlobalGS);

		pChildGlyphData->bSameTransformAsMaster = TRUE;
	}
	
#ifdef FSCFG_SUBPIXEL
	rotationParity = fsg_AnalyzeCurrentTransformationMatrix(&pParentGlyphData->currentTMatrix);
#endif

	if (pChildGlyphData->MultiplexingIndicator == OffsetPoints)
	{
		if (!pChildGlyphData->pParent->bSameTransformAsMaster)
		{
			/* we have both the parent and the child that are not at the same transformation as the master glyph
			   we need to use the scaling of the parent as a child scaling to scale the offset */
			scl_InitializeChildScaling(
				pvGlobalGS,
				pChildGlyphData->pParent->currentTMatrix,
				usEmResolution);
		}

		scl_CalcComponentOffset(
			pvGlobalGS,
			pChildGlyphData->sXOffset,
			pChildGlyphData->sYOffset,
			pChildGlyphData->bRoundXYToGrid,
			pChildGlyphData->bSameTransformAsMaster,
			pChildGlyphData->bScaleCompositeOffset,
			pChildGlyphData->mulT,
#ifdef FSCFG_SUBPIXEL
			rotationParity,
#endif
			&fxXOffset,
			&fxYOffset);
	}
	else        /* Values are anchor points */
	{
		FS_ASSERT(pChildGlyphData->MultiplexingIndicator == AnchorPoints,
			   "Bad Multiplexing Indicator");
		scl_CalcComponentAnchorOffset(
			pParentElement,
			pChildGlyphData->usAnchorPoint1,
			pChildElement,
			pChildGlyphData->usAnchorPoint2,
			&fxXOffset,
			&fxYOffset);
	}
	scl_ShiftCurrentCharPoints(pChildElement, fxXOffset, fxYOffset);


	/* If USE_MY_METRICS, copy side bearings to parent  */

	if (pChildGlyphData->bUseMyMetrics)
	{
		pParentGlyphData->bUseChildMetrics = TRUE;

		scl_SaveSideBearingPoints(
			pChildElement,
			&pParentGlyphData->ptDevLSB,
			&pParentGlyphData->ptDevRSB);
	}

	fsg_MergeScanType(pChildGlyphData, pParentGlyphData);

	/* Start the copy   */

	/* scl_AppendOutlineData(pChildElement, pParentElement); */

	scl_UpdateParentElement(pChildElement, pParentElement);

	pChildElement->nc = 0;
}



FS_PRIVATE void fsg_LinkChild(
	GlyphData *     pGlyphData,     /* GlyphData pointer        */
	GlyphData *     pChildGlyphData)/* Child GlyphData pointer  */
{
	GlyphData * pTempGlyphData;

	if (pGlyphData->pChild == NULL)
	{
		pGlyphData->pChild = pChildGlyphData;
	}
	else
	{

		pTempGlyphData = pGlyphData->pChild;

		CHECK_GLYPHDATA(pTempGlyphData);

		while (pTempGlyphData->pSibling != pGlyphData)
		{
			pTempGlyphData = pTempGlyphData->pSibling;
			CHECK_GLYPHDATA(pTempGlyphData);
		}

		pTempGlyphData->pSibling = pChildGlyphData;
	}
	pChildGlyphData->pSibling = pGlyphData;
	pChildGlyphData->pParent =  pGlyphData;

	/* copy the transformation info from the parent */
	pChildGlyphData->currentTMatrix = pGlyphData->currentTMatrix;
	pChildGlyphData->bSameTransformAsMaster = pGlyphData->bSameTransformAsMaster;
}

FS_PRIVATE void fsg_TransformChild(
	GlyphData *     pGlyphData)     /* GlyphData pointer    */
{

	/* Apply local transform to glyph   */

	if (!mth_Identity(&pGlyphData->mulT))
	{
		scl_LocalPostTransformGlyph (pGlyphData->pGlyphElement, &pGlyphData->mulT);
	}
}

FS_PRIVATE void fsg_MergeScanType(
	GlyphData *     pGlyphData,       /* GlyphData pointer  */
	GlyphData *     pParentGlyphData) /* GlyphData pointer  */
{
	CHECK_GLYPHDATA(pGlyphData);
	CHECK_GLYPHDATA(pParentGlyphData);

	/* Merge Scan Type of parent and child  */

	if(pParentGlyphData->usScanType != SCANTYPE_UNINITIALIZED)
	{

		pParentGlyphData->usScanType =
			(uint16)(((pParentGlyphData->usScanType & (SK_NODROPOUT | SK_STUBS)) &
			(pGlyphData->usScanType & (SK_NODROPOUT | SK_STUBS))) |
			(pParentGlyphData->usScanType & SK_SMART));
	}
	else
	{
		pParentGlyphData->usScanType = pGlyphData->usScanType;
	}
}

/* Use various spline key values to determine if dropout control is to be activated
 * for this glyph, and if so what kind of dropout control.
 * The use of dropout control mode in the scan converter is controlled by 3 conditions.
 * The conditions are: Is the glyph rotated?, is the glyph stretched?,
 * is the current pixels per Em less than a specified threshold?
 * These conditions can be OR'd or ANDed together to determine whether the dropout control
 * mode ought to be used.

Six bits are used to specify the joint condition.  Their meanings are:

BIT     Meaning if set
8       Do dropout mode if other conditions don't block it AND
			pixels per em is less than or equal to bits 0-7
9       Do dropout mode if other conditions don't block it AND
			glyph is rotated
10      Do dropout mode if other conditions don't block it AND
			glyph is stretched
11      Do not do dropout mode unless ppem is less than or equal to bits 0-7
			A value of FF in 0-7  means all sizes
			A value of 0 in 0-7 means no sizes
12      Do not do dropout mode unless glyph is rotated
13      Do not do dropout mode unless glyph is stretched

In other words, we do not do dropout control if:
No bits are set,
Bit 8 is set, but ppem is greater than threshold
Bit 9 is set, but glyph is not rotated
Bit 10 is set, but glyph is not stretched
None of the conditions specified by bits 11-13 are true.

For example, 0xA10 specifies turn dropout control on if the glyph is rotated providing
that it is also less than 0x10 pixels per em.  A glyph is considered stretched if
the X and Y resolutions are different either because of the device characteristics
or because of the transformation matrix.  If both X and Y are changed by the same factor
the glyph is not considered stretched.

 */

FS_PRIVATE boolean fsg_DoScanControl(
	uint16 usScanControl,
	uint32 ulImageState)
{
	if ((usScanControl & SCANCTRL_DROPOUT_IF_LESS) &&
		((uint8)(ulImageState & IMAGESTATE_SIZE_MASK) <= (uint8)(usScanControl & SCANCTRL_SIZE_MASK)))
	{
		return TRUE;
	}

	if ((usScanControl & SCANCTRL_DROPOUT_IF_LESS) &&
		((usScanControl & SCANCTRL_SIZE_MASK) == SCANCTRL_DROPOUT_ALL_SIZES))
	{
		return TRUE;
	}

	if ((usScanControl & SCANCTRL_DROPOUT_IF_ROTATED) &&
		(ulImageState & IMAGESTATE_ROTATED))
	{
		return TRUE;
	}

	if ((usScanControl & SCANCTRL_DROPOUT_IF_STRETCHED) &&
		(ulImageState & IMAGESTATE_STRETCHED))
	{
		return TRUE;
	}

	if ((usScanControl & SCANCTRL_NODROP_UNLESS_LESS) &&
		((uint8)(ulImageState & IMAGESTATE_SIZE_MASK) > (uint8)(usScanControl & SCANCTRL_SIZE_MASK)))
	{
		return FALSE;
	}

	if ((usScanControl & SCANCTRL_NODROP_UNLESS_ROTATED) &&
		! (ulImageState & IMAGESTATE_ROTATED))
	{
		return FALSE;
	}

	if ((usScanControl & SCANCTRL_NODROP_UNLESS_STRETCH) &&
		! (ulImageState & IMAGESTATE_STRETCHED))
	{
		return FALSE;
	}

	return FALSE;
}

FS_PRIVATE void fsg_InitializeGlyphDataMemory(
	uint32              ulGlyphDataCount,
	fsg_WorkSpaceAddr * pWorkSpaceAddr) /* WorkSpace Address      */
{
	uint32      ulIndex;
	boolean *   abyGlyphDataFreeBlocks;

	abyGlyphDataFreeBlocks = pWorkSpaceAddr->pGlyphDataByteSet;

	for(ulIndex = 0; ulIndex < ulGlyphDataCount; ulIndex++)
	{
		abyGlyphDataFreeBlocks[ulIndex] = TRUE;
	}
}

FS_PRIVATE  ErrorCode fsg_AllocateGlyphDataMemory(
	uint32              ulGlyphDataCount,
	fsg_WorkSpaceAddr * pWorkSpaceAddr, /* WorkSpace Address      */
	GlyphData **        ppGlyphData)      /* GlyphData pointer    */
{
	uint32      ulIndex;
	boolean *   abyGlyphDataFreeBlocks;

	abyGlyphDataFreeBlocks = pWorkSpaceAddr->pGlyphDataByteSet;

	ulIndex = 0;
	while((!abyGlyphDataFreeBlocks[ulIndex]) && ulIndex < ulGlyphDataCount)
	{
		ulIndex++;
	}

	if (ulIndex == ulGlyphDataCount)
	{
		return SFNT_RECURSIVE_COMPOSITE_ERR;
	}

	abyGlyphDataFreeBlocks[ulIndex] = FALSE;

	*ppGlyphData = (GlyphData *)&((GlyphData *)pWorkSpaceAddr->pvGlyphData)[ulIndex];
	return NO_ERR;
}

FS_PRIVATE void fsg_DeallocateGlyphDataMemory(
	fsg_WorkSpaceAddr * pWorkSpaceAddr, /* WorkSpace Address    */
	GlyphData *         pGlyphData)     /* GlyphData pointer    */
{
	ptrdiff_t   ptIndex;
	boolean *   abyGlyphDataFreeBlocks;

	pGlyphData->acIdent[0] = '\0';
	pGlyphData->acIdent[1] = '\0';

	abyGlyphDataFreeBlocks = pWorkSpaceAddr->pGlyphDataByteSet;

	ptIndex = (ptrdiff_t)(pGlyphData - (GlyphData *)pWorkSpaceAddr->pvGlyphData);

	abyGlyphDataFreeBlocks[ptIndex] = TRUE;
}

FS_PRIVATE void fsg_InitializeGlyphData(
	GlyphData *             pGlyphData,     /* GlyphData pointer    */
	fsg_WorkSpaceAddr *     pWorkSpaceAddr, /* WorkSpace Address    */
	uint16                  usGlyphIndex,   /* Glyph Index          */
	uint16                  usDepth)        /* Glyph depth          */
{
	pGlyphData->acIdent[0] = 'G';
	pGlyphData->acIdent[1] = 'D';
	pGlyphData->pSibling = NULL;
	pGlyphData->pChild = NULL;
	pGlyphData->pParent = NULL;
	pGlyphData->GlyphType = glyphUndefined;
	pGlyphData->hGlyph.pvGlyphBaseAddress = NULL;
	pGlyphData->hGlyph.pvGlyphNextAddress = NULL;
	pGlyphData->usDepth = usDepth;
	pGlyphData->bUseMyMetrics = FALSE;
	pGlyphData->bScaleCompositeOffset = FALSE;
	pGlyphData->bUseChildMetrics = FALSE;
	pGlyphData->bbox.xMin = SHRT_MAX;
	pGlyphData->bbox.yMin = SHRT_MAX;
	pGlyphData->bbox.xMax = SHRT_MIN;
	pGlyphData->bbox.yMax = SHRT_MIN;
	pGlyphData->usSizeOfInstructions = 0;
	pGlyphData->pbyInstructions = NULL;
	pGlyphData->usNonScaledAW = 0;
	pGlyphData->sNonScaledLSB = 0;
	pGlyphData->MultiplexingIndicator = Undefined;
	pGlyphData->bRoundXYToGrid = FALSE;
	pGlyphData->usGlyphIndex = usGlyphIndex;
	pGlyphData->sXOffset = 0;
	pGlyphData->sYOffset = 0;
	pGlyphData->usAnchorPoint1 = 0;
	pGlyphData->usAnchorPoint2 = 0;
	pGlyphData->mulT = IdentTransform;
	pGlyphData->usScanType = SCANTYPE_UNINITIALIZED;
	pGlyphData->ptDevLSB.x = 0L;
	pGlyphData->ptDevLSB.y = 0L;
	pGlyphData->ptDevRSB.x = 0L;
	pGlyphData->ptDevRSB.y = 0L;
	pGlyphData->pGlyphElement = &pWorkSpaceAddr->pGlyphElement[usDepth];
	pGlyphData->pGlyphElement->nc = 0;
	pGlyphData->currentTMatrix = IdentTransform;
	pGlyphData->bSameTransformAsMaster = TRUE;
}

#ifdef  FSCFG_NO_INITIALIZED_DATA
FS_PUBLIC  void fsg_InitializeData (void)
{
	itrp_InitializeData ();
}
#endif

/* definitions and prototype for functions used in emboldening */

#define MABS(x)                 ( (x) < 0 ? (-(x)) : (x) )

#define LEFTSIDEBEARING 0
#define RIGHTSIDEBEARING 1

#define TOPSIDEBEARING 2
#define BOTTOMSIDEBEARING 3

#define LSBPOINTNUM(pElement) (uint16)(pElement->ep[pElement->nc - 1] + 1 + LEFTSIDEBEARING)
#define RSBPOINTNUM(pElement) (uint16)(pElement->ep[pElement->nc - 1] + 1 + RIGHTSIDEBEARING)

#define TOPSBPOINTNUM(pElement) (uint16)(pElement->ep[pElement->nc - 1] + 1 + TOPSIDEBEARING)
#define BOTTOMSBPOINTNUM(pElement) (uint16)(pElement->ep[pElement->nc - 1] + 1 + BOTTOMSIDEBEARING)

#define POSINFINITY               0x7FFFFFFFUL

#define NotSameKnot(a,b) ((a).x != (b).x || (a).y != (b).y)

/* used by QDiv2 and FQuadraticEqn */
#define places16 16
#define half16 (1 << (places16-1))

#define F32Dot32 int64

#ifndef	Sgn
	#define Sgn(a)		((a) < 0 ? -1 : ((a) > 0 ? 1 : 0))
#endif

typedef struct F26Dot6VECTOR {
	F26Dot6 x;
	F26Dot6 y;
} F26Dot6VECTOR;

typedef struct { long x,y; } Vector;

typedef enum { linkBlack, linkGrey, linkWhite } LinkColor;

short ComputeSign(int32 DeltaPrevX, int32 DeltaPrevY, int32 DeltaNextX, int32 DeltaNextY);

int64 QDiv2(int64 a, int64 b);

void FQuadraticEqn(int64 a, int64 b, int64 c, long* solutions, int64* t1, int64* t2);

F32Dot32 FSqrt(uint64 radicand);

long CurveTransitions(Vector V0, Vector V1, Vector W0, Vector W1, Vector W2);

long CurveTransitionsSegment(Vector V0, Vector V1, Vector W0, Vector W1);

void CalculateXExtremum(boolean min, long V0X, long V0Y, boolean V0On, long V1X, long V1Y, long V2X, long V2Y, boolean V2On, long *extrX, long *extrY);

void CalculateYExtremum(boolean min, long V0X, long V0Y, boolean V0On, long V1X, long V1Y, long V2X, long V2Y, boolean V2On, long *extrX, long *extrY);

void SetLineToInfinity (int16 extremumNumber, Vector extremum, Vector* C0, Vector* C1);

void MinMax2Vectors (Vector A,Vector B,Vector *Min, Vector *Max);

void MinMax3Vectors (Vector A,Vector B,Vector C, Vector *Min, Vector *Max);

boolean CheckBoundingBoxCurve(Vector C0,Vector W0,Vector W1,Vector W2,int16 extremumNumber);

boolean CheckBoundingBoxSegment(Vector C0,Vector W0,Vector W1,int16 extremumNumber);

void NormalizeVector26Dot6 (F26Dot6VECTOR *pVect);

void Intersect26Dot6(F26Dot6VECTOR Pt1, F26Dot6VECTOR Pt2, F26Dot6VECTOR Pt3, F26Dot6VECTOR Pt4, F26Dot6VECTOR *ResultPt);

void  EmboldPoint(int32 iPt, int32 iPt1, 
                  boolean bUnderTheThreshold, boolean bMisoriented, 
				  F26Dot6VECTOR PrevPt, 
				  F26Dot6VECTOR CurrPt, 
				  F26Dot6VECTOR NextPt, 
				  F26Dot6 fxRightShift, F26Dot6 fxLeftShift, 
				  F26Dot6 fxTopShift, F26Dot6 fxBottomShift, 
				  F26Dot6	fxScaledDescender,
				  fnt_ElementType * pElement); 
 
boolean Misoriented(int32 contour, uint16 extremumNumber, short extremumKnot, Vector extremum, fnt_ElementType *pElement);

/* emboldening related code */

void NormalizeVector26Dot6 (F26Dot6VECTOR *pVect)
{
	VECTOR Vec;

	itrp_Normalize (pVect->x, pVect->y, &Vec);

	/* transform from ShortFract to 26.6 */
	pVect->x = Vec.x >> 8;
	pVect->y = Vec.y >> 8;	
}

void Intersect26Dot6(F26Dot6VECTOR Pt1, F26Dot6VECTOR Pt2, F26Dot6VECTOR Pt3, F26Dot6VECTOR Pt4, F26Dot6VECTOR *ResultPt)
{
	/* this procedure was inspired by itrp_ISECT */
	F26Dot6 N, D;
	F26Dot6VECTOR B, A;
	F26Dot6VECTOR dB, dA;

	  dA.x = Pt2.x - (A.x = Pt1.x);
	  dA.y = Pt2.y - (A.y = Pt1.y);

	  dB.x = Pt4.x - (B.x = Pt3.x);
	  dB.y = Pt4.y - (B.y = Pt3.y);

	  if (dA.y == 0) 
	  {
		if (dB.x == 0) 
		{
		  ResultPt->x = B.x;
		  ResultPt->y = A.y;
		  return;
		}
		N = B.y - A.y;
		D = -dB.y;
	  } 
	  else if (dA.x == 0) 
	  {
		if (dB.y == 0) 
		{
		  ResultPt->x = A.x;
		  ResultPt->y = B.y;
		  return;
		}
		N = B.x - A.x;
		D = -dB.x;
	  } 
	  else if (MABS (dA.x) >= MABS (dA.y))
	  {
/* To prevent out of range problems divide both N and D with the max */
		N = (B.y - A.y) - MulDiv26Dot6 (B.x - A.x, dA.y, dA.x);
		D = MulDiv26Dot6 (dB.x, dA.y, dA.x) - dB.y;
	  } 
	  else 
	  {
		N = MulDiv26Dot6 (B.y - A.y, dA.x, dA.y) - (B.x - A.x);
		D = dB.x - MulDiv26Dot6 (dB.y, dA.x, dA.y);
	  }

	  if (MABS(D) > 16) /* this test used to be D != 0 but for very small D we get degenerescence */
	  {
		ResultPt->x = B.x + (F26Dot6) MulDiv26Dot6 (dB.x, N, D);
		ResultPt->y = B.y + (F26Dot6) MulDiv26Dot6 (dB.y, N, D);
	  } 
	  else 
	  {
/* degenerate case: parallell lines, what make sence in this special case is to take the
		  middle point between Pt2 and Pt3 */
		ResultPt->x = (Pt2.x + Pt3.x) >> 1;
		ResultPt->y = (Pt2.y + Pt3.y) >> 1;
	  }

	
}

void  EmboldPoint(int32 iPt, int32 iPt1, 
                  boolean bUnderTheThreshold, boolean bMisoriented,
				  F26Dot6VECTOR PrevPt, 
				  F26Dot6VECTOR CurrPt, 
				  F26Dot6VECTOR NextPt, 
				  F26Dot6 fxRightShift, F26Dot6 fxLeftShift, 
				  F26Dot6 fxTopShift, F26Dot6 fxBottomShift, 
				  F26Dot6	fxScaledDescender,
				  fnt_ElementType * pElement) 


{
	F26Dot6VECTOR dPrev, dNext, Shift, CurrPt1,  NewPt, Delta ;
	F26Dot6 fxTemp;
    int32 i;

	dPrev.x = CurrPt.x - PrevPt.x;
	dPrev.y = CurrPt.y - PrevPt.y;

	dNext.x = NextPt.x - CurrPt.x;
	dNext.y = NextPt.y - CurrPt.y;

	/* compute the orthogonal vectors */

	fxTemp = dPrev.x;
	dPrev.x = -dPrev.y;
	dPrev.y = fxTemp;

	fxTemp = dNext.x;
	dNext.x = -dNext.y;
	dNext.y = fxTemp;

    if (bMisoriented)
    {
	    dPrev.x = -dPrev.x;
	    dPrev.y = -dPrev.y;
	    dNext.x = -dNext.x;
	    dNext.y = -dNext.y;
    }

    /* copy of the current point */

	CurrPt1 = CurrPt;

    if (bUnderTheThreshold)
    {
        /* most common case, we are just moving control points one pixel horizontally */

 	    if (dPrev.x > 0)
	    {
            CurrPt1.x += fxRightShift;
	    }
	    if (dNext.x > 0)
	    {
            CurrPt.x += fxRightShift;
	    }
    } else 
    {
        /* generalization, move along the vector normal to the curve */

	    /* normalize the vectors */
	    NormalizeVector26Dot6 (&dPrev);
	    NormalizeVector26Dot6 (&dNext);


        /* apply the shift on the previous segment */

	    /* Multiply the normalized vector by the shift factor */
	    if (dPrev.x > 0)
	    {
		    Shift.x = Mul26Dot6(dPrev.x, fxRightShift);
	    } else {
		    Shift.x = Mul26Dot6(dPrev.x, fxLeftShift);
	    }

	    if (dPrev.y < 0)
	    {
		    Shift.y = Mul26Dot6(dPrev.y, fxBottomShift);
	    } else {
		    Shift.y = Mul26Dot6(dPrev.y, fxTopShift);
	    }

	    PrevPt.x += Shift.x;
	    PrevPt.y += Shift.y;

	    CurrPt1.x += Shift.x;
	    CurrPt1.y += Shift.y;

	    /* second segment */

	    /* Multiply the normalized vector by the shift factor */
	    if (dNext.x > 0)
	    {
		    Shift.x = Mul26Dot6(dNext.x, fxRightShift);
	    } else {
		    Shift.x = Mul26Dot6(dNext.x, fxLeftShift);
	    }

	    if (dNext.y < 0)
	    {
		    Shift.y = Mul26Dot6(dNext.y, fxBottomShift);
	    } else {
		    Shift.y = Mul26Dot6(dNext.y, fxTopShift);
	    }

	    NextPt.x += Shift.x;
	    NextPt.y += Shift.y;

	    CurrPt.x += Shift.x;
	    CurrPt.y += Shift.y;
    }

	if (CurrPt1.x == CurrPt.x && CurrPt1.y == CurrPt.y)
	{
		/* both points were moved by the same value, no need to intersect */
		pElement->x[iPt] = CurrPt.x;
		pElement->y[iPt] = CurrPt.y;
	} else
	{
	/* we need to reintersect */
		Intersect26Dot6(PrevPt, CurrPt1, CurrPt, NextPt, &NewPt);

		/* sanity check that we are not moving the point too far from it's original position,
			this happen at low ppem size when segment lenght get small compared to the shift 
			or when hinting caused outline overlapp */
		Delta.x = NewPt.x - pElement->x[iPt];
		Delta.y = NewPt.y - pElement->y[iPt];

		if (Delta.x > fxRightShift)
		{
			NewPt.x = pElement->x[iPt] + fxRightShift;
		}
		if (Delta.x < -fxLeftShift)
		{
			NewPt.x = pElement->x[iPt] - fxLeftShift;
		}
		if (Delta.y < -fxBottomShift)
		{
			NewPt.y = pElement->y[iPt] - fxBottomShift;
		} 
		if (Delta.y > fxTopShift)
		{
			NewPt.y = pElement->y[iPt] + fxBottomShift;
		} 

		pElement->x[iPt] = NewPt.x;
		pElement->y[iPt] = NewPt.y;

	}
	/* shift all points by fxLeftShift, fxTopShift */
	pElement->x[iPt] += fxLeftShift;
	pElement->y[iPt] += fxBottomShift;

	if (pElement->y[iPt] < fxScaledDescender)
	{
		/* clipping to prevent going below the descender and causing out of bounds problems */
		pElement->y[iPt] = fxScaledDescender;
	}

    if (iPt != iPt1)
    {
        /* duplicate points at the same coordinate, we need to move them all */
	    for(i= iPt + 1; i <= iPt1; i++)
        {
	        pElement->x[i] = pElement->x[iPt];
	        pElement->y[i] = pElement->y[iPt];
        }
    }

}

FS_PRIVATE void  fsg_Embold(
	fsg_WorkSpaceAddr * pWorkSpaceAddr,
	void *              pvGlobalGS,
	boolean             bUseHints, /* True if glyph is gridfitted       */
	boolean             bBitmapEmboldening
#ifdef FSCFG_SUBPIXEL
	,boolean            bSubPixel
#endif // FSCFG_SUBPIXEL
    )
{
	fnt_ElementType *pElement;
	fnt_GlobalGraphicStateType *globalGS;
	int32 iContour, iPt, iPt1, iStartPt, iEndPt;
	F26Dot6VECTOR FirstPt, PrevPt, NextPt, CurrPt;
	F26Dot6 fxRightShift, fxLeftShift; 
	F26Dot6 fxTopShift, fxBottomShift; 
    boolean bUnderTheThreshold;
    boolean bMisoriented;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	pElement = pWorkSpaceAddr->pGlyphElement;

    bUnderTheThreshold = (globalGS->uBoldSimulHorShift == 1);

#ifdef FSCFG_SUBPIXEL
	if (bSubPixel)
    {
        bUnderTheThreshold = (globalGS->uBoldSimulHorShift <= HINTING_HOR_OVERSCALE);
    }
#endif // FSCFG_SUBPIXEL

	/* adjust the right sidebearing */
    if (pElement->x[RSBPOINTNUM(pElement)] != pElement->x[LSBPOINTNUM(pElement)]) 
        /* we don't increase the width of a zero width glyph, problem with indic script */
    {
#ifdef FSCFG_SUBPIXEL
	    if (bSubPixel)
        {
    	    pElement->x[RSBPOINTNUM(pElement)] += ( ( 1 / HINTING_HOR_OVERSCALE) << 6); /* we increase the widht by one pixel regardless of size for backwards compatibility */
        } else {
#endif // FSCFG_SUBPIXEL
			pElement->x[RSBPOINTNUM(pElement)] += (1 << 6); /* we increase the widht by one pixel regardless of size for backwards compatibility */
#ifdef FSCFG_SUBPIXEL
        }
#endif // FSCFG_SUBPIXEL
    }

	/* adjust the bottom sidebearing, this is done by the value of the HorShift and not the VertShift for backwards compatibility
	   in vertical writing */
    if (pElement->y[BOTTOMSBPOINTNUM(pElement)] != pElement->y[TOPSBPOINTNUM(pElement)])
        /* we don't increase the width of a zero width glyph, problem with indic script */
    {
    	pElement->y[BOTTOMSBPOINTNUM(pElement)] -= (1 << 6); /* we increase the widht by one pixel regardless of size for backwards compatibility */
    }

	if (!bBitmapEmboldening)
	{    

		if (bUseHints)
		{
			/* to preserve the hinting, we should move by an integer amount of pixel */
			/* divide by 2, round to pixel, convert to 26.6 */
#ifdef FSCFG_SUBPIXEL
	        if (bSubPixel)
            {
			    fxLeftShift = ((globalGS->uBoldSimulHorShift /HINTING_HOR_OVERSCALE) >> 1) * HINTING_HOR_OVERSCALE; 
			    fxRightShift = (globalGS->uBoldSimulHorShift - fxLeftShift) << 6;
			    fxLeftShift = fxLeftShift << 6; 
            } else {
#endif // FSCFG_SUBPIXEL
			    fxLeftShift = globalGS->uBoldSimulHorShift >> 1; 
			    fxRightShift = (globalGS->uBoldSimulHorShift - fxLeftShift) << 6;
			    fxLeftShift = fxLeftShift << 6; 
#ifdef FSCFG_SUBPIXEL
            }
#endif // FSCFG_SUBPIXEL
			fxTopShift = globalGS->uBoldSimulVertShift >> 1;
			fxBottomShift = (globalGS->uBoldSimulVertShift - fxTopShift) << 6;
			fxTopShift = fxTopShift << 6;
		} else {
			/* divide by 2, convert to 26.6 */
			fxRightShift = globalGS->uBoldSimulHorShift << 5;
			fxLeftShift = globalGS->uBoldSimulHorShift << 5; 
			fxTopShift = globalGS->uBoldSimulVertShift << 5;
			fxBottomShift = globalGS->uBoldSimulVertShift << 5;
		}

		for (iContour = 0; iContour < pElement->nc; iContour++)
		{
			iStartPt = pElement->sp[iContour];
			iEndPt = pElement->ep[iContour];

			if (iEndPt - iStartPt >= 2)
			/* contour with less than 3 points cannot be emboldened */
			{
                bMisoriented = FALSE;
                if (pElement->fc[iContour] & OUTLINE_MISORIENTED)
                {
                    bMisoriented = TRUE;
                }
				/* we need to save the original coordinate of the first point for the computation of the last point */
				/* to compute the new coordinate for a point, we need the original coordinate of the point, the previous point
				  and the next point */

				FirstPt.x = pElement->x[iStartPt];
				FirstPt.y = pElement->y[iStartPt];

				CurrPt = FirstPt;

				PrevPt.x = pElement->x[iEndPt];
				PrevPt.y = pElement->y[iEndPt];

				NextPt.x = pElement->x[iStartPt+1];
				NextPt.y = pElement->y[iStartPt+1];

				iPt = iStartPt;

				while (iPt <= iEndPt)
				{
					iPt1 = iPt;

					/* deal with the special case of two points at the same coordinate, current and next */
					while ((NextPt.x == CurrPt.x) && (NextPt.y == CurrPt.y) && (iPt1 < iEndPt))
					{
						iPt1++;

						 if (iPt1 >= iEndPt)
							 /* the >= is to avoid goind out of bounds when preparing Prev, Next, Curr at the last step */
						{
							NextPt.x = FirstPt.x;
							NextPt.y = FirstPt.y;
						} else {
							NextPt.x = pElement->x[iPt1 +1];
							NextPt.y = pElement->y[iPt1 +1];
						}
					}

					/* we do the computation for the current point */

					EmboldPoint(iPt, iPt1, bUnderTheThreshold, bMisoriented, PrevPt, CurrPt, NextPt, 
							fxRightShift, fxLeftShift, fxTopShift, fxBottomShift, globalGS->fxScaledDescender, pElement); 
                
					iPt = iPt1;

					iPt++;
					/* we compute Prev, Next, Curr coordinate for the next point */

					PrevPt = CurrPt;

					CurrPt = NextPt;

					 if (iPt >= iEndPt)
						 /* the >= is to avoid goind out of bounds when preparing Prev, Next, Curr at the last step */
					{
						NextPt.x = FirstPt.x;
						NextPt.y = FirstPt.y;
					} else {
						NextPt.x = pElement->x[iPt +1];
						NextPt.y = pElement->y[iPt +1];
					}
				}
			}
		}
    }
}

short ComputeSign(int32 DeltaPrevX, int32 DeltaPrevY, int32 DeltaNextX, int32 DeltaNextY)
{
    int32 sgn;

	/* as our coordinates are in desing unit, they fit in 16 bits and we are not overflowing here */

    sgn = DeltaPrevX*DeltaNextY - DeltaPrevY*DeltaNextX;
	return (short)Sgn(sgn); // +1 => left turn, -1 => right turn, 0 => straight
}

Vector AddV(const Vector a, const Vector b) {
	Vector c;
	
	c.x = a.x + b.x;
	c.y = a.y + b.y;
	return c;
} // AddV

Vector SubV(const Vector a, const Vector b) {
	Vector c;
	
	c.x = a.x - b.x;
	c.y = a.y - b.y;
	return c;
} // SubV

Vector ShlV(const Vector a, long by) {
	Vector b;
	
	b.x = a.x << by;
	b.y = a.y << by;
	return b;
} // ShlV

Vector ShrV(const Vector a, long by) {
	Vector b;
	
	b.x = a.x >> by;
	b.y = a.y >> by;
	return b;
} // ShrV

int64 QDiv2(int64 a, int64 b) { // special version that replaces epsilons by 1, which is actually 1/65536 since we're actually returning F48Dot16
	int64 q;

	if (a < 0 != b < 0) {
		if (a < 0) a = -a; else b = -b;
		if (a < b) q = -1; else if (a > b << places16) q = -65536-1; else q = -((a + (b >> 1))/b);
	} else {
		if (a < 0) a = -a, b = -b;
		if (a < b) q = 1; else if (a > b << places16) q = 65536+1; else q = (a + (b >> 1))/b;
	}
	return q;
} // QDiv2

F32Dot32 FSqrt(uint64 radicand) {
	uint64 bit,root,s;

	root = 0;
	for (bit = (uint64)1 << 62; bit >= 0x8000 /* we don't need the last 16 bits */; bit >>= 1) {
		s = bit + root;
		if (s <= radicand) {
			radicand -= s;
			root |= (bit << 1);
		};
		radicand <<= 1;
	}
	return root;
} // FSqrt

void FQuadraticEqn(int64 a, int64 b, int64 c, long* solutions, int64* t1, int64* t2) {
	// the usual method for solving quadratic equations
	// input is actually in 32bit, output is F48Dot16
	int64 radicand,root,b1,b2,c1;
	
	*solutions = 0;
	if (a == 0) {
		if (b != 0) {
			*solutions = 1;
			c1 = -(c << places16);
			*t1 = QDiv2(c1,b);
		} // else b == 0, no solutions
	} else {
		a *= 2;
		radicand = b*b - 2*a*c;
		if (radicand > 0) {
			*solutions = 2;

            root = (FSqrt(radicand) + half16) >> places16;
            b <<= places16;

			b1 = -(b - root);
			b2 = -(b + root);
			*t1 = QDiv2(b1,a);
			*t2 = QDiv2(b2,a);
		} else if (radicand == 0) {
			*solutions = 1;
			b1 = -(b << places16);
			*t1 = QDiv2(b1,a);
		} // else radicand < 0, no solutions
	}
} // FQuadraticEqn

long CurveTransitionsSegment(Vector V0, Vector V1, Vector W0, Vector W1) {

//	here we're intersecting a straight line (W0, W1) with a straight line (V0, V1).
//	for the two to intersect, and writing both intersectees in standard polynomial form, there must be parameters u and v such that
//
//		A.x*u + B.x = C.x*v + D.x
//		A.y*u + B.y = C.y*v + D.y
//
//	a system of two "halfway" linear eqns. in two unknowns u and v
//	solving the first eqn. for v (which is linear in v, hence the "halfway") yields
//
//		v = (A.x*u + B.x - D.x)/C.x
//
//	substituting v into the second eqn. yields
//
//		A.y*u + B.y - D.y = C.y*(A.x*u + B.x - D.x)/C.x
//
//	rearranging terms by powers of u and multiplying by D.x yields
//
//		(A.y*C.x - C.y*A.x)*u + B.y*C.x - D.y*C.x + C.y*D.x - C.y*B.x = 0
//
//	which is a single linear eqn. in u with 0 thru 1 solutions obtained "the usual way".
//	solutions must be in the interval ]0,1] to make sure we only accept intersections of the actual segment
//	and we don't count start/end points twice by including them in adjacent segments as well (cf. also ColorTransitions above)

	Vector A,B,C,D;
    int64 a, b;
	long transitions;
	int64 u,vd;

//	re-write Line in polynomial form
//	(W1 - W0)*u + W0, which follows immediately from the "first degree" Bzier "curve" W0*(1-u) + W1*u
	A = SubV(W1,W0);
	B = W0;


//	re-write Line in polynomial form
//	(V1 - V0)*v + V0, which follows immediately from the "first degree" Bzier "curve" V0*(1-u) + V1*u
	C = SubV(V1,V0);
	D = V0;

    a = (A.y*C.x - C.y*A.x);

	transitions = 0;

    if (a != 0)
    {
        b = B.y*C.x - D.y*C.x + C.y*D.x - C.y*B.x;

    //  a*u + b = 0 => u = -b / a

	    b = -b << places16;
	    u = QDiv2(b,a); /* u stored in 48.16 */
	    
	    if (0 < u && u <= 0x10000) {
                /* to avoid loss of precision, select in which equation to replace the value of u[] */
            if (MABS(C.x) > MABS(C.y))
            {
			    vd = ((int64)A.x)*u  + ((int64)(B.x - D.x))*0x10000; // avoid division by 0 => multiply by C.x
		    //	transitions += 0 < vd && vd <= Abs(C.x);
			    if (C.x >= 0) {
				    if (0 < vd && vd <= ((int64)C.x)*0x10000) transitions++;
			    } else {
				    if (((int64)C.x)*0x10000 <= vd && vd < 0) transitions++;
			    }
            } else {
			    vd = ((int64)A.y)*u  + ((int64)(B.y - D.y))*0x10000; // avoid division by 0 => multiply by C.y
		    //	transitions += 0 < vd && vd <= Abs(C.y);
			    if (C.y >= 0) {
				    if (0 < vd && vd <= ((int64)C.y)*0x10000) transitions++;
			    } else {
				    if (((int64)C.y)*0x10000 <= vd && vd < 0) transitions++;
			    }
            }
	    }
    }

	return transitions;
} // CurveTransitionsSegment

long CurveTransitions(Vector V0, Vector V1, Vector W0, Vector W1, Vector W2) {

//	here we're intersecting a quadratic Bzier curve (W0, W1, W2) with a straight line (V0, V1).
//	for the two to intersect, and writing both intersectees in standard polynomial form, there must be parameters u and v such that
//
//		A.x*u^2 + B.x*u + C.x = D.x*v + E.x
//		A.y*u^2 + B.y*u + C.y = D.y*v + E.y
//
//	a system of two "halfway" quadratic eqns. in two unknowns u and v
//	solving the first eqn. for v (which is linear in v, hence the "halfway") yields
//
//		v = (A.x*u^2 + B.x*u + C.x - E.x)/D.x
//
//	substituting v into the second eqn. yields
//
//		A.y*u^2 + B.y*u + C.y - E.y = D.y*(A.x*u^2 + B.x*u + C.x - E.x)/D.x
//
//	rearranging terms by powers of u and multiplying by D.x yields
//
//		(A.y*D.x - D.y*A.x)*u^2 + (B.y*D.x - D.y*B.x)*u + C.y*D.x - D.y*C.x - E.y*D.x + D.y*E.x = 0
//
//	which is a single quadratic eqn. in u with 0 thru 2 solutions obtained "the usual way".
//	solutions must be in the interval ]0,1] to make sure we only accept intersections of the actual Bzier segment
//	and we don't count start/end points twice by including them in adjacent Bzier segments as well (cf. also ColorTransitions above)

	Vector A,B,C,D,E;
	long i,solutions,transitions;
	int64 u[2],vd;

//	re-write Bzier curve in polynomial form
//	W0*(1-u)^2 + 2*W1*(1-u)*u + W2*u^2 = W0*(1 - 2*u + u^2) + 2*W1*(u - u^2) + W2*u^2 = 
//	(W0 - 2*W1 + W2)*u^2 + 2*(W1 - W0)*u + W0
	A = AddV(SubV(W0,ShlV(W1,1)),W2);
	B = ShlV(SubV(W1,W0),1);
	C = W0;

//	re-write Line in polynomial form
//	(V1 - V0)*v + V0, which follows immediately from the "first degree" Bzier "curve" V0*(1-u) + V1*u
	D = SubV(V1,V0);
	E = V0;

	FQuadraticEqn(A.y*D.x - D.y*A.x,B.y*D.x - D.y*B.x,C.y*D.x - D.y*C.x - E.y*D.x + D.y*E.x,&solutions,&u[0],&u[1]);
	
	transitions = 0;
	for (i = 0; i < solutions; i++) {
		if (0 < u[i] && u[i] <= 0x10000) {
            /* to avoid loss of precision, select in which equation to replace the value of u[] */
            if (MABS(D.x) > MABS(D.y))
            {
			    vd = ((int64)A.x)*u[i]*u[i] + ((int64)B.x)*u[i]*0x10000 + ((int64)(C.x - E.x))*0x100000000; // avoid division by 0 => multiply by D.x
		    //	transitions += 0 < vd && vd <= Abs(D.x);
			    if (D.x >= 0) {
				    if (0 < vd && vd <= ((int64)D.x)*0x100000000) transitions++;
			    } else {
				    if (((int64)D.x)*0x100000000 <= vd && vd < 0) transitions++;
			    }
            } else {
			    vd = ((int64)A.y)*u[i]*u[i] + ((int64)B.y)*u[i]*0x10000 + ((int64)(C.y - E.y))*0x100000000; // avoid division by 0 => multiply by D.y
		    //	transitions += 0 < vd && vd <= Abs(D.y);
			    if (D.y >= 0) {
				    if (0 < vd && vd <= ((int64)D.y)*0x100000000) transitions++;
			    } else {
				    if (((int64)D.y)*0x100000000 <= vd && vd < 0) transitions++;
			    }
            }
		}
	}


	return transitions;
} // CurveTransitions

boolean CheckBoundingBoxCurve(Vector C0,Vector W0,Vector W1,Vector W2,int16 extremumNumber)
{
    Vector Min, Max;

    /* the curve is completely conatined in the triangle W0,W1,W2 */
    MinMax3Vectors (W0, W1, W2, &Min, &Max);

	switch (extremumNumber)
	{
	case 0:
        /* look for Min X */
        if ((Min.y <= C0.y) && (Max.y >= C0.y) && (Min.x <= C0.x) )
        {
            /* we may have an intersection */
            return TRUE;
        } else {
            return FALSE;
        }
        break;
	case 1:
        /* look for Max X */
        if ((Min.y <= C0.y) && (Max.y >= C0.y) && (Max.x >= C0.x) )
        {
            /* we may have an intersection */
            return TRUE;
        } else {
            return FALSE;
        }
        break;
	case 2:
        /* look for Min Y */
        if ((Min.x <= C0.x) && (Max.x >= C0.x) && (Min.y <= C0.y) )
        {
            /* we may have an intersection */
            return TRUE;
        } else {
            return FALSE;
        }
        break;
	case 3:
        /* look for Max Y */
        if ((Min.x <= C0.x) && (Max.x >= C0.x) && (Max.y >= C0.y) )
        {
            /* we may have an intersection */
            return TRUE;
        } else {
            return FALSE;
        }
        break;
	default:  
        /* we should never get in that case */
        FS_ASSERT(FALSE,"fsglue.c, CheckBoundingBoxCurve, illegal case");
        return TRUE;
    }

}

boolean CheckBoundingBoxSegment(Vector C0,Vector W0,Vector W1, int16 extremumNumber)
{
    Vector Min, Max;

    MinMax2Vectors (W0, W1, &Min, &Max);

	switch (extremumNumber)
	{
	case 0:
        /* look for Min X */
        if ((Min.y <= C0.y) && (Max.y >= C0.y) && (Min.x <= C0.x) )
        {
            /* we may have an intersection */
            return TRUE;
        } else {
            return FALSE;
        }
        break;
	case 1:
        /* look for Max X */
        if ((Min.y <= C0.y) && (Max.y >= C0.y) && (Max.x >= C0.x) )
        {
            /* we may have an intersection */
            return TRUE;
        } else {
            return FALSE;
        }
        break;
	case 2:
        /* look for Min Y */
        if ((Min.x <= C0.x) && (Max.x >= C0.x) && (Min.y <= C0.y) )
        {
            /* we may have an intersection */
            return TRUE;
        } else {
            return FALSE;
        }
        break;
	case 3:
        /* look for Max Y */
        if ((Min.x <= C0.x) && (Max.x >= C0.x) && (Max.y >= C0.y) )
        {
            /* we may have an intersection */
            return TRUE;
        } else {
            return FALSE;
        }
        break;
	default:  
        /* we should never get in that case */
        FS_ASSERT(FALSE,"fsglue.c, CheckBoundingBoxSegment, illegal case");
        return TRUE;
    }

}

void CalculateXExtremum(boolean min, long V0X, long V0Y, boolean V0On, long V1X, long V1Y, long V2X, long V2Y, boolean V2On, long *extrX, long *extrY) {
	int64 uNum,u1Num,uDen2,xNum,yNum; // use int64 to avoid 32 bit integer overflow...
    int64 uDen = 0;

    if (V0On) {
		V0X = V0X << 1;
		V0Y = V0Y << 1;
	} else { // both V0 and V1 are off-curve points, hence calc implied on-curve point
		V0X = V0X + V1X;
		V0Y = V0Y + V1Y;
	}
	if (V2On) {
		V2X = V2X << 1;
		V2Y = V2Y << 1;
	} else { // both V2 and V1 are off-curve points, hence calc implied on-curve point
		V2X = V2X + V1X;
		V2Y = V2Y + V1Y;
	}
	V1X = V1X << 1;
	V1Y = V1Y << 1;
	// at this point we have a quadratic bezier curve V0*(1-u)^2 + 2*V1*(1-u)*u + V2*u^2,
	// with all its control points scaled by 2 to avoid precision loss upon calculating the implied on-curve point
	// its first derivative (with respect to u) is 2*(V0 - 2*V1 + V2)*u + 2*(V1 - V0),
	// which is zero for u = (V0 - V1)/(V0 - 2*V1 + V2)
	// likewise, for 1 - u = (V2 - V1)/(V0 - 2*V1 + V2)
	uDen = V0X - 2*V1X + V2X;
	if (uDen != 0) { // put that back into the eqn. of the quadratic bezier curve
		uNum = V0X - V1X;
		u1Num = V2X - V1X;
		uDen2 = uDen*uDen;
		xNum = V0X*u1Num*u1Num + 2*V1X*u1Num*uNum + V2X*uNum*uNum;
		yNum = V0Y*u1Num*u1Num + 2*V1Y*u1Num*uNum + V2Y*uNum*uNum;
	//	if we're calculating the left extremal point, we floor the result for the probing line
	//	not to start inside the contour as a result of rounding. Starting on the contour should be fine,
	//	as this is handled in CurveTransitions, which does not include the lower end of the interval.
		*extrX = min ? (long)(xNum/uDen2) : (long)((xNum + uDen2 - 1)/uDen2);
	//	symmetrical rounding here
		*extrY = yNum >= 0 ? (long)((yNum + uDen2)/uDen2) : -(long)((uDen2 - yNum)/uDen2);
	} else { // can't solve it
		*extrX = V1X;
		*extrY = V1Y;
	}
} // CalculateXExtremum

void CalculateYExtremum(boolean min, long V0X, long V0Y, boolean V0On, long V1X, long V1Y, long V2X, long V2Y, boolean V2On, long *extrX, long *extrY) {
	int64 uNum,u1Num,uDen2,xNum,yNum; // use int64 to avoid 32 bit integer overflow...
    int64 uDen = 0;

    if (V0On) {
		V0X = V0X << 1;
		V0Y = V0Y << 1;
	} else { // both V0 and V1 are off-curve points, hence calc implied on-curve point
		V0X = V0X + V1X;
		V0Y = V0Y + V1Y;
	}
	if (V2On) {
		V2X = V2X << 1;
		V2Y = V2Y << 1;
	} else { // both V2 and V1 are off-curve points, hence calc implied on-curve point
		V2X = V2X + V1X;
		V2Y = V2Y + V1Y;
	}
	V1X = V1X << 1;
	V1Y = V1Y << 1;
	// at this point we have a quadratic bezier curve V0*(1-u)^2 + 2*V1*(1-u)*u + V2*u^2,
	// with all its control points scaled by 2 to avoid precision loss upon calculating the implied on-curve point
	// its first derivative (with respect to u) is 2*(V0 - 2*V1 + V2)*u + 2*(V1 - V0),
	// which is zero for u = (V0 - V1)/(V0 - 2*V1 + V2)
	// likewise, for 1 - u = (V2 - V1)/(V0 - 2*V1 + V2)
	uDen = V0Y - 2*V1Y + V2Y;
	if (uDen != 0) { // put that back into the eqn. of the quadratic bezier curve
		uNum = V0Y - V1Y;
		u1Num = V2Y - V1Y;
		uDen2 = uDen*uDen;
		xNum = V0X*u1Num*u1Num + 2*V1X*u1Num*uNum + V2X*uNum*uNum;
		yNum = V0Y*u1Num*u1Num + 2*V1Y*u1Num*uNum + V2Y*uNum*uNum;

        *extrY = min ? (long)(yNum/uDen2) : (long)((yNum + uDen2 - 1)/uDen2);
	//	symmetrical rounding here
		*extrX = xNum >= 0 ? (long)((xNum + uDen2)/uDen2) : -(long)((uDen2 - xNum)/uDen2);
	} else { // can't solve it
		*extrX = V1X;
		*extrY = V1Y;
	}
} // CalculateYExtremum

void SetLineToInfinity (int16 extremumNumber, Vector extremum, Vector* C0, Vector* C1)
{
/* extremumKnot = 0 : MinX
   extremumKnot = 1 : MaxX
   extremumKnot = 2 : MinY
   extremumKnot = 3 : MaxY,
    the coordinates returned in C0 and C1 are scaled by 2 */

    switch (extremumNumber) {
	case 0:
        /* line from minX to infinity */
	    C0->x = extremum.x+1;
	    C0->y = extremum.y;
	    C1->x = -32768;
	    C1->y = C0->y-1; // and make sure color transition test line does not align with any straight line in the glyph...
        break;
	case 1:
        /* line from maxX to infinity */
	    C0->x = extremum.x-1;
	    C0->y = extremum.y;
	    C1->x = 32767;
	    C1->y = C0->y-1; // and make sure color transition test line does not align with any straight line in the glyph...
        break;
	case 2:
        /* line from minY to infinity */
	    C0->x = extremum.x;
	    C0->y = extremum.y+1;
	    C1->x = C0->x-1; // and make sure color transition test line does not align with any straight line in the glyph...     
	    C1->y = -32768;
        break;
	case 3:
        /* line from maxY to infinity */
	    C0->x = extremum.x;
	    C0->y = extremum.y-1;
	    C1->x = C0->x-1; // and make sure color transition test line does not align with any straight line in the glyph...     
	    C1->y = 32767;
        break;
	default:  
        /* we should never get in that case */
        FS_ASSERT(FALSE,"fsglue.c, FindExtremaKnot, illegal case");
    }
}

void MinMax3Vectors (Vector A,Vector B,Vector C, Vector *Min, Vector *Max)
{
    *Min = A;
    if (B.x < Min->x) Min->x = B.x;
    if (C.x < Min->x) Min->x = C.x;
    if (B.y < Min->y) Min->y = B.y;
    if (C.y < Min->y) Min->y = C.y;
    *Max = A;
    if (B.x > Max->x) Max->x = B.x;
    if (C.x > Max->x) Max->x = C.x;
    if (B.y > Max->y) Max->y = B.y;
    if (C.y > Max->y) Max->y = C.y;
}

void MinMax2Vectors (Vector A,Vector B, Vector *Min, Vector *Max)
{
    *Min = A;
    if (B.x < Min->x) Min->x = B.x;
    if (B.y < Min->y) Min->y = B.y;
    *Max = A;
    if (B.x > Max->x) Max->x = B.x;
    if (B.y > Max->y) Max->y = B.y;
}

void fsg_CheckOutlineOrientation (fnt_ElementType *pElement)
{
    int32 Contour;
    boolean bMisoriented;
    short knot, n, i, start, end, predKnot, succKnot;
    short extremumKnot[4];
	Vector extremum[4];
    long minX, maxX, minY, maxY;
    long distance0_1, distance0_2, distance0_3;
    uint16 extremaNumber2, extremaNumber3;

    for (Contour = 0; Contour < pElement->nc; Contour++)
	{
        pElement->fc[Contour] = 0;

        start = pElement->sp[Contour];
        end = pElement->ep[Contour];
        
        n = end - start + 1;

        if (n > 2) 
        {
            /* we are not interested in degenerated contours */

            /* look for exterma knots to decide which direction to look to increase our chance of getting the correct result even on bad fonts */

            /* we will look for the following extrema :
               extremumKnot = 0 : MinX
               extremumKnot = 1 : MaxX
               extremumKnot = 2 : MinY
               extremumKnot = 3 : MaxY */

            for (i = 0; i < 4; i++) extremumKnot[i] = -1;
            
            minX = minY = 0x7fffffff;
    	    maxX = maxY = 0x80000000;

	        for (knot = 0; knot < n; knot++) {
                /* look for Min X */
		        if (pElement->oox[start + knot] < minX || 
			        pElement->oox[start + knot] == minX && !pElement->onCurve[extremumKnot[0]] ||  // try to get an on-curve point at same x coord
			        pElement->oox[start + knot] == minX && pElement->onCurve[extremumKnot[0]] && pElement->onCurve[start + knot] && pElement->ooy[start + knot] < pElement->ooy[extremumKnot[0]]) {
					extremumKnot[0] = start + knot;
					minX = pElement->oox[extremumKnot[0]];
					if (pElement->onCurve[extremumKnot[0]]) {
						extremum[0].x = pElement->oox[extremumKnot[0]] << 1;
						extremum[0].y = pElement->ooy[extremumKnot[0]] << 1;
					} else {
						predKnot = extremumKnot[0] == start ? end : extremumKnot[0] - 1;
						succKnot = extremumKnot[0] == end ? start : extremumKnot[0] + 1;
						CalculateXExtremum(true,pElement->oox[predKnot],pElement->ooy[predKnot],pElement->onCurve[predKnot]&true,
											pElement->oox[extremumKnot[0]],pElement->ooy[extremumKnot[0]],
											pElement->oox[succKnot],pElement->ooy[succKnot],pElement->onCurve[succKnot]&true,&extremum[0].x,&extremum[0].y);
					}
				}
                /* look for Max X */
		        if (pElement->oox[start + knot] > maxX || 
			        pElement->oox[start + knot] == maxX && !pElement->onCurve[extremumKnot[1]] ||  // try to get an on-curve point at same x coord
			        pElement->oox[start + knot] == maxX && pElement->onCurve[extremumKnot[1]] && pElement->onCurve[start + knot] && pElement->ooy[start + knot] > pElement->ooy[extremumKnot[1]]) {
					extremumKnot[1] = start + knot;
					maxX = pElement->oox[extremumKnot[1]];
					if (pElement->onCurve[extremumKnot[1]]) {
						extremum[1].x = pElement->oox[extremumKnot[1]] << 1;
						extremum[1].y = pElement->ooy[extremumKnot[1]] << 1;
					} else {
						predKnot = extremumKnot[1] == start ? end : extremumKnot[1] - 1;
						succKnot = extremumKnot[1] == end ? start : extremumKnot[1] + 1;
						CalculateXExtremum(false,pElement->oox[predKnot],pElement->ooy[predKnot],pElement->onCurve[predKnot]&true,
											pElement->oox[extremumKnot[1]],pElement->ooy[extremumKnot[1]],
											pElement->oox[succKnot],pElement->ooy[succKnot],pElement->onCurve[succKnot]&true,&extremum[1].x,&extremum[1].y);
		        		}
				}
                /* look for Min Y */
		        if (pElement->ooy[start + knot] < minY || 
			        pElement->ooy[start + knot] == minY && !pElement->onCurve[extremumKnot[2]] ||  // try to get an on-curve point at same y coord
			        pElement->ooy[start + knot] == minY && pElement->onCurve[extremumKnot[2]] && pElement->onCurve[start + knot] && pElement->oox[start + knot] > pElement->oox[extremumKnot[2]]) {
					extremumKnot[2] = start + knot;
					minY = pElement->ooy[extremumKnot[2]];
					if (pElement->onCurve[extremumKnot[2]]) {
						extremum[2].x = pElement->oox[extremumKnot[2]] << 1;
						extremum[2].y = pElement->ooy[extremumKnot[2]] << 1;
					} else {
						predKnot = extremumKnot[2] == start ? end : extremumKnot[2] - 1;
						succKnot = extremumKnot[2] == end ? start : extremumKnot[2] + 1;
						CalculateYExtremum(true,pElement->oox[predKnot],pElement->ooy[predKnot],pElement->onCurve[predKnot]&true,
											pElement->oox[extremumKnot[2]],pElement->ooy[extremumKnot[2]],
											pElement->oox[succKnot],pElement->ooy[succKnot],pElement->onCurve[succKnot]&true,&extremum[2].x,&extremum[2].y);
					}
				}
                /* look for Max Y */
		        if (pElement->ooy[start + knot] > maxY || 
			        pElement->ooy[start + knot] == maxY && !pElement->onCurve[extremumKnot[3]] ||  // try to get an on-curve point at same y coord
			        pElement->ooy[start + knot] == maxY && pElement->onCurve[extremumKnot[3]] && pElement->onCurve[start + knot] && pElement->oox[start + knot] < pElement->oox[extremumKnot[3]]) {
					extremumKnot[3] = start + knot;
					maxY = pElement->ooy[extremumKnot[3]];
					if (pElement->onCurve[extremumKnot[3]]) {
						extremum[3].x = pElement->oox[extremumKnot[3]] << 1;
						extremum[3].y = pElement->ooy[extremumKnot[3]] << 1;
					} else {
						predKnot = extremumKnot[3] == start ? end : extremumKnot[3] - 1;
						succKnot = extremumKnot[3] == end ? start : extremumKnot[3] + 1;
						CalculateYExtremum(false,pElement->oox[predKnot],pElement->ooy[predKnot],pElement->onCurve[predKnot]&true,
											pElement->oox[extremumKnot[3]],pElement->ooy[extremumKnot[3]],
											pElement->oox[succKnot],pElement->ooy[succKnot],pElement->onCurve[succKnot]&true,&extremum[3].x,&extremum[3].y);
					}
				}
	        }

            /* diagonal distance, we don't need a precise distance */

            distance0_1 = MABS(pElement->oox[extremumKnot[1]] - pElement->oox[extremumKnot[0]]) + MABS(pElement->ooy[extremumKnot[1]] - pElement->ooy[extremumKnot[0]]);
            distance0_2 = MABS(pElement->oox[extremumKnot[2]] - pElement->oox[extremumKnot[0]]) + MABS(pElement->ooy[extremumKnot[2]] - pElement->ooy[extremumKnot[0]]);
            distance0_3 = MABS(pElement->oox[extremumKnot[3]] - pElement->oox[extremumKnot[0]]) + MABS(pElement->ooy[extremumKnot[3]] - pElement->ooy[extremumKnot[0]]);

            if (distance0_2 > distance0_3)
            {
                /* we will look at MinY */
                extremaNumber2 = 2;
                if (distance0_3 > distance0_1)
                {
                    /* we will look then at MaxY */
                    extremaNumber3 = 3;
                } else {
                    /* we will look then at MaxX */
                    extremaNumber3 = 1;
                }
            } else {
                /* we will look at MaxY */
                extremaNumber2 = 3;
                if (distance0_2 > distance0_1)
                {
                    /* we will look then at MinY */
                    extremaNumber3 = 2;
                } else {
                    /* we will look then at MaxX */
                    extremaNumber3 = 1;
                }
            }

            bMisoriented = Misoriented(Contour, 0 /* MinX */, extremumKnot[0], extremum[0], pElement);

            /* look in a second direction to check if same result 
               this additional work help weed out problems with bad fonts having self-intersecting
               or overlapping outlines */
            if (bMisoriented != Misoriented(Contour, extremaNumber2, extremumKnot[extremaNumber2], extremum[extremaNumber2], pElement))
            {
                /* we need to look in a third direction */
                bMisoriented = Misoriented(Contour, extremaNumber3, extremumKnot[extremaNumber3], extremum[extremaNumber3], pElement);
            }

                // at this point we store the orientation of the original component (original in the sense of before the composite code potentially
                // applies a mirroring), such that the concertina code can work on the component w/o having to know about composite transformations
                if (bMisoriented) pElement->fc[Contour] |= OUTLINE_MISORIENTED;
        }
    }
}

boolean Misoriented(int32 contour, uint16 extremumNumber, short extremumKnot, Vector extremum, fnt_ElementType *pElement)
/* we will check the coutour orientation at the following extrema :
   extremumKnot = 0 : MinX
   extremumKnot = 1 : MaxX
   extremumKnot = 2 : MinY
   extremumKnot = 3 : MaxY */

{
	LinkColor color,orientation;
	short predKnot,cont,knot,start,iter,end,n;
	long parity;
	Vector V[3],D[2],C[2],W[3],Wi;
	boolean on[3];

    short dirChange = 0;      
    
	start = pElement->sp[contour];
	end = pElement->ep[contour];
	n = end - start + 1;

	// here we determine the straight line that runs from the extreme of the contour to infinity, to be used below.
    SetLineToInfinity(extremumNumber, extremum, &C[0], &C[1]);
	
	// find out the current orientation of the contour
	// to do so first determine what kinds of turns we make at each knot
	orientation = linkBlack; // assume as default

    knot = extremumKnot - start;
    predKnot = (knot+n-1)%n;

    V[0].x = pElement->oox[start+predKnot]; V[1].x = pElement->oox[start+knot];
	V[0].y = pElement->ooy[start+predKnot]; V[1].y = pElement->ooy[start+knot];
	D[0] = SubV(V[1],V[0]);
	for (iter = 0; iter < n && !dirChange; iter++) {
		V[2].x = pElement->oox[start + (knot + 1)%n];
		V[2].y = pElement->ooy[start + (knot + 1)%n];
		if (NotSameKnot(V[1],V[2])) {
    		D[1] = SubV(V[2],V[1]);
		    dirChange = ComputeSign(D[0].x, D[0].y, D[1].x, D[1].y);
		    V[0] = V[1]; V[1] = V[2]; D[0] = D[1];
        }
        knot = (knot + 1)%n;
	}

    if (iter < n && dirChange > 0)
    {
        orientation = linkWhite; /* counter clockwise */
    }
	
	// now find out what the orientation of the contour should really be
	// to do so we intersect the above probing line with all other contours.
	// If the number of intersections is odd, we have started inside, else outside.
	// if this doesn't correspond to the contour orientation determined above, then we're misoriented.
	// The loops below follow the same pattern used for Contour::Draw but are separate due to different underlying data structure.
	// Notice that this doesn't work for overlapping or self-intersecting contours. They're against the TT laws...
	parity = 0;
	for (cont = 0; cont < pElement->nc; cont++) {
        if (cont != contour) 
        /* we are not interested by the intersections of the contour with itself, optimization */
        {
		    start = pElement->sp[cont];
		    end = pElement->ep[cont];
		    n = end - start + 1;
		    W[1].x = pElement->oox[start] << 1;
		    W[1].y = pElement->ooy[start] << 1;
		    on[1] = pElement->onCurve[start];
		    if (!on[1]) { // we start amidst a curve => get curve start point
			    W[0].x = pElement->oox[end] << 1;
			    W[0].y = pElement->ooy[end] << 1;
			    on[0] = pElement->onCurve[end];
			    if (!on[0]) { // curve start point is implied on-curve point => compute
				    W[0] = ShrV(AddV(W[0],W[1]),1);
			    }
		    }
		    knot = start;
		    do {
			    knot = knot == end ? start : knot + 1;
			    W[2].x = pElement->oox[knot] << 1;
			    W[2].y = pElement->ooy[knot] << 1;
			    on[2] = pElement->onCurve[knot];
			    switch (on[1] << 1 | on[2]) {
				    case 3: // on---on => start and end a line => intersect with line
					    if (NotSameKnot(W[1],W[2]))
                        {
                        /* check bounding box before computing the intersection for performance */
							if (CheckBoundingBoxSegment(C[0],W[1],W[2],extremumNumber))
							{
                                parity += CurveTransitionsSegment(C[0],C[1],W[1],W[2]); // repeating first vertex makes Bzier curve a line...
							}
                        }
					    break;
				    case 2: // on---off => start a curve => intersect with nothing
					    W[0] = W[1];
					    break;
				    case 1: // off---on => end a curve => intersect with the curve
					    if (NotSameKnot(W[0],W[2])) 
                        {
                            /* check bounding box before computing the intersection for performance */
							if (CheckBoundingBoxCurve(C[0],W[0],W[1],W[2],extremumNumber))
							{
                                parity += CurveTransitions(C[0],C[1],W[0],W[1],W[2]);
							}
                        }
					    break;
				    case 0: // off---off => end a curve => intersect with the curve; then start a curve => intersect with nothing
					    Wi = ShrV(AddV(W[1],W[2]),1);
					    if (NotSameKnot(W[0],Wi))
                        {
							if (CheckBoundingBoxCurve(C[0],W[0],W[1],Wi,extremumNumber))
							{
                                parity += CurveTransitions(C[0],C[1],W[0],W[1],Wi);
							}
                        }
					    W[0] = Wi;
					    break;
			    }
			    W[1] = W[2]; on[1] = on[2];
		    } while (knot != start);
        }
	}
	color = parity & 1 ? linkBlack : linkWhite;

	return color == orientation; // cw (black) contours should have white to their left, and v.v., else they're oriented the wrong way round
} // Misoriented

#ifdef FSCFG_SUBPIXEL
FS_PUBLIC void  fsg_CopyFontProgramResults(
	void *              pvGlobalGS,
	void *              pvGlobalGSSubPixel)
{
	fnt_GlobalGraphicStateType *globalGS, *globalGSSubPixel;
	int32 i;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;
	globalGSSubPixel = (fnt_GlobalGraphicStateType *)pvGlobalGSSubPixel;

	for (i = 0; i < globalGS->maxp->maxFunctionDefs; i++)
	{
		globalGSSubPixel->funcDef[i] = globalGS->funcDef[i];

	}

    globalGSSubPixel->instrDefCount = globalGS->instrDefCount;

	for (i = 0; i < globalGS->instrDefCount; i++)
	{
		globalGSSubPixel->instrDef[i] = globalGS->instrDef[i];

	}
	globalGSSubPixel->subPixelCompatibilityFlags = globalGS->subPixelCompatibilityFlags;

	globalGSSubPixel->numDeltaFunctionsDetected = globalGS->numDeltaFunctionsDetected;
	for (i = 0; i < globalGSSubPixel->numDeltaFunctionsDetected; i++)
		globalGSSubPixel->deltaFunction[i] = globalGS->deltaFunction[i];
}


FS_PUBLIC void  fsg_ScaleToCompatibleWidth (
	fsg_WorkSpaceAddr * pWorkSpaceAddr,
    Fixed   fxCompatibleWidthScale)
{
	fnt_ElementType *   pElement;

	pElement = pWorkSpaceAddr->pGlyphElement;
    scl_ScaleToCompatibleWidth(pElement, fxCompatibleWidthScale);
}


FS_PUBLIC void  fsg_AdjustCompatibleMetrics (
	fsg_WorkSpaceAddr * pWorkSpaceAddr,
    F26Dot6   horTranslation,
    F26Dot6   newDevAdvanceWidthX)
{
	fnt_ElementType *   pElement;

	pElement = pWorkSpaceAddr->pGlyphElement;
    scl_AdjustCompatibleMetrics(pElement, horTranslation, newDevAdvanceWidthX);
}

FS_PUBLIC void  fsg_CalcDevHorMetrics(
	fsg_WorkSpaceAddr * pWorkSpaceAddr,
	F26Dot6 *           pDevAdvanceWidthX,
	F26Dot6 *           pDevLeftSideBearingX,
	F26Dot6 *           pDevRightSideBearingX)
{
    fnt_ElementType *   pElement;

	pElement = pWorkSpaceAddr->pGlyphElement;

    scl_CalcDevHorMetrics(pElement, pDevAdvanceWidthX, pDevLeftSideBearingX, pDevRightSideBearingX);

}

FS_PUBLIC void  fsg_CalcDevNatHorMetrics(
	fsg_WorkSpaceAddr * pWorkSpaceAddr,
	F26Dot6 *           pDevAdvanceWidthX,
	F26Dot6 *           pDevLeftSideBearingX,
	F26Dot6 *           pDevRightSideBearingX,
	F26Dot6 *           pNatAdvanceWidthX,
	F26Dot6 *           pNatLeftSideBearingX,
	F26Dot6 *           pNatRightSideBearingX)
{
    fnt_ElementType *   pElement;

	pElement = pWorkSpaceAddr->pGlyphElement;

    scl_CalcDevNatHorMetrics(pElement, pDevAdvanceWidthX, pDevLeftSideBearingX, pDevRightSideBearingX, pNatAdvanceWidthX, pNatLeftSideBearingX, pNatRightSideBearingX);

}

#endif // FSCFG_SUBPIXEL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\fondrv\tt\scaler\fserror.h ===
/*
    File:       fserror.h

    Contains:   xxx put contents here (or delete the whole line) xxx

    Written by: xxx put name of writer here (or delete the whole line) xxx

    Copyright:  c 1989-1990 by Apple Computer, Inc., all rights reserved.
				(c) 1989-1997. Microsoft Corporation, all rights reserved.

    Change History (most recent first):

		<>      10/14/97    CB      error if FDEF/IDEF in GlyphProgram
 		 <>     04/30/97    CB      ClaudeBe, missing ENDF, infinite loop/recursion
		 <>     03/1/97    CB      ClaudeBe, div by 0 in hinting error
        <4>     7/13/90    MR      made endif at bottom use a comment
         <3>      5/3/90    RB      Changed char to int8 for variable type.   Now it is legal to
                                    pass in zero as the address of memory when a piece of
         <2>     2/27/90    CL      New error code for missing but needed table. (0x1409)
       <3.1>    11/14/89    CEL     Now it is legal to pass in zero as the address of memory when a
                                    piece of the sfnt is requested by the scaler. If this happens
                                    the scaler will simply exit with an error code !
       <3.0>     8/28/89    sjk     Cleanup and one transformation bugfix
       <2.2>     8/14/89    sjk     1 point contours now OK
       <2.1>      8/8/89    sjk     Improved encryption handling
       <2.0>      8/2/89    sjk     Just fixed EASE comment
       <1.5>      8/1/89    sjk     Added composites and encryption. Plus some enhancements.
       <1.4>     6/13/89    SJK     Comment
       <1.3>      6/2/89    CEL     16.16 scaling of metrics, minimum recommended ppem, point size 0
                                    bug, correct transformed integralized ppem behavior, pretty much
                                    so
       <1.2>     5/26/89    CEL     EASE messed up on "c" comments
      <,1.1>  5/26/89    CEL     Integrated the new Font Scaler 1.0 into Spline Fonts
       <1.0>     5/25/89    CEL     Integrated 1.0 Font scaler into Bass code for the first time.

    To Do:
*/
/************/
/** ERRORS **/
/************/
#define NO_ERR                      0x0000
#define NULL_KEY                    0x0000


/** EXTERNAL INTERFACE PACKAGE **/
#define NULL_KEY_ERR                0x1001
#define NULL_INPUT_PTR_ERR          0x1002
#define NULL_MEMORY_BASES_ERR       0x1003
#define VOID_FUNC_PTR_BASE_ERR      0x1004  /* No longer used */
#define OUT_OFF_SEQUENCE_CALL_ERR   0x1005
#define BAD_CLIENT_ID_ERR           0x1006
#define NULL_SFNT_DIR_ERR           0x1007
#define NULL_SFNT_FRAG_PTR_ERR      0x1008
#define NULL_OUTPUT_PTR_ERR         0x1009
#define INVALID_GLYPH_INDEX         0x100A
#define BAND_TOO_BIG_ERR            0x100B  /* possible with FindBandingSize */
#define INVALID_CHARCODE_ERR        0x100C

/* fnt_execute */
#define UNDEFINED_INSTRUCTION_ERR   0x1101
#define TRASHED_MEM_ERR             0x1102
#define DIV_BY_0_IN_HINTING_ERR     0x1103
#define MISSING_ENDF_ERR			0x1104
#define MISSING_EIF_ERR				0x1105
#define INFINITE_RECURSION_ERR		0x1106 
#define INFINITE_LOOP_ERR			0x1107 
#define FDEF_IN_GLYPHPGM_ERR		0x1108 
#define IDEF_IN_GLYPHPGM_ERR		0x1109 

#define TRACE_FAILURE_ERR			0x110A  /* can be used by a trace function to notify of an 
                                               internal error (memory allocation failed,...) */
#define JUMP_BEFORE_START_ERR	    0x110B
#define INSTRUCTION_ERR             0x110C  /* can be used by a trace function to notify the discovery of an error */

#define RAW_NOT_IN_GLYPHPGM_ERR		0x110D 

#define SECURE_STACK_UNDERFLOW      0x1110
#define SECURE_STACK_OVERFLOW       0x1111
#define SECURE_POINT_OUT_OF_RANGE   0x1112
#define SECURE_INVALID_STACK_ACCESS 0x1113
#define SECURE_FDEF_OUT_OF_RANGE    0x1114
#define SECURE_ERR_FUNCTION_NOT_DEFINED    0x1115
#define SECURE_INVALID_ZONE         0x1116
#define SECURE_INST_OPCODE_TO_LARGE 0x1117
#define SECURE_EXCEEDS_INSTR_DEFS_IN_MAXP  0x1118
#define SECURE_STORAGE_OUT_OF_RANGE 0x1119
#define SECURE_CONTOUR_OUT_OF_RANGE 0x111A
#define SECURE_CVT_OUT_OF_RANGE     0x111B
#define SECURE_UNITIALIZED_ZONE     0x111C


/* fsg_CalculateBBox */
#define POINT_MIGRATION_ERR         0x1201

/* sc_ScanChar */
#define BAD_START_POINT_ERR         0x1301
#define SCAN_ERR                    0x1302
#define BAD_SCAN_KIND_ERR           0x1303
#define BAD_POINT_INDEX_ERR         0x1304

#define SMART_DROP_OVERFLOW_ERR     0x1305


/** SFNT DATA ERROR and errors in sfnt.c **/
#define SFNT_DATA_ERR               0x1400
#define POINTS_DATA_ERR             0x1401
#define INSTRUCTION_SIZE_ERR        0x1402
#define CONTOUR_DATA_ERR            0x1403
#define GLYPH_INDEX_ERR             0x1404
#define BAD_MAGIC_ERR               0x1405
#define OUT_OF_RANGE_SUBTABLE       0x1406
#define UNKNOWN_COMPOSITE_VERSION   0x1407
#define CLIENT_RETURNED_NULL        0x1408
#define MISSING_SFNT_TABLE          0x1409
#define UNKNOWN_CMAP_FORMAT         0x140A
#define BAD_MAXP_DATA               0x140B
#define SFNT_RECURSIVE_COMPOSITE_ERR 0x140C
#define GLYF_TABLE_CORRUPTION_ERR   0x140D
#define BAD_UNITSPEREM_ERR          0x140E
#define BAD_NUMLONGHORMETRICS_ERR   0x140F
#define COMPOSITE_INVALID_GLYPH_INDEX  0x1410

/* spline call errors */
#define BAD_CALL_ERR                0x1500

#define TRASHED_OUTLINE_CACHE       0x1600

/* gray scale errors */
#define BAD_GRAY_LEVEL_ERR          0x1701
#define GRAY_OLD_BANDING_ERR        0x1703
#define GRAY_NO_OUTLINE_ERR         0x1704

/* embedded bitmap (sbit) errors */
#define SBIT_COMPONENT_MISSING_ERR  0x1801
#define SBIT_ROTATION_ERR           0x1802
#define SBIT_BANDING_ERR            0x1803
#define SBIT_OUTLINE_CACHE_ERR      0x1804

/* new transformation errors : */
#define TRAN_NULL_TRANSFORM_ERR     0x1901

/************ For Debugging *************/

#ifdef XXX
#define DEBUG_ON
pascal  Debug ()                     /* User break drop into Macsbug */
#ifdef  DEBUG_ON
extern  0xA9FF;
#else
{
    ;
}
#endif

#ifndef DEBUGGER
pascal void DEBUGGER(void) = 0xA9FF; 
#endif

#ifdef  LEAVEOUT
#ifndef DEBUGSTR
pascal  void DEBUGSTR (aString) int8 *aString; extern 0xABFF;
int8    *c2pstr ();
#define BugInfo( aString) DEBUGSTR( c2pstr(aString))
#endif
#endif

#endif  /* XXX */
/****************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\fondrv\tt\scaler\fscaler.h ===
#ifdef __cplusplus
extern "C" {
#endif

/*
	File:       fscaler.h

	Contains:   xxx put contents here (or delete the whole line) xxx

	Written by: xxx put name of writer here (or delete the whole line) xxx

	Copyright:  (c) 1987-1990, 1992 by Apple Computer, Inc., all rights reserved.
				(c) 1989-1999. Microsoft Corporation, all rights reserved.

	Change History (most recent first):

				 7/10/99  BeatS		Add support for native SP fonts, vertical RGB
		  <>    10/14/97    CB      move usOverScale to fs_NewTransformation
		<9+>     7/17/90    MR      Conditionalize names in FSInput
		 <9>     7/14/90    MR      rename SQRT2 to FIXEDSQRT2, removed specificID and lowestRecPPEM
									from FSInfo
		 <8>     7/13/90    MR      FSInput now has a union to save space, points to matrix instead
									of storing it
		 <6>     6/21/90    MR      Change fillFunc to ReleaseSfntFrag
		 <5>      6/5/90    MR      remove readmvt and mapcharcodes
		 <4>      5/3/90    RB      Added memory area for new scan converter. MIKE REED - Removed
									.error from fsinfo structure. Added MapCharCodes and ReadMVT
									calls.
		 <3>     3/20/90    CL      New comment style for BBS. 
		 <2>     2/27/90    CL      New CharToIndexMap Table format.
	   <3.5>    11/15/89    CEL     Placed an ifdef around inline MPW calls to the trap. This makes
									it easier to compile for skia and the likes who do not use the
									MPW compiler.
	   <3.4>    11/14/89    CEL     Left Side Bearing should work right for any transformation. The
									phantom points are in, even for components in a composite glyph.
									They should also work for transformations. Device metric are
									passed out in the output data structure. This should also work
									with transformations. Another leftsidebearing along the advance
									width vector is also passed out. whatever the metrics are for
									the component at it's level. Instructions are legal in
									components. Instructions are legal in components. Five
									unnecessary element in the output data structure have been
									deleted. (All the information is passed out in the bitmap data
									structure) fs_FindBMSize now also returns the bounding box.
	   <3.3>     9/27/89    CEL     Took out devAdvanceWidth & devLeftSideBearing.
	   <3.2>     9/25/89    CEL     Took out Mac specific functions.
	   <3.1>     9/15/89    CEL     Re-working dispatcher.
	   <3.0>     8/28/89    sjk     Cleanup and one transformation bugfix
	   <2.2>     8/14/89    sjk     1 point contours now OK
	   <2.1>      8/8/89    sjk     Improved encryption handling
	   <2.0>      8/2/89    sjk     Just fixed EASE comment
	   <1.5>      8/1/89    sjk     Added composites and encryption. Plus some enhancements.
	   <1.4>     6/13/89    SJK     Comment
	   <1.3>      6/2/89    CEL     16.16 scaling of metrics, minimum recommended ppem, point size 0
									bug, correct transformed integralized ppem behavior, pretty much
									so
	   <1.2>     5/26/89    CEL     EASE messed up on "c" comments
	  <,1.1>  5/26/89    CEL     Integrated the new Font Scaler 1.0 into Spline Fonts
	   <1.0>     5/25/89    CEL     Integrated 1.0 Font scaler into Bass code for the first time.

	To Do:
*/

#include    "fscdefs.h"
#include    "fnt.h"

/* QuickDraw Types */

#ifndef _Quickdraw_
#ifndef __QUICKDRAW__   
	typedef struct BitMap {
		char* baseAddr;
		int16 rowBytes;
		Rect bounds;
	} BitMap;
#endif
#endif

#define MEMORYFRAGMENTS 9           /* extra memory base for overscaled bitmap */

#define NONVALID        0xffff

/* For the flags field in the flags field */

/* set on 68020, do not set on 68000 */
#define READ_NONALIGNED_SHORT_IS_OK 0x0001          /* set when calling fs_OpenFonts() */
/* set on 68020, do not set on 68000 */
#define READ_NONALIGNED_LONG_IS_OK  0x0002          /* set when calling fs_OpenFonts() */

#ifdef FSCFG_SUBPIXEL
/* For the SubPixel flag field */
#define SP_SUB_PIXEL			0x0001          /* set when calling fs_NewTransformation() */
#define SP_COMPATIBLE_WIDTH		0x0002          /* set when calling fs_NewTransformation() */
#define SP_VERTICAL_DIRECTION	0x0004          /* set when calling fs_NewTransformation() */
#define SP_BGR_ORDER			0x0008          /* set when calling fs_NewTransformation() */
#endif // FSCFG_SUBPIXEL

typedef struct {
	vectorType      advanceWidth, leftSideBearing;
	vectorType      leftSideBearingLine, devLeftSideBearingLine;/* along AW line */
	vectorType      devAdvanceWidth, devLeftSideBearing;
} metricsType;

typedef struct {
	vectorType      advanceHeight, topSideBearing;
	vectorType      topSideBearingLine, devTopSideBearingLine;/* along AH line */
	vectorType      devAdvanceHeight, devTopSideBearing;
} verticalMetricsType;

#define FS_MEMORY_SIZE  int32

/*
 * Output data structure to the Font Scaler.
 */
typedef struct {
	FS_MEMORY_SIZE  memorySizes[MEMORYFRAGMENTS];

	uint16          glyphIndex;
	uint16          numberOfBytesTaken; /* from the character code */

	metricsType     metricInfo;
	BitMap          bitMapInfo;

	/* Spline Data */
	int32           outlineCacheSize;
	uint16          outlinesExist;
	uint16          numberOfContours;
	F26Dot6         *xPtr, *yPtr;
	int16           *startPtr;
	int16           *endPtr;
	uint8           *onCurve;
	/* End of spline data */

	/* Only of interest to editors */
	F26Dot6         *scaledCVT;

	/* embedded bitmap return values */
	uint16          usBitmapFound;

	/* vertical metrics */
	verticalMetricsType     verticalMetricInfo;

	/* resulting number of gray levels, 0 means black/white, 1 bit per pixel,
	   (grayscale bitmap are 1 byte per pixel)
	   the number of level you receive is not necessarily what you ask for.
	   If there is no embedded gray bitmap :
			usOverscale 2 -> usGrayLevels 5,
			usOverscale 4 -> usGrayLevels 17,
			usOverscale 8 -> usGrayLevels 65,
	   If an embedded gray bitmap is present in the font, the embedded bitmap
	   will be selected before a gray bitmap generated with an higher overscale.
	   If you are unhappy with the number of gray levels (usGrayLevels) you can force
	   the embedded bitmap off by setting bNoEmbeddedBitmap to TRUE  */
	uint16          usGrayLevels;            
#ifdef FSCFG_SUBPIXEL_STANDALONE // B.St.
	BitMap			overscaledBitmapInfo;
#endif
	uint8			*fc;         /* contour flags, one byte for every contour */
} fs_GlyphInfoType;

/*
 * Input data structure to the Font Scaler.
 *
 * styleFunc is not supported in this version of the Font Scalar. Should be set to NULL.
 *
 */

#ifndef UNNAMED_UNION

typedef struct {
	Fixed                   version;
	char*                   memoryBases[MEMORYFRAGMENTS];
	int32                   *sfntDirectory; 
	GetSFNTFunc             GetSfntFragmentPtr; /* (clientID, offset, length) */
	ReleaseSFNTFunc         ReleaseSfntFrag;
	ClientIDType            clientID; /* client private id/stamp (eg. handle for the sfnt) */

	union {
		struct {
			uint16          platformID;
			uint16          specificID;
		} newsfnt;
		struct {
			Fixed           pointSize;
			int16           xResolution;
			int16           yResolution;
			Fixed           pixelDiameter;      /* compute engine char from this */
			transMatrix*    transformMatrix;
			FntTraceFunc    traceFunc;
			uint16          usOverScale;            /* outline magnification */
            /* embolding simulation */
			uint16          usEmboldWeightx;        /* scaling factor in x between 0 and 40 (20 means 2% fo the height) */
			uint16          usEmboldWeighty;        /* scaling factor in y between 0 and 40 (20 means 2% fo the height) */
			int32           lDescDev;               /* descender in device metric, used for clipping */
			boolean         bBitmapEmboldening;
#ifdef FSCFG_SUBPIXEL
			uint16          flSubPixel;
#endif // FSCFG_SUBPIXEL
			boolean         bHintAtEmSquare;        /* hint at the design resolution, this flag is used for sub-pixel position
													   or text animation where we want to turn off gridfitting hinting
													   but for fonts where glyphs are build by hinting, we still want the
													   glyph shape to be correct */
		} newtrans;
		struct {
			uint16          characterCode;
			uint16          glyphIndex;
			boolean         bMatchBBox;             /* force bounding box match */
			boolean         bNoEmbeddedBitmap;      /* disable the embedded bitmap */			
		} newglyph;
		struct {
			void            (*styleFunc) (fs_GlyphInfoType*);
			FntTraceFunc    traceFunc;
			boolean         bSkipIfBitmap;
		} gridfit;
		int32*  outlineCache;
		struct {                                    /* for fs_FindBandingSize */
			uint16          usBandType;             /* old, small or fast */
			uint16          usBandWidth;            /* number of scanlines */
			int32*          outlineCache;           /* cacheing works with banding */
		} band;
		struct {
			int16           bottomClip;
			int16           topClip;
			int32*          outlineCache;
		} scan;
	} param;
} fs_GlyphInputType;

#else

typedef struct {
	Fixed                   version;
	char*                   memoryBases[MEMORYFRAGMENTS];
	int32                   *sfntDirectory; 
	GetSFNTFunc             GetSfntFragmentPtr; /* (clientID, offset, length) */
	ReleaseSFNTFunc         ReleaseSfntFrag;
	ClientIDType            clientID; /* client private id/stamp (eg. handle for the sfnt) */

	union {
		struct {
			uint16          platformID;
			uint16          specificID;
		};
		struct {
			Fixed           pointSize;
			int16           xResolution;
			int16           yResolution;
			Fixed           pixelDiameter;      /* compute engine char from this */
			transMatrix*    transformMatrix;
			FntTraceFunc    tracePreProgramFunc;
			uint16          usOverScale;            /* outline magnification */
            /* embolding simulation */
			uint16          usEmboldWeightx;        /* scaling factor in x between 0 and 40 (20 means 2% fo the height) */
			uint16          usEmboldWeighty;        /* scaling factor in y between 0 and 40 (20 means 2% fo the height) */
			int32           lDescDev;               /* descender in device metric, used for clipping */
			boolean         bBitmapEmboldening;
#ifdef FSCFG_SUBPIXEL
			uint16          flSubPixel;
#endif // FSCFG_SUBPIXEL
			boolean         bHintAtEmSquare;        /* hint at the design resolution, this flag is used for sub-pixel position
													   or text animation where we want to turn off gridfitting hinting
													   but for fonts where glyphs are build by hinting, we still want the
													   glyph shape to be correct */
		};
		struct {
			uint16          characterCode;
			uint16          glyphIndex;
			boolean         bMatchBBox;             /* force bounding box match */
			boolean         bNoEmbeddedBitmap;      /* disable the embedded bitmap */			
		};
		struct {
			void            (*styleFunc) (fs_GlyphInfoType*);
			FntTraceFunc    traceGridFitFunc;
			boolean         bSkipIfBitmap;
		};
		int32*              outlineCache1;
		struct {                                    /* for fs_FindBandingSize */
			uint16          usBandType;             /* old, small or fast */
			uint16          usBandWidth;            /* number of scanlines */
			int32*          outlineCache3;          /* cacheing works with banding */
		};
		struct {
			int16           bottomClip;
			int16           topClip;
			int32*          outlineCache2;
		};
	};
} fs_GlyphInputType;

#endif      /* unnamed union */

#ifndef FIXEDSQRT2
#define FIXEDSQRT2 0x00016A0A
#endif

/* Font scaler trap selctors */
#define OUTLINEFONTTRAP     0xA854
#define FS_OPENFONTS        0x8000
#define FS_INITIALIZE       0x8001
#define FS_NEWSFNT          0x8002
#define FS_NEWTRANS         0x8003
#define FS_NEWGLYPH         0x8004
#define FS_GETAW            0x8005
#define FS_GRIDFITT         0x8006
#define FS_NOGRIDFITT       0x8007
#define FS_FINDBMSIZE       0x8008
#define FS_SIZEOFOUTLINES   0x8009
#define FS_SAVEOUTLINES     0x800a
#define FS_RESTOREOUTLINES  0x800b
#define FS_CONTOURSCAN      0x800c
#define FS_CLOSE            0x800d
#define FS_READMVT          0x800e
#define FS_MAPCHAR_CODES    0x800f

#ifndef FS_ENTRY
#define FS_ENTRY int32
#endif

#ifdef MACINIT
extern FS_ENTRY fs__OpenFonts (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
	= {0x303C,FS_OPENFONTS,0xA854};
extern FS_ENTRY fs__Initialize (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
	= {0x303C,FS_INITIALIZE,0xA854};
extern FS_ENTRY fs__NewSfnt (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
	= {0x303C,FS_NEWSFNT,0xA854};
extern FS_ENTRY fs__NewTransformation (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
	= {0x303C,FS_NEWTRANS,0xA854};
extern FS_ENTRY fs__NewGlyph (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
	= {0x303C,FS_NEWGLYPH,0xA854};
extern FS_ENTRY fs__GetAdvanceWidth (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
	= {0x303C,FS_GETAW,0xA854};
extern FS_ENTRY fs__ContourGridFit (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
	= {0x303C,FS_GRIDFITT,0xA854};
extern FS_ENTRY fs__ContourNoGridFit (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
	= {0x303C,FS_NOGRIDFITT,0xA854};
extern FS_ENTRY fs__FindBitMapSize (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
	= {0x303C,FS_FINDBMSIZE,0xA854};
extern FS_ENTRY fs__FindBandingSize (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
	= {0x303C,FS_FINDBMSIZE,0xA854};

/* these three optional calls are for caching the outlines */
extern FS_ENTRY fs__SizeOfOutlines (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
	= {0x303C,FS_SIZEOFOUTLINES,0xA854};
extern FS_ENTRY fs__SaveOutlines (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
	= {0x303C,FS_SAVEOUTLINES,0xA854};
extern FS_ENTRY fs__RestoreOutlines (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
	= {0x303C,FS_RESTOREOUTLINES,0xA854};

extern FS_ENTRY fs__ContourScan (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
	= {0x303C,FS_CONTOURSCAN,0xA854};
extern FS_ENTRY fs__CloseFonts (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
	= {0x303C,FS_CLOSE,0xA854};

#else

/*** Direct Calls to Font Scaler Client Interface, for Clients not using the trap mechanism ***/

extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_OpenFonts (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr);
extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_Initialize (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr);
extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_NewSfnt (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr);
extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_NewTransformation (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr);
extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_NewTransformNoGridFit (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr);
extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_NewGlyph (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr);
extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_GetAdvanceWidth (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr);
extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_ContourGridFit (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr);
extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_ContourNoGridFit (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr);
extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_FindBitMapSize (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr);
extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_FindBandingSize (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr);

/* these three optional calls are for caching the outlines */
extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_SizeOfOutlines (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr);
extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_SaveOutlines (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr);
extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_RestoreOutlines (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr);

extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_ContourScan (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr);
extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_CloseFonts (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr);

#endif

#ifdef FSCFG_NO_INITIALIZED_DATA
FS_PUBLIC void FS_ENTRY_PROTO fs_InitializeData (void);
#endif

/*** Rasterizer Helper Functions ***/

extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_GetScaledAdvanceWidths (
	fs_GlyphInputType * inputPtr,
	uint16              usFirstGlyph,
	uint16              usLastGlyph,
	int16 *             psGlyphWidths);

typedef struct {
	int16 x;
	int16 y;
} shortVector;

extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_GetScaledAdvanceHeights (
	fs_GlyphInputType * inputPtr,
	uint16              usFirstGlyph,
	uint16              usLastGlyph,
	shortVector *       psvAdvanceHeights);

extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_GetGlyphIDs (
	fs_GlyphInputType * inputPtr,
	uint16	            usCharCount,
	uint16	            usFirstChar,
	uint16 *	        pusCharCode,
	uint16 *	        pusGlyphID);

extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_Win95GetGlyphIDs (
	uint8 *             pbyCmapSubTable,
	uint16	            usCharCount,
	uint16	            usFirstChar,
	uint16 *	        pusCharCode,
	uint16 *	        pusGlyphID);


/* special helper function fs_WinNTGetGlyphIDs
   - an offset ulCharCodeOffset is added to the character codes from pulCharCode 
     before converting the value to glyph index
   - pulCharCode and pulGlyphID are both uint32 *
   - pulCharCode and pulGlyphID can point to the same address        
*/
extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_WinNTGetGlyphIDs (
	fs_GlyphInputType * inputPtr,
	uint16	            usCharCount,
	uint16	            usFirstChar,
	uint32	            ulCharCodeOffset,
	uint32 *	        pulCharCode,
	uint32 *	        pulGlyphID);

extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_GetOutlineCoordinates (
	fs_GlyphInputType * inputPtr,
	uint16              usPointCount,
	uint16 *            pusPointIndex,
	shortVector *       psvCoordinates);

/*** Gray scale definitions ***/

#ifndef FSCFG_DISABLE_GRAYSCALE

#define FS_GRAY_VALUE_MASK  0x008B      /* support usOverScale of 1, 2, 4, & 8 */
#define FS_SBIT_BITDEPTH_MASK	0x0116	 /* support sbit with bitDepth of 1, 2, 4 and 8 */
/* FS_SBIT_BITDEPTH_MASK must have the same value as SBIT_BITDEPTH_MASK in sfntaccs.h */ 

#else

#define FS_GRAY_VALUE_MASK  0x0000      /* no grayscale support */
#define FS_SBIT_BITDEPTH_MASK	0x0002	 /* support only sbit with bitDepth of 1 */
/* FS_SBIT_BITDEPTH_MASK must have the same value as SBIT_BITDEPTH_MASK in sfntaccs.h */ 

#endif
/* the value of FS_GRAY_VALUE_MASK and FS_SBIT_BITDEPTH_MASK can be used to determine
   the usGrayLevels the client need to support.

   Fonts without embedded bitmap :
		usGrayLevels = usOverScale * usOverScale + 1;

   Fonts with embedded bitmap (sbit) :
		usGrayLevels = 0x01 << usBitDepth;

  The usGrayLevels the client may receive with the current version are :

  0 for black/white
  5, 17, 65 fonts without embedded bitmap
  4, 16, 256 fonts with embedded bitmap

*/

extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_GetAdvanceHeight (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr);


#ifdef FSCFG_MOVE_KEY_IN_DOT_H
/* the definition of the key in fscaler.h and fscaler.c must be identical */

/** Private Structures  **/

/* new transformation parameters saved in the internal Key */
typedef struct fs_NewTrans {
			Fixed           pointSize;
			int16           xResolution;
			int16           yResolution;
			transMatrix     transformMatrix;
			uint16          usOverScale;            /* outline magnification */
            /* embolding simulation */
			uint16          usEmboldWeightx;        /* scaling factor in x between 0 and 40 (20 means 2% fo the height) */
			uint16          usEmboldWeighty;        /* scaling factor in y between 0 and 40 (20 means 2% fo the height) */
			int32           lDescDev;               /* descender in device metric, used for clipping */
			boolean         bBitmapEmboldening;
#ifdef FSCFG_SUBPIXEL
			uint16          flSubPixel;
#endif // FSCFG_SUBPIXEL
			boolean         bHintAtEmSquare;        /* hint at the design resolution, this flag is used for sub-pixel position
													   or text animation where we want to turn off gridfitting hinting
													   or text animation where we want to turn off gridfitting hinting
													   but for fonts where glyphs are build by hinting, we still want the
													   glyph shape to be correct */
		} fs_NewTrans;

/*** The Internal Key ***/
typedef struct fs_SplineKey {
	sfac_ClientRec      ClientInfo;         /* Client Information */
	char* const *       memoryBases;        /* array of memory Areas */
	char *              apbPrevMemoryBases[MEMORYFRAGMENTS];

	uint16              usScanType;         /* flags for dropout control etc.*/

	fsg_TransformRec    TransformInfo;

	uint16              usNonScaledAW;
	uint16              usNonScaledAH;

	LocalMaxProfile     maxProfile;         /* copy of profile */

	uint32              ulState;            /* for error checking purposes */
	
	boolean             bExecutePrePgm;
	boolean             bExecuteFontPgm;    /* <4> */

	fsg_WorkSpaceAddr   pWorkSpaceAddr;     /* Hard addresses in Work Space */
	fsg_WorkSpaceOffsets WorkSpaceOffsets;  /* Address offsets in Work Space     */
	fsg_PrivateSpaceOffsets PrivateSpaceOffsets; /* Address offsets in Private Space */

	uint16              usBandType;         /* old, small or fast */
	uint16              usBandWidth;        /* from FindBandingSize */

	GlyphBitMap         GBMap;              /* newscan bitmap type */
	WorkScan            WScan;              /* newscan workspace type */

	GlyphBitMap         OverGBMap;          /* for gray scale */
	boolean             bGrayScale;			/* FALSE if mono (usOverScale == 0)	*/
	boolean             bMatchBBox;         /* force bounding box match */
	boolean             bEmbeddedBitmap;    /* embedded bitmap found */			

	metricsType         metricInfo;         /* Glyph metrics info */
	verticalMetricsType     verticalMetricInfo;

	int32               lExtraWorkSpace;    /* Amount of extra space in workspace */

	boolean             bOutlineIsCached;   /* Outline is cached */
	boolean             bGlyphHasOutline;   /* Outline is empty */
	boolean             bGridFitSkipped;    /* sbit anticipated, no outline loaded */

	uint32              ulGlyphOutlineSize; /* Size of outline cache */
	
	sbit_State          SbitMono;           /* for monochrome bitmaps */
	boolean             bHintingEnabled;    /* hinting is enabled, set to FALSE when 
                                               fs_NewTransformNoGridFit is called */
	int16               sBoldSimulHorShift; /* shift for emboldening simulation, horizonatlly */
	int16               sBoldSimulVertShift; /* shift for emboldening simulation, vertically */
#ifdef FSCFG_SUBPIXEL
	uint16				flSubPixel;
	fsg_TransformRec    TransformInfoSubPixel;
#endif // FSCFG_SUBPIXEL
	fs_NewTrans			SavedTransformInfo; /* saved transformation info */
} fs_SplineKey;

#endif // FSCFG_MOVE_KEY_IN_DOT_H

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\fondrv\tt\scaler\fscdefs.h ===
/*
	File:       fscdefs.h

	Contains:   xxx put contents here (or delete the whole line) xxx

	Written by: xxx put name of writer here (or delete the whole line) xxx

	Copyright:  c 1988-1990 by Apple Computer, Inc., all rights reserved.
	Copyright:  c 1991-1999 by Microsoft Corp., all rights reserved.

	Change History (most recent first):
		
				 7/10/99  BeatS		Add support for native SP fonts, vertical RGB
		         4/01/99  BeatS		Implement alternative interpretation of TT instructions for SP
		 <>     10/14/97    CB      rename ASSERT into FS_ASSERT
		 <3>    11/27/90    MR      Add #define for PASCAL. [ph]
		 <2>     11/5/90    MR      Move USHORTMUL from fontmath.h, add Debug definition [rb]
		 <7>     7/18/90    MR      Add byte swapping macros for INTEL, moved rounding macros from
									fnt.h to here
		 <6>     7/14/90    MR      changed defines to typedefs for int[8,16,32] and others
		 <5>     7/13/90    MR      Declared ReleaseSFNTFunc and GetSFNTFunc
		 <4>      5/3/90    RB      cant remember any changes
		 <3>     3/20/90    CL      type changes for Microsoft
		 <2>     2/27/90    CL      getting bbs headers
	   <3.0>     8/28/89    sjk     Cleanup and one transformation bugfix
	   <2.2>     8/14/89    sjk     1 point contours now OK
	   <2.1>      8/8/89    sjk     Improved encryption handling
	   <2.0>      8/2/89    sjk     Just fixed EASE comment
	   <1.5>      8/1/89    sjk     Added composites and encryption. Plus some enhancements.
	   <1.4>     6/13/89    SJK     Comment
	   <1.3>      6/2/89    CEL     16.16 scaling of metrics, minimum recommended ppem, point size 0
									bug, correct transformed integralized ppem behavior, pretty much
									so
	   <1.2>     5/26/89    CEL     EASE messed up on "c" comments
	  <,1.1>     5/26/89    CEL     Integrated the new Font Scaler 1.0 into Spline Fonts
	   <1.0>     5/25/89    CEL     Integrated 1.0 Font scaler into Bass code for the first time.

	To Do:
*/

#ifndef FSCDEFS_DEFINED
#define FSCDEFS_DEFINED

#include "fsconfig.h"
#include <stddef.h>
#include <limits.h>

#if !defined(__cplusplus)       // true/false are reserved words for C++
#define true 1
#define false 0
#endif

#ifndef TRUE
	#define TRUE    1
#endif

#ifndef FALSE
#define FALSE   0
#endif

#ifndef FS_PRIVATE
#define FS_PRIVATE static
#endif

#ifndef FS_PUBLIC
#define FS_PUBLIC
#endif

#define ONEFIX      ( 1L << 16 )
#define ONEFRAC     ( 1L << 30 )
#define ONEHALFFIX  0x8000L
#define ONEVECSHIFT 16
#define HALFVECDIV  (1L << (ONEVECSHIFT-1))

#define NULL_GLYPH  0

/* banding type constants */

#define FS_BANDINGOLD       0
#define FS_BANDINGSMALL     1
#define FS_BANDINGFAST      2
#define FS_BANDINGFASTER    3

/* Dropout control values are now defined as bit masks to retain compatability */
/* with the old definition, and to allow for current and future expansion */

#define SK_STUBS          0x0001       /* leave stubs white */
#define SK_NODROPOUT      0x0002       /* disable all dropout control */
#define SK_SMART              0x0004        /* symmetrical dropout, closest pixel */

/* Values used to decode curves */

#define ONCURVE             0x01

typedef signed char int8;
typedef unsigned char uint8;
typedef short int16;
typedef unsigned short uint16;
typedef long int32;
typedef unsigned long uint32;

typedef __int64 int64;
typedef unsigned __int64 uint64;

typedef short FUnit;
typedef unsigned short uFUnit;

typedef short ShortFract;                       /* 2.14 */

#ifndef F26Dot6
#define F26Dot6 long
#endif

#ifndef boolean
#define boolean int
#endif

#ifndef ClientIDType
#define ClientIDType int32
#endif

#ifndef CONST
#define CONST const
#endif

#ifndef FAR
#define FAR
#endif

#ifndef NEAR
#define NEAR
#endif

#ifndef TMP_CONV
#define TMP_CONV
#endif

#ifndef FS_MAC_PASCAL
#define FS_MAC_PASCAL
#endif

#ifndef FS_PC_PASCAL
#define FS_PC_PASCAL
#endif

#ifndef FS_MAC_TRAP
#define FS_MAC_TRAP(a)
#endif

/* QuickDraw Types */

#ifndef _MacTypes_
#ifndef __TYPES__
	typedef struct Rect {
		int16 top;
		int16 left;
		int16 bottom;
		int16 right;
	} Rect;

typedef long Fixed;         /* also defined in Mac's types.h */
typedef long Fract;

#endif
#endif

typedef struct {
	Fixed       transform[3][3];
} transMatrix;

typedef struct {
	Fixed       x, y;
} vectorType;

/* Private Data Types */
typedef struct {
	int16 xMin;
	int16 yMin;
	int16 xMax;
	int16 yMax;
} BBOX;

typedef struct {
	F26Dot6 x;
	F26Dot6 y;
} point;

typedef int32 ErrorCode;

#define ALIGN(object, p) p =    (p + ((uint32)sizeof(object) - 1)) & ~((uint32)sizeof(object) - 1);

#define ROWBYTESLONG(x)     (((x + 31) >> 5) << 2)

#ifndef SHORTMUL
#define SHORTMUL(a,b)   (int32)((int32)(a) * (b))
#endif

#ifndef SHORTDIV
#define SHORTDIV(a,b)   (int32)((int32)(a) / (b))
#endif

#ifdef FSCFG_BIG_ENDIAN /* target byte order matches Motorola 68000 */
	#define SWAPL(a)        (a)
	#define CSWAPL(a)       (a)
	#define SWAPW(a)        (a)
	#define CSWAPW(a)       (a)
	#define SWAPWINC(a)     (*(a)++)
#else
	/* Portable code to extract a short or a long from a 2- or 4-byte buffer */
	/* which was encoded using Motorola 68000 (TrueType "native") byte order. */
	#define FS_2BYTE(p) ( ((unsigned short)((p)[0]) << 8) |  (p)[1])
	#define FS_4BYTE(p) ( FS_2BYTE((p)+2) | ( (FS_2BYTE(p)+0L) << 16) )
	#define SWAPW(a)	((int16) FS_2BYTE( (unsigned char *)(&a) ))
	#define CSWAPW(num)	(((((num) & 0xff) << 8) & 0xff00) + (((num) >> 8) & 0xff)) // use this variant or else cannot apply to constants due to FS_2BYTE and FS_4BYTE
	#define SWAPL(a)	((int32) FS_4BYTE( (unsigned char *)(&a) ))
	#define CSWAPL(num)	((CSWAPW((num) & 0xffff) << 16) + CSWAPW((num) >> 16)) // use this variant or else cannot apply to constants due to FS_2BYTE and FS_4BYTE
	#define SWAPWINC(a) SWAPW(*(a)); a++    /* Do NOT parenthesize! */
#endif

#ifndef SWAPW // provoke compiler error if still not defined
	#define SWAPW	a
	#define SWAPW	b
#endif

#ifndef LoopCount
#define LoopCount int16      /* short gives us a Motorola DBF */
#endif

#ifndef ArrayIndex
#define ArrayIndex int32     /* avoids EXT.L on Motorola */
#endif

typedef void (*voidFunc) ();
typedef void * voidPtr;
typedef void (FS_CALLBACK_PROTO *ReleaseSFNTFunc) (voidPtr);
typedef void * (FS_CALLBACK_PROTO *GetSFNTFunc) (ClientIDType, int32, int32);

#ifndef	FS_ASSERT
#define FS_ASSERT(expression, message)
#endif

#ifndef Assert
#define Assert(a)
#endif

#ifndef MEMSET
#define MEMSET(dst, value, size) (void)memset(dst,value,(size_t)(size))
#define FS_NEED_STRING_DOT_H
#endif

#ifndef MEMCPY
#define MEMCPY(dst, src, size) (void)memcpy(dst,src,(size_t)(size))
#ifndef FS_NEED_STRING_DOT_H
#define FS_NEED_STRING_DOT_H
#endif
#endif

#ifdef FS_NEED_STRING_DOT_H
#undef FS_NEED_STRING_DOT_H
#include <string.h>
#endif

#ifndef FS_UNUSED_PARAMETER
#define FS_UNUSED_PARAMETER(a) (a=a)     /* Silence some warnings */
#endif

typedef struct {
	Fixed       version;                /* for this table, set to 1.0 */
	uint16      numGlyphs;
	uint16      maxPoints;              /* in an individual glyph */
	uint16      maxContours;            /* in an individual glyph */
	uint16      maxCompositePoints;     /* in an composite glyph */
	uint16      maxCompositeContours;   /* in an composite glyph */
	uint16      maxElements;            /* set to 2, or 1 if no twilightzone points */
	uint16      maxTwilightPoints;      /* max points in element zero */
	uint16      maxStorage;             /* max number of storage locations */
	uint16      maxFunctionDefs;        /* max number of FDEFs in any preprogram */
	uint16      maxInstructionDefs;     /* max number of IDEFs in any preprogram */
	uint16      maxStackElements;       /* max number of stack elements for any individual glyph */
	uint16      maxSizeOfInstructions;  /* max size in bytes for any individual glyph */
	uint16      maxComponentElements;   /* number of glyphs referenced at top level */
	uint16      maxComponentDepth;      /* levels of recursion, 1 for simple components */
} LocalMaxProfile;

#ifdef FSCFG_SUBPIXEL

	// master switch for turning on Backwards Compatible SubPixel
	// if we turn this off, we basically get the same as in b/w, but with coloured fringes
	// to get the complete original 16x overscaling behaviour back, set HINTING_HOR_OVERSCALE below to 16
	#define	SUBPIXEL_BC
	
	#define ProjVectInX(localGS)	((localGS).proj.x == ONEVECTOR && (localGS).proj.y == 0)
	#define	ProjVectInY(localGS)	((localGS).proj.y == ONEVECTOR && (localGS).proj.x == 0)
	
	#ifdef SUBPIXEL_BC
		
		// master switch for turning on Enhanced Backwards Compatible Advance Width SubPixel Algorithm
		#define SUBPIXEL_BC_AW_STEM_CONCERTINA
		
		#define RunningSubPixel(globalGS)		((uint16)((globalGS)->flHintForSubPixel & FNT_SP_SUB_PIXEL))
		#define CompatibleWidthSP(globalGS)		((uint16)((globalGS)->flHintForSubPixel & FNT_SP_COMPATIBLE_WIDTH))
		#define VerticalSPDirection(globalGS)	((uint16)((globalGS)->flHintForSubPixel & FNT_SP_VERTICAL_DIRECTION))
		#define BGROrderSP(globalGS)			((uint16)((globalGS)->flHintForSubPixel & FNT_SP_BGR_ORDER))
	//	assume that horizontal direction RGB is more frequent than vertical direction, hence put the latter into the else-path
	//	Notice that in order to decide whether we're currently in SubPixel direction, we look at the projection vector, because that's the direction
	//	along which distances are measured. If this projection vector has a non-zero component in the physical direction of our device, we will decide
	//	that rounding should be done in the SubPixel way. For example, if our device has its SubPixel direction in x, and if the projection vector
	//	points in any direction other than the y direction, the pv has a non-zero component in x, hence we round in the SubPixel way. This behaviour
	//	corresponds to the original implementation of the 16x overscaling rasterizer, where the non-zero component in x would be overscaled by 16.
		#define InSubPixelDirection(localGS)	((uint16)(!VerticalSPDirection((localGS).globalGS) ? !ProjVectInY(localGS) : !ProjVectInX(localGS)))
	//	primary values; in interp.c there are further values which are derived from these values, but which are specific to the interpreter
		#define VIRTUAL_OVERSCALE				16 // for itrp_RoundToGrid & al to work properly, this should be a power of two, else have to tabulate rounding
		#define VISUAL_OVERSCALE				2  // between 1.7 and 3, corresponding to the visually experienced resolution relative to the physical resolution.
												   // for our purposes, the exact value is not particularly crucial (cf. ENGINE_COMP_OVERSCALE, MIN_DIST_OVERSCALE,
												   // in interp.c) hence we set it to 2 for efficiency
	#else
		#define RunningSubPixel(globalGS)		false
		#define CompatibleWidthSP(globalGS)		false
		#define VerticalSPDirection(globalGS)	false
		#define InSubPixelDirection(localGS)	false
	//	primary values; in interp.c there are further values which are derived from these values, but which are specific to the interpreter
		#define VIRTUAL_OVERSCALE				1
		#define VISUAL_OVERSCALE				1
	#endif
//	#define VIRTUAL_PIXELSIZE		(FNT_PIXELSIZE/VIRTUAL_OVERSCALE)
//	these values are used in various rounding functions, which includes rounding the advance width
//	they are specific to the rounding operation, if this should become necessary in the future
	#define VIRTUAL_PIXELSIZE_RTDG	(FNT_PIXELSIZE/VIRTUAL_OVERSCALE)
	#define VIRTUAL_PIXELSIZE_RDTG	(FNT_PIXELSIZE/VIRTUAL_OVERSCALE)
	#define VIRTUAL_PIXELSIZE_RUTG	(FNT_PIXELSIZE/VIRTUAL_OVERSCALE)
	#define VIRTUAL_PIXELSIZE_RTG	(FNT_PIXELSIZE/VIRTUAL_OVERSCALE)
	#define VIRTUAL_PIXELSIZE_RTHG	(FNT_PIXELSIZE/VIRTUAL_OVERSCALE)
	#define VIRTUAL_PIXELSIZE_ROFF	(FNT_PIXELSIZE/VIRTUAL_OVERSCALE)
	

	#define HINTING_HOR_OVERSCALE 1 // see SUBPIXEL_BC above for further comments

#ifdef FSCFG_SUBPIXEL_STANDALONE
	
	#define R_Subpixels		5
	#define G_Subpixels		9
	#define B_Subpixels		2

	/* IMPORTANT :
 
	   If you change any of the above
	   make sure you update abColorIndexTable[] in scentry.c
	   and that (R_Subpixels + 1) * (G_Subpixels + 1) * (B_Subpixels + 1) <= 256

	  */

	#define RGB_OVERSCALE (R_Subpixels + G_Subpixels + B_Subpixels)

#else

	#define SUBPIXEL_OVERSCALE 2

	/* IMPORTANT :
 
	   If you change SUBPIXEL_OVERSCALE
	   make sure you update abColorIndexTable[] in scentry.c
	   and that (SUBPIXEL_OVERSCALE + 1) * (SUBPIXEL_OVERSCALE + 1) * (SUBPIXEL_OVERSCALE + 1) <= 256

	  */

	#define RGB_OVERSCALE (SUBPIXEL_OVERSCALE * 3)
#endif

	#define ROUND_FROM_RGB_OVERSCALE(x) x = ((x) + (RGB_OVERSCALE >> 1) ) / RGB_OVERSCALE
	#define ROUND_FROM_HINT_OVERSCALE(x) x = ((x) + (HINTING_HOR_OVERSCALE >> 1) ) / HINTING_HOR_OVERSCALE
	#define ROUND_RGB_OVERSCALE(x) ((x) + (RGB_OVERSCALE >> 1) ) / RGB_OVERSCALE

	#define FLOOR_RGB_OVERSCALE(x) ((x) < 0) ? -((-(x)+ RGB_OVERSCALE -1) / RGB_OVERSCALE) : ((x) / RGB_OVERSCALE) // by the way, this is NOT a floor operation
	#define CEIL_RGB_OVERSCALE(x) FLOOR_RGB_OVERSCALE((x) + RGB_OVERSCALE -1)

	/* we are storing into 2 bits per pixels, weight for each color can be 0,1 or 2 */
	#define MAX_RGB_INDEX (2 * 16 + 2 * 4 + 2 )

	#define SUBPIXEL_SCALEBACK_FACTOR ((RGB_OVERSCALE << 16) / HINTING_HOR_OVERSCALE)

	#define SUBPIXEL_SCALEBACK_UPPER_LIMIT (SUBPIXEL_SCALEBACK_FACTOR *120 /100)
	#define SUBPIXEL_SCALEBACK_LOWER_LIMIT (SUBPIXEL_SCALEBACK_FACTOR *100 /120)
#endif // FSCFG_SUBPIXEL

#endif  /* FSCDEFS_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\fondrv\tt\scaler\fscaler.c ===
/*
	File:       FontScaler.c

	Contains:   xxx put contents here (or delete the whole line) xxx

	Written by: xxx put name of writer here (or delete the whole line) xxx

   Copyright:  (c) 1987-1990, 1992 by Apple Computer, Inc., all rights reserved.
			   (c) 1989-1999. Microsoft Corporation, all rights reserved.

	Change History (most recent first):

				 7/10/99  BeatS		Add support for native SP fonts, vertical RGB
		         4/01/99  BeatS		Implement alternative interpretation of TT instructions for SP
		<>      10/14/97    CB      move usOverScale to fs_NewTransformation
		<>       2/21/97    CB      no need to call pre-program if no hints (was causing div by zero)
		<>       1/10/97    CB      empty bitmap with bMatchBbox == TRUE causes crash
		<>      12/14/95    CB      add	usNonScaledAH to the private key
		<11>    11/27/90    MR      Need two scalars: one for (possibly rounded) outlines and cvt,
									and one (always fractional) metrics. [rb]
		<10>    11/21/90    RB      Allow client to disable DropOutControl by returning a NIL
									pointer to memoryarea[7]. Also make it clear that we inhibit
									DOControl whenever we band. [This is a reversion to 8, so mr's
									initials are added by proxy]
		 <9>    11/13/90    MR      (dnf) Revert back to revision 7 to fix a memmory-trashing bug
									(we hope). Also fix signed/unsigned comparison bug in outline
									caching.
		 <8>    11/13/90    RB      Fix banding so that we can band down to one row, using only
									enough bitmap memory and auxillary memory for one row.[mr]
		 <7>     11/9/90    MR      Add Default return to fs_dropoutval. Continue to fiddle with
									banding. [rb]
		 <6>     11/5/90    MR      Remove FixMath.h from include list. Clean up Stamp macros. [rb]
		 <5>    10/31/90    MR      Conditionalize call to ComputeMapping (to avoid linking
									MapString) [ha]
		 <4>    10/31/90    MR      Add bit-field option for integer or fractional scaling [rb]
		 <3>    10/30/90    RB      [MR] Inhibit DropOutControl when Banding
		 <2>    10/20/90    MR      Restore changes since project died. Converting to smart math
									routines, integer ppem scaling. [rb]
		<16>     7/26/90    MR      don't include ToolUtils.h
		<15>     7/18/90    MR      Fix return bug in GetAdvanceWidth, internal errors are now ints.
		<14>     7/14/90    MR      remove unused fields from FSInfo
		<13>     7/13/90    MR      Ansi-C fixes, rev. for union in FSInput
		<11>     6/29/90    RB      Thus endeth the too long life of encryption
		<10>     6/21/90    MR      Add calls to ReleaseSfntFrag
		 <9>     6/21/90    RB      add scanKind info to fs_dropoutVal
		 <8>      6/5/90    MR      remove fs_MapCharCodes
		 <7>      6/1/90    MR      
		 <6>      6/1/90    RB      fixed bandingbug under dropout control
		 <4>      5/3/90    RB      added dropoutval function.  simplified restore outlines.
									support for new scanconverter in contourscan, findbitmapsize,
									saveoutlines, restoreoutlines.
		 <3>     3/20/90    CL      Changed to use fpem (16.16) instead of pixelsPerEm (int) Removed
									call to AdjustTransformation (not needed with fpem) Added call
									to RunXFormPgm Removed WECANNOTDOTHIS #ifdef Added
									fs_MapCharCodes
		 <2>     2/27/90    CL      New error code for missing but needed table. (0x1409).  New
									CharToIndexMap Table format.
									Fixed transformed component bug.
	   <3.6>    11/15/89    CEL     Put an else for the ifdef WeCanNotDoThis so Printer compile
									could use more effecient code.
	   <3.5>    11/14/89    CEL     Left Side Bearing should work right for any transformation. The
									phantom points are in, even for components in a composite glyph.
									They should also work for transformations. Device metric are
									passed out in the output data structure. This should also work
									with transformations. Another leftsidebearing along the advance
									width vector is also passed out. whatever the metrics are for
									the component at it's level. Instructions are legal in
									components. Instructions are legal in components. The
									transformation is internally automatically normalized. This
									should also solve the overflow problem we had. Now it is legal
									to pass in zero as the address of memory when a piece of the
									sfnt is requested by the scaler. If this happens the scaler will
									simply exit with an error code ! Five unnecessary element in the
									output data structure have been deleted. (All the information is
									passed out in the bitmap data structure) fs_FindBMSize now also
									returns the bounding box.
	   <3.4>     9/28/89    CEL     fs_newglyph did not initialize the output error. Caused routine
									to return error from previous routines.
	   <3.3>     9/27/89    CEL     Took out devAdvanceWidth & devLeftSideBearing.
	   <3.2>     9/25/89    CEL     Changed the NEED_PROTOTYPE ifdef to use the NOT_ON_THE_MAC flag
									that existed previously.
	   <3.1>     9/15/89    CEL     Changed dispatch scheme. Calling conventions through a trap
									needed to match Macintosh pascal. Pascal can not call C unless
									there is extra mucky glue. Bug that caused text not to appear.
									The font scaler state was set up correctly but the sfnt was
									purged. It was reloaded and the clientid changed but was still
									the same font. Under the rules of the FontScaler fs_newsfnt
									should not have to be called again to reset the state. The extra
									checks sent back a BAD_CLIENTID_ERROR so QuickDraw would think
									it was a bad font and not continue to draw.
	   <3.0>     8/28/89    sjk     Cleanup and one transformation bugfix
	   <2.4>     8/17/89    sjk     Coded around MPW C3.0 bug
	   <2.3>     8/14/89    sjk     1 point contours now OK
	   <2.2>      8/8/89    sjk     Improved encryption handling
	   <2.1>      8/2/89    sjk     Fixed outline caching bug
	   <2.0>      8/2/89    sjk     Just fixed EASE comment
	   <1.5>      8/1/89    sjk     Added composites and encryption. Plus some enhancements.
	   <1.4>     6/13/89    SJK     Comment
	   <1.3>      6/2/89    CEL     16.16 scaling of metrics, minimum recommended ppem, point size 0
									bug, correct transformed integralized ppem behavior, pretty much
									so
	   <1.2>     5/26/89    CEL     EASE messed up on "c" comments
	  <y1.1>     5/26/89    CEL     Integrated the new Font Scaler 1.0 into Spline Fonts
	   <1.0>     5/25/89    CEL     Integrated 1.0 Font scaler into Bass code for the first time.

	To Do:
*/
/*      <3+>     3/20/90    mrr     Conditionalized error checking in fs_SetUpKey.
									Compiler option for stamping memmory areas for debugging
									Removed error field from FSInfo structure.
									Added call to RunFontProgram
									Added private function prototypes.
									Optimizations from diet clinic

*/

/** FontScaler's Includes **/

#define FSCFG_INTERNAL

#include "fserror.h"
#include "fscdefs.h"
#include "fontmath.h"        /* For numeric conversion macros    */
#include "fnt.h"
#include "scentry.h"
#include "sfntaccs.h"
#include "fsglue.h"
#include "sbit.h"
#include "fscaler.h"         // moved this to be the last include file (key moved in dot h)


#include "stat.h"                   /* STAT timing card prototypes */
boolean gbTimer = FALSE;            /* set true when timer running */

#ifndef FSCFG_MOVE_KEY_IN_DOT_H
/* the definition of the key in fscaler.h and fscaler.c must be identical */

/** Private Structures  **/

/* new transformation parameters saved in the internal Key */
typedef struct fs_NewTrans {
			Fixed           pointSize;
			int16           xResolution;
			int16           yResolution;
			transMatrix     transformMatrix;
			uint16          usOverScale;            /* outline magnification */
            /* embolding simulation */
			uint16          usEmboldWeightx;        /* scaling factor in x between 0 and 40 (20 means 2% fo the height) */
			uint16          usEmboldWeighty;        /* scaling factor in y between 0 and 40 (20 means 2% fo the height) */
			int32           lDescDev;               /* descender in device metric, used for clipping */
			boolean         bBitmapEmboldening;
#ifdef FSCFG_SUBPIXEL
			uint16          flSubPixel;
#endif // FSCFG_SUBPIXEL
			boolean         bHintAtEmSquare;        /* hint at the design resolution, this flag is used for sub-pixel position
													   or text animation where we want to turn off gridfitting hinting
													   or text animation where we want to turn off gridfitting hinting
													   but for fonts where glyphs are build by hinting, we still want the
													   glyph shape to be correct */
		} fs_NewTrans;

/*** The Internal Key ***/
typedef struct fs_SplineKey {
	sfac_ClientRec      ClientInfo;         /* Client Information */
	char* const *       memoryBases;        /* array of memory Areas */
	char *              apbPrevMemoryBases[MEMORYFRAGMENTS];

	uint16              usScanType;         /* flags for dropout control etc.*/

	fsg_TransformRec    TransformInfo;

	uint16              usNonScaledAW;
	uint16              usNonScaledAH;

	LocalMaxProfile     maxProfile;         /* copy of profile */

	uint32              ulState;            /* for error checking purposes */
	
	boolean             bExecutePrePgm;
	boolean             bExecuteFontPgm;    /* <4> */

	fsg_WorkSpaceAddr   pWorkSpaceAddr;     /* Hard addresses in Work Space */
	fsg_WorkSpaceOffsets WorkSpaceOffsets;  /* Address offsets in Work Space     */
	fsg_PrivateSpaceOffsets PrivateSpaceOffsets; /* Address offsets in Private Space */

	uint16              usBandType;         /* old, small or fast */
	uint16              usBandWidth;        /* from FindBandingSize */

	GlyphBitMap         GBMap;              /* newscan bitmap type */
	WorkScan            WScan;              /* newscan workspace type */

	GlyphBitMap         OverGBMap;          /* for gray scale */
	boolean             bGrayScale;			/* FALSE if mono (usOverScale == 0)	*/
	boolean             bMatchBBox;         /* force bounding box match */
	boolean             bEmbeddedBitmap;    /* embedded bitmap found */			

	metricsType         metricInfo;         /* Glyph metrics info */
	verticalMetricsType     verticalMetricInfo;

	int32               lExtraWorkSpace;    /* Amount of extra space in workspace */

	boolean             bOutlineIsCached;   /* Outline is cached */
	boolean             bGlyphHasOutline;   /* Outline is empty */
	boolean             bGridFitSkipped;    /* sbit anticipated, no outline loaded */

	uint32              ulGlyphOutlineSize; /* Size of outline cache */
	
	sbit_State          SbitMono;           /* for monochrome bitmaps */
	boolean             bHintingEnabled;    /* hinting is enabled, set to FALSE when 
                                               fs_NewTransformNoGridFit is called */
	int16               sBoldSimulHorShift; /* shift for emboldening simulation, horizonatlly */
	int16               sBoldSimulVertShift; /* shift for emboldening simulation, vertically */
#ifdef FSCFG_SUBPIXEL
	uint16				flSubPixel;
	fsg_TransformRec    TransformInfoSubPixel;
#endif // FSCFG_SUBPIXEL
	fs_NewTrans			SavedTransformInfo; /* saved transformation info */
} fs_SplineKey;

#endif // FSCFG_MOVE_KEY_IN_DOT_H

/*  CONSTANTS   */

/* Change this if the format for cached outlines change. */
/* Someone might be caching old stuff for years on a disk */

#define OUTLINESTAMP 0x2D0CBBAD
#define OUTLINESTAMP2 0xA5

#define BITMAP_MEMORY_COUNT 4       /* now for gray scale we need 4 */

/* for the key->ulState field */
#define INITIALIZED 0x0000L
#define NEWSFNT     0x0002L
#define NEWTRANS    0x0004L
#define GOTINDEX    0x0008L
#define GOTGLYPH    0x0010L
#define SIZEKNOWN   0x0020L

#define STAMPEXTRA      4

/* 'sfnt' in ASCII  */
#define STAMP           0x73666E74

/*** Memory shared between all fonts and sizes and transformations ***/
#define KEY_PTR_BASE                0 /* Constant Size ! */
#define VOID_FUNC_PTR_BASE          1 /* Constant Size ! */
#define SCAN_PTR_BASE               2 /* Constant Size ! */
#define WORK_SPACE_BASE             3 /* size is sfnt dependent, can't be shared between grid-fitting and scan-conversion */
/*** Memory that can not be shared between fonts and different sizes, can not dissappear after InitPreProgram () ***/
#define PRIVATE_FONT_SPACE_BASE     4 /* size is sfnt dependent */
/* Only needs to exist when ContourScan is called, and it can be shared */
#define BITMAP_PTR_1                5 /* the bitmap - size is glyph size dependent */
#define BITMAP_PTR_2                6 /* size is proportional to number of rows */
#define BITMAP_PTR_3                7 /* used for dropout control - glyph size dependent */
#define BITMAP_PTR_4                8 /* used in gray scale for overscaled bitmap */

static  const   transMatrix   IdentTransform =
	{{{ONEFIX,      0,      0},
	  {     0, ONEFIX,      0},
	  {     0,      0, ONEFIX}}};


/* PRIVATE DEFINITIONS    */

FS_PRIVATE fs_SplineKey *  fs_SetUpKey (fs_GlyphInputType* inptr, uint32 ulStateBits, ErrorCode * error);
FS_PRIVATE void            fs_InitializeKey(fs_SplineKey * key);
FS_PRIVATE int32           fs__Contour (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr, boolean useHints);
FS_PRIVATE int32           fs__NewTransformation (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr, boolean useHints);
FS_PRIVATE void            fs_SetState(fs_SplineKey * key, uint32 ulState);
FS_PRIVATE void            FS_CALLBACK_PROTO dummyReleaseSfntFrag (voidPtr p);
FS_PRIVATE void            CHECKSTAMP (char * p);
FS_PRIVATE void            SETSTAMP (char * p);

FS_PRIVATE FS_ENTRY LookForSbitAdvanceWidth(fs_SplineKey *key, uint16 usGlyphIndex, boolean *pbBitmapFound, point *pf26DevAdvanceWidth );
FS_PRIVATE FS_ENTRY LookForSbitAdvanceHeight(fs_SplineKey *key, uint16 usGlyphIndex, boolean *pbBitmapFound,
    point *pf26DevAdvanceHeight);

/* FUNCTIONS    */

FS_PRIVATE void SETSTAMP (char * p)
{
	* ((uint32 *) ((p) - STAMPEXTRA)) = STAMP;
}


FS_PRIVATE void CHECKSTAMP (char * p)
{
	if (* ((uint32 *) ((p) - STAMPEXTRA)) != STAMP)
	{
#ifdef  NOT_ON_THE_MAC
		Assert(FALSE);
#else
		DEBUGGER ();
#endif
	}
}


FS_PRIVATE void FS_CALLBACK_PROTO dummyReleaseSfntFrag (voidPtr p)
{
	FS_UNUSED_PARAMETER(p);
}

FS_PRIVATE void   fs_SetState(fs_SplineKey * key, uint32 ulState)
{
	key->ulState = ulState;
}

/*
 *  Set up the key in case memmory has moved or been purged.
 */
FS_PRIVATE fs_SplineKey * fs_SetUpKey (
	fs_GlyphInputType * inptr,
	uint32              ulStateBits,
	ErrorCode *         error)
{
	fs_SplineKey *  key;

	key = (fs_SplineKey *)inptr->memoryBases[KEY_PTR_BASE];
	if (key == NULL)
	{
		*error = NULL_KEY_ERR;
		return 0;
	}

	key->memoryBases =                           inptr->memoryBases;
	if(key->memoryBases == NULL)
	{
		*error = NULL_MEMORY_BASES_ERR;
		return 0;
	}
	key->ClientInfo.GetSfntFragmentPtr =    inptr->GetSfntFragmentPtr;
	if(key->ClientInfo.GetSfntFragmentPtr == NULL)
	{
		*error = NULL_SFNT_FRAG_PTR_ERR;
		return 0;
	}

	key->ClientInfo.ReleaseSfntFrag = inptr->ReleaseSfntFrag;
	if (!(key->ClientInfo.ReleaseSfntFrag))
	{
		key->ClientInfo.ReleaseSfntFrag = dummyReleaseSfntFrag;
	}

	if ((key->ulState & ulStateBits) != ulStateBits)
	{
		*error = OUT_OFF_SEQUENCE_CALL_ERR;
		return 0;
	}

	key->ClientInfo.lClientID = inptr->clientID;
	*error = NO_ERR;

	return key;
}

FS_PRIVATE void fs_InitializeKey(fs_SplineKey * key)
{
	MEMSET(key, 0, sizeof(fs_SplineKey));
	key->TransformInfo.currentTMatrix = IdentTransform;
#ifdef FSCFG_SUBPIXEL
	key->TransformInfoSubPixel.currentTMatrix = IdentTransform;
#endif // FSCFG_SUBPIXEL
}

/*** FONT SCALER INTERFACE ***/

/*
 *
 */

FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_OpenFonts (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
{
	Assert(FS_SBIT_BITDEPTH_MASK == SBIT_BITDEPTH_MASK);
	/* sanity check that the embedded bitmap mask is the same in fscaler.h than in sfntaccs.h */

	if ( outputPtr )
	{
		outputPtr->memorySizes[KEY_PTR_BASE]        = (int32)sizeof (fs_SplineKey) + STAMPEXTRA;
		outputPtr->memorySizes[VOID_FUNC_PTR_BASE]  = 0;
		outputPtr->memorySizes[SCAN_PTR_BASE]       = 0;
		outputPtr->memorySizes[WORK_SPACE_BASE]      = 0; /* we need the sfnt for this */
		outputPtr->memorySizes[PRIVATE_FONT_SPACE_BASE] = 0; /* we need the sfnt for this */
		outputPtr->memorySizes[BITMAP_PTR_1]         = 0; /* we need the grid fitted outline for this */
		outputPtr->memorySizes[BITMAP_PTR_2]         = 0; /* we need the grid fitted outline for this */
		outputPtr->memorySizes[BITMAP_PTR_3]         = 0; /* we need the grid fitted outline for this */
		outputPtr->memorySizes[BITMAP_PTR_4]         = 0; /* gray scale memory */
	}
	else
	{
		return NULL_OUTPUT_PTR_ERR;
	}
	if ( inputPtr )
	{
		inputPtr->memoryBases[KEY_PTR_BASE]             = NULL;
		inputPtr->memoryBases[VOID_FUNC_PTR_BASE]       = NULL;
		inputPtr->memoryBases[SCAN_PTR_BASE]            = NULL;
		inputPtr->memoryBases[WORK_SPACE_BASE]          = NULL;
		inputPtr->memoryBases[PRIVATE_FONT_SPACE_BASE]  = NULL;
		inputPtr->memoryBases[BITMAP_PTR_1]             = NULL;
		inputPtr->memoryBases[BITMAP_PTR_2]             = NULL;
		inputPtr->memoryBases[BITMAP_PTR_3]             = NULL;
		inputPtr->memoryBases[BITMAP_PTR_4]             = NULL;
	}
	else
	{
		return NULL_INPUT_PTR_ERR;
	}
	return NO_ERR;
}

FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_Initialize (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
{
	fs_SplineKey *  key;

	FS_UNUSED_PARAMETER(outputPtr);

	key = (fs_SplineKey *)inputPtr->memoryBases[KEY_PTR_BASE];
	SETSTAMP (inputPtr->memoryBases[KEY_PTR_BASE] + outputPtr->memorySizes[KEY_PTR_BASE]);

	fs_InitializeKey(key);

	key->memoryBases = inputPtr->memoryBases;

	fs_SetState(key, INITIALIZED);

	fsc_Initialize();                            /* initialize scan converter */

	CHECKSTAMP (inputPtr->memoryBases[KEY_PTR_BASE] + outputPtr->memorySizes[KEY_PTR_BASE]);

	return NO_ERR;
}


/*
 *  This guy asks for memmory for points, instructions, fdefs and idefs
 */
FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_NewSfnt (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
{
	ErrorCode       error;
	fs_SplineKey *  key;

	CHECKSTAMP (inputPtr->memoryBases[KEY_PTR_BASE] + outputPtr->memorySizes[KEY_PTR_BASE]);

	STAT_ON_NEWSFNT;                 /* start STAT timer */

	key = fs_SetUpKey(inputPtr, INITIALIZED, &error);

	if(!key)
	{
		return (FS_ENTRY)error;
	}

	error = sfac_DoOffsetTableMap (&key->ClientInfo);  /* Map offset and length table */

	if(error != NO_ERR)
	{
		return (FS_ENTRY)error;
	}

	error = sfac_LoadCriticalSfntMetrics(
		&key->ClientInfo,
		&key->TransformInfo.usEmResolution,
		&key->TransformInfo.bIntegerScaling,
		&key->maxProfile);

	if(error != NO_ERR)
	{
		return (FS_ENTRY)error;
	}

	outputPtr->memorySizes[PRIVATE_FONT_SPACE_BASE] = (int32)fsg_PrivateFontSpaceSize (&key->ClientInfo, &key->maxProfile, &key->PrivateSpaceOffsets) + STAMPEXTRA;
	outputPtr->memorySizes[WORK_SPACE_BASE]         = (int32)fsg_WorkSpaceSetOffsets (&key->maxProfile, &key->WorkSpaceOffsets, &key->lExtraWorkSpace) + STAMPEXTRA;


	error = sfac_ComputeMapping (
		&key->ClientInfo,
		inputPtr->param.newsfnt.platformID,
		inputPtr->param.newsfnt.specificID);

	if(error != NO_ERR)
	{
		return (FS_ENTRY)error;
	}

	fs_SetState(key, (INITIALIZED | NEWSFNT));

	/*
	 *  Can't run font program yet, we don't have any memory for the
	 *  graphic state. Mark it to be run in NewTransformation.
	 */

	key->bExecuteFontPgm = TRUE;

	CHECKSTAMP (inputPtr->memoryBases[KEY_PTR_BASE] + outputPtr->memorySizes[KEY_PTR_BASE]);

	STAT_OFF_NEWSFNT;                /* stop STAT timer */

	return NO_ERR;
}

FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_NewTransformNoGridFit (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
{
	return fs__NewTransformation (inputPtr, outputPtr, FALSE);
}


FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_NewTransformation (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
{
	return fs__NewTransformation (inputPtr, outputPtr, TRUE);
}


FS_PRIVATE int32 fs__NewTransformation (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr, boolean useHints)
{
	void *          pvGlobalGS;
	void *          pvStack;
	void *          pvTwilightZone;
	void *          pvFontProgram;
	void *          pvPreProgram;
	ErrorCode       error;
	fs_SplineKey *  key;
	int16			xOverResolution;
#ifdef FSCFG_SUBPIXEL
	void *          pvGlobalGSSubPixel;
    uint16          flSubPixelHintFlag;
	void *          pvTwilightZoneSubPixel;
#endif // FSCFG_SUBPIXEL
   	uint16            usPPEMX;                  /* for sbits */
	uint16            usPPEMY; 
    uint16            usRotation;

	if((inputPtr->memoryBases[WORK_SPACE_BASE] == NULL) ||
	   (inputPtr->memoryBases[PRIVATE_FONT_SPACE_BASE] == NULL))
	{
		return NULL_MEMORY_BASES_ERR;
	}
	CHECKSTAMP (inputPtr->memoryBases[KEY_PTR_BASE] + outputPtr->memorySizes[KEY_PTR_BASE]);

	SETSTAMP (inputPtr->memoryBases[WORK_SPACE_BASE] + outputPtr->memorySizes[WORK_SPACE_BASE]);
	SETSTAMP (inputPtr->memoryBases[PRIVATE_FONT_SPACE_BASE] + outputPtr->memorySizes[PRIVATE_FONT_SPACE_BASE]);

	STAT_ON_NEWTRAN;                 /* start STAT timer */

	key = fs_SetUpKey(inputPtr, (INITIALIZED | NEWSFNT), &error);

	if(!key)
	{
		return (FS_ENTRY)error;
	}


	if ((key->ulState & NEWTRANS) != 0)
	{

		if ((key->SavedTransformInfo.pointSize == inputPtr->param.newtrans.pointSize) &&
			(key->SavedTransformInfo.xResolution == inputPtr->param.newtrans.xResolution) &&
			(key->SavedTransformInfo.yResolution == inputPtr->param.newtrans.yResolution) &&
			(key->SavedTransformInfo.transformMatrix.transform[0][0] == inputPtr->param.newtrans.transformMatrix->transform[0][0]) &&
			(key->SavedTransformInfo.transformMatrix.transform[1][1] == inputPtr->param.newtrans.transformMatrix->transform[1][1]) &&
			(key->SavedTransformInfo.transformMatrix.transform[1][0] == inputPtr->param.newtrans.transformMatrix->transform[1][0]) &&
			(key->SavedTransformInfo.transformMatrix.transform[0][1] == inputPtr->param.newtrans.transformMatrix->transform[0][1]) &&
			(key->SavedTransformInfo.transformMatrix.transform[2][0] == inputPtr->param.newtrans.transformMatrix->transform[2][0]) &&
			(key->SavedTransformInfo.transformMatrix.transform[2][1] == inputPtr->param.newtrans.transformMatrix->transform[2][1]) &&
			(key->SavedTransformInfo.transformMatrix.transform[2][2] == inputPtr->param.newtrans.transformMatrix->transform[2][2]) &&
			(key->SavedTransformInfo.usOverScale == inputPtr->param.newtrans.usOverScale) &&
			(key->SavedTransformInfo.bHintAtEmSquare == inputPtr->param.newtrans.bHintAtEmSquare) &&
			(key->SavedTransformInfo.flSubPixel == inputPtr->param.newtrans.flSubPixel) &&
			(key->SavedTransformInfo.usEmboldWeightx == inputPtr->param.newtrans.usEmboldWeightx) &&
			(key->SavedTransformInfo.usEmboldWeighty == inputPtr->param.newtrans.usEmboldWeighty) &&
			(key->SavedTransformInfo.lDescDev == inputPtr->param.newtrans.lDescDev) &&
			(key->SavedTransformInfo.bBitmapEmboldening == inputPtr->param.newtrans.bBitmapEmboldening) &&
			(key->TransformInfo.fxPixelDiameter  == inputPtr->param.newtrans.pixelDiameter)
			)
		{
			/* set the subpixel position, we want to ingnore difference in those fields */
			key->TransformInfo.currentTMatrix.transform[0][2] = inputPtr->param.newtrans.transformMatrix->transform[0][2];
			key->TransformInfo.currentTMatrix.transform[1][2] = inputPtr->param.newtrans.transformMatrix->transform[1][2];
			/* we have the same transformation except for the subpixel position, we don't
			   need to do anything more */
			return (FS_ENTRY)error;
		}
		else
		{
			// clear the flag for safety in case we get an error during fs__NewTransformation
			key->ulState &= ~NEWTRANS;
		}
	}

    key->bHintingEnabled = useHints;

	fsg_UpdateWorkSpaceAddresses(
		key->memoryBases[WORK_SPACE_BASE],
		&(key->WorkSpaceOffsets),
		&(key->pWorkSpaceAddr));

	fsg_UpdateWorkSpaceElement(
		&(key->WorkSpaceOffsets),
		&(key->pWorkSpaceAddr));

	pvStack = fsg_QueryStack(&key->pWorkSpaceAddr);

	fsg_UpdatePrivateSpaceAddresses(
		&key->ClientInfo,
		&key->maxProfile,
		key->memoryBases[PRIVATE_FONT_SPACE_BASE],
		&(key->PrivateSpaceOffsets),
		pvStack,
		&pvFontProgram,
		&pvPreProgram);

	pvGlobalGS = fsg_QueryGlobalGS(
		key->memoryBases[PRIVATE_FONT_SPACE_BASE],
		&(key->PrivateSpaceOffsets));

	pvTwilightZone = fsg_QueryTwilightElement(
		key->memoryBases[PRIVATE_FONT_SPACE_BASE],
		&(key->PrivateSpaceOffsets));

	MEMCPY(key->apbPrevMemoryBases, key->memoryBases, sizeof(char *) * (size_t)MEMORYFRAGMENTS);

	key->bExecutePrePgm = (boolean) !inputPtr->param.newtrans.traceFunc;

    if (!key->bHintingEnabled)
    {
        /* if fs_NewTransformNoGridFit was called, we disabled hinting : */
        key->bExecutePrePgm = TRUE;
        key->bExecuteFontPgm = FALSE;
    }

    /* Load the font program and pre program if necessary */

	if (key->bExecuteFontPgm)
	{
		error = sfac_CopyFontAndPrePrograms(
			&key->ClientInfo,
			(char *)pvFontProgram,
			(char *)pvPreProgram);

		if(error)
		{
			return (FS_ENTRY)error;
		}
	}

	key->TransformInfo.currentTMatrix = *inputPtr->param.newtrans.transformMatrix;
	key->TransformInfo.fxPixelDiameter  = inputPtr->param.newtrans.pixelDiameter;

	key->SavedTransformInfo.pointSize = inputPtr->param.newtrans.pointSize;
	key->SavedTransformInfo.xResolution = inputPtr->param.newtrans.xResolution;
	key->SavedTransformInfo.yResolution = inputPtr->param.newtrans.yResolution;
	key->SavedTransformInfo.transformMatrix  = *inputPtr->param.newtrans.transformMatrix;
	key->SavedTransformInfo.usOverScale = inputPtr->param.newtrans.usOverScale;
	key->SavedTransformInfo.usEmboldWeightx = inputPtr->param.newtrans.usEmboldWeightx;
	key->SavedTransformInfo.usEmboldWeighty = inputPtr->param.newtrans.usEmboldWeighty;
	key->SavedTransformInfo.lDescDev = inputPtr->param.newtrans.lDescDev;
	key->SavedTransformInfo.bBitmapEmboldening = inputPtr->param.newtrans.bBitmapEmboldening;
	key->SavedTransformInfo.flSubPixel = inputPtr->param.newtrans.flSubPixel;
	key->SavedTransformInfo.bHintAtEmSquare = inputPtr->param.newtrans.bHintAtEmSquare;

	xOverResolution = inputPtr->param.newtrans.xResolution;

#ifdef FSCFG_SUBPIXEL
    /* convert from external client flags to internal flags */
    key->flSubPixel = 0;
	if (inputPtr->param.newtrans.flSubPixel & SP_SUB_PIXEL)
    {
        key->flSubPixel |= FNT_SP_SUB_PIXEL;
    }
	if (inputPtr->param.newtrans.flSubPixel & SP_COMPATIBLE_WIDTH)
    {
        /* compatible width is disabled under rotation but kept under italization */
        if (key->TransformInfo.currentTMatrix.transform[0][1] == 0)
        {
            key->flSubPixel |= FNT_SP_COMPATIBLE_WIDTH;
        }
    }
	if (inputPtr->param.newtrans.flSubPixel & SP_VERTICAL_DIRECTION)
    {
        key->flSubPixel |= FNT_SP_VERTICAL_DIRECTION;
    }
	if (inputPtr->param.newtrans.flSubPixel & SP_SUB_PIXEL && key->TransformInfo.currentTMatrix.transform[0][0] == 0) {
	// we have a combination of rotation and/or mirroring which swaps the roles of the x- and y-axis
		key->flSubPixel ^= FNT_SP_VERTICAL_DIRECTION;
	}
	
	if (inputPtr->param.newtrans.flSubPixel & SP_BGR_ORDER)
    {
        key->flSubPixel |= FNT_SP_BGR_ORDER;
    }
	
    flSubPixelHintFlag = 0;

	if (((key->flSubPixel & FNT_SP_SUB_PIXEL) && (key->SavedTransformInfo.usOverScale != 0) ) || 
        (((key->flSubPixel & FNT_SP_COMPATIBLE_WIDTH) || (key->flSubPixel & FNT_SP_VERTICAL_DIRECTION) || (key->flSubPixel & FNT_SP_BGR_ORDER)) && !(key->flSubPixel & FNT_SP_SUB_PIXEL)))
	{
		/*****
		We do not yet allow a combination of SubPixel and Gray antialiazing
        The following table lists legal combinations of flags in flSubPixel:

		SubPixel	CompWidth	VertDirect	BGROrder	Comment
			No			No			No			No		b/w
			No			No			No			Yes		Illegal to ask for BGR order without asking for SubPixel
			No			No			Yes			No		Illegal to ask for vertical direction without asking for SubPixel
			No			No			Yes			Yes		Illegal by disjunctive combination
			No			Yes			No			No		Illegal to ask for compatible width without asking for SubPixel 
			No			Yes			No			Yes		Illegal by disjunctive combination 
			No			Yes			Yes			No		Illegal by disjunctive combination
			No			Yes			Yes			Yes		Illegal by disjunctive combination
			Yes			No			No			No		Plain SubPixel horizontal direction RGB
			Yes			No			No			Yes		Plain SubPixel horizontal direction BGR
			Yes			No			Yes			No		Plain SubPixel vertical direction RGB
			Yes			No			Yes			Yes		Plain SubPixel vertical direction BGR
			Yes			Yes			No			No		b/w compatible advance width SubPixel horizontal direction RGB
			Yes			Yes			No			Yes		b/w compatible advance width SubPixel horizontal direction BGR
			Yes			Yes			Yes			No		b/w compatible advance width SubPixel vertical direction RGB
			Yes			Yes			Yes			Yes		b/w compatible advance width SubPixel vertical direction BGR
		
		Note that it could be argued that in vertical direction RGB|BGR, advance widths should be b/w compatible
		by nature, because we are not rounding any x-direction positions and distances any differently than
		in b/w. However, with vertical direction RGB, a glyph may assume a height that is closer to its natural
		height than what it would in b/w, and as a result may seem too narrow or too wide, which in turn would
		call for a correction in x, specific to SubPixel with vertical direction RGB and potentially making the
		advance width incompatible. Therefore, we allow the last two combinations of flags.
		*****/

		return BAD_GRAY_LEVEL_ERR;
	}
	
	if ((key->flSubPixel & FNT_SP_SUB_PIXEL))
    {
        if (key->flSubPixel & FNT_SP_COMPATIBLE_WIDTH)
        {
	        pvGlobalGSSubPixel = fsg_QueryGlobalGSSubPixel(
		        key->memoryBases[PRIVATE_FONT_SPACE_BASE],
		        &(key->PrivateSpaceOffsets));
	        pvTwilightZoneSubPixel = fsg_QueryTwilightElementSubPixel(
		        key->memoryBases[PRIVATE_FONT_SPACE_BASE],
		        &(key->PrivateSpaceOffsets));
            key->TransformInfoSubPixel = key->TransformInfo;
        } else
        {
            xOverResolution = xOverResolution * HINTING_HOR_OVERSCALE;
            flSubPixelHintFlag = key->flSubPixel;
        }

    }
#endif // FSCFG_SUBPIXEL

	if (key->SavedTransformInfo.usOverScale != 0 && 
			(((1 << (key->SavedTransformInfo.usOverScale - 1)) & FS_GRAY_VALUE_MASK) == 0) || key->SavedTransformInfo.usOverScale> 31)
	{
		return BAD_GRAY_LEVEL_ERR;
	}


	key->bGrayScale = (key->SavedTransformInfo.usOverScale == 0) ? FALSE : TRUE;
	fsg_SetHintFlags(pvGlobalGS, key->bGrayScale
#ifdef FSCFG_SUBPIXEL
	    ,flSubPixelHintFlag
#endif // FSCFG_SUBPIXEL
        );

	error = fsg_InitInterpreterTrans (
		&key->TransformInfo,
		pvGlobalGS,
		inputPtr->param.newtrans.pointSize,
#ifdef FSCFG_SUBPIXEL
        xOverResolution,
#else
		inputPtr->param.newtrans.xResolution,
#endif // FSCFG_SUBPIXEL
		inputPtr->param.newtrans.yResolution,
		inputPtr->param.newtrans.bHintAtEmSquare,
		inputPtr->param.newtrans.usEmboldWeightx ,
		inputPtr->param.newtrans.usEmboldWeighty,
		key->ClientInfo.sWinDescender,
		inputPtr->param.newtrans.lDescDev,
		&key->sBoldSimulHorShift,
		&key->sBoldSimulVertShift );

#ifdef FSCFG_SUBPIXEL
	if ((key->flSubPixel & FNT_SP_COMPATIBLE_WIDTH))
    {
	    fsg_SetHintFlags(pvGlobalGSSubPixel, key->bGrayScale, key->flSubPixel);

	    error = fsg_InitInterpreterTrans (
		    &key->TransformInfoSubPixel,
		    pvGlobalGSSubPixel,
		    inputPtr->param.newtrans.pointSize,
		    (int16)(xOverResolution * HINTING_HOR_OVERSCALE),
		    inputPtr->param.newtrans.yResolution,
		    inputPtr->param.newtrans.bHintAtEmSquare,
		    inputPtr->param.newtrans.usEmboldWeightx ,
		    inputPtr->param.newtrans.usEmboldWeighty,
		    key->ClientInfo.sWinDescender,
		    inputPtr->param.newtrans.lDescDev,
		    &key->sBoldSimulHorShift,
		    &key->sBoldSimulVertShift  );
    }
#endif // FSCFG_SUBPIXEL

	if(error)
	{
		return (FS_ENTRY)error;
	}

	if (key->bExecuteFontPgm)
	{
		error = fsg_RunFontProgram (pvGlobalGS, &key->pWorkSpaceAddr, pvTwilightZone,
									inputPtr->param.newtrans.traceFunc);

		if(error)
		{
			return (FS_ENTRY)error;
		}

        key->bExecuteFontPgm = FALSE;
	}

#ifdef FSCFG_SUBPIXEL
	if ((key->flSubPixel & FNT_SP_COMPATIBLE_WIDTH))
    {
		fsg_CopyFontProgramResults (pvGlobalGS, pvGlobalGSSubPixel);
    }
#endif // FSCFG_SUBPIXEL

	if (!key->bExecutePrePgm)
	{

		/* Do this now so we do not confuse font editors    */
		/* Run the pre program and scale the control value table */
		/* Sets key->bExecutePrePgm to false          */

		error = fsg_RunPreProgram (
			&key->ClientInfo,
			&key->maxProfile,
			&key->TransformInfo,
			pvGlobalGS,
			&key->pWorkSpaceAddr,
			pvTwilightZone,
			inputPtr->param.newtrans.traceFunc);

		if(error)
		{
			/* If the pre-program fails, switch off hinting for further glyphs */
			key->bHintingEnabled = FALSE;
			return (FS_ENTRY)error;
		}
#ifdef FSCFG_SUBPIXEL
	    if ((key->flSubPixel & FNT_SP_COMPATIBLE_WIDTH))
        {
		    error = fsg_RunPreProgram (
			    &key->ClientInfo,
			    &key->maxProfile,
			    &key->TransformInfoSubPixel,
			    pvGlobalGSSubPixel,
			    &key->pWorkSpaceAddr,
			    pvTwilightZoneSubPixel,
			    inputPtr->param.newtrans.traceFunc);

		    if(error)
		    {
			    /* If the pre-program fails, switch off hinting for further glyphs */
			    key->bHintingEnabled = FALSE;
			    return (FS_ENTRY)error;
		    }
        }
#endif // FSCFG_SUBPIXEL
	}

	fsg_GetScaledCVT(
		key->memoryBases[PRIVATE_FONT_SPACE_BASE],
		&key->PrivateSpaceOffsets,
		&outputPtr->scaledCVT);

    fsg_QueryPPEMXY(pvGlobalGS, &key->TransformInfo, 
	            &usPPEMX, &usPPEMY, &usRotation);

	error = sbit_NewTransform(&key->SbitMono,key->TransformInfo.usEmResolution,
		key->sBoldSimulHorShift, key->sBoldSimulVertShift, usPPEMX, usPPEMY, usRotation);      /* setup for sbits */
	
	if(error)
	{
		return (FS_ENTRY)error;
	}

	fs_SetState(key, (INITIALIZED | NEWSFNT | NEWTRANS));

	CHECKSTAMP (inputPtr->memoryBases[KEY_PTR_BASE] + outputPtr->memorySizes[KEY_PTR_BASE]);
	CHECKSTAMP (inputPtr->memoryBases[WORK_SPACE_BASE] + outputPtr->memorySizes[WORK_SPACE_BASE]);
	CHECKSTAMP (inputPtr->memoryBases[PRIVATE_FONT_SPACE_BASE] + outputPtr->memorySizes[PRIVATE_FONT_SPACE_BASE]);

	STAT_OFF_NEWTRAN;             /* stop STAT timer */

	return NO_ERR;
}


/*
 * Compute the glyph index from the character code.
 */

FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_NewGlyph (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
{
	ErrorCode         error;
	fs_SplineKey *    key;
	void *            pvGlobalGS;
	uint16			  usBitDepth;			/* 1 for B/W bitmap, 2, 4 or 8 for gray sbit */

	if((inputPtr->memoryBases[WORK_SPACE_BASE] == NULL) ||
	   (inputPtr->memoryBases[PRIVATE_FONT_SPACE_BASE] == NULL))
	{
		return NULL_MEMORY_BASES_ERR;
	}
	CHECKSTAMP (inputPtr->memoryBases[KEY_PTR_BASE] + outputPtr->memorySizes[KEY_PTR_BASE]);
	CHECKSTAMP (inputPtr->memoryBases[WORK_SPACE_BASE] + outputPtr->memorySizes[WORK_SPACE_BASE]);
	CHECKSTAMP (inputPtr->memoryBases[PRIVATE_FONT_SPACE_BASE] + outputPtr->memorySizes[PRIVATE_FONT_SPACE_BASE]);

	STAT_ON_NEWGLYPH;                /* start STAT timer */

	key = fs_SetUpKey(inputPtr, (INITIALIZED | NEWSFNT | NEWTRANS), &error);

	if(!key)
	{
		return (FS_ENTRY)error;
	}

	if (inputPtr->param.newglyph.characterCode != NONVALID)
	{
		error = sfac_GetGlyphIndex(
			&key->ClientInfo,
			inputPtr->param.newglyph.characterCode);

		if(error)
		{
			return (FS_ENTRY)error;
		}

		outputPtr->numberOfBytesTaken = 2;  /*  !!!DISCUSS  */
		outputPtr->glyphIndex = key->ClientInfo.usGlyphIndex;
	}
	else
	{
		key->ClientInfo.usGlyphIndex = inputPtr->param.newglyph.glyphIndex;
		outputPtr->glyphIndex =        inputPtr->param.newglyph.glyphIndex;
		outputPtr->numberOfBytesTaken = 0;
	}

	if( key->ClientInfo.usGlyphIndex > key->maxProfile.numGlyphs - 1)
	{
		return INVALID_GLYPH_INDEX;
	}

	pvGlobalGS = fsg_QueryGlobalGS(
		key->memoryBases[PRIVATE_FONT_SPACE_BASE],
		&(key->PrivateSpaceOffsets));

	key->bEmbeddedBitmap = !inputPtr->param.newglyph.bNoEmbeddedBitmap; /* read input param */

	key->bMatchBBox = inputPtr->param.newglyph.bMatchBBox;

	if (inputPtr->param.newglyph.bNoEmbeddedBitmap)
	{
		outputPtr->usBitmapFound = FALSE;
	} else {
		error = sbit_SearchForBitmap(
			&key->SbitMono,
			&key->ClientInfo,
			key->ClientInfo.usGlyphIndex,
			key->SavedTransformInfo.usOverScale,
			&usBitDepth,
			&outputPtr->usBitmapFound );
	
		if(error)
		{
			return (FS_ENTRY)error;
		}

	}

	if (key->SavedTransformInfo.usOverScale == 0)
	{
		outputPtr->usGrayLevels = 0; 
		/* usGrayLevels == 0 means 1 bit per pixel */
	} else {
#ifndef FSCFG_CONVERT_GRAY_LEVELS
		if(outputPtr->usBitmapFound)
		{
			outputPtr->usGrayLevels = 0x01 << usBitDepth;
		} else {
#endif // FSCFG_CONVERT_GRAY_LEVELS
			outputPtr->usGrayLevels = key->SavedTransformInfo.usOverScale * key->SavedTransformInfo.usOverScale + 1;
#ifndef FSCFG_CONVERT_GRAY_LEVELS
		}
#endif // FSCFG_CONVERT_GRAY_LEVELS
	}

	key->bEmbeddedBitmap = outputPtr->usBitmapFound;

#ifdef FSCFG_SUBPIXEL
	if ((key->flSubPixel & FNT_SP_SUB_PIXEL))
	{
		outputPtr->usBitmapFound = FALSE;
	}
#endif // FSCFG_SUBPIXEL

	/* clear all other bits */

	fs_SetState(key, (INITIALIZED | NEWSFNT | NEWTRANS | GOTINDEX));

	CHECKSTAMP (inputPtr->memoryBases[KEY_PTR_BASE] + outputPtr->memorySizes[KEY_PTR_BASE]);
	CHECKSTAMP (inputPtr->memoryBases[WORK_SPACE_BASE] + outputPtr->memorySizes[WORK_SPACE_BASE]);
	CHECKSTAMP (inputPtr->memoryBases[PRIVATE_FONT_SPACE_BASE] + outputPtr->memorySizes[PRIVATE_FONT_SPACE_BASE]);

	STAT_OFF_NEWGLYPH;                   /* stop STAT timer */

	return NO_ERR;
}


/*
 * this call is optional.
 *
 * can be called right after fs_NewGlyph ()
 */

FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_GetAdvanceWidth (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
{
	ErrorCode       error;
	int16           sNonScaledLSB;
	fs_SplineKey *  key;
	void *          pvGlobalGS;

	key = fs_SetUpKey(inputPtr, (INITIALIZED | NEWSFNT | NEWTRANS | GOTINDEX), &error);

	if(!key)
	{
		return (FS_ENTRY)error;
	}

	pvGlobalGS = fsg_QueryGlobalGS(
		key->memoryBases[PRIVATE_FONT_SPACE_BASE],
		&(key->PrivateSpaceOffsets));

	error = sfac_ReadGlyphHorMetrics (
		&key->ClientInfo,
		key->ClientInfo.usGlyphIndex,
		&key->usNonScaledAW,
		&sNonScaledLSB);

	if(error)
	{
		return (FS_ENTRY)error;
	}

	fsg_UpdateAdvanceWidth (&key->TransformInfo, pvGlobalGS, key->usNonScaledAW,
		&outputPtr->metricInfo.advanceWidth);

#ifdef FSCFG_SUBPIXEL
	if ((key->flSubPixel & FNT_SP_SUB_PIXEL) && !(key->flSubPixel & FNT_SP_COMPATIBLE_WIDTH) )
	{
        /* in the SubPixel mode, key->TransformInfo is overscaled when we don't ask for compatible width */
	    ROUND_FROM_HINT_OVERSCALE(outputPtr->metricInfo.advanceWidth.x);
	}
#endif // FSCFG_SUBPIXEL
	return NO_ERR;
}

/*
 * this call is optional.
 *
 * can be called right after fs_NewGlyph ()
 */

FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_GetAdvanceHeight (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
{
	ErrorCode       error;
	int16           sNonScaledTSB;
	fs_SplineKey *  key;
	void *          pvGlobalGS;

	key = fs_SetUpKey(inputPtr, (INITIALIZED | NEWSFNT | NEWTRANS | GOTINDEX), &error);

	if(!key)
	{
		return (FS_ENTRY)error;
	}

	pvGlobalGS = fsg_QueryGlobalGS(
		key->memoryBases[PRIVATE_FONT_SPACE_BASE],
		&(key->PrivateSpaceOffsets));


	error = sfac_ReadGlyphVertMetrics (
		&key->ClientInfo,
		key->ClientInfo.usGlyphIndex,
		&key->usNonScaledAH,
		&sNonScaledTSB);

	if(error)
	{
		return (FS_ENTRY)error;
	}

	fsg_UpdateAdvanceHeight (&key->TransformInfo, pvGlobalGS, key->usNonScaledAH,
		&outputPtr->verticalMetricInfo.advanceHeight);

#ifdef FSCFG_SUBPIXEL	
	if ((key->flSubPixel & FNT_SP_SUB_PIXEL) && !(key->flSubPixel & FNT_SP_COMPATIBLE_WIDTH) )
	{
        /* in the SubPixel mode, key->TransformInfo is overscaled when we don't ask for compatible width */
	    ROUND_FROM_HINT_OVERSCALE(outputPtr->verticalMetricInfo.advanceHeight.x);
	}
#endif
    return NO_ERR;
}

FS_PRIVATE int32 fs__Contour (fs_GlyphInputType*inputPtr, fs_GlyphInfoType*outputPtr, boolean useHints)
{
	ErrorCode       error;
	void *          pvGlobalGS;
	fs_SplineKey *  key;
	point           f26DevAdvanceWidth;
	point           f26DevAdvanceHeight;
	void *          pvTwilightZone;
	void *          pvStack;
	void *          pvFontProgram;
	void *          pvPreProgram;
#ifdef FSCFG_SUBPIXEL	
	void *          pvGlobalGSSubPixel;
	void *          pvTwilightZoneSubPixel;
	boolean         bSubPixelWidth = FALSE;
#endif // FSCFG_SUBPIXEL

	if((inputPtr->memoryBases[WORK_SPACE_BASE] == NULL) ||
	   (inputPtr->memoryBases[PRIVATE_FONT_SPACE_BASE] == NULL))
	{
		return NULL_MEMORY_BASES_ERR;
	}

	CHECKSTAMP (inputPtr->memoryBases[KEY_PTR_BASE] + outputPtr->memorySizes[KEY_PTR_BASE]);
	CHECKSTAMP (inputPtr->memoryBases[WORK_SPACE_BASE] + outputPtr->memorySizes[WORK_SPACE_BASE]);
	CHECKSTAMP (inputPtr->memoryBases[PRIVATE_FONT_SPACE_BASE] + outputPtr->memorySizes[PRIVATE_FONT_SPACE_BASE]);

	STAT_ON_GRIDFIT;                 /* start STAT timer */

	key = fs_SetUpKey(inputPtr, (INITIALIZED | NEWSFNT | NEWTRANS | GOTINDEX), &error);

	if(!key)
	{
		return (FS_ENTRY)error;
	}

	if((key->apbPrevMemoryBases[WORK_SPACE_BASE] != key->memoryBases[WORK_SPACE_BASE]) ||
	   (key->apbPrevMemoryBases[PRIVATE_FONT_SPACE_BASE] != key->memoryBases[PRIVATE_FONT_SPACE_BASE]))
	{
		fsg_UpdateWorkSpaceAddresses(
			key->memoryBases[WORK_SPACE_BASE],
			&(key->WorkSpaceOffsets),
			&(key->pWorkSpaceAddr));

		pvStack = fsg_QueryStack(&key->pWorkSpaceAddr);

		fsg_UpdatePrivateSpaceAddresses(
			&key->ClientInfo,
			&key->maxProfile,
			key->memoryBases[PRIVATE_FONT_SPACE_BASE],
			&(key->PrivateSpaceOffsets),
			pvStack,
			&pvFontProgram,
			&pvPreProgram);

		MEMCPY(key->apbPrevMemoryBases, key->memoryBases, sizeof(char *) * (size_t)MEMORYFRAGMENTS);
	}

	/* The element data structures need to be updated here because if the    */
	/* WorkSpace memory is shared, the pointers will not be correct. Since  */
	/* fs_Contour[No]GridFit - fs_ContourScan must have the same shared      */
	/* base, these address do not have to be updated explicitly between      */
	/* each call, only if the memory base has physically moved.              */

	fsg_UpdateWorkSpaceElement(
		&(key->WorkSpaceOffsets),
		&(key->pWorkSpaceAddr));

	pvGlobalGS = fsg_QueryGlobalGS(
		key->memoryBases[PRIVATE_FONT_SPACE_BASE],
		&(key->PrivateSpaceOffsets));

#ifdef FSCFG_SUBPIXEL	
	if ((key->flSubPixel & FNT_SP_COMPATIBLE_WIDTH))
    {
	    pvGlobalGSSubPixel = fsg_QueryGlobalGSSubPixel(
		    key->memoryBases[PRIVATE_FONT_SPACE_BASE],
		    &(key->PrivateSpaceOffsets));
	    pvTwilightZoneSubPixel = fsg_QueryTwilightElementSubPixel(
		    key->memoryBases[PRIVATE_FONT_SPACE_BASE],
		    &(key->PrivateSpaceOffsets));
    }

	if ( (key->flSubPixel & FNT_SP_SUB_PIXEL) && !(key->flSubPixel & FNT_SP_COMPATIBLE_WIDTH) ) 
    {
        bSubPixelWidth = TRUE;
    }
#endif // FSCFG_SUBPIXEL

	pvTwilightZone = fsg_QueryTwilightElement(
		key->memoryBases[PRIVATE_FONT_SPACE_BASE],
		&(key->PrivateSpaceOffsets));

    if (!key->bHintingEnabled)
    {
        /* if fs_NewTransformNoGridFit was called, we disabled hinting : */
        key->bExecutePrePgm = FALSE;
        useHints = FALSE;
    }

	/*  potentially do delayed pre program execution */

	if (key->bExecutePrePgm)
	{
		/* Run the pre program and scale the control value table */

		key->bExecutePrePgm = FALSE;

		error = fsg_RunPreProgram (
			&key->ClientInfo,
			&key->maxProfile,
			&key->TransformInfo,
			pvGlobalGS,
			&key->pWorkSpaceAddr,
			pvTwilightZone,
			NULL);

		if(error)
		{
			/* If the pre-program fails, switch off hinting for further glyphs */
			key->bHintingEnabled = FALSE;
			return (FS_ENTRY)error;
		}
#ifdef FSCFG_SUBPIXEL	
	    if ((key->flSubPixel & FNT_SP_COMPATIBLE_WIDTH))
        {
		    error = fsg_RunPreProgram (
			    &key->ClientInfo,
			    &key->maxProfile,
			    &key->TransformInfoSubPixel,
			    pvGlobalGSSubPixel,
			    &key->pWorkSpaceAddr,
			    pvTwilightZoneSubPixel,
			    NULL);

		    if(error)
		    {
			    /* If the pre-program fails, switch off hinting for further glyphs */
			    key->bHintingEnabled = FALSE;
			    return (FS_ENTRY)error;
		    }
	    }
#endif // FSCFG_SUBPIXEL	
	}

#ifdef FSCFG_SUBPIXEL
	if (inputPtr->param.gridfit.bSkipIfBitmap && key->bEmbeddedBitmap && !(key->flSubPixel & FNT_SP_SUB_PIXEL))
#else
	if (inputPtr->param.gridfit.bSkipIfBitmap && key->bEmbeddedBitmap)
#endif // FSCFG_SUBPIXEL	
	{
		key->bGridFitSkipped = TRUE;    /* disallow grayscale, outline caching, banding */
		
		error = sbit_GetDevAdvanceWidth (
			&key->SbitMono,
			&key->ClientInfo,
			&f26DevAdvanceWidth );
		
		if(error)
		{
			return (FS_ENTRY)error;
		}

		error = sbit_GetDevAdvanceHeight (
			&key->SbitMono,
			&key->ClientInfo,
			&f26DevAdvanceHeight );

		if(error)
		{
			return (FS_ENTRY)error;
		}

	}
	else                                /* if we're using the outline */
	{
		key->bGridFitSkipped = FALSE;   /* allow grayscale, outline caching, banding */

		/* THE CALL */

		error = fsg_GridFit (
			&key->ClientInfo,
			&key->maxProfile,
			&key->TransformInfo,
			pvGlobalGS,
			&key->pWorkSpaceAddr,
			pvTwilightZone,
			inputPtr->param.gridfit.traceFunc,
			useHints,
			&key->usScanType,
			&key->bGlyphHasOutline,
			&key->usNonScaledAW,
			key->SavedTransformInfo.bBitmapEmboldening
#ifdef FSCFG_SUBPIXEL
	        ,bSubPixelWidth
#endif // FSCFG_SUBPIXEL
			);

		if(error)
		{
			return (FS_ENTRY)error;
		}

#ifdef FSCFG_SUBPIXEL

        if (key->flSubPixel & FNT_SP_SUB_PIXEL) {
            Fixed   fxCompatibleWidthScale;
            F26Dot6 devAdvanceWidthX, devLeftSideBearingX, devRightSideBearingX;
            F26Dot6 horTranslation;
			
			/* default scale back factor if we don't need to adjust for compatible width
			   (FNT_SP_COMPATIBLE_WIDTH is set off under rotation at fs_NewTransformation) */
			
			fxCompatibleWidthScale = SUBPIXEL_SCALEBACK_FACTOR; 

            if (key->flSubPixel & FNT_SP_COMPATIBLE_WIDTH) {
				Fixed concertFactor;

				// compute the B/W glyph metrics
        	    if (key->bEmbeddedBitmap) {
		            error = sbit_CalcDevHorMetrics (&key->SbitMono,&key->ClientInfo,&devAdvanceWidthX,&devLeftSideBearingX,&devRightSideBearingX);
		            if(error)
		                return (FS_ENTRY)error;
				} else {
		            fsg_CalcDevHorMetrics(&key->pWorkSpaceAddr,&devAdvanceWidthX,&devLeftSideBearingX,&devRightSideBearingX);
                }

				if (key->usNonScaledAW) {
					concertFactor = FixDiv(devAdvanceWidthX,((fnt_GlobalGraphicStateType *)pvGlobalGS)->ScaleFuncX(
										   &((fnt_GlobalGraphicStateType *)pvGlobalGS)->scaleX,(F26Dot6)key->usNonScaledAW));
					if (concertFactor < 0) concertFactor = -concertFactor;
				} else {
					concertFactor = 0x10000; // Fixed 1.0 for 0 AW glyphs
				}
				((fnt_GlobalGraphicStateType *)pvGlobalGSSubPixel)->compatibleWidthStemConcertina = concertFactor;
				
				/* grid fit for the SubPixel overscale resolution */
		        error = fsg_GridFit (
			        &key->ClientInfo,
			        &key->maxProfile,
			        &key->TransformInfoSubPixel,
			        pvGlobalGSSubPixel,
			        &key->pWorkSpaceAddr,
			        pvTwilightZoneSubPixel,
			        inputPtr->param.gridfit.traceFunc,
			        useHints,
			        &key->usScanType,
			        &key->bGlyphHasOutline,
			        &key->usNonScaledAW,
			        key->SavedTransformInfo.bBitmapEmboldening,
			        (key->flSubPixel & FNT_SP_SUB_PIXEL)
			        );

		        if(error) {
			        return (FS_ENTRY)error;
		        }
			} // key->flSubPixel & FNT_SP_COMPATIBLE_WIDTH
			
			fsg_ScaleToCompatibleWidth(&key->pWorkSpaceAddr,fxCompatibleWidthScale);

			if (useHints && (key->flSubPixel & FNT_SP_COMPATIBLE_WIDTH)) {
				horTranslation = 0;
				fsg_AdjustCompatibleMetrics (
					&key->pWorkSpaceAddr,
					horTranslation,
					devAdvanceWidthX*RGB_OVERSCALE);
			}
		}
#endif // FSCFG_SUBPIXEL

        fsg_GetContourData(
			&key->pWorkSpaceAddr,
#ifdef FSCFG_SUBPIXEL
			(boolean)(key->flSubPixel & FNT_SP_SUB_PIXEL),            
#endif // FSCFG_SUBPIXEL
			&outputPtr->xPtr,
			&outputPtr->yPtr,
			&outputPtr->startPtr,
			&outputPtr->endPtr,
			&outputPtr->onCurve,
			&outputPtr->fc,
			&outputPtr->numberOfContours);

		fsg_GetDevAdvanceWidth(
			&key->pWorkSpaceAddr,
			&f26DevAdvanceWidth);

		fsg_GetDevAdvanceHeight(
			&key->pWorkSpaceAddr,
			&f26DevAdvanceHeight);
	}
	
	outputPtr->metricInfo.devAdvanceWidth.x = DOT6TOFIX(f26DevAdvanceWidth.x);
	outputPtr->metricInfo.devAdvanceWidth.y = DOT6TOFIX(f26DevAdvanceWidth.y);

	outputPtr->verticalMetricInfo.devAdvanceHeight.x = DOT6TOFIX(f26DevAdvanceHeight.x);
	outputPtr->verticalMetricInfo.devAdvanceHeight.y = DOT6TOFIX(f26DevAdvanceHeight.y);

#ifdef FSCFG_SUBPIXEL
	if ((key->flSubPixel & FNT_SP_SUB_PIXEL))
	{
		ROUND_FROM_RGB_OVERSCALE(outputPtr->metricInfo.devAdvanceWidth.x);
		ROUND_FROM_RGB_OVERSCALE(outputPtr->verticalMetricInfo.devAdvanceHeight.x);
	}
#endif // FSCFG_SUBPIXEL

	outputPtr->outlinesExist = (uint16)key->bGlyphHasOutline;

	fsg_GetScaledCVT(
		key->memoryBases[PRIVATE_FONT_SPACE_BASE],
		&key->PrivateSpaceOffsets,
		&outputPtr->scaledCVT);

	fs_SetState(key, (INITIALIZED | NEWSFNT | NEWTRANS | GOTINDEX | GOTGLYPH));

	CHECKSTAMP (inputPtr->memoryBases[KEY_PTR_BASE] + outputPtr->memorySizes[KEY_PTR_BASE]);
	CHECKSTAMP (inputPtr->memoryBases[WORK_SPACE_BASE] + outputPtr->memorySizes[WORK_SPACE_BASE]);
	CHECKSTAMP (inputPtr->memoryBases[PRIVATE_FONT_SPACE_BASE] + outputPtr->memorySizes[PRIVATE_FONT_SPACE_BASE]);

	STAT_OFF_GRIDFIT;             /* stop STAT timer */

	return NO_ERR;
}

FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_ContourNoGridFit (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
{
	return fs__Contour (inputPtr, outputPtr, FALSE);
}


FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_ContourGridFit (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
{
	return fs__Contour (inputPtr, outputPtr, TRUE);
}

/*********************************************************************/

/* Calculate scan conversion memory requirements                     */

FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_FindBitMapSize (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
{

	ErrorCode       error;
	BitMap *        pBMI;

	ContourList     CList;        /* newscan contour list type */
	void *          pvGlobalGS;
	fs_SplineKey *  key;

	point           f26DevAdvanceWidth;
	point           f26DevLeftSideBearing;
	point           f26LeftSideBearing;
	point           f26DevLeftSideBearingLine;
	point           f26LeftSideBearingLine;

	point           f26DevAdvanceHeight;
	point           f26DevTopSideBearing;
	point           f26TopSideBearing;
	point           f26DevTopSideBearingLine;
	point           f26TopSideBearingLine;

	int16           sOverScale;
	uint16          usRoundXMin;
	Rect *          pOrigB;             /* original outline bounding box */
	Rect *          pOverB;             /* over scaled outline bounding box */
	GlyphBitMap *   pOverG;             /* over scaled glyph bitmap struct */
	GlyphBitMap *   pGBMap;             /* orig or over pointer */
	
	uint16          usRowBytes;
	uint32          ulSbitOutSize;      /* sbit output memory */
	uint32          ulSbitWorkSize;     /* sbit workspace memory */
	int16           sNonScaledLSB;      /* for non-dev metrics calc */
	int16           sNonScaledTSB;      /* for non-dev metrics calc */
	int16           sNonScaledTopOriginX;      /* for non-dev metrics calc */
    int16           sBitmapEmboldeningHorExtra;      
	int16           sBitmapEmboldeningVertExtra;      

	if((inputPtr->memoryBases[WORK_SPACE_BASE] == NULL) ||
	   (inputPtr->memoryBases[PRIVATE_FONT_SPACE_BASE] == NULL))
	{
		return NULL_MEMORY_BASES_ERR;
	}

	CHECKSTAMP (inputPtr->memoryBases[KEY_PTR_BASE] + outputPtr->memorySizes[KEY_PTR_BASE]);
	CHECKSTAMP (inputPtr->memoryBases[WORK_SPACE_BASE] + outputPtr->memorySizes[WORK_SPACE_BASE]);
	CHECKSTAMP (inputPtr->memoryBases[PRIVATE_FONT_SPACE_BASE] + outputPtr->memorySizes[PRIVATE_FONT_SPACE_BASE]);

	STAT_ON_FINDBMS;                 /* start STAT timer */
	
	key = fs_SetUpKey(inputPtr, (INITIALIZED | NEWSFNT | NEWTRANS | GOTINDEX | GOTGLYPH), &error);
	if(!key)
	{
		return (FS_ENTRY)error;
	}

	if(key->apbPrevMemoryBases[WORK_SPACE_BASE] != key->memoryBases[WORK_SPACE_BASE])
	{
		  fsg_UpdateWorkSpaceAddresses(
				key->memoryBases[WORK_SPACE_BASE],
				&(key->WorkSpaceOffsets),
				&(key->pWorkSpaceAddr));
		
		  fsg_UpdateWorkSpaceElement(
				&(key->WorkSpaceOffsets),
				&(key->pWorkSpaceAddr));
		
		  MEMCPY(key->apbPrevMemoryBases, key->memoryBases, sizeof(char *) * (size_t)MEMORYFRAGMENTS);
	}

	pvGlobalGS = fsg_QueryGlobalGS(
		key->memoryBases[PRIVATE_FONT_SPACE_BASE],
		&(key->PrivateSpaceOffsets));

	pOrigB = &key->GBMap.rectBounds;    /* local copy of bounds pointer */

#ifdef FSCFG_SUBPIXEL
	if (key->bEmbeddedBitmap && !(key->flSubPixel & FNT_SP_SUB_PIXEL))  				/* if bitmap are not disabled */
#else
	if (key->bEmbeddedBitmap)  				/* if bitmap are not disabled */
#endif // FSCFG_SUBPIXEL	
	{
		error = sbit_GetMetrics (                   /* get device metrics */
			&key->SbitMono,
			&key->ClientInfo,
			&f26DevAdvanceWidth,
			&f26DevLeftSideBearing,
            &f26LeftSideBearing,
			&f26DevAdvanceHeight,
			&f26DevTopSideBearing,
			&f26TopSideBearing,
			pOrigB,
			&usRowBytes,
			&ulSbitOutSize,
			&ulSbitWorkSize );
		
		if (error != NO_ERR)
		{
			return(error);
		}
		
		outputPtr->metricInfo.devAdvanceWidth.x = DOT6TOFIX(f26DevAdvanceWidth.x);
		outputPtr->metricInfo.devAdvanceWidth.y = DOT6TOFIX(f26DevAdvanceWidth.y);
		outputPtr->metricInfo.devLeftSideBearing.x = DOT6TOFIX(f26DevLeftSideBearing.x);
		outputPtr->metricInfo.devLeftSideBearing.y = DOT6TOFIX(f26DevLeftSideBearing.y);
		outputPtr->metricInfo.leftSideBearing.x = DOT6TOFIX(f26LeftSideBearing.x);
		outputPtr->metricInfo.leftSideBearing.y = DOT6TOFIX(f26LeftSideBearing.y);
		
		outputPtr->verticalMetricInfo.devAdvanceHeight.x = DOT6TOFIX(f26DevAdvanceHeight.x);
		outputPtr->verticalMetricInfo.devAdvanceHeight.y = DOT6TOFIX(f26DevAdvanceHeight.y);
		outputPtr->verticalMetricInfo.devTopSideBearing.x = DOT6TOFIX(f26DevTopSideBearing.x);
		outputPtr->verticalMetricInfo.devTopSideBearing.y = DOT6TOFIX(f26DevTopSideBearing.y);
		outputPtr->verticalMetricInfo.topSideBearing.x = DOT6TOFIX(f26TopSideBearing.x);
		outputPtr->verticalMetricInfo.topSideBearing.y = DOT6TOFIX(f26TopSideBearing.y);
		
        /* just copy to 'Line' metrics */

		outputPtr->metricInfo.devLeftSideBearingLine.x = outputPtr->metricInfo.devLeftSideBearing.x;
		outputPtr->metricInfo.devLeftSideBearingLine.y = outputPtr->metricInfo.devLeftSideBearing.y;
		outputPtr->metricInfo.leftSideBearingLine.x = outputPtr->metricInfo.leftSideBearing.x;
		outputPtr->metricInfo.leftSideBearingLine.y = outputPtr->metricInfo.leftSideBearing.y;

		outputPtr->verticalMetricInfo.devTopSideBearingLine.x = outputPtr->verticalMetricInfo.devTopSideBearing.x;
		outputPtr->verticalMetricInfo.devTopSideBearingLine.y = outputPtr->verticalMetricInfo.devTopSideBearing.y;
		outputPtr->verticalMetricInfo.topSideBearingLine.x = outputPtr->verticalMetricInfo.topSideBearing.x;
		outputPtr->verticalMetricInfo.topSideBearingLine.y = outputPtr->verticalMetricInfo.topSideBearing.y;


	error = sfac_ReadGlyphMetrics (             /* get non-dev adv width */
			&key->ClientInfo,
			key->ClientInfo.usGlyphIndex,
			&key->usNonScaledAW,
			&key->usNonScaledAH,
			&sNonScaledLSB,
			&sNonScaledTSB,
            &sNonScaledTopOriginX);

		if(error != NO_ERR)
		{
			return error;
		}

		fsg_UpdateAdvanceWidth (
			&key->TransformInfo,                    /* scale the design adv width */
			pvGlobalGS, 
			key->usNonScaledAW,
			&outputPtr->metricInfo.advanceWidth );

		fsg_UpdateAdvanceHeight (
			&key->TransformInfo,                    /* scale the design adv height */
			pvGlobalGS, 
			key->usNonScaledAH,
			&outputPtr->verticalMetricInfo.advanceHeight );

		pBMI = &outputPtr->bitMapInfo;
		pBMI->bounds.left = pOrigB->left;               /* return bbox to client */
		pBMI->bounds.right = pOrigB->right;
		pBMI->bounds.top = pOrigB->bottom;              /* reversed! */
		pBMI->bounds.bottom = pOrigB->top;
		pBMI->rowBytes = (int16)usRowBytes;
		pBMI->baseAddr = 0L;

		outputPtr->memorySizes[BITMAP_PTR_1] = ulSbitOutSize;
		outputPtr->memorySizes[BITMAP_PTR_2] = ulSbitWorkSize;
		outputPtr->memorySizes[BITMAP_PTR_3] = 0L;
		outputPtr->memorySizes[BITMAP_PTR_4] = 0L;
	}
	else                                /* if rasterizing from a contour */
	{
		if (key->TransformInfo.bPhaseShift)
		{
			fsg_45DegreePhaseShift (&key->pWorkSpaceAddr);
		}

		fsg_GetContourData(
			&key->pWorkSpaceAddr,
#ifdef FSCFG_SUBPIXEL
			FALSE,            
#endif // FSCFG_SUBPIXEL
			&CList.afxXCoord,
			&CList.afxYCoord,
			&CList.asStartPoint,
			&CList.asEndPoint,
			&CList.abyOnCurve,
			&CList.abyFc,
			&CList.usContourCount);

		error = fsc_RemoveDups(&CList);                 /* collapse dup'd points */
		if (error != NO_ERR)
		{
			return(error);
		}

		pGBMap = &key->GBMap;                           /* default to usual structure */
		usRoundXMin = 1;

		if (key->bGrayScale)                                 /* if doing gray scale */
		{
			error = fsc_OverScaleOutline(&CList, key->SavedTransformInfo.usOverScale);
			if (error != NO_ERR)
			{
				return(error);
			}
			pGBMap = &key->OverGBMap;                   /* measure overscaled structure */
			usRoundXMin = key->SavedTransformInfo.usOverScale;
		}
		
		fsg_GetWorkSpaceExtra(
			key->memoryBases[WORK_SPACE_BASE],
			&(key->WorkSpaceOffsets),
			&(key->WScan.pchRBuffer));
		key->WScan.lRMemSize = key->lExtraWorkSpace;    /* use extra for MeasureGlyph workspace */
		
		if (key->SavedTransformInfo.bBitmapEmboldening) 
		{
			if (key->bGrayScale)                                 /* if doing gray scale */
			{
				sBitmapEmboldeningHorExtra = key->SavedTransformInfo.usOverScale * key->sBoldSimulHorShift;
				sBitmapEmboldeningVertExtra = key->SavedTransformInfo.usOverScale * key->sBoldSimulVertShift;
			} 
#ifdef FSCFG_SUBPIXEL
			else if ((key->flSubPixel & FNT_SP_SUB_PIXEL))
			{
				sBitmapEmboldeningHorExtra = RGB_OVERSCALE * key->sBoldSimulHorShift; 
				sBitmapEmboldeningVertExtra = key->sBoldSimulVertShift; 
			}
#endif // FSCFG_SUBPIXEL
			else
			{
				sBitmapEmboldeningHorExtra = key->sBoldSimulHorShift; 
				sBitmapEmboldeningVertExtra = key->sBoldSimulVertShift; 
			}
		}
		else
		{
			sBitmapEmboldeningHorExtra = 0;
			sBitmapEmboldeningVertExtra = 0;
		}

		error = fsc_MeasureGlyph(
			&CList, 
			pGBMap, 
			&key->WScan, 
			key->usScanType, 
			usRoundXMin,
			sBitmapEmboldeningHorExtra,
			sBitmapEmboldeningVertExtra );

		if (error == SMART_DROP_OVERFLOW_ERR)
		{
			/* glyph is too complex for the smart dropout control */
			key->usScanType &= ~SK_SMART;
			error = fsc_MeasureGlyph(
				&CList, 
				pGBMap, 
				&key->WScan, 
				key->usScanType, 
				usRoundXMin,
				sBitmapEmboldeningHorExtra,
				sBitmapEmboldeningVertExtra );
		}
		if (error != NO_ERR)
		{
			return(error);
		}
		Assert(key->WScan.lRMemSize < key->lExtraWorkSpace);
		
		if (key->bGrayScale)                                 /* if doing gray scale */
		{
			sOverScale = (int16)key->SavedTransformInfo.usOverScale;
			
			if (key->bMatchBBox)        /* if bounding box is fixed */
			{                                           /* the calc as if orig monochrome */
				pOverG = &key->OverGBMap;        
				pOrigB->left = (int16)((mth_DivShiftLong(pOverG->fxMinX, sOverScale) + 31L) >> 6);
				pOrigB->right = (int16)((mth_DivShiftLong(pOverG->fxMaxX, sOverScale) + 32L) >> 6);
				pOrigB->bottom = (int16)((mth_DivShiftLong(pOverG->fxMinY, sOverScale) + 31L) >> 6);
				pOrigB->top = (int16)((mth_DivShiftLong(pOverG->fxMaxY, sOverScale) + 32L) >> 6);

				/* force the bitmap to have at least one pixel wide and one pixel high */
				if (pOrigB->left == pOrigB->right)
				{
					pOrigB->right++;                                /* force 1 pixel wide */
				}
				if (pOrigB->bottom == pOrigB->top)
				{
					pOrigB->top++;                                /* force 1 pixel high */
				}

			}
			else                                        /* if bounding box can grow */
			{                                           /* then size to gray box */
				pOverB = &key->OverGBMap.rectBounds;        
				pOrigB->left = mth_DivShiftShort(pOverB->left, sOverScale);
				pOrigB->right = mth_DivShiftShort((int16)(pOverB->right + sOverScale - 1), sOverScale);
				pOrigB->bottom = mth_DivShiftShort(pOverB->bottom, sOverScale);
				pOrigB->top = mth_DivShiftShort((int16)(pOverB->top + sOverScale - 1), sOverScale);
			}
		}
		
		fsg_CalcLSBsAndAdvanceWidths(                   /* use original size for all metrics */
			&key->pWorkSpaceAddr,
			INTTODOT6(pOrigB->left),
			INTTODOT6(pOrigB->top),
			&f26DevAdvanceWidth,
			&f26DevLeftSideBearing,
			&f26LeftSideBearing,
			&f26DevLeftSideBearingLine,
			&f26LeftSideBearingLine);

		outputPtr->metricInfo.devAdvanceWidth.x        = DOT6TOFIX(f26DevAdvanceWidth.x);
		outputPtr->metricInfo.devAdvanceWidth.y        = DOT6TOFIX(f26DevAdvanceWidth.y);
		outputPtr->metricInfo.devLeftSideBearing.x     = DOT6TOFIX(f26DevLeftSideBearing.x);
		outputPtr->metricInfo.devLeftSideBearing.y     = DOT6TOFIX(f26DevLeftSideBearing.y);
		outputPtr->metricInfo.leftSideBearing.x        = DOT6TOFIX(f26LeftSideBearing.x);
		outputPtr->metricInfo.leftSideBearing.y        = DOT6TOFIX(f26LeftSideBearing.y);
		outputPtr->metricInfo.devLeftSideBearingLine.x = DOT6TOFIX(f26DevLeftSideBearingLine.x);
		outputPtr->metricInfo.devLeftSideBearingLine.y = DOT6TOFIX(f26DevLeftSideBearingLine.y);
		outputPtr->metricInfo.leftSideBearingLine.x    = DOT6TOFIX(f26LeftSideBearingLine.x);
		outputPtr->metricInfo.leftSideBearingLine.y    = DOT6TOFIX(f26LeftSideBearingLine.y);

		fsg_CalcTSBsAndAdvanceHeights(                   /* use original size for all metrics */
			&key->pWorkSpaceAddr,
			INTTODOT6(pOrigB->left),
			INTTODOT6(pOrigB->top),
			&f26DevAdvanceHeight,
			&f26DevTopSideBearing,
			&f26TopSideBearing,
			&f26DevTopSideBearingLine,
			&f26TopSideBearingLine);

		outputPtr->verticalMetricInfo.devAdvanceHeight.x      = DOT6TOFIX(f26DevAdvanceHeight.x);
		outputPtr->verticalMetricInfo.devAdvanceHeight.y      = DOT6TOFIX(f26DevAdvanceHeight.y);
		outputPtr->verticalMetricInfo.devTopSideBearing.x     = DOT6TOFIX(f26DevTopSideBearing.x);
		outputPtr->verticalMetricInfo.devTopSideBearing.y     = DOT6TOFIX(f26DevTopSideBearing.y);
		outputPtr->verticalMetricInfo.topSideBearing.x        = DOT6TOFIX(f26TopSideBearing.x);
		outputPtr->verticalMetricInfo.topSideBearing.y        = DOT6TOFIX(f26TopSideBearing.y);
		outputPtr->verticalMetricInfo.devTopSideBearingLine.x = DOT6TOFIX(f26DevTopSideBearingLine.x);
		outputPtr->verticalMetricInfo.devTopSideBearingLine.y = DOT6TOFIX(f26DevTopSideBearingLine.y);
		outputPtr->verticalMetricInfo.topSideBearingLine.x    = DOT6TOFIX(f26TopSideBearingLine.x);
		outputPtr->verticalMetricInfo.topSideBearingLine.y    = DOT6TOFIX(f26TopSideBearingLine.y);

		fsg_UpdateAdvanceWidth (&key->TransformInfo, pvGlobalGS, key->usNonScaledAW,
			&outputPtr->metricInfo.advanceWidth);

		fsg_UpdateAdvanceHeight (&key->TransformInfo, pvGlobalGS, key->usNonScaledAH,
			&outputPtr->verticalMetricInfo.advanceHeight);

		MEMCPY(&key->metricInfo, &outputPtr->metricInfo, sizeof( metricsType ));
		MEMCPY(&key->verticalMetricInfo, &outputPtr->verticalMetricInfo, sizeof( verticalMetricsType ));

		pBMI = &outputPtr->bitMapInfo;
		pBMI->bounds.top = pOrigB->bottom;              /* reversed! */
		pBMI->bounds.bottom = pOrigB->top;
		pBMI->baseAddr = 0;
		
#ifdef FSCFG_SUBPIXEL
		if ((key->flSubPixel & FNT_SP_SUB_PIXEL))
		{
	        if (!(key->flSubPixel & FNT_SP_COMPATIBLE_WIDTH) )
	        {
                /* in the SubPixel mode, key->TransformInfo is overscaled when we don't ask for compatible width */
	            ROUND_FROM_HINT_OVERSCALE(outputPtr->metricInfo.advanceWidth.x);
	            ROUND_FROM_HINT_OVERSCALE(outputPtr->verticalMetricInfo.advanceHeight.x);
	        }
			ROUND_FROM_RGB_OVERSCALE(outputPtr->metricInfo.devAdvanceWidth.x);
			ROUND_FROM_RGB_OVERSCALE(outputPtr->metricInfo.devLeftSideBearing.x);
			ROUND_FROM_RGB_OVERSCALE(outputPtr->metricInfo.leftSideBearing.x);
			ROUND_FROM_RGB_OVERSCALE(outputPtr->metricInfo.devLeftSideBearingLine.x);
			ROUND_FROM_RGB_OVERSCALE(outputPtr->metricInfo.leftSideBearingLine.x);
			ROUND_FROM_RGB_OVERSCALE(outputPtr->verticalMetricInfo.devAdvanceHeight.x);
			ROUND_FROM_RGB_OVERSCALE(outputPtr->verticalMetricInfo.devTopSideBearing.x);
			ROUND_FROM_RGB_OVERSCALE(outputPtr->verticalMetricInfo.topSideBearing.x);
			ROUND_FROM_RGB_OVERSCALE(outputPtr->verticalMetricInfo.devTopSideBearingLine.x);
			ROUND_FROM_RGB_OVERSCALE(outputPtr->verticalMetricInfo.topSideBearingLine.x);

			pBMI->bounds.left = FLOOR_RGB_OVERSCALE(pOrigB->left);               /* return bbox to client */
			pBMI->bounds.right = CEIL_RGB_OVERSCALE(pOrigB->right);

			pBMI->rowBytes = ((pBMI->bounds.right - pBMI->bounds.left) + 3) & (-4);

            key->OverGBMap = key->GBMap;
            key->GBMap.sRowBytes = pBMI->rowBytes;
            key->GBMap.rectBounds.left = pBMI->bounds.left;
            key->GBMap.rectBounds.right = pBMI->bounds.right;
			key->GBMap.lMMemSize = (int32)pBMI->rowBytes * (int32)(key->GBMap.rectBounds.top - key->GBMap.rectBounds.bottom);
			outputPtr->memorySizes[BITMAP_PTR_4] = (FS_MEMORY_SIZE) key->OverGBMap.lMMemSize; 
		}
		else
		{
#endif // FSCFG_SUBPIXEL
			pBMI->bounds.left = pOrigB->left;               /* return bbox to client */
			pBMI->bounds.right = pOrigB->right;
			pBMI->rowBytes = key->GBMap.sRowBytes;
#ifdef FSCFG_SUBPIXEL
		}
#endif // FSCFG_SUBPIXEL

		if (key->bGrayScale)                                 /* if doing gray scale */
		{
			pBMI->rowBytes = ((pOrigB->right - pOrigB->left) + 3) & (-4);
			key->GBMap.lMMemSize = (int32)pBMI->rowBytes * (int32)(pOrigB->top - pOrigB->bottom);
			outputPtr->memorySizes[BITMAP_PTR_4] = (FS_MEMORY_SIZE) key->OverGBMap.lMMemSize; 
		}
		
		key->GBMap.sRowBytes = pBMI->rowBytes;
		outputPtr->memorySizes[BITMAP_PTR_1] = (FS_MEMORY_SIZE) key->GBMap.lMMemSize;
		outputPtr->memorySizes[BITMAP_PTR_2] = (FS_MEMORY_SIZE) key->WScan.lHMemSize;
		outputPtr->memorySizes[BITMAP_PTR_3] = (FS_MEMORY_SIZE) key->WScan.lVMemSize;

	}
	fsg_CheckWorkSpaceForFit(
		&(key->WorkSpaceOffsets),
		key->lExtraWorkSpace,
		key->WScan.lRMemSize,
		&(outputPtr->memorySizes[BITMAP_PTR_2]),
		&(outputPtr->memorySizes[BITMAP_PTR_3]));

	key->usBandType = FS_BANDINGOLD;                /* assume old banding */
	key->usBandWidth = 0;
	key->bOutlineIsCached = FALSE;                  /* assume no caching */

	fs_SetState(key,(INITIALIZED | NEWSFNT | NEWTRANS | GOTINDEX | GOTGLYPH | SIZEKNOWN));

	CHECKSTAMP (inputPtr->memoryBases[KEY_PTR_BASE] + outputPtr->memorySizes[KEY_PTR_BASE]);
	CHECKSTAMP (inputPtr->memoryBases[WORK_SPACE_BASE] + outputPtr->memorySizes[WORK_SPACE_BASE]);
	CHECKSTAMP (inputPtr->memoryBases[PRIVATE_FONT_SPACE_BASE] + outputPtr->memorySizes[PRIVATE_FONT_SPACE_BASE]);

	STAT_OFF_FINDBMS;             /* stop STAT timer */
	
	return NO_ERR;
}

/*********************************************************************/

FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_SizeOfOutlines (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
{
	fs_SplineKey *     key;
	int32              ulSize;
	ErrorCode          error;

	key = fs_SetUpKey(inputPtr, (INITIALIZED | NEWSFNT | NEWTRANS | GOTGLYPH | SIZEKNOWN), &error);
	if(!key)
	{
		return (FS_ENTRY)error;
	}

	if (key->bEmbeddedBitmap)
	{
        return SBIT_OUTLINE_CACHE_ERR;      /* can't cache sbits */
    }

	if(key->apbPrevMemoryBases[WORK_SPACE_BASE] != key->memoryBases[WORK_SPACE_BASE])
	{
		fsg_UpdateWorkSpaceAddresses(
			key->memoryBases[WORK_SPACE_BASE],
			&(key->WorkSpaceOffsets),
			&(key->pWorkSpaceAddr));

		fsg_UpdateWorkSpaceElement(
			&(key->WorkSpaceOffsets),
			&(key->pWorkSpaceAddr));

		key->WScan.pchRBuffer = (char *)fsg_QueryReusableMemory(
		key->memoryBases[WORK_SPACE_BASE],
		&(key->WorkSpaceOffsets));

		MEMCPY(key->apbPrevMemoryBases, key->memoryBases, sizeof(char *) * (size_t)MEMORYFRAGMENTS);
	}

	ulSize = (uint32)sizeof( uint32 );                         /* OUTLINESTAMP              */
	ulSize += (uint32)( sizeof( FS_MEMORY_SIZE ) * BITMAP_MEMORY_COUNT );   /* Memory Bases */
	ulSize += (uint32)( sizeof( uint32 ));                     /* Outlines Exist (padded)   */
	ulSize += (uint32)( sizeof( uint32 ));                     /* Scan Type (padded)        */
	ulSize += (uint32)( sizeof( uint32 ));                     /* Glyph Index (padded)      */
	ulSize += (uint32)( sizeof( uint32 ));                     /* Outline Cache Size        */
	ulSize += (uint32)( sizeof( uint32 ));                     /* Gray Scale Over Factor    */
	ulSize += (uint32)( sizeof( uint32 ));                     /* Grid Fit Skipped Boolean  */
	ulSize += (uint32)( sizeof( uint32 ));                     /* no embedded bitmap Boolean*/
	ulSize += (uint32)sizeof( metricsType );                   /* Metrics information       */
	ulSize += (uint32)sizeof( verticalMetricsType );           /* Vert metrics information  */
	ulSize += (uint32)sizeof( GlyphBitMap );                   /* Glyph Bitmap              */
	ulSize += (uint32)sizeof( GlyphBitMap );                   /* Gray Overscaled Bitmap    */
	ulSize += (uint32)sizeof( WorkScan );                      /* Scanconverter Workspace   */
	ulSize += (uint32)key->WScan.lRMemSize;                    /* Reversal list             */
	ulSize += fsg_GetContourDataSize(&key->pWorkSpaceAddr);    /* Contour Data              */
	ulSize += (uint32)sizeof( uint32 );                        /* OUTLINESTAMP2             */
	ALIGN(uint32, ulSize);

	outputPtr->outlineCacheSize = ulSize;
	key->ulGlyphOutlineSize = ulSize;

	return NO_ERR;
}

/*********************************************************************/

FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_SaveOutlines (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
{
	uint8 *            pbyDest;

	fs_SplineKey *     key;
	ErrorCode          error;

	key = fs_SetUpKey(inputPtr, (INITIALIZED | NEWSFNT | NEWTRANS | GOTGLYPH | SIZEKNOWN), &error);

	if(!key)
	{
		return (FS_ENTRY)error;
	}

	if(key->apbPrevMemoryBases[WORK_SPACE_BASE] != key->memoryBases[WORK_SPACE_BASE])
	{
		fsg_UpdateWorkSpaceAddresses(
			key->memoryBases[WORK_SPACE_BASE],
			&(key->WorkSpaceOffsets),
			&(key->pWorkSpaceAddr));

		fsg_UpdateWorkSpaceElement(
			&(key->WorkSpaceOffsets),
			&(key->pWorkSpaceAddr));

		MEMCPY(key->apbPrevMemoryBases, key->memoryBases, sizeof(char *) * (size_t)MEMORYFRAGMENTS);
	}

	if( (outputPtr->memorySizes[BITMAP_PTR_2] == 0L) || (outputPtr->memorySizes[BITMAP_PTR_3] == 0L))
	{
		fsg_GetRealBitmapSizes(
			&(key->WorkSpaceOffsets),
			&outputPtr->memorySizes[BITMAP_PTR_2],
			&outputPtr->memorySizes[BITMAP_PTR_3]);
	}

	pbyDest = (uint8 *)inputPtr->param.outlineCache;

	*((uint32 *)pbyDest) = OUTLINESTAMP;
	pbyDest += sizeof( uint32 );

	*((FS_MEMORY_SIZE *)pbyDest) = outputPtr->memorySizes[BITMAP_PTR_1];
	pbyDest += sizeof( FS_MEMORY_SIZE  );

	*((FS_MEMORY_SIZE *)pbyDest) = outputPtr->memorySizes[BITMAP_PTR_2];
	pbyDest += sizeof( FS_MEMORY_SIZE  );

	*((FS_MEMORY_SIZE *)pbyDest) = outputPtr->memorySizes[BITMAP_PTR_3];
	pbyDest += sizeof( FS_MEMORY_SIZE  );

	*((FS_MEMORY_SIZE *)pbyDest) = outputPtr->memorySizes[BITMAP_PTR_4];
	pbyDest += sizeof( FS_MEMORY_SIZE   );
	 
	/* Outlines exist state */

	*((uint32 *)pbyDest) = (uint32)key->bGlyphHasOutline;
	pbyDest += sizeof( uint32 );

	/* Dropout control state */

	*((uint32 *)pbyDest) = (uint32)key->usScanType;
	pbyDest += sizeof( uint32 );

	/* Glyph Index */

	*((uint32 *)pbyDest) = (uint32)key->ClientInfo.usGlyphIndex;
	pbyDest += sizeof( uint32 );

	/* Outline Cache Size */

	*((uint32 *)pbyDest) = (uint32)key->ulGlyphOutlineSize;
	pbyDest += sizeof( uint32 );

	/* Gray Over Scale Factor */

	*((uint32 *)pbyDest) = (uint32)key->SavedTransformInfo.usOverScale;
	pbyDest += sizeof( uint32 );

    /* Grid Fit Skipped Boolean  */

	*((uint32 *)pbyDest) = (uint32)key->bGridFitSkipped;
	pbyDest += sizeof( uint32 );

    /* No embedded bitmap Boolean  */

	*((uint32 *)pbyDest) = (uint32)key->bEmbeddedBitmap;
	pbyDest += sizeof( uint32 );

	/* Glyph metrics */

	MEMCPY(pbyDest, &key->metricInfo, sizeof(metricsType));
	pbyDest += sizeof(metricsType);

	MEMCPY(pbyDest, &key->verticalMetricInfo, sizeof(verticalMetricsType));
	pbyDest += sizeof(verticalMetricsType);

	/* Scan Converter Data Structures */

	MEMCPY(pbyDest, &key->GBMap, sizeof(GlyphBitMap));
	pbyDest += sizeof(GlyphBitMap);

	MEMCPY(pbyDest, &key->OverGBMap, sizeof(GlyphBitMap));
	pbyDest += sizeof(GlyphBitMap);

	MEMCPY(pbyDest, &key->WScan, sizeof(WorkScan));
	pbyDest += sizeof(WorkScan);

	MEMCPY(pbyDest, key->WScan.pchRBuffer, (size_t)key->WScan.lRMemSize);
	pbyDest += key->WScan.lRMemSize;

	/*** save charData ***/

	fsg_DumpContourData(&key->pWorkSpaceAddr, &pbyDest);

	*((uint32 *)pbyDest) = OUTLINESTAMP2;

	fs_SetState(key,(INITIALIZED | NEWSFNT | NEWTRANS | GOTINDEX | GOTGLYPH | SIZEKNOWN));

	return NO_ERR;
}

/*********************************************************************/

FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_RestoreOutlines (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
{
	fs_SplineKey *  key;
	uint8 *         pbySrc;
	ErrorCode       error;

	key = fs_SetUpKey(inputPtr, INITIALIZED, &error);
	if(!key)
	{
		return (FS_ENTRY)error;
	}

	pbySrc = (uint8 *)inputPtr->param.outlineCache;

	if ( *((uint32 *)pbySrc) != OUTLINESTAMP )
	{
		return TRASHED_OUTLINE_CACHE;
	}
	pbySrc += sizeof(uint32);

	outputPtr->memorySizes[BITMAP_PTR_1] = *((FS_MEMORY_SIZE *)pbySrc);
	pbySrc += sizeof( FS_MEMORY_SIZE   );

	outputPtr->memorySizes[BITMAP_PTR_2] = *((FS_MEMORY_SIZE *)pbySrc);
	pbySrc += sizeof( FS_MEMORY_SIZE   );

	outputPtr->memorySizes[BITMAP_PTR_3] = *((FS_MEMORY_SIZE *)pbySrc);
	pbySrc += sizeof( FS_MEMORY_SIZE   );

	outputPtr->memorySizes[BITMAP_PTR_4] = *((FS_MEMORY_SIZE *)pbySrc);
	pbySrc += sizeof( FS_MEMORY_SIZE    );

	/* Read in GlyphHasOutline */

	outputPtr->outlinesExist = (uint16)(*((uint32 *)pbySrc));
	pbySrc += sizeof( uint32 );

	/* Read ScanType state */

	key->usScanType = (uint16)(*((uint32 *)pbySrc));
	pbySrc += sizeof( uint32 );

	/* Read Glyph Index */

	outputPtr->glyphIndex = (uint16)(*((uint32 *)pbySrc));
	pbySrc += sizeof( uint32 );

	/* Read Size of Outline Cache  */

	outputPtr->outlineCacheSize = (uint16)(*((uint32 *)pbySrc));
	pbySrc += sizeof( uint32 );

	/* Read Gray Over Scale Factor  */

    key->SavedTransformInfo.usOverScale = (uint16)(*((uint32 *)pbySrc));
	outputPtr->usGrayLevels = key->SavedTransformInfo.usOverScale * key->SavedTransformInfo.usOverScale + 1;
	key->bGrayScale = (key->SavedTransformInfo.usOverScale == 0) ? FALSE : TRUE;
	pbySrc += sizeof( uint32 );

    /* Grid Fit Skipped Boolean  */

    key->bGridFitSkipped = (boolean)(*((uint32 *)pbySrc));
	pbySrc += sizeof( uint32 );

    /* No embedded bitmap Boolean  */

    key->bEmbeddedBitmap = (boolean)(*((uint32 *)pbySrc));
	pbySrc += sizeof( uint32 );

	/* Load fs_FindBitmapSize metrics */

	MEMCPY(&outputPtr->metricInfo, pbySrc, sizeof(metricsType));
	pbySrc += sizeof(metricsType);

	MEMCPY(&outputPtr->verticalMetricInfo, pbySrc, sizeof(verticalMetricsType));
	pbySrc += sizeof(verticalMetricsType);

	/* Load ScanConverter data structures */

	MEMCPY(&key->GBMap, pbySrc, sizeof(GlyphBitMap));
	pbySrc += sizeof(GlyphBitMap);

	MEMCPY(&key->OverGBMap, pbySrc, sizeof(GlyphBitMap));
	pbySrc += sizeof(GlyphBitMap);

	MEMCPY(&key->WScan, pbySrc, sizeof(WorkScan));
	pbySrc += sizeof(WorkScan);

	key->WScan.pchRBuffer = (char *)pbySrc;
	pbySrc += key->WScan.lRMemSize;

	fsg_RestoreContourData(
		&pbySrc,
		&outputPtr->xPtr,
		&outputPtr->yPtr,
		&outputPtr->startPtr,
		&outputPtr->endPtr,
		&outputPtr->onCurve,
		&outputPtr->fc,
		&outputPtr->numberOfContours);

	outputPtr->bitMapInfo.baseAddr = NULL;
	outputPtr->bitMapInfo.rowBytes = key->GBMap.sRowBytes;
	outputPtr->bitMapInfo.bounds.left = key->GBMap.rectBounds.left;
	outputPtr->bitMapInfo.bounds.right = key->GBMap.rectBounds.right;
	outputPtr->bitMapInfo.bounds.top = key->GBMap.rectBounds.bottom;   /* reversed! */
	outputPtr->bitMapInfo.bounds.bottom = key->GBMap.rectBounds.top;

	outputPtr->scaledCVT = NULL;
	outputPtr->numberOfBytesTaken = 0;

	key->usBandType = FS_BANDINGOLD;                    /* assume old banding */
	key->usBandWidth = 0;
    key->apbPrevMemoryBases[BITMAP_PTR_2] = NULL;       /* for fast/faster check */
    key->apbPrevMemoryBases[BITMAP_PTR_3] = NULL;

	key->bOutlineIsCached = TRUE;

	fs_SetState(key,(INITIALIZED | NEWSFNT | NEWTRANS | GOTINDEX | GOTGLYPH | SIZEKNOWN));
	return NO_ERR;
}

/*********************************************************************/

/* Calculate memory requirements for banding                         */

FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_FindBandingSize (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
{
	ErrorCode       error;
	fs_SplineKey *  key;
	uint8 *         pbyOutline;
	int16           sMaxOvershoot;
	int16           sHiOvershoot;
	int16           sLoOvershoot;
	GlyphBitMap *   pGBMap;             /* orig or over pointer */


	CHECKSTAMP (inputPtr->memoryBases[KEY_PTR_BASE] + outputPtr->memorySizes[KEY_PTR_BASE]);

	key = fs_SetUpKey(inputPtr, (INITIALIZED | NEWSFNT | NEWTRANS | GOTINDEX | GOTGLYPH | SIZEKNOWN), &error);
	if(!key)
	{
		return (FS_ENTRY)error;
	}

	if (key->bGridFitSkipped || key->bEmbeddedBitmap)
	{
		return SBIT_BANDING_ERR;                /* can't band sbits */
	}
	
	if( !key->bOutlineIsCached )
	{
		CHECKSTAMP (inputPtr->memoryBases[WORK_SPACE_BASE] + outputPtr->memorySizes[WORK_SPACE_BASE]);
		key->WScan.pchRBuffer = (char *)fsg_QueryReusableMemory(
			key->memoryBases[WORK_SPACE_BASE],
			&(key->WorkSpaceOffsets));
	}
	else
	{
		/* Unload the outline cache */

		pbyOutline = (uint8 *)inputPtr->param.band.outlineCache;

		if( *((uint32 *)pbyOutline) != OUTLINESTAMP )
		{
			  return TRASHED_OUTLINE_CACHE;
		}

		pbyOutline += sizeof( uint32 ) +
			  (BITMAP_MEMORY_COUNT * sizeof (FS_MEMORY_SIZE))  /* !!! Skip over stamp & 3 bitmap sizes */
			  + sizeof( uint32 )                      /* Outlines Exist (padded)  */
			  + sizeof( uint32 )                      /* Scan Type (padded)        */
			  + sizeof( uint32 )                      /* Glyph Index (padded)      */
			  + sizeof( uint32 )                      /* Outline Cache Size        */
			  + sizeof( uint32 )                      /* Gray Over Scale Factor    */
			  + sizeof( uint32 )                      /* Grid Fit Skipped Boolean  */
			  + sizeof( uint32 )                      /* no embedded bitmap Boolean*/
			  + sizeof( metricsType )                 /* Metrics information       */
			  + sizeof( verticalMetricsType )         /* Vert metrics information  */
			  + sizeof( GlyphBitMap )
			  + sizeof( GlyphBitMap )                 /* Over Scale structure      */
			  + sizeof( WorkScan );

		key->WScan.pchRBuffer = (char *)pbyOutline;

		/* No need to further unload outline cache */
	}

	pGBMap = &key->GBMap;                           /* default usual structure */
	key->usBandWidth = inputPtr->param.band.usBandWidth;
	key->usBandType = inputPtr->param.band.usBandType;

	if (key->bGrayScale)                                 /* if doing gray scale */
	{
		pGBMap = &key->OverGBMap;                   /* measure overscaled structure */
		key->usBandWidth *= key->SavedTransformInfo.usOverScale;
/*  
 *  Band width for the over scaled bitmap is basically just the requested band 
 *  width times the overscale factor.  However! if the gray scaled bounding 
 *  box has been trimmed to match the monochrome box (i.e. bMatchBBox = TRUE),
 *  then top and bottom bands must be made bigger to include the entire over
 *  scaled bitmap.  If this were not done it would break dropout control, and
 *  bitmaps would change with banding.  So that's why we do this messing around
 *  with overshoot in the key->usBandWidth calculation.
 */
		sMaxOvershoot = 0;
		sHiOvershoot = (int16)(key->OverGBMap.rectBounds.top -
					   key->GBMap.rectBounds.top * (int16)key->SavedTransformInfo.usOverScale);
		if (sHiOvershoot > sMaxOvershoot)
		{
			sMaxOvershoot = sHiOvershoot;
		}
		sLoOvershoot = (int16)(key->GBMap.rectBounds.bottom * (int16)key->SavedTransformInfo.usOverScale -
					   key->OverGBMap.rectBounds.bottom);
		if (sLoOvershoot > sMaxOvershoot)
		{
			sMaxOvershoot = sLoOvershoot;
		}
		key->usBandWidth += (uint16)sMaxOvershoot;
	}

	error = fsc_MeasureBand(
		pGBMap,                     /* orig or over scaled bounding box, etc. */
		&key->WScan,
		key->usBandType,
		key->usBandWidth,           /* worst case band width */
		key->usScanType );
	if (error != NO_ERR)
	{
		return(error);
	}

	if (key->bGrayScale)                                 /* if doing gray scale */
	{
		key->GBMap.lMMemSize = (int32)key->GBMap.sRowBytes * (int32)inputPtr->param.band.usBandWidth;
		outputPtr->memorySizes[BITMAP_PTR_4] = (FS_MEMORY_SIZE) key->OverGBMap.lMMemSize;
	}
	
	outputPtr->memorySizes[BITMAP_PTR_1] = (FS_MEMORY_SIZE) key->GBMap.lMMemSize;
	outputPtr->memorySizes[BITMAP_PTR_2] = (FS_MEMORY_SIZE) key->WScan.lHMemSize;
	outputPtr->memorySizes[BITMAP_PTR_3] = (FS_MEMORY_SIZE) key->WScan.lVMemSize;
	
	if( !key->bOutlineIsCached )
	{
		fsg_CheckWorkSpaceForFit(
			&(key->WorkSpaceOffsets),
			key->lExtraWorkSpace,
			key->WScan.lRMemSize,                             /* MeasureGlyph workspace */
			&(outputPtr->memorySizes[BITMAP_PTR_2]),
			&(outputPtr->memorySizes[BITMAP_PTR_3]));
	}

	CHECKSTAMP (inputPtr->memoryBases[KEY_PTR_BASE] + outputPtr->memorySizes[KEY_PTR_BASE]);
	if( !key->bOutlineIsCached )
	{
		CHECKSTAMP (inputPtr->memoryBases[WORK_SPACE_BASE] + outputPtr->memorySizes[WORK_SPACE_BASE]);
	}

	return NO_ERR;
}

/*********************************************************************/

#ifdef FSCFG_CONVERT_GRAY_LEVELS

// Tables to speed up bitmap translation from different GrayLevels.
uint8 Gray4To5Table[4]= {0,1,3,4};
uint8 Gray16To5Table[16]={0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4};

uint8 Gray4To17Table[4]= {0,5,11,16};
uint8 Gray16To17Table[16]={0,1,2,3,4,5,6,7,9,10,11,12,13,14,15,16};

uint8 Gray4To65Table[4]= {0,21,43,64};
uint8 Gray16To65Table[16]={0,4,9,13,17,21,26,30,34,38,43,47,51,55,60,64};

FS_PRIVATE FS_ENTRY  fs_ConvertGrayLevels (fs_GlyphInfoType *outputPtr, uint16 usOverScale, uint16 usBitDepth);

FS_PRIVATE FS_ENTRY  fs_ConvertGrayLevels (fs_GlyphInfoType *outputPtr, uint16 usOverScale, uint16 usBitDepth)
	{
	  uint16    index; // Gray level xlate table index
      switch (usOverScale) {
       case 2:
		   {
             uint32 i;
             uint32 bitmapSize=0;
             bitmapSize = (outputPtr->bitMapInfo.bounds.bottom - outputPtr->bitMapInfo.bounds.top)
                         *(outputPtr->bitMapInfo.rowBytes);

             switch (usBitDepth) {
             case 2:
                for (i=0 ; i<bitmapSize; i++) {
                    index=((outputPtr->bitMapInfo.baseAddr[i])&0x03);
                    outputPtr->bitMapInfo.baseAddr[i]=Gray4To5Table[index];
				} /* endfor */
                break;
             case 4:
                for (i=0 ; i<bitmapSize; i++) {
                    index=((outputPtr->bitMapInfo.baseAddr[i])&0x0f);
                    outputPtr->bitMapInfo.baseAddr[i]=Gray16To5Table[index];
				} /* endfor */            
                break;
             case 8:
                for (i=0 ; i<bitmapSize; i++) {
                    index=((outputPtr->bitMapInfo.baseAddr[i])>>4);
                    outputPtr->bitMapInfo.baseAddr[i]=Gray16To5Table[index];
				} /* endfor */
                break;

             default:
                  return BAD_GRAY_LEVEL_ERR;
          
             } /* endswitch */
		   }
          break;
       case 4:
		   {
             uint32 i;
             uint32 bitmapSize=0;
             bitmapSize = (outputPtr->bitMapInfo.bounds.bottom - outputPtr->bitMapInfo.bounds.top)
                         *(outputPtr->bitMapInfo.rowBytes);

             switch (usBitDepth) {
             case 2:
                for (i=0 ; i<bitmapSize; i++) {
                    index=((outputPtr->bitMapInfo.baseAddr[i])&0x03);
                    outputPtr->bitMapInfo.baseAddr[i]=Gray4To17Table[index];
				} /* endfor */
                break;
             case 4:
                for (i=0 ; i<bitmapSize; i++) {
                    index=((outputPtr->bitMapInfo.baseAddr[i])&0x0f);
                    outputPtr->bitMapInfo.baseAddr[i]=Gray16To17Table[index];
				} /* endfor */            
                break;
             case 8:
                for (i=0 ; i<bitmapSize; i++) {
                    index=((outputPtr->bitMapInfo.baseAddr[i])>>4);
                    outputPtr->bitMapInfo.baseAddr[i]=Gray16To17Table[index];
				} /* endfor */
                break;

             default:
                  return BAD_GRAY_LEVEL_ERR;
          
			 } /* endswitch */
		   }
          break;
       case 8:
		   {
             uint32 i;
             uint32 bitmapSize=0;
             bitmapSize = (outputPtr->bitMapInfo.bounds.bottom - outputPtr->bitMapInfo.bounds.top)
                         *(outputPtr->bitMapInfo.rowBytes);

             switch (usBitDepth) {
             case 2:
                for (i=0 ; i<bitmapSize; i++) {
                    index=((outputPtr->bitMapInfo.baseAddr[i])&0x03);
                    outputPtr->bitMapInfo.baseAddr[i]=Gray4To65Table[index];
				} /* endfor */
                break;
             case 4:
                for (i=0 ; i<bitmapSize; i++) {
                    index=((outputPtr->bitMapInfo.baseAddr[i])&0x0f);
                    outputPtr->bitMapInfo.baseAddr[i]=Gray16To65Table[index];
				} /* endfor */            
                break;
             case 8:
                for (i=0 ; i<bitmapSize; i++) {
                    index=((outputPtr->bitMapInfo.baseAddr[i])>>4);
                    outputPtr->bitMapInfo.baseAddr[i]=Gray16To65Table[index];
				} /* endfor */
                break;

             default:
                  return BAD_GRAY_LEVEL_ERR;
          
			 } /* endswitch */
		   }
          break;

       default:
               return BAD_GRAY_LEVEL_ERR;
       } /* endswitch */
	   return NO_ERR;

    } /* end if bGrayScale */

#endif // FSCFG_CONVERT_GRAY_LEVELS

/* Generate a bitmap                                                 */

FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_ContourScan (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
{    
	ContourList     CList;        /* newscan contour list type */
	fs_SplineKey *  key;
	char *          pBitmapPtr2;
	char *          pBitmapPtr3;
	uint8 *         pbyOutline;
	ErrorCode       error;
	GlyphBitMap *   pGBMap;             /* orig or over pointer */


	CHECKSTAMP (inputPtr->memoryBases[KEY_PTR_BASE] + outputPtr->memorySizes[KEY_PTR_BASE]);

	STAT_ON_SCAN;                    /* start STAT timer */

	key = fs_SetUpKey(inputPtr, (INITIALIZED | NEWSFNT | NEWTRANS | GOTINDEX | GOTGLYPH | SIZEKNOWN), &error);
	if(!key)
	{
		return (FS_ENTRY)error;
	}

	if( !key->bOutlineIsCached )                /* if outline or embedded bitmap */
	{
		CHECKSTAMP (inputPtr->memoryBases[WORK_SPACE_BASE] + outputPtr->memorySizes[WORK_SPACE_BASE]);

		if(key->apbPrevMemoryBases[WORK_SPACE_BASE] != key->memoryBases[WORK_SPACE_BASE])
		{
			fsg_UpdateWorkSpaceAddresses(
				 key->memoryBases[WORK_SPACE_BASE],
				 &(key->WorkSpaceOffsets),
				 &(key->pWorkSpaceAddr));

			fsg_UpdateWorkSpaceElement(
				 &(key->WorkSpaceOffsets),
				 &(key->pWorkSpaceAddr));

			key->apbPrevMemoryBases[WORK_SPACE_BASE] = key->memoryBases[WORK_SPACE_BASE];
		}

		fsg_SetUpWorkSpaceBitmapMemory(
			key->memoryBases[WORK_SPACE_BASE],
			&(key->WorkSpaceOffsets),
			key->memoryBases[BITMAP_PTR_2],
			key->memoryBases[BITMAP_PTR_3],
			&pBitmapPtr2,                       /* sbits may need Ptr2 */
			&pBitmapPtr3);

        /* check for embedded bitmap, quick return if found */

#ifdef FSCFG_SUBPIXEL
	    if (key->bEmbeddedBitmap && !(key->flSubPixel & FNT_SP_SUB_PIXEL))  				/* if bitmap are not disabled */
#else
	    if (key->bEmbeddedBitmap)  				/* if bitmap are not disabled */
#endif // FSCFG_SUBPIXEL	
    	{
    		if ((inputPtr->param.scan.topClip > inputPtr->param.scan.bottomClip) &&  /* if legal band */
               ((inputPtr->param.scan.topClip < key->GBMap.rectBounds.top) ||
                (inputPtr->param.scan.bottomClip > key->GBMap.rectBounds.bottom)))
    		{
        		return SBIT_BANDING_ERR;            /* can't band sbits */
            }

    		error = sbit_GetBitmap (
    			&key->SbitMono,
    			&key->ClientInfo,
    			(uint8 *) inputPtr->memoryBases[BITMAP_PTR_1],
    			(uint8 *) pBitmapPtr2 );
		
    		if (error != NO_ERR)
    		{
    			return((FS_ENTRY)error);
    		}
        	outputPtr->bitMapInfo.baseAddr = key->memoryBases[BITMAP_PTR_1];  /* return bitmap addr */

        	CHECKSTAMP (inputPtr->memoryBases[KEY_PTR_BASE] + outputPtr->memorySizes[KEY_PTR_BASE]);
       		CHECKSTAMP (inputPtr->memoryBases[WORK_SPACE_BASE] + outputPtr->memorySizes[WORK_SPACE_BASE]);

        	STAT_OFF_SCAN;                  /* stop STAT timer */

#ifdef FSCFG_CONVERT_GRAY_LEVELS
			if (key->bGrayScale)
			{
				error = fs_ConvertGrayLevels (outputPtr, key->SavedTransformInfo.usOverScale, key->SbitMono.usBitDepth);
			
				if(error)
				{
					return (FS_ENTRY)error;
				}
			} /* end if bGrayScale */
#endif // FSCFG_CONVERT_GRAY_LEVELS

        	return NO_ERR;                  /* return now with an sbit */
    	}
        else        /* if scan converting an outline */
        {
			fsg_GetWorkSpaceExtra(
				key->memoryBases[WORK_SPACE_BASE],
				&(key->WorkSpaceOffsets),
				&(key->WScan.pchRBuffer));

			fsg_GetContourData(
				&key->pWorkSpaceAddr,
#ifdef FSCFG_SUBPIXEL
				FALSE,            
#endif // FSCFG_SUBPIXEL
				&CList.afxXCoord,
				&CList.afxYCoord,
				&CList.asStartPoint,
				&CList.asEndPoint,
				&CList.abyOnCurve,
				&CList.abyFc,
				&CList.usContourCount);
        }
    }
    else            /* Unload the outline cache */
	{
		pbyOutline = (uint8 *)inputPtr->param.scan.outlineCache;

		if( *((uint32 *)pbyOutline) != OUTLINESTAMP )
		{
			 return TRASHED_OUTLINE_CACHE;
		}

		pbyOutline += sizeof( uint32 ) +
			(BITMAP_MEMORY_COUNT * sizeof (FS_MEMORY_SIZE))  /* !!! Skip over stamp & 3 bitmap sizes */
			+ sizeof( uint32 )                      /* Outlines Exist (padded)  */
			+ sizeof( uint32 )                      /* Scan Type (padded)        */
			+ sizeof( uint32 )                      /* Glyph Index (padded)      */
			+ sizeof( uint32 )                      /* Outline Cache Size        */
			+ sizeof( uint32 )                      /* Gray Over Scale Factor    */
	        + sizeof( uint32 )                      /* Grid Fit Skipped Boolean  */
	        + sizeof( uint32 )                      /* no embedded bitmap Boolean*/
			+ sizeof( metricsType )                 /* Metrics information       */
			+ sizeof( verticalMetricsType )         /* Vert metrics information  */
			+ sizeof( GlyphBitMap )
			+ sizeof( GlyphBitMap )                 /* Over Scale structure      */
			+ sizeof( WorkScan );

		key->WScan.pchRBuffer = (char *)pbyOutline;
		pbyOutline += key->WScan.lRMemSize;

		fsg_RestoreContourData(
			&pbyOutline,
			&CList.afxXCoord,
			&CList.afxYCoord,
			&CList.asStartPoint,
			&CList.asEndPoint,
			&CList.abyOnCurve,
			&CList.abyFc,
			&CList.usContourCount);

		if( *((uint32 *)pbyOutline) != OUTLINESTAMP2 )
		{
			return TRASHED_OUTLINE_CACHE;
		}

		pBitmapPtr2 = key->memoryBases[BITMAP_PTR_2];
		pBitmapPtr3 = key->memoryBases[BITMAP_PTR_3];
	}

	if (pBitmapPtr3 == NULL)  /* Allow client to turn off DOControl */
	{
		key->usScanType = SK_NODROPOUT;
	}

	key->GBMap.pchBitMap = inputPtr->memoryBases[BITMAP_PTR_1];
	key->GBMap.sHiBand = inputPtr->param.scan.topClip;
	key->GBMap.sLoBand = inputPtr->param.scan.bottomClip;

	if (key->GBMap.sHiBand <= key->GBMap.sLoBand)            /* if negative or no band */
	{
		key->GBMap.sHiBand = key->GBMap.rectBounds.top;     /* then for Apple compatiblity */
		key->GBMap.sLoBand = key->GBMap.rectBounds.bottom;  /* do the entire bitmap */
	}
	if (key->GBMap.sHiBand > key->GBMap.rectBounds.top)
	{
		key->GBMap.sHiBand = key->GBMap.rectBounds.top;     /* clip to bounding box */
	}
	if (key->GBMap.sLoBand < key->GBMap.rectBounds.bottom)
	{
		key->GBMap.sLoBand = key->GBMap.rectBounds.bottom;  /* clip to bounding box */
	}
		 
	if ((key->usBandType == FS_BANDINGFASTER) &&
		((key->apbPrevMemoryBases[BITMAP_PTR_2] != pBitmapPtr2) ||
		 (key->apbPrevMemoryBases[BITMAP_PTR_3] != pBitmapPtr3)))
	{
		 key->usBandType = FS_BANDINGFAST;  /* to recalculate memory */
	}

	if (key->usBandType == FS_BANDINGOLD)   /* if FindGrayBandingSize wasn't called */
	{
		if ((key->GBMap.sHiBand != key->GBMap.rectBounds.top) ||
			(key->GBMap.sLoBand != key->GBMap.rectBounds.bottom))   /* if banding */
		{
			if (key->bGrayScale)
			{
				return GRAY_OLD_BANDING_ERR;        /* gray scale fails with old banding */
			}
			key->usScanType = SK_NODROPOUT;         /* else force dropout off */
		}
	}
	else if (key->usBandType == FS_BANDINGSMALL)  /* if small mem type */
	{
		if (key->bGrayScale)
		{
			if (key->SavedTransformInfo.usOverScale *(key->GBMap.sHiBand - key->GBMap.sLoBand) > (int16)key->usBandWidth)
			{
				return BAND_TOO_BIG_ERR;          /* don't let band exceed calc'd size */
			}
		} else {
			if (key->GBMap.sHiBand - key->GBMap.sLoBand > (int16)key->usBandWidth)
			{
				return BAND_TOO_BIG_ERR;          /* don't let band exceed calc'd size */
			}
		}
		key->usScanType = SK_NODROPOUT;       /* turn off dropout control */
	}
	pGBMap = &key->GBMap;                     /* default to usual structure */
	
	if (key->bGrayScale)
	{
		pGBMap = &key->OverGBMap;             /* measure overscaled structure */
		
		if (key->GBMap.sHiBand == key->GBMap.rectBounds.top)            /* if gray band at top */
		{
			key->OverGBMap.sHiBand = key->OverGBMap.rectBounds.top;     /* use over top */
		}
		else
		{
			key->OverGBMap.sHiBand = (int16)(key->GBMap.sHiBand * (int16)key->SavedTransformInfo.usOverScale);
			if (key->OverGBMap.sHiBand > key->OverGBMap.rectBounds.top)
			{
				key->OverGBMap.sHiBand = key->OverGBMap.rectBounds.top; /* clip */
			}
		}
		if (key->GBMap.sLoBand == key->GBMap.rectBounds.bottom)         /* if gray band at bottom */
		{
			key->OverGBMap.sLoBand = key->OverGBMap.rectBounds.bottom;  /* use over bottom */
		}
		else
		{
			key->OverGBMap.sLoBand = (int16)(key->GBMap.sLoBand * (int16)key->SavedTransformInfo.usOverScale);
			if (key->OverGBMap.sLoBand < key->OverGBMap.rectBounds.bottom)
			{
				key->OverGBMap.sLoBand = key->OverGBMap.rectBounds.bottom;  /* clip */
			}
		}
		key->OverGBMap.pchBitMap = inputPtr->memoryBases[BITMAP_PTR_4];
	}
#ifdef FSCFG_SUBPIXEL
	if ((key->flSubPixel & FNT_SP_SUB_PIXEL))
	{
		pGBMap = &key->OverGBMap;             /* draw into the overscaled structure */

	    key->OverGBMap.pchBitMap = inputPtr->memoryBases[BITMAP_PTR_4];

        /* no banding yet !!! */
	    key->OverGBMap.sHiBand = key->OverGBMap.rectBounds.top;
	    key->OverGBMap.sLoBand = key->OverGBMap.rectBounds.bottom;
    }
#endif // FSCFG_SUBPIXEL

	key->WScan.pchHBuffer = pBitmapPtr2;
	key->WScan.pchVBuffer = pBitmapPtr3;

	error = fsc_FillGlyph(
		&CList,
		pGBMap,
		&key->WScan,
		key->usBandType,
		key->usScanType
		);
	if (error != NO_ERR)
	{
		return(error);
	}
	 
	if (key->bGrayScale)
	{
		error = fsc_CalcGrayMap(
			&key->OverGBMap, 
			&key->GBMap, 
			key->SavedTransformInfo.usOverScale
			);
		if (error != NO_ERR)
		{
			return((FS_ENTRY)error);
		}
	}

#ifdef FSCFG_SUBPIXEL
	if ((key->flSubPixel & FNT_SP_SUB_PIXEL))
	{
#ifdef FSCFG_SUBPIXEL_STANDALONE // B.St.
		outputPtr->overscaledBitmapInfo.baseAddr = key->OverGBMap.pchBitMap;
		outputPtr->overscaledBitmapInfo.rowBytes = key->OverGBMap.sRowBytes;
		outputPtr->overscaledBitmapInfo.bounds = key->OverGBMap.rectBounds; // save for more detailed processing
#endif
        fsc_OverscaleToSubPixel (&key->OverGBMap, (key->flSubPixel & FNT_SP_BGR_ORDER) > 0, &key->GBMap);
	}
#endif // FSCFG_SUBPIXEL

	if (key->SavedTransformInfo.bBitmapEmboldening)
	{
		if (key->bGrayScale)
		{
			uint16 usGrayLevels = key->SavedTransformInfo.usOverScale * key->SavedTransformInfo.usOverScale + 1;
			sbit_EmboldenGray((uint8 *)key->GBMap.pchBitMap, (uint16)(key->GBMap.rectBounds.right - key->GBMap.rectBounds.left), 
						  (uint16)(key->GBMap.sHiBand - key->GBMap.sLoBand), key->GBMap.sRowBytes,usGrayLevels, key->sBoldSimulHorShift, key->sBoldSimulVertShift);
		} 
#ifdef FSCFG_SUBPIXEL
		else if ((key->flSubPixel & FNT_SP_SUB_PIXEL))
		{
			sbit_EmboldenSubPixel((uint8 *)key->GBMap.pchBitMap, (uint16)(key->GBMap.rectBounds.right - key->GBMap.rectBounds.left), 
						  (uint16)(key->GBMap.sHiBand - key->GBMap.sLoBand), key->GBMap.sRowBytes, key->sBoldSimulHorShift, key->sBoldSimulVertShift);
		} 
#endif // FSCFG_SUBPIXEL
		else 
		{
			sbit_Embolden((uint8 *)pGBMap->pchBitMap, (uint16)(pGBMap->rectBounds.right - pGBMap->rectBounds.left), 
						  (uint16)(pGBMap->sHiBand - pGBMap->sLoBand), pGBMap->sRowBytes, key->sBoldSimulHorShift, key->sBoldSimulVertShift);
		}
	}

/*  Setting the Band Type to FS_BANDINGFASTER will allow the next call      */
/*  to fsc_FillGlyph to skip the rendering phase of scan conversion and     */
/*  get right to the bitmap fill.  If the client moves either memoryBase[6] */ 
/*  or memoryBase[7] between fs_ContourScan calls, then we must reset the   */
/*  band type to FS_BANDINGFAST to regenerate the data structures.          */

	if (key->usBandType == FS_BANDINGFAST)
	{
		key->usBandType = FS_BANDINGFASTER;    /* to save re-rendering */
		key->apbPrevMemoryBases[BITMAP_PTR_2] = pBitmapPtr2;
		key->apbPrevMemoryBases[BITMAP_PTR_3] = pBitmapPtr3;
	}

	outputPtr->bitMapInfo.baseAddr = key->memoryBases[BITMAP_PTR_1];  /* return bitmap addr */

	CHECKSTAMP (inputPtr->memoryBases[KEY_PTR_BASE] + outputPtr->memorySizes[KEY_PTR_BASE]);
	if( !key->bOutlineIsCached )
	{
		CHECKSTAMP (inputPtr->memoryBases[WORK_SPACE_BASE] + outputPtr->memorySizes[WORK_SPACE_BASE]);
	}

	STAT_OFF_SCAN;                /* stop STAT timer */

	return NO_ERR;
}

/*********************************************************************/

FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_CloseFonts (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
{
	FS_UNUSED_PARAMETER(inputPtr);
	FS_UNUSED_PARAMETER(outputPtr);
	return NO_ERR;
}

#ifdef  FSCFG_NO_INITIALIZED_DATA
FS_PUBLIC  void FS_ENTRY_PROTO fs_InitializeData (void)
	{
		fsg_InitializeData ();
	}
#endif



/*********************************************************************/

/* fs_GetScaledAdvanceWidths returns only horizontal advance widths and is not meant to be used under rotation */

FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_GetScaledAdvanceWidths (
	fs_GlyphInputType * inputPtr,
	uint16              usFirstGlyph,
	uint16              usLastGlyph,
	int16 *             psGlyphWidths)
{
	fs_SplineKey *      key;
	void *              pvGlobalGS;
	void *              pvStack;
	void *              pvFontProgram;
	void *              pvPreProgram;
	void *              pvTwilightZone;
	uint16              usCurrentGlyphIndex;
	uint16              usGlyphIndex;
	uint16              usPPEm;
	int16               sNonScaledLSB;
	vectorType          fxGlyphWidth;
	point               f26DevAdvanceWidth;
	boolean             bHdmxEntryExist;
	boolean             bBitmapFound;
	ErrorCode           error;
#ifdef FSCFG_SUBPIXEL	
	boolean             bSubPixelWidth = FALSE;
    fsg_TransformRec *  TransformInfoForGridFit;
	void *              pvGlobalGSSubPixel;
	void *              pvTwilightZoneSubPixel;
#endif // FSCFG_SUBPIXEL

	key = fs_SetUpKey(inputPtr, (INITIALIZED | NEWSFNT | NEWTRANS ), &error);

	if(!key)
	{
		return (FS_ENTRY)error;
	}

	if((key->apbPrevMemoryBases[WORK_SPACE_BASE] != key->memoryBases[WORK_SPACE_BASE]) ||
	   (key->apbPrevMemoryBases[PRIVATE_FONT_SPACE_BASE] != key->memoryBases[PRIVATE_FONT_SPACE_BASE]))
	{
		fsg_UpdateWorkSpaceAddresses(
			key->memoryBases[WORK_SPACE_BASE],
			&(key->WorkSpaceOffsets),
			&(key->pWorkSpaceAddr));

		pvStack = fsg_QueryStack(&key->pWorkSpaceAddr);

		fsg_UpdatePrivateSpaceAddresses(
			&key->ClientInfo,
			&key->maxProfile,
			key->memoryBases[PRIVATE_FONT_SPACE_BASE],
			&(key->PrivateSpaceOffsets),
			pvStack,
			&pvFontProgram,
			&pvPreProgram);

		MEMCPY(key->apbPrevMemoryBases, key->memoryBases, sizeof(char *) * (size_t)MEMORYFRAGMENTS);
	}

	pvGlobalGS = fsg_QueryGlobalGS(
		key->memoryBases[PRIVATE_FONT_SPACE_BASE],
		&(key->PrivateSpaceOffsets));

	/*  Initialization  */

	bHdmxEntryExist = FALSE;

#ifdef FSCFG_SUBPIXEL	
	if ( (key->flSubPixel & FNT_SP_SUB_PIXEL) && !(key->flSubPixel & FNT_SP_COMPATIBLE_WIDTH) ) 
    {
        bSubPixelWidth = TRUE;
    }
#endif // FSCFG_SUBPIXEL	

	/*  Save current glyph index    */

	usCurrentGlyphIndex = key->ClientInfo.usGlyphIndex;

	/*  Check input parameters  */

	if( (usLastGlyph > key->maxProfile.numGlyphs ) ||
		(usLastGlyph < usFirstGlyph))
	{
		return INVALID_GLYPH_INDEX;
	}

	if( psGlyphWidths == NULL )
	{
		return NULL_INPUT_PTR_ERR;
	}

	/*  Find our current PPEm   */

	fsg_QueryPPEM(pvGlobalGS, &usPPEm);
	/* Only Grab 'hdmx' if not stretched or rotated */

#ifdef FSCFG_SUBPIXEL	
    /* for SubPixel, use Hdmx width only if we are in compatible width mode */
	if( !bSubPixelWidth &&
	    (!fsg_IsTransformStretched( &key->TransformInfo )) &&
		(!fsg_IsTransformRotated( &key->TransformInfo )) )
#else
	if( (!fsg_IsTransformStretched( &key->TransformInfo )) &&
		(!fsg_IsTransformRotated( &key->TransformInfo )) )
#endif // FSCFG_SUBPIXEL	
	{

		/*  Check if we can quickly grab the widths from the 'hdmx' table   */

		error = sfac_CopyHdmxEntry(
			&key->ClientInfo,
			usPPEm,
			&bHdmxEntryExist,
			usFirstGlyph,
			usLastGlyph,
			psGlyphWidths);

		if (error != NO_ERR)
		{
			return(error);
		}

		/* If we got a hit on the 'hdmx' we are done    */

		if( bHdmxEntryExist )
		{
			return NO_ERR;
		}
	}

	/* No hit on 'hmdx', now it is time for the dirty work  */

	/* We need to prepare ourselves here for a potential grid fit */

	fsg_UpdateWorkSpaceElement(
		&(key->WorkSpaceOffsets),
		&(key->pWorkSpaceAddr));

	pvTwilightZone = fsg_QueryTwilightElement(
		key->memoryBases[PRIVATE_FONT_SPACE_BASE],
		&(key->PrivateSpaceOffsets));

#ifdef FSCFG_SUBPIXEL
    TransformInfoForGridFit = &key->TransformInfo;
	if ((key->flSubPixel & FNT_SP_COMPATIBLE_WIDTH))
    {
	    pvGlobalGSSubPixel = fsg_QueryGlobalGSSubPixel(
		    key->memoryBases[PRIVATE_FONT_SPACE_BASE],
		    &(key->PrivateSpaceOffsets));
	    pvTwilightZoneSubPixel = fsg_QueryTwilightElementSubPixel(
		    key->memoryBases[PRIVATE_FONT_SPACE_BASE],
		    &(key->PrivateSpaceOffsets));
    }
#endif // FSCFG_SUBPIXEL

    /*  potentially do delayed pre program execution */

	if (key->bExecutePrePgm)
	{
		/* Run the pre program and scale the control value table */

		key->bExecutePrePgm = FALSE;

		error = fsg_RunPreProgram (
			&key->ClientInfo,
			&key->maxProfile,
			&key->TransformInfo,
			pvGlobalGS,
			&key->pWorkSpaceAddr,
			pvTwilightZone,
			NULL);

		if(error)
		{
			/* If the pre-program fails, prevent further glyphs from being called */
			fs_SetState(key, (INITIALIZED | NEWSFNT));

			/* If the pre-program fails, switch off hinting for further glyphs */
			key->bHintingEnabled = FALSE;
			return (FS_ENTRY)error;
		}
#ifdef FSCFG_SUBPIXEL	
	    if ((key->flSubPixel & FNT_SP_COMPATIBLE_WIDTH))
        {
		    error = fsg_RunPreProgram (
			    &key->ClientInfo,
			    &key->maxProfile,
			    &key->TransformInfoSubPixel,
			    pvGlobalGSSubPixel,
			    &key->pWorkSpaceAddr,
			    pvTwilightZoneSubPixel,
			    NULL);

		    if(error)
		    {
			    /* If the pre-program fails, prevent further glyphs from being called */
			    fs_SetState(key, (INITIALIZED | NEWSFNT));

                /* If the pre-program fails, switch off hinting for further glyphs */
			    key->bHintingEnabled = FALSE;
			    return (FS_ENTRY)error;
		    }
	    }
#endif // FSCFG_SUBPIXEL	
	}

	/*  Now check 'LTSH' table for linear cutoff information    */

	error = sfac_GetLTSHEntries(
		&key->ClientInfo,
		usPPEm,
		usFirstGlyph,
		usLastGlyph,
		psGlyphWidths);

	/* The pfxGlyphWidths array contains a boolean for each glyph (from     */
	/* first glyph to last glyph) that indicates if the glyph scales        */
	/* linearly.                                                            */

	/* Handle each glyph    */

	for( usGlyphIndex = usFirstGlyph; usGlyphIndex <= usLastGlyph; usGlyphIndex++)
	{
#ifdef FSCFG_SUBPIXEL
        /* for SubPixel, use linear width only if we are in compatible width mode */
		if( !bSubPixelWidth &&
            (psGlyphWidths[usGlyphIndex - usFirstGlyph]) &&
			(!fsg_IsTransformStretched( &key->TransformInfo )) &&
			(!fsg_IsTransformRotated( &key->TransformInfo )) )
#else
		if( (psGlyphWidths[usGlyphIndex - usFirstGlyph]) &&
			(!fsg_IsTransformStretched( &key->TransformInfo )) &&
			(!fsg_IsTransformRotated( &key->TransformInfo )) )
#endif // FSCFG_SUBPIXEL	
		{
			/* Glyph Scales Linearly    */


		error = sfac_ReadGlyphHorMetrics (
				&key->ClientInfo,
				usGlyphIndex,
				&key->usNonScaledAW,
				&sNonScaledLSB);

			if(error)
			{
				return (FS_ENTRY)error;
			}

			fsg_UpdateAdvanceWidth (
				&key->TransformInfo,
				pvGlobalGS,
				key->usNonScaledAW,
				&fxGlyphWidth);

			psGlyphWidths[usGlyphIndex - usFirstGlyph] = (int16)((fxGlyphWidth.x + ONEHALFFIX) >> 16);
		}
		else    /* Glyph does not scale linearly */
		{
			error = LookForSbitAdvanceWidth (
				key, 
				usGlyphIndex, 
				&bBitmapFound, 
				&f26DevAdvanceWidth );          /* value returned if found */
			
			if(error)
			{
				return (FS_ENTRY)error;
			}

			if (bBitmapFound == FALSE)
			{
				/* Glyph needs to be grid fitted */

				key->ClientInfo.usGlyphIndex = usGlyphIndex;

				error = fsg_GridFit (
					&key->ClientInfo,
					&key->maxProfile,
					&key->TransformInfo,
					pvGlobalGS,
					&key->pWorkSpaceAddr,
					pvTwilightZone,
					(FntTraceFunc)NULL,
					TRUE,
					&key->usScanType,
					&key->bGlyphHasOutline,
					&key->usNonScaledAW,
					key->SavedTransformInfo.bBitmapEmboldening
#ifdef FSCFG_SUBPIXEL
	                ,bSubPixelWidth
#endif // FSCFG_SUBPIXEL
					);

				if(error)
				{
					return (FS_ENTRY)error;
				}

				fsg_GetDevAdvanceWidth (
					&key->pWorkSpaceAddr,
					&f26DevAdvanceWidth );
#ifdef FSCFG_SUBPIXEL
                if (bSubPixelWidth)
                /* we need to scale the value downs from hinting overscale */
                {
                    ROUND_FROM_HINT_OVERSCALE(f26DevAdvanceWidth.x);
                }
#endif // FSCFG_SUBPIXEL
			}
			psGlyphWidths[(size_t)(usGlyphIndex - usFirstGlyph)] = (int16)((f26DevAdvanceWidth.x + DOT6ONEHALF) >> 6);
		}
	}

	/* Restore current glyph    */

	key->ClientInfo.usGlyphIndex = usCurrentGlyphIndex;
	
	return NO_ERR;
}

/*********************************************************************/

/*                  Vertical Metrics Helper Function                 */

/*            returns AdvanceHeight vectors for glyph range          */

/*********************************************************************/

FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_GetScaledAdvanceHeights (
	fs_GlyphInputType * inputPtr,
	uint16              usFirstGlyph,
	uint16              usLastGlyph,
	shortVector *       psvAdvanceHeights)
{
	fs_SplineKey *      key;
	void *              pvGlobalGS;
	void *              pvFontProgram;
	void *              pvPreProgram;
	void *              pvStack;
	uint16              usGlyphIndex;
	uint16              usPPEm;
    uint16              usNonScaledAH;              /* advance height from vmtx */
	int16               sNonScaledTSB;              /* top side bearing from vmtx, not used */
	shortVector		    svDevAdvanceHeight;         /* advance height from sbits */
	vectorType			vecAdvanceHeight;
	vectorType			vecTopSideBearing;			/* not used */
	point               f26DevAdvanceHeight;
	boolean             bBitmapFound;
	ErrorCode           error;

	key = fs_SetUpKey(inputPtr, (INITIALIZED | NEWSFNT | NEWTRANS ), &error);

	if(!key)
	{
		return (FS_ENTRY)error;
	}

	if((key->apbPrevMemoryBases[WORK_SPACE_BASE] != key->memoryBases[WORK_SPACE_BASE]) ||
	   (key->apbPrevMemoryBases[PRIVATE_FONT_SPACE_BASE] != key->memoryBases[PRIVATE_FONT_SPACE_BASE]))
	{
		fsg_UpdateWorkSpaceAddresses(
			key->memoryBases[WORK_SPACE_BASE],
			&(key->WorkSpaceOffsets),
			&(key->pWorkSpaceAddr));

		pvStack = fsg_QueryStack(&key->pWorkSpaceAddr);

		fsg_UpdatePrivateSpaceAddresses(
			&key->ClientInfo,
			&key->maxProfile,
			key->memoryBases[PRIVATE_FONT_SPACE_BASE],
			&(key->PrivateSpaceOffsets),
			pvStack,
			&pvFontProgram,
			&pvPreProgram);

		MEMCPY(key->apbPrevMemoryBases, key->memoryBases, sizeof(char *) * (size_t)MEMORYFRAGMENTS);
	}

	pvGlobalGS = fsg_QueryGlobalGS(
		key->memoryBases[PRIVATE_FONT_SPACE_BASE],
		&(key->PrivateSpaceOffsets));

	/*  Check input parameters  */

	if( (usLastGlyph > key->maxProfile.numGlyphs ) ||
		(usLastGlyph < usFirstGlyph))
	{
		return INVALID_GLYPH_INDEX;
	}

	if( psvAdvanceHeights == NULL )
	{
		return NULL_INPUT_PTR_ERR;
	}

	/*  Find our current PPEm   */

	fsg_QueryPPEM(pvGlobalGS, &usPPEm);

	/* Handle each glyph    */

	for( usGlyphIndex = usFirstGlyph; usGlyphIndex <= usLastGlyph; usGlyphIndex++)
	{
		error = LookForSbitAdvanceHeight (
				key, 
				usGlyphIndex, 
				&bBitmapFound, 
				&f26DevAdvanceHeight);           /* values returned if found */

		if(error)
		{
			return (FS_ENTRY)error;
		}

		if (bBitmapFound)                      /*   if bitmap metrics found */
		{
			svDevAdvanceHeight.x = (int16)((f26DevAdvanceHeight.x + DOT6ONEHALF) >> 6);
			svDevAdvanceHeight.y = (int16)((f26DevAdvanceHeight.y + DOT6ONEHALF) >> 6);
		}
		else        /* if (bBitmapFound == FALSE)   if no bitmap, read vmtx */
		{
			error = sfac_ReadGlyphVertMetrics (
				&key->ClientInfo,
				usGlyphIndex,
				&usNonScaledAH,
				&sNonScaledTSB);

			if(error)
			{
				return (FS_ENTRY)error;
			}

			fsg_ScaleVerticalMetrics (
				&key->TransformInfo,
				pvGlobalGS,
				usNonScaledAH,
				sNonScaledTSB,
				&vecAdvanceHeight,
				&vecTopSideBearing);

			svDevAdvanceHeight.x = (int16)((vecAdvanceHeight.x + ONEHALFFIX) >> 16);
			svDevAdvanceHeight.y = (int16)((vecAdvanceHeight.y + ONEHALFFIX) >> 16);
		}
    	
    	*psvAdvanceHeights++ = svDevAdvanceHeight;
	}

	return NO_ERR;
}

/*********************************************************************/

/*  Look for an embedded bitmap, if found return the advance width */

FS_PRIVATE FS_ENTRY LookForSbitAdvanceWidth(
	fs_SplineKey *key,
	uint16 usGlyphIndex, 
	boolean *pbBitmapFound, 
	point *pf26DevAdvanceWidth )
{
	uint16      usFoundCode;
	ErrorCode   error;
	uint16		usBitDepth;			/* 1 for B/W bitmap, 2, 4 or 8 for gray sbit */
	
	*pbBitmapFound = FALSE;                 /* default value */

	error = sbit_SearchForBitmap(
		&key->SbitMono,
		&key->ClientInfo,
		usGlyphIndex, 
		key->SavedTransformInfo.usOverScale,
		&usBitDepth,
		&usFoundCode );

	if (error)
	{
		return (FS_ENTRY)error;
	}

	if (usFoundCode != 0)
	{
		error = sbit_GetDevAdvanceWidth (
			&key->SbitMono,
			&key->ClientInfo,
			pf26DevAdvanceWidth );
		
		if (error)
		{
			return (FS_ENTRY)error;
		}
		*pbBitmapFound = TRUE;
	}
	return NO_ERR;
}

/*********************************************************************/

/*  Look for an embedded bitmap, if found return the advance height */

FS_PRIVATE FS_ENTRY LookForSbitAdvanceHeight(
	fs_SplineKey *key,
	uint16 usGlyphIndex, 
	boolean *pbBitmapFound, 
	point *pf26DevAdvanceHeight )
{
	uint16      usFoundCode;
	ErrorCode   error;
	uint16		usBitDepth;			/* 1 for B/W bitmap, 2, 4 or 8 for gray sbit */
	
	*pbBitmapFound = FALSE;                 /* default value */

	error = sbit_SearchForBitmap(
		&key->SbitMono,
		&key->ClientInfo,
		usGlyphIndex, 
		key->SavedTransformInfo.usOverScale,
		&usBitDepth,
		&usFoundCode );

	if (error)
	{
		return (FS_ENTRY)error;
	}

	if (usFoundCode != 0)
	{
		error = sbit_GetDevAdvanceHeight (
			&key->SbitMono,
			&key->ClientInfo,
        	pf26DevAdvanceHeight);
		
		if (error)
		{
			return (FS_ENTRY)error;
		}
		*pbBitmapFound = TRUE;
	}
	return NO_ERR;
}


/*********************************************************************/

/*              Char Code to Glyph ID Helper Function                */

/*      returns glyph IDs for array or range of character codes      */

/*********************************************************************/

extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_GetGlyphIDs (
	fs_GlyphInputType * inputPtr,
	uint16	            usCharCount,
	uint16	            usFirstChar,
	uint16 *	        pusCharCode,
	uint16 *	        pusGlyphID)
{
	ErrorCode           error;
	fs_SplineKey *      key;

	key = fs_SetUpKey(inputPtr, (INITIALIZED | NEWSFNT), &error);
	if(!key)
	{
		return (FS_ENTRY)error;
	}

	error = sfac_GetMultiGlyphIDs(
	    &key->ClientInfo, 
	    usCharCount, 
	    usFirstChar, 
	    pusCharCode, 
	    pusGlyphID);

	if(error)
	{
		return (FS_ENTRY)error;
	}
	return NO_ERR;
}

/*********************************************************************/

/*              Char Code to Glyph ID Helper Function                */

/*   specific to Win95 - needs no font context, just a cmap pointer  */

/*********************************************************************/

extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_Win95GetGlyphIDs (
	uint8 *             pbyCmapSubTable,
	uint16	            usCharCount,
	uint16	            usFirstChar,
	uint16 *	        pusCharCode,
	uint16 *	        pusGlyphID)
{
	ErrorCode           error;

	error = sfac_GetWin95GlyphIDs(
	    pbyCmapSubTable, 
	    usCharCount, 
	    usFirstChar, 
	    pusCharCode, 
	    pusGlyphID);

	if(error)
	{
		return (FS_ENTRY)error;
	}
	return NO_ERR;
}

/*********************************************************************/

/*              Char Code to Glyph ID Helper Function                */

/*   specific to WinNT                                               */

/*********************************************************************/

/* special helper function fs_WinNTGetGlyphIDs
   - an offset ulCharCodeOffset is added to the character codes from pulCharCode 
     before converting the value to glyph index
   - pulCharCode and pulGlyphID are both uint32 *
   - pulCharCode and pulGlyphID can point to the same address        
*/
extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_WinNTGetGlyphIDs (
	fs_GlyphInputType * inputPtr,
	uint16	            usCharCount,
	uint16	            usFirstChar,
	uint32	            ulCharCodeOffset,
	uint32 *	        pulCharCode,
	uint32 *	        pulGlyphID)
{
	ErrorCode           error;
	fs_SplineKey *      key;

	key = fs_SetUpKey(inputPtr, (INITIALIZED | NEWSFNT), &error);
	if(!key)
	{
		return (FS_ENTRY)error;
	}

	error = sfac_GetWinNTGlyphIDs(
	    &key->ClientInfo, 
        key->maxProfile.numGlyphs,
	    usCharCount, 
	    usFirstChar, 
		ulCharCodeOffset,
	    pulCharCode, 
	    pulGlyphID);

	if(error)
	{
		return (FS_ENTRY)error;
	}
	return NO_ERR;
}


/*********************************************************************/

/*                Outline Coordinates Helper Function                */

/* returns (x,y) coordinates of array of points on the glyph outline */

/*********************************************************************/

extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_GetOutlineCoordinates (
	fs_GlyphInputType * inputPtr,
	uint16              usPointCount,
	uint16 *            pusPointIndex,
	shortVector *       psvCoordinates)
{
	ErrorCode       error;
	ContourList     CList;        /* newscan contour list type */
	fs_SplineKey *  key;

	key = fs_SetUpKey(inputPtr, (INITIALIZED | NEWSFNT | NEWTRANS | GOTINDEX | GOTGLYPH), &error);
	if(!key)
	{
		return (FS_ENTRY)error;
	}
	if (key->ulState & SIZEKNOWN)               /* fail a call after FindBimapSize */
	{
		return OUT_OFF_SEQUENCE_CALL_ERR;
	}
    
    if (key->bGlyphHasOutline == FALSE)
    {
        return BAD_POINT_INDEX_ERR;             /* no meaning if no outlines */
    }

	if(key->apbPrevMemoryBases[WORK_SPACE_BASE] != key->memoryBases[WORK_SPACE_BASE])
	{
		  fsg_UpdateWorkSpaceAddresses(
				key->memoryBases[WORK_SPACE_BASE],
				&(key->WorkSpaceOffsets),
				&(key->pWorkSpaceAddr));
		
		  fsg_UpdateWorkSpaceElement(
				&(key->WorkSpaceOffsets),
				&(key->pWorkSpaceAddr));
		
		  MEMCPY(key->apbPrevMemoryBases, key->memoryBases, sizeof(char *) * (size_t)MEMORYFRAGMENTS);
	}

	fsg_GetContourData(
		&key->pWorkSpaceAddr,
#ifdef FSCFG_SUBPIXEL
		(boolean)(key->flSubPixel & FNT_SP_SUB_PIXEL),            
#endif // FSCFG_SUBPIXEL
		&CList.afxXCoord,
		&CList.afxYCoord,
		&CList.asStartPoint,
		&CList.asEndPoint,
		&CList.abyOnCurve,
		&CList.abyFc,
		&CList.usContourCount);

	error = fsc_GetCoords(&CList, usPointCount, pusPointIndex, (PixCoord *)psvCoordinates);
	if (error != NO_ERR)
	{
		return(error);
	}

	return NO_ERR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\fondrv\tt\scaler\fshelper.h ===
/*
	 File:		 helper.h

	 Contains:	 Helper exports for Font Scaler

	 Written by: GregH

    Copyright:  (c) 1987-1990, 1992 by Apple Computer, Inc., all rights reserved.
                (c) 1989-1993. Microsoft Corporation, all rights reserved.

    Change History (most recent first):

		 <1>		 6/11/93	 GregH		Created.
*/

#ifndef FS_MATH_PROTO
#define FS_MATH_PROTO
#endif

int32 FS_MATH_PROTO ShortMulDiv(int32 a, int16 b, int16 c);	 /* (a*b)/c */

Fract FS_MATH_PROTO FracSqrt(Fract);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\fondrv\tt\scaler\sbit.c ===
/*********************************************************************

      sbit.c -- Embedded Bitmap Module

      (c) Copyright 1993-96  Microsoft Corp.  All rights reserved.

      04/01/96  claudebe    adding support for embedded grayscale bitmap
      02/07/95  deanb       Workspace pointers for GetMetrics & GetBitmap
      01/31/95  deanb       memset unrotated bitmap to zero
      01/27/95  deanb       usShaveLeft & usShaveRight added to sbit state
      12/21/94  deanb       rotation and vertical metrics support
      08/02/94  deanb       pf26DevLSB->y calculated correctly
      01/05/94  deanb       Bitmap scaling added
      11/29/93  deanb       First cut 
 
**********************************************************************/

#define FSCFG_INTERNAL

#include    "fscdefs.h"             /* shared data types  */
#include    "fserror.h"             /* error codes */
#include    "fontmath.h"            /* for inttodot6 macro */
        
#include    "sfntaccs.h"            /* sfnt access functions */
#include    "sbit.h"                /* own function prototypes */

/**********************************************************************/

#define MAX_BIT_INDEX	8			/* maximum bit index in a byte */

/*  Local structure */

typedef struct
{
    uint8*  pbySrc;                 /* unrotated source bitmap (as read) */
    uint8*  pbyDst;                 /* rotated destination bitmap (as returned) */
    uint16  usSrcBytesPerRow;       /* source bitmap width */
    uint16  usDstBytesPerRow;       /* destination bitmap width */
    uint16  usSrcX;                 /* source horiz pixel index */
    uint16  usSrcY;                 /* destination horiz pixel index */
    uint16  usDstX;                 /* source vert pixel index */
    uint16  usDstY;                 /* destination vert pixel index */
	uint16	usBitDepth;				/* bit depth of source/destination bitmap */
} 
CopyBlock;

/**********************************************************************/

/*  Local prototypes  */

FS_PRIVATE ErrorCode GetSbitMetrics(
    sbit_State      *pSbit,
    sfac_ClientRec  *pClientInfo 
);

FS_PRIVATE ErrorCode GetSbitComponent (
    sfac_ClientRec  *pClientInfo,
    uint32          ulStrikeOffset,
    uint16          usBitmapFormat,
    uint32          ulBitmapOffset,
    uint32          ulBitmapLength,
    uint16          usHeight,
    uint16          usWidth,
    uint16          usShaveLeft,
    uint16          usShaveRight,
    uint16          usShaveTop,
    uint16          usShaveBottom,
    uint16          usXOffset,
    uint16          usYOffset,
    uint16          usOriginalRowBytes,
    uint16          usExpandedRowBytes,
	uint16			usBitDepth,
    uint8           *pbyRead, 
    uint8           *pbyExpand 
);

FS_PRIVATE void ExpandSbitToBytePerPixel (
    uint16          usHeight,
    uint16          usWidth,
    uint16          usOriginalRowBytes,
    uint16          usExpandedRowBytes,
	uint16			usBitDepth,
    uint8           *pbySrcBitMap,
    uint8           *pbyDstBitMap );

FS_PRIVATE uint16 UScaleX(
    sbit_State  *pSbit,
    uint16      usValue
);

FS_PRIVATE uint16 UScaleY(
    sbit_State  *pSbit,
    uint16      usValue
);

FS_PRIVATE int16 SScaleX(
    sbit_State  *pSbit,
    int16       sValue
);

FS_PRIVATE int16 SScaleY(
    sbit_State  *pSbit,
    int16       sValue
);

FS_PRIVATE uint16 UEmScaleX(
    sbit_State  *pSbit,
    uint16      usValue
);

FS_PRIVATE uint16 UEmScaleY(
    sbit_State  *pSbit,
    uint16      usValue
);

FS_PRIVATE int16 SEmScaleX(
    sbit_State  *pSbit,
    int16       sValue
);

FS_PRIVATE int16 SEmScaleY(
    sbit_State  *pSbit,
    int16       sValue
);

FS_PRIVATE void ScaleVertical (
    uint8 *pbyBitmap,
    uint16 usBytesPerRow,
    uint16 usOrgHeight,
    uint16 usNewHeight
);

FS_PRIVATE void ScaleHorizontal (
    uint8 *pbyBitmap,
    uint16 usOrgBytesPerRow,
    uint16 usNewBytesPerRow,
	uint16 usBitDepth,
    uint16 usOrgWidth,
    uint16 usNewWidth,
    uint16 usRowCount
);

FS_PRIVATE void CopyBit(
    CopyBlock* pcb );

FS_PRIVATE ErrorCode SubstituteVertMetrics(
    sbit_State      *pSbit,
    sfac_ClientRec  *pClientInfo 
);

FS_PRIVATE ErrorCode SubstituteHorMetrics(
    sbit_State      *pSbit,
    sfac_ClientRec  *pClientInfo 
);



/**********************************************************************/
/***                                                                ***/
/***                       SBIT Functions                           ***/
/***                                                                ***/
/**********************************************************************/

/*  reset sbit state structure to default values */

#define MABS(x)                 ( (x) < 0 ? (-(x)) : (x) )

FS_PUBLIC ErrorCode sbit_NewTransform(
    sbit_State  *pSbit,
    uint16		usEmResolution,
    int16		sBoldSimulHorShift,
     int16		sBoldSimulVertShift,
    uint16          usPpemX,
    uint16          usPpemY,
    uint16          usRotation             /* 0 - 3 => 90 deg rotation, else not 90 */
	)
{
    pSbit->usPpemX = usPpemX;                       /* save requested ppem */
    pSbit->usPpemY = usPpemY;
    pSbit->usRotation = usRotation;                 /* used later on */

    pSbit->bGlyphFound = FALSE;
    pSbit->usTableState = SBIT_UN_SEARCHED;
    pSbit->usEmResolution = usEmResolution;

    /* with embedded bitmap, the emboldement is done before the rotation */
    pSbit->uBoldSimulHorShift = MABS(sBoldSimulHorShift); 
    pSbit->uBoldSimulVertShift = MABS(sBoldSimulVertShift); 
    if ((pSbit->usRotation == 1) || (pSbit->usRotation == 3))
    {
        /* with embedded bitmap, the emboldement is done before the rotation */
        uint16 temp;
        temp = pSbit->uBoldSimulHorShift;
        pSbit->uBoldSimulHorShift = pSbit->uBoldSimulVertShift;
        pSbit->uBoldSimulVertShift = temp;
    }
    return NO_ERR;
}

/**********************************************************************/

/*  Determine whether a glyph bitmap exists */

FS_PUBLIC ErrorCode sbit_SearchForBitmap(
    sbit_State      *pSbit,
    sfac_ClientRec  *pClientInfo,
    uint16          usGlyphCode,
	uint16          usOverScale,            /* outline magnification requested */
	uint16			*pusBitDepth,			/* 1 for B/W bitmap, 2, 4 or 8 for gray sbit */
    uint16          *pusFoundCode )         /* 0 = not found, 1 = bloc, 2 = bsca */
{    
    ErrorCode   ReturnCode;

    *pusFoundCode = 0;                              /* default */
    if (pSbit->usRotation > 3)
    {
        return NO_ERR;                              /* can't match a general rotation */
    }


    if (pSbit->usTableState == SBIT_UN_SEARCHED)    /* new trans - 1st glyph */
    {
        ReturnCode = sfac_SearchForStrike (         /* look for a strike */
            pClientInfo,
            pSbit->usPpemX, 
            pSbit->usPpemY, 
			usOverScale,            /* outline magnification requested */
			&pSbit->usBitDepth,			/* 1 for B/W bitmap, 2, 4 or 8 for gray sbit */
            &pSbit->usTableState,                   /* may set to BLOC or BSCA */
            &pSbit->usSubPpemX,                     /* if BSCA us this ppem */
            &pSbit->usSubPpemY,
            &pSbit->ulStrikeOffset );
        
        if (ReturnCode != NO_ERR) return ReturnCode;
    }

	*pusBitDepth = pSbit->usBitDepth;

    if ((pSbit->usTableState == SBIT_BLOC_FOUND) || 
        (pSbit->usTableState == SBIT_BSCA_FOUND))
    {
        ReturnCode = sfac_SearchForBitmap (         /* now look for this glyph */
            pClientInfo,
            usGlyphCode,
            pSbit->ulStrikeOffset,
            &pSbit->bGlyphFound,                    /* return values */
            &pSbit->usMetricsType,
            &pSbit->usMetricsTable,
            &pSbit->ulMetricsOffset,
            &pSbit->usBitmapFormat,
            &pSbit->ulBitmapOffset,
            &pSbit->ulBitmapLength );
        
        if (ReturnCode != NO_ERR) return ReturnCode;
        
        if (pSbit->bGlyphFound)
        {
            if (pSbit->usTableState == SBIT_BLOC_FOUND)
            {
                *pusFoundCode = 1;
            }
            else
            {
                *pusFoundCode = 2;
            }
            pSbit->bMetricsValid = FALSE;
        }
    }
    return NO_ERR;
}


/**********************************************************************/

FS_PUBLIC ErrorCode sbit_GetDevAdvanceWidth (
    sbit_State      *pSbit,
    sfac_ClientRec  *pClientInfo,
    point           *pf26DevAdvW )
{
    point       ptDevAdvW;                  /* unrotated metrics */
    ErrorCode   ReturnCode;
	boolean		bHorMetricsFound;
	boolean		bVertMetricsFound;

    ReturnCode = sfac_GetSbitMetrics (
        pClientInfo,
        pSbit->usMetricsType,
        pSbit->usMetricsTable,
        pSbit->ulMetricsOffset,
        &pSbit->usHeight,
        &pSbit->usWidth,
        &pSbit->sLSBearingX,
        &pSbit->sLSBearingY,
        &pSbit->sTopSBearingX,
        &pSbit->sTopSBearingY,
        &pSbit->usAdvanceWidth,
        &pSbit->usAdvanceHeight,
        &bHorMetricsFound,
        &bVertMetricsFound );
	
    if (ReturnCode != NO_ERR) return ReturnCode;

	/* we are only interested in AdvanceWidth */
	if (!bHorMetricsFound)
	{
		ReturnCode = SubstituteHorMetrics (pSbit, pClientInfo);
		if (ReturnCode != NO_ERR) return ReturnCode;
	}

    ptDevAdvW.x = INTTODOT6(UScaleX(pSbit, pSbit->usAdvanceWidth));
    ptDevAdvW.y = 0L;                           /* always zero for horizontal metrics */

 	switch(pSbit->usRotation)                   /* handle 90 degree rotations */
	{
	case 0:                                     /* no rotation */
        pf26DevAdvW->x = ptDevAdvW.x;
        pf26DevAdvW->y = ptDevAdvW.y;
		break;
	case 1:                                     /* 90 degree rotation */
        pf26DevAdvW->x = -ptDevAdvW.y;
        pf26DevAdvW->y = ptDevAdvW.x;
		break;
	case 2:                                     /* 180 degree rotation */
        pf26DevAdvW->x = -ptDevAdvW.x;
        pf26DevAdvW->y = -ptDevAdvW.y;
		break;
	case 3:                                     /* 270 degree rotation */
        pf26DevAdvW->x = ptDevAdvW.y;
        pf26DevAdvW->y = -ptDevAdvW.x;
		break;
	default:                                    /* non 90 degree rotation */
		return SBIT_ROTATION_ERR;
	}

    return NO_ERR;
}

#ifdef FSCFG_SUBPIXEL
FS_PUBLIC ErrorCode  sbit_CalcDevHorMetrics(
    sbit_State      *pSbit,
    sfac_ClientRec  *pClientInfo,
	F26Dot6 *       pDevAdvanceWidthX,
	F26Dot6 *       pDevLeftSideBearingX,
	F26Dot6 *       pDevRightSideBearingX)
{
    ErrorCode   ReturnCode;
	boolean		bHorMetricsFound;
	boolean		bVertMetricsFound;

	/* metrics without rotation */
    FS_ASSERT(((pSbit->usRotation == 0) || (pSbit->usRotation == 2)), "sbit_CalcDevHorMetrics called under rotation\n");

    ReturnCode = sfac_GetSbitMetrics (
        pClientInfo,
        pSbit->usMetricsType,
        pSbit->usMetricsTable,
        pSbit->ulMetricsOffset,
        &pSbit->usHeight,
        &pSbit->usWidth,
        &pSbit->sLSBearingX,
        &pSbit->sLSBearingY,
        &pSbit->sTopSBearingX,
        &pSbit->sTopSBearingY,
        &pSbit->usAdvanceWidth,
        &pSbit->usAdvanceHeight,
        &bHorMetricsFound,
        &bVertMetricsFound );
	
    if (ReturnCode != NO_ERR) return ReturnCode;

	if (!bHorMetricsFound)
	{
		ReturnCode = SubstituteHorMetrics (pSbit, pClientInfo);
		if (ReturnCode != NO_ERR) return ReturnCode;
	}

 	switch(pSbit->usRotation)                   /* handle 90 degree rotations */
	{
	case 0:                                     /* no rotation */
        *pDevAdvanceWidthX = INTTODOT6(UScaleX(pSbit, pSbit->usAdvanceWidth));
        *pDevLeftSideBearingX = INTTODOT6(UScaleX(pSbit, pSbit->sLSBearingX));
        *pDevRightSideBearingX = *pDevAdvanceWidthX - *pDevLeftSideBearingX - INTTODOT6(UScaleX(pSbit, pSbit->usWidth));
		break;
	case 2:                                     /* 180 degree rotation */
        *pDevAdvanceWidthX = -INTTODOT6(UScaleX(pSbit, pSbit->usAdvanceWidth));
        *pDevLeftSideBearingX = -INTTODOT6(UScaleX(pSbit, pSbit->sLSBearingX));
        *pDevRightSideBearingX = *pDevAdvanceWidthX - *pDevLeftSideBearingX + INTTODOT6(UScaleX(pSbit, pSbit->usWidth));
		break;
	default:                                    /* non 90 degree rotation */
		return SBIT_ROTATION_ERR;
	}
    

    return NO_ERR;
}
#endif // FSCFG_SUBPIXEL

/**********************************************************************/

FS_PUBLIC ErrorCode sbit_GetDevAdvanceHeight (
    sbit_State      *pSbit,
    sfac_ClientRec  *pClientInfo,
    point           *pf26DevAdvH )
{
    point       ptDevAdvH;                  /* unrotated metrics */
    ErrorCode   ReturnCode;
	boolean		bHorMetricsFound;
	boolean		bVertMetricsFound;

    ReturnCode = sfac_GetSbitMetrics (
        pClientInfo,
        pSbit->usMetricsType,
        pSbit->usMetricsTable,
        pSbit->ulMetricsOffset,
        &pSbit->usHeight,
        &pSbit->usWidth,
        &pSbit->sLSBearingX,
        &pSbit->sLSBearingY,
        &pSbit->sTopSBearingX,
        &pSbit->sTopSBearingY,
        &pSbit->usAdvanceWidth,
        &pSbit->usAdvanceHeight,
        &bHorMetricsFound,
        &bVertMetricsFound);
	
    if (ReturnCode != NO_ERR) return ReturnCode;

	/* we are only interested in AdvanceHeight */
	if (!bVertMetricsFound)
	{
		ReturnCode = SubstituteVertMetrics (pSbit, pClientInfo);
		if (ReturnCode != NO_ERR) return ReturnCode;
	}

/* set x components to zero */

    ptDevAdvH.x = 0L;
    ptDevAdvH.y = INTTODOT6(UScaleY(pSbit, pSbit->usAdvanceHeight));
        
     switch(pSbit->usRotation)                   /* handle 90 degree rotations */
    {
    case 0:                                     /* no rotation */
           pf26DevAdvH->x = ptDevAdvH.x;
           pf26DevAdvH->y = ptDevAdvH.y;
    	break;
    case 1:                                     /* 90 degree rotation */
           pf26DevAdvH->x = -ptDevAdvH.y;
           pf26DevAdvH->y = ptDevAdvH.x;
    	break;
    case 2:                                     /* 180 degree rotation */
           pf26DevAdvH->x = -ptDevAdvH.x;
           pf26DevAdvH->y = -ptDevAdvH.y;
    	break;
    case 3:                                     /* 270 degree rotation */
           pf26DevAdvH->x = ptDevAdvH.y;
           pf26DevAdvH->y = -ptDevAdvH.x;
    	break;
    default:                                    /* non 90 degree rotation */
    	return SBIT_ROTATION_ERR;
    }
	return NO_ERR;
}

/**********************************************************************/

FS_PUBLIC ErrorCode sbit_GetMetrics (
    sbit_State      *pSbit,
    sfac_ClientRec  *pClientInfo,
    point           *pf26DevAdvW,
    point           *pf26DevLSB,
    point           *pf26LSB,
    point           *pf26DevAdvH, 	/* NEW */
    point           *pf26DevTopSB,	/* NEW */
    point           *pf26TopSB,	/* NEW */
    Rect            *pRect,
    uint16          *pusRowBytes,
    uint32          *pulOutSize,
    uint32          *pulWorkSize )
{
    ErrorCode   ReturnCode;
    uint32      ulOrgMemSize;               /* size of unscaled bitmap */
    uint32      ulExpMemSize;               /* size of unscaled bitmap after gray expansion */
    uint32      ulScaMemSize;               /* size of scaled bitmap */
    uint32      ulMaxMemSize;               /* size of larger of scaled, unscaled */
    
    F26Dot6     f26DevAdvWx;                /* unrotated metrics */
    F26Dot6     f26DevAdvWy;
    F26Dot6     f26DevLSBx;
    F26Dot6     f26DevLSBy;
    F26Dot6     f26DevAdvHx;                /* unrotated metrics */
    F26Dot6     f26DevAdvHy;
    F26Dot6     f26DevTopSBx;
    F26Dot6     f26DevTopSBy;
    int16       sTop;                       /* unrotated bounds */
    int16       sLeft;
    int16       sBottom;
    int16       sRight;
	uint16		usOutBitDepth;				/* number of bit per pixel in the output */

	if (pSbit->usBitDepth == 1)
	{
		usOutBitDepth = 1;
	} else {
		usOutBitDepth = 8;
	}

    ReturnCode = GetSbitMetrics(pSbit, pClientInfo);
    if (ReturnCode != NO_ERR) return ReturnCode;
    
    pSbit->usScaledWidth = UScaleX(pSbit, pSbit->usWidth);
    pSbit->usScaledHeight = UScaleY(pSbit, pSbit->usHeight);


    
    sTop = SScaleY(pSbit, pSbit->sLSBearingY);            /* calc scaled metrics */
    sLeft = SScaleX(pSbit, pSbit->sLSBearingX);
    sBottom = sTop - (int16)pSbit->usScaledHeight;
    sRight = sLeft + (int16)pSbit->usScaledWidth;

    f26DevAdvWx = INTTODOT6(UScaleX(pSbit, pSbit->usAdvanceWidth));
    f26DevAdvWy = 0L;                   /* always zero for horizontal metrics */
    f26DevAdvHx = 0L;                   /* always zero for vertical metrics */
    f26DevAdvHy = INTTODOT6(UScaleY(pSbit, pSbit->usAdvanceHeight));
    f26DevLSBx = INTTODOT6(SScaleX(pSbit, pSbit->sLSBearingX));
    f26DevLSBy = INTTODOT6(SScaleY(pSbit, pSbit->sLSBearingY));
    f26DevTopSBx = INTTODOT6(SScaleX(pSbit, pSbit->sTopSBearingX));
    f26DevTopSBy = INTTODOT6(SScaleY(pSbit, pSbit->sTopSBearingY));

    pSbit->usOriginalRowBytes = ROWBYTESLONG(pSbit->usWidth * pSbit->usBitDepth);   /* keep unscaled */
    pSbit->usExpandedRowBytes = ROWBYTESLONG(pSbit->usWidth * usOutBitDepth);   /* keep unscaled */
    pSbit->usScaledRowBytes = ROWBYTESLONG(pSbit->usScaledWidth * usOutBitDepth);

	pSbit->ulReadMemSize = 0; /* size of extra memory, to read gray sbit under scaling or rotation */

    ulOrgMemSize = (uint32)pSbit->usHeight * (uint32)pSbit->usOriginalRowBytes;
    ulExpMemSize = (uint32)pSbit->usHeight * (uint32)pSbit->usExpandedRowBytes;
    ulScaMemSize = (uint32)pSbit->usScaledHeight * (uint32)pSbit->usScaledRowBytes;
    if (ulExpMemSize >= ulScaMemSize)
    {
         ulMaxMemSize = ulExpMemSize;
    }
    else
    {
         ulMaxMemSize = ulScaMemSize;
    }

 	switch(pSbit->usRotation)                   /* handle 90 degree rotations */
	{
	case 0:                                     /* no rotation */
        pRect->top = sTop;                      /* return scaled metrics */
        pRect->left = sLeft;
        pRect->bottom = sBottom;
        pRect->right = sRight;

        pf26DevAdvW->x = f26DevAdvWx;
        pf26DevAdvW->y = f26DevAdvWy;
        pf26DevLSB->x = f26DevLSBx;
        pf26DevLSB->y = f26DevLSBy;
        pf26LSB->x = f26DevLSBx;
        pf26LSB->y = INTTODOT6(sTop);

        pf26DevAdvH->x = f26DevAdvHx;
        pf26DevAdvH->y = f26DevAdvHy;
        pf26DevTopSB->x = f26DevTopSBx;
        pf26DevTopSB->y = f26DevTopSBy;
        pf26TopSB->x = f26DevTopSBx;
        pf26TopSB->y = f26DevTopSBy;

        pSbit->usOutRowBytes = ROWBYTESLONG(pSbit->usScaledWidth * usOutBitDepth);
		pSbit->ulOutMemSize = (uint32)pSbit->usScaledHeight * (uint32)pSbit->usOutRowBytes;

        if ((pSbit->usTableState == SBIT_BSCA_FOUND) || (pSbit->usBitDepth != 1))
        {
            pSbit->ulWorkMemSize = ulMaxMemSize;  /* room to read & scale or expand gray pixels */
			if (pSbit->usBitDepth != 1)
			{
				pSbit->ulWorkMemSize += ulOrgMemSize;  /* extra room to read gray pixels */
				pSbit->ulReadMemSize = ulOrgMemSize;
			}
        }
        else
        {
            pSbit->ulWorkMemSize = 0L;
        }
		break;
	case 1:                                     /* 90 degree rotation */
        pRect->top = sRight;
        pRect->left = -sTop;
        pRect->bottom = sLeft;
        pRect->right = -sBottom;
        
        pf26DevAdvW->x = -f26DevAdvWy;
        pf26DevAdvW->y = f26DevAdvWx;
        pf26DevLSB->x = -f26DevLSBy;
        pf26DevLSB->y = f26DevLSBx + INTTODOT6(sRight - sLeft);
        pf26LSB->x = 0L;
        pf26LSB->y = INTTODOT6(sRight) - f26DevLSBx;

        pf26DevAdvH->x = -f26DevAdvHy;
        pf26DevAdvH->y = f26DevAdvHx;
        pf26DevTopSB->x = -f26DevTopSBy;
        pf26DevTopSB->y = f26DevTopSBx + INTTODOT6(sRight - sLeft);

        pf26TopSB->x = INTTODOT6(-sTop) - f26DevTopSBy; 
        pf26TopSB->y = 0L; 	

        pSbit->usOutRowBytes = ROWBYTESLONG(pSbit->usScaledHeight * usOutBitDepth);
		pSbit->ulOutMemSize = (uint32)pSbit->usScaledWidth * (uint32)pSbit->usOutRowBytes; 
        pSbit->ulWorkMemSize = ulMaxMemSize;    /* room to read & scale or expand gray pixels */
		if (pSbit->usBitDepth != 1)
		{
			pSbit->ulWorkMemSize += ulOrgMemSize;  /* extra room to read gray pixels */
			pSbit->ulReadMemSize = ulOrgMemSize;
		}
		break;
	case 2:                                     /* 180 degree rotation */
        pRect->top = -sBottom;
        pRect->left = -sRight;
        pRect->bottom = -sTop;
        pRect->right = -sLeft;

        pf26DevAdvW->x = -f26DevAdvWx;
        pf26DevAdvW->y = -f26DevAdvWy;
        pf26DevLSB->x = -f26DevLSBx + INTTODOT6(sLeft - sRight);
        pf26DevLSB->y = -f26DevLSBy + INTTODOT6(sTop - sBottom);
        pf26LSB->x = -f26DevLSBx;
        pf26LSB->y = INTTODOT6(-sBottom);

        pf26DevAdvH->x = -f26DevAdvHx;
        pf26DevAdvH->y = -f26DevAdvHy;
        pf26DevTopSB->x = -f26DevTopSBx + INTTODOT6(sLeft - sRight);
        pf26DevTopSB->y = -f26DevTopSBy + INTTODOT6(sTop - sBottom);

		pf26TopSB->x = INTTODOT6(-sRight);	
        pf26TopSB->y = -f26DevTopSBy;

        pSbit->usOutRowBytes = ROWBYTESLONG(pSbit->usScaledWidth * usOutBitDepth);
		pSbit->ulOutMemSize = (uint32)pSbit->usScaledHeight * (uint32)pSbit->usOutRowBytes;
        pSbit->ulWorkMemSize = ulMaxMemSize;    /* room to read & scale or expand gray pixels */
		if (pSbit->usBitDepth != 1)
		{
			pSbit->ulWorkMemSize += ulOrgMemSize;  /* extra room to read gray pixels */
			pSbit->ulReadMemSize = ulOrgMemSize;
		}
		break;
	case 3:                                     /* 270 degree rotation */
        pRect->top = -sLeft;
        pRect->left = sBottom;
        pRect->bottom = -sRight;
        pRect->right = sTop;
        
        pf26DevAdvW->x = f26DevAdvWy;
        pf26DevAdvW->y = -f26DevAdvWx;
        pf26DevLSB->x = f26DevLSBy + INTTODOT6(sBottom - sTop);
        pf26DevLSB->y = -f26DevLSBx;
        pf26LSB->x = 0L;
        pf26LSB->y = INTTODOT6(-sLeft) + f26DevLSBx;

        pf26DevAdvH->x = f26DevAdvHy;
        pf26DevAdvH->y = -f26DevAdvHx;
        pf26DevTopSB->x = f26DevTopSBy + INTTODOT6(sBottom - sTop);
        pf26DevTopSB->y = -f26DevTopSBx;

        pf26TopSB->x = INTTODOT6(sBottom) -INTTODOT6(sTop) -INTTODOT6(sTop) + f26DevTopSBy;
        pf26TopSB->y = 0L;

        pSbit->usOutRowBytes = ROWBYTESLONG(pSbit->usScaledHeight * usOutBitDepth);
		pSbit->ulOutMemSize = (uint32)pSbit->usScaledWidth * (uint32)pSbit->usOutRowBytes;
        pSbit->ulWorkMemSize = ulMaxMemSize;    /* room to read & scale or expand gray pixels */
		if (pSbit->usBitDepth != 1)
		{
			pSbit->ulWorkMemSize += ulOrgMemSize;  /* extra room to read gray pixels */
			pSbit->ulReadMemSize = ulOrgMemSize;
		}
		break;
	default:                                    /* non 90 degree rotation */
		return SBIT_ROTATION_ERR;
	}
        
    *pusRowBytes = pSbit->usOutRowBytes;
    *pulOutSize = pSbit->ulOutMemSize;          /* return mem requirement */
    *pulWorkSize = pSbit->ulWorkMemSize;
    return NO_ERR;
}

/******************************Public*Routine******************************\
*
* sbit_Embolden adapted from vTtfdEmboldenX
*
* Does emboldening in the x direction
*
* History:
*  07-Jul-1998 -by- Claude Betrisey [ClaudeBe]
*      Moved the routine from ttfd into the rasterizer
*  24-Jun-1997 -by- Bodin Dresevic [BodinD]
* Stole from YungT
\**************************************************************************/

#define CJ_MONOCHROME_SCAN(cx)  (((cx)+7)/8)

/* embold only one pixel in the x direction */
#define DXABSBOLD 1

// array of masks for the last byte in a row

static uint8 gjMaskLeft[8] = {0XFF, 0X80, 0XC0, 0XE0, 0XF0, 0XF8, 0XFC, 0XFE };
static uint8 gjMaskRight[8] = {0XFF, 0X01, 0X03, 0X07, 0X0F, 0X1f, 0X3f, 0X7f };

//FS_PUBLIC void sbit_Embolden(uint8 *pbyBitmap, uint16 usBitmapWidth, uint16 usBitmapHeight, uint16 usRowBytes, uint16 uBoldSimulHorShift)
FS_PUBLIC void sbit_Embolden(uint8 *pbyBitmap, uint16 usBitmapWidth, uint16 usBitmapHeight, uint16 usRowBytes, int16 sBoldSimulHorShift, int16 sBoldSimulVertShift)
{
    uint8   *pCur, *pyCur, *pyCurEnd, *pAdd, newByte;	

    uint8    beginMask, endMask;
    int32    i, j;
    int32    noOfValidBitsAtEndBold;
    int32    noOfValidBitsAtEndNormal;
    int32    noOfBytesForOneLineNormal;
    int32    noOfBytesForOneLineBold;
    int32   nBytesMore;
    uint8 *pyTopNormal, *pyBottomNormal, *pyTopBold, *pyBottomBold;	

	// we want to embolden by sBoldSimulHorShift pixels horizontally(if sBoldSimulHorShift>0 then to the right; else to the left) along the base line 
    // and by sBoldSimulVertShift vertically(if sBoldSimulVertShift>0 then to the bottom; else to the top) )

	if ((usBitmapHeight == 0) || (pbyBitmap == NULL))
	{
		return;                              /* quick out for null glyph */
	}


    noOfValidBitsAtEndBold = usBitmapWidth & 7; // styoo: same as noOfValidBitsAtEndBold = usBitmapWidth % 8

    // Before emboldening,the origninal image had scans of width
    // usBitmapWidth - sBoldSimulHorShift.

    noOfBytesForOneLineBold = CJ_MONOCHROME_SCAN(usBitmapWidth);
    if( sBoldSimulHorShift >= 0 ){
        noOfBytesForOneLineNormal = CJ_MONOCHROME_SCAN(usBitmapWidth - sBoldSimulHorShift);
        noOfValidBitsAtEndNormal = (usBitmapWidth - sBoldSimulHorShift) & 7; // styoo: same as noOfValidBitsAtEndNormal = (usBitmapWidth - sBoldSimulHorShift) % 8
    }
    else{
        noOfBytesForOneLineNormal = CJ_MONOCHROME_SCAN(usBitmapWidth - (-sBoldSimulHorShift));
        noOfValidBitsAtEndNormal = (usBitmapWidth - (-sBoldSimulHorShift)) & 7; // styoo: same as noOfValidBitsAtEndNormal = (usBitmapWidth - sBoldSimulHorShift) % 8
    }

    if( sBoldSimulVertShift >= 0 ){
        pyTopNormal = pbyBitmap;
        pyBottomNormal = pbyBitmap + (usBitmapHeight-sBoldSimulVertShift-1)*usRowBytes;
        pyTopBold = pbyBitmap;
        pyBottomBold = pbyBitmap + (usBitmapHeight-1)*usRowBytes;
    }
    else{
        pyTopNormal = pbyBitmap+(-sBoldSimulVertShift)*usRowBytes;
        pyBottomNormal = pbyBitmap + (usBitmapHeight-1)*usRowBytes;
        pyTopBold = pbyBitmap;
        pyBottomBold = pyBottomNormal;
    }

//=============================================================================================================
	//Horizontal To Right
    if( sBoldSimulHorShift > 0){
        endMask = gjMaskLeft[noOfValidBitsAtEndNormal];

        for (pyCur = pyTopNormal ; pyCur <= pyBottomNormal ; pyCur += usRowBytes)
        {
		    // Clear additional Horizontal pixels
            /***************************************************************
            *    Before emboldening,the origninal image had scans of width *
            *    usBitmapWidth - sBoldSimulHorShift. Any pixels beyond this limit are       *
            *    currently garbage and must be cleared. This means that    *
            *    if the width of the emboldened bitmap is even then the low*
            *    nibble of the last byte of each scan must be cleared      *
            *    otherwise the last byte of each scan must be cleared.     *
            ***************************************************************/
            

            pCur = &pyCur[noOfBytesForOneLineNormal - 1];
            *pCur &= endMask;

            pCur++;
            while( pCur < pyCur+usRowBytes ){
                *pCur = 0;
                pCur++;
            }

            //
            pCur = &pyCur[noOfBytesForOneLineBold - 1];

            while( pCur >= pyCur)
            {
                newByte = *pCur;
                // nByteMore is how many bytes we have to borrow for bitwise oring
                // for example, if sBoldSimulHorShift is 8, we need to borrow 2 bytes(current byte(0) and previous byte(-1))
                // if if sBoldSimulHorShift is 9, we need to borrow 3 bytes(current byte(0) and 2 previous bytes(-1,-2)
                nBytesMore = (sBoldSimulHorShift+7)/8;

                for(i = 1; i <= sBoldSimulHorShift; i++){
                    for(j = 0; j<= nBytesMore; j++){
                        // if pCur-j < pyCur then out of bound
                        if(pCur-j < pyCur)
                            break;

                        if( (i-j*8) >= 0 && (i-j*8) < 8 )
                            newByte |= (pCur[-j] >> (i-j*8));
                        else if( (i-j*8) < 0 && (i-j*8) > -8 )
                            newByte |= (pCur[-j] << (j*8 - i));
                    }
                }
                *pCur = newByte;

                pCur--;
            }

        // Special implementation for the last byte, styoo: don't need to borrow from previous byte

        }
    }

    //Horizontal To Left
    else if( sBoldSimulHorShift < 0){
        beginMask = gjMaskRight[8-(-sBoldSimulHorShift)];
        endMask = gjMaskLeft[noOfValidBitsAtEndBold];

        for (pyCur = pyTopNormal ; pyCur <= pyBottomNormal ; pyCur += usRowBytes)
        {
		    // Clear additional Horizontal pixels
            /***************************************************************
            *    Before emboldening,the origninal image had scans of width *
            *    usBitmapWidth - (-sBoldSimulHorShift). Any pixels beyond this limit are       *
            *    currently garbage and must be cleared. This means that    *
            *    if the width of the emboldened bitmap is even then the low*
            *    nibble of the last byte of each scan must be cleared      *
            *    otherwise the last byte of each scan must be cleared.     *
            ***************************************************************/

            pCur = pyCur;
            *pCur &= beginMask;

            pCur = &pyCur[noOfBytesForOneLineBold-1];
            *pCur &= endMask;
            pCur++;

            while( pCur < pyCur+usRowBytes ){
                *pCur = 0;
                pCur++;
            }

            //
            pCur = pyCur;
            pyCurEnd = pyCur+(noOfBytesForOneLineBold-1);

            while( pCur <= pyCurEnd)
            {
                newByte = *pCur;

                // nByteMore is how many bytes we have to borrow for bitwise oring
                // for example, if sBoldSimulHorShift is -8, we need to borrow 2 bytes(current byte(0) and next byte(+1))
                // if if sBoldSimulHorShift is -9, we need to borrow 3 bytes(current byte(0) and 2 next bytes(+1,+2)
                nBytesMore = (-sBoldSimulHorShift+7)/8;

                for(i = 1; i <= -sBoldSimulHorShift; i++){
                    for(j = 0; j<= nBytesMore; j++){
                        // if pCur+j > pyCur+usRowBytes then out of bound
                        if(pCur+j > pyCurEnd)
                            break;

                        if( (i-j*8) >= 0 && (i-j*8) < 8 )
                            newByte |= (pCur[j] << (i-j*8));
                        else if( (i-j*8) < 0 && (i-j*8) > -8 )
                            newByte |= (pCur[j] >> (j*8 - i));
                    }
                }
                *pCur = newByte;

                pCur++;
            }

            // Special implementation for the last byte, styoo: don't need to borrow from previous byte


        }
    }
    // Vertical To the Bottom
	if( sBoldSimulVertShift > 0 ){
		// Clear additional vertical lines
        pyCur = pyBottomNormal + usRowBytes;
        while(pyCur <= pyBottomBold){
            pCur = pyCur;
			for(i=0; i<usRowBytes;i++,pCur++)
				*pCur = 0;

            pyCur += usRowBytes;
        }

        //
		pyCur = pyBottomBold;
		while ( pyCur > pyTopNormal){
			pCur = pyCur;
			for(i=0; i<noOfBytesForOneLineBold;i++,pCur++){
				newByte = *pCur;

				for(j=1; j<=sBoldSimulVertShift; j++){
                    pAdd = pCur - j*usRowBytes;
					if(pAdd >= pyTopNormal)
						newByte |= *pAdd;
					else 
						break;
				}

                *pCur = newByte;
			}

			pyCur -= usRowBytes;
		}

	}
    // Vertical To the Top
	else if( sBoldSimulVertShift < 0 ){

		// Clear additional Vertical lines
        pyCur = pyTopNormal - usRowBytes;
        while(pyCur >= pyTopBold){
            pCur = pyCur;
			for(i=0; i<usRowBytes;i++,pCur++)
				*pCur = 0;

            pyCur -= usRowBytes;
        }
        
		//
		pyCur = pyTopBold;
		while ( pyCur < pyBottomNormal){
			pCur = pyCur;
			for(i=0; i<noOfBytesForOneLineBold;i++,pCur++){
				newByte = *pCur;

				for(j=1; j<=-sBoldSimulVertShift; j++){
                    pAdd = pCur + j*usRowBytes;
					if(pAdd < pyBottomNormal+usRowBytes)
						newByte |= *pAdd;
					else 
						break;
				}

                *pCur = newByte;
			}

			pyCur += usRowBytes;
		}
	}
}

/******************************Public*Routine******************************\
* sbit_EmboldenGray adapted from vEmboldenOneBitGrayBitmap
*
* History:
*  03-Mar-2000 -by- Sung-Tae Yoo [styoo]
*      Bitmap level emboldening
*  07-Jul-1998 -by- Claude Betrisey [ClaudeBe]
*      Moved the routine from ttfd into the rasterizer
*  Wed 28-May-1997 by Tony Tsai [YungT]
*      Rename the function name, a special case for 1-bit embolden
*  Wed 22-Feb-1995 13:21:55 by Kirk Olynyk [kirko]
* Wrote it.
\**************************************************************************/

//FS_PUBLIC void sbit_EmboldenGray(uint8 *pbyBitmap, uint16 usBitmapWidth, uint16 usBitmapHeight, uint16 usRowBytes, uint16 usGrayLevels, uint16 uBoldSimulHorShift)
FS_PUBLIC void sbit_EmboldenGray(uint8 *pbyBitmap, uint16 usBitmapWidth, uint16 usBitmapHeight, uint16 usRowBytes, uint16 usGrayLevels, int16 sBoldSimulHorShift, int16 sBoldSimulVertShift)
{
    uint8 newPix;
    uint8 *pCur, *pyCur, *pAdd;	
    int32  i, j;
    uint8 *pyTopNormal, *pyBottomNormal, *pyTopBold, *pyBottomBold;	

	if ((usBitmapHeight == 0) || (pbyBitmap == NULL))
	{
		return;                              /* quick out for null glyph */
	}

    if( sBoldSimulVertShift >= 0 ){
        pyTopNormal = pbyBitmap;
        pyBottomNormal = pbyBitmap + (usBitmapHeight-sBoldSimulVertShift-1)*usRowBytes;
        pyTopBold = pbyBitmap;
        pyBottomBold = pbyBitmap + (usBitmapHeight-1)*usRowBytes;
    }
    else{
        pyTopNormal = pbyBitmap+(-sBoldSimulVertShift)*usRowBytes;
        pyBottomNormal = pbyBitmap + (usBitmapHeight-1)*usRowBytes;
        pyTopBold = pbyBitmap;
        pyBottomBold = pyBottomNormal;
    }

	//Horizontal To Right
    if( sBoldSimulHorShift > 0 ){
        for (pyCur = pyTopNormal ; pyCur <= pyBottomNormal ; pyCur += usRowBytes)
        {
		    // Clear additional Horizontal pixels

            /***************************************************************
            *    Before emboldening,the origninal image had scans of width *
            *    usBitmapWidth - sBoldSimulHorShift. Any pixels beyond this limit are       *
            *    currently garbage and must be cleared. This means that    *
            *    if the width of the emboldened bitmap is even then the low*
            *    nibble of the last byte of each scan must be cleared      *
            *    otherwise the last byte of each scan must be cleared.     *
            ***************************************************************/

            pCur = pyCur + (usBitmapWidth - 1);
			for(i=0; i<sBoldSimulHorShift;i++,pCur--)
				*pCur = 0;

            // set pCur to point to the last byte in the scan
            pCur = pyCur + (usBitmapWidth - 1);

            /***************************************************
            *    start at the right edge of the scan and work  *
            *    back toward the left edge                     *
            ***************************************************/

            while ( pCur > pyCur )
            {
			    newPix = *pCur;

			    for(i=1; i<=sBoldSimulHorShift; i++){
				    if( (pCur-i) >= pyCur )
                    {
					  newPix += *(pCur-i);
                      if (newPix >= usGrayLevels){
                          newPix = (uint8)(usGrayLevels -1);
                          break;
                      }
                    }
			    }

                *pCur = newPix;

			    pCur--;
            }
        }
	}
	//Horizontal To Left
    else if( sBoldSimulHorShift < 0 ){
        for (pyCur = pyTopNormal ; pyCur <= pyBottomNormal ; pyCur += usRowBytes)
        {
		    // Clear additional Horizontal pixels
            /***************************************************************
            *    Before emboldening,the origninal image had scans of width *
            *    usBitmapWidth - (-sBoldSimulHorShift). Any pixels beyond this limit are       *
            *    currently garbage and must be cleared. This means that    *
            *    if the width of the emboldened bitmap is even then the low*
            *    nibble of the last byte of each scan must be cleared      *
            *    otherwise the last byte of each scan must be cleared.     *
            ***************************************************************/

            pCur = pyCur;
			for(i=0; i<-sBoldSimulHorShift;i++,pCur++)
				*pCur = 0;

            /***************************************************
            *    start at the leftt edge of the scan and work  *
            *    back toward the right edge                     *
            ***************************************************/

            pCur = pyCur;
            while ( pCur < pyCur+usBitmapWidth )
            {
			    newPix = *pCur;

			    for(i=1; i<=-sBoldSimulHorShift; i++){
				    if( (pCur+i) < pyCur+usBitmapWidth )
                    {
					    newPix += *(pCur+i);
                        if (newPix >= usGrayLevels){
                            newPix = (uint8)(usGrayLevels -1);
                            break;
                        }
                    }
			    }


                *pCur = newPix;

			    pCur++;
            }
        }
	}

    // Vertical To Down
	if( sBoldSimulVertShift > 0 ){

		// Clear additional vertical lines
        pyCur = pyBottomNormal + usRowBytes;
        while(pyCur <= pyBottomBold){
            pCur = pyCur;
			for(i=0; i<usBitmapWidth;i++,pCur++)
				*pCur = 0;

            pyCur += usRowBytes;
        }
        
		//
		pyCur = pyBottomBold;
		while ( pyCur > pyTopNormal){
			pCur = pyCur;
			for(i=0; i<usBitmapWidth;i++,pCur++){
				newPix = *pCur;

				for(j=1; j<=sBoldSimulVertShift; j++){
                    pAdd = pCur - j*usRowBytes;
					if(pAdd >= pyTopNormal)
                    {
						newPix += *pAdd;
                        if (newPix >= usGrayLevels){
					        newPix = (uint8)(usGrayLevels -1);
                            break;
                        }
                    }
					else 
						break;
				}


                *pCur = newPix;
			}

			pyCur -= usRowBytes;
		}
	}

    // Vertical To Up
	else if( sBoldSimulVertShift < 0 ){

		// Clear additional Vertical lines
        pyCur = pyTopNormal - usRowBytes;
        while(pyCur >= pyTopBold){
            pCur = pyCur;
			for(i=0; i<usBitmapWidth;i++,pCur++)
				*pCur = 0;

            pyCur -= usRowBytes;
        }
        
		//
		pyCur = pyTopBold;
		while ( pyCur < pyBottomNormal){
			pCur = pyCur;
			for(i=0; i<usBitmapWidth;i++,pCur++){
				newPix = *pCur;

				for(j=1; j<=-sBoldSimulVertShift; j++){
                    pAdd = pCur + j*usRowBytes;
					if(pAdd < pyBottomNormal+usRowBytes)
                    {
						newPix += *pAdd;
                        if (newPix >= usGrayLevels){
					        newPix = (uint8)(usGrayLevels -1);
                            break;
                        }
                    }
					else 
						break;
				}


                *pCur = newPix;
			}

			pyCur += usRowBytes;
		}
	}
}

#ifdef FSCFG_SUBPIXEL

#define MAX(a,b)    ((a) > (b) ? (a) : (b))

/******************************Public*Routine******************************\
* sbit_EmboldenSubPixel adapted from vEmboldenOneBitGrayBitmap
*
* History:
*  03-Mar-2000 -by- Sung-Tae Yoo [styoo]
*      Bitmap level emboldening
*  07-Jul-1998 -by- Claude Betrisey [ClaudeBe]
*      Moved the routine from ttfd into the rasterizer
*  Wed 28-May-1997 by Tony Tsai [YungT]
*      Rename the function name, a special case for 1-bit embolden
*  Wed 22-Feb-1995 13:21:55 by Kirk Olynyk [kirko]
* Wrote it.
\**************************************************************************/

//FS_PUBLIC void sbit_EmboldenSubPixel(uint8 *pbyBitmap, uint16 usBitmapWidth, uint16 usBitmapHeight, uint16 usRowBytes, uint16 uBoldSimulHorShift)
FS_PUBLIC void sbit_EmboldenSubPixel(uint8 *pbyBitmap, uint16 usBitmapWidth, uint16 usBitmapHeight, uint16 usRowBytes, int16 sBoldSimulHorShift, int16 sBoldSimulVertShift)
{
    uint8 *pCur, *pyCur, *pAdd;	
    int32  i, j;
	uint8 newPix;
    uint8 *pyTopNormal, *pyBottomNormal, *pyTopBold, *pyBottomBold;	

	if ((usBitmapHeight == 0) || (pbyBitmap == NULL))
	{
		return;                              /* quick out for null glyph */
	}

    if( sBoldSimulVertShift >= 0 ){
        pyTopNormal = pbyBitmap;
        pyBottomNormal = pbyBitmap + (usBitmapHeight-sBoldSimulVertShift-1)*usRowBytes;
        pyTopBold = pbyBitmap;
        pyBottomBold = pbyBitmap + (usBitmapHeight-1)*usRowBytes;
    }
    else{
        pyTopNormal = pbyBitmap+(-sBoldSimulVertShift)*usRowBytes;
        pyBottomNormal = pbyBitmap + (usBitmapHeight-1)*usRowBytes;
        pyTopBold = pbyBitmap;
        pyBottomBold = pyBottomNormal;
    }


	//Horizontal To Right
    if( sBoldSimulHorShift > 0 ){
        for (pyCur = pyTopNormal ; pyCur <= pyBottomNormal ; pyCur += usRowBytes)
        {
		    // Clear additional Horizontal pixels in the right side
            /***************************************************************
            *    Before emboldening,the origninal image had scans of width *
            *    usBitmapWidth - sBoldSimulHorShift. Any pixels beyond this limit are       *
            *    currently garbage and must be cleared. This means that    *
            *    if the width of the emboldened bitmap is even then the low*
            *    nibble of the last byte of each scan must be cleared      *
            *    otherwise the last byte of each scan must be cleared.     *
            ***************************************************************/

            pCur = pyCur + (usBitmapWidth - 1);
			for(i=0; i<sBoldSimulHorShift;i++,pCur--)
				*pCur = 0;

            // set pCur to point to the last byte in the scan
            pCur = pyCur + (usBitmapWidth - 1);

            /***************************************************
            *    start at the right edge of the scan and work  *
            *    back toward the left edge                     *
            ***************************************************/

            while ( pCur > pyCur )
            {
			    newPix = *pCur;

			    for(i=1; i<=sBoldSimulHorShift; i++){
				    if( (pCur-i) >= pyCur && *(pCur-i) )
                    {
                        if(newPix){
                            newPix = (uint8)MAX_RGB_INDEX;
						    break;
                        }
					    else
						    newPix = *(pCur-i);
					}
			    }

                *pCur = newPix;

			    pCur--;
            }
        }
	}
	//Horizontal To Left
    else if( sBoldSimulHorShift < 0 ){
        for (pyCur = pyTopNormal ; pyCur <= pyBottomNormal ; pyCur += usRowBytes)
        {
		    // Clear additional Horizontal pixels in the left side
            /***************************************************************
            *    Before emboldening,the origninal image had scans of width *
            *    usBitmapWidth - (-sBoldSimulHorShift). Any pixels beyond this limit are       *
            *    currently garbage and must be cleared. This means that    *
            *    if the width of the emboldened bitmap is even then the low*
            *    nibble of the last byte of each scan must be cleared      *
            *    otherwise the last byte of each scan must be cleared.     *
            ***************************************************************/

            pCur = pyCur;
			for(i=0; i<-sBoldSimulHorShift;i++,pCur++)
				*pCur = 0;

            /***************************************************
            *    start at the left edge of the scan and work  *
            *    back toward the right edge                     *
            ***************************************************/

            pCur = pyCur;
            while ( pCur < pyCur+usBitmapWidth )
            {
			    newPix = *pCur;

			    for(i=1; i<=-sBoldSimulHorShift; i++){
                    if( (pCur+i) < pyCur+usBitmapWidth && *(pCur+i) ){
                        if(newPix){
                            newPix = (uint8)MAX_RGB_INDEX;
						    break;
                        }
					    else
						    newPix = *(pCur+i);
                    }
			    }

                *pCur = newPix;

			    pCur++;
            }
        }
	}

    // Vertical To Down
	if( sBoldSimulVertShift > 0 ){

		// Clear additional vertical lines
        pyCur = pyBottomNormal + usRowBytes;
        while(pyCur <= pyBottomBold){
            pCur = pyCur;
			for(i=0; i<usBitmapWidth;i++,pCur++)
				*pCur = 0;

            pyCur += usRowBytes;
        }
        
		//
		pyCur = pyBottomBold;
		while ( pyCur > pyTopNormal){
			pCur = pyCur;
			for(i=0; i<usBitmapWidth;i++,pCur++){
				newPix = *pCur;

				for(j=1; j<=sBoldSimulVertShift; j++){
                    pAdd = pCur - j*usRowBytes;
                    if(pAdd >= pyTopNormal){
                        if(*pAdd && newPix){
                            newPix = MAX(*pAdd,newPix);
                            break;
                        }
                        else if(*pAdd && !newPix){
                            newPix = *pAdd;
                        }
                    }
					else 
						break;
				}

                *pCur = newPix;
			}

			pyCur -= usRowBytes;
		}
	}
    // Vertical To Up
	else if( sBoldSimulVertShift < 0 ){

		// Clear additional Vertical lines
        pyCur = pyTopNormal - usRowBytes;
        while(pyCur >= pyTopBold){
            pCur = pyCur;
			for(i=0; i<usBitmapWidth;i++,pCur++)
				*pCur = 0;

            pyCur -= usRowBytes;
        }
        
		//
		pyCur = pyTopBold;
		while ( pyCur < pyBottomNormal){
			pCur = pyCur;
			for(i=0; i<usBitmapWidth;i++,pCur++){
				newPix = *pCur;

				for(j=1; j<=-sBoldSimulVertShift; j++){
                    pAdd = pCur + j*usRowBytes;
                    if(pAdd < pyBottomNormal+usRowBytes){
                        if(*pAdd && newPix){
                            newPix = MAX(*pAdd,newPix);
                            break;
                        }
                        else if(*pAdd && !newPix){
                            newPix = *pAdd;
                        }
                    }
                    else 
						break;
				}

                *pCur = newPix;
			}

			pyCur += usRowBytes;
		}
	}

    // Second Pass to modify non edge pixel to MaxIndex
    if( MABS(sBoldSimulVertShift) > 1 ){ // If adding 2 or more pix vertically
        pyCur = pyTopBold+usRowBytes;
        while(pyCur < pyBottomBold){
            uint8 *pEndOfLine = pyCur+usBitmapWidth-1;

            pCur = pyCur+1;
            while(pCur < pEndOfLine){
                if( *pCur > (uint8)0 && *pCur < (uint8)MAX_RGB_INDEX){  // If it's color pix
                    if( *(pCur-1) && *(pCur+1) && *(pCur-usRowBytes) && *(pCur+usRowBytes)){  // If it's not edge pix
                        *pCur = (uint8)MAX_RGB_INDEX;
                    }
                }
                pCur++;
            }
            pyCur += usRowBytes;
        }
    }
}
#endif // FSCFG_SUBPIXEL

/**********************************************************************/
/*  if scaling or rotating, read bitmap into workspace,               */
/*  fix it up and copy it to the output map                           */

FS_PUBLIC ErrorCode sbit_GetBitmap (
    sbit_State      *pSbit,
    sfac_ClientRec  *pClientInfo,
    uint8           *pbyOut,
    uint8           *pbyWork )
{
    ErrorCode   ReturnCode;
    uint8       *pbyRead;
    uint8       *pbyExpand;
    CopyBlock   cb;                                 /* for bitmap rotations */
    uint16      usSrcXMax;
    uint16      usSrcYMax;

    MEMSET(pbyOut, 0, pSbit->ulOutMemSize);         /* always clear the output map */

    if ((pSbit->usRotation == 0) &&                 /* if no rotation */
        (pSbit->usTableState != SBIT_BSCA_FOUND))   /* and no scaling */
    {
		if (pSbit->usBitDepth != 1)
		{
			MEMSET(pbyWork, 0, pSbit->ulWorkMemSize);
			pbyRead = pbyWork;                       /* read in the work memory */
			pbyExpand = pbyOut;						 /* expand in the output */
		} else {
			pbyRead = pbyOut;                           /* read straight to output map */
			pbyExpand = NULL;							/* expansion memory not used in that case */
		}
    } else                                            /* if any rotation or scaling */
    {
        MEMSET(pbyWork, 0, pSbit->ulWorkMemSize);
		if (pSbit->usBitDepth != 1)
		{
			pbyRead = pbyWork;                       /* read in the work memory */
			pbyExpand = pbyWork + pSbit->ulReadMemSize;	/* expand in the work memory */
		} else {
			pbyRead = pbyWork;                          /* read into workspace */
			pbyExpand = pbyWork;						/* scaling done in pbyExpand */
		}
    }

    ReturnCode = GetSbitComponent (                 /* fetch the bitmap */
        pClientInfo,
        pSbit->ulStrikeOffset,
        pSbit->usBitmapFormat,                      /* root data only in state */
        pSbit->ulBitmapOffset,
        pSbit->ulBitmapLength,
        pSbit->usHeight,
        pSbit->usWidth,
        pSbit->usShaveLeft,
        pSbit->usShaveRight,
        pSbit->usShaveTop,
        pSbit->usShaveBottom,
        0,                                          /* no offset for the root */
        0,
        pSbit->usOriginalRowBytes,
        pSbit->usExpandedRowBytes,
		pSbit->usBitDepth,
        pbyRead,
		pbyExpand);
            
    if (ReturnCode != NO_ERR) return ReturnCode;

    
    if (pSbit->usTableState == SBIT_BSCA_FOUND)
    {
        ScaleVertical (
            pbyExpand, 
            pSbit->usExpandedRowBytes, 
            pSbit->usHeight, 
            pSbit->usScaledHeight );

        ScaleHorizontal (
            pbyExpand, 
            pSbit->usExpandedRowBytes,
            pSbit->usScaledRowBytes,
            pSbit->usBitDepth, 
            pSbit->usWidth, 
            pSbit->usScaledWidth,
            pSbit->usScaledHeight );
            
        if (pSbit->usRotation == 0)                         /* if no rotation */
        {
            MEMCPY (pbyOut, pbyExpand, pSbit->ulOutMemSize);  /* keep this one */
        }
		/* in the SBIT_BSCA_FOUND the bitmap was already scaled to the final usScaledWidth, no need for additional emboldment */
	} else {
		if ((pSbit->uBoldSimulHorShift != 0) || (pSbit->uBoldSimulVertShift != 0))
		{
			if (pSbit->usRotation == 0)                             /* if no rotation */
			{
				cb.pbySrc = pbyOut;
			} else 
			{
				cb.pbySrc = pbyExpand;
			}
    
			if (pSbit->usBitDepth == 1)
			{
				sbit_Embolden(cb.pbySrc, pSbit->usScaledWidth, pSbit->usScaledHeight, pSbit->usScaledRowBytes, pSbit->uBoldSimulHorShift, pSbit->uBoldSimulVertShift);
			} else {
				uint16 usGrayLevels = (0x01 << pSbit->usBitDepth) ; /* Max gray level index */
				sbit_EmboldenGray(cb.pbySrc, pSbit->usScaledWidth, pSbit->usScaledHeight, pSbit->usScaledRowBytes, usGrayLevels, pSbit->uBoldSimulHorShift, pSbit->uBoldSimulVertShift);
			}

		}
    }

    if (pSbit->usRotation == 0)                             /* if no rotation */
    {
        return NO_ERR;                                      /* done */
    }
    
    cb.pbySrc = pbyExpand;
    cb.pbyDst = pbyOut;
    cb.usSrcBytesPerRow = pSbit->usScaledRowBytes;
    cb.usDstBytesPerRow = pSbit->usOutRowBytes;

	cb.usBitDepth = 1;
	if (pSbit->usBitDepth != 1)
		cb.usBitDepth = 8;

    usSrcXMax = pSbit->usScaledWidth;
    usSrcYMax = pSbit->usScaledHeight;

   	switch(pSbit->usRotation)
	{
	case 1:                                     /* 90 degree rotation */
        for (cb.usSrcY = 0; cb.usSrcY < usSrcYMax; cb.usSrcY++)
        {
            cb.usDstX = cb.usSrcY;                          /* x' = y */
            for (cb.usSrcX = 0; cb.usSrcX < usSrcXMax; cb.usSrcX++)
            {
                cb.usDstY = usSrcXMax - cb.usSrcX - 1;      /* y' = -x */
                CopyBit(&cb);
            }
        }
		break;
	case 2:                                     /* 180 degree rotation */
        for (cb.usSrcY = 0; cb.usSrcY < usSrcYMax; cb.usSrcY++)
        {
            cb.usDstY = usSrcYMax - cb.usSrcY - 1;          /* y' = -y */
            for (cb.usSrcX = 0; cb.usSrcX < usSrcXMax; cb.usSrcX++)
            {
                cb.usDstX = usSrcXMax - cb.usSrcX - 1;      /* x' = -x */
                CopyBit(&cb);
            }
        }
		break;
	case 3:                                     /* 270 degree rotation */
        for (cb.usSrcY = 0; cb.usSrcY < usSrcYMax; cb.usSrcY++)
        {
            cb.usDstX = usSrcYMax - cb.usSrcY - 1;          /* x' = -y */
            for (cb.usSrcX = 0; cb.usSrcX < usSrcXMax; cb.usSrcX++)
            {
                cb.usDstY = cb.usSrcX;                      /* y' = x */
                CopyBit(&cb);
            }
        }
		break;
	default:                                    /* shouldn't happen */
		return SBIT_ROTATION_ERR;
	}

    return NO_ERR;
}


/**********************************************************************/

/*      Private Functions                                             */

/**********************************************************************/

FS_PRIVATE ErrorCode GetSbitMetrics(
    sbit_State      *pSbit,
    sfac_ClientRec  *pClientInfo
)
{
    ErrorCode   ReturnCode;
	boolean		bHorMetricsFound;
	boolean		bVertMetricsFound;

    if (pSbit->bMetricsValid)
    {
        return NO_ERR;                      /* already got 'em */
    }

    ReturnCode = sfac_GetSbitMetrics (
        pClientInfo,
        pSbit->usMetricsType,
        pSbit->usMetricsTable,
        pSbit->ulMetricsOffset,
        &pSbit->usHeight,
        &pSbit->usWidth,
        &pSbit->sLSBearingX,
        &pSbit->sLSBearingY,
        &pSbit->sTopSBearingX,
        &pSbit->sTopSBearingY,
        &pSbit->usAdvanceWidth,
        &pSbit->usAdvanceHeight,
        &bHorMetricsFound,
        &bVertMetricsFound);
	
    if (ReturnCode != NO_ERR) return ReturnCode;

	if (!bHorMetricsFound)
	{
		ReturnCode = SubstituteHorMetrics (pSbit, pClientInfo);
		if (ReturnCode != NO_ERR) return ReturnCode;
	}

	if (!bVertMetricsFound)
	{
		ReturnCode = SubstituteVertMetrics (pSbit, pClientInfo);
		if (ReturnCode != NO_ERR) return ReturnCode;
	}

    {
	    int16	sDescender = pClientInfo->sDefaultDescender;
	    int16	sBoxSize = pClientInfo->sDefaultAscender - pClientInfo->sDefaultDescender;
	    ErrorCode   ReturnCode;
	    uint16	usAdvanceWidth;
	    int16	sNonScaledLSB;

	    ReturnCode = sfac_ReadGlyphHorMetrics (
		    pClientInfo,
		    pClientInfo->usGlyphIndex,
		    &usAdvanceWidth,
		    &sNonScaledLSB);
	    if (ReturnCode != NO_ERR) return ReturnCode;

	    usAdvanceWidth = UEmScaleX(pSbit, usAdvanceWidth);
        
        sBoxSize = SEmScaleX(pSbit, sBoxSize);
        sDescender = SEmScaleX(pSbit, sDescender);

        /* for glyph that are meant to be used for sideways vertical writing, we cannot trust 
           pSbit->sTopSBearingX or pSbit->usAdvanceWidth from the embedded bitmaps metrics 
           since those metrics are not used by GDI many fonts have those metrics wrong MSMincho, MSPMincho, Gulim,...*/

        /* for characters whose adwance width equal the box size, we want to have this origin shifted by the descender so that
           the baseline of non sideways glyphs will align correctely. If the advance width is different we want to adjust to keep the optical center 
           of the character aligned */
        pSbit->sTopSBearingX = pSbit->sLSBearingX +sDescender +((sBoxSize - usAdvanceWidth) /2);

    }

    ReturnCode = sfac_ShaveSbitMetrics (
	    pClientInfo,
        pSbit->usBitmapFormat,
	    pSbit->ulBitmapOffset,
        pSbit->ulBitmapLength,
		pSbit->usBitDepth,
    	&pSbit->usHeight,
    	&pSbit->usWidth,
        &pSbit->usShaveLeft,
        &pSbit->usShaveRight,
        &pSbit->usShaveTop,
        &pSbit->usShaveBottom,
    	&pSbit->sLSBearingX,
    	&pSbit->sLSBearingY,
    	&pSbit->sTopSBearingX,
    	&pSbit->sTopSBearingY);

    if (ReturnCode != NO_ERR) return ReturnCode;
        
    pSbit->bMetricsValid = TRUE;
    return NO_ERR;
}

/**********************************************************************/

FS_PRIVATE ErrorCode SubstituteVertMetrics(
    sbit_State      *pSbit,
    sfac_ClientRec  *pClientInfo 
)
{
    ErrorCode   ReturnCode;
	uint16	usNonScaledAH;
	int16	sNonScaledTSB;

	ReturnCode = sfac_ReadGlyphVertMetrics (
		pClientInfo,
		pClientInfo->usGlyphIndex,
		&usNonScaledAH,
		&sNonScaledTSB);
	if (ReturnCode != NO_ERR) return ReturnCode;

	pSbit->usAdvanceHeight = UEmScaleY(pSbit, usNonScaledAH);

	pSbit->sTopSBearingX = pSbit->sLSBearingX;
	pSbit->sTopSBearingY = - SEmScaleY(pSbit, sNonScaledTSB);

    return NO_ERR;
}

/**********************************************************************/

FS_PRIVATE ErrorCode SubstituteHorMetrics(
    sbit_State      *pSbit,
    sfac_ClientRec  *pClientInfo 
)
{
    ErrorCode   ReturnCode;
	uint16	usNonScaledAW;
	int16	sNonScaledLSB;

	ReturnCode = sfac_ReadGlyphHorMetrics (
		pClientInfo,
		pClientInfo->usGlyphIndex,
		&usNonScaledAW,
		&sNonScaledLSB);
	if (ReturnCode != NO_ERR) return ReturnCode;

	pSbit->usAdvanceWidth = UEmScaleX(pSbit, usNonScaledAW);

	pSbit->sLSBearingX = pSbit->sTopSBearingX;
	pSbit->sLSBearingY = SEmScaleY(pSbit, sNonScaledLSB);
	
    return NO_ERR;
}

FS_PRIVATE void ExpandSbitToBytePerPixel (
    uint16          usHeight,
    uint16          usWidth,
    uint16          usOriginalRowBytes,
    uint16          usExpandedRowBytes,
	uint16			usBitDepth,
    uint8           *pbySrcBitMap,
    uint8           *pbyDstBitMap )
{
	uint16          usCount;
	uint16			usBitIndex, usOriginalBitIndex;
	uint8			*pbyDstBitRow;
	uint8			*pbySrcBitRow;
	uint16			usMask, usShift, usMaxLevel;

	usMaxLevel = (0x01 << usBitDepth) -1; /* Max gray level index */

	if (usBitDepth == 2)
	{
		usMask = 0x03;
		usShift = 0x02;
		usOriginalBitIndex = ((usWidth -1) & 0x03) << 0x01;
	} else if (usBitDepth == 4)
	{
		usMask = 0x0F;
		usShift = 0x01;
		usOriginalBitIndex = ((usWidth -1) & 0x01) << 0x02;
	} else if (usBitDepth == 8)
	{
		usMask = 0xFF;
		usShift = 0x00;
		usOriginalBitIndex = 0; /* ((usWidth -1) & 0x00) << 0x03 */
	} else
	{
		return;
	}

	/* start from the end to be able to use overlapping memories */
	pbyDstBitRow = pbyDstBitMap + (long) (usHeight-1) * (long) usExpandedRowBytes;
	pbySrcBitRow = pbySrcBitMap + (long) (usHeight-1) * (long) usOriginalRowBytes;
	
	while (usHeight > 0)
	{
		pbyDstBitMap = pbyDstBitRow + (long)(usWidth -1);
		pbySrcBitMap = pbySrcBitRow + (long)((usWidth -1) >> usShift);
		usBitIndex = usOriginalBitIndex;

		*pbySrcBitMap = *pbySrcBitMap >> (MAX_BIT_INDEX - usBitDepth - usBitIndex);

		for (usCount = usWidth; usCount > 0; usCount--)
		{
			if (*pbyDstBitMap == 0)
			{
				/* 99.9% of the case */
				*pbyDstBitMap = *pbySrcBitMap & usMask;
			} else {
				*pbyDstBitMap = usMaxLevel - 
						(usMaxLevel - *pbyDstBitMap) * (usMaxLevel - *pbySrcBitMap & usMask) / usMaxLevel;
			}
			*pbySrcBitMap = *pbySrcBitMap >> usBitDepth;

			pbyDstBitMap--;
			if (usBitIndex == 0)
			{
				usBitIndex = MAX_BIT_INDEX;
				pbySrcBitMap--;
			}
			usBitIndex = usBitIndex - usBitDepth;

		}
		pbyDstBitRow -= usExpandedRowBytes;
		pbySrcBitRow -= usOriginalRowBytes;
		usHeight--;
	}
}
/**********************************************************************/

/*  This is the recursive composite routine */

FS_PRIVATE ErrorCode GetSbitComponent (
    sfac_ClientRec  *pClientInfo,
    uint32          ulStrikeOffset,
    uint16          usBitmapFormat,
    uint32          ulBitmapOffset,
    uint32          ulBitmapLength,
    uint16          usHeight,
    uint16          usWidth,
    uint16          usShaveLeft,
    uint16          usShaveRight,
    uint16          usShaveTop,
    uint16          usShaveBottom,
    uint16          usXOffset,
    uint16          usYOffset,
    uint16          usOriginalRowBytes,
    uint16          usExpandedRowBytes,
	uint16			usBitDepth,
    uint8           *pbyRead,
    uint8           *pbyExpand )
{
    uint32          ulCompMetricsOffset;            /* component params */
    uint32          ulCompBitmapOffset;
    uint32          ulCompBitmapLength;
    uint16          usComponent;                    /* index counter */
    uint16          usCompCount;
    uint16          usCompGlyphCode;
    uint16          usCompXOff;
    uint16          usCompYOff;
    uint16          usCompMetricsType;
    uint16          usCompMetricsTable;
    uint16          usCompBitmapFormat;
    uint16          usCompHeight;
    uint16          usCompWidth;
    uint16          usCompShaveLeft;
    uint16          usCompShaveRight;
    uint16          usCompShaveTop;
    uint16          usCompShaveBottom;
    uint16          usCompAdvanceWidth;
    uint16          usCompAdvanceHeight;
    int16           sCompLSBearingX;
    int16           sCompLSBearingY;
    int16           sCompTopSBearingX;
    int16           sCompTopSBearingY;
    boolean         bCompGlyphFound;
   	boolean         bCompHorMetricsFound;
   	boolean         bCompVertMetricsFound;
    ErrorCode       ReturnCode;

		ReturnCode = sfac_GetSbitBitmap (               /* fetch the bitmap */
        pClientInfo,
        usBitmapFormat,
        ulBitmapOffset,
        ulBitmapLength,
        usHeight,
        usWidth,
        usShaveLeft,
        usShaveRight,
        usShaveTop,
        usShaveBottom,
        usXOffset,
        usYOffset,
        usOriginalRowBytes,
		usBitDepth,
        pbyRead,
        &usCompCount );                             /* zero for simple glyph */
            
    if (ReturnCode != NO_ERR) return ReturnCode;
    
	/* we expand after handling composite glyphs and before scaling and applying rotation */	
	if (usBitDepth != 1 && usCompCount == 0)
		ExpandSbitToBytePerPixel (
			usHeight,
			usWidth,
			usOriginalRowBytes,
			usExpandedRowBytes,
			usBitDepth,
			pbyRead,
			pbyExpand );

    if (usCompCount > 0)                            /* if composite glyph */
    {
        for (usComponent = 0; usComponent < usCompCount; usComponent++)
        {
			if (usBitDepth != 1)
			{
				/* for grayscale, the composition is done during expansion, I need to
				   clean the memory used to read between each component */
				MEMSET(pbyRead, 0, usOriginalRowBytes*usHeight);
			}
            ReturnCode = sfac_GetSbitComponentInfo (
                pClientInfo,
                usComponent,                        /* component index */
                ulBitmapOffset,
                ulBitmapLength,
                &usCompGlyphCode,                   /* return values */
                &usCompXOff,
                &usCompYOff );
            
            if (ReturnCode != NO_ERR) return ReturnCode;

            ReturnCode = sfac_SearchForBitmap (     /* look for component glyph */
                pClientInfo,
                usCompGlyphCode,
                ulStrikeOffset,                     /* same strike for all */
                &bCompGlyphFound,                   /* return values */
                &usCompMetricsType,
                &usCompMetricsTable,
                &ulCompMetricsOffset,
                &usCompBitmapFormat,
                &ulCompBitmapOffset,
                &ulCompBitmapLength );
            
            if (ReturnCode != NO_ERR) return ReturnCode;
            
            if (bCompGlyphFound == FALSE)           /* should be there! */
            {
                return SBIT_COMPONENT_MISSING_ERR;
            }

            ReturnCode = sfac_GetSbitMetrics (      /* get component's metrics */
                pClientInfo,
                usCompMetricsType,
                usCompMetricsTable,
                ulCompMetricsOffset,
                &usCompHeight,                      /* these matter */
                &usCompWidth,
                &sCompLSBearingX,                     /* these don't */
                &sCompLSBearingY,
                &sCompTopSBearingX,                     
                &sCompTopSBearingY,
                &usCompAdvanceWidth,
                &usCompAdvanceHeight,
   				&bCompHorMetricsFound,
   				&bCompVertMetricsFound	);
            
            if (ReturnCode != NO_ERR) return ReturnCode;

            ReturnCode = sfac_ShaveSbitMetrics (    /* shave white space for const metrics */
        	    pClientInfo,
                usCompBitmapFormat,
                ulCompBitmapOffset,
                ulCompBitmapLength,
				usBitDepth,
            	&usCompHeight,
            	&usCompWidth,
                &usCompShaveLeft,
                &usCompShaveRight,
                &usCompShaveTop,
                &usCompShaveBottom,
            	&sCompLSBearingX,
            	&sCompLSBearingY,
            	&sCompTopSBearingX,
             	&sCompTopSBearingY );

            if (ReturnCode != NO_ERR) return ReturnCode;

            ReturnCode = GetSbitComponent (         /* recurse here */
                pClientInfo,
                ulStrikeOffset,
                usCompBitmapFormat,
                ulCompBitmapOffset,
                ulCompBitmapLength,
                usCompHeight,
                usCompWidth,
                usCompShaveLeft,
                usCompShaveRight,
                usCompShaveTop,
                usCompShaveBottom,
                (uint16)(usCompXOff + usXOffset + usCompShaveLeft),   /* for nesting */
                (uint16)(usCompYOff + usYOffset + usCompShaveTop),
                usOriginalRowBytes,                         /* same for all */
                usExpandedRowBytes,                         /* same for all */
				usBitDepth,
                pbyRead,
				pbyExpand);
            
            if (ReturnCode != NO_ERR) return ReturnCode;
        }
    }
    return NO_ERR;
}

/********************************************************************/

/*                  Bitmap Scaling Routines                         */

/********************************************************************/

FS_PRIVATE uint16 UScaleX(
    sbit_State  *pSbit,
    uint16      usValue
)
{
    uint32      ulValue;

    if (pSbit->usTableState == SBIT_BSCA_FOUND)     /* if scaling needed */
    {
        ulValue = (uint32)usValue;
        ulValue *= (uint32)pSbit->usPpemX << 1; 
        ulValue += (uint32)pSbit->usSubPpemX;       /* for rounding */
        ulValue /= (uint32)pSbit->usSubPpemX << 1;
        usValue = (uint16)ulValue;
    }
	if (pSbit->uBoldSimulHorShift != 0)
	{
        if (usValue != 0) /* we don't increase the width of a zero width glyph, problem with indic script */
		    usValue += 1; /* we increase the width by one pixel regardless of size for backwards compatibility */
	}
    return usValue;
}

/********************************************************************/

FS_PRIVATE uint16 UScaleY(
    sbit_State  *pSbit,
    uint16      usValue
)
{
    uint32      ulValue;

    if (pSbit->usTableState == SBIT_BSCA_FOUND)     /* if scaling needed */
    {
        ulValue = (uint32)usValue;
        ulValue *= (uint32)pSbit->usPpemY << 1; 
        ulValue += (uint32)pSbit->usSubPpemY;       /* for rounding */
        ulValue /= (uint32)pSbit->usSubPpemY << 1;
        usValue = (uint16)ulValue;
    }
    return usValue;
}

/********************************************************************/

FS_PRIVATE int16 SScaleX(
    sbit_State  *pSbit,
    int16       sValue
)
{
    if (pSbit->usTableState == SBIT_BSCA_FOUND)
    {
        if (sValue >= 0)                    /* positive Value */
        {
            return (int16)UScaleX(pSbit, (uint16)sValue);
        }
        else                                /* negative Value */
        {
            return -(int16)(UScaleX(pSbit, (uint16)(-sValue)));
        }
    }
    else                                    /* no scaling needed */
    {
        return sValue;
    }
}

/********************************************************************/

FS_PRIVATE int16 SScaleY(
    sbit_State  *pSbit,
    int16       sValue
)
{
    if (pSbit->usTableState == SBIT_BSCA_FOUND)
    {
        if (sValue >= 0)                    /* positive Value */
        {
            return (int16)UScaleY(pSbit, (uint16)sValue);
        }
        else                                /* negative Value */
        {
            return -(int16)(UScaleY(pSbit, (uint16)(-sValue)));
        }
    }
    else                                    /* no scaling needed */
    {
        return sValue;
    }
}


FS_PRIVATE uint16 UEmScaleX(
    sbit_State  *pSbit,
    uint16      usValue
)
{
    uint32      ulValue;
	uint16		usPpemX;

    if (pSbit->usTableState == SBIT_BSCA_FOUND)     /* if scaling needed */
    {
		usPpemX = pSbit->usSubPpemX;
    } else {
		usPpemX = pSbit->usPpemX;
	}
    ulValue = (uint32)usValue;
    ulValue *= (uint32)usPpemX << 1; 
    ulValue += (uint32)pSbit->usEmResolution;       /* for rounding */
    ulValue /= (uint32)pSbit->usEmResolution << 1;
    usValue = (uint16)ulValue;
	if (pSbit->uBoldSimulHorShift != 0)
	{
        if (usValue != 0) /* we don't increase the width of a zero width glyph, problem with indic script */
		    usValue += 1; /* we increase the width by one pixel regardless of size for backwards compatibility */
	}
    return usValue;
}

/********************************************************************/

FS_PRIVATE uint16 UEmScaleY(
    sbit_State  *pSbit,
    uint16      usValue
)
{
    uint32      ulValue;
	uint16		usPpemY;

    if (pSbit->usTableState == SBIT_BSCA_FOUND)     /* if scaling needed */
    {
		usPpemY = pSbit->usSubPpemY;
    } else {
		usPpemY = pSbit->usPpemY;
	}
    ulValue = (uint32)usValue;
    ulValue *= (uint32)usPpemY << 1; 
    ulValue += (uint32)pSbit->usEmResolution;       /* for rounding */
    ulValue /= (uint32)pSbit->usEmResolution << 1;
    usValue = (uint16)ulValue;
    return usValue;
}

/********************************************************************/

FS_PRIVATE int16 SEmScaleX(
    sbit_State  *pSbit,
    int16       sValue
)
{
     if (sValue >= 0)                    /* positive Value */
     {
         return (int16)UEmScaleX(pSbit, (uint16)sValue);
     }
     else                                /* negative Value */
     {
         return -(int16)(UEmScaleX(pSbit, (uint16)(-sValue)));
     }
}

/********************************************************************/

FS_PRIVATE int16 SEmScaleY(
    sbit_State  *pSbit,
    int16       sValue
)
{
     if (sValue >= 0)                    /* positive Value */
     {
         return (int16)UEmScaleY(pSbit, (uint16)sValue);
     }
     else                                /* negative Value */
     {
         return -(int16)(UEmScaleY(pSbit, (uint16)(-sValue)));
     }
}

/********************************************************************/

FS_PRIVATE void ScaleVertical (
    uint8 *pbyBitmap,
    uint16 usBytesPerRow,
    uint16 usOrgHeight,
    uint16 usNewHeight
)
{
    uint8 *pbyOrgRow;                   /* original data pointer */
    uint8 *pbyNewRow;                   /* new data pointer */
    uint16 usErrorTerm;                 /* for 'Bresenham' calculation */
    uint16 usLine;                      /* loop counter */

    usErrorTerm = usOrgHeight >> 1;                 /* used by both comp and exp */

    if (usOrgHeight > usNewHeight)                  /* Compress Vertical */
    {
        pbyOrgRow = pbyBitmap;
        pbyNewRow = pbyBitmap;

        for (usLine = 0; usLine < usNewHeight; usLine++)
        {
            while (usErrorTerm >= usNewHeight)
            {
                pbyOrgRow += usBytesPerRow;         /* skip a row */
                usErrorTerm -= usNewHeight;
            }
            if (pbyOrgRow != pbyNewRow)
            {
                MEMCPY(pbyNewRow, pbyOrgRow, usBytesPerRow);
            }
            pbyNewRow += usBytesPerRow;
            usErrorTerm += usOrgHeight;
        }
        for (usLine = usNewHeight; usLine < usOrgHeight; usLine++)
        {
            MEMSET(pbyNewRow, 0, usBytesPerRow);    /* erase the leftover */
            pbyNewRow += usBytesPerRow;
        }
    }
    else if (usNewHeight > usOrgHeight)             /* Expand Vertical */
    {
        pbyOrgRow = pbyBitmap + (usOrgHeight - 1) * usBytesPerRow;
        pbyNewRow = pbyBitmap + (usNewHeight - 1) * usBytesPerRow;

        for (usLine = 0; usLine < usOrgHeight; usLine++)
        {
            usErrorTerm += usNewHeight;
            
            while (usErrorTerm >= usOrgHeight)      /* executes at least once */
            {
                if (pbyOrgRow != pbyNewRow)
                {
                    MEMCPY(pbyNewRow, pbyOrgRow, usBytesPerRow);
                }
                pbyNewRow -= usBytesPerRow;
                usErrorTerm -= usOrgHeight;
            }
            pbyOrgRow -= usBytesPerRow;
        }
    }
}

/********************************************************************/

FS_PRIVATE void ScaleHorizontal (
    uint8 *pbyBitmap,
    uint16 usOrgBytesPerRow,
    uint16 usNewBytesPerRow,
	uint16 usBitDepth,
    uint16 usOrgWidth,
    uint16 usNewWidth,
    uint16 usRowCount
)
{
    uint8 *pbyOrgRow;               /* points to original row beginning */
    uint8 *pbyNewRow;               /* points to new row beginning */
    uint8 *pbyOrg;                  /* original data pointer */
    uint8 *pbyNew;                  /* new data pointer */
    uint8 byOrgData;                /* original data read 1 byte at a time */
    uint8 byNewData;                /* new data assembled bit by bit */

    uint16 usErrorTerm;             /* for 'Bresenham' calculation */
    uint16 usByte;                  /* to byte counter */
    uint16 usOrgBytes;              /* from width rounded up in bytes */
    uint16 usNewBytes;              /* to width rounded up in bytes */
    
    int16 sOrgBits;                 /* counts valid bits of from data */
    int16 sNewBits;                 /* counts valid bits of to data */
    int16 sOrgBitsInit;             /* valid original bits at row begin */
    int16 sNewBitsInit;             /* valid new bits at row begin */

    
	if (usBitDepth == 1)
	{
		if (usOrgWidth > usNewWidth)                    /* Compress Horizontal */
		{
			pbyOrgRow = pbyBitmap;
			pbyNewRow = pbyBitmap;
			usNewBytes = (usNewWidth + 7) >> 3;

			while (usRowCount > 0)
			{
				pbyOrg = pbyOrgRow;
				pbyNew = pbyNewRow;
				usErrorTerm = usOrgWidth >> 1;
            
				sOrgBits = 0;                           /* start at left edge */
				sNewBits = 0;
				usByte = 0;
				byNewData = 0;
				while (usByte < usNewBytes)
				{
					while (usErrorTerm >= usNewWidth)
					{
						sOrgBits--;                     /* skip a bit */
						usErrorTerm -= usNewWidth;
					}
					while (sOrgBits <= 0)               /* if out of data */
					{
						byOrgData = *pbyOrg++;          /*   then get some fresh */
						sOrgBits += 8;
					}
					byNewData <<= 1;                    /* new bit to lsb */
					byNewData |= (byOrgData >> (sOrgBits - 1)) & 1;
                
					sNewBits++;
					if (sNewBits == 8)                  /* if to data byte is full */
					{
						*pbyNew++ = byNewData;          /*   then write it out */
						sNewBits = 0;
						usByte++;                       /* loop counter */
					}
					usErrorTerm += usOrgWidth;
				}
				while (usByte < usNewBytesPerRow)
				{
					*pbyNew++ = 0;                      /* blank out the rest */
					usByte++;
				}
				pbyOrgRow += usOrgBytesPerRow;
				pbyNewRow += usNewBytesPerRow;
				usRowCount--;
			}
		}
		else if (usNewWidth > usOrgWidth)               /* Expand Horizontal */
		{
			pbyOrgRow = pbyBitmap + (usRowCount - 1) * usOrgBytesPerRow;
			pbyNewRow = pbyBitmap + (usRowCount - 1) * usNewBytesPerRow;

			usOrgBytes = (usOrgWidth + 7) >> 3;
			sOrgBitsInit = (int16)((usOrgWidth + 7) & 0x07) - 7;
        
			usNewBytes = (usNewWidth + 7) >> 3;
			sNewBitsInit = 7 - (int16)((usNewWidth + 7) & 0x07);

			while (usRowCount > 0)                      /* for each row */
			{
				pbyOrg = pbyOrgRow + usOrgBytes - 1;    /* point to right edges */
				pbyNew = pbyNewRow + usNewBytes - 1;
				usErrorTerm = usOrgWidth >> 1;
            
				sOrgBits = sOrgBitsInit;                /* initially unaligned */
				sNewBits = sNewBitsInit;
				usByte = 0;
				byNewData = 0;
				while (usByte < usNewBytes)             /* for each output byte */
				{
					if (sOrgBits <= 0)                  /* if out of data */
					{
						byOrgData = *pbyOrg--;          /*   then get some fresh */
						sOrgBits += 8;
					}
					usErrorTerm += usNewWidth;
                
					while (usErrorTerm >= usOrgWidth)   /* executes at least once */
					{
						byNewData >>= 1;                /* use the msb of byte */
						byNewData |= (byOrgData << (sOrgBits - 1)) & 0x80;
                    
						sNewBits++;
						if (sNewBits == 8)              /* if to data byte is full */
						{
							*pbyNew-- = byNewData;      /*   then write it out */
							sNewBits = 0;
							usByte++;                   /* loop counter */
						}
						usErrorTerm -= usOrgWidth;
					}
					sOrgBits--;                         /* get next bit */
				}
				pbyOrgRow -= usOrgBytesPerRow;
				pbyNewRow -= usNewBytesPerRow;
				usRowCount--;
			}
        }
    } else {											/* one byte per pixel */
		if (usOrgWidth > usNewWidth)                    /* Compress Horizontal */
		{
			pbyOrgRow = pbyBitmap;
			pbyNewRow = pbyBitmap;

			while (usRowCount > 0)
			{
				pbyOrg = pbyOrgRow;
				pbyNew = pbyNewRow;
				usErrorTerm = usOrgWidth >> 1;
            
				usByte = 0;
				while (usByte < usNewWidth)
				{
					while (usErrorTerm >= usNewWidth)
					{
						pbyOrg++;                     /* skip a byte */
						usErrorTerm -= usNewWidth;
					}
					*pbyNew++ = *pbyOrg;
					usByte++;                       /* loop counter */
					usErrorTerm += usOrgWidth;
				}
				while (usByte < usNewBytesPerRow)
				{
					*pbyNew++ = 0;                      /* blank out the rest */
					usByte++;
				}
				pbyOrgRow += usOrgBytesPerRow;
				pbyNewRow += usNewBytesPerRow;
				usRowCount--;
			}
		}
		else if (usNewWidth > usOrgWidth)               /* Expand Horizontal */
		{
			pbyOrgRow = pbyBitmap + (usRowCount - 1) * usOrgBytesPerRow;
			pbyNewRow = pbyBitmap + (usRowCount - 1) * usNewBytesPerRow;

			usOrgBytes = usOrgWidth;        
			usNewBytes = usNewWidth ;

			while (usRowCount > 0)                      /* for each row */
			{
				pbyOrg = pbyOrgRow + usOrgBytes - 1;    /* point to right edges */
				pbyNew = pbyNewRow + usNewBytesPerRow - 1;
				usErrorTerm = usOrgWidth >> 1;
            
				usByte = usNewBytesPerRow;
				while (usByte > usNewBytes)
				{
					*pbyNew-- = 0;                      /* blank out the extra bytes on the right */
					usByte--;
				}
				while (usByte > 0)             /* for each output byte */
				{
					usErrorTerm += usNewWidth;
                
					while (usErrorTerm >= usOrgWidth)   /* executes at least once */
					{
						*pbyNew-- = *pbyOrg;

						usByte--;                   /* loop counter */
						usErrorTerm -= usOrgWidth;
					}
					pbyOrg--;
				}
				pbyOrgRow -= usOrgBytesPerRow;
				pbyNewRow -= usNewBytesPerRow;
				usRowCount--;
			}
        }
	}
}

/********************************************************************/

FS_PRIVATE void CopyBit(
    CopyBlock* pcb )
{
    uint16  usSrcOffset;
    uint16  usSrcShift;
    uint16  usDstOffset;
    uint16  usDstShift;
    
    static  uint16 usByteMask[8] = 
        { 0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01 };

/*  if speed becomes an issue, this next multiply could be moved up */
/*  to the calling routine, and placed outside the 'x' loop */

/*  if speed becomes an issue, the test between 1 bit and 1 byte per pixel */
/*  could be moved up to the calling routine */

	if (pcb->usBitDepth == 1)
	{
		usSrcOffset = (pcb->usSrcY * pcb->usSrcBytesPerRow) + (pcb->usSrcX >> 3);
		usSrcShift = pcb->usSrcX & 0x0007;

		if (pcb->pbySrc[usSrcOffset] & usByteMask[usSrcShift])
		{
			usDstOffset = (pcb->usDstY * pcb->usDstBytesPerRow) + (pcb->usDstX >> 3);
			usDstShift = pcb->usDstX & 0x0007;
			pcb->pbyDst[usDstOffset] |= usByteMask[usDstShift];
		}
	} else {
		usSrcOffset = (pcb->usSrcY * pcb->usSrcBytesPerRow) + pcb->usSrcX;
		usDstOffset = (pcb->usDstY * pcb->usDstBytesPerRow) + pcb->usDstX;
		pcb->pbyDst[usDstOffset] = pcb->pbySrc[usSrcOffset];
	}

}

/********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\fondrv\tt\scaler\interp.h ===
/*
	 File:		 interp.h

	 Contains:	 Exports and constants used by TrueType Interpreter

	 Written by: GregH

    Copyright:  (c) 1987-1990, 1992 by Apple Computer, Inc., all rights reserved.
                (c) 1989-1997. Microsoft Corporation, all rights reserved.

    Change History (most recent first):
*/

#include 	"fnterr.h"

#define NOGRIDFITFLAG   1
#define DEFAULTFLAG     2
#define TUNED4SPFLAG	4

FS_PUBLIC ErrorCode itrp_SetDefaults (
    void *  pvGlobalGS,
    Fixed   fxPixelDiameter);

FS_PUBLIC void  itrp_UpdateGlobalGS(
    void *              pvGlobalGS, /* GlobalGS                             */
    void *              pvCVT,      /* Pointer to control value table       */
    void *              pvStore,    /* Pointer to storage                   */
    void *              pvFuncDef,  /* Pointer to function defintions       */
    void *              pvInstrDef, /* Pointer to instruction definitions   */
    void *              pvStack,    /* Pointer to the stack                 */
	 LocalMaxProfile *	maxp,
    uint16              cvtCount,
    uint32              ulLengthFontProgram, /* Length of font program      */
    void *              pvFontProgram, /* Pointer to font program           */
    uint32              ulLengthPreProgram, /* Length of pre program        */
    void *              pvPreProgram, /* Pointer to pre program             */
	ClientIDType        clientID);    /* User ID Number                     */

#ifdef FSCFG_NO_INITIALIZED_DATA
FS_PUBLIC void itrp_InitializeData (void);
#endif

FS_PUBLIC ErrorCode   itrp_ExecuteFontPgm(
    fnt_ElementType *   pTwilightElement,
    fnt_ElementType *   pGlyphElement,
    void *              pvGlobalGS,
	 FntTraceFunc			TraceFunc);

FS_PUBLIC ErrorCode   itrp_ExecutePrePgm(
    fnt_ElementType *   pTwilightElement,
    fnt_ElementType *   pGlyphElement,
    void *              pvGlobalGS,
	 FntTraceFunc			TraceFunc);

FS_PUBLIC ErrorCode   itrp_ExecuteGlyphPgm(
    fnt_ElementType *   pTwilightElement,
    fnt_ElementType *   pGlyphElement,
    uint8 *             ptr,
    uint8 *             eptr,
    void *              pvGlobalGS,
	 FntTraceFunc			TraceFunc,
    uint16 *            pusScanType,
    uint16 *            pusScanControl,
    boolean *           pbChangeScanControl);

FS_PUBLIC boolean itrp_bApplyHints(
    void *      pvGlobalGS);

FS_PUBLIC void  itrp_QueryScanInfo(
    void *      pvGlobalGS,
    uint16 *    pusScanType,
    uint16 *    pusScanControl);

FS_PUBLIC void	itrp_SetCompositeFlag(
	void *      pvGlobalGS,
	uint8		bCompositeFlag);

FS_PUBLIC void	itrp_SetSameTransformFlag(
	void *      pvGlobalGS,
	boolean		bSameTransformAsMaster);

FS_PUBLIC void itrp_Normalize (F26Dot6 x, F26Dot6 y, VECTOR *pVec);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\fondrv\tt\scaler\sbit.h ===
/*********************************************************************

      sbit.h -- Embedded Bitmap Module Export Definitions

      (c) Copyright 1993-1996  Microsoft Corp.  All rights reserved.

      01/12/96  claudebe    Vertical metrics support
      02/07/95  deanb       Workspace pointers for GetMetrics & GetBitmap
      01/27/95  deanb       usShaveLeft & usShaveRight added to sbit state
      01/05/94  deanb       Bitmap scaling state
      11/29/93  deanb       First cut 
 
**********************************************************************/

/*      SBIT Module State Definition    */

typedef struct
{
    uint32  ulStrikeOffset;         /* into bloc or bsca */
    uint32  ulMetricsOffset;        /* may be either table */
    uint32  ulBitmapOffset;         /* into bdat table */
    uint32  ulBitmapLength;         /* bytes of bdat data */
    uint32  ulOutMemSize;           /* bytes of bitmap output data */
    uint32  ulWorkMemSize;          /* bytes of pre-scaled,rotated bitmap data */
    uint32  ulReadMemSize;          /* bytes of extra memory, to read gray sbit under scaling or rotation */
    uint16  usTableState;           /* unsearched, bloc, bsca, or not found */
    uint16  usPpemX;                /* x pixels per Em */
    uint16  usPpemY;                /* y pixels per Em */
    uint16  usSubPpemX;             /* substitute x ppem for bitmap scaling */
    uint16  usSubPpemY;             /* substitute y ppem for bitmap scaling */
	uint16	usRotation;				/* 0=none; 1=90; 2=180; 3=270; 4=other */
    uint16  usMetricsType;          /* horiz, vert, or big */
    uint16  usMetricsTable;         /* bloc or bdat */
    uint16  usBitmapFormat;         /* bdat definitions */
    uint16  usHeight;               /* bitmap rows */
    uint16  usWidth;                /* bitmap columns */
    uint16  usAdvanceWidth;         /* advance width */
    uint16  usAdvanceHeight;        /* advance height */     /* NEW */
    uint16  usOriginalRowBytes;     /* bytes per row (padded long) */
    uint16  usExpandedRowBytes;     /* bytes per row after grayscale expansion (padded long) */
    uint16  usScaledHeight;         /* scaled bitmap rows */
    uint16  usScaledWidth;          /* scaled bitmap columns */
    uint16  usScaledRowBytes;       /* scaled bytes per row (padded long) */
    uint16  usOutRowBytes;          /* reported bytes per row (for rotation) */
    uint16  usShaveLeft;            /* white pixels on left of bbox in format 5 */
    uint16  usShaveRight;           /* white pixels on right of bbox in format 5 */
    uint16  usShaveTop;             /* white pixels on top of bbox in format 5 */   /* NEW */
    uint16  usShaveBottom;          /* white pixels on bottom of bbox in format 5 */  /* NEW */
	int16   sLSBearingX;            /* left side bearing */
	int16   sLSBearingY;            /* y coord of top left corner */ 
	int16   sTopSBearingX;          /* top side bearing X */ /* NEW */
	int16   sTopSBearingY;          /* top side bearing Y */ /* NEW */
    boolean bGlyphFound;            /* TRUE if glyph found in strike */
    boolean bMetricsValid;          /* TRUE when metrics have been read */
	uint16  usEmResolution;			/* needed when substituting missing metrics */ /* NEW */
	uint16	usBitDepth;				/* 1 for B/W bitmap, 2, 4 or 8 for gray sbit */
	uint16	uBoldSimulHorShift;
	uint16	uBoldSimulVertShift;
} 
sbit_State;

/**********************************************************************/

/*      SBIT Export Prototypes      */

FS_PUBLIC ErrorCode sbit_NewTransform(
    sbit_State  *pSbit,
    uint16		usEmResolution,
    int16 	sBoldSimulHorShift,
    int16 	sBoldSimulVertShift,
    uint16          usPpemX,
    uint16          usPpemY,
    uint16          usRotation             /* 0 - 3 => 90 deg rotation, else not 90 */
);

FS_PUBLIC ErrorCode sbit_SearchForBitmap(
    sbit_State      *pSbit,
    sfac_ClientRec  *pClientInfo,
	uint16			usGlyphCode,
	uint16          usOverScale,            /* outline magnification requested */
	uint16			*pusBitDepth,			/* 1 for B/W bitmap, 2, 4 or 8 for gray sbit */
    uint16          *pusFoundCode           /* 0 = not found, 1 = bloc, 2 = bsca */
);

FS_PUBLIC ErrorCode sbit_GetDevAdvanceWidth (
    sbit_State      *pSbit,
    sfac_ClientRec  *pClientInfo,
    point           *pf26DevAdvW 
);

#ifdef FSCFG_SUBPIXEL
FS_PUBLIC ErrorCode  sbit_CalcDevHorMetrics(
    sbit_State      *pSbit,
    sfac_ClientRec  *pClientInfo,
	F26Dot6 *       pDevAdvanceWidthX,
	F26Dot6 *       pDevLeftSideBearingX,
	F26Dot6 *       pDevRightSideBearingX);
#endif // FSCFG_SUBPIXEL

FS_PUBLIC ErrorCode sbit_GetDevAdvanceHeight (	/* NEW */
    sbit_State      *pSbit,
    sfac_ClientRec  *pClientInfo,
    point           *pf26DevAdvH 
);

FS_PUBLIC ErrorCode sbit_GetMetrics (
    sbit_State      *pSbit,
    sfac_ClientRec  *pClientInfo,
    point           *pf26DevAdvanceWidth,
    point           *pf26DevLeftSideBearing,
    point           *pf26LSB,
    point           *pf26DevAdvanceHeight, 	/* NEW */
    point           *pf26DevTopSideBearing,	/* NEW */
    point           *pf26TopSB,	/* NEW */
    Rect            *pRect,
    uint16          *pusRowBytes,
    uint32          *pulOutSize,
    uint32          *pulWorkSize
);

FS_PUBLIC ErrorCode sbit_GetBitmap (
    sbit_State      *pSbit,
    sfac_ClientRec  *pClientInfo,
    uint8           *pbyOut,
    uint8           *pbyWork
);


/**********************************************************************/

FS_PUBLIC void sbit_Embolden(uint8 *pbyBitmap, uint16 usBitmapWidth, uint16 usBitmapHeight, uint16 usRowBytes, int16 sBoldSimulHorShift, int16 sBoldSimulVertShift);

FS_PUBLIC void sbit_EmboldenGray(uint8 *pbyBitmap, uint16 usBitmapWidth, uint16 usBitmapHeight, uint16 usRowBytes, uint16 usGrayLevels, int16 sBoldSimulHorShift, int16 sBoldSimulVertShift);

#ifdef FSCFG_SUBPIXEL
FS_PUBLIC void sbit_EmboldenSubPixel(uint8 *pbyBitmap, uint16 usBitmapWidth, uint16 usBitmapHeight, uint16 usRowBytes, int16 suBoldSimulHorShift, int16 sBoldSimulVertShift);
#endif // FSCFG_SUBPIXEL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\fondrv\tt\scaler\fsglue.h ===
/*
	File:       fsglue.h

	Contains:   xxx put contents here (or delete the whole line) xxx

	Written by: xxx put name of writer here (or delete the whole line) xxx

	Copyright:  (c) 1987-1990, 1992 by Apple Computer, Inc., all rights reserved.
				(c) 1989-1996. Microsoft Corporation, all rights reserved.

	Change History (most recent first):

	      <>    12/15/95    CB      add fsg_UpdateAdvanceHeight
	   <11+>     7/17/90    MR      Change error return type to int
		<11>     7/13/90    MR      Declared function pointer prototypes, Debug fields for runtime
									range checking
		 <8>     6/21/90    MR      Add field for ReleaseSfntFrag
		 <7>      6/5/90    MR      remove vectorMappingF
		 <6>      6/4/90    MR      Remove MVT
		 <5>      6/1/90    MR      Thus endeth the too-brief life of the MVT...
		 <4>      5/3/90    RB      adding support for new scan converter and decryption.
		 <3>     3/20/90    CL      Added function pointer for vector mapping
									Removed devRes field
									Added fpem field
		 <2>     2/27/90    CL      Change: The scaler handles both the old and new format
									simultaneously! It reconfigures itself during runtime !  Changed
									transformed width calculation.  Fixed transformed component bug.
	   <3.1>    11/14/89    CEL     Left Side Bearing should work right for any transformation. The
									phantom points are in, even for components in a composite glyph.
									They should also work for transformations. Device metric are
									passed out in the output data structure. This should also work
									with transformations. Another leftsidebearing along the advance
									width vector is also passed out. whatever the metrics are for
									the component at it's level. Instructions are legal in
									components. Now it is legal to pass in zero as the address of
									memory when a piece of the sfnt is requested by the scaler. If
									this happens the scaler will simply exit with an error code !
	   <3.0>     8/28/89    sjk     Cleanup and one transformation bugfix
	   <2.2>     8/14/89    sjk     1 point contours now OK
	   <2.1>      8/8/89    sjk     Improved encryption handling
	   <2.0>      8/2/89    sjk     Just fixed EASE comment
	   <1.5>      8/1/89    sjk     Added composites and encryption. Plus some enhancements.
	   <1.4>     6/13/89    SJK     Comment
	   <1.3>      6/2/89    CEL     16.16 scaling of metrics, minimum recommended ppem, point size 0
									bug, correct transformed integralized ppem behavior, pretty much
									so
	   <1.2>     5/26/89    CEL     EASE messed up on "c" comments
	  <,1.1>  5/26/89    CEL     Integrated the new Font Scaler 1.0 into Spline Fonts
	   <1.0>     5/25/89    CEL     Integrated 1.0 Font scaler into Bass code for the first time.

	To Do:
*/
/*      <3+>     3/20/90    mrr     Added flag executeFontPgm, set in fs_NewSFNT
*/


/*** Offset table ***/

typedef struct {
	uint32 x;
	uint32 y;
	uint32 ox;
	uint32 oy;
	uint32 oox;
	uint32 ooy;
	uint32 onCurve;
	uint32 sp;
	uint32 ep;
	uint32 f;
	uint32 fc;        
#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	uint32 pcr;
#endif
} fsg_OutlineFieldInfo;

typedef struct fsg_WorkSpaceAddr{
	 F26Dot6 *              pStack;                     /* Address of stack                  */
	 void *                 pGlyphOutlineBase;      /* Address of Glyph Outline Base     */
	 fnt_ElementType *  pGlyphElement;          /* Address of Glyph Element array    */
	 boolean *              pGlyphDataByteSet;      /* Address of ByteSet array          */
	 void *                 pvGlyphData;                /* Address of GlyphData array        */
	 void *                 pReusableMemoryMarker;  /* Address of reusable memory        */
} fsg_WorkSpaceAddr;

typedef struct fsg_WorkSpaceOffsets {
	uint32                  ulStackOffset;
	uint32                  ulGlyphOutlineOffset;
	uint32                  ulGlyphElementOffset;
	uint32                  ulGlyphDataByteSetOffset;
	uint32                  ulGlyphDataOffset;
	fsg_OutlineFieldInfo    GlyphOutlineFieldOffsets;
	 uint32                      ulReusableMemoryOffset;
	uint32                  ulMemoryBase6Offset;
	uint32                  ulMemoryBase7Offset;
	 uint32                      ulMemoryBase6Size;
	 uint32                      ulMemoryBase7Size;
} fsg_WorkSpaceOffsets;

typedef struct fsg_PrivateSpaceOffsets {
	 uint32                      offset_storage;
	 uint32                      offset_functions;
	 uint32                      offset_instrDefs;       /* <4> */
	 uint32                      offset_controlValues;
	 uint32                      offset_globalGS;
	 uint32                      offset_FontProgram;
	 uint32                      offset_PreProgram;
	 uint32                      offset_TwilightZone;
	 uint32                      offset_TwilightOutline;
	fsg_OutlineFieldInfo    TwilightOutlineFieldOffsets;
#ifdef FSCFG_SUBPIXEL
	 uint32                      offset_storageSubPixel;
	 uint32                      offset_functionsSubPixel;
	 uint32                      offset_instrDefsSubPixel;       /* <4> */
	 uint32                      offset_controlValuesSubPixel;
	 uint32                      offset_globalGSSubPixel;
	 uint32                      offset_TwilightZoneSubPixel;
	 uint32                      offset_TwilightOutlineSubPixel;
#endif // FSCFG_SUBPIXEL
} fsg_PrivateSpaceOffsets;

typedef struct fsg_TransformRec {
	uint16              usEmResolution;     /* used to be int32 <4> */
	transMatrix         currentTMatrix;     /* Current Transform Matrix */
	boolean             bPhaseShift;        /* 45 degrees flag <4> */
	boolean             bPositiveSquare;    /* Transform is a positive square */
	boolean             bIntegerScaling;    /* Font uses integer scaling */
	Fixed               fxPixelDiameter;
	uint32              ulImageState;       /* is glyph rotated, stretched, etc. */
	boolean				bEmboldSimulation; 
	uint16	uBoldSimulHorShift;
} fsg_TransformRec;

/**********************/
/** MODULE INTERFACE **/
/**********************/

/*      Memory Management Routines  */

FS_PUBLIC uint32  fsg_PrivateFontSpaceSize (
	sfac_ClientRec *            ClientInfo,
	 LocalMaxProfile *            pMaxProfile,    /* Max Profile Table    */
	fsg_PrivateSpaceOffsets *   PrivateSpaceOffsets);

FS_PUBLIC uint32    fsg_WorkSpaceSetOffsets (
	 LocalMaxProfile *       pMaxProfile,    /* Max Profile Table    */
	 fsg_WorkSpaceOffsets *  WorkSpaceOffsets,
	int32 *                 plExtraWorkSpace);

FS_PUBLIC void  fsg_UpdatePrivateSpaceAddresses(
	sfac_ClientRec *        ClientInfo,      /* Cached sfnt information */
	 LocalMaxProfile *       pMaxProfile,    /* Max Profile Table         */
	char *                  pPrivateFontSpace,
	fsg_PrivateSpaceOffsets * PrivateSpaceOffsets,
	void *                  pvStack,        /* pointer to stack         */
	void **                 pvFontProgram,  /* pointer to font program  */
	void **                 pvPreProgram);  /* pointer to pre program   */

FS_PUBLIC void  fsg_UpdateWorkSpaceAddresses(
	char *                  pWorkSpace,
	 fsg_WorkSpaceOffsets *  WorkSpaceOffsets,
	 fsg_WorkSpaceAddr *     pWorkSpaceAddr);

FS_PUBLIC void  fsg_UpdateWorkSpaceElement(
	 fsg_WorkSpaceOffsets *  WorkSpaceOffsets,
	 fsg_WorkSpaceAddr *     pWorkSpaceAddr);

FS_PUBLIC void *    fsg_QueryGlobalGS(
	char *                  pPrivateFontSpace,
	fsg_PrivateSpaceOffsets * PrivateSpaceOffsets);

#ifdef FSCFG_SUBPIXEL
FS_PUBLIC void *    fsg_QueryGlobalGSSubPixel(
	char *                  pPrivateFontSpace,
	fsg_PrivateSpaceOffsets * PrivateSpaceOffsets);
#endif // FSCFG_SUBPIXEL

FS_PUBLIC void *      fsg_QueryTwilightElement(
	char *                  pPrivateFontSpace,
	 fsg_PrivateSpaceOffsets * PrivateSpaceOffsets);

#ifdef FSCFG_SUBPIXEL
FS_PUBLIC void *      fsg_QueryTwilightElementSubPixel(
	char *                  pPrivateFontSpace,
	 fsg_PrivateSpaceOffsets * PrivateSpaceOffsets);
#endif // FSCFG_SUBPIXEL

FS_PUBLIC void *      fsg_QueryStack(fsg_WorkSpaceAddr * pWorkSpaceAddr);

FS_PUBLIC void *      fsg_QueryReusableMemory(
	char *                  pWorkSpace,
	 fsg_WorkSpaceOffsets *  WorkSpaceOffsets);

FS_PUBLIC void fsg_CheckWorkSpaceForFit(
	fsg_WorkSpaceOffsets *  WorkSpaceOffsets,
	int32                   lExtraWorkSpace,
	int32                   lMGWorkSpace,
	int32 *                 plSizeBitmap1,
	int32 *                 plSizeBitmap2);

FS_PUBLIC void  fsg_GetRealBitmapSizes(
	fsg_WorkSpaceOffsets *  WorkSpaceOffsets,
	int32 *                 plSizeBitmap1,
	 int32 *                     plSizeBitmap2);

FS_PUBLIC void  fsg_SetUpWorkSpaceBitmapMemory(
	 char *                      pWorkSpace,
	fsg_WorkSpaceOffsets *  WorkSpaceOffsets,
	char *                  pClientBitmapPtr2,
	char *                  pClientBitmapPtr3,
	char **                 ppMemoryBase6,
	char **                 ppMemoryBase7);

FS_PUBLIC void  fsg_GetWorkSpaceExtra(
	 char *                      pWorkSpace,
	fsg_WorkSpaceOffsets *  WorkSpaceOffsets,
	char **                 ppWorkSpaceExtra);

FS_PUBLIC void  fsg_QueryPPEM(
	void *      pvGlobalGS,
	uint16 *    pusPPEM);

FS_PUBLIC void  fsg_QueryPPEMXY(
	void *              pvGlobalGS,
	fsg_TransformRec *  TransformInfo,
	uint16 *            pusPPEMX,
	uint16 *            pusPPEMY,
	uint16 *            pusRotation);


/*      FSGlue Access Routines  */

FS_PUBLIC void  fsg_GetContourData(
	fsg_WorkSpaceAddr * pWorkSpaceAddr,
#ifdef FSCFG_SUBPIXEL
	boolean				bSubPixel,            
#endif // FSCFG_SUBPIXEL
	F26Dot6 **          pX,
	F26Dot6 **          pY,
	int16 **            pSp,
	int16 **            pEp,
	uint8 **            pOnCurve,
	uint8 **			pFc,
	uint16 *            pNc);

FS_PUBLIC uint32      fsg_GetContourDataSize(
	 fsg_WorkSpaceAddr * pWorkSpaceAddr);

FS_PUBLIC void  fsg_DumpContourData(
	 fsg_WorkSpaceAddr * pWorkSpaceAddr,
	 uint8 **               pbyOutline);

FS_PUBLIC void  fsg_RestoreContourData(
	 uint8 **               ppbyOutline,
	 F26Dot6 **             ppX,
	 F26Dot6 **             ppY,
	 int16 **               ppSp,
	 int16 **               ppEp,
	 uint8 **               ppOnCurve,
	 uint8 **               ppFc,
	 uint16 *               pNc);

FS_PUBLIC void  fsg_GetDevAdvanceWidth(
	 fsg_WorkSpaceAddr * pWorkSpaceAddr,
	 point *                pDevAdvanceWidth);

FS_PUBLIC void  fsg_GetDevAdvanceHeight(
	 fsg_WorkSpaceAddr * pWorkSpaceAddr,
	 point *                pDevAdvanceHeight);

FS_PUBLIC void  fsg_GetScaledCVT(
	char *                      pPrivateFontSpace,
	fsg_PrivateSpaceOffsets *   PrivateSpaceOffsets,
	F26Dot6 **                  ppScaledCVT);

FS_PUBLIC void  fsg_45DegreePhaseShift(
	 fsg_WorkSpaceAddr * pWorkSpaceAddr);

FS_PUBLIC void  fsg_UpdateAdvanceWidth (
	fsg_TransformRec *  TransformInfo,
	void *              pvGlobalGS,
	uint16              usNonScaledAW,
	vectorType *        AdvanceWidth);

FS_PUBLIC void  fsg_UpdateAdvanceHeight (
	fsg_TransformRec *  TransformInfo,
	void *              pvGlobalGS,
	uint16              usNonScaledAH,
	vectorType *        AdvanceHeight);

FS_PUBLIC void  fsg_ScaleVerticalMetrics (
    fsg_TransformRec *  TransformInfo,
    void *              pvGlobalGS,
	uint16              usNonScaledAH,
    int16               sNonScaledTSB,
	vectorType *        pvecAdvanceHeight,
	vectorType *        pvecTopSideBearing);

FS_PUBLIC void  fsg_CalcLSBsAndAdvanceWidths(
	 fsg_WorkSpaceAddr * pWorkSpaceAddr,
	 F26Dot6                fxXMin,
	 F26Dot6                fxYMax,
	 point *                devAdvanceWidth,
	 point *                devLeftSideBearing,
	 point *                LeftSideBearing,
	 point *                devLeftSideBearingLine,
	 point *                LeftSideBearingLine);

FS_PUBLIC void  fsg_CalcTSBsAndAdvanceHeights(
	 fsg_WorkSpaceAddr * pWorkSpaceAddr,
	 F26Dot6                fxXMin,
	 F26Dot6                fxYMax,
	 point *                devAdvanceHeight,
	 point *                devTopSideBearing,
	 point *                TopSideBearing,
	 point *                devTopSideBearingLine,
	 point *                TopSideBearingLine);

FS_PUBLIC boolean   fsg_IsTransformStretched(
	fsg_TransformRec *  TransformInfo);

FS_PUBLIC boolean   fsg_IsTransformRotated(
	fsg_TransformRec *  TransformInfo);

/*  Control Routines    */

FS_PUBLIC ErrorCode fsg_InitInterpreterTrans (
	fsg_TransformRec *  TransformInfo,
	void *              pvGlobalGS,     /* GlobalGS */
	Fixed               fxPointSize,
	int16               sXResolution,
	int16               sYResolution,
	boolean           bHintAtEmSquare,
	uint16             usEmboldWeightx,     /* scaling factor in x between 0 and 40 (20 means 2% fo the height) */
	uint16             usEmboldWeighty,     /* scaling factor in y between 0 and 40 (20 means 2% fo the height) */
	int16               sWinDescender,
	int32               lDescDev,               /* descender in device metric, used for clipping */
	int16 *            psBoldSimulHorShift,   /* shift for emboldening simulation, horizontally */
	int16 *            psBoldSimulVertShift   /* shift for emboldening simulation, vertically */
	);

FS_PUBLIC void  fsg_SetHintFlags(
	void *              pvGlobalGS,
	boolean				bHintForGray
#ifdef FSCFG_SUBPIXEL
	,uint16				flHintForSubPixel
#endif // FSCFG_SUBPIXEL
    );

FS_PUBLIC ErrorCode fsg_RunFontProgram(
	 void *                 globalGS,           /* GlobalGS */
	 fsg_WorkSpaceAddr * pWorkSpaceAddr,
	 void *                 pvTwilightElement,
	 FntTraceFunc           traceFunc);

FS_PUBLIC ErrorCode fsg_RunPreProgram (
	 sfac_ClientRec *   ClientInfo,
	 LocalMaxProfile *  pMaxProfile,     /* Max Profile Table    */
	 fsg_TransformRec * TransformInfo,
	 void *                 pvGlobalGS,
	 fsg_WorkSpaceAddr * pWorkSpaceAddr,
	 void *                 pvTwilightElement,
	 FntTraceFunc           traceFunc);

FS_PUBLIC ErrorCode fsg_GridFit (
	 sfac_ClientRec *   ClientInfo,      /* sfnt Client information     */
	 LocalMaxProfile *  pMaxProfile,     /* Max Profile Table               */
	 fsg_TransformRec * TransformInfo,  /* Transformation information    */
	 void *                 pvGlobalGS,      /* GlobalGS                            */
	 fsg_WorkSpaceAddr * pWorkSpaceAddr,
	 void *                 pvTwilightElement,
	 FntTraceFunc           traceFunc,
	 boolean                bUseHints,
	 uint16 *               pusScanType,
	 boolean *              pbGlyphHasOutline,
	 uint16 *               pusNonScaledAW,
	boolean                bBitmapEmboldening
#ifdef FSCFG_SUBPIXEL
	,boolean			    bSubPixel
#endif // FSCFG_SUBPIXEL
	 );

#ifdef  FSCFG_NO_INITIALIZED_DATA
FS_PUBLIC  void fsg_InitializeData (void);
#endif

#ifdef FSCFG_SUBPIXEL
FS_PUBLIC void  fsg_CopyFontProgramResults(
	void *              pvGlobalGS,
	void *              pvGlobalGSSubPixel);


FS_PUBLIC void  fsg_ScaleToCompatibleWidth (
	fsg_WorkSpaceAddr * pWorkSpaceAddr,
    Fixed   fxCompatibleWidthScale);  

FS_PUBLIC void  fsg_AdjustCompatibleMetrics (
	fsg_WorkSpaceAddr * pWorkSpaceAddr,
    F26Dot6   horTranslation,
    F26Dot6   newDevAdvanceWidthX);  

FS_PUBLIC void  fsg_CalcDevHorMetrics(
	fsg_WorkSpaceAddr * pWorkSpaceAddr,
	F26Dot6 *           pDevAdvanceWidthX,
	F26Dot6 *           pDevLeftSideBearingX,
	F26Dot6 *           pDevRightSideBearingX);

FS_PUBLIC void  fsg_CalcDevNatHorMetrics(
	fsg_WorkSpaceAddr * pWorkSpaceAddr,
	F26Dot6 *           pDevAdvanceWidthX,
	F26Dot6 *           pDevLeftSideBearingX,
	F26Dot6 *           pDevRightSideBearingX,
	F26Dot6 *           pNatAdvanceWidthX,
	F26Dot6 *           pNatLeftSideBearingX,
	F26Dot6 *           pNatRightSideBearingX);

#endif // FSCFG_SUBPIXEL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\fondrv\tt\scaler\scale.c ===
/****************************** Module Header ******************************\
* Module Name: Scale.c
*
* Created: 16-Oct-1992
*
* Copyright:  (c) 1987-1990, 1992 by Apple Computer, Inc., all rights reserved.
*             (c) 1989-1999. Microsoft Corporation.
*
* All Rights Reserved
*
* History:
*  Tue 16-Oct-1992 09:53:51 -by-  Greg Hitchcock [gregh]
* Created.
*   
*	 7/10/99	BeatS	   Add support for native SP fonts, vertical RGB
*	 4/01/99	BeatS	   Implement alternative interpretation of TT instructions for SP
*	02/21/97    claudebe   scaled component in composite glyphs
*	12/14/95    claudebe   adding two private phantom points for vertical positionning
* .
\***************************************************************************/

#define FSCFG_INTERNAL

/* INCLUDES */

#include "fserror.h"
#include "fscdefs.h"
#include "fontmath.h"
#include "fnt.h"
#include "scale.h"

#include "stat.h"

/* Constants    */

/* use the lower ones for public phantom points */

// public phantom points moved to fnt.h more global use

/* private phantom points start here */

#define ORIGINPOINT 4
#define LEFTEDGEPOINT 5

#define TOPORIGINPOINT 6
#define TOPEDGEPOINT 7

#define CANTAKESHIFT    0x02000000

/* MACROS   */

/* d is half of the denumerator */
#define FROUND( x, n, d, s ) \
		((SHORTMUL (x, n) + (d)) >> s)

#define SROUND( x, n, d, halfd ) \
	(x < 0 ? -((SHORTMUL (-(x), (n)) + (halfd)) / (d)) : ((SHORTMUL ((x), (n)) + (halfd)) / (d)))

#define NUMBEROFCHARPOINTS(pElement)  (uint16)(pElement->ep[pElement->nc - 1] + 1)
#define NUMBEROFTOTALPOINTS(pElement)  (uint16)(pElement->ep[pElement->nc - 1] + 1 + PHANTOMCOUNT)

#define LSBPOINTNUM(pElement) (uint16)(pElement->ep[pElement->nc - 1] + 1 + LEFTSIDEBEARING)
#define RSBPOINTNUM(pElement) (uint16)(pElement->ep[pElement->nc - 1] + 1 + RIGHTSIDEBEARING)

#define TOPSBPOINTNUM(pElement) (uint16)(pElement->ep[pElement->nc - 1] + 1 + TOPSIDEBEARING)
#define BOTTOMSBPOINTNUM(pElement) (uint16)(pElement->ep[pElement->nc - 1] + 1 + BOTTOMSIDEBEARING)

#define ORIGINPOINTNUM(pElement) (uint16)(pElement->ep[pElement->nc - 1] + 1 + ORIGINPOINT)
#define LEFTEDGEPOINTNUM(pElement) (uint16)(pElement->ep[pElement->nc - 1] + 1 + LEFTEDGEPOINT)

#define TOPORIGINPOINTNUM(pElement) (uint16)(pElement->ep[pElement->nc - 1] + 1 + TOPORIGINPOINT)
#define TOPEDGEPOINTNUM(pElement) (uint16)(pElement->ep[pElement->nc - 1] + 1 + TOPEDGEPOINT)

/* PROTOTYPES   */

FS_PRIVATE GlobalGSScaleFunc scl_ComputeScaling(fnt_ScaleRecord* rec, Fixed N, Fixed D);
FS_PRIVATE F26Dot6 scl_FRound (fnt_ScaleRecord* rec, F26Dot6 value);
FS_PRIVATE F26Dot6 scl_SRound (fnt_ScaleRecord* rec, F26Dot6 value);
FS_PRIVATE F26Dot6 scl_FixRound (fnt_ScaleRecord* rec, F26Dot6 value);

FS_PRIVATE void scl_ShiftOldPoints (
	fnt_ElementType *   pElement,
	F26Dot6             fxXShift,
	F26Dot6             fxYShift,
	uint16              usFirstPoint,
	uint16              usNumPoints);

FS_PRIVATE void  scl_Scale (
	fnt_ScaleRecord *   sr,
	GlobalGSScaleFunc   ScaleFunc,
	F26Dot6 *           oop,
	F26Dot6 *           p,
	int32               numPts);

FS_PRIVATE void  scl_ScaleBack (
	fnt_ScaleRecord *   sr,
	GlobalGSScaleFunc   ScaleFunc,
	F26Dot6 *           oop,
	F26Dot6 *           p,
	int32               numPts);

FS_PRIVATE void  scl_ConvertToFixedFUnits (
	F26Dot6 *           oop,
	F26Dot6 *           p,
	int32               numPts);

FS_PRIVATE void  scl_ScaleFromFixedFUnits (
	fnt_ScaleRecord *   sr,
	GlobalGSScaleFunc   ScaleFunc,
	F26Dot6 *           oop,
	F26Dot6 *           p,
	int32               numPts);
/* FUNCTIONS    */

#define BOLD_FACTOR 0x51e
#define MABS(x)                 ( (x) < 0 ? (-(x)) : (x) )
#define POINTSPERINCH               72

void  multiplyForEmbold(long a, long b, long *highRes, long *lowRes)
{
    long lowA, highA, lowB, highB, temp1, temp2;

    lowA = a & 0xffff;
    highA = (a & 0xffff0000) >> 16;
    lowB = b & 0xffff;
    highB = (b & 0xffff0000) >> 16;

    *highRes = highA*highB;
    *lowRes = lowA*lowB;

    temp1 = highA*lowB;
    temp2 = lowA*highB;

    *highRes += (temp1 & 0xffff0000) >> 16;
    *highRes += (temp2 & 0xffff0000) >> 16;

    *lowRes += (temp1 & 0xffff) << 16;
    *lowRes += (temp2 & 0xffff) << 16;
}

void  adjustTrans(transMatrix *trans)   //Adjust matrix for Emboldening
{
    int i,j;
    int  bNegative;
    long tmp, highRes, lowRes;

    for(i=0; i<2; i++)
        for(j=0; j<2; j++){
        
        	tmp = (long) trans->transform[i][j];

            bNegative = tmp < 0 ? TRUE: FALSE;
            tmp = MABS(tmp);

            multiplyForEmbold(tmp, BOLD_FACTOR, &highRes, &lowRes);

            highRes <<= 16;
            tmp -= highRes;

            if(bNegative)
	            tmp = -tmp;

            trans->transform[i][j] = tmp;
        }
}

FS_PUBLIC ErrorCode   scl_InitializeScaling(
	void *          pvGlobalGS,             /* GlobalGS                 */
	boolean         bIntegerScaling,        /* Integer Scaling Flag     */
	transMatrix *   trans,                  /* Current Transformation   */
	uint16          usUpem,                 /* Current units per Em     */
	Fixed           fxPointSize,            /* Current point size       */
	int16           sXResolution,           /* Current X Resolution     */
	int16           sYResolution,           /* Current Y Resolution     */
	uint16          usEmboldWeightx,     /* scaling factor in x between 0 and 40 (20 means 2% fo the height) */
	uint16          usEmboldWeighty,     /* scaling factor in y between 0 and 40 (20 means 2% fo the height) */
	int16           sWinDescender,
	int32           lDescDev,               /* descender in device metric, used for clipping */
	int16 *			psBoldSimulHorShift,   /* shift for emboldening simulation, horizontally */
	int16 *			psBoldSimulVertShift,   /* shift for emboldening simulation, vertically */
	boolean			bHintAtEmSquare,
	uint32 *        pulPixelsPerEm)         /* OUT: Pixels Per Em       */
{
	Fixed        maxScale;
	Fixed        fxUpem;
	fnt_GlobalGraphicStateType *    globalGS;
	transMatrix   origTrans = *trans;
	uint16		usRotation;
	boolean			non90degreeRotation,nonUniformStretching;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	mth_FoldPointSizeResolution(fxPointSize, sXResolution, sYResolution, trans);

	if ( ( (usEmboldWeightx != 0) || (usEmboldWeighty != 0))  && 							// Adjust matrix for Emboldening
		 (uint16)ROUNDFIXTOINT(ShortMulDiv(fxPointSize, sYResolution, POINTSPERINCH)) > 50 )// when bigger than 50 ppem
	{
        adjustTrans(trans);
    }

	mth_ReduceMatrix (trans);

	fxUpem = INTTOFIX(usUpem);

/*
 *  First set up the scalars...
 */

	/*save the flag for use in composite glyphs */
	globalGS->bHintAtEmSquare = bHintAtEmSquare;

	if (bHintAtEmSquare)
	{
		globalGS->interpScalarX = fxUpem;
		globalGS->interpScalarY = fxUpem;
		globalGS->fxMetricScalarX = mth_max_abs (trans->transform[0][0], trans->transform[0][1]);
		globalGS->fxMetricScalarY = mth_max_abs (trans->transform[1][0], trans->transform[1][1]);

		/* we don't want to round the interpScalar */
	}
	else
	{
		globalGS->interpScalarX = mth_max_abs (trans->transform[0][0], trans->transform[0][1]);
		globalGS->interpScalarY = mth_max_abs (trans->transform[1][0], trans->transform[1][1]);
		globalGS->fxMetricScalarX = globalGS->interpScalarX;
		globalGS->fxMetricScalarY = globalGS->interpScalarY;

		if (bIntegerScaling)
		{
			globalGS->interpScalarX = (Fixed)ROUNDFIXED(globalGS->interpScalarX);
			globalGS->interpScalarY = (Fixed)ROUNDFIXED(globalGS->interpScalarY);
		}
	}

	globalGS->ScaleFuncX = scl_ComputeScaling(&globalGS->scaleX, globalGS->interpScalarX, fxUpem);
	globalGS->ScaleFuncY = scl_ComputeScaling(&globalGS->scaleY, globalGS->interpScalarY, fxUpem);

	if ((globalGS->interpScalarX == 0) && (globalGS->interpScalarY == 0))
	{
		return TRAN_NULL_TRANSFORM_ERR;
	}
	if (globalGS->interpScalarX >= globalGS->interpScalarY)
	{
		globalGS->ScaleFuncCVT = globalGS->ScaleFuncX;
		globalGS->scaleCVT = globalGS->scaleX;
		globalGS->cvtStretchX = ONEFIX;
		globalGS->cvtStretchY = FixDiv(globalGS->interpScalarY, globalGS->interpScalarX);;
		maxScale = globalGS->interpScalarX;
	}
	else
	{
		globalGS->ScaleFuncCVT = globalGS->ScaleFuncY;
		globalGS->scaleCVT = globalGS->scaleY;
		globalGS->cvtStretchX = FixDiv(globalGS->interpScalarX, globalGS->interpScalarY);
		globalGS->cvtStretchY = ONEFIX;
		maxScale = globalGS->interpScalarY;
	}

	*pulPixelsPerEm = (uint32)ROUNDFIXTOINT (globalGS->interpScalarY);

	globalGS->bSameStretch  = (uint8)mth_SameStretch( globalGS->interpScalarX, globalGS->interpScalarY );
	globalGS->pixelsPerEm   = (uint16)ROUNDFIXTOINT(maxScale);
	globalGS->pointSize     = (uint16)ROUNDFIXTOINT( fxPointSize );
	globalGS->fpem          = maxScale;
	globalGS->identityTransformation = (int8)mth_PositiveSquare( trans );

	/* Use bit 1 of non90degreeTransformation to signify stretching.  stretch = 2 */

	mth_Non90DegreeTransformation(&origTrans,&non90degreeRotation,&nonUniformStretching);

	globalGS->non90DegreeTransformation = 0;

	if (non90degreeRotation)  globalGS->non90DegreeTransformation |= NON90DEGTRANS_ROTATED;
	if (nonUniformStretching) globalGS->non90DegreeTransformation |= NON90DEGTRANS_STRETCH;


	*psBoldSimulHorShift = 0;
	*psBoldSimulVertShift = 0;

	if ((usEmboldWeightx != 0) || (usEmboldWeighty != 0))
	{
		/* we cannot use globalGS->pixelsPerEm because it s incorrect under non 90degree rotation */
		uint16 ppemY;
		Fixed fxBoldSimulHorShift,fxBoldSimulVertShift;
		F26Dot6	fxDefaultDescender;
        transMatrix reverseTrans;
        Fixed   fxDeterminant;
		Fixed fxScale;

		fxScale = ShortMulDiv(fxPointSize, sYResolution, POINTSPERINCH);
		ppemY = (uint16)ROUNDFIXTOINT(fxScale);  
		usRotation = mth_90degRotationFactorForEmboldening(trans);
		if( usRotation == 8 )   // Consider Italic/Bold case
            usRotation = mth_90degClosestRotationFactor(trans);

		if (bHintAtEmSquare)
		{
            *psBoldSimulVertShift = (ppemY * usEmboldWeighty - 10) /1000; /* save the number of pixels for bitmap emboldening */
			ppemY = usUpem;
		}

		/* this computation is intended to give backwards compatible results with the
			bitmap emboldening simulation done in Windows NT 4.0
		    The following computation was adapted to get the same cutoff than Win'98 between 50 and 51 ppem
			for an emboldening factor of 2% (usEmboldWeight = 20)
		*/

		globalGS->uBoldSimulVertShift = (ppemY * usEmboldWeighty - 10) /1000;
		globalGS->uBoldSimulHorShift = (ppemY * usEmboldWeightx - 10) /1000 + 1;

		if (!bHintAtEmSquare)
		    *psBoldSimulVertShift = globalGS->uBoldSimulVertShift; /* save the number of pixels for bitmap emboldening */

 		switch(usRotation)                   /* handle 90 degree rotations */
		{
		case 0:                                     // 0 degree with sx>0 & sy>0 or 180 degree with sx<0 & sy<0
			*psBoldSimulHorShift = *psBoldSimulVertShift+1;
			*psBoldSimulVertShift = -(*psBoldSimulVertShift);
 			break;
		case 1:                                     // 90 degree with sx>0 & sy>0 or 270 degree with sx<0 & sy<0
			*psBoldSimulHorShift = -(*psBoldSimulVertShift);
			*psBoldSimulVertShift = -(*psBoldSimulVertShift+1);
			break;
		case 2:                                     // 180 degree with sx>0 & sy>0 or 0 degree with sx<0 & sy<0
			*psBoldSimulHorShift = -(*psBoldSimulVertShift+1);
			*psBoldSimulVertShift = *psBoldSimulVertShift;
			break;
		case 3:                                     // 270 degree with sx>0 & sy>0 or 90 degree with sx<0 & sy<0
			*psBoldSimulHorShift = *psBoldSimulVertShift;
			*psBoldSimulVertShift = *psBoldSimulVertShift + 1;
			break;
		case 4:                                     // 0 degree with sx>0 & sy<0 or 180 degree with sx<0 & sy>0
			*psBoldSimulHorShift = *psBoldSimulVertShift+1;
			*psBoldSimulVertShift = *psBoldSimulVertShift;
 			break;
		case 5:                                     // 90 degree with sx>0 & sy<0 or 270 degree with sx<0 & sy>0
			*psBoldSimulHorShift = *psBoldSimulVertShift;
			*psBoldSimulVertShift = -(*psBoldSimulVertShift+1);
			break;
		case 6:                                     // 180 degree with sx>0 & sy<0 or 0 degree with sx<0 & sy>0
			*psBoldSimulHorShift = -(*psBoldSimulVertShift+1);
			*psBoldSimulVertShift = -*psBoldSimulVertShift;
			break;
		case 7:                                     // 270 degree with sx>0 & sy<0 or 90 degree with sx<0 & sy>0
			*psBoldSimulHorShift = -*psBoldSimulVertShift;
			*psBoldSimulVertShift = *psBoldSimulVertShift + 1;
			break;
		default:                                    /* non 90 degree rotation */
			*psBoldSimulHorShift = 0;
			*psBoldSimulVertShift = 0;
		}

		if (!bHintAtEmSquare && (sYResolution != sXResolution))
		{
			fxBoldSimulHorShift = globalGS->uBoldSimulHorShift << 16;
			fxBoldSimulVertShift = globalGS->uBoldSimulVertShift << 16;
            fxDeterminant = MABS( FixMul(origTrans.transform[0][0],origTrans.transform[1][1]) - FixMul(origTrans.transform[0][1],origTrans.transform[1][0]) );

			if (fxDeterminant == 0)
			{
				globalGS->uBoldSimulHorShift = 0;  
				globalGS->uBoldSimulVertShift = 0;  
			}
			else
			{
				origTrans.transform[0][0] = FixDiv(origTrans.transform[0][0], fxDeterminant);
				origTrans.transform[0][1] = FixDiv(origTrans.transform[0][1], fxDeterminant);
				origTrans.transform[1][0] = FixDiv(origTrans.transform[1][0], fxDeterminant);
				origTrans.transform[1][1] = FixDiv(origTrans.transform[1][1], fxDeterminant);
				reverseTrans = origTrans;
				reverseTrans.transform[0][1] = - reverseTrans.transform[0][1];
				reverseTrans.transform[1][0] = - reverseTrans.transform[1][0];

				mth_IntelMul (
					1,
					&fxBoldSimulHorShift,
					&fxBoldSimulVertShift,
					&origTrans,
					ONEFIX,
					ONEFIX);

				fxBoldSimulHorShift = ShortMulDiv(fxBoldSimulHorShift, sXResolution, sYResolution);

				mth_IntelMul (
					1,
					&fxBoldSimulHorShift,
					&fxBoldSimulVertShift,
					&reverseTrans,
					ONEFIX,
					ONEFIX);

				globalGS->uBoldSimulHorShift = (uint16)ROUNDFIXTOINT(MABS(fxBoldSimulHorShift));  
				globalGS->uBoldSimulVertShift = (uint16)ROUNDFIXTOINT(MABS(fxBoldSimulVertShift));  
			}

        }

		if (!bHintAtEmSquare && !(globalGS->non90DegreeTransformation & NON90DEGTRANS_ROTATED))
		{
			/* 90 degree rotation, convert the device value into 26.6 */
			globalGS->fxScaledDescender = -lDescDev << 6;
		} else 
		{
			/* under rotation, we use the value from head-Descender and scale it */
			fxDefaultDescender = sWinDescender;

			scl_Scale (&globalGS->scaleY,
					globalGS->ScaleFuncY,
					&fxDefaultDescender,
					&globalGS->fxScaledDescender,
					1);

			/* add the uBoldSimulVertShift and round to the next pixel */
			globalGS->fxScaledDescender = globalGS->fxScaledDescender & ~(LOWSIXBITS);
		}
	} else {
		globalGS->uBoldSimulHorShift = 0;
		globalGS->uBoldSimulVertShift = 0;
		globalGS->fxScaledDescender = 0;
	}
	return NO_ERR;
}

FS_PUBLIC void scl_InitializeChildScaling(
	void *          pvGlobalGS,             /* GlobalGS                 */
	transMatrix     CurrentTMatrix,                  /* Current Transformation   */
	uint16          usUpem)                 /* Current units per Em     */
{
	Fixed        fxUpem;
	fnt_GlobalGraphicStateType *    globalGS;
	Fixed           interpScalarX;    
	Fixed           interpScalarY;    

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	fxUpem = INTTOFIX(usUpem);

/* 
 * This procedure is a subset from scl_InitializeScaling. 
 * There is no perfect solution here, we decided that the best, in the case of a
 * component that is not at the same transformation as the master glyph,
 * is to scale this child glyph to the user grid for hinting, without re-running
 * the pre-program, without rescaling the cvt or changing other GloblaGS information (pointSize, pixelPerEm,...)
 */

/*
 *  First set up the scalars...
 */
	if (globalGS->bHintAtEmSquare)
	{
		interpScalarX = fxUpem;
		interpScalarY = fxUpem;
	}
	else
	{
		interpScalarX = mth_max_abs (CurrentTMatrix.transform[0][0], CurrentTMatrix.transform[0][1]);
		interpScalarY = mth_max_abs (CurrentTMatrix.transform[1][0], CurrentTMatrix.transform[1][1]);
	}

	globalGS->ScaleFuncXChild = scl_ComputeScaling(&globalGS->scaleXChild, interpScalarX, fxUpem);
	globalGS->ScaleFuncYChild = scl_ComputeScaling(&globalGS->scaleYChild, interpScalarY, fxUpem);

}

FS_PUBLIC void  scl_SetHintFlags(
	void *              pvGlobalGS,
	boolean				bHintForGray
#ifdef FSCFG_SUBPIXEL
	,uint16			flHintForSubPixel
#endif // FSCFG_SUBPIXEL
    )

{
	fnt_GlobalGraphicStateType *    globalGS;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	globalGS->bHintForGray = bHintForGray;

#ifdef FSCFG_SUBPIXEL
	globalGS->flHintForSubPixel = flHintForSubPixel;
#endif // FSCFG_SUBPIXEL
}

/******************** These three scale 26.6 to 26.6 ********************/
/*
 * Fast (scaling)
 */
FS_PRIVATE F26Dot6 scl_FRound(fnt_ScaleRecord* rec, F26Dot6 value)
{
	return (F26Dot6) FROUND (value, rec->numer, rec->denom >> 1, rec->shift);
}

/*
 * Medium (scaling)
 */
FS_PRIVATE F26Dot6 scl_SRound(fnt_ScaleRecord* rec, F26Dot6 value)
{
	int32 D;

	D = rec->denom;
	return (F26Dot6) SROUND (value, rec->numer, D, D >> 1);
}

/*
 * Fixed Rounding (scaling), really slow
 */
FS_PRIVATE F26Dot6 scl_FixRound(fnt_ScaleRecord* rec, F26Dot6 value)
{
	return (F26Dot6) FixMul ((Fixed)value, rec->fixedScale);
}

/********************************* End scaling utilities ************************/

FS_PRIVATE GlobalGSScaleFunc scl_ComputeScaling(fnt_ScaleRecord* rec, Fixed N, Fixed D)
{
	int32     lShift;

	lShift = mth_CountLowZeros((uint32)(N | D) ) - 1;

	if (lShift > 0)
	{
		N >>= lShift;
		D >>= lShift;
	}


	if ( N < CANTAKESHIFT )
	{
		N <<= FNT_PIXELSHIFT;
	}
	else
	{
		D >>= FNT_PIXELSHIFT;
	}

	/* fixedScale is now set in every case for the scale back in scaled composites */
	rec->fixedScale = FixDiv(N, D);

	if (N <= SHRT_MAX)   /* Check to see if N fits in a short    */
	{
		lShift = mth_GetShift ((uint32) D);
		rec->numer = (int32)N;
		rec->denom = (int32)D;

		if ( lShift >= 0 )                  /* FAST SCALE */
		{
			rec->shift = (int32)lShift;
			return (GlobalGSScaleFunc)scl_FRound;
		}
		else                                /* MEDIUM SCALE */
		{
			return (GlobalGSScaleFunc)scl_SRound;
		}
	}
	else                                    /* SLOW SCALE */
	{
		return (GlobalGSScaleFunc)scl_FixRound;
	}
}


FS_PRIVATE void  scl_Scale (
	fnt_ScaleRecord *   sr,
	GlobalGSScaleFunc   ScaleFunc,
	F26Dot6 *           oop,
	F26Dot6 *           p,
	int32               numPts)
{
	int32   Index;

	if (ScaleFunc == scl_FRound)
	{
		for(Index = 0; Index < numPts; Index++)
		{
			p[Index] = (F26Dot6) FROUND (oop[Index], sr->numer, sr->denom >> 1, sr->shift);
		}
	}
	else
	{
		if (ScaleFunc == scl_SRound)
		{
			for(Index = 0; Index < numPts; Index++)
			{
				p[Index] = (F26Dot6) SROUND (oop[Index], sr->numer, sr->denom, sr->denom >> 1);
			}
		}
		else
		{
			for(Index = 0; Index < numPts; Index++)
			{
				p[Index] = (F26Dot6) FixMul ((Fixed)oop[Index], sr->fixedScale);
			}
		}
	}
}


FS_PRIVATE void  scl_ScaleFromFixedFUnits (
	fnt_ScaleRecord *   sr,
	GlobalGSScaleFunc   ScaleFunc,
	F26Dot6 *           oop,
	F26Dot6 *           p,
	int32               numPts)
{
	int32   Index;
	int32	Scale;
	int32	Shift;
	int32	Numer;

	/* we are now multiplying a 26.6 by sr->numer, we could overflow if (sr->numer >= SHRT_MAX >> FNT_PIXELSHIFT) */
	if ((ScaleFunc == scl_FRound) && (sr->numer < (SHRT_MAX >> FNT_PIXELSHIFT) ))
	{
		
		Shift = sr->shift + FNT_PIXELSHIFT;

		for(Index = 0; Index < numPts; Index++)
		{
			p[Index] = (F26Dot6) FROUND (oop[Index], sr->numer, sr->denom >> 1, Shift);
		}
	}
	else
	{
		if (ScaleFunc == scl_SRound)
		{
			Numer = sr->numer >> FNT_PIXELSHIFT;

			for(Index = 0; Index < numPts; Index++)
			{
				p[Index] = (F26Dot6) SROUND (oop[Index], Numer, sr->denom, sr->denom >> 1);
			}
		}
		else
		{
			Scale = sr->fixedScale >> FNT_PIXELSHIFT;
			for(Index = 0; Index < numPts; Index++)
			{
				p[Index] = (F26Dot6) FixMul ((Fixed)oop[Index], Scale);
			}
		}
	}
}

FS_PRIVATE void  scl_ScaleBack (
	fnt_ScaleRecord *   sr,
	GlobalGSScaleFunc   ScaleFunc,
	F26Dot6 *           oop,
	F26Dot6 *           p,
	int32               numPts)
{
	int32   Index;
	int32	ScaleBack;

	ScaleBack = sr->fixedScale >> FNT_PIXELSHIFT;
	for(Index = 0; Index < numPts; Index++)
	{
		p[Index] = (F26Dot6) FixDiv ((Fixed)oop[Index], ScaleBack);
	}
}

FS_PRIVATE void  scl_ConvertToFixedFUnits (
	F26Dot6 *           oop,
	F26Dot6 *           p,
	int32               numPts)
{
	int32   Index;

	for(Index = 0; Index < numPts; Index++)
	{
		p[Index] = (Fixed)oop[Index] << FNT_PIXELSHIFT;
	}
}

/*
 *  scl_ScaleChar                       <3>
 *
 *  Scales a character
 */

FS_PUBLIC void  scl_ScaleOldCharPoints (
	fnt_ElementType *   pElement,   /* Element  */
	void *              pvGlobalGS) /* GlobalGS */
{
	fnt_GlobalGraphicStateType *    globalGS;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	if (globalGS->bSameTransformAsMaster)
	{
		scl_Scale (&globalGS->scaleX,
				globalGS->ScaleFuncX,
				pElement->oox,
				pElement->ox,
				(int32)NUMBEROFCHARPOINTS(pElement));
		scl_Scale (&globalGS->scaleY,
				globalGS->ScaleFuncY,
				pElement->ooy,
				pElement->oy,
				(int32)NUMBEROFCHARPOINTS(pElement));
	}
	else
	{
		scl_Scale (&globalGS->scaleXChild,
				globalGS->ScaleFuncXChild,
				pElement->oox,
				pElement->ox,
				(int32)NUMBEROFCHARPOINTS(pElement));
		scl_Scale (&globalGS->scaleYChild,
				globalGS->ScaleFuncYChild,
				pElement->ooy,
				pElement->oy,
				(int32)NUMBEROFCHARPOINTS(pElement));
	}

}
/*
 *  scl_ScaleChar                       <3>
 *
 *  Scales a character
 */

FS_PUBLIC void  scl_ScaleFixedCurrentCharPoints (
	fnt_ElementType *   pElement,   /* Element  */
	void *              pvGlobalGS) /* GlobalGS */
{
	fnt_GlobalGraphicStateType *    globalGS;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	if (globalGS->bSameTransformAsMaster)
	{
		scl_ScaleFromFixedFUnits (&globalGS->scaleX,
				globalGS->ScaleFuncX,
				pElement->x,
				pElement->x,
				(int32)NUMBEROFCHARPOINTS(pElement));
		scl_ScaleFromFixedFUnits (&globalGS->scaleY,
				globalGS->ScaleFuncY,
				pElement->y,
				pElement->y,
				(int32)NUMBEROFCHARPOINTS(pElement));
	}
	else
	{
		scl_ScaleFromFixedFUnits (&globalGS->scaleXChild,
				globalGS->ScaleFuncXChild,
				pElement->x,
				pElement->x,
				(int32)NUMBEROFCHARPOINTS(pElement));
		scl_ScaleFromFixedFUnits (&globalGS->scaleYChild,
				globalGS->ScaleFuncYChild,
				pElement->y,
				pElement->y,
				(int32)NUMBEROFCHARPOINTS(pElement));
	}

}

FS_PUBLIC void  scl_ScaleOldPhantomPoints (
	fnt_ElementType *   pElement,   /* Element  */
	void *              pvGlobalGS) /* GlobalGS */
{
	uint16                    usFirstPhantomPoint;
	fnt_GlobalGraphicStateType *    globalGS;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	usFirstPhantomPoint = LSBPOINTNUM(pElement);

	if (globalGS->bSameTransformAsMaster)
	{
		scl_Scale (&globalGS->scaleX,
				globalGS->ScaleFuncX,
				&(pElement->oox[usFirstPhantomPoint]),
				&(pElement->ox[usFirstPhantomPoint]),
				(int32)PHANTOMCOUNT);

		scl_Scale (&globalGS->scaleY,
				globalGS->ScaleFuncY,
				&(pElement->ooy[usFirstPhantomPoint]),
				&(pElement->oy[usFirstPhantomPoint]),
				(int32)PHANTOMCOUNT);
	}
	else
	{
		scl_Scale (&globalGS->scaleXChild,
				globalGS->ScaleFuncXChild,
				&(pElement->oox[usFirstPhantomPoint]),
				&(pElement->ox[usFirstPhantomPoint]),
				(int32)PHANTOMCOUNT);

		scl_Scale (&globalGS->scaleYChild,
				globalGS->ScaleFuncYChild,
				&(pElement->ooy[usFirstPhantomPoint]),
				&(pElement->oy[usFirstPhantomPoint]),
				(int32)PHANTOMCOUNT);
	}

}

FS_PUBLIC void  scl_ScaleFixedCurrentPhantomPoints (
	fnt_ElementType *   pElement,   /* Element  */
	void *              pvGlobalGS) /* GlobalGS */
{
	uint16                    usFirstPhantomPoint;
	fnt_GlobalGraphicStateType *    globalGS;


	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	Assert(globalGS->bSameTransformAsMaster);

	usFirstPhantomPoint = LSBPOINTNUM(pElement);

	scl_ScaleFromFixedFUnits (&globalGS->scaleX,
			   globalGS->ScaleFuncX,
			   &(pElement->x[usFirstPhantomPoint]),
			   &(pElement->x[usFirstPhantomPoint]),
			   (int32)PHANTOMCOUNT);

	scl_ScaleFromFixedFUnits (&globalGS->scaleY,
			   globalGS->ScaleFuncY,
			   &(pElement->y[usFirstPhantomPoint]),
			   &(pElement->y[usFirstPhantomPoint]),
			   (int32)PHANTOMCOUNT);

}

/*
 *  scl_ScaleBackCurrentCharPoints                     
 *
 *  Scales back a character to hinted fixed FUnits
 */

FS_PUBLIC void  scl_ScaleBackCurrentCharPoints (
	fnt_ElementType *   pElement,   /* Element  */
	void *              pvGlobalGS) /* GlobalGS */
{
	fnt_GlobalGraphicStateType *    globalGS;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	if (globalGS->bSameTransformAsMaster)
	{
		scl_ScaleBack (&globalGS->scaleX,
			    globalGS->ScaleFuncX,
				pElement->x,
				pElement->x,
				(int32)NUMBEROFCHARPOINTS(pElement));
		scl_ScaleBack (&globalGS->scaleY,
			    globalGS->ScaleFuncY,
				pElement->y,
				pElement->y,
				(int32)NUMBEROFCHARPOINTS(pElement));
	}
	else
	{
		scl_ScaleBack (&globalGS->scaleXChild,
			    globalGS->ScaleFuncXChild,
				pElement->x,
				pElement->x,
				(int32)NUMBEROFCHARPOINTS(pElement));
		scl_ScaleBack (&globalGS->scaleYChild,
			    globalGS->ScaleFuncYChild,
				pElement->y,
				pElement->y,
				(int32)NUMBEROFCHARPOINTS(pElement));
	}

}

FS_PUBLIC void  scl_ScaleBackCurrentPhantomPoints (
	fnt_ElementType *   pElement,   /* Element  */
	void *              pvGlobalGS) /* GlobalGS */
{
	uint16                    usFirstPhantomPoint;
	fnt_GlobalGraphicStateType *    globalGS;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	usFirstPhantomPoint = LSBPOINTNUM(pElement);

	if (globalGS->bSameTransformAsMaster)
	{
		scl_ScaleBack (&globalGS->scaleX,
			    globalGS->ScaleFuncX,
				&(pElement->x[usFirstPhantomPoint]),
				&(pElement->x[usFirstPhantomPoint]),
				(int32)PHANTOMCOUNT);

		scl_ScaleBack (&globalGS->scaleY,
			    globalGS->ScaleFuncY,
				&(pElement->y[usFirstPhantomPoint]),
				&(pElement->y[usFirstPhantomPoint]),
				(int32)PHANTOMCOUNT);
	}
	else
	{
		scl_ScaleBack (&globalGS->scaleXChild,
			    globalGS->ScaleFuncXChild,
				&(pElement->x[usFirstPhantomPoint]),
				&(pElement->x[usFirstPhantomPoint]),
				(int32)PHANTOMCOUNT);

		scl_ScaleBack (&globalGS->scaleYChild,
			    globalGS->ScaleFuncYChild,
				&(pElement->y[usFirstPhantomPoint]),
				&(pElement->y[usFirstPhantomPoint]),
				(int32)PHANTOMCOUNT);
	}
}

/*
 *  scl_OriginalCharPointsToCurrentFixedFUnits                     
 *
 *  Scales back a character to hinted fixed FUnits
 */

FS_PUBLIC void  scl_OriginalCharPointsToCurrentFixedFUnits (
	fnt_ElementType *   pElement) /* Element */
{

	scl_ConvertToFixedFUnits (
			   pElement->oox,
			   pElement->x,
			   (int32)NUMBEROFCHARPOINTS(pElement));

	scl_ConvertToFixedFUnits (
			   pElement->ooy,
			   pElement->y,
			   (int32)NUMBEROFCHARPOINTS(pElement));
}

FS_PUBLIC void  scl_OriginalPhantomPointsToCurrentFixedFUnits (
	fnt_ElementType *   pElement) /* Element */
{
	uint16                    usFirstPhantomPoint;

	usFirstPhantomPoint = LSBPOINTNUM(pElement);

	scl_ConvertToFixedFUnits (
			   &(pElement->oox[usFirstPhantomPoint]),
			   &(pElement->x[usFirstPhantomPoint]),
			   (int32)PHANTOMCOUNT);

	scl_ConvertToFixedFUnits (
			   &(pElement->ooy[usFirstPhantomPoint]),
			   &(pElement->y[usFirstPhantomPoint]),
			   (int32)PHANTOMCOUNT);
}

/*
 * scl_ScaleCVT
 */

FS_PUBLIC void  scl_ScaleCVT(
	void *      pvGlobalGS,
	F26Dot6 *   pfxCVT)
{
	fnt_GlobalGraphicStateType *    globalGS;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	if(globalGS->cvtCount > 0)
	{
		scl_Scale (
			&globalGS->scaleCVT,
			globalGS->ScaleFuncCVT,
			pfxCVT,
			globalGS->controlValueTable,
			(int32)globalGS->cvtCount);
	}
}

FS_PUBLIC void  scl_GetCVTPtr(
	void *      pvGlobalGS,
	F26Dot6 **  pfxCVT)
{
	fnt_GlobalGraphicStateType *    globalGS;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	*pfxCVT = globalGS->controlValueTable;

}

FS_PUBLIC void  scl_CalcOrigPhantomPoints(
	fnt_ElementType *   pElement,       /* Element                      */
	BBOX *              bbox,           /* Bounding Box                 */
	int16               sNonScaledLSB,  /* Non-scaled Left Side Bearing */
	int16               sNonScaledTSB,  /* Non-scaled Top Side Bearing  */
	uint16              usNonScaledAW,  /* Non-scaled Advance Width     */
	uint16              usNonScaledAH, /* Non-scaled Advance Height    */
	int16               sNonScaledTopOriginX) /* Non-scaled Top Origin X  */
{

	F26Dot6             fxXMinMinusLSB;
	F26Dot6             fxYMaxPlusTSB;

	MEMSET (&(pElement->ooy[LSBPOINTNUM(pElement)]),
			'\0',
			PHANTOMCOUNT * sizeof (pElement->ooy[0]));

	MEMSET (&(pElement->oox[LSBPOINTNUM(pElement)]),
			'\0',
			PHANTOMCOUNT * sizeof (pElement->oox[0]));

	fxXMinMinusLSB = ((F26Dot6)bbox->xMin - (F26Dot6)sNonScaledLSB);

	pElement->oox[LSBPOINTNUM(pElement)] = fxXMinMinusLSB;
	pElement->oox[RSBPOINTNUM(pElement)] = fxXMinMinusLSB + (F26Dot6)usNonScaledAW;
	pElement->oox[ORIGINPOINTNUM(pElement)] = fxXMinMinusLSB;
	pElement->oox[LEFTEDGEPOINTNUM(pElement)] = (F26Dot6)bbox->xMin;

	fxYMaxPlusTSB = ((F26Dot6)bbox->yMax + (F26Dot6)sNonScaledTSB);

	pElement->ooy[TOPSBPOINTNUM(pElement)] = fxYMaxPlusTSB;
	pElement->ooy[BOTTOMSBPOINTNUM(pElement)] = fxYMaxPlusTSB - (F26Dot6)usNonScaledAH;
	pElement->ooy[TOPORIGINPOINTNUM(pElement)] = fxYMaxPlusTSB;
	pElement->ooy[TOPEDGEPOINTNUM(pElement)] = (F26Dot6)bbox->yMax;

	pElement->oox[TOPSBPOINTNUM(pElement)] = (F26Dot6)sNonScaledTopOriginX;
	pElement->oox[BOTTOMSBPOINTNUM(pElement)] = (F26Dot6)sNonScaledTopOriginX;
	pElement->oox[TOPORIGINPOINTNUM(pElement)] = (F26Dot6)sNonScaledTopOriginX;
	pElement->oox[TOPEDGEPOINTNUM(pElement)] = (F26Dot6)sNonScaledTopOriginX;
}

FS_PUBLIC void  scl_AdjustOldCharSideBearing(
	fnt_ElementType* pElement
#ifdef FSCFG_SUBPIXEL
	, void* pvGlobalGS
#endif
	)   /* Element  */
{
	F26Dot6     fxOldLeftOrigin;
	F26Dot6     fxNewLeftOrigin;
	uint16      cNumCharPoints;
#ifdef FSCFG_SUBPIXEL
	fnt_GlobalGraphicStateType* globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;
#endif

	cNumCharPoints = NUMBEROFCHARPOINTS(pElement);

	fxOldLeftOrigin = pElement->ox[LSBPOINTNUM(pElement)];
	fxNewLeftOrigin = fxOldLeftOrigin;
#ifdef FSCFG_SUBPIXEL
	if (RunningSubPixel(globalGS) && !VerticalSPDirection(globalGS)) {
		fxNewLeftOrigin += VIRTUAL_PIXELSIZE_RTG/2; // round to a virtual pixel boundary
		fxNewLeftOrigin &= ~(VIRTUAL_PIXELSIZE_RTG - 1);
	} else {
#endif
		fxNewLeftOrigin += FNT_PIXELSIZE/2; /* round to a pixel boundary */
		fxNewLeftOrigin &= ~(FNT_PIXELSIZE - 1);
#ifdef FSCFG_SUBPIXEL
	}
#endif

	scl_ShiftOldPoints (
		pElement,
		fxNewLeftOrigin - fxOldLeftOrigin,
		0L,
		0,
		cNumCharPoints);

}

FS_PUBLIC void  scl_AdjustOldPhantomSideBearing(
	fnt_ElementType* pElement
#ifdef FSCFG_SUBPIXEL
	, void* pvGlobalGS
#endif
	)   /* Element  */
{
	F26Dot6     fxOldLeftOrigin;
	F26Dot6     fxNewLeftOrigin;
#ifdef FSCFG_SUBPIXEL
	fnt_GlobalGraphicStateType* globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;
#endif

	fxOldLeftOrigin = pElement->ox[LSBPOINTNUM(pElement)];
	fxNewLeftOrigin = fxOldLeftOrigin;
#ifdef FSCFG_SUBPIXEL
	if (RunningSubPixel(globalGS) && !VerticalSPDirection(globalGS)) {
		fxNewLeftOrigin += VIRTUAL_PIXELSIZE_RTG/2; // round to a virtual pixel boundary
		fxNewLeftOrigin &= ~(VIRTUAL_PIXELSIZE_RTG - 1);
	} else {
#endif
		fxNewLeftOrigin += FNT_PIXELSIZE/2; /* round to a pixel boundary */
		fxNewLeftOrigin &= ~(FNT_PIXELSIZE - 1);
#ifdef FSCFG_SUBPIXEL
	}
#endif

	scl_ShiftOldPoints (
		pElement,
		fxNewLeftOrigin - fxOldLeftOrigin,
		0L,
		LSBPOINTNUM(pElement),
		PHANTOMCOUNT);
}

FS_PUBLIC void  scl_AdjustOldSideBearingPoints(
	fnt_ElementType* pElement
#ifdef FSCFG_SUBPIXEL
	, void* pvGlobalGS
#endif
	)   /* Element  */
{
	F26Dot6 fxOldLeftOrigin;
	F26Dot6 fxNewLeftOrigin;
#ifdef FSCFG_SUBPIXEL
	fnt_GlobalGraphicStateType* globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;
#endif

	fxOldLeftOrigin = pElement->ox[LSBPOINTNUM(pElement)];
	fxNewLeftOrigin = fxOldLeftOrigin;
#ifdef FSCFG_SUBPIXEL
	if (RunningSubPixel(globalGS) && !VerticalSPDirection(globalGS)) {
		fxNewLeftOrigin += VIRTUAL_PIXELSIZE_RTG/2; // round to a virtual pixel boundary
		fxNewLeftOrigin &= ~(VIRTUAL_PIXELSIZE_RTG - 1);
	} else {
#endif
		fxNewLeftOrigin += FNT_PIXELSIZE/2; /* round to a pixel boundary */
		fxNewLeftOrigin &= ~(FNT_PIXELSIZE - 1);
#ifdef FSCFG_SUBPIXEL
	}
#endif

	pElement->ox[LSBPOINTNUM(pElement)]  = fxNewLeftOrigin;
	pElement->ox[RSBPOINTNUM(pElement)] += fxNewLeftOrigin - fxOldLeftOrigin;
}

FS_PUBLIC void  scl_CopyOldCharPoints(
	fnt_ElementType *           pElement)   /* Element  */
{
	MEMCPY(pElement->ox, pElement->x, (size_t)NUMBEROFCHARPOINTS(pElement) * sizeof(F26Dot6));
	MEMCPY(pElement->oy, pElement->y, (size_t)NUMBEROFCHARPOINTS(pElement) * sizeof(F26Dot6));
}

FS_PUBLIC void  scl_CopyCurrentCharPoints(
	fnt_ElementType *           pElement)   /* Element  */
{
	MEMCPY(pElement->x, pElement->ox, (size_t)NUMBEROFCHARPOINTS(pElement) * sizeof(F26Dot6));
	MEMCPY(pElement->y, pElement->oy, (size_t)NUMBEROFCHARPOINTS(pElement) * sizeof(F26Dot6));
}

FS_PUBLIC void  scl_CopyCurrentPhantomPoints(
	fnt_ElementType *           pElement)   /* Element  */
{
	uint16    usFirstPhantomPoint;

	usFirstPhantomPoint = LSBPOINTNUM(pElement);
	MEMCPY(&pElement->x[usFirstPhantomPoint],
		   &pElement->ox[usFirstPhantomPoint],
		   PHANTOMCOUNT * sizeof(F26Dot6));

	MEMCPY(&pElement->y[usFirstPhantomPoint],
		   &pElement->oy[usFirstPhantomPoint],
		   PHANTOMCOUNT * sizeof(F26Dot6));
}

FS_PUBLIC void  scl_RoundCurrentSideBearingPnt(
	fnt_ElementType *   pElement,   /* Element  */
	void *              pvGlobalGS, /* GlobalGS */
	uint16              usEmResolution)
{
	F26Dot6     fxWidth;
	F26Dot6     fxHeight;
	fnt_GlobalGraphicStateType* globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	/* autoround the right side bearing */

	fxWidth = FIXEDTODOT6 (ShortMulDiv( (int32)globalGS->interpScalarX,
		(int16)(pElement->oox[RSBPOINTNUM(pElement)] - pElement->oox[LSBPOINTNUM(pElement)]),
		(int16)usEmResolution ));
/*
	fxWidth = globalGS->ScaleFuncX(&globalGS->scaleX,
		(pElement->oox[RSBPOINTNUM(pElement)] - pElement->oox[LSBPOINTNUM(pElement)]));
*/

#ifdef FSCFG_SUBPIXEL
	if (RunningSubPixel(globalGS) && !VerticalSPDirection(globalGS)  ) {
		fxWidth += VIRTUAL_PIXELSIZE_RTG / 2;
		fxWidth &= ~(VIRTUAL_PIXELSIZE_RTG - 1);
	} else { // for SubPixel in compatible width mode, always round to full pixel to get full pixel advance width
#endif
		fxWidth += FNT_PIXELSIZE / 2;
		fxWidth &= ~(FNT_PIXELSIZE - 1);
#ifdef FSCFG_SUBPIXEL
	}
#endif
	pElement->x[RSBPOINTNUM(pElement)] = pElement->x[LSBPOINTNUM(pElement)] + fxWidth;

	/* autoround the top side bearing */

	fxHeight = FIXEDTODOT6 (ShortMulDiv( (int32)globalGS->interpScalarY,
		(int16)(pElement->ooy[BOTTOMSBPOINTNUM(pElement)] - pElement->ooy[TOPSBPOINTNUM(pElement)]),
		(int16)usEmResolution ));
/*
	fxHeight = globalGS->ScaleFuncY(&globalGS->scaleY,
		(pElement->ooy[BOTTOMSBPOINTNUM(pElement)] - pElement->ooy[TOPSBPOINTNUM(pElement)]));
*/

	/* in the vertical direction, as we don't round the old TOPSBPOINT 
	    and do scl_ShiftOldPoints, we need to round TOPSBPOINT here */
	pElement->y[TOPSBPOINTNUM(pElement)] =
		(pElement->y[TOPSBPOINTNUM(pElement)] + DOT6ONEHALF) & ~(LOWSIXBITS);

	pElement->y[BOTTOMSBPOINTNUM(pElement)] =
		pElement->y[TOPSBPOINTNUM(pElement)] + (fxHeight + DOT6ONEHALF) & ~(LOWSIXBITS);
}

/*
 *  scl_ShiftChar
 *
 *  Shifts a character          <3>
 */
FS_PUBLIC void scl_ShiftCurrentCharPoints (
	fnt_ElementType *   pElement,
	F26Dot6             fxXShift,
	F26Dot6             fxYShift)

{
	uint32  ulCharIndex;

	if (fxXShift != 0)
	{
		for(ulCharIndex = 0; ulCharIndex < (uint32)NUMBEROFCHARPOINTS(pElement); ulCharIndex++)
		{
		   pElement->x[ulCharIndex] += fxXShift;
		}
	}

	if (fxYShift != 0)
	{
		for(ulCharIndex = 0; ulCharIndex < (uint32)NUMBEROFCHARPOINTS(pElement); ulCharIndex++)
		{
		   pElement->y[ulCharIndex] += fxYShift;
		}
	}
}

FS_PRIVATE void scl_ShiftOldPoints (
	fnt_ElementType *   pElement,
	F26Dot6             fxXShift,
	F26Dot6             fxYShift,
	uint16              usFirstPoint,
	uint16              usNumPoints)
{
	uint32  ulCharIndex;

	if (fxXShift != 0)
	{
		for(ulCharIndex = (uint32)usFirstPoint; ulCharIndex < ((uint32)usFirstPoint + (uint32)usNumPoints); ulCharIndex++)
		{
			pElement->ox[ulCharIndex] += fxXShift;
		}
	}

	if (fxYShift != 0)
	{
		for(ulCharIndex = (uint32)usFirstPoint; ulCharIndex < ((uint32)usFirstPoint + (uint32)usNumPoints); ulCharIndex++)
		{
			pElement->oy[ulCharIndex] += fxYShift;
		}
	}
}

FS_PUBLIC void  scl_CalcComponentOffset(
	void *      pvGlobalGS,         /* GlobalGS             */
	int16       sXOffset,           /* IN: X Offset         */
	int16       sYOffset,           /* Y Offset             */
	boolean     bRounding,          /* Rounding Indicator   */
	boolean		bSameTransformAsMaster, /* local transf. same as master transf. */
	boolean     bScaleCompositeOffset,  /* does the component offset need to be scaled Apple/MS */
	transMatrix mulT,                   /* Transformation matrix for composite              */
#ifdef FSCFG_SUBPIXEL
	RotationParity	rotationParity,
#endif
	F26Dot6 *   pfxXOffset,         /* OUT: X Offset        */
	F26Dot6 *   pfxYOffset)         /* Y Offset             */
{
	fnt_GlobalGraphicStateType *    globalGS;
	Fixed     scalarX;
	Fixed     scalarY;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	if (bSameTransformAsMaster) {
		*pfxXOffset = globalGS->ScaleFuncX(&globalGS->scaleX,(F26Dot6)sXOffset);
		*pfxYOffset = globalGS->ScaleFuncY(&globalGS->scaleY,(F26Dot6)sYOffset);
	} else {
		*pfxXOffset = globalGS->ScaleFuncXChild(&globalGS->scaleXChild,(F26Dot6)sXOffset);
		*pfxYOffset = globalGS->ScaleFuncYChild(&globalGS->scaleYChild,(F26Dot6)sYOffset);
	}

	if (bScaleCompositeOffset)
	/* the composite is designed to have its offset scaled (designed for Apple) */
	{
		/* Apple use a 45 degree special case that they are dropping on their GX rasterizer,
		   I'm not implementing this special rule here */
		scalarX = mth_max_abs (mulT.transform[0][0], mulT.transform[0][1]);
		scalarY = mth_max_abs (mulT.transform[1][0], mulT.transform[1][1]);
		if ((scalarX != ONEFIX) || (scalarY != ONEFIX)) {
			*pfxXOffset = (F26Dot6) FixMul ((Fixed)*pfxXOffset, scalarX);
			*pfxYOffset = (F26Dot6) FixMul ((Fixed)*pfxYOffset, scalarY);
		}
	}

	if (bRounding) {
#ifdef FSCFG_SUBPIXEL
		if (RunningSubPixel(globalGS) && ((rotationParity == arbitraryRotation) || ((rotationParity == evenMult90DRotation) != VerticalSPDirection(globalGS)))) {
			*pfxXOffset += VIRTUAL_PIXELSIZE_RTG / 2;
			*pfxXOffset &= ~(VIRTUAL_PIXELSIZE_RTG - 1);
		} else {
#endif
			*pfxXOffset += FNT_PIXELSIZE / 2;
			*pfxXOffset &= ~(FNT_PIXELSIZE - 1);
#ifdef FSCFG_SUBPIXEL
		}
#endif
#ifdef FSCFG_SUBPIXEL
		if (RunningSubPixel(globalGS) && ((rotationParity == arbitraryRotation) || ((rotationParity == evenMult90DRotation) == VerticalSPDirection(globalGS)))) {
			*pfxYOffset += VIRTUAL_PIXELSIZE_RTG / 2;
			*pfxYOffset &= ~(VIRTUAL_PIXELSIZE_RTG - 1);
		} else {
#endif
			*pfxYOffset += FNT_PIXELSIZE / 2;
			*pfxYOffset &= ~(FNT_PIXELSIZE - 1);
#ifdef FSCFG_SUBPIXEL
		}
#endif
	}
	if (!bSameTransformAsMaster)
	/* we need to scale back the offset in fixed FUnits */
	{
		scl_ScaleBack (&globalGS->scaleXChild,
				globalGS->ScaleFuncXChild,
				pfxXOffset,
				pfxXOffset,
				1 /* only one value to scale */);
		scl_ScaleBack (&globalGS->scaleYChild,
				globalGS->ScaleFuncYChild,
				pfxYOffset,
				pfxYOffset,
				1 /* only one value to scale */);
	}
}

FS_PUBLIC void  scl_CalcComponentAnchorOffset(
	fnt_ElementType *   pParentElement,     /* Parent Element       */
	uint16              usAnchorPoint1,     /* Parent Anchor Point  */
	fnt_ElementType *   pChildElement,      /* Child Element        */
	uint16              usAnchorPoint2,     /* Child Anchor Point   */
	F26Dot6 *           pfxXOffset,         /* OUT: X Offset        */
	F26Dot6 *           pfxYOffset)         /* Y Offset             */
{
	*pfxXOffset = pParentElement->x[usAnchorPoint1] - pChildElement->x[usAnchorPoint2];
	*pfxYOffset = pParentElement->y[usAnchorPoint1] - pChildElement->y[usAnchorPoint2];
}



FS_PUBLIC void  scl_SetSideBearingPoints(
	fnt_ElementType *   pElement,   /* Element                  */
	point *             pptLSB,     /* Left Side Bearing point  */
	point *             pptRSB)     /* Right Side Bearing point */
{
	uint16    usPhantomPointNumber;

	usPhantomPointNumber = LSBPOINTNUM(pElement);
	pElement->x[usPhantomPointNumber] = pptLSB->x;
	pElement->y[usPhantomPointNumber] = pptLSB->y;
	usPhantomPointNumber++;
	pElement->x[usPhantomPointNumber] = pptRSB->x;
	pElement->y[usPhantomPointNumber] = pptRSB->y;
}

FS_PUBLIC void  scl_SaveSideBearingPoints(
	fnt_ElementType *   pElement,   /* Element                  */
	point *             pptLSB,     /* Left Side Bearing point  */
	point *             pptRSB)     /* Right Side Bearing point */
{
	uint16    usPhantomPointNumber;

	usPhantomPointNumber = LSBPOINTNUM(pElement);
	pptLSB->x = pElement->x[usPhantomPointNumber];
	pptLSB->y = pElement->y[usPhantomPointNumber];
	usPhantomPointNumber++;
	pptRSB->x = pElement->x[usPhantomPointNumber];
	pptRSB->y = pElement->y[usPhantomPointNumber];
}

FS_PUBLIC void  scl_InitializeTwilightContours(
	fnt_ElementType *   pElement,       /* Element  */
	int16               sMaxPoints,
	int16               sMaxContours)
{
	pElement->sp[0] = 0;
	pElement->ep[0] = sMaxPoints - 1;
	pElement->nc = sMaxContours;
}

FS_PUBLIC void  scl_ZeroOutlineData(
	fnt_ElementType * pElement,     /* Element pointer  */
	uint16      usNumberOfPoints,
	uint16      usNumberOfContours)
{

	MEMSET (&pElement->x[0], 0, (size_t)usNumberOfPoints * sizeof(F26Dot6));
	MEMSET (&pElement->ox[0], 0, (size_t)usNumberOfPoints * sizeof(F26Dot6));
	MEMSET (&pElement->oox[0], 0, (size_t)usNumberOfPoints * sizeof(F26Dot6));

	MEMSET (&pElement->y[0], 0, (size_t)usNumberOfPoints * sizeof(F26Dot6));
	MEMSET (&pElement->oy[0], 0, (size_t)usNumberOfPoints * sizeof(F26Dot6));
	MEMSET (&pElement->ooy[0], 0, (size_t)usNumberOfPoints * sizeof(F26Dot6));

	MEMSET (&pElement->onCurve[0], 0, (size_t)usNumberOfPoints * sizeof(uint8));
	MEMSET (&pElement->f[0], 0, (size_t)usNumberOfPoints * sizeof(uint8));

	MEMSET (&pElement->sp[0], 0, (size_t)usNumberOfContours * sizeof(int16));
	MEMSET (&pElement->ep[0], 0, (size_t)usNumberOfContours * sizeof(int16));
}

FS_PUBLIC void scl_ZeroOutlineFlags(
	fnt_ElementType * pElement)     /* Element pointer  */
{
	MEMSET (&pElement->f[0], 0, (size_t)NUMBEROFTOTALPOINTS(pElement) * sizeof(uint8));
}

FS_PUBLIC void  scl_IncrementChildElement(
	fnt_ElementType * pChildElement,    /* Child Element pointer    */
	fnt_ElementType * pParentElement)   /* Parent Element pointer   */
{
	uint16          usParentNewStartPoint;

	if(pParentElement->nc != 0)
	{
		usParentNewStartPoint = LSBPOINTNUM(pParentElement);

		pChildElement->x = &pParentElement->x[usParentNewStartPoint];
		pChildElement->y = &pParentElement->y[usParentNewStartPoint];

		pChildElement->ox = &pParentElement->ox[usParentNewStartPoint];
		pChildElement->oy = &pParentElement->oy[usParentNewStartPoint];

		pChildElement->oox = &pParentElement->oox[usParentNewStartPoint];
		pChildElement->ooy = &pParentElement->ooy[usParentNewStartPoint];

		pChildElement->onCurve = &pParentElement->onCurve[usParentNewStartPoint];
		pChildElement->f = &pParentElement->f[usParentNewStartPoint];

		pChildElement->fc = &pParentElement->fc[pParentElement->nc];

#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
		pChildElement->pcr = &pParentElement->pcr[usParentNewStartPoint];
#endif

		pChildElement->sp = &pParentElement->sp[pParentElement->nc];
		pChildElement->ep = &pParentElement->ep[pParentElement->nc];

		pChildElement->nc = 0;
	}
	else
	{
		MEMCPY(pChildElement, pParentElement, sizeof(fnt_ElementType));
	}
}

FS_PUBLIC void  scl_UpdateParentElement(
	fnt_ElementType * pChildElement,    /* Child Element pointer    */
	fnt_ElementType * pParentElement)   /* Parent Element pointer   */
{
	uint16          usNumberOfParentPoints;
	uint32          ulPointIndex;

	if(pParentElement->nc != 0)
	{
		usNumberOfParentPoints = NUMBEROFCHARPOINTS(pParentElement);

		for(ulPointIndex = (uint32)(uint16)pParentElement->nc;
			ulPointIndex < (uint32)(uint16)pParentElement->nc + (uint32)(uint16)pChildElement->nc;
			ulPointIndex++)
		{
			pParentElement->sp[ulPointIndex] += (int16)usNumberOfParentPoints;
			pParentElement->ep[ulPointIndex] += (int16)usNumberOfParentPoints;
		}
	}

	pParentElement->nc += pChildElement->nc;
}

FS_PUBLIC uint32      scl_GetContourDataSize (
	 fnt_ElementType *  pElement)
{
	 uint16 usNumberOfPoints;
	 uint32 ulSize;

	 usNumberOfPoints = NUMBEROFCHARPOINTS(pElement);

	 ulSize =  sizeof( pElement->nc );
	 ulSize += sizeof( *pElement->sp ) * (size_t)pElement->nc;
	 ulSize += sizeof( *pElement->ep ) * (size_t)pElement->nc;
	 ulSize += sizeof( *pElement->x ) * (size_t)usNumberOfPoints;
	 ulSize += sizeof( *pElement->y ) * (size_t)usNumberOfPoints;
	 ulSize += sizeof( *pElement->onCurve ) * (size_t)usNumberOfPoints;

	 return( ulSize );
}

FS_PUBLIC void  scl_DumpContourData(
	 fnt_ElementType *  pElement,
	 uint8 **               ppbyOutline)
{
	 uint16 usNumberOfPoints;

	 usNumberOfPoints = NUMBEROFCHARPOINTS(pElement);

	 *((int16 *)*ppbyOutline) = pElement->nc;
	 *ppbyOutline += sizeof( pElement->nc   );

	 MEMCPY(*ppbyOutline, pElement->sp, (size_t)pElement->nc * sizeof( *pElement->sp ));
	 *ppbyOutline += (size_t)pElement->nc * sizeof( *pElement->sp );

	 MEMCPY(*ppbyOutline, pElement->ep, (size_t)pElement->nc * sizeof( *pElement->ep ));
	 *ppbyOutline += (size_t)pElement->nc * sizeof( *pElement->sp );

	 MEMCPY(*ppbyOutline, pElement->x, (size_t)usNumberOfPoints * sizeof(*pElement->x));
	 *ppbyOutline += (size_t)usNumberOfPoints * sizeof( *pElement->x );

	 MEMCPY(*ppbyOutline, pElement->y, (size_t)usNumberOfPoints * sizeof(*pElement->y));
	 *ppbyOutline += (size_t)usNumberOfPoints * sizeof( *pElement->y );

	 MEMCPY(*ppbyOutline, pElement->onCurve, (size_t)usNumberOfPoints * sizeof(*pElement->onCurve));
	 *ppbyOutline += (size_t)usNumberOfPoints * sizeof( *pElement->onCurve );

}

FS_PUBLIC void  scl_RestoreContourData(
	 fnt_ElementType *  pElement,
	 uint8 **               ppbyOutline)
{
	 uint16 usNumberOfPoints;

	 pElement->nc = *((int16 *)(*ppbyOutline));
	 *ppbyOutline += sizeof( int16 );

	 pElement->sp = (int16 *)(*ppbyOutline);
	 *ppbyOutline += (size_t)pElement->nc * sizeof( int16 );

	 pElement->ep = (int16 *)(*ppbyOutline);
	 *ppbyOutline += (size_t)pElement->nc * sizeof( int16 );

	 usNumberOfPoints = NUMBEROFCHARPOINTS(pElement);

	 pElement->x = (F26Dot6 *)(*ppbyOutline);
	 *ppbyOutline += (size_t)usNumberOfPoints * sizeof( F26Dot6 );

	 pElement->y = (F26Dot6 *)(*ppbyOutline);
	 *ppbyOutline += (size_t)usNumberOfPoints * sizeof( F26Dot6 );

	 pElement->onCurve = (uint8 *)(*ppbyOutline);
	 *ppbyOutline += (size_t)usNumberOfPoints * sizeof( uint8 );
}

FS_PUBLIC void  scl_ScaleAdvanceWidth (
	void *          pvGlobalGS,         /* GlobalGS             */
	vectorType *    AdvanceWidth,
	uint16          usNonScaledAW,
	 boolean          bPositiveSquare,
	uint16          usEmResolution,
	transMatrix *   trans)

{
	fnt_GlobalGraphicStateType *    globalGS;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	 if ( bPositiveSquare )
	{
		AdvanceWidth->x = (Fixed)ShortMulDiv( (int32)globalGS->fxMetricScalarX, (int16)usNonScaledAW, (int16)usEmResolution );
        if (AdvanceWidth->x != 0 /* B.St. */ && globalGS->uBoldSimulHorShift != 0 /* B.St. */) /* we don't increase the width of a zero width glyph, problem with indic script */
		    AdvanceWidth->x += ((Fixed)1 << 16); /* we increase the widht by one pixel regardless of size for backwards compatibility */
	}
	else
	{
		AdvanceWidth->x = FixRatio( (int16)usNonScaledAW, (int16)usEmResolution );
        if ((globalGS->fxMetricScalarX != ONEFIX) && (globalGS->uBoldSimulHorShift != 0))
        {
            AdvanceWidth->x = FixMul(AdvanceWidth->x, globalGS->fxMetricScalarX);
            if (AdvanceWidth->x != 0 /* B.St. */ && globalGS->uBoldSimulHorShift != 0 /* B.St. */) /* we don't increase the width of a zero width glyph, problem with indic script */
		        AdvanceWidth->x += ((Fixed)1 << 16); /* we increase the widht by one pixel regardless of size for backwards compatibility */
            AdvanceWidth->x = FixDiv(AdvanceWidth->x, globalGS->fxMetricScalarX);
        }
        else
        {
            if (AdvanceWidth->x != 0 /* B.St. */ && globalGS->uBoldSimulHorShift != 0 /* B.St. */) /* we don't increase the width of a zero width glyph, problem with indic script */
		        AdvanceWidth->x += ((Fixed)1 << 16); /* we increase the widht by one pixel regardless of size for backwards compatibility */
        }
		mth_FixXYMul( &AdvanceWidth->x, &AdvanceWidth->y, trans );
	}
}

FS_PUBLIC void  scl_ScaleAdvanceHeight (
	void *          pvGlobalGS,         /* GlobalGS             */
	vectorType *    AdvanceHeight,
	uint16          usNonScaledAH,
	 boolean          bPositiveSquare,
	uint16          usEmResolution,
	transMatrix *   trans)

{
	fnt_GlobalGraphicStateType *    globalGS;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	 if ( bPositiveSquare )
	{
		AdvanceHeight->y = (Fixed)ShortMulDiv( (int32)globalGS->fxMetricScalarY, (int16)usNonScaledAH, (int16)usEmResolution );
        if (AdvanceHeight->y != 0) /* we don't increase the width of a zero width glyph, problem with indic script */
		    AdvanceHeight->y += ((Fixed)1 << 16); /* we increase the widht by one pixel regardless of size for backwards compatibility */
	}
	else
	{
		AdvanceHeight->y = FixRatio( (int16)usNonScaledAH, (int16)usEmResolution );
        if (AdvanceHeight->y != 0) /* we don't increase the width of a zero width glyph, problem with indic script */
		    AdvanceHeight->y += ((Fixed)1 << 16); /* we increase the widht by one pixel regardless of size for backwards compatibility */
		mth_FixXYMul( &AdvanceHeight->x, &AdvanceHeight->y, trans );
	}
}

FS_PUBLIC void  scl_ScaleVerticalMetrics (
	void *          pvGlobalGS,
	uint16          usNonScaledAH,
	int16           sNonScaledTSB,
	boolean         bPositiveSquare,
	uint16          usEmResolution,
	transMatrix *   trans,
	vectorType *    pvecAdvanceHeight,
	vectorType *    pvecTopSideBearing
)
{
	fnt_GlobalGraphicStateType *    globalGS;

	if ( bPositiveSquare )
	{
	    globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;
		pvecAdvanceHeight->y = (Fixed)ShortMulDiv(
		    (int32)globalGS->fxMetricScalarY, 
		    (int16)usNonScaledAH, 
		    (int16)usEmResolution );
		
		pvecTopSideBearing->y = (Fixed)ShortMulDiv(
		    (int32)globalGS->fxMetricScalarY, 
		    sNonScaledTSB, 
		    (int16)usEmResolution );
	}
	else
	{
		pvecAdvanceHeight->y = FixRatio( (int16)usNonScaledAH, (int16)usEmResolution );
		mth_FixXYMul( &pvecAdvanceHeight->x, &pvecAdvanceHeight->y, trans );

		pvecTopSideBearing->y = FixRatio( sNonScaledTSB, (int16)usEmResolution );
		mth_FixXYMul( &pvecTopSideBearing->x, &pvecTopSideBearing->y, trans );
	}
}


FS_PUBLIC void  scl_CalcLSBsAndAdvanceWidths(
	fnt_ElementType *   pElement,
	F26Dot6             f26XMin,
	F26Dot6             f26YMax,
	point *             devAdvanceWidth,
	point *             devLeftSideBearing,
	point *             LeftSideBearing,
	point *             devLeftSideBearingLine,
	point *             LeftSideBearingLine)
{
	scl_CalcDevAdvanceWidth(pElement, devAdvanceWidth);

	devLeftSideBearing->x = f26XMin - pElement->x[LSBPOINTNUM(pElement)];
	devLeftSideBearing->y = f26YMax - pElement->y[LSBPOINTNUM(pElement)];

	LeftSideBearing->x = pElement->x[LEFTEDGEPOINTNUM(pElement)];
	LeftSideBearing->x -= pElement->x[ORIGINPOINTNUM(pElement)];
	LeftSideBearing->y = f26YMax - pElement->y[LEFTEDGEPOINTNUM(pElement)];
	LeftSideBearing->y -= pElement->y[ORIGINPOINTNUM(pElement)];

	*devLeftSideBearingLine = *devLeftSideBearing;
	*LeftSideBearingLine = *LeftSideBearing;

}

FS_PUBLIC void  scl_CalcDevAdvanceWidth(
	fnt_ElementType *   pElement,
	point *             devAdvanceWidth)

{
	devAdvanceWidth->x = pElement->x[RSBPOINTNUM(pElement)]; 
	devAdvanceWidth->x -= pElement->x[LSBPOINTNUM(pElement)];
	devAdvanceWidth->y = pElement->y[RSBPOINTNUM(pElement)]; 
	devAdvanceWidth->y -= pElement->y[LSBPOINTNUM(pElement)];
}

FS_PUBLIC void  scl_CalcTSBsAndAdvanceHeights(
	fnt_ElementType *   pElement,
	F26Dot6             f26XMin,
	F26Dot6             f26YMax,
	point *             devAdvanceHeight,
	point *             devTopSideBearing,
	point *             TopSideBearing,
	point *             devTopSideBearingLine,
	point *             TopSideBearingLine)
{
	scl_CalcDevAdvanceHeight(pElement, devAdvanceHeight);

	devTopSideBearing->x = f26XMin - pElement->x[TOPSBPOINTNUM(pElement)];
	devTopSideBearing->y = f26YMax - pElement->y[TOPSBPOINTNUM(pElement)];

	TopSideBearing->x = f26XMin - pElement->x[TOPEDGEPOINTNUM(pElement)];
	TopSideBearing->x -= pElement->x[TOPORIGINPOINTNUM(pElement)];
	TopSideBearing->y = pElement->y[TOPEDGEPOINTNUM(pElement)];
	TopSideBearing->y -= pElement->y[TOPORIGINPOINTNUM(pElement)];

	*devTopSideBearingLine = *devTopSideBearing;
	*TopSideBearingLine = *TopSideBearing;

}

FS_PUBLIC void  scl_CalcDevAdvanceHeight(
	fnt_ElementType *   pElement,
	point *             devAdvanceHeight)

{
	devAdvanceHeight->x = pElement->x[TOPSBPOINTNUM(pElement)]; 
	devAdvanceHeight->x -= pElement->x[BOTTOMSBPOINTNUM(pElement)];
	devAdvanceHeight->y = pElement->y[TOPSBPOINTNUM(pElement)]; 
	devAdvanceHeight->y -= pElement->y[BOTTOMSBPOINTNUM(pElement)];
}


FS_PUBLIC void  scl_QueryPPEM(
	void *      pvGlobalGS,
	uint16 *    pusPPEM)
{
	fnt_GlobalGraphicStateType *    globalGS;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	*pusPPEM = globalGS->pixelsPerEm;
}

/*  Return ppem in X and Y directions for sbits */

FS_PUBLIC void  scl_QueryPPEMXY(
	void *      pvGlobalGS,
	uint16 *    pusPPEMX,
	uint16 *    pusPPEMY)
{
	fnt_GlobalGraphicStateType *    globalGS;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	*pusPPEMX = (uint16)ROUNDFIXTOINT(globalGS->interpScalarX);
	*pusPPEMY = (uint16)ROUNDFIXTOINT(globalGS->interpScalarY);
}


FS_PUBLIC void scl_45DegreePhaseShift (
	fnt_ElementType *   pElement)
{
  F26Dot6 * x;
  int16     count;

  x = pElement->x;
  count = (int16)NUMBEROFCHARPOINTS(pElement) - 1;
  for (; count >= 0; --count)
  {
	(*x)++;
	++x;
  }
}

/*
 *  scl_PostTransformGlyph              <3>
 */
FS_PUBLIC void  scl_PostTransformGlyph (
	void *              pvGlobalGS,         /* GlobalGS             */
	fnt_ElementType *   pElement,
	transMatrix *       trans)
{
	fnt_GlobalGraphicStateType *    globalGS;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	if (globalGS->bHintAtEmSquare)
	{
		mth_IntelMul (
			(int32)NUMBEROFTOTALPOINTS (pElement),
			pElement->x,
			pElement->y,
			trans,
			globalGS->interpScalarX,
			globalGS->interpScalarY); 
	}
	else
	{
		mth_IntelMul (
			(int32)NUMBEROFTOTALPOINTS (pElement),
			pElement->x,
			pElement->y,
			trans,
	/*        globalGS->interpScalarX,
			globalGS->interpScalarY); */
			globalGS->fxMetricScalarX,
			globalGS->fxMetricScalarY);
	}
}

/*
 *  scl_ApplyTranslation              
 */
FS_PUBLIC void  scl_ApplyTranslation (
	fnt_ElementType *   pElement,
	transMatrix *       trans,
	boolean             bUseHints,
	boolean             bHintAtEmSquare
#ifdef FSCFG_SUBPIXEL
	,boolean             bSubPixel
#endif // FSCFG_SUBPIXEL
   )
{
	int32 ulPointIndex;
	F26Dot6 xShift, yShift;

	/* transform from 16.16 to 26.6 */
	xShift = (trans->transform[0][2] + 0x200) >> 10;
	yShift = (trans->transform[1][2] + 0x200) >> 10;

#ifdef FSCFG_SUBPIXEL
	if (bSubPixel)
	{
		xShift = xShift * RGB_OVERSCALE;
    }
#endif

	/* lsb point should be moved to (0,0) so that we can get correct bitmap bounding box when overscaling */
	xShift -= pElement->x[LSBPOINTNUM(pElement)];
	yShift -= pElement->y[LSBPOINTNUM(pElement)];

	
	if (bUseHints && !bHintAtEmSquare) {
#ifdef FSCFG_SUBPIXEL
		if (bSubPixel) {
			/* We want to round to a virtual pixel boundary when hinted */ 
			xShift += VIRTUAL_PIXELSIZE_RTG/2; 
			xShift &= ~(VIRTUAL_PIXELSIZE_RTG - 1); 
		} else {
#endif
			/* We want to round to a pixel boundary when hinted */ 
			xShift += FNT_PIXELSIZE/2; 
			xShift &= ~(FNT_PIXELSIZE - 1); 
#ifdef FSCFG_SUBPIXEL
		}
#endif
	}

	if (xShift != 0 || yShift != 0)
	{
		for(ulPointIndex = 0;
				ulPointIndex < NUMBEROFTOTALPOINTS(pElement);
				ulPointIndex++)
		{
			pElement->x[ulPointIndex] += xShift;
			pElement->y[ulPointIndex] += yShift;
		}
	}

}
/*
 *      scl_LocalPostTransformGlyph                             <3>
 *
 * (1) Inverts the stretch from the CTM
 * (2) Applies the local transformation passed in in the trans parameter
 * (3) Applies the global stretch from the root CTM
 * (4) Restores oox, ooy, oy, ox, and f.
 */
FS_PUBLIC void  scl_LocalPostTransformGlyph(fnt_ElementType * pElement, transMatrix *trans)
{
	int32 lCount;

	lCount = (int32)NUMBEROFTOTALPOINTS(pElement);

	mth_IntelMul (lCount, pElement->x, pElement->y, trans, ONEFIX, ONEFIX);
}

#ifdef FSCFG_SUBPIXEL

FS_PUBLIC void  scl_ScaleDownFromSubPixelOverscale (
	fnt_ElementType *   pElement)   /* Element  */
{
	int32 ulPointIndex;
	for(ulPointIndex = 0;
			ulPointIndex < NUMBEROFTOTALPOINTS(pElement);
			ulPointIndex++)
	{
		pElement->ox[ulPointIndex] = ROUND_RGB_OVERSCALE(pElement->x[ulPointIndex]);
	}
}

FS_PUBLIC void  scl_ScaleToCompatibleWidth (
	fnt_ElementType *   pElement,  /* Element  */
    Fixed   fxCompatibleWidthScale)  
{
	int32 ulPointIndex;

	for(ulPointIndex = 0;
			ulPointIndex < NUMBEROFTOTALPOINTS(pElement);
			ulPointIndex++)
	{
		pElement->x[ulPointIndex] = FixMul(pElement->x[ulPointIndex], fxCompatibleWidthScale);
	}
}


FS_PUBLIC void  scl_AdjustCompatibleMetrics (
	fnt_ElementType *   pElement,  /* Element  */
    F26Dot6   horTranslation,
    F26Dot6   newDevAdvanceWidthX)
{
	int32 ulPointIndex;

	for(ulPointIndex = 0;
			ulPointIndex < NUMBEROFCHARPOINTS(pElement);
			ulPointIndex++)
	{
		pElement->x[ulPointIndex] += horTranslation;
	}
    pElement->x[RSBPOINTNUM(pElement)] = pElement->x[LSBPOINTNUM(pElement)] + newDevAdvanceWidthX;
}


FS_PUBLIC void  scl_CalcDevHorMetrics(
	fnt_ElementType *   pElement,
	F26Dot6 *           pDevAdvanceWidthX,
	F26Dot6 *           pDevLeftSideBearingX,
	F26Dot6 *           pDevRightSideBearingX)
{
	int32 ulPointIndex;
	F26Dot6 fxMaxX;             /* for bounding box left, right */

	*pDevLeftSideBearingX = LONG_MAX;     /* default bounds limits */
	fxMaxX = LONG_MIN;

	*pDevAdvanceWidthX = pElement->x[RSBPOINTNUM(pElement)]; 
	*pDevAdvanceWidthX -= pElement->x[LSBPOINTNUM(pElement)];

	for(ulPointIndex = 0;
			ulPointIndex < NUMBEROFCHARPOINTS(pElement);
			ulPointIndex++)
	{
		if (pElement->x[ulPointIndex] > fxMaxX)
			fxMaxX = pElement->x[ulPointIndex];
		if (pElement->x[ulPointIndex] < *pDevLeftSideBearingX)
			*pDevLeftSideBearingX = pElement->x[ulPointIndex];
	}

    FS_ASSERT(*pDevLeftSideBearingX != LONG_MAX, "scl_CalcDevHorMetrics called on an empty glyph\n");

    *pDevRightSideBearingX = *pDevAdvanceWidthX - fxMaxX;

}

FS_PUBLIC void  scl_CalcDevNatHorMetrics(
	fnt_ElementType *   pElement,
	F26Dot6 *           pDevAdvanceWidthX,
	F26Dot6 *           pDevLeftSideBearingX,
	F26Dot6 *           pDevRightSideBearingX,
	F26Dot6 *           pNatAdvanceWidthX,
	F26Dot6 *           pNatLeftSideBearingX,
	F26Dot6 *           pNatRightSideBearingX)
{
	int32 ulPointIndex;

	*pDevLeftSideBearingX = LONG_MAX; *pDevRightSideBearingX = LONG_MIN;
	*pNatLeftSideBearingX = LONG_MAX; *pNatRightSideBearingX = LONG_MIN;
	
	*pDevAdvanceWidthX = pElement->x[RSBPOINTNUM(pElement)]  - pElement->x[LSBPOINTNUM(pElement)];
	*pNatAdvanceWidthX = pElement->ox[RSBPOINTNUM(pElement)] - pElement->ox[LSBPOINTNUM(pElement)];

	for(ulPointIndex = 0; ulPointIndex < NUMBEROFCHARPOINTS(pElement); ulPointIndex++) {
		if (pElement->x[ulPointIndex]  > *pDevRightSideBearingX) *pDevRightSideBearingX = pElement->x[ulPointIndex];
		if (pElement->x[ulPointIndex]  < *pDevLeftSideBearingX)  *pDevLeftSideBearingX  = pElement->x[ulPointIndex];
		if (pElement->ox[ulPointIndex] > *pNatRightSideBearingX) *pNatRightSideBearingX = pElement->ox[ulPointIndex];
		if (pElement->ox[ulPointIndex] < *pNatLeftSideBearingX)  *pNatLeftSideBearingX  = pElement->ox[ulPointIndex];
	}

    FS_ASSERT(*pDevLeftSideBearingX != LONG_MAX, "scl_CalcDevHorMetrics called on an empty glyph\n");

    *pDevRightSideBearingX = *pDevAdvanceWidthX - *pDevRightSideBearingX;
    *pNatRightSideBearingX = *pNatAdvanceWidthX - *pNatRightSideBearingX;
} // scl_CalcDevNatHorMetrics

#endif // FSCFG_SUBPIXEL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\fondrv\tt\scaler\scale.h ===
/*

	Copyright:  (c) 1992-1999. Microsoft Corporation, all rights reserved.

	Change History (most recent first):

				7/10/99  BeatS	Add support for native SP fonts, vertical RGB
	   <1>     02/21/97    CB   claudebe, scaled component in composite glyphs
	   <1>     12/14/95    CB   add private phantom points for vertical positionning
*/

/* total number of phantom points */

typedef enum { evenMult90DRotation = 0, oddMult90DRotation, arbitraryRotation } RotationParity;

#define PHANTOMCOUNT 8

FS_PUBLIC ErrorCode   scl_InitializeScaling(
	void *          pvGlobalGS,             /* GlobalGS                 */
	boolean         bIntegerScaling,        /* Integer Scaling Flag     */
	transMatrix *   trans,                  /* Current Transformation   */
	uint16          usUpem,                 /* Current units per Em     */
	Fixed           fxPointSize,            /* Current point size       */
	int16           sXResolution,           /* Current X Resolution     */
	int16           sYResolution,           /* Current Y Resolution     */
	uint16          usEmboldWeightx,     /* scaling factor in x between 0 and 40 (20 means 2% fo the height) */
	uint16          usEmboldWeighty,      /* scaling factor in y between 0 and 40 (20 means 2% fo the height) */
	int16           sWinDescender,
	int32           lDescDev,               /* descender in device metric, used for clipping */
	int16 *			psBoldSimulHorShift,   /* shift for emboldening simulation, horizontally */
	int16 *			psBoldSimulVertShift,   /* shift for emboldening simulation, vertically */
	boolean			bHintAtEmSquare,
	uint32 *        pulPixelsPerEm);        /* OUT: Pixels Per Em       */

FS_PUBLIC void scl_InitializeChildScaling(
	void *          pvGlobalGS,             /* GlobalGS                 */
	transMatrix     CurrentTMatrix,                  /* Current Transformation   */
	uint16          usUpem);                 /* Current units per Em     */

FS_PUBLIC void  scl_SetHintFlags(
	void *              pvGlobalGS,
	boolean				bHintForGray
#ifdef FSCFG_SUBPIXEL
	,uint16			flHintForSubPixel
#endif // FSCFG_SUBPIXEL
    );

FS_PUBLIC void  scl_GetCVTPtr(
	void *      pvGlobalGS,
	F26Dot6 **  pfxCVT);

FS_PUBLIC void  scl_ScaleCVT (
	void *      pvGlobalGS,
	F26Dot6 *   pfxCVT);

FS_PUBLIC void  scl_CalcOrigPhantomPoints(
	fnt_ElementType *   pElement,       /* Element                      */
	BBOX *              bbox,           /* Bounding Box                 */
	int16               sNonScaledLSB,  /* Non-scaled Left Side Bearing */
	int16               sNonScaledTSB,  /* Non-scaled Top Side Bearing  */
	uint16              usNonScaledAW,  /* Non-scaled Advance Width     */
	uint16              usNonScaledAH, /* Non-scaled Advance Height    */
	int16               sNonScaledTopOriginX); /* Non-scaled Top Origin X  */

FS_PUBLIC void  scl_ScaleOldCharPoints(
	fnt_ElementType *   pElement,   /* Element  */
	void *              pvGlobalGS);/* GlobalGS */

FS_PUBLIC void  scl_ScaleOldPhantomPoints(
	fnt_ElementType *   pElement,   /* Element  */
	void *              pvGlobalGS);/* GlobalGS */

FS_PUBLIC void  scl_ScaleBackCurrentCharPoints(
	fnt_ElementType *   pElement,   /* Element  */
	void *              pvGlobalGS);/* GlobalGS */

FS_PUBLIC void  scl_ScaleBackCurrentPhantomPoints(
	fnt_ElementType *   pElement,   /* Element  */
	void *              pvGlobalGS);/* GlobalGS */

FS_PUBLIC void  scl_ScaleFixedCurrentCharPoints(
	fnt_ElementType *   pElement,   /* Element  */
	void *              pvGlobalGS);/* GlobalGS */

FS_PUBLIC void  scl_ScaleFixedCurrentPhantomPoints(
	fnt_ElementType *   pElement,   /* Element  */
	void *              pvGlobalGS);/* GlobalGS */

FS_PUBLIC void  scl_OriginalCharPointsToCurrentFixedFUnits(
	fnt_ElementType *   pElement);/* Element */

FS_PUBLIC void  scl_OriginalPhantomPointsToCurrentFixedFUnits(
	fnt_ElementType *   pElement);/* Element */

FS_PUBLIC void  scl_AdjustOldCharSideBearing(
	fnt_ElementType* pElement
#ifdef FSCFG_SUBPIXEL
	, void* pvGlobalGS
#endif
	);  /* Element  */

FS_PUBLIC void  scl_AdjustOldPhantomSideBearing(
	fnt_ElementType* pElement
#ifdef FSCFG_SUBPIXEL
	, void* pvGlobalGS
#endif
	);  /* Element  */

FS_PUBLIC void  scl_AdjustOldSideBearingPoints(
	fnt_ElementType* pElement
#ifdef FSCFG_SUBPIXEL
	, void* pvGlobalGS
#endif
	);  /* Element  */

FS_PUBLIC void  scl_CopyOldCharPoints(
	fnt_ElementType *           pElement);  /* Element  */

FS_PUBLIC void  scl_CopyCurrentCharPoints(
	fnt_ElementType *           pElement);  /* Element  */

FS_PUBLIC void  scl_CopyCurrentPhantomPoints(
	fnt_ElementType *           pElement);  /* Element  */

FS_PUBLIC void  scl_RoundCurrentSideBearingPnt(
	fnt_ElementType *   pElement,   /* Element  */
	void *              pvGlobalGS, /* GlobalGS */
	uint16              usEmResolution);

FS_PUBLIC void  scl_CalcComponentOffset(
	void *      pvGlobalGS,         /* GlobalGS             */
	int16       sXOffset,           /* IN: X Offset         */
	int16       sYOffset,           /* Y Offset             */
	boolean     bRounding,          /* Rounding Indicator   */
	boolean		bSameTransformAsMaster, /* local transf. same as master transf. */
	boolean     bScaleCompositeOffset,  /* does the component offset need to be scaled Apple/MS */
	transMatrix mulT,                   /* Transformation matrix for composite              */
#ifdef FSCFG_SUBPIXEL
	RotationParity	rotationParityParity,
#endif
	F26Dot6 *   pfxXOffset,         /* OUT: X Offset        */
	F26Dot6 *   pfxYOffset);        /* Y Offset             */

FS_PUBLIC void  scl_CalcComponentAnchorOffset(
	fnt_ElementType *   pParentElement,     /* Parent Element       */
	uint16              usAnchorPoint1,     /* Parent Anchor Point  */
	fnt_ElementType *   pChildElement,      /* Child Element        */
	uint16              usAnchorPoint2,     /* Child Anchor Point   */
	F26Dot6 *           pfxXOffset,         /* OUT: X Offset        */
	F26Dot6 *           pfxYOffset);        /* Y Offset             */


FS_PUBLIC void scl_ShiftCurrentCharPoints (
	fnt_ElementType *   pElement,
	F26Dot6             xShift,
	F26Dot6             yShift);

FS_PUBLIC void  scl_SetSideBearingPoints(
	fnt_ElementType *   pElement,   /* Element                  */
	point *             pptLSB,     /* Left Side Bearing point  */
	point *             pptRSB);    /* Right Side Bearing point */

FS_PUBLIC void  scl_SaveSideBearingPoints(
	fnt_ElementType *   pElement,   /* Element                  */
	point *             pptLSB,     /* Left Side Bearing point  */
	point *             pptRSB);    /* Right Side Bearing point */

FS_PUBLIC void  scl_InitializeTwilightContours(
	fnt_ElementType *   pElement,
	int16               sMaxPoints,
	int16               sMaxContours);

FS_PUBLIC void  scl_ZeroOutlineData(
	fnt_ElementType *   pElement,           /* Element              */
	uint16              usNumberOfPoints,   /* Number of Points     */
	uint16              usNumberOfContours);/* Number of Contours   */

FS_PUBLIC void scl_ZeroOutlineFlags(
	fnt_ElementType * pElement);            /* Element pointer  */

FS_PUBLIC void  scl_IncrementChildElement(
	fnt_ElementType * pChildElement,    /* Child Element pointer    */
	fnt_ElementType * pParentElement);  /* Parent Element pointer   */

FS_PUBLIC void  scl_UpdateParentElement(
	fnt_ElementType * pChildElement,    /* Child Element pointer    */
	fnt_ElementType * pParentElement);  /* Parent Element pointer   */

FS_PUBLIC uint32      scl_GetContourDataSize (
	 fnt_ElementType *  pElement);

FS_PUBLIC void  scl_DumpContourData(
	 fnt_ElementType *  pElement,
	 uint8 **               pbyOutline);

FS_PUBLIC void  scl_RestoreContourData(
	 fnt_ElementType *  pElement,
	 uint8 **               ppbyOutline);

FS_PUBLIC void  scl_ScaleAdvanceWidth (
	void *          pvGlobalGS,         /* GlobalGS             */
	vectorType *    AdvanceWidth,
	uint16          usNonScaledAW,
	 boolean          bPositiveSquare,
	uint16          usEmResolution,
	transMatrix *   trans);

FS_PUBLIC void  scl_ScaleAdvanceHeight (
	void *          pvGlobalGS,         /* GlobalGS             */
	vectorType *    AdvanceHeight,
	uint16          usNonScaledAH,
	 boolean          bPositiveSquare,
	uint16          usEmResolution,
	transMatrix *   trans);

FS_PUBLIC void  scl_ScaleVerticalMetrics (
	void *          pvGlobalGS,
	uint16          usNonScaledAH,
	int16           sNonScaledTSB,
	boolean         bPositiveSquare,
	uint16          usEmResolution,
	transMatrix *   trans,
	vectorType *    pvecAdvanceHeight,
	vectorType *    pvecTopSideBearing);

FS_PUBLIC void  scl_CalcLSBsAndAdvanceWidths(
	fnt_ElementType *   pElement,
	F26Dot6             f26XMin,
	F26Dot6             f26YMax,
	point *             devAdvanceWidth,
	point *             devLeftSideBearing,
	point *             LeftSideBearing,
	point *             devLeftSideBearingLine,
	point *             LeftSideBearingLine);

FS_PUBLIC void  scl_CalcTSBsAndAdvanceHeights(
	fnt_ElementType *   pElement,
	F26Dot6             f26XMin,
	F26Dot6             f26YMax,
	point *             devAdvanceHeight,
	point *             devTopSideBearing,
	point *             TopSideBearing,
	point *             devTopSideBearingLine,
	point *             TopSideBearingLine);

FS_PUBLIC void  scl_CalcDevAdvanceWidth(
	fnt_ElementType *   pElement,
	point *             devAdvanceWidth);

FS_PUBLIC void  scl_CalcDevAdvanceHeight(
	fnt_ElementType *   pElement,
	point *             devAdvanceHeight);

FS_PUBLIC void  scl_QueryPPEM(
	void *      pvGlobalGS,
	uint16 *    pusPPEM);

FS_PUBLIC void  scl_QueryPPEMXY(
	void *      pvGlobalGS,
	uint16 *    pusPPEMX,
	uint16 *    pusPPEMY);

FS_PUBLIC void scl_45DegreePhaseShift (
	fnt_ElementType *   pElement);

FS_PUBLIC void  scl_PostTransformGlyph (
	void *              pvGlobalGS,         /* GlobalGS             */
	fnt_ElementType *   pElement,
	transMatrix *       trans);

FS_PUBLIC void  scl_ApplyTranslation (
	fnt_ElementType *   pElement,
	transMatrix *       trans,
	boolean             bUseHints,
	boolean             bHintAtEmSquare
#ifdef FSCFG_SUBPIXEL
	,boolean             bSubPixel
#endif // FSCFG_SUBPIXEL
    );

FS_PUBLIC void  scl_LocalPostTransformGlyph(fnt_ElementType * pElement, transMatrix *trans);

#ifdef FSCFG_SUBPIXEL
FS_PUBLIC void  scl_ScaleDownFromSubPixelOverscale (
	fnt_ElementType *   pElement);   /* Element  */

FS_PUBLIC void  scl_ScaleToCompatibleWidth (
	fnt_ElementType *   pElement,  /* Element  */
    Fixed   fxCompatibleWidthScale);  

FS_PUBLIC void  scl_AdjustCompatibleMetrics (
	fnt_ElementType *   pElement,  /* Element  */
    F26Dot6   horTranslation,
    F26Dot6   newDevAdvanceWidthX);  

FS_PUBLIC void  scl_CalcDevHorMetrics(
	fnt_ElementType *   pElement,
	F26Dot6 *           pDevAdvanceWidthX,
	F26Dot6 *           pDevLeftSideBearingX,
	F26Dot6 *           pDevRightSideBearingX);

FS_PUBLIC void  scl_CalcDevNatHorMetrics(
	fnt_ElementType *   pElement,
	F26Dot6 *           pDevAdvanceWidthX,
	F26Dot6 *           pDevLeftSideBearingX,
	F26Dot6 *           pDevRightSideBearingX,
	F26Dot6 *           pNatAdvanceWidthX,
	F26Dot6 *           pNatLeftSideBearingX,
	F26Dot6 *           pNatRightSideBearingX);

#endif // FSCFG_SUBPIXEL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\fondrv\tt\scaler\scbitmap.c ===
/*********************************************************************

      scbitmap.c -- New Scan Converter BitMap Module

      (c) Copyright 1992  Microsoft Corp.  All rights reserved.

      10/03/93  deanb   use (x) in bitmask shift macros
       8/23/93  deanb   gray scale functions
       6/11/93  deanb   use MEMSET macro, string & stddef removed
       6/10/93  deanb   Start/Stop/Bit mask macros
       6/10/93  deanb   InitializeBitMasks added, stdio & assert removed
       4/29/93  deanb   BLTCopy routine added
       3/19/93  deanb   size_t caste checked
      10/14/92  deanb   memset for fsc_ClearBitMap
       9/15/92  deanb   Set bit coded 
       8/18/92  deanb   include scconst.h 
       6/02/92  deanb   Row pointer, integer limits, no descriptor 
       5/08/92  deanb   reordered includes for precompiled headers 
       5/04/92  deanb   Array tags added 
       4/27/92  deanb   Negative runs handled 
       4/16/92  deanb   Coding 
       3/23/92  deanb   First cut 

**********************************************************************/

#define FSCFG_INTERNAL

/*********************************************************************/

/*      Imports                                                      */

/*********************************************************************/


#include    "fscdefs.h"             /* shared data types */
#include    "scgray.h"              /* gray scale param block */
#include    "fserror.h"             /* error codes */
#include    "scbitmap.h"            /* for own function prototypes */


/*********************************************************************/

/*      Constants                                                    */

/*********************************************************************/

#define     MASKSIZE    32              /* bits per bitmap masks */
#define     MASKSHIFT   5               /* log2 of MASKSIZE */
#define     MASKBITS    0x0000001FL     /* masks pix loc of long word */

#define     ALL_ONES    ((uint32)0xFFFFFFFFL)
#define     HIGH_ONE    ((uint32)0x80000000L)


/*********************************************************************/

/*      Bitmask definitions                                          */

/*********************************************************************/
    
#ifndef FSCFG_USE_MASK_SHIFT    /* if using bitmask tables */

#define START_MASK(x)   aulStartBits[x]
#define STOP_MASK(x)    aulStopBits[x]
#define BIT_MASK(x)     aulBitMask[x]

/*  bitmask tables */

FS_PRIVATE uint32 aulStartBits[MASKSIZE];       /* such as:  0000111 */
FS_PRIVATE uint32 aulStopBits[MASKSIZE];        /* such as:  1110000 */
FS_PRIVATE uint32 aulBitMask[MASKSIZE];         /* such as:  0001000 */


#else                           /* if using bitmask shift */

#define START_MASK(x)   (ALL_ONES >> (x))
#define STOP_MASK(x)    (ALL_ONES << ((MASKSIZE - 1) - (x)))
#define BIT_MASK(x)     (HIGH_ONE >> (x))

#endif


/*********************************************************************/

/*      Export Functions                                             */

/*********************************************************************/

/*      fsc_InitializeBitMasks() loads the arrays of 32-bit masks at 
 *      runtime to create CPU independent bitmap masks.
 *
 *      It is conditionally compiled because the arrays are unused
 *      in a "USE_MASK_SHIFT" (e.g. Apple, HP) configuration. 
 *
 *      We load the arrays by converting the Big-Endian value of
 *      the mask to the "native" representation of that mask.  The
 *      "native" representation can be applied to a "native" byte
 *      array to manipulate more than 8 bits at a time of an output
 *      bitmap.
 */

FS_PUBLIC void fsc_InitializeBitMasks (void)
{
#ifndef FSCFG_USE_MASK_SHIFT

    int32 lIdx;
    uint32 ulStartMask;
    uint32 ulStopMask;
    uint32 ulBitMask;

    ulStartMask = ALL_ONES;
    ulStopMask = ALL_ONES;
    ulBitMask = HIGH_ONE;
    
    for (lIdx = 0; lIdx < MASKSIZE; lIdx++)
    {
        aulStartBits[lIdx] = (uint32) SWAPL(ulStartMask);
        aulStopBits[MASKSIZE - lIdx - 1] = (uint32) SWAPL(ulStopMask);
        aulBitMask[lIdx] = (uint32) SWAPL(ulBitMask);

        ulStartMask >>= 1;
        ulStopMask <<= 1;
        ulBitMask >>= 1;
    }
#endif
}


/*********************************************************************/

FS_PUBLIC int32 fsc_ClearBitMap (
        uint32 ulBMPLongs, 
        uint32 *pulMap )
{
    size_t stBytes;

    stBytes = (size_t)ulBMPLongs << 2;

    Assert((uint32)stBytes == (ulBMPLongs << 2));

    MEMSET((void*)pulMap, 0, stBytes);
    
    return NO_ERR;
}


/*********************************************************************/

FS_PUBLIC int32 fsc_BLTHoriz (
        int32 lXStart, 
        int32 lXStop, 
        uint32 *pulMap )                 
{
    int32 lSkip;

    lSkip = (lXStart >> MASKSHIFT);         /* longwords to first black */
    pulMap += lSkip;
    lXStart -= lSkip << MASKSHIFT;          /* correct start/stop */
    lXStop -= lSkip << MASKSHIFT;
    while (lXStop >= MASKSIZE)
    {
        *pulMap |= START_MASK(lXStart);
        pulMap++;
        lXStart = 0;
        lXStop -= MASKSIZE;
    }
    *pulMap |= START_MASK(lXStart) & STOP_MASK(lXStop);
    return NO_ERR;
}


/*********************************************************************/

FS_PUBLIC int32 fsc_BLTCopy ( 
        uint32 *pulSource,         /* source row pointer */
        uint32 *pulDestination,    /* destination row pointer */
        int32 lCount )             /* long word counter */
{
    while (lCount)
    {
        *pulDestination = *pulSource;
        pulDestination++;
        pulSource++;
        lCount--;
    }
    return NO_ERR;
}


/*********************************************************************/

FS_PUBLIC uint32 fsc_GetBit( 
        int32 lXCoord,              /* x coordinate */
        uint32* pulMap )            /* bit map row pointer */
{
    return(pulMap[lXCoord >> MASKSHIFT] & BIT_MASK(lXCoord & MASKBITS));
}


/*********************************************************************/

FS_PUBLIC int32 fsc_SetBit( 
        int32 lXCoord,              /* x coordinate */
        uint32* pulMap )            /* bit map row pointer */
{
    pulMap[lXCoord >> MASKSHIFT] |= BIT_MASK(lXCoord & MASKBITS);
    
    return NO_ERR;
}


/*********************************************************************/

/*  Gray scale row bitmap calculation                                */
/*  Count one row of over scale pixels into gray scale row           */

/*********************************************************************/
                
FS_PUBLIC int32 fsc_CalcGrayRow(
        GrayScaleParam* pGSP
)
{            
    char        *pchOver;               /* pointer to overscaled bitmap */
    char        *pchGray;               /* pointer to gray scale bitmap */
    uint16      usShiftMask;            /* masks off over scaled bits of interest */
    uint16      usGoodBits;             /* number of valid bits in usOverBits */
    uint16      usOverBits;             /* a byte of overscaled bitmap */
    int16       sGrayColumns;           /* number of gray columns to calc */
    
    static char chCount[256] = {        /* count of one bits */    
        0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
        1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
        1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
        1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
        3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8
    };


    pchGray = pGSP->pchGray;
    pchOver = pGSP->pchOver;
    sGrayColumns = pGSP->sGrayCol;
    usShiftMask = 0x00FF >> (8 - pGSP->usOverScale);  /* over bits per gray pix */
    usGoodBits = 8 - pGSP->usFirstShift;
    usOverBits = ((uint16)*pchOver) >> pGSP->usFirstShift;
                
    Assert (pchGray >= pGSP->pchGrayLo);
    Assert (pchGray < pGSP->pchGrayHi);
    
    *pchGray += chCount[usOverBits & usShiftMask];
    pchGray--;                              /* move backwards through both bitmaps! */
    sGrayColumns--;

    while (sGrayColumns > 0)                /* for each gray column (after 1st) */
    {
        usGoodBits -= pGSP->usOverScale;
        if (usGoodBits > 0)                 /* if bits remain in over byte */
        {
            usOverBits >>= pGSP->usOverScale;
        }
        else                                /* if we've looked at everything */
        {
            pchOver--;

            Assert (pchOver >= pGSP->pchOverLo);
            Assert (pchOver < pGSP->pchOverHi);

            usOverBits = (uint16)*pchOver;
            usGoodBits = 8;
        }

        Assert (pchGray >= pGSP->pchGrayLo);
        Assert (pchGray < pGSP->pchGrayHi);

        *pchGray += chCount[usOverBits & usShiftMask];  /* accumulate count */
        pchGray--;
        sGrayColumns--;
    }
    return NO_ERR;
}

/*********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\fondrv\tt\scaler\scanlist.h ===
/*********************************************************************

	  scanlist.h -- ScanList Module Exports

	  (c) Copyright 1992  Microsoft Corp.  All rights reserved.

	   8/23/93  deanb   gray scale pass through functions
	   6/10/93  deanb   fsc_InitializeScanlist added
	  12/22/92  deanb   Rectangle -> Rect
	  10/28/92  deanb   uiRowBytes moved from setup to fillbitmap
	  10/09/92  deanb   PSTP added
	  10/08/92  deanb   reworked for split workspace
	   9/25/92  deanb   separate entry for nodrop/dropout 
	   9/10/92  deanb   horiz & vert callbacks 
	   9/09/92  deanb   size_t changes 
	   9/08/92  deanb   SetElemGlobals added 
	   6/18/92  deanb   int x coord for HorizScanAdd 
	   6/01/92  deanb   New/Old FillBitMap for debug comparisons 
	   4/21/92  deanb   Single HorizScan with flag 
	   4/13/92  deanb   unsigned int to int for HorizScanOn/Off 
	   3/31/92  deanb   InitScanArray Rectangle param 
	   3/23/92  deanb   GetWorkSize added 
	   3/16/92  deanb   New types 
	   1/31/92  deanb   HorizScan[On/Off] export functions 
	   1/14/92  deanb   First cut 

**********************************************************************/

#include "fscdefs.h"                /* for type definitions */
#include "scgray.h"                 /* for gray param definition */


typedef struct RevRoots *PRevRoot;  /* opaque type */


/*********************************************************************/

/*              Export Functions                                     */

/*********************************************************************/


FS_PUBLIC void fsc_InitializeScanlist (
		void
);

FS_PUBLIC PRevRoot fsc_SetupRevRoots (
		char*,                      /* reversal list buffer space */
		int32                       /* size of buffer space */
);

FS_PUBLIC void fsc_AddYReversal (
		PRevRoot,                   /* pointer to reversal roots */
		F26Dot6,                    /* reversal coordinate */
		int16                       /* +1 / -1 reversal value */
);

FS_PUBLIC void fsc_AddXReversal (
		PRevRoot,                   /* pointer to reversal roots */
		F26Dot6,                    /* reversal coordinate */
		int16                       /* +1 / -1 reversal value */
);

FS_PUBLIC int32 fsc_GetReversalCount (
		PRevRoot                    /* pointer to reversal roots */
);

FS_PUBLIC int32 fsc_GetHIxEstimate  (
		PRevRoot                    /* pointer to reversal roots */
);

FS_PUBLIC int32 fsc_GetVIxEstimate (
		PRevRoot                    /* pointer to reversal roots */
);

FS_PUBLIC int32 fsc_GetHIxBandEst  (
		PRevRoot,                   /* pointer to reversal roots */
		Rect*,                      /* bitmap bounding box */
		int32                                /* band width in scan lines */
);

FS_PUBLIC int32 fsc_GetRevMemSize(
		PRevRoot                    /* pointer to reversal roots */
);


/*********************************************************************/

FS_PUBLIC int32 fsc_GetScanHMem( 
		uint16,                     /* scan type */
		int32,                      /* number of horiz scanlines */
		int32                       /* number of horiz intersections */
);

FS_PUBLIC int32 fsc_GetScanVMem( 
		uint16,                     /* scan type */
		int32,                      /* number of vert scanlines */
		int32,                      /* number of vert intersections */
		int32                       /* number of contour element points */
);

/*********************************************************************/

FS_PUBLIC void fsc_SetupCallBacks( 
		PSTATE                      /* pointer to state variables */
		int16,                      /* element code (line, spline, endpoint) */
		F26Dot6 (*)(int32, F26Dot6*, F26Dot6*),   /* horiz callback */
		F26Dot6 (*)(int32, F26Dot6*, F26Dot6*)    /* vert callback */
);

FS_PUBLIC int32 fsc_SetupScan( 
		PSTATE                      /* pointer to state variables */
		Rect*,                      /* bitmap bounding box */
		uint16,                     /* scan type */
		int32,                      /* band scan upper limit */
		int32,                      /* band scan lower limit */
		boolean,                    /* save over scan bitmap row */
		int32,                      /* bytes per bitmap row */
		int32,                      /* estimate of horiz intersections */
		int32,                      /* estimate of vert intersections */
		int32,                      /* estimate of element points */
		PRevRoot                    /* reversal list Roots */ 
);


FS_PUBLIC void fsc_BeginContourScan(
		PSTATE                      /* pointer to state variables */
		uint16,                     /* scan type */
		F26Dot6,                    /* starting point x coordinate */
		F26Dot6                     /* starting point y coordinate */
);


FS_PUBLIC void fsc_BeginElement( 
		PSTATE                      /* pointer to state variables */
		uint16,                     /* type of dropout control */
		int32,                      /* determines scan on/off */   
		int32,                      /* element (line, spline, ep) */
		int32,                      /* number of points to store */
		F26Dot6*,                   /* next x control point(s) */
		F26Dot6*,                   /* next y control point(s) */
		void (**)(PSTATE int32, int32),    /* horiz add scan return */
		void (**)(PSTATE int32, int32)     /* vert add scan return */
);

/*********************************************************************/

FS_PUBLIC int32 fsc_FillBitMap( 
		PSTATE                      /* pointer to state variables */
		char*,                      /* target memory */
		int32,                      /* bitmap upper limit */
		int32,                      /* bitmap lower limit */
		int32,                      /* bitmap bytes per row */
		int32,                      /* original low band row */
		uint16                      /* scan type */
);

/*********************************************************************/

FS_PUBLIC int32 fsc_ScanClearBitMap ( 
		uint32,                     /* longs per bmp */
		uint32*                     /* bitmap ptr caste long */
);

FS_PUBLIC int32 fsc_ScanCalcGrayRow(
		GrayScaleParam*             /* pointer to param block */
);

/*********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\fondrv\tt\scaler\interp.c ===
/*********************************************************************

	  interp.c -- TT Rasterizer Interpreter Module

	  Copyright:  (c) 1987-1990, 1992 by Apple Computer, Inc., all rights reserved.
				  (c) 1989-1999. Microsoft Corporation, all rights reserved.

	   7/10/99  BeatS	 62 Add support for native SP fonts, vertical RGB
	   4/01/99  BeatS	 61 Implement alternative interpretation of TT instructions for SP
	  10/14/97  claudebe 60 ClaudeBe, allowing a trace function to know if in FontProgram
							access to unitialized data
	  04/29/97  claudebe 59 ClaudeBe, catching illegal recursion and infinite loops
	  02/21/97  claudebe 58 ClaudeBe, scaled component in composite glyphs
	   2/05/96  claudebe 57 compfont for itpr_MD, wrong zone pointer
	   2/05/96  claudebe 56 GetInfo return HintForGray information
	   8/12/94  deanb  55   orphan routine CHECK_STATE deleted
	   2/09/94  deanb  54   RASTERIZER_VERSION defined for GETINFO
	  12/17/93  deanb  53   CHECK_POINT zone corrected in MIRP
	  12/08/93  deanb  52   itrp_SCANTYPE enabled for smart dropout control
	   9/15/93  deanb  51   InnerTraceEx double call fixed; iOpCode -> lOpCode
	   7/29/93  deanb  50   ALIGNPTS, SHE fixed; InnerTraceExecute saves first
	   7/12/93  deanb  49   itrp_IllegalInstruction works
	   6/28/93  deanb  48   gbyPushTable made const
	   2/16/93  deanb  47   fxUnRounded set after check single width
	   2/15/93  deanb  46   fall back to MIRPG when using single width
	   2/15/93  deanb  45   vector defaults for FONTPROGRAM, stat back
	   2/12/93  deanb  44   delete stat code
	   2/12/93  deanb  43   cleanup MSIRP & itrp_Execute
	   2/12/93  deanb  42   branch itrp_IP on MovePoint
	   2/11/93  deanb  41   use c8 register calling convetions
	   2/11/93  deanb  40   switch to Microsoft C ver 8
	   2/09/93  deanb  39   skipPushData inline in itrp_IF
	   2/09/93  deanb  38   do fast MIRP's with if statments
	   2/09/93  deanb  37   remove fast MDRPX and MIRPY routines
	   2/09/93  deanb  36   fast MDRPX and MIRPY routines
	   2/08/93  deanb  35   cleanup MIRPs, combine if statments
	   2/08/93  deanb  34   dual rounding with 6 ptr init values
	   2/08/93  deanb  33   IUP inner loop pointer check
	   2/08/93  deanb  32   repair skipPushData for npushw
	   2/05/93  deanb  31   check for fxHintedDelta = 0
	   2/05/93  deanb  30   use roundFuncPtr in fast MIRP's
	   2/05/93  deanb  29   itrp_SWAP done in place
	   2/05/93  deanb  28   fntMirpFunc defined for MIRPG/X/Y
	   2/05/93  deanb  27   iOpCode passed in to all functions
	   2/05/93  deanb  26   use instr ptr for param and return
	   2/04/93  deanb  25   pull oldRange out of itrp_IP loops
	   2/04/93  deanb  24   movePoint check for proj.x/y = 1
	   2/03/93  deanb  23   table driven skipPushData
	   2/03/93  deanb  22   zero based Unary Operand pointers
	   2/01/93  deanb  21   split out SetRoundState
	   2/01/93  deanb  20   eliminate OpCode assignemnt, registers
	   2/01/93  deanb  19   bump Normalize limit up to 0x20000000L
	   1/29/93  deanb  18   add SuperRound MIRPG fallback
	   1/29/93  deanb  17   fast MIRPX and MIRPY routines
	   1/27/93  deanb  16   single rounding routines restored
	   1/27/93  deanb  15   innerExecute tune up
	   1/27/93  deanb  14   rounding routines for engine/no engine
	   1/27/93  deanb  13   repair itrp_Normalize for BIG vectors
	   1/26/93  deanb  12   split out SPVTCA and SFVTCA
	   1/26/93  deanb  11   clean up itrp_IP
	   1/26/93  deanb  10   return IUP to old start/end calc
	   1/25/93  deanb   9   use pointers in IUP loops
	   1/25/93  deanb   8   major rewrite of itrp_IUP
	   1/25/93  deanb   7   rewrite itrp_Normalize
	   1/22/93  deanb   6   split and do Unary Operands in place
	   1/22/93  deanb   5   do Binary Operands in place
	   1/22/93  deanb   4   split out BinaryOperand
	   1/22/93  deanb   3   split out PUSHB1 and PUSHW1
	   1/22/93  deanb   2   split out PushSomeBytes/Words
	   1/22/93  deanb   1   split out SRP0-2, LLOOP, POP
	   1/22/93  deanb   0   STAT card timing added
	   1/22/93  deanb       dead code/comments moved to history.fnt
 
**********************************************************************/

#define FSCFG_INTERNAL

#include "fscdefs.h"
#include "fontmath.h"
#include "sfnt.h"
#include "fnt.h"
#include "interp.h"
#include "fserror.h"

#include "stat.h"                   /* for STAT card timing only */

#include <stdio.h>

#ifdef SEGMENT_LINK
#pragma segment FNT_C
#endif

/* perfect spot size (Fixed) */
#ifndef FIXEDSQRT2
#define FIXEDSQRT2 0x00016A0A
#endif

#ifdef FSCFG_SUBPIXEL
#define RASTERIZER_VERSION  37      /* MS reserved values 33 - 64 */
#else
#define RASTERIZER_VERSION  35      /* MS reserved values 33 - 64 */
#endif // FSCFG_SUBPIXEL
									/* 33 = Rasterizer v1.5 */
									/* 34 = Rasterizer v1.6 */
									/* 35 = Rasterizer v1.7 */
									/* 36 = Rasterizer v1.6+, Windows CE, SubPixel */
									/* 37 = Rasterizer v1.8, Windows XP (NT 5.1), SubPixel */

#ifdef FSCFG_SUBPIXEL
	// the following are 9 switches to avoid all kinds of "hinting techniques" that have adverse effects on SubPixel
	// they should be considered "band-aid" solutions, to avoid us the worst of the worst with existing fonts.
	// in the future, fonts that are optimized for SubPixel should be tagged as such.
	// This will permit to switch these switches off again.
	#define RDTGRoundsDownToGrid		// to avoid not aligning control points when Align translates to MDRP with RDTG preceded by SPVTL
	#define NoVirtRoundInPrep			// to avoid PMingLiU vertically misplacing strokes (vectors not set properly in prep for certain calculations)
	#define RoundOffRespectsCvtCutIn	// to avoid Palatino Italic's fractional grey-scale targetted cvts and unrounded MIRP (little r) which bypasses cvt cut-in
	#define MSIRPRespectsCvtCutIn		// to avoid fonts pre-calculating a distance and subsequently MSIRPing it (neither rounding nor cvt cut-in involved in MSIRP)
	#define InlineDeltasOnly			// to avoid all kinds of bumps, blops, or irregular weight gains
	#define BypassDandIStroke			// to avoid collapsing strokes in (partly) auto-hinted fonts using DStroke and IStroke commands
	#define BypassJellesSpacing			// to avoid bloated characters
	#define BypassVacuformRound			// to avoid diamond shaped characters
	#define AssistTomsDiagonal			// to avoid Georgia italic to become upright

	// values derived from the primary values in fscdefs.h
	#define CVT_CUT_IN_OVERSCALE	VIRTUAL_OVERSCALE	// high value to encourage MIRP to fall back on original distance to avoid stroke weight jumps in size ramp
	#define ENGINE_COMP_OVERSCALE	VISUAL_OVERSCALE	// value not particularly relevant as engine compensation is not currently used
	#define MIN_DIST_OVERSCALE		VISUAL_OVERSCALE	// value not terribly important as it basically affects the minimum stroke weight

	#define Tuned4SubPixel(globalGS) ((uint16)((globalGS)->localParBlock.instructControl & TUNED4SPFLAG))
#else
	#define Tuned4SubPixel(globalGS) (false)
#endif

#define MAX_ELEMENTS 2
#define TWILIGHTZONE 0 /* The point storage */
#define GLYPHELEMENT 1 /* The actual glyph */

/* those constant are used as default to catch illegal fonts */
#define INTERP_MAX_JUMPS			10000
#define INTERP_MAX_RECURSIVE_CALLS	100

#define MAXANGLES       20

#define ROTATEDGLYPH        0x0100
#define STRETCHEDGLYPH      0x0200
/* new Apple 1994 */
#define VARIATIONGLYPH      0x0400
#define VERTICALGLYPH       0x0800
/* new Microsoft 1996 */
#define HINTEDFORGRAYGLYPH  0x1000

#define VERSIONINTERPRETERQUERY          0x0001
#define ROTATEDINTERPRETERQUERY          0x0002
#define STRETCHEDINTERPRETERQUERY        0x0004
/* new Apple 1994 */
#define VARIATIONINTERPRETERQUERY        0x0008
#define VERTICALMETRICSINTERPRETERQUERY  0x0010
/* new Microsoft 1996 */
#define HINTFORGRAYINTERPRETERQUERY      0x0020

/* new Microsoft 1998
   moved out of FSCFG_SUBPIXEL to build debug version for non SP environment */
#define HINTFORSUBPIXELINTERPRETERQUERY						0x0040
#define HINTFORSUBPIXELCOMPATIBLEWIDTHINTERPRETERQUERY		0x0080
#define HINTFORSUBPIXELVERTICALDIRECTIONINTERPRETERQUERY	0x0100
#define HINTFORSUBPIXELBGRORDERINTERPRETERQUERY				0x0200

#ifdef FSCFG_SUBPIXEL
/* new Microsoft 1998 */
#define HINTEDFORSUBPIXELGLYPH								0x02000
#define HINTEDFORSUBPIXELCOMPATIBLEWIDTHGLYPH				0x04000
#define HINTEDFORSUBPIXELVERTICALDIRECTIONGLYPH				0x08000
#define HINTEDFORSUBPIXELBGRORDERGLYPH						0x10000
#endif // FSCFG_SUBPIXEL

// this includes all SP specific flags, since we don't want a SP enabled font to break on a non SP enabled rasterizer
#define SELECTOR_FLAGS (VERSIONINTERPRETERQUERY | ROTATEDINTERPRETERQUERY | STRETCHEDINTERPRETERQUERY |					\
						VARIATIONINTERPRETERQUERY | VERTICALMETRICSINTERPRETERQUERY | HINTFORGRAYINTERPRETERQUERY |		\
						HINTFORSUBPIXELINTERPRETERQUERY | HINTFORSUBPIXELCOMPATIBLEWIDTHINTERPRETERQUERY |			\
						HINTFORSUBPIXELVERTICALDIRECTIONINTERPRETERQUERY | HINTFORSUBPIXELBGRORDERINTERPRETERQUERY)

#define MAXBYTE_INSTRUCTIONS 256

#define ONEVECTOR                       ONESHORTFRAC
#define VECTORMUL(value, component)     ShortFracMul((F26Dot6)(value), (ShortFract)(component))
#define VECTORDOT(a,b)                  ShortFracDot((ShortFract)(a),(ShortFract)(b))
#define VECTORDIV(num,denum)            ShortFracDiv((ShortFract)(num),(ShortFract)(denum))
#define VECTORMULDIV(a,b,c)             ShortFracMulDiv((ShortFract)(a),(ShortFract)(b),(ShortFract)(c))
#define VECTOR2FIX(a)                   ((Fixed) (a) << 2)
#define ONESIXTEENTHVECTOR              ((ONEVECTOR) >> 4)

#ifdef FSCFG_REENTRANT
#define GSP0    fnt_LocalGraphicStateType* pLocalGS
#define GSP     fnt_LocalGraphicStateType* pLocalGS,
#define GSA0    pLocalGS
#define GSA     pLocalGS,
#define LocalGS (*pLocalGS)
#else 
#define GSP0    void
#define GSP
#define GSA0
#define GSA
fnt_LocalGraphicStateType LocalGS
 #ifndef FSCFG_NO_INITIALIZED_DATA
  = {0}
 #endif 
;
#endif 


#define MABS(x)                 ( (x) < 0 ? (-(x)) : (x) )


/* Common Interpreter Function Parameter */

#define IPARAM         GSP uint8 *pbyInst, int32 lOpCode

#define MIRPG          0
#define MIRPX          1
#define MIRPY          2
				  
// color compensation flags in ROUND, MDRP, and MIRP
#define	GREY	0
#define BLACK	1
#define WHITE	2
#define OTHER	3

// flags for UTP, IUP, MovePoint
#define XMOVED 0x01
#define YMOVED 0x02


#define NUM_PHANTOM_PTS   4L

#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA // master switch

	#define NumRelationShips(elem) (elem->ep[elem->nc - 1] + 1 + NUM_PHANTOM_PTS)

	// Make an empty data structure (DAG)
	void InitPhaseControl(fnt_ElementType *elem) {
		long i;
		PhaseControlRelation *rel;

		for (i = 0; i < NumRelationShips(elem); i++) {
			rel = &elem->pcr[i];
			rel->parent0 = rel->parent1 = rel->child = -1;
			rel->flags = 0;
			rel->phaseShift = 0;
		}
		elem->phaseControlExecuted = false;
	} // InitPhaseControl

	//	Function to avert circular dependencies, whose traversal would cause endless recursion in
	//	"PhaseShift" further below.
	//
	//	In the trivial case (self dependency), a child would depend on itself. This scenario is ex-
	//	cluded by respective tests in the callers.
	//
	//	In the simplest non-trivial case (direct dependency), before linking from a parent to a child,
	//	we want to determine whether the child links back to the parent:
	//
	//		IndirectlyDependsOn(..., parent, child, ...) ?
	//
	//	If it does, then "self" (the parent) depends on "whom" (the child), and we'd get a circular
	//	dependency, because the child would depend on the parent as a result of "AddDistance":
	//
	//		rel->parent0 == whom ?
	//
	//	noting that "rel" points to self's phase control relation structure.
	//
	//	In the more general case (indirect dependency, which includes direct dependency via zero
	//	indirections), self's parent may depend on the child (and recursively), hence:
	//
	//		rel->parent0 == whom || IndirectlyDependsOn(..., rel->parent0, whom, ...) ?
	//
	//	In the most general case, there may be two parents involved, hence we have to follow both
	//	lines of ancestry:
	//
	//		rel->parent0 == whom || IndirectlyDependsOn(..., rel->parent0, whom, ...) || 
	//		rel->parent1 == whom || IndirectlyDependsOn(..., rel->parent1, whom, ...) ?
	//
	//	Notice that in the actual code the latter is re-arranged for efficiency.
	//	Notice also that we don't have a simple case of tail recursion, which could be replaced by
	//	an iteration easily.

	boolean IndirectlyDependsOn(fnt_ElementType *elem, long self, long whom, long level) {
		PhaseControlRelation *rel;

		level--;
		if (level < 0) return true; // safeguard against stack overflow, probably redundant

	//	here we assume that we're called only from within AddDistance or AddProportion, hence
	//	"self" and "whom" have been range checked initially. Every recursion changes the actual
	//	value of "self", but only to a value obtained from a "pcr", which only gets range checked
	//	values, hence we don't need to range check "self" again. "whom" is invariant anyhow.
	//	Additionally, we also assume that "self" and "whom" are not the same. Since the algorithm
	//	below terminates if "self"'s parent equals "whom", "self" never becomes "whom".

		rel = &elem->pcr[self];
		if (rel->parent0 == -1) // 0 parents (MDAP, MIAP)
			return false; // no dependencies
		else if (rel->parent1 == -1) // 1 parent (MDRP, MIRP, SHP, ALIGNRP, etc.)
			return rel->parent0 == whom || IndirectlyDependsOn(elem,rel->parent0,whom,level-1);
		else // 2 parents (IP)
			return rel->parent0 == whom || rel->parent1 == whom || IndirectlyDependsOn(elem,rel->parent0,whom,level-1) || IndirectlyDependsOn(elem,rel->parent1,whom,level-1);
		return false; // we shouldn't get down here, but the compiler thinks we do...
	} // IndirectlyDependsOn

	// Called from the TT interpreter whenever a MIRP, MDRP, SHP, ALIGNRP (etc.) is executed
	// Add a distance relationship to the DAG
	void AddDistance(fnt_LocalGraphicStateType *localGS, fnt_ElementType *elem, long from, long to, long color) {
		long parent;

		if (0 <= from && from < NumRelationShips(elem) && 0 <= to && to < NumRelationShips(elem) && from != to) { // prevent endless recursions
			if (IndirectlyDependsOn(elem,from,to,INTERP_MAX_RECURSIVE_CALLS))
				elem->pcr[to].flags |= BADREL;
			else if (elem->pcr[to].parent0 == -1) { // we have no parent for this child
				while ((parent = elem->pcr[from].parent0) != -1 && elem->oox[from] == elem->oox[parent])
					from = parent; // simplify link structure in case of links to "align" vertical edges
				elem->pcr[to].parent0 = (int16)from; // first link wins, bad links may produce suboptimal phase control
				elem->pcr[to].parent1 = -1;
			}
			if (color == BLACK && elem->pcr[from].child == -1 && elem->pcr[to].child != from) { // first black link wins...
				if ((parent = elem->pcr[from].parent0) != -1 && elem->pcr[parent].child == from)
					elem->pcr[to].flags |= BADREL;
				else
					elem->pcr[from].child = (int16)to;
			}
		}
	} // AddDistance
	
	// Called from the TT interpreter when an IP is executed
	// Add a proportion relationship to the DAG
	void AddProportion(fnt_LocalGraphicStateType *localGS, fnt_ElementType *elem, long from0, long to, long from1) {
		if (0 <= from0 && from0 < NumRelationShips(elem) && 0 <= from1 && from1 < NumRelationShips(elem) && 0 <= to && to < NumRelationShips(elem) && from0 != to && from1 != to && from0 != from1) { // prevent endless recursions
			if (IndirectlyDependsOn(elem,from0,to,INTERP_MAX_RECURSIVE_CALLS) || IndirectlyDependsOn(elem,from1,to,INTERP_MAX_RECURSIVE_CALLS))
				elem->pcr[to].flags |= BADREL;
			else if (elem->pcr[to].parent0 == -1 && elem->pcr[to].parent1 == -1) {
				elem->pcr[to].parent0 = (int16)from0; // first interpolate wins, bad interpolates
				elem->pcr[to].parent1 = (int16)from1; // ...may produce suboptimal phase control
			}
		}
	} // AddProportion
	
	// Calculate the phase shift resulting from a child point that depends on two parent points by proportion (interpolation)
	F26Dot6 CalcAvgXPhaseShift(fnt_ElementType *elem, long parent0, long child, long parent1, F26Dot6 phase0, F26Dot6 phase1) {
		F26Dot6 leftX,childX,rightX,leftPhase,rightPhase;
		
		// the phase of child control points that are interpolated between a pair of parent control points depends on the phase
		// applied to both of these parent control points.
		// If both parents have the same phase, then the child point gets that phase
		if (phase0 == phase1) return phase0; // IPs "within" strokes

		// if the phase is different, we try to calculcate a weighted average.
		// In dubious cases, this may fail (divide-by-zero), in which case we fall back on an unweighted (plain) average.
		if (elem->ox[parent0] < elem->ox[parent1]) {
			leftX = elem->ox[parent0]; rightX = elem->ox[parent1];
			leftPhase = phase0; rightPhase = phase1;
		} else {
			leftX = elem->ox[parent1]; rightX = elem->ox[parent0];
			leftPhase = phase1; rightPhase = phase0;
		}
		childX = elem->ox[child];
		
		return leftX != rightX 
			? ((childX - leftX)*rightPhase + (rightX - childX)*leftPhase)/(rightX - leftX) // weighted average
			: (leftPhase + rightPhase) / 2; // unweighted average
	} // CalcAvgXPhaseShift
	
	// This is the part that (recursively) traverses the data structure to apply the above rules, called from ExecutePhaseControl below
	// Notice that it works much like the early prototype for the compiler that translates VTT's GUI into TMT
	F26Dot6 PhaseShift(fnt_LocalGraphicStateType *localGS, fnt_ElementType *elem, short anyBadRelation, long child) {
		PhaseControlRelation *rel,*childRel;
		F26Dot6 phase;
		
		if (child == -1) return 0; // nothing, hence no phase shift
		
		rel = &elem->pcr[child];
		
		if (rel->flags & DOING) return 0; // prevent from endless recursion due to circular dependencies; probably redundant
		rel->flags |= DOING;

		if ((rel->flags & DONE) == 0) { // else been there already, know phase
			if (child > elem->ep[elem->nc-1]) { // LSB, RSB
				phase = LongMulDiv(elem->x[child],localGS->globalGS->compatibleWidthStemConcertina - 0x10000,0x10000);
			} else if (rel->parent0 == -1) { // MDAP, MIAP
				if (anyBadRelation) {
					phase = LongMulDiv(elem->x[child],localGS->globalGS->compatibleWidthStemConcertina - 0x10000,0x10000);
				} else {
					phase = 0;
				}
			} else if (rel->parent1 == -1) { // MDRP, MIRP, SHP, ALIGNRP, ...
				phase = PhaseShift(localGS,elem,anyBadRelation,rel->parent0);
			} else { // IP
				phase = CalcAvgXPhaseShift(elem,rel->parent0,child,rel->parent1,PhaseShift(localGS,elem,anyBadRelation,rel->parent0),PhaseShift(localGS,elem,anyBadRelation,rel->parent1));
			}
			
			if ((rel->flags & DONE) == 0) { // still not done, after above recursion
				if (rel->child != -1 && ((childRel = &elem->pcr[rel->child])->flags & DONE) == 0) {
					if (rel->parent0 == -1 || rel->parent1 == -1) { // not IP
						phase = LongMulDiv(elem->x[child] + elem->x[rel->child],localGS->globalGS->compatibleWidthStemConcertina - 0x10000,0x20000);
					}
					
					elem->x[child] += phase;
					elem->x[rel->child] += phase;
					
					childRel->phaseShift = phase;
					childRel->flags |= DONE;
				
				// else if we're linked to, and we're not a leaf, such as in a chain of links through a 'v',
				// do the proportional thing, in order not to twist the 'v'
				// additionally, we may want to make the decision, which "stroke" wins, a bit smarter,
				// by giving preference to the one with the lesser |dy|

				} else {
					if (anyBadRelation && rel->parent1 == -1 && (rel->parent0 == -1 || elem->ox[child] != elem->ox[rel->parent0])) {
					//	bad MDRP, MIRP, SHP, ALIGNRP, MDAP, or MIAP, but not in case aligned along vertical edge
						phase = LongMulDiv(elem->x[child],localGS->globalGS->compatibleWidthStemConcertina - 0x10000,0x10000);
					} // else IP
					if (rel->parent0 != -1) {
						elem->x[child] += phase;
					}
				}
				rel->phaseShift = phase;
				rel->flags |= DONE;
			}
		}

		rel->flags &= ~DOING;
		return rel->phaseShift;
	} // PhaseShift

	// This is a plain old loop
	// It is never to be executed in the twilight zone, hence all the guards upon calling it.
	void ExecutePhaseControl(fnt_LocalGraphicStateType *localGS, fnt_ElementType *elem) {
		long i,numRelationShips;
		short anyBadRelation;
		F26Dot6 phase;

		numRelationShips = NumRelationShips(elem);
		for (i = 0; i < numRelationShips && (elem->pcr[i].flags & BADREL) == 0; i++);
		anyBadRelation = i < numRelationShips;
		for (i = 0; i < numRelationShips; i++) {
			phase = PhaseShift(localGS,elem,anyBadRelation,i);
		}
		elem->phaseControlExecuted = true;
	} // ExecutePhaseControl

	// helper function
	long ContNum(fnt_ElementType *elem, long knot) {
		long i;

		for (i = 0; i < elem->nc && knot > elem->ep[i]; i++);
		return i < elem->nc ? i : -1;
	} // ContNum

	// The "concertina algorithm" uses the color flags in the MDRP and MIRP instructions to "determine" the existence
	// of stems. Most of the time, the color flags are set correctly; in fact, if the TT code is generated by the TMT
	// compiler, they should always be correct. However, there is a small number of cases where the flags are erroneous
	// (a black stroke which is not flagged as black) or misleading (the extent of a cross bar, which is a black link
	// as defined in the TMT compiler, but which for the purpose of this algorithm had rather not be flagged as black).
	// Not surprisingly, most of these cases (avoiding to say, all of them) happen on grotesque fonts, with the MDRP
	// or MIRP between two neighbouring points on the outline (cases in which a compiler generating TT code could ar-
	// gueably be undecided). Therefore we make a last ditch effort in this function to correct the colour flags for
	// this special class of problems.
	long DoubleCheckLinkColor(fnt_ElementType *elem, long from, long to, long color) {
		long fromCont,fromStart,fromEnd,fromSucc,fromPred,toCont,toSucc,toPred;
		boolean fromRightTurn,toRightTurn,properlyOriented;

		// first, determine whether we link between a pair of neighbours on one and the same contour
		// one of the knots is not on any contour (LSB, RSB), hence can't be neighbours
		if ((fromCont = ContNum(elem,from)) < 0 || // error
			(toCont   = ContNum(elem,to))   < 0)
			return GREY; // it's not a black stroke
		
		// if they belong to different contours, we don't attempt to improve color flag
		if (fromCont != toCont) return color;
		
		// if they belong to the same contour, but are not neighbours, we don't attempt to improve color flag, either
		fromStart = elem->sp[fromCont];
		fromEnd   = elem->ep[fromCont];
		fromSucc = from == fromEnd ? fromStart : from+1;
		fromPred = from == fromStart ? fromEnd : from-1;
		if (to != fromSucc && to != fromPred) return color;

		// if they are neighbours, but the link is along the arm of a T-junction, we call it a grey link.
		// we determine this by testing whether the link starts at a point where the outline makes a right
		// turn and ends at a point where the outline makes a left turn, or vice versa.
		toSucc = to == fromEnd ? fromStart : to+1;
		toPred = to == fromStart ? fromEnd : to-1;
		fromRightTurn = (elem->oox[from]-elem->oox[fromPred])*(elem->ooy[fromSucc]-elem->ooy[from]) <
						(elem->ooy[from]-elem->ooy[fromPred])*(elem->oox[fromSucc]-elem->oox[from]);
		toRightTurn   = (elem->oox[to]-elem->oox[toPred])*(elem->ooy[toSucc]-elem->ooy[to]) <
						(elem->ooy[to]-elem->ooy[toPred])*(elem->oox[toSucc]-elem->oox[to]);
		if (fromRightTurn != toRightTurn)
			return GREY;

		// a extraneous case encountered, a link along a diagonal stroke
		if (2*MABS(elem->oox[to]-elem->oox[from]) < MABS(elem->ooy[to]-elem->ooy[from]))
			return GREY;

		properlyOriented = (elem->fc[fromCont] & OUTLINE_MISORIENTED) == 0;

		return properlyOriented == fromRightTurn ? BLACK : WHITE;
	} // DoubleCheckLinkColor

	// Determine whether an interpolation is actually an interpolation, as opposed to an extrapolation.
	// For actual interpolations, child points are moved along proportionally to the parent points. For
	// extrapolations child points are shifted along with the parent point(s). Notice that we implement
	// a behaviour similar to IUP (points between extrema are interpolated, the others are shifted along)
	boolean InterAlign(fnt_ElementType *elem, long parent0, long child, long parent1) {
		long parent0x,childx,parent1x,temp;

		parent0x = elem->oox[parent0];
		parent1x = elem->oox[parent1];
		if (parent0x > parent1x) { temp = parent0x; parent0x = parent1x; parent1x = temp; }
		childx = elem->oox[child];
		return parent0x <= childx && childx <= parent1x;
	} // InterAlign

#endif // SUBPIXEL_BC_AW_STEM_CONCERTINA


/* Private function prototypes */

FS_PRIVATE F26Dot6 itrp_RoundToDoubleGrid(GSP F26Dot6 xin, F26Dot6 engine);
FS_PRIVATE F26Dot6 itrp_RoundDownToGrid(GSP F26Dot6 xin, F26Dot6 engine);
FS_PRIVATE F26Dot6 itrp_RoundUpToGrid(GSP F26Dot6 xin, F26Dot6 engine);
FS_PRIVATE F26Dot6 itrp_RoundToGrid(GSP F26Dot6 xin, F26Dot6 engine);
FS_PRIVATE F26Dot6 itrp_RoundToHalfGrid(GSP F26Dot6 xin, F26Dot6 engine);
FS_PRIVATE F26Dot6 itrp_RoundOff(GSP F26Dot6 xin, F26Dot6 engine);

#ifdef FSCFG_SUBPIXEL
	// a duplicate set of rounding functions, with either the b/w (above) or the sp (below) version being installed
	FS_PRIVATE F26Dot6 itrp_RoundToDoubleGridSP(GSP F26Dot6 xin, F26Dot6 engine);
	FS_PRIVATE F26Dot6 itrp_RoundDownToGridSP(GSP F26Dot6 xin, F26Dot6 engine);
	FS_PRIVATE F26Dot6 itrp_RoundUpToGridSP(GSP F26Dot6 xin, F26Dot6 engine);
	FS_PRIVATE F26Dot6 itrp_RoundToGridSP(GSP F26Dot6 xin, F26Dot6 engine);
	FS_PRIVATE F26Dot6 itrp_RoundToHalfGridSP(GSP F26Dot6 xin, F26Dot6 engine);
	FS_PRIVATE F26Dot6 itrp_RoundOffSP(GSP F26Dot6 xin, F26Dot6 engine);
#endif

FS_PRIVATE F26Dot6 itrp_SuperRound(GSP F26Dot6 xin, F26Dot6 engine);
FS_PRIVATE F26Dot6 itrp_Super45Round(GSP F26Dot6 xin, F26Dot6 engine);

FS_PRIVATE void itrp_MovePoint  (GSP fnt_ElementType *element, int32 point, F26Dot6 delta);
FS_PRIVATE void itrp_XMovePoint (GSP fnt_ElementType *element, int32 point, F26Dot6 delta);
FS_PRIVATE void itrp_YMovePoint (GSP fnt_ElementType *element, int32 point, F26Dot6 delta);
FS_PRIVATE F26Dot6 itrp_Project (GSP F26Dot6 x, F26Dot6 y);
FS_PRIVATE F26Dot6 itrp_OldProject (GSP F26Dot6 x, F26Dot6 y);
FS_PRIVATE F26Dot6 itrp_XProject (GSP F26Dot6 x, F26Dot6 y);
FS_PRIVATE F26Dot6 itrp_YProject (GSP F26Dot6 x, F26Dot6 y);
FS_PRIVATE Fixed itrp_GetCVTScale (GSP0);
FS_PRIVATE F26Dot6 itrp_GetCVTEntryFast (GSP int32 n);
FS_PRIVATE F26Dot6 itrp_GetCVTEntrySlow (GSP int32 n);
FS_PRIVATE F26Dot6 itrp_GetSingleWidthFast (GSP0);
FS_PRIVATE F26Dot6 itrp_GetSingleWidthSlow (GSP0);
FS_PRIVATE void itrp_ChangeCvtFast (GSP fnt_ElementType *element, int32 number, F26Dot6 delta);
FS_PRIVATE void itrp_ChangeCvtSlow (GSP fnt_ElementType *element, int32 number, F26Dot6 delta);

FS_PRIVATE void itrp_InnerTraceExecute (GSP uint8 *ptr, uint8 *eptr);
FS_PRIVATE void itrp_InnerExecute (GSP uint8 *ptr, uint8 *eptr);
FS_PRIVATE void itrp_Check_PF_Proj (GSP0);
FS_PRIVATE void itrp_ComputeAndCheck_PF_Proj (GSP0);
FS_PRIVATE void itrp_SetRoundValues (GSP int32 arg1, int32 normalRound);
FS_PRIVATE F26Dot6 itrp_CheckSingleWidth (GSP F26Dot6 value);
FS_PRIVATE fnt_instrDef*itrp_FindIDef (GSP uint8 opCode);
FS_PRIVATE uint8* itrp_DeltaEngine (GSP uint8 *pbyInst, FntMoveFunc doIt, int16 base, int16 shift);

/* Actual instructions for the jump table */
FS_PRIVATE uint8* itrp_SVTCA_0 (IPARAM);
FS_PRIVATE uint8* itrp_SVTCA_1 (IPARAM);
FS_PRIVATE uint8* itrp_SPVTCA_0 (IPARAM);
FS_PRIVATE uint8* itrp_SPVTCA_1 (IPARAM);
FS_PRIVATE uint8* itrp_SFVTCA_0 (IPARAM);
FS_PRIVATE uint8* itrp_SFVTCA_1 (IPARAM);
FS_PRIVATE uint8* itrp_SPVTL (IPARAM);
FS_PRIVATE uint8* itrp_SDPVTL (IPARAM);
FS_PRIVATE uint8* itrp_SFVTL (IPARAM);
FS_PRIVATE uint8* itrp_WPV (IPARAM);
FS_PRIVATE uint8* itrp_WFV (IPARAM);
FS_PRIVATE uint8* itrp_RPV (IPARAM);
FS_PRIVATE uint8* itrp_RFV (IPARAM);
FS_PRIVATE uint8* itrp_SFVTPV (IPARAM);
FS_PRIVATE uint8* itrp_ISECT (IPARAM);
FS_PRIVATE uint8* itrp_SRP0 (IPARAM);
FS_PRIVATE uint8* itrp_SRP1 (IPARAM);
FS_PRIVATE uint8* itrp_SRP2 (IPARAM);
FS_PRIVATE uint8* itrp_SetElementPtr (IPARAM);
FS_PRIVATE uint8* itrp_LLOOP (IPARAM);
FS_PRIVATE uint8* itrp_RTG (IPARAM);
FS_PRIVATE uint8* itrp_RTHG (IPARAM);
FS_PRIVATE uint8* itrp_RTDG (IPARAM);
FS_PRIVATE uint8* itrp_ROFF (IPARAM);
FS_PRIVATE uint8* itrp_RUTG (IPARAM);
FS_PRIVATE uint8* itrp_RDTG (IPARAM);
FS_PRIVATE uint8* itrp_SROUND (IPARAM);
FS_PRIVATE uint8* itrp_S45ROUND (IPARAM);
FS_PRIVATE uint8* itrp_LMD (IPARAM);
FS_PRIVATE uint8* itrp_RAW (IPARAM);
FS_PRIVATE uint8* itrp_LWTCI (IPARAM);
FS_PRIVATE uint8* itrp_LSWCI (IPARAM);
FS_PRIVATE uint8* itrp_LSW (IPARAM);
FS_PRIVATE uint8* itrp_DUP (IPARAM);
FS_PRIVATE uint8* itrp_POP (IPARAM);
FS_PRIVATE uint8* itrp_CLEAR (IPARAM);
FS_PRIVATE uint8* itrp_SWAP (IPARAM);
FS_PRIVATE uint8* itrp_DEPTH (IPARAM);
FS_PRIVATE uint8* itrp_CINDEX (IPARAM);
FS_PRIVATE uint8* itrp_MINDEX (IPARAM);
FS_PRIVATE uint8* itrp_ROTATE (IPARAM);
FS_PRIVATE uint8* itrp_MDAP (IPARAM);
FS_PRIVATE uint8* itrp_MIAP (IPARAM);
FS_PRIVATE uint8* itrp_IUP (IPARAM);
FS_PRIVATE uint8* itrp_SHP (IPARAM);
FS_PRIVATE uint8* itrp_SHC (IPARAM);
FS_PRIVATE uint8* itrp_SHE (IPARAM);
FS_PRIVATE uint8* itrp_SHPIX (IPARAM);
FS_PRIVATE uint8* itrp_IP (IPARAM);
FS_PRIVATE uint8* itrp_MSIRP (IPARAM);
FS_PRIVATE uint8* itrp_ALIGNRP (IPARAM);
FS_PRIVATE uint8* itrp_ALIGNPTS (IPARAM);
FS_PRIVATE uint8* itrp_SANGW (IPARAM);
FS_PRIVATE uint8* itrp_FLIPPT (IPARAM);
FS_PRIVATE uint8* itrp_FLIPRGON (IPARAM);
FS_PRIVATE uint8* itrp_FLIPRGOFF (IPARAM);
FS_PRIVATE uint8* itrp_SCANCTRL (IPARAM);
FS_PRIVATE uint8* itrp_SCANTYPE (IPARAM);
FS_PRIVATE uint8* itrp_INSTCTRL (IPARAM);
FS_PRIVATE uint8* itrp_AA (IPARAM);
FS_PRIVATE uint8* itrp_NPUSHB (IPARAM);
FS_PRIVATE uint8* itrp_NPUSHW (IPARAM);
FS_PRIVATE uint8* itrp_WS (IPARAM);
FS_PRIVATE uint8* itrp_RS (IPARAM);
FS_PRIVATE uint8* itrp_WCVT (IPARAM);
FS_PRIVATE uint8* itrp_WCVTFOD (IPARAM);
FS_PRIVATE uint8* itrp_RCVT (IPARAM);
FS_PRIVATE uint8* itrp_RC (IPARAM);
FS_PRIVATE uint8* itrp_WC (IPARAM);
FS_PRIVATE uint8* itrp_MD (IPARAM);
FS_PRIVATE uint8* itrp_MPPEM (IPARAM);
FS_PRIVATE uint8* itrp_MPS (IPARAM);
FS_PRIVATE uint8* itrp_GETINFO (IPARAM);
FS_PRIVATE uint8* itrp_FLIPON (IPARAM);
FS_PRIVATE uint8* itrp_FLIPOFF (IPARAM);
FS_PRIVATE uint8* itrp_IF (IPARAM);
FS_PRIVATE uint8* itrp_ELSE (IPARAM);
FS_PRIVATE uint8* itrp_EIF (IPARAM);
FS_PRIVATE uint8* itrp_JMPR (IPARAM);
FS_PRIVATE uint8* itrp_JROT (IPARAM);
FS_PRIVATE uint8* itrp_JROF (IPARAM);
FS_PRIVATE uint8* itrp_ROUND (IPARAM);
FS_PRIVATE uint8* itrp_NROUND (IPARAM);
FS_PRIVATE uint8* itrp_PUSHB (IPARAM);
FS_PRIVATE uint8* itrp_PUSHW (IPARAM);
FS_PRIVATE uint8* itrp_MDRP (IPARAM);
FS_PRIVATE uint8* itrp_MIRP (IPARAM);
FS_PRIVATE uint8* itrp_CALL (IPARAM);
FS_PRIVATE uint8* itrp_FDEF (IPARAM);
FS_PRIVATE uint8* itrp_LOOPCALL (IPARAM);
FS_PRIVATE uint8* itrp_IDefPatch (IPARAM);
FS_PRIVATE uint8* itrp_IDEF (IPARAM);
FS_PRIVATE uint8* itrp_UTP (IPARAM);
FS_PRIVATE uint8* itrp_SDB (IPARAM);
FS_PRIVATE uint8* itrp_SDS (IPARAM);
FS_PRIVATE uint8* itrp_DELTAP1 (IPARAM);
FS_PRIVATE uint8* itrp_DELTAP2 (IPARAM);
FS_PRIVATE uint8* itrp_DELTAP3 (IPARAM);
FS_PRIVATE uint8* itrp_DELTAC1 (IPARAM);
FS_PRIVATE uint8* itrp_DELTAC2 (IPARAM);
FS_PRIVATE uint8* itrp_DELTAC3 (IPARAM);

FS_PRIVATE uint8*  itrp_PUSHB1 (IPARAM);
FS_PRIVATE uint8*  itrp_PUSHW1 (IPARAM);

FS_PRIVATE uint8*  itrp_LT  (IPARAM);
FS_PRIVATE uint8*  itrp_LTEQ (IPARAM);
FS_PRIVATE uint8*  itrp_GT  (IPARAM);
FS_PRIVATE uint8*  itrp_GTEQ (IPARAM);
FS_PRIVATE uint8*  itrp_EQ  (IPARAM);
FS_PRIVATE uint8*  itrp_NEQ (IPARAM);
FS_PRIVATE uint8*  itrp_AND (IPARAM);
FS_PRIVATE uint8*  itrp_OR  (IPARAM);
FS_PRIVATE uint8*  itrp_ADD (IPARAM);
FS_PRIVATE uint8*  itrp_SUB (IPARAM);
FS_PRIVATE uint8*  itrp_DIV (IPARAM);
FS_PRIVATE uint8*  itrp_MUL (IPARAM);
FS_PRIVATE uint8*  itrp_MAX (IPARAM);
FS_PRIVATE uint8*  itrp_MIN (IPARAM);

FS_PRIVATE uint8*  itrp_ODD (IPARAM);
FS_PRIVATE uint8*  itrp_EVEN (IPARAM);
FS_PRIVATE uint8*  itrp_NOT (IPARAM);
FS_PRIVATE uint8*  itrp_ABS (IPARAM);
FS_PRIVATE uint8*  itrp_NEG (IPARAM);
FS_PRIVATE uint8*  itrp_CEILING (IPARAM);
FS_PRIVATE uint8*  itrp_FLOOR (IPARAM);

FS_PRIVATE uint8*  itrp_IllegalInstruction (IPARAM);

FS_PRIVATE fnt_ElementType*itrp_SH_Common (GSP F26Dot6*dx, F26Dot6*dy, int32*point, int32 lOpCode);
FS_PRIVATE uint8* itrp_SHP_Common (GSP uint8 *pbyInst, 
#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
								   int32 refPoint,
#endif
#ifdef FSCFG_SUBPIXEL							// extra parameter to distinguish between coming from SHPIX, in which case we assume
								   uint8 shpix, // the context is a delta fn and hence we most likely skip the delta, and SHP
#endif
								   F26Dot6 dx, F26Dot6 dy);
FS_PRIVATE uint8* itrp_PushSomeBytes (GSP int32, uint8*);
FS_PRIVATE uint8* itrp_PushSomeWords (GSP int32, uint8*);
FS_PRIVATE uint8* itrp_SkipPushData (GSP uint8*);

#ifndef NOT_ON_THE_MAC
#ifdef FSCFG_DEBUG
FS_PRIVATE void itrp_DDT (int8 c, int32 n);
#endif
#endif
FS_PRIVATE uint8* itrp_DEBUG (IPARAM);

#define MAX(a,b)        ((a) > (b) ? (a) : (b))

FS_PRIVATE ErrorCode   itrp_Execute (
	fnt_ElementType *               pTwilightElement,
	fnt_ElementType *               pGlyphElement,
	uint8 *                         ptr,
	uint8 *                         eptr,
	fnt_GlobalGraphicStateType *    globalGS,
	 FntTraceFunc                           TraceFunc);

/* GLOBAL GS INITIALIZATION */

FS_PUBLIC void          itrp_UpdateGlobalGS(
	void *              pvGlobalGS, /* GlobalGS                             */
	void *              pvCVT,      /* Pointer to control value table       */
	void *              pvStore,    /* Pointer to storage                   */
	void *              pvFuncDef,  /* Pointer to function defintions       */
	void *              pvInstrDef, /* Pointer to instruction definitions   */
	void *              pvStack,    /* Pointer to the stack                 */
	LocalMaxProfile *       maxp,
	uint16              cvtCount,
	uint32              ulLengthFontProgram, /* Length of font program      */
	void *              pvFontProgram, /* Pointer to font program           */
	uint32              ulLengthPreProgram, /* Length of pre program        */
	void *              pvPreProgram,  /* Pointer to pre program            */
	ClientIDType        clientID)     /* User ID Number                     */
{
	fnt_GlobalGraphicStateType *    globalGS;
#ifdef FSCFG_SECURE
    uint16      maxStackElements = maxp->maxStackElements;

#ifdef FSCFG_EUDC_EDITOR_BUG
    if (maxStackElements == 0)
    {
      maxStackElements = 1;
    }

#endif // FSCFG_EUDC_EDITOR_BUG
#endif // FSCFG_SECURE

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	globalGS->controlValueTable =   (F26Dot6 *)pvCVT;
	globalGS->store =               (F26Dot6 *)pvStore;
	globalGS->funcDef =             (fnt_funcDef *)pvFuncDef;
	globalGS->instrDef =            (fnt_instrDef *)pvInstrDef;
	globalGS->stackBase =           (F26Dot6 *)pvStack;
	globalGS->clientID =            clientID;
#ifdef FSCFG_SECURE
	globalGS->stackMax =             globalGS->stackBase + maxStackElements;
    globalGS->maxPointsIncludePhantom = MAX (maxp->maxPoints,maxp->maxCompositePoints) + NUM_PHANTOM_PTS;
#endif // FSCFG_SECURE

	if(ulLengthFontProgram)
	{
		globalGS->pgmList[FONTPROGRAM].Length = ulLengthFontProgram;
		globalGS->pgmList[FONTPROGRAM].Instruction = (unsigned char *)pvFontProgram;
	}
	else
	{
		globalGS->pgmList[FONTPROGRAM].Length = ulLengthFontProgram;
		globalGS->pgmList[FONTPROGRAM].Instruction = NULL;
	}
	if(ulLengthPreProgram)
	{
		globalGS->pgmList[PREPROGRAM].Length = ulLengthPreProgram;
		globalGS->pgmList[PREPROGRAM].Instruction = (unsigned char *)pvPreProgram;
	}
	else
	{
		globalGS->pgmList[PREPROGRAM].Length = ulLengthPreProgram;
		globalGS->pgmList[PREPROGRAM].Instruction = NULL;
	}

	globalGS->maxp = maxp;
	globalGS->cvtCount = cvtCount;
	globalGS->bCompositeGlyph = FALSE;
	globalGS->bSameTransformAsMaster = TRUE;
	globalGS->bOriginalPointIsInvalid = FALSE;

	globalGS->ulMaxJumpCounter = INTERP_MAX_JUMPS;
	globalGS->ulMaxRecursiveCall = INTERP_MAX_RECURSIVE_CALLS;
}

FS_PUBLIC boolean itrp_bApplyHints(
	void *      pvGlobalGS)
{
	fnt_GlobalGraphicStateType *    globalGS;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;
	return (!(globalGS->localParBlock.instructControl & NOGRIDFITFLAG));
}

FS_PUBLIC void  itrp_QueryScanInfo(
	void *      pvGlobalGS,
	uint16 *    pusScanType,
	uint16 *    pusScanControl)
{
	fnt_GlobalGraphicStateType *    globalGS;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;
	 *pusScanType =  FS_HIWORD(globalGS->localParBlock.scanControl);
	 *pusScanControl = FS_LOWORD(globalGS->localParBlock.scanControl);
}

FS_PUBLIC void  itrp_SetCompositeFlag(
	void *      pvGlobalGS,
	uint8       bCompositeFlag)
{
	fnt_GlobalGraphicStateType *    globalGS;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;
	globalGS->bCompositeGlyph = bCompositeFlag;

	globalGS->bOriginalPointIsInvalid = globalGS->bCompositeGlyph || !globalGS->bSameTransformAsMaster;
}

FS_PUBLIC void	itrp_SetSameTransformFlag(
	void *      pvGlobalGS,
	boolean		bSameTransformAsMaster)
{
	fnt_GlobalGraphicStateType *    globalGS;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;
	globalGS->bSameTransformAsMaster = (uint8)bSameTransformAsMaster;

	globalGS->bOriginalPointIsInvalid = globalGS->bCompositeGlyph || !globalGS->bSameTransformAsMaster;
}

/*
*  function table
*/

FntFunc function [MAXBYTE_INSTRUCTIONS]
#ifndef FSCFG_NO_INITIALIZED_DATA
=
{
  itrp_SVTCA_0, itrp_SVTCA_1, itrp_SPVTCA_0, itrp_SPVTCA_1, itrp_SFVTCA_0, itrp_SFVTCA_1, itrp_SPVTL, itrp_SPVTL,
  itrp_SFVTL, itrp_SFVTL, itrp_WPV, itrp_WFV, itrp_RPV, itrp_RFV, itrp_SFVTPV, itrp_ISECT,
  itrp_SRP0, itrp_SRP1, itrp_SRP2, itrp_SetElementPtr, itrp_SetElementPtr, itrp_SetElementPtr, itrp_SetElementPtr, itrp_LLOOP,
  itrp_RTG, itrp_RTHG, itrp_LMD, itrp_ELSE, itrp_JMPR, itrp_LWTCI, itrp_LSWCI, itrp_LSW,
  itrp_DUP, itrp_POP, itrp_CLEAR, itrp_SWAP, itrp_DEPTH, itrp_CINDEX, itrp_MINDEX, itrp_ALIGNPTS,
  itrp_RAW, itrp_UTP, itrp_LOOPCALL, itrp_CALL, itrp_FDEF, itrp_IllegalInstruction, itrp_MDAP, itrp_MDAP,
  itrp_IUP, itrp_IUP, itrp_SHP, itrp_SHP, itrp_SHC, itrp_SHC, itrp_SHE, itrp_SHE,
  itrp_SHPIX, itrp_IP, itrp_MSIRP, itrp_MSIRP, itrp_ALIGNRP, itrp_RTDG, itrp_MIAP, itrp_MIAP,
  itrp_NPUSHB, itrp_NPUSHW, itrp_WS, itrp_RS, itrp_WCVT, itrp_RCVT, itrp_RC, itrp_RC,
  itrp_WC, itrp_MD, itrp_MD, itrp_MPPEM, itrp_MPS, itrp_FLIPON, itrp_FLIPOFF, itrp_DEBUG,
  itrp_LT, itrp_LTEQ, itrp_GT, itrp_GTEQ, itrp_EQ, itrp_NEQ, itrp_ODD, itrp_EVEN,
  itrp_IF, itrp_EIF, itrp_AND, itrp_OR, itrp_NOT, itrp_DELTAP1, itrp_SDB, itrp_SDS,
  itrp_ADD, itrp_SUB, itrp_DIV, itrp_MUL, itrp_ABS, itrp_NEG, itrp_FLOOR, itrp_CEILING,
  itrp_ROUND, itrp_ROUND, itrp_ROUND, itrp_ROUND, itrp_NROUND, itrp_NROUND, itrp_NROUND, itrp_NROUND,
  itrp_WCVTFOD, itrp_DELTAP2, itrp_DELTAP3, itrp_DELTAC1, itrp_DELTAC2, itrp_DELTAC3, itrp_SROUND, itrp_S45ROUND,
  itrp_JROT, itrp_JROF, itrp_ROFF, itrp_IllegalInstruction, itrp_RUTG, itrp_RDTG, itrp_SANGW, itrp_AA,

  itrp_FLIPPT, itrp_FLIPRGON, itrp_FLIPRGOFF, itrp_IDefPatch, itrp_IDefPatch, itrp_SCANCTRL, itrp_SDPVTL, itrp_SDPVTL,
  itrp_GETINFO, itrp_IDEF, itrp_ROTATE, itrp_MAX, itrp_MIN, itrp_SCANTYPE, itrp_INSTCTRL, itrp_IDefPatch,
  itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch,
  itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch,
  itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch,
  itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch,
  itrp_PUSHB1, itrp_PUSHB, itrp_PUSHB, itrp_PUSHB, itrp_PUSHB, itrp_PUSHB, itrp_PUSHB, itrp_PUSHB,
  itrp_PUSHW1, itrp_PUSHW, itrp_PUSHW, itrp_PUSHW, itrp_PUSHW, itrp_PUSHW, itrp_PUSHW, itrp_PUSHW,
  itrp_MDRP, itrp_MDRP, itrp_MDRP, itrp_MDRP, itrp_MDRP, itrp_MDRP, itrp_MDRP, itrp_MDRP,
  itrp_MDRP, itrp_MDRP, itrp_MDRP, itrp_MDRP, itrp_MDRP, itrp_MDRP, itrp_MDRP, itrp_MDRP,
  itrp_MDRP, itrp_MDRP, itrp_MDRP, itrp_MDRP, itrp_MDRP, itrp_MDRP, itrp_MDRP, itrp_MDRP,
  itrp_MDRP, itrp_MDRP, itrp_MDRP, itrp_MDRP, itrp_MDRP, itrp_MDRP, itrp_MDRP, itrp_MDRP,
  itrp_MIRP, itrp_MIRP, itrp_MIRP, itrp_MIRP, itrp_MIRP, itrp_MIRP, itrp_MIRP, itrp_MIRP,
  itrp_MIRP, itrp_MIRP, itrp_MIRP, itrp_MIRP, itrp_MIRP, itrp_MIRP, itrp_MIRP, itrp_MIRP,
  itrp_MIRP, itrp_MIRP, itrp_MIRP, itrp_MIRP, itrp_MIRP, itrp_MIRP, itrp_MIRP, itrp_MIRP,
  itrp_MIRP, itrp_MIRP, itrp_MIRP, itrp_MIRP, itrp_MIRP, itrp_MIRP, itrp_MIRP, itrp_MIRP
}
#endif /* FSCFG_NO_INITIALIZED_DATA */
;

/* the old itrp_Init function and tables now live in history.fnt - deanb */


#ifdef  GET_STACKSPACE
  int32 MaxStackSize = 0;

  #define PUSH(p, x) \
	{ \
	  if (p - LocalGS.globalGS->stackBase > MaxStackSize) \
		MaxStackSize = p - LocalGS.globalGS->stackBase; \
	  (*(p)++ = (x)); \
	}

#else
  #define PUSH( p, x ) ( *(p)++ = (x) )
#endif
  #define POP( p )     ( *(--p) )

#define BADCOMPILER

#ifdef BADCOMPILER
#define BOOLEANPUSH( p, x ) PUSH( p, ((x) ? 1 : 0) ) /* MPW 3.0 */
#else
#define BOOLEANPUSH( p, x ) PUSH( p, x )
#endif

#ifdef FSCFG_DEBUG
void CHECK_RANGE (int32 n, int32 min, int32 max);
void CHECK_RANGE (int32 n, int32 min, int32 max)
{
  if (n > max || n < min)
	ERR_REPORT (ERR_RANGE, n, min, max, 0);
}


void CHECK_ASSERTION (int32 expression);
void CHECK_ASSERTION (int32 expression)
{
  if (!expression)
	ERR_REPORT (ERR_ASSERTION, expression, 0, 0, 0);
}


void CHECK_CVT (fnt_LocalGraphicStateType* pGS, int32 cvt);
void CHECK_CVT (fnt_LocalGraphicStateType* pGS, int32 cvt)
{
  int32 cvtCount = (int32)(pGS->globalGS->cvtCount - 1L);

  if ((int32)cvt > cvtCount || (int32)cvt < 0L)
	ERR_REPORT (ERR_CVT, cvt, 0, cvtCount, 0);
}


void CHECK_FDEF (fnt_LocalGraphicStateType* pGS, int32 fdef);
void CHECK_FDEF (fnt_LocalGraphicStateType* pGS, int32 fdef)
{
  int32 maxFdef = (int32)(pGS->globalGS->maxp->maxFunctionDefs - 1L);

  if ((int32)fdef > maxFdef || (int32)fdef < 0L)
	ERR_REPORT (ERR_FDEF, fdef, 0, maxFdef, 0);
}

#define CHECK_PROGRAM(a)

void CHECK_ELEMENT (fnt_LocalGraphicStateType* pGS, int32 elem);
void CHECK_ELEMENT (fnt_LocalGraphicStateType* pGS, int32 elem)
{
  int32 maxElem = (int32)(pGS->globalGS->maxp->maxElements - 1L);

/*
  At least 1 maxElements will always be available
*/
  if (!maxElem)
	maxElem++;

  if ((int32)elem > maxElem || (int32)elem < 0L)
	ERR_REPORT (ERR_ELEMENT, elem, 0, maxElem, 0);
}

void CHECK_ELEMENTPTR (fnt_LocalGraphicStateType* pGS, fnt_ElementType*elem);
void CHECK_ELEMENTPTR (fnt_LocalGraphicStateType* pGS, fnt_ElementType*elem)
{
  if (elem == &pGS->elements[1])
  {
	 int32 maxctrs, maxpts;

	maxctrs = MAX (pGS->globalGS->maxp->maxContours,
				   pGS->globalGS->maxp->maxCompositeContours);
	maxpts  = MAX (pGS->globalGS->maxp->maxPoints,
				   pGS->globalGS->maxp->maxCompositePoints);

	if ((int32)elem->nc > (int32)maxctrs || (int32)elem->nc < 1L)
	  ERR_REPORT (ERR_CONTOUR, elem->nc, 1, maxctrs, 0);

	if ((int32)elem->ep[elem->nc-1] > maxpts - 1L ||
		(int32)elem->ep[elem->nc-1] < 0L)
	  ERR_REPORT (ERR_POINT, elem->ep[elem->nc-1], 0, maxpts - 1L, 0);
  }
  else if (elem != &pGS->elements[0])
	ERR_REPORT (ERR_INDEX, elem, &pGS->elements[0], &pGS->elements[1], 0);
}

void CHECK_STORAGE (fnt_LocalGraphicStateType* pGS, int32 index);
void CHECK_STORAGE (fnt_LocalGraphicStateType* pGS, int32 index)
{
  int32 maxIndex = (int32)(pGS->globalGS->maxp->maxStorage - 1L);

  if ((int32)index > maxIndex || (int32)index < 0L)
	ERR_REPORT (ERR_STORAGE, index, 0, maxIndex, 0);
}

void CHECK_STACK (fnt_LocalGraphicStateType* pGS);
void CHECK_STACK (fnt_LocalGraphicStateType* pGS)
{
  int32 base = (int32)(pGS->stackPointer - pGS->globalGS->stackBase);
  int32 max = (int32)(pGS->globalGS->maxp->maxStackElements - 1L);

  if (base > max || base < 0L)
	ERR_REPORT (ERR_STACK, base, 0, max, 0);
}

void CHECK_POINT (fnt_LocalGraphicStateType* pGS, fnt_ElementType*elem, int32 pt);
void CHECK_POINT (fnt_LocalGraphicStateType* pGS, fnt_ElementType*elem, int32 pt)
{
  CHECK_ELEMENTPTR (pGS, elem);
  if (pGS->elements == elem)
  {
	if ((int32)pt > pGS->globalGS->maxp->maxTwilightPoints - 1L ||
		(int32)pt < 0L)
	  ERR_REPORT (ERR_POINT, pt, 0, pGS->globalGS->maxp->maxTwilightPoints - 1L, 0);
  }
  else                                                      /* phantom points */
  {
	if ((int32)pt > elem->ep[elem->nc-1] + 2L || (int32)pt < 0L)
	  ERR_REPORT (ERR_POINT, pt, 0, elem->ep[elem->nc-1] + 2L, 0);
  }
}

void CHECK_CONTOUR (fnt_LocalGraphicStateType* pGS, fnt_ElementType*elem, int32 ctr);
void CHECK_CONTOUR (fnt_LocalGraphicStateType* pGS, fnt_ElementType*elem, int32 ctr)
{
  CHECK_ELEMENTPTR (pGS, elem);
  if ((int32)ctr > elem->nc - 1L || (int32)ctr < 0L)
	ERR_REPORT (ERR_CONTOUR, ctr, 0, elem->nc -1L, 0);
}

void CHECK_VECTOR (VECTORTYPE x, VECTORTYPE y);
void CHECK_VECTOR (VECTORTYPE x, VECTORTYPE y)
{
  if ( x == 0 && y == 0 )
	ERR_REPORT (ERR_VECTOR, x, y, 0, 0);
}

void CHECK_LARGER (int32 min, int32 n);
void CHECK_LARGER (int32 min, int32 n)
{
  if ( n <= min )
	ERR_REPORT (ERR_LARGER, min, n, 0, 0);
}

void CHECK_INT8 (int32 n);
void CHECK_INT8 (int32 n)
{
  if ( n & 0xFFFFFF00 )
	ERR_REPORT (ERR_INT8, n, 0, 0, 0);
}

void CHECK_INT16 (int32 n);
void CHECK_INT16 (int32 n)
{
  if ( n & 0xFFFF0000 )
	ERR_REPORT (ERR_INT16, n, 0, 0, 0);
}

void CHECK_SELECTOR (int32 n);
void CHECK_SELECTOR (int32 n)
{
  if ( n & ~((int32)SELECTOR_FLAGS) )
	ERR_REPORT (ERR_SELECTOR, n, 0, 0, 0);
}

void CHECK_SUBSTACK (fnt_LocalGraphicStateType* pGS, F26Dot6* pt);
void CHECK_SUBSTACK (fnt_LocalGraphicStateType* pGS, F26Dot6* pt)
{
  int32 base = (int32)(pt - pGS->globalGS->stackBase);
  int32 max = (int32)(pGS->globalGS->maxp->maxStackElements - 1L);

  if (base > max || base < 0L)
	ERR_REPORT (ERR_STACK, base, 0, max, 0);
}

void POP_CHECK (F26Dot6*);
void POP_CHECK (F26Dot6* stackPtr)
{
  F26Dot6 * base = LocalGS.globalGS->stackBase;
  F26Dot6 * max;

  max = base + LocalGS.globalGS->maxp->maxStackElements - 1L;
  if ( stackPtr <= base)
	ERR_REPORT (ERR_STACK, (stackPtr - base - 1L), 0, (max - base), 0);
  return;
}

void PUSH_CHECK (F26Dot6*);
void PUSH_CHECK (F26Dot6* stackPtr)
{
  F26Dot6 * base = LocalGS.globalGS->stackBase;
  F26Dot6 * max;

  max = base + LocalGS.globalGS->maxp->maxStackElements - 1L;
  if ( stackPtr > max )
	ERR_REPORT (ERR_STACK, (stackPtr - base), 0, (max - base), 0);
  return;
}

#define CHECK_POP(s)                (POP_CHECK(s),POP(s))
#define CHECK_PUSH(s, v)            (PUSH_CHECK(s),PUSH(s, v))

#else
#define CHECK_RANGE(a,b,c)
#define CHECK_ASSERTION(a)
#define CHECK_CVT(pgs,b)
#define CHECK_POINT(pgs,b,c)
#define CHECK_CONTOUR(pgs,b,c)
#define CHECK_FDEF(pgs,b)
#define CHECK_PROGRAM(a)
#define CHECK_ELEMENT(pgs,b)
#define CHECK_ELEMENTPTR(pgs,b)
#define CHECK_STORAGE(pgs,b)
#define CHECK_STACK(pgs)
#define CHECK_VECTOR(a,b)
#define CHECK_LARGER(a,b)
#define CHECK_INT8(a)
#define CHECK_INT16(a)
#define CHECK_SELECTOR(a)
#define CHECK_SUBSTACK(pgs,a)
#define CHECK_POP(s)                POP(s)
#define CHECK_PUSH(s, v)            PUSH(s, v)
#endif

/*@@*/

/* ClaudeBe 4/15/98 new secure rasterizer testing of critical errors */
/* errors originally detected by the fstrace callback trace function */
/* moved inside the rasterizer for performance reason */

#ifdef FSCFG_SECURE

#define SECURE_CHECK_FOR_POP(stackPtr, lNumItems) \
 \
  if (stackPtr - (int32)(lNumItems) < LocalGS.globalGS->stackBase) \
{ \
	LocalGS.ercReturn = SECURE_STACK_UNDERFLOW;  /* error returned to client */ \
	return LocalGS.pbyEndInst; \
  } 

#define SECURE_CHECK_FOR_PUSH(stackPtr, lNumItems) \
 \
  if (stackPtr + (int32)(lNumItems) > LocalGS.globalGS->stackMax) \
{ \
	LocalGS.ercReturn = SECURE_STACK_OVERFLOW;  /* error returned to client */ \
	return LocalGS.pbyEndInst; \
  } 

#define SECURE_CHECK_SUBSTACK(stackPtr) \
 \
  if ((stackPtr < LocalGS.globalGS->stackBase) || (stackPtr >= LocalGS.globalGS->stackMax)) \
{ \
	LocalGS.ercReturn = SECURE_INVALID_STACK_ACCESS;  /* error returned to client */ \
	return LocalGS.pbyEndInst; \
  } 

#define SECURE_CHECK_POINT(elem, pt) \
{ \
    if (LocalGS.elements == elem) \
    { \
	  if ((int32)pt >= LocalGS.globalGS->maxp->maxTwilightPoints || \
		 (int32)pt < 0L) \
      { \
	    LocalGS.ercReturn = SECURE_POINT_OUT_OF_RANGE;  /* error returned to client */ \
	    return LocalGS.pbyEndInst; \
      } \
    } \
    else \
    { \
	  if ((int32)pt >= LocalGS.globalGS->maxPointsIncludePhantom || (int32)pt < 0L) \
      { \
	    LocalGS.ercReturn = SECURE_POINT_OUT_OF_RANGE;  /* error returned to client */ \
	    return LocalGS.pbyEndInst; \
      } \
    } \
}

#define SECURE_CHECK_FDEF(fdef) \
{ \
    if ((int32)fdef >= (LocalGS.globalGS->maxp->maxFunctionDefs) || (int32)fdef < 0L) \
    { \
	  LocalGS.ercReturn = SECURE_FDEF_OUT_OF_RANGE;  /* error returned to client */ \
	  return LocalGS.pbyEndInst; \
    } \
}

#define SECURE_CHECK_PROGRAM(pgmIndex) \
{ \
    if (pgmIndex >= MAXPREPROGRAMS) \
    { \
	  LocalGS.ercReturn = SECURE_ERR_FUNCTION_NOT_DEFINED;  /* error returned to client */ \
	  return LocalGS.pbyEndInst; \
    } \
}

#define SECURE_CHECK_ZONE(elem) \
{ /* in theory we should compare with maxp->maxElements but the rasterizer always allocate for MAX_ELEMENTS zones */ \
    if ((int32)elem >= MAX_ELEMENTS || (int32)elem < 0L) \
    { \
	  LocalGS.ercReturn = SECURE_INVALID_ZONE;  /* error returned to client */ \
	  return LocalGS.pbyEndInst; \
    } \
}

#define SECURE_CHECK_FOR_UNITIALIZED_ZONE(elem) \
{ \
	if (LocalGS.globalGS->pgmIndex != GLYPHPROGRAM) \
	/* in the glyph program, both zone (glyph and twilight are initialized */ \
	{ \
	    if (LocalGS.globalGS->pgmIndex != PREPROGRAM || LocalGS.elements != elem ) \
		/* in the pre-program, only the twilight zone is initialized, */ \
		/* in any other zone i.e. font program, none of the zones are initialized */ \
		{ \
	       LocalGS.ercReturn = SECURE_UNITIALIZED_ZONE;  /* error returned to client */ \
	       return LocalGS.pbyEndInst; \
		} \
    } \
}


#define SECURE_CHECK_IDEF_OPCODE(idef) \
{ \
    if ( idef & 0xFFFFFF00 ) \
    { \
	  LocalGS.ercReturn = SECURE_INST_OPCODE_TO_LARGE;  /* error returned to client */ \
	  return LocalGS.pbyEndInst; \
    } \
}

#define SECURE_CHECK_IDEF_OVERFLOW() \
{ \
    if (LocalGS.globalGS->instrDefCount >= LocalGS.globalGS->maxp->maxInstructionDefs) \
    { \
	  LocalGS.ercReturn = SECURE_EXCEEDS_INSTR_DEFS_IN_MAXP;  /* error returned to client */ \
	  return LocalGS.pbyEndInst; \
    } \
}

#define SECURE_CHECK_STORAGE(index) \
{ \
    if ((int32)index >= (LocalGS.globalGS->maxp->maxStorage) || (int32)index < 0L) \
    { \
	  LocalGS.ercReturn = SECURE_STORAGE_OUT_OF_RANGE;  /* error returned to client */ \
	  return LocalGS.pbyEndInst; \
    } \
}

#define SECURE_CHECK_CONTOUR(elem, ctr) \
{ /* The reason in SECURE_CHECK_CONTOUR that we are checking against elem->nc instead of maxContours */ \
	/* is that we will access CE2->sp[contour] and we may try to access a point out of bounds */ \
    if ((int32)ctr < 0L || (int32)ctr >= (elem)->nc) \
    { \
	  LocalGS.ercReturn = SECURE_CONTOUR_OUT_OF_RANGE;  /* error returned to client */ \
	  return LocalGS.pbyEndInst; \
    } \
}

#define SECURE_CHECK_CVT(cvt) \
{ \
    if ((int32)cvt >= (LocalGS.globalGS->cvtCount) || (int32)cvt < 0L) \
    { \
	  LocalGS.ercReturn = SECURE_CVT_OUT_OF_RANGE;  /* error returned to client */ \
	  return LocalGS.pbyEndInst; \
    } \
}

#ifdef FSCFG_FONTOGRAPHER_BUG
#define SECURE_CHECK_CVT_READ_SPECIAL(cvt) \
{ \
    if (((int32)cvt >= (LocalGS.globalGS->cvtCount) && cvt > 255) || (int32)cvt < 0L) \
    { \
	  LocalGS.ercReturn = SECURE_CVT_OUT_OF_RANGE;  /* error returned to client */ \
	  return LocalGS.pbyEndInst; \
    } \
}
#endif // FSCFG_FONTOGRAPHER_BUG

#else

#define SECURE_CHECK_FOR_POP(stackPtr, lNumItems) 
#define SECURE_CHECK_FOR_PUSH(stackPtr, lNumItems) 
#define SECURE_CHECK_SUBSTACK(stackPtr) 
#define SECURE_CHECK_POINT(elem, pt) 
#define SECURE_CHECK_FDEF(fdef) 
#define SECURE_CHECK_PROGRAM(pgmIndex)
#define SECURE_CHECK_ZONE(elem)
#define SECURE_CHECK_IDEF_OPCODE(idef) 
#define SECURE_CHECK_IDEF_OVERFLOW() 
#define SECURE_CHECK_STORAGE(index) 
#define SECURE_CHECK_CONTOUR(elem, ctr) 
#define SECURE_CHECK_CVT(cvt) 
#define SECURE_CHECK_FOR_UNITIALIZED_ZONE(elem) 

#ifdef FSCFG_FONTOGRAPHER_BUG
#define SECURE_CHECK_CVT_READ_SPECIAL(cvt) 
#endif // FSCFG_FONTOGRAPHER_BUG

#endif


#define BIT0( t ) ( (t) & 0x01 )
#define BIT1( t ) ( (t) & 0x02 )
#define BIT2( t ) ( (t) & 0x04 )
#define BIT3( t ) ( (t) & 0x08 )
#define BIT4( t ) ( (t) & 0x10 )
#define BIT5( t ) ( (t) & 0x20 )
#define BIT6( t ) ( (t) & 0x40 )
#define BIT7( t ) ( (t) & 0x80 )

/****** Element Codes *********/
#define SCE0_CODE       0x13
#define SCE1_CODE       0x14
#define SCE2_CODE       0x15
#define SCES_CODE       0x16

/****** Control Codes *********/
#define IF_CODE         0x58
#define ELSE_CODE       0x1B
#define EIF_CODE        0x59
#define ENDF_CODE       0x2d
#define MD_CODE         0x49

#ifdef FSCFG_SUBPIXEL
	// For SubPixel, rather than deciding within the rounding function whether we're currently
	// running SubPixel at all, and whether we're in the SubPixel-specific direction, we
	// install the appropriate version of the rounding function into the local ParameterBlock.
	// There are two parameters that determine this installation:
	// - a boolean "inSubPixelDirection" in LocalGS, set whenever the pv changes (eg. in SVTCA[X])
	// - an enum "roundState" in localParBlock, set whenever rounding state changes (eg. in RTG[])
	// It is necessary to have variables for these two parameters, because the states they
	// represent change independently, yet the round function depends on both parameters.
	// Whenever any of these two parameters change, we index the matrix "itrp_RoundFunction"
	// below to install the correct rounding function into the local ParameterBlock. 
	// Exception: itrp_RoundDownToGridSP, the SubPixel version of the RDTG function, inspects
	// the pv and actually rounds down to grid if pv == dpv. (cf. comments in itrp_RoundDownToGridSP)
	
	typedef enum { inRtdg = 0, inRdtg, inRutg, inRtg, inRthg, inRoff, inSRnd, inS45Rnd } RoundFunction;
	#ifndef FSCFG_NO_INITIALIZED_DATA
	const
	#endif
		  FntRoundFunc itrp_RoundFunction[2][8]
	#ifndef FSCFG_NO_INITIALIZED_DATA
												=  {{itrp_RoundToDoubleGrid,   itrp_RoundDownToGrid,   itrp_RoundUpToGrid,   itrp_RoundToGrid,   itrp_RoundToHalfGrid,   itrp_RoundOff,   itrp_SuperRound, itrp_Super45Round},
													{itrp_RoundToDoubleGridSP, itrp_RoundDownToGridSP, itrp_RoundUpToGridSP, itrp_RoundToGridSP, itrp_RoundToHalfGridSP, itrp_RoundOffSP, itrp_SuperRound, itrp_Super45Round}}
	#endif
	;
	// Following are two helper macros to update the aforementioned parameters "inSubPixelDirection"
	// and "roundState", along with installing the updated rounding function. The purpose of these
	// macros is to assert correspondence of the two parameters with the rounding function by system,
	// rather than by industriousness. The first helper macro is used whenever the projection vector
	// changes (eg. in SVTCA[X]) which changes whether or not we're in the SubPixel-specific direction.
	// The second helper macro is used whenever the round state changes (eg. in RTG[]).

	// Two versions of the first helper macro to update
	// - localGS.inSubPixelDirection (flag)
	// - localParBlock.RoundValue (func ptr)
	// as a result of a change of the projection vector.
	// We're using two different macros merely because VC wouldn't let us nest an #ifdef within a #define
	#ifdef NoVirtRoundInPrep
		#define UpdateRoundFunctionByProjectionVector(localGS)											\
			{																							\
				fnt_ParameterBlock *par = &(localGS).globalGS->localParBlock;							\
																										\
				(localGS).inSubPixelDirection = RunningSubPixel((localGS).globalGS) && InSubPixelDirection(localGS);							\
				par->RoundValue = itrp_RoundFunction[(localGS).inSubPixelDirection && (Tuned4SubPixel((localGS).globalGS) || (localGS).globalGS->pgmIndex != PREPROGRAM)][par->roundState];	\
			}
	#else
		#define UpdateRoundFunctionByProjectionVector(localGS)											\
			{																							\
				fnt_ParameterBlock *par = &(localGS).globalGS->localParBlock;							\
																										\
				(localGS).inSubPixelDirection = RunningSubPixel((localGS).globalGS) && InSubPixelDirection(localGS);							\
				par->RoundValue = itrp_RoundFunction[(localGS).inSubPixelDirection][par->roundState];	\
			}
	#endif

	// Second helper macro to update
	// - localParBlock.roundState (enum)
	// - localParBlock.RoundValue (func ptr)
	// as a result of a change of the round state.
	#define UpdateRoundFunctionByRoundState(localGS,state)											\
		{																							\
			fnt_ParameterBlock *par = &(localGS).globalGS->localParBlock;							\
																									\
			par->roundState = (state);																\
			par->RoundValue = itrp_RoundFunction[(localGS).inSubPixelDirection][par->roundState];	\
		}

	// Helper macro to used to determine whether or not to skip a delta instruction or function.
	// In backwardscompatibility mode, deltas are skipped if they are in SubPixel direction or
	// if they are applied to an untouched/unmoved point or if they are postIUP. Additionally,
	// deltas are skipped in composites if they are in SubPixel direction for proper centering
	// and vertical positioning of diacritical marks.
	// See also comments in itrp_SHP_Common.
	#ifdef InlineDeltasOnly
		#define AMovedPointInNonSPDirection(localGS,zonePtr,pointNum)							\
			((uint16)(!VerticalSPDirection((localGS).globalGS) ?								\
					  ProjVectInY((localGS)) && ((localGS).globalGS->bCompositeGlyph || ((localGS).zonePtr->f[(pointNum)] & YMOVED && !((localGS).globalGS->subPixelCompatibilityFlags & SPCF_iupyCalled))) :	\
					  ProjVectInX((localGS)) && ((localGS).globalGS->bCompositeGlyph || ((localGS).zonePtr->f[(pointNum)] & XMOVED && !((localGS).globalGS->subPixelCompatibilityFlags & SPCF_iupxCalled)))))
	#endif

#endif // FSCFG_SUBPIXEL

// Macros for rounding to grid etc. The purpose of these macros is to make the code more readable
// in cases such as MIRP, where rounding is performed inline for optimization reasons.
// - All rounding is applied to non-negative numbers only, negative numbers have their sign changed
//   before and after. 
// - Engine compensation is added to the unrounded number. Notice that substituting (literal) 0 for
//   engine will be optimized by the compiler
// - Rounding, in principle, follows the pattern in RTG:
//   - add half the "resolution" (this corresponds to adding 0.5)
//   - mask with the complement of "resolution"-minus-1 (this corresponds to a truncated division by
//	   "resolution", immediately followed by a multiplication by the same amount)
//	   Notice that masking only works with powers of two for the resolution

// for round-to-double-grid, we simply use half the resolution
#define RTDG(x,engine,resolution)	\
	if (x >= 0) {					\
		x += engine;				\
		x += resolution / 4;		\
		x &= ~(resolution / 2 - 1);	\
	} else {						\
		x = -x;						\
		x += engine;				\
		x += resolution / 4;		\
		x &= ~(resolution / 2 - 1);	\
		x = -x;						\
	}

// for round-down-to-grid, we skip the part that adds 0.5
#define RDTG(x,engine,resolution)	\
	if (x >= 0) {					\
		x += engine;				\
		x &= ~(resolution - 1);		\
	} else {						\
		x = -x;						\
		x += engine;				\
		x &= ~(resolution - 1);		\
		x = -x;						\
	}

// for round-up-to-grid, we add "0.9999" instead of 0.5
#define RUTG(x,engine,resolution)	\
	if (x >= 0) {					\
		x += engine;				\
		x += resolution - 1;		\
		x &= ~(resolution - 1);		\
	} else {						\
		x = -x;						\
		x += engine;				\
		x += resolution - 1;		\
		x &= ~(resolution - 1);		\
		x = -x;						\
	}

#define RTG(x,engine,resolution)	\
	if (x >= 0) {					\
		x += engine;				\
		x += resolution / 2;		\
		x &= ~(resolution - 1);		\
	} else {						\
		x = -x;						\
		x += engine;				\
		x += resolution / 2;		\
		x &= ~(resolution - 1);		\
		x = -x;						\
	}

// for round-to-half-grid, we first round-down-to-grid, then add 0.5
#define RTHG(x,engine,resolution)	\
	if (x >= 0) {					\
		x += engine;				\
		x &= ~(resolution - 1);		\
		x += resolution / 2;		\
	} else {						\
		x = -x;						\
		x += engine;				\
		x &= ~(resolution - 1);		\
		x += resolution / 2;		\
		x = -x;						\
	}

// for round-off, we have to do the engine compensation part only
#define ROFF(x,engine,resolution)	\
	if (x >= 0) {					\
		x += engine;				\
	} else {						\
		x -= engine;				\
	}


// Macro for testing against cvt cut-in. The purpose of this macro is to make the code more readable
// in cases such as MIRP, where this test is performed in various places in accordance with #defines
// and flags. Notice that substituting (literal) 1 for overscale will be optimized by the compiler.
#define CVTCI(parameterBlock,distance,originalDistance,overscale)													\
	{																												\
		F26Dot6 difference = distance - originalDistance;															\
		difference *= overscale;																					\
		if (difference > parameterBlock->wTCI || difference < -parameterBlock->wTCI) /* not within cvt cut-in? */	\
			distance = originalDistance;																			\
	}

/* Set default values for all variables in globalGraphicsState DefaultParameterBlock
 *      Eventually, we should provide for a Default preprogram that could optionally be 
 *      run at this time to provide a different set of default values.
 */
ErrorCode itrp_SetDefaults (
	void *  pvGlobalGS,
	Fixed   fxPixelDiameter)
{
  fnt_ParameterBlock *par;
  fnt_GlobalGraphicStateType *  globalGS;

  globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

  par = &globalGS->defaultParBlock;

#ifdef FSCFG_SUBPIXEL
  par->roundState = inRtg;
  par->RoundValue = itrp_RoundFunction[RunningSubPixel(globalGS)
#ifdef NoVirtRoundInPrep
	// at this point, globalGS->pgmIndex is not defined. However, we may assume that we're called
	// exclusively from fsg_RunPreProgram, hence we assume that we're about to do the pre-program
	&& Tuned4SubPixel(globalGS)
#endif
	][par->roundState]; // at this point, LocalGS.inSubPixelDirection may not be defined
#else
  par->RoundValue = itrp_RoundToGrid;
#endif
  par->minimumDistance = FNT_PIXELSIZE;
  par->wTCI = FNT_PIXELSIZE * 17 / 16;
  par->sWCI = 0;
  par->sW   = 0;
  par->autoFlip = true;
  par->deltaBase = 9;
  par->deltaShift = 3;
  par->angleWeight = 128;
  par->scanControl = 0;
  par->instructControl = 0;

/* Set up the engine compensation array for the interpreter */
/* This will be indexed into by the booleans in some instructions */
  globalGS->engine[0] = globalGS->engine[3] = 0;                     /* Grey and ? distance */
  globalGS->engine[1] = FIXEDTODOT6 (FIXEDSQRT2 - fxPixelDiameter);  /* Black distance */
  globalGS->engine[2] = -globalGS->engine[1];                        /* White distance */

  return NO_ERR;
}

/************************************************************************/

/*
 * Illegal instruction trap
 */
FS_PRIVATE uint8* itrp_IllegalInstruction (IPARAM)
{
	FS_UNUSED_PARAMETER(lOpCode);
	FS_UNUSED_PARAMETER(pbyInst);

	LocalGS.ercReturn = UNDEFINED_INSTRUCTION_ERR;  /* returned to client */
	return LocalGS.pbyEndInst;                      /* stops innerEx loop */
}

/************************************************************************/

/*  Scale vector (x,y) to unit length in 2.14   rewrite - 1/25/93 - deanb */

FS_PUBLIC void itrp_Normalize (F26Dot6 x, F26Dot6 y, VECTOR *pVec)
{
	Fract fLength;
	int32 lSumOfSquares;
	 int32 lShift;

	CHECK_RANGE (x, -32768L << 6, 32767L << 6);
	CHECK_RANGE (y, -32768L << 6, 32767L << 6);


	if ((x == 0L) && (y == 0L))             /* if null vector in */
	{
		pVec->x = ONEVECTOR;                /* default to unit x vector */
		pVec->y = 0;
	}
	else
	{
		if ((x < 32767L) && (x > -32768L) && (y < 32767L) && (y > -32768L))
		{
			lSumOfSquares = (x * x) + (y * y);  
			
				lShift = 8 * sizeof(Fract) - 17; /* to get x and y to 2.30 */
			while (lSumOfSquares < 0x20000000L)
			{
				lSumOfSquares <<= 2;        /* maximize precision */
					 lShift++;
			}
				x <<= lShift;
				y <<= lShift;                         /* keep x and y in step */
		}
		else
		{
			while ((x < 0x20000000L) && (x > -0x20000000L) && (y < 0x20000000L) && (y > -0x20000000L))
			{
				x <<= 1;
				y <<= 1;
			}
			lSumOfSquares = FracMul(x, x) + FracMul(y, y);
		}
		fLength = FracSqrt(lSumOfSquares);
		pVec->x = ROUNDFIXTOINT (FracDiv(x, fLength));
		pVec->y = ROUNDFIXTOINT (FracDiv(y, fLength));
	}
}


/******************** BEGIN Internal Rounding Routines ***************************/

F26Dot6 itrp_RoundToDoubleGrid (GSP F26Dot6 xin, F26Dot6 engine) {
	F26Dot6 x = xin;

	RTDG(x,engine,FNT_PIXELSIZE);
	if (( (int32) (xin ^ x)) < 0 && xin) {
		x = 0; /* The sign flipped, make zero */
	}
	return x;
} // itrp_RoundToDoubleGrid

#ifdef FSCFG_SUBPIXEL
F26Dot6 itrp_RoundToDoubleGridSP (GSP F26Dot6 xin, F26Dot6 engine) {
	F26Dot6 x = xin;

	engine /= ENGINE_COMP_OVERSCALE;
	RTDG(x,engine,VIRTUAL_PIXELSIZE_RTDG);
	if (( (int32) (xin ^ x)) < 0 && xin) {
		x = 0; /* The sign flipped, make zero */
	}
	return x;
} // itrp_RoundToDoubleGridSP
#endif


F26Dot6 itrp_RoundDownToGrid (GSP F26Dot6 xin, F26Dot6 engine) {
	F26Dot6 x = xin;

	RDTG(x,engine,FNT_PIXELSIZE);
	if (( (int32) (xin ^ x)) < 0 && xin) {
		x = 0; /* The sign flipped, make zero */
	}
	return x;
} // itrp_RoundDownToGrid

#ifdef FSCFG_SUBPIXEL
F26Dot6 itrp_RoundDownToGridSP (GSP F26Dot6 xin, F26Dot6 engine) {
#ifdef RDTGRoundsDownToGrid
	// Historically, if a point to be aligned was away by 1.5 degrees or more from the line to which to align, the TypemanTalk
	// Align has translated to SPVTL, followed by RDTG and MDRP. This has a major problem: The MDRP instruction uses the set pv
	// to measure the original distance on the UNINSTRUCTED outline. This gives us an "original" distance which is more or less
	// wrong, depending on how far the reference point has moved already (notice that it is most likely that the reference point
	// has moved somewhat in x and in y before the alignee gets to be aligned). Subsequently, when MDRP gets to move the point,
	// it uses the same pv again, but this time around on the INSTRUCTED outline, in order to determine how far the point has to
	// be moved in the end. Luckily, this is used in connection with RDTG, which is applied to the "original" distance, and
	// thereby often reduces the "original" distance to 0, which often is closer the the correct original distance than the one
	// obtained by using the pv on the uninstructed outline.
	//   In SubPixel, however, these erroneous "original" distances would be rounded down to the nearest 1/16 of a pixel, and
	// with that become highly visible (a distance of just under 1 pixel, which is what gets rounded down to 0 in b/w, is too
	// large a distance to be ignored in SP). Therefore, we have to make an exception here. The recently introduced TypemanTalk
	// DAlign command, in contrast, uses the DUAL projection vector to measure the original distance on the UNINSTRUCTED outline,
	// which gives us the correct original distance. Therefore the exception is to test whether we're using the PV (in which case
	// we fall back onto the b/w rounding) or not (in which case we're using the SP rounding).
	if (Tuned4SubPixel(LocalGS.globalGS) || LocalGS.OldProject != itrp_Project) { // we're using the dual projection vector
#endif
		F26Dot6 x = xin;

		engine /= ENGINE_COMP_OVERSCALE;
		RDTG(x,engine,VIRTUAL_PIXELSIZE_RDTG);
		if (( (int32) (xin ^ x)) < 0 && xin) {
			x = 0; /* The sign flipped, make zero */
		}
		return x;
#ifdef RDTGRoundsDownToGrid
	} else { // we're using the "normal" projection vector
		return itrp_RoundDownToGrid(GSA xin,engine);
	}
#endif
} // itrp_RoundDownToGridSP
#endif


F26Dot6 itrp_RoundUpToGrid (GSP F26Dot6 xin, F26Dot6 engine) {
	F26Dot6 x = xin;

	RUTG(x,engine,FNT_PIXELSIZE);
	if (( (int32) (xin ^ x)) < 0 && xin) {
		x = 0; /* The sign flipped, make zero */
	}
	return x;
} // itrp_RoundUpToGrid

#ifdef FSCFG_SUBPIXEL
F26Dot6 itrp_RoundUpToGridSP (GSP F26Dot6 xin, F26Dot6 engine) {
	F26Dot6 x = xin;

	engine /= ENGINE_COMP_OVERSCALE;
	RUTG(x,engine,VIRTUAL_PIXELSIZE_RUTG);
	if (( (int32) (xin ^ x)) < 0 && xin) {
		x = 0; /* The sign flipped, make zero */
	}
	return x;
} // itrp_RoundUpToGridSP
#endif


F26Dot6 itrp_RoundToGrid (GSP F26Dot6 xin, F26Dot6 engine) {
	F26Dot6 x = xin;

	RTG(x,engine,FNT_PIXELSIZE);
	if (( (int32) (xin ^ x)) < 0 && xin) {
		x = 0; /* The sign flipped, make zero */
	}
	return x;
} // itrp_RoundToGrid

#ifdef FSCFG_SUBPIXEL
F26Dot6 itrp_RoundToGridSP (GSP F26Dot6 xin, F26Dot6 engine) {
	F26Dot6 x = xin;

	engine /= ENGINE_COMP_OVERSCALE;
	RTG(x,engine,VIRTUAL_PIXELSIZE_RTG);
	if (( (int32) (xin ^ x)) < 0 && xin) {
		x = 0; /* The sign flipped, make zero */
	}
	return x;
} // itrp_RoundToGridSP
#endif


F26Dot6 itrp_RoundToHalfGrid (GSP F26Dot6 xin, F26Dot6 engine) {
	F26Dot6 x = xin;

	RTHG(x,engine,FNT_PIXELSIZE);
	if (((xin ^ x)) < 0 && xin) {
		x = xin > 0 ? FNT_PIXELSIZE / 2 : -FNT_PIXELSIZE / 2; /* The sign flipped, make equal to smallest valid value */
	}
	return x;
} // itrp_RoundToHalfGrid

#ifdef FSCFG_SUBPIXEL
F26Dot6 itrp_RoundToHalfGridSP (GSP F26Dot6 xin, F26Dot6 engine) {
	F26Dot6 x = xin;

	engine /= ENGINE_COMP_OVERSCALE;
	RTHG(x,engine,VIRTUAL_PIXELSIZE_RTHG);
	if (((xin ^ x)) < 0 && xin) {
		x = xin > 0 ? VIRTUAL_PIXELSIZE_RTHG / 2 : -VIRTUAL_PIXELSIZE_RTHG / 2; /* The sign flipped, make equal to smallest valid value */
	}
	return x;
} // itrp_RoundToHalfGridSP
#endif


/*
 * Internal rounding routine
 */
F26Dot6 itrp_RoundOff (GSP F26Dot6 xin, F26Dot6 engine) {
	F26Dot6 x = xin;

	ROFF(x,engine,FNT_PIXELSIZE);
	if (( (int32) (xin ^ x)) < 0 && xin) {
		x = 0; /* The sign flipped, make zero */
	}
	return x;
} // itrp_RoundOff

/*
 * Internal rounding routine
 */
#ifdef FSCFG_SUBPIXEL
F26Dot6 itrp_RoundOffSP (GSP F26Dot6 xin, F26Dot6 engine) {
	F26Dot6 x = xin;

	engine /= ENGINE_COMP_OVERSCALE;
	ROFF(x,engine,VIRTUAL_PIXELSIZE_ROFF);
	if (( (int32) (xin ^ x)) < 0 && xin) {
		x = 0; /* The sign flipped, make zero */
	}
	return x;
} // itrp_RoundOffSP
#endif


/************************************************************************/

/*
 * Internal rounding routine
 */
F26Dot6 itrp_SuperRound (GSP  F26Dot6 xin, F26Dot6 engine) { // B.St. to check
  F26Dot6 x = xin;
  fnt_ParameterBlock *pb = &LocalGS.globalGS->localParBlock;

  if (x >= 0) 
  {
	x += engine;
	x += pb->threshold - pb->phase;
	x &= pb->periodMask;
	x += pb->phase;
  } 
  else 
  {
	x = -x;
	x += engine;
	x += pb->threshold - pb->phase;
	x &= pb->periodMask;
	x += pb->phase;
	x = -x;
  }
  if (( (int32) (xin ^ x)) < 0 && xin) 
  {
	x = xin > 0 ? pb->phase : -pb->phase; /* The sign flipped, make equal to smallest phase */
  }
  return x;
}


/*
 * Internal rounding routine
 */
F26Dot6 itrp_Super45Round (GSP  F26Dot6 xin, F26Dot6 engine) { // B.St. to check
  F26Dot6 x = xin;
  fnt_ParameterBlock *pb = &LocalGS.globalGS->localParBlock;

  if (x >= 0) 
  {
	x += engine;
	x += pb->threshold - pb->phase;
	x = (F26Dot6) VECTORDIV (x, pb->period45);
	x  &= ~ (FNT_PIXELSIZE - 1);
	x = (F26Dot6) VECTORMUL (x, pb->period45);
	x += pb->phase;
  } 
  else 
  {
	x = -x;
	x += engine;
	x += pb->threshold - pb->phase;
	x = (F26Dot6) VECTORDIV (x, pb->period45);
	x  &= ~ (FNT_PIXELSIZE - 1);
	x = (F26Dot6) VECTORMUL (x, pb->period45);
	x += pb->phase;
	x = -x;
  }
  if (((xin ^ x)) < 0 && xin)
  {
	x = xin > 0 ? pb->phase : -pb->phase; /* The sign flipped, make equal to smallest phase */
  }
  return x;
}


/******************** END Rounding Routines ***************************/


/* 3-versions ************************************************************************/

/*
 * Moves the point in element by delta (measured against the projection vector)
 * along the freedom vector.
 */

FS_PRIVATE void itrp_MovePoint (GSP fnt_ElementType *element, int32 point, F26Dot6 delta)
{
	VECTORTYPE pfProj;
	VECTORTYPE fx;
	VECTORTYPE fy;
	  
	pfProj = LocalGS.pfProj;
	fx = LocalGS.free.x;
	fy = LocalGS.free.y;

	CHECK_POINT (&LocalGS, element, point);

	if (pfProj != ONEVECTOR)
	{
		if (fx) 
		{
			if (pfProj == fx)                   /* if proj.x = 1 */
			{
				element->x[point] += delta;
			}
			else
			{
				element->x[point] += LongMulDiv (delta, (int32)fx, (int32)pfProj);
			}
			element->f[point] |= XMOVED;
		}
		if (fy) 
		{
			if (pfProj == fy)                   /* if proj.y = 1 */
			{
				element->y[point] += delta;
			}
			else
			{
				element->y[point] += LongMulDiv (delta, (int32)fy, (int32)pfProj);
			}
			element->f[point] |= YMOVED;
		}
	}
	else
	{
		if (fx) 
		{
			element->x[point] += VECTORMUL (delta, fx);
			element->f[point] |= XMOVED;
		}
		if (fy) 
		{
			element->y[point] += VECTORMUL (delta, fy);
			element->f[point] |= YMOVED;
		}
	}
}


/*
 * For use when the projection and freedom vectors coincide along the x-axis.
 */

FS_PRIVATE void itrp_XMovePoint (GSP fnt_ElementType*element, int32 point, F26Dot6 delta)
{
  CHECK_POINT (&LocalGS, element, point);
  element->x[point] += delta;
  element->f[point] |= XMOVED;
}


/*
 * For use when the projection and freedom vectors coincide along the y-axis.
 */
FS_PRIVATE void itrp_YMovePoint (GSP fnt_ElementType *element, int32 point, F26Dot6 delta)
{
  CHECK_POINT (&LocalGS, element, point);
  element->y[point] += delta;
  element->f[point] |= YMOVED;
}

/*
 * projects x and y into the projection vector.
 */
FS_PRIVATE F26Dot6 itrp_Project (GSP F26Dot6 x, F26Dot6 y)
{
  return (F26Dot6) (VECTORMUL (x, LocalGS.proj.x) + VECTORMUL (y, LocalGS.proj.y));
}


/*
 * projects x and y into the old projection vector.
 */
FS_PRIVATE F26Dot6 itrp_OldProject (GSP F26Dot6 x, F26Dot6 y)
{
  return (F26Dot6) (VECTORMUL (x, LocalGS.oldProj.x) + VECTORMUL (y, LocalGS.oldProj.y));
}


/*
 * Projects when the projection vector is along the x-axis
 */
F26Dot6 itrp_XProject (GSP F26Dot6 x, F26Dot6 y)
{
  FS_UNUSED_PARAMETER(y);

  return (x);
}


/*
 * Projects when the projection vector is along the y-axis
 */
F26Dot6 itrp_YProject (GSP F26Dot6 x, F26Dot6 y)
{
  FS_UNUSED_PARAMETER(x);

  return (y);
}


/*************************************************************************/

/*** Compensation for Transformations ***/

/*
* Internal support routine, keep this guy FAST!!!!!!!          <3>
*/
FS_PRIVATE Fixed itrp_GetCVTScale (GSP0)
{
  VECTORTYPE pvx, pvy;
  fnt_GlobalGraphicStateType *globalGS = LocalGS.globalGS;
  Fixed sySq, sxSq, strSq;

/* Do as few Math routines as possible to gain speed */

  pvx = LocalGS.proj.x;
  pvy = LocalGS.proj.y;
  if (pvy) 
  {
	if (pvx)
	{
	  if (LocalGS.cvtDiagonalStretch == 0)    /* cache is now invalid */
	  {
		pvy = VECTORDOT (pvy, pvy);
		pvx = VECTORDOT (pvx, pvx);
		sySq = FixMul (globalGS->cvtStretchY, globalGS->cvtStretchY);
		sxSq = FixMul (globalGS->cvtStretchX, globalGS->cvtStretchX);

		strSq = FixMul (VECTOR2FIX(pvx),sxSq) + FixMul (VECTOR2FIX(pvy),sySq);
		if  (strSq > ONEFIX)      /* Never happens! */
		  return ONEFIX;

		/* Convert 16.16 to 2.30, compute square root, round to 16.16 */
		LocalGS.cvtDiagonalStretch = (FracSqrt (strSq<<14) + (1<<13)) >> 14;
	  }
	  return LocalGS.cvtDiagonalStretch;
	}
	else        /* pvy == +1 or -1 */
	  return globalGS->cvtStretchY;
  }
  else  /* pvx == +1 or -1 */
	return globalGS->cvtStretchX;
}


/*      Functions for function pointer in local graphic state
*/

FS_PRIVATE F26Dot6 itrp_GetCVTEntryFast (GSP int32 n)
{
  CHECK_CVT (&LocalGS, n);
  return LocalGS.globalGS->controlValueTable[ n ];
}


FS_PRIVATE F26Dot6 itrp_GetCVTEntrySlow (GSP int32 n)
{
  Fixed scale;

  CHECK_CVT (&LocalGS, n);
  scale = itrp_GetCVTScale (GSA0);
  return (F26Dot6) (FixMul (LocalGS.globalGS->controlValueTable[ n ], scale));
}


FS_PRIVATE F26Dot6 itrp_GetSingleWidthFast (GSP0)
{
  return LocalGS.globalGS->localParBlock.scaledSW;
}


/*
 *
 */
FS_PRIVATE F26Dot6 itrp_GetSingleWidthSlow (GSP0)
{
  Fixed scale;

  scale = itrp_GetCVTScale (GSA0);
  return (F26Dot6) (FixMul (LocalGS.globalGS->localParBlock.scaledSW, scale));
}


/*************************************************************************/

FS_PRIVATE void itrp_ChangeCvtFast (GSP fnt_ElementType*elem, int32 number, F26Dot6 delta)
{
  FS_UNUSED_PARAMETER(elem);
  CHECK_CVT (&LocalGS, number);
  LocalGS.globalGS->controlValueTable[ number ] += delta;
}



/*************************************************************************/

FS_PRIVATE void itrp_ChangeCvtSlow (GSP fnt_ElementType*elem, int32 number, F26Dot6 delta)
{
  FS_UNUSED_PARAMETER(elem);

  CHECK_CVT (&LocalGS, number);

  delta = FixDiv (delta, itrp_GetCVTScale(GSA0));
  LocalGS.globalGS->controlValueTable[ number ] += delta;
}

/*************************************************************************/

/*
 * This is the tracing interpreter.
 */
FS_PRIVATE void itrp_InnerTraceExecute (GSP uint8 *pbyInst, uint8 *pbyEndInst)
{
	int32 lOpCode;

	LocalGS.pbyEndInst = pbyEndInst;                /* for illegal instruction */
	LocalGS.pbyStartInst = pbyInst;                /* to detect jump before the begining */

	if (pbyInst < pbyEndInst)
	{
		ERR_START ();
		while ((pbyInst < pbyEndInst) && (LocalGS.TraceFunc != NULL))
		{
			LocalGS.insPtr = pbyInst;               /* save for client */
			LocalGS.opCode = *pbyInst;              /* save for client */
			ERR_RECORD (*pbyInst);
			LocalGS.TraceFunc (&LocalGS, pbyEndInst);
			if (LocalGS.TraceFunc == NULL)          /* allow client to break out */
			{
				break;
			}
			lOpCode = (int32)*pbyInst;
			pbyInst++;
			pbyInst = function[ lOpCode ] (GSA pbyInst, lOpCode);
			ERR_BREAK ();
		}
		ERR_END ();
	}
}

/*************************************************************************/

/*
 * This is the fast non-tracing interpreter inner loop.
 */

FS_PRIVATE void itrp_InnerExecute (GSP uint8 *pbyInst, uint8 *pbyEndInst)
{
	int32 lOpCode;

	ERR_START ();
	
	LocalGS.pbyEndInst = pbyEndInst;                /* for illegal instruction */
	LocalGS.pbyStartInst = pbyInst;                /* to detect jump before the begining */
	
	while (pbyInst < pbyEndInst)
	{
		ERR_RECORD (*pbyInst);
			  
		lOpCode = (int32)*pbyInst;  /* opCode no longer saved in LocalGS */
		pbyInst++;

		pbyInst = function[ lOpCode ] (GSA pbyInst, lOpCode);
		ERR_BREAK ();
	}
	ERR_END ();
}

/*************************************************************************/


#ifdef FSCFG_DEBUG
FS_PRIVATE F26Dot6 itrp_GetSingleWidthNil (GSP0);
FS_PRIVATE F26Dot6 itrp_GetCVTEntryNil (GSP int32 n);

FS_PRIVATE F26Dot6 itrp_GetSingleWidthNil (GSP0)
{
  ERR_REPORT (ERR_GETSINGLEWIDTHNIL, 0, 0, 0, 0);
  return 0;
}

FS_PRIVATE F26Dot6 itrp_GetCVTEntryNil (GSP int32 n)
{
  ERR_REPORT (ERR_GETCVTENTRYNIL, 0, 0, 0, 0);
  return 0;
}
#endif

/*************************************************************************/

FS_PUBLIC ErrorCode  itrp_ExecuteFontPgm(
	fnt_ElementType *   pTwilightElement,
	fnt_ElementType *   pGlyphElement,
	void *              pvGlobalGS,
	 FntTraceFunc           TraceFunc)
{
	fnt_GlobalGraphicStateType *    globalGS;

#ifdef FSCFG_SECURE
	int32 i;
#endif // FSCFG_SECURE

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	globalGS->instrDefCount = 0;        /* none allocated yet, always do this, even if there's no fontProgram */
	globalGS->init          = TRUE;
	globalGS->pgmIndex = FONTPROGRAM;

	/* To avoid accessing unitialized memory when setting LocalGS.MIRPCode */
    globalGS->engine[0] = globalGS->engine[3] = 0;                     /* Grey and ? distance */
    globalGS->engine[1] = 0;  /* Black distance */
    globalGS->engine[2] = 0;                        /* White distance */

#ifdef FSCFG_SUBPIXEL
		// init since we don't do itrp_SetDefaults prior to executing the fpgm
    globalGS->localParBlock.roundState = inRtg;
    globalGS->localParBlock.RoundValue = itrp_RoundToGrid;

    globalGS->subPixelCompatibilityFlags = 0;
    globalGS->numDeltaFunctionsDetected = 0;
#endif

#ifdef FSCFG_SECURE
	/* initialize globalGS->funcDef[...].pgmIndex with MAXPREPROGRAMS to detect calls to undefined functions */
	for (i = 0; i < globalGS->maxp->maxFunctionDefs; i++)
	{
		globalGS->funcDef[i].pgmIndex = MAXPREPROGRAMS;

	}
#endif // FSCFG_SECURE

	if (globalGS->pgmList[FONTPROGRAM].Instruction)
	{
		return itrp_Execute (
			pTwilightElement,
			pGlyphElement,
			globalGS->pgmList[FONTPROGRAM].Instruction,
			globalGS->pgmList[FONTPROGRAM].Instruction +
				globalGS->pgmList[FONTPROGRAM].Length,
			globalGS,
			TraceFunc);
	}
	return NO_ERR;
}

/*************************************************************************/

FS_PUBLIC ErrorCode  itrp_ExecutePrePgm(
	fnt_ElementType *   pTwilightElement,
	fnt_ElementType *   pGlyphElement,
	void *              pvGlobalGS,
	 FntTraceFunc           TraceFunc)
{
	ErrorCode   result;
	fnt_GlobalGraphicStateType *    globalGS;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	globalGS->init          = TRUE;
	globalGS->localParBlock = globalGS->defaultParBlock;    /* copy gState parameters */

	globalGS->pgmIndex = PREPROGRAM;

	if (globalGS->pgmList[PREPROGRAM].Instruction)
	{
		result = itrp_Execute (
			pTwilightElement,
			pGlyphElement,
			globalGS->pgmList[PREPROGRAM].Instruction,
			globalGS->pgmList[PREPROGRAM].Instruction + globalGS->pgmList[PREPROGRAM].Length,
			globalGS,
			TraceFunc);
	}
	else
	{
		result = NO_ERR;
	}

	if (! (globalGS->localParBlock.instructControl & DEFAULTFLAG))
		globalGS->defaultParBlock = globalGS->localParBlock;    /* change default parameters */

	return result;
}

/*************************************************************************/

FS_PUBLIC ErrorCode  itrp_ExecuteGlyphPgm(
	fnt_ElementType *   pTwilightElement,
	fnt_ElementType *   pGlyphElement,
	uint8 *             ptr,
	uint8 *    eptr,
	void *              pvGlobalGS,
	 FntTraceFunc           TraceFunc,
	uint16 *            pusScanType,
	uint16 *            pusScanControl,
	boolean *           pbChangeScanControl)
{
	ErrorCode                       result;
	fnt_GlobalGraphicStateType *    globalGS;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	result = NO_ERR;

	globalGS->init          = FALSE;
	globalGS->pgmIndex		= GLYPHPROGRAM;
	globalGS->localParBlock = globalGS->defaultParBlock;    /* default parameters for glyphs */
	
	if (!(globalGS->localParBlock.instructControl & NOGRIDFITFLAG))
	{
		result = itrp_Execute (
			pTwilightElement,
			pGlyphElement,
			ptr,
			eptr,
			globalGS,
			TraceFunc);
	}
	*pbChangeScanControl = (globalGS->localParBlock.scanControl !=
						   globalGS->defaultParBlock.scanControl);
	 *pusScanControl = FS_LOWORD(globalGS->localParBlock.scanControl);
	 *pusScanType =  FS_HIWORD(globalGS->localParBlock.scanControl);

	return result;
}

/*************************************************************************/

/*
 * Executes the font instructions.
 *
 * Parameter Description
 *
 * elements points to the character elements. Element 0 is always
 * reserved and not used by the actual character.
 *
 * ptr points at the first instruction.
 * eptr points to right after the last instruction
 *
 * globalGS points at the global graphics state
 *
 * TraceFunc is pointer to a callback functioned called with a pointer to the
 *              local graphics state if TraceFunc is not null.
 *
 * Note: The stuff globalGS is pointing at must remain intact
 *       between calls to this function.
 */
FS_PRIVATE ErrorCode itrp_Execute (
	fnt_ElementType *               pTwilightElement,
	fnt_ElementType *               pGlyphElement,
	uint8 *                         ptr,
	uint8 *                         eptr,
	fnt_GlobalGraphicStateType *    globalGS,
	 FntTraceFunc                           TraceFunc)

{
#ifdef FSCFG_REENTRANT
	fnt_LocalGraphicStateType thisLocalGS;
	fnt_LocalGraphicStateType* pLocalGS = &thisLocalGS;
#endif
	fnt_ElementType       aElements[MAX_ELEMENTS];

	MEMCPY((void*)&(aElements[TWILIGHTZONE]), (void*)pTwilightElement, sizeof (fnt_ElementType));
	MEMCPY((void*)&(aElements[GLYPHELEMENT]), (void*)pGlyphElement, sizeof (fnt_ElementType));
	
	STAT_ON_FNTEXEC;                        /* start STAT timer */    
	
	LocalGS.globalGS = globalGS;            /* init Local Graphics State */
	LocalGS.elements = aElements;
	LocalGS.Pt0 = 0; 
	LocalGS.Pt1 = 0; 
	LocalGS.Pt2 = 0;
	LocalGS.CE0 = &aElements[GLYPHELEMENT];
	LocalGS.CE1 = &aElements[GLYPHELEMENT];
	LocalGS.CE2 = &aElements[GLYPHELEMENT];
	LocalGS.free.x = ONEVECTOR;
	LocalGS.proj.x = ONEVECTOR;
	LocalGS.oldProj.x = ONEVECTOR;
	LocalGS.free.y = 0;
	LocalGS.proj.y = 0;
	LocalGS.oldProj.y = 0;
	LocalGS.pfProj = ONEVECTOR;
	LocalGS.MovePoint = itrp_XMovePoint;
	LocalGS.Project = itrp_XProject;
	LocalGS.OldProject = itrp_XProject;
	LocalGS.loop = 0;           /* 1 less than count for faster loops. mrr */

	LocalGS.ulJumpCounter = globalGS->ulMaxJumpCounter;           /* counter used to catch infinite loops */
	LocalGS.ulRecursiveCall = globalGS->ulMaxRecursiveCall;           /* counter used to catch deep recrusion */

	if (globalGS->engine[1] == 0)           /* if engine compenstion turned off */
	{
		LocalGS.MIRPCode = MIRPX;           /* default to fast mirp */
	}
	else
	{
		LocalGS.MIRPCode = MIRPG;           /* fall back to general mirp */
	}

	if (globalGS->pgmIndex == FONTPROGRAM)
	{
#ifdef FSCFG_DEBUG
		LocalGS.GetCVTEntry = itrp_GetCVTEntryNil;
		LocalGS.GetSingleWidth = itrp_GetSingleWidthNil;
#else
		LocalGS.GetCVTEntry = itrp_GetCVTEntryFast;
		LocalGS.GetSingleWidth = itrp_GetSingleWidthFast;
#endif
		LocalGS.ChangeCvt = itrp_ChangeCvtFast;
	}
	else
	{
#ifdef FSCFG_SUBPIXEL
		globalGS->subPixelCompatibilityFlags &= ~(SPCF_iupxCalled | SPCF_iupyCalled | SPCF_inVacuformRound | SPCF_inSkippableDeltaFn);
		// can't do this when doing the font program, would try to access the localParBlock, which is still uninitialized at this point.
		UpdateRoundFunctionByProjectionVector(LocalGS);
#endif
#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
		LocalGS.pt0 = LocalGS.pt1 = -1; // points referred to in MDRP for Align as a result of SPVTL and SDPVTL...
#endif
		if (globalGS->pixelsPerEm <= 1)
			return NO_ERR;
		  
		if (globalGS->bSameStretch)
		{
			LocalGS.GetCVTEntry = itrp_GetCVTEntryFast;
			LocalGS.GetSingleWidth = itrp_GetSingleWidthFast;
			LocalGS.ChangeCvt = itrp_ChangeCvtFast;
		} 
		else 
		{
			LocalGS.GetCVTEntry = itrp_GetCVTEntrySlow;
			LocalGS.GetSingleWidth = itrp_GetSingleWidthSlow;
			LocalGS.ChangeCvt = itrp_ChangeCvtSlow;
			LocalGS.MIRPCode = MIRPG;       /* fall back to general mirp */
		}

		if (globalGS->localParBlock.sW)     /* We need to scale the single width for this size  */
		{
			globalGS->localParBlock.scaledSW = globalGS->ScaleFuncCVT (&globalGS->scaleCVT, (F26Dot6)(globalGS->localParBlock.sW));
			LocalGS.MIRPCode = MIRPG;       /* fall back to general mirp */
		}
	}
	
	LocalGS.stackPointer = globalGS->stackBase;
	LocalGS.TraceFunc = TraceFunc;
	LocalGS.ercReturn = NO_ERR;             /* default return value */

	if (TraceFunc != NULL)
	{
		LocalGS.Interpreter = itrp_InnerTraceExecute;
	}
	else
	{
		LocalGS.Interpreter = itrp_InnerExecute;
	}
#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
		if (globalGS->pgmIndex == GLYPHPROGRAM && RunningSubPixel(globalGS) && CompatibleWidthSP(globalGS))
			InitPhaseControl(&LocalGS.elements[GLYPHELEMENT]); // beats
#endif

	(*LocalGS.Interpreter) (GSA ptr, eptr);

#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	if (LocalGS.globalGS->pgmIndex == GLYPHPROGRAM && RunningSubPixel(LocalGS.globalGS) && CompatibleWidthSP(LocalGS.globalGS) &&
		!LocalGS.elements[GLYPHELEMENT].phaseControlExecuted) {
		ExecutePhaseControl(&LocalGS,&LocalGS.elements[GLYPHELEMENT]); // beats
	//	phaseControlExecuted == true by now
	}
#endif
	STAT_OFF_FNTEXEC;                            /* stop STAT timer */
	
	return LocalGS.ercReturn;               /* NO_ERR unless illegal inst */
}


/*************************************************************************/

/*** 2 internal LocalGS.pfProj computation support routines ***/

/*
 * Only does the check of LocalGS.pfProj
 */
  FS_PRIVATE void itrp_Check_PF_Proj (GSP0)
  {
	VECTORTYPE pfProj = LocalGS.pfProj;

	if (pfProj > -ONESIXTEENTHVECTOR && pfProj < ONESIXTEENTHVECTOR) 
	{
	  LocalGS.pfProj = (VECTORTYPE)(pfProj < 0 ? -ONEVECTOR : ONEVECTOR); /* Prevent divide by small number */
	}
  }


/*
 * Computes LocalGS.pfProj and then does the check
 */
  FS_PRIVATE void itrp_ComputeAndCheck_PF_Proj (GSP0)
  {
	VECTORTYPE pfProj;

	pfProj = (VECTORTYPE)(VECTORDOT (LocalGS.proj.x, LocalGS.free.x) + VECTORDOT (LocalGS.proj.y, LocalGS.free.y));
	if (pfProj > -ONESIXTEENTHVECTOR && pfProj < ONESIXTEENTHVECTOR) 
	{
	  pfProj = (VECTORTYPE)(pfProj < 0 ? -ONEVECTOR : ONEVECTOR); /* Prevent divide by small number */
	}
	LocalGS.pfProj = pfProj;

	LocalGS.cvtDiagonalStretch = 0;      /* invalidate cache */ 
  }

/******************************************/
/******** The Actual Instructions *********/
/******************************************/

/*
 * Set Vectors To Coordinate Axis - Y
 */
  FS_PRIVATE uint8* itrp_SVTCA_0 (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);
	LocalGS.free.x = LocalGS.proj.x = 0;
	LocalGS.free.y = LocalGS.proj.y = ONEVECTOR;
	LocalGS.MovePoint = itrp_YMovePoint;
	LocalGS.Project = itrp_YProject;
#ifdef FSCFG_SUBPIXEL
	UpdateRoundFunctionByProjectionVector(LocalGS);
#endif
#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	LocalGS.pt0 = LocalGS.pt1 = -1; // points referred to in MDRP for Align as a result of SPVTL and SDPVTL...
#endif

	LocalGS.OldProject = itrp_YProject;
	LocalGS.pfProj = ONEVECTOR;
	if (LocalGS.MIRPCode != MIRPG)          /* if we haven't fallen back */
	{
		LocalGS.MIRPCode = MIRPY;           /* then use fast mirp */
	}
	return pbyInst;
  }

/*
 * Set Vectors To Coordinate Axis - X
 */
  FS_PRIVATE uint8* itrp_SVTCA_1 (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);
	LocalGS.free.x = LocalGS.proj.x = ONEVECTOR;
	LocalGS.free.y = LocalGS.proj.y = 0;
	LocalGS.MovePoint = itrp_XMovePoint;
	LocalGS.Project = itrp_XProject;
#ifdef FSCFG_SUBPIXEL
	UpdateRoundFunctionByProjectionVector(LocalGS);
#endif
#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	LocalGS.pt0 = LocalGS.pt1 = -1; // points referred to in MDRP for Align as a result of SPVTL and SDPVTL...
#endif

	LocalGS.OldProject = itrp_XProject;
	LocalGS.pfProj = ONEVECTOR;
	if (LocalGS.MIRPCode != MIRPG)          /* if we haven't fallen back */
	{
		LocalGS.MIRPCode = MIRPX;           /* then use fast mirp */
	}
	return pbyInst;
  }

/*
 * Set Projection Vector To Coordinate Axis - Y
 */
  FS_PRIVATE uint8* itrp_SPVTCA_0 (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);
	LocalGS.proj.x = 0;
	LocalGS.proj.y = ONEVECTOR;
	LocalGS.Project = itrp_YProject;
#ifdef FSCFG_SUBPIXEL
	UpdateRoundFunctionByProjectionVector(LocalGS);
#endif
#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	LocalGS.pt0 = LocalGS.pt1 = -1; // points referred to in MDRP for Align as a result of SPVTL and SDPVTL...
#endif

	LocalGS.pfProj = LocalGS.free.y;
	itrp_Check_PF_Proj (GSA0);
	LocalGS.MovePoint = itrp_MovePoint;
	LocalGS.OldProject = LocalGS.Project;
	LocalGS.MIRPCode = MIRPG;               /* fall back to general mirp */
	return pbyInst;
  }

/*
 * Set Projection Vector To Coordinate Axis - X
 */
  FS_PRIVATE uint8* itrp_SPVTCA_1 (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);
	LocalGS.proj.x = ONEVECTOR;
	LocalGS.proj.y = 0;
	LocalGS.Project = itrp_XProject;
#ifdef FSCFG_SUBPIXEL
	UpdateRoundFunctionByProjectionVector(LocalGS);
#endif
#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	LocalGS.pt0 = LocalGS.pt1 = -1; // points referred to in MDRP for Align as a result of SPVTL and SDPVTL...
#endif

	LocalGS.pfProj = LocalGS.free.x;
	itrp_Check_PF_Proj (GSA0);
	LocalGS.MovePoint = itrp_MovePoint;
	LocalGS.OldProject = LocalGS.Project;
	LocalGS.MIRPCode = MIRPG;               /* fall back to general mirp */
	return pbyInst;
  }


/*
 * Set Freedom Vector to Coordinate Axis - Y
 */
  FS_PRIVATE uint8* itrp_SFVTCA_0 (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);
	LocalGS.free.x = 0;
	LocalGS.free.y = ONEVECTOR;
	LocalGS.pfProj = LocalGS.proj.y;
	itrp_Check_PF_Proj (GSA0);
	LocalGS.MovePoint = itrp_MovePoint;
	LocalGS.MIRPCode = MIRPG;               /* fall back to general mirp */
	return pbyInst;
  }

/*
 * Set Freedom Vector to Coordinate Axis - X
 */
  FS_PRIVATE uint8* itrp_SFVTCA_1 (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);
	LocalGS.free.x = ONEVECTOR;
	LocalGS.free.y = 0;
	LocalGS.pfProj = LocalGS.proj.x;
	itrp_Check_PF_Proj (GSA0);
	LocalGS.MovePoint = itrp_MovePoint;
	LocalGS.MIRPCode = MIRPG;               /* fall back to general mirp */
	return pbyInst;
  }


/*
 * Set Projection Vector To Line
 */
  FS_PRIVATE uint8* itrp_SPVTL (IPARAM)
  {
	int32 arg1, arg2;
	
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);

    arg2 = (int32)CHECK_POP (LocalGS.stackPointer);
	arg1 = (int32)CHECK_POP (LocalGS.stackPointer);

    SECURE_CHECK_POINT (LocalGS.CE2, arg2);
	SECURE_CHECK_POINT (LocalGS.CE1, arg1);

	CHECK_POINT (&LocalGS, LocalGS.CE2, arg2);
	CHECK_POINT (&LocalGS, LocalGS.CE1, arg1);

#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	LocalGS.pt0 = (int16)arg2; LocalGS.pt1 = (int16)arg1; // points referred to in MDRP for Align as a result of SPVTL and SDPVTL...
#endif

	itrp_Normalize (LocalGS.CE1->x[arg1] - LocalGS.CE2->x[arg2], LocalGS.CE1->y[arg1] - LocalGS.CE2->y[arg2], &LocalGS.proj);
	if (BIT0 (lOpCode)) { // rotate 90 degrees, appears to work in non-square aspect ratio as well
	  VECTORTYPE tmp = LocalGS.proj.y;
	  LocalGS.proj.y = LocalGS.proj.x;
	  LocalGS.proj.x = (VECTORTYPE)(-tmp);
	}

	itrp_ComputeAndCheck_PF_Proj (GSA0);
	LocalGS.MovePoint = itrp_MovePoint;
	LocalGS.Project = itrp_Project;
#ifdef FSCFG_SUBPIXEL
	UpdateRoundFunctionByProjectionVector(LocalGS);
#endif
	LocalGS.OldProject = LocalGS.Project;
	LocalGS.MIRPCode = MIRPG;               /* fall back to general mirp */
	return pbyInst;
  }


/*
 * Set Dual Projection Vector To Line
 */
  FS_PRIVATE uint8* itrp_SDPVTL (IPARAM)
  {
	int32 arg1, arg2;

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);

    arg2 = (int32)CHECK_POP (LocalGS.stackPointer);
	arg1 = (int32)CHECK_POP (LocalGS.stackPointer);

    SECURE_CHECK_POINT (LocalGS.CE2, arg2);
	SECURE_CHECK_POINT (LocalGS.CE1, arg1);

    CHECK_POINT (&LocalGS, LocalGS.CE2, arg2);
	CHECK_POINT (&LocalGS, LocalGS.CE1, arg1);

#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	LocalGS.pt0 = (int16)arg2; LocalGS.pt1 = (int16)arg1; // points referred to in MDRP for Align as a result of SPVTL and SDPVTL...
#endif

//	Do the current domain
	itrp_Normalize (LocalGS.CE1->x[arg1] - LocalGS.CE2->x[arg2], LocalGS.CE1->y[arg1] - LocalGS.CE2->y[arg2], &LocalGS.proj);

//	Do the old domain
	itrp_Normalize (LocalGS.CE1->ox[arg1] - LocalGS.CE2->ox[arg2], LocalGS.CE1->oy[arg1] - LocalGS.CE2->oy[arg2], &LocalGS.oldProj);

	if (BIT0 (lOpCode))	{ // rotate 90 degrees, appears to work in non-square aspect ratio as well
	  VECTORTYPE tmp = LocalGS.proj.y;
	  LocalGS.proj.y = LocalGS.proj.x;
	  LocalGS.proj.x = (VECTORTYPE)(-tmp);

	  tmp = LocalGS.oldProj.y;
	  LocalGS.oldProj.y = LocalGS.oldProj.x;
	  LocalGS.oldProj.x = (VECTORTYPE)(-tmp);
	}
	
	itrp_ComputeAndCheck_PF_Proj (GSA0);
	LocalGS.MovePoint = itrp_MovePoint;
	LocalGS.Project = itrp_Project;
#ifdef FSCFG_SUBPIXEL
	UpdateRoundFunctionByProjectionVector(LocalGS);
#endif
	LocalGS.OldProject = itrp_OldProject;
	LocalGS.MIRPCode = MIRPG;               /* fall back to general mirp */
	return pbyInst;
  }

/*
 * Set Freedom Vector To Line
 */
  FS_PRIVATE uint8* itrp_SFVTL (IPARAM)
  {
	int32 arg1, arg2;

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);

    arg2 = (int32)CHECK_POP (LocalGS.stackPointer);
	arg1 = (int32)CHECK_POP (LocalGS.stackPointer);

    SECURE_CHECK_POINT (LocalGS.CE2, arg2);
	SECURE_CHECK_POINT (LocalGS.CE1, arg1);

    CHECK_POINT (&LocalGS, LocalGS.CE2, arg2);
	CHECK_POINT (&LocalGS, LocalGS.CE1, arg1);

	itrp_Normalize (LocalGS.CE1->x[arg1] - LocalGS.CE2->x[arg2], LocalGS.CE1->y[arg1] - LocalGS.CE2->y[arg2], &LocalGS.free);
	if (BIT0 (lOpCode)) { // rotate 90 degrees, appears to work in non-square aspect ratio as well
	  VECTORTYPE tmp     = LocalGS.free.y;
	  LocalGS.free.y     = LocalGS.free.x;
	  LocalGS.free.x     = (VECTORTYPE)(-tmp);
	}
	
	itrp_ComputeAndCheck_PF_Proj (GSA0);
	LocalGS.MovePoint = itrp_MovePoint;
	LocalGS.MIRPCode = MIRPG;               /* fall back to general mirp */
	return pbyInst;
  }


/*
 * Write Projection Vector
 */
  FS_PRIVATE uint8* itrp_WPV (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);

    LocalGS.proj.y = (VECTORTYPE) CHECK_POP (LocalGS.stackPointer);
	LocalGS.proj.x = (VECTORTYPE) CHECK_POP (LocalGS.stackPointer);

#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	LocalGS.pt0 = LocalGS.pt1 = -1; // points referred to in MDRP for Align as a result of SPVTL and SDPVTL...
#endif

	CHECK_VECTOR (LocalGS.proj.x, LocalGS.proj.y);
	itrp_ComputeAndCheck_PF_Proj (GSA0);

	LocalGS.MovePoint = itrp_MovePoint;
	LocalGS.Project = itrp_Project;
#ifdef FSCFG_SUBPIXEL
	UpdateRoundFunctionByProjectionVector(LocalGS);
#endif
	LocalGS.OldProject = LocalGS.Project;
	LocalGS.MIRPCode = MIRPG;               /* fall back to general mirp */
	return pbyInst;
  }

/*
 * Write Freedom vector
 */
  FS_PRIVATE uint8* itrp_WFV (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);

    LocalGS.free.y = (VECTORTYPE) CHECK_POP (LocalGS.stackPointer);
	LocalGS.free.x = (VECTORTYPE) CHECK_POP (LocalGS.stackPointer);

	CHECK_VECTOR (LocalGS.free.x, LocalGS.free.y);
	itrp_ComputeAndCheck_PF_Proj (GSA0);

	LocalGS.MovePoint = itrp_MovePoint;
	LocalGS.MIRPCode = MIRPG;               /* fall back to general mirp */
	return pbyInst;
  }

/*
 * Read Projection Vector
 */
  FS_PRIVATE uint8* itrp_RPV (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);
    SECURE_CHECK_FOR_PUSH (LocalGS.stackPointer, 2);
	CHECK_PUSH (LocalGS.stackPointer, LocalGS.proj.x);
	CHECK_PUSH (LocalGS.stackPointer, LocalGS.proj.y);
	return pbyInst;
  }

/*
 * Read Freedom Vector
 */
  FS_PRIVATE uint8* itrp_RFV (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);
    SECURE_CHECK_FOR_PUSH (LocalGS.stackPointer, 2);
	CHECK_PUSH (LocalGS.stackPointer, LocalGS.free.x);
	CHECK_PUSH (LocalGS.stackPointer, LocalGS.free.y);
	return pbyInst;
  }

/*
 * Set Freedom Vector To Projection Vector
 */
  FS_PRIVATE uint8* itrp_SFVTPV (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);
	LocalGS.free = LocalGS.proj;
	LocalGS.pfProj = ONEVECTOR;
	LocalGS.MovePoint = itrp_MovePoint;
	LocalGS.MIRPCode = MIRPG;               /* fall back to general mirp */
	return pbyInst;
  }

/*
 * itrp_ISECT ()
 *
 * Computes the intersection of two lines without using floating point!!
 *
 * (1) Bx + dBx * t0 = Ax + dAx * t1
 * (2) By + dBy * t0 = Ay + dAy * t1
 *
 *  1  => (t1 = Bx - Ax + dBx * t0) / dAx
 *  +2 =>   By + dBy * t0 = Ay + dAy/dAx * [ Bx - Ax + dBx * t0 ]
 *     => t0 * [dAy/dAx * dBx - dBy] = By - Ay - dAy/dAx* (Bx-Ax)
 *     => t0 (dAy*DBx - dBy*dAx) = dAx (By - Ay) + dAy (Ax-Bx)
 *     => t0 = [dAx (By-Ay) + dAy (Ax-Bx)] / [dAy*dBx - dBy*dAx]
 *     => t0 = [dAx (By-Ay) - dAy (Bx-Ax)] / [dBx*dAy - dBy*dAx]
 *     t0 = N/D
 *     =>
 *          N = (By - Ay) * dAx - (Bx - Ax) * dAy;
 *              D = dBx * dAy - dBy * dAx;
 *      A simple floating point implementation would only need this, and
 *      the check to see if D is zero.
 *              But to gain speed we do some tricks and avoid floating point.
 *
 */
  FS_PRIVATE uint8* itrp_ISECT (IPARAM)
  {
	F26Dot6 N, D;
	int32   arg1, arg2;
	F26Dot6 Bx, By, Ax, Ay;
	F26Dot6 dBx, dBy, dAx, dAy;

#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	int32 arg1p, arg2p;
#endif

	{
	  fnt_ElementType*element = LocalGS.CE0;
	  F26Dot6*stack = LocalGS.stackPointer;

	  FS_UNUSED_PARAMETER(lOpCode);

      SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 5);

	  arg2 = (int32)CHECK_POP (stack); /* get one line */
	  arg1 = (int32)CHECK_POP (stack);
	  SECURE_CHECK_POINT (LocalGS.CE0, arg2);
	  SECURE_CHECK_POINT (LocalGS.CE0, arg1);
	  CHECK_POINT (&LocalGS, LocalGS.CE0, arg2);
	  CHECK_POINT (&LocalGS, LocalGS.CE0, arg1);
	  dAx = element->x[arg2] - (Ax = element->x[arg1]);
	  dAy = element->y[arg2] - (Ay = element->y[arg1]);

#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	  if (LocalGS.globalGS->pgmIndex == GLYPHPROGRAM && CompatibleWidthSP(LocalGS.globalGS)) {
		  arg2p = arg2;
		  arg1p = arg1;
	  }
#endif

	  element = LocalGS.CE1;
	  arg2 = (int32)CHECK_POP (stack); /* get the other line */
	  arg1 = (int32)CHECK_POP (stack);
	  SECURE_CHECK_POINT (LocalGS.CE1, arg2);
	  SECURE_CHECK_POINT (LocalGS.CE1, arg1);
	  CHECK_POINT (&LocalGS, LocalGS.CE1, arg2);
	  CHECK_POINT (&LocalGS, LocalGS.CE1, arg1);
	  dBx = element->x[arg2] - (Bx = element->x[arg1]);
	  dBy = element->y[arg2] - (By = element->y[arg1]);

#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	  if (LocalGS.globalGS->pgmIndex == GLYPHPROGRAM && CompatibleWidthSP(LocalGS.globalGS) && MABS(Mul26Dot6(dBy,dAx)) > MABS(Mul26Dot6(dBx,dAy))) {
		  arg2p = arg2;	// pick the line which is closer to the y-axis
		  arg1p = arg1; // since aligning perpendicular to parent axis
	  }
#endif
	  arg1 = (int32)CHECK_POP (stack); /* get the point number */
	  SECURE_CHECK_POINT (LocalGS.CE2, arg1);
	  CHECK_POINT (&LocalGS, LocalGS.CE2, arg1);
	  LocalGS.stackPointer = stack;

#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	  // for our purposes, handle like a proportion (have intersected point follow proportional to parents)
	  // need no fv, pv set for ISECT, hence we don't test against LocalGS.inSubPixelDirection
	  if (LocalGS.CE2 != &LocalGS.elements[TWILIGHTZONE] && LocalGS.globalGS->pgmIndex == GLYPHPROGRAM && CompatibleWidthSP(LocalGS.globalGS))
		AddProportion(&LocalGS,LocalGS.CE2,arg1p,arg1,arg2p);
#endif
				


	}
	LocalGS.CE2->f[arg1] |= XMOVED | YMOVED;
	{
	  F26Dot6*elementx = LocalGS.CE2->x;
	  F26Dot6*elementy = LocalGS.CE2->y;
	  if (dAy == 0) 
	  {
		if (dBx == 0) 
		{
		  elementx[arg1] = Bx;
		  elementy[arg1] = Ay;
		  return pbyInst;
		}
		N = By - Ay;
		D = -dBy;
	  } 
	  else if (dAx == 0) 
	  {
		if (dBy == 0) 
		{
		  elementx[arg1] = Ax;
		  elementy[arg1] = By;
		  return pbyInst;
		}
		N = Bx - Ax;
		D = -dBx;
	  } 
	  else if (MABS (dAx) >= MABS (dAy))
	  {
/* To prevent out of range problems divide both N and D with the max */
		N = (By - Ay) - MulDiv26Dot6 (Bx - Ax, dAy, dAx);
		D = MulDiv26Dot6 (dBx, dAy, dAx) - dBy;
	  } 
	  else 
	  {
		N = MulDiv26Dot6 (By - Ay, dAx, dAy) - (Bx - Ax);
		D = dBx - MulDiv26Dot6 (dBy, dAx, dAy);
	  }

	  if (D) 
	  {
		elementx[arg1] = Bx + (F26Dot6) MulDiv26Dot6 (dBx, N, D);
		elementy[arg1] = By + (F26Dot6) MulDiv26Dot6 (dBy, N, D);
	  } 
	  else 
	  {
/* degenerate case: parallell lines, put point in the middle */
		elementx[arg1] = (Bx + (dBx >> 1) + Ax + (dAx >> 1)) >> 1;
		elementy[arg1] = (By + (dBy >> 1) + Ay + (dAy >> 1)) >> 1;
	  }
	}
	return pbyInst;
  }

/*
 * Load Minimum Distance
 */
  FS_PRIVATE uint8* itrp_LMD (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);

    LocalGS.globalGS->localParBlock.minimumDistance = CHECK_POP (LocalGS.stackPointer);
	CHECK_LARGER (-1L, LocalGS.globalGS->localParBlock.minimumDistance);
	return pbyInst;
  }

/*
 * Load Control Value Table Cut In
 */
  FS_PRIVATE uint8* itrp_LWTCI (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);

    LocalGS.globalGS->localParBlock.wTCI = CHECK_POP (LocalGS.stackPointer);
	CHECK_LARGER (-1L, LocalGS.globalGS->localParBlock.wTCI);
	return pbyInst;
  }

/*
 * Load Single Width Cut In
 */
  FS_PRIVATE uint8* itrp_LSWCI (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);

    LocalGS.globalGS->localParBlock.sWCI = CHECK_POP (LocalGS.stackPointer);
	LocalGS.MIRPCode = MIRPG;               /* fall back to general mirp */
	CHECK_LARGER (-1L, LocalGS.globalGS->localParBlock.sWCI);
	return pbyInst;
  }

/*
 * Load Single Width , assumes value comes from the original domain, not the cvt or outline
 */
  FS_PRIVATE uint8* itrp_LSW (IPARAM)
  {
	fnt_GlobalGraphicStateType *globalGS = LocalGS.globalGS;
	fnt_ParameterBlock *pb = &globalGS->localParBlock;
	int32 arg;

	FS_UNUSED_PARAMETER(lOpCode);

	LocalGS.MIRPCode = MIRPG;               /* fall back to general mirp */

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);

    arg = CHECK_POP (LocalGS.stackPointer);
	CHECK_INT16 (arg);
	pb->sW = (int16)arg;
	CHECK_LARGER (-1L, pb->sW);

	pb->scaledSW = globalGS->ScaleFuncCVT (&globalGS->scaleCVT, (F26Dot6)pb->sW); /* measurement should not come from the outline */
	return pbyInst;
  }

/* these functions were split out from itrp_SetLocalGraphicState - deanb */
  
  FS_PRIVATE uint8* itrp_SRP0 (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	LocalGS.Pt0 = (int32)CHECK_POP (LocalGS.stackPointer);
	return pbyInst;
  }

  FS_PRIVATE uint8* itrp_SRP1 (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	LocalGS.Pt1 = (int32)CHECK_POP (LocalGS.stackPointer);
	return pbyInst;
  }

  FS_PRIVATE uint8* itrp_SRP2 (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	LocalGS.Pt2 = (int32)CHECK_POP (LocalGS.stackPointer);
	return pbyInst;
  }
  
  FS_PRIVATE uint8* itrp_LLOOP (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	LocalGS.loop = (int32)(CHECK_POP (LocalGS.stackPointer)) - 1;
	return pbyInst;
  }

  FS_PRIVATE uint8* itrp_POP (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	CHECK_POP (LocalGS.stackPointer);
	return pbyInst;
  }


  FS_PRIVATE uint8* itrp_SetElementPtr (IPARAM)
  {
	int32             arg;
	fnt_ElementType * element;

	switch (lOpCode)
	{
	  case SCES_CODE: 
		ERR_OPC ("SCES");
		break;
	  case SCE0_CODE: 
		ERR_OPC ("SCE0");
		break;
	  case SCE1_CODE: 
		ERR_OPC ("SCE1");
		break;
	  case SCE2_CODE: 
		ERR_OPC ("SCE2");
		break;
	  default:
		ERR_OPC ("???");
		break;
	}

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	arg = (int32)CHECK_POP (LocalGS.stackPointer);
    SECURE_CHECK_ZONE(arg);
    CHECK_ELEMENT (&LocalGS, arg);
	element = &LocalGS.elements[ arg ];

	switch (lOpCode)
	{
	  case SCES_CODE: 
		LocalGS.CE2 = element;
		LocalGS.CE1 = element;
	  case SCE0_CODE: 
		LocalGS.CE0 = element;
		break;
	  case SCE1_CODE: 
		LocalGS.CE1 = element;
		break;
	  case SCE2_CODE: 
		LocalGS.CE2 = element;
		break;
#ifdef FSCFG_DEBUG
	  default:
		ERR_REPORT (ERR_INVOPC, lOpCode, 0, 0, 0);
		break;
#endif
	}
	LocalGS.MIRPCode = MIRPG;               /* fall back to general mirp */
	return pbyInst;
  }

/*
 * Super Round
 */
  FS_PRIVATE uint8* itrp_SROUND (IPARAM)
  {
	fnt_ParameterBlock *pb = &LocalGS.globalGS->localParBlock;
	int32      arg1;
	int32      arg;

	FS_UNUSED_PARAMETER(lOpCode);
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	arg = (int32)CHECK_POP (LocalGS.stackPointer);
	CHECK_INT16 (arg);
	arg1 = (int32)arg;
	itrp_SetRoundValues (GSA arg1, true);
#ifdef FSCFG_SUBPIXEL
	UpdateRoundFunctionByRoundState(LocalGS,inSRnd);
#else
	pb->RoundValue = itrp_SuperRound; // B.St. to check
#endif
	LocalGS.MIRPCode = MIRPG;               /* fall back to general mirp */
	return pbyInst;
  }

/*
 * Super Round
 */
  FS_PRIVATE uint8* itrp_S45ROUND (IPARAM)
  {
	fnt_ParameterBlock *pb = &LocalGS.globalGS->localParBlock;
	int32      arg1;
	int32      arg;

	FS_UNUSED_PARAMETER(lOpCode);
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	arg = (int32)CHECK_POP (LocalGS.stackPointer);
	CHECK_INT16 (arg);
	arg1 = (int32)arg;
	itrp_SetRoundValues (GSA arg1, false);
#ifdef FSCFG_SUBPIXEL
	UpdateRoundFunctionByRoundState(LocalGS,inS45Rnd);
#else
	pb->RoundValue = itrp_Super45Round; // B.St. to check
#endif
	LocalGS.MIRPCode = MIRPG;               /* fall back to general mirp */
	return pbyInst;
  }

/*********************************************************************/

/*  These routines were split out from SetRoundState  */
/*  They set the current rounding state, and all but  */
/*  RoundToGrid cause MIRP to fall back to MIRPG      */


FS_PRIVATE uint8* itrp_RTG (IPARAM)
{
	FS_UNUSED_PARAMETER(lOpCode);
#ifdef FSCFG_SUBPIXEL
	UpdateRoundFunctionByRoundState(LocalGS,inRtg)
#else
	LocalGS.globalGS->localParBlock.RoundValue = itrp_RoundToGrid;
#endif
	return pbyInst;
}

FS_PRIVATE uint8* itrp_RTHG (IPARAM)
{
	FS_UNUSED_PARAMETER(lOpCode);
#ifdef FSCFG_SUBPIXEL
	UpdateRoundFunctionByRoundState(LocalGS,inRthg);
#else
	LocalGS.globalGS->localParBlock.RoundValue = itrp_RoundToHalfGrid;
#endif
	LocalGS.MIRPCode = MIRPG;
	return pbyInst;
}

FS_PRIVATE uint8* itrp_RTDG (IPARAM)
{
	FS_UNUSED_PARAMETER(lOpCode);
#ifdef FSCFG_SUBPIXEL
	UpdateRoundFunctionByRoundState(LocalGS,inRtdg);
#else
	LocalGS.globalGS->localParBlock.RoundValue = itrp_RoundToDoubleGrid;
#endif
	LocalGS.MIRPCode = MIRPG;
	return pbyInst;
}

FS_PRIVATE uint8* itrp_ROFF (IPARAM)
{
	FS_UNUSED_PARAMETER(lOpCode);
#ifdef FSCFG_SUBPIXEL
	UpdateRoundFunctionByRoundState(LocalGS,inRoff);
#else
	LocalGS.globalGS->localParBlock.RoundValue = itrp_RoundOff;
#endif
	LocalGS.MIRPCode = MIRPG;
	return pbyInst;
}

FS_PRIVATE uint8* itrp_RDTG (IPARAM)
{
	FS_UNUSED_PARAMETER(lOpCode);
#ifdef FSCFG_SUBPIXEL
	UpdateRoundFunctionByRoundState(LocalGS,inRdtg);
#else
	LocalGS.globalGS->localParBlock.RoundValue = itrp_RoundDownToGrid;
#endif
	LocalGS.MIRPCode = MIRPG;
	return pbyInst;
}

FS_PRIVATE uint8* itrp_RUTG (IPARAM)
{
	FS_UNUSED_PARAMETER(lOpCode);
#ifdef FSCFG_SUBPIXEL
	UpdateRoundFunctionByRoundState(LocalGS,inRutg);
#else
	LocalGS.globalGS->localParBlock.RoundValue = itrp_RoundUpToGrid;
#endif
	LocalGS.MIRPCode = MIRPG;
	return pbyInst;
}

/*********************************************************************/


#define FRACSQRT2DIV2   11591
/*
 * Internal support routine for the super rounding routines
 */
  FS_PRIVATE void itrp_SetRoundValues (GSP int32 arg1, int32 normalRound)
  {
	 int32       tmp;
	fnt_ParameterBlock *pb = &LocalGS.globalGS->localParBlock;

	tmp = arg1 & 0xC0;

	if (normalRound) 
	{
	  switch (tmp) 
	  {
	  case 0x00:
		pb->period = FNT_PIXELSIZE / 2;
		break;
	  case 0x40:
		pb->period = FNT_PIXELSIZE;
		break;
	  case 0x80:
		pb->period = FNT_PIXELSIZE * 2;
		break;
	  default:
		pb->period = 999; /* Illegal */
	  }
	  pb->periodMask = ~ (pb->period - 1);
	} 
	else 
	{
	  pb->period45 = FRACSQRT2DIV2;
	  switch (tmp) 
	  {
	  case 0x00:
		pb->period45 >>= 1;
		break;
	  case 0x40:
		break;
	  case 0x80:
		pb->period45 <<= 1;
		break;
	  default:
		pb->period45 = 999; /* Illegal */
	  }
	  tmp = (sizeof (pb->period45) * 8 - 2 - FNT_PIXELSHIFT);
	  pb->period = (int16) ((pb->period45 + (1L << (tmp - 1))) >> tmp); /*convert from 2.30 to 26.6 */
	}

	tmp = arg1 & 0x30;
	switch (tmp) 
	{
	case 0x00:
	  pb->phase = 0;
	  break;
	case 0x10:
	  pb->phase = (int16)((pb->period + 2) >> 2);
	  break;
	case 0x20:
	  pb->phase = (int16)((pb->period + 1) >> 1);
	  break;
	case 0x30:
	  pb->phase = (int16)((pb->period + pb->period + pb->period + 2) >> 2);
	  break;
	}
	tmp = arg1 & 0x0f;
	if (tmp == 0) 
	{
	  pb->threshold = (int16)(pb->period - 1);
	} 
	else 
	{
	  pb->threshold = (int16)(((tmp - 4) * pb->period + 4) >> 3);
	}
  }

/*
 * Read Advance Width
 */
  FS_PRIVATE uint8* itrp_RAW (IPARAM)
  {
	F26Dot6* ox;
	int32 index;  

	FS_UNUSED_PARAMETER(lOpCode);

	if (LocalGS.globalGS->pgmIndex != GLYPHPROGRAM)
	{
		LocalGS.ercReturn = RAW_NOT_IN_GLYPHPGM_ERR;  /* returned to client, error RAW not in glyph program */
		return LocalGS.pbyEndInst;
	}

	ox = LocalGS.elements[GLYPHELEMENT].ox;
	index = LocalGS.elements[GLYPHELEMENT].ep[LocalGS.elements[GLYPHELEMENT].nc - 1] + 1;      /* lsb point */

    SECURE_CHECK_FOR_PUSH (LocalGS.stackPointer, 1);
	CHECK_PUSH( LocalGS.stackPointer, ox[index+1] - ox[index] );
	return pbyInst;
  }

/*
 * DUPlicate
 */
  FS_PRIVATE uint8* itrp_DUP (IPARAM)
  {
	F26Dot6 top;

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	top = LocalGS.stackPointer[-1];
	FS_UNUSED_PARAMETER(lOpCode);
    SECURE_CHECK_FOR_PUSH (LocalGS.stackPointer, 1);
	CHECK_PUSH (LocalGS.stackPointer, top);
	return pbyInst;
  }

/*
 * CLEAR stack
 */
  FS_PRIVATE uint8* itrp_CLEAR (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);
	LocalGS.stackPointer = LocalGS.globalGS->stackBase;
	return pbyInst;
  }

/*********************************************************************/

/*
 * SWAP
 */
FS_PRIVATE uint8* itrp_SWAP (IPARAM)
{
	F26Dot6 *pfxStack;
	F26Dot6 fxTemp;
		   
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	pfxStack = LocalGS.stackPointer - 1;
	fxTemp = pfxStack[0];
	pfxStack[0] = pfxStack[-1];
	pfxStack[-1] = fxTemp;
	
	return pbyInst;
}

/*********************************************************************/

/*
 * DEPTH
 */
  FS_PRIVATE uint8* itrp_DEPTH (IPARAM)
  {
	F26Dot6 depth = (F26Dot6)(LocalGS.stackPointer - LocalGS.globalGS->stackBase);
	FS_UNUSED_PARAMETER(lOpCode);
    SECURE_CHECK_FOR_PUSH (LocalGS.stackPointer, 1);
	CHECK_PUSH (LocalGS.stackPointer, depth);
	return pbyInst;
  }

/*
 * Copy INDEXed value
 */
  FS_PRIVATE uint8* itrp_CINDEX (IPARAM)
  {
	int32   arg1;
	F26Dot6 tmp, *p;
	F26Dot6*stack = LocalGS.stackPointer;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);

	arg1 = (int32)CHECK_POP (stack);

    SECURE_CHECK_FOR_POP (stack, arg1);

	p = stack - arg1;
	CHECK_SUBSTACK (&LocalGS, p);
	SECURE_CHECK_SUBSTACK (p);

	tmp = *p;

	CHECK_PUSH (stack , tmp);
	return pbyInst;
  }

/*
 * Move INDEXed value
 */
  FS_PRIVATE uint8* itrp_MINDEX (IPARAM)
  {
	int32   arg1;
	F26Dot6 tmp, *p;
	F26Dot6*stack = LocalGS.stackPointer;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);

	arg1 = (int32)CHECK_POP (stack);

    SECURE_CHECK_FOR_POP (stack, arg1);

	p = stack - arg1;
	CHECK_SUBSTACK (&LocalGS, p);
	SECURE_CHECK_SUBSTACK (p);

	tmp = *p;

	if (arg1 > 0) 
	{
	  do 
	  {
		*p = * (p + 1); 
		p++;
	  } while (--arg1);
	  CHECK_POP (stack);
	}
	CHECK_PUSH (stack, tmp);
	LocalGS.stackPointer = stack;
	return pbyInst;
  }

/*
 *      Rotate element 3 to the top of the stack                        <4>
 *      Thanks to Oliver for the obscure code.
 */
  FS_PRIVATE uint8* itrp_ROTATE (IPARAM)
  {
	F26Dot6 *stack = LocalGS.stackPointer;
	F26Dot6 element1;
	F26Dot6 element2;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 3);
	element1 = *--stack;
	element2 = *--stack;

    *stack = element1;
	element1 = *--stack;
	*stack = element2;
	* (stack + 2) = element1;
	return pbyInst;
  }

/*********************************************************************/

/*
 * Move Direct Absolute Point
 */
FS_PRIVATE uint8* itrp_MDAP (IPARAM) {
	F26Dot6 fxProj;
	fnt_ElementType *pCE0;
	fnt_ParameterBlock *pb;
	int32 iPoint;

	pCE0 = LocalGS.CE0;
	pb = &LocalGS.globalGS->localParBlock;

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	iPoint = (int32)CHECK_POP (LocalGS.stackPointer);
	SECURE_CHECK_POINT (pCE0, iPoint);
	CHECK_POINT (&LocalGS, pCE0, iPoint);
	LocalGS.Pt0 = iPoint; 
	LocalGS.Pt1 = iPoint;

	if (BIT0 (lOpCode)) { // round?
		fxProj = (*LocalGS.Project) (GSA pCE0->x[iPoint], pCE0->y[iPoint]);
		fxProj = pb->RoundValue (GSA fxProj, LocalGS.globalGS->engine[0]) - fxProj;
	} else {
		fxProj = 0;         /* mark the point as touched */
	}

	(*LocalGS.MovePoint) (GSA pCE0, iPoint, fxProj);
	return pbyInst;
} // itrp_MDAP

/*********************************************************************/

/*
 * Move Indirect Absolute Point
 */
FS_PRIVATE uint8* itrp_MIAP (IPARAM) {
	int32   iPoint;
	int32   iCVTIndex;
	F26Dot6 fxNewProj;
	F26Dot6 fxOrigProj;
	F26Dot6 fxProjDif;
	fnt_ElementType *pCE0;
	fnt_ParameterBlock *pb;

	pCE0 = LocalGS.CE0;
	pb = &LocalGS.globalGS->localParBlock;
	
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	iCVTIndex = (int32)CHECK_POP (LocalGS.stackPointer);
	SECURE_CHECK_CVT (iCVTIndex);
	CHECK_CVT (&LocalGS, iCVTIndex);
	fxNewProj = LocalGS.GetCVTEntry (GSA iCVTIndex);

	iPoint = (int32)CHECK_POP (LocalGS.stackPointer);
	SECURE_CHECK_POINT (pCE0, iPoint);
	CHECK_POINT (&LocalGS, pCE0, iPoint);
	LocalGS.Pt0 = iPoint;
	LocalGS.Pt1 = iPoint;

	if (pCE0 == &LocalGS.elements[TWILIGHTZONE]) {
		pCE0->x[iPoint] = (F26Dot6) VECTORMUL (fxNewProj, LocalGS.proj.x);
		pCE0->ox[iPoint] = pCE0->x[iPoint];
		pCE0->y[iPoint] = (F26Dot6) VECTORMUL (fxNewProj, LocalGS.proj.y);
		pCE0->oy[iPoint] = pCE0->y[iPoint];
	}

	fxOrigProj = (*LocalGS.Project) (GSA pCE0->x[iPoint], pCE0->y[iPoint]);

	if (BIT0 (lOpCode)) { // round?
		fxProjDif = fxNewProj - fxOrigProj;
		if (fxProjDif < 0) {
			fxProjDif = -fxProjDif;
		}
		if (fxProjDif > pb->wTCI) {
			fxNewProj = fxOrigProj;
		}
		fxNewProj = pb->RoundValue (GSA fxNewProj, LocalGS.globalGS->engine[0]);
	}
	// Notice that unlike MIRP, here we don't have a switch that would require the round-off flag MIAP[r] to honour
	// the cvt cut-in. We assume that the context is a stroke placement with coordinates calculated to move a stroke
	// possibly from the origin to the targeted location such as in PMingLiU. See also comments in MSIRP and MIRP.
	
	(*LocalGS.MovePoint) (GSA pCE0, iPoint, fxNewProj - fxOrigProj);
	return pbyInst;
} // itrp_MIAP


/*********************************************************************/

FS_PRIVATE uint8* itrp_IUP (IPARAM)
{
	fnt_ElementType *pCE2;
	
	int32 *alOrig;                          /* original outline array */
	int32 *plOrig;
	int32 *plOrigTouch2;                    /* for loop stop */
	int32 *plOrigEnd;
	int32 lOrig1;                           /* touched point 1 */
	int32 lOrig2;                           /* touched point 2 */
	int32 lOrigMin;                         /* min coord touched point */
	int32 lOrigDelta;
	int32 lOrigCorr;
	
	F26Dot6 *afxScaled;                     /* scaled outline array */
	F26Dot6 *pfxScaled;
	F26Dot6 fxScaledMax;
	F26Dot6 fxScaledMin;
	F26Dot6 fxScaledCoord;
	
	F26Dot6 fxMovedMax;                     /* hint movement of max */
	F26Dot6 fxMovedMin;                     /* hint movement of min */

	F26Dot6 *afxHinted;                     /* hinted outline array */
	F26Dot6 *pfxHinted;
	F26Dot6 fxHintedMax;
	F26Dot6 fxHintedMin;
	F26Dot6 fxHintedDelta;

	uint8 *abyFlags;                        /* point flags array */
	uint8 byMask;
	
	int32 iPt;                         /* current point index */
	int32 iStartPt;                    /* start of contour */
	int32 iEndPt;                      /* end of contour */
	int32 iStopPt;                     /* touched point indicates completion */
	int32 iTouch1;
	int32 iTouch2;
	int32 iMin;
	int32 iMax;
			   
	int32 iContour;

	int32 lTemp;
	Fixed fRatio;

	STAT_ON_IUP;                        /* start STAT timer */    

	pCE2 = LocalGS.CE2;

	SECURE_CHECK_FOR_UNITIALIZED_ZONE(pCE2);

#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	if (LocalGS,pCE2 != &LocalGS.elements[TWILIGHTZONE] && // beats
		LocalGS.globalGS->pgmIndex == GLYPHPROGRAM && RunningSubPixel(LocalGS.globalGS) && CompatibleWidthSP(LocalGS.globalGS) &&
		VerticalSPDirection(LocalGS.globalGS) != (lOpCode & 0x01) && !pCE2->phaseControlExecuted) {
		ExecutePhaseControl(&LocalGS,pCE2);
	//	phaseControlExecuted == true by now
	}
#endif
	
	abyFlags = pCE2->f;

	if (lOpCode & 0x01)              /* use x coordinates */
	{
		afxHinted = pCE2->x;
		afxScaled = pCE2->ox;
		if( LocalGS.globalGS->bOriginalPointIsInvalid)
		{
			alOrig = pCE2->ox;
		}
		else
		{
			alOrig = pCE2->oox;
		}
		byMask = XMOVED;
	} 
	else                                    /* use y coordinates */
	{
		afxHinted = pCE2->y;
		afxScaled = pCE2->oy;
		if( LocalGS.globalGS->bOriginalPointIsInvalid)
		{
			alOrig = pCE2->oy;
		}
		else
		{
			alOrig = pCE2->ooy;
		}
		byMask = YMOVED;
	}

	for (iContour = 0; iContour < pCE2->nc; iContour++)
	{
		iStartPt = pCE2->sp[iContour];
		iEndPt = pCE2->ep[iContour];
		plOrigEnd = &alOrig[iEndPt];        /* for limit check */

		iPt = iStartPt;
		while (!(abyFlags[iPt] & byMask) && (iPt <= iEndPt))
		{
			iPt++;
		}
		if (iPt <= iEndPt)                  /* if any points are touched */
		{
			iStopPt = iPt;                  /* save for done condition */
			
			do                              /* for each contour segment */
			{
				do                          /* find next untouched point */
				{
					iTouch1 = iPt;
					iPt++;
					if (iPt > iEndPt)
					{
						iPt = iStartPt;
					}
				} while ((abyFlags[iPt] & byMask) && iPt != iStopPt);

				if (iPt != iStopPt)
				{
					iTouch2 = iPt;
					do                      /* find next touched point */
					{
						iTouch2++;
						if (iTouch2 > iEndPt)
						{
							iTouch2 = iStartPt;
						}
					} while (!(abyFlags[iTouch2] & byMask));

					lOrig1 = alOrig[iTouch1];
					lOrig2 = alOrig[iTouch2];
					if (lOrig1 < lOrig2)
					{
						lOrigMin = lOrig1;
						lOrigDelta = lOrig2 - lOrig1;
						iMin = iTouch1;
						iMax = iTouch2;
					}
					else
					{
						lOrigMin = lOrig2;
						lOrigDelta = lOrig1 - lOrig2;
						iMin = iTouch2;
						iMax = iTouch1;
					}
					
					fxHintedMin = afxHinted[iMin];
					fxScaledMin = afxScaled[iMin];
					fxMovedMin = fxHintedMin - fxScaledMin;

					if (lOrigDelta != 0L)
					{
						fxScaledMax = afxScaled[iMax];
						fxHintedMax = afxHinted[iMax];
						fxMovedMax = fxHintedMax - fxScaledMax;
						fxHintedDelta = fxHintedMax - fxHintedMin;

						if (lOrigDelta < 32768 && fxHintedDelta < 32768)
						{
							plOrig = &alOrig[iPt];          /* set up pointers */
							pfxScaled = &afxScaled[iPt];
							pfxHinted = &afxHinted[iPt];
							lOrigCorr = lOrigDelta >> 1;
							plOrigTouch2 = &alOrig[iTouch2];    /* set limits */
							
							while (plOrig < plOrigTouch2)   /* if not across start/end */
							{
								fxScaledCoord = *pfxScaled;
								if ((fxScaledCoord > fxScaledMin) && (fxScaledCoord < fxScaledMax))
								{
									lTemp = SHORTMUL (*plOrig - lOrigMin, fxHintedDelta);
									lTemp += lOrigCorr;
									lTemp /= lOrigDelta;
									*pfxHinted = (F26Dot6)lTemp + fxHintedMin;
								}
								else if (fxScaledCoord >= fxScaledMax)
								{
									*pfxHinted = fxScaledCoord + fxMovedMax;
								}
								else
								{
									*pfxHinted = fxScaledCoord + fxMovedMin;
								}
								plOrig++;
								pfxScaled++;
								pfxHinted++;
							}                               /* end of time critical loop */
															
							while (plOrig != plOrigTouch2)  /* if points span start/end */
							{
								fxScaledCoord = *pfxScaled;
								if ((fxScaledCoord > fxScaledMin) && (fxScaledCoord < fxScaledMax))
								{
									lTemp = SHORTMUL (*plOrig - lOrigMin, fxHintedDelta);
									lTemp += lOrigCorr;
									lTemp /= lOrigDelta;
									*pfxHinted = (F26Dot6)lTemp + fxHintedMin;
								}
								else if (fxScaledCoord >= fxScaledMax)
								{
									*pfxHinted = fxScaledCoord + fxMovedMax;
								}
								else
								{
									*pfxHinted = fxScaledCoord + fxMovedMin;
								}
								plOrig++;
								pfxScaled++;
								pfxHinted++;
								
								if (plOrig > plOrigEnd)
								{
									plOrig = &alOrig[iStartPt];
									pfxScaled = &afxScaled[iStartPt];
									pfxHinted = &afxHinted[iStartPt];
								}
							}
							iPt = iTouch2;              /* keep in step */
						}
						else                /* if too big for 32 bit product */
						{
							fRatio = FixDiv (fxHintedDelta, lOrigDelta);
							while (iPt != iTouch2)
							{
								lTemp = afxScaled[iPt];
								if (lTemp <= fxScaledMin)
								{
									lTemp += fxMovedMin;
								}
								else if (lTemp >= fxScaledMax)
								{
									lTemp += fxMovedMax;
								}
								else
								{
									lTemp = alOrig[iPt];
									lTemp -= lOrigMin;
									lTemp = FixMul (lTemp, fRatio);
									lTemp += fxHintedMin;
								}
								afxHinted[iPt] = (F26Dot6)lTemp;
								
								if (iPt < iEndPt)
									iPt++;
								else
									iPt = iStartPt;
							}
						}                   /* endif (lOrigDelta < 32768 && fxHintedDelta < 32768) */
					}
					else                    /* if (lOrigDelta == 0L) */
					{
						while (iPt != iTouch2)
						{
							afxHinted[iPt] += fxMovedMin;
							
							if (iPt < iEndPt)
								iPt++;
							else
								iPt = iStartPt;
						}
					}                       /* endif (lOrigDelta != 0L) */
				}                           /* endif (iPt != iStopPt) */
			} while (iPt != iStopPt);       /* until contour is closed */
		}                                   /* endif (iPt <= iEndPt) */
	 }
								  /* next contour */
	STAT_OFF_IUP;                           /* stop STAT timer */    

#ifdef FSCFG_SUBPIXEL
	LocalGS.globalGS->subPixelCompatibilityFlags |= (lOpCode & 0x01 ? SPCF_iupxCalled : SPCF_iupyCalled);
#endif

	return pbyInst;
} // itrp_IUP

/*********************************************************************/

boolean IsSideBearingPoint(fnt_ElementType *element, int32 point);
boolean IsSideBearingPoint(fnt_ElementType *element, int32 point) {
	int32 numPoints = (int32)element->ep[element->nc - 1] + 1;
	return numPoints + LEFTSIDEBEARING <= point && point <= numPoints + RIGHTSIDEBEARING;
} // IsSideBearingPoint

boolean IsSideBearingLink(fnt_ElementType *element, int32 point0, int32 point1);
boolean IsSideBearingLink(fnt_ElementType *element, int32 point0, int32 point1) {
	int32 numPoints = (int32)element->ep[element->nc - 1] + 1;
	return numPoints + LEFTSIDEBEARING <= point0 && point0 <= numPoints + RIGHTSIDEBEARING || numPoints + LEFTSIDEBEARING <= point1 && point1 <= numPoints + RIGHTSIDEBEARING;
} // IsSideBearingLink


  FS_PRIVATE fnt_ElementType* itrp_SH_Common (GSP F26Dot6*dx, F26Dot6*dy, int32*point, int32 lOpCode)
  {
	F26Dot6 proj;
	int32 pt;
	fnt_ElementType * element;

	if (BIT0 (lOpCode))
	{
	  pt = LocalGS.Pt1;
	  element = LocalGS.CE0;
	} 
	else 
	{
	  pt = LocalGS.Pt2;
	  element = LocalGS.CE1;
	}
	proj = (*LocalGS.Project) (GSA element->x[pt] - element->ox[pt], element->y[pt] - element->oy[pt]);

	*dx = *dy = 0; // silence prefix

	if (LocalGS.pfProj != ONEVECTOR)
	{
	  if (LocalGS.free.x)
		*dx = (F26Dot6) LongMulDiv (proj, (int32)LocalGS.free.x, (int32)LocalGS.pfProj);
	  if (LocalGS.free.y)
		*dy = (F26Dot6) LongMulDiv (proj, (int32)LocalGS.free.y, (int32)LocalGS.pfProj);
	}
	else
	{
	  if (LocalGS.free.x)
		*dx = (F26Dot6) VECTORMUL (proj, LocalGS.free.x);
	  if (LocalGS.free.y)
		*dy = (F26Dot6) VECTORMUL (proj, LocalGS.free.y);
	}
	*point = pt;
	return element;
  }

/*********************************************************************/

FS_PRIVATE uint8* itrp_SHP_Common (GSP uint8 *pbyInst, 
#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
								   int32 refPoint,
#endif
#ifdef FSCFG_SUBPIXEL							// extra parameter to distinguish between coming from SHPIX, in which case we assume
								   uint8 shpix, // the context is a delta fn and hence we most likely skip the delta, and SHP
#endif
								   F26Dot6 dx, F26Dot6 dy)
{
	fnt_ElementType *CE2;
	int32 count;
	int32 point;
	
	CE2 = LocalGS.CE2;
	count = LocalGS.loop + 1;         /* faster for ms c8 */

	while (count != 0)
	{
		point = (int32)CHECK_POP (LocalGS.stackPointer);
		SECURE_CHECK_POINT (LocalGS.CE2, point);
		CHECK_POINT (&LocalGS, LocalGS.CE2, point);

#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
		if (CE2 != &LocalGS.elements[TWILIGHTZONE] && LocalGS.globalGS->pgmIndex == GLYPHPROGRAM && LocalGS.inSubPixelDirection && CompatibleWidthSP(LocalGS.globalGS))
			AddDistance(&LocalGS,CE2,refPoint,point,OTHER);
#endif

#ifdef FSCFG_SUBPIXEL
#ifdef InlineDeltasOnly
		// here we assume that if we're doing a SHPIX instruction, we're in the context of a function that implements delta instructions
		// for a range of ppem sizes. If such a delta occurs on an untouched point, regardless of whether it's in SP direction or not,
		// it creates a dent in the outline. While for b/w this is intended to flip one or more pixels, it distorts the stroke in SP.
		// If such a delta occurs on a touched point, it moves along the entire outline, such as to place strokes differently. If this
		// happens in SP direction, this distorts the natural spacing of the stroke(s). Therefore we keep only deltas on touched points
		// in non SP direction.
		//   Notice that strictly speaking, we should keep inline deltas (in non SP direction) only. However, since we do not have the
		// tree of instructions at this level, we don't know whether there are any dependant points that have been touched already,
		// prior to applying the delta (in which case it's a pre-IUP delta), or not (in which case it's an inline delta). In cases
		// where a pre-IUP delta was used to cleanup several pixels of the b/w bitmap, the SP result won't be optimal, but not nearly
		// as bad as it would be in grey-scaling. This is due to the oversampling, which in grey-scaling is done in both directions,
		// while only in one direction in SP. As a result, even the oversampled pixels (stripes) are typically "in".
		//   Notice also that we cannot use the fact whether IUP has happened already or not (even though this would be easy to track),
		// since some pre-IUP deltas are erroneously applied to untouched points, the result of which is unreliable in the sense that
		// the delta amount applies to the original (untouched) position of the point, which typically differs from its post-IUP
		// position. While this may lead to the desired result in b/w, in SP point positions likely will differ from those in b/w.
		// This has lead to irregularly spaced (and "angled") glyphs in fonts such as Palatino italic.
		//   Notice, finally, that for composites, the touched/untouched rule does not apply the same way. A point that is flagged as
		// untouched may have been previously touched while executing the code for the respective component. Yet a subsequent SHPIX or
		// possibly delta applied to that point will not create a(nother) dent in the outline, but move the entire outline, instead.
		// This is used in b/w e.g. to re-position diacritics to ensure a minimal distance of 1 pixel between the base character and
		// the diacritic. Hence we also keep deltas in composites.

		if (!shpix || (LocalGS.globalGS->subPixelCompatibilityFlags & SPCF_inSkippableDeltaFn) == 0 || AMovedPointInNonSPDirection(LocalGS,CE2,point)) {
#endif // InlineDeltasOnly
#endif // FSCFG_SUBPIXEL
		if (LocalGS.free.x) {
			CE2->x[point] += dx;
			CE2->f[point] |= XMOVED;
		}
		if (LocalGS.free.y) {
			CE2->y[point] += dy;
			CE2->f[point] |= YMOVED;
		}
#ifdef FSCFG_SUBPIXEL
#ifdef InlineDeltasOnly
		}
#endif
#endif
		count--;
	}
	LocalGS.loop = 0;
    return pbyInst;
}

/*********************************************************************/

/*
 * SHift Point
 */
  FS_PRIVATE uint8* itrp_SHP (IPARAM)
  {
	F26Dot6 dx, dy;
	int32 point;

#ifdef FSCFG_SECURE
	if (BIT0 (lOpCode))
	{
	  SECURE_CHECK_POINT (LocalGS.CE0, LocalGS.Pt1);
	} 
	else 
	{
	  SECURE_CHECK_POINT (LocalGS.CE1, LocalGS.Pt2);
	}
#endif 

	itrp_SH_Common (GSA &dx, &dy, &point, lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, LocalGS.loop + 1);

    return itrp_SHP_Common (GSA pbyInst, 
#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
		point,
#endif
#ifdef FSCFG_SUBPIXEL
		false, // we don't come from SHPIX
#endif
		dx, dy);
  }

/*
 * SHift Contour
 */
  FS_PRIVATE uint8* itrp_SHC (IPARAM)
  {
	fnt_ElementType *element;
	F26Dot6 dx, dy;
	int32 contour, point;

	{
	  F26Dot6 x, y;
	  int32 pt;

#ifdef FSCFG_SECURE
	  if (BIT0 (lOpCode))
	  {
	    SECURE_CHECK_POINT (LocalGS.CE0, LocalGS.Pt1);
	  } 
	  else 
	  {
	    SECURE_CHECK_POINT (LocalGS.CE1, LocalGS.Pt2);
	  }
#endif 
	  
	  element = itrp_SH_Common (GSA &x, &y, &pt, lOpCode);
	  point = pt;
	  dx = x;
	  dy = y;
	}
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	contour = (int32)CHECK_POP (LocalGS.stackPointer);

#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	if (element != &LocalGS.elements[TWILIGHTZONE] && // beats
		LocalGS.globalGS->pgmIndex == GLYPHPROGRAM && RunningSubPixel(LocalGS.globalGS) && CompatibleWidthSP(LocalGS.globalGS) &&
		!VerticalSPDirection(LocalGS.globalGS) && !element->phaseControlExecuted) {
		ExecutePhaseControl(&LocalGS,element);
	//	phaseControlExecuted == true by now
		dx += element->pcr[point].phaseShift;
	}
#endif
	


	SECURE_CHECK_FOR_UNITIALIZED_ZONE(LocalGS.CE2);
	SECURE_CHECK_CONTOUR (LocalGS.CE2, contour);
	CHECK_CONTOUR (&LocalGS, LocalGS.CE2, contour);

	{
	  VECTORTYPE fvx = LocalGS.free.x;
	  VECTORTYPE fvy = LocalGS.free.y;
	  fnt_ElementType*CE2 = LocalGS.CE2;
	  int32 currPt = CE2->sp[contour];
	  int32 count = CE2->ep[contour] - currPt;
	  SECURE_CHECK_POINT (CE2, currPt + count);
	  CHECK_POINT (&LocalGS, CE2, currPt + count);
	  for (; count >= 0; --count)
	  {
		if (currPt != point || element != CE2)
		{
		  if (fvx) 
		  {
			CE2->x[currPt] += dx;
			CE2->f[currPt] |= XMOVED;
		  }
		  if (fvy) 
		  {
			CE2->y[currPt] += dy;
			CE2->f[currPt] |= YMOVED;
		  }
		}
		currPt++;
	  }
	}
	
	return pbyInst;
  }

/*********************************************************************/

/*
 * SHift Element                     rewritten 7/29/93 deanb
 *
 * Flags are no longer set to show touch in x or y direction
 */

FS_PRIVATE uint8* itrp_SHE (IPARAM)
{
	fnt_ElementType *element;
	F26Dot6 fxDX, fxDY;
	int32 lFirstPt, lRefPt, lLastPt, arg1;
	
	F26Dot6 fxSaveX;                    /* for ref point restoration */
	F26Dot6 fxSaveY;
	
	F26Dot6 *pfxX, *pfxStopX;           /* temporary element pointers */
	F26Dot6 *pfxY, *pfxStopY;
	
#ifdef FSCFG_SECURE
	if (BIT0 (lOpCode))
	{
	  SECURE_CHECK_POINT (LocalGS.CE0, LocalGS.Pt1);
	} 
	else 
	{
	  SECURE_CHECK_POINT (LocalGS.CE1, LocalGS.Pt2);
	}
#endif 

	element = itrp_SH_Common (GSA &fxDX, &fxDY, &lRefPt, lOpCode);
	
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	arg1 = (int32)CHECK_POP (LocalGS.stackPointer);
    SECURE_CHECK_ZONE(arg1);
	CHECK_ELEMENT (&LocalGS, arg1);
	SECURE_CHECK_FOR_UNITIALIZED_ZONE(&LocalGS.elements[arg1]);

	lLastPt = LocalGS.elements[arg1].ep[LocalGS.elements[arg1].nc - 1];
	SECURE_CHECK_POINT (&LocalGS.elements[arg1], lLastPt);
	CHECK_POINT (&LocalGS, &LocalGS.elements[arg1], lLastPt);
	lFirstPt  = LocalGS.elements[arg1].sp[0];
	SECURE_CHECK_POINT (&LocalGS.elements[arg1], lFirstPt);
	CHECK_POINT (&LocalGS, &LocalGS.elements[arg1], lFirstPt);

	if (element == &LocalGS.elements[arg1])     /* if ref pt is in same zone */     
	{
		fxSaveX = LocalGS.elements[arg1].x[lRefPt];
		fxSaveY = LocalGS.elements[arg1].y[lRefPt];
	}
	
	if (LocalGS.free.x != 0) 
	{
		pfxX = &LocalGS.elements[arg1].x[lFirstPt];
		pfxStopX = &LocalGS.elements[arg1].x[lLastPt];

		while (pfxX <= pfxStopX)
		{
			*pfxX += fxDX;                      /* shift each point in x */
			pfxX++;
		}
	}

	if (LocalGS.free.y != 0) 
	{
		pfxY = &LocalGS.elements[arg1].y[lFirstPt];
		pfxStopY = &LocalGS.elements[arg1].y[lLastPt];

		while (pfxY <= pfxStopY)
		{
			*pfxY += fxDY;                      /* shift each point in y */
			pfxY++;
		}
	}
	
	if (element == &LocalGS.elements[arg1])     /* if ref pt is in same zone */     
	{
		LocalGS.elements[arg1].x[lRefPt] = fxSaveX;
		LocalGS.elements[arg1].y[lRefPt] = fxSaveY;
	}

	return pbyInst;
}

/*********************************************************************/

/*
 * SHift point by PIXel amount
 */
  FS_PRIVATE uint8* itrp_SHPIX (IPARAM)
  {
	F26Dot6 proj, dx, dy;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, LocalGS.loop + 2);
	proj = CHECK_POP (LocalGS.stackPointer);
	if (LocalGS.free.x)
	  dx = (F26Dot6) VECTORMUL (proj, LocalGS.free.x);
	else
		dx = 0; // silence BC
	if (LocalGS.free.y)
	  dy = (F26Dot6) VECTORMUL (proj, LocalGS.free.y);
	else
		dy = 0; // silence BC

	return itrp_SHP_Common (GSA pbyInst, 
#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
		-1,
#endif
#ifdef FSCFG_SUBPIXEL
		true, // we do come from SHPIX
#endif
		dx, dy);
  }

/*********************************************************************/

/*
 * Interpolate Point
 */

uint8* itrp_IP (IPARAM)
{
	int32 arg1;
	int32 RP1;
	int32 RP2;
	
	int32 cLoop;
	fnt_ElementType *pCE0;
	fnt_ElementType *pCE1;
	fnt_ElementType *pCE2;
	fnt_ElementType *pTwilight;
	
	F26Dot6 x_RP1;
	F26Dot6 ox_RP1;
	F26Dot6 *pCE1_ox;
	F26Dot6 *pCE2_ox;

	F26Dot6 y_RP1;
	F26Dot6 oy_RP1;
	F26Dot6 *pCE1_oy;
	F26Dot6 *pCE2_oy;

	F26Dot6 oldRange;
	F26Dot6 proj;
	F26Dot6 fxDelta;
	
	F26Dot6 *pfxStack;

	FntMoveFunc MovePoint;
	FntProject Project;
	

	FS_UNUSED_PARAMETER(lOpCode);

	cLoop = LocalGS.loop + 1;               /* faster for ms c8 */
	pCE0 = LocalGS.CE0;
	pCE1 = LocalGS.CE1;
	pCE2 = LocalGS.CE2;
	pTwilight = &LocalGS.elements[TWILIGHTZONE];
	RP1 = LocalGS.Pt1;
	RP2 = LocalGS.Pt2;

	SECURE_CHECK_POINT (pCE0, RP1);
	SECURE_CHECK_POINT (pCE1, RP2);

	pfxStack = LocalGS.stackPointer;

	MovePoint = LocalGS.MovePoint;
	Project = LocalGS.Project;

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, cLoop);
    
	if (pCE0 == pTwilight || pCE1 == pTwilight || pCE2 == pTwilight 
		|| LocalGS.globalGS->bOriginalPointIsInvalid)
	{
		ox_RP1 = pCE0->ox[RP1];
		oy_RP1 = pCE0->oy[RP1];
		pCE1_ox = pCE1->ox;
		pCE1_oy = pCE1->oy;
		pCE2_ox = pCE2->ox;
		pCE2_oy = pCE2->oy;
	}
	else
	{
		ox_RP1 = pCE0->oox[RP1];
		oy_RP1 = pCE0->ooy[RP1];
		pCE1_ox = pCE1->oox;
		pCE1_oy = pCE1->ooy;
		pCE2_ox = pCE2->oox;
		pCE2_oy = pCE2->ooy;
	}
	x_RP1 = pCE0->x[RP1];
	y_RP1 = pCE0->y[RP1];
		
	oldRange = LocalGS.OldProject (GSA pCE1_ox[RP2] - ox_RP1, pCE1_oy[RP2] - oy_RP1);
	
	if (oldRange != 0)                      /* this should always happen */
	{
		if (MovePoint == itrp_XMovePoint)   /* so project is also xproject */
		{
			proj = pCE1->x[RP2] - x_RP1;
			while (cLoop != 0)
			{
				arg1 = (int32)CHECK_POP (pfxStack);
				SECURE_CHECK_POINT (pCE2, arg1);
				CHECK_POINT (&LocalGS, pCE2, arg1);

#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
				if (pCE2 != &LocalGS.elements[TWILIGHTZONE] && LocalGS.globalGS->pgmIndex == GLYPHPROGRAM && LocalGS.inSubPixelDirection && CompatibleWidthSP(LocalGS.globalGS))
					AddProportion(&LocalGS,pCE2,RP1,arg1,RP2);
#endif
				
				fxDelta = pCE2_ox[arg1] - ox_RP1;
				fxDelta = (F26Dot6)MulDiv26Dot6 (proj, fxDelta, oldRange);
				
				pCE2->x[arg1] = fxDelta + x_RP1;
				pCE2->f[arg1] |= XMOVED;
				cLoop--;
			}
		}
		else if (MovePoint == itrp_YMovePoint)  /* so project is also yproject */
		{
			proj = pCE1->y[RP2] - y_RP1;
			while (cLoop != 0)
			{
				arg1 = (int32)CHECK_POP (pfxStack);
				SECURE_CHECK_POINT (pCE2, arg1);
				CHECK_POINT (&LocalGS, pCE2, arg1);
				
#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
				if (pCE2 != &LocalGS.elements[TWILIGHTZONE] && LocalGS.globalGS->pgmIndex == GLYPHPROGRAM && LocalGS.inSubPixelDirection && CompatibleWidthSP(LocalGS.globalGS))
					AddProportion(&LocalGS,pCE2,RP1,arg1,RP2);
#endif
				
				fxDelta = pCE2_oy[arg1] - oy_RP1; 
				fxDelta = (F26Dot6) MulDiv26Dot6(proj, fxDelta, oldRange);
				
				pCE2->y[arg1] = fxDelta + y_RP1;
				pCE2->f[arg1] |= YMOVED;
				cLoop--;
			}
		}
		else    /* if (MovePoint == itrp_MovePoint) */
		{
			proj = Project (GSA pCE1->x[RP2] - x_RP1, pCE1->y[RP2] - y_RP1);
			while (cLoop != 0)
			{
				arg1 = (int32)CHECK_POP (pfxStack);
				SECURE_CHECK_POINT (pCE2, arg1);
				CHECK_POINT (&LocalGS, pCE2, arg1);
				
#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
				if (pCE2 != &LocalGS.elements[TWILIGHTZONE] && LocalGS.globalGS->pgmIndex == GLYPHPROGRAM && LocalGS.inSubPixelDirection && CompatibleWidthSP(LocalGS.globalGS))
					AddProportion(&LocalGS,pCE2,RP1,arg1,RP2);
#endif
				
				fxDelta = Project (GSA pCE2_ox[arg1] - ox_RP1, pCE2_oy[arg1] - oy_RP1);
				fxDelta = (F26Dot6) MulDiv26Dot6(proj, fxDelta, oldRange);
				MovePoint (GSA pCE2, arg1, fxDelta - 
					Project (GSA pCE2->x[arg1] - x_RP1, pCE2->y[arg1] - y_RP1) );
				cLoop--;
			}
		}
	}
	else    /* if (oldRange == 0) */  
			/* this should never happen, but for safety's sake... */
	{
		while (cLoop != 0)
		{
			arg1 = (int32)CHECK_POP (pfxStack);
			SECURE_CHECK_POINT (pCE2, arg1);
			CHECK_POINT (&LocalGS, pCE2, arg1);
						
#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
			if (pCE2 != &LocalGS.elements[TWILIGHTZONE] && LocalGS.globalGS->pgmIndex == GLYPHPROGRAM && LocalGS.inSubPixelDirection && CompatibleWidthSP(LocalGS.globalGS))
				AddProportion(&LocalGS,pCE2,RP1,arg1,RP2);
#endif
				
			fxDelta = Project (GSA pCE2_ox[arg1] - ox_RP1, pCE2_oy[arg1] - oy_RP1);
			MovePoint (GSA pCE2, arg1, fxDelta - 
				Project (GSA pCE2->x[arg1] - x_RP1, pCE2->y[arg1] - y_RP1) );
			cLoop--;
		}
	}       /* endif (oldRange != 0) */
	
	LocalGS.stackPointer = pfxStack;
	LocalGS.loop = 0;
	return pbyInst;
}

/*********************************************************************/

/*
 * Move Stack Indirect Relative Point
 */

uint8* itrp_MSIRP (IPARAM) {
	int32 iPt0;
	int32 iPt2;                            // point #
	F26Dot6 fxDist;                        // distance
#ifdef FSCFG_SUBPIXEL
#ifdef MSIRPRespectsCvtCutIn
	F26Dot6 fxOutlineDist;
	fnt_ParameterBlock *pb;
#endif
#endif
#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	long color;
#endif
	F26Dot6 fxPosition;
	fnt_ElementType *pCE0;
	fnt_ElementType *pCE1;

	pCE0 = LocalGS.CE0;
	pCE1 = LocalGS.CE1;
	iPt0 = LocalGS.Pt0;
	
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);

    fxDist = CHECK_POP (LocalGS.stackPointer);
	iPt2 = (int32)CHECK_POP (LocalGS.stackPointer);
	SECURE_CHECK_POINT (pCE0, iPt0);
	SECURE_CHECK_POINT (pCE1, iPt2);
	CHECK_POINT (&LocalGS, pCE1, iPt2);
		
#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	if (pCE1 != &LocalGS.elements[TWILIGHTZONE] && LocalGS.globalGS->pgmIndex == GLYPHPROGRAM && LocalGS.inSubPixelDirection && CompatibleWidthSP(LocalGS.globalGS)) {
		color = DoubleCheckLinkColor(pCE1,iPt0,iPt2,BLACK); // don't really know any better
		AddDistance(&LocalGS,pCE1,iPt0,iPt2,color);
	}
#endif

	if (pCE1 == &LocalGS.elements[TWILIGHTZONE]) {
		pCE1->ox[iPt2] = pCE0->ox[iPt0] + (F26Dot6) VECTORMUL (fxDist, LocalGS.proj.x);
		pCE1->oy[iPt2] = pCE0->oy[iPt0] + (F26Dot6) VECTORMUL (fxDist, LocalGS.proj.y);
		pCE1->x[iPt2] = pCE1->ox[iPt2];
		pCE1->y[iPt2] = pCE1->oy[iPt2];
	}
	
#ifdef FSCFG_SUBPIXEL
#ifdef MSIRPRespectsCvtCutIn
	if (!Tuned4SubPixel(LocalGS.globalGS) && LocalGS.inSubPixelDirection) {
	// similarly to MIRP, here we honour a cvt cut-in in case there is a non-trivial outline distance between the
	// parent (reference) and the child (target) point involved, in which case we assume the context is a stroke weight,
	// else we assume the context is an accent placement function, in which case we use the actual distance as before
		fxOutlineDist = (*LocalGS.OldProject) (GSA pCE1->ox[iPt2] - pCE0->ox[iPt0], pCE1->oy[iPt2] - pCE0->oy[iPt0]);
		if (fxOutlineDist) { // else assume we're positioning accents with a calculated MSIRP, hence no cvt cut-in
			pb = &LocalGS.globalGS->localParBlock;
			// notice that unlike MIRP, we don't do the autoFlip since MSIRP is used with calculated distances that
			// would have the correct sign to begin with.
			CVTCI(pb,fxDist,fxOutlineDist,CVT_CUT_IN_OVERSCALE);
		}
	}
#endif
#endif

	fxPosition = (*LocalGS.Project) (GSA pCE1->x[iPt2] - pCE0->x[iPt0], pCE1->y[iPt2] - pCE0->y[iPt0]);
	(*LocalGS.MovePoint) (GSA pCE1, iPt2, fxDist - fxPosition);
	
	LocalGS.Pt1 = iPt0;
	LocalGS.Pt2 = iPt2;
	if (BIT0 (lOpCode)) {
		LocalGS.Pt0 = iPt2; // move the reference point
	}
	return pbyInst;
} // itrp_MSIRP

/*********************************************************************/

/*
 * Align Relative Point
 */

FS_PRIVATE uint8* itrp_ALIGNRP (IPARAM)
  {
	fnt_ElementType*ce1 = LocalGS.CE1;
	F26Dot6 pt0x = LocalGS.CE0->x[LocalGS.Pt0];
	F26Dot6 pt0y = LocalGS.CE0->y[LocalGS.Pt0];

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, LocalGS.loop + 1);

	for (; LocalGS.loop >= 0; --LocalGS.loop)
	{
	  int32 ptNum = (int32)CHECK_POP (LocalGS.stackPointer);
	  F26Dot6 proj;

	  SECURE_CHECK_POINT (ce1, ptNum);
	  CHECK_POINT (&LocalGS, ce1, ptNum);
#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
		if (ce1 != &LocalGS.elements[TWILIGHTZONE] && LocalGS.globalGS->pgmIndex == GLYPHPROGRAM && LocalGS.inSubPixelDirection && CompatibleWidthSP(LocalGS.globalGS))
			// if we are aligning to some diagonal (pt0 and pt1 are set after SPVTL etc.), and if the child is between the parents
			// (InterAlign, cf. also comments there), we handle it as a proportion, else as a distance with non specific color.
			if (LocalGS.pt0 != -1 && LocalGS.pt1 != -1 && InterAlign(LocalGS.CE1,LocalGS.pt0,ptNum,LocalGS.pt1))
				AddProportion(&LocalGS,ce1,LocalGS.pt0,ptNum,LocalGS.pt1);
			else
				AddDistance(&LocalGS,ce1,LocalGS.Pt0,ptNum,OTHER);
#endif
	  proj = -(* LocalGS.Project) (GSA ce1->x[ptNum] - pt0x, ce1->y[ptNum] - pt0y);
	  (*LocalGS.MovePoint) (GSA ce1, ptNum, proj);
	}
	LocalGS.loop = 0;
	return pbyInst;
  }


/*
 * Align Two Points (by moving both of them)
 */
  FS_PRIVATE uint8* itrp_ALIGNPTS (IPARAM)
  {
	int32 pt1, pt2;
	F26Dot6 move1, dist;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	pt2  = (int32)CHECK_POP (LocalGS.stackPointer); /* point # 2   */
	pt1  = (int32)CHECK_POP (LocalGS.stackPointer); /* point # 1   */
	SECURE_CHECK_POINT (LocalGS.CE1, pt2);
	SECURE_CHECK_POINT (LocalGS.CE0, pt1);
	CHECK_POINT (&LocalGS, LocalGS.CE1, pt2);
	CHECK_POINT (&LocalGS, LocalGS.CE0, pt1);
/* We do not have to check if we are in character element zero (the twilight zone)
		   since both points already have to have defined values before we execute this instruction */
	dist = LocalGS.CE1->x[pt2] - LocalGS.CE0->x[pt1];
	move1 = LocalGS.CE1->y[pt2] - LocalGS.CE0->y[pt1];
	if (LocalGS.Project != itrp_XProject)
	{
	  if (LocalGS.Project == itrp_YProject)
		dist = move1;
	  else
		dist = (*LocalGS.Project) (GSA dist, move1);
	}

	move1 = dist >> 1;
	(*LocalGS.MovePoint) (GSA LocalGS.CE0, pt1, move1);
	(*LocalGS.MovePoint) (GSA LocalGS.CE1, pt2, move1 - dist);
	return pbyInst;
  }

/*
 * Set Angle Weight
 */
  FS_PRIVATE uint8* itrp_SANGW (IPARAM)
  {
	int32 arg;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	arg = CHECK_POP (LocalGS.stackPointer);
	CHECK_INT16 (arg);
	LocalGS.globalGS->localParBlock.angleWeight = (int16)arg;
	return pbyInst;
  }

/*
 * Flip Point
 */
  FS_PRIVATE uint8* itrp_FLIPPT (IPARAM)
  {
	uint8 *onCurve = LocalGS.CE0->onCurve;
	F26Dot6*stack = LocalGS.stackPointer;
	int32 count = LocalGS.loop;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, count + 1);

    for (; count >= 0; --count)
	{
	  int32 point = (int32)CHECK_POP (stack);
	  SECURE_CHECK_POINT (LocalGS.CE0, point);
	  CHECK_POINT (&LocalGS, LocalGS.CE0, point);
	  onCurve[ point ] ^= ONCURVE;
	}
	LocalGS.loop = 0;

	LocalGS.stackPointer = stack;
	return pbyInst;
  }

/*
 * Flip On a Range
 */
  FS_PRIVATE uint8* itrp_FLIPRGON (IPARAM)
  {
	int32 lo, hi;
	int32 count;
	uint8 *onCurve = LocalGS.CE0->onCurve;
	F26Dot6*stack = LocalGS.stackPointer;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	hi = (int32)CHECK_POP (stack);
	SECURE_CHECK_POINT (LocalGS.CE0, hi);
	CHECK_POINT (&LocalGS, LocalGS.CE0, hi);
	lo = (int32)CHECK_POP (stack);
	SECURE_CHECK_POINT (LocalGS.CE0, lo);
	CHECK_POINT (&LocalGS, LocalGS.CE0, lo);

	onCurve += lo;
	for (count = (int32) (hi - lo); count >= 0; --count)
	  *onCurve++ |= ONCURVE;
	LocalGS.stackPointer = stack;
	return pbyInst;
  }

/*
 * Flip Off a Range
 */
  FS_PRIVATE uint8* itrp_FLIPRGOFF (IPARAM)
  {
	int32 lo, hi;
	int32 count;
	uint8 *onCurve = LocalGS.CE0->onCurve;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	hi = (int32)CHECK_POP (LocalGS.stackPointer);
	SECURE_CHECK_POINT (LocalGS.CE0, hi);
	CHECK_POINT (&LocalGS, LocalGS.CE0, hi);
	lo = (int32)CHECK_POP (LocalGS.stackPointer);
	SECURE_CHECK_POINT (LocalGS.CE0, lo);
	CHECK_POINT (&LocalGS, LocalGS.CE0, lo);

	onCurve += lo;
	for (count = (int32) (hi - lo); count >= 0; --count)
	  *onCurve++ &= ~ONCURVE;
	return pbyInst;
  }

/* 4/22/90 rwb - made more general
 * Sets lower 16 flag bits of ScanControl variable.  Sets scanContolIn if we are in one
 * of the preprograms; else sets scanControlOut.
 *
 * stack: value => -;
 *
 */
  FS_PRIVATE uint8* itrp_SCANCTRL (IPARAM)
  {
	fnt_GlobalGraphicStateType *globalGS = LocalGS.globalGS;
	fnt_ParameterBlock *pb = &globalGS->localParBlock;
	int32 arg;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	arg = CHECK_POP (LocalGS.stackPointer);
	CHECK_INT16 (arg);
	pb->scanControl = (pb->scanControl & 0xFFFF0000) | arg;
	return pbyInst;
  }

/* 5/24/90 rwb
 * Sets upper 16 bits of ScanControl variable. Sets scanContolIn if we are in one
 * of the preprograms; else sets scanControlOut.
 */

  FS_PRIVATE uint8* itrp_SCANTYPE (IPARAM)
  {
	fnt_GlobalGraphicStateType *globalGS;
	fnt_ParameterBlock *pb;
	int32 *scanPtr;
	int32 arg;

	FS_UNUSED_PARAMETER(lOpCode);

	globalGS = LocalGS.globalGS;
	pb = &globalGS->localParBlock;
	scanPtr = (int32*)&(pb->scanControl);
	
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	arg = CHECK_POP (LocalGS.stackPointer);
	CHECK_INT16 (arg);

/*  how it was:
	CHECK_SCANMODE (arg);
	if (arg == 0)  
	  *scanPtr &= 0xFFFF;
	else if (arg == 1)        
	  *scanPtr = (*scanPtr & 0xFFFF) | STUBCONTROL;
	else if (arg == 2)        
	  *scanPtr = (*scanPtr & 0xFFFF) | NODOCONTROL;
*/

/*  now any 8 bit value may be passed to the scan converter */
	
	*scanPtr = (*scanPtr & 0xFFFF) | (arg << 16);
	return pbyInst;
  }

/* 6/28/90 rwb
 * Sets instructControl flags in global graphic state.  Only legal in pre program.
 * A selector is used to choose the flag to be set.
 * Bit0 - NOGRIDFITFLAG - if set, then truetype instructions are not executed.
 *              A font may want to use the preprogram to check if the glyph is rotated or
 *              transformed in such a way that it is better to not gridfit the glyphs.
 * Bit1 - DEFAULTFLAG - if set, then changes in localParameterBlock variables in the
 *              globalGraphics state made in the CVT preprogram are not copied back into
 *              the defaultParameterBlock.  So, the original default values are the starting
 *              values for each glyph.
 * Bit2 - TUNED4SPFLAG - if set, a font will be rendered in native SP mode (as opposed to
 *              backwards compatible mode)
 *
 * stack: value, selector => -;
 *
 */
  FS_PRIVATE uint8* itrp_INSTCTRL (IPARAM)  /* <13> */
  {
	fnt_GlobalGraphicStateType *globalGS;
	int32 *ic;
	int32 selector;
	int32 value;
	int32 arg;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	globalGS = LocalGS.globalGS;
	ic = (int32*)&globalGS->localParBlock.instructControl;
	arg = CHECK_POP (LocalGS.stackPointer);
	value = CHECK_POP (LocalGS.stackPointer);
	CHECK_INT16 (arg);
	selector = (int32)arg;
	CHECK_SELECTOR (selector);
	if (globalGS->init)
	{
	  if (selector == 1) 
		*ic &= ~NOGRIDFITFLAG;
	  else if (selector == 2) 
		*ic &= ~DEFAULTFLAG;
	  else if (selector == 3)
		*ic &= ~TUNED4SPFLAG;

	  *ic |= value;
	}
	return pbyInst;
  }

/*
 * AdjustAngle         <4>
 */
  FS_PRIVATE uint8* itrp_AA (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);

	/* This is a NOP now. However, do pop the argument off the stack -amitc- 9/11/91. */
	/* Discard the popped value. -lenox- 11/11/91 */
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	(void) CHECK_POP (LocalGS.stackPointer);
						 /* old code now lives in history.fnt - deanb */
	return pbyInst;
  }

/*********************************************************************/

/* Called by itrp_PUSHB and itrp_NPUSHB */

/* these functions were split out from itrp_PushSomeStuff - deanb */
  
FS_PRIVATE uint8* itrp_PushSomeBytes (GSP int32 count, uint8* pbyInst)
{
	F26Dot6 *stack;
		
	stack = LocalGS.stackPointer;
    SECURE_CHECK_FOR_PUSH (stack, count);
	while (count != 0)
	{
		CHECK_PUSH (stack, *pbyInst++);
		count--;
	}
	LocalGS.stackPointer = stack;
	return pbyInst;
}

FS_PRIVATE uint8* itrp_PushSomeWords (GSP int32 count, uint8* pbyInst)
{
	F26Dot6 *stack;
	int16 word;
		
	stack = LocalGS.stackPointer;
    SECURE_CHECK_FOR_PUSH (stack, count);
	while (count != 0)
	{
		word = *pbyInst++;
		CHECK_PUSH (stack, (int16) ((word << 8) + *pbyInst++));
		count--;
	}
	LocalGS.stackPointer = stack;
	return pbyInst;
}

/*********************************************************************/

/*
 * PUSH 1 Byte           the most commonly called pushb
 */
FS_PRIVATE uint8* itrp_PUSHB1 (IPARAM)
{
	FS_UNUSED_PARAMETER(lOpCode);
    SECURE_CHECK_FOR_PUSH (LocalGS.stackPointer, 1);
	CHECK_PUSH (LocalGS.stackPointer, *pbyInst++);
	return pbyInst;
}

/*
 * PUSH Bytes
 */
FS_PRIVATE uint8* itrp_PUSHB (IPARAM)
{
	int32 iCount;

	iCount = lOpCode - 0xb0 + 1;
	return itrp_PushSomeBytes (GSA iCount, pbyInst);
}

/*
 * N PUSH Bytes
 */
FS_PRIVATE uint8* itrp_NPUSHB (IPARAM)
{
	int32 iCount;

	FS_UNUSED_PARAMETER(lOpCode);

	iCount = (int32)*pbyInst++;
	return itrp_PushSomeBytes (GSA iCount, pbyInst);
}

/*
 * PUSH 1 Word           the most commonly called pushw
 */
FS_PRIVATE uint8* itrp_PUSHW1 (IPARAM)
{
	int16 word;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_PUSH (LocalGS.stackPointer, 1);
	word = *pbyInst++;
	CHECK_PUSH (LocalGS.stackPointer, (int16)((word << 8) + *pbyInst++));
	return pbyInst;
}

/*
 * PUSH Words           <3>
 */
FS_PRIVATE uint8* itrp_PUSHW (IPARAM)
{
	int32 iCount;

	iCount = lOpCode - 0xb8 + 1;
	return itrp_PushSomeWords (GSA iCount, pbyInst);
}

/*
 * N PUSH Words
 */
FS_PRIVATE uint8* itrp_NPUSHW (IPARAM)
{
	int32 iCount;

	FS_UNUSED_PARAMETER(lOpCode);

	iCount = (int32)*pbyInst++;
	return itrp_PushSomeWords (GSA iCount, pbyInst);
}

/*********************************************************************/

/*
 * Write Store
 */
  FS_PRIVATE uint8* itrp_WS (IPARAM)
  {
	F26Dot6 storage;
	int32 storeIndex;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	storage = CHECK_POP (LocalGS.stackPointer);
	storeIndex = (int32)CHECK_POP (LocalGS.stackPointer);

	SECURE_CHECK_STORAGE (storeIndex);
	CHECK_STORAGE (&LocalGS,storeIndex);

	LocalGS.globalGS->store[ storeIndex ] = storage;
	return pbyInst;
  }

/*
 * Read Store
 */
  FS_PRIVATE uint8* itrp_RS (IPARAM) {
	int32 storeIndex;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	storeIndex = (int32)CHECK_POP (LocalGS.stackPointer);
	SECURE_CHECK_STORAGE (storeIndex);
	CHECK_STORAGE (&LocalGS, storeIndex);
#ifdef FSCFG_SUBPIXEL
#ifdef BypassVacuformRound
	if (storeIndex == 8 && RunningSubPixel(LocalGS.globalGS) && !Tuned4SubPixel(LocalGS.globalGS) && (LocalGS.globalGS->subPixelCompatibilityFlags & SPCF_detectedVacuformRound) > 0) {
		LocalGS.globalGS->subPixelCompatibilityFlags |= SPCF_inVacuformRound;
		CHECK_PUSH (LocalGS.stackPointer, 0); // push 0 indicating we don't do vacuforming
	} else {
#endif
#endif
		CHECK_PUSH (LocalGS.stackPointer, LocalGS.globalGS->store[storeIndex]);
#ifdef FSCFG_SUBPIXEL
#ifdef BypassVacuformRound
	}
#endif
#endif
	return pbyInst;
  }

/*
 * Write Control Value Table from outLine, assumes the value comes form the outline domain
 */
  FS_PRIVATE uint8* itrp_WCVT (IPARAM)
  {
	int32 cvtIndex;
	F26Dot6 cvtValue;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	cvtValue = CHECK_POP (LocalGS.stackPointer);
	cvtIndex = (int32)CHECK_POP (LocalGS.stackPointer);

	SECURE_CHECK_CVT (cvtIndex);
	CHECK_CVT (&LocalGS, cvtIndex);

	if (cvtValue != 0 && LocalGS.GetCVTEntry != itrp_GetCVTEntryFast)
	  cvtValue = FixDiv (cvtValue, itrp_GetCVTScale (GSA0));
	LocalGS.globalGS->controlValueTable[ cvtIndex ] = cvtValue;
	return pbyInst;
  }

/*
 * Write Control Value Table From Original Domain, assumes the value comes from the original domain, not the cvt or outline
 */
  FS_PRIVATE uint8* itrp_WCVTFOD (IPARAM)
  {
	int32 cvtIndex;
	F26Dot6 cvtValue;
	fnt_GlobalGraphicStateType *globalGS = LocalGS.globalGS;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	cvtValue = CHECK_POP (LocalGS.stackPointer);
	cvtIndex = (int32)CHECK_POP (LocalGS.stackPointer);
	SECURE_CHECK_CVT (cvtIndex);
	CHECK_CVT (&LocalGS, cvtIndex);
	globalGS->controlValueTable[ cvtIndex ] = globalGS->ScaleFuncCVT (&globalGS->scaleCVT, cvtValue);
	return pbyInst;
  }



/*
 * Read Control Value Table
 */
  FS_PRIVATE uint8* itrp_RCVT (IPARAM)
  {
	int32 cvtIndex;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	cvtIndex = (int32)CHECK_POP (LocalGS.stackPointer);

#ifndef FSCFG_FONTOGRAPHER_BUG
	SECURE_CHECK_CVT (cvtIndex);
#else
	SECURE_CHECK_CVT_READ_SPECIAL (cvtIndex);
#endif // FSCFG_FONTOGRAPHER_BUG

	CHECK_CVT (&LocalGS, cvtIndex);

	LocalGS.GetCVTEntry (GSA cvtIndex);
	CHECK_PUSH (LocalGS.stackPointer, LocalGS.GetCVTEntry (GSA cvtIndex));
	return pbyInst;
  }

/*
 * Read Coordinate
 */
  FS_PRIVATE uint8* itrp_RC (IPARAM)
  {
	int32 pt;
	fnt_ElementType * element;
	F26Dot6 proj;

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	pt = (int32)CHECK_POP (LocalGS.stackPointer);
	element = LocalGS.CE2;
	SECURE_CHECK_POINT (element, pt);
	CHECK_POINT (&LocalGS, element, pt);

	if (BIT0 (lOpCode))
	  proj = (*LocalGS.OldProject) (GSA element->ox[pt], element->oy[pt]);
	else
	  proj = (*LocalGS.Project) (GSA element->x[pt], element->y[pt]);

	CHECK_PUSH (LocalGS.stackPointer, proj);
	return pbyInst;
  }

/*
 * Write Coordinate
 */
  FS_PRIVATE uint8* itrp_WC (IPARAM)
  {
	F26Dot6 proj, coord;
	int32 pt;
	fnt_ElementType *element;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	coord = CHECK_POP (LocalGS.stackPointer);/* value */
	pt = (int32)CHECK_POP (LocalGS.stackPointer);/* point */
	element = LocalGS.CE2;
	SECURE_CHECK_POINT (element, pt);
	CHECK_POINT (&LocalGS, element, pt);

	proj = (*LocalGS.Project) (GSA element->x[pt],  element->y[pt]);
	proj = coord - proj;

	(*LocalGS.MovePoint) (GSA element, pt, proj);

	if (element == &LocalGS.elements[TWILIGHTZONE])
	{
	  element->ox[pt] = element->x[pt];
	  element->oy[pt] = element->y[pt];
	}
	return pbyInst;
  }


/*
 * Measure Distance
 */
  FS_PRIVATE uint8* itrp_MD (IPARAM)
  {
	int32 pt1, pt2;
	F26Dot6 proj, *stack = LocalGS.stackPointer;
	fnt_GlobalGraphicStateType *globalGS = LocalGS.globalGS;

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	pt2 = (int32)CHECK_POP (stack);
	pt1 = (int32)CHECK_POP (stack);
	SECURE_CHECK_POINT (LocalGS.CE0, pt1);
	SECURE_CHECK_POINT (LocalGS.CE1, pt2);
	CHECK_POINT (&LocalGS, LocalGS.CE0, pt1);
	CHECK_POINT (&LocalGS, LocalGS.CE1, pt2);
	if (BIT0 (lOpCode - MD_CODE)) { // MD[O] in original outline
		if (LocalGS.CE0 == &LocalGS.elements[TWILIGHTZONE] || LocalGS.CE1 == &LocalGS.elements[TWILIGHTZONE] 
			|| LocalGS.globalGS->bOriginalPointIsInvalid)
		{
			proj = (*LocalGS.OldProject) (GSA LocalGS.CE1->ox[pt1] - LocalGS.CE0->ox[pt2], LocalGS.CE1->oy[pt1] - LocalGS.CE0->oy[pt2]);
		}
		else if (globalGS->bSameStretch)
		{
			proj = (*LocalGS.OldProject) (GSA LocalGS.CE1->oox[pt1] - LocalGS.CE0->oox[pt2], LocalGS.CE1->ooy[pt1] - LocalGS.CE0->ooy[pt2] );
			proj = globalGS->ScaleFuncCVT( &globalGS->scaleCVT, proj );
		}
		else
		{
			proj = (*LocalGS.OldProject) (GSA 
				globalGS->ScaleFuncX (&globalGS->scaleX, LocalGS.CE1->oox[pt1] - LocalGS.CE0->oox[pt2]), 
				globalGS->ScaleFuncY (&globalGS->scaleY, LocalGS.CE1->ooy[pt1] - LocalGS.CE0->ooy[pt2]) );
		}
	}

	/* old MS code, give different value than Apple :
	 * proj  = (*LocalGS.OldProject) (GSA LocalGS.CE0->ox[pt1] - LocalGS.CE1->ox[pt2], LocalGS.CE0->oy[pt1] - LocalGS.CE1->oy[pt2]);
	*/
	
	else { // MD[N] in grid-fitted outline
		proj  = (*LocalGS.Project) (GSA LocalGS.CE0->x[pt1] - LocalGS.CE1->x[pt2], LocalGS.CE0->y[pt1] - LocalGS.CE1->y[pt2]);
#ifdef FSCFG_SUBPIXEL
#ifdef BypassVacuformRound
		if ((LocalGS.globalGS->subPixelCompatibilityFlags & (SPCF_iupxCalled | SPCF_iupyCalled | SPCF_inVacuformRound)) == (SPCF_iupxCalled | SPCF_iupyCalled | SPCF_inVacuformRound) && proj == FNT_PIXELSIZE)
			proj++; // increase by smallest possible amount to throw off type 2 vacuforms which are keyed off a distance being exacly 1 pixel
#endif
#endif
	}
	CHECK_PUSH (stack, proj);
	LocalGS.stackPointer = stack;
	return pbyInst;
  }

/*
 * Measure Pixels Per EM
 */
  FS_PRIVATE uint8* itrp_MPPEM (IPARAM)
  {
	uint16 ppem;
	fnt_GlobalGraphicStateType *globalGS = LocalGS.globalGS;

	FS_UNUSED_PARAMETER(lOpCode);

	ppem = globalGS->pixelsPerEm;
	if (!globalGS->bSameStretch)
		ppem = (uint16)FixMul (ppem, itrp_GetCVTScale (GSA0));

    SECURE_CHECK_FOR_PUSH (LocalGS.stackPointer, 1);
	CHECK_PUSH (LocalGS.stackPointer, ppem);
	return pbyInst;
  }

/*
 * Measure Point Size
 */
  FS_PRIVATE uint8* itrp_MPS (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_PUSH (LocalGS.stackPointer, 1);
	CHECK_PUSH (LocalGS.stackPointer, LocalGS.globalGS->pointSize);
	return pbyInst;
  }

/*
 * Get Miscellaneous info: version number, rotated, stretched   <6>
 * Version number is 8 bits.  This is version 0x01 : 5/1/90
 *
 */

  FS_PRIVATE uint8* itrp_GETINFO (IPARAM)
  {
	fnt_GlobalGraphicStateType *globalGS = LocalGS.globalGS;
	int32      info = 0;
	int32      selector;
	int32      arg;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	arg = CHECK_POP (LocalGS.stackPointer);
	CHECK_INT16 (arg);
	selector = (int32)arg;
	CHECK_SELECTOR (selector);
	if (selector & VERSIONINTERPRETERQUERY)                            /* version */
	  info |= RASTERIZER_VERSION;
	if ((selector & ROTATEDINTERPRETERQUERY) && (globalGS->non90DegreeTransformation & NON90DEGTRANS_ROTATED))
	  info |= ROTATEDGLYPH;
	if ((selector & STRETCHEDINTERPRETERQUERY) && (globalGS->non90DegreeTransformation & NON90DEGTRANS_STRETCH))
	  info |= STRETCHEDGLYPH;
	if ((selector & HINTFORGRAYINTERPRETERQUERY) && (globalGS->bHintForGray))
	  info |= HINTEDFORGRAYGLYPH;
#ifdef FSCFG_SUBPIXEL
	if ((selector & HINTFORSUBPIXELINTERPRETERQUERY) && (globalGS->flHintForSubPixel & FNT_SP_SUB_PIXEL))
	  info |= HINTEDFORSUBPIXELGLYPH;
	if ((selector & HINTFORSUBPIXELCOMPATIBLEWIDTHINTERPRETERQUERY) && (globalGS->flHintForSubPixel & FNT_SP_COMPATIBLE_WIDTH))
	  info |= HINTEDFORSUBPIXELCOMPATIBLEWIDTHGLYPH;
	if ((selector & HINTFORSUBPIXELVERTICALDIRECTIONINTERPRETERQUERY) && (globalGS->flHintForSubPixel & FNT_SP_VERTICAL_DIRECTION))
	  info |= HINTEDFORSUBPIXELVERTICALDIRECTIONGLYPH;
	if ((selector & HINTFORSUBPIXELBGRORDERINTERPRETERQUERY) && (globalGS->flHintForSubPixel & FNT_SP_BGR_ORDER))
	  info |= HINTEDFORSUBPIXELBGRORDERGLYPH;
#endif // FSCFG_SUBPIXEL
	CHECK_PUSH (LocalGS.stackPointer, info);
	return pbyInst;
  } // itrp_GETINFO

/*
 * FLIP ON
 */
  FS_PRIVATE uint8* itrp_FLIPON (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);
	LocalGS.globalGS->localParBlock.autoFlip = true;
	return pbyInst;
  }

/*
 * FLIP OFF
 */
  FS_PRIVATE uint8* itrp_FLIPOFF (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);
	LocalGS.globalGS->localParBlock.autoFlip = false;
	return pbyInst;
  }

#ifndef NOT_ON_THE_MAC
#ifdef FSCFG_DEBUG
/*
 * DEBUG
 */
  FS_PRIVATE uint8* itrp_DEBUG (IPARAM)
  {
	int32 arg;
	int8 buffer[24];

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	arg = CHECK_POP (LocalGS.stackPointer);

	buffer[1] = 'D';
	buffer[2] = 'E';
	buffer[3] = 'B';
	buffer[4] = 'U';
	buffer[5] = 'G';
	buffer[6] = ' ';
	if (arg >= 0) 
	{
	  buffer[7] = '+';
	} 
	else 
	{
	  arg = -arg;
	  buffer[7] = '-';
	}

	buffer[13] = arg % 10 + '0'; 
	arg /= 10;
	buffer[12] = arg % 10 + '0'; 
	arg /= 10;
	buffer[11] = arg % 10 + '0'; 
	arg /= 10;
	buffer[10] = arg % 10 + '0'; 
	arg /= 10;
	buffer[ 9] = arg % 10 + '0'; 
	arg /= 10;
	buffer[ 8] = arg % 10 + '0'; 
	arg /= 10;

	buffer[14] = arg ? '*' : ' ';


	buffer[0] = 14; /* convert to pascal */
	DEBUGSTR (buffer);
	return pbyInst;
  }

#else           /* debug */

  FS_PRIVATE uint8* itrp_DEBUG (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	CHECK_POP (LocalGS.stackPointer);
	return pbyInst;
  }

#endif          /* debug */
#else

  FS_PRIVATE uint8* itrp_DEBUG (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	CHECK_POP (LocalGS.stackPointer);
	return pbyInst;
  }

#endif          /* ! not on the mac */


/* these functions were split out from itrp_BinaryOperand - deanb */

  FS_PRIVATE uint8* itrp_LT (IPARAM)
  {
	F26Dot6 *pfxStack;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	pfxStack = LocalGS.stackPointer - 1;
	LocalGS.stackPointer = pfxStack;
	pfxStack[-1] = (pfxStack[-1] < pfxStack[0]) ? 1 : 0;
	CHECK_STACK (&LocalGS);
	return pbyInst;
  }

  FS_PRIVATE uint8* itrp_LTEQ (IPARAM)
  {
	F26Dot6 *pfxStack;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	pfxStack = LocalGS.stackPointer - 1;
	LocalGS.stackPointer = pfxStack;
	pfxStack[-1] = (pfxStack[-1] <= pfxStack[0]) ? 1 : 0;
	CHECK_STACK (&LocalGS);
	return pbyInst;
  }

  FS_PRIVATE uint8* itrp_GT (IPARAM)
  {
	F26Dot6 *pfxStack;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	pfxStack = LocalGS.stackPointer - 1;
	LocalGS.stackPointer = pfxStack;
	pfxStack[-1] = (pfxStack[-1] > pfxStack[0]) ? 1 : 0;
	CHECK_STACK (&LocalGS);
	return pbyInst;
  }

  FS_PRIVATE uint8* itrp_GTEQ (IPARAM)
  {
	F26Dot6 *pfxStack;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	pfxStack = LocalGS.stackPointer - 1;
	LocalGS.stackPointer = pfxStack;
	pfxStack[-1] = (pfxStack[-1] >= pfxStack[0]) ? 1 : 0;
	CHECK_STACK (&LocalGS);
	return pbyInst;
  }

  FS_PRIVATE uint8* itrp_EQ (IPARAM)
  {
	F26Dot6 *pfxStack;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	pfxStack = LocalGS.stackPointer - 1;
	LocalGS.stackPointer = pfxStack;
	pfxStack[-1] = (pfxStack[-1] == pfxStack[0]) ? 1 : 0;
	CHECK_STACK (&LocalGS);
	return pbyInst;
  }

  FS_PRIVATE uint8* itrp_NEQ (IPARAM)
  {
	F26Dot6 *pfxStack;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	pfxStack = LocalGS.stackPointer - 1;
	LocalGS.stackPointer = pfxStack;
	pfxStack[-1] = (pfxStack[-1] != pfxStack[0]) ? 1 : 0;
	CHECK_STACK (&LocalGS);
	return pbyInst;
  }

  FS_PRIVATE uint8* itrp_AND (IPARAM)
  {
	F26Dot6 *pfxStack;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	pfxStack = LocalGS.stackPointer - 1;
	LocalGS.stackPointer = pfxStack;
	pfxStack[-1] = (pfxStack[-1] && pfxStack[0]) ? 1 : 0;
	CHECK_STACK (&LocalGS);
	return pbyInst;
  }

  FS_PRIVATE uint8* itrp_OR (IPARAM)
  {
	F26Dot6 *pfxStack;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	pfxStack = LocalGS.stackPointer - 1;
	LocalGS.stackPointer = pfxStack;
	pfxStack[-1] = (pfxStack[-1] || pfxStack[0]) ? 1 : 0;
	CHECK_STACK (&LocalGS);
	return pbyInst;
  }

  FS_PRIVATE uint8* itrp_ADD (IPARAM)
  {
	F26Dot6 *pfxStack;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	pfxStack = LocalGS.stackPointer - 1;
	LocalGS.stackPointer = pfxStack;
	pfxStack[-1] += pfxStack[0];
	CHECK_STACK (&LocalGS);
	return pbyInst;
  }

  FS_PRIVATE uint8* itrp_SUB (IPARAM)
  {
	F26Dot6 *pfxStack;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	pfxStack = LocalGS.stackPointer - 1;
	LocalGS.stackPointer = pfxStack;
	pfxStack[-1] -= pfxStack[0];
	CHECK_STACK (&LocalGS);
	return pbyInst;
  }

  FS_PRIVATE uint8* itrp_MUL (IPARAM)
  {
	F26Dot6 *pfxStack;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	pfxStack = LocalGS.stackPointer - 1;
	LocalGS.stackPointer = pfxStack;
	pfxStack[-1] =  Mul26Dot6(pfxStack[-1], pfxStack[0]);
	CHECK_STACK (&LocalGS);
	return pbyInst;
  }

  FS_PRIVATE uint8* itrp_DIV (IPARAM)
  {
	F26Dot6 *pfxStack;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	pfxStack = LocalGS.stackPointer - 1;
	LocalGS.stackPointer = pfxStack;
	if (pfxStack[0] == 0)
	{
		LocalGS.ercReturn = DIV_BY_0_IN_HINTING_ERR;  /* returned to client, error DIV by zero */
		return LocalGS.pbyEndInst;
	} 
	pfxStack[-1] = (int32)(((long)pfxStack[-1] << 6) / pfxStack[0]);
	CHECK_STACK (&LocalGS);
	return pbyInst;
  }

  FS_PRIVATE uint8* itrp_MAX (IPARAM)
  {
	F26Dot6 *pfxStack;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	pfxStack = LocalGS.stackPointer - 1;
	LocalGS.stackPointer = pfxStack;
	if (pfxStack[-1] < pfxStack[0])
	{
		pfxStack[-1] = pfxStack[0];
	}
	CHECK_STACK (&LocalGS);
	return pbyInst;
  }
  
  FS_PRIVATE uint8* itrp_MIN (IPARAM)
  {
	F26Dot6 *pfxStack;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	pfxStack = LocalGS.stackPointer - 1;
	LocalGS.stackPointer = pfxStack;
	if (pfxStack[-1] > pfxStack[0])
	{
		pfxStack[-1] = pfxStack[0];
	}
	CHECK_STACK (&LocalGS);
	return pbyInst;
  }

/**************************************************************************/

/* these functions were split out from itrp_UnaryOperand - deanb */

// for the ODD/EVEN pair, b/w, and no engine compensation case, we could
// essentially look at the two bits before and after the binary point of
// the F26Dot6 number:
//		1.100000 rounds to 2 (even)
//		1.000000 rounds to 1 (odd)
//		0.100000 rounds to 1 (odd)
//		0.000000 rounds to 0 (even)
// If the two bits are equal, then the number is even, else odd
// for engine compensation, we currently call the full itrp_RoundToGrid
// we'll allow tagged SP fonts to inquire about even/odd virtual pixels

  FS_PRIVATE uint8* itrp_ODD (IPARAM) {
	F26Dot6 *pfxStack;
	F26Dot6 fxArg;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	pfxStack = LocalGS.stackPointer - 1;
	fxArg = itrp_RoundToGrid (GSA *pfxStack, 0);
	fxArg >>= FNT_PIXELSHIFT;
	*pfxStack = fxArg & 1L;
	return pbyInst;
  }

  FS_PRIVATE uint8* itrp_EVEN (IPARAM) {
	F26Dot6 *pfxStack;
	F26Dot6 fxArg;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	pfxStack = LocalGS.stackPointer - 1;
	fxArg = itrp_RoundToGrid (GSA *pfxStack, 0);
	fxArg >>= FNT_PIXELSHIFT;
	fxArg++;
	*pfxStack = fxArg & 1L;
	return pbyInst;
  }

  FS_PRIVATE uint8* itrp_NOT (IPARAM)
  {
	F26Dot6 *pfxStack;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	pfxStack = LocalGS.stackPointer - 1;
	*pfxStack = !*pfxStack;
	return pbyInst;
  }
	  
  FS_PRIVATE uint8* itrp_ABS (IPARAM)
  {
	F26Dot6 *pfxStack;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	pfxStack = LocalGS.stackPointer - 1;
	if (*pfxStack < 0L)
	{
		*pfxStack = -*pfxStack;
	}
	return pbyInst;
  }
	  
  FS_PRIVATE uint8* itrp_NEG (IPARAM)
  {
	F26Dot6 *pfxStack;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	pfxStack = LocalGS.stackPointer - 1;
	*pfxStack = -*pfxStack;
	return pbyInst;
  }
	  
  FS_PRIVATE uint8* itrp_CEILING (IPARAM)
  {
	F26Dot6 *pfxStack;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	pfxStack = LocalGS.stackPointer - 1;
	*pfxStack += FNT_PIXELSIZE - 1;		// actually, this is not the pixel size, but the number 1 in 26.6
	*pfxStack &= ~(FNT_PIXELSIZE - 1);	// same here
	return pbyInst;
  }
	  
  FS_PRIVATE uint8* itrp_FLOOR (IPARAM)
  {
	F26Dot6 *pfxStack;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	pfxStack = LocalGS.stackPointer - 1;
	*pfxStack &= ~(FNT_PIXELSIZE - 1);	// actually, this is not the pixel size, but the number 1 in 26.6
	return pbyInst;
  }
	  

/**************************************************************************/

/* This is called by itrp_IF, itrp_ELSE, itrp_FDEF, and itrp_IDEF         */
/* It is used to find the next TrueType instruction in the instruction    */
/* stream by skipping over push data.  It is table driven for speed.      */

static const uint8 gbyPushTable[] = {
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
   21,22, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	1, 2, 3, 4, 5, 6, 7, 8, 2, 4, 6, 8,10,12,14,16,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};

FS_PRIVATE uint8* itrp_SkipPushData (GSP uint8* pbyInst)
{
	int32 iDataCount;         /* count of data following push instruction */
	
	iDataCount = (int32)gbyPushTable[ pbyInst[-1] ];   /* opcode */
	
	if (iDataCount != 0)                        /* if a push instruction */
	{
		if (iDataCount == 21)                   /* special for npushb */
		{
			iDataCount = (int32)*pbyInst + 1;
		}
		else if (iDataCount == 22)              /* special for npushw */
		{
			iDataCount = ((int32)*pbyInst << 1) + 1;
		}
		pbyInst += iDataCount;

	}
	return pbyInst;
}

/**************************************************************************/

/*
 * IF
 */
FS_PRIVATE uint8* itrp_IF (IPARAM)
{
	int32 iLevel;
	int32 iScanOpCode;
	int32 iDataCount;         /* count of data following push instruction */

	FS_UNUSED_PARAMETER(lOpCode);	
	
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	if (!CHECK_POP (LocalGS.stackPointer))
	{
		iLevel = 1;
		while ((iLevel != 0) && (pbyInst < LocalGS.pbyEndInst))     /* iLevel = # of IF's minus # of EIF's */
		{
			iScanOpCode = (int32)*pbyInst++;

			if (iScanOpCode == EIF_CODE)
			{
				ERR_IF (-1);
				iLevel--;
			} 
			else if (iScanOpCode == IF_CODE) 
			{
				ERR_IF (1);
				iLevel++;
			} 
			else if (iScanOpCode == ELSE_CODE) 
			{
				if (iLevel == 1) 
					break;
			} 
			else
			{
				iDataCount = (int32)gbyPushTable[iScanOpCode];
				
				if (iDataCount != 0)            /* if a push instruction */
				{
					if (iDataCount == 21)       /* special for npushb */
					{
						iDataCount = (int32)*pbyInst + 1;
					}
					else if (iDataCount == 22)  /* special for npushw */
					{
						iDataCount = ((int32)*pbyInst << 1) + 1;
					}
					pbyInst += iDataCount;
				}
			}
		}

		if ((pbyInst == LocalGS.pbyEndInst) && (iLevel != 0))
		{
			LocalGS.ercReturn = MISSING_EIF_ERR;  /* returned to client, missing EIF */

		}
	}
	return pbyInst;
}

/**************************************************************************/

/*
 *      ELSE for the IF
 */
FS_PRIVATE uint8* itrp_ELSE (IPARAM)
{
	int16 level;
	uint8 opCode;

	FS_UNUSED_PARAMETER(lOpCode);

	level = 1;
	while ((level != 0) && (pbyInst < LocalGS.pbyEndInst))     /* iLevel = # of IF's minus # of EIF's */
	{
		opCode = *pbyInst++;
		
		if (opCode == EIF_CODE)
		{
			ERR_IF (-1);
			level--;
		} 
		else if (opCode == IF_CODE) 
		{
			ERR_IF (1);
			level++;
		} 
		else
		{
			pbyInst = itrp_SkipPushData (GSA pbyInst);
		}
	}

	if (level != 0)
	{
		LocalGS.ercReturn = MISSING_EIF_ERR;  /* returned to client, missing EIF */

	}
	return pbyInst;
}

/**************************************************************************/

/*
 * End IF
 */
FS_PRIVATE uint8* itrp_EIF (IPARAM)
{
	FS_UNUSED_PARAMETER(lOpCode);

	return pbyInst;
}

/**************************************************************************/

/*
 * Jump Relative
 */
FS_PRIVATE uint8* itrp_JMPR (IPARAM)
{
	int32 offset;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	offset = (int32)CHECK_POP (LocalGS.stackPointer);
	offset--;       /* since the interpreter post-increments the IP */
	pbyInst += offset;
	LocalGS.ulJumpCounter --; /* jump counter used to detect infinite loops */

	if (LocalGS.ulJumpCounter == 0)
	{
		LocalGS.ercReturn = INFINITE_LOOP_ERR;  /* error returned to client */
		return LocalGS.pbyEndInst;
	}
    if (pbyInst < LocalGS.pbyStartInst)
	{
		LocalGS.ercReturn = JUMP_BEFORE_START_ERR;  /* error returned to client */
		return LocalGS.pbyEndInst;
    }
	return pbyInst;
}

/**************************************************************************/

/*
 * Jump Relative On True
 */
FS_PRIVATE uint8* itrp_JROT (IPARAM)
{
	int32 offset;
	boolean bFlag;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	bFlag = (boolean)CHECK_POP (LocalGS.stackPointer);
	offset = (int32)CHECK_POP (LocalGS.stackPointer);

	if (bFlag)
	{
		pbyInst += offset - 1;    /* interpreter post-increments the IP */
		LocalGS.ulJumpCounter --; /* jump counter used to detect infinite loops */
		if (LocalGS.ulJumpCounter == 0)
		{
			LocalGS.ercReturn = INFINITE_LOOP_ERR;  /* error returned to client */
			return LocalGS.pbyEndInst;
		}
        if (pbyInst < LocalGS.pbyStartInst)
		{
			LocalGS.ercReturn = JUMP_BEFORE_START_ERR;  /* error returned to client */
			return LocalGS.pbyEndInst;
		}
	} 
	return pbyInst;
}

/**************************************************************************/

/*
 * Jump Relative On False
 */
FS_PRIVATE uint8* itrp_JROF (IPARAM)
{
	int32 offset;
	boolean bFlag;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	bFlag = (boolean)CHECK_POP (LocalGS.stackPointer);
	offset = (int32)CHECK_POP (LocalGS.stackPointer);

	if (!bFlag)
	{
		pbyInst += offset - 1;    /* interpreter post-increments the IP */
		LocalGS.ulJumpCounter --; /* jump counter used to detect infinite loops */
		if (LocalGS.ulJumpCounter == 0)
		{
			LocalGS.ercReturn = INFINITE_LOOP_ERR;  /* error returned to client */
			return LocalGS.pbyEndInst;
		}
        if (pbyInst < LocalGS.pbyStartInst)
	    {
		    LocalGS.ercReturn = JUMP_BEFORE_START_ERR;  /* error returned to client */
		    return LocalGS.pbyEndInst;
        }
	} 
	return pbyInst;
}

/**************************************************************************/

/*
 * ROUND
 */
  FS_PRIVATE uint8* itrp_ROUND (IPARAM)
  {
	F26Dot6 arg1;
	fnt_ParameterBlock *pb = &LocalGS.globalGS->localParBlock;

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	arg1 = CHECK_POP (LocalGS.stackPointer);

	CHECK_RANGE (lOpCode, 0x68, 0x6B);

	arg1 = pb->RoundValue (GSA arg1, LocalGS.globalGS->engine[lOpCode - 0x68]);
	
	CHECK_PUSH (LocalGS.stackPointer , arg1);
	return pbyInst;
  }

/*
 * No ROUND
 */
  FS_PRIVATE uint8* itrp_NROUND (IPARAM)
  {
	F26Dot6 arg1;

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	arg1 = CHECK_POP (LocalGS.stackPointer);

	CHECK_RANGE (lOpCode, 0x6C, 0x6F);

	arg1 = itrp_RoundOff (GSA arg1, LocalGS.globalGS->engine[lOpCode - 0x6c]);
	CHECK_PUSH (LocalGS.stackPointer , arg1);
	return pbyInst;
  }

/**************************************************************************/

/*
 * An internal function used by MIRP an MDRP.
 */
  F26Dot6 itrp_CheckSingleWidth (GSP F26Dot6 fxValue) { // Single Width cut-in? B.St. to check
	F26Dot6 fxDelta;
	F26Dot6 fxScaledSW;
	fnt_ParameterBlock *pb;

	pb = &LocalGS.globalGS->localParBlock;
	fxScaledSW = LocalGS.GetSingleWidth (GSA0);

	if (fxValue >= 0) 
	{
		fxDelta = fxValue - fxScaledSW;
		if (fxDelta < 0)    
			fxDelta = -fxDelta;
		if (fxDelta < pb->sWCI)    
			fxValue = fxScaledSW;
	} 
	else 
	{
		fxValue = -fxValue;
		fxDelta = fxValue - fxScaledSW;
		if (fxDelta < 0)    
			fxDelta = -fxDelta;
		if (fxDelta < pb->sWCI)    
			fxValue = fxScaledSW;
		fxValue = -fxValue;
	}
	return fxValue;
}

/**************************************************************************/

/*
 * Move Direct Relative Point
 */
FS_PRIVATE uint8* itrp_MDRP (IPARAM)
{
	int32 iPt0;
	int32 iPt1;
	fnt_ElementType *pCE0;
	fnt_ElementType *pCE1;
	fnt_GlobalGraphicStateType *globalGS;
	fnt_ParameterBlock *pb;
	F26Dot6 fxMoveDist;
	F26Dot6 fxUnRounded;
	F26Dot6 fxMin;
	
	iPt0 = LocalGS.Pt0;
	pCE0 = LocalGS.CE0;
	pCE1 = LocalGS.CE1;
	globalGS = LocalGS.globalGS;
	pb = &globalGS->localParBlock;

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	iPt1 = (int32)CHECK_POP (LocalGS.stackPointer);

	SECURE_CHECK_POINT (pCE0, iPt0);
	SECURE_CHECK_POINT (pCE1, iPt1);
	CHECK_POINT (&LocalGS, pCE0, iPt0);
	CHECK_POINT (&LocalGS, pCE1, iPt1);

#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	if (pCE1 != &LocalGS.elements[TWILIGHTZONE] && LocalGS.globalGS->pgmIndex == GLYPHPROGRAM && LocalGS.inSubPixelDirection && CompatibleWidthSP(globalGS))
		if (LocalGS.pt0 != -1 && LocalGS.pt1 != -1 && InterAlign(LocalGS.CE1,LocalGS.pt0,iPt1,LocalGS.pt1))
			AddProportion(&LocalGS,pCE1,LocalGS.pt0,iPt1,LocalGS.pt1);
		else 
			AddDistance(&LocalGS,pCE1,iPt0,iPt1,OTHER); // strokes are hardly MDRPed, more likely to get black MDRPs that should be grey
#endif

	if (pCE0 == &LocalGS.elements[TWILIGHTZONE] || pCE1 == &LocalGS.elements[TWILIGHTZONE] || LocalGS.globalGS->bOriginalPointIsInvalid) {
		fxMoveDist = (*LocalGS.OldProject) (GSA pCE1->ox[iPt1] - pCE0->ox[iPt0], pCE1->oy[iPt1] - pCE0->oy[iPt0]);
	} else if (globalGS->bSameStretch) {
		fxMoveDist = (*LocalGS.OldProject) (GSA pCE1->oox[iPt1] - pCE0->oox[iPt0], pCE1->ooy[iPt1] - pCE0->ooy[iPt0]);
		fxMoveDist = globalGS->ScaleFuncCVT( &globalGS->scaleCVT, fxMoveDist );
	} else {
		fxMoveDist = (*LocalGS.OldProject) (GSA 
			globalGS->ScaleFuncX (&globalGS->scaleX, pCE1->oox[iPt1] - pCE0->oox[iPt0]), 
			globalGS->ScaleFuncY (&globalGS->scaleY, pCE1->ooy[iPt1] - pCE0->ooy[iPt0]) );
	}

	if (pb->sWCI) { // Single Width cut-in? B.St. to check
		fxMoveDist = itrp_CheckSingleWidth (GSA fxMoveDist);
	}

	fxUnRounded = fxMoveDist;

	if (BIT2 (lOpCode)) { // Round?
		fxMoveDist = pb->RoundValue (GSA fxMoveDist, globalGS->engine[lOpCode & 0x03]);
	} else {
		fxMoveDist = itrp_RoundOff (GSA fxMoveDist, globalGS->engine[lOpCode & 0x03]);
	}
	
	if (BIT3 (lOpCode)) { // Minimum distance?
		fxMin = pb->minimumDistance;
#ifdef FSCFG_SUBPIXEL
			if (LocalGS.inSubPixelDirection)
				fxMin /= MIN_DIST_OVERSCALE;
#endif
		if (fxUnRounded >= 0) {
			if (fxMoveDist < fxMin)
				fxMoveDist = fxMin;
		} else {
			fxMin = -fxMin;
			if (fxMoveDist > fxMin)
				fxMoveDist = fxMin;
		}
	}

	fxMoveDist -= (*LocalGS.Project) (GSA pCE1->x[iPt1] - pCE0->x[iPt0], pCE1->y[iPt1] - pCE0->y[iPt0]);
	(*LocalGS.MovePoint) (GSA pCE1, iPt1, fxMoveDist);
	
	LocalGS.Pt1 = iPt0;
	LocalGS.Pt2 = iPt1;
	if (BIT4 (lOpCode))
	{
		LocalGS.Pt0 = iPt1;          /* move the reference point */
	}
	return pbyInst;
} // itrp_MDRP


/**************************************************************************/

/*
 * Move Indirect Relative Point     General
 */

/*    
 *  This routine branches to either the general MIRPG, or to the fast MIRPX 
 *  or MIRPY.  The MIRPCode is set to MIRPX at the beginning of each glyph, 
 *  and may be changed to MIRPY or to MIRPX by the SVTCA instructions.  
 *  Any other change in relevant state will cause the function vector to fall 
 *  back to MIRPG.
 *
 *  Conditions for fast MIRPX and MIRPY:
 *      fast cvt (identity transform)
 *      no single width cut in
 *      no twilight zone
 *      round to grid
 *      no engine compensation
 *      LocalGS.MovePoint = itrp_X[or Y]MovePoint;  
 */

FS_PRIVATE uint8* itrp_MIRP (IPARAM)
{
	int32 iPoint;
	int32 iPt0;
	int32 iCVTIndex;
	F26Dot6 fxMoveDist;
	F26Dot6 fxMin;
	F26Dot6 fxOutlineDist;
	F26Dot6 fxPosition;
	F26Dot6 fxEngine;
#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	long color;
#endif
	
	fnt_ParameterBlock *pb;
	fnt_ElementType *pCE0;
	fnt_ElementType *pCE1;
	fnt_GlobalGraphicStateType *globalGS;

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	globalGS = LocalGS.globalGS;                /* common setup */
	pb = &globalGS->localParBlock;      
	pCE0 = LocalGS.CE0;
	pCE1 = LocalGS.CE1;
	iCVTIndex = (int32)CHECK_POP (LocalGS.stackPointer);
	SECURE_CHECK_CVT (iCVTIndex);
	CHECK_CVT (&LocalGS, iCVTIndex);
	
	iPoint = (int32)CHECK_POP (LocalGS.stackPointer);
	SECURE_CHECK_POINT (LocalGS.CE1, iPoint);
	CHECK_POINT (&LocalGS, LocalGS.CE1, iPoint);
	
	iPt0 = LocalGS.Pt0;
	SECURE_CHECK_POINT (LocalGS.CE0, iPt0);
	CHECK_POINT (&LocalGS, LocalGS.CE0, iPt0);
	LocalGS.Pt1 = iPt0;
	LocalGS.Pt2 = iPoint;
	
#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	if (pCE1 != &LocalGS.elements[TWILIGHTZONE] && LocalGS.globalGS->pgmIndex == GLYPHPROGRAM && LocalGS.inSubPixelDirection && CompatibleWidthSP(globalGS)) {
		color = DoubleCheckLinkColor(pCE1,iPt0,iPoint,lOpCode & 0x03);
		AddDistance(&LocalGS,pCE1,iPt0,iPoint,color);
	}
#endif

	if (LocalGS.MIRPCode == MIRPG)              /********* MIRPG *********/
	{
		fxMoveDist = LocalGS.GetCVTEntry (GSA iCVTIndex);

		if (pb->sWCI) { // Single Width cut-in? B.St. to check
			fxMoveDist = itrp_CheckSingleWidth (GSA fxMoveDist);
		}

		if (pCE1 == &LocalGS.elements[TWILIGHTZONE]) {
			pCE1->ox[iPoint] = pCE0->ox[iPt0] + (F26Dot6) VECTORMUL (fxMoveDist, LocalGS.proj.x);
			pCE1->x[iPoint] = pCE1->ox[iPoint];
			pCE1->oy[iPoint] = pCE0->oy[iPt0] + (F26Dot6) VECTORMUL (fxMoveDist, LocalGS.proj.y);
			pCE1->y[iPoint] = pCE1->oy[iPoint];
		}

		if (LocalGS.OldProject == itrp_XProject) {
			fxOutlineDist = pCE1->ox[iPoint] - pCE0->ox[iPt0];
		} else if (LocalGS.OldProject == itrp_YProject) {
			fxOutlineDist = pCE1->oy[iPoint] - pCE0->oy[iPt0];
		} else {
			fxOutlineDist = (*LocalGS.OldProject) (GSA pCE1->ox[iPoint] - pCE0->ox[iPt0], pCE1->oy[iPoint] - pCE0->oy[iPt0]);
		}

		if (((fxOutlineDist ^ fxMoveDist) < 0) && (pb->autoFlip)) {
			fxMoveDist = -fxMoveDist;           /* Do the auto flip */
		}

		fxEngine = globalGS->engine[lOpCode & 0x03];

#ifdef FSCFG_SUBPIXEL
		if (LocalGS.inSubPixelDirection) {
			// here we may honour a cvt cut-in even though the round-off flag would require not to do so. We assume that the
			// context is a stroke weight that has been tweaked for use with grey-scaling, and the only way to force MIRP
			// to use a particular distance is to round the cvt "by hand" and then turn off the rounding flag, which is
			// quite what we don't want to do in SubPixel, ie. to enforce an unnatural weight.
#ifdef RoundOffRespectsCvtCutIn
			if (!Tuned4SubPixel(globalGS)) {
				// round off respects cvt cut-in, non native sp fonts do early cvt cut-in test, ahead of rounding
				CVTCI(pb,fxMoveDist,fxOutlineDist,CVT_CUT_IN_OVERSCALE);
			}
#endif				
			if (BIT2 (lOpCode)) { // Round?
#ifdef RoundOffRespectsCvtCutIn
				if (Tuned4SubPixel(globalGS)) {
					// round off respects cvt cut-in, but native sp fonts do cvt cut-in test in the usual place
					CVTCI(pb,fxMoveDist,fxOutlineDist,CVT_CUT_IN_OVERSCALE);
				}
#else
				// round off doesn't respect cvt cut-in, hence cvt cut-in test in the usual place
				CVTCI(pb,fxMoveDist,fxOutlineDist,CVT_CUT_IN_OVERSCALE);
#endif // RoundOffRespectsCvtCutIn
				fxMoveDist = pb->RoundValue (GSA fxMoveDist, fxEngine);
			} else { // !Round
				fxMoveDist = itrp_RoundOffSP (GSA fxMoveDist, fxEngine);
			}
		} else { // !inSubPixelDirection
#endif // FSCFG_SUBPIXEL
			if (BIT2 (lOpCode)) { // Round?
				CVTCI(pb,fxMoveDist,fxOutlineDist,1);
				fxMoveDist = pb->RoundValue (GSA fxMoveDist, fxEngine);
			} else {
				fxMoveDist = itrp_RoundOff (GSA fxMoveDist, fxEngine);
			}
#ifdef FSCFG_SUBPIXEL
		}
#endif
		if (BIT3 (lOpCode)) { // Minimum distance?
			fxMin = pb->minimumDistance;
#ifdef FSCFG_SUBPIXEL
			if (LocalGS.inSubPixelDirection)
				fxMin /= MIN_DIST_OVERSCALE;
#endif
			if (fxOutlineDist >= 0) {
				if (fxMoveDist < fxMin)
					fxMoveDist = fxMin;
			} else {
				fxMin = -fxMin;
				if (fxMoveDist > fxMin)
					fxMoveDist = fxMin;
			}
		}
		if (LocalGS.Project == itrp_XProject) {
			fxPosition = pCE1->x[iPoint] - pCE0->x[iPt0];
		} else if (LocalGS.Project == itrp_YProject) {
			fxPosition = pCE1->y[iPoint] - pCE0->y[iPt0];
		} else {
			fxPosition = (*LocalGS.Project) (GSA pCE1->x[iPoint] - pCE0->x[iPt0], pCE1->y[iPoint] - pCE0->y[iPt0]);
		}

		(*LocalGS.MovePoint) (GSA pCE1, iPoint, fxMoveDist - fxPosition);
	
	} else if (LocalGS.MIRPCode == MIRPX) {        /********* MIRPX *********/
	
		fxMoveDist = globalGS->controlValueTable[ iCVTIndex ];  /* always fast */

		fxOutlineDist = pCE1->ox[iPoint] - pCE0->ox[iPt0];  /* x direction only */

		if (((fxOutlineDist ^ fxMoveDist) < 0) && (pb->autoFlip)) {
			fxMoveDist = -fxMoveDist;           /* Do the auto flip */
		}

#ifdef FSCFG_SUBPIXEL
		if (LocalGS.inSubPixelDirection) {
			// same situation as in general MIRP case above
#ifdef RoundOffRespectsCvtCutIn
			if (!Tuned4SubPixel(globalGS)) {
				// round off respects cvt cut-in, non native sp fonts do early cvt cut-in test, ahead of rounding
				CVTCI(pb,fxMoveDist,fxOutlineDist,CVT_CUT_IN_OVERSCALE);
			}
#endif				
			if (BIT2 (lOpCode)) { // Round?
#ifdef RoundOffRespectsCvtCutIn
				if (Tuned4SubPixel(globalGS)) {
					// round off respects cvt cut-in, but native sp fonts do cvt cut-in test in the usual place
					CVTCI(pb,fxMoveDist,fxOutlineDist,CVT_CUT_IN_OVERSCALE);
				}
#else			
				// round off doesn't respect cvt cut-in, hence cvt cut-in test in the usual place
				CVTCI(pb,fxMoveDist,fxOutlineDist,CVT_CUT_IN_OVERSCALE);
#endif				
				RTG(fxMoveDist,0,VIRTUAL_PIXELSIZE_RTG);
			} // else no round off since no engine compensation
		} else { // !inSubPixelDirection
#endif // FSCFG_SUBPIXEL

			if (BIT2 (lOpCode)) { // Round?
				CVTCI(pb,fxMoveDist,fxOutlineDist,1);
				RTG(fxMoveDist,0,FNT_PIXELSIZE);
			} // else no round off since no engine compensation

#ifdef FSCFG_SUBPIXEL
		}
#endif

		if (BIT3 (lOpCode)) { // Minimum distance?
			fxMin = pb->minimumDistance;
#ifdef FSCFG_SUBPIXEL
			if (LocalGS.inSubPixelDirection)
				fxMin /= MIN_DIST_OVERSCALE;
#endif
			if (fxOutlineDist >= 0) {
				if (fxMoveDist < fxMin)
					fxMoveDist = fxMin;
			} else {
				fxMin = -fxMin;
				if (fxMoveDist > fxMin)
					fxMoveDist = fxMin;
			}
		}

		pCE1->x[iPoint] = fxMoveDist + pCE0->x[iPt0];  /* move point fast */
		pCE1->f[iPoint] |= XMOVED;
	
	} else { /* if (LocalGS.MIRPCode == MIRPY) */  /********* MIRPY *********/
	
		fxMoveDist = globalGS->controlValueTable[ iCVTIndex ];  /* always fast */

		fxOutlineDist = pCE1->oy[iPoint] - pCE0->oy[iPt0];  /* y direction only */

		if (((fxOutlineDist ^ fxMoveDist) < 0) && (pb->autoFlip)) {
			fxMoveDist = -fxMoveDist;           /* Do the auto flip */
		}

#ifdef FSCFG_SUBPIXEL
		if (LocalGS.inSubPixelDirection) {
			// same situation as in general MIRP case above
#ifdef RoundOffRespectsCvtCutIn
			if (!Tuned4SubPixel(globalGS)) {
				// round off respects cvt cut-in, non native sp fonts do early cvt cut-in test, ahead of rounding
				CVTCI(pb,fxMoveDist,fxOutlineDist,CVT_CUT_IN_OVERSCALE);
			}
#endif				
			if (BIT2 (lOpCode)) { // Round?
#ifdef RoundOffRespectsCvtCutIn
				if (Tuned4SubPixel(globalGS)) {
					// round off respects cvt cut-in, but native sp fonts do cvt cut-in test in the usual place
					CVTCI(pb,fxMoveDist,fxOutlineDist,CVT_CUT_IN_OVERSCALE);
				}
#else			
				// round off doesn't respect cvt cut-in, hence cvt cut-in test in the usual place
				CVTCI(pb,fxMoveDist,fxOutlineDist,CVT_CUT_IN_OVERSCALE);
#endif				
				RTG(fxMoveDist,0,VIRTUAL_PIXELSIZE_RTG);
			} // else no round off since no engine compensation
		} else { // !inSubPixelDirection
#endif // FSCFG_SUBPIXEL

			if (BIT2 (lOpCode)) { // Round?
				CVTCI(pb,fxMoveDist,fxOutlineDist,1);
				RTG(fxMoveDist,0,FNT_PIXELSIZE);
			} // else no round off since no engine compensation

#ifdef FSCFG_SUBPIXEL
		}
#endif

		if (BIT3 (lOpCode)) { // Minimum distance?
			fxMin = pb->minimumDistance;
#ifdef FSCFG_SUBPIXEL
			if (LocalGS.inSubPixelDirection)
				fxMin /= MIN_DIST_OVERSCALE;
#endif
			if (fxOutlineDist >= 0) {
				if (fxMoveDist < fxMin)
					fxMoveDist = fxMin;
			} else {
				fxMin = -fxMin;
				if (fxMoveDist > fxMin)
					fxMoveDist = fxMin;
			}
		}

		pCE1->y[iPoint] = fxMoveDist + pCE0->y[iPt0];  /* move point fast */
		pCE1->f[iPoint] |= YMOVED;
	}
	
	if (BIT4 (lOpCode)) {
		LocalGS.Pt0 = iPoint;                   /* move the reference point */
	}
	return pbyInst;
} // itrp_MIRP

/**************************************************************************/

/*
 * CALL a function
 */
FS_PRIVATE uint8* itrp_CALL (IPARAM)
{
	fnt_funcDef *funcDef;
	uint8 *pbySubroutine;
	fnt_GlobalGraphicStateType *globalGS;
	int32 arg;
	uint8 *pbyEndInst;                      /* saves parent's stop condition */
	uint8 *pbyStartInst;                    /* saves parent's stop condition */
#ifdef FSCFG_SUBPIXEL
#ifdef BypassDandIStroke
	uint8 patchedStore22 = false;
	F26Dot6 store22;
#endif
#ifdef BypassJellesSpacing
	uint8 patchedStore24 = false;
	F26Dot6 store24;
#endif
#ifdef AssistTomsDiagonal
	uint8 assistTomsDiagonal = false;
	F26Dot6 cvtCI = 0;
#endif
#ifdef InlineDeltasOnly
	uint16 i;
	uint8 inSkippableDeltaFn = false;
#endif
#endif

	FS_UNUSED_PARAMETER(lOpCode);

	globalGS = LocalGS.globalGS;
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	arg = (int32)CHECK_POP (LocalGS.stackPointer);

	CHECK_PROGRAM (funcDef->pgmIndex);
    SECURE_CHECK_FDEF(arg);
	CHECK_FDEF (&LocalGS, arg);
	funcDef = &globalGS->funcDef[ arg ];

 	SECURE_CHECK_PROGRAM (funcDef->pgmIndex);

	pbySubroutine = globalGS->pgmList[ funcDef->pgmIndex ].Instruction;

	CHECK_ASSERTION (globalGS->funcDef != 0);
	CHECK_ASSERTION (pbySubroutine != 0);

	pbySubroutine += funcDef->start;
	pbyEndInst = LocalGS.pbyEndInst;        /* save for parent */
	pbyStartInst = LocalGS.pbyStartInst;        /* save for parent */

#ifdef FSCFG_SUBPIXEL
#ifdef BypassDandIStroke
	// here we're assuming that fns 64 through 66 are support functions for the TMT D/IStroke commands, which may make strokes collapse in SubPixel.
	// To determine whether we've actually run into the context of these fns, we look at the first couple of bytes only, as the exact implementation
	// of these functions may have changed over time, but hopefully, the preamble (to look at storage #22) hasn't. The easiest way to by-pass these
	// fns is to flag storage #22 with 0, indicating not to use D/IStrokes, else we'd have to cleanup the stack.
	// Admittedly a bit of a hack. If anybody can think of a "better bandaid", I'll be happy to consider it.
	//    The reason, by the way, why DStroke doesn't work, is the following. DStroke brings pairs of points to the same y (or x), MIRP[m<rBl] the
	// floating point, and the moves it back to the old y (or x). Now that we re-interpret little r, cvt cut in actually gets to cut in, the original
	// distance gets to apply, just that the original distance is taken prior to bringing points to same y (or x), meaning it's likely to be WAY off.
	// As a result, the diagonal stroke weight (in x) starts to depend heavily on the distance (in y) of the control points involved, which obviously
	// is not what we want. Notice that for non-square aspect ratios, the DStroke is a NOP, therefore was a NOP with 16x SubPixel, and hence we're
	// not doing any major harm by skipping it in SubPixel.
	if (64 <= arg && arg <= 66 && RunningSubPixel(LocalGS.globalGS) && !Tuned4SubPixel(LocalGS.globalGS) && (LocalGS.globalGS->subPixelCompatibilityFlags & SPCF_detectedDandIStroke) > 0) {
		store22 = LocalGS.globalGS->store[22];
		LocalGS.globalGS->store[22] = 0;
		patchedStore22 = true;
	}
#endif
#ifdef BypassJellesSpacing
	// here we're assuming that fns 0, 1, 2, 4, 7, and 8 are support functions for Monotype's Jelle Bosma's spacing functions, which may squish
	// characters or pull them left or right or in both directions at the same time. This has to do amongst other with using the twilight zone.
	// The spacing algorithm is meant to be turned off above a certain size, such as 30 ppem, hence we may argue that with the extra virtual re-
	// solution we should turn it off at a considerably smaller ppem size, or altogether. From there the logic is like bypassing D/IStroke.
	// (1 << arg) & (1 + 2 + 4 + 16 + 128 + 256) != 0
	if ((0 <= arg && arg <= 2 || arg == 4 || 7 <= arg && arg <= 8) && RunningSubPixel(LocalGS.globalGS) && !Tuned4SubPixel(LocalGS.globalGS) && (LocalGS.globalGS->subPixelCompatibilityFlags & SPCF_detectedJellesSpacing) > 0) {
		store24 = LocalGS.globalGS->store[24];
		LocalGS.globalGS->store[24] = 0;
		patchedStore24 = true;
	}
#endif
#ifdef AssistTomsDiagonal
	if (arg == 58 && RunningSubPixel(LocalGS.globalGS) && !Tuned4SubPixel(LocalGS.globalGS) && (LocalGS.globalGS->subPixelCompatibilityFlags & SPCF_detectedTomsDiagonal) > 0) {
		cvtCI = LocalGS.globalGS->localParBlock.wTCI;
		LocalGS.globalGS->localParBlock.wTCI = 0x7fffffff;
		assistTomsDiagonal = true;
	}
#endif
#ifdef InlineDeltasOnly
	for (i = 0; i < LocalGS.globalGS->numDeltaFunctionsDetected && LocalGS.globalGS->deltaFunction[i] != (uint16)arg; i++);
	if (i < LocalGS.globalGS->numDeltaFunctionsDetected && RunningSubPixel(LocalGS.globalGS) && !Tuned4SubPixel(LocalGS.globalGS)) {
		LocalGS.globalGS->subPixelCompatibilityFlags |= SPCF_inSkippableDeltaFn;
		inSkippableDeltaFn = true;
	}
#endif
#endif


	LocalGS.ulRecursiveCall --; /* jump counter used to detect deep recursions */
	if (LocalGS.ulRecursiveCall == 0)
	{
		LocalGS.ercReturn = INFINITE_RECURSION_ERR;  /* error returned to client */
		return LocalGS.pbyEndInst;
	}
	LocalGS.Interpreter (GSA pbySubroutine, pbySubroutine + funcDef->length);   /* recursion */
	LocalGS.ulRecursiveCall ++; /* jump counter used to detect deep recursions */
	

#ifdef FSCFG_SUBPIXEL
#ifdef InlineDeltasOnly
	if (inSkippableDeltaFn) {
		LocalGS.globalGS->subPixelCompatibilityFlags &= ~SPCF_inSkippableDeltaFn;
	}
#endif
#ifdef AssistTomsDiagonal
	if (assistTomsDiagonal) {
		LocalGS.globalGS->localParBlock.wTCI = cvtCI;
	}
#endif
#ifdef BypassJellesSpacing
	if (patchedStore24) {
		LocalGS.globalGS->store[24] = store24;
	}
#endif
#ifdef BypassDandIStroke
	if (patchedStore22) {
		LocalGS.globalGS->store[22] = store22;
	}
#endif
#endif

	LocalGS.pbyEndInst = pbyEndInst;        /* restore for parent */
	LocalGS.pbyStartInst = pbyStartInst;    /* restore for parent */
	if (LocalGS.ercReturn != NO_ERR)        /* if illegal inst has been hit */
	{
		return pbyEndInst;                  /* exit parent's loop */
	}
			
	return pbyInst;
}

/**************************************************************************/

/*
 * Function DEFinition
 */
FS_PRIVATE uint8* itrp_FDEF (IPARAM)
{
	fnt_funcDef *funcDef;
	uint8 * program, *funcStart;
	static const uint8 funcFragment[8][16] ={
								{0x01,0x20,0xB0,0x03,0x25},				// SVTCA[X] DUP[] #PUSH 3 CINDEX[] (DiagEndCtrl)
								{0xB0,0x16,0x43,0x58},					// #PUSH 22 RS[] IF[] (D/IStroke)
								{0x01,0xB0,0x18,0x43,0x58},				// SVTCA[X] #PUSH 24 RS[] IF[] (Jelle's Spacing, version #1)
								{0x01,0x18,0xB0,0x18,0x43,0x58},		// SVTCA[X] RTG[] #PUSH 24 RS[] IF[] (Jelle's Spacing, version #2)
								{0x45,0x23,0x46,0x60,0x20,0xB0,0x26},	// RCVT[] SWAP[] GC[N] ADD[] DUP[] #PUSH 38 (VacuFormRound)
								{0x20,0x20,0xB0,0x01,0x60,0x46,0xB0,0x40,0x23,0x42}, // DUP[] DUP[] #PUSH[] 1 ADD[] GC[N] #PUSH[] 64 SWAP[] WS[] (Tom's Diagonal)
								{0x4B,0x53,0x23,0x4B,0x51,0x5A,0x58,0x38,0x1B,0x21,0x21,0x59,0x2D}, // MPPEM[] GTEQ[] SWAP[] MPPEM[] LTEQ[] AND[] IF[] SHPIX[] ELSE[] POP[] POP[] EIF[] ENDF[] (Range of deltas)
								{0x4B,0x54,0x58,0x38,0x1B,0x21,0x21,0x59,0x2D}}; // MPPEM[] EQ[] IF[] SHPIX[] ELSE[] POP[] POP[] EIF[] ENDF[] (Delta)

	// extend here for two variants of delta fn

	fnt_GlobalGraphicStateType * globalGS;
	int32 arg;

	FS_UNUSED_PARAMETER(lOpCode);

	globalGS = LocalGS.globalGS;

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	arg = (int32)CHECK_POP (LocalGS.stackPointer);
    SECURE_CHECK_FDEF(arg);
	CHECK_FDEF (&LocalGS, arg);

	if (LocalGS.globalGS->pgmIndex >= MAXPREPROGRAMS)
	{
		LocalGS.ercReturn = FDEF_IN_GLYPHPGM_ERR;  /* returned to client, error FDEF in glyph program */
		return LocalGS.pbyEndInst;
	}

	funcDef = &globalGS->funcDef[ arg ];
	program = globalGS->pgmList[ funcDef->pgmIndex = LocalGS.globalGS->pgmIndex ].Instruction;

	CHECK_PROGRAM (funcDef->pgmIndex);
	CHECK_ASSERTION (globalGS->funcDef != 0);
	CHECK_ASSERTION (globalGS->pgmList[funcDef->pgmIndex].Instruction != 0);

	funcDef->start = (int32)(pbyInst - program);

	funcStart = pbyInst;

#ifdef FSCFG_SUBPIXEL
#ifdef BypassDandIStroke
	if (64 <= arg && arg <= 66 && memcmp(funcStart,funcFragment[1],4) == 0)
		LocalGS.globalGS->subPixelCompatibilityFlags |= SPCF_detectedDandIStroke;
#endif
#ifdef BypassJellesSpacing // (1 << arg) & (1 + 2 + 4 + 16 + 128 + 256) != 0
	if ((0 <= arg && arg <= 2 || arg == 4 || 7 <= arg && arg <= 8) && (memcmp(funcStart,funcFragment[2],5) == 0 || memcmp(funcStart,funcFragment[3],6) == 0))
		LocalGS.globalGS->subPixelCompatibilityFlags |= SPCF_detectedJellesSpacing;
#endif
#ifdef BypassVacuformRound
	if (arg == 0 && memcmp(funcStart,funcFragment[4],7) == 0)
		LocalGS.globalGS->subPixelCompatibilityFlags |= SPCF_detectedVacuformRound;
#endif
#ifdef AssistTomsDiagonal
	if (arg == 58 && memcmp(funcStart,funcFragment[5],10) == 0) 
		LocalGS.globalGS->subPixelCompatibilityFlags |= SPCF_detectedTomsDiagonal;
#endif
#ifdef InlineDeltasOnly
	if (*funcStart == funcFragment[6][0] && (memcmp(funcStart,funcFragment[7],9) == 0 || memcmp(funcStart,funcFragment[6],13) == 0) && LocalGS.globalGS->numDeltaFunctionsDetected < maxDeltaFunctions)
		LocalGS.globalGS->deltaFunction[LocalGS.globalGS->numDeltaFunctionsDetected++] = (uint16)arg;
	// if we have too many delta fns, we'll end up executing a delta fn; this may not look optimal, but we don't expect to get to this point in the first place.
#endif
#endif
	while ( ((*pbyInst++) != ENDF_CODE)  && (pbyInst < LocalGS.pbyEndInst) )
	{
		pbyInst = itrp_SkipPushData (GSA pbyInst);
	}

	if ((pbyInst == LocalGS.pbyEndInst) &&  (*(pbyInst-1) != ENDF_CODE ))
	{
		LocalGS.ercReturn = MISSING_ENDF_ERR;  /* returned to client, missing ENDF */

	}

	funcDef->length = (uint16)(pbyInst - funcStart - 1); /* don't execute ENDF */
	return pbyInst;
}

/**************************************************************************/

/*
 * LOOP while CALLing a function
 */
FS_PRIVATE uint8* itrp_LOOPCALL (IPARAM)
{
	uint8 *start, *stop;
	InterpreterFunc Interpreter;
	fnt_funcDef *funcDef;
	int32 arg;
	int32 loop;
	uint8 * ins;
	uint8 *pbyEndInst;                      /* saves parent's stop condition */
	uint8 *pbyStartInst;                    /* saves parent's stop condition */
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	arg = (int32)CHECK_POP (LocalGS.stackPointer);
    SECURE_CHECK_FDEF(arg);
	CHECK_FDEF (&LocalGS, arg);

	funcDef = & (LocalGS.globalGS->funcDef[ arg ]);
	{
		SECURE_CHECK_PROGRAM (funcDef->pgmIndex);
		CHECK_PROGRAM (funcDef->pgmIndex);
		ins = LocalGS.globalGS->pgmList[ funcDef->pgmIndex ].Instruction;

		start = &ins[funcDef->start];
		stop = &ins[funcDef->start + funcDef->length];  /* funcDef->end -> funcDef->length <4> */
	}
	Interpreter = LocalGS.Interpreter;
	arg = (int32)CHECK_POP (LocalGS.stackPointer);
	CHECK_INT16 (arg);
	CHECK_LARGER (-1L, arg);
	loop = (int32)arg;
	
	pbyEndInst = LocalGS.pbyEndInst;        /* save for parent */
	pbyStartInst = LocalGS.pbyStartInst;    /* save for parent */
	LocalGS.ulRecursiveCall --; /* jump counter used to detect deep recursions */
	if (LocalGS.ulRecursiveCall == 0)
	{
		LocalGS.ercReturn = INFINITE_RECURSION_ERR;  /* error returned to client */
		return LocalGS.pbyEndInst;
	}

	for (--loop; ((loop >= 0) && (LocalGS.ercReturn == NO_ERR)); --loop)
	{
		Interpreter (GSA start, stop);
	}
	LocalGS.ulRecursiveCall ++; /* jump counter used to detect deep recursions */
	LocalGS.pbyEndInst = pbyEndInst;        /* restore for parent */
	LocalGS.pbyStartInst = pbyStartInst;    /* restore for parent */
	
	if (LocalGS.ercReturn != NO_ERR)        /* if illegal inst has been hit */
	{
		return pbyEndInst;                  /* exit parent's loop */
	}
	return pbyInst;
}

/**************************************************************************/

/*
 *      This guy returns the index of the given opCode, or 0 if not found <4>
 */
FS_PRIVATE fnt_instrDef *itrp_FindIDef (GSP uint8 opCode)
{
	fnt_GlobalGraphicStateType *globalGS;
	int32 count;
	fnt_instrDef*instrDef;
	
	globalGS = LocalGS.globalGS;
	count = globalGS->instrDefCount;
	instrDef = globalGS->instrDef;
		
	for (--count; count >= 0; instrDef++, --count)
	{
		if (instrDef->opCode == opCode)
		{
			return instrDef;
		}
	}
	return 0;
}

/**************************************************************************/

/*
 *      This guy gets called for opCodes that has been patch by the font's IDEF <4>
 *      or if they have never been defined.  If there is no corresponding IDEF,
 *      flag it as an illegal instruction.
 */
FS_PRIVATE uint8* itrp_IDefPatch (IPARAM)
{
	fnt_instrDef *instrDef;
	uint8 *program;
	uint8 *pbyEndInst;                      /* saves parent's stop condition */
	uint8 *pbyStartInst;                    /* saves parent's stop condition */
	
	pbyEndInst = LocalGS.pbyEndInst;        /* save for parent */
	pbyStartInst = LocalGS.pbyStartInst;    /* save for parent */
	
	instrDef = itrp_FindIDef (GSA (uint8)lOpCode);
	if (instrDef == 0)
	{
		return itrp_IllegalInstruction (GSA pbyInst, lOpCode);
	}
	else
	{
		SECURE_CHECK_PROGRAM (instrDef->pgmIndex);
		CHECK_PROGRAM (instrDef->pgmIndex);
		program = LocalGS.globalGS->pgmList[ instrDef->pgmIndex ].Instruction;
		program += instrDef->start;
		
		LocalGS.ulRecursiveCall --; /* jump counter used to detect deep recursions */
		if (LocalGS.ulRecursiveCall == 0)
		{
			LocalGS.ercReturn = INFINITE_RECURSION_ERR;  /* error returned to client */
			return LocalGS.pbyEndInst;
		}

		LocalGS.Interpreter (GSA program, program + instrDef->length);
	
		LocalGS.ulRecursiveCall ++; /* jump counter used to detect deep recursions */

		LocalGS.pbyEndInst = pbyEndInst;    /* restore for parent */
		LocalGS.pbyStartInst = pbyStartInst;/* restore for parent */
		
		if (LocalGS.ercReturn != NO_ERR)    /* if illegal inst has been hit */
		{
			return pbyEndInst;              /* exit parent's loop */
		}
	}
	return pbyInst;
}

/**************************************************************************/

/*
 * Instruction DEFinition       <4>
 */
FS_PRIVATE uint8* itrp_IDEF (IPARAM)
{
	int32 arg;
	uint8 opCode;
	fnt_instrDef *instrDef;
	int32 pgmIndex;
	uint8 * program;
	uint8 * instrStart;

	FS_UNUSED_PARAMETER(lOpCode);

	pgmIndex = (int32)LocalGS.globalGS->pgmIndex;

	if (pgmIndex >= MAXPREPROGRAMS)
	{
		LocalGS.ercReturn = IDEF_IN_GLYPHPGM_ERR;  /* returned to client, error IDEF in glyph program */
		return LocalGS.pbyEndInst;
	}

	program = LocalGS.globalGS->pgmList[ pgmIndex ].Instruction;
	instrStart = pbyInst;
	
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	arg = CHECK_POP (LocalGS.stackPointer);
    SECURE_CHECK_IDEF_OPCODE(arg);
    CHECK_INT8 (arg);
	opCode = (uint8)arg;
	CHECK_PROGRAM (pgmIndex);

	instrDef = itrp_FindIDef (GSA opCode);
	if (!instrDef)
	{
        SECURE_CHECK_IDEF_OVERFLOW();
		instrDef = LocalGS.globalGS->instrDef + LocalGS.globalGS->instrDefCount++;
	}

	instrDef->pgmIndex = (uint8) pgmIndex;
	instrDef->opCode = opCode;          /* this may or may not have been set */
	instrDef->start = (int32)(pbyInst - program);

	while (((*pbyInst++) != ENDF_CODE) && (pbyInst < LocalGS.pbyEndInst))
	{
		pbyInst = itrp_SkipPushData (GSA pbyInst);
	}

	if ((pbyInst == LocalGS.pbyEndInst) &&  (*(pbyInst-1) != ENDF_CODE ))
	{
		LocalGS.ercReturn = MISSING_ENDF_ERR;  /* returned to client, missing ENDF */

	}

	instrDef->length = (uint16)(pbyInst - instrStart - 1); /* don't execute ENDF */
	return pbyInst;
}

/**************************************************************************/

/*
 * UnTouch Point
 */
  FS_PRIVATE uint8* itrp_UTP (IPARAM)
  {
	uint8*f = LocalGS.CE0->f;
	int32 point;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	point = (int32)CHECK_POP (LocalGS.stackPointer);
	SECURE_CHECK_POINT (LocalGS.CE0, point);
	CHECK_POINT (&LocalGS, LocalGS.CE0, point);
	if (LocalGS.free.x)
	{
	  f[point] &= ~XMOVED;
	}
	if (LocalGS.free.y)
	{
	  f[point] &= ~YMOVED;
	}
	return pbyInst;
  }

/*
 * Set Delta Base
 */
  FS_PRIVATE uint8* itrp_SDB (IPARAM)
  {
	int32 arg;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	arg = CHECK_POP (LocalGS.stackPointer);
	CHECK_INT16 (arg);
	LocalGS.globalGS->localParBlock.deltaBase = (int16)arg;
	return pbyInst;
  }

/*
 * Set Delta Shift
 */
  FS_PRIVATE uint8* itrp_SDS (IPARAM)
  {
	int32 arg;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	arg = CHECK_POP (LocalGS.stackPointer);
	CHECK_INT16 (arg);
	LocalGS.globalGS->localParBlock.deltaShift = (int16)arg;
	return pbyInst;
  }

/**************************************************************************/

/*
 * DeltaEngine, internal support routine
 */
FS_PRIVATE uint8*  itrp_DeltaEngine (GSP uint8 *pbyInst, FntMoveFunc doIt, int16 sBase, int16 sShift)
{
	int32 iRange;
	int32 iAim;
	int32 iHigh;
	int32 iFakePPEM;
	int32 iPPEM;
	F26Dot6 fxDelta;

		/* Find the beginning of data pairs for this particular size */
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	iHigh = CHECK_POP (LocalGS.stackPointer) << 1;
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, iHigh);
	LocalGS.stackPointer -= iHigh;              /* -= number of pops required */
	CHECK_STACK (&LocalGS);

	iRange = LocalGS.globalGS->pixelsPerEm;     /* same as itrp_MPPEM () */
	if (!LocalGS.globalGS->bSameStretch)
		iRange = (int32)FixMul(iRange, itrp_GetCVTScale (GSA0));
	iFakePPEM = iRange - (int32)sBase;

	if ((iFakePPEM >= 16) || (iFakePPEM < 0))
	{
		return pbyInst;                                 /* Not within exception range */
	}
	iFakePPEM = iFakePPEM << 4;

	iAim = 0;
	iRange = iHigh >> 1; 
	iRange &= ~1;
	while (iRange > 2)                          /* binary search for first data */
	{
		iPPEM = LocalGS.stackPointer[ iAim + iRange ]; /* [ iPPEM << 4 | exception ] */
		if ((iPPEM & ~0x0f) < iFakePPEM) 
		{
			iAim += iRange;                     /* approach the starting point */
		}
		iRange >>= 1; 
		iRange &= ~1;                           /* iRange must stay even */
	}

	while (iAim < iHigh) 
	{
		iPPEM = LocalGS.stackPointer[ iAim ];   /* [ iPPEM << 4 | exception ] */
		fxDelta = iPPEM & ~0x0f;
		if (fxDelta == iFakePPEM)
		{                                       /* We found an exception, go ahead and apply it */
			fxDelta = iPPEM & 0xf;              /* 0 ... 15 */
			fxDelta -= fxDelta >= 8 ? 7 : 8;    /* -8 ... -1, 1 ... 8 */
			fxDelta <<= FNT_PIXELSHIFT;        /* convert to pixels */
			fxDelta >>= sShift;                 /* scale to right size */
            
#ifdef FSCFG_SECURE
            if (doIt == LocalGS.MovePoint)
            {
                SECURE_CHECK_POINT(LocalGS.CE0,(int32)LocalGS.stackPointer[iAim+1]);
            } else
			{
				FS_ASSERT( (doIt == LocalGS.ChangeCvt), "itrp_DeltaEngine called with wrong doIt.")
                SECURE_CHECK_CVT((int32)LocalGS.stackPointer[iAim+1]);
			}
#endif
#ifdef FSCFG_SUBPIXEL
#ifdef InlineDeltasOnly
		// similar to itrp_SHP_Common above
		// main difference: we don't distinguish between SHPIX and SHP, but between CVT deltas and ordinary deltas
			if (doIt == LocalGS.ChangeCvt || !RunningSubPixel(LocalGS.globalGS) || Tuned4SubPixel(LocalGS.globalGS) || AMovedPointInNonSPDirection(LocalGS,CE0,(int16)LocalGS.stackPointer[iAim+1]))
#endif
#endif
				doIt (GSA LocalGS.CE0, (int32)LocalGS.stackPointer[iAim+1], (F26Dot6) fxDelta);
		} 
		else if (fxDelta > iFakePPEM)
		{
			break;                              /* we passed the data */
		}
		iAim += 2;
	}
    return pbyInst;
}

/**************************************************************************/

/*
 * DELTAP1
 */
  FS_PRIVATE uint8* itrp_DELTAP1 (IPARAM)
  {
	fnt_ParameterBlock *pb;

	FS_UNUSED_PARAMETER(lOpCode);

	pb = &LocalGS.globalGS->localParBlock;
	return itrp_DeltaEngine (GSA pbyInst, LocalGS.MovePoint, pb->deltaBase, pb->deltaShift);
  }

/*
 * DELTAP2
 */
  FS_PRIVATE uint8* itrp_DELTAP2 (IPARAM)
  {
	fnt_ParameterBlock *pb;
	int16 sBase;

	FS_UNUSED_PARAMETER(lOpCode);

	pb = &LocalGS.globalGS->localParBlock;
	sBase = (int16)(pb->deltaBase + 16);
	return itrp_DeltaEngine (GSA pbyInst, LocalGS.MovePoint, sBase, pb->deltaShift);
  }

/*
 * DELTAP3
 */
  FS_PRIVATE uint8* itrp_DELTAP3 (IPARAM)
  {
	fnt_ParameterBlock *pb;
	int16 sBase;

	FS_UNUSED_PARAMETER(lOpCode);

	pb = &LocalGS.globalGS->localParBlock;
	sBase = (int16)(pb->deltaBase + 32);
	return itrp_DeltaEngine (GSA pbyInst, LocalGS.MovePoint, sBase, pb->deltaShift);
  }

/*
 * DELTAC1
 */
  FS_PRIVATE uint8* itrp_DELTAC1 (IPARAM)
  {
	fnt_ParameterBlock *pb;

	FS_UNUSED_PARAMETER(lOpCode);

	pb = &LocalGS.globalGS->localParBlock;
	return itrp_DeltaEngine (GSA pbyInst, LocalGS.ChangeCvt, pb->deltaBase, pb->deltaShift);
  }

/*
 * DELTAC2
 */
  FS_PRIVATE uint8* itrp_DELTAC2 (IPARAM)
  {
	fnt_ParameterBlock *pb;
	int16 sBase;

	FS_UNUSED_PARAMETER(lOpCode);

	pb = &LocalGS.globalGS->localParBlock;
	sBase = (int16)(pb->deltaBase + 16);
	return itrp_DeltaEngine (GSA pbyInst, LocalGS.ChangeCvt, sBase, pb->deltaShift);
  }

/*
 * DELTAC3
 */
  FS_PRIVATE uint8* itrp_DELTAC3 (IPARAM)
  {
	fnt_ParameterBlock *pb;
	int16 sBase;

	FS_UNUSED_PARAMETER(lOpCode);

	pb = &LocalGS.globalGS->localParBlock;
	sBase = (int16)(pb->deltaBase + 32);
	return itrp_DeltaEngine (GSA pbyInst, LocalGS.ChangeCvt, sBase, pb->deltaShift);
  }


#ifdef FSCFG_NO_INITIALIZED_DATA
	
	void itrp_InitializeData (void)
	{
		int32 i;

		/***** 0x00 - 0x0f *****/
		function[0x00] = itrp_SVTCA_0;
		function[0x01] = itrp_SVTCA_1;
		function[0x02] = itrp_SPVTCA_0;
		function[0x03] = itrp_SPVTCA_1;
		function[0x04] = itrp_SFVTCA_0;
		function[0x05] = itrp_SFVTCA_1;
		function[0x06] = itrp_SPVTL;
		function[0x07] = itrp_SPVTL;
		function[0x08] = itrp_SFVTL;
		function[0x09] = itrp_SFVTL;
		function[0x0A] = itrp_WPV;
		function[0x0B] = itrp_WFV;
		function[0x0C] = itrp_RPV;
		function[0x0D] = itrp_RFV;
		function[0x0E] = itrp_SFVTPV;
		function[0x0F] = itrp_ISECT;

		/***** 0x10 - 0x1f *****/
		function[0x10] = itrp_SRP0;
		function[0x11] = itrp_SRP1;
		function[0x12] = itrp_SRP2;
		function[0x13] = itrp_SetElementPtr;
		function[0x14] = itrp_SetElementPtr;
		function[0x15] = itrp_SetElementPtr;
		function[0x16] = itrp_SetElementPtr;
		function[0x17] = itrp_LLOOP;
		function[0x18] = itrp_RTG;
		function[0x19] = itrp_RTHG;
		function[0x1A] = itrp_LMD;
		function[0x1B] = itrp_ELSE;
		function[0x1C] = itrp_JMPR;
		function[0x1D] = itrp_LWTCI;
		function[0x1E] = itrp_LSWCI;
		function[0x1F] = itrp_LSW;

		/***** 0x20 - 0x2f *****/
		function[0x20] = itrp_DUP;
		function[0x21] = itrp_POP;
		function[0x22] = itrp_CLEAR;
		function[0x23] = itrp_SWAP;
		function[0x24] = itrp_DEPTH;
		function[0x25] = itrp_CINDEX;
		function[0x26] = itrp_MINDEX;
		function[0x27] = itrp_ALIGNPTS;
		function[0x28] = itrp_RAW;
		function[0x29] = itrp_UTP;
		function[0x2A] = itrp_LOOPCALL;
		function[0x2B] = itrp_CALL;
		function[0x2C] = itrp_FDEF;
		function[0x2D] = itrp_IllegalInstruction;
		function[0x2E] = itrp_MDAP;
		function[0x2F] = itrp_MDAP;

		/***** 0x30 - 0x3f *****/
		function[0x30] = itrp_IUP;
		function[0x31] = itrp_IUP;
		function[0x32] = itrp_SHP;
		function[0x33] = itrp_SHP;
		function[0x34] = itrp_SHC;
		function[0x35] = itrp_SHC;
		function[0x36] = itrp_SHE;
		function[0x37] = itrp_SHE;
		function[0x38] = itrp_SHPIX;
		function[0x39] = itrp_IP;
		function[0x3A] = itrp_MSIRP;
		function[0x3B] = itrp_MSIRP;
		function[0x3C] = itrp_ALIGNRP;
		function[0x3D] = itrp_RTDG;
		function[0x3E] = itrp_MIAP;
		function[0x3F] = itrp_MIAP;

		/***** 0x40 - 0x4f *****/
		function[0x40] = itrp_NPUSHB;
		function[0x41] = itrp_NPUSHW;
		function[0x42] = itrp_WS;
		function[0x43] = itrp_RS;
		function[0x44] = itrp_WCVT;
		function[0x45] = itrp_RCVT;
		function[0x46] = itrp_RC;
		function[0x47] = itrp_RC;
		function[0x48] = itrp_WC;
		function[0x49] = itrp_MD;
		function[0x4A] = itrp_MD;
		function[0x4B] = itrp_MPPEM;
		function[0x4C] = itrp_MPS;
		function[0x4D] = itrp_FLIPON;
		function[0x4E] = itrp_FLIPOFF;
		function[0x4F] = itrp_DEBUG;

		/***** 0x50 - 0x5f *****/
		function[0x50] = itrp_LT;
		function[0x51] = itrp_LTEQ;
		function[0x52] = itrp_GT;
		function[0x53] = itrp_GTEQ;
		function[0x54] = itrp_EQ;
		function[0x55] = itrp_NEQ;
		function[0x56] = itrp_ODD;
		function[0x57] = itrp_EVEN;
		function[0x58] = itrp_IF;
		function[0x59] = itrp_EIF;
		function[0x5A] = itrp_AND;
		function[0x5B] = itrp_OR;
		function[0x5C] = itrp_NOT;
		function[0x5D] = itrp_DELTAP1;
		function[0x5E] = itrp_SDB;
		function[0x5F] = itrp_SDS;

		/***** 0x60 - 0x6f *****/
		function[0x60] = itrp_ADD;
		function[0x61] = itrp_SUB;
		function[0x62] = itrp_DIV;
		function[0x63] = itrp_MUL;
		function[0x64] = itrp_ABS;
		function[0x65] = itrp_NEG;
		function[0x66] = itrp_FLOOR;
		function[0x67] = itrp_CEILING;
		function[0x68] = itrp_ROUND;
		function[0x69] = itrp_ROUND;
		function[0x6A] = itrp_ROUND;
		function[0x6B] = itrp_ROUND;
		function[0x6C] = itrp_NROUND;
		function[0x6D] = itrp_NROUND;
		function[0x6E] = itrp_NROUND;
		function[0x6F] = itrp_NROUND;

		/***** 0x70 - 0x7f *****/
		function[0x70] = itrp_WCVTFOD;
		function[0x71] = itrp_DELTAP2;
		function[0x72] = itrp_DELTAP3;
		function[0x73] = itrp_DELTAC1;
		function[0x74] = itrp_DELTAC2;
		function[0x75] = itrp_DELTAC3;
		function[0x76] = itrp_SROUND;
		function[0x77] = itrp_S45ROUND;
		function[0x78] = itrp_JROT;
		function[0x79] = itrp_JROF;
		function[0x7A] = itrp_ROFF;
		function[0x7B] = itrp_IllegalInstruction;
		function[0x7C] = itrp_RUTG;
		function[0x7D] = itrp_RDTG;
		function[0x7E] = itrp_SANGW;
		function[0x7F] = itrp_AA;

		/***** 0x80 - 0x8d *****/
		function[0x80] = itrp_FLIPPT;
		function[0x81] = itrp_FLIPRGON;
		function[0x82] = itrp_FLIPRGOFF;
		function[0x83] = itrp_IDefPatch;
		function[0x84] = itrp_IDefPatch;
		function[0x85] = itrp_SCANCTRL;
		function[0x86] = itrp_SDPVTL;
		function[0x87] = itrp_SDPVTL;
		function[0x88] = itrp_GETINFO;
		function[0x89] = itrp_IDEF;
		function[0x8A] = itrp_ROTATE;
		function[0x8B] = itrp_MAX;
		function[0x8C] = itrp_MIN;
		function[0x8D] = itrp_SCANTYPE;
		function[0x8E] = itrp_INSTCTRL;

		/***** 0x8f - 0xaf *****/
		for ( i = 0x8F; i <= 0xAF;  ++i )
			function[i] = itrp_IDefPatch;

		/***** 0xb0 - 0xb7 *****/
		function[0xB0] = itrp_PUSHB1;
		function[0xB1] = itrp_PUSHB;
		function[0xB2] = itrp_PUSHB;
		function[0xB3] = itrp_PUSHB;
		function[0xB4] = itrp_PUSHB;
		function[0xB5] = itrp_PUSHB;
		function[0xB6] = itrp_PUSHB;
		function[0xB7] = itrp_PUSHB;

		/***** 0xb8 - 0xbf *****/
		function[0xB8] = itrp_PUSHW1;
		function[0xB9] = itrp_PUSHW;
		function[0xBA] = itrp_PUSHW;
		function[0xBB] = itrp_PUSHW;
		function[0xBC] = itrp_PUSHW;
		function[0xBD] = itrp_PUSHW;
		function[0xBE] = itrp_PUSHW;
		function[0xBF] = itrp_PUSHW;

		/***** 0xc0 - 0xdf *****/
		for ( i = 0xC0; i <= 0xDF;  i++ )
			function[i] = itrp_MDRP;

		/***** 0xe0 - 0xff *****/
		for ( i = 0xE0; i <= 0xFF;  i++ )
			function[i] = itrp_MIRP;
		
#ifdef FSCFG_SUBPIXEL
		// initialize round function table for SP
		itrp_RoundFunction[0][0] = itrp_RoundToDoubleGrid;
		itrp_RoundFunction[0][1] = itrp_RoundDownToGrid;
		itrp_RoundFunction[0][2] = itrp_RoundUpToGrid;
		itrp_RoundFunction[0][3] = itrp_RoundToGrid;
		itrp_RoundFunction[0][4] = itrp_RoundToHalfGrid;
		itrp_RoundFunction[0][5] = itrp_RoundOff;
		itrp_RoundFunction[0][6] = itrp_SuperRound;
		itrp_RoundFunction[0][7] = itrp_Super45Round;
		itrp_RoundFunction[1][0] = itrp_RoundToDoubleGridSP;
		itrp_RoundFunction[1][1] = itrp_RoundDownToGridSP;
		itrp_RoundFunction[1][2] = itrp_RoundUpToGridSP;
		itrp_RoundFunction[1][3] = itrp_RoundToGridSP;
		itrp_RoundFunction[1][4] = itrp_RoundToHalfGridSP;
		itrp_RoundFunction[1][5] = itrp_RoundOffSP;
		itrp_RoundFunction[1][6] = itrp_SuperRound;
		itrp_RoundFunction[1][7] = itrp_Super45Round;
#endif
	}

#endif /* FSCFG_NO_INITIALIZED_DATA */

/* END OF interp.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\fondrv\tt\scaler\scbitmap.h ===
/*********************************************************************

	  scbitmap.h -- BitMap Module Exports

	  (c) Copyright 1992  Microsoft Corp.  All rights reserved.

	   8/19/93 deanb    fsc_CalcGrayRow added
	   6/10/93 deanb    fsc_InitializeBitMasks added
	   4/29/93 deanb    BLTCopy routine added
	   9/15/92 deanb    GetBit returns uint32 
	   8/17/92 deanb    GetBit, SetBit added 
	   7/27/92 deanb    ClearBitMap call added 
	   6/02/92 deanb    Row pointer, integer limits, no descriptor 
	   4/09/92 deanb    New types again 
	   3/16/92 deanb    New types 
	   1/15/92 deanb    First cut 

**********************************************************************/

#include "fscdefs.h"                /* for type definitions */


/*********************************************************************/

/*      Export Functions                                             */

/*********************************************************************/


FS_PUBLIC void fsc_InitializeBitMasks (
		void
);

FS_PUBLIC int32 fsc_ClearBitMap ( 
		uint32,             /* longs per bmp */
		uint32*             /* bitmap ptr caste long */
);

FS_PUBLIC int32 fsc_BLTHoriz ( 
		int32,              /* x start */
		int32,              /* x stop */
		uint32*             /* bit map row pointer */
);

FS_PUBLIC int32 fsc_BLTCopy ( 
		uint32*,            /* source row pointer */
		uint32*,            /* destination row pointer */
		int32               /* long word counter */
);

FS_PUBLIC uint32 fsc_GetBit ( 
		int32,              /* x coordinate */
		uint32*             /* bit map row pointer */
);

FS_PUBLIC int32 fsc_SetBit ( 
		int32,              /* x coordinate */
		uint32*             /* bit map row pointer */
);

FS_PUBLIC int32 fsc_CalcGrayRow(
		GrayScaleParam*     /* pointer to param block */
);


/*********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\advcore\gdiplus\engine\fondrv\tt\scaler\scanlist.c ===
/*********************************************************************

	  scanlist.c -- New Scan Converter ScanList Module

	  (c) Copyright 1992  Microsoft Corp.  All rights reserved.

	   8/23/93  deanb   gray scale pass through functions
	   6/22/93  deanb   all dropouts confined to bounding box
	   6/10/93  deanb   fsc_InitializeScanlist added, stdio & assert gone
	   4/26/93  deanb   fix pointers now works with segmented memory
	   4/19/93  deanb   banding added
	   4/07/93  deanb   sorting is now done on the fly
	   4/01/93  deanb   intersection arrays replace linked lists
	   3/19/93  deanb   size_t replaced with int32
	  12/22/92  deanb   Rectangle -> Rect
	  10/28/92  deanb   memory requirements reworked
	  10/19/92  deanb   smart dropout tiebreak left & down
	  10/14/92  deanb   delete usScanKind from state
	  10/09/92  deanb   reentrant
	  10/08/92  deanb   reworked for split workspace
	  10/02/92  deanb   correct AddVertDropoutScan assertions
	   9/25/92  deanb   separate nodrop/dropout entry points
	   9/22/92  deanb   smart dropout control
	   9/17/92  deanb   stub control
	   9/15/92  deanb   simple dropout control
	   9/11/92  deanb   setupscan handles scankind
	   9/09/92  deanb   dropout / nodropout begun
	   8/17/92  deanb   include struc.h scconst.h
	   8/07/92  deanb   initial dropout control
	   8/06/92  deanb   assertions reinstated
	   7/27/92  deanb   bitmap clear added
	   7/16/92  deanb   gulBytesRemaining -> gulIntersectRemaining
	   6/18/92  deanb   int x coord for HorizScanAdd
	   6/01/92  deanb   incorporate bitmap functions
	   5/08/92  deanb   reordered includes for precompiled headers
	   5/04/92  deanb   Array tags added
	   4/28/92  deanb   list array sentinels added
	   4/21/92  deanb   single HorizScanAdd routine
	   4/15/92  deanb   calls to BitMap
	   4/13/92  deanb   uiY to iY for HorizScanOn/Off
	   4/09/92  deanb   New types
	   4/03/92  deanb   HorizScan On/Off coded
	   3/31/92  deanb   InitScanArray begun
	   3/25/92  deanb   GetWorkSizes and local types
	   3/23/92  deanb   First cut

**********************************************************************/

/*********************************************************************/

/*      Imports                                                      */

/*********************************************************************/

#define FSCFG_INTERNAL

#include    "fscdefs.h"             /* shared data types */
#include    "fserror.h"             /* error codes */

#include    "scglobal.h"            /* structures & constants */
#include    "scgray.h"              /* gray scale param block */
#include    "scbitmap.h"            /* bit blt operations */
#include    "scmemory.h"            /* for allocations */

/*********************************************************************/

/*      Contour reversal list structures                             */

/*********************************************************************/

typedef struct Rev                  /* Reversal list entry */
{
	int16 sScan;                    /* scan line */
	int16 sCross;                   /* direction +1 or -1 */
	struct Rev *prevLink;           /* link to next reversal */
}
Reversal;

struct RevRoots                     /* Reversal list roots */
{
	Reversal *prevYRoot;            /* Y direction contour reversals */
	Reversal *prevXRoot;            /* X direction contour reversals */
	Reversal *prevNext;             /* Next available list item */
	Reversal *prevEnd;              /* End of buffer (for overflow check) */
	struct RevRoots *prrSelf;       /* to check for moved memory */
};

#include    "scanlist.h"            /* for own function prototypes */

/*********************************************************************/

/*      Local Prototypes                                             */

/*********************************************************************/

FS_PRIVATE void AddReversal (Reversal**, Reversal*, F26Dot6, int16);
FS_PRIVATE int32 GetIxEstimate(Reversal*);
FS_PRIVATE void FixPointers(PRevRoot);

FS_PRIVATE void AddHorizSimpleScan(PSTATE int32, int32);
FS_PRIVATE void AddVertSimpleScan(PSTATE int32, int32);
FS_PRIVATE void AddHorizSmartScan(PSTATE int32, int32);
FS_PRIVATE void AddVertSmartScan(PSTATE int32, int32);
FS_PRIVATE void AddHorizSimpleBand(PSTATE int32, int32);
FS_PRIVATE void AddHorizSmartBand(PSTATE int32, int32);

FS_PRIVATE int32 LookForDropouts(PSTATE char*, uint16);
FS_PRIVATE int32 DoHorizDropout(PSTATE int16*, int16*, int32, char*, uint16);
FS_PRIVATE int32 DoVertDropout(PSTATE int16*, int16*, int32, char*, uint16);

FS_PRIVATE int32 HorizCrossings(PSTATE int32, int32);
FS_PRIVATE int32 VertCrossings(PSTATE int32, int32);

FS_PRIVATE uint32 GetBitAbs(PSTATE char*, int32, int32);
FS_PRIVATE int32 SetBitAbs(PSTATE char*, int32, int32);


/*********************************************************************/

/*      Initialization Functions                                     */

/*********************************************************************/

FS_PUBLIC void fsc_InitializeScanlist()
{
	fsc_InitializeBitMasks();
}


/*********************************************************************/

/*      Contour Reversal Functions                                   */

/*********************************************************************/

/* setup the contour reversal list roots structure */

FS_PUBLIC PRevRoot  fsc_SetupRevRoots (
		char* pchRevBuf,
		int32 lRevBufSize )
{
	PRevRoot prrRoots;
	Reversal *prevSentinel;
	
	prrRoots = (PRevRoot) pchRevBuf;                /* workspace begin */
	prevSentinel = (Reversal*) (prrRoots + 1);      /* just past the roots */

	prrRoots->prevYRoot = prevSentinel;             /* point to sentinel */
	prrRoots->prevXRoot = prevSentinel;             /* for both lists */
	prevSentinel->sScan = HUGEINT;                  /* stop value */
	prevSentinel->sCross = 0;
	prevSentinel->prevLink = NULL;
	prrRoots->prevNext = prevSentinel + 1;          /* to next free record */
	
	prrRoots->prevEnd = (Reversal*)(pchRevBuf + lRevBufSize);
	prrRoots->prrSelf = prrRoots;                   /* for address validation */
	
	return prrRoots;
}

/*********************************************************************/

/* insert into y list one countour reversal structure */

FS_PUBLIC void fsc_AddYReversal (
		PRevRoot prrRoots,
		F26Dot6 fxCoord,
		int16 sDir )
{
	AddReversal(&(prrRoots->prevYRoot), prrRoots->prevNext, fxCoord, sDir);

	(prrRoots->prevNext)++;                     /* to next free memory */

	Assert(prrRoots->prevNext <= prrRoots->prevEnd);
}

/*********************************************************************/

/* insert into x list one countour reversal structure */

FS_PUBLIC void fsc_AddXReversal (
		PRevRoot prrRoots,
		F26Dot6 fxCoord,
		int16 sDir )
{
	AddReversal(&(prrRoots->prevXRoot), prrRoots->prevNext, fxCoord, sDir);

	(prrRoots->prevNext)++;                     /* to next free memory */

	Assert(prrRoots->prevNext <= prrRoots->prevEnd);
}

/*********************************************************************/

/* insert into x or y list one countour reversal structure */

FS_PRIVATE void AddReversal (
		Reversal **pprevList,
		Reversal *prevNext,
		F26Dot6 fxCoord,
		int16 sDir )
{
	int16 sScan;

	sScan = (int16)((fxCoord + SUBHALF + (sDir >> 1)) >> SUBSHFT);

	while(sScan > (*pprevList)->sScan)          /* will stop before sentinel */
	{
		pprevList = &((*pprevList)->prevLink);  /* else link to next */
	}
	prevNext->sScan = sScan;                    /* save scanline */
	prevNext->sCross = -sDir;                   /* count up from bottom */
	prevNext->prevLink = *pprevList;            /* link rest of list */

	*pprevList = prevNext;                      /* insert new item */
}

/*********************************************************************/

/* return the total number of reversals in the lists */

FS_PUBLIC int32 fsc_GetReversalCount (PRevRoot prrRoots)
{
	return (int32)(( prrRoots->prevNext - 1 -           /* don't count sentinel */
			 (Reversal*)((char*)prrRoots + sizeof(struct RevRoots))) );
}

/*********************************************************************/

/* calculate anticipated horizontal intersections */

FS_PUBLIC int32 fsc_GetHIxEstimate(PRevRoot prrRoots)
{
	if (prrRoots != prrRoots->prrSelf)          /* if reversals have moved */
	{
		FixPointers(prrRoots);                  /* then patch up the pointers */
	}
	return ( GetIxEstimate( prrRoots->prevYRoot ) );
}

/*********************************************************************/

/* calculate anticipated vertical intersections */

FS_PUBLIC int32 fsc_GetVIxEstimate(PRevRoot prrRoots)
{
	if (prrRoots != prrRoots->prrSelf)          /* if reversals have moved */
	{
		FixPointers(prrRoots);                  /* then patch up the pointers */
	}
	return ( GetIxEstimate( prrRoots->prevXRoot ) );
}

/*********************************************************************/

/* calculate anticipated intersections */

FS_PRIVATE int32 GetIxEstimate(Reversal *prevList)
{
	int32 lTotalIx;
	
	lTotalIx = 0L;
	while (prevList->sScan < HUGEINT)       /* look through list */
	{
		if (prevList->sCross == 1)          /* adding up columns! */
		{
			lTotalIx -= (int32)prevList->sScan;
		}
		else
		{
			lTotalIx += (int32)prevList->sScan;
		}
		prevList = prevList->prevLink;
	}
	return(lTotalIx);
}

/*********************************************************************/

/* calculate horizontal intersections for banding */

FS_PUBLIC int32 fsc_GetHIxBandEst(
		PRevRoot prrRoots,
		Rect* prectBox,
		  int32 lBandWidth
)
{
	Reversal *prevHiList;               /* high band reversal pointer */
	Reversal *prevLoList;               /* low band reversal pointer */
	int16 sHiScan;                      /* current top of band */
	int16 sLoScan;                      /* current bottom of band */
	int16 sHiCross;                     /* top of band's crossings */
	int16 sLoCross;                     /* bottom of band's crossings*/
	int32 lTotalIx;                     /* intersection count for each band */
	int32 lBiggestIx;                   /* largest intersection count */

	if (prrRoots != prrRoots->prrSelf)          /* if reversals have moved */
	{
		FixPointers(prrRoots);                  /* then patch up the pointers */
	}
	lTotalIx = 0;
	prevHiList = prrRoots->prevYRoot;
	sHiScan = prectBox->bottom;
	sHiCross = 0;
	while (lBandWidth > 0)
	{
		while (prevHiList->sScan <= sHiScan)
		{
			sHiCross += prevHiList->sCross;     /* add in this line's crossings */
			prevHiList = prevHiList->prevLink;  /* link to next reversal */
		}
		lTotalIx += (int32)sHiCross;            /* add up first band's crossings */
		sHiScan++;
		lBandWidth--;
	}
	lBiggestIx = lTotalIx;

	prevLoList = prrRoots->prevYRoot;
	sLoScan = prectBox->bottom;
	sLoCross = 0;
	while (sHiScan < prectBox->top)
	{
		while (prevHiList->sScan <= sHiScan)
		{
			sHiCross += prevHiList->sCross;     /* add in high line's crossings */
			prevHiList = prevHiList->prevLink;  /* link to next reversal */
		}
		while (prevLoList->sScan <= sLoScan)
		{
			sLoCross += prevLoList->sCross;     /* add in low line's crossings */
			prevLoList = prevLoList->prevLink;  /* link to next reversal */
		}
		lTotalIx += (int32)(sHiCross - sLoCross);
		if (lTotalIx > lBiggestIx)
		{
			lBiggestIx = lTotalIx;              /* save the largest value */
		}
		sHiScan++;
		sLoScan++;
	}
	return(lBiggestIx);
}

/*********************************************************************/

/*      return number of bytes used by reversal lists                */

FS_PUBLIC int32 fsc_GetRevMemSize(PRevRoot prrRoots)
{
	return (int32)((char*)(prrRoots->prevNext) - (char*)prrRoots);
}

/*********************************************************************/

/*  when reversal list has moved, recalculate the pointers           */

FS_PRIVATE void FixPointers(PRevRoot prrRoots)
{
	char *pchNewBase;
	char *pchOldBase;
	Reversal *prevList;

	pchNewBase = (char*)prrRoots;
	pchOldBase = (char*)prrRoots->prrSelf;          /* pre-move base addr */

	prrRoots->prevYRoot = (Reversal*)(pchNewBase + ((char*)prrRoots->prevYRoot - pchOldBase));
	prrRoots->prevXRoot = (Reversal*)(pchNewBase + ((char*)prrRoots->prevXRoot - pchOldBase));
	prrRoots->prevNext = (Reversal*)(pchNewBase + ((char*)prrRoots->prevNext - pchOldBase));
	prrRoots->prevEnd = (Reversal*)(pchNewBase + ((char*)prrRoots->prevEnd - pchOldBase));
	
	prevList = prrRoots->prevYRoot;
	while(prevList->sScan < HUGEINT)                /* from root to sentinel */
	{
		prevList->prevLink = (Reversal*)(pchNewBase + ((char*)prevList->prevLink - pchOldBase));
		prevList = prevList->prevLink;
	}
	
	prevList = prrRoots->prevXRoot;
	while(prevList->sScan < HUGEINT)                /* from root to sentinel */
	{
		prevList->prevLink = (Reversal*)(pchNewBase + ((char*)prevList->prevLink - pchOldBase));
		prevList = prevList->prevLink;
	}
	
	prrRoots->prrSelf = prrRoots;                   /* for next time */
}

/*********************************************************************/

/*      Workspace Calcluation Functions                              */

/*********************************************************************/

/* calculate horizontal scan workspace memory requirements */

FS_PUBLIC int32 fsc_GetScanHMem(
		uint16 usScanKind,      /* scan type */
		int32 lHScan,           /* number of horiz scanlines */
		int32 lHInter )         /* number of horiz intersections */
{
	ALIGN(voidPtr, lHScan); 
	ALIGN(voidPtr, lHInter ); 
	if (!(usScanKind & SK_SMART))       /* if simple dropout */
	{
		return (lHScan * (5 * sizeof(int16*)) +     /* for on/off begin/end */
				lHInter * (2 * sizeof(int16)));     /* for intersection arrays */
	}
	else                                /* if smart dropout */
	{
		return (lHScan * (5 * sizeof(int16*)) +     /* for on/off begin/end */
				lHInter * (4 * sizeof(int16)));     /* for ix/code arrays */
	}
}


/*********************************************************************/

/* calculate vertical scan workspace memory requirements */

FS_PUBLIC int32 fsc_GetScanVMem(
		uint16 usScanKind,      /* scan type */
		int32 lVScan,           /* number of vert scanlines */
		int32 lVInter,          /* number of vert intersections */
		int32 lElemPts )        /* number of contour element points */
{
	ALIGN(voidPtr, lVScan); 
	ALIGN(voidPtr, lVInter); 
	ALIGN(voidPtr, lElemPts ); 
	if (!(usScanKind & SK_SMART))       /* if simple dropout */
	{
		return (lVScan * (5 * sizeof(int16*)) +     /* for on/off begin/end */
				lVInter * (2 * sizeof(int16)));     /* for intersection arrays */
	}
	else                                /* if smart dropout */
	{
		return (lVScan * (5 * sizeof(int16*)) +     /* for on/off begin/end */
				lVInter * (4 * sizeof(int16)) +     /* for ix/code arrays */
				lElemPts * (2 * sizeof(F26Dot6)));  /* for element (x, y) */
	}
}

/*********************************************************************/

/*      Scan Conversion Preparation Functions                        */

/*********************************************************************/

/*  Line, Spline, and Endpoint register their callbacks here */

FS_PUBLIC void fsc_SetupCallBacks(
		PSTATE                       /* pointer to state variables */
		int16 sCode,                 /* element code (line, spline, endpoint) */
		F26Dot6 (*pfnHoriz)(int32, F26Dot6*, F26Dot6*),   /* horiz callback */
		F26Dot6 (*pfnVert)(int32, F26Dot6*, F26Dot6*)     /* vert callback */
)
{
	STATE.pfnHCallBack[sCode] = pfnHoriz;
	STATE.pfnVCallBack[sCode] = pfnVert;
}


/*********************************************************************/

/*  Allocate scan workspace memory and set up pointer arrays */

FS_PUBLIC int32 fsc_SetupScan(
		PSTATE                      /* pointer to state variables */
		Rect* prectBox,             /* bounding box */
		uint16 usScanKind,          /* dropout control value */
		int32 lHiBand,              /* top scan limit */
		int32 lLoBand,              /* bottom scan limit */
		boolean bSaveRow,           /* save last bitmap row for dropout */
		int32 lRowBytes,            /* for last row alloc */
		int32 lHInterCount,         /* estimate of horiz intersections */
		int32 lVInterCount,         /* estimate of vert intersections */
		int32 lElemCount,           /* estimate of element points */
		PRevRoot prrRoots           /* reversal list roots */
)
{
	int32 lHorizBandCount;          /* number of horizontal scan lines */
	int32 lVertScanCount;           /* number of vertical scan lines */
	int32 lPointerArraySize;        /* bytes per pointer array */

	int16 sScan;                    /* current scan line */
	int16 sCross;                   /* crossings on this line */
	int16 *psScanIx;                /* temp scan intersection array */
	Reversal *prevList;             /* pointer to reversal list */
	
    int16 **ppsHOnBegin;            /* for init speed */
    int16 **ppsHOnEnd;
    int16 **ppsHOffBegin;
    int16 **ppsHOffEnd;
    int16 **ppsHOffMax;
    int16 **ppsVOnBegin;            /* for init speed */
    int16 **ppsVOnEnd;
    int16 **ppsVOffBegin;
    int16 **ppsVOffEnd;
    int16 **ppsVOffMax;


    STATE.lBoxTop = (int32)prectBox->top;   /* copy the bounding box */
    STATE.lBoxBottom = (int32)prectBox->bottom;
    STATE.lBoxLeft = (int32)prectBox->left;
    STATE.lBoxRight = (int32)prectBox->right;
    
    STATE.lHiScanBand = lHiBand;    /* copy scan band limits */
    STATE.lLoScanBand = lLoBand;
    
/*  set STATE according to dropout and banding requirements */

    if ((usScanKind & SK_NODROPOUT) || !(usScanKind & SK_SMART))
    {
        STATE.sIxSize = 1;          /* one int16 per intersection */
        STATE.sIxShift = 0;         /* log2 of size */

        if ((STATE.lHiScanBand == STATE.lBoxTop) && (STATE.lLoScanBand == STATE.lBoxBottom))
        {
            STATE.pfnAddHoriz = AddHorizSimpleScan;
        }
        else    /* if banding */
        {
            STATE.pfnAddHoriz = AddHorizSimpleBand;
        }
        STATE.pfnAddVert = AddVertSimpleScan;
    }
    else        /* if smart dropout */
    {
        STATE.sIxSize = 2;          /* two int16's per intersection */
        STATE.sIxShift = 1;         /* log2 of size */

        if ((STATE.lHiScanBand == STATE.lBoxTop) && (STATE.lLoScanBand == STATE.lBoxBottom))
        {
            STATE.pfnAddHoriz = AddHorizSmartScan;
        }
        else    /* if banding */
        {
            STATE.pfnAddHoriz = AddHorizSmartBand;
        }
        STATE.pfnAddVert = AddVertSmartScan;
    }

/* setup horizontal intersection array for all cases */
    
    lHorizBandCount = STATE.lHiScanBand - STATE.lLoScanBand;
    Assert(lHorizBandCount > 0);
    
    lPointerArraySize = lHorizBandCount * sizeof(int16*);
    STATE.apsHOnBegin = (int16**) fsc_AllocHMem(ASTATE lPointerArraySize);
    STATE.apsHOffBegin = (int16**) fsc_AllocHMem(ASTATE lPointerArraySize);
    STATE.apsHOnEnd = (int16**) fsc_AllocHMem(ASTATE lPointerArraySize);
    STATE.apsHOffEnd = (int16**) fsc_AllocHMem(ASTATE lPointerArraySize);
    STATE.apsHOffMax = (int16**) fsc_AllocHMem(ASTATE lPointerArraySize);

    STATE.lPoint = 0L;                      /* initial element index */
    STATE.lElementPoints = lElemCount;

    psScanIx = (int16*) fsc_AllocHMem(ASTATE lHInterCount << (STATE.sIxShift + 2));
            
    if (prrRoots != prrRoots->prrSelf)      /* if reversals have moved */
    {
        FixPointers(prrRoots);              /* then patch up the pointers */
    }
    prevList = prrRoots->prevYRoot;         /* root of y list reversals */
    sCross = 0;
    
    ppsHOnBegin = STATE.apsHOnBegin;        /* for init speed */
    ppsHOnEnd = STATE.apsHOnEnd;
    ppsHOffBegin = STATE.apsHOffBegin;
    ppsHOffEnd = STATE.apsHOffEnd;
    ppsHOffMax = STATE.apsHOffMax;

/* initialize horizontal scan arrays */
    
    for (sScan = (int16)STATE.lLoScanBand; sScan < (int16)STATE.lHiScanBand; sScan++)
    {
        while (prevList->sScan <= sScan)
        {
            sCross += (prevList->sCross << STATE.sIxShift); /* add in this line's crossings */
            prevList = prevList->prevLink;                  /* link to next reversal */
        }
        *ppsHOnBegin = psScanIx;
        ppsHOnBegin++;
        *ppsHOnEnd = psScanIx;
        ppsHOnEnd++;
        psScanIx += sCross;
                
        *ppsHOffBegin = psScanIx;
        ppsHOffBegin++;
        *ppsHOffEnd = psScanIx;
        ppsHOffEnd++;
        psScanIx += sCross;
        *ppsHOffMax = psScanIx;
        ppsHOffMax++;
    }
    
/* if doing dropout control, setup X intersection array */

    if (!(usScanKind & SK_NODROPOUT))           /* if any kind of dropout */
    {
        lVertScanCount = (int32)(prectBox->right - prectBox->left);
        Assert(lVertScanCount > 0);

        lPointerArraySize = lVertScanCount * sizeof(int16*);
        STATE.apsVOnBegin = (int16**) fsc_AllocVMem(ASTATE lPointerArraySize);
        STATE.apsVOffBegin = (int16**) fsc_AllocVMem(ASTATE lPointerArraySize);
        STATE.apsVOnEnd = (int16**) fsc_AllocVMem(ASTATE lPointerArraySize);
        STATE.apsVOffEnd = (int16**) fsc_AllocVMem(ASTATE lPointerArraySize);
        STATE.apsVOffMax = (int16**) fsc_AllocVMem(ASTATE lPointerArraySize);

        if (bSaveRow)                           /* if fast banding & dropout */
        {
            STATE.pulLastRow = (uint32*) fsc_AllocVMem(ASTATE lRowBytes);
            STATE.lLastRowIndex = HUGEFIX;      /* impossible value => uninitialized */
        }
        psScanIx = (int16*) fsc_AllocVMem(ASTATE lVInterCount << (STATE.sIxShift + 2));
                
        prevList = prrRoots->prevXRoot;         /* root of x list reversals */
        sCross = 0;
        sScan = prectBox->left;
    
        ppsVOnBegin = STATE.apsVOnBegin;        /* for init speed */
        ppsVOnEnd = STATE.apsVOnEnd;
        ppsVOffBegin = STATE.apsVOffBegin;
        ppsVOffEnd = STATE.apsVOffEnd;
        ppsVOffMax = STATE.apsVOffMax;
    
        for (sScan = prectBox->left; sScan < prectBox->right; sScan++)
        {
            while (prevList->sScan <= sScan)
            {
                sCross += (prevList->sCross << STATE.sIxShift); /* add in this line's crossings */
                prevList = prevList->prevLink;                  /* link to next reversal */
            }
            *ppsVOnBegin = psScanIx;
            ppsVOnBegin++;
            *ppsVOnEnd = psScanIx;
            ppsVOnEnd++;
            psScanIx += sCross;
                    
            *ppsVOffBegin = psScanIx;
            ppsVOffBegin++;
            *ppsVOffEnd = psScanIx;
            ppsVOffEnd++;
            psScanIx += sCross;
            *ppsVOffMax = psScanIx;
            ppsVOffMax++;
        }
        if (usScanKind & SK_SMART)              /* if smart dropout */
        {
            STATE.afxXPoints = (F26Dot6*) fsc_AllocVMem(ASTATE lElemCount * sizeof(F26Dot6));
            STATE.afxYPoints = (F26Dot6*) fsc_AllocVMem(ASTATE lElemCount * sizeof(F26Dot6));
        }
    }
    return NO_ERR;
}

/*********************************************************************/

/* This function saves the first contour point for smart dropout calcs */

FS_PUBLIC void fsc_BeginContourScan(
		PSTATE                              /* pointer to state variables */
		uint16 usScanKind,                  /* scan type */
		F26Dot6 fxX1,                       /* starting point x coordinate */
		F26Dot6 fxY1                        /* starting point y coordinate */
)
{
	if (!(usScanKind & SK_NODROPOUT) && (usScanKind & SK_SMART)) /* if smart dropout */
	{
		STATE.afxXPoints[STATE.lPoint] = fxX1;
		STATE.afxYPoints[STATE.lPoint] = fxY1;
		STATE.lPoint++;
		Assert (STATE.lPoint <= STATE.lElementPoints);
	}
}

/*********************************************************************/
	
/* This function is called at the beginning of each line, subdivided */
/* spline, or endpoint-on-scanline.  It sets scanline state variables, */
/* save control points (for smart dropout control), and return the */
/* appropriate AddScan function pointers */

FS_PUBLIC void fsc_BeginElement(
	PSTATE                                      /* pointer to state variables */
	uint16 usScanKind,                          /* type of dropout control */
	int32 lQuadrant,                            /* determines scan on/off */
	int32 lElementCode,                         /* element (line, spline, ep) */
	int32 lPts,                                 /* number of points to store */
	F26Dot6 *pfxX,                              /* next x control point(s) */
	F26Dot6 *pfxY,                              /* next y control point(s) */
	void (**ppfnAddHorizScan)(PSTATE int32, int32),  /* horiz add scan return */
	void (**ppfnAddVertScan)(PSTATE int32, int32)    /* vert add scan return */
)
{
	*ppfnAddHorizScan = STATE.pfnAddHoriz;      /* set horiz add scan func */
	*ppfnAddVertScan = STATE.pfnAddVert;        /* set vert add scan func */

	
    if ((lQuadrant == 1) || (lQuadrant == 2))
    {
        STATE.apsHorizBegin = STATE.apsHOnBegin;    /* add 'on' interscections */
        STATE.apsHorizEnd = STATE.apsHOnEnd;
        STATE.apsHorizMax = STATE.apsHOffBegin;  /* the max for the on array is the beginning of off array */
    }
    else
    {
        STATE.apsHorizBegin = STATE.apsHOffBegin;   /* add 'off' interscections */
        STATE.apsHorizEnd = STATE.apsHOffEnd;
        STATE.apsHorizMax = STATE.apsHOffMax; /* the max for the off array is the max array */ 
    }
    
    if (!(usScanKind & SK_NODROPOUT))               /* if any kind of dropout */
    {
        if ((lQuadrant == 2) || (lQuadrant == 3))
        {
            STATE.apsVertBegin = STATE.apsVOnBegin; /* add 'on' interscections */
            STATE.apsVertEnd = STATE.apsVOnEnd;
            STATE.apsVertMax = STATE.apsVOffBegin;  /* the max for the on array is the beginning of off array */
        }
        else
        {
            STATE.apsVertBegin = STATE.apsVOffBegin; /* add 'off' interscections */
            STATE.apsVertEnd = STATE.apsVOffEnd;
            STATE.apsVertMax = STATE.apsVOffMax; /* the max for the off array is the max array */
        }
		
		if (usScanKind & SK_SMART)              /* if smart dropout */
		{
            Assert((STATE.lPoint - 1) <= (0xFFFF >> SC_CODESHFT));
			STATE.usScanTag = (uint16)(((STATE.lPoint - 1) << SC_CODESHFT) | lElementCode);

			while (lPts > 0)                    /* save control points */
			{
				STATE.afxXPoints[STATE.lPoint] = *pfxX;
				pfxX++;
				STATE.afxYPoints[STATE.lPoint] = *pfxY;
				pfxY++;
				STATE.lPoint++;
				lPts--;
				Assert (STATE.lPoint <= STATE.lElementPoints);
			}
		}
	}
}


/*********************************************************************/

/*      Add Scanline Intersection Functions                          */

/*********************************************************************/

/*  Sort a simple intersection into the horizontal scan list array  */

FS_PRIVATE void AddHorizSimpleScan(
        PSTATE                      /* pointer to state variables */
        int32 lX,                   /* x coordinate */
        int32 lY )                  /* scan index */
{
    int16 **ppsEnd;                 /* ptr to end array top */
    int16 *psBegin;                 /* pts to first array element */
    int16 *psEnd;                   /* pts past last element */
    int16 *psLead;                  /* leads psEnd walking backward */
    int16 sX;

/* printf("H(%li, %li)  ", lX, lY); */

    Assert(lX >= STATE.lBoxLeft);   /* trap unreasonable values */
    Assert(lX <= STATE.lBoxRight);
    Assert(lY >= STATE.lBoxBottom);
    Assert(lY < STATE.lBoxTop);

    lY -= STATE.lBoxBottom;         /* normalize */
    psBegin = STATE.apsHorizBegin[lY];
    ppsEnd = &STATE.apsHorizEnd[lY];
    psEnd = *ppsEnd;
    (*ppsEnd)++;                    /* bump ptr for next time */

    Assert(*ppsEnd <= STATE.apsHorizMax[lY]);
    
    psLead = psEnd - 1;
    sX = (int16)lX;
    
    while((psLead >= psBegin) && (*psLead > sX))
    {
        *psEnd-- = *psLead--;       /* make room */
    }
    *psEnd = sX;                    /* store new value */
}

/*********************************************************************/

/*  Sort a simple intersection into the vertical scan list array  */

FS_PRIVATE void AddVertSimpleScan(
        PSTATE                      /* pointer to state variables */
        int32 lX,                   /* x coordinate */
        int32 lY )                  /* scan index */
{
    int16 **ppsEnd;                 /* ptr to end array top */
    int16 *psBegin;                 /* pts to first array element */
    int16 *psEnd;                   /* pts past last element */
    int16 *psLead;                  /* leads psEnd walking backward */
    int16 sY;

/* printf("V(%li, %li)  ", lX, lY); */

    Assert(lX >= STATE.lBoxLeft);   /* trap unreasonable values */
    Assert(lX < STATE.lBoxRight);
    Assert(lY >= STATE.lBoxBottom);
    Assert(lY <= STATE.lBoxTop);

    lX -= STATE.lBoxLeft;           /* normalize */
    psBegin = STATE.apsVertBegin[lX];
    ppsEnd = &STATE.apsVertEnd[lX];
    psEnd = *ppsEnd;
    (*ppsEnd)++;                    /* bump ptr for next time */

    Assert(*ppsEnd <= STATE.apsVertMax[lX]);

    psLead = psEnd - 1;
    sY = (int16)lY;
    
    while((psLead >= psBegin) && (*psLead > sY))
    {
        *psEnd-- = *psLead--;       /* make room */
    }
    *psEnd = sY;                    /* store new value */
}

/*********************************************************************/

/*  Sort a smart intersection into the horizontal scan list array  */

FS_PRIVATE void AddHorizSmartScan(
        PSTATE                      /* pointer to state variables */
        int32 lX,                   /* x coordinate */
        int32 lY )                  /* scan index */
{
    int16 **ppsEnd;                 /* ptr to end array top */
    uint32 *pulBegin;                /* pts to first array element */
    uint32 *pulEnd;                  /* pts past last element */
    uint32 *pulLead;                 /* leads pulEnd walking backward */
    int16 *psInsert;                /* new data insertion point */
    int16 sX;

    Assert(lX >= STATE.lBoxLeft);   /* trap unreasonable values */
    Assert(lX <= STATE.lBoxRight);
    Assert(lY >= STATE.lBoxBottom);
    Assert(lY < STATE.lBoxTop);
    
    lY -= STATE.lBoxBottom;         /* normalize */
    pulBegin = (uint32*)STATE.apsHorizBegin[lY];
    ppsEnd = &STATE.apsHorizEnd[lY];
    pulEnd = (uint32*)*ppsEnd;
    (*ppsEnd) += 2;                 /* value & tag */

    Assert(*ppsEnd <= STATE.apsHorizMax[lY]);

    pulLead = pulEnd - 1;
    sX = (int16)lX;

    while((pulLead >= pulBegin) && (*((int16*)pulLead) > sX))
    {
        *pulEnd-- = *pulLead--;     /* make room */
    }
    psInsert = (int16*)pulEnd;
    *psInsert = sX;                 /* store new value */
    psInsert++;
    *psInsert = STATE.usScanTag;    /* keep tag too */
}

/*********************************************************************/

/*  Sort a smart intersection into the vertical scan list array  */

FS_PRIVATE void AddVertSmartScan(
        PSTATE                      /* pointer to state variables */
        int32 lX,                   /* x coordinate */
        int32 lY )                  /* scan index */
{
    int16 **ppsEnd;                 /* ptr to end array top */
    uint32 *pulBegin;                /* pts to first array element */
    uint32 *pulEnd;                  /* pts past last element */
    uint32 *pulLead;                 /* leads pulEnd walking backward */
    int16 *psInsert;                /* new data insertion point */
    int16 sY;

    Assert(lX >= STATE.lBoxLeft);   /* trap unreasonable values */
    Assert(lX < STATE.lBoxRight);
    Assert(lY >= STATE.lBoxBottom);
    Assert(lY <= STATE.lBoxTop);
    
    lX -= STATE.lBoxLeft;         /* normalize */
    pulBegin = (uint32*)STATE.apsVertBegin[lX];
    ppsEnd = &STATE.apsVertEnd[lX];
    pulEnd = (uint32*)*ppsEnd;
    (*ppsEnd) += 2;                 /* value & tag */

    Assert(*ppsEnd <= STATE.apsVertMax[lX]);

    pulLead = pulEnd - 1;
    sY = (int16)lY;

    while((pulLead >= pulBegin) && (*((int16*)pulLead) > sY))
    {
        *pulEnd-- = *pulLead--;     /* make room */
    }
    psInsert = (int16*)pulEnd;
    *psInsert = sY;                 /* store new value */
    psInsert++;
    *psInsert = STATE.usScanTag;    /* keep tag too */
}

/*********************************************************************/

/*  Add an intersection with banding                                 */

/*********************************************************************/

/*  Sort a simple intersection into the horizontal band list array  */

FS_PRIVATE void AddHorizSimpleBand(
        PSTATE                      /* pointer to state variables */
        int32 lX,                   /* x coordinate */
        int32 lY )                  /* scan index */
{
    int16 **ppsEnd;                 /* ptr to end array top */
    int16 *psBegin;                 /* pts to first array element */
    int16 *psEnd;                   /* pts past last element */
    int16 *psLead;                  /* leads psEnd walking backward */
    int16 sX;

    Assert(lX >= STATE.lBoxLeft);   /* trap unreasonable values */
    Assert(lX <= STATE.lBoxRight);
    
    if ((lY >= STATE.lLoScanBand) && (lY < STATE.lHiScanBand))
    {
        lY -= STATE.lLoScanBand;    /* normalize */
        psBegin = STATE.apsHorizBegin[lY];
        ppsEnd = &STATE.apsHorizEnd[lY];
        psEnd = *ppsEnd;
        (*ppsEnd)++;                /* bump ptr for next time */

        Assert(*ppsEnd <= STATE.apsHorizMax[lY]);
        
        psLead = psEnd - 1;
        sX = (int16)lX;

        while((psLead >= psBegin) && (*psLead > sX))
        {
            *psEnd-- = *psLead--;   /* make room */
        }
        *psEnd = sX;                /* store new value */
    }
}

/*********************************************************************/

/*  Sort a smart intersection into the horizontal band list array  */

FS_PRIVATE void AddHorizSmartBand(
        PS