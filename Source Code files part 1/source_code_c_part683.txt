e;

    // ok, copy the data in
    RtlCopyMemory( &pSndRcvInfo->Data[0],
                   pArapBuf->CurrentBuffer,
                   pArapBuf->DataSize );


    // set the info (contexts need to be set each time in case of select)
    pSndRcvInfo->AtalkContext = pArapConn;
    pSndRcvInfo->pDllContext =  pArapConn->pDllContext;
    pSndRcvInfo->DataLen = SrpModLen;
    pSndRcvInfo->StatusCode = StatusCode;

    dwBytesToDll = SrpModLen + sizeof(ARAP_SEND_RECV_INFO);

    DBGDUMPBYTES("Dll recv:", &pSndRcvInfo->Data[0],pSndRcvInfo->DataLen,1);

    // ok, complete that irp now!
    ARAP_COMPLETE_IRP(pIrp, dwBytesToDll, STATUS_SUCCESS, &ReturnStatus);

    // done with that buffer: free it here
    ARAP_FREE_RCVBUF(pArapBuf);

    return(SrpModLen);
}


//***
//
// Function: MnpSendAckIfReqd
//              This routine sends an ack to the remote client after making
//              sure that condition(s) do exist warranting sending of an Ack.
//
// Parameters:  pArapConn - connection element in question
//
// Return:      none
//
//***$

VOID
MnpSendAckIfReqd(
	IN	PARAPCONN    pArapConn,
    IN  BOOLEAN      fForceAck
)
{
    KIRQL           OldIrql;
    BYTE            SeqToAck;
    BYTE            RecvCredit;
    PMNPSENDBUF     pMnpSendBuf;
    PBYTE           pFrame, pFrameStart;
    BOOLEAN         fOptimized=TRUE;
    USHORT          FrameLen;
    PNDIS_PACKET    ndisPacket;
    NDIS_STATUS     ndisStatus;
    DWORD           StatusCode;
    BOOLEAN         fMustSend;



    DBG_ARAP_CHECK_PAGED_CODE();

    ARAPTRACE(("Entered MnpSendAckIfReqd (%lx)\n",pArapConn));

    ACQUIRE_SPIN_LOCK(&pArapConn->SpinLock, &OldIrql);

    //
    // if we are not up yet (or are disconnecting), forget about this ack
    //
    if (pArapConn->State != MNP_UP)
    {
        RELEASE_SPIN_LOCK(&pArapConn->SpinLock, OldIrql);
        return;
    }

    fMustSend = FALSE;

    //
    // first, find out if we need to send an ack at all
    //


    //
    // if we are told to send, just send it: don't question the decision!
    //
    if (fForceAck)
    {
        fMustSend = TRUE;
    }


    //
    // spec says if we have one or more unacked pkts and there is no user data
    // to send, then send it (what's user data got to do with this??)
    //
// BUGBUG: for now, don't check for IsListEmpty(&pArapConn->HighPriSendQ)
#if 0
    else if ( (pArapConn->MnpState.UnAckedRecvs > 0) &&
              (IsListEmpty(&pArapConn->HighPriSendQ)) )
    {
        fMustSend = TRUE;
    }
#endif
    else if (pArapConn->MnpState.UnAckedRecvs > 0)
    {
        fMustSend = TRUE;
    }

    //
    // if we haven't acked for a while (i.e. have received more than the
    // acceptable number of unacked packets) then send it
    //
    else if (pArapConn->MnpState.UnAckedRecvs >= pArapConn->MnpState.UnAckedLimit)
    {
        fMustSend = TRUE;
    }

    if (!fMustSend)
    {
        RELEASE_SPIN_LOCK(&pArapConn->SpinLock, OldIrql);
        return;
    }


    StatusCode = ARAPERR_NO_ERROR;

    // first, allocate a buff descriptor (before we change the state variables)
	if ((pMnpSendBuf = AtalkBPAllocBlock(BLKID_MNP_SMSENDBUF)) != NULL)
    {
        StatusCode = ArapGetNdisPacket(pMnpSendBuf);
    }

    if ((pMnpSendBuf == NULL) || (StatusCode != ARAPERR_NO_ERROR))
    {
        if (pMnpSendBuf)
        {
            ArapNdisFreeBuf(pMnpSendBuf);
        }
        else
        {
            DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                ("MnpSendAckIfReqd: AtalkBPAllocBlock failed on %lx\n", pArapConn))
        }

        RELEASE_SPIN_LOCK(&pArapConn->SpinLock, OldIrql);
        return;
    }


    // BUGBUG: for now, always send full size
    //RecvCredit = pArapConn->MnpState.RecvCredit;
    RecvCredit = pArapConn->MnpState.WindowSize;

    // tell the client which is the last packet we got successfully
    SeqToAck = pArapConn->MnpState.LastSeqRcvd;

#if DBG
    if ((SeqToAck == pArapConn->MnpState.LastAckSent) && (pArapConn->MnpState.HoleInSeq++ > 1))
    {
        DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_INFO,
            ("MnpSendAckIfReqd: ack %x already sent earlier\n",SeqToAck));
    }
#endif

    pArapConn->MnpState.LastAckSent = pArapConn->MnpState.LastSeqRcvd;

    // with this ack, we will be acking all the outstanding recv's
    pArapConn->MnpState.UnAckedRecvs = 0;

    // "stop" the 402 timer
    pArapConn->LATimer = 0;

    // reset the flow-control timer
    pArapConn->FlowControlTimer = AtalkGetCurrentTick() +
                                    pArapConn->T404Duration;

    if (!(pArapConn->Flags & MNP_OPTIMIZED_DATA))
    {
        fOptimized = FALSE;
    }

    ARAP_DBG_TRACE(pArapConn,11605,0,SeqToAck,RecvCredit,0);

    MNP_DBG_TRACE(pArapConn,SeqToAck,MNP_LA);

    // put MNPSend refcount
    pArapConn->RefCount++;

    RELEASE_SPIN_LOCK(&pArapConn->SpinLock, OldIrql);

#if DBG
    pMnpSendBuf->Signature = MNPSMSENDBUF_SIGNATURE;
    InitializeListHead(&pMnpSendBuf->Linkage);
#endif

    pMnpSendBuf->RetryCount = 0;  // not relevant here
    pMnpSendBuf->RefCount = 1;    // remove when send completes
    pMnpSendBuf->pArapConn = pArapConn;
    pMnpSendBuf->ComplRoutine = NULL;
    pMnpSendBuf->Flags = 1;

    pFrame = pFrameStart = &pMnpSendBuf->Buffer[0];

    AtalkNdisBuildARAPHdr(pFrame, pArapConn);

    pFrame += WAN_LINKHDR_LEN;

    //
    // put the start flags
    //
    *pFrame++ = pArapConn->MnpState.SynByte;
    *pFrame++ = pArapConn->MnpState.DleByte;
    *pFrame++ = pArapConn->MnpState.StxByte;

    //
    // now, put the body of the Ack frame
    //
    if (fOptimized)
    {
        *pFrame++ = 3;              // length indication
        *pFrame++ = 5;              // type indication
        *pFrame++ = SeqToAck;       // Receive seq number ( N(R) )
        *pFrame++ = RecvCredit;     // receive credit ( N(k) )
    }
    else
    {
        *pFrame++ = 7;              // length indication
        *pFrame++ = 5;              // type indication
        *pFrame++ = 1;              // var type
        *pFrame++ = 1;              // var len
        *pFrame++ = SeqToAck;       // receive seq number ( N(R) )
        *pFrame++ = 2;              // var type
        *pFrame++ = 1;              // var len
        *pFrame++ = RecvCredit;     // receive credit ( N(k) )
    }

    //
    // now finally, put the stop flags (no need for spinlock: this won't change!)
    //
    *pFrame++ = pArapConn->MnpState.DleByte;
    *pFrame++ = pArapConn->MnpState.EtxByte;

    FrameLen = (USHORT)(pFrame - pFrameStart);

    AtalkSetSizeOfBuffDescData(&pMnpSendBuf->sb_BuffDesc, FrameLen);

    NdisAdjustBufferLength(pMnpSendBuf->sb_BuffHdr.bh_NdisBuffer,FrameLen);

    //
    // send the packet over.  We need to go directly, and not via ArapNdisSend
    // because this packet needs to be delivered just once, regardless of
    // whether send window is open
    //

    ndisPacket = pMnpSendBuf->sb_BuffHdr.bh_NdisPkt;

    NdisSend(&ndisStatus, RasPortDesc->pd_NdisBindingHandle, ndisPacket);

    // if there was a problem sending, call the completion routine here
    if (ndisStatus != NDIS_STATUS_PENDING)
    {
	    DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
            ("MnpSendAckIfReqd: NdisSend failed %lx\n",ndisStatus));

	    ArapNdisSendComplete(ARAPERR_SEND_FAILED, (PBUFFER_DESC)pMnpSendBuf, NULL);
	}
}



//***
//
// Function: MnpSendLNAck
//              This routine sends an LN ack to the remote client, acknowleding
//              receipt of an LN frame
//
// Parameters:  pArapConn - connection element in question
//
// Return:      none
//
//***$

VOID
MnpSendLNAck(
	IN	PARAPCONN    pArapConn,
    IN  BYTE         LnSeqToAck
)
{
    KIRQL           OldIrql;
    PMNPSENDBUF     pMnpSendBuf;
    PBYTE           pFrame, pFrameStart;
    USHORT          FrameLen;
    PNDIS_PACKET    ndisPacket;
    NDIS_STATUS     ndisStatus;
    DWORD           StatusCode;



    DBG_ARAP_CHECK_PAGED_CODE();

    ARAPTRACE(("Entered MnpSendLNAck (%lx), %d\n",pArapConn,LnSeqToAck));

    StatusCode = ARAPERR_NO_ERROR;

    // first, allocate a buff descriptor
	if ((pMnpSendBuf = AtalkBPAllocBlock(BLKID_MNP_SMSENDBUF)) != NULL)
    {
        StatusCode = ArapGetNdisPacket(pMnpSendBuf);
    }


    if (pMnpSendBuf == NULL || (StatusCode != ARAPERR_NO_ERROR))
    {
        if (pMnpSendBuf)
        {
            ArapNdisFreeBuf(pMnpSendBuf);
        }
        else
        {
            DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                ("MnpSendLNAck: AtalkBPAllocBlock failed on %lx\n", pArapConn))
        }
        return;
    }

#if DBG
    pMnpSendBuf->Signature = MNPSMSENDBUF_SIGNATURE;
    InitializeListHead(&pMnpSendBuf->Linkage);
#endif

    pMnpSendBuf->RetryCount = 0;  // not relevant here
    pMnpSendBuf->RefCount = 1;    // remove when send completes
    pMnpSendBuf->pArapConn = pArapConn;
    pMnpSendBuf->ComplRoutine = NULL;
    pMnpSendBuf->Flags = 1;

    pFrame = pFrameStart = &pMnpSendBuf->Buffer[0];

    ACQUIRE_SPIN_LOCK(&pArapConn->SpinLock, &OldIrql);

    // if we are disconnecting, forget about sending this ack
    if (pArapConn->State >= MNP_LDISCONNECTING)
    {
        RELEASE_SPIN_LOCK(&pArapConn->SpinLock, OldIrql);
        ArapNdisFreeBuf(pMnpSendBuf);
        return;
    }

    // put MNPSend refcount
    pArapConn->RefCount++;

    RELEASE_SPIN_LOCK(&pArapConn->SpinLock, OldIrql);

    AtalkNdisBuildARAPHdr(pFrame, pArapConn);

    pFrame += WAN_LINKHDR_LEN;

    //
    // put the start flags
    //
    *pFrame++ = pArapConn->MnpState.SynByte;
    *pFrame++ = pArapConn->MnpState.DleByte;
    *pFrame++ = pArapConn->MnpState.StxByte;

    //
    // now, put the body of the Ack frame
    //
    *pFrame++ = 4;              // length indication
    *pFrame++ = 7;              // type indication
    *pFrame++ = 1;              // var type
    *pFrame++ = 1;              // var len
    *pFrame++ = LnSeqToAck;     //

    //
    // now finally, put the stop flags
    //
    *pFrame++ = pArapConn->MnpState.DleByte;
    *pFrame++ = pArapConn->MnpState.EtxByte;

    FrameLen = (USHORT)(pFrame - pFrameStart);

    AtalkSetSizeOfBuffDescData(&pMnpSendBuf->sb_BuffDesc, FrameLen);

    NdisAdjustBufferLength(pMnpSendBuf->sb_BuffHdr.bh_NdisBuffer,FrameLen);

    //
    // send the packet over.  We need to go directly, and not via ArapNdisSend
    // because this packet needs to be delivered just once, regardless of
    // whether send window is open
    //

    ndisPacket = pMnpSendBuf->sb_BuffHdr.bh_NdisPkt;

    NdisSend(&ndisStatus, RasPortDesc->pd_NdisBindingHandle, ndisPacket);

    // if there was a problem sending, call the completion routine here
    if (ndisStatus != NDIS_STATUS_PENDING)
    {
	    DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
            ("MnpSendLNAck: NdisSend failed %lx\n",ndisStatus));

	    ArapNdisSendComplete(ARAPERR_SEND_FAILED, (PBUFFER_DESC)pMnpSendBuf, NULL);
	}
}


//***
//
// Function: ArapSendLDPacket
//              This routine sends a Disconnect (LD) packet to the client
//
// Parameters:  pArapConn - the connection
//
// Return:      result of the operation
//
//***$

DWORD
ArapSendLDPacket(
    IN PARAPCONN    pArapConn,
    IN BYTE         UserCode
)
{
    PBYTE                   pFrame, pFrameStart;
    USHORT                  FrameLen;
    PNDIS_PACKET            ndisPacket;
    NDIS_STATUS             ndisStatus;
    PMNPSENDBUF             pMnpSendBuf;
    KIRQL                   OldIrql;
    DWORD                   StatusCode;


    DBG_ARAP_CHECK_PAGED_CODE();

    DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
        ("ArapSendLDPacket: sending DISCONNECT on %lx\n",pArapConn));

    StatusCode = ARAPERR_NO_ERROR;

    //
    // allocate buf to send out the disconnection request
    //
	if ((pMnpSendBuf = AtalkBPAllocBlock(BLKID_MNP_SMSENDBUF)) != NULL)
    {
        StatusCode = ArapGetNdisPacket(pMnpSendBuf);
    }

	if ((pMnpSendBuf == NULL) || (StatusCode != ARAPERR_NO_ERROR))
	{
        if (pMnpSendBuf)
        {
            ArapNdisFreeBuf(pMnpSendBuf);
        }
        else
        {
		    DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
			    ("ArapSendLDPacket: AtalkBPAllocBlock failed on %lx\n", pArapConn));
        }

		return(ARAPERR_OUT_OF_RESOURCES);
	}

#if DBG
    pMnpSendBuf->Signature = MNPSMSENDBUF_SIGNATURE;
    InitializeListHead(&pMnpSendBuf->Linkage);
#endif
    pMnpSendBuf->RetryCount = 0;  // not relevant here
    pMnpSendBuf->RefCount = 1;    // remove when send completes
    pMnpSendBuf->pArapConn = pArapConn;
    pMnpSendBuf->ComplRoutine = NULL;
    pMnpSendBuf->Flags = 1;

    ACQUIRE_SPIN_LOCK(&pArapConn->SpinLock, &OldIrql);

    //
    // if we are already disconnecting (say remote disconnected), just say ok
    //
    if (pArapConn->State >= MNP_LDISCONNECTING)
    {
		DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR, ("ArapSendLDPacket: silently \
             discarding disconnect (already in progress) %lx\n", pArapConn));

        RELEASE_SPIN_LOCK(&pArapConn->SpinLock, OldIrql);
        ArapNdisFreeBuf(pMnpSendBuf);
        return(ARAPERR_DISCONNECT_IN_PROGRESS);
    }

    // Disconnect refcount: protect pArapConn until disconnect is complete
    pArapConn->RefCount++;

    // put MNPSend refcount
    pArapConn->RefCount++;

    pArapConn->State = MNP_LDISCONNECTING;

    RELEASE_SPIN_LOCK(&pArapConn->SpinLock, OldIrql);

    pFrame = pFrameStart = &pMnpSendBuf->Buffer[0];

	AtalkNdisBuildARAPHdr(pFrame, pArapConn);

    pFrame += WAN_LINKHDR_LEN;

    //
    // put the start flags
    //
    *pFrame++ = pArapConn->MnpState.SynByte;
    *pFrame++ = pArapConn->MnpState.DleByte;
    *pFrame++ = pArapConn->MnpState.StxByte;

    //
    // now, put the body of the LD frame
    //
    *pFrame++ = 7;              // length indication
    *pFrame++ = 2;              // type indication for LD
    *pFrame++ = 1;              // var type
    *pFrame++ = 1;              // var len
    *pFrame++ = 0xFF;           // User-initiated disconnect

    *pFrame++ = 2;              // var type
    *pFrame++ = 1;              // var len
    *pFrame++ = UserCode;

    //
    // now finally, put the stop flags
    //
    *pFrame++ = pArapConn->MnpState.DleByte;
    *pFrame++ = pArapConn->MnpState.EtxByte;

    FrameLen = (USHORT)(pFrame - pFrameStart);

    AtalkSetSizeOfBuffDescData(&pMnpSendBuf->sb_BuffDesc, FrameLen);

	NdisAdjustBufferLength(pMnpSendBuf->sb_BuffHdr.bh_NdisBuffer,FrameLen);

    ARAP_SET_NDIS_CONTEXT(pMnpSendBuf, NULL);

    ndisPacket = pMnpSendBuf->sb_BuffHdr.bh_NdisPkt;

    // send the packet over (and don't bother checking return code!)
	NdisSend(&ndisStatus, RasPortDesc->pd_NdisBindingHandle, ndisPacket);

    // if there was a problem sending, call the completion routine here
    if (ndisStatus != NDIS_STATUS_PENDING)
    {
        DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
            ("ArapSendLDPacket: NdisSend failed %lx\n",ndisStatus));

        ArapNdisSendComplete(ARAPERR_SEND_FAILED, (PBUFFER_DESC)pMnpSendBuf, NULL);
    }

    // remove the disconnect refcount
    DerefArapConn(pArapConn);

    return(ARAPERR_NO_ERROR);
}


//***
//
// Function: ArapRetryTimer
//              This is the general purpose timer routine for ARAP.
//              It checks
//                  if the ack timer (LATimer) has expired (if yes, send ack)
//                  if the flowcontrol timer has expired (if yes, send ack)
//                  if the inactivity timer has expired (if yes, send ack)
//                  if the retransmit timer has expired (if yes, retransmit)
//
// Parameters:  pTimer            - the context for the timer that just fired
//              TimerShuttingDown - this is TRUE if timer is shutting down
//
// Return:      none
//
//***$

LONG FASTCALL
ArapRetryTimer(
	IN	PTIMERLIST			pTimer,
	IN	BOOLEAN				TimerShuttingDown
)
{

    PARAPCONN       pArapConn;
    PLIST_ENTRY     pList;
    PMNPSENDBUF     pMnpSendBuf;
    BOOLEAN         fRetransmit=FALSE;
    BOOLEAN         fMustSendAck = FALSE;
    BOOLEAN         fKill=FALSE;
    BOOLEAN         fMustFlowControl=FALSE;
    BOOLEAN         fInactiveClient=FALSE;
    LONG            CurrentTime;
    PIRP            pIrp=NULL;
	NTSTATUS		ReturnStatus=STATUS_SUCCESS;


    DBG_ARAP_CHECK_PAGED_CODE();

    pArapConn = CONTAINING_RECORD(pTimer, ARAPCONN, RetryTimer);

    ARAPTRACE(("Entered ArapRetryTimer (%lx)\n",pArapConn));

	ACQUIRE_SPIN_LOCK_DPC(&pArapConn->SpinLock);

    //
    // if the global timer is shutting down, or if the connection isn't in the
    // right state (e.g. it is disconnecting), then don't requeue the timer
    //
	if ( TimerShuttingDown ||
		(pArapConn->State <= MNP_IDLE) || (pArapConn->State > MNP_UP) )
	{
        pArapConn->Flags &= ~RETRANSMIT_TIMER_ON;

        RELEASE_SPIN_LOCK_DPC(&pArapConn->SpinLock);

        if (TimerShuttingDown)
        {
		    DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                ("ArapRetryTimer: timer shut down, killing conn (%lx)\n",pArapConn));

            ArapCleanup(pArapConn);
        }
        else
        {
		    DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                ("ArapRetryTimer: (%lx) invalid state (%d), not requeing timer\n",
                    pArapConn,pArapConn->State));
        }

        // remove the timer refcount
        DerefArapConn(pArapConn);

		return ATALK_TIMER_NO_REQUEUE;
	}

	CurrentTime = AtalkGetCurrentTick();

    //
    // has the 402 timer expired?  if yes, we must send an ack
    // (a value of 0 signifies that the 402 timer is not "running")
    //
    if ( (pArapConn->LATimer != 0) && (CurrentTime >= pArapConn->LATimer) )
    {
        //
        // make sure there is a receive that needs to be acked (if sent the ack
        // just before this timer fired, don't send the ack again)
        //
        if (pArapConn->MnpState.UnAckedRecvs)
        {
            fMustSendAck = TRUE;

		    DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                ("ArapRetryTimer: 402 timer fired, forcing ack out (%d, now %d)\n",
                    pArapConn->LATimer,CurrentTime));
        }
        else
        {
		    DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                ("ArapRetryTimer: saved on on ack (UnAckedRecvs = 0)\n",pArapConn));
        }
    }

    //
    // has the flow control timer "expired"?  If so, we must send an ack and
    // reset the timer
    // (a value of 0 signifies that the flow control timer is not "running")
    //
    else if ( (pArapConn->FlowControlTimer != 0) &&
              (CurrentTime >= pArapConn->FlowControlTimer) )
    {
		DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_INFO,
            ("ArapRetryTimer: flow-control timer, forcing ack (%d, now %d)\n",
                pArapConn->FlowControlTimer,CurrentTime));

        fMustFlowControl = TRUE;

        pArapConn->FlowControlTimer = CurrentTime + pArapConn->T404Duration;
    }

    //
    // if the client been inactive for a long time, we must tell dll
    //
    else if (CurrentTime >= pArapConn->InactivityTimer)
    {
        // first make sure we can get the select irp
        ArapGetSelectIrp(&pIrp);

        // if we managed to get a select irp, reset the timer so we don't keep
        // informing the dll after every tick after this point!
        //
        if (pIrp)
        {
            pArapConn->InactivityTimer = pArapConn->T403Duration + CurrentTime;

            fInactiveClient = TRUE;
        }
    }

    //
    // Has the retransmit timer expired?  If so, we need to retransmit
    //
    else
    {
        //
        // look at the first entry of the retransmit queue.  If it's time is up, do
        // the retransmit thing.  Otherwise, we are done.  (All others in the queue
        // will be retransmitted after this first one is acked, so ignore for now)
        //
        pList = pArapConn->RetransmitQ.Flink;

        // no entries on the retransmit queue?  we're done!
        if (pList == &pArapConn->RetransmitQ)
        {
    	    RELEASE_SPIN_LOCK_DPC(&pArapConn->SpinLock);
	        return ATALK_TIMER_REQUEUE;
        }

        pMnpSendBuf = CONTAINING_RECORD(pList, MNPSENDBUF, Linkage);

        // is it time to retransmit yet?
        if (CurrentTime >= pMnpSendBuf->RetryTime)
        {
            if (pMnpSendBuf->RetryCount >= ARAP_MAX_RETRANSMITS)
            {
                fKill = TRUE;
                RemoveEntryList(&pMnpSendBuf->Linkage);

                ASSERT(pArapConn->MnpState.UnAckedSends >= 1);

                // not really important, since we're about to disconnect!
                pArapConn->MnpState.UnAckedSends--;

                ASSERT(pArapConn->SendsPending >= pMnpSendBuf->DataSize);

                InitializeListHead(&pMnpSendBuf->Linkage);
            }
            else
            {
		        DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_INFO,
                    ("ArapRetryTimer: timer fired, retransmitting....%x (%ld now %ld)\n",
                        pMnpSendBuf->SeqNum,pMnpSendBuf->RetryTime,CurrentTime));

                if (pMnpSendBuf->RetryCount > 8)
                {
	                DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
		                ("ArapRetryTimer: buf %lx of %lx retransmitted %d times!\n",
                        pMnpSendBuf,pArapConn,pMnpSendBuf->RetryCount));
                }

                pArapConn->MnpState.RetransmitMode = TRUE;
                pArapConn->MnpState.MustRetransmit = TRUE;

                fRetransmit = TRUE;
            }
        }
    }

	RELEASE_SPIN_LOCK_DPC(&pArapConn->SpinLock);

    // force an ack out (that's what TRUE does)
    if (fMustSendAck || fMustFlowControl)
    {
        MnpSendAckIfReqd(pArapConn, TRUE);
    }

    // if we must retransmit, go for it.
    //
    else if (fRetransmit)
    {
        ArapNdisSend(pArapConn, &pArapConn->RetransmitQ);
    }

    //
    // if we retransmitted too many times, let the completion routine know.
    // (it will probably kill the connection)
    //
    else if (fKill)
    {
	    DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
		    ("ArapRetryTimer: too many retransmits (%lx), disconnecting %lx\n",
                pMnpSendBuf,pArapConn));

        (pMnpSendBuf->ComplRoutine)(pMnpSendBuf, ARAPERR_SEND_FAILED);
    }

    //
    // if the connection has been inactive for longer than the limit (given to
    // us by the dll), then tell dll about it
    //
    else if (fInactiveClient)
    {
        PARAP_SEND_RECV_INFO    pSndRcvInfo;

	    DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
		    ("ArapRetryTimer: (%lx) inactive, telling dll (%lx)\n",pArapConn, pIrp));

        ASSERT(pIrp != NULL);

        pSndRcvInfo = (PARAP_SEND_RECV_INFO)pIrp->AssociatedIrp.SystemBuffer;

        pSndRcvInfo->pDllContext = pArapConn->pDllContext;
        pSndRcvInfo->AtalkContext = pArapConn;
        pSndRcvInfo->StatusCode = ARAPERR_CONN_INACTIVE;

        ARAP_COMPLETE_IRP(pIrp, sizeof(ARAP_SEND_RECV_INFO), STATUS_SUCCESS, &ReturnStatus);
		return ReturnStatus;
    }

	return ATALK_TIMER_REQUEUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\atalk\sys\araputil.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	araputil.c

Abstract:

	This module implements utility routines needed for the ARAP functionality

Author:

	Shirish Koti

Revision History:
	15 Nov 1996		Initial Version

--*/

#include 	<atalk.h>
#pragma hdrstop

//	File module number for errorlogging
#define	FILENUM		ARAPUTIL

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE_ARAP, DerefMnpSendBuf)
#pragma alloc_text(PAGE_ARAP, DerefArapConn)
#pragma alloc_text(PAGE_ARAP, ArapReleaseAddr)
#pragma alloc_text(PAGE_ARAP, ArapCleanup)
#pragma alloc_text(PAGE_ARAP, PrepareConnectionResponse)
#pragma alloc_text(PAGE_ARAP, ArapExtractAtalkSRP)
#pragma alloc_text(PAGE_ARAP, ArapQueueSendBytes)
#pragma alloc_text(PAGE_ARAP, ArapGetSendBuf)
#pragma alloc_text(PAGE_ARAP, ArapRefillSendQ)
#endif

//***
//
// Function: AllocArapConn
//              Allocate a connection element and initialize fields
//
// Parameters:  none
//
// Return:      pointer to a newly allocated connection element
//
//***$

PARAPCONN
AllocArapConn(
    IN ULONG    LinkSpeed
)
{

    PARAPCONN               pArapConn;
    v42bis_connection_t    *pV42bis;
    PUCHAR                  pBuf;
    LONG                    RetryTime;



    if ( (pArapConn = AtalkAllocZeroedMemory(sizeof(ARAPCONN))) == NULL)
    {
		DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR, ("AllocArapConn: alloc failed\n"));

        return(NULL);
    }

    //
    // allocate v42bis buffers (it v42bis is enabled that is)
    //
    if (ArapGlobs.V42bisEnabled)
    {
        pV42bis = AtalkAllocZeroedMemory(sizeof(v42bis_connection_t));

        if (pV42bis == NULL)
        {
		    DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                ("AllocArapConn: alloc for v42 failed\n"));

            AtalkFreeMemory(pArapConn);

            return(NULL);
        }

        //
        // allocate overflow buffer for the decode side
        //
        if ((pBuf = AtalkAllocZeroedMemory(MAX_P2)) == NULL)
        {
		    DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                ("AllocArapConn: alloc for v42-2 failed\n"));

            AtalkFreeMemory(pArapConn);

            AtalkFreeMemory(pV42bis);

            return(NULL);
        }

        pV42bis->decode.OverFlowBuf = pBuf;
        pV42bis->decode.OverFlowBytes = 0;

        pV42bis->encode.OverFlowBuf = pBuf;
        pV42bis->encode.OverFlowBytes = 0;

        pArapConn->pV42bis = pV42bis;
    }

    //
    // if v42bis is not enabled, don't need no buffers!
    //
    else
    {
        pArapConn->pV42bis = NULL;
    }


#if DBG
    pArapConn->Signature = ARAPCONN_SIGNATURE;

    //
    // for debug builds, we can set registry parm to keep a trace of events
    // If that setting is enabled, alloc a buffer to store the trace
    //
    if (ArapGlobs.SniffMode)
    {
        pBuf = AtalkAllocZeroedMemory(ARAP_SNIFF_BUFF_SIZE);
        if (pBuf == NULL)
        {
		    DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                ("AllocArapConn: alloc for trace buffer failed\n"));

            // don't fail the call if this alloc fails
        }

        pArapConn->pDbgTraceBuffer = pArapConn->pDbgCurrPtr = pBuf;

        // put in a guard signature, to catch overrun
        if (pArapConn->pDbgTraceBuffer)
        {
            *((DWORD *)&(pArapConn->pDbgTraceBuffer[ARAP_SNIFF_BUFF_SIZE-4])) = 0xcafebeef;
        }
    }
#endif

    pArapConn->State = MNP_IDLE;

    // Creation refcount and a line-up refcount
    pArapConn->RefCount = 2;

    pArapConn->MnpState.WindowSize = ArapGlobs.MaxLTFrames;
    pArapConn->MnpState.RecvCredit = pArapConn->MnpState.WindowSize;

    pArapConn->LinkSpeed = LinkSpeed;

    //
    // T401 timer value in tick counts (1 tick = 100ms).
    // we'll keep this at 1 second (i.e. 10 ticks) for a 33.6 (and faster) modem.
    // If we are on a slower modem, increase it proportionately.  So, a 28.8 modem
    // would get RetryTime=2.0sec, 14.4 would get 3.7sec, 9600 baud would get 4.2sec etc.
    //
    RetryTime = 15;
    if (LinkSpeed < 336)
    {
        RetryTime += (((336 - LinkSpeed) + 5)/10);
    }

    // make sure our calculation didn't go haywire...

    if (RetryTime < ARAP_MIN_RETRY_INTERVAL)
    {
        RetryTime = ARAP_MIN_RETRY_INTERVAL;
    }
    else if (RetryTime > ARAP_MAX_RETRY_INTERVAL)
    {
        RetryTime = ARAP_MAX_RETRY_INTERVAL;
    }

    pArapConn->SendRetryTime = RetryTime;
    pArapConn->SendRetryBaseTime = RetryTime;

    // T402 is 0.5 times T401 value
    pArapConn->T402Duration = (pArapConn->SendRetryTime/2);

    //
    // T403 should be at least 59 seconds.  We don't really kill after this
    // period of inactivity.  We simply tell the dll and it does whatever is the
    // policy: so just use whatever time period the dll tells us
    //
    pArapConn->T403Duration = ArapGlobs.MnpInactiveTime;

    //
    // T404: spec says 3 sec for 2400 baud and faster, 7 sec for anything slower
    // Let's use 4 seconds here
    //
    pArapConn->T404Duration = 30;

    // initialize all the timer values
    pArapConn->LATimer = 0;
    pArapConn->InactivityTimer = pArapConn->T403Duration + AtalkGetCurrentTick();

    // set this to a high value for now: we'll set it when the conn is up
    pArapConn->FlowControlTimer = AtalkGetCurrentTick() + 36000;

    InitializeListHead(&pArapConn->MiscPktsQ);
    InitializeListHead(&pArapConn->ReceiveQ);
    InitializeListHead(&pArapConn->ArapDataQ);
    InitializeListHead(&pArapConn->RetransmitQ);
    InitializeListHead(&pArapConn->HighPriSendQ);
    InitializeListHead(&pArapConn->MedPriSendQ);
    InitializeListHead(&pArapConn->LowPriSendQ);
    InitializeListHead(&pArapConn->SendAckedQ);

    INITIALIZE_SPIN_LOCK(&pArapConn->SpinLock);

    // start the retransmit timer for this connection
    AtalkTimerInitialize( &pArapConn->RetryTimer,
                          (TIMER_ROUTINE)ArapRetryTimer,
                          ARAP_TIMER_INTERVAL) ;

    AtalkTimerScheduleEvent(&pArapConn->RetryTimer);

    pArapConn->Flags |= RETRANSMIT_TIMER_ON;

    // put a timer refcount
    pArapConn->RefCount++;

    return( pArapConn );
}


//***
//
// Function: ArapAcceptIrp
//              Determine if the irp submitted by the dll is acceptable now
//
// Parameters:  pIrp  - the incoming irp
//              IoControlCode - the control code (what's the irp for?)
//              pfDerefDefPort - was default adapter referenced?
//
// Return:      TRUE if the irp is acceptable, FALSE otherwise
//
//***$

BOOLEAN
ArapAcceptIrp(
    IN PIRP     pIrp,
    IN ULONG    IoControlCode,
    IN BOOLEAN  *pfDerefDefPort
)
{

    KIRQL                   OldIrql;
    PARAP_SEND_RECV_INFO    pSndRcvInfo=NULL;
    PARAPCONN               pArapConn;
    BOOLEAN                 fAccept=FALSE;
    BOOLEAN                 fUnblockPnP=FALSE;


    *pfDerefDefPort = FALSE;

    //
    // we allow these ioctls to come in any time
    //
    if ((IoControlCode == IOCTL_ARAP_SELECT) ||
        (IoControlCode == IOCTL_ARAP_DISCONNECT) ||
        (IoControlCode == IOCTL_ARAP_CONTINUE_SHUTDOWN) )
    {
        return(TRUE);
    }


    pSndRcvInfo = (PARAP_SEND_RECV_INFO)pIrp->AssociatedIrp.SystemBuffer;

    pArapConn = pSndRcvInfo->AtalkContext;

    //
    // put a IrpProcess refcount on the default port so it won't go away via pnp etc.
    //
    if (!AtalkReferenceRasDefPort())
    {
        DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
            ("ArapProcessIoctl: Default port gone, or going %lx not accepted (%lx)\n",
            pIrp,IoControlCode));

        pSndRcvInfo->StatusCode = ARAPERR_STACK_IS_NOT_ACTIVE;
        return(FALSE);
    }

    // note the fact that we have referenced the default adapter
    *pfDerefDefPort = TRUE;

    //
    // now it's simple to decide whether we want to accept this irp or not
    //

    ACQUIRE_SPIN_LOCK(&ArapSpinLock, &OldIrql);

    fAccept = (ArapStackState == ARAP_STATE_ACTIVE) ? TRUE : FALSE;

    RELEASE_SPIN_LOCK(&ArapSpinLock, OldIrql);

    return(fAccept);
}

//***
//
// Function: ArapCancelIrp
//              Cancel the irp.  Currently, only select irps are cancellable
//
// Parameters:  pIrp  - the incoming irp
//
// Return:      none
//
//***$
VOID
ArapCancelIrp(
    IN  PIRP    pIrp
)
{

    KIRQL           OldIrql;
    PLIST_ENTRY     pList;
    PARAPCONN       pArapConn;
	NTSTATUS		ReturnStatus=STATUS_SUCCESS;


    //
    // kill all connections and don't accept any more irps:
    // cancelling a select irp is a blasphemy!
    //

    ACQUIRE_SPIN_LOCK(&ArapSpinLock, &OldIrql);

    if (ArapSelectIrp == NULL)
    {
	    DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,("ArapCancelIrp: weird race condition!\n"));
        RELEASE_SPIN_LOCK(&ArapSpinLock, OldIrql);
        return;
    }

    ASSERT (pIrp == ArapSelectIrp);

    ArapSelectIrp = NULL;

    if (ArapStackState == ARAP_STATE_ACTIVE)
    {
        ArapStackState = ARAP_STATE_ACTIVE_WAITING;
    }
    else if (ArapStackState == ARAP_STATE_INACTIVE)
    {
        ArapStackState = ARAP_STATE_INACTIVE_WAITING;
    }

    RELEASE_SPIN_LOCK(&ArapSpinLock, OldIrql);

    if (RasPortDesc == NULL)
    {
	    DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,("ArapCancelIrp: RasPortDesc is null!\n"));

        ARAP_COMPLETE_IRP(pIrp, 0, STATUS_CANCELLED, &ReturnStatus);
        return;
    }

    //
    // now, go kill all the arap connections
    //
    ACQUIRE_SPIN_LOCK(&RasPortDesc->pd_Lock, &OldIrql);

    pList = RasPortDesc->pd_ArapConnHead.Flink;

    while (pList != &RasPortDesc->pd_ArapConnHead)
    {
        pArapConn = CONTAINING_RECORD(pList, ARAPCONN, Linkage);

        ASSERT(pArapConn->Signature == ARAPCONN_SIGNATURE);

        // if this connection is already disconnected, skip it
        ACQUIRE_SPIN_LOCK_DPC(&pArapConn->SpinLock);
        if (pArapConn->State == MNP_DISCONNECTED)
        {
            pList = pArapConn->Linkage.Flink;
            RELEASE_SPIN_LOCK_DPC(&pArapConn->SpinLock);
            continue;
        }

        RELEASE_SPIN_LOCK_DPC(&pArapConn->SpinLock);
        RELEASE_SPIN_LOCK(&RasPortDesc->pd_Lock, OldIrql);

	    DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
	        ("ArapCancelIrp: killing ARAP connection %lx\n",pArapConn));

        ArapCleanup(pArapConn);

        ACQUIRE_SPIN_LOCK(&RasPortDesc->pd_Lock, &OldIrql);

        pList = RasPortDesc->pd_ArapConnHead.Flink;
    }

    //
    // walk through the list to see if any connection(s) disconnected but is
    // waiting for a select irp to come down.  We know the select irp is never
    // going to come down, so pretend that dll has been told and deref the puppy
    // for telling the dll (which will probably free the connection)
    //

    pList = RasPortDesc->pd_ArapConnHead.Flink;

    while (pList != &RasPortDesc->pd_ArapConnHead)
    {
        pArapConn = CONTAINING_RECORD(pList, ARAPCONN, Linkage);

        ASSERT(pArapConn->Signature == ARAPCONN_SIGNATURE);

        ACQUIRE_SPIN_LOCK_DPC(&pArapConn->SpinLock);

        if (pArapConn->Flags & DISCONNECT_NO_IRP)
        {
            pArapConn->Flags &= ~DISCONNECT_NO_IRP;

            RELEASE_SPIN_LOCK_DPC(&pArapConn->SpinLock);
            RELEASE_SPIN_LOCK(&RasPortDesc->pd_Lock, OldIrql);

	        DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
    	        ("ArapCancelIrp: faking dll-completion for dead connection %lx\n",pArapConn));

            DerefArapConn(pArapConn);

            ACQUIRE_SPIN_LOCK(&RasPortDesc->pd_Lock, &OldIrql);
            pList = RasPortDesc->pd_ArapConnHead.Flink;
        }
        else
        {
            pList = pArapConn->Linkage.Flink;
            RELEASE_SPIN_LOCK_DPC(&pArapConn->SpinLock);
        }
    }

    RELEASE_SPIN_LOCK(&RasPortDesc->pd_Lock, OldIrql);

    // finally, complete that cancelled irp!
    ARAP_COMPLETE_IRP(pIrp, 0, STATUS_CANCELLED, &ReturnStatus);

	DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
	    ("ArapCancelIrp: select irp cancelled and completed (%lx)\n",pIrp));
}



//***
//
// Function: ArapGetSelectIrp
//              Get the select irp, after some checks
//
// Parameters:  ppIrp  - pointer to irp pointer, contains select irp on return
//
// Return:      none
//
//***$
VOID
ArapGetSelectIrp(
    IN  PIRP    *ppIrp
)
{
    KIRQL   OldIrql;
    KIRQL   OldIrql2;


    *(ppIrp) = NULL;

	IoAcquireCancelSpinLock(&OldIrql);

    ACQUIRE_SPIN_LOCK(&ArapSpinLock, &OldIrql2);

    if (ArapSelectIrp && (!ArapSelectIrp->Cancel))
    {
        ArapSelectIrp->CancelRoutine = NULL;
        *(ppIrp) = ArapSelectIrp;
        ArapSelectIrp = NULL;
    }

    RELEASE_SPIN_LOCK(&ArapSpinLock, OldIrql2);

	IoReleaseCancelSpinLock(OldIrql);
}



//***
//
// Function: FindArapConnByContx
//              Finds the corresponding connection element, given the dll's
//              context
//
// Parameters:  pDllContext - the dll context for the connection
//
// Return:      pointer to the corresponding connection element, if found
//
//***$

PARAPCONN
FindArapConnByContx(
    IN  PVOID   pDllContext
)
{
    PARAPCONN    pArapConn=NULL;
    PARAPCONN    pWalker;
    PLIST_ENTRY  pList;
    KIRQL        OldIrql;


    // ARAP not configured?
    if (!RasPortDesc)
    {
        return(NULL);
    }

    ACQUIRE_SPIN_LOCK(&RasPortDesc->pd_Lock, &OldIrql);

    if (!(RasPortDesc->pd_Flags & PD_ACTIVE))
    {
		DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
		    ("FindArapConnByContx: ArapPort not active, ignoring\n"));
			
        RELEASE_SPIN_LOCK(&RasPortDesc->pd_Lock, OldIrql);
        return(NULL);
    }

    pList = RasPortDesc->pd_ArapConnHead.Flink;

    //
    // walk through all the Arap clients to see if we find ours
    //
    while (pList != &RasPortDesc->pd_ArapConnHead)
    {
        pWalker = CONTAINING_RECORD(pList, ARAPCONN, Linkage);

        pList = pWalker->Linkage.Flink;

        if (pWalker->pDllContext == pDllContext)
        {
            pArapConn = pWalker;
            break;
        }
    }

    RELEASE_SPIN_LOCK(&RasPortDesc->pd_Lock, OldIrql);

    return( pArapConn );
}


//***
//
// Function: FindAndRefArapConnByAddr
//              Finds the corresponding connection element, given the network
//              address (of the remote client)
//
// Parameters:  destNode - network addr of the destination (remote client)
//              pdwFlags - pointer to a dword to return Flags field
//
// Return:      pointer to the corresponding connection element, if found
//
//***$

PARAPCONN
FindAndRefArapConnByAddr(
    IN  ATALK_NODEADDR      destNode,
    OUT DWORD              *pdwFlags
)
{
    PARAPCONN    pArapConn=NULL;
    PARAPCONN    pWalker;
    PLIST_ENTRY  pList;
    KIRQL        OldIrql;


    // ARAP not configured?
    if (!RasPortDesc)
    {
        return(NULL);
    }

    ACQUIRE_SPIN_LOCK(&RasPortDesc->pd_Lock, &OldIrql);

    if (!(RasPortDesc->pd_Flags & PD_ACTIVE))
    {
		DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
		    ("FindAndRefArapConnByAddr: ArapPort not active, ignoring\n"));
			
        RELEASE_SPIN_LOCK(&RasPortDesc->pd_Lock, OldIrql);
        return(NULL);
    }

    pList = RasPortDesc->pd_ArapConnHead.Flink;

    //
    // walk through all the Arap clients to see if we find ours
    //
    while (pList != &RasPortDesc->pd_ArapConnHead)
    {
        pWalker = CONTAINING_RECORD(pList, ARAPCONN, Linkage);

        pList = pWalker->Linkage.Flink;

        if (ATALK_NODES_EQUAL(&pWalker->NetAddr, &destNode))
        {
            ACQUIRE_SPIN_LOCK_DPC(&pWalker->SpinLock);

            //
            // we return the pArapConn only if the MNP connection is up and
            // and the ARAP connection is also up (or, if ARAP connection isn't
            // up yet then only if we are searching for a node)
            //
            //
            if ((pWalker->State == MNP_UP) &&
                ((pWalker->Flags & ARAP_CONNECTION_UP) ||
                  (pWalker->Flags & ARAP_FINDING_NODE)) )
            {
                pArapConn = pWalker;
                pArapConn->RefCount++;
                *pdwFlags = pWalker->Flags;
            }
            else if (pWalker->Flags & ARAP_CONNECTION_UP)
            {
				DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
				    ("FindAndRefArapConnByAddr: found pArapConn (%lx), but state=%ld,Flags=%lx\n",
						pWalker,pWalker->State,pWalker->Flags));
            }

            RELEASE_SPIN_LOCK_DPC(&pWalker->SpinLock);

            break;
        }
    }

    RELEASE_SPIN_LOCK(&RasPortDesc->pd_Lock, OldIrql);

    return(pArapConn);

}

//***
//
// Function: FindAndRefRasConnByAddr
//              Finds the corresponding connection element, given the network
//              address (of the remote client)
//
// Parameters:  destNode - network addr of the destination (remote client)
//              pdwFlags - pointer to a dword to return Flags field
//              pfThisIsPPP - pointer to a bool: is this PPP or ARAP connection?
//
// Return:      pointer to the corresponding connection element, if found
//
//***$

PVOID
FindAndRefRasConnByAddr(
    IN  ATALK_NODEADDR      destNode,
    OUT DWORD              *pdwFlags,
    OUT BOOLEAN            *pfThisIsPPP
)
{
    PVOID        pRasConn;


    // RAS not configured?
    if (!RasPortDesc)
    {
        return(NULL);
    }

    pRasConn = (PVOID)FindAndRefPPPConnByAddr(destNode,pdwFlags);

    if (pRasConn)
    {
        *pfThisIsPPP = TRUE;
        return(pRasConn);
    }

    pRasConn = FindAndRefArapConnByAddr(destNode, pdwFlags);

    *pfThisIsPPP = FALSE;

    return(pRasConn);

}


//***
//
// Function: ArapConnIsValid
//              Make sure that what we think is a connection is indeed a
//              connection (i.e., it's there in our list of connections)
//
// Parameters:  pArapConn -  the connection in question
//
// Return:      TRUE if the connection is valid, FALSE otherwise
//
//***$

BOOLEAN
ArapConnIsValid(
    IN  PARAPCONN  pArapConn
)
{
    PARAPCONN    pWalker;
    PLIST_ENTRY  pList;
    KIRQL        OldIrql;
    BOOLEAN      fIsValid=FALSE;


    // ARAP not configured?
    if (!RasPortDesc)
    {
        return(FALSE);
    }

    ACQUIRE_SPIN_LOCK(&RasPortDesc->pd_Lock, &OldIrql);

    pList = RasPortDesc->pd_ArapConnHead.Flink;

    //
    // walk through all the Arap conns and see if we find the given conn
    //
    while (pList != &RasPortDesc->pd_ArapConnHead)
    {
        pWalker = CONTAINING_RECORD(pList, ARAPCONN, Linkage);

        pList = pWalker->Linkage.Flink;

        if (pWalker == pArapConn)
        {
            ACQUIRE_SPIN_LOCK_DPC(&pWalker->SpinLock);

            ASSERT(pWalker->Signature == ARAPCONN_SIGNATURE);

            if (!(pWalker->Flags & ARAP_GOING_AWAY))
            {
                // put a validation refcount
                pWalker->RefCount++;

                fIsValid = TRUE;
            }

            RELEASE_SPIN_LOCK_DPC(&pWalker->SpinLock);

            break;
        }
    }

    RELEASE_SPIN_LOCK(&RasPortDesc->pd_Lock, OldIrql);

    return( fIsValid );
}




//***
//
// Function: DerefMnpSendBuf
//              This routine dereferences the MNP send.  When the refcount
//              goes to zero, we free it
//
// Parameters:  pMnpSendBuf - the MNP send to be dereferenced
//
// Return:      Nothing
//
//***$

VOID
DerefMnpSendBuf(
    IN PMNPSENDBUF   pMnpSendBuf,
    IN BOOLEAN       fNdisSendComplete
)
{
    KIRQL           OldIrql;
    PARAPCONN       pArapConn;
    BOOLEAN         fFreeIt=FALSE;


    DBG_ARAP_CHECK_PAGED_CODE();

    pArapConn = pMnpSendBuf->pArapConn;

    ARAPTRACE(("Entered DerefMnpSendBuf (%lx %lx refcount=%d ComplFn=%lx)\n",
        pArapConn,pMnpSendBuf,pMnpSendBuf->RefCount,pMnpSendBuf->ComplRoutine));

    ACQUIRE_SPIN_LOCK(&pArapConn->SpinLock, &OldIrql);

    //
    // catch weird things like freeing twice
    // (we subtract 0x100 in completion routine, to mark that it has run)
    //
    ASSERT((pMnpSendBuf->Signature == MNPSMSENDBUF_SIGNATURE) ||
           (pMnpSendBuf->Signature == MNPSMSENDBUF_SIGNATURE-0x100) ||
           (pMnpSendBuf->Signature == MNPLGSENDBUF_SIGNATURE) ||
           (pMnpSendBuf->Signature == MNPLGSENDBUF_SIGNATURE-0x100));

    ASSERT(pMnpSendBuf->RefCount > 0);

    // Mark that Ndis completed our send
    if (fNdisSendComplete)
    {
        pMnpSendBuf->Flags = 0;
    }

    pMnpSendBuf->RefCount--;

    if (pMnpSendBuf->RefCount == 0)
    {
        fFreeIt = TRUE;
    }

    RELEASE_SPIN_LOCK(&pArapConn->SpinLock, OldIrql);

    if (!fFreeIt)
    {
        return;
    }

    // make sure it's not still sitting on retransmit queue
    ASSERT(IsListEmpty(&pMnpSendBuf->Linkage));

#if DBG
    pMnpSendBuf->Signature--;
#endif

    ArapNdisFreeBuf(pMnpSendBuf);

    // remove that MNPSend refcount
    DerefArapConn(pArapConn);
}



//***
//
// Function: DerefArapConn
//              Decrements the refcount of the connection element by 1.  If the
//              refcount goes to 0, releases network addr and frees it
//
// Parameters:  pArapConn - connection element in question
//
// Return:      none
//
//***$

VOID
DerefArapConn(
	IN	PARAPCONN    pArapConn
)
{

    KIRQL       OldIrql;
    BOOLEAN     fKill = FALSE;


    DBG_ARAP_CHECK_PAGED_CODE();

    ARAPTRACE(("Entered DerefArapConn (%lx refcount=%d)\n",pArapConn,pArapConn->RefCount));

    ACQUIRE_SPIN_LOCK(&pArapConn->SpinLock, &OldIrql);

    ASSERT(pArapConn->Signature == ARAPCONN_SIGNATURE);

    ASSERT(pArapConn->RefCount > 0);

    pArapConn->RefCount--;

    if (pArapConn->RefCount == 0)
    {
        fKill = TRUE;
        pArapConn->Flags |= ARAP_GOING_AWAY;
    }

    RELEASE_SPIN_LOCK(&pArapConn->SpinLock, OldIrql);

    if (!fKill)
    {
        return;
    }

    ASSERT(pArapConn->pRecvIoctlIrp == NULL);

    ASSERT(pArapConn->pIoctlIrp == NULL);

    ASSERT(IsListEmpty(&pArapConn->HighPriSendQ));

    ASSERT(IsListEmpty(&pArapConn->MedPriSendQ));

    ASSERT(IsListEmpty(&pArapConn->LowPriSendQ));

    ASSERT(IsListEmpty(&pArapConn->SendAckedQ));

    ASSERT(IsListEmpty(&pArapConn->ReceiveQ));

    ASSERT(IsListEmpty(&pArapConn->ArapDataQ));

    ASSERT(IsListEmpty(&pArapConn->RetransmitQ));

    /* ASSERT(pArapConn->SendsPending == 0); */

    ASSERT(!(pArapConn->Flags & RETRANSMIT_TIMER_ON));

	DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
        ("DerefArapConn: refcount 0, freeing %lx\n", pArapConn));


    ACQUIRE_SPIN_LOCK(&RasPortDesc->pd_Lock, &OldIrql);

    RemoveEntryList(&pArapConn->Linkage);

    RELEASE_SPIN_LOCK(&RasPortDesc->pd_Lock, OldIrql);

#if ARAP_STATIC_MODE
    // "release" the network addr used by this client
    ArapReleaseAddr(pArapConn);
#endif //ARAP_STATIC_MODE

    // free that v42bis buffer
    if (pArapConn->pV42bis)
    {
        // free the decode-side overflow buffer
        AtalkFreeMemory(pArapConn->pV42bis->decode.OverFlowBuf);

        AtalkFreeMemory(pArapConn->pV42bis);
    }

#if DBG

    ArapDbgDumpMnpHist(pArapConn);

    // if we had allocated a sniff buffer, free it
    if (pArapConn->pDbgTraceBuffer)
    {
        AtalkFreeMemory(pArapConn->pDbgTraceBuffer);
    }

    //
    // let's catch if someone tries to access this after a free
    //
    RtlFillMemory(pArapConn,sizeof(ARAPCONN),0x7);
    pArapConn->Signature = 0xDEADBEEF;
#endif

    // and finally, we say good bye
    AtalkFreeMemory(pArapConn);


    ACQUIRE_SPIN_LOCK(&ArapSpinLock, &OldIrql);
    ArapConnections--;
    RELEASE_SPIN_LOCK(&ArapSpinLock, OldIrql);

#if ARAP_STATIC_MODE
    // This will delete a route if this is the last connection that vanished
    ArapDeleteArapRoute();
#endif //ARAP_STATIC_MODE

    // connection is completely gone: see if arap pages can be unlocked
    AtalkUnlockArapIfNecessary();

}


//***
//
// Function: ArapCleanup
//              Once the client goes into the disconnecting state (as a result
//              of either local side or remote side initiating the disconnect)
//              this routine gets called.  This does all the cleanup, such as
//              completing all unacked sends, uncompleted receives, stopping
//              retransmit timers, completing any irp in progress.
//
// Parameters:  pArapConn - connection element being cleaned up
//
// Return:      none
//
//***$

VOID
ArapCleanup(
    IN PARAPCONN    pArapConn
)
{

    KIRQL                   OldIrql;
    PIRP                    pIrp;
    PIRP                    pRcvIrp;
    PIRP                    pDiscIrp;
    PARAP_SEND_RECV_INFO    pSndRcvInfo;
    PARAP_SEND_RECV_INFO    pDiscSndRcvInfo;
    PLIST_ENTRY             pSendHighList;
    PLIST_ENTRY             pSendMedList;
    PLIST_ENTRY             pSendLowList;
    PLIST_ENTRY             pSendAckList;
    PLIST_ENTRY             pRcvList;
    PLIST_ENTRY             pArapList;
    PLIST_ENTRY             pReXmitList;
    PLIST_ENTRY             pMiscPktList;
    PMNPSENDBUF             pMnpSendBuf;
    PARAPBUF                pArapBuf;
    DWORD                   StatusCode;
    BOOLEAN                 fStopTimer=FALSE;
    BOOLEAN                 fArapConnUp=FALSE;
    DWORD                   dwBytesToDll;
	NTSTATUS				ReturnStatus=STATUS_SUCCESS;



    DBG_ARAP_CHECK_PAGED_CODE();

    // first thing, see if we should send out a disconnect message
    // we make this check without holding the lock because ArapSendLDPacket does
    // the right thing.  If, due to an extremely tiny window, we don't call
    // ArapSendLDPacket, no big deal!
    if (pArapConn->State < MNP_LDISCONNECTING)
    {
        ArapSendLDPacket(pArapConn, 0xFF);
    }

    ACQUIRE_SPIN_LOCK(&pArapConn->SpinLock, &OldIrql);

    ASSERT(pArapConn->Signature == ARAPCONN_SIGNATURE);

    // if we have already run the cleanup, nothing to do!
    if (pArapConn->State == MNP_DISCONNECTED)
    {
	    DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
            ("ArapCleanup: cleanup already done once on (%lx)\n",pArapConn));

        RELEASE_SPIN_LOCK(&pArapConn->SpinLock, OldIrql);
        return;
    }

    pSendHighList = pArapConn->HighPriSendQ.Flink;
    InitializeListHead(&pArapConn->HighPriSendQ);

    pSendMedList = pArapConn->MedPriSendQ.Flink;
    InitializeListHead(&pArapConn->MedPriSendQ);

    pSendLowList = pArapConn->LowPriSendQ.Flink;
    InitializeListHead(&pArapConn->LowPriSendQ);

    pSendAckList = pArapConn->SendAckedQ.Flink;
    InitializeListHead(&pArapConn->SendAckedQ);

    pRcvList = pArapConn->ReceiveQ.Flink;
    InitializeListHead(&pArapConn->ReceiveQ);

    pArapList = pArapConn->ArapDataQ.Flink;
    InitializeListHead(&pArapConn->ArapDataQ);

    pReXmitList = pArapConn->RetransmitQ.Flink;
    InitializeListHead(&pArapConn->RetransmitQ);

    pMiscPktList = pArapConn->MiscPktsQ.Flink;
    InitializeListHead(&pArapConn->MiscPktsQ);

    pIrp = pArapConn->pIoctlIrp;
    pArapConn->pIoctlIrp = NULL;

    pRcvIrp = pArapConn->pRecvIoctlIrp;
    pArapConn->pRecvIoctlIrp = NULL;

    if (pArapConn->State == MNP_RDISCONNECTING)
    {
        pArapConn->Flags |= ARAP_REMOTE_DISCONN;
        StatusCode = ARAPERR_RDISCONNECT_COMPLETE;
    }
    else
    {
        StatusCode = ARAPERR_LDISCONNECT_COMPLETE;
    }

    pArapConn->State = MNP_DISCONNECTED;
    pArapConn->Flags &= ~ARAP_DATA_WAITING;

    // if the timer is running, stop it
    if (pArapConn->Flags & RETRANSMIT_TIMER_ON)
    {
        fStopTimer = TRUE;
        pArapConn->Flags &= ~RETRANSMIT_TIMER_ON;

        // creation refcount and timer refcount better be on here
        ASSERT(pArapConn->RefCount >= 2);
    }

    fArapConnUp = FALSE;

    // was ARAP connection up?
    if (pArapConn->Flags & ARAP_CONNECTION_UP)
    {
        fArapConnUp = TRUE;
    }

#if DBG
    //
    // if we are sniffing, mark the sniff to indicate the end (so dll knows it
    // got all the sniff info)
    //
    if (pArapConn->pDbgCurrPtr)
    {
        PSNIFF_INFO     pSniff;

        pSniff = (PSNIFF_INFO)(pArapConn->pDbgCurrPtr);
        pSniff->Signature = ARAP_SNIFF_SIGNATURE;
        pSniff->TimeStamp = (DWORD)AtalkGetCurrentTick();
        pSniff->Location = 0xfedc;
        pSniff->FrameLen = 0;
        pArapConn->SniffedBytes += sizeof(SNIFF_INFO);
        pArapConn->pDbgCurrPtr += sizeof(SNIFF_INFO);
    }
#endif

    RELEASE_SPIN_LOCK(&pArapConn->SpinLock, OldIrql);

    if (fStopTimer)
    {
        if (AtalkTimerCancelEvent(&pArapConn->RetryTimer, NULL))
        {
            // remove the timer refcount
            DerefArapConn(pArapConn);
        }
    }

    //
    // call completion routine for all the sends that have been acked
    //
    while (pSendAckList != &pArapConn->SendAckedQ)
    {
        pMnpSendBuf = CONTAINING_RECORD(pSendAckList,MNPSENDBUF,Linkage);

        pSendAckList = pSendAckList->Flink;

#if DBG
        InitializeListHead(&pMnpSendBuf->Linkage);
#endif
        // call the completion routine which will do cleanup for this buffer
        (pMnpSendBuf->ComplRoutine)(pMnpSendBuf,ARAPERR_NO_ERROR);
    }

    // whatever is on the ReceiveQ, try and send it off to the destination
    // since this data came before the disconnect came in

    while (1)
    {
        if ((pArapBuf = ArapExtractAtalkSRP(pArapConn)) == NULL)
        {
            // no more data left (or no complete SRP): done here
            break;
        }

        // was ARAP connection up?  route only if it's up, otherwise drop it!
        if (fArapConnUp)
        {
            ArapRoutePacketFromWan( pArapConn, pArapBuf );
        }

        // we received AppleTalk data but connection wasn't up!  Drop pkt
        else
        {
	        DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
	            ("ArapCleanup: (%lx) AT data, but conn not up\n",pArapConn));
        }

#if DBG
        //
        // yeah, there is no spinlock: given our state, no one else will be
        // touching this field.  Besides, this is debug-only!
        //
        pArapConn->RecvsPending -= pArapBuf->DataSize;
#endif

        // done with this buffer
        ARAP_FREE_RCVBUF(pArapBuf);
    }

    //
    // if there are any buffers left on the ReceiveQ, they are basically
    // incomplete SRP's: throw them away
    //
    while (pRcvList != &pArapConn->ReceiveQ)
    {
	    pArapBuf = CONTAINING_RECORD(pRcvList, ARAPBUF, Linkage);

        pRcvList = pRcvList->Flink;

#if DBG
        // same deal again with spinlock again...
        pArapConn->RecvsPending -= pArapBuf->DataSize;
#endif

		ARAP_FREE_RCVBUF(pArapBuf);
    }

    //
    // free up all the packets on ArapDataQ: these are not going to be of
    // any use, whether or not the connection was up, so best just to throw
    // them away (why complicate life?)
    //
    while (pArapList != &pArapConn->ArapDataQ)
    {
	    pArapBuf = CONTAINING_RECORD(pArapList, ARAPBUF, Linkage);

        pArapList = pArapList->Flink;

#if DBG
        // same deal again with spinlock again...
        pArapConn->RecvsPending -= pArapBuf->DataSize;
#endif

		ARAP_FREE_RCVBUF(pArapBuf);
    }

    //
    // free up all the packets on the MiscPktsQ
    //
    while (pMiscPktList != &pArapConn->MiscPktsQ)
    {
	    pArapBuf = CONTAINING_RECORD(pMiscPktList, ARAPBUF, Linkage);

        pMiscPktList = pMiscPktList->Flink;

		ARAP_FREE_RCVBUF(pArapBuf);
    }

    //
    // call completion routine for all the sends that were waiting to be sent
    // on the high priority Q
    //
    while (pSendHighList != &pArapConn->HighPriSendQ)
    {
        pMnpSendBuf = CONTAINING_RECORD(pSendHighList,MNPSENDBUF,Linkage);

        pSendHighList = pSendHighList->Flink;

#if DBG
        InitializeListHead(&pMnpSendBuf->Linkage);
#endif
        // call the completion routine which will do cleanup for this buffer
        (pMnpSendBuf->ComplRoutine)(pMnpSendBuf,ARAPERR_DISCONNECT_IN_PROGRESS);
    }

    //
    // call completion routine for all the sends that were waiting to be sent
    // on the Med priority Q
    //
    while (pSendMedList != &pArapConn->MedPriSendQ)
    {
        pMnpSendBuf = CONTAINING_RECORD(pSendMedList,MNPSENDBUF,Linkage);

        pSendMedList = pSendMedList->Flink;

#if DBG
        InitializeListHead(&pMnpSendBuf->Linkage);
#endif
        // call the completion routine which will do cleanup for this buffer
        (pMnpSendBuf->ComplRoutine)(pMnpSendBuf,ARAPERR_DISCONNECT_IN_PROGRESS);
    }

    //
    // call completion routine for all the sends that were waiting to be sent
    // on the Low priority Q
    //
    while (pSendLowList != &pArapConn->LowPriSendQ)
    {
        pMnpSendBuf = CONTAINING_RECORD(pSendLowList,MNPSENDBUF,Linkage);

        pSendLowList = pSendLowList->Flink;

#if DBG
        InitializeListHead(&pMnpSendBuf->Linkage);
#endif
        // call the completion routine which will do cleanup for this buffer
        (pMnpSendBuf->ComplRoutine)(pMnpSendBuf,ARAPERR_DISCONNECT_IN_PROGRESS);
    }



    //
    // free up all the packets on RetransmitQ that were waiting to be acked
    //
    while (pReXmitList != &pArapConn->RetransmitQ)
    {
	    pMnpSendBuf = CONTAINING_RECORD(pReXmitList, MNPSENDBUF, Linkage);

        pReXmitList = pReXmitList->Flink;

#if DBG
        InitializeListHead(&pMnpSendBuf->Linkage);
#endif
        // call the completion routine which will do cleanup for this buffer
        (pMnpSendBuf->ComplRoutine)(pMnpSendBuf,ARAPERR_DISCONNECT_IN_PROGRESS);
    }


    // if there was an irp in progress, complete it first!
    if (pIrp)
    {
        pSndRcvInfo = (PARAP_SEND_RECV_INFO)pIrp->AssociatedIrp.SystemBuffer;

        pSndRcvInfo->StatusCode = ARAPERR_DISCONNECT_IN_PROGRESS;

        ARAP_COMPLETE_IRP(pIrp, sizeof(ARAP_SEND_RECV_INFO), STATUS_SUCCESS,
							&ReturnStatus);
    }

    // if there was an irp in progress, complete it first!
    if (pRcvIrp)
    {
        pSndRcvInfo = (PARAP_SEND_RECV_INFO)pRcvIrp->AssociatedIrp.SystemBuffer;

        pSndRcvInfo->StatusCode = ARAPERR_DISCONNECT_IN_PROGRESS;

        ARAP_COMPLETE_IRP(pRcvIrp, sizeof(ARAP_SEND_RECV_INFO), STATUS_SUCCESS, 
							&ReturnStatus);
    }

    // if we have any sniff info, give it to dll.
    ARAP_DUMP_DBG_TRACE(pArapConn);

    //
    // now, try telling the dll that the connection went away.  (We can do this
    // only using a "select" irp)
    //
    ACQUIRE_SPIN_LOCK(&pArapConn->SpinLock, &OldIrql);

    ArapGetSelectIrp(&pDiscIrp);

    // no select irp?  just mark that fact, so on next select we'll tell dll
    if (!pDiscIrp)
    {
        pArapConn->Flags |= DISCONNECT_NO_IRP;
    }

    RELEASE_SPIN_LOCK(&pArapConn->SpinLock, OldIrql);

    //
    // if we did find select irp, go ahead and tell the dll
    //
    if (pDiscIrp)
    {
        dwBytesToDll = 0;

#if DBG
        //
        // if we have some sniff info that we couldn't deliver earlier through
        // the sniff irp, then give them through this irp: it's going back
        // "empty" anyway!
        //
        if (pArapConn->pDbgTraceBuffer && pArapConn->SniffedBytes > 0)
        {
            dwBytesToDll = ArapFillIrpWithSniffInfo(pArapConn,pDiscIrp);
        }
#endif

        pDiscSndRcvInfo = (PARAP_SEND_RECV_INFO)pDiscIrp->AssociatedIrp.SystemBuffer;

        pDiscSndRcvInfo->pDllContext = pArapConn->pDllContext;
        pDiscSndRcvInfo->AtalkContext = ARAP_INVALID_CONTEXT;
        pDiscSndRcvInfo->DataLen = dwBytesToDll;
        pDiscSndRcvInfo->StatusCode = StatusCode;

        dwBytesToDll += sizeof(ARAP_SEND_RECV_INFO);

        ARAP_COMPLETE_IRP(pDiscIrp, dwBytesToDll, STATUS_SUCCESS,
							&ReturnStatus);

        // we told dll: remove this link
        pArapConn->pDllContext = NULL;

        // we told the dll, remove the connect refcount
        DerefArapConn(pArapConn);

	    DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
            ("ArapCleanup: told dll (%lx refcount=%d)\n",pArapConn,pArapConn->RefCount));
    }
    else
    {
		DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
		    ("ArapCleanup: no select irp, dll doesn't yet know (%lx) died\n", pArapConn));
    }

    // remove the creation refcount
    DerefArapConn(pArapConn);
}



//***
//
// Function: PrepareConnectionResponse
//              This routine parses the connect request that is first sent by
//              the remote client and forms a connection response (LR frame)
//              based on the options negotiated.
//              This routine basically does the MNP negotiation.
//
// Parameters:  pArapConn - connection element being cleaned up
//              pReq - buffer containting client's original connect request
//              pFrame - buffer in which we put the response
//              BytesWritten - how big is the connection response
//
// Return:      result of the operation (ARAPERR_....)
//
//***$

DWORD
PrepareConnectionResponse(
    IN  PARAPCONN  pArapConn,
    IN  PBYTE      pReq,              // buffer with client's request
    IN  DWORD      ReqLen,            // how big is the request
    OUT PBYTE      pFrame,            // buffer with our response to the client
    OUT USHORT   * pMnpLen
)
{
    PBYTE       pReqEnd;
    PBYTE       pFrameStart;
    BYTE        VarLen;
    KIRQL       OldIrql;
    BYTE        NumLTFrames=0;
    USHORT      MaxInfoLen=0;
    USHORT      FrameLen;
    BYTE        Mandatory[5];
    BOOLEAN     fOptimized=FALSE;
    BOOLEAN     fMaxLen256=FALSE;
    BOOLEAN     fV42Bis=FALSE;
    BOOLEAN     fArapV20=TRUE;
    DWORD       dwReqToSkip;
    DWORD       dwFrameToSkip;
    BYTE        JunkBuffer[MNP_MINPKT_SIZE+1];
    DWORD       i;
    BOOLEAN     fNonStd=FALSE;


    DBG_ARAP_CHECK_PAGED_CODE();

#if DBG

    //
    // validate our assumption that all the clients always send out the same
    // LR request packet
    //
    for (i=0; i<sizeof(ArapDbgLRPacket); i++ )
    {
        if (pReq[3+i] != ArapDbgLRPacket[i])
        {
            fNonStd = TRUE;
        }
    }

    if (fNonStd)
    {
        DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
            ("Arap Prepare..Response: non-standard LR-request packet\n"));
        DbgPrint("  Std : ");
        for (i=0; i<sizeof(ArapDbgLRPacket); i++)
        {
            DbgPrint("%2X ",ArapDbgLRPacket[i]);
        }
        DbgPrint("\n");
        DbgPrint("  This: ");
        for (i=0; i<sizeof(ArapDbgLRPacket); i++)
        {
            DbgPrint("%2X ",pReq[3+i]);
        }
        DbgPrint("\n");
    }
#endif


    for (i=0; i<5; i++)
    {
        Mandatory[i] = 0;
    }


    //
    // in case of callback, we get an LR response from the dial-in client. When
    // that happens, we still want to run through this routine to make sure all
    // parameters are legal, etc., and also to "configure" the connection based
    // on the parms negotiated.  In that case, however, there is no output frame
    // needed.  So, we just write the output frame to junkbuffer
    // which is obviously never used.
    //
    if (pFrame == NULL)
    {
        pFrame = &JunkBuffer[0];
    }

    pFrameStart = pFrame;

    //
    // see if this is ARAP v2.0 or v1.0 connection: we know the frame is good,
    // so just look at the first byte
    //
    if (*pReq == MNP_SYN)
    {
        fArapV20 = FALSE;
    }

    // now copy those three start flag bytes
    *pFrame++ = *pReq++;
    *pFrame++ = *pReq++;
    *pFrame++ = *pReq++;

    // first byte (after the start flag, that is) is the length byte
    FrameLen = *pReq;

    if ((FrameLen > ReqLen) || (FrameLen > MNP_MINPKT_SIZE))
    {
        ASSERT(0);
        return(ARAPERR_BAD_FORMAT);
    }

    pReqEnd = pReq + FrameLen;

    pReq += 2;                   // skip over length ind. and type ind.

    // Constant parameter 1 must have a value of 2
    if ((*pReq++) != MNP_LR_CONST1 )
    {
        DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
            ("Error: MNP_LR_CONST1 missing in conn req %lx:\n",pArapConn));

        return(ARAPERR_BAD_FORMAT);
    }

    // we build the return frame as we parse the incoming frame: we are supposed
    // to return only those options that we both receive and understand.
    //

    pFrame++;      // we'll put the length byte at the end
    *pFrame++ = MNP_LR;
    *pFrame++ = MNP_LR_CONST1;

    // parse all the "variable" parms until we reach end of the frame
    //
    while (pReq < pReqEnd)
    {
        switch (*pReq++)
        {
            //
            // nothing to do here, other than verify it's valid
            //
            case MNP_LR_CONST2:

                VarLen = *pReq++;
                if ( (VarLen == 6) &&
                     (*(pReq  ) == 1) && (*(pReq+1) == 0) &&
                     (*(pReq+2) == 0) && (*(pReq+3) == 0) &&
                     (*(pReq+4) == 0) && (*(pReq+5) == 255) )
                {
                    *pFrame++ = MNP_LR_CONST2;
                    *pFrame++ = VarLen;
                    RtlCopyMemory(pFrame, pReq, VarLen);
                    pFrame += VarLen;
                    pReq += VarLen;
                }
                else
                {
                    DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                        ("Error: bad MNP_LR_CONST2 in conn req %lx:\n",pArapConn));
                    return(ARAPERR_BAD_FORMAT);
                }

                Mandatory[0] = 1;

                break;

            //
            // octet-oriented or bit-oriented framing
            //
            case MNP_LR_FRAMING:

                pReq++;      // skip over length byte

                //
                // we only support octet-oriented framing mode
                //
                if (*pReq++ < MNP_FRMMODE_OCTET)
                {
                    DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                        ("Error: (%lx) unsupported framing mode %d requested:\n",
                        pArapConn,*(pReq-1)));

                    ASSERT(0);
                    return(ARAPERR_BAD_FORMAT);
                }

                *pFrame++ = MNP_LR_FRAMING;
                *pFrame++ = 1;
                *pFrame++ = MNP_FRMMODE_OCTET;

                Mandatory[1] = 1;
                break;

            //
            // Max. number of outstanding LT frames, k
            //
            case MNP_LR_NUMLTFRMS:

                pReq++;      // skip over length byte
                NumLTFrames = *pReq++;

                if (NumLTFrames > ArapGlobs.MaxLTFrames)
                {
                    NumLTFrames = ArapGlobs.MaxLTFrames;
                }

                *pFrame++ = MNP_LR_NUMLTFRMS;
                *pFrame++ = 1;
                *pFrame++ = NumLTFrames;

                Mandatory[2] = 1;
                break;

            //
            // Max. information field length, N401
            //
            case MNP_LR_INFOLEN:

                pReq++;      // skip over length byte
                MaxInfoLen = *((USHORT *)pReq);

                ASSERT(MaxInfoLen <= 256);

                *pFrame++ = MNP_LR_INFOLEN;
                *pFrame++ = 2;

                // we are just copying whatever client gave
                *pFrame++ = *pReq++;
                *pFrame++ = *pReq++;

                Mandatory[3] = 1;
                break;

            //
            // data optimization info
            //
            case MNP_LR_DATAOPT:

                pReq++;      // skip over length byte

                if ((*pReq) & 0x1)
                {
                    fMaxLen256 = TRUE;
                }

                if ((*pReq) & 0x2)
                {
                    fOptimized = TRUE;
                }

                *pFrame++ = MNP_LR_DATAOPT;
                *pFrame++ = 1;
                *pFrame++ = *pReq++;

                Mandatory[4] = 1;

                break;

            //
            // v42 parameter negotiation
            //
            case MNP_LR_V42BIS:

                fV42Bis = v42bisInit( pArapConn,
                                      pReq,
                                      &dwReqToSkip,
                                      pFrame,
                                      &dwFrameToSkip );

                pReq += dwReqToSkip;
                pFrame += dwFrameToSkip;

                break;

            //
            // what the heck is this option?  just skip over it!
            //
            default:

                DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                    ("Prepare..Response (%lx): unknown option %lx len=%ld type=%ld\n",
                    pArapConn, *(pReq-1), *pReq, *(pReq+1)));

                VarLen = *pReq++;
                pReq += VarLen;
                break;
        }
    }

    //
    // make sure we got all the mandatory parameters
    //
    for (i=0; i<5; i++)
    {
        if (Mandatory[i] == 0)
        {
            DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                ("PrepareConnectionResponse: parm %d missing (%lx):\n",i,pArapConn));

            return(ARAPERR_BAD_FORMAT);
        }
    }

    // copy the stop flag
    *pFrame++ = (fArapV20)? MNP_ESC : MNP_DLE;
    *pFrame++ = MNP_ETX;

    // store all the negotiated info
    pArapConn->BlockId = (fMaxLen256)? BLKID_MNP_LGSENDBUF : BLKID_MNP_SMSENDBUF;

    if (fOptimized)
    {
        pArapConn->Flags |= MNP_OPTIMIZED_DATA;
    }

    if (fV42Bis)
    {
        pArapConn->Flags |= MNP_V42BIS_NEGOTIATED;
    }
    else
    {
        DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
            ("Prepare..Response: WARNING!! v42bis NOT negotiated on (%lx):\n",pArapConn));
    }

    if (fArapV20)
    {
        pArapConn->Flags |= ARAP_V20_CONNECTION;

        // save the Syn,Dle,Stx,Etx bytes depeding on what connection this is
        pArapConn->MnpState.SynByte = MNP_SOH;
        pArapConn->MnpState.DleByte = MNP_ESC;
        pArapConn->MnpState.StxByte = MNP_STX;
        pArapConn->MnpState.EtxByte = MNP_ETX;
    }
    else
    {
        pArapConn->MnpState.SynByte = MNP_SYN;
        pArapConn->MnpState.DleByte = MNP_DLE;
        pArapConn->MnpState.StxByte = MNP_STX;
        pArapConn->MnpState.EtxByte = MNP_ETX;
    }

    //
    // if we are doing callback, we should act like the client
    //
    if ((pArapConn->Flags & ARAP_CALLBACK_MODE) && fArapV20)
    {
        pArapConn->MnpState.LTByte = MNP_LT_V20CLIENT;
    }
    else
    {
        pArapConn->MnpState.LTByte = MNP_LT;
    }

    pArapConn->MnpState.WindowSize = NumLTFrames;

    pArapConn->MnpState.UnAckedLimit = (NumLTFrames/2);

    if (pArapConn->MnpState.UnAckedLimit == 0)
    {
        pArapConn->MnpState.UnAckedLimit = 1;
    }

    pArapConn->MnpState.MaxPktSize = MaxInfoLen;
    pArapConn->MnpState.SendCredit = NumLTFrames;

    // how big is the mnp frame
    if (pMnpLen)
    {
        *pMnpLen = (USHORT)(pFrame - pFrameStart);

        // write the length byte
        // (length byte is after the 3 start flag bytes: that's why (pFrameStart+3))
        // (and exclude (3 start + 2 stop + 1 len bytes):that's why (*pMnpLen) - 6)

        *(pFrameStart+3) = (*pMnpLen) - 6;

    }

    return( ARAPERR_NO_ERROR );
}




//***
//
// Function: ArapExtractAtalkSRP
//              This routine extracts one complete SRP out of the receive
//              buffer queue.  One SRP could be split up into multiple receive
//              buffers, or one receive buffer could contain several SRPs: it
//              depends on how the client sent the data.
//
// Parameters:  pArapConn - connection element in question
//
// Return:      Pointer to a buffer containing one complete SRP
//              NULL if there is no data, or if a complete SRP hasn't yet arrived
//
//***$

PARAPBUF
ArapExtractAtalkSRP(
    IN PARAPCONN    pArapConn
)
{
    KIRQL                   OldIrql;
    USHORT                  BytesInThisBuffer;
    USHORT                  SrpLen;
    USHORT                  SrpModLen;
    PARAPBUF                pArapBuf=NULL;
    PARAPBUF                pRecvBufNew=NULL;
    PARAPBUF                pReturnBuf=NULL;
    PARAPBUF                pNextRecvBuf=NULL;
    PLIST_ENTRY             pRcvList;
    DWORD                   BytesOnQ;
    USHORT                  BytesRemaining;
    USHORT                  BytesToCopy;
    BYTE                    DGroupByte;
    BYTE                    TmpArray[4];
    USHORT                  i;


    DBG_ARAP_CHECK_PAGED_CODE();

    ACQUIRE_SPIN_LOCK(&pArapConn->SpinLock, &OldIrql);

    ARAP_CHECK_RCVQ_INTEGRITY(pArapConn);

ArapSRP_TryNext:

    // list is empty?
	if ((pRcvList = pArapConn->ReceiveQ.Flink) == &pArapConn->ReceiveQ)
    {
        RELEASE_SPIN_LOCK(&pArapConn->SpinLock, OldIrql);
        return(NULL);
    }

    pArapBuf = CONTAINING_RECORD(pRcvList, ARAPBUF, Linkage);

    // Debug only: make sure first few bytes are right...
    ARAP_CHECK_RCVQ_INTEGRITY(pArapConn);

	BytesInThisBuffer = pArapBuf->DataSize;

    //
    // if datasize goes to 0, we free the buffer right away.  Also, at indicate time
    // if datasize is 0, we never insert a buffer: so this had better be non-zero!
    //
	ASSERT(BytesInThisBuffer > 0);

    //
    // most common case: we at least have the 2 length bytes in the first buffer
    //
    if (BytesInThisBuffer >= sizeof(USHORT))
    {
        // get the SRP length from the length field (network to host order)
        GETSHORT2SHORT(&SrpLen, pArapBuf->CurrentBuffer);
    }
    //
    // alright, last byte of the first buffer is the 1st length byte.
    // pick up the 2nd length byte from the next buffer
    //
    else
    {
        ARAP_BYTES_ON_RECVQ(pArapConn, &BytesOnQ);

        if (BytesOnQ < sizeof(USHORT))
        {
            RELEASE_SPIN_LOCK(&pArapConn->SpinLock, OldIrql);
            return(NULL);
        }

        pRcvList = pArapBuf->Linkage.Flink;

        ASSERT(pRcvList != &pArapConn->ReceiveQ);

        pNextRecvBuf = CONTAINING_RECORD(pRcvList, ARAPBUF, Linkage);

        TmpArray[0] = pArapBuf->CurrentBuffer[0];
        TmpArray[1] = pNextRecvBuf->CurrentBuffer[0];

        GETSHORT2SHORT(&SrpLen, &TmpArray[0]);
    }

    if (SrpLen > ARAP_MAXPKT_SIZE_INCOMING)
    {
        RELEASE_SPIN_LOCK(&pArapConn->SpinLock, OldIrql);

    	DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
	        ("ArapExtractSRP: (%lx) too big a packet (%ld)\n",pArapConn,SrpLen));

        // can't recover! kill connection here
        ArapCleanup(pArapConn);

        return(NULL);
    }

    // add the 2 len bytes.  We will always deal with an SRP along
    // with these 2 len bytes
    SrpModLen = SrpLen + sizeof(USHORT);

    //
    // let's deal with the simplest case first
    // (the whole pkt is just one complete SRP):
    //
    if (SrpModLen == BytesInThisBuffer)
    {
        RemoveEntryList(&pArapBuf->Linkage);

        // length of the SRP pkt, plus the 2 length bytes
        pArapBuf->DataSize = SrpModLen;

        pReturnBuf = pArapBuf;
    }

    //
    // The packet contains more than one SRP
    // allocate a new buffer and copy the SRP, leaving remaining bytes behind
    //
    else if (SrpModLen < BytesInThisBuffer)
    {
        ARAP_GET_RIGHTSIZE_RCVBUF(SrpModLen, &pRecvBufNew);
        if (pRecvBufNew == NULL)
        {
    	    DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
	            ("ArapExtractSRP: (%lx) mem alloc failed\n",pArapConn));

            return(NULL);
        }

        RtlCopyMemory( &pRecvBufNew->Buffer[0],
                       pArapBuf->CurrentBuffer,
                       SrpModLen);

        pRecvBufNew->DataSize = SrpModLen;

        // changes to reflect the bytes we 'removed' in the original buffer
        pArapBuf->DataSize -= SrpModLen;
        pArapBuf->CurrentBuffer = pArapBuf->CurrentBuffer + SrpModLen;

        pReturnBuf = pRecvBufNew;

        // Debug only: make sure what we're leaving behind is good...
        ARAP_CHECK_RCVQ_INTEGRITY(pArapConn);
    }

    //
    // packet contains a partial SRP (this is a rare case, but possible)
    // we must traverse the queue until we "collect" the whole SRP.  If we still
    // can't get one complete SRP, it's not arrived yet!
    //
    else    // if (SrpModLen > BytesInThisBuffer)
    {
        ARAP_BYTES_ON_RECVQ(pArapConn, &BytesOnQ);

        //
        // if we have a full srp (split up across multiple buffers on the Q)
        //
        if (BytesOnQ >= SrpModLen)
        {

            //
            // allocate a new buffer to hold this fragmented SRP
            //
            ARAP_GET_RIGHTSIZE_RCVBUF(SrpModLen, &pRecvBufNew);

            if (pRecvBufNew == NULL)
            {
    	        DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
	                ("ArapExtractSRP: (%lx) mem alloc failed at II\n",pArapConn));

                return(NULL);
            }

            pRecvBufNew->DataSize = SrpModLen;

            pNextRecvBuf = pArapBuf;

            BytesRemaining = SrpModLen;

            while (BytesRemaining)
            {
                BytesToCopy = (BytesRemaining > pNextRecvBuf->DataSize) ?
                                pNextRecvBuf->DataSize : BytesRemaining;

                RtlCopyMemory( pRecvBufNew->CurrentBuffer,
                               pNextRecvBuf->CurrentBuffer,
                               BytesToCopy );

                pRecvBufNew->CurrentBuffer += BytesToCopy;

                pNextRecvBuf->CurrentBuffer += BytesToCopy;

                pNextRecvBuf->DataSize -= BytesToCopy;

                BytesRemaining -= BytesToCopy;

                pRcvList = pNextRecvBuf->Linkage.Flink;

                // are we done with this buffer?  if so, unlink it and free it
                if (pNextRecvBuf->DataSize == 0)
                {
                    RemoveEntryList(&pNextRecvBuf->Linkage);

                    ARAP_FREE_RCVBUF(pNextRecvBuf);
                }
                else
                {
                    // didn't free up the buffer? we had better be done!
                    ASSERT(BytesRemaining == 0);

                    // Debug only: make sure what we're leaving behind is good...
                    ARAP_CHECK_RCVQ_INTEGRITY(pArapConn);
                }

                // there should be more data on the queue or we should be done
                ASSERT(pRcvList != &pArapConn->ReceiveQ || BytesRemaining == 0);

                pNextRecvBuf = CONTAINING_RECORD(pRcvList, ARAPBUF, Linkage);
            }

            pRecvBufNew->CurrentBuffer = &pRecvBufNew->Buffer[0];

            pReturnBuf = pRecvBufNew;
        }
        else
        {
            pReturnBuf = NULL;
        }
    }

    if (pReturnBuf)
    {
        DGroupByte = pReturnBuf->CurrentBuffer[ARAP_DGROUP_OFFSET];

#if DBG

        ARAP_DBG_TRACE(pArapConn,21105,pReturnBuf,0,0,0);

        GETSHORT2SHORT(&SrpLen, pReturnBuf->CurrentBuffer);

        ASSERT(pReturnBuf->DataSize == SrpLen+2);
        ASSERT(SrpLen <= ARAP_MAXPKT_SIZE_INCOMING);

        if (DGroupByte != 0x10 && DGroupByte != 0x50 &&
           (pArapConn->Flags & ARAP_CONNECTION_UP))
        {
            DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                ("ArapExtract: DGrpByte %x\n",DGroupByte));
            ASSERT(0);
        }

        //
        // see if we have an arap packet embedded inside another arap packet
        // This is an expensive way, but it's debug only: who cares!
        //
        for (i=6; i<(pReturnBuf->DataSize-6); i++)
        {
            if ((pReturnBuf->CurrentBuffer[i] == 0x10) ||
                (pReturnBuf->CurrentBuffer[i] == 0x50))
            {
                if (pReturnBuf->CurrentBuffer[i+1] == 0)
                {
                    if (pReturnBuf->CurrentBuffer[i+2] == 0)
                    {
                        if (pReturnBuf->CurrentBuffer[i+3] == 0x2)
                        {
                            if (pReturnBuf->CurrentBuffer[i+4] == 0)
                            {
                                if (pReturnBuf->CurrentBuffer[i+5] == 0)
                                {
                                    DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                                        ("ArapExtract: ERROR?: embedded arap packet at %lx? (%lx)\n",
                                        &pReturnBuf->CurrentBuffer[i],pReturnBuf));
                                }
                            }
                        }
                    }
                }
            }
        }
#endif

        //
        // is it out-of-band ARAP data?  If so, put it on its own queue, and
        // try to extract another SRP
        //
        if (!(DGroupByte & ARAP_SFLAG_PKT_DATA))
        {
            InsertTailList(&pArapConn->ArapDataQ, &pReturnBuf->Linkage);
            goto ArapSRP_TryNext;
        }
    }

    RELEASE_SPIN_LOCK(&pArapConn->SpinLock, OldIrql);

    return(pReturnBuf);

}



//***
//
// Function: ArapQueueSendBytes
//              This routine takes compressed data and puts it into MNP packets
//              ready to be sent out.  If the last unsent buffer on the queue
//              has some room left, it first stuffs as many bytes as possible
//              in that buffer.  After that, if necessary, it allocates a new
//              buffer and puts the remaining bytes in that buffer.
//              The max data in any buffer can only be the negotiated maximum
//              MNP data length (64 or 256 bytes)
//
// Parameters:  pArapConn - connection element in question
//              pCompressedDataBuffer - pointer to the data to be sent out
//              CompressedDataLen - size of the outgoing data
//              Priority - priority of the send
//
// Return:      Error code
//
//
// NOTES:       IMPORTANT: spinlock must be held before calling this routine
//
//***$

DWORD
ArapQueueSendBytes(
    IN PARAPCONN    pArapConn,
    IN PBYTE        pCompressedDataBuffer,
    IN DWORD        CompressedDataLen,
    IN DWORD        Priority
)
{
    DWORD                   StatusCode;
    PLIST_ENTRY             pSendQHead;
    PMNPSENDBUF             pMnpSendBuf=NULL;
    PBYTE                   pFrame, pFrameStart;
    DWORD                   dwRemainingBytes;
    PMNPSENDBUF             pTailMnpSendBuf=NULL;
    PMNPSENDBUF             pFirstMnpSendBuf=NULL;
    USHORT                  DataLenInThisPkt;
    PLIST_ENTRY             pList;
    USHORT                  DataSizeOfOrgTailSend;
    PBYTE                   FreeBufferOfOrgTailSend;
    BYTE                    NumSendsOfOrgTailSend;
    BOOLEAN                 fNeedNewBuffer;
    PLIST_ENTRY             pSendList;
    USHORT                  BytesFree;
    PBYTE                   pCompressedData;
    BYTE                    DbgStartSeq;



    DBG_ARAP_CHECK_PAGED_CODE();

    if (Priority == ARAP_SEND_PRIORITY_HIGH)
    {
        pSendQHead = &pArapConn->HighPriSendQ;
    }
    else if (Priority == ARAP_SEND_PRIORITY_MED)
    {
        pSendQHead = &pArapConn->MedPriSendQ;
    }
    else
    {
        pSendQHead = &pArapConn->LowPriSendQ;
    }

#if DBG
    DbgStartSeq = pArapConn->MnpState.NextToSend;
#endif

    //
    // first, find the last send-buffer on the queue and see if its buffer has
    // any bytes free that we can use
    //

    fNeedNewBuffer = TRUE;

    if (!IsListEmpty(pSendQHead))
    {
        pList = pSendQHead->Blink;

        pTailMnpSendBuf = CONTAINING_RECORD(pList, MNPSENDBUF, Linkage);

        BytesFree = pTailMnpSendBuf->BytesFree;

        //
        // if there are more than 3 bytes free, we will use the part of this
        // buffer that's free: otherwise, let's go for a new one
        //
        if (BytesFree > ARAP_HDRSIZE)
        {
            pMnpSendBuf = pTailMnpSendBuf;

            pFrame = pTailMnpSendBuf->FreeBuffer;

            pFrameStart = pFrame;

            fNeedNewBuffer = FALSE;

            // save these, in case we have to bail out
            DataSizeOfOrgTailSend = pTailMnpSendBuf->DataSize;
            FreeBufferOfOrgTailSend = pTailMnpSendBuf->FreeBuffer;
            NumSendsOfOrgTailSend = pMnpSendBuf->NumSends;

            // mark that we are stuffing one more send into this buffer
            pMnpSendBuf->NumSends++;
        }
        else
        {
            pTailMnpSendBuf = NULL;
        }
    }


    dwRemainingBytes = CompressedDataLen;

    pCompressedData = pCompressedDataBuffer;

    // we are adding so many more bytes to our send queue
    pArapConn->SendsPending += CompressedDataLen;

    while (dwRemainingBytes)
    {
        if (fNeedNewBuffer)
        {
            pMnpSendBuf = ArapGetSendBuf(pArapConn, Priority);
            if (pMnpSendBuf == NULL)
            {
	            DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                    ("ArapQueueSendBytes: ArapGetSendBuf failed (%lx)\n", pArapConn));

                StatusCode = ARAPERR_OUT_OF_RESOURCES;
                goto ArapQueueSendBytes_ErrExit;
            }

            // put MNPSend refcount
            pArapConn->RefCount++;

            BytesFree = pMnpSendBuf->BytesFree;

            pFrameStart = pFrame = pMnpSendBuf->FreeBuffer;

            //
            // remeber the first buffer, in case we have to bail out!
            //
            if (!pFirstMnpSendBuf)
            {
                pFirstMnpSendBuf = pMnpSendBuf;
            }

            // put this send on the appropriate send queue
            InsertTailList(pSendQHead, &pMnpSendBuf->Linkage);

            pMnpSendBuf->NumSends = 1;
        }

        if (dwRemainingBytes > BytesFree)
        {
            DataLenInThisPkt = BytesFree;
        }
        else
        {
            DataLenInThisPkt = (USHORT)dwRemainingBytes;
        }

        ASSERT(DataLenInThisPkt <= MNP_MAXPKT_SIZE);

        ASSERT(DataLenInThisPkt <= pMnpSendBuf->BytesFree);

        RtlCopyMemory(pFrame, pCompressedData, DataLenInThisPkt);

        dwRemainingBytes -= DataLenInThisPkt;

        pCompressedData += DataLenInThisPkt;

        ASSERT(pCompressedData <= pCompressedDataBuffer + CompressedDataLen);

        pMnpSendBuf->BytesFree -= DataLenInThisPkt;

        pMnpSendBuf->DataSize += DataLenInThisPkt;

        ASSERT(pMnpSendBuf->DataSize <= MNP_MAXPKT_SIZE);

        pFrame += DataLenInThisPkt;

        // buffer from this point on is free: we could (in a subsequent call)
        // stuff more bytes, starting from this point
        pMnpSendBuf->FreeBuffer = pFrame;

        //
        // we are either done with copying the entire send, or done with this
        // buffer: in either case, put those stop flag bytes
        //
        *pFrame++ = pArapConn->MnpState.DleByte;
        *pFrame++ = pArapConn->MnpState.EtxByte;

        ASSERT(pMnpSendBuf->FreeBuffer <=
                        (&pMnpSendBuf->Buffer[0] + 20 + MNP_MAXPKT_SIZE));

    	AtalkSetSizeOfBuffDescData(&pMnpSendBuf->sb_BuffDesc,
                                   (pMnpSendBuf->DataSize + MNP_OVERHD(pArapConn)));

        fNeedNewBuffer = TRUE;
    }

    ARAP_DBG_TRACE(pArapConn,21205,pCompressedDataBuffer,CompressedDataLen,
                    Priority,DbgStartSeq);

    return( ARAPERR_NO_ERROR );


ArapQueueSendBytes_ErrExit:

    //
    // we failed somewhere.  Undo whatever we did, to restore the original
    // state and free up whatever resources were allocated.
    //

	DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
        ("ArapQueueSendBytes_ErrExit (%lx): taking _ErrExit! %ld\n",
            pArapConn,StatusCode));

    pArapConn->SendsPending -= CompressedDataLen;

    // did we fill any bytes in the older buf before allocating new one?
    if (pTailMnpSendBuf)
    {
        pTailMnpSendBuf->DataSize = DataSizeOfOrgTailSend;
        pTailMnpSendBuf->FreeBuffer = pFrame = FreeBufferOfOrgTailSend;
        pTailMnpSendBuf->NumSends = NumSendsOfOrgTailSend;

        // and don't forget those stop flag bytes we overwrote
        *pFrame++ = pArapConn->MnpState.DleByte;
        *pFrame++ = pArapConn->MnpState.EtxByte;
    }

    // did we allocate any new buffers? if so, remove and free them
    if (pFirstMnpSendBuf)
    {
        // restore the next-to-send seq num
        pArapConn->MnpState.NextToSend = pFirstMnpSendBuf->SeqNum;

        while (1)
        {
            // get the next guy first
            pSendList = pFirstMnpSendBuf->Linkage.Flink;

            // remove this one
            RemoveEntryList(&pFirstMnpSendBuf->Linkage);

            ArapNdisFreeBuf(pFirstMnpSendBuf);

            // the guy we thought was next might be the head of list: is he?
            if (pSendList == pSendQHead)
            {
                break;
            }

            pFirstMnpSendBuf = CONTAINING_RECORD(pSendList, MNPSENDBUF, Linkage);
        }
    }

    return(StatusCode);
}


//***
//
// Function: ArapGetSendBuf
//              This routine allocates a buffer for MNP send and sets it up
//              sending.
//              The max data in any buffer can only be the negotiated maximum
//              MNP data length (64 or 256 bytes)
//
// Parameters:  pArapConn - connection element in question
//              Priority  - priority of the send
//
// Return:      Pointer to the newly allocated send buffer
//
//
// NOTES:       IMPORTANT: spinlock must be held before calling this routine
//
//***$

PMNPSENDBUF
ArapGetSendBuf(
    IN PARAPCONN pArapConn,
    IN DWORD     Priority
)
{

    PBYTE           pFrame;
    PBYTE           pFrameStart;
    BYTE            SeqNum;
    PMNPSENDBUF     pMnpSendBuf;


    DBG_ARAP_CHECK_PAGED_CODE();

    // allocate an arap send buffer
	pMnpSendBuf = AtalkBPAllocBlock(pArapConn->BlockId);
    if (pMnpSendBuf == NULL)
    {
	    DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
            ("ArapGetSendBuf: alloc failed (%lx)\n", pArapConn));

        ASSERT(0);

        return( NULL );
    }

#if DBG
    pMnpSendBuf->Signature = (pArapConn->BlockId == BLKID_MNP_LGSENDBUF)?
                        MNPLGSENDBUF_SIGNATURE : MNPSMSENDBUF_SIGNATURE;
    InitializeListHead(&pMnpSendBuf->Linkage);
#endif

    pFrameStart = pFrame = &pMnpSendBuf->Buffer[0];

    AtalkNdisBuildARAPHdr(pFrame, pArapConn);
    pFrame += WAN_LINKHDR_LEN;


    // put the start flag bytes
    *pFrame++ = pArapConn->MnpState.SynByte;
    *pFrame++ = pArapConn->MnpState.DleByte;
    *pFrame++ = pArapConn->MnpState.StxByte;

    //
    // find out what's going to be the seq num for this send if this is a high
    // priority send.
    //
    //
    if (Priority == ARAP_SEND_PRIORITY_HIGH)
    {
        SeqNum = pArapConn->MnpState.NextToSend;
        ADD_ONE(pArapConn->MnpState.NextToSend);
    }

    //
    // For the medium and low priority send, we'll put the seq number when we
    // move it to the high-priority queue
    //
    else
    {
        SeqNum = 0;
    }

    // Optimized? put the header-length, type indication and the seq num
    if (pArapConn->Flags & MNP_OPTIMIZED_DATA)
    {
        *pFrame++ = 2;
        *pFrame++ = pArapConn->MnpState.LTByte;
        *pFrame++ = SeqNum;
    }

    // ok, non-optimized. put the header-length, type indication, type+len for
    // the variable parm and then the seq num
    else
    {
        *pFrame++ = 4;
        *pFrame++ = pArapConn->MnpState.LTByte;
        *pFrame++ = 1;
        *pFrame++ = 1;
        *pFrame++ = SeqNum;
    }

    pMnpSendBuf->BytesFree = (pArapConn->BlockId == BLKID_MNP_SMSENDBUF) ?
                                MNP_MINPKT_SIZE : MNP_MAXPKT_SIZE;

    pMnpSendBuf->DataSize = 0;
    pMnpSendBuf->FreeBuffer = pFrame;

    // store info that's used in retransmission and send completion
    pMnpSendBuf->SeqNum = SeqNum;
    pMnpSendBuf->RetryCount = 0;
    pMnpSendBuf->pArapConn = pArapConn;
    pMnpSendBuf->ComplRoutine = ArapMnpSendComplete;
    pMnpSendBuf->TimeAlloced = AtalkGetCurrentTick();
    pMnpSendBuf->Flags = 0;

    // MNP refcount: removed when this MNP pkt is acked
    pMnpSendBuf->RefCount = 1;

	((PBUFFER_HDR)pMnpSendBuf)->bh_NdisPkt = NULL;

    pArapConn->StatInfo.BytesSent += LT_OVERHEAD(pArapConn);

    return(pMnpSendBuf);
}



//***
//
// Function: ArapRefillSendQ
//              This routine removes bytes accumulated in the medium and the
//              low-priority send queues, and puts them on to the high priority
//              queue from where bytes are actually sent out.  If sufficient
//              bytes haven't accumulated as yet on either of the queus and we
//              haven't waited long enough as yet, then we skip that queue (to
//              allow more bytes to accumulate)
//              The idea behind this is: there are just too many NBP packets
//              - directed as well as broadcast - going toward the remote client.
//              If we send such a packet as soon as it arrives, we end up sending
//              numerous small sized (like 6 or 8 byte) sends to the client and
//              that really hurts throughput as typically the max size is 256!
//
// Parameters:  pArapConn - connection element in question
//
// Return:      TRUE if we moved any data to the higher priority queue
//
//***$

BOOLEAN
ArapRefillSendQ(
    IN PARAPCONN    pArapConn
)
{
    KIRQL           OldIrql;
    PMNPSENDBUF     pMnpSendBuf=NULL;
    PLIST_ENTRY     pSendHead;
    PLIST_ENTRY     pSendList;
    LONG            TimeWaited;
    BYTE            SeqNum;
    BOOLEAN         fMovedSomething=FALSE;
    BOOLEAN         fWaitLonger=FALSE;
    DWORD           SeqOffset;


    DBG_ARAP_CHECK_PAGED_CODE();

    ACQUIRE_SPIN_LOCK(&pArapConn->SpinLock, &OldIrql);

    pSendHead = &pArapConn->MedPriSendQ;

    while (1)
    {
        pSendList = pSendHead->Flink;

        //
        // if the list is not empty, take a look at the first send.  If we have
        // accumulated enough bytes, or if we have waited long enough, then it's
        // time has come to be moved to the HighPriSendQ.  Otherwise, we let it
        // stay on the queue for some more coalescing
        //
        if (pSendList != pSendHead)
        {
            pMnpSendBuf = CONTAINING_RECORD(pSendList,MNPSENDBUF,Linkage);

            TimeWaited = AtalkGetCurrentTick() - pMnpSendBuf->TimeAlloced;

            fWaitLonger =
                ((pMnpSendBuf->DataSize < ARAP_SEND_COALESCE_SIZE_LIMIT) &&
                 (pMnpSendBuf->NumSends < ARAP_SEND_COALESCE_SRP_LIMIT) &&
                 (TimeWaited < ARAP_SEND_COALESCE_TIME_LIMIT) );
        }

        //
        // if this list is empty or if this send must wait for some more time
        // then we must move to the LOW pri queue.  If that's also done, quit
        //
        if ((pSendList == pSendHead) || fWaitLonger )
        {
            // if we were on MedPriSendQ, go to the LowPriSendQ
            if (pSendHead == &pArapConn->MedPriSendQ)
            {
                pSendHead = &pArapConn->LowPriSendQ;
                continue;
            }
            else
            {
                break;
            }
        }

        ASSERT(!fWaitLonger);

        //
        // time to move this send over to the high pri queue:
        // put that seq number we had postponed putting earlier
        //
        SeqNum = pArapConn->MnpState.NextToSend;

        ADD_ONE(pArapConn->MnpState.NextToSend);

        SeqOffset = WAN_LINKHDR_LEN + LT_SEQ_OFFSET(pArapConn);

        pMnpSendBuf->Buffer[SeqOffset] = SeqNum;

        pMnpSendBuf->SeqNum = SeqNum;

        RemoveEntryList(&pMnpSendBuf->Linkage);

        InsertTailList(&pArapConn->HighPriSendQ, &pMnpSendBuf->Linkage);

        fMovedSomething = TRUE;

    	DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
            ("ArapRefill: moved %s seq %lx size = %d wait = %d (%d SRPs)\n",
                (pSendHead == &pArapConn->MedPriSendQ)? "MED":"LOW",
                pMnpSendBuf->SeqNum,pMnpSendBuf->DataSize,TimeWaited,
                pMnpSendBuf->NumSends));
    }

    RELEASE_SPIN_LOCK(&pArapConn->SpinLock, OldIrql);

    return(fMovedSomething);
}




//***
//
// Function: ArapUnblockSelect
//              This function is called when the DLL (ARAP Engine) tells us that
//              it's going away.  In ideal world, select irp is the only thing
//              that should get completed here.  If any connection was left
//              or any irp wasn't complete yet, this is where we would cleanup!
//
// Parameters:  None
//
// Return:      result of the operation (ARAPERR_....)
//
//***$

DWORD
ArapUnblockSelect(
    IN  VOID
)
{

    KIRQL                   OldIrql;
    PIRP                    pIrp;
    PIRP                    pSniffIrp;
    PARAP_SEND_RECV_INFO    pSndRcvInfo;
	NTSTATUS				ReturnStatus=STATUS_SUCCESS;



    ARAPTRACE(("Entered ArapUnblockSelect\n"));

    ACQUIRE_SPIN_LOCK(&ArapSpinLock, &OldIrql);

    pIrp = ArapSelectIrp;
    ArapSelectIrp = NULL;

#if DBG
    pSniffIrp = ArapSniffIrp;
    ArapSniffIrp = NULL;
#endif

    if (ArapStackState == ARAP_STATE_ACTIVE)
    {
        ArapStackState = ARAP_STATE_ACTIVE_WAITING;
    }
    else if (ArapStackState == ARAP_STATE_INACTIVE)
    {
        ArapStackState = ARAP_STATE_INACTIVE_WAITING;
    }

    RELEASE_SPIN_LOCK(&ArapSpinLock, OldIrql);


#if DBG
    //
    // if we had sniffing going, complete the sniff irp since dll is shutting down
    //
    if (pSniffIrp)
    {
        pSndRcvInfo = (PARAP_SEND_RECV_INFO)pSniffIrp->AssociatedIrp.SystemBuffer;
        pSndRcvInfo->StatusCode = ARAPERR_SHUTDOWN_COMPLETE;

        // complete the irp
        ARAP_COMPLETE_IRP(pSniffIrp, sizeof(ARAP_SEND_RECV_INFO), 
							STATUS_SUCCESS, &ReturnStatus);

        DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
            ("ArapUnblockSelect: unblocked the sniff irp\n"));
    }
#endif

    //
    // complete the select irp, now that the engine tells us that it wants to
    // shutdown
    //
    if (pIrp)
    {
        pSndRcvInfo = (PARAP_SEND_RECV_INFO)pIrp->AssociatedIrp.SystemBuffer;
        pSndRcvInfo->StatusCode = ARAPERR_SHUTDOWN_COMPLETE;

        // complete the irp
        ARAP_COMPLETE_IRP(pIrp, sizeof(ARAP_SEND_RECV_INFO), STATUS_SUCCESS,
							&ReturnStatus);

        DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
            ("ArapUnblockSelect: unblocked the select irp\n"));
    }
    else
    {
        DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
            ("ArapUnblockSelect: select irp not yet unblocked\n"));
    }

    return(ARAPERR_NO_ERROR);
}


//***
//
// Function: ArapReleaseResources
//              This routine frees up any global resources we had allocated
//
// Parameters:  None
//
// Return:      result of the operation (ARAPERR_....)
//
//***$

DWORD
ArapReleaseResources(
    IN  VOID
)
{
    KIRQL               OldIrql;
    PLIST_ENTRY         pList;
    PADDRMGMT           pAddrMgmt;
    PADDRMGMT           pNextAddrMgmt;
    PARAPCONN           pArapConn;


    ARAPTRACE(("Entered ArapReleaseResources\n"));

    if (RasPortDesc == NULL)
    {
        DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
            ("ArapReleaseResources: arap engine never initialized; returning\n"));
        return(ARAPERR_NO_ERROR);
    }

#if ARAP_STATIC_MODE
    //
    // if we were in the static mode of network address allocation, we
    // allocated memory for our network address "bitmap": free that here.
    //
    if (!(ArapGlobs.DynamicMode))
    {
        pAddrMgmt = ArapGlobs.pAddrMgmt;

        ASSERT(pAddrMgmt);

        while (pAddrMgmt)
        {
            pNextAddrMgmt = pAddrMgmt->Next;
            AtalkFreeMemory(pAddrMgmt);
            pAddrMgmt = pNextAddrMgmt;
        }
    }
#endif


    //
    // By the time this routine is called, all the connections should have been
    // completely closed.  If, however, some connection got stuck in some weird
    // state, at least make sure that we don't have a memory leak
    //
    ASSERT(IsListEmpty(&RasPortDesc->pd_ArapConnHead));

    while (1)
    {
        ACQUIRE_SPIN_LOCK(&RasPortDesc->pd_Lock, &OldIrql);

        if (IsListEmpty(&RasPortDesc->pd_ArapConnHead))
        {
            RELEASE_SPIN_LOCK(&RasPortDesc->pd_Lock, OldIrql);
            break;
        }

        pList = RasPortDesc->pd_ArapConnHead.Flink;

        pArapConn = CONTAINING_RECORD(pList, ARAPCONN, Linkage);

        ACQUIRE_SPIN_LOCK_DPC(&pArapConn->SpinLock);

        // protect against it going away while we do this
        pArapConn->RefCount++;

        RELEASE_SPIN_LOCK_DPC(&pArapConn->SpinLock);
        RELEASE_SPIN_LOCK(&RasPortDesc->pd_Lock, OldIrql);

        ArapCleanup(pArapConn);

        ACQUIRE_SPIN_LOCK(&RasPortDesc->pd_Lock, &OldIrql);
        ACQUIRE_SPIN_LOCK_DPC(&pArapConn->SpinLock);

        RemoveEntryList(&pArapConn->Linkage);
        InitializeListHead(&pArapConn->Linkage);

        // force this connection to be freed
        pArapConn->RefCount = 1;

        RELEASE_SPIN_LOCK_DPC(&pArapConn->SpinLock);
        RELEASE_SPIN_LOCK(&RasPortDesc->pd_Lock, OldIrql);

        DerefArapConn(pArapConn);
    }

    return(ARAPERR_NO_ERROR);
}


//***
//
// Function: AtalkReferenceRasDefPort
//              This routine puts a refcount on the Default adapter so it doesn't go away
//              with PnP while we are busy doing some ARAP/PPP connection setup
//              It also makes sure that RasPortDesc is indeed present
//
// Parameters:  None
//
// Return:      TRUE (most cases) if port is all ok, FALSE if PnP in progress or something
//
//***$

BOOLEAN
AtalkReferenceRasDefPort(
    IN  VOID
)
{
    KIRQL       OldIrql;
    BOOLEAN     fDefPortOk = FALSE;


    ACQUIRE_SPIN_LOCK(&AtalkPortLock, &OldIrql);

    if ((RasPortDesc != NULL) && (!(RasPortDesc->pd_Flags & PD_PNP_RECONFIGURE)))
    {
        if (AtalkDefaultPort)
        {
            ACQUIRE_SPIN_LOCK_DPC(&AtalkDefaultPort->pd_Lock);
            if ((AtalkDefaultPort->pd_Flags &
                    (PD_ACTIVE | PD_PNP_RECONFIGURE | PD_CLOSING)) == PD_ACTIVE)
            {
                // put a IrpProcess refcount, so AtalkDefaultPort doesn't go away in PnP
                AtalkDefaultPort->pd_RefCount++;
                fDefPortOk = TRUE;
            }
            else
            {
	            DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
	                ("AtalkReferenceRasDefPort: port going away, no can do (%lx)\n",
                    AtalkDefaultPort->pd_Flags));
            }
            RELEASE_SPIN_LOCK_DPC(&AtalkDefaultPort->pd_Lock);
        }
        else
        {
	        DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
	            ("AtalkReferenceRasDefPort: no default adapter configured!\n"));
        }
    }
    else
    {
	    DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
	        ("AtalkReferenceRasDefPort: RasPortDesc not configured\n"));
    }

    RELEASE_SPIN_LOCK(&AtalkPortLock, OldIrql);

    return(fDefPortOk);
}



VOID
AtalkPnPInformRas(
    IN  BOOLEAN     fEnableRas
)
{

    PIRP                    pIrp=NULL;
    PARAP_SEND_RECV_INFO    pSndRcvInfo;
    DWORD                   StatusCode;
    KIRQL                   OldIrql;
	NTSTATUS				ReturnStatus=STATUS_SUCCESS;


    //
    // fEnableRas = TRUE: we are asked to inform RAS (aka dll, engine) that the stack
    // is now "active" (i.e. available for RAS connections)
    //
    if (fEnableRas)
    {
        //
        // make sure both the adapters are ready.  We don't really need spinlock to
        // check the flag since all PnP operations are guaranteed to be serialized
        //
        if ( (AtalkDefaultPort == NULL) ||
             (AtalkDefaultPort->pd_Flags & PD_PNP_RECONFIGURE) ||
             (RasPortDesc == NULL) ||
             (RasPortDesc->pd_Flags & PD_PNP_RECONFIGURE) )
        {
            DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                ("AtalkPnPInformRas: not both adapters are ready %lx %lx, returning\n",
                AtalkDefaultPort,RasPortDesc));
            return;
        }

        ACQUIRE_SPIN_LOCK(&ArapSpinLock, &OldIrql);

        //
        // if we are already active, nothing to do!
        //
        if (ArapStackState == ARAP_STATE_ACTIVE)
        {
            DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                ("AtalkPnPInformRas: stack already active, nothing to do\n"));

            RELEASE_SPIN_LOCK(&ArapSpinLock, OldIrql);
            return;
        }

        pIrp = ArapSelectIrp;
        ArapSelectIrp = NULL;

        if (pIrp)
        {
            DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                ("AtalkPnPInformRas: informing dll that stack is ready\n"));

            ArapStackState = ARAP_STATE_ACTIVE;
            StatusCode = ARAPERR_STACK_IS_ACTIVE;
        }
        else
        {
            DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                ("AtalkPnPInformRas: no select irp. stack ready, but dll not knoweth\n"));

            ArapStackState = ARAP_STATE_ACTIVE_WAITING;
        }

        RELEASE_SPIN_LOCK(&ArapSpinLock, OldIrql);
    }

    //
    // fEnableRas = FALSE: we are asked to inform RAS (aka dll, engine) that the stack
    // is now "inactive" (i.e. not available for RAS connections)
    //
    else
    {
        ACQUIRE_SPIN_LOCK(&ArapSpinLock, &OldIrql);

        //
        // if we are already inactive, nothing to do!
        //
        if (ArapStackState == ARAP_STATE_INACTIVE)
        {
            DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                ("AtalkPnPInformRas: stack already inactive, nothing to do\n"));

            RELEASE_SPIN_LOCK(&ArapSpinLock, OldIrql);
            return;
        }

        pIrp = ArapSelectIrp;
        ArapSelectIrp = NULL;

        if (pIrp)
        {
            DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                ("AtalkPnPInformRas: informing dll that stack is unavailable\n"));

            ArapStackState = ARAP_STATE_INACTIVE;
            StatusCode = ARAPERR_STACK_IS_NOT_ACTIVE;
        }
        else
        {
            DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                ("AtalkPnPInformRas: no select irp. stack unavailable, but dll not knoweth\n"));

            ArapStackState = ARAP_STATE_INACTIVE_WAITING;
        }

        RELEASE_SPIN_LOCK(&ArapSpinLock, OldIrql);
    }

    if (pIrp)
    {
        pSndRcvInfo = (PARAP_SEND_RECV_INFO)pIrp->AssociatedIrp.SystemBuffer;
        pSndRcvInfo->StatusCode = StatusCode;

        // complete the irp
        ARAP_COMPLETE_IRP(pIrp, sizeof(ARAP_SEND_RECV_INFO), STATUS_SUCCESS,
							&ReturnStatus);
    }
}


#if ARAP_STATIC_MODE

//***
//
// Function: ArapReleaseAddr
//              This routine releases the network address that was being used
//              by the client (corresponding to this connection).  In case of
//              dynamic mode, we don't do anything.
//              In case of static mode, we clear the bit corresponding to this
//              particular network address.
//
// Parameters:  pArapConn - connection element in question
//
// Return:      none
//
//***$

VOID
ArapReleaseAddr(
    IN PARAPCONN    pArapConn
)
{

    KIRQL               OldIrql;
    PADDRMGMT           pAddrMgmt;
    BYTE                Node;
    BYTE                ByteNum;
    BYTE                BitMask;
    DWORD               i;


    DBG_ARAP_CHECK_PAGED_CODE();

    //
    // if we are in static mode, we need to "release" the node so that someone
    // else can use it.  Find the bit for this node and clear it (i.e. "release")
    //
    if (!(ArapGlobs.DynamicMode))
    {
        ACQUIRE_SPIN_LOCK(&ArapSpinLock, &OldIrql);

        // first, find the right pAddrMgmt (1st one if we have <255 clients)
        pAddrMgmt = ArapGlobs.pAddrMgmt;

        ASSERT(pAddrMgmt);

        while (pAddrMgmt->Network != pArapConn->NetAddr.atn_Network)
        {
            pAddrMgmt = pAddrMgmt->Next;

            ASSERT(pAddrMgmt);
        }

        Node = pArapConn->NetAddr.atn_Node;

        // find out which of the 32 bytes we should be looking at
        ByteNum = Node/8;
        Node -= (ByteNum*8);

        // generate the bitmask to represent the node
        BitMask = 0x1;
        for (i=0; i<Node; i++ )
        {
            BitMask <<= 1;
        }

        // now, clear that bit!
        pAddrMgmt->NodeBitMap[ByteNum] &= ~BitMask;

        RELEASE_SPIN_LOCK(&ArapSpinLock, OldIrql);
    }


}
#endif //ARAP_STATIC_MODE



//
// not used anymore: leave them in, in case we need to use them sometime...
//
#if 0

DWORD
ArapScheduleWorkerEvent(
    IN DWORD Action,
    IN PVOID Context1,
    IN PVOID Context2
)
{
    PARAPQITEM  pArapQItem;

    if ((pArapQItem = AtalkAllocMemory(sizeof(ARAPQITEM))) == NULL)
    {
        DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
            ("ArapScheduleWorkerEvent: mem alloc failed!\n"));
        return(ARAPERR_OUT_OF_RESOURCES);
    }

    pArapQItem->Action = Action;
    pArapQItem->Context1 = Context1;
    pArapQItem->Context2 = Context2;

    ExInitializeWorkItem(&pArapQItem->WorkQItem,
                         (PWORKER_THREAD_ROUTINE)ArapDelayedEventHandler,
                         pArapQItem);
    ExQueueWorkItem(&pArapQItem->WorkQItem, CriticalWorkQueue);

    return(ARAPERR_NO_ERROR);
}


VOID
ArapDelayedEventHandler(
    IN PARAPQITEM  pArapQItem
)
{
    DWORD               Action;
    PIRP                pIrp;
    PIO_STACK_LOCATION  pIrpSp;
    ULONG               IoControlCode;
    PMNPSENDBUF         pMnpSendBuf;
    DWORD               StatusCode;
    NTSTATUS            status;
    KIRQL               OldIrq;


    Action = pArapQItem->Action;
    switch (Action)
    {
        case ARAPACTION_COMPLETE_IRP:

            pIrp = (PIRP)pArapQItem->Context1;
            status = (NTSTATUS)pArapQItem->Context2;


            ASSERT(pIrp != NULL);

#if DBG
	        pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
            IoControlCode = pIrpSp->Parameters.DeviceIoControl.IoControlCode;

	        DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
		        ("ArapDelayedEventHandler: completing irp %lx, Ioctl %lx, Status=%lx at irql=%d\n",
                    pIrp,IoControlCode,status,KeGetCurrentIrql()));
#endif
            //TdiCompleteRequest(pIrp, status);

            pIrp->IoStatus.Status = status;

            IoCompleteRequest(pIrp,IO_NETWORK_INCREMENT);

            break;

        case ARAPACTION_CALL_COMPLETION:

            pMnpSendBuf = (PMNPSENDBUF )pArapQItem->Context1;
            StatusCode = (DWORD)pArapQItem->Context2;

	        DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
		        ("ArapDelayedEventHandler: calling compl. %lx with %lx, %ld\n",
                 pMnpSendBuf->ComplRoutine,pMnpSendBuf, StatusCode));

            (pMnpSendBuf->ComplRoutine)(pMnpSendBuf, StatusCode);

            break;

        default:

	        DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
		        ("ArapDelayedEventHandler: invalid action %ld\n",Action));
    }

    AtalkFreeMemory(pArapQItem);
}

#endif // #if 0
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\atalk\sys\arapdbg.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	arapdbg.c

Abstract:

	This module implements all debug utilities used by ARAP

Author:

	Shirish Koti

Revision History:
	26 March 1997		Initial Version

--*/

#include 	<atalk.h>

#pragma hdrstop

//	File module number for errorlogging
#define	FILENUM		ARAPDBG


#define ALIGN8(Ptr) ( (((ULONG_PTR)(Ptr))+7) & (~7) )
//
// The following are debug-only routines.  These routines help us catch bad
// things before they do damage, and help us sleep better at night.
//


#if DBG

DWORD   ArapDbgDumpOnDisconnect = 0;

//***
//
// Function: ArapProcessSniff
//              Stores the sniff irp.  Next time some connection needs to return
//              the sniff info, use this irp.
//
// Parameters:  pIrp - the Sniff irp to process
//
// Return:      result of the operation
//
//***$

NTSTATUS
ArapProcessSniff(
    IN  PIRP  pIrp
)
{
    KIRQL                   OldIrql;
    PARAP_SEND_RECV_INFO    pSndRcvInfo;


    ARAPTRACE(("Entered ArapProcessSniff (%lx)\n",pIrp));

    ACQUIRE_SPIN_LOCK(&ArapSpinLock, &OldIrql);

    // store the irp (we can only have one Sniff irp at a time)
    ASSERT (ArapSniffIrp == NULL);

    if (ArapSniffIrp != NULL)
    {
		DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
		    ("ArapProcessSniff: Sniff irp %lx already in progress!\n", ArapSniffIrp));

        pSndRcvInfo = (PARAP_SEND_RECV_INFO)pIrp->AssociatedIrp.SystemBuffer;
        pSndRcvInfo->StatusCode = ARAPERR_IRP_IN_PROGRESS;
        RELEASE_SPIN_LOCK(&ArapSpinLock, OldIrql);
        return( STATUS_SUCCESS );
    }

    ArapSniffIrp = pIrp;

    RELEASE_SPIN_LOCK(&ArapSpinLock, OldIrql);


    return(STATUS_PENDING);
}


//***
//
// Function: ArapDumpSniffInfo
//              If we have collected enough sniff info, complete the sniff irp
//
// Parameters:  pArapConn - connection in question
//
// Return:      TRUE if we returned info to dll, FALSE otherwise
//
//***$

BOOLEAN
ArapDumpSniffInfo(
    IN PARAPCONN    pArapConn
)
{

    PIRP                    pIrp;
    DWORD                   dwBytesToDll;
	NTSTATUS				ReturnStatus=STATUS_SUCCESS;


    // if we don't have a sniff buffer (or no bytes in it), get out
    if (!pArapConn->pDbgTraceBuffer || pArapConn->SniffedBytes == 0)
    {
        return(FALSE);
    }

    //
    // if we have less than 500 bytes in the buffer, and we aren't disconnecting
    // or disconnected, don't complete the irp as yet
    // (it's ok not have spinlock here)
    //
    if ((pArapConn->SniffedBytes < 500) &&
        (pArapConn->State == MNP_UP ))
    {
        return(FALSE);
    }

    ARAP_GET_SNIFF_IRP(&pIrp);

    // no sniff irp available? can't do much, leave
    if (!pIrp)
    {
        return(FALSE);
    }

    dwBytesToDll = ArapFillIrpWithSniffInfo(pArapConn,pIrp) +
                   sizeof(ARAP_SEND_RECV_INFO);

    // ok, complete that irp now!
    ARAP_COMPLETE_IRP(pIrp, dwBytesToDll, STATUS_SUCCESS, &ReturnStatus);

    return(TRUE);

}


//***
//
// Function: ArapFillIrpWithSniffInfo
//              Copy the sniff bytes into the irp
//
// Parameters:  pArapConn - connection in question
//              pIrp - the irp to fill data in
//                     (except in one case, this irp will be the sniff irp.
//                     The exception case is where disconnect has occured and
//                     and at that time, a sniff irp wasn't available.  In that
//                     case, we use the select irp that's carrying the disconnect
//                     info to send the remaining sniff bytes).
//
// Return:      Number of sniff bytes that were copied in
//
//***$

DWORD
ArapFillIrpWithSniffInfo(
    IN PARAPCONN    pArapConn,
    IN PIRP         pIrp
)
{
    PARAP_SEND_RECV_INFO    pSndRcvInfo=NULL;
    KIRQL                   OldIrql;
    DWORD                   SniffedBytes;
    PBYTE                   pStartData;
    DWORD                   dwBytesToDll;


    ACQUIRE_SPIN_LOCK(&pArapConn->SpinLock, &OldIrql);

    pSndRcvInfo = (PARAP_SEND_RECV_INFO)pIrp->AssociatedIrp.SystemBuffer;

    //
    // if buffer is smaller than how much data we have, adjust by ignoring
    // bytes in the beginning of the buffer
    //
    if (pSndRcvInfo->DataLen < pArapConn->SniffedBytes)
    {
		DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
		    ("ArapFill...Info: chopping %d bytes in the beginning\n",
                (pArapConn->SniffedBytes - pSndRcvInfo->DataLen)));

        pStartData = pArapConn->pDbgTraceBuffer +
                        (pArapConn->SniffedBytes - pSndRcvInfo->DataLen);

        pArapConn->SniffedBytes = pSndRcvInfo->DataLen;
    }
    else
    {
        pStartData = pArapConn->pDbgTraceBuffer;
    }

    SniffedBytes = pArapConn->SniffedBytes;

    // ok, copy the data in
    RtlCopyMemory( &pSndRcvInfo->Data[0],
                   pStartData,
                   SniffedBytes );

    pArapConn->pDbgCurrPtr = pArapConn->pDbgTraceBuffer;

    pArapConn->SniffedBytes = 0;

    RELEASE_SPIN_LOCK(&pArapConn->SpinLock, OldIrql);

    // set the info (contexts need to be set each time in case of select)
    pSndRcvInfo->AtalkContext = pArapConn;
    pSndRcvInfo->pDllContext =  pArapConn->pDllContext;
    pSndRcvInfo->DataLen = SniffedBytes;
    pSndRcvInfo->StatusCode = ARAPERR_NO_ERROR;

    return(SniffedBytes);

}


//***
//
// Function: DbgChkRcvQIntegrity
//              This routine looks at the first buffer on the receive queue and
//              verifies that things look reasonable
//
// Parameters:  pArapConn - the connection in question
//
// Return:      TRUE if things look reasonable, FALSE otherwise
//
// NOTES:       IMPORTANT: spinlock must be held before calling this routine
//
//***$

BOOLEAN
DbgChkRcvQIntegrity(
    IN  PARAPCONN       pArapConn
)
{
    PLIST_ENTRY     pList;
    PARAPBUF        pArapBuf;
    PBYTE           packet;
    USHORT          SrpLen;


    pList = pArapConn->ReceiveQ.Flink;
    if (pList == &pArapConn->ReceiveQ)
    {
        return( TRUE );
    }

    if (!(pArapConn->Flags & ARAP_CONNECTION_UP))
    {
        return( TRUE );
    }

    pArapBuf = CONTAINING_RECORD(pList, ARAPBUF, Linkage);

    // wait until more bytes show up
    if (pArapBuf->DataSize < 6)
    {
        return( TRUE );
    }

    packet = pArapBuf->CurrentBuffer;

    GETSHORT2SHORT(&SrpLen, pArapBuf->CurrentBuffer);

    if (SrpLen > ARAP_MAXPKT_SIZE_INCOMING)
    {
		DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
            ("ARAP: packet too big (%d bytes) in %lx)\n",SrpLen,pArapBuf));

        return(FALSE);
    }

    if ((packet[2] != 0x50) && (packet[2] != 0x10))
    {
		DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
            ("ARAP: wrong DGroup byte (%x) in %lx)\n",packet[2],pArapBuf));

        return(FALSE);
    }

    if (packet[2] == 0x50)
    {
        if ((packet[3] != 0) || (packet[4] != 0) || (packet[5] != 2))
        {
		    DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                ("ARAP (%lx): wrong LAP hdr in %lx)\n",pArapBuf));

            return(FALSE);
        }
    }

    return( TRUE );
}



//***
//
// Function: DbgDumpBytes
//              This routine dumps first 64 bytes from a buffer to the debugger
//
// Parameters:  pDbgMsg - string to print before the bytes (optional)
//              pBuffer - buffer from which to dump the bytes
//              BufLen - how big is the buffer
//              DumpLevel - if this matches ArapDumpLevel, we dump the bytes
//
// Return:      Nothing
//
//***$

VOID
DbgDumpBytes(
    IN PBYTE  pDbgMsg,
    IN PBYTE  pBuffer,
    IN DWORD  BufLen,
    IN DWORD  DumpLevel
)
{
    BYTE        OutBuf[400];
    DWORD       NextIndex;
    DWORD       dwBytesToDump;


    if (ArapDumpLevel != DumpLevel)
    {
        return;
    }

    if (pDbgMsg)
    {
        DbgPrint("%s (pkt len = %d)\n",pDbgMsg,BufLen);
    }
    else
    {
        DbgPrint("Dumping packet (pkt len = %d)\n",BufLen);
    }

    // dump the first 64 bytes

    dwBytesToDump = (BufLen <= 64)? BufLen : 64;

    dwBytesToDump = (dwBytesToDump < ArapDumpLen)?dwBytesToDump:ArapDumpLen;

    DbgDumpBytesPart2( pBuffer, OutBuf, dwBytesToDump, &NextIndex );

    OutBuf[NextIndex] = '\n';
    OutBuf[NextIndex+1] = 0;

    DbgPrint("%s",OutBuf);
}


//***
//
// Function: DbgDumpBytesPart2
//              This is a helper routine for the DbgDumpBytes routine
//***$

VOID
DbgDumpBytesPart2(
    IN  PBYTE  pBuffer,
    OUT PBYTE  OutBuf,
    IN  DWORD  BufLen,
    OUT DWORD *NextIndex
)
{
    BYTE        Byte;
    BYTE        nibble;
    DWORD       i, j;


    j = 0;
    OutBuf[j++] = ' '; OutBuf[j++] = ' '; OutBuf[j++] = ' '; OutBuf[j++] = ' ';

    for (i=0; i<BufLen; i++ )
    {
        Byte = pBuffer[i];

        nibble = (Byte >> 4);
        OutBuf[j++] = (nibble < 10) ? ('0' + nibble) : ('a' + (nibble-10));

        nibble = (Byte & 0x0f);
        OutBuf[j++] = (nibble < 10) ? ('0' + nibble) : ('a' + (nibble-10));

        OutBuf[j++] = ' ';

        if (((i+1) % 16) == 0)
        {
            OutBuf[j++] = '\n'; OutBuf[j++] = ' ';
            OutBuf[j++] = ' '; OutBuf[j++] = ' '; OutBuf[j++] = ' ';
        }
        else if (((i+1) % 8) == 0)
        {
            OutBuf[j++] = ' ';
        }
    }

    *NextIndex = j;

    return;
}



//***
//
// Function: DbgDumpNetworkNumbers
//              This routine dumps out all the network ranges that exist on the
//              network.
//
// Parameters:  None
//
// Return:      Nothing
//
//***$

VOID
DbgDumpNetworkNumbers(
    IN VOID
)
{
    KIRQL       OldIrql;
	PRTE	    pRte, pNext;
	int		    i;


	ACQUIRE_SPIN_LOCK(&AtalkRteLock, &OldIrql);

	for (i = 0; i < NUM_RTMP_HASH_BUCKETS; i++)
	{
		for (pRte = AtalkRoutingTable[i]; pRte != NULL; pRte = pNext)
		{
			pNext = pRte->rte_Next;

			ACQUIRE_SPIN_LOCK_DPC(&pRte->rte_Lock);

	        DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                    ("    pRte: %lx  LowEnd %lx  HighEnd %lx\n",
                    pRte,pRte->rte_NwRange.anr_FirstNetwork,pRte->rte_NwRange.anr_LastNetwork));
            RELEASE_SPIN_LOCK_DPC(&pRte->rte_Lock);
		}
	}

	RELEASE_SPIN_LOCK(&AtalkRteLock, OldIrql);
}


//***
//
// Function: DbgTrackInfo
//              This routine tracks various information, useful in arriving at
//              optimum buffer sizes, etc.
//
// Parameters:  pArapConn - the connection in question
//              Size - size of the buffer (incoming, outgoing, as appropriate)
//              TrackingWhat - what are we tracking (sends, recvs etc.)
//
// Return:      Nothing
//
//***$

VOID
DbgTrackInfo(
    IN PARAPCONN    pArapConn,
    IN DWORD        Size,
    IN DWORD        TrackingWhat
)
{
    //
    // track the MNP send sizes (how many are 0-10 bytes, 11-20 bytes, etc.)
    //
    if (TrackingWhat == 1)
    {
        ArapDbgMnpSendSizes[Size/10]++;

        return;
    }
}



//***
//
// Function: ArapDbgTrace
//              This routine traces (keeps a log) of all the events (data going
//              in/out, acks going in/out, error conditions etc.
//
// Parameters:  pArapConn - the connection in question
//              Location  - who is logging this event (the location decides what
//                          the other parms are going to be)
//              Context   - depends on Location (e.g.could be data buffer)
//              dwInfo1   - depends on Location
//              dwInfo2   - depends on Location
//              dwInfo3   - depends on Location
//
// Return:      Nothing
//
// NOTE:        Spinlock is assumed to be held
//
//***$

VOID
ArapDbgTrace(
    IN PARAPCONN    pArapConn,
    IN DWORD        Location,
    IN PVOID        Context,
    IN DWORD        dwInfo1,
    IN DWORD        dwInfo2,
    IN DWORD        dwInfo3
)
{
    LARGE_INTEGER   CurrTime;
    LARGE_INTEGER   DiffTime;
    PBYTE           pStartTrace;
    PBYTE           pTrace;
    PBUFFER_DESC    pBuffDesc;
    PARAPBUF        pArapBuf;
    PMNPSENDBUF     pMnpSendBuf;
    PBYTE           pCurrBuff;
    DWORD           BufLenSoFar=0;
    USHORT          Delta;
    BYTE            Priority;
    DWORD           BytesCopied=0;
    DWORD           BytesAvailable;
    USHORT          DbgInfoLen;
    PSNIFF_INFO     pSniff;
    DWORD           i;



    if (!pArapConn->pDbgTraceBuffer)
    {
        return;
    }

    KeQuerySystemTime(&CurrTime);

    DiffTime = RtlLargeIntegerSubtract(CurrTime, ArapDbgLastTraceTime);

    ArapDbgLastTraceTime = CurrTime;

    // do the conversion to get ms
    Delta = (USHORT)(DiffTime.LowPart);

    pSniff = (PSNIFF_INFO)(pArapConn->pDbgCurrPtr);

    pTrace = pStartTrace = &pSniff->Frame[0];

    // put signature (starting of a "frame")
    pSniff->Signature = ARAP_SNIFF_SIGNATURE;

    // time since last event
    pSniff->TimeStamp = (DWORD)AtalkGetCurrentTick();

    // who is logging this info
    pSniff->Location = (USHORT)Location;

    //
    // ok, now see who has called us and log the relevant info
    // If we can't find the Location, it's ok: we have the Location number
    // logged and and that's adequate (that's why we can't find Location)
    //
    switch (Location)
    {
        // data to client is about to be compressed: copy some info
        case 11205:

            pBuffDesc = (PBUFFER_DESC)Context;
            Priority = (BYTE)dwInfo1;

            while (pBuffDesc)
            {
                if (pBuffDesc->bd_Flags & BD_CHAR_BUFFER)
                {
                    pCurrBuff = pBuffDesc->bd_CharBuffer;
                    BytesAvailable = pBuffDesc->bd_Length;
                }

                else
                {
                    pCurrBuff = MmGetSystemAddressForMdlSafe(
                                    pBuffDesc->bd_OpaqueBuffer,
                                    NormalPagePriority);

					if (pCurrBuff == NULL) {
						goto error_end;
					}
                    BytesAvailable = MmGetMdlByteCount(pBuffDesc->bd_OpaqueBuffer);
                }

                //
                // if this buffer descriptor contains (usually exclusively) the
                // ARAP header, then get some info out of it and skip those bytes
                //
                if ((pCurrBuff[2] == 0x10 || pCurrBuff[2] == 0x50) &&
                    (pCurrBuff[3] == 0) && (pCurrBuff[4] == 0) && (pCurrBuff[5] == 2))
                {
                    *pTrace++ = pCurrBuff[0];   // srplen byte 1
                    *pTrace++ = pCurrBuff[1];   // srplen byte 2
                    *pTrace++ = pCurrBuff[2];   // ARAP or Atalk packet
                    *pTrace++ = Priority;
                    BytesAvailable -= 6;
                    pCurrBuff += 6;
                }

                // copy first 48 bytes of the data packet
                while (BytesAvailable && BytesCopied < 48)
                {
                    *pTrace++ = *pCurrBuff++;
                    BytesCopied++;
                    BytesAvailable--;
                }

                pBuffDesc = pBuffDesc->bd_Next;
            }

            break;

        // we are sending out an ack
        case 11605:

            *pTrace++ = (BYTE)dwInfo1;    // sequence num in our ack
            *pTrace++ = (BYTE)dwInfo2;    // rcv credit in our ack
            break;


        // we are queuing compressed send bytes
        case 21205:

            *pTrace++ = (BYTE)dwInfo2;    // priority of the send
            *pTrace++ = (BYTE)dwInfo3;    // Start sequence for this send
            *pTrace++ = (BYTE)(pArapConn->MnpState.NextToSend-1);  // end sequence

            BytesAvailable = dwInfo1;        // len of compressed data
            pCurrBuff = (PBYTE)Context;       // buffer with compressed data

            // copy first 24 bytes of the compressed data
            while (BytesAvailable && BytesCopied < 24)
            {
                *pTrace++ = *pCurrBuff++;
                BytesCopied++;
                BytesAvailable--;
            }

            break;


        // ArapExtractSRP: we're handing over 1 srp for routing or to dll
        case 21105:

            pArapBuf = (PARAPBUF)Context;
            pCurrBuff = pArapBuf->CurrentBuffer;
            BytesAvailable = pArapBuf->DataSize;

            // copy first 48 bytes of the decompressed data
            while (BytesAvailable && BytesCopied < 48)
            {
                *pTrace++ = *pCurrBuff++;
                BytesCopied++;
                BytesAvailable--;
            }
            break;


        // we just recvd a packet in ArapRcvIndication
        case 30105:

            BytesAvailable = dwInfo1-7;    // lookahead size, minus start,stop,crc
            pCurrBuff = ((PBYTE)Context)+3; // lookahead buffer plus 3 start

            PUTSHORT2SHORT(pTrace,(USHORT)BytesAvailable);
            pTrace += sizeof(USHORT);

            // copy first 24 bytes of the compressed data
            while (BytesAvailable && BytesCopied < 24)
            {
                *pTrace++ = *pCurrBuff++;
                BytesCopied++;
                BytesAvailable--;
            }

            break;

        // we recvd a 0-len packet!
        case 30106:

            break;

        // we decompressed the incoming data
        case 30110:

            // how much was the decompressed length
            PUTSHORT2SHORT(pTrace,(USHORT)dwInfo1);
            pTrace += sizeof(USHORT);

            if (dwInfo1 == 0)
            {
                break;
            }

            pArapBuf = (PARAPBUF)Context;

            BytesAvailable = pArapBuf->DataSize;      // len of decompressed data
            pCurrBuff = pArapBuf->CurrentBuffer;

            // copy first 48 bytes of the decompressed data
            while (BytesAvailable && BytesCopied < 48)
            {
                *pTrace++ = *pCurrBuff++;
                BytesCopied++;
                BytesAvailable--;
            }

            break;

        // attempting send when state was >= MNP_LDISCONNECTING
        case 30305:

            *pTrace = (BYTE)dwInfo1;       // store pArapConn->State
            break;

        // we just sent out a packet in ArapNdisSend()
        case 30320:

            pMnpSendBuf = (PMNPSENDBUF)Context;
            *pTrace++ = pMnpSendBuf->SeqNum;

            // how big is the MNP packet
            PUTSHORT2SHORT(pTrace,pMnpSendBuf->DataSize);
            pTrace += sizeof(USHORT);

            *pTrace++ = (BYTE)dwInfo1;    // is this a retransmission

            BytesAvailable = pMnpSendBuf->DataSize;
            pCurrBuff = (&pMnpSendBuf->Buffer[0]) + 3;  // skip start bytes

            // copy first 24 bytes of the compressed data
            while (BytesAvailable && BytesCopied < 24)
            {
                *pTrace++ = *pCurrBuff++;
                BytesCopied++;
                BytesAvailable--;
            }

        default:

            break;

    }

    DbgInfoLen = (USHORT)(pTrace - pStartTrace);

    pSniff->FrameLen = DbgInfoLen;

    pArapConn->pDbgCurrPtr = (PBYTE)ALIGN8(pTrace);

    // fill up the round-up space with 0s
    for (NOTHING; pTrace < pArapConn->pDbgCurrPtr; pTrace++)
    {
        *pTrace = 0;
    }

    // make sure we haven't overrun this buffer
    ASSERT(*((DWORD *)&(pArapConn->pDbgTraceBuffer[ARAP_SNIFF_BUFF_SIZE-4])) == 0xcafebeef);

    // how many more bytes did we add to the sniff buff?
    pArapConn->SniffedBytes += (DWORD)(pArapConn->pDbgCurrPtr - (PBYTE)pSniff);

    //
    // if we are about to overflow, just reset the pointer to beginning
    // (do it while we have still 200 bytes left)
    //
    BufLenSoFar = (DWORD)(pArapConn->pDbgCurrPtr - pArapConn->pDbgTraceBuffer);

error_end:

    if (BufLenSoFar > ARAP_SNIFF_BUFF_SIZE-200)
    {
	    DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_INFO,
                ("ArapDbgTrace: resetting debug buffer, Sniff data LOST!\n"));

        pArapConn->pDbgCurrPtr = pArapConn->pDbgTraceBuffer;

        pArapConn->SniffedBytes = 0;
    }
}

//***
//
// Function: ArapDbgTrace
//              This routine records history of MNP level packet exchange
//
// Parameters:  pArapConn - the connection in question
//              Seq - sequence number (if applicable)
//              FrameType - LT, LA etc.
//
// Return:      Nothing
//
// NOTE:        Spinlock is assumed to be held
//
//***$

VOID
ArapDbgMnpHist(
    IN PARAPCONN    pArapConn,
    IN BYTE         Seq,
    IN BYTE         FrameType
)
{
    LARGE_INTEGER   TimeNow;
    DWORD           ThisDelta;
    DWORD           DbgMnpIndex;


    KeQuerySystemTime(&TimeNow);

    if (TimeNow.HighPart == pArapConn->LastTimeStamp.HighPart)
    {
        ThisDelta = (TimeNow.LowPart - pArapConn->LastTimeStamp.LowPart);
    }
    else
    {
        ThisDelta = (0xffffffff - pArapConn->LastTimeStamp.LowPart + TimeNow.LowPart);
    }

    // convert 100's ns to ms
    ThisDelta = (ThisDelta/10000);

    pArapConn->LastTimeStamp = TimeNow;

    pArapConn->DbgMnpHist[pArapConn->DbgMnpIndex].TimeStamp = ThisDelta;
    pArapConn->DbgMnpHist[pArapConn->DbgMnpIndex].FrameInfo = (FrameType << 16);
    pArapConn->DbgMnpHist[pArapConn->DbgMnpIndex].FrameInfo |= Seq;

    // wrap-around if necessary
    if ((++pArapConn->DbgMnpIndex) >= DBG_MNP_HISTORY_SIZE)
    {
        pArapConn->DbgMnpIndex = 0;
    }

}


//***
//
// Function: ArapDbgDumpMnpHistory
//              This routine dumps history of MNP level packet exchange
//
// Parameters:  pArapConn - the connection in question
//
// Return:      Nothing
//
//***$

VOID
ArapDbgDumpMnpHist(
    IN PARAPCONN    pArapConn
)
{
    DWORD       i;
    DWORD       dwTmp;
    DWORD       dwDelta;
    BYTE        TmpSeq;


    if (!ArapDbgDumpOnDisconnect)
    {
        return;
    }

    DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
        ("DerefArapConn: Past history on %lx .....\n", pArapConn));

    // dump all info: old info first
    for (i=pArapConn->DbgMnpIndex; i<DBG_MNP_HISTORY_SIZE; i++)
    {
        dwDelta = pArapConn->DbgMnpHist[i].TimeStamp;
        dwTmp = (pArapConn->DbgMnpHist[i].FrameInfo & 0xffff0000);
        TmpSeq = (BYTE)(pArapConn->DbgMnpHist[i].FrameInfo & 0x000000ff);
        switch (dwTmp)
        {
            case 0x40000 : DbgPrint("   %6ld   NT sends %x\n",dwDelta,TmpSeq);break;
            case 0x50000 : DbgPrint("   %6ld                 NT acks %x\n",dwDelta,TmpSeq);break;
            case 0x140000: DbgPrint("   %6ld                 Mac sends %x\n",dwDelta,TmpSeq);break;
            case 0x150000: DbgPrint("   %6ld   Mac acks %x\n",dwDelta,TmpSeq);break;
            default      : DbgPrint("   %6ld   Unknown: %lx\n",dwDelta,pArapConn->DbgMnpHist[i].FrameInfo);
        }
    }

    // dump the current info
    for (i=0; i<pArapConn->DbgMnpIndex; i++)
    {
        dwDelta = pArapConn->DbgMnpHist[i].TimeStamp;
        dwTmp = (pArapConn->DbgMnpHist[i].FrameInfo & 0xffff0000);
        TmpSeq = (BYTE)(pArapConn->DbgMnpHist[i].FrameInfo & 0x000000ff);
        switch (dwTmp)
        {
            case 0x40000 : DbgPrint("   %6ld   NT sends %x\n",dwDelta,TmpSeq);break;
            case 0x50000 : DbgPrint("   %6ld                 NT acks %x\n",dwDelta,TmpSeq);break;
            case 0x140000: DbgPrint("   %6ld                 Mac sends %x\n",dwDelta,TmpSeq);break;
            case 0x150000: DbgPrint("   %6ld   Mac acks %x\n",dwDelta,TmpSeq);break;
            default      : DbgPrint("   %6ld   Unknown: %lx\n",dwDelta,pArapConn->DbgMnpHist[i].FrameInfo);
        }
    }
}

//***
//
// Function: ArapDumpNdisPktInfo
//              walk the ARAP connections list and find out how many Ndis packets
//              are in use right now
//
// Parameters:  nothing
//
// Return:      nothing
//
//***$

VOID
ArapDumpNdisPktInfo(
    IN VOID
)
{
    PARAPCONN       pArapConn;
    PLIST_ENTRY     pConnList;
    PLIST_ENTRY     pList;
    PMNPSENDBUF     pMnpSendBuf;
    KIRQL           OldIrql;
    DWORD           GrandTotal;
    DWORD           ReXmit;
    DWORD           ReXmitInNdis;
    DWORD           Fresh;
    DWORD           FreshInNdis;
    DWORD           ThisConn;
    DWORD           NumConns;



    if (!RasPortDesc)
    {
        return;
    }

    ACQUIRE_SPIN_LOCK(&RasPortDesc->pd_Lock, &OldIrql);

    pConnList = RasPortDesc->pd_ArapConnHead.Flink;

    GrandTotal = 0;
    NumConns = 0;

    DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
        ("NdisPacketInfo: counting total number of ndis packets used by ARAP....\n"));

    //
    // first, let's find the right connection to work on
    //
    while (pConnList != &RasPortDesc->pd_ArapConnHead)
    {
        ReXmit = 0;
        ReXmitInNdis = 0;
        Fresh = 0;
        FreshInNdis = 0;
        ThisConn = 0;

        pConnList = pConnList->Flink;

        pArapConn = CONTAINING_RECORD(pConnList, ARAPCONN, Linkage);

        ACQUIRE_SPIN_LOCK_DPC(&pArapConn->SpinLock);


        pList = pArapConn->RetransmitQ.Flink;

        // collect all buffers on the retransmit queue first
        while (pList != &pArapConn->RetransmitQ)
        {
            pList = pList->Flink;

            pMnpSendBuf = CONTAINING_RECORD(pList, MNPSENDBUF, Linkage);
            ReXmit++;
            if (pMnpSendBuf->Flags == 1)
            {
                ReXmitInNdis++;
            }
        }

        pList = pArapConn->HighPriSendQ.Flink;

        // collect all buffers on the fresh send
        while (pList != &pArapConn->HighPriSendQ)
        {
            pList = pList->Flink;

            pMnpSendBuf = CONTAINING_RECORD(pList, MNPSENDBUF, Linkage);
            Fresh++;
            if (pMnpSendBuf->Flags == 1)
            {
                FreshInNdis++;
            }
        }

        ThisConn = ReXmit+ReXmitInNdis+Fresh+FreshInNdis;

    	DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
            ("     %ld packets on %lx, %d in Ndis (%d+%d+%d+%d)\n",
            ThisConn,pArapConn,ReXmitInNdis,ReXmit,ReXmitInNdis,Fresh,FreshInNdis));

        GrandTotal += ThisConn;
        NumConns++;

        RELEASE_SPIN_LOCK_DPC(&pArapConn->SpinLock);

    }

    RELEASE_SPIN_LOCK(&RasPortDesc->pd_Lock, OldIrql);

    DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
        ("NdisPacketInfo: total of %ld Ndis Packets on %d connections\n",
        GrandTotal, NumConns));

}

#endif  // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\atalk\sys\arapndis.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	arap.c

Abstract:

	This module implements routines specific to ARAP

Author:

	Shirish Koti

Revision History:
	15 Nov 1996		Initial Version

--*/

#include 	<atalk.h>
#pragma hdrstop

#define	FILENUM		ARAPNDIS

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE_ARAP, ArapRcvIndication)
#pragma alloc_text(PAGE_ARAP, ArapNdisSend)
#pragma alloc_text(PAGE_ARAP, ArapNdisSendComplete)
#pragma alloc_text(PAGE_ARAP, ArapGetNdisPacket)
#endif


//***
//
// Function: ArapRcvIndication
//              This routine is called whenever Ndis calls the stack to indicate
//              data on a port.  We find out our context (pArapConn) from the
//              the 'fake' ethernet header that NdisWan cooks up.
//
// Parameters:  pArapConn - connection element for whom data has come in
//              LkBuf - buffer containing the (most likely, compressed) data
//              LkBufSize - size of the lookahead buffer
//
// Return:      none
//
// NOTE:        NdisWan always gives the entire buffer as the lookahead buffer,
//              and we rely on that fact!
//***$


VOID
ArapRcvIndication(
    IN PARAPCONN    pArapConn,
    IN PVOID        LkBuf,
    IN UINT         LkBufSize
)
{

    BYTE            MnpFrameType;
    BYTE            SeqNum = (BYTE)-1;
    BYTE            LastAckRcvd;
    BOOLEAN         fCopyPacket;
    BOOLEAN         fValidPkt;
    BOOLEAN         fMustAck;
    PLIST_ENTRY     pSendList;
    PLIST_ENTRY     pRecvList;
    PMNPSENDBUF     pMnpSendBuf;
    PARAPBUF        pArapBuf;
    PARAPBUF        pFirstArapBuf=NULL;
    BOOLEAN         fLessOrEqual;
    BOOLEAN         fAcceptPkt;
    BOOLEAN         fGreater;
    DWORD           DecompressedDataLen;
    DWORD           dwDataOffset=0;
    DWORD           dwFrameOverhead=0;
    DWORD           dwMaxAcceptableLen;
    DWORD           StatusCode;
    BOOLEAN         fSendLNAck=FALSE;
    BYTE            ClientCredit;
    BYTE            AttnType;
    BYTE            LNSeqToAck;
    DWORD           BufSizeEstimate;
    DWORD           DecompSize;
    DWORD           BytesDecompressed;
    DWORD           BytesToDecompress;
    DWORD           BytesRemaining;
    PBYTE           CompressedDataBuf;
    BYTE            BitMask;
    BYTE            RelSeq;



    DBG_ARAP_CHECK_PAGED_CODE();

    DBGDUMPBYTES("ArapRcvInd pkt rcvd: ",LkBuf,LkBufSize,3);

    //
    // we're at indicate time, so dpc
    //
    ACQUIRE_SPIN_LOCK_DPC(&pArapConn->SpinLock);

    //
    // if the connection is going away, drop the packet
    //
    if ( (pArapConn->State == MNP_IDLE) || (pArapConn->State > MNP_UP) )
    {
        DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
            ("ArapRcvIndication: invalid state = %d, returning (%lx %lx)\n",
                pArapConn,pArapConn->State));

        RELEASE_SPIN_LOCK_DPC(&pArapConn->SpinLock);
        return;
    }

    // one more frame came in
    pArapConn->StatInfo.FramesRcvd++;

    //
    // if a dup LR comes in, SynByte, DleByte etc. aren't set yet, and we hit
    // this assert. just check to see if we are in MNP_RESPONSE state
    //
    ASSERT( ((((PUCHAR)LkBuf)[0] == pArapConn->MnpState.SynByte) &&
             (((PUCHAR)LkBuf)[1] == pArapConn->MnpState.DleByte) &&
             (((PUCHAR)LkBuf)[2] == pArapConn->MnpState.StxByte) &&
             (((PUCHAR)LkBuf)[LkBufSize-4] == pArapConn->MnpState.DleByte) &&
             (((PUCHAR)LkBuf)[LkBufSize-3] == pArapConn->MnpState.EtxByte)) ||
            (pArapConn->State == MNP_RESPONSE) );

    ARAP_DBG_TRACE(pArapConn,30105,LkBuf,LkBufSize,0,0);

    // we just heard from the client: "reset" the inactivity timer
    pArapConn->InactivityTimer = pArapConn->T403Duration + AtalkGetCurrentTick();

    MnpFrameType = ((PUCHAR)LkBuf)[MNP_FRMTYPE_OFFSET];

    if ( MnpFrameType == MNP_LT_V20CLIENT )
    {
        MnpFrameType = (BYTE)MNP_LT;
    }

    fCopyPacket = FALSE;
    fValidPkt = TRUE;
    fMustAck = FALSE;

    dwDataOffset = 3;      // at the least, we'll ignore the 3 start flag bytes
    dwFrameOverhead = 7;   // at the least, ignore 3 start, 2 stop, 2 crc bytes

    switch(MnpFrameType)
    {
        //
        // if this is a duplicate LT frame, don't waste time decompressing and
        // copying (also, make sure we have room to accept this packet!)
        //
        case MNP_LT:

            fValidPkt = FALSE;

            if (LkBufSize < (UINT)LT_MIN_LENGTH(pArapConn))
            {
                DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                    ("ArapRcv: (%lx) LT pkt, but length invalid: dropping!\n",pArapConn));
                ASSERT(0);
                break;
            }

            SeqNum = LT_SEQ_NUM((PBYTE)LkBuf, pArapConn);

            MNP_DBG_TRACE(pArapConn,SeqNum,(0x10|MNP_LT));

            dwMaxAcceptableLen = (pArapConn->BlockId == BLKID_MNP_SMSENDBUF) ?
                                    MNP_MINPKT_SIZE : MNP_MAXPKT_SIZE;

            if ((pArapConn->State == MNP_UP) &&
                (pArapConn->MnpState.RecvCredit > 0) )
            {
                LT_OK_TO_ACCEPT(SeqNum, pArapConn, fAcceptPkt);

                if (fAcceptPkt)
                {
                    fCopyPacket = TRUE;

                    fValidPkt = TRUE;

                    dwDataOffset = LT_SRP_OFFSET(pArapConn);
                    dwFrameOverhead = LT_OVERHEAD(pArapConn);

                    // make sure the packet isn't too big (in other words,invalid!)
                    if (LkBufSize-dwFrameOverhead > dwMaxAcceptableLen)
                    {
                        DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                            ("ArapInd: (%lx) too big a pkt (%d vs %d), dropped\n",
                                pArapConn,LkBufSize-dwFrameOverhead,dwMaxAcceptableLen));

                        fValidPkt = FALSE;
                    }

                    pArapConn->MnpState.HoleInSeq = FALSE;
                }
                else
                {
                    //
                    // packet is valid, just not in the right sequence (make note
                    // of that or else we'll send out an ack!)
                    //
                    fValidPkt = TRUE;

                    //
                    // did we get an out-of-sequence packet (e.g. we lost B5,
                    // so we're still expecting B5 but B6 came in)
                    //
                    LT_GREATER_THAN(SeqNum,
                                    pArapConn->MnpState.NextToReceive,
                                    fGreater);
                    if (fGreater)
                    {
                        //
                        // we have already sent an ack out when we first got
                        // this hole: don't send ack again
                        //
                        if (pArapConn->MnpState.HoleInSeq)
                        {
                            fMustAck = FALSE;
                        }
                        else
                        {
                            pArapConn->MnpState.HoleInSeq = TRUE;

                            fMustAck = TRUE;

                            DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_INFO,
                                ("ArapRcvInd: (%lx) got a hole, dropping seq=%x vs. %x\n",
                                    pArapConn, SeqNum, pArapConn->MnpState.NextToReceive));
                        }

                        break;
                    }

                    //
                    // spec says that we must ignore the first duplicate of any
                    // seq.  What happens most often when we receive a duplicate is
                    // that the Mac sends the whole window full of dups.  e.g. if
                    // seq num B1 is retransmitted then Mac will also retransmit
                    // B2, .. B8.  We should ignore all of them, but if we get B1
                    // (or anything upto B8) again, then we must send out an ack.
                    //

                    //
                    // is this the first time (since we successfully received a
                    // new frame) that we are getting a dup?  If so, we must find
                    // out what's the smallest seq number we can get as a dup
                    //
                    if (!pArapConn->MnpState.ReceivingDup)
                    {
                        //
                        // e.g. if we're expecting seq 79 then 0x71 is the
                        // smallest dup that we can get (for window size = 8)
                        //
                        if (pArapConn->MnpState.NextToReceive >=
                            pArapConn->MnpState.WindowSize)
                        {
                            pArapConn->MnpState.FirstDupSeq =
                                (pArapConn->MnpState.NextToReceive -
                                 pArapConn->MnpState.WindowSize);
                        }

                        //
                        // e.g. if we're expecting seq 3 then 0xfb is the
                        // smallest dup that we can get (for window size = 8)
                        //
                        else
                        {
                            pArapConn->MnpState.FirstDupSeq =
                                (0xff -
                                (pArapConn->MnpState.WindowSize -
                                 pArapConn->MnpState.NextToReceive) +
                                 1);
                        }

                        pArapConn->MnpState.ReceivingDup = TRUE;
                        pArapConn->MnpState.DupSeqBitMap = 0;
                        RelSeq = 0;
                    }

                    //
                    // find the relative seq number (relative to the first dup)
                    //
                    if (SeqNum >= pArapConn->MnpState.FirstDupSeq)
                    {
                        RelSeq = (SeqNum - pArapConn->MnpState.FirstDupSeq);
                    }
                    else
                    {
                        RelSeq = (0xff - pArapConn->MnpState.FirstDupSeq) +
                                 SeqNum;
                    }

                    //
                    // 8-frame window: relseq can be 0 through 7
                    //
                    if (RelSeq >= 8)
                    {
                        DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                            ("ArapRcvInd: (%lx) RelSeq > 8!! (%x %x %x)\n",
                                pArapConn, SeqNum, pArapConn->MnpState.FirstDupSeq,
                                pArapConn->MnpState.DupSeqBitMap));

                        fMustAck = TRUE;
                        break;
                    }

                    BitMask = (1 << RelSeq);

                    //
                    // is this a second (or more) retransmission of this seq num?
                    //
                    if (pArapConn->MnpState.DupSeqBitMap & BitMask)
                    {
                        DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_INFO,
                            ("ArapRcvInd: (%lx) dup pkt, seq=%x vs. %x (%x)\n",
                                pArapConn, SeqNum, pArapConn->MnpState.FirstDupSeq,
                                pArapConn->MnpState.DupSeqBitMap));

                        fMustAck = TRUE;
                    }

                    //
                    // no, this is the first time: don't send out an ack
                    //
                    else
                    {
                        pArapConn->MnpState.DupSeqBitMap |= BitMask;

                        DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_INFO,
                            ("ArapRcvInd: (%lx) first dup pkt, seq=%x vs. %x (%x)\n",
                                pArapConn, SeqNum, pArapConn->MnpState.FirstDupSeq,
                                pArapConn->MnpState.DupSeqBitMap));
                    }
                }
            }
            else
            {
                DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                    ("ArapInd: (%lx) pkt dropped (state %ld, credit %ld)\n",
                    pArapConn,pArapConn->State,pArapConn->MnpState.RecvCredit));
            }

            break;

        //
        // we got an ACK: process it
        //
        case MNP_LA:

            if (LkBufSize < (UINT)LA_MIN_LENGTH(pArapConn))
            {
                DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                    ("ArapRcv: (%lx) LA pkt, but length invalid: dropping!\n",pArapConn));
                ASSERT(0);
                break;
            }

            // client's receive credit (it's our send credit)
            ClientCredit = LA_CREDIT((PBYTE)LkBuf, pArapConn);

            ASSERT((pArapConn->State == MNP_UP) || (pArapConn->State == MNP_RESPONSE));

            // last pkt the client recvd successfully from us
            LastAckRcvd = LA_SEQ_NUM((PBYTE)LkBuf, pArapConn);

            MNP_DBG_TRACE(pArapConn,LastAckRcvd,(0x10|MNP_LA));

            //
            // in the normal case, the ack we got should be for a bigger seq num
            // than the one we got earlier.
            // (special case the MNP_RESPONSE state to complete conn setup)
            //
            LT_GREATER_THAN(LastAckRcvd,pArapConn->MnpState.LastAckRcvd,fGreater);

            if (fGreater || (pArapConn->State == MNP_RESPONSE))
            {
                pArapConn->MnpState.LastAckRcvd = LastAckRcvd;

                //
                // remove all the sends upto and including LastAckRcvd and put
                // them on SendAckedQ so that RcvCompletion can finish up the job
                //
                ASSERT(!IsListEmpty(&pArapConn->RetransmitQ));

                ASSERT(pArapConn->SendsPending > 0);

                //
                // if we sent a response to LR and were waiting for client's
                // ack, this is it!  (RcvCompletion will do the remaining work)
                //
                if (pArapConn->State == MNP_RESPONSE)
                {
                    pArapConn->State = MNP_UP;
                    pArapConn->MnpState.NextToReceive = 1;
                    pArapConn->MnpState.NextToProcess = 1;
                    pArapConn->MnpState.NextToSend = 1;

                    pArapConn->FlowControlTimer = AtalkGetCurrentTick() +
                                                    pArapConn->T404Duration;
                }

                //
                // remove all the sends that are now acked with this ack from the
                // retransmit queue
                //
                while (1)
                {
                    pSendList = pArapConn->RetransmitQ.Flink;

                    // no more sends left on the retransmit queue? if so, done
                    if (pSendList == &pArapConn->RetransmitQ)
                    {
                        break;
                    }

                    pMnpSendBuf = CONTAINING_RECORD(pSendList,MNPSENDBUF,Linkage);

                    LT_LESS_OR_EQUAL(pMnpSendBuf->SeqNum,LastAckRcvd,fLessOrEqual);

                    if (fLessOrEqual)
                    {
                        ASSERT(pArapConn->SendsPending >= pMnpSendBuf->DataSize);

                        RemoveEntryList(&pMnpSendBuf->Linkage);

	                    InsertTailList(&pArapConn->SendAckedQ,
				                       &pMnpSendBuf->Linkage);

                        ASSERT(pArapConn->MnpState.UnAckedSends >= 1);

                        pArapConn->MnpState.UnAckedSends--;
                    }
                    else
                    {
                        // all other sends have higher seq nums: done here
                        break;
                    }
                }

                //
                // if we were in the retransmit mode and the retransmit Q is
                // now empty, get out of retransmit mode!
                //
                if (pArapConn->MnpState.RetransmitMode)
                {
                    if (pArapConn->MnpState.UnAckedSends == 0)
                    {
                        pArapConn->MnpState.RetransmitMode = FALSE;
                        pArapConn->MnpState.MustRetransmit = FALSE;

                        // in case we had gone on a "exponential backoff", reset it
                        pArapConn->SendRetryTime = pArapConn->SendRetryBaseTime;

		                DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_INFO,
			                ("ArapRcvInd: ack %x for xmitted pkt, out of re-xmit mode\n",
                            LastAckRcvd));
                    }
                    else
                    {
		                DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_INFO,
			                ("ArapRcvInd: ack %x for xmitted pkt, still %d more\n",
                            LastAckRcvd,pArapConn->MnpState.UnAckedSends));

                        pArapConn->MnpState.MustRetransmit = TRUE;
                    }
                }
            }

            //
            // the ack we got is for the same seq num as we got earlier: we need
            // to retransmit the send we were hoping this ack was for!
            //
            else
            {
                if (!IsListEmpty(&pArapConn->RetransmitQ))
                {
                    pArapConn->MnpState.RetransmitMode = TRUE;
                    pArapConn->MnpState.MustRetransmit = TRUE;

		            DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_INFO,
			            ("\nArapRcvInd: ack %x again, (%d pkts) entering re-xmit mode\n",
                        LastAckRcvd,pArapConn->MnpState.UnAckedSends));
                }
            }

            ASSERT(pArapConn->MnpState.UnAckedSends <= pArapConn->MnpState.WindowSize);

            //
            // spec says our credit is what the client tells us minus the number
            // of unacked sends on our Q.
            //
            //
            if (ClientCredit > pArapConn->MnpState.UnAckedSends)
            {
                ASSERT((ClientCredit - pArapConn->MnpState.UnAckedSends) <= pArapConn->MnpState.WindowSize);

                pArapConn->MnpState.SendCredit =
                    (ClientCredit - pArapConn->MnpState.UnAckedSends);
            }

            //
            // But if the client tells us say 3 and we have 4 sends pending,
            // be conservative and close the window until sends get cleared up
            //
            else
            {
                pArapConn->MnpState.SendCredit = 0;
            }

            break;

        //
        // if we sent an LR response, this must be a retry by client: retransmit
        // our response.  If we sent in the request (in case of callback) then
        // this is the response: send the ack
        //
        case MNP_LR:

            MNP_DBG_TRACE(pArapConn,0,(0x10|MNP_LR));

	        DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                ("ArapRcvInd: got LR pkt on %lx, state=%d\n",
                    pArapConn,pArapConn->State));

            if (pArapConn->State == MNP_RESPONSE)
            {
		        DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
			        ("ArapRcvInd: excuse me?  got an LR! (setting reX)\n"));

                pArapConn->MnpState.RetransmitMode = TRUE;
                pArapConn->MnpState.MustRetransmit = TRUE;
            }
            else if (pArapConn->State == MNP_REQUEST)
            {
                //
                // we got an LR response to our LR request (we are doing callback)
                // Make sure all the parms that the dial-in client gives are ok
                // with us, and configure pArapConn appropriately
                //
                StatusCode = PrepareConnectionResponse( pArapConn,
                                                        LkBuf,
                                                        LkBufSize,
                                                        NULL,
                                                        NULL);
                if (StatusCode == ARAPERR_NO_ERROR)
                {
                    pArapConn->State = MNP_UP;
                    pArapConn->MnpState.NextToReceive = 1;
                    pArapConn->MnpState.NextToProcess = 1;
                    pArapConn->MnpState.NextToSend = 1;

                    pArapConn->FlowControlTimer = AtalkGetCurrentTick() +
                                                    pArapConn->T404Duration;

                    pSendList = pArapConn->RetransmitQ.Flink;

                    // treat the connection request as a send here
                    if (pSendList != &pArapConn->RetransmitQ)
                    {
                        pMnpSendBuf = CONTAINING_RECORD(pSendList,
                                                        MNPSENDBUF,
                                                        Linkage);

                        RemoveEntryList(&pMnpSendBuf->Linkage);

	                    InsertTailList(&pArapConn->SendAckedQ,
				                       &pMnpSendBuf->Linkage);

                        ASSERT(pArapConn->MnpState.UnAckedSends >= 1);

                        pArapConn->MnpState.UnAckedSends--;
                    }
                    else
                    {
		                DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
			                ("ArapRcvInd: (%lx) can't find LR request\n",pArapConn));
                        ASSERT(0);
                    }

                    fMustAck = TRUE;
                }
                else
                {
		            DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
			            ("ArapRcvInd: (%lx) invalid LR response %ld\n",
                            pArapConn,StatusCode));
                }
            }
            else
            {
                fValidPkt = FALSE;
            }

            break;

        //
        // remote sent a disconnect request.  Though we'll process it at
        // RcvCompletion time, mark it so that we don't attempt send/recv anymore
        //
        case MNP_LD:

            MNP_DBG_TRACE(pArapConn,0,(0x10|MNP_LD));

            DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                ("ArapRcvIndication: recvd disconnect from remote on (%lx)\n",pArapConn));

            pArapConn->State = MNP_RDISC_RCVD;
            fCopyPacket = TRUE;

            break;

        //
        // remote sent a Link Attention request.  See what we need to do
        //
        case MNP_LN:

            if (LkBufSize < (dwDataOffset+LN_MIN_LENGTH))
            {
                DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                    ("ArapRcv: (%lx) LN pkt, but length invalid: dropping!\n",pArapConn));
                ASSERT(0);
                break;
            }

            MNP_DBG_TRACE(pArapConn,0,(0x10|MNP_LN));

            AttnType = LN_ATTN_TYPE((PBYTE)LkBuf+dwDataOffset);

            LNSeqToAck = LN_ATTN_SEQ((PBYTE)LkBuf+dwDataOffset);

            //
            // is this a destructive type LN frame?  Treat this as a LD frame so
            // that we disconnect and cleanup the connection
            //
            if (AttnType == LN_DESTRUCTIVE)
            {
                DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                    ("ArapRcv: (%lx) got an LN pkt, sending LNAck!\n",pArapConn));

                pArapConn->State = MNP_RDISC_RCVD;
            }

            //
            // ok, he just wants to know if we are doing ok: tell him so
            //
            else
            {
                DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                    ("ArapRcv: (%lx) got an LN pkt, sending LNAck!\n",pArapConn));

                fSendLNAck = TRUE;
            }

            break;

        //
        // we only ack an LN packet, but never generate an LN packet
        // so we should never get this LNA packet.  Quietly drop it.
        //
        case MNP_LNA:

            MNP_DBG_TRACE(pArapConn,0,(0x10|MNP_LNA));

            DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                ("ArapRcv: (%lx) got LNA. Now, when did we send LN??\n",pArapConn));

            break;

        default:

            MNP_DBG_TRACE(pArapConn,0,MnpFrameType);

            DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                ("ArapRcvIndication: (%lx) dropping packet with unknown type %d\n",
                    pArapConn,MnpFrameType));

            break;
    }

    //
    // if it's a packet that we don't need to copy (e.g. ack) then we're done here.
    // Also, if it's an invalid pkt (e.g. out of seq packet) then we must send an ack
    //
    if ((!fCopyPacket) || (!fValidPkt))
    {
        RELEASE_SPIN_LOCK_DPC(&pArapConn->SpinLock)

        //
        // if we got an invalid packet or if we have a condition where we must ack,
        // do the needful
        //
        if (!fValidPkt || fMustAck)
        {
            MnpSendAckIfReqd(pArapConn, TRUE);
        }
        else if (fSendLNAck)
        {
            MnpSendLNAck(pArapConn, LNSeqToAck);
        }

        return;
    }

    //
    // if it's not an LT packet, treat it separately
    //
    if (MnpFrameType != MNP_LT)
    {
        // right now LD is the only packet we put on the Misc Q
        ASSERT(MnpFrameType == MNP_LD);

        ARAP_GET_RIGHTSIZE_RCVBUF((LkBufSize-dwFrameOverhead), &pArapBuf);
        if (pArapBuf == NULL)
        {
            DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                ("ArapInd: (%lx) alloc failed, dropping packet (type=%x, seq=%x)\n",
                pArapConn,MnpFrameType,SeqNum));

            RELEASE_SPIN_LOCK_DPC(&pArapConn->SpinLock)
            return;
        }

	    TdiCopyLookaheadData( &pArapBuf->Buffer[0],
                              (PUCHAR)LkBuf+dwDataOffset,
                              LkBufSize-dwFrameOverhead,
                              TDI_RECEIVE_COPY_LOOKAHEAD);

        pArapBuf->MnpFrameType = MnpFrameType;
        pArapBuf->DataSize = (USHORT)(LkBufSize-dwFrameOverhead);

	    InsertTailList(&pArapConn->MiscPktsQ, &pArapBuf->Linkage);

        RELEASE_SPIN_LOCK_DPC(&pArapConn->SpinLock)
        return;
    }


    //
    // ok, we're dealing with the LT packet (the most common packet)
    //

    // reset the flow control timer
    pArapConn->FlowControlTimer = AtalkGetCurrentTick() + pArapConn->T404Duration;


    // update the receive state...

    ASSERT(pArapConn->MnpState.UnAckedRecvs <= pArapConn->MnpState.WindowSize);

    pArapConn->MnpState.UnAckedRecvs++;

    // set LastSeqRcvd to what we received successfully just now
    pArapConn->MnpState.LastSeqRcvd = pArapConn->MnpState.NextToReceive;

    // successfully rcvd the expected packet.  Update to next expected
    ADD_ONE(pArapConn->MnpState.NextToReceive);

    //
    // if the 402 timer isn't already "running", "start" it
    // Also, shut the flow-control timer: starting T402 timer here will ensure
    // that ack goes out, and at that time we'll restart the flow-control timer
    //
    if (pArapConn->LATimer == 0)
    {
        pArapConn->LATimer = pArapConn->T402Duration + AtalkGetCurrentTick();
        pArapConn->FlowControlTimer = 0;
    }

    //
    // 0-length data is not permissible
    // (for some reason, Mac sends a 0-datalength frame: for now, we'll
    // "accept" the frame, though we can't do anything with it!)
    //
    if ((LkBufSize-dwFrameOverhead) == 0)
    {
        ARAP_DBG_TRACE(pArapConn,30106,LkBuf,LkBufSize,0,0);

        DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_INFO,
           ("ArapInd: (%lx) is the client on drugs?  it's sending 0-len data!\n",pArapConn));

        RELEASE_SPIN_LOCK_DPC(&pArapConn->SpinLock)

        return;
    }


    pFirstArapBuf = NULL;

    BytesToDecompress  = (DWORD)LkBufSize-dwFrameOverhead;
    CompressedDataBuf = (PUCHAR)LkBuf+dwDataOffset;

    DecompressedDataLen = 0;

    //
    // for now, assume decompressed data will be 4 times the compressed size
    // (if that assumption isn't true, we'll alloc more again)
    //
    BufSizeEstimate = (BytesToDecompress << 2);

    if (!(pArapConn->Flags & MNP_V42BIS_NEGOTIATED))
    {
        BufSizeEstimate = BytesToDecompress;
    }

    while (1)
    {
        // get a receive buffer for this size
        ARAP_GET_RIGHTSIZE_RCVBUF(BufSizeEstimate, &pArapBuf);

        if (pArapBuf == NULL)
        {
            DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                ("ArapInd: (%lx) %d bytes alloc failed, dropping seq=%x\n",
                    pArapConn,BufSizeEstimate,SeqNum));

            //
            // if we put any stuff on the queue for this MNP packet, remove
            // them all: we can't have a partially decompressed packet!
            //
            if (pFirstArapBuf)
            {
                pRecvList = &pFirstArapBuf->Linkage;

                while (pRecvList != &pArapConn->ReceiveQ)
                {
                    RemoveEntryList(pRecvList);

                    pArapBuf = CONTAINING_RECORD(pRecvList,ARAPBUF,Linkage);

                    ARAP_FREE_RCVBUF(pArapBuf);

                    pRecvList = pRecvList->Flink;
                }
            }

            RELEASE_SPIN_LOCK_DPC(&pArapConn->SpinLock)

            // force ack so the client gets a hint that we dropped a pkt
            MnpSendAckIfReqd(pArapConn, TRUE);

            return;
        }

        if (!pFirstArapBuf)
        {
            pFirstArapBuf = pArapBuf;
        }

        //
        // ok, do that v42bis decompression thing if v42bis is negotiated
        //
        if (pArapConn->Flags & MNP_V42BIS_NEGOTIATED)
        {
            StatusCode = v42bisDecompress(
                                pArapConn,
                                CompressedDataBuf,
                                BytesToDecompress,
                                pArapBuf->CurrentBuffer,
                                pArapBuf->BufferSize,
                                &BytesRemaining,
                                &DecompSize);
        }

        //
        // v42bis is not negotiated: skip decompression
        //
        else
        {
            if (BytesToDecompress)
            {
	            TdiCopyLookaheadData( &pArapBuf->Buffer[0],
                                      (PUCHAR)LkBuf+dwDataOffset,
                                      BytesToDecompress,
                                      TDI_RECEIVE_COPY_LOOKAHEAD);
            }

            DecompSize = BytesToDecompress;
            StatusCode = ARAPERR_NO_ERROR;
        }

        ASSERT((StatusCode == ARAPERR_NO_ERROR) ||
               (StatusCode == ARAPERR_BUF_TOO_SMALL));

        if ((StatusCode != ARAPERR_NO_ERROR) &&
            (StatusCode != ARAPERR_BUF_TOO_SMALL))
        {
            DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                ("ArapInd: (%lx) v42bisDecompress returned %lx, dropping pkt\n",
                    pArapConn,StatusCode));

            ASSERT(0);

            RELEASE_SPIN_LOCK_DPC(&pArapConn->SpinLock)

            // force ack so the client gets a hint that we dropped a pkt
            MnpSendAckIfReqd(pArapConn, TRUE);

            return;
        }

        //
        // if we got any bytes decompressed, put them on the queue
        //
        if (DecompSize > 0)
        {
            ASSERT(pArapBuf->BufferSize >= DecompSize);

            pArapBuf->DataSize = (USHORT)DecompSize;

            // Debug only: make sure q looks ok before we put this stuff on the q
            ARAP_CHECK_RCVQ_INTEGRITY(pArapConn);

            // queue these bytes on to the ReceiveQ
	        InsertTailList(&pArapConn->ReceiveQ, &pArapBuf->Linkage);

            // Debug only: make sure q looks ok after we put this stuff on the q
            ARAP_CHECK_RCVQ_INTEGRITY(pArapConn);
        }

        DecompressedDataLen += DecompSize;

        // are we done decompressing?
        if (StatusCode == ARAPERR_NO_ERROR)
        {
            //
            // if there was no output data and there was no error, we didn't
            // really need this buffer.
            //
            if (DecompSize == 0)
            {
                ARAP_FREE_RCVBUF(pArapBuf);
            }

            break;
        }


        //
        // ok, we're here because our assumption about how big a buffer we
        // needed for decompression wasn't quite right: we must decompress the
        // remaining bytes now
        //

        BytesDecompressed = (BytesToDecompress - BytesRemaining);
        BytesToDecompress = BytesRemaining;
        CompressedDataBuf += BytesDecompressed;

        //
        // we ran out of room:double our initial estimate
        //
        BufSizeEstimate <<= 1;
    }

    ARAP_DBG_TRACE(pArapConn,30110,pFirstArapBuf,DecompressedDataLen,0,0);

    // update statitics on incoming bytes:
    pArapConn->StatInfo.BytesRcvd += (DWORD)LkBufSize;
    pArapConn->StatInfo.BytesReceivedCompressed += ((DWORD)LkBufSize-dwFrameOverhead);
    pArapConn->StatInfo.BytesReceivedUncompressed += DecompressedDataLen;

#if DBG
    ArapStatistics.RecvPostDecompMax =
            (DecompressedDataLen > ArapStatistics.RecvPostDecompMax)?
            DecompressedDataLen : ArapStatistics.RecvPostDecompMax;

    ArapStatistics.RecvPostDecomMin =
            (DecompressedDataLen < ArapStatistics.RecvPostDecomMin)?
            DecompressedDataLen : ArapStatistics.RecvPostDecomMin;
#endif


    // we successfully received a brand new packet, so we aren't getting dup's
    pArapConn->MnpState.ReceivingDup = FALSE;

    // we have these many bytes more waiting to be processed
    pArapConn->RecvsPending += DecompressedDataLen;

    ARAP_ADJUST_RECVCREDIT(pArapConn);

    RELEASE_SPIN_LOCK_DPC(&pArapConn->SpinLock);

    // see if ack needs to be sent for the packet we just received
    MnpSendAckIfReqd(pArapConn, FALSE);

}




//***
//
// Function: ArapRcvComplete
//              This is the RcvComplete routine for the Arap port.
//              We look through all the clients on this port (i.e. all the
//              Arap clients) to see who needs work done, and finish it.
//
// Parameters:  none
//
// Return:      none
//
//***$

VOID
ArapRcvComplete(
    IN VOID
)
{
    PARAPCONN           pArapConn;
    PARAPCONN           pPrevArapConn;
    PLIST_ENTRY         pConnList;
    PLIST_ENTRY         pSendAckedList;
    PLIST_ENTRY         pList;
    KIRQL               OldIrql;
    BOOLEAN             fRetransmitting;
    BOOLEAN             fReceiveQEmpty;
    PMNPSENDBUF         pMnpSendBuf=NULL;
    PMNPSENDBUF         pRetransmitBuf=NULL;
    PARAPBUF            pArapBuf=NULL;
    DWORD               BytesProcessed=0;
    BOOLEAN             fArapDataWaiting;
    BOOLEAN             fArapConnUp=FALSE;



    //
    // walk through all the Arap clients to see if anyone has data to be
    // processed.
    // Start from the head of the list
    //  1 if the connection state is not ok, try the next connection
    //      else up the refcount (to make sure it stays around until we're done)
    //  2  see if we need to disconnect: if yes, do so and move on
    //  3  see if retransmits are needed
    //  4  see if ack needs to be sent
    //  5  see if any sends need to be completed
    //  6  see if any receives need to be completed
    //  7 Find the next connection which we will move to next
    //  8 remove the refcount on the previous connection that we put in step 1
    //

    pArapConn = NULL;
    pPrevArapConn = NULL;

    while (1)
    {
        ACQUIRE_SPIN_LOCK(&RasPortDesc->pd_Lock, &OldIrql);

        //
        // first, let's find the right connection to work on
        //
        while (1)
        {
            // if we're in the middle of the list, get to the next guy
            if (pArapConn != NULL)
            {
                pConnList = pArapConn->Linkage.Flink;
            }
            // we're just starting: get the guy at the head of the list
            else
            {
                pConnList = RasPortDesc->pd_ArapConnHead.Flink;
            }

            // finished all?
            if (pConnList == &RasPortDesc->pd_ArapConnHead)
            {
                RELEASE_SPIN_LOCK(&RasPortDesc->pd_Lock, OldIrql);

                if (pPrevArapConn)
                {
                    DerefArapConn(pPrevArapConn);
                }
                return;
            }

            pArapConn = CONTAINING_RECORD(pConnList, ARAPCONN, Linkage);

            // make sure this connection needs rcv processing
            ACQUIRE_SPIN_LOCK_DPC(&pArapConn->SpinLock);

            //
            // if this connection is being disconnected, skip it (unless we
            // just received disconnect from remote, in which case we need to
            // process that)
            //
            if ((pArapConn->State >= MNP_LDISCONNECTING) &&
                (pArapConn->State != MNP_RDISC_RCVD))
            {
	            DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_INFO,
		            ("ArapRcvComplete: (%lx) invalid state %d, no rcv processing done\n",
                        pArapConn,pArapConn->State));

                RELEASE_SPIN_LOCK_DPC(&pArapConn->SpinLock);

                // go try the next connection
                continue;
            }

            // let's make sure this connection stays around till we finish
            pArapConn->RefCount++;

            RELEASE_SPIN_LOCK_DPC(&pArapConn->SpinLock);

            break;
        }

        RELEASE_SPIN_LOCK(&RasPortDesc->pd_Lock, OldIrql);

        //
        // remove the refcount on the previous connection we put in for the Rcv
        //
        if (pPrevArapConn)
        {
            DerefArapConn(pPrevArapConn);
        }

        ASSERT(pPrevArapConn != pArapConn);

        pPrevArapConn = pArapConn;

        fRetransmitting = FALSE;
        fArapConnUp = FALSE;

        // if our sniff buffer has enough bytes, give them to dll and make room
        ARAP_DUMP_DBG_TRACE(pArapConn);

        ACQUIRE_SPIN_LOCK(&pArapConn->SpinLock, &OldIrql);

        //
        // if we got a disconnect from remote (LD frame), we have cleanup to do
        //
        if (pArapConn->State == MNP_RDISC_RCVD)
        {
	        DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
		        ("ArapRcvComplete: (%lx) disconnect rcvd from remote, calling cleanup\n",
                    pArapConn));

            pArapConn->State = MNP_RDISCONNECTING;

            RELEASE_SPIN_LOCK(&pArapConn->SpinLock, OldIrql);

            ArapCleanup(pArapConn);

            // go process the next connection
            continue;
        }

        //
        // do we need to retransmit the sends queued up on the retransmit Q?
        //
        if (pArapConn->MnpState.MustRetransmit)
        {
            pList = pArapConn->RetransmitQ.Flink;

            if (pList != &pArapConn->RetransmitQ)
            {
                pRetransmitBuf = CONTAINING_RECORD(pList, MNPSENDBUF, Linkage);

                fRetransmitting = TRUE;

                if (pRetransmitBuf->RetryCount >= ARAP_MAX_RETRANSMITS)
                {
                    RemoveEntryList(&pRetransmitBuf->Linkage);

                    ASSERT(pArapConn->MnpState.UnAckedSends >= 1);

                    // not really important, since we're about to disconnect!
                    pArapConn->MnpState.UnAckedSends--;

                    ASSERT(pArapConn->SendsPending >= pRetransmitBuf->DataSize);

#if DBG
                    InitializeListHead(&pRetransmitBuf->Linkage);
#endif

	                DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
		                ("ArapRcvComplete: (%lx) too many retransmits (%lx).  Killing %lx\n",
                            pRetransmitBuf,pArapConn));

                    RELEASE_SPIN_LOCK(&pArapConn->SpinLock, OldIrql);

                    (pRetransmitBuf->ComplRoutine)(pRetransmitBuf,ARAPERR_SEND_FAILED);

                    continue;
                }
            }
        }

        //
        // See if any sends can be completed as a result of an ack coming in
        // (now that we have the spinlock, move the list away and mark the list as
        // empty before we release the lock.  Idea is to avoid grab-release-grab..
        // of spinlock as we complete all the sends).
        //
        pSendAckedList = pArapConn->SendAckedQ.Flink;
        InitializeListHead(&pArapConn->SendAckedQ);

        // is ARAP connection up yet?  we'll use this fact very soon...
        if (pArapConn->Flags & ARAP_CONNECTION_UP)
        {
            fArapConnUp = TRUE;
        }

        RELEASE_SPIN_LOCK(&pArapConn->SpinLock, OldIrql);


        //
        // next, handle any retransmissions if needed
        //
        if (fRetransmitting)
        {
            ArapNdisSend(pArapConn, &pArapConn->RetransmitQ);
        }

        //
        // next, complete all our sends for which we received ack(s)
        //
        while (pSendAckedList != &pArapConn->SendAckedQ)
        {
            pMnpSendBuf = CONTAINING_RECORD(pSendAckedList,MNPSENDBUF,Linkage);

            pSendAckedList = pSendAckedList->Flink;

            InitializeListHead(&pMnpSendBuf->Linkage);

            //
            // call the completion routine for this send buffer
            //
            (pMnpSendBuf->ComplRoutine)(pMnpSendBuf,ARAPERR_NO_ERROR);
        }


        // see if ack needs to be sent, for any packets we received
        MnpSendAckIfReqd(pArapConn, FALSE);


        //
        // and finally, process all the packets on the recieve queue!
        //

        BytesProcessed = 0;
        while (1)
        {
            if ((pArapBuf = ArapExtractAtalkSRP(pArapConn)) == NULL)
            {
                // no more data left (or no complete SRP yet): done here
                break;
            }

            // is ARAP connection up?  route only if it's up, otherwise drop it!
            if (fArapConnUp)
            {
                ArapRoutePacketFromWan( pArapConn, pArapBuf );
            }

            // we received AppleTalk data but connection wasn't/isn't up!  Drop pkt
            else
            {
	            DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
		            ("ArapRcvComplete: (%lx) AT data, but conn not up\n",pArapConn));
            }

            BytesProcessed += pArapBuf->DataSize;

            // done with this buffer
            ARAP_FREE_RCVBUF(pArapBuf);
        }

        //
        // ok, we freed up space: update the counters
        //
        ACQUIRE_SPIN_LOCK(&pArapConn->SpinLock, &OldIrql);

        ASSERT(pArapConn->RecvsPending >= BytesProcessed);
        pArapConn->RecvsPending -= BytesProcessed;

        ARAP_ADJUST_RECVCREDIT(pArapConn);

#if DBG
        if ((IsListEmpty(&pArapConn->RetransmitQ)) &&
            (IsListEmpty(&pArapConn->HighPriSendQ)) &&
            (IsListEmpty(&pArapConn->MedPriSendQ)) &&
            (IsListEmpty(&pArapConn->LowPriSendQ)) &&
            (IsListEmpty(&pArapConn->SendAckedQ)) )
        {
            ASSERT(pArapConn->SendsPending == 0);
        }
#endif
        RELEASE_SPIN_LOCK(&pArapConn->SpinLock, OldIrql);

        ArapDataToDll(pArapConn);

        //
        // see if any more packets can/should be sent
        //
        ArapNdisSend(pArapConn, &pArapConn->HighPriSendQ);
    }
}



//***
//
// Function: ArapNdisSend
//              This routine is called when we need to send data out to the
//              client, whether it's a fresh send or a retransmit.
//
// Parameters:  pArapConn - connection element for whom data has come in
//              pSendHead - from which queue (new send or retransmit) to send
//
// Return:      none
//
//***$

VOID
ArapNdisSend(
    IN  PARAPCONN       pArapConn,
    IN  PLIST_ENTRY     pSendHead
)
{

    KIRQL           OldIrql;
    PMNPSENDBUF     pMnpSendBuf=NULL;
	PNDIS_PACKET	ndisPacket;
    NDIS_STATUS     ndisStatus;
    PLIST_ENTRY     pSendList;
    BOOLEAN         fGreaterThan;
    BYTE            SendCredit;
    BYTE            PrevSeqNum;
    BOOLEAN         fFirstSend=TRUE;
    BOOLEAN         fRetransmitQ;
    DWORD           StatusCode;



    DBG_ARAP_CHECK_PAGED_CODE();

    //
    // before we begin, let's see if any of the lower priority queue sends
    // can be moved ("refilled") on to the high priority queue (the real queue)
    //
    ArapRefillSendQ(pArapConn);


    fRetransmitQ = (pSendHead == &pArapConn->RetransmitQ);

    //
    // while we have sends queued up and send-credits available,
    // keep sending
    //

    while (1)
    {
        ACQUIRE_SPIN_LOCK(&pArapConn->SpinLock, &OldIrql);

        pSendList = pSendHead->Flink;

        if (pArapConn->MnpState.RetransmitMode)
        {
            //
            // if we are asked to retransmit, we only retransmit the first
            // packet (until it is acked)
            //
            if (!fFirstSend)
            {
                goto ArapNdisSend_Exit;
            }

            //
            // if we are in the retransmit mode, we can't accept any fresh sends
            //
            if (!fRetransmitQ)
            {
    	        DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_INFO,
                    ("ArapNdisSend: in retransmit mode, dropping fresh send\n"));

                goto ArapNdisSend_Exit;
            }

            // we will go down and retransmit (if we can): turn this off here
            pArapConn->MnpState.MustRetransmit = FALSE;
        }

#if 0
        //
        // if this is a retransmit, find the next send that we must retransmit
        //
        if ((fRetransmitQ) && (!fFirstSend))
        {
            while (pSendList != pSendHead)
            {
                pMnpSendBuf = CONTAINING_RECORD(pSendList,MNPSENDBUF,Linkage);

                // find the seq number larger than the one we just retransmitted
                LT_GREATER_THAN(pMnpSendBuf->SeqNum,PrevSeqNum,fGreaterThan);

                if (fGreaterThan)
                {
                    break;
                }

                pSendList = pSendList->Flink;
            }
        }
#endif

        // no more to send? then we're done
        if (pSendList == pSendHead)
        {
            goto ArapNdisSend_Exit;
        }

        pMnpSendBuf = CONTAINING_RECORD(pSendList,MNPSENDBUF,Linkage);

        ASSERT( (pMnpSendBuf->Signature == MNPSMSENDBUF_SIGNATURE) ||
                (pMnpSendBuf->Signature == MNPLGSENDBUF_SIGNATURE) );

        fFirstSend = FALSE;
        PrevSeqNum = pMnpSendBuf->SeqNum;

        SendCredit = pArapConn->MnpState.SendCredit;

        //
        // if we are disconnecting, don't send
        //
        if (pArapConn->State >= MNP_LDISCONNECTING)
        {
    	    DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                ("ArapNdisSend: disconnecting, or link-down: dropping send\n"));

            ARAP_DBG_TRACE(pArapConn,30305,NULL,pArapConn->State,0,0);

            goto ArapNdisSend_Exit;
        }

        //
        // if this is a fresh send (i.e. not a retransmit) then make sure we have
        // send credits available
        //
        if ( (SendCredit == 0) && (!fRetransmitQ) )
        {
    	    DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_INFO,
                ("ArapNdisSend: send credit 0, dropping send\n"));

            ARAP_DBG_TRACE(pArapConn,30310,NULL,0,0,0);

            goto ArapNdisSend_Exit;
        }

        //
        // if this send is already in NDIS (rare case, but can happen) then return
        //
        if (pMnpSendBuf->Flags != 0)
        {
    	    DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_INFO,
                ("ArapNdisSend: send %lx already in NDIS!!! (seq=%x, %d times)\n",
                pMnpSendBuf,pMnpSendBuf->SeqNum,pMnpSendBuf->RetryCount));

            goto ArapNdisSend_Exit;
        }

        // Mark that this send is in Ndis
        pMnpSendBuf->Flags = 1;

        //
        // Move it to the RetransmitQ for that "reliable" thing to work
        // and set the length so that ndis knows how much to send!
        //
        if (!fRetransmitQ)
        {
            ASSERT(pMnpSendBuf->DataSize <= MNP_MAXPKT_SIZE);

            DBGTRACK_SEND_SIZE(pArapConn,pMnpSendBuf->DataSize);

            //
            // get ndis packet for this send, since this is the first time we
            // are sending this send out
            //
            StatusCode = ArapGetNdisPacket(pMnpSendBuf);

            if (StatusCode != ARAPERR_NO_ERROR)
            {
    	        DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                    ("ArapNdisSend: (%lx) couldn't alloc NdisPacket\n",pArapConn));

                pMnpSendBuf->Flags = 0;
                goto ArapNdisSend_Exit;
            }

            // one more frame going outcame in
            pArapConn->StatInfo.FramesSent++;

            RemoveEntryList(&pMnpSendBuf->Linkage);

            InsertTailList(&pArapConn->RetransmitQ, &pMnpSendBuf->Linkage);

            pArapConn->MnpState.UnAckedSends++;

            ASSERT(pArapConn->MnpState.UnAckedSends <= pArapConn->MnpState.WindowSize);

            ASSERT( (pArapConn->MnpState.SendCredit > 0) &&
                    (pArapConn->MnpState.SendCredit <= pArapConn->MnpState.WindowSize));

            // we are going to use up one send credit now
            pArapConn->MnpState.SendCredit--;

		    NdisAdjustBufferLength(pMnpSendBuf->sb_BuffHdr.bh_NdisBuffer,
                              (pMnpSendBuf->DataSize + MNP_OVERHD(pArapConn)));

            ASSERT( (pMnpSendBuf->Buffer[14] == pArapConn->MnpState.SynByte) &&
                    (pMnpSendBuf->Buffer[15] == pArapConn->MnpState.DleByte) &&
                    (pMnpSendBuf->Buffer[16] == pArapConn->MnpState.StxByte));

            ASSERT((pMnpSendBuf->Buffer[20 + pMnpSendBuf->DataSize] ==
                                               pArapConn->MnpState.DleByte) &&
                   (pMnpSendBuf->Buffer[20 + pMnpSendBuf->DataSize+1] ==
                                               pArapConn->MnpState.EtxByte));
        }

        //
        //  this is a retransmit
        //
        else
        {
	        DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_INFO,
		        ("ArapNdisSend: (%lx) retransmitting %x size=%d\n",
                    pArapConn,pMnpSendBuf->SeqNum,pMnpSendBuf->DataSize));

            //
            // reset it: it's possible we had changed it for an earlier retransmit
            //
            if (pMnpSendBuf->RetryCount < ARAP_HALF_MAX_RETRANSMITS)
            {
                pArapConn->SendRetryTime = pArapConn->SendRetryBaseTime;
            }

            //
            // hmmm: we have retransmitted quite a few times.  Time to increase
            // our retry time so we do some exponential back off.  Increase the
            // retry time by 50%, with an upper bound of 5 seconds
            //
            else
            {
                pArapConn->SendRetryTime += (pArapConn->SendRetryTime>>1);

                if (pArapConn->SendRetryTime > ARAP_MAX_RETRY_INTERVAL)
                {
                    pArapConn->SendRetryTime = ARAP_MAX_RETRY_INTERVAL;
                }
            }
        }

        // bump this to note our attempt to send this pkt
        pMnpSendBuf->RetryCount++;

        // put an ndis refcount (remove when ndis completes this send)
        pMnpSendBuf->RefCount++;

        // when should we retransmit this pkt?
        pMnpSendBuf->RetryTime = pArapConn->SendRetryTime + AtalkGetCurrentTick();

        // reset the flow-control timer: we're sending something over
        pArapConn->FlowControlTimer = AtalkGetCurrentTick() +
                                        pArapConn->T404Duration;

        ARAP_DBG_TRACE(pArapConn,30320,pMnpSendBuf,fRetransmitQ,0,0);

        MNP_DBG_TRACE(pArapConn,pMnpSendBuf->SeqNum,MNP_LT);

        RELEASE_SPIN_LOCK(&pArapConn->SpinLock, OldIrql);

        ndisPacket = pMnpSendBuf->sb_BuffHdr.bh_NdisPkt;

        DBGDUMPBYTES("ArapNdisSend sending pkt: ",
            &pMnpSendBuf->Buffer[0],(pMnpSendBuf->DataSize + MNP_OVERHD(pArapConn)),3);

		//  Now send the packet descriptor
		NdisSend(&ndisStatus, RasPortDesc->pd_NdisBindingHandle, ndisPacket);

		// if there was a problem sending, call the completion routine here
		if (ndisStatus != NDIS_STATUS_PENDING)
		{
    	    DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                ("ArapNdisSend: NdisSend failed (%lx %lx)\n", pArapConn,ndisStatus));

			ArapNdisSendComplete(ARAPERR_SEND_FAILED, (PBUFFER_DESC)pMnpSendBuf, NULL);

            // might as well stop here for now if we are having trouble sending!
            goto ArapNdisSend_Exit_NoLock;
		}
    }


ArapNdisSend_Exit:

    RELEASE_SPIN_LOCK(&pArapConn->SpinLock, OldIrql);

ArapNdisSend_Exit_NoLock:

    ;

    // if our sniff buffer has enough bytes, give them to dll and make room
    ARAP_DUMP_DBG_TRACE(pArapConn);

}





//***
//
// Function: ArapNdisSendComplete
//              This routine is the completion routine called by Ndis to tell
//              us that the send completed (i.e. just went out on the wire)
//
// Parameters:  Status - did it go out on wire?
//              pMnpSendBuf - the buffer that was sent out. We dereference the
//                            buffer here.  When this send gets acked, that's
//                            when the other deref happens.
//
// Return:      none
//
//***$

VOID
ArapNdisSendComplete(
	IN NDIS_STATUS		    Status,
	IN PBUFFER_DESC         pBufferDesc,
    IN PSEND_COMPL_INFO     pSendInfo
)
{

    PARAPCONN           pArapConn;
	PMNPSENDBUF         pMnpSendBuf;


    DBG_ARAP_CHECK_PAGED_CODE();

    pMnpSendBuf = (PMNPSENDBUF)pBufferDesc;
    pArapConn = pMnpSendBuf->pArapConn;

    ARAPTRACE(("Entered ArapNdisSendComplete (%lx %lx %lx)\n",
        Status,pMnpSendBuf,pArapConn));

    if (Status != NDIS_STATUS_SUCCESS)
    {
	    DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
            ("ArapNdisSendComplete (%lx): send failed %lx\n",pArapConn,Status));
    }

    // ndis send completed: take away the ndis refcount
    DerefMnpSendBuf(pMnpSendBuf, TRUE);
}



//***
//
// Function: ArapGetNdisPacket
//              This function gets an Ndis Packet for the ARAP send buffer
//
// Parameters:  pMnpSendBuf - the send buffer for which we need Ndis Packet
//
// Return:      error code
//
//***$
DWORD
ArapGetNdisPacket(
    IN PMNPSENDBUF     pMnpSendBuf
)
{

		
	PBUFFER_HDR	    pBufHdr;
    NDIS_STATUS     ndisStatus;


    DBG_ARAP_CHECK_PAGED_CODE();

	pBufHdr = (PBUFFER_HDR)pMnpSendBuf;

	pBufHdr->bh_NdisPkt = NULL;

	//  Allocate an NDIS packet descriptor from the global packet pool
	NdisAllocatePacket(&ndisStatus,
					   &pBufHdr->bh_NdisPkt,
					   AtalkNdisPacketPoolHandle);
	
	if (ndisStatus != NDIS_STATUS_SUCCESS)
	{
		LOG_ERROR(EVENT_ATALK_NDISRESOURCES, ndisStatus, NULL, 0);

	    DBGPRINT(DBG_COMP_SYSTEM, DBG_LEVEL_ERR,
		    ("ArapGetNdisPacket: Ndis Out-of-Resource condition hit\n"));

        ASSERT(0);

		return(ARAPERR_OUT_OF_RESOURCES);
	}

	//  Link the buffer descriptor into the packet descriptor
	RtlZeroMemory(pBufHdr->bh_NdisPkt->ProtocolReserved, sizeof(PROTOCOL_RESD));
	NdisChainBufferAtBack(pBufHdr->bh_NdisPkt,
						  pBufHdr->bh_NdisBuffer);
	((PPROTOCOL_RESD)(pBufHdr->bh_NdisPkt->ProtocolReserved))->Receive.pr_BufHdr = pBufHdr;

    ARAP_SET_NDIS_CONTEXT(pMnpSendBuf, NULL);

    return(ARAPERR_NO_ERROR);
}

//***
//
// Function: RasStatusIndication
//              This is the status indication routine for the Arap port.
//              When line-up, line-down indications come from NdisWan, we
//              execute this routine.
//
// Parameters:  GeneralStatus - what is this indication for
//              StatusBuf - the buffer containig the indication info
//              StatusBufLen - length of this buffer
//
// Return:      none
//
//***$

VOID
RasStatusIndication(
	IN	NDIS_STATUS 	GeneralStatus,
	IN	PVOID			StatusBuf,
	IN	UINT 			StatusBufLen
)
{

    KIRQL                   OldIrql;
    PNDIS_WAN_LINE_UP	    pLineUp;
    PNDIS_WAN_LINE_DOWN     pLineDown;
    PNDIS_WAN_FRAGMENT      pFragment;
    ATALK_NODEADDR          ClientNode;
    PARAPCONN               pArapConn;
    PATCPCONN               pAtcpConn;
    PARAP_BIND_INFO         pArapBindInfo;
    PNDIS_WAN_GET_STATS     pWanStats;
    DWORD                   dwFlags;
    BOOLEAN                 fKillConnection=FALSE;


    switch (GeneralStatus)
    {
        case NDIS_STATUS_WAN_LINE_UP:

            if (StatusBufLen < sizeof(NDIS_WAN_LINE_UP))
            {
	            DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR, ("RasStatusIndication:\
                                line-up buff too small (%ld)\n", StatusBufLen));
                break;
            }

            pLineUp = (PNDIS_WAN_LINE_UP)StatusBuf;

            pArapBindInfo = (PARAP_BIND_INFO)pLineUp->ProtocolBuffer;

            //
            // is this a PPP connection?
            //
            if (pArapBindInfo->fThisIsPPP)
            {
                ClientNode.atn_Network = pArapBindInfo->ClientAddr.ata_Network;
                ClientNode.atn_Node = (BYTE)pArapBindInfo->ClientAddr.ata_Node;

                pAtcpConn = FindAndRefPPPConnByAddr(ClientNode, &dwFlags);

                ASSERT(pAtcpConn == pArapBindInfo->AtalkContext);

                if (pAtcpConn)
                {
                    ASSERT(pAtcpConn->Signature == ATCPCONN_SIGNATURE);

	                DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
			            ("PPP: Line-Up received on %lx: link-speed = %lx, net addr %x.%x\n",
                        pAtcpConn,pLineUp->LinkSpeed,ClientNode.atn_Network,ClientNode.atn_Node));

                    if ((dwFlags & ATCP_LINE_UP_DONE) || (dwFlags & ATCP_CONNECTION_UP))
                    {
                        // remove the refcount put in by FindAndRefPPPConnByAddr
                        DerefPPPConn(pAtcpConn);

                        DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                            ("PPP: Line-Up received on connection already up"));
                        break;
                    }

                    ACQUIRE_SPIN_LOCK(&pAtcpConn->SpinLock, &OldIrql);

                    ASSERT(!((dwFlags & ATCP_LINE_UP_DONE) || (dwFlags & ATCP_CONNECTION_UP)));
                
                    pAtcpConn->Flags |= ATCP_LINE_UP_DONE;
                    pAtcpConn->Flags |= ATCP_CONNECTION_UP;

                    // put NDISWAN refcount
                    pAtcpConn->RefCount++;

                    //
                    // put our context for ndiswan
                    //


                    // mark that this is a PPP connection
                    pLineUp->LocalAddress[0] = PPP_ID_BYTE1;
                    pLineUp->LocalAddress[1] = PPP_ID_BYTE2;

                    pLineUp->LocalAddress[2] = 0x0;
                    pLineUp->LocalAddress[3] = ClientNode.atn_Node;
		            *((USHORT UNALIGNED *)(&pLineUp->LocalAddress[4])) =
                        ClientNode.atn_Network;

                    //
                    // copy the header since this is what we'll use throughout the
                    // life of the connection
                    //
                    RtlCopyMemory( &pAtcpConn->NdiswanHeader[0],
                                   pLineUp->RemoteAddress,
                                   6 );

                    RtlCopyMemory( &pAtcpConn->NdiswanHeader[6],
                                   pLineUp->LocalAddress,
                                   6 );

                    // these two bytes don't really mean much, but might as well set'em
                    pAtcpConn->NdiswanHeader[12] = 0x80;
                    pAtcpConn->NdiswanHeader[13] = 0xf3;

                    RELEASE_SPIN_LOCK(&pAtcpConn->SpinLock, OldIrql);

                    // remove the refcount put in by FindAndRefPPPConnByAddr
                    DerefPPPConn(pAtcpConn);

                    // tell dll we bound ok
                    pArapBindInfo->ErrorCode = ARAPERR_NO_ERROR;
                }
                else
                {
	                DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                        ("RasStatusIndication: PPP line-up, but no conn for %ld.%ld\n",
                        ClientNode.atn_Network,ClientNode.atn_Node));
                    ASSERT(0);
                    pArapBindInfo->ErrorCode = ARAPERR_NO_SUCH_CONNECTION;
                }
            }

            //
            // nope, this is an ARAP connection!
            //
            else
            {
	            DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
			        ("Arap: Line-Up received: link-speed = %lx, dll context = %lx\n",
                    pLineUp->LinkSpeed,pArapBindInfo->pDllContext));

                ASSERT(FindArapConnByContx(pArapBindInfo->pDllContext) == NULL);

                //
                // alloc a connection.  If we fail, tell dll sorry
                //

                pArapConn = AllocArapConn(pLineUp->LinkSpeed);
                if (pArapConn == NULL)
                {
    	            DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                        ("RasStatusIndication: AllocArapConn failed\n"));

                    pArapBindInfo->AtalkContext = NULL;
                    pArapBindInfo->ErrorCode = ARAPERR_OUT_OF_RESOURCES;
                    break;
                }

                // do the legendary "binding" (exchange contexts!)
                pArapConn->pDllContext = pArapBindInfo->pDllContext;

                pArapBindInfo->AtalkContext = pArapConn;

                //
                // insert this connection in the list of all Arap connections
                //
                ACQUIRE_SPIN_LOCK(&RasPortDesc->pd_Lock, &OldIrql);

                InsertTailList(&RasPortDesc->pd_ArapConnHead, &pArapConn->Linkage);

                RELEASE_SPIN_LOCK(&RasPortDesc->pd_Lock, OldIrql);


                // mark that this is an ARAP connection
                pLineUp->LocalAddress[0] = ARAP_ID_BYTE1;
                pLineUp->LocalAddress[1] = ARAP_ID_BYTE2;

                // put our context for ndiswan
		        *((ULONG UNALIGNED *)(&pLineUp->LocalAddress[2])) =
    		        *((ULONG UNALIGNED *)(&pArapConn));

                //
                // copy the header since this is what we'll use throughout the
                // life of the connection
                //
                RtlCopyMemory( &pArapConn->NdiswanHeader[0],
                            pLineUp->RemoteAddress,
                            6 );

                RtlCopyMemory( &pArapConn->NdiswanHeader[6],
                            pLineUp->LocalAddress,
                            6 );

                // these two bytes don't really mean much, but might as well set'em
                pArapConn->NdiswanHeader[12] = 0x80;
                pArapConn->NdiswanHeader[13] = 0xf3;

                // tell dll we bound ok
                pArapBindInfo->ErrorCode = ARAPERR_NO_ERROR;

            }  // if (pArapBindInfo->fThisIsPPP)

            break;


        case NDIS_STATUS_WAN_LINE_DOWN:

	        DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
			    ("RasStatusIndication: Line-Down received\n"));

            if (StatusBufLen < sizeof(NDIS_WAN_LINE_DOWN))
            {
	            DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                    ("RasStatusIndication: line-down buff too small (%ld)\n",
                    StatusBufLen));
                break;
            }

            pLineDown = (PNDIS_WAN_LINE_DOWN)StatusBuf;

            //
            // is this a PPP connection?
            //
            if ((pLineDown->LocalAddress[0] == PPP_ID_BYTE1) &&
                (pLineDown->LocalAddress[1] == PPP_ID_BYTE2))
            {
                ClientNode.atn_Node = pLineDown->LocalAddress[3];
                ClientNode.atn_Network =
                          *((USHORT UNALIGNED *)(&pLineDown->LocalAddress[4]));

                pAtcpConn = FindAndRefPPPConnByAddr(ClientNode, &dwFlags);
                if (pAtcpConn)
                {
                    ASSERT(pAtcpConn->Signature == ATCPCONN_SIGNATURE);

                    ACQUIRE_SPIN_LOCK(&pAtcpConn->SpinLock, &OldIrql);

                    ASSERT(dwFlags & ATCP_LINE_UP_DONE);

                    pAtcpConn->Flags &= ~(ATCP_CONNECTION_UP | ATCP_LINE_UP_DONE);
                    RELEASE_SPIN_LOCK(&pAtcpConn->SpinLock, OldIrql);

	                DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
			            ("PPP line-down: killing %lx in line-down\n",pAtcpConn));

                    // line-down: take away the NDISWAN refcount
                    DerefPPPConn(pAtcpConn);

                    // remove the refcount put in by FindAndRefPPPConnByAddr
                    DerefPPPConn(pAtcpConn);
                }
                else
                {
	                DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                        ("RasStatusIndication: PPP line-down, but no conn for %ld.%ld\n",
                        ClientNode.atn_Network,ClientNode.atn_Node));
                }
            }

            //
            // no, this is an ARAP connection
            //
            else
            {

                ASSERT((pLineDown->LocalAddress[0] == ARAP_ID_BYTE1) &&
                       (pLineDown->LocalAddress[1] == ARAP_ID_BYTE2));

		        *((ULONG UNALIGNED *)(&pArapConn)) =
		                    *((ULONG UNALIGNED *)(&pLineDown->LocalAddress[2]));

		        // this had better be a line-down for an existing connection!
                if (ArapConnIsValid(pArapConn))
                {
	                DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
			            ("Arap line-down: killing %lx in line-down\n",pArapConn));

                    ArapCleanup(pArapConn);

                    // remove validation refcount
                    DerefArapConn(pArapConn);

                    // remove line-up refcount
                    DerefArapConn(pArapConn);
                }
                else
                {
	                DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                        ("RasStatusIndication: line-down, can't find pArapConn\n"));
                }
            }

            break;


        case NDIS_STATUS_WAN_GET_STATS:

            if (StatusBufLen < sizeof(NDIS_WAN_GET_STATS))
            {
	            DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                    ("RasStatusIndication: GetStats buff too small (%ld)\n", StatusBufLen));
                break;
            }

            pWanStats = (PNDIS_WAN_GET_STATS)StatusBuf;

            //
            // is this a PPP connection?  If so, ignore it: we don't keep stats
            // for PPP connection
            //
            if ((pWanStats->LocalAddress[0] == PPP_ID_BYTE1) &&
                (pWanStats->LocalAddress[1] == PPP_ID_BYTE2))
            {
                break;
            }

            //
            // no, this is an ARAP connection
            //
            else
            {
                ASSERT((pWanStats->LocalAddress[0] == ARAP_ID_BYTE1) &&
                       (pWanStats->LocalAddress[1] == ARAP_ID_BYTE2));

		        *((ULONG UNALIGNED *)(&pArapConn)) =
		                    *((ULONG UNALIGNED *)(&pWanStats->LocalAddress[2]));

		        // the connection had better be a valid one!
                if (ArapConnIsValid(pArapConn))
                {
                    //
                    // copy those stats in!
                    //
                    ACQUIRE_SPIN_LOCK(&pArapConn->SpinLock, &OldIrql);

                    pWanStats->BytesSent =
                                    pArapConn->StatInfo.BytesSent;
                    pWanStats->BytesRcvd =
                                    pArapConn->StatInfo.BytesRcvd;
                    pWanStats->FramesSent =
                                    pArapConn->StatInfo.FramesSent;
                    pWanStats->FramesRcvd =
                                    pArapConn->StatInfo.FramesRcvd;
                    pWanStats->BytesTransmittedUncompressed =
                                    pArapConn->StatInfo.BytesTransmittedUncompressed;
                    pWanStats->BytesReceivedUncompressed =
                                    pArapConn->StatInfo.BytesReceivedUncompressed;
                    pWanStats->BytesTransmittedCompressed =
                                    pArapConn->StatInfo.BytesTransmittedCompressed;
                    pWanStats->BytesReceivedCompressed =
                                    pArapConn->StatInfo.BytesReceivedCompressed;

                    RELEASE_SPIN_LOCK(&pArapConn->SpinLock, OldIrql);

                    // remove validation refcount
                    DerefArapConn(pArapConn);
                }
                else
                {
	                DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                        ("RasStatusIndication: GetStats on bad connection %lx\n",pArapConn));
                }
            }

            break;

        case NDIS_STATUS_WAN_FRAGMENT:

	        DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
			    ("RasStatusIndication: Wan-Fragment received\n"));

            if (StatusBufLen < sizeof(NDIS_WAN_FRAGMENT))
            {
	            DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR, ("RasStatusIndication:\
                              fragment: buff too small (%ld)\n", StatusBufLen));
                break;
            }

            pFragment = (PNDIS_WAN_FRAGMENT)StatusBuf;

		    *((ULONG UNALIGNED *)(&pArapConn)) =
		                    *((ULONG UNALIGNED *)(&pFragment->LocalAddress[2]));

            if (pArapConn == NULL)
            {
	            DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR, ("RasStatusIndication:\
                    fragment, can't find pArapConn\n"));

                break;
            }

            //
            // a frame got fragmented (wrong crc or resync or something bad)
            // Send an ack to the remote client so he might recover quickly
            //
            MnpSendAckIfReqd(pArapConn, TRUE);

        default:

	        DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
			    ("RasStatusIndication: unknown status %lx\n", GeneralStatus));
            break;
    }

}



//***
//
// Function: ArapAdapterInit
//              This routine, called at init time, sets up protocol type info
//              etc. with ndiswan
//
// Parameters:  pPortDesc - the port descriptor corresponding to the "Adapter"
//
// Return:      none
//
//***$

ATALK_ERROR
ArapAdapterInit(
	IN OUT PPORT_DESCRIPTOR	pPortDesc
)
{
    ATALK_ERROR             error;
    NDIS_REQUEST            request;
    NDIS_STATUS             ndisStatus = NDIS_STATUS_SUCCESS;
    UCHAR WanProtocolId[6] = { 0x80, 0x00, 0x00, 0x00, 0x80, 0xf3 };
    ULONG                   WanHeaderFormat;
    NDIS_WAN_PROTOCOL_CAPS  WanProtCap;


    //
    // set the protocol info
    //
    request.RequestType = NdisRequestSetInformation;
    request.DATA.QUERY_INFORMATION.Oid = OID_WAN_PROTOCOL_TYPE;
    request.DATA.QUERY_INFORMATION.InformationBuffer = WanProtocolId;
    request.DATA.QUERY_INFORMATION.InformationBufferLength = 6;

	ndisStatus = AtalkNdisSubmitRequest(pPortDesc,
	    								&request,
										TRUE,
										NULL,
										NULL);
	
	if (ndisStatus != NDIS_STATUS_SUCCESS)
	{
		LOG_ERRORONPORT(pPortDesc,
						EVENT_ARAP_BIND_FAIL,
						ndisStatus,
						NULL,
						0);
	}


    //
    // set the protocol caps
    //
    WanProtCap.Flags = WAN_PROTOCOL_KEEPS_STATS;
    request.RequestType = NdisRequestSetInformation;
    request.DATA.QUERY_INFORMATION.Oid = OID_WAN_PROTOCOL_CAPS;
    request.DATA.QUERY_INFORMATION.InformationBuffer = &WanProtCap;
    request.DATA.QUERY_INFORMATION.InformationBufferLength = sizeof(NDIS_WAN_PROTOCOL_CAPS);

	ndisStatus = AtalkNdisSubmitRequest(pPortDesc,
	    								&request,
										TRUE,
										NULL,
										NULL);
	
	if (ndisStatus != NDIS_STATUS_SUCCESS)
	{
		LOG_ERRORONPORT(pPortDesc,
						EVENT_ARAP_BIND_FAIL,
						ndisStatus,
						NULL,
						0);
	}

    //
    // set the header info
    //
    WanHeaderFormat = NdisWanHeaderEthernet;
    request.RequestType = NdisRequestSetInformation;
    request.DATA.QUERY_INFORMATION.Oid = OID_WAN_HEADER_FORMAT;
    request.DATA.QUERY_INFORMATION.InformationBuffer = &WanHeaderFormat;
    request.DATA.QUERY_INFORMATION.InformationBufferLength = 4;

	ndisStatus = AtalkNdisSubmitRequest(pPortDesc,
	    								&request,
										TRUE,
										NULL,
										NULL);
	
	if (ndisStatus != NDIS_STATUS_SUCCESS)
	{
		LOG_ERRORONPORT(pPortDesc,
						EVENT_ARAP_BIND_FAIL,
						ndisStatus,
						NULL,
						0);
	}


    //
    // Now query the line count.
    //
    request.RequestType = NdisRequestQueryInformation;
    request.DATA.QUERY_INFORMATION.Oid = OID_WAN_LINE_COUNT;
    request.DATA.QUERY_INFORMATION.InformationBuffer = &pPortDesc->pd_RasLines,
    request.DATA.QUERY_INFORMATION.InformationBufferLength = 4;

	ndisStatus = AtalkNdisSubmitRequest(pPortDesc,
	    								&request,
										TRUE,
										NULL,
										NULL);
	

    if (ndisStatus != NDIS_STATUS_SUCCESS)
    {
        pPortDesc->pd_RasLines = 1;
    }

    if (pPortDesc->pd_RasLines == 0) {

		LOG_ERRORONPORT(pPortDesc,
						EVENT_ARAP_NO_RESRC,
						ndisStatus,
						NULL,
						0);
    }

	return AtalkNdisToAtalkError(ndisStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\atalk\sys\aspc.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

	aspc.c

Abstract:

	This module implements the ASP client protocol.

Author:

	Jameel Hyder (jameelh@microsoft.com)
	Nikhil Kamkolkar (nikhilk@microsoft.com)

Revision History:
	30 Mar 1993		Initial Version

Notes:	Tab stop: 4
--*/

#include <atalk.h>
#pragma hdrstop
#define	FILENUM		ASPC

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, AtalkInitAspCInitialize)
#pragma alloc_text(PAGE, AtalkAspCCreateAddress)
#pragma alloc_text(PAGEASPC, AtalkAspCCleanupAddress)
#pragma alloc_text(PAGEASPC, AtalkAspCCloseAddress)
#pragma alloc_text(PAGEASPC, AtalkAspCCreateConnection)
#pragma alloc_text(PAGEASPC, AtalkAspCCleanupConnection)
#pragma alloc_text(PAGEASPC, AtalkAspCCloseConnection)
#pragma alloc_text(PAGEASPC, AtalkAspCAssociateAddress)
#pragma alloc_text(PAGEASPC, AtalkAspCDissociateAddress)
#pragma alloc_text(PAGEASPC, AtalkAspCPostConnect)
#pragma alloc_text(PAGEASPC, AtalkAspCDisconnect)
#pragma alloc_text(PAGEASPC, AtalkAspCGetStatus)
#pragma alloc_text(PAGEASPC, AtalkAspCGetAttn)
#pragma alloc_text(PAGEASPC, AtalkAspCCmdOrWrite)
#pragma alloc_text(PAGEASPC, atalkAspCIncomingOpenReply)
#pragma alloc_text(PAGEASPC, atalkAspCIncomingStatus)
#pragma alloc_text(PAGEASPC, atalkAspCIncomingCmdReply)
#pragma alloc_text(PAGEASPC, atalkAspCHandler)
#pragma alloc_text(PAGEASPC, AtalkAspCAddrDereference)
#pragma alloc_text(PAGEASPC, AtalkAspCConnDereference)
#pragma alloc_text(PAGEASPC, atalkAspCSessionMaintenanceTimer)
#pragma alloc_text(PAGEASPC, atalkAspCQueueAddrGlobalList)
#pragma alloc_text(PAGEASPC, atalkAspCDeQueueAddrGlobalList)
#pragma alloc_text(PAGEASPC, atalkAspCQueueConnGlobalList)
#pragma alloc_text(PAGEASPC, atalkAspCDeQueueConnGlobalList)
#endif

VOID
AtalkInitAspCInitialize(
	VOID
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	AtalkTimerInitialize(&atalkAspCConnMaint.ascm_SMTTimer,
						 atalkAspCSessionMaintenanceTimer,
						 ASP_SESSION_MAINTENANCE_TIMER);
	INITIALIZE_SPIN_LOCK(&atalkAspCLock);
}


ATALK_ERROR
AtalkAspCCreateAddress(
	IN	PATALK_DEV_CTX		pDevCtx	OPTIONAL,
	OUT	PASPC_ADDROBJ	*	ppAspAddr
	)
/*++

Routine Description:

 	Create an ASP address object.

Arguments:


Return Value:


--*/
{
	ATALK_ERROR			Status;
	PASPC_ADDROBJ		pAspAddr;
	int					i;

	DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_INFO,
			("AtalkAspCCreateAddr: Entered\n"));

	// Allocate memory for the Asp address object
	*ppAspAddr = NULL;
	if ((pAspAddr = AtalkAllocZeroedMemory(sizeof(ASPC_ADDROBJ))) == NULL)
	{
		return ATALK_RESR_MEM;
	}

	// Create an Atp Socket on the port for the Sls
	Status = AtalkAtpOpenAddress(AtalkDefaultPort,
								 0,
								 NULL,
								 ATP_DEF_MAX_SINGLE_PKT_SIZE,
								 ATP_DEF_SEND_USER_BYTES_ALL,
								 NULL,
								 FALSE,
								 &pAspAddr->aspcao_pAtpAddr);

	if (!ATALK_SUCCESS(Status))
	{
		DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_ERR,
				("AtalkAspCCreateAddress: AtalkAtpOpenAddress %ld\n", Status));
		AtalkFreeMemory(pAspAddr);
		return Status;
	}

	// Initialize the Asp address object
#if	DBG
	pAspAddr->aspcao_Signature = ASPCAO_SIGNATURE;
#endif
	INITIALIZE_SPIN_LOCK(&pAspAddr->aspcao_Lock);

	atalkAspCQueueAddrGlobalList(pAspAddr);

	// Refcount for creation and atp address. This goes away when atp address is closed
    // pAspAddr->aspcao_Flags = 0;
	pAspAddr->aspcao_RefCount = 1 + 1;
	*ppAspAddr = pAspAddr;

	return ATALK_NO_ERROR;
}


ATALK_ERROR
AtalkAspCCleanupAddress(
	IN	PASPC_ADDROBJ			pAspAddr
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	return(ATALK_NO_ERROR);
}


ATALK_ERROR
AtalkAspCCloseAddress(
	IN	PASPC_ADDROBJ			pAspAddr,
	IN	GENERIC_COMPLETION		CompletionRoutine,
	IN	PVOID					CloseContext
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	return(ATALK_NO_ERROR);
}


ATALK_ERROR
AtalkAspCCreateConnection(
	IN	PVOID					pConnCtx,	// Context to associate with the session
	IN	PATALK_DEV_CTX			pDevCtx		OPTIONAL,
	OUT	PASPC_CONNOBJ 	*		ppAspConn
	)
/*++

Routine Description:

 	Create an ASP session. The created session starts off being an orphan, i.e.
 	it has no parent address object. It gets one when it is associated.

Arguments:


Return Value:


--*/
{
	PASPC_CONNOBJ		pAspConn;

	// Allocate memory for a connection object
	if ((pAspConn = AtalkAllocZeroedMemory(sizeof(ASPC_CONNOBJ))) == NULL)
	{
		return ATALK_RESR_MEM;
	}

#if	DBG
	pAspConn->aspcco_Signature = ASPCCO_SIGNATURE;
#endif

	INITIALIZE_SPIN_LOCK(&pAspConn->aspcco_Lock);
	pAspConn->aspcco_ConnCtx 	= pConnCtx;
	// pAspConn->aspcco_Flags 		= 0;
	pAspConn->aspcco_RefCount 	= 1;			// Creation reference
	pAspConn->aspcco_NextSeqNum = 1;			// Set to 1, not 0.
	AtalkInitializeRT(&pAspConn->aspcco_RT,
					  ASP_INIT_REQ_INTERVAL,
                      ASP_MIN_REQ_INTERVAL,
                      ASP_MAX_REQ_INTERVAL);

	*ppAspConn = pAspConn;

	//	Insert into the global connection list.
	atalkAspCQueueConnGlobalList(pAspConn);

	DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_INFO,
				("AtalkAspCreateConnection: %lx\n", pAspConn));

	return ATALK_NO_ERROR;
}


ATALK_ERROR
AtalkAspCCleanupConnection(
	IN	PASPC_CONNOBJ			pAspConn
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	return ATALK_NO_ERROR;
}


ATALK_ERROR
AtalkAspCCloseConnection(
	IN	PASPC_CONNOBJ			pAspConn,
	IN	GENERIC_COMPLETION		CompletionRoutine,
	IN	PVOID					CloseContext
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	return ATALK_NO_ERROR;
}


ATALK_ERROR
AtalkAspCAssociateAddress(
	IN	PASPC_ADDROBJ			pAspAddr,
	IN	PASPC_CONNOBJ			pAspConn
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	ATALK_ERROR		error;
	KIRQL			OldIrql;

	ASSERT(VALID_ASPCAO(pAspAddr));
	ASSERT(VALID_ASPCCO(pAspConn));

	ACQUIRE_SPIN_LOCK(&pAspConn->aspcco_Lock, &OldIrql);

	error = ATALK_ALREADY_ASSOCIATED;
	if ((pAspConn->aspcco_Flags & ASPCCO_ASSOCIATED) == 0)
	{
		error = ATALK_NO_ERROR;

		pAspConn->aspcco_Flags 	   |= ASPCCO_ASSOCIATED;
		pAspConn->aspcco_pAspCAddr	= pAspAddr;
	}

	RELEASE_SPIN_LOCK(&pAspConn->aspcco_Lock, OldIrql);

	return error;
}


ATALK_ERROR
AtalkAspCDissociateAddress(
	IN	PASPC_CONNOBJ			pAspConn
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PASPC_ADDROBJ	pAspAddr;
	KIRQL			OldIrql;
	ATALK_ERROR		error = ATALK_NO_ERROR;

	ASSERT(VALID_ASPCCO(pAspConn));

	ACQUIRE_SPIN_LOCK(&pAspConn->aspcco_Lock, &OldIrql);
	if ((pAspConn->aspcco_Flags & (ASPCCO_CONNECTING	|
								   ASPCCO_ACTIVE 		|
								   ASPCCO_ASSOCIATED)) != ASPCCO_ASSOCIATED)
	{
		error = ATALK_INVALID_CONNECTION;
	}
	else
	{
		pAspAddr = pAspConn->aspcco_pAspCAddr ;
		ASSERT(VALID_ASPCAO(pAspAddr));

		//	Clear associated flag.
		pAspConn->aspcco_Flags 	   &= ~ASPCCO_ASSOCIATED;
		pAspConn->aspcco_pAspCAddr	= NULL;
	}
	RELEASE_SPIN_LOCK(&pAspConn->aspcco_Lock, OldIrql);

	return error;
}


ATALK_ERROR
AtalkAspCPostConnect(
	IN	PASPC_CONNOBJ			pAspConn,
	IN	PATALK_ADDR				pRemoteAddr,
	IN	PVOID					pConnectCtx,
	IN	GENERIC_COMPLETION		CompletionRoutine
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	ATALK_ERROR		error	= ATALK_NO_ERROR;
	BOOLEAN			DerefConn = FALSE;
	KIRQL			OldIrql;
	BYTE			UserBytes[ATP_USERBYTES_SIZE];
	PBYTE			pOpenPkt = NULL, pRespPkt = NULL;
	PAMDL			pOpenAmdl = NULL, pRespAmdl = NULL;
	PASPC_ADDROBJ	pAspAddr = pAspConn->aspcco_pAspCAddr;

	ASSERT(VALID_ASPCAO(pAspAddr));
	ASSERT(VALID_ASPCCO(pAspConn));

	ACQUIRE_SPIN_LOCK(&pAspConn->aspcco_Lock, &OldIrql);

	do
	{
		if ((pAspConn->aspcco_Flags & (ASPCCO_CONNECTING	|
									   ASPCCO_ACTIVE 		|
									   ASPCCO_ASSOCIATED)) != ASPCCO_ASSOCIATED)
		{
			error = ATALK_INVALID_CONNECTION;
			break;
		}

		//	Reference the connection for the request we will be posting
		AtalkAspCConnReferenceByPtrNonInterlock(pAspConn, &error);
		if (ATALK_SUCCESS(error))
		{
			DerefConn = TRUE;

			//	Make sure flags are clean.
			pAspConn->aspcco_Flags 			   |= ASPCCO_CONNECTING;
			pAspConn->aspcco_ConnectCtx 		= pConnectCtx;
			pAspConn->aspcco_ConnectCompletion 	= CompletionRoutine;
			pAspConn->aspcco_ServerSlsAddr		= *pRemoteAddr;

			//	Copy the atp address object for efficiency
			pAspConn->aspcco_pAtpAddr			= pAspAddr->aspcao_pAtpAddr;
		}
		else
		{
			ASSERTMSG("AtalkAspCPostConnect: Connection ref failed\n", 0);
		}
	} while (FALSE);

	RELEASE_SPIN_LOCK(&pAspConn->aspcco_Lock, OldIrql);

	if (ATALK_SUCCESS(error))
	{
		UserBytes[ASP_CMD_OFF]	= ASP_OPEN_SESSION;
		UserBytes[ASP_WSS_OFF]	= pAspAddr->aspcao_pAtpAddr->atpao_DdpAddr->ddpao_Addr.ata_Socket;
        UserBytes[ASP_VERSION_OFF] = ASP_VERSION[0];
        UserBytes[ASP_VERSION_OFF+1] = ASP_VERSION[1];
	
		//	Post the open session request.
		error = AtalkAtpPostReq(pAspConn->aspcco_pAtpAddr,
								&pAspConn->aspcco_ServerSlsAddr,
								&pAspConn->aspcco_OpenSessTid,
								ATP_REQ_EXACTLY_ONCE,				// ExactlyOnce request
								NULL,
								0,
								UserBytes,
								NULL,
								0,
								ATP_RETRIES_FOR_ASP,
								ATP_MAX_INTERVAL_FOR_ASP,
								THIRTY_SEC_TIMER,
								atalkAspCIncomingOpenReply,
								pAspConn);

		if (ATALK_SUCCESS(error))
		{
			error = ATALK_PENDING;
			DerefConn = FALSE;
		}
		else
		{
			DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_ERR,
					("AtalkAspCPostConnect: AtalkAtpPostReq: failed %ld\n", error));

			//	Remove connection from the connect list and reset states.
			ACQUIRE_SPIN_LOCK(&pAspConn->aspcco_Lock, &OldIrql);

			pAspConn->aspcco_Flags 			   &= ~ASPCCO_CONNECTING;
			pAspConn->aspcco_ConnectCtx 		= NULL;
			pAspConn->aspcco_ConnectCompletion 	= NULL;
			pAspConn->aspcco_pAtpAddr			= NULL;

			RELEASE_SPIN_LOCK(&pAspConn->aspcco_Lock, OldIrql);

			DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_ERR,
					("AtalkAspCPostConnect: failed %ld\n", error));
		}
	}

	if (DerefConn)
	{
		AtalkAspCConnDereference(pAspConn);
	}

	return error;
}


ATALK_ERROR
AtalkAspCDisconnect(
	IN	PASPC_CONNOBJ				pAspConn,
	IN	ATALK_DISCONNECT_TYPE		DisconnectType,
	IN	PVOID						pDisconnectCtx,
	IN	GENERIC_COMPLETION			CompletionRoutine
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PASPC_REQUEST	pAspReq, pAspReqNext;
	KIRQL			OldIrql;
	ATALK_ERROR		Error;

	// Abort all pending requests.
	ACQUIRE_SPIN_LOCK(&pAspConn->aspcco_Lock, &OldIrql);

	pAspConn->aspcco_Flags |= ASPCCO_DISCONNECTING;
	for (pAspReq = pAspConn->aspcco_pActiveReqs;
		 pAspReq = pAspReq->aspcrq_Next;
		 pAspReq = pAspReqNext)
	{
		pAspReqNext = pAspReq->aspcrq_Next;
	}

	RELEASE_SPIN_LOCK(&pAspConn->aspcco_Lock, OldIrql);

	// Send a close session request to the other end
	// Error = AtalKAtpPostReq(pAspConn->aspcco_ServerSlsAddr);

	return ATALK_NO_ERROR;
}


ATALK_ERROR
AtalkAspCGetStatus(
	IN	PASPC_ADDROBJ				pAspAddr,
	IN	PATALK_ADDR					pRemoteAddr,
	IN	PAMDL						pStatusAmdl,
	IN	USHORT						AmdlSize,
	IN	PACTREQ						pActReq
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	ATALK_ERROR	error;
	BYTE		UserBytes[ATP_USERBYTES_SIZE];
	USHORT		tid;

	if ((pRemoteAddr->ata_Network == 0) ||
        (pRemoteAddr->ata_Node == 0)	||
        (pRemoteAddr->ata_Socket == 0))
	{
		return ATALK_SOCKET_INVALID;
	}

	*(DWORD *)UserBytes = 0;
	UserBytes[ASP_CMD_OFF]	= ASP_GET_STATUS;

	error = AtalkAtpPostReq(pAspAddr->aspcao_pAtpAddr,
							pRemoteAddr,
							&tid,
							0,							// ExactlyOnce request
							NULL,
							0,
							UserBytes,
							pStatusAmdl,
							AmdlSize,
							ATP_RETRIES_FOR_ASP,
							ATP_MAX_INTERVAL_FOR_ASP,
							THIRTY_SEC_TIMER,
							atalkAspCIncomingStatus,
							(PVOID)pActReq);

	if (ATALK_SUCCESS(error))
	{
		error = ATALK_PENDING;
	}

	return error;
}


ATALK_ERROR
AtalkAspCGetAttn(
	IN	PASPC_CONNOBJ			pAspConn,
	IN	PAMDL					pReadBuf,
	IN	USHORT					ReadBufLen,
	IN	ULONG					ReadFlags,
	IN	PVOID					pReadCtx,
	IN	GENERIC_READ_COMPLETION	CompletionRoutine
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	ATALK_ERROR	error = ATALK_NO_ERROR;
	KIRQL			OldIrql;

	ASSERT(VALID_ASPCCO(pAspConn));
	ASSERT(*CompletionRoutine != NULL);

	ACQUIRE_SPIN_LOCK(&pAspConn->aspcco_Lock, &OldIrql);

	do
	{
		if ((pAspConn->aspcco_Flags & ASPCCO_ACTIVE) == 0)
		{
			error = ATALK_ASPC_CONN_NOT_ACTIVE;
			break;
		}

		if ((ReadFlags & TDI_RECEIVE_EXPEDITED) == 0)
		{
			error = ATALK_INVALID_PARAMETER;
			break;
		}

		if (pAspConn->aspcco_Flags & ASPCCO_ATTN_PENDING)
		{
			error = ATALK_ASPC_TOO_MANY_READS;
			break;
		}

		//	PEEK not supported for ASPC
		if (ReadFlags & TDI_RECEIVE_PEEK)
		{
			error = ATALK_INVALID_REQUEST;
			break;
		}

		// We should have space for atleast one attention word
		if (ReadBufLen < sizeof(USHORT))
		{
			error = ATALK_BUFFER_TOO_SMALL;
			break;
		}

		// Check if we have any outstanding attention words
		if (pAspConn->aspcco_AttnOutPtr < pAspConn->aspcco_AttnInPtr)
		{
			PUSHORT	AttnBuf;
			USHORT	BufSize = 0;

			AttnBuf = AtalkGetAddressFromMdlSafe(
					pReadBuf,
					NormalPagePriority);
			if (AttnBuf == NULL) {
				error = ATALK_FAILURE;
				break;
			}
			while (pAspConn->aspcco_AttnOutPtr < pAspConn->aspcco_AttnInPtr)
			{
				*AttnBuf++ = pAspConn->aspcco_AttnBuf[pAspConn->aspcco_AttnOutPtr % MAX_ASPC_ATTNS];
                pAspConn->aspcco_AttnOutPtr++;
				BufSize += sizeof(USHORT);
			}
			(*CompletionRoutine)(error,
								pReadBuf,
								BufSize,
								ReadFlags,
								pReadCtx);

			error = ATALK_PENDING;
			break;
		}
		error = ATALK_INVALID_CONNECTION;
		if ((pAspConn->aspcco_Flags & (ASPCCO_CLOSING | ASPCCO_DISCONNECTING)) == 0)
		{
			AtalkAspCConnReferenceByPtrNonInterlock(pAspConn, &error);
		}

		if (!ATALK_SUCCESS(error))
		{
			break;
		}

		pAspConn->aspcco_Flags 	|= ASPCCO_ATTN_PENDING;

		//	Remember read information in the connection object.
		pAspConn->aspcco_ReadCompletion	= CompletionRoutine;
		pAspConn->aspcco_ReadCtx		= pReadCtx;

	} while (FALSE);

	RELEASE_SPIN_LOCK(&pAspConn->aspcco_Lock, OldIrql);

	return error;
}


ATALK_ERROR
AtalkAspCCmdOrWrite(
	IN	PASPC_CONNOBJ				pAspConn,
	IN	PAMDL						pCmdMdl,
	IN	USHORT						CmdSize,
	IN	PAMDL						pReplyMdl,
	IN	USHORT						ReplySize,
	IN	BOOLEAN						fWrite,		// If TRUE, its a write else command
	IN	PACTREQ						pActReq
	)
/*++

Routine Description:


Arguments:
	Reply and Write buffers are overlaid.

Return Value:

--*/
{
	ATALK_ERROR		Error;
	KIRQL			OldIrql;
	PASPC_REQUEST	pAspReq;
	BYTE			UserBytes[ATP_USERBYTES_SIZE];

	do
	{
		if (((pAspConn->aspcco_Flags & (ASPCCO_ACTIVE		|
									   ASPCCO_CONNECTING 	|
									   ASPCCO_LOCAL_CLOSE	|
									   ASPCCO_REMOTE_CLOSE	|
									   ASPCCO_CLOSING)) != ASPCCO_ACTIVE))
		{
			Error = ATALK_INVALID_REQUEST;
			break;
		}

		AtalkAspCConnReference(pAspConn, &Error);
		if (!ATALK_SUCCESS(Error))
		{
			break;
		}

		if ((pAspReq = (PASPC_REQUEST)AtalkAllocZeroedMemory(sizeof(ASPC_REQUEST))) == NULL)
		{
			Error = ATALK_RESR_MEM;
			break;
		}
#if DBG
		pAspReq->aspcrq_Signature = ASPCRQ_SIGNATURE;
#endif
		pAspReq->aspcrq_Flags = fWrite ? ASPCRQ_WRITE : ASPCRQ_COMMAND;
		pAspReq->aspcrq_pReplyMdl = pReplyMdl;
		pAspReq->aspcrq_ReplySize = ReplySize;
		pAspReq->aspcrq_RefCount = 2;	// Creation+incoming reply handler

		ACQUIRE_SPIN_LOCK(&pAspConn->aspcco_Lock, &OldIrql);

		pAspReq->aspcrq_SeqNum = pAspConn->aspcco_NextSeqNum ++;
		pAspReq->aspcrq_Next = pAspConn->aspcco_pActiveReqs;
		pAspConn->aspcco_pActiveReqs = pAspReq;
		pAspReq->aspcrq_pAspConn = pAspConn;

		RELEASE_SPIN_LOCK(&pAspConn->aspcco_Lock, OldIrql);

		// Build user bytes and send our request over
		UserBytes[ASP_CMD_OFF] = fWrite ? ASP_CMD : ASP_WRITE;
		UserBytes[ASP_SESSIONID_OFF] = pAspConn->aspcco_SessionId;
		PUTSHORT2SHORT(&UserBytes[ASP_SEQUENCE_NUM_OFF], pAspReq->aspcrq_SeqNum);

		Error = AtalkAtpPostReq(pAspConn->aspcco_pAtpAddr,
								&pAspConn->aspcco_ServerSssAddr,
								&pAspReq->aspcrq_ReqXactId,
								ATP_REQ_EXACTLY_ONCE,		// XO request
								pCmdMdl,
								CmdSize,
								UserBytes,
								pReplyMdl,
								ReplySize,
								ATP_RETRIES_FOR_ASP,		// Retry count
								pAspConn->aspcco_RT.rt_Base,// Retry interval
								THIRTY_SEC_TIMER,
								atalkAspCIncomingCmdReply,
								pAspReq);

		if (!ATALK_SUCCESS(Error))
		{
			DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_ERR,
					("AtalkAspCCmdOrWrite: AtalkAtpPostReq failed %lx\n", Error));
			atalkAspCIncomingCmdReply(Error,
									  pAspReq,
									  pCmdMdl,
									  pReplyMdl,
									  ReplySize,
									  UserBytes);
		}

	} while (FALSE);

	return Error;
}


BOOLEAN
AtalkAspCConnectionIsValid(
	IN	PASPC_CONNOBJ	pAspConn
)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	KIRQL	        OldIrql;
    PASPC_CONNOBJ   pTmpConn;
    BOOLEAN         fConnIsValid=FALSE;

	ACQUIRE_SPIN_LOCK(&atalkAspCLock, &OldIrql);

    pTmpConn = atalkAspCConnList;

    while (pTmpConn)
    {
        if (pTmpConn == pAspConn)
        {
            fConnIsValid = TRUE;
            break;
        }

        pTmpConn = pTmpConn->aspcco_Next;
    }
	RELEASE_SPIN_LOCK(&atalkAspCLock, OldIrql);

    return(fConnIsValid);
}

LOCAL VOID
atalkAspCCloseSession(
	IN	PASPC_CONNOBJ				pAspConn
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	
}


LOCAL VOID
atalkAspCIncomingOpenReply(
	IN	ATALK_ERROR					ErrorCode,
	IN	PASPC_CONNOBJ				pAspConn,		// Our context
	IN	PAMDL						pReqAmdl,
	IN	PAMDL						pReadAmdl,
	IN	USHORT						ReadLen,
	IN	PBYTE						ReadUserBytes
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	ATALK_ERROR				error;
	USHORT					OpenStatus;
	BYTE					UserBytes[ATP_USERBYTES_SIZE];
	BOOLEAN					DerefConn = FALSE;
	PASPC_ADDROBJ			pAspAddr = pAspConn->aspcco_pAspCAddr;

	ASSERT(VALID_ASPCCO(pAspConn));

	if (ATALK_SUCCESS(ErrorCode))
	do
	{
		//	Check for open reply code in packet.
		GETSHORT2SHORT(&OpenStatus, &ReadUserBytes[ASP_ERRORCODE_OFF]);
		if (OpenStatus != 0)
		{
			DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_ERR,
					("atalkAspCIncomingOpenReply: Failed %ld, %lx\n", OpenStatus, pAspConn));

			DerefConn = TRUE;	// Since we are not queuing a request handler
			ErrorCode = ATALK_REMOTE_CLOSE;
			break;
		}

		ACQUIRE_SPIN_LOCK_DPC(&pAspConn->aspcco_Lock);

		//	Save the socket the server's SSS
		pAspConn->aspcco_ServerSssAddr = pAspConn->aspcco_ServerSlsAddr;
		pAspConn->aspcco_ServerSssAddr.ata_Socket = ReadUserBytes[ASP_SSS_OFF];
		pAspConn->aspcco_SessionId = ReadUserBytes[ASP_SESSIONID_OFF];
		pAspConn->aspcco_Flags &= ~ASPCCO_CONNECTING;
		pAspConn->aspcco_Flags |= ASPCCO_ACTIVE;

		pAspConn->aspcco_LastContactTime = AtalkGetCurrentTick();

		//	Reference for the request handler
		AtalkAspCConnReferenceByPtrNonInterlock(pAspConn, &error);

		//	Build up userBytes to start tickling the other end.
		UserBytes[ASP_CMD_OFF]	= ASP_TICKLE;
		UserBytes[ASP_SESSIONID_OFF] = pAspConn->aspcco_SessionId;
		PUTSHORT2SHORT(UserBytes + ASP_ERRORCODE_OFF, 0);

		RELEASE_SPIN_LOCK_DPC(&pAspConn->aspcco_Lock);

		//	Set the request handler on this connection.
		//	It will handle tickle's, close's and write-continue
		AtalkAtpSetReqHandler(pAspAddr->aspcao_pAtpAddr,
							  atalkAspCHandler,
							  pAspConn);

		error = AtalkAtpPostReq(pAspConn->aspcco_pAtpAddr,
								&pAspConn->aspcco_ServerSlsAddr,
								&pAspConn->aspcco_TickleTid,
								0,						// ALO transaction
								NULL,
								0,
								UserBytes,
								NULL,
								0,
								ATP_INFINITE_RETRIES,
								ASP_TICKLE_INTERVAL,
								THIRTY_SEC_TIMER,
								NULL,
								NULL);

		if (ATALK_SUCCESS(error))
		{
			ACQUIRE_SPIN_LOCK_DPC(&pAspConn->aspcco_Lock);
			pAspConn->aspcco_Flags |= ASPCCO_TICKLING;
			RELEASE_SPIN_LOCK_DPC(&pAspConn->aspcco_Lock);
		}
		else
		{
			DerefConn = TRUE;	// Since we are not queuing a request handler
		}
	} while (FALSE);

	if (!ATALK_SUCCESS(ErrorCode))
	{
		DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_ERR,
				("atalkAspCIncomingOpenReply: Incoming connect fail %lx\n", ErrorCode));

		AtalkAspCConnDereference(pAspConn);	

		//	Mark it as inactive
		ACQUIRE_SPIN_LOCK_DPC(&pAspConn->aspcco_Lock);
		pAspConn->aspcco_Flags &= ~ASPCCO_ACTIVE;
		RELEASE_SPIN_LOCK_DPC(&pAspConn->aspcco_Lock);
	}

	//	Call the completion routine.
	(*pAspConn->aspcco_ConnectCompletion)(ErrorCode, pAspConn->aspcco_ConnectCtx);
}


LOCAL VOID
atalkAspCIncomingStatus(
	IN	ATALK_ERROR					ErrorCode,
	IN	PACTREQ						pActReq,		// Our Ctx
	IN	PAMDL						pReqAmdl,
	IN	PAMDL						pStatusAmdl,
	IN	USHORT						StatusLen,
	IN	PBYTE						ReadUserBytes
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	//	Call the action completion routine
	(*pActReq->ar_Completion)(ErrorCode, pActReq);
}




LOCAL VOID
atalkAspCIncomingCmdReply(
	IN	ATALK_ERROR				Error,
	IN	PASPC_REQUEST			pAspReq,
	IN	PAMDL					pReqAMdl,
	IN	PAMDL					pRespAMdl,
	IN	USHORT					RespSize,
	IN	PBYTE					RespUserBytes
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PASPC_CONNOBJ	pAspConn;
	PASPC_REQUEST *	ppAspReq;
	KIRQL			OldIrql;

	pAspConn = pAspReq->aspcrq_pAspConn;

	ACQUIRE_SPIN_LOCK(&pAspConn->aspcco_Lock, &OldIrql);
	// Unlink the request from the active list
	for (ppAspReq = &pAspConn->aspcco_pActiveReqs;
		 *ppAspReq != NULL;
		 ppAspReq = &((*ppAspReq)->aspcrq_Next))
	{
		if (pAspReq == *ppAspReq)
		{
			*ppAspReq = pAspReq->aspcrq_Next;
			break;
		}
	}

	ASSERT(*ppAspReq == pAspReq->aspcrq_Next);

	RELEASE_SPIN_LOCK(&pAspConn->aspcco_Lock, OldIrql);

	// Complete the request
	(*pAspReq->aspcrq_pActReq->ar_Completion)(Error, pAspReq->aspcrq_pActReq);

	//  and dereference the connection
	AtalkAspCConnDereference(pAspConn);

	// and finally free the request
	AtalkFreeMemory(pAspReq);
}


LOCAL VOID
atalkAspCHandler(
	IN	ATALK_ERROR					ErrorCode,
	IN	PASPC_CONNOBJ				pAspConn,
	IN	PATP_RESP					pAtpResp,		// Used by PostResp/CancelResp
	IN	PATALK_ADDR					pSrcAddr,		// Address of requestor
	IN	USHORT						PktLen,
	IN	PBYTE						pPkt,
	IN	PBYTE						pUserBytes
	)
/*++

Routine Description:
	Handle tickle, write-continue requests, attentions and close from the server.

Arguments:


Return Value:


--*/
{
	USHORT						SequenceNum;	// From the incoming packet
	BYTE						SessionId;		// -- ditto --
	BYTE						RequestType;	// -- ditto --
	BOOLEAN						CancelTickle, ReleaseLock = TRUE, CancelResp = FALSE, Deref = FALSE;
	PIRP						exRecvIrp;
	PTDI_IND_RECEIVE_EXPEDITED	exRecvHandler;
	PVOID						exRecvHandlerCtx;
	ULONG						exIndicateFlags;
	PASPC_REQUEST				pAspReq;
	ATALK_ERROR					Error;

	do
	{
		if (!ATALK_SUCCESS(ErrorCode))
		{
			DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_ERR,
					("atalkAspCHandler: Error %ld\n", ErrorCode));
			// Take away the reference on the Conn now that the atp address is closing
			if (ErrorCode == ATALK_ATP_CLOSING)
				AtalkAspCConnDereference(pAspConn);
			break;
		}

		ASSERT(VALID_ASPCCO(pAspConn));

		ACQUIRE_SPIN_LOCK_DPC(&pAspConn->aspcco_Lock);

		SessionId = pUserBytes[ASP_SESSIONID_OFF];
		RequestType = pUserBytes[ASP_CMD_OFF];
		GETSHORT2SHORT(&SequenceNum, pUserBytes+ASP_SEQUENCE_NUM_OFF);

		AtalkAspCConnReferenceByPtrNonInterlock(pAspConn, &Error);
		if (ATALK_SUCCESS(Error) && (pAspConn->aspcco_SessionId == SessionId))
		{
			pAspConn->aspcco_LastContactTime = AtalkGetCurrentTick();
		
			switch (RequestType)
			{
			  case ASP_CLOSE_SESSION:
				// Cancel all outstanding requests (and any posted replies to write continue)
				// and shut down the session. Start off by sending a close response.
				CancelTickle = ((pAspConn->aspcco_Flags &ASPCO_TICKLING) != 0);
				pAspConn->aspcco_Flags &= ~(ASPCCO_ACTIVE | ASPCCO_TICKLING);
				pAspConn->aspcco_Flags |= ASPCO_REMOTE_CLOSE;
				RELEASE_SPIN_LOCK_DPC(&pAspConn->aspcco_Lock);
				ReleaseLock = FALSE;
		
				// Send a CloseSession reply and close the session
				Error = AtalkAtpPostResp(pAtpResp,
										 pSrcAddr,
										 NULL,
										 0,
										 NULL,
										 AtalkAtpGenericRespComplete,
										 pAtpResp);
				if (!ATALK_SUCCESS(Error))
				{
					AtalkAtpGenericRespComplete(Error, pAtpResp);
					DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_ERR,
							("atalkAspSssXHandler: AtalkAtpPostResp failed %ld\n", Error));
				}
		
				// Cancel the tickle requests for this session
				if (CancelTickle)
				{
					Error = AtalkAtpCancelReq(pAspConn->aspcco_pAtpAddr,
											  pAspConn->aspcco_TickleXactId,
											  &pAspConn->aspcco_ServerSssAddr);
			
					if (!ATALK_SUCCESS(Error))
					{
						DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_ERR,
								("atalkAspSssXHandler: AtalkAtpCancelReq %ld\n", Error));
					}
				}
		
				// Shut down this session, well almost ... Note that we have a reference
				// to this connection which will be Dereferenced by atalkAspSessionClose.
				atalkAspCCloseSession(pAspConn);
				break;

			  case ASP_ATTENTION:
				// Server is sending us an attention. If we already have a getattn posted
				// complete that. If not, just save the attention word and indicate to AFD
				// that we have recvd. expedited data
				if ((pAspConn->aspcco_AttnInPtr - pAspConn->aspcco_AttnOutPtr) < MAX_ASPC_ATTNS)
				{
					pAspConn->aspcco_AttnBuf[pAspConn->aspcco_AttnInPtr % MAX_ASPC_ATTNS] = SequenceNum;
					pAspConn->aspcco_AttnInPtr++;

					RELEASE_SPIN_LOCK_DPC(&pAspConn->aspcco_Lock);
					ReleaseLock = FALSE;
				}
				break;

			  case ASP_WRITE_DATA:
				// We need to find the request for which we sent a Write command. The
				// server now needs the data. Post a response for this.
				for (pAspReq = pAspConn->aspcco_pActiveReqs;
					 pAspReq != NULL;
					 pAspReq = pAspReq->aspcrq_Next)
				{
					if (pAspReq->aspcrq_SeqNum == SequenceNum)
					{
						RELEASE_SPIN_LOCK_DPC(&pAspConn->aspcco_Lock);
						ReleaseLock = FALSE;
						Error = AtalkAtpPostResp(pAtpResp,
												 pSrcAddr,
												 pAspReq->aspcrq_pWriteMdl,
												 pAspReq->aspcrq_WriteSize,
												 NULL,
												 AtalkAtpGenericRespComplete,
												 pAtpResp);
						Deref = TRUE;
						break;
					}
				}
				break;

			  case ASP_TICKLE:
				DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_INFO,
						("atalkAspCHandler: Received tickle from %x.%x Session %d\n",
						pSrcAddr->ata_Network, pSrcAddr->ata_Node, SessionId));
				CancelResp = TRUE;
				Deref = TRUE;
				break;
			
			  default:
				DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_INFO,
						("atalkAspCHandler: Invalid commnd %d from %x.%x Session %d\n",
						RequestType, pSrcAddr->ata_Network, pSrcAddr->ata_Node, SessionId));
				CancelResp = TRUE;
				Deref = TRUE;
				break;
			}
		}
		else
		{
			DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_ERR,
					("atalkAspCHandler: Mismatched session id from %d.%d, expected %d, recvd. %d\n",
					pSrcAddr->ata_Network, pSrcAddr->ata_Node,
					pAspConn->aspcco_SessionId, SessionId));
		}

		if (ReleaseLock)
		{
			RELEASE_SPIN_LOCK_DPC(&pAspConn->aspcco_Lock);
		}
		if (CancelResp)
		{
			AtalkAtpCancelResp(pAtpResp);
		}
		if (Deref)
		{
			AtalkAspCConnDereference(pAspConn);
		}
	} while (FALSE);
}


LOCAL LONG FASTCALL
atalkAspCSessionMaintenanceTimer(
	IN	PTIMERLIST				pTimer,
	IN	BOOLEAN					TimerShuttingDown
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	
	return ATALK_TIMER_REQUEUE;
}


VOID FASTCALL
AtalkAspCAddrDereference(
	IN	PASPC_ADDROBJ			pAspAddr
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	BOOLEAN	Close = FALSE;
	KIRQL	OldIrql;

	DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_REFASPADDR,
			("AtalkAspCAddrDereference: %lx, %d\n",
			pAspAddr, pAspAddr->aspcao_RefCount-1));

	ASSERT (VALID_ASPCAO(pAspAddr));

	ACQUIRE_SPIN_LOCK(&pAspAddr->aspcao_Lock, &OldIrql);
	if (--(pAspAddr->aspcao_RefCount) == 0)
	{
		ASSERT(pAspAddr->aspcao_Flags & ASPCAO_CLOSING);
		Close = TRUE;
	}
	RELEASE_SPIN_LOCK(&pAspAddr->aspcao_Lock, OldIrql);

	if (Close)
	{
		if (pAspAddr->aspcao_CloseCompletion != NULL)
			(*pAspAddr->aspcao_CloseCompletion)(ATALK_NO_ERROR,
											    pAspAddr->aspcao_CloseContext);
		// Finally free the memory
		AtalkFreeMemory(pAspAddr);

		AtalkUnlockAspCIfNecessary();
	}
}


VOID FASTCALL
AtalkAspCConnDereference(
	IN	PASPC_CONNOBJ			pAspConn
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	BOOLEAN	Close = FALSE;
	KIRQL	OldIrql;

	ASSERT (VALID_ASPCCO(pAspConn));

	DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_REFASPADDR,
			("AtalkAspCConnDereference: %lx, %d\n",
			pAspConn, pAspConn->aspcco_RefCount-1));

	ACQUIRE_SPIN_LOCK(&pAspConn->aspcco_Lock, &OldIrql);
	if (--(pAspConn->aspcco_RefCount) == 0)
	{
		ASSERT(pAspConn->aspcco_Flags & ASPCCO_CLOSING);
		Close = TRUE;
	}
	RELEASE_SPIN_LOCK(&pAspConn->aspcco_Lock, OldIrql);

	if (Close)
	{
		if (pAspConn->aspcco_CloseComp != NULL)
			(*pAspConn->aspcco_CloseComp)(ATALK_NO_ERROR,
											    pAspConn->aspcco_CloseCtx);

        atalkAspCDeQueueConnGlobalList(pAspConn);

		// Finally free the memory
		AtalkFreeMemory(pAspConn);

		AtalkUnlockAspCIfNecessary();
	}
}


LOCAL	VOID
atalkAspCQueueAddrGlobalList(
	IN	PASPC_ADDROBJ	pAspAddr
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	KIRQL	OldIrql;

	ACQUIRE_SPIN_LOCK(&atalkAspCLock, &OldIrql);
	AtalkLinkDoubleAtHead(atalkAspCAddrList, pAspAddr, aspcao_Next, aspcao_Prev);
	RELEASE_SPIN_LOCK(&atalkAspCLock, OldIrql);
}


LOCAL	VOID
atalkAspCDeQueueAddrGlobalList(
	IN	PASPC_ADDROBJ	pAspAddr
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	KIRQL	OldIrql;

	ACQUIRE_SPIN_LOCK(&atalkAspCLock, &OldIrql);
	AtalkUnlinkDouble(pAspAddr, aspcao_Next, aspcao_Prev);
	RELEASE_SPIN_LOCK(&atalkAspCLock, OldIrql);
}


LOCAL	VOID
atalkAspCQueueConnGlobalList(
	IN	PASPC_CONNOBJ	pAspConn
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	KIRQL	OldIrql;

	ACQUIRE_SPIN_LOCK(&atalkAspCLock, &OldIrql);
	AtalkLinkDoubleAtHead(atalkAspCConnList, pAspConn, aspcco_Next, aspcco_Prev);
	RELEASE_SPIN_LOCK(&atalkAspCLock, OldIrql);
}


LOCAL	VOID
atalkAspCDeQueueConnGlobalList(
	IN	PASPC_CONNOBJ	pAspCConn
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	KIRQL	OldIrql;

	ACQUIRE_SPIN_LOCK(&atalkAspCLock, &OldIrql);
	AtalkUnlinkDouble(pAspCConn, aspcco_Next, aspcco_Prev);
	RELEASE_SPIN_LOCK(&atalkAspCLock, OldIrql);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\atalk\sys\aspc.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

	aspc.h

Abstract:

	This module contains definitions for the client side ASP code.

Author:

	Jameel Hyder (jameelh@microsoft.com)

Revision History:
	19 Jun 1992		Initial Version

Notes:	Tab stop: 4
--*/

#ifndef	_ASPC_
#define	_ASPC_

#define	ASPC_CONN_HASH_BUCKETS		13	// Hashed by NodeAddr

#define	HASH_ASPC_SRCADDR(pSrcAddr)	\
			((((pSrcAddr)->ata_Node >> 2) +	\
			  ((pSrcAddr)->ata_Network & 0xFF)) % ASPC_CONN_HASH_BUCKETS)

// For resolving forward references
struct _AspCAddress;
struct _AspCConnxn;
struct _AspCRequest;

#define ASP_MIN_REQ_INTERVAL	5		// In 100ms units
#define ASP_MAX_REQ_INTERVAL	20		// In 100ms units
#define ASP_INIT_REQ_INTERVAL	5		// In 100ms units

#define	ASPCAO_CLOSING			0x8000
#define	ASPCAO_SIGNATURE		*(PULONG)"ACAO"

#define	VALID_ASPCAO(pAspCAddr)	(((pAspCAddr) != NULL) && \
			(((struct _AspCAddress *)(pAspCAddr))->aspcao_Signature == ASPCAO_SIGNATURE))

// Also known as the listener.
typedef struct _AspCAddress
{
	ULONG						aspcao_Signature;
	struct _AspCAddress *		aspcao_Next;			// Links to global list
	struct _AspCAddress **		aspcao_Prev;
	LONG						aspcao_RefCount;		// References to the address obj
	ULONG						aspcao_Flags;

	PATP_ADDROBJ				aspcao_pAtpAddr;		// Atp Socket for this asp conn
	GENERIC_COMPLETION			aspcao_CloseCompletion;
	PVOID						aspcao_CloseContext;
    PTDI_IND_DISCONNECT 		aspcao_DisconnectHandler;
    PVOID 						aspcao_DisconnectHandlerCtx;
    PTDI_IND_RECEIVE_EXPEDITED	aspcao_ExpRecvHandler;	// Used to indicate attention
    PVOID 						aspcao_ExpRecvHandlerCtx;
	ATALK_SPIN_LOCK				aspcao_Lock;
} ASPC_ADDROBJ, *PASPC_ADDROBJ;

#define	ASPCCO_ASSOCIATED		0x0001
#define	ASPCCO_ACTIVE			0x0002
#define	ASPCCO_TICKLING			0x0004
#define	ASPCCO_CONNECTING		0x0008
#define	ASPCCO_CLEANING_UP		0x0010
#define	ASPCCO_LOCAL_CLOSE		0x0020
#define	ASPCCO_REMOTE_CLOSE		0x0040
#define	ASPCCO_DROPPED			0x0080
#define	ASPCCO_ATTN_PENDING		0x0100
#define	ASPCCO_DISCONNECTING	0x0200
#define	ASPCCO_CLOSING			0x8000
#define	ASPCCO_SIGNATURE		*(PULONG)"ACCO"
#define	MAX_ASPC_ATTNS			8

#define	VALID_ASPCCO(pAspConn)	(((pAspConn) != NULL) && \
			(((struct _AspCConnxn *)(pAspConn))->aspcco_Signature == ASPCCO_SIGNATURE))

typedef struct _AspCConnxn
{
	ULONG						aspcco_Signature;

	struct _AspCConnxn *		aspcco_Next;		// Links to global list
	struct _AspCConnxn **		aspcco_Prev;
	LONG						aspcco_RefCount;	// References to the conn obj
	struct _AspCAddress	*		aspcco_pAspCAddr;	// Back pointer to the address

	struct _AspCRequest	*		aspcco_pActiveReqs;	// List of requests being processed
	PATP_ADDROBJ				aspcco_pAtpAddr;	// Atp Socket for this asp conn
													// Copy of aspcao_pAtpAddr for efficiency
	LONG						aspcco_LastContactTime;
	ATALK_ADDR					aspcco_ServerSlsAddr;//This is the server addr to which we send
													// the tickles/open/getstatus
	ATALK_ADDR					aspcco_ServerSssAddr;//This is the server addr to which we send
													// the commands/writes
	BYTE						aspcco_SessionId;
	BYTE						aspcco_cReqsInProcess;// Count of requests in process
	USHORT						aspcco_Flags;		// aspcco_xxx values
	USHORT						aspcco_NextSeqNum;
	USHORT						aspcco_OpenSessTid;
	USHORT						aspcco_TickleTid;
	union
	{
		USHORT					aspcco_TickleXactId;// Transaction id for tickles
		USHORT					aspcco_OpenSessId;	// Transaction id for open-session request
	};

	// We keep a circular buffer for storing attentions. If full further attention
	// bytes overwrite it
	USHORT						aspcco_AttnBuf[MAX_ASPC_ATTNS];
	USHORT						aspcco_AttnInPtr;
	USHORT						aspcco_AttnOutPtr;

	RT							aspcco_RT;			// Used for adaptive round-trip time calculation

	PVOID						aspcco_ConnCtx;

	//	Read (GetAttn) Completion routine
	GENERIC_READ_COMPLETION		aspcco_ReadCompletion;
	PVOID						aspcco_ReadCtx;

	//	Connect inform routine
	GENERIC_COMPLETION			aspcco_ConnectCompletion;
	PVOID						aspcco_ConnectCtx;

	//	Disconnect inform routine
	GENERIC_COMPLETION			aspcco_DisconnectInform;
	PVOID						aspcco_DisconnectInformCtx;

	//	Disconnect request completion
	ATALK_ERROR					aspcco_DisconnectStatus;
	GENERIC_COMPLETION			aspcco_DisconnectCompletion;
	PVOID						aspcco_DisconnectCtx;

	// Completion routine to be called when socket is cleaned-up
	GENERIC_COMPLETION			aspcco_CleanupComp;
	PVOID						aspcco_CleanupCtx;

	// Completion routine to be called when socket is closed
	GENERIC_COMPLETION			aspcco_CloseComp;
	PVOID						aspcco_CloseCtx;

	PATALK_DEV_CTX				aspcco_pDevCtx;
	ATALK_SPIN_LOCK				aspcco_Lock;
} ASPC_CONNOBJ, *PASPC_CONNOBJ;

#define	ASPCRQ_COMMAND				0x0001		// Asp Command
#define	ASPCRQ_WRITE				0x0002		// Asp Write
#define	ASPCRQ_WRTCONT				0x0004		// Write continue recvd. and replied

// The request gets created when a Command or Write is posted
#define	ASPCRQ_SIGNATURE			*(PULONG)"ACRQ"
#if	DBG
#define	VALID_ASPCRQ(pAspCReq)	(((pAspCReq) != NULL) && \
								 ((pAspCReq)->aspcrq_Signature == ASPRQ_SIGNATURE))
#else
#define	VALID_ASPCRQ(pAspCReq)	((pAspCReq) != NULL)
#endif

typedef struct _AspCRequest
{
#if	DBG
	ULONG						aspcrq_Signature;
#endif
	struct _AspCRequest	*		aspcrq_Next;	// Link to next request
	LONG						aspcrq_RefCount;// Reference Count
	struct _AspCConnxn	*		aspcrq_pAspConn;// Owning connection
	PATP_RESP					aspcrq_pAtpResp;// Used to reply to a wrtcont request
	PACTREQ						aspcrq_pActReq;	// Request completion
	union
	{
		PAMDL					aspcrq_pReplyMdl;
		PAMDL					aspcrq_pWriteMdl;
	};
	USHORT						aspcrq_SeqNum;
	USHORT						aspcrq_ReqXactId;// Transaction Id of the request/command
	USHORT						aspcrq_Flags;	// Various ASPRQ_xxx values
	union
	{
		USHORT					aspcrq_ReplySize;
		USHORT					aspcrq_WriteSize;
	};

	ATALK_SPIN_LOCK				aspcrq_Lock;	// Spin-lock
} ASPC_REQUEST, *PASPC_REQUEST;

//	MACROS
#define	AtalkAspCGetDdpAddress(pAspAddr)	\
							AtalkAtpGetDdpAddress((pAspAddr)->aspcao_pAtpAddr)

extern
VOID
AtalkInitAspCInitialize(
	VOID
);

extern
ATALK_ERROR
AtalkAspCCreateAddress(
	IN	PATALK_DEV_CTX			pDevCtx	OPTIONAL,
	OUT	PASPC_ADDROBJ	*		ppAspAddr
);

extern
ATALK_ERROR
AtalkAspCCleanupAddress(
	IN	PASPC_ADDROBJ			pAspAddr
);

extern
ATALK_ERROR
AtalkAspCCloseAddress(
	IN	PASPC_ADDROBJ			pAspAddr,
	IN	GENERIC_COMPLETION		CompletionRoutine,
	IN	PVOID					CloseContext
);

extern
ATALK_ERROR
AtalkAspCCreateConnection(
	IN	PVOID					ConnCtx,
	IN	PATALK_DEV_CTX			pDevCtx	OPTIONAL,
	OUT	PASPC_CONNOBJ	*		ppAspConn
);

extern
ATALK_ERROR
AtalkAspCCleanupConnection(
	IN	PASPC_CONNOBJ			pAspConn
);

extern
ATALK_ERROR
AtalkAspCCloseConnection(
	IN	PASPC_CONNOBJ			pAspConn,
	IN	GENERIC_COMPLETION		CompletionRoutine,
	IN	PVOID					CloseContext
);

//	MACROS
#define	AtalkAspCAddrReferenceNonInterlock(_pAspAddr, _pError)	\
{																\
	if (((_pAspAddr)->aspcao_Flags & ASPCAO_CLOSING) == 0)		\
	{															\
		ASSERT((_pAspAddr)->aspcao_RefCount >= 1);				\
		(_pAspAddr)->aspcao_RefCount++;							\
		*(_pError) = ATALK_NO_ERROR;							\
	}															\
	else														\
	{															\
		*(_pError) = ATALK_ASPC_ADDR_CLOSING;					\
	}															\
	if (ATALK_SUCCESS(*(_pError)))								\
	{															\
		DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_REFASPADDR,			\
				("RefAddr %lx at %s(%d) = %d\n",				\
				_pAspAddr, __FILE__, __LINE__,					\
				((_pAspAddr)->aspcao_RefCount)));				\
	}															\
}

#define	AtalkAspCAddrReference(_pAspAddr, _pError)				\
	{															\
		KIRQL	OldIrql;										\
																\
		ACQUIRE_SPIN_LOCK(&(_pAspAddr)->aspcao_Lock, &OldIrql);	\
		AtalkAspCAddrReferenceNonInterlock(_pAspAddr, _pError);	\
		RELEASE_SPIN_LOCK(&(_pAspAddr)->aspcao_Lock, OldIrql);	\
	}

#define	AtalkAspCConnReferenceByPtrNonInterlock(_pAspConn, _pError)	\
	{															\
		if (((_pAspConn)->aspcco_Flags & ASPCCO_CLOSING) == 0)	\
		{														\
			ASSERT((_pAspConn)->aspcco_RefCount >= 1);			\
			(_pAspConn)->aspcco_RefCount++;						\
			*(_pError) = ATALK_NO_ERROR;						\
		}														\
		else													\
		{														\
			*(_pError) = ATALK_ASPC_ADDR_CLOSING;				\
		}														\
	}

#define	AtalkAspCConnReference(_pAspConn, _pError)				\
	{															\
		KIRQL	OldIrql;										\
																\
		ACQUIRE_SPIN_LOCK(&(_pAspConn)->aspcco_Lock, &OldIrql);	\
		AtalkAspCConnReferenceByPtrNonInterlock(_pAspConn, _pError);\
		RELEASE_SPIN_LOCK(&(_pAspConn)->aspcco_Lock, OldIrql);	\
	}

extern
VOID FASTCALL
AtalkAspCAddrDereference(
	IN	PASPC_ADDROBJ			pAspAddr
);

extern
VOID FASTCALL
AtalkAspCConnDereference(
	IN	PASPC_CONNOBJ			pAspConn
);

extern
ATALK_ERROR
AtalkAspCAssociateAddress(
	IN	PASPC_ADDROBJ			pAspAddr,
	IN	PASPC_CONNOBJ			pAspConn
);

extern
ATALK_ERROR
AtalkAspCDissociateAddress(
	IN	PASPC_CONNOBJ			pAspConn
);

extern
ATALK_ERROR
AtalkAspCPostConnect(
	IN	PASPC_CONNOBJ			pAspConn,
	IN	PATALK_ADDR				pRemoteAddr,
	IN	PVOID					pConnectCtx,
	IN	GENERIC_COMPLETION		CompletionRoutine
);

extern
ATALK_ERROR
AtalkAspCDisconnect(
	IN	PASPC_CONNOBJ			pAspConn,
	IN	ATALK_DISCONNECT_TYPE	DisconnectType,
	IN	PVOID					pDisconnectCtx,
	IN	GENERIC_COMPLETION		CompletionRoutine
);

extern
ATALK_ERROR
AtalkAspCGetStatus(
	IN	PASPC_ADDROBJ			pAspAddr,
	IN	PATALK_ADDR				pRemoteAddr,
	IN	PAMDL					pStatusAmdl,
	IN	USHORT					AmdlSize,
	IN	PACTREQ					pActReq
);

extern
ATALK_ERROR
AtalkAspCGetAttn(
	IN	PASPC_CONNOBJ			pAspConn,
	IN	PAMDL					pReadBuf,
	IN	USHORT					ReadBufLen,
	IN	ULONG					ReadFlags,
	IN	PVOID					pReadCtx,
	IN	GENERIC_READ_COMPLETION	CompletionRoutine
);

extern
ATALK_ERROR
AtalkAspCCmdOrWrite(
	IN	PASPC_CONNOBJ			pAspConn,
	IN	PAMDL					pCmdMdl,
	IN	USHORT					CmdSize,
	IN	PAMDL					pReplyMdl,
	IN	USHORT					ReplySize,
	IN	BOOLEAN					fWrite,		// If TRUE, its a write else command
	IN	PACTREQ					pActReq
);


BOOLEAN
AtalkAspCConnectionIsValid(
	IN	PASPC_CONNOBJ	pAspConn
);

// This is a list of all active connections. This is scanned by the session
// maintenance timer.
typedef	struct
{
	PASP_CONNOBJ	ascm_ConnList;
    TIMERLIST		ascm_SMTTimer;
} ASPC_CONN_MAINT, *PASPC_CONN_MAINT;

extern	ASPC_CONN_MAINT	atalkAspCConnMaint;

extern	ATALK_SPIN_LOCK	atalkAspCLock;
extern	PASPC_ADDROBJ	atalkAspCAddrList;
extern	PASPC_CONNOBJ	atalkAspCConnList;

LOCAL VOID
atalkAspCCloseSession(
	IN	PASPC_CONNOBJ			pAspConn
);

LOCAL VOID
atalkAspCHandler(
	IN	ATALK_ERROR				ErrorCode,
	IN	PASPC_CONNOBJ			pAspConn,		// Listener (our context)
	IN	PATP_RESP				RespCtxt,		// Used by PostResp/CancelResp
	IN	PATALK_ADDR				pSrcAddr,		// Address of requestor
	IN	USHORT					PktLen,
	IN	PBYTE					pPkt,
	IN	PBYTE					pUserBytes
);

LOCAL VOID
atalkAspCIncomingOpenReply(
	IN	ATALK_ERROR				ErrorCode,
	IN	PASPC_CONNOBJ			pAspConn,		// Our context
	IN	PAMDL					pReqAmdl,
	IN	PAMDL					pReadAmdl,
	IN	USHORT					ReadLen,
	IN	PBYTE					ReadUserBytes
);

LOCAL VOID
atalkAspCIncomingStatus(
	IN	ATALK_ERROR				ErrorCode,
	IN	PACTREQ					pActReq,		// Our Ctx
	IN	PAMDL					pReqAmdl,
	IN	PAMDL					pStatusAmdl,
	IN	USHORT					StatusLen,
	IN	PBYTE					ReadUserBytes
);

LOCAL VOID
atalkAspCIncomingCmdReply(
	IN	ATALK_ERROR				Error,
	IN	PASPC_REQUEST			pAspReq,
	IN	PAMDL					pReqAMdl,
	IN	PAMDL					pRespAMdl,
	IN	USHORT					RespSize,
	IN	PBYTE					RespUserBytes
);

LOCAL LONG FASTCALL
atalkAspCSessionMaintenanceTimer(
	IN	PTIMERLIST				pTimer,
	IN	BOOLEAN					TimerShuttingDown
);

LOCAL VOID FASTCALL
atalkAspCGenericRespComplete(
	IN	ATALK_ERROR				ErrorCode,
	IN	PATP_RESP				pAtpResp
);

LOCAL	VOID
atalkAspCQueueAddrGlobalList(
	IN	PASPC_ADDROBJ			pAspCAddr
);

LOCAL	VOID
atalkAspCDeQueueAddrGlobalList(
	IN	PASPC_ADDROBJ			pAspCAddr
);

LOCAL	VOID
atalkAspCQueueConnGlobalList(
	IN	PASPC_CONNOBJ			pAspConn
);

LOCAL	VOID
atalkAspCDeQueueConnGlobalList(
	IN	PASPC_CONNOBJ			pAspCConn
);

#endif	// _ASPC_


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\atalk\sys\atalk.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

	atalk.h

Abstract:

	This module is the main include file for the Appletalk protocol stack.

Author:

	Jameel Hyder (jameelh@microsoft.com)
	Nikhil Kamkolkar (nikhilk@microsoft.com)

Revision History:
	19 Jun 1992		Initial Version

Notes:	Tab stop: 4
--*/

#pragma warning(disable:4010)

#ifndef	_ATALK_
#define	_ATALK_

#include <ntosp.h>
#include <zwapi.h>
#include <tdikrnl.h>
#include <ndis.h>

#define EQU           =
#if	DBG
// Turn off FASTCALL for checked builds
#undef	FASTCALL
#define	FASTCALL
#define	LOCAL
#else
//	#define	LOCAL	static
#define	LOCAL
#endif

//	Basic types for appletalk
#include "fwddecl.h"
#include "lists.h"
#include "atktypes.h"

//	The exported tdi interface file.
#include <atalktdi.h>

//	Main driver file
#include "atkdrvr.h"

//	Now the basic stuff
#include "atktimer.h"

// ARAP support
#include "v42bis.h"
#include "arapio.h"
#include "arap.h"

#include "atkerror.h"
#include "atkmsg.h"
#include "atkmem.h"
#include "atkstat.h"
#include "ports.h"
#include "node.h"
#include "atktdi.h"
#include "ddp.h"
#include "aarp.h"
#include "atkndis.h"
#include "atkutils.h"
#include "router.h"
#include "atktdi.h"
#include "atkinit.h"
#include "atkquery.h"
#include "nbp.h"
#include "rtmp.h"
#include "zip.h"
#include "aep.h"
#include "atp.h"
#include "asp.h"
#include "aspc.h"
#include "pap.h"
#include "adsp.h"
#include "blkpool.h"

#include "rasproto.h"
#endif	// _ATALK_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\atalk\sys\asp.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

	asp.c

Abstract:

	This module implements the ASP protocol.

Author:

	Jameel Hyder (jameelh@microsoft.com)
	Nikhil Kamkolkar (nikhilk@microsoft.com)

Revision History:
	30 Mar 1993		Initial Version

Notes:	Tab stop: 4
--*/

#include <atalk.h>
#pragma hdrstop
#define	FILENUM		ASP

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, AtalkInitAspInitialize)
#pragma alloc_text(PAGE, AtalkAspCreateAddress)
#pragma alloc_text(PAGE_ASP, AtalkAspCloseAddress)
#pragma alloc_text(PAGE_ASP, AtalkAspSetStatus)
#pragma alloc_text(PAGE_ASP, AtalkAspListenControl)
#pragma alloc_text(PAGE_ASP, AtalkAspCloseConnection)
#pragma alloc_text(PAGE_ASP, AtalkAspFreeConnection)
#pragma alloc_text(PAGE_ASP, AtalkAspCleanupConnection)
#pragma alloc_text(PAGE_ASP, AtalkAspWriteContinue)
#pragma alloc_text(PAGE_ASP, AtalkAspReply)
#pragma alloc_text(PAGE_ASP, atalkAspPostWriteContinue)
#pragma alloc_text(PAGE_ASP, AtalkAspSendAttention)
#pragma alloc_text(PAGE_ASP, AtalkAspReferenceAddr)
#pragma alloc_text(PAGE_ASP, atalkAspReferenceConnBySrcAddr)
#pragma alloc_text(PAGE_ASP, AtalkAspDereferenceConn)
#pragma alloc_text(PAGE_ASP, atalkAspSlsXHandler)
#pragma alloc_text(PAGE_ASP, atalkAspSssXHandler)
#pragma alloc_text(PAGE_ASP, atalkAspReplyRelease)
#pragma alloc_text(PAGE_ASP, atalkAspWriteContinueResp)
#pragma alloc_text(PAGE_ASP, atalkAspSendAttentionResp)
#pragma alloc_text(PAGE_ASP, atalkAspSessionClose)
#pragma alloc_text(PAGE_ASP, atalkAspReturnResp)
#pragma alloc_text(PAGE_ASP, atalkAspRespComplete)
#pragma alloc_text(PAGE_ASP, atalkAspCloseComplete)
#endif

/*
 * The model for ASP calls in this module is as follows:
 *
 * - For create calls (CreateAddress & CreateSession), a pointer to the created
 *	 object is returned. This structure is referenced for creation.
 * - For all other calls, it expects a referenced pointer to the object.
 */


VOID
AtalkInitAspInitialize(
	VOID
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	LONG	i;

	INITIALIZE_SPIN_LOCK(&atalkAspLock);

	for (i = 0; i < NUM_ASP_CONN_LISTS; i++)
	{
		AtalkTimerInitialize(&atalkAspConnMaint[i].ascm_SMTTimer,
							 atalkAspSessionMaintenanceTimer,
							 (SHORT)(ASP_SESSION_MAINTENANCE_TIMER - i*ASP_SESSION_TIMER_STAGGER));
		AtalkTimerScheduleEvent(&atalkAspConnMaint[i].ascm_SMTTimer);
	}
}




ATALK_ERROR
AtalkAspCreateAddress(
	OUT	PASP_ADDROBJ	*	ppAspAddr
	)
/*++

Routine Description:

 	Create an ASP address object (aka listener). This object is associated with
 	two seperate Atp sockets, one each for the Sls and the Sss. The Sls accepts
 	the tickle, getstatus and opensession requests from the client end. The
 	Sss accepts requests.

 	Currently only the server side ASP is implemented and hence the ASP address
 	object is only a listener.

Arguments:


Return Value:


--*/
{
	PASP_ADDROBJ		pAspAddr = NULL;
	ATALK_ERROR			Status;
	int					i;

	DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_INFO,
			("AtalkAspCreateAddr: Entered\n"));

	do
	{
		// Allocate memory for the Asp address object
		if ((pAspAddr = AtalkAllocZeroedMemory(sizeof(ASP_ADDROBJ))) == NULL)
		{
			Status = ATALK_RESR_MEM;
			break;
		}

		// Initialize the Asp address object
#if	DBG
		pAspAddr->aspao_Signature = ASPAO_SIGNATURE;
#endif
		INITIALIZE_SPIN_LOCK(&pAspAddr->aspao_Lock);

		// Refcounts for creation, Sls & Sss sockets and request handlers
		pAspAddr->aspao_RefCount = 1 + 2 + 2;
		pAspAddr->aspao_NextSessionId = 1;
		pAspAddr->aspao_EnableNewConnections = TRUE;

		// Create an Atp Socket on the port for the Sls
		Status = AtalkAtpOpenAddress(AtalkDefaultPort,
									 0,
									 NULL,
									 ATP_DEF_MAX_SINGLE_PKT_SIZE,
									 ATP_DEF_SEND_USER_BYTES_ALL,
									 NULL,
									 TRUE,		// CACHE this address
									 &pAspAddr->aspao_pSlsAtpAddr);

		if (!ATALK_SUCCESS(Status))
		{
			DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_ERR,
					("AtalkAspCreateAddress: AtalkAtpOpenAddress for Sls failed %ld\n", Status));
			break;
		}

		// Set Request handler for the SLS to handle GetStatus, OpenSession and Tickle
		AtalkAtpSetReqHandler(pAspAddr->aspao_pSlsAtpAddr,
							  atalkAspSlsXHandler,
							  pAspAddr);

		// Create the Atp Socket on the port for the Sss
		Status = AtalkAtpOpenAddress(AtalkDefaultPort,
									 0,
									 NULL,
									 ATP_DEF_MAX_SINGLE_PKT_SIZE,
									 ATP_DEF_SEND_USER_BYTES_ALL,
									 NULL,
									 TRUE,		// CACHE this address
									 &pAspAddr->aspao_pSssAtpAddr);

		if (!ATALK_SUCCESS(Status))
		{
			DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_ERR,
					("AtalkAspCreateAddress: AtalkAtpOpenAddress for Sss failed %ld\n", Status));
			break;
		}

		// Set Request handler for the SSS to handle Cmd/Write/Close
		AtalkAtpSetReqHandler(pAspAddr->aspao_pSssAtpAddr,
							  atalkAspSssXHandler,
							  pAspAddr);
	} while (FALSE);

	if (!ATALK_SUCCESS(Status))
	{
		if (pAspAddr != NULL)
		{
			if (pAspAddr->aspao_pSlsAtpAddr != NULL)
			{
				DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_ERR,
						("AtalkAspCreateAddress: Closing SLS Atp Address %lx\n",
						pAspAddr->aspao_pSlsAtpAddr));
				AtalkAtpCloseAddress(pAspAddr->aspao_pSlsAtpAddr, NULL, NULL);
			}
			if (pAspAddr->aspao_pSssAtpAddr != NULL)
			{
				DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_ERR,
						("AtalkAspCreateAddress: Closing SSS Atp Address %lx\n",
						pAspAddr->aspao_pSssAtpAddr));
				AtalkAtpCloseAddress(pAspAddr->aspao_pSssAtpAddr, NULL, NULL);
			}
			AtalkFreeMemory(pAspAddr);
		}
	}
	else
	{
		*ppAspAddr = pAspAddr;
	}

	return Status;
}




ATALK_ERROR
AtalkAspCloseAddress(
	IN	PASP_ADDROBJ			pAspAddr,
	IN	GENERIC_COMPLETION		CompletionRoutine,
	IN	PVOID					CloseContext
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PASP_CONNOBJ	pAspConn;
	KIRQL			OldIrql;
	int				i;
	ATALK_ERROR		Status = ATALK_PENDING;
    PBYTE           pStatusBuf;

	ASSERT(VALID_ASPAO(pAspAddr));
	ASSERT(pAspAddr->aspao_RefCount > 1);

	DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_INFO,
			("AtalkAspCloseAddr: Entered for Addr %lx\n", pAspAddr));

	ACQUIRE_SPIN_LOCK(&pAspAddr->aspao_Lock, &OldIrql);

	pAspAddr->aspao_Flags |= ASPAO_CLOSING;

	pAspAddr->aspao_CloseCompletion = CompletionRoutine;
	pAspAddr->aspao_CloseContext = CloseContext;

    pStatusBuf = pAspAddr->aspao_pStatusBuf;
    pAspAddr->aspao_pStatusBuf = NULL;

	RELEASE_SPIN_LOCK(&pAspAddr->aspao_Lock, OldIrql);

	// Close down the atp sockets for Sls and Sss
	DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_WARN,
			("AtalkAspCloseAddress: Closing SLS Atp Address %lx\n",
			pAspAddr->aspao_pSlsAtpAddr));

	AtalkAtpCloseAddress(pAspAddr->aspao_pSlsAtpAddr,
						 atalkAspCloseComplete,
						 pAspAddr);

	DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_WARN,
			("AtalkAspCloseAddress: Closing SSS Atp Address %lx\n",
			pAspAddr->aspao_pSssAtpAddr));

	AtalkAtpCloseAddress(pAspAddr->aspao_pSssAtpAddr,
						 atalkAspCloseComplete,
						 pAspAddr);

	// Free the status buffer if any
	if (pStatusBuf != NULL)
	{
		AtalkFreeMemory(pStatusBuf);
	}

	// Shut down the active sessions now.
	for (i = 0; i < ASP_CONN_HASH_BUCKETS; i++)
	{
		ACQUIRE_SPIN_LOCK(&pAspAddr->aspao_Lock, &OldIrql);
		pAspConn = pAspAddr->aspao_pSessions[i];
		while (pAspConn != NULL)
		{
			ACQUIRE_SPIN_LOCK_DPC(&pAspConn->aspco_Lock);

            // if we have visited this guy, skip it
            if (pAspConn->aspco_Flags & ASPCO_SHUTDOWN)
            {
			    RELEASE_SPIN_LOCK_DPC(&pAspConn->aspco_Lock);

	            DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_ERR,
			        ("AtalkAspCloseAddress: VISITED: skipping conn %lx Flags %lx RefCount %d\n",
			        pAspConn,pAspConn->aspco_Flags,pAspConn->aspco_RefCount));

                // we still have the pAspAddr->aspao_Lock spinlock held!
                pAspConn = pAspConn->aspco_NextOverflow;
                continue;
            }

			pAspConn->aspco_Flags |= (ASPCO_LOCAL_CLOSE | ASPCO_SHUTDOWN);

			// Reference this since atalkAspSessionClose() expects it.
			pAspConn->aspco_RefCount ++;

			RELEASE_SPIN_LOCK_DPC(&pAspConn->aspco_Lock);

			RELEASE_SPIN_LOCK(&pAspAddr->aspao_Lock, OldIrql);

			atalkAspSessionClose(pAspConn);

			ACQUIRE_SPIN_LOCK(&pAspAddr->aspao_Lock, &OldIrql);
		}
		RELEASE_SPIN_LOCK(&pAspAddr->aspao_Lock, OldIrql);
	}

	ASSERT(KeGetCurrentIrql() == LOW_LEVEL);

	// Let remaining cleanup happen during the Derefernce
	AtalkAspDereferenceAddr(pAspAddr);		// Remove the creation reference

	return Status;
}




ATALK_ERROR
AtalkAspBind(
	IN	PASP_ADDROBJ			pAspAddr,
	IN	PASP_BIND_PARAMS		pBindParms,
	IN	PACTREQ					pActReq
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{

    KIRQL   OldIrql;

	ASSERT (VALID_ASPAO(pAspAddr));

    // copy network addr

	ACQUIRE_SPIN_LOCK(&pAspAddr->aspao_Lock, &OldIrql);
    pBindParms->pXportEntries->asp_AtalkAddr.Network =
                pAspAddr->aspao_pSlsAtpAddr->atpao_DdpAddr->ddpao_Addr.ata_Network;
    pBindParms->pXportEntries->asp_AtalkAddr.Node =
                pAspAddr->aspao_pSlsAtpAddr->atpao_DdpAddr->ddpao_Addr.ata_Node;
    pBindParms->pXportEntries->asp_AtalkAddr.Socket =
                pAspAddr->aspao_pSlsAtpAddr->atpao_DdpAddr->ddpao_Addr.ata_Socket;
	RELEASE_SPIN_LOCK(&pAspAddr->aspao_Lock, OldIrql);

	// Fill in our entry points into the client buffer
	pBindParms->pXportEntries->asp_AspCtxt = pAspAddr;
	pBindParms->pXportEntries->asp_SetStatus = AtalkAspSetStatus;
	pBindParms->pXportEntries->asp_CloseConn = AtalkAspCloseConnection;
	pBindParms->pXportEntries->asp_FreeConn  = AtalkAspFreeConnection;
	pBindParms->pXportEntries->asp_ListenControl = AtalkAspListenControl;
	pBindParms->pXportEntries->asp_WriteContinue = AtalkAspWriteContinue;
	pBindParms->pXportEntries->asp_Reply = AtalkAspReply;
	pBindParms->pXportEntries->asp_SendAttention = AtalkAspSendAttention;

	// Get the clients entry points
	pAspAddr->aspao_ClientEntries = pBindParms->ClientEntries;

	// Call the completion routine before returning.
	(*pActReq->ar_Completion)(ATALK_NO_ERROR, pActReq);

	return ATALK_PENDING;
}


NTSTATUS
AtalkAspSetStatus(
	IN	PASP_ADDROBJ	pAspAddr,
	IN	PUCHAR			pStatusBuf,
	IN	USHORT			StsBufSize
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	KIRQL			OldIrql;
	NTSTATUS		Status = STATUS_SUCCESS;
	PUCHAR			pOldBuf = NULL, pNewBuf = NULL;

	ASSERT(VALID_ASPAO(pAspAddr));

	DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_INFO,
			("AtalkAspSetStatus: Entered for Addr %lx\n", pAspAddr));

	do
	{
		if (pStatusBuf != NULL)
		{
			// Allocate a buffer and copy the contents of the passed in
			// buffer descriptor in it. Free an existing status buffer if one exists
			if (StsBufSize >= ASP_MAX_STATUS_SIZE)
			{
				Status = STATUS_BUFFER_TOO_SMALL;
				break;
			}

			if ((pNewBuf = AtalkAllocMemory(StsBufSize)) == NULL)
			{
				Status = STATUS_INSUFFICIENT_RESOURCES;
				break;
			}
			RtlCopyMemory(pNewBuf, pStatusBuf, StsBufSize);
		}

		ACQUIRE_SPIN_LOCK(&pAspAddr->aspao_Lock, &OldIrql);

		if (pAspAddr->aspao_pStatusBuf != NULL)
		{
			ASSERT(pAspAddr->aspao_StsBufSize != 0);
			pOldBuf = pAspAddr->aspao_pStatusBuf;
		}

		pAspAddr->aspao_pStatusBuf = pNewBuf;
		pAspAddr->aspao_StsBufSize = StsBufSize;

		RELEASE_SPIN_LOCK(&pAspAddr->aspao_Lock, OldIrql);

		if (pOldBuf != NULL)
			AtalkFreeMemory(pOldBuf);
	} while (FALSE);

	return Status;
}




NTSTATUS FASTCALL
AtalkAspListenControl(
	IN	PASP_ADDROBJ	pAspAddr,
	IN	BOOLEAN			Enable
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	KIRQL		OldIrql;
	NTSTATUS	Status = STATUS_UNSUCCESSFUL;

	if (AtalkAspReferenceAddr(pAspAddr))
	{
		ACQUIRE_SPIN_LOCK(&pAspAddr->aspao_Lock, &OldIrql);
		pAspAddr->aspao_EnableNewConnections = Enable;
		RELEASE_SPIN_LOCK(&pAspAddr->aspao_Lock, OldIrql);

		AtalkAspDereferenceAddr(pAspAddr);
		Status = STATUS_SUCCESS;
	}

	return Status;
}


NTSTATUS
AtalkAspCloseConnection(
	IN	PASP_CONNOBJ			pAspConn
	)
/*++

Routine Description:

 	Shutdown a session.

Arguments:


Return Value:


--*/
{
	KIRQL		OldIrql;
	BOOLEAN		CompListen = FALSE;

	ASSERT(VALID_ASPCO(pAspConn));
	ASSERT(pAspConn->aspco_RefCount > 0);

	DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_INFO,
			("AtalkAspCloseConn: Entered for Conn %lx\n", pAspConn));

	DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_WARN,
			("AtalkCloseConnection: Close session from %d.%d for Session %d\n",
			pAspConn->aspco_WssRemoteAddr.ata_Network,
			pAspConn->aspco_WssRemoteAddr.ata_Node,
			pAspConn->aspco_SessionId));

	AtalkAspCleanupConnection(pAspConn);

	ACQUIRE_SPIN_LOCK(&pAspConn->aspco_Lock, &OldIrql);

	pAspConn->aspco_Flags |= (ASPCO_CLOSING | ASPCO_LOCAL_CLOSE);

	RELEASE_SPIN_LOCK(&pAspConn->aspco_Lock, OldIrql);


	DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_INFO,
			("AtalkAspCloseConnection: Done for %lx (%ld)\n",
			pAspConn, pAspConn->aspco_RefCount));

	// Let remaining cleanup happen during the Derefernce
	AtalkAspDereferenceConn(pAspConn);	// Remove the creation reference

#ifdef	PROFILING
	INTERLOCKED_DECREMENT_LONG( &AtalkStatistics.stat_CurAspSessions,
								&AtalkStatsLock.SpinLock);
#endif

	return STATUS_PENDING;
}


NTSTATUS
AtalkAspFreeConnection(
	IN	PASP_CONNOBJ			pAspConn
	)
/*++

Routine Description:

 	Shutdown a session.

Arguments:


Return Value:


--*/
{
	return STATUS_SUCCESS;
}



ATALK_ERROR
AtalkAspCleanupConnection(
	IN	PASP_CONNOBJ			pAspConn
	)
/*++

Routine Description:
	Cancel all I/O on this session. Complete pending replies and write
	continues with error.

Arguments:


Return Value:


--*/
{
	PASP_REQUEST	pAspReq;
	PASP_ADDROBJ	pAspAddr;
	ATALK_ERROR		Status;
	KIRQL			OldIrql;
	USHORT			XactId;
	BYTE			UserBytes[ATP_USERBYTES_SIZE];
	ATALK_ADDR		RemoteAddr;
	BOOLEAN			CancelTickle, AlreadyCleaning, fConnActive;
    ATALK_ERROR     error;


	ASSERT(VALID_ASPCO(pAspConn));

	DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_INFO,
			("AtalkAspCleanupConnection: For %lx\n", pAspConn));

	ACQUIRE_SPIN_LOCK(&pAspConn->aspco_Lock, &OldIrql);
	CancelTickle = ((pAspConn->aspco_Flags & ASPCO_TICKLING) != 0);

    AlreadyCleaning = (pAspConn->aspco_Flags & ASPCO_CLEANING_UP) ? TRUE : FALSE;

	if (AlreadyCleaning)
    {
		pAspConn->aspco_Flags &= ~ASPCO_TICKLING;
    }
    fConnActive = (pAspConn->aspco_Flags & ASPCO_ACTIVE) ? TRUE : FALSE;

    pAspConn->aspco_Flags &= ~ASPCO_ACTIVE;

	pAspConn->aspco_Flags |= ASPCO_CLEANING_UP;
	RELEASE_SPIN_LOCK(&pAspConn->aspco_Lock, OldIrql);

	if (AlreadyCleaning)
		return ATALK_NO_ERROR;

	pAspAddr = pAspConn->aspco_pAspAddr;
	ASSERT(VALID_ASPAO(pAspAddr));

	// Send a session close request, if this is an active connection
	if (fConnActive)
	{
		UserBytes[ASP_CMD_OFF] = ASP_CLOSE_SESSION;
		UserBytes[ASP_SESSIONID_OFF] = pAspConn->aspco_SessionId;
		PUTSHORT2SHORT(UserBytes + ASP_ATTN_WORD_OFF, 0);
		DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_INFO,
				("AtalkAspCleanupConnection: Sending close req for %lx\n",
				pAspConn));
		Status = AtalkAtpPostReq(pAspAddr->aspao_pSssAtpAddr,
								 &pAspConn->aspco_WssRemoteAddr,
								 &XactId,
								 ATP_REQ_REMOTE,		// Close session request is ALO
								 NULL,
								 0,
								 UserBytes,
								 NULL,
								 0,
								 ATP_RETRIES_FOR_ASP,
								 ATP_MAX_INTERVAL_FOR_ASP,
								 THIRTY_SEC_TIMER,
								 NULL,
								 NULL);

		if (!ATALK_SUCCESS(Status))
		{
			DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_ERR,
					("AtalkAspCleanupConn: AtalkAtpPostReq %ld\n", Status));
		}
	}

	// Cancel tickle packets
	if (CancelTickle)
	{
		DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_INFO,
				("AtalkAspCleanupConnection: Cancel tickle for %lx\n", pAspConn));
		Status = AtalkAtpCancelReq(pAspAddr->aspao_pSlsAtpAddr,
								   pAspConn->aspco_TickleXactId,
								   &pAspConn->aspco_WssRemoteAddr);
		if (!ATALK_SUCCESS(Status))
		{
			DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_ERR,
					("AtalkAspCleanupConn: AtalkAtpCancelReq %ld\n", Status));
		}
	}

	do
	{
		BOOLEAN		CancelReply = FALSE;

		ACQUIRE_SPIN_LOCK(&pAspConn->aspco_Lock, &OldIrql);
		for (pAspReq = pAspConn->aspco_pActiveReqs;
			 pAspReq != NULL;
			 pAspReq = pAspReq->asprq_Next)
		{
			ASSERT (VALID_ASPRQ(pAspReq));

			DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_INFO,
					("AtalkAspCleanupConnection: Found req %lx (%lx) for %lx\n",
					pAspReq, pAspReq->asprq_Flags, pAspConn));

			CancelReply = FALSE;

			if ((pAspReq->asprq_Flags & (ASPRQ_WRTCONT | ASPRQ_WRTCONT_CANCELLED)) == ASPRQ_WRTCONT)
			{
				pAspReq->asprq_Flags |= ASPRQ_WRTCONT_CANCELLED;
				RemoteAddr = pAspConn->aspco_WssRemoteAddr;
				break;
			}
			if ((pAspReq->asprq_Flags & (ASPRQ_REPLY | ASPRQ_REPLY_CANCELLED)) == ASPRQ_REPLY)
			{
				CancelReply = TRUE;
				pAspReq->asprq_Flags |= ASPRQ_REPLY_CANCELLED;
				break;
			}
		}

		RELEASE_SPIN_LOCK(&pAspConn->aspco_Lock, OldIrql);

		if (pAspReq != NULL)
		{
			if (CancelReply)
			{
				DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_INFO,
						("AtalkAspCleanupConnection: Cancel reply for %lx, flag=%lx\n",
						pAspReq,pAspReq->asprq_Flags));

				error = AtalkAtpCancelResp(pAspReq->asprq_pAtpResp);

                if (!ATALK_SUCCESS(error))
                {
				    DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_ERR,
						("AtalkAspCleanupConnection: AtalkAtpCancelResp failed %lx\n",error));
                }
			}
            else
			{
				DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_INFO,
						("AtalkAspCleanupConnection: Cancel wrtcont for %lx, flag=%lx\n",
						pAspReq,pAspReq->asprq_Flags));

				error = AtalkAtpCancelReq(pAspConn->aspco_pAspAddr->aspao_pSssAtpAddr,
								  pAspReq->asprq_WCXactId,
								  &RemoteAddr);

                if (!ATALK_SUCCESS(error))
                {
				    DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_ERR,
						("AtalkAspCleanupConnection: AtalkAtpCancelReq failed %lx\n",error));
                }
			}
		}
		else
        {
            break;
        }
	} while (TRUE);

	return ATALK_NO_ERROR;
}

NTSTATUS FASTCALL
AtalkAspWriteContinue(
	IN	PREQUEST	  pRequest
    )
/*++

Routine Description:

	The response buffer is in the request itself.

Arguments:


Return Value:


--*/
{

	PASP_REQUEST	pAspReq;


	DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_WARN,
		("AtalkAspWriteContinue: Entered with pRequest %lx\n", pRequest));

	pAspReq = CONTAINING_RECORD(pRequest, ASP_REQUEST, asprq_Request);
	ASSERT (VALID_ASPRQ(pAspReq));

    if (pRequest->rq_WriteMdl != NULL)
    {
        atalkAspPostWriteContinue(pAspReq);
        return(STATUS_SUCCESS);
    }
    else
    {
	    DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_ERR,
		    ("AtalkAspWriteContinue: buffer alloc failed, completing write with error\n"));

        atalkAspWriteContinueResp(ATALK_RESR_MEM, pAspReq, NULL, NULL, 0, NULL);
    }


    return(STATUS_SUCCESS);
}


NTSTATUS FASTCALL
AtalkAspReply(
	IN	PREQUEST				pRequest,	// Pointer to request
	IN	PBYTE					pResultCode	// Pointer to the 4-byte result
	)
/*++

Routine Description:

	The response buffer is in the request itself.

Arguments:


Return Value:


--*/
{
	PASP_REQUEST	pAspReq, *ppAspReq;
	PASP_CONNOBJ	pAspConn;
	PASP_ADDROBJ	pAspAddr;
	ATALK_ERROR		error;
	KIRQL			OldIrql;
	USHORT			ReplySize;

	pAspReq = CONTAINING_RECORD(pRequest, ASP_REQUEST, asprq_Request);
	ASSERT (VALID_ASPRQ(pAspReq));

	pAspConn = pAspReq->asprq_pAspConn;
	ASSERT(VALID_ASPCO(pAspConn));

	pAspAddr = pAspConn->aspco_pAspAddr;
	ASSERT(VALID_ASPAO(pAspAddr));

	DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_INFO,
			("AtalkAspReply: Entered for session %lx\n", pAspConn));
	
	ASSERT ((pAspReq->asprq_Flags & (ASPRQ_WRTCONT | ASPRQ_REPLY)) == 0);

	do
	{
		// Find and de-queue this request from the list
		ACQUIRE_SPIN_LOCK(&pAspConn->aspco_Lock, &OldIrql);
		
		for (ppAspReq = &pAspConn->aspco_pActiveReqs;
			 *ppAspReq != NULL;
			 ppAspReq = &(*ppAspReq)->asprq_Next)
		{
			if (pAspReq == *ppAspReq)
			{
				*ppAspReq = pAspReq->asprq_Next;
				pAspConn->aspco_cReqsInProcess --;
				pAspReq->asprq_Flags |= ASPRQ_REPLY;
				break;
			}
		}
		
		ASSERT(*ppAspReq == pAspReq->asprq_Next);
		
		if (pAspConn->aspco_Flags & (ASPCO_CLEANING_UP |
									 ASPCO_CLOSING |
									 ASPCO_LOCAL_CLOSE |
									 ASPCO_REMOTE_CLOSE))
		{
			DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_ERR,
					("AtalkAspReply: Session Closing - session %x\n", pAspConn->aspco_SessionId));
			RELEASE_SPIN_LOCK(&pAspConn->aspco_Lock, OldIrql);
			pAspReq->asprq_Flags &= ~ASPRQ_REPLY;
			pAspReq->asprq_Flags |= ASPRQ_REPLY_ABORTED;
			error = ATALK_LOCAL_CLOSE;
			break;
		}
	
		RELEASE_SPIN_LOCK(&pAspConn->aspco_Lock, OldIrql);
	
		ReplySize = (USHORT)AtalkSizeMdlChain(pAspReq->asprq_Request.rq_ReplyMdl);
	
		DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_INFO,
				("AtalkAspReply: Posting AtalkAtpPostResp for request %lx\n", pAspReq));
	
		error = AtalkAtpPostResp(pAspReq->asprq_pAtpResp,
								 &pAspReq->asprq_RemoteAddr,
								 pAspReq->asprq_Request.rq_ReplyMdl,
								 ReplySize,
								 pResultCode,
								 atalkAspReplyRelease,
								 pAspReq);

		if (!ATALK_SUCCESS(error))
		{
			DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_ERR,
					("AtalkAspReply: AtalkAtpPostResp %ld\n", error));
		}
	} while (FALSE);

	if (!ATALK_SUCCESS(error))
	{
        if (error != ATALK_ATP_RESP_TOOMANY)
        {
		    atalkAspReplyRelease(error, pAspReq);
        }
	}

	DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_INFO,
			("AtalkAspReply: Completing request %lx, Status %ld\n",
			pAspReq, error));

	return STATUS_PENDING;
}




LOCAL ATALK_ERROR FASTCALL
atalkAspPostWriteContinue(
	IN	PASP_REQUEST			pAspReq
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	ATALK_ERROR		error;
	PASP_CONNOBJ	pAspConn;
	PAMDL			pAMdl = NULL;
	BYTE			UserBytes[ATP_USERBYTES_SIZE];
	USHORT			RespSize;

	ASSERT (VALID_ASPRQ(pAspReq));

	pAspConn = pAspReq->asprq_pAspConn;
	ASSERT(VALID_ASPCO(pAspConn));

	DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_INFO,
			("atalkAspPostWriteContinue: Entered for session %lx\n", pAspConn));

	RespSize = (USHORT)AtalkSizeMdlChain(pAspReq->asprq_Request.rq_WriteMdl);
	ASSERT (RespSize <= ATP_MAX_TOTAL_RESPONSE_SIZE);

	if (RespSize > ATP_MAX_TOTAL_RESPONSE_SIZE)
		RespSize = ATP_MAX_TOTAL_RESPONSE_SIZE;

	ASSERT (!(pAspReq->asprq_Flags & (ASPRQ_WRTCONT | ASPRQ_WRTCONT_CANCELLED)));

	pAspReq->asprq_Flags |= ASPRQ_WRTCONT;

	do
	{
		// We need to build an AMdl for two bytes of response which
		// indicates how much data we are expecting !!!
		if ((pAMdl = AtalkAllocAMdl(pAspReq->asprq_WrtContRespBuf,
									ASP_WRITE_DATA_SIZE)) == NULL)
		{
			error = ATALK_RESR_MEM;
			DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_ERR,
					("AtalkAspWriteContinue: AtalkAllocMdl failed for 2 bytes !!\n"));
		}

		else
		{
			PBYTE	pWrtData;

			DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_INFO,
					("AtalkAspWriteContinue: Posting AtalkAtpPostReq for request %lx\n",
					pAspReq));

			pWrtData = AtalkGetAddressFromMdlSafe(pAMdl, NormalPagePriority);
			if (pWrtData == NULL)
			{
				if (pAMdl != NULL)
                {
					AtalkFreeAMdl(pAMdl);
                }
				error = ATALK_RESR_MEM;
                break;
			}

			UserBytes[ASP_CMD_OFF] = ASP_WRITE_DATA;
			UserBytes[ASP_SESSIONID_OFF] = pAspConn->aspco_SessionId;
			PUTSHORT2SHORT(UserBytes+ASP_SEQUENCE_NUM_OFF, pAspReq->asprq_SeqNum);
			PUTSHORT2SHORT(pWrtData, RespSize);

			// Snapshot the current tick count. We use this to adjust the retry times on
			// write continue.
			pAspConn->aspco_RT.rt_New = AtalkGetCurrentTick();
			error = AtalkAtpPostReq(pAspConn->aspco_pAspAddr->aspao_pSssAtpAddr,
									&pAspConn->aspco_WssRemoteAddr,
									&pAspReq->asprq_WCXactId,
									ATP_REQ_EXACTLY_ONCE | ATP_REQ_REMOTE,
									pAMdl,
									ASP_WRITE_DATA_SIZE,
									UserBytes,
									pAspReq->asprq_Request.rq_WriteMdl,
									RespSize,
									ATP_INFINITE_RETRIES,
									pAspConn->aspco_RT.rt_Base,
									THIRTY_SEC_TIMER,
									atalkAspWriteContinueResp,
									pAspReq);
			if (!ATALK_SUCCESS(error))
			{
				DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_ERR,
						("AtalkAspWriteContinue: AtalkAtpPostReq %ld\n", error));
			}
		}

		if (!ATALK_SUCCESS(error))
		{
			if (pAMdl != NULL)
				AtalkFreeAMdl(pAMdl);
		}
	} while (FALSE);

	return error;
}




NTSTATUS
AtalkAspSendAttention(
	IN	PASP_CONNOBJ			pAspConn,
	IN	USHORT					AttentionWord,
	IN	PVOID					pContext
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	ATALK_ERROR		error;
	NTSTATUS		Status = STATUS_SUCCESS;
	KIRQL			OldIrql;
	PAMDL			pAMdl = NULL;
	BYTE			UserBytes[ATP_USERBYTES_SIZE];
	USHORT			XactId, RespSize = 16;		// Some small number (see comment below)


	ASSERT(VALID_ASPCO(pAspConn));

	DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_INFO,
			("AtalkAspSendAttention: Entered for session %lx\n", pAspConn));

	// Reference by src addr here instead of by pointer since the former will
	// fail when the session is in one of the stages of death whereas the
	// latter will not. Also this assumes that it is called at dispatch so raise irql.
	KeRaiseIrql(DISPATCH_LEVEL, &OldIrql);
	pAspConn = atalkAspReferenceConnBySrcAddr(pAspConn->aspco_pAspAddr,
											  &pAspConn->aspco_WssRemoteAddr,
											  pAspConn->aspco_SessionId);
	KeLowerIrql(OldIrql);

	if (pAspConn == NULL)
		return STATUS_REQUEST_NOT_ACCEPTED;

	UserBytes[ASP_CMD_OFF] = ASP_ATTENTION;
	UserBytes[ASP_SESSIONID_OFF] = pAspConn->aspco_SessionId;
	PUTSHORT2SHORT(UserBytes+ASP_ATTN_WORD_OFF, AttentionWord);

	DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_INFO,
			("AtalkAspSendAttention: Posting AtalkAtpPostReq for Conn %lx\n", pAspConn));

	// We need to build an AMdl for a dummy buffer to hold the response.
	// There is no real response but some clients fry their
	// machines if we don't !!! If we cannot allocate the mdl we we go
	// ahead anyway.
	if ((pAMdl = AtalkAllocAMdl(NULL, RespSize)) == NULL)
	{
		DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_ERR,
				("AtalkAspSendAttention: AtalkAllocMdl failed for dummy buffer !!\n"));
		RespSize = 0;
	}
	pAspConn->aspco_AttentionContext = pContext;

	error = AtalkAtpPostReq(pAspConn->aspco_pAspAddr->aspao_pSssAtpAddr,
							&pAspConn->aspco_WssRemoteAddr,
							&XactId,
							ATP_REQ_REMOTE,		// SendAttention is ALO
							NULL,
							0,
							UserBytes,
							pAMdl,
							RespSize,
							ATP_RETRIES_FOR_ASP,
							ATP_MAX_INTERVAL_FOR_ASP,
							THIRTY_SEC_TIMER,
							atalkAspSendAttentionResp,
							pAspConn);
	if (!ATALK_SUCCESS(error))
	{
		DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_ERR,
				("AtalkAspSendAttention: AtalkAtpPostReq %ld\n", Status));
		Status = AtalkErrorToNtStatus(error);
		atalkAspSendAttentionResp(error,
								  pAspConn,
								  NULL,
								  pAMdl,
								  RespSize,
								  UserBytes);
	}

	return Status;
}




PASP_ADDROBJ FASTCALL
AtalkAspReferenceAddr(
	IN	PASP_ADDROBJ		pAspAddr
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	KIRQL			OldIrql;
	PASP_ADDROBJ	pRefAddr;

	ASSERT(VALID_ASPAO(pAspAddr));

	DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_INFO,
			("AtalkAspReferenceAddr: Addr %lx, PreCount %ld\n",
			pAspAddr, pAspAddr->aspao_RefCount));

	pRefAddr = pAspAddr;
	ACQUIRE_SPIN_LOCK(&pAspAddr->aspao_Lock, &OldIrql);

	ASSERT(pAspAddr->aspao_RefCount > 1);

	if (pAspAddr->aspao_Flags & ASPAO_CLOSING)
	{
		DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_ERR,
				("AtalkAspReferenceAddr: Referencing closing object %lx!!\n",
				pAspAddr));
		pRefAddr = NULL;
	}
	else pAspAddr->aspao_RefCount ++;

	RELEASE_SPIN_LOCK(&pAspAddr->aspao_Lock, OldIrql);

	return pRefAddr;
}




VOID FASTCALL
AtalkAspDereferenceAddr(
	IN	PASP_ADDROBJ		pAspAddr
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	KIRQL			OldIrql;
	BOOLEAN			Cleanup;

	ASSERT(VALID_ASPAO(pAspAddr));

	ASSERT (pAspAddr->aspao_RefCount > 0);

	DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_INFO,
			("AtalkAspDereferenceAddr: Addr %lx, PreCount %ld\n",
			pAspAddr, pAspAddr->aspao_RefCount));

	ACQUIRE_SPIN_LOCK(&pAspAddr->aspao_Lock, &OldIrql);

	pAspAddr->aspao_RefCount --;

	Cleanup = FALSE;
	if (pAspAddr->aspao_RefCount == 0)
	{
		ASSERT (pAspAddr->aspao_Flags & ASPAO_CLOSING);
		Cleanup = TRUE;
	}

	RELEASE_SPIN_LOCK(&pAspAddr->aspao_Lock, OldIrql);

	// Check if this address object is history. Do all the processing needed to make this go
	// away. When all is done, clear the event to signal close is complete
	if (Cleanup)
	{
		// At this point we are sure that no active sessions exist on this
		// address.
		DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_WARN,
				("AtalkAspDereferenceAddr: Cleaning up addr %lx\n", pAspAddr));

		DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_WARN,
				("AtalkAspDereferenceAddr: Indicating close for %lx\n", pAspAddr));

		ASSERT(KeGetCurrentIrql() == LOW_LEVEL);

		// Call the completion routine to indicate close is successfull
		if (pAspAddr->aspao_CloseCompletion != NULL)
			(*pAspAddr->aspao_CloseCompletion)(ATALK_NO_ERROR,
											   pAspAddr->aspao_CloseContext);
		// Finally free the memory
		AtalkFreeMemory(pAspAddr);

		AtalkUnlockAspIfNecessary();
	}
}



LOCAL PASP_CONNOBJ
atalkAspReferenceConnBySrcAddr(
	IN	PASP_ADDROBJ	pAspAddr,
	IN	PATALK_ADDR		pSrcAddr,
	IN	BYTE			SessionId
	)
/*++

Routine Description:

 	ASP has the concept of 8-bit session ids which uniquely identifies a
 	session on a listener. This effectively restricts the number of sessions
 	to 255 (0 is invalid). To eliminate the restriction, the following
 	strategy is used.
 	a, Atp is modified to isolate the transaction ids on a per addr basis
 	   i.e. it monotonically increases for each <net,node,socket> combination.
 	b, We create session ids on a per <net,node> basis.

 	Given the following observed facts:
 	1, That macintoshes use the sockets starting from the top of the range.
 	2, Most network addresses have the same high byte - macintoshes tend
 	   to start from the bottom of the range.
 	3, We allocate session ids starting from 1 and most (all) clients will
 	   not have more than one session with us.

 	It does not make any sense to take either the socket, session id or the
 	high byte of the network number into account. That leaves only the low
 	byte of the network, and node id - a nice 16-bit number to hash.

Arguments:


Return Value:


--*/
{
	PASP_CONNOBJ	pAspConn, pRefConn = NULL;
	int				index;

	ASSERT(VALID_ASPAO(pAspAddr));

	DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_INFO,
			("AtalkAspReferenceConnBySrcAddr: Addr %lx, Source %x.%x SessionId %d\n",
			pAspAddr, pSrcAddr->ata_Network, pSrcAddr->ata_Node, SessionId));

	index = HASH_SRCADDR(pSrcAddr);
	ACQUIRE_SPIN_LOCK_DPC(&pAspAddr->aspao_Lock);

	for (pAspConn = pAspAddr->aspao_pSessions[index];
		 pAspConn != NULL;
		 pAspConn = pAspConn->aspco_NextOverflow)
	{
		if ((pSrcAddr->ata_Network == pAspConn->aspco_WssRemoteAddr.ata_Network) &&
			(pSrcAddr->ata_Node == pAspConn->aspco_WssRemoteAddr.ata_Node) &&
			(pAspConn->aspco_SessionId == SessionId))
		{
			ACQUIRE_SPIN_LOCK_DPC(&pAspConn->aspco_Lock);
			if ((pAspConn->aspco_Flags & (ASPCO_CLOSING |
										  ASPCO_CLEANING_UP |
										  ASPCO_LOCAL_CLOSE |
										  ASPCO_REMOTE_CLOSE)) == 0)
			{
				ASSERT(pAspConn->aspco_RefCount > 0);
				pAspConn->aspco_RefCount ++;

				pRefConn = pAspConn;
			}
			RELEASE_SPIN_LOCK_DPC(&pAspConn->aspco_Lock);
			break;
		}
	}

	RELEASE_SPIN_LOCK_DPC(&pAspAddr->aspao_Lock);

	return pRefConn;
}




VOID FASTCALL
AtalkAspDereferenceConn(
	IN	PASP_CONNOBJ		pAspConn
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PASP_ADDROBJ		pAspAddr = pAspConn->aspco_pAspAddr;
	KIRQL				OldIrql;
	PASP_REQUEST		pAspReq;
	BOOLEAN				Cleanup = FALSE;

	ASSERT(VALID_ASPCO(pAspConn));

	ASSERT (pAspConn->aspco_RefCount > 0);

	DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_INFO,
			("AtalkAspDereferenceConn: Conn %lx, PreCount %ld\n",
			pAspConn, pAspConn->aspco_RefCount));

	ACQUIRE_SPIN_LOCK(&pAspConn->aspco_Lock, &OldIrql);

	pAspConn->aspco_RefCount --;

	if (pAspConn->aspco_RefCount == 0)
	{
		Cleanup = TRUE;
	}

	RELEASE_SPIN_LOCK(&pAspConn->aspco_Lock, OldIrql);

	if (!Cleanup)
	{
		return;
	}

	DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_WARN,
			("AtalkAspDereferenceConn: Last for %lx\n", pAspConn));

	// The connection is all but dead. Perform the last rites. If its an
	// active session that we're about to shut down, send a close notification
	// to the other side. If it is a remote close, we've already responded to it.

	DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_WARN,
			("AtalkAspDereferenceConn: Cleaning up Conn %lx\n", pAspConn));

	ASSERT(VALID_ASPAO(pAspAddr));

	// The connection is in one of the following states:
	// a, Closed remotely - idle
	// b, Active
	//
	// In either case it is in the hash bucket so unlink it
	{
		PASP_CONNOBJ *	ppAspConn;
		int				index;

		// The connection was active. This is linked into two different
		// lists. Unlink from the hash table here and from the global
		// list later.
		ASSERT(pAspConn->aspco_pActiveReqs == NULL);
		index = HASH_SRCADDR(&pAspConn->aspco_WssRemoteAddr);

		ACQUIRE_SPIN_LOCK(&pAspAddr->aspao_Lock, &OldIrql);
		for (ppAspConn = &pAspAddr->aspao_pSessions[index];
			 *ppAspConn != NULL;
			 ppAspConn = &(*ppAspConn)->aspco_NextOverflow)
		{
			if (pAspConn == *ppAspConn)
			{
				*ppAspConn = pAspConn->aspco_NextOverflow;
				break;
			}
		}
		RELEASE_SPIN_LOCK(&pAspAddr->aspao_Lock, OldIrql);

		ASSERT (*ppAspConn == pAspConn->aspco_NextOverflow);
	}

	ACQUIRE_SPIN_LOCK(&atalkAspLock, &OldIrql);

    ACQUIRE_SPIN_LOCK_DPC(&pAspConn->aspco_Lock);

	AtalkUnlinkDouble(pAspConn,
					  aspco_NextSession,
					  aspco_PrevSession)


	// Free any requests on the free list
	while ((pAspReq = pAspConn->aspco_pFreeReqs) != NULL)
	{
		pAspConn->aspco_pFreeReqs = pAspReq->asprq_Next;
		AtalkBPFreeBlock(pAspReq);
	}

    RELEASE_SPIN_LOCK_DPC(&pAspConn->aspco_Lock);

	RELEASE_SPIN_LOCK(&atalkAspLock, OldIrql);

	DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_WARN,
			("AtalkAspDereferenceConn: Indicating close for Conn %lx\n", pAspConn));

	// Call the completion routine to indicate close is successful.
	(*pAspAddr->aspao_ClientEntries.clt_CloseCompletion)(STATUS_SUCCESS,
														 pAspConn->aspco_ConnContext);

	// Now Dereference the address object, before we are history
	AtalkAspDereferenceAddr(pAspAddr);

	// Finally free the memory.
	AtalkFreeMemory(pAspConn);
}




LOCAL VOID
atalkAspSlsXHandler(
	IN	ATALK_ERROR			ErrorCode,
	IN	PASP_ADDROBJ		pAspAddr,		// Listener (our context)
	IN	PATP_RESP			pAtpResp,		// Atp Response context
	IN	PATALK_ADDR			pSrcAddr,		// Address of requestor
	IN	USHORT				PktLen,
	IN	PBYTE				pPkt,
	IN	PBYTE				pUserBytes
	)
/*++

Routine Description:

 	Handler for incoming requests on the Sls. It handles session opens, tickles
 	and get status on the session.

Arguments:


Return Value:


--*/
{
	PASP_CONNOBJ		pAspConn;
	ATALK_ERROR			Status;
	PASP_POSTSTAT_CTX	pStsCtx;
	int					index;
	USHORT				StsBufSize;
	BYTE				AspCmd, SessionId, StartId;
    BOOLEAN             fAddrRefed=FALSE;


	if (!ATALK_SUCCESS(ErrorCode))
	{
		DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_WARN,
				("atalkAspSlsXHandler: Error %ld\n", ErrorCode));

		// Take away the reference on the Sls now that the atp address is closing
		if (ErrorCode == ATALK_ATP_CLOSING)
			AtalkAspDereferenceAddr(pAspAddr);
		return;
	}

	DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_INFO,
			("atalkAspSlsXHandler: Entered for Function %x from %x.%x\n",
			pUserBytes[ASP_CMD_OFF], pSrcAddr->ata_Network, pSrcAddr->ata_Node));

	switch (AspCmd = pUserBytes[ASP_CMD_OFF])
	{
	  case ASP_OPEN_SESSION:
		// Is the version number ok ?
		if ((pUserBytes[ASP_VERSION_OFF] != ASP_VERSION[0]) ||
			(pUserBytes[ASP_VERSION_OFF+1] != ASP_VERSION[1]))
		{
			atalkAspReturnResp( pAtpResp,
								pSrcAddr,
								0,					// SSS
								0,					// SessionId
								ASP_BAD_VERSION);	// ErrorCode
			break;
		}

		// Create a connection object corres. to this listen and then notify
		// the client that it needs to handle a new session
		// Allocate memory for a connection object
		if ((pAspConn = AtalkAllocZeroedMemory(sizeof(ASP_CONNOBJ))) != NULL)
		{
#if	DBG
			pAspConn->aspco_Signature = ASPCO_SIGNATURE;
#endif
			INITIALIZE_SPIN_LOCK(&pAspConn->aspco_Lock);
			pAspConn->aspco_RefCount = 1;				// Creation reference
			pAspConn->aspco_pAspAddr = pAspAddr;		// Owning address object
			AtalkInitializeRT(&pAspConn->aspco_RT,
							  ATP_INITIAL_INTERVAL_FOR_ASP,
							  ATP_MIN_INTERVAL_FOR_ASP,
							  ATP_MAX_INTERVAL_FOR_ASP);
		}

		ACQUIRE_SPIN_LOCK_DPC(&pAspAddr->aspao_Lock);

		if (pAspConn != NULL)
		{
			PASP_CONNOBJ	pTmp;

			// Find a session id that we can use for this session. We use
			// the next assignable id, if that is not in use. Otherwise we
			// use the next id not in use by that session. In most cases
			// we have only one session from any client.
			index = HASH_SRCADDR(pSrcAddr);

			// If we do not find any, we use this
			SessionId = StartId = pAspAddr->aspao_NextSessionId++;
			ASSERT (SessionId != 0);
			if (pAspAddr->aspao_NextSessionId == 0)
				pAspAddr->aspao_NextSessionId = 1;

			for (pTmp = pAspAddr->aspao_pSessions[index];
				 pTmp != NULL;
				 NOTHING)
			{
				if ((pTmp->aspco_WssRemoteAddr.ata_Node == pSrcAddr->ata_Node) &&
					(pTmp->aspco_WssRemoteAddr.ata_Network == pSrcAddr->ata_Network))
				{
					if (pTmp->aspco_SessionId == SessionId)
					{
                        // if we have cycled through all, get out!
                        if (SessionId == (StartId - 1))
                        {
                            break;
                        }

						SessionId ++;
                        if (SessionId == 0)
                        {
                            // all sessions are taken: quit here!
                            if (StartId == 1)
                            {
                                break;
                            }
                            SessionId = 1;
                        }
						pTmp = pAspAddr->aspao_pSessions[index];
						continue;
					}
				}
				pTmp = pTmp->aspco_NextOverflow;
			}

			// if there are 255 sessions already from this address, then
			// we can't have any more, sorry !!!
			if (SessionId != (StartId - 1))
			{
				// Link it into the hash table
				pAspAddr->aspao_RefCount ++;
                fAddrRefed = TRUE;

				pAspConn->aspco_SessionId = SessionId;
				pAspConn->aspco_cReqsInProcess = 0;
				pAspConn->aspco_WssRemoteAddr.ata_Address = pSrcAddr->ata_Address;
				pAspConn->aspco_WssRemoteAddr.ata_Socket = pUserBytes[ASP_WSS_OFF];
				pAspConn->aspco_LastContactTime = AtalkGetCurrentTick();
				pAspConn->aspco_NextExpectedSeqNum = 0;
				pAspConn->aspco_Flags |= (ASPCO_ACTIVE | ASPCO_TICKLING);

				// The session should be linked *after* all of the above
				// are initialized
				pAspConn->aspco_NextOverflow = pAspAddr->aspao_pSessions[index];
				pAspAddr->aspao_pSessions[index] = pAspConn;
#ifdef	PROFILING
				INTERLOCKED_INCREMENT_LONG_DPC(&AtalkStatistics.stat_CurAspSessions,
											   &AtalkStatsLock.SpinLock);

				INTERLOCKED_INCREMENT_LONG_DPC(&AtalkStatistics.stat_TotalAspSessions,
											   &AtalkStatsLock.SpinLock);
#endif
			}
			else
			{
				AtalkFreeMemory(pAspConn);
				pAspConn = NULL;
			}
		}

		RELEASE_SPIN_LOCK_DPC(&pAspAddr->aspao_Lock);

		if (pAspConn != NULL)
		{
			BYTE	Socket;
			BYTE	UserBytes[ATP_USERBYTES_SIZE];

			DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_INFO,
					("atalkAspSlsXHandler: Opening session from %d.%d for Session %d\n",
					pSrcAddr->ata_Network, pSrcAddr->ata_Node, SessionId));


			// Call the open completion routine and get a context. This is needed
			// before we do anything else. Once we send out an open success it'll
			// be too late.
            // FALSE says this is not over TCP/IP
			pAspConn->aspco_ConnContext =
				(*pAspAddr->aspao_ClientEntries.clt_SessionNotify)(pAspConn,FALSE);

			if (pAspConn->aspco_ConnContext != NULL)
			{
				// Now link the session into the global list
				ACQUIRE_SPIN_LOCK_DPC(&atalkAspLock);
				AtalkLinkDoubleAtHead(atalkAspConnMaint[SessionId & (NUM_ASP_CONN_LISTS-1)].ascm_ConnList,
									  pAspConn,
									  aspco_NextSession,
									  aspco_PrevSession)
				RELEASE_SPIN_LOCK_DPC(&atalkAspLock);
	
				// Send an open session response - XO
				Socket = pAspAddr->aspao_pSssAtpAddr->atpao_DdpAddr->ddpao_Addr.ata_Socket;
				atalkAspReturnResp( pAtpResp,
									pSrcAddr,
									Socket,
									pAspConn->aspco_SessionId,
									0);				// Success
	
				// Send a tickle out every ASP_TICKLE_INTERVAL seconds
				UserBytes[ASP_CMD_OFF] = ASP_TICKLE;
				UserBytes[ASP_SESSIONID_OFF] = pAspConn->aspco_SessionId;
				PUTSHORT2SHORT(UserBytes + ASP_ERRORCODE_OFF, 0);
				Status = AtalkAtpPostReq(pAspAddr->aspao_pSlsAtpAddr,
										&pAspConn->aspco_WssRemoteAddr,
										&pAspConn->aspco_TickleXactId,
										ATP_REQ_REMOTE,		// Tickle packets are ALO
										NULL,
										0,
										UserBytes,
										NULL,
										0,
										ATP_INFINITE_RETRIES,
										ASP_TICKLE_INTERVAL,
										THIRTY_SEC_TIMER,
										NULL,
										NULL);
				if (!ATALK_SUCCESS(Status))
				{
					pAspConn->aspco_Flags &= ~ASPCO_TICKLING;
					DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_ERR,
							("atalkAspSlsXHandler: AtalkAtpPostReq %ld\n", Status));
				}
			}
			else
			{
				PASP_CONNOBJ *	ppAspConn;

				// Unlink it from the hash table
				ACQUIRE_SPIN_LOCK_DPC(&pAspAddr->aspao_Lock);

				for (ppAspConn = &pAspAddr->aspao_pSessions[index];
					 *ppAspConn != NULL;
					 ppAspConn = &(*ppAspConn)->aspco_NextOverflow)
				{
					if (*ppAspConn == pAspConn)
					{
						*ppAspConn = pAspConn->aspco_NextOverflow;
						break;
					}
				}

				ASSERT (*ppAspConn == pAspConn->aspco_NextOverflow);

				RELEASE_SPIN_LOCK_DPC(&pAspAddr->aspao_Lock);

				AtalkFreeMemory(pAspConn);
				pAspConn = NULL;
#ifdef	PROFILING
				INTERLOCKED_DECREMENT_LONG_DPC(&AtalkStatistics.stat_CurAspSessions,
											   &AtalkStatsLock.SpinLock);

				INTERLOCKED_DECREMENT_LONG_DPC(&AtalkStatistics.stat_TotalAspSessions,
											   &AtalkStatsLock.SpinLock);
#endif
			}
		}

		// If we are set to disable listens or could not allocate memory, drop it
		if (pAspConn == NULL)
		{
			DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_ERR,
					("atalkAspSlsXHandler: No conn objects available\n"));

			atalkAspReturnResp( pAtpResp,
								pSrcAddr,
								0,
								0,
								ASP_SERVER_BUSY);

            // remove that refcount if we put it in hoping afp would accept the request
            if (fAddrRefed)
            {
                AtalkAspDereferenceAddr(pAspAddr);
            }
		}
		break;

	  case ASP_GET_STATUS:
		DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_INFO,
				("atalkAspSssXHandler: Received GetStat from %x.%x\n",
				pSrcAddr->ata_Network, pSrcAddr->ata_Node));
		// Create an Mdl to describe the status buffer and post a response
		// to the GetStatus request
		StsBufSize = 0;
        pStsCtx = NULL;
		ACQUIRE_SPIN_LOCK_DPC(&pAspAddr->aspao_Lock);
		if (pAspAddr->aspao_pStatusBuf != NULL)
		{
			pStsCtx = (PASP_POSTSTAT_CTX)AtalkAllocMemory(sizeof(ASP_POSTSTAT_CTX) +
														  pAspAddr->aspao_StsBufSize);
			if (pStsCtx != NULL)
			{
				pStsCtx->aps_pAMdl = AtalkAllocAMdl((PBYTE)pStsCtx + sizeof(ASP_POSTSTAT_CTX),
													pAspAddr->aspao_StsBufSize);
				if (pStsCtx->aps_pAMdl != NULL)
				{
					pStsCtx->aps_pAtpResp = pAtpResp;
					StsBufSize = pAspAddr->aspao_StsBufSize;
					RtlCopyMemory((PBYTE)pStsCtx + sizeof(ASP_POSTSTAT_CTX),
								  pAspAddr->aspao_pStatusBuf,
								  StsBufSize);
				}
				else
                {
                    AtalkFreeMemory(pStsCtx);
                    pStsCtx = NULL;
                    StsBufSize = 0;
                }
			}
		}
		RELEASE_SPIN_LOCK_DPC(&pAspAddr->aspao_Lock);

		Status = AtalkAtpPostResp(pAtpResp,
								  pSrcAddr,
								  (pStsCtx != NULL) ?
									pStsCtx->aps_pAMdl : NULL,
								  StsBufSize,
								  NULL,
								  atalkAspRespComplete,
								  pStsCtx);
		if (!ATALK_SUCCESS(Status))
		{
			DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_ERR,
					("atalkAspSlsXHandler: AtalkAtpPostResp %ld\n", Status));
			atalkAspRespComplete(Status, pStsCtx);
		}
		break;

	  case ASP_TICKLE:
		SessionId = pUserBytes[ASP_SESSIONID_OFF];
		DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_INFO,
				("atalkAspSssXHandler: Received tickle from %x.%x Session %d\n",
				pSrcAddr->ata_Network, pSrcAddr->ata_Node, SessionId));

		if ((pAspConn = atalkAspReferenceConnBySrcAddr(pAspAddr, pSrcAddr, SessionId)) != NULL)
		{
			ACQUIRE_SPIN_LOCK_DPC(&pAspConn->aspco_Lock);

			pAspConn->aspco_LastContactTime = AtalkGetCurrentTick();
			RELEASE_SPIN_LOCK_DPC(&pAspConn->aspco_Lock);
			AtalkAspDereferenceConn(pAspConn);
		}
		else
		{
			DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_ERR,
					("atalkAspSssXHandler: Conn not found for addr %d.%d Session %d\n",
					pSrcAddr->ata_Network, pSrcAddr->ata_Node, SessionId));
		}
		// Fall through to the default case

	  default:
		// Cancel this response since we never respond to it and we want this to go away
		AtalkAtpCancelResp(pAtpResp);

	  	if (AspCmd != ASP_TICKLE)
		{
			DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_ERR,
					("atalkAspSlsXHandler: Invalid command\n"));
		}
		break;
	}
}




LOCAL VOID
atalkAspSssXHandler(
	IN	ATALK_ERROR			ErrorCode,
	IN	PASP_ADDROBJ		pAspAddr,		// Listener (our context)
	IN	PATP_RESP			pAtpResp,		// Atp Response context
	IN	PATALK_ADDR			pSrcAddr,		// Address of requestor
	IN	USHORT				PktLen,
	IN	PBYTE				pPkt,
	IN	PBYTE				pUserBytes
	)
/*++

Routine Description:

 	Handler for incoming requests on the Sss. It handles incoming requests, close
 	and write continue.

Arguments:


Return Value:


--*/
{
	PASP_CONNOBJ	pAspConn;		// Session which will handle this request
	PASP_REQUEST	pAspReq;		// The request that will be satisfied
	ATALK_ERROR		Status;
    NTSTATUS        retStatus;
	USHORT			SequenceNum;	// From the incoming packet
	BYTE			SessionId;		// -- ditto --
	BYTE			RequestType;	// -- ditto --
	BOOLEAN			CancelResp = FALSE,
	                CancelTickle;
    BOOLEAN         fTellAfp=TRUE;

	do
	{
		if (!ATALK_SUCCESS(ErrorCode))
		{
			DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_WARN,
					("atalkAspSssXHandler: Error %ld\n", ErrorCode));
			// Take away the reference on the Sls now that the atp address is closing
			if (ErrorCode == ATALK_ATP_CLOSING)
				AtalkAspDereferenceAddr(pAspAddr);
			break;
		}
	
		// Get the session id out of the packet and reference the session that this
		// request is targeted to.
		SessionId = pUserBytes[ASP_SESSIONID_OFF];
		RequestType = pUserBytes[ASP_CMD_OFF];
		GETSHORT2SHORT(&SequenceNum, pUserBytes+ASP_SEQUENCE_NUM_OFF);
	
		DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_INFO,
				("atalkAspSssXHandler: Entered for Request %x from %x.%x\n",
				RequestType, pSrcAddr->ata_Network, pSrcAddr->ata_Node));
	
		// The reference for this connection is passed down to the request
		// for the ASP_CMD & ASP_WRITE case.
		pAspConn = atalkAspReferenceConnBySrcAddr(pAspAddr, pSrcAddr, SessionId);
		if (pAspConn == NULL)
		{
			CancelResp = TRUE;
			break;
		}
	
		ASSERT (pAspConn->aspco_pAspAddr == pAspAddr);
	
		ACQUIRE_SPIN_LOCK_DPC(&pAspConn->aspco_Lock);
		pAspConn->aspco_LastContactTime = AtalkGetCurrentTick();
	
		switch (RequestType)
		{
		  case ASP_CMD:
		  case ASP_WRITE:
			DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_INFO,
					("atalkAspSssXHandler: %s\n",
					(RequestType == ASP_CMD) ? "Command" : "Write"));
			// Create a request for this and notify the client to handle this
			// Validate the incoming sequence number. Reject if out of sequence
			if (SequenceNum == pAspConn->aspco_NextExpectedSeqNum)
			{
				// We now have a request to be handled.
				// The reference to the connection above will be passed on
				// to the request. This will get de-referenced when the
				// request is replied to. See if we have a free request to pick up
				// Allocate a request structure if not and link it in the listener object
				if ((pAspReq = pAspConn->aspco_pFreeReqs) != NULL)
					 pAspConn->aspco_pFreeReqs = pAspReq->asprq_Next;
				else pAspReq = AtalkBPAllocBlock(BLKID_ASPREQ);
	
				if (pAspReq != NULL)
				{
					pAspConn->aspco_NextExpectedSeqNum ++;
#if	DBG
					pAspReq->asprq_Signature = ASPRQ_SIGNATURE;
#endif
					pAspReq->asprq_pAtpResp = pAtpResp;
					pAspReq->asprq_pAspConn = pAspConn;
					pAspReq->asprq_ReqType = RequestType;
					pAspReq->asprq_SeqNum = SequenceNum;
					pAspReq->asprq_RemoteAddr = *pSrcAddr;
					pAspReq->asprq_Flags = 0;
					pAspReq->asprq_Request.rq_WriteMdl = NULL;
					pAspReq->asprq_Request.rq_CacheMgrContext = NULL;
					pAspReq->asprq_Request.rq_RequestSize = PktLen;
					pAspReq->asprq_Next = pAspConn->aspco_pActiveReqs;
					pAspConn->aspco_cReqsInProcess ++;
					pAspConn->aspco_pActiveReqs = pAspReq;

		            ASSERT ((pAspConn->aspco_Flags & (ASPCO_CLEANING_UP |
									                 ASPCO_CLOSING |
									                 ASPCO_LOCAL_CLOSE |
									                 ASPCO_REMOTE_CLOSE)) == 0);
				}
			}
			else
			{
				pAspReq = NULL;
				DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_ERR,
						("atalkAspSssXHandler: Sequence mismatch exp %x, act %x\n",
						pAspConn->aspco_NextExpectedSeqNum, SequenceNum));
			}
	
			RELEASE_SPIN_LOCK_DPC(&pAspConn->aspco_Lock);
	
			// If we do not have an request to handle this, cancel the
			// response. Otherwise the client will keep retrying and atp
			// will not tell us since it already has.
			if (pAspReq == NULL)
			{
				DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_ERR,
						("atalkAspSssXHandler: Dropping request for session %d from %d.%d\n",
						SessionId, pSrcAddr->ata_Network, pSrcAddr->ata_Node));

				CancelResp = TRUE;
				AtalkAspDereferenceConn(pAspConn);
				break;
			}
	
			DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_INFO,
					("atalkAspSssXHandler: Indicating Request %lx\n", pAspReq));
	
			if (RequestType == ASP_WRITE)
			{
                if (PktLen > MAX_WRITE_REQ_SIZE)
                {
                    PASP_REQUEST  *ppTmpAspReq;

                    ASSERT(0);
                    ACQUIRE_SPIN_LOCK_DPC(&pAspConn->aspco_Lock);
                    for (ppTmpAspReq = &pAspConn->aspco_pActiveReqs;
                         *ppTmpAspReq != NULL; ppTmpAspReq = &(*ppTmpAspReq)->asprq_Next )
                    {
                        if (pAspReq == *ppTmpAspReq)
                        {
                            *ppTmpAspReq = pAspReq->asprq_Next;
                            break;
                        }
                    }
                    RELEASE_SPIN_LOCK_DPC(&pAspConn->aspco_Lock);
				    AtalkAspDereferenceConn(pAspConn);
                    AtalkBPFreeBlock(pAspReq);
                    pAspReq = NULL;
                    CancelResp = TRUE;
                    break;
                }

				RtlCopyMemory(pAspReq->asprq_ReqBuf, pPkt, PktLen);
				pAspReq->asprq_Request.rq_RequestBuf = pAspReq->asprq_ReqBuf;

				retStatus = (*pAspAddr->aspao_ClientEntries.clt_GetWriteBuffer)
                            (pAspConn->aspco_ConnContext,&pAspReq->asprq_Request);

                //
                // most common case: file server will pend it so it can go to cache mgr
                //
                if (retStatus == STATUS_PENDING)
                {
                    fTellAfp = FALSE;
                    break;
                }
                else if (retStatus == STATUS_SUCCESS)
                {
                    if (pAspReq->asprq_Request.rq_WriteMdl != NULL)
                    {
					    atalkAspPostWriteContinue(pAspReq);

                        // we informed (or will inform) AFP about this request: don't
                        // inform again below!
                        fTellAfp = FALSE;
                    }
                }
				else
				{
			        DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_ERR,
					    ("atalkAspSssXHandler: GetWriteBuffer returned %lx on %lx\n",
                        retStatus,pAspConn));
				}
			}

            // TRUE for CMD as well
			if ((pAspReq->asprq_Request.rq_WriteMdl == NULL) &&
                (fTellAfp))
			{
				pAspReq->asprq_Request.rq_RequestBuf = pPkt;

                ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

				// Notify the client that it has a request to handle
				retStatus = (*pAspAddr->aspao_ClientEntries.clt_RequestNotify)
                                (STATUS_SUCCESS,
								 pAspConn->aspco_ConnContext,
								 &pAspReq->asprq_Request);

                if (!NT_SUCCESS(retStatus))
                {
                    PASP_REQUEST  *ppTmpAspReq;

			        DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_ERR,
					    ("atalkAspSssXHandler: Afp didn't accept request %lx on conn %lx\n",
                        pAspReq,pAspConn));

                    ACQUIRE_SPIN_LOCK_DPC(&pAspConn->aspco_Lock);
                    for (ppTmpAspReq = &pAspConn->aspco_pActiveReqs;
                         *ppTmpAspReq != NULL; ppTmpAspReq = &(*ppTmpAspReq)->asprq_Next )
                    {
                        if (pAspReq == *ppTmpAspReq)
                        {
                            *ppTmpAspReq = pAspReq->asprq_Next;
                            break;
                        }
                    }
                    RELEASE_SPIN_LOCK_DPC(&pAspConn->aspco_Lock);

				    AtalkAspDereferenceConn(pAspConn);
                    AtalkBPFreeBlock(pAspReq);
                    pAspReq = NULL;
                    CancelResp = TRUE;
                }
			}
			break;
	
		  case ASP_CLOSE_SESSION:
			DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_WARN,
					("atalkAspSssXHandler: Close request from %d.%d for Session %d\n",
					pSrcAddr->ata_Network, pSrcAddr->ata_Node, SessionId));
	
#ifdef	PROFILING
			INTERLOCKED_INCREMENT_LONG_DPC(&AtalkStatistics.stat_AspSessionsClosed,
										   &AtalkStatsLock.SpinLock);
#endif

			CancelTickle = ((pAspConn->aspco_Flags &ASPCO_TICKLING) != 0);
			pAspConn->aspco_Flags &= ~(ASPCO_ACTIVE | ASPCO_TICKLING);
			pAspConn->aspco_Flags |= ASPCO_REMOTE_CLOSE;
			RELEASE_SPIN_LOCK_DPC(&pAspConn->aspco_Lock);
	
			// Send a CloseSession reply and close the session
			Status = AtalkAtpPostResp(pAtpResp,
									  pSrcAddr,
									  NULL,
									  0,
									  NULL,
									  AtalkAtpGenericRespComplete,
									  pAtpResp);
			if (!ATALK_SUCCESS(Status))
			{
				AtalkAtpGenericRespComplete(Status, pAtpResp);
				DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_ERR,
						("atalkAspSssXHandler: AtalkAtpPostResp failed %ld\n", Status));
			}
	
			// Cancel the tickle requests for this session
			if (CancelTickle)
			{
				Status = AtalkAtpCancelReq(pAspAddr->aspao_pSlsAtpAddr,
										   pAspConn->aspco_TickleXactId,
										   &pAspConn->aspco_WssRemoteAddr);
		
				if (!ATALK_SUCCESS(Status))
				{
					DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_ERR,
							("atalkAspSssXHandler: AtalkAtpCancelReq %ld\n", Status));
				}
			}
	
			// Shut down this session, well almost ... Note that we have a reference
			// to this connection which will be Dereferenced by atalkAspSessionClose.
			atalkAspSessionClose(pAspConn);
			break;
	
		  default:
			RELEASE_SPIN_LOCK_DPC(&pAspConn->aspco_Lock);
			CancelResp = TRUE;
			AtalkAspDereferenceConn(pAspConn);
			DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_ERR,
					("atalkAspSssXHandler: Invalid command %d\n", RequestType));
			break;
		}
	} while (FALSE);

	if (CancelResp)
	{
		Status = AtalkAtpCancelResp(pAtpResp);
		if (!ATALK_SUCCESS(Status))
		{
			DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_ERR,
					("atalkAspSssXHandler: AtalkAspCancelResp %ld\n", Status));
		}
	}
}




LOCAL VOID FASTCALL
atalkAspReplyRelease(
	IN	ATALK_ERROR		ErrorCode,
	IN	PASP_REQUEST	pAspReq
	)
/*++

Routine Description:

 	Handler for incoming release for reply

Arguments:


Return Value:


--*/
{
	PASP_CONNOBJ	pAspConn;
	PASP_ADDROBJ	pAspAddr;
	KIRQL			OldIrql;
	NTSTATUS		Status = STATUS_SUCCESS;

	ASSERT (VALID_ASPRQ(pAspReq));
	pAspConn = pAspReq->asprq_pAspConn;
	ASSERT (VALID_ASPCO(pAspConn));

	pAspAddr = pAspConn->aspco_pAspAddr;
	ASSERT (VALID_ASPAO(pAspAddr));

	ASSERT ((pAspReq->asprq_Flags & ASPRQ_REPLY) || !ATALK_SUCCESS(ErrorCode));

	if (!NT_SUCCESS(ErrorCode))
	{
		DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_WARN,
				("atalkAspReplyRelease: Failure %ld\n", ErrorCode));
		Status = AtalkErrorToNtStatus(ErrorCode);
	}

	// We complete here
	(*pAspAddr->aspao_ClientEntries.clt_ReplyCompletion)(Status,
														 pAspConn->aspco_ConnContext,
														 &pAspReq->asprq_Request);

	// Based on whether a reply was actually sent or not, either deref the response
	// or cancel it.
	if (pAspReq->asprq_Flags & ASPRQ_REPLY)
	{
		AtalkAtpRespDereference(pAspReq->asprq_pAtpResp);
	}
	else
	{
		AtalkAtpCancelResp(pAspReq->asprq_pAtpResp);
	}

    // make sure we aren't hanging on to cache mgr's mdl!
	ASSERT(pAspReq->asprq_Request.rq_CacheMgrContext == NULL);

#if	DBG
	pAspReq->asprq_Signature = 0x28041998;
	pAspReq->asprq_pAtpResp = (PATP_RESP)(pAspReq->asprq_Request.rq_WriteMdl);
	pAspReq->asprq_pAspConn = (PASP_CONNOBJ)(pAspReq->asprq_Request.rq_CacheMgrContext);
	pAspReq->asprq_Request.rq_WriteMdl = (PMDL)0x44556677;
	pAspReq->asprq_Request.rq_CacheMgrContext = (PVOID)66778899;
#endif


	// Free this as we are done with this request now
	ACQUIRE_SPIN_LOCK(&pAspConn->aspco_Lock, &OldIrql);

	if (pAspConn->aspco_pFreeReqs == NULL)
	{
		pAspReq->asprq_Next = NULL;
		pAspConn->aspco_pFreeReqs = pAspReq;
	}
	else AtalkBPFreeBlock(pAspReq);

	RELEASE_SPIN_LOCK(&pAspConn->aspco_Lock, OldIrql);

	// We are done with this request.
	AtalkAspDereferenceConn(pAspConn);
}




LOCAL VOID
atalkAspWriteContinueResp(
	IN	ATALK_ERROR		ErrorCode,
	IN	PASP_REQUEST	pAspReq,
	IN	PAMDL			pReqAMdl,
	IN	PAMDL			pRespAMdl,
	IN	USHORT			RespSize,
	IN	PBYTE			RespUserBytes
	)
/*++

Routine Description:

 	Handler for incoming write continue response.

Arguments:


Return Value:


--*/
{
	PASP_CONNOBJ	pAspConn;
	PASP_ADDROBJ	pAspAddr;
	NTSTATUS		Status;
	NTSTATUS		retStatus;
    KIRQL           OldIrql;
	PASP_REQUEST *	ppAspReq;
    PVOID           pClientContxt;


	ASSERT (VALID_ASPRQ(pAspReq));

	ASSERT(pAspReq->asprq_Flags & ASPRQ_WRTCONT);

	pAspConn = pAspReq->asprq_pAspConn;
	ASSERT(VALID_ASPCO(pAspConn));

	DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_INFO,
			("atalkAspWriteContinueResp: Entered for request %lx\n", pAspReq));

	pAspAddr = pAspConn->aspco_pAspAddr;
	ASSERT(VALID_ASPAO(pAspAddr));

	pAspReq->asprq_Flags &= ~ASPRQ_WRTCONT;

	pClientContxt = pAspConn->aspco_ConnContext;

	if (ATALK_SUCCESS(ErrorCode))
	{
		pAspConn->aspco_RT.rt_New = AtalkGetCurrentTick() - pAspConn->aspco_RT.rt_New;
	
		// Estimate the retry interval for next time.
		AtalkCalculateNewRT(&pAspConn->aspco_RT);
		Status = STATUS_SUCCESS;
	}
	else
	{
		Status = AtalkErrorToNtStatus(ErrorCode);
	}

#ifdef	PROFILING
	{
		KIRQL	OldIrql;

		ACQUIRE_SPIN_LOCK(&AtalkStatsLock, &OldIrql);

		AtalkStatistics.stat_LastAspRTT = (ULONG)(pAspConn->aspco_RT.rt_Base);
		if ((ULONG)(pAspConn->aspco_RT.rt_Base) > AtalkStatistics.stat_MaxAspRTT)
			AtalkStatistics.stat_MaxAspRTT = (ULONG)(pAspConn->aspco_RT.rt_Base);

		RELEASE_SPIN_LOCK(&AtalkStatsLock, OldIrql);
	}
#endif
	DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_INFO,
			("atalkAspWriteContinueResp: Indicating request %lx\n", pAspReq));

	// Notify the client that it has a request to handle
    KeRaiseIrql(DISPATCH_LEVEL, &OldIrql);

	retStatus = (*pAspAddr->aspao_ClientEntries.clt_RequestNotify)
                            (Status,
							 pClientContxt,
							 &pAspReq->asprq_Request);

    KeLowerIrql(OldIrql);

    //
	// In case the writecontinue returned an error, this request needs to go away
	// since there will never be a call to AtalkAspReply(). Also deref the conn.
    // Alternately, if the response came in fine, but the server didn't want to accept
    // it, it's the same deal
    //
    if ( (!NT_SUCCESS(Status)) || (!NT_SUCCESS(retStatus)) )
    {
	    DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_ERR,
			("atalkAspWriteContinueResp: incoming %lx, Afp %lx req: %lx on %lx, cancelling\n",
            Status,retStatus,pAspReq,pAspConn));

		ACQUIRE_SPIN_LOCK(&pAspConn->aspco_Lock, &OldIrql);
	
		for (ppAspReq = &pAspConn->aspco_pActiveReqs;
			 *ppAspReq != NULL;
			 ppAspReq = &(*ppAspReq)->asprq_Next)
		{
			if (pAspReq == *ppAspReq)
			{
				*ppAspReq = pAspReq->asprq_Next;
				pAspConn->aspco_cReqsInProcess --;
				break;
			}
		}

		ASSERT (*ppAspReq == pAspReq->asprq_Next);
	
		RELEASE_SPIN_LOCK(&pAspConn->aspco_Lock, OldIrql);

		AtalkAspDereferenceConn(pAspConn);

		// Cancel the response for the original request that caused wrtcont to be posted
		AtalkAtpCancelResp(pAspReq->asprq_pAtpResp);

		// Free this request as well
		AtalkBPFreeBlock(pAspReq);
    }


    if (pReqAMdl)
    {
	    ASSERT (AtalkGetAddressFromMdlSafe(pReqAMdl, NormalPagePriority) == pAspReq->asprq_WrtContRespBuf);
	    ASSERT (AtalkSizeMdlChain(pReqAMdl) == ASP_WRITE_DATA_SIZE);

	    AtalkFreeAMdl(pReqAMdl);
    }

}




LOCAL VOID
atalkAspSendAttentionResp(
	IN	ATALK_ERROR		ErrorCode,
	IN	PVOID			pContext,
	IN	PAMDL			pReqAMdl,
	IN	PAMDL			pRespAMdl,
	IN	USHORT			RespSize,
	IN	PBYTE			RespUserBytes
	)
/*++

Routine Description:

 	Handler for incoming write continue response.

Arguments:


Return Value:


--*/
{
	PBYTE			pBuf;
	PASP_CONNOBJ	pAspConn = (PASP_CONNOBJ)pContext;

	DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_INFO,
			("atalkAspSendAttentionResp: Entered for conn %lx\n", pAspConn));

	if (!ATALK_SUCCESS(ErrorCode))
	{
		DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_ERR,
				("atalkAspSendAttentionResp: Failure %ld\n", ErrorCode));
	}

	if (pRespAMdl != NULL)
	{
		pBuf = AtalkGetAddressFromMdlSafe(
				pRespAMdl,
				NormalPagePriority);

		if (pBuf != NULL)
        {
			AtalkFreeMemory(pBuf);
        }
		AtalkFreeAMdl(pRespAMdl);
	}

	// Call the completion routine
	(*pAspConn->aspco_pAspAddr->aspao_ClientEntries.clt_AttnCompletion)(pAspConn->aspco_AttentionContext);

	pAspConn->aspco_AttentionContext = NULL;

	// Finally Dereference the connection
	AtalkAspDereferenceConn(pAspConn);
}



LOCAL LONG FASTCALL
atalkAspSessionMaintenanceTimer(
	IN	PTIMERLIST	pTimer,
	IN	BOOLEAN		TimerShuttingDown
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PASP_CONNOBJ	pAspConn, pAspConnNext;
    PASP_CONN_MAINT	pAspCM;
	BOOLEAN			Close = FALSE;
	LONG			CurrentTick =  AtalkGetCurrentTick();
#ifdef	PROFILING
	TIME			TimeS, TimeE, TimeD;

	TimeS = KeQueryPerformanceCounter(NULL);
#endif

	DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_INFO,
			("atalkAspSessionMaintenanceTimer: Entered\n"));

	if (TimerShuttingDown)
		return ATALK_TIMER_NO_REQUEUE;

	pAspCM = CONTAINING_RECORD(pTimer, ASP_CONN_MAINT, ascm_SMTTimer);

	ACQUIRE_SPIN_LOCK_DPC(&atalkAspLock);

	// Walk the list of sessions on the global list and shut down
	// sessions that have not tickle'd for a while
	for (pAspConn = pAspCM->ascm_ConnList; pAspConn != NULL; pAspConn = pAspConnNext)
	{
		DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_INFO,
				("atalkAspSessionMaintenanceTimer: Checking out session %d from %x.%x\n",
				pAspConn->aspco_SessionId,
				pAspConn->aspco_WssRemoteAddr.ata_Network,
				pAspConn->aspco_WssRemoteAddr.ata_Node));

		pAspConnNext = pAspConn->aspco_NextSession;

		Close = FALSE;
		ASSERT (VALID_ASPCO(pAspConn));

		ACQUIRE_SPIN_LOCK_DPC(&pAspConn->aspco_Lock);

		if ((pAspConn->aspco_Flags & ASPCO_ACTIVE)	&&
			((CurrentTick - pAspConn->aspco_LastContactTime) > ASP_MAX_SESSION_IDLE_TIME))
		{
			pAspConn->aspco_Flags |= (ASPCO_REMOTE_CLOSE | ASPCO_DROPPED);
			pAspConn->aspco_Flags &= ~ASPCO_ACTIVE;
			pAspConn->aspco_RefCount ++;	// Since atalkAspSessionClose Derefs it

			Close = TRUE;
		}

		RELEASE_SPIN_LOCK_DPC(&pAspConn->aspco_Lock);

		if (Close)
		{
			PASP_ADDROBJ	pAspAddr;
			ATALK_ERROR		Status;

#ifdef	PROFILING
			INTERLOCKED_INCREMENT_LONG_DPC(&AtalkStatistics.stat_AspSessionsDropped,
										   &AtalkStatsLock.SpinLock);
#endif
			pAspAddr = pAspConn->aspco_pAspAddr;
			ASSERT (VALID_ASPAO(pAspAddr));

			DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_ERR,
					("atalkAspSessionMaintenanceTimer: Shutting down session %d from %x.%x\n",
					pAspConn->aspco_SessionId,
					pAspConn->aspco_WssRemoteAddr.ata_Network,
					pAspConn->aspco_WssRemoteAddr.ata_Node));

			RELEASE_SPIN_LOCK_DPC(&atalkAspLock);

			// This session is being punted. Cancel tickles on this and notify the
			// server that this session is history.
			Status = AtalkAtpCancelReq(pAspAddr->aspao_pSlsAtpAddr,
									   pAspConn->aspco_TickleXactId,
									   &pAspConn->aspco_WssRemoteAddr);
			if (!ATALK_SUCCESS(Status))
			{
				DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_ERR,
						("atalkAspSessionMaintenanceTimer: AtalkAtpCancelReq %ld\n", Status));
			}

			// Shut down this session, well almost ...
			atalkAspSessionClose(pAspConn);

			ACQUIRE_SPIN_LOCK_DPC(&atalkAspLock);
			pAspConnNext = pAspCM->ascm_ConnList;
		}
	}

#ifdef	PROFILING
	TimeE = KeQueryPerformanceCounter(NULL);
	TimeD.QuadPart = TimeE.QuadPart - TimeS.QuadPart;

	INTERLOCKED_ADD_LARGE_INTGR_DPC(&AtalkStatistics.stat_AspSmtProcessTime,
									TimeD,
									&AtalkStatsLock.SpinLock);

	INTERLOCKED_INCREMENT_LONG_DPC( &AtalkStatistics.stat_AspSmtCount,
									&AtalkStatsLock.SpinLock);
#endif

	RELEASE_SPIN_LOCK_DPC(&atalkAspLock);

	// Reschedule ourselves
	return ATALK_TIMER_REQUEUE;
}




LOCAL VOID
atalkAspSessionClose(
	IN	PASP_CONNOBJ	pAspConn
	)
/*++

Routine Description:

	This should be called with a reference to the connection which is Dereferenced
	here.

Arguments:


Return Value:


--*/
{
	PASP_REQUEST	pAspReq, pAspReqNext;
	PASP_ADDROBJ	pAspAddr = pAspConn->aspco_pAspAddr;
	REQUEST			Request;
	KIRQL			OldIrql;
	NTSTATUS		Status = STATUS_REMOTE_DISCONNECT;

	ACQUIRE_SPIN_LOCK(&pAspConn->aspco_Lock, &OldIrql);
   	pAspConn->aspco_Flags &= ~ASPCO_ACTIVE;

	// Cancel any Write-continues pending. Do not bother cancelling
	// replies as they will time out anyway. Also atalkAspReplyRelease()
	// will attempt to acquire the connection lock and we're already
	// holding it
	for (pAspReq = pAspConn->aspco_pActiveReqs;
		 pAspReq != NULL;
		 pAspReq = pAspReqNext)
	{
	    pAspReqNext = pAspReq->asprq_Next;
		if ((pAspReq->asprq_Flags & (ASPRQ_WRTCONT | ASPRQ_WRTCONT_CANCELLED)) == ASPRQ_WRTCONT)
		{
			pAspReq->asprq_Flags |= ASPRQ_WRTCONT_CANCELLED;

			RELEASE_SPIN_LOCK(&pAspConn->aspco_Lock, OldIrql);

			AtalkAtpCancelReq(pAspAddr->aspao_pSssAtpAddr,
							  pAspReq->asprq_WCXactId,
							  &pAspConn->aspco_WssRemoteAddr);

			ACQUIRE_SPIN_LOCK(&pAspConn->aspco_Lock, &OldIrql);
			pAspReqNext = pAspConn->aspco_pActiveReqs;
		}
	}

	RELEASE_SPIN_LOCK(&pAspConn->aspco_Lock, OldIrql);

	if (pAspConn->aspco_Flags & ASPCO_DROPPED)
	{
		Status = STATUS_LOCAL_DISCONNECT;
	}

	// Indicate a request with an error to indicate that the session closed remotely.
	// Pass the remote address of the client so that the server can log an event if
	// the session did not shutdown gracefully.

	Request.rq_RequestSize = (LONG)(pAspConn->aspco_WssRemoteAddr.ata_Address);
	Request.rq_RequestBuf = NULL;
	Request.rq_WriteMdl = NULL;
    Request.rq_CacheMgrContext = NULL;

	(*pAspAddr->aspao_ClientEntries.clt_RequestNotify)(Status,
													   pAspConn->aspco_ConnContext,
													   &Request);
	// Finally Dereference the session
	AtalkAspDereferenceConn(pAspConn);
}


LOCAL VOID
atalkAspReturnResp(
	IN	PATP_RESP		pAtpResp,
	IN	PATALK_ADDR		pDstAddr,
	IN	BYTE			Byte0,
	IN	BYTE			Byte1,
	IN	USHORT			Word2
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	BYTE		UserBytes[ATP_USERBYTES_SIZE];
	ATALK_ERROR	Status;

	UserBytes[0] = Byte0;
	UserBytes[1] = Byte1;
	PUTSHORT2SHORT(UserBytes+2, Word2);

	DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_INFO,
			("atalkAspReturnResp: For Resp %lx\n", pAtpResp));

	Status = AtalkAtpPostResp(pAtpResp,
							  pDstAddr,
							  NULL,
							  0,
							  UserBytes,
							  AtalkAtpGenericRespComplete,
							  pAtpResp);
	if (!ATALK_SUCCESS(Status))
	{
		DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_ERR,
				("atalkAspReturnResp: AtalkAtpPostResp failed %ld\n", Status));
		AtalkAtpGenericRespComplete(Status, pAtpResp);
	}
}




LOCAL VOID FASTCALL
atalkAspRespComplete(
	IN	ATALK_ERROR				ErrorCode,
	IN	PASP_POSTSTAT_CTX		pStsCtx
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_INFO,
			("atalkAspRespComplete: Entered pStsCtx %lx\n", pStsCtx));

	if (!ATALK_SUCCESS(ErrorCode))
	{
		DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_ERR,
				("atalkAspRespComplete: Failed %ld, pStsCtx %lx\n", ErrorCode, pStsCtx));
	}

	if (pStsCtx != NULL)
	{
		AtalkFreeAMdl(pStsCtx->aps_pAMdl);
		AtalkAtpRespDereferenceDpc(pStsCtx->aps_pAtpResp);
		AtalkFreeMemory(pStsCtx);
	}
}




LOCAL VOID
atalkAspCloseComplete(
	IN	ATALK_ERROR		Status,
	IN	PASP_ADDROBJ	pAspAddr
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_WARN,
			("atalkAspCloseComplete: AtalkAtpCloseAddr returned %ld\n",  Status));
	AtalkAspDereferenceAddr(pAspAddr);
}


#if	DBG

VOID
AtalkAspDumpSessions(
	VOID
)
{
	PASP_CONNOBJ	pAspConn;
	KIRQL			OldIrql;
	LONG			i;

	DBGPRINT(DBG_COMP_DUMP, DBG_LEVEL_FATAL, ("ASP SESSION LIST:\n"));

	ACQUIRE_SPIN_LOCK(&atalkAspLock, &OldIrql);

	for (i = 0; i < NUM_ASP_CONN_LISTS; i++)
	{
		for (pAspConn = atalkAspConnMaint[i].ascm_ConnList;
			 pAspConn != NULL;
			 pAspConn = pAspConn->aspco_NextSession)
		{
			DBGPRINT(DBG_COMP_DUMP, DBG_LEVEL_FATAL,
					("\tRemote Addr %4d.%3d.%2d SessionId %2d Flags %4x RefCount %ld\n",
					pAspConn->aspco_WssRemoteAddr.ata_Network,
					pAspConn->aspco_WssRemoteAddr.ata_Node,
					pAspConn->aspco_WssRemoteAddr.ata_Socket,
					pAspConn->aspco_SessionId,
					pAspConn->aspco_Flags,
					pAspConn->aspco_RefCount));
		}
	}
	RELEASE_SPIN_LOCK(&atalkAspLock, OldIrql);
}

#endif


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\atalk\sys\atkact.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

	atkact.c

Abstract:

	This module contains the TDI action support code.

Author:

	Jameel Hyder (jameelh@microsoft.com)
	Nikhil Kamkolkar (nikhilk@microsoft.com)

Revision History:
	19 Jun 1992		Initial Version

Notes:	Tab stop: 4
--*/

#include <atalk.h>
#pragma hdrstop
#define	FILENUM		ATKACT

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE_NZ, AtalkNbpTdiAction)
#pragma alloc_text(PAGE_NZ, AtalkZipTdiAction)
#pragma alloc_text(PAGE, AtalkAspTdiAction)
#pragma alloc_text(PAGE, AtalkAdspTdiAction)
#pragma alloc_text(PAGE_PAP, AtalkPapTdiAction)
#pragma alloc_text(PAGEASPC, AtalkAspCTdiAction)
#endif

ATALK_ERROR
AtalkStatTdiAction(
	IN	PVOID				pObject,	// Address or Connection object
	IN	struct _ActionReq *	pActReq		// Pointer to action request
	)
/*++

Routine Description:

 	This is the entry for Statistics TdiAction call. There are no input parameters.
 	The statistics structure is returned.

Arguments:


Return Value:


--*/
{
	ATALK_ERROR			Error = ATALK_NO_ERROR;
	PPORT_DESCRIPTOR	pPortDesc;
	KIRQL				OldIrql;
	ULONG				BytesCopied;
	LONG				Offset;

	if (pActReq->ar_MdlSize < (SHORT)(sizeof(ATALK_STATS) +
								 sizeof(ATALK_PORT_STATS) * AtalkNumberOfPorts))
		Error = ATALK_BUFFER_TOO_SMALL;
	else
	{
#ifdef	PROFILING
		//	This is the only place where this is changed. And it always increases.
		//	Also the stats are changed using ExInterlocked calls. Acquiring a lock
		//	does little in terms of protection anyways.
		AtalkStatistics.stat_ElapsedTime = AtalkTimerCurrentTick/ATALK_TIMER_FACTOR;
#endif
		TdiCopyBufferToMdl(&AtalkStatistics,
						   0,
						   sizeof(ATALK_STATS),
						   pActReq->ar_pAMdl,
						   0,
						   &BytesCopied);
		ASSERT(BytesCopied == sizeof(ATALK_STATS));

		ACQUIRE_SPIN_LOCK(&AtalkPortLock, &OldIrql);

		for (pPortDesc = AtalkPortList, Offset = sizeof(ATALK_STATS);
			 pPortDesc != NULL;
			 pPortDesc = pPortDesc->pd_Next)
		{
			TdiCopyBufferToMdl(&pPortDesc->pd_PortStats,
							   0,
							   sizeof(ATALK_PORT_STATS),
							   pActReq->ar_pAMdl,
							   Offset,
							   &BytesCopied);
			Offset += sizeof(ATALK_PORT_STATS);
			ASSERT(BytesCopied == sizeof(ATALK_PORT_STATS));
		}

		RELEASE_SPIN_LOCK(&AtalkPortLock, OldIrql);
	}
	
	(*pActReq->ar_Completion)(Error, pActReq);
	return ATALK_PENDING;
}


ATALK_ERROR
AtalkNbpTdiAction(
	IN	PVOID				pObject,	// Address or Connection object
	IN	PACTREQ				pActReq		// Pointer to action request
	)
/*++

Routine Description:

 	This is the entry for NBP TdiAction calls. The parameters are validated and
 	the calls are dispacthed to the appropriate NBP routines.

Arguments:


Return Value:


--*/
{
	ATALK_ERROR		error = ATALK_NO_ERROR;
	PDDP_ADDROBJ	pDdpAddr;
	PNBPTUPLE		pNbpTuple;

	PAGED_CODE ();

	// Lock the Nbp stuff, if this is the first nbp action
	AtalkLockNbpIfNecessary();

	ASSERT (VALID_ACTREQ(pActReq));
	// First get the Ddp address out of the pObject for the device
	switch (pActReq->ar_DevType)
	{
	  case ATALK_DEV_DDP:
		pDdpAddr = (PDDP_ADDROBJ)pObject;
  		break;

	  case ATALK_DEV_ASPC:
		pDdpAddr = AtalkAspCGetDdpAddress((PASPC_ADDROBJ)pObject);
		break;

	  case ATALK_DEV_ASP:
  		pDdpAddr = AtalkAspGetDdpAddress((PASP_ADDROBJ)pObject);
		break;

	  case ATALK_DEV_PAP:
 		pDdpAddr = AtalkPapGetDdpAddress((PPAP_ADDROBJ)pObject);
		break;

	  case ATALK_DEV_ADSP:
 		pDdpAddr = AtalkAdspGetDdpAddress((PADSP_ADDROBJ)pObject);
		break;

	  default:
		DBGPRINT(DBG_COMP_ACTION, DBG_LEVEL_FATAL,
				("AtalkNbpTdiAction: Invalid device type !!\n"));
		error = ATALK_INVALID_REQUEST;
		break;
	}

	// reference the Ddp address.
	if ((pActReq->ar_ActionCode == COMMON_ACTION_NBPREGISTER_BY_ADDR) ||
		(pActReq->ar_ActionCode == COMMON_ACTION_NBPREMOVE_BY_ADDR))
	{
		// In this case, we don't want to access the object related to
		// the filehandle in the IO request, we want to access the object
		// related to a specific user socket address.
		pNbpTuple = (PNBPTUPLE)(&((PNBP_REGDEREG_PARAMS)(pActReq->ar_pParms))->RegisterTuple);
		AtalkDdpReferenceByAddr(AtalkDefaultPort,
								&(pNbpTuple->tpl_Address),
								&pDdpAddr,
								&error);
	}
	else
	{
		AtalkDdpReferenceByPtr(pDdpAddr, &error);
	}

	if (!ATALK_SUCCESS(error))
	{
		AtalkUnlockNbpIfNecessary();
		return error;
	}

	// Call Nbp to do the right stuff
	switch (pActReq->ar_ActionCode)
	{
	  case COMMON_ACTION_NBPLOOKUP:
		pNbpTuple = (PNBPTUPLE)(&((PNBP_LOOKUP_PARAMS)(pActReq->ar_pParms))->LookupTuple);
		error = AtalkNbpAction(pDdpAddr,
							   FOR_LOOKUP,
							   pNbpTuple,
							   pActReq->ar_pAMdl,
							   (USHORT)(pActReq->ar_MdlSize/sizeof(NBPTUPLE)),
							   pActReq);
		break;

	  case COMMON_ACTION_NBPCONFIRM:
		pNbpTuple = (PNBPTUPLE)(&((PNBP_CONFIRM_PARAMS)(pActReq->ar_pParms))->ConfirmTuple);
		error = AtalkNbpAction(pDdpAddr,
							   FOR_CONFIRM,
							   pNbpTuple,
							   NULL,
							   0,
							   pActReq);
		break;

	  case COMMON_ACTION_NBPREGISTER:
		pNbpTuple = (PNBPTUPLE)(&((PNBP_REGDEREG_PARAMS)(pActReq->ar_pParms))->RegisterTuple);
		error = AtalkNbpAction(pDdpAddr,
								FOR_REGISTER,
								pNbpTuple,
								NULL,
								0,
								pActReq);
  		break;

	  case COMMON_ACTION_NBPREMOVE:
		pNbpTuple = (PNBPTUPLE)(&((PNBP_REGDEREG_PARAMS)(pActReq->ar_pParms))->RegisteredTuple);
		error = AtalkNbpRemove(pDdpAddr,
							   pNbpTuple,
							   pActReq);
		break;

	  case COMMON_ACTION_NBPREGISTER_BY_ADDR:
		pNbpTuple = (PNBPTUPLE)(&((PNBP_REGDEREG_PARAMS)(pActReq->ar_pParms))->RegisterTuple);
		error = AtalkNbpAction(pDdpAddr,
							   FOR_REGISTER,
							   pNbpTuple,
							   NULL,
							   0,
							   pActReq);
  		break;

	  case COMMON_ACTION_NBPREMOVE_BY_ADDR:
		pNbpTuple = (PNBPTUPLE)(&((PNBP_REGDEREG_PARAMS)(pActReq->ar_pParms))->RegisteredTuple);
		error = AtalkNbpRemove(pDdpAddr,
							   pNbpTuple,
							   pActReq);
		break;

	  default:
		DBGPRINT(DBG_COMP_ACTION, DBG_LEVEL_FATAL,
				("AtalkNbpTdiAction: Invalid Nbp Action !!\n"));
		error = ATALK_INVALID_REQUEST;
		break;
	}

	AtalkDdpDereference(pDdpAddr);

	if (error != ATALK_PENDING)
	{
		AtalkUnlockNbpIfNecessary();
	}

	return error;
}




ATALK_ERROR
AtalkZipTdiAction(
	IN	PVOID				pObject,	// Address or Connection object
	IN	PACTREQ				pActReq		// Pointer to action request
	)
/*++

Routine Description:

 	This is the entry for ZIP TdiAction calls. The parameters are validated and
 	the calls are dispacthed to the appropriate ZIP routines.

Arguments:


Return Value:


--*/
{
	ATALK_ERROR			error = ATALK_INVALID_PARAMETER;
	PPORT_DESCRIPTOR	pPortDesc = AtalkDefaultPort;
	PWCHAR				PortName = NULL;
    USHORT              PortNameLen;
	UNICODE_STRING		AdapterName, UpcaseAdapterName;
	WCHAR				UpcaseBuffer[MAX_INTERNAL_PORTNAME_LEN];
	KIRQL				OldIrql;
	int					i;

	PAGED_CODE ();

	// Lock the Zip stuff, if this is the first zip action
	AtalkLockZipIfNecessary();
	
	ASSERT (VALID_ACTREQ(pActReq));
	if ((pActReq->ar_ActionCode == COMMON_ACTION_ZIPGETLZONESONADAPTER) ||
		(pActReq->ar_ActionCode == COMMON_ACTION_ZIPGETADAPTERDEFAULTS))
	{
		// Map the port name to the port descriptor
		if ((pActReq->ar_pAMdl != NULL) && (pActReq->ar_MdlSize > 0))
		{
			PortName = (PWCHAR)AtalkGetAddressFromMdlSafe(
					pActReq->ar_pAMdl,
					NormalPagePriority);

		}

		if (PortName == NULL)
        {
            AtalkUnlockZipIfNecessary();
            return ATALK_INVALID_PARAMETER;
        }

        PortNameLen = pActReq->ar_MdlSize/sizeof(WCHAR);

        // make sure there is a NULL char in the buffer
        for (i=0; i<PortNameLen; i++)
        {
            if (PortName[i] == UNICODE_NULL)
            {
                break;
            }
        }

        // didn't find null char within limit?  bad parameter..
        if (i >= MAX_INTERNAL_PORTNAME_LEN)
        {
		    DBGPRINT(DBG_COMP_ACTION, DBG_LEVEL_FATAL,
				("AtalkZipTdiAction: port name too big (%d) for %lx\n",PortNameLen,PortName));

            ASSERT(0);
            return ATALK_INVALID_PARAMETER;
        }

        PortNameLen = (USHORT)i;

		AdapterName.Buffer = PortName;
		AdapterName.Length = (PortNameLen)*sizeof(WCHAR);
		AdapterName.MaximumLength = (PortNameLen+1)*sizeof(WCHAR);

		UpcaseAdapterName.Buffer = UpcaseBuffer;
		UpcaseAdapterName.Length =
		UpcaseAdapterName.MaximumLength = sizeof(UpcaseBuffer);
		RtlUpcaseUnicodeString(&UpcaseAdapterName,
							   &AdapterName,
							   FALSE);

		ACQUIRE_SPIN_LOCK(&AtalkPortLock, &OldIrql);

		// Find the port corres. to the port descriptor
		for (pPortDesc = AtalkPortList;
			 pPortDesc != NULL;
			 pPortDesc = pPortDesc->pd_Next)
		{
			if ((UpcaseAdapterName.Length == pPortDesc->pd_AdapterName.Length) &&
				RtlEqualMemory(UpcaseAdapterName.Buffer,
							   pPortDesc->pd_AdapterName.Buffer,
							   UpcaseAdapterName.Length))
			{
				break;
			}
		}

		RELEASE_SPIN_LOCK(&AtalkPortLock, OldIrql);

		if (pPortDesc == NULL)
        {
            AtalkUnlockZipIfNecessary();
            return ATALK_INVALID_PARAMETER;
        }
	}
	else if (pActReq->ar_ActionCode == COMMON_ACTION_ZIPGETZONELIST)
	{
			PPORT_DESCRIPTOR	pTempPortDesc = NULL;

			// This is to take care of cases when zone list is requested
			// but the default adapter has gone away during PnP, and
			// AtalkDefaultPort points to NULL
			if (pPortDesc == NULL)
			{
				DBGPRINT(DBG_COMP_ACTION, DBG_LEVEL_ERR,
					("COMMON_ACTION_ZIPGETZONELIST: PortDesc points to NULL\n"));
			    AtalkUnlockZipIfNecessary();
			    return ATALK_PORT_INVALID;
			}

			// Check if the AtalkDefaultPort is still in the list
			// It is possible that AtalkDefaultPort holds a non-NULL value, but
			// the adapter has gone away during a PnP

			ACQUIRE_SPIN_LOCK(&AtalkPortLock, &OldIrql);

			// Find the port corres. to the port descriptor
			for (pTempPortDesc = AtalkPortList;
			 	pTempPortDesc != NULL;
			 	pTempPortDesc = pTempPortDesc->pd_Next)
			{
					if (pTempPortDesc == pPortDesc)
					{
						break;
					}
			}

			RELEASE_SPIN_LOCK(&AtalkPortLock, OldIrql);

			if (pTempPortDesc == NULL)
       		{
				DBGPRINT(DBG_COMP_ACTION, DBG_LEVEL_ERR,
					("COMMON_ACTION_ZIPGETZONELIST: PortDesc structure has gone away during PnP\n"));
            	AtalkUnlockZipIfNecessary();
            	return ATALK_PORT_INVALID;
        	}
	}

	switch (pActReq->ar_ActionCode)
	{
	  case COMMON_ACTION_ZIPGETMYZONE:
		error = AtalkZipGetMyZone( pPortDesc,
								   TRUE,
								   pActReq->ar_pAMdl,
								   pActReq->ar_MdlSize,
								   pActReq);
		break;

	  case COMMON_ACTION_ZIPGETZONELIST:
		error = AtalkZipGetZoneList(pPortDesc,
									FALSE,
									pActReq->ar_pAMdl,
									pActReq->ar_MdlSize,
									pActReq);
		break;

	  case COMMON_ACTION_ZIPGETADAPTERDEFAULTS:
		// Copy the network range from the port and fall through
		((PZIP_GETPORTDEF_PARAMS)(pActReq->ar_pParms))->NwRangeLowEnd =
							pPortDesc->pd_NetworkRange.anr_FirstNetwork;
		((PZIP_GETPORTDEF_PARAMS)(pActReq->ar_pParms))->NwRangeHighEnd =
							pPortDesc->pd_NetworkRange.anr_LastNetwork;

		error = AtalkZipGetMyZone(pPortDesc,
								  FALSE,
								  pActReq->ar_pAMdl,
								  pActReq->ar_MdlSize,
								  pActReq);
		break;

	  case COMMON_ACTION_ZIPGETLZONESONADAPTER:
	  case COMMON_ACTION_ZIPGETLZONES:
		error = AtalkZipGetZoneList(pPortDesc,
									TRUE,
									pActReq->ar_pAMdl,
									pActReq->ar_MdlSize,
									pActReq);
		break;

	  default:
		DBGPRINT(DBG_COMP_ACTION, DBG_LEVEL_FATAL,
				("AtalkZipTdiAction: Invalid Zip Action !!\n"));
		error = ATALK_INVALID_REQUEST;
		break;
	}

	if (error != ATALK_PENDING)
	{
		AtalkUnlockZipIfNecessary();
	}

	return error;
}




ATALK_ERROR
AtalkAspTdiAction(
	IN	PVOID				pObject,	// Address or Connection object
	IN	PACTREQ				pActReq		// Pointer to action request
	)
/*++

Routine Description:

 	This is the entry for ASP TdiAction calls. The parameters are validated and
 	the calls are dispacthed to the appropriate ASP routines.

 	The only ASP Action is: ASP_XCHG_ENTRIES

Arguments:


Return Value:


--*/
{
	ATALK_ERROR	error = ATALK_INVALID_REQUEST;

	PAGED_CODE ();

	ASSERT(VALID_ACTREQ(pActReq));

	if (pActReq->ar_ActionCode == ACTION_ASP_BIND)
	{
		if (AtalkAspReferenceAddr((PASP_ADDROBJ)pObject) != NULL)
		{
			error = AtalkAspBind((PASP_ADDROBJ)pObject,
								 (PASP_BIND_PARAMS)(pActReq->ar_pParms),
								 pActReq);
			AtalkAspDereferenceAddr((PASP_ADDROBJ)pObject);	
		}
	}

	return error;
}




ATALK_ERROR
AtalkAdspTdiAction(
	IN	PVOID				pObject,	// Address or Connection object
	IN	PACTREQ				pActReq		// Pointer to action request
	)
/*++

Routine Description:

 	This is the entry for ADSP TdiAction calls. The parameters are validated and
 	the calls are dispacthed to the appropriate ADSP routines.

Arguments:


Return Value:


--*/
{
	ATALK_ERROR	error = ATALK_NO_ERROR;

	PAGED_CODE ();

	ASSERT (VALID_ACTREQ(pActReq));

	return error;
}




ATALK_ERROR
AtalkAspCTdiAction(
	IN	PVOID				pObject,	// Address or Connection object
	IN	PACTREQ				pActReq		// Pointer to action request
	)
/*++

Routine Description:

 	This is the entry for ASP Client TdiAction calls. The parameters are validated
 	and the calls are dispatched to the appropriate ASP routines.

Arguments:


Return Value:


--*/
{
	ATALK_ERROR	error = ATALK_NO_ERROR;
	PAMDL		pReplyMdl;
	ATALK_ADDR	atalkAddr;
	BOOLEAN		fWrite;

	PAGED_CODE ();

	ASSERT (VALID_ACTREQ(pActReq));

	switch (pActReq->ar_ActionCode)
	{
	  case ACTION_ASPCGETSTATUS:
  		AtalkAspCAddrReference((PASPC_ADDROBJ)pObject, &error);
		if (ATALK_SUCCESS(error))
		{
			TDI_TO_ATALKADDR(&atalkAddr,
							 &(((PASPC_GETSTATUS_PARAMS)pActReq->ar_pParms)->ServerAddr));

			error = AtalkAspCGetStatus((PASPC_ADDROBJ)pObject,
										&atalkAddr,
										pActReq->ar_pAMdl,
										pActReq->ar_MdlSize,
										pActReq);

			AtalkAspCAddrDereference((PASPC_ADDROBJ)pObject);
		}
		break;

	  case ACTION_ASPCCOMMAND:
	  case ACTION_ASPCWRITE:
		// Split the mdl into command and reply/write mdls. The already constructed mdl
		// serves as the command mdl
		// First validate that the sizes are valid
		if (pActReq->ar_MdlSize < (((PASPC_COMMAND_OR_WRITE_PARAMS)pActReq->ar_pParms)->CmdSize +
								   ((PASPC_COMMAND_OR_WRITE_PARAMS)pActReq->ar_pParms)->WriteAndReplySize))
		{
			error = ATALK_BUFFER_TOO_SMALL;
			break;
		}
		pReplyMdl = AtalkSubsetAmdl(pActReq->ar_pAMdl,
									((PASPC_COMMAND_OR_WRITE_PARAMS)pActReq->ar_pParms)->CmdSize,
									((PASPC_COMMAND_OR_WRITE_PARAMS)pActReq->ar_pParms)->WriteAndReplySize);
		if (pReplyMdl == NULL)
		{
			error = ATALK_RESR_MEM;
			break;
		}

		AtalkAspCConnReference((PASPC_CONNOBJ)pObject, &error);
		if (ATALK_SUCCESS(error))
		{
			fWrite = (pActReq->ar_ActionCode == ACTION_ASPCWRITE) ? TRUE : FALSE;
			error = AtalkAspCCmdOrWrite((PASPC_CONNOBJ)pObject,
										pActReq->ar_pAMdl,
										((PASPC_COMMAND_OR_WRITE_PARAMS)pActReq->ar_pParms)->CmdSize,
										pReplyMdl,
										((PASPC_COMMAND_OR_WRITE_PARAMS)pActReq->ar_pParms)->WriteAndReplySize,
										fWrite,
										pActReq);
			AtalkAspCConnDereference((PASPC_CONNOBJ)pObject);
		}
		break;

	  default:
		DBGPRINT(DBG_COMP_ACTION, DBG_LEVEL_FATAL,
				("AtalkAspCTdiAction: Invalid Asp Client Action !!\n"));
		error = ATALK_INVALID_REQUEST;
		break;
	}

	return error;
}




ATALK_ERROR
AtalkPapTdiAction(
	IN	PVOID				pObject,	// Address or Connection object
	IN	PACTREQ				pActReq		// Pointer to action request
	)
/*++

Routine Description:

 	This is the entry for PAP TdiAction calls. The parameters are validated and
 	the calls are dispacthed to the appropriate PAP routines.

Arguments:


Return Value:


--*/
{
	ATALK_ERROR	error;
	ATALK_ADDR	atalkAddr;

	PAGED_CODE ();

	ASSERT (VALID_ACTREQ(pActReq));

	switch (pActReq->ar_ActionCode)
	{
	  case ACTION_PAPGETSTATUSSRV:
  		AtalkPapAddrReference((PPAP_ADDROBJ)pObject, &error);
		if (ATALK_SUCCESS(error))
		{
			TDI_TO_ATALKADDR(
				&atalkAddr,
				&(((PPAP_GETSTATUSSRV_PARAMS)pActReq->ar_pParms)->ServerAddr));

			error = AtalkPapGetStatus((PPAP_ADDROBJ)pObject,
									   &atalkAddr,
									   pActReq->ar_pAMdl,
									   pActReq->ar_MdlSize,
									   pActReq);

			AtalkPapAddrDereference((PPAP_ADDROBJ)pObject);
		}
		break;

	  case ACTION_PAPSETSTATUS:
  		AtalkPapAddrReference((PPAP_ADDROBJ)pObject, &error);
		if (ATALK_SUCCESS(error))
		{
			error = AtalkPapSetStatus((PPAP_ADDROBJ)pObject,
										pActReq->ar_pAMdl,
										pActReq);
			AtalkPapAddrDereference((PPAP_ADDROBJ)pObject);
		}
		break;

	  case ACTION_PAPPRIMEREAD:
		AtalkPapConnReferenceByPtr((PPAP_CONNOBJ)pObject, &error);
		if (ATALK_SUCCESS(error))
		{
			error = AtalkPapPrimeRead((PPAP_CONNOBJ)pObject, pActReq);
			AtalkPapConnDereference((PPAP_CONNOBJ)pObject);
		}
		break;

	  default:
		DBGPRINT(DBG_COMP_ACTION, DBG_LEVEL_FATAL,
				("AtalkPapTdiAction: Invalid Pap Action !!\n"));
		error = ATALK_INVALID_REQUEST;
		break;
	}

	return error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\atalk\sys\asp.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

	asp.h

Abstract:

	This module contains definitions for the server side ASP code.

Author:

	Jameel Hyder (jameelh@microsoft.com)
	Nikhil Kamkolkar (nikhilk@microsoft.com)

Revision History:
	19 Jun 1992		Initial Version

Notes:	Tab stop: 4
--*/

#ifndef	_ASP_
#define	_ASP_

// This defines only the server side ASP protocol solely for the consumption of the
// AFP Server. Hence any functionality not needed by the AFP Server is missing here

// ASP command type bytes:
#define ASP_CLOSE_SESSION				1
#define ASP_CMD							2
#define ASP_GET_STATUS					3
#define ASP_OPEN_SESSION				4
#define ASP_TICKLE						5
#define ASP_WRITE						6
#define ASP_WRITE_DATA					7
#define ASP_ATTENTION					8

// ASP version:
#define ASP_VERSION						"\001\000"

// Asp error codes that are visible on the wire
#define	ASP_BAD_VERSION					(USHORT)-1066
#define	ASP_BUFFER_TOO_SMALL			(USHORT)-1067
#define	ASP_NO_MORE_SESSIONS			(USHORT)-1068
#define	ASP_NO_SERVERS					(USHORT)-1069
#define	ASP_PARAM_ERROR					(USHORT)-1070
#define	ASP_SERVER_BUSY					(USHORT)-1071
#define	ASP_SIZE_ERROR					(USHORT)-1073
#define	ASP_TOO_MANY_CLIENTS			(USHORT)-1074
#define	ASP_NO_ACK						(USHORT)-1075

// Offsets into the ATP user bytes for finding various fields:
#define ASP_CMD_OFF						0
#define ASP_CMD_RESULT_OFF				0
#define ASP_SSS_OFF						0
#define ASP_SESSIONID_OFF				1
#define ASP_WSS_OFF						1
#define ASP_VERSION_OFF					2
#define ASP_ERRORCODE_OFF				2
#define ASP_ATTN_WORD_OFF				2
#define ASP_SEQUENCE_NUM_OFF			2

#define ASP_CMD_RESULT_SIZE				4

// ASP timer values:
#define ATP_MAX_INTERVAL_FOR_ASP		20		// In 100ms units
#define ATP_MIN_INTERVAL_FOR_ASP		3		// In 100ms units
#define	ATP_INITIAL_INTERVAL_FOR_ASP	3

#define ASP_TICKLE_INTERVAL				300		// In 100ms units
#define ASP_MAX_SESSION_IDLE_TIME		1200	// In 100ms units. How long before we kill it
#define ASP_SESSION_MAINTENANCE_TIMER	1200	// In 100ms units. How often the timer runs
#define ASP_SESSION_TIMER_STAGGER		50		// In 100ms units. How are different queues staggered
#define ATP_RETRIES_FOR_ASP				10		// For open, status, close;
										    	// infinite for others.
#define ASP_WRITE_DATA_SIZE				2		// WriteData command has two
												// bytes of data with it.
// Session status size:
#define ASP_MAX_STATUS_SIZE				ATP_MAX_TOTAL_RESPONSE_SIZE
#define	MAX_WRITE_REQ_SIZE				20

#define	ASP_CONN_HASH_BUCKETS			37	// Hashed by NodeAddr

#define	HASH_SRCADDR(pSrcAddr)	\
			((((pSrcAddr)->ata_Node >> 2) +	\
			  ((pSrcAddr)->ata_Network & 0xFF)) % ASP_CONN_HASH_BUCKETS)

// For resolving forward references
struct _AspAddress;
struct _AspConnxn;
struct _AspRequest;

#define	ASPAO_CLOSING			0x8000
#define	ASPAO_SIGNATURE			*(PULONG)"ASAO"

#if	DBG
#define	VALID_ASPAO(pAspAddr)	(((pAspAddr) != NULL) && \
								 ((pAspAddr)->aspao_Signature == ASPAO_SIGNATURE))
#else
#define	VALID_ASPAO(pAspAddr)	((pAspAddr) != NULL)
#endif

typedef struct _AspAddress
{
#if	DBG
	ULONG					aspao_Signature;
#endif
	LONG					aspao_RefCount;		// References to the address obj
	ULONG					aspao_Flags;
	PATP_ADDROBJ			aspao_pSlsAtpAddr;	// Sls Atp Socket
	PATP_ADDROBJ			aspao_pSssAtpAddr;	// Sss Atp Socket
	struct _AspConnxn	*	aspao_pSessions[ASP_CONN_HASH_BUCKETS];
												// List of open sessions
	PBYTE					aspao_pStatusBuf;	// Status buffer
	USHORT					aspao_StsBufSize;	// Size of the status buffer
	BYTE					aspao_NextSessionId;// Id of the next session that comes in
	BOOLEAN					aspao_EnableNewConnections;
	GENERIC_COMPLETION		aspao_CloseCompletion;
	PVOID					aspao_CloseContext;
	ASP_CLIENT_ENTRIES		aspao_ClientEntries;// Entry points from the client
	ATALK_SPIN_LOCK			aspao_Lock;
} ASP_ADDROBJ, *PASP_ADDROBJ;

#define	ASPCO_ACTIVE			0x0001
#define	ASPCO_TICKLING			0x0002
#define	ASPCO_CLEANING_UP		0x0010
#define	ASPCO_LOCAL_CLOSE		0x0020
#define	ASPCO_REMOTE_CLOSE		0x0040
#define	ASPCO_DROPPED			0x0080
#define	ASPCO_SHUTDOWN		    0x0100
#define	ASPCO_CLOSING			0x8000
#define	ASPCO_SIGNATURE			*(PULONG)"ASCO"

#if	DBG
#define	VALID_ASPCO(pAspConn)	(((pAspConn) != NULL) && \
								 ((pAspConn)->aspco_Signature == ASPCO_SIGNATURE))
#else
#define	VALID_ASPCO(pAspConn)	((pAspConn) != NULL)
#endif

typedef struct _AspConnxn
{
#if	DBG
	ULONG					aspco_Signature;
#endif
	struct _AspConnxn	*	aspco_NextOverflow;	// Overflow link for hash bucket
												// These is non NULL only when on
												// active list
	struct _AspConnxn	*	aspco_NextSession;	// Linked to active session list
	struct _AspConnxn	**	aspco_PrevSession;	// Linked to active session list

	LONG					aspco_RefCount;		// References to the conn obj
	struct _AspAddress	*	aspco_pAspAddr;		// Back pointer to the listener

	struct _AspRequest	*	aspco_pActiveReqs;	// List of requests being processed
	struct _AspRequest	*	aspco_pFreeReqs;	// Free requests
	PVOID					aspco_ConnContext;	// User context associated with this conn.
	LONG					aspco_LastContactTime;
	ATALK_ADDR				aspco_WssRemoteAddr;// This is the remote addr which
												// issues the commands/writes
	BYTE					aspco_SessionId;
	BYTE					aspco_cReqsInProcess;// Count of requests in process
	USHORT					aspco_Flags;		// ASPCO_xxx values
	USHORT					aspco_NextExpectedSeqNum;
	USHORT					aspco_TickleXactId;	// Transaction id for tickles
	RT						aspco_RT;			// Used for adaptive round-trip time calculation
	PVOID					aspco_CloseContext;
	CLIENT_CLOSE_COMPLETION	aspco_CloseCompletion;
	PVOID					aspco_AttentionContext;
	ATALK_SPIN_LOCK			aspco_Lock;
} ASP_CONNOBJ, *PASP_CONNOBJ;

#define	ASPRQ_WRTCONT			0x01		// Set if we are doing a write continue
#define	ASPRQ_WRTCONT_CANCELLED	0x10		// Set if a write continue was cancelled
#define	ASPRQ_REPLY				0x02		// Set if a reply is being processed
#define	ASPRQ_REPLY_CANCELLED	0x20		// Set if a reply is cancelled
#define	ASPRQ_REPLY_ABORTED		0x40		// Reply aborted due to a closing session

// The request gets created when an incoming request arrives.
#define	ASPRQ_SIGNATURE			*(PULONG)"ASRQ"
#if	DBG
#define	VALID_ASPRQ(pAspReq)	(((pAspReq) != NULL) && \
								 ((pAspReq)->asprq_Signature == ASPRQ_SIGNATURE))
#else
#define	VALID_ASPRQ(pAspReq)	((pAspReq) != NULL)
#endif

typedef struct _AspRequest
{
#if	DBG
	ULONG					asprq_Signature;
#endif
	struct _AspRequest	*	asprq_Next;     // Link to next request
	struct _AspConnxn	*	asprq_pAspConn;	// Owning connection
	USHORT					asprq_SeqNum;	// As generated by the wksta end
	USHORT					asprq_WCXactId;	// Transaction Id of the write
											// continue in progress
	PATP_RESP				asprq_pAtpResp;	// Used by PostResp/Cancel
	BYTE					asprq_ReqType;	// Cmd/WrtCont
	BYTE					asprq_Flags;	// Various ASPRQ_xxx values
	ATALK_ADDR				asprq_RemoteAddr;// This address is used for
											// future communications but only
											// for this request
	REQUEST					asprq_Request;	// Request parameters

	UCHAR					asprq_ReqBuf[MAX_WRITE_REQ_SIZE];
											// The request is copied here during a
											// write request
	BYTE					asprq_WrtContRespBuf[ASP_WRITE_DATA_SIZE];
} ASP_REQUEST, *PASP_REQUEST;

//	MACROS
#define	AtalkAspGetDdpAddress(pAspAddr)	\
							AtalkAtpGetDdpAddress((pAspAddr)->aspao_pSlsAtpAddr)

extern
VOID
AtalkInitAspInitialize(
	VOID
);

extern
ATALK_ERROR
AtalkAspCreateAddress(
	OUT	PASP_ADDROBJ	*		ppAspAddr
);

extern
ATALK_ERROR
AtalkAspCloseAddress(
	IN	PASP_ADDROBJ			pAspAddr,
	IN	GENERIC_COMPLETION		CompletionRoutine,
	IN	PVOID					CloseContext
);

extern
ATALK_ERROR
AtalkAspBind(
	IN	PASP_ADDROBJ			pAspAddr,
	IN	PASP_BIND_PARAMS		pBindParms,
	IN	PACTREQ					pActReq
);

NTSTATUS FASTCALL
AtalkAspWriteContinue(
	IN	PREQUEST	  pRequest
    );

ATALK_ERROR FASTCALL
AtalkAspReply(
	IN	PREQUEST				pRequest,
	IN	PBYTE					pResultCode	// Pointer to the 4-byte result
);

extern
NTSTATUS
AtalkAspSetStatus(
	IN	PASP_ADDROBJ			pAspAddr,
	IN	PUCHAR					pStatusBuf,
	IN	USHORT					StsBufSize
);

extern
NTSTATUS FASTCALL
AtalkAspListenControl(
	IN	PASP_ADDROBJ			pAspAddr,
	IN	BOOLEAN					Enable
);

extern
PASP_ADDROBJ FASTCALL
AtalkAspReferenceAddr(
	IN	PASP_ADDROBJ			pAspAddr
);

extern
VOID FASTCALL
AtalkAspDereferenceAddr(
	IN	PASP_ADDROBJ			pAspAddr
);

extern
ATALK_ERROR
AtalkAspCleanupConnection(
	IN	PASP_CONNOBJ			pAspConn
);

extern
ATALK_ERROR
AtalkAspCloseConnection(
	IN	PASP_CONNOBJ			pAspConn
);

extern
ATALK_ERROR
AtalkAspFreeConnection(
	IN	PASP_CONNOBJ			pAspConn
);

extern
NTSTATUS
AtalkAspSendAttention(
	IN	PASP_CONNOBJ			pAspConn,
	IN	USHORT					AttentionWord,
	IN	PVOID					pContext
);

extern
VOID FASTCALL
AtalkAspDereferenceConn(
	IN	PASP_CONNOBJ			pAspConn
);

// This is a list of all active connections. This is scanned by the session
// maintenance timer.
#define	NUM_ASP_CONN_LISTS		4
typedef	struct
{
	PASP_CONNOBJ	ascm_ConnList;
    TIMERLIST		ascm_SMTTimer;
} ASP_CONN_MAINT, *PASP_CONN_MAINT;
extern	ASP_CONN_MAINT	atalkAspConnMaint[NUM_ASP_CONN_LISTS];

extern	ATALK_SPIN_LOCK	atalkAspLock;

typedef	struct
{
	PATP_RESP		aps_pAtpResp;
	PAMDL			aps_pAMdl;
} ASP_POSTSTAT_CTX, *PASP_POSTSTAT_CTX;

LOCAL ATALK_ERROR FASTCALL
atalkAspPostWriteContinue(
	IN	PASP_REQUEST			pAspReq
);

LOCAL PASP_CONNOBJ
atalkAspReferenceConnBySrcAddr(
	IN	PASP_ADDROBJ			pAspAddr,
	IN	PATALK_ADDR				pSrcAddr,
	IN	BYTE					SessionId
);

LOCAL VOID
atalkAspSlsXHandler(
	IN	ATALK_ERROR				ErrorCode,
	IN	PASP_ADDROBJ			pAspAddr,		// Listener (our context)
	IN	PATP_RESP				RespCtxt,		// Used by PostResp/CancelResp
	IN	PATALK_ADDR				pSrcAddr,		// Address of requestor
	IN	USHORT					PktLen,
	IN	PBYTE					pPkt,
	IN	PBYTE					pUserBytes
);

LOCAL VOID
atalkAspSssXHandler(
	IN	ATALK_ERROR				ErrorCode,
	IN	PASP_ADDROBJ			pAspAddr,		// Listener (our context)
	IN	PATP_RESP				RespCtxt,		// Used by PostResp/CancelResp
	IN	PATALK_ADDR				pSrcAddr,		// Address of requestor
	IN	USHORT					PktLen,
	IN	PBYTE					pPkt,
	IN	PBYTE					pUserBytes
);

LOCAL VOID FASTCALL
atalkAspReplyRelease(
	IN	ATALK_ERROR				Error,
	IN	PASP_REQUEST			pAspReq
);

LOCAL VOID
atalkAspWriteContinueResp(
	IN	ATALK_ERROR				Error,
	IN	PASP_REQUEST			pAspReq,
	IN	PAMDL					pReqAMdl,
	IN	PAMDL					pRespAMdl,
	IN	USHORT					RespSize,
	IN	PBYTE					RespUserBytes
);

LOCAL VOID
atalkAspSendAttentionResp(
	IN	ATALK_ERROR				Error,
	IN	PVOID					pContext,
	IN	PAMDL					pReqAMdl,
	IN	PAMDL					pRespAMdl,
	IN	USHORT					RespSize,
	IN	PBYTE					RespUserBytes
);

LOCAL VOID
atalkAspSessionClose(
	IN	PASP_CONNOBJ			pAspConn
);

LOCAL LONG FASTCALL
atalkAspSessionMaintenanceTimer(
	IN	PTIMERLIST				pTimer,
	IN	BOOLEAN					TimerShuttingDown
);

LOCAL VOID FASTCALL
atalkAspRespComplete(
	IN	ATALK_ERROR				Error,
	IN	PASP_POSTSTAT_CTX		pStsCtx
);

LOCAL VOID
atalkAspCloseComplete(
	IN	ATALK_ERROR				Status,
	IN	PASP_ADDROBJ			pAspAddr
);

LOCAL VOID
atalkAspReturnResp(
	IN	PATP_RESP				pAtpResp,
	IN	PATALK_ADDR				pDstAddr,
	IN	BYTE					Byte0,
	IN	BYTE					Byte1,
	IN	USHORT					Word2
);

#endif	// _ASP_


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\atalk\sys\atkdrvr.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

	atkdrvr.c

Abstract:

	This module implements Appletalk Transport Provider driver interfaces
	for NT

Author:

	Jameel Hyder (jameelh@microsoft.com)
	Nikhil Kamkolkar (nikhilk@microsoft.com)

Revision History:
	19 Jun 1992		Initial Version

Notes:	Tab stop: 4
--*/

#include 	<atalk.h>
#pragma hdrstop

//	File module number for errorlogging
#define	FILENUM		ATKDRVR

NTSTATUS
DriverEntry(
	IN	PDRIVER_OBJECT	DriverObject,
	IN	PUNICODE_STRING RegistryPath
);

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(PAGEINIT, AtalkCleanup)
#pragma alloc_text(PAGE, atalkUnload)
#pragma alloc_text(PAGE, AtalkDispatchCreate)
#pragma alloc_text(PAGE, AtalkDispatchCleanup)
#pragma alloc_text(PAGE, AtalkDispatchClose)
#pragma alloc_text(PAGE, AtalkDispatchDeviceControl)
#endif

NTSTATUS
DriverEntry(
	IN	PDRIVER_OBJECT	DriverObject,
	IN	PUNICODE_STRING	RegistryPath
)
/*++

Routine Description:

	This is the initialization routine for the Windows NT Appletalk
	driver. This routine creates the device object for the Atalk
	device and performs all other driver initialization.

Arguments:

	DriverObject - Pointer to driver object created by the system.
	RegistryPath-  Path to the root of the section in the registry for this
					driver

Return Value:

	The function value is the final status from the initialization operation. If
	this is not STATUS_SUCCESS the driver will not load.

--*/
{
	NTSTATUS 		status;
	UNICODE_STRING	deviceName;
	USHORT			i, j;


	DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_INFO,
			("Appletalk DriverEntry - Entered !!!\n"));


    TdiInitialize();

    INITIALIZE_SPIN_LOCK(&AtalkStatsLock);

	INITIALIZE_SPIN_LOCK(&AtalkSktCacheLock);

	INITIALIZE_SPIN_LOCK(&ArapSpinLock);

#if DBG
    INITIALIZE_SPIN_LOCK(&AtalkDebugSpinLock);
#endif

	// Initialize event for locking/unlocking pageable sections. Set it to signalled state
	// so that the first wait is satisfied.
	KeInitializeMutex(&AtalkPgLkMutex, 0xFFFF);

	// Create the device object. (IoCreateDevice zeroes the memory
	// occupied by the object.)
	for (i = 0; i < ATALK_NO_DEVICES; i++)
	{
		RtlInitUnicodeString(&deviceName, AtalkDeviceNames[i]);
		status = IoCreateDevice(
					DriverObject,								// DriverObject
					ATALK_DEV_EXT_LEN,							// DeviceExtension
					&deviceName,								// DeviceName
					FILE_DEVICE_NETWORK,						// DeviceType
					FILE_DEVICE_SECURE_OPEN,					// DeviceCharacteristics
					(BOOLEAN)FALSE,								// Exclusive
					(PDEVICE_OBJECT *) &AtalkDeviceObject[i]);	// DeviceObject

		if (!NT_SUCCESS(status))
		{
			LOG_ERROR(EVENT_ATALK_CANT_CREATE_DEVICE, status, NULL, 0);

			//	Delete all the devices created so far, if any
			for (j = 0; j < i; j++)
			{
				IoDeleteDevice((PDEVICE_OBJECT)AtalkDeviceObject[j]);
			}

			return status;
		}

		//	Assumption:
		//	'i' will correspond to the Device type in the ATALK_DEVICE_TYPE enum
		AtalkDeviceObject[i]->Ctx.adc_DevType = (ATALK_DEV_TYPE)i;

		// Initialize the provider info and statistics structures for this device
		AtalkQueryInitProviderInfo((ATALK_DEV_TYPE)i,
									&AtalkDeviceObject[i]->Ctx.adc_ProvInfo);

#if 0
		// NOTE: Implement
		AtalkQueryInitProviderStatistics((ATALK_DEV_TYPE)i,
										 &AtalkDeviceObject[i]->Ctx.adc_ProvStats);
#endif
	}

	// Initialize the driver object for this driver's entry points.
	DriverObject->MajorFunction[IRP_MJ_CREATE]  = AtalkDispatchCreate;
	DriverObject->MajorFunction[IRP_MJ_CLEANUP] = AtalkDispatchCleanup;
	DriverObject->MajorFunction[IRP_MJ_CLOSE]   = AtalkDispatchClose;
	DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = AtalkDispatchDeviceControl;
	DriverObject->MajorFunction[IRP_MJ_INTERNAL_DEVICE_CONTROL] = AtalkDispatchInternalDeviceControl;

	DriverObject->DriverUnload = atalkUnload;

	// Get lock handles to all the conditional pageable sections
	AtalkLockInit(&AtalkPgLkSection[NBP_SECTION], AtalkNbpAction);
	AtalkLockInit(&AtalkPgLkSection[ZIP_SECTION], AtalkZipGetMyZone);
	AtalkLockInit(&AtalkPgLkSection[TDI_SECTION], AtalkTdiCleanupAddress);
	AtalkLockInit(&AtalkPgLkSection[ATP_SECTION], AtalkAtpCloseAddress);
	AtalkLockInit(&AtalkPgLkSection[ASP_SECTION], AtalkAspCloseAddress);
	AtalkLockInit(&AtalkPgLkSection[PAP_SECTION], AtalkPapCleanupAddress);
	AtalkLockInit(&AtalkPgLkSection[ASPC_SECTION], AtalkAspCCloseAddress);
	AtalkLockInit(&AtalkPgLkSection[ADSP_SECTION], AtalkAdspCleanupAddress);
	AtalkLockInit(&AtalkPgLkSection[ROUTER_SECTION], AtalkRtmpPacketInRouter);
	AtalkLockInit(&AtalkPgLkSection[INIT_SECTION], AtalkInitRtmpStartProcessingOnPort);
	AtalkLockInit(&AtalkPgLkSection[ARAP_SECTION], ArapExchangeParms);
	AtalkLockInit(&AtalkPgLkSection[PPP_SECTION], AllocPPPConn);

	AtalkLockInitIfNecessary();

	status = AtalkInitializeTransport(DriverObject, RegistryPath);

	AtalkUnlockInitIfNecessary();

	if (!NT_SUCCESS(status))
	{
#if	DBG
		// Make sure we are not unloading with any locked sections
		for (i = 0; i < LOCKABLE_SECTIONS; i++)
		{
			ASSERT (AtalkPgLkSection[i].ls_LockCount == 0);
		}
#endif
		DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
				("DriverEntry: AtalkInitializeTransport failed %lx\n",status));
	}
	else
	{
		DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_INFO,
				("DriverEntry: AtalkInitializeTransport complete %lx\n",status));
	}

	return status;
} // DriverEntry




NTSTATUS
AtalkDispatchCreate(
	IN PDEVICE_OBJECT 	DeviceObject,
	IN PIRP 			pIrp
)
/*++

Routine Description:

	This is the dispatch routine for Create functions for the Appletalk driver.

Arguments:

	DeviceObject - Pointer to device object for target device

	pIrp - Pointer to I/O request packet

Return Value:

	NTSTATUS -- Indicates whether the request was successfully queued.

--*/
{
	NTSTATUS					status;
	PIO_STACK_LOCATION 			pIrpSp;
	PFILE_FULL_EA_INFORMATION 	ea;

	INT 						createObject;
	TA_APPLETALK_ADDRESS		tdiAddress;
	CONNECTION_CONTEXT			connectionContext;
	PATALK_DEV_OBJ				atalkDeviceObject;

	UCHAR						protocolType, socketType;

	DBGPRINT(DBG_COMP_CREATE, DBG_LEVEL_INFO,
			("AtalkDispatchCreate: entered for irp %lx\n", pIrp));

	// Make sure status information is consistent every time.
	IoMarkIrpPending(pIrp);
	pIrp->IoStatus.Status = STATUS_PENDING;
	pIrp->IoStatus.Information = 0;

	pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
	atalkDeviceObject = (PATALK_DEV_OBJ)DeviceObject;

	//  Both opens must complete synchronously. It is possible we return
	//  status_pending to the system, but it will not return to the caller
	//  until the call actually completes. In our case, we block until the
	//	actions are complete. So we can be assured that we can complete the irp
	//	upon return from these calls.

	createObject = AtalkIrpGetEaCreateType(pIrp);
	ea = (PFILE_FULL_EA_INFORMATION)pIrp->AssociatedIrp.SystemBuffer;

	switch (createObject)
	{
	  case TDI_TRANSPORT_ADDRESS_FILE :
		if (ea->EaValueLength < sizeof(TA_APPLETALK_ADDRESS))
		{

			DBGPRINT(DBG_COMP_CREATE, DBG_LEVEL_ERR,
					("AtalkDispatchCreate: addr size %d\n", ea->EaValueLength));

			status = STATUS_EA_LIST_INCONSISTENT;
			break;
		}

		//  We have the AtalkTdiOpenAddress routine look at only the first
		//  address in the list of addresses by casting the passed address
		//  to TA_APPLETALK_ADDRESS.
		RtlCopyMemory(
			&tdiAddress,
			(PBYTE)(&ea->EaName[ea->EaNameLength+1]),
			sizeof(TA_APPLETALK_ADDRESS));

		//  Also, get the protocol type field for the socket
		DBGPRINT(DBG_COMP_CREATE, DBG_LEVEL_INFO,
				("AtalkDispatchCreate: Remaining File Name : %S\n",
				&pIrpSp->FileObject->FileName));

		if (!NT_SUCCESS(AtalkGetProtocolSocketType(&atalkDeviceObject->Ctx,
												   &pIrpSp->FileObject->FileName,
												   &protocolType,
												   &socketType)))
		{
			status = STATUS_NO_SUCH_DEVICE;
			break;
		}

		status = AtalkTdiOpenAddress(
					pIrp,
					pIrpSp,
					&tdiAddress,
					protocolType,
					socketType,
					&atalkDeviceObject->Ctx);

		break;

	  case TDI_CONNECTION_FILE :
		if (ea->EaValueLength < sizeof(CONNECTION_CONTEXT))
		{

			DBGPRINT(DBG_COMP_CREATE, DBG_LEVEL_ERR,
					("AtalkDispatchCreate: Context size %d\n", ea->EaValueLength));

			status = STATUS_EA_LIST_INCONSISTENT;
			break;
		}

		RtlCopyMemory(&connectionContext,
					  &ea->EaName[ea->EaNameLength+1],
					  sizeof(CONNECTION_CONTEXT));

		status = AtalkTdiOpenConnection(pIrp,
										pIrpSp,
										connectionContext,
										&atalkDeviceObject->Ctx);
		break;


	  case TDI_CONTROL_CHANNEL_FILE :
		status = AtalkTdiOpenControlChannel(pIrp,
											pIrpSp,
											&atalkDeviceObject->Ctx);
		break;

	  default:
		DBGPRINT(DBG_COMP_CREATE, DBG_LEVEL_ERR,
				("AtalkDispatchCreate: unknown EA passed!\n"));

		status = STATUS_INVALID_EA_NAME;
		break;
	}

	// Successful completion.

	DBGPRINT(DBG_COMP_CREATE, DBG_LEVEL_INFO,
			("AtalkDispatchCreate complete irp %lx status %lx\n", pIrp, status));

	if (NT_SUCCESS(status))
		INTERLOCKED_INCREMENT_LONG(&AtalkHandleCount, &AtalkStatsLock);

	if (status != STATUS_PENDING)
	{
		pIrpSp->Control &= ~SL_PENDING_RETURNED;

		ASSERT (status != STATUS_PENDING);
		TdiCompleteRequest(pIrp, status);
	}

	return status;

} // AtalkDispatchCreate




NTSTATUS
AtalkDispatchCleanup(
	IN PDEVICE_OBJECT 	DeviceObject,
	IN PIRP 			pIrp
)
/*++

Routine Description:

	This is the dispatch routine for Cleanup functions for the Appletalk driver.

Arguments:

	DeviceObject - Pointer to device object for target device
	pIrp - Pointer to I/O request packet

Return Value:

	NTSTATUS -- Indicates whether the request was successfully
				started/completed

--*/
{
	NTSTATUS				status;
	PATALK_DEV_OBJ			atalkDeviceObject;
	PIO_STACK_LOCATION 		pIrpSp;

	DBGPRINT(DBG_COMP_CLOSE, DBG_LEVEL_INFO,
			("AtalkDispatchCleanup: entered irp %lx\n", pIrp));

	// Make sure status information is consistent every time.
	IoMarkIrpPending (pIrp);
	pIrp->IoStatus.Status = STATUS_PENDING;
	pIrp->IoStatus.Information = 0;

	pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
	atalkDeviceObject = (PATALK_DEV_OBJ)DeviceObject;

	switch ((ULONG_PTR)(pIrpSp->FileObject->FsContext2) & 0xFF)
	{
	  case TDI_TRANSPORT_ADDRESS_FILE :
		status = AtalkTdiCleanupAddress(pIrp,
										pIrpSp,
										&atalkDeviceObject->Ctx);

		break;

	  case TDI_CONNECTION_FILE :
		status = AtalkTdiCleanupConnection(pIrp,
										   pIrpSp,
										   &atalkDeviceObject->Ctx);

		break;

	  case TDI_CONTROL_CHANNEL_FILE :
		status = STATUS_SUCCESS;
		break;		

	  default:
		DBGPRINT(DBG_COMP_CLOSE, DBG_LEVEL_ERR,
				("AtalkDispatchCleaup: Invalid object %s\n",
				pIrpSp->FileObject->FsContext));

		status = STATUS_INVALID_HANDLE;
		break;
	}

	DBGPRINT(DBG_COMP_CLOSE, DBG_LEVEL_INFO,
			("AtalkDispatchCleanup complete irp %lx status %lx\n", pIrp, status));

	if (status != STATUS_PENDING)
	{
		pIrpSp->Control &= ~SL_PENDING_RETURNED;

		ASSERT (status != STATUS_PENDING);
		TdiCompleteRequest(pIrp, status);
	}

	return(status);

} // AtalkDispatchCleanup




NTSTATUS
AtalkDispatchClose(
	IN PDEVICE_OBJECT 	DeviceObject,
	IN PIRP 			pIrp
)
/*++

Routine Description:

	This is the dispatch routine for Close functions for the Appletalk driver.

Arguments:

	DeviceObject - Pointer to device object for target device
	irp - Pointer to I/O request packet

Return Value:

	NTSTATUS -- Indicates whether the request was successfully queued.

--*/
{
	NTSTATUS				status;
	PIO_STACK_LOCATION 		pIrpSp;
	PATALK_DEV_OBJ			atalkDeviceObject;

	DBGPRINT(DBG_COMP_CLOSE, DBG_LEVEL_INFO,
			("AtalkDispatchClose: entered for IRP %lx\n", pIrp));

	// Make sure status information is consistent every time.
	IoMarkIrpPending(pIrp);
	pIrp->IoStatus.Status = STATUS_PENDING;
	pIrp->IoStatus.Information = 0;

	pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
	atalkDeviceObject = (PATALK_DEV_OBJ)DeviceObject;

	switch ((ULONG_PTR)(pIrpSp->FileObject->FsContext2) & 0xFF)
	{
	  case TDI_TRANSPORT_ADDRESS_FILE :
		status = AtalkTdiCloseAddress(pIrp,
									  pIrpSp,
									  &atalkDeviceObject->Ctx);

		break;

	  case TDI_CONNECTION_FILE :
		status = AtalkTdiCloseConnection(pIrp,
										 pIrpSp,
										 &atalkDeviceObject->Ctx);

		break;

	  case TDI_CONTROL_CHANNEL_FILE :
		status = AtalkTdiCloseControlChannel(pIrp,
											 pIrpSp,
											 &atalkDeviceObject->Ctx);
		break;		

	  default:
		DBGPRINT(DBG_COMP_CLOSE, DBG_LEVEL_ERR,
				("AtalkDispatchClose: Invalid object %s\n",
				pIrpSp->FileObject->FsContext));

		status = STATUS_INVALID_HANDLE;
		break;
	}

	DBGPRINT(DBG_COMP_CLOSE, DBG_LEVEL_INFO,
			("AtalkDispatchClose complete irp %lx status %lx\n", pIrp, status));

	if (status != STATUS_PENDING)
	{
		pIrpSp->Control &= ~SL_PENDING_RETURNED;

		ASSERT (status != STATUS_PENDING);
		TdiCompleteRequest(pIrp, status);
	}

	INTERLOCKED_DECREMENT_LONG(&AtalkHandleCount, &AtalkStatsLock);

	return(status);

} // AtalkDispatchClose




NTSTATUS
AtalkDispatchDeviceControl(
	IN PDEVICE_OBJECT 	DeviceObject,
	IN PIRP 			pIrp
)
/*++

Routine Description:

	This is the dispatch routine for Device Control functions for the Appletalk driver.

Arguments:

	DeviceObject - Pointer to device object for target device
	pIrp - Pointer to I/O request packet

Return Value:

	NTSTATUS -- Indicates whether the request was successfully queued.

--*/

{
	NTSTATUS				status;
	PATALK_DEV_OBJ			atalkDeviceObject;
	PIO_STACK_LOCATION 		pIrpSp;
    ULONG                   IoControlCode;

	DBGPRINT(DBG_COMP_DISPATCH, DBG_LEVEL_INFO,
			("AtalkDispatchDeviceControl: irp %lx\n", pIrp));

	pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
	atalkDeviceObject = (PATALK_DEV_OBJ)DeviceObject;


    IoControlCode = pIrpSp->Parameters.DeviceIoControl.IoControlCode;

    //
    // if it's a request from ARAP, process it here and return
    //
    if (IoControlCode > IOCTL_ARAP_START && IoControlCode < IOCTL_ARAP_END)
    {
        status = ArapProcessIoctl(pIrp);

	    return(status);
    }

	//  Do a map and call the internal device io control function.
	//  That will also perform the completion.
	status = TdiMapUserRequest(DeviceObject,
							   pIrp,
							   pIrpSp);

	if (status == STATUS_SUCCESS)
	{
		status = AtalkDispatchInternalDeviceControl(
					DeviceObject,
					pIrp);

		//
		//  AtalkDispatchInternalDeviceControl expects to complete the
		//  irp
		//
	}
	else
	{
		DBGPRINT(DBG_COMP_DISPATCH, DBG_LEVEL_WARN,
				("AtalkDispatchDeviceControl: TdiMap failed %lx\n", status));

		pIrpSp->Control &= ~SL_PENDING_RETURNED;

		ASSERT (status != STATUS_PENDING);
		TdiCompleteRequest(pIrp, status);
	}

	return(status);

} // AtalkDispatchDeviceControl




NTSTATUS
AtalkDispatchInternalDeviceControl(
	IN PDEVICE_OBJECT 	DeviceObject,
	IN PIRP 			pIrp
)
/*++

Routine Description:

	This is the dispatch routine for Internal Device Control functions
	for the Appletalk driver.

Arguments:

	DeviceObject - Pointer to device object for target device

	pIrp - Pointer to I/O request packet

Return Value:

	NTSTATUS -- Indicates whether the request was successfully queued.

--*/
{
	NTSTATUS				status;
	PIO_STACK_LOCATION 		pIrpSp;
	PATALK_DEV_OBJ			atalkDeviceObject;
	KIRQL					oldIrql;

	DBGPRINT(DBG_COMP_DISPATCH, DBG_LEVEL_INFO,
			("AtalkDispatchInternalDeviceControl entered for IRP %lx\n", pIrp));

	// Make sure status information is consistent every time.
	IoMarkIrpPending (pIrp);
	pIrp->IoStatus.Status = STATUS_PENDING;
	pIrp->IoStatus.Information = 0;

	pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
	atalkDeviceObject = (PATALK_DEV_OBJ)DeviceObject;


	IoAcquireCancelSpinLock(&oldIrql);
    if (!pIrp->Cancel)
	{
		IoSetCancelRoutine(pIrp, (PDRIVER_CANCEL)AtalkTdiCancel);
	}
    else
    {
	    IoReleaseCancelSpinLock(oldIrql);
        status = STATUS_CANCELLED;
        TdiCompleteRequest(pIrp, status);
        return(status);
    }

	IoReleaseCancelSpinLock(oldIrql);

	//  Branch to the appropriate request handler.
	switch (pIrpSp->MinorFunction)
	{
	  case TDI_ACCEPT:
		status = AtalkTdiAccept(pIrp,
								pIrpSp,
								&atalkDeviceObject->Ctx);
		break;

	  case TDI_RECEIVE_DATAGRAM:
		status = AtalkTdiReceiveDgram(pIrp,
									  pIrpSp,
									  &atalkDeviceObject->Ctx);
		break;

	  case TDI_SEND_DATAGRAM:
		status = AtalkTdiSendDgram(pIrp,
								   pIrpSp,
								   &atalkDeviceObject->Ctx);
		break;

	  case TDI_SET_EVENT_HANDLER:
		status = AtalkTdiSetEventHandler(pIrp,
										 pIrpSp,
										 &atalkDeviceObject->Ctx);
		break;

	  case TDI_RECEIVE:
		status = AtalkTdiReceive(pIrp,
								 pIrpSp,
								 &atalkDeviceObject->Ctx);
		break;

	  case TDI_SEND:
		status = AtalkTdiSend(pIrp,
							  pIrpSp,
							  &atalkDeviceObject->Ctx);
		break;

	  case TDI_ACTION:
		ASSERT(pIrp->MdlAddress != NULL);
		status = AtalkTdiAction(pIrp,
								pIrpSp,
								&atalkDeviceObject->Ctx);
		break;

	  case TDI_ASSOCIATE_ADDRESS:
		status = AtalkTdiAssociateAddress(pIrp,
										  pIrpSp,
										  &atalkDeviceObject->Ctx);
		break;

	  case TDI_DISASSOCIATE_ADDRESS:
		status = AtalkTdiDisassociateAddress(pIrp,
											 pIrpSp,
											 &atalkDeviceObject->Ctx);
		break;

	  case TDI_CONNECT:
		status = AtalkTdiConnect(pIrp,
								 pIrpSp,
								 &atalkDeviceObject->Ctx);
		break;

	  case TDI_DISCONNECT:
		status = AtalkTdiDisconnect(pIrp,
									pIrpSp,
									&atalkDeviceObject->Ctx);
		break;

	  case TDI_LISTEN:
		status = AtalkTdiListen(pIrp,
								pIrpSp,
								&atalkDeviceObject->Ctx);
		break;

	  case TDI_QUERY_INFORMATION:
		ASSERT(pIrp->MdlAddress != NULL);
		status = AtalkTdiQueryInformation(pIrp,
										  pIrpSp,
										  &atalkDeviceObject->Ctx);
		break;

	  case TDI_SET_INFORMATION:
		status = AtalkTdiSetInformation(pIrp,
										pIrpSp,
										&atalkDeviceObject->Ctx);
		break;

	  default:
		// Something we don't know about was submitted.
		DBGPRINT(DBG_COMP_DISPATCH, DBG_LEVEL_ERR,
				("AtalkDispatchInternal: fnct %lx\n", pIrpSp->MinorFunction));

		status = STATUS_INVALID_DEVICE_REQUEST;
	}

	DBGPRINT(DBG_COMP_DISPATCH, DBG_LEVEL_INFO,
			("AtalkDispatchInternal complete irp %lx status %lx\n", pIrp, status));

	// Return the immediate status code to the caller.
	if (status != STATUS_PENDING)
	{
		pIrpSp->Control &= ~SL_PENDING_RETURNED;

		//  Complete the request, this will also dereference it.
		pIrp->CancelRoutine = NULL;
		ASSERT (status != STATUS_PENDING);
		TdiCompleteRequest(pIrp, status);
	}

	return status;
} // AtalkDispatchInternalDeviceControl




VOID
atalkUnload(
	IN PDRIVER_OBJECT DriverObject
)
/*++

Routine Description:

	This is the unload routine for the Appletalk driver.

	NOTE: Unload will not be called until all the handles have been
		  closed successfully. We just shutdown all the ports, and do
		  misc. cleanup.


Arguments:

	DriverObject - Pointer to driver object for this driver.

Return Value:

	None.

--*/
{
	UNREFERENCED_PARAMETER (DriverObject);

    AtalkBindnUnloadStates |= ATALK_UNLOADING;

    // if we hit that timing window where binding or PnP event is going on,
    // sleep (for a second each time) until that action completes
    while (AtalkBindnUnloadStates & (ATALK_BINDING | ATALK_PNP_IN_PROGRESS))
    {
        AtalkSleep(1000);
    }

	AtalkLockInitIfNecessary();

	AtalkCleanup();

	AtalkUnlockInitIfNecessary();

#if	DBG
	{
		int i;

		// Make sure we are not unloading with any locked sections
		for (i = 0; i < LOCKABLE_SECTIONS; i++)
		{
			ASSERT (AtalkPgLkSection[i].ls_LockCount == 0);
		}
	}

	DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
		("Appletalk driver unloaded\n"));

#endif
} // atalkUnload



VOID
AtalkCleanup(
	VOID
	)
/*++

Routine Description:

	This is synchronous and will block until Unload Completes


Arguments:

	None.

Return Value:

	None.

--*/
{
	PPORT_DESCRIPTOR	pPortDesc;
	LONG				i;
	KIRQL				OldIrql;


	//	Stop the timer subsystem
	AtalkTimerFlushAndStop();

	ASSERT(KeGetCurrentIrql() == LOW_LEVEL);

	ACQUIRE_SPIN_LOCK(&AtalkPortLock, &OldIrql);

	//	Shut down all ports
	while ((pPortDesc = AtalkPortList) != NULL)
	{
		RELEASE_SPIN_LOCK(&AtalkPortLock, OldIrql);

		AtalkPortShutdown(pPortDesc);

		ACQUIRE_SPIN_LOCK(&AtalkPortLock, &OldIrql);
	}

	RELEASE_SPIN_LOCK(&AtalkPortLock, OldIrql);

	if (AtalkRegPath.Buffer != NULL)
	{
		AtalkFreeMemory(AtalkRegPath.Buffer);
	}

	if (AtalkDefaultPortName.Buffer != NULL)
	{
		AtalkFreeMemory(AtalkDefaultPortName.Buffer);
	}

	for (i = 0; i < ATALK_NO_DEVICES; i++)
	{
		//
		//	Delete all the devices created
		//
		IoDeleteDevice((PDEVICE_OBJECT)AtalkDeviceObject[i]);
	}

	// Deinitialize the Block Package
	AtalkDeInitMemorySystem();

	// Check if routing is on, if so unlock the router code now
	if (AtalkRouter)
		AtalkUnlockRouterIfNecessary();

	// Free the rtmp tables
	AtalkRtmpInit(FALSE);

	// Free the zip tables
	AtalkZipInit(FALSE);

	//	Release ndis resources (buffer/packet pools)
	AtalkNdisReleaseResources();

	//	Deregister the protocol from ndis if handle is non-null
	if (AtalkNdisProtocolHandle != (NDIS_HANDLE)NULL)
		AtalkNdisDeregisterProtocol();

	ASSERT(AtalkStatistics.stat_CurAllocSize == 0);

    ASSERT(AtalkDbgMdlsAlloced == 0);
    ASSERT(AtalkDbgIrpsAlloced == 0);

#ifdef	PROFILING
	ASSERT(AtalkStatistics.stat_CurAllocCount == 0);
	ASSERT(AtalkStatistics.stat_CurMdlCount == 0);
#endif
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\atalk\sys\atkdrvr.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

	atkdrvr.h

Abstract:

	This module contains the driver related information.

Author:

	Jameel Hyder (jameelh@microsoft.com)
	Nikhil Kamkolkar (nikhilk@microsoft.com)

Revision History:
	19 Jun 1992		Initial Version

Notes:	Tab stop: 4
--*/

#ifndef	_ATKDRVR_
#define	_ATKDRVR_

//  The following are the types of devices the Atalk driver will open
//
//  WARNING:
//  Note that the ordering of the below is very important in
//  ATKDRVR.C's DriverEntry routine, where it is assumed that the order
//  of the device names in their array corresponds to the order of types here

#define  ATALK_NO_DEVICES   6

typedef enum
{
   ATALK_DEV_DDP = 0,
   ATALK_DEV_ADSP,
   ATALK_DEV_ASP,
   ATALK_DEV_PAP,
   ATALK_DEV_ARAP,
   ATALK_DEV_ASPC,

   //   The following device type is used only for the tdi action dispatch.
   //   It *should not* be included in the ATALK_NODEVICES count.
   ATALK_DEV_ANY

} ATALK_DEV_TYPE;

//  Atalk Device Context
typedef struct _ATALK_DEV_CTX
{

   ATALK_DEV_TYPE 		adc_DevType;

   //   Provider info and provider statistics.
   TDI_PROVIDER_INFO    	adc_ProvInfo;
   TDI_PROVIDER_STATISTICS  adc_ProvStats;

} ATALK_DEV_CTX, *PATALK_DEV_CTX;


//  Atalk device object
typedef struct _ATALK_DEV_OBJ
{

   DEVICE_OBJECT 		DevObj;
   ATALK_DEV_CTX	 	Ctx;

} ATALK_DEV_OBJ, *PATALK_DEV_OBJ;

#define ATALK_DEV_EXT_LEN \
			(sizeof(ATALK_DEV_OBJ) - sizeof(DEVICE_OBJECT))


//	Define the type for the TDI Control Channel object.
#define		TDI_CONTROL_CHANNEL_FILE	3


//
// The address of the atalk device objects are kept
// in global storage. These are the device names the driver
// will create
//
// IMPORTANT:
// There is a strong connection between the names listed here and the
// ATALK_DEVICE_TYPE enum. They must correspond exactly.
//

extern	PWCHAR				AtalkDeviceNames[];

extern	PATALK_DEV_OBJ  	AtalkDeviceObject[ATALK_NO_DEVICES];

#define    ATALK_UNLOADING          0x000000001
#define    ATALK_BINDING	        0x000000002
#define    ATALK_PNP_IN_PROGRESS    0x000000004

extern	DWORD				AtalkBindnUnloadStates;
extern  PVOID               TdiAddressChangeRegHandle;


#if DBG
extern	ATALK_SPIN_LOCK		AtalkDebugSpinLock;

extern  DWORD               AtalkDbgMdlsAlloced;
extern  DWORD               AtalkDbgIrpsAlloced;

#define ATALK_DBG_INC_COUNT(_Val)  AtalkDbgIncCount(&_Val)
#define ATALK_DBG_DEC_COUNT(_Val)  AtalkDbgDecCount(&_Val)
#else
#define ATALK_DBG_INC_COUNT(_Val)
#define ATALK_DBG_DEC_COUNT(_Val)
#endif


NTSTATUS
AtalkDispatchInternalDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp);

VOID
AtalkCleanup(
    VOID);

//  LOCAL Function prototypes

VOID
atalkUnload(
    IN PDRIVER_OBJECT DriverObject);

NTSTATUS
AtalkDispatchCreate(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp);

NTSTATUS
AtalkDispatchCleanup(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp);

NTSTATUS
AtalkDispatchClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp);

NTSTATUS
AtalkDispatchDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp);

#endif	// _ATKDRVR_


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\atalk\sys\atkerror.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

	atkerror.h

Abstract:

	This module contains some error definitions for appletalk.

Author:

	Jameel Hyder (jameelh@microsoft.com)
	Nikhil Kamkolkar (nikhilk@microsoft.com)

Revision History:
	19 Jun 1992		Initial Version

Notes:	Tab stop: 4
--*/

#ifndef	_ATKERROR_
#define	_ATKERROR_

//	Define the modules names for Appletalk - use the high bits.
#define		ATKINIT				0x00010000
#define		ATKDRVR				0x00020000
#define		ATKNDIS				0x00030000
#define		ATKTDI				0x00040000
#define		ATKACT				0x00050000
#define		ATKUTILS			0x00060000
#define		ATKTIMER			0x00070000
#define		ATKMEM				0x00080000
#define		ATKERROR			0x00090000

#define		ROUTER				0x000A0000
#define		SOCKET				0x000B0000
#define		PORTS				0x000C0000
#define		NODE				0x000D0000
#define		AARP				0x000E0000
#define		AEP					0x000F0000
#define		DDP					0x00100000
#define		RTMP				0x00200000
#define		NBP					0x00300000
#define		ZIP					0x00400000
#define		ATP					0x00500000
#define		ASP					0x00600000
#define		PAP					0x00700000
#define		ADSP				0x00800000
#define		ATKIND				0x00900000
#define		ASPC				0x00A00000
#define		DATAX				0x00B00000
#define     RAS                 0x00C00000
#define     ARAP                0x00D00000
#define     ARAPNDIS            0x00E00000
#define     ARAPUTIL            0x00F00000
#define     ARAPATK             0x01000000
#define     ARAPDBG             0x02000000
#define     ATKPNP              0x03000000
#define     PPP                 0x04000000


// DEBUGGING SUPPORT:
// Debugging messages are provided per-subsystem defined here, and within
// the subsystems, there are 4 levels of messages.
//
// The four levels of debug messages are:
//
// INFO:		Informational messages, eg., entry exit in routines
// WARN:		Something went wrong, but its not an error, eg., packet was not ours
// ERR:		Error situations, but we can still run if a retry happens
// FATAL:		In this situation, the driver is not operational

// These give the ref/deref dbgprints if DBG is defined. LOTS of output.
// Defined as a hierarchy of the stack objects.
#define	DBG_LEVEL_REFDDP		0x2000
#define	DBG_LEVEL_REFNODE		0x3000
#define	DBG_LEVEL_REFPORT		0x4000
#define	DBG_LEVEL_REFATP		0x4100
#define	DBG_LEVEL_REFPAPADDR	0x4200
#define	DBG_LEVEL_REFPAPCONN	0x4300
#define	DBG_LEVEL_REFASPADDR	0x4400
#define	DBG_LEVEL_REFASPCONN	0x4500

#define	DBG_LEVEL_INFO			0x5000
#define	DBG_LEVEL_WARN			0x6000
#define	DBG_LEVEL_ERR			0x7000
#define	DBG_LEVEL_FATAL			0x8000

// SUBSYSTEMS
#define DBG_COMP_INIT			0x00000001
#define DBG_COMP_DISPATCH		0x00000002
#define DBG_COMP_CREATE			0x00000004
#define DBG_COMP_CLOSE			0x00000008
#define DBG_COMP_ACTION			0x00000010
#define DBG_COMP_ADDROBJ		0x00000020
#define DBG_COMP_CONNOBJ		0x00000040
#define DBG_COMP_CHANOBJ		0x00000080
#define DBG_COMP_RESOURCES		0x00000100
#define DBG_COMP_UNLOAD			0x00000200

#define	DBG_COMP_NODE			0x00000400
#define	DBG_COMP_AARP			0x00000800

#define	DBG_COMP_AEP			0x00001000
#define DBG_COMP_DDP			0x00002000
#define DBG_COMP_ATP			0x00004000
#define DBG_COMP_ADSP			0x00008000
#define DBG_COMP_ZIP			0x00010000
#define DBG_COMP_NBP			0x00020000
#define DBG_COMP_PAP			0x00040000
#define DBG_COMP_ASP			0x00080000
#define DBG_COMP_RTMP			0x00100000
#define	DBG_COMP_ROUTER			0x00200000

#define	DBG_COMP_DUMP			0x00400000
#define DBG_COMP_REFCOUNTS		0x00800000
#define DBG_COMP_SYSTEM			0x01000000
#define DBG_COMP_CRITSEC		0x02000000
#define DBG_COMP_UTILS			0x04000000

#define DBG_COMP_NDISSEND		0x08000000
#define DBG_COMP_NDISRECV		0x10000000
#define DBG_COMP_NDISREQ		0x20000000
#define DBG_COMP_TDI			0x40000000
#define DBG_COMP_RAS            0x80000000

#define DBG_MOST			   (DBG_COMP_INIT			|	\
								DBG_COMP_DISPATCH		|	\
								DBG_COMP_CREATE			|	\
								DBG_COMP_CLOSE			|	\
								DBG_COMP_ACTION			|	\
								DBG_COMP_ADDROBJ		|	\
								DBG_COMP_CONNOBJ		|	\
								DBG_COMP_CHANOBJ		|	\
								DBG_COMP_RESOURCES		|	\
								DBG_COMP_UNLOAD			|	\
								DBG_COMP_NODE			|	\
								DBG_COMP_AARP			|	\
								DBG_COMP_AEP			|	\
								DBG_COMP_DDP			|	\
								DBG_COMP_ATP			|	\
								DBG_COMP_ADSP			|	\
								DBG_COMP_ZIP			|	\
								DBG_COMP_NBP			|	\
								DBG_COMP_PAP			|	\
								DBG_COMP_ASP			|	\
								DBG_COMP_RTMP			|	\
								DBG_COMP_ROUTER			|	\
								DBG_COMP_DUMP			|	\
								DBG_COMP_UTILS			|	\
								DBG_COMP_REFCOUNTS		|	\
								DBG_COMP_SYSTEM			|	\
								DBG_COMP_TDI            |	\
                                DBG_COMP_RAS)

// past here are debug things that are really frequent; don't use them
// unless you want LOTS of output


#define DBG_ALL			 		(DBG_MOST | DBG_COMP_CRITSEC)


// More debugging support. These values define the dumping components.
// There are a max of 32 such components that can be defined. Each of
// these are associated with a dump routine. It one is specified and
// enabled, periodically it is called. It is upto that component to
// decide what it wants to do

#define	DBG_DUMP_DEF_INTERVAL			300			// In 100ms units

#define	DBG_DUMP_PORTINFO				0x00000001
#define	DBG_DUMP_AMT					0x00000002
#define	DBG_DUMP_ZONETABLE				0x00000004
#define	DBG_DUMP_RTES					0x00000008
#define	DBG_DUMP_TIMERS					0x00000010
#define	DBG_DUMP_ATPINFO				0x00000020
#define	DBG_DUMP_ASPSESSIONS			0x00000040
#define	DBG_DUMP_PAPJOBS				0x00000080

typedef	LONG	ATALK_ERROR, *PATALK_ERROR;

#define	ATALK_SUCCESS(error)			((ATALK_ERROR)(error) >= 0)

#define	ATALK_NO_ERROR					0x00000000
#define	ATALK_PENDING					0x00000001

#define	ATALK_RESR_MEM					-1000

#define	ATALK_INVALID_PARAMETER			-1050
#define	ATALK_BUFFER_TOO_SMALL			-1051
#define	ATALK_BUFFER_TOO_BIG			-1052
#define	ATALK_ALREADY_ASSOCIATED		-1053
#define	ATALK_CANNOT_DISSOCIATE			-1054
#define	ATALK_CANNOT_CANCEL				-1055
#define	ATALK_INVALID_REQUEST			-1056
#define	ATALK_REQUEST_NOT_ACCEPTED		-1057
#define	ATALK_DEVICE_NOT_READY			-1058
#define	ATALK_INVALID_CONNECTION		-1059
#define	ATALK_INVALID_ADDRESS			-1060
#define	ATALK_TOO_MANY_COMMANDS			-1061
#define	ATALK_CONNECTION_TIMEOUT		-1062
#define	ATALK_REMOTE_CLOSE				-1063
#define	ATALK_LOCAL_CLOSE				-1064
#define	ATALK_BUFFER_INVALID_SIZE		-1065
#define	ATALK_REQUEST_CANCELLED			-1066
#define	ATALK_NEW_SOCKET				-1067
#define	ATALK_TIMEOUT					-1068
#define	ATALK_SHARING_VIOLATION			-1069
#define	ATALK_INVALID_PKT				-1070
#define	ATALK_DUP_PKT					-1071

#define	ATALK_INIT_BINDFAIL				-1100
#define	ATALK_INIT_REGPROTO_FAIL		-1101
#define	ATALK_INIT_MEDIA_INVALID		-1102

#define	ATALK_PORT_INVALID				-1200
#define	ATALK_PORT_CLOSING				-1201

#define	ATALK_NODE_FINDING				-1300
#define	ATALK_NODE_NONEXISTENT			-1301
#define	ATALK_NODE_CLOSING				-1302
#define	ATALK_NODE_NOMORE				-1303

#define	ATALK_SOCKET_INVALID			-1400
#define	ATALK_SOCKET_NODEFULL			-1401
#define	ATALK_SOCKET_EXISTS				-1402
#define	ATALK_SOCKET_CLOSED				-1403

#define	ATALK_DDP_CLOSING				-1500
#define	ATALK_DDP_NOTFOUND				-1501
#define	ATALK_DDP_INVALID_LEN			-1502
#define	ATALK_DDP_SHORT_HDR				-1503
#define	ATALK_DDP_INVALID_SRC			-1504
#define	ATALK_DDP_INVALID_DEST			-1505
#define	ATALK_DDP_INVALID_ADDR			-1506
#define	ATALK_DDP_INVALID_PROTO	 		-1507
#define	ATALK_DDP_INVALID_PARAM	 		-1508
#define	ATALK_DDP_NO_ROUTER				-1509
#define	ATALK_DDP_NO_AMT_ENTRY			-1510
#define	ATALK_DDP_NO_BRC_ENTRY			-1511
#define	ATALK_DDP_PKT_DROPPED			-1512

#define	ATALK_ATP_NOT_FOUND				-1600
#define	ATALK_ATP_INVALID_PKT			-1601
#define	ATALK_ATP_INVALID_REQ			-1602
#define	ATALK_ATP_REQ_CLOSING			-1603
#define	ATALK_ATP_RESP_CLOSING			-1604
#define	ATALK_ATP_INVALID_RETRYCNT		-1605
#define	ATALK_ATP_INVALID_TIMERVAL		-1606
#define	ATALK_ATP_INVALID_RELINT		-1607
#define	ATALK_ATP_CLOSING				-1608
#define	ATALK_ATP_RESP_TOOMANY			-1609
#define	ATALK_ATP_NO_MATCH_REQ			-1610
#define	ATALK_ATP_NO_GET_REQ			-1611
#define	ATALK_ATP_RESP_TIMEOUT			-1612
#define	ATALK_ATP_RESP_CANCELLED		-1613
#define	ATALK_ATP_REQ_CANCELLED			-1614
#define	ATALK_ATP_GET_REQ_CANCELLED		-1615
#define	ATALK_ATP_NO_VALID_RESP			-1616
#define	ATALK_ATP_REQ_TIMEOUT			-1617

#define	ATALK_ASP_INVALID_REQUEST		-1700

#define	ATALK_PAP_LOCAL_CLOSE			-1800
#define	ATALK_PAP_REMOTE_CLOSE			-1801
#define	ATALK_PAP_INVALID_REQUEST		-1802
#define	ATALK_PAP_TOO_MANY_READS		-1803
#define	ATALK_PAP_TOO_MANY_WRITES		-1804
#define	ATALK_PAP_CONN_NOT_ACTIVE		-1805
#define	ATALK_PAP_ADDR_CLOSING			-1806
#define	ATALK_PAP_CONN_CLOSING			-1807
#define	ATALK_PAP_CONN_NOT_FOUND		-1808
#define	ATALK_PAP_INVALID_USERBYTES		-1809
#define	ATALK_PAP_SERVER_BUSY			-1810
#define	ATALK_PAP_INVALID_STATUS		-1811
#define	ATALK_PAP_PARTIAL_RECEIVE		-1812
#define	ATALK_PAP_CONN_RESET			-1813

#define	ATALK_ADSP_INVALID_REQUEST		-1900
#define	ATALK_ADSP_CONN_NOT_ACTIVE		-1903
#define	ATALK_ADSP_ADDR_CLOSING			-1904
#define	ATALK_ADSP_CONN_CLOSING			-1905
#define	ATALK_ADSP_CONN_NOT_FOUND		-1906
#define	ATALK_ADSP_CONN_RESET			-1907
#define	ATALK_ADSP_SERVER_BUSY			-1908

#define	ATALK_ADSP_PARTIAL_RECEIVE		-1912
#define	ATALK_ADSP_EXPED_RECEIVE		-1913
#define	ATALK_ADSP_PAREXPED_RECEIVE		-1914
#define	ATALK_ADSP_REMOTE_RESR			-1915

#define	ATALK_TIMER_CANCEL_FAIL			-2000
#define	ATALK_TIMER_SCHEDULE_FAIL		-2001

#define	ATALK_ASPC_LOCAL_CLOSE			-2100
#define	ATALK_ASPC_REMOTE_CLOSE			-2101
#define	ATALK_ASPC_INVALID_REQUEST		-2102
#define	ATALK_ASPC_TOO_MANY_READS		-2103
#define	ATALK_ASPC_TOO_MANY_WRITES		-2104
#define	ATALK_ASPC_CONN_NOT_ACTIVE		-2105
#define	ATALK_ASPC_ADDR_CLOSING			-2106
#define	ATALK_ASPC_CONN_CLOSING			-2107
#define	ATALK_ASPC_CONN_NOT_FOUND		-2108
#define	ATALK_ASPC_INVALID_USERBYTES	-2109
#define	ATALK_ASPC_SERVER_BUSY			-2110
#define	ATALK_ASPC_INVALID_STATUS		-2111
#define	ATALK_ASPC_PARTIAL_RECEIVE		-2112
#define	ATALK_ASPC_CONN_RESET			-2113

#define	ATALK_FAILURE					-5000

//	This defines the number of times an error has to happen consecutively before
//	it gets logged again.
#define		ERROR_CONSEQ_FREQ			200
#define		ERROR_CONSEQ_TIME			18000	// 30 minutes in 100ns intervals


#if	DBG
extern	ULONG		AtalkDebugDump;
extern	LONG		AtalkDumpInterval;
extern	ULONG		AtalkDebugLevel;
extern	ULONG		AtalkDebugSystems;
extern	TIMERLIST	AtalkDumpTimerList;
typedef VOID	(*DUMP_ROUTINE)(VOID);

extern
LONG FASTCALL
AtalkDumpComponents(
	IN	PTIMERLIST	Context,
	IN	BOOLEAN		TimerShuttingDown
);

extern
VOID
AtalkAmtDumpTable(
	VOID
);

extern
VOID
AtalkPortDumpInfo(
	VOID
);

extern
VOID
AtalkRtmpDumpTable(
	VOID
);

extern
VOID
AtalkTimerDumpList(
	VOID
);

extern
VOID
AtalkZoneDumpTable(
	VOID
);

extern
VOID
AtalkAspDumpSessions(
	VOID
);

#endif


#define LOG_ERROR(AtalkError, NtStatus, RawData, RawDataLen)				\
		LOG_ERRORONPORT(NULL, AtalkError, NtStatus, RawData, RawDataLen)

#define RES_LOG_ERROR()														\
		LOG_ERROR(EVENT_ATALK_RESOURCES, STATUS_INSUFFICIENT_RESOURCES, NULL, 0)

#define LOG_ERRORONPORT(Port, AtalkError, NtStatus, RawData, RawDataLen)	\
	{																		\
		if (!NT_SUCCESS(NtStatus))											\
		{																	\
			DBGPRINT(DBG_ALL, DBG_LEVEL_ERR,								\
					("LOG_ERROR: File %s Line %ld Event %lx Error %lx\n",	\
					__FILE__, __LINE__, AtalkError, NtStatus));			    \
		}																	\
		AtalkWriteErrorLogEntry(Port,										\
								AtalkError,									\
								(__LINE__ | FILENUM),  					    \
								NtStatus,									\
								RawData,									\
								RawDataLen);								\
	}

#if DBG
// ERROR and above ignore the Component part
#define DBGPRINT(Component, Level, Fmt)										\
		{																	\
			if ((Level >= AtalkDebugLevel) &&								\
				((AtalkDebugSystems & Component) == Component))				\
			{																\
				DbgPrint("***ATALK*** ");									\
				DbgPrint Fmt;												\
			}																\
		}

#define DBGPRINTSKIPHDR(Component, Level, Fmt)								\
		{																	\
			if ((Level >= AtalkDebugLevel) &&								\
				((AtalkDebugSystems & Component) == Component))				\
			{																\
				DbgPrint Fmt;												\
			}																\
		}

#define DBGBRK(Level)														\
		{																	\
			if (Level >= AtalkDebugLevel)									\
				DbgBreakPoint();											\
		}

#define	TMPLOGERR()		DBGPRINT(DBG_MOST, DBG_LEVEL_ERR,					\
								("TempErrLog: %s, Line %ld\n",				\
								__FILE__, __LINE__));

#else
#define DBGPRINTSKIPHDR(Component, Level, Fmt)
#define DBGPRINT(Component, Level, Fmt)
#define DBGBRK(Level)
#define	TMPLOGERR()
#endif

extern
VOID
AtalkWriteErrorLogEntry(
	IN	struct _PORT_DESCRIPTOR	*	pPortDesc,
	IN	NTSTATUS 					UniqueErrorCode,
	IN	ULONG						UniqueErrorValue,
	IN	NTSTATUS 					NtStatusCode,
	IN	PVOID						RawDataBuf OPTIONAL,
	IN	LONG	 					RawDataLen);

extern
VOID
AtalkLogBadPacket(
	IN	struct _PORT_DESCRIPTOR	*	pPortDesc,
	IN	PATALK_ADDR					pSrcAddr,
	IN	PATALK_ADDR					pDstAddr	OPTIONAL,
	IN	PBYTE						pPkt,
	IN	USHORT	 					PktLen);

extern
ATALK_ERROR FASTCALL
AtalkNdisToAtalkError(
	IN	NDIS_STATUS					Error);

extern
NTSTATUS FASTCALL
AtalkErrorToNtStatus(
	IN	ATALK_ERROR					AtalkError);

#endif	// _ATKERROR_


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\atalk\sys\atkind.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

	atkind.c

Abstract:

	This module contains the Appletalk Internal Indication support.

Author:

	Nikhil Kamkolkar (nikhilk@microsoft.com)
	Jameel Hyder (jameelh@microsoft.com)

Revision History:
	22	Oct 1993		Initial Version

Notes:	Tab stop: 4
--*/

#include <atalk.h>
#pragma hdrstop
#define	FILENUM		ATKIND


ATALK_ERROR
AtalkIndAtpPkt(
	IN		PPORT_DESCRIPTOR	pPortDesc,
	IN		PBYTE				pLookahead,
	IN		USHORT				PktLen,
	IN	OUT	PUINT				pXferOffset,
	IN		PBYTE				pLinkHdr,
	IN		BOOLEAN				ShortDdpHdr,
	OUT		PBYTE				pSubType,
	OUT		PBYTE			* 	ppPacket,
	OUT		PNDIS_PACKET	*	pNdisPkt
	)
/*++

Routine Description:

	This routine clumps together DDP and ATP packet in functionality for
	optimizing response packet reception.

Arguments:


Return Value:


--*/
{
	USHORT			dgramLen, hopCnt;
	ATALK_ADDR		destAddr, srcAddr;
	PBYTE			pAtpHdr, pDdpPkt;

	//	Only for localtalk
	BYTE			alapSrcNode=0;
	BYTE			alapDestNode=0;
	NDIS_STATUS		ndisStatus;
	PNDIS_PACKET	ndisPkt;
	PNDIS_BUFFER	ndisBuffer=NULL;
	USHORT			atpDataSize, DataSize;
	USHORT			seqNum, tid, startOffset;
	BYTE			controlInfo, function, eomFlag;
	BYTE			RespType;
	PPROTOCOL_RESD  protocolResd;		// Protocolresd field in ndisPkt

	PATP_ADDROBJ	pAtpAddrObj;
	PATP_REQ		pAtpReq;

	BOOLEAN			refAtpAddr 	= FALSE, refAtpReq = FALSE;
	BOOLEAN			Deref = FALSE;
	ATALK_ERROR		error = ATALK_NO_ERROR;
#ifdef	PROFILING
	LARGE_INTEGER	TimeS, TimeE, TimeD;

	TimeS = KeQueryPerformanceCounter(NULL);
#endif

	do
	{
#if 0	// Receive indication has already verified this !!
		//	If we dont have atleast the ddp header and atp header, we
		//	cant figure much out.
		if (LookaheadLen < ((ShortDdpHdr ? SDDP_HDR_LEN : LDDP_HDR_LEN) + ATP_HEADER_SIZE))
		{
			error 	= ATALK_FAILURE;
			break;
		}

		if (PktLen > (MAX_DGRAM_SIZE + LDDP_HDR_LEN))
		{
			error	= ATALK_INVALID_PKT;
			break;
		}
#endif
		//	Short and long header formats have the length in the same place,
		pDdpPkt	 = pLookahead;
		dgramLen = DDP_GET_LEN(pDdpPkt);
		hopCnt	 = DDP_GET_HOP_COUNT(pDdpPkt);

		//	Is the packet too long?
		if ((hopCnt > RTMP_MAX_HOPS) || (dgramLen > PktLen))
		{
			error	= ATALK_INVALID_PKT;
			break;
		}

		switch (pPortDesc->pd_NdisPortType)
		{
		  case NdisMedium802_5:
		  case NdisMedium802_3:
		  case NdisMediumFddi:

			//	Check the length.
			if ((dgramLen < LDDP_HDR_LEN) ||
				(dgramLen > (MAX_DGRAM_SIZE + LDDP_HDR_LEN)))
			{
				error	= ATALK_INVALID_PKT;
				break;
			}

			pAtpHdr		= pDdpPkt + LDDP_HDR_LEN;
			atpDataSize	= dgramLen 	- (LDDP_HDR_LEN + ATP_HEADER_SIZE);
			break;
	
		  case NdisMediumLocalTalk:
	
			if (ShortDdpHdr)
			{
				//	Short DDP header! If we are not the default port, dont indicate
				//	packet, as we shouldn't be routing it to the default port, on
				//	which all our cached sockets reside.
				if (!DEF_PORT(pPortDesc))
				{
					error = ATALK_FAILURE;
					break;
				}
	
				if ((alapDestNode = *(pLinkHdr + ALAP_DEST_OFFSET)) == ATALK_BROADCAST_NODE)
				{
					error = ATALK_FAILURE;
					break;
				}
				else if (alapDestNode != NODE_ON_NONEXTPORT(pPortDesc))
				{
					error = ATALK_FAILURE;
					break;
				}

				alapSrcNode = *(pLinkHdr + ALAP_SRC_OFFSET);

				if ((dgramLen < SDDP_HDR_LEN) ||
					(dgramLen > MAX_DGRAM_SIZE + SDDP_HDR_LEN))
				{
					error = ATALK_INVALID_PKT;
					break;
				}
	
				pAtpHdr	= pDdpPkt 	+ SDDP_HDR_LEN;
				atpDataSize	= dgramLen 	- (SDDP_HDR_LEN + ATP_HEADER_SIZE);
			}
			else
			{
				pAtpHdr	= pDdpPkt + LDDP_HDR_LEN;
				atpDataSize	= dgramLen 	- (LDDP_HDR_LEN + ATP_HEADER_SIZE);
			}
			break;
	
		  default:
			KeBugCheck(0);
			break;
		}

		if (!ATALK_SUCCESS(error))
		{
			break;
		}

		DataSize	= atpDataSize + ATP_HEADER_SIZE;
		pDdpPkt += 2;
		if (ShortDdpHdr)
		{
			destAddr.ata_Node  	= alapDestNode;
			srcAddr.ata_Network = destAddr.ata_Network = NET_ON_NONEXTPORT(pPortDesc);
			srcAddr.ata_Node 	= alapSrcNode;

			//	Get the socket numbers from the ddp header.
			destAddr.ata_Socket = *pDdpPkt++;
			srcAddr.ata_Socket	= *pDdpPkt;

			DBGPRINT(DBG_COMP_DDP, DBG_LEVEL_WARN,
					("AtalkDdpPacketIn: NonExtended Dest Net.Node %lx.%lx\n",
					destAddr.ata_Network, destAddr.ata_Node));

			//	Now the destination node address could be
			//	ALAP_BROADCAST_NODE (0xFF).
			if ((srcAddr.ata_Node < MIN_USABLE_ATALKNODE) ||
				(srcAddr.ata_Node > MAX_USABLE_ATALKNODE) ||
				(destAddr.ata_Node == UNKNOWN_NODE))
			{
				error	= ATALK_INVALID_PKT;
				break;
			}

			if (destAddr.ata_Node == ATALK_BROADCAST_NODE)
			{
				error = ATALK_FAILURE;
				break;
			}
		}
		else
		{
			//	If we have a checksum, we cannot optimize.
			if ((*pDdpPkt++ != 0) || (*pDdpPkt++ != 0))
			{
				error = ATALK_FAILURE;
				break;
			}

			//	Build full source and destination AppleTalk address structures
			//	from our DDP header.
			GETSHORT2SHORT(&destAddr.ata_Network, pDdpPkt);
			pDdpPkt += 2;

			GETSHORT2SHORT(&srcAddr.ata_Network, pDdpPkt);
			pDdpPkt += 2;

			destAddr.ata_Node 	= *pDdpPkt++;
			srcAddr.ata_Node 	= *pDdpPkt++;
			destAddr.ata_Socket	= *pDdpPkt++;
			srcAddr.ata_Socket 	= *pDdpPkt;

			if (destAddr.ata_Node == ATALK_BROADCAST_NODE)
			{
				error = ATALK_FAILURE;
				break;
			}

			//	Do we like what we see?  Note "nnnn00" is now allowed and used by NBP.
			
			if ((srcAddr.ata_Network > LAST_VALID_NETWORK)	||
				(srcAddr.ata_Network < FIRST_VALID_NETWORK) ||
				(srcAddr.ata_Node < MIN_USABLE_ATALKNODE)	||
				(srcAddr.ata_Node > MAX_USABLE_ATALKNODE))
			{
				error = ATALK_INVALID_PKT;
				break;
			}
		} 	//	Long DDP header
	} while (FALSE);

	if (!ATALK_SUCCESS(error))
	{
		DBGPRINT(DBG_COMP_DDP, DBG_LEVEL_WARN,
				("AtalkDdpPacketIn: drop packet in indication%lx\n", error));

		return error;
	}

	//	Now for the ATP processing. We need to copy header into ndispkt.
	//	Get the static fields from the ATP header.
	controlInfo = pAtpHdr[ATP_CMD_CONTROL_OFF];
	function = (controlInfo & ATP_FUNC_MASK);
	eomFlag = ((controlInfo & ATP_EOM_MASK) != 0);

	//	Get the sequence number
	seqNum = (USHORT)(pAtpHdr[ATP_SEQ_NUM_OFF]);

	//	Get the transaction id
	GETSHORT2SHORT(&tid, &pAtpHdr[ATP_TRANS_ID_OFF]);

	DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_INFO,
			("AtalkIndAtpPkt: Packet tid %x func %x ctrlinfo %x\n",
			tid, function, controlInfo));

	do
	{
		//	See if we have a a cached ATP address for this destination address.
		AtalkIndAtpCacheLkUpSocket(&destAddr, &pAtpAddrObj, &error);
		if (!ATALK_SUCCESS(error))
		{
			error = ATALK_FAILURE;
			DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_INFO,
					("AtalkIndAtpPkt: CacheLkup failed - tid %x, func %x, ctrlinfo %x\n",
					tid, function, controlInfo));
			break;
		}

		refAtpAddr = TRUE;

		if (function != ATP_RESPONSE) // Is this a request or a release?
		{
			PBYTE				packet;
			PBUFFER_HDR			pBufferHdr = NULL;
			PPROTOCOL_RESD  	protocolResd;
			BLKID				BlkId;

			//	Allocate a small or large ddp buffer as appropriate.
			BlkId = BLKID_DDPSM;
			if (DataSize > (sizeof(DDP_SMBUFFER) - sizeof(BUFFER_HDR)))
				BlkId = BLKID_DDPLG;

			if ((pBufferHdr = (PBUFFER_HDR)AtalkBPAllocBlock(BlkId)) == NULL)
			{
				error = ATALK_FAILURE;
				break;
			}

			DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_INFO,
					("AtalkIndAtpPkt: Indicating request\n"));

			//	Setup the ndis packet.
			packet		= (PBYTE)pBufferHdr + sizeof(BUFFER_HDR);
		
			//  Get a pointer to the NDIS packet descriptor from the buffer header.
			ndisPkt			= pBufferHdr->bh_NdisPkt;
			protocolResd 	= (PPROTOCOL_RESD)(ndisPkt->ProtocolReserved);

			//	All set! Set appropriate values in the packet descriptor.
			protocolResd->Receive.pr_OptimizeType	= INDICATE_ATP;
			protocolResd->Receive.pr_OptimizeSubType= ATP_ALLOC_BUF;
			protocolResd->Receive.pr_AtpAddrObj		= pAtpAddrObj;
			protocolResd->Receive.pr_SrcAddr		= srcAddr;
			protocolResd->Receive.pr_DestAddr		= destAddr;
			protocolResd->Receive.pr_DataLength		= DataSize;
			protocolResd->Receive.pr_OptimizeCtx	= (PVOID)NULL;
			protocolResd->Receive.pr_OffCablePkt	= (BOOLEAN)(hopCnt > 0);

			*pNdisPkt	= ndisPkt;
			*ppPacket	= packet;
			*pSubType	= function;
			*pXferOffset += (ShortDdpHdr ? SDDP_HDR_LEN : LDDP_HDR_LEN);

			//	Done, break out.
			error = ATALK_NO_ERROR;
			break;
		}

		ASSERT (function == ATP_RESPONSE);

		DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_INFO,
				("AtalkIndAtpPkt: RESPONSE SeqNum %d tid %lx\n", seqNum, tid));

		if (seqNum > (ATP_MAX_RESP_PKTS-1))
		{
			error	= ATALK_INVALID_PKT;
			break;
		}

		//	See if there is a pending request.
		ACQUIRE_SPIN_LOCK_DPC(&pAtpAddrObj->atpao_Lock);
		atalkAtpReqReferenceByAddrTidDpc(pAtpAddrObj,
										 &srcAddr,
										 tid,
										 &pAtpReq,
										 &error);
		RELEASE_SPIN_LOCK_DPC(&pAtpAddrObj->atpao_Lock);

		if (!ATALK_SUCCESS(error))
		{
			//	We dont have a corresponding pending request. Ignore.
			DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_ERR,
					("AtalkIndAtpPkt: NO pending request for tid %lx\n", tid));
			error	= ATALK_DUP_PKT;	// Do not add this to dropped packet statistic
			break;
		}

		refAtpReq = TRUE;

		do
		{
			//	Check the request bitmap, which could be zero if the user only
			//	wanted the user bytes and passed in a null response buffer.
			//	Do we want to keep this response? Check the corresponding
			//	bit in our current bitmap set.
			ACQUIRE_SPIN_LOCK_DPC(&pAtpReq->req_Lock);

			pAtpReq->req_Flags |= ATP_REQ_REMOTE;

			do
			{
				if (((pAtpReq->req_RecdBitmap & AtpBitmapForSeqNum[seqNum]) != 0) ||
					((pAtpReq->req_Bitmap & AtpBitmapForSeqNum[seqNum]) == 0))
				{
					error	= ATALK_DUP_PKT;	// Not an error condition
					break;
				}

				if (atpDataSize > 0)
				{
					startOffset = (USHORT)seqNum * pAtpAddrObj->atpao_MaxSinglePktSize;
					if (pAtpReq->req_RespBufLen < (startOffset + atpDataSize))
					{
						error = ATALK_FAILURE;
						break;
					}
				}

				//	If we are the first packet, copy the response user bytes.
				if (seqNum == 0)
				{
					DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_INFO,
							("AtalkIndAtpPkt: Copying user bytes for tid %x\n", tid));
					RtlCopyMemory(pAtpReq->req_RespUserBytes,
								  pAtpHdr + ATP_USER_BYTES_OFF,
								  ATP_USERBYTES_SIZE);
				}

				// If this response packet does not cause the req_Bitmap to go to ZERO
				// i.e. we have not recvd. all the packets, just copy the data into
				// user's buffer, adjust the bitmaps (req_Bitmap & req_RecdBitmap) and
				// not indicate this packet up to Atp.
				pAtpReq->req_RecdBitmap |= AtpBitmapForSeqNum[seqNum];
				pAtpReq->req_Bitmap &= ~AtpBitmapForSeqNum[seqNum];
				pAtpReq->req_RespRecdLen += atpDataSize;

				DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_INFO,
						("AtalkIndAtpPkt: Bitmap %x, RecdBitmap %x, RecdLen %d for tid %x\n",
						pAtpReq->req_Bitmap, pAtpReq->req_RecdBitmap,
						pAtpReq->req_RespRecdLen, tid));

				//	Now if eom is set, we need to reset all high order bits
				//	of the req_Bitmap. req_RecdBitmap should now indicate all
				//	the buffers we received. The two should be mutually exclusive
				//	at this point.
				if (eomFlag)
				{
					pAtpReq->req_Bitmap &= AtpEomBitmapForSeqNum[seqNum];
					ASSERT((pAtpReq->req_Bitmap & pAtpReq->req_RecdBitmap) == 0);
				}

				RespType = ATP_USER_BUF;
				if (pAtpReq->req_Bitmap != 0)
				{
					RespType = ATP_USER_BUFX;
					Deref = TRUE;
				}
				else
				{
					pAtpReq->req_Flags |= ATP_REQ_RESPONSE_COMPLETE;
					DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_INFO,
							("AtalkIndAtpPkt: LAST Response for tid %x\n", tid));
				}

				//	Allocate an NDIS packet descriptor.
				NdisDprAllocatePacket(&ndisStatus,
									  &ndisPkt,
									  AtalkNdisPacketPoolHandle);
				if (ndisStatus == NDIS_STATUS_SUCCESS)
				{
					RtlZeroMemory(ndisPkt->ProtocolReserved, sizeof(PROTOCOL_RESD));
					//	It will be freed by receive completion now.
					ndisBuffer = pAtpReq->req_NdisBuf[seqNum];
					pAtpReq->req_NdisBuf[seqNum]	= NULL;
				}
				else
				{
					error = ATALK_FAILURE;
					break;
				}
			} while (FALSE);

			RELEASE_SPIN_LOCK_DPC(&pAtpReq->req_Lock);

			if (!ATALK_SUCCESS(error))
			{
				break;
			}

			//	Copy the data into the users buffer. Check if there's room.
			if ((atpDataSize > 0) || (ndisBuffer != NULL))
			{
				if (ndisBuffer == NULL)
				{
					//	Allocate an NDIS buffer descriptor and chain into pkt desc.
					NdisCopyBuffer(&ndisStatus,
								   &ndisBuffer,
								   AtalkNdisBufferPoolHandle,
								   (PVOID)pAtpReq->req_RespBuf,
								   startOffset,  			//	Offset
								   (UINT)atpDataSize);
	
					if (ndisStatus != NDIS_STATUS_SUCCESS)
					{
						NdisDprFreePacket(ndisPkt);
	
						error = ATALK_FAILURE;
						break;
					}

                    ATALK_DBG_INC_COUNT(AtalkDbgMdlsAlloced);
				}

				//	Chain in the buffer.
				NdisChainBufferAtBack(ndisPkt, ndisBuffer);
			}

			//	All set! Set appropriate values in the packet descriptor.
			protocolResd 	= (PPROTOCOL_RESD)&ndisPkt->ProtocolReserved;
			protocolResd->Receive.pr_OptimizeType	= INDICATE_ATP;
			protocolResd->Receive.pr_OptimizeSubType= RespType;
			protocolResd->Receive.pr_AtpAddrObj		= pAtpAddrObj;
			protocolResd->Receive.pr_SrcAddr		= srcAddr;
			protocolResd->Receive.pr_DestAddr		= destAddr;
			protocolResd->Receive.pr_DataLength		= atpDataSize;
			protocolResd->Receive.pr_OptimizeCtx	= (PVOID)pAtpReq;
			protocolResd->Receive.pr_OffCablePkt	= (BOOLEAN)(hopCnt > 0);

			// Do not copy the Atp header unless AtalkAtpPacketIn will be called.
			if (RespType == ATP_USER_BUF)
			{
				ATALK_RECV_INDICATION_COPY(pPortDesc,
										   protocolResd->Receive.pr_AtpHdr,
										   pAtpHdr,
										   ATP_HEADER_SIZE);
				DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_INFO,
						("AtalkIndAtpPkt: Last packet for request, indicating tid %x\n", tid));
			}
	
			*pNdisPkt = ndisPkt;
			*ppPacket = NULL;
			*pSubType = function;
			*pXferOffset += ((ShortDdpHdr ? SDDP_HDR_LEN : LDDP_HDR_LEN) + ATP_HEADER_SIZE);
		} while (FALSE);
	} while (FALSE);

	if (!ATALK_SUCCESS(error) || Deref)
	{
		if (refAtpReq)
		{
			AtalkAtpReqDereferenceDpc(pAtpReq);
		}

		if (refAtpAddr)
		{
			AtalkAtpAddrDereferenceDpc(pAtpAddrObj);
		}
	}

#ifdef	PROFILING
	TimeE = KeQueryPerformanceCounter(NULL);
	TimeD.QuadPart = TimeE.QuadPart - TimeS.QuadPart;

	INTERLOCKED_ADD_LARGE_INTGR_DPC(&AtalkStatistics.stat_AtpIndicationProcessTime,
									TimeD,
									&AtalkStatsLock.SpinLock);

	INTERLOCKED_INCREMENT_LONG_DPC(&AtalkStatistics.stat_AtpNumIndications,
								   &AtalkStatsLock.SpinLock);
#endif

	return error;
}


ATALK_ERROR
AtalkIndAtpCacheSocket(
	IN	PATP_ADDROBJ		pAtpAddr,
	IN	PPORT_DESCRIPTOR	pPortDesc
	)
/*++

Routine Description:

	Cache ATP socket routine. Have another one for ADSP when that is done.

Arguments:


Return Value:

	None
--*/
{
	USHORT			i;
	KIRQL			OldIrql;
	PDDP_ADDROBJ	pDdpAddr;
	ATALK_ERROR		error = ATALK_FAILURE;

	//	Only cache if the net and node match the current net and node.
	ACQUIRE_SPIN_LOCK(&AtalkSktCacheLock, &OldIrql);
	pDdpAddr	= pAtpAddr->atpao_DdpAddr;

	if ((AtalkSktCache.ac_Network == 0)	&&
		(AtalkSktCache.ac_Node == 0)	&&
		(AtalkDefaultPort	== pPortDesc))
	{
		AtalkSktCache.ac_Network = pDdpAddr->ddpao_Addr.ata_Network;
		AtalkSktCache.ac_Node	 = pDdpAddr->ddpao_Addr.ata_Node;
	}

	if ((AtalkSktCache.ac_Network == pDdpAddr->ddpao_Addr.ata_Network) &&
		(AtalkSktCache.ac_Node == pDdpAddr->ddpao_Addr.ata_Node))
	{
		//	First try to get a free slot
		for (i = 0; i < ATALK_CACHE_SKTMAX; i++)
		{
			if (AtalkSktCache.ac_Cache[i].Type == ATALK_CACHE_NOTINUSE)
			{
				ASSERT(AtalkSktCache.ac_Cache[i].u.pAtpAddr	== NULL);

				//	Use this slot
				AtalkSktCache.ac_Cache[i].Type = (ATALK_CACHE_INUSE | ATALK_CACHE_ATPSKT);
				AtalkSktCache.ac_Cache[i].Socket = pDdpAddr->ddpao_Addr.ata_Socket;
	
				//	The caller must have referenced these before calling cache AND
				//	must called uncache before removing those references. Also, if we
				//	returned error from this routine, Caller must Dereference them.
				AtalkSktCache.ac_Cache[i].u.pAtpAddr	= pAtpAddr;
				error = ATALK_NO_ERROR;
				break;
			}
		}
	}
	RELEASE_SPIN_LOCK(&AtalkSktCacheLock, OldIrql);

	return error;
}


VOID
AtalkIndAtpUnCacheSocket(
	IN	PATP_ADDROBJ		pAtpAddr
	)
/*++

Routine Description:

	Cache ATP socket routine. Have another one for ADSP when that is done.

Arguments:


Return Value:

	None
--*/
{
	USHORT	i;
	KIRQL	OldIrql;

	ACQUIRE_SPIN_LOCK(&AtalkSktCacheLock, &OldIrql);
	for (i = 0; i < ATALK_CACHE_SKTMAX; i++)
	{
		if ((AtalkSktCache.ac_Cache[i].Type == (ATALK_CACHE_INUSE | ATALK_CACHE_ATPSKT)) &&
			(AtalkSktCache.ac_Cache[i].Socket == pAtpAddr->atpao_DdpAddr->ddpao_Addr.ata_Socket))
		{
			ASSERT(AtalkSktCache.ac_Cache[i].u.pAtpAddr	== pAtpAddr);
		
			AtalkSktCache.ac_Cache[i].Type = ATALK_CACHE_NOTINUSE;
			AtalkSktCache.ac_Cache[i].u.pAtpAddr = NULL;
			break;
		}
	}

	if (i == ATALK_CACHE_SKTMAX)
	{
		//	We didnt find the socket! References will get all messed up!
		ASSERT(0);
	}

	RELEASE_SPIN_LOCK(&AtalkSktCacheLock, OldIrql);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\atalk\sys\atkind.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

	atkind.h

Abstract:


Author:

	Nikhil Kamkolkar (nikhilk@microsoft.com)

Revision History:
	22 Oct 1993		Initial Version

Notes:	Tab stop: 4
--*/

#ifndef	_ATKIND_
#define	_ATKIND_

//	Different subtypes for ATP indication type.
#define	ATP_ALLOC_BUF	0
#define	ATP_USER_BUF	1
#define	ATP_USER_BUFX	2		// Do not indicate the packet to Atp with this.

ATALK_ERROR
AtalkIndAtpPkt(
	IN		PPORT_DESCRIPTOR	pPortDesc,
	IN		PBYTE				pLookahead,
	IN		USHORT				PktLen,
	IN	OUT	PUINT				pXferOffset,
	IN		PBYTE				pLinkHdr,
	IN		BOOLEAN				ShortDdpHdr,
	OUT		PBYTE				SubType,
	OUT		PBYTE			* 	ppPacket,
	OUT		PNDIS_PACKET	*	pNdisPkt);

ATALK_ERROR
AtalkIndAtpCacheSocket(
	IN	struct _ATP_ADDROBJ	*	pAtpAddr,
	IN	PPORT_DESCRIPTOR		pPortDesc);

VOID
AtalkIndAtpUnCacheSocket(
	IN	struct _ATP_ADDROBJ	*	pAtpAddr);

//	VOID
//	AtalkIndAtpSetupNdisBuffer(
//		IN	OUT	PATP_REQ		pAtpReq,
//		IN		ULONG			MaxSinglePktSize);
//
#define	AtalkIndAtpSetupNdisBuffer(pAtpReq, MaxSinglePktSize)	\
	{															\
		NDIS_STATUS		ndisStatus;								\
		PNDIS_BUFFER	ndisBuffer;								\
		USHORT			seqNum		= 0;						\
		USHORT			startOffset = 0;						\
		SHORT			BufLen = (SHORT)pAtpReq->req_RespBufLen;\
																\
		RtlZeroMemory(pAtpReq->req_NdisBuf,						\
					  sizeof(PVOID) * ATP_MAX_RESP_PKTS);		\
																\
		while (BufLen > 0)										\
		{														\
			NdisCopyBuffer(&ndisStatus,							\
						   &ndisBuffer,							\
						   AtalkNdisBufferPoolHandle,			\
						   (PVOID)pAtpReq->req_RespBuf,			\
						   startOffset,							\
						   (UINT)MIN(BufLen,					\
						   (SHORT)MaxSinglePktSize));			\
																\
			if (ndisStatus != NDIS_STATUS_SUCCESS)				\
				break;											\
																\
			pAtpReq->req_NdisBuf[seqNum++] = ndisBuffer;		\
			startOffset  += (USHORT)MaxSinglePktSize;			\
			BufLen -= (SHORT)MaxSinglePktSize;					\
		}														\
	}

//	VOID
//	AtalkIndAtpReleaseNdisBuffer(
//		IN	OUT	PATP_REQ		pAtpReq);
//
#define	AtalkIndAtpReleaseNdisBuffer(pAtpReq)					\
	{															\
		LONG	_i;												\
																\
		for (_i = 0; _i < ATP_MAX_RESP_PKTS; _i++)				\
		{														\
			if ((pAtpReq)->req_NdisBuf[_i] != NULL)				\
				NdisFreeBuffer((pAtpReq)->req_NdisBuf[_i]);		\
		}														\
	}


//	ATALK_ERROR
//	AtalkIndAtpCacheLkUpSocket(
//		IN	PATALK_ADDR				pDestAddr,
//		OUT	struct _ATP_ADDROBJ	**	ppAtpAddr,
//		OUT	ATALK_ERROR			*	pError);
//
#define	AtalkIndAtpCacheLkUpSocket(pDestAddr, ppAtpAddr, pError)	\
	{																\
		USHORT					i;									\
		struct ATALK_CACHED_SKT	*pCachedSkt;						\
																	\
		*(pError) = ATALK_FAILURE;									\
																	\
		if (((pDestAddr)->ata_Network == AtalkSktCache.ac_Network) &&	\
			((pDestAddr)->ata_Node	== AtalkSktCache.ac_Node))		\
		{															\
			ACQUIRE_SPIN_LOCK_DPC(&AtalkSktCacheLock);				\
																	\
			for (i = 0, pCachedSkt = &AtalkSktCache.ac_Cache[0];	\
				 i < ATALK_CACHE_SKTMAX;							\
				 i++, pCachedSkt++)									\
			{														\
				if ((pCachedSkt->Type == (ATALK_CACHE_INUSE | ATALK_CACHE_ATPSKT))	&&	\
					(pCachedSkt->Socket == (pDestAddr)->ata_Socket))\
				{													\
					AtalkAtpAddrReferenceDpc(pCachedSkt->u.pAtpAddr,\
											 pError);				\
																	\
					if (ATALK_SUCCESS(*pError))						\
					{												\
						*(ppAtpAddr) = pCachedSkt->u.pAtpAddr;		\
					}												\
					break;											\
				}													\
			}														\
																	\
			RELEASE_SPIN_LOCK_DPC(&AtalkSktCacheLock);				\
		}															\
	}

#endif


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\atalk\sys\atkinit.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

	atkinit.c

Abstract:

	This module contains the initialization code for the Appletalk stack.

Author:

	Jameel Hyder (jameelh@microsoft.com)
	Nikhil Kamkolkar (nikhilk@microsoft.com)

Revision History:
	19 Jun 1992		Initial Version

Notes:	Tab stop: 4
--*/

#include <atalk.h>
#pragma hdrstop
#define	FILENUM		ATKINIT

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, AtalkInitializeTransport)
#pragma alloc_text(PAGEINIT, atalkInitGetHandleToKey)
#pragma alloc_text(PAGEINIT, atalkInitGlobal)
#pragma alloc_text(PAGEINIT, atalkInitPort)
#pragma alloc_text(PAGEINIT, atalkInitNetRangeCheck)
#pragma alloc_text(PAGEINIT, atalkInitNetRange)
#pragma alloc_text(PAGEINIT, atalkInitZoneList)
#pragma alloc_text(PAGEINIT, atalkInitDefZone)
#pragma alloc_text(PAGEINIT, atalkInitSeeding)
#pragma alloc_text(PAGEINIT, atalkInitPortParameters)
#pragma alloc_text(PAGEINIT, atalkInitStartPort)
#pragma alloc_text(PAGEINIT, AtalkInitAdapter)
#pragma alloc_text(PAGEINIT, AtalkDeinitAdapter)
#pragma alloc_text(PAGEINIT, atalkInitStartPort)
#endif

NTSTATUS
AtalkInitializeTransport(
	IN	PDRIVER_OBJECT		pDrvObj,
	IN	PUNICODE_STRING		pRegPath
	)
/*++

Routine Description:

	This routine is called during initialization time to
	initialize the transport.

Arguments:

Return Value:

	Status - STATUS_SUCCESS if initialized,
			 Appropriate NT error code otherwise
--*/
{
	PPORT_DESCRIPTOR	pPortDesc;
	NTSTATUS			status;				

	do
	{
		// Initialize the default-port event
		KeInitializeEvent(&AtalkDefaultPortEvent, NotificationEvent, FALSE);

		// Save our registry path
		if ((AtalkRegPath.Buffer = AtalkAllocMemory(pRegPath->Length)) == NULL)
		{
			status = STATUS_INSUFFICIENT_RESOURCES;
			RES_LOG_ERROR();
			break;
		}
		AtalkRegPath.MaximumLength =
		AtalkRegPath.Length = pRegPath->Length;
		RtlCopyMemory(AtalkRegPath.Buffer,
					  pRegPath->Buffer,
				      pRegPath->Length);

		AtalkInitMemorySystem();
	
		// Get the frequency of the performance counters
		KeQueryPerformanceCounter(&AtalkStatistics.stat_PerfFreq);

		//	Initialize the timer subsystem
		if (!NT_SUCCESS(status = AtalkTimerInit()) ||
			!NT_SUCCESS(status = AtalkZipInit(TRUE)))
		{
			RES_LOG_ERROR();
			break;
		}


		//	Initialize the global port descriptors
		AtalkPortList = NULL;
		AtalkDefaultPort = NULL;
		AtalkNumberOfPorts = 0;
		AtalkRouter = FALSE;
	

		// Get the global parameters
		status = atalkInitGlobal();

		if (!NT_SUCCESS(status))
		{
			DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
					("AtalkInitializeTransport: AtalkInitGlobal failed %ul\n", status));
			break;
		}

		if (!NT_SUCCESS(status = AtalkNdisInitRegisterProtocol()))
		{
			break;
		}

	} while (FALSE);

	if (NT_SUCCESS(status))
	{
#if	DBG
		AtalkTimerInitialize(&AtalkDumpTimerList,
							 AtalkDumpComponents,
							 DBG_DUMP_DEF_INTERVAL);
		AtalkTimerScheduleEvent(&AtalkDumpTimerList);
#endif

		// Initialize the other subsystems now
		AtalkInitAspInitialize();
		AtalkInitPapInitialize();
		AtalkInitAdspInitialize();
	}
	else
	{
		DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
				("Initialization failed!\n"));

		//	We are not loading. Stop everything and return.
		//	Stop all ports, release port resources
		//	Stop the timer subsystem if it was started
		AtalkCleanup();
	}

	return status;
}


NTSTATUS
atalkInitGetHandleToKey(
	IN	PUNICODE_STRING		KeyName,
	OUT	PHANDLE				KeyHandle
	)
/*++

Routine Description:

	Returns the handle for the key specified using SectionHandle as the
	root.

Arguments:

	SectionHandle - Key to registry tree root
	KeyNameString - name of key to be opened
	KeyHandle - Returns the handle for KeyNameString

Return Value:

	The status of the request.

--*/
{
	HANDLE				ConfigHandle;
	NTSTATUS			status;
	OBJECT_ATTRIBUTES	ObjectAttributes;

	*KeyHandle = NULL;

	InitializeObjectAttributes(&ObjectAttributes,
							   &AtalkRegPath,			// name
							   OBJ_CASE_INSENSITIVE,	// attributes
							   NULL,					// root
							   NULL);					// security descriptor

	status = ZwOpenKey(&ConfigHandle,
					   KEY_READ,
					   &ObjectAttributes);

	if (NT_SUCCESS(status))
	{
		InitializeObjectAttributes(&ObjectAttributes,
								   KeyName,					// name
								   OBJ_CASE_INSENSITIVE,	// attributes
								   ConfigHandle,			// root
								   NULL);					// security descriptor

		status = ZwOpenKey(KeyHandle,
						   KEY_READ,
						   &ObjectAttributes);
		ZwClose(ConfigHandle);
	}

	return status;
}


NTSTATUS
atalkInitGlobal(
	VOID
	)
/*++

Routine Description:

	Reads the Parameters key to get the global parameters. These are:
	- DefaultPort
	- DesiredZOne
	- EnableRouter
	- FilterOurNames

Arguments:

Return Value:

	Status - STATUS_SUCCESS
			 Or other NT status codes
--*/
{
	UNICODE_STRING		valueName, unicodePortName, unicodeZone;
    UNICODE_STRING      rasName;
	HANDLE				ParametersHandle;
	ANSI_STRING			ansiZone;
	BYTE				ansiBuf[MAX_ENTITY_LENGTH+1];
	NTSTATUS			status;
	ULONG				bytesWritten;
	PWCHAR				portName;
	PWCHAR				desiredZoneValue;
	PCHAR				asciiDesiredZone = NULL;
	BYTE				Storage[2*2*MAX_ENTITY_LENGTH+sizeof(KEY_VALUE_FULL_INFORMATION)];
	PKEY_VALUE_FULL_INFORMATION Info = (PKEY_VALUE_FULL_INFORMATION)Storage;
	PULONG				Value;

	do
	{
		// Open the parameters key.
		RtlInitUnicodeString(&valueName, PARAMETERS_STRING);
		status = atalkInitGetHandleToKey(&valueName,
										 &ParametersHandle);
		if (!NT_SUCCESS(status))
		{
			break;
		}

		// Read the "EnableRouter" value name
		RtlInitUnicodeString (&valueName, VALUENAME_ENABLEROUTER);
		status = ZwQueryValueKey(ParametersHandle,
								 &valueName,
								 KeyValueFullInformation,
								 Info,
								 sizeof(Storage),
								 &bytesWritten);
	
		if (status == STATUS_SUCCESS)
		{
			Value = (PULONG)((PBYTE)Info + Info->DataOffset);
			if (*Value != 0)
			{
                // if router wasn't running before, change that! (PnP case)
                if (!AtalkRouter)
                {
				    AtalkRouter = TRUE;
				    AtalkRtmpInit(TRUE);
				    AtalkLockRouterIfNecessary();
                }
			}
            else
            {
                AtalkRouter = FALSE;
            }
		}
		else
		{
			DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
					("atalkInitGlobal: EnableRouter value not found, assuming false\n"));
		}
	
		// Read the "FilterOurNames" value name
		RtlInitUnicodeString (&valueName, VALUENAME_FILTEROURNAMES);
		status = ZwQueryValueKey(ParametersHandle,
								 &valueName,
								 KeyValueFullInformation,
								 Info,
								 sizeof(Storage),
								 &bytesWritten);
	
		if (status == STATUS_SUCCESS)
		{
			Value = (PULONG)((PBYTE)Info + Info->DataOffset);
			if (*Value == 0)
			{
				AtalkFilterOurNames = FALSE;
			}
		}
		else
		{
			DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_WARN,
					("atalkInitGlobal: FilterOurNames value not found, assuming true\nq"));
		}
		// Get the default port value
		RtlInitUnicodeString (&valueName, VALUENAME_DEFAULTPORT);
		status = ZwQueryValueKey(ParametersHandle,
								 &valueName,
								 KeyValueFullInformation,
								 Info,
								 sizeof(Storage),
								 &bytesWritten);

		if (status != STATUS_SUCCESS)
		{
			// No default port keyword specified! ABORT
			LOG_ERROR(EVENT_ATALK_NO_DEFAULTPORT, status, NULL, 0);
			ZwClose(ParametersHandle);
            // let appletalk run: it's just that it won't have default adapter
            status = STATUS_SUCCESS;
			break;
		}

		portName = (PWCHAR)((PBYTE)Info + Info->DataOffset);
        AtalkDefaultPortName.Buffer = NULL;
		if (*portName != 0)
		{
			RtlInitUnicodeString(&unicodePortName, portName);
            RtlInitUnicodeString(&rasName,RAS_ADAPTER_NAME);

            // make sure this isn't RAS adapter (setup bug)
		    if (RtlEqualUnicodeString(&unicodePortName,&rasName,TRUE))
		    {
			    DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
					("atalkInitGlobal: can't have RAS adapter as default adapter!\n"));

			    // No default port keyword specified! ABORT
			    LOG_ERROR(EVENT_ATALK_NO_DEFAULTPORT, status, NULL, 0);
			    ZwClose(ParametersHandle);
                status = STATUS_INVALID_PARAMETER;
			    break;
		    }

			AtalkDefaultPortName.Buffer = AtalkAllocMemory(unicodePortName.Length);
			if (AtalkDefaultPortName.Buffer != NULL)
			{
				AtalkDefaultPortName.Length =
                AtalkDefaultPortName.MaximumLength = unicodePortName.Length;
				RtlCopyMemory(AtalkDefaultPortName.Buffer,
							  unicodePortName.Buffer,
							  unicodePortName.Length);
			}
		}

		if (AtalkDefaultPortName.Buffer == NULL)
		{
			LOG_ERROR(EVENT_ATALK_NO_DEFAULTPORT, status, NULL, 0);
			DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
				("WARNING!!! Appletalk driver running, but no default port configured\n"));
			ZwClose(ParametersHandle);

            // let appletalk run: it's just that it won't have default adapter
            status = STATUS_SUCCESS;
			break;
		}
	
		// Get the desired zone value in the form of an asciiz string
		RtlInitUnicodeString (&valueName, VALUENAME_DESIREDZONE);
		status = ZwQueryValueKey(ParametersHandle,
								 &valueName,
								 KeyValueFullInformation,
								 Info,
								 sizeof(Storage),
								 &bytesWritten);
	
		// Close this handle now - we do not need it anymore
		ZwClose(ParametersHandle);
		ParametersHandle = NULL;

		if (status != STATUS_SUCCESS)
		{
			LOG_ERROR(EVENT_ATALK_INVALID_DESIREDZONE, status, NULL, 0);
			status = STATUS_SUCCESS;
			break;
		}

		desiredZoneValue = (PWCHAR)((PBYTE)Info + Info->DataOffset);
		if (*desiredZoneValue != 0)
		{
			RtlInitUnicodeString(&unicodeZone, desiredZoneValue);
			ansiZone.Length = (USHORT)RtlUnicodeStringToAnsiSize(&unicodeZone)-1;
			if (ansiZone.Length > MAX_ENTITY_LENGTH)
			{
				status = STATUS_UNSUCCESSFUL;

				//	Incorrect zone name!
				LOG_ERROR(EVENT_ATALK_INVALID_DESIREDZONE, status, NULL, 0);
				break;
			}
	
			ansiZone.Buffer = ansiBuf;
			ansiZone.MaximumLength = sizeof(ansiBuf);
		
			status = RtlUnicodeStringToAnsiString(&ansiZone,
												  &unicodeZone,
												  (BOOLEAN)FALSE);
	
			if (status == STATUS_SUCCESS)
			{
				AtalkDesiredZone = AtalkZoneReferenceByName(ansiBuf, (BYTE)(ansiZone.Length));
			}
			if ((status != STATUS_SUCCESS) ||
				(AtalkDesiredZone == NULL))
			{
				LOG_ERROR(EVENT_ATALK_RESOURCES, status, NULL, 0);
			}
		}
	} while (FALSE);

	return status;
}


NTSTATUS
atalkInitPort(
	IN	PPORT_DESCRIPTOR	pPortDesc,
	IN	HANDLE				AdaptersHandle
	)
/*++

Routine Description:

	This routine is called during initialization time to get the per port
	parameters from the registry. It will store the per port parameters
	in the port information structures readying them to be passed to the main
	initialize() routine

Arguments:

	AdaptersHandle- Handle to the ...\Parameters\Adapters key in registry

Return Value:

	Status - STATUS_SUCCESS
			 STATUS_INSUFFICIENT_RESOURCES
--*/
{
	OBJECT_ATTRIBUTES	ObjectAttributes;
	NTSTATUS			status;
	BOOLEAN				seeding;

	// Get the key to the adapter for this port
	InitializeObjectAttributes(&ObjectAttributes,
							   &pPortDesc->pd_AdapterKey,		// name
							   OBJ_CASE_INSENSITIVE,			// attributes
							   AdaptersHandle,					// root
							   NULL);							// security descriptor

	status = ZwOpenKey(&pPortDesc->pd_AdapterInfoHandle,
					   KEY_READ,
					   &ObjectAttributes);

	if (!NT_SUCCESS(status))
	{
		if (!AtalkRouter)
			status = STATUS_SUCCESS;

		return status;
	}

    //
    // if this is the first time the adapter is being initialized (usually the case),
    // read the PramNodes from the registry.  If we are initializing this adapter on
    // a PnP event, then there is a good chance our network config has changed, so
    // ignore the registry values and get fresh ones)
    //
    if (!(pPortDesc->pd_Flags & PD_CONFIGURED_ONCE))
    {
        pPortDesc->pd_Flags |= PD_CONFIGURED_ONCE;

	    // Get PRAM Information
	    AtalkInitNodeGetPramAddr(pPortDesc,
		    					 ROUTER_NODE_VALUE,
			    				 &pPortDesc->pd_RoutersPramNode);

	    AtalkInitNodeGetPramAddr(pPortDesc,
		    					 USER_NODE1_VALUE,
			    				 &pPortDesc->pd_UsersPramNode1);

	    AtalkInitNodeGetPramAddr(pPortDesc,
		    					 USER_NODE2_VALUE,
			    				 &pPortDesc->pd_UsersPramNode2);
    }
    else
    {
        ASSERT(pPortDesc->pd_RoutersPramNode.atn_Network == 0);
        ASSERT(pPortDesc->pd_RoutersPramNode.atn_Node == 0);
        ASSERT(pPortDesc->pd_UsersPramNode1.atn_Network == 0);
        ASSERT(pPortDesc->pd_UsersPramNode1.atn_Node == 0);
        ASSERT(pPortDesc->pd_UsersPramNode2.atn_Network == 0);
        ASSERT(pPortDesc->pd_UsersPramNode2.atn_Node == 0);
    }

	// If we are a router, get the following information
	if (AtalkRouter)
	{
		if (!DEF_PORT(pPortDesc))
		{
			AtalkZapPramValue(pPortDesc, USER_NODE1_VALUE);
			AtalkZapPramValue(pPortDesc, USER_NODE2_VALUE);
		}
		atalkInitSeeding(pPortDesc, &seeding);

		//	Check following values only if the seeding flag	is set.
		if (seeding) do
		{
			// Get the Network range information. Value names are
			// NetworkRangeLowerEnd & NetworkRangeUpperEnd
			status = atalkInitNetRange(pPortDesc);

			if (!NT_SUCCESS(status))
			{
				LOG_ERRORONPORT(pPortDesc,
			                    EVENT_ATALK_SEEDROUTER_NONETRANGE,
								0,
								NULL,
								0);
				DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
						("atalkInitPort: Could not get network range\n"));

				break;
			}
	
			status = atalkInitNetRangeCheck(pPortDesc);

			if (!NT_SUCCESS(status))
			{
				break;
			}

			// Get the Zone list information. Value name is ZoneList
			status = atalkInitZoneList(pPortDesc);

			if (!NT_SUCCESS(status))
			{
				LOG_ERRORONPORT(pPortDesc,
			                    EVENT_ATALK_SEEDROUTER_NOZONELIST,
								0,
								NULL,
								0);
				DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
						("atalkInitPort: Could not get zone list\n"));

				break;
			}
	
			// Get the default zone specification. Value name is DefaultZone
			status = atalkInitDefZone(pPortDesc);

			if (!NT_SUCCESS(status))
			{
				DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
						("atalkInitPort: Could not get default zone\n"));

				break;
			}

			//	Check for default zone being in the zone list for the port
			//	Also make sure that a localtalk port is not specified
			//	as the default port. And that a default zone was not
			//	specified for a localtalk port. We can only do this after
			//	bind as we do not know until then the media type.
			if (pPortDesc->pd_Flags & PD_SEED_ROUTER)
			{
				if (pPortDesc->pd_InitialDefaultZone == NULL)
				{
					LOG_ERRORONPORT(pPortDesc,
									EVENT_ATALK_NO_DEFZONE,
									0,
									NULL,
									0);
					status = STATUS_UNSUCCESSFUL;
					break;
				}
				if (pPortDesc->pd_InitialZoneList == NULL)
				{
					LOG_ERRORONPORT(pPortDesc,
									EVENT_ATALK_SEEDROUTER_NOZONELIST,
									0,
									NULL,
									0);
					status = STATUS_UNSUCCESSFUL;
					break;
				}
				if (!AtalkZoneOnList(pPortDesc->pd_InitialDefaultZone,
									 pPortDesc->pd_InitialZoneList))
				{
					LOG_ERRORONPORT(pPortDesc,
									EVENT_ATALK_ZONE_NOTINLIST,
									0,
									NULL,
									0);
					status = STATUS_UNSUCCESSFUL;
					break;
				}
			}
		} while (FALSE);
	}
	else
	{
		AtalkZapPramValue(pPortDesc, ROUTER_NODE_VALUE);
	}

	if (NT_SUCCESS(status)) do
	{
		// Get the per-Port parameters
		status = atalkInitPortParameters(pPortDesc);
	
		if (!NT_SUCCESS(status))
		{
			DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
					("atalkInitPort: Could not get port parameters\n"));
		}
	
		//	None of the above affect us loading.
		status = STATUS_SUCCESS;
		break;

	} while (FALSE);

	return status;
}


NTSTATUS
atalkInitNetRangeCheck(
	IN	PPORT_DESCRIPTOR		pPortDesc
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PPORT_DESCRIPTOR	pTmp;
	NTSTATUS			status = STATUS_SUCCESS;

	do
	{
		//	Check for network range overlap among all the ports
		for (pTmp = AtalkPortList;
			 pTmp != NULL;
			 pTmp = pTmp->pd_Next)
		{
			if (pTmp != pPortDesc)
			{
				if ((pPortDesc->pd_InitialNetworkRange.anr_FirstNetwork != UNKNOWN_NETWORK) &&
					(pTmp->pd_InitialNetworkRange.anr_FirstNetwork != UNKNOWN_NETWORK))
				{
					if (AtalkRangesOverlap(&pPortDesc->pd_InitialNetworkRange,
										   &pTmp->pd_InitialNetworkRange))
					{
						LOG_ERRORONPORT(pPortDesc,
										EVENT_ATALK_INITIAL_RANGEOVERLAP,
										status,
										NULL,
										0);
		
						status = STATUS_UNSUCCESSFUL;
						break;
					}
				}
			}
		}

		if (!NT_SUCCESS(status))
		{
			break;
		}

		//	Make sure any PRAM values we might have are in this range
		if ((pPortDesc->pd_RoutersPramNode.atn_Network != UNKNOWN_NETWORK) &&
            (pPortDesc->pd_InitialNetworkRange.anr_FirstNetwork != UNKNOWN_NETWORK) &&
			!(WITHIN_NETWORK_RANGE(pPortDesc->pd_RoutersPramNode.atn_Network,
								   &pPortDesc->pd_InitialNetworkRange)))
		{
			LOG_ERRORONPORT(pPortDesc,
							EVENT_ATALK_PRAM_OUTOFSYNC,
							status,
							NULL,
							0);
		
			pPortDesc->pd_RoutersPramNode.atn_Network = UNKNOWN_NETWORK;
			pPortDesc->pd_RoutersPramNode.atn_Node	  = UNKNOWN_NODE;
		}
		
		if ((pPortDesc->pd_UsersPramNode1.atn_Network != UNKNOWN_NETWORK) &&
	        (pPortDesc->pd_InitialNetworkRange.anr_FirstNetwork != UNKNOWN_NETWORK) &&
			!(WITHIN_NETWORK_RANGE(pPortDesc->pd_UsersPramNode1.atn_Network,
								   &pPortDesc->pd_InitialNetworkRange)))
		{
			LOG_ERRORONPORT(pPortDesc,
							EVENT_ATALK_PRAM_OUTOFSYNC,
							status,
							NULL,
							0);
		
			pPortDesc->pd_UsersPramNode1.atn_Network = UNKNOWN_NETWORK;
			pPortDesc->pd_UsersPramNode1.atn_Node	 = UNKNOWN_NODE;
		}
		if ((pPortDesc->pd_UsersPramNode2.atn_Network != UNKNOWN_NETWORK) &&
	        (pPortDesc->pd_InitialNetworkRange.anr_FirstNetwork != UNKNOWN_NETWORK) &&
			!(WITHIN_NETWORK_RANGE(pPortDesc->pd_UsersPramNode2.atn_Network,
								   &pPortDesc->pd_InitialNetworkRange)))
		{
			LOG_ERRORONPORT(pPortDesc,
							EVENT_ATALK_PRAM_OUTOFSYNC,
							status,
							NULL,
							0);
		
			pPortDesc->pd_UsersPramNode2.atn_Network = UNKNOWN_NETWORK;
			pPortDesc->pd_UsersPramNode2.atn_Node	 = UNKNOWN_NODE;
		}
	} while (FALSE);

	return status;
}




NTSTATUS
atalkInitNetRange(
	OUT	PPORT_DESCRIPTOR	pPortDesc
	)
/*++

Routine Description:

	Gets the network range for the port defined by AdapterInfoHandle

Arguments:

	AdapterInfoHandle- Handle to ...Atalk\Adapters\<adapterName>
	pPortDesc- Pointer to port information structure for the port

Return Value:

	Status - STATUS_SUCCESS or system call returned status codes
--*/
{
	UNICODE_STRING	valueName;
	NTSTATUS		registryStatus;
	ULONG			bytesWritten;
	PULONG			netNumber;

	BYTE			netNumberStorage[sizeof(KEY_VALUE_FULL_INFORMATION) + 80];
	PKEY_VALUE_FULL_INFORMATION netValue = (PKEY_VALUE_FULL_INFORMATION)netNumberStorage;

	do
	{
		// Read the "NetworkRangeLowerEnd" value name
		RtlInitUnicodeString (&valueName, VALUENAME_NETLOWEREND);
		registryStatus = ZwQueryValueKey(pPortDesc->pd_AdapterInfoHandle,
										 &valueName,
										 KeyValueFullInformation,
										 netValue,
										 sizeof(netNumberStorage),
										 &bytesWritten);

		//	This should change with the routing flags.
		if (registryStatus != STATUS_SUCCESS)
		{
			// Set defaults
			pPortDesc->pd_InitialNetworkRange.anr_FirstNetwork = UNKNOWN_NETWORK;
			pPortDesc->pd_InitialNetworkRange.anr_LastNetwork  = UNKNOWN_NETWORK;
	
			registryStatus = STATUS_SUCCESS;
			break;
		}

		netNumber = (PULONG)((PBYTE)netValue + netValue->DataOffset);
		pPortDesc->pd_InitialNetworkRange.anr_FirstNetwork = (USHORT)(*netNumber);

		// Get the upper number only if lower was specified
		RtlInitUnicodeString (&valueName, VALUENAME_NETUPPEREND);
		registryStatus = ZwQueryValueKey(pPortDesc->pd_AdapterInfoHandle,
										 &valueName,
										 KeyValueFullInformation,
										 netValue,
										 sizeof(netNumberStorage),
										 &bytesWritten);

		if (registryStatus != STATUS_SUCCESS)
		{
			// Do not load if lower end specified but upper end was not
			break;
		}

		// Set the upper end of the network range
		netNumber = (PULONG)((PBYTE)netValue + netValue->DataOffset);
		pPortDesc->pd_InitialNetworkRange.anr_LastNetwork =(USHORT)(*netNumber);

		if (!AtalkCheckNetworkRange(&pPortDesc->pd_InitialNetworkRange))
		{
			registryStatus = STATUS_UNSUCCESSFUL;
			break;
		}
	} while (FALSE);

	if (registryStatus != STATUS_SUCCESS)
	{
		LOG_ERRORONPORT(pPortDesc,
						EVENT_ATALK_INVALID_NETRANGE,
						registryStatus,
						NULL,
						0);
	}

	return registryStatus;
}




NTSTATUS
atalkInitZoneList(
	OUT	PPORT_DESCRIPTOR	pPortDesc
	)
/*++

Routine Description:

	Gets the zone list for the port defined by AdapterInfoHandle

Arguments:

	AdapterInfoHandle- Handle to ...Atalk\Adapters\<adapterName>
	pPortDesc- Pointer to port information structure for the port

Return Value:

	Status - STATUS_SUCCESS or system call returned status codes
--*/
{
	UNICODE_STRING	valueName;
	NTSTATUS		status;
	ULONG			bytesWritten;
	PWCHAR			curZoneValue;

	// Anticipate about 10 zones and get space for those, if more then do a
	// dynamic alloc. Note that the below *does not* guarantee 10 zones...
	BYTE			zoneStorage[10*2*(MAX_ENTITY_LENGTH)+sizeof(KEY_VALUE_FULL_INFORMATION)];
	PKEY_VALUE_FULL_INFORMATION zoneValue = (PKEY_VALUE_FULL_INFORMATION)zoneStorage;

	RtlInitUnicodeString (&valueName, VALUENAME_ZONELIST);
	status = ZwQueryValueKey(pPortDesc->pd_AdapterInfoHandle,
							 &valueName,
							 KeyValueFullInformation,
							 zoneValue,
							 sizeof(zoneStorage),
							 &bytesWritten);

	if (status == STATUS_BUFFER_OVERFLOW)
	{
		// If error was a buffer overrun, then allocate space and try again
		zoneValue = (PKEY_VALUE_FULL_INFORMATION)AtalkAllocMemory(bytesWritten);
		if (zoneValue == NULL)
		{
			return STATUS_INSUFFICIENT_RESOURCES;
		}

		status = ZwQueryValueKey(pPortDesc->pd_AdapterInfoHandle,
								 &valueName,
								 KeyValueFullInformation,
								 zoneValue,
								 bytesWritten,
								 &bytesWritten);
	}

	do
	{
		if (status != STATUS_SUCCESS)
		{
			break;
		}
	
		// Proceed to get zone list
		pPortDesc->pd_InitialZoneList = NULL;
		curZoneValue = (PWCHAR)((PBYTE)zoneValue + zoneValue->DataOffset);
		while (*curZoneValue != 0)
		{
			UNICODE_STRING	Us;
			ANSI_STRING		As;
			BYTE			ansiBuf[MAX_ENTITY_LENGTH + 1];

			RtlInitUnicodeString(&Us, curZoneValue);

			As.Buffer = ansiBuf;
			As.Length = (USHORT)RtlUnicodeStringToAnsiSize(&Us) - 1;
			As.MaximumLength = sizeof(ansiBuf);

			if (As.Length > MAX_ENTITY_LENGTH)
			{
				//	Incorrect zone name!
				LOG_ERROR(EVENT_ATALK_INVALID_ZONEINLIST, status, NULL, 0);
			}

			status = RtlUnicodeStringToAnsiString(&As, &Us, FALSE);

			if (!NT_SUCCESS(status))
			{
				DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
						("atalkInitZoneList: RtlUnicodeStringToAnsiSize %lx\n", status));
	
				break;
			}
	
			// Insert the zone in the list in Port
			pPortDesc->pd_InitialZoneList = AtalkZoneAddToList(pPortDesc->pd_InitialZoneList,
															   ansiBuf,
															   (BYTE)(As.Length));

			if (pPortDesc->pd_InitialZoneList == NULL)
			{
				DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
						("atalkInitZoneList: AtalkZoneAddToList failed\n"));
				break;
			}
	
			// Now advance the curZoneValue value to next zone
			curZoneValue = (PWCHAR)((PBYTE)curZoneValue + Us.Length + sizeof(WCHAR));
		}

	} while (FALSE);

	if ((PVOID)zoneValue != (PVOID)zoneStorage)
	{
		AtalkFreeMemory(zoneValue);
	}

	return status;
}




NTSTATUS
atalkInitDefZone(
	OUT	PPORT_DESCRIPTOR	pPortDesc
	)
/*++

Routine Description:

	Gets the default zone for the port defined by AdapterInfoHandle

Arguments:

	AdapterInfoHandle- Handle to ...Atalk\Adapters\<adapterName>
	pPort- Pointer to port information structure for the port

Return Value:

	Status - STATUS_SUCCESS or system call returned status codes
--*/
{
	UNICODE_STRING	valueName;
	NTSTATUS		status;
	ULONG			bytesWritten;
	PWCHAR			defZoneValue;
	BYTE			zoneStorage[2*MAX_ENTITY_LENGTH+sizeof(KEY_VALUE_FULL_INFORMATION)];
	PKEY_VALUE_FULL_INFORMATION zoneValue = (PKEY_VALUE_FULL_INFORMATION)zoneStorage;

	RtlInitUnicodeString (&valueName, VALUENAME_DEFAULTZONE);
	status = ZwQueryValueKey(pPortDesc->pd_AdapterInfoHandle,
							 &valueName,
							 KeyValueFullInformation,
							 zoneValue,
							 sizeof(zoneStorage),
							 &bytesWritten);
	if (status == STATUS_BUFFER_OVERFLOW)
	{
		// If error was a buffer overrun, then allocate space and try again
		zoneValue = (PKEY_VALUE_FULL_INFORMATION)AtalkAllocMemory(bytesWritten);
		if (zoneValue == NULL)
		{
			return STATUS_INSUFFICIENT_RESOURCES;
		}

		status = ZwQueryValueKey(pPortDesc->pd_AdapterInfoHandle,
								 &valueName,
								 KeyValueFullInformation,
								 zoneValue,
								 bytesWritten,
								 &bytesWritten);
	}

	do
	{
		if (status != STATUS_SUCCESS)
		{
			LOG_ERRORONPORT(pPortDesc,
							EVENT_ATALK_NO_DEFZONE,
							status,
							NULL,
							0);

			status = STATUS_SUCCESS;
			break;
		}
		else
		{
			ANSI_STRING		ansiZone;
			UNICODE_STRING	unicodeZone;
			BYTE			ansiBuf[MAX_ENTITY_LENGTH+1];
			NTSTATUS		status;

			defZoneValue = (PWCHAR)((PBYTE)zoneValue + zoneValue->DataOffset);
			if (*defZoneValue != 0)
			{
				RtlInitUnicodeString(&unicodeZone, defZoneValue);
				ansiZone.Length = (USHORT)RtlUnicodeStringToAnsiSize(&unicodeZone) - 1;
				if (ansiZone.Length > MAX_ENTITY_LENGTH+1)
				{
					status = STATUS_UNSUCCESSFUL;

					//	Incorrect zone name!
					LOG_ERRORONPORT(pPortDesc,
									EVENT_ATALK_INVALID_DEFZONE,
									status,
									NULL,
									0);
					break;
				}
	
				ansiZone.Buffer = ansiBuf;
				ansiZone.MaximumLength = sizeof(ansiBuf);
			
				status = RtlUnicodeStringToAnsiString(&ansiZone, &unicodeZone, (BOOLEAN)FALSE);
	
				if (status == STATUS_SUCCESS)
				{
					PZONE		pZone;
					PZONE_LIST 	pZoneList;

					// Ensure that the zone exists in the zone list, We are seed-routing
					ASSERT(pPortDesc->pd_Flags & PD_SEED_ROUTER);
					for (pZoneList = pPortDesc->pd_InitialZoneList;
						 pZoneList != NULL;
						 pZoneList = pZoneList->zl_Next)
					{
						pZone = pZoneList->zl_pZone;

						if (AtalkFixedCompareCaseInsensitive(pZone->zn_Zone,
															 pZone->zn_ZoneLen,
															 ansiBuf,
															 ansiZone.Length))
						{
							break;
						}
					}
					if (pZone == NULL)
					{
						//	Incorrect zone name - not in the list
						LOG_ERRORONPORT(pPortDesc,
										EVENT_ATALK_INVALID_DEFZONE,
										status,
										NULL,
										0);
					}
					pPortDesc->pd_InitialDefaultZone = AtalkZoneReferenceByName(ansiBuf,
																				(BYTE)(ansiZone.Length));
				}
				if ((status != STATUS_SUCCESS) ||
					(pPortDesc->pd_InitialDefaultZone == NULL))
				{
					LOG_ERROR(EVENT_ATALK_RESOURCES, status, NULL, 0);
				}
			}
		}
	} while (FALSE);

	if ((PVOID)zoneValue != (PVOID)zoneStorage)
	{
		AtalkFreeMemory(zoneValue);
	}

	return status;
}




NTSTATUS
atalkInitSeeding(
	IN OUT	PPORT_DESCRIPTOR	pPortDesc,
	OUT		PBOOLEAN			Seeding
	)
/*++

Routine Description:

	Gets the value of the enable router flag from the registry. Sets the
	startRouter value in PortInfo based on this flag.

Arguments:

	AdapterHandle- Handle to the Adapter in registry

Return Value:

	Value of the flag:  TRUE/FALSE
--*/
{

	UNICODE_STRING	valueName;
	NTSTATUS		registryStatus;
	ULONG			bytesWritten;
	PULONG			seedingPortFlag;
	BYTE			flagStorage[sizeof(KEY_VALUE_FULL_INFORMATION)+32];

	PKEY_VALUE_FULL_INFORMATION flagValue = (PKEY_VALUE_FULL_INFORMATION)flagStorage;

	*Seeding = FALSE;

	// Read the "seedingPort" value name
	RtlInitUnicodeString (&valueName, VALUENAME_SEEDROUTER);
	registryStatus = ZwQueryValueKey(pPortDesc->pd_AdapterInfoHandle,
									 &valueName,
									 KeyValueFullInformation,
									 flagValue,
									 sizeof(flagStorage),
									 &bytesWritten);

	if (registryStatus == STATUS_SUCCESS)
	{
		seedingPortFlag = (PULONG)((PBYTE)flagValue + flagValue->DataOffset);
		if (*seedingPortFlag != 0)
		{
			*Seeding = TRUE;
			pPortDesc->pd_Flags |= PD_SEED_ROUTER;
		}
	}

	return registryStatus;
}


NTSTATUS
atalkInitPortParameters(
	OUT	PPORT_DESCRIPTOR	pPortDesc
	)
/*++

Routine Description:

	Gets the per-port parameters for the port

Arguments:

	pPortDesc- Pointer to port information structure for the port

Return Value:

	Status - STATUS_SUCCESS or system call returned status codes
--*/
{
	UNICODE_STRING	valueName;
	NTSTATUS		status;
	ULONG			bytesWritten;
	BYTE			Storage[sizeof(KEY_VALUE_FULL_INFORMATION)+4*MAX_ENTITY_LENGTH];
	PKEY_VALUE_FULL_INFORMATION pInfo = (PKEY_VALUE_FULL_INFORMATION)Storage;

	// Read the "DdpChecksums" value name
	RtlInitUnicodeString (&valueName, VALUENAME_DDPCHECKSUMS);
	status = ZwQueryValueKey(pPortDesc->pd_AdapterInfoHandle,
							 &valueName,
							 KeyValueFullInformation,
							 pInfo,
							 sizeof(Storage),
							 &bytesWritten);

	if (status == STATUS_SUCCESS)
	{
		PULONG	ddpChecksumFlag;

		ddpChecksumFlag = (PULONG)((PBYTE)pInfo + pInfo->DataOffset);
		if ((*ddpChecksumFlag) != 0)
		{
			pPortDesc->pd_Flags |= PD_SEND_CHECKSUMS;
		}
	}

	// Read the "AarpRetries" value name
	RtlInitUnicodeString (&valueName, VALUENAME_AARPRETRIES);
	status = ZwQueryValueKey(pPortDesc->pd_AdapterInfoHandle,
							 &valueName,
							 KeyValueFullInformation,
							 pInfo,
							 sizeof(Storage),
							 &bytesWritten);

	if (status == STATUS_SUCCESS)
	{
		PULONG	aarpRetries;

		aarpRetries = (PULONG)((PBYTE)pInfo + pInfo->DataOffset);
		pPortDesc->pd_AarpProbes = (USHORT)*aarpRetries;
	}

	RtlInitUnicodeString (&valueName, VALUENAME_PORTNAME);
	status = ZwQueryValueKey(pPortDesc->pd_AdapterInfoHandle,
							 &valueName,
							 KeyValueFullInformation,
							 pInfo,
							 sizeof(Storage),
							 &bytesWritten);

	do
	{
		if (status == STATUS_SUCCESS)
		{
			PWCHAR			portName;
			ANSI_STRING		ansiPort;
			UNICODE_STRING	unicodePort;
			ULONG			ansiSize;
			NTSTATUS		status;
	
			portName = (PWCHAR)((PBYTE)pInfo + pInfo->DataOffset);
			if (*portName != 0)
			{
	
				RtlInitUnicodeString(&unicodePort, portName);
				ansiSize = RtlUnicodeStringToAnsiSize(&unicodePort);
				if (ansiSize > MAX_ENTITY_LENGTH+1)
				{
					status = STATUS_UNSUCCESSFUL;

					//	Incorrect port name!
					LOG_ERRORONPORT(pPortDesc,
									EVENT_ATALK_INVALID_PORTNAME,
									status,
									NULL,
									0);
					break;
				}
	
				ansiPort.Buffer = pPortDesc->pd_PortName;
				ansiPort.MaximumLength = (USHORT)ansiSize+1;
				ansiPort.Length = 0;
			
				status = RtlUnicodeStringToAnsiString(&ansiPort,
													  &unicodePort,
													  (BOOLEAN)FALSE);
	
				if (status != STATUS_SUCCESS)
				{
					LOG_ERROR(EVENT_ATALK_RESOURCES,status, NULL, 0);
				}
			}
			else
			{
				//	NULL Port Name! Set status to unsuccessful so we copy
				//	default name at the end.
				status = STATUS_UNSUCCESSFUL;
			}
		}

	} while (FALSE);

	//	Do we need to copy the default port name?
	if (!NT_SUCCESS(status))
	{
		RtlCopyMemory(pPortDesc->pd_PortName, ATALK_PORT_NAME, ATALK_PORT_NAME_SIZE);
	}

	return status;
}


NTSTATUS
atalkInitStartPort(
	IN	OUT	PPORT_DESCRIPTOR	pPortDesc
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	ATALK_NODEADDR	Node;
	ATALK_ADDR		AtalkAddr;
	PDDP_ADDROBJ	pDdpAddr;
	KIRQL			OldIrql;
	ATALK_ERROR		error;
	ULONG			length;
	NTSTATUS		status = STATUS_UNSUCCESSFUL;
    INT             LookaheadSize;
    BOOLEAN         fPnpReconfigure;


    fPnpReconfigure = (pPortDesc->pd_Flags & PD_PNP_RECONFIGURE)? TRUE : FALSE;

	do
	{
		//	Initialize NetworkRange. We can do this here, only *after*
		//	we bind, as we dont know our port type until then.
		if (EXT_NET(pPortDesc))
		{
			pPortDesc->pd_NetworkRange.anr_FirstNetwork = FIRST_VALID_NETWORK;
			pPortDesc->pd_NetworkRange.anr_LastNetwork = LAST_STARTUP_NETWORK;
		}
		else
		{
			pPortDesc->pd_NetworkRange.anr_FirstNetwork =
			pPortDesc->pd_NetworkRange.anr_LastNetwork = UNKNOWN_NETWORK;
			pPortDesc->pd_LtNetwork = UNKNOWN_NETWORK;
		}

        //
        // only when the adapter is initialized for the first time, we need
        // to all the initialization stuff (like set lookahead size etc.).
        // If we are here because of a PnPReconfigure event, don't do it
        //
        if (!fPnpReconfigure)
        {
		    error = AtalkInitNdisQueryAddrInfo(pPortDesc);
		    if (!ATALK_SUCCESS(error))
		    {
				DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
					("atalkInitStartPort: Error in AtalkInitNdisQueryAddrInfo %lx\n", error));
			    break;
		    }

            LookaheadSize = AARPLINK_MAX_PKT_SIZE;
            if (pPortDesc->pd_NdisPortType == NdisMedium802_5)
            {
                LookaheadSize = AARPLINK_MAX_PKT_SIZE + TLAP_MAX_LINKHDR_LEN;
            }
            else if (pPortDesc->pd_NdisPortType == NdisMediumWan)
            {
                LookaheadSize = AARPLINK_MAX_PKT_SIZE + TLAP_MAX_LINKHDR_LEN;
            }

		    //	Set lookahead to be the max of the complete aarp packet including link
		    error = AtalkInitNdisSetLookaheadSize(pPortDesc, LookaheadSize);
		    if (!ATALK_SUCCESS(error))
		    {
				DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
					("atalkInitStartPort: Error in AtalkInitNdisSetLookaheadSize %lx\n", error));
			    break;
		    }

            //
            // if this is an ARAP port, we need to do a little more work (e.g. set the
            // protocol type, etc.
            //
            if (pPortDesc->pd_Flags & PD_RAS_PORT)
            {
                error = ArapAdapterInit( pPortDesc );
		        if (!ATALK_SUCCESS(error))
		        {
    	            DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                        ("ArapAdapterInit: failed (%d)\n",error));
			        break;
		        }
            }

		    if (pPortDesc->pd_AddMulticastAddr)
		    {
    			error = (*pPortDesc->pd_AddMulticastAddr)(pPortDesc,
													    pPortDesc->pd_BroadcastAddr,
													    TRUE,
													    NULL,
													    NULL);

			    if (!ATALK_SUCCESS(error))
			    {
					DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
						("atalkInitStartPort: Error in pd_AddMulticastAddr %lx\n", error));
    				break;
			    }
		    }
    			
		    error = AtalkInitNdisStartPacketReception(pPortDesc);

		    if (!ATALK_SUCCESS(error))
		    {
				DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
					("atalkInitStartPort: Error in AtalkInitNdisStartPacketReception %lx\n", error));
    			LOG_ERRORONPORT(pPortDesc,
							    EVENT_ATALK_RECEPTION,
							    0,
							    NULL,
							    0);
			    break;
		    }

        }  // if (!fPnpReconfigure)

		//	Set flag to active here. Until then all packets will be dropped
		ACQUIRE_SPIN_LOCK(&pPortDesc->pd_Lock, &OldIrql);
		pPortDesc->pd_Flags |= PD_ACTIVE;
		RELEASE_SPIN_LOCK(&pPortDesc->pd_Lock, OldIrql);

        // if this is arap port, we are done at this point
        if (pPortDesc->pd_Flags & PD_RAS_PORT)
        {
            RtlZeroMemory(pPortDesc->pd_PortStats.prtst_PortName,
                          sizeof(pPortDesc->pd_PortStats.prtst_PortName));

		    //	Set up the name in the statistics structure.
		    length = MIN(pPortDesc->pd_AdapterKey.Length,
                         ((MAX_INTERNAL_PORTNAME_LEN * sizeof(WCHAR)) - sizeof(WCHAR)));
	
		    RtlCopyMemory(pPortDesc->pd_PortStats.prtst_PortName,
					      pPortDesc->pd_AdapterKey.Buffer,
					      length);
	
		    AtalkStatistics.stat_NumActivePorts++;
	
		    AtalkNumberOfActivePorts ++;
		    status = STATUS_SUCCESS;
            break;
        }

		//	is localtalk our default port? if so, we make sure routing is not on.
		if (AtalkRouter && !EXT_NET(pPortDesc) && DEF_PORT(pPortDesc))
		{
			//	No can do.
			break;
		}

		//	We need to have a node created on every single port. If routing
		//	is on, then this will be the router node. The Default port will
		//	also have an additional user node. In the case, where we are non-
		//	routing, we should only create the user node on the default port.
		//	The other nodes will be created on the other ports as usual.
		//
		//	!!!	AtalkNodeCreateOnPort should set the pointer to the router
		//		node in the port descriptor. !!!

		//	Make sure we do not create this node if localtalk default port.
		if (!DEF_PORT(pPortDesc) || AtalkRouter)
		{
			BOOLEAN	allowstartuprange = !AtalkRouter;

			//	If router then startup range is not allowed!
			error = AtalkInitNodeCreateOnPort(pPortDesc,
											  allowstartuprange,
											  AtalkRouter,
											  &Node);
			if (!ATALK_SUCCESS(error))
			{
				LOG_ERRORONPORT(pPortDesc,
								EVENT_ATALK_INIT_COULDNOTGETNODE,
								0,
								NULL,
								0);
				DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
						("atalkInitStartPort: Failed to open node on port %lx (%Z)\n",
						pPortDesc, &pPortDesc->pd_AdapterKey));
				break;
			}
	
			if (AtalkRouter)
			{
				//	Start RTMP/ZIP Processing on this port.
				if (!AtalkInitRtmpStartProcessingOnPort(pPortDesc, &Node) ||
					!AtalkInitZipStartProcessingOnPort(pPortDesc, &Node))
				{
					break;
				}
			}

			//	Register the port name on the NIS on this node.
			AtalkAddr.ata_Network = Node.atn_Network;
			AtalkAddr.ata_Node	=   Node.atn_Node;
			AtalkAddr.ata_Socket  = NAMESINFORMATION_SOCKET;
		
			AtalkDdpReferenceByAddr(pPortDesc,
									&AtalkAddr,
									&pDdpAddr,
									&error);
		
			if (ATALK_SUCCESS(error))
			{
				PACTREQ		pActReq;
				NBPTUPLE	NbpTuple;
				
				NbpTuple.tpl_Zone[0] = '*';
				NbpTuple.tpl_ZoneLen = 1;
                NbpTuple.tpl_ObjectLen = (BYTE)strlen(pPortDesc->pd_PortName);
				RtlCopyMemory(NbpTuple.tpl_Object,
							  pPortDesc->pd_PortName,
							  NbpTuple.tpl_ObjectLen);
				if (AtalkRouter)
				{
					RtlCopyMemory(NbpTuple.tpl_Type,
								  ATALK_ROUTER_NBP_TYPE,
								  sizeof(ATALK_ROUTER_NBP_TYPE) - 1);
					NbpTuple.tpl_TypeLen = sizeof(ATALK_ROUTER_NBP_TYPE) - 1;
				}
				else
				{
					RtlCopyMemory(NbpTuple.tpl_Type,
								  ATALK_NONROUTER_NBP_TYPE,
								  sizeof(ATALK_NONROUTER_NBP_TYPE) - 1);
					NbpTuple.tpl_TypeLen = sizeof(ATALK_NONROUTER_NBP_TYPE) - 1;
				}
	
				// Initialize parameters and call AtalkNbpAction
				if ((pActReq = AtalkAllocZeroedMemory(sizeof(ACTREQ))) == NULL)
					error = ATALK_RESR_MEM;
				else
				{
#if	DBG
					pActReq->ar_Signature = ACTREQ_SIGNATURE;
#endif
					pActReq->ar_Completion = atalkRegNbpComplete;
					pActReq->ar_pParms = pPortDesc;
					AtalkLockNbpIfNecessary();
					error = AtalkNbpAction(pDdpAddr,
										   FOR_REGISTER,
										   &NbpTuple,
										   NULL,
										   0,
										   pActReq);
			
                    if (!ATALK_SUCCESS(error))
                    {
					    DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
							("atalkInitStartPort: AtalkNbpAction returned %lx\n",
							error));
                        ASSERT(0);
                        AtalkFreeMemory(pActReq);
                        AtalkUnlockNbpIfNecessary();
                    }
                    else
                    {
					    DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_WARN,
							("atalkInitStartPort: AtalkNbpAction(Register) %lx\n",
							error));
                    }
				}
				//	Remove the reference added here.
				AtalkDdpDereference(pDdpAddr);
			}
			else
			{
				LOG_ERRORONPORT(pPortDesc,
								EVENT_ATALK_INIT_NAMEREGISTERFAILED,
								AtalkErrorToNtStatus(error),
								NULL,
								0);
			}
		}

		//	If this is the default port, open the user node on it.
		if (DEF_PORT(pPortDesc))
		{
			ASSERT(!AtalkRouter || EXT_NET(pPortDesc));

			if (!ATALK_SUCCESS(AtalkInitNodeCreateOnPort(pPortDesc,
														 TRUE,
														 FALSE,
														 &Node)))
			{
				LOG_ERRORONPORT(pPortDesc,
								EVENT_ATALK_INIT_COULDNOTGETNODE,
								0,
								NULL,
								0);
				DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
						("atalkInitStartPort: Failed to open node on port %lx (%Z)\n",
						pPortDesc, &pPortDesc->pd_AdapterKey));
				break;
			}

			ACQUIRE_SPIN_LOCK(&pPortDesc->pd_Lock, &OldIrql);
			pPortDesc->pd_Flags |= PD_USER_NODE_1;
			AtalkUserNode1 = Node;
			RELEASE_SPIN_LOCK(&pPortDesc->pd_Lock, OldIrql);

			//	Register the port name on the NIS on this node.
			AtalkAddr.ata_Network = Node.atn_Network;
			AtalkAddr.ata_Node	= Node.atn_Node;
			AtalkAddr.ata_Socket  = NAMESINFORMATION_SOCKET;
			AtalkDdpReferenceByAddr(pPortDesc,
									&AtalkAddr,
									&pDdpAddr,
									&error);

			if (ATALK_SUCCESS(error))
			{
				PACTREQ		pActReq;
				NBPTUPLE	NbpTuple;
				
				NbpTuple.tpl_Zone[0] = '*';
				NbpTuple.tpl_ZoneLen = 1;
                RtlCopyMemory(NbpTuple.tpl_Object,
							  pPortDesc->pd_PortName,
							  NbpTuple.tpl_ObjectLen = (BYTE)strlen(pPortDesc->pd_PortName));
				RtlCopyMemory(NbpTuple.tpl_Type,
							  ATALK_NONROUTER_NBP_TYPE,
							  sizeof(ATALK_NONROUTER_NBP_TYPE) - 1);
				NbpTuple.tpl_TypeLen = sizeof(ATALK_NONROUTER_NBP_TYPE) - 1;

				// Initialize parameters and call AtalkNbpAction
				if ((pActReq = AtalkAllocZeroedMemory(sizeof(ACTREQ))) == NULL)
					error = ATALK_RESR_MEM;
				else
				{
#if	DBG
					pActReq->ar_Signature = ACTREQ_SIGNATURE;
#endif
					pActReq->ar_Completion = atalkRegNbpComplete;
					pActReq->ar_pParms = pPortDesc;
					AtalkLockNbpIfNecessary();
					error = AtalkNbpAction(pDdpAddr,
											FOR_REGISTER,
											&NbpTuple,
											NULL,
											0,
											pActReq);

                    if (!ATALK_SUCCESS(error))
                    {
					    DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
							("atalkInitStartPort: AtalkNbpAction returned %lx\n",
							error));
                        AtalkFreeMemory(pActReq);
                        AtalkUnlockNbpIfNecessary();
                    }
                    else
                    {
					    DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_WARN,
							("atalkInitStartPort: AtalkNbpAction(Register) %lx\n",
							error));
                    }
				}
				//	Remove the reference added here.
				AtalkDdpDereference(pDdpAddr);
			}
			else
			{
				LOG_ERRORONPORT(pPortDesc,
								EVENT_ATALK_INIT_NAMEREGISTERFAILED,
								STATUS_UNSUCCESSFUL,
								NULL,
								0);
			}

			//	If we are an extended port, we open a second node on the port.
			if (EXT_NET(pPortDesc))
			{
				if (ATALK_SUCCESS(AtalkInitNodeCreateOnPort(pPortDesc,
															 TRUE,
															 FALSE,
															 &Node)))
				{
					ACQUIRE_SPIN_LOCK(&pPortDesc->pd_Lock, &OldIrql);
					pPortDesc->pd_Flags |= PD_USER_NODE_2;
					AtalkUserNode2 = Node;
					RELEASE_SPIN_LOCK(&pPortDesc->pd_Lock, OldIrql);
				}
				else
				{
					LOG_ERRORONPORT(pPortDesc,
									EVENT_ATALK_INIT_COULDNOTGETNODE,
									0,
									NULL,
									0);

					DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
							("atalkInitStartPort: Fail 2nd node port %lx (%Z)\n",
							pPortDesc, &pPortDesc->pd_AdapterKey));
				}
			}
		}

		// Start the Amt and Brc timers for the port, only for extended ports
		if (EXT_NET(pPortDesc))
		{
			AtalkPortReferenceByPtr(pPortDesc, &error);
			if (ATALK_SUCCESS(error))
			{
				AtalkTimerInitialize(&pPortDesc->pd_BrcTimer,
									 AtalkAarpBrcTimer,
									 BRC_AGE_TIME);
				AtalkTimerScheduleEvent(&pPortDesc->pd_BrcTimer);
			}
	
			AtalkPortReferenceByPtr(pPortDesc, &error);
			if (ATALK_SUCCESS(error))
			{
				AtalkTimerInitialize(&pPortDesc->pd_AmtTimer,
									 AtalkAarpAmtTimer,
									 AMT_AGE_TIME);
				AtalkTimerScheduleEvent(&pPortDesc->pd_AmtTimer);
			}
		}

		// Start the Rtmp aging timer for non-routing case
		if (!AtalkRouter)
		{
			AtalkPortReferenceByPtr(pPortDesc, &error);
			if (!ATALK_SUCCESS(error))
			{
				break;
			}

			AtalkTimerInitialize(&pPortDesc->pd_RtmpAgingTimer,
								 AtalkRtmpAgingTimer,
								 RTMP_AGING_TIMER);
			AtalkTimerScheduleEvent(&pPortDesc->pd_RtmpAgingTimer);
		}

        RtlZeroMemory(pPortDesc->pd_PortStats.prtst_PortName,
                      sizeof(pPortDesc->pd_PortStats.prtst_PortName));

		//	Set up the name in the statistics structure.
		length = MIN(pPortDesc->pd_AdapterKey.Length,
                     ((MAX_INTERNAL_PORTNAME_LEN * sizeof(WCHAR)) - sizeof(WCHAR)));

		RtlCopyMemory(pPortDesc->pd_PortStats.prtst_PortName,
					  pPortDesc->pd_AdapterKey.Buffer,
					  length);
	
		status = STATUS_SUCCESS;

	} while (FALSE);

    //
    // in case of PnP, we want to get the stats right even in case of failure
    //
    if (fPnpReconfigure || NT_SUCCESS(status))
    {
		AtalkStatistics.stat_NumActivePorts++;
	
		AtalkNumberOfActivePorts ++;
    }

	if (!NT_SUCCESS(status))
	{
		DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
				("atalkInitStartPort: Start port failed %lx %s\n",
                status, (fPnpReconfigure)?"(during PnP)" : " "));
	}

	return status;
}




VOID
atalkRegNbpComplete(
	IN	ATALK_ERROR		Status,
	IN	PACTREQ			pActReq
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	ASSERT (VALID_ACTREQ(pActReq));

	if (ATALK_SUCCESS(Status))
	{
		DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_INFO,
				("atalkInitNbpCompletion: NBP Name registered on port %Z\n",
				&((PPORT_DESCRIPTOR)(pActReq->ar_pParms))->pd_AdapterKey));
		LOG_ERRORONPORT((PPORT_DESCRIPTOR)(pActReq->ar_pParms),
						EVENT_ATALK_INIT_NAMEREGISTERED,
						STATUS_SUCCESS,
						NULL,
						0);
	}
	else
	{
		DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
				("atalkInitNbpCompletion: Failed to register name on port %Z (%ld)\n",
				&((PPORT_DESCRIPTOR)(pActReq->ar_pParms))->pd_AdapterKey, Status));
		LOG_ERRORONPORT((PPORT_DESCRIPTOR)(pActReq->ar_pParms),
						EVENT_ATALK_INIT_NAMEREGISTERFAILED,
						STATUS_UNSUCCESSFUL,
						NULL,
						0);
	}

	AtalkFreeMemory(pActReq);
}


NTSTATUS
AtalkInitAdapter(
	IN	PUNICODE_STRING	    AdapterName,
	IN	PPORT_DESCRIPTOR	pExistingPortDesc
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PPORT_DESCRIPTOR	pPortDesc;
	KIRQL				OldIrql;
	PWCHAR				devicePrefix = L"\\Device\\";
#define					prefixLength	(sizeof(L"\\Device\\") - sizeof(WCHAR))
	UCHAR               Address[sizeof(TA_ADDRESS) + sizeof(TDI_ADDRESS_APPLETALK)];
    PTA_ADDRESS         AddressPtr;
    NTSTATUS            Status;
    UNICODE_STRING      Us;
    UNICODE_STRING      AspDeviceName;
    HANDLE              RegHandle;
    BOOLEAN             fMustBindToNdis;
    BOOLEAN             IsDefaultPort = FALSE;


    if (AdapterName)
    {
	    DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_INFO,
			("AtalkInitAdapter: Initiating bind for adapter %Z\n", AdapterName));
    }

	do
	{
		// Open the adapters section key.
		RtlInitUnicodeString(&Us, ADAPTERS_STRING);
		Status = atalkInitGetHandleToKey(&Us,
										 &RegHandle);
	
		if (!NT_SUCCESS(Status))
		{
	        DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
    			("AtalkInitAdapter: Failed to open %ws key\n", ADAPTERS_STRING));
			break;
		}

        if (pExistingPortDesc == NULL)
        {
		    //	Get the size of the string, and make sure that is it atleast
		    //	greater than the \Device prefix. Fail if not.
		    if (AdapterName->Length <= prefixLength)
		    {
			    break;
		    }

		    // Allocate space for the port descriptors. Allocate an extra DWORD
            // and set port descriptor past the first DWORD_PTR. This is a kludge to
            // force LONGLONG alignment.
		    pPortDesc =
                (PPORT_DESCRIPTOR)AtalkAllocZeroedMemory(sizeof(PORT_DESCRIPTOR) +
														 AdapterName->Length +
														 sizeof(WCHAR) +
														 sizeof(DWORD_PTR));
		    if (pPortDesc == NULL)
		    {
			    Status = STATUS_INSUFFICIENT_RESOURCES;
			    break;
		    }
	
		    // Reference the port for creation
		    pPortDesc->pd_RefCount = 1;
	
#if	DBG
		    pPortDesc->pd_Signature = PD_SIGNATURE;
#endif
		    // Copy the AdapterName and AdapterKey strings into the portdesc
		    pPortDesc->pd_AdapterName.Buffer =
                        (PWCHAR)((PBYTE)pPortDesc + sizeof(PORT_DESCRIPTOR));
		    pPortDesc->pd_AdapterName.Length = AdapterName->Length;
		    pPortDesc->pd_AdapterName.MaximumLength =
                        AdapterName->Length + sizeof(WCHAR);
		    RtlUpcaseUnicodeString(&pPortDesc->pd_AdapterName,
							   AdapterName,
							   FALSE);
		
		    pPortDesc->pd_AdapterKey.Buffer =
                (PWCHAR)((PBYTE)pPortDesc->pd_AdapterName.Buffer + prefixLength);
		    pPortDesc->pd_AdapterKey.Length =
                pPortDesc->pd_AdapterName.Length - prefixLength;
		    pPortDesc->pd_AdapterKey.MaximumLength =
                pPortDesc->pd_AdapterName.MaximumLength - prefixLength;

            // buffer for this will be allocated later
            pPortDesc->pd_FriendlyAdapterName.Buffer = NULL;
            pPortDesc->pd_FriendlyAdapterName.MaximumLength = 0;
            pPortDesc->pd_FriendlyAdapterName.Length = 0;

		    //	Now initialize any other fields that need to be.
		    INITIALIZE_SPIN_LOCK(&pPortDesc->pd_Lock);
		
		    InitializeListHead(&pPortDesc->pd_ReceiveQueue);

            // only in case of a Ras port will these lists head be used
		    InitializeListHead(&pPortDesc->pd_ArapConnHead);
		    InitializeListHead(&pPortDesc->pd_PPPConnHead);
		
		    //	Initialize the events in the port descriptor
		    KeInitializeEvent(&pPortDesc->pd_RequestEvent, NotificationEvent, FALSE);
		
		    KeInitializeEvent(&pPortDesc->pd_SeenRouterEvent, NotificationEvent, FALSE);
		
		    KeInitializeEvent(&pPortDesc->pd_NodeAcquireEvent, NotificationEvent, FALSE);

		    fMustBindToNdis = TRUE;
        }
        else
        {
            pPortDesc = pExistingPortDesc;
		    fMustBindToNdis = FALSE;
        }

		if ((AtalkDefaultPortName.Buffer != NULL) &&
				(RtlEqualUnicodeString(&pPortDesc->pd_AdapterName,
		    					  &AtalkDefaultPortName,
			    				  TRUE)))
		{
			// Used for tracking Default Port for error message logging
			IsDefaultPort = TRUE;
			pPortDesc->pd_Flags |= PD_DEF_PORT;
	
		    pPortDesc->pd_InitialDesiredZone = AtalkDesiredZone;
		    if (AtalkDesiredZone != NULL)
			    AtalkZoneReferenceByPtr(pPortDesc->pd_InitialDesiredZone);
		}

		// Link it in the global list
		ACQUIRE_SPIN_LOCK(&AtalkPortLock, &OldIrql);
		pPortDesc->pd_Next = AtalkPortList;
		AtalkPortList = pPortDesc;
		AtalkNumberOfPorts ++;
		RELEASE_SPIN_LOCK(&AtalkPortLock, OldIrql);

        if (fMustBindToNdis)
        {
            // bind to the adapter
		    Status = AtalkNdisInitBind(pPortDesc);

            if (NT_SUCCESS(Status))
            {
	            DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
			        ("Bind done for %Z\n", (pPortDesc->pd_FriendlyAdapterName.Buffer) ?
                        (&pPortDesc->pd_FriendlyAdapterName) :
                        (&pPortDesc->pd_AdapterName)));
            }
            else
            {
	            DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
			        ("AtalkInitAdapter: AtalkNdisInitBind failed (0x%lx) for adapter %Z\n",
                    Status,AdapterName));
            }
        }
        else
        {
            Status = STATUS_SUCCESS;
        }

		if (Status == NDIS_STATUS_SUCCESS)
		{
            Status = STATUS_SUCCESS;
	
			DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_INFO,
			        ("AtalkInitAdapter: Going into atalkInitPort (0x%lx) for adapter %Z\n",
                    Status,AdapterName));

		    // Get per port parameters (ARAP port doesn't have any parms to get)
            if (!(pPortDesc->pd_Flags & PD_RAS_PORT))
            {
		        Status = atalkInitPort(pPortDesc, RegHandle);
            }

		    if (NT_SUCCESS(Status))
			{
				DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_INFO,
			        ("AtalkInitAdapter: atalkInitPort succeeded (0x%lx) for adapter %Z\n",
                    Status,AdapterName));
				// And start the port
				Status = atalkInitStartPort(pPortDesc);
				if (NT_SUCCESS(Status) && (pPortDesc->pd_Flags & PD_DEF_PORT))
				{
					DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_INFO,
			        	("AtalkInitAdapter: atalkInitStartPort succeeded (0x%lx) for adapter %Z\n",
                    Status,AdapterName));
                    //
                    // if we were doing PnP, we are done with the PnP at this point:
                    // clear the flag, so macfile can do its things...
                    //
	                ACQUIRE_SPIN_LOCK(&pPortDesc->pd_Lock, &OldIrql);
	                pPortDesc->pd_Flags &= ~PD_PNP_RECONFIGURE;
	                RELEASE_SPIN_LOCK(&pPortDesc->pd_Lock, OldIrql);

					//	Set the global default port value
					AtalkDefaultPort = pPortDesc;
					KeSetEvent(&AtalkDefaultPortEvent, IO_NETWORK_INCREMENT, FALSE);

                    // Now tell TDI that we are up and ready for binding
		            RtlInitUnicodeString(&AspDeviceName, ATALKASPS_DEVICENAME);

					DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_INFO,
			        	("AtalkInitAdapter: Calling TdiRegisterDeviceObject for adapter %Z\n",
                    AdapterName));

                    Status = TdiRegisterDeviceObject(
                                    &AspDeviceName,
                                    &TdiRegistrationHandle);

                    if (!NT_SUCCESS(Status))
                    {
                        DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
                            ( "TdiRegisterDeviceObject failed with %lx\n", Status));

                        TdiRegistrationHandle = NULL;
                    }
                    else
                    {
                        DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_INFO,
                            ( "TdiRegisterDeviceObject succeeded\n"));

                        AddressPtr = (PTA_ADDRESS)Address;
                        RtlZeroMemory(Address, sizeof(Address));
                        AddressPtr->AddressLength = sizeof(TDI_ADDRESS_APPLETALK);
                        AddressPtr->AddressType = TDI_ADDRESS_TYPE_APPLETALK;

                        Status = TdiRegisterNetAddress(AddressPtr,
                                                       &pPortDesc->pd_AdapterName,
                                                       NULL,
                                                       &TdiAddressChangeRegHandle);
                        if (!NT_SUCCESS(Status))
                        {
	                        DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
	                            ("AtalkInitAdapter: TdiRegisterNetAddress failed %lx\n",Status));

                            TdiAddressChangeRegHandle = NULL;
                        }
                        else
                        {

                            DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_INFO,
                                ("AtalkInitAdapter: TdiRegisterNetAddress on %Z done\n",
                                &pPortDesc->pd_AdapterName));

                            ASSERT(TdiAddressChangeRegHandle != NULL);
                        }

                    }
				}
                else if (!NT_SUCCESS(Status))
                {
			        DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
					    ( "AtalkInitBinding: atalkInitStartPort failed (%lx) on %Z\n",
                        Status, &pPortDesc->pd_AdapterName));
                }
			}
			else
			{
				DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
			        ("AtalkInitAdapter: atalkInitPort failed (0x%lx) for adapter %Z\n",
                    Status,AdapterName));
			}

			if (pPortDesc->pd_AdapterInfoHandle != NULL)
			{
				ZwClose(pPortDesc->pd_AdapterInfoHandle);
				pPortDesc->pd_AdapterInfoHandle = NULL;
			}
		}

		else
		{
            ASSERT(AdapterName != NULL);

			DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
					( "AtalkInitBinding failed (%lx) on %Z\n", Status, AdapterName));

            if (pPortDesc->pd_FriendlyAdapterName.Buffer)
            {
                AtalkFreeMemory(pPortDesc->pd_FriendlyAdapterName.Buffer);
            }

            AtalkFreeMemory(pPortDesc);
		}
	} while (FALSE);

	// Close the Adapters Key
	if (RegHandle != NULL)
		ZwClose (RegHandle);

    //
    // if we just successfully initialized default adapter or the RAS adapter,
    // let RAS know about it
    //
    if ( (NT_SUCCESS(Status)) &&
         (pPortDesc->pd_Flags & (PD_RAS_PORT | PD_DEF_PORT)) )
    {
		DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
			("AtalkInitAdapter: %s adapter initialized (%lx), informing RAS\n",
            (pPortDesc->pd_Flags & PD_RAS_PORT)? "RAS" : "Default",pPortDesc));

        AtalkPnPInformRas(TRUE);
    }
    else
    {
        if (IsDefaultPort)
        {
            LOG_ERROR(EVENT_ATALK_NO_DEFAULTPORT, Status, NULL, 0);
            DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
                ("WARNING!!! Appletalk driver running, but no default port configured\n"));
        }
    }

    return Status;
}


NTSTATUS
AtalkDeinitAdapter(
	IN	PPORT_DESCRIPTOR	pPortDesc
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_INFO,
			("AtalkDeinitAdapter: Initiating un-bind for adapter %Z\n",
			&pPortDesc->pd_AdapterName));


	AtalkPortShutdown(pPortDesc);

	return STATUS_SUCCESS;
}


#ifdef	ALLOC_DATA_PRAGMA
#pragma data_seg("PAGE")
#endif

ACTION_DISPATCH	AtalkActionDispatch[MAX_ALLACTIONCODES+1] =
{
	//
	// NBP dispatch functions
	//

	{
		sizeof(NBP_LOOKUP_ACTION),
		COMMON_ACTION_NBPLOOKUP,
		(DFLAG_CNTR | DFLAG_ADDR | DFLAG_MDL),
		sizeof(NBP_LOOKUP_ACTION),
		ATALK_DEV_ANY,
		AtalkNbpTdiAction
	},
	{
		sizeof(NBP_CONFIRM_ACTION),
		COMMON_ACTION_NBPCONFIRM,
		(DFLAG_CNTR | DFLAG_ADDR),
		sizeof(NBP_CONFIRM_ACTION),
		ATALK_DEV_ANY,
		AtalkNbpTdiAction
	},
	{
		sizeof(NBP_REGDEREG_ACTION),
		COMMON_ACTION_NBPREGISTER,
		DFLAG_ADDR,
		sizeof(NBP_REGDEREG_ACTION),
		ATALK_DEV_ANY,
		AtalkNbpTdiAction
	},
	{
		sizeof(NBP_REGDEREG_ACTION),
		COMMON_ACTION_NBPREMOVE,
		DFLAG_ADDR,
		sizeof(NBP_REGDEREG_ACTION),
		ATALK_DEV_ANY,
		AtalkNbpTdiAction
	},

	//
	// ZIP dispatch functions
	//

	{
		sizeof(ZIP_GETMYZONE_ACTION),
		COMMON_ACTION_ZIPGETMYZONE,
		(DFLAG_CNTR | DFLAG_ADDR | DFLAG_MDL),
		sizeof(ZIP_GETMYZONE_ACTION),
		ATALK_DEV_ANY,
		AtalkZipTdiAction
	},
	{
		sizeof(ZIP_GETZONELIST_ACTION),
		COMMON_ACTION_ZIPGETZONELIST,
		(DFLAG_CNTR | DFLAG_ADDR | DFLAG_MDL),
		sizeof(ZIP_GETZONELIST_ACTION),
		ATALK_DEV_ANY,
		AtalkZipTdiAction
	},
	{
		sizeof(ZIP_GETZONELIST_ACTION),
		COMMON_ACTION_ZIPGETLZONES,
		(DFLAG_CNTR | DFLAG_ADDR | DFLAG_MDL),
		sizeof(ZIP_GETZONELIST_ACTION),
		ATALK_DEV_ANY,
		AtalkZipTdiAction
	},
	{
		sizeof(ZIP_GETZONELIST_ACTION),
		COMMON_ACTION_ZIPGETLZONESONADAPTER,
		(DFLAG_CNTR | DFLAG_ADDR | DFLAG_MDL),
		sizeof(ZIP_GETZONELIST_ACTION),
		ATALK_DEV_ANY,
		AtalkZipTdiAction
	},
	{
		sizeof(ZIP_GETPORTDEF_ACTION),
		COMMON_ACTION_ZIPGETADAPTERDEFAULTS,
		(DFLAG_CNTR | DFLAG_ADDR | DFLAG_MDL),
		sizeof(ZIP_GETPORTDEF_ACTION),
		ATALK_DEV_ANY,
		AtalkZipTdiAction
	},
	{
		sizeof(ATALK_STATS) +
		sizeof(GET_STATISTICS_ACTION),
		COMMON_ACTION_GETSTATISTICS,
		(DFLAG_CNTR | DFLAG_ADDR | DFLAG_MDL),
		sizeof(GET_STATISTICS_ACTION),
		ATALK_DEV_ANY,
		AtalkStatTdiAction
	},

	//
	// ADSP dispatch functions
	//

	{
		sizeof(ADSP_FORWARDRESET_ACTION),
		ACTION_ADSPFORWARDRESET,
		(DFLAG_CONN),
		sizeof(ADSP_FORWARDRESET_ACTION),
		ATALK_DEV_ADSP,
		AtalkAdspTdiAction
	},

	//
	// ASPC Dispatch functions
	//

	{
		sizeof(ASPC_GETSTATUS_ACTION),
		ACTION_ASPCGETSTATUS,
		(DFLAG_ADDR | DFLAG_MDL),
		sizeof(ASPC_GETSTATUS_ACTION),
		ATALK_DEV_ASPC,
		AtalkAspCTdiAction
	},
	{
		sizeof(ASPC_COMMAND_OR_WRITE_ACTION),
		ACTION_ASPCCOMMAND,
		(DFLAG_CONN | DFLAG_MDL),
		sizeof(ASPC_COMMAND_OR_WRITE_ACTION),
		ATALK_DEV_ASPC,
		AtalkAspCTdiAction
	},
	{
		sizeof(ASPC_COMMAND_OR_WRITE_ACTION),
		ACTION_ASPCWRITE,
		(DFLAG_CONN | DFLAG_MDL),
		sizeof(ASPC_COMMAND_OR_WRITE_ACTION),
		ATALK_DEV_ASPC,
		AtalkAspCTdiAction
	},
	//
	// NBP dispatch functions used by atalk
	// winsock helper dll's SetService Api
	//
	{
		sizeof(NBP_REGDEREG_ACTION),
		COMMON_ACTION_NBPREGISTER_BY_ADDR,
		DFLAG_ADDR,
		sizeof(NBP_REGDEREG_ACTION),
		ATALK_DEV_ANY,
		AtalkNbpTdiAction
	},
	{
		sizeof(NBP_REGDEREG_ACTION),
		COMMON_ACTION_NBPREMOVE_BY_ADDR,
		DFLAG_ADDR,
		sizeof(NBP_REGDEREG_ACTION),
		ATALK_DEV_ANY,
		AtalkNbpTdiAction
	},
	{
		sizeof(ASPC_RESERVED_ACTION),
		ACTION_ASPCRESERVED3,
		(DFLAG_ADDR),
		sizeof(ASPC_RESERVED_ACTION),
		ATALK_DEV_ASPC,
		AtalkAspCTdiAction
	},

	//
	// ASP Dispatch functions
	//

	{
		sizeof(ASP_BIND_ACTION),
		ACTION_ASP_BIND,
		(DFLAG_ADDR),
		sizeof(ASP_BIND_ACTION),
		ATALK_DEV_ASP,
		AtalkAspTdiAction
	},

	//
	// PAP dispatch routines
	//
	{
		sizeof(PAP_GETSTATUSSRV_ACTION),
		ACTION_PAPGETSTATUSSRV,
		(DFLAG_ADDR | DFLAG_CNTR | DFLAG_MDL),
		sizeof(PAP_GETSTATUSSRV_ACTION),
		ATALK_DEV_PAP,
		AtalkPapTdiAction
	},
	{
		sizeof(PAP_SETSTATUS_ACTION),
		ACTION_PAPSETSTATUS,
		(DFLAG_ADDR | DFLAG_MDL),
		sizeof(PAP_SETSTATUS_ACTION),
		ATALK_DEV_PAP,
		AtalkPapTdiAction
	},
	{
		sizeof(PAP_PRIMEREAD_ACTION),
		ACTION_PAPPRIMEREAD,
		(DFLAG_CONN | DFLAG_MDL),
		0,								// !!!NOTE!!!
		ATALK_DEV_PAP,					// We set the offset to be 0. We want the
		AtalkPapTdiAction				// complete buffer to be used for read data
										// overwriting action header to preserve
	}									// winsock read model.
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\atalk\sys\atkinit.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

	atkinit.h

Abstract:

	This module contains definitions for init time routines.

Author:

	Jameel Hyder (jameelh@microsoft.com)
	Nikhil Kamkolkar (nikhilk@microsoft.com)

Revision History:
	19 Jun 1992		Initial Version

Notes:	Tab stop: 4
--*/

#ifndef	_ATKINIT_
#define	_ATKINIT_

//  Winsock related constants used during initialization util routines
#define PROTOCOLTYPE_PREFIX	 		L"\\"
#define SOCKETSTREAM_SUFFIX	 		L"\\Stream"
#define SOCKET_TYPE_UNDEFINED		0
#define PROTOCOL_TYPE_UNDEFINED 	0
#define SOCKET_TYPE_STREAM			1
#define SOCKET_TYPE_RDM		 		2

#define	ATALK_PORT_NAME				"Microsoft\250 Windows 2000\252 Prt"
#define	ATALK_PORT_NAME_SIZE		(strlen(ATALK_PORT_NAME) + 1)
#define	ATALK_ROUTER_NBP_TYPE		"Microsoft\250 Windows 2000\252 Rtr"
#define	ATALK_ROUTER_NBP_SIZE		(strlen(ATALK_ROUTER_NBP_TYPE) + 1)
#define	ATALK_NONROUTER_NBP_TYPE	ATALK_PORT_NAME
#define	ATALK_NONROUTER_NBP_SIZE	(strlen(ATALK_NONROUTER_NBP_TYPE) + 1)

//	Registry parameters keys that we use and expect

#define LINKAGE_STRING				L"Linkage"
#define PARAMETERS_STRING			L"Parameters"
#define ADAPTERS_STRING				L"Parameters\\Adapters"
#define RAS_ADAPTER_NAME            L"\\DEVICE\\NDISWANATALK"
#define BIND_STRING					L"Bind"

#define VALUENAME_NETUPPEREND		L"NetworkRangeUpperEnd"
#define VALUENAME_NETLOWEREND		L"NetworkRangeLowerEnd"
#define VALUENAME_ZONELIST			L"ZoneList"
#define VALUENAME_DEFAULTZONE		L"DefaultZone"
#define VALUENAME_PORTNAME			L"PortName"
#define VALUENAME_DDPCHECKSUMS		L"DdpChecksums"
#define VALUENAME_AARPRETRIES		L"AarpRetries"
#define	VALUENAME_SEEDROUTER		L"SeedingNetwork"

#define VALUENAME_ENABLEROUTER		L"EnableRouter"
#define VALUENAME_DEFAULTPORT		L"DefaultPort"
#define VALUENAME_DESIREDZONE		L"DesiredZone"
#define VALUENAME_FILTEROURNAMES	L"FilterOurNames"

NTSTATUS
AtalkInitializeTransport (
	IN	PDRIVER_OBJECT			pDrvObj,
	IN	PUNICODE_STRING			pRegPath
);

NTSTATUS
AtalkInitAdapter(
	IN	PUNICODE_STRING			AdapterName,
	IN	PPORT_DESCRIPTOR		pExistingPortDesc
);

NTSTATUS
AtalkDeinitAdapter(
	IN	PPORT_DESCRIPTOR		pPortDesc
);

NTSTATUS
atalkInitGetHandleToKey(
	IN	PUNICODE_STRING			KeyName,
	OUT	PHANDLE 				KeyHandle
);

NTSTATUS
atalkInitGlobal(
	VOID
);

NTSTATUS
atalkInitPort(
	IN	PPORT_DESCRIPTOR		pPortDesc,
	IN	HANDLE					AdaptersKeyHandle
);

NTSTATUS
atalkInitNetRangeCheck(
	IN	PPORT_DESCRIPTOR		pPortDesc
);

NTSTATUS
atalkInitNetRange(
	OUT		PPORT_DESCRIPTOR	pPortDesc
);

NTSTATUS
atalkInitZoneList(
	OUT		PPORT_DESCRIPTOR	pPortDesc
);

NTSTATUS
atalkInitDefZone(
	OUT		PPORT_DESCRIPTOR	pPortDesc
);

NTSTATUS
atalkInitSeeding(
	IN OUT	PPORT_DESCRIPTOR	pPortDesc,
	OUT		PBOOLEAN			Seeding
);

NTSTATUS
atalkInitPortParameters(
	OUT		PPORT_DESCRIPTOR	pPortDesc
);

NTSTATUS
atalkInitStartPort(
	IN	PPORT_DESCRIPTOR		pPortDesc
);

VOID
atalkRegNbpComplete(
	IN	ATALK_ERROR				Status,
	IN	PACTREQ					pActReq
);

#if DBG

VOID
atalkInitPrintPortInfo(
	VOID
);

#endif

#endif	// _ATKINIT_


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\atalk\sys\atkerror.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

	atkerror.c

Abstract:

	This module contains the event logging and all error log code.

Author:

	Jameel Hyder (jameelh@microsoft.com)
	Nikhil Kamkolkar (nikhilk@microsoft.com)

Revision History:
	19 Jun 1992		Initial Version

Notes:	Tab stop: 4
--*/

#include <atalk.h>
#pragma hdrstop
#define	FILENUM	ATKERROR


LONG		AtalkLastRawDataLen	= 0;
NTSTATUS	AtalkLastErrorCode	= STATUS_SUCCESS;
ULONG		AtalkLastErrorCount	= 0;
LONG		AtalkLastErrorTime  = 0;
BYTE		AtalkLastRawData[PORT_MAXIMUM_MESSAGE_LENGTH - \
							 sizeof(IO_ERROR_LOG_PACKET)]	= {0};

VOID
AtalkWriteErrorLogEntry(
	IN	PPORT_DESCRIPTOR	pPortDesc			OPTIONAL,
    IN	NTSTATUS 			UniqueErrorCode,
    IN	ULONG    			UniqueErrorValue,
    IN	NTSTATUS 			NtStatusCode,
    IN	PVOID    			RawDataBuf			OPTIONAL,
    IN	LONG     			RawDataLen
    )
/*++

Routine Description:


Arguments:


Return Value:


--*/
{

    PIO_ERROR_LOG_PACKET 	errorLogEntry;
    int 					AdapterNameLen = 0;
    PUNICODE_STRING         pAdapterName = NULL;

    if (pPortDesc != NULL)
	{
        // do we have the friendly name (always yes, unless mem alloc failed)
        if (pPortDesc->pd_FriendlyAdapterName.Buffer)
        {
            pAdapterName = &pPortDesc->pd_FriendlyAdapterName;
        }
        else
        {
            pAdapterName = &pPortDesc->pd_AdapterKey;
        }

		AdapterNameLen += pAdapterName->Length;
	}

	//ASSERT ((AdapterNameLen + sizeof(IO_ERROR_LOG_PACKET)) <
							//PORT_MAXIMUM_MESSAGE_LENGTH);

#if DBG
    if ((AdapterNameLen + sizeof(IO_ERROR_LOG_PACKET)) > PORT_MAXIMUM_MESSAGE_LENGTH)
    {
        DBGPRINT(DBG_COMP_UTILS, DBG_LEVEL_ERR,
				("AtalkWriteErrorLogEntry: Adapter Name for Port Descriptor has length = %d, which is greater than space allocated for it in the port message buffer = %d. The adapter name will be truncated in the log.\n", AdapterNameLen, PORT_MAXIMUM_MESSAGE_LENGTH-sizeof(IO_ERROR_LOG_PACKET)));
	}
#endif

    // make sure the adaptername isn't huge: if it is, chop it
    if ((AdapterNameLen + sizeof(IO_ERROR_LOG_PACKET)) > PORT_MAXIMUM_MESSAGE_LENGTH)
    {
        AdapterNameLen = PORT_MAXIMUM_MESSAGE_LENGTH - sizeof(IO_ERROR_LOG_PACKET);
    }

    //
    if ((RawDataLen + AdapterNameLen + sizeof(IO_ERROR_LOG_PACKET)) >
											PORT_MAXIMUM_MESSAGE_LENGTH)
    {
		RawDataLen = PORT_MAXIMUM_MESSAGE_LENGTH -
				        (AdapterNameLen + sizeof(IO_ERROR_LOG_PACKET));
    }

	// Filter out events such that the same event recurring close together does not
	// cause errorlog clogging. The scheme is - if the event is same as the last event
	// and the elapsed time is > THRESHOLD and ERROR_CONSEQ_FREQ simulataneous errors
	// have happened, then log it else skip
	if (UniqueErrorCode == AtalkLastErrorCode)
	{
		AtalkLastErrorCount++;
		if ((AtalkLastRawDataLen == RawDataLen)					&&
			(AtalkFixedCompareCaseSensitive(AtalkLastRawData,
											RawDataLen,
											RawDataBuf,
											RawDataLen))		&&
			((AtalkLastErrorCount % ERROR_CONSEQ_FREQ) != 0)	&&
			((AtalkGetCurrentTick() - AtalkLastErrorTime) < ERROR_CONSEQ_TIME))
		{
			return;
		}
	}

	AtalkLastErrorCode	= UniqueErrorCode;
	AtalkLastErrorCount	= 0;
	AtalkLastErrorTime  = AtalkGetCurrentTick();
	ASSERT(RawDataLen < (PORT_MAXIMUM_MESSAGE_LENGTH -
						 sizeof(IO_ERROR_LOG_PACKET)));

	if (RawDataLen != 0)
	{
	    AtalkLastRawDataLen = RawDataLen;
		RtlCopyMemory(
			AtalkLastRawData,
			RawDataBuf,
			RawDataLen);
	}

	errorLogEntry =
        (PIO_ERROR_LOG_PACKET)IoAllocateErrorLogEntry(
                                    (PDEVICE_OBJECT)AtalkDeviceObject[0],
                                    (UCHAR)(sizeof(IO_ERROR_LOG_PACKET) +
									AdapterNameLen + RawDataLen));

    if (errorLogEntry != NULL)
    {
        // Fill in the Error log entry
        errorLogEntry->ErrorCode = UniqueErrorCode;
        errorLogEntry->UniqueErrorValue = UniqueErrorValue;
        errorLogEntry->MajorFunctionCode = 0;
        errorLogEntry->RetryCount = 0;
        errorLogEntry->FinalStatus = NtStatusCode;
        errorLogEntry->IoControlCode = 0;
        errorLogEntry->DeviceOffset.LowPart = 0;
        errorLogEntry->DeviceOffset.HighPart = 0;
        errorLogEntry->DumpDataSize = (USHORT)RawDataLen;

        errorLogEntry->StringOffset =
            (USHORT)(FIELD_OFFSET(IO_ERROR_LOG_PACKET, DumpData) + RawDataLen);

        errorLogEntry->NumberOfStrings = (ARGUMENT_PRESENT(pPortDesc)) ? 1 : 0;

        if (ARGUMENT_PRESENT(RawDataBuf))
        {
			ASSERT(RawDataLen > 0);
            RtlCopyMemory((PCHAR)&errorLogEntry->DumpData[0], RawDataBuf, RawDataLen);
        }

        if (ARGUMENT_PRESENT(pPortDesc))
		{
            RtlCopyMemory((PCHAR)errorLogEntry->DumpData + RawDataLen,
						  pAdapterName->Buffer,
						  AdapterNameLen);
        }

        // Write the entry
        IoWriteErrorLogEntry(errorLogEntry);
    }
	else
	{
		DBGPRINT(DBG_ALL, DBG_LEVEL_FATAL,
			("AtalkWriteErrorLogEntry: IoAllocErrorlogEntry Failed %d = %d+%d+%d\n",
            sizeof(IO_ERROR_LOG_PACKET)+AdapterNameLen+RawDataLen,
            sizeof(IO_ERROR_LOG_PACKET),AdapterNameLen,RawDataLen));
	}
}



VOID
AtalkLogBadPacket(
	IN	struct _PORT_DESCRIPTOR	*	pPortDesc,
	IN	PATALK_ADDR					pSrcAddr,
	IN	PATALK_ADDR					pDstAddr	OPTIONAL,
	IN	PBYTE						pPkt,
	IN	USHORT	 					PktLen
	)
{
	PBYTE	RawData;

	if ((RawData = AtalkAllocMemory(PktLen + sizeof(ATALK_ADDR) + sizeof(ATALK_ADDR))) != NULL)
	{
		RtlCopyMemory(RawData,
					  pSrcAddr,
					  sizeof(ATALK_ADDR));
		if (ARGUMENT_PRESENT(pDstAddr))
		{
			RtlCopyMemory(RawData + sizeof(ATALK_ADDR),
						  pDstAddr,
						  sizeof(ATALK_ADDR));
		}
		else RtlZeroMemory(RawData + sizeof(ATALK_ADDR), sizeof(ATALK_ADDR));
		RtlCopyMemory(RawData + sizeof(ATALK_ADDR) + sizeof(ATALK_ADDR),
					  pPkt,
					  PktLen);
		LOG_ERRORONPORT(pPortDesc,
						EVENT_ATALK_PACKETINVALID,
						0,
						RawData,
						PktLen + sizeof(ATALK_ADDR) + sizeof(ATALK_ADDR));
		AtalkFreeMemory(RawData);
	}
}

struct _NdisToAtalkCodes
{
	NDIS_STATUS	_NdisCode;
	ATALK_ERROR	_AtalkCode;
} atalkNdisToAtalkCodes[] =
	{
		{ NDIS_STATUS_SUCCESS,				ATALK_NO_ERROR				},
		{ NDIS_STATUS_PENDING,				ATALK_PENDING               },
		{ NDIS_STATUS_RESOURCES,			ATALK_RESR_MEM              },
		{ NDIS_STATUS_UNSUPPORTED_MEDIA,	ATALK_INIT_MEDIA_INVALID    },
		{ NDIS_STATUS_BAD_VERSION,			ATALK_INIT_REGPROTO_FAIL    },
		{ NDIS_STATUS_BAD_CHARACTERISTICS,	ATALK_INIT_REGPROTO_FAIL    },
		{ NDIS_STATUS_BUFFER_TOO_SHORT,		ATALK_BUFFER_TOO_SMALL      },
		{ NDIS_STATUS_ADAPTER_NOT_FOUND,	ATALK_INIT_BINDFAIL         },
		{ NDIS_STATUS_OPEN_FAILED,			ATALK_INIT_BINDFAIL         },
		{ NDIS_STATUS_OPEN_LIST_FULL,		ATALK_INIT_BINDFAIL         },
		{ NDIS_STATUS_ADAPTER_NOT_READY,	ATALK_INIT_BINDFAIL         }
	};

ATALK_ERROR FASTCALL
AtalkNdisToAtalkError(
	IN	NDIS_STATUS	Error
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	ATALK_ERROR	err = ATALK_FAILURE;	// default
	int			i;
	struct _NdisToAtalkCodes *pCodes;

	for (i = 0, pCodes = &atalkNdisToAtalkCodes[0];
		 i < sizeof(atalkNdisToAtalkCodes)/sizeof(struct _NdisToAtalkCodes);
		 i++, pCodes++)
	{
		if (pCodes->_NdisCode == Error)
		{
			err = pCodes->_AtalkCode;
			break;
		}
	}

	return(err);
}




struct _AtalkToNtCodes
{
	ATALK_ERROR	_AtalkCode;
	NTSTATUS	_NtCode;
} atalkToNtCodes[] =
	{
		{ ATALK_NO_ERROR,				STATUS_SUCCESS							},
		{ ATALK_PENDING,				STATUS_PENDING                          },
		{ ATALK_RESR_MEM,				STATUS_INSUFFICIENT_RESOURCES           },
		{ ATALK_CONNECTION_TIMEOUT,		STATUS_REMOTE_DISCONNECT                },
		{ ATALK_LOCAL_CLOSE,			STATUS_LOCAL_DISCONNECT                 },
		{ ATALK_REMOTE_CLOSE,			STATUS_REMOTE_DISCONNECT                },
		{ ATALK_INVALID_PARAMETER,		STATUS_INVALID_PARAMETER                },
		{ ATALK_BUFFER_TOO_SMALL,		STATUS_BUFFER_TOO_SMALL                 },
		{ ATALK_INVALID_REQUEST,		STATUS_REQUEST_NOT_ACCEPTED             },
		{ ATALK_DEVICE_NOT_READY,		STATUS_DEVICE_NOT_READY                 },
		{ ATALK_REQUEST_NOT_ACCEPTED,	STATUS_REQUEST_NOT_ACCEPTED             },
		{ ATALK_NEW_SOCKET,				STATUS_INVALID_ADDRESS                  },
		{ ATALK_TIMEOUT,				STATUS_IO_TIMEOUT                       },
		{ ATALK_SHARING_VIOLATION,		STATUS_SHARING_VIOLATION                },
		{ ATALK_INIT_BINDFAIL,			(NTSTATUS)NDIS_STATUS_OPEN_FAILED       },
		{ ATALK_INIT_REGPROTO_FAIL,		(NTSTATUS)NDIS_STATUS_BAD_VERSION       },
		{ ATALK_INIT_MEDIA_INVALID,		(NTSTATUS)NDIS_STATUS_UNSUPPORTED_MEDIA },
		{ ATALK_PORT_INVALID,			STATUS_INVALID_PORT_HANDLE              },
		{ ATALK_PORT_CLOSING,			STATUS_PORT_DISCONNECTED                },
		{ ATALK_NODE_FINDING,			STATUS_TOO_MANY_COMMANDS                },
		{ ATALK_NODE_NONEXISTENT,		STATUS_INVALID_ADDRESS_COMPONENT        },
		{ ATALK_NODE_CLOSING,			STATUS_ADDRESS_CLOSED                   },
		{ ATALK_NODE_NOMORE,			STATUS_TOO_MANY_NODES                   },
		{ ATALK_SOCKET_INVALID,			STATUS_INVALID_ADDRESS_COMPONENT        },
		{ ATALK_SOCKET_NODEFULL,		STATUS_TOO_MANY_ADDRESSES               },
		{ ATALK_SOCKET_EXISTS,			STATUS_ADDRESS_ALREADY_EXISTS           },
		{ ATALK_SOCKET_CLOSED,			STATUS_ADDRESS_CLOSED                   },
		{ ATALK_DDP_CLOSING,			STATUS_ADDRESS_CLOSED                   },
		{ ATALK_DDP_NOTFOUND,			STATUS_INVALID_ADDRESS                  },
		{ ATALK_DDP_INVALID_LEN,		STATUS_INVALID_PARAMETER                },
		{ ATALK_DDP_INVALID_SRC,		STATUS_INVALID_ADDRESS                  },
		{ ATALK_DDP_INVALID_DEST,		STATUS_INVALID_ADDRESS                  },
		{ ATALK_DDP_INVALID_ADDR,		STATUS_INVALID_ADDRESS                  },
		{ ATALK_DDP_INVALID_PARAM,		STATUS_INVALID_PARAMETER                },
		{ ATALK_ATP_RESP_TIMEOUT,		STATUS_SUCCESS                          },
		{ ATALK_ATP_INVALID_RETRYCNT,	STATUS_INVALID_PARAMETER                },
		{ ATALK_ATP_INVALID_TIMERVAL,	STATUS_INVALID_PARAMETER                },
		{ ATALK_ATP_INVALID_RELINT,		STATUS_INVALID_PARAMETER                },
		{ ATALK_ATP_RESP_CANCELLED,		STATUS_CANCELLED                        },
		{ ATALK_ATP_REQ_CANCELLED,		STATUS_CANCELLED                        },
		{ ATALK_ATP_GET_REQ_CANCELLED,	STATUS_CANCELLED                        },
		{ ATALK_ASP_INVALID_REQUEST,	STATUS_REQUEST_NOT_ACCEPTED             },
    	{ ATALK_PAP_INVALID_REQUEST,	STATUS_REQUEST_NOT_ACCEPTED             },
    	{ ATALK_PAP_TOO_MANY_READS,		STATUS_TOO_MANY_COMMANDS                },
    	{ ATALK_PAP_TOO_MANY_WRITES,	STATUS_TOO_MANY_COMMANDS                },
    	{ ATALK_PAP_CONN_NOT_ACTIVE,	STATUS_INVALID_CONNECTION               },
    	{ ATALK_PAP_ADDR_CLOSING,		STATUS_INVALID_HANDLE                   },
    	{ ATALK_PAP_CONN_CLOSING,		STATUS_INVALID_HANDLE                   },
    	{ ATALK_PAP_CONN_NOT_FOUND,		STATUS_INVALID_HANDLE                   },
		{ ATALK_PAP_SERVER_BUSY,		STATUS_REMOTE_NOT_LISTENING             },
    	{ ATALK_PAP_INVALID_STATUS,		STATUS_INVALID_PARAMETER                },
		{ ATALK_PAP_PARTIAL_RECEIVE,	STATUS_RECEIVE_PARTIAL                  },
		{ ATALK_ADSP_INVALID_REQUEST,	STATUS_REQUEST_NOT_ACCEPTED             },
		{ ATALK_ADSP_CONN_NOT_ACTIVE,	STATUS_INVALID_CONNECTION               },
		{ ATALK_ADSP_ADDR_CLOSING,		STATUS_INVALID_HANDLE                   },
		{ ATALK_ADSP_CONN_CLOSING,		STATUS_INVALID_HANDLE                   },
		{ ATALK_ADSP_CONN_NOT_FOUND,	STATUS_INVALID_HANDLE                   },
		{ ATALK_ADSP_CONN_RESET,		STATUS_CONNECTION_RESET                 },
		{ ATALK_ADSP_SERVER_BUSY,		STATUS_REMOTE_NOT_LISTENING             },
		{ ATALK_ADSP_PARTIAL_RECEIVE,	STATUS_RECEIVE_PARTIAL                  },
		{ ATALK_ADSP_EXPED_RECEIVE,		STATUS_RECEIVE_EXPEDITED                },
		{ ATALK_ADSP_PAREXPED_RECEIVE,	STATUS_RECEIVE_PARTIAL_EXPEDITED        },
		{ ATALK_ADSP_REMOTE_RESR,		STATUS_REMOTE_RESOURCES        			}
	};

NTSTATUS FASTCALL
AtalkErrorToNtStatus(
    ATALK_ERROR	AtalkError
    )
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    NTSTATUS    Status = STATUS_UNSUCCESSFUL;	// default
	int			i;
	struct _AtalkToNtCodes *pCodes;

	for (i = 0, pCodes = &atalkToNtCodes[0];
		 i < sizeof(atalkToNtCodes)/sizeof(struct _AtalkToNtCodes);
		 i++, pCodes++)
	{
		if (pCodes->_AtalkCode == AtalkError)
		{
			Status = pCodes->_NtCode;
			break;
		}
	}

    return(Status);
}




#if	DBG

struct
{
	ULONG			DumpMask;
	DUMP_ROUTINE	DumpRoutine;
} AtalkDumpTable[32] =
{
	{ DBG_DUMP_PORTINFO,			AtalkPortDumpInfo },
	{ DBG_DUMP_AMT,					AtalkAmtDumpTable },
	{ DBG_DUMP_ZONETABLE,			AtalkZoneDumpTable },
	{ DBG_DUMP_RTES,				AtalkRtmpDumpTable },
	{ DBG_DUMP_TIMERS,				AtalkTimerDumpList },
	{ DBG_DUMP_ATPINFO,				NULL },
	{ DBG_DUMP_ASPSESSIONS,			AtalkAspDumpSessions },
	{ DBG_DUMP_PAPJOBS,				NULL },
	{ 0,							NULL },
	{ 0,							NULL },
	{ 0,							NULL },
	{ 0,							NULL },
	{ 0,							NULL },
	{ 0,							NULL },
	{ 0,							NULL },
	{ 0,							NULL },
	{ 0,							NULL },
	{ 0,							NULL },
	{ 0,							NULL },
	{ 0,							NULL },
	{ 0,							NULL },
	{ 0,							NULL },
	{ 0,							NULL },
	{ 0,							NULL },
	{ 0,							NULL },
	{ 0,							NULL },
	{ 0,							NULL },
	{ 0,							NULL },
	{ 0,							NULL },
	{ 0,							NULL },
	{ 0,							NULL },
	{ 0,							NULL }
};

LONG FASTCALL
AtalkDumpComponents(
	IN	PTIMERLIST	Context,
	IN	BOOLEAN		TimerShuttingDown
)
{
	int		i;

	if (!TimerShuttingDown)
	{
		for (i = 0;AtalkDebugDump && (i < 32); i++)
		{
			if ((AtalkDebugDump & AtalkDumpTable[i].DumpMask) &&
				(AtalkDumpTable[i].DumpRoutine != NULL))
			{
				(*AtalkDumpTable[i].DumpRoutine)();
			}
		}
	
		if (AtalkDumpInterval == 0)
		{
			AtalkDumpInterval = DBG_DUMP_DEF_INTERVAL;
		}
	}
	else AtalkDumpInterval = ATALK_TIMER_NO_REQUEUE;

	return AtalkDumpInterval;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\atalk\sys\atkmem.c ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	atkmem.c

Abstract:

	This module contains the routines which allocates and free memory. Only
	the non-paged pool is used.

	!!! For profiling, we use spinlock acquire/release for CurAllocCount/CurAllocSize

Author:

	Nikhil Kamkolkar	(NikhilK@microsoft.com)
	Jameel Hyder (JameelH@microsoft.com)

Revision History:
	25 Apr 1992	 Initial Version (JameelH)

--*/

#include <atalk.h>
#pragma hdrstop
#define	FILENUM	ATKMEM

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, AtalkInitMemorySystem)
#pragma alloc_text(PAGE, AtalkDeInitMemorySystem)
#endif


VOID
AtalkInitMemorySystem(
	VOID
)
{
	LONG	i;

	for (i = 0; i < NUM_BLKIDS; i++)
		INITIALIZE_SPIN_LOCK(&atalkBPLock[i]);

	AtalkTimerInitialize(&atalkBPTimer,
						 atalkBPAgePool,
						 BLOCK_POOL_TIMER);
	AtalkTimerScheduleEvent(&atalkBPTimer);
}


VOID
AtalkDeInitMemorySystem(
	VOID
)
{
	LONG		i, j, NumBlksPerChunk;
	PBLK_CHUNK	pChunk, pFree;
	
	for (i = 0; i < NUM_BLKIDS; i++)
	{
		NumBlksPerChunk = atalkNumBlks[i];
		for (pChunk = atalkBPHead[i];
			 pChunk != NULL;
			 NOTHING)
		{
			DBGPRINT(DBG_COMP_RESOURCES, DBG_LEVEL_INFO,
					("AtalkDeInitMemorySystem: Freeing %lx\n", pChunk));
			if ((pChunk->bc_NumFree != NumBlksPerChunk) ||
				(pChunk->bc_NumAlloc != 0))
			{
				DBGPRINT(DBG_COMP_RESOURCES, DBG_LEVEL_ERR,
						("AtalkDeInitMemorySystem: Unfreed blocks from blockid %d, Chunk %lx\n",
						i, pChunk));
				ASSERT(0);
			}

			if (pChunk->bc_BlkId >= BLKID_NEED_NDIS_INT)
			{
				PBLK_HDR	pBlkHdr;

				// We need to free the Ndis stuff for these guys
				for (j = 0, pBlkHdr = pChunk->bc_FreeHead;
					 j < NumBlksPerChunk;
					 j++, pBlkHdr = pBlkHdr->bh_Next)
				{
					PBUFFER_HDR	pBufHdr;

					pBufHdr = (PBUFFER_HDR)((PBYTE)pBlkHdr + sizeof(BLK_HDR));
					ASSERT(pBufHdr->bh_NdisPkt == NULL);
					AtalkNdisFreeBuffer(pBufHdr->bh_NdisBuffer);
				}
			}
			pFree = pChunk;
			pChunk = pChunk->bc_Next;
			AtalkFreeMemory(pFree);
		}
		atalkBPHead[i] = NULL;
	}
}


PVOID FASTCALL
AtalkAllocMem(
#ifdef	TRACK_MEMORY_USAGE
	IN	ULONG	Size,
	IN	ULONG	FileLine
#else
	IN	ULONG	Size
#endif	// TRACK_MEMORY_USAGE
)
/*++

Routine Description:

	Allocate a block of non-paged memory. This is just a wrapper over ExAllocPool.
 	Allocation failures are error-logged. We always allocate a ULONG more than
 	the specified size to accomodate the size. This is used by AtalkFreeMemory
 	to update the statistics.

Arguments:


Return Value:


--*/
{
	PBYTE	pBuf;
	BOOLEAN	zeroed;
#ifdef	PROFILING
	TIME	TimeS, TimeE, TimeD;
#endif

	//	round up the size so that we can put a signature at the end
	//	that is on a ULONG boundary
	zeroed = ((Size & ZEROED_MEMORY_TAG) == ZEROED_MEMORY_TAG);

	Size = DWORDSIZEBLOCK(Size & ~ZEROED_MEMORY_TAG) +
#if	DBG
			sizeof(DWORD) +				// For the signature
#endif
			sizeof(ULONG_PTR);

#ifdef	PROFILING
	TimeS = KeQueryPerformanceCounter(NULL);
#endif

	// Do the actual memory allocation. Allocate four extra bytes so
	// that we can store the size of the allocation for the free routine.
	if ((pBuf = ExAllocatePoolWithTag(NonPagedPool, Size, ATALK_TAG)) == NULL)
	{
		LOG_ERROR(EVENT_ATALK_MEMORYRESOURCES, STATUS_INSUFFICIENT_RESOURCES, NULL, 0);
		DBGPRINT(DBG_COMP_RESOURCES, DBG_LEVEL_FATAL,
				("AtalkAllocMemory: failed - size %lx\n", Size));
		return NULL;
	}

#ifdef	PROFILING
	INTERLOCKED_INCREMENT_LONG(&AtalkStatistics.stat_CurAllocCount,
							   &AtalkStatsLock.SpinLock);
	INTERLOCKED_INCREMENT_LONG(&AtalkStatistics.stat_ExAllocPoolCount,
							   &AtalkStatsLock.SpinLock);
	TimeE = KeQueryPerformanceCounter(NULL);
	TimeD.QuadPart = TimeE.QuadPart - TimeS.QuadPart;
	INTERLOCKED_ADD_LARGE_INTGR(&AtalkStatistics.stat_ExAllocPoolTime,
								 TimeD,
								 &AtalkStatsLock.SpinLock);
#endif

	INTERLOCKED_ADD_ULONG(&AtalkStatistics.stat_CurAllocSize,
						  Size,
						  &AtalkStatsLock.SpinLock);

	ASSERTMSG("AtalkAllocMemory: Allocation has exceeded Limit !!!\n",
				AtalkStatistics.stat_CurAllocSize < (ULONG)AtalkMemLimit);

	// Save the size of this block in the four extra bytes we allocated.
	*((PULONG)pBuf) = Size;

#if DBG
	*((PULONG)(pBuf+Size-sizeof(ULONG))) = ATALK_MEMORY_SIGNATURE;
	DBGPRINT(DBG_COMP_RESOURCES, DBG_LEVEL_INFO,
			("AtalkAllocMemory: Allocated %lx bytes @%lx\n", Size, pBuf));
#endif

	AtalkTrackMemoryUsage((PVOID)pBuf, Size, TRUE, FileLine);

#if	DBG
	Size -= sizeof(ULONG);
#endif

	pBuf += sizeof(ULONG_PTR);

	if (zeroed)
	{
		RtlZeroMemory(pBuf, Size - sizeof(ULONG_PTR));
	}

	// Return a pointer to the memory after the size longword.
	return (pBuf);
}




VOID FASTCALL
AtalkFreeMemory(
	IN	PVOID	pBuf
	)
/*++

Routine Description:

 	Free the block of memory allocated via AtalkAllocMemory. This is
 	a wrapper around ExFreePool.

Arguments:


Return Value:


--*/
{
	PULONG 	pRealBuffer;
	ULONG	Size;
#ifdef	PROFILING
	TIME	TimeS, TimeE, TimeD;
#endif

	// Get a pointer to the block allocated by ExAllocatePool.
	pRealBuffer = (PULONG)((PCHAR)pBuf - sizeof(ULONG_PTR));
	Size = *pRealBuffer;

	AtalkTrackMemoryUsage(pRealBuffer, Size, FALSE, 0);

#if	DBG
	*pRealBuffer = 0;
	// Check the signature at the end
	if (*(PULONG)((PCHAR)pRealBuffer + Size - sizeof(ULONG))
											!= ATALK_MEMORY_SIGNATURE)
	{
		DBGPRINT(DBG_COMP_RESOURCES, DBG_LEVEL_FATAL,
				("AtalkFreeMemory: Memory overrun on block %lx\n", pRealBuffer));
		ASSERT(0);
	}
	*(PULONG)((PCHAR)pRealBuffer + Size - sizeof(ULONG)) = 0;
#endif

	INTERLOCKED_ADD_ULONG(&AtalkStatistics.stat_CurAllocSize,
						  -(LONG)Size,
						  &AtalkStatsLock.SpinLock);
#ifdef	PROFILING
	INTERLOCKED_DECREMENT_LONG(&AtalkStatistics.stat_CurAllocCount,
							   &AtalkStatsLock);
	INTERLOCKED_INCREMENT_LONG(&AtalkStatistics.stat_ExFreePoolCount,
							   &AtalkStatsLock);
	TimeS = KeQueryPerformanceCounter(NULL);
#endif

	// Free the pool and return.
	ExFreePool(pRealBuffer);

#ifdef	PROFILING
	TimeE = KeQueryPerformanceCounter(NULL);
	TimeD.QuadPart = TimeE.QuadPart - TimeS.QuadPart;
	INTERLOCKED_ADD_LARGE_INTGR(&AtalkStatistics.stat_ExFreePoolTime,
								 TimeD,
								 &AtalkStatsLock.SpinLock);
#endif
}




PBUFFER_DESC
AtalkDescribeBufferDesc(
	IN	PVOID	DataPtr,
	IN	PVOID	FreePtr,
	IN	USHORT	Length,
#ifdef	TRACK_BUFFDESC_USAGE
	IN	USHORT	Flags,
	IN	ULONG	FileLine
#else
	IN	USHORT	Flags
#endif
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PBUFFER_DESC	pBuffDesc;

	if ((pBuffDesc = AtalkAllocBufferDesc(DataPtr,
										  Length,
#ifdef	TRACK_BUFFDESC_USAGE
										  Flags,
										  FileLine
#else
										  Flags
#endif
		)) != NULL)
	{
		pBuffDesc->bd_FreeBuffer = FreePtr;
	}

	return pBuffDesc;
}




PBUFFER_DESC
AtalkAllocBufferDesc(
	IN	PVOID	Ptr	OPTIONAL,
	IN	USHORT	Length,
#ifdef	TRACK_BUFFDESC_USAGE
	IN	USHORT	Flags,
	IN	ULONG	FileLine
#else
	IN	USHORT	Flags
#endif
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PBUFFER_DESC	pBuffDesc = NULL;

	DBGPRINT(DBG_COMP_RESOURCES, DBG_LEVEL_INFO,
			("AtalkAllocBuffDesc: Ptr %lx, Length %x, Flags %x\n",
			Ptr, Length, Flags));


	pBuffDesc = AtalkBPAllocBlock(BLKID_BUFFDESC);

	if (pBuffDesc != NULL)
	{
#if	DBG
		pBuffDesc->bd_Signature = BD_SIGNATURE;
#endif
		pBuffDesc->bd_Length = Length;
		pBuffDesc->bd_Flags = Flags;
		pBuffDesc->bd_Next = NULL;

		//	Depending on whether a char buffer or a PAMDL is being
		//	passed in...
		if (Flags & BD_CHAR_BUFFER)
		{
			if ((Ptr == NULL) &&
				((Ptr = AtalkAllocMemory(Length)) == NULL))
			{
				pBuffDesc->bd_Flags = 0;
				pBuffDesc->bd_CharBuffer = NULL;
				AtalkFreeBuffDesc(pBuffDesc);
				pBuffDesc = NULL;
			}
			else
			{
				pBuffDesc->bd_CharBuffer = pBuffDesc->bd_FreeBuffer = Ptr;
				AtalkTrackBuffDescUsage(pBuffDesc, TRUE, FileLine);
			}
		}
		else
		{
			pBuffDesc->bd_OpaqueBuffer = (PAMDL)Ptr;
		}
	}

	return pBuffDesc;
}




VOID FASTCALL
AtalkFreeBuffDesc(
	IN	PBUFFER_DESC	pBuffDesc
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	ASSERT(VALID_BUFFDESC(pBuffDesc));

	if ((pBuffDesc->bd_Flags & (BD_FREE_BUFFER | BD_CHAR_BUFFER)) ==
									(BD_FREE_BUFFER | BD_CHAR_BUFFER))
		AtalkFreeMemory(pBuffDesc->bd_FreeBuffer);
	AtalkTrackBuffDescUsage(pBuffDesc, FALSE, 0);

	AtalkBPFreeBlock(pBuffDesc);
}




VOID
AtalkCopyBuffDescToBuffer(
	IN	PBUFFER_DESC	pBuffDesc,
	IN	LONG			SrcOff,
	IN	LONG			BytesToCopy,
	IN	PBYTE			DstBuf
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	NTSTATUS	Status;
	ULONG		BytesCopied;
	LONG		Index = 0;

	ASSERT(VALID_BUFFDESC(pBuffDesc));

	while ((pBuffDesc != NULL) &&
		   (SrcOff > (LONG)pBuffDesc->bd_Length))
	{
		SrcOff -= pBuffDesc->bd_Length;
		pBuffDesc = pBuffDesc->bd_Next;
	}

	do
	{
		LONG	ThisCopy;

		if (pBuffDesc == NULL)
			break;

		ThisCopy = BytesToCopy;
		if (ThisCopy > ((LONG)pBuffDesc->bd_Length - SrcOff))
			ThisCopy = ((LONG)pBuffDesc->bd_Length - SrcOff);
		BytesToCopy -= ThisCopy;

		if (pBuffDesc->bd_Flags & BD_CHAR_BUFFER)
		{
			RtlCopyMemory(DstBuf + Index,
						  pBuffDesc->bd_CharBuffer + SrcOff,
						  ThisCopy);
		}
		else
		{
			Status = TdiCopyMdlToBuffer(pBuffDesc->bd_OpaqueBuffer,
										SrcOff,
										DstBuf + Index,
										0,
										ThisCopy,
										&BytesCopied);
			ASSERT(NT_SUCCESS(Status) && (BytesCopied == (ULONG)ThisCopy));
		}
		Index += ThisCopy;
		SrcOff -= (pBuffDesc->bd_Length - ThisCopy);
		pBuffDesc = pBuffDesc->bd_Next;
	} while (BytesToCopy > 0);
}




VOID
AtalkCopyBufferToBuffDesc(
	IN	PBYTE			SrcBuf,
	IN	LONG			BytesToCopy,
	IN	PBUFFER_DESC	pBuffDesc,
	IN	LONG			DstOff
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	NTSTATUS	Status;
	LONG		Index = 0;

	ASSERT(VALID_BUFFDESC(pBuffDesc));

	while ((DstOff > (LONG)pBuffDesc->bd_Length) &&
		   (pBuffDesc != NULL))
	{
		DstOff -= pBuffDesc->bd_Length;
		pBuffDesc = pBuffDesc->bd_Next;
	}

	do
	{
		LONG	ThisCopy;

		if (pBuffDesc == NULL)
			break;

		ThisCopy = BytesToCopy;
		if (ThisCopy > ((LONG)pBuffDesc->bd_Length - DstOff))
			ThisCopy = ((LONG)pBuffDesc->bd_Length - DstOff);
		BytesToCopy -= ThisCopy;

		if (pBuffDesc->bd_Flags & BD_CHAR_BUFFER)
		{
			RtlCopyMemory(pBuffDesc->bd_CharBuffer + DstOff,
						  SrcBuf + Index,
						  ThisCopy);
		}
		else
		{
			Status = TdiCopyBufferToMdl(SrcBuf,
										Index,
										ThisCopy,
										pBuffDesc->bd_OpaqueBuffer,
										DstOff,
										(PULONG)&ThisCopy);
			ASSERT(NT_SUCCESS(Status) && (ThisCopy == BytesToCopy));
		}
		Index += ThisCopy;
		DstOff -= (pBuffDesc->bd_Length - ThisCopy);
		pBuffDesc = pBuffDesc->bd_Next;
	} while (BytesToCopy > 0);
}




LONG FASTCALL
AtalkSizeBuffDesc(
	IN	PBUFFER_DESC	pBuffDesc
	)
/*++

Routine Description:


Arguments:


Return Value:

--*/
{
	LONG	Size;

	ASSERT(VALID_BUFFDESC(pBuffDesc));

	for (Size = 0; pBuffDesc != NULL; pBuffDesc = pBuffDesc->bd_Next)
		Size += (LONG)pBuffDesc->bd_Length;
	return(Size);
}


PAMDL
AtalkSubsetAmdl(
	IN	PAMDL	pStartingMdl,
	IN	ULONG	TotalOffset,
	IN	ULONG	DesiredLength
	)
/*++

Routine Description:

	This routine is called to build an Mdl chain from a source Mdl chain and
	offset into it. We assume we don't know the length of the source Mdl chain,
	and we must allocate and build the Mdls for the destination chain, which
	we do from non-paged pool. Note that this routine, unlike the IO subsystem
	routines, sets the SystemVaMapped bit in the generated Mdls to the same
	value as that in the source Mdls.
	
	IT WOULD BE BAD TO USE MmMapLockedPages OR MmProbeAndLockPages ON THE
	DESTINATION MDLS UNLESS YOU TAKE RESPONSIBILITY FOR UNMAPPING THEM!
	
	The MDLs that are returned are mapped and locked. (Actually, the pages in
	them are in the same state as those in the source MDLs.)
	
	If the system runs out of memory while we are building the destination
	MDL chain, we completely clean up the built chain and return with
	NewCurrentMdl and NewByteOffset set to the current values of CurrentMdl
	and TotalOffset. TRUELength is set to 0.

Environment:

	Kernel Mode, Source Mdls locked. It is recommended, although not required,
	that the source Mdls be mapped and locked prior to calling this routine.

Arguments:

	pStartingMdl			- the source appletalk mdl ( == nt mdl)
	TotalOffset 		- Offset within this MDL to start the packet at.
	DesiredLength 	- The number of bytes to insert into the packet.

Return Value:

	pointer to build mdl, NULL if out of resources, or lengths inconsistent.

--*/
{
	PMDL 	Destination=NULL;

	PBYTE 	BaseVa;
	ULONG 	NewMdlLength;
	PMDL 	NewMdl;
    PMDL    pMdl;

	PMDL 	CurrentMdl = (PMDL)pStartingMdl;
    ULONG   CurrentOffset = TotalOffset;
    ULONG   BytesToDescribe = DesiredLength;


    //
    // first make sure that we have enough bytes!
    //
    if (DesiredLength > (ULONG)AtalkSizeMdlChain(pStartingMdl))
    {
	    DBGPRINT(DBG_COMP_UTILS, DBG_LEVEL_ERR,
		    ("AtalkSubsetMdl: req len (%ld) exceeds avl len (%ld) for mdl %lx\n",
		    DesiredLength, AtalkSizeMdlChain(pStartingMdl),pStartingMdl));

        ASSERT(0);
	    return(NULL);
    }

    //
    // first, get to the right Mdl (in most cases, the same as pStartingMdl)
    //
    while (CurrentMdl && (CurrentOffset >= MmGetMdlByteCount (CurrentMdl)))
    {
        CurrentOffset -= MmGetMdlByteCount (CurrentMdl);
        CurrentMdl = CurrentMdl->Next;
        ASSERT(CurrentMdl != NULL);
    }

    while (BytesToDescribe)
    {
        ASSERT(CurrentMdl != NULL);

	    BaseVa = (PBYTE)MmGetMdlVirtualAddress(CurrentMdl) + CurrentOffset;
	    NewMdlLength 	= MmGetMdlByteCount (CurrentMdl) - CurrentOffset;

        // if Mdl has more bytes than what's needed, set available to what's needed
        if (NewMdlLength > BytesToDescribe)
        {
            NewMdlLength = BytesToDescribe;
        }

	    pMdl = IoAllocateMdl(BaseVa,
		    			     NewMdlLength,
			    			 FALSE,
				    		 FALSE,
					    	 NULL);

        // store the first mdl for return
        if (!Destination)
        {
	        Destination = pMdl;

            // subsequent Mdl's must start with offset 0!!
            CurrentOffset = 0;
        }
        else
        {
            // link-in to the earlier mdl
            NewMdl->Next = pMdl;
        }

        NewMdl = pMdl;

        if (pMdl != NULL)
        {
            ATALK_DBG_INC_COUNT(AtalkDbgMdlsAlloced);

#ifdef	PROFILING
		    INTERLOCKED_INCREMENT_LONG(
			    &AtalkStatistics.stat_CurMdlCount,
			    &AtalkStatsLock.SpinLock);
#endif
		    IoBuildPartialMdl(CurrentMdl,
			    			  pMdl,
				    		  BaseVa,
					    	  NewMdlLength);
        }
        else
        {
            // free up whatever was allocated so far
            while (Destination)
            {
                pMdl = Destination->Next;
                IoFreeMdl(Destination);
                ATALK_DBG_DEC_COUNT(AtalkDbgMdlsAlloced);
                Destination = pMdl;
            }
        }

        BytesToDescribe -= NewMdlLength;
        CurrentMdl = CurrentMdl->Next;
    }

    return(Destination);

}




PAMDL
AtalkAllocAMdl(
	IN	PBYTE	pBuffer	OPTIONAL,
	IN	LONG	Size
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PMDL	pMdl = NULL;

	if (pBuffer == NULL)
	{
		pBuffer = AtalkAllocMemory(Size);
	}

	if ((pBuffer == NULL) ||
		((pMdl = IoAllocateMdl(pBuffer, Size, FALSE, FALSE, NULL)) == NULL))
	{
		LOG_ERROR(EVENT_ATALK_RESOURCES, STATUS_INSUFFICIENT_RESOURCES, NULL, 0);
	}
#ifdef	PROFILING
	else
	{
		INTERLOCKED_INCREMENT_LONG(
			&AtalkStatistics.stat_CurMdlCount,
			&AtalkStatsLock.SpinLock);
	}
#endif

	if (pMdl != NULL)
    {
        ATALK_DBG_INC_COUNT(AtalkDbgMdlsAlloced);

		MmBuildMdlForNonPagedPool(pMdl);
    }

	return(pMdl);
}




LONG FASTCALL
AtalkSizeMdlChain(
	IN	PAMDL	pAMdlChain
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	LONG	Size;

	for (Size = 0; pAMdlChain != NULL; pAMdlChain = pAMdlChain->Next)
	{
		Size += MmGetMdlByteCount(pAMdlChain);
	}
	return(Size);
}



/***	AtalkBPAllocBlock
 *
 *	Alloc a block of memory from the block pool package. This is written to speed up
 *	operations where a lot of small fixed size allocations/frees happen. Going to
 *	ExAllocPool() in these cases is expensive.
 *
 *	It is important to keep the list of blocks in such a way that all completely free
 *	blocks are at the tail end of the list.
 */
PVOID FASTCALL
AtalkBPAllocBlock(
	IN	BLKID	BlockId
)
{
	PBLK_HDR			pBlk = NULL;
	PBLK_CHUNK			pChunk, *ppChunkHead;
	KIRQL				OldIrql;
	USHORT				BlkSize;
	ATALK_SPIN_LOCK *	pLock;
	NDIS_STATUS			ndisStatus;
#ifdef	PROFILING
	TIME				TimeS, TimeE, TimeD;

	TimeS = KeQueryPerformanceCounter(NULL);
#endif

	ASSERT (BlockId < NUM_BLKIDS);

	BlkSize = atalkBlkSize[BlockId];
	ppChunkHead = &atalkBPHead[BlockId];

	pLock = &atalkBPLock[BlockId];
	ACQUIRE_SPIN_LOCK(pLock, &OldIrql);

	if ((pChunk = *ppChunkHead) != NULL)
	{
		ASSERT(VALID_BC(pChunk));
		ASSERT(pChunk->bc_BlkId == BlockId);
		ASSERT((pChunk->bc_NumFree + pChunk->bc_NumAlloc) == atalkNumBlks[BlockId]);

		if (pChunk->bc_NumFree > 0)
		{
			// This is where we take it off from
			DBGPRINT(DBG_COMP_SYSTEM, DBG_LEVEL_INFO,
					("AtalkBPAllocBlock: Found space in Chunk %lx\n", pChunk));
#ifdef	PROFILING
			INTERLOCKED_INCREMENT_LONG( &AtalkStatistics.stat_NumBPHits,
										&AtalkStatsLock.SpinLock);
#endif
		}

		if (pChunk->bc_NumFree == 0)
		{
			// We do not have space on any of the chunks on this list
			ASSERT(pChunk->bc_NumAlloc == atalkNumBlks[BlockId]);
			pChunk = NULL;
		}
	}
	
	if (pChunk == NULL)
	{
		DBGPRINT(DBG_COMP_SYSTEM, DBG_LEVEL_INFO,
				("AtalkBPAllocBlock: Allocating a new chunk for Id %d\n", BlockId));

#ifdef	PROFILING
		INTERLOCKED_INCREMENT_LONG( &AtalkStatistics.stat_NumBPMisses,
									&AtalkStatsLock.SpinLock);
#endif
		pChunk = AtalkAllocMemory(atalkChunkSize[BlockId]);
		if (pChunk != NULL)
		{
			LONG		i, j;
			PBLK_HDR	pBlkHdr;
			PBUFFER_HDR	pBufHdr;
			USHORT		NumBlksPerChunk;

#if	DBG
			pChunk->bc_Signature = BC_SIGNATURE;
			pChunk->bc_NumAlloc = 0;
#endif
			NumBlksPerChunk = atalkNumBlks[BlockId];
			ASSERT (NumBlksPerChunk <= 0xFF);
			pChunk->bc_NumFree = (BYTE)NumBlksPerChunk;
			pChunk->bc_BlkId = BlockId;
			pChunk->bc_FreeHead = (PBLK_HDR)((PBYTE)pChunk + sizeof(BLK_CHUNK));

			DBGPRINT(DBG_COMP_SYSTEM, DBG_LEVEL_INFO,
			    ("AtalkBPAllocBlock: Initializing chunk %lx, BlkId=%d\n", pChunk,BlockId));

			// Initialize the blocks in the chunk
			for (i = 0, pBlkHdr = pChunk->bc_FreeHead;
				 i < NumBlksPerChunk;
				 i++, pBlkHdr = pBlkHdr->bh_Next)
			{
				LONG		Size;
#if	DBG
				pBlkHdr->bh_Signature = BH_SIGNATURE;
#endif
				pBlkHdr->bh_Next = (i == (NumBlksPerChunk-1)) ?
										NULL :
										(PBLK_HDR)((PBYTE)pBlkHdr + BlkSize);

				if (BlockId >= BLKID_NEED_NDIS_INT)
				{
                    PCHAR   pStartOfBuf;

					// We need to initialize the Ndis stuff for these guys
					pBufHdr = (PBUFFER_HDR)((PBYTE)pBlkHdr + sizeof(BLK_HDR));

					pBufHdr->bh_NdisPkt = NULL;

                    if (BlockId == BLKID_SENDBUF)
                    {
                        Size = sizeof(BUFFER_HDR) + sizeof(BUFFER_DESC);
                        pStartOfBuf = (PCHAR)pBufHdr + Size;
                    }
                    else if ((BlockId == BLKID_MNP_SMSENDBUF) ||
                             (BlockId == BLKID_MNP_LGSENDBUF) )
                    {
                        // NOTE: the 1 byte of Buffer[1], combined with aligning
                        // effect screws up Size (it's 3 more than what we think!)
                        Size = sizeof(MNPSENDBUF);
                        pStartOfBuf = &(((PMNPSENDBUF)pBufHdr)->Buffer[0]);
                    }
                    else
                    {
                        Size = sizeof(BUFFER_HDR);
                        pStartOfBuf = (PCHAR)pBufHdr + Size;
                    }

					//  Make a NDIS buffer descriptor for this data
					NdisAllocateBuffer(&ndisStatus,
									   &pBufHdr->bh_NdisBuffer,
									   AtalkNdisBufferPoolHandle,
									   pStartOfBuf,
									   (UINT)(BlkSize - sizeof(BLK_HDR) - Size));
				
					if (ndisStatus != NDIS_STATUS_SUCCESS)
					{
						LOG_ERROR(EVENT_ATALK_NDISRESOURCES, ndisStatus, NULL, 0);

		                DBGPRINT(DBG_COMP_SYSTEM, DBG_LEVEL_ERR,
				            ("NdisAllocateBuffer: Ndis Out-of-Resource condition hit\n"));

                        ASSERT(0);
						break;
					}
				
                    ATALK_DBG_INC_COUNT(AtalkDbgMdlsAlloced);

					// More processing for send buffers
					if ((BlockId == BLKID_SENDBUF) ||
                        (BlockId == BLKID_MNP_SMSENDBUF) ||
                        (BlockId == BLKID_MNP_LGSENDBUF))
					{
						PSENDBUF		pSendBuf;
						PBUFFER_DESC	pBuffDesc;
	                    PMNPSENDBUF	    pMnpSendBuf;

					    if (BlockId == BLKID_SENDBUF)
                        {
						    pSendBuf = (PSENDBUF)pBufHdr;
						    pBuffDesc = &pSendBuf->sb_BuffDesc;
						    pBuffDesc->bd_Length 	= MAX_SENDBUF_LEN;
						    pBuffDesc->bd_CharBuffer= pSendBuf->sb_Space;
                        }
                        else if (BlockId == BLKID_MNP_SMSENDBUF)
                        {
						    pMnpSendBuf = (PMNPSENDBUF)pBufHdr;
                            pMnpSendBuf->DataSize = 0;
                            pMnpSendBuf->FreeBuffer = &pMnpSendBuf->Buffer[0];
						    pBuffDesc = &pMnpSendBuf->sb_BuffDesc;
						    pBuffDesc->bd_Length 	= MNP_MINSEND_LEN;
						    pBuffDesc->bd_CharBuffer= &pMnpSendBuf->Buffer[0];
                        }
                        else // if (BlockId == BLKID_MNP_LGSENDBUF)
                        {
						    pMnpSendBuf = (PMNPSENDBUF)pBufHdr;
                            pMnpSendBuf->DataSize = 0;
                            pMnpSendBuf->FreeBuffer = &pMnpSendBuf->Buffer[0];
						    pBuffDesc = &pMnpSendBuf->sb_BuffDesc;
						    pBuffDesc->bd_Length 	= MNP_MAXSEND_LEN;
						    pBuffDesc->bd_CharBuffer= &pMnpSendBuf->Buffer[0];
                        }
#if	DBG
						pBuffDesc->bd_Signature = BD_SIGNATURE;
#endif
						pBuffDesc->bd_Flags 	= BD_CHAR_BUFFER;
						pBuffDesc->bd_Next 		= NULL;
						pBuffDesc->bd_FreeBuffer= NULL;
					}
				}

			}
			if (i != NumBlksPerChunk)
			{
				// This has to be a failure from Ndis !!!
				// Undo a bunch of stuff
				ASSERT (BlockId >= BLKID_NEED_NDIS_INT);
				DBGPRINT(DBG_COMP_SYSTEM, DBG_LEVEL_ERR,
						("AtalkBPAllocBlock: Freeing new chunk (Ndis failure) Id %d\n",
						BlockId));
				pBlkHdr = pChunk->bc_FreeHead;
				for (j = 0, pBlkHdr = pChunk->bc_FreeHead;
					 j < i; j++, pBlkHdr = pBlkHdr->bh_Next)
				{
					PBUFFER_HDR	pBufHdr;

					pBufHdr = (PBUFFER_HDR)((PBYTE)pBlkHdr + sizeof(BLK_HDR));
					AtalkNdisFreeBuffer(pBufHdr->bh_NdisBuffer);
				}
				AtalkFreeMemory(pChunk);
				pChunk = NULL;
			}
			else
			{
				// Successfully initialized the chunk, link it in
				AtalkLinkDoubleAtHead(*ppChunkHead, pChunk, bc_Next, bc_Prev);
#if	DBG
				atalkNumChunksForId[BlockId] ++;
#endif
			}
		}
	}	
	if (pChunk != NULL)
	{
		PBLK_CHUNK	pTmp;

		ASSERT(VALID_BC(pChunk));
		ASSERT(pChunk->bc_BlkId == BlockId);
		DBGPRINT(DBG_COMP_RESOURCES, DBG_LEVEL_INFO,
				("AtalkBPAllocBlock: Allocating a block out of chunk %lx(%d,%d) for Id %d\n",
				pChunk, pChunk->bc_NumFree, pChunk->bc_NumAlloc, BlockId));

		pBlk = pChunk->bc_FreeHead;
		ASSERT(VALID_BH(pBlk));

		pChunk->bc_FreeHead = pBlk->bh_Next;
		pBlk->bh_pChunk = pChunk;
		pChunk->bc_Age = 0;			// Reset age
		pChunk->bc_NumFree --;
#if	DBG
		pChunk->bc_NumAlloc ++;
#endif
		// If the block is now empty, unlink it from here and move it
		// to the first empty slot. We know that all blocks 'earlier' than
		// this are non-empty.
		if ((pChunk->bc_NumFree == 0) &&
			((pTmp = pChunk->bc_Next) != NULL) &&
			(pTmp->bc_NumFree > 0))
		{
			ASSERT(pChunk->bc_NumAlloc == atalkNumBlks[BlockId]);
			AtalkUnlinkDouble(pChunk, bc_Next, bc_Prev);
			for (; pTmp != NULL; pTmp = pTmp->bc_Next)
			{
				ASSERT(VALID_BC(pTmp));
				if (pTmp->bc_NumFree == 0)
				{
					ASSERT(pTmp->bc_NumAlloc == atalkNumBlks[BlockId]);
					// Found a free one. Park it right here.
					AtalkInsertDoubleBefore(pChunk, pTmp, bc_Next, bc_Prev);
					break;
				}
				else if (pTmp->bc_Next == NULL)	// We reached the end
				{
					AtalkLinkDoubleAtEnd(pChunk, pTmp, bc_Next, bc_Prev);
					break;
				}
			}
		}
	}

	if (pBlk != NULL)
	{
        //
        // we allocate Ndis Packets for ARAP guys later, when we really need
        //
		if ((BlockId >= BLKID_NEED_NDIS_INT) &&
            (BlockId != BLKID_MNP_SMSENDBUF) &&
            (BlockId != BLKID_MNP_LGSENDBUF))
		{
			PBUFFER_HDR	pBufHdr;

			// We need to initialize the Ndis stuff for these guys
			pBufHdr = (PBUFFER_HDR)((PBYTE)pBlk + sizeof(BLK_HDR));

			pBufHdr->bh_NdisPkt = NULL;

			//  Allocate an NDIS packet descriptor from the global packet pool
			NdisDprAllocatePacket(&ndisStatus,
								  &pBufHdr->bh_NdisPkt,
								  AtalkNdisPacketPoolHandle);
			
			if (ndisStatus != NDIS_STATUS_SUCCESS)
			{
				LOG_ERROR(EVENT_ATALK_NDISRESOURCES, ndisStatus, NULL, 0);

		        DBGPRINT(DBG_COMP_SYSTEM, DBG_LEVEL_ERR,
				    ("NdisDprAllocatePacket: Ndis Out-of-Resource condition hit\n"));

                ASSERT(0);

                RELEASE_SPIN_LOCK(pLock, OldIrql);
				AtalkBPFreeBlock(pBufHdr);
				return(NULL);
			}

			//  Link the buffer descriptor into the packet descriptor
			RtlZeroMemory(pBufHdr->bh_NdisPkt->ProtocolReserved, sizeof(PROTOCOL_RESD));
			NdisChainBufferAtBack(pBufHdr->bh_NdisPkt,
								  pBufHdr->bh_NdisBuffer);
			((PPROTOCOL_RESD)(pBufHdr->bh_NdisPkt->ProtocolReserved))->Receive.pr_BufHdr = pBufHdr;
		}
		++pBlk;
#if	DBG
		atalkBlksForId[BlockId] ++;
#endif
	}

	RELEASE_SPIN_LOCK(pLock, OldIrql);

#ifdef	PROFILING
	INTERLOCKED_INCREMENT_LONG(&AtalkStatistics.stat_BPAllocCount,
							   &AtalkStatsLock.SpinLock);
	TimeE = KeQueryPerformanceCounter(NULL);
	TimeD.QuadPart = TimeE.QuadPart - TimeS.QuadPart;
	INTERLOCKED_ADD_LARGE_INTGR(&AtalkStatistics.stat_BPAllocTime,
								 TimeD,
								 &AtalkStatsLock.SpinLock);
#endif
	return pBlk;
}


/***	atalkBPFreeBlock
 *
 *	Return a block to its owning chunk.
 */
VOID FASTCALL
AtalkBPFreeBlock(
	IN	PVOID		pBlock
)
{
	PBLK_CHUNK			pChunk;
	PBLK_HDR			pBlkHdr;
	BLKID				BlockId;
	KIRQL				OldIrql;
	ATALK_SPIN_LOCK *	pLock;
#ifdef	PROFILING
	TIME				TimeS, TimeE, TimeD;

	TimeS = KeQueryPerformanceCounter(NULL);
#endif

	pBlkHdr = (PBLK_HDR)((PCHAR)pBlock - sizeof(BLK_HDR));
	ASSERT(VALID_BH(pBlkHdr));

	pChunk = pBlkHdr->bh_pChunk;
	ASSERT(VALID_BC(pChunk));

	BlockId = pChunk->bc_BlkId;
	pLock = &atalkBPLock[BlockId];

	ACQUIRE_SPIN_LOCK(pLock, &OldIrql);

	if (BlockId >= BLKID_NEED_NDIS_INT)
	{
		PBUFFER_HDR	pBufHdr;

		// We need to free the ndis packet here - if present
		pBufHdr = (PBUFFER_HDR)pBlock;

		if (pBufHdr->bh_NdisPkt != NULL)
		{
		    NdisDprFreePacket(pBufHdr->bh_NdisPkt);
		    pBufHdr->bh_NdisPkt = NULL;
		}
	}

	DBGPRINT(DBG_COMP_SYSTEM, DBG_LEVEL_INFO,
			("AtalkBPFreeBlock: Returning Block %lx to chunk %lx for Id %d\n",
			pBlkHdr, pChunk, BlockId));

	ASSERT (pChunk->bc_NumFree < atalkNumBlks[BlockId]);
#if	DBG
	atalkBlksForId[BlockId] --;
	pChunk->bc_NumAlloc --;
#endif

	pChunk->bc_NumFree ++;
	ASSERT((pChunk->bc_NumFree + pChunk->bc_NumAlloc) == atalkNumBlks[BlockId]);
	pBlkHdr->bh_Next = pChunk->bc_FreeHead;
	pChunk->bc_FreeHead = pBlkHdr;

	// If this block's status is changing from a 'none available' to 'available'
	// move him to the head of the list
	if (pChunk->bc_NumFree == 1)
	{
		AtalkUnlinkDouble(pChunk, bc_Next, bc_Prev);
		AtalkLinkDoubleAtHead(atalkBPHead[BlockId],
							pChunk,
							bc_Next,
							bc_Prev);
	}

#ifdef	PROFILING
	INTERLOCKED_INCREMENT_LONG(&AtalkStatistics.stat_BPFreeCount,
							   &AtalkStatsLock.SpinLock);
	TimeE = KeQueryPerformanceCounter(NULL);
	TimeD.QuadPart = TimeE.QuadPart - TimeS.QuadPart;
	INTERLOCKED_ADD_LARGE_INTGR_DPC(&AtalkStatistics.stat_BPFreeTime,
									TimeD,
									&AtalkStatsLock.SpinLock);
#endif

	RELEASE_SPIN_LOCK(pLock, OldIrql);
}



/***	atalkBPAgePool
 *
 *	Age out the block pool of unused blocks
 */
LOCAL LONG FASTCALL
atalkBPAgePool(
	IN PTIMERLIST 	Context,
	IN BOOLEAN		TimerShuttingDown
)
{
	PBLK_CHUNK	pChunk;
	LONG		i, j, NumBlksPerChunk;

	if (TimerShuttingDown)
	{
		return ATALK_TIMER_NO_REQUEUE;
	}

	for (i = 0; i < NUM_BLKIDS; i++)
	{
		NumBlksPerChunk = atalkNumBlks[i];
		ACQUIRE_SPIN_LOCK_DPC(&atalkBPLock[i]);
	
		for (pChunk = atalkBPHead[i];
			 pChunk != NULL; )
		{
			PBLK_CHUNK	pFree;

			ASSERT(VALID_BC(pChunk));

			pFree = pChunk;
			pChunk = pChunk->bc_Next;

			// Since all blocks which are completely used up are at the tail end of
			// the list, if we encounter one, we are done.
			if (pFree->bc_NumFree == 0)
				break;

			if (pFree->bc_NumFree == NumBlksPerChunk)
			{
				DBGPRINT(DBG_COMP_SYSTEM, DBG_LEVEL_WARN,
						("atalkBPAgePool: Aging Chunk %lx, Id %d NumFree %d\n",
						pFree, pFree->bc_BlkId,pFree->bc_NumFree));
	
				if (++(pFree->bc_Age) >= MAX_BLOCK_POOL_AGE)
				{
					DBGPRINT(DBG_COMP_SYSTEM, DBG_LEVEL_WARN,
							("atalkBPAgePool: freeing Chunk %lx, Id %d\n",
							pFree, pFree->bc_BlkId));
					AtalkUnlinkDouble(pFree, bc_Next, bc_Prev);
#ifdef	PROFILING
					INTERLOCKED_INCREMENT_LONG( &AtalkStatistics.stat_NumBPAge,
											&AtalkStatsLock.SpinLock);
#endif
					if (pFree->bc_BlkId >= BLKID_NEED_NDIS_INT)
					{
						PBLK_HDR	pBlkHdr;
	
						// We need to free Ndis stuff for these guys
						pBlkHdr = pFree->bc_FreeHead;
						for (j = 0, pBlkHdr = pFree->bc_FreeHead;
							 j < NumBlksPerChunk;
							 j++, pBlkHdr = pBlkHdr->bh_Next)
						{
							PBUFFER_HDR	pBufHdr;
	
							pBufHdr = (PBUFFER_HDR)((PBYTE)pBlkHdr + sizeof(BLK_HDR));
	
							ASSERT(pBufHdr->bh_NdisPkt == NULL);
							AtalkNdisFreeBuffer(pBufHdr->bh_NdisBuffer);
						}
					}
					AtalkFreeMemory(pFree);
#if	DBG
					atalkNumChunksForId[i] --;
#endif
				}
			}
		}
		RELEASE_SPIN_LOCK_DPC(&atalkBPLock[i]);
	}

	return ATALK_TIMER_REQUEUE;
}

#ifdef	TRACK_MEMORY_USAGE

#define	MAX_PTR_COUNT		4*1024
#define	MAX_MEM_USERS		512
LOCAL	ATALK_SPIN_LOCK		atalkMemTrackLock	= {0};
LOCAL	struct
{
	PVOID	mem_Ptr;
	ULONG	mem_FileLine;
} atalkMemPtrs[MAX_PTR_COUNT]	= {0};

LOCAL	struct
{
	ULONG	mem_FL;
	ULONG	mem_Count;
} atalkMemUsage[MAX_MEM_USERS]	= {0};

BOOLEAN NeverBeenFull=TRUE;

VOID
AtalkTrackMemoryUsage(
	IN	PVOID	pMem,
    IN  ULONG   Size,
	IN	BOOLEAN	Alloc,
	IN	ULONG	FileLine
	)
/*++

Routine Description:

 	Keep track of memory usage by storing and clearing away pointers as and
 	when they are allocated or freed. This helps in keeping track of memory
 	leaks.

Arguments:


Return Value:


--*/
{
	static int		i = 0;
	int				j, k;
	KIRQL				OldIrql;

	ACQUIRE_SPIN_LOCK(&atalkMemTrackLock, &OldIrql);

	if (Alloc)
	{
		for (j = 0; j < MAX_PTR_COUNT; i++, j++)
		{
			i = i & (MAX_PTR_COUNT-1);
			if (atalkMemPtrs[i].mem_Ptr == NULL)
			{
				atalkMemPtrs[i].mem_Ptr = pMem;
				atalkMemPtrs[i++].mem_FileLine = FileLine;
				break;
			}
		}

		for (k = 0; k < MAX_MEM_USERS; k++)
		{
			if (atalkMemUsage[k].mem_FL == FileLine)
			{
				atalkMemUsage[k].mem_Count += Size;
				break;
			}
		}
		if (k == MAX_MEM_USERS)
		{
			for (k = 0; k < MAX_MEM_USERS; k++)
			{
				if (atalkMemUsage[k].mem_FL == 0)
				{
					atalkMemUsage[k].mem_FL = FileLine;
					atalkMemUsage[k].mem_Count = Size;
					break;
				}
			}
			if (k == MAX_MEM_USERS)
			{
				DBGPRINT(DBG_COMP_RESOURCES, DBG_LEVEL_ERR,
					("AtalkTrackMemoryUsage: Out of space on atalkMemUsage !!!\n"));
			}
		}
	}
	else
	{
		for (j = 0, k = i; j < MAX_PTR_COUNT; j++, k--)
		{
			k = k & (MAX_PTR_COUNT-1);
			if (atalkMemPtrs[k].mem_Ptr == pMem)
			{
				atalkMemPtrs[k].mem_Ptr = 0;
				atalkMemPtrs[k].mem_FileLine = 0;
				break;
			}
		}

		for (k = 0; k < MAX_MEM_USERS; k++)
		{
			if (atalkMemUsage[k].mem_FL == FileLine)
			{
                if (atalkMemUsage[k].mem_Count >= Size)
                {
				    atalkMemUsage[k].mem_Count -= Size;
                }
				break;
			}
		}

	}

	RELEASE_SPIN_LOCK(&atalkMemTrackLock, OldIrql);

	if (j == MAX_PTR_COUNT)
	{
        if (NeverBeenFull)
        {
            NeverBeenFull = FALSE;
		    DBGPRINT(DBG_COMP_RESOURCES, DBG_LEVEL_ERR,
			    ("AtalkTrackMemoryUsage: %s\n", Alloc ? "Table Full" : "Can't find"));
        }
	}
}

#endif	// TRACK_MEMORY_USAGE

#ifdef	TRACK_BUFFDESC_USAGE

#define	MAX_BD_COUNT		1024*2
LOCAL	ATALK_SPIN_LOCK	atalkBdTrackLock	= {0};
LOCAL	struct
{
	PVOID	bdesc_Ptr;
	ULONG	bdesc_FileLine;
} atalkBuffDescPtrs[MAX_BD_COUNT]			= {0};


VOID
AtalkTrackBuffDescUsage(
	IN	PVOID	pBuffDesc,
	IN	BOOLEAN	Alloc,
	IN	ULONG	FileLine
	)
/*++

Routine Description:

 	Keep track of buffer-desc usage by storing and clearing away pointers as and
 	when they are allocated or freed. This helps in keeping track of memory
 	leaks.

Arguments:


Return Value:


--*/
{
	static int		i = 0;
	int				j, k;
	KIRQL				OldIrql;

	ACQUIRE_SPIN_LOCK(&atalkBdTrackLock, &OldIrql);

	if (Alloc)
	{
		for (j = 0; j < MAX_BD_COUNT; i++, j++)
		{
			i = i & (MAX_BD_COUNT-1);
			if (atalkBuffDescPtrs[i].bdesc_Ptr == NULL)
			{
				atalkBuffDescPtrs[i].bdesc_Ptr = pBuffDesc;
				atalkBuffDescPtrs[i++].bdesc_FileLine = FileLine;
				break;
			}
		}
	}
	else
	{
		for (j = 0, k = i; j < MAX_BD_COUNT; j++, k--)
		{
			k = k & (MAX_BD_COUNT-1);
			if (atalkBuffDescPtrs[k].bdesc_Ptr == pBuffDesc)
			{
				atalkBuffDescPtrs[k].bdesc_Ptr = 0;
				atalkBuffDescPtrs[k].bdesc_FileLine = 0;
				break;
			}
		}
	}

	RELEASE_SPIN_LOCK(&atalkBdTrackLock, OldIrql);

	if (j == MAX_BD_COUNT)
	{
		DBGPRINT(DBG_COMP_RESOURCES, DBG_LEVEL_INFO,
			("AtalkTrackBuffDescUsage: %s\n", Alloc ? "Table Full" : "Can't find"));
		ASSERT(0);
	}
}

#endif	// TRACK_BUFFDESC_USAGE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\atalk\sys\atkmem.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

	atkmem.h

Abstract:

	This module contains memory allocator routines for the stack

Author:

	Jameel Hyder (jameelh@microsoft.com)
	Nikhil Kamkolkar (nikhilk@microsoft.com)

Revision History:
	23 Feb 1993		Initial Version

Notes:	Tab stop: 4
--*/

#ifndef	_ATKMEM_
#define	_ATKMEM_

#define	DWORDSIZEBLOCK(Size)	(((Size)+sizeof(ULONG)-1) & ~(sizeof(ULONG)-1))
#define	ATALK_MEMORY_SIGNATURE	*(PULONG)"ATKM"
#define	ZEROED_MEMORY_TAG		0xF0000000
#define	ATALK_TAG				*(PULONG)"Atk "

//
// Definitions for the block management package
//
typedef	UCHAR	BLKID;

// Add a BLKID_xxx and an entry to atalkBlkSize for every block client
#define	BLKID_BUFFDESC				(BLKID)0
#define	BLKID_AMT					(BLKID)1
#define	BLKID_AMT_ROUTE				(BLKID)2
#define	BLKID_BRE					(BLKID)3
#define	BLKID_BRE_ROUTE				(BLKID)4
#define	BLKID_ATPREQ				(BLKID)5
#define	BLKID_ATPRESP				(BLKID)6
#define	BLKID_ASPREQ				(BLKID)7
#define	BLKID_ARAP_SMPKT  	        (BLKID)8
#define	BLKID_ARAP_MDPKT	        (BLKID)9
#define	BLKID_ARAP_LGPKT		    (BLKID)10
#define BLKID_ARAP_SNDPKT           (BLKID)11
#define	BLKID_ARAP_LGBUF		    (BLKID)12
#define	BLKID_NEED_NDIS_INT			BLKID_AARP		// All ids above this needs Ndis Initialization
													// See AtalkBPAllocBlock
#define	BLKID_AARP					(BLKID)13
#define	BLKID_DDPSM					(BLKID)14
#define	BLKID_DDPLG					(BLKID)15
#define	BLKID_SENDBUF				(BLKID)16
#define	BLKID_MNP_SMSENDBUF		    (BLKID)17
#define	BLKID_MNP_LGSENDBUF		    (BLKID)18
#define	NUM_BLKIDS					(BLKID)19

//
// if we need huge buffers, we just do an alloc ourselves (rather than using the
// above BLKID mechanism.  So that we know it is something we allocated, we use
// this as the "block id".  Now, make sure NUM_BLKIDS never exceeds 250!
//
#define ARAP_UNLMTD_BUFF_ID         (NUM_BLKIDS+5)


//	BUFFER DESCRIPTORS
//	These will be used by callers into the DDP layer. They can be
//	chained together. They contain either an opaque (MDL on NT) or
//	a PBYTE buffer. All outside callers *must* pass in an MDL. Only
//	DDP/AARP will have the right to create a buffer descriptor which
//	will hold a PBYTE buffer.
//
//	MODEL OF OPERATION FOR DDP:
//	DDP/AARP will call the link AllocBuildLinkHeader routine. This will
//	allocate the space that DDP/AARP says it needs. The link header will
//	then be built from the start of the buffer. A pointer to the beginning
//	and to the place where the caller can fill in their headers is returned.
//	DDP/AARP will then fill in its header, make a buffer descriptor for
//	this buffer, prepend to the buffer descriptor its received from its
//	client, and then call the packet out routines.

#define		BD_CHAR_BUFFER		(USHORT)0x0001
#define		BD_FREE_BUFFER		(USHORT)0x0002

#define		BD_SIGNATURE		*((PULONG)"BDES")
#if	DBG
#define	VALID_BUFFDESC(pBuffDesc)	\
				(((pBuffDesc) != NULL) && ((pBuffDesc)->bd_Signature == BD_SIGNATURE))
#else
#define	VALID_BUFFDESC(pBuffDesc)	((pBuffDesc) != NULL)
#endif
typedef	struct _BUFFER_DESC
{
#if DBG
	ULONG					bd_Signature;
#endif
	struct _BUFFER_DESC *	bd_Next;
	USHORT					bd_Flags;
	SHORT					bd_Length;

	union
	{
		PAMDL				bd_OpaqueBuffer;
		struct
		{
			//	bd_FreeBuffer is the beginning of the allocated buffer.
			//	bd_CharBuffer is from some offset (0 or >) within it
			//	from where the data starts.
			PBYTE			bd_CharBuffer;
			PBYTE			bd_FreeBuffer;
		};
	};
} BUFFER_DESC, *PBUFFER_DESC;

#ifdef	TRACK_MEMORY_USAGE

#define	AtalkAllocMemory(Size)	AtalkAllocMem(Size, FILENUM | __LINE__)

extern
PVOID FASTCALL
AtalkAllocMem(
	IN	ULONG	Size,
	IN	ULONG	FileLine
);

extern
VOID
AtalkTrackMemoryUsage(
	IN	PVOID	pMem,
    IN  ULONG   Size,
	IN	BOOLEAN	Alloc,
	IN	ULONG	FileLine
);

#else

#define	AtalkAllocMemory(Size)	AtalkAllocMem(Size)

#define	AtalkTrackMemoryUsage(pMem, Size, Alloc, FileLine)

extern
PVOID FASTCALL
AtalkAllocMem(
	IN	ULONG	Size
);

#endif	// TRACK_MEMORY_USAGE

#ifdef	TRACK_BUFFDESC_USAGE

#define	AtalkAllocBuffDesc(Ptr, Length, Flags)	\
				AtalkAllocBufferDesc(Ptr, Length, Flags, FILENUM | __LINE__)

#define	AtalkDescribeBuffDesc(DataPtr, FreePtr, Length, Flags)	\
				AtalkDescribeBufferDesc(DataPtr, FreePtr, Length, Flags, FILENUM | __LINE__)

extern
VOID
AtalkTrackBuffDescUsage(
	IN	PVOID	pBuffDesc,
	IN	BOOLEAN	Alloc,
	IN	ULONG	FileLine
);

extern
PBUFFER_DESC
AtalkAllocBufferDesc(
	IN	PVOID	Ptr,		// Either a PAMDL or a PBYTE
	IN	USHORT	Length,
	IN	USHORT	Flags,
	IN	ULONG	FileLine
);

extern
PBUFFER_DESC
AtalkDescribeBufferDesc(
	IN	PVOID	DataPtr,
	IN	PVOID	FreePtr,
	IN	USHORT	Length,
	IN	USHORT	Flags,
	IN	ULONG	FileLine
);

#else

#define	AtalkAllocBuffDesc(Ptr, Length, Flags)	\
						AtalkAllocBufferDesc(Ptr, Length, Flags)

#define	AtalkDescribeBuffDesc(DataPtr, FreePtr, Length, Flags)	\
						AtalkDescribeBufferDesc(DataPtr, FreePtr, Length, Flags)

#define	AtalkTrackBuffDescUsage(pBuffDesc, Alloc, FileLine)

extern
PBUFFER_DESC
AtalkAllocBufferDesc(
	IN	PVOID	Ptr,		// Either a PAMDL or a PBYTE
	IN	USHORT	Length,
	IN	USHORT	Flags
);

extern
PBUFFER_DESC
AtalkDescribeBufferDesc(
	IN	PVOID	DataPtr,
	IN	PVOID	FreePtr,
	IN	USHORT	Length,
	IN	USHORT	Flags
);

#endif	// TRACK_BUFFDESC_USAGE

#define	AtalkAllocZeroedMemory(Size)		AtalkAllocMemory((Size) | ZEROED_MEMORY_TAG)

extern
VOID FASTCALL
AtalkFreeMemory(
	IN	PVOID pBuffer
);

extern
VOID FASTCALL
AtalkFreeBuffDesc(
	IN	PBUFFER_DESC	pBuffDesc
);

extern
VOID
AtalkCopyBuffDescToBuffer(
	IN	PBUFFER_DESC	pBuffDesc,
	IN	LONG			SrcOff,
	IN	LONG			BytesToCopy,
	IN	PBYTE			DstBuf
);

extern
VOID
AtalkCopyBufferToBuffDesc(
	IN	PBYTE			SrcBuf,
	IN	LONG			BytesToCopy,
	IN	PBUFFER_DESC	pBuffDesc,
	IN	LONG			DstOff
);

extern
LONG FASTCALL
AtalkSizeBuffDesc(
	IN	PBUFFER_DESC	pBuffDesc
);

extern
VOID
AtalkInitMemorySystem(
	VOID
);

extern
VOID
AtalkDeInitMemorySystem(
	VOID
);

//	Macros
#define		GET_MDL_FROM_OPAQUE(x)		((PMDL)x)

#define	AtalkPrependBuffDesc(pNode, pList)			\
			pNode->bd_Next = pList;

#define	AtalkAppendBuffDesc(pNode, pList)			\
		{											\
			PBUFFER_DESC	_L = pList;				\
													\
			if (_L == NULL)							\
			{										\
				pNode->bd_Next = NULL;				\
			}										\
			else									\
			{										\
				while (_L->bd_Next != NULL)			\
					_L = _L->bd_Next;				\
													\
				_L->bd_Next = pNode;				\
				pNode->bd_Next = NULL;				\
			}										\
		}

#define	AtalkSizeOfBuffDescData(pBuf, pLen)			\
		{			 								\
			PBUFFER_DESC	_B = (pBuf);			\
			USHORT			_L = 0;					\
													\
			while (_B)								\
			{										\
				_L += _B->bd_Length;				\
				_B  = _B->bd_Next;					\
			}										\
			*(pLen) = _L;							\
		}

#define	AtalkSetSizeOfBuffDescData(pBuf, Len)	((pBuf)->bd_Length = (Len))

extern
PAMDL
AtalkAllocAMdl(
	IN	PBYTE	pBuffer OPTIONAL,
	IN	LONG	Size
);

extern
PAMDL
AtalkSubsetAmdl(
	IN	PAMDL	pStartingMdl,
	IN	ULONG	TotalOffset,
	IN	ULONG	DesiredLength);

#define	AtalkGetAddressFromMdl(pAMdl)		MmGetSystemAddressForMdl(pAMdl)
#define	AtalkGetAddressFromMdlSafe(pAMdl, PagePriority)		MmGetSystemAddressForMdlSafe(pAMdl, PagePriority)

#ifdef	PROFILING
#define	AtalkFreeAMdl(pAmdl)						\
		{											\
			PAMDL	_N;								\
			PAMDL	_L = pAmdl;						\
			while (_L != NULL)						\
			{										\
				_N = _L->Next;						\
				ExInterlockedDecrementLong(			\
					&AtalkStatistics.stat_CurMdlCount,\
					&AtalkKeStatsLock);				\
				IoFreeMdl(_L);						\
                ATALK_DBG_DEC_COUNT(AtalkDbgMdlsAlloced); \
				_L = _N;							\
			}										\
		}
#else
#define	AtalkFreeAMdl(pAmdl)						\
		{											\
			PAMDL	_N;								\
			PAMDL	_L = pAmdl;						\
			while (_L != NULL)						\
			{										\
				_N = _L->Next;						\
				IoFreeMdl(_L);						\
                ATALK_DBG_DEC_COUNT(AtalkDbgMdlsAlloced); \
				_L = _N;							\
			}										\
		}
#endif

#define	AtalkIsMdlFragmented(pMdl)	((pMdl)->Next != NULL)

extern
LONG FASTCALL
AtalkSizeMdlChain(
	IN	PAMDL		pAMdlChain
);

PVOID FASTCALL
AtalkBPAllocBlock(
	IN	BLKID		BlockId
);

VOID FASTCALL
AtalkBPFreeBlock(
	IN	PVOID		pBlock
);

#endif	// _ATKMEM_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\atalk\sys\atkndis.c ===
/*++										

Copyright (c) 1992  Microsoft Corporation

Module Name:

	atkndis.c

Abstract:

	This module contains the support code for the stack dealing with
	the NDIS 3.0 interface. The NDIS Init/Deinit and the ndis-protocol
	interface code.

Author:

	Jameel Hyder (jameelh@microsoft.com)
	Nikhil Kamkolkar (nikhilk@microsoft.com)

Revision History:
	19 Jun 1992		Initial Version

Notes:	Tab stop: 4
--*/

#include <atalk.h>
#pragma hdrstop
#define	FILENUM	ATKNDIS


#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, AtalkNdisInitRegisterProtocol)
#pragma alloc_text(INIT, atalkNdisInitInitializeResources)
#pragma alloc_text(PAGEINIT, AtalkNdisInitBind)
#pragma alloc_text(PAGEINIT, AtalkInitNdisQueryAddrInfo)
#pragma alloc_text(PAGEINIT, AtalkInitNdisSetLookaheadSize)
#pragma alloc_text(PAGEINIT, AtalkInitNdisStartPacketReception)
#pragma alloc_text(PAGEINIT, AtalkBindAdapter)
#pragma alloc_text(PAGEINIT, AtalkUnbindAdapter)
#endif


ATALK_ERROR
AtalkNdisInitRegisterProtocol(
	VOID
	)
/*++

Routine Description:

	This routine is called during initialization time to register the protocol
	with NDIS.

Arguments:

	NameString- The name to be registered for this protocol- human-readable form

Return Value:

	Status - TRUE if register went ok, FALSE otherwise.
--*/
{
	NDIS_STATUS		ndisStatus;
	UNICODE_STRING	RegName;
	NDIS_PROTOCOL_CHARACTERISTICS protocolInfo;

	RtlZeroMemory(&protocolInfo, sizeof(protocolInfo));
	RtlInitUnicodeString(&RegName, PROTOCOL_REGISTER_NAME);

	// Set up the characteristics for the protocol for registering with NDIS
	protocolInfo.MajorNdisVersion = PROTOCOL_MAJORNDIS_VERSION;
	protocolInfo.MinorNdisVersion = PROTOCOL_MINORNDIS_VERSION;
	protocolInfo.Name.Length = RegName.Length;
	protocolInfo.Name.Buffer = (PVOID)RegName.Buffer;

	protocolInfo.OpenAdapterCompleteHandler	 = AtalkOpenAdapterComplete;
	protocolInfo.CloseAdapterCompleteHandler = AtalkCloseAdapterComplete;
	protocolInfo.ResetCompleteHandler		 = AtalkResetComplete;
	protocolInfo.RequestCompleteHandler		 = AtalkRequestComplete;

	protocolInfo.SendCompleteHandler		 = AtalkSendComplete;
	protocolInfo.TransferDataCompleteHandler = AtalkTransferDataComplete;

	protocolInfo.ReceiveHandler				 = AtalkReceiveIndication;
	protocolInfo.ReceiveCompleteHandler		 = AtalkReceiveComplete;
	protocolInfo.StatusHandler				 = AtalkStatusIndication;
	protocolInfo.StatusCompleteHandler		 = AtalkStatusComplete;

	protocolInfo.BindAdapterHandler			 = AtalkBindAdapter;
	protocolInfo.UnbindAdapterHandler		 = AtalkUnbindAdapter;

    protocolInfo.PnPEventHandler             = AtalkPnPHandler;

	ndisStatus = atalkNdisInitInitializeResources();

	if (ndisStatus == NDIS_STATUS_SUCCESS)
	{
		NdisRegisterProtocol(&ndisStatus,
							 &AtalkNdisProtocolHandle,
							 &protocolInfo,
							 (UINT)sizeof(NDIS_PROTOCOL_CHARACTERISTICS)+RegName.Length);

		if (ndisStatus != NDIS_STATUS_SUCCESS)
		{
			LOG_ERROR(EVENT_ATALK_REGISTERPROTOCOL, ndisStatus, NULL, 0);
	
			DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
					("AtalkNdisRegister: failed %ul\n", ndisStatus));
		}
	}

	return AtalkNdisToAtalkError(ndisStatus);
}



VOID
AtalkNdisDeregisterProtocol(
	VOID
	)
/*++

Routine Description:

	This routine is called to deregister the protocol

Arguments:

	NONE

Return Value:

	NONE
--*/
{
	NDIS_STATUS ndisStatus;

	if (AtalkNdisProtocolHandle != (NDIS_HANDLE)NULL)
	{
		NdisDeregisterProtocol(&ndisStatus, AtalkNdisProtocolHandle);

		AtalkNdisProtocolHandle = (NDIS_HANDLE)NULL;
		if (ndisStatus != NDIS_STATUS_SUCCESS)
		{
			LOG_ERROR(EVENT_ATALK_DEREGISTERPROTOCOL, ndisStatus, NULL, 0);
		}
	}
	else
	{
		ASSERTMSG("AtalkNdisDeregisterProtocol: NULL ProtocolHandle\n", FALSE);
	}
}



LOCAL NDIS_STATUS
atalkNdisInitInitializeResources(
	VOID
	)
/*++

Routine Description:


Arguments:


Return Value:

	Status - STATUS_SUCCESS if all resources were allocated
			 STATUS_INSUFFICIENT_RESOURCES otherwise.
--*/
{
	NDIS_STATUS ndisStatus;
	LONG		numPktDescs, numBufDescs;

	numPktDescs = NUM_PACKET_DESCRIPTORS;
	if (AtalkRouter)
	{
		numPktDescs *= ROUTING_FACTOR;
	}

	numBufDescs = NUM_BUFFER_DESCRIPTORS;
	if (AtalkRouter)
	{
		numBufDescs *= ROUTING_FACTOR;
	}

	do
	{
		// Setup the ndis packet descriptor pools in the Port descriptor
		DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_INFO,
				("atalkNdisInitInitializeResources: Allocating %ld Packets\n",
				numPktDescs));

        AtalkNdisPacketPoolHandle = (PVOID)NDIS_PACKET_POOL_TAG_FOR_APPLETALK;

		NdisAllocatePacketPoolEx(&ndisStatus,
								 &AtalkNdisPacketPoolHandle,
								 numPktDescs,
								 numPktDescs*200,	// Overflow descriptors
								 sizeof(PROTOCOL_RESD));
	
		if ((ndisStatus != NDIS_STATUS_SUCCESS) && (ndisStatus != NDIS_STATUS_PENDING))
		{
			break;
		}

		//  Setup the ndis buffer descriptor pool
		DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_INFO,
				("atalkNdisInitInitializeResources: Allocating %ld buffers\n",
				numBufDescs));
		NdisAllocateBufferPool(&ndisStatus,
							   &AtalkNdisBufferPoolHandle,
							   numBufDescs);

		if ((ndisStatus != NDIS_STATUS_SUCCESS) && (ndisStatus != NDIS_STATUS_PENDING))
		{
			NdisFreePacketPool(AtalkNdisPacketPoolHandle);
			AtalkNdisPacketPoolHandle = NULL;
		}
	} while (FALSE);

	if (ndisStatus != NDIS_STATUS_SUCCESS)
	{
		LOG_ERROR(EVENT_ATALK_NDISRESOURCES, ndisStatus, NULL, 0);
	}

	return ndisStatus;
}




NDIS_STATUS
AtalkNdisInitBind(
	IN OUT PPORT_DESCRIPTOR	pPortDesc
	)
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
	NDIS_STATUS     ndisStatus, openStatus, queryStatus;
	ATALK_ERROR	    error;
	UINT 		    selectedMediumIndex;
    NDIS_STRING     FriendlyName;

	// reference the port for bind
	AtalkPortReferenceByPtr(pPortDesc, &error);
	if (error != ATALK_NO_ERROR)
	{
		return(STATUS_UNSUCCESSFUL);
	}

	//	Reset event before possible wait
	KeClearEvent(&pPortDesc->pd_RequestEvent);

	NdisOpenAdapter(&ndisStatus,			// open status
					&openStatus,			// more info not used
					&pPortDesc->pd_NdisBindingHandle,
					&selectedMediumIndex,
					AtalkSupportedMedia,
					AtalkSupportedMediaSize,
					AtalkNdisProtocolHandle,
					(NDIS_HANDLE)pPortDesc,
					(PNDIS_STRING)&pPortDesc->pd_AdapterName,
					0,						//	Open options
					NULL);					//	Addressing information


	if (ndisStatus == NDIS_STATUS_PENDING)
	{
		DBGPRINT(DBG_COMP_NDISREQ, DBG_LEVEL_WARN,
				("AtalkNdisInitBind: OpenAdapter is pending for %Z\n",
				&pPortDesc->pd_AdapterKey));

		//  Make sure we are not at or above dispatch level
		ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

		// 	Wait on event, completion routine will set NdisRequestEvent
		//	Use wrappers
		KeWaitForSingleObject(&pPortDesc->pd_RequestEvent,
							  Executive,
							  KernelMode,
							  FALSE,
							  NULL);

		ndisStatus = pPortDesc->pd_RequestStatus;
	}

	if (ndisStatus == NDIS_STATUS_SUCCESS)
	{
		PPORT_HANDLERS	pPortHandler;

		pPortDesc->pd_Flags 		|= 	PD_BOUND;
		pPortDesc->pd_NdisPortType 	= 	AtalkSupportedMedia[selectedMediumIndex];
		pPortDesc->pd_PortType 		= 	GET_PORT_TYPE(pPortDesc->pd_NdisPortType);

		if (pPortDesc->pd_PortType != ALAP_PORT)
		{
			pPortDesc->pd_Flags |= PD_EXT_NET;
		}
		else if (pPortDesc->pd_Flags & PD_SEED_ROUTER)
		{
			pPortDesc->pd_InitialNetworkRange.anr_LastNetwork =
								pPortDesc->pd_InitialNetworkRange.anr_FirstNetwork;
		}

        // is this a RAS port?
        if (pPortDesc->pd_NdisPortType == NdisMediumWan)
        {
			pPortDesc->pd_Flags |= PD_RAS_PORT;
            RasPortDesc = pPortDesc;
        }

		// Set stuff from the PortHandler structure to the port descriptor
		pPortHandler = &AtalkPortHandlers[pPortDesc->pd_PortType];
		pPortDesc->pd_AddMulticastAddr = pPortHandler->ph_AddMulticastAddr;
		pPortDesc->pd_RemoveMulticastAddr = pPortHandler->ph_RemoveMulticastAddr;
		pPortDesc->pd_AarpProtocolType = pPortHandler->ph_AarpProtocolType;
		pPortDesc->pd_AarpHardwareType = pPortHandler->ph_AarpHardwareType;
        pPortDesc->pd_BroadcastAddrLen = pPortHandler->ph_BroadcastAddrLen;
		RtlCopyMemory(pPortDesc->pd_BroadcastAddr,
					  pPortHandler->ph_BroadcastAddr,
					  pPortHandler->ph_BroadcastAddrLen);

        FriendlyName.MaximumLength = FriendlyName.Length = 0;
        FriendlyName.Buffer = NULL;

        queryStatus = NdisQueryAdapterInstanceName(&FriendlyName,
                                                   pPortDesc->pd_NdisBindingHandle);
        if (queryStatus == NDIS_STATUS_SUCCESS)
        {
            ASSERT((FriendlyName.Buffer != NULL) && (FriendlyName.Length > 0));

            pPortDesc->pd_FriendlyAdapterName.Buffer =
                AtalkAllocZeroedMemory(FriendlyName.Length + sizeof(WCHAR));

            if (pPortDesc->pd_FriendlyAdapterName.Buffer != NULL)
            {
                pPortDesc->pd_FriendlyAdapterName.MaximumLength =
                                                    FriendlyName.MaximumLength;
                pPortDesc->pd_FriendlyAdapterName.Length = FriendlyName.Length;

                RtlCopyMemory(pPortDesc->pd_FriendlyAdapterName.Buffer,
                              FriendlyName.Buffer,
                              FriendlyName.Length);
            }

            NdisFreeString(FriendlyName);
        }
	}
	else
	{
		LOG_ERRORONPORT(pPortDesc,
						EVENT_ATALK_OPENADAPTER,
						ndisStatus,
						NULL,
						0);
		AtalkPortDereference(pPortDesc);
	}

	return ndisStatus;
}




VOID
AtalkNdisUnbind(
	IN	PPORT_DESCRIPTOR	pPortDesc
	)
/*++

Routine Description:


Arguments:


Return Value:

--*/
{
	NDIS_STATUS	ndisStatus;
	KIRQL		OldIrql;

	//	Reset event before possible wait
	KeClearEvent(&pPortDesc->pd_RequestEvent);

	ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);
	NdisCloseAdapter(&ndisStatus, pPortDesc->pd_NdisBindingHandle);

	if (ndisStatus == NDIS_STATUS_PENDING)
	{
		DBGPRINT(DBG_COMP_NDISREQ, DBG_LEVEL_WARN,
				("AtalkNdisUnbind: pending for close!\n"));

		//  Make sure we are not at or above dispatch level
		ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

		// Wait on event, completion routine will set NdisRequestEvent
		KeWaitForSingleObject(&pPortDesc->pd_RequestEvent,
							  Executive,
							  KernelMode,
							  FALSE,
							  NULL);

		ndisStatus = pPortDesc->pd_RequestStatus;
	}

	if (ndisStatus == NDIS_STATUS_SUCCESS)
	{
		DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
		    ("AtalkNdisUnbind: CloseAdapter on %Z completed successfully\n",
            ((pPortDesc->pd_FriendlyAdapterName.Buffer) ?
                (&pPortDesc->pd_FriendlyAdapterName) : (&pPortDesc->pd_AdapterName))
            ));


		ACQUIRE_SPIN_LOCK(&pPortDesc->pd_Lock, &OldIrql);
		pPortDesc->pd_Flags &= ~PD_BOUND;
		RELEASE_SPIN_LOCK(&pPortDesc->pd_Lock, OldIrql);

		// Remove the reference added at bind time
		AtalkPortDereference(pPortDesc);
	}
	else
	{
		DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
		    ("AtalkNdisUnbind: CloseAdapter on %Z failed %lx\n",
            ((pPortDesc->pd_FriendlyAdapterName.Buffer) ?
                (&pPortDesc->pd_FriendlyAdapterName) : (&pPortDesc->pd_AdapterName)),
            ndisStatus
            ));


		LOG_ERRORONPORT(pPortDesc,
						EVENT_ATALK_CLOSEADAPTER,
						ndisStatus,
						NULL,
						0);
	}
}



VOID
AtalkNdisReleaseResources(
	VOID
	)
/*++

Routine Description:


Arguments:


Return Value:

	None
--*/
{
	if (AtalkNdisPacketPoolHandle != NULL)
	{
		NdisFreePacketPool(AtalkNdisPacketPoolHandle);
		AtalkNdisPacketPoolHandle = NULL;
	}
	if (AtalkNdisBufferPoolHandle)
	{
		NdisFreeBufferPool(AtalkNdisBufferPoolHandle);
		AtalkNdisBufferPoolHandle = NULL;
	}
}




ATALK_ERROR
AtalkInitNdisQueryAddrInfo(
	IN	PPORT_DESCRIPTOR	pPortDesc
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{							
	NDIS_OID		ndisOid;
	ULONG			macOptions;
	PBYTE			address;
	UINT			addressLength;

	//	We assume a single thread/init time behavior
	NDIS_REQUEST	request;
	NDIS_STATUS	 	ndisStatus = NDIS_STATUS_SUCCESS;

	do
	{
		//  Check to see it we bound successfully to this adapter
		if (!PORT_BOUND(pPortDesc))
		{
			LOG_ERRORONPORT(pPortDesc,
							EVENT_ATALK_NOTBOUNDTOMAC,
							STATUS_INSUFFICIENT_RESOURCES,
							NULL,
							0);

			ndisStatus = NDIS_STATUS_RESOURCES;
			break;
		}

		switch (pPortDesc->pd_NdisPortType)
		{
		  case NdisMedium802_3 :
			ndisOid = OID_802_3_CURRENT_ADDRESS;
			address = &pPortDesc->pd_PortAddr[0];
			addressLength = MAX_HW_ADDR_LEN;
			break;

		  case NdisMediumFddi :
			ndisOid = OID_FDDI_LONG_CURRENT_ADDR;
			address = &pPortDesc->pd_PortAddr[0];
			addressLength = MAX_HW_ADDR_LEN;
			break;

		  case NdisMedium802_5:
			ndisOid = OID_802_5_CURRENT_ADDRESS;
			address = &pPortDesc->pd_PortAddr[0];
			addressLength = MAX_HW_ADDR_LEN;
			break;

		  case NdisMediumLocalTalk :
			ndisOid = OID_LTALK_CURRENT_NODE_ID;
			address = (PBYTE)&pPortDesc->pd_AlapNode;
			addressLength = sizeof(pPortDesc->pd_AlapNode);
			break;

          case NdisMediumWan:
			ndisOid = OID_WAN_CURRENT_ADDRESS;
            // NOTE: the following two fields not relevant for RAS
			address = &pPortDesc->pd_PortAddr[0];
			addressLength = MAX_HW_ADDR_LEN;
			break;

		  default:
			KeBugCheck(0);
			break;
		}

		//  Setup request
		request.RequestType = NdisRequestQueryInformation;
		request.DATA.QUERY_INFORMATION.Oid = ndisOid;
		request.DATA.QUERY_INFORMATION.InformationBuffer = address;
		request.DATA.QUERY_INFORMATION.InformationBufferLength = addressLength;

		ndisStatus = AtalkNdisSubmitRequest(pPortDesc,
											&request,
											TRUE,
											NULL,
											NULL);
	
	
		if (ndisStatus != NDIS_STATUS_SUCCESS)
		{
			LOG_ERRORONPORT(pPortDesc,
							EVENT_ATALK_STATIONADDRESS,
							ndisStatus,
							NULL,
							0);
		}

		//  Setup request to get the mac options information
		request.RequestType = NdisRequestQueryInformation;
		request.DATA.QUERY_INFORMATION.Oid = OID_GEN_MAC_OPTIONS;
		request.DATA.QUERY_INFORMATION.InformationBuffer = &macOptions;
		request.DATA.QUERY_INFORMATION.InformationBufferLength = sizeof(ULONG);

		ndisStatus = AtalkNdisSubmitRequest(pPortDesc,
											&request,
											TRUE,
											NULL,
											NULL);
	
	
		if (ndisStatus != NDIS_STATUS_SUCCESS)
		{
			//	No mac options.
			ndisStatus = NDIS_STATUS_SUCCESS;
			macOptions = 0;
		}

		pPortDesc->pd_MacOptions	= macOptions;
		DBGPRINT(DBG_COMP_NDISREQ, DBG_LEVEL_INFO,
				("AtalkNdisQueryAddrInfo: MacOptions %lx\n", macOptions));
	} while (FALSE);

	return AtalkNdisToAtalkError(ndisStatus);
}




ATALK_ERROR
AtalkInitNdisSetLookaheadSize(
	IN  PPORT_DESCRIPTOR	pPortDesc,
	IN  INT					LookaheadSize		// Has to be INT
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	NDIS_REQUEST  	request;
	NDIS_STATUS		ndisStatus = NDIS_STATUS_SUCCESS;

	do
	{
		//  Check to see it we bound successfully to this adapter
		if (!PORT_BOUND(pPortDesc))
		{
			LOG_ERRORONPORT(pPortDesc,
							EVENT_ATALK_NOTBOUNDTOMAC,
							STATUS_INSUFFICIENT_RESOURCES,
							NULL,
							0);

			ndisStatus = NDIS_STATUS_RESOURCES;
			break;
		}

		//  Setup request
		request.RequestType = NdisRequestSetInformation;
		request.DATA.SET_INFORMATION.Oid = OID_GEN_CURRENT_LOOKAHEAD;
		request.DATA.SET_INFORMATION.InformationBuffer = (PBYTE)&LookaheadSize;
		request.DATA.SET_INFORMATION.InformationBufferLength = sizeof(LookaheadSize);

		ndisStatus = AtalkNdisSubmitRequest(pPortDesc,
											&request,
											TRUE,
											NULL,
											NULL);
	
		if (ndisStatus != NDIS_STATUS_SUCCESS)
		{
			LOG_ERRORONPORT(pPortDesc,
							EVENT_ATALK_LOOKAHEADSIZE,
							STATUS_INSUFFICIENT_RESOURCES,
							NULL,
							0);
		}

	} while (FALSE);

	return AtalkNdisToAtalkError(ndisStatus);
}



ATALK_ERROR
AtalkInitNdisStartPacketReception(
	IN	PPORT_DESCRIPTOR	pPortDesc
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	NDIS_REQUEST  	request;
	ULONG   		packetFilter;
	NDIS_STATUS	 	ndisStatus = NDIS_STATUS_SUCCESS;
	KIRQL			OldIrql;

	do
	{
		//  Check to see it we bound successfully to this adapter
		if (!PORT_BOUND(pPortDesc))
		{
			LOG_ERRORONPORT(pPortDesc,
							EVENT_ATALK_NOTBOUNDTOMAC,
							STATUS_INSUFFICIENT_RESOURCES,
							NULL,
							0);

			ndisStatus = NDIS_STATUS_RESOURCES;
			break;
		}

		switch (pPortDesc->pd_NdisPortType)
		{
		  case NdisMedium802_3 :
		  case NdisMediumFddi :
			packetFilter = NDIS_PACKET_TYPE_DIRECTED | NDIS_PACKET_TYPE_MULTICAST;
			break;

		  case NdisMedium802_5:
			packetFilter = NDIS_PACKET_TYPE_DIRECTED | NDIS_PACKET_TYPE_FUNCTIONAL;
			break;

		  case NdisMediumLocalTalk :
			packetFilter = NDIS_PACKET_TYPE_DIRECTED | NDIS_PACKET_TYPE_BROADCAST;
			break;

          case NdisMediumWan:
			packetFilter = NDIS_PACKET_TYPE_DIRECTED | NDIS_PACKET_TYPE_MULTICAST;
			break;

		  default:
			KeBugCheck(0);
			break;
		}

		//  Setup request
		request.RequestType = NdisRequestSetInformation;
		request.DATA.SET_INFORMATION.Oid =OID_GEN_CURRENT_PACKET_FILTER;
		request.DATA.SET_INFORMATION.InformationBuffer = (PBYTE)&packetFilter;
		request.DATA.SET_INFORMATION.InformationBufferLength = sizeof(packetFilter);

		ndisStatus = AtalkNdisSubmitRequest(pPortDesc,
											&request,
											TRUE,
											NULL,
											NULL);
	
		if (ndisStatus != NDIS_STATUS_SUCCESS)
		{
			LOG_ERRORONPORT(pPortDesc,
							EVENT_ATALK_PACKETFILTER,
							STATUS_INSUFFICIENT_RESOURCES,
							NULL,
							0);
		}
	} while (FALSE);

	return AtalkNdisToAtalkError(ndisStatus);
}




NDIS_STATUS
AtalkNdisSubmitRequest(
	PPORT_DESCRIPTOR	pPortDesc,
	PNDIS_REQUEST		Request,
	BOOLEAN				ExecuteSync,
	REQ_COMPLETION		CompletionRoutine,
	PVOID				Ctx
	)
/*++

Routine Description:


Arguments:


Return Value:

	None
--*/
{
	NDIS_STATUS			ndisStatus;
	PATALK_NDIS_REQ		atalkNdisRequest;

	//	Allocate an atalk request packet
	if ((atalkNdisRequest = AtalkAllocMemory(sizeof(ATALK_NDIS_REQ))) == NULL)
	{
		return NDIS_STATUS_RESOURCES;
	}

	atalkNdisRequest->nr_Request 			= *Request;
	atalkNdisRequest->nr_Sync				= ExecuteSync;
	atalkNdisRequest->nr_RequestCompletion 	= CompletionRoutine;
	atalkNdisRequest->nr_Ctx				= Ctx;

	if (ExecuteSync)
	{
		//  Make sure we are not at or above dispatch level
		//	Also assert that the completion routine is NULL
		ASSERT(KeGetCurrentIrql() == LOW_LEVEL);
		ASSERT(CompletionRoutine == NULL);

		//	Initialize event to not signalled before possible wait.
		KeInitializeEvent(&atalkNdisRequest->nr_Event,
						  NotificationEvent,
						  FALSE);
	}

	NdisRequest(&ndisStatus,
				pPortDesc->pd_NdisBindingHandle,
				&atalkNdisRequest->nr_Request);

	DBGPRINT(DBG_COMP_NDISREQ, DBG_LEVEL_INFO,
			("atalkNdisSubmitRequest: status NdisRequest %lx\n", ndisStatus));

	if (ndisStatus == NDIS_STATUS_PENDING)
	{
		if (ExecuteSync)
		{
			KeWaitForSingleObject(&atalkNdisRequest->nr_Event,
								  Executive,
								  KernelMode,
								  FALSE,
								  NULL);
	
			ndisStatus = atalkNdisRequest->nr_RequestStatus;
			AtalkFreeMemory((PVOID)atalkNdisRequest);
		}
	}
	else if (ndisStatus == NDIS_STATUS_SUCCESS)
	{
		//	Ndis will not call the completion routine.
		if (!ExecuteSync)
		{
			//	Call the users completion routine if specified.
			if (CompletionRoutine != NULL)
			{
				(*CompletionRoutine)(NDIS_STATUS_SUCCESS, Ctx);
			}
		}
		AtalkFreeMemory((PVOID)atalkNdisRequest);
	}
	else
	{
		//	There was an error. Just free up the atalk ndis request.
		AtalkFreeMemory((PVOID)atalkNdisRequest);
	}

	return ndisStatus;
}




//  Protocol/NDIS interaction code

VOID
AtalkOpenAdapterComplete(
	IN	NDIS_HANDLE NdisBindCtx,
	IN	NDIS_STATUS Status,
	IN	NDIS_STATUS OpenErrorStatus
	)
/*++

Routine Description:

	This routine is called during by NDIS to indicate that an open adapter
	is complete. This happens only during initialization and single-file. Clear
	the event, so the blocked init thread can go on to the next adapter. Set the
	status in the ndis port descriptor for this adapter.

Arguments:

	NdisBindCtx- Pointer to a port descriptor for this port
	Status- completion status of open adapter
	OpenErrorStatus- Extra status information

Return Value:

	None

--*/
{
	PPORT_DESCRIPTOR	pPortDesc = (PPORT_DESCRIPTOR)NdisBindCtx;

	pPortDesc->pd_RequestStatus = Status;
	KeSetEvent(&pPortDesc->pd_RequestEvent, IO_NETWORK_INCREMENT, FALSE);
}




VOID
AtalkCloseAdapterComplete(
	IN	NDIS_HANDLE NdisBindCtx,
	IN	NDIS_STATUS Status
	)
/*++

Routine Description:

	This routine is called by NDIS to indicate that a close adapter is complete.

Arguments:

	NdisBindCtx- Pointer to a port descriptor for this port
	Status- completion status of close adapter

Return Value:

	None

--*/
{
	PPORT_DESCRIPTOR	pPortDesc = (PPORT_DESCRIPTOR)NdisBindCtx;

	pPortDesc->pd_RequestStatus = Status;
	KeSetEvent(&pPortDesc->pd_RequestEvent, IO_NETWORK_INCREMENT, FALSE);
}




VOID
AtalkResetComplete(
	IN	NDIS_HANDLE NdisBindCtx,
	IN	NDIS_STATUS Status
	)
/*++

Routine Description:

	This routine is called by NDIS to indicate that a reset is complete.

Arguments:

	NdisBindCtx- Pointer to a port descriptor for this port
	Status- completion status of close adapter

Return Value:

	None

--*/
{
	UNREFERENCED_PARAMETER(NdisBindCtx);
}




VOID
AtalkRequestComplete(
	IN	NDIS_HANDLE			NdisBindCtx,
	IN	PNDIS_REQUEST		NdisRequest,
	IN	NDIS_STATUS 		Status
	)
/*++

Routine Description:

	This routine is called by NDIS to indicate that a NdisRequest is complete.

Arguments:

	NdisBindCtx- Pointer to a port descriptor for this port
	NdisRequest- Block identifying the request
	Status- completion status of close adapter

Return Value:

	None

--*/
{
	PATALK_NDIS_REQ		atalkRequest;

	//  Get the AtalkRequest block
	atalkRequest = CONTAINING_RECORD(NdisRequest, ATALK_NDIS_REQ, nr_Request);

	DBGPRINT(DBG_COMP_NDISREQ, DBG_LEVEL_INFO,
			("AtalkRequestComplete: %lx status %lx\n", atalkRequest, Status));

	if (atalkRequest->nr_Sync)
	{
		//	This was a sync request
		//  Set status and clear event

		ASSERT(atalkRequest->nr_RequestCompletion == NULL);
		atalkRequest->nr_RequestStatus = Status;
		KeSetEvent(&atalkRequest->nr_Event, IO_NETWORK_INCREMENT, FALSE);
	}

	//  Call the completion routine if specified
	if (atalkRequest->nr_RequestCompletion != NULL)
	{
		(*atalkRequest->nr_RequestCompletion)(Status, atalkRequest->nr_Ctx);
	}

	if (!atalkRequest->nr_Sync)
		AtalkFreeMemory(atalkRequest);
}




VOID
AtalkStatusIndication(
	IN	NDIS_HANDLE 	NdisBindCtx,
	IN	NDIS_STATUS 	GeneralStatus,
	IN	PVOID			StatusBuf,
	IN	UINT 			StatusBufLen
	)
/*++

Routine Description:

	This routine is called by NDIS to indicate a status change.

Arguments:

	NdisBindCtx- Pointer to a port descriptor for this port
	GeneralStatus- A general status value
	StatusBuffer - A more specific status value

Return Value:

	None

--*/
{

    PPORT_DESCRIPTOR    pPortDesc;


    pPortDesc = (PPORT_DESCRIPTOR)NdisBindCtx;

    // line-up, line-down or stat request from ndiswan?  deal with it!
    if (pPortDesc == RasPortDesc)
    {
        RasStatusIndication(GeneralStatus, StatusBuf, StatusBufLen);
    }

	DBGPRINT(DBG_COMP_NDISREQ, DBG_LEVEL_ERR,
			("AtalkStatusIndication: Status indication called %lx\n", GeneralStatus));
}




VOID
AtalkStatusComplete (
	IN	NDIS_HANDLE ProtoBindCtx
	)
/*++

Routine Description:

	This routine is called by NDIS to allow postprocessing after a status event.

Arguments:

	ProtoBindCtx- Value associated with the binding with the adapter

Return Value:

	None

--*/
{
	UNREFERENCED_PARAMETER(ProtoBindCtx);

	DBGPRINT(DBG_COMP_NDISREQ, DBG_LEVEL_WARN,
			("AtalkStatusComplete: Status complete called\n"));
}




typedef	struct
{
	REQ_COMPLETION		AddCompletion;
	PVOID				AddContext;
	PBYTE				Buffer;
} ADDMC, *PADDMC;

LOCAL VOID
atalkNdisAddMulticastCompletion(
	IN	NDIS_STATUS 	Status,
	IN	PADDMC			pAmc
)
{
	if (pAmc->Buffer != NULL)
		AtalkFreeMemory(pAmc->Buffer);
	if (pAmc->AddCompletion != NULL)
		(*pAmc->AddCompletion)(Status, pAmc->AddContext);
	AtalkFreeMemory(pAmc);
}

ATALK_ERROR
AtalkNdisReplaceMulticast(
	IN  PPORT_DESCRIPTOR		pPortDesc,
	IN  PBYTE					OldAddress,
	IN  PBYTE					NewAddress
	)
{
	INT				sizeOfList, i, numberInList;
	PBYTE			addressData, currentList, tempList;
	KIRQL			OldIrql;
	NDIS_REQUEST	request;
	NDIS_OID		ndisOid;
	NDIS_STATUS		ndisStatus;
	PADDMC			pAmc;

	//  Check to see it we bound successfully to this adapter
	if (!PORT_BOUND(pPortDesc))
	{
		LOG_ERRORONPORT(pPortDesc,
						EVENT_ATALK_NOTBOUNDTOMAC,
						STATUS_INSUFFICIENT_RESOURCES,
						NULL,
						0);

		ndisStatus = NDIS_STATUS_RESOURCES;
		goto errorExit;
	}

	//  Grab the perport spinlock. Again, a very infrequent operation.
	//	Probably just twice in the lifetime of the stack.
	ACQUIRE_SPIN_LOCK(&pPortDesc->pd_Lock, &OldIrql);

	if (pPortDesc->pd_MulticastList != NULL)
	{
		numberInList = pPortDesc->pd_MulticastListSize/ELAP_ADDR_LEN;
		currentList  = pPortDesc->pd_MulticastList;
		for (i = 0; i < numberInList; i++, currentList += ELAP_ADDR_LEN)
		{
			//	Search for the address and remember the index if found
			if (RtlCompareMemory(currentList,
								 OldAddress,
								 ELAP_ADDR_LEN) == ELAP_ADDR_LEN)
			{
				//	Move all address following this overwriting this address
				//	we ignore wasted space that will never be touched anymore.
				//	This could turn out to be a NOP if we are removing the last
				//	address in the list.
				RtlMoveMemory(currentList,
							  currentList + ELAP_ADDR_LEN,
							  pPortDesc->pd_MulticastListSize-((i+1)*ELAP_ADDR_LEN));

				pPortDesc->pd_MulticastListSize -= ELAP_ADDR_LEN;

				//	Have we removed the last address. If so, reset values.
				if (pPortDesc->pd_MulticastListSize == 0)
				{
					AtalkFreeMemory(pPortDesc->pd_MulticastList);
					pPortDesc->pd_MulticastList = NULL;
				}

				break;
			}
		}
	}
	else
	{
		// Nothing to remove
		pPortDesc->pd_MulticastListSize = 0;
	}
	
  	sizeOfList = pPortDesc->pd_MulticastListSize + ELAP_ADDR_LEN;

	ASSERTMSG("AtalkNdisAddMulticast: Size is not > 0\n", (sizeOfList > 0));

	//	Allocate/reallocate the list for the port descriptor, and also
	//	for a copy to be used in the NDIS request function.
	tempList = (PBYTE)AtalkAllocZeroedMemory(sizeOfList);
	addressData = (PBYTE)AtalkAllocZeroedMemory(sizeOfList);
	pAmc = (PADDMC)AtalkAllocZeroedMemory(sizeof(ADDMC));

	if ((tempList == NULL) || (addressData == NULL) || (pAmc == NULL))
	{
		//  Release the spinlock
		RELEASE_SPIN_LOCK(&pPortDesc->pd_Lock, OldIrql);

		if (pAmc != NULL)
			AtalkFreeMemory(pAmc);
		if (tempList != NULL)
			AtalkFreeMemory(tempList);
		if (addressData != NULL)
			AtalkFreeMemory(addressData);

		return ATALK_RESR_MEM;
	}

	if (pPortDesc->pd_MulticastList != NULL)
	{
		//  Copy the old list over to the new space
		RtlCopyMemory(tempList,
					  pPortDesc->pd_MulticastList,
					  pPortDesc->pd_MulticastListSize);
	
		//  Set the proper values back into PortDesc after freeing the old list
		AtalkFreeMemory(pPortDesc->pd_MulticastList);
	}

	//  Guaranteed space is available to copy the new address
	//  Ready to copy our new address here and then do the set!
	RtlCopyMemory(tempList + pPortDesc->pd_MulticastListSize,
				  NewAddress,
				  ELAP_ADDR_LEN);

	pPortDesc->pd_MulticastList = tempList;
	pPortDesc->pd_MulticastListSize = sizeOfList;

	switch (pPortDesc->pd_NdisPortType)
	{
	  case NdisMedium802_3 :

		ndisOid = OID_802_3_MULTICAST_LIST;
		break;

	  case NdisMediumFddi:

		//  FDDI supports 2byte and 6byte multicast addresses. We use the
		//  6byte multicast addresses for appletalk.
		ndisOid = OID_FDDI_LONG_MULTICAST_LIST;
		break;

	  default:

		KeBugCheck(0);
		break;
	}

	//  Setup request
	//  Move the list to our buffer

	ASSERTMSG("AtalkNdisAddMulticast: Size incorrect!\n",
			 ((ULONG)sizeOfList == pPortDesc->pd_MulticastListSize));
	
	RtlCopyMemory(addressData,
				  pPortDesc->pd_MulticastList,
				  pPortDesc->pd_MulticastListSize);

	//  Release the spinlock
	RELEASE_SPIN_LOCK(&pPortDesc->pd_Lock, OldIrql);

	request.RequestType = NdisRequestSetInformation;
	request.DATA.SET_INFORMATION.Oid = ndisOid;
	request.DATA.SET_INFORMATION.InformationBuffer = addressData;
	request.DATA.SET_INFORMATION.InformationBufferLength = sizeOfList;
	pAmc->AddCompletion = NULL;
	pAmc->AddContext = NULL;
	pAmc->Buffer = addressData;

	ndisStatus = AtalkNdisSubmitRequest(pPortDesc,
										&request,
										FALSE,
										atalkNdisAddMulticastCompletion,
										pAmc);

	//	NOTE: Sumbit calls completion if success is being returned.
	if ((ndisStatus != NDIS_STATUS_SUCCESS) &&
		(ndisStatus != NDIS_STATUS_PENDING))
	{
		LOG_ERRORONPORT(pPortDesc,
						EVENT_ATALK_NDISREQUEST,
						ndisStatus,
						NULL,
						0);
	}

errorExit:
	return AtalkNdisToAtalkError(ndisStatus);
}

ATALK_ERROR
AtalkNdisAddMulticast(
	IN  PPORT_DESCRIPTOR		pPortDesc,
	IN  PBYTE					Address,
	IN  BOOLEAN					ExecuteSynchronously,
	IN  REQ_COMPLETION			AddCompletion,
	IN  PVOID					AddContext
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	INT				sizeOfList;
	PBYTE			addressData, tempList;
	KIRQL			OldIrql;
	NDIS_OID		ndisOid;
	NDIS_REQUEST	request;
	NDIS_STATUS		ndisStatus;
	PADDMC			pAmc;

	//  Check to see it we bound successfully to this adapter
	if (!PORT_BOUND(pPortDesc))
	{
		LOG_ERRORONPORT(pPortDesc,
						EVENT_ATALK_NOTBOUNDTOMAC,
						STATUS_INSUFFICIENT_RESOURCES,
						NULL,
						0);

		return ATALK_FAILURE;
	}

	//  Grab the perport spinlock. We need to allocate within a
	//	critical section as the size might change. This routine
	//	is called very infrequently, during init and when we
	//	receive our default zone from zip.

	ACQUIRE_SPIN_LOCK(&pPortDesc->pd_Lock, &OldIrql);
	sizeOfList = pPortDesc->pd_MulticastListSize + ELAP_ADDR_LEN;

	ASSERTMSG("AtalkNdisAddMulticast: Size is not > 0\n", (sizeOfList > 0));

	//	Allocate/reallocate the list for the port descriptor, and also
	//	for a copy to be used in the NDIS request function.
	tempList = (PBYTE)AtalkAllocZeroedMemory(sizeOfList);
	addressData = (PBYTE)AtalkAllocZeroedMemory(sizeOfList);
	pAmc = (PADDMC)AtalkAllocZeroedMemory(sizeof(ADDMC));

	if ((tempList == NULL) || (addressData == NULL) || (pAmc == NULL))
	{
		//  Release the spinlock
		RELEASE_SPIN_LOCK(&pPortDesc->pd_Lock, OldIrql);

		if (pAmc != NULL)
			AtalkFreeMemory(pAmc);
		if (tempList != NULL)
			AtalkFreeMemory(tempList);
		if (addressData != NULL)
			AtalkFreeMemory(addressData);

		return ATALK_RESR_MEM;
	}

	if (pPortDesc->pd_MulticastList == NULL)
	{
		//	No old addresses to work with.
		pPortDesc->pd_MulticastListSize = 0;
	}
	else
	{
		//  Copy the old list over to the new space
		RtlCopyMemory(tempList,
					  pPortDesc->pd_MulticastList,
					  pPortDesc->pd_MulticastListSize);
	
		//  Set the proper values back into PortDesc after freeing the old list
		AtalkFreeMemory(pPortDesc->pd_MulticastList);
	}

	//  Guaranteed space is available to copy the new address
	//  Ready to copy our new address here and then do the set!
	RtlCopyMemory(tempList + pPortDesc->pd_MulticastListSize,
				  Address,
				  ELAP_ADDR_LEN);

	pPortDesc->pd_MulticastList = tempList;
	pPortDesc->pd_MulticastListSize = sizeOfList;

	switch (pPortDesc->pd_NdisPortType)
	{
	  case NdisMedium802_3 :

		ndisOid = OID_802_3_MULTICAST_LIST;
		break;

	  case NdisMediumFddi:

		//  FDDI supports 2byte and 6byte multicast addresses. We use the
		//  6byte multicast addresses for appletalk.
		ndisOid = OID_FDDI_LONG_MULTICAST_LIST;
		break;

	  default:

		KeBugCheck(0);
		break;
	}

	//  Setup request
	//  Move the list to our buffer

	ASSERTMSG("AtalkNdisAddMulticast: Size incorrect!\n",
			 ((ULONG)sizeOfList == pPortDesc->pd_MulticastListSize));
	
	RtlCopyMemory(addressData,
				  pPortDesc->pd_MulticastList,
				  pPortDesc->pd_MulticastListSize);

	//  Release the spinlock
	RELEASE_SPIN_LOCK(&pPortDesc->pd_Lock, OldIrql);

	request.RequestType = NdisRequestSetInformation;
	request.DATA.SET_INFORMATION.Oid = ndisOid;
	request.DATA.SET_INFORMATION.InformationBuffer = addressData;
	request.DATA.SET_INFORMATION.InformationBufferLength = sizeOfList;
	pAmc->AddCompletion = AddCompletion;
	pAmc->AddContext = AddContext;
	pAmc->Buffer = addressData;

	ndisStatus = AtalkNdisSubmitRequest(pPortDesc,
										&request,
										FALSE,
										atalkNdisAddMulticastCompletion,
										pAmc);

	//	NOTE: Sumbit calls completion if success is being returned.
	if ((ndisStatus != NDIS_STATUS_SUCCESS) &&
		(ndisStatus != NDIS_STATUS_PENDING))
	{
		LOG_ERRORONPORT(pPortDesc,
						EVENT_ATALK_NDISREQUEST,
						ndisStatus,
						NULL,
						0);
	}

	return AtalkNdisToAtalkError(ndisStatus);
}




ATALK_ERROR
AtalkNdisRemoveMulticast(
	IN  PPORT_DESCRIPTOR	pPortDesc,
	IN  PBYTE				Address,
	IN  BOOLEAN				ExecuteSynchronously,
	IN  REQ_COMPLETION		RemoveCompletion,
	IN  PVOID				RemoveContext
	)
{
	INT				sizeOfList, i, numberInList;
	PBYTE			addressData, currentList;
	KIRQL			OldIrql;
	NDIS_REQUEST	request;
	NDIS_OID		ndisOid;
	NDIS_STATUS		ndisStatus;
	PADDMC			pAmc;

	do
	{
		//  Check to see it we bound successfully to this adapter
		if (!PORT_BOUND(pPortDesc))
		{
			LOG_ERRORONPORT(pPortDesc,
							EVENT_ATALK_NOTBOUNDTOMAC,
							STATUS_INSUFFICIENT_RESOURCES,
							NULL,
							0);

			ndisStatus = NDIS_STATUS_RESOURCES;
			break;
		}

		//  Grab the perport spinlock. Again, a very infrequent operation.
		//	Probably just twice in the lifetime of the stack.
		ACQUIRE_SPIN_LOCK(&pPortDesc->pd_Lock, &OldIrql);

		ASSERT(pPortDesc->pd_MulticastList != NULL);
		if (pPortDesc->pd_MulticastList == NULL)
		{
			//   Nothing to remove!
			ndisStatus = NDIS_STATUS_SUCCESS;
			RELEASE_SPIN_LOCK(&pPortDesc->pd_Lock, OldIrql);
			break;
		}
	
		numberInList = pPortDesc->pd_MulticastListSize/ELAP_ADDR_LEN;
		currentList  = pPortDesc->pd_MulticastList;
		for (i = 0; i < numberInList; i++, currentList += ELAP_ADDR_LEN)
		{
			//	Search for the address and remember the index if found
			if (RtlCompareMemory(currentList,
								 Address,
								 ELAP_ADDR_LEN) == ELAP_ADDR_LEN)
			{
				//	Move all address following this overwriting this address
				//	we ignore wasted space that will never be touched anymore.
				//	This could turn out to be a NOP if we are removing the last
				//	address in the list.
				RtlMoveMemory(currentList,
							  currentList + ELAP_ADDR_LEN,
							  pPortDesc->pd_MulticastListSize-((i+1)*ELAP_ADDR_LEN));
	
				pPortDesc->pd_MulticastListSize -= ELAP_ADDR_LEN;
	
				//	Have we removed the last address. If so, reset values.
				if (pPortDesc->pd_MulticastListSize == 0)
				{
					AtalkFreeMemory(pPortDesc->pd_MulticastList);
					pPortDesc->pd_MulticastList = NULL;
				}
	
				break;
			}
		}
	
		//	We assume address was found and the list is changed as expected
		//	Set this new list
		switch (pPortDesc->pd_NdisPortType)
		{
		  case NdisMedium802_3 :
	
			ndisOid = OID_802_3_MULTICAST_LIST;
			break;
	
		  case NdisMediumFddi:
	
			//  FDDI supports 2byte and 6byte multicast addresses. We use the
			//  6byte multicast addresses for appletalk.
			ndisOid = OID_FDDI_LONG_MULTICAST_LIST;
			break;
	
		  default:
	
			KeBugCheck(0);
			break;
		}
	
		addressData = NULL;
		sizeOfList  = pPortDesc->pd_MulticastListSize;
	
	    pAmc = (PADDMC)AtalkAllocZeroedMemory(sizeof(ADDMC));

		if (pAmc == NULL)
        {
			RELEASE_SPIN_LOCK(&pPortDesc->pd_Lock, OldIrql);
			ndisStatus = NDIS_STATUS_RESOURCES;
			break;
        }

		if (sizeOfList > 0)
		{
			//	Allocate addressData and copy list to it
			addressData = (PBYTE)AtalkAllocMemory(sizeOfList);
			if (addressData == NULL)
			{
				//  Release the spinlock
				RELEASE_SPIN_LOCK(&pPortDesc->pd_Lock, OldIrql);
			    AtalkFreeMemory(pAmc);
				ndisStatus = NDIS_STATUS_RESOURCES;
				break;
			}

			//  Move the list to our buffer
			RtlCopyMemory(addressData,
						  pPortDesc->pd_MulticastList,
						  pPortDesc->pd_MulticastListSize);
		}
	
		//  Release the spinlock
		RELEASE_SPIN_LOCK(&pPortDesc->pd_Lock, OldIrql);
	
		request.RequestType = NdisRequestSetInformation;
		request.DATA.SET_INFORMATION.Oid = ndisOid;
		request.DATA.SET_INFORMATION.InformationBuffer = addressData;
		request.DATA.SET_INFORMATION.InformationBufferLength = sizeOfList;
		pAmc->AddCompletion = RemoveCompletion;
		pAmc->AddContext = RemoveContext;
		pAmc->Buffer = addressData;
		
		ndisStatus = AtalkNdisSubmitRequest(pPortDesc,
											&request,
											FALSE,
											atalkNdisAddMulticastCompletion,
											pAmc);
	
		if ((ndisStatus != NDIS_STATUS_SUCCESS) &&
			(ndisStatus != NDIS_STATUS_PENDING))
		{
			LOG_ERRORONPORT(pPortDesc,
							EVENT_ATALK_NDISREQUEST,
							ndisStatus,
							NULL,
							0);
		}

	} while (FALSE);

	return AtalkNdisToAtalkError(ndisStatus);
}



ATALK_ERROR
AtalkNdisSendPacket(
	IN  PPORT_DESCRIPTOR			pPortDesc,
	IN  PBUFFER_DESC				BufferChain,
	IN  SEND_COMPLETION				SendCompletion	OPTIONAL,
	IN  PSEND_COMPL_INFO			pSendInfo		OPTIONAL
	)
/*++

Routine Description:

	This routine is called by the portable code to send a packet out on
	ethernet. It will build the NDIS packet descriptor for the passed in
	chain and then send the packet on the specified port.

Arguments:


Return Value:

	TRUE- If sent/pending, FALSE otherwise
		  TransmitComplete is called if this call pended by completion code

--*/
{
	PNDIS_PACKET	ndisPacket;
	PNDIS_BUFFER	ndisBuffer;
	PPROTOCOL_RESD  protocolResd;
	ATALK_ERROR		error;
	PSENDBUF		pSendBuf;
	NDIS_STATUS	 	ndisStatus	= NDIS_STATUS_SUCCESS;
    PMDL            pMdl;
    PMDL            pFirstMdl=NULL;

	if (PORT_CLOSING(pPortDesc))
	{
		//	If we are not active, return!
		return ATALK_PORT_CLOSING;
	}

	do
	{
		pSendBuf	= (PSENDBUF)((PBYTE)BufferChain - sizeof(BUFFER_HDR));
		ndisPacket	= pSendBuf->sb_BuffHdr.bh_NdisPkt;

		//  Store the information needed in the packet descriptor
		protocolResd = (PPROTOCOL_RESD)&ndisPacket->ProtocolReserved;
		protocolResd->Send.pr_Port 				= pPortDesc;
		protocolResd->Send.pr_BufferDesc 		= BufferChain;
		protocolResd->Send.pr_SendCompletion 	= SendCompletion;
		if (pSendInfo != NULL)
			 protocolResd->Send.pr_SendInfo 	= *pSendInfo;
		else RtlZeroMemory(&protocolResd->Send.pr_SendInfo, sizeof(SEND_COMPL_INFO));

		//	For the first buffer, set up the length of the NDIS buffer to be
		//	the same as in indicated in the descriptor.
		NdisAdjustBufferLength(pSendBuf->sb_BuffHdr.bh_NdisBuffer,
							   BufferChain->bd_Length);
	
		//	NOTE: There is either a PBYTE being pointed to, or a PAMDL
		//		  being pointed to by the buffer descriptor. Also, the
		//		  size of the data will be the size that is to be
		//		  used. At the end, just assert that the total length
		//		  equals length passed in.
		if (BufferChain->bd_Next != NULL)
		{
			if (BufferChain->bd_Next->bd_Flags & BD_CHAR_BUFFER)
			{
				NdisAllocateBuffer(&ndisStatus,
								   &ndisBuffer,
								   AtalkNdisBufferPoolHandle,
								   (PVOID)BufferChain->bd_Next->bd_CharBuffer,
								   (UINT)BufferChain->bd_Next->bd_Length);
	
				if (ndisStatus != NDIS_STATUS_SUCCESS)
				{
					DBGPRINT(DBG_COMP_NDISSEND, DBG_LEVEL_ERR,
							("AtalkNdisSendPacket: NdisAllocateBuffer %lx\n", ndisStatus));
					// LOG_ERROR(EVENT_ATALK_NDISRESOURCES, ndisStatus, NULL, 0);
					break;
				}

                ATALK_DBG_INC_COUNT(AtalkDbgMdlsAlloced);

			    NdisChainBufferAtBack(ndisPacket, ndisBuffer);
			}
			else
			{
				//  It is an MDL
                pMdl = (PMDL)BufferChain->bd_Next->bd_OpaqueBuffer;

                ASSERT(AtalkSizeMdlChain(pMdl) == BufferChain->bd_Next->bd_Length);
                while (pMdl)
                {
				    NdisCopyBuffer(&ndisStatus,
					    		   &ndisBuffer,
						    	   AtalkNdisBufferPoolHandle,
    							   (PVOID)pMdl,
	    						   0,  				//Offset
		    					   (UINT)MmGetMdlByteCount(pMdl));

				    if (ndisStatus != NDIS_STATUS_SUCCESS)
				    {
                        if (pFirstMdl)
                        {
                            AtalkNdisFreeBuffer(pFirstMdl);
                        }
					    break;
				    }
	
                    ATALK_DBG_INC_COUNT(AtalkDbgMdlsAlloced);

                    if (!pFirstMdl)
                    {
                        pFirstMdl = pMdl;
                    }

			        NdisChainBufferAtBack(ndisPacket, ndisBuffer);

                    pMdl = pMdl->Next;
                }

				if (ndisStatus != NDIS_STATUS_SUCCESS)
				{
				    DBGPRINT(DBG_COMP_NDISSEND, DBG_LEVEL_ERR,
					    ("AtalkNdisSendPacket: NdisCopyBuffer %lx\n", ndisStatus));
				    break;
				}
			}
		}
	
#ifdef	PROFILING
		INTERLOCKED_INCREMENT_LONG_DPC(
			&pPortDesc->pd_PortStats.prtst_CurSendsOutstanding,
			&AtalkStatsLock.SpinLock);
#endif
		INTERLOCKED_INCREMENT_LONG_DPC(
			&pPortDesc->pd_PortStats.prtst_NumPacketsOut,
			&AtalkStatsLock.SpinLock);

		//  Now send the built packet descriptor
		NdisSend(&ndisStatus,
				 pPortDesc->pd_NdisBindingHandle,
				 ndisPacket);

		//	Completion will dereference the port!
		if (ndisStatus != NDIS_STATUS_PENDING)
		{
			//  Call the completion handler
			AtalkSendComplete(pPortDesc->pd_NdisBindingHandle,
							  ndisPacket,
							  ndisStatus);
			ndisStatus	= NDIS_STATUS_PENDING;
		}
	} while (FALSE);

	return AtalkNdisToAtalkError(ndisStatus);
}



ATALK_ERROR
AtalkNdisAddFunctional(
	IN  PPORT_DESCRIPTOR		pPortDesc,
	IN  PBYTE					Address,
	IN  BOOLEAN					ExecuteSynchronously,
	IN  REQ_COMPLETION			AddCompletion,
	IN  PVOID					AddContext
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	ULONG			i;
	NDIS_REQUEST	request;
	NDIS_STATUS		ndisStatus;
	KIRQL			OldIrql;

	DBGPRINT(DBG_COMP_NDISREQ, DBG_LEVEL_INFO,
			("Current %02x%02x%02x%02x, Adding %02x%02x%02x%02x\n",
			 pPortDesc->pd_FunctionalAddr[0], pPortDesc->pd_FunctionalAddr[1],
             pPortDesc->pd_FunctionalAddr[2], pPortDesc->pd_FunctionalAddr[3],
			 Address[2], Address[3], Address[4], Address[5]));

	//  Grab the perport spinlock
	ACQUIRE_SPIN_LOCK(&pPortDesc->pd_Lock, &OldIrql);

	//  We only need the last four bytes of the address assuming that the
	//  first two bytes always remain the same (C000) and that the MAC assumes
	//  the same- NDIS 3.0 OID length = 4
	for (i = 0;
		 i < sizeof(ULONG);
		 i++)
		pPortDesc->pd_FunctionalAddr[i] |= Address[2+i];

	//  Release the spinlock
	RELEASE_SPIN_LOCK(&pPortDesc->pd_Lock, OldIrql);

	DBGPRINT(DBG_COMP_NDISREQ, DBG_LEVEL_INFO,
			("After Add %02x%02x%02x%02x\n",
			 pPortDesc->pd_FunctionalAddr[0], pPortDesc->pd_FunctionalAddr[1],
             pPortDesc->pd_FunctionalAddr[2], pPortDesc->pd_FunctionalAddr[3]));

	request.RequestType = NdisRequestSetInformation;
	request.DATA.SET_INFORMATION.Oid = OID_802_5_CURRENT_FUNCTIONAL;
	request.DATA.SET_INFORMATION.InformationBuffer = pPortDesc->pd_FunctionalAddr;
	request.DATA.SET_INFORMATION.InformationBufferLength = TLAP_ADDR_LEN - TLAP_MCAST_HDR_LEN;

	ndisStatus = AtalkNdisSubmitRequest(pPortDesc,
										&request,
										ExecuteSynchronously,
										AddCompletion,
										AddContext);

	if (ndisStatus == NDIS_STATUS_PENDING)
	{
		ASSERT(ExecuteSynchronously != TRUE);
	}
	else if (ndisStatus != NDIS_STATUS_SUCCESS)
	{
		LOG_ERRORONPORT(pPortDesc,
						EVENT_ATALK_NDISREQUEST,
						ndisStatus,
						NULL,
						0);
	}

	return AtalkNdisToAtalkError(ndisStatus);
}




ATALK_ERROR
AtalkNdisRemoveFunctional(
	IN  PPORT_DESCRIPTOR		pPortDesc,
	IN  PBYTE					Address,
	IN  BOOLEAN					ExecuteSynchronously,
	IN  REQ_COMPLETION			RemoveCompletion,
	IN  PVOID					RemoveContext
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	ULONG			i;
	KIRQL			OldIrql;
	NDIS_REQUEST	request;
	NDIS_STATUS		ndisStatus;

	DBGPRINT(DBG_COMP_NDISREQ, DBG_LEVEL_INFO,
			("Current %02x%02x%02x%02x, Removing %02x%02x%02x%02x\n",
			pPortDesc->pd_FunctionalAddr[0], pPortDesc->pd_FunctionalAddr[1],
            pPortDesc->pd_FunctionalAddr[2], pPortDesc->pd_FunctionalAddr[3],
			Address[2], Address[3], Address[4], Address[5]));

	//  Grab the perport spinlock
	ACQUIRE_SPIN_LOCK(&pPortDesc->pd_Lock, &OldIrql);

	//  We only need the last four bytes of the address assuming that the
	//  first two bytes always remain the same (C000) and that the MAC assumes
	//  the same- NDIS 3.0 OID length = 4
	for (i = 0; i < sizeof(ULONG); i++)
		pPortDesc->pd_FunctionalAddr[i] &= ~Address[2+i];

	//  Release the spinlock
	RELEASE_SPIN_LOCK(&pPortDesc->pd_Lock, OldIrql);

	DBGPRINT(DBG_COMP_NDISREQ, DBG_LEVEL_INFO,
			("After Remove %02x%02x%02x%02x\n",
			 pPortDesc->pd_FunctionalAddr[0], pPortDesc->pd_FunctionalAddr[1],
             pPortDesc->pd_FunctionalAddr[2], pPortDesc->pd_FunctionalAddr[3]));

	request.RequestType = NdisRequestSetInformation;
	request.DATA.SET_INFORMATION.Oid = OID_802_5_CURRENT_FUNCTIONAL;
	request.DATA.SET_INFORMATION.InformationBuffer = pPortDesc->pd_FunctionalAddr;
	request.DATA.SET_INFORMATION.InformationBufferLength = TLAP_ADDR_LEN - TLAP_MCAST_HDR_LEN;

	ndisStatus = AtalkNdisSubmitRequest(pPortDesc,
										&request,
										ExecuteSynchronously,
										RemoveCompletion,
										RemoveContext);

	if (ndisStatus == NDIS_STATUS_PENDING)
	{
		ASSERT(ExecuteSynchronously != TRUE);
	}
	else if (ndisStatus != NDIS_STATUS_SUCCESS)
	{
		LOG_ERRORONPORT(pPortDesc,
						EVENT_ATALK_NDISREQUEST,
						ndisStatus,
						NULL,
						0);
	}

	return AtalkNdisToAtalkError(ndisStatus);
}




USHORT
AtalkNdisBuildEthHdr(
	IN		PUCHAR				PortAddr,			// 802 address of port
	IN 		PBYTE				pLinkHdr,			// Start of link header
	IN		PBYTE				pDestHwOrMcastAddr,	// Destination or multicast addr
	IN		LOGICAL_PROTOCOL	Protocol,			// Logical protocol
	IN		USHORT				ActualDataLen		// Length for ethernet packets
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	USHORT			len;

	//  Set destination address.
	if (pDestHwOrMcastAddr == NULL)
		pDestHwOrMcastAddr = AtalkElapBroadcastAddr;

	RtlCopyMemory(pLinkHdr,
				  pDestHwOrMcastAddr,
				  ELAP_ADDR_LEN);

	//  Set source address.
	RtlCopyMemory(pLinkHdr += ELAP_ADDR_LEN,
				  PortAddr,
				  ELAP_ADDR_LEN);

	//  Set length, excluding Ethernet hardware header.
	len = ActualDataLen + IEEE8022_HDR_LEN;
	pLinkHdr += ELAP_ADDR_LEN;
	PUTSHORT2SHORT(pLinkHdr, len);
	pLinkHdr += sizeof(USHORT);

	ATALK_BUILD8022_HDR(pLinkHdr, Protocol);

	//	Return the link header length.
	return (ELAP_LINKHDR_LEN + IEEE8022_HDR_LEN);
}




USHORT
AtalkNdisBuildTRHdr(
	IN		PUCHAR				PortAddr,			// 802 address of port
	IN 		PBYTE				pLinkHdr,			// Start of link header
	IN		PBYTE				pDestHwOrMcastAddr,	// Destination or multicast addr
	IN		LOGICAL_PROTOCOL	Protocol,			// Logical protocol
	IN		PBYTE				pRouteInfo,			// Routing info for tokenring
	IN		USHORT				RouteInfoLen		// Length of above
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	USHORT			linkLen;

	//	Here we need to worry about the routing info.
	//	If we currently do not have any, set the values
	if (pDestHwOrMcastAddr == NULL)
	{
		// Broadcast?
		pRouteInfo = AtalkBroadcastRouteInfo;
		RouteInfoLen = TLAP_MIN_ROUTING_BYTES;

	}
	else if (RouteInfoLen != 0)
	{
		//	We are all set
	}
	else if (AtalkFixedCompareCaseSensitive(pDestHwOrMcastAddr,
											TLAP_BROADCAST_DEST_LEN,
											AtalkBroadcastDestHdr,
											TLAP_BROADCAST_DEST_LEN))
	{
		// Multicast?
		pRouteInfo = AtalkBroadcastRouteInfo;
		RouteInfoLen = TLAP_MIN_ROUTING_BYTES;
	}
	else
	{
		// No routing know; use simple non-broadcast
		pRouteInfo = AtalkSimpleRouteInfo;
		RouteInfoLen = TLAP_MIN_ROUTING_BYTES;
	}							

	linkLen = TLAP_MIN_LINKHDR_LEN + RouteInfoLen + IEEE8022_HDR_LEN;

	// Set the first two bytes in the header
	*pLinkHdr++	= TLAP_ACCESS_CTRL_VALUE;
	*pLinkHdr++ = TLAP_FRAME_CTRL_VALUE ;

	// Set detination address.
	if (pDestHwOrMcastAddr == NULL)
		pDestHwOrMcastAddr = AtalkTlapBroadcastAddr;

	RtlCopyMemory(pLinkHdr,
				  pDestHwOrMcastAddr ,
				  TLAP_ADDR_LEN);

	// Set source address.
	RtlCopyMemory(pLinkHdr += TLAP_ADDR_LEN,
				  PortAddr,
				  TLAP_ADDR_LEN);

	ASSERTMSG("AtalkNdisBuildTRHdr: Routing Info is 0!\n", (RouteInfoLen > 0));
	*pLinkHdr |= TLAP_SRC_ROUTING_MASK;

	// Move in routing info.
	RtlCopyMemory(pLinkHdr += TLAP_ADDR_LEN,
				  pRouteInfo,
				  RouteInfoLen);

	pLinkHdr += RouteInfoLen;
	ATALK_BUILD8022_HDR(pLinkHdr, Protocol);

	//	Return the link header length.
	return linkLen;
}




USHORT
AtalkNdisBuildFDDIHdr(
	IN		PUCHAR				PortAddr,			// 802 address of port
	IN 		PBYTE				pLinkHdr,			// Start of link header
	IN		PBYTE				pDestHwOrMcastAddr,	// Destination or multicast addr
	IN		LOGICAL_PROTOCOL	Protocol			// Logical protocol
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	*pLinkHdr++ = FDDI_HEADER_BYTE;

	//  Set destination address.
	if (pDestHwOrMcastAddr == NULL)
		pDestHwOrMcastAddr = AtalkElapBroadcastAddr;

	//  Set destination address.
	RtlCopyMemory(pLinkHdr,
				  pDestHwOrMcastAddr,
				  FDDI_ADDR_LEN);

	//  Set source address.
	RtlCopyMemory(pLinkHdr += FDDI_ADDR_LEN,
				  PortAddr,
				  FDDI_ADDR_LEN);

	pLinkHdr += FDDI_ADDR_LEN;

	//  NOTE: No Length field for FDDI, unlike Ethernet.
	ATALK_BUILD8022_HDR(pLinkHdr, Protocol);

	//	Return the link header length.
	return (FDDI_LINKHDR_LEN + IEEE8022_HDR_LEN);
}




USHORT
AtalkNdisBuildLTHdr(
	IN 		PBYTE				pLinkHdr,			// Start of link header
	IN		PBYTE				pDestHwOrMcastAddr,	// Destination or multicast addr
	IN		BYTE				AlapSrc,			// Localtalk source node
	IN		BYTE				AlapType			// Localtalk ddp header type
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	// Fill in LAP header.
	if (pDestHwOrMcastAddr == NULL)
		pLinkHdr = AtalkAlapBroadcastAddr;

	*pLinkHdr++ = *pDestHwOrMcastAddr;

	*pLinkHdr++ = AlapSrc;
	*pLinkHdr   = AlapType;

	//	Return the link header length.
	return ALAP_LINKHDR_LEN;
}

VOID
AtalkNdisSendTokRingTestResp(
	IN		PPORT_DESCRIPTOR	pPortDesc,
	IN		PBYTE 				HdrBuf,
	IN		UINT 				HdrBufSize,
	IN		PBYTE 				LkBuf,
	IN		UINT 				LkBufSize,
	IN		UINT 				PktSize
	)
{
	PBUFFER_DESC	pBufDesc, pHdrDesc;
	PBYTE			pResp;
	UINT			routeInfoLen	= 0;

	//	Allocate a buffer to hold the response and call NdisSend
	//	providing a completion routine which will free up the buffer.
	ASSERT(PktSize == LkBufSize);

    // make sure there are at least 14 bytes!
    if (HdrBufSize < TLAP_ROUTE_INFO_OFFSET)
    {
        ASSERT(0);
        return;
    }

	//	First allocate a buffer to hold the link header.
	AtalkNdisAllocBuf(&pHdrDesc);
	if (pHdrDesc == NULL)
	{
		return;
	}

	if ((pBufDesc = AtalkAllocBuffDesc(NULL,
									   (USHORT)LkBufSize,
									   BD_CHAR_BUFFER | BD_FREE_BUFFER)) == NULL)
		
	{
		AtalkNdisFreeBuf(pHdrDesc);

		RES_LOG_ERROR();
		return;
	}

	pResp		= pHdrDesc->bd_CharBuffer;
	*pResp++	= TLAP_ACCESS_CTRL_VALUE;
	*pResp++	= TLAP_FRAME_CTRL_VALUE;

	// Set destination address to be the incoming src addr.
	ATALK_RECV_INDICATION_COPY(pPortDesc,
							   pResp,
							   HdrBuf+TLAP_SRC_OFFSET,
							   TLAP_ADDR_LEN);

	//	Make sure we do not have the routing bit set.
	*pResp	&= ~TLAP_SRC_ROUTING_MASK;
	pResp	+= TLAP_ADDR_LEN;

	// Set source address to be the incoming destination address.
	ATALK_RECV_INDICATION_COPY(pPortDesc,
							   pResp,
							   HdrBuf+TLAP_DEST_OFFSET,
							   TLAP_ADDR_LEN);

	//	Is there routing info present?
	if (HdrBuf[TLAP_SRC_OFFSET] & TLAP_SRC_ROUTING_MASK)
	{
		routeInfoLen = (HdrBuf[TLAP_ROUTE_INFO_OFFSET] & TLAP_ROUTE_INFO_SIZE_MASK);
		ASSERT(routeInfoLen != 0);
		ASSERTMSG("RouteInfo incorrect!\n",
				 (routeInfoLen <= TLAP_MAX_ROUTING_BYTES));

        if (HdrBufSize < (TLAP_ROUTE_INFO_OFFSET+routeInfoLen))
        {
            ASSERT(0);
		    AtalkNdisFreeBuf(pHdrDesc);
            AtalkFreeBuffDesc(pBufDesc);
            return;
        }

		//	Copy it in the response packet and then tune it.
		ATALK_RECV_INDICATION_COPY(pPortDesc,
								   pResp + TLAP_ADDR_LEN,
								   HdrBuf+TLAP_ROUTE_INFO_OFFSET,
								   routeInfoLen);

		// Set to "non-broadcast" and invert "direction".
		*(pResp+TLAP_ADDR_LEN) 		&= TLAP_NON_BROADCAST_MASK;
		*(pResp+TLAP_ADDR_LEN+1) 	^= TLAP_DIRECTION_MASK;

		//	Set the routing info bit in the source address
		*pResp	|= TLAP_SRC_ROUTING_MASK;
	}

	//	Set the length for this buffer descriptor.
	AtalkSetSizeOfBuffDescData(pHdrDesc, TLAP_ROUTE_INFO_OFFSET + routeInfoLen);

	//	Copy the remaining data
	ATALK_RECV_INDICATION_COPY(pPortDesc,
							   pBufDesc->bd_CharBuffer,
							   LkBuf,
							   LkBufSize);

	//	Set the source SAP to indicate FINAL (0xAB instead of 0xAA)
	pBufDesc->bd_CharBuffer[IEEE8022_SSAP_OFFSET] = SNAP_SAP_FINAL;

	//	Chain the passed in buffer desc onto the tail of the one
	//	returned above.
	AtalkPrependBuffDesc(pHdrDesc, pBufDesc);

	//	Call send at this point
	if (!ATALK_SUCCESS(AtalkNdisSendPacket(pPortDesc,
										   pHdrDesc,
										   AtalkNdisSendTokRingTestRespComplete,
										   NULL)))
	{
		AtalkNdisSendTokRingTestRespComplete(NDIS_STATUS_RESOURCES,
											 pHdrDesc,
											 NULL);
	}
}




VOID
AtalkNdisSendTokRingTestRespComplete(
	IN	NDIS_STATUS				Status,
	IN	PBUFFER_DESC			pBufDesc,
	IN	PSEND_COMPL_INFO		pInfo
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	//	Free up the buffer descriptor
	ASSERT((pBufDesc != NULL) && (pBufDesc->bd_Next != NULL));
	ASSERT(pBufDesc->bd_Flags & BD_CHAR_BUFFER);
	AtalkFreeBuffDesc(pBufDesc->bd_Next);
	AtalkNdisFreeBuf(pBufDesc);
}


NDIS_STATUS
AtalkReceiveIndication(
	IN	NDIS_HANDLE 	BindingCtx,
	IN	NDIS_HANDLE 	ReceiveCtx,
	IN	PVOID 			HdrBuf,
	IN	UINT 			HdrBufSize,
	IN	PVOID 			LkBuf,
	IN	UINT 			LkBufSize,
	IN	UINT 			PktSize
	)
/*++

Routine Description:

	This routine is called by NDIS to indicate a receive

Arguments:

	BindingCtx- Pointer to a port descriptor for this port
	ReceiveCtx- To be used in a transfer data if necessary
	LkBuf- buffer with lookahead data
	LkBufSize- Size of the above buffer
	PktSize- Size of whole packet

Return Value:

	STATUS_SUCCESS- Packet accepted
	STATUS_NOT_RECOGNIZED- Not our packet
	Other

--*/
{
	PPORT_DESCRIPTOR	pPortDesc = (PPORT_DESCRIPTOR)BindingCtx;
	PNDIS_PACKET		ndisPkt;
	PBUFFER_HDR			pBufferHdr = NULL;
	PPROTOCOL_RESD  	protocolResd;		// Protocolresd field in ndisPkt
	UINT				actualPktSize;		// Size of data to copy
	UINT				bytesTransferred;	// Number of bytes transferred in XferData
	BOOLEAN				result;
	UINT				xferOffset;
	PBYTE				lkBufOrig	= (PBYTE)LkBuf;
	ATALK_ERROR			error		= ATALK_NO_ERROR;
	BOOLEAN				shortDdpHdr	= FALSE;
	BYTE				indicate	= 0,
						subType		= 0;
	NDIS_MEDIUM			Media;
	PBYTE				packet		= NULL;	// Where we will copy the packet
	NDIS_STATUS 		ndisStatus 	= NDIS_STATUS_SUCCESS;
	LOGICAL_PROTOCOL	protocol 	= UNKNOWN_PROTOCOL;
    PARAPCONN           pArapConn;
    PATCPCONN           pAtcpConn;
    ATALK_NODEADDR      ClientNode;
#ifdef	PROFILING
	TIME				TimeS, TimeE, TimeD;

	TimeS = KeQueryPerformanceCounter(NULL);
#endif

	do
	{
		if ((pPortDesc->pd_Flags & (PD_ACTIVE | PD_CLOSING)) != PD_ACTIVE)
		{
			//	If we are not active, return!
			ndisStatus = ATALK_PORT_CLOSING;
			break;
		}
	
		ASSERT (KeGetCurrentIrql() == DISPATCH_LEVEL);
		ACQUIRE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);
	
		Media = pPortDesc->pd_NdisPortType;

		//	Reduce 802.2 code, avoid making it a routine. First 802.2.
		switch (Media)
		{
		  case NdisMedium802_3:
		  case NdisMediumFddi:
		  case NdisMedium802_5:
			ATALK_VERIFY8022_HDR((PBYTE)LkBuf, LkBufSize, protocol, result);
	
			if (!result)
			{
				ndisStatus	= NDIS_STATUS_NOT_RECOGNIZED;

                if (LkBufSize < IEEE8022_CONTROL_OFFSET+1)
                {
                    ASSERT(0);
                    break;
                }

				if (Media == NdisMedium802_5)
				{
					//	BUG #16002
					//	On tokenring the macs also send out a Unnumbered format
					//	TEST frame to which we need to respond. Check for that
					//	here.
		
					if ((((PBYTE)LkBuf)[IEEE8022_DSAP_OFFSET]	== SNAP_SAP)	&&
						(((PBYTE)LkBuf)[IEEE8022_SSAP_OFFSET]	== SNAP_SAP)	&&
						(((PBYTE)LkBuf)[IEEE8022_CONTROL_OFFSET] == UNNUMBERED_FORMAT))
					{
						DBGPRINT(DBG_COMP_NDISRECV, DBG_LEVEL_INFO,
								("atalkNdisAcceptTlapPacket: LLC TEST FRAME RECD!\n"));
			
						RELEASE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);

						//	Due to the aarp lookahead size setting, we are guaranteed
						//	the entire frame is contained in the lookahead data.
						AtalkNdisSendTokRingTestResp(pPortDesc,
													(PBYTE)HdrBuf,
													HdrBufSize,
													(PBYTE)LkBuf,
													LkBufSize,
													PktSize);

						ACQUIRE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);
					}
				}
				break;
			}

			if (protocol == APPLETALK_PROTOCOL)
			{
				//  Do we at least have a 802.2 and DDP header in the indicated packet?
				if ((PktSize < (IEEE8022_HDR_LEN + LDDP_HDR_LEN)) ||
					(PktSize > (IEEE8022_HDR_LEN + MAX_LDDP_PKT_SIZE)))
				{
					ndisStatus = NDIS_STATUS_NOT_RECOGNIZED;
					break;
				}
			}
			else	// AARP
			{
				UINT	routeInfoLen = 0; // length of routing info if present (802.5)

				switch (Media)
				{
				  case NdisMediumFddi:
					//  For fddi, there could be padding included in the packet. Shrink
					//  the length if so. Note header length is not included in packetlength.
					//
					if (PktSize >= (MIN_FDDI_PKT_LEN - FDDI_LINKHDR_LEN))
					{
						PktSize = (IEEE8022_HDR_LEN + AARP_MIN_DATA_SIZE);
					}
					break;

				  case NdisMedium802_5:
		
					//  Remember- routing info is in the header buffer
					if (((PBYTE)HdrBuf)[TLAP_SRC_OFFSET] & TLAP_SRC_ROUTING_MASK)
					{
						routeInfoLen = (((PBYTE)HdrBuf)[TLAP_ROUTE_INFO_OFFSET] &
																TLAP_ROUTE_INFO_SIZE_MASK);
						ASSERTMSG("RouteInfo incorrect!\n",
								 ((routeInfoLen > 0) && (routeInfoLen <= TLAP_MAX_ROUTING_BYTES)));
		
						//	Routing info must be of reasonable size, and not odd.
						if ((routeInfoLen & 1) ||
							(routeInfoLen > TLAP_MAX_ROUTING_BYTES))
						{
							ndisStatus = NDIS_STATUS_NOT_RECOGNIZED;
							break;
						}
					}
					// Fall through to 802.3 case
		
				  case NdisMedium802_3:
					if (PktSize >= (ELAP_MIN_PKT_LEN - ELAP_LINKHDR_LEN))
					{
						PktSize = (IEEE8022_HDR_LEN + AARP_MIN_DATA_SIZE);
					}
				}

				if (((PktSize - IEEE8022_HDR_LEN) > AARP_MAX_DATA_SIZE) ||
					((PktSize - IEEE8022_HDR_LEN) < AARP_MIN_DATA_SIZE))
				{
					ndisStatus = NDIS_STATUS_NOT_RECOGNIZED;
					break;
				}
			}
			actualPktSize = (PktSize + HdrBufSize - IEEE8022_HDR_LEN);
			(PBYTE)LkBuf += IEEE8022_HDR_LEN;
			xferOffset	  = IEEE8022_HDR_LEN;

			break;
	
		  case NdisMediumLocalTalk:

			//  No AARP/802.2 header on localtalk
			protocol = APPLETALK_PROTOCOL;

            // we should have enough bytes to have at least the short-header
            if (LkBufSize < SDDP_PROTO_TYPE_OFFSET+1)
            {
				ndisStatus = NDIS_STATUS_NOT_RECOGNIZED;
                ASSERT(0);
				break;
            }

			if (((PBYTE)HdrBuf)[ALAP_TYPE_OFFSET] == ALAP_SDDP_HDR_TYPE)
			{
				shortDdpHdr = TRUE;
			}
			else if (((PBYTE)HdrBuf)[ALAP_TYPE_OFFSET] != ALAP_LDDP_HDR_TYPE)
			{
				ndisStatus = NDIS_STATUS_NOT_RECOGNIZED;
				break;
			}
			actualPktSize = PktSize + HdrBufSize;
			xferOffset		= 0;
			break;

          case NdisMediumWan:

            if (pPortDesc->pd_Flags & PD_RAS_PORT)
            {
                //
                // 1st byte 0x01 tells us it's a PPP connection
                //
                if ((((PBYTE)HdrBuf)[0] == PPP_ID_BYTE1) &&
                    (((PBYTE)HdrBuf)[1] == PPP_ID_BYTE2))
                {
                    RELEASE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);

                    DBGDUMPBYTES("Packet from PPP client:", (PBYTE)LkBuf,LkBufSize,4);

                    if (AtalkReferenceDefaultPort())
                    {
                        AtalkDdpPacketIn(AtalkDefaultPort,  // came on which port
                                         NULL,              // Link Hdr
                                         (PBYTE)LkBuf,      // packet
                                         (USHORT)LkBufSize, // how big is the pkt
                                         TRUE);             // did this come on WAN?

                        AtalkPortDereference(AtalkDefaultPort);
                    }
                }

                //
                // this is ARAP connection: lot of stuff to be done before pkt
                // can be given to the right destination...
                //
                else
                {
                    ASSERT ((((PBYTE)HdrBuf)[0] == ARAP_ID_BYTE1) &&
                            (((PBYTE)HdrBuf)[1] == ARAP_ID_BYTE2));

                    *((ULONG UNALIGNED *)(&pArapConn)) =
                                  *((ULONG UNALIGNED *)(&((PBYTE)HdrBuf)[2]));

                    RELEASE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);

                    ASSERT(pArapConn->Signature == ARAPCONN_SIGNATURE);

                    //
                    // NDISWAN guarantees that all the data is in the LookAhead buffer
                    //
                    ArapRcvIndication( pArapConn,
                                       LkBuf,
                                       LkBufSize );
                }
            }

            break;

		  default:
			//  Should never happen!
			DBGPRINT(DBG_COMP_DDP, DBG_LEVEL_FATAL,
					("AtalkReceiveIndication: Unknown media\n"));
			ASSERT(0);
            ndisStatus = NDIS_STATUS_NOT_RECOGNIZED;
			break;
		}

        // we have already taken care of the Wan case: quit here
        if (Media == NdisMediumWan)
        {
            break;
        }

        //
        // if pkt not interesting, quit., if this is ras adapter, quit
        //
		if (ndisStatus != NDIS_STATUS_SUCCESS)
		{
			RELEASE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);
			break;
		}
	
		INTERLOCKED_INCREMENT_LONG_DPC(
			&pPortDesc->pd_PortStats.prtst_NumPacketsIn,
			&AtalkStatsLock.SpinLock);

		INTERLOCKED_ADD_STATISTICS(&pPortDesc->pd_PortStats.prtst_DataIn,
								   (LONG)actualPktSize,
								   &AtalkStatsLock.SpinLock);

		ASSERT ((protocol == APPLETALK_PROTOCOL) || (protocol == AARP_PROTOCOL));

		//	At this point, the IEEE802.2 header has been skipped in the lookahead
		//	buffer.
		//  Packet is to be accepted! Get an appropriate buffer and set the
		//	fields.
		switch (protocol)
		{
		  case APPLETALK_PROTOCOL:
			//	We either need to receive this packet on the default port, or
			//	we must be a router.
			if ((pPortDesc == AtalkDefaultPort) || AtalkRouter)
			{
				if (shortDdpHdr)
				{
					//	Check to see if we can indicate this to ATP/ADSP.
					if ((((PBYTE)LkBuf)[SDDP_PROTO_TYPE_OFFSET] == DDPPROTO_ATP) &&
						((USHORT)(LkBufSize - xferOffset) >= (SDDP_HDR_LEN + ATP_HEADER_SIZE)))
					{
						indicate = INDICATE_ATP;
					}
				}
				else
				{
					//	Check to see if we can indicate this to ATP/ADSP.
					if ((((PBYTE)LkBuf)[LDDP_PROTO_TYPE_OFFSET] == DDPPROTO_ATP) &&
						((USHORT)(LkBufSize - xferOffset) >= (LDDP_HDR_LEN + ATP_HEADER_SIZE)))
					{
						indicate = INDICATE_ATP;
					}
				}
			}
		
			//	First check for optimizing ATP/ADSP packets.
			if (indicate == INDICATE_ATP)
			{
				error = AtalkIndAtpPkt(pPortDesc,
									   (PBYTE)LkBuf,
									   (USHORT)(PktSize - xferOffset),
									   &xferOffset,	//	IN/OUT parameter
									   HdrBuf,
									   shortDdpHdr,
									   &subType,
									   &packet,
									   &ndisPkt);
							
				if (ATALK_SUCCESS(error))
				{
					break;
				}
				else if (error == ATALK_INVALID_PKT)
				{
					//	This indicates that the indication code has figured out that
					//	the packet is bad.
					break;
				}
				else
				{
					//	This is the case where the indication code cannot figure out
					//	if this packet qualifies.
					indicate = 0;
					error 	 = ATALK_NO_ERROR;
				}
			}
	
			if (actualPktSize > (sizeof(DDP_SMBUFFER) - sizeof(BUFFER_HDR)))
			{
				pBufferHdr = (PBUFFER_HDR)AtalkBPAllocBlock(BLKID_DDPLG);
			}
			else
			{
				pBufferHdr = (PBUFFER_HDR)AtalkBPAllocBlock(BLKID_DDPSM);
			}
			break;
	
		  case AARP_PROTOCOL:
			pBufferHdr = (PBUFFER_HDR)AtalkBPAllocBlock(BLKID_AARP);
			break;
	
		  default:
			KeBugCheck(0);
			break;
		}
	
		if (!ATALK_SUCCESS(error) || ((pBufferHdr == NULL) && (indicate == 0)))
		{
#if	DBG
			UINT	i;			

			DBGPRINT(DBG_COMP_NDISRECV, DBG_LEVEL_ERR,
					("AtalkReceiveIndication: Dropping packet (2) %ld\n", error));
			for (i = 0; i < HdrBufSize; i++)
				DBGPRINTSKIPHDR(DBG_COMP_NDISRECV, DBG_LEVEL_ERR,
								("%02x ", ((PUCHAR)HdrBuf)[i]));
			for (i = 0; i < LkBufSize; i++)
				DBGPRINTSKIPHDR(DBG_COMP_NDISRECV, DBG_LEVEL_ERR,
								("%02x ", ((PUCHAR)LkBuf)[i]));
	
#endif
			//	No logging in this critical path.
			//	LOG_ERRORONPORT(pPortDesc,
			//					EVENT_ATALK_AARPPACKET,
			//					actualPktSize,
			//					HdrBuf,
			//					HdrBufSize);
	
			RELEASE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);

			if (error != ATALK_DUP_PKT)
			{
				INTERLOCKED_INCREMENT_LONG_DPC(
					&pPortDesc->pd_PortStats.prtst_NumPktDropped,
					&AtalkStatsLock.SpinLock);
			}
	
			ndisStatus = NDIS_STATUS_RESOURCES;
			break;
		}
	
		if (indicate == 0)
		{
			packet = (PBYTE)pBufferHdr + sizeof(BUFFER_HDR);
		
			//  Get a pointer to the NDIS packet descriptor from the buffer header.
			ndisPkt	= pBufferHdr->bh_NdisPkt;
		}
	
		protocolResd = (PPROTOCOL_RESD)(ndisPkt->ProtocolReserved);

		//  Store the information needed in the packet descriptor
		protocolResd->Receive.pr_Port 		= pPortDesc;
		protocolResd->Receive.pr_Protocol 	= protocol;
		protocolResd->Receive.pr_Processed 	= FALSE;
	
		//  Queue up the packet in the receive queue on this port
		//  Then, go ahead with the transfer data etc. For Atp response
		//	case when SubType == ATP_USER_BUFX, we do not want any
		//	Recv. completion processing, do not queue. In this case
		//	TransferData completion frees up the Ndis resources.
		if ((indicate != INDICATE_ATP) ||
			(protocolResd->Receive.pr_OptimizeSubType != ATP_USER_BUFX))
		{
			ATALK_RECV_INDICATION_COPY(pPortDesc,
									   protocolResd->Receive.pr_LinkHdr,
									   (PBYTE)HdrBuf,
									   HdrBufSize);
			InsertTailList(&pPortDesc->pd_ReceiveQueue,
						   &protocolResd->Receive.pr_Linkage);
		}
		else
		{
			DBGPRINT(DBG_COMP_NDISRECV, DBG_LEVEL_ERR,
					("AtalkReceiveIndication: Skipping link hdr !!!\n"));
		}

		RELEASE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);
#ifdef	PROFILING
		INTERLOCKED_INCREMENT_LONG_DPC(
				&pPortDesc->pd_PortStats.prtst_CurReceiveQueue,
				&AtalkStatsLock.SpinLock);
#endif
	
		//	Adjust for the link header size. Set size in protocol reserved. We want
		//	to avoid changing the size described by the NDIS buffer descriptor.
		if (indicate == 0)
		{
			actualPktSize 					   -= HdrBufSize;
			protocolResd->Receive.pr_DataLength	= (USHORT)actualPktSize;
		}
		else
		{
			actualPktSize = protocolResd->Receive.pr_DataLength;
		}
	
		ASSERT(ndisStatus == NDIS_STATUS_SUCCESS);
	
		if ((PktSize <= LkBufSize) 	&&
			((indicate != INDICATE_ATP) || (subType != ATP_RESPONSE)))
		{
			//	LkBuf has already been advanced to skip the ieee 802.2 header.
			//	We may need to skip more. Use the original lkbuf and xfer offset.
			ATALK_RECV_INDICATION_COPY(pPortDesc,
									   packet,
									   (PBYTE)lkBufOrig + xferOffset,
									   actualPktSize);
			bytesTransferred = actualPktSize;
		}
		else
		{
			//	Skip 802.2 header (both AARP and Appletalk), localtalk doesnt have one!
			if (actualPktSize > 0)
			{
				NdisTransferData(&ndisStatus,
								 pPortDesc->pd_NdisBindingHandle,
								 ReceiveCtx,
								 xferOffset,
								 actualPktSize,
								 ndisPkt,
								 &bytesTransferred);
				ASSERT(bytesTransferred == actualPktSize);
			}
		}
	
		if (ndisStatus == NDIS_STATUS_PENDING)
		{
			ndisStatus = NDIS_STATUS_SUCCESS;
		}
		else
		{
			//  Transfer data completed, call the transfer data completion
			//  routine to do rest of the work. If an error happened, ReceiveCompletion
			//	will drop the packet.
			protocolResd->Receive.pr_ReceiveStatus = ndisStatus;
			protocolResd->Receive.pr_Processed = TRUE;
		
			// In case of intermediate Atp response, the packet is not actually linked
			// into the receive queue, just free it.
			if ((protocolResd->Receive.pr_OptimizeType == INDICATE_ATP) &&
                (protocolResd->Receive.pr_OptimizeSubType == ATP_USER_BUFX))
			{
				PNDIS_BUFFER	ndisBuffer;

				//	Free NDIS buffers if any are present.
				NdisUnchainBufferAtFront(ndisPkt, &ndisBuffer);
			
				if (ndisBuffer != NULL)
				{
					AtalkNdisFreeBuffer(ndisBuffer);
				}
				NdisDprFreePacket(ndisPkt);
			}
		}
	} while (FALSE);

#ifdef	PROFILING
	TimeE = KeQueryPerformanceCounter(NULL);
	TimeD.QuadPart = TimeE.QuadPart - TimeS.QuadPart;

	INTERLOCKED_ADD_LARGE_INTGR_DPC(&pPortDesc->pd_PortStats.prtst_RcvIndProcessTime,
									TimeD,
									&AtalkStatsLock.SpinLock);

	INTERLOCKED_INCREMENT_LONG_DPC( &pPortDesc->pd_PortStats.prtst_RcvIndCount,
									&AtalkStatsLock.SpinLock);
#endif

	return ndisStatus;
}


VOID
AtalkTransferDataComplete(
	IN	NDIS_HANDLE		BindingCtx,
	IN	PNDIS_PACKET	NdisPkt,
	IN	NDIS_STATUS		Status,
	IN	UINT			BytesTransferred
)
/*++

Routine Description:

	This routine is called by NDIS to indicate completion of a TransferData

Arguments:

	BindingCtx- Pointer to a port descriptor for this port
	NdisPkt- Ndis packet into which data was transferred
	Status- Status of request
	bytesTransferred- Actual number of bytes transferred

Return Value:

	None

--*/
{
	PPROTOCOL_RESD  	protocolResd;
	PNDIS_BUFFER		ndisBuffer;

	protocolResd = (PPROTOCOL_RESD)(NdisPkt->ProtocolReserved);

	protocolResd->Receive.pr_ReceiveStatus = Status;
	protocolResd->Receive.pr_Processed = TRUE;

	// In case of intermediate Atp response, the packet is not actually linked
	// into the receive queue, just free it.
	if (protocolResd->Receive.pr_OptimizeSubType == ATP_USER_BUFX)
	{
		//	Free NDIS buffers if any are present.
		NdisUnchainBufferAtFront(NdisPkt, &ndisBuffer);
	
		if (ndisBuffer != NULL)
		{
			AtalkNdisFreeBuffer(ndisBuffer);
		}
		NdisDprFreePacket(NdisPkt);
	}
}




VOID
AtalkReceiveComplete(
	IN	NDIS_HANDLE	BindingCtx
	)
/*++

Routine Description:

	We experimented with queueing up a work item for receive completion. It really
	KILLED performance with multiple clients as apparently the receive completion
	kept getting interrupted with receive indications. AS the optimization was
	put in for slow cards like the ELNKII which do not have adequate buffering,
	we decided to take it out. The retry values (or timeout trimming) should be
	enough for the slow cards. They will inevitably drop packets.

Arguments:


Return Value:


--*/
{
	PPORT_DESCRIPTOR	pPortDesc = (PPORT_DESCRIPTOR)BindingCtx;
	PPROTOCOL_RESD  	protocolResd;
	PNDIS_PACKET 		ndisPkt;
	PNDIS_BUFFER		ndisBuffer;
	PBUFFER_HDR			pBufHdr;
	NDIS_MEDIUM			Media;
	PLIST_ENTRY 		p;
	PBYTE				packet;
	LOGICAL_PROTOCOL	protocol;
	UINT				packetLength;
    BOOLEAN             fDerefDefPort=FALSE;
#ifdef	PROFILING
	TIME				TimeS, TimeE, TimeD;
#endif


    if (pPortDesc->pd_Flags & PD_RAS_PORT)
    {
        // give ARAP guys a chance
        ArapRcvComplete();

        if (!AtalkReferenceDefaultPort())
        {
            return;
        }

        fDerefDefPort = TRUE;

        // give PPP guys a chance
        pPortDesc = AtalkDefaultPort;
    }

	//  Get the stuff off the receive queue for the port and send it up. Do not
	//	enter if the queue is initially empty.
	if (IsListEmpty(&pPortDesc->pd_ReceiveQueue))
	{
        if (fDerefDefPort)
        {
            AtalkPortDereference(AtalkDefaultPort);
        }
		return;
	}

#ifdef	PROFILING
	TimeS = KeQueryPerformanceCounter(NULL);
#endif

	while (TRUE)
	{
		ACQUIRE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);
		p = pPortDesc->pd_ReceiveQueue.Flink;
		if (p == &pPortDesc->pd_ReceiveQueue)
		{
			//	Queue is empty
			RELEASE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);
			break;
		}

		ndisPkt = CONTAINING_RECORD(p, NDIS_PACKET, ProtocolReserved[0]);
		protocolResd = (PPROTOCOL_RESD)(ndisPkt->ProtocolReserved);

		//  Check if the queued receive is done processing. Since we are looping
		//	through the queue and since receive complete only checks if the first
		//	is done, we need this check here for subsequent queued up receives.
		if (!protocolResd->Receive.pr_Processed)
		{
			//	Queue is empty
			RELEASE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);
			break;
		}

		//  Dequeue and indicate this packet to the ddp/atp layer
		p = RemoveHeadList(&pPortDesc->pd_ReceiveQueue);
		pBufHdr = protocolResd->Receive.pr_BufHdr;

		RELEASE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);

#ifdef	PROFILING
		INTERLOCKED_DECREMENT_LONG_DPC(
			&pPortDesc->pd_PortStats.prtst_CurReceiveQueue,
			&AtalkStatsLock.SpinLock);
#endif
		Media = pPortDesc->pd_NdisPortType;
		protocol = protocolResd->Receive.pr_Protocol;

		if ((protocol == APPLETALK_PROTOCOL) &&
			(protocolResd->Receive.pr_OptimizeType == INDICATE_ATP))
		{
			protocolResd->Receive.pr_OptimizeType = 0;
			ASSERT(protocolResd->Receive.pr_OptimizeSubType != ATP_USER_BUFX);

			//  Check the receive status- accept only if ok
			if (protocolResd->Receive.pr_ReceiveStatus == NDIS_STATUS_SUCCESS)
			{
				//	Glean information. Check for route info if tokenring network.
				if (Media != NdisMediumLocalTalk)
				{
					AtalkAarpOptGleanInfo(pPortDesc,
										  protocolResd->Receive.pr_LinkHdr,
										  &protocolResd->Receive.pr_SrcAddr,
										  &protocolResd->Receive.pr_DestAddr,
										  protocolResd->Receive.pr_OffCablePkt);
				}
		
				//	Different calls for response & non-response packets.
				if (protocolResd->Receive.pr_OptimizeSubType == ATP_USER_BUF)
				{
					AtalkAtpPacketIn(AtalkDefaultPort,
									protocolResd->Receive.pr_AtpAddrObj->atpao_DdpAddr,
									protocolResd->Receive.pr_AtpHdr,
									(USHORT)(protocolResd->Receive.pr_DataLength + 8),
									&protocolResd->Receive.pr_SrcAddr,
									&protocolResd->Receive.pr_DestAddr,
									ATALK_NO_ERROR,
									DDPPROTO_ATP,
									protocolResd->Receive.pr_AtpAddrObj,
									TRUE,
									protocolResd->Receive.pr_OptimizeCtx);
				}
				else
				{
					ASSERT (protocolResd->Receive.pr_OptimizeSubType == ATP_ALLOC_BUF);

					packet = (PBYTE)pBufHdr + sizeof(BUFFER_HDR);
					ASSERT(packet != NULL);
			
					AtalkAtpPacketIn(AtalkDefaultPort,
									protocolResd->Receive.pr_AtpAddrObj->atpao_DdpAddr,
									packet,
									(USHORT)protocolResd->Receive.pr_DataLength,
									&protocolResd->Receive.pr_SrcAddr,
									&protocolResd->Receive.pr_DestAddr,
									ATALK_NO_ERROR,
									DDPPROTO_ATP,
									protocolResd->Receive.pr_AtpAddrObj,
									TRUE,
									protocolResd->Receive.pr_OptimizeCtx);
				}
			}

			//	Different calls for user buffer/allocated packets
			if (protocolResd->Receive.pr_OptimizeSubType == ATP_USER_BUF)
			{
				//	Free NDIS buffers if any are present.
				NdisUnchainBufferAtFront(ndisPkt, &ndisBuffer);
	
				if (ndisBuffer != NULL)
				{
					AtalkNdisFreeBuffer(ndisBuffer);
				}
				NdisDprFreePacket(ndisPkt);
			}
			else
			{
				AtalkBPFreeBlock(packet-sizeof(BUFFER_HDR));
			}
			continue;
		}

		//  IMPORTANT:
		//  We know that the buffer is virtually contiguous since we allocated
		//  it. And we also know that only one buffer is allocated. So we use
		//  that knowledge to get the actual address and pass that onto the
		//  higher level routines.
		//	!!!!
		//	Although, the allocated buffer contains the link header tagged on at
		//	the end, we do not have the packet descriptor describing that. As
		//	far as we are concerned here, that tagged entity does not exist and
		//	is independently pointed to by protocolResd->pr_LinkHdr.
		//	!!!!
		packet = (PBYTE)pBufHdr + sizeof(BUFFER_HDR);
		ASSERT(packet != NULL);

		packetLength = protocolResd->Receive.pr_DataLength;

		//  Check the receive status- accept only if ok
		if (protocolResd->Receive.pr_ReceiveStatus != NDIS_STATUS_SUCCESS)
		{
			DBGPRINT(DBG_COMP_NDISRECV, DBG_LEVEL_ERR,
					("AtalkReceiveComplete: ReceiveStatus FAILURE %lx!\n",
					protocolResd->Receive.pr_ReceiveStatus));

			AtalkBPFreeBlock(packet-sizeof(BUFFER_HDR));
			continue;
		}

		//  The packet descriptor is now associate with the buffer, and we cant
		//	release the buffer (and hence the descriptor) until after we indicate to
		//  the higher levels

		switch (Media)
		{
		  case NdisMedium802_3 :
		  case NdisMediumFddi :
		  case NdisMedium802_5 :
		  case NdisMediumLocalTalk :

			if (protocol == APPLETALK_PROTOCOL)
			{
				DBGPRINT(DBG_COMP_NDISRECV, DBG_LEVEL_INFO,
						("AtalkReceiveComplete: Indicating DDP Ethernet\n"));

				AtalkDdpPacketIn(pPortDesc,
								 protocolResd->Receive.pr_LinkHdr,
								 packet,
								 (USHORT)packetLength,
                                 FALSE);
			}
			else
			{
				//  AARP Packet
				DBGPRINT(DBG_COMP_NDISRECV, DBG_LEVEL_INFO,
						("AtalkReceiveComplete: Indicating AARP Ethernet\n"));

				ASSERT(Media != NdisMediumLocalTalk);
				AtalkAarpPacketIn(pPortDesc,
								  protocolResd->Receive.pr_LinkHdr,
								  packet,
								  (USHORT)packetLength);
			}
			break;

		  default:
			KeBugCheck(0);
			break;
		}

		//	!!!!
		//	We dont have to free the link header. This follows the packet
		//	buffer (and was allocated along with it) and will be freed when
		//	the packet is freed.
		AtalkBPFreeBlock(packet-sizeof(BUFFER_HDR));
	}

    if (fDerefDefPort)
    {
        AtalkPortDereference(AtalkDefaultPort);
    }

#ifdef	PROFILING
	TimeE = KeQueryPerformanceCounter(NULL);
	TimeD.QuadPart = TimeE.QuadPart - TimeS.QuadPart;

	INTERLOCKED_ADD_LARGE_INTGR_DPC(
		&pPortDesc->pd_PortStats.prtst_RcvCompProcessTime,
		TimeD,
		&AtalkStatsLock.SpinLock);

	INTERLOCKED_INCREMENT_LONG_DPC( &pPortDesc->pd_PortStats.prtst_RcvCompCount,
									&AtalkStatsLock.SpinLock);
#endif
}



VOID
AtalkSendComplete(
	IN	NDIS_HANDLE		ProtoBindCtx,
	IN	PNDIS_PACKET	NdisPkt,
	IN	NDIS_STATUS		NdisStatus
	)
/*++

Routine Description:


Arguments:

	ProtoBindCtx- Binding associated with mac
	NdisPkt- Packet which was sent
	NdisStatus- Final status of send

Return Value:

	None

--*/
{
	PPROTOCOL_RESD  		pProtocolResd;
	PNDIS_BUFFER			pNdisBuffer=NULL, pNdisFirstBuffer=NULL;
	PPORT_DESCRIPTOR		pPortDesc;
	PBUFFER_DESC			pBufferDesc;
	SEND_COMPLETION			pSendComp;
	SEND_COMPL_INFO			sendInfo;

	//  Call the completion routine, we don't care about status now
	pProtocolResd = (PPROTOCOL_RESD)(NdisPkt->ProtocolReserved);
	ASSERT(pProtocolResd != NULL);

	pPortDesc	= pProtocolResd->Send.pr_Port;
	sendInfo	= pProtocolResd->Send.pr_SendInfo;
	pBufferDesc	= pProtocolResd->Send.pr_BufferDesc;
	pSendComp	= pProtocolResd->Send.pr_SendCompletion;

	//	We free up all the ndis buffer descriptors except the first one.
	//	NOTE: The presence of a second buffer descriptor indicates that more
	//		  than one NdisBuffer is present. But not necessarily just two. If
	//		  the client had passed in a MDL chain, we would create a corresponding
	// 		  NDIS buffer descriptor chain. Therefore, remove the first, free up
	//		  all remaining ones, then queue back the first.

	NdisUnchainBufferAtFront(NdisPkt, &pNdisFirstBuffer);

	if (pProtocolResd->Send.pr_BufferDesc->bd_Next != NULL)
	{
		while (TRUE)
		{
			NdisUnchainBufferAtBack(NdisPkt,
									&pNdisBuffer);

			if (pNdisBuffer == NULL)
			{
				break;
			}

			//	Free up the ndis buffer descriptor.
			AtalkNdisFreeBuffer(pNdisBuffer);
		}
	}

	//	Reintialize the packet descriptor.
	NdisReinitializePacket(NdisPkt);

	//	Put first buffer back in.
    if (pNdisFirstBuffer != NULL)
    {
	    NdisChainBufferAtFront(NdisPkt, pNdisFirstBuffer);
    }

	//	Call the completion routine for the transmit. This invalidates NdisPkt.
    if (pSendComp)
    {
	    (*pSendComp)(NdisStatus, pBufferDesc, &sendInfo);
    }

	//	Dereference the port
	ASSERT(pPortDesc != NULL);

#ifdef	PROFILING
	INTERLOCKED_DECREMENT_LONG(
		&pPortDesc->pd_PortStats.prtst_CurSendsOutstanding,
		&AtalkStatsLock.SpinLock);
#endif
}


VOID
AtalkBindAdapter(
	OUT PNDIS_STATUS Status,
	IN	NDIS_HANDLE	 BindContext,
	IN	PNDIS_STRING DeviceName,
	IN	PVOID		 SystemSpecific1,
	IN	PVOID		 SystemSpecific2
)
{
    // are we unloading?  if so, just return
    if (AtalkBindnUnloadStates & ATALK_UNLOADING)
    {
		DBGPRINT(DBG_COMP_NDISRECV, DBG_LEVEL_ERR,
			("AtalkBindAdapter: nothing to do: driver unloading\n"));
        return;
    }

    AtalkBindnUnloadStates |= ATALK_BINDING;

	AtalkLockInitIfNecessary();
	*Status = AtalkInitAdapter(DeviceName, NULL);

	ASSERT(*Status != NDIS_STATUS_PENDING);
	AtalkUnlockInitIfNecessary();

    AtalkBindnUnloadStates &= ~ATALK_BINDING;
}


VOID
AtalkUnbindAdapter(
	OUT PNDIS_STATUS Status,
	IN	NDIS_HANDLE ProtocolBindingContext,
	IN	NDIS_HANDLE	UnbindContext
)
{
	PPORT_DESCRIPTOR	pPortDesc = (PPORT_DESCRIPTOR)ProtocolBindingContext;


	DBGPRINT(DBG_COMP_ACTION, DBG_LEVEL_ERR,
	    ("AtalkUnbindAdapter on %lx\n",ProtocolBindingContext));

    ASSERT( VALID_PORT(pPortDesc) );

	AtalkLockInitIfNecessary();

    // First and foremost: tell guys above so they can cleanup
    if ((pPortDesc->pd_Flags & PD_DEF_PORT) ||
        (pPortDesc->pd_Flags & PD_RAS_PORT))
    {
        if (pPortDesc->pd_Flags & PD_DEF_PORT)
        {
            ASSERT(pPortDesc == AtalkDefaultPort);

            if (TdiAddressChangeRegHandle)
            {
                TdiDeregisterNetAddress(TdiAddressChangeRegHandle);
                TdiAddressChangeRegHandle = NULL;

                DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
                    ("AtalkUnbindAdapter: TdiDeregisterNetAddress on %Z done\n",
                    &pPortDesc->pd_AdapterName));

            }

            // this will tell AFP
            if (TdiRegistrationHandle)
            {
	            DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
			        ("AtalkUnbindAdapter: default adapter unbound, telling AFP, RAS\n"));

                TdiDeregisterDeviceObject(TdiRegistrationHandle);
                TdiRegistrationHandle = NULL;
            }
        }
        else
        {
	        DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
		        ("AtalkUnbindAdapter: RAS adapter unbound! telling AFP, RAS\n"));
        }

        // this will take care of informing ARAP and PPP engine above
        AtalkPnPInformRas(FALSE);
    }


	*Status = AtalkDeinitAdapter(pPortDesc);

	ASSERT(*Status != NDIS_STATUS_PENDING);
	AtalkUnlockInitIfNecessary();
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\atalk\sys\atkpnp.c ===
/*++										

Copyright (c) 1997  Microsoft Corporation

Module Name:

	atkpnp.c

Abstract:

	This module contains the support code for handling PnP events

Author:

	Shirish Koti

Revision History:
	16 Jun 1997		Initial Version

--*/


#include <atalk.h>
#pragma hdrstop
#define	FILENUM	ATKPNP

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, AtalkPnPHandler)
#pragma alloc_text(PAGE, AtalkPnPReconfigure)
#pragma alloc_text(PAGE, AtalkPnPEnableAdapter)
#endif

NDIS_STATUS
AtalkPnPHandler(
    IN  NDIS_HANDLE    NdisBindCtx,
    IN  PNET_PNP_EVENT pPnPEvent
)
{

    NDIS_STATUS     Status=STATUS_SUCCESS;

    PAGED_CODE();

    ASSERT(pPnPEvent);

    ASSERT(KeGetCurrentIrql() == 0);

    switch (pPnPEvent->NetEvent)
    {
        case NetEventReconfigure:

	            DBGPRINT(DBG_COMP_ACTION, DBG_LEVEL_INFO,
		            ("AtalkPnPHandler: NetEventReconfigure event\n"));

                Status = AtalkPnPReconfigure(NdisBindCtx,pPnPEvent);

                break;

        case NetEventCancelRemoveDevice:

	            DBGPRINT(DBG_COMP_ACTION, DBG_LEVEL_ERR,
		            ("AtalkPnPHandler: NetEventCancelRemoveDevice event\n"));
                break;

        case NetEventQueryRemoveDevice:

	            DBGPRINT(DBG_COMP_ACTION, DBG_LEVEL_ERR,
		            ("AtalkPnPHandler: NetEventQueryRemoveDevice event\n"));
                break;

        case NetEventQueryPower:

	            DBGPRINT(DBG_COMP_ACTION, DBG_LEVEL_ERR,
		            ("AtalkPnPHandler: NetEventQueryPower event\n"));
                break;

        case NetEventSetPower:

	            DBGPRINT(DBG_COMP_ACTION, DBG_LEVEL_ERR,
		            ("AtalkPnPHandler: NetEventSetPower event\n"));
                break;

        case NetEventBindsComplete:
	            DBGPRINT(DBG_COMP_ACTION, DBG_LEVEL_ERR,
		            ("AtalkPnPHandler: NetEventBindsComplete event\n"));
                break;

        case NetEventBindList:
	            DBGPRINT(DBG_COMP_ACTION, DBG_LEVEL_ERR,
		            ("AtalkPnPHandler: NetEventBindList event\n"));
                break;

        default:
	            DBGPRINT(DBG_COMP_ACTION, DBG_LEVEL_ERR,
		            ("AtalkPnPHandler: what is this event?, verify if it is valid/new = %ld\n", pPnPEvent->NetEvent));

		break;
    }

    ASSERT(Status == STATUS_SUCCESS);

    return(STATUS_SUCCESS);
}


NDIS_STATUS
AtalkPnPReconfigure(
    IN  NDIS_HANDLE    NdisBindCtx,
    IN  PNET_PNP_EVENT pPnPEvent
)
{

    NTSTATUS            Status=STATUS_SUCCESS;
    NTSTATUS            LocStatus=STATUS_SUCCESS;
    PPORT_DESCRIPTOR    pPortDesc;
    PPORT_DESCRIPTOR    pPrevPortDesc;
    PPORT_DESCRIPTOR    pNextPortDesc;
    PPORT_DESCRIPTOR    pFirstPortDesc;
    PPORT_DESCRIPTOR    pWalkerPortDesc;
    PATALK_PNP_EVENT    pPnpBuf;
    BOOLEAN             fWeFoundOut;


    pPortDesc = (PPORT_DESCRIPTOR)NdisBindCtx;

    pPnpBuf = (PATALK_PNP_EVENT)(pPnPEvent->Buffer);

    //
    // if it's a global configuration message, just ignore it because we will
    // be getting (or have already got) specific messages
    //
    if (pPnpBuf == NULL)
    {
		DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
		    ("AtalkPnPReconfigure: ignoring global config message\n"));
        return(STATUS_SUCCESS);
    }

    if ((!pPortDesc) &&
        (pPnpBuf->PnpMessage != AT_PNP_SWITCH_ROUTING) &&
        (pPnpBuf->PnpMessage != AT_PNP_SWITCH_DEFAULT_ADAPTER))
    {
		DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
		    ("AtalkPnPReconfigure: ignoring NULL context (pnp msg = %d)\n",
            pPnpBuf->PnpMessage));
        return(STATUS_SUCCESS);
    }

    if (AtalkBindnUnloadStates & ATALK_UNLOADING)
    {
		DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
		    ("AtalkPnPReconfigure: stack is shutting down, ignoring pnp\n"));
        return(STATUS_SUCCESS);
    }

    AtalkBindnUnloadStates |= ATALK_PNP_IN_PROGRESS;

	DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR, ("\n\nProcessing PnP Event....\n\n"));

    AtalkLockInitIfNecessary();

    ASSERT(pPnpBuf != NULL);

    switch (pPnpBuf->PnpMessage)
    {
        //
        // user just checked (or unchecked) the router checkbox!  If we are
        // currently not routing, we must start routing.  If we are currently
        // routing, we must stop routing.  "Disable" all the adapters, go read
        // the global config info and "Enable" all the adapters back.
        //
        case AT_PNP_SWITCH_ROUTING:

			DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
			    ("AtalkPnPReconfigure: AT_PNP_SWITCH_ROUTING. Currently, routing is %s\n"
                ,(AtalkRouter)? "ON" : "OFF" ));

            pPortDesc = pFirstPortDesc = AtalkPortList;
            pPrevPortDesc = pPortDesc;

            if (!pPortDesc)
            {
			    DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
			        ("AtalkPnPReconfigure: no adapter configured! no action taken\n"));
                break;
            }

            //
            // if we are currently running the router, first stop the global
            // rtmp and zip timers
            //
            if (AtalkRouter)
            {
                if (AtalkTimerCancelEvent(&atalkRtmpVTimer, NULL))
                {
			        DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
			            ("AtalkPnPReconfigure: cancelled atalkRtmpValidityTimer\n"));
                }
                else
                {
			        DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
			            ("AtalkPnPReconfigure: couldn't cancel atalkRtmpValidityTimer\n"));
                }

                if (AtalkTimerCancelEvent(&atalkZipQTimer, NULL))
                {
			        DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
			            ("AtalkPnPReconfigure: cancelled atalkZipQueryTimer\n"));
                }
                else
                {
			        DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
			            ("AtalkPnPReconfigure: couldn't cancel atalkZipQueryTimer\n"));
                }
            }

            atalkRtmpVdtTmrRunning  = FALSE;

            atalkZipQryTmrRunning   = FALSE;

            //
            // now, disable all the ports in the list one by one.  This actually
            // removes the adapter from the list as well.  Link all these adapters
            // together so we can enable all of them.
            // (NDIS guaranteed that no ndis event (pnp, unbind etc.) can happen
            // when one is in progress, so we don't need lock here)
            //
            while (pPortDesc != NULL)
            {

                DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
                    ("AtalkPnPReconfigure: disabling pPortDesc %lx\n",pPortDesc));

                Status = AtalkPnPDisableAdapter(pPortDesc);

                pPortDesc = AtalkPortList;
                pPrevPortDesc->pd_Next = pPortDesc;
                pPrevPortDesc = pPortDesc;
            }

            // unlock the pages that we locked when router was first started
            if (AtalkRouter)
            {
                AtalkUnlockRouterIfNecessary();
            }

            if (AtalkDefaultPortName.Buffer)
            {
                AtalkFreeMemory(AtalkDefaultPortName.Buffer);
                AtalkDefaultPortName.Buffer = NULL;
            }

            if (AtalkDesiredZone)
            {
                ASSERT(AtalkDesiredZone->zn_RefCount >= 1);
                AtalkZoneDereference(AtalkDesiredZone);
                AtalkDesiredZone = NULL;
            }

            // get rid of routing table, if one exists
            AtalkRtmpInit(FALSE);

            // go read all the parms again: registry must have changed
            LocStatus = atalkInitGlobal();

            ASSERT(NT_SUCCESS(LocStatus));

            // now, enable all the adapters back!
            pPortDesc = pFirstPortDesc;

            while (pPortDesc != NULL)
            {
                pNextPortDesc = pPortDesc->pd_Next;
                pPortDesc->pd_Next = NULL;

                DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
                    ("AtalkPnPReconfigure: enabling pPortDesc %lx\n",pPortDesc));

                Status = AtalkPnPEnableAdapter(pPortDesc);

                pPortDesc = pNextPortDesc;
            }

            break;

        //
        // user has changed the default adapter.  First, "disable" our
        // current default adapter and the wannabe default adapter.  Then,
        // "enable" both the adapters, and that should take care of everything!
        //
        case AT_PNP_SWITCH_DEFAULT_ADAPTER:

			DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
			    ("AtalkPnPReconfigure: AT_PNP_SWITCH_DEFAULT_ADAPTER (old=(%lx) new=(%lx)\n",
                AtalkDefaultPort,pPortDesc));

            pPrevPortDesc = AtalkDefaultPort;

            // check if default adapter exists: it's possible that at this moment there isn't one
            if (pPrevPortDesc)
            {
                Status = AtalkPnPDisableAdapter(pPrevPortDesc);
            }

            // release the default adapter name buffer, and desired zone buffer
            if (AtalkDefaultPortName.Buffer)
            {
                AtalkFreeMemory(AtalkDefaultPortName.Buffer);
                AtalkDefaultPortName.Buffer = NULL;
            }

            if (AtalkDesiredZone)
            {
                ASSERT(AtalkDesiredZone->zn_RefCount >= 1);
                AtalkZoneDereference(AtalkDesiredZone);
                AtalkDesiredZone = NULL;
            }

            // go read all the parms again: registry must have changed
            LocStatus = atalkInitGlobal();

            ASSERT(NT_SUCCESS(LocStatus));

            fWeFoundOut = FALSE;

            ASSERT(AtalkDefaultPortName.Buffer != NULL);

            // if we know who the new default adapter is going to be, disable him now
            if (pPortDesc != NULL)
            {
                Status = AtalkPnPDisableAdapter(pPortDesc);
            }

            //
            // UI doesn't know who the default adapter is, so let's find out
            // AtalkDefaultPortName.Buffer can not be null, but let's not bugcheck if
            // there is some problem in how UI does things.
            //
            else if (AtalkDefaultPortName.Buffer != NULL)
            {
                //
                // note that we aren't holding AtalkPortLock here.  The only way
                // the list can change is if an adapter binds or unbinds.  Since ndis
                // guarantees that all bind/unbind/pnp operations are serialized, and
                // since ndis has already called us here, the list can't change.
                //
                pPortDesc = AtalkPortList;

                while (pPortDesc != NULL)
                {
	                if (RtlEqualUnicodeString(&pPortDesc->pd_AdapterName,
		    		            	          &AtalkDefaultPortName,
			    		                      TRUE))
	                {
                        fWeFoundOut = TRUE;
	                    break;
	                }

                    pPortDesc = pPortDesc->pd_Next;
                }

                if (pPortDesc == NULL)
                {
			        DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
			            ("AtalkPnPReconfigure: still no default port????\n"));
                }
            }

            //
            // if there default adapter existed before this, reenable it (to be
            // a non-default adapter)
            //
            if (pPrevPortDesc)
            {
                Status = AtalkPnPEnableAdapter(pPrevPortDesc);
            }

            //
            // if we were told who the default adapter is, or if we found out
            // ourselves and one of the existing adapters is the default adatper,
            // disable it and reenable
            //
            if (pPortDesc)
            {
                // disable this guy if we found him out
                if (fWeFoundOut)
                {
                    Status = AtalkPnPDisableAdapter(pPortDesc);
                }

                // reenable the new adapter so that it is now the default adatper
                Status = AtalkPnPEnableAdapter(pPortDesc);

			    DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
			        ("AtalkPnPReconfigure: %lx is the new default adapter\n",pPortDesc));
                ASSERT(AtalkDefaultPort == pPortDesc);
            }
            else
            {
			    DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
			        ("AtalkPnPReconfigure: no default adapter configured!\n"));
            }

            break;

        //
        // user has changed some parameter on the adapter (e.g. the desired zone,
        // or some seeding info etc.).  Just "disable" and then "enable" this
        // adapter, and everything should just work!
        //
        case AT_PNP_RECONFIGURE_PARMS:

			DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
			    ("AtalkPnPReconfigure: AT_PNP_RECONFIGURE_PARMS on pPortDesc %lx\n",pPortDesc));

            Status = AtalkPnPDisableAdapter(pPortDesc);

            // release the default adapter name buffer, and desired zone buffer
            if (AtalkDefaultPortName.Buffer)
            {
                AtalkFreeMemory(AtalkDefaultPortName.Buffer);
                AtalkDefaultPortName.Buffer = NULL;
            }

            if (AtalkDesiredZone)
            {
                ASSERT(AtalkDesiredZone->zn_RefCount >= 1);
                AtalkZoneDereference(AtalkDesiredZone);
                AtalkDesiredZone = NULL;
            }

            // go read all the parms again: registry must have changed
            LocStatus = atalkInitGlobal();

            ASSERT(NT_SUCCESS(LocStatus));

            Status = AtalkPnPEnableAdapter(pPortDesc);

            break;


        default:

			DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
			    ("AtalkPnPReconfigure: and what msg is this (%ld) ??\n",pPnpBuf->PnpMessage));

            ASSERT(0);

            break;
    }


    AtalkUnlockInitIfNecessary();

    ASSERT(Status == STATUS_SUCCESS);

    AtalkBindnUnloadStates &= ~ATALK_PNP_IN_PROGRESS;

	DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
	    ("\n\n.... completed processing PnP Event\n\n"));

    return(STATUS_SUCCESS);
}



NTSTATUS
AtalkPnPDisableAdapter(
	IN	PPORT_DESCRIPTOR	pPortDesc
)
{

    NTSTATUS        Status;
    KIRQL           OldIrql;
    PLIST_ENTRY     pList;
    PARAPCONN       pArapConn;
    PATCPCONN       pAtcpConn;
    BOOLEAN         fDllDeref;
    BOOLEAN         fLineDownDeref;


    if (!pPortDesc)
    {
	    DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
	        ("AtalkPnPDisableAdapter: pPortDesc is NULL!!!\n"));

        return(STATUS_SUCCESS);
    }

    ASSERT(VALID_PORT(pPortDesc));

	DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
	    ("AtalkPnPDisableAdapter: entered with %lx\n",pPortDesc));

    //
    // we are going to "disable" this port due to PnP: note that fact!
    //
	ACQUIRE_SPIN_LOCK(&pPortDesc->pd_Lock, &OldIrql);
	pPortDesc->pd_Flags |= PD_PNP_RECONFIGURE;
	RELEASE_SPIN_LOCK(&pPortDesc->pd_Lock, OldIrql);

    // First and foremost: tell guys above so they can cleanup
    if (pPortDesc->pd_Flags & PD_DEF_PORT)
    {
        ASSERT(pPortDesc == AtalkDefaultPort);

        if (TdiAddressChangeRegHandle)
        {
            TdiDeregisterNetAddress(TdiAddressChangeRegHandle);
            TdiAddressChangeRegHandle = NULL;

            DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
                ("AtalkPnPDisableAdapter: TdiDeregisterNetAddress on %Z done\n",
                &pPortDesc->pd_AdapterName));

        }

        // this will tell AFP
        if (TdiRegistrationHandle)
        {
	        DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
			    ("AtalkPnPDisableAdapter: telling AFP about PnP\n"));

            TdiDeregisterDeviceObject(TdiRegistrationHandle);
            TdiRegistrationHandle = NULL;
        }

        // this will take care of informing ARAP and PPP engine above
        AtalkPnPInformRas(FALSE);
    }

    //
    // if this is RAS port or the Default port, kill all the ARAP and PPP
    // connections if any are left.
    // Since we've marked that PnpReconfigure is in progress, no more
    // new connections will be allowed
    //
    if ((pPortDesc == RasPortDesc) ||
        ((pPortDesc->pd_Flags & PD_DEF_PORT) && (RasPortDesc != NULL)))
    {
        ACQUIRE_SPIN_LOCK(&RasPortDesc->pd_Lock, &OldIrql);

        pList = RasPortDesc->pd_ArapConnHead.Flink;

        // first, the ARAP guys
        while (pList != &RasPortDesc->pd_ArapConnHead)
        {
            pArapConn = CONTAINING_RECORD(pList, ARAPCONN, Linkage);

            ASSERT(pArapConn->Signature == ARAPCONN_SIGNATURE);

            // if this connection is already disconnected, skip it
            ACQUIRE_SPIN_LOCK_DPC(&pArapConn->SpinLock);
            if (pArapConn->State == MNP_DISCONNECTED)
            {
                pList = pArapConn->Linkage.Flink;
                RELEASE_SPIN_LOCK_DPC(&pArapConn->SpinLock);
                continue;
            }

            RELEASE_SPIN_LOCK_DPC(&pArapConn->SpinLock);
            RELEASE_SPIN_LOCK(&RasPortDesc->pd_Lock, OldIrql);

	        DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
	            ("AtalkPnPDisableAdapter: killing ARAP connection %lx\n",pArapConn));

            ArapCleanup(pArapConn);

            ACQUIRE_SPIN_LOCK(&RasPortDesc->pd_Lock, &OldIrql);

            pList = RasPortDesc->pd_ArapConnHead.Flink;
        }

        // and now, the PPP guys

        // if there are any ppp guys, remove them from this list and dereference
        // them.  In most cases, they will get freed right away.  If someone had
        // a refcount, it will get freed when that refcount goes away
        while (!(IsListEmpty(&RasPortDesc->pd_PPPConnHead)))
        {
            pList = RasPortDesc->pd_PPPConnHead.Flink;
            pAtcpConn = CONTAINING_RECORD(pList, ATCPCONN, Linkage);

            ASSERT(pAtcpConn->Signature == ATCPCONN_SIGNATURE);

            ACQUIRE_SPIN_LOCK_DPC(&pAtcpConn->SpinLock);

            RemoveEntryList(&pAtcpConn->Linkage);
            InitializeListHead(&pAtcpConn->Linkage);

            fDllDeref = (pAtcpConn->Flags & ATCP_DLL_SETUP_DONE)? TRUE : FALSE;
            fLineDownDeref = (pAtcpConn->Flags & ATCP_LINE_UP_DONE)? TRUE : FALSE;

            pAtcpConn->Flags &= ~(ATCP_DLL_SETUP_DONE|ATCP_LINE_UP_DONE);

            RELEASE_SPIN_LOCK_DPC(&pAtcpConn->SpinLock);
            RELEASE_SPIN_LOCK(&RasPortDesc->pd_Lock, OldIrql);

	        DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
	            ("AtalkPnPDisableAdapter: deref'ing PPP conn %lx (%d+%d times)\n",
                pAtcpConn,fDllDeref,fLineDownDeref));

            // remove the DLL refcount
            if (fDllDeref)
            {
                DerefPPPConn(pAtcpConn);
            }

            // remove the NDISWAN refcount
            if (fLineDownDeref)
            {
                DerefPPPConn(pAtcpConn);
            }

            ACQUIRE_SPIN_LOCK(&RasPortDesc->pd_Lock, &OldIrql);
        }

        RELEASE_SPIN_LOCK(&RasPortDesc->pd_Lock, OldIrql);
    }

    //
    // "Disable" the adapter (basically we do everything except close the
    // adapter with ndis and freeing up the pPortDesc memory)
    //
	Status = AtalkDeinitAdapter(pPortDesc);

    if (!NT_SUCCESS(Status))
    {
	    DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
	        ("AtalkPnPDisableAdapter: AtalkDeinitAdapter failed %lx\n",Status));
        ASSERT(0);
    }
    return(Status);
}


NTSTATUS
AtalkPnPEnableAdapter(
	IN	PPORT_DESCRIPTOR	pPortDesc
)
{

    NTSTATUS        Status;


    if (!pPortDesc)
    {
	    DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
	        ("AtalkPnPDisableAdapter: pPortDesc is NULL!!!\n"));

        return(STATUS_SUCCESS);
    }


	DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
	    ("AtalkPnPEnableAdapter: entered with %lx\n",pPortDesc));

    //
    // "Enable" the adapter (we do everything except that we don't
    // allocate memory for pPortDesc - since we didn't free it, and we don't
    // open the adapter with ndis - since we didn't close it).
    //

	Status = AtalkInitAdapter(NULL, pPortDesc);

    // we are done with the PnPReconfigure evnet: reset that bit
    AtalkPortSetResetFlag(pPortDesc, TRUE, PD_PNP_RECONFIGURE);

    // tell ARAP everything is ok
    if (pPortDesc->pd_Flags & (PD_DEF_PORT | PD_RAS_PORT))
    {
        ASSERT((pPortDesc == AtalkDefaultPort) || (pPortDesc == RasPortDesc));

        // this will take care of informing ARAP and PPP engine above
        AtalkPnPInformRas(TRUE);
    }


    if (!NT_SUCCESS(Status))
    {
	    DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
	        ("AtalkPnPEnableAdapter: AtalkInitAdapter failed %lx\n",Status));
        ASSERT(0);
    }

    DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
        ("AtalkPnPEnableAdapter: completed PnP on %lx (flag %lx)\n",
        pPortDesc,pPortDesc->pd_Flags));

    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\atalk\sys\atkndis.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

	atkndis.h

Abstract:

	This module contains the ndis init/deint and protocol-support
	for	ndis definitions.

Author:

	Jameel Hyder (jameelh@microsoft.com)
	Nikhil Kamkolkar (nikhilk@microsoft.com)

Revision History:
	19 Jun 1992		Initial Version

Notes:	Tab stop: 4
--*/

#ifndef	_ATKNDIS_
#define	_ATKNDIS_

// This is the name that will be used in NdisRegisterProtocol. This has to match the
// registry section for PnP to work !!!
#define	PROTOCOL_REGISTER_NAME		L"Appletalk"

//	NDIS Version (4.0)
#define	PROTOCOL_MAJORNDIS_VERSION 	4
#define	PROTOCOL_MINORNDIS_VERSION 	0

// IEEE802.2 Definitions
// Offsets within the Extended 802.2 header:
#define IEEE8022_DSAP_OFFSET				0
#define IEEE8022_SSAP_OFFSET				1
#define IEEE8022_CONTROL_OFFSET				2
#define IEEE8022_PROTO_OFFSET				3

// 808.2 header length: DSAP, SSAP, UI, and PID (protocol ID).
#define IEEE8022_HDR_LEN					8

// Values for SSAP and DSAP (the SNAP SAP) indicating 802.2 Extended.
#define SNAP_SAP							((BYTE)0xAA)
#define	SNAP_SAP_FINAL						((BYTE)0xAB)

// Value for Control Field:
#define UNNUMBERED_INFO						0x03
#define	UNNUMBERED_FORMAT					0xF3

// Length of 802.2 SNAP protocol discriminators.
#define IEEE8022_PROTO_TYPE_LEN				5

//	The MAX_OPTHDR_LEN should be such that it holds the maximum header following
//	the ddp header from the upper layers (ADSP 13/ATP 8) and also it should allow a
//	full aarp packet to be held in the buffer when including the DDP header buffer.
//	i.e. 28. Ddp long header is 13. So the max works out to 15.
#define	MAX_OPTHDR_LEN						15

// AARP hardware types:
#define AARP_ELAP_HW_TYPE					1
#define AARP_TLAP_HW_TYPE					2

// Packet sizes.
#define AARP_MAX_DATA_SIZE					38		// Var fields... Enet is max
#define AARP_MIN_DATA_SIZE					28
#define AARP_MAX_PKT_SIZE					(IEEE8022_HDR_LEN +	AARP_MAX_DATA_SIZE)
#define	AARPLINK_MAX_PKT_SIZE				AARP_MAX_PKT_SIZE

#define AARP_ATALK_PROTO_TYPE				0x809B

#define	NUM_PACKET_DESCRIPTORS				300
#define	NUM_BUFFER_DESCRIPTORS				600
#define	ROUTING_FACTOR						4

// ETHERNET
#define ELAP_MIN_PKT_LEN					60
#define ELAP_ADDR_LEN						6

#define ELAP_DEST_OFFSET					0
#define ELAP_SRC_OFFSET						6
#define ELAP_LEN_OFFSET						12
#define ELAP_8022_START_OFFSET				14

#define ELAP_LINKHDR_LEN					14

// Ethernet multicast address:
#define ELAP_BROADCAST_ADDR_INIT			\
	{	0x09, 0x00, 0x07, 0xFF, 0xFF, 0xFF	}

#define ELAP_ZONE_MULTICAST_ADDRS			253

#define	ELAP_NUM_INIT_AARP_BUFFERS			 10

#define AtalkNdisFreeBuffer(_ndisBuffer)        \
{                                               \
    PNDIS_BUFFER    _ThisBuffer, _NextBuffer;   \
                                                \
    _ThisBuffer = _ndisBuffer;                  \
    while (_ThisBuffer)                         \
    {                                           \
        _NextBuffer = _ThisBuffer->Next;        \
        _ThisBuffer->Next = NULL;               \
        NdisFreeBuffer(_ThisBuffer);            \
        ATALK_DBG_DEC_COUNT(AtalkDbgMdlsAlloced);\
        _ThisBuffer = _NextBuffer;              \
    }                                           \
}

//	Values that are global to ndis routines
//	These are the media the stack will support
extern	NDIS_MEDIUM AtalkSupportedMedia[];


extern	ULONG		AtalkSupportedMediaSize;

extern	NDIS_HANDLE		AtalkNdisProtocolHandle;

extern	BYTE			AtalkElapBroadcastAddr[ELAP_ADDR_LEN];

extern	BYTE			AtalkAlapBroadcastAddr[];

extern	BYTE			AtalkAarpProtocolType[IEEE8022_PROTO_TYPE_LEN];

extern	BYTE			AtalkAppletalkProtocolType[IEEE8022_PROTO_TYPE_LEN];

extern	ATALK_NETWORKRANGE	AtalkStartupNetworkRange;
																
#define	ELAP_MCAST_HDR_LEN		(ELAP_ADDR_LEN - 1)

extern	BYTE	AtalkEthernetZoneMulticastAddrsHdr[ELAP_MCAST_HDR_LEN];

extern	BYTE	AtalkEthernetZoneMulticastAddrs[ELAP_ZONE_MULTICAST_ADDRS];

//	TOKENRING

#define TLAP_ADDR_LEN						6

//	For the following offsets we assume that a TokenRing packet as handed to
//	us will be complete EXCEPT for the "non-data" portions: Starting Delimiter
//	(SD), Frame Check Sequence (FCS), End of Frame Sequence (EFS), and Ending
//	Delimiter (ED).
#define TLAP_ACCESS_CTRL_OFFSET				0
#define TLAP_FRAME_CTRL_OFFSET				1
#define TLAP_DEST_OFFSET					2
#define TLAP_SRC_OFFSET						8
#define TLAP_ROUTE_INFO_OFFSET				14

//		A few "magic" values:
#define TLAP_ACCESS_CTRL_VALUE				0x00	// Priority zero frame.
#define TLAP_FRAME_CTRL_VALUE				0x40	// LLC frame, priority zero.
#define TLAP_SRC_ROUTING_MASK				0x80	// In first byte of source
													// address.

// Token ring source routing info stuff:
#define TLAP_ROUTE_INFO_SIZE_MASK			0x1F	// In first byte of routing
													// info, if present.

#define TLAP_MIN_ROUTING_BYTES				2
#define TLAP_MAX_ROUTING_BYTES				MAX_ROUTING_BYTES
#define TLAP_MAX_ROUTING_SPACE				MAX_ROUTING_SPACE
													// Previously defined in ports.h
#define TLAP_BROADCAST_INFO_MASK			0xE0	// In first byte of routing
													// info.
#define TLAP_NON_BROADCAST_MASK				0x1F	// To reset above bits.
#define TLAP_DIRECTION_MASK					0x80	// In second byte of routing
													// info.

#define TLAP_MIN_LINKHDR_LEN				TLAP_ROUTE_INFO_OFFSET
#define TLAP_MAX_LINKHDR_LEN				(TLAP_ROUTE_INFO_OFFSET + MAX_ROUTING_SPACE)

#define TLAP_BROADCAST_DEST_LEN				2

// TokenRing multicast address:
#define TLAP_BROADCAST_ADDR_INIT			{	0xC0, 0x00, 0x40, 0x00, 0x00, 0x00	}

#define TLAP_ZONE_MULTICAST_ADDRS			19

#define	TLAP_NUM_INIT_AARP_BUFFERS			6

#define	TLAP_MCAST_HDR_LEN					2

extern	BYTE	AtalkTokenRingZoneMulticastAddrsHdr[TLAP_MCAST_HDR_LEN];

extern	BYTE	AtalkTokenRingZoneMulticastAddrs[TLAP_ZONE_MULTICAST_ADDRS]
												[TLAP_ADDR_LEN - TLAP_MCAST_HDR_LEN];

extern	BYTE			AtalkTlapBroadcastAddr[TLAP_ADDR_LEN];

extern	BYTE			AtalkBroadcastRouteInfo[TLAP_MIN_ROUTING_BYTES];

extern	BYTE			AtalkSimpleRouteInfo[TLAP_MIN_ROUTING_BYTES];

extern	BYTE			AtalkBroadcastDestHdr[TLAP_BROADCAST_DEST_LEN];

//	FDDI
#define	FDDI_HEADER_BYTE					0x57	// Highest priority
#define MIN_FDDI_PKT_LEN					53		// From emperical data
#define FDDI_ADDR_LEN						6

#define FDDI_DEST_OFFSET					1
#define FDDI_SRC_OFFSET						7
#define FDDI_802DOT2_START_OFFSET			13
#define FDDI_LINKHDR_LEN					13

#define	FDDI_NUM_INIT_AARP_BUFFERS			10

//	LOCALTALK
#define ALAP_DEST_OFFSET					0
#define ALAP_SRC_OFFSET						1
#define ALAP_TYPE_OFFSET					2

#define ALAP_LINKHDR_LEN					3	// src, dest, lap type

#define ALAP_SDDP_HDR_TYPE					1
#define ALAP_LDDP_HDR_TYPE					2

#define	ALAP_NUM_INIT_AARP_BUFFERS			0

// WAN
#define WAN_LINKHDR_LEN                     14

// For send buffers, define a max. linkhdr len which is max of ELAP, TLAP, FDDI & ALAP
#define	MAX_LINKHDR_LEN				(IEEE8022_HDR_LEN + TLAP_MAX_LINKHDR_LEN)
											

#define	MAX_SENDBUF_LEN				(MAX_OPTHDR_LEN + MAX_LINKHDR_LEN + LDDP_HDR_LEN)

//
// 14 for "fake" ethernet hdr, 5 (worst case, with non-optimized phase) for
// MNP LT hdr, 5 for Start,Stop flags)
//
#define MNP_MINSEND_LEN         (MNP_MINPKT_SIZE + WAN_LINKHDR_LEN + 5 + 5 + 40)
#define MNP_MAXSEND_LEN         (MNP_MAXPKT_SIZE + WAN_LINKHDR_LEN + 5 + 5 + 40)

// Localtalk broadcast address: (only the first byte - 0xFF)
#define ALAP_BROADCAST_ADDR_INIT					\
		{ 0xFF, 0x00, 0x00,	0x00, 0x00, 0x00 }

// there is no broadcast addr for Arap: just put 0's
#define ARAP_BROADCAST_ADDR_INIT					\
		{ 0x00, 0x00, 0x00,	0x00, 0x00, 0x00 }

//	Completion routine type for ndis requests
typedef	struct _SEND_COMPL_INFO
{
	TRANSMIT_COMPLETION	sc_TransmitCompletion;
	PVOID				sc_Ctx1;
	PVOID				sc_Ctx2;
	PVOID				sc_Ctx3;

} SEND_COMPL_INFO, *PSEND_COMPL_INFO;

typedef VOID (*SEND_COMPLETION)(
						NDIS_STATUS				Status,
						PBUFFER_DESC			BufferChain,
						PSEND_COMPL_INFO		SendInfo	OPTIONAL
);

//	For incoming packets:
//	The structure of our ddp packets will be
//			+-------+
//			|Header |
//Returned->+-------+
//Ptr		| DDP	|
//			| HDR   |
//			| DATA	|
//			| AARP  |
//			| DATA	|
//			+-------+
//	
//	The link header is stored in the ndis packet descriptor.
//

typedef	struct _BUFFER_HDR
{
	PNDIS_PACKET				bh_NdisPkt;
	PNDIS_BUFFER				bh_NdisBuffer;
} BUFFER_HDR, *PBUFFER_HDR;

typedef	struct _AARP_BUFFER
{
	BUFFER_HDR					ab_Hdr;
	BYTE						ab_Data[AARP_MAX_DATA_SIZE];

} AARP_BUFFER, *PAARP_BUFFER;


typedef	struct _DDP_SMBUFFER
{
	BUFFER_HDR					dsm_Hdr;
	BYTE						dsm_Data[LDDP_HDR_LEN +
										 8 +	// ATP header size
										 64];	// ASP Data size (Average)

} DDP_SMBUFFER, *PDDP_SMBUFFER;

typedef	struct _DDP_LGBUFFER
{
	BUFFER_HDR					dlg_Hdr;
	BYTE						dlg_Data[MAX_LDDP_PKT_SIZE];

} DDP_LGBUFFER, *PDDP_LGBUFFER;


//	BUFFERING for sends
//	For outgoing packets, we preallocate buffer headers with buffer descriptors
//	following it, and the link/ddp/max opt hdr len memory following it.
//			+-------+
//			|Header	|
//			+-------+
//			|BuffDes|
//			+-------+
//			|MAXLINK|
//			+-------+
//			|MAX DDP|
//			+-------+
//			|MAX OPT|
//			+-------+
//
//	The header will contain a ndis buffer descriptor which will describe the
//	MAXLINK/MAXDDP/MAXOPT area. Set the size before sending. And reset when
//	Freeing. The next pointer in the buffer descriptor is used for chaining in
//	free list.
//
//	NOTE: Since for receives, we store the link header in the packet descriptor,
//		  the question arises, why not for sends? Because we want to use just one
//		  ndis buffer descriptor to describe all the non-data part.
//
//	!!!!IMPORTANT!!!!
//	The buffer descriptor header is accessed by going back from the buffer descriptor
//	pointer, so its important that the buffer descriptor header start from an
//	aligned address, i.e. make sure the structure does not contain elements that
//	could throw it out of alignment.
typedef struct _SENDBUF
{
	// NOTE: BUFFER_HDR must be the first thing. Look at AtalkBPAllocBlock();
	BUFFER_HDR						sb_BuffHdr;
	BUFFER_DESC						sb_BuffDesc;
	BYTE							sb_Space[MAX_SENDBUF_LEN];
} SENDBUF, *PSENDBUF;


//
// !!!!IMPORTANT!!!!
// This structure needs to stay aligned (i.e. Buffer[1] field MUST start on an
// aligned addr! If necessary, add a padding!)
//
typedef struct _MNPSENDBUF
{
    // NOTE: BUFFER_HDR must be the first thing. Look at AtalkBPAllocBlock();
    BUFFER_HDR            sb_BuffHdr;
    BUFFER_DESC           sb_BuffDesc;
    LIST_ENTRY            Linkage;      // to queue in ArapRetransmitQ
#if DBG
    DWORD                 Signature;
#endif
    LONG                  RetryTime;    // at this time, we will retransmit this send

    PARAPCONN             pArapConn;    // who owns this send
    PARAP_SEND_COMPLETION ComplRoutine; // routine to call when this send completes
    LONG                  TimeAlloced;  // time the first send came in on this buf

    USHORT                DataSize;     // how much of the buffer is data
    USHORT                BytesFree;    // can we stuff more packet(s)?

    // NOTE: (Remember: Buffer[1] must start on DWORD boundary) see if we can make Flags a byte
    DWORD                 Flags;

    BYTE                  SeqNum;       // sequence number used for this send
    BYTE                  RetryCount;   // how many times we have retransmitted this
    BYTE                  RefCount;     // free this buffer when refcount goes to 0
    BYTE                  NumSends;     // how many sends do we have stuffed here
    PBYTE                 FreeBuffer;   // pointer to free space
    BYTE                  Buffer[1];
} MNPSENDBUF, *PMNPSENDBUF;

typedef struct _ARAPBUF
{
    LIST_ENTRY            Linkage;       // to queue in ReceiveQ
#if DBG
    DWORD                 Signature;
#endif
    BYTE                  MnpFrameType;  // type of frame this is (LT, LN etc.)
    BYTE                  BlockId;       // what kind of buffer is this
    USHORT                BufferSize;    // how big is the buffer (set at init only)
	USHORT				  DataSize;      // how many bytes are valid (possible >1 srp)
    PBYTE                 CurrentBuffer; // where does data begin...
    BYTE                  Buffer[1];     // the buffer (with v42bis compressed pkt)
} ARAPBUF, *PARAPBUF;


#define ARAPCONN_SIGNATURE      0x99999999
#define ATCPCONN_SIGNATURE      0x88888888

#define MNPSMSENDBUF_SIGNATURE  0xbeef1111
#define MNPLGSENDBUF_SIGNATURE  0xbeef8888

#define ARAPSMPKT_SIGNATURE     0xcafe2222
#define ARAPMDPKT_SIGNATURE     0xcafe3333
#define ARAPLGPKT_SIGNATURE     0xcafe4444

#define ARAPLGBUF_SIGNATURE     0xdeebacad
#define ARAPUNLMTD_SIGNATURE    0xfafababa


//	PROTOCOL RESERVED Structure
//	This is what we expect to be in the packet descriptor. And we use it
//	to store information to be used during the completion of the send/
//	receives.

typedef struct
{
	//	!!!WARNING!!!
	//	pr_Linkage must be the first element in this structure for the
	//	CONTAINING_RECORD macro to work in receive completion.

	union
	{
		struct
		{
			PPORT_DESCRIPTOR		pr_Port;
			PBUFFER_DESC			pr_BufferDesc;
			SEND_COMPLETION			pr_SendCompletion;
			SEND_COMPL_INFO			pr_SendInfo;
		} Send;

		struct
		{
			LIST_ENTRY				pr_Linkage;
			PPORT_DESCRIPTOR		pr_Port;
			LOGICAL_PROTOCOL		pr_Protocol;
			NDIS_STATUS				pr_ReceiveStatus;
			PBUFFER_HDR				pr_BufHdr;
			BYTE					pr_LinkHdr[TLAP_MAX_LINKHDR_LEN];
			USHORT					pr_DataLength;
			BOOLEAN					pr_Processed;
			BYTE					pr_OptimizeType;
			BYTE					pr_OptimizeSubType;
			PVOID					pr_OptimizeCtx;
			ATALK_ADDR				pr_SrcAddr;
			ATALK_ADDR				pr_DestAddr;
			BOOLEAN					pr_OffCablePkt;
			union
			{
				//	ATP Structure
				struct
				{
					BYTE					pr_AtpHdr[8];	// ATP header size
					struct _ATP_ADDROBJ *	pr_AtpAddrObj;
				};

				//	ADSP Structure

			};
		} Receive;
	};
} PROTOCOL_RESD, *PPROTOCOL_RESD;


//	ATALK NDIS REQUEST
//	Used to store completion routine information for NDIS requests.

typedef struct _ATALK_NDIS_REQ
{
	NDIS_REQUEST					nr_Request;
	REQ_COMPLETION					nr_RequestCompletion;
	PVOID							nr_Ctx;
	KEVENT							nr_Event;
	NDIS_STATUS		 				nr_RequestStatus;
	BOOLEAN							nr_Sync;

} ATALK_NDIS_REQ, *PATALK_NDIS_REQ;


#define GET_PORT_TYPE(medium) \
			((medium == NdisMedium802_3) ? ELAP_PORT :\
			((medium == NdisMediumFddi)	? FDDI_PORT :\
			((medium == NdisMedium802_5) ? TLAP_PORT :\
			((medium == NdisMediumLocalTalk) ? ALAP_PORT : \
			((medium == NdisMediumWan) ? ARAP_PORT : \
			0)))))


//	Handlers for the different port types.
typedef struct _PORT_HANDLERS
{
	ADDMULTICASTADDR	ph_AddMulticastAddr;
	REMOVEMULTICASTADDR	ph_RemoveMulticastAddr;
	BYTE				ph_BroadcastAddr[MAX_HW_ADDR_LEN];
	USHORT				ph_BroadcastAddrLen;
	USHORT				ph_AarpHardwareType;
	USHORT				ph_AarpProtocolType;
} PORT_HANDLERS, *PPORT_HANDLERS;


typedef enum
{
    AT_PNP_SWITCH_ROUTING=0,
    AT_PNP_SWITCH_DEFAULT_ADAPTER,
    AT_PNP_RECONFIGURE_PARMS

} ATALK_PNP_MSGTYPE;

typedef struct _ATALK_PNP_EVENT
{
    ATALK_PNP_MSGTYPE   PnpMessage;
} ATALK_PNP_EVENT, *PATALK_PNP_EVENT;

//	MACROS for building/verifying 802.2 headers
#define	ATALK_VERIFY8022_HDR(pPkt, PktLen, Protocol, Result)				\
		{																	\
			Result = TRUE;													\
			if ((PktLen >= (IEEE8022_PROTO_OFFSET+IEEE8022_PROTO_TYPE_LEN))	&&	\
				(*(pPkt + IEEE8022_DSAP_OFFSET)	== SNAP_SAP)		&&		\
				(*(pPkt + IEEE8022_SSAP_OFFSET)	== SNAP_SAP)		&&		\
				(*(pPkt + IEEE8022_CONTROL_OFFSET)== UNNUMBERED_INFO))		\
			{																\
				if (!memcmp(pPkt + IEEE8022_PROTO_OFFSET,					\
						   AtalkAppletalkProtocolType,						\
						   IEEE8022_PROTO_TYPE_LEN))						\
				{															\
					Protocol = APPLETALK_PROTOCOL;							\
				}															\
				else if (!memcmp(pPkt + IEEE8022_PROTO_OFFSET,				\
								 AtalkAarpProtocolType,						\
								 IEEE8022_PROTO_TYPE_LEN))					\
				{															\
					Protocol = AARP_PROTOCOL;								\
				}															\
				else														\
				{															\
					Result	= FALSE;										\
				}															\
			}																\
			else															\
			{																\
				Result	= FALSE;											\
			}																\
		}


#define	ATALK_BUILD8022_HDR(Packet,	Protocol)									\
		{																		\
			PUTBYTE2BYTE(														\
				Packet + IEEE8022_DSAP_OFFSET,									\
				SNAP_SAP);														\
																				\
			PUTBYTE2BYTE(														\
				Packet + IEEE8022_SSAP_OFFSET,									\
				SNAP_SAP);														\
																				\
			PUTBYTE2BYTE(														\
				Packet + IEEE8022_CONTROL_OFFSET,								\
				UNNUMBERED_INFO);												\
																				\
			RtlCopyMemory(														\
				Packet + IEEE8022_PROTO_OFFSET,									\
				((Protocol == APPLETALK_PROTOCOL) ?								\
						AtalkAppletalkProtocolType : AtalkAarpProtocolType),	\
				IEEE8022_PROTO_TYPE_LEN);										\
		}																		
																				


//	Allocating and freeing send buffers
#define	AtalkNdisAllocBuf(_ppBuffDesc)										\
		{																		\
			PSENDBUF		_pSendBuf;											\
																				\
			_pSendBuf = AtalkBPAllocBlock(BLKID_SENDBUF);						\
			if ((_pSendBuf) != NULL)											\
			{																	\
				*(_ppBuffDesc) = &(_pSendBuf)->sb_BuffDesc;						\
				(_pSendBuf)->sb_BuffDesc.bd_Next = NULL;						\
				(_pSendBuf)->sb_BuffDesc.bd_Length = MAX_SENDBUF_LEN;			\
				(_pSendBuf)->sb_BuffDesc.bd_Flags  = BD_CHAR_BUFFER;			\
				(_pSendBuf)->sb_BuffDesc.bd_CharBuffer= (_pSendBuf)->sb_Space;	\
				(_pSendBuf)->sb_BuffDesc.bd_FreeBuffer= NULL;					\
			}																	\
			else																\
			{																	\
				*(_ppBuffDesc)	= NULL;											\
																				\
				DBGPRINT(DBG_COMP_NDISSEND, DBG_LEVEL_ERR,						\
						("AtalkNdisAllocBuf: AtalkBPAllocBlock failed\n"));	\
																				\
				LOG_ERROR(EVENT_ATALK_NDISRESOURCES,							\
						  NDIS_STATUS_RESOURCES,								\
						  NULL,													\
						  0);													\
			}																	\
		}																		
																				
#define	AtalkNdisFreeBuf(_pBuffDesc)											\
		{																		\
			PSENDBUF	_pSendBuf;												\
																				\
			ASSERT(VALID_BUFFDESC(_pBuffDesc));									\
			_pSendBuf = (PSENDBUF)((PBYTE)(_pBuffDesc) - sizeof(BUFFER_HDR));	\
			NdisAdjustBufferLength(												\
				(_pSendBuf)->sb_BuffHdr.bh_NdisBuffer,							\
				MAX_SENDBUF_LEN);												\
			AtalkBPFreeBlock((_pSendBuf));										\
		}																		


#define	ArapNdisFreeBuf(_pMnpSendBuf)											\
		{																		\
            PBUFFER_DESC    _pBufDes;                                           \
            _pBufDes = &_pMnpSendBuf->sb_BuffDesc;                              \
                                                                                \
	        DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_INFO,   					        \
		        ("ArapNdisFreeBuf: freeing %lx  NdisPkt=%lx\n",                 \
                    _pMnpSendBuf,_pMnpSendBuf->sb_BuffHdr.bh_NdisPkt));	        \
                                                                                \
			NdisAdjustBufferLength(												\
				(_pMnpSendBuf)->sb_BuffHdr.bh_NdisBuffer,						\
				(_pBufDes)->bd_Length);							                \
                                                                                \
			AtalkBPFreeBlock((_pMnpSendBuf));									\
		}																		


//	Exported Prototypes
ATALK_ERROR
AtalkInitNdisQueryAddrInfo(
	IN	PPORT_DESCRIPTOR			pPortDesc
);

ATALK_ERROR
AtalkInitNdisStartPacketReception(
	IN	PPORT_DESCRIPTOR			pPortDesc
);

ATALK_ERROR
AtalkInitNdisSetLookaheadSize(
	IN	PPORT_DESCRIPTOR			pPortDesc,
	IN	INT							LookaheadSize
);

ATALK_ERROR
AtalkNdisReplaceMulticast(
	IN  PPORT_DESCRIPTOR		pPortDesc,
	IN  PBYTE					OldAddress,
	IN  PBYTE					NewAddress
	);

ATALK_ERROR
AtalkNdisAddMulticast(
	IN	PPORT_DESCRIPTOR			pPortDesc,
	IN	PBYTE						Address,
	IN	BOOLEAN						ExecuteSynchronously,
	IN	REQ_COMPLETION				AddCompletion,
	IN	PVOID						AddContext
);

ATALK_ERROR
AtalkNdisRemoveMulticast(
	IN	PPORT_DESCRIPTOR			pPortDesc,
	IN	PBYTE						Address,
	IN	BOOLEAN						ExecuteSynchronously,
	IN	REQ_COMPLETION				RemoveCompletion,
	IN	PVOID						RemoveContext
);

ATALK_ERROR
AtalkNdisSendPacket(
	IN	PPORT_DESCRIPTOR			pPortDesc,
	IN	PBUFFER_DESC				BufferChain,
	IN	SEND_COMPLETION				SendCompletion	OPTIONAL,
	IN	PSEND_COMPL_INFO			pSendInfo		OPTIONAL
);

ATALK_ERROR
AtalkNdisAddFunctional(
	IN	PPORT_DESCRIPTOR			pPortDesc,
	IN	PUCHAR						Address,
	IN	BOOLEAN						ExecuteSynchronously,
	IN	REQ_COMPLETION				AddCompletion,
	IN	PVOID						AddContext
);

ATALK_ERROR
AtalkNdisRemoveFunctional(
	IN	PPORT_DESCRIPTOR			pPortDesc,
	IN	PUCHAR						Address,
	IN	BOOLEAN						ExecuteSynchronously,
	IN	REQ_COMPLETION				RemoveCompletion,
	IN	PVOID						RemoveContext
);

USHORT
AtalkNdisBuildEthHdr(
	IN		PUCHAR					PortAddr,			// 802 address of port
	IN 		PBYTE					pLinkHdr,			// Start of link header
	IN		PBYTE					pDestHwOrMcastAddr,	// Destination or multicast addr
	IN		LOGICAL_PROTOCOL		Protocol,			// Logical protocol
	IN		USHORT					ActualDataLen		// Length for ethernet packets
);

USHORT
AtalkNdisBuildTRHdr(
	IN		PUCHAR					PortAddr,			// 802 address of port
	IN 		PBYTE					pLinkHdr,			// Start of link header
	IN		PBYTE					pDestHwOrMcastAddr,	// Destination or multicast addr
	IN		LOGICAL_PROTOCOL		Protocol,			// Logical protocol
	IN		PBYTE					pRouteInfo,			// Routing info for tokenring
	IN		USHORT					RouteInfoLen		// Length of above
);

USHORT
AtalkNdisBuildFDDIHdr(
	IN		PUCHAR					PortAddr,			// 802 address of port
	IN 		PBYTE					pLinkHdr,			// Start of link header
	IN		PBYTE					pDestHwOrMcastAddr,	// Destination or multicast addr
	IN		LOGICAL_PROTOCOL		Protocol			// Logical protocol
);

USHORT
AtalkNdisBuildLTHdr(
	IN 		PBYTE					pLinkHdr,			// Start of link header
	IN		PBYTE					pDestHwOrMcastAddr,	// Destination or multicast addr
	IN		BYTE					AlapSrc,			// Localtalk source node
	IN		BYTE					AlapType			// Localtalk ddp header type
);


#define AtalkNdisBuildARAPHdr(_pLnkHdr, _pConn)             \
    RtlCopyMemory(_pLnkHdr, _pConn->NdiswanHeader, WAN_LINKHDR_LEN)

#define AtalkNdisBuildPPPPHdr(_pLnkHdr, _pConn)             \
    RtlCopyMemory(_pLnkHdr, _pConn->NdiswanHeader, WAN_LINKHDR_LEN)

#define	AtalkNdisBuildHdr(pPortDesc,						\
						  pLinkHdr,							\
						  linkLen,							\
						  ActualDataLen,					\
						  pDestHwOrMcastAddr,				\
						  pRouteInfo,						\
						  RouteInfoLen,						\
						  Protocol)							\
	{														\
		switch (pPortDesc->pd_NdisPortType)					\
		{													\
		  case NdisMedium802_3:								\
			linkLen = AtalkNdisBuildEthHdr(					\
								(pPortDesc)->pd_PortAddr,	\
								pLinkHdr,					\
								pDestHwOrMcastAddr,			\
								Protocol,					\
								ActualDataLen);				\
			break;											\
															\
		  case NdisMedium802_5:								\
			linkLen = AtalkNdisBuildTRHdr(					\
								(pPortDesc)->pd_PortAddr,	\
								pLinkHdr,					\
								pDestHwOrMcastAddr,			\
								Protocol,					\
								pRouteInfo,					\
								RouteInfoLen);				\
			break;											\
															\
		  case NdisMediumFddi:								\
			linkLen = AtalkNdisBuildFDDIHdr(				\
								(pPortDesc)->pd_PortAddr,	\
								pLinkHdr,					\
								pDestHwOrMcastAddr,			\
								Protocol);					\
			break;											\
															\
		  case NdisMediumLocalTalk:							\
			ASSERTMSG("AtalkNdisBuildHdr called for LT\n", 0);	\
			break;											\
															\
		  default:											\
			ASSERT (0);										\
			KeBugCheck(0);									\
			break;											\
		}													\
	}

VOID
AtalkNdisSendTokRingTestRespComplete(
	IN	NDIS_STATUS					Status,
	IN	PBUFFER_DESC				pBuffDesc,
	IN	PSEND_COMPL_INFO			pInfo	OPTIONAL);

VOID
AtalkNdisSendTokRingTestResp(
	IN		PPORT_DESCRIPTOR		pPortDesc,
	IN		PBYTE					HdrBuf,
	IN		UINT					HdrBufSize,
	IN		PBYTE					LkBuf,
	IN		UINT					LkBufSize,
	IN		UINT					pPktSize);

//	PORT HANDLERS
//	
extern	PORT_HANDLERS	AtalkPortHandlers[LAST_PORTTYPE];

//	Exported Prototypes

ATALK_ERROR
AtalkNdisInitRegisterProtocol(
	VOID
);

VOID
AtalkNdisDeregisterProtocol(
	VOID
);

VOID
AtalkNdisReleaseResources(
	VOID
);

NDIS_STATUS
AtalkNdisInitBind(
	IN	PPORT_DESCRIPTOR			pPortDesc
);

VOID
AtalkNdisUnbind(
	IN	PPORT_DESCRIPTOR		pPortDesc
);

NDIS_STATUS
AtalkNdisSubmitRequest(
	PPORT_DESCRIPTOR			pPortDesc,
	PNDIS_REQUEST				Request,
	BOOLEAN						ExecuteSync,
	REQ_COMPLETION				CompletionRoutine,
	PVOID						Ctx
);

VOID
AtalkOpenAdapterComplete(
	IN	NDIS_HANDLE				NdisBindCtx,
	IN	NDIS_STATUS				Status,
	IN	NDIS_STATUS				OpenErrorStatus
);

VOID
AtalkCloseAdapterComplete(
	IN	NDIS_HANDLE				NdisBindCtx,
	IN	NDIS_STATUS				Status
);

VOID
AtalkResetComplete(
	IN	NDIS_HANDLE				NdisBindCtx,
	IN	NDIS_STATUS				Status
);

VOID
AtalkRequestComplete(
	IN	NDIS_HANDLE				NdisBindCtx,
	IN	PNDIS_REQUEST			NdisRequest,
	IN	NDIS_STATUS				Status
);

VOID
AtalkStatusIndication (
	IN	NDIS_HANDLE				NdisBindCtx,
	IN	NDIS_STATUS				GeneralStatus,
	IN	PVOID					StatusBuf,
	IN	UINT					StatusBufLen
);

VOID
AtalkStatusComplete (
	IN	NDIS_HANDLE				ProtoBindCtx
);

VOID
AtalkReceiveComplete (
	IN	NDIS_HANDLE 			BindingCtx
);

VOID
AtalkTransferDataComplete(
	IN	NDIS_HANDLE				BindingCtx,
	IN	PNDIS_PACKET			NdisPkt,
	IN	NDIS_STATUS				Status,
	IN	UINT					BytesTransferred
);

NDIS_STATUS
AtalkReceiveIndication(
	IN	NDIS_HANDLE				BindingCtx,
	IN	NDIS_HANDLE				ReceiveCtx,
	IN	PVOID	   				HdrBuf,
	IN	UINT					HdrBufSize,
	IN	PVOID					LkBuf,
	IN	UINT					LkBufSize,
	IN	UINT					PktSize
);

ATALK_ERROR
ArapAdapterInit(
	IN OUT PPORT_DESCRIPTOR	pPortDesc
);

VOID
AtalkSendComplete(
	IN	NDIS_HANDLE				ProtoBindCtx,
	IN	PNDIS_PACKET			NdisPkt,
	IN	NDIS_STATUS				NdisStatus
);


VOID
AtalkBindAdapter(
	OUT PNDIS_STATUS Status,
	IN	NDIS_HANDLE	 BindContext,
	IN	PNDIS_STRING DeviceName,
	IN	PVOID		 SystemSpecific1,
	IN	PVOID		 SystemSpecific2
);

VOID
AtalkUnbindAdapter(
	OUT PNDIS_STATUS Status,
	IN	NDIS_HANDLE ProtocolBindingContext,
	IN	NDIS_HANDLE	UnbindContext
	);

NDIS_STATUS
AtalkPnPHandler(
    IN  NDIS_HANDLE    NdisBindCtx,
    IN  PNET_PNP_EVENT NetPnPEvent
);


NDIS_STATUS
AtalkPnPReconfigure(
    IN  NDIS_HANDLE    NdisBindCtx,
    IN  PNET_PNP_EVENT NetPnPEvent
);


NTSTATUS
AtalkPnPDisableAdapter(
	IN	PPORT_DESCRIPTOR	pPortDesc
);


NTSTATUS
AtalkPnPEnableAdapter(
	IN	PPORT_DESCRIPTOR	pPortDesc
);


PPORT_DESCRIPTOR
AtalkFindDefaultPort(
    IN  VOID
);

//	Receive indication copy macro. This accomodates shared memory copies.
#define	ATALK_RECV_INDICATION_COPY(_pPortDesc, _pDest, _pSrc, _Len)		\
	{																	\
		TdiCopyLookaheadData(_pDest,									\
							 _pSrc,										\
							 _Len,										\
							 ((_pPortDesc)->pd_MacOptions & NDIS_MAC_OPTION_COPY_LOOKAHEAD_DATA) ? \
									TDI_RECEIVE_COPY_LOOKAHEAD : 0);	\
	}

LOCAL NDIS_STATUS
atalkNdisInitInitializeResources(
	VOID
);


#endif	// _ATKNDIS_


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\atalk\sys\atkstat.h ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	atkstat.h

Abstract:

	This file defines the statistics structure used whene PROFILING is turned on

Author:

	Jameel Hyder (microsoft!jameelh)
	Nikhil Kamkolkar (microsoft!nikhilk)


Revision History:
	10 Mar 1993             Initial Version

Notes:  Tab stop: 4
--*/


#ifndef _ATKSTAT_
#define _ATKSTAT_

#define	MAX_PORTNAME_LEN	        32
#define MAX_INTERNAL_PORTNAME_LEN   64

extern	ATALK_SPIN_LOCK		AtalkStatsLock;
#if	DBG
extern	LONG				AtalkMemLimit;
#endif

// NOTE: This structure should be sized 8*N so that the array of them have all
//		 LARGE_INTEGERs aligned
typedef	struct _AtalkPortStatistics
{
	LARGE_INTEGER		prtst_DataIn;
	LARGE_INTEGER		prtst_DataOut;
	LARGE_INTEGER		prtst_DdpPacketInProcessTime;
	LARGE_INTEGER		prtst_AarpPacketInProcessTime;
	LARGE_INTEGER		prtst_NbpPacketInProcessTime;
	LARGE_INTEGER		prtst_ZipPacketInProcessTime;
	LARGE_INTEGER		prtst_RtmpPacketInProcessTime;

#ifdef	PROFILING
	LARGE_INTEGER		prtst_RcvIndProcessTime;
	LARGE_INTEGER		prtst_RcvCompProcessTime;
	ULONG				prtst_RcvIndCount;
	ULONG				prtst_RcvCompCount;
	ULONG				prtst_CurReceiveQueue;
	ULONG				prtst_CurSendsOutstanding;
#endif

	ULONG				prtst_NumPacketsIn;
	ULONG				prtst_NumPacketsOut;
	ULONG				prtst_NumDdpPacketsIn;
	ULONG				prtst_NumAarpProbesOut;
	ULONG				prtst_NumAarpPacketsIn;
	ULONG				prtst_NumNbpPacketsIn;
	ULONG				prtst_NumZipPacketsIn;
	ULONG				prtst_NumRtmpPacketsIn;

	//	Routing information
	ULONG				prtst_NumPktRoutedIn;
	ULONG				prtst_NumPktRoutedOut;

	//	Keep track of how many packets were dropped.
	ULONG				prtst_NumPktDropped;
	ULONG				prtst_Dummy;				// Keep the size 8*N for alignment

	// Port name for use by perfmon
	WCHAR				prtst_PortName[MAX_INTERNAL_PORTNAME_LEN];
} ATALK_PORT_STATS, *PATALK_PORT_STATS;

typedef struct _AtalkStatistics
{
	LARGE_INTEGER		stat_PerfFreq;
	LARGE_INTEGER		stat_AtpPacketInProcessTime;
#ifdef	PROFILING
	LARGE_INTEGER		stat_AtpIndicationProcessTime;
	LARGE_INTEGER		stat_AtpReqHndlrProcessTime;
	LARGE_INTEGER		stat_AtpReqTimerProcessTime;
	LARGE_INTEGER		stat_AtpRelTimerProcessTime;
	LARGE_INTEGER		stat_AspSmtProcessTime;
	LARGE_INTEGER		stat_ExAllocPoolTime;
	LARGE_INTEGER		stat_ExFreePoolTime;
	LARGE_INTEGER		stat_BPAllocTime;
	LARGE_INTEGER		stat_BPFreeTime;
	ULONG				stat_AtpNumIndications;
	ULONG				stat_AtpNumRequests;
	ULONG				stat_AtpNumReqTimer;
	ULONG				stat_AtpNumRelTimer;
	ULONG				stat_AtpNumReqHndlr;
	ULONG				stat_TotalAspSessions;
	ULONG				stat_AspSessionsDropped;
	ULONG				stat_AspSessionsClosed;
	ULONG				stat_AspSmtCount;
	ULONG				stat_MaxAspSessions;
	ULONG				stat_CurAspSessions;
	ULONG				stat_LastAspRTT;
	ULONG				stat_MaxAspRTT;
	ULONG				stat_LastPapRTT;
	ULONG				stat_MaxPapRTT;
	ULONG				stat_CurAllocCount;
	ULONG				stat_CurMdlCount;
	ULONG				stat_ExAllocPoolCount;
	ULONG				stat_ExFreePoolCount;
	ULONG				stat_BPAllocCount;
	ULONG				stat_BPFreeCount;
	ULONG				stat_NumBPHits;
	ULONG				stat_NumBPMisses;
	ULONG				stat_NumBPAge;
	ULONG				stat_ElapsedTime;
#endif
	ULONG				stat_AtpNumPackets;
	ULONG				stat_AtpNumLocalRetries;
	ULONG				stat_AtpNumRemoteRetries;
	ULONG				stat_AtpNumXoResponse;
	ULONG				stat_AtpNumAloResponse;
	ULONG				stat_AtpNumRecdRelease;
	ULONG				stat_AtpNumRespTimeout;
	ULONG				stat_CurAllocSize;
	ULONG				stat_NumActivePorts;
	ULONG				stat_Dummy;				// Keep the size 8*N for alignment
} ATALK_STATS, *PATALK_STATS;

extern	ATALK_STATS			AtalkStatistics;

#endif	// _ATKSTAT_


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\atalk\sys\atktdi.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

	atktdi.c

Abstract:

	This module contains the code providing the tdi interface.

Author:

	Jameel Hyder (jameelh@microsoft.com)
	Nikhil Kamkolkar (nikhilk@microsoft.com)

Revision History:
	19 Jun 1992		Initial Version

Notes:	Tab stop: 4
--*/

#include <atalk.h>
#pragma hdrstop
#define	FILENUM		ATKTDI

#ifdef	ALLOC_PRAGMA
#pragma alloc_text(INIT, AtalkLockInit)
#pragma alloc_text(PAGE, AtalkTdiOpenAddress)
#pragma alloc_text(PAGE, AtalkTdiOpenConnection)
//#pragma alloc_text(PAGE, AtalkTdiOpenControlChannel)
#pragma alloc_text(PAGE, AtalkTdiAction)
#pragma alloc_text(PAGE, atalkQueuedLockUnlock)
#pragma alloc_text(PAGE_TDI, AtalkTdiCleanupAddress)
#pragma alloc_text(PAGE_TDI, AtalkTdiCleanupConnection)
#pragma alloc_text(PAGE_TDI, AtalkTdiCloseAddress)
#pragma alloc_text(PAGE_TDI, AtalkTdiCloseConnection)
#pragma alloc_text(PAGE_TDI, AtalkTdiCloseControlChannel)
#pragma alloc_text(PAGE_TDI, AtalkTdiAssociateAddress)
#pragma alloc_text(PAGE_TDI, AtalkTdiDisassociateAddress)
#pragma alloc_text(PAGE_TDI, AtalkTdiConnect)
#pragma alloc_text(PAGE_TDI, AtalkTdiDisconnect)
#pragma alloc_text(PAGE_TDI, AtalkTdiAccept)
#pragma alloc_text(PAGE_TDI, AtalkTdiListen)
#pragma alloc_text(PAGE_TDI, AtalkTdiSend)
#pragma alloc_text(PAGE_TDI, AtalkTdiSendDgram)
#pragma alloc_text(PAGE_TDI, AtalkTdiReceive)
#pragma alloc_text(PAGE_TDI, AtalkTdiReceiveDgram)
#pragma alloc_text(PAGE_TDI, AtalkTdiQueryInformation)
#pragma alloc_text(PAGE_TDI, AtalkTdiSetInformation)
#pragma alloc_text(PAGE_TDI, AtalkTdiSetEventHandler)
#pragma alloc_text(PAGE_TDI, AtalkTdiCancel)
#pragma alloc_text(PAGE_TDI, AtalkQueryInitProviderInfo)
#pragma alloc_text(PAGE_TDI, atalkTdiActionComplete)
#pragma alloc_text(PAGE_TDI, atalkTdiGenericComplete)
#pragma alloc_text(PAGE_TDI, atalkTdiGenericReadComplete)
#pragma alloc_text(PAGE_TDI, atalkTdiGenericWriteComplete)
#endif

// Primary TDI Functions for appletalk stack

NTSTATUS
AtalkTdiOpenAddress(
	IN		PIRP					pIrp,
	IN		PIO_STACK_LOCATION		pIrpSp,
	IN		PTA_APPLETALK_ADDRESS	pTdiAddr,
	IN		BYTE					ProtoType,
	IN		BYTE					SocketType,
	IN OUT	PATALK_DEV_CTX			pCtx
	)
/*++

Routine Description:

	This routine is used to create an address object. It will also the
	create the appropriate socket with the portable stack.

Arguments:


Return Value:

	STATUS_SUCCESS if address was successfully opened
	Error otherwise.

--*/
{
	PVOID			FsContext;
	ATALK_ADDR		atalkAddr;
	ATALK_ERROR		error;

	do
	{
		atalkWaitDefaultPort();
		// We honor only if count/type and length are as we expect. And only if the
		// default port is valid.
		if ((AtalkDefaultPort == NULL)												||
            (AtalkDefaultPort->pd_Flags & PD_PNP_RECONFIGURE)                       ||
			(pTdiAddr->TAAddressCount != 1)											||
			(pTdiAddr->Address[0].AddressLength < sizeof(TDI_ADDRESS_APPLETALK))	||
			(pTdiAddr->Address[0].AddressType != TDI_ADDRESS_TYPE_APPLETALK))
		{
			DBGPRINT(DBG_COMP_TDI, DBG_LEVEL_ERR,
				("AtalkTdiOpenAddress: returning STATUS_INVALID_ADDRESS (%lx)\n",AtalkDefaultPort));

			error = ATALK_NEW_SOCKET; // maps to STATUS_INVALID_ADDRESS
			break;
		}

		TDI_TO_ATALKADDR(&atalkAddr, pTdiAddr);

		// Now depending on the requested device...
		switch (pCtx->adc_DevType)
		{
		  case ATALK_DEV_DDP:
			error = AtalkDdpOpenAddress(AtalkDefaultPort,
										atalkAddr.ata_Socket,
										NULL,					// Desired node (any node)
										NULL,					// NULL Socket Handler
										NULL,					// Context for handler
										ProtoType,
										pCtx,
										(PDDP_ADDROBJ *)(&FsContext));
			break;

		  case ATALK_DEV_ASPC:
			AtalkLockAspCIfNecessary();
			error = AtalkAspCCreateAddress(pCtx, (PASPC_ADDROBJ *)(&FsContext));
			break;

		  case ATALK_DEV_ASP:
			AtalkLockAspIfNecessary();
			error = AtalkAspCreateAddress((PASP_ADDROBJ *)(&FsContext));
			break;

		  case ATALK_DEV_PAP:
			AtalkLockPapIfNecessary();
			error = AtalkPapCreateAddress(pCtx, (PPAP_ADDROBJ *)(&FsContext));
			break;

		  case ATALK_DEV_ADSP:
			AtalkLockAdspIfNecessary();
			error = AtalkAdspCreateAddress(pCtx,
										   SocketType,
										   (PADSP_ADDROBJ *)(&FsContext));
			break;

		  default:
			// The device type in the Ctx field can never be anything
			// other than the above! Internal protocol error. KeBugCheck.
            error = ATALK_INVALID_REQUEST;
			DBGPRINT(DBG_COMP_TDI, DBG_LEVEL_ERR,
					("AtalkTdiOpenAddress: Invalid device type\n"));
			break;
		}

		if (ATALK_SUCCESS(error))
		{
			pIrpSp->FileObject->FsContext2 =
				(PVOID)((ULONG_PTR)(TDI_TRANSPORT_ADDRESS_FILE + (pCtx->adc_DevType << 16)));

			pIrpSp->FileObject->FsContext = FsContext;
			AtalkLockTdiIfNecessary();
		}
	} while (FALSE);

	return AtalkErrorToNtStatus(error);
}




NTSTATUS
AtalkTdiOpenConnection(
	IN		PIRP					pIrp,
	IN		PIO_STACK_LOCATION		pIrpSp,
	IN		CONNECTION_CONTEXT		ConnCtx,
	IN OUT	PATALK_DEV_CTX			pCtx
	)
/*++

Routine Description:

	This routine is used to create a connection object and associate the
	passed ConnectionContext with it.

Arguments:

	ConnectionContext - The TDI ConnectionContext to be associated with object
	Context - The DeviceContext of the device on which open is happening

Return Value:

	STATUS_SUCCESS if connection was successfully opened
	Error otherwise.

--*/
{
	ATALK_ERROR	error = ATALK_INVALID_REQUEST;
	PVOID		FsContext;

	if ((pCtx->adc_DevType == ATALK_DEV_PAP) ||
		(pCtx->adc_DevType == ATALK_DEV_ADSP)||
		(pCtx->adc_DevType == ATALK_DEV_ASPC))
	do
	{
		atalkWaitDefaultPort();
		// Only if the default port is valid.
		if (AtalkDefaultPort == NULL)
		{
			DBGPRINT(DBG_COMP_TDI, DBG_LEVEL_ERR,
				("AtalkTdiOpenConnection: returning STATUS_INVALID_ADDRESS\n"));

			error = ATALK_NEW_SOCKET; // maps to STATUS_INVALID_ADDRESS
			break;
		}

		// Now depending on the requested device...
		switch (pCtx->adc_DevType)
		{
		  case ATALK_DEV_PAP:
			AtalkLockPapIfNecessary();
			error = AtalkPapCreateConnection(ConnCtx,
											 pCtx,
											 (PPAP_CONNOBJ *)(&FsContext));
			break;

		  case ATALK_DEV_ADSP:
			AtalkLockAdspIfNecessary();
			error = AtalkAdspCreateConnection(ConnCtx,
											  pCtx,
											  (PADSP_CONNOBJ *)(&FsContext));
			break;

		  case ATALK_DEV_ASPC:
			AtalkLockAspCIfNecessary();
			error = AtalkAspCCreateConnection(ConnCtx,
											  pCtx,
											  (PASPC_CONNOBJ *)(&FsContext));
			break;
		}

		if (ATALK_SUCCESS(error))
		{
			pIrpSp->FileObject->FsContext2 = (PVOID)((ULONG_PTR)(TDI_CONNECTION_FILE +
													 (pCtx->adc_DevType << 16)));
			pIrpSp->FileObject->FsContext = FsContext;
			AtalkLockTdiIfNecessary();
		}
		
		ASSERT(error == ATALK_NO_ERROR);

	} while (FALSE);

	return AtalkErrorToNtStatus(error);
}




NTSTATUS
AtalkTdiOpenControlChannel(
	IN		PIRP					pIrp,
	IN		PIO_STACK_LOCATION		pIrpSp,
	IN OUT	PATALK_DEV_CTX			pCtx
	)
/*++

Routine Description:

	This routine is used to create a control channel

Arguments:

	Context - The DeviceContext of the device on which open is happening

Return Value:

	STATUS_SUCCESS if controlchannel was successfully opened
	Error otherwise.

--*/
{
	PDDP_ADDROBJ	pDdpAddr;
	ATALK_ERROR		error = ATALK_INVALID_REQUEST;
    KIRQL           OldIrql;

	do
	{
		if (pCtx->adc_DevType != ATALK_DEV_ARAP)
		{
			atalkWaitDefaultPort();
			// Only if the default port is valid.
			if (AtalkDefaultPort == NULL)
			{
				DBGPRINT(DBG_COMP_TDI, DBG_LEVEL_ERR,
						("AtalkTdiOpenControlChannel: NOT ATALK_DEV_ARAP: returning STATUS_INVALID_ADDRESS\n"));
				if (!AtalkNoDefPortPrinted)
				{
					LOG_ERROR(EVENT_ATALK_NO_DEFAULTPORT, 0, NULL, 0);
					AtalkNoDefPortPrinted = TRUE;
				}

				error = ATALK_NEW_SOCKET; // maps to STATUS_INVALID_ADDRESS
				break;
			}
        }

		// Now depending on the requested device...
		switch (pCtx->adc_DevType)
		{
		  case ATALK_DEV_DDP:
		  case ATALK_DEV_ASP:
		  case ATALK_DEV_PAP:
		  case ATALK_DEV_ADSP:
          case ATALK_DEV_ASPC:

			error = AtalkDdpOpenAddress(AtalkDefaultPort,
										UNKNOWN_SOCKET,
										NULL,
										NULL,
										NULL,
										0,
										pCtx,
										&pDdpAddr);
			break;

          case ATALK_DEV_ARAP:

            if (AtalkDefaultPort == NULL)
            {
			    DBGPRINT(DBG_COMP_TDI, DBG_LEVEL_ERR,
				    ("AtalkTdiOpenControlChannel: device is ATALK_DEV_ARAP: returning STATUS_INVALID_ADDRESS\n"));
				if (!AtalkNoDefPortPrinted)
				{
					LOG_ERROR(EVENT_ATALK_NO_DEFAULTPORT, 0, NULL, 0);
					AtalkNoDefPortPrinted = TRUE;
				}
                error = ATALK_NEW_SOCKET; // maps to STATUS_INVALID_ADDRESS
                break;
            }

			DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,("RAS device opened\n"));

#if DBG
            KeQuerySystemTime(&ArapDbgLastTraceTime);
#endif
            error = ATALK_NO_ERROR;
            break;

		  default:
			// The device type in the Ctx field can never be anything
			// other than the above! Internal protocol error. KeBugCheck.
			DBGPRINT(DBG_COMP_TDI, DBG_LEVEL_ERR,
					("AtalkTdiOpenControlChannel: Invalid device type\n"));
			break;
		}

		if (ATALK_SUCCESS(error))
		{
			pIrpSp->FileObject->FsContext2 =
					(PVOID)((ULONG_PTR)(TDI_CONTROL_CHANNEL_FILE + (pCtx->adc_DevType << 16)));
			pIrpSp->FileObject->FsContext = pDdpAddr;
			AtalkLockTdiIfNecessary();
		}
		else
		{
			DBGPRINT(DBG_COMP_TDI, DBG_LEVEL_ERR,
					("AtalkTdiOpenControlChannel: Failed %ld\n", error));
		}
	} while (FALSE);

	return AtalkErrorToNtStatus(error);
}




NTSTATUS
AtalkTdiCleanupAddress(
	IN		PIRP					pIrp,
	IN		PIO_STACK_LOCATION		pIrpSp,
	IN OUT	PATALK_DEV_CTX			pCtx
	)
/*++

Routine Description:

	This routine removes the creation reference on the object. It also
	sets up the closepIrp for completion.

Arguments:

	pIrp - The close irp
	Context - The DeviceContext of the device on which close is happening

Return Value:

	STATUS_SUCCESS if successfully setup
	Error otherwise.

--*/
{
	ATALK_ERROR	error;
	PVOID		pAddrObj = pIrpSp->FileObject->FsContext;

	do
	{
		// Now depending on the requested device...
		switch (pCtx->adc_DevType)
		{
		  case ATALK_DEV_DDP:
			if (!(VALID_DDP_ADDROBJ(((PDDP_ADDROBJ)pAddrObj))))
            {
                ASSERT(0);
                error = ATALK_INVALID_ADDRESS;
                break;
            }
			AtalkDdpReferenceByPtr(((PDDP_ADDROBJ)pAddrObj), &error);
			if (ATALK_SUCCESS(error))
			{
				AtalkDdpCleanupAddress((PDDP_ADDROBJ)pAddrObj);
				AtalkDdpDereference(((PDDP_ADDROBJ)pAddrObj));
			}
			break;

		  case ATALK_DEV_ASPC:
			if (!(VALID_ASPCAO((PASPC_ADDROBJ)pAddrObj)))
            {
                ASSERT(0);
                error = ATALK_INVALID_ADDRESS;
                break;
            }
            AtalkLockAspCIfNecessary();
			AtalkAspCAddrReference((PASPC_ADDROBJ)pAddrObj, &error);
			if (ATALK_SUCCESS(error))
			{
				AtalkAspCCleanupAddress((PASPC_ADDROBJ)pAddrObj);
				AtalkAspCAddrDereference((PASPC_ADDROBJ)pAddrObj);
			}
            AtalkUnlockAspCIfNecessary();
			break;

		  case ATALK_DEV_ASP:
			error = ATALK_NO_ERROR;
			break;

		  case ATALK_DEV_PAP:
			if (!(VALID_PAPAO((PPAP_ADDROBJ)pAddrObj)))
            {
                ASSERT(0);
                error = ATALK_INVALID_ADDRESS;
                break;
            }
            AtalkLockPapIfNecessary();
			AtalkPapAddrReference((PPAP_ADDROBJ)pAddrObj, &error);
			if (ATALK_SUCCESS(error))
			{
				AtalkPapCleanupAddress((PPAP_ADDROBJ)pAddrObj);
				AtalkPapAddrDereference((PPAP_ADDROBJ)pAddrObj);
			}
            AtalkUnlockPapIfNecessary();
			break;

		  case ATALK_DEV_ADSP:
			if (!(VALID_ADSPAO((PADSP_ADDROBJ)pAddrObj)))
            {
                ASSERT(0);
                error = ATALK_INVALID_ADDRESS;
                break;
            }
            AtalkLockAdspIfNecessary();
			AtalkAdspAddrReference((PADSP_ADDROBJ)pAddrObj, &error);
			if (ATALK_SUCCESS(error))
			{
				AtalkAdspCleanupAddress((PADSP_ADDROBJ)pAddrObj);
				AtalkAdspAddrDereference((PADSP_ADDROBJ)pAddrObj);
			}
            AtalkUnlockAdspIfNecessary();
			break;

		  default:
			// The device type in the Ctx field can never be anything
			// other than the above! Internal protocol error. KeBugCheck.
			DBGPRINT(DBG_COMP_TDI, DBG_LEVEL_ERR,
					("AtalkTdiCleanupAddress: Invalid device type\n"));
			error = ATALK_INVALID_REQUEST;
			break;
		}

	} while (FALSE);

	return AtalkErrorToNtStatus(error);
}




NTSTATUS
AtalkTdiCleanupConnection(
	IN		PIRP					pIrp,
	IN		PIO_STACK_LOCATION		pIrpSp,
	IN OUT	PATALK_DEV_CTX			pCtx
	)
/*++

Routine Description:

	This routine removes the creation reference on the object. It also
	sets up the closepIrp for completion.

Arguments:

	pIrp - The close irp
	Context - The DeviceContext of the device on which close is happening

Return Value:

	STATUS_SUCCESS if successfully setup
	Error otherwise.

--*/
{
	ATALK_ERROR	error;
	PVOID		pConnObj = pIrpSp->FileObject->FsContext;

	do
	{
		// Now depending on the requested device...
		switch (pCtx->adc_DevType)
		{
		  case ATALK_DEV_PAP:

			if (!(VALID_PAPCO((PPAP_CONNOBJ)pConnObj)))
            {
                ASSERT(0);
                error = ATALK_INVALID_CONNECTION;
                break;
            }
            AtalkLockPapIfNecessary();
			AtalkPapConnReferenceByPtr((PPAP_CONNOBJ)pConnObj, &error);
			if (ATALK_SUCCESS(error))
			{
				//	No need to have lock as we have a reference.
				((PPAP_CONNOBJ)pConnObj)->papco_CleanupComp = atalkTdiGenericComplete;
				((PPAP_CONNOBJ)pConnObj)->papco_CleanupCtx  = pIrp;

				DBGPRINT(DBG_COMP_TDI, DBG_LEVEL_INFO,
						("AtalkTdiCleanupConnection: Cleanup %lx.%lx\n",
						pConnObj, pIrp));

				AtalkPapCleanupConnection((PPAP_CONNOBJ)pConnObj);
				AtalkPapConnDereference((PPAP_CONNOBJ)pConnObj);
			    error = ATALK_PENDING;
			}
            AtalkUnlockPapIfNecessary();
			break;

		  case ATALK_DEV_ADSP:
			if (!(VALID_ADSPCO((PADSP_CONNOBJ)pConnObj)))
            {
                ASSERT(0);
                error = ATALK_INVALID_CONNECTION;
                break;
            }
            AtalkLockAdspIfNecessary();
			AtalkAdspConnReferenceByPtr((PADSP_CONNOBJ)pConnObj, &error);
			if (ATALK_SUCCESS(error))
			{
				//	No need to have lock as we have a reference.
				((PADSP_CONNOBJ)pConnObj)->adspco_CleanupComp = atalkTdiGenericComplete;
				((PADSP_CONNOBJ)pConnObj)->adspco_CleanupCtx  = pIrp;
				AtalkAdspCleanupConnection((PADSP_CONNOBJ)pConnObj);
				AtalkAdspConnDereference((PADSP_CONNOBJ)pConnObj);
			    error = ATALK_PENDING;
			}
            AtalkUnlockAdspIfNecessary();
			break;

		  case ATALK_DEV_ASPC:
			if (!(VALID_ASPCCO((PASPC_CONNOBJ)pConnObj)))
            {
                ASSERT(0);
                error = ATALK_INVALID_CONNECTION;
                break;
            }
            AtalkLockAspCIfNecessary();
			AtalkAspCConnReference((PASPC_CONNOBJ)pConnObj, &error);
			if (ATALK_SUCCESS(error))
			{
				//	No need to have lock as we have a reference.
				((PASPC_CONNOBJ)pConnObj)->aspcco_CleanupComp = atalkTdiGenericComplete;
				((PASPC_CONNOBJ)pConnObj)->aspcco_CleanupCtx  = pIrp;
				AtalkAspCCleanupConnection((PASPC_CONNOBJ)pConnObj);
				AtalkAspCConnDereference((PASPC_CONNOBJ)pConnObj);
			    error = ATALK_PENDING;
			}
            AtalkUnlockAspCIfNecessary();
			break;

		  case ATALK_DEV_DDP:
		  default:

			// The device type in the Ctx field can never be anything
			// other than the above! Internal protocol error. KeBugCheck.
			DBGPRINT(DBG_COMP_TDI, DBG_LEVEL_ERR,
					("AtalkTdiCleanupConnection: Invalid device type\n"));
			error = ATALK_INVALID_REQUEST;
			break;
		}

	} while (FALSE);

	return AtalkErrorToNtStatus(error);
}



NTSTATUS
AtalkTdiCloseAddress(
	IN		PIRP					pIrp,
	IN		PIO_STACK_LOCATION		pIrpSp,
	IN OUT	PATALK_DEV_CTX			pCtx
	)
/*++

Routine Description:

	This routine removes the creation reference on the object. It also
	sets up the closepIrp for completion.

Arguments:

	pIrp - The close irp
	Context - The DeviceContext of the device on which close is happening

Return Value:

	STATUS_SUCCESS if successfully setup
	Error otherwise.

--*/
{
	ATALK_ERROR	error;
	PVOID		pAddrObj = pIrpSp->FileObject->FsContext;

	do
	{
		// Now depending on the requested device...
		switch (pCtx->adc_DevType)
		{
		  case ATALK_DEV_DDP:
			if (!(VALID_DDP_ADDROBJ(((PDDP_ADDROBJ)pAddrObj))))
            {
                ASSERT(0);
                error = ATALK_INVALID_ADDRESS;
                break;
            }
			AtalkDdpReferenceByPtr(((PDDP_ADDROBJ)pAddrObj), &error);
			if (ATALK_SUCCESS(error))
			{
				error = AtalkDdpCloseAddress((PDDP_ADDROBJ)pAddrObj,
											  atalkTdiCloseAddressComplete,
											  pIrp);

				AtalkDdpDereference(((PDDP_ADDROBJ)pAddrObj));
			}
			break;

		  case ATALK_DEV_ASPC:
			if (!(VALID_ASPCAO((PASPC_ADDROBJ)pAddrObj)))
            {
                ASSERT(0);
                error = ATALK_INVALID_ADDRESS;
                break;
            }
			AtalkAspCAddrReference((PASPC_ADDROBJ)pAddrObj, &error);
			if (ATALK_SUCCESS(error))
			{
				error = AtalkAspCCloseAddress((PASPC_ADDROBJ)pAddrObj,
											  atalkTdiCloseAddressComplete,
											  pIrp);

				AtalkAspCAddrDereference((PASPC_ADDROBJ)pAddrObj);
			}
			break;

		  case ATALK_DEV_ASP:
			if (!(VALID_ASPAO((PASP_ADDROBJ)pAddrObj)))
            {
                ASSERT(0);
                error = ATALK_INVALID_ADDRESS;
                break;
            }
			if (AtalkAspReferenceAddr((PASP_ADDROBJ)pAddrObj) != NULL)
			{
				error = AtalkAspCloseAddress((PASP_ADDROBJ)pAddrObj,
											  atalkTdiCloseAddressComplete,
											  pIrp);
				AtalkAspDereferenceAddr((PASP_ADDROBJ)pAddrObj);
			}
			break;

		  case ATALK_DEV_PAP:
			if (!(VALID_PAPAO((PPAP_ADDROBJ)pAddrObj)))
            {
                ASSERT(0);
                error = ATALK_INVALID_ADDRESS;
                break;
            }
			AtalkPapAddrReference((PPAP_ADDROBJ)pAddrObj, &error);
			if (ATALK_SUCCESS(error))
			{
				error = AtalkPapCloseAddress((PPAP_ADDROBJ)pAddrObj,
											  atalkTdiCloseAddressComplete,
											  pIrp);

				AtalkPapAddrDereference((PPAP_ADDROBJ)pAddrObj);
			}
			break;

		  case ATALK_DEV_ADSP:
			if (!(VALID_ADSPAO((PADSP_ADDROBJ)pAddrObj)))
            {
                ASSERT(0);
                error = ATALK_INVALID_ADDRESS;
                break;
            }
			AtalkAdspAddrReference((PADSP_ADDROBJ)pAddrObj, &error);
			if (ATALK_SUCCESS(error))
			{
				error = AtalkAdspCloseAddress((PADSP_ADDROBJ)pAddrObj,
											  atalkTdiCloseAddressComplete,
											  pIrp);

				AtalkAdspAddrDereference((PADSP_ADDROBJ)pAddrObj);
			}
			break;

		  default:

			// The device type in the Ctx field can never be anything
			// other than the above! Internal protocol error. KeBugCheck.
			error = ATALK_INVALID_REQUEST;
			DBGPRINT(DBG_COMP_TDI, DBG_LEVEL_ERR,
					("AtalkTdiCloseAddress: Invalid device type\n"));
			break;
		}

	} while (FALSE);

	if (error == ATALK_NO_ERROR)
		error = ATALK_PENDING;

	return AtalkErrorToNtStatus(error);
}




NTSTATUS
AtalkTdiCloseConnection(
	IN		PIRP					pIrp,
	IN		PIO_STACK_LOCATION		pIrpSp,
	IN OUT	PATALK_DEV_CTX			pCtx
	)
/*++

Routine Description:

	This routine removes the creation reference on the object. It also
	sets up the closepIrp for completion.

Arguments:

	pIrp - The close irp
	Context - The DeviceContext of the device on which close is happening

Return Value:

	STATUS_SUCCESS if successfully setup
	Error otherwise.

--*/
{
	ATALK_ERROR		error = ATALK_INVALID_REQUEST;
	PVOID		pConnObj = pIrpSp->FileObject->FsContext;

	if ((pCtx->adc_DevType == ATALK_DEV_PAP) ||
		(pCtx->adc_DevType == ATALK_DEV_ADSP)||
		(pCtx->adc_DevType == ATALK_DEV_ASPC))
	do
	{
		// Now depending on the requested device...
		switch (pCtx->adc_DevType)
		{
		  case ATALK_DEV_PAP:
			if (!(VALID_PAPCO((PPAP_CONNOBJ)pConnObj)))
            {
                ASSERT(0);
                error = ATALK_INVALID_CONNECTION;
                break;
            }
            AtalkLockPapIfNecessary();
			AtalkPapConnReferenceByPtr((PPAP_CONNOBJ)pConnObj, &error);
			if (ATALK_SUCCESS(error))
			{
				error = AtalkPapCloseConnection((PPAP_CONNOBJ)pConnObj,
												atalkTdiCloseAddressComplete,
												pIrp);

				AtalkPapConnDereference((PPAP_CONNOBJ)pConnObj);
			}
            AtalkUnlockPapIfNecessary();
			break;

		  case ATALK_DEV_ADSP:
			if (!(VALID_ADSPCO((PADSP_CONNOBJ)pConnObj)))
            {
                ASSERT(0);
                error = ATALK_INVALID_CONNECTION;
                break;
            }
            AtalkLockAdspIfNecessary();
			AtalkAdspConnReferenceByPtr((PADSP_CONNOBJ)pConnObj, &error);
			if (ATALK_SUCCESS(error))
			{
				error = AtalkAdspCloseConnection((PADSP_CONNOBJ)pConnObj,
												 atalkTdiCloseAddressComplete,
												 pIrp);

				AtalkAdspConnDereference((PADSP_CONNOBJ)pConnObj);
			}
            AtalkUnlockAdspIfNecessary();
			break;

          case ATALK_DEV_ASPC:

			if (!(VALID_ASPCCO((PASPC_CONNOBJ)pConnObj)))
            {
                ASSERT(0);
                error = ATALK_INVALID_CONNECTION;
                break;
            }
            AtalkLockAspCIfNecessary();
            if (!AtalkAspCConnectionIsValid((PASPC_CONNOBJ)pConnObj))
            {
                error = ATALK_INVALID_CONNECTION;
                AtalkUnlockAspCIfNecessary();
                break;
            }

			AtalkAspCConnReference((PASPC_CONNOBJ)pConnObj, &error);
			if (ATALK_SUCCESS(error))
			{
				error = AtalkAspCCloseConnection((PASPC_CONNOBJ)pConnObj,
												 atalkTdiCloseAddressComplete,
												 pIrp);

				AtalkAspCConnDereference((PASPC_CONNOBJ)pConnObj);
			}
            AtalkUnlockAspCIfNecessary();
			break;
		}

	} while (FALSE);

	if (error == ATALK_NO_ERROR)
		error = ATALK_PENDING;

	return AtalkErrorToNtStatus(error);
}




NTSTATUS
AtalkTdiCloseControlChannel(
	IN		PIRP					pIrp,
	IN		PIO_STACK_LOCATION		pIrpSp,
	IN OUT	PATALK_DEV_CTX			pCtx
	)
/*++

Routine Description:

	This routine removes the creation reference on the object. It also
	sets up the closepIrp for completion.

Arguments:

	pIrp - The close irp
	Context - The DeviceContext of the device on which close is happening

Return Value:

	STATUS_SUCCESS if successfully setup
	Error otherwise.

--*/
{
	ATALK_ERROR		error;
	PVOID			pCtrlChnl = pIrpSp->FileObject->FsContext;
    KIRQL           OldIrql;


    if (pCtx->adc_DevType == ATALK_DEV_ARAP)
    {
        ArapReleaseResources();

		DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
		    ("AtalkTdiCloseAddress: RAS device closed\n"));

        // flip the state, so if engine restarts, we tell the engine
        ACQUIRE_SPIN_LOCK(&ArapSpinLock, &OldIrql);

        if (ArapStackState == ARAP_STATE_ACTIVE)
        {
            ArapStackState = ARAP_STATE_ACTIVE_WAITING;
        }
        else if (ArapStackState == ARAP_STATE_INACTIVE)
        {
            ArapStackState = ARAP_STATE_INACTIVE_WAITING;
        }

        RELEASE_SPIN_LOCK(&ArapSpinLock, OldIrql);

        AtalkUnlockTdiIfNecessary();

        return(STATUS_SUCCESS);
    }


	if (!(VALID_DDP_ADDROBJ((PDDP_ADDROBJ)pCtrlChnl)))
    {
        ASSERT(0);
        error = ATALK_INVALID_ADDRESS;
	    return AtalkErrorToNtStatus(error);
    }

	AtalkDdpReferenceByPtr(((PDDP_ADDROBJ)pCtrlChnl), &error);
	if (ATALK_SUCCESS(error))
	{
		error = AtalkDdpCloseAddress(((PDDP_ADDROBJ)pCtrlChnl),
									  atalkTdiCloseAddressComplete,
									  pIrp);
		AtalkDdpDereference(((PDDP_ADDROBJ)pCtrlChnl));
	}

	return AtalkErrorToNtStatus(error);
}



NTSTATUS
AtalkTdiAssociateAddress(
	IN		PIRP					pIrp,
	IN		PIO_STACK_LOCATION		pIrpSp,
	IN OUT	PATALK_DEV_CTX			pCtx
	)
/*++

Routine Description:

	This routine will associate the connection object with the specified
	address object.

	This routine is pretty much provider independent. All we check for is
	that the address object and the provider object belong to the same device.
	Also, this routine will complete synchronously.

Arguments:


Return Value:

	STATUS_SUCCESS if successfully completed
	Error otherwise.

--*/
{
	ATALK_ERROR		error = ATALK_INVALID_REQUEST;
	PVOID			pAddrObj;
	PVOID			pConnObj = pIrpSp->FileObject->FsContext;
	PFILE_OBJECT	pFileObj = NULL;
	HANDLE			AddrObjHandle =
			((PTDI_REQUEST_KERNEL_ASSOCIATE)(&pIrpSp->Parameters))->AddressHandle;
    PDEVICE_OBJECT  pDeviceObject;
	NTSTATUS		status;
    DWORD           i;


	if ((pCtx->adc_DevType == ATALK_DEV_PAP) ||
		(pCtx->adc_DevType == ATALK_DEV_ADSP)||
		(pCtx->adc_DevType == ATALK_DEV_ASPC))
	do
	{
		// Get the handle to the address object from the irp and map it to
		// the corres. file object.
		{
			status = ObReferenceObjectByHandle(AddrObjHandle,
											   0,
											   *IoFileObjectType,
											   pIrp->RequestorMode,
											   (PVOID *)&pFileObj,
										       NULL);
			ASSERT (NT_SUCCESS(status));

            if (!NT_SUCCESS(status))
            {
                return(status);
            }
		}


        pDeviceObject = IoGetRelatedDeviceObject(pFileObj);

        status = STATUS_OBJECT_NAME_INVALID;

        for (i=0; i < ATALK_NO_DEVICES; i++ )
        {
            if (pDeviceObject == (PDEVICE_OBJECT)AtalkDeviceObject[i])
            {
                status = STATUS_SUCCESS;
                break;
            }
        }

        if (!NT_SUCCESS(status))
        {
	        DBGPRINT(DBG_COMP_TDI, DBG_LEVEL_ERR,
			    ("AtalkTdiAssociateAddress: wrong devObject %lx\n",pDeviceObject));
            ASSERT(0);
            return(status);
        }

		pAddrObj = pFileObj->FsContext;

		ASSERT(((LONG_PTR)pFileObj->FsContext2 >> 16) == pCtx->adc_DevType);

		switch (pCtx->adc_DevType)
		{
		  case ATALK_DEV_PAP:

			if (!(VALID_PAPAO((PPAP_ADDROBJ)pAddrObj)))
            {
                ASSERT(0);
                error = ATALK_INVALID_ADDRESS;
                break;
            }
            AtalkLockPapIfNecessary();
			AtalkPapAddrReference((PPAP_ADDROBJ)pAddrObj, &error);
			if (ATALK_SUCCESS(error))
			{
				if (!(VALID_PAPCO((PPAP_CONNOBJ)pConnObj)))
                {
                    ASSERT(0);
                    error = ATALK_INVALID_CONNECTION;
                    AtalkPapAddrDereference((PPAP_ADDROBJ)pAddrObj);
                    break;
                }
				AtalkPapConnReferenceByPtr((PPAP_CONNOBJ)pConnObj, &error);
				if (ATALK_SUCCESS(error))
				{
					error = AtalkPapAssociateAddress((PPAP_ADDROBJ)pAddrObj,
													 (PPAP_CONNOBJ)pConnObj);
					AtalkPapConnDereference((PPAP_CONNOBJ)pConnObj);
				}

				AtalkPapAddrDereference((PPAP_ADDROBJ)pAddrObj);
			}
            AtalkUnlockPapIfNecessary();
			break;

		  case ATALK_DEV_ADSP:
			if (!(VALID_ADSPAO((PADSP_ADDROBJ)pAddrObj)))
            {
                ASSERT(0);
                error = ATALK_INVALID_ADDRESS;
                break;
            }
            AtalkLockAdspIfNecessary();
			AtalkAdspAddrReference((PADSP_ADDROBJ)pAddrObj, &error);
			if (ATALK_SUCCESS(error))
			{
				if (!(VALID_ADSPCO((PADSP_CONNOBJ)pConnObj)))
                {
                    ASSERT(0);
                    error = ATALK_INVALID_CONNECTION;
                    AtalkAdspAddrDereference((PADSP_ADDROBJ)pAddrObj);
                    break;
                }
				AtalkAdspConnReferenceByPtr((PADSP_CONNOBJ)pConnObj, &error);
				if (ATALK_SUCCESS(error))
				{
					error = AtalkAdspAssociateAddress((PADSP_ADDROBJ)pAddrObj,
													  (PADSP_CONNOBJ)pConnObj);
					AtalkAdspConnDereference((PADSP_CONNOBJ)pConnObj);
				}

				AtalkAdspAddrDereference((PADSP_ADDROBJ)pAddrObj);
			}
            AtalkUnlockAdspIfNecessary();
			break;

		  case ATALK_DEV_ASPC:
			if (!(VALID_ASPCAO((PASPC_ADDROBJ)pAddrObj)))
            {
                ASSERT(0);
                error = ATALK_INVALID_ADDRESS;
                break;
            }
            AtalkLockAspCIfNecessary();
			AtalkAspCAddrReference((PASPC_ADDROBJ)pAddrObj, &error);
			if (ATALK_SUCCESS(error))
			{
				if (!(VALID_ASPCCO((PASPC_CONNOBJ)pConnObj)))
                {
                    ASSERT(0);
                    error = ATALK_INVALID_CONNECTION;
                    AtalkAspCAddrDereference((PASPC_ADDROBJ)pAddrObj);
                    break;
                }
				AtalkAspCConnReference((PASPC_CONNOBJ)pConnObj, &error);
				if (ATALK_SUCCESS(error))
				{
					error = AtalkAspCAssociateAddress((PASPC_ADDROBJ)pAddrObj,
													  (PASPC_CONNOBJ)pConnObj);
					AtalkAspCConnDereference((PASPC_CONNOBJ)pConnObj);
				}

				AtalkAspCAddrDereference((PASPC_ADDROBJ)pAddrObj);
			}
            AtalkUnlockAspCIfNecessary();
			break;
		}

		// Dereference the file object corres. to the address object
		ObDereferenceObject(pFileObj);

	} while (FALSE);

	return AtalkErrorToNtStatus(error);
}




NTSTATUS
AtalkTdiDisassociateAddress(
	IN		PIRP					pIrp,
	IN		PIO_STACK_LOCATION		pIrpSp,
	IN OUT	PATALK_DEV_CTX			pCtx
	)
/*++

Routine Description:

	This routine performs a disassociate. This request is only valid when
	the connection is in a purely ASSOCIATED state.

Arguments:


Return Value:

	STATUS_SUCCESS if successfully completed
	Error otherwise.

--*/
{
	ATALK_ERROR	error = ATALK_INVALID_REQUEST;
	PVOID		pConnObj = pIrpSp->FileObject->FsContext;

	if ((pCtx->adc_DevType == ATALK_DEV_PAP) ||
		(pCtx->adc_DevType == ATALK_DEV_ADSP)||
		(pCtx->adc_DevType == ATALK_DEV_ASPC))
	do
	{
		ASSERT(((LONG_PTR)pIrpSp->FileObject->FsContext2 >> 16) == pCtx->adc_DevType);

		// Now depending on the requested device...
		switch (pCtx->adc_DevType)
		{
		  case ATALK_DEV_PAP:
			// Reference the connection object
			if (!(VALID_PAPCO((PPAP_CONNOBJ)pConnObj)))
            {
                ASSERT(0);
                error = ATALK_INVALID_CONNECTION;
                break;
            }
            AtalkLockPapIfNecessary();
			AtalkPapConnReferenceByPtr((PPAP_CONNOBJ)pConnObj, &error);
			if (ATALK_SUCCESS(error))
			{
				error = AtalkPapDissociateAddress(pConnObj);

				AtalkPapConnDereference((PPAP_CONNOBJ)pConnObj);
			}
            AtalkUnlockPapIfNecessary();
			break;

		  case ATALK_DEV_ADSP:
			// Reference the connection object
			if (!(VALID_ADSPCO((PADSP_CONNOBJ)pConnObj)))
            {
                ASSERT(0);
                error = ATALK_INVALID_CONNECTION;
                break;
            }
            AtalkLockAdspIfNecessary();
			AtalkAdspConnReferenceByPtr((PADSP_CONNOBJ)pConnObj, &error);
			if (ATALK_SUCCESS(error))
			{
				error = AtalkAdspDissociateAddress(pConnObj);

				AtalkAdspConnDereference((PADSP_CONNOBJ)pConnObj);
			}
            AtalkUnlockAdspIfNecessary();
			break;

        case ATALK_DEV_ASPC:

			if (!(VALID_ASPCCO((PASPC_CONNOBJ)pConnObj)))
            {
                ASSERT(0);
                error = ATALK_INVALID_CONNECTION;
                break;
            }
            AtalkLockAspCIfNecessary();
            if (!AtalkAspCConnectionIsValid((PASPC_CONNOBJ)pConnObj))
            {
                error = ATALK_INVALID_CONNECTION;
                AtalkUnlockAspCIfNecessary();
                break;
            }

			// Reference the connection object
			AtalkAspCConnReference((PASPC_CONNOBJ)pConnObj, &error);
			if (ATALK_SUCCESS(error))
			{
				error = AtalkAspCDissociateAddress(pConnObj);

				AtalkAspCConnDereference((PASPC_CONNOBJ)pConnObj);
			}
            AtalkUnlockAspCIfNecessary();
			break;
		}

	} while (FALSE);

	return AtalkErrorToNtStatus(error);
}




NTSTATUS
AtalkTdiConnect(
	IN		PIRP					pIrp,
	IN		PIO_STACK_LOCATION		pIrpSp,
	IN OUT	PATALK_DEV_CTX			pCtx
	)
/*++

Routine Description:

	This routine will post a connect request with the portable stack.

Arguments:

Return Value:

	STATUS_PENDING if successfully started
	Error otherwise.

--*/
{
	PTDI_REQUEST_KERNEL_CONNECT	parameters;
	PTA_APPLETALK_ADDRESS		remoteTdiAddr;
	ATALK_ADDR					remoteAddr;
	ATALK_ERROR					error = ATALK_INVALID_REQUEST;
	PVOID						pConnObj = pIrpSp->FileObject->FsContext;

	parameters 		= (PTDI_REQUEST_KERNEL_CONNECT)&pIrpSp->Parameters;
	remoteTdiAddr  	= (PTA_APPLETALK_ADDRESS)
						parameters->RequestConnectionInformation->RemoteAddress;

	DBGPRINT(DBG_COMP_TDI, DBG_LEVEL_INFO,
			("AtalkTdiConnect: Net %x Node %x Socket %x\n",
			remoteTdiAddr->Address[0].Address[0].Network,
			remoteTdiAddr->Address[0].Address[0].Node,
			remoteTdiAddr->Address[0].Address[0].Socket));

	DBGPRINT(DBG_COMP_TDI, DBG_LEVEL_INFO,
			("AtalkConnPostConnect: Cnt %x\n", remoteTdiAddr->TAAddressCount));

	TDI_TO_ATALKADDR(&remoteAddr, remoteTdiAddr);

	DBGPRINT(DBG_COMP_TDI, DBG_LEVEL_INFO,
			("AtalkTdiConnect: Portable Net %x Node %x Socket %x\n",
			remoteAddr.ata_Network, remoteAddr.ata_Node, remoteAddr.ata_Socket));

	if ((pCtx->adc_DevType == ATALK_DEV_PAP) ||
		(pCtx->adc_DevType == ATALK_DEV_ADSP)||
		(pCtx->adc_DevType == ATALK_DEV_ASPC))
	do
	{
		ASSERT(((LONG_PTR)pIrpSp->FileObject->FsContext2 >> 16) == pCtx->adc_DevType);

		// Now depending on the requested device...
		switch (pCtx->adc_DevType)
		{
		  case ATALK_DEV_PAP:
			if (!(VALID_PAPCO((PPAP_CONNOBJ)pConnObj)))
            {
                ASSERT(0);
                error = ATALK_INVALID_CONNECTION;
                break;
            }
			AtalkPapConnReferenceByPtr((PPAP_CONNOBJ)pConnObj, &error);
			if (ATALK_SUCCESS(error))
			{
				error = AtalkPapPostConnect((PPAP_CONNOBJ)pConnObj,
											&remoteAddr,
											pIrp,
											atalkTdiGenericComplete);

				AtalkPapConnDereference((PPAP_CONNOBJ)pConnObj);
			}
			break;

		  case ATALK_DEV_ADSP:
			if (!(VALID_ADSPCO((PADSP_CONNOBJ)pConnObj)))
            {
                ASSERT(0);
                error = ATALK_INVALID_CONNECTION;
                break;
            }
			AtalkAdspConnReferenceByPtr((PADSP_CONNOBJ)pConnObj, &error);
			if (ATALK_SUCCESS(error))
			{
				error = AtalkAdspPostConnect((PADSP_CONNOBJ)pConnObj,
											 &remoteAddr,
											 pIrp,
											 atalkTdiGenericComplete);

				AtalkAdspConnDereference((PADSP_CONNOBJ)pConnObj);
			}
			break;

		  case ATALK_DEV_ASPC:
			if (!(VALID_ASPCCO((PASPC_CONNOBJ)pConnObj)))
            {
                ASSERT(0);
                error = ATALK_INVALID_CONNECTION;
                break;
            }
            if (!AtalkAspCConnectionIsValid((PASPC_CONNOBJ)pConnObj))
            {
                error = ATALK_INVALID_CONNECTION;
                break;
            }

			AtalkAspCConnReference((PASPC_CONNOBJ)pConnObj, &error);
			if (ATALK_SUCCESS(error))
			{
				error = AtalkAspCPostConnect((PASPC_CONNOBJ)pConnObj,
											 &remoteAddr,
											 pIrp,
											 atalkTdiGenericComplete);

				AtalkAspCConnDereference((PASPC_CONNOBJ)pConnObj);
			}
			break;
		}
	} while (FALSE);

	return AtalkErrorToNtStatus(error);
}




NTSTATUS
AtalkTdiDisconnect(
	IN		PIRP					pIrp,
	IN		PIO_STACK_LOCATION		pIrpSp,
	IN OUT	PATALK_DEV_CTX			pCtx
	)
/*++

Routine Description:

	This routine will disconnect an active connection or cancel a posted
	listen/connect

Arguments:

				
Return Value:

	STATUS_SUCCESS if successfully completed
	STATUS_PENDING if successfully started
	Error otherwise.

--*/
{
	ATALK_ERROR	error = ATALK_INVALID_REQUEST;
	PVOID		pConnObj = pIrpSp->FileObject->FsContext;

	if ((pCtx->adc_DevType == ATALK_DEV_PAP) ||
		(pCtx->adc_DevType == ATALK_DEV_ADSP)||
		(pCtx->adc_DevType == ATALK_DEV_ASPC))
	do
	{
		ASSERT(((LONG_PTR)pIrpSp->FileObject->FsContext2 >> 16) == pCtx->adc_DevType);

		// Now depending on the requested device...
		switch (pCtx->adc_DevType)
		{
		  case ATALK_DEV_PAP:
			if (!(VALID_PAPCO((PPAP_CONNOBJ)pConnObj)))
            {
                ASSERT(0);
                error = ATALK_INVALID_CONNECTION;
                break;
            }
			AtalkPapConnReferenceByPtr((PPAP_CONNOBJ)pConnObj, &error);
			if (ATALK_SUCCESS(error))
			{
				error = AtalkPapDisconnect((PPAP_CONNOBJ)pConnObj,
											ATALK_LOCAL_DISCONNECT,
											pIrp,
											atalkTdiGenericComplete);

				AtalkPapConnDereference((PPAP_CONNOBJ)pConnObj);
			}
			break;

		  case ATALK_DEV_ADSP:
			if (!(VALID_ADSPCO((PADSP_CONNOBJ)pConnObj)))
            {
                ASSERT(0);
                error = ATALK_INVALID_CONNECTION;
                break;
            }
			AtalkAdspConnReferenceByPtr((PADSP_CONNOBJ)pConnObj, &error);
			if (ATALK_SUCCESS(error))
			{
				error = AtalkAdspDisconnect((PADSP_CONNOBJ)pConnObj,
											ATALK_LOCAL_DISCONNECT,
											pIrp,
											atalkTdiGenericComplete);

				AtalkAdspConnDereference((PADSP_CONNOBJ)pConnObj);
			}
			break;

		  case ATALK_DEV_ASPC:

            if (!(VALID_ASPCCO((PASPC_CONNOBJ)pConnObj)))
            {
                ASSERT(0);
                error = ATALK_INVALID_CONNECTION;
                break;
            }
            if (!AtalkAspCConnectionIsValid((PASPC_CONNOBJ)pConnObj))
            {
                error = ATALK_INVALID_CONNECTION;
                break;
            }

			AtalkAspCConnReference((PASPC_CONNOBJ)pConnObj, &error);
			if (ATALK_SUCCESS(error))
			{
				error = AtalkAspCDisconnect((PASPC_CONNOBJ)pConnObj,
											ATALK_LOCAL_DISCONNECT,
											pIrp,
											atalkTdiGenericComplete);

				AtalkAspCConnDereference((PASPC_CONNOBJ)pConnObj);
			}
			break;
		}
	} while (FALSE);

	return AtalkErrorToNtStatus(error);
}




NTSTATUS
AtalkTdiAccept(
	IN		PIRP					pIrp,
	IN		PIO_STACK_LOCATION		pIrpSp,
	IN OUT	PATALK_DEV_CTX			pCtx
	)
/*++

Routine Description:

	This routine

Arguments:

				
Return Value:

	STATUS_SUCCESS if successfully completed
	STATUS_PENDING if successfully started
	Error otherwise.

--*/
{
	NTSTATUS	status = STATUS_SUCCESS;

	do
	{
		ASSERT(((LONG_PTR)pIrpSp->FileObject->FsContext2 >> 16) == pCtx->adc_DevType);

		// Now depending on the requested device...
		switch (pCtx->adc_DevType)
		{
		  case ATALK_DEV_ADSP:
		  case ATALK_DEV_PAP:
			break;

		  default:
			// The device type in the Ctx field can never be anything
			// other than the above! Internal protocol error. KeBugCheck.
			DBGPRINT(DBG_COMP_TDI, DBG_LEVEL_ERR,
					("AtalkTdiAccept: Invalid device type\n"));
		  case ATALK_DEV_DDP:
		  case ATALK_DEV_ASPC:
		  case ATALK_DEV_ASP:
			status = STATUS_INVALID_DEVICE_REQUEST;
			break;
		}
	} while (FALSE);

	return status;
}




NTSTATUS
AtalkTdiListen(
	IN		PIRP					pIrp,
	IN		PIO_STACK_LOCATION		pIrpSp,
	IN OUT	PATALK_DEV_CTX			pCtx
	)
/*++

Routine Description:

	This routine

Arguments:

				
Return Value:

	STATUS_PENDING if successfully started
	Error otherwise.

--*/
{
	ATALK_ERROR	error = ATALK_INVALID_REQUEST;
	PVOID		pConnObj = pIrpSp->FileObject->FsContext;

	if ((pCtx->adc_DevType == ATALK_DEV_PAP) ||
		(pCtx->adc_DevType == ATALK_DEV_ADSP))
	do
	{
		ASSERT(((LONG_PTR)pIrpSp->FileObject->FsContext2 >> 16) == pCtx->adc_DevType);

		// Now depending on the requested device...
		switch (pCtx->adc_DevType)
		{
		  case ATALK_DEV_PAP:
			if (!(VALID_PAPCO((PPAP_CONNOBJ)pConnObj)))
            {
                ASSERT(0);
                error = ATALK_INVALID_CONNECTION;
                break;
            }
			AtalkPapConnReferenceByPtr((PPAP_CONNOBJ)pConnObj, &error);
			if (ATALK_SUCCESS(error))
			{
				error = AtalkPapPostListen((PPAP_CONNOBJ)pConnObj,
											pIrp,
											atalkTdiGenericComplete);
				AtalkPapConnDereference((PPAP_CONNOBJ)pConnObj);
			}
			break;

		  case ATALK_DEV_ADSP:
			if (!(VALID_ADSPCO((PADSP_CONNOBJ)pConnObj)))
            {
                ASSERT(0);
                error = ATALK_INVALID_CONNECTION;
                break;
            }
			AtalkAdspConnReferenceByPtr((PADSP_CONNOBJ)pConnObj, &error);
			if (ATALK_SUCCESS(error))
			{
				error = AtalkAdspPostListen((PADSP_CONNOBJ)pConnObj,
											pIrp,
											atalkTdiGenericComplete);
				AtalkAdspConnDereference((PADSP_CONNOBJ)pConnObj);
			}
			break;
		}

	} while (FALSE);

	if (error == ATALK_NO_ERROR)
		error = ATALK_PENDING;

	return AtalkErrorToNtStatus(error);
}




NTSTATUS
AtalkTdiSendDgram(
	IN		PIRP					pIrp,
	IN		PIO_STACK_LOCATION		pIrpSp,
	IN OUT	PATALK_DEV_CTX			pCtx
	)
/*++

Routine Description:

	This routine sends a datagram.

Arguments:

				
Return Value:

	STATUS_PENDING if successfully started
	Error otherwise.

--*/
{
	NTSTATUS		status = STATUS_SUCCESS;
	SEND_COMPL_INFO	SendInfo;

	do
	{
		// Now depending on the requested device...
		switch (pCtx->adc_DevType)
		{
		  case ATALK_DEV_DDP:
			{
				PTDI_REQUEST_KERNEL_SENDDG	pParam;
				PBUFFER_DESC				pBufDesc;
				ATALK_ERROR					error;
				PTA_APPLETALK_ADDRESS		pTaDest;
				ATALK_ADDR					AtalkAddr;
				PDDP_ADDROBJ				pDdpAddr;

				pDdpAddr  = (PDDP_ADDROBJ)pIrpSp->FileObject->FsContext;
				if (!(VALID_DDP_ADDROBJ(pDdpAddr)))
                {
                    ASSERT(0);
                    error = ATALK_INVALID_ADDRESS;
                    break;
                }
				
				pParam = (PTDI_REQUEST_KERNEL_SENDDG)&pIrpSp->Parameters;
				pTaDest = (PTA_APPLETALK_ADDRESS)
								pParam->SendDatagramInformation->RemoteAddress;
			
				DBGPRINT(DBG_COMP_DDP, DBG_LEVEL_INFO,
						("DDP: SendDatagram - Net %x Node %x Socket %x\n",
							pTaDest->Address[0].Address[0].Network,
							pTaDest->Address[0].Address[0].Node,
							pTaDest->Address[0].Address[0].Socket));
			
				if ((pTaDest->Address[0].AddressType != TDI_ADDRESS_TYPE_APPLETALK) ||
					(pTaDest->Address[0].AddressLength < sizeof(TDI_ADDRESS_APPLETALK)))
				{
			        DBGPRINT(DBG_COMP_TDI, DBG_LEVEL_ERR,
				        ("AtalkTdiSendDgram: returning STATUS_INVALID_ADDRESS (Type %x Len %d)\n",
                        pTaDest->Address[0].AddressType,pTaDest->Address[0].AddressLength));

					status = STATUS_INVALID_ADDRESS;
				}
				else
				{
					ULONG	sendLength;
			
					AtalkAddr.ata_Network = pTaDest->Address[0].Address[0].Network;
					AtalkAddr.ata_Node = pTaDest->Address[0].Address[0].Node;
					AtalkAddr.ata_Socket = pTaDest->Address[0].Address[0].Socket;
			
					// Get the length of the send mdl
					sendLength = AtalkSizeMdlChain(pIrp->MdlAddress);

					//	Check destination address
					if (INVALID_ADDRESS(&AtalkAddr))
					{
						error = ATALK_DDP_INVALID_ADDR;
					}
				
					if (sendLength > MAX_DGRAM_SIZE)
					{
						error = ATALK_BUFFER_TOO_BIG;
					}

					else if ((pBufDesc = AtalkAllocBuffDesc(pIrp->MdlAddress,
															(USHORT)sendLength,
															0)) != NULL)
					{
						SendInfo.sc_TransmitCompletion = atalkTdiSendDgramComplete;
						SendInfo.sc_Ctx1 = pDdpAddr;
						SendInfo.sc_Ctx2 = pBufDesc;
						SendInfo.sc_Ctx3 = pIrp;
						error = AtalkDdpSend(pDdpAddr,
											 &AtalkAddr,
											 pDdpAddr->ddpao_Protocol,
											 FALSE,
											 pBufDesc,
											 NULL,	// OptHdr
											 0,		// OptHdrLen
											 NULL,	// ZoneMcastAddr
											 &SendInfo);

						if (!ATALK_SUCCESS(error))
						{
							atalkTdiSendDgramComplete(NDIS_STATUS_FAILURE,
													  &SendInfo);

							error = ATALK_PENDING;
						}
					}

					else error	= ATALK_RESR_MEM;
								
					status = AtalkErrorToNtStatus(error);
				}
			}
			break;

		  case ATALK_DEV_ASPC:
		  case ATALK_DEV_ADSP:
		  case ATALK_DEV_ASP:
		  case ATALK_DEV_PAP:
			status = STATUS_INVALID_DEVICE_REQUEST;
			break;

		  default:
			// The device type in the Ctx field can never be anything
			// other than the above! Internal protocol error. KeBugCheck.
			DBGPRINT(DBG_COMP_TDI, DBG_LEVEL_ERR,
					("AtalkTdiSendDatagram: Invalid device type\n"));
			break;
		}

	} while (FALSE);

	return status;
}




NTSTATUS
AtalkTdiReceiveDgram(
	IN		PIRP					pIrp,
	IN		PIO_STACK_LOCATION		pIrpSp,
	IN OUT	PATALK_DEV_CTX			pCtx
	)
/*++

Routine Description:

	This routine receives a datagram.

Arguments:

				
Return Value:

	STATUS_PENDING if successfully started
	Error otherwise.

--*/
{
	ATALK_ERROR	error = ATALK_INVALID_REQUEST;

	if (pCtx->adc_DevType == ATALK_DEV_DDP)
	{
		PDDP_ADDROBJ					pDdpAddr;
		PTDI_REQUEST_KERNEL_RECEIVEDG	parameters =
										(PTDI_REQUEST_KERNEL_RECEIVEDG)&pIrpSp->Parameters;

		pDdpAddr  = (PDDP_ADDROBJ)pIrpSp->FileObject->FsContext;
		if (!(VALID_DDP_ADDROBJ(pDdpAddr)))
        {
            ASSERT(0);
            error = ATALK_INVALID_ADDRESS;
            return(AtalkErrorToNtStatus(error));
        }

		error = AtalkDdpReceive(pDdpAddr,
								pIrp->MdlAddress,
								(USHORT)AtalkSizeMdlChain(pIrp->MdlAddress),
								parameters->ReceiveFlags,
								atalkTdiRecvDgramComplete,
								pIrp);

	}

	return AtalkErrorToNtStatus(error);
}




NTSTATUS
AtalkTdiSend(
	IN		PIRP					pIrp,
	IN		PIO_STACK_LOCATION		pIrpSp,
	IN OUT	PATALK_DEV_CTX			pCtx
	)
/*++

Routine Description:

	This routine sends the data specified. (used by PAP/ADSP only)

Arguments:

				
Return Value:

	STATUS_SUCCESS if successfully completed
	STATUS_PENDING if successfully started
	Error otherwise.

--*/
{
	PTDI_REQUEST_KERNEL_SEND	parameters;
	ATALK_ERROR					error = ATALK_INVALID_REQUEST;
	PVOID						pConnObj= pIrpSp->FileObject->FsContext;

	parameters = (PTDI_REQUEST_KERNEL_SEND)&pIrpSp->Parameters;

	if ((pCtx->adc_DevType == ATALK_DEV_PAP) ||
		(pCtx->adc_DevType == ATALK_DEV_ADSP))
	do
	{
		// Now depending on the requested device...
		switch (pCtx->adc_DevType)
		{
		  case ATALK_DEV_ADSP:
			if (!(VALID_ADSPCO((PADSP_CONNOBJ)pConnObj)))
			{
				ASSERT(0);
				error = ATALK_INVALID_CONNECTION;
				break;
			}
			error = AtalkAdspWrite(pConnObj,
								   pIrp->MdlAddress,
								   (USHORT)parameters->SendLength,
								   parameters->SendFlags,
								   pIrp,
								   atalkTdiGenericWriteComplete);

			if (!ATALK_SUCCESS(error))
			{
				DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
						("AtalkAdspWrite: Failed for conn %lx.%lx error %lx\n",
						pConnObj, ((PADSP_CONNOBJ)pConnObj)->adspco_Flags, error));
			}
			break;

		  case ATALK_DEV_PAP:
			if (!(VALID_PAPCO((PPAP_CONNOBJ)pConnObj)))
			{
				ASSERT(0);
				error = ATALK_INVALID_CONNECTION;
				break;
			}
			error = AtalkPapWrite(pConnObj,
								pIrp->MdlAddress,
								(USHORT)parameters->SendLength,
								parameters->SendFlags,
								pIrp,
								atalkTdiGenericWriteComplete);

			if (!ATALK_SUCCESS(error))
			{
				DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_INFO,
						("AtalkPapWrite: Failed for conn %lx.%lx error %lx\n",
						pConnObj, ((PPAP_CONNOBJ)pConnObj)->papco_Flags, error));
			}
			break;
		}

	} while (FALSE);

	return AtalkErrorToNtStatus(error);
}




NTSTATUS
AtalkTdiReceive(
	IN		PIRP					pIrp,
	IN		PIO_STACK_LOCATION		pIrpSp,
	IN OUT	PATALK_DEV_CTX			pCtx
	)
/*++

Routine Description:

	This routine receives data. (used by PAP/ADSP only)

Arguments:

				
Return Value:

	STATUS_SUCCESS if successfully completed
	STATUS_PENDING if successfully started
	Error otherwise.

--*/
{
	ATALK_ERROR					error = ATALK_INVALID_REQUEST;
	PVOID						pConnObj= pIrpSp->FileObject->FsContext;
	PTDI_REQUEST_KERNEL_RECEIVE	parameters =
									(PTDI_REQUEST_KERNEL_RECEIVE)&pIrpSp->Parameters;

	if ((pCtx->adc_DevType == ATALK_DEV_PAP) ||
		(pCtx->adc_DevType == ATALK_DEV_ASPC)||
		(pCtx->adc_DevType == ATALK_DEV_ADSP))
	do
	{
		// Now depending on the requested device...
		switch (pCtx->adc_DevType)
		{
		  case ATALK_DEV_PAP:
			if (!(VALID_PAPCO((PPAP_CONNOBJ)pConnObj)))
			{
				ASSERT(0);
				error = ATALK_INVALID_CONNECTION;
				break;
			}
			error = AtalkPapRead(pConnObj,
								 pIrp->MdlAddress,
								 (USHORT)parameters->ReceiveLength,
								 parameters->ReceiveFlags,
								 pIrp,
								 atalkTdiGenericReadComplete);

			if (!ATALK_SUCCESS(error))
			{
				DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_INFO,
						("AtalkPapRead: Failed for conn %lx.%lx error %lx\n",
						pConnObj, ((PPAP_CONNOBJ)pConnObj)->papco_Flags, error));
			}
			break;

		  case ATALK_DEV_ADSP:
			if (!(VALID_ADSPCO((PADSP_CONNOBJ)pConnObj)))
			{
				ASSERT(0);
				error = ATALK_INVALID_CONNECTION;
				break;
			}
			AtalkLockAdspIfNecessary();

			error = AtalkAdspRead(pConnObj,
								  pIrp->MdlAddress,
								  (USHORT)parameters->ReceiveLength,
								  parameters->ReceiveFlags,
								  pIrp,
								  atalkTdiGenericReadComplete);

            AtalkUnlockAdspIfNecessary();

			if (!ATALK_SUCCESS(error))
			{
				DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
						("AtalkAdspRead: Failed for conn %lx.%lx error %lx\n",
						pConnObj, ((PADSP_CONNOBJ)pConnObj)->adspco_Flags, error));
			}
			break;

		  case ATALK_DEV_ASPC:
			if (!(VALID_ASPCCO((PASPC_CONNOBJ)pConnObj)))
			{
				ASSERT(0);
				error = ATALK_INVALID_CONNECTION;
				break;
			}
			error = AtalkAspCGetAttn(pConnObj,
									 pIrp->MdlAddress,
									 (USHORT)parameters->ReceiveLength,
									 parameters->ReceiveFlags,
									 pIrp,
									 atalkTdiGenericReadComplete);

			if (!ATALK_SUCCESS(error))
			{
				DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_INFO,
						("AtalkAspCGetAttn: Failed for conn %lx.%lx error %lx\n",
						pConnObj, ((PASPC_CONNOBJ)pConnObj)->aspcco_Flags, error));
			}
			break;
		}
	
	} while (FALSE);

	return AtalkErrorToNtStatus(error);
}



NTSTATUS
AtalkTdiAction(
	IN		PIRP					pIrp,
	IN		PIO_STACK_LOCATION		pIrpSp,
	IN OUT	PATALK_DEV_CTX			pCtx
	)
/*++

Routine Description:

	This routine is the dispatch routine for all the TdiAction primitives
	for all the providers

Arguments:

				
Return Value:

	STATUS_SUCCESS if successfully completed
	STATUS_PENDING if successfully started
	Error otherwise.

--*/
{
	NTSTATUS			status = STATUS_SUCCESS;
	ATALK_ERROR			error  = ATALK_NO_ERROR;
	USHORT				bufLen;
	USHORT				actionCode, Flags;
	TDI_ACTION_HEADER	UNALIGNED *pActionHdr;
	PMDL				pMdl = pIrp->MdlAddress;
	PVOID				pObject;
	USHORT				ObjectType;
	USHORT				DevType;
	BOOLEAN				freeHdr = FALSE;

	do
	{
		if (pMdl == NULL)
		{
			status = STATUS_INVALID_PARAMETER;
			break;
		}
	
		bufLen = (USHORT)AtalkSizeMdlChain(pIrp->MdlAddress);
	
		// If we atleast do not have the action header, return
		if (bufLen < sizeof(TDI_ACTION_HEADER))
		{
			status = STATUS_INVALID_PARAMETER;
            ASSERT(0);
			break;
		}
	
		if (AtalkIsMdlFragmented(pMdl))
		{
			ULONG	bytesCopied;

			if ((pActionHdr = AtalkAllocMemory(sizeof(TDI_ACTION_HEADER))) == NULL)
			{
				status = STATUS_INSUFFICIENT_RESOURCES;
				break;
			}

			freeHdr = TRUE;

			//	Copy the header to this buffer
			status = TdiCopyMdlToBuffer(pMdl,
										0,							// SrcOff
										pActionHdr,
										0,							// Dest Off
										sizeof(TDI_ACTION_HEADER),
										&bytesCopied);

			ASSERT(NT_SUCCESS(status) && (bytesCopied == sizeof(TDI_ACTION_HEADER)));

			if (!NT_SUCCESS(status))
				break;
		}
		else
		{
			pActionHdr = (TDI_ACTION_HEADER UNALIGNED *)MmGetSystemAddressForMdlSafe(
					pMdl, NormalPagePriority);

			if (pActionHdr == NULL) {
                ASSERT(0);
				status = STATUS_INSUFFICIENT_RESOURCES;
				break;
			}

		}
	
		DBGPRINT(DBG_COMP_ACTION, DBG_LEVEL_INFO,
				("AtalkTdiAction - code %lx BufLen %d SysAddress %lx\n",
				pActionHdr->ActionCode, bufLen, pActionHdr));
	
		// If the MATK identifier is not present, we return
		if (pActionHdr->TransportId != MATK)
		{
			status = STATUS_INVALID_DEVICE_REQUEST;
			break;
		}
	
		actionCode = pActionHdr->ActionCode;
		if ((actionCode < MIN_COMMON_ACTIONCODE) ||
			(actionCode > MAX_ALLACTIONCODES))
		{
			DBGPRINT(DBG_COMP_ACTION, DBG_LEVEL_ERR,
					("AtalkTdiAction - Invalid action code %d\n", actionCode));
	
			status = STATUS_INVALID_PARAMETER;
			break;
		}

		if (bufLen < AtalkActionDispatch[actionCode]._MinBufLen)
		{
			DBGPRINT(DBG_COMP_ACTION, DBG_LEVEL_ERR,
					("AtalkTdiAction - Minbuflen %d Expected %d\n",
					bufLen, AtalkActionDispatch[actionCode]._MinBufLen));

			status = STATUS_BUFFER_TOO_SMALL;
			break;
		}

        // if someone is trying to open ASP via usermode, reject it!
        if ((AtalkActionDispatch[actionCode]._OpCode == ACTION_ASP_BIND) &&
            (pIrp->RequestorMode != KernelMode))
        {
			status = STATUS_INVALID_PARAMETER;
            ASSERT(0);
			break;
        }

		Flags = AtalkActionDispatch[actionCode]._Flags;

		pObject = (PVOID)pIrpSp->FileObject->FsContext;
		ObjectType = (USHORT)((ULONG_PTR)(pIrpSp->FileObject->FsContext2) & 0xFF);
		DevType = (USHORT)((ULONG_PTR)(pIrpSp->FileObject->FsContext2) >> 16);
		// Convert control channel operations to Ddp
		if (ObjectType == TDI_CONTROL_CHANNEL_FILE)
			DevType = ATALK_DEV_DDP;

		// Verify the device type is that expected. Either the request
		// should be valid for any device or the type of device for the
		// request should match the type of device expected.
		if ((AtalkActionDispatch[actionCode]._DeviceType != ATALK_DEV_ANY) &&
			((pCtx->adc_DevType != AtalkActionDispatch[actionCode]._DeviceType) ||
			 (DevType != AtalkActionDispatch[actionCode]._DeviceType)))
		{
			status = STATUS_INVALID_DEVICE_REQUEST;
			break;
		}

		// Verify the object - it has to be one of those specified as valid
		// in the dispatch table for this action call.
		ASSERT(ObjectType & (DFLAG_ADDR | DFLAG_CNTR | DFLAG_CONN));

		switch (ObjectType)
		{
		  case TDI_TRANSPORT_ADDRESS_FILE:
			if (!(Flags & DFLAG_ADDR))
				status = STATUS_INVALID_HANDLE;
			break;

		  case TDI_CONNECTION_FILE:
			if (!(Flags & DFLAG_CONN))
				status = STATUS_INVALID_HANDLE;
			break;

		  case TDI_CONTROL_CHANNEL_FILE:
			if (!(Flags & DFLAG_CNTR))
				status = STATUS_INVALID_HANDLE;
			break;

		  default:
			status = STATUS_INVALID_HANDLE;
			break;
		}

	} while (FALSE);

	if (!NT_SUCCESS(status))
	{
		if (freeHdr)
		{
			AtalkFreeMemory(pActionHdr);
		}
		return status;
	}


	// Handle the requests based on the action code.
	// Use the table to call the appropriate routine

	do
	{
		PACTREQ				pActReq;
		USHORT				offset = AtalkActionDispatch[actionCode]._ActionBufSize;
		USHORT				size = bufLen - offset;

		// If DFLAG_MDL is set, then we know we have to create the mdl.
		//
		// NOTE:	User can pass in invalid sizes...
		//			Also, it is assumed that BuildMdl will not change
		//			value of the mdl unless it can successfully build
		//			all of it. Therefore, error cases must preserve
		//			value of NULL.
		//

		// First allocate an action request structure.
		// !!!This memory should be zeroed out as we depend on extra mdl pointer to
		//	be NULL!!!
		if ((pActReq = AtalkAllocZeroedMemory(sizeof(ACTREQ))) == NULL)
		{
			status = STATUS_INSUFFICIENT_RESOURCES;
			break;
		}
#if	DBG
		pActReq->ar_Signature = ACTREQ_SIGNATURE;
#endif
		pActReq->ar_pIrp = pIrp;
		pActReq->ar_DevType = DevType;
		pActReq->ar_pParms = (PBYTE)pActionHdr + sizeof(TDI_ACTION_HEADER);
		pActReq->ar_Completion = atalkTdiActionComplete;
		pActReq->ar_ActionCode = actionCode;
		pActReq->ar_pAMdl =	NULL;
		pActReq->ar_MdlSize = 0;

		if (Flags & DFLAG_MDL)
		{
			ASSERT((size >= 0) && ((offset+size) <= bufLen));
			pActReq->ar_MdlSize = size;

			if ((size < 0) || ((offset+size) > bufLen))
			{
				AtalkFreeMemory(pActReq);
				status = STATUS_INVALID_PARAMETER;
				break;
			}

			// If size is zero, we go on to the next mdl.
			// IoAllocateMdl will fail for a 0-length mdl
			// If size < 0, we will hit the error later.
			if (size != 0)
			{
				DBGPRINT(DBG_COMP_ACTION, DBG_LEVEL_INFO,
						("AtalkTdiAction - Size of mdl %lx\n", size));
		
				pActReq->ar_pAMdl =	AtalkSubsetAmdl(pMdl,	// MasterMdl
													offset,	// ByteOffset,
													size);	// SubsetMdlSize,
		
				if (pActReq->ar_pAMdl == NULL)
				{
					AtalkFreeMemory(pActReq);
					status = STATUS_INSUFFICIENT_RESOURCES;
					break;
				}
			}
		}

		//	Now call the dispatch routine
		error = (*AtalkActionDispatch[actionCode]._Dispatch)(pObject, pActReq);
		if (!ATALK_SUCCESS(error))
		{
			//	Call the generic completion routine and then return
			//	pending. That will free up the mdl's and the actreq.
			atalkTdiActionComplete(error, pActReq);
		}
		status = STATUS_PENDING;
	} while (FALSE);

	return status;
}




NTSTATUS
AtalkTdiQueryInformation(
	IN		PIRP					pIrp,
	IN		PIO_STACK_LOCATION		pIrpSp,
	IN OUT	PATALK_DEV_CTX			pCtx
	)
/*++

Routine Description:

	This routine will satisfy the query for the object indicated in the Request. It
	supports the following query types-

	TDI_QUERY_PROVIDER_INFO
		The provider information structure for the provider that the object belongs to.

	TDI_QUERY_ADDRESS_INFO
		The address information for the address object passed in.

	TDI_QUERY_CONNECTION_INFO			**NOT SUPPORTED**
		The connection information for the connection object passed in.

	TDI_QUERY_PROVIDER_STATISTICS		**NOT SUPPORTED**
		The provider statistics - per provider statistics. All actions on a particular
		file object corresponds to activity on the provider of that file object. So each
		provider context structure will have the provider statistics structure which will
		be returned in this call.

Arguments:

				
Return Value:

	STATUS_SUCCESS if successfully completed
	STATUS_PENDING if successfully started
	Error otherwise.

--*/
{
	PVOID				pObject;
	USHORT				ObjectType;
	USHORT				DevType;
	USHORT				bufLen;
    ULONG               BytesWritten;
	NTSTATUS			status = STATUS_SUCCESS;

	PTDI_REQUEST_KERNEL_QUERY_INFORMATION	pQuery;

	pObject = (PVOID)pIrpSp->FileObject->FsContext;
	ObjectType = (USHORT)((ULONG_PTR)(pIrpSp->FileObject->FsContext2) & 0xFF);
	DevType = (USHORT)((ULONG_PTR)(pIrpSp->FileObject->FsContext2) >> 16);

	pQuery = (PTDI_REQUEST_KERNEL_QUERY_INFORMATION)&pIrpSp->Parameters;
    BytesWritten = 0;
	pIrp->IoStatus.Information	= 0;

	bufLen = (USHORT)AtalkSizeMdlChain(pIrp->MdlAddress);
	
	switch (pQuery->QueryType)
	{

	case TDI_QUERY_ADDRESS_INFO:
		if (bufLen < sizeof(TDI_ADDRESS_INFO))
		{
			status	= STATUS_BUFFER_TOO_SMALL;
			break;
		}

		switch (DevType)
		{
		  case ATALK_DEV_DDP:
			ASSERT(ObjectType == TDI_TRANSPORT_ADDRESS_FILE);
			AtalkDdpQuery(pObject,
						  pIrp->MdlAddress,
						  &BytesWritten);

			break;

		  case ATALK_DEV_PAP:
			AtalkPapQuery(pObject,
						  ObjectType,
						  pIrp->MdlAddress,
						  &BytesWritten);
			break;

		  case ATALK_DEV_ADSP:
			AtalkAdspQuery(pObject,
						   ObjectType,
						   pIrp->MdlAddress,
						   &BytesWritten);
			break;

		  case ATALK_DEV_ASPC:
		  case ATALK_DEV_ASP:
			status = STATUS_INVALID_DEVICE_REQUEST;
			break;

		  default:
			// The device type in the Ctx field can never be anything
			// other than the above! Internal protocol error. KeBugCheck.
			DBGPRINT(DBG_COMP_TDI, DBG_LEVEL_ERR,
					("AtalkTdiQueryInformation: Invalid device type\n"));

			status = STATUS_INVALID_DEVICE_REQUEST;
			break;
		}
		break;

	  case TDI_QUERY_CONNECTION_INFO:
		//	Statistics on a connection. Not supported.
		DBGPRINT(DBG_COMP_TDI, DBG_LEVEL_ERR,
			("AtalkTdiQueryInformation: TDI_QUERY_CONNECTION_INFO not supported\n"));
        ASSERT(0);

		status = STATUS_NOT_IMPLEMENTED;
		break;

	  case TDI_QUERY_PROVIDER_INFO:

		if (bufLen < sizeof(TDI_PROVIDER_INFO))
		{
			status	= STATUS_BUFFER_TOO_SMALL;
			break;
		}

		status = TdiCopyBufferToMdl(&pCtx->adc_ProvInfo,
									0,
									sizeof (TDI_PROVIDER_INFO),
									pIrp->MdlAddress,
									0,
									&BytesWritten);
		break;

      case TDI_QUERY_PROVIDER_STATISTICS:

		DBGPRINT(DBG_COMP_TDI, DBG_LEVEL_ERR,
			("AtalkTdiQueryInformation: TDI_QUERY_PROVIDER_STATISTICS not supported\n"));
        ASSERT(0);

		status = STATUS_NOT_IMPLEMENTED;
		break;

	  default:
		status = STATUS_INVALID_DEVICE_REQUEST;
		break;
	}

    pIrp->IoStatus.Information = BytesWritten;
	
	return status;
}




NTSTATUS
AtalkTdiSetInformation(
	IN		PIRP					pIrp,
	IN		PIO_STACK_LOCATION		pIrpSp,
	IN OUT	PATALK_DEV_CTX			pCtx
	)
/*++

Routine Description:

	This routine

Arguments:

				
Return Value:

	STATUS_SUCCESS if successfully completed
	STATUS_PENDING if successfully started
	Error otherwise.

--*/
{
	NTSTATUS	status;


	do
	{
		// Now depending on the requested device...
		switch (pCtx->adc_DevType)
		{
		  case ATALK_DEV_DDP:
		  case ATALK_DEV_PAP:
		  case ATALK_DEV_ADSP:
		  case ATALK_DEV_ASPC:
	        status = STATUS_SUCCESS;
			break;

		  case ATALK_DEV_ASP:
			status = STATUS_INVALID_DEVICE_REQUEST;
			break;

		  default:
			// The device type in the Ctx field can never be anything
			// other than the above! Internal protocol error. KeBugCheck.
			status = STATUS_INVALID_DEVICE_REQUEST;
			DBGPRINT(DBG_COMP_TDI, DBG_LEVEL_ERR,
					("AtalkTdiSetInformation: Invalid device type\n"));
			break;
		}

	} while (FALSE);

	return status;
}




NTSTATUS
AtalkTdiSetEventHandler(
	IN		PIRP					pIrp,
	IN		PIO_STACK_LOCATION		pIrpSp,
	IN OUT	PATALK_DEV_CTX			pCtx
	)
/*++

Routine Description:

	This routine

Arguments:


Return Value:

	STATUS_SUCCESS if successfully completed
	STATUS_PENDING if successfully started
	Error otherwise.

--*/
{
	PVOID				pObject;
	PDDP_ADDROBJ		pDdpAddr;
	PADSP_ADDROBJ		pAdspAddr;
	PPAP_ADDROBJ		pPapAddr;
	PASPC_ADDROBJ		pAspAddr;
	USHORT				objectType;
	USHORT				devType;
	KIRQL				OldIrql;
	NTSTATUS			status = STATUS_SUCCESS;

	do
	{
		PTDI_REQUEST_KERNEL_SET_EVENT parameters = (PTDI_REQUEST_KERNEL_SET_EVENT)&pIrpSp->Parameters;
	
		pObject 	= (PVOID)pIrpSp->FileObject->FsContext;
		objectType 	= (USHORT)((ULONG_PTR)(pIrpSp->FileObject->FsContext2) & 0xFF);
		devType 	= (USHORT)((ULONG_PTR)(pIrpSp->FileObject->FsContext2) >> 16);

		if (objectType != TDI_TRANSPORT_ADDRESS_FILE)
		{
			DBGPRINT(DBG_COMP_TDI, DBG_LEVEL_ERR,
				("AtalkTdiSetEventHandler: returning STATUS_INVALID_ADDRESS\n"));

			status = STATUS_INVALID_ADDRESS;
			break;
		}

		switch (parameters->EventType)
		{
		  case TDI_EVENT_RECEIVE_DATAGRAM:
			if (devType != ATALK_DEV_DDP)
			{
				status = STATUS_INVALID_DEVICE_REQUEST;
				break;
			}

			pDdpAddr = (PDDP_ADDROBJ)pObject;
			if (!(VALID_DDP_ADDROBJ(pDdpAddr)))
            {
                ASSERT(0);
                status = STATUS_INVALID_ADDRESS;
                break;
            }

			ACQUIRE_SPIN_LOCK(&pDdpAddr->ddpao_Lock, &OldIrql);

			//	Allocate event info if null.
			if (pDdpAddr->ddpao_EventInfo == NULL)
			{
				pDdpAddr->ddpao_EventInfo =
					AtalkAllocZeroedMemory(sizeof(DDPEVENT_INFO));
			}

			if (pDdpAddr->ddpao_EventInfo != NULL)
			{
				pDdpAddr->ddpao_Flags |= DDPAO_DGRAM_EVENT;
				if ((pDdpAddr->ddpao_EventInfo->ev_RcvDgramHandler =
							(PTDI_IND_RECEIVE_DATAGRAM)parameters->EventHandler) == NULL)
				{
					pDdpAddr->ddpao_Flags	&= ~DDPAO_DGRAM_EVENT;
				}

				pDdpAddr->ddpao_EventInfo->ev_RcvDgramCtx = parameters->EventContext;
			}
			else
			{
				status = STATUS_INSUFFICIENT_RESOURCES;
			}
			RELEASE_SPIN_LOCK(&pDdpAddr->ddpao_Lock, OldIrql);
			break;

		  case TDI_EVENT_ERROR:
			break;

		  case TDI_EVENT_CONNECT:
			switch (devType)
			{
			  case ATALK_DEV_ADSP:
				pAdspAddr = (PADSP_ADDROBJ)pObject;
				if (!(VALID_ADSPAO(pAdspAddr)))
                {
                    ASSERT(0);
                    status = STATUS_INVALID_ADDRESS;
                    break;
                }

				ACQUIRE_SPIN_LOCK(&pAdspAddr->adspao_Lock, &OldIrql);
				if (pAdspAddr->adspao_Flags & ADSPAO_CONNECT)
				{
					status = STATUS_INVALID_ADDRESS;
				}
				else
				{
					pAdspAddr->adspao_ConnHandler = (PTDI_IND_CONNECT)parameters->EventHandler;
					pAdspAddr->adspao_ConnHandlerCtx = parameters->EventContext;
					pAdspAddr->adspao_Flags	|= ADSPAO_LISTENER;
				}
				RELEASE_SPIN_LOCK(&pAdspAddr->adspao_Lock, OldIrql);
				break;

			  case ATALK_DEV_PAP:
				pPapAddr = (PPAP_ADDROBJ)pObject;
				if (!(VALID_PAPAO(pPapAddr)))
                {
                    ASSERT(0);
                    status = STATUS_INVALID_ADDRESS;
                    break;
                }

				ACQUIRE_SPIN_LOCK(&pPapAddr->papao_Lock, &OldIrql);
				if (pPapAddr->papao_Flags & PAPAO_CONNECT)
				{
					status = STATUS_INVALID_ADDRESS;
				}
				else
				{
					pPapAddr->papao_Flags	|= (PAPAO_LISTENER | PAPAO_UNBLOCKED);

					//	If we are setting a null handler, set it to blocked.
					if ((pPapAddr->papao_ConnHandler = (PTDI_IND_CONNECT)parameters->EventHandler) == NULL)
					{
						//	Oops. block. Dont care about listens being posted here.
						pPapAddr->papao_Flags &= ~PAPAO_UNBLOCKED;
					}

					pPapAddr->papao_ConnHandlerCtx = parameters->EventContext;
				}
				RELEASE_SPIN_LOCK(&pPapAddr->papao_Lock, OldIrql);

				if (NT_SUCCESS(status))
				{
					//	Prime the listener.
					if (!ATALK_SUCCESS(AtalkPapPrimeListener(pPapAddr)))
					{
						TMPLOGERR();
					}
				}
				break;

			  case ATALK_DEV_ASPC:
				// No listens here. Client side only.
				status = STATUS_INVALID_ADDRESS;
				break;

			  default:
				status = STATUS_INVALID_DEVICE_REQUEST;
				break;

			}
			break;

		  case TDI_EVENT_RECEIVE:

			switch (devType)
			{
			  case ATALK_DEV_ADSP:
				pAdspAddr = (PADSP_ADDROBJ)pObject;
				if (!(VALID_ADSPAO(pAdspAddr)))
                {
                    ASSERT(0);
                    status = STATUS_INVALID_ADDRESS;
                    break;
                }

				ACQUIRE_SPIN_LOCK(&pAdspAddr->adspao_Lock, &OldIrql);
				pAdspAddr->adspao_RecvHandler = (PTDI_IND_RECEIVE)parameters->EventHandler;
				pAdspAddr->adspao_RecvHandlerCtx = parameters->EventContext;
				RELEASE_SPIN_LOCK(&pAdspAddr->adspao_Lock, OldIrql);
				break;

			  case ATALK_DEV_PAP:
				pPapAddr = (PPAP_ADDROBJ)pObject;
				if (!(VALID_PAPAO(pPapAddr)))
                {
                    ASSERT(0);
                    status = STATUS_INVALID_ADDRESS;
                    break;
                }

				ACQUIRE_SPIN_LOCK(&pPapAddr->papao_Lock, &OldIrql);
				pPapAddr->papao_RecvHandler = (PTDI_IND_RECEIVE)parameters->EventHandler;
				pPapAddr->papao_RecvHandlerCtx = parameters->EventContext;
				RELEASE_SPIN_LOCK(&pPapAddr->papao_Lock, OldIrql);
				break;

			  case ATALK_DEV_ASPC:
		  		// No receives in asp client
				status	= STATUS_SUCCESS;
				break;

			  default:
				status = STATUS_INVALID_DEVICE_REQUEST;
				break;
			}
			break;

		  case TDI_EVENT_RECEIVE_EXPEDITED:
			switch (devType)
			{
			  case ATALK_DEV_ADSP:
				pAdspAddr = (PADSP_ADDROBJ)pObject;
				if (!(VALID_ADSPAO(pAdspAddr)))
                {
                    ASSERT(0);
                    status = STATUS_INVALID_ADDRESS;
                    break;
                }
	
				ACQUIRE_SPIN_LOCK(&pAdspAddr->adspao_Lock, &OldIrql);
				pAdspAddr->adspao_ExpRecvHandler = (PTDI_IND_RECEIVE_EXPEDITED)parameters->EventHandler;
				pAdspAddr->adspao_ExpRecvHandlerCtx = parameters->EventContext;
				RELEASE_SPIN_LOCK(&pAdspAddr->adspao_Lock, OldIrql);
				break;

			  case ATALK_DEV_ASPC:
				pAspAddr = (PASPC_ADDROBJ)pObject;
				if (!(VALID_ASPCAO(pAspAddr)))
                {
                    ASSERT(0);
                    status = STATUS_INVALID_ADDRESS;
                    break;
                }
	
				ACQUIRE_SPIN_LOCK(&pAspAddr->aspcao_Lock, &OldIrql);
				pAspAddr->aspcao_ExpRecvHandler = (PTDI_IND_RECEIVE_EXPEDITED)parameters->EventHandler;
				pAspAddr->aspcao_ExpRecvHandlerCtx = parameters->EventContext;
				RELEASE_SPIN_LOCK(&pAspAddr->aspcao_Lock, OldIrql);
				break;

			  default:
				status = STATUS_INVALID_DEVICE_REQUEST;
				break;
			}
			break;

		  case TDI_EVENT_DISCONNECT:

			switch (devType)
			{
			  case ATALK_DEV_ADSP:
				pAdspAddr = (PADSP_ADDROBJ)pObject;
				if (!(VALID_ADSPAO(pAdspAddr)))
                {
                    ASSERT(0);
                    status = STATUS_INVALID_ADDRESS;
                    break;
                }

				ACQUIRE_SPIN_LOCK(&pAdspAddr->adspao_Lock, &OldIrql);
				pAdspAddr->adspao_DisconnectHandler = (PTDI_IND_DISCONNECT)parameters->EventHandler;
				pAdspAddr->adspao_DisconnectHandlerCtx = parameters->EventContext;
				RELEASE_SPIN_LOCK(&pAdspAddr->adspao_Lock, OldIrql);
				break;

			  case ATALK_DEV_PAP:
				pPapAddr = (PPAP_ADDROBJ)pObject;
				if (!(VALID_PAPAO(pPapAddr)))
                {
                    ASSERT(0);
                    status = STATUS_INVALID_ADDRESS;
                    break;
                }

				ACQUIRE_SPIN_LOCK(&pPapAddr->papao_Lock, &OldIrql);
				pPapAddr->papao_DisconnectHandler = (PTDI_IND_DISCONNECT)parameters->EventHandler;
				pPapAddr->papao_DisconnectHandlerCtx = parameters->EventContext;
				RELEASE_SPIN_LOCK(&pPapAddr->papao_Lock, OldIrql);
				break;

			  case ATALK_DEV_ASPC:
				pAspAddr = (PASPC_ADDROBJ)pObject;
				if (!(VALID_ASPCAO(pAspAddr)))
                {
                    ASSERT(0);
                    status = STATUS_INVALID_ADDRESS;
                    break;
                }

				ACQUIRE_SPIN_LOCK(&pAspAddr->aspcao_Lock, &OldIrql);
				pAspAddr->aspcao_DisconnectHandler = (PTDI_IND_DISCONNECT)parameters->EventHandler;
				pAspAddr->aspcao_DisconnectHandlerCtx= parameters->EventContext;
				RELEASE_SPIN_LOCK(&pAspAddr->aspcao_Lock, OldIrql);
				break;

			  default:
				status = STATUS_INVALID_DEVICE_REQUEST;
				break;
			}
			break;

		  case TDI_EVENT_SEND_POSSIBLE:

			switch (devType)
			{
			  case ATALK_DEV_ADSP:
				pAdspAddr = (PADSP_ADDROBJ)pObject;
				if (!(VALID_ADSPAO(pAdspAddr)))
                {
                    ASSERT(0);
                    status = STATUS_INVALID_ADDRESS;
                    break;
                }

				ACQUIRE_SPIN_LOCK(&pAdspAddr->adspao_Lock, &OldIrql);
				pAdspAddr->adspao_SendPossibleHandler = (PTDI_IND_SEND_POSSIBLE)parameters->EventHandler;
				pAdspAddr->adspao_SendPossibleHandlerCtx = parameters->EventContext;
				RELEASE_SPIN_LOCK(&pAdspAddr->adspao_Lock, OldIrql);
				break;

			  case ATALK_DEV_PAP:
				pPapAddr = (PPAP_ADDROBJ)pObject;
				if (!(VALID_PAPAO(pPapAddr)))
                {
                    ASSERT(0);
                    status = STATUS_INVALID_ADDRESS;
                    break;
                }

				ACQUIRE_SPIN_LOCK(&pPapAddr->papao_Lock, &OldIrql);
				pPapAddr->papao_SendPossibleHandler	= (PTDI_IND_SEND_POSSIBLE)parameters->EventHandler;
				pPapAddr->papao_SendPossibleHandlerCtx = parameters->EventContext;
				RELEASE_SPIN_LOCK(&pPapAddr->papao_Lock, OldIrql);
				break;

			  case ATALK_DEV_ASPC:
		  		// No sends in asp client
				status	= STATUS_SUCCESS;
				break;

			  default:
				status = STATUS_INVALID_DEVICE_REQUEST;
				break;

			}
			break;

		  default:
			status = STATUS_INVALID_PARAMETER;
		}
	
#if DBG
		//	Avoid assertions in AFD.
		status	= STATUS_SUCCESS;
#endif

	} while (FALSE);

	return status;
}




VOID
AtalkTdiCancel(
	IN OUT	PATALK_DEV_OBJ			pDevObj,
	IN		PIRP					pIrp
	)
/*++

Routine Description:

	This routine handles cancellation of IO requests

Arguments:


Return Value:
--*/
{
	PIO_STACK_LOCATION		pIrpSp;
	PVOID					pObject;
	PATALK_DEV_CTX			pCtx;
    PVOID                   FsContext2;

	pIrpSp 	= IoGetCurrentIrpStackLocation(pIrp);
	pObject = pIrpSp->FileObject->FsContext;
    FsContext2 = pIrpSp->FileObject->FsContext2;
	pCtx	= &pDevObj->Ctx;

	ASSERT(((LONG_PTR)FsContext2 >> 16) == pCtx->adc_DevType);

	IoReleaseCancelSpinLock (pIrp->CancelIrql);

	switch (pCtx->adc_DevType)
	{
        case ATALK_DEV_DDP:
		break;

	  case ATALK_DEV_ASPC:
		if (FsContext2 == (PVOID)((ULONG_PTR)(TDI_CONNECTION_FILE + (pCtx->adc_DevType << 16))))
        {
			 AtalkAspCCleanupConnection((PASPC_CONNOBJ)pObject);
        }

		else
        {
            AtalkAspCCleanupAddress((PASPC_ADDROBJ)pObject);
        }
		break;

	  case ATALK_DEV_ASP:
		// We only handle cancellation of IO requests on connection objects.
		if (FsContext2 == (PVOID)((ULONG_PTR)(TDI_CONNECTION_FILE + (pCtx->adc_DevType << 16))))
			AtalkAspCleanupConnection((PASP_CONNOBJ)pObject);
		break;

	  case ATALK_DEV_PAP:
		if (FsContext2 == (PVOID)((ULONG_PTR)(TDI_CONNECTION_FILE + (pCtx->adc_DevType << 16))))
        {
			 AtalkPapCleanupConnection((PPAP_CONNOBJ)pObject);
        }
		else
        {
            AtalkPapCleanupAddress((PPAP_ADDROBJ)pObject);
        }
		break;

	  case ATALK_DEV_ADSP:
		if (FsContext2 == (PVOID)((ULONG_PTR)(TDI_CONNECTION_FILE + (pCtx->adc_DevType << 16))))
			 AtalkAdspCleanupConnection((PADSP_CONNOBJ)pObject);
		else AtalkAdspCleanupAddress((PADSP_ADDROBJ)pObject);
		break;

      case ATALK_DEV_ARAP:
        ArapCancelIrp(pIrp);
        break;

	  default:
		// The device type in the Ctx field can never be anything
		// other than the above! Internal protocol error.
		DBGPRINT(DBG_COMP_TDI, DBG_LEVEL_ERR,
				("AtalkTdiCancel: Invalid device type\n"));
		break;
	}

}




VOID
AtalkQueryInitProviderInfo(
	IN		ATALK_DEV_TYPE		DeviceType,
	IN OUT	PTDI_PROVIDER_INFO  ProviderInfo
	)
{
	//
	//  Initialize to defaults first
	//

	RtlZeroMemory((PVOID)ProviderInfo, sizeof(TDI_PROVIDER_INFO));

	ProviderInfo->Version = ATALK_TDI_PROVIDERINFO_VERSION;
	KeQuerySystemTime (&ProviderInfo->StartTime);

	switch (DeviceType)
	{
	  case ATALK_DEV_DDP:
		ProviderInfo->MaxDatagramSize = ATALK_DDP_PINFODGRAMSIZE;
		ProviderInfo->ServiceFlags = ATALK_DDP_PINFOSERVICEFLAGS;
		break;

	  case ATALK_DEV_PAP:
		ProviderInfo->MaxSendSize =  ATALK_PAP_PINFOSENDSIZE;
		ProviderInfo->ServiceFlags = ATALK_PAP_PINFOSERVICEFLAGS;
		break;

	  case ATALK_DEV_ADSP:
		ProviderInfo->MaxSendSize =  ATALK_ADSP_PINFOSENDSIZE;
		ProviderInfo->ServiceFlags = ATALK_ADSP_PINFOSERVICEFLAGS;
		break;

	  case ATALK_DEV_ASP:
		ProviderInfo->MaxSendSize =  ATALK_ASP_PINFOSENDSIZE;
		ProviderInfo->ServiceFlags = ATALK_ASP_PINFOSERVICEFLAGS;
		break;

	  case ATALK_DEV_ARAP:
		ProviderInfo->MaxSendSize =  ATALK_ARAP_PINFOSENDSIZE;
		ProviderInfo->ServiceFlags = ATALK_ARAP_PINFOSERVICEFLAGS;
		break;

	  case ATALK_DEV_ASPC:
		ProviderInfo->MaxSendSize =  ATALK_ASP_PINFOSENDSIZE;
		ProviderInfo->ServiceFlags = ATALK_ASP_PINFOSERVICEFLAGS;
		break;


	  default:
		KeBugCheck(0);
	}
}


LOCAL VOID FASTCALL
atalkTdiSendDgramComplete(
	IN	NDIS_STATUS			Status,
	IN	PSEND_COMPL_INFO	pSendInfo
	)
{
	PDDP_ADDROBJ	pAddr = (PDDP_ADDROBJ)(pSendInfo->sc_Ctx1);
	PBUFFER_DESC	pBufDesc = (PBUFFER_DESC)(pSendInfo->sc_Ctx2);
	PIRP			pIrp = (PIRP)(pSendInfo->sc_Ctx3);

	ASSERT(VALID_DDP_ADDROBJ(pAddr));

	DBGPRINT(DBG_COMP_TDI, DBG_LEVEL_ERR,
			("atalkTdiSendDgramComplete: Status %lx, addr %lx\n", Status, pAddr));

	AtalkFreeBuffDesc(pBufDesc);
	pIrp->CancelRoutine = NULL;
	TdiCompleteRequest(pIrp,
					   ((Status == NDIS_STATUS_SUCCESS) ?
						STATUS_SUCCESS: STATUS_UNSUCCESSFUL));
}




LOCAL VOID
atalkTdiRecvDgramComplete(
	IN	ATALK_ERROR		ErrorCode,
	IN	PAMDL			pReadBuf,
	IN	USHORT			ReadLen,
	IN	PATALK_ADDR		pSrcAddr,
	IN	PIRP			pIrp
	)
{
	PIO_STACK_LOCATION 				pIrpSp;
	PTDI_REQUEST_KERNEL_RECEIVEDG	parameters;
	PTDI_CONNECTION_INFORMATION		returnInfo;
	PTA_APPLETALK_ADDRESS			remoteAddress;


	DBGPRINT(DBG_COMP_TDI, DBG_LEVEL_ERR,
			("atalkTdiRecvDgramComplete: %lx\n", ErrorCode));

	pIrpSp 		= IoGetCurrentIrpStackLocation(pIrp);
	parameters 	= (PTDI_REQUEST_KERNEL_RECEIVEDG)&pIrpSp->Parameters;

	//	Set length in the info field and call the completion routine.
	pIrp->CancelRoutine = NULL;
	pIrp->IoStatus.Information	= (ULONG)ReadLen;

	if (ATALK_SUCCESS(ErrorCode))
	{
		ASSERT(parameters != NULL);

		if (parameters != NULL)
		{
			parameters->ReceiveLength = (ULONG)ReadLen;

            try {
			    returnInfo =
				    (PTDI_CONNECTION_INFORMATION)parameters->ReturnDatagramInformation;

			    ASSERT(returnInfo != NULL);
			    if (returnInfo != NULL)
			    {
				    if (returnInfo->RemoteAddressLength >= sizeof(TA_APPLETALK_ADDRESS))
				    {
					    //  Fill in the remote address
					    remoteAddress = (PTA_APPLETALK_ADDRESS)returnInfo->RemoteAddress;

					    ASSERT(remoteAddress != NULL);
					    if (remoteAddress != NULL)
					    {
						    //	Copy the remote address from where the datagram was received
						    ATALKADDR_TO_TDI(
							    remoteAddress,
							    pSrcAddr);

						    DBGPRINT(DBG_COMP_DDP, DBG_LEVEL_ERR,
								("AtalkAddrRecvDgComp - Net %x Node %x Socket %x\n",
									remoteAddress->Address[0].Address[0].Network,
									remoteAddress->Address[0].Address[0].Node,
									remoteAddress->Address[0].Address[0].Socket));
					    }
				    }
			    }
            } except( EXCEPTION_EXECUTE_HANDLER ) {

                ErrorCode = GetExceptionCode();

	            DBGPRINT(DBG_COMP_TDI, DBG_LEVEL_ERR,
			        ("atalkTdiRecvDgramComplete: exception occured %lx\n", ErrorCode));
            }
		}
	}

	ASSERT (ErrorCode != ATALK_PENDING);
	TdiCompleteRequest(pIrp, AtalkErrorToNtStatus(ErrorCode));
}




LOCAL VOID
atalkTdiActionComplete(
	IN	ATALK_ERROR	ErrorCode,
	IN	PACTREQ		pActReq
	)
{
	PIRP	pIrp = pActReq->ar_pIrp;

	ASSERT (VALID_ACTREQ(pActReq));

	if (pActReq->ar_pAMdl != NULL)
		AtalkFreeAMdl(pActReq->ar_pAMdl);
	AtalkFreeMemory(pActReq);

	pIrp->CancelRoutine = NULL;
	ASSERT (ErrorCode != ATALK_PENDING);
	TdiCompleteRequest(pIrp, AtalkErrorToNtStatus(ErrorCode));
}




LOCAL VOID
atalkTdiGenericComplete(
	IN	ATALK_ERROR	ErrorCode,
	IN	PIRP		pIrp
	)
{
	DBGPRINT(DBG_COMP_TDI, DBG_LEVEL_INFO,
			("atalkTdiGenericComplete: Completing %lx with %lx\n",
				pIrp, AtalkErrorToNtStatus(ErrorCode)));

	pIrp->CancelRoutine = NULL;
	ASSERT (ErrorCode != ATALK_PENDING);
	TdiCompleteRequest(pIrp, AtalkErrorToNtStatus(ErrorCode));
}



LOCAL VOID
atalkTdiCloseAddressComplete(
	IN	ATALK_ERROR	ErrorCode,
	IN	PIRP		pIrp
	)
{
	DBGPRINT(DBG_COMP_TDI, DBG_LEVEL_INFO,
			("atalkTdiCloseAddressComplete: Completing %lx with %lx\n",
			pIrp, AtalkErrorToNtStatus(ErrorCode)));

	pIrp->CancelRoutine = NULL;
	ASSERT (ErrorCode != ATALK_PENDING);
	AtalkUnlockTdiIfNecessary();

	TdiCompleteRequest(pIrp, AtalkErrorToNtStatus(ErrorCode));
}



LOCAL VOID
atalkTdiGenericReadComplete(
	IN	ATALK_ERROR	ErrorCode,
	IN 	PAMDL		ReadBuf,
	IN 	USHORT		ReadLen,
	IN 	ULONG		ReadFlags,
	IN 	PIRP		pIrp
	)
{
	ASSERT(pIrp->IoStatus.Status != STATUS_UNSUCCESSFUL);

	DBGPRINT(DBG_COMP_TDI, DBG_LEVEL_INFO,
			("atalkTdiGenericReadComplete: Irp %lx Status %lx Info %lx\n",
				pIrp, pIrp->IoStatus.Status, ReadLen));

	pIrp->CancelRoutine = NULL;
	pIrp->IoStatus.Information	= (ULONG)ReadLen;
	ASSERT (ErrorCode != ATALK_PENDING);

	TdiCompleteRequest(pIrp, AtalkErrorToNtStatus(ErrorCode));
}




VOID
atalkTdiGenericWriteComplete(
	IN	ATALK_ERROR	ErrorCode,
	IN 	PAMDL		WriteBuf,
	IN 	USHORT		WriteLen,
	IN	PIRP		pIrp
	)
{
	ASSERT(pIrp->IoStatus.Status != STATUS_UNSUCCESSFUL);

	if (pIrp->IoStatus.Status == STATUS_UNSUCCESSFUL)
	{
		DBGPRINT(DBG_COMP_TDI, DBG_LEVEL_ERR,
				("atalkTdiGenericWriteComplete: Irp %lx Status %lx Info %lx\n",
				pIrp, pIrp->IoStatus.Status, WriteLen));
	}

	DBGPRINT(DBG_COMP_TDI, DBG_LEVEL_INFO,
			("atalkTdiGenericWriteComplete: Irp %lx Status %lx Info %lx\n",
				pIrp, pIrp->IoStatus.Status, WriteLen));

	pIrp->CancelRoutine = NULL;
	pIrp->IoStatus.Information	= (ULONG)WriteLen;
	ASSERT (ErrorCode != ATALK_PENDING);
	TdiCompleteRequest(pIrp, AtalkErrorToNtStatus(ErrorCode));
}


LOCAL VOID
atalkQueuedLockUnlock(
	IN	PQLU		pQLU
)
{
	ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

	AtalkLockUnlock(FALSE,
					pQLU->qlu_pLockSection);
	AtalkPortDereference(pQLU->qlu_pPortDesc);
	AtalkFreeMemory(pQLU);
}


VOID
AtalkLockInit(
	IN	PLOCK_SECTION	pLs,
	IN	PVOID			Address
)
{
	pLs->ls_LockHandle = MmLockPagableCodeSection(Address);
	MmUnlockPagableImageSection(pLs->ls_LockHandle);
}


VOID
AtalkLockUnlock(
	IN	BOOLEAN			Lock,
	IN	PLOCK_SECTION	pLs
	)
{
	KIRQL	OldIrql;
	BOOLEAN	DoForReal;

	// We cannot call the MmLock/MmUnlock routines at Dpc. So if we are called at
	// DISPATCH, just queue ourselves. Also we only get unlock requests at DISPATCH,
	// Lock requests are only at LOW_LEVEL. So failure to allocate memory can be
	// IGNORED since that will only have the effect of failure to unlock.
	if (KeGetCurrentIrql() == DISPATCH_LEVEL)
	{
		PQLU		pQLU;
		ATALK_ERROR	Error;

		ASSERT (!Lock || (pLs->ls_LockCount > 0));

		if (Lock)
		{
			ASSERT (pLs->ls_LockCount > 0);
			ACQUIRE_SPIN_LOCK_DPC(&AtalkPgLkLock);
			pLs->ls_LockCount ++;
			RELEASE_SPIN_LOCK_DPC(&AtalkPgLkLock);
		}
		else
		{
			if ((pQLU = AtalkAllocMemory(sizeof(QLU))) != NULL)
			{
				pQLU->qlu_pPortDesc = AtalkPortList;
				AtalkPortReferenceByPtrDpc(pQLU->qlu_pPortDesc, &Error);
				if (ATALK_SUCCESS(Error))
				{
					pQLU->qlu_pLockSection = pLs;
		
					ExInitializeWorkItem(&pQLU->qlu_WQI, atalkQueuedLockUnlock, pQLU);
					ExQueueWorkItem(&pQLU->qlu_WQI, CriticalWorkQueue);
				}
				else
				{
					AtalkFreeMemory(pQLU);
				}
			}
		}
		return;									
	}

	ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

	// We need to serialize the operations here. Note that a spin-lock will not do the
	// job since the MmLock/MmUnlock routines cannot be called with the spin-lock held
	KeWaitForSingleObject(&AtalkPgLkMutex,
						  Executive,
						  KernelMode,
						  TRUE,
						  (PLARGE_INTEGER)NULL);

	ASSERT (pLs->ls_LockHandle != NULL);

	DoForReal = FALSE;
	ACQUIRE_SPIN_LOCK(&AtalkPgLkLock, &OldIrql);

	if (Lock)
	{
		if (pLs->ls_LockCount == 0)
		{
			DBGPRINT(DBG_COMP_TDI, DBG_LEVEL_WARN,
					("AtalkLockUnlock: Locking %d\n", pLs - AtalkPgLkSection));
			DoForReal = TRUE;
		}
		pLs->ls_LockCount ++;
	}
	else
	{
		ASSERT (pLs->ls_LockCount > 0);

		pLs->ls_LockCount --;
		if (pLs->ls_LockCount == 0)
		{
			DBGPRINT(DBG_COMP_TDI, DBG_LEVEL_WARN,
					("AtalkLockUnlock: Unlocking %d\n", pLs - AtalkPgLkSection));
			DoForReal = TRUE;
		}
	}

	RELEASE_SPIN_LOCK(&AtalkPgLkLock, OldIrql);

	if (DoForReal)
	{
		if (Lock)
		{
			MmLockPagableSectionByHandle(pLs->ls_LockHandle);
		}
		else
		{
			MmUnlockPagableImageSection(pLs->ls_LockHandle);
		}
	}

	// LeaveCriticalSection
	KeReleaseMutex(&AtalkPgLkMutex, FALSE);
}


VOID
atalkWaitDefaultPort(
	VOID
)
{
	TIME		Time;
#define	ONE_SEC_IN_100ns		-10000000L		// 1sec in 100ns units

	if ((AtalkDefaultPort == NULL) ||
		((AtalkDefaultPort->pd_Flags & (PD_USER_NODE_1 | PD_USER_NODE_2)) == 0))
	{
		// Make sure we can indeed wait
		ASSERT (KeGetCurrentIrql() == LOW_LEVEL);
	
		Time.QuadPart = Int32x32To64((LONG)20, ONE_SEC_IN_100ns);
		KeWaitForSingleObject(&AtalkDefaultPortEvent, Executive, KernelMode, FALSE, &Time);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\atalk\sys\atkquery.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

	atkquery.h

Abstract:

	TDI Query/Statistics header file

Author:

	Nikhil Kamkolkar (nikhilk@microsoft.com)

Revision History:
	10 Jul 1992	 Initial Version

--*/

#ifndef	_ATKQUERY_
#define	_ATKQUERY_

#define ATALK_TDI_PROVIDERINFO_VERSION		0x0001

#define ATALK_DDP_PINFODGRAMSIZE			586
#define ATALK_DDP_PINFOSERVICEFLAGS			(TDI_SERVICE_CONNECTIONLESS_MODE	| \
											 TDI_SERVICE_BROADCAST_SUPPORTED	| \
											 TDI_SERVICE_FORCE_ACCESS_CHECK)

#define ATALK_ATP_PINFOSENDSIZE				0
#define ATALK_ATP_PINFOSERVICEFLAGS			(TDI_SERVICE_FORCE_ACCESS_CHECK)

#define ATALK_ADSP_PINFOSENDSIZE			0
#define ATALK_ADSP_PINFOSERVICEFLAGS		(TDI_SERVICE_CONNECTION_MODE		| \
											 TDI_SERVICE_ERROR_FREE_DELIVERY	| \
											 TDI_SERVICE_EXPEDITED_DATA			| \
											 TDI_SERVICE_INTERNAL_BUFFERING		| \
											 TDI_SERVICE_FORCE_ACCESS_CHECK)

#define ATALK_ASP_PINFOSENDSIZE				0
#define ATALK_ASP_PINFOSERVICEFLAGS			(TDI_SERVICE_FORCE_ACCESS_CHECK)

#define ATALK_PAP_PINFOSENDSIZE				0
#define ATALK_PAP_PINFOSERVICEFLAGS			(TDI_SERVICE_CONNECTION_MODE		| \
											 TDI_SERVICE_ERROR_FREE_DELIVERY	| \
											 TDI_SERVICE_EXPEDITED_DATA			| \
											 TDI_SERVICE_INTERNAL_BUFFERING		| \
											 TDI_SERVICE_FORCE_ACCESS_CHECK)

#define ATALK_ARAP_PINFOSENDSIZE			0
#define ATALK_ARAP_PINFOSERVICEFLAGS		(TDI_SERVICE_FORCE_ACCESS_CHECK)

//
//	ROUTINE PROTOTYPES
//

VOID
AtalkQueryInitProviderInfo(
	IN		ATALK_DEV_TYPE		DeviceType,
	IN OUT	PTDI_PROVIDER_INFO  ProviderInfo
);

#endif	// _ATKQUERY_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\atalk\sys\atktimer.c ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	atktimer.c

Abstract:

	This file implements the timer routines used by the stack.

Author:

	Jameel Hyder (jameelh@microsoft.com)
	Nikhil Kamkolkar (nikhilk@microsoft.com)


Revision History:
	23 Feb 1993		Initial Version

Notes:	Tab stop: 4
--*/

#include <atalk.h>
#pragma hdrstop
#define	FILENUM	ATKTIMER


//  Discardable code after Init time
#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, AtalkTimerInit)
#pragma alloc_text(PAGEINIT, AtalkTimerFlushAndStop)
#endif

/***	AtalkTimerInit
 *
 *	Initialize the timer component for the appletalk stack.
 */
NTSTATUS
AtalkTimerInit(
	VOID
)
{
	BOOLEAN	TimerStarted;

	// Initialize the timer and its associated Dpc and kick it off
	KeInitializeEvent(&atalkTimerStopEvent, NotificationEvent, FALSE);
	KeInitializeTimer(&atalkTimer);
	INITIALIZE_SPIN_LOCK(&atalkTimerLock);
	KeInitializeDpc(&atalkTimerDpc, atalkTimerDpcRoutine, NULL);
	atalkTimerTick.QuadPart = ATALK_TIMER_TICK;
	TimerStarted = KeSetTimer(&atalkTimer,
							  atalkTimerTick,
							  &atalkTimerDpc);
	ASSERT(!TimerStarted);

	return STATUS_SUCCESS;
}


/***	AtalkTimerScheduleEvent
 *
 *	Insert an event in the timer event list. If the list is empty, then
 *	fire off a timer. The time is specified in ticks. Each tick is currently
 *	100ms. It may not be zero or negative. The internal timer also fires at
 *	100ms granularity.
 */
VOID FASTCALL
AtalkTimerScheduleEvent(
	IN	PTIMERLIST			pList			// TimerList to use for queuing
)
{
	KIRQL	OldIrql;

	DBGPRINT(DBG_COMP_SYSTEM, DBG_LEVEL_INFO,
			("AtalkTimerScheduleEvent: pList %lx\n", pList));

	ASSERT(VALID_TMR(pList));
	ASSERT (pList->tmr_Routine != NULL);
	ASSERT (pList->tmr_AbsTime != 0);

	if (!atalkTimerStopped)
	{
		ACQUIRE_SPIN_LOCK(&atalkTimerLock, &OldIrql);
		
		// Enqueue this handler
		atalkTimerEnqueue(pList);

		RELEASE_SPIN_LOCK(&atalkTimerLock, OldIrql);
	}
	else
	{
		DBGPRINT(DBG_COMP_SYSTEM, DBG_LEVEL_FATAL,
				("AtalkTimerScheduleEvent: Called after Flush !!\n"));
	}
}



/***	atalkTimerDpcRoutine
 *
 *	This is called in at DISPATCH_LEVEL when the timer expires. The entry at
 *	the head of the list is decremented and if ZERO unlinked and dispatched.
 *	If the list is non-empty, the timer is fired again.
 */
LOCAL VOID
atalkTimerDpcRoutine(
	IN	PKDPC	pKDpc,
	IN	PVOID	pContext,
	IN	PVOID	SystemArgument1,
	IN	PVOID	SystemArgument2
)
{
	PTIMERLIST	pList;
	BOOLEAN		TimerStarted;
	LONG		ReQueue;

	pKDpc; pContext; SystemArgument1; SystemArgument2;

	if (atalkTimerStopped)
	{
		DBGPRINT(DBG_COMP_SYSTEM, DBG_LEVEL_ERR,
				("atalkTimerDpc: Enetered after Flush !!!\n"));
		return;
	}

	ACQUIRE_SPIN_LOCK_DPC(&atalkTimerLock);

	AtalkTimerCurrentTick ++;	// Update our relative time

	// We should never be here if we have no work to do
	if ((atalkTimerList != NULL))
	{
		// Careful here. If two guys wanna go off together - let them !!
		if (atalkTimerList->tmr_RelDelta != 0)
			(atalkTimerList->tmr_RelDelta)--;
	
		// Dispatch the entry if it is ready to go
		pList = atalkTimerList;
		if (pList->tmr_RelDelta == 0)
		{
			ASSERT(VALID_TMR(pList));

			// Unlink from the list
			// AtalkUnlinkDouble(pList, tmr_Next, tmr_Prev);
			atalkTimerList = pList->tmr_Next;
			if (atalkTimerList != NULL)
				atalkTimerList->tmr_Prev = &atalkTimerList;

			pList->tmr_Queued = FALSE;
			pList->tmr_Running = TRUE;
			atalkTimerRunning = TRUE;

			DBGPRINT(DBG_COMP_SYSTEM, DBG_LEVEL_INFO,
					("atalkTimerDpcRoutine: Dispatching %lx\n", pList->tmr_Routine));

			RELEASE_SPIN_LOCK_DPC(&atalkTimerLock);

			ReQueue = (*pList->tmr_Routine)(pList, FALSE);

			ACQUIRE_SPIN_LOCK_DPC(&atalkTimerLock);

			atalkTimerRunning = FALSE;

			if (ReQueue != ATALK_TIMER_NO_REQUEUE)
			{
				ASSERT(VALID_TMR(pList));

				pList->tmr_Running = FALSE;
				if (pList->tmr_CancelIt)
				{
					DBGPRINT(DBG_COMP_SYSTEM, DBG_LEVEL_INFO,
							("atalkTimerDpcRoutine: Delayed cancel for %lx\n", pList));

					RELEASE_SPIN_LOCK_DPC(&atalkTimerLock);

					ReQueue = (*pList->tmr_Routine)(pList, TRUE);

					ACQUIRE_SPIN_LOCK_DPC(&atalkTimerLock);

					ASSERT(ReQueue == ATALK_TIMER_NO_REQUEUE);
				}
				else
				{
					if (ReQueue != ATALK_TIMER_REQUEUE)
						pList->tmr_AbsTime = (USHORT)ReQueue;
					atalkTimerEnqueue(pList);
				}
			}
		}
	}

	RELEASE_SPIN_LOCK_DPC(&atalkTimerLock);

	if (!atalkTimerStopped)
	{
		TimerStarted = KeSetTimer(&atalkTimer,
								  atalkTimerTick,
								  &atalkTimerDpc);
		ASSERT(!TimerStarted);
	}
	else
	{
		KeSetEvent(&atalkTimerStopEvent, IO_NETWORK_INCREMENT, FALSE);
	}
}


/***	atalkTimerEnqueue
 *
 *	Here is a thesis on the code that follows.
 *
 *	The timer events are maintained as a list which the timer dpc routine
 *	looks at every timer tick. The list is maintained in such a way that only
 *	the head of the list needs to be updated every tick i.e. the entire list
 *	is never scanned. The way this is achieved is by keeping delta times
 *	relative to the previous entry.
 *
 *	Every timer tick, the relative time at the head of the list is decremented.
 *	When that goes to ZERO, the head of the list is unlinked and dispatched.
 *
 *	To give an example, we have the following events queued at time slots
 *	X			Schedule A after 10 ticks.
 *	X+3			Schedule B after 5  ticks.
 *	X+5			Schedule C after 4  ticks.
 *	X+8			Schedule D after 6  ticks.
 *
 *	So A will schedule at X+10, B at X+8 (X+3+5), C at X+9 (X+5+4) and
 *	D at X+14 (X+8+6).
 *
 *	The above example covers all the situations.
 *
 *	- NULL List.
 *	- Inserting at head of list.
 *	- Inserting in the middle of the list.
 *	- Appending to the list tail.
 *
 *	The list will look as follows.
 *
 *		    BEFORE                          AFTER
 *		    ------                          -----
 *
 *    X   Head -->|                  Head -> A(10) ->|
 *    A(10)
 *
 *    X+3 Head -> A(7) ->|           Head -> B(5) -> A(2) ->|
 *    B(5)
 *
 *    X+5 Head -> B(3) -> A(2) ->|   Head -> B(3) -> C(1) -> A(1) ->|
 *    C(4)
 *
 *    X+8 Head -> C(1) -> A(1) ->|   Head -> C(1) -> A(1) -> D(4) ->|
 *    D(6)
 *
 *	The granularity is one tick. THIS MUST BE CALLED WITH THE TIMER LOCK HELD.
 */
VOID FASTCALL
atalkTimerEnqueue(
	IN	PTIMERLIST	pListNew
)
{
	PTIMERLIST	pList, *ppList;
	USHORT		DeltaTime = pListNew->tmr_AbsTime;

	// The DeltaTime is adjusted in every pass of the loop to reflect the
	// time after the previous entry that the new entry will schedule.
	for (ppList = &atalkTimerList;
		 (pList = *ppList) != NULL;
		 ppList = &pList->tmr_Next)
	{
		ASSERT(VALID_TMR(pList));
		if (DeltaTime <= pList->tmr_RelDelta)
		{
			pList->tmr_RelDelta -= DeltaTime;
			break;
		}
		DeltaTime -= pList->tmr_RelDelta;
	}
	

	// Link this in the chain
	pListNew->tmr_RelDelta = DeltaTime;
	pListNew->tmr_Next = pList;
	pListNew->tmr_Prev = ppList;
	*ppList = pListNew;
	if (pList != NULL)
	{
		pList->tmr_Prev = &pListNew->tmr_Next;
	}

	pListNew->tmr_Queued = TRUE;
	pListNew->tmr_Cancelled = FALSE;
	pListNew->tmr_CancelIt = FALSE;
}


/***	AtalkTimerFlushAndStop
 *
 *	Force all entries in the timer queue to be dispatched immediately. No
 *	more queue'ing of timer routines is permitted after this. The timer
 *	essentially shuts down.
 */
VOID
AtalkTimerFlushAndStop(
	VOID
)
{
	PTIMERLIST	pList;
	LONG		ReQueue;
	KIRQL		OldIrql;
	BOOLEAN		Wait;

	ASSERT (KeGetCurrentIrql() == LOW_LEVEL);

	DBGPRINT(DBG_COMP_SYSTEM, DBG_LEVEL_ERR,
			("AtalkTimerFlushAndStop: Entered\n"));

	KeCancelTimer(&atalkTimer);

	// The timer routines assume they are being called at DISPATCH level.
	// Raise our Irql for this routine.
	KeRaiseIrql(DISPATCH_LEVEL, &OldIrql);

	ACQUIRE_SPIN_LOCK_DPC(&atalkTimerLock);

	atalkTimerStopped = TRUE;
	Wait = atalkTimerRunning;

	// Dispatch all entries right away
	while (atalkTimerList != NULL)
	{
		pList = atalkTimerList;
		ASSERT(VALID_TMR(pList));
		atalkTimerList = pList->tmr_Next;

		DBGPRINT(DBG_COMP_SYSTEM, DBG_LEVEL_INFO,
				("atalkTimerFlushAndStop: Dispatching %lx\n",
				pList->tmr_Routine));

		pList->tmr_Queued = FALSE;
		pList->tmr_Running = TRUE;

		RELEASE_SPIN_LOCK_DPC(&atalkTimerLock);

		ReQueue = (*pList->tmr_Routine)(pList, TRUE);

		ASSERT (ReQueue == ATALK_TIMER_NO_REQUEUE);

		pList->tmr_Running = FALSE;
		ACQUIRE_SPIN_LOCK_DPC(&atalkTimerLock);
	}

	RELEASE_SPIN_LOCK_DPC(&atalkTimerLock);

	KeLowerIrql(OldIrql);

	if (Wait)
	{
		// Wait for any timer events that are currently running. Only an MP issue
		KeWaitForSingleObject(&atalkTimerStopEvent,
							  Executive,
							  KernelMode,
							  TRUE,
							  NULL);
	}
}


/***	AtalkTimerCancelEvent
 *
 *	Cancel a previously scheduled timer event, if it hasn't fired already.
 */
BOOLEAN FASTCALL
AtalkTimerCancelEvent(
	IN	PTIMERLIST			pList,
	IN	PDWORD              pdwOldState
)
{
	KIRQL	OldIrql;
	BOOLEAN	Cancelled = FALSE;
    DWORD   OldState=ATALK_TIMER_QUEUED;


	ACQUIRE_SPIN_LOCK(&atalkTimerLock, &OldIrql);

	// If this is not running, unlink it from the list
	// adjusting relative deltas carefully
	if (pList->tmr_Queued)
	{
		ASSERT (!(pList->tmr_Running));

        OldState = ATALK_TIMER_QUEUED;

		if (pList->tmr_Next != NULL)
		{
			pList->tmr_Next->tmr_RelDelta += pList->tmr_RelDelta;
			pList->tmr_Next->tmr_Prev = pList->tmr_Prev;
		}

		*(pList->tmr_Prev) = pList->tmr_Next;

		// pointing to timer being removed? fix it!
		if (atalkTimerList == pList)
		{
			atalkTimerList = pList->tmr_Next;
		}

		Cancelled = pList->tmr_Cancelled = TRUE;

		pList->tmr_Queued = FALSE;

	}
	else if (pList->tmr_Running)
	{
		DBGPRINT(DBG_COMP_SYSTEM, DBG_LEVEL_ERR,
				("AtalkTimerCancelEvent: %lx Running, cancel set\n",
				pList->tmr_Routine));
		pList->tmr_CancelIt = TRUE;		// Set to cancel after handler returns.

        OldState = ATALK_TIMER_RUNNING;
	}

	RELEASE_SPIN_LOCK(&atalkTimerLock, OldIrql);

    if (pdwOldState)
    {
        *pdwOldState = OldState;
    }

	return Cancelled;
}


#if	DBG

VOID
AtalkTimerDumpList(
	VOID
)
{
	PTIMERLIST	pList;
	ULONG		CumTime = 0;

	DBGPRINT(DBG_COMP_DUMP, DBG_LEVEL_FATAL,
			("TIMER LIST: (Times are in 100ms units)\n"));
	DBGPRINT(DBG_COMP_DUMP, DBG_LEVEL_FATAL,
			("\tTime(Abs)  Time(Rel)  Routine Address  TimerList\n"));

	ACQUIRE_SPIN_LOCK_DPC(&atalkTimerLock);

	for (pList = atalkTimerList;
		 pList != NULL;
		 pList = pList->tmr_Next)
	{
		CumTime += pList->tmr_RelDelta;
		DBGPRINT(DBG_COMP_DUMP, DBG_LEVEL_FATAL,
				("\t    %5d      %5ld          %lx   %lx\n",
				pList->tmr_AbsTime, CumTime,
				pList->tmr_Routine, pList));
	}

	RELEASE_SPIN_LOCK_DPC(&atalkTimerLock);
}

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\atalk\sys\atktimer.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

	atktimer.h

Abstract:

	This module contains routines to schedule timer events.

Author:

	Jameel Hyder (jameelh@microsoft.com)
	Nikhil Kamkolkar (nikhilk@microsoft.com)

Revision History:
	19 Jun 1992		Initial Version

Notes:	Tab stop: 4
--*/

#ifndef	_ATKTIMER_
#define	_ATKTIMER_

struct _TimerList;

typedef	LONG (FASTCALL * TIMER_ROUTINE)(IN struct _TimerList *pTimer, IN BOOLEAN TimerShuttingDown);

#define	TMR_SIGNATURE		*(PULONG)"ATMR"
#if	DBG
#define	VALID_TMR(pTmr)		(((pTmr) != NULL) && \
							 ((pTmr)->tmr_Signature == TMR_SIGNATURE))
#else
#define	VALID_TMR(pTmr)		((pTmr) != NULL)
#endif
typedef	struct _TimerList
{
#if	DBG
	ULONG					tmr_Signature;
#endif
	struct _TimerList *		tmr_Next;		// Link to next
	struct _TimerList **	tmr_Prev;		// Link to prev
	TIMER_ROUTINE			tmr_Routine;	// Timer routine
	SHORT					tmr_AbsTime;	// Absolute time, for re-enqueue
	SHORT					tmr_RelDelta;	// Relative to the previous entry
	union
	{
		struct
		{
			BOOLEAN			tmr_Queued;		// TRUE, if currently queued
			BOOLEAN			tmr_Cancelled;	// TRUE, if cancelled
			BOOLEAN			tmr_Running;	// TRUE, if currently running
			BOOLEAN			tmr_CancelIt;	// TRUE, if cancel called while active
		};
		DWORD				tmr_Bools;		// For clearing all
	};
} TIMERLIST, *PTIMERLIST;

extern
NTSTATUS
AtalkTimerInit(
	VOID
);

/***	AtalkTimerInitialize
 *
 *	Initialize the timer list structure.
extern
VOID
AtalkTimerInitialize(
 IN	PTIMERLIST			pList,			// TimerList to use for queuing
 IN	TIMER_ROUTINE		TimerRoutine,	// TimerRoutine
 IN	SHORT				DeltaTime		// Schedule after this much time
);
 */

#if DBG
#define	AtalkTimerInitialize(pList, TimerRoutine, DeltaTime)	\
	{															\
		(pList)->tmr_Signature = TMR_SIGNATURE;					\
		(pList)->tmr_Routine = TimerRoutine;					\
		(pList)->tmr_AbsTime = DeltaTime;						\
		(pList)->tmr_Bools = 0;									\
	}
#else
#define	AtalkTimerInitialize(pList, TimerRoutine, DeltaTime)	\
	{															\
		(pList)->tmr_Routine = TimerRoutine;					\
		(pList)->tmr_AbsTime = DeltaTime;						\
		(pList)->tmr_Bools = 0;									\
	}
#endif

extern
VOID FASTCALL
AtalkTimerScheduleEvent(
	IN	PTIMERLIST			pTimerList		// TimerList to use for queuing
);

extern
VOID
AtalkTimerFlushAndStop(
	VOID
);

extern
BOOLEAN FASTCALL
AtalkTimerCancelEvent(
	IN	PTIMERLIST			pTimerList,		// TimerList used for queuing
	IN	PDWORD              pdwOldState     // return old state
);

#define	AtalkTimerSetAbsTime(pTimerList, AbsTime)	\
	{												\
		ASSERT(!(pTimerList)->tmr_Queued);			\
		(pTimerList)->tmr_AbsTime = AbsTime;		\
	}

extern	LONG					AtalkTimerCurrentTick;

#define	AtalkGetCurrentTick()	AtalkTimerCurrentTick

// Keep this at 100ms unit
#define	ATALK_TIMER_FACTOR		10			// i.e. 10 ticks per second
#define	ATALK_TIMER_TICK		-1000000L	// 100ms in 100ns units
#define	ATALK_TIMER_NO_REQUEUE	0			// Do not re-enqueue
#define	ATALK_TIMER_REQUEUE		-1			// Re-enqueue at current count

#define ATALK_TIMER_QUEUED      1
#define ATALK_TIMER_RUNNING     2
#define ATALK_TIMER_CANCELLED   3


extern	PTIMERLIST			atalkTimerList;
extern	ATALK_SPIN_LOCK		atalkTimerLock;
extern	LARGE_INTEGER		atalkTimerTick;
extern	KTIMER				atalkTimer;
extern	KDPC				atalkTimerDpc;
extern	KEVENT				atalkTimerStopEvent;
extern	BOOLEAN				atalkTimerStopped;	// Set to TRUE if timer system stopped
extern	BOOLEAN				atalkTimerRunning;	// Set to TRUE when timer Dpc is running

LOCAL VOID
atalkTimerDpcRoutine(
	IN	PKDPC				pKDpc,
	IN	PVOID				pContext,
	IN	PVOID				SystemArgument1,
	IN	PVOID				SystemArgument2
);

LOCAL VOID FASTCALL
atalkTimerEnqueue(
	IN	PTIMERLIST	pList
);

#endif	// _ATKTIMER_



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\atalk\sys\atktypes.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

	atktypes.h

Abstract:

	This module contains the type definitions for the Appletalk protocol.

Author:

	Jameel Hyder (jameelh@microsoft.com)
	Nikhil Kamkolkar (nikhilk@microsoft.com)

Revision History:
	19 Jun 1992		Initial Version

Notes:	Tab stop: 4
--*/

#ifndef	_ATKTYPES_
#define	_ATKTYPES_

#ifndef PBYTE
typedef	UCHAR	BYTE, *PBYTE;
#endif

#ifndef	DWORD
typedef	ULONG	DWORD, *PDWORD;
#endif

//	Define our opaque type. On NT, this will just be an MDL.
typedef		MDL		AMDL, *PAMDL;

//	Logical protocol types - #defines for compiler warnings...
typedef	BYTE				LOGICAL_PROTOCOL, *PLOGICAL_PROTOCOL;
#define	UNKNOWN_PROTOCOL	0
#define	APPLETALK_PROTOCOL	1
#define	AARP_PROTOCOL		2


//	Appletalk Node address: Includes the network number
typedef	struct _ATALK_NODEADDR
{
	USHORT			atn_Network;
	BYTE			atn_Node;
} ATALK_NODEADDR, *PATALK_NODEADDR;

#define	NODEADDR_EQUAL(NodeAddr1, NodeAddr2)	\
				(((NodeAddr1)->atn_Network == (NodeAddr2)->atn_Network) &&	\
				 ((NodeAddr1)->atn_Node == (NodeAddr2)->atn_Node))

//	Appletalk internet address: This is similar to what is in the
//	TDI Appletalk address definition. We do not use that directly
//	because of the naming convention differences. We will instead
//	have macros to convert from one to the other.
typedef	union _ATALK_ADDR
{
	struct
	{
		USHORT		ata_Network;
		BYTE		ata_Node;
		BYTE		ata_Socket;
	};
	ULONG			ata_Address;
} ATALK_ADDR, *PATALK_ADDR;

//	Appletalk Network range structure
typedef struct _ATALK_NETWORKRANGE
{
	USHORT	anr_FirstNetwork;
	USHORT	anr_LastNetwork;
} ATALK_NETWORKRANGE, *PATALK_NETWORKRANGE;

#define	NW_RANGE_EQUAL(Range1, Range2)	(*(PULONG)(Range1) == *(PULONG)(Range2))

#endif	// _ATKTYPES_


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\atalk\sys\atktdi.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

	atktdi.h

Abstract:

	This module contains tdi related definitions.

Author:

	Jameel Hyder (jameelh@microsoft.com)
	Nikhil Kamkolkar (nikhilk@microsoft.com)

Revision History:
	19 Jun 1992		Initial Version

Notes:	Tab stop: 4
--*/

#ifndef	_ATKTDI_
#define	_ATKTDI_

#define DFLAG_ADDR		0x0001
#define DFLAG_CONN		0x0002
#define DFLAG_CNTR		0x0004
#define DFLAG_MDL		0x0008

struct _ActionReq;

// Typedef for the worker routine used in the dispatch tables
typedef VOID		(*GENERIC_COMPLETION)(IN ATALK_ERROR	ErrorCode,
										  IN PIRP			pIrp);
typedef VOID		(*ACTION_COMPLETION)(IN ATALK_ERROR		ErrorCode,
										 IN struct _ActionReq *pActReq);
typedef ATALK_ERROR	(*DISPATCH_ROUTINE)(IN PVOID			pObject,
										IN struct _ActionReq *pActReq);

typedef VOID		(*GENERIC_WRITE_COMPLETION)(
									IN ATALK_ERROR	ErrorCode,
									IN PAMDL		WriteBuf,
									IN USHORT		WriteLen,
									IN PIRP			pIrp);

typedef VOID		(*GENERIC_READ_COMPLETION)(
									IN ATALK_ERROR	ErrorCode,
									IN PAMDL		ReadBuf,
									IN USHORT		ReadLen,
									IN ULONG		ReadFlags,
									IN PIRP			pIrp);

// Define the Action dispatch table here.
//
// *IMPORTANT*
// This table is tightly integrated with the action codes defined in
// ATALKTDI.H.
//
// Order is NBP/ZIP/ADSP/ATP/ASP/PAP
//
// Each element of the array contains:
// _MinBufLen - The minimum length of the MdlAddress buffer for the request
// _OpCode - The action code of the request (sanity check)
// _OpInfo - Bit flags give more information about the request
//		DFLAG_ADDR - Object for request must be an address object
//		DFLAG_CONN - Object for request must be connection object
//		DFLAG_CNTR - Object for request must be control channel
//		DFLAG_MDL1 - Request uses an mdl (submdl of MdlAddress)
//		DFLAG_MDL2 - Request uses a second mdl (submdl of MdlAddress)
// _ActionBufSize  - The size of the action header buffer for request
//					 (beginning of the buffer described by MdlAddress)
// _DeviceType	   - Valid device types for the request
//					 ATALK_DEV_ANY => Any device
// _MdlSizeOffset  - Offset in action buffer where the size for the first
//					 mdl can be found. Non-zero only when DFLAG_MDL2 is set.
// _Dispatch	   - The dispatch routine for the request
//
typedef struct _ActionDispatch {
	USHORT				_MinBufLen;
	USHORT				_OpCode;
	USHORT				_Flags;
	USHORT				_ActionBufSize;
	ATALK_DEV_TYPE		_DeviceType;
	DISPATCH_ROUTINE	_Dispatch;
} ACTION_DISPATCH, *PACTION_DISPATCH;


extern POBJECT_TYPE *IoFileObjectType;

extern	ACTION_DISPATCH	AtalkActionDispatch[];

#define	ACTREQ_SIGNATURE	(*(PULONG)"ACRQ")
#if	DBG
#define	VALID_ACTREQ(pActReq)	(((pActReq) != NULL) &&	\
								 ((pActReq)->ar_Signature == ACTREQ_SIGNATURE))
#else
#define	VALID_ACTREQ(pActReq)	((pActReq) != NULL)
#endif
typedef	struct _ActionReq
{
#if	DBG
	ULONG				ar_Signature;
#endif
	PIRP				ar_pIrp;					// Irp for the request
	PVOID				ar_pParms;					// Action parameter block
	PAMDL				ar_pAMdl;					// Mdl (OPTIONAL)
	SHORT				ar_MdlSize;					// And its size
	ULONG				ar_ActionCode;				// TDI Action code
	SHORT				ar_DevType;					// Which device ?
	ACTION_COMPLETION	ar_Completion;				// Tdi Completion routine
    PKEVENT             ar_CmplEvent;               // zone-list acquiring done
    PVOID               ar_pZci;                    // ptr to zoneinfo struct
    ULONG               ar_StatusCode;
} ACTREQ, *PACTREQ;

typedef	enum {
	ATALK_INDICATE_DISCONNECT,
	ATALK_TIMER_DISCONNECT,
	ATALK_REMOTE_DISCONNECT,
	ATALK_LOCAL_DISCONNECT
} ATALK_DISCONNECT_TYPE;
#define DISCONN_STATUS(DiscType)												\
			(((DiscType == ATALK_TIMER_DISCONNECT) ? ATALK_CONNECTION_TIMEOUT : \
			(DiscType == ATALK_REMOTE_DISCONNECT)) ? ATALK_REMOTE_CLOSE :   	\
			ATALK_NO_ERROR)

extern
NTSTATUS
AtalkTdiOpenAddress(
	IN 		PIRP					Irp,
	IN 		PIO_STACK_LOCATION		IrpSp,
	IN 		PTA_APPLETALK_ADDRESS	TdiAddress,
	IN 		UCHAR					ProtocolType,
	IN 		UCHAR					SocketType,
	IN OUT 	PATALK_DEV_CTX			Context
);

extern
NTSTATUS
AtalkTdiOpenConnection(
	IN		PIRP					Irp,
	IN 		PIO_STACK_LOCATION 		IrpSp,
	IN 		CONNECTION_CONTEXT		ConnectionContext,
	IN OUT	PATALK_DEV_CTX			Context
);

extern
NTSTATUS
AtalkTdiOpenControlChannel(
	IN		PIRP					Irp,
	IN 		PIO_STACK_LOCATION 		IrpSp,
	IN OUT	PATALK_DEV_CTX			Context
);

extern
NTSTATUS
AtalkTdiCleanupAddress(
	IN		PIRP					Irp,
	IN 		PIO_STACK_LOCATION 		IrpSp,
	IN OUT	PATALK_DEV_CTX			Context
);

extern
NTSTATUS
AtalkTdiCleanupConnection(
	IN		PIRP					Irp,
	IN 		PIO_STACK_LOCATION 		IrpSp,
	IN OUT	PATALK_DEV_CTX			Context
);

extern
NTSTATUS
AtalkTdiCloseAddress(
	IN		PIRP					Irp,
	IN 		PIO_STACK_LOCATION 		IrpSp,
	IN OUT	PATALK_DEV_CTX			Context
);

extern
NTSTATUS
AtalkTdiCloseConnection(
	IN		PIRP					Irp,
	IN 		PIO_STACK_LOCATION 		IrpSp,
	IN OUT	PATALK_DEV_CTX			Context
);

extern
NTSTATUS
AtalkTdiCloseControlChannel(
	IN		PIRP					Irp,
	IN 		PIO_STACK_LOCATION 		IrpSp,
	IN OUT	PATALK_DEV_CTX			Context
);

extern
VOID
AtalkTdiCancel(
	IN OUT	PATALK_DEV_OBJ			pDevObj,
	IN		PIRP					Irp
);

extern
NTSTATUS
AtalkTdiAssociateAddress(
	IN		PIRP					Irp,
	IN 		PIO_STACK_LOCATION 		IrpSp,
	IN OUT	PATALK_DEV_CTX			Context
);

extern
NTSTATUS
AtalkTdiDisassociateAddress(
	IN		PIRP					Irp,
	IN 		PIO_STACK_LOCATION 		IrpSp,
	IN OUT	PATALK_DEV_CTX			Context
);

extern
NTSTATUS
AtalkTdiConnect(
	IN		PIRP					Irp,
	IN 		PIO_STACK_LOCATION 		IrpSp,
	IN OUT	PATALK_DEV_CTX			Context
);

extern
NTSTATUS
AtalkTdiDisconnect(
	IN		PIRP					Irp,
	IN 		PIO_STACK_LOCATION 		IrpSp,
	IN OUT	PATALK_DEV_CTX			Context
);

extern
NTSTATUS
AtalkTdiAccept(
	IN		PIRP					Irp,
	IN 		PIO_STACK_LOCATION 		IrpSp,
	IN OUT	PATALK_DEV_CTX			Context
);

extern
NTSTATUS
AtalkTdiListen(
	IN		PIRP					Irp,
	IN 		PIO_STACK_LOCATION 		IrpSp,
	IN OUT	PATALK_DEV_CTX			Context
);

extern
NTSTATUS
AtalkTdiSendDgram(
	IN		PIRP					Irp,
	IN 		PIO_STACK_LOCATION 		IrpSp,
	IN OUT	PATALK_DEV_CTX			Context
);

extern
NTSTATUS
AtalkTdiReceiveDgram(
	IN		PIRP					Irp,
	IN 		PIO_STACK_LOCATION 		IrpSp,
	IN OUT	PATALK_DEV_CTX			Context
);

extern
NTSTATUS
AtalkTdiSend(
	IN		PIRP					Irp,
	IN 		PIO_STACK_LOCATION 		IrpSp,
	IN OUT	PATALK_DEV_CTX			Context
);

extern
NTSTATUS
AtalkTdiReceive(
	IN		PIRP					Irp,
	IN 		PIO_STACK_LOCATION 		IrpSp,
	IN OUT	PATALK_DEV_CTX			Context
);

extern
NTSTATUS
AtalkTdiAction(
	IN		PIRP					Irp,
	IN 		PIO_STACK_LOCATION 		IrpSp,
	IN OUT	PATALK_DEV_CTX			Context
);

extern
NTSTATUS
AtalkTdiQueryInformation(
	IN		PIRP					Irp,
	IN 		PIO_STACK_LOCATION 		IrpSp,
	IN OUT	PATALK_DEV_CTX			Context
);

extern
NTSTATUS
AtalkTdiSetInformation(
	IN		PIRP					Irp,
	IN 		PIO_STACK_LOCATION 		IrpSp,
	IN OUT	PATALK_DEV_CTX			Context
);

extern
NTSTATUS
AtalkTdiSetEventHandler(
	IN		PIRP					Irp,
	IN 		PIO_STACK_LOCATION 		IrpSp,
	IN OUT	PATALK_DEV_CTX			Context
);


extern
ATALK_ERROR
AtalkStatTdiAction(
	IN	PVOID						pObject,	// Address or Connection object
	IN	PACTREQ						pActReq		// Pointer to action request
);

extern
ATALK_ERROR
AtalkNbpTdiAction(
	IN	PVOID						pObject,	// Address or Connection object
	IN	PACTREQ						pActReq		// Pointer to action request
);

extern
ATALK_ERROR
AtalkZipTdiAction(
	IN	PVOID						pObject,	// Address or Connection object
	IN	PACTREQ						pActReq		// Pointer to action request
);

extern
ATALK_ERROR
AtalkAdspTdiAction(
	IN	PVOID						pObject,	// Address or Connection object
	IN	PACTREQ						pActReq		// Pointer to action request
);

extern
ATALK_ERROR
AtalkAspCTdiAction(
	IN	PVOID						pObject,	// Address or Connection object
	IN	PACTREQ						pActReq		// Pointer to action request
);

extern
ATALK_ERROR
AtalkPapTdiAction(
	IN	PVOID						pObject,	// Address or Connection object
	IN	PACTREQ						pActReq		// Pointer to action request
);

extern
ATALK_ERROR
AtalkAspTdiAction(
	IN	PVOID						pObject,	// Address or Connection object
	IN	PACTREQ						pActReq		// Pointer to action request
);

extern
VOID
atalkTdiGenericWriteComplete(
	IN	ATALK_ERROR					ErrorCode,
	IN 	PAMDL						WriteBuf,
	IN 	USHORT						WriteLen,
	IN	PIRP						pIrp
);

typedef	struct
{
	LONG	ls_LockCount;
	PVOID	ls_LockHandle;
} LOCK_SECTION, *PLOCK_SECTION;

#define	AtalkLockAdspIfNecessary()		AtalkLockUnlock(TRUE,							\
														&AtalkPgLkSection[ADSP_SECTION])
#define	AtalkUnlockAdspIfNecessary()	AtalkLockUnlock(FALSE,							\
														&AtalkPgLkSection[ADSP_SECTION])

#define	AtalkLockPapIfNecessary()		AtalkLockUnlock(TRUE,							\
														&AtalkPgLkSection[PAP_SECTION])
#define	AtalkUnlockPapIfNecessary()		AtalkLockUnlock(FALSE,							\
														&AtalkPgLkSection[PAP_SECTION])

#define	AtalkLockNbpIfNecessary()		AtalkLockUnlock(TRUE,							\
														&AtalkPgLkSection[NBP_SECTION])
#define	AtalkUnlockNbpIfNecessary()		AtalkLockUnlock(FALSE,							\
														&AtalkPgLkSection[NBP_SECTION])

#define	AtalkLockZipIfNecessary()		AtalkLockUnlock(TRUE,							\
														&AtalkPgLkSection[ZIP_SECTION])
#define	AtalkUnlockZipIfNecessary()		AtalkLockUnlock(FALSE,							\
														&AtalkPgLkSection[ZIP_SECTION])

#define	AtalkLockRouterIfNecessary()	AtalkLockUnlock(TRUE,							\
														&AtalkPgLkSection[ROUTER_SECTION])
#define	AtalkUnlockRouterIfNecessary()	AtalkLockUnlock(FALSE,							\
														&AtalkPgLkSection[ROUTER_SECTION])

#define	AtalkLockTdiIfNecessary()		AtalkLockUnlock(TRUE,							\
														&AtalkPgLkSection[TDI_SECTION])
#define	AtalkUnlockTdiIfNecessary()		AtalkLockUnlock(FALSE,			        		\
														&AtalkPgLkSection[TDI_SECTION])

#define	AtalkLockAspIfNecessary()		AtalkLockUnlock(TRUE,							\
														&AtalkPgLkSection[ASP_SECTION])
#define	AtalkUnlockAspIfNecessary()		AtalkLockUnlock(FALSE,			        		\
														&AtalkPgLkSection[ASP_SECTION])

#define	AtalkLockAspCIfNecessary()		AtalkLockUnlock(TRUE,							\
														&AtalkPgLkSection[ASPC_SECTION])
#define	AtalkUnlockAspCIfNecessary()	AtalkLockUnlock(FALSE,			        		\
														&AtalkPgLkSection[ASPC_SECTION])

#define	AtalkLockAtpIfNecessary()		AtalkLockUnlock(TRUE,							\
														&AtalkPgLkSection[ATP_SECTION])
#define	AtalkUnlockAtpIfNecessary()		AtalkLockUnlock(FALSE,			        		\
														&AtalkPgLkSection[ATP_SECTION])

#define	AtalkLockInitIfNecessary()		AtalkLockUnlock(TRUE,							\
														&AtalkPgLkSection[INIT_SECTION])
#define	AtalkUnlockInitIfNecessary()		AtalkLockUnlock(FALSE,		            		\
														&AtalkPgLkSection[INIT_SECTION])
#define	AtalkLockArapIfNecessary()		AtalkLockUnlock(TRUE,		            		\
														&AtalkPgLkSection[ARAP_SECTION])
#define	AtalkUnlockArapIfNecessary()		AtalkLockUnlock(FALSE,		            		\
														&AtalkPgLkSection[ARAP_SECTION])
#define	AtalkLockPPPIfNecessary()		AtalkLockUnlock(TRUE,		            		\
														&AtalkPgLkSection[PPP_SECTION])
#define	AtalkUnlockPPPIfNecessary()		AtalkLockUnlock(FALSE,		            		\
														&AtalkPgLkSection[PPP_SECTION])

extern
VOID
AtalkLockInit(
	IN	PLOCK_SECTION	pLs,
	IN	PVOID			Address
);

extern
VOID
AtalkLockUnlock(
	IN		BOOLEAN						Lock,
	IN		PLOCK_SECTION				pLs
);

#define	ROUTER_SECTION					0
#define	NBP_SECTION						1	// NBP & ZIP share the sections
#define	ZIP_SECTION						1
#define	TDI_SECTION						2
#define	ATP_SECTION						3
#define	ASP_SECTION						4
#define	PAP_SECTION						5
#define	ADSP_SECTION					6
#define	ASPC_SECTION					7
#define	INIT_SECTION					8
#define ARAP_SECTION                    9
#define PPP_SECTION                     10
#define	LOCKABLE_SECTIONS				11

extern	KMUTEX							AtalkPgLkMutex;
extern	ATALK_SPIN_LOCK					AtalkPgLkLock;
extern	LOCK_SECTION					AtalkPgLkSection[LOCKABLE_SECTIONS];

// Used by AtalkLockUnlock & atalkQueuedLockUnlock to communicate. The latter is queued
// up by the former whenever it is called at DISPACTH to unlock
typedef	struct
{
	WORK_QUEUE_ITEM		qlu_WQI;
	PLOCK_SECTION		qlu_pLockSection;
	PPORT_DESCRIPTOR	qlu_pPortDesc;
} QLU, *PQLU;

LOCAL VOID FASTCALL
atalkTdiSendDgramComplete(
	IN	NDIS_STATUS						Status,
	IN	struct _SEND_COMPL_INFO	*		pSendInfo
);

LOCAL VOID
atalkTdiRecvDgramComplete(
	IN	ATALK_ERROR						ErrorCode,
	IN	PAMDL							pReadBuf,
	IN	USHORT							ReadLen,
	IN	PATALK_ADDR						pSrcAddr,
	IN	PIRP							pIrp);

LOCAL VOID
atalkTdiActionComplete(
	IN	ATALK_ERROR						ErrorCode,
	IN	PACTREQ							pActReq
);

LOCAL VOID
atalkTdiGenericComplete(
	IN	ATALK_ERROR						ErrorCode,
	IN	PIRP							pIrp
);

LOCAL VOID
atalkTdiCloseAddressComplete(
	IN	ATALK_ERROR						ErrorCode,
	IN	PIRP							pIrp
);

LOCAL VOID
atalkTdiGenericReadComplete(
	IN	ATALK_ERROR						ErrorCode,
	IN 	PAMDL							ReadBuf,
	IN 	USHORT							ReadLen,
	IN 	ULONG							ReadFlags,
	IN 	PIRP							pIrp
);

LOCAL VOID
atalkQueuedLockUnlock(
	IN	PQLU		pQLU
);

VOID
atalkWaitDefaultPort(
	VOID
);

#endif	// _ATKTDI_


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\atalk\sys\atkutils.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

	atkutils.h

Abstract:

	This module contains miscellaneous support routines.

Author:

	Jameel Hyder (jameelh@microsoft.com)
	Nikhil Kamkolkar (nikhilk@microsoft.com)

Revision History:
	19 Jun 1992		Initial Version

Notes:	Tab stop: 4
--*/

#ifndef	_ATKUTILS_
#define	_ATKUTILS_

//	SpinLock Macros
#if	DBG
#define INITIALIZE_SPIN_LOCK(_pLock)											\
	{																			\
		KeInitializeSpinLock(&(_pLock)->SpinLock);								\
		(_pLock)->FileLineLock = 0;												\
	}
#else	// DBG
#define INITIALIZE_SPIN_LOCK(_pLock)											\
	{																			\
		KeInitializeSpinLock(&(_pLock)->SpinLock);								\
	}
#endif

#if	DBG
#define ACQUIRE_SPIN_LOCK(_pLock, _pOldIrql)									\
	{																			\
		KeAcquireSpinLock(&(_pLock)->SpinLock,									\
						  _pOldIrql);											\
		(_pLock)->FileLineLock = (FILENUM | __LINE__);							\
	}

#define ACQUIRE_SPIN_LOCK_DPC(_pLock)											\
	{																			\
		ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);							\
		KeAcquireSpinLockAtDpcLevel(&(_pLock)->SpinLock);						\
		(_pLock)->FileLineLock = (FILENUM | __LINE__ | 0x80000000);				\
	}

#define RELEASE_SPIN_LOCK(_pLock, _OldIrql)										\
	{																			\
		ASSERT ((_pLock)->FileLineLock != 0);									\
		ASSERT (((_pLock)->FileLineLock & 0x80000000) == 0);					\
		(_pLock)->FileLineLock = 0;												\
		(_pLock)->FileLineUnlock = (FILENUM | __LINE__);						\
		KeReleaseSpinLock(&(_pLock)->SpinLock,									\
						  _OldIrql);											\
	}

#define RELEASE_SPIN_LOCK_DPC(_pLock)											\
	{																			\
		ASSERT ((_pLock)->FileLineLock != 0);									\
		ASSERT ((_pLock)->FileLineLock & 0x80000000);							\
		(_pLock)->FileLineLock = 0;												\
		(_pLock)->FileLineUnlock = (FILENUM | __LINE__ | 0x80000000);			\
		KeReleaseSpinLockFromDpcLevel(&(_pLock)->SpinLock);						\
		ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);							\
	}

#else	// DBG

#define ACQUIRE_SPIN_LOCK(_pLock, _pOldIrql)									\
	{																			\
		KeAcquireSpinLock(&(_pLock)->SpinLock,									\
						  _pOldIrql);											\
	}

#define ACQUIRE_SPIN_LOCK_DPC(_pLock)											\
	{																			\
		KeAcquireSpinLockAtDpcLevel(&(_pLock)->SpinLock);						\
	}

#define RELEASE_SPIN_LOCK(_pLock, _OldIrql)										\
	{																			\
		KeReleaseSpinLock(&(_pLock)->SpinLock,									\
						  (_OldIrql));											\
	}

#define RELEASE_SPIN_LOCK_DPC(_pLock) 											\
	{																			\
		KeReleaseSpinLockFromDpcLevel(&(_pLock)->SpinLock);						\
	}																			\

#endif	// DBG

// Macros for ExInterlocked calls
#define INTERLOCKED_INCREMENT_LONG(p, l)			InterlockedIncrement(p)
#define INTERLOCKED_DECREMENT_LONG(p, l)			InterlockedDecrement(p)
#define INTERLOCKED_INCREMENT_LONG_DPC(p, l)		InterlockedIncrement(p)
#define INTERLOCKED_DECREMENT_LONG_DPC(p, l)		InterlockedDecrement(p)
#define	INTERLOCKED_ADD_STATISTICS(p, v, l)			ExInterlockedAddLargeStatistic(p, v)
#define INTERLOCKED_ADD_ULONG(p, v, l)				ExInterlockedAddUlong(p, v, l)
#define INTERLOCKED_ADD_LARGE_INTGR(p, v, l)		ExInterlockedAddLargeInteger(p, v, l)

#define INTERLOCKED_ADD_ULONG_DPC(p, v, l)			ExInterlockedAddUlong(p, v, l)
#define INTERLOCKED_ADD_LARGE_INTGR_DPC(p, v, l)	ExInterlockedAddLargeInteger(p, v, l)

#define	ATALK_NODES_EQUAL(N1, N2)												\
				((((N1)->atn_Network == (N2)->atn_Network) ||					\
				  ((N1)->atn_Network == 0) ||									\
				  ((N2)->atn_Network == 0)) &&									\
				 ((N1)->atn_Node == (N2)->atn_Node))


#define	ATALK_ADDRS_EQUAL(A1, A2)												\
				((((A1)->ata_Network == (A2)->ata_Network) ||					\
				  ((A1)->ata_Network == 0) ||									\
				  ((A2)->ata_Network == 0)) &&									\
				 ((A1)->ata_Node == (A2)->ata_Node) &&							\
				 ((A1)->ata_Socket == (A2)->ata_Socket))
				

#define	INVALID_ADDRESS(pAddr)													\
				(((pAddr)->ata_Network > LAST_VALID_NETWORK)	||				\
				(((pAddr)->ata_Node > MAX_USABLE_ATALKNODE)	&&					\
				 ((pAddr)->ata_Node != ATALK_BROADCAST_NODE))	||				\
				((pAddr)->ata_Socket < FIRST_VALID_SOCKET)		||				\
				((pAddr)->ata_Socket > LAST_VALID_SOCKET))

#define	ATALKADDR_TO_TDI(pTdiAddr, pAtalkAddr)									\
	{																			\
		(pTdiAddr)->TAAddressCount = 1;											\
		(pTdiAddr)->Address[0].AddressLength = sizeof(TDI_ADDRESS_APPLETALK);	\
		(pTdiAddr)->Address[0].AddressType = TDI_ADDRESS_TYPE_APPLETALK;		\
		(pTdiAddr)->Address[0].Address[0].Network = (pAtalkAddr)->ata_Network;	\
		(pTdiAddr)->Address[0].Address[0].Node = (pAtalkAddr)->ata_Node;		\
		(pTdiAddr)->Address[0].Address[0].Socket = (pAtalkAddr)->ata_Socket;	\
	}

#define	TDI_TO_ATALKADDR(pAtalkAddr, pTdiAddr)									\
	{																		\
		ASSERTMSG("TdiAddrCount is not 1\n",								\
			((pTdiAddr)->TAAddressCount == 1));								\
																			\
		ASSERTMSG("TdiAddrLen invalid\n",									\
			((pTdiAddr)->Address[0].AddressLength >=						\
			sizeof(TDI_ADDRESS_APPLETALK)));								\
																			\
		ASSERTMSG("TdiAddrType invalid\n",									\
			((pTdiAddr)->Address[0].AddressType ==							\
			TDI_ADDRESS_TYPE_APPLETALK));									\
																			\
		(pAtalkAddr)->ata_Network = (pTdiAddr)->Address[0].Address[0].Network;\
		(pAtalkAddr)->ata_Node = (pTdiAddr)->Address[0].Address[0].Node;	\
		(pAtalkAddr)->ata_Socket = (pTdiAddr)->Address[0].Address[0].Socket;\
	}																		

#define	IN_NETWORK_RANGE(NetworkNumber, pRte)									\
			(((pRte)->rte_NwRange.anr_FirstNetwork == NetworkNumber)   ||		\
			  ((NetworkNumber >= (pRte)->rte_NwRange.anr_FirstNetwork) &&		\
			   (NetworkNumber <= (pRte)->rte_NwRange.anr_LastNetwork)))

#define	WITHIN_NETWORK_RANGE(NetworkNumber, pRange)								\
			 (((pRange)->anr_FirstNetwork == NetworkNumber) ||					\
			  ((NetworkNumber >= (pRange)->anr_FirstNetwork) &&					\
			   (NetworkNumber <= (pRange)->anr_LastNetwork)))

#define	COPY_NETWORK_ADDR(_Dst, _Src)											\
	{																			\
		*((ULONG UNALIGNED *)(_Dst)) = *((ULONG UNALIGNED *)(_Src));			\
		*((USHORT UNALIGNED *)((UCHAR *)(_Dst)+4)) =							\
							*((USHORT UNALIGNED *)((UCHAR *)(_Src)+4));			\
	}

//	Hash functions
//	Make sure we're positive [thus the shift by 7 rather than 8].
//	Only hash node and  socket; due to the "zero matches all" for
//	non-extended network numbers.

#define HASH_ATALK_ADDR(address)												\
	((USHORT)(((address)->ata_Node << 7) +					  					\
			  ((address)->ata_Socket & 0x7F)))

#define HASH_ATALK_NODE(address)						   						\
	((USHORT)((((address)->atn_Network & 0x3C) >> 2) +			   				\
			  (address)->atn_Node & 0x04))

#define	HASH_ID_SRCADDR(id, pSrcAddr)											\
	((id) + (((pSrcAddr)->ata_Node >> 2) + ((pSrcAddr)->ata_Network & 0xFF)))


/*
 * The following macros deal with on-the-wire integer and long values
 *
 * On the wire format is big-endian i.e. a long value of 0x01020304 is
 * represented as 01 02 03 04. Similarly an int value of 0x0102 is
 * represented as 01 02.
 *
 * The host format is not assumed since it will vary from processor to
 * processor.
 */

// Get a byte from on-the-wire format to a short in the host format
#define GETBYTE2SHORT(DstPtr, SrcPtr)											\
		*(PUSHORT)(DstPtr) = (USHORT) (*(PBYTE)(SrcPtr))

// Get a byte from on-the-wire format to a dword in the host format
#define GETBYTE2DWORD(DstPtr, SrcPtr)											\
		*(PDWORD)(DstPtr) = (DWORD) (*(PBYTE)(SrcPtr))

// Get a short from on-the-wire format to a dword in the host format
#define GETSHORT2DWORD(DstPtr, SrcPtr)											\
		*(PDWORD)(DstPtr) = ((*((PBYTE)(SrcPtr)+0) << 8) +						\
							  (*((PBYTE)(SrcPtr)+1)))

// Get a short from on-the-wire format to a short in the host format
#define GETSHORT2SHORT(DstPtr, SrcPtr)											\
		*(PUSHORT)(DstPtr) = ((*((PBYTE)(SrcPtr)+0) << 8) +						\
							  (*((PBYTE)(SrcPtr)+1)))

// Get a dword from on-the-wire format to a dword in the host format
#define GETDWORD2DWORD(DstPtr, SrcPtr)											\
		*(PDWORD)(DstPtr) = ((*((PBYTE)(SrcPtr)+0) << 24) +						\
							  (*((PBYTE)(SrcPtr)+1) << 16) +					\
							  (*((PBYTE)(SrcPtr)+2) << 8)  +					\
							  (*((PBYTE)(SrcPtr)+3)))

// Put a dword from the host format to a short to on-the-wire format
#define PUTBYTE2BYTE(DstPtr, Src)												\
		*((PBYTE)(DstPtr)) = (BYTE)(Src)

// Put a dword from the host format to a short to on-the-wire format
#define PUTSHORT2BYTE(DstPtr, Src)												\
		*((PBYTE)(DstPtr)) = ((USHORT)(Src) % 256)

// Put a dword from the host format to a short to on-the-wire format
#define PUTSHORT2SHORT(DstPtr, Src)												\
		*((PBYTE)(DstPtr)+0) = (BYTE) ((USHORT)(Src) >> 8),						\
		*((PBYTE)(DstPtr)+1) = (BYTE)(Src)

// Put a dword from the host format to a byte to on-the-wire format
#define PUTDWORD2BYTE(DstPtr, Src)												\
		*(PBYTE)(DstPtr) = (BYTE)(Src)

// Put a dword from the host format to a short to on-the-wire format
#define PUTDWORD2SHORT(DstPtr, Src)												\
		*((PBYTE)(DstPtr)+0) = (BYTE) ((DWORD)(Src) >> 8),						\
		*((PBYTE)(DstPtr)+1) = (BYTE) (Src)

// Put a dword from the host format to a dword to on-the-wire format
#define PUTDWORD2DWORD(DstPtr, Src)												\
		*((PBYTE)(DstPtr)+0) = (BYTE) ((DWORD)(Src) >> 24),						\
		*((PBYTE)(DstPtr)+1) = (BYTE) ((DWORD)(Src) >> 16),						\
		*((PBYTE)(DstPtr)+2) = (BYTE) ((DWORD)(Src) >>  8),						\
		*((PBYTE)(DstPtr)+3) = (BYTE) (Src)

//	MIN/MAX macros
#define	MIN(a, b)	(((a) < (b)) ? (a) : (b))
#define	MAX(a, b)	(((a) > (b)) ? (a) : (b))

extern	BYTE AtalkUpCaseTable[];

extern
VOID
AtalkUpCase(
	IN	PBYTE	pSrc,
	IN	BYTE	SrcLen,
	OUT	PBYTE	pDst
);

extern
BOOLEAN
AtalkCompareCaseInsensitive(
	IN	PBYTE	s1,
	IN	PBYTE	s2
);

extern
int
AtalkOrderCaseInsensitive(
	IN	PBYTE	s1,
	IN	PBYTE	s2
);

#define	AtalkFixedCompareCaseInsensitive(s1, l1, s2, l2)						\
		(((l1) == (l2)) && AtalkCompareFixedCaseInsensitive(s1, s2, l1))

extern
BOOLEAN
AtalkCompareFixedCaseInsensitive(
	IN	PBYTE		s1,
	IN	PBYTE		s2,
	IN	int			len
);

#define	AtalkFixedCompareCaseSensitive(s1, l1, s2, l2)							\
			((l1 == l2) && !memcmp(s1, s2, l1))

extern
PBYTE
AtalkSearchBuf(
	IN	PBYTE	pBuf,
	IN	BYTE	BufLen,
	IN	BYTE	SearchChar
);


int
GetTokenLen(
        IN PBYTE pTokStr,
        IN int   WildStringLen,
        IN BYTE  NBP_WILD_CHARACTER
        );

BOOLEAN
SubStringMatch(
        IN PBYTE pTarget,
        IN PBYTE pTokStr,
        IN int   StringLen,
        IN int   TokStrLen
        );
extern
BOOLEAN
AtalkCheckNetworkRange(
	IN	PATALK_NETWORKRANGE	NetworkRange
);

#define	AtalkRangesOverlap(pRange1, pRange2)									\
		(((pRange1)->anr_LastNetwork >= (pRange2)->anr_FirstNetwork) &&			\
		 ((pRange1)->anr_FirstNetwork <= (pRange2)->anr_LastNetwork))

extern
BOOLEAN
AtalkIsPrime(
	long Step
);

extern
LONG
AtalkRandomNumber(
	VOID
);


extern
VOID
AtalkDbgIncCount(
    IN DWORD    *Value
);

extern
VOID
AtalkDbgDecCount(
    IN DWORD    *Value
);

// Used for calculating round trip times using Van Jacobson algorithm
typedef struct
{
	ULONG	rt_New;
	SHORT	rt_Min;
	SHORT	rt_Max;
	SHORT	rt_Ave;
	SHORT	rt_Dev;
	SHORT	rt_Base;
} RT, *PRT;

#define	AtalkInitializeRT(pRT, Initial, Min, Max)								\
	{																			\
		(pRT)->rt_Min = Min;													\
		(pRT)->rt_Max = Max;													\
		(pRT)->rt_Base = Initial;												\
		(pRT)->rt_Ave = Min;													\
		(pRT)->rt_Dev = 0;														\
	}

#define	AtalkCalculateNewRT(pRT)												\
	{																			\
		SHORT	baseT, error;													\
																				\
		/* VAN JACOBSEN Algorithm.  From Internetworking with Tcp/ip (Comer). */\
																				\
		if ((pRT)->rt_New == 0)													\
			(pRT)->rt_New = 1;		/* Do not let this go to zero */			\
																				\
		error = (SHORT)((pRT)->rt_New) - ((pRT)->rt_Ave >> 3);					\
		(pRT)->rt_Ave	+= error;												\
		/* Make sure not too small */											\
		if ((pRT)->rt_Ave <= 0)	 												\
		{																		\
			(pRT)->rt_Ave = (pRT)->rt_Min;										\
		}																		\
																				\
		if (error < 0)															\
			error = -error;														\
																				\
		error -= ((pRT)->rt_Dev >> 2);											\
		(pRT)->rt_Dev	+= error;												\
		if ((pRT)->rt_Dev <= 0)													\
			(pRT)->rt_Dev = 1;													\
																				\
		baseT = ((((pRT)->rt_Ave >> 2) + (pRT)->rt_Dev) >> 1);					\
																				\
		/*	If less then min - set it */										\
		if (baseT < (pRT)->rt_Min)												\
			baseT = (pRT)->rt_Min;												\
																				\
		/*	If greater than max - set it */										\
		if (baseT > (pRT)->rt_Max)												\
			baseT = (pRT)->rt_Max;												\
																				\
		/*	Set the new value */												\
		(pRT)->rt_Base = baseT;													\
	}

extern
BOOLEAN
AtalkWaitTE(
	IN	PKEVENT	pEvent,
	IN	ULONG	TimeInMs
);

extern
VOID
AtalkSleep(
	IN	ULONG	TimeInMs
);

NTSTATUS
AtalkGetProtocolSocketType(
	PATALK_DEV_CTX   	Context,
	PUNICODE_STRING 	RemainingFileName,
	PBYTE  				ProtocolType,
	PBYTE  				SocketType
);

INT
AtalkIrpGetEaCreateType(
	IN PIRP Irp);

LOCAL LONG
atalkStringHash(
	IN	PBYTE	String,
	IN	BYTE	StrLen
);

#endif	// _ATKUTILS_



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\atalk\sys\atkutils.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

	AtkUtils.c

Abstract:

	This module contains miscellaneous support routines

Author:

	Jameel Hyder (jameelh@microsoft.com)
	Nikhil Kamkolkar (nikhilk@microsoft.com)

Revision History:
	25 Feb 1993		Initial Version

Notes:	Tab stop: 4
--*/

#include <atalk.h>
#pragma hdrstop
#define	FILENUM	ATKUTILS

#define	ONE_MS_IN_100ns		-10000L		// 1ms in 100ns units

extern	BYTE AtalkUpCaseTable[256];

VOID
AtalkUpCase(
	IN	PBYTE	pSrc,
	IN	BYTE	SrcLen,
	OUT	PBYTE	pDst
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	while (SrcLen --)
	{
		*pDst++ = AtalkUpCaseTable[*pSrc++];
	}
}




BOOLEAN
AtalkCompareCaseInsensitive(
	IN	PBYTE	s1,
	IN	PBYTE	s2
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	BYTE	c1, c2;

	while (((c1 = *s1++) != 0) && ((c2 = *s2++) != 0))
	{
		if (AtalkUpCaseTable[c1] != AtalkUpCaseTable[c2])
			return(FALSE);
	}

	return (c2 == 0);
}




int
AtalkOrderCaseInsensitive(
	IN	PBYTE	s1,
	IN	PBYTE	s2
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	BYTE	c1, c2;

	while (((c1 = *s1++) != 0) && ((c2 = *s2++) != 0))
	{
		c1 = AtalkUpCaseTable[c1];
		c2 = AtalkUpCaseTable[c2];
		if (c1 != c2)
			return (c1 - c2);
	}

	if (c2 == 0)
		return 0;

	return (-1);
}




BOOLEAN
AtalkCompareFixedCaseInsensitive(
	IN	PBYTE	s1,
	IN	PBYTE	s2,
	IN	int		len
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	while(len--)
	{
		if (AtalkUpCaseTable[*s1++] != AtalkUpCaseTable[*s2++])
			return(FALSE);
	}

	return(TRUE);
}




PBYTE
AtalkSearchBuf(
	IN	PBYTE	pBuf,
	IN	BYTE	BufLen,
	IN	BYTE	SearchChar
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	for (NOTHING;
		 (BufLen != 0);
		 BufLen--, pBuf++)
	{
		if (*pBuf == SearchChar)
		{
			break;
		}
	}

	return ((BufLen == 0) ? NULL : pBuf);
}


int
GetTokenLen(
        IN PBYTE pTokStr,
        IN int   WildStringLen,
        IN BYTE  SearchChar
        )
/*++

Routine Description:

       Find the substring between start of the given string and the first
       wildchar after that, and return the length of the substring
--*/

{
        int    len;


        len = 0;

        while (len < WildStringLen)
        {
            if (pTokStr[len] == SearchChar)
            {
                break;
            }
            len++;
        }

        return (len);

}

BOOLEAN
SubStringMatch(
        IN PBYTE pTarget,
        IN PBYTE pTokStr,
        IN int   StringLen,
        IN int   TokStrLen
        )
/*++

Routine Description:

        Search pTarget string to see if the substring pTokStr can be
        found in it.
--*/
{
        int     i;

        if (TokStrLen > StringLen)
        {
            return (FALSE);
        }

        // if the pTarget string is "FooBarString" and if the substring is
        // BarStr
        for (i=(StringLen-TokStrLen); i>=0; i--)
        {
            if ( AtalkFixedCompareCaseInsensitive( pTarget+i,
                                                   TokStrLen,
                                                   pTokStr,
                                                   TokStrLen) )
            {
                return( TRUE );
            }
        }

        return (FALSE);
}

BOOLEAN
AtalkCheckNetworkRange(
	IN	PATALK_NETWORKRANGE	Range
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	if ((Range->anr_FirstNetwork < FIRST_VALID_NETWORK) 		||
		(Range->anr_FirstNetwork > LAST_VALID_NETWORK)  		||
		(Range->anr_LastNetwork < FIRST_VALID_NETWORK)  		||
		(Range->anr_LastNetwork > LAST_VALID_NETWORK)			||
		(Range->anr_LastNetwork < Range->anr_FirstNetwork) 		||
		(Range->anr_FirstNetwork >= FIRST_STARTUP_NETWORK))
	{
		return(FALSE);
	}

	return(TRUE);
}




BOOLEAN
AtalkIsPrime(
	long Step
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	// We assume "step" is odd.
	long i, j;
	
	// All odds, seven and below, are prime.
	if (Step <= 7)
		return (TRUE);
	
	//	Do a little divisibility checking. The "/3" is a reasonably good
	// shot at sqrt() because the smallest odd to come through here will be
	// 9.
	j = Step/3;
	for (i = 3; i <= j; i++)
		if (Step % i == 0)
			return(FALSE);
	
	return(TRUE);
	
}




LONG
AtalkRandomNumber(
	VOID
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	LARGE_INTEGER	Li;
	static LONG		seed = 0;

	// Return a positive pseudo-random number; simple linear congruential
	// algorithm. ANSI C "rand()" function.

	if (seed == 0)
	{
		KeQuerySystemTime(&Li);
		seed = Li.LowPart;
	}

	seed *= (0x41C64E6D + 0x3039);

	return (seed & 0x7FFFFFFF);
}


BOOLEAN
AtalkWaitTE(
	IN	PKEVENT	pEvent,
	IN	ULONG	TimeInMs
	)
/*++

Routine Description:

	Wait for an event to get signalled or a time to elapse

Arguments:


Return Value:


--*/
{
	TIME		Time;
	NTSTATUS	Status;

	// Make sure we can indeed wait
	ASSERT (KeGetCurrentIrql() == LOW_LEVEL);

	// Initialize the event
	KeInitializeEvent(pEvent, NotificationEvent, FALSE);

	Time.QuadPart = Int32x32To64((LONG)TimeInMs, ONE_MS_IN_100ns);
	Status = KeWaitForSingleObject(pEvent, Executive, KernelMode, FALSE, &Time);

	return (Status != STATUS_TIMEOUT);
}




VOID
AtalkSleep(
	IN	ULONG	TimeInMs
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	KTIMER			SleepTimer;
	LARGE_INTEGER	TimerValue;

	ASSERT (KeGetCurrentIrql() == LOW_LEVEL);

	KeInitializeTimer(&SleepTimer);

	TimerValue.QuadPart = Int32x32To64(TimeInMs, ONE_MS_IN_100ns);
	KeSetTimer(&SleepTimer,
			   TimerValue,
			   NULL);

	KeWaitForSingleObject(&SleepTimer, UserRequest, KernelMode, FALSE, NULL);
}




NTSTATUS
AtalkGetProtocolSocketType(
	PATALK_DEV_CTX		Context,
	PUNICODE_STRING 	RemainingFileName,
	PBYTE				ProtocolType,
	PBYTE				SocketType
)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	NTSTATUS			status = STATUS_SUCCESS;
	ULONG				protocolType;
	UNICODE_STRING		typeString;

	*ProtocolType = PROTOCOL_TYPE_UNDEFINED;
	*SocketType	= SOCKET_TYPE_UNDEFINED;

	switch (Context->adc_DevType)
	{
	  case ATALK_DEV_DDP :

		if ((UINT)RemainingFileName->Length <= (sizeof(PROTOCOLTYPE_PREFIX) - sizeof(WCHAR)))
		{
			status = STATUS_NO_SUCH_DEVICE;
			break;
		}

		RtlInitUnicodeString(&typeString,
							(PWCHAR)((PCHAR)RemainingFileName->Buffer +
									 sizeof(PROTOCOLTYPE_PREFIX) - sizeof(WCHAR)));

		status = RtlUnicodeStringToInteger(&typeString,
										   DECIMAL_BASE,
										   &protocolType);

		if (NT_SUCCESS(status))
		{

			DBGPRINT(DBG_COMP_CREATE, DBG_LEVEL_INFO,
					("AtalkGetProtocolType: protocol type is %lx\n", protocolType));

			if ((protocolType > DDPPROTO_DDP) && (protocolType <= DDPPROTO_MAX))
			{
				*ProtocolType = (BYTE)protocolType;
			}
			else
			{
				status = STATUS_NO_SUCH_DEVICE;
			}
		}
		break;

	  case ATALK_DEV_ADSP :

		// Check for the socket type
		if (RemainingFileName->Length == 0)
		{
			*SocketType = SOCKET_TYPE_RDM;
			break;
		}

		if ((UINT)RemainingFileName->Length != (sizeof(SOCKETSTREAM_SUFFIX) - sizeof(WCHAR)))
		{
			status = STATUS_NO_SUCH_DEVICE;
			break;
		}

		RtlInitUnicodeString(&typeString, SOCKETSTREAM_SUFFIX);

		//  Case insensitive compare
		if (RtlEqualUnicodeString(&typeString, RemainingFileName, TRUE))
		{
			*SocketType = SOCKET_TYPE_STREAM;
			break;
		}
		else
		{
			status = STATUS_NO_SUCH_DEVICE;
			break;
		}

	  case ATALK_DEV_ASPC:
	  case ATALK_DEV_ASP :
	  case ATALK_DEV_PAP :
		break;

	  default:
		status = STATUS_NO_SUCH_DEVICE;
		break;
	}

	return(status);
}



INT
AtalkIrpGetEaCreateType(
	IN PIRP Irp
	)
/*++

Routine Description:

 	Checks the EA name and returns the appropriate open type.

Arguments:

 	Irp - the irp for the create request, the EA value is stored in the
 		  SystemBuffer

Return Value:

 	TDI_TRANSPORT_ADDRESS_FILE: Create irp was for a transport address
 	TDI_CONNECTION_FILE: Create irp was for a connection object
 	ATALK_FILE_TYPE_CONTROL: Create irp was for a control channel (ea = NULL)

--*/
{
	PFILE_FULL_EA_INFORMATION 	openType;
	BOOLEAN 					found;
	INT 						returnType=0;   // not a valid type
	USHORT 						i;

	openType = (PFILE_FULL_EA_INFORMATION)Irp->AssociatedIrp.SystemBuffer;

	if (openType != NULL)
	{
		do
		{
			found = TRUE;

			for (i=0;
                 (i<(USHORT)openType->EaNameLength) && (i < sizeof(TdiTransportAddress));
                 i++)
			{
				if (openType->EaName[i] == TdiTransportAddress[i])
				{
					continue;
				}
				else
				{
					found = FALSE;
					break;
				}
			}

			if (found)
			{
				returnType = TDI_TRANSPORT_ADDRESS_FILE;
				break;
			}

			//
			// Is this a connection object?
			//

			found = TRUE;

			for (i=0;
                 (i<(USHORT)openType->EaNameLength) && (i < sizeof(TdiConnectionContext));
                 i++)
			{
				if (openType->EaName[i] == TdiConnectionContext[i])
				{
					 continue;
				}
				else
				{
					found = FALSE;
					break;
				}
			}

			if (found)
			{
				returnType = TDI_CONNECTION_FILE;
				break;
			}

		} while ( FALSE );

	}
	else
	{
		returnType = TDI_CONTROL_CHANNEL_FILE;
	}

	return(returnType);
}

#if DBG
VOID
AtalkDbgIncCount(
    IN DWORD    *Value
)
{
    KIRQL       OldIrql;

    ACQUIRE_SPIN_LOCK(&AtalkDebugSpinLock, &OldIrql);
    (*Value)++;
    RELEASE_SPIN_LOCK(&AtalkDebugSpinLock, OldIrql);
}

VOID
AtalkDbgDecCount(
    IN DWORD    *Value
)
{
    KIRQL       OldIrql;

    ACQUIRE_SPIN_LOCK(&AtalkDebugSpinLock, &OldIrql);
    ASSERT((*Value) > 0);
    (*Value)--;
    RELEASE_SPIN_LOCK(&AtalkDebugSpinLock, OldIrql);
}

#endif


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\atalk\sys\atp.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

	atp.h

Abstract:

	This module contains definitions for the ATP code.

Author:

	Jameel Hyder (jameelh@microsoft.com)
	Nikhil Kamkolkar (nikhilk@microsoft.com)

Revision History:
	19 Jun 1992		Initial Version

Notes:	Tab stop: 4
--*/

#ifndef	_ATP_
#define _ATP_

// Command/control bit masks.
#define ATP_REL_TIMER_MASK					0x07
#define ATP_STS_MASK						0x08
#define ATP_EOM_MASK						0x10
#define ATP_XO_MASK							0x20

// Values for function code
#define ATP_REQUEST							0x40
#define ATP_RESPONSE						0x80
#define ATP_RELEASE							0xC0
#define ATP_FUNC_MASK						0xC0

#define ATP_CMD_CONTROL_OFF					0
#define ATP_BITMAP_OFF						1
#define ATP_SEQ_NUM_OFF						1
#define ATP_TRANS_ID_OFF					2
#define ATP_USER_BYTES_OFF					4
#define ATP_DATA_OFF						8

#define	ATP_MAX_RESP_PKTS					8
#define	ATP_USERBYTES_SIZE					4
#define	ATP_HEADER_SIZE						8

// NOTE: Event handler routines- ATP has no event handling support


// ATP Address Object

#define	ATP_DEF_MAX_SINGLE_PKT_SIZE			578
#define	ATP_MAX_TOTAL_RESPONSE_SIZE			(ATP_MAX_RESP_PKTS * ATP_DEF_MAX_SINGLE_PKT_SIZE)
#define	ATP_DEF_SEND_USER_BYTES_ALL			((BOOLEAN)FALSE)

#define	ATP_DEF_RETRY_INTERVAL				20	// 2 seconds in 100ms units
#define	ATP_INFINITE_RETRIES				-1

#define ATP_REQ_HASH_SIZE					29
#define ATP_RESP_HASH_SIZE					37

// Values for the release timer (.5, 1, 2, 4, 8 minutes).
typedef LONG	RELEASE_TIMERVALUE;

#define	FIRSTVALID_TIMER 					0
#define	THIRTY_SEC_TIMER					0
#define	ONE_MINUTE_TIMER					1
#define	TWO_MINUTE_TIMER					2
#define	FOUR_MINUTE_TIMER 					3
#define	EIGHT_MINUTE_TIMER					4
#define	LAST_VALID_TIMER					4
#define	MAX_VALID_TIMERS					5

//	Different subtypes for ATP indication type.
#define	ATP_ALLOC_BUF	0
#define	ATP_USER_BUF	1
#define	ATP_USER_BUFX	2		// Do not indicate the packet to Atp with this.

struct	_ATP_RESP;

typedef	VOID	(*ATPAO_CLOSECOMPLETION)(
	IN	ATALK_ERROR				CloseResult,
	IN	PVOID					CloseContext
);

typedef VOID	(*ATP_REQ_HANDLER)(
	IN	ATALK_ERROR				Error,
	IN	PVOID					CompletionContext,
	IN	struct _ATP_RESP *		pAtpResp,
	IN	PATALK_ADDR				SourceAddress,
	IN	USHORT					RequestLength,
	IN 	PBYTE					RequestPacket,
	IN 	PBYTE					RequestUserBytes	// 4 bytes of user bytes
);

typedef	VOID	(*ATP_RESP_HANDLER)(
	IN	ATALK_ERROR				Error,
	IN	PVOID					CompletionContext,
	IN	PAMDL					RequestBuffer,
	IN	PAMDL					ResponseBuffer,
	IN	USHORT					ResponseSize,
	IN	PBYTE					ResponseUserBytes	// 4 bytes of user bytes
);


typedef	VOID	(FASTCALL *ATP_REL_HANDLER)(
	IN	ATALK_ERROR				Error,
	IN	PVOID					CompletionContext
);


//  ATP ADDRESS OBJECT	STATES

#define	ATPAO_OPEN				0x00000001
#define ATPAO_SENDUSERBYTESALL  0x00000002
#define	ATPAO_CACHED			0x00000004
#define	ATPAO_TIMERS			0x00000008
#define	ATPAO_CLEANUP			0x40000000
#define	ATPAO_CLOSING			0x80000000

#define ATPAO_SIGNATURE			(*(PULONG)"ATPA")

#if	DBG
#define	VALID_ATPAO(pAtpAddr)	(((pAtpAddr) != NULL) &&						\
								 ((pAtpAddr)->atpao_Signature == ATPAO_SIGNATURE))
#else
#define	VALID_ATPAO(pAtpAddr)	((pAtpAddr) != NULL)
#endif
typedef struct _ATP_ADDROBJ
{
#if DBG
	ULONG					atpao_Signature;
#endif

	LONG					atpao_RefCount;

	// State of the address object
	ULONG					atpao_Flags;

	//	We pass a pointer to the ATP Address object to the upper layers to
	//	use as the endpoint, and this same pointer is passed to DDP Open
	//	Address	as the ATP address handler context.

	//	Linkage list for all responses to AtLeastOnce (ALO) transactions.
	//	These are not kept in the resp hash table for efficiency. These
	//	happen very infrequently and only exist on the list until the
	//	SENDs complete.
	struct _ATP_RESP	* 	atpao_AloRespLinkage;

	// next Transaction id to be used
	USHORT					atpao_NextTid;

	// Maximum single packet size to be used (PAP needs this to be 512)
	USHORT					atpao_MaxSinglePktSize;

	// Pointer to the DDP address object that this will create
	PDDP_ADDROBJ			atpao_DdpAddr;

	// Completion routine to be called when socket is closed
	ATPAO_CLOSECOMPLETION	atpao_CloseComp;
	PVOID					atpao_CloseCtx;

	// Hash table of pending ATP PostReq
	struct _ATP_REQ 	*	atpao_ReqHash[ATP_REQ_HASH_SIZE];

	LIST_ENTRY				atpao_ReqList;			// List of requests for retry timer
	TIMERLIST				atpao_RetryTimer;		// Retry timer for ALL requests

	// Hash table of pending ATP PostResponses
	struct _ATP_RESP 	*	atpao_RespHash[ATP_RESP_HASH_SIZE];

	LIST_ENTRY				atpao_RespList;			// List of requests for release timer
	TIMERLIST				atpao_RelTimer;			// Release timer for ALL XO responses

	// handler and corres. contexts for requests
	ATP_REQ_HANDLER			atpao_ReqHandler;
	PVOID					atpao_ReqCtx;

	PATALK_DEV_CTX			atpao_DevCtx;
	ATALK_SPIN_LOCK			atpao_Lock;
} ATP_ADDROBJ, *PATP_ADDROBJ;


#define	ATP_REQ_EXACTLY_ONCE		0x0001
#define	ATP_REQ_RETRY_TIMER			0x0002
#define	ATP_REQ_REMOTE				0x0004
#define	ATP_REQ_RESPONSE_COMPLETE	0x0008
#define	ATP_REQ_CLOSING				0x8000

#define ATP_REQ_SIGNATURE			(*(PULONG)"ATRQ")
#if	DBG
#define	VALID_ATPRQ(pAtpReq)		(((pAtpReq) != NULL) &&						\
									 ((pAtpReq)->req_Signature == ATP_REQ_SIGNATURE))
#else
#define	VALID_ATPRQ(pAtpReq)		((pAtpReq) != NULL)
#endif
typedef struct _ATP_REQ
{
#if DBG
	ULONG					req_Signature;
#endif

	LONG					req_RefCount;

	// Linkage of requests on this address object (hash overflow)
	struct _ATP_REQ 	*	req_Next;
	struct _ATP_REQ 	**	req_Prev;

	LIST_ENTRY				req_List;		// List of requests for retry timer

	// BackPointer to the ATP address object. Need for reference/Dereference.
	PATP_ADDROBJ			req_pAtpAddr;

	// State of the request
	USHORT					req_Flags;

	// ATP Bitmap showing the response packets we are waiting for/expect.
	BYTE					req_Bitmap;

	BYTE					req_RecdBitmap;

	// Destination of this request
	ATALK_ADDR				req_Dest;

	// Request buffer for retransmission
	PAMDL					req_Buf;
	USHORT					req_BufLen;

	// Transaction id
	USHORT					req_Tid;

	union
	{
		BYTE				req_UserBytes[ATP_USERBYTES_SIZE];
		DWORD				req_dwUserBytes;
	};

	// User's response buffer
	PAMDL					req_RespBuf;

	//	Buffer descriptors for parts of the resp buf.
	PNDIS_BUFFER			req_NdisBuf[ATP_MAX_RESP_PKTS];

	USHORT					req_RespBufLen;

	//	Received response length
	USHORT					req_RespRecdLen;
	BYTE					req_RespUserBytes[ATP_USERBYTES_SIZE];

	LONG					req_RetryInterval;
	LONG					req_RetryCnt;

	//	Release timer value to send to the remote end.
	RELEASE_TIMERVALUE		req_RelTimerValue;

	// Retry time stamp, time at which the request will be retried if no response
	LONG					req_RetryTimeStamp;

	// Completion routine to be called when request is done
	ATALK_ERROR				req_CompStatus;
	ATP_RESP_HANDLER		req_Comp;
	PVOID					req_Ctx;
	ATALK_SPIN_LOCK			req_Lock;
} ATP_REQ, *PATP_REQ;

// ATP_RESP_REMOTE indicates that the response is not to a local socket in which
// case we can avoid trying to deliver to our sockets
#define	ATP_RESP_EXACTLY_ONCE			0x0001
#define	ATP_RESP_ONLY_USER_BYTES		0x0002
#define	ATP_RESP_REL_TIMER				0x0004
#define	ATP_RESP_VALID_RESP				0x0008
#define	ATP_RESP_SENT					0x0010
#define	ATP_RESP_TRANSMITTING			0x0020
#define	ATP_RESP_REMOTE					0x0040
#define	ATP_RESP_HANDLER_NOTIFIED		0x0080
#define	ATP_RESP_CANCELLED				0x0100
#define	ATP_RESP_RELEASE_RECD			0x0200
#define	ATP_RESP_CLOSING				0x8000

#define ATP_RESP_SIGNATURE				(*(PULONG)"ATRS")
#if	DBG
#define	VALID_ATPRS(pAtpResp)			(((pAtpResp) != NULL) &&				\
										 ((pAtpResp)->resp_Signature == ATP_RESP_SIGNATURE))
#else
#define	VALID_ATPRS(pAtpResp)			((pAtpResp) != NULL)
#endif
typedef struct _ATP_RESP
{
#if DBG
	ULONG					resp_Signature;
#endif

	LONG					resp_RefCount;

	// Linkage of responses on this address object (hash overflow)
	struct _ATP_RESP 	*	resp_Next;
	struct _ATP_RESP 	**	resp_Prev;

	LIST_ENTRY				resp_List;		// List of resp for release timer

	// BackPointer to the ATP address object
	PATP_ADDROBJ			resp_pAtpAddr;

	// Transaction id
	USHORT					resp_Tid;

	// ATP Bitmap from corresponding request
	BYTE					resp_Bitmap;
	BYTE					resp_UserBytesOnly;

	// Destination of this request
	ATALK_ADDR				resp_Dest;

	// State of the response
	USHORT					resp_Flags;

	// User's response buffer
	USHORT					resp_BufLen;
	PAMDL					resp_Buf;
	union
	{
		BYTE				resp_UserBytes[ATP_USERBYTES_SIZE];
		DWORD				resp_dwUserBytes;
	};

	// Release timer value, How long do we wait before release.
	LONG					resp_RelTimerTicks;

	// Release time stamp, time at which the request arrived.
	LONG					resp_RelTimeStamp;

	// Routine to call when release comes in, or release timer expires
	ATALK_ERROR				resp_CompStatus;
	ATP_REL_HANDLER			resp_Comp;
	PVOID					resp_Ctx;
	ATALK_SPIN_LOCK			resp_Lock;
} ATP_RESP, *PATP_RESP;


#define	ATP_RETRY_TIMER_INTERVAL	10		// 1 second in 100ms units
											// NOTE: This will essentially put dampers on
											//		 the RT stuff. Thats not too bad since
											//		 we are guaranteed to try every second atleast
#define	ATP_RELEASE_TIMER_INTERVAL	300		// 30 seconds in 100ms units

//	Values for the 0.5, 1, 2, 4, 8 minute timer in ATP_RELEASE_TIMER_INTERVAL units.
extern	SHORT	AtalkAtpRelTimerTicks[MAX_VALID_TIMERS];

//	Bitmaps for the sequence numbers in response packets.
extern	BYTE	AtpBitmapForSeqNum[ATP_MAX_RESP_PKTS];

extern	BYTE	AtpEomBitmapForSeqNum[ATP_MAX_RESP_PKTS];

typedef struct
{
	BYTE		atph_CmdCtrl;
	union
	{
		BYTE	atph_SeqNum;
		BYTE	atph_Bitmap;
	};
	USHORT		atph_Tid;
	union
	{
		BYTE	atph_UserBytes[ATP_USERBYTES_SIZE];
		DWORD	atph_dwUserBytes;
	};
} ATP_HEADER, *PATP_HEADER;

//	Exported prototypes
#define	AtalkAtpGetDdpAddress(pAtpAddr)	((pAtpAddr)->atpao_DdpAddr)

extern
ATALK_ERROR
AtalkAtpOpenAddress(
	IN		PPORT_DESCRIPTOR		pPort,
	IN		BYTE					Socket,
	IN OUT	PATALK_NODEADDR			pDesiredNode		OPTIONAL,
	IN		USHORT					MaxSinglePktSize,
	IN		BOOLEAN					SendUserBytesAll,
	IN		PATALK_DEV_CTX			pDevCtx				OPTIONAL,
	IN		BOOLEAN					CacheSocket,
	OUT		PATP_ADDROBJ	*		ppAtpAddr);

extern
ATALK_ERROR
AtalkAtpCleanupAddress(
	IN	PATP_ADDROBJ				pAtpAddr);

extern
ATALK_ERROR
AtalkAtpCloseAddress(
	IN	PATP_ADDROBJ				pAddr,
	IN	ATPAO_CLOSECOMPLETION		pCloseCmp	OPTIONAL,
	IN	PVOID						pCloseCtx	OPTIONAL);

extern
ATALK_ERROR
AtalkAtpPostReq(
	IN		PATP_ADDROBJ			pAddr,
	IN		PATALK_ADDR				pDest,
	OUT		PUSHORT					pTid,
	IN		USHORT					Flags,
	IN		PAMDL					pReq,
	IN		USHORT					ReqLen,
	IN		PBYTE					pUserBytes	OPTIONAL,
	IN OUT	PAMDL					pResp		OPTIONAL,
	IN  	USHORT					RespLen,
	IN		SHORT					RetryCnt,
	IN		LONG					RetryInterval,
	IN		RELEASE_TIMERVALUE		timerVal,
	IN		ATP_RESP_HANDLER		pCmpRoutine	OPTIONAL,
	IN		PVOID					pCtx		OPTIONAL);

extern
VOID
AtalkAtpSetReqHandler(
	IN		PATP_ADDROBJ			pAddr,
	IN		ATP_REQ_HANDLER			ReqHandler,
	IN		PVOID					ReqCtx		OPTIONAL);

extern
ATALK_ERROR
AtalkAtpPostResp(
	IN		PATP_RESP				pAtpResp,
	IN		PATALK_ADDR				pDest,
	IN OUT	PAMDL					pResp,
	IN		USHORT					RespLen,
	IN		PBYTE					pUbytes		OPTIONAL,
	IN		ATP_REL_HANDLER			pCmpRoutine,
	IN		PVOID					pCtx		OPTIONAL);

extern
ATALK_ERROR
AtalkAtpCancelReq(
	IN		PATP_ADDROBJ			pAtpAddr,
	IN		USHORT					Tid,
	IN		PATALK_ADDR				pDest);

extern
BOOLEAN
AtalkAtpIsReqComplete(
	IN		PATP_ADDROBJ			pAtpAddr,
	IN		USHORT					Tid,
	IN		PATALK_ADDR				pDest);

extern
ATALK_ERROR
AtalkAtpCancelResp(
	IN		PATP_RESP				pAtpResp);

extern
ATALK_ERROR
AtalkAtpCancelRespByTid(
	IN		PATP_ADDROBJ			pAtpAddr,
	IN		PATALK_ADDR				pDest,
	IN		USHORT					Tid);

extern
VOID
AtalkAtpPacketIn(
	IN	PPORT_DESCRIPTOR			pPortDesc,
	IN	PDDP_ADDROBJ				pDdpAddr,
	IN	PBYTE						pPkt,
	IN	USHORT						PktLen,
	IN	PATALK_ADDR					pSrcAddr,
	IN	PATALK_ADDR					pDstAddr,
	IN	ATALK_ERROR					ErrorCode,
	IN	BYTE						DdpType,
	IN	PATP_ADDROBJ				pAtpAddr,
	IN	BOOLEAN						OptimizePath,
	IN	PVOID						OptimizeCtx);

#define	AtalkAtpAddrReference(_pAtpAddr, _pError)								\
	{																			\
		KIRQL	OldIrql;														\
																				\
		ACQUIRE_SPIN_LOCK(&(_pAtpAddr)->atpao_Lock, &OldIrql);					\
		atalkAtpAddrRefNonInterlock((_pAtpAddr), _pError);						\
		RELEASE_SPIN_LOCK(&(_pAtpAddr)->atpao_Lock, OldIrql);					\
	}

#define	AtalkAtpAddrReferenceDpc(_pAtpAddr, _pError)							\
	{																			\
		ACQUIRE_SPIN_LOCK_DPC(&(_pAtpAddr)->atpao_Lock);						\
		atalkAtpAddrRefNonInterlock((_pAtpAddr), _pError);						\
		RELEASE_SPIN_LOCK_DPC(&(_pAtpAddr)->atpao_Lock);						\
	}

#define	atalkAtpAddrRefNonInterlock(_pAtpAddr, _pError)							\
	{																			\
		*(_pError) = ATALK_NO_ERROR;											\
		if (((_pAtpAddr)->atpao_Flags & (ATPAO_CLOSING|ATPAO_OPEN))==ATPAO_OPEN)\
		{																		\
			ASSERT((_pAtpAddr)->atpao_RefCount >= 1);							\
			(_pAtpAddr)->atpao_RefCount++;										\
		}																		\
		else																	\
		{																		\
			*(_pError) = ATALK_ATP_CLOSING;										\
			DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_WARN,								\
					("atalkAtpAddrRefNonInterlock: %lx %s (%ld) Failure\n",		\
					_pAtpAddr, __FILE__, __LINE__));							\
		}																		\
	}


VOID FASTCALL
AtalkAtpAddrDeref(
	IN OUT	PATP_ADDROBJ			pAtpAddr,
	IN		BOOLEAN					AtDpc);

#define	AtalkAtpAddrDereference(_pAtpAddr)										\
		AtalkAtpAddrDeref(_pAtpAddr, FALSE)

#define	AtalkAtpAddrDereferenceDpc(_pAtpAddr)									\
		AtalkAtpAddrDeref(_pAtpAddr, TRUE)

VOID FASTCALL
AtalkAtpRespDeref(
	IN		PATP_RESP				pAtpResp,
	IN		BOOLEAN					AtDpc);

#define	AtalkAtpRespDereference(_pAtrpResp)										\
		AtalkAtpRespDeref(_pAtrpResp, FALSE)

#define	AtalkAtpRespDereferenceDpc(_pAtrpResp)									\
		AtalkAtpRespDeref(_pAtrpResp, TRUE)

#define	AtalkAtpRespReferenceByPtr(_pAtpResp, _pError)							\
	{																			\
		KIRQL	OldIrql;														\
																				\
		*(_pError) = ATALK_NO_ERROR;											\
																				\
		ACQUIRE_SPIN_LOCK(&(_pAtpResp)->resp_Lock, &OldIrql);					\
		if (((_pAtpResp)->resp_Flags & ATP_RESP_CLOSING) == 0)					\
		{																		\
			(_pAtpResp)->resp_RefCount++;										\
		}																		\
		else																	\
		{																		\
			DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_WARN,								\
					("AtalkAtpRespReferenceByPtr: %lx %s (%ld) Failure\n",		\
					_pAtpResp, __FILE__, __LINE__));							\
			*(_pError) = ATALK_ATP_RESP_CLOSING;								\
		}																		\
		RELEASE_SPIN_LOCK(&(_pAtpResp)->resp_Lock, OldIrql);					\
	}

#define	AtalkAtpRespReferenceByPtrDpc(_pAtpResp, _pError)						\
	{																			\
		*(_pError) = ATALK_NO_ERROR;											\
																				\
		ACQUIRE_SPIN_LOCK_DPC(&(_pAtpResp)->resp_Lock);							\
		if (((_pAtpResp)->resp_Flags & ATP_RESP_CLOSING) == 0)					\
		{																		\
			(_pAtpResp)->resp_RefCount++;										\
		}																		\
		else																	\
		{																		\
			*(_pError) = ATALK_ATP_RESP_CLOSING;								\
			DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_WARN,								\
					("atalkAtpRespRefByPtrDpc: %lx %s (%ld) Failure\n",			\
					_pAtpResp, __FILE__, __LINE__));							\
		}																		\
		RELEASE_SPIN_LOCK_DPC(&(_pAtpResp)->resp_Lock);							\
	}

ATALK_ERROR
AtalkIndAtpPkt(
	IN		PPORT_DESCRIPTOR	pPortDesc,
	IN		PBYTE				pLookahead,
	IN		USHORT				PktLen,
	IN	OUT	PUINT				pXferOffset,
	IN		PBYTE				pLinkHdr,
	IN		BOOLEAN				ShortDdpHdr,
	OUT		PBYTE				SubType,
	OUT		PBYTE			* 	ppPacket,
	OUT		PNDIS_PACKET	*	pNdisPkt);

ATALK_ERROR
AtalkIndAtpCacheSocket(
	IN	struct _ATP_ADDROBJ	*	pAtpAddr,
	IN	PPORT_DESCRIPTOR		pPortDesc);

VOID
AtalkIndAtpUnCacheSocket(
	IN	struct _ATP_ADDROBJ	*	pAtpAddr);

VOID FASTCALL
AtalkAtpGenericRespComplete(
	IN	ATALK_ERROR				ErrorCode,
	IN	PATP_RESP				pAtpResp
);

VOID FASTCALL
AtalkIndAtpSetupNdisBuffer(
	IN	OUT	PATP_REQ		pAtpReq,
	IN		ULONG			MaxSinglePktSize
);

VOID FASTCALL
AtalkIndAtpReleaseNdisBuffer(
	IN	OUT	PATP_REQ		pAtpReq
);


//	ATALK_ERROR
//	AtalkIndAtpCacheLkUpSocket(
//		IN	PATALK_ADDR				pDestAddr,
//		OUT	struct _ATP_ADDROBJ	**	ppAtpAddr,
//		OUT	ATALK_ERROR			*	pError);
//
#define	AtalkIndAtpCacheLkUpSocket(pDestAddr, ppAtpAddr, pError)	\
	{																\
		USHORT					i;									\
		struct ATALK_CACHED_SKT	*pCachedSkt;						\
																	\
		*(pError) = ATALK_FAILURE;									\
																	\
		if (((pDestAddr)->ata_Network == AtalkSktCache.ac_Network) &&	\
			((pDestAddr)->ata_Node	== AtalkSktCache.ac_Node))		\
		{															\
			ACQUIRE_SPIN_LOCK_DPC(&AtalkSktCacheLock);				\
																	\
			for (i = 0, pCachedSkt = &AtalkSktCache.ac_Cache[0];	\
				 i < ATALK_CACHE_SKTMAX;							\
				 i++, pCachedSkt++)									\
			{														\
				if ((pCachedSkt->Type == (ATALK_CACHE_INUSE | ATALK_CACHE_ATPSKT))	&&	\
					(pCachedSkt->Socket == (pDestAddr)->ata_Socket))\
				{													\
					AtalkAtpAddrReferenceDpc(pCachedSkt->u.pAtpAddr,\
											 pError);				\
																	\
					if (ATALK_SUCCESS(*pError))						\
					{												\
						*(ppAtpAddr) = pCachedSkt->u.pAtpAddr;		\
					}												\
					break;											\
				}													\
			}														\
																	\
			RELEASE_SPIN_LOCK_DPC(&AtalkSktCacheLock);				\
		}															\
	}

VOID FASTCALL
atalkAtpReqDeref(
	IN		PATP_REQ				pAtpReq,
	IN		BOOLEAN					AtDpc);

//	MACROS
//	Top byte of network number is pretty static so we get rid of it and add
//	in the tid.
#define	ATP_HASH_TID_DESTADDR(_tid, _pAddr, _BucketSize)						\
			(((_pAddr)->ata_Node+((_pAddr)->ata_Network & 0xFF)+_tid)%(_BucketSize))

#define	atalkAtpReqReferenceByAddrTidDpc(_pAtpAddr, _pAddr, _Tid, _ppAtpReq, _pErr)	\
	{																			\
		PATP_REQ		__p;													\
		ULONG			__i;													\
																				\
		DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_INFO,									\
				("atalkAtpReqRefByAddrTid: %lx.%lx.%lx tid %lx\n",				\
				(_pAddr)->ata_Network, (_pAddr)->ata_Node,						\
				(_pAddr)->ata_Socket, (_Tid)));									\
																				\
		__i = ATP_HASH_TID_DESTADDR((_Tid), (_pAddr), ATP_REQ_HASH_SIZE);		\
		for (__p = (_pAtpAddr)->atpao_ReqHash[(__i)];							\
			 __p != NULL;														\
			 __p = __p->req_Next)												\
		{																		\
			if ((ATALK_ADDRS_EQUAL(&__p->req_Dest, (_pAddr))) &&				\
				(__p->req_Tid == (_Tid)))										\
			{																	\
				AtalkAtpReqReferenceByPtrDpc(__p, _pErr);						\
				if (ATALK_SUCCESS(*(_pErr)))									\
				{																\
					*(_ppAtpReq) = __p;											\
					DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_INFO,						\
							("atalkAtpReqRefByAddrTid: FOUND %lx\n", __p));		\
				}																\
				break;															\
			}																	\
		}																		\
		if (__p == NULL)														\
			*(_pErr) = ATALK_ATP_NOT_FOUND;										\
	}

#define	AtalkAtpReqReferenceByPtr(_pAtpReq, _pErr)								\
	{																			\
		KIRQL	OldIrql;														\
																				\
		*(_pErr) = ATALK_NO_ERROR;												\
																				\
		ACQUIRE_SPIN_LOCK(&(_pAtpReq)->req_Lock, &OldIrql);						\
		if (((_pAtpReq)->req_Flags & ATP_REQ_CLOSING) == 0)						\
		{																		\
			(_pAtpReq)->req_RefCount++;											\
		}																		\
		else																	\
		{																		\
			DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_WARN,								\
					("AtalkAtpReqReferenceByPtr: %lx %s (%ld) Failure\n",		\
					_pAtpReq, __FILE__, __LINE__));								\
			*(_pErr) = ATALK_ATP_REQ_CLOSING;									\
		}																		\
		RELEASE_SPIN_LOCK(&(_pAtpReq)->req_Lock, OldIrql);						\
	}

#define	AtalkAtpReqReferenceByPtrDpc(_pAtpReq, _pErr)							\
	{																			\
		*(_pErr) = ATALK_NO_ERROR;												\
																				\
		ACQUIRE_SPIN_LOCK_DPC(&(_pAtpReq)->req_Lock);							\
		if (((_pAtpReq)->req_Flags & ATP_REQ_CLOSING) == 0)						\
		{																		\
			(_pAtpReq)->req_RefCount++;											\
		}																		\
		else																	\
		{																		\
			*(_pErr) = ATALK_ATP_REQ_CLOSING;									\
			DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_WARN,								\
					("AtalkAtpReqReferenceByPtrDpc: %lx %s (%ld) Failure\n",	\
					_pAtpReq, __FILE__, __LINE__));								\
		}																		\
		RELEASE_SPIN_LOCK_DPC(&(_pAtpReq)->req_Lock);							\
	}

#define	atalkAtpRespReferenceNDpc(_pAtpResp, _N, _pError)						\
	{																			\
		*(_pError) = ATALK_NO_ERROR;											\
		ACQUIRE_SPIN_LOCK_DPC(&(_pAtpResp)->resp_Lock);							\
		if (((_pAtpResp)->resp_Flags & ATP_RESP_CLOSING) == 0)					\
		{																		\
			(_pAtpResp)->resp_RefCount += _N;									\
		}																		\
		else																	\
		{																		\
			*(_pError) = ATALK_ATP_RESP_CLOSING;								\
			DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_WARN,								\
					("atalkAtpRespReferenceNDpc: %lx %d %s (%ld) Failure\n",	\
					_pAtpResp, _N, __FILE__, __LINE__));						\
		}																		\
		RELEASE_SPIN_LOCK_DPC(&(_pAtpResp)->resp_Lock);							\
	}

// THIS SHOULD BE CALLED WITH ADDRESS LOCK HELD !!!

#define	atalkAtpRespReferenceByAddrTidDpc(_pAtpAddr, _pAddr, _Tid, _ppAtpResp, _pErr)\
	{																			\
		PATP_RESP		__p;													\
		ULONG			__i;													\
																				\
		__i = ATP_HASH_TID_DESTADDR((_Tid), (_pAddr), ATP_RESP_HASH_SIZE);		\
																				\
		DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_INFO,									\
				("atalkAtpRespRefByAddrTid: %lx.%lx.%lx tid %lx\n",				\
				(_pAddr)->ata_Network, (_pAddr)->ata_Node,						\
				(_pAddr)->ata_Socket, (_Tid)));									\
																				\
		for (__p = (_pAtpAddr)->atpao_RespHash[__i];							\
			 __p != NULL;														\
			 __p = __p->resp_Next)												\
		{																		\
			if (ATALK_ADDRS_EQUAL(&__p->resp_Dest, _pAddr) &&					\
				(__p->resp_Tid == (_Tid)))										\
			{																	\
				AtalkAtpRespReferenceByPtrDpc(__p, _pErr);						\
				if (ATALK_SUCCESS((*(_pErr))))									\
				{																\
					*(_ppAtpResp) = __p;										\
					DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_INFO,						\
							("atalkAtpRespRefByAddrTid: FOUND %lx\n", __p));	\
				}																\
				break;															\
			}																	\
		}																		\
		if (__p == NULL)														\
			*(_pErr) = ATALK_ATP_NOT_FOUND;										\
	}

#define		AtalkAtpReqDereference(_pAtpReq)									\
			atalkAtpReqDeref(_pAtpReq, FALSE)

#define		AtalkAtpReqDereferenceDpc(_pAtpReq)									\
			atalkAtpReqDeref(_pAtpReq, TRUE)

VOID FASTCALL
atalkAtpTransmitReq(
	IN		PATP_REQ			pAtpReq);

VOID FASTCALL
atalkAtpTransmitResp(
	IN		PATP_RESP			pAtpResp);

VOID FASTCALL
atalkAtpTransmitRel(
	IN		PATP_REQ			pAtpReq);

VOID
atalkAtpGetNextTidForAddr(
	IN		PATP_ADDROBJ		pAtpAddr,
	IN		PATALK_ADDR			pRemoteAddr,
	OUT		PUSHORT				pTid,
	OUT		PULONG				pIndex);

LOCAL LONG FASTCALL
atalkAtpReqTimer(
	IN	PTIMERLIST				pTimer,
	IN	BOOLEAN					TimerShuttingDown);

LOCAL LONG FASTCALL
atalkAtpRelTimer(
	IN	PTIMERLIST				pTimer,
	IN	BOOLEAN					TimerShuttingDown);

#define	atalkAtpBufferSizeToBitmap(_Bitmap, _BufSize, _SinglePktSize)			\
	{																			\
		SHORT	__bufSize = (_BufSize);											\
																				\
		(_Bitmap) = 0;															\
		while(__bufSize > 0)													\
		{																		\
			(_Bitmap) = ((_Bitmap) <<= 1) | 1;									\
			__bufSize -= (_SinglePktSize);										\
		}																		\
	}


#define	atalkAtpBitmapToBufferSize(_Size, _Bitmap, _SinglePktSize)				\
	{																			\
		BYTE	__bitmap = (_Bitmap);											\
		BOOLEAN __bitOn;														\
																				\
		_Size = 0;																\
		while (__bitmap)														\
		{																		\
			__bitOn = (__bitmap & 1);											\
			__bitmap >>= 1;														\
			if (__bitOn)														\
			{																	\
				(_Size) += (_SinglePktSize);									\
			}																	\
			else																\
			{																	\
				if (__bitmap)													\
				{																\
					(_Size) = -1;												\
				}																\
				break;															\
			}																	\
		}																		\
	}

VOID FASTCALL
atalkAtpSendReqComplete(
	IN	NDIS_STATUS				Status,
	IN	PSEND_COMPL_INFO		pSendInfo);

VOID FASTCALL
atalkAtpSendRespComplete(
	IN	NDIS_STATUS				Status,
	IN	PSEND_COMPL_INFO		pSendInfo);

VOID FASTCALL
atalkAtpSendRelComplete(
	IN	NDIS_STATUS				Status,
	IN	PSEND_COMPL_INFO		pSendInfo);

VOID
atalkAtpRespRefNextNc(
	IN		PATP_RESP			pAtpResp,
	OUT		PATP_RESP	 *  	ppNextNcResp,
	OUT		PATALK_ERROR		pError);

VOID
atalkAtpReqRefNextNc(
	IN		PATP_REQ			pAtpReq,
	OUT		PATP_REQ	*		pNextNcReq,
	OUT		PATALK_ERROR		pError);

VOID FASTCALL
atalkAtpRespComplete(
	IN	OUT	PATP_RESP			pAtpResp,
	IN		ATALK_ERROR			CompletionStatus);

VOID FASTCALL
atalkAtpReqComplete(
	IN	OUT	PATP_REQ			pAtpReq,
	IN		ATALK_ERROR			CompletionStatus);

#endif	// _ATP_

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\atalk\sys\atp.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

	atp.c

Abstract:

	This module contains the Appletalk Transaction Protocol code.

Author:

	Jameel Hyder (jameelh@microsoft.com)
	Nikhil Kamkolkar (nikhilk@microsoft.com)

Revision History:
	19 Jun 1992		Initial Version

Notes:	Tab stop: 4

	25 Mar 1994		JH - Changed the request response paradigm. It now works as follows:
					When a request comes in, a response structure is allocated, initialized
					and linked into the address object either in the hash table if it is a
					XO request or the ALO linear list if it an ALO.
					The GetReq handler is passed a pointer to the response structure. This
					is referenced for the GetReq handler. The GetReq handler must Dereference
					it explicity either in its release handler if a response was posted or
					after a CancelResp is called.

					The respDeref notifies the release handler when the reference goes to 1
					and frees it up when it goes to zero.

					The GetReq structure is now re-used if the handler so specifies. This
					avoids the free-ing and re-allocing of these structures as well as
					the need to call AtalkAtpGetReq() from within the handler.

					Retry and release timers are per-atp-address now instead of one per
					request and one per response. The release handler is not 'started'
					till a response is posted.
--*/

#include <atalk.h>
#pragma hdrstop
#define	FILENUM	  	ATP

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE_PAP, AtalkAtpOpenAddress)	// Since PAP is the only one which calls
													// at DISPATCH_LEVEL
#pragma alloc_text(PAGE_ATP, AtalkAtpCleanupAddress)
#pragma alloc_text(PAGE_ATP, AtalkAtpCloseAddress)
#pragma alloc_text(PAGE_ATP, AtalkAtpPostReq)
#pragma alloc_text(PAGE_ATP, AtalkAtpSetReqHandler)
#pragma alloc_text(PAGE_ATP, AtalkAtpPostResp)
#pragma alloc_text(PAGE_ATP, AtalkAtpCancelReq)
#pragma alloc_text(PAGE_ATP, AtalkAtpIsReqComplete)
#pragma alloc_text(PAGE_ATP, AtalkAtpCancelResp)
#pragma alloc_text(PAGE_ATP, AtalkAtpCancelRespByTid)
#pragma alloc_text(PAGE_ATP, AtalkAtpPacketIn)
#pragma alloc_text(PAGE_ATP, atalkAtpTransmitReq)
#pragma alloc_text(PAGE_ATP, atalkAtpSendReqComplete)
#pragma alloc_text(PAGE_ATP, atalkAtpTransmitResp)
#pragma alloc_text(PAGE_ATP, atalkAtpSendRespComplete)
#pragma alloc_text(PAGE_ATP, atalkAtpTransmitRel)
#pragma alloc_text(PAGE_ATP, atalkAtpSendRelComplete)
#pragma alloc_text(PAGE_ATP, atalkAtpRespComplete)
#pragma alloc_text(PAGE_ATP, atalkAtpReqComplete)
#pragma alloc_text(PAGE_ATP, atalkAtpGetNextTidForAddr)
#pragma alloc_text(PAGE_ATP, atalkAtpReqRefNextNc)
#pragma alloc_text(PAGE_ATP, atalkAtpReqDeref)
#pragma alloc_text(PAGE_ATP, atalkAtpRespRefNextNc)
#pragma alloc_text(PAGE_ATP, AtalkAtpRespDeref)
#pragma alloc_text(PAGE_ATP, atalkAtpReqTimer)
#pragma alloc_text(PAGE_ATP, atalkAtpRelTimer)
#pragma alloc_text(PAGE_ATP, AtalkAtpGenericRespComplete)

#endif

ATALK_ERROR
AtalkAtpOpenAddress(
	IN		PPORT_DESCRIPTOR		pPort,
	IN		BYTE					Socket,
	IN OUT	PATALK_NODEADDR			pDesiredNode		OPTIONAL,
	IN		USHORT					MaxSinglePktSize,
	IN		BOOLEAN					SendUserBytesAll,
	IN		PATALK_DEV_CTX			pDevCtx				OPTIONAL,
	IN		BOOLEAN					CacheSocket,
	OUT		PATP_ADDROBJ	*		ppAtpAddr
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PATP_ADDROBJ	pAtpAddr;
	ATALK_ERROR		error;

	do
	{
		if ((pAtpAddr = AtalkAllocZeroedMemory(sizeof(ATP_ADDROBJ))) == NULL)
		{
			error = ATALK_RESR_MEM;
			break;
		}

		//	Initialize this structure. Note that packet handler could
		//	entered with this context even before secondary initialization
		//	completes. So we make sure, that it will not touch anything
		//	until then by using the OPEN flag.

#if DBG
		pAtpAddr->atpao_Signature = ATPAO_SIGNATURE;
#endif

		//	Set creation reference count, include one each for release and retry timers
		pAtpAddr->atpao_RefCount 			= (CacheSocket ? 4 : 3);
		pAtpAddr->atpao_NextTid				= 1;
		pAtpAddr->atpao_MaxSinglePktSize 	= MaxSinglePktSize;
		pAtpAddr->atpao_DevCtx 				= pDevCtx;

		if (SendUserBytesAll)
		{
			pAtpAddr->atpao_Flags |= ATPAO_SENDUSERBYTESALL;
		}

		InitializeListHead(&pAtpAddr->atpao_ReqList);
		AtalkTimerInitialize(&pAtpAddr->atpao_RelTimer,
							 atalkAtpRelTimer,
							 ATP_RELEASE_TIMER_INTERVAL);

		InitializeListHead(&pAtpAddr->atpao_RespList);
		AtalkTimerInitialize(&pAtpAddr->atpao_RetryTimer,
							 atalkAtpReqTimer,
							 ATP_RETRY_TIMER_INTERVAL);

		//	Open the ddp socket
		error = AtalkDdpOpenAddress(pPort,
									Socket,
									pDesiredNode,
									AtalkAtpPacketIn,
									pAtpAddr,
									DDPPROTO_ANY,
									pDevCtx,
									&pAtpAddr->atpao_DdpAddr);

		if (!ATALK_SUCCESS(error))
		{
			//	Socket open error will be logged at the ddp level.
			DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_ERR,
					("AtalkAtpOpenAddress: AtalkDdpOpenAddress failed %ld\n", error));

			AtalkFreeMemory(pAtpAddr);
			break;
		}

		//	Activate the atp socket. Cache the socket if desired.
		//	This takes port lock on default port.
		if (CacheSocket)
		{
			if (!ATALK_SUCCESS(AtalkIndAtpCacheSocket(pAtpAddr, pPort)))
			{
				pAtpAddr->atpao_RefCount--;
				CacheSocket = FALSE;
			}
		}
		pAtpAddr->atpao_Flags |= (ATPAO_OPEN | ATPAO_TIMERS | (CacheSocket ? ATPAO_CACHED : 0));

		AtalkLockAtpIfNecessary();

		// Start the release timer for responses on this address
		AtalkTimerScheduleEvent(&pAtpAddr->atpao_RelTimer);

		// Start the retry timer for requests on this address
		AtalkTimerScheduleEvent(&pAtpAddr->atpao_RetryTimer);

		*ppAtpAddr = pAtpAddr;
	} while (FALSE);

	return error;
}




ATALK_ERROR
AtalkAtpCleanupAddress(
	IN	PATP_ADDROBJ			pAtpAddr
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PATP_REQ		pAtpReq, pAtpReqNext;
	PATP_RESP		pAtpResp, pAtpRespNext;
	ATP_REQ_HANDLER	ReqHandler;
	ATALK_ERROR		error = ATALK_PENDING;
	KIRQL			OldIrql;
	USHORT			i;
	BOOLEAN			cached, CancelTimers, done, ReEnqueue;

	ACQUIRE_SPIN_LOCK(&pAtpAddr->atpao_Lock, &OldIrql);

	CancelTimers = FALSE;
	done = FALSE;
	if (pAtpAddr->atpao_Flags & ATPAO_TIMERS)
	{
		pAtpAddr->atpao_Flags &= ~ATPAO_TIMERS;
		CancelTimers = TRUE;
	}

	if (pAtpAddr->atpao_Flags & ATPAO_CLEANUP)
	{
		done = TRUE;
	}
    else
    {
        // put a Cleanup refcount for this routine, since we are going to cleanup
        pAtpAddr->atpao_RefCount++;
    }
	pAtpAddr->atpao_Flags |= ATPAO_CLEANUP;

	RELEASE_SPIN_LOCK(&pAtpAddr->atpao_Lock, OldIrql);

	if (done)
	{
		return error;
	}

	if (CancelTimers)
	{
		//	Cancel the release timer
		if (AtalkTimerCancelEvent(&pAtpAddr->atpao_RelTimer, NULL))
		{
			AtalkAtpAddrDereference(pAtpAddr);
		}
        else
        {
			DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_ERR,
				("AtalkAtpCleanupAddress: couldn't cancel release timer\n"));
        }

		//	And also the retry timer
		if (AtalkTimerCancelEvent(&pAtpAddr->atpao_RetryTimer, NULL))
		{
			AtalkAtpAddrDereference(pAtpAddr);
		}
        else
        {
			DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_ERR,
				("AtalkAtpCleanupAddress: couldn't cancel retry timer\n"));
        }
	}

	ASSERT (pAtpAddr->atpao_RefCount >= 1);	// creation ref

	ACQUIRE_SPIN_LOCK(&pAtpAddr->atpao_Lock, &OldIrql);

	//	Call requests handler if set
	if ((ReqHandler = pAtpAddr->atpao_ReqHandler) != NULL)
	{
		pAtpAddr->atpao_ReqHandler = NULL;

		RELEASE_SPIN_LOCK(&pAtpAddr->atpao_Lock, OldIrql);

		(*ReqHandler)(ATALK_ATP_CLOSING,
					  pAtpAddr->atpao_ReqCtx,
					  NULL,
					  NULL,
					  0,
					  NULL,
					  NULL);

		//	Dereference address object.
		AtalkAtpAddrDereference(pAtpAddr);

		ACQUIRE_SPIN_LOCK(&pAtpAddr->atpao_Lock, &OldIrql);
	}

	//	Cancel all the requests.
	for (i = 0; i < ATP_REQ_HASH_SIZE; i++)
	{
		if ((pAtpReq = pAtpAddr->atpao_ReqHash[i]) == NULL)
		{
			//	If empty, go on to the next index in hash table.
			continue;
		}

		//	Includes the one we are starting with.
		atalkAtpReqRefNextNc(pAtpReq, &pAtpReqNext, &error);
		if (!ATALK_SUCCESS(error))
		{
			//	No requests left on this index. Go to the next one.
			continue;
		}

		while (TRUE)
		{
			if ((pAtpReq = pAtpReqNext) == NULL)
			{
				break;
			}

			if ((pAtpReqNext = pAtpReq->req_Next) != NULL)
			{
				atalkAtpReqRefNextNc(pAtpReq->req_Next, &pAtpReqNext, &error);
				if (!ATALK_SUCCESS(error))
				{
					//	No requests left on this index. Go to the next one.
					pAtpReqNext = NULL;
				}
			}

			//	Cancel this request.
			RELEASE_SPIN_LOCK(&pAtpAddr->atpao_Lock, OldIrql);

			AtalkAtpCancelReq(pAtpAddr,
							  pAtpReq->req_Tid,
							  &pAtpReq->req_Dest);

			ASSERTMSG("RefCount incorrect\n", (pAtpReq->req_RefCount >= 1));

            // remove the refcount added in the beginning of the loop
			AtalkAtpReqDereference(pAtpReq);
			ACQUIRE_SPIN_LOCK(&pAtpAddr->atpao_Lock, &OldIrql);
		}
	}

	//	Cancel all pending responses.
	for (i = 0; i < ATP_RESP_HASH_SIZE; i++)
	{
		if ((pAtpResp = pAtpAddr->atpao_RespHash[i]) == NULL)
		{
			//	If empty, go on to the next index in hash table.
			continue;
		}

		//	Includes the one we are starting with.
		atalkAtpRespRefNextNc(pAtpResp, &pAtpRespNext, &error);
		if (!ATALK_SUCCESS(error))
		{
			//	No requests left on this index. Go to the next one.
			continue;
		}

		while (TRUE)
		{
			if ((pAtpResp = pAtpRespNext) == NULL)
			{
				break;
			}

			if ((pAtpRespNext = pAtpResp->resp_Next) != NULL)
			{
				atalkAtpRespRefNextNc(pAtpResp->resp_Next, &pAtpRespNext, &error);
				if (!ATALK_SUCCESS(error))
				{
					//	No requests left on this index. Go to the next one.
					pAtpRespNext = NULL;
				}
			}

			//	Cancel this response
			RELEASE_SPIN_LOCK(&pAtpAddr->atpao_Lock, OldIrql);

			AtalkAtpCancelResp(pAtpResp);

            // remove the refcount added in the beginning of the loop
            AtalkAtpRespDereference(pAtpResp);

			ACQUIRE_SPIN_LOCK(&pAtpAddr->atpao_Lock, &OldIrql);
		}
	}

	//	if the socket was cached, uncache it, remove reference.
	cached = FALSE;
	if (pAtpAddr->atpao_Flags & ATPAO_CACHED)
	{
		cached = TRUE;
		pAtpAddr->atpao_Flags &= ~ATPAO_CACHED;
	}

	RELEASE_SPIN_LOCK(&pAtpAddr->atpao_Lock, OldIrql);

	if (cached)
	{
		AtalkIndAtpUnCacheSocket(pAtpAddr);
		AtalkAtpAddrDereference(pAtpAddr);
	}

    // remove the Cleanup refcount we put at the beginning of this routine
	AtalkAtpAddrDereference(pAtpAddr);

	return error;
}




ATALK_ERROR
AtalkAtpCloseAddress(
	IN	PATP_ADDROBJ			pAtpAddr,
	IN	ATPAO_CLOSECOMPLETION	pCloseCmp	OPTIONAL,
	IN	PVOID					pCloseCtx	OPTIONAL
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	KIRQL			OldIrql;
	BOOLEAN			cleanup;

	//	Cancel all the pending get requests.
	ACQUIRE_SPIN_LOCK(&pAtpAddr->atpao_Lock, &OldIrql);
	if ((pAtpAddr->atpao_Flags & ATPAO_CLOSING) == 0)
	{
		cleanup = TRUE;
		if (pAtpAddr->atpao_Flags & ATPAO_CLEANUP)
			cleanup = FALSE;

		pAtpAddr->atpao_Flags |= ATPAO_CLOSING;
		pAtpAddr->atpao_CloseComp = pCloseCmp;
		pAtpAddr->atpao_CloseCtx = pCloseCtx;
		RELEASE_SPIN_LOCK(&pAtpAddr->atpao_Lock, OldIrql);

		if (cleanup)
			AtalkAtpCleanupAddress(pAtpAddr);

		//	Remove the creation reference
		AtalkAtpAddrDereference(pAtpAddr);
	}
	else
	{
		//	We are already closing! this should never happen!
		ASSERT ((pAtpAddr->atpao_Flags & ATPAO_CLOSING) != 0);
		KeBugCheck(0);
	}

	return ATALK_PENDING;
}




ATALK_ERROR
AtalkAtpPostReq(
	IN		PATP_ADDROBJ			pAtpAddr,
	IN		PATALK_ADDR				pDest,
	OUT		PUSHORT					pTid,
	IN		USHORT					Flags,
	IN		PAMDL					pReq,
	IN		USHORT					ReqLen,
	IN		PBYTE					pUserBytes		OPTIONAL,
	IN OUT	PAMDL					pResp			OPTIONAL,
	IN  	USHORT					RespLen			OPTIONAL,
	IN		SHORT					RetryCnt,
	IN		LONG					RetryInterval	OPTIONAL,	// In timer ticks
	IN		RELEASE_TIMERVALUE		RelTimerVal,
	IN		ATP_RESP_HANDLER		pCmpRoutine		OPTIONAL,
	IN		PVOID					pCtx			OPTIONAL
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PATP_REQ		pAtpReq;
	KIRQL			OldIrql;
	ULONG			index;
	ATALK_ERROR		error = ATALK_NO_ERROR;

	//	Verify relevant parameters.
	do
	{
#ifdef	ATP_STRICT
		// NOTE: These checks need to be added to the TDI interface if/when ATP is
		//		 opened upto user mode.
		if ((ReqLen < 0)									||
			(ReqLen > pAtpAddr->atpao_MaxSinglePktSize)		||
			(RespLen < 0)									||
			(RespLen > (pAtpAddr->atpao_MaxSinglePktSize * ATP_MAX_RESP_PKTS)))
		{
			error = ATALK_BUFFER_TOO_BIG;
			break;
		}

		if ((RetryCnt < 0) && (RetryCnt != ATP_INFINITE_RETRIES))
		{
			error = ATALK_ATP_INVALID_RETRYCNT;
			break;
		}

		if ((RelTimerVal < FIRSTVALID_TIMER) || (RelTimerVal > LAST_VALID_TIMER))
		{
			error = ATALK_ATP_INVALID_TIMERVAL;
			break;
		}

		if (RetryInterval < 0)
		{
			error = ATALK_ATP_INVALID_RELINT;
			break;
		}
#endif
		// The only valid values for Flags are ATP_REQ_EXACTLY_ONCE and ATP_REQ_REMOTE
		ASSERT ((Flags & ~(ATP_REQ_EXACTLY_ONCE | ATP_REQ_REMOTE)) == 0);

		if (RetryInterval == 0)
		{
			RetryInterval = ATP_DEF_RETRY_INTERVAL;
		}

		//	Reference the address object.
		AtalkAtpAddrReference(pAtpAddr, &error);
		if (!ATALK_SUCCESS(error))
		{
			break;
		}

		if ((pAtpReq = (PATP_REQ)AtalkBPAllocBlock(BLKID_ATPREQ)) == NULL)
		{
			AtalkAtpAddrDereference(pAtpAddr);
			error = ATALK_RESR_MEM;
			break;
		}
	} while (FALSE);

	if (!ATALK_SUCCESS(error))
		return error;

	//	We have memory allocated and the address object referenced at this
	//	point. Initialize the request structure.
#if DBG
	RtlZeroMemory(pAtpReq, sizeof(ATP_REQ));
	pAtpReq->req_Signature = ATP_REQ_SIGNATURE;
#endif

	//	Initial reference count - for creation.
	//	Also another ref for this routine itself. Ran into a situation
	//	where a thread posting the request was preempted and a close called.
	//	So at the point where the first thread is doing the transmit call,
	//	the request structure is already freed.
	pAtpReq->req_RefCount		= 2;
	pAtpReq->req_pAtpAddr		= pAtpAddr;

	pAtpReq->req_RetryInterval	= RetryInterval;
	pAtpReq->req_RetryCnt		= RetryCnt;
	pAtpReq->req_RelTimerValue	= RelTimerVal;

	pAtpReq->req_Dest 	  		= *pDest;
	pAtpReq->req_Buf			= pReq;
	pAtpReq->req_BufLen			= ReqLen;

	if (RetryCnt != 0)
		Flags |= ATP_REQ_RETRY_TIMER;
	pAtpReq->req_Flags = Flags;

	if (pUserBytes != NULL)
	{
		RtlCopyMemory(pAtpReq->req_UserBytes,
					  pUserBytes,
					  ATP_USERBYTES_SIZE);
	}
	else
	{
		pAtpReq->req_dwUserBytes = 0;
	}

	pAtpReq->req_RespBuf 	= pResp;
	pAtpReq->req_RespBufLen = RespLen;
	atalkAtpBufferSizeToBitmap( pAtpReq->req_Bitmap,
								RespLen,
								pAtpAddr->atpao_MaxSinglePktSize);
	pAtpReq->req_RespRecdLen = 0;
	pAtpReq->req_RecdBitmap = 0;

	//	Setup the ndis buffer descriptors for the response buffer
	AtalkIndAtpSetupNdisBuffer(pAtpReq, pAtpAddr->atpao_MaxSinglePktSize);

	pAtpReq->req_Comp = pCmpRoutine;
	pAtpReq->req_Ctx = pCtx;

	INITIALIZE_SPIN_LOCK(&pAtpReq->req_Lock);

	ACQUIRE_SPIN_LOCK(&pAtpAddr->atpao_Lock, &OldIrql);
	atalkAtpGetNextTidForAddr(pAtpAddr,
							  pDest,
							  &pAtpReq->req_Tid,
							  &index);

	DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_INFO,
			("AtalkAtpPostReq: Tid %lx for %lx.%lx.%lx\n",
			pAtpReq->req_Tid, pDest->ata_Network,
			pDest->ata_Node, pDest->ata_Socket));

	//	Get the index where this request is supposed to go.
	//	Need to know the tid.
	index = ATP_HASH_TID_DESTADDR(pAtpReq->req_Tid, pDest, ATP_REQ_HASH_SIZE);

	//	Put this in the request queue
	AtalkLinkDoubleAtHead(pAtpAddr->atpao_ReqHash[index],
						  pAtpReq,
						  req_Next,
						  req_Prev);

	if (RetryCnt != 0)
	{
		// Set the time stamp when this should be retried
		pAtpReq->req_RetryTimeStamp = AtalkGetCurrentTick() + RetryInterval;

		InsertTailList(&pAtpAddr->atpao_ReqList, &pAtpReq->req_List);
	}

#ifdef	PROFILING
	INTERLOCKED_INCREMENT_LONG_DPC(&AtalkStatistics.stat_AtpNumRequests,
								   &AtalkStatsLock.SpinLock);
#endif
	RELEASE_SPIN_LOCK(&pAtpAddr->atpao_Lock, OldIrql);

	//	Return the tid
	*pTid = pAtpReq->req_Tid;

	//	Now send the request
	atalkAtpTransmitReq(pAtpReq);

	//	Remove the ref added at the beginning of this routine.
	AtalkAtpReqDereference(pAtpReq);

	return ATALK_NO_ERROR;
}



VOID
AtalkAtpSetReqHandler(
	IN		PATP_ADDROBJ			pAtpAddr,
	IN		ATP_REQ_HANDLER			ReqHandler,
	IN		PVOID					ReqCtx		OPTIONAL
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	KIRQL			OldIrql;
	ATALK_ERROR		error;

	ASSERT (ReqHandler != NULL);

	//	Set the request handler in the address object
	ACQUIRE_SPIN_LOCK(&pAtpAddr->atpao_Lock, &OldIrql);

	ASSERT((pAtpAddr->atpao_Flags & ATPAO_CLOSING) == 0);
	pAtpAddr->atpao_RefCount++;
	pAtpAddr->atpao_ReqHandler = ReqHandler;
	pAtpAddr->atpao_ReqCtx = ReqCtx;

	RELEASE_SPIN_LOCK(&pAtpAddr->atpao_Lock, OldIrql);
}




ATALK_ERROR
AtalkAtpPostResp(
	IN		PATP_RESP				pAtpResp,
	IN		PATALK_ADDR				pDest,
	IN OUT	PAMDL					pResp,
	IN  	USHORT					RespLen,
	IN		PBYTE					pUserBytes	OPTIONAL,
	IN		ATP_REL_HANDLER			pCmpRoutine,
	IN		PVOID					pCtx		OPTIONAL
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PATP_ADDROBJ	pAtpAddr;
	BOOLEAN			addrlocked = FALSE, resplocked = FALSE;
	BOOLEAN			DerefAddr = FALSE, DerefResp = FALSE;
	SHORT			ResponseLen;
	KIRQL			OldIrql;
	ATALK_ERROR		error;

	ASSERT(VALID_ATPRS(pAtpResp));
	ASSERT ((pAtpResp->resp_Flags & (ATP_RESP_VALID_RESP		|
									 ATP_RESP_REL_TIMER			|
									 ATP_RESP_HANDLER_NOTIFIED)) == 0);

	DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_INFO,
			("AtalkAtpPostResp: Posting response for Resp %lx, Tid %x %s\n",
			pAtpResp, pAtpResp->resp_Tid,
			(pAtpResp->resp_Flags & ATP_RESP_EXACTLY_ONCE) ? "XO" : "ALO"));

	pAtpAddr = pAtpResp->resp_pAtpAddr;
	ASSERT(VALID_ATPAO(pAtpAddr));

	do
	{
		KeRaiseIrql(DISPATCH_LEVEL, &OldIrql);

		if ((RespLen < 0) ||
			(RespLen > (pAtpAddr->atpao_MaxSinglePktSize * ATP_MAX_RESP_PKTS)))
		{
			DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_ERR,
					("AtalkAtpPostResp: Invalid buffer size %ld", RespLen));
			error = ATALK_BUFFER_INVALID_SIZE;
			break;
		}

		ACQUIRE_SPIN_LOCK_DPC(&pAtpAddr->atpao_Lock);
		addrlocked = TRUE;

		atalkAtpAddrRefNonInterlock(pAtpAddr, &error);
		if (!ATALK_SUCCESS(error))
		{
			break;
		}
		DerefAddr = TRUE;

		atalkAtpBitmapToBufferSize( ResponseLen,
									pAtpResp->resp_Bitmap,
									pAtpAddr->atpao_MaxSinglePktSize);
		if (ResponseLen < RespLen)
		{
			DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_ERR,
					("AtalkAtpPostResp: bitmap resplen (%d) < specified (%d)\n",
					ResponseLen, RespLen));
			error = ATALK_BUFFER_TOO_BIG;
			break;
		}


		AtalkAtpRespReferenceByPtrDpc(pAtpResp, &error);
		if (!ATALK_SUCCESS(error))
		{
			break;
		}
		DerefResp = TRUE;

		ACQUIRE_SPIN_LOCK_DPC(&pAtpResp->resp_Lock);
		resplocked = TRUE;

		if (pAtpResp->resp_Flags & (ATP_RESP_CLOSING | ATP_RESP_CANCELLED))
		{
			DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_ERR,
					("AtalkAtpPostResp: Closing/Cancelled %x", pAtpResp->resp_Flags));
			error = ATALK_ATP_RESP_CLOSING;
			break;
		}

		if (pAtpResp->resp_Flags & ATP_RESP_VALID_RESP)
		{
			DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_ERR,
					("AtalkAtpPostResp: Already posted !\n"));
			error = ATALK_ATP_RESP_TOOMANY;
			break;
		}

		//	No response was previously posted. OK to proceed.
		pAtpResp->resp_Flags |= ATP_RESP_VALID_RESP;

		pAtpResp->resp_Buf 		= pResp;
		pAtpResp->resp_BufLen	= RespLen;
		pAtpResp->resp_Comp 	= pCmpRoutine;

		ASSERT(pCmpRoutine != NULL);

		pAtpResp->resp_Ctx		= pCtx;
		pAtpResp->resp_Dest		= *pDest;
		pAtpResp->resp_UserBytesOnly = (pAtpResp->resp_Bitmap == 0) ? TRUE : FALSE;

		if (ARGUMENT_PRESENT(pUserBytes))
		{
			pAtpResp->resp_dwUserBytes = *(UNALIGNED ULONG *)pUserBytes;
		}
		else
		{
			pAtpResp->resp_dwUserBytes = 0;
		}

		DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_INFO,
				("AtalkAtpPostResp: Posting response for %s request id %x\n",
				(pAtpResp->resp_Flags & ATP_RESP_EXACTLY_ONCE) ? "XO" : "ALO",
				pAtpResp->resp_Tid));

		//	Now setup to start the release timer, but only for XO
		if (pAtpResp->resp_Flags & ATP_RESP_EXACTLY_ONCE)
		{
			pAtpResp->resp_Flags |= ATP_RESP_REL_TIMER;
			InsertTailList(&pAtpAddr->atpao_RespList, &pAtpResp->resp_List);
		}

		// For ALO set the comp status right here.
		pAtpResp->resp_CompStatus = error = ATALK_NO_ERROR;
	} while (FALSE);

	if (addrlocked)
	{
		if (resplocked)
			RELEASE_SPIN_LOCK_DPC(&pAtpResp->resp_Lock);
		RELEASE_SPIN_LOCK_DPC(&pAtpAddr->atpao_Lock);
	}

	if (ATALK_SUCCESS(error))
	{
		//	Send the response.
		ASSERT(pAtpResp->resp_Flags & ATP_RESP_VALID_RESP);
		DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_WARN,
				("AtalkAtpPostResp: Transmitting response %lx\n", pAtpResp));
		atalkAtpTransmitResp(pAtpResp);
	}

	//	Dereference the address object.
	if (DerefAddr)
		AtalkAtpAddrDereferenceDpc(pAtpAddr);

	if (DerefResp)
		AtalkAtpRespDereferenceDpc(pAtpResp);

	// for ALO transactions, we are done so take away the creation reference
	if ((pAtpResp->resp_Flags & ATP_RESP_EXACTLY_ONCE) == 0)
	{
		DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_INFO,
				("AtalkAtpPostResp: Removing creation reference for ALO request %lx Tid %x\n",
				pAtpResp, pAtpResp->resp_Tid));
		AtalkAtpRespDereferenceDpc(pAtpResp);
	}

	if (OldIrql != DISPATCH_LEVEL)
		KeLowerIrql(OldIrql);

	return error;
}



ATALK_ERROR
AtalkAtpCancelReq(
	IN		PATP_ADDROBJ		pAtpAddr,
	IN		USHORT				Tid,
	IN		PATALK_ADDR			pDest
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	ATALK_ERROR		error;
	KIRQL			OldIrql;
	PATP_REQ		pAtpReq;

	//	Find the request.
	ACQUIRE_SPIN_LOCK(&pAtpAddr->atpao_Lock, &OldIrql);
	atalkAtpReqReferenceByAddrTidDpc(pAtpAddr,
									 pDest,
									 Tid,
									 &pAtpReq,
									 &error);

	if (ATALK_SUCCESS(error))
	{
		DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_WARN,
				("AtalkAtpCancelReq: Cancelling req tid %x\n", Tid));

		//	Request is referenced for us. Remove the creation reference.
		ACQUIRE_SPIN_LOCK_DPC(&pAtpReq->req_Lock);

		// Do not cancel a request that has just about been satisfied anyway !!!
		if (pAtpReq->req_Flags & ATP_REQ_RESPONSE_COMPLETE)
		{
			error = ATALK_ATP_REQ_CLOSING;
		}

		RELEASE_SPIN_LOCK_DPC(&pAtpReq->req_Lock);

		RELEASE_SPIN_LOCK(&pAtpAddr->atpao_Lock, OldIrql);

		if (ATALK_SUCCESS(error))
		{
			//	Try to remove the creation reference
			atalkAtpReqComplete(pAtpReq, ATALK_ATP_REQ_CANCELLED);
		}

		//	Remove the reference added at the beginning.
		AtalkAtpReqDereference(pAtpReq);
	}
	else RELEASE_SPIN_LOCK(&pAtpAddr->atpao_Lock, OldIrql);

	return error;
}




BOOLEAN
AtalkAtpIsReqComplete(
	IN		PATP_ADDROBJ		pAtpAddr,
	IN		USHORT				Tid,
	IN		PATALK_ADDR			pDest
	)
/*++

Routine Description:

	This is always called at DISPATCH_LEVEL - only by PAP.

Arguments:

Return Value:


--*/
{
	PATP_REQ		pAtpReq;
	ATALK_ERROR		error;
	BOOLEAN			rc = FALSE;

	ASSERT (KeGetCurrentIrql() == DISPATCH_LEVEL);

	//	Find the request.
	ACQUIRE_SPIN_LOCK_DPC(&pAtpAddr->atpao_Lock);
	atalkAtpReqReferenceByAddrTidDpc(pAtpAddr,
									 pDest,
									 Tid,
									 &pAtpReq,
									 &error);

	if (ATALK_SUCCESS(error))
	{
		ACQUIRE_SPIN_LOCK_DPC(&pAtpReq->req_Lock);

		// Do not cancel a request that has just about been satisfied anyway !!!
		if (pAtpReq->req_Flags & ATP_REQ_RESPONSE_COMPLETE)
		{
			rc = TRUE;
		}

		RELEASE_SPIN_LOCK_DPC(&pAtpReq->req_Lock);
		AtalkAtpReqDereferenceDpc(pAtpReq);
	}

	RELEASE_SPIN_LOCK_DPC(&pAtpAddr->atpao_Lock);

	return rc;
}


ATALK_ERROR
AtalkAtpCancelResp(
	IN		PATP_RESP			pAtpResp
	)
/*++

Routine Description:

	NOTE: A Response can be cancelled in two states:
		- *before* a response is posted
			In this case no release handler is there so an extra dereference needs to be done
		- *after* a response is posted
			In this case a release handler is associated which will do the final dereference.

Arguments:


Return Value:


--*/
{
	BOOLEAN			extraDeref = FALSE, CompleteResp = FALSE;
	KIRQL			OldIrql;
	ATALK_ERROR		error;

	DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_INFO,
			("AtalkAtpCancelResp: Cancelling response for tid %x %s\n",
			pAtpResp->resp_Tid,
			(pAtpResp->resp_Flags & ATP_RESP_EXACTLY_ONCE) ? "XO" : "ALO"));

	AtalkAtpRespReferenceByPtr(pAtpResp, &error);

	if (ATALK_SUCCESS(error))
	{
		//	Remove the creation reference for it.
		//	Only XO responses can be cancelled, if a repsonse has been posted.
		ACQUIRE_SPIN_LOCK(&pAtpResp->resp_Lock, &OldIrql);

		if ((pAtpResp->resp_Flags & ATP_RESP_VALID_RESP) == 0)
			extraDeref  = TRUE;

		pAtpResp->resp_Flags |= ATP_RESP_CANCELLED;

		if (pAtpResp->resp_Flags & ATP_RESP_EXACTLY_ONCE)
		{
			if (pAtpResp->resp_Flags & ATP_RESP_REL_TIMER)
			{
				ASSERT (pAtpResp->resp_Flags & ATP_RESP_VALID_RESP);
			}
			CompleteResp = TRUE;
		}
		else if ((pAtpResp->resp_Flags & ATP_RESP_VALID_RESP) == 0)
			CompleteResp = TRUE;

		RELEASE_SPIN_LOCK(&pAtpResp->resp_Lock, OldIrql);

		if (extraDeref)
			AtalkAtpRespDereference(pAtpResp);

		if (CompleteResp)
		{
			//	Try to remove the creation reference
			atalkAtpRespComplete(pAtpResp, ATALK_ATP_RESP_CANCELLED);
		}

		// Remove the reference added at the beginning.
		AtalkAtpRespDereference(pAtpResp);
	}
	else
	{
		DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_ERR,
				("AtalkAtpCancelResp: Failed to reference resp %lx, flags %x, tid %x\n",
				pAtpResp, pAtpResp->resp_Flags, pAtpResp->resp_Tid));
	}

	return error;
}




ATALK_ERROR
AtalkAtpCancelRespByTid(
	IN		PATP_ADDROBJ			pAtpAddr,
	IN		PATALK_ADDR				pSrcAddr,
	IN		USHORT					Tid
/*++

Routine Description:


Arguments:


Return Value:


--*/
	)
{
	ATALK_ERROR	error;
	PATP_RESP	pAtpResp;

	ASSERT (VALID_ATPAO(pAtpAddr));

	ACQUIRE_SPIN_LOCK_DPC(&pAtpAddr->atpao_Lock);

	atalkAtpRespReferenceByAddrTidDpc(pAtpAddr, pSrcAddr, Tid, &pAtpResp, &error);

	RELEASE_SPIN_LOCK_DPC(&pAtpAddr->atpao_Lock);

	if (ATALK_SUCCESS(error))
	{
		error = AtalkAtpCancelResp(pAtpResp);
		AtalkAtpRespDereferenceDpc(pAtpResp);
	}

	return error;
}


VOID
AtalkAtpPacketIn(
	IN	PPORT_DESCRIPTOR	pPortDesc,
	IN	PDDP_ADDROBJ		pDdpAddr,
	IN	PBYTE				pPkt,
	IN	USHORT				PktLen,
	IN	PATALK_ADDR			pSrcAddr,
	IN	PATALK_ADDR			pDstAddr,
	IN	ATALK_ERROR			ErrorCode,
	IN	BYTE				DdpType,
	IN	PATP_ADDROBJ		pAtpAddr,
	IN	BOOLEAN				OptimizedPath,
	IN	PVOID				OptimizeCtx
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	ATALK_ERROR		error;
	NTSTATUS		ntStatus;
	USHORT			atpDataSize;
	ULONG			index;
	BYTE			controlInfo, function, relTimer, bitmap;
	USHORT			seqNum, tid, startOffset;
	SHORT			expectedRespSize;
	ULONG			bytesCopied;
	BOOLEAN			sendSts, eomFlag, xoFlag;
	BOOLEAN			RetransmitResp = FALSE;

	PATP_REQ		pAtpReq;
	ATP_REQ_HANDLER	ReqHandler;
	PATP_RESP		pAtpResp;

	BOOLEAN			UnlockAddr = FALSE, DerefAddr = FALSE;
	PBYTE			pDgram 	= pPkt;
	TIME			TimeS, TimeE, TimeD;

	TimeS = KeQueryPerformanceCounter(NULL);

	ASSERT(VALID_ATPAO(pAtpAddr));

	do
	{
		//	Check for incoming errors
		if ((!ATALK_SUCCESS(ErrorCode) &&
			 (ErrorCode != ATALK_SOCKET_CLOSED))	||
			(DdpType != DDPPROTO_ATP))
		{
			//	Drop the packet. Invalid packet error log.
			TMPLOGERR();
			error = ATALK_ATP_INVALID_PKT;
			break;
		}

		if (ErrorCode == ATALK_SOCKET_CLOSED)
		{
			//	Our ddp address pointer is no longer valid. It will be potentially
			//	be freed after return from this call! Only valid request on this
			//	ATP request will now be AtpCloseAddress(). Also, we should never
			//	be called with this address object by DDP.
			ACQUIRE_SPIN_LOCK_DPC(&pAtpAddr->atpao_Lock);
			pAtpAddr->atpao_DdpAddr = NULL;
			pAtpAddr->atpao_Flags  &= ~ATPAO_OPEN;
			RELEASE_SPIN_LOCK_DPC(&pAtpAddr->atpao_Lock);

			// If we are coming in via the optimized path and socket closed
			// deref the address object since it was referenced within the
			// indication code.
			if (OptimizedPath)
			{
				AtalkAtpAddrDereferenceDpc(pAtpAddr);
			}
			error = ErrorCode;
			break;
		}

		//	Make sure that we are not called after the ddp socket is closed.
		ASSERT(pAtpAddr->atpao_Flags & ATPAO_OPEN);

		if (PktLen < ATP_HEADER_SIZE)
		{
			error = ATALK_ATP_INVALID_PKT;
			break;
		}

		//	This must fail if OPEN is not set/initialization.
		error = ATALK_NO_ERROR;
		if (!OptimizedPath)
		{
			AtalkAtpAddrReferenceDpc(pAtpAddr, &error);
		}
	} while (FALSE);

	if (!ATALK_SUCCESS(error))
	{
		return;
	}

	//	Dereference address at the end,unless we want to keep it for some reason.
	DerefAddr = TRUE;

	//	Get the static fields from the ATP header.
	controlInfo = *pDgram++;


	function = (controlInfo & ATP_FUNC_MASK);
	relTimer = (controlInfo & ATP_REL_TIMER_MASK);
	xoFlag   = ((controlInfo & ATP_XO_MASK) != 0);
	eomFlag  = ((controlInfo & ATP_EOM_MASK) != 0);
	sendSts	 = ((controlInfo & ATP_STS_MASK) != 0);

	//	Get the bitmap/sequence number
	bitmap = *pDgram++;
	seqNum = (USHORT)bitmap;

	//	Get the transaction id
	GETSHORT2SHORT(&tid, pDgram);
	pDgram += sizeof(USHORT);

	DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_INFO,
			("AtalkAtpPacketIn: Packet tid %lx fu %lx ci %lx\n",
			tid, function, controlInfo));

	//	pDgram now points to the user bytes.
	do
	{
		//	Check all the values
		if (relTimer > LAST_VALID_TIMER)
		{
			//	Use a thirty second timer value.
			relTimer = THIRTY_SEC_TIMER;
		}

		atpDataSize = PktLen - ATP_HEADER_SIZE;
		if (atpDataSize > pAtpAddr->atpao_MaxSinglePktSize)
		{
			error = ATALK_ATP_INVALID_PKT;
			break;
		}

		ACQUIRE_SPIN_LOCK_DPC(&pAtpAddr->atpao_Lock);
		UnlockAddr = TRUE;

		switch (function)
		{
		  case ATP_REQUEST:
			DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_INFO,
					("AtalkAtpPacketIn: Received REQUEST from %lx.%lx.%lx (%d.%d.%d)\n",
					pSrcAddr->ata_Network, pSrcAddr->ata_Node, pSrcAddr->ata_Socket,
					pSrcAddr->ata_Network, pSrcAddr->ata_Node, pSrcAddr->ata_Socket));

			if (xoFlag)
			{
				//	ExactlyOnce Transaction
				//	Check for a queued response. If available use it.
				atalkAtpRespReferenceByAddrTidDpc(pAtpAddr,
												  pSrcAddr,
												  tid,
												  &pAtpResp,
												  &error);

				if (ATALK_SUCCESS(error))
				{
					ASSERT (pAtpResp->resp_Flags & ATP_RESP_EXACTLY_ONCE);

					//	Found a response corresponding to this request. It
					//	is referenced for us. Retransmit it, if there is a
					//	response posted on it.

					//	Check to see if this response has a valid response
					//	posted by the atp client yet. If so reset the release timer.
					ACQUIRE_SPIN_LOCK_DPC(&pAtpResp->resp_Lock);

					if (pAtpResp->resp_Flags & ATP_RESP_VALID_RESP)
					{
						if ((pAtpResp->resp_Flags & (ATP_RESP_TRANSMITTING | ATP_RESP_SENT)) == ATP_RESP_SENT)
						{

							RetransmitResp = TRUE;
							if (pAtpResp->resp_Flags & ATP_RESP_REL_TIMER)
							{
								DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_INFO,
										("AtalkAtpPacketIn: Retransmitting request %lx, tid %x (%x)\n",
										pAtpResp, pAtpResp->resp_Tid, pAtpResp->resp_Flags));

								pAtpResp->resp_RelTimeStamp = AtalkGetCurrentTick() +
																pAtpResp->resp_RelTimerTicks;
								DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_WARN,
										("AtalkAtpPacketIn: Restarted reltimer %lx\n", pAtpResp->resp_Tid));

								//	Set the latest bitmap for the request! We
								//	shouldn't touch this if no valid response is yet
								//	posted, so that we use the one in the first request
								//	packet received.
								pAtpResp->resp_Bitmap	= bitmap;
							}
							else
							{
								error = ATALK_ATP_RESP_CLOSING;

								//	Timer already fired. Drop the request.
								DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_ERR,
										("AtalkAtpPacketIn: Req recv after Reltimer fired ? Flags %lx\n",
										pAtpResp->resp_Flags));

								ASSERT (pAtpResp->resp_Flags & ATP_RESP_CLOSING);
							}
						}
					}
					else
					{
						error = ATALK_ATP_NO_VALID_RESP;
					}

					RELEASE_SPIN_LOCK_DPC(&pAtpResp->resp_Lock);
					RELEASE_SPIN_LOCK_DPC(&pAtpAddr->atpao_Lock);
					UnlockAddr = FALSE;

					if (ATALK_SUCCESS(error))
					{
						ASSERT(pAtpResp->resp_Flags & ATP_RESP_VALID_RESP);
						if (RetransmitResp)
						{
							DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_WARN,
									("AtalkAtpPacketIn: Retransmitting response %lx\n", pAtpResp));

							INTERLOCKED_INCREMENT_LONG_DPC(&AtalkStatistics.stat_AtpNumRemoteRetries,
														   &AtalkStatsLock.SpinLock);
							atalkAtpTransmitResp(pAtpResp);
						}
					}

					//	Remove the refererence on this response structure.
					AtalkAtpRespDereferenceDpc(pAtpResp);
					break;
				}
			}

            // make sure the 4 bytes (pAtpResp->resp_dwUserBytes) exist
            if (PktLen < (ATP_USERBYTES_SIZE + sizeof(ULONG)))
            {
				error = ATALK_ATP_INVALID_PKT;
                ASSERT(0);
				break;
            }

			// Its either an ALO request or an XO request which we have not seen it before
			//	Decode the response bitmap. We're still holding the address spinlock
			atalkAtpBitmapToBufferSize( expectedRespSize,
										bitmap,
										pAtpAddr->atpao_MaxSinglePktSize);
			if (expectedRespSize < 0)
			{
				error = ATALK_ATP_INVALID_PKT;
				break;
			}

			if (xoFlag)
			{
				INTERLOCKED_INCREMENT_LONG_DPC(&AtalkStatistics.stat_AtpNumXoResponse,
											   &AtalkStatsLock.SpinLock);
			}
			else
			{
				INTERLOCKED_INCREMENT_LONG_DPC(&AtalkStatistics.stat_AtpNumAloResponse,
											   &AtalkStatsLock.SpinLock);
			}

			//	New request. Check for request handler set
			if ((ReqHandler = pAtpAddr->atpao_ReqHandler) == NULL)
			{
				DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_ERR,
						("AtalkAtpPacketIn: No GetRequests for request\n"));

				error = ATALK_ATP_NO_GET_REQ;
				break;
			}

			//	Allocate memory for a send response structure.
			if ((pAtpResp =(PATP_RESP)AtalkBPAllocBlock(BLKID_ATPRESP)) == NULL)
			{
				DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_ERR,
						("AtalkAtpPacketIn: Could not alloc mem for resp\n"));

				error = ATALK_RESR_MEM;
				break;
			}

#if DBG
			RtlZeroMemory(pAtpResp, sizeof(ATP_RESP));
			pAtpResp->resp_Signature = ATP_RESP_SIGNATURE;
#endif
			//	Initialize the send response structure. Note that we do
			//	not have a posted response yet for XO or this is an ALO

			//	Initialize spinlock/list
			INITIALIZE_SPIN_LOCK(&pAtpResp->resp_Lock);

			//  Reference for Creation and indication
			pAtpResp->resp_RefCount = 2;

			//	Remember the destination of this response.
			pAtpResp->resp_Dest = *pSrcAddr;
			pAtpResp->resp_Tid	= tid;
			pAtpResp->resp_Bitmap = bitmap;

			//	Backpointer to the address object
			pAtpResp->resp_pAtpAddr = pAtpAddr;

			//	Remember a response needs to be posted by the atp client.
			pAtpResp->resp_Flags = (OptimizedPath ? ATP_RESP_REMOTE : 0);
			pAtpResp->resp_UserBytesOnly = (bitmap == 0) ? TRUE : FALSE;
			pAtpResp->resp_Comp = NULL;
			pAtpResp->resp_Ctx = NULL;
			pAtpResp->resp_dwUserBytes = *(UNALIGNED ULONG *)(pDgram + ATP_USERBYTES_SIZE);

			if (xoFlag)
			{
				//	Get the index into the hash response array where this
				//	response would be.
				index = ATP_HASH_TID_DESTADDR(tid, pSrcAddr, ATP_RESP_HASH_SIZE);

				DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_INFO,
							("AtalkAtpPacketIn: XO Req Index %lx resp for %lx-%lx.%lx.%lx %d\n",
							index, tid, pSrcAddr->ata_Network, pSrcAddr->ata_Node,
							pSrcAddr->ata_Socket, AtalkAtpRelTimerTicks[relTimer]));

				//	Put this in the XO response queue - LOCK Should be acquired!
				AtalkLinkDoubleAtHead(pAtpAddr->atpao_RespHash[index],
									  pAtpResp,
									  resp_Next,
									  resp_Prev);

				pAtpResp->resp_Flags |= ATP_RESP_EXACTLY_ONCE;
				pAtpResp->resp_RelTimerTicks = (LONG)AtalkAtpRelTimerTicks[relTimer];
				pAtpResp->resp_RelTimeStamp = AtalkGetCurrentTick() + pAtpResp->resp_RelTimerTicks;
			}
			else
			{
				DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_INFO,
							("AtalkAtpPacketIn: ALO Req resp for %lx-%lx.%lx %d\n",
							tid, pSrcAddr->ata_Network, pSrcAddr->ata_Node,
							pSrcAddr->ata_Socket));

				//	Put this in the ALO response queue - LOCK Should be acquired!
				AtalkLinkDoubleAtHead(pAtpAddr->atpao_AloRespLinkage,
									  pAtpResp,
									  resp_Next,
									  resp_Prev);
			}

			//	We dont want to have the initial ref go away, as we have
			//	inserted a resp into the addr resp list.
			DerefAddr = FALSE;

			error = ATALK_NO_ERROR;

			RELEASE_SPIN_LOCK_DPC(&pAtpAddr->atpao_Lock);
			UnlockAddr = FALSE;

			DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_INFO,
					("AtalkAtpPacketIn: Indicating request %lx, tid %x %s\n",
					pAtpResp, tid,
					(pAtpResp->resp_Flags & ATP_RESP_EXACTLY_ONCE) ? "XO" : "ALO"));

#ifdef	PROFILING
			TimeD = KeQueryPerformanceCounter(NULL);
#endif
			(*ReqHandler)(ATALK_NO_ERROR,
						  pAtpAddr->atpao_ReqCtx,
						  pAtpResp,
						  pSrcAddr,
						  atpDataSize,
						  pDgram + ATP_USERBYTES_SIZE,
						  pDgram);

#ifdef	PROFILING
			TimeE = KeQueryPerformanceCounter(NULL);
			TimeE.QuadPart -= TimeD.QuadPart;

			INTERLOCKED_INCREMENT_LONG_DPC(&AtalkStatistics.stat_AtpNumReqHndlr,
										   &AtalkStatsLock.SpinLock);
			INTERLOCKED_ADD_LARGE_INTGR(&AtalkStatistics.stat_AtpReqHndlrProcessTime,
										 TimeE,
										 &AtalkStatsLock.SpinLock);
#endif
			break;

		  case ATP_RESPONSE:
			DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_INFO,
					("AtalkAtpPacketIn: Received RESPONSE from %lx.%lx.%lx, SeqNum %d tid %lx ss %lx\n",
					pSrcAddr->ata_Network, pSrcAddr->ata_Node, pSrcAddr->ata_Socket,
					seqNum, tid, sendSts));

			if (seqNum > (ATP_MAX_RESP_PKTS-1))
			{
				//	Drop the packet. Invalid packet error log.
				TMPLOGERR();
				break;
			}

			//	See if we have a request for this tid and remote address.
			if (OptimizedPath)
			{
				pAtpReq	= (PATP_REQ)OptimizeCtx;
				ASSERT (VALID_ATPRQ(pAtpReq));
				ASSERT (pAtpReq->req_Bitmap == 0);
			}
			else
			{
				atalkAtpReqReferenceByAddrTidDpc(pAtpAddr,
												 pSrcAddr,
												 tid,
												 &pAtpReq,
												 &error);
			}

			if (!ATALK_SUCCESS(error))
			{
				//	We dont have a corresponding pending request. Ignore.
				DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_WARN,
						("AtalkAtpPacketIn: No pending request for tid %lx\n", tid));
				break;
			}

			do
			{
				if (!OptimizedPath)
				{
					//	Check the request bitmap, which could be zero if the user only
					//	wanted the user bytes and passed in a null response buffer.
					ACQUIRE_SPIN_LOCK_DPC(&pAtpReq->req_Lock);

					//	If we are the first packet, copy the response user bytes.
					if (seqNum == 0)
					{
						RtlCopyMemory(pAtpReq->req_RespUserBytes,
									  pDgram,
									  ATP_USERBYTES_SIZE);
					}

					//	Now skip over the user bytes
					pDgram += ATP_USERBYTES_SIZE;

					//	Do we want to keep this response? Check the corresponding
					//	bit in our current bitmap set.
					if (((pAtpReq->req_RecdBitmap & AtpBitmapForSeqNum[seqNum]) != 0) ||
						((pAtpReq->req_Bitmap & AtpBitmapForSeqNum[seqNum]) == 0))
					{
						RELEASE_SPIN_LOCK_DPC(&pAtpReq->req_Lock);
						//	We dont care about this packet. We already received it or weren't
						//	expecting it.
						break;
					}

					//	We want this response. Set bit in the recd bitmap. And
					//	Clear it in the expected packets req_Bitmap.

					//	!!!NOTE!!! 	We can release the spinlock even though the copy
					//				is not done. We have a ref to the req, and it wont
					//				get completed before that is done.
					pAtpReq->req_Bitmap 			&= ~AtpBitmapForSeqNum[seqNum];
					pAtpReq->req_RecdBitmap 		|= AtpBitmapForSeqNum[seqNum];
					pAtpReq->req_RespRecdLen	 	+= atpDataSize;

					DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_INFO,
							("AtalkAtpPacketIn: req_Bitmap %x, req_RecdBitmap %x\n",
							pAtpReq->req_Bitmap, pAtpReq->req_RecdBitmap));


					//	Now if eom is set, we need to reset all high order bits
					//	of the req_Bitmap. req_RecdBitmap should now indicate all
					//	the buffers we received. The two should be mutually exclusive
					//	at this point.
					if (eomFlag)
					{
						pAtpReq->req_Bitmap &= AtpEomBitmapForSeqNum[seqNum];
						ASSERT((pAtpReq->req_Bitmap & pAtpReq->req_RecdBitmap) == 0);
					}

					if (sendSts)
					{
						//	Reset timer since we are going to retransmit the request
						pAtpReq->req_RetryTimeStamp = AtalkGetCurrentTick() +
															pAtpReq->req_RetryInterval;
					}

					RELEASE_SPIN_LOCK_DPC(&pAtpReq->req_Lock);

					//	Copy the data into the users buffer. Check if there's room.
					startOffset = (USHORT)seqNum * pAtpAddr->atpao_MaxSinglePktSize;
					if (pAtpReq->req_RespBufLen < (startOffset + atpDataSize))
					{
						//	This should be a rare case; packet was in bitmap limits,
						//	but still wouldn't fit into user space.The other way this
						//	could occure is if the responder is sending less than full
						//	responses -- we don't "synch" up the user buffer until all
						//	packets have been received.

						//	We want to give up now, call the comp rotuine signaling
						//	the error -- unthread and free the request control block
						//	cancel the retry timer.

						ASSERT(0);
                        error = ATALK_RESR_MEM;
				        atalkAtpReqComplete(pAtpReq, error);
                        break;
					}

					if ((atpDataSize > 0) && (pAtpReq->req_RespBuf != NULL))
					{
						//	We have room to copy the data into the users buffer.
						ntStatus = TdiCopyBufferToMdl(pDgram,
													  0,
													  atpDataSize,
													  pAtpReq->req_RespBuf,
													  startOffset,
													  &bytesCopied);

						ASSERT(bytesCopied == atpDataSize);
						ASSERT(NT_SUCCESS(ntStatus));
					}

					if (sendSts)
					{
						// We have reset the retry timer above
						atalkAtpTransmitReq(pAtpReq);
					}

					//	If the bitmap is non-zero, we are still awaiting more responses.
					if (pAtpReq->req_Bitmap != 0)
					{
						break;
					}
				}
				else
				{
					ASSERT (pAtpReq->req_Bitmap == 0);
				}

				//	Ok, we have the entire response !
				//	If an XO request send a release, synch up the user buffer,
				//	Deref the request to have it complete.

				RELEASE_SPIN_LOCK_DPC(&pAtpAddr->atpao_Lock);
				UnlockAddr = FALSE;

				if (pAtpReq->req_Flags & ATP_REQ_EXACTLY_ONCE)
				{
					atalkAtpTransmitRel(pAtpReq);
				}

				//	Do the synch up! USE RECD_BITMAP!!

				//	Set the response length, the user bytes in the request buffer.

				//	See if we can grab ownership of this request to remove
				//	the creation reference and complete it.
				DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_INFO,
						("AtalkAtpPacketIn: Completing req %lx tid %x\n",
						pAtpReq, pAtpReq->req_Tid));

				atalkAtpReqComplete(pAtpReq, error);
			} while (FALSE);

			//	Remove reference on the request added at the beginning.
			AtalkAtpReqDereferenceDpc(pAtpReq);
			break;

		  case ATP_RELEASE:
			DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_INFO,
					("AtalkAtpPacketIn: Received release for tid %lx!\n", tid));

			atalkAtpRespReferenceByAddrTidDpc(pAtpAddr,
											  pSrcAddr,
											  tid,
											  &pAtpResp,
											  &error);
			if (ATALK_SUCCESS(error))
			{
				DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_INFO,
						("AtalkAtpPacketIn: Found resp for release for tid %lx!\n",
						pAtpResp->resp_Tid));

				//	We received a release for this response. Cleanup and
				//	complete.
				ACQUIRE_SPIN_LOCK_DPC(&pAtpResp->resp_Lock);

				pAtpResp->resp_Flags |= ATP_RESP_RELEASE_RECD;
				if (pAtpResp->resp_Flags & ATP_RESP_REL_TIMER)
				{
					ASSERT (pAtpResp->resp_Flags & ATP_RESP_EXACTLY_ONCE);
				}

				RELEASE_SPIN_LOCK_DPC(&pAtpResp->resp_Lock);
			}
			else
			{
				DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_ERR,
						("AtalkAtpPacketIn: resp not found - release for tid %lx!\n", tid));
			}

			RELEASE_SPIN_LOCK_DPC(&pAtpAddr->atpao_Lock);
			UnlockAddr = FALSE;

			INTERLOCKED_INCREMENT_LONG_DPC(&AtalkStatistics.stat_AtpNumRecdRelease,
										   &AtalkStatsLock.SpinLock);

			if (ATALK_SUCCESS(error))
			{
                ATALK_ERROR     ErrorCode = ATALK_NO_ERROR;

                // if client (mac) cancelled the request (possibly because session
                // went away), make sure our completion routine gets called
                if ((pAtpResp->resp_Flags & ATP_RESP_VALID_RESP) == 0)
                {
                    ErrorCode = ATALK_ATP_RESP_CANCELLED;
                    pAtpResp->resp_Flags |= ATP_RESP_VALID_RESP;
                }

				//	Try to have the creation reference removed
				atalkAtpRespComplete(pAtpResp, ErrorCode);

				//	Remove the reference we added at the beginning.
				AtalkAtpRespDereferenceDpc(pAtpResp);
			}
			break;

		  default:
			break;
		}
		if (UnlockAddr)
		{
			RELEASE_SPIN_LOCK_DPC(&pAtpAddr->atpao_Lock);
		}
	} while (FALSE);

	//	Deref addr added at the beginning of this routine.
	if (DerefAddr)
	{
		AtalkAtpAddrDereferenceDpc(pAtpAddr);
	}

	TimeE = KeQueryPerformanceCounter(NULL);
	TimeD.QuadPart = TimeE.QuadPart - TimeS.QuadPart;

	INTERLOCKED_ADD_LARGE_INTGR_DPC(&AtalkStatistics.stat_AtpPacketInProcessTime,
									TimeD,
									&AtalkStatsLock.SpinLock);

	INTERLOCKED_INCREMENT_LONG_DPC(&AtalkStatistics.stat_AtpNumPackets,
								   &AtalkStatsLock.SpinLock);
}




VOID FASTCALL
atalkAtpTransmitReq(
	IN		PATP_REQ	pAtpReq
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	ATALK_ERROR		error;
	ATP_HEADER		atpHeader;
	BOOLEAN			remote;
	BOOLEAN			DerefReq = FALSE;
	PBUFFER_DESC	pBufDesc = NULL;
	SEND_COMPL_INFO	SendInfo;

	//	Reference the request. This goes away in request send completion.
	AtalkAtpReqReferenceByPtr(pAtpReq, &error);
	if (ATALK_SUCCESS(error))
	{
		DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_INFO,
				("atalkAtpTransmitReq: Transmitting req %lx tid %x\n",
					pAtpReq, pAtpReq->req_Tid));

		//	Build the atp header.
		atpHeader.atph_CmdCtrl = ATP_REQUEST | (UCHAR)(ATP_REL_TIMER_MASK & pAtpReq->req_RelTimerValue);
		if (pAtpReq->req_Flags & ATP_REQ_EXACTLY_ONCE)
			atpHeader.atph_CmdCtrl |= ATP_XO_MASK;

		//	Put in the expected packets bitmap.
		atpHeader.atph_Bitmap = pAtpReq->req_Bitmap;

		//	Put in the tid.
		PUTSHORT2SHORT(&atpHeader.atph_Tid, pAtpReq->req_Tid);

		//	Copy the user bytes.
		atpHeader.atph_dwUserBytes = pAtpReq->req_dwUserBytes;

		//	Build a buffer descriptor, this should hold the above mdl.
		if (pAtpReq->req_BufLen > 0)
		{
			if ((pBufDesc = AtalkAllocBuffDesc(pAtpReq->req_Buf,
											   pAtpReq->req_BufLen,
											   0)) == NULL)
			{
				DerefReq 	= TRUE;
				error 		= ATALK_RESR_MEM;
			}
		}

		remote = (pAtpReq->req_Flags & ATP_REQ_REMOTE) ? TRUE : FALSE;
		//	Call ddp to send the packet. Dont touch request after this call,
		//	as the send completion could potentially lead to it being freed.
		SendInfo.sc_TransmitCompletion = atalkAtpSendReqComplete;
		SendInfo.sc_Ctx1 = pAtpReq;
		SendInfo.sc_Ctx2 = pBufDesc;
		// SendInfo.sc_Ctx3 = NULL;
		if (ATALK_SUCCESS(error) &&
			!ATALK_SUCCESS(error = AtalkDdpSend(pAtpReq->req_pAtpAddr->atpao_DdpAddr,
												&pAtpReq->req_Dest,
												(BYTE)DDPPROTO_ATP,
												remote,
												pBufDesc,
												(PBYTE)&atpHeader,
												ATP_HEADER_SIZE,
												NULL,
												&SendInfo)))
		{
			DerefReq = TRUE;
			if (pBufDesc != NULL)
			{
				//	The flags will indicate that the data buffer is not to be
				//	freed.
				AtalkFreeBuffDesc(pBufDesc);
			}
		}

		if (DerefReq)
		{
			pAtpReq->req_CompStatus = error;
			AtalkAtpReqDereference(pAtpReq);
		}
	}
}




VOID FASTCALL
atalkAtpSendReqComplete(
	IN	NDIS_STATUS			Status,
	IN	PSEND_COMPL_INFO	pSendInfo
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	if (pSendInfo->sc_Ctx2 != NULL)
	{
		AtalkFreeBuffDesc((PBUFFER_DESC)(pSendInfo->sc_Ctx2));
	}

	AtalkAtpReqDereference((PATP_REQ)(pSendInfo->sc_Ctx1));
}




VOID FASTCALL
atalkAtpTransmitResp(
	IN		PATP_RESP		pAtpResp
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	ATALK_ERROR		error;
	KIRQL			OldIrql;
	BYTE			i, bitmap, currentBit, seqNum, pktstosend;
	BOOLEAN			RemoteAddr;
	USHORT			bytesSent, bytesToSend, maxSinglePktSize;
	SHORT			remainingBytes;
	PATP_ADDROBJ	pAtpAddr;
	PAMDL			pAmdl[ATP_MAX_RESP_PKTS];
	PBUFFER_DESC	pBufDesc[ATP_MAX_RESP_PKTS];
	ATP_HEADER		atpHeader;
	SEND_COMPL_INFO	SendInfo;

	//	Verify we have a response posted
	ASSERT(pAtpResp->resp_Flags & ATP_RESP_VALID_RESP);

	pAtpAddr = pAtpResp->resp_pAtpAddr;
	ASSERT(VALID_ATPAO(pAtpAddr));

	RemoteAddr = ((pAtpResp->resp_Flags & ATP_RESP_REMOTE) == 0) ? FALSE : TRUE;

	//	send each response packet that is needed.
	seqNum			= 0;
	pktstosend		= 0;
	currentBit		= 1;

	//	Get the max packet size for this atp object
	maxSinglePktSize	= pAtpAddr->atpao_MaxSinglePktSize;

	bitmap			= pAtpResp->resp_Bitmap;
	remainingBytes 	= pAtpResp->resp_BufLen;
	bytesSent		= 0;

	//	Indicate response type.
	atpHeader.atph_CmdCtrl = ATP_RESPONSE;

	//	Put in the tid.
	PUTSHORT2SHORT(&atpHeader.atph_Tid, pAtpResp->resp_Tid);

	ASSERTMSG("atalkAtpTransmitResp: resp len is negative\n", (remainingBytes >= 0));

	KeRaiseIrql(DISPATCH_LEVEL, &OldIrql);

	do
	{
		ACQUIRE_SPIN_LOCK_DPC(&pAtpResp->resp_Lock);
		pAtpResp->resp_Flags |= ATP_RESP_TRANSMITTING;
		RELEASE_SPIN_LOCK_DPC(&pAtpResp->resp_Lock);

		do
		{
			pAmdl[seqNum] = NULL;
			pBufDesc[seqNum]  = NULL;

			if (((bitmap & currentBit) != 0) ||
				((seqNum == 0) && pAtpResp->resp_UserBytesOnly))
			{
				ASSERT(pAtpResp->resp_Flags & ATP_RESP_VALID_RESP);

				bytesToSend = MIN(remainingBytes, maxSinglePktSize);

				if (bytesToSend != 0)
				{
					ASSERT (pAtpResp->resp_Buf != NULL);
					//	Make an mdl for the proper subsection of the response mdl.
					//	Make a buffer descriptor for the mdl.
					if (((pAmdl[seqNum] = AtalkSubsetAmdl(pAtpResp->resp_Buf,
														  bytesSent,
														  bytesToSend)) == NULL) ||
						((pBufDesc[seqNum] = AtalkAllocBuffDesc(pAmdl[seqNum],
																bytesToSend,
																0)) == NULL))
					{
						ASSERTMSG("atalkAtpTransmitResp: Create mdl or BD failed\n", 0);
						if (pAmdl[seqNum] != NULL)
						{
							AtalkFreeAMdl(pAmdl[seqNum]);
							pAmdl[seqNum] = NULL;
						}
						if (seqNum > 0)
							seqNum --;		// Adjust this.

						break;
					}
				}

				pktstosend ++;

			}
			else
			{
				//	We are omitting this. Let us mark it appropriately
				pBufDesc[seqNum]  = (PBUFFER_DESC)-1;
			}

			seqNum 			++;
			currentBit 		<<= 1;
			remainingBytes 	-= maxSinglePktSize;
			bytesSent 		+= maxSinglePktSize;
		} while (remainingBytes > 0);

		ASSERT (seqNum <= ATP_MAX_RESP_PKTS);

		//	Attempt to reference the response structure. If we fail, we abort.
		//	This will go away in the completion routine.
		atalkAtpRespReferenceNDpc(pAtpResp, pktstosend, &error);
		if (!ATALK_SUCCESS(error))
		{
			DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_ERR,
					("atalkAtpTransmitResp: response %lx ref (%d) failed\n",
					pAtpResp, seqNum, error));

			// Need to free up the Mdls/Buffdescs
			for (i = 0; i < seqNum; i++)
			{
				if (pAmdl[i] != NULL)
					AtalkFreeAMdl(pAmdl[i]);

				if ((pBufDesc[i] != NULL) && (pBufDesc[i] != (PBUFFER_DESC)-1))
					AtalkFreeBuffDesc(pBufDesc[i]);
			}
			break;
		}

		// Now blast off all the packets
		SendInfo.sc_TransmitCompletion = atalkAtpSendRespComplete;
		SendInfo.sc_Ctx1 = pAtpResp;
		// SendInfo.sc_Ctx3 = pAmdl[i];
		for (i = 0; i < seqNum; i++)
		{
			if (pBufDesc[i] == (PBUFFER_DESC)-1)
				continue;

			DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_INFO,
					("atalkAtpTransmitResp: Sending seq #%d for tid %lx\n",
					i, pAtpResp->resp_Tid));

			//	Indicate if this is the last packet of the response.
			if (i == (seqNum-1))
			{
				atpHeader.atph_CmdCtrl |= ATP_EOM_MASK;
			}

			//	Put in the sequence number
			atpHeader.atph_SeqNum = i;

			//	User bytes only go in the first packet of the response
			//	unless otherwise indicated for this atp object.
			if ((i == 0)	||
				(pAtpAddr->atpao_Flags & ATPAO_SENDUSERBYTESALL))
			{
				atpHeader.atph_dwUserBytes = pAtpResp->resp_dwUserBytes;
			}
			else
			{
				//	Zero the user bytes
				atpHeader.atph_dwUserBytes = 0;
			}

			ASSERT(pAtpResp->resp_Flags & ATP_RESP_VALID_RESP);

			DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_INFO,
					("atalkAtpTransmitResp: Sending seq #%d, BufDesc %lx, Resp %lx\n",
					i, pBufDesc[i], pAtpResp));

			ASSERT ((pBufDesc[i] == NULL) ||
					VALID_BUFFDESC(pBufDesc[i]));
			SendInfo.sc_Ctx2 = pBufDesc[i];
			error = AtalkDdpSend(pAtpAddr->atpao_DdpAddr,
								 &pAtpResp->resp_Dest,
								 (BYTE)DDPPROTO_ATP,
								 RemoteAddr,
								 pBufDesc[i],
								 (PBYTE)&atpHeader,
								 ATP_HEADER_SIZE,
								 NULL,
								 &SendInfo);

			if (!ATALK_SUCCESS(error))
			{
				DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_ERR,
						("atalkAtpTransmitResp: AtalkDdpSend Failed %ld\n", error));
				//	Call completion so the buffer/mdl can get freed up,
				//	and the reference is removed.
				atalkAtpSendRespComplete(error,
										 &SendInfo);
			}
		}
	} while (FALSE);

	ACQUIRE_SPIN_LOCK_DPC(&pAtpResp->resp_Lock);
	pAtpResp->resp_Flags |= ATP_RESP_SENT;
	pAtpResp->resp_Flags &= ~ATP_RESP_TRANSMITTING;
	RELEASE_SPIN_LOCK_DPC(&pAtpResp->resp_Lock);

	if (OldIrql != DISPATCH_LEVEL)
		KeLowerIrql(OldIrql);
}




VOID FASTCALL
atalkAtpSendRespComplete(
	IN	NDIS_STATUS			Status,
	IN	PSEND_COMPL_INFO	pSendInfo
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	if (pSendInfo->sc_Ctx2 != NULL)
	{
		PAMDL	pMdl;

		if ((pMdl = ((PBUFFER_DESC)(pSendInfo->sc_Ctx2))->bd_OpaqueBuffer) != NULL)
			AtalkFreeAMdl(pMdl);
		AtalkFreeBuffDesc((PBUFFER_DESC)(pSendInfo->sc_Ctx2));

	}

	AtalkAtpRespDereference((PATP_RESP)(pSendInfo->sc_Ctx1));
}



//	This is used to perform a retry when a release send fails in completion.
#define		ATP_TID_RETRY_MASK	0xF0000000
#define		ATP_TID_MASK		0xFFFF

VOID FASTCALL
atalkAtpTransmitRel(
	IN		PATP_REQ	pAtpReq
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	ATALK_ERROR		error;
	ATP_HEADER		atpHeader;
	BOOLEAN			remote;
	SEND_COMPL_INFO	SendInfo;

	AtalkAtpAddrReferenceDpc(pAtpReq->req_pAtpAddr, &error);

	if (ATALK_SUCCESS(error))
	{
		DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_INFO,
				("atalkAtpTransmitRel: Sending release for %lx\n", pAtpReq->req_Tid));

		//	Build header for this packet.
		atpHeader.atph_dwUserBytes = 0;

		//	Indicate response type.
		atpHeader.atph_CmdCtrl = ATP_RELEASE;

		//	Put in the bitmap
		atpHeader.atph_Bitmap = pAtpReq->req_RecdBitmap;

		//	Put in the tid.
		PUTSHORT2SHORT(&atpHeader.atph_Tid, pAtpReq->req_Tid);

		remote = (pAtpReq->req_Flags & ATP_REQ_REMOTE) ? TRUE : FALSE;
		SendInfo.sc_TransmitCompletion = atalkAtpSendRelComplete;
		SendInfo.sc_Ctx1 = pAtpReq->req_pAtpAddr;
		SendInfo.sc_Ctx2 = (PVOID)((ULONG_PTR)(ATP_TID_RETRY_MASK | pAtpReq->req_Tid));
		SendInfo.sc_Ctx3 = (PVOID)((ULONG_PTR)(pAtpReq->req_Dest.ata_Address));
		error = AtalkDdpSend(pAtpReq->req_pAtpAddr->atpao_DdpAddr,
							 &pAtpReq->req_Dest,
							 (BYTE)DDPPROTO_ATP,
							 remote,
							 NULL,
							 (PBYTE)&atpHeader,
							 ATP_HEADER_SIZE,
							 NULL,
							 &SendInfo);

		if (!ATALK_SUCCESS(error))
		{
			DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_INFO,
					("atalkAtpTransmitRel: Send release failed %lx\n", error));

			AtalkAtpAddrDereferenceDpc(pAtpReq->req_pAtpAddr);
		}
	}
}




VOID FASTCALL
atalkAtpSendRelComplete(
	IN	NDIS_STATUS			Status,
	IN	PSEND_COMPL_INFO	pSendInfo
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	ATALK_ERROR		error;
	ATP_HEADER		atpHeader;
#define	pAtpAddr	((PATP_ADDROBJ)(pSendInfo->sc_Ctx1))
#define	TidAndRetry	(ULONG_PTR)(pSendInfo->sc_Ctx2)
#define	DestAddr	(ULONG_PTR)(pSendInfo->sc_Ctx3)

	DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_INFO,
			("atalkAtpSendRelComplete: Send status %lx\n", Status));

	if ((Status == NDIS_STATUS_SUCCESS) ||
		((TidAndRetry & ATP_TID_RETRY_MASK) == 0))
	{
		//	Either successful, or we have already retried.
		AtalkAtpAddrDereference(pAtpAddr);
		return;
	}

	//	Go ahead and retry!
	//	Build header for this packet.
	atpHeader.atph_dwUserBytes = 0;

	//	Indicate response type.
	atpHeader.atph_CmdCtrl = ATP_RELEASE;

	//	Put in the tid.
	PUTSHORT2SHORT(&atpHeader.atph_Tid, (TidAndRetry & ATP_TID_MASK));

	pSendInfo->sc_Ctx2 = NULL;
	pSendInfo->sc_Ctx3 = NULL;
	error = AtalkDdpSend(pAtpAddr->atpao_DdpAddr,
						(PATALK_ADDR)&DestAddr,
						(BYTE)DDPPROTO_ATP,
						FALSE,
						NULL,
						(PBYTE)&atpHeader,
						ATP_HEADER_SIZE,
						NULL,
						pSendInfo);

	if (!ATALK_SUCCESS(error))
	{
		DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_INFO,
				("atalkAtpSendRelComplete: Send release failed %lx\n", error));

		AtalkAtpAddrDereference(pAtpAddr);
	}
#undef	pAtpAddr
#undef	TidAndRetry
#undef	DestAddr
}




VOID  FASTCALL
atalkAtpRespComplete(
	IN	OUT	PATP_RESP	pAtpResp,
	IN		ATALK_ERROR	CompletionStatus
	)
{
	KIRQL	OldIrql;
	BOOLEAN	ownResp = TRUE;

	DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_INFO,
			("atalkAtpRespComplete: Completing %lx.%lx\n",
				pAtpResp->resp_Tid, CompletionStatus));

	//	See if we can grab ownership of this response to remove
	//	the creation reference and complete it.
	ACQUIRE_SPIN_LOCK(&pAtpResp->resp_Lock, &OldIrql);
	if (pAtpResp->resp_Flags & ATP_RESP_CLOSING)
	{
		ownResp = FALSE;
	}
	pAtpResp->resp_Flags |= ATP_RESP_CLOSING;
	pAtpResp->resp_CompStatus = CompletionStatus;
	RELEASE_SPIN_LOCK(&pAtpResp->resp_Lock, OldIrql);

	//	If we managed to get ownership of the request, call the
	//	Deref for creation.
	if (ownResp)
	{
		AtalkAtpRespDereference(pAtpResp);
	}
}




VOID FASTCALL
atalkAtpReqComplete(
	IN	OUT	PATP_REQ	pAtpReq,
	IN		ATALK_ERROR	CompletionStatus
	)
{
	KIRQL	OldIrql;
	BOOLEAN	ownReq = TRUE;

	DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_INFO,
			("atalkAtpReqComplete: Completing %lx\n", pAtpReq->req_Tid));

	//	See if we can grab ownership of this resquest to remove
	//	the creation reference and complete it.
	ACQUIRE_SPIN_LOCK(&pAtpReq->req_Lock, &OldIrql);
	if (pAtpReq->req_Flags & ATP_REQ_CLOSING)
	{
		ownReq = FALSE;
	}
	pAtpReq->req_CompStatus = CompletionStatus;
	pAtpReq->req_Flags |= ATP_REQ_CLOSING;
	RELEASE_SPIN_LOCK(&pAtpReq->req_Lock, OldIrql);

	//	If we managed to get ownership of the request, call the deref for creation.
	if (ownReq)
	{
		AtalkAtpReqDereference(pAtpReq);
	}
}




VOID
atalkAtpGetNextTidForAddr(
	IN		PATP_ADDROBJ	pAtpAddr,
	IN		PATALK_ADDR		pRemoteAddr,
	OUT		PUSHORT			pTid,
	OUT		PULONG			pIndex
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	USHORT		TentativeTid;
	ULONG		index;
	PATP_REQ	pAtpReq;

	do
	{
		TentativeTid = pAtpAddr->atpao_NextTid++;
		if (pAtpAddr->atpao_NextTid == 0)
			pAtpAddr->atpao_NextTid = 1;

		//	Check to see if this tid is in use for this address.

		//	!!!NOTE!!!
		//	This will be true even if the tid is in use for a closing
		//	request or a response.

		//	Calculate the hash value of the destination address of this request
		//	and the tid.
		index = ATP_HASH_TID_DESTADDR(TentativeTid, pRemoteAddr, ATP_REQ_HASH_SIZE);

		for (pAtpReq = pAtpAddr->atpao_ReqHash[index];
			 pAtpReq != NULL;
			 pAtpReq = pAtpReq->req_Next)
		{
			if ((ATALK_ADDRS_EQUAL(&pAtpReq->req_Dest, pRemoteAddr)) &&
				(pAtpReq->req_Tid == TentativeTid))
			{
				break;
			}
		}
	} while (pAtpReq != NULL);

	DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_INFO,
			("atalkAtpGetNextTidForAddr: Tid %lx for %lx.%lx.%lx\n",
				TentativeTid, pRemoteAddr->ata_Network, pRemoteAddr->ata_Node,
				pRemoteAddr->ata_Socket));

	*pTid = TentativeTid;
	*pIndex = index;
}


VOID
atalkAtpReqRefNextNc(
	IN		PATP_REQ		pAtpReq,
	OUT		PATP_REQ	*	ppNextNcReq,
	OUT		PATALK_ERROR	pError
	)
/*++

Routine Description:

	MUST BE CALLED WITH THE ADDRESS LOCK HELD!

Arguments:


Return Value:


--*/
{
	for (NOTHING; pAtpReq != NULL; pAtpReq = pAtpReq->req_Next)
	{
		AtalkAtpReqReferenceByPtrDpc(pAtpReq, pError);
		if (ATALK_SUCCESS(*pError))
		{
			//	Ok, this request is referenced!
			*ppNextNcReq = pAtpReq;
			break;
		}
	}
}




VOID FASTCALL
atalkAtpReqDeref(
	IN		PATP_REQ	pAtpReq,
	IN		BOOLEAN		AtDpc
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	KIRQL		OldIrql;
	BOOLEAN		done = FALSE;

	//	This will call the completion routine and remove it from the
	//	list when ref count goes to 0.
	ASSERT(VALID_ATPRQ(pAtpReq));

	if (AtDpc)
	{
		ACQUIRE_SPIN_LOCK_DPC(&pAtpReq->req_Lock);
	}
	else
	{
		ACQUIRE_SPIN_LOCK(&pAtpReq->req_Lock, &OldIrql);
	}

	if ((--pAtpReq->req_RefCount) == 0)
	{
		ASSERT(pAtpReq->req_Flags & ATP_REQ_CLOSING);
		done = TRUE;
	}

	if (AtDpc)
	{
		RELEASE_SPIN_LOCK_DPC(&pAtpReq->req_Lock);
	}
	else
	{
		RELEASE_SPIN_LOCK(&pAtpReq->req_Lock, OldIrql);
	}

	if (done)
	{
		if (AtDpc)
		{
			ACQUIRE_SPIN_LOCK_DPC(&pAtpReq->req_pAtpAddr->atpao_Lock);
		}
		else
		{
			ACQUIRE_SPIN_LOCK(&pAtpReq->req_pAtpAddr->atpao_Lock, &OldIrql);
		}

		//	Remove it from the list.
		AtalkUnlinkDouble(pAtpReq, req_Next, req_Prev);

		if (pAtpReq->req_Flags & ATP_REQ_RETRY_TIMER)
		{
			pAtpReq->req_Flags &= ~ATP_REQ_RETRY_TIMER;
			RemoveEntryList(&pAtpReq->req_List);
		}

		if (AtDpc)
		{
			RELEASE_SPIN_LOCK_DPC(&pAtpReq->req_pAtpAddr->atpao_Lock);
		}
		else
		{
			RELEASE_SPIN_LOCK(&pAtpReq->req_pAtpAddr->atpao_Lock, OldIrql);
		}

		DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_INFO,
				("atalkAtpReqDeref: Completing req for tid %lx.%d\n",
				pAtpReq->req_Tid, pAtpReq->req_Tid));

		//	Call the completion routine for the request.
		if (pAtpReq->req_Comp != NULL)
		{
			KIRQL	OldIrql;

			// Resp handlers expect to be called at DISPATCH. If the
			// request was cancelled, make it so.
			if (pAtpReq->req_CompStatus == ATALK_ATP_REQ_CANCELLED)
				KeRaiseIrql(DISPATCH_LEVEL, &OldIrql);

			(*pAtpReq->req_Comp)(pAtpReq->req_CompStatus,
								 pAtpReq->req_Ctx,
								 pAtpReq->req_Buf,
								 pAtpReq->req_RespBuf,
								 pAtpReq->req_RespRecdLen,
								 pAtpReq->req_RespUserBytes);

			if (pAtpReq->req_CompStatus == ATALK_ATP_REQ_CANCELLED)
				KeLowerIrql(OldIrql);
		}

		//	Deref the address object
		if (AtDpc)
		{
			AtalkAtpAddrDereferenceDpc(pAtpReq->req_pAtpAddr);
		}
		else
		{
			AtalkAtpAddrDereference(pAtpReq->req_pAtpAddr);
		}

		//	Release the ndis buffer descriptors, if any
		AtalkIndAtpReleaseNdisBuffer(pAtpReq);

		AtalkBPFreeBlock(pAtpReq);
	}
}




VOID
atalkAtpRespRefNextNc(
	IN		PATP_RESP		pAtpResp,
	OUT		PATP_RESP	 *  ppNextNcResp,
	OUT		PATALK_ERROR	pError
	)
/*++

Routine Description:

	MUST BE CALLED WITH THE ADDRESS LOCK HELD!

Arguments:


Return Value:


--*/
{
	PATP_RESP	pNextResp	= NULL;
	ATALK_ERROR	error 		= ATALK_FAILURE;

	for (; pAtpResp != NULL; pAtpResp = pAtpResp->resp_Next)
	{
		AtalkAtpRespReferenceByPtrDpc(pAtpResp, pError);
		if (ATALK_SUCCESS(*pError))
		{
			//	Ok, this request is referenced!
			*ppNextNcResp = pAtpResp;
			break;
		}
	}
}




VOID FASTCALL
AtalkAtpRespDeref(
	IN		PATP_RESP	pAtpResp,
	IN		BOOLEAN		AtDpc
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PATP_ADDROBJ	pAtpAddr;
	KIRQL			OldIrql;
	BOOLEAN			done = FALSE;
	BOOLEAN			NotifyRelHandler = FALSE;

	//	This will call the completion routine when the ref count goes to 1
	//	and remove it from the list when ref count goes to 0. The assumption
	//	here is that the release handler will be the last to Dereference.

	if (AtDpc)
	{
		ACQUIRE_SPIN_LOCK_DPC(&pAtpResp->resp_Lock);
	}
	else
	{
		ACQUIRE_SPIN_LOCK(&pAtpResp->resp_Lock, &OldIrql);
	}

	pAtpResp->resp_RefCount--;
	if (pAtpResp->resp_RefCount == 0)
	{
		ASSERT(pAtpResp->resp_Flags & (ATP_RESP_HANDLER_NOTIFIED | ATP_RESP_CANCELLED));

		done = TRUE;
	}
	else if ((pAtpResp->resp_RefCount == 1) &&
			 (pAtpResp->resp_Flags & ATP_RESP_VALID_RESP) &&
			 ((pAtpResp->resp_Flags & ATP_RESP_HANDLER_NOTIFIED) == 0))
	{
		NotifyRelHandler = TRUE;

		DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_INFO,
				("AtalkAtpRespDereference: Notifying release handler for Resp %lx, tid %x %s\n",
				pAtpResp, pAtpResp->resp_Tid,
				(pAtpResp->resp_Flags & ATP_RESP_EXACTLY_ONCE) ? "XO" : "ALO"));
		pAtpResp->resp_Flags |= ATP_RESP_HANDLER_NOTIFIED;
	}

	if (AtDpc)
	{
		RELEASE_SPIN_LOCK_DPC(&pAtpResp->resp_Lock);
	}
	else
	{
		RELEASE_SPIN_LOCK(&pAtpResp->resp_Lock, OldIrql);
	}

	if (NotifyRelHandler)
	{
		ASSERT (!done);

		//	Call the completion routine.
		DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_INFO,
				("AtalkAtpRespDereference: Calling resp handler for tid %lx %s\n",
				pAtpResp->resp_Tid,
				(pAtpResp->resp_Flags & ATP_RESP_EXACTLY_ONCE) ? "XO" : "ALO"));

        //
        // if Mac cancels its request before a response is posted by the client,
        // the compl. routine won't be set yet.
        //
        if (pAtpResp->resp_Comp != NULL)
        {
		    (*pAtpResp->resp_Comp)(pAtpResp->resp_CompStatus, pAtpResp->resp_Ctx);
        }
	}

	else if (done)
	{
		DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_INFO,
				("AtalkAtpRespDereference: Freeing resp for tid %lx - %lx %s\n",
				pAtpResp->resp_Tid, pAtpResp->resp_CompStatus,
				(pAtpResp->resp_Flags & ATP_RESP_EXACTLY_ONCE) ? "XO" : "ALO"));

		pAtpAddr = pAtpResp->resp_pAtpAddr;
		if (AtDpc)
		{
			ACQUIRE_SPIN_LOCK_DPC(&pAtpAddr->atpao_Lock);
		}
		else
		{
			ACQUIRE_SPIN_LOCK(&pAtpAddr->atpao_Lock, &OldIrql);
		}


		//	Remove it from the list.
		AtalkUnlinkDouble(pAtpResp, resp_Next, resp_Prev);

		if (pAtpResp->resp_Flags & ATP_RESP_REL_TIMER)
		{
			ASSERT (pAtpResp->resp_Flags & ATP_RESP_EXACTLY_ONCE);
			pAtpResp->resp_Flags &= ~ATP_RESP_REL_TIMER;
			RemoveEntryList(&pAtpResp->resp_List);
		}

		if (AtDpc)
		{
			RELEASE_SPIN_LOCK_DPC(&pAtpAddr->atpao_Lock);
		}
		else
		{
			RELEASE_SPIN_LOCK(&pAtpAddr->atpao_Lock, OldIrql);
		}

		//	Deref the address object
		if (AtDpc)
		{
			AtalkAtpAddrDereferenceDpc(pAtpResp->resp_pAtpAddr);
		}
		else
		{
			AtalkAtpAddrDereference(pAtpResp->resp_pAtpAddr);
		}
		AtalkBPFreeBlock(pAtpResp);
	}
}



VOID FASTCALL
AtalkAtpAddrDeref(
	IN OUT	PATP_ADDROBJ	pAtpAddr,
	IN		BOOLEAN			AtDpc
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	KIRQL	OldIrql;
	BOOLEAN	done = FALSE;

	if (AtDpc)
	{
		ACQUIRE_SPIN_LOCK_DPC(&pAtpAddr->atpao_Lock);
	}
	else
	{
		ACQUIRE_SPIN_LOCK(&pAtpAddr->atpao_Lock, &OldIrql);
	}

	ASSERT(pAtpAddr->atpao_RefCount > 0);
	if (--(pAtpAddr->atpao_RefCount) == 0)
	{
		done = TRUE;
		ASSERT(pAtpAddr->atpao_Flags & ATPAO_CLOSING);
	}

	if (AtDpc)
	{
		RELEASE_SPIN_LOCK_DPC(&pAtpAddr->atpao_Lock);
	}
	else
	{
		RELEASE_SPIN_LOCK(&pAtpAddr->atpao_Lock, OldIrql);
	}

	if (done)
	{
		//	Call the close completion routine.
		if (pAtpAddr->atpao_CloseComp != NULL)
		{
			(*pAtpAddr->atpao_CloseComp)(ATALK_NO_ERROR, pAtpAddr->atpao_CloseCtx);
		}

		// 	This address is done for. Close the ddp socket.
		AtalkDdpCloseAddress(pAtpAddr->atpao_DdpAddr, NULL, NULL);

		//	Free up the memory
		AtalkFreeMemory(pAtpAddr);

		AtalkUnlockAtpIfNecessary();
	}
}


VOID FASTCALL
AtalkIndAtpSetupNdisBuffer(
	IN	OUT	PATP_REQ		pAtpReq,
	IN		ULONG			MaxSinglePktSize
)
{
	NDIS_STATUS		ndisStatus;
	PNDIS_BUFFER	ndisBuffer;
	PNDIS_BUFFER	ndisFirstBuffer;
	PNDIS_BUFFER	ndisPrevBuffer;
    UINT            ndisBufLen;
	USHORT			seqNum		= 0;
	USHORT			startOffset = 0;
    USHORT          Offset;
    USHORT          BytesRemaining;
    USHORT          PartialBytesNeeded=0;
    USHORT          PacketRoom;
    PMDL            pCurrentMdl;
    BOOLEAN         fPartialMdl;
	SHORT			BufLen = (SHORT)pAtpReq->req_RespBufLen;


	RtlZeroMemory(pAtpReq->req_NdisBuf,
				  sizeof(PVOID) * ATP_MAX_RESP_PKTS);

    if (BufLen == 0)
    {
        return;
    }

    //
    // BytesRemaining: bytes remaining in the current Mdl
    // PacketRoom: bytes required to complete setting up the
    //             Atp request corresponding to seqNum
    // ndisBufLen: bytes that will describe the (partial) mdl,
    //             obtained via NdisCopyBuffer
    //

    pCurrentMdl = pAtpReq->req_RespBuf;

    ASSERT(pCurrentMdl != NULL);

    BytesRemaining = (USHORT)MmGetMdlByteCount(pCurrentMdl);
    Offset = 0;

    ndisFirstBuffer = NULL;

	while (BufLen > 0 && seqNum < ATP_MAX_RESP_PKTS)
	{
        PacketRoom = MIN(BufLen, (USHORT)MaxSinglePktSize);

        while (PacketRoom > 0)
        {
            // are all the bytes there or are we at an Mdl boundary?
            if (BytesRemaining >= PacketRoom)
            {
                ndisBufLen = (UINT)PacketRoom;
                fPartialMdl = FALSE;
            }

            // looks like we are at boundary: need to get a partial mdl
            else
            {
                ndisBufLen = (UINT)BytesRemaining;
                fPartialMdl = TRUE;
            }

            ASSERT(ndisBufLen > 0);

		    NdisCopyBuffer(&ndisStatus,
			    		   &ndisBuffer,
				    	   AtalkNdisBufferPoolHandle,
					       (PVOID)pCurrentMdl,
    					   Offset,
	    				   ndisBufLen);

    		if (ndisStatus != NDIS_STATUS_SUCCESS)
            {
                DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_ERR,
	                ("AtalkIndAtpSetupNdisBuffer: NdisCopyBuffer failed!\n"));
		    	break;
            }

            ASSERT(ndisBufLen == MmGetMdlByteCount(ndisBuffer));

            ATALK_DBG_INC_COUNT(AtalkDbgMdlsAlloced);

            // first buffer for this packet?
            if (!ndisFirstBuffer)
            {
                ndisFirstBuffer = ndisBuffer;
                ndisPrevBuffer = ndisBuffer;
            }

            // no, it's not the first.  Chain it in!
            else
            {
                ndisPrevBuffer->Next = ndisBuffer;
                ndisPrevBuffer = ndisBuffer;
            }

		    BufLen -= (SHORT)ndisBufLen;
            Offset += (USHORT)ndisBufLen;
            BytesRemaining -= (USHORT)ndisBufLen;
            PacketRoom -= (USHORT)ndisBufLen;

            // did we exhaust the current Mdl?  move to the next mdl then!
            if (fPartialMdl)
            {
                ASSERT(PacketRoom > 0);

                pCurrentMdl = pCurrentMdl->Next;
                ASSERT(pCurrentMdl != NULL);

                BytesRemaining = (USHORT)MmGetMdlByteCount(pCurrentMdl);
                Offset = 0;
            }
        }

        if (PacketRoom > 0)
        {
            DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_ERR,
	            ("AtalkIndAtpSetupNdisBuffer: couldn't get Mdl!\n"));

            // if an mdl was allocated (describing part of buffer), free it
            if (ndisFirstBuffer)
            {
                AtalkNdisFreeBuffer(ndisFirstBuffer);
            }
		   	break;
        }

        ASSERT(ndisFirstBuffer != NULL);

		pAtpReq->req_NdisBuf[seqNum++] = ndisFirstBuffer;
        ndisFirstBuffer = NULL;
	}
}

VOID FASTCALL
AtalkIndAtpReleaseNdisBuffer(
	IN	OUT	PATP_REQ		pAtpReq
)
{
	LONG	        i;
    PNDIS_BUFFER    ndisBuffer;
    PNDIS_BUFFER    ndisNextBuffer;

	for (i = 0; i < ATP_MAX_RESP_PKTS; i++)
	{
		if ((ndisBuffer = pAtpReq->req_NdisBuf[i]) != NULL)
        {
            AtalkNdisFreeBuffer(ndisBuffer);
        }
	}

}




LOCAL LONG FASTCALL
atalkAtpReqTimer(
	IN	PTIMERLIST			pTimer,
	IN	BOOLEAN				TimerShuttingDown
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PATP_REQ		pAtpReq;
	PATP_ADDROBJ	pAtpAddr;
	PLIST_ENTRY		pList, pListNext;
	ATALK_ERROR		error;
	LONG			now;
	BOOLEAN			retry;
#ifdef	PROFILING
	LARGE_INTEGER	TimeS, TimeE, TimeD;

	TimeS = KeQueryPerformanceCounter(NULL);
#endif

	pAtpAddr = CONTAINING_RECORD(pTimer, ATP_ADDROBJ, atpao_RetryTimer);
	ASSERT(VALID_ATPAO(pAtpAddr));

	DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_INFO,
			("atalkAtpReqTimer: Entered for address %lx\n", pAtpAddr));

	if (TimerShuttingDown ||
		(pAtpAddr->atpao_Flags & (ATPAO_CLOSING|ATPAO_CLEANUP)))
	{
		AtalkAtpAddrDereferenceDpc(pAtpAddr);
		return ATALK_TIMER_NO_REQUEUE;
	}

	now = AtalkGetCurrentTick();

	ACQUIRE_SPIN_LOCK_DPC(&pAtpAddr->atpao_Lock);

	for (pList = pAtpAddr->atpao_ReqList.Flink;
		 pList != &pAtpAddr->atpao_ReqList;
		 pList = pListNext)
	{
		pAtpReq = CONTAINING_RECORD(pList, ATP_REQ, req_List);
		ASSERT (VALID_ATPRQ(pAtpReq));

		ACQUIRE_SPIN_LOCK_DPC(&pAtpReq->req_Lock);

		pListNext = pAtpReq->req_List.Flink;

		//	If either we are closing this request or have not timed out yet, skip.
		if (((pAtpReq->req_Flags & (ATP_REQ_CLOSING		|
									ATP_REQ_RETRY_TIMER	|
									ATP_REQ_RESPONSE_COMPLETE)) != ATP_REQ_RETRY_TIMER) ||
			(now < pAtpReq->req_RetryTimeStamp))

		{
			RELEASE_SPIN_LOCK_DPC(&pAtpReq->req_Lock);
			continue;
		}

		//	If retry count == 0, we have reached the end of the road.
		if ((pAtpReq->req_RetryCnt == ATP_INFINITE_RETRIES) ||
			(--(pAtpReq->req_RetryCnt) > 0))
		{
			//	Transmit the request again!
			retry = TRUE;
			pAtpReq->req_RetryTimeStamp = (now + pAtpReq->req_RetryInterval);
		}
		else
		{
			//	We should now be Dereferenced for creation.
			retry = FALSE;
		}

		RELEASE_SPIN_LOCK_DPC(&pAtpReq->req_Lock);

		if (retry)
		{
			// We do not want to update statistics for requests are that are never going to
			// be responded to (like tickle packets). Detect these and skip updating the
			// stats for these
			if (pAtpReq->req_RespBufLen > 0)	// i.e. response expected
			{
				INTERLOCKED_INCREMENT_LONG_DPC(&AtalkStatistics.stat_AtpNumLocalRetries,
											   &AtalkStatsLock.SpinLock);
			}

			AtalkAtpReqReferenceByPtrDpc(pAtpReq, &error);

			RELEASE_SPIN_LOCK_DPC(&pAtpAddr->atpao_Lock);

			if (ATALK_SUCCESS(error))
			{
				atalkAtpTransmitReq(pAtpReq);
				AtalkAtpReqDereferenceDpc(pAtpReq);
			}
		}
		else
		{
			//	We have run out of retries - complete with an error
			ASSERT (pAtpReq->req_RetryCnt == 0);
			DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_ERR,
					("atalkAtpReqTimer: Request %lx, tid %x timed out !!!\n",
					pAtpReq, pAtpReq->req_Tid));

			AtalkAtpReqReferenceByPtrDpc(pAtpReq, &error);

			RELEASE_SPIN_LOCK_DPC(&pAtpAddr->atpao_Lock);

			if (ATALK_SUCCESS(error))
			{
				atalkAtpReqComplete(pAtpReq, ATALK_ATP_REQ_TIMEOUT);
				AtalkAtpReqDereferenceDpc(pAtpReq);
			}
            else
            {
	            DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_ERR,
			        ("atalkAtpReqTimer: couldn't reference pAtpReq %lx :nothing done!\n",pAtpReq));
            }
		}

		ACQUIRE_SPIN_LOCK_DPC(&pAtpAddr->atpao_Lock);

		// Start over
		pListNext = pAtpAddr->atpao_ReqList.Flink;
	}

	RELEASE_SPIN_LOCK_DPC(&pAtpAddr->atpao_Lock);

#ifdef	PROFILING
	TimeE = KeQueryPerformanceCounter(NULL);
	TimeD.QuadPart = TimeE.QuadPart - TimeS.QuadPart;

	INTERLOCKED_ADD_LARGE_INTGR_DPC(&AtalkStatistics.stat_AtpReqTimerProcessTime,
									TimeD,
									&AtalkStatsLock.SpinLock);

	INTERLOCKED_INCREMENT_LONG_DPC(&AtalkStatistics.stat_AtpNumReqTimer,
								   &AtalkStatsLock.SpinLock);
#endif

	return ATALK_TIMER_REQUEUE;
}




LOCAL LONG FASTCALL
atalkAtpRelTimer(
	IN	PTIMERLIST			pTimer,
	IN	BOOLEAN				TimerShuttingDown
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PATP_ADDROBJ	pAtpAddr;
	PATP_RESP		pAtpResp;
	PLIST_ENTRY		pList, pListNext;
	LONG			now;
#ifdef	PROFILING
	LARGE_INTEGER	TimeS, TimeE, TimeD;

	TimeS = KeQueryPerformanceCounter(NULL);
#endif

	pAtpAddr = CONTAINING_RECORD(pTimer, ATP_ADDROBJ, atpao_RelTimer);
	ASSERT(VALID_ATPAO(pAtpAddr));

	if (TimerShuttingDown ||
		(pAtpAddr->atpao_Flags & (ATPAO_CLOSING|ATPAO_CLEANUP)))
	{
		AtalkAtpAddrDereferenceDpc(pAtpAddr);
		return ATALK_TIMER_NO_REQUEUE;
	}

	now = AtalkGetCurrentTick();

	ACQUIRE_SPIN_LOCK_DPC(&pAtpAddr->atpao_Lock);

	for (pList = pAtpAddr->atpao_RespList.Flink;
		 pList != &pAtpAddr->atpao_RespList;
		 pList = pListNext)
	{
		BOOLEAN	derefResp;

		pAtpResp = CONTAINING_RECORD(pList, ATP_RESP, resp_List);

		ACQUIRE_SPIN_LOCK_DPC(&pAtpResp->resp_Lock);
		derefResp = TRUE;

		ASSERT (VALID_ATPRS(pAtpResp));
		ASSERT (pAtpResp->resp_Flags & (ATP_RESP_EXACTLY_ONCE|ATP_RESP_VALID_RESP|ATP_RESP_REL_TIMER));

		pListNext = pAtpResp->resp_List.Flink;

		if ((pAtpResp->resp_Flags &
				(ATP_RESP_CLOSING			|
				 ATP_RESP_REL_TIMER			|
				 ATP_RESP_TRANSMITTING		|
				 ATP_RESP_SENT				|
				 ATP_RESP_HANDLER_NOTIFIED	|
				 ATP_RESP_RELEASE_RECD)) == (ATP_RESP_REL_TIMER | ATP_RESP_SENT))
		{
			DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_INFO,
					("atalkAtpRelTimer: Checking req tid %lx (%x)\n",
					pAtpResp->resp_Tid, pAtpResp->resp_Flags));

			if (now >= pAtpResp->resp_RelTimeStamp)
			{
				DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_WARN,
						("atalkAtpRelTimer: Releasing req %lx tid %lx (%x)\n",
						pAtpResp, pAtpResp->resp_Tid, pAtpResp->resp_Flags));

				RELEASE_SPIN_LOCK_DPC(&pAtpResp->resp_Lock);

				RELEASE_SPIN_LOCK_DPC(&pAtpAddr->atpao_Lock);
				derefResp = FALSE;

				INTERLOCKED_INCREMENT_LONG_DPC(&AtalkStatistics.stat_AtpNumRespTimeout,
											   &AtalkStatsLock.SpinLock);

				//	Try to have the creation reference removed
				atalkAtpRespComplete(pAtpResp, ATALK_ATP_RESP_TIMEOUT);

				ACQUIRE_SPIN_LOCK_DPC(&pAtpAddr->atpao_Lock);

				// Start over
				pListNext = pAtpAddr->atpao_RespList.Flink;
			}
		}

		if (derefResp)
		{
			RELEASE_SPIN_LOCK_DPC(&pAtpResp->resp_Lock);
		}
	}

	RELEASE_SPIN_LOCK_DPC(&pAtpAddr->atpao_Lock);

#ifdef	PROFILING
	TimeE = KeQueryPerformanceCounter(NULL);
	TimeD.QuadPart = TimeE.QuadPart - TimeS.QuadPart;

	INTERLOCKED_ADD_LARGE_INTGR_DPC(&AtalkStatistics.stat_AtpRelTimerProcessTime,
									TimeD,
									&AtalkStatsLock.SpinLock);

	INTERLOCKED_INCREMENT_LONG_DPC(&AtalkStatistics.stat_AtpNumRelTimer,
								   &AtalkStatsLock.SpinLock);
#endif

	return ATALK_TIMER_REQUEUE;
}


VOID FASTCALL
AtalkAtpGenericRespComplete(
	IN	ATALK_ERROR				ErrorCode,
	IN	PATP_RESP				pAtpResp
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	AtalkAtpRespDereference(pAtpResp);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\atalk\sys\blkpool.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

	blkpool.h

Abstract:

	This module contains routines to manage block pools.

Author:

	Jameel Hyder (jameelh@microsoft.com)
	Nikhil Kamkolkar (nikhilk@microsoft.com)

Revision History:
	19 Jun 1992		Initial Version

Notes:	Tab stop: 4
--*/

#ifndef	_BLK_POOL
#define	_BLK_POOL

#define	SM_BLK	1024
#define	LG_BLK	2048
#define	XL_BLK	4096

#define	BC_SIGNATURE			*(PULONG)"BLKC"
#if	DBG
#define	VALID_BC(pChunk)	(((pChunk) != NULL) && \
							 ((pChunk)->bc_Signature == BC_SIGNATURE))
#else
#define	VALID_BC(pChunk)	((pChunk) != NULL)
#endif
typedef	struct _BLK_CHUNK
{
#if	DBG
	DWORD				bc_Signature;
#endif
	struct _BLK_CHUNK *	bc_Next;		// Pointer to next in the link
	struct _BLK_CHUNK **bc_Prev;		// Pointer to previous one
	UCHAR				bc_NumFree;		// Number of free blocks in the chunk
	UCHAR				bc_NumAlloc;	// Number of blocks used (DBG only)
	UCHAR				bc_Age;			// Number of invocations since the chunk free
	BLKID				bc_BlkId;		// Id of the block
	struct _BLK_HDR *	bc_FreeHead;	// Head of the list of free blocks
	// This is followed by an array of N blks of size M such that the block header
	// is exactly atalkChunkSize[i]
} BLK_CHUNK, *PBLK_CHUNK;

#define	BH_SIGNATURE			*(PULONG)"BLKH"
#if	DBG
#define	VALID_BH(pBlkHdr)	(((pBlkHdr) != NULL) && \
							 ((pBlkHdr)->bh_Signature == BH_SIGNATURE))
#else
#define	VALID_BH(pBlkHdr)	((pBlkHdr) != NULL)
#endif
typedef	struct _BLK_HDR
{
#if	DBG
	DWORD					bh_Signature;
#endif
	union
	{
		struct _BLK_HDR	*	bh_Next;	// Valid when it is free
		struct _BLK_CHUNK *	bh_pChunk;	// The parent chunk to which this blocks belong
										// valid when it is allocated
	};
} BLK_HDR, *PBLK_HDR;

#if	DBG
#define	BC_OVERHEAD				(8+4)	// DWORD for AtalkAllocMemory() header and
										// POOL_HEADER for ExAllocatePool() header
#else
#define	BC_OVERHEAD				(8+8)	// 2*DWORD for AtalkAllocMemory() header and
										// POOL_HEADER for ExAllocatePool() header
#endif

#define	BLOCK_SIZE(VirginSize)	DWORDSIZEBLOCK(sizeof(BLK_HDR)+VirginSize)

#define	NUM_BLOCKS(VirginSize, ChunkSize)	\
			((ChunkSize) - BC_OVERHEAD - sizeof(BLK_CHUNK))/BLOCK_SIZE(VirginSize)

extern	USHORT	atalkBlkSize[NUM_BLKIDS];

extern	USHORT	atalkChunkSize[NUM_BLKIDS];

extern	BYTE	atalkNumBlks[NUM_BLKIDS];

extern	ATALK_SPIN_LOCK	atalkBPLock[NUM_BLKIDS];

#define	BLOCK_POOL_TIMER			150	// Check interval - in 100ms units
#define	MAX_BLOCK_POOL_AGE			6	// # of timer invocations before free

extern	PBLK_CHUNK		atalkBPHead[NUM_BLKIDS];
extern	TIMERLIST		atalkBPTimer;

#if	DBG
extern	LONG	atalkNumChunksForId[NUM_BLKIDS];
extern	LONG	atalkBlksForId[NUM_BLKIDS];
#endif

LOCAL LONG FASTCALL
atalkBPAgePool(
	IN PTIMERLIST 	Context,
	IN BOOLEAN		TimerShuttingDown
);

#endif	// _BLK_POOL


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\atalk\sys\data.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

	data.c

Abstract:

	This module defines global data for the appletalk transport.

Author:

	Jameel Hyder (jameelh@microsoft.com)

Revision History:
	22 Feb 1997		Initial Version

Notes:	Tab stop: 4
--*/

#include 	<atalk.h>
#pragma hdrstop

//	File module number for errorlogging
#define	FILENUM		DATAX

PWCHAR			AtalkDeviceNames[] =
	{
		ATALKDDP_DEVICENAME,
		ATALKADSP_DEVICENAME,
		ATALKASPS_DEVICENAME,
		ATALKPAP_DEVICENAME,
        ATALKARAP_DEVICENAME,
		ATALKASPC_DEVICENAME
	};

PATALK_DEV_OBJ  AtalkDeviceObject[ATALK_NO_DEVICES] = {0};
DWORD			AtalkBindnUnloadStates = 0;

LONG			AtalkTimerCurrentTick = 0;
PTIMERLIST		atalkTimerList			= NULL;
ATALK_SPIN_LOCK	atalkTimerLock			= {0};
LARGE_INTEGER	atalkTimerTick			= {0};
KTIMER			atalkTimer				= {0};
KDPC			atalkTimerDpc			= {0};
KEVENT			atalkTimerStopEvent		= {0};
BOOLEAN			atalkTimerStopped 		= FALSE;	// Set to TRUE if timer system stopped
BOOLEAN			atalkTimerRunning		= FALSE;	// Set to TRUE when timer Dpc is running
BOOLEAN         atalkRtmpVdtTmrRunning  = FALSE;
BOOLEAN         atalkZipQryTmrRunning   = FALSE;

PRTE *			AtalkRoutingTable =	NULL;			// Allocated at init time
PRTE *			AtalkRecentRoutes		= NULL;		// Allocated at init time
ATALK_SPIN_LOCK	AtalkRteLock = {0};
TIMERLIST		atalkRtmpVTimer = { 0 };
TIMERLIST		atalkZipQTimer = { 0 };

ATALK_SKT_CACHE	AtalkSktCache		= {0};
ATALK_SPIN_LOCK	AtalkSktCacheLock	= {0};

PPORT_DESCRIPTOR AtalkPortList	= NULL;	 		// Head of the port list
PPORT_DESCRIPTOR AtalkDefaultPort = NULL;		// Ptr to the def port
KEVENT			 AtalkDefaultPortEvent = { 0 };	// Signalled when default port is available
UNICODE_STRING	 AtalkDefaultPortName = { 0 };	// Name of the default port
ATALK_SPIN_LOCK	 AtalkPortLock = { 0 };			// Lock for AtalkPortList
ATALK_NODEADDR	 AtalkUserNode1 = { 0 };		// Node address of user node
ATALK_NODEADDR	 AtalkUserNode2 = { 0 };		// Node address of user node
SHORT	 		 AtalkNumberOfPorts = 0; 		// Determine dynamically
SHORT			 AtalkNumberOfActivePorts = 0;	// Number of ports active
BOOLEAN			 AtalkRouter =	FALSE;			// Are we a router?
BOOLEAN			 AtalkFilterOurNames =	TRUE;	// If TRUE, Nbplookup fails on names on this machine
KEVENT			 AtalkUnloadEvent = {0};		// Event for unloading
NDIS_HANDLE		 AtalkNdisPacketPoolHandle = NULL;
NDIS_HANDLE		 AtalkNdisBufferPoolHandle = NULL;
LONG			 AtalkHandleCount = 0;
UNICODE_STRING	 AtalkRegPath = { 0 };

HANDLE           TdiRegistrationHandle = NULL;
PVOID            TdiAddressChangeRegHandle = NULL;

KMUTEX			AtalkPgLkMutex						= { 0 };
ATALK_SPIN_LOCK	AtalkPgLkLock						= { 0 };
LOCK_SECTION	AtalkPgLkSection[LOCKABLE_SECTIONS]	= { 0 };

ATALK_SPIN_LOCK	AtalkZoneLock = {0};
PZONE *			AtalkZonesTable = NULL;
PZONE			AtalkDesiredZone = NULL;

BOOLEAN         AtalkNoDefPortPrinted = FALSE;  // If no default ATalk port print the message only once

//	Values for the 0.5, 1, 2, 4, 8 minute timer in ATP_RELEASE_TIMER_INTERVAL units.
SHORT			AtalkAtpRelTimerTicks[MAX_VALID_TIMERS] =
	{
		300, 600, 2*600, 4*600, 8*600
	};

//	Bitmaps for the s=ence numbers in response packets.
BYTE			AtpBitmapForSeqNum[ATP_MAX_RESP_PKTS] =
	{
		0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80
	};

BYTE			AtpEomBitmapForSeqNum[ATP_MAX_RESP_PKTS] =
	{
		0x01, 0x03, 0x07, 0x0F, 0x1F, 0x3F, 0x7F, 0xFF
	};

ATALK_SPIN_LOCK	atalkAspLock = {0};

ASP_CONN_MAINT	atalkAspConnMaint[NUM_ASP_CONN_LISTS] = { 0 };
ASPC_CONN_MAINT	atalkAspCConnMaint = { 0 };
ATALK_SPIN_LOCK	atalkAspCLock = {0};
PASPC_ADDROBJ	atalkAspCAddrList = NULL;
PASPC_CONNOBJ	atalkAspCConnList = NULL;

PPAP_ADDROBJ	atalkPapAddrList	= NULL;
PPAP_CONNOBJ	atalkPapConnList	= NULL;
TIMERLIST		atalkPapCMTTimer	= { 0 };
ATALK_SPIN_LOCK	atalkPapLock		= {0};

NDIS_MEDIUM		AtalkSupportedMedia[] =
	{
		NdisMedium802_3,
		NdisMediumFddi,
		NdisMedium802_5,
		NdisMediumLocalTalk,
        NdisMediumWan
	};


ULONG			AtalkSupportedMediaSize = sizeof(AtalkSupportedMedia)/sizeof(NDIS_MEDIUM);

NDIS_HANDLE		AtalkNdisProtocolHandle	= NULL;

BYTE			AtalkElapBroadcastAddr[ELAP_ADDR_LEN] = ELAP_BROADCAST_ADDR_INIT;

BYTE			AtalkAlapBroadcastAddr[] = {0xFF};

BYTE			AtalkAarpProtocolType[IEEE8022_PROTO_TYPE_LEN] =
	{
		0x00, 0x00,	0x00, 0x80,	0xF3
	};

BYTE			AtalkAppletalkProtocolType[IEEE8022_PROTO_TYPE_LEN] =
	{
		0x08, 0x00, 0x07, 0x80, 0x9B
	};

ATALK_NETWORKRANGE	AtalkStartupNetworkRange =
	{
		FIRST_STARTUP_NETWORK, LAST_STARTUP_NETWORK
	};
																
BYTE			AtalkEthernetZoneMulticastAddrsHdr[ELAP_MCAST_HDR_LEN] =
	{
		0x09, 0x00, 0x07, 0x00, 0x00
	};

BYTE			AtalkEthernetZoneMulticastAddrs[ELAP_ZONE_MULTICAST_ADDRS]	=
	{
		 0x00 , 0x01 , 0x02 , 0x03 , 0x04 , 0x05 , 0x06 , 0x07 ,
		 0x08 , 0x09 , 0x0A , 0x0B , 0x0C , 0x0D , 0x0E , 0x0F ,
		 0x10 , 0x11 , 0x12 , 0x13 , 0x14 , 0x15 , 0x16 , 0x17 ,
		 0x18 , 0x19 , 0x1A , 0x1B , 0x1C , 0x1D , 0x1E , 0x1F ,
		 0x20 , 0x21 , 0x22 , 0x23 , 0x24 , 0x25 , 0x26 , 0x27 ,
		 0x28 , 0x29 , 0x2A , 0x2B , 0x2C , 0x2D , 0x2E , 0x2F ,
		 0x30 , 0x31 , 0x32 , 0x33 , 0x34 , 0x35 , 0x36 , 0x37 ,
		 0x38 , 0x39 , 0x3A , 0x3B , 0x3C , 0x3D , 0x3E , 0x3F ,
		 0x40 , 0x41 , 0x42 , 0x43 , 0x44 , 0x45 , 0x46 , 0x47 ,
		 0x48 , 0x49 , 0x4A , 0x4B , 0x4C , 0x4D , 0x4E , 0x4F ,
		 0x50 , 0x51 , 0x52 , 0x53 , 0x54 , 0x55 , 0x56 , 0x57 ,
		 0x58 , 0x59 , 0x5A , 0x5B , 0x5C , 0x5D , 0x5E , 0x5F ,
		 0x60 , 0x61 , 0x62 , 0x63 , 0x64 , 0x65 , 0x66 , 0x67 ,
		 0x68 , 0x69 , 0x6A , 0x6B , 0x6C , 0x6D , 0x6E , 0x6F ,
		 0x70 , 0x71 , 0x72 , 0x73 , 0x74 , 0x75 , 0x76 , 0x77 ,
		 0x78 , 0x79 , 0x7A , 0x7B , 0x7C , 0x7D , 0x7E , 0x7F ,
		 0x80 , 0x81 , 0x82 , 0x83 , 0x84 , 0x85 , 0x86 , 0x87 ,
		 0x88 , 0x89 , 0x8A , 0x8B , 0x8C , 0x8D , 0x8E , 0x8F ,
		 0x90 , 0x91 , 0x92 , 0x93 , 0x94 , 0x95 , 0x96 , 0x97 ,
		 0x98 , 0x99 , 0x9A , 0x9B , 0x9C , 0x9D , 0x9E , 0x9F ,
		 0xA0 , 0xA1 , 0xA2 , 0xA3 , 0xA4 , 0xA5 , 0xA6 , 0xA7 ,
		 0xA8 , 0xA9 , 0xAA , 0xAB , 0xAC , 0xAD , 0xAE , 0xAF ,
		 0xB0 , 0xB1 , 0xB2 , 0xB3 , 0xB4 , 0xB5 , 0xB6 , 0xB7 ,
		 0xB8 , 0xB9 , 0xBA , 0xBB , 0xBC , 0xBD , 0xBE , 0xBF ,
		 0xC0 , 0xC1 , 0xC2 , 0xC3 , 0xC4 , 0xC5 , 0xC6 , 0xC7 ,
		 0xC8 , 0xC9 , 0xCA , 0xCB , 0xCC , 0xCD , 0xCE , 0xCF ,
		 0xD0 , 0xD1 , 0xD2 , 0xD3 , 0xD4 , 0xD5 , 0xD6 , 0xD7 ,
		 0xD8 , 0xD9 , 0xDA , 0xDB , 0xDC , 0xDD , 0xDE , 0xDF ,
		 0xE0 , 0xE1 , 0xE2 , 0xE3 , 0xE4 , 0xE5 , 0xE6 , 0xE7 ,
		 0xE8 , 0xE9 , 0xEA , 0xEB , 0xEC , 0xED , 0xEE , 0xEF ,
		 0xF0 , 0xF1 , 0xF2 , 0xF3 , 0xF4 , 0xF5 , 0xF6 , 0xF7 ,
		 0xF8 , 0xF9 , 0xFA , 0xFB , 0xFC
	};


BYTE			AtalkTokenRingZoneMulticastAddrsHdr[TLAP_MCAST_HDR_LEN] = { 0xC0, 0x00 };

BYTE			AtalkTokenRingZoneMulticastAddrs[TLAP_ZONE_MULTICAST_ADDRS]
												[TLAP_ADDR_LEN - TLAP_MCAST_HDR_LEN] =
	{
		{ 0x00, 0x00, 0x08, 0x00 },
		{ 0x00, 0x00, 0x10, 0x00 },
		{ 0x00, 0x00, 0x20, 0x00 },
		{ 0x00, 0x00, 0x40, 0x00 },
		{ 0x00, 0x00, 0x80, 0x00 },
		{ 0x00, 0x01, 0x00, 0x00 },
		{ 0x00, 0x02, 0x00, 0x00 },
		{ 0x00, 0x04, 0x00, 0x00 },
		{ 0x00, 0x08, 0x00, 0x00 },
		{ 0x00, 0x10, 0x00, 0x00 },
		{ 0x00, 0x20, 0x00, 0x00 },
		{ 0x00, 0x40, 0x00, 0x00 },
		{ 0x00, 0x80, 0x00, 0x00 },
		{ 0x01, 0x00, 0x00, 0x00 },
		{ 0x02, 0x00, 0x00, 0x00 },
		{ 0x04, 0x00, 0x00, 0x00 },
		{ 0x08, 0x00, 0x00, 0x00 },
		{ 0x10, 0x00, 0x00, 0x00 },
		{ 0x20, 0x00, 0x00, 0x00 }
	};

BYTE			AtalkTlapBroadcastAddr[TLAP_ADDR_LEN] = TLAP_BROADCAST_ADDR_INIT;

//
//	Static "source routing" info for a TokenRing broadcast/multicast packet;
//	the following values are set: single-route broadcast, 2 bytes of routing
//	info, outgoing packet, broadcast (bigo) frame size.
//
BYTE			AtalkBroadcastRouteInfo[TLAP_MIN_ROUTING_BYTES] = { 0xC2,	0x70 };

//
//	Same stuff for a non-broadcast packet's simple routing info; the following
//	values are set: non-broadcast, 2 bytes of routing info, outgoing packet,
//
//	802.5-style frame.
BYTE			AtalkSimpleRouteInfo[TLAP_MIN_ROUTING_BYTES] = { 0x02, 0x30 };

//
//	The following may not really be safe, but, we'll make the assumption that
//	all outgoing TokenTalk packets whos destination address starts with "0xC0
//	0x00" are broadcast (or multicast).	Further, we assume that no packets
//	that are intended to be boradcast/multicast will fail to meet this test.
//	If this proves not to be the case, we'll need to find a new way to determine
//	this from the destination address, or introduce a new perameter to the
//	various "buildHeader" routines.	This is all for "source routing" support.
//
BYTE			AtalkBroadcastDestHdr[TLAP_BROADCAST_DEST_LEN] = { 0xC0, 0x00};

PORT_HANDLERS	AtalkPortHandlers[LAST_PORTTYPE] =
	{
		{
			AtalkNdisAddMulticast,
			AtalkNdisRemoveMulticast,
			ELAP_BROADCAST_ADDR_INIT,
			MAX_HW_ADDR_LEN,
			AARP_ELAP_HW_TYPE,
			AARP_ATALK_PROTO_TYPE
		},
		{
			AtalkNdisAddMulticast,
			AtalkNdisRemoveMulticast,
			ELAP_BROADCAST_ADDR_INIT,
			MAX_HW_ADDR_LEN,
			AARP_ELAP_HW_TYPE,
			AARP_ATALK_PROTO_TYPE
		},
		{
			AtalkNdisAddFunctional,
			AtalkNdisRemoveFunctional,
			TLAP_BROADCAST_ADDR_INIT,
			MAX_HW_ADDR_LEN,
			AARP_TLAP_HW_TYPE,
			AARP_ATALK_PROTO_TYPE
		},
		{
			NULL,
			NULL,
			ALAP_BROADCAST_ADDR_INIT,
			1,
			0,
			0
		},
	    {
		    NULL,
		    NULL,
		    ARAP_BROADCAST_ADDR_INIT,
		    1,
		    0,
		    0
	    }
	};


ATALK_STATS		AtalkStatistics = {0};
ATALK_SPIN_LOCK	AtalkStatsLock	= {0};

// The following table ia taken from page D-3 of the Inside AppleTalk manual.
BYTE AtalkUpCaseTable[256] =
{
	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,		// 0x00 - 0x07
	0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,	    // 0x08 - 0x0F
	0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,	    // 0x10 - 0x17
	0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F,	    // 0x18 - 0x1F
	0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,	    // 0x20 - 0x27
	0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F,	    // 0x28 - 0x2F
	0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,	    // 0x30 - 0x37
	0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F,	    // 0x38 - 0x3F
	0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,	    // 0x40 - 0x47
	0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F,	    // 0x48 - 0x4F
	0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,	    // 0x50 - 0x57
	0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F,	    // 0x58 - 0x5F
	0x60, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,	    // 0x60 - 0x67
	0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F,	    // 0x68 - 0x6F
	0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,	    // 0x70 - 0x77
	0x58, 0x59, 0x5A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F,	    // 0x78 - 0x7F
	0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,	    // 0x80 - 0x87
	0xCB, 0x89, 0x80, 0xCC, 0x81, 0x82, 0x83, 0x8F,	    // 0x88 - 0x8F
	0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x84, 0x97,	    // 0x90 - 0x97
	0x98, 0x99, 0x85, 0xCD, 0x9C, 0x9D, 0x9E, 0x86,	    // 0x98 - 0x9F
	0xA0, 0xA1, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7,	    // 0xA0 - 0xA7
	0xA8, 0xA9, 0xAA, 0xAB, 0xAC, 0xAD, 0xAE, 0xAF,	    // 0xA8 - 0xAF
	0xB0, 0xB1, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 0xB7,	    // 0xB0 - 0xB7
	0xB8, 0xB9, 0xBA, 0xBB, 0xBC, 0xBD, 0xAE, 0xAF,	    // 0xB8 - 0xBF
	0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7,	    // 0xC0 - 0xC7
	0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCB, 0xCE, 0xCE,	    // 0xC8 - 0xCF
	0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7,	    // 0xD0 - 0xD7
	0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0xDF,	    // 0xD8 - 0xDF
	0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7,	    // 0xE0 - 0xE7
	0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF,	    // 0xE8 - 0xEF
	0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7,	    // 0xF0 - 0xF7
	0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF	     // 0xF8 - 0xFF
};


USHORT	atalkBlkSize[NUM_BLKIDS] =	// Size of each block
	{
		BLOCK_SIZE(sizeof(BUFFER_DESC)),					// BLKID_BUFFDESC
		BLOCK_SIZE(sizeof(AMT)),							// BLKID_AMT
		BLOCK_SIZE(sizeof(AMT)+MAX_ROUTING_SPACE),			// BLKID_AMT_ROUTE
		BLOCK_SIZE(sizeof(BRE)),							// BLKID_BRE
		BLOCK_SIZE(sizeof(BRE)+MAX_ROUTING_SPACE),			// BLKID_BRE_ROUTE
		BLOCK_SIZE(sizeof(ATP_REQ)),						// BLKID_ATPREQ
		BLOCK_SIZE(sizeof(ATP_RESP)),						// BLKID_ATPRESP
		BLOCK_SIZE(sizeof(ASP_REQUEST)),					// BLKID_ASPREQ

		BLOCK_SIZE(sizeof(ARAPBUF)+ARAP_SMPKT_SIZE),      	// BLKID_ARAP_SMPKT
		BLOCK_SIZE(sizeof(ARAPBUF)+ARAP_MDPKT_SIZE),      	// BLKID_ARAP_MDPKT
		BLOCK_SIZE(sizeof(ARAPBUF)+ARAP_LGPKT_SIZE),      	// BLKID_ARAP_LGPKT
		BLOCK_SIZE(ARAP_SENDBUF_SIZE),      	            // BLKID_ARAP_SNDPKT
		BLOCK_SIZE(sizeof(ARAPBUF)+ARAP_LGBUF_SIZE),       	// BLKID_ARAP_LGBUF
		BLOCK_SIZE(sizeof(AARP_BUFFER)),					// BLKID_AARP
		BLOCK_SIZE(sizeof(DDP_SMBUFFER)),					// BLKID_DDPSM
		BLOCK_SIZE(sizeof(DDP_LGBUFFER)),					// BLKID_DDPLG
		BLOCK_SIZE(sizeof(SENDBUF)),						// BLKID_SENDBUF
		BLOCK_SIZE(sizeof(MNPSENDBUF)+MNP_MINSEND_LEN),     // BLKID_MNP_SMSENDBUF
		BLOCK_SIZE(sizeof(MNPSENDBUF)+MNP_MAXSEND_LEN)	    // BLKID_MNP_LGSENDBUF
	};

USHORT	atalkChunkSize[NUM_BLKIDS] =	// Size of each Chunk
	{
		SM_BLK-BC_OVERHEAD,									// BLKID_BUFFDESC
		SM_BLK-BC_OVERHEAD,									// BLKID_AMT
		SM_BLK-BC_OVERHEAD,									// BLKID_AMT_ROUTE
		SM_BLK-BC_OVERHEAD,									// BLKID_BRE
		SM_BLK-BC_OVERHEAD,									// BLKID_BRE_ROUTE
		LG_BLK-BC_OVERHEAD,									// BLKID_ATPREQ
		LG_BLK-BC_OVERHEAD,									// BLKID_ATPRESP
		LG_BLK-BC_OVERHEAD,									// BLKID_ASPREQ
		SM_BLK-BC_OVERHEAD,									// BLKID_ARAP_SMPKT
		SM_BLK-BC_OVERHEAD,									// BLKID_ARAP_MDPKT
		LG_BLK-BC_OVERHEAD,									// BLKID_ARAP_LGPKT
		XL_BLK-BC_OVERHEAD,                 	            // BLKID_ARAP_SNDPKT
		XL_BLK-BC_OVERHEAD,									// BLKID_ARAP_LGBUF
		SM_BLK-BC_OVERHEAD,									// BLKID_AARP
		SM_BLK-BC_OVERHEAD,									// BLKID_DDPSM
		XL_BLK-BC_OVERHEAD,									// BLKID_DDPLG
		LG_BLK-BC_OVERHEAD,									// BLKID_SENDBUF
		SM_BLK-BC_OVERHEAD,									// BLKID_MNP_SMSENDBUF
		LG_BLK-BC_OVERHEAD									// BLKID_MNP_LGSENDBUF
	};

BYTE	atalkNumBlks[NUM_BLKIDS] =	// Number of blocks per chunk
	{
		NUM_BLOCKS(sizeof(BUFFER_DESC),			SM_BLK),	// BLKID_BUFFDESC
		NUM_BLOCKS(sizeof(AMT),					SM_BLK),	// BLKID_AMT
		NUM_BLOCKS(sizeof(AMT)+MAX_ROUTING_SPACE,SM_BLK),	// BLKID_AMT_ROUTE
		NUM_BLOCKS(sizeof(BRE),					SM_BLK),	// BLKID_BRE
		NUM_BLOCKS(sizeof(BRE)+MAX_ROUTING_SPACE,SM_BLK),	// BLKID_BRE_ROUTE
		NUM_BLOCKS(sizeof(ATP_REQ),				LG_BLK),	// BLKID_ATPREQ
		NUM_BLOCKS(sizeof(ATP_RESP),			LG_BLK),	// BLKID_ATPRESP
		NUM_BLOCKS(sizeof(ASP_REQUEST),			LG_BLK),	// BLKID_ASPREQ
		NUM_BLOCKS(sizeof(ARAPBUF)+ARAP_SMPKT_SIZE,SM_BLK), // BLKID_ARAP_SMPKT
		NUM_BLOCKS(sizeof(ARAPBUF)+ARAP_MDPKT_SIZE,SM_BLK),	// BLKID_ARAP_MDPKT
		NUM_BLOCKS(sizeof(ARAPBUF)+ARAP_LGPKT_SIZE,LG_BLK),	// BLKID_ARAP_LGPKT
		NUM_BLOCKS(ARAP_SENDBUF_SIZE,XL_BLK),	            // BLKID_ARAP_SNDPKT
		NUM_BLOCKS(sizeof(ARAPBUF)+ARAP_LGBUF_SIZE,XL_BLK),	// BLKID_ARAP_LGBUF
		NUM_BLOCKS(sizeof(AARP_BUFFER),			SM_BLK),	// BLKID_AARP
		NUM_BLOCKS(sizeof(DDP_SMBUFFER),		SM_BLK),	// BLKID_DDPSM
		NUM_BLOCKS(sizeof(DDP_LGBUFFER),		XL_BLK),	// BLKID_DDPLG
		NUM_BLOCKS(sizeof(SENDBUF),				LG_BLK),	// BLKID_SENDBUF
		NUM_BLOCKS(sizeof(MNPSENDBUF)+MNP_MINSEND_LEN,SM_BLK), // BLKID_MNP_SMSENDBUF
		NUM_BLOCKS(sizeof(MNPSENDBUF)+MNP_MAXSEND_LEN,LG_BLK)  // BLKID_MNP_LGSENDBUF
	};

ATALK_SPIN_LOCK	atalkBPLock[NUM_BLKIDS] = { 0 };

PBLK_CHUNK		atalkBPHead[NUM_BLKIDS] = { 0 };
TIMERLIST		atalkBPTimer = { 0 };

//	List of all adsp address/connection objects.
PADSP_ADDROBJ	atalkAdspAddrList	= NULL;
PADSP_CONNOBJ	atalkAdspConnList	= NULL;
ATALK_SPIN_LOCK	atalkAdspLock		= {0};

//
// ARAP data
//
struct _PORT_DESCRIPTOR  *RasPortDesc  EQU  NULL;

// spinlock to guard the all the Arap global things
ATALK_SPIN_LOCK ArapSpinLock;

// global configuration info
ARAPGLOB        ArapGlobs           EQU {0};

PIRP            ArapSelectIrp       EQU NULL;
DWORD           ArapConnections     EQU 0;
DWORD           ArapStackState      EQU ARAP_STATE_INACTIVE_WAITING;

DWORD           PPPConnections      EQU 0;

#if	DBG

ATALK_SPIN_LOCK		AtalkDebugSpinLock;

DWORD               AtalkDbgMdlsAlloced  EQU 0;
DWORD               AtalkDbgIrpsAlloced  EQU 0;


ULONG			AtalkDebugDump 		= 0;
LONG			AtalkDumpInterval	= DBG_DUMP_DEF_INTERVAL;
ULONG			AtalkDebugLevel		= DBG_LEVEL_ERR;
ULONG			AtalkDebugSystems	= DBG_MOST;
TIMERLIST		AtalkDumpTimerList	= { 0 };
LONG			AtalkMemLimit = 10*1024*1024;

LONG	atalkNumChunksForId[NUM_BLKIDS] = { 0 };
LONG	atalkBlksForId[NUM_BLKIDS] = { 0 };

PIRP            ArapSniffIrp        = NULL;
ARAPSTATS       ArapStatistics      = {0,0,10000,10000,0,10000};
DWORD           ArapDumpLevel       = 0;
DWORD           ArapDumpLen         = 64;
DWORD           ArapDbgMnpSendSizes[30] = {0};
DWORD           ArapDbgMnpRecvSizes[30] = {0};
DWORD           ArapDbgArapSendSizes[15] = {0};
DWORD           ArapDbgArapRecvSizes[15] = {0};
LARGE_INTEGER   ArapDbgLastTraceTime;
UCHAR           ArapDbgLRPacket[30] = {0x1d,1,2,1,6,1,0,0,0,0,0xff,2,1,2,3,
                                       1,8,4,2,0x40,0,8,1,3,0xe,4,3,0,8,0xfa};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\atalk\sys\ddp.h ===
/*+++

Copyright (c) 1992  Microsoft Corporation

Module Name:

	ddp.h

Abstract:

	This module contains the DDP address object and ddp related definitions

Author:

	Jameel Hyder (jameelh@microsoft.com)
	Nikhil Kamkolkar (nikhilk@microsoft.com)

Revision History:
	19 Jun 1992		Initial Version

Notes:	Tab stop: 4
--*/

#ifndef	_DDP_
#define	_DDP_

// Network number information.
#define FIRST_VALID_NETWORK			0x0001
#define LAST_VALID_NETWORK			0xFFFE
#define FIRST_STARTUP_NETWORK		0xFF00
#define LAST_STARTUP_NETWORK		0xFFFE
#define NULL_NETWORK				0x0000
#define UNKNOWN_NETWORK				NULL_NETWORK
#define CABLEWIDE_BROADCAST_NETWORK	NULL_NETWORK

//	Appletalk Sockets Definitions
#define UNKNOWN_SOCKET				0
#define	DYNAMIC_SOCKET				UNKNOWN_SOCKET
#define LAST_VALID_SOCKET			254
#define FIRST_DYNAMIC_SOCKET		128
#define LAST_DYNAMIC_SOCKET			LAST_VALID_SOCKET
#define FIRST_STATIC_SOCKET			1
#define FIRST_VALID_SOCKET			FIRST_STATIC_SOCKET
#define LAST_STATIC_SOCKET			127

// "Well known" sockets:
#define RTMP_SOCKET					1		// RTMP
#define NAMESINFORMATION_SOCKET		2		// NBP
#define ECHOER_SOCKET				4		// EP
#define ZONESINFORMATION_SOCKET		6		// ZIP

#define LAST_APPLE_RESD_SOCKET		0x3F	// Apple reserves 1 thru 0x3F

//	DDP Datagram Definitions
#define MAX_DGRAM_SIZE				586
#define MAX_LDDP_PKT_SIZE			600		// Really 599, but even is nicer
#define MAX_SDDP_PKT_SIZE			592		// Again, really 591

//	Define temporary buffer sizes, these must be big enough to hold both all
//	of the packet data plus any link/hardware headers...
#define MAX_PKT_SIZE				(MAX_HDR_LEN + MAX_LDDP_PKT_SIZE)

#define DDP_LEN_MASK1				0x03	// High order 3 bits of length
#define DDP_LEN_MASK2				0xFF	// Next byte of length

// DDP packet offsets (skipping Link/Hardware headers):
#define SDDP_HDR_LEN				5

#define SDDP_LEN_OFFSET				0
#define SDDP_DEST_SOCKET_OFFSET		2
#define SDDP_SRC_SOCKET_OFFSET		3
#define SDDP_PROTO_TYPE_OFFSET		4
#define SDDP_DGRAM_OFFSET			5

#define LDDP_HDR_LEN				13

#define LDDP_LEN_OFFSET				0
#define LDDP_CHECKSUM_OFFSET		2
#define LDDP_DEST_NETWORK_OFFSET	4
#define LDDP_SRC_NETWORK_OFFSET		6
#define LDDP_DEST_NODE_OFFSET		8
#define LDDP_SRC_NODE_OFFSET		9
#define LDDP_DEST_SOCKET_OFFSET		10
#define LDDP_SRC_SOCKET_OFFSET		11
#define LDDP_PROTO_TYPE_OFFSET		12
#define LDDP_DGRAM_OFFSET			13

#define LEADING_UNCHECKSUMED_BYTES	4
#define LDDP_HOPCOUNT_MASK			0x3C

#define DECIMAL_BASE    			10

// DDP protocol types:
#define	DDPPROTO_ANY				0	// Used to allow any protocol packet

#define DDPPROTO_DDP    			0
#define DDPPROTO_RTMPRESPONSEORDATA 1
#define DDPPROTO_NBP				2
#define DDPPROTO_ATP				3
#define DDPPROTO_EP					4
#define DDPPROTO_RTMPREQUEST		5
#define DDPPROTO_ZIP				6
#define DDPPROTO_ADSP				7
#define DDPPROTO_MAX        		255

typedef	struct _DDPEVENT_INFO
{
	//	Event handler routines: DDP Only has RecvDatagram/Error handlers

	//	The following function pointer always points to a TDI_IND_RECEIVE_DATAGRAM
	//	event handler for the address.
	PTDI_IND_RECEIVE_DATAGRAM	ev_RcvDgramHandler;
	PVOID						ev_RcvDgramCtx;

	// The following function pointer always points to a TDI_IND_ERROR
	// handler for the address.
	PTDI_IND_ERROR				ev_ErrHandler;
	PVOID						ev_ErrCtx;
	PVOID						ev_ErrOwner;

	//	Winsock assumes a buffering transport. So we buffer the last datagram
	//	indicated that was not accepted.
	BYTE						ev_IndDgram[MAX_DGRAM_SIZE];
	int							ev_IndDgramLen;
	int							ev_IndProto;

	//	Source address of buffered datagram
	ATALK_ADDR					ev_IndSrc;

} DDPEVENT_INFO, *PDDPEVENT_INFO;



//	Handler type for the DDP address object
typedef	VOID	(*DDPAO_HANDLER)(
					IN	PPORT_DESCRIPTOR	pPortDesc,
					IN	struct _DDP_ADDROBJ *pAddr,
					IN	PBYTE				pPkt,
					IN	USHORT				pPktLen,
					IN	PATALK_ADDR			pSrcAddr,
					IN	PATALK_ADDR			pActDest,
					IN	ATALK_ERROR			ErrorCode,
					IN	BYTE				pDdpType,
					IN	PVOID				pHandlerCtx,
					IN	BOOLEAN				OptimizedPath,
					IN	PVOID				OptimizeCtx);

//	DDP Address Object
//	This is the basic address object in the stack. All other address objects
//	eventually resolve to this one. It also holds the AppletalkSocket opened
//	as its actual address. One address object corresponds to one address.

//	DDP ADDRESS OBJECT	STATES
#define	DDPAO_DGRAM_EVENT		0x00000001
#define	DDPAO_DGRAM_ACTIVE		0x00000002
#define	DDPAO_DGRAM_PENDING		0x00000004
#define DDPAO_SOCK_INTERNAL     0x00000008
#define DDPAO_SOCK_PNPZOMBIE    0x00000010
#define	DDPAO_CLOSING			0x80000000


#define	DDPAO_SIGNATURE			(*(PULONG)"DDPA")
#define	VALID_DDP_ADDROBJ(pDdpAddr)	(((pDdpAddr) != NULL) &&	\
			(((struct _DDP_ADDROBJ *)(pDdpAddr))->ddpao_Signature == DDPAO_SIGNATURE))
typedef struct _DDP_ADDROBJ
{
	ULONG					ddpao_Signature;

	//	This will be a hash overflow list. Hash on the internet address.
	//	List of address objects on the node linkage
	struct _DDP_ADDROBJ	*	ddpao_Next;

	ULONG					ddpao_RefCount;

	//	State of the address object
	ULONG					ddpao_Flags;

	//	Backpointer to the node on which this socket exists
	struct _ATALK_NODE	 *	ddpao_Node;

	//	The Appletalk address number for this object
	ATALK_ADDR				ddpao_Addr;

	//	List of NBP names registered on this socket
	struct _REGD_NAME	*	ddpao_RegNames;

	//	List of NBP names being looked up, registered or confirmed on
	//	this socket.
	struct _PEND_NAME	*	ddpao_PendNames;

	//	Linked list of pending ddp reads
	LIST_ENTRY				ddpao_ReadLinkage;

	//	The protocol type to use for datagrams sent on this socket and
	//	which can be received on this socket. 0 => no restrictions.
	BYTE					ddpao_Protocol;

	ATALK_SPIN_LOCK			ddpao_Lock;
	PATALK_DEV_CTX			ddpao_DevCtx;

	//	The handler below is an listener for the upper layers. Note that
	//	this will take precedence over a incoming datagram event handler
	//	which would be set in ddpao_EventInfo.
	DDPAO_HANDLER			ddpao_Handler;
	PVOID					ddpao_HandlerCtx;

	//	This structure is allocated when setting an event handler
	//	on this socket. All the event handler addresses are part of this
	//	structure.
	PDDPEVENT_INFO			ddpao_EventInfo;

	//	Completion routine to be called when socket is closed
	GENERIC_COMPLETION		ddpao_CloseComp;
	PVOID					ddpao_CloseCtx;
} DDP_ADDROBJ, *PDDP_ADDROBJ;

//	Receive datagram completion: This will return the mdl we pass in along
//	with the received length written into the mdl. Also, the protocol type
//	and the RemoteAddress are passed back. The receive context will be the
//	irp for the request. As will be the send context.
typedef	VOID	(*RECEIVE_COMPLETION)(
						IN	ATALK_ERROR			ErrorCode,
						IN	PAMDL				OpaqueBuffer,
						IN	USHORT          	LengthReceived,
						IN	PATALK_ADDR			RemoteAddress,
						IN	PVOID				ReceiveContext);

typedef	VOID	(FASTCALL *WRITE_COMPLETION)(
						IN	NDIS_STATUS			Status,
						IN	PVOID				Ctx);

typedef	VOID	(FASTCALL *TRANSMIT_COMPLETION)(
						IN	NDIS_STATUS			Status,
						IN	struct _SEND_COMPL_INFO	*	pInfo);

//	If the above routine was set in the AtalkDdpSend(), then
//	then context values would be:
//	Ctx1 = pddp address object
//	Ctx2 = pbuffer descriptor
//	Ctx3 = Only for DdpWrite calls, this will be a pointer to the
//			write structure enqueued in the ddp address object.
//
//	If the above routine was set in the AtalkDdpTransmit(), then
//	the context values would be (as specified by the client of
//	course):
//	Ctx1 = pport descriptor
//	Ctx2 = pbuffer descriptor
//	Ctx3 = not used.
//
//	These are only suggested ideas, but probably is what the internal
//	stack routines will use.

//	This is used to store a pending read on a particular socket.
typedef struct _DDP_READ
{
	//	Linkage chain for reads on a socket.
	LIST_ENTRY			dr_Linkage;

	PAMDL				dr_OpBuf;
	USHORT				dr_OpBufLen;

	RECEIVE_COMPLETION	dr_RcvCmp;
	PVOID				dr_RcvCtx;

} DDP_READ, *PDDP_READ;


//	This is used to store a pending write on a particular socket
//	DDP will create a buffer descriptor for the header
//	and will chain it in front of the buffer descriptor passed in.
//	A pointer to this structure will then be passed as a completion
//	context to DdpSend.
typedef struct _DDP_WRITE
{
	//	Linkage chain for writes on a socket.
	LIST_ENTRY		dw_Linkage;

	//	The buffer descriptor chain, including the ddp buffer
	//	descriptor containing the ddp/optional/link headers.
	PBUFFER_DESC	dw_BufferDesc;

	//	Write completion
	//	This will be called with the context (which will be a pointer
	//	to the write irp) after the write completes.
	WRITE_COMPLETION	dw_WriteRoutine;
	PVOID				dw_WriteCtx;

} DDP_WRITE, *PDDP_WRITE;

//
//	CANCEL IRP Functionality for NT:
//
//	We have decided that if we receive a cancel irp for a particular request,
//	we will shutdown the file object associated with that request, whether it
//	be a connection object or an address object. This implies that the socket/
//	connection/listener will be closed, thus cancelling *all* pending requests.
//

ATALK_ERROR
AtalkDdpOpenAddress(
	IN		PPORT_DESCRIPTOR		pPortDesc,
	IN		BYTE					Socket,
	IN	OUT	PATALK_NODEADDR			pDesiredNode	OPTIONAL,
	IN		DDPAO_HANDLER			pSktHandler		OPTIONAL,
	IN		PVOID					pSktCtx			OPTIONAL,
	IN		BYTE					ProtoType		OPTIONAL,
	IN		PATALK_DEV_CTX			pDevCtx,
	OUT		PDDP_ADDROBJ	*		pAddr);

ATALK_ERROR
AtalkDdpCloseAddress(
	IN	PDDP_ADDROBJ				pAddr,
	IN	GENERIC_COMPLETION			pCloseCmp	OPTIONAL,	
	IN	PVOID						pCloseCtx	OPTIONAL);

ATALK_ERROR
AtalkDdpPnPSuspendAddress(
	IN	PDDP_ADDROBJ			pDdpAddr);

ATALK_ERROR
AtalkDdpCleanupAddress(
	IN	PDDP_ADDROBJ				pAddr);

ATALK_ERROR
AtalkDdpInitCloseAddress(
	IN	PPORT_DESCRIPTOR			pPortDesc,
	IN	PATALK_ADDR					pAtalkAddr);

ATALK_ERROR
AtalkInitDdpOpenStaticSockets(
	IN		PPORT_DESCRIPTOR		pPortDesc,
	IN	OUT PATALK_NODE				pNode);

ATALK_ERROR
AtalkDdpReceive(
	IN		PDDP_ADDROBJ			pAddr,
	IN		PAMDL					pAmdl,
	IN		USHORT					AmdlLen,
	IN		ULONG					RecvFlags,
	IN		RECEIVE_COMPLETION		pRcvCmp,
	IN		PVOID					pRcvCtx);

ATALK_ERROR
AtalkDdpSend(
	IN	PDDP_ADDROBJ				pDdpAddr,
	IN	PATALK_ADDR					DestAddr,
	IN	BYTE						ProtoType,
	IN	BOOLEAN						DefinitelyRemoteAddr,
	IN	PBUFFER_DESC				pBufDesc,
	IN	PBYTE						pOptHdr			OPTIONAL,
	IN	USHORT						OptHdrLen		OPTIONAL,
	IN	PBYTE						pZoneMcastAddr	OPTIONAL,
	IN	struct _SEND_COMPL_INFO	*	pInfo			OPTIONAL);

ATALK_ERROR
AtalkDdpTransmit(
	IN	PPORT_DESCRIPTOR			pPortDesc,
	IN	PATALK_ADDR					SrcAddr,
	IN	PATALK_ADDR					DestAddr,
	IN	BYTE						ProtoType,
	IN	PBUFFER_DESC				pBufDesc,
	IN	PBYTE						pOptHdr			OPTIONAL,
	IN	USHORT						OptHdrLen		OPTIONAL,
	IN	USHORT						HopCnt,
	IN	PBYTE						pMcastAddr		OPTIONAL,	
	IN	PATALK_NODEADDR				pXmitDestNode	OPTIONAL,
	IN	struct _SEND_COMPL_INFO	*	pInfo			OPTIONAL);

VOID
AtalkDdpSendComplete(
	IN	NDIS_STATUS					Status,
	IN	PBUFFER_DESC				pBufDesc,
	IN	struct _SEND_COMPL_INFO	*	pInfo			OPTIONAL);

VOID
AtalkDdpPacketIn(
	IN	PPORT_DESCRIPTOR			pPortDesc,
	IN	PBYTE						pLinkHdr,
	IN	PBYTE						pPkt,
	IN	USHORT						PktLen,
    IN  BOOLEAN                     fWanPkt);

VOID
AtalkDdpQuery(
	IN	PDDP_ADDROBJ				pDdpAddr,
	IN	PAMDL						pAmdl,
	OUT	PULONG						BytesWritten);

VOID
AtalkDdpRefByAddr(
	IN		PPORT_DESCRIPTOR		pPortDesc,
	IN		PATALK_ADDR				pAtalkAddr,
	OUT		PDDP_ADDROBJ	*		ppDdpAddr,
	OUT		PATALK_ERROR			pErr);

VOID
AtalkDdpRefByAddrNode(
	IN		PPORT_DESCRIPTOR		pPortDesc,
	IN		PATALK_ADDR				pAtalkAddr,
	IN		PATALK_NODE				pAtalkNode,
	OUT		PDDP_ADDROBJ	*		ppDdpAddr,
	OUT		PATALK_ERROR			pErr);

VOID
AtalkDdpRefNextNc(
	IN	PDDP_ADDROBJ				pDdpAddr,
	IN	PDDP_ADDROBJ	*			ppDdpAddr,
	OUT	PATALK_ERROR				pErr);

VOID FASTCALL
AtalkDdpDeref(
	IN	OUT		PDDP_ADDROBJ		pDdpAddr,
	IN			BOOLEAN				AtDpc);

VOID
AtalkDdpOutBufToNodesOnPort(
	IN	PPORT_DESCRIPTOR			pPortDesc,
	IN	PATALK_ADDR					pSrc,
	IN	PATALK_ADDR					pDest,
	IN	BYTE						ProtoType,
	IN	PBUFFER_DESC				pBufDesc,
	IN	PBYTE						pOptHdr,
	IN	USHORT						OptHdrLen,
	OUT	PBOOLEAN					Delivered);

VOID
AtalkDdpInPktToNodesOnPort(
	IN	PPORT_DESCRIPTOR			pPortDesc,
	IN	PATALK_ADDR					pDest,
	IN	PATALK_ADDR					pSrc,
	IN	BYTE						ProtoType,
	IN	PBYTE						pPkt,
	IN	USHORT						PktLen,
	OUT	PBOOLEAN					Routed);

VOID
AtalkDdpInvokeHandlerBufDesc(
	IN		PPORT_DESCRIPTOR		pPortDesc,
	IN		PDDP_ADDROBJ			pDdpAddr,
	IN		PATALK_ADDR				pSrcAddr,
	IN		PATALK_ADDR				pActDest,
	IN		BYTE					ProtoType,
	IN		PBUFFER_DESC			pBufDesc,
	IN		PBYTE					pOptHdr,
	IN		USHORT					OptHdrLen);

VOID
AtalkDdpInvokeHandler(
	IN		PPORT_DESCRIPTOR		pPortDesc,
	IN		PDDP_ADDROBJ			pDdpAddr,
	IN		PATALK_ADDR				pSrcAddr,
	IN		PATALK_ADDR				pActDest,
	IN		BYTE					ProtoType,
	IN		PBYTE					pPkt,
	IN		USHORT					PktLen);

USHORT
AtalkDdpCheckSumBuffer(
	IN	PBYTE						Buffer,
	IN	USHORT						BufLen,
	IN	USHORT						CurrentCheckSum);

USHORT
AtalkDdpCheckSumBufferDesc(
	IN	PBUFFER_DESC				pBuffDesc,
	IN	USHORT						Offset);

USHORT
AtalkDdpCheckSumPacket(
	IN	PBYTE						pHdr,
	IN	USHORT						HdrLen,
	IN	PBYTE						pPkt,
	IN	USHORT						PktLen);

VOID
AtalkDdpNewHandlerForSocket(
	IN	PDDP_ADDROBJ				pDdpAddr,
	IN	DDPAO_HANDLER				pSktHandler,
	IN	PVOID						pSktHandlerCtx);

//	MACROS
#define	DDP_MSB_LEN(L)			(((L) >> 8) & 0x03)
#define	DDP_GET_LEN(P)			((((*P) & 0x03) << 8) + *(P+1))
#define	DDP_GET_HOP_COUNT(P)	(((*P) >> 2) & 0x0F)
#define	DDP_HOP_COUNT(H)		(((H) & 0x0F) << 2)

#if DBG

#define	AtalkDdpReferenceByPtr(pDdpAddr, pErr)					\
	{															\
		KIRQL	OldIrql;										\
																\
		ACQUIRE_SPIN_LOCK(&(pDdpAddr)->ddpao_Lock, &OldIrql);	\
		AtalkDdpRefByPtrNonInterlock(pDdpAddr, pErr);			\
		RELEASE_SPIN_LOCK(&(pDdpAddr)->ddpao_Lock, OldIrql);	\
		DBGPRINT(DBG_COMP_DDP, DBG_LEVEL_REFDDP,				\
				("AtalkDdpReferenceByPtr: %s %d PostCount %d\n",\
				__FILE__, __LINE__,pDdpAddr->ddpao_RefCount));	\
	}

#define	AtalkDdpReferenceByPtrDpc(pDdpAddr, pErr)				\
	{															\
		ACQUIRE_SPIN_LOCK_DPC(&(pDdpAddr)->ddpao_Lock);			\
		AtalkDdpRefByPtrNonInterlock(pDdpAddr, pErr);			\
		RELEASE_SPIN_LOCK_DPC(&(pDdpAddr)->ddpao_Lock);			\
		DBGPRINT(DBG_COMP_DDP, DBG_LEVEL_REFDDP,				\
				("AtalkDdpReferenceByPtr: %s %d PostCount %d\n",\
				__FILE__, __LINE__,pDdpAddr->ddpao_RefCount));	\
	}

#define	AtalkDdpRefByPtrNonInterlock(pDdpAddr, pErr)			\
	{															\
		ASSERT (VALID_DDP_ADDROBJ(pDdpAddr));					\
																\
		*pErr = ATALK_DDP_CLOSING;								\
																\
		if ((pDdpAddr->ddpao_Flags & DDPAO_CLOSING) == 0)		\
		{														\
			pDdpAddr->ddpao_RefCount++;							\
			*pErr = ATALK_NO_ERROR;								\
		}														\
		DBGPRINT(DBG_COMP_DDP, DBG_LEVEL_REFDDP,				\
				("AtalkDdpReferenceByPtrNonInterlock: %s %d PostCount %d\n",\
				__FILE__, __LINE__,							\
				pDdpAddr->ddpao_RefCount));					\
	}

#define	AtalkDdpReferenceNextNc(pDdpAddr, ppDdpAddr, pErr)		\
	{															\
		AtalkDdpRefNextNc(pDdpAddr, ppDdpAddr, pErr);			\
		if (ATALK_SUCCESS(*pErr))								\
		{														\
			DBGPRINT(DBG_COMP_DDP, DBG_LEVEL_REFDDP,			\
					("DdpRefNextNc : %s %d PostCount %d\n",		\
					__FILE__, __LINE__,							\
					(*ppDdpAddr)->ddpao_RefCount));				\
		}														\
	}

#define	AtalkDdpReferenceByAddr(pPortDesc, pAddr, ppDdpAddr, pErr)	\
	{															\
		AtalkDdpRefByAddr(pPortDesc, pAddr, ppDdpAddr, pErr);	\
		if (ATALK_SUCCESS(*pErr))								\
		{														\
			DBGPRINT(DBG_COMP_DDP, DBG_LEVEL_REFDDP,			\
					("AtalkDdpReferenceByAddr: %s %d PostCount %d\n",\
					__FILE__, __LINE__,							\
					(*ppDdpAddr)->ddpao_RefCount));				\
		}														\
	}

#define	AtalkDdpDereference(pDdpAddr)							\
	{															\
		DBGPRINT(DBG_COMP_DDP, DBG_LEVEL_REFDDP,				\
				("AtalkDdpDereference: %s %d PreCount %d\n",	\
				__FILE__, __LINE__,pDdpAddr->ddpao_RefCount));	\
		AtalkDdpDeref(pDdpAddr, FALSE);							\
	}

#define	AtalkDdpDereferenceDpc(pDdpAddr)						\
	{															\
		DBGPRINT(DBG_COMP_DDP, DBG_LEVEL_REFDDP,				\
				("AtalkDdpDereferenceDpc: %s %d PreCount %d\n",	\
				__FILE__, __LINE__,pDdpAddr->ddpao_RefCount));	\
		AtalkDdpDeref(pDdpAddr, TRUE);							\
	}

#else
#define	AtalkDdpReferenceByPtr(pDdpAddr, pErr) 					\
	{															\
		KIRQL	OldIrql;										\
																\
		ACQUIRE_SPIN_LOCK(&(pDdpAddr)->ddpao_Lock, &OldIrql);	\
		AtalkDdpRefByPtrNonInterlock(pDdpAddr, pErr);			\
		RELEASE_SPIN_LOCK(&(pDdpAddr)->ddpao_Lock, OldIrql);	\
	}

#define	AtalkDdpReferenceByPtrDpc(pDdpAddr, pErr)				\
	{															\
		ACQUIRE_SPIN_LOCK_DPC(&(pDdpAddr)->ddpao_Lock);			\
		AtalkDdpRefByPtrNonInterlock(pDdpAddr, pErr);			\
		RELEASE_SPIN_LOCK_DPC(&(pDdpAddr)->ddpao_Lock);			\
	}

#define	AtalkDdpRefByPtrNonInterlock(pDdpAddr, pErr)			\
	{															\
		*pErr = ATALK_DDP_CLOSING;								\
																\
		if ((pDdpAddr->ddpao_Flags & DDPAO_CLOSING) == 0)		\
		{														\
			pDdpAddr->ddpao_RefCount++;							\
			*pErr = ATALK_NO_ERROR;								\
		}														\
	}

#define	AtalkDdpReferenceByAddr(pPortDesc, pAddr, ppDdpAddr, pErr) \
		AtalkDdpRefByAddr(pPortDesc, pAddr, ppDdpAddr, pErr)

#define	AtalkDdpReferenceNextNc(pDdpAddr, ppDdpAddr, pErr)		\
		AtalkDdpRefNextNc(pDdpAddr, ppDdpAddr, pErr)

#define	AtalkDdpDereference(pDdpAddr) 							\
		AtalkDdpDeref(pDdpAddr, FALSE)

#define	AtalkDdpDereferenceDpc(pDdpAddr) 						\
		AtalkDdpDeref(pDdpAddr, TRUE)
#endif

#define	NET_ON_NONEXTPORT(pPort)								\
			(pPort->pd_LtNetwork)

#define	NODE_ON_NONEXTPORT(pPort)								\
			(((pPort)->pd_Nodes != NULL) ?						\
				(pPort)->pd_Nodes->an_NodeAddr.atn_Node : 0)

ATALK_ERROR
atalkDdpAllocSocketOnNode(
	IN		PPORT_DESCRIPTOR		pPortDesc,
	IN		BYTE					Socket,
	IN		PATALK_NODE				pAtalkNode,
	IN		DDPAO_HANDLER			pSktHandler	OPTIONAL,
	IN		PVOID					pSktCtx			OPTIONAL,
	IN		BYTE					ProtoType		OPTIONAL,
	IN		PATALK_DEV_CTX			pDevCtx,
	OUT		PDDP_ADDROBJ			pDdpAddr);

VOID
atalkDdpInitCloseComplete(
	IN	ATALK_ERROR					Error,
	IN	PVOID						Ctx);

/*
PBRE
atalkDdpFindInBrc(
	IN	PPORT_DESCRIPTOR			pPortDesc,
	IN	PATALK_NODEADDR				pDestNodeAddr);
*/
#define	atalkDdpFindInBrc(_pPortDesc, _Network, _ppBre)		\
{															\
	USHORT		index;										\
	KIRQL		OldIrql;									\
	PBRE		pBre;										\
															\
	index = (_Network) & (PORT_BRC_HASH_SIZE - 1);			\
															\
	ACQUIRE_SPIN_LOCK(&(_pPortDesc)->pd_Lock, &OldIrql);	\
															\
	for (pBre = (_pPortDesc)->pd_Brc[index];				\
		 pBre != NULL;										\
		 pBre = pBre->bre_Next)								\
	{														\
		if ((_Network) == pBre->bre_Network)				\
		{													\
			break;											\
		}													\
	}														\
															\
	RELEASE_SPIN_LOCK(&(_pPortDesc)->pd_Lock, OldIrql);		\
															\
 	*(_ppBre) = pBre;										\
}


BOOLEAN
atalkDdpFindAddrOnList(
	IN	PATALK_NODE					pAtalkNode,
	IN	ULONG						Index,
	IN	BYTE						Socket,
	OUT	PDDP_ADDROBJ	*			ppDdpAddr);

#define	IS_VALID_SOCKET(Socket)								\
			((Socket == DYNAMIC_SOCKET)			||			\
			 (Socket == LAST_DYNAMIC_SOCKET)	||			\
			 ((Socket >= FIRST_STATIC_SOCKET) &&			\
				(Socket <= LAST_STATIC_SOCKET)))

#endif	// _DDP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\atalk\sys\fwddecl.h ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	fwddecl.h

Abstract:

	This file defines dummy structures to avoid the circular relationships in
	header files.

Author:

	Jameel Hyder (microsoft!jameelh)
	Nikhil Kamkolkar (microsoft!nikhilk)


Revision History:
	10 Mar 1993             Initial Version

Notes:  Tab stop: 4
--*/


#ifndef _FWDDECL_
#define _FWDDECL_

struct _PORT_DESCRIPTOR;

struct _AMT_NODE;

struct _ZONE;

struct _ZONE_LIST;

struct _DDP_ADDROBJ;

struct _ATP_ADDROBJ;

struct _PEND_NAME;

struct _REGD_NAME;

struct _BUFFER_DESC;

struct _AARP_BUFFER;

struct _DDP_SMBUFFER;

struct _DDP_LGBUFFER;

struct _TimerList;

struct _RoutingTableEntry;

struct _ZipCompletionInfo;

struct _SEND_COMPL_INFO;

struct _ActionReq;

struct _BLK_HDR;

struct _BLK_CHUNK;

// Support for debugging
typedef	struct
{
	KSPIN_LOCK		SpinLock;
#if	DBG
	ULONG			FileLineLock;
	ULONG			FileLineUnlock;
#endif
} ATALK_SPIN_LOCK, *PATALK_SPIN_LOCK;

#endif  // _FWDDECL_


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\atalk\sys\ddp.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

	ddp.c

Abstract:

	This module implements the ddp protocol.

Author:

	Jameel Hyder (jameelh@microsoft.com)
	Nikhil Kamkolkar (nikhilk@microsoft.com)

Revision History:
	19 Jun 1992		Initial Version

Notes:	Tab stop: 4
--*/

#include <atalk.h>
#pragma hdrstop
#define	FILENUM	DDP

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGEINIT, AtalkDdpInitCloseAddress)
#pragma alloc_text(PAGEINIT, atalkDdpInitCloseComplete)
#pragma alloc_text(PAGEINIT, AtalkInitDdpOpenStaticSockets)
#endif

//
//	AtalkDdpOpenAddress()
//	This opens a DDP address object and returns a pointer to it in
//	DdpAddrObject. The AppletalkSocket is created and will be the
//	address of this object.
//

ATALK_ERROR
AtalkDdpOpenAddress(
	IN		PPORT_DESCRIPTOR		pPortDesc,
	IN		BYTE					Socket,
	IN OUT	PATALK_NODEADDR			pDesiredNode	OPTIONAL,
	IN 		DDPAO_HANDLER			pSktHandler 	OPTIONAL,
	IN		PVOID					pSktCtx			OPTIONAL,
	IN		BYTE					Protocol		OPTIONAL,
	IN		PATALK_DEV_CTX			pDevCtx,
	OUT		PDDP_ADDROBJ	*		ppDdpAddr
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PATALK_NODE		pAtalkNode, pNextNode;

	PDDP_ADDROBJ 	pDdpAddr 	= NULL;
	ATALK_ERROR		error 		= ATALK_NO_ERROR;

	DBGPRINT(DBG_COMP_DDP, DBG_LEVEL_INFO,
			("AtalkDdpOpenAddress: Opening DDP socket %d on port %lx\n",
			Socket, pPortDesc));

	do
	{
		//	Verify the Appletalk socket number
		if (!IS_VALID_SOCKET(Socket))
		{
			error = ATALK_SOCKET_INVALID;
			break;
		}
		//	Allocate space for the address object
		if ((pDdpAddr = AtalkAllocZeroedMemory(sizeof(DDP_ADDROBJ))) == NULL)
		{
			error = ATALK_RESR_MEM;
			break;
		}
	
		if (pDesiredNode != NULL)
		{
			AtalkNodeReferenceByAddr(pPortDesc,
									 pDesiredNode,
									 &pAtalkNode,
									 &error);
	
			if (ATALK_SUCCESS(error))
			{
				ASSERT(VALID_ATALK_NODE(pAtalkNode));

				//	try to allocate the socket on this node.
				error = atalkDdpAllocSocketOnNode(pPortDesc,
												  Socket,
												  pAtalkNode,
												  pSktHandler,
												  pSktCtx,
												  Protocol,
												  pDevCtx,
												  pDdpAddr);
	
				//	Remove the reference on the node.
				AtalkNodeDereference(pAtalkNode);
			}

			break;
		}
		else
		{
			KIRQL	OldIrql;

			//	We can open the socket on any one of our
			//	nodes.

			//	We first get the port lock
			//	Then we go through all the nodes on the port
			//	reference a node, let go of the port lock
			//	acquire the node lock, try to open the socket
			//	on it. If we succeed, we return, else we fail.

			ACQUIRE_SPIN_LOCK(&pPortDesc->pd_Lock, &OldIrql);
			do
			{
				//	Try to get a referenced node. null if no non-closing node found.
				AtalkNodeReferenceNextNc(pPortDesc->pd_Nodes, &pAtalkNode, &error);
		
				while (ATALK_SUCCESS(error))
				{
					//	We do not use this node if it is orphaned or if
					//	it is a router node and we are trying to open a
					//	user socket (dynamic or non-reserved).
					if (((pAtalkNode->an_Flags & (AN_ORPHAN_NODE | AN_ROUTER_NODE)) == 0) ||
						((Socket != UNKNOWN_SOCKET) && (Socket <= LAST_APPLE_RESD_SOCKET)))
					{
						RELEASE_SPIN_LOCK(&pPortDesc->pd_Lock, OldIrql);
	
						//	try to allocate the socket on this node. PortLock held!
						error = atalkDdpAllocSocketOnNode(pPortDesc,
														  Socket,
														  pAtalkNode,
														  pSktHandler,
														  pSktCtx,
														  Protocol,
														  pDevCtx,
														  pDdpAddr);
	
						if (ATALK_SUCCESS(error))
						{
							//	Done! Break out of the loop. Remove the ref we added.
							AtalkNodeDereference(pAtalkNode);
							ACQUIRE_SPIN_LOCK(&pPortDesc->pd_Lock, &OldIrql);
							break;
						}

						ACQUIRE_SPIN_LOCK(&pPortDesc->pd_Lock, &OldIrql);
					}

					//	Gotta get to the next node.
					AtalkNodeReferenceNextNc(pAtalkNode->an_Next, &pNextNode, &error);

					RELEASE_SPIN_LOCK(&pPortDesc->pd_Lock, OldIrql);
					AtalkNodeDereference(pAtalkNode);
					ACQUIRE_SPIN_LOCK(&pPortDesc->pd_Lock, &OldIrql);

					pAtalkNode = pNextNode;
				}
		
			} while (FALSE);

			RELEASE_SPIN_LOCK(&pPortDesc->pd_Lock, OldIrql);
		}

	} while (FALSE);

	if (ATALK_SUCCESS(error))
	{
		if (ppDdpAddr != NULL)
			*ppDdpAddr = pDdpAddr;
	}
	else
	{
		DBGPRINT(DBG_COMP_DDP, DBG_LEVEL_ERR,
				("AtalkDdpOpenAddress: failed with error %lx\n", error));

		if (pDdpAddr)
			AtalkFreeMemory(pDdpAddr);
	}

	return error;
}




ATALK_ERROR
AtalkDdpCleanupAddress(
	IN	PDDP_ADDROBJ			pDdpAddr
	)
/*++

Routine Description:

	Releases any pending requests on the address.

Arguments:


Return Value:


--*/
{
	KIRQL			OldIrql;

	//	Free all pending ddp reads.
	ACQUIRE_SPIN_LOCK(&pDdpAddr->ddpao_Lock, &OldIrql);

	while (!IsListEmpty(&pDdpAddr->ddpao_ReadLinkage))
	{
		PLIST_ENTRY	p;
		PDDP_READ	pRead;

		p = RemoveHeadList(&pDdpAddr->ddpao_ReadLinkage);
		RELEASE_SPIN_LOCK(&pDdpAddr->ddpao_Lock, OldIrql);

		pRead 	= CONTAINING_RECORD(p, DDP_READ, dr_Linkage);

		(*pRead->dr_RcvCmp)(ATALK_FAILURE,
							pRead->dr_OpBuf,
							0,
							NULL,
							pRead->dr_RcvCtx);

		AtalkDdpDereference(pDdpAddr);
		AtalkFreeMemory(pRead);
		ACQUIRE_SPIN_LOCK(&pDdpAddr->ddpao_Lock, &OldIrql);
	}

	RELEASE_SPIN_LOCK(&pDdpAddr->ddpao_Lock, OldIrql);
	return ATALK_NO_ERROR;
}




ATALK_ERROR
AtalkDdpCloseAddress(
	IN	PDDP_ADDROBJ			pDdpAddr,
	IN	GENERIC_COMPLETION		pCloseCmp	OPTIONAL,	
	IN	PVOID					pCloseCtx	OPTIONAL
	)
/*++

Routine Description:

	Called to close an open ddp address object. This will complete after all
	requests on the object are done/cancelled, and the Appletalk Socket is
	closed.

Arguments:


Return Value:


--*/
{
	KIRQL			OldIrql;
	BOOLEAN			closing;
    BOOLEAN         pnpZombie;


	ASSERT (VALID_DDP_ADDROBJ(pDdpAddr));

	ACQUIRE_SPIN_LOCK(&pDdpAddr->ddpao_Lock, &OldIrql);
	closing = ((pDdpAddr->ddpao_Flags & DDPAO_CLOSING) != 0) ? TRUE : FALSE;
    pnpZombie = ((pDdpAddr->ddpao_Flags & DDPAO_SOCK_PNPZOMBIE) != 0) ? TRUE: FALSE;

	ASSERTMSG("DdpAddr is already closing!\n", ((!closing) || pnpZombie));

	if (!closing)
	{
		//	Set the closing flag and remember the completion routines.
		pDdpAddr->ddpao_Flags |= DDPAO_CLOSING;
		pDdpAddr->ddpao_CloseComp = pCloseCmp;
		pDdpAddr->ddpao_CloseCtx  = pCloseCtx;
	}
	RELEASE_SPIN_LOCK(&pDdpAddr->ddpao_Lock, OldIrql);

	if (!closing)
	{
		//	Release any pending reads
		AtalkDdpCleanupAddress(pDdpAddr);
		AtalkNbpCloseSocket(pDdpAddr);

		//	Remove reference for the creation
		AtalkDdpDereference(pDdpAddr);
	}

    // is this socket in a zombie state?  if so, deref it so it'll get freed
    if (pnpZombie)
    {
        ASSERT(closing == TRUE);

	    DBGPRINT(DBG_COMP_DDP, DBG_LEVEL_ERR,
		    ("AtalkDdpClose..: zombie addr %lx (%lx) deref'ed\n",
            pDdpAddr,pDdpAddr->ddpao_Handler));

        AtalkDdpDereference(pDdpAddr);
    }

	return ATALK_PENDING;
}


ATALK_ERROR
AtalkDdpPnPSuspendAddress(
	IN	PDDP_ADDROBJ			pDdpAddr
	)
/*++

Routine Description:

	Called to "suspend" an open ddp address object. This is called during PnP,
    to "suspend" "external" sockets. The nodes associated with this address are
    released (deref'ed) and this socket is cleaned up but kept around because
    the client might close it.  When the client does close it, it gets freed.

Arguments:


Return Value:


--*/
{
	KIRQL			OldIrql;
    PATALK_NODE     pNode = pDdpAddr->ddpao_Node;
	BOOLEAN			closing;


	ASSERT (VALID_DDP_ADDROBJ(pDdpAddr));

	ACQUIRE_SPIN_LOCK(&pDdpAddr->ddpao_Lock, &OldIrql);
	closing = ((pDdpAddr->ddpao_Flags & DDPAO_CLOSING) != 0) ? TRUE : FALSE;

	ASSERTMSG("DdpAddr is already closing!\n", !closing);

	if (!closing)
	{
		//	Set the closing flag and remember the completion routines.
		pDdpAddr->ddpao_Flags |= DDPAO_CLOSING;

        // this call is only for external sockets
        ASSERT((pDdpAddr->ddpao_Flags & DDPAO_SOCK_INTERNAL) == 0);

        pDdpAddr->ddpao_Flags |= DDPAO_SOCK_PNPZOMBIE;
	}

	RELEASE_SPIN_LOCK(&pDdpAddr->ddpao_Lock, OldIrql);

	if (!closing)
	{
        PDDP_ADDROBJ *  ppDdpAddr;
        int             index;

		//	Release any pending reads
		AtalkDdpCleanupAddress(pDdpAddr);
		AtalkNbpCloseSocket(pDdpAddr);

	    ACQUIRE_SPIN_LOCK(&pNode->an_Lock, &OldIrql);
	
	    index = HASH_ATALK_ADDR(&pDdpAddr->ddpao_Addr) % NODE_DDPAO_HASH_SIZE;

	    for (ppDdpAddr = &pNode->an_DdpAoHash[index];
		     *ppDdpAddr != NULL;
		    ppDdpAddr = &((*ppDdpAddr)->ddpao_Next))
	    {
		    if (*ppDdpAddr == pDdpAddr)
		    {
			    *ppDdpAddr = pDdpAddr->ddpao_Next;

                // to catch weirdnesses!
                pDdpAddr->ddpao_Next = (PDDP_ADDROBJ)0x081294;
			    break;
		    }
	    }

	    RELEASE_SPIN_LOCK(&pNode->an_Lock, OldIrql);

	    if (pDdpAddr->ddpao_EventInfo != NULL)
	    {
		    AtalkFreeMemory(pDdpAddr->ddpao_EventInfo);
            pDdpAddr->ddpao_EventInfo = NULL;
	    }

	    //	Call the completion routines
	    if (pDdpAddr->ddpao_CloseComp != NULL)
	    {
		    (*pDdpAddr->ddpao_CloseComp)(ATALK_NO_ERROR, pDdpAddr->ddpao_CloseCtx);
            pDdpAddr->ddpao_CloseComp = NULL;
	    }

	    //	Dereference the node for this address
	    AtalkNodeDereference(pNode);

	    DBGPRINT(DBG_COMP_DDP, DBG_LEVEL_ERR,
		    ("AtalkDdpPnp..: addr %lx (%lx) put in zombie state\n",
            pDdpAddr,pDdpAddr->ddpao_Handler));
	}

	return ATALK_PENDING;
}



ATALK_ERROR
AtalkDdpInitCloseAddress(
	IN	PPORT_DESCRIPTOR	pPortDesc,
	IN	PATALK_ADDR			pAtalkAddr
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	ATALK_ERROR		error;
	PDDP_ADDROBJ	pDdpAddr;

	//	!!!This should only be called during initialization!!!
	KEVENT	Event	= {0};

	//	Try to see if the socket exists.
	AtalkDdpRefByAddr(pPortDesc, pAtalkAddr, &pDdpAddr, &error);
	if (ATALK_SUCCESS(error))
	{
		ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

		KeInitializeEvent(&Event, NotificationEvent, FALSE);

		//	Call close with the appropriate completion routine.
		error = AtalkDdpCloseAddress(pDdpAddr,
									 atalkDdpInitCloseComplete,
									 (PVOID)&Event);

		//	Remove the reference we added.
		AtalkDdpDereference(pDdpAddr);

		if (error == ATALK_PENDING)
		{
			// 	Wait on event, completion routine will set NdisRequestEvent
			KeWaitForSingleObject(&Event,
								  Executive,
								  KernelMode,
								  TRUE,
								  NULL);

			//	Assume socket closed successfully.
			error = ATALK_NO_ERROR;
		}
	}

	return error;
}




VOID
atalkDdpInitCloseComplete(
	ATALK_ERROR 	Error,
	PVOID			Ctx
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PKEVENT		pEvent = (PKEVENT)Ctx;

	if (!ATALK_SUCCESS(Error))
	{
		DBGPRINT(DBG_COMP_DDP, DBG_LEVEL_INFO,
				("atalkDdpInitCloseComplete: Closed with error %lx\n", Error));
	}

	KeSetEvent(pEvent, 0L, FALSE);
}




ATALK_ERROR
AtalkInitDdpOpenStaticSockets(
	IN		PPORT_DESCRIPTOR		pPortDesc,
	IN	OUT PATALK_NODE				pNode
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PDDP_ADDROBJ	pDdpAddr, pDdpAddr1, pDdpAddr2, pDdpAddr3;
	ATALK_ERROR		error = ATALK_NO_ERROR;

	//	This is called whenever a new node is created.
	do
	{
		error = AtalkDdpOpenAddress(pPortDesc,
									NAMESINFORMATION_SOCKET,
									&pNode->an_NodeAddr,
									AtalkNbpPacketIn,
									NULL,
									DDPPROTO_ANY,		
									NULL,
									&pDdpAddr);
	
		if (!ATALK_SUCCESS(error))
			break;
	
        // mark the fact that this is an "internal" socket
        pDdpAddr->ddpao_Flags |= DDPAO_SOCK_INTERNAL;

		// A lot of devices today work around the fact that a macintosh uses socket 254
		// for lookups from chooser. Agfa is one such beast. To make this work, we reserve
		// this socket for Nbp lookups ourselves.
		error = AtalkDdpOpenAddress(pPortDesc,
									LAST_DYNAMIC_SOCKET,
									&pNode->an_NodeAddr,
									AtalkNbpPacketIn,
									NULL,
									DDPPROTO_ANY,		
									NULL,
									&pDdpAddr1);
	
		if (!ATALK_SUCCESS(error))
		{
			AtalkDdpCloseAddress(pDdpAddr, NULL, NULL);
			break;
		}
	
        // mark the fact that this is an "internal" socket
        pDdpAddr1->ddpao_Flags |= DDPAO_SOCK_INTERNAL;

		error = AtalkDdpOpenAddress(pPortDesc,
									ECHOER_SOCKET,
									&pNode->an_NodeAddr,
									AtalkAepPacketIn,
									NULL,
									DDPPROTO_ANY,		
									NULL,
									&pDdpAddr2);
	
		if (!ATALK_SUCCESS(error))
		{
			AtalkDdpCloseAddress(pDdpAddr, NULL, NULL);
			AtalkDdpCloseAddress(pDdpAddr1, NULL, NULL);
			break;
		}

        // mark the fact that this is an "internal" socket
        pDdpAddr2->ddpao_Flags |= DDPAO_SOCK_INTERNAL;

		//	NOTE: RTMP uses two protocol types.
		error = AtalkDdpOpenAddress(pPortDesc,
									RTMP_SOCKET,
									&pNode->an_NodeAddr,
									AtalkRtmpPacketIn,
									NULL,
									DDPPROTO_ANY,		
									NULL,
									&pDdpAddr3);
	
		if (!ATALK_SUCCESS(error))
		{
			AtalkDdpCloseAddress(pDdpAddr, NULL, NULL);
			AtalkDdpCloseAddress(pDdpAddr1, NULL, NULL);
			AtalkDdpCloseAddress(pDdpAddr2, NULL, NULL);
		}

        // mark the fact that this is an "internal" socket
        pDdpAddr3->ddpao_Flags |= DDPAO_SOCK_INTERNAL;

	} while (FALSE);

	return error;
}


//
//	AtalkDdpReceive()
//	Called by an external caller to the stack.
// 	PAMDL is an Appletalk Memory Descriptor List. On NT, it will be an MDL.
//


ATALK_ERROR
AtalkDdpReceive(
	IN		PDDP_ADDROBJ		pDdpAddr,
	IN		PAMDL				pAmdl,
	IN		USHORT				AmdlLen,
	IN		ULONG				RecvFlags,
	IN		RECEIVE_COMPLETION	pRcvCmp,
	IN		PVOID				pRcvCtx		OPTIONAL
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	ATALK_ERROR		error;
	PDDP_READ		pRead;
	NTSTATUS		status;
	ULONG			bytesCopied;
	ATALK_ADDR		remoteAddr;
	KIRQL			OldIrql;
	BOOLEAN			completeRecv 	= FALSE,
					DerefAddr		= FALSE;
	BOOLEAN			pendingDgram 	= FALSE;

	do
	{
		if (pRcvCmp == NULL)
		{
			error = ATALK_DDP_INVALID_PARAM;
			break;
		}

		AtalkDdpReferenceByPtr(pDdpAddr, &error);
		if (!ATALK_SUCCESS(error))
		{
			break;
		}

		DerefAddr 	= TRUE;
		error		= ATALK_NO_ERROR;

		ACQUIRE_SPIN_LOCK(&pDdpAddr->ddpao_Lock, &OldIrql);
		if (pDdpAddr->ddpao_Flags & DDPAO_DGRAM_PENDING)
		{
			if (AmdlLen < pDdpAddr->ddpao_EventInfo->ev_IndDgramLen)
			{
				error	= ATALK_BUFFER_TOO_SMALL;
			}

			AmdlLen = MIN(AmdlLen, pDdpAddr->ddpao_EventInfo->ev_IndDgramLen);
			status = TdiCopyBufferToMdl(
						pDdpAddr->ddpao_EventInfo->ev_IndDgram,
						0,
						AmdlLen,
						pAmdl,
						0,
						&bytesCopied);

			remoteAddr				= pDdpAddr->ddpao_EventInfo->ev_IndSrc;
			pDdpAddr->ddpao_Flags  &= ~DDPAO_DGRAM_PENDING;
			completeRecv			= TRUE;
		}
		else
		{
			//	This case never really will be executed for non-blocking sockets.
			//	Dont bother about this alloc with spinlock held for now.
			//	RACE CONDITION is with a packet coming in and setting DGRAM_PENDING.
			if ((pRead = AtalkAllocMemory(sizeof(DDP_READ))) == NULL)
			{
				RELEASE_SPIN_LOCK(&pDdpAddr->ddpao_Lock, OldIrql);
				error = ATALK_RESR_MEM;
				break;
			}

			InsertTailList(&pDdpAddr->ddpao_ReadLinkage, &pRead->dr_Linkage);

			DerefAddr = FALSE;
			pRead->dr_OpBuf 	= pAmdl;
			pRead->dr_OpBufLen 	= AmdlLen;
			pRead->dr_RcvCmp 	= pRcvCmp;
			pRead->dr_RcvCtx 	= pRcvCtx;
			error 				= ATALK_PENDING;

		}
		RELEASE_SPIN_LOCK(&pDdpAddr->ddpao_Lock, OldIrql);
	
	} while (FALSE);

	if (completeRecv)
	{
		ASSERT((error == ATALK_NO_ERROR) || (error == ATALK_BUFFER_TOO_SMALL));
		(*pRcvCmp)(error,
				   pAmdl,
				   AmdlLen,
				   &remoteAddr,
				   pRcvCtx);

		//	And return pending for sure!
		error		= ATALK_PENDING;
		DerefAddr	= TRUE;
	}


	if (DerefAddr)
	{
		AtalkDdpDereference(pDdpAddr);
	}

	return error;
}




//
//	DdpSend()
//	This function is used to deliver packets submitted by the ddp clients.
//	The packets are assummed to either be destined for one of the nodes on
//	the port, or need to be routed to another port (if router is on), or to
//	be transmitted onto the physical medium.
//
//	This takes a buffer descriptor as an input. This can contain either a
//	PAMDL or a PBYTE depending on where the data is coming from (user space
//	or router code respectively). In addition, it will take an optional header
//	buffer that will be appended to the ddp header. The buffer descriptor is
//	optional, that if NULL, it will be construed as a zero-length send.
//

ATALK_ERROR
AtalkDdpSend(
	IN	PDDP_ADDROBJ				pDdpAddr,
	IN	PATALK_ADDR					pDestAddr,
	IN	BYTE						Protocol,
	IN	BOOLEAN						DefinitelyRemoteAddr,
	IN	PBUFFER_DESC				pBuffDesc		OPTIONAL,
	IN	PBYTE						pOptHdr			OPTIONAL,
	IN	USHORT						OptHdrLen		OPTIONAL,
	IN	PBYTE						pMcastAddr		OPTIONAL,
	IN	PSEND_COMPL_INFO			pSendInfo		OPTIONAL
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	ATALK_ERROR			error;
	BOOLEAN				shouldBeRouted;
	PPORT_DESCRIPTOR	pPortDesc;
	ATALK_ADDR			srcAddr;
	KIRQL				OldIrql;
	BOOLEAN				delivered 	= FALSE;

	//	NULL buffer descriptor => 0-length send.
	ASSERT((pBuffDesc == NULL) || (pBuffDesc->bd_Length > 0));

#ifdef DDP_STRICT
	//	Check destination address
	if (INVALID_ADDRESS(pDestAddr))
	{
		return ATALK_DDP_INVALID_ADDR;
	}
	
	//	Check the datagram length.
	if (pBuffDesc)
	{
		USHORT	dgramLen;

		AtalkSizeOfBuffDescData(pBuffDesc, &dgramLen);
		if (dgramLen > MAX_DGRAM_SIZE)
		{
			return ATALK_BUFFER_TOO_BIG;
		}
	}
#endif

    //
    // if this socket is in a zombie state (pnp changes are over) then reject
    // this send
    //
    if (pDdpAddr->ddpao_Flags & DDPAO_SOCK_PNPZOMBIE)
    {
		return ATALK_DDP_INVALID_ADDR;
    }

	//	Get a pointer to the port on which the socket exists.
	pPortDesc = pDdpAddr->ddpao_Node->an_Port;

	//	Get the source address
	srcAddr = pDdpAddr->ddpao_Addr;

	if (!DefinitelyRemoteAddr)
	{
		// All socket handlers assume that they are called at DISPACTH. Make it so.
		KeRaiseIrql(DISPATCH_LEVEL, &OldIrql);

		AtalkDdpOutBufToNodesOnPort(pPortDesc,
									&srcAddr,
									pDestAddr,
									Protocol,
									pBuffDesc,
									pOptHdr,
									OptHdrLen,
									&delivered);
		KeLowerIrql(OldIrql);

		if (delivered)
		{
			//	Ok, packet meant for one of our own nodes on this port,
			//	and we delivered it. Call the completion routine.
	
			if (pSendInfo != NULL)
			{
				(*pSendInfo->sc_TransmitCompletion)(NDIS_STATUS_SUCCESS, pSendInfo);
			}
			return ATALK_PENDING;
		}
	}

	ASSERT (!delivered);

	//	Can our router handle it?
	shouldBeRouted = ((pPortDesc->pd_Flags & PD_ROUTER_RUNNING)					&&
					  (pDestAddr->ata_Network != CABLEWIDE_BROADCAST_NETWORK)	&&
					  !(WITHIN_NETWORK_RANGE(pDestAddr->ata_Network,
											 &pPortDesc->pd_NetworkRange))		&&
					  !(WITHIN_NETWORK_RANGE(pDestAddr->ata_Network,
											 &AtalkStartupNetworkRange)));

	DBGPRINT(DBG_COMP_DDP, DBG_LEVEL_INFO,
			("AtalkDdpSend: destNet %lx shouldBeRouted %s\n",
			pDestAddr->ata_Network, shouldBeRouted ? "Yes" : "No"));

	if (shouldBeRouted)
	{
		ASSERT (!((WITHIN_NETWORK_RANGE(pDestAddr->ata_Network, &pPortDesc->pd_NetworkRange)) &&
				  (pDestAddr->ata_Node == ATALK_BROADCAST_NODE)));

		//	If we're a router and the packet isn't destined for the target ports
		//	local network, let our router handle it -- rather than sending to
		//	whatever the "best router" is or to "a router".
		do
		{
			// This algorithm is taken from the "Appletalk Phase 2 Specification".
		
			// If the destination network number is within the range of the reception
			// port's network range and the destination node number is broadcast, then
			// we can drop the packet on the floor -- it is a network specific broadcast
			// not for this router.  Note that we've already delivered the packet, and
			// thus not gotten here, if it was really addressed to the network of any
			// node owned by the reception port (in AtalkDdpPacketIn).
			// Also:
			// Try to find an entry in the routing table that contains the target
			// network.  If not found, discard the packet.

			PDDP_ADDROBJ		pRouteDdpAddr;
			PRTE				pRte;
			PPORT_DESCRIPTOR	pDestPortDesc;
			PATALK_NODE			pRouterNode;
			ATALK_ADDR			actualDest;
		
			if ((pRte = AtalkRtmpReferenceRte(pDestAddr->ata_Network)) == NULL)
			{
				DBGPRINT(DBG_COMP_ROUTER, DBG_LEVEL_FATAL,
						("AtalkDdpRouter: %lx RtmpRte/Not in ThisCableRange\n",
						pDestAddr->ata_Network));
		
				error = ATALK_RESR_MEM;
				break;
			}
		
			do
			{
				//	Get the port descriptor corres. to the RTE
				pDestPortDesc = pRte->rte_PortDesc;
		
				ASSERT(VALID_PORT(pDestPortDesc));
		
				//	If the target network's hop count is non-zero, we really need to send
				//	the beast, so, just do it!
				if (pRte->rte_NumHops != 0)
				{
					//	Too many hops?
					error = AtalkDdpTransmit(pDestPortDesc,
											 &srcAddr,
											 pDestAddr,
											 Protocol,
											 pBuffDesc,
											 pOptHdr,
											 OptHdrLen,
											 1,						//	HopCount
											 NULL,					//	pZoneMcastAddr
											 &pRte->rte_NextRouter,
											 pSendInfo);
					break;
				}
				
				//	If the destination node is zero, the packet is really destined for the
				//	router's node on this port.
				if (pDestAddr->ata_Node == ANY_ROUTER_NODE)
				{
					//	Try to reference this port, if not successful, its probably
					//	closing down. Grab the port lock and read the router node address.
					//	No need to reference, just ensure its not null.
					ACQUIRE_SPIN_LOCK(&pDestPortDesc->pd_Lock, &OldIrql);
		
					if ((pDestPortDesc->pd_Flags & PD_CLOSING) == 0)
					{
						ASSERT(pDestPortDesc->pd_RefCount > 0);
						pDestPortDesc->pd_RefCount++;
					}
					else
					{
						ASSERTMSG("AtalkDdpRouter: Could not ref port!\n", 0);
						error = ATALK_PORT_CLOSING;
						RELEASE_SPIN_LOCK(&pDestPortDesc->pd_Lock, OldIrql);
						break;
					}
		
					pRouterNode = pDestPortDesc->pd_RouterNode;
					if (pRouterNode != NULL)
					{
						actualDest.ata_Network = pRouterNode->an_NodeAddr.atn_Network;
						actualDest.ata_Node    = pRouterNode->an_NodeAddr.atn_Node;
		
						//	Set the actual destination socket.
						actualDest.ata_Socket  = pDestAddr->ata_Socket;
					}
					else
					{
						ASSERTMSG("AtalkDdpRouter: pRouter node is null!\n", 0);
						error = ATALK_DDP_NOTFOUND;
					}
		
					if (ATALK_SUCCESS(error))
					{
						AtalkDdpRefByAddrNode(pDestPortDesc,
											  &actualDest,
											  pRouterNode,
											  &pRouteDdpAddr,
											  &error);
					}
		
					RELEASE_SPIN_LOCK(&pDestPortDesc->pd_Lock, OldIrql);
		
					if (ATALK_SUCCESS(error))
					{
						KIRQL	OldIrql;

						// Socket handlers assume that they are called at DISPATCH. Make it so.
						KeRaiseIrql(DISPATCH_LEVEL, &OldIrql);

						AtalkDdpInvokeHandlerBufDesc(pDestPortDesc,
													 pRouteDdpAddr,
													 &srcAddr,
													 pDestAddr,		// Pass in the actual destination
													 Protocol,
													 pBuffDesc,
													 pOptHdr,
													 OptHdrLen);
		
						//	Remove the reference on the socket
						AtalkDdpDereferenceDpc(pRouteDdpAddr);

						KeLowerIrql(OldIrql);
					}
					else
					{
						ASSERTMSG("AtalkDdpRouter: pSocket on router node is null!\n", 0);
					}
					break;
				}
		
				//	Okay, now walk through the nodes on the target port, looking for a
				//	home for this packet.
				if (!DefinitelyRemoteAddr)
				{
					// All socket handlers assume that they are called at DISPACTH. Make it so.
					KeRaiseIrql(DISPATCH_LEVEL, &OldIrql);

					AtalkDdpOutBufToNodesOnPort(pDestPortDesc,
												&srcAddr,
												pDestAddr,
												Protocol,
												pBuffDesc,
												pOptHdr,
												OptHdrLen,
												&delivered);
					KeLowerIrql(OldIrql);

					if (delivered)
					{
			            if (pSendInfo != NULL)
			            {
				            (*pSendInfo->sc_TransmitCompletion)(NDIS_STATUS_SUCCESS, pSendInfo);
			            }
						error = ATALK_NO_ERROR;
						break;
					}
				}
			
				//	We need to deliver this packet to a local ports network.
				error = AtalkDdpTransmit(pDestPortDesc,
										 &srcAddr,
										 pDestAddr,
										 Protocol,
										 pBuffDesc,
										 pOptHdr,
										 OptHdrLen,
										 1,						//	HopCount
										 NULL,					//	pZoneMcastAddr,
										 NULL,	
										 pSendInfo);
			} while (FALSE);
		
			INTERLOCKED_INCREMENT_LONG_DPC(
					&pDestPortDesc->pd_PortStats.prtst_NumPktRoutedOut,
					&AtalkStatsLock.SpinLock);
		
			AtalkRtmpDereferenceRte(pRte, FALSE);				// Lock held?
		} while (FALSE);

		INTERLOCKED_INCREMENT_LONG_DPC(
			&pPortDesc->pd_PortStats.prtst_NumPktRoutedIn,
			&AtalkStatsLock.SpinLock);
	}
	else
	{
		error = AtalkDdpTransmit(pPortDesc,
								 &srcAddr,
								 pDestAddr,
								 Protocol,
								 pBuffDesc,
								 pOptHdr,
								 OptHdrLen,
								 0,					//	HopCnt,
								 pMcastAddr,
								 NULL,				//	pXmitDestNode,
								 pSendInfo);
	}

	return error;
}


//
//	DdpTransmit()
//	This function is called to build the headers for the packet and send it
//	out via the depend level functions. It is assumed at this point that the
//	packet is destined for nodes not currently controlled by this stack.
//
//	KnownMulticastAddress: Although the DDP destination is encoded using
//	'Destination', if this parameter is non-null, the packet is actually
//	sent to this address.
//
//	TransmitDestination: Again, as above, the router uses this to pass on the
//	packet to the next router it needs to go to, if 'Destination' is still one
//	or more hops away.
//
//	This is only called from within ddp send or by the router code (rtmp/zip/router).
//

ATALK_ERROR
AtalkDdpTransmit(
	IN	PPORT_DESCRIPTOR			pPortDesc,
	IN	PATALK_ADDR					pSrcAddr,
	IN	PATALK_ADDR					pDestAddr,
	IN	BYTE						Protocol,
	IN	PBUFFER_DESC				pBuffDesc		OPTIONAL,
	IN	PBYTE						pOptHdr			OPTIONAL,
	IN	USHORT						OptHdrLen		OPTIONAL,
	IN	USHORT						HopCnt,
	IN	PBYTE						pMcastAddr		OPTIONAL,	
	IN	PATALK_NODEADDR				pXmitDestNode	OPTIONAL,
	IN	PSEND_COMPL_INFO			pSendInfo		OPTIONAL
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PBYTE			pDgram, pDgramStart, pLinkDdpOptHdr;
	PBUFFER_DESC	pPktDesc;
	USHORT			linkLen;
	ATALK_NODEADDR	srcNode;
	ATALK_NODEADDR	destNode;
	USHORT			actualLength;
	ATALK_NODEADDR	actualDest;
	PBUFFER_DESC	probe;
	PBRE			routerNode;
	USHORT			bufLen				= 0;
	USHORT			checksum 			= 0;
	PBYTE			knownAddress 		= NULL;
	PBYTE			knownRouteInfo 		= NULL;
	USHORT	   		knownRouteInfoLen 	= 0;
	BOOLEAN			broadcast 			= FALSE;
	ATALK_ERROR		error 				= ATALK_NO_ERROR;
	BOOLEAN			shortDdpHeader		= FALSE;
	BOOLEAN			errorFreePkt		= FALSE;
    PARAPCONN       pArapConn           = NULL;
    PATCPCONN       pAtcpConn           = NULL;
    DWORD           StatusCode;
    DWORD           dwFlags;
    USHORT          SrpLen;
    PBYTE           pTmpPtr;
    NDIS_STATUS     status;
    BOOLEAN         fThisIsPPP;
    PVOID           pRasConn;


	//
	// The basic transmit algorithum is:
	//
	//	   if (non-extended-network)
	//	   {
	//			if ((destination-network is 0 or
	//				 destination-network is NetworkRange.firstNetwork) and
	//				(source-network is 0 or
	//				 source-network is NetworkRange.firstNetwork))
	//			{
	//				 <send short form DDP packet to local network>
	//				 return-okay
	//			}
	//	   }
	//	   if (destination-network is CableWideBroadcastNetworkNumber or
	//		   destination-network in NetworkRange or
	//		   destination-network in SartupRange or
	//	   {
	//			<send long form DDP packet to local network>
	//			return-okay
	//	   }
	//	   if (destination-network-and-node in best-router-cache)
	//	   {
	//			<send long form DDP packet to best router>
	//			return-okay
	//	   }
	//	   if (seen-a-router-recently)
	//	   {
	//			<send long form DDP packet to a-router>
	//			return-okay
	//	   }
	//	   return-error
	
	destNode.atn_Network = pDestAddr->ata_Network;
	destNode.atn_Node = pDestAddr->ata_Node;
	actualDest.atn_Network = UNKNOWN_NETWORK;
	actualDest.atn_Node = UNKNOWN_NODE;

	do
	{
		if (pBuffDesc != NULL)
		{
			//	Get the buffer length. Check the datagram length.
			AtalkSizeOfBuffDescData(pBuffDesc, &bufLen);
			ASSERT(bufLen > 0);
		}

#ifdef DDP_STRICT
		//	Check destination address
		if (INVALID_ADDRESS(pDestAddr) || INVALID_ADDRESS(pSrcAddr))
		{
			error = ATALK_DDP_INVALID_ADDR;
			break;
		}
	
		if (pBuffDesc != NULL)
		{
			//	Ensure we do not have a chained datagram.
			if (pBuffDesc->bd_Next != NULL)
			{
				KeBugCheck(0);
			}

			if (bufLen > MAX_DGRAM_SIZE)
			{
				error = ATALK_BUFFER_TOO_BIG;
				break;
			}
		}

		if (OptHdrLen > MAX_OPTHDR_LEN)
		{
			error = ATALK_BUFFER_TOO_BIG;
			break;
		}
#endif

        //
        // is the desination one of our dial-in clients?
        //
        pRasConn = FindAndRefRasConnByAddr(destNode, &dwFlags, &fThisIsPPP);

        if ((pRasConn == NULL) && (pPortDesc->pd_Flags & PD_RAS_PORT))
        {
			DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
					("AtalkDdpTransmit: pArapConn is NULL! Network, Node = %lx %lx\n",
					pDestAddr->ata_Network,pDestAddr->ata_Node));

			error = ATALK_FAILURE;
			break;
        }

        pArapConn = NULL;
        pAtcpConn = NULL;

        // if this is a dial-in client, see if it's PPP or ARAP
        if (pRasConn)
        {
            if (fThisIsPPP)
            {
                pAtcpConn = (PATCPCONN)pRasConn;

                // we can send only if the PPP connection is up
                if (!(dwFlags & ATCP_CONNECTION_UP))
                {
                    DerefPPPConn(pAtcpConn);
                    pAtcpConn = NULL;
                }
            }
            else
            {
                pArapConn = (PARAPCONN)pRasConn;
            }
        }

        //
        // if the destination is a dial-in client, we have more work to do
        //

        // PPP client?
        if (pAtcpConn != NULL)
        {
			//	the buffer that will hold both the link and ddp hdrs.
			shortDdpHeader	= FALSE;

			AtalkNdisAllocBuf(&pPktDesc);
			if (pPktDesc == NULL)
			{
				error = ATALK_FAILURE;
				break;
			}

			//	In cases of error, free the allocated packet.
			errorFreePkt = TRUE;

			actualLength 		= bufLen + LDDP_HDR_LEN + OptHdrLen;
			pLinkDdpOptHdr		= pPktDesc->bd_CharBuffer;

            AtalkNdisBuildPPPPHdr(pLinkDdpOptHdr, pAtcpConn);
            linkLen = WAN_LINKHDR_LEN;

            break;
        }

        // nope, ARAP client?
        else if ( pArapConn != NULL )
        {
			shortDdpHeader	= FALSE;          // ARAP mandates always long form

			AtalkNdisAllocBuf(&pPktDesc);
			if (pPktDesc == NULL)
			{
				error = ATALK_FAILURE;
				break;
			}

			//	In cases of error, free the allocated packet.
			errorFreePkt = TRUE;

			actualLength = bufLen + LDDP_HDR_LEN + OptHdrLen;
			pLinkDdpOptHdr = pTmpPtr = pPktDesc->bd_CharBuffer;

			linkLen	= ARAP_LAP_HDRSIZE + ARAP_HDRSIZE;

            // don't count the 2 length bytes
            SrpLen = actualLength + linkLen - sizeof(USHORT);

            //
            // put the 2 SRP bytes and the 1 byte DGroup flag (we have enough room)
            //
            PUTSHORT2SHORT(pTmpPtr, SrpLen);
            pTmpPtr += sizeof(USHORT);

            // the Dgroup byte
            *pTmpPtr++ = (ARAP_SFLAG_PKT_DATA | ARAP_SFLAG_LAST_GROUP);

            // the LAP hdr
            *pTmpPtr++ = 0;
            *pTmpPtr++ = 0;
            *pTmpPtr++ = 2;

            break;
        }

		//	For non-extended networks, we may want to send a short DDP header.
		if (!(EXT_NET(pPortDesc)) &&
			((pDestAddr->ata_Network == UNKNOWN_NETWORK) ||
			 (pDestAddr->ata_Network == pPortDesc->pd_NetworkRange.anr_FirstNetwork)) &&
			((pSrcAddr->ata_Network == UNKNOWN_NETWORK) ||
			 (pSrcAddr->ata_Network == pPortDesc->pd_NetworkRange.anr_FirstNetwork)))
		{
			//	Use a short ddp header. Call the port handler to first alloc
			//	the buffer that will hold both the link and ddp hdrs.
			shortDdpHeader	= TRUE;
			AtalkNdisAllocBuf(&pPktDesc);
			if (pPktDesc == NULL)
			{
				error = ATALK_FAILURE;
				break;
			}

			//	In cases of error, free the allocated packet.
			errorFreePkt = TRUE;

			//	pPkt will be the beginning of the packet and pDgram is where
			//	we fill in the ddp header.
			actualLength 		= bufLen + SDDP_HDR_LEN + OptHdrLen;
			pLinkDdpOptHdr		= pPktDesc->bd_CharBuffer;
			linkLen				= 0;
		
			ASSERT (pPortDesc->pd_NdisPortType == NdisMediumLocalTalk);

			//	Build the LAP header. This will build it from pDgram backwards,
			//	and set the pPkt pointer as the packet to be freed in the
			//	built buffer descriptor.
			linkLen = AtalkNdisBuildLTHdr(pLinkDdpOptHdr,
										  &pDestAddr->ata_Node,
										  pSrcAddr->ata_Node,
										  ALAP_SDDP_HDR_TYPE);
	
			DBGPRINT(DBG_COMP_DDP, DBG_LEVEL_INFO,
					("AtalkDdpTransmit: Sending short hdr on non-ext net! %ld\n",
					pDestAddr->ata_Node, pDestAddr->ata_Network));
			break;
		}

		//	LONG DDP HEADER
		// 	Compute the extended AppleTalk node number that we'll really need to
		//  send the packet to.

		DBGPRINT(DBG_COMP_DDP, DBG_LEVEL_INFO,
				("AtalkDdpTransmit: Building a long ddp header for bufdesc %lx on port %lx\n",
				pBuffDesc, pPortDesc));

		do
		{
			if (pMcastAddr != NULL)
			{
				knownAddress = pMcastAddr ;
				break;
			}

			if (pXmitDestNode != NULL)
			{
				actualDest = *pXmitDestNode;
				break;
			}

			if ((WITHIN_NETWORK_RANGE(pDestAddr->ata_Network,
									  &pPortDesc->pd_NetworkRange))	 ||
				(pDestAddr->ata_Network == CABLEWIDE_BROADCAST_NETWORK) ||
				(WITHIN_NETWORK_RANGE(pDestAddr->ata_Network,
									  &AtalkStartupNetworkRange)))
			{
				actualDest.atn_Node = pDestAddr->ata_Node;
				actualDest.atn_Network = pDestAddr->ata_Network;
				broadcast = (pDestAddr->ata_Node == ATALK_BROADCAST_NODE);
				break;
			}

			atalkDdpFindInBrc(pPortDesc, destNode.atn_Network, &routerNode);
			if (routerNode != NULL)
			{
				// Okay, we know where to go.
				knownAddress 		= routerNode->bre_RouterAddr;
				knownRouteInfo 		= (PBYTE)routerNode + sizeof(BRE);
				knownRouteInfoLen 	= routerNode->bre_RouteInfoLen;
				break;
			}

			if (pPortDesc->pd_Flags & PD_SEEN_ROUTER_RECENTLY)
			{
				actualDest = pPortDesc->pd_ARouter;
				break;
			}

			//	No router known. What do we do ? If its not an extended net,
			//  just send it - else return error.
			if (EXT_NET(pPortDesc))
			{
				error = ATALK_DDP_NO_ROUTER;
				break;
			}
			actualDest.atn_Node = pDestAddr->ata_Node;
			actualDest.atn_Network = pDestAddr->ata_Network;
			broadcast = (pDestAddr->ata_Node == ATALK_BROADCAST_NODE);
		} while (FALSE);

		if (error != ATALK_NO_ERROR)
		{
			break;
		}

		AtalkNdisAllocBuf(&pPktDesc);
		if (pPktDesc == NULL)
		{
			error = ATALK_FAILURE;
			break;
		}

		//	In cases of error, free the allocated packet.
		errorFreePkt = TRUE;

		pLinkDdpOptHdr		= pPktDesc->bd_CharBuffer;
		linkLen				= 0;
		actualLength 		= bufLen + LDDP_HDR_LEN + OptHdrLen;
	
		//	If we already know where we're headed, just blast it out.  Also,
		//	if we're broadcasting, just do it.  "knownAddress" will be NULL
		//	if we're broadcasting and that will cause the BuildHeader to make
		//	a broadcast packet.
		
		if (EXT_NET(pPortDesc) &&
			((knownAddress != NULL) ||
			  broadcast				||
			 (actualDest.atn_Network == CABLEWIDE_BROADCAST_NETWORK)))
		{
			//	Build the LAP header.
			AtalkNdisBuildHdr(pPortDesc,
							  pLinkDdpOptHdr,
							  linkLen,
							  actualLength,
							  knownAddress,
							  knownRouteInfo,
							  knownRouteInfoLen,
							  APPLETALK_PROTOCOL);
			break;
		}

		//	On non-extended networks, just send the packet to the desired node --
		//	no AARP games here.
		if (!EXT_NET(pPortDesc))
		{
			DBGPRINT(DBG_COMP_DDP, DBG_LEVEL_INFO,
					("AtalkDdpTransmit: Sending long hdr on non-ext net! %ld\n",
					actualDest.atn_Network, actualDest.atn_Node));
			
			ASSERT (pPortDesc->pd_NdisPortType == NdisMediumLocalTalk);

			linkLen = AtalkNdisBuildLTHdr(pLinkDdpOptHdr,
										  &actualDest.atn_Node,
										  pSrcAddr->ata_Node,
										  ALAP_LDDP_HDR_TYPE);
			break;
		}
	
		//	We're sending to a particular node on an extended network.
		//	Do we know its hardware address ? If so, send it out.
		{
			KIRQL		OldIrql;
			USHORT		index;
			PAMT		pAmt;
		
			//	Go through the AMT and find the entry for the destination
			//	address if present.
			index = HASH_ATALK_NODE(&actualDest) % PORT_AMT_HASH_SIZE;
		
			ACQUIRE_SPIN_LOCK(&pPortDesc->pd_Lock, &OldIrql);
			
			for (pAmt = pPortDesc->pd_Amt[index];
				 pAmt != NULL;
				 pAmt = pAmt->amt_Next)
			{
				if (ATALK_NODES_EQUAL(&pAmt->amt_Target, &actualDest))
				{
					ASSERT(EXT_NET(pPortDesc));
					AtalkNdisBuildHdr(pPortDesc,
									  pLinkDdpOptHdr,
									  linkLen,
									  actualLength,
									  pAmt->amt_HardwareAddr,
									  (PBYTE)pAmt+sizeof(AMT),
									  pAmt->amt_RouteInfoLen,
									  APPLETALK_PROTOCOL);
					error = ATALK_NO_ERROR;
					break;
				}
			}
		
			RELEASE_SPIN_LOCK(&pPortDesc->pd_Lock, OldIrql);

			if (pAmt == NULL)
			{
				DBGPRINT(DBG_COMP_AARP, DBG_LEVEL_WARN,
						("atalkDdpFindInAmt: Could not find %lx.%lx\n",
						actualDest.atn_Network, actualDest.atn_Node));
				error = ATALK_DDP_NO_AMT_ENTRY;
			}
			else break;				// Found the actual h/w address we want to go to.
		}

		//	Free up the allocated header buffer.
		errorFreePkt = TRUE;

		ASSERT(!ATALK_SUCCESS(error));

		//	We dont have the hardware address for the logical address that we
		//	need to send the packet to. Send out aarp requests and drop this packet.
		//	The higher layers can retry later if they have to.
		srcNode.atn_Network = pSrcAddr->ata_Network;
		srcNode.atn_Node	= pSrcAddr->ata_Node;

		probe = BUILD_AARPREQUEST(pPortDesc,
								  MAX_HW_ADDR_LEN,
								  srcNode,
								  actualDest);

		if (probe != NULL)
		{
#ifdef	PROFILING
			INTERLOCKED_INCREMENT_LONG(
				&pPortDesc->pd_PortStats.prtst_NumAarpProbesOut,
				&AtalkStatsLock.SpinLock);
#endif

			//	Send the aarp packet.
			error = AtalkNdisSendPacket(pPortDesc,
										probe,
										AtalkAarpSendComplete,
										NULL);
		
			if (!ATALK_SUCCESS(error))
			{
				TMPLOGERR()
				AtalkAarpSendComplete(NDIS_STATUS_FAILURE,
									  probe,
									  NULL);
			}
		}

		DBGPRINT(DBG_COMP_DDP, DBG_LEVEL_WARN,
				("AMT Entry not found for %lx.%lx\n",
				pDestAddr->ata_Network, pDestAddr->ata_Node));

		error = ATALK_DDP_NO_AMT_ENTRY;
		break;

	} while (FALSE);

	//	Do we need to send the packet?
	if (ATALK_SUCCESS(error))
	{
		ASSERT(HopCnt <= RTMP_MAX_HOPS);

		//	Remember the beginning of the dgram
		pDgramStart = pDgram = pLinkDdpOptHdr + linkLen;

		if (!shortDdpHeader)
		{

			*pDgram++ = (DDP_HOP_COUNT(HopCnt) + DDP_MSB_LEN(actualLength));
		
			PUTSHORT2BYTE(pDgram, actualLength);
			pDgram++;
	
			ASSERT(checksum == 0);
			PUTSHORT2SHORT(pDgram, checksum);
			pDgram += sizeof(USHORT);
		
			PUTSHORT2SHORT(pDgram, pDestAddr->ata_Network);
			pDgram += sizeof(USHORT);
		
			PUTSHORT2SHORT(pDgram, pSrcAddr->ata_Network);
			pDgram += sizeof(USHORT);
		
			*pDgram++ = pDestAddr->ata_Node;
			*pDgram++ = pSrcAddr->ata_Node;
			*pDgram++ = pDestAddr->ata_Socket;
			*pDgram++ = pSrcAddr->ata_Socket;
			*pDgram++ = Protocol;
	
			//	Copy the optional header if present
			if (OptHdrLen > 0)
			{
				ASSERT(pOptHdr != NULL);
				RtlCopyMemory(pDgram, pOptHdr, OptHdrLen);
			}
	
			//	Set length in the buffer descriptor.
			AtalkSetSizeOfBuffDescData(pPktDesc,
									   linkLen + LDDP_HDR_LEN + OptHdrLen);
		}
		else
		{
			*pDgram++ 	= DDP_MSB_LEN(actualLength);

			PUTSHORT2BYTE(pDgram, actualLength);
			pDgram++;
	
			*pDgram++ = pDestAddr->ata_Socket;
			*pDgram++ = pSrcAddr->ata_Socket;
			*pDgram++ = Protocol;
	
			//	Copy the optional header if present
			if (OptHdrLen > 0)
			{
				ASSERT(pOptHdr != NULL);
				RtlCopyMemory(pDgram, pOptHdr, OptHdrLen);
			}

			//	Set length in the buffer descriptor.
			AtalkSetSizeOfBuffDescData(pPktDesc,
									   linkLen + SDDP_HDR_LEN + OptHdrLen);
		}

		//	Chain the passed in buffer desc onto the tail of the one
		//	returned above.
		AtalkPrependBuffDesc(pPktDesc, pBuffDesc);

		//	Okay, set checksum if needed.
		if (pPortDesc->pd_Flags & PD_SEND_CHECKSUMS)
		{
			// 	Temporary skip over the leading unchecksumed bytes.
			checksum = AtalkDdpCheckSumBufferDesc(pPktDesc,
												  (USHORT)(linkLen + LEADING_UNCHECKSUMED_BYTES));
									

			DBGPRINT(DBG_COMP_DDP, DBG_LEVEL_INFO,
					("AtalkDdpTransmit: checksum %lx\n", checksum));

			PUTSHORT2SHORT(&pDgramStart[LDDP_CHECKSUM_OFFSET], checksum);
		}
		
		INTERLOCKED_ADD_STATISTICS(&pPortDesc->pd_PortStats.prtst_DataOut,
								   AtalkSizeBuffDesc(pPktDesc),
								   &AtalkStatsLock.SpinLock);

        //
        // is this packet going to an Arap client?  If so, we may need to compress,
        // and do other processing
        //
        if (pArapConn)
        {
            StatusCode =  ArapSendPrepare( pArapConn,
                                           pPktDesc,
                                           ARAP_SEND_PRIORITY_HIGH );

            if (StatusCode == ARAPERR_NO_ERROR)
            {
		        //	Send the packet(s)
                ArapNdisSend(pArapConn, &pArapConn->HighPriSendQ);

                status = NDIS_STATUS_SUCCESS;
            }
            else
            {
                status = NDIS_STATUS_FAILURE;
            }

			AtalkDdpSendComplete(status, pPktDesc, pSendInfo);

			//	Return pending here
			error = ATALK_PENDING;
        }
        else
        {
            // PPP packets need to go over the RAS port
            if (pAtcpConn)
            {
                pPortDesc = RasPortDesc;
            }

		    //	Send the packet.  The completion routine will handle freeing
            // the buffer chain.
		    error = AtalkNdisSendPacket(pPortDesc,
			    						pPktDesc,
				    					AtalkDdpSendComplete,
					    				pSendInfo);
			
		    if (!ATALK_SUCCESS(error))
		    {
                DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
	                ("AtalkDdpTransmit: AtalkNdisSendPacket failed %ld\n",error));

			    AtalkDdpSendComplete(NDIS_STATUS_FAILURE,
				    				 pPktDesc,
					    			 pSendInfo);

			    //	Return pending. We've alredy called the completion
			    //	routine here, which will have called the callers
			    //	completion routine.
			    error = ATALK_PENDING;
		    }
        }
	}

    // Ras connection? remove the refcount put by FindAndRefRasConnByAddr
    if (pAtcpConn)
    {
        DerefPPPConn(pAtcpConn);
    }
    else if (pArapConn)
    {
        DerefArapConn(pArapConn);
    }

	//	Do we need to free the allocated header packet?
	if (!ATALK_SUCCESS(error) && (errorFreePkt))
	{
		AtalkNdisFreeBuf(pPktDesc);
	}

	return error;
}



VOID
AtalkDdpSendComplete(
	NDIS_STATUS				Status,
	PBUFFER_DESC			pBuffDesc,
	PSEND_COMPL_INFO		pInfo
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	//	Free up the buffer descriptor for the first part
	//	and call the specified completion. One of the contexts
	//	should be the remaining part of the buffer descriptor
	//	chain.

	//	There will always be atleast the ddp header, although the next
	//	part could be null. Thats upto the completion routine to care
	//	about.

	ASSERT(pBuffDesc != NULL);
	pBuffDesc->bd_Next = NULL;

	ASSERT(pBuffDesc->bd_Flags & BD_CHAR_BUFFER);
	AtalkNdisFreeBuf(pBuffDesc);

	//	If null, just return.
	if (pInfo != NULL)
	{
		//	Call the completion routine for the transmit if present
		if (pInfo->sc_TransmitCompletion)
			(pInfo->sc_TransmitCompletion)(Status, pInfo);
	}
}
	
VOID
AtalkDdpInvokeHandlerBufDesc(
	IN		PPORT_DESCRIPTOR	pPortDesc,
	IN		PDDP_ADDROBJ		pDdpAddr,
	IN		PATALK_ADDR			pSrc,
	IN		PATALK_ADDR			pDest,
	IN		BYTE				Protocol,
	IN		PBUFFER_DESC		pBuffDesc		OPTIONAL,
	IN		PBYTE				pOptHdr			OPTIONAL,
	IN		USHORT				OptHdrLen		OPTIONAL
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	USHORT			pktLen	= 0;
	PBYTE			pPkt	= NULL;
	BOOLEAN			freePkt = FALSE;

	//	This is only called from directly or indirectly throught
	//	the router in AtalkDdpSend. Both of these cases indicate
	//	that we have completion routines to deal with. We just make
	//	a copy and assume caller will deal with its buffer descriptor.


	//	Alloc and copy the buffer descriptor data into pPkt.
	//	optimization: If the buffer descriptor is not a chain
	//				  and contains a PBYTE and OptHdrLen = 0,
	//				  then pass that directly.
	//				  Or if buffer descriptor is NULL indicating 0-length
	//				  sends.

	do
	{
		if ((pBuffDesc != NULL) &&
			(pBuffDesc->bd_Next == NULL) &&
			(pBuffDesc->bd_Flags & BD_CHAR_BUFFER) &&
			(OptHdrLen == 0))
		{
			DBGPRINT(DBG_COMP_DDP, DBG_LEVEL_INFO,
					("AtalkDdpInvokeHandlerBufDesc: one element, opt hdr null %ld\n",
					pBuffDesc->bd_Length));
	
			pPkt 	= pBuffDesc->bd_CharBuffer;
			pktLen 	= pBuffDesc->bd_Length;
		}
		else if ((pBuffDesc != NULL) || (OptHdrLen != 0))
		{
			//	Make a copy! Either the buffer descriptor of the Optional Header
			//	is non null. Or both or non-null.
			if (pBuffDesc != NULL)
			{
				AtalkSizeOfBuffDescData(pBuffDesc, &pktLen);
				ASSERT(pktLen > 0);
			}
	
			//	Add the optHdrLen
			pktLen += OptHdrLen;
	
			DBGPRINT(DBG_COMP_DDP, DBG_LEVEL_INFO,
					("AtalkDdpInvokeHandlerBufDesc: Size (incl opt hdr len) %ld\n",
					pktLen));
	
			if ((pPkt = AtalkAllocMemory(pktLen)) != NULL)
			{
				//	First copy the OptHdr if present
				if (pOptHdr != NULL)
				{
					RtlCopyMemory(pPkt, pOptHdr, OptHdrLen);
				}

				if (pBuffDesc != NULL)
				{
					AtalkCopyBuffDescToBuffer(pBuffDesc,
											  0,						// SrcOff
											  pktLen - OptHdrLen,
											  pPkt + OptHdrLen);
				}

				freePkt = TRUE;
			}
			else
			{
				break;
			}
		}
		else
		{
			ASSERT((pBuffDesc == NULL) && (OptHdrLen == 0));
			ASSERT(pPkt == NULL);
			ASSERT(pktLen == 0);
		}
	
		AtalkDdpInvokeHandler(pPortDesc,
							  pDdpAddr,
							  pSrc,
							  pDest,
							  Protocol,
							  pPkt,
							  pktLen);

	} while (FALSE);

	if (freePkt)
	{
        AtalkFreeMemory(pPkt);
	}
}




VOID
AtalkDdpInvokeHandler(
	IN		PPORT_DESCRIPTOR	pPortDesc,
	IN		PDDP_ADDROBJ		pDdpAddr,
	IN		PATALK_ADDR			pSrc,
	IN		PATALK_ADDR			pDest,
	IN		BYTE				Protocol,
	IN		PBYTE				pPkt		OPTIONAL,
	IN		USHORT				PktLen		OPTIONAL
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PLIST_ENTRY	p;
	PDDP_READ	pRead;
	NTSTATUS	status;
	ATALK_ERROR	error;
	ULONG		bytesCopied;
	BOOLEAN		eventDone = FALSE;

	ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

	//	The address object should be referenced, and we just assume
	//	it will be valid during the lifetime of this call.

	//	Check if protocol type is valid.
	if ((pDdpAddr->ddpao_Protocol != Protocol) &&
		(pDdpAddr->ddpao_Protocol != DDPPROTO_ANY))
	{
		return;
	}

	//	First check for queued ddp reads
	ACQUIRE_SPIN_LOCK_DPC(&pDdpAddr->ddpao_Lock);
	if (!IsListEmpty(&pDdpAddr->ddpao_ReadLinkage))
	{
		p = RemoveHeadList(&pDdpAddr->ddpao_ReadLinkage);
		RELEASE_SPIN_LOCK_DPC(&pDdpAddr->ddpao_Lock);

		error	= ATALK_NO_ERROR;
		pRead 	= CONTAINING_RECORD(p, DDP_READ, dr_Linkage);

		//	Do copy if > 0 bytes
		if (PktLen > 0)
		{
			if (PktLen > pRead->dr_OpBufLen)
			{
				error 	= ATALK_BUFFER_TOO_SMALL;
			}

			PktLen 	= MIN(PktLen, pRead->dr_OpBufLen);
			status = TdiCopyBufferToMdl(pPkt,
										0,
										PktLen,
										GET_MDL_FROM_OPAQUE(pRead->dr_OpBuf),
										0,
										&bytesCopied);

			ASSERT(status == STATUS_SUCCESS);
		}


		(*pRead->dr_RcvCmp)(error, pRead->dr_OpBuf, PktLen, pSrc, pRead->dr_RcvCtx);

		AtalkFreeMemory(pRead);
		return;
	}

	//	If a handler was set on this socket,call it.
	else if (pDdpAddr->ddpao_Handler != NULL)
	{
		RELEASE_SPIN_LOCK_DPC(&pDdpAddr->ddpao_Lock);
		(*pDdpAddr->ddpao_Handler)(pPortDesc,
								   pDdpAddr,
								   pPkt,
								   PktLen,
								   pSrc,
								   pDest,
								   ATALK_NO_ERROR,
								   Protocol,
								   pDdpAddr->ddpao_HandlerCtx,
								   FALSE,
								   NULL);
	}
	else
	{
		//	if there is an event handler on this address object call it.
		//	If there is already a buffered datagram, drop this packet.
		//	If not, save this datagram as the buffered one, and then
		//	indicate,

		if (pDdpAddr->ddpao_Flags & DDPAO_DGRAM_EVENT)
		{
			do
			{
				//	We have datagram event handler set on this AO.
				if (pDdpAddr->ddpao_Flags & (DDPAO_DGRAM_ACTIVE |
											 DDPAO_DGRAM_PENDING))
				{
					//	We are already indicating an event. Or we
					//	have a buffered datagram. Drop this pkt.
					break;
				}
				else
				{
					PTDI_IND_RECEIVE_DATAGRAM 	RcvHandler;
					PVOID 						RcvCtx;
					ULONG						bytesTaken;
					PIRP						rcvDgramIrp;
					TA_APPLETALK_ADDRESS		srcTdiAddr;
					NTSTATUS					status;
				
					ASSERT(pDdpAddr->ddpao_EventInfo != NULL);

					pDdpAddr->ddpao_Flags |= (DDPAO_DGRAM_ACTIVE	|
											  DDPAO_DGRAM_PENDING);

					RcvHandler = pDdpAddr->ddpao_EventInfo->ev_RcvDgramHandler;
					RcvCtx	 = pDdpAddr->ddpao_EventInfo->ev_RcvDgramCtx;

					ATALKADDR_TO_TDI(&srcTdiAddr, pSrc);

					//	Save the dgram in the event info.
					RtlCopyMemory(pDdpAddr->ddpao_EventInfo->ev_IndDgram, pPkt, PktLen);

					pDdpAddr->ddpao_EventInfo->ev_IndDgramLen 	= PktLen;
					pDdpAddr->ddpao_EventInfo->ev_IndSrc 		= *pSrc;
					pDdpAddr->ddpao_EventInfo->ev_IndProto 		= Protocol;
					RELEASE_SPIN_LOCK_DPC(&pDdpAddr->ddpao_Lock);

					status = (*RcvHandler)(RcvCtx,
										   sizeof(TA_APPLETALK_ADDRESS),
										   &srcTdiAddr,
										   0,					  	// Options length
										   NULL,				   	// Options
										   0,						// Datagram flags
										   (ULONG)PktLen,  		// Bytes indicated
										   (ULONG)PktLen,  		// Bytes available
										   (ULONG *)&bytesTaken,
										   pPkt,
										   &rcvDgramIrp);
		
					ASSERT((bytesTaken == 0) || (bytesTaken == PktLen));
		
					if (status == STATUS_MORE_PROCESSING_REQUIRED)
					{
						if (rcvDgramIrp != NULL)
						{
							//  Post the receive as if it came from the io system
							status= AtalkDispatchInternalDeviceControl(
									(PDEVICE_OBJECT)AtalkDeviceObject[ATALK_DEV_DDP],
									 rcvDgramIrp);
			
							ASSERT(status == STATUS_PENDING);
						}
					}	
					else if (status == STATUS_SUCCESS)
					{
						if (bytesTaken != 0)
						{
							//	Assume all of the data was read.
							pDdpAddr->ddpao_Flags &= ~DDPAO_DGRAM_PENDING;
						}
					}
					else if (status == STATUS_DATA_NOT_ACCEPTED)
					{
						//	Client may have posted a receive in the indication. Or
						//	it will post a receive later on. Do nothing here.
						DBGPRINT(DBG_COMP_DDP, DBG_LEVEL_ERR,
								("atalkDdpRecvData: Indication status %lx\n", status));
					}

					ACQUIRE_SPIN_LOCK_DPC(&pDdpAddr->ddpao_Lock);
				}

			} while (FALSE);

			//	reset the event flags
			pDdpAddr->ddpao_Flags &= ~DDPAO_DGRAM_ACTIVE;
		}
		RELEASE_SPIN_LOCK_DPC(&pDdpAddr->ddpao_Lock);
	}
}




VOID
AtalkDdpPacketIn(
	IN	PPORT_DESCRIPTOR	pPortDesc,
	IN	PBYTE				pLinkHdr,
	IN	PBYTE				pPkt,
	IN	USHORT				PktLen,
    IN  BOOLEAN             fWanPkt
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	USHORT			dgramLen, ddpHdrLen;
	USHORT			hopCnt, checksum;
	BYTE			Protocol;
	ATALK_ADDR		destAddr, srcAddr;
	PBYTE			pDdpHdr;

	//	Only for localtalk
	BYTE			alapSrcNode;
	BYTE			alapDestNode;

    PBUFFER_DESC    pBufCopy = NULL;
    SEND_COMPL_INFO SendInfo;
	PBYTE			pOrgPkt;
	USHORT			srcOffset;
	BOOLEAN			extHdr	  = TRUE;
	PBYTE			pRouteInfo;
	USHORT			routeLen  = 0;
	BOOLEAN			delivered = FALSE;
	BOOLEAN			broadcast = FALSE;
	BOOLEAN			shouldBeRouted = FALSE;
    BOOLEAN         sendOnDefAdptr = FALSE;
	ATALK_ERROR		error = ATALK_NO_ERROR;
    KIRQL           OldIrql;
	TIME			TimeS, TimeE, TimeD;

	TimeS = KeQueryPerformanceCounter(NULL);

	if (PORT_CLOSING(pPortDesc))
	{
		//	If we are not active, return!
		return;
	}

    // save the packet starting
    pOrgPkt = pPkt;

	do
	{
		ASSERT((PktLen > 0) || ((PktLen == 0) && (pPkt == NULL)));

		if (PktLen > (MAX_DGRAM_SIZE + LDDP_HDR_LEN))
		{
			DBGPRINT(DBG_COMP_DDP, DBG_LEVEL_WARN,
					("AtalkDdpPacketIn: Invalid size %lx\n", PktLen));
			error = ATALK_DDP_INVALID_LEN;
			break;
		}

		//	Get to the ddp header
		pDdpHdr		= pPkt;

		//	Short and long header formats have the length in the same place,
		dgramLen = DDP_GET_LEN(pDdpHdr);
		hopCnt   = DDP_GET_HOP_COUNT(pDdpHdr);

		//	Is the packet too long?
		if ((hopCnt > RTMP_MAX_HOPS) || (dgramLen > PktLen))
		{
			error = ATALK_DDP_INVALID_LEN;
			break;
		}

		//	First glean the information. Check for route info if
		//	tokenring network.
		switch (pPortDesc->pd_NdisPortType)
		{
		  case NdisMedium802_5:
	
			if (pLinkHdr[TLAP_SRC_OFFSET] & TLAP_SRC_ROUTING_MASK)
			{
				routeLen = (pLinkHdr[TLAP_ROUTE_INFO_OFFSET] & TLAP_ROUTE_INFO_SIZE_MASK);

				//  First, glean any AARP information that we can, then handle the DDP
				//  packet.  This guy also makes sure we have a good 802.2 header...
				//
				//  Need to make a localcopy of the source address and then turn
				//  the source routing bit off before calling GleanAarpInfo
				//
			
				pLinkHdr[TLAP_SRC_OFFSET] &= ~TLAP_SRC_ROUTING_MASK;
				pRouteInfo = pLinkHdr + TLAP_ROUTE_INFO_OFFSET;
			}

			ddpHdrLen	 = LDDP_HDR_LEN;

			srcOffset = TLAP_SRC_OFFSET;
			break;
	
		  case NdisMedium802_3:

			//	Check the length.
			if ((dgramLen < LDDP_HDR_LEN) ||
				(dgramLen > MAX_DGRAM_SIZE + LDDP_HDR_LEN))
			{
				error = ATALK_DDP_INVALID_LEN;
				break;
			}

			ddpHdrLen	 = LDDP_HDR_LEN;

			srcOffset	 = ELAP_SRC_OFFSET;
			break;
	
		  case NdisMediumFddi:

			//	Check the length.
			if ((dgramLen < LDDP_HDR_LEN) ||
				(dgramLen > MAX_DGRAM_SIZE + LDDP_HDR_LEN))
			{
				error = ATALK_DDP_INVALID_LEN;
				break;
			}

			ddpHdrLen	 = LDDP_HDR_LEN;

			srcOffset	 = FDDI_SRC_OFFSET;
			break;
	
		  case NdisMediumLocalTalk:
	
			//	Do we have an extended header?
			extHdr = (BOOLEAN)(pLinkHdr[ALAP_TYPE_OFFSET] == ALAP_LDDP_HDR_TYPE);

			if (extHdr)
			{
				ddpHdrLen	 = LDDP_HDR_LEN;
			}
			else
			{
				alapDestNode 	= *(pLinkHdr + ALAP_DEST_OFFSET);
				alapSrcNode 	= *(pLinkHdr + ALAP_SRC_OFFSET);

				if ((dgramLen < SDDP_HDR_LEN) ||
					(dgramLen > (MAX_DGRAM_SIZE + SDDP_HDR_LEN)))
				{
					error = ATALK_DDP_INVALID_LEN;
					break;
				}
	
				ddpHdrLen	 = SDDP_HDR_LEN;
			}

			break;
	
		  case NdisMediumWan:

			//	Check the length.
			if ((dgramLen < LDDP_HDR_LEN) ||
				(dgramLen > MAX_DGRAM_SIZE + LDDP_HDR_LEN))
			{
				error = ATALK_DDP_INVALID_LEN;
				break;
			}

			ddpHdrLen	 = LDDP_HDR_LEN;

			extHdr = TRUE;           // always extended for ARAP

			break;
	
		  default:
			//  Should never happen!
			DBGPRINT(DBG_COMP_DDP, DBG_LEVEL_FATAL,
					("AtalkDdpPacketIn: Unknown media\n"));

			KeBugCheck(0);
			break;
		}

		if (!ATALK_SUCCESS(error))
		{
			break;
		}

		//	Advance packet to point to the data. Caller frees up packet.
		pPkt += ddpHdrLen;

		//	Glean aarp information for non-localtalk and non-RAS ports
		if ((pPortDesc->pd_NdisPortType != NdisMediumLocalTalk) && !fWanPkt)
		{
			AtalkAarpGleanInfo(pPortDesc,
							   pLinkHdr + srcOffset,
							   TLAP_ADDR_LEN,
							   pRouteInfo,
							   (USHORT)routeLen,
							   pDdpHdr,
							   (USHORT)ddpHdrLen);
		}

		pDdpHdr += 2;	// Past off-cable & len
	
		if (extHdr)		//	Long DDP header
		{
			//	Get checksum, verification, if needed.
			GETSHORT2SHORT(&checksum, pDdpHdr);
			pDdpHdr += 2;

			if (checksum != 0)
			{
				USHORT	calcCheckSum;

				//	pDdpHdr has already moved passed LEADING_UNCHECKSUMED_BYTES.
				//	So we just need to decrease the header length field. Use
				//	dgramLen, NOT PktLen!
				calcCheckSum = AtalkDdpCheckSumPacket(pDdpHdr,
													  (USHORT)(ddpHdrLen - LEADING_UNCHECKSUMED_BYTES),
													  pPkt,
													  (USHORT)(dgramLen - ddpHdrLen));
				if (checksum != calcCheckSum)
				{
					DBGPRINT(DBG_COMP_DDP, DBG_LEVEL_ERR,
							("AtalkDdpPacketIn: Checksums dont match! %lx.%lx\n",
							checksum, calcCheckSum));

					AtalkLogBadPacket(pPortDesc,
									  &srcAddr,
									  &destAddr,
									  pDdpHdr,
									  (USHORT)(ddpHdrLen - LEADING_UNCHECKSUMED_BYTES));

					error = ATALK_DDP_PKT_DROPPED;
					break;
				}
			}
			

			//	Build full source and destination AppleTalk address structures
			//	from our DDP header.
			GETSHORT2SHORT(&destAddr.ata_Network, pDdpHdr);
			pDdpHdr += 2;

			GETSHORT2SHORT(&srcAddr.ata_Network, pDdpHdr);
			pDdpHdr += 2;

			destAddr.ata_Node 	= *pDdpHdr++;
			srcAddr.ata_Node 	= *pDdpHdr++;

			destAddr.ata_Socket	= *pDdpHdr++;
			srcAddr.ata_Socket 	= *pDdpHdr++;

			//	Get the protocol type.
			Protocol 			= *pDdpHdr;

			broadcast = (destAddr.ata_Node == ATALK_BROADCAST_NODE);
			
			//	Do we like what we see?  Note "nnnn00" is now allowed and used by
			//	NBP.
			
			if ((srcAddr.ata_Network > LAST_VALID_NETWORK) ||
				(srcAddr.ata_Network < FIRST_VALID_NETWORK) ||
				(srcAddr.ata_Node < MIN_USABLE_ATALKNODE) ||
				(srcAddr.ata_Node > MAX_USABLE_ATALKNODE))
			{
				error = ATALK_DDP_INVALID_SRC;
				DBGPRINT(DBG_COMP_DDP, DBG_LEVEL_ERR,
					("DdpPacketIn: Received pkt with bad src addr %lx.%lx\n",
                        srcAddr.ata_Network,srcAddr.ata_Node));
				break;
			}

			if ((destAddr.ata_Network > LAST_VALID_NETWORK) ||
				((destAddr.ata_Node > MAX_USABLE_ATALKNODE) &&
				  !broadcast))
			{
				error = ATALK_DDP_INVALID_DEST;
				DBGPRINT(DBG_COMP_DDP, DBG_LEVEL_ERR,
					("DdpPacketIn: Received pkt with bad src addr %lx.%lx\n",
                        destAddr.ata_Network,destAddr.ata_Node));
				break;
			}

			//	Loop through all nodes that are on the reception port and see if
			//	anybody wants this packet.  The algorithm is from the "AppleTalk
			//	Phase 2 Protocol Specification" with enhacements to support ports
			//	that have multiple nodes.
			
			//	"0000xx" (where "xx" isnt "FF") should not be accepted on an
			//	extended port... For some unknown reason, the spec would like
			//	us to pass this case onto the router (which will, no doubt,
			//	drop it on the floor because it won't find network zero in its
			//	routing table)... you know, bug-for-bug compatible!
			if ((destAddr.ata_Network == UNKNOWN_NETWORK) &&
				(pPortDesc->pd_Flags & PD_EXT_NET) &&
				(!broadcast))
			{
				DBGPRINT(DBG_COMP_DDP, DBG_LEVEL_ERR,
						("DdpPacketIn: Received pkt with net/node %lx.%lx on ext\n",
						destAddr.ata_Network, destAddr.ata_Node));

				shouldBeRouted = TRUE;
			}
			else
			{
                //
                // if we have RAS port configured, and currently have dial-in
                // client(s) connected then see if any (or all) of them are
                // interested in this packet
                // Make sure that any broadcasts we forward came on default port
                //
                if ( (RasPortDesc) &&
                     ((!broadcast) ||
                      (broadcast && (pPortDesc == AtalkDefaultPort))) )
                {

                    ACQUIRE_SPIN_LOCK(&RasPortDesc->pd_Lock, &OldIrql);

                    if (!IsListEmpty(&RasPortDesc->pd_PPPConnHead))
                    {
                        RELEASE_SPIN_LOCK(&RasPortDesc->pd_Lock, OldIrql);

                        // see if any PPP client(s) are interested
                        PPPRoutePacketToWan(
                                &destAddr,
                                &srcAddr,
    						    Protocol,
                                pPkt,                             // only data, no DDP hdr
                                (USHORT)(dgramLen - ddpHdrLen),   // only data length
                                hopCnt,
                                broadcast,
                                &delivered);
                        //
                        // if we delivered it to any of the PPP clients, and
                        // this was not a broadcast, then we 're done here
                        //
                        if (delivered && !broadcast)
                        {
                            break;
                        }

                    }
                    else
                    {
                        RELEASE_SPIN_LOCK(&RasPortDesc->pd_Lock, OldIrql);
                    }

                    ACQUIRE_SPIN_LOCK(&RasPortDesc->pd_Lock, &OldIrql);

                    if (!IsListEmpty(&RasPortDesc->pd_ArapConnHead))
                    {
                        RELEASE_SPIN_LOCK(&RasPortDesc->pd_Lock, OldIrql);

                        // see if any ARAP client(s) are interested
                        ArapRoutePacketToWan(
                                &destAddr,
                                &srcAddr,
			    			    Protocol,
                                pOrgPkt,                // whole packet (with DDP hdr)
                                dgramLen,               // whole packet length
                                broadcast,
                                &delivered);

                        //
                        // if we delivered it to any of the ARAP clients, and
                        // this was not a broadcast, then we 're done here
                        //
                        if (delivered && !broadcast)
                        {
                            break;
                        }
                    }
                    else
                    {
                        RELEASE_SPIN_LOCK(&RasPortDesc->pd_Lock, OldIrql);
                    }
                }

				//	Now, on the packet in path, we either deliver the packet
				//	to one of our nodes on this port, or we pass it on to the
				//	router. Even if the packet is a broadcast, the delivered
				//	flag will be set to true. shouldBeRouter will be set to
				//	true, only if the packet *DOES NOT* seem to be destined for
				//	this port. We route the packet *ONLY IF* shouldBeRouter
				//	is true
				AtalkDdpInPktToNodesOnPort(pPortDesc,
										   &destAddr,
										   &srcAddr,
										   Protocol,
										   pPkt,
										   (USHORT)(dgramLen - LDDP_HDR_LEN),
										   &shouldBeRouted);
			}

            //
            // if this packet originated from a dial-in client and the packet wasn't
            // claimed by any of our nodes then we need to send it over to the LAN net:
            // see if we must
            //
            if (fWanPkt)
            {
                sendOnDefAdptr = FALSE;

                //
                // broadcasts are meant for the local net, so default adapter only
                //
	            if (broadcast)
	            {
                    sendOnDefAdptr = TRUE;
                }

                //
                // if destination is on the same net as the default adapter, or
                // if the router is not running then send it on the default adapter
                //
	            if (shouldBeRouted)
                {
                    if ((WITHIN_NETWORK_RANGE(destAddr.ata_Network,
                                    &pPortDesc->pd_NetworkRange)) ||
                        (!(pPortDesc->pd_Flags & PD_ROUTER_RUNNING)))
                    {
                        sendOnDefAdptr = TRUE;
                    }
                }

                //
                // ok, we must send it on the default adapter.
                //
                if (sendOnDefAdptr)
                {
                    // no need to send this packet to router: we're sending here
                    shouldBeRouted = FALSE;

    			    pBufCopy = AtalkAllocBuffDesc(
                                    NULL,
                                    (USHORT)(dgramLen - LDDP_HDR_LEN),
                                    (BD_FREE_BUFFER | BD_CHAR_BUFFER));

                    if (pBufCopy == NULL)
				    {
    				    error = ATALK_RESR_MEM;
				        break;
				    }

    			    AtalkCopyBufferToBuffDesc(pPkt,
                                            (USHORT)(dgramLen - LDDP_HDR_LEN),
                                            pBufCopy,
                                            0);

                    SendInfo.sc_TransmitCompletion = atalkDdpRouteComplete;
		            SendInfo.sc_Ctx1 = pPortDesc;
		            SendInfo.sc_Ctx3 = NULL;
				    SendInfo.sc_Ctx2 = pBufCopy;

    			    error = AtalkDdpTransmit(pPortDesc,
				    					    &srcAddr,
					    				    &destAddr,
						    			    Protocol,
							    		    pBufCopy,
								    	    NULL,
									        0,
    									    0,
	    								    NULL,
		    							    NULL,
			    						    &SendInfo);

                    if (error != ATALK_PENDING)
                    {
                        AtalkFreeBuffDesc(pBufCopy);
                        break;
                    }
	            }
            }

            //
			//	if we still haven't been able to deliver the packet, and if we
            //  have routing enabled, give router a crack at it
            //
            if (shouldBeRouted && pPortDesc->pd_Flags & PD_ROUTER_RUNNING)
			{
			    AtalkDdpRouteInPkt(pPortDesc,
				    			   &srcAddr,
					    		   &destAddr,
						    	   Protocol,
							       pPkt,
        						   (USHORT)(dgramLen - LDDP_HDR_LEN),
		    					   hopCnt);
			}
		}
		else		//	Short DDP header!
		{
			BYTE	ThisNode;

			ASSERT(!EXT_NET(pPortDesc));

			if (pPortDesc->pd_Flags & PD_EXT_NET)
			{
				error = ATALK_DDP_SHORT_HDR;
				break;
			}

			//	Use network number for the node on this port for source/destination
			//	network numbers. When we search for the socket/address
			//	object, the concept net = 0, matches anything will come
			//	into play.

			srcAddr.ata_Network = destAddr.ata_Network = NET_ON_NONEXTPORT(pPortDesc);
			srcAddr.ata_Node 	= alapSrcNode;

			ThisNode = NODE_ON_NONEXTPORT(pPortDesc);
			if (alapDestNode == ATALK_BROADCAST_NODE)
			{
				destAddr.ata_Node = ThisNode;
			}
			else if (alapDestNode != ThisNode)
			{
				error = ATALK_DDP_INVALID_DEST;
				break;
			}
			else
			{
				destAddr.ata_Node  	= alapDestNode;
			}

			DBGPRINT(DBG_COMP_DDP, DBG_LEVEL_WARN,
					("AtalkDdpPacketIn: NonExtended Dest Net.Node %lx.%lx\n",
					destAddr.ata_Network, destAddr.ata_Node));

			//	Get the socket numbers from the ddp header.
			destAddr.ata_Socket = *pDdpHdr++;
			srcAddr.ata_Socket	= *pDdpHdr++;

			//	Get the protocol type
			Protocol 			= *pDdpHdr;

			//	If the protocol type is 0, we have an error.
			if (Protocol == 0)
			{
				error = ATALK_DDP_INVALID_PROTO;
				break;
			}

			//	Now the destination node address could be
			//	ALAP_BROADCAST_NODE (0xFF).
			if ((srcAddr.ata_Node < MIN_USABLE_ATALKNODE) ||
				(srcAddr.ata_Node > MAX_USABLE_ATALKNODE))
			{
				error = ATALK_DDP_INVALID_SRC;
				break;
			}

			if (((destAddr.ata_Node < MIN_USABLE_ATALKNODE) ||
				 (destAddr.ata_Node > MAX_USABLE_ATALKNODE)) &&
				(destAddr.ata_Node != ATALK_BROADCAST_NODE))
			{
				error = ATALK_DDP_INVALID_DEST;
				break;
			}

			//	On a non-extended port, there will be only one node.
			AtalkDdpInPktToNodesOnPort(pPortDesc,
									   &destAddr,
									   &srcAddr,
									   Protocol,
									   pPkt,
									   (USHORT)(dgramLen - SDDP_HDR_LEN),
									   &shouldBeRouted);		// This is a dud parameter
																// for non-ext nets
		}
	} while (FALSE);

	if (!ATALK_SUCCESS(error))
	{
		DBGPRINT(DBG_COMP_DDP, DBG_LEVEL_WARN,
				("AtalkDdpPacketIn: Dropping packet %lx\n", error) );
	}

	TimeE = KeQueryPerformanceCounter(NULL);
	TimeD.QuadPart = TimeE.QuadPart - TimeS.QuadPart;

	INTERLOCKED_ADD_LARGE_INTGR_DPC(
		&pPortDesc->pd_PortStats.prtst_DdpPacketInProcessTime,
		TimeD,
		&AtalkStatsLock.SpinLock);

	INTERLOCKED_INCREMENT_LONG_DPC(
		&pPortDesc->pd_PortStats.prtst_NumDdpPacketsIn,
		&AtalkStatsLock.SpinLock);
}



VOID
AtalkDdpQuery(
	IN	PDDP_ADDROBJ	pDdpAddr,
	IN	PAMDL			pAmdl,
	OUT	PULONG			BytesWritten
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	TDI_ADDRESS_INFO		tdiInfo;
	PTA_APPLETALK_ADDRESS	pTaAddr;

	ASSERT (VALID_DDP_ADDROBJ(pDdpAddr));

	pTaAddr	= (PTA_APPLETALK_ADDRESS)&tdiInfo.Address;
	ATALKADDR_TO_TDI(pTaAddr, &pDdpAddr->ddpao_Addr);
	TdiCopyBufferToMdl ((PBYTE)&tdiInfo,
						0L,
						sizeof(tdiInfo),
						pAmdl,
						0,
						BytesWritten);
}




VOID
AtalkDdpOutBufToNodesOnPort(
	IN	PPORT_DESCRIPTOR	pPortDesc,
	IN	PATALK_ADDR			pSrc,
	IN	PATALK_ADDR			pDest,
	IN	BYTE				Protocol,
	IN	PBUFFER_DESC		pBuffDesc		OPTIONAL,
	IN	PBYTE				pOptHdr			OPTIONAL,
	IN	USHORT				OptHdrLen		OPTIONAL,
	OUT	PBOOLEAN			Delivered
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	ATALK_ERROR		error;
	PATALK_NODE		pAtalkNode, pNextNode;
	PDDP_ADDROBJ	pDdpAddr;
	BOOLEAN			fDeliver, fSpecific, needToRef;
	BOOLEAN			lockHeld = FALSE;

	ASSERT (KeGetCurrentIrql() == DISPATCH_LEVEL);

	//	Do not internally loopback broadcast frames, these should come
	//	back to us from the mac.
	if (pDest->ata_Node == ATALK_BROADCAST_NODE)
	{
		*Delivered = FALSE;
		return;
	}

	fSpecific	= (pDest->ata_Network != CABLEWIDE_BROADCAST_NETWORK);

	//	Walk through our nodes to see if we can deliver this packet.
	//	OPTIMIZATIONS:
	//	In most cases, this will not be true. Optimize for returning false.
	//	Also, a node closing is a rare occurence. If we run into one that is
	//	closing, we abort trying to deliver this packet to a node on our port,
	//	and instead return delivered = FALSE. DDP - unreliable, and node closing
	//	should be a transient state. We avoid the acquire/release code.
	ACQUIRE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);
	lockHeld	= TRUE;

	pNextNode	= pPortDesc->pd_Nodes;
	needToRef	= TRUE;
	for (; (pAtalkNode = pNextNode) != NULL; )
	{
		fDeliver	= FALSE;
		error		= ATALK_NO_ERROR;

		if (((pAtalkNode->an_NodeAddr.atn_Network == pDest->ata_Network) ||
			 !fSpecific) &&
			(pAtalkNode->an_NodeAddr.atn_Node == pDest->ata_Node))
		{
			//	Reference node. If we fail, we abort.
			if (needToRef)
			{
				AtalkNodeRefByPtr(pAtalkNode, &error);
			}

			if (ATALK_SUCCESS(error))
			{
				fDeliver	= TRUE;

				//	Set up for next node.
				if (fSpecific)
				{
					pNextNode	= NULL;
				}
				else
				{
					//	Get next eligible node.
					pNextNode	= pAtalkNode->an_Next;
					while (pNextNode != NULL)
					{
						if (pNextNode->an_NodeAddr.atn_Node == pDest->ata_Node)
						{
							AtalkNodeRefByPtr(pNextNode, &error);
							if (!ATALK_SUCCESS(error))
							{
								pNextNode	= NULL;
							}

							needToRef	= FALSE;
							break;
						}
						else
						{
							pNextNode	= pNextNode->an_Next;
						}
					}
				}
			}
			else
			{
				//	Break out of the for loop.
				break;
			}
		}
		else
		{
			pNextNode	= pAtalkNode->an_Next;
			needToRef	= TRUE;
		}

		if (fDeliver)
		{
			//	Release port lock, deliver packet, and Deref the node.
			//	Find the ddp address object on this node corresponding
			//	to this address. This will get the node lock.
			AtalkDdpRefByAddrNode(pPortDesc,
								  pDest,
								  pAtalkNode,
								  &pDdpAddr,
								  &error);

			RELEASE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);
			lockHeld	= FALSE;

			if (ATALK_SUCCESS(error))
			{
				//	Invoke socket handler on this address object.
				AtalkDdpInvokeHandlerBufDesc(pPortDesc,
											 pDdpAddr,
											 pSrc,
											 pDest,
											 Protocol,
											 pBuffDesc,
											 pOptHdr,
											 OptHdrLen);
	
				//	Remove the reference on the socket
				AtalkDdpDereferenceDpc(pDdpAddr);
			}

			//	Remove the reference on the node
			AtalkNodeDereference(pAtalkNode);

			//	If we had to deliver to a specific node, we are done.
			if (fSpecific)
			{
				break;
			}

			ACQUIRE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);
			lockHeld	= TRUE;
		}
	}

	if (lockHeld)
	{
		RELEASE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);
	}

	*Delivered = (fSpecific && fDeliver);
}




VOID
AtalkDdpInPktToNodesOnPort(
	IN	PPORT_DESCRIPTOR	pPortDesc,
	IN	PATALK_ADDR			pDest,
	IN	PATALK_ADDR			pSrc,
	IN	BYTE				Protocol,
	IN	PBYTE				pPkt			OPTIONAL,
	IN	USHORT				PktLen			OPTIONAL,
	OUT	PBOOLEAN			ShouldBeRouted
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PATALK_NODE		pAtalkNode, pNextNode;
	PDDP_ADDROBJ	pDdpAddr;
	BOOLEAN			broadcast;
	BOOLEAN			fSpecific, fDeliver, needToRef;
	ATALK_ERROR		error			= ATALK_NO_ERROR;
	BOOLEAN			lockHeld 		= FALSE;
	BOOLEAN			shouldBeRouted  = FALSE;

	ASSERT (KeGetCurrentIrql() == DISPATCH_LEVEL);

	broadcast = (pDest->ata_Node == ATALK_BROADCAST_NODE);

	//	is a directed packet to a socket on a particular node...?
	fSpecific = (!broadcast &&
					(pDest->ata_Network != UNKNOWN_NETWORK));

	//	OPTIMIZATIONS:
	//	In most cases, this will not be true. Optimize for returning false.
	//	Also, a node closing is a rare occurence. If we run into one that is
	//	closing, we abort trying to deliver this packet to a node on our port,
	//	and instead return delivered = FALSE. DDP - unreliable, and node closing
	//	should be a transient state. We avoid the acquire/release code.
	ACQUIRE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);
	lockHeld	= TRUE;

	pNextNode	= pPortDesc->pd_Nodes;
	needToRef	= TRUE;
	while ((pAtalkNode = pNextNode) != NULL)
	{
		fDeliver	= FALSE;
		error		= ATALK_NO_ERROR;

		//	For incoming packet, we check to see if the destination
		//	net is 0, or destination net is our node's net, or we are
		//	non-extended and our node's net is zero. i.e. is the packet
		//	destined for a node on this port. If not, route it. Continue
		//	checking all nodes though, as a single port can have nodes with
		//	different network numbers.

		if (((pAtalkNode->an_NodeAddr.atn_Network == pDest->ata_Network) 	||
			 (pDest->ata_Network == UNKNOWN_NETWORK)						||
			 (!EXT_NET(pPortDesc) &&
			  (pAtalkNode->an_NodeAddr.atn_Network == UNKNOWN_NETWORK)))	&&
			(broadcast || (pAtalkNode->an_NodeAddr.atn_Node == pDest->ata_Node)))
		{
			//	Reference node if we need to. Only happens for the first
			//	time we enter the loop. If we fail, we  abort.
			if (needToRef)
			{
				AtalkNodeRefByPtr(pAtalkNode, &error);
				if (!ATALK_SUCCESS(error))
				{
					break;
				}
			}

			fDeliver	= TRUE;

			//	Set up for next node.
			if (fSpecific)
			{
				//	Only one node on a non-extended port. So set next to NULL.
				pNextNode	= NULL;
			}
			else
			{
				//	Get next eligible node.
				pNextNode	= pAtalkNode->an_Next;
				while (pNextNode != NULL)
				{
					if (((pNextNode->an_NodeAddr.atn_Network == pDest->ata_Network) ||
						(pDest->ata_Network == UNKNOWN_NETWORK)						||
						(!EXT_NET(pPortDesc) &&
						 (pNextNode->an_NodeAddr.atn_Network == UNKNOWN_NETWORK)))	&&
						(broadcast ||
						 (pNextNode->an_NodeAddr.atn_Node == pDest->ata_Node)))
					{
						AtalkNodeRefByPtr(pNextNode, &error);
						if (!ATALK_SUCCESS(error))
						{
							pNextNode	= NULL;
						}
	
						needToRef	= FALSE;
						break;
					}

					pNextNode	= pNextNode->an_Next;
				}
			}
		}
		else
		{
			//	The packet probably could be meant to be routed.
			//	This could be set multiple times - idempotent.
			shouldBeRouted 	= TRUE;
			needToRef		= TRUE;
			pNextNode		= pAtalkNode->an_Next;
		}

		if (fDeliver)
		{
			//	Release port lock, deliver packet, and Deref the node.
			//	Find the ddp address object on this node corresponding
			//	to this address. This will get the node lock.
			if (broadcast)
				pDest->ata_Node = pAtalkNode->an_NodeAddr.atn_Node;
		
			AtalkDdpRefByAddrNode(pPortDesc,
								  pDest,
								  pAtalkNode,
								  &pDdpAddr,
								  &error);

			//	If we had changed the destination node, change it back.		
			if (broadcast)
				pDest->ata_Node = ATALK_BROADCAST_NODE;

			RELEASE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);
			lockHeld	= FALSE;

			if (ATALK_SUCCESS(error))
			{
				//	Invoke socket handler on this address object.
				//	Use the packet pointer directly!

				AtalkDdpInvokeHandler(pPortDesc,
									  pDdpAddr,
									  pSrc,
									  pDest,
									  Protocol,
									  pPkt,
									  PktLen);
	
				//	Remove the reference on the socket
				AtalkDdpDereferenceDpc(pDdpAddr);
			}

			//	Remove the reference on the node
			AtalkNodeDereference(pAtalkNode);

			//	If we had to deliver to a specific node, we are done.
			if (fSpecific)
			{
				shouldBeRouted = FALSE;
				break;
			}

			ACQUIRE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);
			lockHeld	= TRUE;
		}
	}

	if (lockHeld)
	{
		RELEASE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);
	}

	*ShouldBeRouted = shouldBeRouted;
}




USHORT
AtalkDdpCheckSumBuffer(
	IN	PBYTE	Buffer,
	IN	USHORT	BufLen,
	IN	USHORT	CurrentCheckSum
	)
/*++

Routine Description:

	Calculate the DDP checksum of a byte array

Arguments:


Return Value:


--*/
{
	USHORT	CheckSum = CurrentCheckSum;
	ULONG	i;

	// The following algorithm is from Inside AppleTalk, Second Edition
	// page 4-17
	for (i = 0; i < BufLen; i++)
	{
		CheckSum += Buffer[i];
		if (CheckSum & 0x8000)	// 16-bit rotate left one bit
		{
			CheckSum <<= 1;
			CheckSum ++;
		}
		else CheckSum <<= 1;
	}
	if (CheckSum == 0)
		CheckSum = 0xFFFF;

	return CheckSum;
}




USHORT
AtalkDdpCheckSumPacket(
	IN	PBYTE	pHdr,
	IN	USHORT	HdrLen,
	IN	PBYTE	pPkt,
	IN	USHORT	PktLen
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	USHORT	checksum = 0;

	//	MAX_LDDP_PKT_SIZE is 600, so we use < instead of <=

	ASSERT(HdrLen + PktLen < MAX_LDDP_PKT_SIZE);
	if ((HdrLen + PktLen) < MAX_LDDP_PKT_SIZE)
	{
		if (HdrLen > 0)
		{
			checksum = AtalkDdpCheckSumBuffer(pHdr, HdrLen, 0);
		}

		if (PktLen > 0)
		{
			checksum = AtalkDdpCheckSumBuffer(pPkt, PktLen, checksum);
		}
	}

	return checksum;
}


// Calculate the DDP checksum of the passed in buffer. The buffer is described
// by the buffer descriptor
USHORT
AtalkDdpCheckSumBufferDesc(
	IN	PBUFFER_DESC	pBuffDesc,
	IN	USHORT			Offset
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PBYTE	pBuf;
	USHORT	checksum = 0;

	while (pBuffDesc != NULL)
	{
		if (pBuffDesc->bd_Flags & BD_CHAR_BUFFER)
		{
			pBuf = pBuffDesc->bd_CharBuffer;
		}
		else
		{
			pBuf = MmGetSystemAddressForMdlSafe(
					pBuffDesc->bd_OpaqueBuffer,
					NormalPagePriority);
		}
		if (pBuf != NULL) {
			checksum = AtalkDdpCheckSumBuffer(pBuf, pBuffDesc->bd_Length, checksum);
			pBuffDesc = pBuffDesc->bd_Next;
		}
	}

	return checksum;
}



//	This routine needs to verify that the socket does not already
//	exist on the node. If it doesnt it will alloc the ddp address
//	object and link it into the node and do all the required initialization.
//	The node is guaranteed to be referenced.

ATALK_ERROR
atalkDdpAllocSocketOnNode(
	IN		PPORT_DESCRIPTOR		pPortDesc,
	IN		BYTE					Socket,
	IN		PATALK_NODE				pAtalkNode,
	IN 		DDPAO_HANDLER			pSktHandler 	OPTIONAL,
	IN		PVOID					pSktCtx			OPTIONAL,
	IN		BYTE					Protocol		OPTIONAL,
	IN		PATALK_DEV_CTX			pDevCtx,
	OUT		PDDP_ADDROBJ			pDdpAddr
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	ATALK_ADDR			addr;
	PDDP_ADDROBJ		pDdpAddrx;
	KIRQL				OldIrql;
	int					i, j, index;
	BOOLEAN				found	= TRUE;
	ATALK_ERROR			error 	= ATALK_NO_ERROR;

	//	See if the socket exists else, link our new socket into
	//	the node linkage. All within a critical section.

	addr.ata_Network = pAtalkNode->an_NodeAddr.atn_Network;
	addr.ata_Node = pAtalkNode->an_NodeAddr.atn_Node;
	addr.ata_Socket = Socket;

	//	Now reference the node on which this socket will reside.
	//	This will go away when the socket is closed.
	AtalkNodeReferenceByPtr(pAtalkNode, &error);
	if (!ATALK_SUCCESS(error))
	{
		TMPLOGERR();
		return error;
	}

	ACQUIRE_SPIN_LOCK(&pAtalkNode->an_Lock, &OldIrql);

	if (Socket == DYNAMIC_SOCKET)
	{
		//	Two attempts if we are at the end of the range and restart from
		//	the beginning.
		for (j = 0; (j < NUM_USER_NODES) && found; j++)
		{
			for (i = pAtalkNode->an_NextDynSkt; i <= LAST_DYNAMIC_SOCKET; i++)
			{
				addr.ata_Socket = (BYTE)i;
				index = HASH_ATALK_ADDR(&addr) % NODE_DDPAO_HASH_SIZE;

				found = atalkDdpFindAddrOnList(pAtalkNode, index, (BYTE)i, &pDdpAddrx);

				if (found)
					continue;

				Socket = (BYTE)i;
				break;
			}

			//	Now if still havent found the socket id, set NextDynSkt to
			//	beginning of the range and try again.
			if (found)
			{
				pAtalkNode->an_NextDynSkt = FIRST_DYNAMIC_SOCKET;
				continue;
			}

			//	Not found. Increment next id to be used.
			if (++(pAtalkNode->an_NextDynSkt) == 0)
			{
				//	We wrapped! Set the value to the lowest dynamic
				//	socket. Thats what it should have been initialized
				//	to.
				pAtalkNode->an_NextDynSkt = FIRST_DYNAMIC_SOCKET;
			}

			DBGPRINT(DBG_COMP_DDP, DBG_LEVEL_INFO,
					("atalkDdpAllocSocketOnNode: Created dynamic socket %x\n", Socket));

			//	Done.
			break;
		}

		if (found)
		{
			error = ATALK_SOCKET_NODEFULL;
		}
	}
	else
	{
		index = HASH_ATALK_ADDR(&addr) % NODE_DDPAO_HASH_SIZE;

		found = atalkDdpFindAddrOnList(pAtalkNode, index, (BYTE)Socket, &pDdpAddrx);

		if (found)
		{
			error = ATALK_SOCKET_EXISTS;
		}
	}

	if (ATALK_SUCCESS(error))
	{
		//	Initialize and thread in the structure

		pDdpAddr->ddpao_Signature	= DDPAO_SIGNATURE;

		pDdpAddr->ddpao_RefCount 	= 1;		//	Creation
		pDdpAddr->ddpao_DevCtx 		= pDevCtx;
		pDdpAddr->ddpao_Node 		= pAtalkNode;

		pDdpAddr->ddpao_Addr.ata_Network	= pAtalkNode->an_NodeAddr.atn_Network;
		pDdpAddr->ddpao_Addr.ata_Node  		= pAtalkNode->an_NodeAddr.atn_Node;
		pDdpAddr->ddpao_Addr.ata_Socket		= Socket;

		pDdpAddr->ddpao_Protocol 	= Protocol;
		pDdpAddr->ddpao_Handler 	= pSktHandler;
		pDdpAddr->ddpao_HandlerCtx 	= pSktCtx;

		INITIALIZE_SPIN_LOCK(&pDdpAddr->ddpao_Lock);
		InitializeListHead(&pDdpAddr->ddpao_ReadLinkage);

		//	We use 'index' to link this in.
		pDdpAddr->ddpao_Next = pAtalkNode->an_DdpAoHash[index];
		pAtalkNode->an_DdpAoHash[index] = pDdpAddr;
	}

	RELEASE_SPIN_LOCK(&pAtalkNode->an_Lock, OldIrql);

	//	If we failed, Dereference the node
	if (!ATALK_SUCCESS(error))
		AtalkNodeDereference(pAtalkNode);

	return error;
}




BOOLEAN
atalkDdpFindAddrOnList(
	IN	PATALK_NODE		pAtalkNode,
	IN	ULONG			Index,
	IN	BYTE			Socket,
	OUT	PDDP_ADDROBJ *	ppDdpAddr
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PDDP_ADDROBJ	pDdpAddr;

   	BOOLEAN		found = FALSE;

	for (pDdpAddr = pAtalkNode->an_DdpAoHash[Index];
		 pDdpAddr != NULL;
		 pDdpAddr = pDdpAddr->ddpao_Next)
	{
		if (pDdpAddr->ddpao_Addr.ata_Socket == Socket)
		{
			*ppDdpAddr = pDdpAddr;
			found = TRUE;
			break;
		}
	}

	return found;
}




VOID
AtalkDdpRefByAddr(
	IN		PPORT_DESCRIPTOR	pPortDesc,
	IN		PATALK_ADDR			pAtalkAddr,
	OUT		PDDP_ADDROBJ	*	ppDdpAddr,
	OUT		PATALK_ERROR		pErr
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	ULONG				index;
	ATALK_NODEADDR		node;
	PATALK_NODE			pAtalkNode;
	PDDP_ADDROBJ		pDdpAddr;
	KIRQL				OldIrql;
	ATALK_ERROR			ErrorCode;

	node.atn_Network = pAtalkAddr->ata_Network;
	node.atn_Node	= pAtalkAddr->ata_Node;

	//	First find the node on this port given its address
	AtalkNodeReferenceByAddr(pPortDesc,
							 &node,
							 &pAtalkNode,
							 &ErrorCode);

	if (ATALK_SUCCESS(ErrorCode))
	{
		ASSERT(VALID_ATALK_NODE(pAtalkNode));

		index = HASH_ATALK_ADDR(pAtalkAddr) % NODE_DDPAO_HASH_SIZE;

		ACQUIRE_SPIN_LOCK(&pAtalkNode->an_Lock, &OldIrql);
		if(atalkDdpFindAddrOnList(pAtalkNode,
								  index,
								  pAtalkAddr->ata_Socket,
								  &pDdpAddr))
		{
			AtalkDdpReferenceByPtr(pDdpAddr, &ErrorCode);
			if (ATALK_SUCCESS(ErrorCode))
			{
				ASSERT (VALID_DDP_ADDROBJ(pDdpAddr));
				*ppDdpAddr = pDdpAddr;
			}
		}
		else
		{
			ErrorCode = ATALK_DDP_NOTFOUND;
		}
		RELEASE_SPIN_LOCK(&pAtalkNode->an_Lock, OldIrql);

		//	Remove the node reference
		ASSERT(VALID_ATALK_NODE(pAtalkNode));
		AtalkNodeDereference(pAtalkNode);
	}
	*pErr = ErrorCode;
}




VOID
AtalkDdpRefByAddrNode(
	IN		PPORT_DESCRIPTOR	pPortDesc,
	IN		PATALK_ADDR			pAtalkAddr,
	IN		PATALK_NODE			pAtalkNode,
	OUT		PDDP_ADDROBJ	*	ppDdpAddr,
	OUT		PATALK_ERROR		pErr
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	ULONG			index;
	KIRQL			OldIrql;
	PDDP_ADDROBJ	pDdpAddr;

	ASSERT(VALID_ATALK_NODE(pAtalkNode));

	index = HASH_ATALK_ADDR(pAtalkAddr) % NODE_DDPAO_HASH_SIZE;

	ACQUIRE_SPIN_LOCK(&pAtalkNode->an_Lock, &OldIrql);
	if(atalkDdpFindAddrOnList(pAtalkNode,
							  index,
							  pAtalkAddr->ata_Socket,
							  &pDdpAddr))
	{
		AtalkDdpReferenceByPtr(pDdpAddr, pErr);
		if (ATALK_SUCCESS(*pErr))
		{
			ASSERT (VALID_DDP_ADDROBJ(pDdpAddr));
			*ppDdpAddr = pDdpAddr;
		}
	}
	else
	{
		*pErr = ATALK_DDP_NOTFOUND;
	}
	RELEASE_SPIN_LOCK(&pAtalkNode->an_Lock, OldIrql);
}




VOID
AtalkDdpRefNextNc(
	IN	PDDP_ADDROBJ	pDdpAddr,
	IN	PDDP_ADDROBJ *	ppDdpAddr,
	OUT	PATALK_ERROR	pErr
	)
/*++

Routine Description:

	MUST BE CALLED WITH THE NODE LOCK HELD!

Arguments:


Return Value:


--*/
{
	*pErr = ATALK_FAILURE;
	*ppDdpAddr = NULL;
	for (; pDdpAddr != NULL; pDdpAddr = pDdpAddr->ddpao_Next)
	{
		AtalkDdpReferenceByPtrDpc(pDdpAddr, pErr);
		if (ATALK_SUCCESS(*pErr))
		{
			//	Ok, this address is referenced!
			ASSERT (VALID_DDP_ADDROBJ(pDdpAddr));
			*ppDdpAddr = pDdpAddr;
			break;
		}
	}
}




VOID FASTCALL
AtalkDdpDeref(
	IN	OUT	PDDP_ADDROBJ		pDdpAddr,
	IN		BOOLEAN				AtDpc
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	ATALK_ERROR		error = ATALK_NO_ERROR;
	PATALK_NODE		pNode = pDdpAddr->ddpao_Node;
	BOOLEAN			done = FALSE;
	KIRQL			OldIrql;

	ASSERT (VALID_DDP_ADDROBJ(pDdpAddr));

	if (AtDpc)
	{
		 ACQUIRE_SPIN_LOCK_DPC(&pDdpAddr->ddpao_Lock);
	}
	else
	{
		ACQUIRE_SPIN_LOCK(&pDdpAddr->ddpao_Lock, &OldIrql);
	}

	ASSERT(pDdpAddr->ddpao_RefCount > 0);
	if (--(pDdpAddr->ddpao_RefCount) == 0)
	{
		done = TRUE;
	}

	if (AtDpc)
	{
		 RELEASE_SPIN_LOCK_DPC(&pDdpAddr->ddpao_Lock);
	}
	else
	{
		RELEASE_SPIN_LOCK(&pDdpAddr->ddpao_Lock, OldIrql);
	}

	if (done)
	{
		PDDP_ADDROBJ *	ppDdpAddr;
		int				index;

        //
        // if this is a zombie socket (that is, it was cleaned up but not freed
        // because it's an external socket) then now is the time to free it.
        // Cleanup is all done already.
        //
        if ((pDdpAddr->ddpao_Flags & DDPAO_SOCK_PNPZOMBIE) != 0)
        {
	        DBGPRINT(DBG_COMP_DDP, DBG_LEVEL_ERR,
		        ("AtalkDdpDeref..: zombie addr %lx (%lx) freed\n",
                pDdpAddr,pDdpAddr->ddpao_Handler));

		    //	Free the address structure
		    AtalkFreeMemory(pDdpAddr);

            return;
        }

		ASSERT((pDdpAddr->ddpao_Flags & DDPAO_CLOSING) != 0);

		if ((pDdpAddr->ddpao_Flags & DDPAO_CLOSING) == 0)
		{
			KeBugCheck(0);
		}

		//	Remove this guy from the node linkage
		if (AtDpc)
		{
			ACQUIRE_SPIN_LOCK_DPC(&pNode->an_Lock);
		}
		else
		{
			ACQUIRE_SPIN_LOCK(&pNode->an_Lock, &OldIrql);
		}
		index = HASH_ATALK_ADDR(&pDdpAddr->ddpao_Addr) % NODE_DDPAO_HASH_SIZE;
		for (ppDdpAddr = &pNode->an_DdpAoHash[index];
			 *ppDdpAddr != NULL;
			 ppDdpAddr = &((*ppDdpAddr)->ddpao_Next))
		{
			if (*ppDdpAddr == pDdpAddr)
			{
				*ppDdpAddr = pDdpAddr->ddpao_Next;
				break;
			}
		}
		if (AtDpc)
		{
			RELEASE_SPIN_LOCK_DPC(&pNode->an_Lock);
		}
		else
		{
			RELEASE_SPIN_LOCK(&pNode->an_Lock, OldIrql);
		}

		DBGPRINT(DBG_COMP_DDP, DBG_LEVEL_INFO,
				("AtalkDdpDeref: Closing ddp socket %lx\n", pDdpAddr->ddpao_Addr.ata_Socket));

		if (pDdpAddr->ddpao_EventInfo != NULL)
		{
			AtalkFreeMemory(pDdpAddr->ddpao_EventInfo);
		}

		//	Call the completion routines
		if (*pDdpAddr->ddpao_CloseComp != NULL)
		{
			(*pDdpAddr->ddpao_CloseComp)(ATALK_NO_ERROR, pDdpAddr->ddpao_CloseCtx);
		}

		//	Free the address structure
		AtalkFreeMemory(pDdpAddr);

		//	Dereference the node for this address
		AtalkNodeDereference(pNode);
	}
}




VOID
AtalkDdpNewHandlerForSocket(
	IN	PDDP_ADDROBJ			pDdpAddr,
	IN	DDPAO_HANDLER			pSktHandler,
	IN	PVOID					pSktHandlerCtx
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	KIRQL	OldIrql;

	ASSERT (VALID_DDP_ADDROBJ(pDdpAddr));

	ACQUIRE_SPIN_LOCK(&pDdpAddr->ddpao_Lock, &OldIrql);

	pDdpAddr->ddpao_Handler = pSktHandler;
	pDdpAddr->ddpao_HandlerCtx = pSktHandlerCtx;

	RELEASE_SPIN_LOCK(&pDdpAddr->ddpao_Lock, OldIrql);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\atalk\sys\lists.h ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	lists.h

Abstract:

	This module contains the macros for managing lists

Author:

	Jameel Hyder (microsoft!jameelh)


Revision History:
	25 Oct 1992		Initial Version

Notes:	Tab stop: 4
--*/

#ifndef _LISTS_
#define _LISTS_

#define	AtalkLinkDoubleAtHead(_pHead, _p, Next, Prev)		\
	{														\
		(_p)->Next = (_pHead);								\
		(_p)->Prev = &(_pHead);								\
		if ((_pHead) != NULL)								\
		(_pHead)->Prev = &(_p)->Next;						\
			(_pHead) = (_p);								\
	}

#define	AtalkLinkDoubleAtEnd(_pThis, _pLast, Next, Prev)	\
	{														\
		(_pLast)->Next = (_pThis);							\
		(_pThis)->Prev = &(_pLast)->Next;					\
		(_pThis)->Next = NULL;								\
	}

#define	AtalkInsertDoubleBefore(_pThis, _pBefore, Next, Prev)\
	{														\
		(_pThis)->Next = (_pBefore);						\
		(_pThis)->Prev = (_pBefore)->Prev;					\
		(_pBefore)->Prev = &(_pThis)->Next;					\
		*((_pThis)->Prev) = (_pThis);						\
	}

#define	AtalkUnlinkDouble(_p, Next, Prev)					\
	{														\
		*((_p)->Prev) = (_p)->Next;							\
		if ((_p)->Next != NULL)								\
			(_p)->Next->Prev = (_p)->Prev;					\
	}

#endif	// _LISTS_


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\atalk\sys\nbp.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

	nbp.c

Abstract:

	This module contains nbp code

Author:

	Jameel Hyder (jameelh@microsoft.com)
	Nikhil Kamkolkar (nikhilk@microsoft.com)

Revision History:
	19 Jun 1992		Initial Version

Notes:	Tab stop: 4
--*/

#include <atalk.h>
#pragma hdrstop
#define	FILENUM		NBP

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE_NZ, AtalkNbpAction)
#pragma alloc_text(PAGE_NZ, atalkNbpLinkPendingNameInList)
#pragma alloc_text(PAGE_NZ, atalkNbpSendRequest)
#endif

/***	AtalkNbpPacketIn
 *
 */
VOID
AtalkNbpPacketIn(
	IN	PPORT_DESCRIPTOR	pPortDesc,
	IN	PDDP_ADDROBJ		pDdpAddr,
	IN	PBYTE				pPkt,
	IN	USHORT				PktLen,
	IN	PATALK_ADDR			pSrcAddr,
	IN	PATALK_ADDR			pDstAddr,
	IN	ATALK_ERROR			ErrorCode,
	IN	BYTE				DdpType,
	IN	PVOID				pHandlerCtx,
	IN	BOOLEAN				OptimizedPath,
	IN	PVOID				OptimizeCtx
	)
{
	PPEND_NAME		pPendName;
	PATALK_NODE		pNode;
	TIME			TimeS, TimeE, TimeD;
	PNBPHDR			pNbpHdr = (PNBPHDR)pPkt;
	PRTE			pRte;
	SHORT			i, NbpId, NbpCmd, TupleCnt;
	PNBPTUPLE		pNbpTuple = NULL, pInBufTuple = NULL;
	BOOLEAN			DefZone = FALSE, RestartTimer = FALSE;
    BOOLEAN         fWeCancelledTimer = TRUE;
	BOOLEAN			Found;

	ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

	TimeS = KeQueryPerformanceCounter(NULL);

	do
	{
		if ((ErrorCode == ATALK_SOCKET_CLOSED) || (DdpType != DDPPROTO_NBP))
			break;

		else if ((ErrorCode != ATALK_NO_ERROR) || (PktLen < sizeof(NBPHDR)))
		{
			break;
		}

		// Get NBP header information and decide what to do
		NbpCmd = (SHORT)((pNbpHdr->_CmdAndTupleCnt >> 4) & 0x0F);
		TupleCnt = (SHORT)(pNbpHdr->_CmdAndTupleCnt & 0x0F);
		NbpId = (SHORT)pNbpHdr->_NbpId;

		if ((pNbpTuple = AtalkAllocMemory(sizeof(NBPTUPLE))) == NULL)
		{
			TMPLOGERR();
			break;
		}

		switch (NbpCmd)
		{
		  case NBP_LOOKUP:
  			DBGPRINT(DBG_COMP_NBP, DBG_LEVEL_INFO,
					("atalkNbpPacketIn: Cmd Lookup\n"));
  			if ((TupleCnt == 1) &&
				(atalkNbpDecodeTuple(pPkt + sizeof(NBPHDR),
									 (USHORT)(PktLen - sizeof(NBPHDR)),
									 pNbpTuple) > 0))
			{
				atalkNbpLookupNames(pPortDesc, pDdpAddr, pNbpTuple, NbpId);
			}
			else
			{
#if 0
				AtalkLogBadPacket(pPortDesc,
								  pSrcAddr,
								  pDstAddr,
								  pPkt,
								  PktLen);
#endif
				break;
			}
			break;

		  case NBP_BROADCAST_REQUEST:
		  case NBP_FORWARD_REQUEST:
  			DBGPRINT(DBG_COMP_NBP, DBG_LEVEL_INFO,
					("atalkNbpPacketIn: Cmd %sRequest\n",
					(NbpCmd == NBP_BROADCAST_REQUEST) ? "Broadcast" : "Forward"));
			// We don't care if we are not a router
			if ((pPortDesc->pd_Flags & PD_ROUTER_RUNNING) == 0)
				break;

			if (TupleCnt != 1)
			{
				AtalkLogBadPacket(pPortDesc,
								  pSrcAddr,
								  pDstAddr,
								  pPkt,
								  PktLen);
				break;
			}
			if (atalkNbpDecodeTuple(pPkt + sizeof(NBPHDR),
									(USHORT)(PktLen - sizeof(NBPHDR)),
									pNbpTuple) == 0)
			{
				AtalkLogBadPacket(pPortDesc,
								  pSrcAddr,
								  pDstAddr,
								  pPkt,
								  PktLen);
				break;
			}
			if ((pNbpTuple->tpl_ZoneLen == 0) ||
				((pNbpTuple->tpl_Zone[0] == '*') && (pNbpTuple->tpl_ZoneLen == 1)))
				DefZone = TRUE;

			if (EXT_NET(pPortDesc))
			{
				if (DefZone)
				{
					AtalkLogBadPacket(pPortDesc,
									  pSrcAddr,
									  pDstAddr,
									  pPkt,
									  PktLen);
					break;
				}
			}
			else				// Non-extended network
			{
				if	(DefZone)
				{
					if (pPortDesc->pd_NetworkRange.anr_FirstNetwork != pSrcAddr->ata_Network)
					{
						DBGPRINT(DBG_COMP_NBP, DBG_LEVEL_ERR,
								("AtalkNbpPacketIn: LT Port, '*' zone - SrcAddr %d.%d, Net %d\n",
								pSrcAddr->ata_Network, pSrcAddr->ata_Node,
                                pPortDesc->pd_NetworkRange.anr_FirstNetwork));
								AtalkLogBadPacket(pPortDesc,
												  pSrcAddr,
												  pDstAddr,
												  pPkt,
												  PktLen);
						break;
					}
					if (!(pPortDesc->pd_Flags & PD_VALID_DESIRED_ZONE))
						break;

					ACQUIRE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);
					pNbpTuple->tpl_ZoneLen = pPortDesc->pd_DesiredZone->zn_ZoneLen;
					RtlCopyMemory(pNbpTuple->tpl_Zone,
								  pPortDesc->pd_DesiredZone->zn_Zone,
								  pPortDesc->pd_DesiredZone->zn_ZoneLen);
					RELEASE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);
				}
			}

			// For a forward request send a lookup datagram
			if (NbpCmd == NBP_FORWARD_REQUEST)
			{
				DBGPRINT(DBG_COMP_NBP, DBG_LEVEL_INFO,
						("AtalkNbpPacketIn: Sending NbpLookup for a NbpForwardRequest\n"));
				atalkNbpSendLookupDatagram(pPortDesc, pDdpAddr, NbpId, pNbpTuple);
				break;
			}

			// We have a broadcast request. Walk through the routing tables
			// sending either a forward request or a lookup (broadcast) to
			// each network that contains the specified zone
			ACQUIRE_SPIN_LOCK_DPC(&AtalkRteLock);

			for (i = 0;i < NUM_RTMP_HASH_BUCKETS; i++)
			{
				for (pRte = AtalkRoutingTable[i];
					 pRte != NULL;
					 pRte = pRte->rte_Next)
				{
					ATALK_ERROR			Status;

					// If the network is directly connected i.e. 0 hops away
					// use the zone-list in the PortDesc rather than the
					// routing table - the routing table may not be filled
					// in with a zone list (due to the normal ZipQuery mechanism)
					ACQUIRE_SPIN_LOCK_DPC(&pRte->rte_Lock);
					if (!(pRte->rte_Flags & RTE_ZONELIST_VALID))
					{
						if ((pRte->rte_NumHops != 0) ||
							!AtalkZoneNameOnList(pNbpTuple->tpl_Zone,
												 pNbpTuple->tpl_ZoneLen,
												 pRte->rte_PortDesc->pd_ZoneList))
						{
							RELEASE_SPIN_LOCK_DPC(&pRte->rte_Lock);
							continue;
						}
					}
					else if (!AtalkZoneNameOnList(pNbpTuple->tpl_Zone,
												  pNbpTuple->tpl_ZoneLen,
												  pRte->rte_ZoneList))
					{
						RELEASE_SPIN_LOCK_DPC(&pRte->rte_Lock);
						continue;
					}

					pRte->rte_RefCount ++;
					RELEASE_SPIN_LOCK_DPC(&pRte->rte_Lock);

					// If not a local network, send a forward request
					if (pRte->rte_NumHops != 0)
					{
						DBGPRINT(DBG_COMP_NBP, DBG_LEVEL_INFO,
								("AtalkNbpPacketIn: Sending NbpForwardRequest for a broadcast\n"));

						// Do not hold the Rte lock during a DdpSend
						RELEASE_SPIN_LOCK_DPC(&AtalkRteLock);
						atalkNbpSendForwardRequest(pDdpAddr,
												   pRte,
												   NbpId,
												   pNbpTuple);
						ACQUIRE_SPIN_LOCK_DPC(&AtalkRteLock);
						AtalkRtmpDereferenceRte(pRte, TRUE);
					}
					else
					{
						DBGPRINT(DBG_COMP_NBP, DBG_LEVEL_INFO,
								("AtalkNbpPacketIn: Sending Lookup for a broadcast\n"));
						// Send a lookup
						RELEASE_SPIN_LOCK_DPC(&AtalkRteLock);
						atalkNbpSendLookupDatagram(pRte->rte_PortDesc,
												   NULL,
												   NbpId,
												   pNbpTuple);
						ACQUIRE_SPIN_LOCK_DPC(&AtalkRteLock);
						AtalkRtmpDereferenceRte(pRte, TRUE);
					}
				}
			}

			RELEASE_SPIN_LOCK_DPC(&AtalkRteLock);
			break;

		  case NBP_LOOKUP_REPLY:
  			DBGPRINT(DBG_COMP_NBP, DBG_LEVEL_INFO,
					("atalkNbpPacketIn: Cmd LookupReply\n"));
  			// This had better be a response to a previous lookup
			// Look for a pending name on all open sockets on this node

			if (TupleCnt == 0)
				break;

			// Decode the tuple for Register/Confirm case
			if (atalkNbpDecodeTuple(pPkt + sizeof(NBPHDR),
									(USHORT)(PktLen - sizeof(NBPHDR)),
									pNbpTuple) == 0)
			{
				break;
			}

			pNode = pDdpAddr->ddpao_Node;
			ACQUIRE_SPIN_LOCK_DPC(&pNode->an_Lock);

			Found = FALSE;
			for (i = 0; (i < NODE_DDPAO_HASH_SIZE) && !Found; i++)
			{
				PDDP_ADDROBJ	pSkt;

				for (pSkt = pNode->an_DdpAoHash[i];
					 (pSkt != NULL) && !Found;
					 pSkt = pSkt->ddpao_Next)
				{
					PPEND_NAME	*	ppPendName;

					ACQUIRE_SPIN_LOCK_DPC(&pSkt->ddpao_Lock);

					for (ppPendName = &pSkt->ddpao_PendNames;
						 (pPendName = *ppPendName) != NULL;
						 ppPendName = &pPendName->pdn_Next)
					{
						ASSERT (VALID_PENDNAME(pPendName));

						if (pPendName->pdn_Flags & PDN_CLOSING)
						{
							continue;
						}

						if (pPendName->pdn_NbpId == NbpId)
						{
							DBGPRINT(DBG_COMP_NBP, DBG_LEVEL_INFO,
								("atalkNbpPacketIn: LookupReply Found name\n"));
							Found = TRUE;
							ACQUIRE_SPIN_LOCK_DPC(&pPendName->pdn_Lock);
							pPendName->pdn_RefCount ++;
							RELEASE_SPIN_LOCK_DPC(&pPendName->pdn_Lock);
							break;
						}
					}

					RELEASE_SPIN_LOCK_DPC(&pSkt->ddpao_Lock);
				}
			}

			RELEASE_SPIN_LOCK_DPC(&pNode->an_Lock);

			// If the timer fired just before we could find and cancel it
			if (pPendName == NULL)
				break;

			do
			{
				if (AtalkTimerCancelEvent(&pPendName->pdn_Timer, NULL))
				{
					// if the timer was successfully cancelled, take away
					// the reference for it
					atalkNbpDerefPendName(pPendName);
					RestartTimer = TRUE;
				}
                else
                {
                    fWeCancelledTimer = FALSE;
                }

				if ((pPendName->pdn_Reason == FOR_REGISTER) ||
					(pPendName->pdn_Reason == FOR_CONFIRM))
				{
					BOOLEAN	NoMatch;

					// Does the reply match the one we're trying to register ?
					NoMatch = ( (TupleCnt != 1) ||
								(pPendName->pdn_pRegdName == NULL) ||
								!AtalkFixedCompareCaseInsensitive(
									pPendName->pdn_pRegdName->rdn_Tuple.tpl_Object,
									pPendName->pdn_pRegdName->rdn_Tuple.tpl_ObjectLen,
									pNbpTuple->tpl_Object,
									pNbpTuple->tpl_ObjectLen) ||
								!AtalkFixedCompareCaseInsensitive(
									pPendName->pdn_pRegdName->rdn_Tuple.tpl_Type,
									pPendName->pdn_pRegdName->rdn_Tuple.tpl_TypeLen,
									pNbpTuple->tpl_Type,
									pNbpTuple->tpl_TypeLen));

					if (NoMatch)
					{
						if (TupleCnt != 1)
							AtalkLogBadPacket(pPortDesc,
											  pSrcAddr,
											  pDstAddr,
											  pPkt,
											  PktLen);
						break;
					}

					// If we are registering, we're done as someone already
					// has our name
					if (pPendName->pdn_Reason == FOR_REGISTER)
					{
						DBGPRINT(DBG_COMP_NBP, DBG_LEVEL_INFO,
								("atalkNbpPacketIn: Register failure\n"));
						ACQUIRE_SPIN_LOCK_DPC(&pPendName->pdn_Lock);
						pPendName->pdn_Status = ATALK_SHARING_VIOLATION;
						pPendName->pdn_Flags |= PDN_CLOSING;
						RELEASE_SPIN_LOCK_DPC(&pPendName->pdn_Lock);
						if (fWeCancelledTimer)
						{
							atalkNbpDerefPendName(pPendName);	// Take away creation ref
						}
						RestartTimer = FALSE;
						break;
					}

					// We're confirming, if no match get out
					if ((pPendName->pdn_ConfirmAddr.ata_Network != pNbpTuple->tpl_Address.ata_Network) ||
						(pPendName->pdn_ConfirmAddr.ata_Node != pNbpTuple->tpl_Address.ata_Node))
					{
						break;
					}

					DBGPRINT(DBG_COMP_NBP, DBG_LEVEL_INFO,
							("atalkNbpPacketIn: Confirm success\n"));
					ACQUIRE_SPIN_LOCK_DPC(&pPendName->pdn_Lock);
					pPendName->pdn_Status = ATALK_NO_ERROR;
					((PNBP_CONFIRM_PARAMS)(pPendName->pdn_pActReq->ar_pParms))->ConfirmTuple.Address.Address =
															pNbpTuple->tpl_Address.ata_Address;
					if (pPendName->pdn_ConfirmAddr.ata_Socket != pNbpTuple->tpl_Address.ata_Socket)
					{
						pPendName->pdn_Status = ATALK_NEW_SOCKET;
					}
					pPendName->pdn_Flags |= PDN_CLOSING;
					RELEASE_SPIN_LOCK_DPC(&pPendName->pdn_Lock);
					atalkNbpDerefPendName(pPendName);	// Take away creation ref
					RestartTimer = FALSE;
				}

				else			// FOR_LOOKUP
				{
					int			i, j, tmp, NextTupleOff = sizeof(NBPHDR);
					BOOLEAN		Done = FALSE;
					ULONG		BytesCopied;

					DBGPRINT(DBG_COMP_NBP, DBG_LEVEL_INFO,
							("atalkNbpPacketIn: Lookup searching...\n"));

					// Allocate space for an NBP tuple for copying and comparing
					// Failure to allocate can result in duplicates - so be it
					if (pInBufTuple == NULL)
						pInBufTuple = AtalkAllocMemory(sizeof(NBPTUPLE));
					for (i = 0; i < TupleCnt && !Done; i++)
					{
						BOOLEAN	Duplicate = FALSE;

						// If we encounter a bad tuple, ignore the rest. Drop tuples which are
						// our names and we are set to drop them !!!
						if (((tmp = atalkNbpDecodeTuple(pPkt + NextTupleOff,
														(USHORT)(PktLen - NextTupleOff),
														pNbpTuple)) == 0) ||
							(AtalkFilterOurNames &&
							(((pNbpTuple->tpl_Address.ata_Network == AtalkUserNode1.atn_Network) &&
							  (pNbpTuple->tpl_Address.ata_Node == AtalkUserNode1.atn_Node)) ||
							 ((pNbpTuple->tpl_Address.ata_Network == AtalkUserNode2.atn_Network) &&
							  (pNbpTuple->tpl_Address.ata_Node == AtalkUserNode2.atn_Node)))))
							break;

						NextTupleOff += tmp;
						ACQUIRE_SPIN_LOCK_DPC(&pPendName->pdn_Lock);

						// Now walk through the tuples that we already picked
						// up and drop duplicates
						if (pInBufTuple != NULL)
						{
							for (j = 0; j < pPendName->pdn_TotalTuples; j++)
							{
								TdiCopyMdlToBuffer(pPendName->pdn_pAMdl,
													j * sizeof(NBPTUPLE),
													(PBYTE)pInBufTuple,
													0,
													sizeof(NBPTUPLE),
													&BytesCopied);
								ASSERT (BytesCopied == sizeof(NBPTUPLE));
	
								if ((pInBufTuple->tpl_Address.ata_Network ==
											pNbpTuple->tpl_Address.ata_Network) &&
									(pInBufTuple->tpl_Address.ata_Node ==
											pNbpTuple->tpl_Address.ata_Node) &&
									(pInBufTuple->tpl_Address.ata_Socket ==
											pNbpTuple->tpl_Address.ata_Socket))
								{
									Duplicate = TRUE;
									break;
								}
							}
							if (Duplicate)
							{
								RELEASE_SPIN_LOCK_DPC(&pPendName->pdn_Lock);
								continue;
							}
						}

						// We are guaranteed that there is space available
						// for another tuple.
						TdiCopyBufferToMdl((PBYTE)pNbpTuple,
											0,
											sizeof(NBPTUPLE),
											pPendName->pdn_pAMdl,
											pPendName->pdn_TotalTuples * sizeof(NBPTUPLE),
											&BytesCopied);
						ASSERT (BytesCopied == sizeof(NBPTUPLE));

						DBGPRINT(DBG_COMP_NBP, DBG_LEVEL_INFO,
								("atalkNbpPacketIn: Lookup, found a tuple\n"));
						pPendName->pdn_TotalTuples ++;

						if ((pPendName->pdn_TotalTuples == pPendName->pdn_MaxTuples) ||
							(pPendName->pdn_MdlLength -
								(pPendName->pdn_TotalTuples * sizeof(NBPTUPLE)) <
														sizeof(NBPTUPLE)))
						{
							Done = TRUE;
							((PNBP_LOOKUP_PARAMS)(pPendName->pdn_pActReq->ar_pParms))->NoTuplesRead =
														pPendName->pdn_TotalTuples;
							pPendName->pdn_Status = ATALK_NO_ERROR;
							pPendName->pdn_Flags |= PDN_CLOSING;

							RestartTimer = FALSE;
						}

						RELEASE_SPIN_LOCK_DPC(&pPendName->pdn_Lock);

						if (Done)
						{
							DBGPRINT(DBG_COMP_NBP, DBG_LEVEL_INFO,
								("atalkNbpPacketIn: Lookup calling completion\n"));

                            if (fWeCancelledTimer)
                            {
							    atalkNbpDerefPendName(pPendName);	// Take away creation ref
                            }
							break;
						}
					}
				}
			} while (FALSE);

			if (RestartTimer)
			{
				DBGPRINT(DBG_COMP_NBP, DBG_LEVEL_INFO,
						("atalkNbpPacketIn: Restarting timer\n"));

				ACQUIRE_SPIN_LOCK_DPC(&pPendName->pdn_Lock);
				pPendName->pdn_RefCount ++;
				RELEASE_SPIN_LOCK_DPC(&pPendName->pdn_Lock);
				AtalkTimerScheduleEvent(&pPendName->pdn_Timer);
			}
			atalkNbpDerefPendName(pPendName);
			break;

		  default:
			AtalkLogBadPacket(pPortDesc,
							  pSrcAddr,
							  pDstAddr,
							  pPkt,
							  PktLen);
			break;
		}
	} while (FALSE);

	if (pNbpTuple != NULL)
		AtalkFreeMemory(pNbpTuple);

	if (pInBufTuple != NULL)
		AtalkFreeMemory(pInBufTuple);

	TimeE = KeQueryPerformanceCounter(NULL);
	TimeD.QuadPart = TimeE.QuadPart - TimeS.QuadPart;

	INTERLOCKED_ADD_LARGE_INTGR(
		&pPortDesc->pd_PortStats.prtst_NbpPacketInProcessTime,
		TimeD,
		&AtalkStatsLock.SpinLock);

	INTERLOCKED_INCREMENT_LONG_DPC(
		&pPortDesc->pd_PortStats.prtst_NumNbpPacketsIn,
		&AtalkStatsLock.SpinLock);
}


/***	atalkNbpTimer
 *
 */
LOCAL LONG FASTCALL
atalkNbpTimer(
	IN	PTIMERLIST		pTimer,
	IN	BOOLEAN			TimerShuttingDown
)
{
	PPEND_NAME		pCurrPendName;
	ATALK_ERROR		error;
	PDDP_ADDROBJ	pDdpAddr;
	BOOLEAN			RestartTimer = TRUE;
	BYTE			Reason;

	pCurrPendName = (PPEND_NAME)CONTAINING_RECORD(pTimer, PEND_NAME, pdn_Timer);
	ASSERT (VALID_PENDNAME(pCurrPendName));


	Reason = pCurrPendName->pdn_Reason;
	ASSERT ((Reason == FOR_REGISTER) ||
			(Reason == FOR_LOOKUP)	||
			(Reason == FOR_CONFIRM));

	pDdpAddr = pCurrPendName->pdn_pDdpAddr;

	DBGPRINT(DBG_COMP_NBP, DBG_LEVEL_INFO,
			("atalkNbpTimer: For Socket %lx, PendName %lx\n",
			pDdpAddr, pCurrPendName));

	ACQUIRE_SPIN_LOCK_DPC(&pCurrPendName->pdn_Lock);

	if (TimerShuttingDown ||
		(pCurrPendName->pdn_Flags & PDN_CLOSING))
		    pCurrPendName->pdn_RemainingBroadcasts = 1;

	if (--(pCurrPendName->pdn_RemainingBroadcasts) == 0)
	{
		RestartTimer = FALSE;
		if (Reason == FOR_REGISTER)
		{
			DBGPRINT(DBG_COMP_NBP, DBG_LEVEL_INFO,
					("atalkNbpTimer: Register success\n"));

			ACQUIRE_SPIN_LOCK_DPC(&pDdpAddr->ddpao_Lock);
			pCurrPendName->pdn_pRegdName->rdn_Next = pDdpAddr->ddpao_RegNames;
			pDdpAddr->ddpao_RegNames = pCurrPendName->pdn_pRegdName;
			RELEASE_SPIN_LOCK_DPC(&pDdpAddr->ddpao_Lock);

			pCurrPendName->pdn_Flags &= ~PDN_FREE_REGDNAME;
		}
		pCurrPendName->pdn_Flags |= PDN_CLOSING;
	}

	DBGPRINT(DBG_COMP_NBP, DBG_LEVEL_INFO,
			("atalkNbpTimer: Remaining broadcasts %d\n",
			pCurrPendName->pdn_RemainingBroadcasts));

	if (RestartTimer)
	{
		pCurrPendName->pdn_RefCount ++;
		RELEASE_SPIN_LOCK_DPC(&pCurrPendName->pdn_Lock);

		DBGPRINT(DBG_COMP_NBP, DBG_LEVEL_INFO,
				("atalkNbpTimer: Sending another request\n"));

		if (!atalkNbpSendRequest(pCurrPendName))
		{
			DBGPRINT(DBG_COMP_NBP, DBG_LEVEL_ERR,
					("atalkNbpTimer: atalkNbpSendRequest failed\n"));
		}
	}
	else
	{
		RELEASE_SPIN_LOCK_DPC(&pCurrPendName->pdn_Lock);
		error = ATALK_NO_ERROR;
		if (Reason == FOR_CONFIRM)
		{
			DBGPRINT(DBG_COMP_NBP, DBG_LEVEL_INFO,
					("atalkNbpTimer: Confirm Failure\n"));
			error = ATALK_TIMEOUT;
		}
		else if (Reason == FOR_LOOKUP)
		{
			((PNBP_LOOKUP_PARAMS)(pCurrPendName->pdn_pActReq->ar_pParms))->NoTuplesRead =
								pCurrPendName->pdn_TotalTuples;
		}

		DBGPRINT(DBG_COMP_NBP, DBG_LEVEL_INFO,
				("atalkNbpTimer: Calling completion routine\n"));
		pCurrPendName->pdn_Status = error;

		atalkNbpDerefPendName(pCurrPendName);	// Take away creation reference
	}
	atalkNbpDerefPendName(pCurrPendName);

	return (RestartTimer ? ATALK_TIMER_REQUEUE : ATALK_TIMER_NO_REQUEUE);
}


/***	atalkNbpLookupNames
 *
 */
LOCAL VOID
atalkNbpLookupNames(
	IN	PPORT_DESCRIPTOR	pPortDesc,
	IN	PDDP_ADDROBJ		pDdpAddr,
	IN	PNBPTUPLE			pNbpTuple,
	IN	SHORT				NbpId
)
{
	int				i, index, TupleCnt;
	BOOLEAN			AllocNewBuffDesc = TRUE;
	PBUFFER_DESC	pBuffDesc,
					pBuffDescStart = NULL,
					*ppBuffDesc = &pBuffDescStart;
	PATALK_NODE		pNode = pDdpAddr->ddpao_Node;
	SEND_COMPL_INFO	SendInfo;
	PBYTE			Datagram;

	ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

	DBGPRINT(DBG_COMP_NBP, DBG_LEVEL_INFO,
			("atalkNbpLookupNames: Entered\n"));

	// Does the requestor atleast has the right zone ?
	if ((pNbpTuple->tpl_Zone[0] != '*') ||
		(pNbpTuple->tpl_ZoneLen != 1))
	{
		// If either we do not know our zone or if it does not match or
		// we are an extended network, return - we have nothing to do
		if (EXT_NET(pPortDesc))
		{
			if (!(pPortDesc->pd_Flags & PD_VALID_DESIRED_ZONE) ||
				((pPortDesc->pd_DesiredZone == NULL) ?1:
				 (!AtalkFixedCompareCaseInsensitive(pNbpTuple->tpl_Zone,
							pNbpTuple->tpl_ZoneLen,
							pPortDesc->pd_DesiredZone->zn_Zone,
							pPortDesc->pd_DesiredZone->zn_ZoneLen))))
			{
				return;
			}
		}
	}

	// Walk the registered names list on all sockets open on this node and
	// see if we have a matching name. We have to walk the pending names
	// list also (should not answer, if we the node trying to register the
	// name).

	ACQUIRE_SPIN_LOCK_DPC(&pDdpAddr->ddpao_Node->an_Lock);

	for (i = 0; i < NODE_DDPAO_HASH_SIZE; i++)
	{
		PDDP_ADDROBJ	pSkt;

		for (pSkt = pNode->an_DdpAoHash[i];
			 pSkt != NULL;
			 pSkt = pSkt->ddpao_Next)
		{
			PREGD_NAME		pRegdName;
			PPEND_NAME		pPendName;

			ACQUIRE_SPIN_LOCK_DPC(&pSkt->ddpao_Lock);

			DBGPRINT(DBG_COMP_NBP, DBG_LEVEL_INFO,
					("atalkNbpLookupNames: Checking Socket %lx\n", pSkt));

			// First check registered names
			for (pRegdName = pSkt->ddpao_RegNames;
				 pRegdName != NULL;
				 pRegdName = pRegdName->rdn_Next)
			{
				ASSERT (VALID_REGDNAME(pRegdName));
				DBGPRINT(DBG_COMP_NBP, DBG_LEVEL_INFO,
						("atalkNbpLookupNames: Checking RegdName %lx\n", pRegdName));

				if (!atalkNbpMatchWild(pNbpTuple->tpl_Object,
									   pNbpTuple->tpl_ObjectLen,
									   pRegdName->rdn_Tuple.tpl_Object,
									   pRegdName->rdn_Tuple.tpl_ObjectLen) ||
					!atalkNbpMatchWild(pNbpTuple->tpl_Type,
									   pNbpTuple->tpl_TypeLen,
									   pRegdName->rdn_Tuple.tpl_Type,
									   pRegdName->rdn_Tuple.tpl_TypeLen))
					continue;

				// Allocate a new buffer descriptor, if we must
				if (AllocNewBuffDesc)
				{
					if ((pBuffDesc = AtalkAllocBuffDesc(NULL,
										MAX_DGRAM_SIZE,
										BD_CHAR_BUFFER | BD_FREE_BUFFER)) == NULL)
						break;
					Datagram = pBuffDesc->bd_CharBuffer;
					index = sizeof(NBPHDR);
					TupleCnt = 0;
					*ppBuffDesc = pBuffDesc;
					pBuffDesc->bd_Next = NULL;
					ppBuffDesc = &pBuffDesc->bd_Next;
					AllocNewBuffDesc = FALSE;
				}

				// We have a match. Build complete Nbp tuple
				index += atalkNbpEncodeTuple(&pRegdName->rdn_Tuple,
											 "*",
											 1,
											 0,
											 Datagram+index);
				TupleCnt ++;

				if (((index + MAX_NBP_TUPLELENGTH) > MAX_DGRAM_SIZE) ||
					(TupleCnt == 0x0F))
				{
					((PNBPHDR)Datagram)->_NbpId = (BYTE)NbpId;
					((PNBPHDR)Datagram)->_CmdAndTupleCnt =
											(NBP_LOOKUP_REPLY << 4) + TupleCnt;
					AllocNewBuffDesc = TRUE;
					pBuffDesc->bd_Length = (SHORT)index;
				}
			}

			// Now check pending names
			for (pPendName = pSkt->ddpao_PendNames;
				 pPendName != NULL;
				 pPendName = pPendName->pdn_Next)
			{
				ASSERT (VALID_PENDNAME(pPendName));
				DBGPRINT(DBG_COMP_NBP, DBG_LEVEL_INFO,
						("atalkNbpLookupNames: Checking PendName %lx\n", pPendName));

				// Ignore all but the ones that are being registered
				if (pPendName->pdn_Reason != FOR_REGISTER)
					continue;

				// Also those that we are registering
				if ((pSkt->ddpao_Node->an_NodeAddr.atn_Network ==
										pNbpTuple->tpl_Address.ata_Network) &&
					(pSkt->ddpao_Node->an_NodeAddr.atn_Node ==
										pNbpTuple->tpl_Address.ata_Node) &&
					(pPendName->pdn_NbpId == (BYTE)NbpId))
					continue;

				if ((pPendName->pdn_pRegdName == NULL) ||
					!atalkNbpMatchWild(
								pNbpTuple->tpl_Object,
								pNbpTuple->tpl_ObjectLen,
								pPendName->pdn_pRegdName->rdn_Tuple.tpl_Object,
								pPendName->pdn_pRegdName->rdn_Tuple.tpl_ObjectLen) ||
					 !atalkNbpMatchWild(
								pNbpTuple->tpl_Type,
								pNbpTuple->tpl_TypeLen,
								pPendName->pdn_pRegdName->rdn_Tuple.tpl_Type,
								pPendName->pdn_pRegdName->rdn_Tuple.tpl_TypeLen))
				{
					continue;
				}

				// Allocate a new buffer descriptor, if we must
				if (AllocNewBuffDesc)
				{
					if ((pBuffDesc = AtalkAllocBuffDesc(NULL,
										MAX_DGRAM_SIZE,
										BD_CHAR_BUFFER | BD_FREE_BUFFER)) == NULL)
					break;
					Datagram = pBuffDesc->bd_CharBuffer;
					index = sizeof(NBPHDR);
					TupleCnt = 0;
					*ppBuffDesc = pBuffDesc;
					pBuffDesc->bd_Next = NULL;
					ppBuffDesc = &pBuffDesc->bd_Next;
					AllocNewBuffDesc = FALSE;
				}

				// We have a match. Build complete Nbp tuple
				index += atalkNbpEncodeTuple(&pPendName->pdn_pRegdName->rdn_Tuple,
											 "*",
											 1,
											 0,
											 Datagram+index);

				TupleCnt ++;

				if (((index + MAX_NBP_TUPLELENGTH) > MAX_DGRAM_SIZE) ||
					(TupleCnt == 0x0F))
				{
					((PNBPHDR)Datagram)->_NbpId = (BYTE)NbpId;
					((PNBPHDR)Datagram)->_CmdAndTupleCnt =
											(NBP_LOOKUP_REPLY << 4) + TupleCnt;
					AllocNewBuffDesc = TRUE;
					pBuffDesc->bd_Length = (SHORT)index;
				}
			}

			RELEASE_SPIN_LOCK_DPC(&pSkt->ddpao_Lock);
		}
	}

	RELEASE_SPIN_LOCK_DPC(&pDdpAddr->ddpao_Node->an_Lock);

	// Close the current buffdesc
	if (!AllocNewBuffDesc)
	{
		((PNBPHDR)Datagram)->_NbpId = (BYTE)NbpId;
		((PNBPHDR)Datagram)->_CmdAndTupleCnt = (NBP_LOOKUP_REPLY << 4) + TupleCnt;
		pBuffDesc->bd_Length = (SHORT)index;

	}

	// Now blast off all the datagrams that we have filled up
	SendInfo.sc_TransmitCompletion = atalkNbpSendComplete;
	// SendInfo.sc_Ctx2 = NULL;
	// SendInfo.sc_Ctx3 = NULL;
	for (pBuffDesc = pBuffDescStart;
		 pBuffDesc != NULL;
		 pBuffDesc = pBuffDescStart)
	{
		ATALK_ERROR	ErrorCode;

		DBGPRINT(DBG_COMP_NBP, DBG_LEVEL_INFO,
				("atalkNbpLookupNames: Sending lookup response\n"));

		pBuffDescStart = pBuffDesc->bd_Next;
		pBuffDesc->bd_Next = NULL;

		DBGPRINT(DBG_COMP_NBP, DBG_LEVEL_INFO,
				("atalkNbpLookupNames: Sending %lx\n", pBuffDesc));

		ASSERT(pBuffDesc->bd_Length > 0);

		//	Length is already properly set in the buffer descriptor.
		SendInfo.sc_Ctx1 = pBuffDesc;
		ErrorCode = AtalkDdpSend(pDdpAddr,
								 &pNbpTuple->tpl_Address,
								 DDPPROTO_NBP,
								 FALSE,
								 pBuffDesc,
								 NULL,
								 0,
								 NULL,
								 &SendInfo);

		if (!ATALK_SUCCESS(ErrorCode))
		{
			DBGPRINT(DBG_COMP_NBP, DBG_LEVEL_WARN,
					("atalkNbpLookupNames: DdpSend failed %ld\n", ErrorCode));
			AtalkFreeBuffDesc(pBuffDesc);
		}
	}
}


/***	AtalkNbpAction
 *
 */
ATALK_ERROR
AtalkNbpAction(
	IN	PDDP_ADDROBJ		pDdpAddr,
	IN	BYTE				Reason,
	IN	PNBPTUPLE			pNbpTuple,
	OUT	PAMDL				pAMdl			OPTIONAL,	// FOR_LOOKUP
	IN	USHORT				MaxTuples		OPTIONAL,	// FOR_LOOKUP
	IN	PACTREQ				pActReq
)
{
	PPORT_DESCRIPTOR	pPortDesc;
	PPEND_NAME			pPendName = NULL;
	PREGD_NAME			pRegdName = NULL;
	ATALK_ERROR			Status = ATALK_INVALID_PARAMETER;
	LONG				MdlLen = 0;
	BOOLEAN				DefZone = FALSE;

	ASSERT (Reason == FOR_REGISTER	||
			Reason == FOR_CONFIRM	||
			Reason == FOR_LOOKUP);

	do
	{
		if ((pNbpTuple->tpl_ObjectLen == 0)					||
			(pNbpTuple->tpl_ObjectLen > MAX_ENTITY_LENGTH)	||
			(pNbpTuple->tpl_TypeLen == 0)					||
			(pNbpTuple->tpl_TypeLen > MAX_ENTITY_LENGTH))
			break;

		if ((Reason == FOR_LOOKUP) &&
			((pAMdl == NULL) ||
			((MdlLen = AtalkSizeMdlChain(pAMdl)) < sizeof(NBPTUPLE))))
		{
			Status = ATALK_BUFFER_TOO_SMALL;
			break;
		}

		pPortDesc = pDdpAddr->ddpao_Node->an_Port;
		if (pNbpTuple->tpl_ZoneLen != 0)
		{
			if (pNbpTuple->tpl_ZoneLen > MAX_ENTITY_LENGTH)
				break;

			if (((pNbpTuple->tpl_Zone[0] == '*') && (pNbpTuple->tpl_ZoneLen == 1)) ||
				((pPortDesc->pd_DesiredZone != NULL) &&
				 AtalkFixedCompareCaseInsensitive(pNbpTuple->tpl_Zone,
												  pNbpTuple->tpl_ZoneLen,
												  pPortDesc->pd_DesiredZone->zn_Zone,
												  pPortDesc->pd_DesiredZone->zn_ZoneLen)))
			{
				DefZone = TRUE;
			}
		}
		else
		{
			pNbpTuple->tpl_Zone[0] = '*';
			pNbpTuple->tpl_ZoneLen = 1;
			DefZone = TRUE;
		}

		if (Reason != FOR_LOOKUP)	// i.e. REGISTER or CONFIRM
		{
			if ((pNbpTuple->tpl_Object[0] == '=')	||
				(pNbpTuple->tpl_Type[0] == '=')		||
				(AtalkSearchBuf(pNbpTuple->tpl_Object,
								pNbpTuple->tpl_ObjectLen,
								NBP_WILD_CHARACTER) != NULL) ||
				(AtalkSearchBuf(pNbpTuple->tpl_Type,
								pNbpTuple->tpl_TypeLen,
								NBP_WILD_CHARACTER) != NULL))
				break;

			if ((Reason == FOR_REGISTER) && !DefZone)
				break;
		}

		// For extended networks, set the zone name correctly
		if (DefZone &&
			(pPortDesc->pd_Flags & (PD_EXT_NET | PD_VALID_DESIRED_ZONE)) ==
									(PD_EXT_NET | PD_VALID_DESIRED_ZONE))
		{
			RtlCopyMemory(pNbpTuple->tpl_Zone,
						  pPortDesc->pd_DesiredZone->zn_Zone,
						  pPortDesc->pd_DesiredZone->zn_ZoneLen);
			pNbpTuple->tpl_ZoneLen = pPortDesc->pd_DesiredZone->zn_ZoneLen;
		}

		// Start by building the pending name structure. This needs to be linked
		// to the socket holding the spin lock and getting a unique enumerator
		// and an nbp id. If either of these fail, then we undo the stuff.
		if (((pPendName = (PPEND_NAME)AtalkAllocZeroedMemory(sizeof(PEND_NAME))) == NULL) ||
			((pRegdName = (PREGD_NAME)AtalkAllocZeroedMemory(sizeof(REGD_NAME))) == NULL))
		{
			if (pPendName != NULL)
			{
				AtalkFreeMemory(pPendName);
				pPendName = NULL;
			}
			Status = ATALK_RESR_MEM;
			break;
		}

		DBGPRINT(DBG_COMP_NBP, DBG_LEVEL_INFO,
				("AtalkNbpAction: %s, Socket %lx, PendName %lx, RegdName %lx\n",
				(Reason == FOR_REGISTER) ? "Register" :
					((Reason == FOR_CONFIRM) ? "Confirm" : "Lookup"),
				pDdpAddr, pPendName, pRegdName));

#if	DBG
		pRegdName->rdn_Signature = RDN_SIGNATURE;
		pPendName->pdn_Signature = PDN_SIGNATURE;
#endif
		pRegdName->rdn_Tuple.tpl_ObjectLen = pNbpTuple->tpl_ObjectLen;;
		RtlCopyMemory(pRegdName->rdn_Tuple.tpl_Object,
					  pNbpTuple->tpl_Object,
					  pNbpTuple->tpl_ObjectLen);
		pRegdName->rdn_Tuple.tpl_TypeLen = pNbpTuple->tpl_TypeLen;;
		RtlCopyMemory(pRegdName->rdn_Tuple.tpl_Type,
					  pNbpTuple->tpl_Type,
					  pNbpTuple->tpl_TypeLen);
		pRegdName->rdn_Tuple.tpl_ZoneLen = pNbpTuple->tpl_ZoneLen;;
		RtlCopyMemory(pRegdName->rdn_Tuple.tpl_Zone,
					  pNbpTuple->tpl_Zone,
					  pNbpTuple->tpl_ZoneLen);

		pRegdName->rdn_Tuple.tpl_Address.ata_Address = pDdpAddr->ddpao_Addr.ata_Address;

		pPendName->pdn_pRegdName = pRegdName;

		INITIALIZE_SPIN_LOCK(&pPendName->pdn_Lock);
		pPendName->pdn_RefCount = 3;	// Reference for creation, timer & for ourselves
		pPendName->pdn_pDdpAddr = pDdpAddr;
		AtalkDdpReferenceByPtr(pDdpAddr, &Status);
		ASSERT(ATALK_SUCCESS(Status));

		pPendName->pdn_Flags = PDN_FREE_REGDNAME;
		pPendName->pdn_Reason = Reason;
		pPendName->pdn_pActReq = pActReq;
		pPendName->pdn_RemainingBroadcasts = NBP_NUM_BROADCASTS;
		AtalkTimerInitialize(&pPendName->pdn_Timer,
							 atalkNbpTimer,
							 NBP_BROADCAST_INTERVAL);
		if (Reason == FOR_CONFIRM)
			pPendName->pdn_ConfirmAddr = pNbpTuple->tpl_Address;

		else if (Reason == FOR_LOOKUP)
		{
			pPendName->pdn_pAMdl = pAMdl;
			pPendName->pdn_MdlLength = (USHORT)MdlLen;
			pPendName->pdn_TotalTuples = 0;
			pPendName->pdn_MaxTuples = MaxTuples;

			// If we are not doing a wild card search, restrict
			// the tuples to one so we get out early instead of
			// the max. time-out since we are never going to
			// fill the buffer
			if (!((pNbpTuple->tpl_Object[0] == '=')				||
				 (pNbpTuple->tpl_Type[0] == '=')				||
				 (pNbpTuple->tpl_Zone[0] == '=')				||
				 (AtalkSearchBuf(pNbpTuple->tpl_Object,
								pNbpTuple->tpl_ObjectLen,
								NBP_WILD_CHARACTER) != NULL)	||
				 (AtalkSearchBuf(pNbpTuple->tpl_Type,
								pNbpTuple->tpl_TypeLen,
								NBP_WILD_CHARACTER) != NULL)	||
				 (AtalkSearchBuf(pNbpTuple->tpl_Zone,
								pNbpTuple->tpl_ZoneLen,
								NBP_WILD_CHARACTER) != NULL)))
			{
				pPendName->pdn_MaxTuples = 1;
			}
		}

		// We're going to send a directed lookup for confirms, or either a
		// broadcast request or a lookup for registers or lookup depending
		// on whether we know about a router or not. We do not have to bother
		// checking the registered names list, for register, in our node
		// because the broadcast will eventually get to us and we'll handle
		// it then ! Request packet, with one tuple

		if (Reason == FOR_CONFIRM)	// Send to confirming node
			((PNBPHDR)(pPendName->pdn_Datagram))->_CmdAndTupleCnt =
											(NBP_LOOKUP << 4) + 1;
		else if (pPortDesc->pd_Flags & PD_SEEN_ROUTER_RECENTLY)
			((PNBPHDR)(pPendName->pdn_Datagram))->_CmdAndTupleCnt =
											(NBP_BROADCAST_REQUEST << 4) + 1;
		else ((PNBPHDR)(pPendName->pdn_Datagram))->_CmdAndTupleCnt =
											(NBP_LOOKUP << 4) + 1;

		pPendName->pdn_DatagramLength = sizeof(NBPHDR) +
					atalkNbpEncodeTuple(&pPendName->pdn_pRegdName->rdn_Tuple,
										NULL,
										0,
										// NAMESINFORMATION_SOCKET,
										LAST_DYNAMIC_SOCKET,
										pPendName->pdn_Datagram + sizeof(NBPHDR));
		// Alloc an Nbp Id and an enumerator and link it into the list
		atalkNbpLinkPendingNameInList(pDdpAddr, pPendName);

		((PNBPHDR)(pPendName->pdn_Datagram))->_NbpId = (BYTE)(pPendName->pdn_NbpId);

		AtalkTimerScheduleEvent(&pPendName->pdn_Timer);

		atalkNbpSendRequest(pPendName);

		atalkNbpDerefPendName(pPendName);		// We are done now.

		Status = ATALK_PENDING;
	} while (FALSE);

	return Status;
}


/***	AtalkNbpRemove
 *
 */
ATALK_ERROR
AtalkNbpRemove(
	IN	PDDP_ADDROBJ	pDdpAddr,
	IN	PNBPTUPLE		pNbpTuple,
	IN	PACTREQ			pActReq
)
{
	PREGD_NAME	pRegdName, *ppRegdName;
	KIRQL		OldIrql;
	ATALK_ERROR	Status = ATALK_INVALID_PARAMETER;

	do
	{
		// Remove a registered NBP name. Zone must either be NULL or "*"
		if ((pNbpTuple->tpl_ObjectLen == 0) ||
			(pNbpTuple->tpl_ObjectLen > MAX_ENTITY_LENGTH) ||
			(pNbpTuple->tpl_TypeLen == 0) ||
			(pNbpTuple->tpl_TypeLen > MAX_ENTITY_LENGTH))
			break;
	
		if (pNbpTuple->tpl_ZoneLen == 0)
		{
			pNbpTuple->tpl_ZoneLen = 1;
			pNbpTuple->tpl_Zone[0] = '*';
		}
		else
		{
			if ((pNbpTuple->tpl_ZoneLen != 1) ||
				(pNbpTuple->tpl_Zone[0] != '*'))
				break;
		}
	
		if ((pNbpTuple->tpl_Object[0] == '=') || (pNbpTuple->tpl_Type[0] == '=') ||
			AtalkSearchBuf(pNbpTuple->tpl_Object, pNbpTuple->tpl_ObjectLen, NBP_WILD_CHARACTER)  ||
			AtalkSearchBuf(pNbpTuple->tpl_Type, pNbpTuple->tpl_TypeLen, NBP_WILD_CHARACTER))
			break;
	
		// Search in the registered names list in the open socket
		// Lock down the structure first
		ACQUIRE_SPIN_LOCK(&pDdpAddr->ddpao_Lock, &OldIrql);
	
		for (ppRegdName = &pDdpAddr->ddpao_RegNames;
			 (pRegdName = *ppRegdName) != NULL;
			 ppRegdName = &pRegdName->rdn_Next)
		{
			ASSERT (VALID_REGDNAME(pRegdName));
			if (AtalkFixedCompareCaseInsensitive(pNbpTuple->tpl_Object,
												 pNbpTuple->tpl_ObjectLen,
												 pRegdName->rdn_Tuple.tpl_Object,
												 pRegdName->rdn_Tuple.tpl_ObjectLen) &&
				AtalkFixedCompareCaseInsensitive(pNbpTuple->tpl_Type,
												 pNbpTuple->tpl_TypeLen,
												 pRegdName->rdn_Tuple.tpl_Type,
												 pRegdName->rdn_Tuple.tpl_TypeLen))
			{
				*ppRegdName = pRegdName->rdn_Next;
				break;
			}
		}
		RELEASE_SPIN_LOCK(&pDdpAddr->ddpao_Lock, OldIrql);
	
		Status = ATALK_FAILURE;
		if (pRegdName != NULL)
		{
			AtalkFreeMemory(pRegdName);
			Status = ATALK_NO_ERROR;
		}
	} while (FALSE);

	AtalkUnlockNbpIfNecessary();
	(*pActReq->ar_Completion)(Status, pActReq);

	return (ATALK_PENDING);
}



/***	atalkNbpMatchWild
 *
 */
LOCAL BOOLEAN
atalkNbpMatchWild(
	IN	PBYTE	WildString,
	IN	BYTE	WildStringLen,
	IN	PBYTE	String,
	IN	BYTE	StringLen
)
/*++
	There are two kinds of wild card searches. An '=' by itself matches anything.
	Partial matches use the 'curly equals' or 0xC5. So representing that by the
	'=' character below.

	foo= will match any name which starts with foo.
	=foo will match any name which ends in foo.
	=foo= will match any name with foo in it.
	foo=bar will match any name that starts with foo and ends with bar.

--*/
{
        PBYTE   pTarget, pTokStr;
        int     TargetLen, TokStrLen;
	PBYTE	pWildCard, pCurStr, pCurWild;
	int		Len;
        int     i;
        BOOLEAN fWildCharPresent = FALSE;


        // first see if it's a 'match any' request
	if ((WildString[0] == 0) ||
		((WildString[0] == '=') && (WildStringLen == 1)))
		return TRUE;

        // now, check to see if there is any wild char in the requested name
        for (i=0; i<WildStringLen; i++)
        {
            if (WildString[i] == NBP_WILD_CHARACTER)
            {
                fWildCharPresent = TRUE;
                break;
            }
        }

        // if there is no wild character in the requested name, this is
        // a straight forward string compare!
        if (!fWildCharPresent)
        {
            if (WildStringLen != StringLen)
                return FALSE;

            if (SubStringMatch(WildString,String,StringLen,WildStringLen))
                return TRUE;
            else
                return FALSE;
        }


        // ok, now deal with the wild character mess

	pTarget = String;
	pTokStr = WildString;
        TargetLen = StringLen;

        while (WildStringLen > 0 && StringLen > 0)
        {
            // find length of substring until the next wild-char
            TokStrLen = GetTokenLen(pTokStr,WildStringLen,NBP_WILD_CHARACTER);

            if (TokStrLen > 0)
            {
                if (!SubStringMatch(pTarget,pTokStr,StringLen,TokStrLen))
                {
                    return (FALSE);
                }

                pTokStr += TokStrLen;
                WildStringLen -= (BYTE)TokStrLen;
                pTarget += TokStrLen;
                StringLen -= (BYTE)TokStrLen;
            }
            // the very first char was wild-char: skip over it
            else
            {
                pTokStr++;
                WildStringLen--;
            }
        }

        // if we survived all the checks, this string is a match!
	return (TRUE);
}


/***	atalkNbpEncodeTuple
 *
 */
LOCAL SHORT
atalkNbpEncodeTuple(
	IN	PNBPTUPLE	pNbpTuple,
	IN	PBYTE		pZone	OPTIONAL,	// Override zone
	IN	BYTE		ZoneLen OPTIONAL,	// Valid only if pZone != NULL
	IN	BYTE		Socket	OPTIONAL,
	OUT	PBYTE		pBuffer
)
{
	typedef struct
	{
		BYTE	_NetNum[2];
		BYTE	_Node;
		BYTE	_Socket;
		BYTE	_Enumerator;
	} HDR, *PHDR;
	SHORT		Len = sizeof(HDR);

	if (pZone == NULL)
	{
		pZone = pNbpTuple->tpl_Zone;
		ZoneLen = pNbpTuple->tpl_ZoneLen;
	}

	PUTSHORT2SHORT(((PHDR)pBuffer)->_NetNum, pNbpTuple->tpl_Address.ata_Network);
	((PHDR)pBuffer)->_Node = pNbpTuple->tpl_Address.ata_Node;
	((PHDR)pBuffer)->_Socket = pNbpTuple->tpl_Address.ata_Socket;
	if (Socket != 0)
		((PHDR)pBuffer)->_Socket = Socket;
	PUTSHORT2BYTE(&((PHDR)pBuffer)->_Enumerator, pNbpTuple->tpl_Enumerator);

	pBuffer += sizeof(HDR);

	*pBuffer++ = pNbpTuple->tpl_ObjectLen;
	RtlCopyMemory(pBuffer, pNbpTuple->tpl_Object, pNbpTuple->tpl_ObjectLen);
	pBuffer += pNbpTuple->tpl_ObjectLen;
	Len += (pNbpTuple->tpl_ObjectLen + 1);

	*pBuffer++ = pNbpTuple->tpl_TypeLen;
	RtlCopyMemory(pBuffer, pNbpTuple->tpl_Type, pNbpTuple->tpl_TypeLen);
	pBuffer += pNbpTuple->tpl_TypeLen;
	Len += (pNbpTuple->tpl_TypeLen + 1);

	*pBuffer++ = ZoneLen;
	RtlCopyMemory(pBuffer, pZone, ZoneLen);
	// pBuffer += ZoneLen;
	Len += (ZoneLen + 1);

	return (Len);
}


/***	atalkNbpDecodeTuple
 *
 */
LOCAL SHORT
atalkNbpDecodeTuple(
	IN	PBYTE		pBuffer,
	IN	USHORT		PktLen,
	OUT	PNBPTUPLE	pNbpTuple
)
{
	typedef struct
	{
		BYTE	_NetNum[2];
		BYTE	_Node;
		BYTE	_Socket;
		BYTE	_Enumerator;
	} HDR, *PHDR;
	SHORT		Len = 0;

	do
	{
		if (PktLen < MIN_NBP_TUPLELENGTH)
		{
			break;
		}

		GETSHORT2SHORT(&pNbpTuple->tpl_Address.ata_Network,
					   ((PHDR)pBuffer)->_NetNum);
		pNbpTuple->tpl_Address.ata_Node = ((PHDR)pBuffer)->_Node;
		pNbpTuple->tpl_Address.ata_Socket = ((PHDR)pBuffer)->_Socket;
		GETBYTE2SHORT(&pNbpTuple->tpl_Enumerator,
						&((PHDR)pBuffer)->_Enumerator);
	
		// Get past the header
		pBuffer += sizeof(HDR);
		PktLen -= sizeof(HDR);
	
		Len = sizeof(HDR);

		pNbpTuple->tpl_ObjectLen = *pBuffer++;
		PktLen --;
		if ((pNbpTuple->tpl_ObjectLen > PktLen) ||
			(pNbpTuple->tpl_ObjectLen > MAX_ENTITY_LENGTH))
		{
			Len = 0;
			break;
		}
		RtlCopyMemory(pNbpTuple->tpl_Object, pBuffer, pNbpTuple->tpl_ObjectLen);
		pBuffer += pNbpTuple->tpl_ObjectLen;
		PktLen -= pNbpTuple->tpl_ObjectLen;
		Len += (pNbpTuple->tpl_ObjectLen + 1);
	
		if (PktLen == 0)
		{
			Len = 0;
			break;
		}
		pNbpTuple->tpl_TypeLen = *pBuffer++;
		PktLen --;
		if ((pNbpTuple->tpl_TypeLen > PktLen) ||
			(pNbpTuple->tpl_TypeLen > MAX_ENTITY_LENGTH))
		{
			Len = 0;
			break;
		}
		RtlCopyMemory(pNbpTuple->tpl_Type, pBuffer, pNbpTuple->tpl_TypeLen);
		pBuffer += pNbpTuple->tpl_TypeLen;
		PktLen -= pNbpTuple->tpl_TypeLen;
		Len += (pNbpTuple->tpl_TypeLen + 1);
	
		if (PktLen == 0)
		{
			Len = 0;
			break;
		}
		pNbpTuple->tpl_ZoneLen = *pBuffer++;
		PktLen --;
		if ((pNbpTuple->tpl_ZoneLen > PktLen) ||
			(pNbpTuple->tpl_ZoneLen > MAX_ENTITY_LENGTH))
		{
			Len = 0;
			break;
		}
		RtlCopyMemory(pNbpTuple->tpl_Zone, pBuffer, pNbpTuple->tpl_ZoneLen);
		Len += (pNbpTuple->tpl_ZoneLen + 1);
	} while (FALSE);

	return (Len);
}



/***	atalkNbpLinkPendingNameInList
 *
 */
LOCAL VOID
atalkNbpLinkPendingNameInList(
	IN		PDDP_ADDROBJ	pDdpAddr,
	IN OUT	PPEND_NAME		pPendName
)
{
	PATALK_NODE		pNode = pDdpAddr->ddpao_Node;
	KIRQL			OldIrql;

	ASSERT (VALID_PENDNAME(pPendName));

	ACQUIRE_SPIN_LOCK(&pNode->an_Lock, &OldIrql);

	// Use the next consecutive values. If there are > 256 pending names on a node, we'll
	// end up re-using the ids and enums. Still ok unless all of them are of the form
	// =:=@=. Well lets just keep it simple.
	pPendName->pdn_NbpId = ++(pNode->an_NextNbpId);
	pPendName->pdn_pRegdName->rdn_Tuple.tpl_Enumerator = ++(pNode->an_NextNbpEnum);

	DBGPRINT(DBG_COMP_NBP, DBG_LEVEL_INFO,
			("atalkNbpLinkPendingNameInList: Linking PendingName %lx in socket %lx\n",
			pPendName, pDdpAddr));

	pPendName->pdn_Next = pDdpAddr->ddpao_PendNames;
	pDdpAddr->ddpao_PendNames = pPendName;

	RELEASE_SPIN_LOCK(&pNode->an_Lock, OldIrql);
}


/***	AtalkNbpCloseSocket
 *
 */
VOID
AtalkNbpCloseSocket(
	IN	PDDP_ADDROBJ	pDdpAddr
)
{
	PPEND_NAME	pPendName, *ppPendName;
	PREGD_NAME	pRegdName, *ppRegdName;
	KIRQL		OldIrql;

	ACQUIRE_SPIN_LOCK(&pDdpAddr->ddpao_Lock, &OldIrql);

	// Free the pending names from the open socket.
	for (ppPendName = &pDdpAddr->ddpao_PendNames;
		 (pPendName = *ppPendName) != NULL;
		 NOTHING)
	{
		ASSERT (VALID_PENDNAME(pPendName));
		if (pPendName->pdn_Flags & PDN_CLOSING)
		{
	        ppPendName = &pPendName->pdn_Next;
			continue;
		}

		pPendName->pdn_Flags |= PDN_CLOSING;
		pPendName->pdn_Status = ATALK_SOCKET_CLOSED;
		// Cancel outstanding timers on the pending names
		if (AtalkTimerCancelEvent(&pPendName->pdn_Timer, NULL))
		{
			atalkNbpDerefPendName(pPendName);
		}

		RELEASE_SPIN_LOCK(&pDdpAddr->ddpao_Lock, OldIrql);

		ASSERT (pPendName->pdn_RefCount > 0);

		atalkNbpDerefPendName(pPendName);

		ACQUIRE_SPIN_LOCK(&pDdpAddr->ddpao_Lock, &OldIrql);
	    ppPendName = &pDdpAddr->ddpao_PendNames;
	}

	// Free the registered names from the open socket.
	for (ppRegdName = &pDdpAddr->ddpao_RegNames;
		 (pRegdName = *ppRegdName) != NULL;
		 NOTHING)
	{
		ASSERT (VALID_REGDNAME(pRegdName));
		*ppRegdName = pRegdName->rdn_Next;
		AtalkFreeMemory(pRegdName);
	}

	RELEASE_SPIN_LOCK(&pDdpAddr->ddpao_Lock, OldIrql);
}


/***	atalkNbpSendRequest
 *
 */
LOCAL BOOLEAN
atalkNbpSendRequest(
	IN	PPEND_NAME	pPendName
)
{
	PDDP_ADDROBJ		pDdpAddr;
	PBUFFER_DESC		pBuffDesc;
	ATALK_ADDR			DestAddr;
	ATALK_ADDR			SrcAddr;
	ATALK_ERROR			Status;
	PPORT_DESCRIPTOR	pPortDesc;
	SEND_COMPL_INFO		SendInfo;

	DBGPRINT(DBG_COMP_NBP, DBG_LEVEL_INFO,
			("atalkNbpSendRequest: Sending request for PendName %lx\n", pPendName));

	ASSERT(!(pPendName->pdn_Flags & PDN_CLOSING));

	pPortDesc = pPendName->pdn_pDdpAddr->ddpao_Node->an_Port;
	DestAddr.ata_Socket = NAMESINFORMATION_SOCKET;
	if (pPendName->pdn_Reason == FOR_CONFIRM)
	{
		DestAddr.ata_Network = pPendName->pdn_ConfirmAddr.ata_Network;
		DestAddr.ata_Node = pPendName->pdn_ConfirmAddr.ata_Node;
	}
	else
	{
		if (pPortDesc->pd_Flags & PD_SEEN_ROUTER_RECENTLY)
		{
			DestAddr.ata_Network = pPortDesc->pd_ARouter.atn_Network;
			DestAddr.ata_Node = pPortDesc->pd_ARouter.atn_Node;
		}
		else
		{
			DestAddr.ata_Network = CABLEWIDE_BROADCAST_NETWORK;
			DestAddr.ata_Node = ATALK_BROADCAST_NODE;
		}
	}

	SrcAddr.ata_Address = pPendName->pdn_pDdpAddr->ddpao_Addr.ata_Address;

	// SrcAddr.ata_Socket = NAMESINFORMATION_SOCKET;
	SrcAddr.ata_Socket = LAST_DYNAMIC_SOCKET;
	AtalkDdpReferenceByAddr(pPendName->pdn_pDdpAddr->ddpao_Node->an_Port,
							&SrcAddr,
							&pDdpAddr,
							&Status);

	if (!ATALK_SUCCESS(Status))
	{
		return FALSE;
	}

	if ((pBuffDesc = AtalkAllocBuffDesc(pPendName->pdn_Datagram,
										pPendName->pdn_DatagramLength,
										BD_CHAR_BUFFER)) == NULL)
	{
		AtalkDdpDereference(pDdpAddr);
		return FALSE;
	}

	ASSERT(pBuffDesc->bd_Length == pPendName->pdn_DatagramLength);
	ASSERT(pBuffDesc->bd_Length > 0);
	SendInfo.sc_TransmitCompletion = atalkNbpSendComplete;
	SendInfo.sc_Ctx1 = pBuffDesc;
	// SendInfo.sc_Ctx2 = NULL;
	// SendInfo.sc_Ctx3 = NULL;
	Status = AtalkDdpSend(pDdpAddr,
						  &DestAddr,
						  DDPPROTO_NBP,
						  FALSE,
						  pBuffDesc,
						  NULL,
						  0,
						  NULL,
						  &SendInfo);

	if (!ATALK_SUCCESS(Status))
	{
		DBGPRINT(DBG_COMP_NBP, DBG_LEVEL_ERR,
				("atalkNbpSendRequest: AtalkDdpSend Failed %lx\n", Status));
		AtalkFreeBuffDesc(pBuffDesc);
	}
	AtalkDdpDereference(pDdpAddr);

	return (ATALK_SUCCESS(Status));
}


/***	atalkNbpSendLookupDatagram
 *
 */
LOCAL VOID
atalkNbpSendLookupDatagram(
	IN	PPORT_DESCRIPTOR	pPortDesc,
	IN	PDDP_ADDROBJ		pDdpAddr OPTIONAL,
	IN	SHORT				NbpId,
	IN	PNBPTUPLE			pNbpTuple
)
{
	PBYTE			Datagram = NULL;
	BYTE			MulticastAddr[ELAP_ADDR_LEN];
	PBUFFER_DESC	pBuffDesc = NULL;
	BOOLEAN			DerefDdp = FALSE;
	ULONG			Len;
	ATALK_ADDR		Dst, Src;
	ATALK_ERROR		Status;
	SEND_COMPL_INFO	SendInfo;

	if (pDdpAddr == NULL)
	{
		Src.ata_Network = pPortDesc->pd_ARouter.atn_Network;
		Src.ata_Node = pPortDesc->pd_ARouter.atn_Node;
		Src.ata_Socket = NAMESINFORMATION_SOCKET;

		AtalkDdpReferenceByAddr(pPortDesc, &Src, &pDdpAddr, &Status);
		if (!ATALK_SUCCESS(Status))
		{
			return;
		}
		DerefDdp = TRUE;
	}

	do
	{
		if ((pBuffDesc = AtalkAllocBuffDesc(NULL,
										sizeof(NBPHDR) + MAX_NBP_TUPLELENGTH,
										BD_CHAR_BUFFER | BD_FREE_BUFFER)) == NULL)
			break;

		Datagram = pBuffDesc->bd_CharBuffer;
		((PNBPHDR)Datagram)->_NbpId = (BYTE)NbpId;
		((PNBPHDR)Datagram)->_CmdAndTupleCnt = (NBP_LOOKUP << 4) + 1;
		Len = sizeof(NBPHDR) +
			  atalkNbpEncodeTuple(pNbpTuple,
								  NULL,
								  0,
								  0,
								  Datagram+sizeof(NBPHDR));

		Dst.ata_Node = ATALK_BROADCAST_NODE;
		Dst.ata_Socket = NAMESINFORMATION_SOCKET;

		if (EXT_NET(pPortDesc))
		{
			// Send to "0000FF" at correct zone multicast address
			Dst.ata_Network = CABLEWIDE_BROADCAST_NETWORK;
			AtalkZipMulticastAddrForZone(pPortDesc,
										 pNbpTuple->tpl_Zone,
										 pNbpTuple->tpl_ZoneLen,
										 MulticastAddr);
		}
		else
		{
			// Send to "nnnnFF" as broadcast
			Dst.ata_Network = pPortDesc->pd_NetworkRange.anr_FirstNetwork;
		}

		//	Set the length in the buffer descriptor.
		AtalkSetSizeOfBuffDescData(pBuffDesc, (USHORT)Len);

		ASSERT(pBuffDesc->bd_Length > 0);
		SendInfo.sc_TransmitCompletion = atalkNbpSendComplete;
		SendInfo.sc_Ctx1 = pBuffDesc;
		// SendInfo.sc_Ctx2 = NULL;
		// SendInfo.sc_Ctx3 = NULL;
		if (!ATALK_SUCCESS(Status = AtalkDdpSend(pDdpAddr,
												 &Dst,
												 DDPPROTO_NBP,
												 FALSE,
												 pBuffDesc,
												 NULL,
												 0,
												 MulticastAddr,
												 &SendInfo)))
		{
			DBGPRINT(DBG_COMP_NBP, DBG_LEVEL_ERR,
					("atalkNbpSendLookupDatagram: DdpSend failed %ld\n", Status));
			break;
		}
		Datagram = NULL;
		pBuffDesc = NULL;
	} while (FALSE);

	if (DerefDdp)
		AtalkDdpDereference(pDdpAddr);

	if (pBuffDesc != NULL)
		AtalkFreeBuffDesc(pBuffDesc);
}


/***	atalkNbpSendForwardRequest
 *
 */
LOCAL VOID
atalkNbpSendForwardRequest(
	IN	PDDP_ADDROBJ		pDdpAddr,
	IN	PRTE				pRte,
	IN	SHORT				NbpId,
	IN	PNBPTUPLE			pNbpTuple
)
{
	PBYTE			Datagram = NULL;
	PBUFFER_DESC	pBuffDesc = NULL;
	SEND_COMPL_INFO	SendInfo;
	ATALK_ERROR		ErrorCode;
	ULONG			Len;
	ATALK_ADDR		Dst;

	do
	{
		if ((pBuffDesc = AtalkAllocBuffDesc(NULL,
											sizeof(NBPHDR) + MAX_NBP_TUPLELENGTH,
											BD_CHAR_BUFFER | BD_FREE_BUFFER)) == NULL)
			break;

		Datagram = pBuffDesc->bd_CharBuffer;
		((PNBPHDR)Datagram)->_NbpId = (BYTE)NbpId;
		((PNBPHDR)Datagram)->_CmdAndTupleCnt = (NBP_FORWARD_REQUEST << 4) + 1;
		Len = sizeof(NBPHDR) +
			  atalkNbpEncodeTuple(pNbpTuple,
								  NULL,
								  0,
								  0,
								  Datagram+sizeof(NBPHDR));

		Dst.ata_Network = pRte->rte_NwRange.anr_FirstNetwork;
		Dst.ata_Node = ANY_ROUTER_NODE;
		Dst.ata_Socket = NAMESINFORMATION_SOCKET;

		//	Set the length in the buffer descriptor.
		AtalkSetSizeOfBuffDescData(pBuffDesc, (USHORT)Len);

		ASSERTMSG("Dest in rte 0\n", Dst.ata_Network != CABLEWIDE_BROADCAST_NETWORK);

		ASSERT(pBuffDesc->bd_Length > 0);
		SendInfo.sc_TransmitCompletion = atalkNbpSendComplete;
		SendInfo.sc_Ctx1 = pBuffDesc;
		// SendInfo.sc_Ctx2 = NULL;
		// SendInfo.sc_Ctx3 = NULL;
        ErrorCode = AtalkDdpSend(pDdpAddr,
								 &Dst,
								 DDPPROTO_NBP,
								 FALSE,
								 pBuffDesc,
								 NULL,
								 0,
								 NULL,
								 &SendInfo);
		if (!ATALK_SUCCESS(ErrorCode))
		{
			DBGPRINT(DBG_COMP_NBP, DBG_LEVEL_ERR,
					("atalkNbpSendForwardRequest: DdpSend failed %ld\n", ErrorCode));
			break;
		}
		Datagram = NULL;
		pBuffDesc = NULL;
	} while (FALSE);

	if (pBuffDesc != NULL)
		AtalkFreeBuffDesc(pBuffDesc);
}


/***	atalkNbpDerefPendName
 *
 */
VOID
atalkNbpDerefPendName(
	IN	PPEND_NAME		pPendName
)
{
	PPEND_NAME	*	ppPendName;
	PDDP_ADDROBJ	pDdpAddr = pPendName->pdn_pDdpAddr;
	BOOLEAN			Unlink, Found = FALSE;
	KIRQL			OldIrql;

	ACQUIRE_SPIN_LOCK(&pPendName->pdn_Lock, &OldIrql);

	Unlink = (--(pPendName->pdn_RefCount) == 0);

	DBGPRINT(DBG_COMP_NBP, DBG_LEVEL_INFO,
			("atalkNbpDerefPendName: New Count %d\n", pPendName->pdn_RefCount));

	RELEASE_SPIN_LOCK(&pPendName->pdn_Lock, OldIrql);

	if (!Unlink)
		return;

	DBGPRINT(DBG_COMP_NBP, DBG_LEVEL_INFO,
			("atalkNbpDerefPendName: Unlinking pPendName\n"));

	ACQUIRE_SPIN_LOCK(&pDdpAddr->ddpao_Lock, &OldIrql);

	for (ppPendName = &pDdpAddr->ddpao_PendNames;
		 *ppPendName != NULL;
		 ppPendName = &(*ppPendName)->pdn_Next)
	{
		if (*ppPendName == pPendName)
		{
			*ppPendName = pPendName->pdn_Next;
			Found = TRUE;
			break;
		}
	}

	RELEASE_SPIN_LOCK(&pDdpAddr->ddpao_Lock, OldIrql);

	if (Found)
	{
		AtalkDdpDereference(pDdpAddr);
	}
	else ASSERTMSG("atalkNbpDerefPendName: Could not find\n", 0);

	AtalkUnlockNbpIfNecessary();
	(*pPendName->pdn_pActReq->ar_Completion)(pPendName->pdn_Status, pPendName->pdn_pActReq);
	if (pPendName->pdn_Flags & PDN_FREE_REGDNAME)
		AtalkFreeMemory(pPendName->pdn_pRegdName);
	AtalkFreeMemory(pPendName);
}


/***	atalkNbpSendComplete
 *
 */
VOID FASTCALL
atalkNbpSendComplete(
	IN	NDIS_STATUS			Status,
	IN	PSEND_COMPL_INFO	pSendInfo
)
{
	PBUFFER_DESC	pBuffDesc = (PBUFFER_DESC)(pSendInfo->sc_Ctx1);

	if (!ATALK_SUCCESS(Status))
		DBGPRINT(DBG_COMP_NBP, DBG_LEVEL_ERR,
				("atalkNbpSendComplete: Failed %lx, pBuffDesc %lx\n",
				Status, pBuffDesc));

	AtalkFreeBuffDesc(pBuffDesc);
}





=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\atalk\sys\nbp.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

	nbp.h

Abstract:

	This module contains NBP specific declarations.

Author:

	Jameel Hyder (jameelh@microsoft.com)
	Nikhil Kamkolkar (nikhilk@microsoft.com)

Revision History:
	25 Feb 1993		Initial Version

Notes:	Tab stop: 4
--*/

#ifndef	_NBP_

// Each "OpenSocket" structure has a "RegsiteredName" field which is the list
// of Network Visible Entities (NVE) available on that socket.  Each NVE is
// made up of three fields: object, type, zone For example:
// "Sidhu:MailBox:Bandley3".  We don't have to store the zone in the NVE
// structure because each entity must be registered in the zone that the node
// resides in.

// NBP entity multiple character wildcard.
#define NBP_WILD_CHARACTER			0xC5

// The largest "on the wire" NBP tuple
#define MAX_NBP_TUPLELENGTH			(2 + 1 + 1 + 1 + \
									 3 * (MAX_ENTITY_LENGTH + 1))

#define MIN_NBP_TUPLELENGTH			(2 + 1 + 1 + 1 + 3 * (1 + 1))

// Structure of NBP Header
typedef struct _NbpHeader {
	BYTE	_CmdAndTupleCnt;
	BYTE	_NbpId;
} NBPHDR, *PNBPHDR;

// An internal representation of an NBP tuple.  This structure is never
// actually put out on the wire so it can be in a convienient form to work
// with.  See "Inside AppleTalk" for further information.
typedef struct
{
	ATALK_ADDR			tpl_Address;
	SHORT				tpl_Enumerator;
	BYTE				tpl_ObjectLen;
	BYTE				tpl_Object[MAX_ENTITY_LENGTH];
	BYTE				tpl_TypeLen;
	BYTE				tpl_Type  [MAX_ENTITY_LENGTH];
	BYTE				tpl_ZoneLen;
	BYTE				tpl_Zone  [MAX_ENTITY_LENGTH];
} NBPTUPLE, *PNBPTUPLE;

// A registered name hangs off a open socket
#define	RDN_SIGNATURE	*(PULONG)"NBPR"
#if	DBG
#define	VALID_REGDNAME(pRegdName)	(((pRegdName) != NULL) && \
									 ((pRegdName)->rdn_Signature == RDN_SIGNATURE))
#else
#define	VALID_REGDNAME(pRegdName)	((pRegdName) != NULL)
#endif
typedef struct _REGD_NAME
{
#if	DBG
	ULONG					rdn_Signature;
#endif
	struct _REGD_NAME *		rdn_Next;
	NBPTUPLE				rdn_Tuple;
} REGD_NAME, *PREGD_NAME;

#define FOR_REGISTER			1
#define FOR_CONFIRM				2
#define FOR_LOOKUP				3

#define	PDN_FREE_REGDNAME		0x0001
#define	PDN_CLOSING				0x8000

// When we're doing NBP registers, lookups, or confirms we need to have a
// concept of "pending" NVE's.
#define	PDN_SIGNATURE	*(PULONG)"NBPP"
#if	DBG
#define	VALID_PENDNAME(pPendName)	(((pPendName) != NULL) && \
									 ((pPendName)->pdn_Signature == PDN_SIGNATURE))
#else
#define	VALID_PENDNAME(pPendName)	((pPendName) != NULL)
#endif
typedef struct _PEND_NAME
{
#if	DBG
	ULONG					pdn_Signature;
#endif
	struct _PEND_NAME 	*	pdn_Next;				// Next in the chain
	PREGD_NAME				pdn_pRegdName;			// This is moved to the open socket, if
													// FOR_REGISTER and successful
	PDDP_ADDROBJ			pdn_pDdpAddr;			// Socket that is registering,
													// confiming or looking-up.
	ATALK_ADDR				pdn_ConfirmAddr;		// The expected internet address
													// that we're trying to confirm.
	TIMERLIST				pdn_Timer;				// Broadcast timer
	LONG					pdn_RefCount;			// Reference count
	USHORT					pdn_NbpId;				// So we can sort out answers!
	USHORT					pdn_Flags;				// PDN_xxx values
	USHORT					pdn_MaxTuples;			// For lookup, what is the max # of
								    				// tuples our client is expecting?
	USHORT					pdn_TotalTuples;		// For lookup, how many tuples have we stored so far?
	BYTE					pdn_Reason;				// Confirm,Lookup or Register
	BYTE					pdn_RemainingBroadcasts;// How many more till we assume we're finished?
	USHORT					pdn_DatagramLength;		// Actual length of the datagram
	USHORT					pdn_MdlLength;			// Length of user Mdl
	PAMDL					pdn_pAMdl;				// Start of caller's "buffer" used to recieve tuples.
	PACTREQ					pdn_pActReq;			// Passed on to the completion routine.
	ATALK_ERROR				pdn_Status;				// Final status
	ATALK_SPIN_LOCK			pdn_Lock;				// Lock for this pending name
	CHAR					pdn_Datagram[sizeof(NBPHDR) + MAX_NBP_TUPLELENGTH];
								    				// The DDP datagram that we use to broadcast
								    				// the request.
} PEND_NAME, *PPEND_NAME;

// Default values for NBP timers

#define NBP_BROADCAST_INTERVAL		10		// In 100ms units
#define NBP_NUM_BROADCASTS			10

// The three NBP command types
#define NBP_BROADCAST_REQUEST		1
#define NBP_LOOKUP					2
#define NBP_LOOKUP_REPLY			3
#define NBP_FORWARD_REQUEST			4

extern
VOID
AtalkNbpPacketIn(
	IN	PPORT_DESCRIPTOR		pPortDesc,
	IN	PDDP_ADDROBJ			pDdpAddr,
	IN	PBYTE					pPkt,
	IN	USHORT					PktLen,
	IN	PATALK_ADDR				pSrcAddr,
	IN	PATALK_ADDR				pDstAddr,
	IN	ATALK_ERROR				ErrorCode,
	IN	BYTE					DdpType,
	IN	PVOID					pHandlerCtx,
	IN	BOOLEAN					OptimizePath,
	IN	PVOID					OptimizeCtx
);

extern
ATALK_ERROR
AtalkNbpAction(
	IN	PDDP_ADDROBJ			pDdpAddr,
	IN	BYTE					Reason,
	IN	PNBPTUPLE				pNbpTuple,
	OUT	PAMDL					pAMdl			OPTIONAL,	// FOR_LOOKUP
	IN	USHORT					MaxTuples		OPTIONAL,	// FOR_LOOKUP
	IN	PACTREQ					pActReq
);

extern
VOID
AtalkNbpCloseSocket(
	IN	PDDP_ADDROBJ			pDdpAddr
);

extern
ATALK_ERROR
AtalkNbpRemove(
	IN	PDDP_ADDROBJ			pDdpAddr,
	IN	PNBPTUPLE				pNbpTuple,
	IN	PACTREQ					pActReq
);

LOCAL LONG FASTCALL
atalkNbpTimer(
	IN	PTIMERLIST				pTimer,
	IN	BOOLEAN					TimerShuttingDown
);
	
LOCAL VOID                  	
atalkNbpLookupNames(        	
	IN	PPORT_DESCRIPTOR		pPortDesc,
	IN	PDDP_ADDROBJ			pDdpAddr,
	IN	PNBPTUPLE				pNbpTuple,
	IN	SHORT					NbpId
);

LOCAL BOOLEAN
atalkNbpMatchWild(
	IN	PBYTE					WildString,
	IN	BYTE					WildStringLen,
	IN	PBYTE					String,
	IN	BYTE					StringLen
);

LOCAL SHORT
atalkNbpEncodeTuple(
	IN	PNBPTUPLE				pNbpTuple,
	IN	PBYTE					pZone	OPTIONAL,
	IN	BYTE					ZoneLen OPTIONAL,
	IN	BYTE					Socket	OPTIONAL,
	OUT	PBYTE					pBuffer
);

LOCAL SHORT
atalkNbpDecodeTuple(
	IN	PBYTE					pBuffer,
	IN	USHORT					PktLen,
	OUT	PNBPTUPLE				pNbpTuple
);

LOCAL VOID
atalkNbpLinkPendingNameInList(
	IN	PDDP_ADDROBJ			pDdpAddr,
	IN OUT	PPEND_NAME			pPendName
);

LOCAL BOOLEAN
atalkNbpSendRequest(
	IN	PPEND_NAME				pPendName
);

LOCAL VOID
atalkNbpSendLookupDatagram(
	IN	PPORT_DESCRIPTOR		pPortDesc,
	IN	PDDP_ADDROBJ			pDdpAddr,
	IN	SHORT					NbpId,
	IN	PNBPTUPLE				pNbpTuple
);

LOCAL VOID
atalkNbpSendForwardRequest(
	IN	PDDP_ADDROBJ			pDdpAddr,
	IN	struct _RoutingTableEntry *	pRte,
	IN	SHORT					NbpId,
	IN	PNBPTUPLE				pNbpTuple
);

VOID
atalkNbpDerefPendName(
	IN	PPEND_NAME				pPendName
);

VOID FASTCALL
atalkNbpSendComplete(
	IN	NDIS_STATUS				Status,
	IN	PSEND_COMPL_INFO		pSendInfo
);

#endif	// _NBP_



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\atalk\sys\node.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

	node.c

Abstract:

	This module contains the Appletalk Node management code.

Author:

	Jameel Hyder (jameelh@microsoft.com)
	Nikhil Kamkolkar (nikhilk@microsoft.com)

Revision History:
	19 Jun 1992		Initial Version

Notes:	Tab stop: 4
--*/

#include <atalk.h>
#pragma hdrstop
#define	FILENUM	NODE


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGEINIT, AtalkInitNodeCreateOnPort)
#pragma alloc_text(PAGEINIT, AtalkInitNodeAllocate)
#pragma alloc_text(PAGEINIT, AtalkInitNodeGetPramAddr)
#pragma alloc_text(PAGEINIT, AtalkInitNodeSavePramAddr)
#endif

ATALK_ERROR
AtalkInitNodeCreateOnPort(
	PPORT_DESCRIPTOR	pPortDesc,
	BOOLEAN				AllowStartupRange,
	BOOLEAN				RouterNode,
	PATALK_NODEADDR		NodeAddr
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PATALK_NODE			pNode;
	ATALK_ERROR			error = ATALK_NO_ERROR;
	ATALK_NODEADDR		desiredNode = { UNKNOWN_NETWORK, UNKNOWN_NODE};
	PWSTR				NodeName;
	KIRQL				OldIrql;

	ACQUIRE_SPIN_LOCK(&pPortDesc->pd_Lock, &OldIrql);

	do
	{
		if ((pPortDesc->pd_Flags & PD_FINDING_NODE) == 0)
		{
			pPortDesc->pd_Flags |= PD_FINDING_NODE;
		}
		else
		{
			//	Return if we are already trying to find a node
			error = ATALK_NODE_FINDING;
			break;
		}
	
		//	We should not be here if we have already allocated a router node and the user nodes
		ASSERT(!RouterNode || ((pPortDesc->pd_Flags & PD_ROUTER_NODE) == 0));
		ASSERT ((pPortDesc->pd_Flags & (PD_ROUTER_NODE | PD_USER_NODE_1 | PD_USER_NODE_2))
				!= (PD_ROUTER_NODE | PD_USER_NODE_1 | PD_USER_NODE_2));
	
		//	On non-extended ports we only allow one node!  The theory being that some
		//	LocalTalk cards are too smart for their own good and have a concept of
		//	their "source node number" and thus only support one node, also on
		//	non-extended ports, nodes are scarse.
		if (!EXT_NET(pPortDesc))
		{
			//	For a localtalk node we do things differently.
			//	During initialization time, we would have obtained
			//	the address from the mac, that will be the node
			//	address.

			ASSERT(pPortDesc->pd_Flags & PD_BOUND);
			ASSERT(pPortDesc->pd_AlapNode != 0);

			//	This needs to be initialized to UNKNOWN_NETWORK or obtained
			//	from the net during initialization.
			ASSERT(pPortDesc->pd_NetworkRange.anr_FirstNetwork == UNKNOWN_NETWORK);

			if (!ATALK_SUCCESS((error = AtalkInitNodeAllocate(pPortDesc, &pNode))))
			{
				LOG_ERRORONPORT(pPortDesc,
				                EVENT_ATALK_INIT_COULDNOTGETNODE,
								0,
								NULL,
								0);
				break;
			}

			// 	Use the allocated structure to set the info.
			//	Thread this into the port structure.
			pPortDesc->pd_LtNetwork =
			pNode->an_NodeAddr.atn_Network =
								pPortDesc->pd_NetworkRange.anr_FirstNetwork;
			pNode->an_NodeAddr.atn_Node = (BYTE)pPortDesc->pd_AlapNode;

			//	Reference the port for this node.
			AtalkPortReferenceByPtrNonInterlock(pPortDesc, &error);
			if (!ATALK_SUCCESS(error))
			{
				AtalkFreeMemory(pNode);
				break;
			}

			//	Now put it in the port descriptor
			pNode->an_Next = pPortDesc->pd_Nodes;
			pPortDesc->pd_Nodes = pNode;
		}
		else
		{
			//	Use PRAM values if we have them
			if (RouterNode)
			{
	            NodeName = ROUTER_NODE_VALUE;
				if (pPortDesc->pd_RoutersPramNode.atn_Network != UNKNOWN_NETWORK)
				{
					desiredNode = pPortDesc->pd_RoutersPramNode;
				}
			}
			else
			{
				if ((pPortDesc->pd_Flags & PD_USER_NODE_1) == 0)
				{
	                NodeName = USER_NODE1_VALUE;
	                if (pPortDesc->pd_UsersPramNode1.atn_Network != UNKNOWN_NETWORK)
					{
						//	If we are not a router node, and the first user node
						//	has not been allocated...
						desiredNode = pPortDesc->pd_UsersPramNode1;
					}
				}
				else if ((pPortDesc->pd_Flags & PD_USER_NODE_2) == 0)
				{
	                NodeName = USER_NODE2_VALUE;
	                if (pPortDesc->pd_UsersPramNode2.atn_Network != UNKNOWN_NETWORK)
					{
						//	If we are not a router node, and the second user node
						//	has not been allocated...
						desiredNode = pPortDesc->pd_UsersPramNode2;
					}
				}
			}

			//	Flags should be set so future get node requests return failure
			//	until we are done with this attempt. We need to call
			//	the aarp routines without the lock held - they will
			//	block.

			ASSERT(pPortDesc->pd_Flags & PD_FINDING_NODE);

			RELEASE_SPIN_LOCK(&pPortDesc->pd_Lock, OldIrql);

			//	If this routine succeeds in finding the node, it
			//	will chain in the atalkNode into the port. It also
			//	returns with the proper flags set/reset in the
			//	pPortDesc structure. It will also have referenced the port
			//	and inserted the node into the port's node list.
			error = AtalkInitAarpForNodeOnPort(pPortDesc,
											   AllowStartupRange,
											   desiredNode,
											   &pNode);

			ACQUIRE_SPIN_LOCK(&pPortDesc->pd_Lock, &OldIrql);

			if (!ATALK_SUCCESS(error))
			{
				//	AARP for node failed.
				LOG_ERRORONPORT(pPortDesc,
				                EVENT_ATALK_INIT_COULDNOTGETNODE,
								0,
								NULL,
								0);
			}
		}

	} while (FALSE);

	//	Ok, done finding node. No need for a crit section.
	pPortDesc->pd_Flags &= ~PD_FINDING_NODE;

	if (ATALK_SUCCESS(error))
	{
		//	If router node, remember it in port descriptor
		//	Do this before setting up the rtmp/nbp listeners.
		//	In anycase, clients must check this value for null,
		//	not guaranteed as zip socket could already be open.
		if (RouterNode)
			pPortDesc->pd_RouterNode = pNode;

		RELEASE_SPIN_LOCK(&pPortDesc->pd_Lock, OldIrql);

		//	Setup the RTMP, NBP and EP listeners on this node.
		//	These will be the non-router versions. StartRouting
		//	calls will then switch them to be the router versions
		//	at the appropriate time.
	
		error = AtalkInitDdpOpenStaticSockets(pPortDesc, pNode);
	
		if (ATALK_SUCCESS(error))
		{
			if (EXT_NET(pPortDesc))
			{
				//	We always save this address.
				AtalkInitNodeSavePramAddr(pPortDesc,
										  NodeName,
										  &pNode->an_NodeAddr);
			}
			
			// 	Return the address of the node opened.
			if (NodeAddr != NULL)
				*NodeAddr = pNode->an_NodeAddr;
		}
		else
		{
			//	Error opening sockets. Release node, return failure
			LOG_ERRORONPORT(pPortDesc,
			                EVENT_ATALK_NODE_OPENSOCKETS,
							0,
							NULL,
							0);
			AtalkNodeReleaseOnPort(pPortDesc, pNode);
		}
	}
	else
	{
		RELEASE_SPIN_LOCK(&pPortDesc->pd_Lock, OldIrql);
	}

	if (!ATALK_SUCCESS(error))
	{
		DBGPRINT(DBG_COMP_NODE, DBG_LEVEL_INFO,
				("Creation node on port %lx failed! %lx\n",
				pPortDesc,  error));
	}
	else
	{
		DBGPRINT(DBG_COMP_NODE, DBG_LEVEL_INFO,
				("Creation node on port %lx with addr %lx.%lx and p%lx\n",
				pPortDesc,  pNode->an_NodeAddr.atn_Network,
				pNode->an_NodeAddr.atn_Node, pNode));
	}

	return(error);
}




ATALK_ERROR
AtalkNodeReleaseOnPort(
	PPORT_DESCRIPTOR	pPortDesc,
	PATALK_NODE			pNode
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PDDP_ADDROBJ	pDdpAddr, pNextAddr;
	ATALK_ERROR	error;
	KIRQL			OldIrql;
	SHORT			i;

	DBGPRINT(DBG_COMP_NODE, DBG_LEVEL_WARN,
			("AtalkNodeReleaseOnPort: Releasing node %lx on port %lx!\n", pNode, pPortDesc));

	ACQUIRE_SPIN_LOCK(&pNode->an_Lock, &OldIrql);

	if ((pNode->an_NodeAddr.atn_Network == AtalkUserNode1.atn_Network) &&
		(pNode->an_NodeAddr.atn_Node == AtalkUserNode1.atn_Node))
	{
		pPortDesc->pd_Flags &= ~PD_USER_NODE_1;
		AtalkUserNode1.atn_Network = 0;
		AtalkUserNode1.atn_Node = 0;
	}
	else if ((pNode->an_NodeAddr.atn_Network == AtalkUserNode2.atn_Network) &&
			 (pNode->an_NodeAddr.atn_Node == AtalkUserNode2.atn_Node))
	{
		pPortDesc->pd_Flags &= ~PD_USER_NODE_2;
		AtalkUserNode2.atn_Network = 0;
		AtalkUserNode2.atn_Node = 0;
	}

	if ((pNode->an_Flags & AN_CLOSING) == 0)
	{
		//	Set the closing flag.
		pNode->an_Flags |= AN_CLOSING;

		//	First close all the sockets on the node
		for (i = 0; i < NODE_DDPAO_HASH_SIZE; i++)
		{
			pNextAddr = NULL;
			AtalkDdpReferenceNextNc(pNode->an_DdpAoHash[i],
									&pDdpAddr,
									&error);

			if (!ATALK_SUCCESS(error))
			{
				//	Check the other hash table entries. No non-closing
				//	sockets on this list.
				continue;
			}
	
			while (TRUE)
			{
				//	Get the next non-closing node using our referenced node before
				//	closing it. Note we use pDdpAddr->...Flink.
				AtalkDdpReferenceNextNc(pDdpAddr->ddpao_Next,
										&pNextAddr,
										&error);
	
				//	Close the referenced ddp addr after releasing the node lock.
				RELEASE_SPIN_LOCK(&pNode->an_Lock, OldIrql);

                if (pDdpAddr->ddpao_Flags & DDPAO_SOCK_INTERNAL)
                {
				    AtalkDdpCloseAddress(pDdpAddr, NULL, NULL);
                }
                else
                {
                    AtalkDdpPnPSuspendAddress(pDdpAddr);
                }

				//	Dereference the address.
				AtalkDdpDereference(pDdpAddr);

				ACQUIRE_SPIN_LOCK(&pNode->an_Lock, &OldIrql);
	
				if (pNextAddr != NULL)
					pDdpAddr = pNextAddr;
				else
					break;
			}
		}

		RELEASE_SPIN_LOCK(&pNode->an_Lock, OldIrql);

		//	Remove the creation reference for this node.
		AtalkNodeDereference(pNode);
	}
	else
	{
		//	We are already closing.
		RELEASE_SPIN_LOCK(&pNode->an_Lock, OldIrql);
	}

	return(ATALK_NO_ERROR);
}




BOOLEAN
AtalkNodeExistsOnPort(
	PPORT_DESCRIPTOR	pPortDesc,
	PATALK_NODEADDR		pNodeAddr
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PATALK_NODE		pCheckNode;
	BOOLEAN			exists = FALSE;


	ACQUIRE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);

	for (pCheckNode = pPortDesc->pd_Nodes;
		 pCheckNode != NULL;
		 pCheckNode = pCheckNode->an_Next)
	{
		if (ATALK_NODES_EQUAL(&pCheckNode->an_NodeAddr, pNodeAddr))
		{
			exists = TRUE;
			break;
		}
	}

	RELEASE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);

	return(exists);
}




VOID
AtalkInitNodeSavePramAddr(
	IN	PPORT_DESCRIPTOR	pPortDesc,
	IN	PWSTR				RegValue,
	OUT	PATALK_NODEADDR		pNode
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	UNICODE_STRING	valueName;
	ULONG			bytesWritten;
	ULONG			ValueToSave;

	// Save the node value as xxxx00yy where xxxx is network, yy is node
	ValueToSave = (pNode->atn_Network << 16) + pNode->atn_Node;

	RtlInitUnicodeString (&valueName, RegValue);

	ZwSetValueKey(pPortDesc->pd_AdapterInfoHandle,
				  &valueName,
				  0,
				  REG_DWORD,
				  &ValueToSave,
				  sizeof(ULONG));
}




VOID
AtalkInitNodeGetPramAddr(
	IN	PPORT_DESCRIPTOR	pPortDesc,
	IN	PWSTR				RegValue,
	OUT	PATALK_NODEADDR		pNode
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	NTSTATUS		Status;
	UNICODE_STRING	valueName;
	ULONG			bytesWritten;
	ULONG			ValueRead;
	BYTE			buffer[sizeof(KEY_VALUE_FULL_INFORMATION) + 32];
	PKEY_VALUE_FULL_INFORMATION nodeValue = (PKEY_VALUE_FULL_INFORMATION)buffer;

	RtlInitUnicodeString (&valueName, RegValue);

	Status = ZwQueryValueKey(pPortDesc->pd_AdapterInfoHandle,
							 &valueName,
							 KeyValueFullInformation,
							 buffer,
							 sizeof(buffer),
							 &bytesWritten);
	if (NT_SUCCESS(Status))
	{
		ValueRead = *(PULONG)(buffer + nodeValue->DataOffset);
	}
	else
	{
		ValueRead = 0;
		ASSERT (UNKNOWN_NETWORK == 0);
		ASSERT (UNKNOWN_NODE == 0);
	}
	pNode->atn_Node = (BYTE)(ValueRead & 0xFF);
	pNode->atn_Network = (USHORT)(ValueRead >> 16);
	if ((pNode->atn_Network == UNKNOWN_NETWORK) ||
		(pNode->atn_Node == UNKNOWN_NODE))
	{
		pNode->atn_Node = UNKNOWN_NODE;
        pNode->atn_Network = UNKNOWN_NETWORK;
	}
}




VOID
AtalkZapPramValue(
	IN	PPORT_DESCRIPTOR	pPortDesc,
	IN	PWSTR				RegValue
)
{
	UNICODE_STRING	valueName;
	ULONG			bytesWritten;
	ULONG			ValueToSave;

	// Write 0 to the value to zap it for now.
	ValueToSave = 0;

	RtlInitUnicodeString (&valueName, RegValue);

	ZwSetValueKey(pPortDesc->pd_AdapterInfoHandle,
				  &valueName,
				  0,
				  REG_DWORD,
				  &ValueToSave,
				  sizeof(ULONG));
}


ATALK_ERROR
AtalkInitNodeAllocate(
	IN	PPORT_DESCRIPTOR	pPortDesc,
	OUT PATALK_NODE			*ppNode
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PATALK_NODE		pNode;

	// 	Allocate a new active Node structure
	if ((pNode = (PATALK_NODE)AtalkAllocZeroedMemory(sizeof(ATALK_NODE))) == NULL)
	{
		return(ATALK_RESR_MEM);
	}

	//	Initialize some elements of the structure. Remaining stuff
	//	done when the node is actually being inserted into the port
	//	hash table.
#if	DBG
	pNode->an_Signature = AN_SIGNATURE;
#endif

	// Initialize the Nbp Id & Enumerator
	pNode->an_NextNbpId = 0;
	pNode->an_NextNbpEnum = 0;
	pNode->an_NextDynSkt = FIRST_DYNAMIC_SOCKET;
	INITIALIZE_SPIN_LOCK(&pNode->an_Lock);
	pNode->an_Port = pPortDesc;			// Port on which node exists
	pNode->an_RefCount = 1;				// Reference for creation.

	//	Return pointer to allocated node
	*ppNode = pNode;

	return(ATALK_NO_ERROR);
}




VOID
AtalkNodeRefByAddr(
	IN	PPORT_DESCRIPTOR	pPortDesc,
	IN	PATALK_NODEADDR		NodeAddr,
	OUT	PATALK_NODE		*	ppNode,
	OUT	PATALK_ERROR		pErr
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PATALK_NODE	pNode;
	KIRQL		OldIrql;
	BOOLEAN		foundNode = FALSE;

	*pErr = ATALK_NODE_NONEXISTENT;

	ACQUIRE_SPIN_LOCK(&pPortDesc->pd_Lock, &OldIrql);
	for (pNode = pPortDesc->pd_Nodes; pNode != NULL; pNode = pNode->an_Next)
	{
		ASSERT(VALID_ATALK_NODE(pNode));

		//	Note: On non-extended ports, there should be only one pNode.
		if (((NodeAddr->atn_Network == CABLEWIDE_BROADCAST_NETWORK) 	||
			 (pNode->an_NodeAddr.atn_Network == NodeAddr->atn_Network)	||
			 (!EXT_NET(pPortDesc) && (pNode->an_NodeAddr.atn_Network == UNKNOWN_NETWORK)))

			&&

			((NodeAddr->atn_Node == ATALK_BROADCAST_NODE) ||
			 (pNode->an_NodeAddr.atn_Node == NodeAddr->atn_Node)))
		{
			DBGPRINT(DBG_COMP_NODE, DBG_LEVEL_INFO,
					("AtalkNodeRefByAddr: Found: %lx.%lx for Lookup: %lx.%lx\n",
						pNode->an_NodeAddr.atn_Network, pNode->an_NodeAddr.atn_Node,
						NodeAddr->atn_Network, NodeAddr->atn_Node));

			foundNode = TRUE;
			break;
		}
	}

	if (foundNode)
	{
		AtalkNodeRefByPtr(pNode, pErr);

		// Return a pointer to the referenced node.
		if (ATALK_SUCCESS(*pErr))
		{
			ASSERT(ppNode != NULL);
			ASSERT(pNode != NULL);

			*ppNode = pNode;
		}
	}
	RELEASE_SPIN_LOCK(&pPortDesc->pd_Lock, OldIrql);
}




VOID
AtalkNodeRefNextNc(
	IN	PATALK_NODE		pNode,
	IN	PATALK_NODE	*	ppNode,
	OUT	PATALK_ERROR	pErr
	)
/*++

Routine Description:

	MUST BE CALLED WITH THE PORTLOCK HELD!

Arguments:


Return Value:


--*/
{
	*pErr = ATALK_FAILURE;
	*ppNode = NULL;
	for (; pNode != NULL; pNode = pNode->an_Next)
	{
		ASSERT(VALID_ATALK_NODE(pNode));

		AtalkNodeRefByPtr(pNode, pErr);
		if (ATALK_SUCCESS(*pErr))
		{
			//	Ok, this node is referenced!
			*ppNode = pNode;
			break;
		}
	}
}




VOID
AtalkNodeDeref(
	IN	OUT	PATALK_NODE	pNode
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PPORT_DESCRIPTOR	pPortDesc = pNode->an_Port;
	KIRQL				OldIrql;
	BOOLEAN				done = FALSE;

	ASSERT(VALID_ATALK_NODE(pNode));

	ACQUIRE_SPIN_LOCK(&pNode->an_Lock, &OldIrql);

	ASSERT(pNode->an_RefCount > 0);
	if (--pNode->an_RefCount == 0)
	{
		done = TRUE;
	}
	RELEASE_SPIN_LOCK(&pNode->an_Lock, OldIrql);

	if (done)
	{
		PATALK_NODE	*ppNode;

		ASSERT((pNode->an_Flags & AN_CLOSING) != 0);

		DBGPRINT(DBG_COMP_NODE, DBG_LEVEL_WARN,
				("AtalkNodeDeref: Freeing node %lx\n", pNode));

		ACQUIRE_SPIN_LOCK(&pPortDesc->pd_Lock, &OldIrql);
		//	Remove this guy from the port linkage
		for (ppNode = &pNode->an_Port->pd_Nodes;
			 *ppNode != NULL;
			 ppNode = &((*ppNode)->an_Next))
		{
			if (*ppNode == pNode)
			{
				*ppNode = pNode->an_Next;
				break;
			}
		}
		RELEASE_SPIN_LOCK(&pPortDesc->pd_Lock, OldIrql);

		//	Dereference the port for this node
		AtalkPortDereference(pPortDesc);

		//	Free the node structure
		AtalkFreeMemory(pNode);
	}
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\atalk\sys\node.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

	node.h

Abstract:

	This module contains support for the Appletalk Node structure.

Author:

	Jameel Hyder (jameelh@microsoft.com)
	Nikhil Kamkolkar (nikhilk@microsoft.com)

Revision History:
	19 Jun 1992		Initial Version

Notes:	Tab stop: 4
--*/

#ifndef	_NODE_
#define	_NODE_

#define ANY_ROUTER_NODE		 		0
#define UNKNOWN_NODE				0
#define MAX_ATALK_NODES				256
#define MIN_USABLE_ATALKNODE  		1
#define MAX_USABLE_ATALKNODE  		254
#define MAX_EXT_ATALKNODE			253
#define HIGHEST_WORKSTATION_NODE	127
#define LOWEST_SERVER_NODE	  		128
#define ATALK_BROADCAST_NODE		((BYTE)0xFF)
#define	NUM_USER_NODES				2


//  NODE STATES
#define	AN_OPEN						0x01
#define	AN_ROUTER_NODE				0x02
#define	AN_ORPHAN_NODE				0x04
#define AN_CLOSING					0x80

// values under which pram nodes are stored
#define	ROUTER_NODE_VALUE			L"RouterPramNode"
#define	USER_NODE1_VALUE			L"UserPramNode1"
#define	USER_NODE2_VALUE			L"UserPramNode2"

//	Number of slots in the socket hash table stored per node
#define		NODE_DDPAO_HASH_SIZE	8

#define	AN_SIGNATURE			(*(PULONG)"ANOD")
#if	DBG
#define	VALID_ATALK_NODE(pNode)	(((pNode) != NULL) &&	\
								 ((pNode)->an_Signature == AN_SIGNATURE))
#else
#define	VALID_ATALK_NODE(pNode)	((pNode) != NULL)
#endif
typedef struct _ATALK_NODE
{

#if DBG
	ULONG					an_Signature;
#endif

	//	List for all active nodes on a port
	struct _ATALK_NODE *	an_Next;

	ULONG  					an_RefCount;

	//	Backpointer to the port for this node
	struct _PORT_DESCRIPTOR	*an_Port;

	//  State of the node
	BYTE 					an_Flags;

	//	Next dynamic socket number to create on this node.
	BYTE					an_NextDynSkt;

	//	Nbp Id & Enumerator to use on the next NbpAction
	BYTE					an_NextNbpId;
	BYTE					an_NextNbpEnum;

	//	Hash List of ddp address objects (accessed by the
	//	Appletalk socket address) on this node
	struct _DDP_ADDROBJ	*	an_DdpAoHash[NODE_DDPAO_HASH_SIZE];

	//	Address of this node
	ATALK_NODEADDR			an_NodeAddr;

	//	Lock
	ATALK_SPIN_LOCK			an_Lock;
} ATALK_NODE, *PATALK_NODE;

//	Exports

VOID
AtalkNodeRefByAddr(
	IN	PPORT_DESCRIPTOR		pPortDesc,
	IN  PATALK_NODEADDR     	pNodeAddr,
	OUT	PATALK_NODE			*	pNode,
	OUT	PATALK_ERROR			pErr
);

// VOID
// AtalkNodeRefByPtr(
// 	IN	OUT	PATALK_NODE			Node,
// 	OUT		PATALK_ERROR		pErr
// );
#define	AtalkNodeRefByPtr(_pNode, _pErr)				\
	{													\
		KIRQL	OldIrql;								\
														\
		ASSERT(VALID_ATALK_NODE(_pNode));				\
														\
		ACQUIRE_SPIN_LOCK(&(_pNode)->an_Lock, &OldIrql);\
		AtalkNodeRefByPtrNonInterlock(_pNode, _pErr);	\
		RELEASE_SPIN_LOCK(&(_pNode)->an_Lock, OldIrql);	\
	}

// VOID
// AtalkNodeRefByPtrNonInterlock(
//	IN	OUT	PATALK_NODE			Node,
//	OUT		PATALK_ERROR		pErr
// );

#define	AtalkNodeRefByPtrNonInterlock(_pNode, _pErr)	\
	{													\
		ASSERT(VALID_ATALK_NODE(_pNode));				\
														\
		if (((_pNode)->an_Flags & AN_CLOSING) == 0)		\
		{												\
			(_pNode)->an_RefCount++;					\
			*(_pErr) = ATALK_NO_ERROR;					\
		}												\
		else											\
		{												\
			*(_pErr) = ATALK_NODE_CLOSING;				\
			DBGPRINT(DBG_COMP_NODE, DBG_LEVEL_WARN,		\
					("AtalkNodeRefByPtrNonInterlock: Attempt to ref a closing node %lx (%x.%x)\n",\
					_pNode, (_pNode)->an_NodeAddr.atn_Network, (_pNode)->an_NodeAddr.atn_Node));\
		}												\
	}

VOID
AtalkNodeRefNextNc(
	IN	PATALK_NODE				pNode,
	IN	PATALK_NODE		*		ppNode,
	OUT	PATALK_ERROR			pErr
);

VOID
AtalkNodeDeref(
	IN	OUT	PATALK_NODE			pNode
);

ATALK_ERROR
AtalkInitNodeCreateOnPort(
	IN  PPORT_DESCRIPTOR		pPortDesc,
	IN  BOOLEAN					AllowStartupRange,
	IN  BOOLEAN					RouterNode,
	IN  PATALK_NODEADDR			pNodeAddr
);

ATALK_ERROR
AtalkNodeReleaseOnPort(
	IN  PPORT_DESCRIPTOR		pPortDesc,
	IN  PATALK_NODE				pNode
);

BOOLEAN
AtalkNodeExistsOnPort(
	IN  PPORT_DESCRIPTOR		pPortDesc,
	IN  PATALK_NODEADDR			pNodeAddr
);

ATALK_ERROR
AtalkInitNodeAllocate(
	IN	PPORT_DESCRIPTOR		pPortDesc,
	OUT PATALK_NODE			*	ppNode
);

//	MACROS

#if DBG
#define	AtalkNodeReferenceByAddr(pPortDesc,NodeAddr,Node, pErr)	\
		{														\
			AtalkNodeRefByAddr(pPortDesc,NodeAddr,Node, pErr);	\
			if (ATALK_SUCCESS(*pErr))							\
			{													\
				DBGPRINT(DBG_COMP_NODE,	DBG_LEVEL_REFNODE,		\
				("AtalkNodeRefByAddr : %s %d PostCount %d\n",	\
				__FILE__, __LINE__,(*Node)->an_RefCount));		\
			}													\
		}

#define	AtalkNodeReferenceByPtr(Node, pErr)						\
		{														\
			AtalkNodeRefByPtr(Node, pErr);						\
			DBGPRINT(DBG_COMP_NODE,	DBG_LEVEL_REFNODE,			\
			("AtalkNodeRefByPtr : %s %d PostCount %d\n",		\
			__FILE__, __LINE__, Node->an_RefCount))				\
		}

#define	AtalkNodeReferenceByPtrNonInterlock(Node, pErr)			\
		{														\
			AtalkNodeRefByPtrNonInterlock(Node, pErr);			\
			DBGPRINT(DBG_COMP_NODE,	DBG_LEVEL_REFNODE,			\
			("AtalkNodeRefByPtrNi : %s %d PostCount %d\n",		\
				__FILE__, __LINE__,Node->an_RefCount));			\
		}

#define	AtalkNodeReferenceNextNc(pNode, ppNode, pErr)			\
		{														\
			AtalkNodeRefNextNc(pNode, ppNode, pErr);			\
			if (ATALK_SUCCESS(*pErr))							\
			{													\
				DBGPRINT(DBG_COMP_NODE,	DBG_LEVEL_REFNODE, 		\
				("AtalkNodeRefByPtrNc : %s %d PostCount %d\n",	\
				__FILE__, __LINE__, (*ppNode)->an_RefCount));	\
			}													\
		}

#define	AtalkNodeDereference(Node)								\
		{														\
			DBGPRINT(DBG_COMP_NODE,	DBG_LEVEL_REFNODE, 			\
			("AtalkNodeDerefByPtr : %s %d PreCount %d\n",		\
			__FILE__, __LINE__,Node->an_RefCount));				\
			AtalkNodeDeref(Node);								\
		}

#else
#define	AtalkNodeReferenceByAddr(pPortDesc,NodeAddr,Node, pErr)	\
			AtalkNodeRefByAddr(pPortDesc,NodeAddr,Node, pErr)

#define	AtalkNodeReferenceByPtr(Node, pErr)						\
			AtalkNodeRefByPtr(Node, pErr)

#define	AtalkNodeReferenceByPtrNonInterlock(Node, pErr)			\
			AtalkNodeRefByPtrNonInterlock(Node, pErr)		

#define	AtalkNodeReferenceNextNcNonInterlock(pNode, ppNode, pErr)\
			AtalkNodeRefNextNcNonInterlock(pNode, ppNode, pErr)	

#define	AtalkNodeReferenceNextNc(pNode, ppNode, pErr)			\
			AtalkNodeRefNextNc(pNode, ppNode, pErr);

#define	AtalkNodeDereference(Node)	AtalkNodeDeref(Node)							
#endif


VOID
AtalkInitNodeSavePramAddr(
	IN	PPORT_DESCRIPTOR	pPortDesc,
	IN	PWSTR				RegValue,
	IN	PATALK_NODEADDR		Node
);

VOID
AtalkInitNodeGetPramAddr(       	
	IN	PPORT_DESCRIPTOR	pPortDesc,
	IN	PWSTR				RegValue,
	OUT	PATALK_NODEADDR		Node
);


VOID
AtalkZapPramValue(
	IN	PPORT_DESCRIPTOR	pPortDesc,
	IN	PWSTR				RegValue
);

#endif	// _NODE_


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\atalk\sys\pap.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

	pap.h

Abstract:

	This module contains definitions for the PAP code.

Author:

	Jameel Hyder (jameelh@microsoft.com)
	Nikhil Kamkolkar (nikhilk@microsoft.com)

Revision History:
	19 Jun 1992		Initial Version

Notes:	Tab stop: 4
--*/

#ifndef	_PAP_
#define	_PAP_

// PAP command type bytes:

#define PAP_OPEN_CONN					1
#define PAP_OPEN_CONNREPLY				2
#define PAP_SEND_DATA			 		3
#define PAP_DATA				 		4
#define PAP_TICKLE						5
#define PAP_CLOSE_CONN					6
#define PAP_CLOSE_CONN_REPLY 			7
#define PAP_SEND_STATUS					8
#define PAP_STATUS_REPLY				9

// Error codes for OpenConnectionReply:

#define PAP_NO_ERROR					0x0000
#define PAP_PRINTER_BUSY				0xFFFF

// PAP sizes:

#define PAP_MAX_DATA_PACKET_SIZE		512
#define	PAP_SEND_USER_BYTES_ALL			TRUE
#define PAP_MAX_STATUS_SIZE				255

#define PAP_MAX_FLOW_QUANTUM			8

#define PAP_MAX_ATP_BYTES_TO_SL	 		4

// PAP timer values:

#define PAP_OPENCONN_REQ_RETRYCOUNT		5
#define PAP_OPENCONN_INTERVAL	 		20		// In 100ms units
#define PAP_TICKLE_INTERVAL				600		// In 100ms units
#define PAP_CONNECTION_INTERVAL			1200	// In 100ms units
#define PAP_MIN_SENDDATA_REQ_INTERVAL	10		// In 100ms units
#define PAP_MAX_SENDDATA_REQ_INTERVAL	150		// In 100ms units
#define PAP_INIT_SENDDATA_REQ_INTERVAL	10		// In 100ms units

// The following aren't documented... so we'll take a wild guess...

#define PAP_GETSTATUS_REQ_RETRYCOUNT	5
#define PAP_GETSTATUS_ATP_INTERVAL 		20		// In 100ms units

// Offsets within ATP userBytes and data buffer for the various fields of the
// PAP header:

#define PAP_CONNECTIONID_OFF			0
#define PAP_CMDTYPE_OFF					1
#define PAP_EOFFLAG_OFF					2
#define PAP_SEQNUM_OFF					2

#define PAP_RESP_SOCKET_OFF 			0
#define PAP_FLOWQUANTUM_OFF				1
#define PAP_WAITTIME_OFF				2
#define PAP_RESULT_OFF					2
#define PAP_STATUS_OFF					4

#define	PAP_MAX_WAIT_TIMEOUT			0x80	// Pretty randomly chosen

// For resolving forward references
struct _PAP_ADDROBJ;
struct _PAP_CONNOBJ;

// PAP Address Object
// This is created whenever an address object is created on the Pap device.
// This represents either a client or a server side pap address. The server
// side address is represented by PAPAO_LISTENER flag.

#define	PAP_CONN_HASH_SIZE				7


// PAP ADDRESS OBJECT STATES
#define	PAPAO_LISTENER					0x00000001
#define	PAPAO_CONNECT					0x00000002
#define	PAPAO_UNBLOCKED					0x00000004
#define	PAPAO_SLS_QUEUED				0x00000008
#define	PAPAO_CLEANUP					0x01000000
#define	PAPAO_BLOCKING					0x02000000
#define	PAPAO_BLOCKING					0x02000000
#define	PAPAO_CLOSING					0x80000000

#define	PAPAO_SIGNATURE			(*(PULONG)"PAAO")
#define	VALID_PAPAO(pPapAddr)	(((pPapAddr) != NULL) && \
		(((struct _PAP_ADDROBJ *)(pPapAddr))->papao_Signature == PAPAO_SIGNATURE))

typedef struct _PAP_ADDROBJ
{
	ULONG					papao_Signature;

	//	Global list of address objects.
	struct _PAP_ADDROBJ	 *	papao_Next;
	struct _PAP_ADDROBJ	 **	papao_Prev;

	ULONG					papao_Flags;
	ULONG					papao_RefCount;

	//	List of connections associated with this address object.
	//	Potentially greater than one if this address object is a listener.
	struct	_PAP_CONNOBJ *	papao_pAssocConn;

	//	List of connections that are associated, but also have a listen/connect
	//	posted on them.
	union
	{
		struct	_PAP_CONNOBJ *	papao_pListenConn;
		struct	_PAP_CONNOBJ *	papao_pConnectConn;
	};

	//	Lookup list of all active connections hashed by connId and remote
	//	address.
	struct	_PAP_CONNOBJ *	papao_pActiveHash[PAP_CONN_HASH_SIZE];

	//	Next connection to use.
	BYTE					papao_NextConnId;

	//	The following are valid only if this is a listener.
	SHORT					papao_SrvQuantum;
	SHORT					papao_StatusSize;
	PBYTE					papao_pStatusBuf;

	//	Event support routines.
    //
    // This function pointer points to a connection indication handler for this
    // Address. Any time a connect request is received on the address, this
    // routine is invoked.
    PTDI_IND_CONNECT 		papao_ConnHandler;
    PVOID 					papao_ConnHandlerCtx;

    // The following function pointer always points to a TDI_IND_DISCONNECT
    // handler for the address.  If the NULL handler is specified in a
    // TdiSetEventHandler, this this points to an internal routine which
    // simply returns successfully.
    PTDI_IND_DISCONNECT 	papao_DisconnectHandler;
    PVOID 					papao_DisconnectHandlerCtx;

    // The following function pointer always points to a TDI_IND_RECEIVE
    // event handler for connections on this address.  If the NULL handler
    // is specified in a TdiSetEventHandler, then this points to an internal
    // routine which does not accept the incoming data.
    PTDI_IND_RECEIVE 		papao_RecvHandler;
    PVOID 					papao_RecvHandlerCtx;

    // The following function pointer always points to a TDI_IND_SEND_POSSIBLE
    // handler for the address.  If the NULL handler is specified in a
    // TdiSetEventHandler, this this points to an internal routine which
    // simply returns successfully.
    PTDI_IND_SEND_POSSIBLE  papao_SendPossibleHandler;
    PVOID   				papao_SendPossibleHandlerCtx;

	//	ATP Address for this pap address. If this is a listener, then the ATP
	//	address will be what the listens effectively will be posted on, if this
	//	is a connect address object, then this atp address will be what the
	//	associated connection be active over.
	PATP_ADDROBJ			papao_pAtpAddr;

	// Completion routine to be called when address is closed
	GENERIC_COMPLETION		papao_CloseComp;
	PVOID					papao_CloseCtx;

	PATALK_DEV_CTX			papao_pDevCtx;
	ATALK_SPIN_LOCK			papao_Lock;
} PAP_ADDROBJ, *PPAP_ADDROBJ;


#define	PAPCO_ASSOCIATED			0x00000001
#define	PAPCO_LISTENING				0x00000002
#define	PAPCO_CONNECTING			0x00000004
#define	PAPCO_ACTIVE				0x00000008
#define	PAPCO_SENDDATA_RECD			0x00000010
#define	PAPCO_WRITEDATA_WAITING		0x00000020
#define	PAPCO_SEND_EOF_WRITE		0x00000040
#define	PAPCO_READDATA_PENDING		0x00000080
#define	PAPCO_DISCONNECTING			0x00000100
#define	PAPCO_LOCAL_DISCONNECT		0x00000200
#define	PAPCO_REMOTE_DISCONNECT		0x00000400
#define	PAPCO_SERVER_JOB			0x00000800
#define	PAPCO_REMOTE_CLOSE			0x00001000
#define	PAPCO_NONBLOCKING_READ		0x00002000
#define	PAPCO_READDATA_WAITING		0x00004000
#define	PAPCO_DELAYED_DISCONNECT	0x00008000
#define	PAPCO_RECVD_DISCONNECT		0x00010000
#define PAPCO_ADDR_ACTIVE           0x00020000
#define PAPCO_REJECT_READS          0x00040000
#if DBG
#define	PAPCO_CLEANUP				0x01000000
#define	PAPCO_INDICATE_AFD_DISC		0x02000000
#endif
#define	PAPCO_STOPPING				0x40000000
#define	PAPCO_CLOSING				0x80000000

#define	PAPCO_SIGNATURE				(*(PULONG)"PACO")

#define	VALID_PAPCO(pPapConn)	(((pPapConn) != NULL) && \
		(((struct _PAP_CONNOBJ *)(pPapConn))->papco_Signature == PAPCO_SIGNATURE))

// This will represent a 'job' on the Pap address. This could either be a
// workstation job or a server job. In the latter case it could either
// be in a 'listen' state or active state. In the former case it is either
// active or 'waiting'
typedef struct _PAP_CONNOBJ
{
	ULONG					papco_Signature;

	//	Global list of connection objects.
	struct _PAP_CONNOBJ	 *	papco_Next;
	struct _PAP_CONNOBJ	**	papco_Prev;

	ULONG					papco_Flags;
	ULONG					papco_RefCount;

	//	Backpointer to the associated address
	struct _PAP_ADDROBJ	*	papco_pAssocAddr;

	//	The address this connection uses for itself. In the case of a connect
	//	this will be the same as the address object's ATP address.
	PATP_ADDROBJ			papco_pAtpAddr;

	//	Used to queue into the address object's associated list.
	struct	_PAP_CONNOBJ *	papco_pNextAssoc;

	//	Used to queue into the address object's listen/connect list. When it
	//	is removed from the listen/connect, it goes into the active list of the
	//	address object. When active, pNextActive will be the overflow list.
	union
	{
		struct	_PAP_CONNOBJ *	papco_pNextListen;
		struct	_PAP_CONNOBJ *	papco_pNextConnect;
		struct	_PAP_CONNOBJ *	papco_pNextActive;
	};

	//	Address of remote end of the connection
	ATALK_ADDR				papco_RemoteAddr;

	//	Connection id
	BYTE					papco_ConnId;

	// WaitTime value for PapConnect call. We start with 0 and increment by 2
	// till we either succeed or reach PAP_MAX_WAIT_TIMEOUT
	BYTE					papco_WaitTimeOut;

	//	Max size we can write to the remote end. This is dictated by the
	//	remote end. Our recv flow quantum will always be PAP_MAX_FLOW_QUANTUM.
	SHORT					papco_SendFlowQuantum;

	LONG					papco_LastContactTime;
	USHORT					papco_TickleTid;

	// Adaptive Retry time support
	RT						papco_RT;

	//	Connection context
	PVOID					papco_ConnCtx;

	//	PAP handles only one read and one write per job at a time. So we
	//	explicitly have the relevant information for the two cases in here.

	//	PAPWRITE():
	//	If the remote end did a papread() and we are waiting for our client
	//	to do a papwrite(), then the PAPCO_SENDDATA_RECD will be true and the
	//	following will be used for our papwrite() response. Note
	//	that we will assume all send data responses to be exactly-once.
	PATP_RESP				papco_pAtpResp;

	//	Next expected sequence number of send data.
	USHORT					papco_NextIncomingSeqNum;

	//	Where did the senddata request come from. NOTE this may not be the
	//	same as papco_RemoteAddr!!!
	ATALK_ADDR				papco_SendDataSrc;

	//	If the remote end has not done a send data, then our write will pend
	//	and the	PAPCO_WRITEDATA_WAITING will be set. Even if send credit is
	//	available the write will pend until all the data is sent out. But in
	//	that case both the PAPCO_WRITEDATA_WAITING and the PAPCO_SENDDATA_RECD will
	//	be set. Note that whenever PAPCO_WRITEDATA_WAITING is set, no new writes
	//	will be accepted by PAP for this job.
	PAMDL					papco_pWriteBuf;
	SHORT					papco_WriteLen;

	GENERIC_WRITE_COMPLETION papco_WriteCompletion;
	PVOID					papco_WriteCtx;

	//	PAPREAD():
	//	In the case where we are doing a PapRead(). Pap only allows one read
	//	at a time per connection. The last seq num we used for an outgoing senddata.
	//	While a PAPREAD() is active, the PAPCO_READDATA_PENDING will be set.
	//	NOTE: The user's buffer is passed on to ATP as a response buffer. For
	//	nonblocking reads we prime with the users buffers which are stored here.
	ULONG					papco_NbReadFlags;
	PACTREQ					papco_NbReadActReq;
	USHORT					papco_NbReadLen;		//	Number of bytes read

	USHORT					papco_ReadDataTid;
	USHORT					papco_NextOutgoingSeqNum;
	GENERIC_READ_COMPLETION	papco_ReadCompletion;
	PVOID					papco_ReadCtx;

	//	The connection object can have either a CONNECT or a LISTEN posted
	//	on it, but not both.
	union
	{
	  struct
	  {
		//	Pending Listen routine.
		GENERIC_COMPLETION	papco_ListenCompletion;
		PVOID				papco_ListenCtx;
	  };

	  struct
	  {
		//	Pending Connect routine. The status buffer is remembered and
		//	returned via socket options. The pConnectRespBuf is remembered
		//	to avoid having to get the system address for it. It is freed
		//	when connection is taken off the connectlist.
		GENERIC_COMPLETION	papco_ConnectCompletion;
		PVOID				papco_ConnectCtx;
        PBYTE				papco_pConnectRespBuf;
		PBYTE				papco_pConnectOpenBuf;
		USHORT				papco_ConnectRespLen;
		USHORT				papco_ConnectTid;
	  };
	};

	//	Disconnect inform routine
	GENERIC_COMPLETION		papco_DisconnectInform;
	PVOID					papco_DisconnectInformCtx;

	//	Disconnect request completion
	ATALK_ERROR				papco_DisconnectStatus;
	GENERIC_COMPLETION		papco_DisconnectCompletion;
	PVOID					papco_DisconnectCtx;

	// Completion routine to be called when socket cleanup is called
	GENERIC_COMPLETION		papco_CleanupComp;
	PVOID					papco_CleanupCtx;

	// Completion routine to be called when socket is closed
	GENERIC_COMPLETION		papco_CloseComp;
	PVOID					papco_CloseCtx;

	PATALK_DEV_CTX			papco_pDevCtx;
	ATALK_SPIN_LOCK			papco_Lock;
} PAP_CONNOBJ, *PPAP_CONNOBJ;

//	Used for sending a status reply to a send status command.
typedef	struct _PAP_SEND_STATUS_REL
{
	PPAP_ADDROBJ			papss_pPapAddr;
	PATP_RESP				papss_pAtpResp;
	PAMDL					papss_pAmdl;
	BYTE					papss_StatusBuf[PAP_STATUS_OFF + 1];
	//	This will be followed by the actual status.
} PAP_SEND_STATUS_REL, *PPAP_SEND_STATUS_REL;


//	Used for sending a open reply
typedef	struct _PAP_OPEN_REPLY_REL
{
	PAMDL					papor_pRespAmdl;
	PATP_RESP				papor_pAtpResp;
	BYTE					papor_pRespPkt[PAP_MAX_DATA_PACKET_SIZE];
} PAP_OPEN_REPLY_REL, *PPAP_OPEN_REPLY_REL;

//	Routine prototypes
VOID
AtalkInitPapInitialize(
	VOID);

ATALK_ERROR
AtalkPapCreateAddress(
	IN	PATALK_DEV_CTX				pDevCtx	OPTIONAL,
	OUT	PPAP_ADDROBJ	*			ppPapAddr);

ATALK_ERROR
AtalkPapCleanupAddress(
	IN	PPAP_ADDROBJ				pPapAddr);

ATALK_ERROR
AtalkPapCloseAddress(
	IN	PPAP_ADDROBJ				pPapAddr,
	IN	GENERIC_COMPLETION			CompletionRoutine,
	IN	PVOID						pCloseCtx);

ATALK_ERROR
AtalkPapCreateConnection(
	IN	PVOID						pConnCtx,	// Context to associate with the session
	IN	PATALK_DEV_CTX				pDevCtx		OPTIONAL,
	OUT	PPAP_CONNOBJ 	*			ppPapConn);

ATALK_ERROR
AtalkPapCleanupConnection(
	IN	PPAP_CONNOBJ				pPapConn);

ATALK_ERROR
AtalkPapCloseConnection(
	IN	PPAP_CONNOBJ				pPapConn,
	IN	GENERIC_COMPLETION			CompletionRoutine,
	IN	PVOID						pCloseCtx);

ATALK_ERROR
AtalkPapConnStop(
	IN	PPAP_CONNOBJ				pPapConn);

ATALK_ERROR
AtalkPapAssociateAddress(
	IN	PPAP_ADDROBJ				pPapAddr,
	IN	PPAP_CONNOBJ				pPapConn);

ATALK_ERROR
AtalkPapDissociateAddress(
	IN	PPAP_CONNOBJ				pPapConn);

ATALK_ERROR
AtalkPapPostListen(
	IN	PPAP_CONNOBJ				pPapConn,
	IN	PVOID						pListenCtx,
	IN	GENERIC_COMPLETION			CompletionRoutine);

ATALK_ERROR
AtalkPapPrimeListener(
	IN	PPAP_ADDROBJ				pPapAddr);

ATALK_ERROR
AtalkPapCancelListen(
	IN	PPAP_CONNOBJ				pPapConn);

ATALK_ERROR
AtalkPapPostConnect(
	IN	PPAP_CONNOBJ				pPapConn,
	IN	PATALK_ADDR					pRemoteAddr,
	IN	PVOID						pConnectCtx,
	IN	GENERIC_COMPLETION			CompletionRoutine);

ATALK_ERROR
AtalkPapDisconnect(
	IN	PPAP_CONNOBJ				pPapConn,
	IN	ATALK_DISCONNECT_TYPE		DisconnectType,
	IN	PVOID						pDisconnectCtx,
	IN	GENERIC_COMPLETION			CompletionRoutine);

ATALK_ERROR
AtalkPapRead(
	IN	PPAP_CONNOBJ				pPapConn,
	IN	PAMDL						pReadBuf,
	IN	USHORT						ReadBufLen,
	IN	ULONG						ReadFlags,
	IN	PVOID						pReadCtx,
	IN	GENERIC_READ_COMPLETION		CompletionRoutine);

ATALK_ERROR
AtalkPapPrimeRead(
	IN	PPAP_CONNOBJ				pPapConn,
	IN	PACTREQ						pActReq);

ATALK_ERROR
AtalkPapWrite(
	IN	PPAP_CONNOBJ				pPapConn,
	IN	PAMDL						pWriteBuf,
	IN	USHORT						WriteBufLen,
	IN	ULONG						SendFlags,
	IN	PVOID						pWriteCtx,
	IN	GENERIC_WRITE_COMPLETION	CompletionRoutine);

ATALK_ERROR
AtalkPapSetStatus(
	IN	PPAP_ADDROBJ				pPapAddr,
	IN	PAMDL						pStatusMdl,
	IN	PACTREQ						pActReq);

ATALK_ERROR
AtalkPapGetStatus(
	IN	PPAP_ADDROBJ				pPapAddr,
	IN	PATALK_ADDR					pRemoteAddr,
	IN	PAMDL						pStatusAmdl,
	IN	USHORT						AmdlSize,
	IN	PACTREQ						pActReq);

VOID
AtalkPapQuery(
	IN	PVOID						pObject,
	IN	ULONG						ObjectType,
	IN	PAMDL						pAmdl,
	OUT	PULONG						BytesWritten);

VOID FASTCALL
atalkPapAddrDeref(
	IN	PPAP_ADDROBJ				pPapAddr);

VOID FASTCALL
atalkPapConnRefByPtrNonInterlock(
	IN	PPAP_CONNOBJ				pPapConn,
	OUT	PATALK_ERROR				pError);

VOID
atalkPapConnRefNextNc(
	IN		PPAP_CONNOBJ			pPapConn,
	IN		PPAP_CONNOBJ	*		ppPapConnNext,
	OUT		PATALK_ERROR			pError);

VOID
atalkPapConnRefByCtx(
	IN	PPAP_ADDROBJ				pPapAddr,
	IN	CONNECTION_CONTEXT			pCtx,
	OUT	PPAP_CONNOBJ	*			pPapConn,
	OUT	PATALK_ERROR				pError);

VOID FASTCALL
atalkPapConnDeref(
	IN	PPAP_CONNOBJ				pPapConn);

//	MACROS
#define	AtalkPapAddrReferenceNonInterlock(_pPapAddr, _pError)			\
		{																\
			if (((_pPapAddr)->papao_Flags & PAPAO_CLOSING) == 0)        \
			{                                                           \
				ASSERT((_pPapAddr)->papao_RefCount >= 1);               \
				(_pPapAddr)->papao_RefCount++;                          \
				*(_pError) = ATALK_NO_ERROR;                            \
			}                                                           \
			else                                                        \
			{                                                           \
				*(_pError) = ATALK_PAP_ADDR_CLOSING;                    \
			}                                                           \
			if (ATALK_SUCCESS(*(_pError)))								\
			{															\
				DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_REFPAPADDR,			\
						("RefAddr %lx at %s(%d) = %d\n",				\
						_pPapAddr, __FILE__, __LINE__,					\
						((_pPapAddr)->papao_RefCount)));				\
			}															\
		}

#define	AtalkPapAddrReference(pPapAddr, pError)							\
		{																\
			KIRQL	OldIrql;											\
																		\
			ACQUIRE_SPIN_LOCK(&(pPapAddr)->papao_Lock, &OldIrql);		\
			AtalkPapAddrReferenceNonInterlock(pPapAddr, pError);		\
			RELEASE_SPIN_LOCK(&(pPapAddr)->papao_Lock, OldIrql);		\
		}

#define	AtalkPapAddrDereference(pPapAddr)								\
		{																\
			DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_REFPAPADDR,				\
					("DerefAddr %lx at %s %d = %d\n",					\
					pPapAddr, __FILE__, __LINE__,						\
					((pPapAddr)->papao_RefCount-1)));					\
			atalkPapAddrDeref(pPapAddr);								\
		}

#define	AtalkPapConnReferenceByPtr(pPapConn, pError)					\
		{																\
			KIRQL	OldIrql;											\
																		\
			ACQUIRE_SPIN_LOCK(&(pPapConn)->papco_Lock, &OldIrql);		\
			AtalkPapConnReferenceByPtrNonInterlock(pPapConn, pError);	\
			RELEASE_SPIN_LOCK(&(pPapConn)->papco_Lock, OldIrql);		\
		}

#define	AtalkPapConnReferenceByPtrDpc(pPapConn, pError)					\
		{																\
			ACQUIRE_SPIN_LOCK_DPC(&(pPapConn)->papco_Lock);				\
			AtalkPapConnReferenceByPtrNonInterlock(pPapConn, pError);	\
			RELEASE_SPIN_LOCK_DPC(&(pPapConn)->papco_Lock);				\
		}

#define	AtalkPapConnReferenceByPtrNonInterlock(pPapConn, pError)		\
		{																\
			atalkPapConnRefByPtrNonInterlock(pPapConn, pError);			\
			if (ATALK_SUCCESS(*pError))									\
			{															\
				DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_REFPAPCONN,			\
						("RefConn %lx at %s (%ld): + 1 = %ld\n", 		\
						pPapConn, __FILE__, __LINE__,					\
						(pPapConn)->papco_RefCount));					\
			}															\
			else														\
			{															\
				DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_REFPAPCONN,			\
						("RefConn %lx at %s (%ld): FAILED, Flags %lx\n",\
						pPapConn, __FILE__, __LINE__,					\
						(pPapConn)->papco_Flags));						\
			}															\
		}

#define	AtalkPapConnReferenceByCtxNonInterlock(pPapAddr, Ctx, ppPapConn, pError) \
		{																\
			atalkPapConnRefByCtxNonInterlock(pPapAddr, Ctx, ppPapConn, pError);	\
			if (ATALK_SUCCESS(*pError))									\
			{															\
				DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_REFPAPCONN,			\
						("RefConnByCtx %lx at %s(%ld) = %ld\n", 		\
						*ppPapConn, __FILE__, __LINE__,					\
						((*ppPapConn)->papco_RefCount)));				\
			}															\
		}

#define	AtalkPapConnDereference(pPapConn)								\
		{																\
			DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_REFPAPCONN,				\
					("DerefConn %lx at %s(%ld) = %ld\n",				\
					pPapConn, __FILE__, __LINE__,						\
					(pPapConn)->papco_RefCount-1));						\
			atalkPapConnDeref(pPapConn);								\
		}

#define	AtalkPapGetDdpAddress(pPapAddr)									\
		AtalkAtpGetDdpAddress((pPapAddr)->papao_pAtpAddr)

#define	PAPCONN_DDPSOCKET(pPapConn)										\
		AtalkAtpGetDdpAddress((pPapConn)->papco_pAtpAddr)->ddpao_Addr.ata_Socket

#define	PAPADDR_DDPSOCKET(pPapAddr)										\
		AtalkAtpGetDdpAddress((pPapAddr)->papao_pAtpAddr)->ddpao_Addr.ata_Socket

//	List of all pap address/connection objects.
extern	PPAP_ADDROBJ	atalkPapAddrList;
extern	PPAP_CONNOBJ	atalkPapConnList;
extern	TIMERLIST		atalkPapCMTTimer;
extern	ATALK_SPIN_LOCK	atalkPapLock;

#define	PAP_HASH_ID_ADDR(_id, _pAddr)			\
			(((_pAddr)->ata_Node+((_pAddr)->ata_Network & 0xFF)+_id)%PAP_CONN_HASH_SIZE)

LOCAL	ATALK_ERROR
atalkPapRepostConnect(
	IN	PPAP_CONNOBJ				pPapConn,
	IN	PAMDL						pOpenAmdl,
	IN	PAMDL						pRespAmdl
);

LOCAL VOID
atalkPapSlsHandler(
	IN	ATALK_ERROR					ErrorCode,
	IN	PPAP_ADDROBJ				pPapAddr,		// Listener (our context)
	IN	PVOID						RespContext,	// CancelResp/PostResp will need this
	IN	PATALK_ADDR					pSrcAddr,		// Address of requestor
	IN	USHORT						PktLen,
	IN	PBYTE						pPkt,
	IN	PBYTE						pUserBytes);

LOCAL VOID
atalkPapIncomingReadComplete(
	IN	ATALK_ERROR					ErrorCode,
	IN	PPAP_CONNOBJ				pPapConn,		// Our context
	IN	PAMDL						pReqAmdl,
	IN	PAMDL						pReadAmdl,
	IN	USHORT						ReadLen,
	IN	PBYTE						ReadUserBytes);

LOCAL VOID
atalkPapPrimedReadComplete(
	IN	ATALK_ERROR					ErrorCode,
	IN	PPAP_CONNOBJ				pPapConn,		// Our context
	IN	PAMDL						pReqAmdl,
	IN	PAMDL						pReadAmdl,
	IN	USHORT						ReadLen,
	IN	PBYTE						ReadUserBytes);

LOCAL VOID
atalkPapIncomingStatus(
	IN	ATALK_ERROR					ErrorCode,
	IN	PACTREQ						pActReq,		// Our Ctx
	IN	PAMDL						pReqAmdl,
	IN	PAMDL						pStatusAmdl,
	IN	USHORT						StatusLen,
	IN	PBYTE						ReadUserBytes);

LOCAL VOID
atalkPapIncomingReq(
	IN	ATALK_ERROR					ErrorCode,
	IN	PPAP_CONNOBJ				pPapConn,		// Connection (our context)
	IN	PVOID						RespContext,	// CancelResp/PostResp will need this
	IN	PATALK_ADDR					pSrcAddr,		// Address of requestor
	IN	USHORT						PktLen,
	IN	PBYTE						pPkt,
	IN	PBYTE						pUserBytes);

LOCAL VOID
atalkPapIncomingOpenReply(
	IN	ATALK_ERROR					ErrorCode,
	IN	PPAP_CONNOBJ				pPapConn,		// Our context
	IN	PAMDL						pReqAmdl,
	IN	PAMDL						pReadAmdl,
	IN	USHORT						ReadLen,
	IN	PBYTE						ReadUserBytes);

LOCAL VOID FASTCALL
atalkPapIncomingRel(
	IN	ATALK_ERROR					ErrorCode,
	IN	PPAP_OPEN_REPLY_REL			pOpenReply);

LOCAL VOID FASTCALL
atalkPapStatusRel(
	IN	ATALK_ERROR					ErrorCode,
	IN	PPAP_SEND_STATUS_REL		pSendSts);

LOCAL ATALK_ERROR FASTCALL
atalkPapPostSendDataResp(
	IN	PPAP_CONNOBJ				pPapConn);

LOCAL BOOLEAN
atalkPapConnAccept(
	IN	PPAP_ADDROBJ				pPapAddr,		// Listener
	IN	PATALK_ADDR					pSrcAddr,		// Address of requestor
	IN	PBYTE						pPkt,
	IN	BYTE						ConnId,
	IN	PATP_RESP					pAtpResp);

LOCAL LONG FASTCALL
atalkPapConnMaintenanceTimer(
	IN	PTIMERLIST					pTimer,
	IN	BOOLEAN						TimerShuttingDown);

LOCAL VOID FASTCALL
atalkPapSendDataRel(
	IN	ATALK_ERROR					ErrorCode,
	IN	PPAP_CONNOBJ				pPapConn);

LOCAL BYTE
atalkPapGetNextConnId(
	IN	PPAP_ADDROBJ				pPapAddr,
	OUT	PATALK_ERROR				pError);

LOCAL	VOID
atalkPapQueueAddrGlobalList(
	IN	PPAP_ADDROBJ	pPapAddr);

LOCAL	VOID
atalkPapConnDeQueueAssocList(
	IN	PPAP_ADDROBJ				pPapAddr,
	IN	PPAP_CONNOBJ				pPapConn);

LOCAL	VOID
atalkPapConnDeQueueConnectList(
	IN	PPAP_ADDROBJ				pPapAddr,
	IN	PPAP_CONNOBJ				pPapConn);

LOCAL	BOOLEAN
atalkPapConnDeQueueListenList(
	IN	PPAP_ADDROBJ				pPapAddr,
	IN	PPAP_CONNOBJ				pPapConn);

LOCAL	VOID
atalkPapConnDeQueueActiveList(
	IN	PPAP_ADDROBJ				pPapAddr,
	IN	PPAP_CONNOBJ				pPapConn);

LOCAL	VOID
atalkPapConnRefByCtxNonInterlock(
	IN	PPAP_ADDROBJ				pPapAddr,
	IN	CONNECTION_CONTEXT			Ctx,
	OUT	PPAP_CONNOBJ	*			pPapConn,
	OUT	PATALK_ERROR				pError);

#endif	// _PAP_


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\atalk\sys\pap.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

	pap.c

Abstract:

	This module implements the PAP protocol.

Author:

	Jameel Hyder (jameelh@microsoft.com)
	Nikhil Kamkolkar (nikhilk@microsoft.com)

Revision History:
	30 Mar 1993		Initial Version

Notes:	Tab stop: 4
--*/

#include <atalk.h>
#pragma hdrstop
#define	FILENUM		PAP

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, AtalkInitPapInitialize)
#pragma alloc_text(PAGE_PAP, AtalkPapCreateAddress)
#pragma alloc_text(PAGE_PAP, AtalkPapCreateConnection)
#pragma	alloc_text(PAGE_PAP, AtalkPapCleanupAddress)
#pragma	alloc_text(PAGE_PAP, AtalkPapCloseAddress)
#pragma	alloc_text(PAGE_PAP, AtalkPapCleanupConnection)
#pragma	alloc_text(PAGE_PAP, AtalkPapCloseConnection)
#pragma	alloc_text(PAGE_PAP, AtalkPapAssociateAddress)
#pragma	alloc_text(PAGE_PAP, AtalkPapDissociateAddress)
#pragma	alloc_text(PAGE_PAP, AtalkPapPostListen)
#pragma	alloc_text(PAGE_PAP, AtalkPapPrimeListener)
#pragma	alloc_text(PAGE_PAP, AtalkPapCancelListen)
#pragma	alloc_text(PAGE_PAP, AtalkPapPostConnect)
#pragma	alloc_text(PAGE_PAP, AtalkPapDisconnect)
#pragma	alloc_text(PAGE_PAP, AtalkPapRead)
#pragma	alloc_text(PAGE_PAP, AtalkPapPrimeRead)
#pragma	alloc_text(PAGE_PAP, AtalkPapWrite)
#pragma	alloc_text(PAGE_PAP, AtalkPapSetStatus)
#pragma	alloc_text(PAGE_PAP, AtalkPapGetStatus)
#pragma	alloc_text(PAGE_PAP, AtalkPapQuery)
#pragma	alloc_text(PAGE_PAP, atalkPapConnRefByPtrNonInterlock)
#pragma	alloc_text(PAGE_PAP, atalkPapConnRefByCtxNonInterlock)
#pragma	alloc_text(PAGE_PAP, atalkPapConnRefNextNc)
#pragma	alloc_text(PAGE_PAP, atalkPapPostSendDataResp)
#pragma	alloc_text(PAGE_PAP, atalkPapIncomingReadComplete)
#pragma	alloc_text(PAGE_PAP, atalkPapPrimedReadComplete)
#pragma	alloc_text(PAGE_PAP, atalkPapIncomingStatus)
#pragma	alloc_text(PAGE_PAP, atalkPapSendDataRel)
#pragma	alloc_text(PAGE_PAP, atalkPapSlsHandler)
#pragma	alloc_text(PAGE_PAP, atalkPapIncomingReq)
#pragma	alloc_text(PAGE_PAP, atalkPapIncomingOpenReply)
#pragma	alloc_text(PAGE_PAP, atalkPapIncomingRel)
#pragma	alloc_text(PAGE_PAP, atalkPapStatusRel)
#pragma	alloc_text(PAGE_PAP, atalkPapConnAccept)
#pragma	alloc_text(PAGE_PAP, atalkPapGetNextConnId)
#pragma	alloc_text(PAGE_PAP, atalkPapQueueAddrGlobalList)
#pragma	alloc_text(PAGE_PAP, atalkPapConnDeQueueAssocList)
#pragma	alloc_text(PAGE_PAP, atalkPapConnDeQueueConnectList)
#pragma	alloc_text(PAGE_PAP, atalkPapConnDeQueueListenList)
#pragma	alloc_text(PAGE_PAP, atalkPapConnDeQueueActiveList)
#endif

//
//	The model for PAP calls in this module is as follows:
//	- For create calls (CreateAddress & CreateSession), a pointer to the created
//	 object is returned. This structure is referenced for creation.
//	- For all other calls, it expects a referenced pointer to the object.
//

VOID
AtalkInitPapInitialize(
	VOID
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	INITIALIZE_SPIN_LOCK(&atalkPapLock);
	AtalkTimerInitialize(&atalkPapCMTTimer,
						 atalkPapConnMaintenanceTimer,
						 PAP_CONNECTION_INTERVAL);
	AtalkTimerScheduleEvent(&atalkPapCMTTimer);
}




ATALK_ERROR
AtalkPapCreateAddress(
	IN	PATALK_DEV_CTX		pDevCtx	OPTIONAL,
	OUT	PPAP_ADDROBJ	*	ppPapAddr
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PPAP_ADDROBJ		pPapAddr = NULL;
	ATALK_ERROR			error;

	do
	{
		// Allocate memory for the Pap address object
		if ((pPapAddr = AtalkAllocZeroedMemory(sizeof(PAP_ADDROBJ))) == NULL)
		{
			error = ATALK_RESR_MEM;
			break;
		}

		// Create an Atp Socket on the port for the Sls/Connection Socket.
		error = AtalkAtpOpenAddress(AtalkDefaultPort,
									0,
									NULL,
									PAP_MAX_DATA_PACKET_SIZE,
									TRUE,					// SEND_USER_BYTES_ALL
									NULL,
									FALSE,		// CACHE address
									&pPapAddr->papao_pAtpAddr);

		if (!ATALK_SUCCESS(error))
		{
			DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_ERR,
					("AtalkPapCreateAddress: AtalkAtpOpenAddress fail %ld\n",error));

			break;
		}

		// Initialize the Pap address object
		pPapAddr->papao_Signature = PAPAO_SIGNATURE;

		INITIALIZE_SPIN_LOCK(&pPapAddr->papao_Lock);

		//	Creation reference
		pPapAddr->papao_RefCount = 1;

	} while (FALSE);

	if (ATALK_SUCCESS(error))
	{
		//	Insert into the global address list.
		atalkPapQueueAddrGlobalList(pPapAddr);
		*ppPapAddr = pPapAddr;
	}
	else if (pPapAddr != NULL)
	{
		AtalkFreeMemory(pPapAddr);
	}

	return error;
}




ATALK_ERROR
AtalkPapCleanupAddress(
	IN	PPAP_ADDROBJ			pPapAddr
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PPAP_CONNOBJ	pPapConn, pPapConnNext;
	KIRQL			OldIrql;
	ATALK_ERROR		error;

	DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_INFO,
			("AtalkPapCleanupAddress: %lx\n", pPapAddr));

	ACQUIRE_SPIN_LOCK(&pPapAddr->papao_Lock, &OldIrql);

#if DBG
	pPapAddr->papao_Flags	|= PAPAO_CLEANUP;
#endif

	if ((pPapConn = pPapAddr->papao_pAssocConn) != NULL)
	{
		atalkPapConnRefNextNc(pPapConn, &pPapConnNext, &error);
		if (ATALK_SUCCESS(error))
		{
			while (TRUE)
			{
				if ((pPapConn = pPapConnNext) == NULL)
				{
					break;
				}

				if ((pPapConnNext = pPapConn->papco_pNextAssoc) != NULL)
				{
					atalkPapConnRefNextNc(pPapConnNext, &pPapConnNext, &error);
					if (!ATALK_SUCCESS(error))
					{
						pPapConnNext = NULL;
					}
				}

				//	Shutdown this connection
				RELEASE_SPIN_LOCK(&pPapAddr->papao_Lock, OldIrql);

				DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_INFO,
						("AtalkPapCloseAddress: Stopping conn %lx\n", pPapConn));

				AtalkPapCleanupConnection(pPapConn);

				AtalkPapConnDereference(pPapConn);
				ACQUIRE_SPIN_LOCK(&pPapAddr->papao_Lock, &OldIrql);
			}
		}
	}
	RELEASE_SPIN_LOCK(&pPapAddr->papao_Lock, OldIrql);

	return ATALK_NO_ERROR;
}




ATALK_ERROR
AtalkPapCloseAddress(
	IN	PPAP_ADDROBJ			pPapAddr,
	IN	GENERIC_COMPLETION		CompletionRoutine,
	IN	PVOID					pCloseCtx
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	KIRQL	OldIrql;
	PPAP_CONNOBJ	pPapConn, pPapConnNext;
    DWORD   dwAssocRefCounts=0;


	DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_INFO,
			("AtalkPapCloseAddress: %lx\n", pPapAddr));

	ACQUIRE_SPIN_LOCK(&pPapAddr->papao_Lock, &OldIrql);
	if (pPapAddr->papao_Flags & PAPAO_CLOSING)
	{
		//	We are already closing! This should never happen!
		ASSERT(0);
	}
	pPapAddr->papao_Flags |= PAPAO_CLOSING;

	//	Set the completion info.
	pPapAddr->papao_CloseComp  = CompletionRoutine;
	pPapAddr->papao_CloseCtx   = pCloseCtx;


	// Implicitly dissociate any connection objects
	for (pPapConn = pPapAddr->papao_pAssocConn;
		 pPapConn != NULL;
		 pPapConn = pPapConnNext)
	{
		ACQUIRE_SPIN_LOCK_DPC(&pPapConn->papco_Lock);
		pPapConnNext = pPapConn->papco_pNextAssoc;

		//	when the conn was associate, we put a refcount: remove it
        if (pPapConn->papco_Flags & PAPCO_ADDR_ACTIVE)
        {
		    pPapConn->papco_Flags &= ~PAPCO_ADDR_ACTIVE;
            dwAssocRefCounts++;
        }

		RELEASE_SPIN_LOCK_DPC(&pPapConn->papco_Lock);
	}

	ASSERT(pPapAddr->papao_CloseComp != NULL);
	ASSERT(pPapAddr->papao_CloseCtx  != NULL);

    // ok to subtract: at least Creation refcount is still around
    pPapAddr->papao_RefCount -= dwAssocRefCounts;

	RELEASE_SPIN_LOCK(&pPapAddr->papao_Lock, OldIrql);

	//	Close the ATP Address Object.
	if (pPapAddr->papao_pAtpAddr != NULL)
		AtalkAtpCloseAddress(pPapAddr->papao_pAtpAddr, NULL, NULL);
    pPapAddr->papao_pAtpAddr = NULL;

	//	Remove the creation reference count
	AtalkPapAddrDereference(pPapAddr);
	return ATALK_PENDING;
}




ATALK_ERROR
AtalkPapCreateConnection(
	IN	PVOID					pConnCtx,	// Context to associate with the session
	IN	PATALK_DEV_CTX			pDevCtx		OPTIONAL,
	OUT	PPAP_CONNOBJ 	*		ppPapConn
	)
/*++

Routine Description:

 	Create an PAP session. The created session starts off being an orphan, i.e.
 	it has no parent address object. It gets one when it is associated.

Arguments:


Return Value:


--*/
{
	PPAP_CONNOBJ	pPapConn;
	KIRQL			OldIrql;

	// Allocate memory for a connection object
	if ((pPapConn = AtalkAllocZeroedMemory(sizeof(PAP_CONNOBJ))) == NULL)
	{
		return ATALK_RESR_MEM;
	}

	pPapConn->papco_Signature = PAPCO_SIGNATURE;

	INITIALIZE_SPIN_LOCK(&pPapConn->papco_Lock);
	pPapConn->papco_ConnCtx 	= pConnCtx;
	pPapConn->papco_Flags 		= 0;
	pPapConn->papco_RefCount 	= 1;					// Creation reference
	pPapConn->papco_NextOutgoingSeqNum = 1;				// Set to 1, not 0.
	pPapConn->papco_NextIncomingSeqNum = 1;				// Next expected incoming.
	AtalkInitializeRT(&pPapConn->papco_RT,
					  PAP_INIT_SENDDATA_REQ_INTERVAL,
                      PAP_MIN_SENDDATA_REQ_INTERVAL,
                      PAP_MAX_SENDDATA_REQ_INTERVAL);

	*ppPapConn = pPapConn;

	//	Insert into the global connection list.
	ACQUIRE_SPIN_LOCK(&atalkPapLock, &OldIrql);
	AtalkLinkDoubleAtHead(atalkPapConnList, pPapConn, papco_Next, papco_Prev);
	RELEASE_SPIN_LOCK(&atalkPapLock, OldIrql);

	DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_INFO,
				("AtalkPapCreateConnection: %lx\n", pPapConn));

	return ATALK_NO_ERROR;
}




ATALK_ERROR
AtalkPapCleanupConnection(
	IN	PPAP_CONNOBJ			pPapConn
	)
/*++

Routine Description:

 	Shutdown a session.

Arguments:


Return Value:


--*/
{
	BOOLEAN		stopping 	= FALSE;
	BOOLEAN		pendingRead = FALSE;
    BOOLEAN     fWaitingRead = FALSE;
	KIRQL		OldIrql;
	ATALK_ERROR	error 		= ATALK_NO_ERROR;

	ASSERT(VALID_PAPCO(pPapConn));

	DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_INFO,
			("AtalkPapCleanupConnection: %lx\n", pPapConn));

	ACQUIRE_SPIN_LOCK(&pPapConn->papco_Lock, &OldIrql);

	pPapConn->papco_Flags |= PAPCO_LOCAL_DISCONNECT;

#if DBG
	pPapConn->papco_Flags |= PAPCO_CLEANUP;
#endif

	if ((pPapConn->papco_Flags & PAPCO_STOPPING) == 0)
	{
		//	Allows completion of cleanup irp in Deref.
		pPapConn->papco_Flags |= PAPCO_STOPPING;

		//	If already effectively stopped, just return.
		if (pPapConn->papco_Flags & PAPCO_ASSOCIATED)
		{
			pendingRead = (pPapConn->papco_Flags & PAPCO_READDATA_PENDING) ? TRUE : FALSE;
			if (pPapConn->papco_Flags & PAPCO_READDATA_WAITING)
            {
                fWaitingRead = TRUE;
                pPapConn->papco_Flags &= ~PAPCO_READDATA_WAITING;
            }

			ASSERTMSG("PapCleanup: Called with read data unread\n", !pendingRead);

			stopping = TRUE;

		}
		else
		{
			DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_INFO,
					("AtalkPapCleanupConnection: Called for a stopped conn %lx.%lx\n",
					pPapConn, pPapConn->papco_Flags));
		}

	}
	RELEASE_SPIN_LOCK(&pPapConn->papco_Lock, OldIrql);

	//	Close the ATP Address Object if this was a server connection and
	//	opened its own socket.
	if (stopping)
	{
		//	If there is a pending read, then we need to cancel that atp request.
		if ((pendingRead || fWaitingRead) && (pPapConn->papco_pAtpAddr != NULL))
		{
			AtalkAtpCancelReq(pPapConn->papco_pAtpAddr,
							  pPapConn->papco_ReadDataTid,
							  &pPapConn->papco_RemoteAddr);
		}

		//	If we are already disconnecting this will return an error which
		//	we ignore. But if we were only in the ASSOCIATED state, then we
		//	need to call disassociate here.
		error = AtalkPapDisconnect(pPapConn,
								   ATALK_LOCAL_DISCONNECT,
								   NULL,
								   NULL);

		//	We were already disconnected.
		if (error == ATALK_INVALID_REQUEST)
		{
			AtalkPapDissociateAddress(pPapConn);
		}
	}

	return ATALK_NO_ERROR;
}




ATALK_ERROR
AtalkPapCloseConnection(
	IN	PPAP_CONNOBJ			pPapConn,
	IN	GENERIC_COMPLETION		CompletionRoutine,
	IN	PVOID					pCloseCtx
	)
/*++

Routine Description:

 	Shutdown a session.

Arguments:


Return Value:


--*/
{
	KIRQL	OldIrql;

	ASSERT(VALID_PAPCO(pPapConn));

	DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_INFO,
			("AtalkPapCloseConnection: %lx\n", pPapConn));

	ACQUIRE_SPIN_LOCK(&pPapConn->papco_Lock, &OldIrql);
	if (pPapConn->papco_Flags & PAPCO_CLOSING)
	{
		//	We are already closing! This should never happen!
		KeBugCheck(0);
	}
	pPapConn->papco_Flags |= PAPCO_CLOSING;

	//	Set the completion info.
	pPapConn->papco_CloseComp	= CompletionRoutine;
	pPapConn->papco_CloseCtx	= pCloseCtx;
	RELEASE_SPIN_LOCK(&pPapConn->papco_Lock, OldIrql);

	//	Remove the creation reference count
	AtalkPapConnDereference(pPapConn);

	return ATALK_PENDING;
}




ATALK_ERROR
AtalkPapAssociateAddress(
	IN	PPAP_ADDROBJ			pPapAddr,
	IN	PPAP_CONNOBJ			pPapConn
	)
/*++

Routine Description:

	Removed reference for the address for this connection. Causes deadlock in AFD where
	AFD blocks on close of the address object and we wait for connections to be closed
	first

Arguments:


Return Value:


--*/
{
	ATALK_ERROR		error;
	KIRQL			OldIrql;

	ASSERT(VALID_PAPAO(pPapAddr));
	ASSERT(VALID_PAPCO(pPapConn));

	ACQUIRE_SPIN_LOCK(&pPapAddr->papao_Lock, &OldIrql);
	ACQUIRE_SPIN_LOCK_DPC(&pPapConn->papco_Lock);

	error = ATALK_ALREADY_ASSOCIATED;
	if ((pPapConn->papco_Flags & PAPCO_ASSOCIATED) == 0)
	{
		error = ATALK_NO_ERROR;

		//	Link it in.
		pPapConn->papco_pNextAssoc 	= pPapAddr->papao_pAssocConn;
		pPapAddr->papao_pAssocConn	= pPapConn;

		//	Remove not associated flag.
		pPapConn->papco_Flags 	   |= PAPCO_ASSOCIATED;
		pPapConn->papco_pAssocAddr	= pPapAddr;

        // put Association refcount
        pPapAddr->papao_RefCount++;

        // mark that fact that we now have a refcount on addr obj for this conn
        pPapConn->papco_Flags |= PAPCO_ADDR_ACTIVE;
	}

	RELEASE_SPIN_LOCK_DPC(&pPapConn->papco_Lock);
	RELEASE_SPIN_LOCK(&pPapAddr->papao_Lock, OldIrql);

	return error;
}




ATALK_ERROR
AtalkPapDissociateAddress(
	IN	PPAP_CONNOBJ			pPapConn
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PPAP_ADDROBJ	pPapAddr;
	KIRQL			OldIrql;
	ATALK_ERROR		error = ATALK_NO_ERROR;
    BOOLEAN         fDerefAddr = FALSE;

	ASSERT(VALID_PAPCO(pPapConn));

	ACQUIRE_SPIN_LOCK(&pPapConn->papco_Lock, &OldIrql);
	if ((pPapConn->papco_Flags & (PAPCO_LISTENING 	|
								  PAPCO_CONNECTING	|
								  PAPCO_ACTIVE 		|
								  PAPCO_ASSOCIATED)) != PAPCO_ASSOCIATED)
	{
		error = ATALK_INVALID_CONNECTION;
	}
	else
	{
		pPapAddr = pPapConn->papco_pAssocAddr ;
		ASSERT(VALID_PAPAO(pPapAddr));

		//	Set not associated flag.
		pPapConn->papco_Flags 	   &= ~PAPCO_ASSOCIATED;
		pPapConn->papco_pAssocAddr	= NULL;

        if (pPapConn->papco_Flags & PAPCO_ADDR_ACTIVE)
        {
            pPapConn->papco_Flags &= ~PAPCO_ADDR_ACTIVE;
            fDerefAddr = TRUE;
        }
	}
	RELEASE_SPIN_LOCK(&pPapConn->papco_Lock, OldIrql);

	//	  Unlink it if ok.
	if (ATALK_SUCCESS(error))
	{
		ACQUIRE_SPIN_LOCK(&pPapAddr->papao_Lock, &OldIrql);
		ACQUIRE_SPIN_LOCK_DPC(&pPapConn->papco_Lock);
		atalkPapConnDeQueueAssocList(pPapAddr, pPapConn);
		RELEASE_SPIN_LOCK_DPC(&pPapConn->papco_Lock);
		RELEASE_SPIN_LOCK(&pPapAddr->papao_Lock, OldIrql);

        if (fDerefAddr)
        {
            // remove the Association refcount
		    AtalkPapAddrDereference(pPapAddr);
        }

	}

	return error;
}




ATALK_ERROR
AtalkPapPostListen(
	IN	PPAP_CONNOBJ			pPapConn,
	IN	PVOID					pListenCtx,
	IN	GENERIC_COMPLETION		CompletionRoutine
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PPAP_ADDROBJ	pPapAddr = pPapConn->papco_pAssocAddr;
	KIRQL			OldIrql;
	ATALK_ERROR		error;

	//	This will also insert the connection object in the address objects
	//	list of connection which have a listen posted on them. When open
	//	connection requests come in, the first connection is taken off the list
	//	and the request satisfied.

	ASSERT(VALID_PAPCO(pPapConn));
	ASSERT(VALID_PAPAO(pPapAddr));

	ACQUIRE_SPIN_LOCK(&pPapAddr->papao_Lock, &OldIrql);
	ACQUIRE_SPIN_LOCK_DPC(&pPapConn->papco_Lock);
	do
	{
		if ((pPapConn->papco_Flags & (PAPCO_LISTENING 	|
									  PAPCO_CONNECTING	|
									  PAPCO_ACTIVE 		|
									  PAPCO_ASSOCIATED)) != PAPCO_ASSOCIATED)
		{
			error = ATALK_INVALID_CONNECTION;
			break;
		}

		//	Verify the address object is not a connect address type.
		if (pPapAddr->papao_Flags & PAPAO_CONNECT)
		{
			error = ATALK_INVALID_PARAMETER;
			break;
		}

		//	Make the address object a listener.
		pPapAddr->papao_Flags		 	   |= PAPAO_LISTENER;

		pPapConn->papco_Flags 			   |= PAPCO_LISTENING;
		pPapConn->papco_ListenCtx 			= pListenCtx;
		pPapConn->papco_ListenCompletion 	= CompletionRoutine;

		//	Insert into the listen list.
		pPapConn->papco_pNextListen			= pPapAddr->papao_pListenConn;
		pPapAddr->papao_pListenConn			= pPapConn;

		//	Unblock the address object.
		pPapAddr->papao_Flags			   |= PAPAO_UNBLOCKED;
		error = ATALK_NO_ERROR;

	} while (FALSE);

	RELEASE_SPIN_LOCK_DPC(&pPapConn->papco_Lock);
	RELEASE_SPIN_LOCK(&pPapAddr->papao_Lock, OldIrql);

	if (ATALK_SUCCESS(error))
	{
		//	Now enqueue a few handlers on the address object. These will handle
		//	open conn/get status etc.
		//
		//	DOC: For our implementation, until a server associates and places a
		//		 listen on one of the connection objects, we do not become a
		//		 listener. So the fact that we will not handle any request
		//		 until that point is ok. Note that for a connect, the requests
		//		 get posted on the connections atp address, which will be the same
		//		 as the address's atp address.
		if (!ATALK_SUCCESS(error = AtalkPapPrimeListener(pPapAddr)))
		{
			//	Undo insert into the listen list.
			ACQUIRE_SPIN_LOCK(&pPapAddr->papao_Lock, &OldIrql);
			ACQUIRE_SPIN_LOCK_DPC(&pPapConn->papco_Lock);
			atalkPapConnDeQueueListenList(pPapAddr, pPapConn);
			RELEASE_SPIN_LOCK_DPC(&pPapConn->papco_Lock);
			RELEASE_SPIN_LOCK(&pPapAddr->papao_Lock, OldIrql);
		}
	}

	return error;
}




ATALK_ERROR
AtalkPapPrimeListener(
	IN	PPAP_ADDROBJ			pPapAddr
	)
/*++

Routine Description:

 	Enqueue a handler on the listener.

Arguments:


Return Value:


--*/
{
	ATALK_ERROR	error = ATALK_NO_ERROR;
	KIRQL		OldIrql;
	BOOLEAN		Unlock = TRUE;

	ACQUIRE_SPIN_LOCK(&pPapAddr->papao_Lock, &OldIrql);

	if ((pPapAddr->papao_Flags & PAPAO_SLS_QUEUED) == 0)
	{
		//	Reference the address object for this handler we will be enqueuing.
		AtalkPapAddrReferenceNonInterlock(pPapAddr, &error);
		if (ATALK_SUCCESS(error))
		{
			pPapAddr->papao_Flags |= PAPAO_SLS_QUEUED;
			RELEASE_SPIN_LOCK(&pPapAddr->papao_Lock, OldIrql);
            Unlock = FALSE;
	
			AtalkAtpSetReqHandler(pPapAddr->papao_pAtpAddr,
								  atalkPapSlsHandler,
								  pPapAddr);
		}
	}
	if (Unlock)
	{
		RELEASE_SPIN_LOCK(&pPapAddr->papao_Lock, OldIrql);
	}

	return error;
}




ATALK_ERROR
AtalkPapCancelListen(
	IN	PPAP_CONNOBJ			pPapConn
	)
/*++

Routine Description:

  	Cancel a previously posted listen.

Arguments:


Return Value:


--*/
{
	PPAP_ADDROBJ		pPapAddr 	= pPapConn->papco_pAssocAddr;
	ATALK_ERROR			error 	 	= ATALK_NO_ERROR;
	GENERIC_COMPLETION	completionRoutine = NULL;
	KIRQL				OldIrql;
	PVOID			  	completionCtx = NULL;

	ASSERT(VALID_PAPCO(pPapConn));
	ASSERT(VALID_PAPAO(pPapAddr));
	ACQUIRE_SPIN_LOCK(&pPapAddr->papao_Lock, &OldIrql);
	if (!atalkPapConnDeQueueListenList(pPapAddr, pPapConn))
	{
		error = ATALK_INVALID_CONNECTION;
	}
	else
	{
		//	We complete the listen routine
		ASSERT(pPapConn->papco_Flags & PAPCO_LISTENING);
		pPapConn->papco_Flags  &= ~PAPCO_LISTENING;
		completionRoutine 		= pPapConn->papco_ListenCompletion;
		completionCtx			= pPapConn->papco_ListenCtx;
	}
	RELEASE_SPIN_LOCK(&pPapAddr->papao_Lock, OldIrql);

	if (*completionRoutine != NULL)
	{
		(*completionRoutine)(ATALK_REQUEST_CANCELLED, completionCtx);
	}

	return error;
}




ATALK_ERROR
AtalkPapPostConnect(
	IN	PPAP_CONNOBJ			pPapConn,
	IN	PATALK_ADDR				pRemoteAddr,
	IN	PVOID					pConnectCtx,
	IN	GENERIC_COMPLETION		CompletionRoutine
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	BOOLEAN			DerefConn = FALSE;
	KIRQL			OldIrql;
	ATALK_ERROR		error	= ATALK_NO_ERROR;
	PBYTE			pOpenPkt = NULL, pRespPkt = NULL;
	PAMDL			pOpenAmdl = NULL, pRespAmdl = NULL;
	PPAP_ADDROBJ	pPapAddr = pPapConn->papco_pAssocAddr;

	ASSERT(VALID_PAPAO(pPapAddr));
	ASSERT(VALID_PAPCO(pPapConn));

	//	Allocate a buffer to use.
	if (((pOpenPkt = AtalkAllocMemory(PAP_STATUS_OFF)) == NULL)				||
		((pOpenAmdl = AtalkAllocAMdl(pOpenPkt, PAP_STATUS_OFF)) == NULL)	||
		((pRespPkt = AtalkAllocMemory(PAP_MAX_DATA_PACKET_SIZE)) == NULL)	||
		((pRespAmdl = AtalkAllocAMdl(pRespPkt, PAP_MAX_DATA_PACKET_SIZE)) == NULL))

	{
		if (pOpenPkt != NULL)
			AtalkFreeMemory(pOpenPkt);
		if (pOpenAmdl != NULL)
			AtalkFreeAMdl(pOpenAmdl);
		if (pRespPkt != NULL)
			AtalkFreeMemory(pRespPkt);

		return ATALK_RESR_MEM;
	}

	ACQUIRE_SPIN_LOCK(&pPapAddr->papao_Lock, &OldIrql);
	ACQUIRE_SPIN_LOCK_DPC(&pPapConn->papco_Lock);
	do
	{
		if ((pPapConn->papco_Flags & (PAPCO_LISTENING 	|
									  PAPCO_CONNECTING	|
									  PAPCO_ACTIVE 		|
									  PAPCO_ASSOCIATED)) != PAPCO_ASSOCIATED)
		{
			error = ATALK_INVALID_CONNECTION;
			break;
		}

		//	Verify the address object is not a listener address type.
		if (pPapAddr->papao_Flags & PAPAO_LISTENER)
		{
			error = ATALK_INVALID_ADDRESS;
			break;
		}

		//	Reference the connection for the request we will be posting
		AtalkPapConnReferenceByPtrNonInterlock(pPapConn, &error);
		if (!ATALK_SUCCESS(error))
		{
			ASSERTMSG("AtalkPapPostConnect: Connection ref failed\n", 0);
			break;
		}

		DerefConn = TRUE;

		pPapConn->papco_ConnId	= atalkPapGetNextConnId(pPapAddr, &error);
		if (ATALK_SUCCESS(error))
		{
			//	Make sure flags are clean.
			pPapConn->papco_Flags			   &= ~(PAPCO_SENDDATA_RECD		|
													PAPCO_WRITEDATA_WAITING	|
													PAPCO_SEND_EOF_WRITE   	|
													PAPCO_READDATA_PENDING 	|
													PAPCO_REMOTE_CLOSE	 	|
													PAPCO_NONBLOCKING_READ 	|
													PAPCO_READDATA_WAITING);

			pPapConn->papco_Flags 			   |= PAPCO_CONNECTING;
			pPapConn->papco_ConnectCtx 			= pConnectCtx;
			pPapConn->papco_ConnectCompletion 	= CompletionRoutine;
			pPapConn->papco_pConnectRespBuf		= pRespPkt;
			pPapConn->papco_pConnectOpenBuf		= pOpenPkt;
			pPapConn->papco_ConnectRespLen		= PAP_MAX_DATA_PACKET_SIZE;
			pPapConn->papco_RemoteAddr			= *pRemoteAddr;
			pPapConn->papco_WaitTimeOut			= 0;	// To begin with

			//	For CONNECT, the connection object inherits the associated
			//	address objects atp address.
			pPapConn->papco_pAtpAddr			= pPapAddr->papao_pAtpAddr;

			//	Insert into the connect list.
			pPapConn->papco_pNextConnect		= pPapAddr->papao_pConnectConn;
			pPapAddr->papao_pConnectConn		= pPapConn;
			pPapAddr->papao_Flags 			   |= PAPAO_CONNECT;
		}
		else
		{
			ASSERTMSG("AtalkPapPostConnect: Unable to get conn id > 255 sess?\n", 0);
		}
	} while (FALSE);

	RELEASE_SPIN_LOCK_DPC(&pPapConn->papco_Lock);
	RELEASE_SPIN_LOCK(&pPapAddr->papao_Lock, OldIrql);

	if (ATALK_SUCCESS(error))
	{
		error = atalkPapRepostConnect(pPapConn, pOpenAmdl, pRespAmdl);

		if (ATALK_SUCCESS(error))
		{
			error = ATALK_PENDING;
			DerefConn = FALSE;
		}
		else
		{
			DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_ERR,
					("AtalkPapConnect: AtalkAtpPostReq: failed %ld\n", error));

			//	Remove connection from the connect list and reset states.
			ACQUIRE_SPIN_LOCK(&pPapAddr->papao_Lock, &OldIrql);
			ACQUIRE_SPIN_LOCK_DPC(&pPapConn->papco_Lock);

			pPapConn->papco_Flags 			   &= ~PAPCO_CONNECTING;
			pPapConn->papco_ConnectCtx 			= NULL;
			pPapConn->papco_ConnectCompletion 	= NULL;
			pPapConn->papco_pConnectRespBuf		= NULL;
			pPapConn->papco_ConnectRespLen		= 0;
			pPapConn->papco_pAtpAddr			= NULL;

			//	Remove from the connect list.
			atalkPapConnDeQueueConnectList(pPapAddr, pPapConn);
			RELEASE_SPIN_LOCK_DPC(&pPapConn->papco_Lock);
			RELEASE_SPIN_LOCK(&pPapAddr->papao_Lock, OldIrql);
		}
	}

	if (!ATALK_SUCCESS(error))
	{
		DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_ERR,
				("AtalkPapConnect: failed %ld\n", error));

		//	Free all buffers.
		ASSERT(pOpenPkt != NULL);
		AtalkFreeMemory(pOpenPkt);

		ASSERT(pOpenAmdl != NULL);
		AtalkFreeAMdl(pOpenAmdl);

		ASSERT(pRespPkt != NULL);
		AtalkFreeMemory(pRespPkt);

		ASSERT(pRespAmdl != NULL);
		AtalkFreeAMdl(pRespAmdl);
	}

	if (DerefConn)
	{
		AtalkPapConnDereference(pPapConn);
	}

	return error;
}




ATALK_ERROR
AtalkPapDisconnect(
	IN	PPAP_CONNOBJ			pPapConn,
	IN	ATALK_DISCONNECT_TYPE	DisconnectType,
	IN	PVOID					pDisconnectCtx,
	IN	GENERIC_COMPLETION		CompletionRoutine
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	ATALK_ERROR					tmpError;
	PACTREQ						pActReq;
	PAMDL						writeBuf;
	PVOID						writeCtx;
	GENERIC_WRITE_COMPLETION	writeCompletion	= NULL;
	ATALK_ERROR					error 			= ATALK_PENDING;
	KIRQL						OldIrql;
	BOOLEAN						cancelPrimedRead = FALSE;

	ASSERT(VALID_PAPCO(pPapConn));

	DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_INFO,
			("AtalkPapDisconnect: %lx.%lx\n", pPapConn, DisconnectType));

	ACQUIRE_SPIN_LOCK(&pPapConn->papco_Lock, &OldIrql);

    // is it already disconnecting?
    if (pPapConn->papco_Flags & PAPCO_DISCONNECTING)
    {
		RELEASE_SPIN_LOCK(&pPapConn->papco_Lock, OldIrql);
        return(ATALK_PAP_CONN_CLOSING);
    }

	//	When a disconnect comes in, we abort any sends waiting for a remote
	//	send data to come in.
	if ((pPapConn->papco_Flags & (PAPCO_WRITEDATA_WAITING|PAPCO_SENDDATA_RECD)) ==
															PAPCO_WRITEDATA_WAITING)
	{
		//	In this situation, what happened is that a write was posted
		//	before a send data was received. As PapPostSendData response
		//	was never called in that case, there will be no pending reference
		//	on the connection.
		writeCompletion = pPapConn->papco_WriteCompletion;
		writeCtx		= pPapConn->papco_WriteCtx;
		writeBuf		= pPapConn->papco_pWriteBuf;

		pPapConn->papco_Flags	&= ~PAPCO_WRITEDATA_WAITING;
		pPapConn->papco_WriteCtx = NULL;
		pPapConn->papco_pWriteBuf= NULL;
		pPapConn->papco_WriteCompletion	= NULL;
	}

	// Handle the case where a send data was received, but no data is to be sent
	// just cancel the response.
	if (pPapConn->papco_Flags & PAPCO_SENDDATA_RECD)
	{
		PATP_RESP	pAtpResp = pPapConn->papco_pAtpResp;

		ASSERT(VALID_ATPRS(pAtpResp));

		pPapConn->papco_Flags &= ~PAPCO_SENDDATA_RECD;

		RELEASE_SPIN_LOCK(&pPapConn->papco_Lock, OldIrql);

		AtalkAtpCancelResp(pAtpResp);

		ACQUIRE_SPIN_LOCK(&pPapConn->papco_Lock, &OldIrql);
	}

	//	Handle the race condition between disconnect and last recv. indication.
	//	The fact that we have received a disconnect from the other side implies
	//	that we have sent out a release which in turn implies that we have all
	//	the data. If this is the case, then we defer disconnect till the recv.
	//	indication is done. Otherwise AFD gets real upset.
	if ((DisconnectType == ATALK_REMOTE_DISCONNECT) &&
		(pPapConn->papco_Flags & PAPCO_NONBLOCKING_READ))
	{
		if (AtalkAtpIsReqComplete(pPapConn->papco_pAtpAddr,
								  pPapConn->papco_ReadDataTid,
								  &pPapConn->papco_RemoteAddr))
		{
			pPapConn->papco_Flags |= PAPCO_DELAYED_DISCONNECT;
		}
	}

	//	Support for graceful disconnect. We only drop the received
	//	data when the local end does a disconnect. This will happen
	//	regardless of whether this routine was previously called or
	//	not. Also, this means that we must satisfy a read if disconnect is pending.
	if ((DisconnectType == ATALK_LOCAL_DISCONNECT) ||
		(DisconnectType == ATALK_TIMER_DISCONNECT))
	{
        pPapConn->papco_Flags |= PAPCO_REJECT_READS;

		if (pPapConn->papco_Flags & PAPCO_READDATA_WAITING)
		{
			ASSERT(pPapConn->papco_Flags & PAPCO_NONBLOCKING_READ);

			pActReq		= pPapConn->papco_NbReadActReq;

			//	Reset the flags
			pPapConn->papco_Flags &= ~(PAPCO_NONBLOCKING_READ | PAPCO_READDATA_WAITING);

			RELEASE_SPIN_LOCK(&pPapConn->papco_Lock, OldIrql);

			//	Call the action completion routine for the prime read.
			(*pActReq->ar_Completion)(ATALK_LOCAL_CLOSE, pActReq);

			ACQUIRE_SPIN_LOCK(&pPapConn->papco_Lock, &OldIrql);
		}
	}

	if ((pPapConn->papco_Flags & (PAPCO_DISCONNECTING | PAPCO_DELAYED_DISCONNECT)) == 0)
	{
		if (pPapConn->papco_Flags & (PAPCO_LISTENING	|
									 PAPCO_CONNECTING   |
									 PAPCO_ACTIVE))
		{
			pPapConn->papco_Flags |= PAPCO_DISCONNECTING;
			if (pPapConn->papco_Flags & PAPCO_LISTENING)
			{
				RELEASE_SPIN_LOCK(&pPapConn->papco_Lock, OldIrql);
				AtalkPapCancelListen(pPapConn);
				ACQUIRE_SPIN_LOCK(&pPapConn->papco_Lock, &OldIrql);
			}
			else if (pPapConn->papco_Flags & PAPCO_CONNECTING)
			{
				RELEASE_SPIN_LOCK(&pPapConn->papco_Lock, OldIrql);
				tmpError = AtalkAtpCancelReq(pPapConn->papco_pAtpAddr,
											 pPapConn->papco_ConnectTid,
											 &pPapConn->papco_RemoteAddr);

				//	We just stop the address. If success, it'll be dequeued from the
				//	connect list. If !success, its gone active. In either
				//	case we do not need to cleanup the ATP address. It could
				//	possibly be set to NULL by now as disconnect would have
				//	completed.
				if (ATALK_SUCCESS(tmpError))
				{
					DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_INFO,
							("atalkPapDisconnect: Stopping atp address for %lx\n", pPapConn));

					//	AtalkAtpCleanupAddress(pPapConn->papco_pAtpAddr);
				}
				ACQUIRE_SPIN_LOCK(&pPapConn->papco_Lock, &OldIrql);
			}

			//	Both of the above could have failed as the connection
			//	might have become active before the cancel succeeded.
			//	In that case (or if we were active to begin with), do
			//	a disconnect here.
			if (pPapConn->papco_Flags & PAPCO_ACTIVE)
			{
				//	Remember completion routines as appropriate.
				if (DisconnectType == ATALK_INDICATE_DISCONNECT)
				{
					if (pPapConn->papco_DisconnectInform == NULL)
					{
						pPapConn->papco_DisconnectInform = CompletionRoutine;
						pPapConn->papco_DisconnectInformCtx = pDisconnectCtx;
					}
					else
					{
						DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_ERR,
								("AtalkPapDisconnect: duplicate disc comp rou%lx\n", pPapConn));

						error = ATALK_TOO_MANY_COMMANDS;
					}
				}
				else if (DisconnectType == ATALK_LOCAL_DISCONNECT)
				{
					//	Replace completion routines only if previous ones are NULL.
					if (pPapConn->papco_DisconnectCompletion == NULL)
					{
						pPapConn->papco_DisconnectCompletion = CompletionRoutine;
						pPapConn->papco_DisconnectCtx		 = pDisconnectCtx;
					}
					else
					{
						DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_ERR,
								("AtalkPapDisconnect: duplicate disc comp rou%lx\n", pPapConn));
						error = ATALK_TOO_MANY_COMMANDS;
					}
				}

				//	Figure out the disconnect status and remember it in the
				//	connection object.
				pPapConn->papco_DisconnectStatus = DISCONN_STATUS(DisconnectType);

				if ((pPapConn->papco_Flags & (PAPCO_NONBLOCKING_READ|PAPCO_READDATA_WAITING)) ==
																	PAPCO_NONBLOCKING_READ)
				{
					pPapConn->papco_Flags &= ~PAPCO_NONBLOCKING_READ;
					cancelPrimedRead = TRUE;
				}

				RELEASE_SPIN_LOCK(&pPapConn->papco_Lock, OldIrql);

				//	If there is a pending write, then we need to complete the write.
				if (writeCompletion != NULL)
				{
					DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_ERR,
							("AtalkPapDisconect: Completing write %lx.%lx\n",
							pPapConn, pPapConn->papco_DisconnectStatus));

					(*writeCompletion)(pPapConn->papco_DisconnectStatus,
									   writeBuf,
									   0,							// Write length
									   writeCtx);
    				}

				if (cancelPrimedRead)
				{
					AtalkAtpCancelReq(pPapConn->papco_pAtpAddr,
									  pPapConn->papco_ReadDataTid,
									  &pPapConn->papco_RemoteAddr);
				}

				//	Cancel the tickle request
				AtalkAtpCancelReq(pPapConn->papco_pAtpAddr,
								  pPapConn->papco_TickleTid,
								  &pPapConn->papco_RemoteAddr);

				//	Send out disconnect packet if this was a timer or local close.
				if ((DisconnectType == ATALK_LOCAL_DISCONNECT) ||
					(DisconnectType == ATALK_TIMER_DISCONNECT))
				{
					BYTE		userBytes[ATP_USERBYTES_SIZE];
					USHORT		tid;

					userBytes[PAP_CONNECTIONID_OFF]	= pPapConn->papco_ConnId;
					userBytes[PAP_CMDTYPE_OFF]		= PAP_CLOSE_CONN;
					PUTSHORT2SHORT(&userBytes[PAP_SEQNUM_OFF], 0);

					DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_INFO,
							("AtalkPapDisconect: Sending disc to %lx - %lx\n",
							pPapConn->papco_RemoteAddr.ata_Address,
							DisconnectType));

					tmpError = AtalkAtpPostReq(pPapConn->papco_pAtpAddr,
											   &pPapConn->papco_RemoteAddr,
											   &tid,
											   0,						// ALO request
											   NULL,
											   0,
											   userBytes,
											   NULL,
											   0,
											   0,						// Retry count
											   0,						// Retry interval
											   THIRTY_SEC_TIMER,
											   NULL,
											   NULL);

					if (!ATALK_SUCCESS(tmpError))
					{
						DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_ERR,
								("AtalkPapDisconnect: post disc to rem fail%lx\n", pPapConn));
					}
				}

				//	Call the disconnect indication routine if present for a timer/
				//	remote disconnect.
				if ((DisconnectType == ATALK_REMOTE_DISCONNECT) ||
					(DisconnectType == ATALK_TIMER_DISCONNECT))
				{
					PVOID 					discCtx;
					PTDI_IND_DISCONNECT 	discHandler = NULL;

					//	Acquire lock so we get a consistent handler/ctx.
					ACQUIRE_SPIN_LOCK(&pPapConn->papco_pAssocAddr->papao_Lock, &OldIrql);
					discHandler = pPapConn->papco_pAssocAddr->papao_DisconnectHandler;
					discCtx = pPapConn->papco_pAssocAddr->papao_DisconnectHandlerCtx;

					DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_INFO,
							("AtalkPapDisconnect: IndDisc to AFD %lx\n", pPapConn));
#if DBG
					if (discHandler != NULL)
					{
						pPapConn->papco_Flags |= PAPCO_INDICATE_AFD_DISC;
					}
#endif
					RELEASE_SPIN_LOCK(&pPapConn->papco_pAssocAddr->papao_Lock, OldIrql);

					if (discHandler != NULL)
					{
						//	We use TDI_DISCONNECT_ABORT for flags. This makes
						//	AFD call Close for connection, but also allows a
						//	recv to come in as we are a buffering transport.
						(*discHandler)(discCtx,
									   pPapConn->papco_ConnCtx,
									   0,						//	DisconnectDataLength
									   NULL,					//	DisconnectData
									   0,		 				//	DisconnectInfoLength
									   NULL,					//	DisconnectInfo
									   TDI_DISCONNECT_ABORT);	//	Disconnect flags.
					}
				}

				//	Stop the atp address. only if we are a server job ?
				//	Client side pap connections can be many-to-one atp address.
				//	Doesn't affect monitor.
				AtalkAtpCleanupAddress(pPapConn->papco_pAtpAddr);
				ACQUIRE_SPIN_LOCK(&pPapConn->papco_Lock, &OldIrql);
			}
		}
		else
		{
			error = ATALK_INVALID_REQUEST;
		}
	}
	else
	{
		//	Do we need to remember the completion routines?
		//	Yes, if this is a disconnect or a indicate disconnect request,
		//	and our current disconnect was started due to the address object
		//	being closed.
		if (DisconnectType == ATALK_INDICATE_DISCONNECT)
		{
			if (pPapConn->papco_DisconnectInform == NULL)
			{
				pPapConn->papco_DisconnectInform = CompletionRoutine;
				pPapConn->papco_DisconnectInformCtx = pDisconnectCtx;
			}
			else
			{
				error = ATALK_TOO_MANY_COMMANDS;
			}
		}
		else if (DisconnectType == ATALK_LOCAL_DISCONNECT)
		{
			//	Replace completion routines only if previous ones are NULL.
			if (pPapConn->papco_DisconnectCompletion == NULL)
			{
				pPapConn->papco_DisconnectCompletion = CompletionRoutine;
				pPapConn->papco_DisconnectCtx		 = pDisconnectCtx;
			}
			else
			{
				error = ATALK_TOO_MANY_COMMANDS;
			}
		}
	}

	RELEASE_SPIN_LOCK(&pPapConn->papco_Lock, OldIrql);

	return error;
}




ATALK_ERROR
AtalkPapRead(
	IN	PPAP_CONNOBJ			pPapConn,
	IN	PAMDL					pReadBuf,
	IN	USHORT					ReadBufLen,
	IN	ULONG					ReadFlags,
	IN	PVOID					pReadCtx,
	IN	GENERIC_READ_COMPLETION	CompletionRoutine
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	BYTE			userBytes[ATP_USERBYTES_SIZE];
	USHORT			readLen, timeout;
	ULONG			readFlags;
	PACTREQ			pActReq;
	BOOLEAN			delayedDisConn = FALSE;
	KIRQL			OldIrql;
	ATALK_ERROR		error 		= ATALK_NO_ERROR;

	ASSERT(VALID_PAPCO(pPapConn));
	ASSERT(*CompletionRoutine != NULL);

	ACQUIRE_SPIN_LOCK(&pPapConn->papco_Lock, &OldIrql);

	do
	{
		if (ReadFlags & TDI_RECEIVE_EXPEDITED)
		{
			error = ATALK_INVALID_PARAMETER;
			break;
		}

		if (pPapConn->papco_Flags & PAPCO_READDATA_PENDING)
		{
			error = ATALK_PAP_TOO_MANY_READS;
			break;
		}

		//	PEEK not supported for PAP
		if (ReadFlags & TDI_RECEIVE_PEEK)
		{
			error = ATALK_PAP_INVALID_REQUEST;
			break;
		}


		//	Do we already have a pending/indicated read waiting?
		//	!!!NOTE!!! If we do we complete the read regardless. With winsock
		//	our primed read will complete and we will indicate the data, but the
		//	mac immediately follows with a disconnect. if the winsock client is
		//	unable to read the data, before the disconnect comes in, it will lose
		//	the last block of data.
		if (pPapConn->papco_Flags & PAPCO_READDATA_WAITING)
		{
			pActReq		= pPapConn->papco_NbReadActReq;
			readLen		= pPapConn->papco_NbReadLen;
			readFlags	= pPapConn->papco_NbReadFlags;

			//	Make sure buffer size is atleast that of the indicated
			//	data.
			if (ReadBufLen < readLen)
			{
				error = ATALK_BUFFER_TOO_SMALL;
				break;
			}

			//	Reset the flags allowing primes to happen.
			pPapConn->papco_Flags	&= ~(PAPCO_NONBLOCKING_READ |
										 PAPCO_READDATA_WAITING);

			pPapConn->papco_NbReadLen	= 0;
			pPapConn->papco_NbReadFlags = 0;
			RELEASE_SPIN_LOCK(&pPapConn->papco_Lock, OldIrql);

			//	Call the action completion routine for the prime read.
			(*pActReq->ar_Completion)(ATALK_NO_ERROR, pActReq);

			if (ATALK_SUCCESS(error))
			{
				error = ((readFlags & TDI_RECEIVE_PARTIAL) ?
							ATALK_PAP_PARTIAL_RECEIVE : ATALK_NO_ERROR);
			}

			//	Call completion routine and return status success.
			(*CompletionRoutine)(error,
								pReadBuf,
								readLen,
								readFlags,
								pReadCtx);

			//	Return pending.
			return ATALK_PENDING;
		}

		if ((pPapConn->papco_Flags & PAPCO_ACTIVE) == 0)
		{
			error = ATALK_PAP_CONN_NOT_ACTIVE;
			break;
		}


		if (ReadBufLen < (PAP_MAX_FLOW_QUANTUM*PAP_MAX_DATA_PACKET_SIZE))
		{
			error = ATALK_BUFFER_TOO_SMALL;
			break;
		}

		error = ATALK_INVALID_CONNECTION;
		if ((pPapConn->papco_Flags & (PAPCO_CLOSING 	|
									  PAPCO_STOPPING |
									  PAPCO_DISCONNECTING)) == 0)
		{
			AtalkPapConnReferenceByPtrNonInterlock(pPapConn, &error);
		}

		if (!ATALK_SUCCESS(error))
		{
			break;
		}

		pPapConn->papco_Flags 	|= PAPCO_READDATA_PENDING;

		//	Remember read information in the connection object.
		pPapConn->papco_ReadCompletion	= CompletionRoutine;
		pPapConn->papco_ReadCtx			= pReadCtx;

	} while (FALSE);

	RELEASE_SPIN_LOCK(&pPapConn->papco_Lock, OldIrql);

	if (!ATALK_SUCCESS(error))
	{
		return error;
	}

	//	Build up the user bytes to post the 'SendData' to the remote end.
	userBytes[PAP_CONNECTIONID_OFF]	= pPapConn->papco_ConnId;
	userBytes[PAP_CMDTYPE_OFF]		= PAP_SEND_DATA;
	PUTSHORT2SHORT(&userBytes[PAP_SEQNUM_OFF], pPapConn->papco_NextOutgoingSeqNum);

	//	PAP Sequence number 0 means unsequenced.
	if (++pPapConn->papco_NextOutgoingSeqNum == 0)
		pPapConn->papco_NextOutgoingSeqNum = 1;

	//	Post the SendData request.
	pPapConn->papco_RT.rt_New = AtalkGetCurrentTick();
	if (pPapConn->papco_Flags & PAPCO_SERVER_JOB)
		 timeout = pPapConn->papco_RT.rt_Base;
	else timeout = PAP_MAX_SENDDATA_REQ_INTERVAL;

	error = AtalkAtpPostReq(pPapConn->papco_pAtpAddr,
							&pPapConn->papco_RemoteAddr,
							&pPapConn->papco_ReadDataTid,
							ATP_REQ_EXACTLY_ONCE,
							NULL,
							0,
							userBytes,
							pReadBuf,
							ReadBufLen,
							ATP_INFINITE_RETRIES,
							timeout,
							THIRTY_SEC_TIMER,
							atalkPapIncomingReadComplete,
							pPapConn);

	if (!ATALK_SUCCESS(error))
	{
		DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_ERR,
				("AtalkPapRead: AtalkAtpPostReq %ld\n", error));

		ACQUIRE_SPIN_LOCK(&pPapConn->papco_Lock, &OldIrql);

		//	Undo the seq number change.
		if (--pPapConn->papco_NextOutgoingSeqNum == 0)
			pPapConn->papco_NextOutgoingSeqNum = (USHORT)0xFFFF;

		pPapConn->papco_Flags 	&= ~PAPCO_READDATA_PENDING;

		//	Clear out read information in the connection object.
		pPapConn->papco_ReadCompletion	= NULL;
		pPapConn->papco_ReadCtx			= NULL;
		RELEASE_SPIN_LOCK(&pPapConn->papco_Lock, OldIrql);

		AtalkPapConnDereference(pPapConn);
	}
	else
	{
		DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_INFO,
				("AtalkPapRead: No error - AtalkAtpPostReq tid %lx\n",
				pPapConn->papco_ReadDataTid));

		error = ATALK_PENDING;
	}

	return error;
}




ATALK_ERROR
AtalkPapPrimeRead(
	IN	PPAP_CONNOBJ	pPapConn,
	IN	PACTREQ			pActReq
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	BYTE			userBytes[ATP_USERBYTES_SIZE];
	USHORT			timeout;
	KIRQL			OldIrql;
	ATALK_ERROR		error 		= ATALK_NO_ERROR;
        SHORT                   MaxRespBufLen;

	ASSERT(VALID_PAPCO(pPapConn));

	ACQUIRE_SPIN_LOCK(&pPapConn->papco_Lock, &OldIrql);

	do
	{
		DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_INFO,
				("AtalkPapPrimeRead: %lx\n", pPapConn));

		if (pPapConn->papco_Flags & PAPCO_NONBLOCKING_READ)
		{
			error = ATALK_PAP_TOO_MANY_READS;
			break;
		}

        if (pPapConn->papco_Flags & PAPCO_REJECT_READS)
        {
			error = ATALK_PAP_CONN_NOT_ACTIVE;
			break;
        }

		if ((pPapConn->papco_Flags & PAPCO_ACTIVE) == 0)
		{
			error = ATALK_PAP_CONN_NOT_ACTIVE;
			break;
		}

		error = ATALK_INVALID_CONNECTION;
		if ((pPapConn->papco_Flags & (PAPCO_CLOSING 			|
									  PAPCO_STOPPING			|
									  PAPCO_DELAYED_DISCONNECT	|
									  PAPCO_DISCONNECTING)) == 0)
		{
			AtalkPapConnReferenceByPtrNonInterlock(pPapConn, &error);
		}

		if (!ATALK_SUCCESS(error))
		{
			DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_ERR,
					("AtalkPapPrimeRead: Conn %lx Reference Failed %lx\n", pPapConn, error));
			break;
		}

		//	Remember info in the connection
		pPapConn->papco_Flags 		|= PAPCO_NONBLOCKING_READ;
		pPapConn->papco_NbReadLen 	 = 0;
		pPapConn->papco_NbReadActReq = pActReq;
	} while (FALSE);

	RELEASE_SPIN_LOCK(&pPapConn->papco_Lock, OldIrql);

	if (!ATALK_SUCCESS(error))
	{
		DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_INFO,
				("AtalkPapPrimeRead: Failed %lx.%lx\n", error, pPapConn));

		return error;
	}



	//	Build up the user bytes to post the 'SendData' to the remote end.
	userBytes[PAP_CONNECTIONID_OFF]	= pPapConn->papco_ConnId;
	userBytes[PAP_CMDTYPE_OFF]		= PAP_SEND_DATA;
	PUTSHORT2SHORT(&userBytes[PAP_SEQNUM_OFF], pPapConn->papco_NextOutgoingSeqNum);

	//	PAP Sequence number 0 means unsequenced.
	if (++pPapConn->papco_NextOutgoingSeqNum == 0)
		pPapConn->papco_NextOutgoingSeqNum = 1;

	//	Post the SendData request.
	pPapConn->papco_RT.rt_New = AtalkGetCurrentTick();
	if (pPapConn->papco_Flags & PAPCO_SERVER_JOB)
		 timeout = pPapConn->papco_RT.rt_Base;
	else timeout = PAP_MAX_SENDDATA_REQ_INTERVAL;

        MaxRespBufLen = (pPapConn->papco_pAtpAddr->atpao_MaxSinglePktSize * ATP_MAX_RESP_PKTS);
        if (pActReq->ar_MdlSize > MaxRespBufLen)
        {
            pActReq->ar_MdlSize = MaxRespBufLen;
        }

	error = AtalkAtpPostReq(pPapConn->papco_pAtpAddr,
							&pPapConn->papco_RemoteAddr,
							&pPapConn->papco_ReadDataTid,
							ATP_REQ_EXACTLY_ONCE,				// ExactlyOnce request
							NULL,
							0,
							userBytes,
							pActReq->ar_pAMdl,
							pActReq->ar_MdlSize,
							ATP_INFINITE_RETRIES,
							timeout,
							THIRTY_SEC_TIMER,
							atalkPapPrimedReadComplete,
							pPapConn);

	if (!ATALK_SUCCESS(error))
	{
		DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_ERR,
				("AtalkPapRead: AtalkAtpPostReq %ld\n", error));

		//	Out of resources error log.
		TMPLOGERR();

		ACQUIRE_SPIN_LOCK(&pPapConn->papco_Lock, &OldIrql);

		//	Undo the seq number change.
		if (--pPapConn->papco_NextOutgoingSeqNum == 0)
			pPapConn->papco_NextOutgoingSeqNum = (USHORT)0xFFFF;

		pPapConn->papco_Flags 		&= ~PAPCO_NONBLOCKING_READ;
		pPapConn->papco_NbReadActReq = NULL;
		pPapConn->papco_NbReadLen 	 = 0;
		RELEASE_SPIN_LOCK(&pPapConn->papco_Lock, OldIrql);

		AtalkPapConnDereference(pPapConn);
	}
	else
	{
		DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_INFO,
				("AtalkPapPrimedRead: No error - AtalkAtpPostReq tid %lx\n",
				pPapConn->papco_ReadDataTid));

		error = ATALK_PENDING;

		//	If a disconnect happened, cancel prime read just in case disconnect
		//	was unable to due to the tid having been uninitialized.
		if (pPapConn->papco_Flags & PAPCO_DISCONNECTING)
		{
			DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_ERR,
					("AtalkPapPrimedRead: DISC When PRIMEREAD %lx.%lx\n",
					pPapConn, pPapConn->papco_Flags));

			AtalkAtpCancelReq(pPapConn->papco_pAtpAddr,
							  pPapConn->papco_ReadDataTid,
							  &pPapConn->papco_RemoteAddr);
		}
	}

	return error;
}




ATALK_ERROR
AtalkPapWrite(
	IN	PPAP_CONNOBJ				pPapConn,
	IN	PAMDL						pWriteBuf,
	IN	USHORT						WriteBufLen,
	IN	ULONG						SendFlags,
	IN	PVOID						pWriteCtx,
	IN	GENERIC_WRITE_COMPLETION	CompletionRoutine
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	BOOLEAN					sendDataRecd, eom;
	ATALK_ERROR				error;
	PTDI_IND_SEND_POSSIBLE  sendPossibleHandler;
	PVOID   				sendPossibleHandlerCtx;
	KIRQL					OldIrql;
	PPAP_ADDROBJ			pPapAddr;


	ASSERT(VALID_PAPCO(pPapConn));

	pPapAddr = pPapConn->papco_pAssocAddr;

	ASSERT(VALID_PAPAO(pPapAddr));

	KeRaiseIrql(DISPATCH_LEVEL, &OldIrql);

	ACQUIRE_SPIN_LOCK_DPC(&pPapConn->papco_Lock);

	do
	{
		DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_INFO,
				("AtalkPapWrite: Buffer size %lx.%lx\n",
				WriteBufLen, pPapConn->papco_SendFlowQuantum * PAP_MAX_DATA_PACKET_SIZE));

		if (WriteBufLen > (pPapConn->papco_SendFlowQuantum * PAP_MAX_DATA_PACKET_SIZE))
		{
			error = ATALK_BUFFER_TOO_BIG;
			ASSERTMSG("AtalkPapWrite: An invalid buffer size used for write\n",
					(WriteBufLen <= (pPapConn->papco_SendFlowQuantum * PAP_MAX_DATA_PACKET_SIZE)));
			break;
		}

		if (pPapConn->papco_Flags & PAPCO_WRITEDATA_WAITING)
		{
			error = ATALK_PAP_TOO_MANY_WRITES;
			ASSERTMSG("AtalkPapWrite: A second write was posted\n", 0);
			break;
		}

		if ((pPapConn->papco_Flags & PAPCO_ACTIVE) == 0)
		{
			error = ATALK_PAP_CONN_NOT_ACTIVE;
			break;
		}

		//  Non-blocking sends for PAP:
		//  Pap uses a binary event - send data credit thats sent to the remote
		//  end. ATP remembers the actual size of the remote entity's response
		//  buffer. In any case, if we do not have send credit the call would
		//  block, and we dont want that to happen. Also, there should be no
		//  pending writes on the connection to begin with.
		//

		if (SendFlags & TDI_SEND_EXPEDITED)
		{
			ASSERTMSG("AtalkPapWrite: Expedited set for pap\n", 0);
			error = ATALK_INVALID_PARAMETER;
			break;
		}

		//	This goes away before the call returns. PostSendData has its
		//	own reference.
		error = ATALK_INVALID_CONNECTION;
		if ((pPapConn->papco_Flags & (	PAPCO_CLOSING			|
										PAPCO_STOPPING			|
										PAPCO_DISCONNECTING)) == 0)
		{
			AtalkPapConnReferenceByPtrNonInterlock(pPapConn, &error);
			if (ATALK_SUCCESS(error))
			{
				sendDataRecd = ((pPapConn->papco_Flags & PAPCO_SENDDATA_RECD) != 0);

				if (!sendDataRecd &&
					(SendFlags & TDI_SEND_NON_BLOCKING))
				{
					//	!!!NOTE!!!
					//	To avoid the race condition in AFD where an incoming
					//	send data indication setting send's possible to true
					//	is overwritten by this read's unwinding and setting it
					//	to false, we return ATALK_REQUEST_NOT_ACCEPTED, which
					//	will map to STATUS_REQUEST_NOT_ACCEPTED and then to
					//	WSAEWOULDBLOCK.

					error = ATALK_REQUEST_NOT_ACCEPTED;

					RELEASE_SPIN_LOCK_DPC(&pPapConn->papco_Lock);

					//	We have a reference on the connection we must remove.
					AtalkPapConnDereference(pPapConn);

					ACQUIRE_SPIN_LOCK_DPC(&pPapConn->papco_Lock);
				}
			}
		}

		if (!ATALK_SUCCESS(error))
		{
			DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_INFO,
					("AtalkPapWrite: Write failed %lx\n", error));
			break;
		}

		error = ATALK_PENDING;

		eom = (SendFlags & TDI_SEND_PARTIAL) ? FALSE : TRUE;

		pPapConn->papco_Flags 		   |= PAPCO_WRITEDATA_WAITING;
		if (eom)
		{
			pPapConn->papco_Flags	   |= PAPCO_SEND_EOF_WRITE;
		}

		pPapConn->papco_WriteCompletion	= CompletionRoutine;
		pPapConn->papco_WriteCtx		= pWriteCtx;

		pPapConn->papco_pWriteBuf		= pWriteBuf;
		pPapConn->papco_WriteLen		= WriteBufLen;

		//	Stop further writes from happening by indicating to afd.
		//	Call the send data event handler on the associated address with
		//	0 to turn off selects on writes. We do this before we post any
		//	get requests, so there is no race condition.
		//	remember send possible handler/context.
		sendPossibleHandler	= pPapAddr->papao_SendPossibleHandler;
		sendPossibleHandlerCtx = pPapAddr->papao_SendPossibleHandlerCtx;

	} while (FALSE);

	if (ATALK_SUCCESS(error))
	{
		if (sendDataRecd)
		{
			if (*sendPossibleHandler != NULL)
			{
				(*sendPossibleHandler)(sendPossibleHandlerCtx,
									   pPapConn->papco_ConnCtx,
									   0);
			}

			// atalkPostSendDataResp() will release the conn lock
			error = atalkPapPostSendDataResp(pPapConn);

			if (!ATALK_SUCCESS(error))
			{
				ACQUIRE_SPIN_LOCK_DPC(&pPapConn->papco_Lock);
				pPapConn->papco_Flags &= ~PAPCO_WRITEDATA_WAITING;
				RELEASE_SPIN_LOCK_DPC(&pPapConn->papco_Lock);
				DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_ERR,
						("AtalkPapWrite: atalkPapPostSendDataResp Failed %lx\n", pPapConn));
			}
		}
		else
		{
			RELEASE_SPIN_LOCK_DPC(&pPapConn->papco_Lock);
		}

		AtalkPapConnDereference(pPapConn);
	}
	else
	{
		RELEASE_SPIN_LOCK_DPC(&pPapConn->papco_Lock);
	}

	if (OldIrql != DISPATCH_LEVEL)
		KeLowerIrql(OldIrql);

	return error;
}




ATALK_ERROR
AtalkPapSetStatus(
	IN	PPAP_ADDROBJ	pPapAddr,
	IN	PAMDL			pStatusMdl,			// NULL if 0-length status
	IN	PACTREQ			pActReq
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	NTSTATUS		status;
	USHORT			stsBufSize=0;
	ULONG			bytesCopied;
	KIRQL			OldIrql;
	PBYTE			pStatusBuf = NULL, pFreeStatusBuf = NULL;

	ASSERT(VALID_PAPAO(pPapAddr));

	DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_INFO,
			("AtalkPapSetStatus: Entered for Addr %lx\n", pPapAddr));

	if (pStatusMdl == NULL)
	{
		pStatusBuf = NULL;
		stsBufSize = 0;
	}
	else
	{
		// Allocate a buffer and copy the contents of the passed in
		// buffer descriptor in it. Free an existing status buffer if one exists
		stsBufSize = (USHORT)AtalkSizeMdlChain(pStatusMdl);
		if (stsBufSize >= PAP_MAX_STATUS_SIZE)
			return ATALK_BUFFER_TOO_BIG;
		if (stsBufSize < 0)
			return ATALK_BUFFER_TOO_SMALL;
	}

	if (stsBufSize > 0)
	{
		if ((pStatusBuf = AtalkAllocMemory(stsBufSize)) == NULL)
		{
			return ATALK_RESR_MEM;
		}

		status = TdiCopyMdlToBuffer(pStatusMdl,
									0,
									pStatusBuf,
									0,
									stsBufSize,
									&bytesCopied);

		ASSERT(NT_SUCCESS(status) && (bytesCopied == stsBufSize));
	}

	ACQUIRE_SPIN_LOCK(&pPapAddr->papao_Lock, &OldIrql);

	pFreeStatusBuf = pPapAddr->papao_pStatusBuf;

	pPapAddr->papao_pStatusBuf = pStatusBuf;
	pPapAddr->papao_StatusSize = stsBufSize;
	RELEASE_SPIN_LOCK(&pPapAddr->papao_Lock, OldIrql);

	if (pFreeStatusBuf != NULL)
	{
		AtalkFreeMemory(pFreeStatusBuf);
	}

	// Call the completion routine before returning.
	(*pActReq->ar_Completion)(ATALK_NO_ERROR, pActReq);
	return ATALK_NO_ERROR;
}




ATALK_ERROR
AtalkPapGetStatus(
	IN	PPAP_ADDROBJ	pPapAddr,
	IN	PATALK_ADDR		pRemoteAddr,
	IN	PAMDL			pStatusAmdl,
	IN	USHORT			AmdlSize,
	IN	PACTREQ			pActReq
	)
/*++

Routine Description:


Arguments:

	The Status Buffer passed in will be preceded by 4 bytes for the
	unused bytes.

Return Value:


--*/
{
	ATALK_ERROR	error;
	BYTE		userBytes[ATP_USERBYTES_SIZE];
	USHORT		tid;

	if ((pRemoteAddr->ata_Network == 0) ||
        (pRemoteAddr->ata_Node == 0)	||
        (pRemoteAddr->ata_Socket == 0))
	{
		return ATALK_SOCKET_INVALID;
	}
	userBytes[PAP_CONNECTIONID_OFF]	= 0;
	userBytes[PAP_CMDTYPE_OFF]		= PAP_SEND_STATUS;
	PUTSHORT2SHORT(&userBytes[PAP_SEQNUM_OFF], 0);

	error = AtalkAtpPostReq(pPapAddr->papao_pAtpAddr,
							pRemoteAddr,
							&tid,
							0,							// ExactlyOnce request
							NULL,
							0,
							userBytes,
							pStatusAmdl,
							AmdlSize,
							PAP_GETSTATUS_REQ_RETRYCOUNT,
							PAP_GETSTATUS_ATP_INTERVAL,
							THIRTY_SEC_TIMER,
							atalkPapIncomingStatus,
							(PVOID)pActReq);

	if (ATALK_SUCCESS(error))
	{
		error = ATALK_PENDING;
	}

	return error;
}



VOID
AtalkPapQuery(
	IN	PVOID			pObject,
	IN	ULONG			ObjectType,
	IN	PAMDL			pAmdl,
	OUT	PULONG			BytesWritten
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	switch (ObjectType)
	{
	  case TDI_TRANSPORT_ADDRESS_FILE :
		ASSERT(VALID_PAPAO((PPAP_ADDROBJ)pObject));
		AtalkDdpQuery(AtalkPapGetDdpAddress((PPAP_ADDROBJ)pObject),
					  pAmdl,
					  BytesWritten);

		break;

	  case TDI_CONNECTION_FILE :
		{
			PPAP_CONNOBJ	pPapConn;
			KIRQL			OldIrql;

			pPapConn	= (PPAP_CONNOBJ)pObject;
			ASSERT(VALID_PAPCO(pPapConn));

			*BytesWritten = 0;
			//	Get the address from the associated address if any.
			ACQUIRE_SPIN_LOCK(&pPapConn->papco_Lock, &OldIrql);
			if (pPapConn->papco_Flags & PAPCO_ASSOCIATED)
			{
				AtalkDdpQuery(AtalkPapGetDdpAddress(pPapConn->papco_pAssocAddr),
							  pAmdl,
							  BytesWritten);
			}
			RELEASE_SPIN_LOCK(&pPapConn->papco_Lock, OldIrql);
		}
		break;

	  case TDI_CONTROL_CHANNEL_FILE :
	  default:
		break;
	}

}




LOCAL	ATALK_ERROR
atalkPapRepostConnect(
	IN	PPAP_CONNOBJ			pPapConn,
	IN	PAMDL					pOpenAmdl,
	IN	PAMDL					pRespAmdl
	)
/*++

Routine Description:


Arguments:



Return Value:


--*/
{
	BYTE		userBytes[ATP_USERBYTES_SIZE];
	PBYTE		pOpenPkt = AtalkGetAddressFromMdlSafe(pOpenAmdl, NormalPagePriority);
	ATALK_ERROR	error;

	if (pOpenPkt == NULL) {
		error = ATALK_RESR_MEM;
		return error;
	}

	//	Okay, prepare to post the OpenConn request; build up both userBytes and
	//	data buffer!
	userBytes[PAP_CONNECTIONID_OFF]	= pPapConn->papco_ConnId;
	userBytes[PAP_CMDTYPE_OFF]		= PAP_OPEN_CONN;
	PUTSHORT2SHORT(&userBytes[PAP_SEQNUM_OFF], 0);

	pOpenPkt[PAP_RESP_SOCKET_OFF] 	= PAPCONN_DDPSOCKET(pPapConn);
	pOpenPkt[PAP_FLOWQUANTUM_OFF]	= PAP_MAX_FLOW_QUANTUM;
	PUTDWORD2SHORT(&pOpenPkt[PAP_WAITTIME_OFF], pPapConn->papco_WaitTimeOut);

	//	Post the open connection request. We do it on the atp address of the
	//	pap address object.
	error = AtalkAtpPostReq(pPapConn->papco_pAtpAddr,
							&pPapConn->papco_RemoteAddr,
							&pPapConn->papco_ConnectTid,
							ATP_REQ_EXACTLY_ONCE,				// ExactlyOnce request
							pOpenAmdl,
							PAP_STATUS_OFF,
							userBytes,
							pRespAmdl,
							PAP_MAX_DATA_PACKET_SIZE,
							PAP_OPENCONN_REQ_RETRYCOUNT,
							PAP_OPENCONN_INTERVAL,
							THIRTY_SEC_TIMER,
							atalkPapIncomingOpenReply,
							pPapConn);
	return error;
}


LOCAL VOID FASTCALL
atalkPapAddrDeref(
	IN	PPAP_ADDROBJ		pPapAddr
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	KIRQL	OldIrql;
	BOOLEAN	done = FALSE;

	ACQUIRE_SPIN_LOCK(&pPapAddr->papao_Lock, &OldIrql);
	ASSERT(pPapAddr->papao_RefCount > 0);
	if (--pPapAddr->papao_RefCount == 0)
	{
		done = TRUE;
		ASSERT(pPapAddr->papao_Flags & PAPAO_CLOSING);
	}
	RELEASE_SPIN_LOCK(&pPapAddr->papao_Lock, OldIrql);

	if (done)
	{
		DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_INFO,
				("atalkPapAddrDeref: Addr %lx done with.\n", pPapAddr));

		if (pPapAddr->papao_CloseComp != NULL)
		{
			(*pPapAddr->papao_CloseComp)(ATALK_NO_ERROR,
										 pPapAddr->papao_CloseCtx);
		}

		//	Remove from the global list.
		ACQUIRE_SPIN_LOCK(&atalkPapLock, &OldIrql);
		AtalkUnlinkDouble(pPapAddr, papao_Next, papao_Prev);
		RELEASE_SPIN_LOCK(&atalkPapLock, OldIrql);

		// Free any status buffer allocated for this address object
		if (pPapAddr->papao_pStatusBuf != NULL)
			AtalkFreeMemory(pPapAddr->papao_pStatusBuf);

		AtalkFreeMemory(pPapAddr);

		AtalkUnlockPapIfNecessary();
	}
}




LOCAL VOID FASTCALL
atalkPapConnRefByPtrNonInterlock(
	IN	PPAP_CONNOBJ		pPapConn,
	OUT	PATALK_ERROR		pError
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	*pError = ATALK_NO_ERROR;
	ASSERT(VALID_PAPCO(pPapConn));

	if ((pPapConn->papco_Flags & PAPCO_CLOSING) == 0)
	{
		ASSERT(pPapConn->papco_RefCount >= 1);

		pPapConn->papco_RefCount ++;
	}
	else
	{
		*pError = ATALK_PAP_CONN_CLOSING;
	}
}




LOCAL	VOID
atalkPapConnRefByCtxNonInterlock(
	IN	PPAP_ADDROBJ		pPapAddr,
	IN	CONNECTION_CONTEXT	Ctx,
	OUT	PPAP_CONNOBJ	*	pPapConn,
	OUT	PATALK_ERROR		pError
	)
/*++

Routine Description:

	!!!MUST BE CALLED WITH THE ADDRESS SPINLOCK HELD!!!

Arguments:


Return Value:


--*/
{
	PPAP_CONNOBJ	pPapChkConn;
	ATALK_ERROR		error = ATALK_PAP_CONN_NOT_FOUND;

	for (pPapChkConn = pPapAddr->papao_pAssocConn;
		 pPapChkConn != NULL;
		 pPapChkConn = pPapChkConn->papco_pNextAssoc)
	{
		if (pPapChkConn->papco_ConnCtx == Ctx)
		{
			AtalkPapConnReferenceByPtr(pPapChkConn, &error);
			if (ATALK_SUCCESS(error))
			{
				*pPapConn = pPapChkConn;
			}
			break;
		}
	}

	*pError = error;
}




LOCAL	VOID
atalkPapConnRefNextNc(
	IN		PPAP_CONNOBJ		pPapConn,
	IN		PPAP_CONNOBJ	*	ppPapConnNext,
	OUT		PATALK_ERROR		pError
	)
/*++

Routine Description:

	MUST BE CALLED WITH THE ASSOCIATED ADDRESS LOCK HELD!

Arguments:


Return Value:


--*/
{
	PPAP_CONNOBJ	pNextConn 	= NULL;
	ATALK_ERROR		error 		= ATALK_FAILURE;

	ASSERT(VALID_PAPCO(pPapConn));

	for (; pPapConn != NULL; pPapConn = pPapConn->papco_pNextActive)
	{
		AtalkPapConnReferenceByPtrDpc(pPapConn, &error);
		if (ATALK_SUCCESS(error))
		{
			//	Ok, this connection is referenced!
			*ppPapConnNext = pPapConn;
			break;
		}
	}

	*pError = error;
}




LOCAL VOID FASTCALL
atalkPapConnDeref(
	IN	PPAP_CONNOBJ		pPapConn
	)
/*++

Routine Description:

	Disconnect completion happens when the reference count goes from
	2->1 if the creation reference is not already removed. If the creation
	reference is already removed, it will be done when the refcount goes
	from 1->0.

Arguments:


Return Value:


--*/
{
	KIRQL			OldIrql;
	BOOLEAN			fEndProcessing = FALSE;

	ASSERT(VALID_PAPCO(pPapConn));

	ACQUIRE_SPIN_LOCK(&pPapConn->papco_Lock, &OldIrql);

	ASSERT(pPapConn->papco_RefCount > 0);
	pPapConn->papco_RefCount--;

	if (pPapConn->papco_RefCount > 1)
	{
		fEndProcessing = TRUE;
	}
	RELEASE_SPIN_LOCK(&pPapConn->papco_Lock, OldIrql);

	if (fEndProcessing)
	{
		return;
	}
	else
	{
		PTDI_IND_DISCONNECT 	discHandler;
		PVOID 					discCtx;
		ATALK_ERROR				disconnectStatus;

		GENERIC_COMPLETION		disconnectInform		= NULL;
		PVOID					disconnectInformCtx		= NULL;
		GENERIC_COMPLETION		disconnectCompletion	= NULL;
		PVOID					cleanupCtx				= NULL;
		GENERIC_COMPLETION		cleanupCompletion		= NULL;
		PVOID					closeCtx				= NULL;
		GENERIC_COMPLETION		closeCompletion			= NULL;
		PVOID					disconnectCtx			= NULL;
		PATP_ADDROBJ			pAtpAddr				= NULL;

		PPAP_ADDROBJ			pPapAddr	= pPapConn->papco_pAssocAddr;
		BOOLEAN					disconnDone = FALSE;

		//	We allow stopping phase to happen only after disconnecting is done.
		//	If disconnecting is not set and stopping is, it implies we are only
		//	in an associated state.
		ACQUIRE_SPIN_LOCK(&pPapConn->papco_Lock, &OldIrql);
		if (pPapConn->papco_Flags & PAPCO_DISCONNECTING)
		{
			DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_INFO,
					("atalkPapConnDeref: Disconnect set for %lx\n", pPapConn));

			if (pPapConn->papco_RefCount == 1)
			{
				DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_INFO,
						("atalkPapConnDeref: Disconnect done %lx\n",
						pPapConn));

				disconnDone = TRUE;

				//	Avoid multiple disconnect completions/close atp addresses
				//	Remember all the disconnect info before we release the lock
				disconnectInform		= pPapConn->papco_DisconnectInform;
				disconnectInformCtx		= pPapConn->papco_DisconnectInformCtx;
				disconnectStatus		= pPapConn->papco_DisconnectStatus;
				disconnectCompletion	= pPapConn->papco_DisconnectCompletion;
				disconnectCtx			= pPapConn->papco_DisconnectCtx;

				//	The atp address to be closed
				pAtpAddr 			= pPapConn->papco_pAtpAddr;

				//	Reset all the be null, so next request doesnt get any
				pPapConn->papco_DisconnectInform		= NULL;
				pPapConn->papco_DisconnectInformCtx		= NULL;
				pPapConn->papco_DisconnectCompletion	= NULL;
				pPapConn->papco_DisconnectCtx			= NULL;
				pPapConn->papco_pAtpAddr				= NULL;
			}
		}

		if (pPapConn->papco_RefCount == 0)
		{
			closeCtx			= pPapConn->papco_CloseCtx;
			closeCompletion		= pPapConn->papco_CloseComp;

			pPapConn->papco_CloseCtx = NULL;
			pPapConn->papco_CloseComp= NULL;

			ASSERT(pPapConn->papco_Flags & PAPCO_CLOSING);
		}
		RELEASE_SPIN_LOCK(&pPapConn->papco_Lock, OldIrql);

		if (disconnDone)
		{
			//	Remove from the active queue.
			//	Reset all relevent flags.
			ACQUIRE_SPIN_LOCK(&pPapAddr->papao_Lock, &OldIrql);
			ACQUIRE_SPIN_LOCK_DPC(&pPapConn->papco_Lock);

			atalkPapConnDeQueueActiveList(pPapAddr, pPapConn);

			discHandler = pPapConn->papco_pAssocAddr->papao_DisconnectHandler;
			discCtx = pPapConn->papco_pAssocAddr->papao_DisconnectHandlerCtx;

			//	Close the atp address if a server object. If the SERVER_JOB flag
			//	is set, it implies that the atp address object was open.
			if ((pPapConn->papco_Flags & PAPCO_SERVER_JOB) == 0)
			{
				pAtpAddr = NULL;
			}

			//	This can be done outside the spinlock section. Keep disconnection
			//	flag set so no other requests can get in.
			//	!!!NOTE!!! We keep the readdata_waiting flag so that the client
			//	may read the last set of data sent by the mac.

			pPapConn->papco_Flags	&=	~(PAPCO_LISTENING 			|
										  PAPCO_CONNECTING			|
										  PAPCO_ACTIVE				|
                                          PAPCO_DISCONNECTING       |
										  PAPCO_READDATA_PENDING	|
										  PAPCO_WRITEDATA_WAITING	|
										  PAPCO_NONBLOCKING_READ	|
										  PAPCO_SENDDATA_RECD);

            pPapConn->papco_Flags |= PAPCO_REJECT_READS;

			RELEASE_SPIN_LOCK_DPC(&pPapConn->papco_Lock);
			RELEASE_SPIN_LOCK(&pPapAddr->papao_Lock, OldIrql);

			//	Call the disconnect completion routines.
			if (*disconnectInform != NULL)
			{
				(*disconnectInform)(disconnectStatus, disconnectInformCtx);
			}

			if (*disconnectCompletion != NULL)
			{
				(*disconnectCompletion)(disconnectStatus, disconnectCtx);
			}

			//	Close the atp address if a server object. If the SERVER_JOB flag
			//	is set, it implies that the atp address object was open.
			if (pAtpAddr != NULL)
			{
				ASSERT(VALID_ATPAO(pAtpAddr));
				ASSERT(pPapConn->papco_pAtpAddr == NULL);
				AtalkAtpCloseAddress(pAtpAddr, NULL, NULL);
			}
		}

		//	Check if we are done with stopping. We could either just be done with
		//	disconnect, or be done previously, and just need to complete the stop
		//	now.
		ACQUIRE_SPIN_LOCK(&pPapConn->papco_Lock, &OldIrql);
		if ((pPapConn->papco_Flags & PAPCO_STOPPING) != 0)
		{
			BOOLEAN	fDisassoc = FALSE;

			//	See if we do the cleanup irp completion.
			if (pPapConn->papco_RefCount == 1)
			{
				cleanupCtx			= pPapConn->papco_CleanupCtx;
				cleanupCompletion	= pPapConn->papco_CleanupComp;

				pPapConn->papco_CleanupComp	= NULL;
				pPapConn->papco_CleanupCtx  = NULL;

				pPapConn->papco_Flags &= ~PAPCO_STOPPING;

				DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_INFO,
						("atalkPapConnDeref: Cleanup on %lx.%lx\n",
						pPapConn, cleanupCtx));
			}

			if ((pPapConn->papco_Flags & (	PAPCO_LISTENING 	|
											PAPCO_CONNECTING  	|
											PAPCO_ACTIVE)) == 0)
			{
				DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_INFO,
						("atalkPapConnDeref: Stopping - do disassoc for %lx\n", pPapConn));

				fDisassoc = ((pPapConn->papco_Flags & PAPCO_ASSOCIATED) != 0);
			}
			RELEASE_SPIN_LOCK(&pPapConn->papco_Lock, OldIrql);

			//	Call the disassociate routine. This should just fail, if the
			//	connection is still active or any other state than just
			//	plain associated. This will also reset the stopping flag.
			if (fDisassoc)
			{
				AtalkPapDissociateAddress(pPapConn);
			}
		}
		else
		{
			RELEASE_SPIN_LOCK(&pPapConn->papco_Lock, OldIrql);
		}

		//	Complete cleanup at the end.
		if (*cleanupCompletion != NULL)
			(*cleanupCompletion)(ATALK_NO_ERROR, cleanupCtx);

		if (*closeCompletion != NULL)
		{
			DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_INFO,
					("atalkPapConnDeref: Close done for %lx\n", pPapConn));

			//	Call the close completion routines
			(*closeCompletion)(ATALK_NO_ERROR, closeCtx);

			//	Remove from the global list.
			ACQUIRE_SPIN_LOCK(&atalkPapLock, &OldIrql);
			AtalkUnlinkDouble(pPapConn, papco_Next, papco_Prev);
			RELEASE_SPIN_LOCK(&atalkPapLock, OldIrql);

			//	Free up the connection memory.
			DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_INFO,
					("atalkPapConnDeref: Freeing up connection %lx\n", pPapConn));

			AtalkUnlockPapIfNecessary();
			AtalkFreeMemory(pPapConn);
		}
	}
}




LOCAL ATALK_ERROR FASTCALL
atalkPapPostSendDataResp(
	IN	PPAP_CONNOBJ	pPapConn
	)
/*++

Routine Description:

	Timing Thoughts:	We could get here from PapWrite *only* if we had already
	received a senddata. And so we will not get here from a send data being received
	as it will not be accepted while we have a previous send data pending. The
	other way around- we will only get here from a send data coming in if we
	have a write pending. So we will never get here from write as we would not
	have had a send data pending at that time.

	If the connection reference fails, that means we are shutting down, and
	the shutdown code would already have called the write completion with an
	error. We just get outta here.

	THIS IS CALLED WITH papco_Lock held !!!

Arguments:


Return Value:


--*/
{
	ATALK_ERROR		error;
	PATP_RESP		pAtpResp;
	BYTE			userBytes[ATP_USERBYTES_SIZE];

	ASSERT(VALID_PAPCO(pPapConn));

	// ACQUIRE_SPIN_LOCK_DPC(&pPapConn->papco_Lock);

	//	If we are disconnecting or received a remote disconnect, get out.
	//	The disconnect routine would have already cancelled the response.
	error	= ATALK_FAILURE;
	if ((pPapConn->papco_Flags & (PAPCO_CLOSING 			|
								  PAPCO_STOPPING 			|
								  PAPCO_DELAYED_DISCONNECT 	|
								  PAPCO_RECVD_DISCONNECT 	|
								  PAPCO_DISCONNECTING)) == 0)
	{
		ASSERT ((pPapConn->papco_Flags & (PAPCO_SENDDATA_RECD | PAPCO_WRITEDATA_WAITING)) ==
										 (PAPCO_SENDDATA_RECD | PAPCO_WRITEDATA_WAITING));
	
		userBytes[PAP_CONNECTIONID_OFF] = pPapConn->papco_ConnId;
		userBytes[PAP_CMDTYPE_OFF] = PAP_DATA;
	
		//	If EOF, need a non-zero value in the first byte.
		PUTSHORT2SHORT(&userBytes[PAP_EOFFLAG_OFF], 0);
		if (pPapConn->papco_Flags & PAPCO_SEND_EOF_WRITE)
			userBytes[PAP_EOFFLAG_OFF] = TRUE;
	
		pAtpResp = pPapConn->papco_pAtpResp;

		//	Reference connection for this send.
		AtalkPapConnReferenceByPtrNonInterlock(pPapConn, &error);

		if (ATALK_SUCCESS(error))
		{
			AtalkAtpRespReferenceByPtrDpc(pAtpResp, &error);
		}
		else
		{
			//	Connection reference failed!
			//	Pending write would have been completed by the closing routine.
			DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_ERR,
					("AtalkPapPostSendData: Conn ref failed for %lx.%lx\n",
					pPapConn, pPapConn->papco_Flags));

			//	This should never happen as we check closing flag above and the reference
			//	shouldn't fail for any other reason.
			KeBugCheck(0);
		}
	}
	else
	{
		DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_ERR,
				("AtalkPapPostSendData: HIT RACE CONDITION conn %lx Resp %lx\n",
				pPapConn, pPapConn->papco_pAtpResp));
	}

	RELEASE_SPIN_LOCK_DPC(&pPapConn->papco_Lock);

	DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_INFO,
			("AtalkPapPostSendData: conn %lx Resp %lx\n",
			pPapConn, pPapConn->papco_pAtpResp));

	if (ATALK_SUCCESS(error))
	{
		//	Post the response.
		error = AtalkAtpPostResp(pAtpResp,
								 &pPapConn->papco_SendDataSrc,
								 pPapConn->papco_pWriteBuf,
								 pPapConn->papco_WriteLen,
								 userBytes,
								 atalkPapSendDataRel,
								 pPapConn);
		AtalkAtpRespDereference(pAtpResp);

		if (!ATALK_SUCCESS(error))
		{
			//	Simulate completion with an error.
			atalkPapSendDataRel(error, pPapConn);
		}
		error = ATALK_PENDING;
	}

	return error;
}




LOCAL VOID
atalkPapIncomingReadComplete(
	IN	ATALK_ERROR		ErrorCode,
	IN	PPAP_CONNOBJ	pPapConn,		// Our context
	IN	PAMDL			pReqAmdl,
	IN	PAMDL			pReadAmdl,
	IN	USHORT			ReadLen,
	IN	PBYTE			ReadUserBytes
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	GENERIC_READ_COMPLETION	pReadCompletion;
	PVOID					pReadCtx;
	KIRQL					OldIrql;
	ULONG					readFlags = TDI_RECEIVE_PARTIAL;

	ASSERT(VALID_PAPCO(pPapConn));

	if (ATALK_SUCCESS(ErrorCode))
	{
		//	When a read completes, tag that we have heard something from the other side
		pPapConn->papco_LastContactTime = AtalkGetCurrentTick();

		if ((ReadUserBytes[PAP_CONNECTIONID_OFF] != pPapConn->papco_ConnId) ||
			(ReadUserBytes[PAP_CMDTYPE_OFF] != PAP_DATA))
		{
			DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_ERR,
					("atalkPapIncomingReadComplete: ReadUserBytes %lx. %lx\n",
					*((PULONG)ReadUserBytes), pPapConn->papco_ConnId));

			ErrorCode = ATALK_PAP_INVALID_USERBYTES;
		}
		if (ReadUserBytes[PAP_EOFFLAG_OFF] != 0)
		{
			readFlags = 0;
		}
	}
	else
	{
		DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_ERR,
				("atalkPapIncomingReadComplete: Error %lx for pPapConn %lx\n",
					ErrorCode, pPapConn));
	}

	ASSERT(pReqAmdl == NULL);


	// Estimate the retry interval for next time.
	if (pPapConn->papco_Flags & PAPCO_SERVER_JOB)
	{
		pPapConn->papco_RT.rt_New = AtalkGetCurrentTick() - pPapConn->papco_RT.rt_New;
		AtalkCalculateNewRT(&pPapConn->papco_RT);
	}

#ifdef	PROFILING
	{
		KIRQL	OldIrql;

		ACQUIRE_SPIN_LOCK(&AtalkStatsLock, &OldIrql);

		AtalkStatistics.stat_LastPapRTT = (ULONG)(pPapConn->papco_RT.rt_Base);
		if ((ULONG)(pPapConn->papco_RT.rt_Base) > AtalkStatistics.stat_MaxPapRTT)
			AtalkStatistics.stat_MaxPapRTT = (ULONG)(pPapConn->papco_RT.rt_Base);

		RELEASE_SPIN_LOCK(&AtalkStatsLock, OldIrql);
	}
#endif

	//	Before we look at the incoming error code, see if we can mark in the
	//	job structure that the other sides sendData is complete.
	ACQUIRE_SPIN_LOCK(&pPapConn->papco_Lock, &OldIrql);
	pPapConn->papco_Flags 	&= ~PAPCO_READDATA_PENDING;
	pReadCompletion			 = pPapConn->papco_ReadCompletion;
	pReadCtx				 = pPapConn->papco_ReadCtx;

	ASSERT(pReadCompletion != NULL);
	RELEASE_SPIN_LOCK(&pPapConn->papco_Lock, OldIrql);

	(*pReadCompletion)(ErrorCode, pReadAmdl, ReadLen, readFlags, pReadCtx);

	//	Deref the connection object.
	AtalkPapConnDereference(pPapConn);
}




LOCAL VOID
atalkPapPrimedReadComplete(
	IN	ATALK_ERROR		ErrorCode,
	IN	PPAP_CONNOBJ	pPapConn,		// Our context
	IN	PAMDL			pReqAmdl,
	IN	PAMDL			pReadAmdl,
	IN	USHORT			ReadLen,
	IN	PBYTE			ReadUserBytes
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PTDI_IND_RECEIVE 		recvHandler;
	PVOID 					recvHandlerCtx;
	PIRP					recvIrp;
	NTSTATUS				ntStatus;
	ULONG					bytesTaken;
	PBYTE					pReadBuf;
	KIRQL					OldIrql;
	PACTREQ					pActReq;
	BOOLEAN					completeRead = FALSE, delayedDisConn = FALSE;
	ULONG					readFlags = (TDI_RECEIVE_PARTIAL | TDI_RECEIVE_NORMAL);

	ASSERT(VALID_PAPCO(pPapConn));

	if (ATALK_SUCCESS(ErrorCode))
	{
		if ((ReadUserBytes[PAP_CONNECTIONID_OFF] != pPapConn->papco_ConnId) ||
			(ReadUserBytes[PAP_CMDTYPE_OFF] != PAP_DATA))
		{
			//	This will mean a primed read completes with disconnect indication to afd!!
			DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_ERR,
					("atalkPapIncomingReadComplete: ReadUserBytes %lx. %lx\n",
					*((PULONG)ReadUserBytes), pPapConn->papco_ConnId));

			ErrorCode = ATALK_PAP_INVALID_USERBYTES;
		}
		if (ReadUserBytes[PAP_EOFFLAG_OFF] != 0)
		{
			readFlags = TDI_RECEIVE_NORMAL;
		}
	}
	else if (ErrorCode == ATALK_ATP_REQ_CANCELLED)
	{
		DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_ERR,
				("atalkPapIncomingReadComplete: Request cancelled\n"));
		completeRead = TRUE;
	}
	else
	{
		DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_ERR,
				("atalkPapIncomingReadComplete: Error %lx for pPapConn %lx\n",
				ErrorCode, pPapConn));
	}

	ASSERT(pReqAmdl == NULL);

#ifdef	PROFILING
	{
		KIRQL	OldIrql;

		ACQUIRE_SPIN_LOCK(&AtalkStatsLock, &OldIrql);

		AtalkStatistics.stat_LastPapRTT = (ULONG)(pPapConn->papco_RT.rt_Base);
		if ((ULONG)(pPapConn->papco_RT.rt_Base) > AtalkStatistics.stat_MaxPapRTT)
			AtalkStatistics.stat_MaxPapRTT = (ULONG)(pPapConn->papco_RT.rt_Base);

		RELEASE_SPIN_LOCK(&AtalkStatsLock, OldIrql);
	}
#endif

	//	Remember the info in the connection object.
	ACQUIRE_SPIN_LOCK(&pPapConn->papco_Lock, &OldIrql);

	pActReq	= pPapConn->papco_NbReadActReq;
	recvHandler 	= pPapConn->papco_pAssocAddr->papao_RecvHandler;
	recvHandlerCtx	= pPapConn->papco_pAssocAddr->papao_RecvHandlerCtx;

	if (ATALK_SUCCESS(ErrorCode))
	{
		//	When a read completes, tag that we have heard something from the other side
		pPapConn->papco_LastContactTime = AtalkGetCurrentTick();

		// Estimate the retry interval for next time.
		if (pPapConn->papco_Flags & PAPCO_SERVER_JOB)
		{
			pPapConn->papco_RT.rt_New = AtalkGetCurrentTick() - pPapConn->papco_RT.rt_New;
			AtalkCalculateNewRT(&pPapConn->papco_RT);
		}

		pPapConn->papco_Flags 		|= PAPCO_READDATA_WAITING;
		if (pPapConn->papco_Flags & PAPCO_RECVD_DISCONNECT)
		{
			// AFD gets awfully upset when a read is indicated after a disconnect
			recvHandler 				 = NULL;
		}
		pPapConn->papco_NbReadLen 	 = ReadLen;
		pPapConn->papco_NbReadFlags	 = readFlags;

		//	Get the system address for the mdl
		pReadBuf = (PBYTE)MmGetSystemAddressForMdlSafe(
				pActReq->ar_pAMdl,
				NormalPagePriority);

		if (pReadBuf == NULL)
		{
			pPapConn->papco_Flags 		&= ~PAPCO_NONBLOCKING_READ;
			pPapConn->papco_NbReadActReq = NULL;
			pPapConn->papco_NbReadLen 	 = 0;
		
			//	Do not indicate a receive
			recvHandler 				 = NULL;
		
			//	Complete the read
			completeRead = TRUE;
		}
	}
	else
	{
		pPapConn->papco_Flags 		&= ~PAPCO_NONBLOCKING_READ;
		pPapConn->papco_NbReadActReq = NULL;
		pPapConn->papco_NbReadLen 	 = 0;

		pReadBuf					 = NULL;

		//	Do not indicate a receive
		recvHandler 				 = NULL;

		//	Complete the read
		completeRead = TRUE;
	}

	RELEASE_SPIN_LOCK(&pPapConn->papco_Lock, OldIrql);

	//	Call the indication routine on the address object..
	if (*recvHandler != NULL)
	{
		DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_WARN,
				("atalkPapPrimedReadComplete: Indicating when disconnecting!\n"));

		ntStatus = (*recvHandler)(recvHandlerCtx,
								  pPapConn->papco_ConnCtx,
								  readFlags,
								  pPapConn->papco_NbReadLen,
								  pPapConn->papco_NbReadLen,
								  &bytesTaken,
								  pReadBuf,
								  &recvIrp);

		ASSERT((bytesTaken == 0) || (bytesTaken == ReadLen));
		if (ntStatus == STATUS_MORE_PROCESSING_REQUIRED)
		{
			if (recvIrp != NULL)
			{
				//  Post the receive as if it came from the io system
				ntStatus = AtalkDispatchInternalDeviceControl(
								(PDEVICE_OBJECT)AtalkDeviceObject[ATALK_DEV_PAP],
								recvIrp);

				ASSERT(ntStatus == STATUS_PENDING);
			}
			else
			{
				ASSERTMSG("atalkPapPrimedReadComplete: No receive irp!\n", 0);
				KeBugCheck(0);
			}
		}
		else if (ntStatus == STATUS_SUCCESS)
		{
			//	!!!NOTE!!!
			//	Its possible that a disconnect happened and completed
			//	the pending read already. And so AFD is returning us this
			//	for the indication as the connection is already disconnected.
			if (bytesTaken != 0)
			{
				//	Assume all of the data was read.
				ASSERT(bytesTaken == ReadLen);
				DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_INFO,
						("atalkPapPrimedReadComplete: All bytes read %lx\n",
							bytesTaken));

				//	We are done with the primed read.
				ACQUIRE_SPIN_LOCK(&pPapConn->papco_Lock, &OldIrql);
				if (pPapConn->papco_Flags & PAPCO_NONBLOCKING_READ)
				{
					pPapConn->papco_Flags 		&= ~(PAPCO_NONBLOCKING_READ |
													 PAPCO_READDATA_WAITING);

					pPapConn->papco_NbReadActReq = NULL;
					pPapConn->papco_NbReadLen 	 = 0;

					//	Complete the read
					completeRead = TRUE;
				}
				RELEASE_SPIN_LOCK(&pPapConn->papco_Lock, OldIrql);
			}
		}
		else if (ntStatus == STATUS_DATA_NOT_ACCEPTED)
		{
			//	Client may have posted a receive in the indication. Or
			//	it will post a receive later on. Do nothing here.
			DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_INFO,
					("atalkPapPrimedReadComplete: Indication status %lx\n", ntStatus));
		}
	}

	ACQUIRE_SPIN_LOCK(&pPapConn->papco_Lock, &OldIrql);

	if (pPapConn->papco_Flags & PAPCO_DELAYED_DISCONNECT)
	{
		delayedDisConn = TRUE;
		pPapConn->papco_Flags &= ~PAPCO_DELAYED_DISCONNECT;
	}

	RELEASE_SPIN_LOCK(&pPapConn->papco_Lock, OldIrql);

	//	Complete the action request.
	if (completeRead)
	{
		//	Call the action completion routine for the prime read.
		(*pActReq->ar_Completion)(ATALK_NO_ERROR, pActReq);
	}

	// Finally if we have a delayed disconnect, complete the stuff
	if (delayedDisConn)
	{
		AtalkPapDisconnect(pPapConn,
						   ATALK_REMOTE_DISCONNECT,
						   NULL,
						   NULL);
	}

	//	Deref the connection object.
	AtalkPapConnDereference(pPapConn);
}




LOCAL VOID
atalkPapIncomingStatus(
	IN	ATALK_ERROR		ErrorCode,
	IN	PACTREQ			pActReq,		// Our Ctx
	IN	PAMDL			pReqAmdl,
	IN	PAMDL			pStatusAmdl,
	IN	USHORT			StatusLen,
	IN	PBYTE			ReadUserBytes
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	//	Call the action completion routine
	(*pActReq->ar_Completion)(ErrorCode, pActReq);
}




LOCAL VOID FASTCALL
atalkPapSendDataRel(
	IN	ATALK_ERROR		ErrorCode,
	IN	PPAP_CONNOBJ	pPapConn
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PAMDL						pWriteBuf;
	SHORT						writeLen;
	GENERIC_WRITE_COMPLETION	writeCompletion;
	PVOID						writeCtx;
	PATP_RESP					pAtpResp;
	KIRQL						OldIrql;

	ASSERT(VALID_PAPCO(pPapConn));

	DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_INFO,
			("atalkPapSendDataRel: Error %lx for pPapConn %lx\n", ErrorCode, pPapConn));

	//	If this was cancelled, then we turn the error into a no-error.
	if (ErrorCode == ATALK_ATP_RESP_CANCELLED)
		ErrorCode = ATALK_NO_ERROR;

	ACQUIRE_SPIN_LOCK(&pPapConn->papco_Lock, &OldIrql);
	pPapConn->papco_Flags  &= ~(PAPCO_WRITEDATA_WAITING		|
								PAPCO_SENDDATA_RECD			|
								PAPCO_SEND_EOF_WRITE);

	pWriteBuf		= pPapConn->papco_pWriteBuf;
	writeLen		= pPapConn->papco_WriteLen;
	writeCompletion	= pPapConn->papco_WriteCompletion;
	writeCtx		= pPapConn->papco_WriteCtx;
	pAtpResp		= pPapConn->papco_pAtpResp;
	pPapConn->papco_pAtpResp = NULL;

	ASSERT (pAtpResp != NULL);

	//	Reinitialize all the variables.
	pPapConn->papco_WriteLen	= 0;
	pPapConn->papco_pWriteBuf	= NULL;
	pPapConn->papco_WriteCtx	= NULL;
	pPapConn->papco_WriteCompletion	= NULL;
	RELEASE_SPIN_LOCK(&pPapConn->papco_Lock, OldIrql);

	(*writeCompletion)(ErrorCode, pWriteBuf, writeLen, writeCtx);

	// Dereference the atp response structure now, but not if a response was never posted
	if (ErrorCode != ATALK_ATP_RESP_CLOSING)
	{
		AtalkAtpRespDereference(pAtpResp);
	}
	else
	{
		DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_ERR,
				("atalkPapSendDataRel: Resp cancelled before post %lx\n", pPapConn));
	}

	//	Dereference the connection
	AtalkPapConnDereference(pPapConn);
}




LOCAL VOID
atalkPapSlsHandler(
	IN	ATALK_ERROR			ErrorCode,
	IN	PPAP_ADDROBJ		pPapAddr,		// Listener (our context)
	IN	PATP_RESP			pAtpResp,
	IN	PATALK_ADDR			pSrcAddr,		// Address of requestor
	IN	USHORT				PktLen,
	IN	PBYTE				pPkt,
	IN	PBYTE				pUserBytes
	)
/*++

Routine Description:

 	Handler for incoming requests on the Sls. It handles session opens and get
 	status on the session.

Arguments:


Return Value:


--*/
{
	BYTE					connId, cmdType;
	BYTE					userBytes[ATP_USERBYTES_SIZE];
	PBYTE					pRespPkt;
	PAMDL					pRespAmdl;
	SHORT					respLen;
	PPAP_SEND_STATUS_REL	pSendSts;

	BOOLEAN					DerefAddr	= FALSE;
	ATALK_ERROR				error 		= ATALK_NO_ERROR;

	if (!ATALK_SUCCESS(ErrorCode))
	{
		//	Remove the reference on the address object since atp socket is closing
		if (ErrorCode == ATALK_ATP_CLOSING)
		{
			//	Remove reference on the connection since socket is closing
			AtalkPapAddrDereference(pPapAddr);
		}
		return;
	}

	//	Try to reference the address. If we fail, its probably closing, so
	//	get out. This reference will stay around for the duration of this call.
	AtalkPapAddrReference(pPapAddr, &error);
	if (!ATALK_SUCCESS(error))
	{
		if (pAtpResp != NULL)
		{
			AtalkAtpCancelResp(pAtpResp);
		}
		return;
	}

	//	If we have a send status request, and we manage to
	//	successfully post it, we reset this. And then it goes away in
	//	the release routine.
	DerefAddr		= TRUE;

	connId 	= pUserBytes[PAP_CONNECTIONID_OFF];
	cmdType	= pUserBytes[PAP_CMDTYPE_OFF];

	DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_INFO,
			("atalkPapSlsHandler: Received request %x, tid %x\n",
			cmdType, (pAtpResp != NULL) ? pAtpResp->resp_Tid : 0));

	switch(cmdType)
	{
	  case PAP_OPEN_CONN:
		//	Ensure packet length is ok.
		// Accept the connection. This will send any error replies as appropriate.
		if ((PktLen < PAP_STATUS_OFF) ||
			!atalkPapConnAccept(pPapAddr,
								pSrcAddr,
								pPkt,
								connId,
								pAtpResp))
		{
			AtalkAtpCancelResp(pAtpResp);
		}
		break;

	  case PAP_SEND_STATUS:
		userBytes[PAP_CONNECTIONID_OFF] = 0;
		userBytes[PAP_CMDTYPE_OFF] 		= PAP_STATUS_REPLY;
		PUTSHORT2SHORT(&userBytes[PAP_SEQNUM_OFF], 0);

		//	We need to put in the status with the spinlock of the
		//	address object held.
		ACQUIRE_SPIN_LOCK_DPC(&pPapAddr->papao_Lock);
		do
		{
			//	Get a buffer we can send the response with.
			ASSERTMSG("atalkPapSlsHandler: Status size incorrec\n",
					 (pPapAddr->papao_StatusSize >= 0));

			if ((pSendSts = AtalkAllocMemory(sizeof(PAP_SEND_STATUS_REL) +
											 pPapAddr->papao_StatusSize))== NULL)
			{
				error = ATALK_RESR_MEM;
				break;
			}

			respLen		= PAP_STATUS_OFF + 1;
			ASSERT(pPapAddr->papao_StatusSize <= PAP_MAX_STATUS_SIZE);

			pRespPkt = pSendSts->papss_StatusBuf;
			pRespPkt[PAP_STATUS_OFF]	= (BYTE)pPapAddr->papao_StatusSize;

			// Zero out the unused portion of the buffer
			PUTDWORD2DWORD(pRespPkt, 0);

			if (pPapAddr->papao_StatusSize > 0)
			{
				RtlCopyMemory(pRespPkt + 1 + PAP_STATUS_OFF,
							  pPapAddr->papao_pStatusBuf,
							  pPapAddr->papao_StatusSize);

				respLen += pPapAddr->papao_StatusSize;
				ASSERT(respLen <= PAP_MAX_DATA_PACKET_SIZE);
			}

			//	Build an mdl for the length that we are using.
			if ((pRespAmdl = AtalkAllocAMdl(pRespPkt, respLen)) == NULL)
			{
				error = ATALK_RESR_MEM;
				AtalkFreeMemory(pSendSts);
				break;
			}

			pSendSts->papss_pAmdl		= pRespAmdl;
			pSendSts->papss_pPapAddr	= pPapAddr;
			pSendSts->papss_pAtpResp	= pAtpResp;
		} while (FALSE);

		RELEASE_SPIN_LOCK_DPC(&pPapAddr->papao_Lock);

		if (!ATALK_SUCCESS(error))
		{
			AtalkAtpCancelResp(pAtpResp);
			break;
		}

		ASSERT(pSendSts != NULL);
		ASSERT((pRespAmdl != NULL) && (respLen > 0));

		error = AtalkAtpPostResp(pAtpResp,
								 pSrcAddr,
								 pRespAmdl,
								 respLen,
								 userBytes,
								 atalkPapStatusRel,
								 pSendSts);

		//	atalkPapStatusRel Dereferences the address.
		DerefAddr = FALSE;
		if (!ATALK_SUCCESS(error))
		{
			atalkPapStatusRel(error, pSendSts);
		}
		break;

	  default:
		DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_ERR,
				("atalkPapSlsHandler: Invalid request %x\n", cmdType));
		AtalkAtpCancelResp(pAtpResp);
		break;
	}

	//	Remove reference added at the beginning.
	if (DerefAddr)
	{
		AtalkPapAddrDereference(pPapAddr);
	}
}




LOCAL VOID
atalkPapIncomingReq(
	IN	ATALK_ERROR			ErrorCode,
	IN	PPAP_CONNOBJ		pPapConn,		// Connection (our context)
	IN	PATP_RESP			pAtpResp,
	IN	PATALK_ADDR			pSrcAddr,		// Address of requestor
	IN	USHORT				PktLen,
	IN	PBYTE				pPkt,
	IN	PBYTE				pUserBytes
	)
/*++

Routine Description:

	This handles requests on a connection, SendData, Tickles, and Close.

Arguments:


Return Value:


--*/
{
	ATALK_ERROR				error;
	BYTE					connId, cmdType;
	USHORT					seqNum;
	PTDI_IND_SEND_POSSIBLE  sendPossibleHandler;
	PVOID   				sendPossibleHandlerCtx;
	BOOLEAN					DerefConn = FALSE;
	BOOLEAN					cancelResp = TRUE;

	ASSERT(VALID_PAPCO(pPapConn));

	do
	{
		if (!ATALK_SUCCESS(ErrorCode))
		{
			DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_WARN,
					("atalkPapIncomingReq: pPapConn %lx, ErrorCode %ld, exit.\n",
					pPapConn, ErrorCode));

			if (ErrorCode == ATALK_ATP_CLOSING)
			{
				//	Remove reference on the connection since socket is closing
				AtalkPapConnDereference(pPapConn);
				break;
			}
		}

		ACQUIRE_SPIN_LOCK_DPC(&pPapConn->papco_Lock);
		if ((pPapConn->papco_Flags & (PAPCO_ACTIVE			|
									  PAPCO_STOPPING		|
									  PAPCO_LOCAL_DISCONNECT|
									  PAPCO_DISCONNECTING	|
									  PAPCO_CLOSING)) == PAPCO_ACTIVE)
		{
			AtalkPapConnReferenceByPtrNonInterlock(pPapConn, &error);
		}
		else
		{
			error = ATALK_INVALID_CONNECTION;
		}
		RELEASE_SPIN_LOCK_DPC(&pPapConn->papco_Lock);

		if (!ATALK_SUCCESS(error))
		{
			DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_ERR,
					("atalkPapIncomingReq: Ref FAILED/DISC %lx.%lx\n",
					pPapConn, pPapConn->papco_Flags));
			break;
		}

		//	Remember to remove connection referenced above
		DerefConn = TRUE;

		connId 	= pUserBytes[PAP_CONNECTIONID_OFF];
		cmdType	= pUserBytes[PAP_CMDTYPE_OFF];

		DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_INFO,
				("atalkPapIncomingReq: Received request %x, tid %x\n",
				cmdType, (pAtpResp != NULL) ? pAtpResp->resp_Tid : 0));

		if (connId != pPapConn->papco_ConnId)
		{
			//	Just drop this packet. Cancel response though in case this is
			//	a xo request
			DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_INFO,
					("atalkPapIncomingReq: ConnId %lx recd %lx\n",
					pPapConn->papco_ConnId, connId));
			break;
		}

		pPapConn->papco_LastContactTime = AtalkGetCurrentTick();

		switch (cmdType)
		{
		  case PAP_SEND_DATA:

			GETSHORT2SHORT(&seqNum, &pUserBytes[PAP_SEQNUM_OFF]);

			DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_INFO,
					("atalkPapIncomingReq: send data %lx recd %lx\n",
					seqNum, pPapConn->papco_ConnId));

			ACQUIRE_SPIN_LOCK_DPC(&pPapConn->papco_Lock);
			if ((seqNum == 0) &&
				(pPapConn->papco_Flags & PAPCO_SENDDATA_RECD))
			{
			   //	We have an unsequenced incoming sendData request before we've
			   //	finished with the previous one (i.e gotten a release for it).
			   //	We don't clear the PAPCO_SENDDATA_RECD flag until we receive
			   //	a release or time out. Also, we cannot assume an implied
			   //	release as we can with sequenced requests. So we just cancel
			   //	the response  so we can be notified of a retry of the send
			   //	data request again
				DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_ERR,
						("atalkPapIncomingReq: Dropping unseq send data %lx\n", pAtpResp));
				RELEASE_SPIN_LOCK_DPC(&pPapConn->papco_Lock);
				break;
			}

			if (seqNum != 0)
			{
				//	Sequenced send data. Verify the seq num.
				if (seqNum != (USHORT)(pPapConn->papco_NextIncomingSeqNum))
				{
					DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_ERR,
							("atalkPapIncomingReq: Out of Seq - current %lx, incoming %lx on %lx\n",
							pPapConn->papco_NextIncomingSeqNum, seqNum, pPapConn));

					//	Cancel our response.
					RELEASE_SPIN_LOCK_DPC(&pPapConn->papco_Lock);
					break;
				}

				if (pPapConn->papco_Flags & PAPCO_SENDDATA_RECD)
				{
					USHORT	tid;

					//	We have a send data before the previous one has completed.
					//	As PAP is a one-request-at-a-time protocol, we can assume
					//	that the release for previous transaction is lost. This
					//	gets rid of the 30 second pauses when a release is dropped.
					//	Cancel our response. Note this implies that a response
					//	had been posted by the pap client. In SendRel then, we
					//	convert the response cancelled error to no error.

					ASSERT (pPapConn->papco_pAtpResp != NULL);

					tid = pPapConn->papco_pAtpResp->resp_Tid;

					RELEASE_SPIN_LOCK_DPC(&pPapConn->papco_Lock);

					DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_WARN,
							("atalkPapIncomingReq: Cancelling response tid %x\n", tid));

					// CAUTION: We cannot use AtalkAtpCancelResp() since we have no
					//			reference to the resp structure and involves a potential
					//			race condition. Play safe and cancel by tid instead.
					error = AtalkAtpCancelRespByTid(pPapConn->papco_pAtpAddr,
													&pPapConn->papco_SendDataSrc,
													tid);

					DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_INFO,
							("atalkPapIncomingReq: Cancel error %lx\n", error));

					//	If we were unable to cancel the response that means that
					//	it already timed out or got a release. We dont want to
					//	get into a situation where we would be messing with variables
					//	accessed both in the SendDataRel and here. So we just
					//	cancel this response and hope to get it again.
					if (!ATALK_SUCCESS(error))
					{
						DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_WARN,
								("atalkPapIncomingReq: Cancel old resp tid %x (%ld)\n",
								tid, error));
						break;
					}

					ACQUIRE_SPIN_LOCK_DPC(&pPapConn->papco_Lock);
					pPapConn->papco_pAtpResp = NULL;
					pPapConn->papco_Flags &= ~(PAPCO_SENDDATA_RECD | PAPCO_WRITEDATA_WAITING);
				}

				//	Increment the sequence number. If we loop to 0, set to 1.
				if (++pPapConn->papco_NextIncomingSeqNum == 0)
				{
					pPapConn->papco_NextIncomingSeqNum = 1;
				}

				DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_INFO,
						("atalkPapIncomingReq: Recd %lx Next %lx\n",
						seqNum, pPapConn->papco_NextIncomingSeqNum));
			}
			else
			{
				//	Unsequenced send data received. Handle it.
				ASSERT (seqNum != 0);
				DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_INFO,
						("atalkPapIncomingReq: Unsequenced  send data recd!\n"));
			}

			cancelResp	= FALSE;
			ASSERT((pPapConn->papco_Flags & PAPCO_SENDDATA_RECD) == 0);
			pPapConn->papco_Flags 			|= PAPCO_SENDDATA_RECD;

			pPapConn->papco_pAtpResp		 = pAtpResp;

			//	The mac may not send its 'SendData' from its responding socket
			//	(the one we are tickling and have noted as papco_RemoteAddr), we need
			//	to address the response to the socket that the request originated on.
			pPapConn->papco_SendDataSrc		 = *pSrcAddr;

			DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_INFO,
					("atalkPapIncomingReq: send data src %lx.%lx.%lx\n",
					pSrcAddr->ata_Network, pSrcAddr->ata_Node, pSrcAddr->ata_Socket));

			//	remember send possible handler/context.
			sendPossibleHandler	= pPapConn->papco_pAssocAddr->papao_SendPossibleHandler;
			sendPossibleHandlerCtx = pPapConn->papco_pAssocAddr->papao_SendPossibleHandlerCtx;

			if (pPapConn->papco_Flags & PAPCO_WRITEDATA_WAITING)
			{
				// RELEASE_SPIN_LOCK_DPC(&pPapConn->papco_Lock);

				DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_INFO,
						("atalkPapIncomingReq: Posting send data resp\n"));

				// atalkPostSendDataResp() will release the conn lock
				atalkPapPostSendDataResp(pPapConn);
			}
			else
			{
				DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_INFO,
						("atalkPapIncomingReq: No WriteData waiting\n"));

				if (sendPossibleHandler != NULL)
				{
					(*sendPossibleHandler)(sendPossibleHandlerCtx,
										   pPapConn->papco_ConnCtx,
										   pPapConn->papco_SendFlowQuantum*PAP_MAX_DATA_PACKET_SIZE);
				}

				RELEASE_SPIN_LOCK_DPC(&pPapConn->papco_Lock);
			}
			break;

		  case PAP_CLOSE_CONN:
  			DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_INFO,
					("atalkPapIncomingReq: Close conn recvd. for connection %lx\n",
					pPapConn));

			ACQUIRE_SPIN_LOCK_DPC(&pPapConn->papco_Lock);
			pPapConn->papco_Flags |= (PAPCO_REMOTE_DISCONNECT | PAPCO_RECVD_DISCONNECT);
			RELEASE_SPIN_LOCK_DPC(&pPapConn->papco_Lock);

			//	Post the close connection reply.
			cancelResp	= FALSE;
			pUserBytes[PAP_CMDTYPE_OFF]	= PAP_CLOSE_CONN_REPLY;
			AtalkAtpPostResp(pAtpResp,
							 pSrcAddr,
							 NULL,		// Response buffer
							 0,
							 pUserBytes,
							 AtalkAtpGenericRespComplete,
							 pAtpResp);

			//	PapDisconnect will call the disconnect indication routine if set.
			AtalkPapDisconnect(pPapConn,
							   ATALK_REMOTE_DISCONNECT,
							   NULL,
							   NULL);
			break;

		  case PAP_TICKLE:
			//	We've already registered contact.
			// Cancel this response since we never respond to it and we want this to go away
			DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_INFO,
					("atalkPapIncomingReq: Recvd. tickle - resp %lx\n", pAtpResp));
			cancelResp = TRUE;
			break;

		  default:
			DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_ERR,
					("atalkPapIncomingReq: Invalid command %x\n", cmdType));
			cancelResp = TRUE;
			break;
		}
	} while (FALSE);

	if (cancelResp & (pAtpResp != NULL))
	{
		AtalkAtpCancelResp(pAtpResp);
	}

	if (DerefConn)
	{
		//	Remove reference added at the beginning.
		AtalkPapConnDereference(pPapConn);
	}
}




LOCAL VOID
atalkPapIncomingOpenReply(
	IN	ATALK_ERROR		ErrorCode,
	IN	PPAP_CONNOBJ	pPapConn,		// Our context
	IN	PAMDL			pReqAmdl,
	IN	PAMDL			pReadAmdl,
	IN	USHORT			ReadLen,
	IN	PBYTE			ReadUserBytes
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	ULONG					index;
	KIRQL					OldIrql;
	ATALK_ERROR				error;
	USHORT					statusLen, i, connectStatus;
	BYTE					userBytes[ATP_USERBYTES_SIZE];
	PBYTE					pRespPkt, pOpenPkt;
	PTDI_IND_SEND_POSSIBLE  sendPossibleHandler;
	PVOID   				sendPossibleHandlerCtx;
	PPAP_ADDROBJ			pPapAddr = pPapConn->papco_pAssocAddr;

	ASSERT(VALID_PAPCO(pPapConn));
	pRespPkt = pPapConn->papco_pConnectRespBuf;
	pOpenPkt = pPapConn->papco_pConnectOpenBuf;

	ASSERT(pRespPkt != NULL);
	ASSERT(pOpenPkt != NULL);

	if (ATALK_SUCCESS(ErrorCode))
	{
		//	Well, lets see what kind of response we got; take a look at both the
		//	response user-bytes and the response buffer.  Note that we now allow
		//	the LaserWriter IIg to leave the status string off altogether,
		//	rather than the [correct] zero-sized string.
		do
		{
			//	The reply length should be atleast the minimum and it should be
			// an open-reply we are looking at.
			if ((ReadLen < PAP_STATUS_OFF) ||
                (ReadUserBytes[PAP_CMDTYPE_OFF] != PAP_OPEN_CONNREPLY))
			{
				DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_ERR,
						("atalkPapIncomingOpenReply: Invalid read len or cmd %x/%x\n",
						ReadLen, ReadUserBytes[PAP_CMDTYPE_OFF]));

				ErrorCode = ATALK_REMOTE_CLOSE;
				break;
			}

			if (ReadLen == PAP_STATUS_OFF)
			{
				statusLen = 0;	//	Missing, from the LaserWriter IIg
			}
			else
			{
				//	Verify length.
				statusLen = pRespPkt[PAP_STATUS_OFF];
				if ((statusLen != 0) &&
					((statusLen + 1 + PAP_STATUS_OFF) > ReadLen))
				{
					DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_ERR,
							("atalkPapIncomingOpenReply: Invalid status len %lx\n", ReadLen));

					ErrorCode = ATALK_REMOTE_CLOSE;
					break;
				}
			}

			//	Check for connect result.
			GETSHORT2SHORT(&connectStatus, &pRespPkt[PAP_RESULT_OFF]);

			//	Check for open reply code in packet. Do not check the
			//	connectionid unless the response is success. Some rips
			//	are known to send a bogus connectionid if the return
			//	code is 'busy'.
			if ((connectStatus == 0) &&
				(ReadUserBytes[PAP_CONNECTIONID_OFF] != pPapConn->papco_ConnId))
			{
				DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_ERR,
						("atalkPapIncomingOpenReply: Invalid connid %x, expected %x\n",
						ReadUserBytes[PAP_CONNECTIONID_OFF], pPapConn->papco_ConnId));

				ErrorCode = ATALK_REMOTE_CLOSE;
				break;
			}

			if (connectStatus != 0)
			{
				ATALK_ERROR	ReconnectError;

				DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_WARN,
						("atalkPapIncomingOpenReply: server busy %lx\n", connectStatus));

				ErrorCode = ATALK_PAP_SERVER_BUSY;

				// If we have not yet reached the max. timeout, retry
				if (pPapConn->papco_WaitTimeOut < PAP_MAX_WAIT_TIMEOUT)
				{
					pPapConn->papco_WaitTimeOut ++;
					ReconnectError = atalkPapRepostConnect(pPapConn, pReqAmdl, pReadAmdl);
                    if (ATALK_SUCCESS(ReconnectError))
						return;		// Exit now
					DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_WARN,
							("atalkPapIncomingOpenReply: Post reconnect failed %lx\n", ReconnectError));
				}
				break;
			}

			//	Switch the socket of the remote address to be the one specified
			//	by the remote end.
			pPapConn->papco_RemoteAddr.ata_Socket 	= pRespPkt[PAP_RESP_SOCKET_OFF];
			pPapConn->papco_SendFlowQuantum			= pRespPkt[PAP_FLOWQUANTUM_OFF];
			if (pPapConn->papco_SendFlowQuantum > PAP_MAX_FLOW_QUANTUM)
			{
				pPapConn->papco_SendFlowQuantum = PAP_MAX_FLOW_QUANTUM;
			}

		} while (FALSE);

		if (ATALK_SUCCESS(ErrorCode))
		{
			//	Build up userBytes to start tickling the other end.
			userBytes[PAP_CONNECTIONID_OFF] = pPapConn->papco_ConnId;
			userBytes[PAP_CMDTYPE_OFF] 		= PAP_TICKLE;
			PUTSHORT2SHORT(&userBytes[PAP_SEQNUM_OFF], 0);

			DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_INFO,
					("atalkPapIncomingOpenReply: id %lx Rem %lx.%lx.%lx RespSkt %lx\n",
					pPapConn->papco_ConnId, pPapConn->papco_RemoteAddr.ata_Network,
					pPapConn->papco_RemoteAddr.ata_Node, pPapConn->papco_RemoteAddr.ata_Socket,
					PAPCONN_DDPSOCKET(pPapConn)));

			error = AtalkAtpPostReq(pPapConn->papco_pAtpAddr,
									&pPapConn->papco_RemoteAddr,
									&pPapConn->papco_TickleTid,
									0,						// ALO transaction
									NULL,
									0,
									userBytes,
									NULL,
									0,
									ATP_INFINITE_RETRIES,
									PAP_TICKLE_INTERVAL,
									THIRTY_SEC_TIMER,
									NULL,
									NULL);

			ASSERT(ATALK_SUCCESS(error));

			index = PAP_HASH_ID_ADDR(pPapConn->papco_ConnId, &pPapConn->papco_RemoteAddr);

			//	Move the connection from the connect list to the active list.
			ACQUIRE_SPIN_LOCK(&pPapAddr->papao_Lock, &OldIrql);
			ACQUIRE_SPIN_LOCK_DPC(&pPapConn->papco_Lock);

			//	Make sure flags are clean.
			pPapConn->papco_Flags			   &= ~(PAPCO_SENDDATA_RECD		|
													PAPCO_WRITEDATA_WAITING	|
													PAPCO_SEND_EOF_WRITE   	|
													PAPCO_READDATA_PENDING 	|
													PAPCO_REMOTE_CLOSE	 	|
													PAPCO_NONBLOCKING_READ 	|
													PAPCO_READDATA_WAITING);

			pPapConn->papco_Flags &= ~PAPCO_CONNECTING;
			pPapConn->papco_Flags |= PAPCO_ACTIVE;
			atalkPapConnDeQueueConnectList(pPapAddr, pPapConn);

			//	Thread the connection object into addr lookup by session id.
			pPapConn->papco_pNextActive	 = pPapAddr->papao_pActiveHash[index];
			pPapAddr->papao_pActiveHash[index]	= pPapConn;

			//	Reference for the request handler
			AtalkPapConnReferenceByPtrNonInterlock(pPapConn, &error);

			//	Call the send data event handler on the associated address with
			//	0 to turn off selects on writes. We do this before we post any
			//	get requests, so there is no race condition.
			//	remember send possible handler/context.
			sendPossibleHandler	= pPapAddr->papao_SendPossibleHandler;
			sendPossibleHandlerCtx = pPapAddr->papao_SendPossibleHandlerCtx;

			RELEASE_SPIN_LOCK_DPC(&pPapConn->papco_Lock);
			RELEASE_SPIN_LOCK(&pPapAddr->papao_Lock, OldIrql);

			if (sendPossibleHandler != NULL)
			{
				(*sendPossibleHandler)(sendPossibleHandlerCtx,
									   pPapConn->papco_ConnCtx,
									   0);
			}

			//	Set the request handler on this connection.
			//	It will handle tickle's, close's and sendData's.

			AtalkAtpSetReqHandler(pPapConn->papco_pAtpAddr,
								  atalkPapIncomingReq,
								  pPapConn);

			pPapConn->papco_LastContactTime	= AtalkGetCurrentTick();
		}
		else
		{
			DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_ERR,
					("atalkPapIncomingOpenReply: Incoming connect fail %lx\n", ErrorCode));

			//	Move the connection out of the connect list.
			ACQUIRE_SPIN_LOCK(&pPapAddr->papao_Lock, &OldIrql);
			ACQUIRE_SPIN_LOCK_DPC(&pPapConn->papco_Lock);
			pPapConn->papco_Flags &= ~PAPCO_CONNECTING;
			atalkPapConnDeQueueConnectList(pPapAddr, pPapConn);
			RELEASE_SPIN_LOCK_DPC(&pPapConn->papco_Lock);
			RELEASE_SPIN_LOCK(&pPapAddr->papao_Lock, OldIrql);
		}
	}
	else
	{
		//	Move the connection out of the connect list.
		ACQUIRE_SPIN_LOCK(&pPapAddr->papao_Lock, &OldIrql);
		ACQUIRE_SPIN_LOCK_DPC(&pPapConn->papco_Lock);
		atalkPapConnDeQueueConnectList(pPapAddr, pPapConn);
		pPapConn->papco_Flags &= ~PAPCO_CONNECTING;
		RELEASE_SPIN_LOCK_DPC(&pPapConn->papco_Lock);
		RELEASE_SPIN_LOCK(&pPapAddr->papao_Lock, OldIrql);
	}

	//	Free the buffers.
	AtalkFreeMemory(pRespPkt);
	AtalkFreeMemory(pOpenPkt);
	AtalkFreeAMdl(pReadAmdl);
	AtalkFreeAMdl(pReqAmdl);

	//	Call the completion routine.
	(*pPapConn->papco_ConnectCompletion)(ErrorCode, pPapConn->papco_ConnectCtx);

	//	Remove reference for this handler.
	AtalkPapConnDereference(pPapConn);
}




LOCAL VOID FASTCALL
atalkPapIncomingRel(
	IN	ATALK_ERROR			ErrorCode,
	IN	PPAP_OPEN_REPLY_REL	pOpenReply
	)
/*++

Routine Description:

 	Handler for incoming release for reply

Arguments:


Return Value:


--*/
{
	KIRQL			OldIrql;

	DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_INFO,
			("atalkPapIncomingRel: Called %lx for pOpenReply %lx\n",
			ErrorCode, pOpenReply));

	ASSERT(pOpenReply != NULL);
	ASSERT(pOpenReply->papor_pRespAmdl != NULL);

	// Dereference the atp response structure now
	AtalkAtpRespDereference(pOpenReply->papor_pAtpResp);

	AtalkFreeAMdl(pOpenReply->papor_pRespAmdl);
	AtalkFreeMemory(pOpenReply);
}




LOCAL VOID FASTCALL
atalkPapStatusRel(
	IN	ATALK_ERROR				ErrorCode,
	IN	PPAP_SEND_STATUS_REL	pSendSts
	)
/*++

Routine Description:

 	Handler for incoming release for reply

Arguments:


Return Value:


--*/
{
	KIRQL		OldIrql;

	UNREFERENCED_PARAMETER(ErrorCode);

	ASSERT(pSendSts != NULL);
	ASSERT(pSendSts->papss_pAmdl != NULL);

	// Dereference the atp response structure now
	AtalkAtpRespDereference(pSendSts->papss_pAtpResp);

	AtalkPapAddrDereference(pSendSts->papss_pPapAddr);
	AtalkFreeAMdl(pSendSts->papss_pAmdl);
	AtalkFreeMemory(pSendSts);
}



#define		SLS_OPEN_RESP_SOCKET		0x0001
#define		SLS_OPEN_RESP_PKT			0x0002
#define		SLS_OPEN_RESP_MDL			0x0004
#define		SLS_OPEN_CONN_REF			0x0008
#define		SLS_ACCEPT_IRP				0x0010
#define		SLS_CONN_REQ_REFS			0x0020
#define		SLS_CONN_TIMER_REF			0x0040
#define		SLS_LISTEN_DEQUEUED			0x0080

BOOLEAN
atalkPapConnAccept(
	IN	PPAP_ADDROBJ		pPapAddr,		// Listener
	IN	PATALK_ADDR			pSrcAddr,		// Address of requestor
	IN	PBYTE				pPkt,
	IN	BYTE				ConnId,
	IN	PATP_RESP			pAtpResp
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	ATALK_ERROR				tmpError;
	BYTE					userBytes[ATP_USERBYTES_SIZE];
	PBYTE					pRespPkt;
	PAMDL					pRespAmdl;
	PATP_ADDROBJ			pRespondingAtpAddr;
	PPAP_CONNOBJ			pPapConn;
	ULONG					index;
	SHORT					respLen, i;
	PPAP_OPEN_REPLY_REL		pOpenReply;
	GENERIC_COMPLETION		listenCompletion;
	PVOID					listenCtx;
	KIRQL					OldIrql;
	PIRP					acceptIrp;
	PTDI_IND_SEND_POSSIBLE  sendPossibleHandler;
	PVOID   				sendPossibleHandlerCtx;

	USHORT					openResr	= 0;
	ATALK_ERROR				error 		= ATALK_NO_ERROR;
	BOOLEAN					indicate  	= FALSE;
	BOOLEAN					relAddrLock	= FALSE;
	BOOLEAN					DerefAddr	= FALSE;
	BOOLEAN					sendOpenErr	= FALSE;

	//	Get a buffer we can send the response with.
	if ((pOpenReply = (PPAP_OPEN_REPLY_REL)
						AtalkAllocMemory(sizeof(PAP_OPEN_REPLY_REL))) == NULL)
	{
		DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_ERR,
				("atalkPapConnAccept: Could not allocate resp packet\n"));
		return FALSE;
	}

	//	NOTE! pOpenReply contains a max sized packet. Get a ptr to work with.
	pRespPkt 	 = pOpenReply->papor_pRespPkt;
	openResr	|= SLS_OPEN_RESP_PKT;

	//	Build up the response packet. If we encounter an error later on,
	//	just set the error code in packet.
	userBytes[PAP_CONNECTIONID_OFF] = ConnId;
	userBytes[PAP_CMDTYPE_OFF] 		= PAP_OPEN_CONNREPLY;
	PUTSHORT2SHORT(&userBytes[PAP_SEQNUM_OFF], PAP_NO_ERROR);

	//	!!!NOTE!!!
	//	The socket will be set after the connection is determined.
	//	This will only happen in the non-error case.

	pRespPkt[PAP_FLOWQUANTUM_OFF]	= PAP_MAX_FLOW_QUANTUM;
	PUTSHORT2SHORT(&pRespPkt[PAP_RESULT_OFF], 0);

	ACQUIRE_SPIN_LOCK(&pPapAddr->papao_Lock, &OldIrql);
	relAddrLock = TRUE;

	do
	{
		//	We need to put in the status with the spinlock of the
		//	address object held.
		pRespPkt[PAP_STATUS_OFF] = (BYTE)pPapAddr->papao_StatusSize;
		ASSERT((pPapAddr->papao_StatusSize  >= 0) &&
			   (pPapAddr->papao_StatusSize <= PAP_MAX_STATUS_SIZE));

		if (pPapAddr->papao_StatusSize > 0)
		{
			ASSERT(pPapAddr->papao_pStatusBuf != NULL);
			RtlCopyMemory(pRespPkt+PAP_STATUS_OFF+1,
						  pPapAddr->papao_pStatusBuf,
						  pPapAddr->papao_StatusSize);
		}

		respLen = PAP_STATUS_OFF + pPapAddr->papao_StatusSize + 1;
		ASSERT(respLen <= PAP_MAX_DATA_PACKET_SIZE);

		//	Build an mdl for the length that we are using.
		if ((pRespAmdl = AtalkAllocAMdl(pRespPkt, respLen)) == NULL)
		{
			error = ATALK_RESR_MEM;
			break;
		}

		pOpenReply->papor_pRespAmdl = pRespAmdl;
		pOpenReply->papor_pAtpResp = pAtpResp;
		openResr	|= SLS_OPEN_RESP_MDL;

		//	Send an open status whatever happens now. If ATALK_SUCCESS(error)
		//	we send out a connection accept packets. Assume blocked. If
		//	unblocked and we are able to get a connection object, error will
		//	be set to success.
		sendOpenErr  = TRUE;
		error 		 = ATALK_RESR_MEM;

		//	If PapUnblockedState - either there is a GetNextJob posted, or
		//	an incoming event handler is set on the listener.
		if (pPapAddr->papao_Flags & PAPAO_UNBLOCKED)
		{
			PTDI_IND_CONNECT		indicationRoutine;
			PVOID					indicationCtx;
			NTSTATUS				status;
			CONNECTION_CONTEXT  	ConnCtx;
			TA_APPLETALK_ADDRESS	tdiAddr;

			//	either a getnextjob() or a listener is set.
			//	depending on which one it is, dequeue or remember the listener.
			if (pPapAddr->papao_pListenConn != NULL)
			{
				//	There a connection with a pending listen. use it.
				pPapConn = pPapAddr->papao_pListenConn;
				if (((pPapAddr->papao_pListenConn = pPapConn->papco_pNextListen) == NULL) &&
					(pPapAddr->papao_ConnHandler == NULL))
				{
					//	We have no more listens pending! No event handler either.
					pPapAddr->papao_Flags &= ~PAPAO_UNBLOCKED;
#if DBG
					pPapAddr->papao_Flags |= PAPAO_BLOCKING;
#endif
				}

				ASSERT(VALID_PAPCO(pPapConn));

				//	Reference the connection object with a listen posted on it.
				AtalkPapConnReferenceByPtrDpc(pPapConn, &error);
				if (!ATALK_SUCCESS(error))
				{
					break;
				}

				//	Get the listen completion information
				listenCompletion 	= pPapConn->papco_ListenCompletion;
				listenCtx			= pPapConn->papco_ListenCtx;

				openResr	|= (SLS_OPEN_CONN_REF | SLS_LISTEN_DEQUEUED);
			}
			else if ((indicationRoutine = pPapAddr->papao_ConnHandler) != NULL)
			{
				indicationCtx	= pPapAddr->papao_ConnHandlerCtx;
				indicate 		= TRUE;

				//	Convert remote atalk address to tdi address
				ATALKADDR_TO_TDI(&tdiAddr, pSrcAddr);

				RELEASE_SPIN_LOCK(&pPapAddr->papao_Lock, OldIrql);
				relAddrLock = FALSE;

				acceptIrp = NULL;
				status = (*indicationRoutine)(indicationCtx,
											  sizeof(tdiAddr),
											  (PVOID)&tdiAddr,
											  0,			// User data length
											  NULL,			// User data
											  0,			// Option length
											  NULL,			// Options
											  &ConnCtx,
											  &acceptIrp);

				DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_INFO,
						("atalkPapConnAccept: indicate status %lx\n", status));

				if (status == STATUS_MORE_PROCESSING_REQUIRED)
				{
				    ASSERT(acceptIrp != NULL);

					if (acceptIrp != NULL)
					{
						openResr	|= SLS_ACCEPT_IRP;
					}

					//  Find the connection and accept the connection using that
					//	connection object.
					ACQUIRE_SPIN_LOCK(&pPapAddr->papao_Lock, &OldIrql);
					relAddrLock = TRUE;

					AtalkPapConnReferenceByCtxNonInterlock(pPapAddr,
														   ConnCtx,
														   &pPapConn,
														   &error);
					if (!ATALK_SUCCESS(error))
					{
						break;
					}
					openResr	|= SLS_OPEN_CONN_REF;
				}
				else
				{
					ASSERT(acceptIrp == NULL);
					error 	= ATALK_RESR_MEM;
					break;
				}
			}
			else
			{
				//	The UNBLOCKED bit was set.
				ASSERT(0);
				KeBugCheck(0);
			}
		}

		if (openResr & SLS_OPEN_CONN_REF)
		{
			if (relAddrLock)
			{
				RELEASE_SPIN_LOCK(&pPapAddr->papao_Lock, OldIrql);
				relAddrLock = FALSE;
			}

			DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_INFO,
					("atalkPapConnAccept: Creating an Atp address\n"));

			//	Now on NT, we will mostly (always) be using the indication, as PAP
			//	will be exposed only through winsock.
			error = AtalkAtpOpenAddress(AtalkDefaultPort,
										0,
										NULL,
										PAP_MAX_DATA_PACKET_SIZE,
										PAP_SEND_USER_BYTES_ALL,
										NULL,
										TRUE,		// CACHE address
										&pRespondingAtpAddr);

			if (!ATALK_SUCCESS(error))
			{
				DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_ERR,
						("atalkPapConnAccept: Error open atp resp socket %lx\n", error));
				break;
			}
			openResr	|= SLS_OPEN_RESP_SOCKET;

			//	Common for both listen and indicate. The connection object
			//	should be referenced.

			//	Store the information in the connection structure given by
			//	the connection object thats passed back in the indication
			//	or is part of the getnextjob structure.

			pPapConn->papco_Flags	   	   |= PAPCO_SERVER_JOB;
			pPapConn->papco_RemoteAddr   	= *pSrcAddr;
			pPapConn->papco_RemoteAddr.ata_Socket = pPkt[PAP_RESP_SOCKET_OFF];
			pPapConn->papco_ConnId			= ConnId;
			pPapConn->papco_SendFlowQuantum	= pPkt[PAP_FLOWQUANTUM_OFF];
			pPapConn->papco_LastContactTime = AtalkGetCurrentTick();

			DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_INFO,
					("atalkPapConnAccept: ConnId %lx Rem %lx.%lx.%lx\n",
					ConnId, pSrcAddr->ata_Network, pSrcAddr->ata_Node,
					pPkt[PAP_RESP_SOCKET_OFF]));

			ASSERT(pPapConn->papco_SendFlowQuantum > 0);

			if (pPapConn->papco_SendFlowQuantum > PAP_MAX_FLOW_QUANTUM)
				pPapConn->papco_SendFlowQuantum = PAP_MAX_FLOW_QUANTUM;

			//	Thread the connection object into addr lookup by session id.
			index = PAP_HASH_ID_ADDR(ConnId, &pPapConn->papco_RemoteAddr);

			ACQUIRE_SPIN_LOCK(&pPapAddr->papao_Lock, &OldIrql);
			relAddrLock = TRUE;

			ACQUIRE_SPIN_LOCK_DPC(&pPapConn->papco_Lock);

			//	Try to reference the connection for the request handler that we
			//	are going to set
			AtalkPapConnReferenceByPtrNonInterlock(pPapConn, &error);

			if (!ATALK_SUCCESS(error))
			{
				ASSERT(0);

				RELEASE_SPIN_LOCK_DPC(&pPapConn->papco_Lock);
				break;
			}

			openResr	|= (SLS_CONN_REQ_REFS | SLS_CONN_TIMER_REF);

			// The connection object could be re-used by AFD. Make sure it is
			// in the right state
			pPapConn->papco_NextOutgoingSeqNum = 1;				// Set to 1, not 0.
			pPapConn->papco_NextIncomingSeqNum = 1;				// Next expected incoming.
			AtalkInitializeRT(&pPapConn->papco_RT,
							  PAP_INIT_SENDDATA_REQ_INTERVAL,
							  PAP_MIN_SENDDATA_REQ_INTERVAL,
							  PAP_MAX_SENDDATA_REQ_INTERVAL);
			pPapConn->papco_Flags &= ~(PAPCO_LISTENING			|
									   PAPCO_DELAYED_DISCONNECT |
                                       PAPCO_DISCONNECTING		|
									   PAPCO_RECVD_DISCONNECT	|
									   PAPCO_LOCAL_DISCONNECT	|
									   PAPCO_REMOTE_DISCONNECT	|
									   PAPCO_SENDDATA_RECD		|
									   PAPCO_WRITEDATA_WAITING	|
									   PAPCO_SEND_EOF_WRITE		|
									   PAPCO_READDATA_PENDING	|
                                       PAPCO_NONBLOCKING_READ	|
                                       PAPCO_READDATA_WAITING	|
#if DBG
                                       PAPCO_CLEANUP			|
                                       PAPCO_INDICATE_AFD_DISC	|
#endif
                                       PAPCO_REMOTE_CLOSE);

			pPapConn->papco_Flags |= PAPCO_ACTIVE;
			pPapConn->papco_pNextActive = pPapAddr->papao_pActiveHash[index];
			pPapAddr->papao_pActiveHash[index] = pPapConn;

			//	Remember the responding socket.
			pPapConn->papco_pAtpAddr = pRespondingAtpAddr;

			//	Set the socket in the packet we'll be sending.
			pRespPkt[PAP_RESP_SOCKET_OFF]	= PAPCONN_DDPSOCKET(pPapConn);

			//	Call the send data event handler on the associated address with
			//	0 to turn off selects on writes. We do this before we post any
			//	get requests, so there is no race condition.
			//	remember send possible handler/context.
			sendPossibleHandler	= pPapAddr->papao_SendPossibleHandler;
			sendPossibleHandlerCtx = pPapAddr->papao_SendPossibleHandlerCtx;

			RELEASE_SPIN_LOCK_DPC(&pPapConn->papco_Lock);
		}
	} while (FALSE);

	if (relAddrLock)
	{
		RELEASE_SPIN_LOCK(&pPapAddr->papao_Lock, OldIrql);
	}

	//	This reference needs to go regardless.
	if (openResr & SLS_OPEN_CONN_REF)
	{
		//	Remove the reference for the listen dequeued/indication accept.
		AtalkPapConnDereference(pPapConn);
	}

	if (sendOpenErr)
	{
		if (!ATALK_SUCCESS(error))
		{
			//	Send error status.
			PUTSHORT2SHORT(&pRespPkt[PAP_RESULT_OFF], PAP_PRINTER_BUSY);
		}
		else
		{
			//	Set the request handler on this connection. It will handle
			//	tickle's, close's and sendData's. Do this before we send
			//	the open reply so that we dont miss the first send data.
			openResr 	&= ~SLS_CONN_REQ_REFS;
			AtalkAtpSetReqHandler(pPapConn->papco_pAtpAddr,
								  atalkPapIncomingReq,
								  pPapConn);
		}

		if (ATALK_SUCCESS(AtalkAtpPostResp(pAtpResp,
										   pSrcAddr,
										   pRespAmdl,
										   respLen,
										   userBytes,
										   atalkPapIncomingRel,
										   pOpenReply)))
		{
			//	We want the completion to free up the buffer/mdl.
			openResr   &= ~(SLS_OPEN_RESP_PKT | SLS_OPEN_RESP_MDL);
		}
	}


	if (ATALK_SUCCESS(error))
	{
		//	We better have sent the open reply.
		ASSERT(sendOpenErr);
		ASSERT(VALID_ATPAO(pPapConn->papco_pAtpAddr));

		if ((openResr & (SLS_ACCEPT_IRP & SLS_OPEN_CONN_REF)) ==
						(SLS_ACCEPT_IRP & SLS_OPEN_CONN_REF))
		{
			//	Only if we got a referenced connection through an accept
			//	do we call the send possible.
			if (sendPossibleHandler != NULL)
			{
				(*sendPossibleHandler)(sendPossibleHandlerCtx,
									   pPapConn->papco_ConnCtx,
									   0);
			}
		}

		//	Build up userBytes to start tickling the other end.
		userBytes[PAP_CONNECTIONID_OFF] = ConnId;
		userBytes[PAP_CMDTYPE_OFF] 		= PAP_TICKLE;
		PUTSHORT2SHORT(&userBytes[PAP_SEQNUM_OFF], 0);

		tmpError = AtalkAtpPostReq(pPapConn->papco_pAtpAddr,
									&pPapConn->papco_RemoteAddr,
									&pPapConn->papco_TickleTid,
									0,						// AtLeastOnce
									NULL,
									0,
									userBytes,
									NULL,
									0,
									ATP_INFINITE_RETRIES,
									PAP_TICKLE_INTERVAL,
									THIRTY_SEC_TIMER,
									NULL,
									NULL);

		ASSERT(ATALK_SUCCESS(tmpError));

		pPapConn->papco_LastContactTime	= AtalkGetCurrentTick();
	}
	else
	{
		//	Release all resources
		if (openResr & SLS_OPEN_RESP_SOCKET)
		{
			AtalkAtpCloseAddress(pRespondingAtpAddr, NULL, NULL);
		}

		if (openResr & SLS_OPEN_RESP_MDL)
		{
			AtalkFreeAMdl(pOpenReply->papor_pRespAmdl);
		}

		if (openResr & SLS_OPEN_RESP_PKT)
		{
			AtalkFreeMemory(pOpenReply);
		}

		if (openResr & SLS_CONN_TIMER_REF)
		{
			AtalkPapConnDereference(pPapConn);
		}
	}

	if (openResr & SLS_LISTEN_DEQUEUED)
	{
		ASSERT(!indicate);
		ASSERT(listenCompletion != NULL);
		(*listenCompletion)(error, listenCtx);
	}

	if (openResr & SLS_ACCEPT_IRP)
	{
		acceptIrp->IoStatus.Information = 0;
		ASSERT (error != ATALK_PENDING);

		TdiCompleteRequest(acceptIrp, AtalkErrorToNtStatus(error));
	}

	return sendOpenErr;
}




LOCAL LONG FASTCALL
atalkPapConnMaintenanceTimer(
	IN	PTIMERLIST		pTimer,
	IN	BOOLEAN			TimerShuttingDown
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PPAP_CONNOBJ	pPapConn;
	ATALK_ERROR		error;
	BOOLEAN			Close;

	DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_INFO,
			("atalkPapConnMaintenanceTimer: Entered \n"));

	if (TimerShuttingDown)
		return ATALK_TIMER_NO_REQUEUE;

	ACQUIRE_SPIN_LOCK_DPC(&atalkPapLock);

	// Walk the list of connections on the global list and shut down
	// ones that have not tickle'd for a while
	for (pPapConn = atalkPapConnList; pPapConn != NULL; NOTHING)
	{
		ASSERT(VALID_PAPCO(pPapConn));
		Close = FALSE;

		ACQUIRE_SPIN_LOCK_DPC(&pPapConn->papco_Lock);

		if (((pPapConn->papco_Flags & (PAPCO_ACTIVE				|
									   PAPCO_CLOSING			|
									   PAPCO_STOPPING			|
									   PAPCO_DELAYED_DISCONNECT	|
									   PAPCO_DISCONNECTING)) == PAPCO_ACTIVE) &&
			((AtalkGetCurrentTick() - pPapConn->papco_LastContactTime) > PAP_CONNECTION_INTERVAL))
		{
			//	Connection has expired.
			DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_ERR,
					("atalkPapConnMaintenanceTimer: Connection %lx.%lx expired\n",
					pPapConn, pPapConn->papco_ConnId));
			Close = TRUE;
		}

		RELEASE_SPIN_LOCK_DPC(&pPapConn->papco_Lock);

		if (Close)
		{
			AtalkPapConnReferenceByPtrDpc(pPapConn, &error);
			if (ATALK_SUCCESS(error))
			{
				RELEASE_SPIN_LOCK_DPC(&atalkPapLock);
				AtalkPapDisconnect(pPapConn,
								   ATALK_TIMER_DISCONNECT,
								   NULL,
								   NULL);
				AtalkPapConnDereference(pPapConn);
				ACQUIRE_SPIN_LOCK_DPC(&atalkPapLock);
				pPapConn = atalkPapConnList;
			}
		}

		if (!Close)
		{
			pPapConn = pPapConn->papco_Next;
		}
	}

	RELEASE_SPIN_LOCK_DPC(&atalkPapLock);

	return ATALK_TIMER_REQUEUE;
}



LOCAL BYTE
atalkPapGetNextConnId(
	IN	PPAP_ADDROBJ	pPapAddr,
	OUT	PATALK_ERROR	pError
	)
/*++

Routine Description:

	CALLED WITH THE ADDRESS SPIN LOCK HELD!

Arguments:


Return Value:


--*/
{
	PPAP_CONNOBJ	pPapConn;
	USHORT			i;
	BYTE			startConnId, connId;
	ATALK_ERROR		error = ATALK_NO_ERROR;

	startConnId = connId = ++pPapAddr->papao_NextConnId;
	while (TRUE)
	{
		for (i = 0; i < PAP_CONN_HASH_SIZE; i++)
		{
			for (pPapConn = pPapAddr->papao_pActiveHash[i];
				 ((pPapConn != NULL) && (pPapConn->papco_ConnId != connId));
				 pPapConn = pPapConn->papco_pNextActive)
				 NOTHING;

			if (pPapConn != NULL)
				break;
		}

		if (pPapConn == NULL)
		{
			pPapAddr->papao_NextConnId = connId+1;
			break;
		}
		else
		{
			if (connId == (startConnId - 1))
			{
				ASSERT(0);

				//	We wrapped around and there are no more conn ids.
				error = ATALK_RESR_MEM;
				break;
			}
			connId++;
		}
	}

	*pError = error;

	return(ATALK_SUCCESS(error) ? connId : 0);
}




LOCAL	VOID
atalkPapQueueAddrGlobalList(
	IN	PPAP_ADDROBJ	pPapAddr
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	KIRQL	OldIrql;

	ACQUIRE_SPIN_LOCK(&atalkPapLock, &OldIrql);
	AtalkLinkDoubleAtHead(atalkPapAddrList, pPapAddr, papao_Next, papao_Prev);
	RELEASE_SPIN_LOCK(&atalkPapLock, OldIrql);
}


LOCAL	VOID
atalkPapConnDeQueueAssocList(
	IN	PPAP_ADDROBJ	pPapAddr,
	IN	PPAP_CONNOBJ	pPapConn
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PPAP_CONNOBJ	pPapRemConn, *ppPapRemConn;

	for (ppPapRemConn = &pPapAddr->papao_pAssocConn;
		 ((pPapRemConn = *ppPapRemConn) != NULL);
		 NOTHING)
	{
		if (pPapRemConn == pPapConn)
		{
			*ppPapRemConn = pPapConn->papco_pNextAssoc;
			break;
		}
		ppPapRemConn = &pPapRemConn->papco_pNextAssoc;
	}
}




LOCAL	VOID
atalkPapConnDeQueueConnectList(
	IN	PPAP_ADDROBJ	pPapAddr,
	IN	PPAP_CONNOBJ	pPapConn
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PPAP_CONNOBJ	pPapRemConn, *ppPapRemConn;

	ASSERT(pPapAddr->papao_Flags & PAPAO_CONNECT);

	for (ppPapRemConn = &pPapAddr->papao_pConnectConn;
		 ((pPapRemConn = *ppPapRemConn) != NULL);
		 NOTHING)
	{
		if (pPapRemConn == pPapConn)
		{
			*ppPapRemConn = pPapConn->papco_pNextConnect;

			DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_INFO,
					("atalkPapConnDeQueueConnectList: Removed connect conn %lx\n", pPapConn));
			break;
		}
		ppPapRemConn = &pPapRemConn->papco_pNextConnect;
	}
}




LOCAL	BOOLEAN
atalkPapConnDeQueueListenList(
	IN	PPAP_ADDROBJ	pPapAddr,
	IN	PPAP_CONNOBJ	pPapConn
	)
/*++

Routine Description:

	!!!MUST BE CALLED WITH PAP ADDRESS LOCK HELD!!!

Arguments:


Return Value:


--*/
{
	PPAP_CONNOBJ	pPapRemConn, *ppPapRemConn;
	BOOLEAN			removed = FALSE;

	ASSERT(pPapAddr->papao_Flags & PAPAO_LISTENER);

	for (ppPapRemConn = &pPapAddr->papao_pListenConn;
		 ((pPapRemConn = *ppPapRemConn) != NULL);
		 NOTHING)
	{
		if (pPapRemConn == pPapConn)
		{
			removed = TRUE;
			*ppPapRemConn = pPapConn->papco_pNextListen;

			//	If no more listens, then we set the address object to blocked
			//	state.
			if ((pPapAddr->papao_pListenConn == NULL) &&
				(pPapAddr->papao_ConnHandler == NULL))
			{
				pPapAddr->papao_Flags	&= ~PAPAO_UNBLOCKED;
#if DBG
				pPapAddr->papao_Flags |= PAPAO_BLOCKING;
#endif
			}

			DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_INFO,
					("atalkPapConnDeQueueListenList: Removed listen conn %lx\n", pPapConn));
			break;
		}
		ppPapRemConn = &pPapRemConn->papco_pNextListen;
	}

	return removed;
}




LOCAL	VOID
atalkPapConnDeQueueActiveList(
	IN	PPAP_ADDROBJ	pPapAddr,
	IN	PPAP_CONNOBJ	pPapConn
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PPAP_CONNOBJ	pPapRemConn, *ppPapRemConn;
	ULONG			index;

	index = PAP_HASH_ID_ADDR(pPapConn->papco_ConnId, &pPapConn->papco_RemoteAddr);

	for (ppPapRemConn = &pPapAddr->papao_pActiveHash[index];
		 ((pPapRemConn = *ppPapRemConn) != NULL);
		 NOTHING)
	{
		if (pPapRemConn == pPapConn)
		{
			*ppPapRemConn = pPapConn->papco_pNextActive;

			DBGPRINT(DBG_COMP_PAP, DBG_LEVEL_INFO,
					("atalkPapConnDeQueueActiveList: Removed active conn %lx\n", pPapConn));
			break;
		}
		ppPapRemConn = &pPapRemConn->papco_pNextActive;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\atalk\sys\ports.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

	ports.c

Abstract:

	This module contains the port management code.

Author:

	Jameel Hyder (jameelh@microsoft.com)
	Nikhil Kamkolkar (nikhilk@microsoft.com)

Revision History:
	19 Jun 1992		Initial Version

Notes:	Tab stop: 4
--*/

#include <atalk.h>
#pragma hdrstop
#define	FILENUM	PORTS

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGEINIT, AtalkPortShutdown)
#pragma alloc_text(PAGEINIT, atalkPortFreeZones)
#endif

VOID FASTCALL
AtalkPortDeref(
	IN	OUT	PPORT_DESCRIPTOR	pPortDesc,
	IN	BOOLEAN					AtDpc
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	BOOLEAN				portDone	= FALSE;
    BOOLEAN             fPnPInProgress;
    BOOLEAN             fRasPort;
	KIRQL				OldIrql;

	if (AtDpc)
	{
		ACQUIRE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);
	}
	else
	{
		ACQUIRE_SPIN_LOCK(&pPortDesc->pd_Lock, &OldIrql);
	}

	ASSERT(pPortDesc->pd_RefCount > 0);
	pPortDesc->pd_RefCount--;
	if (pPortDesc->pd_RefCount == 0)
	{
		portDone	= TRUE;

		ASSERT((pPortDesc->pd_Flags & PD_CLOSING) != 0);
	}

    fPnPInProgress = (pPortDesc->pd_Flags & PD_PNP_RECONFIGURE)? TRUE : FALSE;

	//	We hold the lock while freeing up all the stuff, this should
	//	only happen during unload.
	if (portDone)
	{
		DBGPRINT(DBG_COMP_UNLOAD, DBG_LEVEL_WARN,
				("AtalkPortDeref: Freeing zones and such ...\n"));
	
		//	Free up zonelist
		atalkPortFreeZones(pPortDesc);
	
		DBGPRINT(DBG_COMP_UNLOAD, DBG_LEVEL_WARN,
				("AtalkPortDeref: Releasing Amt tables ...\n"));

		// We do need to free up the AMT.
		AtalkAarpReleaseAmt(pPortDesc);

		// Free the BRC
		AtalkAarpReleaseBrc(pPortDesc);
	}

	if (AtDpc)
	{
		RELEASE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);
	}
	else
	{
		RELEASE_SPIN_LOCK(&pPortDesc->pd_Lock, OldIrql);
	}

	if (portDone)
	{
		PPORT_DESCRIPTOR	*ppTmp;

		// Unlink the portdesc from the list and free its memory
		ACQUIRE_SPIN_LOCK(&AtalkPortLock, &OldIrql);

		for (ppTmp = &AtalkPortList;
			 *ppTmp != NULL;
			 ppTmp = &((*ppTmp)->pd_Next))
		{
			if (*ppTmp == pPortDesc)
			{
				*ppTmp = pPortDesc->pd_Next;
				break;
			}
		}

		ASSERT (*ppTmp == pPortDesc->pd_Next);

		// Is the default-port going away ?
		if (AtalkDefaultPort == pPortDesc)
		{
			AtalkDefaultPort = NULL;
			KeResetEvent(&AtalkDefaultPortEvent);
		}

		RELEASE_SPIN_LOCK(&AtalkPortLock, OldIrql);

        //
        // if we are here becaue of PnP Reconfigure then don't free the memory
        // (we haven't closed the adapter with ndis, and we have other useful
        // stuff that we must retain).  Put the creation refcount and the
        // binding refcount back that got taken away when we first got the
        // PnP Reconfigure event.
        // (no need for spinlock: this was ready for a free!!)
        //
        if (fPnPInProgress)
        {
            // 1 binding refcount + 1 creation refcount
            pPortDesc->pd_RefCount = 2;

            if (pPortDesc->pd_Flags & PD_RAS_PORT)
            {
                fRasPort = TRUE;
            }
            else
            {
                fRasPort = FALSE;
            }

            // blow away everything on the flag, except these
			pPortDesc->pd_Flags = (PD_PNP_RECONFIGURE | PD_BOUND);

            if (fRasPort)
            {
                pPortDesc->pd_Flags |= PD_RAS_PORT;
            }

            // restore EXT_NET flag if applicable
            if (pPortDesc->pd_PortType != ALAP_PORT)
            {
                pPortDesc->pd_Flags |= PD_EXT_NET;
            }

            // reset all pointers and other gunk to 0
            pPortDesc->pd_Next = NULL;
            pPortDesc->pd_Nodes = NULL;
            pPortDesc->pd_RouterNode = NULL;
            pPortDesc->pd_TentativeNodeAddr.atn_Network = 0;
            pPortDesc->pd_TentativeNodeAddr.atn_Node = 0;
            pPortDesc->pd_RoutersPramNode.atn_Network = 0;
            pPortDesc->pd_RoutersPramNode.atn_Node = 0;
            pPortDesc->pd_UsersPramNode1.atn_Network = 0;
            pPortDesc->pd_UsersPramNode1.atn_Node = 0;
            pPortDesc->pd_UsersPramNode2.atn_Network = 0;
            pPortDesc->pd_UsersPramNode2.atn_Node = 0;
            pPortDesc->pd_InitialZoneList = NULL;
            pPortDesc->pd_InitialDefaultZone = NULL;
            pPortDesc->pd_InitialDesiredZone = NULL;
            pPortDesc->pd_ZoneList = NULL;
            pPortDesc->pd_DefaultZone = NULL;
            pPortDesc->pd_DesiredZone = NULL;
            pPortDesc->pd_AmtCount = 0;
            RtlZeroMemory(&pPortDesc->pd_PortStats, sizeof(ATALK_PORT_STATS));

		    // Unblock caller now that we are done
		    KeSetEvent(pPortDesc->pd_ShutDownEvent, IO_NETWORK_INCREMENT, FALSE);

            pPortDesc->pd_ShutDownEvent = NULL;
        }
        else
        {
            // is the Arap port going away?
            if (RasPortDesc == pPortDesc)
            {
                RasPortDesc = NULL;
            }

		    if (pPortDesc->pd_MulticastList != NULL)
            {
			    AtalkFreeMemory(pPortDesc->pd_MulticastList);
			    pPortDesc->pd_MulticastList = NULL;
            }
	
		    // Unblock caller now that we are done
		    KeSetEvent(pPortDesc->pd_ShutDownEvent, IO_NETWORK_INCREMENT, FALSE);

            if (pPortDesc->pd_FriendlyAdapterName.Buffer)
            {
                AtalkFreeMemory(pPortDesc->pd_FriendlyAdapterName.Buffer);
            }

		    AtalkFreeMemory(pPortDesc);

		    ACQUIRE_SPIN_LOCK(&AtalkPortLock, &OldIrql);
		    AtalkNumberOfPorts --;
		    RELEASE_SPIN_LOCK(&AtalkPortLock, OldIrql);
        }
	}
}



BOOLEAN
AtalkReferenceDefaultPort(
    IN VOID
)
{

    KIRQL       OldIrql;
    BOOLEAN     fReferenced = FALSE;


    ACQUIRE_SPIN_LOCK(&AtalkPortLock, &OldIrql);
    if (AtalkDefaultPort)
    {
        ACQUIRE_SPIN_LOCK_DPC(&AtalkDefaultPort->pd_Lock);
        if ( !(AtalkDefaultPort->pd_Flags & (PD_PNP_RECONFIGURE | PD_CLOSING)) )
        {
            AtalkDefaultPort->pd_RefCount++;
            fReferenced = TRUE;
        }
        RELEASE_SPIN_LOCK_DPC(&AtalkDefaultPort->pd_Lock);
    }
    RELEASE_SPIN_LOCK(&AtalkPortLock, OldIrql);

    return(fReferenced);
}


VOID
atalkPortFreeZones(
	IN	PPORT_DESCRIPTOR	pPortDesc
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	// Dereference initial default and desired zones, and the zone list
	if (pPortDesc->pd_InitialDefaultZone != NULL)
		AtalkZoneDereference(pPortDesc->pd_InitialDefaultZone);
	if (pPortDesc->pd_InitialDesiredZone != NULL)
		AtalkZoneDereference(pPortDesc->pd_InitialDesiredZone);
	if (pPortDesc->pd_InitialZoneList != NULL)
		AtalkZoneFreeList(pPortDesc->pd_InitialZoneList);

	// and the current versions of the zones
	if (pPortDesc->pd_DefaultZone != NULL)
		AtalkZoneDereference(pPortDesc->pd_DefaultZone);
	if (pPortDesc->pd_DesiredZone != NULL)
		AtalkZoneDereference(pPortDesc->pd_DesiredZone);
	if (pPortDesc->pd_ZoneList != NULL)
		AtalkZoneFreeList(pPortDesc->pd_ZoneList);
}


VOID FASTCALL
AtalkPortSetResetFlag(
	IN	PPORT_DESCRIPTOR	pPortDesc,
	IN	BOOLEAN				fRemoveBit,
    IN  DWORD               dwBit
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{

    KIRQL           OldIrql;


    ASSERT(VALID_PORT(pPortDesc));

	ACQUIRE_SPIN_LOCK(&pPortDesc->pd_Lock, &OldIrql);
    if (fRemoveBit)
    {
	    pPortDesc->pd_Flags &= ~(dwBit);
    }
    else
    {
	    pPortDesc->pd_Flags |= dwBit;
    }
	RELEASE_SPIN_LOCK(&pPortDesc->pd_Lock, OldIrql);
}


ATALK_ERROR
AtalkPortShutdown(
	IN OUT	PPORT_DESCRIPTOR	pPortDesc
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PATALK_NODE		pAtalkNode;
	ATALK_ERROR		error = ATALK_NO_ERROR;
	BOOLEAN			fActive;
	BOOLEAN			fRasPort=FALSE;
    BOOLEAN         fPnpReconfigure;
	KEVENT			ShutdownEvent;
	KIRQL			OldIrql;



	DBGPRINT(DBG_COMP_UNLOAD, DBG_LEVEL_WARN,
			("AtalkPortShutdown: Shutting down port %Z...\n", &pPortDesc->pd_AdapterKey));

	KeInitializeEvent(&ShutdownEvent, NotificationEvent, FALSE);

    // if this is the default port, tell TDI that we are leaving so server finds out
    if (pPortDesc->pd_Flags & PD_DEF_PORT)
    {
        if (TdiRegistrationHandle)
        {
	        DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_INFO,
			    ("AtalkPortShutdown: deregistering device!!\n"));

            TdiDeregisterDeviceObject(TdiRegistrationHandle);
            TdiRegistrationHandle = NULL;
        }
    }

	ACQUIRE_SPIN_LOCK(&pPortDesc->pd_Lock, &OldIrql);

    // we have already taken care of the Arap port separately: just say done
    if (pPortDesc->pd_Flags & PD_RAS_PORT)
    {
	    fRasPort = TRUE;
    }

	pPortDesc->pd_Flags |= PD_CLOSING;

	fActive = (pPortDesc->pd_Flags & PD_BOUND) ? TRUE : FALSE;
    fPnpReconfigure = (pPortDesc->pd_Flags & PD_PNP_RECONFIGURE)? TRUE : FALSE;

	//	Switch off the active flag just in case the unbind fails.
	//	We arent going to accept any packets anymore.
	pPortDesc->pd_Flags &= ~PD_ACTIVE;
	pPortDesc->pd_ShutDownEvent = &ShutdownEvent;

	DBGPRINT(DBG_COMP_UNLOAD, DBG_LEVEL_WARN,
		("AtalkPortShutdown: Freeing nodes on port ....\n"));

	//	Release any nodes on this port that are not already closing.
    if (!fRasPort)
    {
	    do
	    {
		    //	Ref the next node.
		    //	ASSERT!! error does not get changed after this statement.
		    AtalkNodeReferenceNextNc(pPortDesc->pd_Nodes, &pAtalkNode, &error);

		    if (!ATALK_SUCCESS(error))
            {
			    break;
            }

		    RELEASE_SPIN_LOCK(&pPortDesc->pd_Lock, OldIrql);

		    DBGPRINT(DBG_COMP_UNLOAD, DBG_LEVEL_ERR,
			    	("AtalkPortShutdown: Releasing Node\n"));

		    AtalkNodeReleaseOnPort(pPortDesc, pAtalkNode);

		    AtalkNodeDereference(pAtalkNode);

		    ACQUIRE_SPIN_LOCK(&pPortDesc->pd_Lock, &OldIrql);
	    } while (TRUE);
    }

	RELEASE_SPIN_LOCK(&pPortDesc->pd_Lock, OldIrql);

	// If we are routing, remove the RTEs for this port since each has a reference
	// to this port.
	if (AtalkRouter & !fRasPort)
	{
		AtalkRtmpKillPortRtes(pPortDesc);
	}

    if (EXT_NET(pPortDesc))
    {
        // cancel the Amt timer and take away the refcount for it
        if (AtalkTimerCancelEvent(&pPortDesc->pd_AmtTimer, NULL))
        {
		    AtalkPortDereference(pPortDesc);
        }

        // cancel the Brc timer and take away the refcount for it
        if (AtalkTimerCancelEvent(&pPortDesc->pd_BrcTimer, NULL))
        {
		    AtalkPortDereference(pPortDesc);
        }
    }

    if (!AtalkRouter)
    {
        // cancel the RtmpAging timer and take away the refcount for it
        if (AtalkTimerCancelEvent(&pPortDesc->pd_RtmpAgingTimer, NULL))
        {
		    AtalkPortDereference(pPortDesc);
        }
    }

    //
    // if we are currently bound, *and* we are not here because of
    // PnPReconfigure, go ahead and unbind from ndis
    //
	if (fActive && !fPnpReconfigure)
	{
		//	Unbind from the mac
		AtalkNdisUnbind(pPortDesc);
	}

    //
    // if are here because of PnpReconfigure, we didn't unbind.  But fake
    // that we did (from refcount perspective) so that we can proceed!
    // (in the PnPReconfigure code path, we don't free this memory when refcount
    // goes to 0: we merely use it to trigger some pnp work)
    //
    if (fPnpReconfigure)
    {
		AtalkPortDereference(pPortDesc);
    }

	//	Remove the creation reference
	AtalkPortDereference(pPortDesc);	

	//  Make sure we are not at or above dispatch level
	ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

	//	Wait for the last reference to go away
	KeWaitForSingleObject(&ShutdownEvent,
						  Executive,
						  KernelMode,
						  FALSE,
						  NULL);

	if (fActive)
	{
		ACQUIRE_SPIN_LOCK(&AtalkPortLock, &OldIrql);
		AtalkNumberOfActivePorts--;
		RELEASE_SPIN_LOCK(&AtalkPortLock, OldIrql);

        ASSERT(AtalkStatistics.stat_NumActivePorts > 0);

        AtalkStatistics.stat_NumActivePorts--;
	}

	DBGPRINT(DBG_COMP_UNLOAD, DBG_LEVEL_ERR,
			("AtalkPortShutdown: shutdown for port %lx completed\n",pPortDesc));

	return ATALK_NO_ERROR;
}


#if DBG

VOID
AtalkPortDumpInfo(
	VOID
)
{
	int					i, j;
	KIRQL				OldIrql;
	PPORT_DESCRIPTOR	pPortDesc;
	PZONE_LIST			pZoneList;

	ACQUIRE_SPIN_LOCK(&AtalkPortLock, &OldIrql);
	for (pPortDesc = AtalkPortList;
		 pPortDesc != NULL;
		 pPortDesc = pPortDesc->pd_Next)
	{
		DBGPRINT(DBG_COMP_DUMP, DBG_LEVEL_FATAL,
				("Port info for port %Z\n", &pPortDesc->pd_AdapterKey));

		ACQUIRE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);

		DBGPRINT(DBG_COMP_DUMP, DBG_LEVEL_FATAL,
				("  Flags               -> %d\n", pPortDesc->pd_Flags));

		DBGPRINT(DBG_COMP_DUMP, DBG_LEVEL_FATAL,
				("  PortType            -> %d\n", pPortDesc->pd_PortType));

		DBGPRINT(DBG_COMP_DUMP, DBG_LEVEL_FATAL,
				("  PortName            -> %s\n", pPortDesc->pd_PortName));

		DBGPRINT(DBG_COMP_DUMP, DBG_LEVEL_FATAL,
				("  AARP Probes         -> %d\n", pPortDesc->pd_AarpProbes));

		if (pPortDesc->pd_InitialNetworkRange.anr_FirstNetwork != 0)
		{
			DBGPRINT(DBG_COMP_DUMP, DBG_LEVEL_FATAL,
					("  InitialNwRange      -> %lx-%lx\n",
					pPortDesc->pd_InitialNetworkRange.anr_FirstNetwork,
					pPortDesc->pd_InitialNetworkRange.anr_LastNetwork))
		}

		DBGPRINT(DBG_COMP_DUMP, DBG_LEVEL_FATAL,
				("  NetworkRange        -> %x-%x\n",
				pPortDesc->pd_NetworkRange.anr_FirstNetwork,
				pPortDesc->pd_NetworkRange.anr_LastNetwork))

		DBGPRINT(DBG_COMP_DUMP, DBG_LEVEL_FATAL,
				("  ARouter Address     -> %x.%x\n",
				pPortDesc->pd_ARouter.atn_Network,
				pPortDesc->pd_ARouter.atn_Node));

		DBGPRINT(DBG_COMP_DUMP, DBG_LEVEL_FATAL,
				("  Multicast Addr      -> "));
		for (j = 0; j < MAX_HW_ADDR_LEN; j++)
			DBGPRINTSKIPHDR(DBG_COMP_DUMP, DBG_LEVEL_FATAL,
							("%02x", (BYTE)pPortDesc->pd_ZoneMulticastAddr[j]));
		DBGPRINTSKIPHDR(DBG_COMP_DUMP, DBG_LEVEL_FATAL,
							("\n"));

		if (pPortDesc->pd_InitialZoneList != NULL)
		{
			DBGPRINT(DBG_COMP_DUMP, DBG_LEVEL_FATAL,
					("  Initial zone list:\n"));
	
			for (pZoneList = pPortDesc->pd_InitialZoneList;
				 pZoneList != NULL; pZoneList = pZoneList->zl_Next)
			{
				DBGPRINT(DBG_COMP_DUMP, DBG_LEVEL_FATAL,
						("    %s\n", pZoneList->zl_pZone->zn_Zone));
			}
		}

		if (pPortDesc->pd_InitialDefaultZone != NULL)
			DBGPRINT(DBG_COMP_DUMP, DBG_LEVEL_FATAL,
				("  InitialDefZone      -> %s\n",
				pPortDesc->pd_InitialDefaultZone->zn_Zone));

		if (pPortDesc->pd_InitialDesiredZone != NULL)
			DBGPRINT(DBG_COMP_DUMP, DBG_LEVEL_FATAL,
				("  InitialDesZone      -> %s\n",
				pPortDesc->pd_InitialDesiredZone->zn_Zone));

		if (pPortDesc->pd_ZoneList)
		{
			DBGPRINT(DBG_COMP_DUMP, DBG_LEVEL_FATAL,
					("  Current zone list:\n"));
	
			for (pZoneList = pPortDesc->pd_ZoneList;
				 pZoneList != NULL; pZoneList = pZoneList->zl_Next)
			{
				DBGPRINT(DBG_COMP_DUMP, DBG_LEVEL_FATAL,
						("    %s\n", pZoneList->zl_pZone->zn_Zone));
			}
		}

		if (pPortDesc->pd_DefaultZone != NULL)
			DBGPRINT(DBG_COMP_DUMP, DBG_LEVEL_FATAL,
				("  CurrentDefZone      -> %s\n",
				pPortDesc->pd_DefaultZone->zn_Zone));

		if (pPortDesc->pd_DesiredZone != NULL)
			DBGPRINT(DBG_COMP_DUMP, DBG_LEVEL_FATAL,
				("  CurrentDesZone      -> %s\n",
				pPortDesc->pd_DesiredZone->zn_Zone));

		RELEASE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);
	}
	RELEASE_SPIN_LOCK(&AtalkPortLock, OldIrql);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\atalk\sys\ports.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

	ports.h

Abstract:

	This module contains the structures for ports.

Author:

	Jameel Hyder (jameelh@microsoft.com)
	Nikhil Kamkolkar (nikhilk@microsoft.com)

Revision History:
	19 Jun 1992		Initial Version

Notes:	Tab stop: 4
--*/

#ifndef	_PORTS_
#define	_PORTS_

#define	PORT_AMT_HASH_SIZE			64
#define	PORT_BRC_HASH_SIZE			16

#define MAX_ENTITY_LENGTH			32
#define	MAX_HW_ADDR_LEN				6
#define	MAX_ROUTING_BYTES			18
#define	MAX_ROUTING_SPACE			0x1F		// This much space is allocated
												// for routing info

typedef VOID (*REQ_COMPLETION)(
						NDIS_STATUS 			Status,
						PVOID					Ctx
);

// Prototypes for handlers
typedef	ATALK_ERROR	(*ADDMULTICASTADDR)(
						struct _PORT_DESCRIPTOR *pPortDesc,
						PBYTE					Addr,
						BOOLEAN					ExecuteSync,
						REQ_COMPLETION			AddCompletion,
						PVOID					AddContext);

typedef	ATALK_ERROR	(*REMOVEMULTICASTADDR)(
						struct _PORT_DESCRIPTOR *pPortDesc,
						PBYTE					Addr,
						BOOLEAN					ExecuteSync,
						REQ_COMPLETION			RemoveCompletion,
						PVOID					RemoveContext);
// Address mapping table
// Each port that the stack or router is communicating on must have an
// address mapping table [except non-extended ports]. The mapping table
// holds the association between Appletalk node addresses (network/node),
// and the actual hardware (ethernet/tokenring) addresses. Hash on the
// network/node value.

#define	AMT_SIGNATURE		(*(ULONG *)"AMT ")
#if	DBG
#define	VALID_AMT(pAmt)		(((pAmt) != NULL) &&	\
							 ((pAmt)->amt_Signature == AMT_SIGNATURE))
#else
#define	VALID_AMT(pAmt)		((pAmt) != NULL)
#endif
typedef	struct _AMT_NODE
{
#if	DBG
	DWORD				amt_Signature;
#endif
	struct _AMT_NODE *	amt_Next;
	ATALK_NODEADDR		amt_Target;
	BYTE				amt_HardwareAddr[MAX_HW_ADDR_LEN];
	BYTE				amt_Age;
	BYTE				amt_RouteInfoLen;
	// BYTE				amt_RouteInfo[MAX_ROUTING_SPACE];
} AMT, *PAMT;

#define AMT_AGE_TIME	 			600		// In 100ms units
#define AMT_MAX_AGE					3



// Best Router Entry Table
// Maintained only for extended networks. This must age more quickly than the
// "SeenARouter" timer (50 seconds). To avoid allocations/frees for this structure,
// we use statically allocated data in the port descriptor.

typedef struct _BRE
{
	struct _BRE *		bre_Next;
	USHORT				bre_Network;
	BYTE				bre_Age;
	BYTE				bre_RouterAddr[MAX_HW_ADDR_LEN];
	BYTE				bre_RouteInfoLen;
	// BYTE				bre_RouteInfo[MAX_ROUTING_SPACE];
} BRE, *PBRE;

#define BRC_AGE_TIME				40		// In 100ms units
#define BRC_MAX_AGE					3

//
// Types of ports currently supported by stack. This is kept different
// from the NDIS medium types for two reasons. One is we use these as
// an index into the port handler array, and the second is if we decide
// to implement half-ports etc., which ndis might not be able to deal with.
// WARNING: THIS IS INTEGRATED WITH THE PORT HANDLER ARRAY IN GLOBALS.

typedef enum
{
	ELAP_PORT = 0,
	FDDI_PORT,
	TLAP_PORT,
	ALAP_PORT,
	ARAP_PORT,

	LAST_PORT,

	LAST_PORTTYPE = LAST_PORT

} ATALK_PORT_TYPE;


//
// PORT DESCRIPTORS
// Descriptor for each active port:
//

#define	PD_ACTIVE				0x00000001	// State after packets recv enabled
#define	PD_BOUND	 			0x00000002	// State it goes in before ACTIVE
#define	PD_EXT_NET				0x00000004	// For now, non-localtalk
#define	PD_DEF_PORT				0x00000008	// Is this the default port
#define	PD_SEND_CHECKSUMS		0x00000010	// Send ddp checksums?
#define	PD_SEED_ROUTER			0x00000020	// seeding on this port?
#define	PD_ROUTER_STARTING		0x00000040	// Temporary state when router is starting
#define	PD_ROUTER_RUNNING		0x00000080	// Is the router running?
#define	PD_SEEN_ROUTER_RECENTLY	0x00000100	// Seen router recently?
#define	PD_VALID_DESIRED_ZONE	0x00000200	// Desired Zone is valid
#define	PD_VALID_DEFAULT_ZONE	0x00000400	// Default zone is valid
#define	PD_FINDING_DEFAULT_ZONE	0x00000800	// searching for default zone?
#define	PD_FINDING_DESIRED_ZONE	0x00001000	// searching for desired zone?
#define	PD_FINDING_NODE			0x00002000	// In the process of acquiring a
								 			// new node on this port
#define	PD_NODE_IN_USE			0x00004000	// Tentative node is already in
								 			// use.
#define	PD_ROUTER_NODE			0x00008000 	// Router node is allocated
#define PD_USER_NODE_1			0x00010000 	// First user node is allocated
#define PD_USER_NODE_2			0x00020000 	// Second user node is allocated
#define PD_RAS_PORT             0x00040000  // this port for RAS clients
#define PD_PNP_RECONFIGURE      0x00080000  // this port is currently being reconfigured
#define PD_CONFIGURED_ONCE      0x00100000  // this port has been configured once
#define	PD_CLOSING				0x80000000	// State when unbinding/shutting down

#define	PD_SIGNATURE			(*(ULONG *)"PDES")
#if	DBG
#define	VALID_PORT(pPortDesc)	(((pPortDesc) != NULL) &&	\
								 ((pPortDesc)->pd_Signature == PD_SIGNATURE))
#else
#define	VALID_PORT(pPortDesc)	((pPortDesc) != NULL)
#endif
typedef struct _PORT_DESCRIPTOR
{
#if DBG
	ULONG					pd_Signature;
#endif

	// Link to next - for now to help debugging
	struct _PORT_DESCRIPTOR	*pd_Next;

	// Number of references to this port
	ULONG					pd_RefCount;

	// State of the port
	ULONG					pd_Flags;

    // if this is a Ras port, all ARAP connetions hang on this list
	LIST_ENTRY				pd_ArapConnHead;

    // if this is a Ras port, all PPP connetions hang on this list
	LIST_ENTRY				pd_PPPConnHead;

    // if this is a Ras port, how many lines do we have on this port?
    ULONG                   pd_RasLines;

	// Overide the default number of aarp probes when looking for a
	// node on this port
	SHORT					pd_AarpProbes;

	// Node # of the localtalk node
	USHORT					pd_LtNetwork;

	// Nodes that are being managed on this port. We have a maximum
	// of 2 nodes (3 if the router is started).
	struct _ATALK_NODE	*	pd_Nodes;

	struct _ATALK_NODE	*	pd_RouterNode;

	// Following are used only during node acquisition process.
	// PD_FINDINGNODE is set. Keep this separate from the ndis
	// request event. Both could happen at the same time.
	ATALK_NODEADDR			pd_TentativeNodeAddr;
	KEVENT					pd_NodeAcquireEvent;

	// Port type as defined above
	ATALK_PORT_TYPE 		pd_PortType;

	// NdisMedium type for this port
	NDIS_MEDIUM				pd_NdisPortType;

	// Used during OpenAdapter to block
	KEVENT					pd_RequestEvent;
	NDIS_STATUS		 		pd_RequestStatus;

	// 	Binding handle to the mac associated with this port
	// 	Options associated with the mac.
	// 	MAC Options - 	these are things that we can and cannot do with
	// 					specific macs. Is the value of OID_GEN_MAC_OPTIONS.
	NDIS_HANDLE		 		pd_NdisBindingHandle;
	ULONG					pd_MacOptions;

	// 	This is the spin lock used to protect all requests that need exclusion
	// 	over requests per port.
	ATALK_SPIN_LOCK			pd_Lock;

	// 	All the packets received on this port are linked in here. When the
	// 	receive complete indication is called, all of them are passed to DDP.
	LIST_ENTRY				pd_ReceiveQueue;

	// ASCII port name to be registered on the router node for this port
	// This will be an NBP object name and hence is limited to 32 characters.
	CHAR					pd_PortName[MAX_ENTITY_LENGTH + 1];

	// 	AdapterName is of the form \Device\<adaptername>. It is used
	// 	to bind to the NDIS macs, and then during ZIP requests by setup
	// 	to get the zonelist for a particular adapter. AdapterKey
	// 	contains the adapterName only- this is useful both for getting
	// 	per-port parameters and during errorlogging to specify the adapter
	// 	name without the '\Device\' prefix.
	UNICODE_STRING			pd_AdapterKey;
	UNICODE_STRING			pd_AdapterName;

    UNICODE_STRING          pd_FriendlyAdapterName;

	ATALK_NODEADDR	 		pd_RoutersPramNode;
	ATALK_NODEADDR	 		pd_UsersPramNode1;
	ATALK_NODEADDR	 		pd_UsersPramNode2;
	HANDLE					pd_AdapterInfoHandle;	// Valid during initialization only

	// Initial values from the registry
	ATALK_NETWORKRANGE		pd_InitialNetworkRange;
	struct _ZONE_LIST	*	pd_InitialZoneList;
	struct _ZONE		*	pd_InitialDefaultZone;
	struct _ZONE		*	pd_InitialDesiredZone;

	// True cable range of connected network. Initial/aged values for
	// extended ports: 1:FFFE; Initial value for non-extended ports:
	// 0:0 (does not age).
	ATALK_NETWORKRANGE		pd_NetworkRange;

	// If we are routing, this is the default zone for the network
	// on this port, and the zone list for the same.
	struct _ZONE_LIST	*	pd_ZoneList;
	struct _ZONE		*	pd_DefaultZone;
	struct _ZONE		*	pd_DesiredZone;

	// When did we hear from a router?
	LONG 					pd_LastRouterTime;

	// Address of last router seen. If we are a routing port, this will
	// always be the node that "our" router is operating on!
	ATALK_NODEADDR	 		pd_ARouter;
	KEVENT					pd_SeenRouterEvent;

	// Zone in which all nodes on this port reside and the multicast
	// address for it.
	CHAR					pd_ZoneMulticastAddr[MAX_HW_ADDR_LEN];

	union
	{
		struct
		{
			//
			// FOR ETHERNET PORTS:
			//
			// We add multicast addresses during ZIP packet reception at non-init
			// time. We need to do a GET followed by a SET with the new address
			// list. But there could be two zip packets coming in and doing the
			// same thing effectively overwriting the effects of the first one to
			// set the multicast list. So we need to maintain our own copy of the
			// multicast list.
			//

			// Size of the list
			ULONG			pd_MulticastListSize;
			PCHAR			pd_MulticastList;
		};

		struct
		{

			//
			// FOR TOKENRING PORTS:
			//
			// Just like for ethernet, we need to store the value for
			// the current functional address. We only modify the last
			// four bytes of this address, as the first two always remain
			// constant. So we use a ULONG for it.
			//

			UCHAR			pd_FunctionalAddr[4];	// TLAP_ADDR_LEN - TLAP_MCAST_HDR_LEN
		};
	};

	// Hardware address for the port
	union
	{
		UCHAR				pd_PortAddr[MAX_HW_ADDR_LEN];
		USHORT				pd_AlapNode;
	};

	// Mapping table for best route to "off cable" addresses.
	TIMERLIST				pd_BrcTimer;
	PBRE				 	pd_Brc[PORT_BRC_HASH_SIZE];

	// Logical/physical address mappings for the nodes on the network that
	// this port is connected to.
	ULONG					pd_AmtCount;	// # of entries in the Amt
	TIMERLIST				pd_AmtTimer;
	PAMT 					pd_Amt[PORT_AMT_HASH_SIZE];

	union
	{
		TIMERLIST			pd_RtmpSendTimer;	// If router is configured
		TIMERLIST			pd_RtmpAgingTimer;	// else
	};
	// Per port statistics
    ATALK_PORT_STATS		pd_PortStats;

	// Port handler stuff
	ADDMULTICASTADDR		pd_AddMulticastAddr;

	REMOVEMULTICASTADDR		pd_RemoveMulticastAddr;

	BYTE					pd_BroadcastAddr[MAX_HW_ADDR_LEN];
	USHORT					pd_BroadcastAddrLen;
	USHORT					pd_AarpHardwareType;
	USHORT					pd_AarpProtocolType;

	PKEVENT					pd_ShutDownEvent;
} PORT_DESCRIPTOR, *PPORT_DESCRIPTOR;

#define	INDICATE_ATP		0x01
#define	INDICATE_ADSP		0x02

#define	ATALK_CACHE_SKTMAX	8

#define	ATALK_CACHE_ADSPSKT		((BYTE)0x01)
#define	ATALK_CACHE_ATPSKT		((BYTE)0x02)
#define	ATALK_CACHE_INUSE	    ((BYTE)0x10)
#define	ATALK_CACHE_NOTINUSE	((BYTE)0)

typedef	struct _ATALK_SKT_CACHE
{
	USHORT					ac_Network;
	BYTE					ac_Node;

	struct ATALK_CACHED_SKT
	{
		BYTE				Type;
		BYTE				Socket;

		union
		{
			//	For ATP
			struct _ATP_ADDROBJ * pAtpAddr;
		} u;

	} ac_Cache[ATALK_CACHE_SKTMAX];

} ATALK_SKT_CACHE, *PATALK_SKT_CACHE;

extern		ATALK_SKT_CACHE	AtalkSktCache;
extern		ATALK_SPIN_LOCK	AtalkSktCacheLock;

// externS

extern	PPORT_DESCRIPTOR 	AtalkPortList;		 	// Head of the port list
extern	PPORT_DESCRIPTOR	AtalkDefaultPort;		// Ptr to the def port
extern	KEVENT				AtalkDefaultPortEvent;	// Signalled when default port is available
extern	UNICODE_STRING		AtalkDefaultPortName;	// Name of the default port
extern	ATALK_SPIN_LOCK		AtalkPortLock;			// Lock for AtalkPortList
extern	ATALK_NODEADDR		AtalkUserNode1;			// Node address of user node
extern	ATALK_NODEADDR		AtalkUserNode2;			// Node address of user node
extern	SHORT	 			AtalkNumberOfPorts; 	// Determine dynamically
extern	SHORT				AtalkNumberOfActivePorts;// Number of ports active
extern	BOOLEAN				AtalkRouter;			// Are we a router?
extern	BOOLEAN				AtalkFilterOurNames;	// If TRUE, Nbplookup fails on names on this machine
extern	KEVENT				AtalkUnloadEvent;		// Event for unloading
extern	NDIS_HANDLE			AtalkNdisPacketPoolHandle;
extern	NDIS_HANDLE			AtalkNdisBufferPoolHandle;
extern	LONG				AtalkHandleCount;
extern	UNICODE_STRING		AtalkRegPath;

extern  HANDLE				TdiRegistrationHandle;
extern 	BOOLEAN				AtalkNoDefPortPrinted;

// Exported prototypes
extern
VOID FASTCALL
AtalkPortDeref(
	IN	OUT	PPORT_DESCRIPTOR	pPortDesc,
	IN		BOOLEAN				AtDpc);

extern
BOOLEAN
AtalkReferenceDefaultPort(
    IN VOID
);

extern
ATALK_ERROR
AtalkPortShutdown(
	IN OUT	PPORT_DESCRIPTOR	pPortDesc);

VOID FASTCALL
AtalkPortSetResetFlag(
	IN	PPORT_DESCRIPTOR	pPortDesc,
	IN	BOOLEAN				fRemoveBit,
    IN  DWORD               dwBit);


// Macros
#define	AtalkPortReferenceByPtr(Port, pErr)						\
		{														\
			DBGPRINT(DBG_COMP_REFCOUNTS, DBG_LEVEL_INFO,		\
					("Ref at %s %d\n", __FILE__, __LINE__));	\
			AtalkPortRefByPtr((Port), (pErr));					\
		}

#define	AtalkPortReferenceByPtrDpc(Port, pErr)					\
		{														\
			DBGPRINT(DBG_COMP_REFCOUNTS, DBG_LEVEL_INFO,		\
					("Ref (Dpc) at %s %d\n",					\
					__FILE__, __LINE__));						\
			AtalkPortRefByPtrDpc((Port), (pErr));				\
		}

#define	AtalkPortReferenceByPtrNonInterlock(Port, pErr)			\
		{														\
			DBGPRINT(DBG_COMP_REFCOUNTS, DBG_LEVEL_INFO,		\
					("Ref at %s %d\n", __FILE__, __LINE__));	\
			AtalkPortRefByPtrNonInterlock((Port), (pErr));		\
		}

#define	AtalkPortReferenceByDdpAddr(DdpAddr, Port, pErr)		\
		{														\
			DBGPRINT(DBG_COMP_REFCOUNTS, DBG_LEVEL_INFO,		\
					("Ref at %s %d\n", __FILE__, __LINE__));	\
			AtalkPortRefByDdpAddr((DdpAddr), (Port), (pErr));	\
		}

#define	AtalkPortDereference(Port)								\
		{														\
			DBGPRINT(DBG_COMP_REFCOUNTS, DBG_LEVEL_INFO,		\
					("Deref at %s %d\n", __FILE__, __LINE__));	\
			AtalkPortDeref(Port, FALSE);						\
		}

#define	AtalkPortDereferenceDpc(Port)							\
		{														\
			DBGPRINT(DBG_COMP_REFCOUNTS, DBG_LEVEL_INFO,		\
					("Deref at %s %d\n", __FILE__, __LINE__));	\
			AtalkPortDeref(Port, TRUE);							\
		}

#define	EXT_NET(_pPortDesc)				((_pPortDesc)->pd_Flags & PD_EXT_NET)
#define	DEF_PORT(_pPortDesc)			((_pPortDesc)->pd_Flags & PD_DEF_PORT)
#define	PORT_BOUND(_pPortDesc)			((_pPortDesc)->pd_Flags & PD_BOUND)
#define PORT_CLOSING(_pPortDesc)		((_pPortDesc)->pd_Flags & PD_CLOSING)

#define	AtalkPortRefByPtr(pPortDesc, pErr)						\
		{														\
			KIRQL	OldIrql;									\
																\
			ACQUIRE_SPIN_LOCK(&((pPortDesc)->pd_Lock),&OldIrql);\
			AtalkPortRefByPtrNonInterlock((pPortDesc), (pErr));	\
			RELEASE_SPIN_LOCK(&((pPortDesc)->pd_Lock),OldIrql);	\
		}

#define	AtalkPortRefByPtrDpc(pPortDesc, pErr)					\
		{														\
			ACQUIRE_SPIN_LOCK_DPC(&((pPortDesc)->pd_Lock));		\
			AtalkPortRefByPtrNonInterlock((pPortDesc), (pErr));	\
			RELEASE_SPIN_LOCK_DPC(&((pPortDesc)->pd_Lock));		\
		}

#define	AtalkPortRefByPtrNonInterlock(pPortDesc, pErr)			\
		{														\
			if (((pPortDesc)->pd_Flags & PD_CLOSING) == 0)		\
			{													\
				ASSERT((pPortDesc)->pd_RefCount > 0);			\
				(pPortDesc)->pd_RefCount++;						\
				*(pErr) = ATALK_NO_ERROR;						\
			}													\
			else												\
			{													\
				*(pErr) = ATALK_PORT_CLOSING;					\
			}													\
		}

#define	AtalkPortRefByDdpAddr(pDdpAddr, ppPortDesc,	pErr)		\
		{														\
			ASSERT(VALID_ATALK_NODE((pDdpAddr)->ddpao_Node));	\
																\
			*(ppPortDesc) = (pDdpAddr)->ddpao_Node->an_Port;	\
			AtalkPortRefByPtr(*(ppPortDesc), (pErr));			\
		}

VOID
atalkPortFreeZones(
	IN	PPORT_DESCRIPTOR	pPortDesc
);

#endif	// _PORTS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\atalk\sys\router.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

	router.h

Abstract:

	This module contains the router associated definitions.

Author:

	Jameel Hyder (jameelh@microsoft.com)
	Nikhil Kamkolkar (nikhilk@microsoft.com)

Revision History:
	19 Jun 1992		Initial Version

Notes:	Tab stop: 4
--*/

#ifndef	_ROUTER_
#define	_ROUTER_


VOID
AtalkDdpRouteInPkt(
	IN	PPORT_DESCRIPTOR			pPortDesc,
	IN	PATALK_ADDR					pSrc,
	IN	PATALK_ADDR					pDest,
	IN	BYTE						ProtoType,
	IN	PBYTE						pPkt,
	IN	USHORT						PktLen,
	IN	USHORT						HopCnt
);

VOID FASTCALL
atalkDdpRouteComplete(
	IN	NDIS_STATUS					Status,
	IN	PSEND_COMPL_INFO			pSendInfo
);

#endif	// _ROUTER_


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\atalk\sys\router.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

	router.c

Abstract:

	This module contains

Author:

	Jameel Hyder (jameelh@microsoft.com)
	Nikhil Kamkolkar (nikhilk@microsoft.com)

Revision History:
	19 Jun 1992		Initial Version

Notes:	Tab stop: 4
--*/

#include <atalk.h>
#pragma hdrstop
#define	FILENUM	ROUTER

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE_RTR, AtalkDdpRouteInPkt)
#endif

VOID
AtalkDdpRouteInPkt(
	IN	PPORT_DESCRIPTOR	pPortDesc,
	IN	PATALK_ADDR			pSrc,
	IN	PATALK_ADDR			pDest,
	IN	BYTE				ProtoType,
	IN	PBYTE				pPkt,
	IN	USHORT				PktLen,
	IN	USHORT				HopCnt
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PDDP_ADDROBJ		pDdpAddr;
	PRTE				pRte;
	PPORT_DESCRIPTOR	pDestPort;
	PATALK_NODE			pRouterNode;
	ATALK_ADDR			actualDest;
	BUFFER_DESC			BufDesc;

	PBUFFER_DESC		pBufCopy	= NULL;
	USHORT				bufLen		= 0;
	BOOLEAN				delivered 	= FALSE;
	ATALK_ERROR			error 		= ATALK_NO_ERROR;
	SEND_COMPL_INFO	 	SendInfo;

	//	AtalkDdpRouteOutBufDesc() will have already passed us a
	//	copy if bcast is going to be TRUE, and AtalkDdpRouteInPkt() will
	//	never call AtalkDdpRouter() for a bcast packet. They will also set
	//	the completion routines to be different if they passed us a copy.
	//	Those will free up the buffer descriptors.
	//
	//	The completion routines are optional in the sense that the buffer
	//	will never be freed if they are not set!

	//	This algorithm is taken from the "Appletalk Phase 2 Specification".

	//	If the destination network number is within the range of the reception
	//	port's network range and the destination node number is broadcast, then
	//	we can drop the packet on the floor -- it is a network specific broadcast
	//	not for this router.  Note that we've already delivered the packet, and
	//	thus not gotten here, if it was really addressed to the network of any
	//	node owned by the reception port (in AtalkDdpPacketIn).
	//	Also:
	//	Try to find an entry in the routing table that contains the target
	//	network.  If not found, discard the packet.

	if (((WITHIN_NETWORK_RANGE(pDest->ata_Network,
							   &pPortDesc->pd_NetworkRange)) &&
		(pDest->ata_Node == ATALK_BROADCAST_NODE))			 ||
		((pRte = AtalkRtmpReferenceRte(pDest->ata_Network)) == NULL))
	{
		DBGPRINT(DBG_COMP_ROUTER, DBG_LEVEL_FATAL,
				("AtalkDdpRouter: %lx RtmpRte/Not in ThisCableRange\n",
				pDest->ata_Network));
		return;
	}

	do
	{
		//	Get the port descriptor for this port number.
		pDestPort = pRte->rte_PortDesc;

		ASSERT(VALID_PORT(pDestPort));

		DBGPRINT(DBG_COMP_ROUTER, DBG_LEVEL_WARN,
				("ROUTER: Routing pkt from port %Z.%lx to %Z.%lx\n",
				&pPortDesc->pd_AdapterKey, pSrc->ata_Network,
				&pDestPort->pd_AdapterKey, pDest->ata_Network));

        SendInfo.sc_TransmitCompletion = atalkDdpRouteComplete;
		SendInfo.sc_Ctx1 = pDestPort;
		// SendInfo.sc_Ctx3 = NULL;

		//	If the target network's hop count is non-zero, we really need to send
		//	the beast, so, just do it!
		if (pRte->rte_NumHops != 0)
		{
			//	Too many hops?
			error = ATALK_FAILURE;
			if (HopCnt < RTMP_MAX_HOPS)
			{
				//	We own the data. Call AtalkTransmitDdp() with the buffer descriptor.
				//	Make a copy! Caller will free our current packet.
				//	Alloc a buffer descriptor, copy data from packet to buffdesc.

				if ((pBufCopy = AtalkAllocBuffDesc(NULL,
												   PktLen,
												   (BD_FREE_BUFFER | BD_CHAR_BUFFER))) == NULL)
				{
					error = ATALK_RESR_MEM;
					break;
				}

				AtalkCopyBufferToBuffDesc(pPkt, PktLen, pBufCopy, 0);
				SendInfo.sc_Ctx2 = pBufCopy;

				error = AtalkDdpTransmit(pDestPort,
										 pSrc,
										 pDest,
										 ProtoType,
										 pBufCopy,
										 NULL,
										 0,
										 (USHORT)(HopCnt+1),
										 NULL,					//	pZoneMcastAddr,
										 &pRte->rte_NextRouter,
										 &SendInfo);
			}
			INTERLOCKED_INCREMENT_LONG_DPC(
					&pDestPort->pd_PortStats.prtst_NumPktRoutedOut,
					&AtalkStatsLock.SpinLock);
		
			break;
		}
		
		//	If the destination node is zero, the packet is really destined for the
		//	router's node on this port.
		if (pDest->ata_Node == ANY_ROUTER_NODE)
		{
			//	Grab the port lock and read the router node address.
			//	No need to reference, just ensure its not null.
			ACQUIRE_SPIN_LOCK_DPC(&pDestPort->pd_Lock);
			pRouterNode = pDestPort->pd_RouterNode;
			if (pRouterNode != NULL)
			{
				actualDest.ata_Network = pRouterNode->an_NodeAddr.atn_Network;
				actualDest.ata_Node    = pRouterNode->an_NodeAddr.atn_Node;

				//	Set the actual destination socket.
				actualDest.ata_Socket  = pDest->ata_Socket;
			}
			else
			{
				ASSERTMSG("AtalkDdpRouter: pRouter node is null!\n", 0);
				error = ATALK_DDP_NOTFOUND;
			}

			if (ATALK_SUCCESS(error))
			{
				AtalkDdpRefByAddrNode(pDestPort,
									  &actualDest,
									  pRouterNode,
									  &pDdpAddr,
									  &error);
			}

			RELEASE_SPIN_LOCK_DPC(&pDestPort->pd_Lock);

			if (ATALK_SUCCESS(error))
			{
				AtalkDdpInvokeHandler(pDestPort,
									  pDdpAddr,
									  pSrc,
									  pDest,		// Pass in the actual destination
									  ProtoType,
									  pPkt,
									  PktLen);

				//	Remove the reference on the socket
				AtalkDdpDereferenceDpc(pDdpAddr);
			}
			else
			{
				ASSERTMSG("AtalkDdpRouter: pSocket on router node is null!\n", 0);
			}

			break;
		}


		//	Okay, now walk through the nodes on the target port, looking for a
		//	home for this packet.
		BufDesc.bd_Next			= NULL;
		BufDesc.bd_Flags		= BD_CHAR_BUFFER;
		BufDesc.bd_Length		= PktLen;
		BufDesc.bd_CharBuffer	= pPkt;

		AtalkDdpOutBufToNodesOnPort(pDestPort,
									pSrc,
									pDest,
									ProtoType,
									&BufDesc,
									NULL,
									0,
									&delivered);
	
		error = ATALK_NO_ERROR;
		if (!delivered)
		{
			//	We need to deliver this packet to a local ports network.
			//	delivered would have been set true *EVEN* if broadcast
			//	were set, so we need to ensure it was delivered to a specific
			//	socket by making sure broadcast was not true.
			if (HopCnt < RTMP_MAX_HOPS)
			{
				//	We own the data. Call AtalkTransmitDdp() with the buffer descriptor.
				//	Make a copy! Caller will free our current packet.
				//	Alloc a buffer descriptor, copy data from packet to buffdesc.

				if ((pBufCopy = AtalkAllocBuffDesc(NULL,
												   PktLen,
												   (BD_FREE_BUFFER | BD_CHAR_BUFFER))) == NULL)
				{
					error = ATALK_RESR_MEM;
					break;
				}

				AtalkCopyBufferToBuffDesc(pPkt, PktLen, pBufCopy, 0);
				SendInfo.sc_Ctx2 = pBufCopy;

				error = AtalkDdpTransmit(pDestPort,
										 pSrc,
										 pDest,
										 ProtoType,
										 pBufCopy,
										 NULL,
										 0,
										 (USHORT)(HopCnt+1),
										 NULL,					//	pZoneMcastAddr
										 NULL,
										 &SendInfo);
				INTERLOCKED_INCREMENT_LONG_DPC(
						&pDestPort->pd_PortStats.prtst_NumPktRoutedOut,
						&AtalkStatsLock.SpinLock);
			
			}
			else error	= ATALK_FAILURE;

			break;
		}
		
	} while (FALSE);

	if ((error != ATALK_PENDING) && (pBufCopy != NULL))
	{
		//	Free the copied buffer descriptor if a copy was made.
		AtalkFreeBuffDesc(pBufCopy);
	}

	AtalkRtmpDereferenceRte(pRte, FALSE);				// Lock held?

	INTERLOCKED_INCREMENT_LONG_DPC(
		&pPortDesc->pd_PortStats.prtst_NumPktRoutedIn,
		&AtalkStatsLock.SpinLock);
}




VOID FASTCALL
atalkDdpRouteComplete(
	IN	NDIS_STATUS			Status,
	IN	PSEND_COMPL_INFO	pSendInfo
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PPORT_DESCRIPTOR	pPortDesc = (PPORT_DESCRIPTOR)(pSendInfo->sc_Ctx1);
	PBUFFER_DESC		pBuffDesc = (PBUFFER_DESC)(pSendInfo->sc_Ctx2);

	if (pBuffDesc != NULL)
	{
		ASSERT(pBuffDesc->bd_Flags & (BD_CHAR_BUFFER | BD_FREE_BUFFER));
		AtalkFreeBuffDesc(pBuffDesc);
	}
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\atalk\sys\rasproto.h ===
// prototypes

NTSTATUS
ArapProcessIoctl(
	IN PIRP 			pIrp
);


BOOLEAN
ArapAcceptIrp(
    IN PIRP     pIrp,
    IN ULONG    IoControlCode,
    IN BOOLEAN  *pfDerefDefPort
);


VOID
ArapCancelIrp(
    IN  PIRP    pIrp
);


VOID
ArapGetSelectIrp(
    IN  PIRP    *ppIrp
);


NTSTATUS
ArapExchangeParms(
    IN PIRP         pIrp
);


NTSTATUS
ArapConnect(
    IN PIRP                 pIrp,
    IN ULONG                IoControlCode
);


NTSTATUS
ArapDisconnect(
    IN PIRP                 pIrp
);


NTSTATUS
ArapGetStats(
    IN PIRP                 pIrp
);


NTSTATUS
ArapGetAddr(
    IN PIRP                 pIrp
);


NTSTATUS
ArapProcessSelect(
    IN  PIRP  pIrp
);


PARAPCONN
FindArapConnByContx(
    IN  PVOID   pDllContext
);


PARAPCONN
FindAndRefArapConnByAddr(
    IN  ATALK_NODEADDR      destNode,
    OUT DWORD               *pdwFlags
);


PVOID
FindAndRefRasConnByAddr(
    IN  ATALK_NODEADDR      destNode,
    OUT DWORD              *pdwFlags,
    OUT BOOLEAN            *pfThisIsPPP
);


BOOLEAN
ArapConnIsValid(
    IN  PARAPCONN  pArapConn
);


VOID
DerefArapConn(
	IN	PARAPCONN    pArapConn
);


VOID
DerefMnpSendBuf(
    IN PMNPSENDBUF   pMnpSendBuf,
    IN BOOLEAN       fNdisSendComplete
);


VOID
ArapReleaseAddr(
    IN PARAPCONN    pArapConn
);


NTSTATUS
ArapIoctlSend(
    IN PIRP                    pIrp
);


NTSTATUS
ArapIoctlRecv(
    IN PIRP                 pIrp
);


VOID
ArapDelayedNotify(
    OUT PARAPCONN   *ppDiscArapConn,
    OUT PARAPCONN   *ppRecvArapConn
);


DWORD
ArapSendPrepare(
    IN  PARAPCONN       pArapConn,
    IN  PBUFFER_DESC    pOrgBuffDesc,
    IN  DWORD           Priority
);

VOID
ArapIoctlSendComplete(
	IN  DWORD               StatusCode,
    IN  PARAPCONN           pArapConn
);


VOID
ArapRcvIndication(
    IN PARAPCONN    pArapConn,
    IN PVOID        LkBuf,
    IN UINT         LkBufSize
);


VOID
ArapRcvComplete(
    IN VOID
);


VOID
ArapPerConnRcvProcess(
    IN  PARAPCONN   pArapConn
);


VOID
ArapNdisSend(
    IN  PARAPCONN       pArapConn,
    IN  PLIST_ENTRY     pSendHead
);


DWORD
ArapGetNdisPacket(
    IN PMNPSENDBUF     pMnpSendBuf
);


BOOLEAN
ArapRefillSendQ(
    IN PARAPCONN    pArapConn
);


VOID
ArapNdisSendComplete(
	IN NDIS_STATUS		    Status,
	IN PBUFFER_DESC         pBufferDesc,
    IN PSEND_COMPL_INFO     pSendInfo
);


VOID
RasStatusIndication(
	IN	NDIS_STATUS 	GeneralStatus,
	IN	PVOID			StatusBuf,
	IN	UINT 			StatusBufLen
);


VOID
ArapRetransmitComplete(
	NDIS_STATUS				Status,
	PBUFFER_DESC			pBuffDesc,
	PSEND_COMPL_INFO		pArapSendInfo
);


VOID ArapMnpSendComplete(
    IN PMNPSENDBUF   pMnpSendBuf,
    IN DWORD         Status
);


PARAPBUF
ArapExtractAtalkSRP(
    IN PARAPCONN    pArapConn
);


PBYTE
ArapAllocDecompMemory(
    IN DWORD    BufferSize
);


VOID
ArapFreeDecompMemory(
    IN PBYTE    pDecompMemory
);


DWORD
ArapQueueSendBytes(
    IN PARAPCONN    pArapConn,
    IN PBYTE        pCompressedDataBuffer,
    IN DWORD        CompressedDataLen,
    IN  DWORD       Priority
);


PMNPSENDBUF
ArapGetSendBuf(
    IN PARAPCONN pArapConn,
    IN DWORD     Priority
);


DWORD
PrepareConnectionResponse(
    IN PARAPCONN  pArapConn,
    IN PBYTE      pReq,
    IN  DWORD     ReqLen,
    IN PBYTE      pFrame,
    IN USHORT   * pMnpLen
);


NTSTATUS
ArapMarkConnectionForCallback(
    IN PIRP                 pIrp,
    IN ULONG                IoControlCode
);


NTSTATUS
ArapMarkConnectionUp(
    IN PIRP                 pIrp
);


PLIST_ENTRY
ArapRearrangePackets(
    IN PARAPCONN    pArapConn,
    IN PLIST_ENTRY  pRcvList
);


VOID
MnpSendAckIfReqd(
    IN PARAPCONN pArapConn,
    IN BOOLEAN   fForceAck
);


VOID
MnpSendLNAck(
    IN  PARAPCONN    pArapConn,
    IN  BYTE         LnSeqToAck
);


DWORD
ArapSendLDPacket(
    IN PARAPCONN    pArapConn,
    IN BYTE         UserCode
);


VOID
ArapConnectComplete(
    IN PMNPSENDBUF  pMnpSendBuf,
    IN DWORD        Status
);


VOID
ArapCleanup(
    IN PARAPCONN    pArapConn
);


DWORD
ArapDataToDll(
	IN	PARAPCONN    pArapConn
);


VOID
MnpSendAckComplete(
    IN NDIS_STATUS          Status,
    IN PBUFFER_DESC         pBuffDesc,
    IN PSEND_COMPL_INFO     pInfo
);


DWORD
ArapGetStaticAddr(
    IN PARAPCONN  pArapConn
);


DWORD
ArapGetDynamicAddr(
    IN PARAPCONN       pArapConn
);


PARAPCONN
AllocArapConn(
    IN ULONG    LinkSpeed
);


DWORD
ArapUnblockSelect(
    IN  VOID
);


DWORD
ArapReleaseResources(
    IN  VOID
);


BOOLEAN
AtalkReferenceRasDefPort(
    IN  VOID
);


VOID
AtalkPnPInformRas(
    IN  BOOLEAN     fEnableRas
);


DWORD
ArapScheduleWorkerEvent(
    IN DWORD Action,
    IN PVOID Context1,
    IN PVOID Context2
);


VOID
ArapDelayedEventHandler(
    IN PARAPQITEM  pArapQItem
);


LONG FASTCALL
ArapRetryTimer(
	IN	PTIMERLIST			pTimer,
	IN	BOOLEAN				TimerShuttingDown
);


VOID
ArapRoutePacketFromWan(
    IN  PARAPCONN    pArapConn,
    IN  PARAPBUF     pArapBuf
);


VOID
ArapRoutePacketToWan(
	IN  ATALK_ADDR	*pDestAddr,
	IN  ATALK_ADDR	*pSrcAddr,
    IN  BYTE         Protocol,
	IN	PBYTE		 packet,
	IN	USHORT		 PktLen,
    IN  BOOLEAN      broadcast,
    OUT PBOOLEAN     pDelivered
);


BOOLEAN
ArapOkToForward(
    IN  PARAPCONN   pArapConn,
    IN  PBYTE       packet,
    IN  USHORT      packetLen,
    OUT DWORD      *pPriority
);


VOID
ArapAddArapRoute(
    IN VOID
);


VOID
ArapDeleteArapRoute(
    IN VOID
);



VOID
ArapZipGetZoneStat(
    IN OUT PZONESTAT pZoneStat
);


VOID
ArapZipGetZoneStatCompletion(
    IN ATALK_ERROR  ErrorCode,
    IN PACTREQ      pActReq
);


BOOLEAN
ArapValidNetrange(
    IN NETWORKRANGE NetRange
);

BOOLEAN
v42bisInit(
  IN  PARAPCONN  pArapConn,
  IN  PBYTE      pReq,
  OUT DWORD     *dwReqToSkip,
  OUT PBYTE      pFrame,
  OUT DWORD     *dwFrameToSkip
);


DWORD
v42bisCompress(
  IN  PARAPCONN  pArapConn,
  IN  PUCHAR     pUncompressedData,
  IN  DWORD      UnCompressedDataLen,
  OUT PUCHAR     pCompressedData,
  OUT DWORD      CompressedDataBufSize,
  OUT DWORD     *pCompressedDataLen
);


DWORD
v42bisDecompress(
  IN  PARAPCONN  pArapConn,
  IN  PUCHAR     pCompressedData,
  IN  DWORD      CompressedDataLen,
  OUT PUCHAR     pDecompressedData,
  OUT DWORD      DecompressedDataBufSize,
  OUT DWORD     *pByteStillToDecompress,
  OUT DWORD     *pDecompressedDataLen
);


VOID
ArapCaptureSniff(
    IN  PARAPCONN       pArapConn,
    IN  PBUFFER_DESC    pBufferDescr,
    IN  BYTE            FirstSeq,
    IN  BYTE            LastSeq
);


//
// PPP specific routines
//

PATCPCONN
AllocPPPConn(
    IN VOID
);


NTSTATUS FASTCALL
PPPProcessIoctl(
	IN     PIRP 			    pIrp,
    IN OUT PARAP_SEND_RECV_INFO pSndRcvInfo,
    IN     ULONG                IoControlCode,
    IN     PATCPCONN            pIncomingAtcpConn
);


VOID
DerefPPPConn(
	IN	PATCPCONN    pAtcpConn
);


PATCPCONN
FindAndRefPPPConnByAddr(
    IN  ATALK_NODEADDR      destNode,
    OUT DWORD               *pdwFlags
);



VOID
PPPRoutePacketToWan(
	IN  ATALK_ADDR	*pDestAddr,
	IN  ATALK_ADDR	*pSrcAddr,
    IN  BYTE         Protocol,
	IN	PBYTE		 packet,
	IN	USHORT		 PktLen,
    IN  USHORT       HopCount,
    IN  BOOLEAN      broadcast,
    OUT PBOOLEAN     pDelivered
);


VOID FASTCALL
PPPTransmit(
    IN  PATCPCONN    pAtcpConn,
	IN  ATALK_ADDR	*pDestAddr,
	IN  ATALK_ADDR	*pSrcAddr,
    IN  BYTE         Protocol,
	IN	PBYTE		 packet,
	IN	USHORT		 PktLen,
    IN  USHORT       HopCount
);


VOID FASTCALL
PPPTransmitCompletion(
    IN  NDIS_STATUS         Status,
    IN  PSEND_COMPL_INFO    pSendInfo
);


DWORD
PPPGetDynamicAddr(
    IN PATCPCONN       pAtcpConn
);


//
// Debug-only routines
//

#if DBG

NTSTATUS
ArapProcessSniff(
    IN  PIRP  pIrp
);


BOOLEAN
DbgChkRcvQIntegrity(
    IN  PARAPCONN       pArapConn
);

VOID
DbgDumpBytes(
    IN PBYTE  pDbgMsg,
    IN PBYTE  pBuffer,
    IN DWORD  BufLen,
    IN DWORD  DumpLevel
);

VOID
DbgDumpBytesPart2(
    IN  PBYTE  pBuffer,
    OUT PBYTE  OutBuf,
    IN  DWORD  BufLen,
    OUT DWORD *NextIndex
);

VOID
DbgDumpNetworkNumbers(
    IN VOID
);


VOID
ArapDbgTrace(
    IN PARAPCONN    pArapConn,
    IN DWORD        Location,
    IN PVOID        Context,
    IN DWORD        dwInfo1,
    IN DWORD        dwInfo2,
    IN DWORD        dwInfo3
);


VOID
ArapDbgMnpHist(
    IN PARAPCONN    pArapConn,
    IN BYTE         Seq,
    IN BYTE         FrameType
);

VOID
ArapDbgDumpMnpHist(
    IN PARAPCONN    pArapConn
);


BOOLEAN
ArapDumpSniffInfo(
    IN PARAPCONN    pArapConn
);


DWORD
ArapFillIrpWithSniffInfo(
    IN PARAPCONN    pArapConn,
    IN PIRP         pIrp
);


VOID
DbgTrackInfo(
    IN PARAPCONN    pArapConn,
    IN DWORD        Size,
    IN DWORD        TrackingWhat
);


VOID
ArapDumpNdisPktInfo(
    IN VOID
);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\atalk\sys\ppp.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	ppp.c

Abstract:

	This module implements routines that are used for PPP functionality

Author:

	Shirish Koti

Revision History:
	11 Mar 1998		Initial Version

--*/

#define		ARAP_LOCALS
#include 	<atalk.h>
#pragma hdrstop

#define	FILENUM		PPP

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE_PPP, AllocPPPConn)
#pragma alloc_text(PAGE_PPP, PPPProcessIoctl)
#pragma alloc_text(PAGE_PPP, PPPRoutePacketToWan)
#pragma alloc_text(PAGE_PPP, PPPTransmit)
#pragma alloc_text(PAGE_PPP, PPPTransmitCompletion)
#pragma alloc_text(PAGE_PPP, DerefPPPConn)
#pragma alloc_text(PAGE_PPP, PPPGetDynamicAddr)
#endif

//***
//
// Function: AllocPPPConn
//              Allocate a connection element and initialize fields
//
// Parameters:  none
//
// Return:      pointer to a newly allocated connection element
//
//***$

PATCPCONN
AllocPPPConn(
    IN VOID
)
{

    PATCPCONN   pAtcpConn;
    KIRQL       OldIrql;


    DBG_PPP_CHECK_PAGED_CODE();

    if ( (pAtcpConn = AtalkAllocZeroedMemory(sizeof(ATCPCONN))) == NULL)
    {
		DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR, ("AllocPPPConn: alloc failed\n"));

        return(NULL);
    }

#if DBG
    pAtcpConn->Signature = ATCPCONN_SIGNATURE;
#endif

    // RAS refcount
    pAtcpConn->RefCount = 1;
    pAtcpConn->Flags |= ATCP_DLL_SETUP_DONE;

    INITIALIZE_SPIN_LOCK(&pAtcpConn->SpinLock);

    KeInitializeEvent(&pAtcpConn->NodeAcquireEvent, NotificationEvent, FALSE);

    // and insert it in the list
    ACQUIRE_SPIN_LOCK(&RasPortDesc->pd_Lock, &OldIrql);
    InsertTailList(&RasPortDesc->pd_PPPConnHead, &pAtcpConn->Linkage);
    RELEASE_SPIN_LOCK(&RasPortDesc->pd_Lock, OldIrql);

    ACQUIRE_SPIN_LOCK(&ArapSpinLock, &OldIrql);
    PPPConnections++;
    RELEASE_SPIN_LOCK(&ArapSpinLock, OldIrql);

    return( pAtcpConn );
}


//***
//
// Function: PPPProcessIoctl
//              This routine gets called in to process ioclts coming from ATCP
//              For SETUP, we allocate a connection context, get an address for
//                the client, get the zone and router info.
//              For CLOSE, we mark and dereference our connection context
//
// Parameters:  pIrp - irp from ATCP
//              pSndRcvInfo - buffer from ATCP that contains all the info
//              IoControlCode - what does ATCP want to do
//
// Return:      none
//
//***$

NTSTATUS FASTCALL
PPPProcessIoctl(
	IN     PIRP 			    pIrp,
    IN OUT PARAP_SEND_RECV_INFO pSndRcvInfo,
    IN     ULONG                IoControlCode,
    IN     PATCPCONN            pIncomingAtcpConn
)
{
    KIRQL                   OldIrql;
    PATCPINFO               pAtcpInfo;
    PATCPCONN               pAtcpConn;
    DWORD                   dwRetCode=ARAPERR_NO_ERROR;
    PATCP_SUPPRESS_INFO     pSupprInfo;
    ATALK_NODEADDR          ClientNode;
    DWORD                   DataLen=0;
    DWORD                   ErrCode;
    BOOLEAN                 fDerefPort=FALSE;
	NTSTATUS				ReturnStatus=STATUS_SUCCESS;


    DBG_PPP_CHECK_PAGED_CODE();

    pAtcpConn = pIncomingAtcpConn;

    switch (IoControlCode)
    {
        case IOCTL_ATCP_SETUP_CONNECTION:

            ErrCode = ATALK_PORT_INVALID;

            // put a IrpProcess refcount, so AtalkDefaultPort doesn't go away in PnP
            if (!AtalkReferenceDefaultPort())
            {
                DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                    ("PPPProcessIoctl: Default port gone, or going %lx not accepted (%lx)\n", pIrp,IoControlCode));

                dwRetCode = ARAPERR_STACK_IS_NOT_ACTIVE;

                break;
            }

            fDerefPort = TRUE;

            // allocate connection context
            pAtcpConn = AllocPPPConn();
            if (!pAtcpConn)
            {
		        DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                    ("PPPProcessIoctl: alloc failed\n"));
                pSndRcvInfo->StatusCode = ARAPERR_OUT_OF_RESOURCES;
                break;
            }

            pAtcpConn->pDllContext = pSndRcvInfo->pDllContext;

            dwRetCode = PPPGetDynamicAddr(pAtcpConn);
            if (dwRetCode != ARAPERR_NO_ERROR)
            {
                DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                    ("PPPProcessIoctl: couldn't get network addr %ld (%lx)\n",
                    dwRetCode,pAtcpConn));

                dwRetCode = ARAPERR_NO_NETWORK_ADDR;

                // remove the creation refcount
                DerefPPPConn(pAtcpConn);
                break;
            }

            pAtcpInfo = (PATCPINFO)&pSndRcvInfo->Data[0];


            ACQUIRE_SPIN_LOCK(&AtalkPortLock, &OldIrql);

            ACQUIRE_SPIN_LOCK_DPC(&AtalkDefaultPort->pd_Lock);

            if ((AtalkDefaultPort->pd_Flags & PD_PNP_RECONFIGURE) ||
            (AtalkDefaultPort->pd_Flags & PD_CLOSING))
            {
                DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                    ("PPPProcessIoctl: PnP is ine progress\n"));

                dwRetCode = ARAPERR_STACK_IS_NOT_ACTIVE;
                RELEASE_SPIN_LOCK_DPC(&AtalkDefaultPort->pd_Lock);
                RELEASE_SPIN_LOCK(&AtalkPortLock, OldIrql);

                // remove the creation refcount
                DerefPPPConn(pAtcpConn);
                break;
            }

            // we will be returning server's address and router's address
            DataLen += (2*sizeof(NET_ADDR));

            // copy server's net address
            pAtcpInfo->ServerAddr.ata_Network =
                        AtalkDefaultPort->pd_Nodes->an_NodeAddr.atn_Network;
            pAtcpInfo->ServerAddr.ata_Node =
                        AtalkDefaultPort->pd_Nodes->an_NodeAddr.atn_Node;

            // if we are a router, copy our own address
            if (AtalkDefaultPort->pd_Flags & PD_ROUTER_RUNNING)
            {
                pAtcpInfo->DefaultRouterAddr.ata_Network =
                                AtalkDefaultPort->pd_RouterNode->an_NodeAddr.atn_Network;
                pAtcpInfo->DefaultRouterAddr.ata_Network =
                                AtalkDefaultPort->pd_RouterNode->an_NodeAddr.atn_Node;
            }

            // if we know who the router on the net is, copy his address
            else if (AtalkDefaultPort->pd_Flags & PD_SEEN_ROUTER_RECENTLY)
            {
                pAtcpInfo->DefaultRouterAddr.ata_Network =
                                AtalkDefaultPort->pd_ARouter.atn_Network;
                pAtcpInfo->DefaultRouterAddr.ata_Node =
                                AtalkDefaultPort->pd_ARouter.atn_Node;
            }

            // hmmm: no router!
            else
            {
                pAtcpInfo->DefaultRouterAddr.ata_Network = 0;
                pAtcpInfo->DefaultRouterAddr.ata_Node = 0;
            }

            //
            // copy the name of the zone on which this server lives
            //
            if (AtalkDesiredZone)
            {
                pAtcpInfo->ServerZoneName[0] = AtalkDesiredZone->zn_ZoneLen;
                RtlCopyMemory( &pAtcpInfo->ServerZoneName[1],
                               &AtalkDesiredZone->zn_Zone[0],
                               AtalkDesiredZone->zn_ZoneLen );
            }
            else if (AtalkDefaultPort->pd_DefaultZone)
            {
                pAtcpInfo->ServerZoneName[0] =
                                AtalkDefaultPort->pd_DefaultZone->zn_ZoneLen;
                RtlCopyMemory( &pAtcpInfo->ServerZoneName[1],
                               &AtalkDefaultPort->pd_DefaultZone->zn_Zone[0],
                               AtalkDefaultPort->pd_DefaultZone->zn_ZoneLen );
            }
            else
            {
                DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                    ("PPPProcessIoctl: Server not in any zone!!\n"));
                pAtcpInfo->ServerZoneName[0] = 0;
            }

            RELEASE_SPIN_LOCK_DPC(&AtalkDefaultPort->pd_Lock);
            RELEASE_SPIN_LOCK(&AtalkPortLock, OldIrql);

            DataLen += pAtcpInfo->ServerZoneName[0];

            // return our context and the network addr to the dll
            pSndRcvInfo->AtalkContext = pAtcpConn;

            pSndRcvInfo->ClientAddr.ata_Network = pAtcpConn->NetAddr.atn_Network;
            pSndRcvInfo->ClientAddr.ata_Node = pAtcpConn->NetAddr.atn_Node;

		    DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                    ("PPPProcessIoctl: PPP conn %lx created, addr = %x.%x\n",
                    pAtcpConn,pSndRcvInfo->ClientAddr.ata_Network,pSndRcvInfo->ClientAddr.ata_Node));
            break;

        case IOCTL_ATCP_SUPPRESS_BCAST:

            pSupprInfo = (PATCP_SUPPRESS_INFO)&pSndRcvInfo->Data[0];

            //
            // see what flags need to be set: suppress only RTMP only or all bcast
            //
            ACQUIRE_SPIN_LOCK(&pAtcpConn->SpinLock, &OldIrql);

            if (pSupprInfo->SuppressRtmp)
            {
                pAtcpConn->Flags |= ATCP_SUPPRESS_RTMP;
            }

            if (pSupprInfo->SuppressAllBcast)
            {
                pAtcpConn->Flags |= ATCP_SUPPRESS_ALLBCAST;
            }

            RELEASE_SPIN_LOCK(&pAtcpConn->SpinLock, OldIrql);

            break;

        case IOCTL_ATCP_CLOSE_CONNECTION:

	        DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                ("PPPProcessIoctl: close connection received on %lx (refcount %d)\n",
                pAtcpConn,pAtcpConn->RefCount));

            ACQUIRE_SPIN_LOCK(&pAtcpConn->SpinLock, &OldIrql);
            pAtcpConn->Flags &= ~(ATCP_CONNECTION_UP | ATCP_DLL_SETUP_DONE);
            RELEASE_SPIN_LOCK(&pAtcpConn->SpinLock, OldIrql);

            // PPP wants to close connection: take away the RAS refcount
            DerefPPPConn(pAtcpConn);

            break;

        default:
            ASSERT(0);
            break;
    }

    pSndRcvInfo->DataLen = DataLen;
    pSndRcvInfo->StatusCode = dwRetCode;

    // complete that irp
    ARAP_COMPLETE_IRP(pIrp, (sizeof(ARAP_SEND_RECV_INFO)+DataLen), STATUS_SUCCESS, &ReturnStatus);

    if (fDerefPort)
    {
        // remove that IrpProcess refcount
        AtalkPortDereference(AtalkDefaultPort);
    }

    return ReturnStatus;
}



//***
//
// Function: DerefPPPConn
//              Decrements the refcount of the connection element by 1.  If the
//              refcount goes to 0, releases network addr and frees it
//
// Parameters:  pAtcpConn - connection element in question
//
// Return:      none
//
//***$

VOID
DerefPPPConn(
	IN	PATCPCONN    pAtcpConn
)
{

    KIRQL       OldIrql;
    BOOLEAN     fKill = FALSE;


    DBG_PPP_CHECK_PAGED_CODE();

    ACQUIRE_SPIN_LOCK(&pAtcpConn->SpinLock, &OldIrql);

    ASSERT(pAtcpConn->Signature == ATCPCONN_SIGNATURE);

    ASSERT(pAtcpConn->RefCount > 0);

    pAtcpConn->RefCount--;

    if (pAtcpConn->RefCount == 0)
    {
        if (!(pAtcpConn->Flags & ATCP_CONNECTION_CLOSING))
        {
            fKill = TRUE;
            pAtcpConn->Flags |= ATCP_CONNECTION_CLOSING;
        }
    }

    RELEASE_SPIN_LOCK(&pAtcpConn->SpinLock, OldIrql);

    if (!fKill)
    {
        return;
    }

    // and remove from the list
    ACQUIRE_SPIN_LOCK(&RasPortDesc->pd_Lock, &OldIrql);
    RemoveEntryList(&pAtcpConn->Linkage);
    RELEASE_SPIN_LOCK(&RasPortDesc->pd_Lock, OldIrql);

    // free that memory
    AtalkFreeMemory(pAtcpConn);

	DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
        ("DerefPPPConn: PPP connection %lx freed\n",pAtcpConn));

    ACQUIRE_SPIN_LOCK(&ArapSpinLock, &OldIrql);
    PPPConnections--;
    RELEASE_SPIN_LOCK(&ArapSpinLock, OldIrql);

    // if possible (i.e. if this was the last connection), unlock PPP pages
    AtalkUnlockPPPIfNecessary();
}

//***
//
// Function: FindAndRefPPPConnByAddr
//              Finds the corresponding connection element, given the network
//              address (of the remote client)
//
// Parameters:  destNode - network addr of the destination (remote client)
//              pdwFlags - pointer to a dword to return Flags field
//
// Return:      pointer to the corresponding connection element, if found
//
//***$

PATCPCONN
FindAndRefPPPConnByAddr(
    IN  ATALK_NODEADDR      destNode,
    OUT DWORD               *pdwFlags
)
{
    PATCPCONN    pAtcpConn=NULL;
    PATCPCONN    pAtcpWalker;
    PLIST_ENTRY  pList;
    KIRQL        OldIrql;


    // RAS not configured?
    if (!RasPortDesc)
    {
        return(NULL);
    }

    ACQUIRE_SPIN_LOCK(&RasPortDesc->pd_Lock, &OldIrql);

    if (!(RasPortDesc->pd_Flags & PD_ACTIVE))
    {
		DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
		    ("FindAndRefPPPConnByAddr: RAS not active, ignoring\n"));
			
        RELEASE_SPIN_LOCK(&RasPortDesc->pd_Lock, OldIrql);
        return(NULL);
    }

    pList = RasPortDesc->pd_PPPConnHead.Flink;

    //
    // walk through all the PPP clients to see if we find ours
    //
    while (pList != &RasPortDesc->pd_PPPConnHead)
    {
        pAtcpWalker = CONTAINING_RECORD(pList, ATCPCONN, Linkage);

        pList = pAtcpWalker->Linkage.Flink;

        ACQUIRE_SPIN_LOCK_DPC(&pAtcpWalker->SpinLock);

        if (ATALK_NODES_EQUAL(&pAtcpWalker->NetAddr, &destNode))
        {
            pAtcpConn = pAtcpWalker;
            pAtcpConn->RefCount++;

            *pdwFlags = pAtcpWalker->Flags;

            RELEASE_SPIN_LOCK_DPC(&pAtcpWalker->SpinLock);
            break;
        }

        RELEASE_SPIN_LOCK_DPC(&pAtcpWalker->SpinLock);
    }

    RELEASE_SPIN_LOCK(&RasPortDesc->pd_Lock, OldIrql);

    return( pAtcpConn );
}



//***
//
// Function: PPPRoutePacketToWan
//              This routine picks up a packet from the lan, checks to see if
//              it must be forwarded to any of the PPP clients and does the
//              good deed.
//
// Parameters:  pDestAddr - who is this packet addressed to? (potentially bcast)
//              pSrcAddr  - who sent this packet
//              Protocol  - what packet is it? (ATP, NBP, etc.)
//              packet    - buffer containing the packet
//              PktLen    - how big is the packet
//              broadcast - is this a broadcast packet?
//              pDelivered - set on return: did we forward it to any dial-in
//                           client (set to TRUE only for directed dgrams)
//
// Return:      none
//
//***$

VOID
PPPRoutePacketToWan(
	IN  ATALK_ADDR	*pDestAddr,
	IN  ATALK_ADDR	*pSrcAddr,
    IN  BYTE         Protocol,
	IN	PBYTE		 packet,
	IN	USHORT		 PktLen,
    IN  USHORT       HopCount,
    IN  BOOLEAN      broadcast,
    OUT PBOOLEAN     pDelivered
)
{

    KIRQL           OldIrql;
    PATCPCONN       pAtcpConn;
    PATCPCONN       pPrevAtcpConn;
    PLIST_ENTRY     pConnList;
    ATALK_NODEADDR  DestNode;
    ATALK_NODEADDR  SourceNode;
    DWORD           StatusCode;
    DWORD           dwFlags;
    BOOLEAN         fRtmpPacket=FALSE;


    DBG_PPP_CHECK_PAGED_CODE();

    // assume for now
    *pDelivered = FALSE;

    //
    // if this is a unicast, see if a PPP client with this dest address exists
    //
    if (!broadcast)
    {

        DestNode.atn_Network = pDestAddr->ata_Network;
        DestNode.atn_Node    = pDestAddr->ata_Node;

        // first and foremost, let's find the puppy
        pAtcpConn = FindAndRefPPPConnByAddr(DestNode, &dwFlags);

        if (pAtcpConn == NULL)
        {
            return;
        }

        // let the caller know that we found who this data was meant for
        *pDelivered = TRUE;

        // if this dude isn't ready to route data, drop this packet!
        if (!(dwFlags & ATCP_CONNECTION_UP))
        {
		    DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_WARN,
		        ("PPPRoutePacketToWan: dropping pkt on %lx, line-up not done\n",pAtcpConn));

            // remove the refcount put in by FindAndRefPPPConnByAddr
            DerefPPPConn(pAtcpConn);

            return;
        }


        // send the packet out
        PPPTransmit(pAtcpConn,
                    pDestAddr,
                    pSrcAddr,
                    Protocol,
                    packet,
                    PktLen,
                    HopCount);

        // remove the refcount put in by FindAndRefPPPConnByAddr
        DerefPPPConn(pAtcpConn);

        return;
    }



    //
    // it's a broadcast packet: must send it to all the PPP guys
    //

    if (packet[LDDP_PROTO_TYPE_OFFSET] == DDPPROTO_RTMPRESPONSEORDATA)
    {
        fRtmpPacket = TRUE;
    }

    pAtcpConn = NULL;
    pPrevAtcpConn = NULL;

    SourceNode.atn_Network = pSrcAddr->ata_Network;
    SourceNode.atn_Node    = pSrcAddr->ata_Node;

    while (1)
    {
        ACQUIRE_SPIN_LOCK(&RasPortDesc->pd_Lock, &OldIrql);

        //
        // first, let's find the right connection to work on
        //
        while (1)
        {
            // if we're in the middle of the list, get to the next guy
            if (pAtcpConn != NULL)
            {
                pConnList = pAtcpConn->Linkage.Flink;
            }
            // we're just starting: get the guy at the head of the list
            else
            {
                pConnList = RasPortDesc->pd_PPPConnHead.Flink;
            }

            // finished all?
            if (pConnList == &RasPortDesc->pd_PPPConnHead)
            {
                RELEASE_SPIN_LOCK(&RasPortDesc->pd_Lock, OldIrql);

                if (pPrevAtcpConn)
                {
                    DerefPPPConn(pPrevAtcpConn);
                }
                return;
            }

            pAtcpConn = CONTAINING_RECORD(pConnList, ATCPCONN, Linkage);

            ACQUIRE_SPIN_LOCK_DPC(&pAtcpConn->SpinLock);

            // if this guy sent out the broadcast, don't send it back to him!
            if (ATALK_NODES_EQUAL(&pAtcpConn->NetAddr, &SourceNode))
            {
		        DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_WARN,
		            ("PPPRoutePacketToWan: skipping bcast from source\n"));
                RELEASE_SPIN_LOCK_DPC(&pAtcpConn->SpinLock);
                continue;
            }

            // if this dude isn't ready to route data, skip
            if (!(pAtcpConn->Flags & ATCP_CONNECTION_UP))
            {
		        DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_WARN,
		            ("PPPRoutePacketToWan: skipping %lx because line-up not done\n",pAtcpConn));
                RELEASE_SPIN_LOCK_DPC(&pAtcpConn->SpinLock);
                continue;
            }

            //
            // if this is an RTMP packet and the client doesn't want those
            // packets, don't send
            //
            if (fRtmpPacket && (pAtcpConn->Flags & ATCP_SUPPRESS_RTMP))
            {
		        DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_WARN,
		            ("PPPRoutePacketToWan: skipping %lx because RTMP data to be suppressed\n",pAtcpConn));
                RELEASE_SPIN_LOCK_DPC(&pAtcpConn->SpinLock);
                continue;
            }

            // if this dude wants all broadcasts suppressed, skip it
            if (pAtcpConn->Flags & ATCP_SUPPRESS_ALLBCAST)
            {
		        DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_WARN,
		            ("PPPRoutePacketToWan: skipping %lx because all bcast to be suppressed\n",pAtcpConn));
                RELEASE_SPIN_LOCK_DPC(&pAtcpConn->SpinLock);
                continue;
            }

            // let's make sure this connection stays around till we finish
            pAtcpConn->RefCount++;

            RELEASE_SPIN_LOCK_DPC(&pAtcpConn->SpinLock);

            break;
        }

        RELEASE_SPIN_LOCK(&RasPortDesc->pd_Lock, OldIrql);

        //
        // remove the refcount on the previous connection we put in earlier
        //
        if (pPrevAtcpConn)
        {
            DerefPPPConn(pPrevAtcpConn);
        }

        ASSERT(pPrevAtcpConn != pAtcpConn);

        pPrevAtcpConn = pAtcpConn;

        PPPTransmit(pAtcpConn,
                    pDestAddr,
                    pSrcAddr,
                    Protocol,
                    packet,
                    PktLen,
                    HopCount);
    }

}


//***
//
// Function: PPPTransmit
//              This routine sends the packet out to a PPP destination
//
// Parameters:  pAtcpConn - PPP connection to send to
//              pDestAddr - who is this packet addressed to? (potentially bcast)
//              pSrcAddr  - who sent this packet
//              Protocol  - what packet is it? (ATP, NBP, etc.)
//              packet    - buffer containing the packet
//              PktLen    - how big is the packet
//              HopCount  - hopcount in the DDP pkt as received
//
// Return:      none
//
//***$

VOID FASTCALL
PPPTransmit(
    IN  PATCPCONN    pAtcpConn,
	IN  ATALK_ADDR	*pDestAddr,
	IN  ATALK_ADDR	*pSrcAddr,
    IN  BYTE         Protocol,
	IN	PBYTE		 packet,
	IN	USHORT		 PktLen,
    IN  USHORT       HopCount
)
{

    PBUFFER_DESC        pBufCopy;
    PBUFFER_DESC        pPktDesc;
    SEND_COMPL_INFO     SendInfo;
    PBYTE               pLinkDdpOptHdr;
    PBYTE               pDgram;
    ATALK_ERROR         error;


    DBG_PPP_CHECK_PAGED_CODE();

    // allocate a buffer and bufdesc to copy the incoming packet (data portion)
	pBufCopy = AtalkAllocBuffDesc(NULL,PktLen,(BD_FREE_BUFFER | BD_CHAR_BUFFER));

	if (pBufCopy == NULL)
	{
		DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
		    ("PPPTransmit: alloc BufDesc failed\n"));
		return;
	}

    // copy the data in
	AtalkCopyBufferToBuffDesc(packet, PktLen, pBufCopy, 0);

    // allocate a buffdesc to hold headers
	AtalkNdisAllocBuf(&pPktDesc);
	if (pPktDesc == NULL)
	{
	    DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
	        ("PPPTransmit: couldn't alloc ndis bufdesc\n"));

        AtalkFreeBuffDesc(pBufCopy);
		return;
	}

    // put in the Mac header (NdisWan's header)
	pLinkDdpOptHdr = pPktDesc->bd_CharBuffer;

    AtalkNdisBuildPPPPHdr(pLinkDdpOptHdr, pAtcpConn);

    // make up the DDP header
	pDgram = pLinkDdpOptHdr + WAN_LINKHDR_LEN;

	*pDgram++ = (DDP_HOP_COUNT(HopCount) + DDP_MSB_LEN(PktLen + LDDP_HDR_LEN));
	
	PUTSHORT2BYTE(pDgram, (PktLen + LDDP_HDR_LEN));
	pDgram++;
	
	PUTSHORT2SHORT(pDgram, 0);        
	pDgram += sizeof(USHORT);
	
	PUTSHORT2SHORT(pDgram, pDestAddr->ata_Network);
	pDgram += sizeof(USHORT);
	
	PUTSHORT2SHORT(pDgram, pSrcAddr->ata_Network);
	pDgram += sizeof(USHORT);
	
	*pDgram++ = pDestAddr->ata_Node;
	*pDgram++ = pSrcAddr->ata_Node;
	*pDgram++ = pDestAddr->ata_Socket;
	*pDgram++ = pSrcAddr->ata_Socket;
	*pDgram++ = Protocol;
	
	//	Set length in the buffer descriptor.
	AtalkSetSizeOfBuffDescData(pPktDesc, WAN_LINKHDR_LEN + LDDP_HDR_LEN);

    // chain in this bufdesc
	AtalkPrependBuffDesc(pPktDesc, pBufCopy);

	INTERLOCKED_ADD_STATISTICS(&RasPortDesc->pd_PortStats.prtst_DataOut,
							   AtalkSizeBuffDesc(pPktDesc),
							   &AtalkStatsLock.SpinLock);

    // set up our completion info
    SendInfo.sc_TransmitCompletion = PPPTransmitCompletion;
    SendInfo.sc_Ctx1 = RasPortDesc;
    SendInfo.sc_Ctx2 = pBufCopy;
    SendInfo.sc_Ctx3 = pAtcpConn;

	//	send the packet
	error = AtalkNdisSendPacket(RasPortDesc,
	    						pPktDesc,
		    					AtalkDdpSendComplete,
			    				&SendInfo);
	
	if (!ATALK_SUCCESS(error))
	{
	    DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
	        ("PPPTransmit: AtalkNdisSendPacket failed %ld\n",error));

	    AtalkDdpSendComplete(NDIS_STATUS_FAILURE,
		    				 pPktDesc,
			    			 &SendInfo);
	}

}


//***
//
// Function: PPPTransmitCompletion
//              This is the completion routine for PPPTransmit, and is called
//              by NDIS after the packet is sent out (or failure occurs)
//
// Parameters:  Status - how did the send go
//              pSendInfo - completion info
//
// Return:      none
//
//***$

VOID FASTCALL
PPPTransmitCompletion(
    IN  NDIS_STATUS         Status,
    IN  PSEND_COMPL_INFO    pSendInfo
)
{
    PBUFFER_DESC    pBuffDesc;

    DBG_PPP_CHECK_PAGED_CODE();

    pBuffDesc = (PBUFFER_DESC)(pSendInfo->sc_Ctx2);

    ASSERT(pBuffDesc != NULL);
    ASSERT(pBuffDesc->bd_Flags & (BD_CHAR_BUFFER | BD_FREE_BUFFER));

    if (Status != 0)
    {
		DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
		    ("PPPTransmitCompletion: send failed, %lx on %lx\n",
            Status,pSendInfo->sc_Ctx3));
    }

    AtalkFreeBuffDesc(pBuffDesc);
}


//***
//
// Function: PPPGetDynamicAddr
//              This routine gets a network address for a PPP dial-in client.
//              It does the same AARP logic as if it were acquiring a
//              node-address for the host itself.
//
// Parameters:  pAtcpConn - the connection for which we need a network addr
//
// Return:      ARAPERR_NO_ERROR if all went well.
//
//***$

DWORD
PPPGetDynamicAddr(
    IN PATCPCONN       pAtcpConn
)
{
    ATALK_NODEADDR      NetAddr;
    ATALK_NETWORKRANGE  NetRange;
    BOOLEAN             fFound=FALSE;
    KIRQL               OldIrql;
    DWORD               StatusCode=ARAPERR_STACK_NOT_UP;



    DBG_PPP_CHECK_PAGED_CODE();

    ASSERT(AtalkDefaultPort != NULL);

    //
    // go find a node address on the default port (we'll never get this far if
    // default port isn't up yet)
    //
    ACQUIRE_SPIN_LOCK(&pAtcpConn->SpinLock, &OldIrql);

    ASSERT(!(pAtcpConn->Flags & ATCP_FINDING_NODE));

    pAtcpConn->Flags |= ATCP_FINDING_NODE;

    RELEASE_SPIN_LOCK(&pAtcpConn->SpinLock, OldIrql);

    AtalkLockInitIfNecessary();

    // if we are stuck in the startup range, use that range for dial-in guys, too
    if (WITHIN_NETWORK_RANGE(AtalkDefaultPort->pd_NetworkRange.anr_LastNetwork,
                             &AtalkStartupNetworkRange))
    {
        NetRange = AtalkStartupNetworkRange;
    }
    else
    {
        NetRange = AtalkDefaultPort->pd_NetworkRange;
    }
    fFound = AtalkInitAarpForNodeInRange(AtalkDefaultPort,
                                         (PVOID)pAtcpConn,
                                         TRUE,
                                         NetRange,
                                         &NetAddr);


    AtalkUnlockInitIfNecessary();

    ACQUIRE_SPIN_LOCK(&pAtcpConn->SpinLock, &OldIrql);

    pAtcpConn->Flags &= ~ATCP_FINDING_NODE;

    if (fFound)
    {
        // store that adddr!
        pAtcpConn->NetAddr.atn_Network = NetAddr.atn_Network;
        pAtcpConn->NetAddr.atn_Node = NetAddr.atn_Node;

        pAtcpConn->Flags |= ATCP_NODE_IN_USE;
        StatusCode = ARAPERR_NO_ERROR;

	    DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_INFO,
    	    ("PPPGetDynamicAddr: found addr for PPP client = %lx %lx\n",
                NetAddr.atn_Network,NetAddr.atn_Node));
    }
    else
    {
        DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
	        ("ArapGetDynamicAddr: PPP: no more network addr left?\n"));

        pAtcpConn->Flags &= ~ATCP_NODE_IN_USE;
        pAtcpConn->NetAddr.atn_Network = 0;
        pAtcpConn->NetAddr.atn_Node = 0;
        StatusCode = ARAPERR_NO_NETWORK_ADDR;
    }

    RELEASE_SPIN_LOCK(&pAtcpConn->SpinLock, OldIrql);

    return(StatusCode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\atalk\sys\rtmp.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

	rtmp.h

Abstract:

	This module contains information for the Routing Table Maintainance Protocol.

Author:

	Jameel Hyder (jameelh@microsoft.com)
	Nikhil Kamkolkar (nikhilk@microsoft.com)

Revision History:
	19 Jun 1992		Initial Version

Notes:	Tab stop: 4
--*/

#ifndef	_RTMP_
#define	_RTMP_

// RTMP specific data.

#define RTMP_REQUEST					1
#define RTMP_DATA_REQUEST				2
#define RTMP_ENTIRE_DATA_REQUEST		3

#define RTMP_REQ_DATAGRAM_SIZE			1
#define RTMP_DATA_MIN_SIZE_EXT			10
#define RTMP_DATA_MIN_SIZE_NON_EXT		7

#define RTMP_RESPONSE_MAX_SIZE			10

#define RTMP_VERSION				    (BYTE)0x82

#define RTMP_TUPLE_WITHRANGE			(BYTE)0x80
#define RTMP_TUPLE_WITHOUTRANGE		    (BYTE)0x00
#define RTMP_EXT_TUPLE_MASK		    	0x80
#define RTMP_MAX_HOPS			    	0x0F
#define RTMP_NUM_HOPS_MASK		    	0x1F

#define RTMP_EXT_TUPLE_SIZE		    	6

// When trying to find our network number on a non-extended port.

#define RTMP_REQUEST_WAIT				100		// MilliSeconds
#define RTMP_NUM_REQUESTS	    		30

// The actual RTMP routing table. Entries are hashed by target network number
// and contain the port number used to get to the target network, next bridge
// used to get to the target network, the number of hops to that network,
// and entry state (Good, Suspect, or Bad).  Note that with AppleTalk phase II,
// it takes two Validity timers to get from Suspect to Bad, so we let an entry
// go through a PrettyBad state (we won't send these guys when the Send timer goes off).

#define	GOOD				1
#define	SUSPECT				2
#define BAD					3
#define UGLY				4

extern	ATALK_SPIN_LOCK		AtalkRteLock;

#define	RTE_ZONELIST_VALID	0x01
#define	RTE_DELETE			0x80

#define	RTE_SIGNATURE		*(PULONG)"RTMP"
#if	DBG
#define	VALID_RTE(pRte)		((pRte != NULL) && (pRte->rte_Signature == RTE_SIGNATURE))
#else
#define	VALID_RTE(pRte)		(pRte != NULL)
#endif

typedef struct _RoutingTableEntry
{
#if	DBG
	ULONG					rte_Signature;
#endif
	struct _RoutingTableEntry *	rte_Next;
											// Hashed by first network number,
											// overflow buckets.
	PPORT_DESCRIPTOR		rte_PortDesc;	// Port used to access this network range
	LONG					rte_RefCount;	// Reference count
	BYTE					rte_Flags;
	BYTE					rte_State;		// State of the rtmp entry
	BYTE					rte_NumHops;	// Hops to get to net
	ATALK_NETWORKRANGE		rte_NwRange;	// The network range that we represent
	ATALK_NODEADDR 			rte_NextRouter;	// Node number of next router on
											// the way to this net range
	struct _ZONE_LIST	*	rte_ZoneList;	// Valid zones for this net
	ATALK_SPIN_LOCK			rte_Lock;
} RTE, *PRTE;

#define NUM_RTMP_HASH_BUCKETS		15
extern	PRTE *	AtalkRoutingTable;

// To decrease the odds of having to do a scan of the routing tables to
// find where to route a packet, we keep a cache of "recently used routes".
// This cache is checked before we use the "first network number" hash and
// before we resort of a full scan of the routing tables.  The size of this
// cache may want to be increased to get a proportional increase in
// "hit rate".

#define NUM_RECENT_ROUTES		63
extern	PRTE *	AtalkRecentRoutes;

// RTMP timer values:
#define RTMP_SEND_TIMER			100			// In 100ms units
#define RTMP_VALIDITY_TIMER		200			// In 100ms units
#define RTMP_AGING_TIMER		500			// In 100ms units

// RTMP Offsets into the Datagram
#define	RTMP_REQ_CMD_OFF		0
#define	RTMP_SENDER_NW_OFF		0
#define	RTMP_SENDER_IDLEN_OFF	2
#define	RTMP_SENDER_ID_OFF		3
#define	RTMP_VERSION_OFF_NE		6
#define	RTMP_RANGE_START_OFF	4
#define	RTMP_TUPLE_TYPE_OFF		6
#define	RTMP_RANGE_END_OFF		7
#define	RTMP_VERSION_OFF_EXT	9

ATALK_ERROR
AtalkRtmpInit(
	IN	BOOLEAN	Init
);

BOOLEAN
AtalkInitRtmpStartProcessingOnPort(
	IN	PPORT_DESCRIPTOR 	pPortDesc,
	IN	PATALK_NODEADDR		RouterNode
);

extern
VOID
AtalkRtmpPacketIn(
	IN	PPORT_DESCRIPTOR	pPortDesc,
	IN	PDDP_ADDROBJ		pDdpAddr,
	IN	PBYTE				pPkt,
	IN	USHORT				PktLen,
	IN	PATALK_ADDR			pSrcAddr,
	IN	PATALK_ADDR			pDstAddr,
	IN	ATALK_ERROR			ErrorCode,
	IN	BYTE				DdpType,
	IN	PVOID				pHandlerCtx,
	IN	BOOLEAN				OptimizePath,
	IN	PVOID				OptimizeCtx
);

extern
VOID
AtalkRtmpPacketInRouter(
	IN	PPORT_DESCRIPTOR	pPortDesc,
	IN	PDDP_ADDROBJ		pDdpAddr,
	IN	PBYTE				pPkt,
	IN	USHORT              PktLen,
	IN	PATALK_ADDR			pSrcAddr,
	IN	PATALK_ADDR			pDstAddr,
	IN	ATALK_ERROR			ErrorCode,
	IN	BYTE				DdpType,
	IN	PVOID				pHandlerCtx,
	IN	BOOLEAN				OptimizePath,
	IN	PVOID				OptimizeCtx
);

extern
PRTE
AtalkRtmpReferenceRte(
	IN	USHORT				Network
);

extern
BOOLEAN
atalkRtmpRemoveRte(
	IN	USHORT				Network
);

extern
VOID
AtalkRtmpDereferenceRte(
	IN	PRTE				pRte,
	IN	BOOLEAN				LockHeld
);

extern
BOOLEAN
atalkRtmpCreateRte(
	IN	ATALK_NETWORKRANGE	NwRange,
	IN	PPORT_DESCRIPTOR	pPortDesc,
	IN	PATALK_NODEADDR		pNextRouter,
	IN	int					NumHops
);

LONG FASTCALL
AtalkRtmpAgingTimer(
	IN	PTIMERLIST			pContext,
	IN	BOOLEAN				TimerShuttingDown
);

VOID FASTCALL
AtalkRtmpKillPortRtes(
	IN	PPORT_DESCRIPTOR	pPortDesc
);

typedef	struct _RtmpSendDataHdr
{
	BYTE	rsd_RouterNetwork[2];
	BYTE	rsd_IdLength;
} *PRTMPSENDDATAHDR;

typedef	struct _RtmpTupleNonExt
{
	BYTE	rtne_Network[2];
	BYTE	rtne_RangenDist;
} *PRTMPTUPLE;

typedef	struct _RtmpTupleExt
{
	BYTE	rtne_NetworkStart[2];
	BYTE	rtne_RangenDist;
	BYTE	rtne_NetworkEnd[2];
	BYTE	rtne_Version;
} *PRTMPTUPLEEXT;

extern	TIMERLIST	atalkRtmpVTimer;

extern  BOOLEAN     atalkRtmpVdtTmrRunning;

LOCAL VOID
atalkRtmpSendRoutingData(
	IN	PPORT_DESCRIPTOR	pPortDesc,
	IN	PATALK_ADDR			pDstAddr,
	IN	BOOLEAN				fSplitHorizon
);

LOCAL BOOLEAN
atalkRtmpGetOrSetNetworkNumber(
	IN	PPORT_DESCRIPTOR	pPortDesc,
	IN	USHORT				SuggestedNetwork
);

LOCAL LONG FASTCALL
atalkRtmpSendTimer(
	IN	PTIMERLIST			pContext,
	IN	BOOLEAN				TimerShuttingDown
);

LOCAL LONG FASTCALL
atalkRtmpValidityTimer(
	IN	PTIMERLIST			pContext,
	IN	BOOLEAN				TimerShuttingDown
);

LOCAL VOID FASTCALL
atalkRtmpSendComplete(
	IN	NDIS_STATUS			Status,
	IN	PSEND_COMPL_INFO	pSendInfo
);

#endif	// _RTMP_


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\atalk\sys\rtmp.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

	rtmp.c

Abstract:

	This module implements the rtmp.

Author:

	Jameel Hyder (jameelh@microsoft.com)
	Nikhil Kamkolkar (nikhilk@microsoft.com)

Revision History:
	26 Feb 1993		Initial Version

Notes:	Tab stop: 4
--*/

#include <atalk.h>
#pragma hdrstop
#define	FILENUM		RTMP

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, AtalkRtmpInit)
#pragma alloc_text(PAGEINIT, AtalkInitRtmpStartProcessingOnPort)
#pragma alloc_text(PAGEINIT, atalkRtmpGetOrSetNetworkNumber)
#pragma alloc_text(PAGEINIT, AtalkRtmpKillPortRtes)
#pragma alloc_text(PAGE_RTR, AtalkRtmpPacketInRouter)
#pragma alloc_text(PAGE_RTR, AtalkRtmpReferenceRte)
#pragma alloc_text(PAGE_RTR, AtalkRtmpDereferenceRte)
#pragma alloc_text(PAGE_RTR, atalkRtmpCreateRte)
#pragma alloc_text(PAGE_RTR, atalkRtmpRemoveRte)
#pragma alloc_text(PAGE_RTR, atalkRtmpSendTimer)
#pragma alloc_text(PAGE_RTR, atalkRtmpValidityTimer)
#pragma alloc_text(PAGE_RTR, atalkRtmpSendRoutingData)
#endif


/***	AtalkRtmpInit
 *
 */
ATALK_ERROR
AtalkRtmpInit(
	IN	BOOLEAN	Init
)
{
	if (Init)
	{
		// Allocate space for routing tables and recent routes
		AtalkRoutingTable =
				(PRTE *)AtalkAllocZeroedMemory(sizeof(PRTE) * NUM_RTMP_HASH_BUCKETS);
		AtalkRecentRoutes =
				(PRTE *)AtalkAllocZeroedMemory(sizeof(PRTE) * NUM_RECENT_ROUTES);
		if ((AtalkRecentRoutes == NULL) || (AtalkRoutingTable == NULL))
		{
			if (AtalkRoutingTable != NULL)
            {
				AtalkFreeMemory(AtalkRoutingTable);
                AtalkRoutingTable = NULL;
            }
			return ATALK_RESR_MEM;
		}

		INITIALIZE_SPIN_LOCK(&AtalkRteLock);
	}
	else
	{
		// At this point, we are unloading and there are no race conditions
		// or lock contentions. Do not bother locking down the rtmp tables
		if (AtalkRoutingTable != NULL)
		{
			int		i;
			PRTE	pRte;

			for (i = 0; i < NUM_RTMP_HASH_BUCKETS; i++)
			{
				ASSERT(AtalkRoutingTable[i] == NULL);
			}
			AtalkFreeMemory(AtalkRoutingTable);
			AtalkRoutingTable = NULL;
		}
		if (AtalkRecentRoutes != NULL)
		{
			AtalkFreeMemory(AtalkRecentRoutes);
			AtalkRecentRoutes = NULL;
		}
	}
	return ATALK_NO_ERROR;
}

BOOLEAN
AtalkInitRtmpStartProcessingOnPort(
	IN	PPORT_DESCRIPTOR 	pPortDesc,
	IN	PATALK_NODEADDR		pRouterNode
)
{
	ATALK_ADDR		closeAddr;
	ATALK_ERROR		Status;
	PRTE			pRte;
	KIRQL			OldIrql;
	BOOLEAN			rc = FALSE;
    PDDP_ADDROBJ    pRtDdpAddr=NULL;

	ASSERT (KeGetCurrentIrql() == LOW_LEVEL);

	// For extended networks, the process of acquiring the node has done most of the work
	ACQUIRE_SPIN_LOCK(&pPortDesc->pd_Lock, &OldIrql);
	do
	{
		if (EXT_NET(pPortDesc))
		{
			if ((pPortDesc->pd_Flags & PD_SEEN_ROUTER_RECENTLY) &&
				(pPortDesc->pd_InitialNetworkRange.anr_FirstNetwork != UNKNOWN_NETWORK))
			{
				if (!NW_RANGE_EQUAL(&pPortDesc->pd_InitialNetworkRange,
									&pPortDesc->pd_NetworkRange))
				{
					DBGPRINT(DBG_COMP_RTMP, DBG_LEVEL_ERR,
							("AtalkRtmpStartProcessingOnPort: Initial range %d-%d, Actual %d-%d\n",
							pPortDesc->pd_InitialNetworkRange.anr_FirstNetwork,
							pPortDesc->pd_InitialNetworkRange.anr_LastNetwork,
							pPortDesc->pd_NetworkRange.anr_FirstNetwork,
							pPortDesc->pd_NetworkRange.anr_LastNetwork));
					LOG_ERRORONPORT(pPortDesc,
									EVENT_ATALK_INVALID_NETRANGE,
									0,
									NULL,
									0);
	
					// Change InitialNetwork range so that it matches the net
					pPortDesc->pd_InitialNetworkRange = pPortDesc->pd_NetworkRange;
				}
			}
	
			// We are the seed router, so seed if possible
			if (!(pPortDesc->pd_Flags & PD_SEEN_ROUTER_RECENTLY) &&
				!(pPortDesc->pd_Flags & PD_SEED_ROUTER))
			{
				RELEASE_SPIN_LOCK(&pPortDesc->pd_Lock, OldIrql);
				break;
			}
			if (!(pPortDesc->pd_Flags & PD_SEEN_ROUTER_RECENTLY))
			{
				pPortDesc->pd_NetworkRange = pPortDesc->pd_InitialNetworkRange;
			}
		}
	
		// For non-extended network either seed or find our network number
		else
		{
			PATALK_NODE		pNode;
			USHORT			SuggestedNetwork;
			int				i;
	
			SuggestedNetwork = UNKNOWN_NETWORK;
			if (pPortDesc->pd_Flags & PD_SEED_ROUTER)
				SuggestedNetwork = pPortDesc->pd_InitialNetworkRange.anr_FirstNetwork;
			RELEASE_SPIN_LOCK(&pPortDesc->pd_Lock, OldIrql);
			if (!atalkRtmpGetOrSetNetworkNumber(pPortDesc, SuggestedNetwork))
			{
				DBGPRINT(DBG_COMP_RTMP, DBG_LEVEL_ERR,
						("AtalkRtmpStartProcessingOnPort: atalkRtmpGetOrSetNetworkNumber failed\n"));
				break;
			}
	
			ACQUIRE_SPIN_LOCK(&pPortDesc->pd_Lock, &OldIrql);
			if (!(pPortDesc->pd_Flags & PD_SEEN_ROUTER_RECENTLY))
			{
				pPortDesc->pd_NetworkRange.anr_FirstNetwork =
				pPortDesc->pd_NetworkRange.anr_LastNetwork =
								pPortDesc->pd_InitialNetworkRange.anr_FirstNetwork;
			}
	
			// We'd have allocated a node with network 0, fix it up. Alas the fixup
			// also involves all the sockets so far created on this node.
			pNode = pPortDesc->pd_Nodes;
			ASSERT((pNode != NULL) && (pPortDesc->pd_RouterNode == pNode));
	
			pNode->an_NodeAddr.atn_Network =
			pPortDesc->pd_LtNetwork =
			pPortDesc->pd_ARouter.atn_Network =
			pRouterNode->atn_Network = pPortDesc->pd_NetworkRange.anr_FirstNetwork;
	
			ACQUIRE_SPIN_LOCK_DPC(&pNode->an_Lock);
			for (i = 0; i < NODE_DDPAO_HASH_SIZE; i ++)
			{
				PDDP_ADDROBJ	pDdpAddr;
	
				for (pDdpAddr = pNode->an_DdpAoHash[i];
					 pDdpAddr != NULL;
					 pDdpAddr = pDdpAddr->ddpao_Next)
				{
					ACQUIRE_SPIN_LOCK_DPC(&pDdpAddr->ddpao_Lock);
					pDdpAddr->ddpao_Addr.ata_Network =
								pPortDesc->pd_NetworkRange.anr_FirstNetwork;
					RELEASE_SPIN_LOCK_DPC(&pDdpAddr->ddpao_Lock);
				}
			}
			RELEASE_SPIN_LOCK_DPC(&pNode->an_Lock);
		}
	
		// We're the router now. Mark it appropriately
		pPortDesc->pd_Flags |= (PD_ROUTER_RUNNING | PD_SEEN_ROUTER_RECENTLY);
		KeSetEvent(&pPortDesc->pd_SeenRouterEvent, IO_NETWORK_INCREMENT, FALSE);
		pPortDesc->pd_ARouter = *pRouterNode;
	
		RELEASE_SPIN_LOCK(&pPortDesc->pd_Lock, OldIrql);
	
		// Before creating a Rte for ourselves, check if there is an Rte with
		// the same network range already. This will happen, for instance, when
		// we are routing on ports which other routers are also seeding and we
		// got to know of our port from the other router on another port !!!
		do
		{
			pRte = AtalkRtmpReferenceRte(pPortDesc->pd_NetworkRange.anr_FirstNetwork);
			if (pRte != NULL)
			{
				ACQUIRE_SPIN_LOCK(&pRte->rte_Lock, &OldIrql);
				pRte->rte_RefCount --;		// Take away creation reference
				pRte->rte_Flags |= RTE_DELETE;
				RELEASE_SPIN_LOCK(&pRte->rte_Lock, OldIrql);
		
				AtalkRtmpDereferenceRte(pRte, FALSE);
		
				DBGPRINT(DBG_COMP_RTMP, DBG_LEVEL_ERR,
						("AtalkRtmpStartProcessing: Invalid Rte for port %Z's range found\n",
						&pPortDesc->pd_AdapterKey));
			}
		} while (pRte != NULL);
	
		// Now we get to really, really create our own Rte !!!
		if (!atalkRtmpCreateRte(pPortDesc->pd_NetworkRange,
								pPortDesc,
								pRouterNode,
								0))
		{
			DBGPRINT(DBG_COMP_RTMP, DBG_LEVEL_ERR,
					("AtalkRtmpStartProcessingOnPort: Could not create Rte\n"));
			break;
		}
	
		// Switch the incoming rtmp handler to the router version
		closeAddr.ata_Network = pRouterNode->atn_Network;
		closeAddr.ata_Node = pRouterNode->atn_Node;
		closeAddr.ata_Socket = RTMP_SOCKET;
	
		ASSERT (KeGetCurrentIrql() == LOW_LEVEL);
	
		AtalkDdpInitCloseAddress(pPortDesc, &closeAddr);
		Status = AtalkDdpOpenAddress(pPortDesc,
								RTMP_SOCKET,
								pRouterNode,
								AtalkRtmpPacketInRouter,
								NULL,
								DDPPROTO_ANY,
								NULL,
								&pRtDdpAddr);
		if (!ATALK_SUCCESS(Status))
		{
			DBGPRINT(DBG_COMP_RTMP, DBG_LEVEL_ERR,
					("AtalkRtmpStartProcessingOnPort: AtalkDdpOpenAddress failed %ld\n",
					Status));
			DBGPRINT(DBG_COMP_RTMP, DBG_LEVEL_ERR,
					("AtalkRtmpStartProcessingOnPort: Unable to open the routers rtmp socket %ld\n",
					Status));
			
			break;
		}

        // mark the fact that this is an "internal" socket
        pRtDdpAddr->ddpao_Flags |= DDPAO_SOCK_INTERNAL;
	
		// Start the timers now. Reference the port for each timer.
		AtalkPortReferenceByPtr(pPortDesc, &Status);
		if (!ATALK_SUCCESS(Status))
		{
			break;
		}
		AtalkTimerInitialize(&pPortDesc->pd_RtmpSendTimer,
							 atalkRtmpSendTimer,
							 RTMP_SEND_TIMER);
		AtalkTimerScheduleEvent(&pPortDesc->pd_RtmpSendTimer);
	
		if (!atalkRtmpVdtTmrRunning)
		{
			AtalkTimerInitialize(&atalkRtmpVTimer,
								 atalkRtmpValidityTimer,
								 RTMP_VALIDITY_TIMER);
			AtalkTimerScheduleEvent(&atalkRtmpVTimer);

            atalkRtmpVdtTmrRunning = TRUE;
		}
		rc = TRUE;
	} while (FALSE);

	return rc;
}


// Private data structure used between AtalkRtmpPacketIn and atalkRtmpGetNwInfo
typedef struct _QueuedGetNwInfo
{
	WORK_QUEUE_ITEM		qgni_WorkQItem;
	PPORT_DESCRIPTOR	qgni_pPortDesc;
	PDDP_ADDROBJ		qgni_pDdpAddr;
	ATALK_NODEADDR		qgni_SenderNode;
	ATALK_NETWORKRANGE	qgni_CableRange;
	BOOLEAN				qgni_FreeThis;
} QGNI, *PQGNI;


VOID
atalkRtmpGetNwInfo(
	IN	PQGNI	pQgni
)
{
	PPORT_DESCRIPTOR	pPortDesc = pQgni->qgni_pPortDesc;
	PDDP_ADDROBJ		pDdpAddr = pQgni->qgni_pDdpAddr;
	KIRQL				OldIrql;

	ASSERT (KeGetCurrentIrql() == LOW_LEVEL);

	AtalkZipGetNetworkInfoForNode(pPortDesc,
									&pDdpAddr->ddpao_Node->an_NodeAddr,
									FALSE);

	ACQUIRE_SPIN_LOCK(&pPortDesc->pd_Lock, &OldIrql);
	
	if (!(pPortDesc->pd_Flags & PD_ROUTER_RUNNING))
	{
		// Well, we heard from a router. Copy the information. Don't do it
		// if we're a router [maybe a proxy node on arouting port] -- we don't
		// want "aRouter" to shift away from "us."
		pPortDesc->pd_Flags |= PD_SEEN_ROUTER_RECENTLY;
		KeSetEvent(&pPortDesc->pd_SeenRouterEvent, IO_NETWORK_INCREMENT, FALSE);
		pPortDesc->pd_LastRouterTime = AtalkGetCurrentTick();
		pPortDesc->pd_ARouter = pQgni->qgni_SenderNode;
		pPortDesc->pd_NetworkRange = pQgni->qgni_CableRange;
	}
	
	RELEASE_SPIN_LOCK(&pPortDesc->pd_Lock, OldIrql);

	if (pQgni->qgni_FreeThis)
	{
		AtalkDdpDereference(pDdpAddr);
		AtalkFreeMemory(pQgni);
	}
}

VOID
AtalkRtmpPacketIn(
	IN	PPORT_DESCRIPTOR	pPortDesc,
	IN	PDDP_ADDROBJ		pDdpAddr,
	IN	PBYTE				pPkt,
	IN	USHORT				PktLen,
	IN	PATALK_ADDR			pSrcAddr,
	IN	PATALK_ADDR			pDstAddr,
	IN	ATALK_ERROR			ErrorCode,
	IN	BYTE				DdpType,
	IN	PVOID				pHandlerCtx,
	IN	BOOLEAN				OptimizedPath,
	IN	PVOID				OptimizeCtx
)			
{
	ATALK_NODEADDR		SenderNode;
	ATALK_NETWORKRANGE	CableRange;
	ATALK_ERROR			Status;
	TIME				TimeS, TimeE, TimeD;

	ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

	TimeS = KeQueryPerformanceCounter(NULL);
	do
	{
		if (ErrorCode == ATALK_SOCKET_CLOSED)
			break;

		else if (ErrorCode != ATALK_NO_ERROR)
		{
			break;
		}
	
		if (DdpType != DDPPROTO_RTMPRESPONSEORDATA)
			break;

		// we do not care about non-ext tuples on an extended network
		if ((EXT_NET(pPortDesc)) && (PktLen < (RTMP_RANGE_END_OFF+2)))
		{
			break;
		}

		GETSHORT2SHORT(&SenderNode.atn_Network, pPkt+RTMP_SENDER_NW_OFF);
		if (pPkt[RTMP_SENDER_IDLEN_OFF] != 8)
		{
			AtalkLogBadPacket(pPortDesc,
							  pSrcAddr,
							  pDstAddr,
							  pPkt,
							  PktLen);
			break;
		}

		SenderNode.atn_Node = pPkt[RTMP_SENDER_ID_OFF];

		if (EXT_NET(pPortDesc))
		{
			GETSHORT2SHORT(&CableRange.anr_FirstNetwork, pPkt+RTMP_RANGE_START_OFF);
			GETSHORT2SHORT(&CableRange.anr_LastNetwork, pPkt+RTMP_RANGE_END_OFF);
			if (!AtalkCheckNetworkRange(&CableRange))
				break;
		}

		// On a non-extended network, we do not have to do any checking.
		// Just copy the information into A-ROUTER and THIS-NET
		if (!EXT_NET(pPortDesc))
		{
			ACQUIRE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);

			pPortDesc->pd_Flags |= PD_SEEN_ROUTER_RECENTLY;
			KeSetEvent(&pPortDesc->pd_SeenRouterEvent, IO_NETWORK_INCREMENT, FALSE);
			pPortDesc->pd_LastRouterTime = AtalkGetCurrentTick();
			pPortDesc->pd_ARouter = SenderNode;
			if (pPortDesc->pd_NetworkRange.anr_FirstNetwork == UNKNOWN_NETWORK)
			{
				PATALK_NODE	pNode;
				LONG		i;

				pDdpAddr->ddpao_Node->an_NodeAddr.atn_Network =
					pPortDesc->pd_NetworkRange.anr_FirstNetwork =
					pPortDesc->pd_NetworkRange.anr_LastNetwork = SenderNode.atn_Network;

				pNode = pPortDesc->pd_Nodes;
				ASSERT (pNode != NULL);
		
				// Fixup all sockets to have the correct network numbers.
				ACQUIRE_SPIN_LOCK_DPC(&pNode->an_Lock);
				for (i = 0; i < NODE_DDPAO_HASH_SIZE; i ++)
				{
					PDDP_ADDROBJ	pDdpAddr;
		
					for (pDdpAddr = pNode->an_DdpAoHash[i];
						 pDdpAddr != NULL;
						 pDdpAddr = pDdpAddr->ddpao_Next)
					{
						PREGD_NAME	pRegdName;
						PPEND_NAME	pPendName;

						ACQUIRE_SPIN_LOCK_DPC(&pDdpAddr->ddpao_Lock);
						DBGPRINT(DBG_COMP_RTMP, DBG_LEVEL_INFO,
								("Setting socket %d to network %d\n",
								pDdpAddr->ddpao_Addr.ata_Socket, SenderNode.atn_Network));
						pDdpAddr->ddpao_Addr.ata_Network = SenderNode.atn_Network;

						// Now all regd/pend name tuples as well
						for (pRegdName = pDdpAddr->ddpao_RegNames;
							 pRegdName != NULL;
							 pRegdName = pRegdName->rdn_Next)
						{
							pRegdName->rdn_Tuple.tpl_Address.ata_Network = SenderNode.atn_Network;
						}

						for (pPendName = pDdpAddr->ddpao_PendNames;
							 pPendName != NULL;
							 pPendName = pPendName->pdn_Next)
						{
							ACQUIRE_SPIN_LOCK_DPC(&pPendName->pdn_Lock);
							pPendName->pdn_pRegdName->rdn_Tuple.tpl_Address.ata_Network = SenderNode.atn_Network;
							RELEASE_SPIN_LOCK_DPC(&pPendName->pdn_Lock);
						}

						RELEASE_SPIN_LOCK_DPC(&pDdpAddr->ddpao_Lock);
					}
				}
				RELEASE_SPIN_LOCK_DPC(&pNode->an_Lock);
			}
			else if (pPortDesc->pd_NetworkRange.anr_FirstNetwork != SenderNode.atn_Network)
			{
				AtalkLogBadPacket(pPortDesc,
								  pSrcAddr,
								  pDstAddr,
								  pPkt,
								  PktLen);
			}
			RELEASE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);
			break;
		}

		// On extended networks, we may want to reject the information: If we
		// already know about a router, the cable ranges must exacly match; If
		// we don't know about a router, our node's network number must be
		// within the cable range specified by the first tuple. The latter
		// test will discard the information if our node is in the startup
		// range (which is the right thing to do).
		if (pPortDesc->pd_Flags & PD_SEEN_ROUTER_RECENTLY)
		{
			if (!NW_RANGE_EQUAL(&CableRange, &pPortDesc->pd_NetworkRange))
				break;
		}

		// Okay, we've seen a valid Rtmp data, this should allow us to find the
		// zone name for the port. We do this outside of the
		// "PD_SEEN_ROUTER_RECENTLY" case because the first time a router
		// send out an Rtmp data it may not know everything yet, or
		// AtalkZipGetNetworkInfoForNode() may really do a
		// hard wait and we may need to try it a second time (due to not
		// repsonding to Aarp LocateNode's the first time through... the
		// second time our addresses should be cached by the remote router
		// and he won't need to do a LocateNode again).

		if (!(pPortDesc->pd_Flags & PD_VALID_DESIRED_ZONE))
		{
			if (!WITHIN_NETWORK_RANGE(pDdpAddr->ddpao_Addr.ata_Network,
									  &CableRange))
				break;

			// MAKE THIS ASYNCHRONOUS CONDITIONALLY BASED ON THE CURRENT IRQL
			// A new router, see if it will tell us our zone name.
			if (KeGetCurrentIrql() == LOW_LEVEL)
			{
				QGNI	Qgni;

				Qgni.qgni_pPortDesc = pPortDesc;
				Qgni.qgni_pDdpAddr = pDdpAddr;
				Qgni.qgni_SenderNode = SenderNode;
				Qgni.qgni_CableRange = CableRange;
				Qgni.qgni_FreeThis = FALSE;
				atalkRtmpGetNwInfo(&Qgni);
			}
			else
			{
				PQGNI	pQgni;

				if ((pQgni = AtalkAllocMemory(sizeof(QGNI))) != NULL)
				{
					pQgni->qgni_pPortDesc = pPortDesc;
					pQgni->qgni_pDdpAddr = pDdpAddr;
					pQgni->qgni_SenderNode = SenderNode;
					pQgni->qgni_CableRange = CableRange;
					pQgni->qgni_FreeThis = TRUE;
					AtalkDdpReferenceByPtr(pDdpAddr, &Status);
					ASSERT (ATALK_SUCCESS(Status));
					ExInitializeWorkItem(&pQgni->qgni_WorkQItem,
										 (PWORKER_THREAD_ROUTINE)atalkRtmpGetNwInfo,
										 pQgni);
					ExQueueWorkItem(&pQgni->qgni_WorkQItem, CriticalWorkQueue);
				}
			}
			break;
		}

		// Update the fact that we heard from a router
		if ((pPortDesc->pd_Flags & PD_ROUTER_RUNNING) == 0)
		{
			ACQUIRE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);
			pPortDesc->pd_Flags |= PD_SEEN_ROUTER_RECENTLY;
			KeSetEvent(&pPortDesc->pd_SeenRouterEvent, IO_NETWORK_INCREMENT, FALSE);
			pPortDesc->pd_LastRouterTime = AtalkGetCurrentTick();
			pPortDesc->pd_ARouter = SenderNode;
			pPortDesc->pd_NetworkRange = CableRange;
			RELEASE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);
		}
	} while (FALSE);

	TimeE = KeQueryPerformanceCounter(NULL);
	TimeD.QuadPart = TimeE.QuadPart - TimeS.QuadPart;

	INTERLOCKED_ADD_LARGE_INTGR_DPC(
		&pPortDesc->pd_PortStats.prtst_RtmpPacketInProcessTime,
		TimeD,
		&AtalkStatsLock.SpinLock);

	INTERLOCKED_INCREMENT_LONG_DPC(
		&pPortDesc->pd_PortStats.prtst_NumRtmpPacketsIn,
		&AtalkStatsLock.SpinLock);
}



VOID
AtalkRtmpPacketInRouter(
	IN	PPORT_DESCRIPTOR	pPortDesc,
	IN	PDDP_ADDROBJ		pDdpAddr,
	IN	PBYTE				pPkt,
	IN	USHORT				PktLen,
	IN	PATALK_ADDR			pSrcAddr,
	IN	PATALK_ADDR			pDstAddr,
	IN	ATALK_ERROR			ErrorCode,
	IN	BYTE				DdpType,
	IN	PVOID				pHandlerCtx,
	IN	BOOLEAN				OptimizedPath,
	IN	PVOID				OptimizeCtx
)
{
	PBUFFER_DESC		pBuffDesc = NULL;
	ATALK_NETWORKRANGE	CableRange;
	ATALK_ERROR			Status;
	TIME				TimeS, TimeE, TimeD;
	PRTE				pRte = NULL;
	BYTE				RtmpCmd, NumHops;
	PBYTE				Datagram;
	int					i, index;
	USHORT				RespSize;
	BOOLEAN				RteLocked;
	SEND_COMPL_INFO	 	SendInfo;

	TimeS = KeQueryPerformanceCounter(NULL);

	ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

	do
	{
		if (ErrorCode == ATALK_SOCKET_CLOSED)
			break;

		if (ErrorCode != ATALK_NO_ERROR)
		{
			break;
		}
	
		if (DdpType == DDPPROTO_RTMPREQUEST)
		{
			DBGPRINT(DBG_COMP_RTMP, DBG_LEVEL_INFO,
					("AtalkRtmpPacketInRouter: RtmpRequest\n"));

			if (PktLen < RTMP_REQ_DATAGRAM_SIZE)
			{
				AtalkLogBadPacket(pPortDesc,
								  pSrcAddr,
								  pDstAddr,
								  pPkt,
								  PktLen);
				break;
			}
			RtmpCmd = pPkt[RTMP_REQ_CMD_OFF];

			DBGPRINT(DBG_COMP_RTMP, DBG_LEVEL_INFO,
					("AtalkRtmpPacketInRouter: RtmpRequest %d\n", RtmpCmd));

			if ((RtmpCmd == RTMP_DATA_REQUEST) ||
				(RtmpCmd == RTMP_ENTIRE_DATA_REQUEST))
			{
				atalkRtmpSendRoutingData(pPortDesc, pSrcAddr,
									 (BOOLEAN)(RtmpCmd == RTMP_DATA_REQUEST));
				break;
			}
			else if (RtmpCmd != RTMP_REQUEST)
			{
				DBGPRINT(DBG_COMP_RTMP, DBG_LEVEL_ERR,
						("atalkRtmpPacketInRouter: RtmpCmd %d\n", RtmpCmd));
				AtalkLogBadPacket(pPortDesc,
								  pSrcAddr,
								  pDstAddr,
								  pPkt,
								  PktLen);
				break;
			}

			// This is a standard Rtmp Request. Do the needfull
			// Send an Rtmp response to this guy. Start off by allocating
			// a buffer descriptor
			pBuffDesc = AtalkAllocBuffDesc(NULL,
											RTMP_RESPONSE_MAX_SIZE,
											BD_CHAR_BUFFER | BD_FREE_BUFFER);
			if (pBuffDesc == NULL)
			{
				DBGPRINT(DBG_COMP_RTMP, DBG_LEVEL_ERR,
					("AtalkRtmpPacketInRouter: AtalkAllocBuffDesc failed\n"));
				break;
			}

			Datagram = pBuffDesc->bd_CharBuffer;
			PUTSHORT2SHORT(Datagram + RTMP_SENDER_NW_OFF,
							pPortDesc->pd_ARouter.atn_Network);
			Datagram[RTMP_SENDER_IDLEN_OFF] = 8;
			Datagram[RTMP_SENDER_ID_OFF] = pPortDesc->pd_ARouter.atn_Node;

			// On extended port, we also want to add the initial network
			// range tuple
			RespSize = RTMP_SENDER_ID_OFF + sizeof(BYTE);
			if (EXT_NET(pPortDesc))
			{
				PUTSHORT2SHORT(Datagram+RTMP_RANGE_START_OFF,
								pPortDesc->pd_NetworkRange.anr_FirstNetwork);
				PUTSHORT2SHORT(Datagram+RTMP_RANGE_END_OFF,
								pPortDesc->pd_NetworkRange.anr_LastNetwork);
				Datagram[RTMP_TUPLE_TYPE_OFF] = RTMP_TUPLE_WITHRANGE;
				RespSize = RTMP_RANGE_END_OFF + sizeof(USHORT);
			}

			//	Set the length in the buffer descriptor.
			AtalkSetSizeOfBuffDescData(pBuffDesc, RespSize);
	
			// Send the response
			ASSERT(pBuffDesc->bd_Length > 0);
			SendInfo.sc_TransmitCompletion = atalkRtmpSendComplete;
			SendInfo.sc_Ctx1 = pBuffDesc;
			// SendInfo.sc_Ctx2 = NULL;
			// SendInfo.sc_Ctx3 = NULL;
			if (!ATALK_SUCCESS(Status = AtalkDdpSend(pDdpAddr,
													 pSrcAddr,
													 (BYTE)DDPPROTO_RTMPRESPONSEORDATA,
													 FALSE,
													 pBuffDesc,
													 NULL,
													 0,
													 NULL,
													 &SendInfo)))
			{
				DBGPRINT(DBG_COMP_RTMP, DBG_LEVEL_ERR,
					("AtalkRtmpPacketInRouter: DdpSend failed %ld\n", ErrorCode));
				DBGPRINT(DBG_COMP_RTMP, DBG_LEVEL_ERR,
						("AtalkRtmpPacketInRouter: AtalkDdpSend Failed %ld\n", Status));
				AtalkFreeBuffDesc(pBuffDesc);
			}
			pBuffDesc = NULL;
			break;
		}
		else if (DdpType != DDPPROTO_RTMPRESPONSEORDATA)
		{
			DBGPRINT(DBG_COMP_RTMP, DBG_LEVEL_INFO,
					("AtalkRtmpPacketInRouter: Not ours !!!\n"));
			break;
		}

		ASSERT (DdpType == DDPPROTO_RTMPRESPONSEORDATA);

		DBGPRINT(DBG_COMP_RTMP, DBG_LEVEL_INFO,
				("AtalkRtmpPacketInRouter: RtmpResponse\n"));

		if ((PktLen < (RTMP_SENDER_IDLEN_OFF + 1)) ||
			(pPkt[RTMP_SENDER_IDLEN_OFF] != 8))
		{
			DBGPRINT(DBG_COMP_RTMP, DBG_LEVEL_ERR,
					("AtalkRtmpPacketInRouter: %sExt net, PktLen %d, SenderId %d\n",
					EXT_NET(pPortDesc) ? "" : "Non", PktLen, pPkt[RTMP_SENDER_IDLEN_OFF]));
			AtalkLogBadPacket(pPortDesc,
							  pSrcAddr,
							  pDstAddr,
							  pPkt,
							  PktLen);
			break;
		}

		// For non-extended networks, we should have a leading version stamp
		if (EXT_NET(pPortDesc))
		{
			// Source could be bad (coming in from a half port) so in this
			// case use the source from the rtmp packet
			if (pSrcAddr->ata_Network == UNKNOWN_NETWORK)
			{
                if (PktLen < RTMP_SENDER_ID_OFF + 1)
                {
                    ASSERT(0);
                    break;
                }

				GETSHORT2SHORT(&pSrcAddr->ata_Network, pPkt+RTMP_SENDER_NW_OFF);
				pSrcAddr->ata_Node = pPkt[RTMP_SENDER_ID_OFF];
			}
			index = RTMP_SENDER_ID_OFF + 1;
		}
		else
		{
			USHORT	SenderId;

            if (PktLen < RTMP_TUPLE_TYPE_OFF+1)
            {
                ASSERT(0);
                break;
            }
			GETSHORT2SHORT(&SenderId, pPkt + RTMP_SENDER_ID_OFF + 1);
			if ((SenderId != 0) ||
				(pPkt[RTMP_TUPLE_TYPE_OFF] != RTMP_VERSION))
			{
				AtalkLogBadPacket(pPortDesc,
								  pSrcAddr,
								  pDstAddr,
								  pPkt,
								  PktLen);
				break;
			}
			index = RTMP_SENDER_ID_OFF + 4;
		}

		// Walk though the routing tuples. Ensure we atleast have a
		// non-extended tuple
		RteLocked = FALSE;
		while ((index + sizeof(USHORT) + sizeof(BYTE)) <= PktLen)
		{
			BOOLEAN	FoundOverlap;

			// Dereference the previous RTE, if any
			if (pRte != NULL)
			{
				if (RteLocked)
				{
					RELEASE_SPIN_LOCK_DPC(&pRte->rte_Lock);
					RteLocked = FALSE;
				}
				AtalkRtmpDereferenceRte(pRte, FALSE);
				pRte = NULL;
			}

			GETSHORT2SHORT(&CableRange.anr_FirstNetwork, pPkt+index);
			index += sizeof(USHORT);
			NumHops = pPkt[index++];
			CableRange.anr_LastNetwork = CableRange.anr_FirstNetwork;
			if (NumHops & RTMP_EXT_TUPLE_MASK)
			{
				if ((index + sizeof(USHORT) + sizeof(BYTE)) > PktLen)
				{
                    ASSERT(0);
					AtalkLogBadPacket(pPortDesc,
									  pSrcAddr,
									  pDstAddr,
									  pPkt,
									  PktLen);
					break;
				}

				GETSHORT2SHORT(&CableRange.anr_LastNetwork, pPkt+index);
				index += sizeof(USHORT);
				if (pPkt[index++] != RTMP_VERSION)
				{
					AtalkLogBadPacket(pPortDesc,
									  pSrcAddr,
									  pDstAddr,
									  pPkt,
									  PktLen);
					break;
				}
			}
			NumHops &= RTMP_NUM_HOPS_MASK;

			DBGPRINT(DBG_COMP_RTMP, DBG_LEVEL_INFO,
					("AtalkRtmpPacketInRouter: Response - Port %Z, Hops %d, CableRange %d,%d\n",
					&pPortDesc->pd_AdapterKey,  NumHops,
					CableRange.anr_FirstNetwork, CableRange.anr_LastNetwork));

			if (!AtalkCheckNetworkRange(&CableRange))
				continue;

			// Check if this tuple concerns a network range that we
			// already know about
			pRte = AtalkRtmpReferenceRte(CableRange.anr_FirstNetwork);
			if ((pRte != NULL) &&
				NW_RANGE_EQUAL(&pRte->rte_NwRange, &CableRange))
			{
				ACQUIRE_SPIN_LOCK_DPC(&pRte->rte_Lock);
				RteLocked = TRUE;

				// Check for "notify neighbor" telling us that an entry is bad
				if ((NumHops == RTMP_NUM_HOPS_MASK) &&
					(pRte->rte_NextRouter.atn_Network == pSrcAddr->ata_Network) &&
					(pRte->rte_NextRouter.atn_Node == pSrcAddr->ata_Node))
				{
					DBGPRINT(DBG_COMP_RTMP, DBG_LEVEL_INFO,
							("AtalkRtmpPacketInRouter: Notify Neighbor State %d\n",
							pRte->rte_State));

					if (pRte->rte_State != UGLY)
						pRte->rte_State = BAD;

					continue;
				}

				// If we are hearing about one of our directly connected
				// nets, we know best. Ignore the information.
				if (pRte->rte_NumHops == 0)
				{
					DBGPRINT(DBG_COMP_RTMP, DBG_LEVEL_INFO,
							("AtalkRtmpPacketInRouter: Ignoring - hop count 0\n",
							pRte->rte_State));
					continue;
				}

				// Check for previously bad entry, and a short enough
				// path with this tuple. Also if it shorter or equi-
				// distant path to target network. If so, replace the entry

				if ((NumHops < RTMP_MAX_HOPS) &&
					((pRte->rte_NumHops >= (NumHops + 1)) ||
					 (pRte->rte_State >= BAD)))
				{
					DBGPRINT(DBG_COMP_RTMP, DBG_LEVEL_WARN,
							("AtalkRtmpPacketInRouter: Updating Rte from:\n\tRange %d,%d Hops %d Port %Z NextRouter %d.%d\n",
							pRte->rte_NwRange.anr_FirstNetwork,
							pRte->rte_NwRange.anr_LastNetwork,
							pRte->rte_NumHops,
							&pRte->rte_PortDesc->pd_AdapterKey,
							pRte->rte_NextRouter.atn_Node,
							pRte->rte_NextRouter.atn_Network));
					pRte->rte_NumHops = NumHops + 1;
					pRte->rte_NextRouter.atn_Network = pSrcAddr->ata_Network;
					pRte->rte_NextRouter.atn_Node = pSrcAddr->ata_Node;
					if (pRte->rte_PortDesc != pPortDesc)
					{
						ATALK_ERROR	Error;

						AtalkPortDereference(pRte->rte_PortDesc);
						AtalkPortReferenceByPtrDpc(pPortDesc, &Error);
						ASSERT (ATALK_SUCCESS(Error));
						pRte->rte_PortDesc = pPortDesc;
					}
					pRte->rte_State = GOOD;
					DBGPRINT(DBG_COMP_RTMP, DBG_LEVEL_WARN,
							("to:\tRange %d,%d Hops %d NextRouter %d.%d\n",
							pRte->rte_NwRange.anr_FirstNetwork,
							pRte->rte_NwRange.anr_LastNetwork,
							pRte->rte_NumHops,
							pRte->rte_NextRouter.atn_Node,
							pRte->rte_NextRouter.atn_Network));
					continue;
				}

				// Check for the same router still thinking it has a path
				// to the network, but it is further away now. If so
				// update the entry
				if ((pRte->rte_PortDesc == pPortDesc) &&
					(pRte->rte_NextRouter.atn_Network == pSrcAddr->ata_Network) &&
					(pRte->rte_NextRouter.atn_Node == pSrcAddr->ata_Node))
				{
					pRte->rte_NumHops = NumHops + 1;
					DBGPRINT(DBG_COMP_RTMP, DBG_LEVEL_INFO,
							("AtalkRtmpPacketInRouter: NumHops for Rte %lx changed to %d\n",
							pRte, pRte->rte_NumHops));

					if (pRte->rte_NumHops < 16)
						 pRte->rte_State = GOOD;
					else
					{
						// atalkRtmpRemoveRte(pRte);
						DBGPRINT(DBG_COMP_RTMP, DBG_LEVEL_INFO,
								("AtalkRtmpPacketInRouter: Removing Rte\n"));
						pRte->rte_Flags |= RTE_DELETE;
						pRte->rte_RefCount --;
					}
				}
				continue;
			}

			// Dereference any previous RTEs
			if (pRte != NULL)
			{
				if (RteLocked)
				{
					RELEASE_SPIN_LOCK_DPC(&pRte->rte_Lock);
					RteLocked = FALSE;
				}
				AtalkRtmpDereferenceRte(pRte, FALSE);
				pRte = NULL;
			}

			// Walk thru the entire routing table making sure the current
			// tuple does not overlap with anything we already have (since
			// it did not match. If we find an overlap, ignore the tuple
			// (a network configuration error, no doubt), else add it as
			// a new network range !!

			ACQUIRE_SPIN_LOCK_DPC(&AtalkRteLock);

			FoundOverlap = FALSE;
			for (i = 0; !FoundOverlap && (i < NUM_RTMP_HASH_BUCKETS); i++)
			{
				for (pRte = AtalkRoutingTable[i];
					 pRte != NULL; pRte = pRte->rte_Next)
				{
					if (AtalkRangesOverlap(&pRte->rte_NwRange, &CableRange))
					{
						FoundOverlap = TRUE;
						DBGPRINT(DBG_COMP_RTMP, DBG_LEVEL_WARN,
								("AtalkRtmpPacketInRouter: Overlapped ranges %d,%d & %d,%d\n",
								pRte->rte_NwRange.anr_FirstNetwork,
								pRte->rte_NwRange.anr_LastNetwork,
								CableRange.anr_FirstNetwork,
								CableRange.anr_LastNetwork));
						break;
					}
				}
			}

			RELEASE_SPIN_LOCK_DPC(&AtalkRteLock);

			pRte = NULL;		// We do not want to Dereference this !!!

			if (FoundOverlap)
			{
				DBGPRINT(DBG_COMP_RTMP, DBG_LEVEL_ERR,
						("AtalkRtmpPacketInRouter: Found overlapped ranges\n"));
				continue;
			}

			// Enter this new network range
			if (NumHops < RTMP_MAX_HOPS)
			{
				ATALK_NODEADDR	NextRouter;

				NextRouter.atn_Network = pSrcAddr->ata_Network;
				NextRouter.atn_Node = pSrcAddr->ata_Node;
				atalkRtmpCreateRte(CableRange,
								   pPortDesc,
								   &NextRouter,
								   NumHops + 1);
			}
		}
	} while (FALSE);

	if (pRte != NULL)
	{
		if (RteLocked)
		{
			RELEASE_SPIN_LOCK_DPC(&pRte->rte_Lock);
			// RteLocked = FALSE;
		}
		AtalkRtmpDereferenceRte(pRte, FALSE);
		// pRte = NULL;
	}

	if (pBuffDesc != NULL)
		AtalkFreeBuffDesc(pBuffDesc);

	TimeE = KeQueryPerformanceCounter(NULL);
	TimeD.QuadPart = TimeE.QuadPart - TimeS.QuadPart;

	INTERLOCKED_ADD_LARGE_INTGR_DPC(
		&pPortDesc->pd_PortStats.prtst_RtmpPacketInProcessTime,
		TimeD,
		&AtalkStatsLock.SpinLock);

	INTERLOCKED_INCREMENT_LONG_DPC(
		&pPortDesc->pd_PortStats.prtst_NumRtmpPacketsIn,
		&AtalkStatsLock.SpinLock);
}



/***	AtalkReferenceRte
 *
 */
PRTE
AtalkRtmpReferenceRte(
	IN	USHORT	Network
)
{
	int		i, index, rindex;
	PRTE	pRte;
	KIRQL	OldIrql;

	index = (int)((Network >> 4) % NUM_RTMP_HASH_BUCKETS);
	rindex = (int)((Network >> 6) % NUM_RECENT_ROUTES);

	// First try the recent route cache
	ACQUIRE_SPIN_LOCK(&AtalkRteLock, &OldIrql);

	if (((pRte = AtalkRecentRoutes[rindex]) == NULL) ||
		!IN_NETWORK_RANGE(Network, pRte))
	{
		// We did not find it in the recent routes cache,
		// check in the real table
		for (pRte = AtalkRoutingTable[index];
			 pRte != NULL;
			 pRte = pRte->rte_Next)
		{
			if (IN_NETWORK_RANGE(Network, pRte))
				break;
		}

		// If we did not find here. Check all routing tables.
		// If we do, cache the info
		if (pRte == NULL)
		{
			for (i = 0; i < NUM_RTMP_HASH_BUCKETS; i++)
			{
				for (pRte = AtalkRoutingTable[i];
					 pRte != NULL;
					 pRte = pRte->rte_Next)
				{
					if (IN_NETWORK_RANGE(Network, pRte))
					{
						AtalkRecentRoutes[rindex] = pRte;
						break;
					}
				}

				//	if we found an entry, search no further.
				if (pRte != NULL)
					break;
			}
		}
	}

	if (pRte != NULL)
	{
		ASSERT(VALID_RTE(pRte));

		ACQUIRE_SPIN_LOCK_DPC(&pRte->rte_Lock);

		pRte->rte_RefCount ++;
		DBGPRINT(DBG_COMP_RTMP, DBG_LEVEL_INFO,
				("AtalkRtmpReferenceRte: Rte %lx, PostCount %d\n",
				pRte, pRte->rte_RefCount));

		RELEASE_SPIN_LOCK_DPC(&pRte->rte_Lock);
	}

	RELEASE_SPIN_LOCK(&AtalkRteLock, OldIrql);

	return (pRte);
}


/***	AtalkRtmpDereferenceRte
 *
 */
VOID
AtalkRtmpDereferenceRte(
	IN	PRTE	pRte,
	IN	BOOLEAN	LockHeld
)
{
	PRTE *				ppRte;
	int					Index;
	BOOLEAN				KillCache = FALSE, Kill = FALSE;
	KIRQL				OldIrql;
	PPORT_DESCRIPTOR	pPortDesc;

	ASSERT(VALID_RTE(pRte));

	ASSERT(pRte->rte_RefCount > 0);

	DBGPRINT(DBG_COMP_RTMP, DBG_LEVEL_INFO,
			("AtalkRtmpDereferenceRte: Rte %lx, PreCount %d\n",
			pRte, pRte->rte_RefCount));

	ACQUIRE_SPIN_LOCK(&pRte->rte_Lock, &OldIrql);

	pRte->rte_RefCount --;
	KillCache = (pRte->rte_Flags & RTE_DELETE) ? TRUE : FALSE;
	if (pRte->rte_RefCount == 0)
	{
		ASSERT (pRte->rte_Flags & RTE_DELETE);
		KillCache = Kill = TRUE;
	}

	RELEASE_SPIN_LOCK(&pRte->rte_Lock, OldIrql);

	if (KillCache)
	{
		pPortDesc = pRte->rte_PortDesc;

		DBGPRINT(DBG_COMP_RTMP, DBG_LEVEL_WARN,
			("atalkRtmpDereferenceRte: Removing from cache for port %Z, Range %d, %d\n",
			&pRte->rte_PortDesc->pd_AdapterKey,
			pRte->rte_NwRange.anr_FirstNetwork,
			pRte->rte_NwRange.anr_LastNetwork));

		if (!LockHeld)
			ACQUIRE_SPIN_LOCK(&AtalkRteLock, &OldIrql);

		// Walk through the recent routes cache and kill All found
		for (Index = 0; Index < NUM_RECENT_ROUTES; Index ++)
		{
			if (AtalkRecentRoutes[Index] == pRte)
			{
				AtalkRecentRoutes[Index] = NULL;
			}
		}

		if (Kill)
		{
			DBGPRINT(DBG_COMP_RTMP, DBG_LEVEL_WARN,
					("atalkRtmpDereferenceRte: Removing for port %Z, Range %d, %d\n",
					&pRte->rte_PortDesc->pd_AdapterKey,
					pRte->rte_NwRange.anr_FirstNetwork,
					pRte->rte_NwRange.anr_LastNetwork));

			Index = (pRte->rte_NwRange.anr_FirstNetwork >> 4) % NUM_RTMP_HASH_BUCKETS;
	
			for (ppRte = &AtalkRoutingTable[Index];
				 *ppRte != NULL;
				 ppRte = &(*ppRte)->rte_Next)
			{
				if (pRte == *ppRte)
				{
					*ppRte = pRte->rte_Next;
					AtalkZoneFreeList(pRte->rte_ZoneList);
					AtalkFreeMemory(pRte);
					break;
				}
			}
			AtalkPortDereference(pPortDesc);
		}

		if (!LockHeld)
			RELEASE_SPIN_LOCK(&AtalkRteLock, OldIrql);
	}
}


/***	atalkCreateRte
 *
 */
BOOLEAN
atalkRtmpCreateRte(
	IN	ATALK_NETWORKRANGE	NwRange,
	IN	PPORT_DESCRIPTOR	pPortDesc,
	IN	PATALK_NODEADDR		pNextRouter,
	IN	int					NumHops
)
{
	ATALK_ERROR	Error;
	PRTE		pRte;
	int			index, rindex;
	KIRQL		OldIrql;
	BOOLEAN		Success = FALSE;

	index = (int)((NwRange.anr_FirstNetwork >> 4) % NUM_RTMP_HASH_BUCKETS);
	rindex = (int)((NwRange.anr_FirstNetwork >> 6) % NUM_RECENT_ROUTES);

	// First reference the port
	AtalkPortReferenceByPtr(pPortDesc, &Error);

	if (ATALK_SUCCESS(Error))
	{
		if ((pRte = AtalkAllocMemory(sizeof(RTE))) != NULL)
		{
			DBGPRINT(DBG_COMP_RTMP, DBG_LEVEL_INFO,
					("atalkRtmpCreateRte: Creating for port %Z, Range %d,%d Hops %d index %d\n",
					&pPortDesc->pd_AdapterKey,
					NwRange.anr_FirstNetwork,
					NwRange.anr_LastNetwork,
					NumHops,
					index));
#if	DBG
			pRte->rte_Signature = RTE_SIGNATURE;
#endif
			INITIALIZE_SPIN_LOCK(&pRte->rte_Lock);
			pRte->rte_RefCount = 1;		// Creation Reference
			pRte->rte_State = GOOD;
			pRte->rte_Flags = 0;
			pRte->rte_NwRange = NwRange;
			pRte->rte_NumHops = (BYTE)NumHops;
			pRte->rte_PortDesc = pPortDesc;
			pRte->rte_NextRouter = *pNextRouter;
			pRte->rte_ZoneList = NULL;
	
			// Link this in the global table
			ACQUIRE_SPIN_LOCK(&AtalkRteLock, &OldIrql);
	
			pRte->rte_Next = AtalkRoutingTable[index];
			AtalkRoutingTable[index] = pRte;
			AtalkRecentRoutes[rindex] = pRte;
	
			RELEASE_SPIN_LOCK(&AtalkRteLock, OldIrql);
	
			Success = TRUE;
		}
		else
		{
			AtalkPortDereference(pPortDesc);
		}
	}

	return Success;
}


/***	atalkRtmpRemoveRte
 *
 */
BOOLEAN
atalkRtmpRemoveRte(
	IN	USHORT	Network
)
{
	PRTE	pRte;
	KIRQL	OldIrql;

	if ((pRte = AtalkRtmpReferenceRte(Network)) != NULL)
	{
		ACQUIRE_SPIN_LOCK(&pRte->rte_Lock, &OldIrql);
		pRte->rte_RefCount --;		// Take away creation reference
		pRte->rte_Flags |= RTE_DELETE;
		RELEASE_SPIN_LOCK(&pRte->rte_Lock, OldIrql);

		AtalkRtmpDereferenceRte(pRte, FALSE);
	}

	return (pRte != NULL);
}


/***	AtalkRtmpKillPortRtes
 *
 */
VOID FASTCALL
AtalkRtmpKillPortRtes(
	IN	PPORT_DESCRIPTOR	pPortDesc
)
{
	// At this point, we are unloading and there are no race conditions
	// or lock contentions. Do not bother locking down the rtmp tables
	if (AtalkRoutingTable != NULL)
	{
		int		i;
		PRTE	pRte, pTmp;
		KIRQL	OldIrql;

		ACQUIRE_SPIN_LOCK(&AtalkRteLock, &OldIrql);

		for (i = 0; i < NUM_RTMP_HASH_BUCKETS; i++)
		{
			for (pRte = AtalkRoutingTable[i];
				 pRte != NULL;
				 pRte = pTmp)
			{
				pTmp = pRte->rte_Next;
				if (pRte->rte_PortDesc == pPortDesc)
				{
					ACQUIRE_SPIN_LOCK_DPC(&pRte->rte_Lock);
					pRte->rte_Flags |= RTE_DELETE;
					RELEASE_SPIN_LOCK_DPC(&pRte->rte_Lock);
					AtalkRtmpDereferenceRte(pRte, TRUE);
				}
			}
		}

		RELEASE_SPIN_LOCK(&AtalkRteLock, OldIrql);
	}
}


/***	AtalkRtmpAgingTimer
 *
 */
LONG FASTCALL
AtalkRtmpAgingTimer(
	IN	PTIMERLIST	pContext,
	IN	BOOLEAN		TimerShuttingDown
)
{
	PPORT_DESCRIPTOR	pPortDesc;
	ATALK_ERROR			error;
	LONG				Now;

	pPortDesc = CONTAINING_RECORD(pContext, PORT_DESCRIPTOR, pd_RtmpAgingTimer);

	if (TimerShuttingDown ||
		(pPortDesc->pd_Flags & PD_CLOSING))
	{
		AtalkPortDereferenceDpc(pPortDesc);
		return ATALK_TIMER_NO_REQUEUE;
	}

	Now = AtalkGetCurrentTick();

	ACQUIRE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);

	if (((pPortDesc->pd_Flags &
		  (PD_ACTIVE | PD_ROUTER_RUNNING | PD_SEEN_ROUTER_RECENTLY)) ==
			 (PD_ACTIVE | PD_SEEN_ROUTER_RECENTLY)) &&
		((pPortDesc->pd_LastRouterTime + RTMP_AGING_TIMER) < Now))
	{
		// Age out A-ROUTER. On extended networks age out THIS-CABLE-RANGE
		// and THIS-ZONE too
		KeClearEvent(&pPortDesc->pd_SeenRouterEvent);
		pPortDesc->pd_Flags &= ~PD_SEEN_ROUTER_RECENTLY;
		if (EXT_NET(pPortDesc))
		{
			pPortDesc->pd_Flags &= ~PD_VALID_DESIRED_ZONE;
			pPortDesc->pd_NetworkRange.anr_FirstNetwork = FIRST_VALID_NETWORK;
			pPortDesc->pd_NetworkRange.anr_LastNetwork = LAST_STARTUP_NETWORK;

			// If we have a zone multicast address that is not broadcast, age it out
			if (!AtalkFixedCompareCaseSensitive(pPortDesc->pd_ZoneMulticastAddr,
												MAX_HW_ADDR_LEN,
												pPortDesc->pd_BroadcastAddr,
												MAX_HW_ADDR_LEN))
			{
				// Release lock before calling in to remove multicast address
				RELEASE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);
	
				(*pPortDesc->pd_RemoveMulticastAddr)(pPortDesc,
													 pPortDesc->pd_ZoneMulticastAddr,
													 FALSE,
													 NULL,
													 NULL);
	
				// Re-acquire the lock now
				ACQUIRE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);
			}

			RtlZeroMemory(pPortDesc->pd_ZoneMulticastAddr, MAX_HW_ADDR_LEN);
		}
	}

	RELEASE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);

	return ATALK_TIMER_REQUEUE;
}


/***	atalkRtmpSendTimer
 *
 */
LOCAL LONG FASTCALL
atalkRtmpSendTimer(
	IN	PTIMERLIST	pContext,
	IN	BOOLEAN		TimerShuttingDown
)
{
	PPORT_DESCRIPTOR	pPortDesc;
	ATALK_ADDR			Destination;
	ATALK_ERROR			error;

	pPortDesc = CONTAINING_RECORD(pContext, PORT_DESCRIPTOR, pd_RtmpSendTimer);

	if (TimerShuttingDown ||
		(pPortDesc->pd_Flags & PD_CLOSING))
	{
		AtalkPortDereferenceDpc(pPortDesc);
		return ATALK_TIMER_NO_REQUEUE;
	}

	Destination.ata_Network = CABLEWIDE_BROADCAST_NETWORK;
	Destination.ata_Node = ATALK_BROADCAST_NODE;
	Destination.ata_Socket = RTMP_SOCKET;

	if (((pPortDesc->pd_Flags &
		  (PD_ACTIVE | PD_ROUTER_RUNNING)) == (PD_ACTIVE | PD_ROUTER_RUNNING)))
	{
		atalkRtmpSendRoutingData(pPortDesc, &Destination, TRUE);
	}

	return ATALK_TIMER_REQUEUE;
}


/***	atalkValidityTimer
 *
 */
LOCAL LONG FASTCALL
atalkRtmpValidityTimer(
	IN	PTIMERLIST	pContext,
	IN	BOOLEAN		TimerShuttingDown
)
{
	PRTE	pRte, pNext;
	int		i;

	if (TimerShuttingDown)
		return ATALK_TIMER_NO_REQUEUE;

	ACQUIRE_SPIN_LOCK_DPC(&AtalkRteLock);
	for (i = 0; i < NUM_RTMP_HASH_BUCKETS; i++)
	{
		for (pRte = AtalkRoutingTable[i]; pRte != NULL; pRte = pNext)
		{
			BOOLEAN	Deref;

			pNext = pRte->rte_Next;
			if (pRte->rte_NumHops == 0)
				continue;

			Deref = FALSE;
			ACQUIRE_SPIN_LOCK_DPC(&pRte->rte_Lock);

			switch (pRte->rte_State)
			{
			  case GOOD:
			  case SUSPECT:
			  case BAD:
				pRte->rte_State++;
				break;

			  case UGLY:
				Deref = TRUE;
				DBGPRINT(DBG_COMP_RTMP, DBG_LEVEL_WARN,
						("atalkRtmpValidityTimer: Killing pRte %lx\n"));
  				pRte->rte_Flags |= RTE_DELETE;
				break;

			  default:
				// How did we get here ?
				ASSERT(0);
				KeBugCheck(0);
			}

			RELEASE_SPIN_LOCK_DPC(&pRte->rte_Lock);

			if (Deref)
				AtalkRtmpDereferenceRte(pRte, TRUE);
		}
	}
	RELEASE_SPIN_LOCK_DPC(&AtalkRteLock);

	return ATALK_TIMER_REQUEUE;
}


/***	atalkRtmpSendRoutingData
 *
 */
LOCAL VOID
atalkRtmpSendRoutingData(
	IN	PPORT_DESCRIPTOR	pPortDesc,
	IN	PATALK_ADDR			pDstAddr,
	IN	BOOLEAN				fSplitHorizon
)
{
	int				i, index;
	PRTE			pRte;
	PBYTE			Datagram;
	PDDP_ADDROBJ	pDdpAddr;
	ATALK_ADDR		SrcAddr;
	PBUFFER_DESC	pBuffDesc,
					pBuffDescStart = NULL,
					*ppBuffDesc = &pBuffDescStart;
	SEND_COMPL_INFO	SendInfo;
	ATALK_ERROR		Status;
	BOOLEAN			AllocNewBuffDesc = TRUE;

	ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

	// Compute the source socket: Rtmp socket on our routers node
	SrcAddr.ata_Network = pPortDesc->pd_ARouter.atn_Network;
	SrcAddr.ata_Node = pPortDesc->pd_ARouter.atn_Node;
	SrcAddr.ata_Socket = RTMP_SOCKET;

	AtalkDdpReferenceByAddr(pPortDesc, &SrcAddr, &pDdpAddr, &Status);
	if (!ATALK_SUCCESS(Status))
	{
		DBGPRINT(DBG_COMP_RTMP, DBG_LEVEL_ERR,
				("atalkRtmpSendRoutingData: AtalkDdpRefByAddr failed %ld for %d.%d\n",
				Status, SrcAddr.ata_Network, SrcAddr.ata_Node));
		return;
	}

	// Walk through the rtmp table building a tuple for each network.
	// Note: We may have to send multiple-packets. Each packet needs
	//		 to be allocated afresh. The completion routine will free
	//		 it up.
	ACQUIRE_SPIN_LOCK_DPC(&AtalkRteLock);
	for (i = 0; i < NUM_RTMP_HASH_BUCKETS; i++)
	{
		for (pRte = AtalkRoutingTable[i];
			 pRte != NULL;
			 pRte = pRte->rte_Next)
		{
			if (AllocNewBuffDesc)
			{
				if ((pBuffDesc = AtalkAllocBuffDesc(NULL,
									MAX_DGRAM_SIZE,
									BD_CHAR_BUFFER | BD_FREE_BUFFER)) == NULL)
					break;
				Datagram = pBuffDesc->bd_CharBuffer;
				*ppBuffDesc = pBuffDesc;
				pBuffDesc->bd_Next = NULL;
				ppBuffDesc = &pBuffDesc->bd_Next;
				AllocNewBuffDesc = FALSE;

				// Build the static part of the rtmp data packet
				PUTSHORT2SHORT(Datagram+RTMP_SENDER_NW_OFF,
								pPortDesc->pd_ARouter.atn_Network);
				Datagram[RTMP_SENDER_IDLEN_OFF] = 8;
				Datagram[RTMP_SENDER_ID_OFF] = pPortDesc->pd_ARouter.atn_Node;

				// For non-extended network, we also need the version stamp.
				// For extended network, include a initial network range tuple
				// as part of the header
				if (EXT_NET(pPortDesc))
				{
					PUTSHORT2SHORT(Datagram + RTMP_RANGE_START_OFF,
								pPortDesc->pd_NetworkRange.anr_FirstNetwork);
					PUTSHORT2SHORT(Datagram + RTMP_RANGE_END_OFF,
								pPortDesc->pd_NetworkRange.anr_LastNetwork);
					Datagram[RTMP_TUPLE_TYPE_OFF] = RTMP_TUPLE_WITHRANGE;
					Datagram[RTMP_VERSION_OFF_EXT] = RTMP_VERSION;

					index = RTMP_VERSION_OFF_EXT + 1; // Beyond version
				}
				else
				{
					PUTSHORT2SHORT(Datagram + RTMP_SENDER_ID_OFF + 1, 0);
					Datagram[RTMP_VERSION_OFF_NE] = RTMP_VERSION;
					index = RTMP_VERSION_OFF_NE + 1; // Beyond version
				}
			}

			// See if we should skip the current tuple due to split horizon
			if (fSplitHorizon && (pRte->rte_NumHops != 0) &&
				(pPortDesc == pRte->rte_PortDesc))
				continue;

			// Skip the ports range since we already copied it as the
			// first tuple, but only if extended port
			if (EXT_NET(pPortDesc) &&
				(pPortDesc->pd_NetworkRange.anr_FirstNetwork ==
									pRte->rte_NwRange.anr_FirstNetwork) &&
				(pPortDesc->pd_NetworkRange.anr_FirstNetwork ==
									pRte->rte_NwRange.anr_FirstNetwork))
				continue;

			// Place the tuple in the packet
			PUTSHORT2SHORT(Datagram+index, pRte->rte_NwRange.anr_FirstNetwork);
			index += sizeof(SHORT);

			// Do 'notify neighbor' if our current state is bad
			if (pRte->rte_State >= BAD)
			{
				Datagram[index++] = RTMP_NUM_HOPS_MASK;
				DBGPRINT(DBG_COMP_RTMP, DBG_LEVEL_ERR,
						("atalkRtmpSendRoutingData: Notifying neighbor of bad Rte - port %Z, Range %d.%d\n",
						&pRte->rte_PortDesc->pd_AdapterKey,
						pRte->rte_NwRange.anr_FirstNetwork,
						pRte->rte_NwRange.anr_LastNetwork));
			}
			else
			{
				Datagram[index++] = pRte->rte_NumHops;
			}

			// Send an extended tuple, if the network range isn't ONE or the
			// target port is an extended network.
			// JH - Changed this so that an extended tuple is sent IFF the range
			//		isn't ONE
#if EXT_TUPLES_FOR_NON_EXTENDED_RANGE
			if ((EXT_NET(pPortDesc)) &&
				(pRte->rte_NwRange.anr_FirstNetwork != pRte->rte_NwRange.anr_LastNetwork))
#else
			if (pRte->rte_NwRange.anr_FirstNetwork != pRte->rte_NwRange.anr_LastNetwork)
#endif
			{
				Datagram[index-1] |= RTMP_EXT_TUPLE_MASK;
				PUTSHORT2SHORT(Datagram+index, pRte->rte_NwRange.anr_LastNetwork);
				index += sizeof(SHORT);
				Datagram[index++] = RTMP_VERSION;
			}
			DBGPRINT(DBG_COMP_RTMP, DBG_LEVEL_INFO,
					("atalkRtmpSendRoutingData: Port %Z, Net '%d:%d', Distance %d\n",
					&pPortDesc->pd_AdapterKey,
					pRte->rte_NwRange.anr_FirstNetwork,
					pRte->rte_NwRange.anr_LastNetwork,
					pRte->rte_NumHops));

			// Check if this datagram is full.
			if ((index + RTMP_EXT_TUPLE_SIZE) >= MAX_DGRAM_SIZE)
			{
				pBuffDesc->bd_Length = (SHORT)index;
				AllocNewBuffDesc = TRUE;
			}
		}
	}
	RELEASE_SPIN_LOCK_DPC(&AtalkRteLock);

	// Close the current buffdesc
	if (!AllocNewBuffDesc)
	{
		pBuffDesc->bd_Length = (SHORT)index;
	}

	// We have a bunch of datagrams ready to be fired off. Make it so.
	SendInfo.sc_TransmitCompletion = atalkRtmpSendComplete;
	// SendInfo.sc_Ctx2 = NULL;
	// SendInfo.sc_Ctx3 = NULL;
	for (pBuffDesc = pBuffDescStart;
		 pBuffDesc != NULL;
		 pBuffDesc = pBuffDescStart)
	{
		ATALK_ERROR	ErrorCode;

		pBuffDescStart = pBuffDesc->bd_Next;

		//	Reset next pointer to be null, length is already correctly set.
		pBuffDesc->bd_Next = NULL;
		ASSERT(pBuffDesc->bd_Length > 0);
		SendInfo.sc_Ctx1 = pBuffDesc;
		if (!ATALK_SUCCESS(ErrorCode = AtalkDdpSend(pDdpAddr,
													pDstAddr,
													DDPPROTO_RTMPRESPONSEORDATA,
													FALSE,
													pBuffDesc,
													NULL,
													0,
													NULL,
													&SendInfo)))
		{
			DBGPRINT(DBG_COMP_RTMP, DBG_LEVEL_ERR,
					("atalkRtmpSendRoutingData: DdpSend failed %ld\n", ErrorCode));
			AtalkFreeBuffDesc(pBuffDesc);
		}
	}
	AtalkDdpDereference(pDdpAddr);
}


/***	atalkRtmpGetOrSetNetworkNumber
 *
 */
BOOLEAN
atalkRtmpGetOrSetNetworkNumber(
	IN	PPORT_DESCRIPTOR	pPortDesc,
	IN	USHORT				SuggestedNetwork
)
{
	int				i;
	ATALK_ERROR		ErrorCode;
	ATALK_ADDR		SrcAddr, DstAddr;
	PBUFFER_DESC	pBuffDesc;
	KIRQL			OldIrql;
	BOOLEAN			RetCode = TRUE;
	SEND_COMPL_INFO	SendInfo;

	// If we find the network number of the network, use that and ignore the
	// one passed in. Otherwise use the one passed in, unless it is UNKOWN (0)
	// in which case it is an error case. This is used only for non-extended
	// networks

	ASSERT (!EXT_NET(pPortDesc));

	SrcAddr.ata_Network = UNKNOWN_NETWORK;
	SrcAddr.ata_Node = pPortDesc->pd_RouterNode->an_NodeAddr.atn_Node;
	SrcAddr.ata_Socket = RTMP_SOCKET;

	DstAddr.ata_Network = UNKNOWN_NETWORK;
	DstAddr.ata_Node = ATALK_BROADCAST_NODE;
	DstAddr.ata_Socket = RTMP_SOCKET;

	// Send off a bunch of broadcasts and see if we get to know the network #
	KeClearEvent(&pPortDesc->pd_SeenRouterEvent);
	SendInfo.sc_TransmitCompletion = atalkRtmpSendComplete;
	// SendInfo.sc_Ctx2 = NULL;
	// SendInfo.sc_Ctx3 = NULL;

	for (i = 0;
		 (i < RTMP_NUM_REQUESTS) && !(pPortDesc->pd_Flags & PD_SEEN_ROUTER_RECENTLY);
		 i++)
	{
		if ((pBuffDesc = AtalkAllocBuffDesc(NULL,
								RTMP_REQ_DATAGRAM_SIZE,
								BD_CHAR_BUFFER | BD_FREE_BUFFER)) == NULL)
		{
			RetCode = FALSE;
			break;
		}

		//	Set buffer/size
		pBuffDesc->bd_CharBuffer[0] = RTMP_REQUEST;
		AtalkSetSizeOfBuffDescData(pBuffDesc, RTMP_REQ_DATAGRAM_SIZE);

		SendInfo.sc_Ctx1 = pBuffDesc;
		ErrorCode = AtalkDdpTransmit(pPortDesc,
									 &SrcAddr,
									 &DstAddr,
									 DDPPROTO_RTMPREQUEST,
									 pBuffDesc,
									 NULL,
									 0,
									 0,
									 NULL,
									 NULL,
									 &SendInfo);
		if (!ATALK_SUCCESS(ErrorCode))
		{
			DBGPRINT(DBG_COMP_RTMP, DBG_LEVEL_ERR,
					("atalkRtmpGetOrSetNetworkNumber: DdpTransmit failed %ld\n", ErrorCode));
			AtalkFreeBuffDesc(pBuffDesc);
			RetCode = FALSE;
			break;
		}

		if (AtalkWaitTE(&pPortDesc->pd_SeenRouterEvent, RTMP_REQUEST_WAIT))
			break;
	}

	ACQUIRE_SPIN_LOCK(&pPortDesc->pd_Lock, &OldIrql);
	// If we get an answer, we are done
	if (pPortDesc->pd_Flags & PD_SEEN_ROUTER_RECENTLY)
	{
		if ((SuggestedNetwork != UNKNOWN_NETWORK) &&
			(pPortDesc->pd_NetworkRange.anr_FirstNetwork != SuggestedNetwork))
		{
			LOG_ERRORONPORT(pPortDesc,
							EVENT_ATALK_NETNUMBERCONFLICT,
							0,
							NULL,
							0);
		}
	}

	// If we did not get an answer, then we better have a good suggested
	// network passed in
	else if (SuggestedNetwork == UNKNOWN_NETWORK)
	{
		LOG_ERRORONPORT(pPortDesc,
						EVENT_ATALK_INVALID_NETRANGE,
						0,
						NULL,
						0);
		RetCode = FALSE;
	}

	else
	{
		pPortDesc->pd_NetworkRange.anr_FirstNetwork =
			pPortDesc->pd_NetworkRange.anr_LastNetwork = SuggestedNetwork;
	}

	RELEASE_SPIN_LOCK(&pPortDesc->pd_Lock, OldIrql);

	return RetCode;
}


/***	atalkRtmpComplete
 *
 */
VOID FASTCALL
atalkRtmpSendComplete(
	IN	NDIS_STATUS			Status,
	IN	PSEND_COMPL_INFO	pSendInfo
)
{
	AtalkFreeBuffDesc((PBUFFER_DESC)(pSendInfo->sc_Ctx1));
}


#if	DBG

PCHAR	atalkRteStates[] = { "Eh ?", "GOOD", "SUSPECT", "BAD", "UGLY" };

VOID
AtalkRtmpDumpTable(
	VOID
)
{
	int		i;
	PRTE	pRte;

	if (AtalkRoutingTable == NULL)
		return;

	ACQUIRE_SPIN_LOCK_DPC(&AtalkRteLock);

	DBGPRINT(DBG_COMP_DUMP, DBG_LEVEL_FATAL, ("RECENT ROUTE CACHE:\n"));
	for (i = 0; (AtalkRecentRoutes != NULL) && (i < NUM_RECENT_ROUTES); i ++)
	{
		if ((pRte = AtalkRecentRoutes[i]) != NULL)
		{
			DBGPRINT(DBG_COMP_DUMP, DBG_LEVEL_FATAL,
					("Port %Z Hops %d Range %4d.%4d Router %4d.%3d Flags %x Ref %2d %s\n",
					&pRte->rte_PortDesc->pd_AdapterKey,
					pRte->rte_NumHops,
					pRte->rte_NwRange.anr_FirstNetwork,
					pRte->rte_NwRange.anr_LastNetwork,
					pRte->rte_NextRouter.atn_Network,
					pRte->rte_NextRouter.atn_Node,
					pRte->rte_Flags,
					pRte->rte_RefCount,
					atalkRteStates[pRte->rte_State]));
		}
	}

	DBGPRINT(DBG_COMP_DUMP, DBG_LEVEL_FATAL, ("ROUTINGTABLE:\n"));
	for (i = 0; i < NUM_RTMP_HASH_BUCKETS; i ++)
	{
		for (pRte = AtalkRoutingTable[i]; pRte != NULL; pRte = pRte->rte_Next)
		{
			DBGPRINT(DBG_COMP_DUMP, DBG_LEVEL_FATAL,
					("Port %Z Hops %d Range %4d.%4d Router %4d.%3d Flags %x Ref %2d %s\n",
					&pRte->rte_PortDesc->pd_AdapterKey,
					pRte->rte_NumHops,
					pRte->rte_NwRange.anr_FirstNetwork,
					pRte->rte_NwRange.anr_LastNetwork,
					pRte->rte_NextRouter.atn_Network,
					pRte->rte_NextRouter.atn_Node,
					pRte->rte_Flags,
					pRte->rte_RefCount,
					atalkRteStates[pRte->rte_State]));
		}
	}

	RELEASE_SPIN_LOCK_DPC(&AtalkRteLock);
}

#endif


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\atalk\sys\v42bis.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	arap.c

Abstract:

	Header file for all the v42bis stuff useed by ARAP (adapted from fcr's code)

Author:

	Shirish Koti

Revision History:
	15 Nov 1996		Initial Version

--*/


// v42bis stuff begin

// #define PRIVATE  static

// v42bis stuff end


/* negotiated parameters in XID */
#define PARM_GROUP_ID		0xf0	/* ISB 8885, Addendum 3 */
#define PARM_PARM_ID_V42	0x00
#define PARM_PARM_ID_P0		0x01
#define PARM_PARM_ID_P1		0x02
#define PARM_PARM_ID_P2		0x03

/* control code words (compression mode) */
#define	CCW_ETM		0x00	/* enter transparent mode */
#define	CCW_FLUSH	0x01	/* flush data */
#define	CCW_STEPUP	0x02	/* stepup code word size */

/* command code words (transparent mode) */
#define	CCW_ECM		0x00	/* enter compression mode */
#define	CCW_EID		0x01	/* escape character in data */
#define	CCW_RESET	0x02	/* force reinitialization */

/* escape char cycling */
#define	ESCAPE_CYCLE	51

/*
 * v.42bis dictionary node
 */
typedef struct {
    UCHAR	byte;		/* character */
    USHORT	parent;		/* ptr to parent node */
    USHORT	node;		/* chain of nodes w/same parent */
    USHORT	leaf;		/* chain of leafs w/same parent */
} node_t;

/*
 * v.42bis state block
 */
typedef struct {
    /* connection */
    void	*connection;

    /* values from spec */
    SHORT	n1;		/* maximum codeword size (bits) */
    SHORT	n2;		/* total number of codewords */
#define	N3	8		/* character size (bits) */
#define	N4	256		/* characters in alphabet (2^n3) */
#define	N5	(N4+N6)		/* index # of 1st entry to store a string */
#define	N6	3		/* # of control words */
    UCHAR	n7;		/* maximum string length */

    /* dictionary */
#define	CODES		2048	/* max # of codewords */
#define	LOG2_CODES	11	/* log2(CODES) (max # of codeword bits) */
    node_t	dictionary[CODES];
#define DICT(i) (&state->dictionary[i])
#define CODE(n) ((n) - state->dictionary)

    USHORT	c1;		/* next dictionary entry */
    UCHAR	c2;		/* current codeword size */
    USHORT	c3;		/* threshhold for codeword size change */

    UCHAR	string_size;		/* # bytes in string so far */
    USHORT	last_match;		/* index of last match of "string" */
    USHORT	last_new;		/* index of last new node */
    USHORT	last_decode;
    UCHAR	last_decode_size;

    UCHAR	escape;			/* escape character */
    BOOLEAN	transparent;		/* are we in transparent mode? */
    BOOLEAN	decode_only;		/* are we decode side ? */

#if DEBUG
    UCHAR	dump_indent;		/* indentation dumping dict. tree */
    BOOLEAN	debug_encode_bytes;
    BOOLEAN	debug_encode;
    BOOLEAN	debug_decode_bytes;
    BOOLEAN	debug_decode;
    BOOLEAN	debug_flow;
#endif

    UCHAR	word_size;    		/* local # bits to decode into */
    BOOLEAN	exception_next;		/* do exception processing; next ch */
    BOOLEAN	escaped;		/* have we just gotten an escape? */
    BOOLEAN	just_flushed;		/* did we just flush? */
    BOOLEAN	dict_full;		/* is dictionary full? */

    /* decode bytes->codeword state */
    DWORD	bits_waiting;		/* decode holder */
    UCHAR	bits_remaining;		/* # bits waiting in holder now */

    UCHAR	*input_ptr;
    USHORT	input_size;

    /* encode codeword->bytes state */
    DWORD	bits_acc;		/* encode accumulator */
    UCHAR	bits_used;		/* # bits packed in acc now */

    UCHAR	*output_buffer;		/* ptr to work buffer */
    UCHAR	*output_ptr;		/* current ptr into buffer */
    USHORT	output_size;		/* current work size */
    USHORT	output_max;		/* size of work buffer */

    /* i/o */
    void	*push_context;
    //void	(*push_func)(void *a, u_char *b, int c, int d);
    void	(*push_func)();

    /* statistics for compressibility */
    DWORD	bytes_in;		/* total bytes input to compress */
    DWORD	bytes_out;		/* total bytes output from compress */
    long	bits_out_other_mode;	/* output if we were in other mode */
    long	bits_out_this_mode; 	/* since last transition */
    USHORT	bytes_since_last_check;	/* since last compression test */

    UCHAR  *OverFlowBuf;
    UCHAR  OverFlowBytes;
#define bits_out_if_compressed		bits_out_other_mode
#define bits_out_while_compressed	bits_out_this_mode
#define bits_out_if_transparent		bits_out_other_mode
#define bits_out_while_transparent	bits_out_this_mode
} v42bis_t;

/*
  define hysteresis for compressed/transparent mode switch

  WINDOW_FULL defines how many bits we look at
  WINDOW_MIN_BITS is the min bits of difference required for a change
*/
#define WINDOW_FULL(n)		(n & 0xfffffc00)	/* 1024 bits */
#define WINDOW_MIN_BITS		16*N3			/* 128 bits */
#define WINDOW_CHECK_BYTES	32			/* check every 32 */


#ifdef DEBUG
# define V_FLOW(s)	if (state->debug_flow) logf s;

# define EN_DEBUG(s)	\
    if (state->debug_encode) { \
	logf_prefix(state->decode_only ? "decode: " : "encode: "); \
	logf s; }

//# define EN_S_DEBUG(s)	\
//    if (state->debug_encode > 1) { \
//	logf_prefix(state->decode_only ? "decode: " : "encode: "); \
//	logf s; }
# define EN_S_DEBUG(s)	\
    if (state->debug_encode > 1) { \
	DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,s);
# define EN_DEBUG_ON	(state->debug_encode)

# define DE_DEBUG(s)	\
    if (state->debug_decode) { logf_prefix("decode: "); logf s; }
# define DE_DEBUG_ON	(state->debug_decode)

# define E_DEBUG(s)	if (state->debug_encode_bytes) logf s;
# define D_DEBUG(s)	if (state->debug_decode_bytes) logf s;
#else
# define V_FLOW(s)	/* #s */
# define EN_DEBUG(s)	/* #s */
# define DE_DEBUG(s)	/* #s */
# define E_DEBUG(s)	/* #s */
# define D_DEBUG(s)	/* #s */
# define EN_S_DEBUG(s)
# define EN_DEBUG_ON	FALSE
# define DE_DEBUG_ON	FALSE
#endif

/*
 * v42bis connection type
 */
typedef struct {
    /* negotiated options */
    UCHAR	neg_p0;		/* negotiated value of p0 */
    USHORT	neg_p1;		/* negotiated value of p1 */
    UCHAR	neg_p2;		/* negotiated value of p2 */

    UCHAR	default_p0;	/* default value of p0 */
    USHORT	default_p1;	/* default value of p1 */
#define MIN_P1	512
#define DEF_P1	2048
    USHORT	default_p2;	/* default value of p2 */
#define MIN_P2	6
/*#define DEF_P2	8 */
#define DEF_P2	250
#define MAX_P2	250

    BOOLEAN	compress_init_resp;	/* comp. in initiator->responder dir */
    BOOLEAN	compress_resp_init;	/* comp. in responder->initiator dir */
    BOOLEAN	got_p0;			/* got negitated XID options */
    BOOLEAN	got_p1;
    BOOLEAN	got_p2;
    BOOLEAN	got_unknown_p;		/* got unknown option */

    v42bis_t	encode;			/* encode state */
    v42bis_t	decode;			/* decode state */
} v42bis_connection_t;

/* turn a "state" into a connection */
#define CONN(s)	((v42bis_connection_t *)(s)->connection)

#define PUT(ch)                                                             \
{                                                                           \
    if (state->output_size < state->output_max)                             \
    {                                                                       \
        *state->output_ptr++ = (ch);                                        \
        state->output_size++;                                               \
    }                                                                       \
    else                                                                    \
    {                                                                       \
        /* put this byte in the overflow buffer: we'll recover later */     \
	    if (state == &((v42bis_connection_t *)state->connection)->decode)   \
        {                                                                   \
            *(state->OverFlowBuf + state->OverFlowBytes) = (ch);            \
            state->OverFlowBytes++;                                         \
                                                                            \
            ASSERT(state->OverFlowBytes <= MAX_P2);                         \
        }                                                                   \
                                                                            \
        /* we don't have overflow buffer for encode side!!  */              \
        else                                                                \
        {                                                                   \
            DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,                           \
                ("Arap v42bis: buf overflow on encode!! (%ld)\n",           \
                    state->output_size));                                   \
                                                                            \
            ASSERT(0);                                                      \
        }                                                                   \
    }                                                                       \
}


/* local routines */
int decode_xid_params (v42bis_t *state, PUCHAR params, int len);
DWORD v42bis_encode_codeword (v42bis_t *state, USHORT value);
DWORD v42bis_c_error (v42bis_t *state, char *msg);
DWORD v42bis_transition_to_compressed (v42bis_t *state);
DWORD v42bis_transition_to_transparent (v42bis_t *state);
DWORD v42bis_disconnect(v42bis_t *state, char *reason_string);
DWORD v42bis_init_dictionary(v42bis_t *state);
DWORD exit_handler( void );
DWORD v42bis_init(v42bis_t *state);
USHORT v42bis_decode_codeword(v42bis_t *state, UCHAR value);
USHORT v42bis_decode_codeword_flush(v42bis_t *state);
DWORD v42bis_encode_codeword_flush(v42bis_t *state);
DWORD v42bis_encode_codeword_flush(v42bis_t *state);
DWORD v42bis_encode_value(v42bis_t *state, USHORT value);
DWORD v42bis_apply_compression_test(v42bis_t *state);
DWORD v42bis_encode_buffer(v42bis_t *state, PUCHAR string, int insize);
DWORD v42bis_encode_flush(v42bis_t *state);
DWORD v42bis_signal_reset(v42bis_t *state);
DWORD v42bis_decode_match(v42bis_t *state, USHORT codeword, int *psize, UCHAR *pRetChar);
DWORD v42bis_decode_buffer(v42bis_t *state, PUCHAR data, int *pDataSize);
DWORD v42bis_decode_flush(v42bis_t *state);
DWORD v42bis_init_buffer(v42bis_t *state, PUCHAR buf, int size);
DWORD v42bis_connection_init(v42bis_connection_t *conn);
DWORD v42bis_connection_init_buffers(v42bis_connection_t *conn, PUCHAR e_buf,
                                     int e_size, PUCHAR d_buf, int d_size);
DWORD v42bis_connection_init_push(v42bis_connection_t *conn, void *context,
                                  void (*e_push)(), void (*d_push)());
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\atalk\sys\v42bis.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	arap.c

Abstract:

	This module implements the v42bis compression/decompression routines
    used by ARAP (adapted from fcr's code)

Author:

	Shirish Koti

Revision History:
	15 Nov 1996		Initial Version

--*/

#include "atalk.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE_ARAP, v42bis_init_dictionary)
#pragma alloc_text(PAGE_ARAP, v42bis_init)
#pragma alloc_text(PAGE_ARAP, v42bis_decode_codeword)
#pragma alloc_text(PAGE_ARAP, v42bis_decode_codeword_flush)
#pragma alloc_text(PAGE_ARAP, v42bis_encode_codeword)
#pragma alloc_text(PAGE_ARAP, v42bis_encode_codeword_flush)
#pragma alloc_text(PAGE_ARAP, v42bis_encode_value)
#pragma alloc_text(PAGE_ARAP, v42bis_apply_compression_test)
#pragma alloc_text(PAGE_ARAP, v42bis_encode_buffer)
#pragma alloc_text(PAGE_ARAP, v42bis_encode_flush)
#pragma alloc_text(PAGE_ARAP, v42bis_transition_to_compressed)
#pragma alloc_text(PAGE_ARAP, v42bis_transition_to_transparent)
#pragma alloc_text(PAGE_ARAP, v42bis_signal_reset)
#pragma alloc_text(PAGE_ARAP, v42bis_decode_match)
#pragma alloc_text(PAGE_ARAP, v42bis_decode_buffer)
#pragma alloc_text(PAGE_ARAP, v42bis_decode_flush)
#pragma alloc_text(PAGE_ARAP, v42bis_init_buffer)
#pragma alloc_text(PAGE_ARAP, v42bis_connection_init)
#pragma alloc_text(PAGE_ARAP, v42bis_connection_init_buffers)
#pragma alloc_text(PAGE_ARAP, v42bis_connection_init_push)
#pragma alloc_text(PAGE_ARAP, v42bisInit)
#pragma alloc_text(PAGE_ARAP, v42bisCompress)
#pragma alloc_text(PAGE_ARAP, v42bisDecompress)
#endif

//
// bitmaps[# of bits]
//
USHORT bit_masks[16] =
{
    0x0000, 0x0001, 0x0003, 0x0007, 0x000f, 0x001f, 0x003f, 0x007f,
    0x00ff, 0x01ff, 0x03ff, 0x07ff, 0x0fff, 0x1fff, 0x3fff, 0x7fff
};


static PCHAR
show_char(
    IN  UCHAR ch
)
{
    static char dec[20];

    if (' ' <= ch && ch <= '~')
    {
	    dec[0] = ch;
	    dec[1] = 0;
	    return dec;
    }

    // BUGV42BUG: do we need this?
    //sprintf(dec, "0x%02x", ch);
    return dec;
}

/*
  decode_xid_params()

  decode compression negotiation packet as per V42bis spec.

  note: this is not used (there is code in the mnp LR routines to do
  this), but is included for completeness.
*/


/*
  v42bis_push()

  perform PUSH on output stream.  accumlated bytes are pushed
  out.
*/


/*
  v42bis_init_dictionary()

  init dictionary in accordance with section 6.2 and 7.2

  this is used at init time and in response to a CCW_RESET
*/

DWORD
v42bis_init_dictionary(state)
v42bis_t *state;
{
    int i;
    node_t *n;

    /* initialize dictionary tree */
    for (i = 0, n = state->dictionary; i < state->n2; i++, n++)
    {
    	n->byte = 0;
	    n->parent = 0;
	    n->node = 0;
	    n->leaf = 0;
    }

    /* section 6.2 */
    state->c1 = N5;	/* next codeword */
    state->c2 = N3 + 1;	/* codeword size (bits) */
    state->c3 = N4 * 2;	/* threshold */

    state->transparent = TRUE;
    state->escape = 0;
    state->escaped = FALSE;
    state->exception_next = FALSE;

    /* initialize searching  */
    state->last_match = 0;
    state->last_new = 0;
    state->string_size = 0;

	return ARAPERR_NO_ERROR;
}

/*
  v42bis_init()

  implements C-INIT semantics
*/

DWORD
v42bis_init(state)
v42bis_t *state;
{

    DWORD   dwRetCode;

    V_FLOW(("v42bis_init()"));

    /* our defaults */
    state->n1 = LOG2_CODES;		/* max codeword size (bits) */
    state->n2 = CONN(state)->neg_p1;	/* total # of codewords */
    state->n7 = CONN(state)->neg_p2;	/* max string length */

    /* init dictionary */
    v42bis_init_dictionary(state);

    /* initialize encode/decode */
    state->bits_acc = 0;
    state->bits_used = 0;
    state->word_size = 8*sizeof(unsigned short);

    state->bits_waiting = 0;
    state->bits_remaining = 0;

	return ARAPERR_NO_ERROR;
}

#ifdef DEBUG_ENABLED
/*
  itobits()

  turn an integer bitfield into an ascii representation (i.e. "01010101")
*/

char *
itobits(word, bits)
USHORT word;
int bits;
{
    static char buf[33];
    int i;

    if (bits > 32) bits = 32;

    for (i = bits-1; i >= 0; i--)
	buf[(bits-1)-i] = word & (1 << i) ? '1' : '0';

    buf[bits] = 0;
    return buf;
}
#endif



/*
  v42bis_decode_codeword()

  decode n-bit codewords from a bytesteam.
*/

USHORT
v42bis_decode_codeword(state, value)
v42bis_t *state;
UCHAR value;
{
    register UCHAR bits_free, bits_new, bits_residual;
    register USHORT codeword;

    V_FLOW(("v42bis_decode_codeword(%x) c2=%d", value, state->c2));

    /* simple case */
    if (state->c2 == 8 || state->transparent)
	return value;

    /* not-so-simple case */
    D_DEBUG(("before: waiting %06x, bits_remaining %d",
	     state->bits_waiting, state->bits_remaining));

    /* add in these 8 bits */
    state->bits_waiting |= ((DWORD)value) << state->bits_remaining;
    state->bits_remaining += 8;

    /* do we have a codeword ? */
    if (state->bits_remaining >= state->c2) {
	D_DEBUG(("input %04x %s",
		 state->bits_waiting & bit_masks[state->c2],
		 itobits(state->bits_waiting & bit_masks[state->c2],
			 state->c2)));

	codeword = (USHORT)(state->bits_waiting & bit_masks[state->c2]);

	state->bits_waiting >>= state->c2;
	state->bits_remaining -= state->c2;

	D_DEBUG(("after: waiting %04x, bits_remaining %d (data)",
		 state->bits_waiting, state->bits_remaining));

	return codeword;
    }

    D_DEBUG(("after: waiting %04x, bits_remaining %d (no data)",
	     state->bits_waiting, state->bits_remaining));

    return ((USHORT)-1);
}

/*
  v42bis_decode_codeword_flush()

  "flush" decoding of codewords, returning the last codeword
*/

USHORT
v42bis_decode_codeword_flush(state)
v42bis_t *state;
{
    USHORT codeword = (USHORT)-1;

    if (state->bits_remaining)
	codeword = (USHORT)(state->bits_waiting & bit_masks[state->c2]);

    state->bits_waiting = 0;
    state->bits_remaining = 0;

    return codeword;
}

/*
  v42bis_encode_codeword()

  encode n-bit codewords into a bytesteam.

  This routine makes use of the fact that the code words will be always
  be smaller than 16 bits.  An "accumulator" is used with several state
  variables to keep track of how much of the accumulator is in use at
  any given time.

  The code works for wordsizes of 8 and 16 bits.  It is assumed that the
  output is a byte stream.  No assumptions are made about alignment of
  data.

  note: this routine needs to be "flushed" to get out the value left
  in the accumulator.

  jbp@fcr.com 09/13/92, 19:52
*/

DWORD
v42bis_encode_codeword(state, value)
v42bis_t *state;
USHORT value;
{
    register UCHAR bits_free, bits_new, bits_residual;

    EN_DEBUG(("v42bis_encode_codeword(%d 0x%x) c2=%d",
	      value, value, state->c2));

    /* simple case */
    if (state->c2 == 8 || state->transparent)
    {
	    E_DEBUG(("put acc %02x %s", value & 0xff, itobits(value & 0xff, 8)));

	    PUT((UCHAR)value);

	    if (state->transparent)
        {
	        state->bits_out_while_transparent += N3;
        }
	    else
        {
	        state->bits_out_while_compressed += N3;
        }

	    return ARAPERR_NO_ERROR;
    }

    state->bits_out_while_compressed += state->c2;

    /* not-so-simple case */
    E_DEBUG(("before: acc %04x, bits_used %d",
	     state->bits_acc, state->bits_used));

    /* place new value in appropriate bit positions */
    state->bits_acc |= ((DWORD)value) << state->bits_used;

    /* housekeeping */
    bits_free = state->word_size - state->bits_used;
    bits_new = bits_free < state->c2 ? bits_free : state->c2;
    bits_residual = state->c2 - bits_new;

    E_DEBUG(("bits_free %d, bits_new %d, bits_residual %d",
	     bits_free, bits_new, bits_residual));

#ifdef DEBUG
    if (state->bits_used + bits_new >= 31)
	logf("acc oflo, size %d", state->bits_used + bits_new);
#endif

    /* do we have a full codeword in the accumulator? */
    if (state->bits_used + bits_new == state->word_size)
    {

	    if (state->word_size == 16)
        {
	        E_DEBUG(("put acc %06x %s",
		         state->bits_acc, itobits(state->bits_acc, 24)));

	        PUT((UCHAR)(state->bits_acc));

	        PUT((UCHAR)(state->bits_acc >> 8));

	    }
        else
        {
    	    E_DEBUG(("put acc %02x %s",
	    	     state->bits_acc & 0xff,
		         itobits(state->bits_acc & 0xff, 8)));

	        PUT((UCHAR)(state->bits_acc));
	    }

	    E_DEBUG(("value 0x%x, bits_used %d, acc 0x%x",
		     value, state->bits_used, value >> state->bits_used));

	    /* account for left over bits */
	    state->bits_acc = value >> (state->c2 - bits_residual);

        state->bits_used = bits_residual;
    }
    else
    {
	    state->bits_used += bits_new;
    }

    E_DEBUG(("after: acc %06x, bits_used %d",
	     state->bits_acc, state->bits_used));

	return ARAPERR_NO_ERROR;
}

/*
  v42bis_encode_codeword_flush()

  flush partial assembly of codeword into 16 bit accumulator
*/

DWORD
v42bis_encode_codeword_flush(state)
v42bis_t *state;
{
    V_FLOW(("v42bis_encode_codeword_flush() bits_used %d", state->bits_used));

    if (state->bits_used) {
	E_DEBUG(("put acc (flush) %02x %s",
		 state->bits_acc & 0xff,
		 itobits(state->bits_acc & 0xff, 8)));

	PUT((UCHAR)(state->bits_acc));
    }

    if (state->bits_used > 8) {
	E_DEBUG(("put acc (flush2) %02x %s",
		 (state->bits_acc>>8) & 0xff,
		 itobits((state->bits_acc>>8) & 0xff, 8)));

	PUT((UCHAR)(state->bits_acc >> 8));
    }

#ifdef DEBUG
    if (state->bits_used > 16)
	logf("flush: bits_used %d", state->bits_used);
#endif

    state->bits_used = 0;
    state->bits_acc = 0;

	return ARAPERR_NO_ERROR;
}

/*
  v42bis_encode_value()

  encode a codeword value, noting if it's size exceeds C3, and
  doing any required STEPUPs
*/

DWORD
v42bis_encode_value(state, value)
v42bis_t *state;
USHORT value;
{
    DWORD   dwRetCode;

    V_FLOW(("v42bis_encode_value(%lx, 0x%x)", state, value));

#ifdef DEBUG
    /* sanity check */
    if (value >= 8192) {
	logf("encode_value() value too big, %d", value);
	exit(1);
    }
#endif

    /* section 7.4 */

    /* check codeword size */
    while (value >= state->c3)
    {
	    EN_DEBUG(("stepup: value %d, max %d", value, state->c3));

	    dwRetCode = v42bis_encode_codeword(state, CCW_STEPUP);
	    if (dwRetCode != ARAPERR_NO_ERROR)
        {
            return(dwRetCode);
        }
	    state->c2++;
	    state->c3 *= 2;
    }

    dwRetCode = v42bis_encode_codeword(state, value);

	return(dwRetCode);
}

/*
  decide if we should transition from tranparent to compressed or
  visa versa.
*/

DWORD
v42bis_apply_compression_test(state)
v42bis_t *state;
{

    DWORD   dwRetCode;

    if (state->just_flushed || state->exception_next)
    {
	    return ARAPERR_NO_ERROR;
    }

#ifdef UNIT_TEST_PROGRESS
    {
	    static int times = 0;
	    if (++times == 1000)
        {
	        times = 0;
	        dwRetCode = v42bis_comp_test_report(state);
            if (dwRetCode != ARAPERR_NO_ERROR)
            {
                return(dwRetCode);
            }
	    }
    }
#endif

#ifdef UNIT_TEST_FORCE
    /* force consistant behavior across all input */
    if (!state->transparent)
    {
    	state->bits_out_while_transparent = 0;
	    return ARAPERR_NO_ERROR;
    }
    else
    {
	    state->bits_out_if_transparent = 0;
#undef WINDOW_CHECK_BYTES
#define WINDOW_CHECK_BYTES 0
	    if (state->bits_out_while_transparent > 64*N3)
        {
	        dwRetCode = v42bis_transition_to_compressed(state);
            if (dwRetCode != ARAPERR_NO_ERROR)
            {
                return(dwRetCode);
            }
        }
	    return ARAPERR_NO_ERROR;
    }
#endif

    /* bound check to recent history */
    if (WINDOW_FULL(state->bits_out_this_mode))
    {
	    state->bits_out_this_mode = 0;
	    state->bits_out_other_mode = 0;
    }

    if (!state->transparent)
    {
	    /* compressing */
	    if ((state->bits_out_while_compressed -
	         state->bits_out_if_transparent) > WINDOW_MIN_BITS)
        {
	        dwRetCode = v42bis_transition_to_transparent(state);
            if (dwRetCode != ARAPERR_NO_ERROR)
            {
                return(dwRetCode);
            }
        }
    }
    else
    {
	/* transparent */
#ifdef NEVER_SEND_COMPRESSED
	    return ARAPERR_NO_ERROR;
#endif
	/* transparent */
	    if ((state->bits_out_while_transparent -
	         state->bits_out_if_compressed) > WINDOW_MIN_BITS)
        {
	        dwRetCode = v42bis_transition_to_compressed(state);
            if (dwRetCode != ARAPERR_NO_ERROR)
            {
                return(dwRetCode);
            }
        }
    }


	return ARAPERR_NO_ERROR;
}

/*
  v42bis_encode_buffer()

  implements C-DATA semantics on encode side

  encode a buffer full of data...
*/

DWORD
v42bis_encode_buffer(state, string, insize)
v42bis_t *state;
PUCHAR string;
int insize;
{
    UCHAR ch;
    BOOLEAN hit, duplicate;
    USHORT root_value, hit_node;
    node_t *n, *dead, *p;
    DWORD   dwRetCode;


    V_FLOW(("v42bis_encode_buffer(%lx, %lx, %d)", state, string, insize));

    if (insize == 0)
    {
	    return ARAPERR_NO_ERROR;
    }

    V_FLOW(("v42bis_encode: input %*s", insize, string));

    state->bytes_in += insize;

    /* section 6.3 */

    while (insize > 0)
    {
	    /* "search" dictionary for string + character */
	    ch = string[0];

	    hit = FALSE;
	    duplicate = FALSE;
	    hit_node = state->last_match;
	    p = DICT(state->last_match);

	    EN_S_DEBUG(("last_match %d, string_size %d, insize %d, ch %d '%s'",
		        state->last_match, state->string_size, insize,
		        ch, show_char(ch)));

	    if (state->last_match == 0)
        {
	        /*
	        * "the code word associated with each root node shall be N6 (the
	        * number of control codewords) plus the ordinal value of the
	        * character represented by the node"
	        */

	        state->last_match = ch + N6;
	        state->string_size = 1;

	        EN_S_DEBUG(("codeword for root %d, '%s' = %d",
			    ch + N6, show_char(ch), CODE(DICT(ch + N6))));

	        p = DICT(ch + N6);
	        p->byte = ch;

	        hit = TRUE;
 	        hit_node = state->last_match;

	        /* consume input */
	        goto consume_input;
	    }

	    /* we're at a node; search it's leaves */
	    for (n = DICT(DICT(state->last_match)->leaf);
	         CODE(n) && insize > 0;)
	    {
	        EN_S_DEBUG(("  checking leaf node %d", CODE(n)));

	        if (n->byte == *string)
            {
		        /* hit - check leafs */
		        EN_S_DEBUG(("  hit: "));

		        hit_node = (USHORT)CODE(n);
		        p = n;
		        state->last_match = (USHORT)CODE(n);

		        if (state->just_flushed || hit_node == state->last_new)
		        {
		            EN_S_DEBUG(("leaving search, node == last created"));
		            hit = FALSE;
		            duplicate = TRUE;

		            /* backup to previous node */
		            hit_node = n->parent;
		            state->last_match = n->parent;
		            break;
		        }

		        hit = TRUE;
		        state->string_size++;

#ifdef never
		        string++;
		        insize--;

		        /* if no leafs, exit now - we're at the end */
		        if (n->leaf == 0)
                {
		            EN_S_DEBUG(("leaving search, no leaf"));
		            break;
		        }

		        n = DICT(n->leaf);
		        EN_S_DEBUG(("continuing search, leaf %d", CODE(n)));
		        continue;
#else
        		EN_S_DEBUG(("exiting search, leaf %d", CODE(n)));
		        goto consume_input;
#endif
	        }
            else
            {
		        EN_S_DEBUG(("  miss: "));
		        hit = FALSE;
	        }

	        if (n->node == 0)
            {
		        EN_S_DEBUG(("leaving search, no node"));
		        break;
	        }

	        n = DICT(n->node);
	        EN_S_DEBUG(("continuing search, node %d", CODE(n)));
	    }

	    EN_S_DEBUG(("search done, n %d, insize %d, next %d '%s' %s %s",
		        CODE(n), insize, string[0], show_char(string[0]),
		        hit ? "hit" : "miss", duplicate ? "duplicate" : ""));

#ifdef never
	    /* we're matching but we ran out of characters */
	    if (hit && insize == 0)
        {
	        return ARAPERR_NO_ERROR;
        }
#endif

	    if (!hit && duplicate)
        {
	        BOOLEAN ok_to_output;

	        EN_S_DEBUG(("duplicate"));

	        ok_to_output =
		        !state->just_flushed &&
		        !state->exception_next &&
			    !state->decode_only;

	        state->exception_next = FALSE;

	        if (ok_to_output)
	        {
		        if (!state->transparent)
                {
		            dwRetCode = v42bis_encode_value(state, hit_node);
                    if (dwRetCode != ARAPERR_NO_ERROR)
                    {
                        return(dwRetCode);
                    }
                }
		        else
                {
		            state->bits_out_if_compressed += state->c2;

		            /* check if we should go compressed */
		            if (state->bytes_since_last_check > WINDOW_CHECK_BYTES)
                    {
			            state->bytes_since_last_check = 0;

                        dwRetCode = v42bis_apply_compression_test(state);
                        if (dwRetCode != ARAPERR_NO_ERROR)
                        {
                            return(dwRetCode);
                        }
		            }
		        }
	        }

	        /* string = string + character */
	        state->string_size++;

	        /* reset match to unmatched character */
	        state->last_match = 0;
	        state->string_size = 0;
	        state->last_new = 0;

	        state->just_flushed = 0;

	        /* don't advance, "string = unmatched character" */
	        continue;
	    }

	    /* last char did not match or already in dictionary */
	    if (!hit && !duplicate)
	    {
	        BOOLEAN ok_to_output;

	        EN_S_DEBUG(("update dictionary"));

	        ok_to_output =
		        !state->just_flushed &&
		        !state->exception_next &&
			    !state->decode_only;

	        state->exception_next = FALSE;

	        if (ok_to_output)
	        {
		        if (!state->transparent)
                {
    		        dwRetCode = v42bis_encode_value(state, hit_node);
                    if (dwRetCode != ARAPERR_NO_ERROR)
                    {
                        return(dwRetCode);
                    }
                }
		        else
                {
    		        state->bits_out_if_compressed += state->c2;

	    	        /* check if we should go compressed */
		            if (state->bytes_since_last_check > WINDOW_CHECK_BYTES)
                    {
			            state->bytes_since_last_check = 0;
			            dwRetCode = v42bis_apply_compression_test(state);
                        if (dwRetCode != ARAPERR_NO_ERROR)
                        {
                            return(dwRetCode);
                        }
		            }
		        }
	        }

	        state->just_flushed = 0;

	        /* "add string + character to dictionary" */

	        /* section 6.4a */

	        /* string too big? */
	        if (state->string_size >= state->n7)
            {
		        EN_DEBUG(("string size (%d) > n7 (%d)",
			    state->string_size, state->n7));

		        /* reset match */
		        state->last_match = 0;
		        state->string_size = 0;

		        /* we were in the match routine, reset last new */
		        state->last_new = 0;

                continue;
	        }

	        /* pick a new code word */
	        n = DICT(state->c1);
	        state->last_new = (USHORT)CODE(n);

	        EN_DEBUG(("adding new node %d = %d '%s', parent %d",
		          CODE(n), string[0], show_char(string[0]), CODE(p)));

	        /* attach "string + character" */
	        n->byte = string[0];
	        n->parent = hit_node;
#ifdef DEBUG
	        if (CODE(n) == hit_node)
            {
		        logf("creating loop! node %d", CODE(n));
            }
#endif
	        n->node = 0;

	        /* XXX should be in ord(ch) order to allow faster search */
	        n->node = p->leaf;
	        p->leaf = (USHORT)CODE(n);

	        /* section 6.5 */

    	    /* recover dictionary entries */
	        do
            {
		        state->c1++;

		        if (state->c1 > (state->n2 - 1))
                {
		            state->c1 = N5;
		            state->dict_full = TRUE;
		        }

		        dead = DICT(state->c1);

		        /* find terminal nodes (i.e. leaf == 0) */
	        } while (/*dead->parent != 0 &&*/ dead->leaf != 0);

	        /* terminal nodes with parents are eligible */
	        if (CODE(dead) && /* <- I think this is not needed */
		        /*dead->parent && */dead->leaf == 0 &&
		        state->dict_full)
	        {
		        /* go to parent, disconnect from chain */
		        node_t *parent = DICT(dead->parent);

		        EN_DEBUG(("recovering dead node %d", CODE(dead)));

		        /* if first on parents list, fix parent */
		        if (DICT(parent->leaf) == dead)
                {
		            parent->leaf = dead->node;
                }
		        else
                {
		            /* else search parents list, fix sibling */
		            for (parent = DICT(DICT(dead->parent)->leaf);
			            CODE(parent); parent = DICT(parent->node))
		            {
			            if (DICT(parent->node) == dead)
                        {
    			            parent->node = dead->node;
			                break;
			            }
		            }
                }

		        /* mark node free */
		        dead->parent = 0;
		        dead->leaf = 0;
	        } /* dead node */

	        /* if we added a node, reset "string" */
//reset_match:
	        state->last_match = 0;
	        state->string_size = 0;
	        state->just_flushed = 0;

	        /*
	        * this is a "safe time" to do compression test, as we've just
	        * done an update...
	        */
	        if (!state->decode_only)
            {
		        if (state->bytes_since_last_check > WINDOW_CHECK_BYTES)
                {
		            state->bytes_since_last_check = 0;
		            dwRetCode = v42bis_apply_compression_test(state);
                    if (dwRetCode != ARAPERR_NO_ERROR)
                    {
                        return(dwRetCode);
                    }
		        }
	        }

	        /* don't advance, "string = unmatched character" */
	        continue;
	    } /* (!hit && !duplicate) */

consume_input:
	    string++;
	    insize--;
	    state->bytes_since_last_check++;

	/* section 9.2 */
//check_escape:
	/* escape processing */
	    if (state->transparent)
        {
	        if (!state->decode_only)
            {
		        dwRetCode = v42bis_encode_value(state, ch);
                if (dwRetCode != ARAPERR_NO_ERROR)
                {
                    return(dwRetCode);
                }
            }

	        if (ch == state->escape)
            {
		        if (!state->decode_only)
                {
		            dwRetCode = v42bis_encode_value(state, CCW_EID);
                    if (dwRetCode != ARAPERR_NO_ERROR)
                    {
                        return(dwRetCode);
                    }
		            state->escape += ESCAPE_CYCLE;
		        }
	        }
	    }
        else
        {
    	    /* compressed, cycle escape character */
	        if (ch == state->escape && !state->decode_only)
            {
		        state->escape += ESCAPE_CYCLE;
            }

	        state->bits_out_if_transparent += N3;
	    }

	    state->just_flushed = 0;
    }

	return ARAPERR_NO_ERROR;
}

/*
  implements C-FLUSH semantics
*/

DWORD
v42bis_encode_flush(state)
v42bis_t *state;
{

    DWORD   dwRetCode=ARAPERR_NO_ERROR;


    V_FLOW(("v42bis_encode_flush() string_size %d, last_match %d",
	  state->string_size, state->last_match));

    if (state->just_flushed)
    {
	    return ARAPERR_NO_ERROR;
    }

    if (state->transparent)
    {
	    /* transparent, send any buffered characters */
    }
    else
    {
	    /* compressed */

	    /* section 7.9a */
	    /* output partial match, if any */
	    if (state->string_size)
        {
	        /* section 7.8.2 */
	        dwRetCode = v42bis_encode_value(state, state->last_match);
            if (dwRetCode != ARAPERR_NO_ERROR)
            {
                return(dwRetCode);
            }
	    }

	    state->just_flushed = 1;

	    dwRetCode = v42bis_encode_value(state, CCW_FLUSH);

        if (dwRetCode != ARAPERR_NO_ERROR)
        {
            return(dwRetCode);
        }

	    dwRetCode = v42bis_encode_codeword_flush(state);
    }

	return dwRetCode;
}

DWORD
v42bis_transition_to_compressed(state)
v42bis_t *state;
{

    DWORD   dwRetCode=ARAPERR_NO_ERROR;


    V_FLOW(("v42bis_transition_to_compressed()"));

#ifdef UNIT_TEST_VERBOSE
    logf("v42bis_transition_to_compressed()");
    v42bis_comp_test_report(state);
#endif

    if (state->transparent)
    {
	    /* section 7.8.1a */
	    dwRetCode = v42bis_encode_value(state, state->escape);
	    if (dwRetCode != ARAPERR_NO_ERROR)
        {
            return(dwRetCode);
        }

	    /* section 7.8.1b */
	    if ((dwRetCode = v42bis_encode_value(state, CCW_ECM)) != ARAPERR_NO_ERROR)
        {
            return(dwRetCode);
        }

	    if ((dwRetCode = v42bis_encode_codeword_flush(state)) != ARAPERR_NO_ERROR)
        {
            return(dwRetCode);
        }

	    /* enter compressed mode */
	    state->transparent = FALSE;

	    state->bits_out_if_transparent = 0;
	    state->bits_out_while_compressed = 0;
    }

	return ARAPERR_NO_ERROR;
}

DWORD
v42bis_transition_to_transparent(state)
v42bis_t *state;
{

    DWORD   dwRetCode;

    V_FLOW(("v42bis_transition_to_transparent()"));

#ifdef UNIT_TEST_VERBOSE
    logf("v42bis_transition_to_transparent()");
    v42bis_comp_test_report(state);
#endif

    /* check counters for overflow */

    if (!state->transparent)
    {
	    /* output partial match, if any */
	    if (state->string_size)
        {
    	    /* section 7.8.2 */
	        dwRetCode = v42bis_encode_value(state, state->last_match);
            if (dwRetCode != ARAPERR_NO_ERROR)
            {
                return(dwRetCode);
            }
	    }

	    /* section 7.8.2c */
	    if ((dwRetCode = v42bis_encode_value(state, CCW_ETM)) != ARAPERR_NO_ERROR)
        {
            return(dwRetCode);
        }

	    /* section 7.8.2d */
	    if ((dwRetCode = v42bis_encode_codeword_flush(state)) != ARAPERR_NO_ERROR)
        {
            return(dwRetCode);
        }

	    /* section 7.8.2e */
	    /* enter transparent mode */
	    state->transparent = TRUE;

	    /* reset compressibility test */
	    state->bits_out_if_compressed = 0;
	    state->bits_out_while_transparent = 0;
    }

	return ARAPERR_NO_ERROR;
}

DWORD
v42bis_signal_reset(state)
v42bis_t *state;
{

    DWORD   dwRetCode;

    if (!state->transparent)
    {
	    /* change to transparent */
	    dwRetCode = v42bis_transition_to_transparent(state);
        if (dwRetCode != ARAPERR_NO_ERROR)
        {
            return(dwRetCode);
        }

	    /* counteract side effect */
	    state->exception_next = FALSE;
    }

    dwRetCode = v42bis_encode_value(state, state->escape);
    if (dwRetCode != ARAPERR_NO_ERROR)
    {
        return(dwRetCode);
    }

    dwRetCode = v42bis_encode_value(state, CCW_RESET);

	return(dwRetCode);
}

/*
  expand a codeword into it's string

  follow chain of "parent" to root and then expand the node characters
  one by one.
*/

DWORD
v42bis_decode_match(state, codeword, psize, pRetChar)
v42bis_t *state;
USHORT codeword;
UCHAR   *pRetChar;
int *psize;
{
    node_t *path[256];
    int path_size = 0;
    node_t *base;
    int i;

    V_FLOW(("v42bis_decode_match(%d)", codeword));

    for (base = DICT(codeword); CODE(base); base = DICT(base->parent))
    {
	    path[path_size++] = base;
	    if (path_size >= 256)
        {
	        v42bis_c_error(state, "path_size exceeds 256!");
	        break;
	    }
#ifdef DEBUG
	    if (base == DICT(base->parent))
        {
	        logf("loop! node %d", CODE(base));
	        break;
	    }
#endif
    }

    /* XXX this should not be done here! */
    if (codeword < N5 && DICT(codeword)->byte == 0)
    {
	    DICT(codeword)->byte = codeword - N6;
    }

    D_DEBUG(("path_size %d", path_size));

    for (i = path_size - 1; i >= 0; i--)
    {
	    D_DEBUG(("put byte %02x '%s'",
		     path[i]->byte, show_char(path[i]->byte)));

	    if (path[i]->byte == state->escape)
        {
    	    state->escape += ESCAPE_CYCLE;
        }

    	PUT(path[i]->byte);
    }

    *psize = path_size;

    /* return first (prefix) char of string */
    *pRetChar = path[path_size-1]->byte;

    return ARAPERR_NO_ERROR;
}

/*
  decode L-DATA semantics on the decode side

  decode a buffer full of data...
*/

DWORD
v42bis_decode_buffer(state, data, pDataSize)
v42bis_t *state;
PUCHAR data;
int *pDataSize;
{
    USHORT codeword;
    UCHAR  ch;
    DWORD   dwRetCode;


    V_FLOW(("v42bis_decode_buffer() %d bytes", *pDataSize));

    while (*pDataSize)
    {
        //
        // did we have an overflow?  if so, stop right here
        //
        if (state->OverFlowBytes && data)
        {
            DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_INFO,
                ("Arap v42bis: %d bytes overflowed, suspending decomp\n",
                    state->OverFlowBytes));

            return(ARAPERR_BUF_TOO_SMALL);
        }

#if DBG
        if (state->OverFlowBytes && !data)
        {
            DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                ("Arap v42bis: ALERT! ALERT: (%d)\n",state->OverFlowBytes));

            ASSERT(0);
        }
#endif

        (*pDataSize)--;

	    if (data)
        {
	        /* we have a buffer */
    	    D_DEBUG(("pull 0x%x", *data & 0xff));
    	    codeword = v42bis_decode_codeword(state, *data++);
	    }
        else
        {
	        /* no input buffer, flush */
	        codeword = v42bis_decode_codeword_flush(state);
	        *pDataSize = 0;
	    }

	    DE_DEBUG(("codeword %d (0x%x)", codeword, codeword));

	    /* if decode did not return a value, return */
	    if (codeword == 0xffff)
        {
    	    /* no data */
	        D_DEBUG(("no data"));

	        continue;
	    }

	    if (state->transparent)
        {
    	    /* transparent mode */

	        /* escaped - look at next codeword */
	        if (state->escaped)
            {
		        state->escaped = FALSE;

		        DE_DEBUG(("escape codeword"));

		        /* section 5.8d */
		        if (codeword >= 3 && codeword <= 255)
                {
                    DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
		                ("v42: received reserved code word (%d)", codeword));
		            v42bis_c_error(state, "received reserved code word");
		            break;
		        }

		        switch (codeword)
                {
		            case CCW_ECM:
		                DE_DEBUG(("enter compression mode"));
		                state->transparent = FALSE;

		                /* set up for decode */
		                state->last_decode = state->last_match;
		                state->last_decode_size = state->string_size;

        		        state->exception_next = TRUE;
		                break;

		            case CCW_EID:
		                DE_DEBUG(("escape id"));

		                codeword = state->escape;
		                state->escape += ESCAPE_CYCLE;
		                goto decode_encode;
		                break;

		            case CCW_RESET:
		                DE_DEBUG(("reset"));

		                v42bis_init_dictionary(state);
		                break;
		        }
	        }

            else
            {
		        /* escape? */
		        if (codeword == state->escape)
                {
		            DE_DEBUG(("escape prefix"));
		            state->escaped = TRUE;
		            continue;
		        }

	            decode_encode:
		        /* save data in output buffer */
		        PUT((UCHAR)codeword);

		        /* encode to build dictionary */
		        ch = (UCHAR)codeword;

		        dwRetCode = v42bis_encode_buffer(state, &ch, 1);
                if (dwRetCode != ARAPERR_NO_ERROR)
                {
                    return(dwRetCode);
                }
	        }
	    }
        else
        {
	        int size;

	        /* compression mode */
	        switch (codeword)
            {
	            case CCW_ETM:
		            DE_DEBUG(("enter transparent mode"));

		            v42bis_decode_codeword_flush(state);
		            state->transparent = TRUE;
		            state->last_match = state->last_decode;
		            state->string_size = state->last_decode_size;
		            state->last_new = 0;

            		state->just_flushed = 1;
		            break;

	            case CCW_FLUSH:
		            DE_DEBUG(("flush"));

		            /* terminate search */
		            state->last_match = 0;
		            state->string_size = 0;
		            state->last_match = state->last_decode;
		            state->string_size = state->last_decode_size;
		            state->last_new = 0;

		            /* reset codeword decode machine */
		            state->bits_waiting = 0;
		            state->bits_remaining = 0;
		            break;

                case CCW_STEPUP:
		            DE_DEBUG(("stepup"));

		            /* section 5.8a */;
		            if (state->c2 + 1 > state->n1)
                    {
		                v42bis_c_error(state, "received STEPUP; c2 exceeds max");
                    }
		            else
                    {
		                state->c2++;
                    }
		        break;

	            default:
		            /* regular codeword */

		            /* section 5.8b */
		            if (codeword == state->c1)
                    {
#ifdef DEBUG
		                logf(state, "received codeword equal to c1");
#endif
		                continue;
		            }

		            /* section 5.8c */
		            if (codeword >= N5 && state->dictionary[codeword].parent == 0)
		            {
#ifdef DEBUG
		                logf("received unused codeword %d, full %d, c1 %d",
			            codeword, state->dict_full, state->c1);
#endif
		                v42bis_c_error(state, "received unused codeword");
		            }

		            dwRetCode = v42bis_decode_match(state, codeword, &size, &ch);
                    if (dwRetCode != ARAPERR_NO_ERROR)
                    {
                        return(dwRetCode);
                    }

		            /*
		            * umm... "New dictionary entries shall be created using
		            * the proceedure defined in section 6.4, with the first
		            * (prefix) character of the most recently decoded string
		            * being appended to the previously decoded string."
		            *
		            * what a pain this was to get right!
		            */

		            /* section 8 */
		            state->last_match = state->last_decode;
		            state->string_size = state->last_decode_size;

		            dwRetCode = v42bis_encode_buffer(state, &ch, 1);
                    if (dwRetCode != ARAPERR_NO_ERROR)
                    {
                        return(dwRetCode);
                    }

		            state->last_decode = codeword;
		            state->last_decode_size = (UCHAR)size;
	        }
	    }
    }

    dwRetCode = (state->OverFlowBytes) ?
                    ARAPERR_BUF_TOO_SMALL : ARAPERR_NO_ERROR;

    return(dwRetCode);
}

/*
  v42bis_decode_flush()

  flush codeword decoder and push out data
*/

DWORD
v42bis_decode_flush(state)
v42bis_t *state;
{
    DWORD   dwRetCode;
    int     one;

    V_FLOW(("v42bis_decode_flush()"));

    one = 1;

    dwRetCode = v42bis_decode_buffer(state, (PUCHAR )0, &one);

	return(dwRetCode);
}

/*
  v42bis_c_error()

  implements C-ERROR semantics
*/

DWORD
v42bis_c_error(state, reason_string)
v42bis_t *state;
char *reason_string;
{
    DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
        ("v42bis: C-ERROR with '%s' on %s",reason_string,
	    state == &((v42bis_connection_t *)state->connection)->encode ?
	    "encode" : "decode"));

    ASSERT(0);

	return ARAPERR_NO_ERROR;
}



DWORD
v42bis_init_buffer(state, buf, size)
v42bis_t *state;
PUCHAR buf;
int size;
{
    state->output_buffer = buf;
    state->output_ptr = buf;
    state->output_size = 0;
    state->output_max = (USHORT)size;

	return ARAPERR_NO_ERROR;
}

/*
*/
DWORD
v42bis_connection_init(conn)
v42bis_connection_t *conn;
{
    conn->default_p0 = 3;
    conn->default_p1 = DEF_P1;	/* total # of codewords */
    conn->default_p2 = DEF_P2;	/* max string length */

    conn->neg_p0 = conn->default_p0;	/* direction of compression */
    conn->neg_p1 = conn->default_p1;	/* total # of codewords */
    conn->neg_p2 = (UCHAR)conn->default_p2;	/* max string length */

    /* encode side */
    conn->encode.connection = (void *)conn;
    conn->encode.decode_only = FALSE;

    v42bis_init(&conn->encode);

    /* decode side */
    conn->decode.connection = (void *)conn;
    conn->decode.decode_only = TRUE;

    v42bis_init(&conn->decode);

	return ARAPERR_NO_ERROR;
}

DWORD
v42bis_connection_init_buffers(conn, e_buf, e_size, d_buf, d_size)
v42bis_connection_t *conn;
PUCHAR e_buf;
int e_size;
PUCHAR d_buf;
int d_size;
{
    v42bis_init_buffer(&conn->encode, e_buf, e_size);
    v42bis_init_buffer(&conn->decode, d_buf, d_size);

	return ARAPERR_NO_ERROR;
}

DWORD
v42bis_connection_init_push(conn, context, e_push, d_push)
v42bis_connection_t *conn;
void *context;
void (*e_push)();
void (*d_push)();
{
    conn->encode.push_func = e_push;
    conn->encode.push_context = context;
    conn->decode.push_func = d_push;
    conn->decode.push_context = context;

	return ARAPERR_NO_ERROR;
}

/* ------------- debug -------------- */

#ifdef DEBUG

DWORD
v42bis_dumptree_follownode(state, node)
v42bis_t *state;
USHORT node;
{
    int i;
    node_t *n = DICT(node);

    for (i = 0; i < state->dump_indent; i++)
	fprintf(stderr, "  ");

    fprintf(stderr, "code %d; char %d '%s' parent %d, node %d, leaf %d\n",
	   node, n->byte, show_char(n->byte), n->parent, n->node, n->leaf);

    if (n->node)
	v42bis_dumptree_follownode(state, n->node);

    state->dump_indent++;

    if (n->leaf)
	v42bis_dumptree_follownode(state, n->leaf);

    state->dump_indent--;

	return ARAPERR_NO_ERROR;
}

DWORD
v42bis_dumptree(state, name)
v42bis_t *state;
char *name;
{
    int i;

    fprintf(stderr, "%s codewords:\n", name);
    for (i = 0; i < CODES; i++)
	if (state->dictionary[i].byte) {
	    node_t *n = &state->dictionary[i];

	    fprintf(stderr, "code %d; char %d '%s' parent %d, node %d, leaf %d\n",
		   i, n->byte, show_char(n->byte),
		   n->parent, n->node, n->leaf);
	}

    state->dump_indent = 0;

    fprintf(stderr, "%s tree:\n", name);
    for (i = 0; i < N5; i++)
	if (state->dictionary[i].byte) {
	    node_t *n = &state->dictionary[i];

	    fprintf(stderr, "code %d; root node, %d '%s', leaf %d:\n",
		   i, n->byte, show_char(n->byte), n->leaf);

	    if (state->dictionary[i].leaf) {
		state->dump_indent = 1;
		v42bis_dumptree_follownode(state, n->leaf);
	    }
	}

	return ARAPERR_NO_ERROR;
}

DWORD
v42bis_connection_dumptree(conn)
v42bis_connection_t *conn;
{
    int i;

    fprintf(stderr, "\nv42bis_connection_dumptree()\n");

    v42bis_dumptree(&conn->encode, "encode");
    v42bis_dumptree(&conn->decode, "decode");

	return ARAPERR_NO_ERROR;
}

#endif	/* DEBUG */


/* ------------- external interface -------------- */

DWORD
v42bis_mnp_set_debug(pArapConn)
PARAPCONN pArapConn;
{
#if DEBUG
    pArapConn->v42bis.decode.debug_decode = 0;
    pArapConn->v42bis.decode.debug_encode = 0;

    switch (pArapConn->debug_v42) {
      case 3:
	    pArapConn->v42bis.decode.debug_flow = TRUE;
    	pArapConn->v42bis.encode.debug_flow = TRUE;
	    /* fall through */

      case 2:
	    pArapConn->v42bis.decode.debug_decode_bytes = TRUE;
	    pArapConn->v42bis.decode.debug_encode_bytes = TRUE;

	    pArapConn->v42bis.encode.debug_encode_bytes = TRUE;

	    pArapConn->v42bis.decode.debug_decode++;
	    pArapConn->v42bis.decode.debug_encode++;

	    /* fall through */

      case 1:
	    pArapConn->v42bis.decode.debug_decode++;
	    pArapConn->v42bis.decode.debug_encode++;

	    pArapConn->v42bis.encode.debug_encode = TRUE;
	    break;

      case 0:
	    break;
    }
#endif

	return ARAPERR_NO_ERROR;
}



/*
  v42bis_send()

  send data to V.42bis connection

  input:	unsigned char *buffer; 	pointer to user data buffer
	     	int buflen;		length of user data buffer

  output:	int retcode - if positive, the number of data bytes
		              copied from the user data buffer;
			      if negative, link error code
*/


/*
  v42bis_receive()

  receive data from V.42bis connection

  input:	unsigned char *buffer;	pointer to user buffer
		int buflen;		length of user buffer

  output:	int retcode;	if positive, the number of data bytes
				copied into the user data buffer;
				if negative, link error code
*/



//-----------------------------------------------------------------------------
//
// Interface functions
//
//-----------------------------------------------------------------------------

BOOLEAN
v42bisInit(
  IN  PARAPCONN  pArapConn,
  IN  PBYTE      pReq,
  OUT DWORD     *dwReqToSkip,
  OUT PBYTE      pFrame,
  OUT DWORD     *dwFrameToSkip
)
{

    BYTE        VarLen;
    BOOLEAN     fV42Bis=TRUE;


    DBG_ARAP_CHECK_PAGED_CODE();

    if (ArapGlobs.V42bisEnabled)
    {
        *pFrame++ = MNP_LR_V42BIS;
        VarLen = *pReq;
        *pFrame++ = *pReq++;

        RtlCopyMemory(pFrame, pReq, VarLen);

        fV42Bis = TRUE;

        *dwReqToSkip = (VarLen+1);
        *dwFrameToSkip = (VarLen+2);

        /* init the connection (both encode and decode */
        v42bis_connection_init(pArapConn->pV42bis);

    }
    else
    {
        // send the v42bis type, but 0 for all parms
        DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
            ("v42bisInit: no v42bis (type 1: i.e. 0 for all parms) on %lx\n",pArapConn));

        *pFrame++ = MNP_LR_V42BIS;
        VarLen = *pReq;
        *pFrame++ = *pReq++;

        *pFrame++ = 0;
        *pFrame++ = 0;
        *pFrame++ = 0;
        *pFrame++ = 0;

        fV42Bis = FALSE;

        *dwReqToSkip = (VarLen+1);
        *dwFrameToSkip = (VarLen+2);

    //
    // the other two possibilities to indicate no compression: the one above works,
    // the following two retained just in case we need later
    //
#if 0
        // send the v42bis type, but 0 for the direction flags: other parms valid
        {
            DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                ("v42bisInit: no v42bis (type 2: i.e. 0 only for direction) on %lx\n",pArapConn));

            *pFrame++ = MNP_LR_V42BIS;
            VarLen = *pReq;
            *pFrame++ = *pReq++;

            *pFrame++ = 0;
            *pFrame++ = 0;
            *pFrame++ = 0x8;
            *pFrame++ = 0xfa;

            fV42Bis = FALSE;

            *dwReqToSkip = (VarLen+1);
            *dwFrameToSkip = (VarLen+2);
        }

        // skip the v42bis type altogether
        {
            DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                ("v42bisInit: no v42bis (type 3: i.e. not sending v42bis type) on %lx\n",pArapConn));

            VarLen = *pReq;

            fV42Bis = FALSE;

            *dwReqToSkip = (VarLen+1);
            *dwFrameToSkip = 0;
        }
#endif

    }

    return(fV42Bis);
}

DWORD
v42bisCompress(
  IN  PARAPCONN  pArapConn,
  IN  PUCHAR     pUncompressedData,
  IN  DWORD      UnCompressedDataLen,
  OUT PUCHAR     pCompressedData,
  OUT DWORD      CompressedDataBufSize,
  OUT DWORD     *pCompressedDataLen
)
{
    DWORD   dwRetCode;


    DBG_ARAP_CHECK_PAGED_CODE();

    DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_INFO,("v42bisCompress (%lx, %lx, %ld)\n",
        pArapConn, pUncompressedData, UnCompressedDataLen));

#ifdef V42_DUMP_ENABLED
    if (pArapConn->v42_dump) {
	pArapConn->v42_size = buflen;
	pArapConn->v42_type = 2;
	write(pArapConn->v42_dump, &pArapConn->v42_esize, 4);
	write(pArapConn->v42_dump, bufptr, buflen);
    }
#endif

    v42bis_init_buffer(&pArapConn->pV42bis->encode,
                       pCompressedData,
                       CompressedDataBufSize);

    dwRetCode = v42bis_encode_buffer(&pArapConn->pV42bis->encode,
                                     pUncompressedData,
                                     UnCompressedDataLen);

    if (dwRetCode != ARAPERR_NO_ERROR)
    {
        return(dwRetCode);
    }

    dwRetCode = v42bis_encode_flush(&pArapConn->pV42bis->encode);

    // set the length of compressed data
    *pCompressedDataLen = pArapConn->pV42bis->encode.output_size;

    return(dwRetCode);
}

DWORD
v42bisDecompress(
  IN  PARAPCONN  pArapConn,
  IN  PUCHAR     pCompressedData,
  IN  DWORD      CompressedDataLen,
  OUT PUCHAR     pDecompressedData,
  OUT DWORD      DecompressedDataBufSize,
  OUT DWORD     *pByteStillToDecompress,
  OUT DWORD     *pDecompressedDataLen
)
{

    DWORD   dwRetCode;
    DWORD   dwRemaingDataSize;
    DWORD   dwOverFlow;


    DBG_ARAP_CHECK_PAGED_CODE();

    DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_INFO,("v42bisDecompress (%lx, %lx, %ld)\n",
        pArapConn, pCompressedData, CompressedDataLen));


    *pDecompressedDataLen = 0;

    dwRemaingDataSize = CompressedDataLen;

    *pByteStillToDecompress = CompressedDataLen;



#ifdef V42_DUMP_ENABLED
    if (pArapConn->v42_dump) {
	pArapConn->v42_size = mnp_size;
	pArapConn->v42_type = 2;
	write(pArapConn->v42_dump, &pArapConn->v42_size, 4 + mnp_size);
    }
#endif

    //
    // if we had an overflow in the previous decomp effort, we have bytes in
    // the overflow buffer: copy those in first.
    //
    if ( (dwOverFlow = pArapConn->pV42bis->decode.OverFlowBytes) > 0)
    {
        if (DecompressedDataBufSize <= dwOverFlow)
        {
            return(ARAPERR_BUF_TOO_SMALL);
        }


        DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_INFO,
            ("Arap v42bis: (%lx) copying %d overflow bytes first\n",
                pArapConn, dwOverFlow));

        RtlCopyMemory(pDecompressedData,
                      pArapConn->pV42bis->decode.OverFlowBuf,
                      dwOverFlow);

        pDecompressedData += dwOverFlow;

        DecompressedDataBufSize -= dwOverFlow;

        pArapConn->pV42bis->decode.OverFlowBytes = 0;

        *pDecompressedDataLen += dwOverFlow;
    }


    //
    // this can happen if we got called because we told in a previous call that
    // there was buffer overflow and there was nothing more left to decompress
    //
    if (CompressedDataLen == 0)
    {
        return(ARAPERR_NO_ERROR);
    }

    //
    // set decomp buffer to the buffer supplied
    //
    v42bis_init_buffer(&pArapConn->pV42bis->decode,
                       pDecompressedData,
                       DecompressedDataBufSize);

    /* decode everything we got */
    dwRetCode = v42bis_decode_buffer(&pArapConn->pV42bis->decode,
                                     pCompressedData,
                                     &dwRemaingDataSize);


    *pByteStillToDecompress = dwRemaingDataSize;


    //
    // how big is the decompressed data?
    //
    *pDecompressedDataLen += pArapConn->pV42bis->decode.output_size;

    return(dwRetCode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\atalk\sys\zip.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

	zip.h

Abstract:

	This module contains information for the Zone Information Protocol.

Author:

	Jameel Hyder (jameelh@microsoft.com)
	Nikhil Kamkolkar (nikhilk@microsoft.com)

Revision History:
	19 Jun 1992		Initial Version

Notes:	Tab stop: 4
--*/

#ifndef	_ZIP_
#define	_ZIP_

#define MAX_ZONE_LENGTH			32

#define MAX_ZONES_PER_NET	    255	// AppleTalk phase 2

// ZIP specific data:

#define ZIP_QUERY						1
#define ZIP_REPLY						2
#define ZIP_TAKEDOWN					3
#define ZIP_BRINGUP						4
#define ZIP_GET_NETINFO					5
#define ZIP_NETINFO_REPLY				6
#define ZIP_NOTIFY						7
#define ZIP_EXT_REPLY					8

#define ZIP_ONEZONEQUERY_DDPSIZE		4
#define ZIP_GETZONELIST_DDPSIZE			8

// For GetZoneList and GetMyZone we're handling simple ATP packets:

#define ATP_ZIP_CMD_OFF				(ATP_USER_BYTES_OFF + 0)
#define ATP_ZIP_LAST_FLAG_OFF		(ATP_USER_BYTES_OFF + 0)
#define ATP_ZIP_START_INDEX_OFF		(ATP_USER_BYTES_OFF + 2)
#define ATP_ZIP_ZONE_CNT_OFF		(ATP_USER_BYTES_OFF + 2)
#define ATP_ZIP_FIRST_ZONE_OFF		(ATP_USER_BYTES_OFF + 4)

// Offsets into the datagram
#define	ZIP_CMD_OFF						0
#define	ZIP_NW_CNT_OFF					1
#define	ZIP_FLAGS_OFF					1
#define	ZIP_FIRST_NET_OFF				2	// Zip Query/Reply
#define	ZIP_FIRST_ZONELEN_OFF			4
#define	ZIP_LAST_NET_OFF				4	// Zip Query/Reply
#define	ZIP_FIRST_ZONENAME_OFF			5
#define	ZIP_REQ_ZONELEN_OFF				6	// Zip Query/Reply
#define	ZIP_REQ_ZONENAME_OFF			7	// Zip Query/Reply

#define	ZIP_CABLE_RANGE_START_OFF		2	// Phase II Values
#define	ZIP_CABLE_RANGE_END_OFF			4
#define	ZIP_ZONELEN_OFF					6
#define	ZIP_OLD_ZONELEN_OFF				6
#define	ZIP_ZONENAME_OFF				7
#define	ZIP_OLD_ZONENAME_OFF			7


// The three ZIP ATP commands:

#define ZIP_GET_MY_ZONE					7
#define ZIP_GET_ZONE_LIST				8
#define ZIP_GET_LOCAL_ZONES				9

// The ZIP NetInfoReply and Notify flags.

#define ZIP_ZONE_INVALID_FLAG			0x80
#define ZIP_USE_BROADCAST_FLAG			0x40
#define ZIP_ONLYONE_ZONE_FLAG			0x20

// When we're starting up (on extended networks) we send out a few NetGetInfo's
// to try to find out our zone name.  This seems to be what phase II Macintosh
// nodes do (timing wise):

#define ZIP_GET_NETINFO_WAIT			500		// In Ms
#define ZIP_NUM_GETNET_INFOS	  		3

// When nodes are doing either GetMyZone (non-extended only) or GetZoneList
// (both flavours) the request is sent to A-ROUTER a few times:

#define ZIP_GET_ZONEINFO_TIMER			10		// In 100ms units
#define ZIP_GET_ZONEINFO_RETRIES		3

// The ZIP specific timer values:

#define ZIP_QUERY_TIMER					100		// In 100ms units

// When we're looking for the zone list of a network, when starting the
// router, how many zip queries?  how fast?

#define ZIP_QUERY_WAIT					10		// In Ms
#define ZIP_NUM_QUERIES					30
#define	ZIP_NUM_RETRIES					10

#define ZONE_NAMES                      1
#define ZONE_NUM                        2


//	Zone structure
typedef	struct _ZONE
{
	struct _ZONE *		zn_Next;		// Next zone in the table
	struct _ZONE **		zn_Prev;		// Next zone in the table
	LONG				zn_RefCount;	// Reference count
	BYTE				zn_ZoneLen;		// Length of the zone name string
	BYTE				zn_Zone[1];		// Zone string, not null-terminated

} ZONE, *PZONE;

#define	ZONES_EQUAL(pZ1, pZ2)	AtalkFixedCompareCaseInsensitive(	\
									(pZ1)->zn_Zone,					\
									(pZ1)->zn_ZoneLen,				\
									(pZ2)->zn_Zone,					\
									(pZ1)->zn_ZoneLen)				\

typedef	struct _ZONE_LIST
{
	struct _ZONE_LIST *	zl_Next;		// Next zone on the list
	PZONE				zl_pZone;		// The zone itself
} ZONE_LIST, *PZONE_LIST;

#define	NUM_ZONES_HASH_BUCKETS	23
extern	ATALK_SPIN_LOCK			AtalkZoneLock;
extern	PZONE *					AtalkZonesTable;
extern	PZONE					AtalkDesiredZone;

extern
ATALK_ERROR
AtalkZipInit(
	IN	BOOLEAN	Init
);

extern
VOID
AtalkZipMulticastAddrForZone(
	IN	PPORT_DESCRIPTOR		pPortDesc,
	IN	PBYTE					pZone,
	IN	BYTE					ZoneLen,
	IN	PBYTE					MulticastAddr
);

extern
BOOLEAN
AtalkZipGetNetworkInfoForNode(
	IN	PPORT_DESCRIPTOR		pPortDesc,
	IN	PATALK_NODEADDR			pNode,
	IN	BOOLEAN					FindDefZone
);

extern
VOID
AtalkZipPacketIn(
	IN	PPORT_DESCRIPTOR		pPortDesc,
	IN	PDDP_ADDROBJ			pDdpAddr,
	IN	PBYTE					pPkt,
	IN	USHORT					PktLen,
	IN	PATALK_ADDR				pSrcAddr,
	IN	PATALK_ADDR				pDstAddr,
	IN	ATALK_ERROR				ErrorCode,
	IN	BYTE					DdpType,
	IN	PVOID					pHandlerCtx,
	IN	BOOLEAN					OptimizePath,
	IN	PVOID					OptimizeCtx
);

extern
VOID
AtalkZipPacketInRouter(
	IN	PPORT_DESCRIPTOR		pPortDesc,
	IN	PDDP_ADDROBJ			pDdpAddr,
	IN	PBYTE					pPkt,
	IN	USHORT					PktLen,
	IN	PATALK_ADDR				pSrcAddr,
	IN	PATALK_ADDR				pDstAddr,
	IN	ATALK_ERROR				ErrorCode,
	IN	BYTE					DdpType,
	IN	PVOID					pHandlerCtx,
	IN	BOOLEAN					OptimizePath,
	IN	PVOID					OptimizeCtx
);

BOOLEAN
AtalkInitZipStartProcessingOnPort(
	IN	PPORT_DESCRIPTOR 		pPortDesc,
	IN	PATALK_NODEADDR			RouterNode
);

extern
ATALK_ERROR
AtalkZipGetMyZone(
	IN		PPORT_DESCRIPTOR	pPortDesc,
	IN		BOOLEAN				fDesired,
	IN	OUT	PAMDL				pAMdl,
	IN		INT					Size,
	IN		struct _ActionReq *	pActReq
);

extern
ATALK_ERROR
AtalkZipGetZoneList(
	IN		PPORT_DESCRIPTOR	pPortDesc,
	IN		BOOLEAN				fLocalZones,
	IN	OUT	PAMDL				pAMdl,
	IN		INT					Size,
	IN		struct _ActionReq *	pActReq
);

extern
PZONE
AtalkZoneReferenceByName(
	IN	PBYTE					ZoneName,
	IN	BYTE					ZoneLen
);

extern
VOID
AtalkZoneReferenceByPtr(
	IN	PZONE					pZone
);

VOID
AtalkZoneDereference(
	IN	PZONE					pZone
);

extern
VOID
AtalkZoneFreeList(
	IN	PZONE_LIST				pZoneList
);

extern
ULONG
AtalkZoneNumOnList(
	IN	PZONE_LIST				ZoneList
);

extern
PZONE_LIST
AtalkZoneAddToList(
	IN	PZONE_LIST				ZoneList,
	IN	PBYTE					Zone,
	IN	BYTE					ZoneLen
);

extern
PZONE_LIST
AtalkZoneCopyList(
	IN	PZONE_LIST				ZoneList
);

extern
BOOLEAN
AtalkZoneNameOnList(
	IN	PBYTE					ZoneName,
	IN	BYTE					ZoneLen,
	IN	PZONE_LIST				pZoneList
);

extern
BOOLEAN
AtalkZoneOnList(
	IN	PZONE					pZone,
	IN	PZONE_LIST				pZoneList
);

extern	TIMERLIST				atalkZipQTimer;
extern  BOOLEAN                 atalkZipQryTmrRunning;

LOCAL VOID
atalkZipHandleNetInfo(
	IN	PPORT_DESCRIPTOR		pPortDesc,
	IN	PDDP_ADDROBJ			pDdpAddr,
	IN	PATALK_ADDR				pSrcAddr,
	IN	PATALK_ADDR				pDstAddr,
	IN	PBYTE					pPkt,
	IN	USHORT					PktLen
);

LOCAL VOID
atalkZipHandleReply(
	IN	PDDP_ADDROBJ			pDdpAddr,
	IN	PATALK_ADDR				pSrcAddr,
	IN	PBYTE					pPkt,
	IN	USHORT					PktLen
);

LOCAL VOID
atalkZipHandleQuery(
	IN	PPORT_DESCRIPTOR		pPortDesc,
	IN	PDDP_ADDROBJ			pDdpAddr,
	IN	PATALK_ADDR				pSrcAddr,
	IN	PBYTE					pPkt,
	IN	USHORT					PktLen
);

LOCAL VOID
atalkZipHandleAtpRequest(
	IN	PPORT_DESCRIPTOR		pPortDesc,
	IN	PDDP_ADDROBJ			pDdpAddr,
	IN	PATALK_ADDR				pSrcAddr,
	IN	BYTE					CmdType,
	IN	USHORT					TrId,
	IN	USHORT					StartIndex
);

LOCAL LONG FASTCALL
atalkZipQueryTimer(
	IN	PTIMERLIST				pContext,
	IN	BOOLEAN					TimerShuttingDown
);

LOCAL BOOLEAN
atalkZipGetZoneListForPort(
	IN	PPORT_DESCRIPTOR		pPortDesc
);

// Control blocks from processing GetMyZone and GetZoneList calls
#define		ZCI_SIGNATURE			(*(PULONG)"ZCI")
#if	DBG
#define	VALID_ZCI(pZci)	(((pZci) != NULL) &&	\
						 ((pZci)->zci_Signature == ZCI_SIGNATURE))
#else
#define	VALID_ZCI(pZci)	((pZci) != NULL)
#endif
typedef struct _ZipCompletionInfo
{
#if	DBG
	ULONG						zci_Signature;
#endif
	LONG						zci_RefCount;
	PPORT_DESCRIPTOR			zci_pPortDesc;
	PDDP_ADDROBJ				zci_pDdpAddr;
	DDPAO_HANDLER				zci_Handler;
	PAMDL						zci_pAMdl;
	INT							zci_BufLen;
	PACTREQ						zci_pActReq;
	ATALK_ADDR					zci_Router;
	TIMERLIST					zci_Timer;
	USHORT						zci_NextZoneOff;
	SHORT						zci_ZoneCount;
	SHORT						zci_ExpirationCount;
	SHORT						zci_AtpRequestType;
	ATALK_ERROR					zci_FinalStatus;
	BYTE						zci_Datagram[ZIP_GETZONELIST_DDPSIZE];
	ATALK_SPIN_LOCK				zci_Lock;
} ZIPCOMPLETIONINFO, *PZIPCOMPLETIONINFO;

LOCAL VOID
atalkZipGetMyZoneReply(
	IN	PPORT_DESCRIPTOR		pPortDesc,
	IN	PDDP_ADDROBJ			pDdpAddr,
	IN	PBYTE					pPkt,
	IN	USHORT					PktLen,
	IN	PATALK_ADDR				pSrcAddr,
	IN	PATALK_ADDR				pDstAddr,
	IN	ATALK_ERROR				ErrorCode,
	IN	BYTE					DdpType,
	IN	PZIPCOMPLETIONINFO		pZci,
	IN	BOOLEAN					OptimizePath,
	IN	PVOID					OptimizeCtx
);

LOCAL VOID
atalkZipGetZoneListReply(
	IN	PPORT_DESCRIPTOR		pPortDesc,
	IN	PDDP_ADDROBJ			pDdpAddr,
	IN	PBYTE					pPkt,
	IN	USHORT					PktLen,
	IN	PATALK_ADDR				pSrcAddr,
	IN	PATALK_ADDR				pDstAddr,
	IN	ATALK_ERROR				ErrorCode,
	IN	BYTE					DdpType,
	IN	PZIPCOMPLETIONINFO		pZci,
	IN	BOOLEAN					OptimizePath,
	IN	PVOID					OptimizeCtx
);

LOCAL ATALK_ERROR
atalkZipSendPacket(
	IN	PZIPCOMPLETIONINFO		pZci,
	IN	BOOLEAN					TimerEnqueue
);

LOCAL VOID
atalkZipDereferenceZci(
	IN	PZIPCOMPLETIONINFO		pZci
);

LOCAL LONG FASTCALL
atalkZipZoneInfoTimer(
	IN	PTIMERLIST				pTimer,
	IN	BOOLEAN					TimerShuttingDown
);

LOCAL VOID FASTCALL
atalkZipSendComplete(
	IN	NDIS_STATUS				Status,
	IN	PSEND_COMPL_INFO		pSendInfo
);

#endif	// _ZIP_


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\atalk\winsock\nspatalk.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    nspatalk.h

Abstract:

    Contains support for the winsock 1.x Name Space Provider for Appletalk.

Author:

    Sue Adams (suea)    10-Mar-1995

Revision History:

--*/
#define UNICODE

//
// MappingTriple structures and associated data for Appletalk
//
#define PMDL    PVOID       // AtalkTdi.h uses PMDL

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windef.h>
#include <winbase.h>
#include <tdi.h>
#include <winsock.h>
#include <atalkwsh.h>
#include <nspapi.h>
#include <nspapip.h>
#include <wsahelp.h>
#include <wshatalk.h>

#define DLL_VERSION        1
#define WSOCK_VER_REQD     0x0101

#define ZIP_NAME        L"ZIP"
#define RTMP_NAME       L"RTMP"
#define PAP_NAME        L"PAP"
#define ADSP_NAME       L"ADSP"

INT
NbpGetAddressByName(
    IN LPGUID      lpServiceType,
    IN LPWSTR      lpServiceName,
    IN LPDWORD     lpdwProtocols,
    IN DWORD       dwResolution,
    IN OUT LPVOID  lpCsAddrBuffer,
    IN OUT LPDWORD lpdwBufferLength,
    IN OUT LPWSTR  lpAliasBuffer,
    IN OUT LPDWORD lpdwAliasBufferLength,
    IN HANDLE      hCancellationEvent
);


NTSTATUS
NbpSetService (
    IN     DWORD           dwOperation,
    IN     DWORD           dwFlags,
    IN     BOOL            fUnicodeBlob,
    IN     LPSERVICE_INFO  lpServiceInfo
);

NTSTATUS
GetNameInNbpFormat(
        IN              LPGUID                          pType,
        IN              LPWSTR                          pObject,
        IN OUT  PWSH_NBP_NAME           pNbpName
);


NTSTATUS
NbpLookupAddress(
    IN          PWSH_NBP_NAME           pNbpLookupName,
        IN              DWORD                           nProt,
        IN OUT  LPVOID                          lpCsAddrBuffer,
    IN OUT      LPDWORD                         lpdwBufferLength,
    OUT         LPDWORD                         lpcAddress
);


DWORD
FillBufferWithCsAddr(
    IN PSOCKADDR_AT pAddress,
    IN DWORD        nProt,
    IN OUT LPVOID   lpCsAddrBuffer,
    IN OUT LPDWORD  lpdwBufferLength,
    OUT LPDWORD     pcAddress
);

DWORD
NbpRegDeregService(
        IN DWORD                        dwOperation,
        IN PWSH_NBP_NAME        pNbpName,
        IN PSOCKADDR_AT         pSockAddr
);



//
// Macros
//


#if DBG
#define DBGPRINT(Fmt)                                                                                   \
        {                                                                                                               \
                        DbgPrint("WSHATALK: ");                                                         \
                        DbgPrint Fmt;                                                                           \
                }

#define DBGBRK()                                                                                \
                {                                                                                                               \
                                DbgBreakPoint();                                                                \
                }
#else

#define DBGPRINT(Fmt)
#define DBGBRK()

#endif


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\atalk\winsock\nspatalk.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    nspatalk.c

Abstract:

    Contains support for the winsock 1.x Name Space Provider for Appletalk.

Author:

    Sue Adams (suea)    10-Mar-1995

Revision History:

--*/

#include "nspatalk.h"

#define ADSP_BIT    0x0001  // Bitmask used internally to store the
#define PAP_BIT		0x0002	// protocols requested by the caller


INT
APIENTRY
NPLoadNameSpaces(
    IN OUT LPDWORD      lpdwVersion,
    IN OUT LPNS_ROUTINE nsrBuffer,
    IN OUT LPDWORD      lpdwBufferLength
    )
/*++

Routine Description:

    This routine returns name space info and functions supported in this
    dll.

Arguments:

    lpdwVersion - dll version

    nsrBuffer - on return, this will be filled with an array of
        NS_ROUTINE structures

    lpdwBufferLength - on input, the number of bytes contained in the buffer
        pointed to by nsrBuffer. On output, the minimum number of bytes
        to pass for the nsrBuffer to retrieve all the requested info

Return Value:

    The number of NS_ROUTINE structures returned, or SOCKET_ERROR (-1) if
    the nsrBuffer is too small. Use GetLastError() to retrieve the
    error code.

--*/
{
    DWORD err;
    DWORD dwLengthNeeded;

    *lpdwVersion = DLL_VERSION;

    //
    // Check to see if the buffer is large enough
    //
    dwLengthNeeded = sizeof(NS_ROUTINE) + 4 * sizeof(LPFN_NSPAPI);

    if (  ( *lpdwBufferLength < dwLengthNeeded )
       || ( nsrBuffer == NULL )
       )
    {
        *lpdwBufferLength = dwLengthNeeded;
        SetLastError( ERROR_INSUFFICIENT_BUFFER );
        return (DWORD) SOCKET_ERROR;
    }

    //
    // We only support 1 name space, so fill in the NS_ROUTINE.
    //
    nsrBuffer->dwFunctionCount = 3;
    nsrBuffer->alpfnFunctions = (LPFN_NSPAPI *)
        ((BYTE *) nsrBuffer + sizeof(NS_ROUTINE));
    (nsrBuffer->alpfnFunctions)[NSPAPI_GET_ADDRESS_BY_NAME] =
        (LPFN_NSPAPI) NbpGetAddressByName;
    (nsrBuffer->alpfnFunctions)[NSPAPI_GET_SERVICE] = NULL;
    (nsrBuffer->alpfnFunctions)[NSPAPI_SET_SERVICE] =
        (LPFN_NSPAPI) NbpSetService;
    (nsrBuffer->alpfnFunctions)[3] = NULL;

    nsrBuffer->dwNameSpace = NS_NBP;
    nsrBuffer->dwPriority  = NS_STANDARD_PRIORITY;

    return 1;  // number of namespaces
}


INT
NbpGetAddressByName(
    IN LPGUID      lpServiceType,
    IN LPWSTR      lpServiceName,
    IN LPDWORD     lpdwProtocols,
    IN DWORD       dwResolution,
    IN OUT LPVOID  lpCsAddrBuffer,
    IN OUT LPDWORD lpdwBufferLength,
    IN OUT LPWSTR  lpAliasBuffer,
    IN OUT LPDWORD lpdwAliasBufferLength,
    IN HANDLE      hCancellationEvent
)
/*++

Routine Description:

    This routine returns address information about a specific service.

Arguments:

    lpServiceType - pointer to the GUID for the service type

    lpServiceName - unique string representing the service name.

    lpdwProtocols - a zero terminated array of protocol ids. This parameter
        is optional; if lpdwProtocols is NULL, information on all available
        Protocols is returned

    dwResolution - can be one of the following values:RES_SERVICE

    lpCsAddrBuffer - on return, will be filled with CSADDR_INFO structures

    lpdwBufferLength - on input, the number of bytes contained in the buffer
        pointed to by lpCsAddrBuffer. On output, the minimum number of bytes
        to pass for the lpCsAddrBuffer to retrieve all the requested info

    lpAliasBuffer - not used

    lpdwAliasBufferLength - not used

    hCancellationEvent - the event which signals us to cancel the request

Return Value:

    The number of CSADDR_INFO structures returned, or SOCKET_ERROR (-1) if
    the lpCsAddrBuffer is too small. Use GetLastError() to retrieve the
    error code.

--*/
{
    DWORD err;
	WSH_NBP_NAME NbpLookupName;
    DWORD cAddress = 0;   // Count of the number of address returned
                          // in lpCsAddrBuffer
    DWORD cProtocols = 0; // Count of the number of protocols contained
                          // in lpdwProtocols + 1 ( for zero terminate )
    DWORD nProt = ADSP_BIT | PAP_BIT;

    if (  ARGUMENT_PRESENT( lpdwAliasBufferLength )
       && ARGUMENT_PRESENT( lpAliasBuffer )
       )
    {
        if ( *lpdwAliasBufferLength >= sizeof(WCHAR) )
           *lpAliasBuffer = 0;
    }

//DebugBreak();

    //
    // Check for invalid parameters
    //
    if (  ( lpServiceType == NULL )
       || ( (lpServiceName == NULL) && (dwResolution != RES_SERVICE) )
       || ( lpdwBufferLength == NULL )
       )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return SOCKET_ERROR;
    }

    // The size of the user's buffer will dictate also how many
	// tuples can be returned from the NBP lookup in case they
    // are querying using wildcards.
	if ( *lpdwBufferLength < (sizeof(WSH_LOOKUP_NAME) + sizeof(WSH_NBP_TUPLE)) )
	{
        SetLastError( ERROR_INSUFFICIENT_BUFFER );
        return SOCKET_ERROR;
	}

	//
    // If an array of protocol ids is passed in, check to see if
    // the ADSP or PAP protocol is requested. If not, return 0 since
    // we only support these 2.
    //
    if ( lpdwProtocols != NULL )
    {
        INT i = -1;

        nProt = 0;
        while ( lpdwProtocols[++i] != 0 )
        {
            if ( lpdwProtocols[i] == ATPROTO_ADSP )
                nProt |= ADSP_BIT;

            if ( lpdwProtocols[i] == ATPROTO_PAP )
                nProt |= PAP_BIT;
        }

        if ( nProt == 0 )
			return 0;  // No address found

    }


	//
	// If this is a service asking what local address to use when
	// bind()-ing its appletalk socket, return the generic Appletalk
	// socket address.
	//
    if ((dwResolution & RES_SERVICE) != 0)
    {
        err = FillBufferWithCsAddr( NULL,
                                    nProt,
                                    lpCsAddrBuffer,
                                    lpdwBufferLength,
                                    &cAddress );

        if ( err )
        {
            SetLastError( err );
            return SOCKET_ERROR;
        }

        return cAddress;
    }

    //
	// This is a client trying to do an NBP lookup on an Appletalk
	// named entity to find out what remote address to connect() to.
	//
	err = GetNameInNbpFormat(lpServiceType,
							 lpServiceName,
							 &NbpLookupName);
	if (err)
	{
		KdPrint(("GetNameInNbpFormat failed with error %d for name %ws\n", err, lpServiceName ));
		SetLastError(err);
		return SOCKET_ERROR;
	}

    err = NbpLookupAddress( &NbpLookupName,
							nProt,
							lpCsAddrBuffer,
							lpdwBufferLength,
							&cAddress );
#if DBG
   if ( err == NO_ERROR )
    {
        KdPrint(("NbpGetAddrByName:Successfully got %d address for %ws from NBP.\n",
                cAddress, lpServiceName ));
    }
    else
    {
        KdPrint(("NbpGetAddrByName:Failed with err %d when getting address for %ws from NBP.\n", err, lpServiceName ));
    }
#endif

    if ( err )
    {
        SetLastError( err );
        return SOCKET_ERROR;
    }

    return cAddress;

}


NTSTATUS
GetNameInNbpFormat(
	IN		LPGUID				pServiceType,
	IN		LPWSTR				pServiceName,
	IN OUT 	PWSH_NBP_NAME		pNbpName
)
/*++

	Routine description:

		Convert pServiceType and pServiceName to system ANSI strings in
		the pLookupName structure so they can be used to do NBP lookup.

    Arguments:


	Return value:
	
--*/
{
	INT		err;
	WCHAR	wtypeBuf[MAX_ENTITY + 1];
	CHAR	entityBuf[(MAX_ENTITY + 1) * 2];	// potentially all multibyte
	PWCHAR  pColon, pAtSign, pType = wtypeBuf, pObject = pServiceName, pZone = L"*";

	// Parse the service name for "object:type@zone" form.  If we find a
	// ':' there must also be a '@' (and vice-versa).
	// If there is a type in the servicename string, we will still convert
	// the LPGUID to a string.  If the types don't match return an error.
	// So, we will accept the following forms for the service name:
	// object OR object:type@zone.  If just object is given, then the zone
	// used will be the default zone "*". Wildcards are acceptible for
	// NBP Lookup, but not for NBP (De)Register. No checking is done for that.
	//
	pColon  = wcschr(pServiceName, L':');
	pAtSign = wcschr(pServiceName, L'@');

	if ( ((pColon != NULL) && (pAtSign == NULL)) ||
		 ((pAtSign != NULL) && (pColon == NULL)) ||
		 (pColon > pAtSign) )
	{
		return(ERROR_INVALID_PARAMETER);
	}

	//
	// By default we only use our own local zone
	//
	if (pAtSign != NULL)
	{
		pZone = pAtSign + 1;
		if ((wcslen(pZone) == 0) ||
			(wcslen(pZone) > MAX_ENTITY))
		{
			return ERROR_INVALID_PARAMETER;
		}
	}
	if (WideCharToMultiByte(CP_ACP,
							0,
							pZone,
							-1,				// says that wchar string is null terminated
							entityBuf,
							sizeof(entityBuf),
							NULL,
							NULL) == 0)
	{
		DBGPRINT(("GetNameInNbpFormat FAILED wctomb %ws\n", pZone));

		return GetLastError();
	}
	pNbpName->ZoneNameLen = strlen( entityBuf );
    memcpy( pNbpName->ZoneName,
			entityBuf,
			pNbpName->ZoneNameLen );

	if (pAtSign != NULL)
	{
		// change the @ to a null so the type will be null terminated
		*pAtSign = 0;
	}

	//
	// Convert the Type string
	//

	err = GetNameByType(pServiceType, wtypeBuf, sizeof(wtypeBuf));
	if (err != NO_ERROR)
	{
		// Appletalk type can be 32 chars max, so if this
		// fails with buffer too small error it couldn't be
		// used on appletalk anyway
		return err;
	}

	// If there was a type name in the ServiceName, then it better match
	// what the LPGUID resolved to.
	if (pColon != NULL)
	{
		pType = pColon + 1;
		if ((wcslen(pType) == 0) ||
//			(wcscmp(pType, wtypeBuf) != 0) ||
			(wcslen(pType) > MAX_ENTITY))
		{
			return ERROR_INVALID_PARAMETER;
		}
	}

	if (WideCharToMultiByte(CP_ACP,
							0,
							pType,
							-1,				// says that wchar string is null terminated
							entityBuf,
							sizeof(entityBuf),
							NULL,
							NULL) == 0)
	{
		DBGPRINT(("GetNameInNbpFormat FAILED wctomb %ws\n", pType));

		return GetLastError();
	}
	pNbpName->TypeNameLen = strlen( entityBuf );
	memcpy( pNbpName->TypeName,
			entityBuf,
			pNbpName->TypeNameLen );

    if (pColon != NULL)
	{
		// change the colon to a null so the object will be null terminated
		*pColon = 0;
	}

	//
	// Convert the Object string
	//
	if ((wcslen(pObject) == 0) ||
		(wcslen(pObject) > MAX_ENTITY))
	{
		return ERROR_INVALID_PARAMETER;
	}
	if (WideCharToMultiByte(CP_ACP,
							0,
							pServiceName,
							-1,				// says that wchar string is null terminated
							entityBuf,
							sizeof(entityBuf),
							NULL,
							NULL) == 0)
	{
		DBGPRINT(("GetNameInNbpFormat FAILED wctomb %ws\n", pServiceName));

		return GetLastError();
	}
	pNbpName->ObjectNameLen = strlen( entityBuf );
    memcpy( pNbpName->ObjectName,
			entityBuf,
			pNbpName->ObjectNameLen );


	return STATUS_SUCCESS;

} // GetNameInNbpFormat

NTSTATUS
NbpLookupAddress(
    IN		PWSH_NBP_NAME 		pNbpLookupName,
	IN		DWORD				nProt,
	IN OUT	LPVOID				lpCsAddrBuffer,
    IN OUT	LPDWORD				lpdwBufferLength,
    OUT 	LPDWORD				lpcAddress
)
/*++

Routine Description:

    This routine uses NBP requests to find the address of the given service
    name/type.

Arguments:

	pNbpLookupName - NBP name to lookup

	nProt - ADSP_BIT | PAP_BIT

    lpCsAddrBuffer - on return, will be filled with CSADDR_INFO structures

    lpdwBufferLength - on input, the number of bytes contained in the buffer
        pointed to by lpCsAddrBuffer. On output, the minimum number of bytes
        to pass for the lpCsAddrBuffer to retrieve all the requested info

    hCancellationEvent - the event which signals us to cancel the request???

    lpcAddress - on output, the number of CSADDR_INFO structures returned

Return Value:

    Win32 error code.

--*/
{
    DWORD err = NO_ERROR;
    NTSTATUS ntstatus;

	WSADATA wsaData;
    SOCKET socketNbp;
    SOCKADDR_AT socketAddr = {AF_APPLETALK, 0, 0, 0};
	PWSH_LOOKUP_NAME   pWshLookupName;
	PWSH_ATALK_ADDRESS pWshATAddr;
	PBYTE	pTmp = lpCsAddrBuffer;
	DWORD	templen = *lpdwBufferLength;
	DWORD	bufsize;
	PBYTE	buf = NULL;

	int i;

    *lpcAddress = 0;

    //
    // Initialize the socket interface
    //
    err = WSAStartup( WSOCK_VER_REQD, &wsaData );
    if ( err )
    {
        return err;
    }

    //
    // Open an Appletalk datagram socket
	// ISSUE: should we use DDPPROTO_NBP, or just a random
	// dynamic DDP socket? Or an ADSP socket since we know
	// that works and has been tested...Does it really matter
	// since this only defines what devicename will be opened
	// in the appletalk driver i.e. \\device\\atalkddp\2 .
    //
    socketNbp = socket( AF_APPLETALK, SOCK_DGRAM, DDPPROTO_NBP);
    if ( socketNbp == INVALID_SOCKET )
    {
        err = WSAGetLastError();
        (VOID) WSACleanup();
        return err;
    }

	do
	{
		//
		// Bind the socket (this does not actually go thru
		// the WSHAtalk helper dll, it goes thru AFD which
		// Ioctls appletalk directly.  The node and net values
		// are ignored, and socket 0 means give me a dynamic
		// socket number)
		//
		if ( bind( socketNbp,
				   (PSOCKADDR) &socketAddr,
				   sizeof( SOCKADDR_AT)) == SOCKET_ERROR )
		{
			err = WSAGetLastError();
			break;
		}

		//
		// Determine how many CSADDR_INFO structures could fit
		// into this buffer, then allocate a buffer to use for
		// the NBP lookup that can hold this many returned tuples
		//

		bufsize = sizeof(WSH_LOOKUP_NAME) +
			( (*lpdwBufferLength / (sizeof(CSADDR_INFO) + (2*sizeof(SOCKADDR_AT)))) *
				sizeof(WSH_NBP_TUPLE) );

        if ((buf = LocalAlloc(LMEM_ZEROINIT, bufsize)) == NULL)
		{
			err = GetLastError();
			break;
		}

		// copy the NBP name to look for into the buffer
		pWshLookupName = (PWSH_LOOKUP_NAME)buf;
		pWshLookupName->LookupTuple.NbpName = *pNbpLookupName;

		//
		// Send the Nbp lookup request
		//
		if (getsockopt( socketNbp,
			 		    SOL_APPLETALK,
						SO_LOOKUP_NAME,
						buf,
						&bufsize) != NO_ERROR)
		{
			err = WSAGetLastError();
			if (err == WSAENOBUFS)
			{
	            // this assumes that getsockopt will	NOT
				// put the required number of bytes into the
				// bufsize parameter on error
				*lpdwBufferLength = 2 * *lpdwBufferLength;
			}
			break;
		}

		if (pWshLookupName->NoTuples == 0)
		{
			// didn't find anything matching this NBP entity name
			*lpdwBufferLength = 0;
			break;
		}

		// point to the returned tuples
		pWshATAddr = (PWSH_ATALK_ADDRESS)(pWshLookupName + 1);
		for ( i = 0; i < (INT)pWshLookupName->NoTuples; i++ )
		{
			DWORD cAddr, bytesWritten;

			socketAddr.sat_net    = pWshATAddr->Network;
			socketAddr.sat_node   = pWshATAddr->Node;
			socketAddr.sat_socket = pWshATAddr->Socket;
			err = FillBufferWithCsAddr( &socketAddr,
										nProt,
										// USE LOCALS TO KEEP TRACK OF BUF POSITION AND COUNT LEFT
										pTmp,
										&templen,
										&cAddr);
	
			if (err != NO_ERROR)
			{
				// Fill in how many bytes the buffer should have been to
				// hold all the returned addresses
				*lpdwBufferLength = templen * pWshLookupName->NoTuples;
				break; // from for and then from while
			}
			else
			{
				pTmp += sizeof(CSADDR_INFO) * cAddr;
				templen -= (sizeof(CSADDR_INFO) + (2 * sizeof(SOCKADDR_AT))) * cAddr;
				*lpcAddress += cAddr;	// running count of CSADDR_INFOs in buffer
				(PWSH_NBP_TUPLE)pWshATAddr ++; // get next NBP tuple
			}
		}
	} while (FALSE);

    //
    // Clean up the socket interface
    //

	if (buf != NULL)
	{
		LocalFree(buf);
	}
    closesocket( socketNbp );
    (VOID) WSACleanup();

    return err;
}


DWORD
FillBufferWithCsAddr(
    IN PSOCKADDR_AT pAddress,  		// if NULL, then return generic appletalk socket address for RemoteAddr
    IN DWORD        nProt,
    IN OUT LPVOID   lpCsAddrBuffer,
    IN OUT LPDWORD  lpdwBufferLength,
    OUT LPDWORD     pcAddress		
)
{
    DWORD nAddrCount = 0;
    CSADDR_INFO  *pCsAddr;
    SOCKADDR_AT *pAddrLocal, *pAddrRemote;
    DWORD i;
    LPBYTE pBuffer;

    if ( nProt & ADSP_BIT )
        nAddrCount ++;

    if ( nProt & PAP_BIT )
        nAddrCount++;


    if ( *lpdwBufferLength <
         nAddrCount * ( sizeof( CSADDR_INFO) + 2*sizeof( SOCKADDR_AT)))
    {
        *lpdwBufferLength = nAddrCount *
                            ( sizeof( CSADDR_INFO) + 2*sizeof( SOCKADDR_AT));
        return ERROR_INSUFFICIENT_BUFFER;
    }


    pBuffer = ((LPBYTE) lpCsAddrBuffer) + *lpdwBufferLength -
			(2*sizeof( SOCKADDR_AT) * nAddrCount);

    for ( i = 0, pCsAddr = (CSADDR_INFO *)lpCsAddrBuffer;
          (i < nAddrCount) && ( nProt != 0 );
          i++, pCsAddr++ )
    {
		if ( nProt & ADSP_BIT )
        {
			pCsAddr->iSocketType = SOCK_RDM;
            pCsAddr->iProtocol   = ATPROTO_ADSP;
            nProt &= ~ADSP_BIT;
        }
        else if ( nProt & PAP_BIT )
        {
            pCsAddr->iSocketType = SOCK_RDM;
            pCsAddr->iProtocol   = ATPROTO_PAP;
            nProt &= ~PAP_BIT;
        }
        else
        {
            break;
        }

        pCsAddr->LocalAddr.iSockaddrLength  = sizeof( SOCKADDR_AT );
        pCsAddr->RemoteAddr.iSockaddrLength = sizeof( SOCKADDR_AT );
        pCsAddr->LocalAddr.lpSockaddr = (LPSOCKADDR) pBuffer;
        pCsAddr->RemoteAddr.lpSockaddr =
            (LPSOCKADDR) ( pBuffer + sizeof(SOCKADDR_AT));
        pBuffer += 2 * sizeof( SOCKADDR_AT );

        pAddrLocal  = (SOCKADDR_AT *) pCsAddr->LocalAddr.lpSockaddr;
        pAddrRemote = (SOCKADDR_AT *) pCsAddr->RemoteAddr.lpSockaddr;

        pAddrLocal->sat_family  = AF_APPLETALK;
        pAddrRemote->sat_family = AF_APPLETALK;

        //
        // The default local sockaddr for ADSP and PAP is
        // sa_family = AF_APPLETALK and all other bytes = 0.
        //

        pAddrLocal->sat_net    = 0;
		pAddrLocal->sat_node   = 0;
		pAddrLocal->sat_socket = 0;

        //
        // If pAddress is NULL, i.e. we are doing RES_SERVICE,
        // just make all bytes in remote address zero.
        //

        if ( pAddress == NULL )
        {
			pAddrRemote->sat_net    = 0;
			pAddrRemote->sat_node   = 0;
			pAddrRemote->sat_socket = 0;
		}
        else
        {
			pAddrRemote->sat_net    = pAddress->sat_net;
			pAddrRemote->sat_node   = pAddress->sat_node;
			pAddrRemote->sat_socket = pAddress->sat_socket;
        }
    }

    *pcAddress = nAddrCount;
    return NO_ERROR;
} // FillBufferWithCSAddr


NTSTATUS
NbpSetService (
    IN     DWORD           dwOperation,
    IN     DWORD           dwFlags,
    IN     BOOL            fUnicodeBlob,
    IN     LPSERVICE_INFO  lpServiceInfo
)
/*++

Routine Description:

    This routine registers or deregisters the given service type/name on NBP.

Arguments:

    dwOperation - Either SERVICE_REGISTER or SERVICE_DEREGISTER

    dwFlags - ignored

	fUnicodeBlob - ignored

    lpServiceInfo - Pointer to a SERVICE_INFO structure containing all info
                    about the service.

Return Value:

    Win32 error code.

--*/
{
    NTSTATUS		err = STATUS_SUCCESS;
	SOCKADDR_AT		sockAddr;
	WSH_NBP_NAME	nbpName;
    DWORD 			i;
    INT 			nNBP = -1;

    UNREFERENCED_PARAMETER( dwFlags );
    UNREFERENCED_PARAMETER( fUnicodeBlob );

	DBGPRINT(("NbpSetService entered...\n"));

	//
    // Check for invalid parameters
    //
    if (  ( lpServiceInfo == NULL )
       || ( lpServiceInfo->lpServiceType == NULL )
       || ( lpServiceInfo->lpServiceName == NULL )  )
    {
        return ERROR_INVALID_PARAMETER;
    }

	if ( lpServiceInfo->lpServiceAddress == NULL )
        return ERROR_INCORRECT_ADDRESS;

	switch (dwOperation)
    {
		case SERVICE_REGISTER:
		case SERVICE_DEREGISTER:
		{
			//
			// Check to see if the service address array contains NBP address,
			// we will only use the first NBP address contained in the array.
			//
		
			for ( i = 0; i < lpServiceInfo->lpServiceAddress->dwAddressCount; i++)
			{
				if ( lpServiceInfo->lpServiceAddress->Addresses[i].dwAddressType == AF_APPLETALK )
				{
					sockAddr = *(PSOCKADDR_AT)(lpServiceInfo->lpServiceAddress->Addresses[i].lpAddress);
					nNBP = (INT) i;
					break;
				}
			}
		
			//
			// If we cannot find a atalk address in the user's array, return error
			//
			if ( nNBP == -1 )
			{
				DBGPRINT(("NbpSetService: no Appletalk addresses in lpServiceInfo!\n"));
				return ERROR_INCORRECT_ADDRESS;
			}

			//
			// Convert the service type and name into NBP form
			//
			err = GetNameInNbpFormat(lpServiceInfo->lpServiceType,
									 lpServiceInfo->lpServiceName,
									 &nbpName);
			if (err != NO_ERROR)
			{
				break;
			}

			err = NbpRegDeregService(dwOperation, &nbpName, &sockAddr);
			break;
		}
        case SERVICE_FLUSH:
        case SERVICE_ADD_TYPE:
        case SERVICE_DELETE_TYPE:
            //
            // This is a no-op in our provider, so just return success
            //
            return NO_ERROR;

        default:
            //
            // We can probably say all other operations which we have no
            // knowledge of are ignored by us. So, just return success.
            //
            return NO_ERROR;
    }

	return err;
}


DWORD
NbpRegDeregService(
	IN DWORD			dwOperation,
	IN PWSH_NBP_NAME	pNbpName,
	IN PSOCKADDR_AT		pSockAddr
)
/*++

Routine Description:

    This routine registers or deregisters the given service on NBP.

Arguments:

	dwOperation - either SERVICE_REGISTER or SERVICE_DEREGISTER

	pNbpName - points to NBP name to register (zone should be "*")

	pSockAddr - socket address on which to register name


Return Value:

    Win32 error.

--*/
{
	int							status;
	BYTE						EaBuffer[sizeof(FILE_FULL_EA_INFORMATION) +
										TDI_TRANSPORT_ADDRESS_LENGTH + 1 +
										sizeof(TA_APPLETALK_ADDRESS)];
	PFILE_FULL_EA_INFORMATION	pEaBuf = (PFILE_FULL_EA_INFORMATION)EaBuffer;
	TA_APPLETALK_ADDRESS		Ta;
	OBJECT_ATTRIBUTES			ObjAttr;
	UNICODE_STRING				DeviceName;
	IO_STATUS_BLOCK				IoStsBlk;

	NBP_TUPLE					nbpTuple;
	SOCKET						bogusSocket = 0;
	HANDLE						AtalkAddressHandle = NULL, eventHandle = NULL;
	PTDI_ACTION_HEADER			tdiAction;
	ULONG						tdiActionLength;
	BOOLEAN						freeTdiAction = FALSE, closeEventHandle = FALSE;
	PNBP_REGDEREG_ACTION		nbpAction;
	PVOID 						completionApc = NULL;
	PVOID 						apcContext = NULL;

	DBGPRINT(("NbpRegDeregService entered...\n"));
DebugBreak();	

	// Dosn't matter what protocol or socket we open, we just want a
	// device handle into the stack.
	RtlInitUnicodeString(&DeviceName, WSH_ATALK_ADSPRDM);

	InitializeObjectAttributes(&ObjAttr, &DeviceName, 0, NULL, NULL);

	// Initialize the EA Buffer
	pEaBuf->NextEntryOffset = 0;
	pEaBuf->Flags = 0;
	pEaBuf->EaValueLength = sizeof(TA_APPLETALK_ADDRESS);
	pEaBuf->EaNameLength = TDI_TRANSPORT_ADDRESS_LENGTH;
	RtlCopyMemory(pEaBuf->EaName,TdiTransportAddress,
											TDI_TRANSPORT_ADDRESS_LENGTH + 1);
	Ta.TAAddressCount = 1;
	Ta.Address[0].AddressType = TDI_ADDRESS_TYPE_APPLETALK;
	Ta.Address[0].AddressLength = sizeof(TDI_ADDRESS_APPLETALK);

	// Open dynamic socket - note we will be using up one extra socket for the
	// duration we have the device handle open in this routine.
	Ta.Address[0].Address[0].Socket = 0;
	Ta.Address[0].Address[0].Network = 0;
	Ta.Address[0].Address[0].Node = 0;

	RtlCopyMemory(&pEaBuf->EaName[TDI_TRANSPORT_ADDRESS_LENGTH + 1], &Ta, sizeof(Ta));

	// Open a handle to appletalk stack DDP device
	status = NtCreateFile(
					&AtalkAddressHandle,
					GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE,
					&ObjAttr,
					&IoStsBlk,
					NULL,								// Don't Care
					0,									// Don't Care
					FILE_SHARE_READ | FILE_SHARE_WRITE,
					FILE_CREATE,
					0,
					&EaBuffer,
					sizeof(EaBuffer));

	if (!NT_SUCCESS(status))
	{
		DBGPRINT(("NbpRegDeregService: NtCreateFile failed (0x%x)\n", status));
		return WSHNtStatusToWinsockErr(status);
	}

	do
	{
		status = NtCreateEvent(
					 &eventHandle,
					 EVENT_ALL_ACCESS,
					 NULL,
					 SynchronizationEvent,
					 FALSE
					 );
	
		if ( !NT_SUCCESS(status) )
		{
			DBGPRINT(("NbpRegDeregService: Create event failed (%d)\n", status));
			break;
		}
		else
			closeEventHandle = TRUE;

		tdiActionLength = sizeof(NBP_REGDEREG_ACTION);
		tdiAction = RtlAllocateHeap( RtlProcessHeap( ), 0, tdiActionLength );
		if ( tdiAction == NULL )
		{
			status = STATUS_NO_MEMORY;
			DBGPRINT(("NbpRegDeregService: Could not allocate tdiAction\n"));
			break;
		}
		else
			freeTdiAction = TRUE;

		tdiAction->TransportId = MATK;

		tdiAction->ActionCode = (dwOperation == SERVICE_REGISTER) ?
									COMMON_ACTION_NBPREGISTER_BY_ADDR :
									COMMON_ACTION_NBPREMOVE_BY_ADDR;

		nbpAction = (PNBP_REGDEREG_ACTION)tdiAction;

		//
		// Copy the nbp tuple info to the proper place
		//

		nbpAction->Params.RegisterTuple.Address.Network = pSockAddr->sat_net;
		nbpAction->Params.RegisterTuple.Address.Node    = pSockAddr->sat_node;
		nbpAction->Params.RegisterTuple.Address.Socket  = pSockAddr->sat_socket;
		nbpAction->Params.RegisterTuple.Enumerator = 0; 	
		nbpAction->Params.RegisterTuple.NbpName = *((PNBP_NAME)pNbpName);

		//
		// Convert the tuple to MAC code page
		//

		if (!WshNbpNameToMacCodePage(
				(PWSH_NBP_NAME)&nbpAction->Params.RegisterTuple.NbpName))
		{
			status = STATUS_INVALID_PARAMETER;
			break;
		}

		status = NtDeviceIoControlFile(
					 AtalkAddressHandle,
					 eventHandle,
					 completionApc,
					 apcContext,
					 &IoStsBlk,
					 IOCTL_TDI_ACTION,
					 NULL,				 // Input buffer
					 0,					 // Length of input buffer
					 tdiAction,
					 tdiActionLength
					 );
	
		if ( status == STATUS_PENDING )
		{
			status = NtWaitForSingleObject( eventHandle, FALSE, NULL );
			ASSERT( NT_SUCCESS(status) );
			status = IoStsBlk.Status;
		}
	
        if (status != NO_ERROR)
		{
			DBGPRINT(("NbpRegDeregService: DevIoctl SO_(DE)REGISTER_NAME failed (0x%x)\n", status));
		}


	} while (0);

	if (closeEventHandle)
		NtClose(eventHandle);

	if (freeTdiAction)
		RtlFreeHeap( RtlProcessHeap( ), 0, tdiAction );

	NtClose(AtalkAddressHandle);

	return WSHNtStatusToWinsockErr(status);
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\atalk\sys\zip.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

	zip.c

Abstract:

	This module contains

Author:

	Jameel Hyder (jameelh@microsoft.com)
	Nikhil Kamkolkar (nikhilk@microsoft.com)

Revision History:
	19 Jun 1992		Initial Version

Notes:	Tab stop: 4
--*/

#include <atalk.h>
#pragma hdrstop
#define	FILENUM	ZIP

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, AtalkZipInit)
#pragma alloc_text(PAGEINIT, AtalkInitZipStartProcessingOnPort)
#pragma alloc_text(PAGEINIT, atalkZipGetZoneListForPort)
#pragma alloc_text(PAGE_RTR, AtalkZipPacketInRouter)
#pragma alloc_text(PAGE_RTR, atalkZipHandleNetInfo)
#pragma alloc_text(PAGE_RTR, atalkZipHandleReply)
#pragma alloc_text(PAGE_RTR, atalkZipHandleQuery)
#pragma alloc_text(PAGE_RTR, atalkZipHandleAtpRequest)
#pragma alloc_text(PAGE_RTR, atalkZipQueryTimer)
#pragma alloc_text(PAGE_NZ, AtalkZipGetMyZone)
#pragma alloc_text(PAGE_NZ, atalkZipGetMyZoneReply)
#pragma alloc_text(PAGE_NZ, AtalkZipGetZoneList)
#pragma alloc_text(PAGE_NZ, atalkZipGetZoneListReply)
#pragma alloc_text(PAGE_NZ, atalkZipZoneInfoTimer)
#pragma alloc_text(PAGE_NZ, atalkZipSendPacket)
#endif


/***	AtalkZipInit
 *
 */
ATALK_ERROR
AtalkZipInit(
	IN	BOOLEAN	Init
)
{
	if (Init)
	{
		// Allocate space for zones
		AtalkZonesTable = (PZONE *)AtalkAllocZeroedMemory(sizeof(PZONE) * NUM_ZONES_HASH_BUCKETS);
		if (AtalkZonesTable == NULL)
		{
			return ATALK_RESR_MEM;
		}

		INITIALIZE_SPIN_LOCK(&AtalkZoneLock);
	}
	else
	{
		// At this point, we are unloading and there are no race conditions
		// or lock contentions. Do not bother locking down the zones table
		if (AtalkDesiredZone != NULL)
			AtalkZoneDereference(AtalkDesiredZone);
		if (AtalkZonesTable != NULL)
		{
			AtalkFreeMemory(AtalkZonesTable);
			AtalkZonesTable = NULL;
		}
	}
	return ATALK_NO_ERROR;
}


/***	AtalkZipStartProcessingOnPort
 *
 */
BOOLEAN
AtalkInitZipStartProcessingOnPort(
	IN	PPORT_DESCRIPTOR 	pPortDesc,
	IN	PATALK_NODEADDR		pRouterNode
)
{
	ATALK_ADDR		closeAddr;
	ATALK_ERROR		Status;
	KIRQL			OldIrql;
	BOOLEAN			RetCode = FALSE;
    PDDP_ADDROBJ    pZpDdpAddr=NULL;

	// Switch the incoming zip handler to the router version
	closeAddr.ata_Network = pRouterNode->atn_Network;
	closeAddr.ata_Node = pRouterNode->atn_Node;
	closeAddr.ata_Socket  = ZONESINFORMATION_SOCKET;

	do
	{
		ACQUIRE_SPIN_LOCK(&pPortDesc->pd_Lock, &OldIrql);
		pPortDesc->pd_Flags |= PD_ROUTER_STARTING;
		RELEASE_SPIN_LOCK(&pPortDesc->pd_Lock, OldIrql);
	
		// Close the non-router version of the handler and start the router version
		AtalkDdpInitCloseAddress(pPortDesc, &closeAddr);
		if (!ATALK_SUCCESS(Status = AtalkDdpOpenAddress(pPortDesc,
														ZONESINFORMATION_SOCKET,
														pRouterNode,
														AtalkZipPacketInRouter,
														NULL,
														DDPPROTO_ANY,
														NULL,
														&pZpDdpAddr)))
		{
			DBGPRINT(DBG_COMP_RTMP, DBG_LEVEL_ERR,
					("AtalkZipStartProcessingOnPort: AtalkDdpOpenAddress failed %ld\n",
					Status));
			break;
		}

        // mark the fact that this is an "internal" socket
        pZpDdpAddr->ddpao_Flags |= DDPAO_SOCK_INTERNAL;
	
		// Try to get or set the zone information
		if (!atalkZipGetZoneListForPort(pPortDesc))
		{
			DBGPRINT(DBG_COMP_ZIP, DBG_LEVEL_ERR,
					("AtalkZipStartProcessingOnPort: Failed to get zone list for port\n"));
			break;
		}

		if (!atalkZipQryTmrRunning)
		{
			AtalkTimerInitialize(&atalkZipQTimer,
								 atalkZipQueryTimer,
								 ZIP_QUERY_TIMER);
			AtalkTimerScheduleEvent(&atalkZipQTimer);

            atalkZipQryTmrRunning = TRUE;
		}
	
		ACQUIRE_SPIN_LOCK(&pPortDesc->pd_Lock, &OldIrql);
		pPortDesc->pd_Flags &= ~PD_ROUTER_STARTING;
		RELEASE_SPIN_LOCK(&pPortDesc->pd_Lock, OldIrql);

		RetCode = TRUE;
	} while (FALSE);

	return RetCode;
}


/***	AtalkZipPacketIn
 *
 */
VOID
AtalkZipPacketIn(
	IN	PPORT_DESCRIPTOR	pPortDesc,
	IN	PDDP_ADDROBJ		pDdpAddr,
	IN	PBYTE				pPkt,
	IN	USHORT				PktLen,
	IN	PATALK_ADDR			pSrcAddr,
	IN	PATALK_ADDR			pDstAddr,
	IN	ATALK_ERROR			Status,
	IN	BYTE				DdpType,
	IN	PVOID				pHandlerCtx,
	IN	BOOLEAN				OptimizedPath,
	IN	PVOID				OptimizeCtx
)
{
	BYTE			CmdType, Flags;
	BYTE			ZoneLen, DefZoneLen, MulticastAddrLen;
	PBYTE			pZone, pDefZone, pMulticastAddr;
	TIME			TimeS, TimeE, TimeD;
	ULONG			Index;

	ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

	TimeS = KeQueryPerformanceCounter(NULL);
	do
	{
		if ((Status == ATALK_SOCKET_CLOSED) ||
			(DdpType != DDPPROTO_ZIP))
			break;

		else if (Status != ATALK_NO_ERROR)
		{
			break;
		}
	
		if (!EXT_NET(pPortDesc))
		{
			AtalkLogBadPacket(pPortDesc,
							  pSrcAddr,
							  pDstAddr,
							  pPkt,
							  PktLen);
			break;
		}

        if (PktLen < ZIP_CMD_OFF+1)
        {
            break;
        }

		CmdType = pPkt[ZIP_CMD_OFF];

		// We only care about Zip Notifies and NetInfo replies
		if (((CmdType != ZIP_NOTIFY) && (CmdType != ZIP_NETINFO_REPLY)) ||
			(PktLen < (ZIP_ZONELEN_OFF + 1)))
		{
			break;
		}

		// If it is a NetInfoReply, then we should be looking for either the
		// default or the desired zone
		if ((CmdType != ZIP_NETINFO_REPLY) &&
			(pPortDesc->pd_Flags & (PD_FINDING_DEFAULT_ZONE | PD_FINDING_DESIRED_ZONE)))
			break;

		if ((CmdType == ZIP_NETINFO_REPLY) &&
			!(pPortDesc->pd_Flags & (PD_FINDING_DEFAULT_ZONE | PD_FINDING_DESIRED_ZONE)))
			break;

		// If it is a Notify then the desired zone must be valid
		if ((CmdType == ZIP_NOTIFY) &&
			!(pPortDesc->pd_Flags & PD_VALID_DESIRED_ZONE))
			break;

		// We have a NetInfoReply or a Notify. Handle it
		Flags = pPkt[ZIP_FLAGS_OFF];
		Index = ZIP_ZONELEN_OFF;

		ZoneLen = pPkt[ZIP_ZONELEN_OFF];
		Index ++;

		if ((ZoneLen > MAX_ZONE_LENGTH) || (PktLen < (Index + ZoneLen)))
		{
			AtalkLogBadPacket(pPortDesc,
							  pSrcAddr,
							  pDstAddr,
							  pPkt,
							  PktLen);
			break;
		}

		pZone = pPkt+Index;
		Index += ZoneLen;

        // If we are looking for a desired zone and we get a late default zone
        // response then toss this packet
        if ((CmdType == ZIP_NETINFO_REPLY) && (ZoneLen == 0) &&
			(pPortDesc->pd_Flags & (PD_FINDING_DESIRED_ZONE)) &&
            (pPortDesc->pd_InitialDesiredZone != NULL))
        {
            DBGPRINT(DBG_COMP_RTMP, DBG_LEVEL_ERR,
                ("AtalkZipPacketIn: dropping a NetInfoReply packet\n"));
			break;
        }


		// If we're requesting the zone name, make sure the response matches
		// our request. ZoneLen will be zero when we're looking for the def
		// zone, so we won't do this test
		if ((CmdType == ZIP_NETINFO_REPLY) &&
			(ZoneLen != 0) &&
			(pPortDesc->pd_InitialDesiredZone != NULL))
		{
			BOOLEAN NoMatch = FALSE;

			ACQUIRE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);
			ASSERT(!(pPortDesc->pd_Flags & PD_ROUTER_RUNNING) ||
					(pPortDesc->pd_Flags & PD_FINDING_DESIRED_ZONE));
			if (!AtalkFixedCompareCaseInsensitive(pZone,
												  ZoneLen,
												  pPortDesc->pd_InitialDesiredZone->zn_Zone,
												  pPortDesc->pd_InitialDesiredZone->zn_ZoneLen))
			{
				NoMatch = TRUE;
			}
			RELEASE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);
			if (NoMatch)
				break;
		}
		
		// If its a Notify, make sure we're in the zone that is being changed
		if (CmdType == ZIP_NOTIFY)
		{
			BOOLEAN NoMatch = FALSE;

			ACQUIRE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);
			if (!AtalkFixedCompareCaseInsensitive(pZone, ZoneLen,
								pPortDesc->pd_DesiredZone->zn_Zone,
								pPortDesc->pd_DesiredZone->zn_ZoneLen))
			{
				NoMatch = TRUE;
			}
			RELEASE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);
			if (NoMatch)
				break;
		}

		if (PktLen < (Index + 1))
		{
			AtalkLogBadPacket(pPortDesc,
							  pSrcAddr,
							  pDstAddr,
							  pPkt,
							  PktLen);
			break;
		}

		MulticastAddrLen = pPkt[Index++];
		if (MulticastAddrLen != pPortDesc->pd_BroadcastAddrLen)
		{
			AtalkLogBadPacket(pPortDesc,
							  pSrcAddr,
							  pDstAddr,
							  pPkt,
							  PktLen);
			break;
		}

		if (PktLen < (Index + MulticastAddrLen))
		{
			AtalkLogBadPacket(pPortDesc,
							  pSrcAddr,
							  pDstAddr,
							  pPkt,
							  PktLen);
			break;
		}
		pMulticastAddr = pPkt + Index;
		Index += MulticastAddrLen;
#if 0
		if (Flags & ZIP_USE_BROADCAST_FLAG)
			pMulticastAddr = pPortDesc->pd_BroadcastAddr;
#endif
		// Grab second name, if needed or present
		DefZoneLen = 0;
		if ((CmdType == ZIP_NOTIFY) || (PktLen  > Index))
		{
			if (PktLen < (Index+1))
			{
				AtalkLogBadPacket(pPortDesc,
								  pSrcAddr,
								  pDstAddr,
								  pPkt,
								  PktLen);
				break;
			}
			DefZoneLen = pPkt[Index++];
			if ((DefZoneLen == 0) ||
				(DefZoneLen > MAX_ZONE_LENGTH) ||
				(PktLen < (Index+DefZoneLen)))
			{
				AtalkLogBadPacket(pPortDesc,
								  pSrcAddr,
								  pDstAddr,
								  pPkt,
								  PktLen);
				break;
			}
			pDefZone = pPkt+Index;
			Index += DefZoneLen;
		}

		// Make default zone be the new one. We may not have a default/new
		// zone in netinfo reply case and we requested for the correct zone
		if (DefZoneLen == 0)
		{
			pDefZone = pZone;
			DefZoneLen = ZoneLen;
		}

		//	Make sure the port lock is released before calling any depend/ddp
		//	etc. routines.
		ACQUIRE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);

		// If we're just looking for the default zone, set here and note
		// our mission completed
		if ((pPortDesc->pd_Flags & PD_FINDING_DEFAULT_ZONE) &&
			(ZoneLen == 0))
		{
            if (pPortDesc->pd_DefaultZone != NULL)
				AtalkZoneDereference(pPortDesc->pd_DefaultZone);
			pPortDesc->pd_DefaultZone = AtalkZoneReferenceByName(pDefZone, DefZoneLen);
			if (pPortDesc->pd_DefaultZone == NULL)
			{
				RELEASE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);
				RES_LOG_ERROR();
				break;
			}
			pPortDesc->pd_Flags |= PD_VALID_DEFAULT_ZONE;
			pPortDesc->pd_Flags &= ~PD_FINDING_DEFAULT_ZONE;
		}

		// Now we want to accept all of the information about 'thiszone'
		// for the nodes on the current port
		// If the new multicast address is different, remove the old and
		// set the new. Don't allow changes to the 'broadcast' multicast
		// address.
		if (pPortDesc->pd_Flags & PD_FINDING_DESIRED_ZONE)
		{
			if(pPortDesc->pd_PortType == ELAP_PORT || pPortDesc->pd_PortType == FDDI_PORT)
			{
				int IsOldAddress, IsBroadcastAddress;
				IsOldAddress = AtalkFixedCompareCaseSensitive(pMulticastAddr,
															MulticastAddrLen,
															pPortDesc->pd_ZoneMulticastAddr,
															MulticastAddrLen);
				IsBroadcastAddress = AtalkFixedCompareCaseSensitive(pMulticastAddr,
																MulticastAddrLen,
																pPortDesc->pd_BroadcastAddr,
																MulticastAddrLen);
				if(!IsOldAddress && !IsBroadcastAddress)
				{
					RELEASE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);
					AtalkNdisReplaceMulticast(pPortDesc,
											pPortDesc->pd_ZoneMulticastAddr,
											pMulticastAddr);
					ACQUIRE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);
				}
				else
				{
					if (!IsOldAddress)
					{
						RELEASE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);
						(*pPortDesc->pd_RemoveMulticastAddr)(pPortDesc,
															 pPortDesc->pd_ZoneMulticastAddr,
															 FALSE,
															 NULL,
															 NULL);
						ACQUIRE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);
					}
			
					if (!IsBroadcastAddress)
					{
						RELEASE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);
						(*pPortDesc->pd_AddMulticastAddr)(pPortDesc,
														  pMulticastAddr,
														  FALSE,
														  NULL,
														  NULL);
						ACQUIRE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);
					}
				}
			}
			else
			{
				if (!AtalkFixedCompareCaseSensitive(pMulticastAddr,
													MulticastAddrLen,
													pPortDesc->pd_ZoneMulticastAddr,
													MulticastAddrLen))
				{
					RELEASE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);
					(*pPortDesc->pd_RemoveMulticastAddr)(pPortDesc,
														 pPortDesc->pd_ZoneMulticastAddr,
														 FALSE,
														 NULL,
														 NULL);
					ACQUIRE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);
				}
		
				if (!AtalkFixedCompareCaseSensitive(pMulticastAddr,
													MulticastAddrLen,
													pPortDesc->pd_BroadcastAddr,
													MulticastAddrLen))
				{
					RELEASE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);
					(*pPortDesc->pd_AddMulticastAddr)(pPortDesc,
													  pMulticastAddr,
													  FALSE,
													  NULL,
													  NULL);
					ACQUIRE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);
				}
			}
	
			RtlCopyMemory(pPortDesc->pd_ZoneMulticastAddr,
						  pMulticastAddr,
						  MulticastAddrLen);
		}

		// Finally set this cable range if this is a net info reply
		if (CmdType == ZIP_NETINFO_REPLY)
		{
			GETSHORT2SHORT(&pPortDesc->pd_NetworkRange.anr_FirstNetwork,
						   pPkt+ZIP_CABLE_RANGE_START_OFF);
			GETSHORT2SHORT(&pPortDesc->pd_NetworkRange.anr_LastNetwork,
						   pPkt+ZIP_CABLE_RANGE_END_OFF);
			if (!(pPortDesc->pd_Flags & PD_ROUTER_STARTING))
			{
				pPortDesc->pd_ARouter.atn_Network = pSrcAddr->ata_Network;
				pPortDesc->pd_ARouter.atn_Node = pSrcAddr->ata_Node;
			}
			pPortDesc->pd_Flags |= PD_SEEN_ROUTER_RECENTLY;
			KeSetEvent(&pPortDesc->pd_SeenRouterEvent, IO_NETWORK_INCREMENT, FALSE);
		}
		
		// Now that we know the zone
		if (pPortDesc->pd_Flags & PD_FINDING_DESIRED_ZONE)
		{
			pPortDesc->pd_Flags &= ~PD_FINDING_DESIRED_ZONE;
			pPortDesc->pd_Flags |= PD_VALID_DESIRED_ZONE;
			if (pPortDesc->pd_DesiredZone != NULL)
				AtalkZoneDereference(pPortDesc->pd_DesiredZone);
			pPortDesc->pd_DesiredZone = AtalkZoneReferenceByName(pDefZone, DefZoneLen);
			if (pPortDesc->pd_DesiredZone == NULL)
			{
				pPortDesc->pd_Flags &= ~PD_VALID_DESIRED_ZONE;
				RES_LOG_ERROR();
			}
		}

		RELEASE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);

		TimeE = KeQueryPerformanceCounter(NULL);
		TimeD.QuadPart = TimeE.QuadPart - TimeS.QuadPart;
	
		INTERLOCKED_ADD_LARGE_INTGR_DPC(
			&pPortDesc->pd_PortStats.prtst_ZipPacketInProcessTime,
			TimeD,
			&AtalkStatsLock.SpinLock);
	
		INTERLOCKED_INCREMENT_LONG_DPC(
			&pPortDesc->pd_PortStats.prtst_NumZipPacketsIn,
			&AtalkStatsLock.SpinLock);
	} while (FALSE);
}


/***	AtalkZipPacketInRouter
 *
 */
VOID
AtalkZipPacketInRouter(
	IN	PPORT_DESCRIPTOR	pPortDesc,
	IN	PDDP_ADDROBJ		pDdpAddr,
	IN	PBYTE				pPkt,
	IN	USHORT				PktLen,
	IN	PATALK_ADDR			pSrcAddr,
	IN	PATALK_ADDR			pDstAddr,
	IN	ATALK_ERROR			Status,
	IN	BYTE				DdpType,
	IN	PVOID				pHandlerCtx,
	IN	BOOLEAN				OptimizedPath,
	IN	PVOID				OptimizeCtx
)
{
	BYTE			CmdType;
	TIME			TimeS, TimeE, TimeD;

	ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

	TimeS = KeQueryPerformanceCounter(NULL);
	do
	{
		if (Status == ATALK_SOCKET_CLOSED)
			break;

		else if (Status != ATALK_NO_ERROR)
		{
			break;
		}
	
		if (DdpType == DDPPROTO_ZIP)
		{
			if (PktLen < ZIP_FIRST_NET_OFF)
			{
				break;
			}
			CmdType = pPkt[ZIP_CMD_OFF];

			switch (CmdType)
			{
			  case ZIP_NETINFO_REPLY:
			  case ZIP_NOTIFY:
				DBGPRINT(DBG_COMP_ZIP, DBG_LEVEL_INFO,
						("AtalkZipPacketInRouter: Ignoring %s\n",
						(CmdType == ZIP_NOTIFY) ? "Notify" : "NetInfoReply"));
				break;

			  case ZIP_GET_NETINFO:
  				// We do not want to do a thing if we're starting up
				if (pPortDesc->pd_Flags & PD_ROUTER_STARTING)
					break;

				if (!EXT_NET(pPortDesc))
				{
					AtalkLogBadPacket(pPortDesc,
									  pSrcAddr,
									  pDstAddr,
									  pPkt,
									  PktLen);
					break;
				}
				if (pPortDesc->pd_ZoneList == NULL)
					break;			// Not fully up yet !

				if (PktLen < ZIP_REQ_ZONENAME_OFF)
				{
					AtalkLogBadPacket(pPortDesc,
									  pSrcAddr,
									  pDstAddr,
									  pPkt,
									  PktLen);
					break;
				}
				DBGPRINT(DBG_COMP_ZIP, DBG_LEVEL_INFO,
						("AtalkZipPacketInRouter: GetNetInfo Port %Z\n",
						&pPortDesc->pd_AdapterKey));
				atalkZipHandleNetInfo(pPortDesc,
									  pDdpAddr,
									  pSrcAddr,
									  pDstAddr,
									  pPkt,
									  PktLen);
				break;

			  case ZIP_EXT_REPLY:
			  case ZIP_REPLY:
				DBGPRINT(DBG_COMP_ZIP, DBG_LEVEL_INFO,
						("AtalkZipPacketInRouter: %sReply Port %Z\n",
						(CmdType == ZIP_REPLY) ? "" : "Extended",
						&pPortDesc->pd_AdapterKey));
				atalkZipHandleReply(pDdpAddr, pSrcAddr, pPkt, PktLen);
				break;

			  case ZIP_QUERY:
				DBGPRINT(DBG_COMP_ZIP, DBG_LEVEL_INFO,
						("AtalkZipPacketInRouter: Query Port %Z\n",
						&pPortDesc->pd_AdapterKey));

  				// We do not want to do a thing if we're starting up
				if (pPortDesc->pd_Flags & PD_ROUTER_STARTING)
					break;

  				atalkZipHandleQuery(pPortDesc, pDdpAddr, pSrcAddr, pPkt, PktLen);
				break;

			  default:
				AtalkLogBadPacket(pPortDesc,
								  pSrcAddr,
								  pDstAddr,
								  pPkt,
								  PktLen);
				break;
			}
		}
		else if (DdpType == DDPPROTO_ATP)
		{
			USHORT	TrId, StartIndex;

			if (PktLen < ATP_ZIP_START_INDEX_OFF+1)
			{
                ASSERT(0);
				break;
			}

			// We do not want to do a thing if we're starting up
			if (pPortDesc->pd_Flags & PD_ROUTER_STARTING)
				break;

			// This had better be a GetZoneList, a GetMyZone ATP request
			if ((pPkt[ATP_CMD_CONTROL_OFF] & ATP_FUNC_MASK) != ATP_REQUEST)
				break;
		
			if (pPkt[ATP_BITMAP_OFF] != 1)
			{
				AtalkLogBadPacket(pPortDesc,
								  pSrcAddr,
								  pDstAddr,
								  pPkt,
								  PktLen);
				break;
			}
		
			GETSHORT2SHORT(&TrId, pPkt + ATP_TRANS_ID_OFF);
			CmdType = pPkt[ATP_ZIP_CMD_OFF];

			if ((CmdType != ZIP_GET_ZONE_LIST) &&
				(CmdType != ZIP_GET_MY_ZONE) &&
				(CmdType != ZIP_GET_LOCAL_ZONES))
			{
				AtalkLogBadPacket(pPortDesc,
								  pSrcAddr,
								  pDstAddr,
								  pPkt,
								  PktLen);
				break;
			}

			DBGPRINT(DBG_COMP_ZIP, DBG_LEVEL_INFO,
					("ZIP: Received atp type command %d\n", CmdType));

			// Get start index. Not meaningful for GetMyZone
			GETSHORT2SHORT(&StartIndex, pPkt+ATP_ZIP_START_INDEX_OFF);

			DBGPRINT(DBG_COMP_ZIP, DBG_LEVEL_INFO,
					("AtalkZipPacketInRouter: AtpRequest %d, Port %Z\n",
						CmdType, &pPortDesc->pd_AdapterKey));
			atalkZipHandleAtpRequest(pPortDesc, pDdpAddr, pSrcAddr,
									CmdType, TrId, StartIndex);
		}
	} while (FALSE);

	TimeE = KeQueryPerformanceCounter(NULL);
	TimeD.QuadPart = TimeE.QuadPart - TimeS.QuadPart;

	INTERLOCKED_ADD_LARGE_INTGR_DPC(
		&pPortDesc->pd_PortStats.prtst_ZipPacketInProcessTime,
		TimeD,
		&AtalkStatsLock.SpinLock);

	INTERLOCKED_INCREMENT_LONG_DPC(
		&pPortDesc->pd_PortStats.prtst_NumZipPacketsIn,
		&AtalkStatsLock.SpinLock);
}


/***	atalkZipHandleNetInfo
 *
 */
VOID
atalkZipHandleNetInfo(
	IN	PPORT_DESCRIPTOR	pPortDesc,
	IN	PDDP_ADDROBJ		pDdpAddr,
	IN	PATALK_ADDR			pSrcAddr,
	IN	PATALK_ADDR			pDstAddr,
	IN	PBYTE				pPkt,
	IN	USHORT				PktLen
)
{
	PBUFFER_DESC	pBuffDesc;
	BYTE			ZoneLen;
	PBYTE			Datagram, pZoneName;
	ATALK_ADDR		SrcAddr = *pSrcAddr;
	ATALK_ERROR		error;
	BOOLEAN			UseDefZone = FALSE;
	USHORT			index;
	SEND_COMPL_INFO	SendInfo;

	ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

	do
	{
		// Get the zone name out of the request
		ZoneLen = pPkt[ZIP_REQ_ZONELEN_OFF];
		if ((ZoneLen > MAX_ZONE_LENGTH) ||
			(PktLen < (USHORT)(ZoneLen + ZIP_REQ_ZONENAME_OFF)))
		{
			AtalkLogBadPacket(pPortDesc,
							  pSrcAddr,
							  pDstAddr,
							  pPkt,
							  PktLen);
			break;
		}

		pZoneName =  pPkt+ZIP_REQ_ZONENAME_OFF;
		
		if ((pBuffDesc = AtalkAllocBuffDesc(NULL,
								MAX_DGRAM_SIZE,
								BD_CHAR_BUFFER | BD_FREE_BUFFER)) == NULL)
		{
			break;
		}
		Datagram = pBuffDesc->bd_CharBuffer;
		
		// Format a GetNetInfo reply command
		Datagram[ZIP_CMD_OFF] = ZIP_NETINFO_REPLY;
		Datagram[ZIP_FLAGS_OFF] = 0;
		
		ACQUIRE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);
		if ((ZoneLen == 0) ||
			!AtalkZoneNameOnList(pZoneName, ZoneLen, pPortDesc->pd_ZoneList))
		{
			Datagram[ZIP_FLAGS_OFF] |= ZIP_ZONE_INVALID_FLAG;
			UseDefZone = TRUE;
		}
		
		if (AtalkZoneNumOnList(pPortDesc->pd_ZoneList) == 1)
			Datagram[ZIP_FLAGS_OFF] |= ZIP_ONLYONE_ZONE_FLAG;
		
		// Add our cable range
		PUTSHORT2SHORT(&Datagram[ZIP_FIRST_NET_OFF],
						pPortDesc->pd_NetworkRange.anr_FirstNetwork);
		PUTSHORT2SHORT(Datagram +ZIP_LAST_NET_OFF,
						pPortDesc->pd_NetworkRange.anr_LastNetwork);
		
		// Echo back the requested zone name
		Datagram[ZIP_REQ_ZONELEN_OFF] = ZoneLen;
		RtlCopyMemory(Datagram+ZIP_REQ_ZONENAME_OFF, pZoneName, ZoneLen);
		index = ZIP_REQ_ZONENAME_OFF + ZoneLen;
		
		// Place in the correct zone multicast address
		Datagram[index++] = (BYTE)(pPortDesc->pd_BroadcastAddrLen);
		if (UseDefZone)
		{
			pZoneName = pPortDesc->pd_DefaultZone->zn_Zone;
			ZoneLen = pPortDesc->pd_DefaultZone->zn_ZoneLen;
		}
		AtalkZipMulticastAddrForZone(pPortDesc, pZoneName, ZoneLen, Datagram + index);
		
		index += pPortDesc->pd_BroadcastAddrLen;
		
		// If we need it, add in the default zone
		if (UseDefZone)
		{
			Datagram[index++] = ZoneLen = pPortDesc->pd_DefaultZone->zn_ZoneLen;
			RtlCopyMemory(Datagram + index, pPortDesc->pd_DefaultZone->zn_Zone, ZoneLen);
			index += ZoneLen;
		}
		
		// If the request came as a cable-wide broadcast and its
		// source network is not valid for this port, then we want
		// to respond to cable-wide broadcast rather than the source
		if ((pDstAddr->ata_Network == CABLEWIDE_BROADCAST_NETWORK) &&
			(pDstAddr->ata_Node == ATALK_BROADCAST_NODE) &&
			!WITHIN_NETWORK_RANGE(pSrcAddr->ata_Network,
									&pPortDesc->pd_NetworkRange) &&
			!WITHIN_NETWORK_RANGE(pSrcAddr->ata_Network,
									&AtalkStartupNetworkRange))
		{
			SrcAddr.ata_Network = CABLEWIDE_BROADCAST_NETWORK;
			SrcAddr.ata_Node = ATALK_BROADCAST_NODE;
		}
		
		RELEASE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);
		
		//	Set the length in the buffer descriptor.
        AtalkSetSizeOfBuffDescData(pBuffDesc, index);

		// Finally, send this out
		DBGPRINT(DBG_COMP_ZIP, DBG_LEVEL_INFO,
				("atalkZipHandleNetInfo: Sending Reply to %d.%d.%d\n",
				SrcAddr.ata_Network, SrcAddr.ata_Node, SrcAddr.ata_Socket));
		SendInfo.sc_TransmitCompletion = atalkZipSendComplete;
		SendInfo.sc_Ctx1 = pBuffDesc;
		// SendInfo.sc_Ctx2 = NULL;
		// SendInfo.sc_Ctx3 = NULL;
		error = AtalkDdpSend(pDdpAddr,
							 &SrcAddr,
							 DDPPROTO_ZIP,
							 FALSE,
							 pBuffDesc,
							 NULL,
							 0,
							 NULL,
							 &SendInfo);
		if (!ATALK_SUCCESS(error))
		{
			AtalkFreeBuffDesc(pBuffDesc);
			DBGPRINT(DBG_COMP_ZIP, DBG_LEVEL_ERR,
					("atalkZipHandleNetInfo: AtalkDdpSend %ld\n", error));
		}
	} while (FALSE);
}


/***	atalkZipHandleReply
 *
 */
VOID
atalkZipHandleReply(
	IN	PDDP_ADDROBJ		pDdpAddr,
	IN	PATALK_ADDR			pSrcAddr,
	IN	PBYTE				pPkt,
	IN	USHORT				PktLen
)
{
	ULONG			index, TotalNetCnt;
	PRTE			pRte = NULL;
	PBYTE			ZoneName;
	USHORT			NetNum;
	BYTE			CmdType, NwCnt, NumZonesOnNet, ZoneLen;
	BOOLEAN			RteLocked = FALSE;
	BOOLEAN			ExtReply = FALSE;

	ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

	DBGPRINT(DBG_COMP_ZIP, DBG_LEVEL_INFO,
			("atalkZipHandleReply: Enetered\n"));

	// For a zip extended reply, the network count is really not
	// the # of networks contained in the packet. It is the total #
	// of zones on the single network that is described by the reply
	NwCnt = NumZonesOnNet = pPkt[ZIP_NW_CNT_OFF];
	CmdType = pPkt[ZIP_CMD_OFF];

	do
	{
		// Walk through the reply packet (assuming we asked for the
		// contained information). We're still using NwCnt when
		// processing an extended reply, but that's okay 'cause it
		// will certainly be at least the # of zones contained in
		// this packet. The '+3' guarantees that we really have
		// network # and node
		for (index = ZIP_FIRST_NET_OFF, TotalNetCnt = 0;
			 (TotalNetCnt < NwCnt) && ((index + 3 ) <= PktLen);
			 TotalNetCnt ++)
		{
			if (pRte != NULL)
			{
				if (RteLocked)
				{
					RELEASE_SPIN_LOCK_DPC(&pRte->rte_Lock);
					RteLocked = FALSE;
				}
				AtalkRtmpDereferenceRte(pRte, FALSE);
				pRte = NULL;
			}
	
			// Get the next netwotk #, if it's not in our routing
			// table (or not the start of a range), then we certainly
			// don't care about its zone name
			GETSHORT2SHORT(&NetNum, pPkt+index);
			index += sizeof(USHORT);
			ZoneLen = pPkt[index++];
			if (((pRte = AtalkRtmpReferenceRte(NetNum)) == NULL) ||
				(pRte->rte_NwRange.anr_FirstNetwork != NetNum))
			{
				DBGPRINT(DBG_COMP_ZIP, DBG_LEVEL_ERR,
						("atalkZipHandleReply: Don't know about this range %d\n",
						NetNum));
				index += ZoneLen;
				continue;
			}
	
			// Validate the zone name
			if ((ZoneLen == 0) || (ZoneLen > MAX_ZONE_LENGTH) ||
				((index + ZoneLen) > PktLen))
			{
				AtalkLogBadPacket(pDdpAddr->ddpao_Node->an_Port,
								  pSrcAddr,
								  NULL,
								  pPkt,
								  PktLen);
				break;
			}
	
			// Conditionally move the zone name into the routing table
			ZoneName = pPkt+index;
			index += ZoneLen;
			ACQUIRE_SPIN_LOCK_DPC(&pRte->rte_Lock);
			RteLocked = TRUE;
	
			if (AtalkZoneNameOnList(ZoneName, ZoneLen, pRte->rte_ZoneList))
			{
				DBGPRINT(DBG_COMP_ZIP, DBG_LEVEL_INFO,
						("atalkZipHandleReply: Already have this zone\n"));
				continue;
			}

			// Check for somebody out there trying to add another zone to
			// our directly connected non-extended network and we already
			// know its zone.
			if ((pRte->rte_NumHops == 0) &&
				!EXT_NET(pRte->rte_PortDesc) &&
				(AtalkZoneNumOnList(pRte->rte_ZoneList) == 1))
			{
				AtalkLogBadPacket(pDdpAddr->ddpao_Node->an_Port,
								  pSrcAddr,
								  NULL,
								  pPkt,
								  PktLen);
				continue;
			}
	
			// Add to the list now
			pRte->rte_ZoneList = AtalkZoneAddToList(pRte->rte_ZoneList,
													ZoneName,
													ZoneLen);
			if (pRte->rte_ZoneList == NULL)
			{
				DBGPRINT(DBG_COMP_ZIP, DBG_LEVEL_ERR,
						("atalkZipHandleReply: Failed to add zone to list\n"));
				pRte->rte_Flags &= ~RTE_ZONELIST_VALID;
				continue;
			}

			DBGPRINT(DBG_COMP_ZIP, DBG_LEVEL_INFO,
					("atalkZipHandleReply: # of zones known so far %d\n",
					AtalkZoneNumOnList(pRte->rte_ZoneList)));

			// If not an extended reply, we know that we have all
			// of the information about a given network contained
			// in this packet, so we can go ahead and mark the zone
			// list valid now
			if (!ExtReply)
				pRte->rte_Flags |= RTE_ZONELIST_VALID;
		}
	
		// If we just handled an extended reply, do we now know all
		// that we should know about the specified network ?
	
		if (pRte != NULL)
		{
			if (ExtReply)
			{
				if (!RteLocked)
				{
					ACQUIRE_SPIN_LOCK_DPC(&pRte->rte_Lock);
					RteLocked = TRUE;
				}
				if (AtalkZoneNumOnList(pRte->rte_ZoneList) >= NumZonesOnNet)
					pRte->rte_Flags |= RTE_ZONELIST_VALID;
			}
			if (RteLocked)
			{
				RELEASE_SPIN_LOCK_DPC(&pRte->rte_Lock);
				// RteLocked = FALSE;
			}
			AtalkRtmpDereferenceRte(pRte, FALSE);
			// pRte = NULL;
		}
	} while (FALSE);
}

/***	atalkZipHandleQuery
 *
 */
VOID
atalkZipHandleQuery(
	IN	PPORT_DESCRIPTOR	pPortDesc,
	IN	PDDP_ADDROBJ		pDdpAddr,
	IN	PATALK_ADDR			pSrcAddr,
	IN	PBYTE				pPkt,
	IN	USHORT				PktLen
)
{
	PRTE			pRte = NULL;
	PBUFFER_DESC	pBuffDesc,
					pBuffDescStart = NULL,
					*ppBuffDesc = &pBuffDescStart;
	PZONE_LIST		pZoneList;
	PBYTE			Datagram;
	ATALK_ERROR		error;
    ULONG           i, CurrNumZones, PrevNumZones, TotalNetCnt;
	ULONG			NwCnt, NetCntInPkt;
	USHORT			NetNum, Size;
    BOOLEAN			AllocNewBuffDesc = TRUE, NewPkt = TRUE;
	BOOLEAN			PortLocked = FALSE,  RteLocked = FALSE;
	BYTE			CurrReply, NextReply;
	SEND_COMPL_INFO	SendInfo;

	ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    CurrNumZones = 0;
	do
	{
		// Walk through the query packet building reply packets that
		// have as much information as we know.
		// When sending replies, we will always send a reply about a
		// network that has more than one zone as an extended reply.
		// As were walking the query list, and we encounter a couple of
		// networks that have only one zone, we'll pack as many of
		// these as we can into a non-extended reply
		NwCnt = pPkt[ZIP_NW_CNT_OFF];

		for (NetCntInPkt = 0, TotalNetCnt = 0, i = ZIP_FIRST_NET_OFF;
			 (TotalNetCnt < NwCnt) && ((i + sizeof(SHORT)) <= PktLen);
			 i += sizeof(USHORT), TotalNetCnt++)
		{
			// Dereference any previous Rtes
			if (pRte != NULL)
			{
				if (RteLocked)
				{
					RELEASE_SPIN_LOCK_DPC(&pRte->rte_Lock);
					RteLocked = FALSE;
				}
				AtalkRtmpDereferenceRte(pRte, FALSE);
				pRte = NULL;
			}
			if (PortLocked)
			{
				RELEASE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);
				PortLocked = FALSE;
			}

			// Grab the next network number from the query packet,
			// if we don't know about the network, or we don't know
			// the zone name, continue with the next network number
			GETSHORT2SHORT(&NetNum, pPkt+i);
	
			ACQUIRE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);

			if ((WITHIN_NETWORK_RANGE(NetNum,&pPortDesc->pd_NetworkRange)) &&
				(pPortDesc->pd_ZoneList != NULL))
			{
				pZoneList = pPortDesc->pd_ZoneList;
				PortLocked = TRUE;
			}
			else
			{
				RELEASE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);
				if (((pRte = AtalkRtmpReferenceRte(NetNum)) == NULL) ||
						 (!WITHIN_NETWORK_RANGE(NetNum, &pRte->rte_NwRange)) ||
						 !(pRte->rte_Flags & RTE_ZONELIST_VALID))
				{
					continue;
				}
				else
				{
					ACQUIRE_SPIN_LOCK_DPC(&pRte->rte_Lock);
					pZoneList = pRte->rte_ZoneList;
					RteLocked = TRUE;
				}
			}

		next_reply:

			if (AllocNewBuffDesc)
			{
				if ((pBuffDesc = AtalkAllocBuffDesc(NULL,
									MAX_DGRAM_SIZE,
									BD_CHAR_BUFFER | BD_FREE_BUFFER)) == NULL)
                {
                    DBGPRINT(DBG_COMP_RTMP, DBG_LEVEL_ERR,
	                    ("\natalkZipHandleQuery:  AtalkAllocBuffDesc @1 failed\n"));
					break;
                }

				Size = 0;
				Datagram = pBuffDesc->bd_CharBuffer;
				*ppBuffDesc = pBuffDesc;
                pBuffDesc->bd_Next = NULL;
				ppBuffDesc = &pBuffDesc->bd_Next;
				AllocNewBuffDesc = FALSE;
			}

			// What type of response does this network want ?
			// Copy the previous network's zone count. In case of the first
			// pass, make it same.
            PrevNumZones = CurrNumZones;
			CurrNumZones = AtalkZoneNumOnList(pZoneList);
			if (i == ZIP_FIRST_NET_OFF)
				PrevNumZones = CurrNumZones;

			ASSERT (CurrNumZones != 0);

			NextReply = ZIP_REPLY;
			if (CurrNumZones > 1)
			{
				// We start a new packet for each extended network
				NewPkt = TRUE;
				NextReply = ZIP_EXT_REPLY;
				if (NetCntInPkt > 0)
				{
					Datagram[ZIP_CMD_OFF] = CurrReply;
					if (CurrReply == ZIP_REPLY)
						Datagram[ZIP_NW_CNT_OFF] = (BYTE)NetCntInPkt;
					else Datagram[ZIP_NW_CNT_OFF] = (BYTE)PrevNumZones;
					AllocNewBuffDesc = TRUE;

					pBuffDesc->bd_Length = Size;
					NetCntInPkt = 0;
					goto next_reply;
				}
			}
	
			// Walk the zone list
			for (; pZoneList != NULL; pZoneList = pZoneList->zl_Next)
			{
				PZONE	pZone = pZoneList->zl_pZone;

				// If we're starting to build a new reply packet due to
				// either:
				//
				//	1. first time through
				//	2. packet full
				//	3. switching reply types
				//
				// set the index to the first tuple position.
				if (NewPkt || (CurrReply != NextReply))
				{
					if (NetCntInPkt > 0)
					{
						// Close the current buffdesc and open a new one
						// Careful here with the CurrNumZones vs. PrevNumZones
						// If we are going from ExtReply to a Reply, we need
						// to get PrevNumZones. If we are continuing the
						// same ExtReply then we need CurrNumZones.
						Datagram[ZIP_CMD_OFF] = CurrReply;
						if (CurrReply == ZIP_REPLY)
							Datagram[ZIP_NW_CNT_OFF] = (BYTE)NetCntInPkt;
						else
						{
							Datagram[ZIP_NW_CNT_OFF] = (BYTE)CurrNumZones;
							if (CurrReply != NextReply)
								Datagram[ZIP_NW_CNT_OFF] = (BYTE)PrevNumZones;
						}
						pBuffDesc->bd_Length = Size;

						if ((pBuffDesc = AtalkAllocBuffDesc(NULL,MAX_DGRAM_SIZE,
									BD_CHAR_BUFFER | BD_FREE_BUFFER)) == NULL)
                        {
                            DBGPRINT(DBG_COMP_RTMP, DBG_LEVEL_ERR,
	                            ("\natalkZipHandleQuery:  AtalkAllocBuffDesc @2 failed\n"));
							break;
                        }

						Size = 0;
						Datagram = pBuffDesc->bd_CharBuffer;

						*ppBuffDesc = pBuffDesc;
						pBuffDesc->bd_Next = NULL;
						ppBuffDesc = &pBuffDesc->bd_Next;
						NetCntInPkt = 0;
					}
					Size = ZIP_FIRST_NET_OFF;
					CurrReply = NextReply;
					NewPkt = FALSE;
				}
				// We know the answer to the question. Pack a new
				// network/zone tuple into the reply packet.
				
				PUTSHORT2SHORT(Datagram+Size, NetNum);
				Size += sizeof(USHORT);
				Datagram[Size++] = pZone->zn_ZoneLen;
				RtlCopyMemory(Datagram + Size,
							  pZone->zn_Zone,
							  pZone->zn_ZoneLen);
				Size += pZone->zn_ZoneLen;
				NetCntInPkt ++;
				
				// If we can't hold another big tuple, signal that we
				// should send on the next pass.
				if ((Size + sizeof(USHORT) + sizeof(char) + MAX_ZONE_LENGTH)
															>= MAX_DGRAM_SIZE)
				{
				   NewPkt = TRUE;
				}
			}

            if (pBuffDesc == NULL)
            {
                break;
            }
		}

		// Dereference an rte if we broke out the loop above
		if (pRte != NULL)
		{
			ASSERT(!PortLocked);
			if (RteLocked)
			{
				RELEASE_SPIN_LOCK_DPC(&pRte->rte_Lock);
				// RteLocked = FALSE;
			}
			AtalkRtmpDereferenceRte(pRte, FALSE);
			// pRte = NULL;
		}
		if (PortLocked)
		{
			ASSERT(!RteLocked);
			RELEASE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);
            PortLocked = FALSE;
		}

		// Close the current buffdesc
		if ((!AllocNewBuffDesc) && (pBuffDesc != NULL))
		{
			pBuffDesc->bd_Length = Size;
			if (NetCntInPkt > 0)
			{
				Datagram[ZIP_CMD_OFF] = CurrReply;
				if (CurrReply == ZIP_REPLY)
					Datagram[ZIP_NW_CNT_OFF] = (BYTE)NetCntInPkt;
				else Datagram[ZIP_NW_CNT_OFF] = (BYTE)CurrNumZones;
			}
		}

		// We have a bunch of datagrams ready to be fired off.
		// Make it so. Do not send any with zero lengths, however.
		SendInfo.sc_TransmitCompletion = atalkZipSendComplete;
		// SendInfo.sc_Ctx2 = NULL;
		// SendInfo.sc_Ctx3 = NULL;
		for (pBuffDesc = pBuffDescStart;
			 pBuffDesc != NULL;
			 pBuffDesc = pBuffDescStart)
		{
			pBuffDescStart = pBuffDesc->bd_Next;
	
			if (pBuffDesc->bd_Length == 0)
			{
				ASSERT(pBuffDescStart == NULL);
				AtalkFreeBuffDesc(pBuffDesc);
				break;
			}

			//	Set the next ptr to be null. Length already set correctly.
			pBuffDesc->bd_Next = NULL;
			DBGPRINT(DBG_COMP_ZIP, DBG_LEVEL_INFO,
					("atalkZipHandleQuery: Sending Reply to %d.%d.%d\n",
					pSrcAddr->ata_Network, pSrcAddr->ata_Node, pSrcAddr->ata_Socket));
			SendInfo.sc_Ctx1 = pBuffDesc;
			error = AtalkDdpSend(pDdpAddr,
								 pSrcAddr,
								 DDPPROTO_ZIP,
								 FALSE,
								 pBuffDesc,
								 NULL,
								 0,
								 NULL,
								 &SendInfo);
			if (!ATALK_SUCCESS(error))
			{
				AtalkFreeBuffDesc(pBuffDesc);
				DBGPRINT(DBG_COMP_ZIP, DBG_LEVEL_ERR,
						("atalkZipHandleQuery: AtalkDdpSend %ld\n", error));
			}
		}
	} while (FALSE);

	if (PortLocked)
	{
		ASSERT(!RteLocked);
		RELEASE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);
	}
}


/***	atalkZipHandleAtpRequest
 *
 */
VOID
atalkZipHandleAtpRequest(
	IN	PPORT_DESCRIPTOR	pPortDesc,
	IN	PDDP_ADDROBJ		pDdpAddr,
	IN	PATALK_ADDR			pSrcAddr,
	IN	BYTE				CmdType,
	IN	USHORT				TrId,
	IN	USHORT				StartIndex
)
{
	PBUFFER_DESC	pBuffDesc;
	PBYTE			Datagram, ZoneName;
	PZONE			pZone;
	ATALK_ERROR		error;
	int				i, ZoneLen, ZoneCnt, CurrZoneIndex, index;
	BYTE			LastFlag = 0;
	SEND_COMPL_INFO	SendInfo;

	ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

	do
	{
		// Allocate a buffer descriptor and initialize the header
		if ((pBuffDesc = AtalkAllocBuffDesc(NULL, MAX_DGRAM_SIZE,
								BD_CHAR_BUFFER | BD_FREE_BUFFER)) == NULL)
		{
			break;
		}

		Datagram = pBuffDesc->bd_CharBuffer;
		Datagram[ATP_CMD_CONTROL_OFF] = ATP_RESPONSE + ATP_EOM_MASK;
		Datagram[ATP_SEQ_NUM_OFF] = 0;
		PUTSHORT2SHORT(Datagram + ATP_TRANS_ID_OFF, TrId);
		SendInfo.sc_TransmitCompletion = atalkZipSendComplete;
		SendInfo.sc_Ctx1 = pBuffDesc;
		// SendInfo.sc_Ctx2 = NULL;
		// SendInfo.sc_Ctx3 = NULL;
	
		if (CmdType == ZIP_GET_MY_ZONE)
		{
			// We really shouldn't be getting this request on an
			// extended network, but go ahead and reply with the
			// "default zone" in this case, of course, reply with
			// "desired zone" for non-extended nets.  We are a router,
			// so "desired zone" will always be valid -- as will the
			// default zone for extended net.
		
			PUTSHORT2SHORT(Datagram+ATP_ZIP_LAST_FLAG_OFF, 0);
			PUTSHORT2SHORT(Datagram+ATP_ZIP_START_INDEX_OFF, 1);
	
			ACQUIRE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);

			if (EXT_NET(pPortDesc))
			{
				ZoneName = pPortDesc->pd_DefaultZone->zn_Zone;
				ZoneLen = pPortDesc->pd_DefaultZone->zn_ZoneLen;
			}
			else
			{
				ZoneName = pPortDesc->pd_DesiredZone->zn_Zone;
				ZoneLen = pPortDesc->pd_DesiredZone->zn_ZoneLen;
			}
			RtlCopyMemory(Datagram+ATP_DATA_OFF+1, ZoneName, ZoneLen);
			Datagram[ATP_DATA_OFF] = (BYTE)ZoneLen;

			RELEASE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);

			//	Set the length in the buffer descriptor.
			AtalkSetSizeOfBuffDescData(pBuffDesc, (USHORT)(ATP_DATA_OFF + 1 + ZoneLen));
	
			DBGPRINT(DBG_COMP_ZIP, DBG_LEVEL_INFO,
					("atalkZipHandleAtpReq: Sending GetMyZone Reply to %d.%d.%d\n",
					pSrcAddr->ata_Network, pSrcAddr->ata_Node, pSrcAddr->ata_Socket));
			error = AtalkDdpSend(pDdpAddr,
								 pSrcAddr,
								 DDPPROTO_ATP,
								 FALSE,
								 pBuffDesc,
								 NULL,
								 0,
								 NULL,
								 &SendInfo);
			if (!ATALK_SUCCESS(error))
			{
				DBGPRINT(DBG_COMP_ZIP, DBG_LEVEL_ERR,
						("atalkZipHandleAtpRequest: AtalkDdpSend %ld\n", error));
			}
			break;
		}
	
		// Either a GetLocalZones or a GetZoneList. Fill the reply packet
		// with as many zones as it'll hold starting at the requested
		// start index
		index = ATP_DATA_OFF;
	
		if (CmdType == ZIP_GET_LOCAL_ZONES)
		{
			PZONE_LIST	pZoneList;

			// For GetLocalZones, we only want to count zones
			// that are on the network that is directly connected
			// to the port on which the request originated. Use the
			// zone list on the port.
			ACQUIRE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);
			for (pZoneList = pPortDesc->pd_ZoneList, ZoneCnt = 0, CurrZoneIndex = 0;
				 pZoneList != NULL;
				 pZoneList = pZoneList->zl_Next)
			{
				// If we have not seen StartIndex zones yet, keep going
				if (++CurrZoneIndex < StartIndex)
					continue;

				pZone = pZoneList->zl_pZone;
	
				// If this packet cannot hold more, we're done (for now)
				// Fill in the zone count and the last flag
				if ((index + pZone->zn_ZoneLen + 1) >= MAX_DGRAM_SIZE)
				{
					break;
				}

				// Place zone name in the packet
				ASSERT(pZone != NULL);
				Datagram[index] = pZone->zn_ZoneLen;
				RtlCopyMemory(Datagram+index+1,
							  pZone->zn_Zone,
							  pZone->zn_ZoneLen);
				index += (pZone->zn_ZoneLen + 1);
				ZoneCnt ++;
			}
			RELEASE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);

			// We've build a packet, set the last flag, if applicable
			LastFlag = (pZoneList == NULL) ? 1 : 0;
		}

		else	// This is a ZIP_GET_ZONE_LIST
		{
			BOOLEAN	PktFull = FALSE;

			ASSERT (CmdType == ZIP_GET_ZONE_LIST);

			// For GetZoneList, we want all the zones that we know
			// of, so use the AtalkZoneTable.
			ACQUIRE_SPIN_LOCK_DPC(&AtalkZoneLock);
			for (i = 0, ZoneCnt = 0, CurrZoneIndex = 0;
				 (i < NUM_ZONES_HASH_BUCKETS) && !PktFull; i++)
			{
				for (pZone = AtalkZonesTable[i];
					 pZone != NULL;
					 pZone = pZone->zn_Next)
				{
					// If we have not seen StartIndex zones yet, keep going
					if (++CurrZoneIndex < StartIndex)
						continue;
		
					// If this packet cannot hold more, we're done (for now)
					// Fill in the zone count and the last flag
					if ((index + pZone->zn_ZoneLen + 1) >= MAX_DGRAM_SIZE)
					{
						PktFull = TRUE;
						break;
					}

					// Place zone name in the packet
					Datagram[index] = pZone->zn_ZoneLen;
					RtlCopyMemory(Datagram+index+1,
								  pZone->zn_Zone,
								  pZone->zn_ZoneLen);
					index += (pZone->zn_ZoneLen + 1);
					ZoneCnt ++;
				}
			}
			RELEASE_SPIN_LOCK_DPC(&AtalkZoneLock);

			// We've build a packet, set the last flag, if applicable
			LastFlag = ((i == NUM_ZONES_HASH_BUCKETS) && (pZone == NULL)) ? 1 : 0;
		}

		// We've build a packet, set the last flag and # of zones in packet
		Datagram[ATP_ZIP_LAST_FLAG_OFF] = LastFlag;
		Datagram[ATP_ZIP_LAST_FLAG_OFF + 1] = 0;
		PUTSHORT2SHORT(Datagram + ATP_ZIP_ZONE_CNT_OFF, ZoneCnt);

		//	Set the length in the buffer descriptor.
        AtalkSetSizeOfBuffDescData(pBuffDesc, (USHORT)index);

		// Finally, send this out
		DBGPRINT(DBG_COMP_ZIP, DBG_LEVEL_INFO,
				("atalkZipHandleAtpReq: Sending LocalZones Reply to %d.%d.%d\n",
				pSrcAddr->ata_Network, pSrcAddr->ata_Node, pSrcAddr->ata_Socket));
		error = AtalkDdpSend(pDdpAddr,
							 pSrcAddr,
							 DDPPROTO_ATP,
							 FALSE,
							 pBuffDesc,
							 NULL,
							 0,
							 NULL,
							 &SendInfo);
		if (!ATALK_SUCCESS(error))
		{
			AtalkFreeBuffDesc(pBuffDesc);
			DBGPRINT(DBG_COMP_ZIP, DBG_LEVEL_ERR,
					("atalkZipHandleAtpRequest: AtalkDdpSend %ld\n", error));
		}
	} while (FALSE);
}


/***	AtalkZipMulticastAddrForZone
 *
 */
VOID
AtalkZipMulticastAddrForZone(
	IN	PPORT_DESCRIPTOR	pPortDesc,
	IN	PBYTE				pZone,
	IN	BYTE				ZoneLen,
	IN	PBYTE				MulticastAddr
)
{
	USHORT	CheckSum;
	BYTE	UpCasedZone[MAX_ZONE_LENGTH];

	AtalkUpCase(pZone, ZoneLen, UpCasedZone);

	// Caculate the checksum for the zone
	CheckSum = AtalkDdpCheckSumBuffer(UpCasedZone, ZoneLen, 0);

	switch (pPortDesc->pd_PortType)
	{
		case ELAP_PORT:
		case FDDI_PORT:
			RtlCopyMemory(MulticastAddr,
						  AtalkEthernetZoneMulticastAddrsHdr,
						  ELAP_MCAST_HDR_LEN);

			MulticastAddr[ELAP_MCAST_HDR_LEN] =
						  AtalkEthernetZoneMulticastAddrs[CheckSum % ELAP_ZONE_MULTICAST_ADDRS];
			break;
		case TLAP_PORT:
			RtlCopyMemory(MulticastAddr,
						  AtalkTokenRingZoneMulticastAddrsHdr,
						  TLAP_MCAST_HDR_LEN);

			RtlCopyMemory(&MulticastAddr[TLAP_MCAST_HDR_LEN],
						  AtalkTokenRingZoneMulticastAddrs[CheckSum % TLAP_ZONE_MULTICAST_ADDRS],
						  TLAP_ADDR_LEN - TLAP_MCAST_HDR_LEN);
			break;
		default:
			DBGBRK(DBG_LEVEL_FATAL);
			KeBugCheck(0);
	}
}


/***	AtalkZipGetNetworkInfoForNode
 *
 */
BOOLEAN
AtalkZipGetNetworkInfoForNode(
	IN	PPORT_DESCRIPTOR	pPortDesc,
	IN	PATALK_NODEADDR		pNode,
	IN	BOOLEAN				FindDefZone
)
{
	PBUFFER_DESC		pBuffDesc = NULL;
	ATALK_ADDR			SrcAddr, DstAddr;
	ATALK_ERROR			error;
	USHORT				NumReqs, DgLen;
	BYTE				DgCopy[ZIP_ZONENAME_OFF + MAX_ZONE_LENGTH];
	KIRQL				OldIrql;
	BOOLEAN				RetCode, Done;
	SEND_COMPL_INFO		SendInfo;

	ASSERT(EXT_NET(pPortDesc));

	ACQUIRE_SPIN_LOCK(&pPortDesc->pd_Lock, &OldIrql);

	if (FindDefZone)
	{
		pPortDesc->pd_Flags &= ~PD_VALID_DEFAULT_ZONE;
		pPortDesc->pd_Flags |= PD_FINDING_DEFAULT_ZONE;
	}
	else
	{
		pPortDesc->pd_Flags &= ~PD_VALID_DESIRED_ZONE;
		pPortDesc->pd_Flags |= PD_FINDING_DESIRED_ZONE;
	}

	// Get source and destination addresses
	SrcAddr.ata_Network = pNode->atn_Network;
	SrcAddr.ata_Node = pNode->atn_Node;
	SrcAddr.ata_Socket = ZONESINFORMATION_SOCKET;

	DstAddr.ata_Network = CABLEWIDE_BROADCAST_NETWORK;
	DstAddr.ata_Node = ATALK_BROADCAST_NODE;
	DstAddr.ata_Socket = ZONESINFORMATION_SOCKET;

	// Build a ZipNetGetInfo datagram
	DgCopy[ZIP_CMD_OFF] = ZIP_GET_NETINFO;
	DgCopy[ZIP_FLAGS_OFF] = 0;
	PUTSHORT2SHORT(DgCopy + ZIP_CABLE_RANGE_START_OFF, 0);
	PUTSHORT2SHORT(DgCopy + ZIP_CABLE_RANGE_END_OFF, 0);

	DgLen = ZIP_ZONENAME_OFF;
	DgCopy[ZIP_ZONELEN_OFF] = 0;
	if (!FindDefZone &&
		(pPortDesc->pd_InitialDesiredZone != NULL))
	{
		DgCopy[ZIP_ZONELEN_OFF] = pPortDesc->pd_InitialDesiredZone->zn_ZoneLen;
		RtlCopyMemory(DgCopy + ZIP_ZONENAME_OFF,
					  pPortDesc->pd_InitialDesiredZone->zn_Zone,
					  pPortDesc->pd_InitialDesiredZone->zn_ZoneLen);
		DgLen += DgCopy[ZIP_ZONELEN_OFF];
	}

	RELEASE_SPIN_LOCK(&pPortDesc->pd_Lock, OldIrql);

	for (NumReqs = 0;
		 NumReqs < ZIP_NUM_GETNET_INFOS;
		 NumReqs++)
	{
		Done = FindDefZone ?
				((pPortDesc->pd_Flags & PD_VALID_DEFAULT_ZONE) != 0) :
				((pPortDesc->pd_Flags & PD_VALID_DESIRED_ZONE) != 0);

		if (Done)
        {
			break;
        }

		if ((pBuffDesc = AtalkAllocBuffDesc(NULL, DgLen,
									BD_CHAR_BUFFER | BD_FREE_BUFFER)) == NULL)
		{
			break;
		}
		RtlCopyMemory(pBuffDesc->bd_CharBuffer, DgCopy, DgLen);

		//	Set the length in the buffer descriptor.
		AtalkSetSizeOfBuffDescData(pBuffDesc, DgLen);
	
		SendInfo.sc_TransmitCompletion = atalkZipSendComplete;
		SendInfo.sc_Ctx1 = pBuffDesc;
		// SendInfo.sc_Ctx2 = NULL;
		// SendInfo.sc_Ctx3 = NULL;

		error = AtalkDdpTransmit(pPortDesc,
								 &SrcAddr,
								 &DstAddr,
								 DDPPROTO_ZIP,
								 pBuffDesc,
								 NULL,
								 0,
								 0,
								 NULL,
								 NULL,
								 &SendInfo);
		if (!ATALK_SUCCESS(error))
		{
			DBGPRINT(DBG_COMP_ZIP, DBG_LEVEL_ERR,
					("AtalkZipGetNetworkInfoForNode: AtalkDdpTransmit %ld\n", error));
			break;
		}
		pBuffDesc = NULL;
		AtalkSleep(ZIP_GET_NETINFO_WAIT);
	}

	if (pBuffDesc != NULL)
		AtalkFreeBuffDesc(pBuffDesc);

	ACQUIRE_SPIN_LOCK(&pPortDesc->pd_Lock, &OldIrql);
	if (FindDefZone)
	{
		pPortDesc->pd_Flags &= ~PD_FINDING_DEFAULT_ZONE;
	}
	else
	{
		pPortDesc->pd_Flags &= ~PD_FINDING_DESIRED_ZONE;
	}

	RetCode = FindDefZone ?
				((pPortDesc->pd_Flags & PD_VALID_DEFAULT_ZONE) == PD_VALID_DEFAULT_ZONE) :
				((pPortDesc->pd_Flags & PD_VALID_DESIRED_ZONE) == PD_VALID_DESIRED_ZONE);

	RELEASE_SPIN_LOCK(&pPortDesc->pd_Lock, OldIrql);

    return RetCode;
}


/***	AtalkZipGetMyZone
 *
 */
ATALK_ERROR
AtalkZipGetMyZone(
	IN		PPORT_DESCRIPTOR	pPortDesc,
	IN		BOOLEAN				fDesired,
	IN	OUT	PAMDL				pAMdl,
	IN		INT					Size,
	IN		PACTREQ				pActReq
)
{
	PZIPCOMPLETIONINFO	pZci = NULL;
	ATALK_ERROR			Status = ATALK_NO_ERROR;
	ULONG				BytesCopied;
	PZONE				pZone;
	KIRQL				OldIrql;
	BOOLEAN				Done = FALSE;

	ASSERT (VALID_ACTREQ(pActReq));

	if (Size < (MAX_ZONE_LENGTH + 1))
		return ATALK_BUFFER_TOO_SMALL;

	do
	{
		ACQUIRE_SPIN_LOCK(&pPortDesc->pd_Lock, &OldIrql);

		// For extended network, we either know or cannot find out
		if (EXT_NET(pPortDesc))
		{
			BOOLEAN	Yes = FALSE;

			if (fDesired && (pPortDesc->pd_Flags & PD_VALID_DESIRED_ZONE))
			{
				pZone = pPortDesc->pd_DesiredZone;
				Yes = TRUE;
			}
			else if (!fDesired && (pPortDesc->pd_Flags & PD_VALID_DEFAULT_ZONE))
			{
				pZone = pPortDesc->pd_DefaultZone;
				Yes = TRUE;
			}
			if (Yes)
			{
				TdiCopyBufferToMdl( pZone->zn_Zone,
									0,
									pZone->zn_ZoneLen,
									pAMdl,
									0,
									&BytesCopied);
				ASSERT (BytesCopied == pZone->zn_ZoneLen);
	
				TdiCopyBufferToMdl( "",
									0,
									1,
									pAMdl,
									pZone->zn_ZoneLen,
									&BytesCopied);
				ASSERT (BytesCopied == 1);
				Done = TRUE;
			}
		}

		// For non-extended networks, we need to ask a router. If we don't
		// know about a router, return.
		if (!Done &&
			(EXT_NET(pPortDesc) ||
			 !(pPortDesc->pd_Flags & PD_SEEN_ROUTER_RECENTLY)))
		{
			TdiCopyBufferToMdl( "*",
								0,
								sizeof("*"),
								pAMdl,
								0,
								&BytesCopied);
			ASSERT (BytesCopied == sizeof("*"));
			Done = TRUE;
		}

		RELEASE_SPIN_LOCK(&pPortDesc->pd_Lock, OldIrql);

		if (Done)
		{
			(*pActReq->ar_Completion)(ATALK_NO_ERROR, pActReq);
			break;
		}

		ASSERT (!EXT_NET(pPortDesc));

		// Allocate a Completion info structure
		if ((pZci = AtalkAllocMemory(sizeof(ZIPCOMPLETIONINFO))) == NULL)
		{
			Status = ATALK_RESR_MEM;
			break;
		}

		// Initialize completion info
#if	DBG
		pZci->zci_Signature = ZCI_SIGNATURE;
#endif
		INITIALIZE_SPIN_LOCK(&pZci->zci_Lock);
		pZci->zci_RefCount = 1;
		pZci->zci_pPortDesc = pPortDesc;
        pZci->zci_pDdpAddr = NULL;
		pZci->zci_pAMdl = pAMdl;
		pZci->zci_BufLen = Size;
		pZci->zci_pActReq = pActReq;
		pZci->zci_Router.ata_Network = pPortDesc->pd_ARouter.atn_Network;
		pZci->zci_Router.ata_Node = pPortDesc->pd_ARouter.atn_Node;
		pZci->zci_Router.ata_Socket = ZONESINFORMATION_SOCKET;
		pZci->zci_ExpirationCount = ZIP_GET_ZONEINFO_RETRIES;
		pZci->zci_NextZoneOff = 0;
		pZci->zci_ZoneCount = -1;
		pZci->zci_AtpRequestType = ZIP_GET_MY_ZONE;
		pZci->zci_Handler = atalkZipGetMyZoneReply;
		AtalkTimerInitialize(&pZci->zci_Timer,
							 atalkZipZoneInfoTimer,
							 ZIP_GET_ZONEINFO_TIMER);

		Status = atalkZipSendPacket(pZci, TRUE);
		if (!ATALK_SUCCESS(Status))
		{
			DBGPRINT(DBG_COMP_ZIP, DBG_LEVEL_INFO,
					("AtalkZipGetMyZone: atalkZipSendPacket %ld\n",
					Status));
			pZci->zci_FinalStatus = Status;
			atalkZipDereferenceZci(pZci);
			Status = ATALK_PENDING;		// atalkZipDereferenceZci completes the req
		}
	} while (FALSE);

	return(Status);
}


/***	atalkZipGetMyZoneReply
 *
 */
VOID
atalkZipGetMyZoneReply(
	IN	PPORT_DESCRIPTOR		pPortDesc,
	IN	PDDP_ADDROBJ			pDdpAddr,
	IN	PBYTE					pPkt,
	IN	USHORT					PktLen,
	IN	PATALK_ADDR				pSrcAddr,
	IN	PATALK_ADDR				pDstAddr,
	IN	ATALK_ERROR				Status,
	IN	BYTE					DdpType,
	IN	PZIPCOMPLETIONINFO		pZci,
	IN	BOOLEAN					OptimizePath,
	IN	PVOID					OptimizeCtx
)
{
	ULONG			BytesCopied;
	KIRQL			OldIrql;
	USHORT			ZoneCnt;
	BYTE			ZoneLen;

	do
	{
		if (Status == ATALK_SOCKET_CLOSED)
		{
			pZci->zci_pDdpAddr = NULL;
			if (AtalkTimerCancelEvent(&pZci->zci_Timer, NULL))
				atalkZipDereferenceZci(pZci);
			pZci->zci_FinalStatus = Status;
			atalkZipDereferenceZci(pZci);
			break;
		}

		if ((Status != ATALK_NO_ERROR) ||
			(DdpType != DDPPROTO_ATP) ||
			(PktLen <= ATP_ZIP_FIRST_ZONE_OFF))
		{
			AtalkLogBadPacket(pPortDesc,
							  pSrcAddr,
							  pDstAddr,
							  pPkt,
							  PktLen);
			break;
		}

		// We should have one zone
		GETSHORT2SHORT(&ZoneCnt, pPkt + ATP_ZIP_ZONE_CNT_OFF);
		ZoneLen = pPkt[ATP_ZIP_FIRST_ZONE_OFF];
		if ((ZoneCnt != 1) ||
			(ZoneLen == 0) || (ZoneLen > MAX_ZONE_LENGTH))
		{
			DBGPRINT(DBG_COMP_ZIP, DBG_LEVEL_ERR,
					("atalkZipGetMyZoneReply: Bad reply\n"));
			break;
		}

		if (AtalkTimerCancelEvent(&pZci->zci_Timer, NULL))
		{
			atalkZipDereferenceZci(pZci);
		}

		ACQUIRE_SPIN_LOCK(&pZci->zci_Lock, &OldIrql);

		TdiCopyBufferToMdl( pPkt + ATP_ZIP_FIRST_ZONE_OFF + 1,
							0,
							ZoneLen,
							pZci->zci_pAMdl,
							0,
							&BytesCopied);
		ASSERT (BytesCopied == ZoneLen);

		TdiCopyBufferToMdl( "",
							0,
							1,
							pZci->zci_pAMdl,
							ZoneLen,
							&BytesCopied);
		ASSERT (BytesCopied == 1);
		pZci->zci_FinalStatus = ATALK_NO_ERROR;
		RELEASE_SPIN_LOCK(&pZci->zci_Lock, OldIrql);
		atalkZipDereferenceZci(pZci);
	} while (FALSE);
}


/***	AtalkZipGetZoneList
 *
 */
ATALK_ERROR
AtalkZipGetZoneList(
	IN		PPORT_DESCRIPTOR	pPortDesc,
	IN		BOOLEAN				fLocalZones,
	IN	OUT	PAMDL				pAMdl,
	IN		INT					Size,
	IN		PACTREQ				pActReq
)
{
	PZIPCOMPLETIONINFO	pZci = NULL;
	ATALK_ERROR			Status = ATALK_NO_ERROR;
	ULONG				BytesCopied, index, NumZones;
	KIRQL				OldIrql;
	BOOLEAN				Done = FALSE, PortLocked = TRUE;

	ASSERT (VALID_ACTREQ(pActReq));

	if (Size < (MAX_ZONE_LENGTH + 1))
		return ATALK_BUFFER_TOO_SMALL;

	ACQUIRE_SPIN_LOCK(&pPortDesc->pd_Lock, &OldIrql);

	do
	{
		// If we don't know about a router, return.
		if (!(pPortDesc->pd_Flags & PD_SEEN_ROUTER_RECENTLY))
		{
			DBGPRINT(DBG_COMP_ZIP, DBG_LEVEL_WARN,
					("AtalkZipGetZoneList: Don't know a router !!!\n"));
			TdiCopyBufferToMdl( "*",
								0,
								sizeof("*"),
								pAMdl,
								0,
								&BytesCopied);
			ASSERT (BytesCopied == sizeof("*"));
			Done = TRUE;
		}

		RELEASE_SPIN_LOCK(&pPortDesc->pd_Lock, OldIrql);
		PortLocked = FALSE;

		if (Done)
		{
            ((PZIP_GETZONELIST_PARAMS)(pActReq->ar_pParms))->ZonesAvailable = 1;
			(*pActReq->ar_Completion)(ATALK_NO_ERROR, pActReq);
			break;
		}

		// If we are a router, then simply copy the zones. Else send a
		// a request to the router. DO NOT SEND A REQUEST IF WE ARE A
		// ROUTER SINCE THAT WILL RESULT IN A HORRIBLE RECURSION RESULTING
		// IN A DOUBLE FAULT (OUT OF STACK SPACE).
		if (pPortDesc->pd_Flags & PD_ROUTER_RUNNING)
		{
			PZONE		pZone;

			NumZones = 0;
			if (fLocalZones)
			{
				PZONE_LIST	pZoneList;
	
				// For GetLocalZones, we only want to count zones
				// that are on the network that is directly connected
				// to the port on which the request originated
				ACQUIRE_SPIN_LOCK(&pPortDesc->pd_Lock, &OldIrql);
				for (index = 0, pZoneList = pPortDesc->pd_ZoneList;
					 pZoneList != NULL;
					 pZoneList = pZoneList->zl_Next)
				{
					pZone = pZoneList->zl_pZone;

					ASSERT (pZone != NULL);

					// If this packet cannot hold more, we're done
					if ((INT)(index + pZone->zn_ZoneLen + 1) >= Size)
					{
						break;
					}

					// Place zone name in the packet
					TdiCopyBufferToMdl( pZone->zn_Zone,
										0,
										pZone->zn_ZoneLen + 1,
										pAMdl,
										index,
										&BytesCopied);
					ASSERT (BytesCopied == (ULONG)(pZone->zn_ZoneLen + 1));
			
					NumZones ++;
					index += (pZone->zn_ZoneLen + 1);
				}
				RELEASE_SPIN_LOCK(&pPortDesc->pd_Lock, OldIrql);
				Status = (pZoneList != NULL) ?
								ATALK_BUFFER_TOO_SMALL : ATALK_NO_ERROR;
			}
			else
			{
				BOOLEAN	PktFull = FALSE;
				INT		i;
	
				ACQUIRE_SPIN_LOCK(&AtalkZoneLock, &OldIrql);
				for (i = 0, index = 0, PktFull = FALSE;
					 (i < NUM_ZONES_HASH_BUCKETS) && !PktFull;
					 i++)
				{
					for (pZone = AtalkZonesTable[i];
						 pZone != NULL;
						 pZone = pZone->zn_Next)
					{
						// If this packet cannot hold more, we're done
						if ((INT)(index + pZone->zn_ZoneLen + 1) >= Size)
						{
							PktFull = TRUE;
							break;
						}

						// Place zone name in the packet
						TdiCopyBufferToMdl( pZone->zn_Zone,
											0,
											pZone->zn_ZoneLen + 1,
											pAMdl,
											index,
											&BytesCopied);
						ASSERT (BytesCopied == (ULONG)(pZone->zn_ZoneLen + 1));
				
						NumZones ++;
						index += (pZone->zn_ZoneLen + 1);
					}
				}
				RELEASE_SPIN_LOCK(&AtalkZoneLock, OldIrql);
				Status = ((pZone != NULL) || ( i < NUM_ZONES_HASH_BUCKETS)) ?
								ATALK_BUFFER_TOO_SMALL : ATALK_NO_ERROR;
			}
            ((PZIP_GETZONELIST_PARAMS)
							(pActReq->ar_pParms))->ZonesAvailable = NumZones;
            if (ATALK_SUCCESS(Status))
            {
			(*pActReq->ar_Completion)(Status, pActReq);
            }
			break;
		}

		ASSERT ((pPortDesc->pd_Flags & PD_ROUTER_RUNNING) == 0);

		// Allocate a Completion info structure
		if ((pZci = AtalkAllocMemory(sizeof(ZIPCOMPLETIONINFO))) == NULL)
		{
			Status = ATALK_RESR_MEM;
			break;
		}
	
		// Initialize completion info
#if	DBG
		pZci->zci_Signature = ZCI_SIGNATURE;
#endif
		INITIALIZE_SPIN_LOCK(&pZci->zci_Lock);
		pZci->zci_RefCount = 1;
		pZci->zci_pPortDesc = pPortDesc;
		pZci->zci_pDdpAddr = NULL;
		pZci->zci_pAMdl = pAMdl;
		pZci->zci_BufLen = Size;
		pZci->zci_pActReq = pActReq;
		pZci->zci_Router.ata_Network = pPortDesc->pd_ARouter.atn_Network;
		pZci->zci_Router.ata_Node = pPortDesc->pd_ARouter.atn_Node;
		pZci->zci_Router.ata_Socket = ZONESINFORMATION_SOCKET;
		pZci->zci_ExpirationCount = ZIP_GET_ZONEINFO_RETRIES;
		pZci->zci_NextZoneOff = 0;
		pZci->zci_ZoneCount = 0;
		pZci->zci_AtpRequestType = ZIP_GET_ZONE_LIST;
		AtalkTimerInitialize(&pZci->zci_Timer,
							 atalkZipZoneInfoTimer,
							 ZIP_GET_ZONEINFO_TIMER);
		if (fLocalZones)
			pZci->zci_AtpRequestType = ZIP_GET_LOCAL_ZONES;
		pZci->zci_Handler = atalkZipGetZoneListReply;
	
		Status = atalkZipSendPacket(pZci, TRUE);
		if (!ATALK_SUCCESS(Status))
		{
			DBGPRINT(DBG_COMP_ZIP, DBG_LEVEL_ERR,
					("AtalkZipGetZoneList: atalkZipSendPacket %ld\n", Status));
			pZci->zci_FinalStatus = Status;
			atalkZipDereferenceZci(pZci);
			Status = ATALK_PENDING;		// atalkZipDereferenceZci completes the req
		}
	} while (FALSE);

	if (PortLocked)
		RELEASE_SPIN_LOCK(&pPortDesc->pd_Lock, OldIrql);

	return(Status);
}



/***	atalkZipGetZoneListReply
 *
 */
VOID
atalkZipGetZoneListReply(
	IN	PPORT_DESCRIPTOR		pPortDesc,
	IN	PDDP_ADDROBJ			pDdpAddr,
	IN	PBYTE					pPkt,
	IN	USHORT					PktLen,
	IN	PATALK_ADDR				pSrcAddr,
	IN	PATALK_ADDR				pDstAddr,
	IN	ATALK_ERROR				Status,
	IN	BYTE					DdpType,
	IN	PZIPCOMPLETIONINFO		pZci,
	IN	BOOLEAN					OptimizePath,
	IN	PVOID					OptimizeCtx
)
{
	PBYTE				pZone;
	ULONG				dindex;
	ULONG				BytesCopied;
	USHORT				ZoneCnt;
	BYTE				ZoneLen;
	BOOLEAN				LastFlag, Overflow = FALSE;

	ASSERT(VALID_ZCI(pZci));

	do
	{
		if (Status == ATALK_SOCKET_CLOSED)
		{
			pZci->zci_pDdpAddr = NULL;
			if (AtalkTimerCancelEvent(&pZci->zci_Timer, NULL))
			{
				atalkZipDereferenceZci(pZci);
			}
			pZci->zci_FinalStatus = Status;
			atalkZipDereferenceZci(pZci);
			break;
		}

		if ((Status != ATALK_NO_ERROR) ||
			(DdpType != DDPPROTO_ATP) ||
			(PktLen <= ATP_ZIP_FIRST_ZONE_OFF))
		{
			AtalkLogBadPacket(pPortDesc,
							  pSrcAddr,
							  pDstAddr,
							  pPkt,
							  PktLen);
			break;
		}

		// We should have a zone list.
		// Cancel the timer. Start it again if we have not got all the zones
		if (AtalkTimerCancelEvent(&pZci->zci_Timer, NULL))
		{
			atalkZipDereferenceZci(pZci);
		}

		DBGPRINT(DBG_COMP_ZIP, DBG_LEVEL_INFO,
				("atalkZipGetZoneListReply: More zones. Index %d, SizeLeft %d\n",
				pZci->zci_ZoneCount, pZci->zci_BufLen - pZci->zci_NextZoneOff));

		ACQUIRE_SPIN_LOCK_DPC(&pZci->zci_Lock);

		GETSHORT2SHORT(&ZoneCnt, pPkt + ATP_ZIP_ZONE_CNT_OFF);
		LastFlag = FALSE;
		if ((pPkt[ATP_ZIP_LAST_FLAG_OFF] != 0) ||
			(ZoneCnt == 0))
			LastFlag = TRUE;
		dindex = ATP_ZIP_FIRST_ZONE_OFF;

		while (ZoneCnt != 0)
		{
			// Pull out the next zone
			ZoneLen = pPkt[dindex++];
			if ((ZoneLen == 0) ||
				(ZoneLen > MAX_ZONE_LENGTH) ||
				(PktLen < (dindex + ZoneLen)))
			{
				DBGPRINT(DBG_COMP_ZIP, DBG_LEVEL_ERR,
						("atalkZipGetZoneListReply: Bad Zip reply\n"));
				break;
			}
			pZone = pPkt + dindex;
			dindex += ZoneLen;
			if ((pZci->zci_NextZoneOff + ZoneLen + 1) > pZci->zci_BufLen)
			{
				DBGPRINT(DBG_COMP_ZIP, DBG_LEVEL_INFO,
						("AtalkZipGetZoneList: Overflow\n"));
				Overflow = TRUE;
				break;
			}
			DBGPRINT(DBG_COMP_ZIP, DBG_LEVEL_INFO,
					("AtalkZipGetZoneList: Copying a zone (%d, %d)\n",
					pZci->zci_ZoneCount,
					pZci->zci_BufLen - pZci->zci_NextZoneOff));
			TdiCopyBufferToMdl( pZone,
								0,
								ZoneLen,
								pZci->zci_pAMdl,
								pZci->zci_NextZoneOff,
								&BytesCopied);
			ASSERT (BytesCopied == ZoneLen);
	
			TdiCopyBufferToMdl( "",
								0,
								1,
								pZci->zci_pAMdl,
								pZci->zci_NextZoneOff + ZoneLen,
								&BytesCopied);
			pZci->zci_NextZoneOff += (ZoneLen + 1);
            pZci->zci_ZoneCount ++;
			ZoneCnt --;
		}

		RELEASE_SPIN_LOCK_DPC(&pZci->zci_Lock);

		if (Overflow || LastFlag)
		{
			DBGPRINT(DBG_COMP_ZIP, DBG_LEVEL_INFO,
					("atalkZipGetZoneListReply: All that we wanted\n"));

			pZci->zci_FinalStatus = ATALK_NO_ERROR;
			if (Overflow)
				pZci->zci_FinalStatus = ATALK_BUFFER_TOO_SMALL;
            ((PZIP_GETZONELIST_PARAMS)
					(pZci->zci_pActReq->ar_pParms))->ZonesAvailable =
														pZci->zci_ZoneCount;
			atalkZipDereferenceZci(pZci);
		}
		else
		{
			DBGPRINT(DBG_COMP_ZIP, DBG_LEVEL_INFO,
					("atalkZipGetZoneListReply: Sending another packet\n"));

			Status = atalkZipSendPacket(pZci, TRUE);
			if (!ATALK_SUCCESS(Status))
			{
				DBGPRINT(DBG_COMP_ZIP, DBG_LEVEL_ERR,
						("AtalkZipGetZoneListReply: atalkZipSendPacket %ld\n", Status));
				pZci->zci_FinalStatus = Status;
				atalkZipDereferenceZci(pZci);
			}
		}
	} while (FALSE);
}


/***	atalkZipZoneInfoTimer
 *
 */
LOCAL LONG FASTCALL
atalkZipZoneInfoTimer(
	IN	PTIMERLIST			pTimer,
	IN	BOOLEAN				TimerShuttingDown
)
{
	PZIPCOMPLETIONINFO	pZci;
	ATALK_ERROR			Status;
	ULONG				BytesCopied;
	BOOLEAN				Done = FALSE, RestartTimer = FALSE;

	pZci = (PZIPCOMPLETIONINFO)CONTAINING_RECORD(pTimer, ZIPCOMPLETIONINFO, zci_Timer);

	DBGPRINT(DBG_COMP_ZIP, DBG_LEVEL_INFO,
			("atalkZipZoneInfoTimer: Entered for pZci = %lx\n", pZci));

	ASSERT(VALID_ZCI(pZci));

	do
	{
		ACQUIRE_SPIN_LOCK_DPC(&pZci->zci_Lock);
		if (--(pZci->zci_ExpirationCount) != 0)
		{
			RestartTimer = TRUE;
			DBGPRINT(DBG_COMP_ZIP, DBG_LEVEL_INFO,
					("atalkZipZoneInfoTimer: Sending another packet\n", pZci));

			RELEASE_SPIN_LOCK_DPC(&pZci->zci_Lock);
			Status = atalkZipSendPacket(pZci, FALSE);
			if (!ATALK_SUCCESS(Status))
			{
				RestartTimer = FALSE;
				DBGPRINT(DBG_COMP_ZIP, DBG_LEVEL_INFO,
						("atalkZipZoneInfoTimer: atalkZipSendPacket %ld\n",
						Status));

				pZci->zci_FinalStatus = Status;
				atalkZipDereferenceZci(pZci);
			}
			break;
		}

		if (pZci->zci_AtpRequestType == ZIP_GET_MY_ZONE)
		{
			DBGPRINT(DBG_COMP_ZIP, DBG_LEVEL_INFO,
					("atalkZipZoneInfoTimer: Completing GetMyZone\n"));

			TdiCopyBufferToMdl("*",
								0,
								sizeof("*"),
								pZci->zci_pAMdl,
								0,
								&BytesCopied);
		}
		else	// GET_ZONE_LIST
		{
			DBGPRINT(DBG_COMP_ZIP, DBG_LEVEL_INFO,
					("atalkZipZoneInfoTimer: Completing GetZoneList\n"));

			if ((pZci->zci_ZoneCount == 0) &&
				 ((SHORT)(pZci->zci_NextZoneOff + sizeof("*")) < pZci->zci_BufLen))
			{
				pZci->zci_ZoneCount++;
				TdiCopyBufferToMdl("*",
									0,
									sizeof("*"),
									pZci->zci_pAMdl,
									pZci->zci_NextZoneOff,
									&BytesCopied);
				ASSERT (BytesCopied == sizeof("*"));
			}
            ((PZIP_GETZONELIST_PARAMS)
				(pZci->zci_pActReq->ar_pParms))->ZonesAvailable =
														pZci->zci_ZoneCount;
		}

		RELEASE_SPIN_LOCK_DPC(&pZci->zci_Lock);
		atalkZipDereferenceZci(pZci);	// Timer reference

		pZci->zci_FinalStatus = ATALK_NO_ERROR;
		atalkZipDereferenceZci(pZci);
		ASSERT(!RestartTimer);

	} while (FALSE);

	return (RestartTimer ? ATALK_TIMER_REQUEUE : ATALK_TIMER_NO_REQUEUE);
}


/***	atalkZipSendPacket
 *
 */
ATALK_ERROR
atalkZipSendPacket(
	IN	PZIPCOMPLETIONINFO	pZci,
	IN	BOOLEAN				EnqueueTimer
)
{
	PBUFFER_DESC	pBuffDesc;
	ATALK_ERROR		Status;
	ATALK_ADDR		DestAddr;
	PBYTE			Datagram;
	SEND_COMPL_INFO	SendInfo;

	ASSERT (VALID_ZCI(pZci));

	if (pZci->zci_pDdpAddr == NULL)
	{
		DBGPRINT(DBG_COMP_ZIP, DBG_LEVEL_INFO,
				("atalkZipSendPacket: Opening Ddp Socket\n"));

		// Open a socket for handling replies
		Status = AtalkDdpOpenAddress(pZci->zci_pPortDesc,
										UNKNOWN_SOCKET,
										NULL,
										pZci->zci_Handler,
										pZci,
										0,
										NULL,
										&pZci->zci_pDdpAddr);
	
		if (!ATALK_SUCCESS(Status))
		{
			DBGPRINT(DBG_COMP_ZIP, DBG_LEVEL_ERR,
					("atalkZipSendPacket: AtalkDdpOpenAddress %ld\n", Status));
			return Status;
		}

        // mark the fact that this is an "internal" socket
        pZci->zci_pDdpAddr->ddpao_Flags |= DDPAO_SOCK_INTERNAL;

	}

	ASSERT (VALID_DDP_ADDROBJ(pZci->zci_pDdpAddr));

	// Alloc a buffer desciptor for the atp request
	if ((pBuffDesc = AtalkAllocBuffDesc(pZci->zci_Datagram,
										ZIP_GETZONELIST_DDPSIZE,
										BD_CHAR_BUFFER)) == NULL)
	{
		DBGPRINT(DBG_COMP_ZIP, DBG_LEVEL_ERR,
				("atalkZipSendPacket: Couldn't allocate a buffdesc\n"));
		AtalkDdpCloseAddress(pZci->zci_pDdpAddr, NULL, NULL);
		return ATALK_RESR_MEM;
	}

	// Start the zone info timer
	if (EnqueueTimer)
	{
		KIRQL	OldIrql;

		ACQUIRE_SPIN_LOCK(&pZci->zci_Lock, &OldIrql);
		pZci->zci_RefCount ++;			// For the timer
		AtalkTimerScheduleEvent(&pZci->zci_Timer);
		RELEASE_SPIN_LOCK(&pZci->zci_Lock, OldIrql);
	}

	// Build the Atp request and send it along
	Datagram = pBuffDesc->bd_CharBuffer;
	Datagram[ATP_CMD_CONTROL_OFF] = ATP_REQUEST;
	Datagram[ATP_BITMAP_OFF] = 1;
	Datagram[ATP_TRANS_ID_OFF] =  0;
	Datagram[ATP_TRANS_ID_OFF+1] =  0;
	Datagram[ATP_ZIP_CMD_OFF] = (BYTE)pZci->zci_AtpRequestType;
	Datagram[ATP_ZIP_CMD_OFF+1] = 0;

	PUTSHORT2SHORT(Datagram + ATP_ZIP_START_INDEX_OFF, pZci->zci_ZoneCount+1);

	//	Set the length in the buffer descriptor.
	AtalkSetSizeOfBuffDescData(pBuffDesc, ZIP_GETZONELIST_DDPSIZE);

	DBGPRINT(DBG_COMP_ZIP, DBG_LEVEL_INFO,
			("atalkZipSendPacket: Sending the packet along\n"));

	DestAddr = pZci->zci_Router;
	SendInfo.sc_TransmitCompletion = atalkZipSendComplete;
	SendInfo.sc_Ctx1 = pBuffDesc;
	// SendInfo.sc_Ctx2 = NULL;
	// SendInfo.sc_Ctx3 = NULL;
	if (!ATALK_SUCCESS(Status = AtalkDdpSend(pZci->zci_pDdpAddr,
											&DestAddr,
											DDPPROTO_ATP,
											FALSE,
											pBuffDesc,
											NULL,
											0,
											NULL,
											&SendInfo)))
	{
		DBGPRINT(DBG_COMP_ZIP, DBG_LEVEL_ERR,
				("atalkZipSendPacket: AtalkDdpSend %ld\n", Status));

		AtalkFreeBuffDesc(pBuffDesc);
		if (AtalkTimerCancelEvent(&pZci->zci_Timer, NULL))
		{
			atalkZipDereferenceZci(pZci);
		}
	}
	else Status = ATALK_PENDING;
	return Status;
}


/***	atalkZipDereferenceZci
 *
 */
LOCAL VOID
atalkZipDereferenceZci(
	IN	PZIPCOMPLETIONINFO		pZci
)
{
	BOOLEAN	Done;
	KIRQL	OldIrql;

	ASSERT(VALID_ZCI(pZci));

	ACQUIRE_SPIN_LOCK(&pZci->zci_Lock, &OldIrql);
	Done  = (--(pZci->zci_RefCount) == 0);
	RELEASE_SPIN_LOCK(&pZci->zci_Lock, OldIrql);

	if (Done)
	{
		if (pZci->zci_pDdpAddr != NULL)
			AtalkDdpCloseAddress(pZci->zci_pDdpAddr, NULL, NULL);
		(*pZci->zci_pActReq->ar_Completion)(pZci->zci_FinalStatus, pZci->zci_pActReq);

		// Unlock the Zip stuff back again, if there are no more pending zip operations
		AtalkUnlockZipIfNecessary();
		AtalkFreeMemory(pZci);
	}
}


// We do not want to send too many queries per invocation of the timer. This is to avoid
// spending too much time within the timer Dpc and also using up all of the Ndis packets
// and buffers during this.
#define	MAX_QUERIES_PER_INVOCATION	75

// Structure used by the atalkZipQueryTimer routine
typedef struct	_QueryTimerData
{
	struct	_QueryTimerData *	qtd_Next;
	BOOLEAN						qtd_SkipThis;
	PBUFFER_DESC				qtd_pBuffDesc;
	ATALK_ADDR					qtd_DstAddr;
	PDDP_ADDROBJ				qtd_pDdpAddr;
} QTD, *PQTD;

/***	atalkZipQueryTimer
 *
 *	When we are a router and if any of our RTEs do not have a valid zone list, we send
 *	out queries to other routers who do.
 */
LOCAL LONG FASTCALL
atalkZipQueryTimer(
	IN	PTIMERLIST		pContext,
	IN	BOOLEAN			TimerShuttingDown
)
{
	PPORT_DESCRIPTOR	pPortDesc;
	ATALK_ADDR			SrcAddr;
	PRTE				pRte;
	PBYTE				Datagram;
	PQTD				pQtd, pQtdStart = NULL, *ppQtd = &pQtdStart;
	ATALK_ERROR			Status;
	int					i, j;
	SEND_COMPL_INFO		SendInfo;

	if (TimerShuttingDown)
		return ATALK_TIMER_NO_REQUEUE;

	// Go through the routing tables and send out a query to any network
	// that we do not know the zone name of
	ACQUIRE_SPIN_LOCK_DPC(&AtalkRteLock)
	for (i = 0, j = 0;
		 (i < NUM_RTMP_HASH_BUCKETS) && (j <= MAX_QUERIES_PER_INVOCATION);
		 i++)
	{
		for (pRte = AtalkRoutingTable[i]; pRte != NULL; pRte = pRte->rte_Next)
		{
			if (pRte->rte_Flags & RTE_ZONELIST_VALID)
            {
				continue;
            }

            // If login is to restrict access to zones over dial up connection
            // put restrictions here
            if (pRte->rte_PortDesc == RasPortDesc)
            {
                continue;
            }

			// Up the count of # of datagrams used. Do need exceed max.
			if (++j >= MAX_QUERIES_PER_INVOCATION)
				break;

			if (((pQtd = AtalkAllocMemory(sizeof(QTD))) == NULL) ||
				((pQtd->qtd_pBuffDesc = AtalkAllocBuffDesc(NULL,
									ZIP_ONEZONEQUERY_DDPSIZE,
									BD_CHAR_BUFFER | BD_FREE_BUFFER)) == NULL))
			{
				if (pQtd != NULL)
					AtalkFreeMemory(pQtd);
				break;
			}
			*ppQtd = pQtd;
			pQtd->qtd_Next = NULL;
			ppQtd = &pQtd->qtd_Next;
			pQtd->qtd_SkipThis = FALSE;
			Datagram = pQtd->qtd_pBuffDesc->bd_CharBuffer;

			// Build the datagram and send it on its way
			Datagram[ZIP_CMD_OFF] = ZIP_QUERY;
			Datagram[ZIP_NW_CNT_OFF] = 1;
			PUTSHORT2SHORT(Datagram+ZIP_FIRST_NET_OFF,
						   pRte->rte_NwRange.anr_FirstNetwork);

			// Compute the source and destination
			SrcAddr.ata_Network = pRte->rte_PortDesc->pd_ARouter.atn_Network;
			SrcAddr.ata_Node = pRte->rte_PortDesc->pd_ARouter.atn_Node;
			SrcAddr.ata_Socket = ZONESINFORMATION_SOCKET;
			pQtd->qtd_DstAddr.ata_Socket = ZONESINFORMATION_SOCKET;

			if (pRte->rte_NumHops == 0)
			{
				pQtd->qtd_DstAddr = SrcAddr;
			}
			else
			{
				pQtd->qtd_DstAddr.ata_Network = pRte->rte_NextRouter.atn_Network;
				pQtd->qtd_DstAddr.ata_Node = pRte->rte_NextRouter.atn_Node;
			}

			// Map source address to the ddp address object (open socket)
			AtalkDdpReferenceByAddr(pRte->rte_PortDesc,
									&SrcAddr,
									&pQtd->qtd_pDdpAddr,
									&Status);

			if (!ATALK_SUCCESS(Status))
			{
				DBGPRINT(DBG_COMP_ZIP, DBG_LEVEL_ERR,
						("atalkZipQueryTimer: DdpRefByAddr failed for %d.%d\n",
						SrcAddr.ata_Network, SrcAddr.ata_Node));
				pQtd->qtd_pDdpAddr = NULL;
				pQtd->qtd_SkipThis = TRUE;
			}
		}
	}
	RELEASE_SPIN_LOCK_DPC(&AtalkRteLock);

	// We have a bunch of datagrams ready to be fired off.
	// Make it so.
	SendInfo.sc_TransmitCompletion = atalkZipSendComplete;
	// SendInfo.sc_Ctx2 = NULL;
	// SendInfo.sc_Ctx3 = NULL;
	for (pQtd = pQtdStart; pQtd != NULL; pQtd = pQtdStart)
	{
		pQtdStart = pQtd->qtd_Next;
	
		//	Set the length in the buffer descriptor.
        AtalkSetSizeOfBuffDescData(pQtd->qtd_pBuffDesc, ZIP_ONEZONEQUERY_DDPSIZE);

		SendInfo.sc_Ctx1 = pQtd->qtd_pBuffDesc;
		if (pQtd->qtd_SkipThis ||
			!ATALK_SUCCESS(AtalkDdpSend(pQtd->qtd_pDdpAddr,
										&pQtd->qtd_DstAddr,
										DDPPROTO_ZIP,
										FALSE,
										pQtd->qtd_pBuffDesc,
										NULL,
										0,
										NULL,
										&SendInfo)))
		{
			AtalkFreeBuffDesc(pQtd->qtd_pBuffDesc);
		}

		if (pQtd->qtd_pDdpAddr != NULL)
			AtalkDdpDereferenceDpc(pQtd->qtd_pDdpAddr);
		AtalkFreeMemory(pQtd);
	}

	return ATALK_TIMER_REQUEUE;
}


/***	atalkZipGetZoneListForPort
 *
 */
LOCAL BOOLEAN
atalkZipGetZoneListForPort(
	IN	PPORT_DESCRIPTOR	pPortDesc
)
{
	PRTE					pRte;
	PBUFFER_DESC			pBuffDesc = NULL;
	ATALK_ADDR				SrcAddr, DstAddr;
	ATALK_ERROR				Status;
	KIRQL					OldIrql;
	int						NumReqs = 0;
	BOOLEAN					RetCode = FALSE;
	BYTE					MulticastAddr[ELAP_ADDR_LEN];
	SEND_COMPL_INFO			SendInfo;

	ASSERT (KeGetCurrentIrql() == LOW_LEVEL);

	// Similar to RTMP finding out the network number attached to port, our
	// task is to find out the zone list of the network attached to a
	// particular port.  We too don't want to mess up a working AppleTalk
	// internet.  So, spend a little while doing zone queries to see if the
	// network already has a zone list -- if we find one, use it; else, we
	// had better be a seed router.

	// Set source and destination address
	SrcAddr.ata_Node = pPortDesc->pd_ARouter.atn_Node;
	SrcAddr.ata_Network = pPortDesc->pd_ARouter.atn_Network;
	SrcAddr.ata_Socket = ZONESINFORMATION_SOCKET;

	DstAddr.ata_Network = CABLEWIDE_BROADCAST_NETWORK;
	DstAddr.ata_Node = ATALK_BROADCAST_NODE;
	DstAddr.ata_Socket = ZONESINFORMATION_SOCKET;

	if ((pRte = AtalkRtmpReferenceRte(pPortDesc->pd_NetworkRange.anr_FirstNetwork)) == NULL)
	{
		DBGPRINT(DBG_COMP_ZIP, DBG_LEVEL_ERR,
				("atalkZipGetZoneListForPort: Could not reference Rte for nwrange on port\n"));
		return FALSE;
	}

	// Blast a few queries and see if anybody knows our zone-name
	ACQUIRE_SPIN_LOCK(&pPortDesc->pd_Lock, &OldIrql);
	pPortDesc->pd_Flags |= PD_FINDING_DEFAULT_ZONE;
	RELEASE_SPIN_LOCK(&pPortDesc->pd_Lock, OldIrql);

	SendInfo.sc_TransmitCompletion = atalkZipSendComplete;
	// SendInfo.sc_Ctx2 = NULL;
	// SendInfo.sc_Ctx3 = NULL;

	while ((NumReqs < (ZIP_NUM_QUERIES * ZIP_NUM_RETRIES)) &&
		   !(pRte->rte_Flags & RTE_ZONELIST_VALID))
	{
		if ((NumReqs % ZIP_NUM_RETRIES) == 0)
		{
			if ((pBuffDesc = AtalkAllocBuffDesc(NULL, ZIP_ONEZONEQUERY_DDPSIZE,
										BD_CHAR_BUFFER | BD_FREE_BUFFER)) == NULL)
			{
				break;
			}
	
			pBuffDesc->bd_CharBuffer[ZIP_CMD_OFF] = ZIP_QUERY;
			pBuffDesc->bd_CharBuffer[ZIP_NW_CNT_OFF] = 1;
			PUTSHORT2SHORT(pBuffDesc->bd_CharBuffer + ZIP_FIRST_NET_OFF,
						   pPortDesc->pd_NetworkRange.anr_FirstNetwork);
	
			//	Set the length in the buffer descriptor.
			AtalkSetSizeOfBuffDescData(pBuffDesc, ZIP_ONEZONEQUERY_DDPSIZE);

			SendInfo.sc_Ctx1 = pBuffDesc;
			Status = AtalkDdpTransmit(pPortDesc,
									  &SrcAddr,
									  &DstAddr,
									  DDPPROTO_ZIP,
									  pBuffDesc,
									  NULL,
									  0,
									  0,
									  NULL,
									  NULL,
									  &SendInfo);
            if (!ATALK_SUCCESS(Status))
			{
				DBGPRINT(DBG_COMP_ZIP, DBG_LEVEL_ERR,
						("atalkZipGetZoneListForPort: AtalkDdpTransmit %ld\n", Status));
				break;
			}
			pBuffDesc = NULL;
		}
		NumReqs++;
		AtalkSleep(ZIP_QUERY_WAIT);
	}

	// We either got an answer or we did not. In the latter case we should
	// be seeding.
	do
	{
		if (pRte->rte_Flags &  RTE_ZONELIST_VALID)
		{
			// We got an answer. The valid zone list is in the routing table
			// Move it to the port descriptor
			ACQUIRE_SPIN_LOCK(&pPortDesc->pd_Lock, &OldIrql);
			ACQUIRE_SPIN_LOCK_DPC(&pRte->rte_Lock);
	
			DBGPRINT(DBG_COMP_ZIP, DBG_LEVEL_INFO,
					("atalkZipGetZoneListForPort: Moving ZoneList from Rte to Port %Z\n",
					&pPortDesc->pd_AdapterKey));

			pPortDesc->pd_ZoneList = AtalkZoneCopyList(pRte->rte_ZoneList);

			RELEASE_SPIN_LOCK_DPC(&pRte->rte_Lock);
			RELEASE_SPIN_LOCK(&pPortDesc->pd_Lock, OldIrql);
			if (pPortDesc->pd_ZoneList == NULL)
			{
				DBGPRINT(DBG_COMP_ZIP, DBG_LEVEL_INFO,
						("atalkZipGetZoneListForPort: Failed to Move ZoneList from Rte to Port\n"));
				break;
			}

			// If this is an extended network, we should already have "ThisZone"
			// set (due to GetNetInfo's when we allocated this node), if not
			// find out the true default zone

			if (EXT_NET(pPortDesc))
			{
				PDDP_ADDROBJ	pDdpAddr = NULL;
				ATALK_ADDR		Addr;
				ATALK_ERROR		Status;

				// The router's Zip packet handler doesn't want to be told
				// about zones (it thinks it knows), so it ignores
				// NetInfoReplies. Switch back to the non-router Zip handler
				// while we do a GetNetworkInfoForNode
				Addr.ata_Node = pPortDesc->pd_ARouter.atn_Node;
				Addr.ata_Network = pPortDesc->pd_ARouter.atn_Network;
				Addr.ata_Socket = ZONESINFORMATION_SOCKET;
				AtalkDdpReferenceByAddr(pPortDesc, &Addr, &pDdpAddr, &Status);

				if (!ATALK_SUCCESS(Status))
				{
					DBGPRINT(DBG_COMP_RTMP, DBG_LEVEL_ERR,
							("atalkZipGetZoneListForPort: AtalkDdpRefByAddr %ld for %d.%d\n",
							Status, Addr.ata_Network, Addr.ata_Node));
					break;
				}

				AtalkDdpNewHandlerForSocket(pDdpAddr,
											AtalkZipPacketIn,
											pPortDesc);
				if ((!(pPortDesc->pd_Flags & PD_VALID_DESIRED_ZONE) &&
					 !AtalkZipGetNetworkInfoForNode(pPortDesc,
												   &pPortDesc->pd_ARouter,
												   FALSE)) ||
					!AtalkZipGetNetworkInfoForNode(pPortDesc,
												   &pPortDesc->pd_ARouter,
												   TRUE))
				{
					AtalkDdpDereference(pDdpAddr);
					break;
				}

				// Switch back the handler to the router's version
				AtalkDdpNewHandlerForSocket(pDdpAddr,
											AtalkZipPacketInRouter,
											pPortDesc);

				AtalkDdpDereference(pDdpAddr);

				// The default zone had better be on the list we just
				// received
				ACQUIRE_SPIN_LOCK(&pPortDesc->pd_Lock, &OldIrql);
				if (!AtalkZoneOnList(pPortDesc->pd_DefaultZone,
									 pPortDesc->pd_ZoneList) ||
					!AtalkZoneOnList(pPortDesc->pd_DesiredZone,
									 pPortDesc->pd_ZoneList))
				{
					DBGPRINT(DBG_COMP_ZIP, DBG_LEVEL_ERR,
							("atalkZipGetZoneListForPort: Ext port, Default/Desired zone not on list\n"));

				}
				else RetCode = TRUE;
				RELEASE_SPIN_LOCK(&pPortDesc->pd_Lock, OldIrql);
			}
			else
			{
				// On non-extended network, the one entry on the zone list
				// should also be "ThisZone"
				ACQUIRE_SPIN_LOCK(&pPortDesc->pd_Lock, &OldIrql);
				if (pPortDesc->pd_DesiredZone != NULL)
					AtalkZoneDereference(pPortDesc->pd_DesiredZone);
				AtalkZoneReferenceByPtr(pPortDesc->pd_DesiredZone =
										pPortDesc->pd_ZoneList->zl_pZone);
				RELEASE_SPIN_LOCK(&pPortDesc->pd_Lock, OldIrql);
                RetCode = TRUE;
			}
			break;
		}

		// We did not get an answer. We had better be able to seed. There is
		// a chance that we got "ThisZone" set when allocating our node and
		// whatever router told us that went down before we could ask for the
		// zone list - so de-allocate the multicast address, if any first
		if ((pPortDesc->pd_Flags & (PD_EXT_NET | PD_VALID_DESIRED_ZONE)) ==
										(PD_EXT_NET | PD_VALID_DESIRED_ZONE))
		{
			if (!AtalkFixedCompareCaseSensitive(pPortDesc->pd_ZoneMulticastAddr,
												pPortDesc->pd_BroadcastAddrLen,
                                                pPortDesc->pd_BroadcastAddr,
												pPortDesc->pd_BroadcastAddrLen))
				(*pPortDesc->pd_RemoveMulticastAddr)(pPortDesc,
														pPortDesc->pd_ZoneMulticastAddr,
														FALSE,
														NULL,
														NULL);
		}

		// Now we better know enough to seed
		if (pPortDesc->pd_InitialZoneList == NULL)
		{
			DBGPRINT(DBG_COMP_ZIP, DBG_LEVEL_ERR,
					("atalkZipGetZoneListForPort: %sExt port, NULL InitialZoneList\n",
					EXT_NET(pPortDesc) ? "" : "Non"));
			break;
		}

		ACQUIRE_SPIN_LOCK(&pPortDesc->pd_Lock, &OldIrql);
		DBGPRINT(DBG_COMP_ZIP, DBG_LEVEL_INFO,
				("atalkZipGetZoneListForPort: Moving Initial ZoneList to Current on port %Z\n",
				&pPortDesc->pd_AdapterKey));

		pPortDesc->pd_ZoneList = AtalkZoneCopyList(pPortDesc->pd_InitialZoneList);

		if (EXT_NET(pPortDesc))
		{
			// We need to seed the default zone too
			AtalkZoneReferenceByPtr(pPortDesc->pd_DefaultZone =
											pPortDesc->pd_InitialDefaultZone);
			pPortDesc->pd_Flags |= PD_VALID_DEFAULT_ZONE;
			if (pPortDesc->pd_InitialDesiredZone != NULL)
			{
				AtalkZoneReferenceByPtr(pPortDesc->pd_DesiredZone =
											pPortDesc->pd_InitialDesiredZone);
			}
			else
			{
				AtalkZoneReferenceByPtr(pPortDesc->pd_DesiredZone =
										pPortDesc->pd_InitialDefaultZone);
			}

			// Finally set the zone multicast address
			AtalkZipMulticastAddrForZone(pPortDesc,
										pPortDesc->pd_DesiredZone->zn_Zone,
										pPortDesc->pd_DesiredZone->zn_ZoneLen,
										MulticastAddr);

			if (!AtalkFixedCompareCaseSensitive(MulticastAddr,
												pPortDesc->pd_BroadcastAddrLen,
                                                pPortDesc->pd_BroadcastAddr,
												pPortDesc->pd_BroadcastAddrLen))
			{
				RELEASE_SPIN_LOCK(&pPortDesc->pd_Lock, OldIrql);
				(*pPortDesc->pd_AddMulticastAddr)(pPortDesc,
													 MulticastAddr,
													 FALSE,
													 NULL,
													 NULL);
				ACQUIRE_SPIN_LOCK(&pPortDesc->pd_Lock, &OldIrql);
			}
			RtlCopyMemory(pPortDesc->pd_ZoneMulticastAddr,
						  MulticastAddr,
						  pPortDesc->pd_BroadcastAddrLen);
		}
		else
		{
			// On non-extended networks, this (desired/default)should be the
			// only one on zone-list
			AtalkZoneReferenceByPtr(pPortDesc->pd_DesiredZone =
									pPortDesc->pd_ZoneList->zl_pZone);
		}
		pPortDesc->pd_Flags |= PD_VALID_DESIRED_ZONE;
		RELEASE_SPIN_LOCK(&pPortDesc->pd_Lock, OldIrql);
		RetCode = TRUE;
	} while (FALSE);

	AtalkRtmpDereferenceRte(pRte, FALSE);
	if (pBuffDesc != NULL)
	{
		AtalkFreeBuffDesc(pBuffDesc);
	}
	return(RetCode);
}




/***	AtalkZipZoneReferenceByName
 *
 */
PZONE
AtalkZoneReferenceByName(
	IN	PBYTE	ZoneName,
	IN	BYTE	ZoneLen
)
{
	PZONE	pZone;
	BYTE	Len;
	KIRQL	OldIrql;
	ULONG	i, Hash;

	for (i = 0, Hash = 0, Len = ZoneLen;
		 Len > 0;
		 Len --, i++)
	{
		Hash <<= 1;
		Hash += AtalkUpCaseTable[ZoneName[i]];
	}

	Hash %= NUM_ZONES_HASH_BUCKETS;

	ACQUIRE_SPIN_LOCK(&AtalkZoneLock, &OldIrql);

	for (pZone = AtalkZonesTable[Hash];
		 pZone != NULL;
		 pZone = pZone->zn_Next)
	{
		if (AtalkFixedCompareCaseInsensitive(ZoneName,
											 ZoneLen,
											 pZone->zn_Zone,
											 pZone->zn_ZoneLen))
		{
			pZone->zn_RefCount ++;
			break;
		}
	}

	if (pZone == NULL)
	{
		if ((pZone = (PZONE)AtalkAllocMemory(sizeof(ZONE) + ZoneLen)) != NULL)
		{
			pZone->zn_RefCount = 1;
			pZone->zn_ZoneLen = ZoneLen;
			RtlCopyMemory(pZone->zn_Zone, ZoneName, ZoneLen);
			pZone->zn_Zone[ZoneLen] = 0;
			AtalkLinkDoubleAtHead(AtalkZonesTable[Hash],
								  pZone,
								  zn_Next,
								  zn_Prev);
		}
	}

	RELEASE_SPIN_LOCK(&AtalkZoneLock, OldIrql);
	return(pZone);
}


/***	AtalkZipZoneReferenceByPtr
 *
 */
VOID
AtalkZoneReferenceByPtr(
	IN	PZONE	pZone
)
{
	KIRQL	OldIrql;

	ACQUIRE_SPIN_LOCK(&AtalkZoneLock, &OldIrql);

	pZone->zn_RefCount++;

	RELEASE_SPIN_LOCK(&AtalkZoneLock, OldIrql);
}


/***	AtalkZoneDereference
 *
 */
VOID
AtalkZoneDereference(
	IN	PZONE	pZone
)
{
	KIRQL	OldIrql;

	ACQUIRE_SPIN_LOCK(&AtalkZoneLock, &OldIrql);

	if (--pZone->zn_RefCount == 0)
	{
		AtalkUnlinkDouble(pZone, zn_Next, zn_Prev);
		AtalkFreeMemory(pZone);
	}

	RELEASE_SPIN_LOCK(&AtalkZoneLock, OldIrql);
}


/***	AtalkZipZoneFreeList
 *
 */
VOID
AtalkZoneFreeList(
	IN	PZONE_LIST	pZoneList
)
{
	PZONE_LIST	pNextZone;

	for (; pZoneList != NULL; pZoneList = pNextZone)
	{
		pNextZone = pZoneList->zl_Next;
		AtalkZoneDereference(pZoneList->zl_pZone);
		AtalkFreeMemory(pZoneList);
	}
}


/***	AtalkZoneNameOnList
 *
 */
BOOLEAN
AtalkZoneNameOnList(
	IN	PBYTE		ZoneName,
	IN	BYTE		ZoneLen,
	IN	PZONE_LIST	pZoneList
)
{
	 for ( ; pZoneList != NULL; pZoneList = pZoneList->zl_Next)
		if (AtalkFixedCompareCaseInsensitive(pZoneList->zl_pZone->zn_Zone,
											 pZoneList->zl_pZone->zn_ZoneLen,
											 ZoneName, ZoneLen))
			return(TRUE);

	return(FALSE);
}

/***	AtalkZipZoneOnList
 *
 */
BOOLEAN
AtalkZoneOnList(
	IN	PZONE		pZone,
	IN	PZONE_LIST	pZoneList
)
{
	 for ( ; pZoneList != NULL; pZoneList = pZoneList->zl_Next)
		if (pZoneList->zl_pZone == pZone)
			return(TRUE);

	return(FALSE);
}

/***	AtalkZipZone
 *
 */
ULONG
AtalkZoneNumOnList(
	IN	PZONE_LIST	pZoneList
)
{
	ULONG	Cnt;

	for (Cnt = 0; pZoneList != NULL; pZoneList = pZoneList->zl_Next)
		Cnt++;
	return Cnt;
}


/***	AtalkZipZoneAddToList
 *
 */
PZONE_LIST
AtalkZoneAddToList(
	IN	PZONE_LIST	pZoneList,
	IN	PBYTE		ZoneName,
	IN	BYTE		ZoneLen
)
{
	PZONE_LIST		pNewZoneList;
	PZONE			pZone;

	// Get memory for a new ZoneList node.
	pNewZoneList = (PZONE_LIST)AtalkAllocMemory(sizeof(ZONE_LIST));

	if (pNewZoneList != NULL)
	{
		if ((pZone = AtalkZoneReferenceByName(ZoneName, ZoneLen)) != NULL)
		{
		    pNewZoneList->zl_Next = pZoneList;
			pNewZoneList->zl_pZone = pZone;
		}
		else
		{
			AtalkZoneFreeList(pNewZoneList);
			pNewZoneList = NULL;
		}
	}
	else
	{
		AtalkZoneFreeList(pZoneList);
	}

	return(pNewZoneList);
}


/***	AtalkZipZoneCopyList
 *
 */
PZONE_LIST
AtalkZoneCopyList(
	IN	PZONE_LIST	pZoneList
)
{
	PZONE_LIST	pNewZoneList,
				pZoneListStart = NULL,
				*ppZoneList = &pZoneListStart;

	for (; pZoneList != NULL; pZoneList = pZoneList = pZoneList->zl_Next)
	{
		pNewZoneList = AtalkAllocMemory(sizeof(ZONE_LIST));
		if (pNewZoneList == NULL)
		{
			break;
		}
		pNewZoneList->zl_Next = NULL;
		pNewZoneList->zl_pZone = pZoneList->zl_pZone;
		*ppZoneList = pNewZoneList;
		ppZoneList = &pNewZoneList->zl_Next;
		AtalkZoneReferenceByPtr(pNewZoneList->zl_pZone);
	}
	if (pNewZoneList == NULL)
	{
		AtalkZoneFreeList(pZoneListStart);
	}
	return(pZoneListStart);
}


/***	atalkZipSendComplete
 *
 */
VOID FASTCALL
atalkZipSendComplete(
	IN	NDIS_STATUS			Status,
	IN	PSEND_COMPL_INFO	pSendInfo
)
{
	PBUFFER_DESC	pBuffDesc = (PBUFFER_DESC)(pSendInfo->sc_Ctx1);

	DBGPRINT(DBG_COMP_ZIP, DBG_LEVEL_INFO,
			("atalkZipSendComplete: Freeing BuffDesc %lx\n", pBuffDesc));
	if (!ATALK_SUCCESS(Status))
		DBGPRINT(DBG_COMP_ZIP, DBG_LEVEL_ERR,
				("atalkZipSendComplete: Failed %lx, pBuffDesc %lx\n",
				Status, pBuffDesc));

	AtalkFreeBuffDesc(pBuffDesc);
}

#if DBG
VOID
AtalkZoneDumpTable(
	VOID
)
{
	int		i;
	PZONE	pZone;

	ACQUIRE_SPIN_LOCK_DPC(&AtalkZoneLock);

	DBGPRINT(DBG_COMP_DUMP, DBG_LEVEL_FATAL, ("ZONETABLE: \n"));
	for (i = 0; i < NUM_ZONES_HASH_BUCKETS; i ++)
	{
		for (pZone = AtalkZonesTable[i]; pZone != NULL; pZone = pZone->zn_Next)
		{
			DBGPRINT(DBG_COMP_DUMP, DBG_LEVEL_FATAL,
					("\t\t%s\n", pZone->zn_Zone));
		}
	}

	RELEASE_SPIN_LOCK_DPC(&AtalkZoneLock);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\atalk\winsock\wshatalk.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

	wshatalk.h

Abstract:


Author:

	Nikhil Kamkolkar (nikhilk@microsoft.com)

Revision History:
	10 Jul 1992	 Initial Version

--*/

#include	"atalktdi.h"
#include	"atalkwsh.h"		// winsock header file for appletalk

#define WSH_ATALK_ADSPSTREAM	L"\\Device\\AtalkAdsp\\Stream"
#define WSH_ATALK_ADSPRDM		L"\\Device\\AtalkAdsp"
#define WSH_ATALK_PAPRDM		L"\\Device\\AtalkPap"

#define WSH_KEYPATH_CODEPAGE  \
		TEXT("SYSTEM\\CurrentControlSet\\Control\\Nls\\Codepage")

#define	WSHREG_VALNAME_CODEPAGE  			TEXT("MACCP")

//
// Device names for DDP need protocol field at the end - defined in wshdata.h
//

//
// Structure and variables to define the triples supported by Appletalk. The
// first entry of each array is considered the canonical triple for
// that socket type; the other entries are synonyms for the first.
//

typedef struct _MAPPING_TRIPLE {
	INT AddressFamily;
	INT SocketType;
	INT Protocol;
} MAPPING_TRIPLE, *PMAPPING_TRIPLE;


//
// The socket context structure for this DLL. Each open Appletalk socket
// will have one of these context structures, which is used to maintain
// information about the socket.
//

typedef struct _WSHATALK_SOCKET_CONTEXT
{
	INT		AddressFamily;
	INT		SocketType;
	INT		Protocol;
} WSHATALK_SOCKET_CONTEXT, *PWSHATALK_SOCKET_CONTEXT;




//
// Forward declarations of internal routines.
//

BOOL FAR PASCAL
WshDllInitialize(
	HINSTANCE 	hInstance,
    DWORD  		nReason,
    LPVOID 		pReserved);

BOOLEAN
WshRegGetCodePage(
	VOID);

BOOLEAN
WshNbpNameToMacCodePage(
	IN	OUT	PWSH_NBP_NAME	pNbpName);

BOOLEAN
WshNbpNameToOemCodePage(
	IN	OUT	PWSH_NBP_NAME	pNbpName);

BOOLEAN
WshZoneListToOemCodePage(
	IN	OUT	PUCHAR		pZoneList,
	IN		USHORT		NumZones);

BOOLEAN
WshConvertStringMacToOem(
	IN	PUCHAR	pSrcMacString,
	IN	USHORT	SrcStringLen,
	OUT	PUCHAR	pDestOemString,
	IN	PUSHORT	pDestStringLen);

BOOLEAN
WshConvertStringOemToMac(
	IN	PUCHAR	pSrcOemString,
	IN	USHORT	SrcStringLen,
	OUT	PUCHAR	pDestMacString,
	IN	PUSHORT	pDestStringLen);

INT
WSHNtStatusToWinsockErr(
	IN	NTSTATUS	Status);

BOOLEAN
IsTripleInList (
	IN PMAPPING_TRIPLE	List,
	IN ULONG			ListLength,
	IN INT				AddressFamily,
	IN INT				SocketType,
	IN INT				Protocol);

VOID
CompleteTdiActionApc (
    IN PVOID ApcContext,
    IN PIO_STATUS_BLOCK IoStatusBlock);

//
// Macros
//


#if DBG
#define DBGPRINT(Fmt)											\
        {														\
			DbgPrint("WSHATALK: ");								\
			DbgPrint Fmt;										\
		}

#define DBGBRK()               									\
		{														\
				DbgBreakPoint();								\
		}
#else

#define DBGPRINT(Fmt)
#define DBGBRK()

#endif

#define	SOCK_TO_TDI_ATALKADDR(tdiAddr, sockAddr)								\
		{																		\
			(tdiAddr)->TAAddressCount	= 1;										\
			(tdiAddr)->Address[0].AddressLength = sizeof(TDI_ADDRESS_APPLETALK);	\
			(tdiAddr)->Address[0].AddressType = TDI_ADDRESS_TYPE_APPLETALK;		\
			(tdiAddr)->Address[0].Address[0].Network = (sockAddr)->sat_net;			\
			(tdiAddr)->Address[0].Address[0].Node = (sockAddr)->sat_node;			\
			(tdiAddr)->Address[0].Address[0].Socket = (sockAddr)->sat_socket;		\
		}


#define	TDI_TO_SOCK_ATALKADDR(sockAddr, tdiAddr)				\
		{																		\
			(sockAddr)->sat_family	= AF_APPLETALK;								\
			(sockAddr)->sat_net		= (tdiAddr)->Address[0].Address[0].Network;	\
			(sockAddr)->sat_node	= (tdiAddr)->Address[0].Address[0].Node;	\
			(sockAddr)->sat_socket	= (tdiAddr)->Address[0].Address[0].Socket;	\
		}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\inc\atalktdi.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

	atalktdi.h

Abstract:

	This file defines the interface that will be offered to the layers of the
	stack

Author:

	Nikhil Kamkolkar (NikhilK)	8-Jun-1992

Revision History:

--*/

#ifndef	_ATALKTDI_H
#define	_ATALKTDI_H

//
// The provider names supported by the Appletalk stack
//

#define ATALKDDP_DEVICENAME		L"\\Device\\AtalkDdp"
#define ATALKADSP_DEVICENAME	L"\\Device\\AtalkAdsp"
#define ATALKASPS_DEVICENAME	L"\\Device\\AtalkAspServer"
#define ATALKASPC_DEVICENAME	L"\\Device\\AtalkAspClient"
#define ATALKPAP_DEVICENAME		L"\\Device\\AtalkPap"
#define ATALKARAP_DEVICENAME	L"\\Device\\AtalkArap"

//
// The following is passed in the TdiAction calls to reaffirm that
// the request is meant for the Appletalk transport.
//

#define MATK	(*(ULONG *)"MATK")

//
// Options buffer for all the calls
//

typedef struct _OPTIONS_CONNINF
{
	union
	{
		int ProtocolType;
		TRANSPORT_ADDRESS	Address;

		struct
		{
			TRANSPORT_ADDRESS	RemoteAddress;
			USHORT	WorkstationQuantum;
			USHORT	ServerQuantum;
		} PapInfo;
	};
} OPTIONS_CONNINF, *POPTIONS_CONNINF;
#define OPTIONS_LENGTH	sizeof(OPTIONS_CONNINF)

typedef	union
{
	struct
	{
		USHORT		Network;
		UCHAR		Node;
		UCHAR       Socket;
	};
	ULONG			Address;
} ATALK_ADDRESS, *PATALK_ADDRESS;

//
// ACTION CODES:
// The NBP/ZIP primitives are available to all the providers. The action
// codes for those are defined first. Following this are the action
// codes specific to each provider. To insert a new action code, just
// tag it at the end of the action codes for a particular block (common/
// provider specific), and increment the max for that block.
//
// *IMPORTANT*
// These are tightly integrated with the dispatch table for the action
// routines in ATKINIT.C
//


#define COMMON_ACTIONBASE					0
#define MIN_COMMON_ACTIONCODE				(COMMON_ACTIONBASE)

#define COMMON_ACTION_NBPLOOKUP				(COMMON_ACTIONBASE)
#define COMMON_ACTION_NBPCONFIRM			(COMMON_ACTIONBASE+0x01)
#define COMMON_ACTION_NBPREGISTER			(COMMON_ACTIONBASE+0x02)
#define COMMON_ACTION_NBPREMOVE				(COMMON_ACTIONBASE+0x03)

#define COMMON_ACTION_ZIPGETMYZONE			(COMMON_ACTIONBASE+0x04)
#define COMMON_ACTION_ZIPGETZONELIST		(COMMON_ACTIONBASE+0x05)
#define COMMON_ACTION_ZIPGETLZONES			(COMMON_ACTIONBASE+0x06)
#define COMMON_ACTION_ZIPGETLZONESONADAPTER (COMMON_ACTIONBASE+0x07)
#define	COMMON_ACTION_ZIPGETADAPTERDEFAULTS	(COMMON_ACTIONBASE+0x08)

#define	COMMON_ACTION_GETSTATISTICS			(COMMON_ACTIONBASE+0x09)
#define MAX_COMMON_ACTIONCODE				(COMMON_ACTIONBASE+0x09)
#define COMMON_ACTIONCODES					(MAX_COMMON_ACTIONCODE - MIN_COMMON_ACTIONCODE + 1)

//
// Provider specific action codes
//

//
// DDP
//
// NONE
//

//
// ADSP
//

#define ADSP_ACTIONBASE					(MAX_COMMON_ACTIONCODE + 0x01)
#define MIN_ADSPACTIONCODE				(ADSP_ACTIONBASE)
	
#define ACTION_ADSPFORWARDRESET			(ADSP_ACTIONBASE)
	
#define MAX_ADSPACTIONCODE				(ADSP_ACTIONBASE)
#define ADSP_SPECIFIC_ACTIONCODES		(MAX_ADSPACTIONCODE - MIN_ADSPACTIONCODE + 1)

//
// ASP Client
//

#define ASPC_ACTIONBASE					(MAX_ADSPACTIONCODE + 0x01)
#define MIN_ASPCACTIONCODE				(ATP_ACTIONBASE)

#define ACTION_ASPCGETSTATUS			(ASPC_ACTIONBASE)
#define ACTION_ASPCCOMMAND				(ASPC_ACTIONBASE+0x01)
#define ACTION_ASPCWRITE				(ASPC_ACTIONBASE+0x02)

// The following 2 are for NBP, stole 2 slots here that were reserved
#define COMMON_ACTION_NBPREGISTER_BY_ADDR	(ASPC_ACTIONBASE+0x03)
#define COMMON_ACTION_NBPREMOVE_BY_ADDR		(ASPC_ACTIONBASE+0x04)
#define ACTION_ASPCRESERVED3			(ASPC_ACTIONBASE+0x05)

#define MAX_ASPCACTIONCODE				(ASPC_ACTIONBASE+0x05)
#define ASPC_SPECIFIC_ACTIONCODES		(MAX_ASPCACTIONCODE - MIN_ASPCACTIONCODE + 1)


//
// ASP Server
//

#define ASP_ACTIONBASE					(MAX_ASPCACTIONCODE + 0x01)
#define MIN_ASPACTIONCODE				(ASP_ACTIONBASE)
	
#define	ACTION_ASP_BIND					(ASP_ACTIONBASE)
	
#define MAX_ASPACTIONCODE				(ASP_ACTIONBASE)
#define ASP_SPECIFIC_ACTIONCODES		(MAX_ASPACTIONCODE - MIN_ASPACTIONCODE + 1)
	
//                                  	
// PAP                              	
//                                  	
	
#define PAP_ACTIONBASE					(MAX_ASPACTIONCODE + 0x01)
#define MIN_PAPACTIONCODE				(PAP_ACTIONBASE)
	
#define ACTION_PAPGETSTATUSSRV			(PAP_ACTIONBASE)
#define ACTION_PAPSETSTATUS				(PAP_ACTIONBASE+0x01)
#define	ACTION_PAPPRIMEREAD				(PAP_ACTIONBASE+0x02)
	
#define MAX_PAPACTIONCODE				(PAP_ACTIONBASE+0x02)
#define PAP_SPECIFIC_ACTIONCODES		(MAX_PAPACTIONCODE - MIN_PAPACTIONCODE + 1)
	
#define MAX_ALLACTIONCODES				(MAX_PAPACTIONCODE)

//
// STRUCTURE Definitions for the ACTION routines for all the providers
//




//
// NBP Interface
//

//
// **WARNING**
// The structure WSH_NBP_NAME is defined to be exactly like this in atalkwsh.h
// Change both if they ever need to be changed
//

#define MAX_ENTITY	32

typedef struct
{
	UCHAR					ObjectNameLen;
	UCHAR					ObjectName[MAX_ENTITY];
	UCHAR					TypeNameLen;
	UCHAR					TypeName[MAX_ENTITY];
	UCHAR					ZoneNameLen;
	UCHAR					ZoneName[MAX_ENTITY];
} NBP_NAME, *PNBP_NAME;

typedef struct
{
	ATALK_ADDRESS			Address;
	USHORT					Enumerator;
	NBP_NAME				NbpName;
} NBP_TUPLE, *PNBP_TUPLE;

//
// NBP Lookup
//

typedef struct
{
	NBP_TUPLE				LookupTuple;
	USHORT					NoTuplesRead;

} NBP_LOOKUP_PARAMS, *PNBP_LOOKUP_PARAMS;

typedef struct
{
	TDI_ACTION_HEADER		ActionHeader;
	NBP_LOOKUP_PARAMS		Params;

	//
	// NBP_TUPLE			NbpTuples[]
	//

} NBP_LOOKUP_ACTION, *PNBP_LOOKUP_ACTION;

//
// NBP Confirm
//

typedef struct
{
	NBP_TUPLE				ConfirmTuple;

} NBP_CONFIRM_PARAMS, *PNBP_CONFIRM_PARAMS;

typedef struct
{
	TDI_ACTION_HEADER		ActionHeader;
	NBP_CONFIRM_PARAMS		Params;

} NBP_CONFIRM_ACTION, *PNBP_CONFIRM_ACTION;

//
// NBP Register/Deregister- Address Object
// Use the following for both register/deregister on their
// respective objects
//

typedef struct
{
	union
	{
		NBP_TUPLE			RegisterTuple;
		NBP_TUPLE			RegisteredTuple;
	};

} NBP_REGDEREG_PARAMS, *PNBP_REGDEREG_PARAMS;

typedef struct
{
	TDI_ACTION_HEADER		ActionHeader;
	NBP_REGDEREG_PARAMS		Params;

} NBP_REGDEREG_ACTION, *PNBP_REGDEREG_ACTION;




//
// ZIP Interface
//

//
// ZIP GetMyZone
//

typedef struct
{
	TDI_ACTION_HEADER		ActionHeader;

	//
	// CHAR	ZoneName[]
	// Maximum of MAX_ENTITYNAME+1
	//

} ZIP_GETMYZONE_ACTION, *PZIP_GETMYZONE_ACTION;

//
// ZIP GetZoneList
//

typedef struct
{
	LONG					ZonesAvailable;

} ZIP_GETZONELIST_PARAMS, *PZIP_GETZONELIST_PARAMS;

typedef struct
{
	TDI_ACTION_HEADER		ActionHeader;
	ZIP_GETZONELIST_PARAMS	Params;

	//
	// CHAR					ZoneListBuffer[];
	//

} ZIP_GETZONELIST_ACTION, *PZIP_GETZONELIST_ACTION;

//
// ZIP GetLocalZones
// This uses the same structure as that for the GetZoneList command
//

//
// ZIP GetLocalZonesOnAdapter
// This uses the same structure as for the GetZoneList command, with the
// condition that the adapter name follows the structure as a null
// terminated double-byte string. It will be overwritten upon return
// by the zone names.
//

//
// ZIP GetAdaptorDefaults (Network Range & Default Zone)
//
// The adapter name follows the structure as a null terminated double-byte
// string. This is replaced by the zone name.

typedef struct
{
	USHORT					NwRangeLowEnd;
	USHORT					NwRangeHighEnd;

} ZIP_GETPORTDEF_PARAMS, *PZIP_GETPORTDEF_PARAMS;

typedef struct
{
	TDI_ACTION_HEADER		ActionHeader;
	ZIP_GETPORTDEF_PARAMS	Params;

	// INPUT:
	// WCHAR				AdaptorName
	// Maximum of MAX_ENTITYNAME+1
	//
	// OUTPUT:
	// BYTE					DefZone[MAX_ENTITY+1];
} ZIP_GETPORTDEF_ACTION, *PZIP_GETPORTDEF_ACTION;

typedef struct
{
	TDI_ACTION_HEADER		ActionHeader;

	// OUTPUT:
	// Appletalk statistics structure
} GET_STATISTICS_ACTION, *PGET_STATISTICS_ACTION;

//
// DDP Interface
// NONE
//


//
// ADSP Interface- specific action routines for ADSP
//

//
// ADSP Forward Reset
//

typedef struct _ADSP_FORWARDRESET_ACTION
{
	TDI_ACTION_HEADER		ActionHeader;
} ADSP_FORWARDRESET_ACTION, *PADSP_FORWARDRESET_ACTION;




//
// ASP Client Interface- specific action routines for ASP Client
//

//
// ASP GetStatus
//
typedef struct
{
	TA_APPLETALK_ADDRESS		ServerAddr;

} ASPC_GETSTATUS_PARAMS, *PASPC_GETSTATUS_PARAMS;

typedef struct
{
	TDI_ACTION_HEADER			ActionHeader;
	ASPC_GETSTATUS_PARAMS		Params;

} ASPC_GETSTATUS_ACTION, *PASPC_GETSTATUS_ACTION;

//
// ASP Command or Write
//
typedef struct
{
	USHORT						CmdSize;
	USHORT						WriteAndReplySize;
	// BYTE						CmdBuff[CmdSize];
	// BYTE						WriteAndReplyBuf[ReplySize];

} ASPC_COMMAND_OR_WRITE_PARAMS, *PASPC_COMMAND_OR_WRITE_PARAMS;

typedef struct
{
	TDI_ACTION_HEADER			ActionHeader;
	ASPC_COMMAND_OR_WRITE_PARAMS Params;

} ASPC_COMMAND_OR_WRITE_ACTION, *PASPC_COMMAND_OR_WRITE_ACTION;

typedef struct
{
	TDI_ACTION_HEADER			ActionHeader;

} ASPC_RESERVED_ACTION, *PASPC_RESERVED_ACTION;

//
// ASP Server Interface- action routines specific to ASP Server
//

typedef	PVOID	CONNCTXT;

typedef struct
{
	PUCHAR		rq_RequestBuf;
	LONG		rq_RequestSize;
	union
	{
		PMDL	rq_WriteMdl;
		PMDL	rq_ReplyMdl;
	};
    PVOID       rq_CacheMgrContext;

} REQUEST, *PREQUEST;

typedef	VOID		(FASTCALL *CLIENT_CLOSE_COMPLETION)(
					IN	NTSTATUS				Status,
					IN	PVOID					pCloseCtxt);

typedef	VOID        (FASTCALL *CLIENT_REPLY_COMPLETION)(
					IN	NTSTATUS				Status,
					IN	PVOID					pReplyCtxt,
					IN  PREQUEST                Request);

                    // Returns context to associate for this session
typedef	CONNCTXT	(FASTCALL *CLIENT_SESSION_NOTIFY)(	
					IN	PVOID					pConnection,
                    IN  BOOLEAN                 fOverTcp);

typedef	NTSTATUS    (FASTCALL *CLIENT_REQUEST_NOTIFY)(
					IN	NTSTATUS				Status,
					IN	PVOID					ConnCtxt,
					IN	PREQUEST				Request);

                    // Returns MDL describing the buffer
typedef	NTSTATUS    (FASTCALL *CLIENT_GET_WRITEBUFFER)(
                    IN  PVOID                   pSda,
					IN	PREQUEST			    pRequest);

typedef	VOID		(FASTCALL *CLIENT_ATTN_COMPLETION)(
					IN	PVOID					pContext);

typedef	NTSTATUS	(*ASP_CLOSE_CONN)(
					IN	PVOID					pConnection);

typedef	NTSTATUS	(*ASP_FREE_CONN)(
					IN	PVOID					pConnection);

typedef	NTSTATUS	(FASTCALL *ASP_LISTEN_CONTROL)(		// Synchronous
					IN	PVOID					pAspCtxt,
					IN	BOOLEAN					Active);

typedef	NTSTATUS	(*ASP_SET_STATUS)(			// Synchronous
					IN	PVOID					pAspCtxt,
					IN	PUCHAR					pStatus,
					IN	USHORT					StatusSize);

typedef NTSTATUS    (FASTCALL *ASP_WRITE_CONTINUE)(
                    IN  PVOID   PREQUEST);

typedef	NTSTATUS	(FASTCALL *ASP_REPLY)(
					IN	PREQUEST				pRequest,
					IN	PUCHAR					ResultCode);

typedef	NTSTATUS	(*ASP_SEND_ATTENTION)(
					IN	PVOID					pConnection,
					IN	USHORT					AttentionCode,
					IN	PVOID					pContext);

typedef	struct
{
	CLIENT_SESSION_NOTIFY	clt_SessionNotify;		// When a new session is established
	CLIENT_REQUEST_NOTIFY	clt_RequestNotify;		// When a new request comes in
													// Also on remote closes
	CLIENT_GET_WRITEBUFFER	clt_GetWriteBuffer;		// For ASP Write command.
	CLIENT_REPLY_COMPLETION	clt_ReplyCompletion;	// Completion routine for a reply
    CLIENT_ATTN_COMPLETION	clt_AttnCompletion;		// Completion routine for send attention
	CLIENT_CLOSE_COMPLETION	clt_CloseCompletion;	// Completion routine for a session close request
} ASP_CLIENT_ENTRIES, *PASP_CLIENT_ENTRIES;

typedef	struct
{
    ATALK_ADDRESS           asp_AtalkAddr;          // net addr of default adapter
	PVOID					asp_AspCtxt;
	ASP_SET_STATUS			asp_SetStatus;
	ASP_CLOSE_CONN			asp_CloseConn;
	ASP_FREE_CONN			asp_FreeConn;
	ASP_LISTEN_CONTROL		asp_ListenControl;
    ASP_WRITE_CONTINUE      asp_WriteContinue;
	ASP_REPLY				asp_Reply;
	ASP_SEND_ATTENTION		asp_SendAttention;
} ASP_XPORT_ENTRIES, *PASP_XPORT_ENTRIES;

//
// ASP Exchange entries
//

typedef	struct
{
	PASP_XPORT_ENTRIES		pXportEntries;
    ASP_CLIENT_ENTRIES		ClientEntries;
} ASP_BIND_PARAMS, *PASP_BIND_PARAMS;

typedef struct
{
	TDI_ACTION_HEADER		ActionHeader;
	ASP_BIND_PARAMS			Params;
} ASP_BIND_ACTION, *PASP_BIND_ACTION;




//
// PAP Interface
//

//
// PAP GetStatus Using Server Address
//

typedef struct
{
	TA_APPLETALK_ADDRESS	ServerAddr;

} PAP_GETSTATUSSRV_PARAMS, *PPAP_GETSTATUSSRV_PARAMS;

typedef struct
{
	TDI_ACTION_HEADER		ActionHeader;
	PAP_GETSTATUSSRV_PARAMS Params;

} PAP_GETSTATUSSRV_ACTION, *PPAP_GETSTATUSSRV_ACTION;


//
// PAP SetStatus
//

typedef struct
{
	TDI_ACTION_HEADER		ActionHeader;

} PAP_SETSTATUS_ACTION, *PPAP_SETSTATUS_ACTION;

//
// PAP PrimeRead
//

typedef struct
{
	TDI_ACTION_HEADER		ActionHeader;

} PAP_PRIMEREAD_ACTION, *PPAP_PRIMEREAD_ACTION;

#else
	;
#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\setup\resource\sfmres.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    atresdll.c

Abstract:

    This module contians the DLL attach/detach event entry point for
    the AppleTalk Setup resource DLL.

Author:

    Ted Miller (tedm) July-1990

Revision History:

--*/
/*
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
*/
#include <windows.h>

HANDLE ThisDLLHandle;

BOOL
DLLInit(
    IN HANDLE DLLHandle,
    IN DWORD  Reason,
    IN LPVOID ReservedAndUnused
    )
{
    ReservedAndUnused;

    switch(Reason) {

    case DLL_PROCESS_ATTACH:

        ThisDLLHandle = DLLHandle;
        break;

    case DLL_PROCESS_DETACH:

    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:

        break;
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\atalk\winsock\wshatalk.c ===
/*++

Copyright (c) 1992 Microsoft Corporation

Module Name:

    wshatalk.c

Abstract:

    This module contains necessary routines for the Appletalk Windows Sockets
    Helper DLL. This DLL provides the transport-specific support necessary
    for the Windows Sockets DLL to use Appletalk as a transport.

Author:

    David Treadwell (davidtr)   19-Jul-1992 - TCP/IP version
    Nikhil Kamkolkar (nikhilk)  17-Nov- 1992 - Appletalk version

Revision History:

--*/

#include "nspatalk.h"
#include "wshdata.h"


//  GLOBAL - get the mac code page value from the registry.
int WshMacCodePage  = 0;

#if 0

VOID
PrintByteString(
    PUCHAR  pSrcOemString,
    USHORT  SrcStringLen
    )
{
    DbgPrint("%x - ", SrcStringLen);
    while (SrcStringLen-- > 0)
    {
        DbgPrint("%x", *pSrcOemString++);
    }
    DbgPrint("\n");
}

#define DBGPRINT0   DBGPRINT
#else
#define DBGPRINT0
#endif

INT
WSHGetSockaddrType (
    IN      PSOCKADDR Sockaddr,
    IN      DWORD SockaddrLength,
    OUT     PSOCKADDR_INFO SockaddrInfo
    )

/*++

Routine Description:

    This routine parses a sockaddr to determine the type of the
    machine address and endpoint address portions of the sockaddr.
    This is called by the winsock DLL whenever it needs to interpret
    a sockaddr.

Arguments:

    Sockaddr - a pointer to the sockaddr structure to evaluate.

    SockaddrLength - the number of bytes in the sockaddr structure.

    SockaddrInfo - a pointer to a structure that will receive information
        about the specified sockaddr.


Return Value:

    INT - a winsock error code indicating the status of the operation, or
        NO_ERROR if the operation succeeded.

--*/

{

    UNALIGNED SOCKADDR_AT *sockaddr = (PSOCKADDR_AT)Sockaddr;

    DBGPRINT0(("WSHGetSockAddrType: Entered\n"));

    //
    // Make sure that the address family is correct.
    //

    if ( sockaddr->sat_family != AF_APPLETALK )
    {
        return WSAEAFNOSUPPORT;
    }

    //
    // Make sure that the length is correct.
    //

    if ( SockaddrLength < sizeof(SOCKADDR_AT) )
    {
        return WSAEFAULT;
    }

    //
    // The address passed the tests, looks like a good address.
    // Determine the type of the address portion of the sockaddr.
    //

    if ( sockaddr->sat_socket == ATADDR_ANY )
    {
        SockaddrInfo->AddressInfo = SockaddrAddressInfoWildcard;
    }
    else if ( sockaddr->sat_node == ATADDR_BROADCAST )
    {
        SockaddrInfo->AddressInfo = SockaddrAddressInfoBroadcast;
    }
    else
    {
        SockaddrInfo->AddressInfo = SockaddrAddressInfoNormal;
    }

    //
    // Determine the type of the port (endpoint) in the sockaddr.
    //

    if ( sockaddr->sat_socket == 0 )
    {
        SockaddrInfo->EndpointInfo = SockaddrEndpointInfoWildcard;
    }
    else
    {
        SockaddrInfo->EndpointInfo = SockaddrEndpointInfoNormal;
    }

    return NO_ERROR;

} // WSHGetSockaddrType


// Fix for bug 262107
INT
WSHGetWildcardSockaddr (
    IN PVOID HelperDllSocketContext,
    OUT PSOCKADDR Sockaddr,
    OUT PINT SockaddrLength
    )

/*++

Routine Description:

    This routine returns a wildcard socket address.  A wildcard address
    is one which will bind the socket to an endpoint of the transport's
    choosing.  For AppleTalk, we just blank out the address with zeros.

Arguments:

    HelperDllSocketContext - the context pointer returned from
        WSHOpenSocket() for the socket for which we need a wildcard
        address.

    Sockaddr - points to a buffer which will receive the wildcard socket
        address.

    SockaddrLength - receives the length of the wioldcard sockaddr.

Return Value:

    INT - a winsock error code indicating the status of the operation, or
        NO_ERROR if the operation succeeded.

--*/

{
    if ( *SockaddrLength < sizeof(SOCKADDR_AT) ) {
        return WSAEFAULT;
    }

    *SockaddrLength = sizeof(SOCKADDR_AT);

    //
    // Just zero out the address and set the family to AF_APPLETALK--this is
    // a wildcard address for AppleTalk.
    //

    RtlZeroMemory( Sockaddr, sizeof(SOCKADDR_AT) );

    Sockaddr->sa_family = AF_APPLETALK;

    return NO_ERROR;

} // WSAGetWildcardSockaddr


INT
WSHGetSocketInformation (
    IN  PVOID   HelperDllSocketContext,
    IN  SOCKET  SocketHandle,
    IN  HANDLE  TdiAddressObjectHandle,
    IN  HANDLE  TdiConnectionObjectHandle,
    IN  INT     Level,
    IN  INT     OptionName,
    OUT PCHAR   OptionValue,
    OUT PINT    OptionLength
    )

/*++

Routine Description:

    This routine retrieves information about a socket for those socket
    options supported in this helper DLL. The options supported here
    are SO_LOOKUPNAME/SO_LOOKUPZONES.
    This routine is called by the winsock DLL when a level/option name
    combination is passed to getsockopt() that the winsock DLL does not
    understand.

Arguments:

    HelperDllSocketContext - the context pointer returned from
        WSHOpenSocket().

    SocketHandle - the handle of the socket for which we're getting
        information.

    TdiAddressObjectHandle - the TDI address object of the socket, if
        any. If the socket is not yet bound to an address, then
        it does not have a TDI address object and this parameter
        will be NULL.

    TdiConnectionObjectHandle - the TDI connection object of the socket,
        if any. If the socket is not yet connected, then it does not
        have a TDI connection object and this parameter will be NULL.

    Level - the level parameter passed to getsockopt().

    OptionName - the optname parameter passed to getsockopt().

    OptionValue - the optval parameter passed to getsockopt().

    OptionLength - the optlen parameter passed to getsockopt().

Return Value:

    INT - a winsock error code indicating the status of the operation, or
        NO_ERROR if the operation succeeded.

--*/

{
    NTSTATUS            status;
    ULONG               tdiActionLength;
    IO_STATUS_BLOCK     ioStatusBlock;
    HANDLE              eventHandle;
    PTDI_ACTION_HEADER  tdiAction;
    INT                 error = NO_ERROR;

    UNREFERENCED_PARAMETER( SocketHandle );
    UNREFERENCED_PARAMETER( TdiConnectionObjectHandle );

    DBGPRINT0(("WSHGetSocketInformation: Entered, OptionName %ld\n", OptionName));

    if ( Level == SOL_INTERNAL && OptionName == SO_CONTEXT )
    {

        PWSHATALK_SOCKET_CONTEXT    context = HelperDllSocketContext;

        //
        // The Windows Sockets DLL is requesting context information
        // from us.  If an output buffer was not supplied, the Windows
        // Sockets DLL is just requesting the size of our context
        // information.
        //

        if ( OptionValue != NULL ) {

            //
            // Make sure that the buffer is sufficient to hold all the
            // context information.
            //

            if ( *OptionLength < sizeof(*context) )
            {
                *OptionLength = sizeof(*context);
                return WSAEFAULT;
            }

            //
            // Copy in the context information.
            //

            RtlCopyMemory( OptionValue, context, sizeof(*context) );
        }

        *OptionLength = sizeof(*context);

        return NO_ERROR;
    }


    //
    // The only level we support here is SOL_APPLETALK.
    //

    if ( Level != SOL_APPLETALK )
    {
        return WSAEINVAL;
    }

    //
    // Fill in the result based on the option name.
    //

    switch ( OptionName )
    {
      case SO_LOOKUP_NAME:
        if (( TdiAddressObjectHandle != NULL) &&
            (*OptionLength > sizeof(WSH_LOOKUP_NAME)))
        {
            //  Due to the 'greater than' check we are guaranteed atleast
            //  one byte after the parameters.
            tdiActionLength =   sizeof(NBP_LOOKUP_ACTION) +
                                *OptionLength -
                                sizeof(WSH_LOOKUP_NAME);
        }
        else
        {
            error = WSAEINVAL;
        }
        break;

      case SO_CONFIRM_NAME:
        if (( TdiAddressObjectHandle != NULL) &&
            (*OptionLength >= sizeof(WSH_NBP_TUPLE)))
        {
            tdiActionLength =   sizeof(NBP_CONFIRM_ACTION);
        }
        else
        {
            error = WSAEINVAL;
        }
        break;

      case SO_LOOKUP_MYZONE :
        if (( TdiAddressObjectHandle != NULL) &&
            (*OptionLength > 0))
        {
            //  Due to the 'greater than' check we are guaranteed atleast
            //  one byte after the parameters.
            tdiActionLength =   sizeof(ZIP_GETMYZONE_ACTION) +
                                *OptionLength;
        }
        else
        {
            error = WSAEINVAL;
        }

        break;

      case SO_LOOKUP_ZONES :
        if (( TdiAddressObjectHandle != NULL) &&
            (*OptionLength > sizeof(WSH_LOOKUP_ZONES)))
        {
            //  Due to the 'greater than' check we are guaranteed atleast
            //  one byte after the parameters.
            tdiActionLength =   sizeof(ZIP_GETZONELIST_ACTION) +
                                *OptionLength -
                                sizeof(WSH_LOOKUP_ZONES);
        }
        else
        {
            error = WSAEINVAL;
        }

        break;

      case SO_LOOKUP_ZONES_ON_ADAPTER:
        if ((TdiAddressObjectHandle != NULL) &&
            (*OptionLength > sizeof(WSH_LOOKUP_ZONES)))
        {
            tdiActionLength =   sizeof(ZIP_GETZONELIST_ACTION) +
                                *OptionLength -
                                sizeof(WSH_LOOKUP_ZONES);
        }
        else
        {
            error = WSAEINVAL;
        }
        break;

      case SO_LOOKUP_NETDEF_ON_ADAPTER:
        if ((TdiAddressObjectHandle != NULL) &&
            (*OptionLength > sizeof(WSH_LOOKUP_NETDEF_ON_ADAPTER)))
        {
            tdiActionLength =   sizeof(ZIP_GETPORTDEF_ACTION) +
                                *OptionLength -
                                sizeof(WSH_LOOKUP_NETDEF_ON_ADAPTER);
        }
        else
        {
            error = WSAEINVAL;
        }

        break;

      case SO_PAP_GET_SERVER_STATUS:
        if (( TdiAddressObjectHandle != NULL ) &&
            ( *OptionLength >= sizeof(WSH_PAP_GET_SERVER_STATUS)))
        {
            tdiActionLength =   sizeof(PAP_GETSTATUSSRV_ACTION) +
                                *OptionLength -
                                sizeof(SOCKADDR_AT);
        }
        else
        {
            error = WSAEINVAL;
        }
        break;

    default:

        error = WSAENOPROTOOPT;
        break;
    }

    if (error != NO_ERROR)
    {
        return(error);
    }


    tdiAction = RtlAllocateHeap( RtlProcessHeap( ), 0, tdiActionLength );
    if ( tdiAction == NULL )
    {
        return WSAENOBUFS;
    }

    tdiAction->TransportId = MATK;
    status = NtCreateEvent(
                 &eventHandle,
                 EVENT_ALL_ACCESS,
                 NULL,
                 SynchronizationEvent,
                 FALSE);

    if ( !NT_SUCCESS(status) )
    {
        RtlFreeHeap( RtlProcessHeap( ), 0, tdiAction );
        return WSAENOBUFS;
    }

    switch ( OptionName )
    {
      case SO_LOOKUP_NAME:
        {
            PNBP_LOOKUP_ACTION nbpAction;

            nbpAction = (PNBP_LOOKUP_ACTION)tdiAction;
            nbpAction->ActionHeader.ActionCode = COMMON_ACTION_NBPLOOKUP;

            //
            // Copy the nbp name for lookup in the proper place
            //

            RtlCopyMemory(
                (PCHAR)&nbpAction->Params.LookupTuple,
                (PCHAR)(&((PWSH_LOOKUP_NAME)OptionValue)->LookupTuple),
                sizeof(((PWSH_LOOKUP_NAME)OptionValue)->LookupTuple));

            if (!WshNbpNameToMacCodePage(
                    &((PWSH_LOOKUP_NAME)OptionValue)->LookupTuple.NbpName))
            {
                error = WSAEINVAL;
                break;
            }
        }

        break;

      case SO_CONFIRM_NAME:
        {
            PNBP_CONFIRM_ACTION nbpAction;

            nbpAction = (PNBP_CONFIRM_ACTION)tdiAction;
            nbpAction->ActionHeader.ActionCode = COMMON_ACTION_NBPCONFIRM;

            //
            // Copy the nbp name for confirm in the proper place
            //

            RtlCopyMemory(
                (PCHAR)&nbpAction->Params.ConfirmTuple,
                (PCHAR)OptionValue,
                sizeof(WSH_NBP_TUPLE));

            if (!WshNbpNameToMacCodePage(
                    &((PWSH_NBP_TUPLE)OptionValue)->NbpName))
            {
                error = WSAEINVAL;
                break;
            }
        }

        break;

      case SO_LOOKUP_ZONES :
        {
            PZIP_GETZONELIST_ACTION zipAction;

            zipAction = (PZIP_GETZONELIST_ACTION)tdiAction;
            zipAction->ActionHeader.ActionCode = COMMON_ACTION_ZIPGETZONELIST;

            //
            // No parameters need to be passed
            //
        }

        break;

      case SO_LOOKUP_NETDEF_ON_ADAPTER:
        {
            PZIP_GETPORTDEF_ACTION  zipAction;

            zipAction = (PZIP_GETPORTDEF_ACTION)tdiAction;
            zipAction->ActionHeader.ActionCode = COMMON_ACTION_ZIPGETADAPTERDEFAULTS;

            //  If the string is not null-terminated, the calling process will *DIE*.
            wcsncpy(
                (PWCHAR)((PUCHAR)zipAction + sizeof(ZIP_GETPORTDEF_ACTION)),
                (PWCHAR)((PUCHAR)OptionValue + sizeof(WSH_LOOKUP_NETDEF_ON_ADAPTER)),
                ((tdiActionLength - sizeof(ZIP_GETPORTDEF_ACTION))/sizeof(WCHAR)));
        }

        break;

      case SO_LOOKUP_ZONES_ON_ADAPTER:
        {
            PZIP_GETZONELIST_ACTION zipAction;

            zipAction = (PZIP_GETZONELIST_ACTION)tdiAction;
            zipAction->ActionHeader.ActionCode = COMMON_ACTION_ZIPGETLZONESONADAPTER;

            //  If the string is not null-terminated, the calling process will *DIE*.
            wcsncpy(
                (PWCHAR)((PUCHAR)zipAction + sizeof(ZIP_GETZONELIST_ACTION)),
                (PWCHAR)((PUCHAR)OptionValue + sizeof(WSH_LOOKUP_ZONES)),
                ((tdiActionLength - sizeof(ZIP_GETZONELIST_ACTION))/sizeof(WCHAR)));
        }

        break;

      case SO_LOOKUP_MYZONE :
        {
            PZIP_GETMYZONE_ACTION   zipAction;

            zipAction = (PZIP_GETMYZONE_ACTION)tdiAction;
            zipAction->ActionHeader.ActionCode = COMMON_ACTION_ZIPGETMYZONE;
        }

        break;

      case SO_PAP_GET_SERVER_STATUS:
        {
            PPAP_GETSTATUSSRV_ACTION papAction;

            papAction = (PPAP_GETSTATUSSRV_ACTION)tdiAction;
            papAction->ActionHeader.ActionCode = ACTION_PAPGETSTATUSSRV;

            // Set the server address.
            SOCK_TO_TDI_ATALKADDR(
                &papAction->Params.ServerAddr,
                &((PWSH_PAP_GET_SERVER_STATUS)OptionValue)->ServerAddr);
        }

        break;

    default:

        //
        // Should have returned in the first switch statement
        //

        error = WSAENOPROTOOPT;
        break;
    }

    if (error != NO_ERROR)
    {
        RtlFreeHeap( RtlProcessHeap( ), 0, tdiAction );
        NtClose( eventHandle );
        return (error);
    }

    status = NtDeviceIoControlFile(
                 TdiAddressObjectHandle,
                 eventHandle,
                 NULL,
                 NULL,
                 &ioStatusBlock,
                 IOCTL_TDI_ACTION,
                 NULL,               // Input buffer
                 0,                  // Length of input buffer
                 tdiAction,
                 tdiActionLength);

    if ( status == STATUS_PENDING )
    {
        status = NtWaitForSingleObject( eventHandle, FALSE, NULL );
        ASSERT( NT_SUCCESS(status) );
        status = ioStatusBlock.Status;
    }

    error = WSHNtStatusToWinsockErr(status);

    //  Only copy data over if the error code is no-error or buffer too small.
    //  For a confirm, a new socket could be returned for the lookup.
    if ((error == NO_ERROR) || (error == WSAENOBUFS) ||
        ((error == WSAEADDRNOTAVAIL) && (OptionName == SO_CONFIRM_NAME)))
    {
        switch ( OptionName )
        {
          case SO_LOOKUP_NAME:
            //
            // We are guaranteed by checks in the beginning atleast one byte
            // following the buffer
            //
            {
                PNBP_LOOKUP_ACTION  nbpAction;
                PWSH_NBP_TUPLE      pNbpTuple;
                PUCHAR tdiBuffer = (PCHAR)tdiAction+sizeof(NBP_LOOKUP_ACTION);
                PUCHAR userBuffer = (PCHAR)OptionValue+sizeof(WSH_LOOKUP_NAME);
                INT copySize = *OptionLength - sizeof(WSH_LOOKUP_NAME);

                nbpAction = (PNBP_LOOKUP_ACTION)tdiAction;
                ((PWSH_LOOKUP_NAME)OptionValue)->NoTuples =
                                        nbpAction->Params.NoTuplesRead;

                RtlCopyMemory(
                    userBuffer,
                    tdiBuffer,
                    copySize);

                //
                //  Convert all tuples from MAC to OEM code page
                //

                pNbpTuple   = (PWSH_NBP_TUPLE)userBuffer;
                while (nbpAction->Params.NoTuplesRead-- > 0)
                {
                    if (!WshNbpNameToOemCodePage(
                            &pNbpTuple->NbpName))
                    {
                        DBGPRINT(("WSHGetSocketInformation: ToOem failed %d\n!",
                                (USHORT)((PWSH_LOOKUP_ZONES)OptionValue)->NoZones));

                        error = WSAEINVAL;
                        break;
                    }

                    pNbpTuple++;
                }
            }
            break;

          case SO_CONFIRM_NAME:
            {
                PNBP_CONFIRM_ACTION nbpAction;

                nbpAction = (PNBP_CONFIRM_ACTION)tdiAction;

                //
                // Copy the nbp name for confirm back into the option buffer
                //

                RtlCopyMemory(
                    (PCHAR)OptionValue,
                    (PCHAR)&nbpAction->Params.ConfirmTuple,
                    sizeof(WSH_NBP_TUPLE));

                //
                //  Convert NbpName from MAC to OEM code page
                //

                if (!WshNbpNameToOemCodePage(
                        &((PWSH_NBP_TUPLE)OptionValue)->NbpName))
                {
                    DBGPRINT(("WSHGetSocketInformation: ToOem failed %d\n!",
                            (USHORT)((PWSH_LOOKUP_ZONES)OptionValue)->NoZones));

                    error = WSAEINVAL;
                    break;
                }

            }
            break;

          case SO_LOOKUP_ZONES:
          case SO_LOOKUP_ZONES_ON_ADAPTER:
            //
            // We are guaranteed by checks in the beginning atleast one byte
            // following the buffer
            //
            {
                PZIP_GETZONELIST_ACTION zipAction;
                PUCHAR tdiBuffer = (PCHAR)tdiAction + sizeof(ZIP_GETZONELIST_ACTION);
                PUCHAR userBuffer = (PCHAR)OptionValue + sizeof(WSH_LOOKUP_ZONES);
                INT copySize = *OptionLength - sizeof(WSH_LOOKUP_ZONES);

                zipAction = (PZIP_GETZONELIST_ACTION)tdiAction;
                ((PWSH_LOOKUP_ZONES)OptionValue)->NoZones=
                                            zipAction->Params.ZonesAvailable;

                RtlCopyMemory(
                    userBuffer,
                    tdiBuffer,
                    copySize);

                if (!WshZoneListToOemCodePage(
                        userBuffer,
                        (USHORT)((PWSH_LOOKUP_ZONES)OptionValue)->NoZones))
                {
                    DBGPRINT(("WSHGetSocketInformation: ToOem failed %d\n!",
                            (USHORT)((PWSH_LOOKUP_ZONES)OptionValue)->NoZones));

                    error = WSAEINVAL;
                    break;
                }
            }
            break;

          case SO_LOOKUP_NETDEF_ON_ADAPTER:
            {
                PZIP_GETPORTDEF_ACTION  zipAction;
                PUCHAR tdiBuffer = (PCHAR)tdiAction + sizeof(ZIP_GETPORTDEF_ACTION);
                PUCHAR userBuffer = (PCHAR)OptionValue +
                                    sizeof(WSH_LOOKUP_NETDEF_ON_ADAPTER);

                INT copySize = *OptionLength - sizeof(WSH_LOOKUP_NETDEF_ON_ADAPTER);

                zipAction = (PZIP_GETPORTDEF_ACTION)tdiAction;
                ((PWSH_LOOKUP_NETDEF_ON_ADAPTER)OptionValue)->NetworkRangeLowerEnd =
                    zipAction->Params.NwRangeLowEnd;

                ((PWSH_LOOKUP_NETDEF_ON_ADAPTER)OptionValue)->NetworkRangeUpperEnd =
                    zipAction->Params.NwRangeHighEnd;

                //  Copy the rest of the buffer
                RtlCopyMemory(
                    userBuffer,
                    tdiBuffer,
                    copySize);

                if (!WshZoneListToOemCodePage(
                        userBuffer,
                        1))
                {
                    DBGPRINT(("WSHGetSocketInformation: ToOem failed %d\n!",
                            (USHORT)((PWSH_LOOKUP_ZONES)OptionValue)->NoZones));

                    error = WSAEINVAL;
                    break;
                }
            }
            break;

          case SO_LOOKUP_MYZONE :
            {
                PUCHAR tdiBuffer = (PCHAR)tdiAction+sizeof(ZIP_GETMYZONE_ACTION);
                PUCHAR userBuffer = (PCHAR)OptionValue;
                INT copySize = *OptionLength;

                RtlCopyMemory(
                    userBuffer,
                    tdiBuffer,
                    copySize);

                if (!WshZoneListToOemCodePage(
                        userBuffer,
                        1))
                {
                    DBGPRINT(("WSHGetSocketInformation: ToOem failed %d\n!",
                            (USHORT)((PWSH_LOOKUP_ZONES)OptionValue)->NoZones));

                    error = WSAEINVAL;
                    break;
                }
            }
            break;

          case SO_PAP_GET_SERVER_STATUS:
            {
                PUCHAR tdiBuffer = (PCHAR)tdiAction+sizeof(PAP_GETSTATUSSRV_ACTION);
                PUCHAR userBuffer = (PCHAR)OptionValue+sizeof(SOCKADDR_AT);
                INT copySize = *OptionLength - sizeof(SOCKADDR_AT);

                RtlCopyMemory(
                    userBuffer,
                    tdiBuffer,
                    copySize);
            }
            break;

          default:
            error = WSAENOPROTOOPT;
            break;
        }
    }

    RtlFreeHeap( RtlProcessHeap( ), 0, tdiAction );
    NtClose( eventHandle );
    return error;

} // WSHGetSocketInformation




INT
WSHSetSocketInformation (
    IN  PVOID   HelperDllSocketContext,
    IN  SOCKET  SocketHandle,
    IN  HANDLE  TdiAddressObjectHandle,
    IN  HANDLE  TdiConnectionObjectHandle,
    IN  INT     Level,
    IN  INT     OptionName,
    IN  PCHAR   OptionValue,
    IN  INT     OptionLength
    )

/*++

Routine Description:

    This routine sets information about a socket for those socket
    options supported in this helper DLL. The options supported here
    are SO_REGISTERNAME/SO_DEREGISTERNAME. This routine is called by the
    winsock DLL when a level/option name combination is passed to
    setsockopt() that the winsock DLL does not understand.

Arguments:

    HelperDllSocketContext - the context pointer returned from
        WSHOpenSocket().

    SocketHandle - the handle of the socket for which we're getting
        information.

    TdiAddressObjectHandle - the TDI address object of the socket, if
        any. If the socket is not yet bound to an address, then
        it does not have a TDI address object and this parameter
        will be NULL.

    TdiConnectionObjectHandle - the TDI connection object of the socket,
        if any. If the socket is not yet connected, then it does not
        have a TDI connection object and this parameter will be NULL.

    Level - the level parameter passed to setsockopt().

    OptionName - the optname parameter passed to setsockopt().

    OptionValue - the optval parameter passed to setsockopt().

    OptionLength - the optlen parameter passed to setsockopt().

Return Value:

    INT - a winsock error code indicating the status of the operation, or
        NO_ERROR if the operation succeeded.

--*/

{
    NTSTATUS            status;
    ULONG               tdiActionLength;
    HANDLE              objectHandle;
    PIO_STATUS_BLOCK    pIoStatusBlock;
    PTDI_ACTION_HEADER  tdiAction;

    PWSHATALK_SOCKET_CONTEXT    context = HelperDllSocketContext;
    HANDLE                      eventHandle = NULL;
    PVOID                       completionApc = NULL;
    PVOID                       apcContext = NULL;
    BOOLEAN                     freeTdiAction = FALSE;
    INT                         error = NO_ERROR;
    BOOLEAN                     waitForCompletion =(OptionName != SO_PAP_PRIME_READ);


    UNREFERENCED_PARAMETER( SocketHandle );

    DBGPRINT0(("WSHSetSocketInformation: Entered, OptionName %ld\n", OptionName));

    //
    // Check if this is an internal request for context information.
    //

    if ( Level == SOL_INTERNAL && OptionName == SO_CONTEXT ) {

        //
        // The Windows Sockets DLL is requesting that we set context
        // information for a new socket.  If the new socket was
        // accept()'ed, then we have already been notified of the socket
        // and HelperDllSocketContext will be valid.  If the new socket
        // was inherited or duped into this process, then this is our
        // first notification of the socket and HelperDllSocketContext
        // will be equal to NULL.
        //
        // Insure that the context information being passed to us is
        // sufficiently large.
        //

        if ( OptionLength < sizeof(*context) ) {
            return WSAEINVAL;
        }

        if ( HelperDllSocketContext == NULL ) {

            //
            // This is our notification that a socket handle was
            // inherited or duped into this process.  Allocate a context
            // structure for the new socket.
            //

            context = RtlAllocateHeap( RtlProcessHeap( ), 0, sizeof(*context) );
            if ( context == NULL ) {
                return WSAENOBUFS;
            }

            //
            // Copy over information into the context block.
            //

            RtlCopyMemory( context, OptionValue, sizeof(*context) );

            //
            // Tell the Windows Sockets DLL where our context information is
            // stored so that it can return the context pointer in future
            // calls.
            //

            *(PWSHATALK_SOCKET_CONTEXT *)OptionValue = context;

            return NO_ERROR;
        }
        else
        {
            return NO_ERROR;
        }
    }

    //
    // The only level we support here is SOL_APPLETALK.
    //

    if ( Level != SOL_APPLETALK )
    {
        DBGPRINT0(("WSHSetSocketInformation: Level incorrect %d\n", Level));
        return WSAEINVAL;
    }

    //
    // Fill in the result based on the option name.
    // We support SO_REGISTERNAME/SO_DEREGISTERNAME only
    //

    pIoStatusBlock = RtlAllocateHeap( RtlProcessHeap(), 0, sizeof(IO_STATUS_BLOCK));
    if (pIoStatusBlock == NULL)
    {
        return(WSAENOBUFS);
    }


    if (waitForCompletion)
    {
        status = NtCreateEvent(
                     &eventHandle,
                     EVENT_ALL_ACCESS,
                     NULL,
                     SynchronizationEvent,
                     FALSE
                     );

        if ( !NT_SUCCESS(status) )
        {
            RtlFreeHeap( RtlProcessHeap(), 0, pIoStatusBlock);
            DBGPRINT(("WSHSetSocketInformation: Create event failed\n"));
            return WSAENOBUFS;
        }
    }
    else
    {
        completionApc = CompleteTdiActionApc;
        apcContext = pIoStatusBlock;
    }

    switch (OptionName)
    {
      case SO_REGISTER_NAME:
        {
            PNBP_REGDEREG_ACTION    nbpAction;

            if (( TdiAddressObjectHandle == NULL) ||
                (OptionLength != sizeof(WSH_REGISTER_NAME)))
            {
                error = WSAEINVAL;
                break;
            }

            //  Operation is on the address handle
            objectHandle = TdiAddressObjectHandle;

            tdiActionLength = sizeof(NBP_REGDEREG_ACTION);
            tdiAction = RtlAllocateHeap( RtlProcessHeap( ), 0, tdiActionLength );
            if ( tdiAction == NULL )
            {
                error = WSAENOBUFS;
                break;
            }

            freeTdiAction = TRUE;

            tdiAction->TransportId = MATK;
            tdiAction->ActionCode = COMMON_ACTION_NBPREGISTER;
            nbpAction = (PNBP_REGDEREG_ACTION)tdiAction;

            //
            // Copy the nbp name to the proper place
            //

            RtlCopyMemory(
                (PCHAR)&nbpAction->Params.RegisterTuple.NbpName,
                OptionValue,
                OptionLength);

            //
            // Convert the tuple to MAC code page
            //

            if (!WshNbpNameToMacCodePage(
                    (PWSH_REGISTER_NAME)OptionValue))
            {
                error = WSAEINVAL;
                break;
            }
        }
        break;

      case SO_DEREGISTER_NAME:
        {
            PNBP_REGDEREG_ACTION    nbpAction;

            if (( TdiAddressObjectHandle == NULL) ||
                (OptionLength != sizeof(WSH_DEREGISTER_NAME)))
            {
                error = WSAEINVAL;
                break;
            }

            //  Operation is on the address handle
            objectHandle = TdiAddressObjectHandle;

            tdiActionLength = sizeof(NBP_REGDEREG_ACTION);
            tdiAction = RtlAllocateHeap( RtlProcessHeap( ), 0, tdiActionLength );
            if ( tdiAction == NULL )
            {
                error = WSAENOBUFS;
                break;
            }

            freeTdiAction = TRUE;

            tdiAction->TransportId = MATK;
            tdiAction->ActionCode = COMMON_ACTION_NBPREMOVE;
            nbpAction = (PNBP_REGDEREG_ACTION)tdiAction;

            //
            // Copy the nbp name to the proper place
            //

            RtlCopyMemory(
                (PCHAR)&nbpAction->Params.RegisteredTuple.NbpName,
                OptionValue,
                OptionLength);

            //
            // Convert the tuple to MAC code page
            //

            if (!WshNbpNameToMacCodePage(
                    (PWSH_DEREGISTER_NAME)OptionValue))
            {
                error = WSAEINVAL;
                break;
            }
        }
        break;

      case SO_PAP_SET_SERVER_STATUS:
        {
            PPAP_SETSTATUS_ACTION   papAction;

            if (( TdiAddressObjectHandle == NULL) ||
                (OptionLength < 0))
            {
                error = WSAEINVAL;
                break;
            }

            //  Operation is on the address handle
            objectHandle = TdiAddressObjectHandle;

            tdiActionLength = (ULONG)OptionLength +
                                (ULONG)(sizeof(PAP_SETSTATUS_ACTION));

            DBGPRINT0(("ActionLen %lx\n", tdiActionLength));

            tdiAction = RtlAllocateHeap( RtlProcessHeap( ), 0, tdiActionLength );
            if ( tdiAction == NULL )
            {
                error = WSAENOBUFS;
                break;
            }

            freeTdiAction = TRUE;

            tdiAction->TransportId = MATK;
            tdiAction->ActionCode = ACTION_PAPSETSTATUS;
            papAction = (PPAP_SETSTATUS_ACTION)tdiAction;

            DBGPRINT0(("Setting Status len %lx\n", OptionLength));

            //
            // Copy the passed status into our buffer
            //

            if (OptionLength > 0)
            {
                RtlCopyMemory(
                    (PCHAR)papAction + sizeof(PAP_SETSTATUS_ACTION),
                    OptionValue,
                    OptionLength);
            }
        }
        break;

      case SO_PAP_PRIME_READ :
        {
            tdiAction = (PTDI_ACTION_HEADER)OptionValue;
            tdiActionLength = OptionLength;

            ASSERT(waitForCompletion == FALSE);

            if ((TdiConnectionObjectHandle == NULL) ||
                (OptionLength < MIN_PAP_READ_BUF_SIZE))
            {
                error = WSAEINVAL;
                break;
            }

            //  Operation is on the connection handle
            objectHandle = TdiConnectionObjectHandle;

            //  These will get overwritten by the incoming data.
            tdiAction->TransportId  = MATK;
            tdiAction->ActionCode   = ACTION_PAPPRIMEREAD;

            //  This is the caller's buffer! Dont free it! Also, we dont wait
            //  for this to complete.
            freeTdiAction = FALSE;

            // We potentially have an APC waiting to be delivered from a
            // previous setsockopt(). Give it a chance
            NtTestAlert();
        }
        break;

    default:
        error = WSAENOPROTOOPT;
        break;
    }

    if (error != NO_ERROR)
    {
        if (freeTdiAction)
        {
            RtlFreeHeap( RtlProcessHeap( ), 0, tdiAction );
        }

        if (waitForCompletion)
        {
            NtClose(eventHandle);
        }

        RtlFreeHeap( RtlProcessHeap(), 0, pIoStatusBlock);
        return(error);
    }

    status = NtDeviceIoControlFile(
                 objectHandle,
                 eventHandle,
                 completionApc,
                 apcContext,
                 pIoStatusBlock,
                 IOCTL_TDI_ACTION,
                 NULL,               // Input buffer
                 0,                  // Length of input buffer
                 tdiAction,
                 tdiActionLength
                 );

    if ( status == STATUS_PENDING )
    {
        if (waitForCompletion)
        {
            status = NtWaitForSingleObject( eventHandle, FALSE, NULL );
            ASSERT( NT_SUCCESS(status) );
            status = pIoStatusBlock->Status;
        }
        else
        {
            status = STATUS_SUCCESS;
        }
    }

    if (freeTdiAction)
    {
        RtlFreeHeap( RtlProcessHeap( ), 0, tdiAction );
    }

    //  Close the event
    if (waitForCompletion)
    {
        NtClose(eventHandle);
        RtlFreeHeap( RtlProcessHeap( ), 0, pIoStatusBlock );
    }

    return (WSHNtStatusToWinsockErr(status));

} // WSHSetSocketInformation




DWORD
WSHGetWinsockMapping (
    OUT PWINSOCK_MAPPING    Mapping,
    IN  DWORD               MappingLength
    )

/*++

Routine Description:

    Returns the list of address family/socket type/protocol triples
    supported by this helper DLL.

Arguments:

    Mapping - receives a pointer to a WINSOCK_MAPPING structure that
        describes the triples supported here.

    MappingLength - the length, in bytes, of the passed-in Mapping buffer.

Return Value:

    DWORD - the length, in bytes, of a WINSOCK_MAPPING structure for this
        helper DLL. If the passed-in buffer is too small, the return
        value will indicate the size of a buffer needed to contain
        the WINSOCK_MAPPING structure.

--*/

{
    DWORD   mappingLength;
    ULONG   offset;

    DBGPRINT0(("WSHGetWinsockMapping: Entered\n"));

    mappingLength = sizeof(WINSOCK_MAPPING) -
                    sizeof(MAPPING_TRIPLE) +
                    sizeof(AdspStreamMappingTriples) +
                    sizeof(AdspMsgMappingTriples) +
                    sizeof(PapMsgMappingTriples) +
                    sizeof(DdpMappingTriples);

    //
    // If the passed-in buffer is too small, return the length needed
    // now without writing to the buffer. The caller should allocate
    // enough memory and call this routine again.
    //

    if ( mappingLength > MappingLength )
    {
        return mappingLength;
    }

    //
    // Fill in the output mapping buffer with the list of triples
    // supported in this helper DLL.
    //

    Mapping->Rows =
        sizeof(AdspStreamMappingTriples) / sizeof(AdspStreamMappingTriples[0]) +
        sizeof(AdspMsgMappingTriples) / sizeof(AdspMsgMappingTriples[0]) +
        sizeof(PapMsgMappingTriples) / sizeof(PapMsgMappingTriples[0]) +
        sizeof(DdpMappingTriples) / sizeof(DdpMappingTriples[0]);

    Mapping->Columns = sizeof(MAPPING_TRIPLE) / sizeof(DWORD);

    offset = 0;
    RtlCopyMemory(
        Mapping->Mapping,
        AdspStreamMappingTriples,
        sizeof(AdspStreamMappingTriples));

    offset += sizeof(AdspStreamMappingTriples);
    RtlCopyMemory(
        (PCHAR)Mapping->Mapping + offset,
        AdspMsgMappingTriples,
        sizeof(AdspMsgMappingTriples));

    offset += sizeof(AdspMsgMappingTriples);
    RtlCopyMemory(
        (PCHAR)Mapping->Mapping + offset,
        PapMsgMappingTriples,
        sizeof(PapMsgMappingTriples));

    offset += sizeof(PapMsgMappingTriples);
    RtlCopyMemory(
        (PCHAR)Mapping->Mapping + offset,
        DdpMappingTriples,
        sizeof(DdpMappingTriples));

    //
    // Return the number of bytes we wrote.
    //

    DBGPRINT0(("WSHGetWinsockMapping: Mapping Length = %d\n", mappingLength));

    return mappingLength;

} // WSHGetWinsockMapping




INT
WSHOpenSocket (
    IN  OUT PINT        AddressFamily,
    IN  OUT PINT        SocketType,
    IN  OUT PINT        Protocol,
    OUT PUNICODE_STRING TransportDeviceName,
    OUT PVOID   *       HelperDllSocketContext,
    OUT PDWORD          NotificationEvents
    )

/*++

Routine Description:

    Does the necessary work for this helper DLL to open a socket and is
    called by the winsock DLL in the socket() routine. This routine
    verifies that the specified triple is valid, determines the NT
    device name of the TDI provider that will support that triple,
    allocates space to hold the socket's context block, and
    canonicalizes the triple.

Arguments:

    AddressFamily - on input, the address family specified in the
        socket() call. On output, the canonicalized value for the
        address family.

    SocketType - on input, the socket type specified in the socket()
        call. On output, the canonicalized value for the socket type.

    Protocol - on input, the protocol specified in the socket() call.
        On output, the canonicalized value for the protocol.

    TransportDeviceName - receives the name of the TDI provider that
        will support the specified triple.

    HelperDllSocketContext - receives a context pointer that the winsock
        DLL will return to this helper DLL on future calls involving
        this socket.

    NotificationEvents - receives a bitmask of those state transitions
        this helper DLL should be notified on.

Return Value:

    INT - a winsock error code indicating the status of the operation, or
        NO_ERROR if the operation succeeded.

--*/

{
    PWSHATALK_SOCKET_CONTEXT    context;

    DBGPRINT0(("WSHOpenSocket: Entered\n"));

    //
    // Determine whether this is to be a TCP or UDP socket.
    //

    if ( IsTripleInList(
             AdspStreamMappingTriples,
             sizeof(AdspStreamMappingTriples) / sizeof(AdspStreamMappingTriples[0]),
             *AddressFamily,
             *SocketType,
             *Protocol ) )
    {
        //
        // Indicate the name of the TDI device that will service
        // SOCK_STREAM sockets in the internet address family.
        //

        RtlInitUnicodeString( TransportDeviceName, WSH_ATALK_ADSPRDM );

    }
    else if ( IsTripleInList(
                    AdspMsgMappingTriples,
                    sizeof(AdspMsgMappingTriples) / sizeof(AdspMsgMappingTriples[0]),
                    *AddressFamily,
                    *SocketType,
                    *Protocol ) )
    {
        //
        // Indicate the name of the TDI device that will service
        // SOCK_RDM sockets in the internet address family.
        //

        RtlInitUnicodeString( TransportDeviceName, WSH_ATALK_ADSPRDM );

    }
    else if ( IsTripleInList(
                    PapMsgMappingTriples,
                    sizeof(PapMsgMappingTriples) / sizeof(PapMsgMappingTriples[0]),
                    *AddressFamily,
                    *SocketType,
                    *Protocol ) )
    {
        //
        // Indicate the name of the TDI device that will service
        // SOCK_RDM sockets in the appletalk address family.
        //

        RtlInitUnicodeString( TransportDeviceName, WSH_ATALK_PAPRDM );

    }
    else
    {
        BOOLEAN tripleFound = FALSE;

        //
        // Check the DDP triples
        //

        if ( IsTripleInList(
                    DdpMappingTriples,
                    sizeof(DdpMappingTriples) / sizeof(DdpMappingTriples[0]),
                    *AddressFamily,
                    *SocketType,
                    *Protocol ) )
        {
            tripleFound = TRUE;

            //
            // Indicate the name of the TDI device that will service
            // SOCK_DGRAM sockets in the appletalk address family.
            //

            RtlInitUnicodeString(
                TransportDeviceName,
                WSH_ATALK_DGRAMDDP[(*Protocol) - ATPROTO_BASE - 1] );

            DBGPRINT0(("WSHOpenSocket: Protocol number %d index %d\n",
                        (*Protocol) , (*Protocol) - ATPROTO_BASE - 1));
        }

        //
        // This should never happen if the registry information about this
        // helper DLL is correct. If somehow this did happen, just return
        // an error.
        //

        if (!tripleFound)
        {
            return WSAEINVAL;
        }
    }

    //
    // Allocate context for this socket. The Windows Sockets DLL will
    // return this value to us when it asks us to get/set socket options.
    //

    context = RtlAllocateHeap( RtlProcessHeap( ), 0, sizeof(*context) );
    if ( context == NULL )
    {
        return WSAENOBUFS;
    }

    //
    // Initialize the context for the socket.
    //

    context->AddressFamily = *AddressFamily;
    context->SocketType = *SocketType;
    context->Protocol = *Protocol;

    //
    // Tell the Windows Sockets DLL which state transitions we're
    // interested in being notified of.
    //

    *NotificationEvents = WSH_NOTIFY_CONNECT | WSH_NOTIFY_CLOSE;

    //
    // Everything worked, return success.
    //

    *HelperDllSocketContext = context;
    return NO_ERROR;

} // WSHOpenSocket




INT
WSHNotify (
    IN  PVOID   HelperDllSocketContext,
    IN  SOCKET  SocketHandle,
    IN  HANDLE  TdiAddressObjectHandle,
    IN  HANDLE  TdiConnectionObjectHandle,
    IN  DWORD   NotifyEvent
    )

/*++

Routine Description:

    This routine is called by the winsock DLL after a state transition
    of the socket. Only state transitions returned in the
    NotificationEvents parameter of WSHOpenSocket() are notified here.
    This routine allows a winsock helper DLL to track the state of
    socket and perform necessary actions corresponding to state
    transitions.

Arguments:

    HelperDllSocketContext - the context pointer given to the winsock
        DLL by WSHOpenSocket().

    SocketHandle - the handle for the socket.

    TdiAddressObjectHandle - the TDI address object of the socket, if
        any. If the socket is not yet bound to an address, then
        it does not have a TDI address object and this parameter
        will be NULL.

    TdiConnectionObjectHandle - the TDI connection object of the socket,
        if any. If the socket is not yet connected, then it does not
        have a TDI connection object and this parameter will be NULL.

    NotifyEvent - indicates the state transition for which we're being
        called.

Return Value:

    INT - a winsock error code indicating the status of the operation, or
        NO_ERROR if the operation succeeded.

--*/

{

    PWSHATALK_SOCKET_CONTEXT context = HelperDllSocketContext;

    //
    // We should only be called after a connect() completes or when the
    // socket is being closed.
    //

    if ( NotifyEvent == WSH_NOTIFY_CONNECT )
    {
        //
        // Just for debugging right now
        //

        DBGPRINT0(("WSHNotify: Connect completed, notify called!\n"));
    }
    else if ( NotifyEvent == WSH_NOTIFY_CLOSE )
    {
        //
        // Just free the socket context.
        //

        DBGPRINT0(("WSHNotify: Close notify called!\n"));

        RtlFreeHeap( RtlProcessHeap( ), 0, HelperDllSocketContext );
    }
    else
    {
        return WSAEINVAL;
    }

    return NO_ERROR;

} // WSHNotify




INT
WSHNtStatusToWinsockErr(
    IN  NTSTATUS    Status
    )
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    INT error;

    switch (Status)
    {
        case STATUS_SUCCESS:            error = NO_ERROR;
                                        break;

        case STATUS_BUFFER_OVERFLOW:
        case STATUS_BUFFER_TOO_SMALL:   error = WSAENOBUFS;
                                        break;

        case STATUS_INVALID_ADDRESS:    error = WSAEADDRNOTAVAIL;
                                        break;
        case STATUS_SHARING_VIOLATION:  error = WSAEADDRINUSE;
                                        break;

        default:                        error = WSAEINVAL;
                                        break;
    }

    DBGPRINT0(("WSHNtStatusToWinsockErr: Converting %lx to %lx\n", Status, error));
    return(error);
}




BOOLEAN
IsTripleInList (
    IN  PMAPPING_TRIPLE List,
    IN  ULONG           ListLength,
    IN  INT             AddressFamily,
    IN  INT             SocketType,
    IN  INT             Protocol
    )
/*++

Routine Description:

    Determines whether the specified triple has an exact match in the
    list of triples.

Arguments:

    List - a list of triples (address family/socket type/protocol) to
        search.

    ListLength - the number of triples in the list.

    AddressFamily - the address family to look for in the list.

    SocketType - the socket type to look for in the list.

    Protocol - the protocol to look for in the list.

Return Value:

    BOOLEAN - TRUE if the triple was found in the list, false if not.

--*/
{
    ULONG i;

    //
    // Walk through the list searching for an exact match.
    //

    for ( i = 0; i < ListLength; i++ )
    {
        //
        // If all three elements of the triple match, return indicating
        // that the triple did exist in the list.
        //

        if ( AddressFamily == List[i].AddressFamily &&
             SocketType == List[i].SocketType &&
             Protocol == List[i].Protocol )
        {
            return TRUE;
        }
    }

    //
    // The triple was not found in the list.
    //

    return FALSE;

} // IsTripleInList




VOID
CompleteTdiActionApc (
    IN PVOID ApcContext,
    IN PIO_STATUS_BLOCK IoStatusBlock
    )
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    //
    // Just free the heap we allovcated to hold the IO status block and
    // the TDI action buffer.  There is nothing we can do if the call
    // failed.
    //

    RtlFreeHeap( RtlProcessHeap( ), 0, ApcContext );

} // CompleteTdiActionApc




BOOLEAN
WshNbpNameToMacCodePage(
    IN  OUT PWSH_NBP_NAME   pNbpName
    )
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    USHORT  destLen;
    BOOLEAN retVal  = FALSE;

    do
    {
        destLen = MAX_ENTITY;
        if (!WshConvertStringOemToMac(
                pNbpName->ObjectName,
                pNbpName->ObjectNameLen,
                pNbpName->ObjectName,
                &destLen))
        {
            break;
        }

        pNbpName->ObjectNameLen = (CHAR)destLen;

        destLen = MAX_ENTITY;
        if (!WshConvertStringOemToMac(
                pNbpName->TypeName,
                pNbpName->TypeNameLen,
                pNbpName->TypeName,
                &destLen))
        {
            break;
        }

        pNbpName->TypeNameLen   = (CHAR)destLen;

        destLen = MAX_ENTITY;
        if (!WshConvertStringOemToMac(
                pNbpName->ZoneName,
                pNbpName->ZoneNameLen,
                pNbpName->ZoneName,
                &destLen))
        {
            break;
        }

        pNbpName->ZoneNameLen   = (CHAR)destLen;
        retVal                  = TRUE;

    } while (FALSE);

    return(retVal);
}




BOOLEAN
WshNbpNameToOemCodePage(
    IN  OUT PWSH_NBP_NAME   pNbpName
    )
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    USHORT  destLen;
    BOOLEAN retVal  = FALSE;

    do
    {
        destLen = MAX_ENTITY;
        if (!WshConvertStringMacToOem(
                pNbpName->ObjectName,
                pNbpName->ObjectNameLen,
                pNbpName->ObjectName,
                &destLen))
        {
            break;
        }

        pNbpName->ObjectNameLen = (CHAR)destLen;

        destLen = MAX_ENTITY;
        if (!WshConvertStringMacToOem(
                pNbpName->TypeName,
                pNbpName->TypeNameLen,
                pNbpName->TypeName,
                &destLen))
        {
            break;
        }

        pNbpName->TypeNameLen   = (CHAR)destLen;

        destLen = MAX_ENTITY;
        if (!WshConvertStringMacToOem(
                pNbpName->ZoneName,
                pNbpName->ZoneNameLen,
                pNbpName->ZoneName,
                &destLen))
        {
            break;
        }

        pNbpName->ZoneNameLen   = (CHAR)destLen;
        retVal                  = TRUE;

    } while (FALSE);

    return(retVal);
}




BOOLEAN
WshZoneListToOemCodePage(
    IN  OUT PUCHAR      pZoneList,
    IN      USHORT      NumZones
    )
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    USHORT  zoneLen;
    BOOLEAN retVal  = TRUE;
    PUCHAR  pCurZone = pZoneList, pNextZone = NULL, pCopyZone = pZoneList;

    while (NumZones-- > 0)
    {
        zoneLen     = strlen(pCurZone) + 1;
        pNextZone   = pCurZone + zoneLen;

        //  Modify current zone. This could decrease its length
        if (!WshConvertStringMacToOem(
                pCurZone,
                zoneLen,
                pCopyZone,
                &zoneLen))
        {
            DBGPRINT(("WshZoneListToOemCodePage: FAILED %s-%d\n",
                        pCurZone, zoneLen));

            retVal  = FALSE;
            break;
        }

        pCopyZone   += zoneLen;
        pCurZone     = pNextZone;
    }

    return(retVal);
}




BOOLEAN
WshConvertStringOemToMac(
    IN  PUCHAR  pSrcOemString,
    IN  USHORT  SrcStringLen,
    OUT PUCHAR  pDestMacString,
    IN  PUSHORT pDestStringLen
    )
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    WCHAR           wcharBuf[MAX_ENTITY + 1];
    INT             wcharLen, destLen;
    BOOLEAN         retCode = TRUE;

    do
    {
        if ((SrcStringLen > (MAX_ENTITY+1)) ||
            (*pDestStringLen < SrcStringLen))
        {
            DBGPRINT(("WshConvertStringOemToMac: Invalid len %d.%d\n",
                        SrcStringLen, *pDestStringLen));

            retCode = FALSE;
            break;
        }

        //  Convert the src string using the OEM codepage.
        if ((wcharLen = MultiByteToWideChar(
                            CP_ACP,
                            MB_PRECOMPOSED,
                            pSrcOemString,
                            SrcStringLen,
                            wcharBuf,
                            MAX_ENTITY + 1)) == FALSE)
        {
            DBGPRINT(("WshConvertStringOemToMac: FAILED mbtowcs %s-%d\n",
                        pSrcOemString, SrcStringLen));

            retCode = FALSE;
            break;
        }

        DBGPRINT0(("WshConvertStringOemToMac: Converting mbtowcs %s-%d\n",
                    pSrcOemString, SrcStringLen));
        //  Convert the wide char string to mac ansi string.
        if ((destLen = WideCharToMultiByte(
                            WshMacCodePage,
                            0,
                            wcharBuf,
                            wcharLen,
                            pDestMacString,
                            *pDestStringLen,
                            NULL,
                            NULL)) == FALSE)
        {
            DBGPRINT(("WshConvertStringOemToMac: FAILED wctomb %s-%d\n",
                        pDestMacString, *pDestStringLen));

            retCode = FALSE;
            break;
        }

        *pDestStringLen = (USHORT)destLen;

        DBGPRINT0(("WshConvertStringOemToMac: Converted mbtowcs %s-%d\n",
                    pDestMacString, *pDestStringLen));


    } while (FALSE);

    return(retCode);
}




BOOLEAN
WshConvertStringMacToOem(
    IN  PUCHAR  pSrcMacString,
    IN  USHORT  SrcStringLen,
    OUT PUCHAR  pDestOemString,
    IN  PUSHORT pDestStringLen
    )
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    WCHAR           wcharBuf[MAX_ENTITY + 1];
    INT             wcharLen, destLen;
    BOOLEAN         retCode = TRUE;

    do
    {
        if ((SrcStringLen > (MAX_ENTITY+1)) ||
            (*pDestStringLen < SrcStringLen))
        {
            retCode = FALSE;
            break;
        }

        //  Convert the src string using the MAC codepage.
        if ((wcharLen = MultiByteToWideChar(
                            WshMacCodePage,
                            MB_PRECOMPOSED,
                            pSrcMacString,
                            SrcStringLen,
                            wcharBuf,
                            MAX_ENTITY + 1)) == FALSE)
        {
            DBGPRINT(("WshConvertStringMacToOem: FAILED mbtowcs %s-%d\n",
                        pSrcMacString, SrcStringLen));

            retCode = FALSE;
            break;
        }

        DBGPRINT0(("WshConvertStringMacToOem: Converting mbtowcs %s-%d\n",
                    pSrcMacString, SrcStringLen));

        //  Convert the wide char string to mac ansi string.
        if ((destLen = WideCharToMultiByte(
                            CP_ACP,
                            0,
                            wcharBuf,
                            wcharLen,
                            pDestOemString,
                            *pDestStringLen,
                            NULL,
                            NULL)) == FALSE)
        {
            DBGPRINT(("WshConvertStringMacToOem: FAILED wctomb %s-%d\n",
                        pDestOemString, *pDestStringLen));

            retCode = FALSE;
            break;
        }

        *pDestStringLen = (USHORT)destLen;

        DBGPRINT0(("WshConvertStringMacToOem: Converted mbtowcs %s-%d\n",
                    pDestOemString, *pDestStringLen));
    } while (FALSE);

    return(retCode);
}




BOOLEAN
WshRegGetCodePage(
    VOID
    )
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    DWORD           dwRetCode;
    HKEY            hkeyCodepagePath;
    DWORD           dwType;
    DWORD           dwBufSize;
    WCHAR           wchCodepageNum[60];
    UNICODE_STRING  wchUnicodeCodePage;
    NTSTATUS        status;

    // Open the key
    if (dwRetCode = RegOpenKeyEx(
                        HKEY_LOCAL_MACHINE,
                        WSH_KEYPATH_CODEPAGE,
                        0,
                        KEY_QUERY_VALUE,
                        &hkeyCodepagePath))
        return(FALSE);


    // Get the Code page number value for the Mac
    dwBufSize = sizeof(wchCodepageNum);
    if (dwRetCode = RegQueryValueEx(
                        hkeyCodepagePath,
                        WSHREG_VALNAME_CODEPAGE,
                        NULL,
                        &dwType,
                        (LPBYTE)wchCodepageNum,
                        &dwBufSize))
    {
        RegCloseKey(hkeyCodepagePath);
        return(FALSE);
    }

    // Close the key
    RegCloseKey(hkeyCodepagePath);

    //  Convert the code page to a numerical value
    RtlInitUnicodeString(&wchUnicodeCodePage, wchCodepageNum);
    status  = RtlUnicodeStringToInteger(
                &wchUnicodeCodePage,
                DECIMAL_BASE,
                &WshMacCodePage);

    DBGPRINT0(("WSHGetCodePage %lx.%d\n", WshMacCodePage, WshMacCodePage));

    return(NT_SUCCESS(status));
}


INT
WSHEnumProtocols (
    IN LPINT lpiProtocols,
    IN LPTSTR lpTransportKeyName,       // unused
    IN OUT LPVOID lpProtocolBuffer,
    IN OUT LPDWORD lpdwBufferLength
    )
/*++

Routine Description:

    This routine returns information about the protocols active on the local host.
Arguments:

    lpiProtocols - a NULL terminated array of protocol ids.  This parameter
        is optional; if NULL, information on all available protocols is returned.

    lpTransportKeyName -  unused

    lpProtocolBuffer - a buffer which is filled with PROTOCOL_INFO structures.

    lpdwBufferLength - on input, the count of bytes in the lpProtocolBuffer passed
        to EnumProtocols.  On output, the minimum buffersize that can be passed to
        EnumProtocols to retrieve all the requested information.  This routine has
        no ability to enumerate over multiple calls; the passed in buffer must be
        large enough to hold all entries in order for the routine to succeed.

Return Value:
    If no error occurs, it returns the number of PROTOCOL_INFO structures written to
    the lpProtocolBuffer buffer.  If there is an error, returns SOCKET_ERROR (-1) and
    a specific error code is retrieved with the GetLastError() API.


--*/
{
    DWORD bytesRequired;
    PPROTOCOL_INFO NextProtocolInfo;
    LPWSTR NextName;
    BOOL usePap = FALSE;
    BOOL useAdsp = FALSE;
    BOOL useRtmp = FALSE;
    BOOL useZip = FALSE;
    DWORD i, numRequested = 0;

    lpTransportKeyName;         // Avoid compiler warnings for unused parm

    //
    // Make sure that the caller cares about PAP and/or ADSP
    //

    if ( ARGUMENT_PRESENT( lpiProtocols ) )
    {
        for ( i = 0; lpiProtocols[i] != 0; i++ )
        {
            if ( lpiProtocols[i] == ATPROTO_ADSP )
            {
                useAdsp = TRUE;
                numRequested += 1;
            }
            if ( lpiProtocols[i] == ATPROTO_PAP )
            {
                usePap = TRUE;
                numRequested += 1;
            }
            if ( lpiProtocols[i] == DDPPROTO_RTMP )
            {
                useRtmp = TRUE;
                numRequested += 1;
            }
            if ( lpiProtocols[i] == DDPPROTO_ZIP )
            {
                useZip = TRUE;
                numRequested += 1;
            }
        }

    } else
    {
        usePap = TRUE;
        useAdsp = TRUE;
        useRtmp = TRUE;
        useZip = TRUE;
        numRequested = 4;
    }

    if ( !usePap && !useAdsp && !useRtmp && !useZip)
    {
        *lpdwBufferLength = 0;
        return 0;
    }

    //
    // Make sure that the caller has specified a sufficiently large
    // buffer.
    //

    bytesRequired = (sizeof(PROTOCOL_INFO) * numRequested);
    if (useAdsp)
    {
        bytesRequired += sizeof( ADSP_NAME );
    }
    if (usePap)
    {
        bytesRequired += sizeof( PAP_NAME );
    }
    if (useRtmp)
    {
        bytesRequired += sizeof( RTMP_NAME );
    }
    if (useZip)
    {
        bytesRequired += sizeof( ZIP_NAME );
    }

    if ( bytesRequired > *lpdwBufferLength )
    {
        *lpdwBufferLength = bytesRequired;
        return -1;
    }

    NextProtocolInfo = lpProtocolBuffer;
    NextName = (LPWSTR)( (LPBYTE)lpProtocolBuffer + *lpdwBufferLength );

    //
    // Fill in ADSP info, if requested.
    //

    if ( useAdsp ) {

        // Adsp - note that even though we return iSocketType of SOCK_RDM, the
        // fact that the XP_PSUEDO_STREAM service flag is set tells the caller
        // they can actually open a adsp socket in SOCK_STREAM mode as well.
        NextName -= sizeof( ADSP_NAME )/sizeof(WCHAR);

        NextProtocolInfo->dwServiceFlags = XP_EXPEDITED_DATA |
                                           XP_GUARANTEED_ORDER |
                                           XP_GUARANTEED_DELIVERY |
                                           XP_MESSAGE_ORIENTED |
                                           XP_PSEUDO_STREAM |
                                           XP_GRACEFUL_CLOSE;

        NextProtocolInfo->iAddressFamily = AF_APPLETALK;
        NextProtocolInfo->iMaxSockAddr = sizeof(SOCKADDR_AT);
        NextProtocolInfo->iMinSockAddr = sizeof(SOCKADDR_AT);
        NextProtocolInfo->iSocketType = SOCK_RDM;
        NextProtocolInfo->iProtocol = ATPROTO_ADSP;
        NextProtocolInfo->dwMessageSize = 65535;
        NextProtocolInfo->lpProtocol = NextName;
        lstrcpyW( NextProtocolInfo->lpProtocol, ADSP_NAME );

        NextProtocolInfo++;
    }

    //
    // Fill in PAP info, if requested.
    //

    if ( usePap ) {

        NextName -= sizeof( PAP_NAME )/sizeof(WCHAR);

        NextProtocolInfo->dwServiceFlags = XP_MESSAGE_ORIENTED |
                                          XP_GUARANTEED_DELIVERY |
                                          XP_GUARANTEED_ORDER |
                                          XP_GRACEFUL_CLOSE;
        NextProtocolInfo->iAddressFamily = AF_APPLETALK;
        NextProtocolInfo->iMaxSockAddr = sizeof(SOCKADDR_AT);
        NextProtocolInfo->iMinSockAddr = sizeof(SOCKADDR_AT);
        NextProtocolInfo->iSocketType = SOCK_RDM;
        NextProtocolInfo->iProtocol = ATPROTO_PAP;
        NextProtocolInfo->dwMessageSize = 4096;
        NextProtocolInfo->lpProtocol = NextName;
        lstrcpyW( NextProtocolInfo->lpProtocol, PAP_NAME );

        NextProtocolInfo++;
    }

    if ( useRtmp ) {

        NextName -= sizeof( RTMP_NAME )/sizeof(WCHAR);

        NextProtocolInfo->dwServiceFlags = XP_CONNECTIONLESS;
        NextProtocolInfo->iAddressFamily = AF_APPLETALK;
        NextProtocolInfo->iMaxSockAddr = sizeof(SOCKADDR_AT);
        NextProtocolInfo->iMinSockAddr = sizeof(SOCKADDR_AT);
        NextProtocolInfo->iSocketType = SOCK_DGRAM;
        NextProtocolInfo->iProtocol = DDPPROTO_RTMP;
        NextProtocolInfo->dwMessageSize = 0;
        NextProtocolInfo->lpProtocol = NextName;
        lstrcpyW( NextProtocolInfo->lpProtocol, RTMP_NAME );

        NextProtocolInfo++;

    }

    if ( useZip ) {

        NextName -= sizeof( ZIP_NAME )/sizeof(WCHAR);

        NextProtocolInfo->dwServiceFlags = XP_CONNECTIONLESS;
        NextProtocolInfo->iAddressFamily = AF_APPLETALK;
        NextProtocolInfo->iMaxSockAddr = sizeof(SOCKADDR_AT);
        NextProtocolInfo->iMinSockAddr = sizeof(SOCKADDR_AT);
        NextProtocolInfo->iSocketType = SOCK_DGRAM;
        NextProtocolInfo->iProtocol = DDPPROTO_ZIP;
        NextProtocolInfo->dwMessageSize = 0;
        NextProtocolInfo->lpProtocol = NextName;
        lstrcpyW( NextProtocolInfo->lpProtocol, ZIP_NAME );

        NextProtocolInfo++;

    }

    *lpdwBufferLength = bytesRequired;

    return numRequested;

} // WSHEnumProtocols


BOOL FAR PASCAL
WshDllInitialize(
    HINSTANCE   hInstance,
    DWORD       nReason,
    LPVOID      pReserved
    )
/*++

Routine Description:

    SYNOPSIS:   This DLL entry point is called when processes & threads
                are initialized and terminated, or upon calls to
                LoadLibrary() and FreeLibrary().

Arguments:

    ENTRY:    hInstance             - A handle to the DLL.

                nReason              - Indicates why the DLL entry
                                          point is being called.

                pReserved               - Reserved.

Return Value:

    RETURNS:    BOOL                    - TRUE  = DLL init was successful.
                                          FALSE = DLL init failed.

    NOTES:    The return value is only relevant during processing of
                DLL_PROCESS_ATTACH notifications.

--*/
{
    BOOL fResult = TRUE;

    UNREFERENCED_PARAMETER( pReserved );

    switch( nReason  )
    {
      case DLL_PROCESS_ATTACH:
        //
        //  This notification indicates that the DLL is attaching to
        //  the address space of the current process.  This is either
        //  the result of the process starting up, or after a call to
        //  LoadLibrary().  The DLL should us this as a hook to
        //  initialize any instance data or to allocate a TLS index.
        //
        //  This call is made in the context of the thread that
        //  caused the process address space to change.
        //

        fResult = WshRegGetCodePage();
        break;

      case DLL_PROCESS_DETACH:
        //
        //  This notification indicates that the calling process is
        //  detaching the DLL from its address space.  This is either
        //  due to a clean process exit or from a FreeLibrary() call.
        //  The DLL should use this opportunity to return any TLS
        //  indexes allocated and to free any thread local data.
        //
        //  Note that this notification is posted only once per
        //  process.  Individual threads do not invoke the
        //  DLL_THREAD_DETACH notification.
        //

        break;

      case DLL_THREAD_ATTACH:
        //
        //  This notfication indicates that a new thread is being
        //  created in the current process.  All DLLs attached to
        //  the process at the time the thread starts will be
        //  notified.  The DLL should use this opportunity to
        //  initialize a TLS slot for the thread.
        //
        //  Note that the thread that posts the DLL_PROCESS_ATTACH
        //  notification will not post a DLL_THREAD_ATTACH.
        //
        //  Note also that after a DLL is loaded with LoadLibrary,
        //  only threads created after the DLL is loaded will
        //  post this notification.
        //

        break;

      case DLL_THREAD_DETACH:
        //
        //  This notification indicates that a thread is exiting
        //  cleanly.  The DLL should use this opportunity to
        //  free any data stored in TLS indices.
        //

        break;

    default:
        //
        //  Who knows?  Just ignore it.
        //

        break;
    }

    return fResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\setup\resource\sfmres.h ===
/*
**	PushButton Control IDs
*/
_dt_public
#define IDC_A        401
_dt_public
#define IDC_B        402
_dt_public
#define IDC_C        403
_dt_public
#define IDC_D        404
_dt_public
#define IDC_E        405
_dt_public
#define IDC_F        406
_dt_public
#define IDC_G        407
_dt_public
#define IDC_H        408
_dt_public
#define IDC_I        409
_dt_public
#define IDC_J        410
_dt_public
#define IDC_K        411
_dt_public
#define IDC_L        412
_dt_public
#define IDC_M        413
_dt_public
#define IDC_N        414
_dt_public
#define IDC_O        415
_dt_public
#define IDC_P        416
_dt_public
#define IDC_Q        417
_dt_public
#define IDC_R        418
_dt_public
#define IDC_S        419
_dt_public
#define IDC_T        420
_dt_public
#define IDC_U        421
_dt_public
#define IDC_V        422
_dt_public
#define IDC_W        423
_dt_public
#define IDC_X        424
_dt_public
#define IDC_Y        425
_dt_public
#define IDC_Z        426


/*
**	Text Control IDs
*/
_dt_public
#define IDC_TEXT1    431
_dt_public
#define IDC_TEXT2    432
_dt_public
#define IDC_TEXT3    433
_dt_public
#define IDC_TEXT4    434
_dt_public
#define IDC_TEXT5    435
_dt_public
#define IDC_TEXT6    436
_dt_public
#define IDC_TEXT7    437
_dt_public
#define IDC_TEXT8    438
_dt_public
#define IDC_TEXT9    439
_dt_public
#define IDC_TEXT10   440
_dt_public
#define IDC_TEXT11   441


/*
**	Radio and Checkbox Button Control IDs
*/
_dt_public
#define IDC_B0       450
_dt_public
#define IDC_B1       451
_dt_public
#define IDC_B2       452
_dt_public
#define IDC_B3       453
_dt_public
#define IDC_B4       454
_dt_public
#define IDC_B5       455
_dt_public
#define IDC_B6       456
_dt_public
#define IDC_B7       457
_dt_public
#define IDC_B8       458
_dt_public
#define IDC_B9       459
_dt_public
#define IDC_B10      460

_dt_public
#define IDC_RB0       610
_dt_public
#define IDC_RB1       611
_dt_public
#define IDC_RB2       612
_dt_public
#define IDC_RB3       613
_dt_public
#define IDC_RB4       614
_dt_public
#define IDC_RB5       615
_dt_public
#define IDC_RB6       616
_dt_public
#define IDC_RB7       617
_dt_public
#define IDC_RB8       618
_dt_public
#define IDC_RB9       619
_dt_public
#define IDC_RB10      620


/*
**	Combo box IDs
*/
_dt_public
#define IDC_COMBO0   480
_dt_public
#define IDC_COMBO1   481
_dt_public
#define IDC_COMBO2   482
_dt_public
#define IDC_COMBO3   483
_dt_public
#define IDC_COMBO4   484
_dt_public
#define IDC_COMBO5   485
_dt_public
#define IDC_COMBO6   486
_dt_public
#define IDC_COMBO7   487
_dt_public
#define IDC_COMBO8   488
_dt_public
#define IDC_COMBO9   489

/*
**	ICON IDs
*/
_dt_public
#define IDC_ICON0    500
_dt_public
#define IDC_ICON1    501
_dt_public
#define IDC_ICON2    502
_dt_public
#define IDC_ICON3    503
_dt_public
#define IDC_ICON4    504
_dt_public
#define IDC_ICON5    505
_dt_public
#define IDC_ICON6    506
_dt_public
#define IDC_ICON7    507
_dt_public
#define IDC_ICON8    508
_dt_public
#define IDC_ICON9    509

/*
** SPECIAL PUSHBUTTONS
*/

_dt_public
#define IDC_SP1    521
_dt_public
#define IDC_SP2    522
_dt_public
#define IDC_SP3    523
_dt_public
#define IDC_SP4    524
_dt_public
#define IDC_SP5    525
_dt_public
#define IDC_SP6    526
_dt_public
#define IDC_SP7    527
_dt_public
#define IDC_SP8    528
_dt_public
#define IDC_SP9    529
_dt_public
#define IDC_SP10   530

/*
** STATUS TEXT FIELDS
*/

_dt_public
#define IDC_STATUS1    541
_dt_public
#define IDC_STATUS2    542
_dt_public
#define IDC_STATUS3    543
_dt_public
#define IDC_STATUS4    544
_dt_public
#define IDC_STATUS5    545
_dt_public
#define IDC_STATUS6    546
_dt_public
#define IDC_STATUS7    547
_dt_public
#define IDC_STATUS8    548
_dt_public
#define IDC_STATUS9    549
_dt_public
#define IDC_STATUS10   550



/*
** SIZE FIELDS ASSOCIATED WITH CHECK OPTIONAL COMPONENTS
*/

_dt_public
#define IDC_SIZE1    551
_dt_public
#define IDC_SIZE2    552
_dt_public
#define IDC_SIZE3    553
_dt_public
#define IDC_SIZE4    554
_dt_public
#define IDC_SIZE5    555
_dt_public
#define IDC_SIZE6    556
_dt_public
#define IDC_SIZE7    557
_dt_public
#define IDC_SIZE8    558
_dt_public
#define IDC_SIZE9    559
_dt_public
#define IDC_SIZE10   560



/*
** TOTALS OF SIZES
*/

_dt_public
#define IDC_TOTAL1    561
_dt_public
#define IDC_TOTAL2    562
_dt_public
#define IDC_TOTAL3    563
_dt_public
#define IDC_TOTAL4    564
_dt_public
#define IDC_TOTAL5    565
_dt_public
#define IDC_TOTAL6    566
_dt_public
#define IDC_TOTAL7    567
_dt_public
#define IDC_TOTAL8    568
_dt_public
#define IDC_TOTAL9    569
_dt_public
#define IDC_TOTAL10   570

/*
** MAXIMUM SIZES
*/

_dt_public
#define IDC_MAX1    571
_dt_public
#define IDC_MAX2    572
_dt_public
#define IDC_MAX3    573
_dt_public
#define IDC_MAX4    574
_dt_public
#define IDC_MAX5    575
_dt_public
#define IDC_MAX6    576
_dt_public
#define IDC_MAX7    577
_dt_public
#define IDC_MAX8    578
_dt_public
#define IDC_MAX9    579
_dt_public
#define IDC_MAX10   580

/*
**	Edit Control IDs
*/

#define IDC_EDIT1   581
#define IDC_EDIT2   582
#define IDC_EDIT3   583
#define IDC_EDIT4   584
#define IDC_EDIT5   585
#define IDC_EDIT6   586
#define IDC_EDIT7   587
#define IDC_EDIT8   588
#define IDC_EDIT9   589
#define IDC_EDIT10  590

/*
**	ListBox Control IDs
*/

#define IDC_LIST1   591
#define IDC_LIST2   592
#define IDC_LIST3   593
#define IDC_LIST4   594
#define IDC_LIST5   595
#define IDC_LIST6   596
#define IDC_LIST7   597
#define IDC_LIST8   598
#define IDC_LIST9   599
#define IDC_LIST10  600


/*
** MENU IDS
*/

#define ID_MAINTAIN  651
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\setup\sfmreg\sfmreg.c ===
/*
 * This util is used by the batch file that a user uses to copy
 * admin tools from the NT Server CD to a NT Workstation.
 * This tool is used to add the File Manager and Server Manager
 * extensions for MacFile.
 *
 * Usage: sfmreg.reg SMAddons sfmmgr.dll ntnet.ini
 *        sfmreg.reg Addons   sfmmgr.dll winfile.ini
 *
 * Author: Ram Cherala Feb 24th 95  Copied from test\util\afpini
 *
 */

#define DOSWIN32

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <lmerr.h>

extern BOOL FAR PASCAL WriteAfpMgrIniStrings (
	DWORD	nArgs,
	LPSTR	apszArgs[],
	LPSTR   *ppszResult
);

extern int CDECL main(int argc, char *argv[]);

int CDECL
main (int argc, char *argv[])
{
    TCHAR   ResultBuffer[1024];

    // go past the file name argument

	 argc--;
	 ++argv;


	if(WriteAfpMgrIniStrings(argc, argv , (LPSTR*) &ResultBuffer))
   {
      return(0);
   }
   else
   {
      return(1);
   }
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\atalk\winsock\wshdata.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

	wshdata.h

Abstract:


Author:

	Nikhil Kamkolkar (nikhilk@microsoft.com)

Revision History:
	10 Jul 1992	Initial Version

--*/




MAPPING_TRIPLE AdspStreamMappingTriples[] =
		{
			AF_APPLETALK,	SOCK_STREAM,	ATPROTO_ADSP
		};

MAPPING_TRIPLE AdspMsgMappingTriples[] =
		{
			AF_APPLETALK,	SOCK_RDM,		ATPROTO_ADSP
		};

MAPPING_TRIPLE PapMsgMappingTriples[] =
		{
			AF_APPLETALK,	SOCK_RDM,		ATPROTO_PAP
		};

//	This will handle protocol types from 1 to 255. Note the actual numberical
//	values are (ATPROTO_BASE + desired protocol number).
//	NOTE: Protocol 0 is not valid.

MAPPING_TRIPLE	DdpMappingTriples[] =
	{
		AF_APPLETALK,	SOCK_DGRAM,	(DDPPROTO_RTMP),
		AF_APPLETALK,	SOCK_DGRAM,	(DDPPROTO_NBP),
		AF_APPLETALK,	SOCK_DGRAM,	(DDPPROTO_ATP),
		AF_APPLETALK,	SOCK_DGRAM,	(DDPPROTO_AEP),
		AF_APPLETALK,	SOCK_DGRAM,	(DDPPROTO_RTMPRQ),
		AF_APPLETALK,	SOCK_DGRAM,	(DDPPROTO_ZIP),
		AF_APPLETALK,	SOCK_DGRAM,	(DDPPROTO_ADSP),

		//
		//	Now the other protocol types that are not
		//	defined yet - what about aurp? It runs on
		//	top of ddp and is the appletalk update
		//	based routing protocol
		//

		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 8),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 9),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 10),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 11),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 12),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 13),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 14),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 15),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 16),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 17),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 18),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 19),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 20),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 21),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 22),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 23),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 24),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 25),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 26),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 27),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 28),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 29),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 30),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 31),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 32),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 33),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 34),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 35),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 36),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 37),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 38),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 39),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 40),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 41),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 42),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 43),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 44),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 45),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 46),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 47),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 48),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 49),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 50),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 51),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 52),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 53),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 54),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 55),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 56),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 57),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 58),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 59),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 60),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 61),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 62),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 63),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 64),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 65),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 66),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 67),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 68),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 69),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 70),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 71),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 72),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 73),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 74),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 75),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 76),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 77),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 78),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 79),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 80),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 81),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 82),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 83),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 84),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 85),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 86),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 87),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 88),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 89),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 90),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 91),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 92),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 93),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 94),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 95),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 96),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 97),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 98),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 99),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 100),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 101),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 102),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 103),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 104),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 105),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 106),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 107),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 108),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 109),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 110),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 111),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 112),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 113),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 114),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 115),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 116),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 117),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 118),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 119),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 120),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 121),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 122),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 123),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 124),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 125),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 126),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 127),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 128),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 129),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 130),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 131),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 132),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 133),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 134),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 135),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 136),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 137),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 138),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 139),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 140),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 141),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 142),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 143),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 144),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 145),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 146),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 147),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 148),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 149),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 150),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 151),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 152),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 153),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 154),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 155),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 156),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 157),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 158),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 159),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 160),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 161),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 162),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 163),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 164),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 165),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 166),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 167),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 168),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 169),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 170),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 171),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 172),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 173),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 174),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 175),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 176),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 177),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 178),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 179),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 180),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 181),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 182),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 183),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 184),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 185),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 186),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 187),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 188),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 189),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 190),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 191),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 192),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 193),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 194),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 195),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 196),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 197),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 198),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 199),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 200),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 201),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 202),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 203),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 204),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 205),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 206),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 207),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 208),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 209),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 210),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 211),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 212),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 213),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 214),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 215),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 216),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 217),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 218),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 219),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 220),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 221),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 222),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 223),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 224),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 225),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 226),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 227),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 228),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 229),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 230),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 231),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 232),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 233),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 234),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 235),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 236),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 237),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 238),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 239),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 240),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 241),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 242),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 243),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 244),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 245),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 246),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 247),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 248),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 249),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 250),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 251),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 252),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 253),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 254),
		AF_APPLETALK,	SOCK_DGRAM,	(ATPROTO_BASE + 255),
};


// Protocol type should be at the end - we cannot dynamically do this,	due to the
// assumption that this memory will never need to be freed by the Winsock dll.
//
// Protocol type 0 is not valid.

PWCHAR		WSH_ATALK_DGRAMDDP[DDPPROTO_MAX] =
	{
		L"\\Device\\AtalkDdp\\1",
		L"\\Device\\AtalkDdp\\2",
		L"\\Device\\AtalkDdp\\3",
		L"\\Device\\AtalkDdp\\4",
		L"\\Device\\AtalkDdp\\5",
		L"\\Device\\AtalkDdp\\6",
		L"\\Device\\AtalkDdp\\7",
		L"\\Device\\AtalkDdp\\8",
		L"\\Device\\AtalkDdp\\9",
		L"\\Device\\AtalkDdp\\10",
		L"\\Device\\AtalkDdp\\11",
		L"\\Device\\AtalkDdp\\12",
		L"\\Device\\AtalkDdp\\13",
		L"\\Device\\AtalkDdp\\14",
		L"\\Device\\AtalkDdp\\15",
		L"\\Device\\AtalkDdp\\16",
		L"\\Device\\AtalkDdp\\17",
		L"\\Device\\AtalkDdp\\18",
		L"\\Device\\AtalkDdp\\19",
		L"\\Device\\AtalkDdp\\20",
		L"\\Device\\AtalkDdp\\21",
		L"\\Device\\AtalkDdp\\22",
		L"\\Device\\AtalkDdp\\23",
		L"\\Device\\AtalkDdp\\24",
		L"\\Device\\AtalkDdp\\25",
		L"\\Device\\AtalkDdp\\26",
		L"\\Device\\AtalkDdp\\27",
		L"\\Device\\AtalkDdp\\28",
		L"\\Device\\AtalkDdp\\29",
		L"\\Device\\AtalkDdp\\30",
		L"\\Device\\AtalkDdp\\31",
		L"\\Device\\AtalkDdp\\32",
		L"\\Device\\AtalkDdp\\33",
		L"\\Device\\AtalkDdp\\34",
		L"\\Device\\AtalkDdp\\35",
		L"\\Device\\AtalkDdp\\36",
		L"\\Device\\AtalkDdp\\37",
		L"\\Device\\AtalkDdp\\38",
		L"\\Device\\AtalkDdp\\39",
		L"\\Device\\AtalkDdp\\40",
		L"\\Device\\AtalkDdp\\41",
		L"\\Device\\AtalkDdp\\42",
		L"\\Device\\AtalkDdp\\43",
		L"\\Device\\AtalkDdp\\44",
		L"\\Device\\AtalkDdp\\45",
		L"\\Device\\AtalkDdp\\46",
		L"\\Device\\AtalkDdp\\47",
		L"\\Device\\AtalkDdp\\48",
		L"\\Device\\AtalkDdp\\49",
		L"\\Device\\AtalkDdp\\50",
		L"\\Device\\AtalkDdp\\51",
		L"\\Device\\AtalkDdp\\52",
		L"\\Device\\AtalkDdp\\53",
		L"\\Device\\AtalkDdp\\54",
		L"\\Device\\AtalkDdp\\55",
		L"\\Device\\AtalkDdp\\56",
		L"\\Device\\AtalkDdp\\57",
		L"\\Device\\AtalkDdp\\58",
		L"\\Device\\AtalkDdp\\59",
		L"\\Device\\AtalkDdp\\60",
		L"\\Device\\AtalkDdp\\61",
		L"\\Device\\AtalkDdp\\62",
		L"\\Device\\AtalkDdp\\63",
		L"\\Device\\AtalkDdp\\64",
		L"\\Device\\AtalkDdp\\65",
		L"\\Device\\AtalkDdp\\66",
		L"\\Device\\AtalkDdp\\67",
		L"\\Device\\AtalkDdp\\68",
		L"\\Device\\AtalkDdp\\69",
		L"\\Device\\AtalkDdp\\70",
		L"\\Device\\AtalkDdp\\71",
		L"\\Device\\AtalkDdp\\72",
		L"\\Device\\AtalkDdp\\73",
		L"\\Device\\AtalkDdp\\74",
		L"\\Device\\AtalkDdp\\75",
		L"\\Device\\AtalkDdp\\76",
		L"\\Device\\AtalkDdp\\77",
		L"\\Device\\AtalkDdp\\78",
		L"\\Device\\AtalkDdp\\79",
		L"\\Device\\AtalkDdp\\80",
		L"\\Device\\AtalkDdp\\81",
		L"\\Device\\AtalkDdp\\82",
		L"\\Device\\AtalkDdp\\83",
		L"\\Device\\AtalkDdp\\84",
		L"\\Device\\AtalkDdp\\85",
		L"\\Device\\AtalkDdp\\86",
		L"\\Device\\AtalkDdp\\87",
		L"\\Device\\AtalkDdp\\88",
		L"\\Device\\AtalkDdp\\89",
		L"\\Device\\AtalkDdp\\90",
		L"\\Device\\AtalkDdp\\91",
		L"\\Device\\AtalkDdp\\92",
		L"\\Device\\AtalkDdp\\93",
		L"\\Device\\AtalkDdp\\94",
		L"\\Device\\AtalkDdp\\95",
		L"\\Device\\AtalkDdp\\96",
		L"\\Device\\AtalkDdp\\97",
		L"\\Device\\AtalkDdp\\98",
		L"\\Device\\AtalkDdp\\99",
		L"\\Device\\AtalkDdp\\100",
		L"\\Device\\AtalkDdp\\101",
		L"\\Device\\AtalkDdp\\102",
		L"\\Device\\AtalkDdp\\103",
		L"\\Device\\AtalkDdp\\104",
		L"\\Device\\AtalkDdp\\105",
		L"\\Device\\AtalkDdp\\106",
		L"\\Device\\AtalkDdp\\107",
		L"\\Device\\AtalkDdp\\108",
		L"\\Device\\AtalkDdp\\109",
		L"\\Device\\AtalkDdp\\110",
		L"\\Device\\AtalkDdp\\111",
		L"\\Device\\AtalkDdp\\112",
		L"\\Device\\AtalkDdp\\113",
		L"\\Device\\AtalkDdp\\114",
		L"\\Device\\AtalkDdp\\115",
		L"\\Device\\AtalkDdp\\116",
		L"\\Device\\AtalkDdp\\117",
		L"\\Device\\AtalkDdp\\118",
		L"\\Device\\AtalkDdp\\119",
		L"\\Device\\AtalkDdp\\120",
		L"\\Device\\AtalkDdp\\121",
		L"\\Device\\AtalkDdp\\122",
		L"\\Device\\AtalkDdp\\123",
		L"\\Device\\AtalkDdp\\124",
		L"\\Device\\AtalkDdp\\125",
		L"\\Device\\AtalkDdp\\126",
		L"\\Device\\AtalkDdp\\127",
		L"\\Device\\AtalkDdp\\128",
		L"\\Device\\AtalkDdp\\129",
		L"\\Device\\AtalkDdp\\130",
		L"\\Device\\AtalkDdp\\131",
		L"\\Device\\AtalkDdp\\132",
		L"\\Device\\AtalkDdp\\133",
		L"\\Device\\AtalkDdp\\134",
		L"\\Device\\AtalkDdp\\135",
		L"\\Device\\AtalkDdp\\136",
		L"\\Device\\AtalkDdp\\137",
		L"\\Device\\AtalkDdp\\138",
		L"\\Device\\AtalkDdp\\139",
		L"\\Device\\AtalkDdp\\140",
		L"\\Device\\AtalkDdp\\141",
		L"\\Device\\AtalkDdp\\142",
		L"\\Device\\AtalkDdp\\143",
		L"\\Device\\AtalkDdp\\144",
		L"\\Device\\AtalkDdp\\145",
		L"\\Device\\AtalkDdp\\146",
		L"\\Device\\AtalkDdp\\147",
		L"\\Device\\AtalkDdp\\148",
		L"\\Device\\AtalkDdp\\149",
		L"\\Device\\AtalkDdp\\150",
		L"\\Device\\AtalkDdp\\151",
		L"\\Device\\AtalkDdp\\152",
		L"\\Device\\AtalkDdp\\153",
		L"\\Device\\AtalkDdp\\154",
		L"\\Device\\AtalkDdp\\155",
		L"\\Device\\AtalkDdp\\156",
		L"\\Device\\AtalkDdp\\157",
		L"\\Device\\AtalkDdp\\158",
		L"\\Device\\AtalkDdp\\159",
		L"\\Device\\AtalkDdp\\160",
		L"\\Device\\AtalkDdp\\161",
		L"\\Device\\AtalkDdp\\162",
		L"\\Device\\AtalkDdp\\163",
		L"\\Device\\AtalkDdp\\164",
		L"\\Device\\AtalkDdp\\165",
		L"\\Device\\AtalkDdp\\166",
		L"\\Device\\AtalkDdp\\167",
		L"\\Device\\AtalkDdp\\168",
		L"\\Device\\AtalkDdp\\169",
		L"\\Device\\AtalkDdp\\170",
		L"\\Device\\AtalkDdp\\171",
		L"\\Device\\AtalkDdp\\172",
		L"\\Device\\AtalkDdp\\173",
		L"\\Device\\AtalkDdp\\174",
		L"\\Device\\AtalkDdp\\175",
		L"\\Device\\AtalkDdp\\176",
		L"\\Device\\AtalkDdp\\177",
		L"\\Device\\AtalkDdp\\178",
		L"\\Device\\AtalkDdp\\179",
		L"\\Device\\AtalkDdp\\180",
		L"\\Device\\AtalkDdp\\181",
		L"\\Device\\AtalkDdp\\182",
		L"\\Device\\AtalkDdp\\183",
		L"\\Device\\AtalkDdp\\184",
		L"\\Device\\AtalkDdp\\185",
		L"\\Device\\AtalkDdp\\186",
		L"\\Device\\AtalkDdp\\187",
		L"\\Device\\AtalkDdp\\188",
		L"\\Device\\AtalkDdp\\189",
		L"\\Device\\AtalkDdp\\190",
		L"\\Device\\AtalkDdp\\191",
		L"\\Device\\AtalkDdp\\192",
		L"\\Device\\AtalkDdp\\193",
		L"\\Device\\AtalkDdp\\194",
		L"\\Device\\AtalkDdp\\195",
		L"\\Device\\AtalkDdp\\196",
		L"\\Device\\AtalkDdp\\197",
		L"\\Device\\AtalkDdp\\198",
		L"\\Device\\AtalkDdp\\199",
		L"\\Device\\AtalkDdp\\200",
		L"\\Device\\AtalkDdp\\201",
		L"\\Device\\AtalkDdp\\202",
		L"\\Device\\AtalkDdp\\203",
		L"\\Device\\AtalkDdp\\204",
		L"\\Device\\AtalkDdp\\205",
		L"\\Device\\AtalkDdp\\206",
		L"\\Device\\AtalkDdp\\207",
		L"\\Device\\AtalkDdp\\208",
		L"\\Device\\AtalkDdp\\209",
		L"\\Device\\AtalkDdp\\210",
		L"\\Device\\AtalkDdp\\211",
		L"\\Device\\AtalkDdp\\212",
		L"\\Device\\AtalkDdp\\213",
		L"\\Device\\AtalkDdp\\214",
		L"\\Device\\AtalkDdp\\215",
		L"\\Device\\AtalkDdp\\216",
		L"\\Device\\AtalkDdp\\217",
		L"\\Device\\AtalkDdp\\218",
		L"\\Device\\AtalkDdp\\219",
		L"\\Device\\AtalkDdp\\220",
		L"\\Device\\AtalkDdp\\221",
		L"\\Device\\AtalkDdp\\222",
		L"\\Device\\AtalkDdp\\223",
		L"\\Device\\AtalkDdp\\224",
		L"\\Device\\AtalkDdp\\225",
		L"\\Device\\AtalkDdp\\226",
		L"\\Device\\AtalkDdp\\227",
		L"\\Device\\AtalkDdp\\228",
		L"\\Device\\AtalkDdp\\229",
		L"\\Device\\AtalkDdp\\230",
		L"\\Device\\AtalkDdp\\231",
		L"\\Device\\AtalkDdp\\232",
		L"\\Device\\AtalkDdp\\233",
		L"\\Device\\AtalkDdp\\234",
		L"\\Device\\AtalkDdp\\235",
		L"\\Device\\AtalkDdp\\236",
		L"\\Device\\AtalkDdp\\237",
		L"\\Device\\AtalkDdp\\238",
		L"\\Device\\AtalkDdp\\239",
		L"\\Device\\AtalkDdp\\240",
		L"\\Device\\AtalkDdp\\241",
		L"\\Device\\AtalkDdp\\242",
		L"\\Device\\AtalkDdp\\243",
		L"\\Device\\AtalkDdp\\244",
		L"\\Device\\AtalkDdp\\245",
		L"\\Device\\AtalkDdp\\246",
		L"\\Device\\AtalkDdp\\247",
		L"\\Device\\AtalkDdp\\248",
		L"\\Device\\AtalkDdp\\249",
		L"\\Device\\AtalkDdp\\250",
		L"\\Device\\AtalkDdp\\251",
		L"\\Device\\AtalkDdp\\252",
		L"\\Device\\AtalkDdp\\253",
		L"\\Device\\AtalkDdp\\254",
		L"\\Device\\AtalkDdp\\255"
	};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\setup\util\access.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntdef.h>
#include <ntstatus.h>
#include <windows.h>
#include <winspool.h>
#include <stdlib.h>
#include <ntsam.h>
#include <ntlsa.h>
#include <ntseapi.h>
#include "sfmutil.h"

extern TCHAR ReturnTextBuffer[512];


#define	AFP_MIN_ACCESS		(FILE_READ_ATTRIBUTES | \
							 READ_CONTROL)

#define	AFP_READ_ACCESS		(READ_CONTROL		 |	\
							FILE_READ_ATTRIBUTES |	\
							FILE_TRAVERSE		 |	\
							FILE_LIST_DIRECTORY	 |	\
							FILE_READ_EA)

#define	AFP_WRITE_ACCESS	(FILE_ADD_FILE		 |	\
							FILE_ADD_SUBDIRECTORY|	\
							FILE_WRITE_ATTRIBUTES|	\
							FILE_WRITE_EA		 |	\
							DELETE)

#define	AFP_OWNER_ACCESS	(WRITE_DAC			  | \
							 WRITE_OWNER)



SID	AfpSidWorld	= { 1, 1, SECURITY_WORLD_SID_AUTHORITY, SECURITY_WORLD_RID };
SID	AfpSidNull	= { 1, 1, SECURITY_NULL_SID_AUTHORITY, SECURITY_NULL_RID };
SID	AfpSidSystem = { 1, 1, SECURITY_NT_AUTHORITY, SECURITY_LOCAL_SYSTEM_RID };
SID	AfpSidCrtrOwner = { 1, 1, SECURITY_CREATOR_SID_AUTHORITY, SECURITY_CREATOR_OWNER_RID };
SID	AfpSidCrtrGroup = { 1, 1, SECURITY_CREATOR_SID_AUTHORITY, SECURITY_CREATOR_GROUP_RID };

/***	afpAddAceToAcl
 *
 *	Build an Ace corres. to the Sid(s) and mask and add these to the Acl. It is
 *	assumed that the Acl has space for the Aces. If the Mask is 0 (i.e. no access)
 *	the Ace added is a DENY Ace, else a ALLOWED ACE is added.
 */
PACCESS_ALLOWED_ACE
afpAddAceToAcl(
	IN  PACL				pAcl,
	IN  PACCESS_ALLOWED_ACE	pAce,
	IN  ACCESS_MASK			Mask,
	IN  PSID				pSid,
	IN  PSID				pSidInherit OPTIONAL
)
{
	// Add a vanilla ace
	pAcl->AceCount ++;
	pAce->Mask = Mask | SYNCHRONIZE | AFP_MIN_ACCESS;
	pAce->Header.AceFlags = 0;
	pAce->Header.AceType = ACCESS_ALLOWED_ACE_TYPE;
	pAce->Header.AceSize = (USHORT)(sizeof(ACE_HEADER) + sizeof(ACCESS_MASK) +
							RtlLengthSid(pSid));
	RtlCopySid(RtlLengthSid(pSid), (PSID)(&pAce->SidStart), pSid);

	// Now add an inherit ace
	if (1)
	{
		pAce = (PACCESS_ALLOWED_ACE)((PBYTE)pAce + pAce->Header.AceSize);
		pAcl->AceCount ++;
		pAce->Mask = Mask | SYNCHRONIZE | AFP_MIN_ACCESS;
		pAce->Header.AceFlags = CONTAINER_INHERIT_ACE |
								OBJECT_INHERIT_ACE |
								INHERIT_ONLY_ACE;
		pAce->Header.AceType = ACCESS_ALLOWED_ACE_TYPE;
		pAce->Header.AceSize = (USHORT)(sizeof(ACE_HEADER) + sizeof(ACCESS_MASK) +
								RtlLengthSid(pSid));
		RtlCopySid(RtlLengthSid(pSid), (PSID)(&pAce->SidStart), pSid);
	
		// Now add an inherit ace for the CreatorOwner/CreatorGroup
		if (ARGUMENT_PRESENT(pSidInherit))
		{
			pAce = (PACCESS_ALLOWED_ACE)((PBYTE)pAce + pAce->Header.AceSize);
			pAcl->AceCount ++;
			pAce->Mask = Mask | SYNCHRONIZE | AFP_MIN_ACCESS;
			pAce->Header.AceFlags = CONTAINER_INHERIT_ACE |
									OBJECT_INHERIT_ACE |
									INHERIT_ONLY_ACE;
			pAce->Header.AceType = ACCESS_ALLOWED_ACE_TYPE;
			pAce->Header.AceSize = (USHORT)(sizeof(ACE_HEADER) + sizeof(ACCESS_MASK) +
									RtlLengthSid(pSidInherit));
			RtlCopySid(RtlLengthSid(pSidInherit), (PSID)(&pAce->SidStart), pSidInherit);
		}
	}

	return ((PACCESS_ALLOWED_ACE)((PBYTE)pAce + pAce->Header.AceSize));
}

/***	afpMoveAces
 *
 *	Move a bunch of aces from the old security descriptor to the new security
 *	descriptor.
 */
PACCESS_ALLOWED_ACE
afpMoveAces(
	IN	PACL				pOldDacl,
	IN	PACCESS_ALLOWED_ACE	pAceStart,
	IN	PSID				pSidOldOwner,
	IN	PSID				pSidNewOwner,
	IN	PSID				pSidOldGroup,
	IN	PSID				pSidNewGroup,
	IN	BOOLEAN				DenyAces,
	IN	OUT PACL			pNewDacl
)
{
	USHORT				i;
	PACCESS_ALLOWED_ACE	pAceOld;
	PSID				pSidAce;

	for (i = 0, pAceOld = (PACCESS_ALLOWED_ACE)((PBYTE)pOldDacl + sizeof(ACL));
		 i < pOldDacl->AceCount;
		 i++, pAceOld = (PACCESS_ALLOWED_ACE)((PBYTE)pAceOld + pAceOld->Header.AceSize))
	{
		// Note: All deny aces are ahead of the grant aces.
		if (DenyAces && (pAceOld->Header.AceType != ACCESS_DENIED_ACE_TYPE))
			break;

		if (!DenyAces && (pAceOld->Header.AceType == ACCESS_DENIED_ACE_TYPE))
			continue;

		pSidAce = (PSID)(&pAceOld->SidStart);
		if (!(RtlEqualSid(pSidAce, &AfpSidWorld)		||
			  RtlEqualSid(pSidAce, pSidOldOwner)		||
			  RtlEqualSid(pSidAce, pSidNewOwner)		||
			  RtlEqualSid(pSidAce, &AfpSidCrtrOwner)	||
			  RtlEqualSid(pSidAce, pSidOldGroup)		||
			  RtlEqualSid(pSidAce, pSidNewGroup)		||
			  RtlEqualSid(pSidAce, &AfpSidCrtrGroup)))
		{
			RtlCopyMemory(pAceStart, pAceOld, pAceOld->Header.AceSize);
			pAceStart = (PACCESS_ALLOWED_ACE)((PBYTE)pAceStart +
													pAceStart->Header.AceSize);
			pNewDacl->AceCount ++;
		}
	}
	return (pAceStart);
}


/***	AfpSetAfpPermissions
 *
 *	Set the permissions on this directory. Also optionally set the owner and
 *	group ids. For setting the owner and group ids verify if the user has the
 *	needed access. This access is however not good enough. We check for this
 *	access but do the actual setting of the permissions in the special server
 *	context (RESTORE privilege is needed).
 */
BOOL
SfmSetUamSecurity(
	 DWORD cArgs,
	 LPTSTR Args[],
	 LPTSTR *TextOut
	 )

{
	NTSTATUS				Status;
	DWORD					SizeNeeded;
	PBYTE					pBuffer = NULL;
	PISECURITY_DESCRIPTOR	pSecDesc;
	SECURITY_INFORMATION	SecInfo = DACL_SECURITY_INFORMATION;
	PACL					pDaclNew = NULL;
	PACCESS_ALLOWED_ACE		pAce;
	LONG					SizeNewDacl;
	HANDLE					DirHandle;
	LPWSTR					lpwsDirPath = NULL;
	LPTSTR					pDirPath = NULL;
	UNICODE_STRING			DirectoryName;
	IO_STATUS_BLOCK			IoStatusBlock;
	DWORD					cbDirPath;
	OBJECT_ATTRIBUTES		ObjectAttributes;
	UINT					Size;


	//
	// Convert the DIR Path to UNICODE
	//

	*TextOut = ReturnTextBuffer;

    lstrcpy(ReturnTextBuffer, TEXT("FAILED"));

	if(cArgs != 1) {

	  return FALSE;

	}
	cbDirPath = (strlen((LPSTR)Args[0]) + 1) * sizeof(WCHAR);

	if((lpwsDirPath  = (LPWSTR)LocalAlloc(LPTR,cbDirPath)) == NULL)
	  return(FALSE);
	
    if(!MultiByteToWideChar(CP_ACP,
                            MB_PRECOMPOSED,
                            (LPSTR)Args[0],
                            -1,
                             lpwsDirPath,
                             cbDirPath
                            ))
   {

	  LocalFree(lpwsDirPath);
	  return(FALSE);

   }
#ifdef DEBUG
   DbgPrint("UAM: Directory = %ws\n",lpwsDirPath);
#endif

   pDirPath =  (LPTSTR)LocalAlloc(LPTR,
	           (wcslen(lpwsDirPath) + wcslen(TEXT("\\DOSDEVICES\\"))+1)
			   * sizeof(WCHAR));				

   if(pDirPath == NULL) {
#ifdef DEBUG
	  DbgPrint("UAMSETSECURITY: malloc for dir path failed\n");
#endif
	  LocalFree(lpwsDirPath);
	  return(FALSE);
   }

   wcscpy(pDirPath, TEXT("\\DOSDEVICES\\"));
   wcscat(pDirPath, lpwsDirPath);

   LocalFree(lpwsDirPath);

	
   RtlInitUnicodeString(&DirectoryName, pDirPath);


   InitializeObjectAttributes(&ObjectAttributes,
				 	 &DirectoryName,
					 OBJ_CASE_INSENSITIVE,
					 NULL,
					 NULL);

   Status = NtOpenFile(&DirHandle,
			   WRITE_DAC | READ_CONTROL | SYNCHRONIZE,
			   &ObjectAttributes,
			   &IoStatusBlock,
			   FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE ,
			   FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT);


   LocalFree(pDirPath);

   if(!NT_SUCCESS(Status)) {

#ifdef DEBUG

	  DbgPrint("UAMSETSECURITY: NtOpen File Failed\n");
#endif
	  return(FALSE);
   }


   do
   {
	  //
	  // Read the security descriptor for this directory
	  //

	  SizeNeeded = 256;
	
	  do
	  {
	      if (pBuffer != NULL)
				LocalFree(pBuffer);
	
			if ((pBuffer = (PBYTE)LocalAlloc(LPTR,SizeNewDacl = SizeNeeded)) == NULL)
			{

				Status = STATUS_NO_MEMORY;
				break;
			}
	
			Status = NtQuerySecurityObject(DirHandle,
										OWNER_SECURITY_INFORMATION |
										GROUP_SECURITY_INFORMATION |
										DACL_SECURITY_INFORMATION,
										(PSECURITY_DESCRIPTOR)pBuffer,
										SizeNeeded, &SizeNeeded);
	
	  } while ((Status != STATUS_SUCCESS) &&
				 ((Status == STATUS_BUFFER_TOO_SMALL)	||
				  (Status == STATUS_BUFFER_OVERFLOW)	||
				  (Status == STATUS_MORE_ENTRIES)));
	
		if (!NT_SUCCESS(Status)) {

			break;
		}
	
		pSecDesc = (PSECURITY_DESCRIPTOR)pBuffer;
	
		// If the security descriptor is in self-relative form, convert to absolute
		if (pSecDesc->Control & SE_SELF_RELATIVE)
		{
			pSecDesc->Control &= ~SE_SELF_RELATIVE;
	
			if (pSecDesc->Owner != NULL)
				pSecDesc->Owner = (PSID)RtlOffsetToPointer(pSecDesc, pSecDesc->Owner);
			if (pSecDesc->Group != NULL)
				pSecDesc->Group = (PSID)RtlOffsetToPointer(pSecDesc, pSecDesc->Group);
			if (pSecDesc->Dacl  != NULL)
				pSecDesc->Dacl  = (PACL)RtlOffsetToPointer(pSecDesc, pSecDesc->Dacl);
		}
	
		// Construct the new Dacl. This consists of Aces for World, Owner and Group
		// followed by Old Aces for everybody else, but with Aces for World, OldOwner
		// and OldGroup stripped out. First determine space for the new Dacl and
		// allocated space for the new Dacl. Lets be exteremely conservative. We
		// have two aces each for owner/group/world.
	
		SizeNewDacl +=
				(RtlLengthSid(pSecDesc->Owner) + sizeof(ACCESS_ALLOWED_ACE) +
				 RtlLengthSid(pSecDesc->Group) + sizeof(ACCESS_ALLOWED_ACE) +
				 RtlLengthSid(&AfpSidSystem) + sizeof(ACCESS_ALLOWED_ACE) +
				 RtlLengthSid(&AfpSidWorld) + sizeof(ACCESS_ALLOWED_ACE)) * 3;
	
		if ((pDaclNew = (PACL)LocalAlloc(LPTR,SizeNewDacl)) == NULL)
		{

			Status = STATUS_NO_MEMORY;
			break;
		}
	
		RtlCreateAcl(pDaclNew, SizeNewDacl, ACL_REVISION);
		pAce = (PACCESS_ALLOWED_ACE)((PBYTE)pDaclNew + sizeof(ACL));
	
		// At this time the Acl list is empty, i.e. no access for anybody
		// Start off by copying the Deny Aces from the original Dacl list
		// weeding out the Aces for World, old and new owner, new and old
		// group, creator owner and creator group
		if (pSecDesc->Dacl != NULL)
		{
			pAce = afpMoveAces(pSecDesc->Dacl, pAce, pSecDesc->Owner,
							pSecDesc->Owner, pSecDesc->Group, pSecDesc->Group,
							TRUE, pDaclNew);

		}

		// Now add Aces for System, World, Group & Owner - in that order
		pAce = afpAddAceToAcl(pDaclNew,
					   pAce,
					   AFP_READ_ACCESS,
					   &AfpSidSystem,
					   &AfpSidSystem);
	
		pAce = afpAddAceToAcl(pDaclNew,
					   pAce,
					   AFP_READ_ACCESS,
					   &AfpSidWorld,
					   NULL);
	
		pAce = afpAddAceToAcl(pDaclNew,
					 pAce,
					 AFP_READ_ACCESS ,
					 pSecDesc->Group,
					 &AfpSidCrtrGroup);

		pAce = afpAddAceToAcl(pDaclNew,
						pAce,
						AFP_READ_ACCESS |  AFP_WRITE_ACCESS,
						pSecDesc->Owner,
						&AfpSidCrtrOwner);


		// Now add in the Grant Aces from the original Dacl list weeding out
		// the Aces for World, old and new owner, new and old group, creator
		// owner and creator group
		if (pSecDesc->Dacl != NULL)
		{
			pAce = afpMoveAces(pSecDesc->Dacl, pAce, pSecDesc->Owner,
							pSecDesc->Owner, pSecDesc->Group, pSecDesc->Group,
							FALSE, pDaclNew);

		}

		// Now set the new security descriptor
		pSecDesc->Dacl = pDaclNew;
	
		Status = NtSetSecurityObject(DirHandle, SecInfo, pSecDesc);


	} while (FALSE);

	// Free the allocated buffers before we return
	if (pBuffer != NULL)
		LocalFree(pBuffer);
	if (pDaclNew != NULL)
		LocalFree(pDaclNew);

   if(NT_SUCCESS(Status)) {

	  lstrcpy(ReturnTextBuffer, TEXT("SUCCESS"));

	  return(TRUE);
   }

   return FALSE;
}






=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\uam\dummy.c ===
/* */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\setup\util\sfmutil.h ===
#define UAMRESOURCEFILE  uamres
#define UAMINFOFILE 	 uaminf
#define UAMDESTRESFILE	 "UAM:Afp_Resource"
#define UAMDESTINFOFILE  "UAM:Afp_AfpInfo"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\setup\util\sfmutil.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

	sfmutil.c

Author:

	Krishg

Revision History:

--*/

#if DBG==1 && DEVL==1
#define DEBUG
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winspool.h>
#include <ntsam.h>
#include <ntlsa.h>
#include <stdlib.h>
#include "sfmutil.h"

#ifdef DBCS
#include "locale.h"
#endif // DBCS
HANDLE ThisDLLHandle;

CHAR ReturnTextBuffer[512];


BOOL
UtilDLLInit(
    IN HANDLE DLLHandle,
    IN DWORD  Reason,
    IN LPVOID ReservedAndUnused
    )
{
    ReservedAndUnused;

    switch(Reason) {

    case DLL_PROCESS_ATTACH:

        ThisDLLHandle = DLLHandle;
#ifdef DBCS // UtilDLLInit()
    // we want to have the Unicode <-> Ansi conversion based on System locale.
        setlocale(LC_ALL,"");
#endif // DBCS
        break;

    case DLL_PROCESS_DETACH:

    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:

        break;
    }

    return(TRUE);
}

/* Delete the file. If Unable to delete the file return failed */

BOOL
DelFile (
	 DWORD cArgs,
	 LPTSTR Args[],
	 LPTSTR *TextOut
	 )
{
   BOOL  	Status = FALSE;
   LPTSTR 	pSrcFile = NULL;
   INT 		cbAscii;

   *TextOut = (LPTSTR)ReturnTextBuffer;

   do
   {
	  if(cArgs!=1)
		 break;

	  cbAscii = strlen((LPSTR)Args[0]) +1;

	  pSrcFile = (LPTSTR)LocalAlloc(LPTR, sizeof(WCHAR) * cbAscii);

	  if(pSrcFile == NULL)
		 break;

	  if(mbstowcs(pSrcFile, (LPSTR)Args[0],cbAscii) == -1)
		 break;

      Status = DeleteFile(pSrcFile);

    } while (FALSE);

	if(pSrcFile != NULL)
	   LocalFree(pSrcFile);

    strcpy(ReturnTextBuffer, Status ? (LPSTR)"SUCCESS" : (LPSTR)"FAILED");
    return Status;
}

/*
 * Copy Uam Files :
 * Copies the UAM Files to the NTFS Volume
*/

BOOL
CopyUamFiles (
	 DWORD cArgs,
	 LPTSTR Args[],
	 LPTSTR *TextOut
	 )
{
   BOOL Status = FALSE;
   INT cbAscii;

   LPTSTR pSrcFile = NULL;
   LPTSTR  pDestFile = NULL;

   *TextOut = (LPTSTR)ReturnTextBuffer;

   do
   {
	  if(cArgs!=2)
		 break;

	  cbAscii = strlen((LPSTR)Args[0]) +1;

	  pSrcFile = (LPTSTR)LocalAlloc(LPTR, sizeof(WCHAR) * cbAscii);

	  if(pSrcFile == NULL)
		 break;

	  if(mbstowcs(pSrcFile, (LPSTR)Args[0],cbAscii) == -1)
		 break;

	  cbAscii = strlen((LPSTR)Args[1]) +1;

	  pDestFile = (LPTSTR)LocalAlloc(LPTR, sizeof(WCHAR) * cbAscii);

	  if(pDestFile == NULL)
		 break;

	  if(mbstowcs(pDestFile, (LPSTR)Args[1],cbAscii) == -1)
		 break;

#ifdef DEBUG
	DbgPrint("Source File  %ws\n",pSrcFile);
	DbgPrint("Destination File %ws\n",pDestFile);
#endif

	  Status = CopyFile(pSrcFile,pDestFile,FALSE);

    } while (FALSE);

	if(pSrcFile != NULL)
	   LocalFree(pSrcFile);

	if(pDestFile != NULL)
	   LocalFree(pDestFile);

	strcpy(ReturnTextBuffer, Status ? (LPSTR)"SUCCESS" : (LPSTR)"FAILED");

    return Status;

}

#define AFPMGRKEY		TEXT("Afp Manager")

BOOL
WriteAfpMgrIniStrings (
	DWORD cArgs,
	LPTSTR Args[],
	LPTSTR *TextOut
	)

{

   BOOL 	Status = FALSE;
   BOOL    	KeyDelete = FALSE;
   INT 		cbAscii;
   LPTSTR  	pSectionName = NULL;
   LPTSTR 	pString = NULL;
   LPTSTR	pIniFile = NULL;

   *TextOut = (LPTSTR)ReturnTextBuffer;

   do
   {
	  if(cArgs != 3)
		 break;

	  cbAscii = strlen((LPSTR)Args[0]) +1;

	  pSectionName = (LPTSTR)LocalAlloc(LPTR, sizeof(WCHAR) * cbAscii);

	  if(pSectionName == NULL)
		 break;

	  if(mbstowcs(pSectionName, (LPSTR)Args[0],cbAscii) == -1)
		 break;
	  //
	  // If the String is NULL, set String to NULL, otherwise
	  // convert the string to unicode
	  //

	  if(!strcmp((LPSTR)Args[1],(LPSTR)"NULL")) {
		 KeyDelete = TRUE;
	  }
      else
	  {
		 cbAscii = strlen((LPSTR)Args[1]) +1;
		 pString = (LPTSTR)LocalAlloc(LPTR, sizeof(WCHAR) * cbAscii);
		 if(pString == NULL)
			break;
		 if(mbstowcs(pString, (LPSTR)Args[1],cbAscii) == -1)
			break;
      }

	  cbAscii = strlen((LPSTR)Args[2]) +1;
	  pIniFile = (LPTSTR)LocalAlloc(LPTR, sizeof(WCHAR) * cbAscii);
	  if(pIniFile == NULL)
		 break;
	  if(mbstowcs(pIniFile, (LPSTR)Args[2],cbAscii) == -1)
		 break;

#ifdef DEBUG
	DbgPrint("File:%ws\n",pIniFile);
	DbgPrint("String: 	%ws\n",pString);
	DbgPrint("Section: 	%ws\n",pSectionName);
#endif

	  Status = WritePrivateProfileString (pSectionName,
						AFPMGRKEY,
                        (KeyDelete == TRUE) ?  (LPCTSTR)NULL : pString,
						pIniFile);

   } while (FALSE);

   if(pIniFile != NULL)
	  LocalFree(pIniFile);

   if(pSectionName != NULL)
	  LocalFree(pSectionName);

   if(pString != NULL)
	  LocalFree(pString);

   strcpy(ReturnTextBuffer ,Status ? (LPSTR)"SUCCESS": (LPSTR)"FAILED");

   return Status;

}
BOOL
GetPrintProcDir (
	DWORD cArgs,
	LPTSTR Args[],
	LPTSTR *TextOut
	)

{

   BOOL		Status = FALSE;
   DWORD  	BytesCopied;
   LPTSTR  	wpProcFile = NULL;
   *TextOut = (LPTSTR)ReturnTextBuffer;

   do
   {
	  wpProcFile = (LPTSTR)LocalAlloc(LPTR, 512);

	  if(wpProcFile == NULL)
		 break;

	  Status = GetPrintProcessorDirectory(NULL,
						   NULL,
                           1,
						   (LPBYTE)wpProcFile,
                           512,
                           &BytesCopied
                           );

	  if(Status) {

		 if(wcstombs(ReturnTextBuffer,wpProcFile,512) ==-1) {
			Status = FALSE;
			break;
		 }

	  }

    } while (FALSE);

	if(wpProcFile != NULL)
	   LocalFree(wpProcFile);

    if(!Status)
      strcpy(ReturnTextBuffer ,(LPSTR)"FAILED");

    return Status;
}


BOOL
AddPrintProc (
	DWORD cArgs,
	LPTSTR Args[],
	LPTSTR *TextOut
	)

{

   BOOL		Status = FALSE;
   LPTSTR  	pPrintProcessorFile = NULL;
   LPTSTR   	pPrintProcessor  = NULL;
   INT     	cbAscii;

   *TextOut = (LPTSTR)ReturnTextBuffer;

   do
   {
	  if(cArgs != 2)
		 break;

	  cbAscii = strlen((LPSTR)Args[0]) +1;

	  pPrintProcessorFile = (LPTSTR)LocalAlloc(LPTR, sizeof(WCHAR) * cbAscii);

	  if(pPrintProcessorFile == NULL)
		 break;

	  if(mbstowcs(pPrintProcessorFile, (LPSTR)Args[0],cbAscii) == -1)
		 break;
	

	  cbAscii = strlen((LPSTR)Args[1]) +1;

	  pPrintProcessor = (LPTSTR)LocalAlloc(LPTR, sizeof(WCHAR) * cbAscii);

	  if(pPrintProcessor == NULL)
		 break;

	  if(mbstowcs(pPrintProcessor, (LPSTR)Args[1],cbAscii) == -1)
		 break;

	  Status =  AddPrintProcessor(NULL,	  // Do local stuff only
	                              NULL,     // Use Current Environment
	                              pPrintProcessorFile, // PSPRINT.DLL
	                              pPrintProcessor
								 );

   } while (FALSE);

   if(pPrintProcessorFile != NULL)
	  LocalFree(pPrintProcessorFile);

   if(pPrintProcessor != NULL)
	  LocalFree(pPrintProcessor);

   strcpy(ReturnTextBuffer ,Status ? (LPSTR)"SUCCESS": (LPSTR)"FAILED");
   return Status;

}

/* Delete  the PSTODIB PSPRINT PrintProcessor
 *
 *
 */

BOOL
DeletePrintProc (
	DWORD cArgs,
	LPTSTR Args[],
	LPTSTR *TextOut
	)

{

   BOOL		Status = FALSE;
   LPTSTR  	pPrintProcessorFile = NULL;
   LPTSTR   	pPrintProcessor  = NULL;
   INT     	cbAscii;

   *TextOut = (LPTSTR)ReturnTextBuffer;

   do
   {
	  if(cArgs != 2)
		 break;

	  cbAscii = strlen((LPSTR)Args[0]) +1;

	  pPrintProcessorFile = (LPTSTR)LocalAlloc(LPTR, sizeof(WCHAR) * cbAscii);

	  if(pPrintProcessorFile == NULL)
		 break;

	  if(mbstowcs(pPrintProcessorFile, (LPSTR)Args[0],cbAscii) == -1)
		 break;
	

	  cbAscii = strlen((LPSTR)Args[1]) +1;

	  pPrintProcessor = (LPTSTR)LocalAlloc(LPTR, sizeof(WCHAR) * cbAscii);

	  if(pPrintProcessor == NULL)
		 break;

	  if(mbstowcs(pPrintProcessor, (LPSTR)Args[1],cbAscii) == -1)
		 break;

	  Status =  DeletePrintProcessor(	pPrintProcessorFile,
								   		NULL,		// Use Current Environment
								   		pPrintProcessor
							   		  );

   } while (FALSE);

   if(pPrintProcessorFile != NULL)
	  LocalFree(pPrintProcessorFile);

   if(pPrintProcessor != NULL)
	  LocalFree(pPrintProcessor);


   strcpy(ReturnTextBuffer ,Status ? (LPSTR)"SUCCESS": (LPSTR)"FAILED");
   return Status;

}

BOOL
SfmAddPrintMonitor (
	DWORD cArgs,
	LPTSTR Args[],
	LPTSTR *TextOut
	)

{

   BOOL 	Status = FALSE;
   LPTSTR 	wpMonName = NULL;
   INT		cbAscii = 0;
   LPSTR 	pMonInfoBuffer = NULL;
   TCHAR 	MonDllName[] = L"sfmmon.dll";
   PMONITOR_INFO_2 pmoninfo;

   *TextOut = (LPTSTR)ReturnTextBuffer;

   do {

	  if(cArgs != 1)
		 break;

	  cbAscii = strlen((LPSTR)Args[0]) + 1;

	  wpMonName = (LPTSTR)LocalAlloc(LPTR,sizeof(WCHAR) * cbAscii);

	  if(wpMonName == NULL)
		 break;

	  if(mbstowcs(wpMonName, (LPSTR)Args[0], cbAscii) == -1)
		 break;

	  pMonInfoBuffer = (LPSTR) LocalAlloc(LPTR, 512);

	  if(pMonInfoBuffer == NULL)
		 break;

	  pmoninfo = (PMONITOR_INFO_2)pMonInfoBuffer;
	  pmoninfo->pName = wpMonName;
	  pmoninfo->pEnvironment = NULL;
	  pmoninfo->pDLLName = MonDllName;

#ifdef DEBUG
	DbgPrint("ADDPRINTMONITOR Name : %ws\n", pmoninfo->pName);
    DbgPrint("ADDPRINTMONITOR Dll Name : %ws\n", pmoninfo->pDLLName);
#endif

	  Status = AddMonitor( NULL,
						   2,
						   (LPSTR)pMonInfoBuffer
						   );

	}while(FALSE);

	if(wpMonName != NULL)
	   LocalFree(wpMonName);

	if(pMonInfoBuffer != NULL)
	   LocalFree(pMonInfoBuffer);

	strcpy(ReturnTextBuffer ,Status ? (LPSTR)"SUCCESS": (LPSTR)"FAILED");

	return Status;

}

BOOL
SfmDeletePrintMonitor (
	DWORD cArgs,
	LPTSTR Args[],
	LPTSTR *TextOut
	)

{

    BOOL Status = FALSE;
    LPTSTR wpMonName = NULL;
	INT cbAscii;
    *TextOut = (LPTSTR)ReturnTextBuffer;

   do
   {

	  if(cArgs !=1)
		 break;

	  cbAscii = strlen((LPSTR)Args[0]) + 1;

	  wpMonName = (LPTSTR)LocalAlloc(LPTR,sizeof(WCHAR) * cbAscii);

	  if(wpMonName == NULL)
		 break;

	  if(mbstowcs(wpMonName, (LPSTR)Args[0], cbAscii) == -1)
		 break;

	  Status = DeleteMonitor( NULL,
							  NULL,
							  wpMonName
                           	);
   }while(FALSE);

   if(wpMonName != NULL)
	  LocalFree(wpMonName);

   strcpy(ReturnTextBuffer ,Status ? (LPSTR)"SUCCESS": (LPSTR)"FAILED");

   return Status;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\uam\makefile.inc ===
make_uam:
    binplace uaminst.ifo
    binplace uaminst.rsc
    binplace sfmuam5.ifo
    binplace sfmuam5.rsc
    binplace sfmuam.ifo
    binplace sfmuam.rsc
    binplace sfmuam.txt
    binplace sfmicon.vol

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\uam\macsource\macssp\bootdefs.h ===
#ifndef _BLDR_KERNEL_DEFS
#define _BLDR_KERNEL_DEFS

#include <macwindefs.h>

typedef struct _TIME_FIELDS {
    short Year;        // range [1601...]
    short Month;       // range [1..12]
    short Day;         // range [1..31]
    short Hour;        // range [0..23]
    short Minute;      // range [0..59]
    short Second;      // range [0..59]
    short Milliseconds;// range [0..999]
    short Weekday;     // range [0..6] == [Sunday..Saturday]
} TIME_FIELDS;
typedef TIME_FIELDS *PTIME_FIELDS;

#ifdef MAC
typedef enum {
    MsvAvEOL,                 // end of list
    MsvAvNbComputerName,      // server's computer name -- NetBIOS
    MsvAvNbDomainName,        // server's domain name -- NetBIOS
    MsvAvDnsComputerName,     // server's computer name -- DNS
    MsvAvDnsDomainName,       // server's domain name -- DNS
    MsvAvDnsTreeName,         // server's tree name -- DNS
    MsvAvFlags                // server's extended flags -- DWORD mask
} MSV1_0_AVID;
#endif

// Update Sequence Number

typedef LONGLONG USN;

typedef struct _LIST_ENTRY {
   struct _LIST_ENTRY * volatile Flink;
   struct _LIST_ENTRY * volatile Blink;
} LIST_ENTRY, *PLIST_ENTRY;

#if defined(_AXP64_)
#define KSEG0_BASE 0xffffffff80000000     // from halpaxp64.h
#elif defined(_ALPHA_)
#define KSEG0_BASE 0x80000000             // from halpalpha.h
#endif

//
// 16 byte aligned type for 128 bit floats
//

// *** TBD **** when compiler support is available:
// typedef __float80 FLOAT128;
// For we define a 128 bit structure and use force_align pragma to
// align to 128 bits.
//

typedef struct _FLOAT128 {
    LONGLONG LowPart;
    LONGLONG HighPart;
} FLOAT128;

typedef FLOAT128 *PFLOAT128;


#if defined(_M_IA64)

#pragma force_align _FLOAT128 16

#endif // _M_IA64

#if defined(_WIN64)

typedef unsigned __int64 ULONG_PTR, *PULONG_PTR;

#else

typedef unsigned long ULONG_PTR, *PULONG_PTR;

#endif

typedef unsigned char BYTE, *PBYTE;

typedef ULONG_PTR KSPIN_LOCK;
typedef KSPIN_LOCK *PKSPIN_LOCK;

//
// Interrupt Request Level (IRQL)
//

typedef UCHAR KIRQL;
typedef KIRQL *PKIRQL;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\uam\macsource\macssp\cache.h ===
/*****************************************************************/
/**		  Microsoft Windows for Workgroups		**/
/**	      Copyright (C) Microsoft Corp., 1991-1992		**/
/*****************************************************************/


/*
    cache.h
    Memory based Password caching support prototypes.

    FILE HISTORY:

	davidar	12/30/93	Created

*/

void
CacheInitializeCache(
    );

BOOL
CacheGetPassword(
    PSSP_CREDENTIAL Credential
    );

BOOL
CacheSetPassword(
    PSSP_CREDENTIAL Credential
    );

#ifndef WIN
SECURITY_STATUS
CacheSetCredentials(
    IN PVOID        AuthData,
    PSSP_CREDENTIAL Credential
    );
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\uam\macsource\macssp\cred.h ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    cred.h

Abstract:

    SSP Credential.

Author:

    Cliff Van Dyke (CliffV) 17-Sep-1993

Revision History:

--*/

#ifndef _NTLMSSP_CRED_INCLUDED_
#define _NTLMSSP_CRED_INCLUDED_

#include <sspi.h>


#define SECPKG_CRED_OWF_PASSWORD        0x00000010

//
// Description of a credential.
//

typedef struct _SSP_CREDENTIAL {

    //
    // Global list of all Credentials.
    //

    LIST_ENTRY Next;

    //
    // Used to prevent this Credential from being deleted prematurely.
    //

    WORD References;

    //
    // Flag of how credential may be used.
    //
    // SECPKG_CRED_* flags
    //

    ULONG CredentialUseFlags;

    PCHAR Username;

    PCHAR Domain;

    PCHAR Workstation;

#ifdef BL_USE_LM_PASSWORD
    PLM_OWF_PASSWORD LmPassword;
#endif
    
    PNT_OWF_PASSWORD NtPassword;

} SSP_CREDENTIAL, *PSSP_CREDENTIAL;

PSSP_CREDENTIAL
SspCredentialAllocateCredential(
    IN ULONG CredentialUseFlags
    );

PSSP_CREDENTIAL
SspCredentialReferenceCredential(
    IN PCredHandle CredentialHandle,
    IN BOOLEAN RemoveCredential
    );

void
SspCredentialDereferenceCredential(
    PSSP_CREDENTIAL Credential
    );

#endif // ifndef _NTLMSSP_CRED_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\uam\macsource\macssp\crc32.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    crc32.g

Abstract:

    CRC-32 alogorithm prototypes and constants

Author:

    MikeSw

Revision History:

    31-Mar-94       MikeSw      Created

--*/



//////////////////////////////////////////////////////////////
//
// Function prototypes for CRC-32
//
//////////////////////////////////////////////////////////////


void
Crc32(  unsigned long crc,
        unsigned long cbBuffer,
        LPVOID pvBuffer,
        unsigned long SEC_FAR * pNewCrc);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\uam\macsource\macssp\crypt.h ===
/*

Copyright (c) 1989  Microsoft Corporation

Module Name:

    crypt.h

Abstract:

    This module contains the public data structures and API definitions
    needed to utilize the encryption library


Author:

    David Chalmers (Davidc) 21-October-1991

Revision History:

--*/

#ifndef _NTCRYPT_
#define _NTCRYPT_

#define IN
#define OUT


/////////////////////////////////////////////////////////////////////////
//                                                                     //
// Core encryption types                                               //
//                                                                     //
/////////////////////////////////////////////////////////////////////////


#define CLEAR_BLOCK_LENGTH          8

typedef struct _CLEAR_BLOCK {
    char    data[CLEAR_BLOCK_LENGTH];
}                                   CLEAR_BLOCK;
typedef CLEAR_BLOCK *               PCLEAR_BLOCK;


#define CYPHER_BLOCK_LENGTH         8

typedef struct _CYPHER_BLOCK {
    char    data[CYPHER_BLOCK_LENGTH];
}                                   CYPHER_BLOCK;
typedef CYPHER_BLOCK *              PCYPHER_BLOCK;


#define BLOCK_KEY_LENGTH            7

typedef struct _BLOCK_KEY {
    char    data[BLOCK_KEY_LENGTH];
}                                   BLOCK_KEY;
typedef BLOCK_KEY *                 PBLOCK_KEY;




/////////////////////////////////////////////////////////////////////////
//                                                                     //
// Arbitrary length data encryption types                              //
//                                                                     //
/////////////////////////////////////////////////////////////////////////

typedef struct _CRYPT_BUFFER {
    unsigned long   Length;         // Number of valid bytes in buffer
    unsigned long   MaximumLength;  // Number of bytes pointed to by Buffer
    void *   Buffer;
} CRYPT_BUFFER;
typedef CRYPT_BUFFER *  PCRYPT_BUFFER;

typedef CRYPT_BUFFER    CLEAR_DATA;
typedef CLEAR_DATA *    PCLEAR_DATA;

typedef CRYPT_BUFFER    DATA_KEY;
typedef DATA_KEY *      PDATA_KEY;

typedef CRYPT_BUFFER    CYPHER_DATA;
typedef CYPHER_DATA *   PCYPHER_DATA;



/////////////////////////////////////////////////////////////////////////
//                                                                     //
// Lan Manager data types                                              //
//                                                                     //
/////////////////////////////////////////////////////////////////////////


//
// Define a LanManager compatible password
//
// A LanManager password is a null-terminated ansi string consisting of a
// maximum of 14 characters (not including terminator)
//

typedef char *                      PLM_PASSWORD;



//
// Define the result of the 'One Way Function' (OWF) on a LM password
//

#define LM_OWF_PASSWORD_LENGTH      (CYPHER_BLOCK_LENGTH * 2)

typedef struct _LM_OWF_PASSWORD {
    CYPHER_BLOCK data[2];
}                                   LM_OWF_PASSWORD;
typedef LM_OWF_PASSWORD *           PLM_OWF_PASSWORD;

//
// NT password types.
//

typedef struct _UNICODE_STRING {
    USHORT Length;
    USHORT MaximumLength;
    PWSTR  Buffer;
} UNICODE_STRING;
typedef UNICODE_STRING *PUNICODE_STRING;

#ifdef MAC
typedef UNICODE_STRING *PCUNICODE_STRING;
#endif

typedef UNICODE_STRING              NT_PASSWORD;
typedef NT_PASSWORD *               PNT_PASSWORD;


#define NT_OWF_PASSWORD_LENGTH      LM_OWF_PASSWORD_LENGTH

typedef LM_OWF_PASSWORD             NT_OWF_PASSWORD;
typedef NT_OWF_PASSWORD *           PNT_OWF_PASSWORD;



//
// Define the challenge sent by the Lanman server during logon
//

#define LM_CHALLENGE_LENGTH         CLEAR_BLOCK_LENGTH

typedef CLEAR_BLOCK                 LM_CHALLENGE;
typedef LM_CHALLENGE *              PLM_CHALLENGE;

typedef LM_CHALLENGE                NT_CHALLENGE;
typedef NT_CHALLENGE *              PNT_CHALLENGE;


#define USER_SESSION_KEY_LENGTH     (CYPHER_BLOCK_LENGTH * 2)

typedef struct _USER_SESSION_KEY {
    CYPHER_BLOCK data[2];
}                                   USER_SESSION_KEY;
typedef USER_SESSION_KEY          * PUSER_SESSION_KEY;



//
// Define the response sent by redirector in response to challenge from server
//

#define LM_RESPONSE_LENGTH          (CYPHER_BLOCK_LENGTH * 3)

typedef struct _LM_RESPONSE {
    CYPHER_BLOCK  data[3];
}                                   LM_RESPONSE;
typedef LM_RESPONSE *               PLM_RESPONSE;

#define NT_RESPONSE_LENGTH          LM_RESPONSE_LENGTH

typedef LM_RESPONSE                 NT_RESPONSE;
typedef NT_RESPONSE *               PNT_RESPONSE;



//
// Define the result of the reversible encryption of an OWF'ed password.
//

#define ENCRYPTED_LM_OWF_PASSWORD_LENGTH (CYPHER_BLOCK_LENGTH * 2)

typedef struct _ENCRYPTED_LM_OWF_PASSWORD {
    CYPHER_BLOCK data[2];
}                                   ENCRYPTED_LM_OWF_PASSWORD;
typedef ENCRYPTED_LM_OWF_PASSWORD * PENCRYPTED_LM_OWF_PASSWORD;



//
// Define the session key maintained by the redirector and server
//

#define LM_SESSION_KEY_LENGTH       LM_CHALLENGE_LENGTH

typedef LM_CHALLENGE                LM_SESSION_KEY;
typedef LM_SESSION_KEY *            PLM_SESSION_KEY;

#define NT_SESSION_KEY_LENGTH       (2 * CLEAR_BLOCK_LENGTH)



//
// Define the index type used to encrypt OWF Passwords
//

typedef long                        CRYPT_INDEX;
typedef CRYPT_INDEX *               PCRYPT_INDEX;



////////////////////////////////////////////////////////////////////////////
//                                                                        //
// Encryption library API macros                                          //
//                                                                        //
// To conceal the purpose of these functions to someone dumping out the   //
// encryption dll they have been purposefully given unhelpful names.      //
// Each has an associated macro that should be used by system components  //
// to access these routines in a readable way.                            //
//                                                                        //
////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////
//                                                                        //
// Encryption library API function prototypes                             //
//                                                                        //
////////////////////////////////////////////////////////////////////////////


//
// Core block encryption functions
//

#ifdef __cplusplus
extern "C" {
#endif

BOOL
EncryptBlock(
    IN PCLEAR_BLOCK ClearBlock,
    IN PBLOCK_KEY BlockKey,
    OUT PCYPHER_BLOCK CypherBlock
    );

BOOL
DecryptBlock(
    IN PCYPHER_BLOCK CypherBlock,
    IN PBLOCK_KEY BlockKey,
    OUT PCLEAR_BLOCK ClearBlock
    );

BOOL
EncryptStdBlock(
    IN PBLOCK_KEY BlockKey,
    OUT PCYPHER_BLOCK CypherBlock
    );

//
// Arbitrary length data encryption functions
//

BOOL
EncryptData(
    IN PCLEAR_DATA ClearData,
    IN PDATA_KEY DataKey,
    OUT PCYPHER_DATA CypherData
    );

BOOL
DecryptData(
    IN PCYPHER_DATA CypherData,
    IN PDATA_KEY DataKey,
    OUT PCLEAR_DATA ClearData
    );

//
// Password hashing functions (One Way Function)
//

BOOL
CalculateLmOwfPassword(
    IN PLM_PASSWORD LmPassword,
    OUT PLM_OWF_PASSWORD LmOwfPassword
    );

BOOL
CalculateNtOwfPassword(
    IN PNT_PASSWORD NtPassword,
    OUT PNT_OWF_PASSWORD NtOwfPassword
    );


//
// OWF password comparison functions
//

BOOL
EqualLmOwfPassword(
    IN PLM_OWF_PASSWORD LmOwfPassword1,
    IN PLM_OWF_PASSWORD LmOwfPassword2
    );



//
// Functions for calculating response to server challenge
//

BOOL
CalculateLmResponse(
    IN PLM_CHALLENGE LmChallenge,
    IN PLM_OWF_PASSWORD LmOwfPassword,
    OUT PLM_RESPONSE LmResponse
    );

BOOL
CalculateNtResponse(
    IN PNT_CHALLENGE NtChallenge,
    IN PNT_OWF_PASSWORD NtOwfPassword,
    OUT PNT_RESPONSE NtResponse
    );

BOOL
CalculateUserSessionKeyLm(
    IN PLM_RESPONSE LmResponse,
    IN PLM_OWF_PASSWORD LmOwfPassword,
    OUT PUSER_SESSION_KEY UserSessionKey
    );

BOOL
CalculateUserSessionKeyNt(
    IN PNT_RESPONSE NtResponse,
    IN PNT_OWF_PASSWORD NtOwfPassword,
    OUT PUSER_SESSION_KEY UserSessionKey
    );

//
// OwfPassword encryption functions
//


//
// Encrypt OwfPassword using OwfPassword as the key
//
BOOL
EncryptLmOwfPwdWithLmOwfPwd(
    IN PLM_OWF_PASSWORD DataLmOwfPassword,
    IN PLM_OWF_PASSWORD KeyLmOwfPassword,
    OUT PENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword
    );

BOOL
DecryptLmOwfPwdWithLmOwfPwd(
    IN PENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword,
    IN PLM_OWF_PASSWORD KeyLmOwfPassword,
    OUT PLM_OWF_PASSWORD DataLmOwfPassword
    );


//
// Encrypt OwfPassword using SessionKey as the key
//
BOOL
EncryptLmOwfPwdWithLmSesKey(
    IN PLM_OWF_PASSWORD LmOwfPassword,
    IN PLM_SESSION_KEY LmSessionKey,
    OUT PENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword
    );

BOOL
DecryptLmOwfPwdWithLmSesKey(
    IN PENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword,
    IN PLM_SESSION_KEY LmSessionKey,
    OUT PLM_OWF_PASSWORD LmOwfPassword
    );

//
// Encrypt OwfPassword using an index as the key
//
BOOL
EncryptLmOwfPwdWithIndex(
    IN PLM_OWF_PASSWORD LmOwfPassword,
    IN PCRYPT_INDEX Index,
    OUT PENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword
    );

BOOL
DecryptLmOwfPwdWithIndex(
    IN PENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword,
    IN PCRYPT_INDEX Index,
    OUT PLM_OWF_PASSWORD LmOwfPassword
    );

#ifdef __cplusplus
}
#endif //__cplusplus
#endif // _NTCRYPT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\uam\macsource\macssp\context.h ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    context.h

Abstract:

    SSP Context.

Author:

    Cliff Van Dyke (CliffV) 17-Sep-1993

Revision History:

--*/

#ifndef _NTLMSSP_CONTEXT_INCLUDED_
#define _NTLMSSP_CONTEXT_INCLUDED_

#include <rsa32.h>
#include <ntlmsspv2.h>

typedef struct _SSP_CONTEXT {

    //
    // Global list of all Contexts
    //  (Serialized by SspContextCritSect)
    //

    LIST_ENTRY Next;

    //
    // Timeout the context after awhile.
    //

    DWORD StartTime;
    DWORD Interval;

    //
    // Used to prevent this Context from being deleted prematurely.
    //

    WORD References;

    //
    // Maintain the Negotiated protocol
    //

    ULONG NegotiateFlags;

    //
    // State of the context
    //

    enum {
        IdleState,
        NegotiateSentState,    // Outbound context only
        ChallengeSentState,    // Inbound context only
        AuthenticateSentState, // Outbound context only
        AuthenticatedState     // Inbound context only
        } State;

    //
    // The challenge passed to the client.
    //  Only valid when in ChallengeSentState.
    //

    UCHAR Challenge[MSV1_0_CHALLENGE_LENGTH];

    PSSP_CREDENTIAL Credential;

    ULONG Nonce;
    struct RC4_KEYSTRUCT SEC_FAR * Rc4Key;

    //
    //  NTLMv2 session keys
    //

    USER_SESSION_KEY UserSessionKey;
    NTLMV2_DERIVED_SKEYS Ntlmv2SKeys;

} SSP_CONTEXT, *PSSP_CONTEXT;

PSSP_CONTEXT
SspContextReferenceContext(
    IN PCtxtHandle ContextHandle,
    IN BOOLEAN RemoveContext
    );

void
SspContextDereferenceContext(
    PSSP_CONTEXT Context
    );

PSSP_CONTEXT
SspContextAllocateContext(
    );

TimeStamp
SspContextGetTimeStamp(
    IN PSSP_CONTEXT Context,
    IN BOOLEAN GetExpirationTime
    );

#endif // ifndef _NTLMSSP_CONTEXT_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\uam\macsource\macssp\macssp.cpp ===
/*
 *  macssp.cpp
 *  MSUAM
 *
 *  Created by mconrad on Sun Sep 30 2001.
 *  Copyright (c) 2001 Microsoft Corp. All rights reserved.
 *
 */

#ifdef SSP_TARGET_CARBON
#include <Carbon/Carbon.h>
#endif

#include <descrypt.h>
#include <ntstatus.h>
#include <winerror.h>
#include <ntlmsspv2.h>
#include <ntlmsspi.h>
#include <ntlmssp.h>
#include <macssp.h>
#include <sspdebug.h>
#include <macunicode.h>

// ---------------------------------------------------------------------------
//  MacSspHandleNtlmv2ChallengeMessage()
// ---------------------------------------------------------------------------
// Handles an NTLMv2 challenge message from a server. This function is fairly
// "black box" in that the caller needs to do nothing else other than send
// off the authenticate message generated here to the server.
//
// NOTE: All byte swapping from little to bigendian and back is performed
// here. As a result, the caller should not attempt to access the structures
// after returning or a crash will occur.
//

HRESULT
MacSspHandleNtlmv2ChallengeMessage(
    IN PCSTR 					pszUserName,
    IN PCSTR 					pszDomainName,
    IN PCSTR 					pszWorkstation,
    IN PCSTR 					pszCleartextPassword,
    IN ULONG 					cbChallengeMessage,
    IN CHALLENGE_MESSAGE* 		pChallengeMessage,
    IN OUT ULONG* 				pNegotiateFlags,
    OUT ULONG* 					pcbAuthenticateMessage,
    OUT AUTHENTICATE_MESSAGE** 	ppAuthenticateMessage,
    OUT USER_SESSION_KEY* 		pUserSessionKey
    )
{
    NTSTATUS 				Status;
    SSP_CREDENTIAL 			Credential;
    USER_SESSION_KEY 		UserSessionKey;
    NT_OWF_PASSWORD 		NtOwfPassword;
    UNICODE_STRING			uszCleartextPassword	= {0, 0, NULL};
    UInt16					unicodeLen				= 0;
    ULONG 					cbAuthenticateMessage 	= 0;
    AUTHENTICATE_MESSAGE* 	pAuthenticateMessage 	= NULL;
    ULONG 					NegotiateFlags 			= *pNegotiateFlags;
    
    SspDebugPrint((DBUF, "Handling NTLMv2 Challenge Message..."));
    SspDebugPrint((DBUF, "Username:    %s", pszUserName));
    SspDebugPrint((DBUF, "DomainName:  %s", pszDomainName));
    SspDebugPrint((DBUF, "Workstation: %s", pszWorkstation));
    SspDebugPrint((DBUF, "Password:    %s", pszCleartextPassword));
    
    //
    //Initialize all the structures, on mac we use memset since not all
    //compilers like the {0} initializer.
    //
    ZeroMemory(&Credential, sizeof(Credential));
    ZeroMemory(&UserSessionKey, sizeof(UserSessionKey));
    ZeroMemory(&NtOwfPassword, sizeof(NtOwfPassword));
    
    //
    //Build a unicode string from the supplied ansi password with which
    //we'll use to build an owf password.
    //
    Status = MacSspCStringToUnicode(
                pszCleartextPassword,
                &unicodeLen,
                (UniCharArrayPtr*)&(uszCleartextPassword.Buffer)
                );
    
    if (NT_SUCCESS(Status))
    {
        uszCleartextPassword.Length			= unicodeLen;
        uszCleartextPassword.MaximumLength	= unicodeLen;
        
        SspSwapUnicodeString(&uszCleartextPassword);
    }
    else
    {
        SspDebugPrint((DBUF, "****Unicode conversion failed! Bailing out..."));
        return(E_FAIL);
    }

    //
    //Build a credential reference that the Ssp hanlder routine requires.
    //
    Credential.Username	 	= const_cast<CHAR*>(pszUserName);
    Credential.Domain 		= const_cast<CHAR*>(pszDomainName);
    Credential.Workstation 	= const_cast<CHAR*>(pszWorkstation);
    
    //
    //The credenatial requires an NTOwf password.
    //
    Status = CalculateNtOwfPassword(&uszCleartextPassword, &NtOwfPassword);
    
    if (NT_SUCCESS(Status))
    {
        Credential.NtPassword = &NtOwfPassword;
        
        //
        //The challenge message came from a windows box which means we have
        //to swap the byte order to bigendian for Macs.
        //
        SspSwapChallengeMessageBytes(pChallengeMessage);
        
        //SspDebugPrintNTLMMsg(pChallengeMessage, cbChallengeMessage);
        SspDebugPrint((DBUF, "Unicode Password:"));
        SspDebugPrintHex(uszCleartextPassword.Buffer, uszCleartextPassword.Length);
        SspDebugPrint((DBUF, "Generating Authenticate Message..."));
        
        Status = SsprHandleNtlmv2ChallengeMessage(
                        &Credential,
                        cbChallengeMessage,
                        pChallengeMessage,
                        &NegotiateFlags,
                        &cbAuthenticateMessage,
                        NULL,
                        &UserSessionKey
                        );
        
        if (Status == STATUS_BUFFER_TOO_SMALL)
        {
            pAuthenticateMessage = reinterpret_cast<AUTHENTICATE_MESSAGE*>(new CHAR[cbAuthenticateMessage]);
            Status = pAuthenticateMessage ? STATUS_SUCCESS : STATUS_NO_MEMORY;
        }
    }

    if (NT_SUCCESS(Status))
    {
        Status = SsprHandleNtlmv2ChallengeMessage(
                        &Credential,
                        cbChallengeMessage,
                        pChallengeMessage,
                        &NegotiateFlags,
                        &cbAuthenticateMessage,
                        pAuthenticateMessage,
                        &UserSessionKey
                        );
    }

    if (NT_SUCCESS(Status))
    {
        *pNegotiateFlags 		= NegotiateFlags;
        *ppAuthenticateMessage 	= pAuthenticateMessage;
        pAuthenticateMessage 	= NULL;
        *pcbAuthenticateMessage = cbAuthenticateMessage;
        *pUserSessionKey 		= UserSessionKey;
        
        //
        //Put the authenticate message into Windows byte order.
        //
        SspSwapAuthenticateMessageBytes(*ppAuthenticateMessage);
        
        SspDebugPrint((DBUF, "******************** Session Key **********************\n"));
        SspDebugPrintHex(&UserSessionKey, sizeof(UserSessionKey));
        //SspDebugPrintNTLMMsg(*ppAuthenticateMessage, cbAuthenticateMessage);
    }
    else
    {
        SspDebugPrint((DBUF, "SsprHandleNtlmv2ChallengeMessage() failed!"));
        
        if (pAuthenticateMessage) {
            
            delete pAuthenticateMessage;
        }
    }
    
    //
    //Release the allocated unicode buffer after zeroing it out.
    //
    if (uszCleartextPassword.Buffer != NULL)
    {
	    //
	    //03.01.02 MJC: We need to zero out the buffer before freeing
	    //otherwise the password may still exist in memory.
	    //
    	RtlSecureZeroMemory(
    		uszCleartextPassword.Buffer,
    		uszCleartextPassword.Length
    		);
    	
        DisposePtr((Ptr)uszCleartextPassword.Buffer);
    }

    return NT_SUCCESS(Status) ? S_OK : E_FAIL;
}


// ---------------------------------------------------------------------------
//		 MacSspGenerateChallengeMessage()
// ---------------------------------------------------------------------------
//	This function creates a "fake" challenge message that can be passed to
//	MacSspHandleNtlmv2ChallengeMessage(). Use this function in the case where
//	you only want to do NTLMv2 authentication (not session security) and are
//	only supplied an 8 byte MSV1_0_CHALLENGE message.
//
//	NOTE: This function reverses byte order to align with windows, so don't
//	attempt to access elements in the structure upon return from this function!
//	The return value should be passed directly to MacSspHandleNtlmv2ChallengeMessage()
//	without modification.
//

HRESULT
MacSspGenerateChallengeMessage(
	IN 	CHAR					pChallengeToClient[MSV1_0_CHALLENGE_LENGTH],
	OUT ULONG*					pcbChallengeMessage,
	OUT	CHALLENGE_MESSAGE**		ppChallengeMessage
	)
{
	HRESULT		hResult	= E_FAIL;
	ULONG		NegotiateFlags;
	
	//
	//Fake the negotiate flags for what we want.
	//
	NegotiateFlags = 	NTLMSSP_NEGOTIATE_UNICODE		|
						NTLMSSP_NEGOTIATE_ALWAYS_SIGN	|
						NTLMSSP_NEGOTIATE_NTLM2			|
						NTLMSSP_NEGOTIATE_128			|
						NTLMSSP_TARGET_TYPE_SERVER;
	
	*pcbChallengeMessage = sizeof(CHALLENGE_MESSAGE);
	*ppChallengeMessage  = (CHALLENGE_MESSAGE*)new char[*pcbChallengeMessage];
	
	hResult = (*ppChallengeMessage) ? S_OK : E_OUTOFMEMORY;
	
	if (SUCCEEDED(hResult))
	{
		ZeroMemory(*ppChallengeMessage, *pcbChallengeMessage);
		
		StringCbCopy(
			(char*)(*ppChallengeMessage)->Signature,
			sizeof((*ppChallengeMessage)->Signature),
			NTLMSSP_SIGNATURE
			);
			
		CopyMemory(
			(*ppChallengeMessage)->Challenge, 
			pChallengeToClient,
			MSV1_0_CHALLENGE_LENGTH
			);
		
		(*ppChallengeMessage)->MessageType			= NtLmChallenge;
		(*ppChallengeMessage)->NegotiateFlags		= NegotiateFlags;
				
		(*ppChallengeMessage)->TargetInfo.Buffer	= *pcbChallengeMessage;
		(*ppChallengeMessage)->TargetName.Buffer	= *pcbChallengeMessage;
	}
	
	//
	//Swap the bytes to align with windows system since we assume
	//here that the result will be passed directly to the above
	//function.
	//
	SspSwapChallengeMessageBytes(*ppChallengeMessage);
	
	return hResult;
}


// ---------------------------------------------------------------------------
//		 MacSspCalculateLmResponse()
// ---------------------------------------------------------------------------
//	Wrapper to windows function to calculate LmResponse back to server.
//

BOOL
MacSspCalculateLmResponse(
    IN PLM_CHALLENGE 	LmChallenge,
    IN PLM_OWF_PASSWORD LmOwfPassword,
    OUT PLM_RESPONSE 	LmResponse
    )
{	
	return CalculateLmResponse(LmChallenge, LmOwfPassword, LmResponse);
}


// ---------------------------------------------------------------------------
//		 MacSspCalculateLmOwfPassword()
// ---------------------------------------------------------------------------
//	An LmOwf function that works on a Mac.
//

BOOL
MacSspCalculateLmOwfPassword(
    IN 	PLM_PASSWORD 		LmPassword,
    OUT PLM_OWF_PASSWORD 	LmOwfPassword
)
{
	return CalculateLmOwfPassword(LmPassword, LmOwfPassword);
}

// ---------------------------------------------------------------------------
//		 MacSspEncryptBlock()
// ---------------------------------------------------------------------------
//	Routine Description:
//
//    Takes a block of data and encrypts it with a key producing
//    an encrypted block of data.
//
//	Arguments:
//
//    ClearBlock - The block of data that is to be encrypted.
//
//    BlockKey - The key to use to encrypt data
//
//    CypherBlock - Encrypted data is returned here
//
//	Return Values:
//
//    TRUE - The data was encrypted successfully. The encrypted
//                     data block is in CypherBlock
//
//    FALSE - Something failed. The CypherBlock is undefined.

BOOL
MacSspEncryptBlock(
	IN 	PCLEAR_BLOCK 	ClearBlock,
	IN 	PBLOCK_KEY 		BlockKey,
	OUT PCYPHER_BLOCK 	CypherBlock
	)
{
    unsigned Result;

    Result = DES_ECB_LM(ENCR_KEY,
                        (const char *)BlockKey,
                        (unsigned char *)ClearBlock,
                        (unsigned char *)CypherBlock
                       );

    if (Result == CRYPT_OK) {
        return(TRUE);
    } else {
        return(FALSE);
    }
}


// ---------------------------------------------------------------------------
//		 MacSspEncryptLmOwfPwdWithLmOwfPwd()
// ---------------------------------------------------------------------------
//	Routine Description:
//
//    Encrypts one OwfPassword with another
//
//	Arguments:
//
//    DataLmOwfPassword - OwfPassword to be encrypted
//
//    KeyLmOwfPassword - OwfPassword to be used as a key to the encryption
//
//    EncryptedLmOwfPassword - The encrypted OwfPassword is returned here.
//
//	Return Values:
//
//    TRUE - The function completed successfully. The encrypted
//                     OwfPassword is in EncryptedLmOwfPassword
//
//    FALSE - Something failed. The EncryptedLmOwfPassword is undefined.

BOOL
MacSspEncryptLmOwfPwdWithLmOwfPwd(
    	IN 	PLM_OWF_PASSWORD 			DataLmOwfPassword,
    	IN 	PLM_OWF_PASSWORD 			KeyLmOwfPassword,
   		OUT PENCRYPTED_LM_OWF_PASSWORD 	EncryptedLmOwfPassword
   		)
{
    Boolean    Status;
    PBLOCK_KEY	pK;

    Status = MacSspEncryptBlock(  (PCLEAR_BLOCK)&(DataLmOwfPassword->data[0]),
                            &(((PBLOCK_KEY)(KeyLmOwfPassword->data))[0]),
                            &(EncryptedLmOwfPassword->data[0]));
    if (!Status) {
        return(Status);
    }
    
    pK = (PBLOCK_KEY)&(KeyLmOwfPassword->data[1]);
    
    //
    //Notice the "-1" in the second parameter, this is necessary because the
    //compiler aligns on an 8 byte boundary!
    //

    Status = MacSspEncryptBlock(  (PCLEAR_BLOCK)&(DataLmOwfPassword->data[1]),
                            /*(PBLOCK_KEY)&(KeyLmOwfPassword->data[1]),*/ (PBLOCK_KEY)(((PUCHAR)pK)-1),
                            &(EncryptedLmOwfPassword->data[1]));  
     
    //
    //*****************************************
    //
    
    return(Status);
}


// ---------------------------------------------------------------------------
//		 MacSspEncryptNtOwfPwdWithNtOwfPwd()
// ---------------------------------------------------------------------------
//	Routine Description:
//
//    Encrypts one OwfPassword with another

BOOL
MacSspEncryptNtOwfPwdWithNtOwfPwd(
    IN	PNT_OWF_PASSWORD			DataNtOwfPassword,
    IN	PNT_OWF_PASSWORD			KeyNtOwfPassword,
    OUT	PENCRYPTED_NT_OWF_PASSWORD	EncryptedNtOwfPassword
    )
{
    return( MacSspEncryptLmOwfPwdWithLmOwfPwd(
                (PLM_OWF_PASSWORD)DataNtOwfPassword,
                (PLM_OWF_PASSWORD)KeyNtOwfPassword,
                (PENCRYPTED_LM_OWF_PASSWORD)EncryptedNtOwfPassword));
}


// ---------------------------------------------------------------------------
//		 MacSspSampEncryptLmPasswords()
// ---------------------------------------------------------------------------
//Routine Description:
//
//    Encrypts the cleartext passwords into the form that is sent over
//    the network.  Before computing the OWF passwords, the cleartext forms
//    are upper cased, then OEMed (the order is significant).  The cleartext
//    password to be sent is OEMed only.
//
//Arguments:
//
//Return Value:

BOOL
MacSspSampEncryptLmPasswords(
	    LPSTR OldUpcasePassword,
	    LPSTR NewUpcasePassword,
	    LPSTR NewPassword,
	    PSAMPR_ENCRYPTED_USER_PASSWORD NewEncryptedWithOldLm,
	    PENCRYPTED_NT_OWF_PASSWORD OldLmOwfEncryptedWithNewLm
	    )
{
    LM_OWF_PASSWORD OldLmOwfPassword;
    LM_OWF_PASSWORD NewLmOwfPassword;
    PSAMPR_USER_PASSWORD NewLm = (PSAMPR_USER_PASSWORD) NewEncryptedWithOldLm;
    struct RC4_KEYSTRUCT Rc4Key;
    Boolean Status;
    
    ZeroMemory(&Rc4Key, sizeof(RC4_KEYSTRUCT));

    //
    // Calculate the LM OWF passwords
    //
    Status = CalculateLmOwfPassword(
                OldUpcasePassword,
                &OldLmOwfPassword
                );
    
    if (Status)
    {
        Status = CalculateLmOwfPassword(
                    NewUpcasePassword,
                    &NewLmOwfPassword
                    );
    }

    //
    // Calculate the encrypted old passwords
    //
    if (Status)
    {
        Status = MacSspEncryptLmOwfPwdWithLmOwfPwd(
                    &OldLmOwfPassword,
                    &NewLmOwfPassword,
                    OldLmOwfEncryptedWithNewLm
                    );
    }
    
    //
    // Calculate the encrypted new passwords
    //
    if (Status)
    {
        //
        // Compute the encrypted new password with LM key.
        //
        rc4_key(
            &Rc4Key,
            (DWORD)LM_OWF_PASSWORD_LENGTH,
            (PUCHAR)&OldLmOwfPassword
            );
            
        CopyMemory(
            ((PUCHAR) NewLm->Buffer) + (SAM_MAX_PASSWORD_LENGTH * sizeof(UInt16)) - strlen(NewPassword),
            NewPassword,
            strlen(NewPassword)
            );
    
        NewLm->Length = strlen(NewPassword);
		NewLm->Length = swaplong(NewLm->Length);
	
        rc4(&Rc4Key,
            sizeof(SAMPR_USER_PASSWORD),
            (PUCHAR) NewLm->Buffer
            );
    }

    return Status;
}


// ---------------------------------------------------------------------------
//		 MacSspSamiEncryptPasswords()
// ---------------------------------------------------------------------------
// Produces encrypted old and new passwords.
//

OSStatus
MacSspSamiEncryptPasswords(
    IN	PUNICODE_STRING					oldPassword,
    IN	PUNICODE_STRING					newPassword,
    OUT	PSAMPR_ENCRYPTED_USER_PASSWORD	NewEncryptedWithOldNt,
    OUT	PENCRYPTED_NT_OWF_PASSWORD		OldNtOwfEncryptedWithNewNt
    )
{
    OSStatus					Status;
    NT_OWF_PASSWORD				OldNtOwfPassword;
    NT_OWF_PASSWORD				NewNtOwfPassword;
    PSAMPR_USER_PASSWORD		NewNt = (PSAMPR_USER_PASSWORD)NewEncryptedWithOldNt;
    
    struct RC4_KEYSTRUCT		Rc4Key;
    
    SspDebugPrint((DBUF, "Entering MacSfpSamiEncryptPasswords()"));
    
    //
    //The struct must be zero filled to start.
    //
    ZeroMemory(&Rc4Key, sizeof(RC4_KEYSTRUCT));
    ZeroMemory(&OldNtOwfPassword, sizeof(OldNtOwfPassword));
    ZeroMemory(&NewNtOwfPassword, sizeof(NewNtOwfPassword));
    
    //
    //Calculate the NT OWF passwords.
    //
    
    Status = CalculateNtOwfPassword(oldPassword, &OldNtOwfPassword);
    
    if (NT_SUCCESS(Status))
    {
        Status = CalculateNtOwfPassword(newPassword, &NewNtOwfPassword);
    }
    
    //
    //Compute the encrypted old passwords.
    //
    
    if (NT_SUCCESS(Status))
    {
        Status = MacSspEncryptNtOwfPwdWithNtOwfPwd(
                        &OldNtOwfPassword,
                        &NewNtOwfPassword,
                        OldNtOwfEncryptedWithNewNt
                        );
    }
    
    //
    //Calculate the encrypted new passwords.
    //
    
    if (NT_SUCCESS(Status))
    {
        //
        //Compute the encrypted new password with NT key.
        //
        rc4_key(
            &Rc4Key,
            NT_OWF_PASSWORD_LENGTH,
            (PUCHAR)&OldNtOwfPassword
            );
            
        CopyMemory(
            ((PUCHAR)NewNt->Buffer) + SAM_MAX_PASSWORD_LENGTH * sizeof(WCHAR) - newPassword->Length,
            newPassword->Buffer,
            newPassword->Length
            );
            
        NewNt->Length = newPassword->Length;
        NewNt->Length = swaplong(NewNt->Length);
    }
    
    if (NT_SUCCESS(Status))
    {
        rc4(
            &Rc4Key,
            sizeof(SAMPR_USER_PASSWORD),
            (PUCHAR)NewEncryptedWithOldNt
            );
    }
    
    SspDebugPrint((DBUF, "Leaving MacSfpSamiEncryptPasswords()"));
    
    return(Status);
}


// ---------------------------------------------------------------------------
//		 MacSspSamiEncryptPasswordsANSI()
// ---------------------------------------------------------------------------
// Produces encrypted old and new passwords. This routine does not use any
// of the Mac's unicode utilities, therefore, we should not use it. We need
// to leave this here however for possible future use by other parties.
//

OSStatus
MacSspSamiEncryptPasswordsANSI(
    IN	PCSTR							oldPassword,
    IN	PCSTR							newPassword,
    OUT	PSAMPR_ENCRYPTED_USER_PASSWORD	NewEncryptedWithOldNt,
    OUT	PENCRYPTED_NT_OWF_PASSWORD		OldNtOwfEncryptedWithNewNt
    )
{
    OSStatus		Status;
    UNICODE_STRING	uszOldPassword;
    UNICODE_STRING	uszNewPassword;
    CHAR 			oldPasswordStorage[(UNLEN + 4) * sizeof(WCHAR)];
    CHAR 			newPasswordStorage[(UNLEN + 4) * sizeof(WCHAR)];

    //
    //Build a unicode string from the supplied ansi password with which
    //we'll use to build a owf password. Note that we swap the strings
    //to windows alignment before we calculate passwords.
    //
    
    uszOldPassword.Length			= 0;
    uszOldPassword.MaximumLength	= sizeof(oldPasswordStorage);
    uszOldPassword.Buffer			= (PWSTR)oldPasswordStorage;
    
    SspInitUnicodeStringNoAlloc(oldPassword, (UNICODE_STRING*)&uszOldPassword);
    SspSwapUnicodeString(&uszOldPassword);

    uszNewPassword.Length			= 0;
    uszNewPassword.MaximumLength	= sizeof(newPasswordStorage);
    uszNewPassword.Buffer			= (PWSTR)newPasswordStorage;

    SspInitUnicodeStringNoAlloc(newPassword, (UNICODE_STRING*)&uszNewPassword);
    SspSwapUnicodeString(&uszNewPassword);
    
    Status = MacSspSamiEncryptPasswords(
                &uszOldPassword,
                &uszNewPassword,
                NewEncryptedWithOldNt,
                OldNtOwfEncryptedWithNewNt
                );
    
    #if 0          
    SspDebugPrint((DBUF, "NewEncryptedWithOldNt:"));
    SspDebugPrintHex(NewEncryptedWithOldNt, sizeof(SAMPR_ENCRYPTED_USER_PASSWORD));
    SspDebugPrint((DBUF, "OldNtOwfEncryptedWithNewNt:"));
    SspDebugPrintHex(OldNtOwfEncryptedWithNewNt, sizeof(ENCRYPTED_NT_OWF_PASSWORD));
    #endif
    
    //
    //03.01.02 MJC: We need to zero out the buffers
    //otherwise the passwords may still exist in memory.
    //
	RtlSecureZeroMemory(
		uszNewPassword.Buffer,
		uszNewPassword.Length
		);
		
	RtlSecureZeroMemory(
		uszOldPassword.Buffer,
		uszOldPassword.Length
		);
             
    return(Status);
}

#pragma mark-


// ---------------------------------------------------------------------------
//		 MacSspSamiEncryptCStringPasswords()
// ---------------------------------------------------------------------------
// Produces encrypted old and new passwords. This is the C string variant and
// uses the Mac's built in unicode utilities for converting from ASCII to
// unicode strings.
//

OSStatus
MacSspSamiEncryptCStringPasswords(
    IN	PCSTR							oldPassword,
    IN	PCSTR							newPassword,
    OUT	PSAMPR_ENCRYPTED_USER_PASSWORD	NewEncryptedWithOldNt,
    OUT	PENCRYPTED_NT_OWF_PASSWORD		OldNtOwfEncryptedWithNewNt
    )
{
	OSStatus			Status 			= noErr;
    UNICODE_STRING		uszOldPassword	= {0, 0, NULL};
    UNICODE_STRING		uszNewPassword	= {0, 0, NULL};
	
	//
	//Put the converted unicode string into an NT style unicode
	//string strucuture format. Get the unicode equivelant string
	//of the old password.
	//
	Status = MacSspCStringToUnicode(
					oldPassword,
					&uszOldPassword.Length,
					&uszOldPassword.Buffer
					);
					
	uszOldPassword.MaximumLength = uszOldPassword.Length;
	
	if (NT_SUCCESS(Status))
	{		
		Status = MacSspCStringToUnicode(
					newPassword,
					&uszNewPassword.Length,
					&uszNewPassword.Buffer
					);
					
		uszNewPassword.MaximumLength = uszNewPassword.Length;
		
		if (NT_SUCCESS(Status))
		{
		    //
		    //Swap the unicode strings so they are in Windows byte order.
		    //
		    SspSwapUnicodeString(&uszOldPassword);
		    SspSwapUnicodeString(&uszNewPassword);
		    
		    //
		    //Now encrypt everything...
		    //
		    Status = MacSspSamiEncryptPasswords(
		                &uszOldPassword,
		                &uszNewPassword,
		                NewEncryptedWithOldNt,
		                OldNtOwfEncryptedWithNewNt
		                );
		    
		    //
		    //03.01.02 MJC: We need to zero out the buffer before freeing
		    //otherwise the password may still exist in memory.
		    //
			RtlSecureZeroMemory(
				uszNewPassword.Buffer,
				uszNewPassword.Length
				);
			
		    //
		    //We don't need the unicode string buffer anymore.
		    //
		    DisposePtr((Ptr)uszNewPassword.Buffer);
		  	
		  	//
		  	//The following debug code helps a lot when debugging but is
		  	//really annoying in most cases.
		  	//
		  	#if 0
		    SspDebugPrint((DBUF, "NewEncryptedWithOldNt:"));
		    SspDebugPrintHex(NewEncryptedWithOldNt, sizeof(SAMPR_ENCRYPTED_USER_PASSWORD));
		    SspDebugPrint((DBUF, "OldNtOwfEncryptedWithNewNt:"));
		    SspDebugPrintHex(OldNtOwfEncryptedWithNewNt, sizeof(ENCRYPTED_NT_OWF_PASSWORD));
		    #endif
		}
		
	    //
	    //03.01.02 MJC: We need to zero out the buffers before freeing
	    //otherwise the password may still exist in memory.
	    //
	    RtlSecureZeroMemory(
	    	uszOldPassword.Buffer,
	    	uszOldPassword.Length
	    	);
	    
		DisposePtr((Ptr)uszOldPassword.Buffer);
	}
	
	return(Status);
}


// ---------------------------------------------------------------------------
//		 MacSspSamiEncryptPStringPasswords()
// ---------------------------------------------------------------------------
// Produces encrypted old and new passwords. This is the P string variant and
// uses the Mac's built in unicode utilities for converting from ASCII to
// unicode strings.
//

OSStatus
MacSspSamiEncryptPStringPasswords(
	IN	Str255							oldPassword,
	IN	Str255							newPassword,
    OUT	PSAMPR_ENCRYPTED_USER_PASSWORD	NewEncryptedWithOldNt,
    OUT	PENCRYPTED_NT_OWF_PASSWORD		OldNtOwfEncryptedWithNewNt
	)
{
	OSStatus			Status 				= noErr;
    UNICODE_STRING		uszOldPassword		= {0, 0, NULL};
    UNICODE_STRING		uszNewPassword		= {0, 0, NULL};
    
	//
	//Put the converted unicode string into an NT style unicode
	//string strucuture format. Get the unicode equivelant string
	//of the old password.
	//
	Status = MacSspPStringToUnicode(
					oldPassword,
					&uszOldPassword.Length,
					&uszOldPassword.Buffer
					);
					
	uszOldPassword.MaximumLength = uszOldPassword.Length;
	
	if (NT_SUCCESS(Status))
	{
		Status = MacSspPStringToUnicode(
					newPassword,
					&uszNewPassword.Length,
					&uszNewPassword.Buffer
					);
					
		uszNewPassword.MaximumLength = uszNewPassword.Length;
					
		if (NT_SUCCESS(Status))
		{
		    //
		    //Swap the unicode strings so they are in Windows byte order.
		    //
		    SspSwapUnicodeString(&uszOldPassword);
		    SspSwapUnicodeString(&uszNewPassword);
		    
		    //
		    //Now encrypt everything...
		    //
		    Status = MacSspSamiEncryptPasswords(
		                &uszOldPassword,
		                &uszNewPassword,
		                NewEncryptedWithOldNt,
		                OldNtOwfEncryptedWithNewNt
		                );
		    		                
		    //
		    //03.01.02 MJC: We need to zero out the buffer before freeing
		    //otherwise the password may still exist in memory.
		    //
			RtlSecureZeroMemory(
				uszNewPassword.Buffer,
				uszNewPassword.Length
				);

		    //
		    //We don't need the unicode string buffer anymore.
		    //
		    DisposePtr((Ptr)uszNewPassword.Buffer);
		}
		
		
	    //
	    //03.01.02 MJC: We need to zero out the buffers before freeing
	    //otherwise the password may still exist in memory.
	    //
	    RtlSecureZeroMemory(
	    	uszOldPassword.Buffer,
	    	uszOldPassword.Length
	    	);
	    
	    //
	    //We don't need the unicode string buffer anymore.
	    //
		DisposePtr((Ptr)uszOldPassword.Buffer);
	}
	
	return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\uam\macsource\macssp\debug.h ===
/*++

Copyright (c) 1987-1993  Microsoft Corporation

Module Name:

    debug.h

Abstract:

    NtLmSsp service debug support

Author:

    Ported from Lan Man 2.0

Revision History:

    21-May-1991 (cliffv)
        Ported to NT.  Converted to NT style.
    09-Apr-1992 JohnRo
        Prepare for WCHAR.H (_wcsicmp vs _wcscmpi, etc).

--*/

#ifndef DEBUG_H
#define DEBUG_H

//
// init.c will #include this file with DEBUG_ALLOCATE defined.
// That will cause each of these variables to be allocated.
//
#ifdef DEBUG_ALLOCATE
#define EXTERN
#else
#define EXTERN extern
#endif


////////////////////////////////////////////////////////////////////////
//
// Debug Definititions
//
////////////////////////////////////////////////////////////////////////

#define SSP_INIT           0x00000001 // Initialization
#define SSP_MISC           0x00000002 // Misc debug
#define SSP_API            0x00000004 // API processing
#define SSP_LPC            0x00000008 // LPC
#define SSP_NTLMV2         0x00000010 // NTLMv2 specific
#define SSP_CRED           0x00000020 // cred
#define SSP_CRITICAL       0x00000100 // Only real important errors
#define SSP_WARNING        0x00000200 // warning

//
// Very verbose bits
//

#define SSP_API_MORE       0x04000000 // verbose API
#define SSP_LPC_MORE       0x08000000 // verbose LPC

//
// Control bits.
//

#define SSP_TIMESTAMP      0x20000000 // TimeStamp each output line
#define SSP_REQUEST_TARGET 0x40000000 // Force client to ask for target name
#define SSP_USE_OEM        0x80000000 // Force client to use OEM character set


//
// Name and directory of log file
//

#ifdef DEBUGRPC

#define ASSERT(con) \
    if (!(con)) \
    SspPrint((SSP_MISC, "Assert %s(%d): "#con"\n", __FILE__, __LINE__));

EXTERN ULONG SspGlobalDbflag;

#define IF_DEBUG(Function) \
     if (SspGlobalDbflag & SSP_ ## Function)

#define SspPrint(_x_) SspPrintRoutine _x_

void
SspPrintRoutine(
    IN ULONG DebugFlag,
    IN PCHAR FORMATSTRING,     // PRINTF()-STYLE FORMAT STRING.
    ...                                 // OTHER ARGUMENTS ARE POSSIBLE.

    );

#else

#define ASSERT(con)

#define IF_DEBUG(Function) if (FALSE)

// Nondebug version.

#define SspPrint(_x_)

#endif // DEBUGRPC

#undef EXTERN

#endif // DEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\uam\macsource\macssp\macssp.h ===
/*
 *  macssp.h
 *  MSUAM
 *
 *  Created by mconrad on Sun Sep 30 2001.
 *  Copyright (c) 2001 Microsoft Corp. All rights reserved.
 *
 */
 
#ifndef __MAC_SSP__
#define __MAC_SSP__

#include <macstrsafe.h>

#include "descrypt.h"
#include "ntstatus.h"
#include "ntlmsspv2.h"
#include "ntlmsspi.h"
#include "ntlmssp.h"
#include "crypt.h"
#include "sspdebug.h"

//
// From ntsam.h
//
#define SAM_MAX_PASSWORD_LENGTH 256

//
// From sampass.h
//
typedef struct //_SAMPR_USER_PASSWORD
{
	UInt16 	Buffer[SAM_MAX_PASSWORD_LENGTH];
	DWORD 	Length;
}SAMPR_USER_PASSWORD, *PSAMPR_USER_PASSWORD;

//typedef struct _SAMPR_USER_PASSWORD __RPC_FAR *PSAMPR_USER_PASSWORD;
typedef struct  _SAMPR_ENCRYPTED_USER_PASSWORD
{
	UCHAR Buffer[516];
}SAMPR_ENCRYPTED_USER_PASSWORD, *PSAMPR_ENCRYPTED_USER_PASSWORD;

typedef ENCRYPTED_LM_OWF_PASSWORD   ENCRYPTED_NT_OWF_PASSWORD;
typedef ENCRYPTED_NT_OWF_PASSWORD* PENCRYPTED_NT_OWF_PASSWORD;


HRESULT
MacSspHandleNtlmv2ChallengeMessage(
    IN PCSTR 					pszUserName,
    IN PCSTR 					pszDomainName,
    IN PCSTR 					pszWorkstation,
    IN PCSTR 					pszCleartextPassword,
    IN ULONG 					cbChallengeMessage,
    IN CHALLENGE_MESSAGE* 		pChallengeMessage,
    IN OUT ULONG* 				pNegotiateFlags,
    OUT ULONG* 					pcbAuthenticateMessage,
    OUT AUTHENTICATE_MESSAGE** 	ppAuthenticateMessage,
    OUT USER_SESSION_KEY* 		pUserSessionKey
    );
    
HRESULT
MacSspGenerateChallengeMessage(
	IN 	CHAR					pChallengeToClient[MSV1_0_CHALLENGE_LENGTH],
	OUT ULONG*					pcbChallengeMessage,
	OUT	CHALLENGE_MESSAGE**		ppChallengeMessage
	);
    
BOOL
MacSspCalculateLmResponse(
    IN PLM_CHALLENGE 	LmChallenge,
    IN PLM_OWF_PASSWORD LmOwfPassword,
    OUT PLM_RESPONSE 	LmResponse
    );
	
BOOL
MacSspCalculateLmOwfPassword(
    IN 	PLM_PASSWORD 		LmPassword,
    OUT PLM_OWF_PASSWORD 	LmOwfPassword
	);

BOOL
MacSspEncryptBlock(
	IN 	PCLEAR_BLOCK 	ClearBlock,
	IN 	PBLOCK_KEY 		BlockKey,
	OUT PCYPHER_BLOCK 	CypherBlock
	);

BOOL
MacSspEncryptLmOwfPwdWithLmOwfPwd(
	IN 	PLM_OWF_PASSWORD 			DataLmOwfPassword,
	IN 	PLM_OWF_PASSWORD 			KeyLmOwfPassword,
	OUT PENCRYPTED_LM_OWF_PASSWORD 	EncryptedLmOwfPassword
	);

BOOL
MacSspEncryptNtOwfPwdWithNtOwfPwd(
    IN	PNT_OWF_PASSWORD			DataNtOwfPassword,
    IN	PNT_OWF_PASSWORD			KeyNtOwfPassword,
    OUT	PENCRYPTED_NT_OWF_PASSWORD	EncryptedNtOwfPassword
    );

BOOL
MacSspSampEncryptLmPasswords(
    LPSTR OldUpcasePassword,
    LPSTR NewUpcasePassword,
    LPSTR NewPassword,
    PSAMPR_ENCRYPTED_USER_PASSWORD NewEncryptedWithOldLm,
    PENCRYPTED_NT_OWF_PASSWORD OldLmOwfEncryptedWithNewLm
    );
    
OSStatus
MacSspSamiEncryptPasswords(
    IN	PUNICODE_STRING					oldPassword,
    IN	PUNICODE_STRING					newPassword,
    OUT	PSAMPR_ENCRYPTED_USER_PASSWORD	NewEncryptedWithOldNt,
    OUT	PENCRYPTED_NT_OWF_PASSWORD		OldNtOwfEncryptedWithNewNt
    );
    
OSStatus
MacSspSamiEncryptPasswordsANSI(
    IN	PCSTR							oldPassword,
    IN	PCSTR							newPassword,
    OUT	PSAMPR_ENCRYPTED_USER_PASSWORD	NewEncryptedWithOldNt,
    OUT	PENCRYPTED_NT_OWF_PASSWORD		OldNtOwfEncryptedWithNewNt
    );

OSStatus
MacSspSamiEncryptCStringPasswords(
    IN	PCSTR							oldPassword,
    IN	PCSTR							newPassword,
    OUT	PSAMPR_ENCRYPTED_USER_PASSWORD	NewEncryptedWithOldNt,
    OUT	PENCRYPTED_NT_OWF_PASSWORD		OldNtOwfEncryptedWithNewNt
    );
		
OSStatus
MacSspSamiEncryptPStringPasswords(
	IN	Str255							oldPassword,
	IN	Str255							newPassword,
    OUT	PSAMPR_ENCRYPTED_USER_PASSWORD	NewEncryptedWithOldNt,
    OUT	PENCRYPTED_NT_OWF_PASSWORD		OldNtOwfEncryptedWithNewNt
	);
	
#endif //__MAC_SSP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\uam\macsource\macssp\macunicode.c ===
/*
 *  macunicode.cpp
 *  MSUAM
 *
 *  Created by mconrad on Fri Nov 16 2001.
 *  Copyright (c) 2001 Microsoft Corp. All rights reserved.
 *
 */

#include "macunicode.h"



// ---------------------------------------------------------------------------
//		 MacSspCStringToUnicode()
// ---------------------------------------------------------------------------
// Convert a c-string (null terminated mbcs) into a unicode string.
//

OSStatus
MacSspCStringToUnicode(
	IN	PCSTR				cString,
	OUT	UInt16*				unicodeLen,
	OUT	UniCharArrayPtr*	unicodeString
	)
{
	UnicodeMapping		unicodeMapping;
	TextToUnicodeInfo	textInfo;
	OSStatus			Status					= noErr;
	ByteCount			unicodeBufferSize		= CALC_UNICODE_CSTRING_LENGTH(cString);
	ByteCount			unicodeActualLen		= 0;
	UniCharArrayPtr		unicodeResult			= NULL;
    ByteCount			actualCharsConverted	= 0;
    OptionBits			controlFlags			= 0;
	
	//
	//Just in case the caller didn't initialize the return
	//parameters, we'll do it for them for safety.
	//
	*unicodeString 	= NULL;
	*unicodeLen		= 0;
	
	//
	//Create the test encoding that we'll use to convert Mac
	//characters to unicode chars.
	//
	unicodeMapping.unicodeEncoding 	= CreateTextEncoding(
											kTextEncodingUnicodeV2_0,
											kUnicodeNoSubset,
											kUnicode16BitFormat
											);
    
    //
    //Call our homegrown routine that will set the proper encoding
    //for the current script system.
    //
    Status = MacSspGetCurrentTextEncoding(&unicodeMapping.otherEncoding);
    
    if (NT_SUCCESS(Status))
    {
        unicodeMapping.mappingVersion	= kUnicodeUseLatestMapping;
        
        Status = CreateTextToUnicodeInfo(&unicodeMapping, &textInfo);
                
        if (NT_SUCCESS(Status))
        {
        	//
        	//Allocate memory for the unicode string. Note that the buffer
        	//should be big enough to hold the new unicode string.
        	//
            unicodeResult = (UniCharArrayPtr)NewPtrClear(unicodeBufferSize);
            
            if (unicodeResult != nil)
            {
	            //
	            //Set the control flags for this conversion.
	            //
	            //controlFlags = kUnicodeForceASCIIRangeMask;
	            
	            Status = ConvertFromTextToUnicode(
	                            textInfo,
	                            strlen(cString),
	                            cString,
	                            controlFlags,
	                            0,
	                            NULL,
	                            NULL,
	                            NULL,
	                            unicodeBufferSize,
	                            &actualCharsConverted,
	                            &unicodeActualLen,
	                            unicodeResult
	                            );
	                            
	            SspDebugPrint((DBUF, "ConvertFromTextToUnicode() returned = %d", Status));
	            
	            if (NT_SUCCESS(Status))
	            {
	                SspDebugPrintHex(unicodeResult, unicodeActualLen);
	                
	                *unicodeString 	= unicodeResult;
	                *unicodeLen		= unicodeActualLen;
	            }
	        }
	        else
	        {
	        	Status = memFullErr;
	        }
            
            //
            //Dispose of the opaque info structure used for the conversion.
            //
            DisposeTextToUnicodeInfo(&textInfo);
        }
	}
    
	return(Status);
}


// ---------------------------------------------------------------------------
//		 MacSspUnicodeToWindowsCString()
// ---------------------------------------------------------------------------
// Converts a unicode string to a single byte CString using the Windows ASCII
// mapping table.
//

OSStatus
MacSspUnicodeToWindowsCString(
	IN	UniCharArrayPtr		unicodeString,
	IN	UInt32				unicodeLen,
	IN	UInt32				cStringBufferLen,
	OUT	PCHAR				cString
	)
{
	OSStatus			Status	= noErr;
	UnicodeMapping		unicodeMapping;
	UnicodeToTextInfo	textInfo;
	ByteCount			inputRead 	= 0;
	ByteCount			outputLen 	= 0;
	OptionBits			options		= 0;
	
	unicodeMapping.unicodeEncoding 	= CreateTextEncoding(
                                            kTextEncodingUnicodeV2_0,
                                            kUnicodeNoSubset,
                                            kUnicode16BitFormat
                                            );
    
    unicodeMapping.otherEncoding	= CreateTextEncoding(
											kTextEncodingWindowsLatin1,
											kTextEncodingDefaultVariant,
											kTextEncodingDefaultFormat
											);
                                            
	unicodeMapping.mappingVersion	= kUnicodeUseLatestMapping;
	
	Status = CreateUnicodeToTextInfo(
				&unicodeMapping,
				&textInfo
				);
				
	if (NT_SUCCESS(Status))
	{
		//
		//Set the options bits. If we don't set the fallback bit, then
		//conversion from unicode to Windows will fail if extended
		//characters are in the string.
		//
		options	= kUnicodeUseFallbacksMask;
		
		Status = ConvertFromUnicodeToText(
						textInfo,
						unicodeLen,
						unicodeString,
						options,
						0,
						NULL,
						NULL,
						NULL,
						cStringBufferLen,
						&inputRead,
						&outputLen,
						cString
						);
                        
        SspDebugPrint((DBUF, "ConvertFromUnicodeToText() returned: %d", Status));
						
		DisposeUnicodeToTextInfo(&textInfo);
	}
	
	return(Status);
}


// ---------------------------------------------------------------------------
//		 MacSspPStringToUnicode()
// ---------------------------------------------------------------------------
// Convert a PString into a unicode string.
//

OSStatus
MacSspPStringToUnicode(
	IN	Str255				PString,
	OUT	UInt16*				unicodeLen,
	OUT	UniCharArrayPtr*	unicodeString
	)
{
	UnicodeMapping		unicodeMapping;
	TextToUnicodeInfo	textInfo;
	OSStatus			Status				= noErr;
	ByteCount			unicodeBufferSize	= CALC_UNICODE_PSTRING_LENGTH(PString);
	ByteCount			unicodeActualLen	= 0;
	UniCharArrayPtr		unicodeResult		= NULL;
	
	unicodeMapping.unicodeEncoding 	= CreateTextEncoding(
											kTextEncodingUnicodeV2_0,
											kUnicodeNoSubset,
											kUnicode16BitFormat
											);

    //
    //Call our homegrown routine that will set the proper encoding
    //for the current script system.
    //
    Status = MacSspGetCurrentTextEncoding(&unicodeMapping.otherEncoding);
    
    if (NT_SUCCESS(Status))
    {
        unicodeMapping.mappingVersion	= kUnicodeUseLatestMapping;
        
        Status = CreateTextToUnicodeInfo(&unicodeMapping, &textInfo);
                
        if (NT_SUCCESS(Status))
        {
            unicodeResult = (UniCharArrayPtr)NewPtrClear(unicodeBufferSize);
            
            if (unicodeResult != nil)
            {
	            Status = ConvertFromPStringToUnicode(
	                            textInfo,
	                            PString,
	                            unicodeBufferSize,
	                            &unicodeActualLen,
	                            unicodeResult
	                            );
	            
	            SspDebugPrint((DBUF, "ConvertFromPStringToUnicode() returned = %d", Status));
	            
	            if (NT_SUCCESS(Status))
	            {
	                SspDebugPrintHex(unicodeResult, unicodeActualLen);
	                
	                *unicodeString 	= unicodeResult;
	                *unicodeLen		= unicodeActualLen;
	            }
	        }
	        else
	        {
	        	Status = memFullErr;
	        }
            
            //
            //Dispose of the opaque info structure used for the conversion.
            //
            DisposeTextToUnicodeInfo(&textInfo);
        }
	}
    
	return(Status);
}


// ---------------------------------------------------------------------------
//		 MacSspGetCurrentTextEncoding()
// ---------------------------------------------------------------------------
// Returns a text encoding of the current system script.
//

OSStatus
MacSspGetCurrentTextEncoding(
    OUT	TextEncoding* currentEncoding
    )
{
    OSStatus	Status = noErr;
    LangCode	currentLang;
    
    //
    //Unfortuanately, we cannot test for failure here since a value of
    //0 actual means its a US system. I guess it should never fail??
    //
    currentLang = (LangCode)GetScriptVariable(smCurrentScript, smScriptLang);
    
    //
    //Call the API that converts Scrip Manager information into an encoding
    //we can use in the conversion routines.
    //
    Status = UpgradeScriptInfoToTextEncoding(
                    smCurrentScript,
                    currentLang,
                    kTextRegionDontCare,
                    NULL,
                    currentEncoding
                    );
    
    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\uam\macsource\macssp\macunicode.h ===
/*
 *  macunicode.h
 *  MSUAM
 *
 *  Created by mconrad on Fri Nov 16 2001
 *  Copyright (c) 2001 Microsoft Corp. All rights reserved.
 *
 */
 
#ifndef __MACUNICODE__
#define __MACUNICODE__
 
#ifdef SSP_TARGET_CARBON
#include <Carbon/Carbon.h>
#else
#include <TextCommon.h>
#include <Unicode.h>
#include <UnicodeConverter.h>
#endif

#include <bootdefs.h>
#include <sspdebug.h>


#define CALC_UNICODE_CSTRING_LENGTH(s)		((strlen(s) * sizeof(UniChar)) + sizeof(UniChar))
#define CALC_UNICODE_PSTRING_LENGTH(s)		((s[0] * sizeof(UniChar)) + sizeof(UniChar))

#ifdef __cplusplus
extern "C" {
#endif

OSStatus
MacSspCStringToUnicode(
	IN	PCSTR				cString,
	OUT	UInt16*				unicodeLen,
	OUT	UniCharArrayPtr*	unicodeString
	);
	
OSStatus
MacSspUnicodeToWindowsCString(
	IN	UniCharArrayPtr		unicodeString,
	IN	UInt32				unicodeLen,
	IN	UInt32				cStringBufferLen,
	OUT	PCHAR				cString
	);

OSStatus
MacSspPStringToUnicode(
	IN	Str255				PString,
	OUT	UInt16*				unicodeLen,
	OUT	UniCharArrayPtr*	unicodeString
	);

OSStatus
MacSspGetCurrentTextEncoding(
    OUT	TextEncoding* currentEncoding
    );
	
#ifdef __cplusplus
}
#endif

#endif //__MACUNICODE__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\uam\macsource\macssp\nlsboot.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    nlsboot.h

Abstract:

    This header is only need on Macintosh machines to build the Rtl routines.

Author:

    Michael J. Conrad (mconrad) 9/26/01

Revision History:


--*/

#ifndef __NLSBOOT__
#define __NLSBOOT__

#ifdef MAC

#ifdef SSP_TARGET_CARBON
#include <Carbon/Carbon.h>
#endif

#include <bootdefs.h>
#include <ntstatus.h>
#include <crypt.h>
#include <ntlmsspi.h>

#endif


//
//Define equivelant for RtlMoveMemory on mac
//
#define RtlMoveMemory(dest, source, length)		BlockMove(source, dest, length);

#ifdef __cplusplus
extern "C" {
#endif

NTSTATUS
RtlAnsiStringToUnicodeString(
    OUT PUNICODE_STRING DestinationString,
    IN PCANSI_STRING SourceString,
    IN BOOLEAN AllocateDestinationString
    );
    
LONG
RtlCompareUnicodeString(
    IN PCUNICODE_STRING String1,
    IN PCUNICODE_STRING String2,
    IN BOOLEAN CaseInSensitive
    );

BOOLEAN
RtlEqualUnicodeString(
    IN const UNICODE_STRING *String1,
    IN const UNICODE_STRING *String2,
    IN BOOLEAN CaseInSensitive
    );

VOID
RtlInitString(
    OUT PSTRING DestinationString,
    IN PCSZ SourceString OPTIONAL
    );

VOID
RtlInitUnicodeString(
    OUT PUNICODE_STRING DestinationString,
    IN PCWSTR SourceString OPTIONAL
    );

VOID
RtlInitAnsiString(
    OUT PANSI_STRING DestinationString,
    IN PCSTR SourceString OPTIONAL
    );

NTSTATUS
RtlAppendUnicodeStringToString (
    IN OUT PUNICODE_STRING Destination,
    IN PCUNICODE_STRING Source
    );

NTSTATUS
RtlAppendUnicodeToString (
    IN PUNICODE_STRING Destination,
    IN PCWSTR Source OPTIONAL
    );

WCHAR
RtlUpcaseUnicodeChar(
    IN WCHAR SourceCharacter
    );

WCHAR
RtlAnsiCharToUnicodeChar(
    IN OUT PUCHAR *SourceCharacter
    );

NTSTATUS
RtlUpcaseUnicodeToMultiByteN(
    OUT PCH MultiByteString,
    IN ULONG MaxBytesInMultiByteString,
    OUT PULONG BytesInMultiByteString OPTIONAL,
    IN PWCH UnicodeString,
    IN ULONG BytesInUnicodeString);

NTSTATUS
RtlMultiByteToUnicodeN(
    OUT PWCH UnicodeString,
    IN ULONG MaxBytesInUnicodeString,
    OUT PULONG BytesInUnicodeString OPTIONAL,
    IN PCSTR MultiByteString,
    IN ULONG BytesInMultiByteString);

NTSTATUS
RtlUnicodeToMultiByteN(
    OUT PCH MultiByteString,
    IN ULONG MaxBytesInMultiByteString,
    OUT PULONG BytesInMultiByteString OPTIONAL,
    IN PWCH UnicodeString,
    IN ULONG BytesInUnicodeString);

#ifdef __cplusplus
}
#endif
#endif //__NLSBOOT__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\uam\macsource\macssp\ntlmssp.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    ntlmssp.h

Abstract:

    Externally visible definition of the NT Lanman Security Support Provider
    (NtLmSsp) Service.

Author:

    Cliff Van Dyke (cliffv) 01-Jul-1993

Environment:

    User mode only.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    Borrowed from the Cairo's ntlmssp.h by PeterWi.

--*/

#ifndef _NTLMSSP_
#define _NTLMSSP_

//#include <security.h>
//#include <spseal.h>
//
// Defines for SecPkgInfo structure returned by QuerySecurityPackageInfo
//

#undef NTLMSP_NAME
#define NTLMSP_NAME             "NTLM"
#define NTLMSP_COMMENT          "NTLM Security Package"

#define NTLMSP_CAPABILITIES     (SECPKG_FLAG_TOKEN_ONLY | \
                                 SECPKG_FLAG_INTEGRITY | \
                                 SECPKG_FLAG_PRIVACY | \
                                 SECPKG_FLAG_MULTI_REQUIRED | \
                                 SECPKG_FLAG_CONNECTION)

#define NTLMSP_VERSION          1
#define NTLMSP_MAX_TOKEN_SIZE 0x300

// includes that should go elsewhere.

//
// Move to secscode.h
//

#define SEC_E_PRINCIPAL_UNKNOWN SEC_E_UNKNOWN_CREDENTIALS
#define SEC_E_PACKAGE_UNKNOWN SEC_E_SECPKG_NOT_FOUND
#ifndef MAC
#define SEC_E_BUFFER_TOO_SMALL SEC_E_INSUFFICIENT_MEMORY
#endif
#define SEC_I_CALLBACK_NEEDED SEC_I_CONTINUE_NEEDED
#define SEC_E_INVALID_CONTEXT_REQ SEC_E_NOT_SUPPORTED
#define SEC_E_INVALID_CREDENTIAL_USE SEC_E_NOT_SUPPORTED

//
// Move to security.h
//


#endif // _NTLMSSP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\uam\macsource\macssp\nlsboot.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    nlsboot.c

Abstract:

    This module contains NLS routines for use by the OS Loader.  Before
    the NLS tables are loaded, they convert between ANSI and Unicode by
    zero-extending.

Author:

    John Vert (jvert) 11-Nov-1992

Revision History:

    John Vert (jvert) 11-Nov-1992
        created - mostly copied from old RTL routines

--*/

#ifndef MAC
#include "bldr.h"
#else

#ifdef SSP_TARGET_CARBON
#include <Carbon/Carbon.h>
#endif //SSP_TARGET_CARBON

#include <nlsboot.h>

#endif

//
// Hack-o-rama string routines to use before tables are loaded
//

#define upcase(C) (WCHAR )(((C) >= 'a' && (C) <= 'z' ? (C) - ('a' - 'A') : (C)))


NTSTATUS
RtlAnsiStringToUnicodeString(
    OUT PUNICODE_STRING DestinationString,
    IN PCANSI_STRING SourceString,
    IN BOOLEAN AllocateDestinationString
    )

{
    ULONG UnicodeLength;
    ULONG Index;

    UnicodeLength = (SourceString->Length << 1) + sizeof(UNICODE_NULL);

    if ( UnicodeLength > MAXUSHORT ) {
        return STATUS_INVALID_PARAMETER_2;
        }

    DestinationString->Length = (USHORT)(UnicodeLength - sizeof(UNICODE_NULL));
    if ( AllocateDestinationString ) {
        return STATUS_NO_MEMORY;
        }
    else {
        if ( DestinationString->Length >= DestinationString->MaximumLength ) {
            return STATUS_BUFFER_OVERFLOW;
            }
        }

    Index = 0;
    while(Index < SourceString->Length )
	{
        DestinationString->Buffer[Index] = (WCHAR)SourceString->Buffer[Index];
        Index++;
        }
    DestinationString->Buffer[Index] = UNICODE_NULL;

    return STATUS_SUCCESS;
}

NTSTATUS
RtlUnicodeStringToAnsiString(
    OUT PANSI_STRING DestinationString,
    IN  PCUNICODE_STRING SourceString,
    IN BOOLEAN AllocateDestinationString
    )

{
    ULONG AnsiLength;
    ULONG Index;

    AnsiLength = SourceString->Length + 1;

    if ( AnsiLength > MAXUSHORT ) {
        return STATUS_INVALID_PARAMETER_2;
        }

    DestinationString->Length = (USHORT)(AnsiLength*2);
    if ( AllocateDestinationString ) {
        return STATUS_NO_MEMORY;
        }
    else {
        if ( DestinationString->Length >= DestinationString->MaximumLength ) {
            return STATUS_BUFFER_OVERFLOW;
            }
        }

    Index = 0;
    while(Index < SourceString->Length ) {
        DestinationString->Buffer[Index] = (CHAR)SourceString->Buffer[Index];
        Index++;
        }
    DestinationString->Buffer[Index] = TEXT('\0');

    return STATUS_SUCCESS;
}


LONG
RtlCompareUnicodeString(
    IN PCUNICODE_STRING String1,
    IN PCUNICODE_STRING String2,
    IN BOOLEAN CaseInSensitive
    )

/*++

Routine Description:

    The RtlCompareUnicodeString function compares two counted strings.  The
    return value indicates if the strings are equal or String1 is less than
    String2 or String1 is greater than String2.

    The CaseInSensitive parameter specifies if case is to be ignored when
    doing the comparison.

Arguments:

    String1 - Pointer to the first string.

    String2 - Pointer to the second string.

    CaseInsensitive - TRUE if case should be ignored when doing the
        comparison.

Return Value:

    Signed value that gives the results of the comparison:

        Zero - String1 equals String2

        < Zero - String1 less than String2

        > Zero - String1 greater than String2


--*/

{

    UNALIGNED WCHAR *s1, *s2;
    USHORT n1, n2;
    WCHAR c1, c2;
    LONG cDiff;

    s1 = String1->Buffer;
    s2 = String2->Buffer;
    n1 = (USHORT )(String1->Length / sizeof(WCHAR));
    n2 = (USHORT )(String2->Length / sizeof(WCHAR));
    while (n1 && n2) {
        c1 = *s1++;
        c2 = *s2++;

        if (CaseInSensitive) {
            //
            // Note that this needs to reference the translation table !
            //
            c1 = upcase(c1);
            c2 = upcase(c2);
        }

        if ((cDiff = ((LONG)c1 - (LONG)c2)) != 0) {
            return( cDiff );
            }

        n1--;
        n2--;
        }

    return( n1 - n2 );
}

BOOLEAN
RtlEqualUnicodeString(
    IN const UNICODE_STRING *String1,
    IN const UNICODE_STRING *String2,
    IN BOOLEAN CaseInSensitive
    )

/*++

Routine Description:

    The RtlEqualUnicodeString function compares two counted unicode strings for
    equality.

    The CaseInSensitive parameter specifies if case is to be ignored when
    doing the comparison.

Arguments:

    String1 - Pointer to the first string.

    String2 - Pointer to the second string.

    CaseInsensitive - TRUE if case should be ignored when doing the
        comparison.

Return Value:

    Boolean value that is TRUE if String1 equals String2 and FALSE otherwise.

--*/

{
    UNALIGNED WCHAR *s1, *s2;
    USHORT n1, n2;
    WCHAR c1, c2;

    s1 = String1->Buffer;
    s2 = String2->Buffer;
    n1 = (USHORT )(String1->Length / sizeof(WCHAR));
    n2 = (USHORT )(String2->Length / sizeof(WCHAR));

    if ( n1 != n2 ) {
        return FALSE;
        }

    if (CaseInSensitive) {

        while ( n1 ) {

            if ( *s1++ != *s2++ ) {
                c1 = upcase(*(s1-1));
                c2 = upcase(*(s2-1));
                if (c1 != c2) {
                    return( FALSE );
                    }
                }
            n1--;
            }
        }
    else {

        while ( n1 ) {

            if (*s1++ != *s2++) {
                return( FALSE );
                }

            n1--;
            }
        }

    return TRUE;
}


VOID
RtlInitString(
    OUT PSTRING DestinationString,
    IN PCSZ SourceString OPTIONAL
    )

/*++

Routine Description:

    The RtlInitString function initializes an NT counted string.
    The DestinationString is initialized to point to the SourceString
    and the Length and MaximumLength fields of DestinationString are
    initialized to the length of the SourceString, which is zero if
    SourceString is not specified.

Arguments:

    DestinationString - Pointer to the counted string to initialize

    SourceString - Optional pointer to a null terminated string that
        the counted string is to point to.


Return Value:

    None.

--*/

{
    DestinationString->Length = 0;
    DestinationString->Buffer = (PCHAR)SourceString;
    if (ARGUMENT_PRESENT( SourceString )) {
        while (*SourceString++) {
            DestinationString->Length++;
            }

        DestinationString->MaximumLength = (SHORT)(DestinationString->Length+1);
        }
    else {
        DestinationString->MaximumLength = 0;
        }
}


VOID
RtlInitUnicodeString(
    OUT PUNICODE_STRING DestinationString,
    IN PCWSTR SourceString OPTIONAL
    )

/*++

Routine Description:

    The RtlInitUnicodeString function initializes an NT counted
    unicode string.  The DestinationString is initialized to point to
    the SourceString and the Length and MaximumLength fields of
    DestinationString are initialized to the length of the SourceString,
    which is zero if SourceString is not specified.

Arguments:

    DestinationString - Pointer to the counted string to initialize

    SourceString - Optional pointer to a null terminated unicode string that
        the counted string is to point to.


Return Value:

    None.

--*/

{
    USHORT Length = 0;
    DestinationString->Length = 0;
    DestinationString->Buffer = (PWSTR)SourceString;
    if (ARGUMENT_PRESENT( SourceString )) {
        while (*SourceString++) {
            Length += sizeof(*SourceString);
            }

        DestinationString->Length = Length;

        DestinationString->MaximumLength = Length+(USHORT)sizeof(UNICODE_NULL);
        }
    else {
        DestinationString->MaximumLength = 0;
        }
}


VOID
RtlInitAnsiString(
    OUT PANSI_STRING DestinationString,
    IN PCSTR SourceString OPTIONAL
    )

/*++

Routine Description:

    The RtlInitAnsiString function initializes an NT counted
    ANSI string.  The DestinationString is initialized to point to
    the SourceString and the Length and MaximumLength fields of
    DestinationString are initialized to the length of the SourceString,
    which is zero if SourceString is not specified.

Arguments:

    DestinationString - Pointer to the counted string to initialize

    SourceString - Optional pointer to a null terminated ANSI string that
        the counted string is to point to.


Return Value:

    None.

--*/

{
    USHORT Length = 0;
    DestinationString->Length = 0;
    DestinationString->Buffer = (PSTR)SourceString;
    if (ARGUMENT_PRESENT( SourceString )) {
        while (*SourceString++) {
            Length += sizeof(*SourceString);
            }

        DestinationString->Length = Length;

        DestinationString->MaximumLength = Length+1;
        }
    else {
        DestinationString->MaximumLength = 0;
        }
}



NTSTATUS
RtlAppendUnicodeStringToString (
    IN OUT PUNICODE_STRING Destination,
    IN PCUNICODE_STRING Source
    )

/*++

Routine Description:

    This routine will concatinate two PSTRINGs together.  It will copy
    bytes from the source up to the MaximumLength of the destination.

Arguments:

    IN PSTRING Destination, - Supplies the destination string
    IN PSTRING Source - Supplies the source for the string copy

Return Value:

    STATUS_SUCCESS - The source string was successfully appended to the
        destination counted string.

    STATUS_BUFFER_TOO_SMALL - The destination string length was not big
        enough to allow the source string to be appended.  The Destination
        string length is not updated.

--*/

{
    USHORT n = Source->Length;
    UNALIGNED WCHAR *dst;

    if (n) {
        if ((n + Destination->Length) > Destination->MaximumLength) {
            return( STATUS_BUFFER_TOO_SMALL );
            }

        dst = &Destination->Buffer[ (Destination->Length / sizeof( WCHAR )) ];
        RtlMoveMemory( dst, Source->Buffer, n );

        Destination->Length += n;

        if (Destination->Length < Destination->MaximumLength) {
            dst[ n / sizeof( WCHAR ) ] = UNICODE_NULL;
            }
        }

    return( STATUS_SUCCESS );
}


NTSTATUS
RtlAppendUnicodeToString (
    IN PUNICODE_STRING Destination,
    IN PCWSTR Source OPTIONAL
    )

/*++

Routine Description:

    This routine appends the supplied UNICODE string to an existing
    PUNICODE_STRING.

    It will copy bytes from the Source PSZ to the destination PSTRING up to
    the destinations PUNICODE_STRING->MaximumLength field.

Arguments:

    IN PUNICODE_STRING Destination, - Supplies a pointer to the destination
                            string
    IN PWSTR Source - Supplies the string to append to the destination

Return Value:

    STATUS_SUCCESS - The source string was successfully appended to the
        destination counted string.

    STATUS_BUFFER_TOO_SMALL - The destination string length was not big
        enough to allow the source string to be appended.  The Destination
        string length is not updated.

--*/

{
    USHORT n;
    UNALIGNED WCHAR *dst;

    if (ARGUMENT_PRESENT( Source )) {
        UNICODE_STRING UniSource;

        RtlInitUnicodeString(&UniSource, Source);

        n = UniSource.Length;

        if ((n + Destination->Length) > Destination->MaximumLength) {
            return( STATUS_BUFFER_TOO_SMALL );
            }

        dst = &Destination->Buffer[ (Destination->Length / sizeof( WCHAR )) ];
        RtlMoveMemory( dst, Source, n );

        Destination->Length += n;

        if (Destination->Length < Destination->MaximumLength) {
            dst[ n / sizeof( WCHAR ) ] = UNICODE_NULL;
            }
        }

    return( STATUS_SUCCESS );
}

WCHAR
RtlUpcaseUnicodeChar(
    IN WCHAR SourceCharacter
    )

/*++

Routine Description:

    This function translates the specified unicode character to its
    equivalent upcased unicode chararacter.  The purpose for this routine
    is to allow for character by character upcase translation.  The
    translation is done with respect to the current system locale
    information.


Arguments:

    SourceCharacter - Supplies the unicode character to be upcased.

Return Value:

    Returns the upcased unicode equivalent of the specified input character.

--*/

{

    return (upcase(SourceCharacter));
}

WCHAR
RtlAnsiCharToUnicodeChar(
    IN OUT PUCHAR *SourceCharacter
    )

/*++

Routine Description:

    This function translates the specified ansi character to unicode and
    returns the unicode value.  The purpose for this routine is to allow
    for character by character ansi to unicode translation.  The
    translation is done with respect to the current system locale
    information.


Arguments:

    SourceCharacter - Supplies a pointer to an ansi character pointer.
        Through two levels of indirection, this supplies an ansi
        character that is to be translated to unicode.  After
        translation, the ansi character pointer is modified to point to
        the next character to be converted.  This is done to allow for
        dbcs ansi characters.

Return Value:

    Returns the unicode equivalent of the specified ansi character.

--*/

{
    WCHAR UnicodeCharacter;


    UnicodeCharacter = (WCHAR)**SourceCharacter;
    (*SourceCharacter)++;
    return(UnicodeCharacter);
}

NTSTATUS
RtlUpcaseUnicodeToMultiByteN(
    OUT PCH MultiByteString,
    IN ULONG MaxBytesInMultiByteString,
    OUT PULONG BytesInMultiByteString OPTIONAL,
    IN PWCH UnicodeString,
    IN ULONG BytesInUnicodeString)

/*++

Routine Description:

    This functions upper cases the specified unicode source string and
    converts it into an ansi string. The translation is done with respect
    to the ANSI Code Page (ACP) loaded at boot time.

Arguments:

    MultiByteString - Returns an ansi string that is equivalent to the
        upper case of the unicode source string.  If the translation can
        not be done, an error is returned.

    MaxBytesInMultiByteString - Supplies the maximum number of bytes to be
        written to MultiByteString.  If this causes MultiByteString to be a
        truncated equivalent of UnicodeString, no error condition results.

    BytesInMultiByteString - Returns the number of bytes in the returned
        ansi string pointed to by MultiByteString.

    UnicodeString - Supplies the unicode source string that is to be
        converted to ansi.

    BytesInUnicodeString - The number of bytes in the the string pointed to by
        UnicodeString.

Return Value:

    SUCCESS - The conversion was successful

--*/

{
    ULONG LoopCount;
    ULONG CharsInUnicodeString;
    ULONG i;

    //
    // Convert Unicode byte count to character count. Byte count of
    // multibyte string is equivalent to character count.
    //
    CharsInUnicodeString = BytesInUnicodeString / sizeof(WCHAR);

    LoopCount = (CharsInUnicodeString < MaxBytesInMultiByteString) ?
                 CharsInUnicodeString : MaxBytesInMultiByteString;

    if (ARGUMENT_PRESENT(BytesInMultiByteString))
        *BytesInMultiByteString = LoopCount;


    for (i=0;i<LoopCount;i++) {

        MultiByteString[i] = (UCHAR)RtlUpcaseUnicodeChar((UCHAR)(UnicodeString[i]));
    }

    return STATUS_SUCCESS;
}

NTSTATUS
RtlMultiByteToUnicodeN(
    OUT PWCH UnicodeString,
    IN ULONG MaxBytesInUnicodeString,
    OUT PULONG BytesInUnicodeString OPTIONAL,
    IN PCSTR MultiByteString,
    IN ULONG BytesInMultiByteString)

/*++

Routine Description:

    This functions converts the specified ansi source string into a
    Unicode string. The translation is done with respect to the
    ANSI Code Page (ACP) installed at boot time.  Single byte characters
    in the range 0x00 - 0x7f are simply zero extended as a performance
    enhancement.  In some far eastern code pages 0x5c is defined as the
    Yen sign.  For system translation we always want to consider 0x5c
    to be the backslash character.  We get this for free by zero extending.

    NOTE: This routine only supports precomposed Unicode characters.

Arguments:

    UnicodeString - Returns a unicode string that is equivalent to
        the ansi source string.

    MaxBytesInUnicodeString - Supplies the maximum number of bytes to be
        written to UnicodeString.  If this causes UnicodeString to be a
        truncated equivalent of MultiByteString, no error condition results.

    BytesInUnicodeString - Returns the number of bytes in the returned
        unicode string pointed to by UnicodeString.

    MultiByteString - Supplies the ansi source string that is to be
        converted to unicode.

    BytesInMultiByteString - The number of bytes in the string pointed to
        by MultiByteString.

Return Value:

    SUCCESS - The conversion was successful.


--*/

{
    ULONG LoopCount;
    ULONG MaxCharsInUnicodeString;
    ULONG i;

    MaxCharsInUnicodeString = MaxBytesInUnicodeString / sizeof(WCHAR);

    LoopCount = (MaxCharsInUnicodeString < BytesInMultiByteString) ?
                 MaxCharsInUnicodeString : BytesInMultiByteString;

    if (ARGUMENT_PRESENT(BytesInUnicodeString))
        *BytesInUnicodeString = LoopCount * sizeof(WCHAR);

    for (i=0;i<LoopCount;i++) {
        UnicodeString[i] = (WCHAR)((UCHAR)(MultiByteString[i]));
    }

    return(STATUS_SUCCESS);
}

NTSTATUS
RtlUnicodeToMultiByteN(
    OUT PCH MultiByteString,
    IN ULONG MaxBytesInMultiByteString,
    OUT PULONG BytesInMultiByteString OPTIONAL,
    IN PWCH UnicodeString,
    IN ULONG BytesInUnicodeString)

/*++

Routine Description:

    This functions converts the specified unicode source string into an
    ansi string. The translation is done with respect to the
    ANSI Code Page (ACP) loaded at boot time.

Arguments:

    MultiByteString - Returns an ansi string that is equivalent to the
        unicode source string.  If the translation can not be done,
        an error is returned.

    MaxBytesInMultiByteString - Supplies the maximum number of bytes to be
        written to MultiByteString.  If this causes MultiByteString to be a
        truncated equivalent of UnicodeString, no error condition results.

    BytesInMultiByteString - Returns the number of bytes in the returned
        ansi string pointed to by MultiByteString.

    UnicodeString - Supplies the unicode source string that is to be
        converted to ansi.

    BytesInUnicodeString - The number of bytes in the the string pointed to by
        UnicodeString.

Return Value:

    SUCCESS - The conversion was successful

--*/

{
    ULONG LoopCount;
    ULONG CharsInUnicodeString;
    ULONG i;

    //
    // Convert Unicode byte count to character count. Byte count of
    // multibyte string is equivalent to character count.
    //
    CharsInUnicodeString = BytesInUnicodeString / sizeof(WCHAR);

    LoopCount = (CharsInUnicodeString < MaxBytesInMultiByteString) ?
                 CharsInUnicodeString : MaxBytesInMultiByteString;

    if (ARGUMENT_PRESENT(BytesInMultiByteString))
        *BytesInMultiByteString = LoopCount;


    for (i=0;i<LoopCount;i++) {
        MultiByteString[i] = (CHAR)(UnicodeString[i]);
    }

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\uam\macsource\macssp\ntlmssp.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    stub.c

Abstract:

    NT LM Security Support Provider client stubs.

Author:

    Cliff Van Dyke (CliffV) 29-Jun-1993

Environment:  User Mode

Revision History:

--*/

#ifdef BLDR_KERNEL_RUNTIME
#include <bootdefs.h>
#endif
#ifdef WIN
#include <windows.h>
#include <ctype.h>
#include <security.h>
#include <ntlmsspi.h>
#include <crypt.h>
#include <ntlmssp.h>
#include <cred.h>
#include <debug.h>
#include <string.h>
#include <memory.h>
#include <cache.h>
#include <persist.h>
#include <rpc.h>
#include <md5.h>
#include <context.h>
#endif
#ifdef MAC
#include "ntlmsspi.h"
#include "sspi.h"
#include "crypt.h"
#include "ntlmssp.h"
#include "cred.h"
#include "cache.h"
//#include "debug.h"
#include "string.h"
#include "memory.h"
//#include "cache.h"
//#include "persist.h"
//#include "rpc.h"
#include "md5.h"
#include "context.h"
#include "winerror.h"
#endif

#include <stdio.h>

#include "crc32.h"

#if 0
static SecurityFunctionTable FunctionTable =
{
    SECURITY_SUPPORT_PROVIDER_INTERFACE_VERSION,
    EnumerateSecurityPackages,
    0, // QueryCredentialsAttributes
    AcquireCredentialsHandle,
    FreeCredentialsHandle,
    0,
    InitializeSecurityContext,
    0,
    CompleteAuthToken,
    DeleteSecurityContext,
    ApplyControlToken,
    QueryContextAttributes,
    0,
    0,
    MakeSignature,
    VerifySignature,
    FreeContextBuffer,
    QuerySecurityPackageInfo,
    SealMessage,
    UnsealMessage
};


PSecurityFunctionTable SEC_ENTRY
InitSecurityInterface(
    )

/*++

Routine Description:

    RPC calls this function to get the addresses of all the other functions
    that it might call.

Arguments:

    None.

Return Value:

    A pointer to our static SecurityFunctionTable.  The caller need
    not deallocate this table.

--*/

{
    CacheInitializeCache();

    return &FunctionTable;
}
#endif   // 0

BOOL
__loadds
GetPassword(
    PSSP_CREDENTIAL Credential,
    int NeverPrompt
    )
{
#ifdef BL_USE_LM_PASSWORD
    if ((Credential->LmPassword != NULL) && (Credential->NtPassword != NULL)) {
        return (TRUE);
    }
#else
    if (Credential->NtPassword != NULL) {
        return (TRUE);
    }
#endif

    if (CacheGetPassword(Credential) == TRUE) {
        return (TRUE);
    }

    return (FALSE);
}


#if 0
BOOLEAN
SspTimeHasElapsed(
    IN DWORD StartTime,
    IN DWORD Timeout
    )
/*++

Routine Description:

    Determine if "Timeout" milliseconds have elapsed since StartTime.

Arguments:

    StartTime - Specifies an absolute time when the event started
    (in millisecond units).

    Timeout - Specifies a relative time in milliseconds.  0xFFFFFFFF indicates
        that the time will never expire.

Return Value:

    TRUE -- iff Timeout milliseconds have elapsed since StartTime.

--*/
{
    DWORD TimeNow;
    DWORD ElapsedTime;

    //
    // If the period to too large to handle (i.e., 0xffffffff is forever),
    //  just indicate that the timer has not expired.
    //
    //

    if ( Timeout == 0xffffffff ) {
        return FALSE;
    }

    TimeNow = SspTicks();

    ElapsedTime = TimeNow - StartTime;

    if (ElapsedTime > Timeout) {
        return (TRUE);
    }

    return (FALSE);
}
#endif

#ifndef MAC
SECURITY_STATUS SEC_ENTRY
QuerySecurityPackageInfo(
    IN SEC_CHAR SEC_FAR * PackageName,
    OUT PSecPkgInfo SEC_FAR *PackageInfo
    )

/*++

Routine Description:

    This API is intended to provide basic information about Security
    Packages themselves.  This information will include the bounds on sizes
    of authentication information, credentials and contexts.

    ?? This is a local routine rather than the real API call since the API
    call has a bad interface that neither allows me to allocate the
    buffer nor tells me how big the buffer is.  Perhaps when the real API
    is fixed, I'll make this the real API.

Arguments:

     PackageName - Name of the package being queried.

     PackageInfo - Returns a pointer to an allocated block describing the
        security package.  The allocated block must be freed using
        FreeContextBuffer.

Return Value:

    SEC_E_OK -- Call completed successfully

    SEC_E_PACKAGE_UNKNOWN -- Package being queried is not this package
    SEC_E_INSUFFICIENT_MEMORY -- Not enough memory

--*/
{
    SEC_CHAR *Where;

    //
    // Ensure the correct package name was passed in.
    //

    if ( _fstrcmp( PackageName, NTLMSP_NAME ) != 0 ) {
        return SEC_E_PACKAGE_UNKNOWN;
    }

    //
    // Allocate a buffer for the PackageInfo
    //

    *PackageInfo = (PSecPkgInfo) SspAlloc (sizeof(SecPkgInfo) +
                                           sizeof(NTLMSP_NAME) +
                                           sizeof(NTLMSP_COMMENT) );

    if ( *PackageInfo == NULL ) {
        return SEC_E_INSUFFICIENT_MEMORY;
    }

    //
    // Fill in the information.
    //

    (*PackageInfo)->fCapabilities = NTLMSP_CAPABILITIES;
    (*PackageInfo)->wVersion = NTLMSP_VERSION;
    (*PackageInfo)->wRPCID = RPC_C_AUTHN_WINNT;
    (*PackageInfo)->cbMaxToken = NTLMSP_MAX_TOKEN_SIZE;

    Where = (SEC_CHAR *)((*PackageInfo)+1);

    (*PackageInfo)->Name = Where;
    _fstrcpy( Where, NTLMSP_NAME);
    Where += _fstrlen(Where) + 1;


    (*PackageInfo)->Comment = Where;
    _fstrcpy( Where, NTLMSP_COMMENT);
    Where += _fstrlen(Where) + 1;

    return SEC_E_OK;
}


SECURITY_STATUS SEC_ENTRY
EnumerateSecurityPackages(
    OUT PULONG PackageCount,
    OUT PSecPkgInfo * PackageInfo
    )

/*++

Routine Description:

    This API returns a list of Security Packages available to client (i.e.
    those that are either loaded or can be loaded on demand).  The caller
    must free the returned buffer with FreeContextBuffer.  This API returns
    a list of all the security packages available to a service.  The names
    returned can then be used to acquire credential handles, as well as
    determine which package in the system best satisfies the requirements
    of the caller.  It is assumed that all available packages can be
    included in the single call.

    This is really a dummy API that just returns information about this
    security package.  It is provided to ensure this security package has the
    same interface as the multiplexer DLL does.

Arguments:

     PackageCount - Returns the number of packages supported.

     PackageInfo - Returns an allocate array of structures
        describing the security packages.  The array must be freed
        using FreeContextBuffer.

Return Value:

    SEC_E_OK -- Call completed successfully

    SEC_E_PACKAGE_UNKNOWN -- Package being queried is not this package
    SEC_E_INSUFFICIENT_MEMORY -- Not enough memory

--*/
{
    SECURITY_STATUS SecStatus;

    //
    // Get the information for this package.
    //

    SecStatus = QuerySecurityPackageInfo( NTLMSP_NAME,
                                              PackageInfo );

    if ( SecStatus != SEC_E_OK ) {
        return SecStatus;
    }

    *PackageCount = 1;

    return (SEC_E_OK);
}
#endif


SECURITY_STATUS SEC_ENTRY
AcquireCredentialsHandle(
    IN SEC_CHAR * PrincipalName,
    IN SEC_CHAR * PackageName,
    IN ULONG CredentialUseFlags,
    IN PVOID LogonId,
    IN PVOID AuthData,
    IN SEC_GET_KEY_FN GetKeyFunction,
    IN PVOID GetKeyArgument,
    OUT PCredHandle CredentialHandle,
    OUT PTimeStamp Lifetime
    )

/*++

Routine Description:

    This API allows applications to acquire a handle to pre-existing
    credentials associated with the user on whose behalf the call is made
    i.e. under the identity this application is running.  These pre-existing
    credentials have been established through a system logon not described
    here.  Note that this is different from "login to the network" and does
    not imply gathering of credentials.

    Note for DOS we will ignore the previous note.  On DOS we will gather
    logon credentials through the AuthData parameter.

    This API returns a handle to the credentials of a principal (user, client)
    as used by a specific security package.  This handle can then be used
    in subsequent calls to the Context APIs.  This API will not let a
    process obtain a handle to credentials that are not related to the
    process; i.e. we won't allow a process to grab the credentials of
    another user logged into the same machine.  There is no way for us
    to determine if a process is a trojan horse or not, if it is executed
    by the user.

Arguments:

    PrincipalName - Name of the principal for whose credentials the handle
        will reference.  Note, if the process requesting the handle does
        not have access to the credentials, an error will be returned.
        A null string indicates that the process wants a handle to the
        credentials of the user under whose security it is executing.

     PackageName - Name of the package with which these credentials will
        be used.

     CredentialUseFlags - Flags indicating the way with which these
        credentials will be used.

        #define     CRED_INBOUND        0x00000001
        #define     CRED_OUTBOUND       0x00000002
        #define     CRED_BOTH           0x00000003
        #define     CRED_OWF_PASSWORD   0x00000010

        The credentials created with CRED_INBOUND option can only be used
        for (validating incoming calls and can not be used for making accesses.
        CRED_OWF_PASSWORD means that the password in AuthData has already
        been through the OWF function.

    LogonId - Pointer to NT style Logon Id which is a LUID.  (Provided for
        file system ; processes such as network redirectors.)

    CredentialHandle - Returned credential handle.

    Lifetime - Time that these credentials expire. The value returned in
        this field depends on the security package.

Return Value:

    STATUS_SUCCESS -- Call completed successfully

    SEC_E_NO_SPM -- Security Support Provider is not running
    SEC_E_PACKAGE_UNKNOWN -- Package being queried is not this package
    SEC_E_PRINCIPAL_UNKNOWN -- No such principal
    SEC_E_NOT_OWNER -- caller does not own the specified credentials
    SEC_E_INSUFFICIENT_MEMORY -- Not enough memory

--*/

{
    SECURITY_STATUS SecStatus;
    PSSP_CREDENTIAL Credential = NULL;

#ifdef DEBUGRPC_DETAIL
    SspPrint(( SSP_API, "SspAcquireCredentialHandle Entered\n" ));
#endif

    //
    // Validate the arguments
    //

    if ( _fstrcmp( PackageName, NTLMSP_NAME ) != 0 ) {
        return (SEC_E_PACKAGE_UNKNOWN);
    }

    if ( (CredentialUseFlags & SECPKG_CRED_OUTBOUND) &&
         ARGUMENT_PRESENT(PrincipalName) && *PrincipalName != L'\0' ) {
        return (SEC_E_PRINCIPAL_UNKNOWN);
    }

    if ( ARGUMENT_PRESENT(LogonId) ) {
        return (SEC_E_PRINCIPAL_UNKNOWN);
    }

    if ( ARGUMENT_PRESENT(GetKeyFunction) ) {
        return (SEC_E_PRINCIPAL_UNKNOWN);
    }

    if ( ARGUMENT_PRESENT(GetKeyArgument) ) {
        return (SEC_E_PRINCIPAL_UNKNOWN);
    }

    //
    // Ensure at least one Credential use bit is set.
    //

    if ( (CredentialUseFlags & (SECPKG_CRED_INBOUND|SECPKG_CRED_OUTBOUND)) == 0 ) {
        SspPrint(( SSP_API,
            "SspAcquireCredentialHandle: invalid credential use.\n" ));
        SecStatus = SEC_E_INVALID_CREDENTIAL_USE;
        goto Cleanup;
    }

    //
    // Allocate a credential block and initialize it.
    //

    Credential = SspCredentialAllocateCredential(CredentialUseFlags);

    if ( Credential == NULL ) {
        SecStatus = SEC_E_INSUFFICIENT_MEMORY;
        goto Cleanup;
    }

    SecStatus = CacheSetCredentials( AuthData, Credential );
    if (SecStatus != SEC_E_OK)
        goto Cleanup;

    //
    // Return output parameters to the caller.
    //

    CredentialHandle->dwUpper = (ULONG_PTR)Credential;

    CredentialHandle->dwLower = 0;
    
    #ifndef MAC
    Lifetime->HighPart = 0;
    Lifetime->LowPart = 0xffffffffL;
    #else
    *Lifetime = 0xffffffffL;
    #endif

    SecStatus = SEC_E_OK;

    //
    // Free and locally used resources.
    //
Cleanup:

    if ( SecStatus != SEC_E_OK ) {

        if ( Credential != NULL ) {
            SspFree( Credential );
        }

    }

#ifdef DEBUGRPC_DETAIL
    SspPrint(( SSP_API, "SspAcquireCredentialHandle returns 0x%x\n", SecStatus ));
#endif
    return SecStatus;
}



SECURITY_STATUS SEC_ENTRY
FreeCredentialsHandle(
    IN PCredHandle CredentialHandle
    )

/*++

Routine Description:

    This API is used to notify the security system that the credentials are
    no longer needed and allows the application to free the handle acquired
    in the call described above. When all references to this credential
    set has been removed then the credentials may themselves be removed.

Arguments:

    CredentialHandle - Credential Handle obtained through
        AcquireCredentialHandle.

Return Value:


    STATUS_SUCCESS -- Call completed successfully

    SEC_E_NO_SPM -- Security Support Provider is not running
    SEC_E_INVALID_HANDLE -- Credential Handle is invalid


--*/

{
    SECURITY_STATUS SecStatus;
    PSSP_CREDENTIAL Credential;

    //
    // Initialization
    //

#ifdef DEBUGRPC_DETAIL
    SspPrint(( SSP_API, "SspFreeCredentialHandle Entered\n" ));
#endif

    //
    // Find the referenced credential and delink it.
    //

    Credential = SspCredentialReferenceCredential(CredentialHandle, TRUE);

    if ( Credential == NULL ) {
        SecStatus = SEC_E_INVALID_HANDLE;
        goto Cleanup;
    }

    SspCredentialDereferenceCredential( Credential );
    SspCredentialDereferenceCredential( Credential );

    SecStatus = SEC_E_OK;

Cleanup:

#ifdef DEBUGRPC_DETAIL
    SspPrint(( SSP_API, "SspFreeCredentialHandle returns 0x%x\n", SecStatus ));
#endif
    return SecStatus;
}


BOOLEAN
SspGetTokenBuffer(
    IN PSecBufferDesc TokenDescriptor OPTIONAL,
    OUT PVOID * TokenBuffer,
    OUT PULONG * TokenSize,
    IN BOOLEAN ReadonlyOK
    )

/*++

Routine Description:

    This routine parses a Token Descriptor and pulls out the useful
    information.

Arguments:

    TokenDescriptor - Descriptor of the buffer containing (or to contain) the
        token. If not specified, TokenBuffer and TokenSize will be returned
        as NULL.

    TokenBuffer - Returns a pointer to the buffer for the token.

    TokenSize - Returns a pointer to the location of the size of the buffer.

    ReadonlyOK - TRUE if the token buffer may be readonly.

Return Value:

    TRUE - If token buffer was properly found.

--*/

{
    ULONG i;

    //
    // If there is no TokenDescriptor passed in,
    //  just pass out NULL to our caller.
    //

    if ( !ARGUMENT_PRESENT( TokenDescriptor) ) {
        *TokenBuffer = NULL;
        *TokenSize = NULL;
        return TRUE;
    }

    //
    // Check the version of the descriptor.
    //

    if ( TokenDescriptor->ulVersion != 0 ) {
        return FALSE;
    }

    //
    // Loop through each described buffer.
    //

    for ( i=0; i<TokenDescriptor->cBuffers ; i++ ) {
        PSecBuffer Buffer = &TokenDescriptor->pBuffers[i];
        if ( (Buffer->BufferType & (~SECBUFFER_READONLY)) == SECBUFFER_TOKEN ) {

            //
            // If the buffer is readonly and readonly isn't OK,
            //  reject the buffer.
            //

            if ( !ReadonlyOK && (Buffer->BufferType & SECBUFFER_READONLY) ) {
                return FALSE;
            }

            //
            // Return the requested information
            //

            *TokenBuffer = Buffer->pvBuffer;
            *TokenSize = &Buffer->cbBuffer;
            return TRUE;
        }

    }

    return FALSE;
}


SECURITY_STATUS
SspHandleFirstCall(
    IN PCredHandle CredentialHandle,
    IN OUT PCtxtHandle ContextHandle,
    IN ULONG ContextReqFlags,
    IN ULONG QoPFlags,
    IN ULONG InputTokenSize,
    IN PVOID InputToken,
    IN OUT PULONG OutputTokenSize,
    OUT PVOID OutputToken,
    OUT PULONG ContextAttributes,
    OUT PTimeStamp ExpirationTime
    )

/*++

Routine Description:

    Handle the First Call part of InitializeSecurityContext.

Arguments:

    QoPFlags - Indicates security configuration

    All other arguments same as for InitializeSecurityContext

Return Value:

    STATUS_SUCCESS -- All OK
    SEC_I_CALLBACK_NEEDED -- Caller should call again later

    SEC_E_INVALID_HANDLE -- Credential/Context Handle is invalid
    SEC_E_BUFFER_TOO_SMALL -- Buffer for output token isn't big enough
    SEC_E_INSUFFICIENT_MEMORY -- Not enough memory

--*/

{
    SECURITY_STATUS SecStatus;
    PSSP_CONTEXT Context = NULL;
    PSSP_CREDENTIAL Credential = NULL;

    NEGOTIATE_MESSAGE NegotiateMessage;

    //
    // Initialization
    //

    *ContextAttributes = 0;

    //
    // Get a pointer to the credential
    //

    Credential = SspCredentialReferenceCredential(
                    CredentialHandle,
                    FALSE );

    if ( Credential == NULL ) {
        SspPrint(( SSP_API,
            "SspHandleFirstCall: invalid credential handle.\n" ));
        SecStatus = SEC_E_INVALID_HANDLE;
        goto Cleanup;
    }

    if ( (Credential->CredentialUseFlags & SECPKG_CRED_OUTBOUND) == 0 ) {
        SspPrint(( SSP_API, "SspHandleFirstCall: invalid credential use.\n" ));
        SecStatus = SEC_E_INVALID_CREDENTIAL_USE;
        goto Cleanup;
    }


    //
    // Allocate a new context
    //

    Context = SspContextAllocateContext();

    if ( Context == NULL ) {
        SecStatus = SEC_E_INSUFFICIENT_MEMORY;
        goto Cleanup;
    }

    //
    // Build a handle to the newly created context.
    //

    ContextHandle->dwUpper = (ULONG_PTR) Context;
    ContextHandle->dwLower = 0;

    //
    // We don't support any options.
    //
    // Complain about those that require we do something.
    //

    if ( (ContextReqFlags & (ISC_REQ_ALLOCATE_MEMORY |
                            ISC_REQ_PROMPT_FOR_CREDS |
                            ISC_REQ_USE_SUPPLIED_CREDS )) != 0 ) {

        SspPrint(( SSP_API,
                   "SspHandleFirstCall: invalid ContextReqFlags 0x%lx.\n",
                   ContextReqFlags ));
        SecStatus = SEC_E_INVALID_CONTEXT_REQ;
        goto Cleanup;
    }

    //
    // If this is the first call,
    //  build a Negotiate message.
    //
    // Offer to talk Oem character set.
    //

    _fstrcpy((CHAR*)NegotiateMessage.Signature, NTLMSSP_SIGNATURE );
    NegotiateMessage.MessageType = (NTLM_MESSAGE_TYPE)NtLmNegotiate;

    if (QoPFlags & QOP_NTLMV2)
    {
        Context->NegotiateFlags =
                              NTLMSSP_NEGOTIATE_UNICODE |
                              NTLMSSP_NEGOTIATE_OEM |
                              NTLMSSP_NEGOTIATE_NTLM |
                              NTLMSSP_NEGOTIATE_NTLM2 |
                              NTLMSSP_REQUEST_TARGET |
                              NTLMSSP_NEGOTIATE_ALWAYS_SIGN |
                              NTLMSSP_NEGOTIATE_128;

        NegotiateMessage.NegotiateFlags = NTLMSSP_NEGOTIATE_UNICODE |
                                          NTLMSSP_NEGOTIATE_OEM |
                                          NTLMSSP_REQUEST_TARGET |
                                          NTLMSSP_NEGOTIATE_NTLM |
                                          NTLMSSP_NEGOTIATE_ALWAYS_SIGN |
                                          NTLMSSP_NEGOTIATE_NTLM2 |
                                          NTLMSSP_NEGOTIATE_56 |
                                          NTLMSSP_NEGOTIATE_128;
    }
    else
    {
        NegotiateMessage.NegotiateFlags = NTLMSSP_NEGOTIATE_OEM |
                                          NTLMSSP_NEGOTIATE_NTLM |
                                          NTLMSSP_NEGOTIATE_ALWAYS_SIGN;

        if (Credential->Domain == NULL)
        {
            NegotiateMessage.NegotiateFlags |= NTLMSSP_REQUEST_TARGET;
        }
    }

    if ( *OutputTokenSize < sizeof(NEGOTIATE_MESSAGE) ) {
        SecStatus = SEC_E_BUFFER_TOO_SMALL;
        goto Cleanup;
    }

    if (ContextReqFlags & (ISC_REQ_SEQUENCE_DETECT | ISC_REQ_REPLAY_DETECT)) {
        Context->NegotiateFlags |= NTLMSSP_NEGOTIATE_SIGN;
        NegotiateMessage.NegotiateFlags |= NTLMSSP_NEGOTIATE_SIGN |
                                           NTLMSSP_NEGOTIATE_NT_ONLY;
    }

    if (ContextReqFlags & ISC_REQ_CONFIDENTIALITY) {
        Context->NegotiateFlags |= NTLMSSP_NEGOTIATE_SEAL;
        NegotiateMessage.NegotiateFlags |= NTLMSSP_NEGOTIATE_SEAL |
                                           NTLMSSP_NEGOTIATE_NT_ONLY;
    }

    swaplong(NegotiateMessage.NegotiateFlags);
    swaplong(*((ULONG*)&NegotiateMessage.MessageType));

    _fmemcpy(OutputToken, &NegotiateMessage, sizeof(NEGOTIATE_MESSAGE));

    *OutputTokenSize = sizeof(NEGOTIATE_MESSAGE);

    //
    // Return output parameters to the caller.
    //

    *ExpirationTime = SspContextGetTimeStamp( Context, TRUE );

    Context->Credential = SspCredentialReferenceCredential(
                               CredentialHandle,
                               FALSE);

    SecStatus = SEC_I_CALLBACK_NEEDED;
    Context->State = NegotiateSentState;

    //
    // Free locally used resources.
    //
Cleanup:

    if ( Context != NULL ) {

        if (SecStatus != SEC_I_CALLBACK_NEEDED) {
            SspContextDereferenceContext( Context );
        }
    }

    if ( Credential != NULL ) {
        SspCredentialDereferenceCredential( Credential );
    }

    return SecStatus;

    UNREFERENCED_PARAMETER( InputToken );
    UNREFERENCED_PARAMETER( InputTokenSize );
}


SECURITY_STATUS
SspHandleChallengeMessage(
    IN PLUID LogonId,
    IN PCredHandle CredentialHandle,
    IN OUT PCtxtHandle ContextHandle,
    IN ULONG ContextReqFlags,
    IN ULONG InputTokenSize,
    IN PVOID InputToken,
    IN OUT PULONG OutputTokenSize,
    OUT PVOID OutputToken,
    OUT PULONG ContextAttributes,
    OUT PTimeStamp ExpirationTime
    )

/*++

Routine Description:

    Handle the Challenge message part of InitializeSecurityContext.

Arguments:

    LogonId -- LogonId of the calling process.

    All other arguments same as for InitializeSecurityContext

Return Value:

    STATUS_SUCCESS - Message handled
    SEC_I_CALLBACK_NEEDED -- Caller should call again later

    SEC_E_INVALID_TOKEN -- Token improperly formatted
    SEC_E_INVALID_HANDLE -- Credential/Context Handle is invalid
    SEC_E_BUFFER_TOO_SMALL -- Buffer for output token isn't big enough
    SEC_E_NO_CREDENTIALS -- There are no credentials for this client
    SEC_E_INSUFFICIENT_MEMORY -- Not enough memory

--*/

{
    SECURITY_STATUS SecStatus;
    PSSP_CONTEXT Context = NULL;
    PSSP_CREDENTIAL Credential = NULL;
    PCHALLENGE_MESSAGE ChallengeMessage = NULL;
    PAUTHENTICATE_MESSAGE AuthenticateMessage = NULL;
    ULONG AuthenticateMessageSize;
    PCHAR Where;
#ifdef BL_USE_LM_PASSWORD
    LM_RESPONSE LmResponse;
#endif
    NT_RESPONSE NtResponse;
    STRING32* pString;

    //
    // Initialization
    //

    *ContextAttributes = 0;

    //
    // Find the currently existing context.
    //

    Context = SspContextReferenceContext( ContextHandle, FALSE );

    if ( Context == NULL ) {
        SecStatus = SEC_E_INVALID_HANDLE;
        goto Cleanup;
    }


    //
    // If we have already sent the authenticate message, then this must be
    // RPC calling Initialize a third time to re-authenticate a connection.
    // This happens when a new interface is called over an existing
    // connection.  What we do here is build a NULL authenticate message
    // that the server will recognize and also ignore.
    //

    if ( Context->State == AuthenticateSentState ) {
        AUTHENTICATE_MESSAGE NullMessage;

        //
        // To make sure this is the intended meaning of the call, check
        // that the input token is NULL.
        //

        if ( (InputTokenSize != 0) || (InputToken != NULL) ) {

            SecStatus = SEC_E_INVALID_TOKEN;
            goto Cleanup;
        }

        if ( *OutputTokenSize < sizeof(NullMessage) ) {

            SecStatus = SEC_E_BUFFER_TOO_SMALL;

        } else {

            _fstrcpy((CHAR*)NullMessage.Signature, NTLMSSP_SIGNATURE );
            NullMessage.MessageType = NtLmAuthenticate;
            swaplong(NullMessage.MessageType) ;

            _fmemset(&NullMessage.LmChallengeResponse, 0, 5*sizeof(STRING));
            *OutputTokenSize = sizeof(NullMessage);
            _fmemcpy(OutputToken, &NullMessage, sizeof(NullMessage));
            SecStatus = SEC_E_OK;
        }

        goto Cleanup;

    }


    if ( Context->State != NegotiateSentState ) {
        SspPrint(( SSP_API,
                  "SspHandleChallengeMessage: "
                  "Context not in NegotiateSentState\n" ));
        SecStatus = SEC_E_OUT_OF_SEQUENCE;
        goto Cleanup;
    }

    //
    // We don't support any options.
    //
    // Complain about those that require we do something.
    //

    if ( (ContextReqFlags & (ISC_REQ_ALLOCATE_MEMORY |
                            ISC_REQ_PROMPT_FOR_CREDS |
                            ISC_REQ_USE_SUPPLIED_CREDS )) != 0 ) {

        SspPrint(( SSP_API,
                   "SspHandleFirstCall: invalid ContextReqFlags 0x%lx.\n",
                   ContextReqFlags ));
        SecStatus = SEC_E_INVALID_CONTEXT_REQ;
        goto Cleanup;
    }

    if (ContextReqFlags & (ISC_REQ_SEQUENCE_DETECT | ISC_REQ_REPLAY_DETECT)) {
        Context->NegotiateFlags |= NTLMSSP_NEGOTIATE_SIGN;

    }

    if (ContextReqFlags & ISC_REQ_CONFIDENTIALITY) {
        Context->NegotiateFlags |= NTLMSSP_NEGOTIATE_SEAL;
    }
    //
    // Ignore the Credential Handle.
    //
    // Since this is the second call,
    //  the credential is implied by the Context.
    //  We could double check that the Credential Handle is either NULL or
    //  correct.  However, our implementation doesn't maintain a close
    //  association between the two (actually no association) so checking
    //  would require a lot of overhead.
    //

    UNREFERENCED_PARAMETER( CredentialHandle );

    ASSERT(Context->Credential != NULL);

    Credential = Context->Credential;

    //
    // Get the ChallengeMessage.
    //

    if ( InputTokenSize < sizeof(CHALLENGE_MESSAGE) ) {
        SspPrint(( SSP_API,
                  "SspHandleChallengeMessage: "
                  "ChallengeMessage size wrong %ld\n",
                  InputTokenSize ));
        SecStatus = SEC_E_INVALID_TOKEN;
        goto Cleanup;
    }

    if ( InputTokenSize > NTLMSSP_MAX_MESSAGE_SIZE ) {
        SspPrint(( SSP_API,
                  "SspHandleChallengeMessage: "
                  "InputTokenSize > NTLMSSP_MAX_MESSAGE_SIZE\n" ));
        SecStatus = SEC_E_INVALID_TOKEN;
        goto Cleanup;
    }

    ChallengeMessage = (PCHALLENGE_MESSAGE) InputToken;
    swaplong(ChallengeMessage->MessageType) ;
    swaplong(ChallengeMessage->NegotiateFlags) ;

    if ( _fstrncmp((CHAR*)ChallengeMessage->Signature,
                  NTLMSSP_SIGNATURE,
                  sizeof(NTLMSSP_SIGNATURE)) != 0 ||
        ChallengeMessage->MessageType != NtLmChallenge ) {
        SspPrint(( SSP_API,
                  "SspHandleChallengeMessage: "
                  "InputToken has invalid NTLMSSP signature\n" ));
        SecStatus = SEC_E_INVALID_TOKEN;
        goto Cleanup;
    }

    //
    // Only negotiate OEM
    //

    if ( !(ChallengeMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_NTLM2) && ChallengeMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_UNICODE ) {
        SspPrint(( SSP_API,
                  "SspHandleChallengeMessage: "
                  "ChallengeMessage bad NegotiateFlags (UNICODE) 0x%lx\n",
                  ChallengeMessage->NegotiateFlags ));
        SecStatus = SEC_E_INVALID_TOKEN;
        goto Cleanup;
    }

    //
    // Check whether the server negotiated ALWAYS_SIGN
    //

    if ( ChallengeMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_ALWAYS_SIGN ) {
        Context->NegotiateFlags |= NTLMSSP_NEGOTIATE_ALWAYS_SIGN;
    }

    //
    // Only negotiate NTLM
    //

    if ( ( ChallengeMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_NETWARE ) &&
        !( ChallengeMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_NTLM ) ) {
        SspPrint(( SSP_API,
                  "SspHandleChallengeMessage: "
                  "ChallengeMessage bad NegotiateFlags (NETWARE) 0x%lx\n",
                  ChallengeMessage->NegotiateFlags ));
        SecStatus = SEC_E_INVALID_TOKEN;
        goto Cleanup;
    }

#if 0
    //
    // Make sure that if we are signing or sealing we only have to use the
    // LM key
    //

    if ((Context->NegotiateFlags & (NTLMSSP_NEGOTIATE_SIGN | NTLMSSP_NEGOTIATE_SEAL)) &&
        !(ChallengeMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_LM_KEY))
    {
        SspPrint(( SSP_API,
                  "SspHandleChallengeMessage: "
                  "ChallengeMessage bad NegotiateFlags (Sign or Seal but no LM key) 0x%lx\n",
                  ChallengeMessage->NegotiateFlags ));
        SecStatus = SEC_E_INVALID_TOKEN;
        goto Cleanup;
    }
#endif

    if (!Credential || !Credential->Username || !Credential->Domain)
    {
        SspPrint((SSP_CRITICAL, "SspHandleChallengeMessage no credential\n"));
        SecStatus = SEC_E_NO_CREDENTIALS;
        goto Cleanup;
    }

    SspPrint((SSP_CRED, "User name: (%s)\n", Credential->Username));
    SspPrint((SSP_CRED, "Domain name: (%s)\n", Credential->Domain));
    SspPrint((SSP_CRED, "Workstation: (%s)\n", Credential->Workstation));

    if (ChallengeMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_NTLM2)
    {
        if (!Credential || !Credential->NtPassword)
        {
            SspPrint((SSP_CRITICAL, "No NtPassword\n"));
            SecStatus = SEC_E_NO_CREDENTIALS;
            goto Cleanup;
        }

        SecStatus = SsprHandleNtlmv2ChallengeMessage(
                        Credential,
                        InputTokenSize,
                        InputToken,
                        &Context->NegotiateFlags,
                        OutputTokenSize,
                        OutputToken,
                        &Context->UserSessionKey
                        );

        if (SEC_E_BUFFER_TOO_SMALL == SEC_E_OK)
        {
            SecStatus = SEC_E_INSUFFICIENT_MEMORY;
        }

        if (SecStatus != SEC_E_OK)
        {
            goto Cleanup;
        }

        SspMakeNtlmv2SKeys(
            &Context->UserSessionKey,
            Context->NegotiateFlags,
            0,  // SendNonce
            0,  // RecvNonce
            &Context->Ntlmv2SKeys
            );

        goto ReturnSuccess;
    }

    if (Credential->Domain == NULL) {

        ASSERT(ChallengeMessage->TargetName.Length != 0);

        Credential->Domain = SspAlloc(ChallengeMessage->TargetName.Length + 1);
        if (Credential->Domain == NULL) {
            SecStatus = SEC_E_INSUFFICIENT_MEMORY;
            goto Cleanup;
        }
        pString = &ChallengeMessage->TargetName;

#if defined(_WIN64)
        _fmemcpy(Credential->Domain, (PCHAR)ChallengeMessage + (ULONG)((__int64)pString->Buffer), pString->Length);
#else
        _fmemcpy(Credential->Domain, (PCHAR)ChallengeMessage + (ULONG)pString->Buffer, pString->Length);
#endif

        Credential->Domain[pString->Length] = '\0';
    }

    if (GetPassword(Credential, 0) == FALSE) {
        SecStatus = SEC_E_NO_CREDENTIALS;
        goto Cleanup;
    }

#ifdef BL_USE_LM_PASSWORD
    if (CalculateLmResponse((PLM_CHALLENGE)ChallengeMessage->Challenge, Credential->LmPassword, &LmResponse) == FALSE) {
        SecStatus = SEC_E_INSUFFICIENT_MEMORY;
        goto Cleanup;
    }
#endif

    if (CalculateNtResponse((PNT_CHALLENGE)ChallengeMessage->Challenge, Credential->NtPassword, &NtResponse) == FALSE) {
        SecStatus = SEC_E_INSUFFICIENT_MEMORY;
        goto Cleanup;
    }

    //
    // Allocate an authenticate message. Change this #if 0 and the next one
    // to send an LM challenge response also.
    //

#ifdef BL_USE_LM_PASSWORD
    AuthenticateMessageSize = sizeof(*AuthenticateMessage)+LM_RESPONSE_LENGTH+NT_RESPONSE_LENGTH;
#else
    AuthenticateMessageSize = sizeof(*AuthenticateMessage)+NT_RESPONSE_LENGTH;
#endif

    if (Credential->Domain != NULL) {
        AuthenticateMessageSize += _fstrlen(Credential->Domain);
    }
    if (Credential->Username != NULL) {
        AuthenticateMessageSize += _fstrlen(Credential->Username);
    }
    if (Credential->Workstation != NULL) {
        AuthenticateMessageSize += _fstrlen(Credential->Workstation);
    }

    if ( AuthenticateMessageSize > *OutputTokenSize ) {
        SecStatus = SEC_E_BUFFER_TOO_SMALL;
        goto Cleanup;
    }

    AuthenticateMessage = (PAUTHENTICATE_MESSAGE) SspAlloc ((int)AuthenticateMessageSize );

    if ( AuthenticateMessage == NULL ) {
        SecStatus = SEC_E_INSUFFICIENT_MEMORY;
        goto Cleanup;
    }

    //
    // Build the authenticate message
    //

    _fstrcpy((CHAR*)AuthenticateMessage->Signature, NTLMSSP_SIGNATURE );
    AuthenticateMessage->MessageType = NtLmAuthenticate;
    swaplong(AuthenticateMessage->MessageType) ;

    Where = (PCHAR)(AuthenticateMessage+1);

#ifdef BL_USE_LM_PASSWORD
    SspCopyStringFromRaw( AuthenticateMessage,
                         &AuthenticateMessage->LmChallengeResponse,
                         (PCHAR)&LmResponse,
                         LM_RESPONSE_LENGTH,
                         &Where);
#else
    SspCopyStringFromRaw( AuthenticateMessage,
                         &AuthenticateMessage->LmChallengeResponse,
                         NULL,
                         0,
                         &Where);
#endif

    SspCopyStringFromRaw( AuthenticateMessage,
                         &AuthenticateMessage->NtChallengeResponse,
                         (PCHAR)&NtResponse,
                         NT_RESPONSE_LENGTH,
                         &Where);

    if (Credential->Domain != NULL) {
        SspCopyStringFromRaw( AuthenticateMessage,
                             &AuthenticateMessage->DomainName,
                             Credential->Domain,
                             _fstrlen(Credential->Domain),
                             &Where);
    } else {
        SspCopyStringFromRaw( AuthenticateMessage,
                             &AuthenticateMessage->DomainName,
                             NULL, 0, &Where);
    }

    if (Credential->Username != NULL) {
        SspCopyStringFromRaw( AuthenticateMessage,
                             &AuthenticateMessage->UserName,
                             Credential->Username,
                             _fstrlen(Credential->Username),
                             &Where);
    } else {
        SspCopyStringFromRaw( AuthenticateMessage,
                             &AuthenticateMessage->UserName,
                             NULL, 0, &Where);
    }

    if (Credential->Workstation != NULL) {
        SspCopyStringFromRaw( AuthenticateMessage,
                             &AuthenticateMessage->Workstation,
                             Credential->Workstation,
                             _fstrlen(Credential->Workstation),
                             &Where);
    } else {
        SspCopyStringFromRaw( AuthenticateMessage,
                             &AuthenticateMessage->Workstation,
                             NULL, 0, &Where);
    }

    _fmemcpy(OutputToken, AuthenticateMessage, (int)AuthenticateMessageSize);

    *OutputTokenSize = AuthenticateMessageSize;

    //
    // The session key is the password, so convert it to a rc4 key.
    //

    if (Context->NegotiateFlags & (NTLMSSP_NEGOTIATE_SIGN |
                                   NTLMSSP_NEGOTIATE_SEAL)) {

#ifdef BL_USE_LM_PASSWORD
        if (ChallengeMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_LM_KEY) {

            LM_RESPONSE SessionKey;
            LM_OWF_PASSWORD LmKey;
            UCHAR Key[LM_SESSION_KEY_LENGTH];

            //
            // The session key is the first 8 bytes of the challenge response,
            // re-encrypted with the password with the second 8 bytes set to 0xbd
            //

            _fmemcpy(&LmKey,Credential->LmPassword,LM_SESSION_KEY_LENGTH);

            _fmemset(   (PUCHAR)(&LmKey) + LM_SESSION_KEY_LENGTH,
                        0xbd,
                        LM_OWF_PASSWORD_LENGTH - LM_SESSION_KEY_LENGTH);

            if (CalculateLmResponse(    (PLM_CHALLENGE) &LmResponse,
                                        &LmKey,
                                        &SessionKey) == FALSE) {
                SecStatus = SEC_E_INSUFFICIENT_MEMORY;
                goto Cleanup;
            }

            _fmemcpy(Key,&SessionKey,5);

            ASSERT(LM_SESSION_KEY_LENGTH == 8);

            //
            // Put a well-known salt at the end of the key to limit
            // the changing part to 40 bits.
            //

            Key[5] = 0xe5;
            Key[6] = 0x38;
            Key[7] = 0xb0;

            Context->Rc4Key = SspAlloc(sizeof(struct RC4_KEYSTRUCT));
            if (Context->Rc4Key == NULL)
            {
                SecStatus = SEC_E_INSUFFICIENT_MEMORY;
                goto Cleanup;
            }
            rc4_key(Context->Rc4Key, LM_SESSION_KEY_LENGTH, Key);
            Context->Nonce = 0;

        } else
#endif
        if (ChallengeMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_NT_ONLY) {

            MD5_CTX Md5Context;
            USER_SESSION_KEY UserSessionKey;

            if (AuthenticateMessage->NtChallengeResponse.Length != NT_RESPONSE_LENGTH) {
                SecStatus = SEC_E_UNSUPPORTED_FUNCTION;
                goto Cleanup;
            }

            CalculateUserSessionKeyNt(
                &NtResponse,
                Credential->NtPassword,
                &UserSessionKey);

            //
            // The NT session key is made by MD5'ing the challenge response,
            // user name, domain name, and nt user session key together.
            //
            _fmemset(&Md5Context, 0, sizeof(MD5_CTX));

            MD5Init(
                &Md5Context
                );
            MD5Update(
                &Md5Context,
                (PUCHAR)&NtResponse,
                NT_RESPONSE_LENGTH
                );
            MD5Update(
                &Md5Context,
                (PUCHAR)Credential->Username,
                _fstrlen(Credential->Username)
                );
            MD5Update(
                &Md5Context,
                (PUCHAR)Credential->Domain,
                _fstrlen(Credential->Domain)
                );
            MD5Update(
                &Md5Context,
                (PUCHAR)&UserSessionKey,
                NT_SESSION_KEY_LENGTH
                );
            MD5Final(
                &Md5Context
                );
            ASSERT(MD5DIGESTLEN == NT_SESSION_KEY_LENGTH);

            Context->Rc4Key = SspAlloc(sizeof(struct RC4_KEYSTRUCT));
            if (Context->Rc4Key == NULL)
            {
                SecStatus = SEC_E_INSUFFICIENT_MEMORY;
                goto Cleanup;
            }
            rc4_key(Context->Rc4Key, NT_SESSION_KEY_LENGTH, Md5Context.digest);
            Context->Nonce = 0;

        } else {
            USER_SESSION_KEY UserSessionKey;

            if (AuthenticateMessage->NtChallengeResponse.Length != NT_RESPONSE_LENGTH) {
                SecStatus = SEC_E_UNSUPPORTED_FUNCTION;
                goto Cleanup;
            }

            CalculateUserSessionKeyNt(
                &NtResponse,
                Credential->NtPassword,
                &UserSessionKey);
            Context->Rc4Key = SspAlloc(sizeof(struct RC4_KEYSTRUCT));
            if (Context->Rc4Key == NULL)
            {
                SecStatus = SEC_E_INSUFFICIENT_MEMORY;
                goto Cleanup;
            }
            rc4_key(Context->Rc4Key, NT_SESSION_KEY_LENGTH, (PUCHAR) &UserSessionKey);
            Context->Nonce = 0;

        }

    }

ReturnSuccess:

    //
    // Return output parameters to the caller.
    //

    *ExpirationTime = SspContextGetTimeStamp( Context, TRUE );

    SecStatus = SEC_E_OK;

    //
    // Free and locally used resources.
    //
Cleanup:

    if ( Context != NULL ) {
        //
        // Don't allow this context to be used again.
        //
        if ( SecStatus == SEC_E_OK ) {
            Context->State = AuthenticateSentState;
        } else {
            Context->State = IdleState;
        }
        SspContextDereferenceContext( Context );
    }

    if ( AuthenticateMessage != NULL ) {
        SspFree( AuthenticateMessage );
    }

    return SecStatus;
}


SECURITY_STATUS SEC_ENTRY
InitializeSecurityContext(
    IN PCredHandle CredentialHandle,
    IN PCtxtHandle OldContextHandle,
    IN SEC_CHAR * TargetName,
    IN ULONG ContextReqFlags,
    IN ULONG Reserved1,
    IN ULONG TargetDataRep,
    IN PSecBufferDesc InputToken,
    IN ULONG Reserved2,
    OUT PCtxtHandle NewContextHandle,
    OUT PSecBufferDesc OutputToken,
    OUT PULONG ContextAttributes,
    OUT PTimeStamp ExpirationTime
    )

/*++

Routine Description:

    This routine initiates the outbound security context from a credential
    handle.  This results in the establishment of a security context
    between the application and a remote peer.  The routine returns a token
    which must be passed to the remote peer which in turn submits it to the
    local security implementation via the AcceptSecurityContext() call.
    The token generated should be considered opaque by all callers.

    This function is used by a client to initialize an outbound context.
    For a two leg security package, the calling sequence is as follows: The
    client calls the function with OldContextHandle set to NULL and
    InputToken set either to NULL or to a pointer to a security package
    specific data structure.  The package returns a context handle in
    NewContextHandle and a token in OutputToken.  The handle can then be
    used for message APIs if desired.

    The OutputToken returned here is sent across to target server which
    calls AcceptSecuirtyContext() with this token as an input argument and
    may receive a token which is returned to the initiator so it can call
    InitializeSecurityContext() again.

    For a three leg (mutual authentication) security package, the calling
    sequence is as follows: The client calls the function as above, but the
    package will return SEC_I_CALLBACK_NEEDED.  The client then sends the
    output token to the server and waits for the server's reply.  Upon
    receipt of the server's response, the client calls this function again,
    with OldContextHandle set to the handle that was returned from the
    first call.  The token received from the server is supplied in the
    InputToken parameter.  If the server has successfully responded, then
    the package will respond with success, or it will invalidate the
    context.

    Initialization of security context may require more than one call to
    this function depending upon the underlying authentication mechanism as
    well as the "choices" indicated via ContextReqFlags.  The
    ContextReqFlags and ContextAttributes are bit masks representing
    various context level functions viz.  delegation, mutual
    authentication, confidentiality, replay detection and sequence
    detection.

    When ISC_REQ_PROMPT_FOR_CREDS flag is set the security package always
    prompts the user for credentials, irrespective of whether credentials
    are present or not.  If user indicated that the supplied credentials be
    used then they will be stashed (overwriting existing ones if any) for
    future use.  The security packages will always prompt for credentials
    if none existed, this optimizes for the most common case before a
    credentials database is built.  But the security packages can be
    configured to not do that.  Security packages will ensure that they
    only prompt to the interactive user, for other logon sessions, this
    flag is ignored.

    When ISC_REQ_USE_SUPPLIED_CREDS flag is set the security package always
    uses the credentials supplied in the InitializeSecurityContext() call
    via InputToken parameter.  If the package does not have any credentials
    available it will prompt for them and record it as indicated above.

    It is an error to set both these flags simultaneously.

    If the ISC_REQ_ALLOCATE_MEMORY was specified then the caller must free
    the memory pointed to by OutputToken by calling FreeContextBuffer().

    For example, the InputToken may be the challenge from a LAN Manager or
    NT file server.  In this case, the OutputToken would be the NTLM
    encrypted response to the challenge.  The caller of this API can then
    take the appropriate response (case-sensitive v.  case-insensitive) and
    return it to the server for an authenticated connection.


Arguments:

   CredentialHandle - Handle to the credentials to be used to
       create the context.

   OldContextHandle - Handle to the partially formed context, if this is
       a second call (see above) or NULL if this is the first call.

   TargetName - String indicating the target of the context.  The name will
       be security package specific.  For example it will be a fully
       qualified Cairo name for Kerberos package and can be UNC name or
       domain name for the NTLM package.

   ContextReqFlags - Requirements of the context, package specific.

      #define ISC_REQ_DELEGATE           0x00000001
      #define ISC_REQ_MUTUAL_AUTH        0x00000002
      #define ISC_REQ_REPLAY_DETECT      0x00000004
      #define ISC_REQ_SEQUENCE_DETECT    0x00000008
      #define ISC_REQ_CONFIDENTIALITY    0x00000010
      #define ISC_REQ_USE_SESSION_KEY    0x00000020
      #define ISC_REQ_PROMT_FOR__CREDS   0x00000040
      #define ISC_REQ_USE_SUPPLIED_CREDS 0x00000080
      #define ISC_REQ_ALLOCATE_MEMORY    0x00000100
      #define ISC_REQ_USE_DCE_STYLE      0x00000200

   Reserved1 - Reserved value, MBZ.

   TargetDataRep - Long indicating the data representation (byte ordering, etc)
        on the target.  The constant SECURITY_NATIVE_DREP may be supplied
        by the transport indicating that the native format is in use.

   InputToken - Pointer to the input token.  In the first call this
       token can either be NULL or may contain security package specific
       information.

   Reserved2 - Reserved value, MBZ.

   NewContextHandle - New context handle.  If this is a second call, this
       can be the same as OldContextHandle.

   OutputToken - Buffer to receive the output token.

   ContextAttributes -Attributes of the context established.

      #define ISC_RET_DELEGATE             0x00000001
      #define ISC_RET_MUTUAL_AUTH          0x00000002
      #define ISC_RET_REPLAY_DETECT        0x00000004
      #define ISC_RET_SEQUENCE_DETECT      0x00000008
      #define ISC_REP_CONFIDENTIALITY      0x00000010
      #define ISC_REP_USE_SESSION_KEY      0x00000020
      #define ISC_REP_USED_COLLECTED_CREDS 0x00000040
      #define ISC_REP_USED_SUPPLIED_CREDS  0x00000080
      #define ISC_REP_ALLOCATED_MEMORY     0x00000100
      #define ISC_REP_USED_DCE_STYLE       0x00000200

   ExpirationTime - Expiration time of the context.

Return Value:

    STATUS_SUCCESS - Message handled
    SEC_I_CALLBACK_NEEDED -- Caller should call again later

    SEC_E_NO_SPM -- Security Support Provider is not running
    SEC_E_INVALID_TOKEN -- Token improperly formatted
    SEC_E_INVALID_HANDLE -- Credential/Context Handle is invalid
    SEC_E_BUFFER_TOO_SMALL -- Buffer for output token isn't big enough
    SEC_E_NO_CREDENTIALS -- There are no credentials for this client
    SEC_E_INSUFFICIENT_MEMORY -- Not enough memory

--*/

{
    SECURITY_STATUS SecStatus;

    PVOID InputTokenBuffer;
    PULONG InputTokenSize;
    ULONG LocalInputTokenSize;

    PVOID OutputTokenBuffer;
    PULONG OutputTokenSize;

    SspPrint((SSP_API, "SspInitializeSecurityContext Entered\n"));

    //
    // Check argument validity
    //

    if (!ARGUMENT_PRESENT(OutputToken)) {
        return (ERROR_BAD_ARGUMENTS);
    }

#ifdef notdef  // ? RPC passes 0x10 or 0 here depending on attitude
    if ( TargetDataRep != SECURITY_NATIVE_DREP ) {
        return (STATUS_INVALID_PARAMETER);
    }
#else // notdef
    UNREFERENCED_PARAMETER( TargetDataRep );
#endif // notdef

    if ( !SspGetTokenBuffer( InputToken,
                             &InputTokenBuffer,
                             &InputTokenSize,
                             TRUE ) ) {
        return (SEC_E_INVALID_TOKEN);
    }

    if ( InputTokenSize == 0 ) {
        InputTokenSize = &LocalInputTokenSize;
        LocalInputTokenSize = 0;
    }

    if ( !SspGetTokenBuffer( OutputToken,
                             &OutputTokenBuffer,
                             &OutputTokenSize,
                             FALSE ) ) {
        return (SEC_E_INVALID_TOKEN);
    }

    //
    // If no previous context was passed in this is the first call.
    //

    if ( !ARGUMENT_PRESENT( OldContextHandle ) ) {

        if ( !ARGUMENT_PRESENT( CredentialHandle ) ) {
            return (SEC_E_INVALID_HANDLE);
        }

        return SspHandleFirstCall(
                   CredentialHandle,
                   NewContextHandle,
                   ContextReqFlags,
                   QOP_NTLMV2,
                   *InputTokenSize,
                   InputTokenBuffer,
                   OutputTokenSize,
                   OutputTokenBuffer,
                   ContextAttributes,
                   ExpirationTime
                   );

        //
        // If context was passed in, continue where we left off.
        //

    } else {

        *NewContextHandle = *OldContextHandle;

        return SspHandleChallengeMessage(
                    NULL,
                    CredentialHandle,
                    NewContextHandle,
                    ContextReqFlags,
                    *InputTokenSize,
                    InputTokenBuffer,
                    OutputTokenSize,
                    OutputTokenBuffer,
                    ContextAttributes,
                    ExpirationTime
                    );
    }

    return (SecStatus);
}

#if 0

SECURITY_STATUS SEC_ENTRY
QueryContextAttributes(
    IN PCtxtHandle ContextHandle,
    IN ULONG Attribute,
    OUT PVOID Buffer
    )

/*++

Routine Description:

    This API allows a customer of the security services to determine
    certain attributes of the context.  These are: sizes, names, and
    lifespan.

Arguments:

    ContextHandle - Handle to the context to query.

    Attribute - Attribute to query.

        #define SECPKG_ATTR_SIZES    0
        #define SECPKG_ATTR_NAMES    1
        #define SECPKG_ATTR_LIFESPAN 2

    Buffer - Buffer to copy the data into.  The buffer must be large enough
        to fit the queried attribute.

Return Value:

    SEC_E_OK - Call completed successfully

    SEC_E_NO_SPM -- Security Support Provider is not running
    SEC_E_INVALID_HANDLE -- Credential/Context Handle is invalid
    SEC_E_UNSUPPORTED_FUNCTION -- Function code is not supported

--*/

{
    SecPkgContext_Sizes ContextSizes;
    SecPkgContext_Lifespan ContextLifespan;
    UCHAR ContextNamesBuffer[sizeof(SecPkgContext_Names)+20];
    PSecPkgContext_Names ContextNames;
    int ContextNamesSize;
    SECURITY_STATUS SecStatus = SEC_E_OK;
    PSSP_CONTEXT Context = NULL;


    //
    // Initialization
    //

    SspPrint(( SSP_API, "SspQueryContextAttributes Entered\n" ));

    //
    // Find the currently existing context.
    //

    Context = SspContextReferenceContext( ContextHandle,
                                          FALSE );

    if ( Context == NULL ) {
        SecStatus = SEC_E_INVALID_HANDLE;
        goto Cleanup;
    }


    //
    // Handle each of the various queried attributes
    //

    switch ( Attribute) {
    case SECPKG_ATTR_SIZES:

        ContextSizes.cbMaxToken = NTLMSP_MAX_TOKEN_SIZE;

        if (Context->NegotiateFlags & (NTLMSSP_NEGOTIATE_ALWAYS_SIGN |
                                       NTLMSSP_NEGOTIATE_SIGN |
                                       NTLMSSP_NEGOTIATE_SEAL ))
        {
            ContextSizes.cbMaxSignature = NTLMSSP_MESSAGE_SIGNATURE_SIZE;
        }
        else
        {
            ContextSizes.cbMaxSignature = 0;
        }

        if (Context->NegotiateFlags & NTLMSSP_NEGOTIATE_SEAL)
        {
            ContextSizes.cbBlockSize = 1;
            ContextSizes.cbSecurityTrailer = NTLMSSP_MESSAGE_SIGNATURE_SIZE;
        }
        else
        {
            ContextSizes.cbBlockSize = 0;
            ContextSizes.cbSecurityTrailer = 0;
        }

        _fmemcpy(Buffer, &ContextSizes, sizeof(ContextSizes));

        break;

    //
    // No one uses the function so don't go to the overhead of maintaining
    // the username in the context structure.
    //

    case SECPKG_ATTR_NAMES:

        ContextNames = (PSecPkgContext_Names)Buffer;
        ContextNames->sUserName = (SEC_CHAR *) SspAlloc(1);

        if (ContextNames->sUserName == NULL) {
            SecStatus = SEC_E_INSUFFICIENT_MEMORY;
            goto Cleanup;
        }
        *ContextNames->sUserName = '\0';

        break;

    case SECPKG_ATTR_LIFESPAN:

        // Use the correct times here
        ContextLifespan.tsStart = SspContextGetTimeStamp( Context, FALSE );
        ContextLifespan.tsExpiry = SspContextGetTimeStamp( Context, TRUE );

        _fmemcpy(Buffer, &ContextLifespan, sizeof(ContextLifespan));

        break;

    default:
        SecStatus = SEC_E_NOT_SUPPORTED;
        break;
    }


    //
    // Free local resources
    //
Cleanup:

    if ( Context != NULL ) {
        SspContextDereferenceContext( Context );
    }

    SspPrint(( SSP_API, "SspQueryContextAttributes returns 0x%x\n", SecStatus ));
    return SecStatus;
}
#endif

SECURITY_STATUS SEC_ENTRY
DeleteSecurityContext (
    PCtxtHandle ContextHandle
    )

/*++

Routine Description:

    Deletes the local data structures associated with the specified
    security context and generates a token which is passed to a remote peer
    so it too can remove the corresponding security context.

    This API terminates a context on the local machine, and optionally
    provides a token to be sent to the other machine.  The OutputToken
    generated by this call is to be sent to the remote peer (initiator or
    acceptor).  If the context was created with the I _REQ_ALLOCATE_MEMORY
    flag, then the package will allocate a buffer for the output token.
    Otherwise, it is the responsibility of the caller.

Arguments:

    ContextHandle - Handle to the context to delete

    TokenLength - Size of the output token (if any) that should be sent to
        the process at the other end of the session.

    Token - Pointer to the token to send.

Return Value:

    SEC_E_OK - Call completed successfully

    SEC_E_NO_SPM -- Security Support Provider is not running
    SEC_E_INVALID_HANDLE -- Credential/Context Handle is invalid

--*/

{
    SECURITY_STATUS SecStatus;
    PSSP_CONTEXT Context = NULL;

    //
    // Initialization
    //

    SspPrint(( SSP_API, "SspDeleteSecurityContext Entered\n" ));

    //
    // Find the currently existing context (and delink it).
    //

    Context = SspContextReferenceContext( ContextHandle,
                                          TRUE );

    if ( Context == NULL ) {
        SecStatus = SEC_E_INVALID_HANDLE;
        goto cleanup;
    } else {
        SspContextDereferenceContext( Context );
        SecStatus = SEC_E_OK;
    }

cleanup:

    if (Context != NULL) {

        SspContextDereferenceContext(Context);

        Context = NULL;
    }

    SspPrint(( SSP_API, "SspDeleteSecurityContext returns 0x%x\n", SecStatus ));
    return SecStatus;
}


SECURITY_STATUS SEC_ENTRY
FreeContextBuffer (
    void * ContextBuffer
    )

/*++

Routine Description:

    This API is provided to allow callers of security API such as
    InitializeSecurityContext() for free the memory buffer allocated for
    returning the outbound context token.

Arguments:

    ContextBuffer - Address of the buffer to be freed.

Return Value:

    SEC_E_OK - Call completed successfully

--*/

{
    //
    // The only allocated buffer that NtLmSsp currently returns to the caller
    // is from EnumeratePackages.  It uses LocalAlloc to allocate memory.  If
    // we ever need memory to be allocated by the service, we have to rethink
    // how this routine distinguishes between to two types of allocated memory.
    //

    SspFree( ContextBuffer );

    return (SEC_E_OK);
}


SECURITY_STATUS SEC_ENTRY
ApplyControlToken (
    PCtxtHandle ContextHandle,
    PSecBufferDesc Input
    )
{
#ifdef DEBUGRPC
    SspPrint(( SSP_API, "ApplyContextToken Called\n" ));
#endif // DEBUGRPC
    return SEC_E_UNSUPPORTED_FUNCTION;
    UNREFERENCED_PARAMETER( ContextHandle );
    UNREFERENCED_PARAMETER( Input );
}

void
SsprGenCheckSum(
    IN  PSecBuffer  pMessage,
    OUT PNTLMSSP_MESSAGE_SIGNATURE  pSig
    )
{
    Crc32(pSig->CheckSum,pMessage->cbBuffer,pMessage->pvBuffer,&pSig->CheckSum);
}

SECURITY_STATUS SEC_ENTRY
MakeSignature(
    IN OUT PCtxtHandle ContextHandle,
    IN ULONG fQOP,
    IN OUT PSecBufferDesc pMessage,
    IN ULONG MessageSeqNo
    )
{
    PSSP_CONTEXT pContext;
    PNTLMSSP_MESSAGE_SIGNATURE  pSig;
    int Signature;
    ULONG i;

    pContext = SspContextReferenceContext(ContextHandle,FALSE);

    if (!pContext ||
        (!(pContext->NegotiateFlags & NTLMSSP_NEGOTIATE_NTLM2)
          && (pContext->Rc4Key == NULL)
          && !(pContext->NegotiateFlags & NTLMSSP_NEGOTIATE_ALWAYS_SIGN)
        )
       )
    {
        return(SEC_E_INVALID_HANDLE);
    }

    if (pContext->NegotiateFlags & NTLMSSP_NEGOTIATE_NTLM2)
    {
         return SspNtlmv2MakeSignature(
                     &pContext->Ntlmv2SKeys,
                     pContext->NegotiateFlags,
                     fQOP,
                     MessageSeqNo,
                     pMessage
                     );
    }

    Signature = -1;
    for (i = 0; i < pMessage->cBuffers; i++)
    {
        if ((pMessage->pBuffers[i].BufferType & 0xFF) == SECBUFFER_TOKEN)
        {
            Signature = i;
            break;
        }
    }
    if (Signature == -1)
    {
        SspContextDereferenceContext(pContext);
        return(SEC_E_INVALID_TOKEN);
    }

    pSig = pMessage->pBuffers[Signature].pvBuffer;

    if (!(pContext->NegotiateFlags & NTLMSSP_NEGOTIATE_SIGN))
    {
        _fmemset(pSig,0,NTLMSSP_MESSAGE_SIGNATURE_SIZE);
        pSig->Version = NTLMSSP_SIGN_VERSION;
        swaplong(pSig->Version) ; // MACBUG
        SspContextDereferenceContext(pContext);
        return(SEC_E_OK);
    }
    //
    // required by CRC-32 algorithm
    //

    pSig->CheckSum = 0xffffffff;

    for (i = 0; i < pMessage->cBuffers ; i++ )
    {
        if (((pMessage->pBuffers[i].BufferType & 0xFF) == SECBUFFER_DATA) &&
            !(pMessage->pBuffers[i].BufferType & SECBUFFER_READONLY))
        {
            SsprGenCheckSum(&pMessage->pBuffers[i], pSig);
        }
    }

    //
    // Required by CRC-32 algorithm
    //

    pSig->CheckSum ^= 0xffffffff;

    pSig->Nonce = pContext->Nonce++;
    pSig->Version = NTLMSSP_SIGN_VERSION; // MACBUG

    swaplong(pSig->CheckSum) ;
    swaplong(pSig->Nonce) ;
    swaplong(pSig->Version) ;

    rc4(pContext->Rc4Key, sizeof(NTLMSSP_MESSAGE_SIGNATURE) - sizeof(ULONG),
        (unsigned char SEC_FAR *) &pSig->RandomPad);
    pMessage->pBuffers[Signature].cbBuffer = sizeof(NTLMSSP_MESSAGE_SIGNATURE);


    SspContextDereferenceContext(pContext);
    return(SEC_E_OK);


}

SECURITY_STATUS SEC_ENTRY
VerifySignature(
    IN OUT PCtxtHandle ContextHandle,
    IN OUT PSecBufferDesc pMessage,
    IN ULONG MessageSeqNo,
    OUT PULONG pfQOP
    )
{
    PSSP_CONTEXT pContext;
    PNTLMSSP_MESSAGE_SIGNATURE  pSig;
    NTLMSSP_MESSAGE_SIGNATURE   Sig;
    int Signature;
    ULONG i;


    UNREFERENCED_PARAMETER(pfQOP);
    UNREFERENCED_PARAMETER(MessageSeqNo);

    pContext = SspContextReferenceContext(ContextHandle,FALSE);

    if (!pContext ||
        (!(pContext->NegotiateFlags & NTLMSSP_NEGOTIATE_NTLM2)
         && (pContext->Rc4Key == NULL)
         && !(pContext->NegotiateFlags & NTLMSSP_NEGOTIATE_ALWAYS_SIGN)
         )
        )
    {
        return(SEC_E_INVALID_HANDLE);
    }

    if (pContext->NegotiateFlags & NTLMSSP_NEGOTIATE_NTLM2)
    {
         return SspNtlmv2VerifySignature(
                     &pContext->Ntlmv2SKeys,
                     pContext->NegotiateFlags,
                     MessageSeqNo,
                     pMessage,
                     pfQOP
                     );
    }

    Signature = -1;
    for (i = 0; i < pMessage->cBuffers; i++)
    {
        if ((pMessage->pBuffers[i].BufferType & 0xFF) == SECBUFFER_TOKEN)
        {
            Signature = i;
            break;
        }
    }
    if (Signature == -1)
    {
        SspContextDereferenceContext(pContext);
        return(SEC_E_INVALID_TOKEN);
    }

    pSig = pMessage->pBuffers[Signature].pvBuffer;
    swaplong(pSig->Version) ;

    //
    // Check if this is just a trailer and not a real signature
    //

    if (!(pContext->NegotiateFlags & NTLMSSP_NEGOTIATE_SIGN))
    {
        SspContextDereferenceContext(pContext);
        _fmemset(&Sig,0,NTLMSSP_MESSAGE_SIGNATURE_SIZE);
        Sig.Version = NTLMSSP_SIGN_VERSION;
        if (!_fmemcmp(&Sig,pSig,NTLMSSP_MESSAGE_SIGNATURE_SIZE))
        {
            return(SEC_E_OK);
        }
        return(SEC_E_MESSAGE_ALTERED);
    }

    Sig.CheckSum = 0xffffffff;
    for (i = 0; i < pMessage->cBuffers ; i++ )
    {
        if (((pMessage->pBuffers[i].BufferType & 0xFF) == SECBUFFER_DATA) &&
            !(pMessage->pBuffers[i].BufferType & SECBUFFER_READONLY))
        {
            SsprGenCheckSum(&pMessage->pBuffers[i], &Sig);
        }
    }

    Sig.CheckSum ^= 0xffffffff;
    Sig.Nonce = pContext->Nonce++;

    rc4(pContext->Rc4Key, sizeof(NTLMSSP_MESSAGE_SIGNATURE) - sizeof(ULONG),
        (unsigned char SEC_FAR *) &pSig->RandomPad);

    SspContextDereferenceContext(pContext);

    swaplong(pSig->CheckSum) ;
    swaplong(pSig->Nonce) ;

    if (pSig->CheckSum != Sig.CheckSum)
    {
        return(SEC_E_MESSAGE_ALTERED);
    }

    if (pSig->Nonce != Sig.Nonce)
    {
        return(SEC_E_OUT_OF_SEQUENCE);
    }

    return(SEC_E_OK);
}

SECURITY_STATUS SEC_ENTRY
SealMessage(
    IN OUT PCtxtHandle ContextHandle,
    IN ULONG fQOP,
    IN OUT PSecBufferDesc pMessage,
    IN ULONG MessageSeqNo
    )
{
    PSSP_CONTEXT pContext;
    PNTLMSSP_MESSAGE_SIGNATURE  pSig;
    int Signature;
    ULONG i;

    UNREFERENCED_PARAMETER(fQOP);
    UNREFERENCED_PARAMETER(MessageSeqNo);

    pContext = SspContextReferenceContext(ContextHandle, FALSE);

    if (!pContext ||
        (!(pContext->NegotiateFlags & NTLMSSP_NEGOTIATE_NTLM2)
         && (pContext->Rc4Key == NULL)
         )
       )
    {
        return(SEC_E_INVALID_HANDLE);
    }

    if (pContext->NegotiateFlags & NTLMSSP_NEGOTIATE_NTLM2)
    {
         return SspNtlmv2SealMessage(
                     &pContext->Ntlmv2SKeys,
                     pContext->NegotiateFlags,
                     fQOP,
                     MessageSeqNo,
                     pMessage
                     );
    }

    Signature = -1;
    for (i = 0; i < pMessage->cBuffers; i++)
    {
        if ((pMessage->pBuffers[i].BufferType & 0xFF) == SECBUFFER_TOKEN)
        {
            Signature = i;
            break;
        }
    }
    if (Signature == -1)
    {
        SspContextDereferenceContext(pContext);
        return(SEC_E_INVALID_TOKEN);
    }

    pSig = pMessage->pBuffers[Signature].pvBuffer;

    //
    // required by CRC-32 algorithm
    //

    pSig->CheckSum = 0xffffffff;

    for (i = 0; i < pMessage->cBuffers ; i++ )
    {
        if (((pMessage->pBuffers[i].BufferType & 0xFF) == SECBUFFER_DATA) &&
            !(pMessage->pBuffers[i].BufferType & SECBUFFER_READONLY))
        {
            SsprGenCheckSum(&pMessage->pBuffers[i], pSig);
            if (pMessage->pBuffers[i].cbBuffer) // rc4 fails with zero byte buffers
                {
                rc4(pContext->Rc4Key,
                    (int) pMessage->pBuffers[i].cbBuffer,
                    (PUCHAR) pMessage->pBuffers[i].pvBuffer );
                }
        }
    }

    //
    // Required by CRC-32 algorithm
    //

    pSig->CheckSum ^= 0xffffffff;

    pSig->Nonce = pContext->Nonce++;
    pSig->Version = NTLMSSP_SIGN_VERSION; // MACBUG

    swaplong(pSig->CheckSum) ;
    swaplong(pSig->Nonce) ;
    swaplong(pSig->Version) ;

    rc4(pContext->Rc4Key, sizeof(NTLMSSP_MESSAGE_SIGNATURE) - sizeof(ULONG),
        (PUCHAR) &pSig->RandomPad);
    pMessage->pBuffers[Signature].cbBuffer = sizeof(NTLMSSP_MESSAGE_SIGNATURE);

    SspContextDereferenceContext(pContext);

    return(SEC_E_OK);
}


SECURITY_STATUS SEC_ENTRY
UnsealMessage(
    IN OUT PCtxtHandle ContextHandle,
    IN OUT PSecBufferDesc pMessage,
    IN ULONG MessageSeqNo,
    OUT PULONG pfQOP
    )
{
    PSSP_CONTEXT pContext;
    PNTLMSSP_MESSAGE_SIGNATURE  pSig;
    NTLMSSP_MESSAGE_SIGNATURE   Sig;
    int Signature;
    ULONG i;

    UNREFERENCED_PARAMETER(pfQOP);
    UNREFERENCED_PARAMETER(MessageSeqNo);

    pContext = SspContextReferenceContext(ContextHandle, FALSE);

    if (!pContext ||
        (!(pContext->NegotiateFlags & NTLMSSP_NEGOTIATE_NTLM2)
         && (!pContext->Rc4Key)
        )
       )
    {
        return(SEC_E_INVALID_HANDLE);
    }

    if (pContext->NegotiateFlags & NTLMSSP_NEGOTIATE_NTLM2)
    {
         return SspNtlmv2UnsealMessage(
                     &pContext->Ntlmv2SKeys,
                     pContext->NegotiateFlags,
                     MessageSeqNo,
                     pMessage,
                     pfQOP
                     );
    }

    Signature = -1;
    for (i = 0; i < pMessage->cBuffers; i++)
    {
        if ((pMessage->pBuffers[i].BufferType & 0xFF) == SECBUFFER_TOKEN)
        {
            Signature = i;
            break;
        }
    }
    if (Signature == -1)
    {
        SspContextDereferenceContext(pContext);
        return(SEC_E_INVALID_TOKEN);
    }

    pSig = pMessage->pBuffers[Signature].pvBuffer;

    Sig.CheckSum = 0xffffffff;
    for (i = 0; i < pMessage->cBuffers ; i++ )
    {
        if (((pMessage->pBuffers[i].BufferType & 0xFF) == SECBUFFER_DATA) &&
            !(pMessage->pBuffers[i].BufferType & SECBUFFER_READONLY))
        {
            if (pMessage->pBuffers[i].cbBuffer)
                {
                rc4(pContext->Rc4Key,
                    (int) pMessage->pBuffers[i].cbBuffer,
                    (unsigned char *) pMessage->pBuffers[i].pvBuffer );
                }
            SsprGenCheckSum(&pMessage->pBuffers[i], &Sig);
        }
    }

    Sig.CheckSum ^= 0xffffffff;
    Sig.Nonce = pContext->Nonce++;

    rc4(pContext->Rc4Key, sizeof(NTLMSSP_MESSAGE_SIGNATURE) - sizeof(ULONG),
        (unsigned char *) &pSig->RandomPad);

    SspContextDereferenceContext(pContext);

    swaplong(pSig->Nonce) ;
    swaplong(pSig->CheckSum) ;

    if (pSig->Nonce != Sig.Nonce)
    {
        return(SEC_E_OUT_OF_SEQUENCE);
    }

    if (pSig->CheckSum != Sig.CheckSum)
    {
        return(SEC_E_MESSAGE_ALTERED);
    }

    return(SEC_E_OK);
}

#if 0
SECURITY_STATUS SEC_ENTRY
CompleteAuthToken (
    PCtxtHandle ContextHandle,
    PSecBufferDesc BufferDescriptor
    )
{
#ifdef DEBUGRPC
    SspPrint(( SSP_API, "CompleteAuthToken Called\n" ));
#endif // DEBUGRPC
    return SEC_E_UNSUPPORTED_FUNCTION;
    UNREFERENCED_PARAMETER( ContextHandle );
    UNREFERENCED_PARAMETER( BufferDescriptor );
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\uam\macsource\macssp\ntlmsspv2.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    ntlmsspv2.h

Abstract:

    NTLM v2 specific stuff

Author:

    Larry Zhu (LZhu) 29-August-2001

Environment:

    User mode only.

Revision History:

--*/

#ifndef NTLMSSPV2_H
#define NTLMSSPV2_H

#ifndef __MACSSP__
#ifdef BLDR_KERNEL_RUNTIME
#include <bootdefs.h>
#endif
#include <security.h>
#include <ntlmsspi.h>
#include <crypt.h>
#include <cred.h>
#include <debug.h>
#include <string.h>
#include <memory.h>
#include <rc4.h>
#include <md5.h>
#include <hmac.h>
#include <winerror.h>
#include <ntstatus.h>
#else
#include <winerror.h>
#include <bootdefs.h>
#include <ntlmsspi.h>
#include <sspi.h>
#include <crypt.h>
#include <cred.h>
#include <rc4.h>
#include <md5.h>
#include <hmac.h>
#include <macunicode.h>
#endif //__MACSSP__

#include <stdlib.h>
#include <string.h>

#ifdef __cplusplus

extern "C" {

#endif  // __cplusplus

VOID
SspFreeUnicodeString(
    IN OUT UNICODE_STRING* pUnicodeString
    );

VOID
SspFreeStringEx(
    IN OUT STRING* pString
    );

NTSTATUS
SspInitUnicodeStringNoAlloc(
    IN PCSTR pszSource,
    OUT UNICODE_STRING* pDestination
    );

NTSTATUS
SspUpcaseUnicodeStringToOemString(
    IN UNICODE_STRING* pUnicodeString,
    OUT STRING* pOemString
    );

VOID
SspCopyStringAsString32(
    IN VOID* pMessageBuffer,
    IN STRING* pInString,
    IN OUT UCHAR** ppWhere,
    OUT STRING32* pOutString32
    );

NTSTATUS
SspGetSystemTimeAsFileTime(
    OUT FILETIME* pSystemTimeAsFileTime
    );

NTSTATUS
SspGenerateChallenge(
    UCHAR ChallengeFromClient[MSV1_0_CHALLENGE_LENGTH]
    );

NTSTATUS
SspConvertRelativeToAbsolute(
    IN VOID* pMessageBase,
    IN ULONG cbMessageSize,
    IN STRING32* pStringToRelocate,
    IN BOOLEAN AlignToWchar,
    IN BOOLEAN AllowNullString,
    OUT STRING* pOutputString
    );

VOID
SspUpcaseUnicodeString(
    IN OUT UNICODE_STRING* pUnicodeString
    );

NTSTATUS
SspLm20GetNtlmv2ChallengeResponse(
    IN NT_OWF_PASSWORD* pNtOwfPassword,
    IN UNICODE_STRING* pUserName,
    IN UNICODE_STRING* pLogonDomainName,
    IN UNICODE_STRING* pTargetInfo,
    IN UCHAR ChallengeToClient[MSV1_0_CHALLENGE_LENGTH],
    OUT MSV1_0_NTLMV2_RESPONSE* pNtlmv2Response,
    OUT MSV1_0_LMV2_RESPONSE* pLmv2Response,
    OUT USER_SESSION_KEY* UserSessionKey,
    OUT LM_SESSION_KEY* LmSessionKey
    );

VOID
SspGetNtlmv2Response(
    IN NT_OWF_PASSWORD* pNtOwfPassword,
    IN UNICODE_STRING* pUserName,
    IN UNICODE_STRING* pLogonDomainName,
    IN ULONG ServerNameLength,
    IN UCHAR ChallengeToClient[MSV1_0_CHALLENGE_LENGTH],
    IN OUT MSV1_0_NTLMV2_RESPONSE* pNtlmv2Response,
    OUT USER_SESSION_KEY* pUserSessionKey,
    OUT LM_SESSION_KEY* pLmSessionKey
    );

// calculate Ntlmv2 OWF from credentials
VOID
SspCalculateNtlmv2Owf(
    IN NT_OWF_PASSWORD* pNtOwfPassword,
    IN UNICODE_STRING* pUserName,
    IN UNICODE_STRING* pLogonDomainName,
    OUT UCHAR Ntlmv2Owf[MSV1_0_NTLMV2_OWF_LENGTH]
    );

// calculate LMV2 response from credentials
VOID
SspGetLmv2Response(
    IN NT_OWF_PASSWORD* pNtOwfPassword,
    IN UNICODE_STRING* pUserName,
    IN UNICODE_STRING* pLogonDomainName,
    IN UCHAR ChallengeToClient[MSV1_0_CHALLENGE_LENGTH],
    IN UCHAR ChallengeFromClient[MSV1_0_CHALLENGE_LENGTH],
    OUT UCHAR Response[MSV1_0_NTLMV2_RESPONSE_LENGTH]
    );

NTSTATUS
SspMakeSessionKeys(
    IN ULONG NegotiateFlags,
    IN STRING* pLmChallengeResponse,
    IN USER_SESSION_KEY* pNtUserSessionKey, // from the DC or GetChalResp
    IN LM_SESSION_KEY* pLanmanSessionKey, // from the DC of GetChalResp
    IN STRING* pDatagramSessionKey,
    OUT USER_SESSION_KEY* pContextSessionKey
    );

NTSTATUS
SspSignSealHelper(
    IN NTLMV2_DERIVED_SKEYS* pNtlmv2Keys,
    IN ULONG NegotiateFlags,
    IN eSignSealOp Op,
    IN ULONG MessageSeqNo,
    IN OUT SecBufferDesc* pMessage,
    OUT NTLMSSP_MESSAGE_SIGNATURE* pSig,
    OUT NTLMSSP_MESSAGE_SIGNATURE** ppSig
    );

SECURITY_STATUS
SspNtStatusToSecStatus(
    IN NTSTATUS NtStatus,
    IN SECURITY_STATUS DefaultStatus
    );

NTSTATUS
SsprHandleNtlmv2ChallengeMessage(
    IN SSP_CREDENTIAL* pCredential,
    IN ULONG cbChallengeMessage,
    IN CHALLENGE_MESSAGE* pChallengeMessage,
    IN OUT ULONG* pNegotiateFlags,
    IN OUT ULONG* pcbAuthenticateMessage,
    OUT AUTHENTICATE_MESSAGE* pAuthenticateMessage,
    OUT USER_SESSION_KEY* pUserSessionKey
    );

VOID
SspMakeNtlmv2SKeys(
    IN USER_SESSION_KEY* pUserSessionKey,
    IN ULONG NegotiateFlags,
    IN ULONG SendNonce,
    IN ULONG RecvNonce,
    OUT NTLMV2_DERIVED_SKEYS* pNtlmv2Keys
    );

SECURITY_STATUS
SspNtlmv2MakeSignature(
    IN NTLMV2_DERIVED_SKEYS* pNtlmv2Keys,
    IN ULONG NegotiateFlags,
    IN ULONG fQOP,
    IN ULONG MessageSeqNo,
    IN OUT SecBufferDesc* pMessage
    );

SECURITY_STATUS
SspNtlmv2VerifySignature(
    IN NTLMV2_DERIVED_SKEYS* pNtlmv2Keys,
    IN ULONG NegotiateFlags,
    IN ULONG MessageSeqNo,
    IN OUT SecBufferDesc* pMessage,
    OUT ULONG* pfQOP
    );

SECURITY_STATUS
SspNtlmv2SealMessage(
    IN NTLMV2_DERIVED_SKEYS* pNtlmv2Keys,
    IN ULONG NegotiateFlags,
    IN ULONG fQOP,
    IN ULONG MessageSeqNo,
    IN OUT SecBufferDesc* pMessage
    );

SECURITY_STATUS
SspNtlmv2UnsealMessage(
    IN NTLMV2_DERIVED_SKEYS* pNtlmv2Keys,
    IN ULONG NegotiateFlags,
    IN ULONG MessageSeqNo,
    IN OUT SecBufferDesc* pMessage,
    OUT ULONG* pfQOP
    );

NTSTATUS
BlGetSystemTimeAsFileTime(
    OUT FILETIME* pSystemTimeAsFileTime
    );

#ifdef MAC

#define NUM_100ns_PER_SECOND					10000000L
#define WINDOWS_MAC_TIME_DIFFERENCE_IN_SECONDS	(159360480*60)	//9561628800 seconds

VOID
SspSwapUnicodeString(
	IN OUT UNICODE_STRING* pString
);

VOID
SspSwapString32Bytes(
	IN STRING32* pString
	);
	
VOID
SspSwapChallengeMessageBytes(
	IN CHALLENGE_MESSAGE* pChallengeMessage
	);
	
VOID
SspSwapAuthenticateMessageBytes(
	IN AUTHENTICATE_MESSAGE* pAuthenticateMessage
	);

LONG
SspMacSecondsFromGMT(void);

#endif //MAC

#ifdef __cplusplus

}

#endif // __cplusplus

#endif // NTLMSSPV2_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\uam\macsource\macssp\owf.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    owf.c

Abstract:

    Implentation of the one-way-functions used to implement password hashing.

        CalculateLmOwfPassword

Author:

    David Chalmers (Davidc) 10-21-91
    David Arnold (DavidAr) 12-15-93 (Adapted for WfW RPC SSP)

Revision History:

--*/
#ifdef BLDR_KERNEL_RUNTIME
#include <bootdefs.h>
#endif

#include <descrypt.h>
#include <ntlmsspi.h>
#include <crypt.h>
#include <descrypt.h>
#include <md4.h>

#include <string.h>


BOOL
CalculateLmOwfPassword(
    IN PLM_PASSWORD LmPassword,
    OUT PLM_OWF_PASSWORD LmOwfPassword
    )

/*++

Routine Description:

    Takes the passed LmPassword and performs a one-way-function on it.
    The current implementation does this by using the password as a key
    to encrypt a known block of text.

Arguments:

    LmPassword - The password to perform the one-way-function on.

    LmOwfPassword - The hashed password is returned here

Return Values:

    TRUE - The function was completed successfully. The hashed
    password is in LmOwfPassword.

    FALSE - Something failed. The LmOwfPassword is undefined.
--*/

{
    char StdEncrPwd[] = "KGS!@#$%";
    BLOCK_KEY    Key[2];
    PCHAR       pKey;

    // Copy the password into our key buffer and zero pad to fill the 2 keys

    pKey = (PCHAR)(&Key[0]);

    while (*LmPassword && (pKey < (PCHAR)(&Key[2]))) {
        *pKey++ = *LmPassword++;
    }

    while (pKey < (PCHAR)(&Key[2])) {
        *pKey++ = 0;
    }


    // Use the keys to encrypt the standard text

    if (DES_ECB_LM(ENCR_KEY,
                   (char *)&Key[0],
                   (unsigned char *)StdEncrPwd,
                   (unsigned char *)&LmOwfPassword->data[0]
                   ) != CRYPT_OK) {

        return (FALSE);
    }
    
    if (DES_ECB_LM(ENCR_KEY,
                   (char *)&Key[1],
                   (unsigned char *)StdEncrPwd,
                   (unsigned char *)&LmOwfPassword->data[1]
                   ) != CRYPT_OK) {

        return (FALSE);
    }

    //
    // clear our copy of the cleartext password
    //

    pKey = (PCHAR)(&Key[0]);

    while (pKey < (PCHAR)(&Key[2])) {
        *pKey++ = 0;
    }

    return(TRUE);
}



BOOL
CalculateNtOwfPassword(
    IN PNT_PASSWORD NtPassword,
    OUT PNT_OWF_PASSWORD NtOwfPassword
    )

/*++

Routine Description:

    Takes the passed NtPassword and performs a one-way-function on it.
    Uses the RSA MD4 function

Arguments:

    NtPassword - The password to perform the one-way-function on.

    NtOwfPassword - The hashed password is returned here

Return Values:

    STATUS_SUCCESS - The function was completed successfully. The hashed
                     password is in NtOwfPassword.
--*/

{
    MD4_CTX     MD4_Context;


    MD4Init(&MD4_Context);

    MD4Update(&MD4_Context, (PUCHAR)NtPassword->Buffer, NtPassword->Length);
    
    MD4Final(&MD4_Context);

    if (sizeof(*NtOwfPassword) != sizeof(MD4_Context.digest)) {
        return(FALSE);
    }
    
    memcpy(NtOwfPassword, MD4_Context.digest, sizeof(*NtOwfPassword));
    
    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\uam\macsource\macssp\ntlmsspi.h ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    ntlmsspi.h

Abstract:

    Header file describing the interface to code common to the
    NT Lanman Security Support Provider (NtLmSsp) Service and the DLL.

Author:

    Cliff Van Dyke (CliffV) 17-Sep-1993

Revision History:

--*/

#ifndef _NTLMSSPI_INCLUDED_
#define _NTLMSSPI_INCLUDED_

#include <rc4.h>
#include <md5.h>
#include <hmac.h>
#include <crypt.h>

#ifndef __MACSSP__
#define SEC_FAR
#define FAR
#define _fmemcpy memcpy
#define _fmemcmp memcmp
#define _fmemset memset
#define _fstrcmp strcmp
#define _fstrcpy strcpy
#define _fstrlen strlen
#define _fstrncmp strncmp
#endif

#ifdef DOS
#ifndef FAR
#define FAR far
#endif
#ifndef SEC_FAR
#define SEC_FAR FAR
#endif
#endif

//#include <sysinc.h>

#define MSV1_0_CHALLENGE_LENGTH 8

#ifndef IN
#define IN
#define OUT
#define OPTIONAL
#endif

#define ARGUMENT_PRESENT(ArgumentPointer)    (\
    (CHAR *)(ArgumentPointer) != (CHAR *)(NULL) )
#define UNREFERENCED_PARAMETER(P)

#ifdef MAC
#define swaplong(Value) \
          Value =  (  (((Value) & 0xFF000000) >> 24) \
             | (((Value) & 0x00FF0000) >> 8) \
             | (((Value) & 0x0000FF00) << 8) \
             | (((Value) & 0x000000FF) << 24))
#else
#define swaplong(Value)
#endif

#ifdef MAC
#define swapshort(Value) \
   Value = (  (((Value) & 0x00FF) << 8) \
             | (((Value) & 0xFF00) >> 8))
#else
#define swapshort(Value)
#endif

#ifndef MAC
typedef int BOOL;
#endif
#ifndef TRUE
#define FALSE 0
#define TRUE 1
#endif

#ifndef MAC
typedef unsigned long ULONG, DWORD, *PULONG;
typedef unsigned long SEC_FAR *LPULONG;
typedef unsigned short USHORT, WORD;
typedef char CHAR, *PCHAR;
typedef unsigned char UCHAR, *PUCHAR;
typedef unsigned char SEC_FAR *LPUCHAR;
typedef void SEC_FAR *PVOID, *LPVOID;
typedef unsigned char BOOLEAN;
#endif
#ifndef BLDR_KERNEL_RUNTIME
typedef long LUID, *PLUID;
#endif

//
// Calculate the address of the base of the structure given its type, and an
// address of a field within the structure.
//

#define CONTAINING_RECORD(address, type, field) ((type *)( \
                                                  (PCHAR)(address) - \
                                                  (PCHAR)(&((type *)0)->field)))

#ifndef BLDR_KERNEL_RUNTIME
typedef struct _LIST_ENTRY {
   struct _LIST_ENTRY *Flink;
   struct _LIST_ENTRY *Blink;
} LIST_ENTRY, *PLIST_ENTRY;
#endif

//
//  VOID
//  InitializeListHead(
//      PLIST_ENTRY ListHead
//      );
//

#define InitializeListHead(ListHead) (\
    (ListHead)->Flink = (ListHead)->Blink = (ListHead))

//
//  VOID
//  RemoveEntryList(
//      PLIST_ENTRY Entry
//      );
//

#define RemoveEntryList(Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_Flink;\
    _EX_Flink = (Entry)->Flink;\
    _EX_Blink = (Entry)->Blink;\
    _EX_Blink->Flink = _EX_Flink;\
    _EX_Flink->Blink = _EX_Blink;\
    }

//
//  VOID
//  InsertHeadList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertHeadList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Flink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Flink = _EX_ListHead->Flink;\
    (Entry)->Flink = _EX_Flink;\
    (Entry)->Blink = _EX_ListHead;\
    _EX_Flink->Blink = (Entry);\
    _EX_ListHead->Flink = (Entry);\
    }

//
//  BOOLEAN
//  IsListEmpty(
//      PLIST_ENTRY ListHead
//      );
//

#define IsListEmpty(ListHead) \
    ((ListHead)->Flink == (ListHead))

//
// Maximum lifetime of a context
//
//#define NTLMSSP_MAX_LIFETIME (2*60*1000)L    // 2 minutes
#define NTLMSSP_MAX_LIFETIME 120000L    // 2 minutes


////////////////////////////////////////////////////////////////////////
//
// Opaque Messages passed between client and server
//
////////////////////////////////////////////////////////////////////////

#define NTLMSSP_SIGNATURE "NTLMSSP"

//
// MessageType for the following messages.
//

typedef enum {
    NtLmNegotiate = 1,
    NtLmChallenge,
    NtLmAuthenticate,
    #ifdef MAC
    NtLmUnknown
    #endif
} NTLM_MESSAGE_TYPE;

//
// Signature structure
//

typedef struct _NTLMSSP_MESSAGE_SIGNATURE {
    ULONG   Version;
    ULONG   RandomPad;
    ULONG   CheckSum;
    ULONG   Nonce;
} NTLMSSP_MESSAGE_SIGNATURE, * PNTLMSSP_MESSAGE_SIGNATURE;

#define NTLMSSP_MESSAGE_SIGNATURE_SIZE sizeof(NTLMSSP_MESSAGE_SIGNATURE)

#define NTLMSSP_SIGN_VERSION 1

#define NTLMSSP_KEY_SALT 0xbd

#define MSV1_0_NTLMV2_RESPONSE_LENGTH     16
#define MSV1_0_NTLMV2_OWF_LENGTH          16
#define MSV1_0_CHALLENGE_LENGTH           8

//
// valid QoP flags
//

#define QOP_NTLMV2                        0x00000001

//
// this is an MSV1_0 private data structure, defining the layout of an Ntlmv2
// response, as sent by a client in the NtChallengeResponse field of the
// NETLOGON_NETWORK_INFO structure. If can be differentiated from an old style
// NT response by its length. This is crude, but it needs to pass through
// servers and the servers' DCs that do not understand Ntlmv2 but that are
// willing to pass longer responses.
//

typedef struct _MSV1_0_NTLMV2_RESPONSE {
    UCHAR Response[MSV1_0_NTLMV2_RESPONSE_LENGTH]; // hash of OWF of password with all the following fields
    UCHAR RespType;      // id number of response; current is 1
    UCHAR HiRespType;    // highest id number understood by client
    USHORT Flags;        // reserved; must be sent as zero at this version
    ULONG MsgWord;       // 32 bit message from client to server (for use by auth protocol)
    ULONGLONG TimeStamp; // time stamp when client generated response -- NT system time, quad part
    UCHAR ChallengeFromClient[MSV1_0_CHALLENGE_LENGTH];
    ULONG AvPairsOff;    // offset to start of AvPairs (to allow future expansion)
    UCHAR Buffer[1];     // start of buffer with AV pairs (or future stuff -- so use the offset)
} MSV1_0_NTLMV2_RESPONSE, *PMSV1_0_NTLMV2_RESPONSE;

#define MSV1_0_NTLMV2_INPUT_LENGTH        (sizeof(MSV1_0_NTLMV2_RESPONSE) - MSV1_0_NTLMV2_RESPONSE_LENGTH)

typedef struct {
    UCHAR Response[MSV1_0_NTLMV2_RESPONSE_LENGTH];
    UCHAR ChallengeFromClient[MSV1_0_CHALLENGE_LENGTH];
} MSV1_0_LMV2_RESPONSE, *PMSV1_0_LMV2_RESPONSE;

//
// User, Group and Password lengths
//

#define UNLEN                             256 // Maximum user name length
#define LM20_UNLEN                        20  // LM 2.0 Maximum user name length

//
// String Lengths for various LanMan names
//

#define CNLEN                             15  // Computer name length
#define LM20_CNLEN                        15  // LM 2.0 Computer name length
#define DNLEN                             CNLEN  // Maximum domain name length
#define LM20_DNLEN                        LM20_CNLEN // LM 2.0 Maximum domain name length

//
// Size of the largest message
//  (The largest message is the AUTHENTICATE_MESSAGE)
//

#define DNSLEN                            256  // length of DNS name

#define TARGET_INFO_LEN                   ((2*DNSLEN + DNLEN + CNLEN) * sizeof(WCHAR) +  \
                                          5 * sizeof(MSV1_0_AV_PAIR))

// length of NTLM2 response
#define NTLMV2_RESPONSE_LENGTH            (sizeof(MSV1_0_NTLMV2_RESPONSE) + \
                                           TARGET_INFO_LEN)

#define NTLMSSP_MAX_MESSAGE_SIZE (sizeof(AUTHENTICATE_MESSAGE) +  \
                                  LM_RESPONSE_LENGTH +            \
                                  NTLMV2_RESPONSE_LENGTH +         \
                                  (DNLEN + 1) * sizeof(WCHAR) +   \
                                  (UNLEN + 1) * sizeof(WCHAR) +   \
                                  (CNLEN + 1) * sizeof(WCHAR))

typedef struct  _MSV1_0_AV_PAIR {
    USHORT AvId;
    USHORT AvLen;
    // Data is treated as byte array following structure
} MSV1_0_AV_PAIR, *PMSV1_0_AV_PAIR;

//
// bootssp does not support RtlOemStringToUnicodeString or
// RtlUnicodeStringToOemString, punt to Ansi Strings
//

#define SspOemStringToUnicodeString    RtlAnsiStringToUnicodeString
#define SspUnicodeStringToOemString    RtlUnicodeStringToAnsiString

#define CSSEALMAGIC "session key to client-to-server sealing key magic constant"
#define SCSEALMAGIC "session key to server-to-client sealing key magic constant"
#define CSSIGNMAGIC "session key to client-to-server signing key magic constant"
#define SCSIGNMAGIC "session key to server-to-client signing key magic constant"

//
// Valid values of NegotiateFlags
//

#define NTLMSSP_NEGOTIATE_UNICODE               0x00000001  // Text strings are in unicode
#define NTLMSSP_NEGOTIATE_OEM                   0x00000002  // Text strings are in OEM
#define NTLMSSP_REQUEST_TARGET                  0x00000004  // Server should return its authentication realm

#define NTLMSSP_NEGOTIATE_SIGN                  0x00000010  // Request signature capability
#define NTLMSSP_NEGOTIATE_SEAL                  0x00000020  // Request confidentiality
#define NTLMSSP_NEGOTIATE_DATAGRAM              0x00000040  // Use datagram style authentication
#define NTLMSSP_NEGOTIATE_LM_KEY                0x00000080  // Use LM session key for sign/seal

#define NTLMSSP_NEGOTIATE_NETWARE               0x00000100  // NetWare authentication
#define NTLMSSP_NEGOTIATE_NTLM                  0x00000200  // NTLM authentication
#define NTLMSSP_NEGOTIATE_NT_ONLY               0x00000400  // NT authentication only (no LM)
#define NTLMSSP_NEGOTIATE_NULL_SESSION          0x00000800  // NULL Sessions on NT 5.0 and beyand

#define NTLMSSP_NEGOTIATE_OEM_DOMAIN_SUPPLIED       0x1000  // Domain Name supplied on negotiate
#define NTLMSSP_NEGOTIATE_OEM_WORKSTATION_SUPPLIED  0x2000  // Workstation Name supplied on negotiate
#define NTLMSSP_NEGOTIATE_LOCAL_CALL            0x00004000  // Indicates client/server are same machine
#define NTLMSSP_NEGOTIATE_ALWAYS_SIGN           0x00008000  // Sign for all security levels

//
// Valid target types returned by the server in Negotiate Flags
//

#define NTLMSSP_TARGET_TYPE_DOMAIN              0x00010000  // TargetName is a domain name
#define NTLMSSP_TARGET_TYPE_SERVER              0x00020000  // TargetName is a server name
#define NTLMSSP_TARGET_TYPE_SHARE               0x00040000  // TargetName is a share name
#define NTLMSSP_NEGOTIATE_NTLM2                 0x00080000  // NTLM2 authentication added for NT4-SP4

#define NTLMSSP_NEGOTIATE_IDENTIFY              0x00100000  // Create identify level token

//
// Valid requests for additional output buffers
//

#define NTLMSSP_REQUEST_INIT_RESPONSE           0x00100000  // get back session keys
#define NTLMSSP_REQUEST_ACCEPT_RESPONSE         0x00200000  // get back session key, LUID
#define NTLMSSP_REQUEST_NON_NT_SESSION_KEY      0x00400000  // request non-nt session key
#define NTLMSSP_NEGOTIATE_TARGET_INFO           0x00800000  // target info present in challenge message

#define NTLMSSP_NEGOTIATE_EXPORTED_CONTEXT      0x01000000  // It's an exported context

#define NTLMSSP_NEGOTIATE_128                   0x20000000  // negotiate 128 bit encryption
#define NTLMSSP_NEGOTIATE_KEY_EXCH              0x40000000  // exchange a key using key exchange key
#define NTLMSSP_NEGOTIATE_56                    0x80000000  // negotiate 56 bit encryption

// flags used in client space to control sign and seal; never appear on the wire
#define NTLMSSP_APP_SEQ                         0x00000040  // Use application provided seq num

typedef struct _NTLMV2_DERIVED_SKEYS {
    ULONG                   KeyLen;          // key length in octets
    ULONG*                  pSendNonce;      // ptr to nonce to use for send
    ULONG*                  pRecvNonce;      // ptr to nonce to use for receive
    struct RC4_KEYSTRUCT*   pSealRc4Sched;   // ptr to key sched used for Seal
    struct RC4_KEYSTRUCT*   pUnsealRc4Sched; // ptr to key sched used to Unseal

    ULONG                   SendNonce;
    ULONG                   RecvNonce;
    UCHAR                   SignSessionKey[sizeof(USER_SESSION_KEY)];
    UCHAR                   VerifySessionKey[sizeof(USER_SESSION_KEY)];
    UCHAR                   SealSessionKey[sizeof(USER_SESSION_KEY)];
    UCHAR                   UnsealSessionKey[sizeof(USER_SESSION_KEY)];
    ULONG64                 Pad1;           // pad keystructs to 64.
    struct RC4_KEYSTRUCT    SealRc4Sched;   // key struct used for Seal
    ULONG64                 Pad2;           // pad keystructs to 64.
    struct RC4_KEYSTRUCT    UnsealRc4Sched; // key struct used to Unseal
} NTLMV2_DERIVED_SKEYS, *PNTLMV2_DERIVED_SKEYS;

//
// Opaque message returned from first call to InitializeSecurityContext
//

typedef struct _NEGOTIATE_MESSAGE {
    UCHAR Signature[sizeof(NTLMSSP_SIGNATURE)];
    NTLM_MESSAGE_TYPE MessageType;
    ULONG NegotiateFlags;
    STRING32 OemDomainName;
    STRING32 OemWorkstationName;
} NEGOTIATE_MESSAGE, *PNEGOTIATE_MESSAGE;

//
// Opaque message returned from first call to AcceptSecurityContext
//

typedef struct _CHALLENGE_MESSAGE {
    UCHAR Signature[sizeof(NTLMSSP_SIGNATURE)];
    NTLM_MESSAGE_TYPE MessageType;
    STRING32 TargetName;
    ULONG NegotiateFlags;
    UCHAR Challenge[MSV1_0_CHALLENGE_LENGTH];
    ULONG64 ServerContextHandle;
    STRING32 TargetInfo;
} CHALLENGE_MESSAGE, *PCHALLENGE_MESSAGE;

//
// Opaque message returned from second call to InitializeSecurityContext
//

typedef struct _AUTHENTICATE_MESSAGE {
    UCHAR Signature[sizeof(NTLMSSP_SIGNATURE)];
    NTLM_MESSAGE_TYPE MessageType;
    STRING32 LmChallengeResponse;
    STRING32 NtChallengeResponse;
    STRING32 DomainName;
    STRING32 UserName;
    STRING32 Workstation;
    STRING32 SessionKey;
    ULONG NegotiateFlags;
} AUTHENTICATE_MESSAGE, *PAUTHENTICATE_MESSAGE;

typedef enum _eSignSealOp {
    eSign,      // MakeSignature is calling
    eVerify,    // VerifySignature is calling
    eSeal,      // SealMessage is calling
    eUnseal     // UnsealMessage is calling
} eSignSealOp;

//
// Version 1 is the structure above, using stream RC4 to encrypt the trailing
// 12 bytes.
//

#define NTLM_SIGN_VERSION                 1

#ifdef __cplusplus
extern "C" {
#endif

//
// the following declarations may be duplicates
//

NTSTATUS
RtlAnsiStringToUnicodeString(
    UNICODE_STRING* DestinationString,
    ANSI_STRING* SourceString,
    BOOLEAN AllocateDestinationString
    );

VOID
RtlInitString(
    OUT STRING* DestinationString,
    IN PCSTR SourceString OPTIONAL
    );

NTSTATUS
RtlUnicodeStringToAnsiString(
    OUT ANSI_STRING* DestinationString,
    IN UNICODE_STRING* SourceString,
    IN BOOLEAN AllocateDestinationString
    );

WCHAR
RtlUpcaseUnicodeChar(
    IN WCHAR SourceCharacter
    );

////////////////////////////////////////////////////////////////////////
//
// Procedure Forwards
//
////////////////////////////////////////////////////////////////////////

PVOID
SspAlloc(
    int Size
    );

void
SspFree(
    PVOID Buffer
    );

PSTRING
SspAllocateString(
    PVOID Value
    );

PSTRING
SspAllocateStringBlock(
    PVOID Value,
    int Length
    );

void
SspFreeString(
    PSTRING * String
    );

void
SspCopyString(
    IN PVOID MessageBuffer,
    OUT PSTRING OutString,
    IN PSTRING InString,
    IN OUT PCHAR *Where,
    IN BOOLEAN Absolute
    );

void
SspCopyStringFromRaw(
    IN PVOID MessageBuffer,
    OUT STRING32* OutString,
    IN PCHAR InString,
    IN int InStringLength,
    IN OUT PCHAR *Where
    );

DWORD
SspTicks(
    );

#ifdef __cplusplus
}
#endif
#endif // ifndef _NTLMSSPI_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\uam\macsource\macssp\ntlmsspv2.c ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    ntlmsspv2.c

Abstract:

    NTLM v2 specific modules

Author:

    Larry Zhu (LZhu) 29-August-2001

Environment:  User Mode

Revision History:

--*/


#ifdef MAC
#ifdef SSP_TARGET_CARBON
#include <Carbon/Carbon.h>
#endif

#include <ntlmsspv2.h>
#include <ntlmsspi.h>
#include <ntlmssp.h>
#include <ntstatus.h>
#include <winerror.h>
#include <crypt.h>
#include "debug.h"
#include "macunicode.h"

#endif //MAC

SECURITY_STATUS
SspNtStatusToSecStatus(
    IN NTSTATUS NtStatus,
    IN SECURITY_STATUS DefaultStatus
    )
/*++

Routine Description:

    Convert an NtStatus code to the corresponding Security status code. For
    particular errors that are required to be returned as is (for setup code)
    don't map the errors.

Arguments:

    NtStatus      - NT status to convert
    DefaultStatus - default security status if NtStatus is not mapped

Return Value:

    Returns security status code.

--*/

{
    SECURITY_STATUS SecStatus;

    //
    // Check for security status and let them through
    //

    if (HRESULT_FACILITY(NtStatus) == FACILITY_SECURITY)
    {
        return (NtStatus);
    }

    switch (NtStatus)
    {
    case STATUS_SUCCESS:
        SecStatus = SEC_E_OK;
        break;

    case STATUS_NO_MEMORY:
    case STATUS_INSUFFICIENT_RESOURCES:
        SecStatus = SEC_E_INSUFFICIENT_MEMORY;
        break;

    case STATUS_NETLOGON_NOT_STARTED:
    case STATUS_DOMAIN_CONTROLLER_NOT_FOUND:
    case STATUS_NO_LOGON_SERVERS:
    case STATUS_NO_SUCH_DOMAIN:
    case STATUS_BAD_NETWORK_PATH:
    case STATUS_TRUST_FAILURE:
    case STATUS_TRUSTED_RELATIONSHIP_FAILURE:
    case STATUS_NETWORK_UNREACHABLE:

        SecStatus = SEC_E_NO_AUTHENTICATING_AUTHORITY;
        break;

    case STATUS_NO_SUCH_LOGON_SESSION:
        SecStatus = SEC_E_UNKNOWN_CREDENTIALS;
        break;

    case STATUS_INVALID_PARAMETER:
    case STATUS_PARTIAL_COPY:
        SecStatus = SEC_E_INVALID_TOKEN;
        break;

    case STATUS_PRIVILEGE_NOT_HELD:
        SecStatus = SEC_E_NOT_OWNER;
        break;

    case STATUS_INVALID_HANDLE:
        SecStatus = SEC_E_INVALID_HANDLE;
        break;

    case STATUS_BUFFER_TOO_SMALL:
        SecStatus = SEC_E_BUFFER_TOO_SMALL;
        break;

    case STATUS_NOT_SUPPORTED:
        SecStatus = SEC_E_UNSUPPORTED_FUNCTION;
        break;

    case STATUS_OBJECT_NAME_NOT_FOUND:
    case STATUS_NO_TRUST_SAM_ACCOUNT:
        SecStatus = SEC_E_TARGET_UNKNOWN;
        break;

    case STATUS_NOLOGON_INTERDOMAIN_TRUST_ACCOUNT:
    case STATUS_NOLOGON_SERVER_TRUST_ACCOUNT:
    case STATUS_NOLOGON_WORKSTATION_TRUST_ACCOUNT:
    case STATUS_TRUSTED_DOMAIN_FAILURE:
        SecStatus = NtStatus;
        break;

    case STATUS_LOGON_FAILURE:
    case STATUS_NO_SUCH_USER:
    case STATUS_ACCOUNT_DISABLED:
    case STATUS_ACCOUNT_RESTRICTION:
    case STATUS_ACCOUNT_LOCKED_OUT:
    case STATUS_WRONG_PASSWORD:
    case STATUS_ACCOUNT_EXPIRED:
    case STATUS_PASSWORD_EXPIRED:
    case STATUS_PASSWORD_MUST_CHANGE:
    case STATUS_LOGON_TYPE_NOT_GRANTED:
        SecStatus = SEC_E_LOGON_DENIED;
        break;

    case STATUS_NAME_TOO_LONG:
    case STATUS_ILL_FORMED_PASSWORD:

        SecStatus = SEC_E_INVALID_TOKEN;
        break;

    case STATUS_TIME_DIFFERENCE_AT_DC:
        SecStatus = SEC_E_TIME_SKEW;
        break;

    case STATUS_SHUTDOWN_IN_PROGRESS:
        SecStatus = SEC_E_SHUTDOWN_IN_PROGRESS;
        break;

    case STATUS_INTERNAL_ERROR:
        SecStatus = SEC_E_INTERNAL_ERROR;
        ASSERT(FALSE);
        break;

    default:

        SecStatus = DefaultStatus;
        break;
    }

    return (SecStatus);
}

NTSTATUS
SspInitUnicodeStringNoAlloc(
    IN PCSTR pszSource,
    IN OUT UNICODE_STRING* pDestination
    )

/*++

Routine Description:

    Initialize unicode string. This routine does not allocate memory.

Arguments:

    pszSource    - source string
    pDestination - unicode string

Return Value:

    NTSTATUS

--*/

{
	#ifndef __MACSSP__
	
    STRING OemString;

    RtlInitString(&OemString, pszSource);

	return SspOemStringToUnicodeString(pDestination, &OemString, FALSE);
	
	#else
	
	UniCharArrayPtr		unicodeString	= NULL;
	OSStatus			Status			= noErr;
	
	Status = MacSspCStringToUnicode(pszSource, &pDestination->Length, &unicodeString);
	
	if (NT_SUCCESS(Status))
	{
		_fmemcpy(pDestination->Buffer, unicodeString, pDestination->Length);
	}
	
	return(Status);
	
	#endif
}

VOID
SspFreeStringEx(
    IN OUT STRING* pString
    )
/*++

Routine Description:

    Free string.

Arguments:

    pString - string to free

Return Value:

    none

--*/

{
    if (pString->MaximumLength && pString->Buffer)
    {
        SspFree(pString->Buffer);

        pString->MaximumLength = pString->Length = 0;
        pString->Buffer = NULL;
    }
}

VOID
SspFreeUnicodeString(
    IN OUT UNICODE_STRING* pUnicodeString
    )

/*++

Routine Description:

    Free unicode string.

Arguments:

    pUnicodeString - unicode string to free

Return Value:

    none

--*/

{
    SspFreeStringEx((STRING *) pUnicodeString);
}

#ifdef MAC

VOID
SspSwapUnicodeString(
	IN OUT UNICODE_STRING* pString
)
/*++

Routine Description:

    Reverse the alignment of each word in the unicode string. Needed
    for Macintosh only.

Arguments:

    pString		- The string to modify.

Return Value:

    None

--*/
{
	if (pString->Length)
	{
		//
		//For mac's we need to reverse each word in the unicode string.
		//
		USHORT i;
		
		for (i = 0; i < (pString->Length/sizeof(USHORT)); i++)
		{
			swapshort(pString->Buffer[i]);
		}
	}
}

#endif


NTSTATUS
SsprHandleNtlmv2ChallengeMessage(
    IN SSP_CREDENTIAL* pCredential,
    IN ULONG cbChallengeMessage,
    IN CHALLENGE_MESSAGE* pChallengeMessage,
    IN OUT ULONG* pNegotiateFlags,
    IN OUT ULONG* pcbAuthenticateMessage,
    OUT AUTHENTICATE_MESSAGE* pAuthenticateMessage,
    OUT USER_SESSION_KEY* pContextSessionKey
    )

/*++

Routine Description:

    Handle challenge message and generate authentication message and context session key

Arguments:

    pCredential              - client credentials
    cbChallengeMessage       - challenge message size
    pChallengeMessage        - challenge message
    pNegotiateFlags          - negotiate flags
    pcbAuthenticateMessage   - size of authentication message
    pAuthenticateMessage     - authentication message
    pContextSessionKey       - context session key

Return Value:

    NTSTATUS

--*/

{
    NTSTATUS NtStatus = STATUS_UNSUCCESSFUL;

    ULONG cbAuthenticateMessage = 0;
    UCHAR* pWhere = NULL;
    BOOLEAN DoUnicode = TRUE;

    //
    // use a scratch buffer to avoid memory allocation in bootssp
    //

    CHAR ScrtachBuff[sizeof(MSV1_0_NTLMV2_RESPONSE) + sizeof(DWORD) + NTLMV2_RESPONSE_LENGTH] = {0};

    STRING LmChallengeResponse = {0};
    STRING NtChallengeResponse = {0};
    STRING DatagramSessionKey = {0};

    USHORT Ntlmv2ResponseSize = 0;
    MSV1_0_NTLMV2_RESPONSE* pNtlmv2Response = NULL;
    LM_SESSION_KEY LanmanSessionKey;
    UNICODE_STRING TargetInfo = {0};
    UCHAR DatagramKey[sizeof(USER_SESSION_KEY)] ={0};
    USER_SESSION_KEY NtUserSessionKey;

    //
    // use pre-allocated buffers to avoid memory allocation in bootssp
    //
    // to be consistent with LSA/SSPI, allow DNS names in szDomainName and
    // szWorkstation
    //

    CHAR szUserName[(UNLEN + 4) * sizeof(WCHAR)] = {0};
    CHAR szDomainName[(DNSLEN + 4) * sizeof(WCHAR)] = {0};
    CHAR szWorkstation[(DNSLEN + 4) * sizeof(WCHAR)] = {0};

    //
    // responses to return to the caller
    //

    LM_RESPONSE LmResponse;
    NT_RESPONSE NtResponse;
    USER_SESSION_KEY ContextSessionKey;
    ULONG NegotiateFlags = 0;
        
	#ifdef MAC
	STRING UserName;
	STRING DomainName;
	STRING Workstation;
	
	UserName.Length = 0;
	UserName.MaximumLength = sizeof(szUserName);
	UserName.Buffer = szUserName;
	
	DomainName.Length = 0;
	DomainName.MaximumLength = sizeof(szDomainName);
	DomainName.Buffer = szDomainName;
	
	Workstation.Length = 0;
	Workstation.MaximumLength = sizeof(szWorkstation);
	Workstation.Buffer = szWorkstation;
	#else
    STRING UserName = {0, sizeof(szUserName), szUserName};
    STRING DomainName = {0, sizeof(szDomainName), szDomainName};
    STRING Workstation = {0, sizeof(szWorkstation), szWorkstation};
    #endif

    _fmemset(&LmResponse, 0, sizeof(LmResponse));
    _fmemset(&NtResponse, 0, sizeof(NtResponse));
    _fmemset(&LanmanSessionKey, 0, sizeof(LanmanSessionKey));
    _fmemset(&NtUserSessionKey, 0, sizeof(NtUserSessionKey));
    _fmemset(&ContextSessionKey, 0, sizeof(ContextSessionKey));

    if (!pCredential || !pChallengeMessage || !pNegotiateFlags || !pcbAuthenticateMessage || !pContextSessionKey)
    {
        return STATUS_INVALID_PARAMETER;
    }

    SspPrint((SSP_NTLMV2, "Entering SsprHandleNtlmv2ChallengeMessage\n"));

    NegotiateFlags = *pNegotiateFlags;

    NtStatus = SspInitUnicodeStringNoAlloc(pCredential->Username, (UNICODE_STRING *) &UserName);

    if (NT_SUCCESS(NtStatus))
    {
        NtStatus = SspInitUnicodeStringNoAlloc(pCredential->Domain, (UNICODE_STRING *) &DomainName);
    }

    if (NT_SUCCESS(NtStatus))
    {
        NtStatus = SspInitUnicodeStringNoAlloc(pCredential->Workstation, (UNICODE_STRING *) &Workstation);
    }

    if (NT_SUCCESS(NtStatus))
    {
        NtStatus = !_fstrcmp(NTLMSSP_SIGNATURE, (char *) pChallengeMessage->Signature) && pChallengeMessage->MessageType == NtLmChallenge ? STATUS_SUCCESS : STATUS_INVALID_PARAMETER;
    }

    if (NT_SUCCESS(NtStatus))
    {
        if (pChallengeMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_UNICODE)
        {
            NegotiateFlags |= NTLMSSP_NEGOTIATE_UNICODE;
            NegotiateFlags &= ~NTLMSSP_NEGOTIATE_OEM;
            DoUnicode = TRUE;
        }
        else if (pChallengeMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_OEM)
        {
            NegotiateFlags |= NTLMSSP_NEGOTIATE_OEM;
            NegotiateFlags &= ~NTLMSSP_NEGOTIATE_UNICODE;
            DoUnicode = FALSE;
        }
        else
        {
            NtStatus = STATUS_INVALID_PARAMETER;
        }
    }

    if (NT_SUCCESS(NtStatus))
    {
        if (!DoUnicode)
        {
            //
            // username will be upcased in SspCalculateNtlmv2Owf
            //

            SspUpcaseUnicodeString((UNICODE_STRING *) &DomainName);
            SspUpcaseUnicodeString((UNICODE_STRING *) &Workstation);
        }

        if (pChallengeMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_TARGET_INFO)
        {
            NegotiateFlags |= NTLMSSP_NEGOTIATE_TARGET_INFO;
        }
        else
        {
            NegotiateFlags &= ~(NTLMSSP_NEGOTIATE_TARGET_INFO);
        }

        if (pChallengeMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_NTLM2)
        {
            NegotiateFlags &= ~NTLMSSP_NEGOTIATE_LM_KEY;
        }
        else // (!(pChallengeMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_NTLM2))
        {
            NegotiateFlags &= ~(NTLMSSP_NEGOTIATE_NTLM2);
        }

        if (!(pChallengeMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_NTLM))
        {
            NegotiateFlags &= ~(NTLMSSP_NEGOTIATE_NTLM);
        }

        if (!(pChallengeMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_KEY_EXCH))
        {
            NegotiateFlags &= ~(NTLMSSP_NEGOTIATE_KEY_EXCH);
        }

        if (!(pChallengeMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_LM_KEY))
        {
            NegotiateFlags &= ~(NTLMSSP_NEGOTIATE_LM_KEY);
        }

        if ((NegotiateFlags & NTLMSSP_NEGOTIATE_DATAGRAM) &&
            (NegotiateFlags & (NTLMSSP_NEGOTIATE_SIGN |NTLMSSP_NEGOTIATE_SEAL)))
        {
            NegotiateFlags |= NTLMSSP_NEGOTIATE_KEY_EXCH;
        }

        if (!(pChallengeMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_56))
        {
            NegotiateFlags &= ~(NTLMSSP_NEGOTIATE_56);
        }

        if ((pChallengeMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_128) == 0)
        {
            NegotiateFlags &= ~(NTLMSSP_NEGOTIATE_128);
        }

        if (pChallengeMessage->NegotiateFlags & NTLMSSP_NEGOTIATE_ALWAYS_SIGN)
        {
            NegotiateFlags |= NTLMSSP_NEGOTIATE_ALWAYS_SIGN;
        }
        else
        {
            NegotiateFlags &= ~NTLMSSP_NEGOTIATE_ALWAYS_SIGN;
        }

        NtStatus = SspConvertRelativeToAbsolute(
                        pChallengeMessage,
                        cbChallengeMessage,
                        &pChallengeMessage->TargetInfo,
                        DoUnicode,
                        TRUE, // NULL target info OK
                        (STRING *) &TargetInfo
                        );
    }

    if (NT_SUCCESS(NtStatus))
    {
        Ntlmv2ResponseSize = sizeof(MSV1_0_NTLMV2_RESPONSE) + TargetInfo.Length;

        NtStatus = Ntlmv2ResponseSize <= sizeof(ScrtachBuff) ? STATUS_SUCCESS : STATUS_INSUFFICIENT_RESOURCES;
    }

    if (NT_SUCCESS(NtStatus))
    {
        // C_ASSERT(sizeof(MSV1_0_NTLMV2_RESPONSE) == sizeof(LM_RESPONSE));

        pNtlmv2Response = (MSV1_0_NTLMV2_RESPONSE *) ScrtachBuff;

        NtStatus = SspLm20GetNtlmv2ChallengeResponse(
                        pCredential->NtPassword,
                        (UNICODE_STRING *) &UserName,
                        (UNICODE_STRING *) &DomainName,
                        &TargetInfo,
                        pChallengeMessage->Challenge,
                        pNtlmv2Response,
                        (MSV1_0_LMV2_RESPONSE *) &LmResponse,
                        &NtUserSessionKey,
                        &LanmanSessionKey
                        );
    }

    if (NT_SUCCESS(NtStatus))
    {
        NtChallengeResponse.Buffer = (CHAR *) pNtlmv2Response;
        NtChallengeResponse.Length = Ntlmv2ResponseSize;
        LmChallengeResponse.Buffer = (CHAR *) &LmResponse;
        LmChallengeResponse.Length = sizeof(LmResponse);

        //
        // prepare to send encrypted randomly generated session key
        //

        DatagramSessionKey.Buffer = (CHAR *) DatagramKey;
        DatagramSessionKey.Length = DatagramSessionKey.MaximumLength = 0;

        //
        // Generate the session key, or encrypt the previosly generated random
        // one, from various bits of info. Fill in session key if needed.
        //

        NtStatus = SspMakeSessionKeys(
                        NegotiateFlags,
                        &LmChallengeResponse,
                        &NtUserSessionKey,
                        &LanmanSessionKey,
                        &DatagramSessionKey,
                        &ContextSessionKey
                        );
    }

    if (NT_SUCCESS(NtStatus) && !DoUnicode)
    {
        NtStatus = SspUpcaseUnicodeStringToOemString((UNICODE_STRING *) &DomainName, &DomainName);

        if (NT_SUCCESS(NtStatus))
        {
            NtStatus = SspUpcaseUnicodeStringToOemString((UNICODE_STRING *) &UserName, &UserName);
        }

        if (NT_SUCCESS(NtStatus))
        {
            NtStatus = SspUpcaseUnicodeStringToOemString((UNICODE_STRING *) &Workstation, &Workstation);
        }
    }

    if (NT_SUCCESS(NtStatus))
    {
        cbAuthenticateMessage =
                sizeof(*pAuthenticateMessage) +
                LmChallengeResponse.Length +
                NtChallengeResponse.Length +
                DomainName.Length +
                UserName.Length +
                Workstation.Length +
                DatagramSessionKey.Length;

        NtStatus = cbAuthenticateMessage <= *pcbAuthenticateMessage ? STATUS_SUCCESS : STATUS_BUFFER_TOO_SMALL;

        if (NtStatus == STATUS_BUFFER_TOO_SMALL)
        {
            *pcbAuthenticateMessage = cbAuthenticateMessage;
        }
    }

    if (NT_SUCCESS(NtStatus))
    {
        _fmemset(pAuthenticateMessage, 0, cbAuthenticateMessage);

        //
        // Build the authenticate message
        //

        StringCbCopy(
        	(char *)pAuthenticateMessage->Signature,
        	sizeof(pAuthenticateMessage->Signature),
        	NTLMSSP_SIGNATURE
        	);

        pAuthenticateMessage->MessageType = NtLmAuthenticate;

        pWhere = (UCHAR *) (pAuthenticateMessage + 1);

        //
        // Copy the strings needing 2 byte alignment.
        //

        SspCopyStringAsString32(
            pAuthenticateMessage,
            &DomainName,
            &pWhere,
            &pAuthenticateMessage->DomainName
            );

        SspCopyStringAsString32(
            pAuthenticateMessage,
            &UserName,
            &pWhere,
            &pAuthenticateMessage->UserName
            );

        SspCopyStringAsString32(
            pAuthenticateMessage,
            &Workstation,
            &pWhere,
            &pAuthenticateMessage->Workstation
            );

        //
        // Copy the strings not needing special alignment.
        //

        SspCopyStringAsString32(
            pAuthenticateMessage,
            (STRING *) &LmChallengeResponse,
            &pWhere,
            &pAuthenticateMessage->LmChallengeResponse
            );

        SspCopyStringAsString32(
            pAuthenticateMessage,
            (STRING *) &NtChallengeResponse,
            &pWhere,
            &pAuthenticateMessage->NtChallengeResponse
            );

        SspCopyStringAsString32(
            pAuthenticateMessage,
            (STRING *) &DatagramSessionKey,
            &pWhere,
            &pAuthenticateMessage->SessionKey
            );

        pAuthenticateMessage->NegotiateFlags = NegotiateFlags;

        *pcbAuthenticateMessage = cbAuthenticateMessage;
        *pContextSessionKey = ContextSessionKey;
        *pNegotiateFlags = NegotiateFlags;
    }

    SspPrint((SSP_NTLMV2, "Leaving SsprHandleNtlmv2ChallengeMessage %#x\n", NtStatus));

    return NtStatus;
}

NTSTATUS
SspGenerateChallenge(
    UCHAR ChallengeFromClient[MSV1_0_CHALLENGE_LENGTH]
    )

/*++

Routine Description:

    Generate a challenge.

Arguments:

    ChallengeFromClient  - challenge from client

Return Value:

    NTSTATUS

--*/

{
    NTSTATUS NtStatus;
    MD5_CTX Md5Context;
    FILETIME CurTime;
    ULONG ulRandom;

    SspPrint((SSP_NTLMV2, "SspGenerateChallenge\n"));

#ifdef USE_CONSTANT_CHALLENGE

    _fmemset(ChallengeFromClient, 0, MSV1_0_CHALLENGE_LENGTH);

    return STATUS_SUCCESS;

#endif

    ulRandom = rand();
    _fmemcpy(ChallengeFromClient, &ulRandom, sizeof(ULONG));
    ulRandom = rand();
    _fmemcpy(ChallengeFromClient + sizeof(ULONG), &ulRandom, sizeof(ULONG));

    NtStatus = SspGetSystemTimeAsFileTime(&CurTime);

    if (!NT_SUCCESS(NtStatus))
    {
        return NtStatus;
    }

    MD5Init(&Md5Context);
    MD5Update(&Md5Context, ChallengeFromClient, MSV1_0_CHALLENGE_LENGTH);
    MD5Update(&Md5Context, (UCHAR*)&CurTime, sizeof(CurTime));
    MD5Final(&Md5Context);

    //
    // only take the first half of the MD5 hash
    //

    _fmemcpy(ChallengeFromClient, Md5Context.digest, MSV1_0_CHALLENGE_LENGTH);

    return NtStatus;
}

NTSTATUS
SspConvertRelativeToAbsolute(
    IN VOID* pMessageBase,
    IN ULONG cbMessageSize,
    IN STRING32* pStringToRelocate,
    IN BOOLEAN AlignToWchar,
    IN BOOLEAN AllowNullString,
    OUT STRING* pOutputString
    )

/*++

Routine Description:

    Convert relative string to absolute string

Arguments:

    pMessageBase       - message base
    cbMessageSize      - mssage size
    pStringToRelocate  - relative string
    AlignToWchar       - align to wide char
    AllowNullString    - allow null string
    pOutputString      - output string

Return Value:

    NTSTATUS

--*/

{
    ULONG Offset;

    //
    // If the buffer is allowed to be null,
    //  check that special case.
    //

    if (AllowNullString && (pStringToRelocate->Length == 0))
    {
        pOutputString->MaximumLength = pOutputString->Length = pStringToRelocate->Length;
        pOutputString->Buffer = NULL;
        return STATUS_SUCCESS;
    }

    //
    // Ensure the string in entirely within the message.
    //

    Offset = (ULONG)pStringToRelocate->Buffer;

    if (Offset >= cbMessageSize || Offset + pStringToRelocate->Length > cbMessageSize)
    {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Ensure the buffer is properly aligned.
    //

    if (AlignToWchar && (!COUNT_IS_ALIGNED(Offset, ALIGN_WCHAR) ||
                         !COUNT_IS_ALIGNED(pStringToRelocate->Length, ALIGN_WCHAR)))
    {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Finally make the pointer absolute.
    //

    pOutputString->Buffer = (CHAR*)(pMessageBase) + Offset;
    pOutputString->MaximumLength = pOutputString->Length = pStringToRelocate->Length ;

    return STATUS_SUCCESS;
}

NTSTATUS
SspUpcaseUnicodeStringToOemString(
    IN UNICODE_STRING* pUnicodeString,
    OUT STRING* pOemString
    )

/*++

Routine Description:

    Upcase unicode string and convert it to oem string.

Arguments:

    pUnicodeString   - uncide string
    pOemString       - OEM string

Return Value:

    NTSTATUS

--*/

{
    ULONG i;

    //
    // use a scratch buffer: the strings we encounter are among
    // username/domainname/workstationname, hence the length are
    // UNLEN maximum
    //

    CHAR Buffer[2 * (UNLEN + 4)] = {0};
    
    #ifndef MAC
    STRING OemString = {0, sizeof(Buffer), Buffer};
    #else
    STRING OemString;
    
    OemString.Length  = 0;
    OemString.MaximumLength = sizeof(Buffer);
    OemString.Buffer = Buffer;
    #endif

    if (OemString.MaximumLength < pUnicodeString->Length)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // upcase the unicode string and put it into OemString
    //

    OemString.Length = pUnicodeString->Length;

    for (i = 0; i < pUnicodeString->Length / sizeof(WCHAR); i++)
    {
        ((UNICODE_STRING*)(&OemString))->Buffer[i] = RtlUpcaseUnicodeChar(pUnicodeString->Buffer[i]);
    }

    return SspUnicodeStringToOemString((STRING*)(pUnicodeString), (UNICODE_STRING*)(&OemString), FALSE);
}

VOID
SspUpcaseUnicodeString(
    IN OUT UNICODE_STRING* pUnicodeString
    )

/*++

Routine Description:

    Upcase unicode string, modifying string in place.

Arguments:

    pUnicodeString - string

Return Value:

    none

--*/

{
    ULONG i;

    for (i = 0; i < pUnicodeString->Length / sizeof(WCHAR); i++)
    {
        pUnicodeString->Buffer[i] = RtlUpcaseUnicodeChar(pUnicodeString->Buffer[i]);
    }
}

NTSTATUS
SspGetSystemTimeAsFileTime(
    OUT FILETIME* pSystemTimeAsFileTime
    )

/*++

Routine Description:

    Get system time as FILETIME

Arguments:

    pSystemTimeAsFileTime system time as FILETIME

Return Value:

    NTSTATUS

--*/

{
#if !defined(USE_CONSTANT_CHALLENGE) && defined(MAC)
	DWORD	dwTime;
	ULONGLONG time64 = 0;
	MACFILETIME	MacFileTime;
#endif
	
    SspPrint((SSP_NTLMV2, "SspGetSystemTimeAsFileTime\n"));

#ifdef USE_CONSTANT_CHALLENGE

    _fmemset(pSystemTimeAsFileTime, 0, sizeof(*pSystemTimeAsFileTime));

    return STATUS_SUCCESS;

#else

#ifndef MAC
    return BlGetSystemTimeAsFileTime(pSystemTimeAsFileTime);
#else
	//
	//The following is from the MacOffice folks. I know is just works...
	//
	
	GetDateTime(&dwTime);
	time64 = dwTime;
	
	time64 -= SspMacSecondsFromGMT();
	time64 += WINDOWS_MAC_TIME_DIFFERENCE_IN_SECONDS;
	time64 *= NUM_100ns_PER_SECOND;
	
	//
	//Get time in FILETIME format.
	//
	_fmemcpy(&MacFileTime, &time64, sizeof(time64));
	
	pSystemTimeAsFileTime->dwLowDateTime = MacFileTime.dwLowDateTime;
	pSystemTimeAsFileTime->dwHighDateTime = MacFileTime.dwHighDateTime;
	
	swaplong(pSystemTimeAsFileTime->dwLowDateTime);
	swaplong(pSystemTimeAsFileTime->dwHighDateTime);

	return STATUS_SUCCESS;
#endif

#endif

}

NTSTATUS
SspLm20GetNtlmv2ChallengeResponse(
    IN NT_OWF_PASSWORD* pNtOwfPassword,
    IN UNICODE_STRING* pUserName,
    IN UNICODE_STRING* pLogonDomainName,
    IN UNICODE_STRING* pTargetInfo,
    IN UCHAR ChallengeToClient[MSV1_0_CHALLENGE_LENGTH],
    OUT MSV1_0_NTLMV2_RESPONSE* pNtlmv2Response,
    OUT MSV1_0_LMV2_RESPONSE* pLmv2Response,
    OUT USER_SESSION_KEY* pNtUserSessionKey,
    OUT LM_SESSION_KEY* pLmSessionKey
    )

/*++

Routine Description:

    Get NTLMv2 response and session keys. This route fills in time stamps and
    challenge from client.

Arguments:

    pNtOwfPassword      - NT OWF
    pUserName           - user name
    pLogonDomainName    - logon domain name
    pTargetInfo         - target info
    ChallengeToClient   - challenge to client
    pNtlmv2Response     - NTLM v2 response
    pLmv2Response       - LM v2 response
    pNtUserSessionKey   - NT user session key
    pLmSessionKey       - LM session key

Return Value:

    NTSTATUS

--*/

{
    NTSTATUS NtStatus;

    SspPrint((SSP_API, "Entering SspLm20GetNtlmv2ChallengeResponse\n"));
    
    //
    // fill in version numbers, timestamp, and client's challenge
    //

    pNtlmv2Response->RespType = 1;
    pNtlmv2Response->HiRespType = 1;
    pNtlmv2Response->Flags = 0;
    pNtlmv2Response->MsgWord = 0;

    NtStatus = SspGetSystemTimeAsFileTime((FILETIME*)(&pNtlmv2Response->TimeStamp));

    if (NT_SUCCESS(NtStatus))
    {
        NtStatus = SspGenerateChallenge(pNtlmv2Response->ChallengeFromClient);
    }

    if (NT_SUCCESS(NtStatus))
    {
        _fmemcpy(pNtlmv2Response->Buffer, pTargetInfo->Buffer, pTargetInfo->Length);

        //
        // Calculate Ntlmv2 response, filling in response field
        //

        SspGetNtlmv2Response(
            pNtOwfPassword,
            pUserName,
            pLogonDomainName,
            pTargetInfo->Length,
            ChallengeToClient,
            pNtlmv2Response,
            pNtUserSessionKey,
            pLmSessionKey
            );

        //
        // Use same challenge to compute the LMV2 response
        //

        _fmemcpy(pLmv2Response->ChallengeFromClient, pNtlmv2Response->ChallengeFromClient, MSV1_0_CHALLENGE_LENGTH);

        //
        // Calculate LMV2 response
        //

        SspGetLmv2Response(
            pNtOwfPassword,
            pUserName,
            pLogonDomainName,
            ChallengeToClient,
            pLmv2Response->ChallengeFromClient,
            pLmv2Response->Response
            );
    }

    SspPrint((SSP_API, "Leaving SspLm20GetNtlmv2ChallengeResponse %#x\n", NtStatus));

    return NtStatus;
}

VOID
SspGetNtlmv2Response(
    IN NT_OWF_PASSWORD* pNtOwfPassword,
    IN UNICODE_STRING* pUserName,
    IN UNICODE_STRING* pLogonDomainName,
    IN ULONG TargetInfoLength,
    IN UCHAR ChallengeToClient[MSV1_0_CHALLENGE_LENGTH],
    IN OUT MSV1_0_NTLMV2_RESPONSE* pNtlmv2Response,
    OUT USER_SESSION_KEY* pNtUserSessionKey,
    OUT LM_SESSION_KEY* pLmSessionKey
    )
/*++

Routine Description:

    Get NTLM v2 response.

Arguments:

    pNtOwfPassword    - NT OWF
    pUserName         - user name
    pLogonDomainName  - logon domain name
    TargetInfoLength  - target info length
    ChallengeToClient - challenge to client
    pNtlmv2Response   - NTLM v2 response
    response          - response
    pNtUserSessionKey - NT user session key
    pLmSessionKey     - LM session key

Return Value:

    none

--*/

{
    HMACMD5_CTX HMACMD5Context;
    UCHAR Ntlmv2Owf[MSV1_0_NTLMV2_OWF_LENGTH];

    SspPrint((SSP_NTLMV2, "SspGetLmv2Response\n"));
    
    //
    // get Ntlmv2 OWF
    //

    SspCalculateNtlmv2Owf(
        pNtOwfPassword,
        pUserName,
        pLogonDomainName,
        Ntlmv2Owf
        );
    
    //
    // Calculate Ntlmv2 Response
    // HMAC(Ntlmv2Owf, (NS, V, HV, T, NC, S))
    //

    HMACMD5Init(
        &HMACMD5Context,
        Ntlmv2Owf,
        MSV1_0_NTLMV2_OWF_LENGTH
        );

    HMACMD5Update(
        &HMACMD5Context,
        ChallengeToClient,
        MSV1_0_CHALLENGE_LENGTH
        );

    HMACMD5Update(
        &HMACMD5Context,
        &pNtlmv2Response->RespType,
        (MSV1_0_NTLMV2_INPUT_LENGTH + TargetInfoLength)
        );

    HMACMD5Final(
        &HMACMD5Context,
        pNtlmv2Response->Response
        );

    //
    // now compute the session keys
    //  HMAC(Kr, R)
    //

    HMACMD5Init(
        &HMACMD5Context,
        Ntlmv2Owf,
        MSV1_0_NTLMV2_OWF_LENGTH
        );

    HMACMD5Update(
        &HMACMD5Context,
        pNtlmv2Response->Response,
        MSV1_0_NTLMV2_RESPONSE_LENGTH
        );

    HMACMD5Final(
        &HMACMD5Context,
        (UCHAR*)(pNtUserSessionKey)
        );

    _fmemcpy(pLmSessionKey, pNtUserSessionKey, sizeof(LM_SESSION_KEY));
}

VOID
SspCopyStringAsString32(
    IN VOID* pMessageBuffer,
    IN STRING* pInString,
    IN OUT UCHAR** ppWhere,
    OUT STRING32* pOutString32
    )

/*++

Routine Description:

    Copy string as STRING32

Arguments:

    pMessageBuffer  - STRING32 base
    pInString       - input STRING
    ppWhere         - next empty spot in pMessageBuffer
    pOutString32    - output STRING32

Return Value:

    none

--*/

{
    //
    // Copy the data to the Buffer
    //

    if (pInString->Buffer != NULL)
    {
        _fmemcpy(*ppWhere, pInString->Buffer, pInString->Length);
    }

    //
    // Build a descriptor to the newly copied data
    //

    pOutString32->Length = pOutString32->MaximumLength = pInString->Length;
    pOutString32->Buffer = (ULONG)(*ppWhere - (UCHAR*)(pMessageBuffer));


    //
    // Update Where to point past the copied data
    //

    *ppWhere += pInString->Length;
}

VOID
SspCalculateNtlmv2Owf(
    IN NT_OWF_PASSWORD* pNtOwfPassword,
    IN UNICODE_STRING* pUserName,
    IN UNICODE_STRING* pLogonDomainName,
    OUT UCHAR Ntlmv2Owf[MSV1_0_NTLMV2_OWF_LENGTH]
    )
/*++

Routine Description:

    Calculate Ntlm v2 OWF, salted with username and logon domain name

Arguments:

    pNtOwfPassword    - NT OWF
    pUserName         - user name
    pLogonDomainName  - logon domain name
    Ntlmv2Owf         - NTLM v2 OWF

Return Value:

    none

--*/

{
    HMACMD5_CTX HMACMD5Context;

    SspPrint((SSP_NTLMV2, "SspCalculateNtlmv2Owf\n"));

    SspUpcaseUnicodeString(pUserName);

    //
    //For Macintosh computers, we need to change the alignment
    //of the unicode strings so it matches windows alignment.
    //
    #ifdef MAC
    SspSwapUnicodeString(pUserName);
    SspSwapUnicodeString(pLogonDomainName);
    #endif
    
    //
    // Calculate Ntlmv2 OWF -- HMAC(MD4(P), (UserName, LogonDomainName))
    //

    HMACMD5Init(
        &HMACMD5Context,
        (UCHAR *) pNtOwfPassword,
        sizeof(*pNtOwfPassword)
        );

    HMACMD5Update(
        &HMACMD5Context,
        (UCHAR *) pUserName->Buffer,
        pUserName->Length
        );

    HMACMD5Update(
        &HMACMD5Context,
        (UCHAR *) pLogonDomainName->Buffer,
        pLogonDomainName->Length
        );

    HMACMD5Final(
        &HMACMD5Context,
        Ntlmv2Owf
        );

	//
	//For Macintosh, we need to set the alignment back to the
	//host alignment in case the strings need to be manipulated
	//in the future.
	//
    #ifdef MAC
    SspSwapUnicodeString(pUserName);
    SspSwapUnicodeString(pLogonDomainName);
    #endif
}

VOID
SspGetLmv2Response(
    IN NT_OWF_PASSWORD* pNtOwfPassword,
    IN UNICODE_STRING* pUserName,
    IN UNICODE_STRING* pLogonDomainName,
    IN UCHAR ChallengeToClient[MSV1_0_CHALLENGE_LENGTH],
    IN UCHAR ChallengeFromClient[MSV1_0_CHALLENGE_LENGTH],
    OUT UCHAR Response[MSV1_0_NTLMV2_RESPONSE_LENGTH]
    )

/*++

Routine Description:

    Get LMv2 response

Arguments:

    pNtOwfPassword       - NT OWF
    pUserName            - user name
    pLogonDomainName     - logon domain name
    ChallengeToClient    - challenge to client
    pLmv2Response        - Lm v2 response
    Routine              - response

Return Value:

    NTSTATUS

--*/

{
    HMACMD5_CTX HMACMD5Context;
    UCHAR Ntlmv2Owf[MSV1_0_NTLMV2_OWF_LENGTH];

    C_ASSERT(MD5DIGESTLEN == MSV1_0_NTLMV2_RESPONSE_LENGTH);

    SspPrint((SSP_NTLMV2, "SspGetLmv2Response\n"));

    //
    // get Ntlmv2 OWF
    //

    SspCalculateNtlmv2Owf(
        pNtOwfPassword,
        pUserName,
        pLogonDomainName,
        Ntlmv2Owf
        );

    //
    // Calculate Ntlmv2 Response
    // HMAC(Ntlmv2Owf, (NS, V, HV, T, NC, S))
    //

    HMACMD5Init(
        &HMACMD5Context,
        Ntlmv2Owf,
        MSV1_0_NTLMV2_OWF_LENGTH
        );

    HMACMD5Update(
        &HMACMD5Context,
        ChallengeToClient,
        MSV1_0_CHALLENGE_LENGTH
        );

    HMACMD5Update(
        &HMACMD5Context,
        ChallengeFromClient,
        MSV1_0_CHALLENGE_LENGTH
        );

    HMACMD5Final(
        &HMACMD5Context,
        Response
        );

    return;
}

NTSTATUS
SspMakeSessionKeys(
    IN ULONG NegotiateFlags,
    IN STRING* pLmChallengeResponse,
    IN USER_SESSION_KEY* pNtUserSessionKey, // from the DC or GetChalResp
    IN LM_SESSION_KEY* pLanmanSessionKey, // from the DC of GetChalResp
    OUT STRING* pDatagramSessionKey, // this is the session key sent over wire
    OUT USER_SESSION_KEY* pContextSessionKey // session key in context
    )

/*++

Routine Description:

    Make NTLMv2 context session key and DatagramSessionKey.

Arguments:

    NegotiateFlags        - negotiate flags
    pLmChallengeResponse  - LM challenge response
    pNtUserSessionKey     - NtUserSessionKey
    pLanmanSessionKey     - LanmanSessionKey
    pDatagramSessionKey   - DatagramSessionKey
    pContextSessionKey    - NTLMv2 conext session key

Return Value:

    NTSTATUS

--*/

{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    UCHAR pLocalSessionKey[sizeof(USER_SESSION_KEY)] = {0};

    SspPrint((SSP_NTLMV2, "Entering SspMakeSessionKeys\n"));

    if (!(NegotiateFlags & (NTLMSSP_NEGOTIATE_SIGN| NTLMSSP_NEGOTIATE_SEAL)))
    {
        _fmemcpy(pContextSessionKey, pNtUserSessionKey, sizeof(pLocalSessionKey));
        return STATUS_SUCCESS;
    }

    if (NegotiateFlags & NTLMSSP_NEGOTIATE_NTLM2)
    {
        _fmemcpy(pLocalSessionKey, pNtUserSessionKey, sizeof(pLocalSessionKey));
    }
    else if(NegotiateFlags & NTLMSSP_NEGOTIATE_LM_KEY)
    {
        LM_OWF_PASSWORD LmKey;
        LM_RESPONSE LmResponseKey;

        BYTE pTemporaryResponse[LM_RESPONSE_LENGTH] = {0};

        if (pLmChallengeResponse->Length > LM_RESPONSE_LENGTH)
        {
            return STATUS_NOT_SUPPORTED;
        }

        _fmemcpy(pTemporaryResponse, pLmChallengeResponse->Buffer, pLmChallengeResponse->Length);

        _fmemcpy(&LmKey, pLanmanSessionKey, sizeof(LM_SESSION_KEY));

        _fmemset((UCHAR*)(&LmKey) + sizeof(LM_SESSION_KEY),
                NTLMSSP_KEY_SALT,
                LM_OWF_PASSWORD_LENGTH - sizeof(LM_SESSION_KEY)
                );

        NtStatus = CalculateLmResponse(
                    (LM_CHALLENGE *) pTemporaryResponse,
                    &LmKey,
                    &LmResponseKey
                    );

        if (!NT_SUCCESS(NtStatus))
        {
            return NtStatus;
        }

        _fmemcpy(pLocalSessionKey, &LmResponseKey, sizeof(USER_SESSION_KEY));
    }
    else
    {
        _fmemcpy(pLocalSessionKey, pNtUserSessionKey, sizeof(USER_SESSION_KEY));
    }

    if (NegotiateFlags & NTLMSSP_NEGOTIATE_KEY_EXCH)
    {
        struct RC4_KEYSTRUCT Rc4Key;

        rc4_key(
            &Rc4Key,
            sizeof(USER_SESSION_KEY),
            pLocalSessionKey
            );

        if (pDatagramSessionKey == NULL)
        {
            rc4(
                &Rc4Key,
                sizeof(USER_SESSION_KEY),
                (UCHAR*) pContextSessionKey
                );
        }
        else
        {
            pDatagramSessionKey->Length =
                pDatagramSessionKey->MaximumLength =
                    sizeof(USER_SESSION_KEY);

            _fmemcpy(pDatagramSessionKey->Buffer, pContextSessionKey, sizeof(USER_SESSION_KEY));

            rc4(
                &Rc4Key,
                sizeof(USER_SESSION_KEY),
                (UCHAR*)(pDatagramSessionKey->Buffer)
                );
        }
    }
    else
    {
        _fmemcpy(pContextSessionKey, pLocalSessionKey, sizeof(USER_SESSION_KEY));
    }

    SspPrint((SSP_NTLMV2, "Leaving SspMakeSessionKeys %#x\n", NtStatus));

    return NtStatus;
}

VOID
SspMakeNtlmv2SKeys(
    IN USER_SESSION_KEY* pUserSessionKey,
    IN ULONG NegotiateFlags,
    IN ULONG SendNonce,
    IN ULONG RecvNonce,
    OUT NTLMV2_DERIVED_SKEYS* pNtlmv2Keys
    )

/*++

Routine Description:

    Derive all NTLMv2 session keys

Arguments:

    pUserSessionKey - NTLMv2 user session key
    NegotiateFlags  - negotiate flags
    SendNonce       - send message sequence number
    RecvNonce       - receive message sequence number
    pNtlmv2Keys     - derived NTLMv2 session keys

Return Value:

    none

--*/

{
    MD5_CTX Md5Context;

    C_ASSERT(MD5DIGESTLEN == sizeof(USER_SESSION_KEY));

    SspPrint((SSP_NTLMV2, "SspMakeSessionKeys\n"));

    if (NegotiateFlags & NTLMSSP_NEGOTIATE_128)
    {
        pNtlmv2Keys->KeyLen = 16;
    }
    else if (NegotiateFlags & NTLMSSP_NEGOTIATE_56)
    {
        pNtlmv2Keys->KeyLen = 7;
    }
    else
    {
        pNtlmv2Keys->KeyLen = 5;
    }

    //
    // make client to server encryption key
    //

    MD5Init(&Md5Context);
    MD5Update(&Md5Context, (UCHAR*)(pUserSessionKey), pNtlmv2Keys->KeyLen);
    MD5Update(&Md5Context, (UCHAR*)(CSSEALMAGIC), sizeof(CSSEALMAGIC));
    MD5Final(&Md5Context);

    _fmemcpy(&pNtlmv2Keys->SealSessionKey, Md5Context.digest, sizeof(USER_SESSION_KEY));

    //
    // make server to client encryption key
    //

    MD5Init(&Md5Context);
    MD5Update(&Md5Context, (UCHAR*)(pUserSessionKey), pNtlmv2Keys->KeyLen);
    MD5Update(&Md5Context, (UCHAR*)(SCSEALMAGIC), sizeof(SCSEALMAGIC));
    MD5Final(&Md5Context);

    _fmemcpy(&pNtlmv2Keys->UnsealSessionKey, Md5Context.digest, sizeof(USER_SESSION_KEY));

    //
    // make client to server signing key -- always 128 bits!
    //

    MD5Init(&Md5Context);
    MD5Update(&Md5Context, (UCHAR*)(pUserSessionKey), sizeof(USER_SESSION_KEY));
    MD5Update(&Md5Context, (UCHAR*)(CSSIGNMAGIC), sizeof(CSSIGNMAGIC));
    MD5Final(&Md5Context);

    _fmemcpy(&pNtlmv2Keys->SignSessionKey, Md5Context.digest, sizeof(USER_SESSION_KEY));

    //
    // make server to client signing key
    //

    MD5Init(&Md5Context);
    MD5Update(&Md5Context, (UCHAR*)(pUserSessionKey), sizeof(USER_SESSION_KEY));
    MD5Update(&Md5Context, (UCHAR*)(SCSIGNMAGIC), sizeof(SCSIGNMAGIC));
    MD5Final(&Md5Context);

    _fmemcpy(&pNtlmv2Keys->VerifySessionKey, Md5Context.digest, sizeof(USER_SESSION_KEY));

    //
    // set pointers to different key schedule and nonce for each direction
    // key schedule will be filled in later...
    //

    pNtlmv2Keys->pSealRc4Sched = &pNtlmv2Keys->SealRc4Sched;
    pNtlmv2Keys->pUnsealRc4Sched = &pNtlmv2Keys->UnsealRc4Sched;
    pNtlmv2Keys->pSendNonce = &pNtlmv2Keys->SendNonce;
    pNtlmv2Keys->pRecvNonce = &pNtlmv2Keys->RecvNonce;

    pNtlmv2Keys->SendNonce = SendNonce;
    pNtlmv2Keys->RecvNonce = RecvNonce;
    rc4_key(&pNtlmv2Keys->SealRc4Sched, sizeof(USER_SESSION_KEY), (UCHAR*)(&pNtlmv2Keys->SealSessionKey));
    rc4_key(&pNtlmv2Keys->UnsealRc4Sched, sizeof(USER_SESSION_KEY), (UCHAR*)(&pNtlmv2Keys->UnsealSessionKey));
}

NTSTATUS
SspSignSealHelper(
    IN NTLMV2_DERIVED_SKEYS* pNtlmv2Keys,
    IN ULONG NegotiateFlags,
    IN eSignSealOp Op,
    IN ULONG MessageSeqNo,
    IN OUT SecBufferDesc* pMessage,
    OUT NTLMSSP_MESSAGE_SIGNATURE* pSig,
    OUT NTLMSSP_MESSAGE_SIGNATURE** ppSig
    )

/*++

Routine Description:

    Helper function for signing/sealing/unsealing/verifying.

Arguments:

    pNtlmv2Keys      - key materials
    NegotiateFlags   - negotiate Flags
    Op               - which operation to performance
    MessageSeqNo     - message sequence number
    pMessage         - message buffer descriptor
    pSig             - result signature
    ppSig            - address of the signature token in message
                       buffer descriptor pMessage

Return Value:

    SECURITY_STATUS

--*/

{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    HMACMD5_CTX HMACMD5Context;
    UCHAR TempSig[MD5DIGESTLEN];
    NTLMSSP_MESSAGE_SIGNATURE Sig;
    int Signature;
    ULONG i;
    PUCHAR pKey = NULL; // ptr to key to use for encryption
    PUCHAR pSignKey = NULL; // ptr to key to use for signing
    PULONG pNonce  = NULL; // ptr to nonce to use
    struct RC4_KEYSTRUCT* pRc4Sched = NULL; // ptr to key schedule to use

    NTLMSSP_MESSAGE_SIGNATURE AlignedSig; // aligned copy of input sig data

    SspPrint((SSP_NTLMV2, "Entering SspSignSealHelper NegotiateFlags %#x, eSignSealOp %d\n", NegotiateFlags, Op));

    Signature = -1;
    for (i = 0; i < pMessage->cBuffers; i++)
    {
        if ((pMessage->pBuffers[i].BufferType & 0xFF) == SECBUFFER_TOKEN)
        {
            Signature = i;
            break;
        }
    }

    if (Signature == -1)
    {
        NtStatus = STATUS_INVALID_PARAMETER;
    }

    if (NT_SUCCESS(NtStatus))
    {
        if (pMessage->pBuffers[Signature].cbBuffer < sizeof(NTLMSSP_MESSAGE_SIGNATURE))
        {
            NtStatus = STATUS_INVALID_PARAMETER;
        }
    }

    if (NT_SUCCESS(NtStatus))
    {
        *ppSig = (NTLMSSP_MESSAGE_SIGNATURE*)(pMessage->pBuffers[Signature].pvBuffer);

        _fmemcpy(&AlignedSig, *ppSig, sizeof(AlignedSig));

        //
        // If sequence detect wasn't requested, put on an empty security token.
        // Don't do the check if Seal/Unseal is called
        //

        if (!(NegotiateFlags & NTLMSSP_NEGOTIATE_SIGN) &&
           (Op == eSign || Op == eVerify))
        {
            _fmemset(pSig, 0, sizeof(NTLMSSP_MESSAGE_SIGNATURE));
            pSig->Version = NTLM_SIGN_VERSION;
            NtStatus = STATUS_SUCCESS;
        }
    }

    if (NT_SUCCESS(NtStatus))
    {
        switch (Op)
        {
        case eSeal:
            pSignKey = pNtlmv2Keys->SignSessionKey;    // if NTLM2
            pKey = pNtlmv2Keys->SealSessionKey;
            pRc4Sched = pNtlmv2Keys->pSealRc4Sched;
            pNonce = pNtlmv2Keys->pSendNonce;
            break;
        case eUnseal:
            pSignKey = pNtlmv2Keys->VerifySessionKey;  // if NTLM2
            pKey = pNtlmv2Keys->UnsealSessionKey;
            pRc4Sched = pNtlmv2Keys->pUnsealRc4Sched;
            pNonce = pNtlmv2Keys->pRecvNonce;
            break;
        case eSign:
            pSignKey = pNtlmv2Keys->SignSessionKey;    // if NTLM2
            pKey = pNtlmv2Keys->SealSessionKey;        // might be used to encrypt the signature
            pRc4Sched = pNtlmv2Keys->pSealRc4Sched;
            pNonce = pNtlmv2Keys->pSendNonce;
            break;
        case eVerify:
            pSignKey = pNtlmv2Keys->VerifySessionKey;  // if NTLM2
            pKey = pNtlmv2Keys->UnsealSessionKey;      // might be used to decrypt the signature
            pRc4Sched = pNtlmv2Keys->pUnsealRc4Sched;
            pNonce = pNtlmv2Keys->pRecvNonce;
            break;
        default:
            NtStatus = (STATUS_INVALID_LEVEL);
            break;
        }
    }

    //
    // Either we can supply the sequence number, or the application can supply
    // the message sequence number.
    //

    if (NT_SUCCESS(NtStatus))
    {
        Sig.Version = NTLM_SIGN_VERSION;

        if ((NegotiateFlags & NTLMSSP_APP_SEQ) == 0)
        {
            Sig.Nonce = *pNonce;    // use our sequence number
            (*pNonce) += 1;
        }
        else
        {
            if (Op == eSeal || Op == eSign || MessageSeqNo != 0)
            {
                Sig.Nonce = MessageSeqNo;
            }
            else
            {
                Sig.Nonce = AlignedSig.Nonce;
            }

            //
            // if using RC4, must rekey for each packet RC4 is used for seal,
            // unseal; and for encrypting the HMAC hash if key exchange was
            // negotiated (we use just HMAC if no key exchange, so that a good
            // signing option exists with no RC4 encryption needed)
            //

            if (Op == eSeal || Op == eUnseal || NegotiateFlags & NTLMSSP_NEGOTIATE_KEY_EXCH)
            {
                MD5_CTX Md5ContextReKey;
                C_ASSERT(MD5DIGESTLEN == sizeof(USER_SESSION_KEY));

                MD5Init(&Md5ContextReKey);
                MD5Update(&Md5ContextReKey, pKey, sizeof(USER_SESSION_KEY));
                MD5Update(&Md5ContextReKey, (unsigned char*)&Sig.Nonce, sizeof(Sig.Nonce));
                MD5Final(&Md5ContextReKey);
                rc4_key(pRc4Sched, sizeof(USER_SESSION_KEY), Md5ContextReKey.digest);
            }
        }

        //
        // using HMAC hash, init it with the key
        //

        HMACMD5Init(&HMACMD5Context, pSignKey, sizeof(USER_SESSION_KEY));

        //
        // include the message sequence number
        //

        HMACMD5Update(&HMACMD5Context, (unsigned char*)&Sig.Nonce, sizeof(Sig.Nonce));

        for (i = 0; i < pMessage->cBuffers; i++)
        {
            if (((pMessage->pBuffers[i].BufferType & 0xFF) == SECBUFFER_DATA) &&
                (pMessage->pBuffers[i].cbBuffer != 0))
            {
                //
                // decrypt (before checksum...) if it's not READ_ONLY
                //

                if ((Op == eUnseal)
                    && !(pMessage->pBuffers[i].BufferType & SECBUFFER_READONLY))
                {
                    rc4(
                        pRc4Sched,
                        pMessage->pBuffers[i].cbBuffer,
                        (UCHAR*)(pMessage->pBuffers[i].pvBuffer)
                        );
                }

                HMACMD5Update(
                            &HMACMD5Context,
                            (UCHAR*)(pMessage->pBuffers[i].pvBuffer),
                            pMessage->pBuffers[i].cbBuffer
                            );

                //
                // Encrypt if its not READ_ONLY
                //

                if ((Op == eSeal)
                    && !(pMessage->pBuffers[i].BufferType & SECBUFFER_READONLY))
                {
                    rc4(
                        pRc4Sched,
                        pMessage->pBuffers[i].cbBuffer,
                        (UCHAR*)(pMessage->pBuffers[i].pvBuffer)
                        );
                }
            }
        }

        HMACMD5Final(&HMACMD5Context, TempSig);

        //
        // use RandomPad and Checksum fields for 8 bytes of MD5 hash
        //

        _fmemcpy(&Sig.RandomPad, TempSig, 8);

        //
        // if we're using crypto for KEY_EXCH, may as well use it for signing too
        //

        if (NegotiateFlags & NTLMSSP_NEGOTIATE_KEY_EXCH)
        {
            rc4(
                pRc4Sched,
                8,
                (UCHAR*)(&Sig.RandomPad)
                );
        }

        _fmemcpy(pSig, &Sig, sizeof(NTLMSSP_MESSAGE_SIGNATURE));
    }

    SspPrint((SSP_NTLMV2, "Leaving SspSignSealHelper %#x\n", NtStatus));

    return STATUS_SUCCESS;
}

SECURITY_STATUS
SspNtlmv2MakeSignature(
    IN NTLMV2_DERIVED_SKEYS* pNtlmv2Keys,
    IN ULONG NegotiateFlags,
    IN ULONG fQOP,
    IN ULONG MessageSeqNo,
    IN OUT SecBufferDesc* pMessage
    )

/*++

Routine Description:

    Make signature of a message

Arguments:

    pNtlmv2Keys      - key materials
    NegotiateFlags   - negotiate Flags
    fQOP             - quality of protection
    MessageSeqNo     - message Sequence Number
    pMessage         - message buffer descriptor

Return Value:

    SECURITY_STATUS

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    NTLMSSP_MESSAGE_SIGNATURE Sig;
    NTLMSSP_MESSAGE_SIGNATURE *pSig;

    Status = SspSignSealHelper(
                pNtlmv2Keys,
                NegotiateFlags,
                eSign,
                MessageSeqNo,
                pMessage,
                &Sig,
                &pSig
                );

    if (NT_SUCCESS(Status))
    {
        _fmemcpy(pSig, &Sig, sizeof(NTLMSSP_MESSAGE_SIGNATURE));
    }

    return SspNtStatusToSecStatus(Status, SEC_E_INTERNAL_ERROR);
}

SECURITY_STATUS
SspNtlmv2VerifySignature(
    IN NTLMV2_DERIVED_SKEYS* pNtlmv2Keys,
    IN ULONG NegotiateFlags,
    IN ULONG MessageSeqNo,
    IN OUT SecBufferDesc* pMessage,
    OUT ULONG* pfQOP
    )

/*++

Routine Description:

    Verify signature of a message

Arguments:

    pNtlmv2Keys      - key materials
    NegotiateFlags   - negotiate Flags
    MessageSeqNo     - message Sequence Number
    pMessage         - message buffer descriptor
    pfQOP            - quality of protection

Return Value:

    SECURITY_STATUS

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    NTLMSSP_MESSAGE_SIGNATURE Sig;
    NTLMSSP_MESSAGE_SIGNATURE* pSig; // pointer to buffer with sig in it
    NTLMSSP_MESSAGE_SIGNATURE AlignedSig; // Aligned sig buffer.

    Status = SspSignSealHelper(
                pNtlmv2Keys,
                NegotiateFlags,
                eVerify,
                MessageSeqNo,
                pMessage,
                &Sig,
                &pSig
                );

    if (NT_SUCCESS(Status))
    {
        _fmemcpy(&AlignedSig, pSig, sizeof(AlignedSig));

        if (AlignedSig.Version != NTLM_SIGN_VERSION)
        {
           return SEC_E_INVALID_TOKEN;
        }

        //
        // validate the signature...
        //

        if (AlignedSig.CheckSum != Sig.CheckSum)
        {
            return SEC_E_MESSAGE_ALTERED;
        }

        //
        // with MD5 sig, this now matters!
        //

        if (AlignedSig.RandomPad != Sig.RandomPad)
        {
            return  SEC_E_MESSAGE_ALTERED;
        }

        if (AlignedSig.Nonce != Sig.Nonce)
        {
           return SEC_E_OUT_OF_SEQUENCE;
        }
    }

    return SspNtStatusToSecStatus(Status, SEC_E_INTERNAL_ERROR);
}

SECURITY_STATUS
SspNtlmv2SealMessage(
    IN NTLMV2_DERIVED_SKEYS* pNtlmv2Keys,
    IN ULONG NegotiateFlags,
    IN ULONG fQOP,
    IN ULONG MessageSeqNo,
    IN OUT SecBufferDesc* pMessage
    )

/*++

Routine Description:

    Seal a message

Arguments:

    pNtlmv2Keys      - key materials
    NegotiateFlags   - negotiate Flags
    fQOP             - quality of protection
    MessageSeqNo     - message Sequence Number
    pMessage         - message buffer descriptor

Return Value:

    SECURITY_STATUS

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    NTLMSSP_MESSAGE_SIGNATURE Sig;
    NTLMSSP_MESSAGE_SIGNATURE* pSig;    // pointer to buffer where sig goes
    ULONG i;

    Status = SspSignSealHelper(
                    pNtlmv2Keys,
                    NegotiateFlags,
                    eSeal,
                    MessageSeqNo,
                    pMessage,
                    &Sig,
                    &pSig
                    );

    if (NT_SUCCESS(Status))
    {
        _fmemcpy(pSig, &Sig, sizeof(NTLMSSP_MESSAGE_SIGNATURE));

        //
        // for gss style sign/seal, strip the padding as RC4 requires none.
        // (in fact, we rely on this to simplify the size computation in
        // DecryptMessage). if we support some other block cipher, need to rev
        // the NTLM_ token version to make blocksize
        //

        for (i = 0; i < pMessage->cBuffers; i++)
        {
            if ((pMessage->pBuffers[i].BufferType & 0xFF) == SECBUFFER_PADDING)
            {
                //
                // no padding required!
                //

                pMessage->pBuffers[i].cbBuffer = 0;
                break;
            }
        }
    }

    return SspNtStatusToSecStatus(Status, SEC_E_INTERNAL_ERROR);
}

SECURITY_STATUS
SspNtlmv2UnsealMessage(
    IN NTLMV2_DERIVED_SKEYS* pNtlmv2Keys,
    IN ULONG NegotiateFlags,
    IN ULONG MessageSeqNo,
    IN OUT SecBufferDesc* pMessage,
    OUT ULONG* pfQOP
    )

/*++

Routine Description:

    Unseal a message

Arguments:

    pNtlmv2Keys      - key materials
    NegotiateFlags   - negotiate Flags
    MessageSeqNo     - message Sequence Number
    pMessage         - message buffer descriptor
    pfQOP            - quality of protection

Return Value:

    SECURITY_STATUS

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    NTLMSSP_MESSAGE_SIGNATURE Sig;
    NTLMSSP_MESSAGE_SIGNATURE* pSig; // pointer to buffer where sig goes
    NTLMSSP_MESSAGE_SIGNATURE AlignedSig; // aligned buffer.

    SecBufferDesc* pMessageBuffers = pMessage;
    ULONG Index;
    SecBuffer* pSignatureBuffer = NULL;
    SecBuffer* pStreamBuffer = NULL;
    SecBuffer* pDataBuffer = NULL;
    SecBufferDesc ProcessBuffers;
    SecBuffer wrap_bufs[2];

    //
    // Find the body and signature SecBuffers from pMessage
    //

    for (Index = 0; Index < pMessageBuffers->cBuffers; Index++)
    {
        if ((pMessageBuffers->pBuffers[Index].BufferType & ~SECBUFFER_ATTRMASK) == SECBUFFER_TOKEN)
        {
            pSignatureBuffer = &pMessageBuffers->pBuffers[Index];
        }
        else if ((pMessageBuffers->pBuffers[Index].BufferType & ~SECBUFFER_ATTRMASK) == SECBUFFER_STREAM)
        {
            pStreamBuffer = &pMessageBuffers->pBuffers[Index];
        }
        else if ((pMessageBuffers->pBuffers[Index].BufferType & ~SECBUFFER_ATTRMASK) == SECBUFFER_DATA)
        {
            pDataBuffer = &pMessageBuffers->pBuffers[Index];
        }
    }

    if (pStreamBuffer != NULL)
    {
        if (pSignatureBuffer != NULL)
        {
            return SEC_E_INVALID_TOKEN;
        }

        //
        // for version 1 NTLM blobs, padding is never present, since RC4 is
        // stream cipher
        //

        wrap_bufs[0].cbBuffer = sizeof(NTLMSSP_MESSAGE_SIGNATURE);
        wrap_bufs[1].cbBuffer = pStreamBuffer->cbBuffer - sizeof(NTLMSSP_MESSAGE_SIGNATURE);

        if (pStreamBuffer->cbBuffer < wrap_bufs[0].cbBuffer)
        {
            return SEC_E_INVALID_TOKEN;
        }

        wrap_bufs[0].BufferType = SECBUFFER_TOKEN;
        wrap_bufs[0].pvBuffer = pStreamBuffer->pvBuffer;

        wrap_bufs[1].BufferType = SECBUFFER_DATA;
        wrap_bufs[1].pvBuffer = (PBYTE)wrap_bufs[0].pvBuffer + wrap_bufs[0].cbBuffer;

        if (pDataBuffer == NULL)
        {
            return SEC_E_INVALID_TOKEN;
        }

        pDataBuffer->cbBuffer = wrap_bufs[1].cbBuffer;
        pDataBuffer->pvBuffer = wrap_bufs[1].pvBuffer;

        ProcessBuffers.cBuffers = 2;
        ProcessBuffers.pBuffers = wrap_bufs;
        ProcessBuffers.ulVersion = SECBUFFER_VERSION;
    }
    else
    {
        ProcessBuffers = *pMessageBuffers;
    }

    Status = SspSignSealHelper(
                pNtlmv2Keys,
                NegotiateFlags,
                eUnseal,
                MessageSeqNo,
                &ProcessBuffers,
                &Sig,
                &pSig
                );

    if (NT_SUCCESS(Status))
    {
        _fmemcpy(&AlignedSig, pSig, sizeof(AlignedSig));

        if (AlignedSig.Version != NTLM_SIGN_VERSION)
        {
            return SEC_E_INVALID_TOKEN;
        }

        //
        // validate the signature...
        //

        if (AlignedSig.CheckSum != Sig.CheckSum)
        {
            return SEC_E_MESSAGE_ALTERED;
        }

        if (AlignedSig.RandomPad != Sig.RandomPad)
        {
            return SEC_E_MESSAGE_ALTERED;
        }

        if (AlignedSig.Nonce != Sig.Nonce)
        {
            return SEC_E_OUT_OF_SEQUENCE;
        }
    }

    return SspNtStatusToSecStatus(Status, SEC_E_INTERNAL_ERROR);
}


#ifdef MAC

VOID
SspSwapString32Bytes(
	IN STRING32* pString
)

/*++

Routine Description:

    Take a STRING32 struct and swap it's bytes (big and little endian).

Arguments:

    pString      - the STRING32 to swap

Return Value:

    none

--*/

{	
	swapshort(pString->Length);
	swapshort(pString->MaximumLength);
	swaplong(pString->Buffer);
}


VOID
SspSwapChallengeMessageBytes(
	IN CHALLENGE_MESSAGE* pChallengeMessage
	)
	
/*++

Routine Description:

    Make sure all the fields are in big endian format before parsing
    the fields. This routine is only usefull when this code is running
    on machines that align bigendian (ie. Macintosh computers).

Arguments:

    pChallengeMessage      - the challenge message to swap

Return Value:

    none

--*/

{
	if (pChallengeMessage)
	{
		swaplong(pChallengeMessage->NegotiateFlags);
		
		SspSwapString32Bytes(&pChallengeMessage->TargetName);
		SspSwapString32Bytes(&pChallengeMessage->TargetInfo);
	}
}


VOID
SspSwapAuthenticateMessageBytes(
	IN AUTHENTICATE_MESSAGE* pAuthenticateMessage
	)

/*++

Routine Description:

    Make sure all the fields are in little endian format before sending to a Windows
    server. This routine is only usefull when this code is running on machines that
    align bigendian (ie. Macintosh computers).

Arguments:

    pAuthenticateMessage      - the authentication message to swap

Return Value:

    none

--*/

{
	if (pAuthenticateMessage)
	{
		SspSwapString32Bytes(&pAuthenticateMessage->LmChallengeResponse);
		SspSwapString32Bytes(&pAuthenticateMessage->NtChallengeResponse);
		SspSwapString32Bytes(&pAuthenticateMessage->DomainName);
		SspSwapString32Bytes(&pAuthenticateMessage->UserName);
		SspSwapString32Bytes(&pAuthenticateMessage->Workstation);
		SspSwapString32Bytes(&pAuthenticateMessage->SessionKey);
		
		swaplong(pAuthenticateMessage->NegotiateFlags);
	}
}

LONG
SspMacSecondsFromGMT(void)

/*++

Routine Description:

    Get the numbers of seconds from GMT on Macintosh computers.

Arguments:

    None.

Return Value:

    LONG - seconds from GMT (in mac time format)

--*/

{
	MachineLocation	location;
	DWORD secondsFromGMT;
	
	ReadLocation(&location);
	
	secondsFromGMT = location.u.gmtDelta & 0x00FFFFFF;
	
	if (secondsFromGMT & 0x00800000)
		secondsFromGMT |= 0xFF000000;
	
	return secondsFromGMT;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\uam\macsource\macssp\response.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    response.c

Abstract:

    Contains functions that calculate the correct response to return
    to the server when logging on.

        CalculateLmResponse


Author:

    David Chalmers (Davidc) 10-21-91
    David Arnold (DavidAr) 12-15-93 (Adapted for RPC SSP)


Revision History:

--*/

#ifdef BLDR_KERNEL_RUNTIME
#include <bootdefs.h>
#endif

#include <descrypt.h>
#include <ntlmsspi.h>
#include <crypt.h>

#include <string.h>

//
// Define the user session key that represents an error.
// This value will be generated by other parts of the system on failure.
// We will check for it in our query code and return an error if it's found.
//

USER_SESSION_KEY ErrorSessionKey = { 0, 0, 0, 0, 0, 0, 0, 0,
                                     0, 0, 0, 0, 0, 0, 0, 0
                                   };



BOOL
CalculateLmResponse(
    IN PLM_CHALLENGE LmChallenge,
    IN PLM_OWF_PASSWORD LmOwfPassword,
    OUT PLM_RESPONSE LmResponse
    )

/*++

Routine Description:

    Takes the challenge sent by the server and the OwfPassword generated
    from the password the user entered and calculates the response to
    return to the server.

Arguments:

    LmChallenge - The challenge sent by the server

    LmOwfPassword - The hashed password.

    LmResponse - The response is returned here.


Return Values:

    TRUE - The function completed successfully. The response
                     is in LmResponse.

    FALSE - Something failed. The LmResponse is undefined.
--*/

{
    BLOCK_KEY    Key;
    PCHAR       pKey, pData;

    // The first 2 keys we can get at by type-casting

    if (DES_ECB_LM(ENCR_KEY,
                   (char *)&(((PBLOCK_KEY)(LmOwfPassword->data))[0]),
                   (unsigned char *)LmChallenge,
                   (unsigned char *)&(LmResponse->data[0])
                   ) != CRYPT_OK) {
        return (FALSE);
    }

    if (DES_ECB_LM(ENCR_KEY,
                   (char *)&(((PBLOCK_KEY)(LmOwfPassword->data))[1]),
                   (unsigned char *)LmChallenge,
                   (unsigned char *)&(LmResponse->data[1])
                   ) != CRYPT_OK) {
        return (FALSE);
    }

    // To get the last key we must copy the remainder of the OwfPassword
    // and fill the rest of the key with 0s

    pKey = &(Key.data[0]);
    pData = (PCHAR)&(((PBLOCK_KEY)(LmOwfPassword->data))[2]);

    while (pData < (PCHAR)&(LmOwfPassword->data[2])) {
        *pKey++ = *pData++;
    }

    // Zero extend

    while (pKey < (PCHAR)&((&Key)[1])) {
        *pKey++ = 0;
    }

    // Use the 3rd key

    if (DES_ECB_LM(ENCR_KEY,
                   (const char *)&Key,
                   (unsigned char *)LmChallenge,
                   (unsigned char *)&(LmResponse->data[2])
                   ) != CRYPT_OK) {
        return (FALSE);
    }

    return(TRUE);
}



BOOL
CalculateNtResponse(
    IN PNT_CHALLENGE NtChallenge,
    IN PNT_OWF_PASSWORD NtOwfPassword,
    OUT PNT_RESPONSE NtResponse
    )

/*++

Routine Description:

    Calculates the NT challenge response. Currently just calls the
    LM function.

--*/

{
    return CalculateLmResponse(
               (PLM_CHALLENGE)NtChallenge,
               (PLM_OWF_PASSWORD)NtOwfPassword,
               (PLM_RESPONSE)NtResponse);
}


BOOL
CalculateUserSessionKeyLm(
    IN PLM_RESPONSE LmResponse,
    IN PLM_OWF_PASSWORD LmOwfPassword,
    OUT PUSER_SESSION_KEY UserSessionKey)

/*++

Routine Description:

    Takes the passed Response and OwfPassword and generates a UserSessionKey.

    The current implementation takes the one-way-function of the OwfPassword
    and returns this as the key.

Arguments:

    LmResponse - The response sent during session setup.

    LmOwfPassword - The hashed version of the user's password.

Return Values:

    STATUS_SUCCESS - The function was completed successfully.
                     The UserSessionKey is in UserSessionKey.

    STATUS_UNSUCCESSFUL - Something failed. The UserSessionKey is undefined.
--*/

{
    BOOL Status;
    NT_PASSWORD NtPassword;

    //
    // Make the Owf password look like an NT password
    //

    NtPassword.Buffer = (PWSTR)LmOwfPassword; // We can do this cast because we
                                              // know the OWF routine treats this
                                              // pointer as a byte pointer.
    NtPassword.Length = sizeof(*LmOwfPassword);
    NtPassword.MaximumLength = sizeof(*LmOwfPassword);


    //
    // Calculate the OWF of the OwfPassword
    //

    Status = CalculateNtOwfPassword( &NtPassword,
                                     (PNT_OWF_PASSWORD)UserSessionKey
                                     );
    if (!Status) {
        return(Status);
    }

    //
    // Check if we've generated the error session key
    //

    if (!_fmemcmp(UserSessionKey, &ErrorSessionKey, sizeof(*UserSessionKey))) {

        //
        // Move away from the error session key
        //

        UserSessionKey->data[0].data[0] ++;

    }

    return(TRUE);

    UNREFERENCED_PARAMETER(LmResponse);
}



BOOL
CalculateUserSessionKeyNt(
    IN PNT_RESPONSE NtResponse,
    IN PNT_OWF_PASSWORD NtOwfPassword,
    OUT PUSER_SESSION_KEY UserSessionKey)

/*++

Routine Description:

    Takes the passed Response and OwfPassword and generates a UserSessionKey.

Arguments:

    NtResponse - The response sent during session setup.

    NtOwfPassword - The hashed version of the user's password.

Return Values:

    STATUS_SUCCESS - The function was completed successfully.
                     The UserSessionKey is in UserSessionKey.

    STATUS_UNSUCCESSFUL - Something failed. The UserSessionKey is undefined.
--*/

{
    // Just call the LM version

    return(CalculateUserSessionKeyLm((PLM_RESPONSE)NtResponse,
                                     (PLM_OWF_PASSWORD)NtOwfPassword,
                                     UserSessionKey));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\uam\macsource\macssp\sspdebug.cpp ===
/*
 *  sspdebug.cpp
 *  MSUAM
 *
 *  Created by mconrad on Sun Sep 30 2001.
 *  Copyright (c) 2001 Microsoft Corp. All rights reserved.
 *
 */

#ifdef SSP_TARGET_CARBON
#include <Carbon/Carbon.h>
#endif

#include <bootdefs.h>
#include <ntlmsspi.h>
#include <ntlmsspv2.h>
#include <debug.h> //windows version
#include <sspdebug.h>

#if defined(SSP_DEBUG) && defined(SSP_TARGET_CARBON)

//
// Valid values of NegotiateFlags
//
typedef struct _NTLM_NEG_FLAGS {
    char* desc;
    ULONG flag;
} NTLM_NEG_FLAGS;

NTLM_NEG_FLAGS g_flagTable[] = {
//
// Valid values of NegotiateFlags
//
    {"NTLMSSP_NEGOTIATE_UNICODE",                     0x00000001 },   // Text strings are in unicode
    {"NTLMSSP_NEGOTIATE_OEM",                         0x00000002 },   // Text strings are in OEM
    {"NTLMSSP_REQUEST_TARGET",                        0x00000004 },   // Server should return its authentication realm
    {"NTLMSSP_NEGOTIATE_SIGN",                        0x00000010 },   // Request signature capability
    {"NTLMSSP_NEGOTIATE_SEAL",                        0x00000020 },   // Request confidentiality
    {"NTLMSSP_NEGOTIATE_DATAGRAM",                    0x00000040 },   // Use datagram style authentication
    {"NTLMSSP_NEGOTIATE_LM_KEY",                      0x00000080 },   // Use LM session key for sign/seal
    {"NTLMSSP_NEGOTIATE_NETWARE",                     0x00000100 },   // NetWare authentication
    {"NTLMSSP_NEGOTIATE_NTLM",                        0x00000200 },   // NTLM authentication
    {"NTLMSSP_NEGOTIATE_NT_ONLY",                     0x00000400 },   // NT authentication only (no LM)
    {"NTLMSSP_NEGOTIATE_NULL_SESSION",                0x00000800 },   // NULL Sessions on NT 5.0 and beyand
    {"NTLMSSP_NEGOTIATE_OEM_DOMAIN_SUPPLIED",             0x1000 },   // Domain Name supplied on negotiate
    {"NTLMSSP_NEGOTIATE_OEM_WORKSTATION_SUPPLIED",        0x2000 },   // Workstation Name supplied on negotiate
    {"NTLMSSP_NEGOTIATE_LOCAL_CALL",                   0x00004000},   // Indicates client/server are same machine
    {"NTLMSSP_NEGOTIATE_ALWAYS_SIGN",                  0x00008000},   // Sign for all security levels


//
// Valid target types returned by the server in Negotiate Flags
//
    {"NTLMSSP_TARGET_TYPE_DOMAIN",                     0x00010000},   // TargetName is a domain name
    {"NTLMSSP_TARGET_TYPE_SERVER",                     0x00020000},   // TargetName is a server name
    {"NTLMSSP_TARGET_TYPE_SHARE",                      0x00040000},   // TargetName is a share name
    {"NTLMSSP_NEGOTIATE_NTLM2",                        0x00080000},   // NTLM2 authentication added for NT4-SP4

    {"NTLMSSP_NEGOTIATE_IDENTIFY",                     0x00100000},   // Create identify level token

//
// Valid requests for additional output buffers
//
    {"NTLMSSP_REQUEST_INIT_RESPONSE",                   0x00100000},   // get back session keys
    {"NTLMSSP_REQUEST_ACCEPT_RESPONSE",                 0x00200000},   // get back session key, LUID
    {"NTLMSSP_REQUEST_NON_NT_SESSION_KEY",              0x00400000},   // request non-nt session key
    {"NTLMSSP_NEGOTIATE_TARGET_INFO",                   0x00800000},   // target info present in challenge message

    {"NTLMSSP_NEGOTIATE_EXPORTED_CONTEXT",              0x01000000},   // It's an exported context

    {"NTLMSSP_NEGOTIATE_128",                           0x20000000},   // negotiate 128 bit encryption
    {"NTLMSSP_NEGOTIATE_KEY_EXCH",                      0x40000000},   // exchange a key using key exchange key
    {"NTLMSSP_NEGOTIATE_56",                            0x80000000},   // negotiate 56 bit encryption

//
// flags used in client space to control sign and seal; never appear on the wire
//
    {"NTLMSSP_APP_SEQ",                                     0x0040},   // Use application provided seq num
    };

char toChar(IN char c)
{
    if (c >= 0x20 && c <= 0x7E) {
        return c;
    }

    return '.';
}

void spaceIt(IN char* buf, IN ULONG len)
{
    ULONG i;

    for ( i = 0; i < len; i++) {
        buf[i] = ' ';
    }
}

char toHex(IN int c)
{
    if (c >= 0x0 && c <= 0x9) {
        return c + '0';
    }

    return c - 10 + 'a';
}

void _SspDebugPrintHex(IN const void *buffer, IN LONG len)
{
    unsigned char* p = (unsigned char*) buffer;
    int high = 0;
    int low = 0;
    char line[256] = {0};
    int i;

    if (!len) return;

    spaceIt(line, 72);

    for (i = 0; i < len; i++) {
        high = p[i] / 16;
        low = p[i] % 16;

        line[3 * (i % 16)] = toHex(high);
        line[3 * (i % 16) + 1] = toHex(low);
        line [52 + (i % 16)] = toChar(p[i]);

        if (i % 16 == 7  && i != (len - 1)) {
            line[3 * (i % 16) + 2] = '-';
        }

        if (i % 16 == 15) {

            printf(" %s\n", line);
            spaceIt(line, 72);
        }
    }

    printf(" %s\n", line);
}

void _SspDebugPrintString32(IN STRING32 str32, IN const void* base)
{
    // printf("%d(%d):", str32.Length, str32.MaximumLength);
    if (str32.Length <= 1024) {
        _SspDebugPrintHex((const char*)base + (ULONG)str32.Buffer, str32.Length);
    } else {
        printf(" Length %d, MaximumLenght %d ", str32.Length, str32.MaximumLength);
        printf(" <not initialized>\n");
    }
}

PCSTR g_attr_table[] = {
    "",
    "NetbiosServerName",
    "NetbiosDomainName",
    "DnsComputerName",
    "DnsDomainName",
    "DnsTreeName",
    "Flags",
    "", "", "", "", "", "",
};

void _SspDebugPrintString32TargetInfo(IN STRING32* pTargetInfo, IN const void* buffer)
{
    const char* start =  reinterpret_cast<const char*>(buffer) + pTargetInfo->Buffer;
    const char* p = NULL;
    USHORT attr = 0;
    USHORT len = 0;

    if (pTargetInfo->Length >= 1024) {

        printf("String32 TargetInfo too large\n");
        return;
    }

    _SspDebugPrintHex(start, pTargetInfo->Length);

    for (p = start; p < start + pTargetInfo->Length; p += (2 * sizeof(USHORT) + len)){
   
       attr = reinterpret_cast<USHORT*>(const_cast<char*>(p))[0];
       len = reinterpret_cast<USHORT*>(const_cast<char*>(p))[1];
    	
       if (attr >= MsvAvNbComputerName && attr <= MsvAvDnsTreeName) {

          printf("%s: ", g_attr_table[attr]);
          //debugNPrintfW(p + 2 * sizeof(USHORT), len);
          printf("\n");
       } else if (attr == MsvAvFlags) {

           printf("Flags: 0x%x\n", (unsigned int)*reinterpret_cast<ULONG*>(const_cast<char*>(p + 2 * sizeof(USHORT))) );
       } else if (attr == MsvAvEOL) {

           break;
       } else {

			printf("Unrecognized attribute %d\n", attr);
       }
    }
}

void _SspDebugPrintNegFlags(IN ULONG flags)
{
    unsigned int i;
    
    printf(" 0x%x\n", (unsigned int)flags);
    for (i = 0; i < sizeof(g_flagTable)/sizeof(*g_flagTable); i++) {
        if (g_flagTable[i].flag & flags) {
            flags &= ~g_flagTable[i].flag;
            printf("  + %s\n", g_flagTable[i].desc);
        }
    }

    if (flags) {
        printf("unrecognized flags: 0x%x\n", (unsigned int)flags);
    }
}

void _SspDebugPrintNTLMMsg(IN const void* buf, IN ULONG len)
{
    const char* buffer = reinterpret_cast<const char*>(buf);

    NTLM_MESSAGE_TYPE msgType;
    ULONG negFlags;
    NEGOTIATE_MESSAGE* pNeg = (NEGOTIATE_MESSAGE*) buffer;
    CHALLENGE_MESSAGE* pCha = (CHALLENGE_MESSAGE*) buffer;
    AUTHENTICATE_MESSAGE* pAut = (AUTHENTICATE_MESSAGE*) buffer;
    STRING32 scratch = {0};

    printf("buf %p, len %d\n", buf, (unsigned int)len);

    if (!buf) {

        printf("****Empty NTLM msg\n");
        return;
    }

    if (strcmp(buffer, "NTLMSSP"))
    {
        printf("****buffer corrupted!\n");
        return;
    }
       	
    printf("******************* Message Begin *********************\n");
    _SspDebugPrintHex(buffer,len);
    printf("******************* Message END ***********************\n");
    
    msgType = *((NTLM_MESSAGE_TYPE*) (buffer + strlen(buffer) + 1));

    switch (msgType) {
        case NtLmNegotiate:
            printf("Msg type: Negociate\n");
            printf("NegotiateFlags: ");
            _SspDebugPrintNegFlags(pNeg->NegotiateFlags);
            printf("OemDomainName: \n");
            _SspDebugPrintString32(pNeg->OemDomainName, buffer);
            printf("OemWorkstationName: \n");
            _SspDebugPrintString32(pNeg->OemWorkstationName, buffer);
            break;
        case NtLmChallenge:
            printf("Msg type: Challenge\n");
            printf("TargeName: \n");
            _SspDebugPrintString32(pCha->TargetName, buffer);
            printf("NegotiateFlags: ");
            _SspDebugPrintNegFlags(pCha->NegotiateFlags);
            printf("Chanllenge: \n");
            _SspDebugPrintHex(pCha->Challenge, MSV1_0_CHALLENGE_LENGTH);
            printf("ServerContextHandle (Lower Upper): \n");
            _SspDebugPrintHex(&pCha->ServerContextHandle, sizeof(pCha->ServerContextHandle));
            printf("TargetInfo: \n");
            _SspDebugPrintString32TargetInfo(&pCha->TargetInfo, buffer);
            break;
        case NtLmAuthenticate:
            printf("Msg type: Authenticate\n");
            
            memcpy(&scratch, &pAut->LmChallengeResponse, sizeof(scratch));
            SspSwapString32Bytes(&scratch);
            printf("LmChallengeResponse (length %d): \n", scratch.Length);
            _SspDebugPrintHex(buffer + (ULONG) scratch.Buffer, scratch.Length);
            
            memcpy(&scratch, &pAut->NtChallengeResponse, sizeof(scratch));
            SspSwapString32Bytes(&scratch);
            printf("NtChallengeResponse (length %d): \n", scratch.Length);
            _SspDebugPrintHex(buffer + (ULONG) scratch.Buffer, scratch.Length);
            
            printf("DomainName: \n");
            memcpy(&scratch, &pAut->DomainName, sizeof(scratch));
            SspSwapString32Bytes(&scratch);
            _SspDebugPrintString32(scratch, buffer);
            
            printf("UserName: \n");
            memcpy(&scratch, &pAut->UserName, sizeof(scratch));
            SspSwapString32Bytes(&scratch);
            _SspDebugPrintString32(scratch, buffer);
            
            printf("Workstation: \n");
            memcpy(&scratch, &pAut->Workstation, sizeof(scratch));
            SspSwapString32Bytes(&scratch);
            _SspDebugPrintString32(scratch, buffer);
            
            memcpy(&scratch, &pAut->SessionKey, sizeof(scratch));
            SspSwapString32Bytes(&scratch);
            printf("Sessionkey (length %d): \n", scratch.Length);
            _SspDebugPrintHex(buffer + (ULONG) scratch.Buffer, scratch.Length);
            
            printf("NegotiateFlags: ");
            negFlags = pAut->NegotiateFlags;
            swaplong(negFlags);
            _SspDebugPrintNegFlags(negFlags);
            break;
        case NtLmUnknown:
            printf("unknown msg.\n");
            break;
        default:
            printf("buffer corrupted.\n");
            break;
    }

    printf("******************** INTERP END ***********************\n");
}

#endif //SSP_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\uam\macsource\macssp\sspdebug.h ===
/*
 *  ssp_SspDebug.h
 *  MSUAM
 *
 *  Created by mconrad on Sun Sep 30 2001.
 *  Copyright (c) 2001 Microsoft Corp. All rights reserved.
 *
 */
 
#ifndef __SSPDEBUG__
#define __SSPDEBUG__

#ifdef SSP_TARGET_CARBON
#include <Carbon/Carbon.h>
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <macstrsafe.h>

#ifdef __cplusplus
extern "C" {
#endif

char toChar(IN char c);
void spaceIt(IN char* buf, IN ULONG len);
char toHex(IN int c);

void _SspDebugPrintHex(IN const void *buffer, IN LONG len);
void _SspDebugPrintString32(IN STRING32 str32, IN const void* base);
void _SspDebugPrintNegFlags(IN ULONG flags);
void _SspDebugPrintNTLMMsg(IN const void* buffer, IN ULONG len);
void _SspDebugPrintString32TargetInfo(IN STRING32* pTargetInfo, IN const void* buffer);

#ifdef __cplusplus
}
#endif

#ifdef SSP_DEBUG

#define DBUF	_buff,sizeof(_buff)

#ifdef SSP_TARGET_CARBON

#define SspDebugPrintHex				_SspDebugPrintHex
#define SspDebugPrintString32			_SspDebugPrintString32
#define SspDebugPrintNegFlags			_SspDebugPrintNegFlags
#define SspDebugPrintNTLMMsg			_SspDebugPrintNTLMMsg
#define SspDebugPrintString32TargetInfo	_SspDebugPrintString32TargetInfo

#define SspDebugPrint(x)	do {																	\
								char	_buff[256];													\
								StringCbPrintf x;															\
 								printf("%s%s", _buff, "\n");										\
							}while(false)
						
#else //NOT Carbon

//
//The following debug stuff doesn't work in non-carbon environment.
//
#define SspDebugPrintHex(a,b)
#define SspDebugPrintString32(a,b)
#define SspDebugPrintNegFlags(a)
#define SspDebugPrintNTLMMsg(a,b)
#define SspDebugPrintString32TargetInfo(a,b)

#define SspDebugPrint(x)	do {																	\
								char	_buff[256];													\
								StringCbPrintf x;															\
                                StringCbCat(_buff, sizeof(_buff), ";");													\
                                StringCbCat(_buff, sizeof(_buff), "g");													\
 								DebugStr(c2pstr(_buff));											\
							}while(false)
#endif //SSP_TARGET_CARBON

#else //no debug

#define SspDebugPrintHex(a,b)
#define SspDebugPrintString32(a,b)
#define SspDebugPrintNegFlags(a)
#define SspDebugPrintNTLMMsg(a,b)
#define SspDebugPrintString32TargetInfo(a,b)

#define SspDebugPrint(x)

#endif //SSP_DEBUG

#endif //__SSPDEBUG__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\uam\macsource\macssp\boot\alloc.c ===
#include <bootdefs.h>
#include <ntlmsspi.h>

#define USE_BlAllocateHeap 1

#ifndef MAC
extern    
ULONG
_cdecl
DbgPrint(
    PCH Format,
    ...
    );
#endif

VOID DbgBreakPoint(VOID);

#if USE_BlAllocateHeap

PVOID
BlAllocateHeap (
    ULONG Size
    );

PVOID
SspAlloc(
    int Size
    )
{
    #ifndef MAC
    return BlAllocateHeap( Size );
    #else
    return malloc( Size );
    #endif
}

void
SspFree(
    PVOID Buffer
    )
{
	#pragma unused(Buffer)
    //
    // Loader heap never frees.
    //
}

#else // USE_BlAllocateHeap

//
// Do a memory allocator out of a static buffer, because the Bl memory
// system gets reinitialized.
//

#define MEMORY_BUFFER_SIZE 2048
#define MEMORY_BLOCK_SIZE 8    // must be power of 2
#define MEMORY_BLOCK_MASK (((ULONG)-1) - (MEMORY_BLOCK_SIZE-1))

static UCHAR MemoryBuffer[MEMORY_BUFFER_SIZE];
static PUCHAR CurMemoryLoc = MemoryBuffer;

PVOID
SspAlloc(
    int Size
    )
{
    int RoundedUpSize = (Size + (MEMORY_BLOCK_SIZE-1)) & MEMORY_BLOCK_MASK;
    PVOID NewAlloc;

    if (((CurMemoryLoc + RoundedUpSize) - MemoryBuffer) > MEMORY_BUFFER_SIZE) {
        DbgPrint("!!! SspAlloc: Could not allocate %d bytes !!!\n", Size);
        return NULL;
    }

    NewAlloc = CurMemoryLoc;

    CurMemoryLoc += RoundedUpSize;
    
    return NewAlloc;
}

void
SspFree(
    PVOID Buffer
    )
{
    //
    // Should eventually really free things for reallocation!
    //
}

#endif // else USE_BlAllocateHeap
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\uam\macsource\macssp\boot\getuser.c ===
#ifndef MAC
#include <security.h>
#endif

#include <bootdefs.h>
#include <ntlmsspi.h>
#include <crypt.h>
#include <cred.h>

BOOL
SspGetWorkstation(
    PSSP_CREDENTIAL Credential
    );
    
BOOL
SspGetWorkstation(
    PSSP_CREDENTIAL Credential
    )
{
    //
    // We don't necessarily know this during boot. The NTLMSSP
    // package will use "none" if we return FALSE here.
    //

    return FALSE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\uam\macsource\macssp\boot\ticks.c ===
#ifdef SSP_TARGET_CARBON
#include <Carbon/Carbon.h>
#endif //SSP_TARGET_CARBON

#include <bootdefs.h>
#include <ntlmsspi.h>

DWORD
SspTicks(
    )
{
	#ifndef MAC
     // Seems good enough, it claims to be in seconds.
 	return ArcGetRelativeTime();
    #else
    return TickCount() / 60;
    #endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\uam\macsource\macssp\boot\cache.c ===
#ifndef MAC
#include <security.h>
#endif

#include <bootdefs.h>
#include <sspi.h>
#include <ntlmsspi.h>
#include <crypt.h>
#include <cred.h>
#include <winerror.h>
#include "cache.h"

#ifndef MAC
#include <rpc.h>
#endif

#define toupper(_c) ( ((_c) >= 'a' && (_c) <= 'z') ? ( (_c)-'a'+'A' ) : (_c) )

BOOL
SspGetWorkstation(
    PSSP_CREDENTIAL Credential
    );

static PSSP_CREDENTIAL Cache = NULL;

void
CacheInitializeCache(
    )
{
}

BOOL
CacheGetPassword(
    PSSP_CREDENTIAL Credential
    )
{
    if (Cache == NULL) {
        return (FALSE);
    }

#ifdef BL_USE_LM_PASSWORD
    Credential->LmPassword = SspAlloc (sizeof(LM_OWF_PASSWORD));
    if (Credential->LmPassword == NULL) {
        return (FALSE);
    }
#endif
    Credential->NtPassword = (LM_OWF_PASSWORD*)SspAlloc (sizeof(NT_OWF_PASSWORD));
    if (Credential->NtPassword == NULL) {
        return (FALSE);
    }
#ifdef BL_USE_LM_PASSWORD
    _fmemcpy((PCHAR)Credential->LmPassword, (PCHAR)Cache->LmPassword, sizeof(LM_OWF_PASSWORD));
#endif
    _fmemcpy((PCHAR)Credential->NtPassword, (PCHAR)Cache->NtPassword, sizeof(NT_OWF_PASSWORD));

    return (TRUE);
}

SECURITY_STATUS
CacheSetCredentials(
    IN PVOID        AuthData,
    PSSP_CREDENTIAL Credential
    )
{
    SEC_WINNT_AUTH_IDENTITY *Identity = (SEC_WINNT_AUTH_IDENTITY*)AuthData;
    char                     TmpText[CLEAR_BLOCK_LENGTH*2];
    NT_PASSWORD              TmpNtPassword;
    WCHAR                    TmpUnicodeText[CLEAR_BLOCK_LENGTH*2];
    int                      Length = 0;
    int                      i = 0;
    
    if (Identity->Domain == NULL)
        return SEC_E_UNKNOWN_CREDENTIALS;

    Credential->Username    = NULL;
    Credential->Domain      = NULL;
#ifdef BL_USE_LM_PASSWORD
    Credential->LmPassword  = NULL;
#endif
    Credential->NtPassword  = NULL;
    Credential->Workstation = NULL;

    // If no identity is passed and there is no cached identity, give up.
    if (AuthData == NULL)
    {
      if (Cache == NULL)
        return SEC_E_UNKNOWN_CREDENTIALS;
    }

    // Save the latest authentication information.
    else
    {

      // If an old cache entry exists, release its strings.
      if (Cache != NULL)
      {
        if (Cache->Username != NULL)
            SspFree(Cache->Username);
        if (Cache->Domain != NULL)
            SspFree(Cache->Domain);
        if (Cache->Workstation != NULL)
            SspFree(Cache->Workstation);
#ifdef BL_USE_LM_PASSWORD
        if (Cache->LmPassword != NULL)
            SspFree(Cache->LmPassword);
#endif
        if (Cache->NtPassword != NULL)
            SspFree(Cache->NtPassword);
      }

      // Otherwise, allocate a cache entry
      else
      {
        Cache = (PSSP_CREDENTIAL) SspAlloc (sizeof(SSP_CREDENTIAL));
        if (Cache == NULL) {
          return (SEC_E_INSUFFICIENT_MEMORY);
        }
      }

      Cache->Username    = NULL;
      Cache->Domain      = NULL;
#ifdef BL_USE_LM_PASSWORD
      Cache->LmPassword  = NULL;
#endif
      Cache->NtPassword  = NULL;
      Cache->Workstation = NULL;

      Cache->Username = (PCHAR)SspAlloc(_fstrlen((const char*)Identity->User) + 1);
      if (Cache->Username == NULL) {
          goto cache_failure;
      }
      _fstrcpy(Cache->Username, (const char*)Identity->User);

      Cache->Domain = (PCHAR)SspAlloc(_fstrlen((const char*)Identity->Domain) + 1);
      if (Cache->Domain == NULL) {
          goto cache_failure;
      }
      _fstrcpy(Cache->Domain, (const char*)Identity->Domain);

      // If netbios won't tell us the workstation name, make one up.
      if (!SspGetWorkstation(Cache))
      {
        Cache->Workstation = (PCHAR)SspAlloc(_fstrlen("none") + 1);
        if (Cache->Workstation == NULL) {
            goto cache_failure;
        }
        _fstrcpy(Cache->Workstation, "none");
      }

#ifdef BL_USE_LM_PASSWORD
      Cache->LmPassword = SspAlloc (sizeof(LM_OWF_PASSWORD));
      if (Cache->LmPassword == NULL) {
          goto cache_failure;
      }
#endif
 
      Cache->NtPassword = (LM_OWF_PASSWORD*)SspAlloc (sizeof(NT_OWF_PASSWORD));
      if (Cache->NtPassword == NULL) {
          goto cache_failure;
      }
 
#ifdef ALLOW_NON_OWF_PASSWORD
      if ( (Credential->CredentialUseFlags & SECPKG_CRED_OWF_PASSWORD) == 0 ) {

        if (Identity->Password == NULL)
          Length = 0;
        else
          Length = _fstrlen(Identity->Password);
        if (Length  > CLEAR_BLOCK_LENGTH * 2)
          goto cache_failure;

        // Allow NULL and "\0" passwords by prefilling TmpText with and
        // empty string.
        if (Length == 0)
          TmpText[0] = 0;
        else
          for (i = 0; i <= Length; i++) {
            TmpText[i] = toupper(Identity->Password[i]);
            TmpUnicodeText[i] = (WCHAR)(Identity->Password[i]);
          }

#ifdef BL_USE_LM_PASSWORD
        CalculateLmOwfPassword((PLM_PASSWORD)TmpText, Cache->LmPassword);
#endif

        TmpNtPassword.Buffer = TmpUnicodeText;
        TmpNtPassword.Length = Length * sizeof(WCHAR);
        TmpNtPassword.MaximumLength = sizeof(TmpUnicodeText);
        CalculateNtOwfPassword(&TmpNtPassword, Cache->NtPassword);

      } else
#endif
      {

        //
        // In this case the passed-in password is the LM and NT OWF
        // passwords concatenated together.
        //

#ifdef BL_USE_LM_PASSWORD
        _fmemcpy(Cache->LmPassword, Identity->Password, sizeof(LM_OWF_PASSWORD));
#endif
        _fmemcpy(Cache->NtPassword, Identity->Password + sizeof(LM_OWF_PASSWORD), sizeof(NT_OWF_PASSWORD));

      }

    }

    // Copy the credentials for the caller.
    Credential->Username = (PCHAR)SspAlloc(_fstrlen(Cache->Username) + 1);
    if (Credential->Username == NULL) {
        goto out_failure;
    }
    _fstrcpy(Credential->Username, Cache->Username);

    if (_fstrcmp(Cache->Domain, "WORKGROUP") != 0) {
        Credential->Domain = (PCHAR)SspAlloc(_fstrlen(Cache->Domain) + 1);
        if (Credential->Domain == NULL) {
            goto out_failure;
        }
        _fstrcpy(Credential->Domain, Cache->Domain);
    }

    Credential->Workstation = (PCHAR)SspAlloc(_fstrlen(Cache->Workstation) + 1);
    if (Credential->Workstation == NULL) {
        goto out_failure;
    }
    _fstrcpy(Credential->Workstation, Cache->Workstation);

#ifdef BL_USE_LM_PASSWORD
    Credential->LmPassword = SspAlloc(sizeof(LM_OWF_PASSWORD));
    if (Credential->LmPassword == NULL) {
        goto out_failure;
    }
    _fmemcpy(Credential->LmPassword, Cache->LmPassword, sizeof(LM_OWF_PASSWORD));
#endif

    Credential->NtPassword = (LM_OWF_PASSWORD*)SspAlloc(sizeof(NT_OWF_PASSWORD));
    if (Credential->NtPassword == NULL) {
        goto out_failure;
    }
    _fmemcpy(Credential->NtPassword, Cache->NtPassword, sizeof(NT_OWF_PASSWORD));

    return (SEC_E_OK);

cache_failure:

    if (Cache->Username != NULL) {
        SspFree(Cache->Username);
    }

    if (Cache->Domain != NULL) {
        SspFree(Cache->Domain);
    }

    if (Cache->Workstation != NULL) {
        SspFree(Cache->Workstation);
    }

#ifdef BL_USE_LM_PASSWORD
    if (Cache->LmPassword != NULL) {
        SspFree(Cache->LmPassword);
    }
#endif

    if (Cache->NtPassword != NULL) {
        SspFree(Cache->NtPassword);
    }

    SspFree(Cache);
    Cache = NULL;

out_failure:

    if (Credential->Username != NULL) {
        SspFree(Credential->Username);
        Credential->Username = NULL;
    }

    if (Credential->Domain != NULL) {
        SspFree(Credential->Domain);
        Credential->Domain = NULL;
    }

    if (Credential->Workstation != NULL) {
        SspFree(Credential->Workstation);
        Credential->Workstation = NULL;
    }

#ifdef BL_USE_LM_PASSWORD
    if (Credential->LmPassword != NULL) {
        SspFree(Credential->LmPassword);
        Credential->LmPassword = NULL;
    }
#endif

    if (Credential->NtPassword != NULL) {
        SspFree(Credential->NtPassword);
        Credential->NtPassword = NULL;
    }

    return (SEC_E_INSUFFICIENT_MEMORY);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\uam\macsource\macssp\project\sspdebugheadersmach.h ===
// ===========================================================================
//	SspDebugHeadersMach.h		   2001 Microsoft Corp. All rights reserved.
// ===========================================================================

#ifndef UAM_TARGET_CARBON
#include <MacHeadersMach-O.h>		// Precompiled header of Toolbox routines
#endif

#define __MACUAM__			//Needed for MWERKSCrypt.h in RSA32 lib.
#define SSP_TARGET_PPC
#define MAC_TARGET_CARBON
#define MAC

//
//This is needed so we can use the RSA32 headers and not conflict
//with typedefs in that library.
//
#define __MACSSP__

//
//This define will force the inclusion of several windows
//typdefs and functions not available on the mac.
//
#define BLDR_KERNEL_RUNTIME

//
//On what platform are we compiling the Ssp library for?
//
#define SECURITY_MAC

//
//Define the following when building on Carbon.
//
#define SSP_TARGET_CARBON


//***************************************************************
//The following enabled on debug builds only!
//***************************************************************

//
//Turn on the debugging code in the MacSsp library.
//
#define SSP_DEBUG

//
//Define the following to use constants so you can
//debug challenge/authenticate messages easily.
//
#define USE_CONSTANT_CHALLENGE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\uam\macsource\macssp\project\sspheaders68k.h ===
// ===========================================================================
//	SspHeaders68K.h		   2001 Microsoft Corp. All rights reserved.
// ===========================================================================

#include <MacHeaders.h>		// Precompiled header of Toolbox routines

#define __MACUAM__		1	//Needed for MWERKSCrypt.h in RSA32 lib.
#define SSP_TARGET_68K	1
#define MAC

//
//This is needed so we can use the RSA32 headers and not conflict
//with typedefs in that library.
//
#define __MACSSP__

//
//This define will force the inclusion of several windows
//typdefs and functions not available on the mac.
//
#define BLDR_KERNEL_RUNTIME

//
//On what platform are we compiling the Ssp library for?
//
#define SECURITY_MAC

//
//Define the following when building on Carbon.
//
#undef SSP_TARGET_CARBON


//***************************************************************
//The following enabled on debug builds only!
//***************************************************************

//
//Turn on the debugging code in the MacSsp library.
//
#undef SSP_DEBUG

//
//Define the following to use constants so you can
//debug challenge/authenticate messages easily.
//
#undef USE_CONSTANT_CHALLENGE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\uam\macsource\macssp\project\sspheadersmach.h ===
// ===========================================================================
//	SspHeadersMach.h		   2001 Microsoft Corp. All rights reserved.
// ===========================================================================

#ifndef UAM_TARGET_CARBON
#include <MacHeadersMach-O.h>		// Precompiled header of Toolbox routines
#endif

#define __MACUAM__			//Needed for MWERKSCrypt.h in RSA32 lib.
#define SSP_TARGET_PPC
#define MAC_TARGET_CARBON
#define MAC

//
//This is needed so we can use the RSA32 headers and not conflict
//with typedefs in that library.
//
#define __MACSSP__

//
//This define will force the inclusion of several windows
//typdefs and functions not available on the mac.
//
#define BLDR_KERNEL_RUNTIME

//
//On what platform are we compiling the Ssp library for?
//
#define SECURITY_MAC

//
//Define the following when building on Carbon.
//
#define SSP_TARGET_CARBON
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\uam\macsource\macssp\project\sspdebugheaders68k.h ===
// ===========================================================================
//	SspDebugHeaders68K.h		   2001 Microsoft Corp. All rights reserved.
// ===========================================================================

#include <MacHeaders.h>		// Precompiled header of Toolbox routines

#define __MACUAM__		1	//Needed for MWERKSCrypt.h in RSA32 lib.
#define SSP_TARGET_68K	1
#define MAC

//
//This is needed so we can use the RSA32 headers and not conflict
//with typedefs in that library.
//
#define __MACSSP__

//
//This define will force the inclusion of several windows
//typdefs and functions not available on the mac.
//
#define BLDR_KERNEL_RUNTIME

//
//On what platform are we compiling the Ssp library for?
//
#define SECURITY_MAC

//
//Define the following when building on Carbon.
//
#undef SSP_TARGET_CARBON


//***************************************************************
//The following enabled on debug builds only!
//***************************************************************

//
//Turn on the debugging code in the MacSsp library.
//
#define SSP_DEBUG

//
//Define the following to use constants so you can
//debug challenge/authenticate messages easily.
//
#undef USE_CONSTANT_CHALLENGE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\uam\macsource\macssp\project\sspheadersppc.h ===
// ===========================================================================
//	SspDebugHeadersPPC.h		   2001 Microsoft Corp. All rights reserved.
// ===========================================================================

#include <MacHeaders.h>		// Precompiled header of Toolbox routines

#define __MACUAM__		1	//Needed for MWERKSCrypt.h in RSA32 lib.
#define SSP_TARGET_PPC	1
#define MAC

//
//This is needed so we can use the RSA32 headers and not conflict
//with typedefs in that library.
//
#define __MACSSP__

//
//This define will force the inclusion of several windows
//typdefs and functions not available on the mac.
//
#define BLDR_KERNEL_RUNTIME

//
//On what platform are we compiling the Ssp library for?
//
#define SECURITY_MAC

//
//Define the following when building on Carbon.
//
#undef SSP_TARGET_CARBON


//***************************************************************
//The following enabled on debug builds only!
//***************************************************************

//
//Turn on the debugging code in the MacSsp library.
//
#undef SSP_DEBUG

//
//Define the following to use constants so you can
//debug challenge/authenticate messages easily.
//
#undef USE_CONSTANT_CHALLENGE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\uam\macsource\macssp\project\sspdebugheadersppc.h ===
// ===========================================================================
//	SspDebugHeadersPPC.h		   2001 Microsoft Corp. All rights reserved.
// ===========================================================================

#include <MacHeaders.h>		// Precompiled header of Toolbox routines

#define __MACUAM__		1	//Needed for MWERKSCrypt.h in RSA32 lib.
#define SSP_TARGET_PPC	1
#define MAC

//
//This is needed so we can use the RSA32 headers and not conflict
//with typedefs in that library.
//
#define __MACSSP__

//
//This define will force the inclusion of several windows
//typdefs and functions not available on the mac.
//
#define BLDR_KERNEL_RUNTIME

//
//On what platform are we compiling the Ssp library for?
//
#define SECURITY_MAC

//
//Define the following when building on Carbon.
//
#undef SSP_TARGET_CARBON


//***************************************************************
//The following enabled on debug builds only!
//***************************************************************

//
//Turn on the debugging code in the MacSsp library.
//
#define SSP_DEBUG

//
//Define the following to use constants so you can
//debug challenge/authenticate messages easily.
//
#define USE_CONSTANT_CHALLENGE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\uam\macsource\macwindefs\macstrsafe.h ===
// ===========================================================================
//	macstrsafe.h 			 2002 Microsoft Corp. All rights reserved.
// ===========================================================================
// 	Porting header for Windows strsafe.h
//
//	We also use this header to define some other security related routines
//	like RtlSecureZeroMemory().
//

#ifndef _MAC_STRSAFE_H_INCLUDE
#define _MAC_STRSAFE_H_INCLUDE
#pragma once

#ifndef MAC
#define MAC
#endif

//
//We need to include this here so that other files that use it
//won't fail with predefined errors.
//
#include "winerror.h"
#include "macwindefs.h"

//
//To implicitly support wide characters. Mac calls will always map
//to the "A" routines, this makes the unmodified strsafe.h compile
//though.
//
#ifndef MAC_TARGET_CARBON
#include <wchar.h>
#else
//
//In Carbon under OS X, we have to define all the wcsXXX routines.
//
#define wcslen(w)		0
#define getwc(c)		0
#endif

//
//These macros map to the correct vsXXXX function calls on Macintosh
//
#define _vsnprintf	vsnprintf

#ifndef MAC_TARGET_CARBON
#define _vsnwprintf	vswprintf
#else
#define _vsnwprintf(a,b,c,d)	vsnprintf((char*)a,b,(char*)c,d);
#endif

//
//This is the "real" strsafe.h from the Windows SDK.
//
#include <strsafe.h>

//
//The following actually exists in ntrtl.h on windows. It is a safe
//zero memory to be used when zeroing out password and auth data in memory.
//
inline PVOID RtlSecureZeroMemory(
	IN	PVOID	ptr,
	IN	size_t	cnt
	)
{
	volatile char *vptr = (volatile char*)ptr;
	
	while(cnt)
	{
		*vptr = 0;
		vptr++;
		cnt--;
	}
	
	return ptr;
}


#endif //_MAC_STRSAFE_H_INCLUDE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\uam\macsource\uamx\uamx_src\uamdlogutils.h ===
// ===========================================================================
//	UAMDLOGUtils.h 			 1997-2001 Microsoft Corp. All rights reserved.
// ===========================================================================

#pragma once

#include <Carbon/Carbon.h>

void UAM_MakeEditItemFocus(DialogRef inDialog, SInt16 inEditItem);
Rect UAM_GetDialogItemRect(DialogRef inDialog, SInt16 inItem);
void UAM_ToggleDialogControl(DialogRef inDialog, SInt16 inItem);
void UAM_GetDialogEditText(DialogRef inDialog, short item, Str255 theText);
void UAM_SetDialogEditText(DialogRef inDialog, short item, Str255 theText);
void UAM_HiliteDialogControlItem(DialogRef inDialog, SInt16 inItem, SInt16 inValue);
Boolean UAM_IsDialogControlActive(DialogRef inDialog, SInt16 inItem);
SInt16 UAM_GetDialogControlValue(DialogRef inDialog, SInt16 inItem);
void UAM_SetDialogControlValue(DialogRef inDialog, SInt16 inItem, SInt16 inValue);
pascal void UAM_FrameDialogItem(DialogRef inDialog, SInt16 i);
void UAM_SetupDialogUserItem(DialogRef inDialog, SInt16 inItem, UserItemUPP inUserProc, SInt16 inType);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\uam\macsource\uamx\clientuam.h ===
/*
	File:		ClientUAM.h

	Contains:	Public header file for writing UAM modules

	Version:	AppleShare X

	Copyright:	 2000 by Apple Computer, Inc., all rights reserved.

	Change History (most recent first):

	 <RASC2>	 2/25/00	law		more updates
		 <1>	  2/3/00	law		first checked in
*/

#ifndef __CLIENTUAM__
#define __CLIENTUAM__

#ifndef __CORESERVICES__
#include <CoreServices/CoreServices.h>
#endif


//#ifndef __EVENTS__
//#include <HIToolbox/Events.h>
//#endif




#if PRAGMA_ONCE
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

#if PRAGMA_IMPORT
#pragma import on
#endif

#if PRAGMA_STRUCT_ALIGN
	#pragma options align=mac68k
#elif PRAGMA_STRUCT_PACKPUSH
	#pragma pack(push, 2)
#elif PRAGMA_STRUCT_PACK
	#pragma pack(2)
#endif


/* Error values*/
enum {
	kUAMError		= -5002,			/* afpBadUAM*/
	kNotForUs		= -50				/* paramErr*/
};

/* UAM Class & Type values*/
enum {
	kUAMStdClass			= 0,			/* Standard UAM */
	kUAMVarClearClass		= 1,			/* variable length cleartext password*/
	kUAMVarCryptClass		= 2,			/* variable length encrypted password*/
	kUAMUserDefClass		= 3			/* Custom UAM*/
};

enum {
	kNoPasswd			= 1,			/* Class 0, No User Authentication (Guest)*/
	kCleartextPasswd		= 2,			/* Class 0, Cleartext password (8 byte password)*/
	kEncryptPasswd			= 3,			/* Class 0, RandnumExchange (8 byte password)*/
	kVarPasswd			= 4,			/* Class 1, variable length cleartext password*/
	kVarEncryptPasswd		= 5,			/* Class 2, variable length encrypted password*/
	kTwoWayEncryptPasswd		= 6,			/* Class 0, two way randnum exchange (8 byte password)*/
	kEncryptPasswdTransport		= 7			/* Class 0, Diffie Hellman password transport (64 byte pasword)*/
};

/* general constants*/
enum {
	kMaxAFPCommand			= 576,
	kStdPWdLength			= 8,
	kMaxPwdLength			= 64
};


/* UAM Commands	*/
enum {
	kUAMOpen				= 0,
	kUAMPWDlog				= 1,
	kUAMLogin				= 2,
	kUAMVSDlog				= 3,
	kUAMChgPassDlg				= 4,
	kUAMChgPass				= 5,
	kUAMGetInfoSize				= 6,
	kUAMGetInfo				= 7,
	kUAMClose				= 8
};



/* config bits*/
enum {
	kUsePWDlog	= 0,		/* The UAM wants to put up its own Password/PRAuth Dialog*/
	kUseVolDlog	= 1,		/* The UAM wants to put up its own Volume Selection Dialog*/
	kSupportsCP	= 2,		/* The UAM supports Changing the password*/
	kUseCPDlog	= 3,		/* The UAM wants to put up its own Change Password Dialog*/
	kUseUAMInfo	= 4		/* The UAM supports storing authentication info in UAMInfo*/
};

/* All other bits are reserved and must be set to 0 */


/* structs*/

struct AFPName {
    unsigned short fNameLen;		// length of the fNameData field in bytes
    unsigned char  fNameData[765];	// 255 unicode characters in utf-8
};
typedef struct AFPName	AFPName;


struct ClientInfo {
	short 			fInfoType;			/* the type of ClientInfo*/
	Str255 			fDefaultUserName;		/* a pointer to the Default User name*/
};
typedef struct ClientInfo	ClientInfo;
enum {
	kAFPClientInfo			= 0
};


struct AFPClientInfo {
	short 		fInfoType;			/* the type of ClientInfo (kAFPClientInfo)*/
	Str255 		fDefaultUserName;		/* a pointer to the Default User name*/
        AFPName		fUTF8UserName;			/* the utf-8 version of the username	*/
	short 		fConfigFlags;			/* the hi  short of the gestalt('afpt') response*/
	short 		fVersion;			/* the low short of the gestalt('afpt') response*/
	short 		fNumAFPVersions;		/* the number of afp versions supported by this client*/
	StringPtr *	fAFPVersionStrs;		/* an array of afp version strings supported by this client*/
};
typedef struct AFPClientInfo		AFPClientInfo;

/* Callbacks:*/

/*
   this Completion routine is called with the contextPtr passed in to
   the OpenAFPSession() and SendRequest() calls, when one of these calls
   completes. The result parameter contains the AFP result.
   You cannot call any of the callback routines from this Completion
   routine, so you can't do chained completion routines. This routine
   will be called just like any other completion routine or notifier
   so the usual rules apply.
*/

typedef CALLBACK_API( void , CompletionPtr )(void *contextPtr, OSStatus result);

/*	GetClientInfo()
	Returns information about the Client, such as which versions of AFP are
	supported and the various gestalt values. This call also returns the
	default user name. If the infoType is not avaliable it will return nil.

	pascal	OSStatus	GetClientInfo(short infoType,ClientInfo	**infoPtr);		
*/

struct UAMMessage {
	long 			commandCode;
	long 			sessionRefNum;
	OSStatus 		result;
	unsigned char *		cmdBuffer;
	unsigned long 		cmdBufferSize;
	unsigned char *		replyBuffer;
	unsigned long 		replyBufferSize;
	CompletionPtr 		completion;
	void *			contextPtr;
	UInt8 			scratch[80];	/* scratch space for the client*/
};
typedef struct UAMMessage	UAMMessage;
typedef UAMMessage *		UAMMessagePtr;

enum {
					/* commandCodes (for future expansion)*/
	kOpenSession				= FOUR_CHAR_CODE('UAOS'),
	kSendRequest				= FOUR_CHAR_CODE('UASR')
};

/*	OpenSession()
	Opens a session to the specified address. If you are using AFP, cmdBuffer MUST 
	contain an AFP Login command. If you are using AFP the command buffer size is limited
	to kMaxAFPCommand (576 bytes). Set endpointString to nil if default is desired 
	(TCP only, it is ignored for AppleTalk connections and on Mac OS X). 
	Leave completion & contextPtr nil for sync. Session reference number 
	is returned in the sessionRefNum field.


	pascal	OSStatus	OpenSession(struct sockaddr*, const char* endpointString, UAMMessagePtr);
*/
/* 	SendRequest()
	Sends a command to the server. If the session is an AFP session, cmdBuffer
	MUST contain an AFP command. If you are using AFP the command buffer size is limited
	to kMaxAFPCommand (576 bytes). Leave completion & contextPtr nil for sync.
	the Session reference number for this connection must be in the sessionRefNum field.
				
	pascal	OSStatus	SendRequest(UAMMessagePtr);
*/

/*	CloseSession()
	Closes the session denoted by the sessRefNum;

	pascal	OSStatus	CloseSession(short sessRefNum);
*/

/*	SetMic()
	Sets the message integrity code key. If the connection supports using 
	keyed HMAC-SHA1 for message integrity, the UAM may pass a key down
	to the network layer using this call. 

	pascal	OSStatus	SetMic(short sizeInBytes, Ptr micValue);
*/
/*	EventCallback()
	Call this fcn with any event that you do not handle in your FilterProc if you
	put up a dialog. This passes the event back to the client so that update & idle
	events are handled correctly. Returns true if the event was handled.

	pascal	Boolean		EventCallback(EventRecord *theEvent);
*/
#if TARGET_CPU_68K
typedef CALLBACK_API( OSStatus , OpenSessionPtr )(struct sockaddr* addr, const char *endpointString, UAMMessagePtr message);
typedef CALLBACK_API( OSStatus , SendRequestPtr )(UAMMessagePtr message);
typedef CALLBACK_API( OSStatus , CloseSessionPtr )(long sessRefNum);
typedef CALLBACK_API( OSStatus , GetClientInfoPtr )(short infoType, ClientInfo **info);
typedef CALLBACK_API( OSStatus , SetMicPtr )(short sizeInBytes, Ptr micValue);
typedef CALLBACK_API( Boolean , EventCallbackPtr )(EventRecord *theEvent);

#else
#ifdef UAM_TARGET_CARBON
typedef CALLBACK_API( OSStatus , OpenSessionPtr )(OTAddress* addr, const char *endpointString, UAMMessagePtr message);
typedef CALLBACK_API( OSStatus , SendRequestPtr )(UAMMessagePtr message);
typedef CALLBACK_API( OSStatus , CloseSessionPtr )(long sessRefNum);
typedef CALLBACK_API( OSStatus , GetClientInfoPtr )(short infoType, ClientInfo **info);
typedef CALLBACK_API( OSStatus , SetMicPtr )(short sizeInBytes, Ptr micValue);
typedef CALLBACK_API( Boolean , EventCallbackPtr )(EventRecord *theEvent);
#else
typedef UniversalProcPtr 				OpenSessionPtr;
typedef UniversalProcPtr 				SendRequestPtr;
typedef UniversalProcPtr 				CloseSessionPtr;
typedef UniversalProcPtr 				GetClientInfoPtr;
typedef UniversalProcPtr 				SetMicPtr;
typedef UniversalProcPtr 				EventCallbackPtr;
#endif
#endif  /* TARGET_CPU_68K */


struct ClientUAMCallbackRec {
	OpenSessionPtr 					OpenSessionUPP;
	SendRequestPtr 					SendRequestUPP;
	CloseSessionPtr 				CloseSessionUPP;
	GetClientInfoPtr 				GetClientInfoUPP;
	SetMicPtr 					SetMicUPP;
	EventCallbackPtr 				EventCallbackUPP;
};
typedef struct ClientUAMCallbackRec		ClientUAMCallbackRec;

struct VolListElem {
	UInt8 							volFlags;					/* volume flags*/
	Str32 							volName;
};
typedef struct VolListElem				VolListElem;
/* definitions for the volume flags*/
enum {
	kMountFlag		= 0,		/* bit indicating this volume is to be mounted (set by the UAM)*/
	kAlreadyMounted		= 1,		/* bit indicating that the volume is currently mounted*/
	kNoRights		= 2,		/* bit indicating that this user has no permission to use the volume*/
	kHasVolPw		= 7		/* bit indicating that the volume has a volume password*/
};


struct UAMOpenBlk {				/* called for UAMOpen & UAMPrOpen*/
	StringPtr 		objectName;	/* <-	server or printer name*/
	StringPtr 		zoneName;	/* <-	zone name or nil if no zone is present*/
	struct sockaddr*	srvrAddress;	/* <-	Address of the "server"	*/
	struct AFPSrvrInfo *	srvrInfo;	/* <-	for UAMOpen this is the GetStatus reply, for Printers ???*/
};
typedef struct UAMOpenBlk	UAMOpenBlk;

struct UAMPWDlogBlk {				/* for the password dialog and prAuthDlog*/
	StringPtr 		userName;		/* <->	pointer to a Str64 containing the user name*/
	unsigned char *		password;		/* <-	pointer to a Str64 containing the password*/
        AFPName*		utf8Name;		/* <->  pointer to an AFPName to containing the UTF-8 version of the user name */
        AFPName*		userDomain;		/* <->  pointer to an AFPName to containing the UTF-8 version of the directory to look up the user name in 	*/
};
typedef struct UAMPWDlogBlk	UAMPWDlogBlk;

struct UAMAuthBlk {				/* called for login and prAuthenticate*/
	StringPtr 		userName;		/* <-	pointer to a Str64 containing the user name*/
	unsigned char *		password;		/* <-	pointer to a 64 byte buffer containing the password*/
	struct sockaddr*	srvrAddress;		/* <-	Address of the "server"	*/
        AFPName*		utf8Name;		/* <->  pointer to an AFPName to containing the UTF-8 version of the user name */
        AFPName*		userDomain;		/* <->  pointer to an AFPName to containing the UTF-8 version of the directory to look up the user name in 	*/
};
typedef struct UAMAuthBlk	UAMAuthBlk;

struct UAMVSDlogBlk {				/* for the volume select dialog*/
	short 		numVolumes;		/* <-	number of volumes in the volume list*/
	VolListElem *	volumes;		/* <-	the volume list*/
};
typedef struct UAMVSDlogBlk	UAMVSDlogBlk;

struct UAMChgPassBlk {			/* for both the change password dialog and the change password call*/
	StringPtr 		userName;		/* <-	pointer to a Str64 containing the user name*/
	unsigned char *		oldPass;		/* <-	pointer to a 64 byte buffer containing the old password*/
	unsigned char *		newPass;		/* <-	pointer to a 64 byte buffer containing the new password*/
};
typedef struct UAMChgPassBlk	UAMChgPassBlk;

struct UAMArgs {
	short 			command;		/* <-	UAM command selector*/
	long 			sessionRefNum;		/* <->	session reference number (was short in old header) */
	long 			result;			/*  ->	command result*/
	void *			uamInfo;		/* <-	pointer to a block of Auth Data*/
	long 			uamInfoSize;		/* <->	size of the Auth Data*/
	ClientUAMCallbackRec *	callbacks;		/* <-	Callback record */
	union {
		UAMChgPassBlk 	chgPass;
		UAMVSDlogBlk 	vsDlog;
		UAMAuthBlk 	auth;
		UAMPWDlogBlk 	pwDlg;
		UAMOpenBlk 	open;
	} Opt;
};
typedef struct UAMArgs		UAMArgs;

EXTERN_API( OSStatus )
UAMCall				(UAMArgs * theArgs);


#if 0	// should be a conditional compile for non Mac OS X dev.
/* procinfos*/

enum {
	kOpenSessionProcInfo = kPascalStackBased	
			| RESULT_SIZE(SIZE_CODE(sizeof(OSStatus)))	
			| STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(OTAddress *)))		
			| STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(const char*)))		
			| STACK_ROUTINE_PARAMETER(3, SIZE_CODE(sizeof(UAMMessagePtr))),		
	
	kSendRequestProcInfo =  kPascalStackBased	
			| RESULT_SIZE(SIZE_CODE(sizeof(OSStatus)))	
			| STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(UAMMessagePtr))),		
	
	kCloseSessionProcInfo =  kPascalStackBased	
			| RESULT_SIZE(SIZE_CODE(sizeof(OSStatus)))	
			| STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(short))),				
	
	kGetClientInfoProcInfo =  kPascalStackBased	
			| RESULT_SIZE(SIZE_CODE(sizeof(OSStatus)))	
			| STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(short)))	
			| STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(ClientInfo **))),		
	
	kSetMicProcInfo =  kPascalStackBased	
			| RESULT_SIZE(SIZE_CODE(sizeof(OSStatus)))	
			| STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(short)))				
			| STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(Ptr))),				
	
	kEventCallbackProcInfo =  kPascalStackBased	
			| RESULT_SIZE(SIZE_CODE(sizeof(Boolean)))	
			| STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(EventRecord *))),		
	
	kUAMCallProcInfo =  kPascalStackBased
			| RESULT_SIZE(SIZE_CODE(sizeof(OSStatus)))	
			| STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(UAMArgs *)))			
};
#endif

#define	kUAMBundleType	CFSTR("uamx")	


/* Resouce definitions
*/
enum {
	kUAMName			= 0,	/* user visible name of the UAM*/
	kUAMProtoName			= 1,	/* protocol name of the UAM (sent to the server in the login cmd)*/
	kUAMDescription			= 2,	/* short description of the UAM (displayed in the dialog)*/
	kUAMHelpBalloon			= 3	/* Str255 for the Balloon Help item*/
};

enum {
	kUAMFileType	= FOUR_CHAR_CODE('uams')	/* Type of the UAM file*/
};

/* resource types*/
enum {
	kUAMStr		= FOUR_CHAR_CODE('uamn'),
	kUAMCode	= FOUR_CHAR_CODE('uamc'),
	kUAMConfig	= FOUR_CHAR_CODE('uamg')
};

/* 'uams' resource IDs	*/
enum {
	kUAMTitle		= 0,		/* UAM Title string (shown in the UAM list)*/
	kUAMProtocol		= 1,		/* UAM protocol name*/
	kUAMPWStr		= 2,		/* UAM description string (shown in the Password dialog)*/
	kUAMBallHelp		= 3		/* Balloon Help string for the Password dialog.*/
};


#if PRAGMA_STRUCT_ALIGN
	#pragma options align=reset
#elif PRAGMA_STRUCT_PACKPUSH
	#pragma pack(pop)
#elif PRAGMA_STRUCT_PACK
	#pragma pack()
#endif

#ifdef PRAGMA_IMPORT_OFF
#pragma import off
#elif PRAGMA_IMPORT
#pragma import reset
#endif

#ifdef __cplusplus
}
#endif

#endif /* __CLIENTUAM__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\uam\macsource\uamx\uamx_src\uamdlogutils.cpp ===
// ===========================================================================
//	UAMDLOGUtils.c 			 1997-2001 Microsoft Corp. All rights reserved.
// ===========================================================================
// General dialog utilities used by the Microsoft User Authentication Method.
//
// ===========================================================================

#include <Carbon/Carbon.h>

#include <ctype.h>

#include "UAMUtils.h"
#include "UAMDLOGUtils.h"
#include "UAMDebug.h"

// ---------------------------------------------------------------------------
//		 UAM_MakeEditItemFocus()
// ---------------------------------------------------------------------------

void UAM_MakeEditItemFocus(DialogRef inDialog, SInt16 inEditItem)
{
    OSErr		theError;
    ControlRef	theControl = NULL;
    
    theError = GetDialogItemAsControl(inDialog, inEditItem, &theControl);
    
    if (theError == noErr)
    {
        SetKeyboardFocus(GetDialogWindow(inDialog), theControl, kControlEditTextPart);
    }
}


// ---------------------------------------------------------------------------
//		 UAM_GetDialogItemRect()
// ---------------------------------------------------------------------------

Rect UAM_GetDialogItemRect(DialogRef inDialog, SInt16 inItem)
{
	SInt16	itype;
	Rect	irect;
	Handle	ihan;
	
	GetDialogItem(inDialog, inItem, &itype, &ihan, &irect);
	return(irect);
}


// ---------------------------------------------------------------------------
//		 UAM_ToggleControl()
// ---------------------------------------------------------------------------

void UAM_ToggleDialogControl(DialogRef inDialog, SInt16 inItem)
{
    OSErr		theError;
    ControlRef	theControl	= NULL;
    
    theError = GetDialogItemAsControl(inDialog, inItem, &theControl);
    
    if (theError == noErr)
    {
        SetControlValue(
                theControl,
                (SInt16)GetControlValue(theControl) == 0);
    }
}


// ---------------------------------------------------------------------------
//		 UAM_GetDialogEditText()
// ---------------------------------------------------------------------------

void UAM_GetDialogEditText(DialogRef inDialog, short item, Str255 theText)
{
    OSErr		theError;
    Size		theActualLength;
    ControlRef	theControl	= NULL;
    
    theError = GetDialogItemAsControl(inDialog, item, &theControl);
    
    if (theError == noErr)
    {
        GetControlData(
                theControl,
                kControlNoPart,
                kControlEditTextTextTag,
                sizeof(Str255),
                (char*)&theText[1],
                &theActualLength);
                
        theText[0] = (UInt8)theActualLength;
    }
}


// ---------------------------------------------------------------------------
//		 UAM_SetDialogEditText()
// ---------------------------------------------------------------------------

void UAM_SetDialogEditText(DialogRef inDialog, short item, Str255 theText)
{
    OSErr		theError;
    ControlRef	theControl = NULL;
    
    theError = GetDialogItemAsControl(inDialog, item, &theControl);
    
    if (theError == noErr)
    {
        SetControlData(
                theControl,
                kControlEditTextPart,
                kControlStaticTextTextTag,
                theText[0],
                (void*)&theText[1]);
    }
}


// ---------------------------------------------------------------------------
//		 UAM_HiliteDialogControlItem()
// ---------------------------------------------------------------------------

void UAM_HiliteDialogControlItem(DialogRef inDialog, SInt16 inItem, SInt16 inValue)
{
    OSErr		theError;
    ControlRef	theControl = NULL;
    
    theError = GetDialogItemAsControl(inDialog, inItem, &theControl);
    
    if (theError == noErr)
    {
        HiliteControl(theControl, inValue);
    }
}


// ---------------------------------------------------------------------------
//		 UAM_IsDialogControlActive()
// ---------------------------------------------------------------------------

Boolean UAM_IsDialogControlActive(DialogRef inDialog, SInt16 inItem)
{
    OSErr		theError;
    ControlRef	theControl = NULL;
    
    theError = GetDialogItemAsControl(inDialog, inItem, &theControl);
    
    if (theError == noErr)
    {
        return(IsControlActive(theControl));
    }
    
    return(FALSE);
}


// ---------------------------------------------------------------------------
//		 UAM_GetDialogControlValue()
// ---------------------------------------------------------------------------

SInt16 UAM_GetDialogControlValue(DialogRef inDialog, SInt16 inItem)
{
    OSErr		theError;
    ControlRef	theControl = NULL;
    
    theError = GetDialogItemAsControl(inDialog, inItem, &theControl);
    
    if (theError == noErr)
    {
        return(GetControlValue(theControl));
    }

	return(0);
}


// ---------------------------------------------------------------------------
//		 UAM_SetDialogControlValue()
// ---------------------------------------------------------------------------

void UAM_SetDialogControlValue(DialogRef inDialog, SInt16 inItem, SInt16 inValue)
{
    OSErr		theError;
    ControlRef	theControl = NULL;
    
    theError = GetDialogItemAsControl(inDialog, inItem, &theControl);
    
    if (theError == noErr)
    {
       SetControlValue(theControl, inValue);
    }
}


// ---------------------------------------------------------------------------
//		 UAM_FrameDialogItem()
// ---------------------------------------------------------------------------

pascal void UAM_FrameDialogItem(DialogRef inDialog, SInt16 inItem)
{
	GrafPtr	savePort;
	Rect	r;
	
	GetPort(&savePort);
	SetPortDialogPort(inDialog);
	
	r = UAM_GetDialogItemRect(inDialog, inItem);
	if ((r.bottom - r.top <= 1) || (r.right - r.left <= 1))
	{
		if (r.bottom - r.top <= 1) {
			MoveTo(r.left, r.top);
			LineTo(r.right, r.top);
		} else {
			MoveTo(r.left, r.top);
			LineTo(r.left, r.bottom);
		}
	}
	else
		FrameRect(&r);
	
	SetPort(savePort);
}


// ---------------------------------------------------------------------------
//		 UAM_SetupDialogUserItem()
// ---------------------------------------------------------------------------

void UAM_SetupDialogUserItem(DialogRef inDialog, SInt16 inItem, UserItemUPP inUserProc, SInt16 inType)
{
	short	itype;
	Handle	ihan;
	Rect	irect;
	
	GetDialogItem(inDialog, inItem, &itype, &ihan, &irect);
	SetDialogItem(inDialog, inItem, inType, (Handle)inUserProc, &irect);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\uam\macsource\macwindefs\macwindefs.h ===
// ===========================================================================
//	macwindefs.h 			 2002 Microsoft Corp. All rights reserved.
// ===========================================================================
// 	Aid for porting windows functions/files to compile on the Mac.
//

#ifndef _MAC_MACWINDEFS_H_INCLUDE_
#define _MAC_MACWINDEFS_H_INCLUDE_

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#ifndef MAC
#define MAC
#endif

#define _MAC                1

#ifdef __POWERPC__
#define MPPC                1
#endif  // __POWERPC__

// Calling convention defaults to MetroWerks Standard

#ifndef RSA32API
#define RSA32API
#endif
#define NTSYSAPI
#define NTAPI
#define __cdecl
#define __loadds
#define __stdcall
#define __far
#define __pascal
#define __int64 long long

// Common Windows types

#define HANDLE  void*
#define FAR
#define IN
#define OUT
#define UNALIGNED
#define OPTIONAL
#define FARPROC void*
#define SEC_FAR
#define FAR

#ifndef CONST
#ifdef __cplusplus
#define CONST   const
#else   // !__cplusplus	
#define CONST
#endif  // __cplusplus
#endif //CONST

#define HEAP_ZERO_MEMORY    0x00000001
#ifndef TRUE
#define TRUE                1
#define FALSE               0
#endif  // TRUE

#ifndef NULL
#define NULL (0)
#endif //NULL

#define UNICODE_NULL	((WCHAR)0)
#define TEXT(x)			x
#define UNALIGNED

#define _fstrcmp strcmp
#define _fstrcpy strcpy
#define _fstrlen strlen
#define _fstrncmp strncmp
#define _fmemcpy memcpy
#define _fmemset memset
#define _fmemcmp memcmp

#define MoveMemory                  memmove
#define CopyMemory                  memcpy
#define ZeroMemory(_pb, _cb)        memset(_pb, 0, _cb)
#define FillMemory(_pb, _cb, _val)  memset(_pb, _val, _cb)

#define MAXUSHORT		(0xffff)
#define MAXLONGLONG		(0x7fffffffffffffff)

#define POINTER_32
#define FIRMWARE_PTR POINTER_32

#ifndef lstrlenA
#define lstrlenA                    strlen
#endif

#ifndef lstrcat
#define lstrcat                     strcat
#endif

#ifndef wvsprintfA
#define wvsprintfA                  vsprintf
#endif

typedef long NTSTATUS;

#ifndef NT_SUCCESS
#define NT_SUCCESS(Status) ((NTSTATUS)(Status) >= 0)
#endif //NT_SUCCESS

//
// C_ASSERT() can be used to perform many compile-time assertions:
//            type sizes, field offsets, etc.
//
// An assertion failure results in error C2118: negative subscript.
//

#define C_ASSERT(e) typedef char __C_ASSERT__[(e)?1:-1]

#define ALIGN_WCHAR             sizeof(WCHAR)


// BOOL
// COUNT_IS_ALIGNED(
//     IN DWORD Count,
//     IN DWORD Pow2      // undefined if this isn't a power of 2.
//     );
//

#define COUNT_IS_ALIGNED(Count,Pow2) \
        ( ( ( (Count) & (((Pow2)-1)) ) == 0) ? TRUE : FALSE )


//============================================================================
// Standard Windows Type Defs
//============================================================================

typedef unsigned char BOOL;
typedef char CHAR;
typedef const char *PCSZ;
typedef unsigned char UCHAR, BYTE, *PBYTE, *LPBYTE;
typedef short SHORT;
typedef unsigned short USHORT, WORD;
typedef long LONG, *PLONG, *LPLONG;
typedef unsigned long ULONG;
typedef unsigned long DWORD, *LPDWORD;
typedef unsigned short WCHAR;
typedef void *PVOID, *LPVOID;
typedef void VOID;
typedef PVOID PSID;
typedef LONG HRESULT;
typedef UCHAR BOOLEAN;
typedef BOOLEAN *PBOOLEAN;
typedef WCHAR *PWCHAR;
typedef WCHAR *LPWCH, *PWCH;
typedef CONST WCHAR *LPCWCH, *PCWCH;
typedef WCHAR *NWPSTR;
typedef WCHAR *LPWSTR, *PWSTR;

typedef CONST WCHAR *LPCWSTR, *PCWSTR;
typedef CHAR *PCHAR;
typedef CHAR *LPCH, *PCH;
typedef CONST CHAR *LPCCH, *PCCH;
typedef CHAR *NPSTR;
typedef CHAR *LPSTR, *PSTR;
typedef CONST CHAR *LPCSTR, *PCSTR;

typedef UCHAR *PUCHAR;
typedef USHORT *PUSHORT;
typedef ULONG *PULONG;
typedef unsigned long ULONG_PTR, *PULONG_PTR;

typedef int INT;
typedef unsigned __int64 DWORDLONG, *LPDWORDLONG;
typedef unsigned __int64 ULONGLONG, ULONG64, PULONG64, *LPULONGLONG;
typedef __int64 LONGLONG, *LPLONGLONG;


typedef struct _LUID {
    ULONG LowPart;
    LONG HighPart;
} LUID, *PLUID;

typedef union _LARGE_INTEGER { 
    struct {
        LONG  HighPart; 
        DWORD LowPart; 
    }u;
    LONGLONG QuadPart;
} LARGE_INTEGER; 

typedef union _ULARGE_INTEGER {
    struct {
        ULONG LowPart;
        ULONG HighPart;
    }u;
    ULONGLONG QuadPart;
} ULARGE_INTEGER, *PULARGE_INTEGER;

typedef struct _STRING32
{
	USHORT	Length;
	USHORT	MaximumLength;
	ULONG	Buffer;
}STRING32;
typedef STRING32 *PSTRING32;

typedef struct _STRING
{
	USHORT	Length;
	USHORT	MaximumLength;
	PCHAR	Buffer;
}STRING, *PSTRING;

typedef STRING ANSI_STRING, *PANSI_STRING;
typedef PSTRING PCANSI_STRING;

#ifndef _FILETIME_
#define _FILETIME_
typedef struct _FILETIME {
    DWORD dwLowDateTime;
    DWORD dwHighDateTime;
} FILETIME, *PFILETIME;
#endif // _FILETIME_

typedef struct _MAC_FILETIME {
	DWORD dwHighDateTime;
	DWORD dwLowDateTime;
}MACFILETIME, *PMACFILETIME;
















#endif _MAC_MACWINDEFS_H_INCLUDE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\uam\macsource\uamx\uamx_src\uamx_dbgheaders.h ===
// ===========================================================================
//	UAM_DebugHeaders.h		   1998 Microsoft Corp. All rights reserved.
// ===========================================================================


#include <MacHeadersMach-O.h>

#define UAM_TARGET_CARBON
#define UAM_TARGET_PPC

//
//This tells everything to build as debug.
//
#define UAMDebug

//
//These are needed because we include the MacSSP headers.
//
#include <SspDebugHeadersMach.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\sfm\uam\macsource\uamx\uamx_src\uammain.cpp ===
// ===========================================================================
//	UAMMain.cp 	 1997-2001 Microsoft Corp. All rights reserved.
// ===========================================================================
//	Main unit for Microsoft User Authentication Method.
//
//	Notes:
//	--------------------------------------------------------------------------
//
// 	Version History:
// 	===========================================================================
//	Version 5.0.8:
//	04.26.01	MJC	- Code cleanup. Combined UAMNetwork and UAMDSNetwork into
//					  one file (UAMNetwork.c & UAMNetwork.h)
//					- UAM_ChangePasswordV2(): Now check for zero length old
//					  and new passwords before upper casing.
//					- Now use common LM hash code for login and changepassword v2.
//					- Zero password buffers when done with them (security fix).
//					- Now clear password field when login error occurs.
//	05.01.01		- Fixed bug where over-long user names could be pasted
//					  into username field.
//					- Can now tab out of user name field when name is max length.
//					- Now clear password when failure occurs in UAM_LoginMSUAM().
//	07.02.01		- Fixed bug where password was being cleared in UAM_LoginContinue()
//					  before I saved it to the keychain.
//	10.18.01		- Completed MacOS X v1.0 UAM.
//					- Support added for NTLMv2 auth and change password.
//  Version 1.0.1:
//	01.21.02		- Fix: Keychain passwords couldn't exceed 8 bytes.
//					- Fix: Close session after attempted login w/bad password.
//					- Fix: Now conform to Apple's Aqua UI guidelines.
//					- Now check buffer length for all string copies.
//	Version 1.0.2:
//	02.18.02		- User can now choose to allow only strong authentication.
//					- Added preference file support for above change.
//					- Finally moved OSX builds to CodeWarrior!
//	03.01.02		- Many changes for security push
//
//	Version 1.0.3:
//	05.31.02		- Fixed bug where we weren't dealing with all the new
//					  AFP URL type (eg. afp://username:password@server/share).
// ===========================================================================

#include "UAMMain.h"
#include "UAMDebug.h"
#include "UAMUtils.h"
#include "UAMDialogs.h"
#include "UAMNetwork.h"
#include "UAMDLOGUtils.h"
#include "UAMKeychain.h"
#include "UAMPswdField.h"
#include "UAMPrefs.h"

//
//Global variables are declared here
//
Str32				gServerName;
Str64				gUserName;
Boolean				gContextInited;
Boolean				gGuestLogon;
Boolean				gSupportsChngPwd;
DialogPtr			gDialog;
Str32				gAFPVersion;
long				gSupportedUAMs;
ModalFilterUPP		gPwdDialogFilter;
UserItemUPP			gLineItem;
Str32				gUAMVersionString;
Str32				gZoneName;
UInt32				gExpirationTime		= 0;
struct sockaddr*	gServerAddress 		= NULL;
EventCallbackPtr	gEventCallbackUPP 	= NULL;
Boolean				gTriedKeychain		= false;

extern UAM_PREFERENCES	gUAMPreferences;

#pragma export on

// ---------------------------------------------------------------------------
//		 main()
// ---------------------------------------------------------------------------
//	This is the main entry point for our UAM. This function is passed a
//	pointer to a UAMArgs struct. This struct contains the function selector,
//	call-backs, and many other things we need to do our stuff.

EXTERN_API( OSStatus ) UAMMain(UAMArgs *inUAMArgs)
{
    OSStatus theResult = noErr;
            
    switch(inUAMArgs->command)
    {
        case kUAMOpen:
            theResult = MS_UAMOpen(inUAMArgs);
            break;
                
        case kUAMClose:
            MS_UAMClose();
            break;
                
        case kUAMPWDlog:
            theResult = MS_UAMPwdDialog(inUAMArgs);
            break;
                
        case kUAMLogin:
            theResult = UAM_UAMLogin(inUAMArgs);
            break;
                
        case kUAMVSDlog:
            break;
        
        case kUAMChgPass:
        case k